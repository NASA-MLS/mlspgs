head	1.6;
access;
symbols
	v5-02-NRT-19:1.6
	v6-00:1.6
	v5-02-NRT-18:1.6
	v5-02:1.6
	v5-01-NRT-17:1.6
	v5-01-NRT-16:1.6
	v5-01-NRT-15:1.6
	v5-01-NRT-14:1.6
	neuralnetworks-1-0:1.6.0.12
	cfm-single-freq-0-1:1.6.0.10
	v5-01:1.6
	v5-00:1.6
	v4-23-TA133:1.6.0.8
	mus-emls-1-70:1.6.0.6
	rel-1-0-englocks-work:1.6.0.4
	VUMLS1-00:1.6
	VPL1-00:1.6
	V4-22-NRT-08:1.6
	VAM1-00:1.6
	V4-21:1.6.0.2
	V4-13:1.6
	V4-12:1.6
	V4-11:1.6
	V4-10:1.6
	V3-43:1.4
	M4-00:1.6
	V3-41:1.4
	V3-40-PlusGM57:1.4.0.2
	V2-24-NRT-04:1.4
	V3-33:1.4
	V2-24:1.4
	V3-31:1.4
	V3-30-NRT-05:1.4
	cfm-01-00:1.4
	V3-30:1.4
	V3-20:1.4
	V3-10:1.4
	V2-23-NRT-02:1.4
	V2-23:1.4
	V2-22-NRT-01:1.4
	V2-22:1.4
	V2-21:1.4
	V2-20:1.4
	V2-11:1.4
	V2-10:1.4
	V2-00:1.4
	V1-51:1.2
	V1-50:1.2
	V1-45:1.2
	V1-44:1.2
	V1-43:1.2
	V1-42:1.2
	V1-41:1.2
	V1-32:1.2
	V1-40:1.2
	V1-31:1.2
	V1-30:1.2
	V1-13:1.2
	V1-12:1.2
	V1-11:1.2
	V1-10:1.2
	newfwm-feb03:1.2.0.4
	V1-04:1.2
	V1-03:1.2
	V1-02:1.2
	V1-00:1.2
	newfwm-sep01:1.2.0.2
	V0-7:1.2;
locks; strict;
comment	@ * @;


1.6
date	2011.09.02.15.28.57;	author hcp;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.02.15.22.15;	author hcp;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.07.08.26.52;	author hcp;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.25.09.47.56;	author hcp;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.27.16.54.01;	author pumphrey;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.15.14.29.34;	author pumphrey;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Lazy fix for filenames > 80 chars. Should do it properly at some point.
@
text
@/* This file contains a program to extract some of the datasets in an
 * HDF5 file and put them into another HDF5 file. This can be useful
 * if you have a file containing many datasets and you only want one
 * or two, particularly if you want to transport the file across a
 * slow link, fit it on a small hard disc, read it into a program that
 * barfs on large files and can't do the subsetting itself (e.g. R) etc. etc. 

 * Compile it like this:
   cc -g -o h5subset h5subset.c -lhdf5 
   (You may need  -DH5_USE_16_API with HDF5-1.8, depends how the lib was built)
 * and run it like this:
   ./h5subset infile outfile varfoo,varbar,varbaz........

 * .....to extract variables varfoo,varbar,varbaz from infile and put them
 * in outfile 

 * varfoo,varbar etc can be groups as well as datasets. 
 
 *  Copyright (c) © H. C. Pumphrey 2001 */



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <hdf5.h>
#include <unistd.h> /* required for use of getopt() */

/* Global as I can't be arsed to pass them to the iterator */
/* hid_t outfile_id; */
char **global_varlist;
char **global_grouplist;
int n_vars,n_groups;
int global_nattrs, global_attrcnt,verbose;

/* Function prototype for operator (function is later on in this file) */
herr_t operator(hid_t group_id, const char *member_name, void
		       *operator_data);
/* Function prototype for attribute operator (function is later on in
   this file) */
herr_t attr_op(hid_t loc_id, const char *attribute_name, void
		       *operator_data);

typedef struct opdat_t{
  int getall;
  hid_t newloc_id;
}opdat_t;

/*-----Main---------Main---------Main---------Main---------Main-------*/
int main(int argc , char *argv[] ){

  /*--------Local vars--------------------------*/
  char infile[160], outfile[160];
  hid_t file_id,outfile_id;
  int error, *idx,*aidx, stringlen, i;
  char rootname[160];
  char *varstring, *dummy,*groupstring;
  char *invarstring,*ingroupstring;
  
  /*void *operator_data;*/
  void *aopdata;
  opdat_t opdat; 
  hid_t rg_id,nrg_id,*nrg_idp;
  /* Stuff for getopt */
  char optstring[]="vd:g:a:";
  int optval;
  char optvalc;
  unsigned majnum, minnum,relnum;
  extern char *optarg;
  extern int optind,opterr,optopt;

  /* end of getopt vars */
 
  /*------------------Executable----------------------------*/
  strcpy(rootname,"/\0");
  if (argc < 3){
    printf("Usage: h5subset -a nattr -d dsets -g groups <infile> <outfile>\n");
    printf("where dsets is a comma separated list of datasets to copy\n"); 
    printf("groups is a comma-sep. list of groups to copy all of \n");
    printf("nattr is the number of attributes to copy for each dataset\n");
    printf(" -v : verbose \n");
    exit(3);
  }
  
  /* Loop through options */
  invarstring=NULL;
  ingroupstring=NULL;
  optval=0;
  verbose=0;
  while(optval >= 0){
    optval=getopt(argc,argv,optstring);
    optvalc=(char)optval;
    if(optvalc=='v'){
      verbose=1;
      printf("Ohhh! Verbosity on! Now I can spout lots of rubbish at you\n");

	
    }
    else if(optvalc=='d'){
      stringlen=strlen(optarg);
      invarstring=(char *) malloc(stringlen+3);
      varstring=(char *) malloc(stringlen+3);
      strcpy(invarstring,optarg);
      strcpy(varstring,optarg);
    }else if(optvalc=='g'){
      if(verbose) printf("arg to -g was%s\n",optarg);
      stringlen=strlen(optarg);
      ingroupstring=(char *) malloc(stringlen+3);
      groupstring=(char *) malloc(stringlen+3);
      strcpy(groupstring,optarg); 
      strcpy(ingroupstring,optarg); 
    }else if(optvalc=='a'){
      sscanf(optarg,"%d",&global_nattrs);
      if(verbose)
	printf("Doing %d attrs for each dataset \n",global_nattrs);
    }
  }/* End of getopt loop */

  /* use of H5open() is belt-and-braces stuff -- whatever it does should
     be done when you use any H5_* call */
  error=H5open();
  /* print the HDF5 version that we were linked against. This needs
     to be as new as the one our file was mae with or Bad Stuff happens */
 
  if(verbose){
    error= H5get_libversion(&majnum, &minnum, &relnum);
    printf("HDF5 Version %u.%u.%u \n",majnum, minnum, relnum);
  }

  
  strcpy(infile,argv[argc-2]);
  strcpy(outfile,argv[argc-1]);

  if(verbose)printf("copying from %s to %s \n ",infile,outfile);
  /* split varstring into an array of variable names. */
  /* First, count the variables */
  n_vars=0;
  dummy=strtok(varstring,",");
  while(dummy !=NULL){
    n_vars++;
    dummy=strtok(NULL,",");
  }
  /* Now allocate an array of strings for them and put them in it */
  if(verbose)printf("That is %d variables\n ",n_vars);
  global_varlist=(char **) malloc(sizeof(char *)*n_vars);
  strcpy(varstring,invarstring);
  
  global_varlist[0]=strtok(varstring,",");
  if(verbose)printf("Will search for variables X%sX  ",global_varlist[0]);
  for(i=1;i<n_vars;i++){
    global_varlist[i]=strtok(NULL,",");
    if(verbose) printf(" X%sX ",global_varlist[i]);
  }
  if(verbose) printf("\n");

  /* Done making string array of  variable names */
  
  if(ingroupstring!=NULL){
    /* split groupstring into an array of variable names. */
    /* First, count the variables */
    n_groups=0;
    dummy=strtok(groupstring,",");
    while(dummy !=NULL){
      n_groups++;
      dummy=strtok(NULL,",");
    }
    /* Now allocate an array of strings for them and put them in it */
    
    if(verbose) printf("That is %d groups\n ",n_groups);
    global_grouplist=(char **) malloc(sizeof(char *)*n_groups);
    strcpy(groupstring,ingroupstring);
  
    global_grouplist[0]=strtok(groupstring,",");
    if(verbose) printf("Will search for groups X%sX  ",global_grouplist[0]);
    for(i=1;i<n_groups;i++){
      global_grouplist[i]=strtok(NULL,",");
      if(verbose) printf(" X%sX ",global_grouplist[i]);
    }
    if(verbose) printf("\n");
  }

  /* printf("opening file: %s id  was",infile);*/
  file_id=H5Fopen(infile, H5F_ACC_RDONLY, H5P_DEFAULT );
  /*printf("%d\n",file_id);*/

  /*printf("opening outfile %s: id  was", outfile);*/
  outfile_id=H5Fcreate(outfile, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT );
  /*printf("%d\n",outfile_id);*/
  /* iterate over all things in root group */
  idx=NULL;
  opdat.newloc_id=outfile_id;
  opdat.getall=0;
  error=H5Giterate(file_id, rootname, idx, 
		   operator, (void *) &opdat ) ;


  /* Process attributes of root group. Yes, Veronica, it can have them. */

  /* First arg needs to be group id of the root group. Second needs to be NULL
     which forces all attributes to be processed. Third needs to be our
     function (see below). Fourth needs to be a pointer to any data we 
     want to pass to our function attr_op. For attr_op it is a pointer 
     to the thing the new attributes are being copied to (the root group 
     of the new file in this instance)  */
  if(global_nattrs > 0){
    aidx=NULL;
    rg_id=H5Gopen(file_id, "/"  );
    nrg_id=H5Gopen(outfile_id, "/"  );
    nrg_idp=&nrg_id;
    aopdata=(void *) nrg_idp;
    if(verbose) printf("Calling H5Aiterate for root group\n");
    error=H5Aiterate(rg_id, aidx, attr_op, aopdata ) ;
    if(verbose) printf("Finished H5Aiterate for root group\n");
    error=H5Gclose(rg_id);
    error=H5Gclose(nrg_id);
  }
  error=H5Fclose(file_id ) ;
  error=H5Fclose(outfile_id ) ;
  return 0;
} /* End of main() */

/*---End-of-Main------End-of-Main------End-of-Main------End-of-Main---*/


/* This is the thing that gets done to each item in the root group. */
herr_t operator(hid_t group_id, const char *member_name, void
		*operator_data){
  /* Local variables */
  H5G_stat_t statbuf, *statbufp; 
  hbool_t follow_link;
  hid_t  newloc_id;
  int error, is_wanted,i;
  opdat_t  *opdatp, newopdat;
  /* executable */
  opdatp= (opdat_t *) operator_data;
 
  newloc_id=opdatp->newloc_id;
  if(opdatp->getall==1){
    if(verbose) printf("getting %s whatever\n",member_name);
    newopdat.getall=1;
    is_wanted=1;
  }
  else{
    if(verbose) printf("operating on %s ... ",member_name);
    is_wanted=0;
    newopdat.getall=0;
      for(i=0;i<n_vars;i++){
	if (strcmp(global_varlist[i],member_name)==0){
	  is_wanted=1;
	} 
      }
    for(i=0;i<n_groups;i++){
      if (strcmp(global_grouplist[i],member_name)==0){
	is_wanted=1;
	newopdat.getall=1;
      } 
    }
  }
  if(is_wanted==0){
    if(verbose) printf("not on wanted list\n");
  }
  else {
    
    follow_link=0;
    statbufp=&statbuf;

    /* Call to HDF5 to find what type of item this is. The results are returned
     * in the structure statbuf, pointed to by statbufp */
    error=H5Gget_objinfo(group_id, member_name, follow_link, statbufp );
  
    /* Main if block  to process each of the possible item types */
    if(statbuf.type ==  H5G_GROUP){
      /*hid_t oldsubgroup_id, newsubgroup_id, *newsubgroup_idp;*/
      int *idx;
      opdat_t newsubgroup;
      size_t size_hint;
      if(verbose) printf("It's a group: Looking into it\n");
      /*oldsubgroup_id=H5Gopen(group_id,member_name );*/
      size_hint=40;
      newsubgroup.newloc_id=H5Gcreate(newloc_id, member_name, size_hint );
      newsubgroup.getall=newopdat.getall;
      idx=NULL;
      error=H5Giterate(group_id, member_name, idx, 
		       operator, (void *) &newsubgroup ) ;

      /*error=H5Gclose(oldsubgroup_id); */
      error=H5Gclose(newsubgroup.newloc_id); 
      /* Should process attributes of group here. */
      if(verbose) printf("Finished with group %s\n",member_name);
    }
    else if(statbuf.type ==  H5G_DATASET){
      /* OK, it's a dataset. Now we need to process it to write it out */
      /* variables local to this block (?is this standard C? It seems to work.)*/
      hid_t old_dspace, new_dspace, old_dset, new_dset, type_id ,plist_id;
      void *databuf;
      int n_elements;
      int *aidx;
      void *aopdata;
      hid_t *new_dsetp;
      /* executable for this bock */
      if(verbose) printf("It's a dataset: \n");
      old_dset=H5Dopen(group_id, member_name );
      /*printf("Opened dataset with id=%d\n",old_dset); */
      old_dspace=H5Dget_space(old_dset) ;
      /*printf("Opened dataspace with id=%d\n",old_dspace);*/
      plist_id=H5Dget_create_plist(old_dset); 
      new_dspace=H5Scopy(old_dspace);
      type_id=H5Dget_type(old_dset); 
    
      /* This next line makes a new dataset in the new file with an
       * identical dataspace to the old dataset in the old file */
      /* needs fixing to work for extendible datasets */
      new_dset=H5Dcreate(newloc_id, member_name, type_id, 
			 new_dspace, plist_id );

      /* Now we have to move the actual data. To do that, we have to malloc
	 a suitably humongous buffer */
      n_elements=H5Sget_simple_extent_npoints(new_dspace); 
      databuf=(void *) malloc(n_elements*H5Tget_size(type_id) );
      error=H5Dread(old_dset,type_id, H5S_ALL,H5S_ALL ,
		    H5P_DEFAULT,databuf ); 
      error=H5Dwrite(new_dset,type_id,H5S_ALL,H5S_ALL, 
		     H5P_DEFAULT,databuf ) ;
      /* Process all attributes of this dataset */
      aidx=NULL;
      new_dsetp=&new_dset;
      aopdata=(void *) new_dsetp;
      global_attrcnt=0;
      if(global_nattrs > 0)
	error=H5Aiterate(old_dset, aidx, attr_op, aopdata ) ;


      free(databuf);
      error=H5Sclose(old_dspace );
      error=H5Sclose(new_dspace );
      error=H5Dclose(old_dset); 
      error=H5Dclose(new_dset); 
    }
    else if(statbuf.type ==  H5G_LINK){
      if(verbose) printf("It's a link: ignore\n");
    }
    else if(statbuf.type ==  H5G_TYPE){
      if(verbose) printf("It's a type: ignore\n");
    }
    else {
      printf("I really don't know what the fsck %s is: it has type:%d\n",
	     member_name,statbuf.type);
    }
    /* End of main if block  to process each of the possible item types */  
  }
  /* end of wanted-or-not if block */
  return 0;

}

herr_t attr_op(hid_t loc_id, const char *attr_name, void *operator_data){

  hid_t attr_id, new_attr_id,new_dset_id, *new_dset_idp;
  hid_t type_id, space_id,new_dspace;
  int error,n_elements;
  void *databuf;
  new_dset_idp=(hid_t *) operator_data;
  new_dset_id= *new_dset_idp;


  printf("Processing attribute %s\n",attr_name);
  
  attr_id=H5Aopen_name(loc_id, attr_name ) ;
  type_id=H5Aget_type(attr_id);
  space_id=H5Aget_space(attr_id);
  new_dspace=H5Scopy(space_id);
  new_attr_id=H5Acreate(new_dset_id,attr_name,type_id, space_id, H5P_DEFAULT);
  
  n_elements=H5Sget_simple_extent_npoints(new_dspace); 
  databuf=(void *) malloc(n_elements*H5Tget_size(type_id) );
  error=H5Aread(attr_id,type_id, databuf ); 
  error=H5Awrite(new_attr_id,type_id, databuf ); 

  
  error=H5Aclose(attr_id);


  global_attrcnt++;
  if(global_attrcnt < global_nattrs){
    return 0; /* next attribute will be processed */
  }else{
    return 1; /* No more attributes will be processed */
  }
}
@


1.5
log
@Added comment about building on HDF5-v1.8
@
text
@d53 1
a53 1
  char infile[80], outfile[80];
d56 1
a56 1
  char rootname[80];
@


1.4
log
@Added call to print out HDF5 version when -v flag is used. Helps user to
check whether he has inadvertantly linked against an out-of-date library.
Also tidied out a lot of unused variables. (gcc -Wall now quiet)
@
text
@d10 1
d22 1
@


1.3
log
@Now processes attributes of root group. Attributes of other groups
not yet processed. Use -a <number> to activate
@
text
@d52 3
a54 3
  hid_t file_id,outfile_id,dset_id,dspace_id;
  int error, nmembers,*idx,*aidx,obj_type, stringlen, i;
  char obj_name[80],rootname[80];
d58 1
a58 1
  void *operator_data;
d61 1
a61 1
  hid_t *newloc_idp,newloc_id,rg_id,nrg_id,*nrg_idp;
d66 1
d94 2
d116 12
d217 1
a217 1
  
d229 1
a229 1
  hid_t *newloc_idp, newloc_id;
d231 1
a231 1
  opdat_t opdat, *opdatp, newopdat;
d271 1
a271 1
      hid_t oldsubgroup_id, newsubgroup_id, *newsubgroup_idp;
d357 1
a357 1
  hid_t type_id, dspace_id,new_space,space_id,new_dspace;
@


1.2
log
@Added command line args.
@
text
@d53 1
a53 1
  int error, nmembers,*idx,obj_type, stringlen, i;
d59 1
d61 1
a61 1
  hid_t *newloc_idp,newloc_id;
d178 22
a199 1
  
d271 1
@


1.1
log
@  HCP Added utility program for subsetting HDF5 files,
@
text
@d25 1
d32 1
d56 2
d61 8
d72 6
a77 3
  if (argc < 4){
    printf("Usage: subset <infile> <outfile> <comma separated ");
    printf("list of datasets> <opt.comma-sep. list of groups to copy all of>");
a79 5
  strcpy(infile,argv[1]);
  strcpy(outfile,argv[2]);
  stringlen=strlen(argv[3]);
  varstring=(char *) malloc(stringlen+3);
  strcpy(varstring,argv[3]);
d81 31
d113 4
d126 1
a126 1
  printf("That is %d variables\n ",n_vars);
d128 1
a128 1
  strcpy(varstring,argv[3]);
d131 1
a131 1
  printf("Will search for variables X%sX  ",global_varlist[0]);
d134 1
a134 1
    printf(" X%sX ",global_varlist[i]);
d136 1
a136 1
  printf("\n");
d140 1
a140 1
  if(argc>4){
a142 4
    stringlen=strlen(argv[4]);
    groupstring=(char *) malloc(stringlen+3);
    strcpy(groupstring,argv[4]);

d150 2
a151 1
    printf("That is %d groups\n ",n_groups);
d153 1
a153 1
    strcpy(groupstring,argv[4]);
d156 1
a156 1
    printf("Will search for groups X%sX  ",global_grouplist[0]);
d159 1
a159 1
      printf(" X%sX ",global_grouplist[i]);
d161 1
a161 1
    printf("\n");
d200 1
a200 1
    printf("getting %s whatever\n",member_name);
d205 1
a205 1
    printf("operating on %s ... ",member_name);
d221 1
a221 1
    printf("not on wanted list\n");
d238 1
a238 1
      printf("It's a group: Looking into it\n");
d249 1
a249 1
      printf("Finished with group %s\n",member_name);
d261 1
a261 1
      printf("It's a dataset: \n");
d288 3
a290 1
      error=H5Aiterate(old_dset, aidx, attr_op, aopdata ) ;
d300 1
a300 1
      printf("It's a link: ignore\n");
d303 1
a303 1
      printf("It's a type: ignore\n");
d306 2
a307 2
      printf("I really don't know what the fsck this is: it has type:%d\n",
	     statbuf.type);
d342 7
a348 4
  /* "return 1;" here causes only the first attribute to be processed
     "return 0" causes all of them to be processed. 
  */
  return 1;
@

