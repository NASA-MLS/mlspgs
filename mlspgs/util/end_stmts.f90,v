head	1.3;
access;
symbols
	v5-02-NRT-19:1.3
	v6-00:1.3
	v5-02-NRT-18:1.3
	v5-02:1.3
	v5-01-NRT-17:1.3
	v5-01-NRT-16:1.3
	v5-01-NRT-15:1.3
	v5-01-NRT-14:1.3
	neuralnetworks-1-0:1.3.0.14
	cfm-single-freq-0-1:1.3.0.12
	v5-01:1.3
	v5-00:1.3
	v4-23-TA133:1.3.0.10
	mus-emls-1-70:1.3.0.8
	rel-1-0-englocks-work:1.3.0.6
	VUMLS1-00:1.3
	VPL1-00:1.3
	V4-22-NRT-08:1.3
	VAM1-00:1.3
	V4-21:1.3.0.4
	V4-13:1.3
	V4-12:1.3
	V4-11:1.3
	V4-10:1.3
	V3-43:1.3
	M4-00:1.3
	V3-41:1.3
	V3-40-PlusGM57:1.3.0.2
	V2-24-NRT-04:1.3
	V3-33:1.3
	V2-24:1.3
	V3-31:1.3
	V3-30-NRT-05:1.3
	cfm-01-00:1.3
	V3-30:1.3
	V3-20:1.3
	V3-10:1.3
	V2-23-NRT-02:1.3
	V2-23:1.3
	V2-22-NRT-01:1.3
	V2-22:1.3
	V2-21:1.3
	V2-20:1.3
	V2-11:1.3
	V2-10:1.3
	V2-00:1.3
	V1-51:1.2
	V1-50:1.2
	V1-45:1.2
	V1-44:1.2
	V1-43:1.2
	V1-42:1.2
	V1-41:1.2
	V1-32:1.2
	V1-40:1.2
	V1-31:1.2
	V1-30:1.2
	V1-13:1.2
	V1-12:1.2
	V1-11:1.2
	V1-10:1.2
	newfwm-feb03:1.2.0.4
	V1-04:1.2
	V1-03:1.2
	V1-02:1.2
	V1-00:1.2
	newfwm-sep01:1.2.0.2
	V0-7:1.2
	V0-5-Level2:1.2
	V0-5-SIPS:1.2
	V0_1:1.2;
locks; strict;
comment	@# @;


1.3
date	2005.06.22.19.27.32;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.11.00.41.59;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.11.00.35.36;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Reworded Copyright statement, moved rcs id
@
text
@program END_STMTS

! Read a Fortran program file, in fixed format.  Copy all lines in it,
! except for END statements, to the output unchanged.

! When a SUBROUTINE or FUNCTION statement is found, remember which
! it is, and the name.  THIS PROGRAM ASSUMES THE NAME IS ON THE SAME LINE!

! When an END statement is found, add SUBROUTINE or FUNCTION as remembered,
! and the remembered name.

!---------------------------- RCS Ident Info ------------------------------
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: MLSL2.f90,v $"
  character (len=*), parameter :: IdParm = &
       "$Id: MLSL2.f90,v 2.138 2005/06/22 18:57:02 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
!---------------------------------------------------------------------------

  integer :: I1, I2                     ! Begin and end of SUBROUTINE or
                                        ! FUNCTION in LINE_CAP, else zero.
  integer :: I3, I4                     ! Begin and end of name in LINE_IN.
  integer :: IC                         ! Position of ! in LINE_CAP, else 133
  character(len=133) :: LINE_CAP        ! LINE_IN, capitalized
  character(len=133) :: LINE_IN         ! Input line
  character(len=133) :: NAME = ' '      ! Name of procedure
  character(len=10) :: TYPE = ' '       ! SUBROUTINE or FUNCTION

  do
    read ( *, '(a)', end=999 ) line_in
    line_cap = capitalize(line_in)
    ic = index(line_cap, '!')
    if ( ic == 0 ) ic = len(line_cap) + 1

    ! Look for SUBROUTINE or FUNCTION not after !
    i2 = 0
    i1 = index(line_cap, 'SUBROUTINE')
    if ( i1 /= 0 .and. i1 < ic ) then
      i2 = i1 + len('SUBROUTINE') - 1
    else
      i1 = index(line_cap, 'FUNCTION')
      if ( i1 /= 0 .and. i1 < ic ) i2 = i1 + len('FUNCTION') - 1
    end if
    if ( i2 /= 0 ) then ! Find the name after SUBROUTINE or FUNCTION
      do i3 = i2+1, 132
        if ( line_in(i3:i3) /= ' ' ) then
          type = line_in(i1:i2)
          i4 = index(line_in(i3:), ' ') + i3 - 2
          name = line_in(i3:i4)
          exit
        end if
      end do
      write ( *, '(a)' ) trim(line_in)
    else

      ! Look for END statement
      i1 = index(line_cap, 'END')
      if ( i1 /= 0 .and. i1 < ic .and. line_cap(i1+3:ic-1) == ' ' ) then
        write ( *, '(a)' ) '      ' // line_in(i1:i1+2) // ' ' // &
        &                  trim(type) // ' ' // trim(name) // ' ' // &
        &                  line_in(ic:)
      else
        write ( *, '(a)' ) trim(line_in)
      end if
    end if
  end do
999 stop

contains
  character(len=len(in)) function CAPITALIZE ( IN )
    character(len=*), intent(in) :: IN
    integer :: I                        ! Loop inductor
    do i = 1, len(in)
      if ( in(i:i) < 'a' .or. in(i:i) > 'z' ) then
        capitalize(i:i) = in(i:i)
      else
        capitalize(i:i) = char( ichar(in(i:i)) + ichar('A') - ichar('a') )
      end if
    end do
  end function CAPITALIZE
end program END_STMTS
! $Log: end_stmts.f90,v $
! Revision 1.2  2000/03/11 00:41:59  vsnyder
! Inserted CVS id and log
!
@


1.2
log
@Inserted CVS id and log
@
text
@d12 7
a18 4
!------------------------------- RCS Ident Info ------------------------------
CHARACTER(LEN=130) :: id = & 
   "$Id: end_stmts.f90,v 1.0 2000/03/10 16:40:02 snyder Exp $"
!-----------------------------------------------------------------------------
d83 3
@


1.1
log
@VSnyder 000310 Original code
@
text
@d12 5
d79 1
@

