head	1.2;
access;
symbols
	v5-02-NRT-19:1.2
	v6-00:1.2
	v5-02-NRT-18:1.2
	v5-02:1.2
	v5-01-NRT-17:1.2
	v5-01-NRT-16:1.2
	v5-01-NRT-15:1.2
	v5-01-NRT-14:1.2
	neuralnetworks-1-0:1.2.0.18
	cfm-single-freq-0-1:1.2.0.16
	v5-01:1.2
	v5-00:1.2
	v4-23-TA133:1.2.0.14
	mus-emls-1-70:1.2.0.12
	rel-1-0-englocks-work:1.2.0.10
	VUMLS1-00:1.2
	VPL1-00:1.2
	V4-22-NRT-08:1.2
	VAM1-00:1.2
	V4-21:1.2.0.8
	V4-13:1.2
	V4-12:1.2
	V4-11:1.2
	V4-10:1.2
	V3-43:1.2
	M4-00:1.2
	V3-41:1.2
	V3-40-PlusGM57:1.2.0.6
	V2-24-NRT-04:1.2
	V3-33:1.2
	V2-24:1.2
	V3-31:1.2
	V3-30-NRT-05:1.2
	cfm-01-00:1.2
	V3-30:1.2
	V3-20:1.2
	V3-10:1.2
	V2-23-NRT-02:1.2
	V2-23:1.2
	V2-22-NRT-01:1.2
	V2-22:1.2
	V2-21:1.2
	V2-20:1.2
	V2-11:1.2
	V2-10:1.2
	V2-00:1.2
	V1-51:1.2
	V1-50:1.2
	V1-45:1.2
	V1-44:1.2
	V1-43:1.2
	V1-42:1.2
	V1-41:1.2
	V1-32:1.2
	V1-40:1.2
	V1-31:1.2
	V1-30:1.2
	V1-13:1.2
	V1-12:1.2
	V1-11:1.2
	V1-10:1.2
	newfwm-feb03:1.2.0.4
	V1-04:1.2
	V1-03:1.2
	V1-02:1.2
	V1-00:1.2
	newfwm-sep01:1.2.0.2
	V0-7:1.2
	V0-5-Level2:1.2
	V0-5-SIPS:1.2
	V0_1:1.2;
locks; strict;
comment	@# @;


1.2
date	2000.03.11.00.41.59;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.11.00.35.36;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Inserted CVS id and log
@
text
@#!/usr/bin/perl
#
# Usage: makemake {<program name> {<F90 compiler or fc or f77 or cc or c>}}
#
# Generate a Makefile from the sources in the current directory.  The source
# files may be in either C, FORTRAN 77, Fortran 90 or some combination of
# these languages.  If the F90 compiler specified is cray or parasoft, then
# the Makefile generated will conform to the conventions of these compilers.
# To run makemake, it will be necessary to modify the first line of this script
# to point to the actual location of Perl on your system.
#
# Written by Michael Wester <wester@@math.unm.edu> February 16, 1995
# Cotopaxi (Consulting), Albuquerque, New Mexico
#
# "$Id: f90mkmf,v 1.0 2000/03/10 16:40:02 snyder Exp $"

open(MAKEFILE, "> Makefile");
#
print MAKEFILE "PROG =\t$ARGV[0]\n\n";
#
# Source listing
#
print MAKEFILE "SRCS =\t";
@@srcs = <*.f90 *.f *.F *.c>;
&PrintWords(8, 0, @@srcs);
print MAKEFILE "\n\n";
#
# Object listing
#
print MAKEFILE "OBJS =\t";
@@objs = @@srcs;
foreach (@@objs) { s/\.[^.]+$/.o/ };
&PrintWords(8, 0, @@objs);
print MAKEFILE "\n\n";
#
# Define common macros
#
print MAKEFILE "LIBS =\t\n\n";
print MAKEFILE "CC = cc\n";
print MAKEFILE "CFLAGS = -O\n";
print MAKEFILE "FC = f77\n";
print MAKEFILE "FFLAGS = -O\n";
print MAKEFILE "F90 = f90\n";
print MAKEFILE "F90FLAGS = -O\n";
print MAKEFILE "LDFLAGS = -s\n\n";
#
# make
#
print MAKEFILE "all: \$(PROG)\n\n";
print MAKEFILE "\$(PROG): \$(OBJS)\n";
print MAKEFILE "\t\$(", &LanguageCompiler($ARGV[1], @@srcs);
print MAKEFILE ") \$(LDFLAGS) -o \$@@ \$(OBJS) \$(LIBS)\n\n";
#
# make clean
#
print MAKEFILE "clean:\n";
print MAKEFILE "\trm -f \$(PROG) \$(OBJS) *.mod\n\n";
#
# Make .f90 a valid suffix
#
print MAKEFILE ".SUFFIXES: \$(SUFFIXES) .f90\n\n";
#
# .f90 -> .o
#
print MAKEFILE ".f90.o:\n";
print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c \$<\n\n";
#
# Dependency listings
#
&MakeDependsf90($ARGV[1]);
&MakeDepends("*.f *.F", '^\s*include\s+["\']([^"\']+)["\']');
&MakeDepends("*.c",     '^\s*#\s*include\s+["\']([^"\']+)["\']');

#
# &PrintWords(current output column, extra tab?, word list); --- print words
#    nicely
#
sub PrintWords {
   local($columns) = 78 - shift(@@_);
   local($extratab) = shift(@@_);
   local($wordlength);
   #
   print MAKEFILE @@_[0];
   $columns -= length(shift(@@_));
   foreach $word (@@_) {
      $wordlength = length($word);
      if ($wordlength + 1 < $columns) {
         print MAKEFILE " $word";
         $columns -= $wordlength + 1;
         }
      else {
         #
         # Continue onto a new line
         #
         if ($extratab) {
            print MAKEFILE " \\\n\t\t$word";
            $columns = 62 - $wordlength;
            }
         else {
            print MAKEFILE " \\\n\t$word";
            $columns = 70 - $wordlength;
            }
         }
      }
   }

#
# &LanguageCompiler(compiler, sources); --- determine the correct language
#    compiler
#
sub LanguageCompiler {
   local($compiler) = &toLower(shift(@@_));
   local(@@srcs) = @@_;
   #
   if (length($compiler) > 0) {
      CASE: {
         grep(/^$compiler$/, ("fc", "f77")) &&
            do { $compiler = "FC"; last CASE; };
         grep(/^$compiler$/, ("cc", "c"))   &&
            do { $compiler = "CC"; last CASE; };
         $compiler = "F90";
         }
      }
   else {
      CASE: {
         grep(/\.f90$/, @@srcs)   && do { $compiler = "F90"; last CASE; };
         grep(/\.(f|F)$/, @@srcs) && do { $compiler = "FC";  last CASE; };
         grep(/\.c$/, @@srcs)     && do { $compiler = "CC";  last CASE; };
         $compiler = "???";
         }
      }
   $compiler;
   }

#
# &toLower(string); --- convert string into lower case
#
sub toLower {
   local($string) = @@_[0];
   $string =~ tr/A-Z/a-z/;
   $string;
   }

#
# &uniq(sorted word list); --- remove adjacent duplicate words
#
sub uniq {
   local(@@words);
   foreach $word (@@_) {
      if ($word ne $words[$#words]) {
         push(@@words, $word);
         }
      }
   @@words;
   }

#
# &MakeDepends(language pattern, include file sed pattern); --- dependency
#    maker
#
sub MakeDepends {
   local(@@incs);
   local($lang) = @@_[0];
   local($pattern) = @@_[1];
   #
   foreach $file (<${lang}>) {
      open(FILE, $file) || warn "Cannot open $file: $!\n";
      while (<FILE>) {
         /$pattern/i && push(@@incs, $1);
         }
      if (defined @@incs) {
         $file =~ s/\.[^.]+$/.o/;
         print MAKEFILE "$file: ";
         &PrintWords(length($file) + 2, 0, @@incs);
         print MAKEFILE "\n";
         undef @@incs;
         }
      }
   }

#
# &MakeDependsf90(f90 compiler); --- FORTRAN 90 dependency maker
#
sub MakeDependsf90 {
   local($compiler) = &toLower(@@_[0]);
   local(@@dependencies);
   local(%filename);
   local(@@incs);
   local(@@modules);
   local($objfile);
   #
   # Associate each module with the name of the file that contains it
   #
   foreach $file (<*.f90>) {
      open(FILE, $file) || warn "Cannot open $file: $!\n";
      while (<FILE>) {
         /^\s*module\s+([^\s!]+)/i &&
            ($filename{&toLower($1)} = $file) =~ s/\.f90$/.o/;
         }
      }
   #
   # Print the dependencies of each file that has one or more include's or
   # references one or more modules
   #
   foreach $file (<*.f90>) {
      open(FILE, $file);
      while (<FILE>) {
         /^\s*include\s+["\']([^"\']+)["\']/i && push(@@incs, $1);
         /^\s*use\s+([^\s,!]+)/i && push(@@modules, &toLower($1));
         }
      if (defined @@incs || defined @@modules) {
         ($objfile = $file) =~ s/\.f90$/.o/;
         print MAKEFILE "$objfile: ";
         undef @@dependencies;
         foreach $module (@@modules) {
            push(@@dependencies, $filename{$module});
            }
         @@dependencies = &uniq(sort(@@dependencies));
         &PrintWords(length($objfile) + 2, 0,
                     @@dependencies, &uniq(sort(@@incs)));
         print MAKEFILE "\n";
         undef @@incs;
         undef @@modules;
         #
         # Cray F90 compiler
         #
         if ($compiler eq "cray") {
            print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
            foreach $depend (@@dependencies) {
               push(@@modules, "-p", $depend);
               }
            push(@@modules, $file);
            &PrintWords(30, 1, @@modules);
            print MAKEFILE "\n";
            undef @@modules;
            }
         #
         # ParaSoft F90 compiler
         #
         if ($compiler eq "parasoft") {
            print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
            foreach $depend (@@dependencies) {
               $depend =~ s/\.o$/.f90/;
               push(@@modules, "-module", $depend);
               }
            push(@@modules, $file);
            &PrintWords(30, 1, @@modules);
            print MAKEFILE "\n";
            undef @@modules;
            }
         }
      }
   }
# $Log: f90mkmf,v $
@


1.1
log
@VSnyder 000310 Original code
@
text
@d15 2
d254 1
@

