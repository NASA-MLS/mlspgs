head	1.12;
access;
symbols
	v5-02-NRT-19:1.12
	v6-00:1.12
	v5-02-NRT-18:1.12
	v5-02:1.12
	v5-01-NRT-17:1.12
	v5-01-NRT-16:1.12
	v5-01-NRT-15:1.12
	v5-01-NRT-14:1.12
	neuralnetworks-1-0:1.12.0.12
	cfm-single-freq-0-1:1.12.0.10
	v5-01:1.12
	v5-00:1.12
	v4-23-TA133:1.12.0.8
	mus-emls-1-70:1.12.0.6
	rel-1-0-englocks-work:1.12.0.4
	VUMLS1-00:1.12
	VPL1-00:1.12
	V4-22-NRT-08:1.12
	VAM1-00:1.12
	V4-21:1.12.0.2
	V4-13:1.12
	V4-12:1.12
	V4-11:1.12
	V4-10:1.12
	V3-43:1.11
	M4-00:1.12
	V3-41:1.11
	V3-40-PlusGM57:1.11.0.2
	V2-24-NRT-04:1.11
	V3-33:1.11
	V2-24:1.11
	V3-31:1.11
	V3-30-NRT-05:1.11
	cfm-01-00:1.11
	V3-30:1.11
	V3-20:1.11
	V3-10:1.11
	V2-23-NRT-02:1.11
	V2-23:1.11
	V2-22-NRT-01:1.11
	V2-22:1.11
	V2-21:1.11
	V2-20:1.11
	V2-11:1.11
	V2-10:1.11
	V2-00:1.11
	V1-51:1.10
	V1-50:1.10
	V1-45:1.10
	V1-44:1.10
	V1-43:1.10
	V1-42:1.10
	V1-41:1.10
	V1-32:1.10
	V1-40:1.10
	V1-31:1.10
	V1-30:1.10
	V1-13:1.10
	V1-12:1.10
	V1-11:1.10
	V1-10:1.10
	newfwm-feb03:1.10.0.2
	V1-04:1.10
	V1-03:1.10
	V1-02:1.10
	V1-00:1.10
	newfwm-sep01:1.5.0.2
	V0-7:1.5;
locks; strict;
comment	@# @;


1.12
date	2011.11.10.23.40.25;	author vsnyder;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.22.19.27.32;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.15.17.20.49;	author pwagner;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.12.22.13.44;	author vsnyder;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.12.22.03.09;	author vsnyder;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.04.19.54.43;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.03.17.18.20;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.25.19.57.30;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.25.19.47.22;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.25.18.49.08;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.25.18.26.34;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.25.02.07.02;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Allow comments to begin with %
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

program INIT_GEN

  ! Generate the parameter statements and references to add_ident
  ! for init_tables_module and others similar to it.

  ! An input file specifies the names.
  ! You can put one or two names on a line, separated by spaces.
  ! The first name is the parameter name WITHOUT ITS PREFIX.
  ! The second name is the entity's text -- e.g. a field name.  If
  ! it's not present, the first name is used for the entity's text.

  ! Blank lines don't count.  Lines for which the first nonblank is
  ! "!", "#" or "%" don't count.

  ! The command line controls everything else.  See the PRINT statements
  ! that explain the usage.

  use MACHINE,only: GETARG, HP, IO_ERROR

!---------------------------- RCS Ident Info ------------------------------
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: init_gen.f90,v $"
  character (len=*), parameter :: IdParm = &
       "$Id: init_gen.f90,v 1.11 2005/06/22 19:27:32 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
!---------------------------------------------------------------------------

  character(len=30) :: CapName               ! Capitalized? name
  integer, parameter :: Decl_Wid = len("  integer, parameter :: ")
  logical :: DoIdent = .true.                ! Do add_ident stuff, made false
                                             ! if no file is supplied for it
  logical :: DoCap = .false.                 ! "Capitalize declaration"
  character(len=40) :: FirstName = '1', LastName = ' '
  integer :: I, J                            ! subscripts, loop inductors
  character(len=127) :: InFile = ' '
  character(len=30) :: Index_Name            ! Array for output from add_ident
  integer :: Index_Wid                       ! Width of Index_Name
  integer :: IOSTAT
  character(len=127) :: LINE
  integer :: Margin = 0                      ! Internal margin
  integer :: MaxNames = 1000                 ! Maximum number of names
  integer :: MaxWid                          ! of a name
  character(len=30), dimension(:), allocatable :: Names ! for the symbol table
  integer :: Nspaces
  integer :: NumNames
  character(len=127) :: Out_Add, Out_Parm    ! File names
  character(len=40), dimension(:), allocatable :: P_Names   ! Parameter names
  !                                            that go with Names
  character(len=10) :: Pfx = ' '             ! for declarations

  character(len=127), dimension(3) :: HEADER = (/ &
    & 'This file is automatically generated by the makefile', &
    & 'Please do not edit it directly nor cvs commit it    ', &
    & 'Instead edit the file <file_name_here>              ' &
    & /)
  logical, parameter                        :: WRITEHEADER = .true.

  i = hp
  do
    i = i + 1
    call getarg ( i, line )
    if ( line(1:3) == '-c ' ) then
      doCap = .true.
    else if ( line(1:2) == '-f' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      firstName = line(3:)
    else if ( line(1:2) == '-i' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      inFile = line(3:)
      j = index(header(3),'<')
      header(3)(j:) = trim(infile)
    else if ( line(1:2) == '-j' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      j = index(header(3),'<')
      header(3)(j:) = trim(line(3:))
    else if ( line(1:2) == '-l' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      lastName = line(3:)
    else if ( line(1:2) == '-m' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      read ( line(3:), *, iostat=iostat ) margin
      if ( iostat /= 0 ) then
        call io_error ( 'While reading "m" option', iostat )
        margin = 0
      end if
    else if ( line(1:2) == '-n' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      read ( line(3:), *, iostat=iostat ) maxNames
      if ( iostat /= 0 ) then
        call io_error ( 'While reading "n" option', iostat )
        maxNames = 1000
      end if
     else if ( line(1:2) == '-p' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      pfx = line(3:)
    else if ( line(1:1) == '-' ) then
      call getarg ( hp, line )
      print *, 'Usage: ', trim(line), ' [options] out_parm [out_add index_name]'
      print *, ' Options:  -c: Capitalize entire name in declarations'
      print *, '           -f[ ]first_name -- The expression from which the'
      print *, '             first name gets its value.  Default 1.'
      print *, '           -i[ ]input_file -- stdin used otherwise.'
      print *, '           -j[ ]file -- name of file you piped in throough stdin.'
      print *, '           -l[ ]last_name -- A name made equal to the last name.'
      print *, '             Not emitted if not present.'
      print *, '           -m[ ]margin -- The "middle" margin, which is otherwise'
      print *, '             computed from the width of the widest name.'
      print *, '           -n[ ]number -- the maximum number of names, default ', &
        &                    maxNames
      print *, '           -p[ ]prefix -- Prefix for variable names.'
      print *, '           -<anything else>: This output.'
      print *, ' out_parm:   The file to store the generated parameter declarations.'
      print *, '                (Mandatory)'
      print *, '    The next two are co-optional: if one given then both must be given'
      print *, ' out_add:    The file to store the generated references to add_ident.'
      print *, ' index_name: The name of the array in which to store the outputs'
      print *, '             of add_ident.'
      stop
    else
  exit
    end if
  end do

  call getarg ( i, out_parm )
  if ( out_parm == ' ' ) then
    print *, 'No parameter declarations file name given.'
    stop
  end if
  call getarg ( i+1, out_add )
  doIdent = out_add /= ' '
  if ( doIdent ) then
    call getarg ( i+2, index_name )
    if ( index_name == ' ' ) then
      print *, 'No name given for the array to store references to add_ident.'
      stop
    end if
    index_Wid = len_trim(index_name)
  end if

  if ( inFile /= ' ' ) then
    open ( 10, file=inFile, form='formatted', status='old', iostat=iostat )
    if ( iostat /= 0 ) then
      call io_error ( 'Opening input file', iostat, inFile )
      stop
    end if
  end if

  if ( doIdent ) then
    open ( 11, file=out_add, form='formatted', iostat=iostat )
    if ( iostat /= 0 ) then
      call io_error ( 'Opening file for results of add_ident', iostat, inFile )
      stop
    end if
  end if

  open ( 12, file=out_parm, form='formatted', iostat=iostat )
  if ( iostat /= 0 ) then
    call io_error ( 'Opening file for parameter declarations', iostat, inFile )
    stop
  end if

  ! Read the names.  Calculate the width of the widest name.
  maxWid = 0
  numNames = 0
  allocate ( names(maxNames), p_names(maxNames), stat=iostat )
  if ( iostat > 0 ) then
    call io_error ( 'Allocating arrays', iostat )
    stop
  end if

  do
    if ( infile == ' ' ) then
      read ( *, '(a)', iostat=iostat ) line
    else
      read ( 10, '(a)', iostat=iostat ) line
    end if
    if ( iostat < 0 ) exit
    if ( iostat > 0 ) then
      call io_error ( 'Reading input file', iostat, inFile )
      stop
    end if
    if ( line == ' ' ) cycle
    line = adjustl(line)
    if ( line(1:1) == '#' .or. line(1:1) == '!' .or. line(1:1) == '%' ) cycle
    numNames = numNames + 1
    if ( numNames > maxNames ) then
      print *, numNames, ' is too many names.  Use the "-n" option.'
      stop
    end if
    ! Trim off comments
    j = index(line,'#')
    if ( j /= 0 ) line(j:) = ' '
    j = index(line,'!')
    if ( j /= 0 ) line(j:) = ' '
    ! get p_name if any
    j = index(line,' ')
    p_names(numNames) = line(:j-1)
    line = adjustl(line(j+1:))
    if ( line == ' ' ) then
      names(numNames) = p_names(numNames)
    else
      names(numNames) = line
    end if
    p_names(numNames) = trim(pfx) // p_names(numNames)
    maxWid = max(maxWid, len_trim(p_names(numNames)))
  end do
  line = ' '
  close ( 10 )

  if ( lastName /= ' ' ) maxWid = max(maxWid, len_trim(lastName))

  ! Output the parameter declarations.

  line = ' ' ! used to output spaces

100 format ( "  integer, parameter :: ",a," = ",a,a)
  ! Warn off users from editing Out_parm
  if ( writeheader ) then
    write ( 12, '(a, a)' ) '! File name: ', trim(Out_parm)
    do i = 1, size(header)
      write ( 12, '(a, a)' ) '! ', trim(header(i))
    end do
  end if

  do i = 1, numNames
    capName = capitalize(p_names(i))
    capName(1:1) = cap(capName(1:1))
    if ( margin /= 0 ) then
      nspaces = margin - decl_wid - len_trim(capName) - 4
    else
      nspaces = maxwid - len_trim(capName)
    end if
    write ( 12, 100 ) trim(capName), line(:nspaces), &
                    & trim(firstName)
    firstName = trim(p_names(i)) // ' + 1'
  end do
  if ( lastName /= ' ' ) then
    lastName = capitalize ( lastName )
    lastName(1:1) = cap(lastName(1:1))
    if ( margin /= 0 ) then
      nspaces = margin - decl_wid - len_trim(lastName) - 4
    else
      nspaces = maxwid - len_trim(lastName)
    end if
    write ( 12, 100 ) trim(lastName), line(:nspaces), &
                    & trim(p_names(numNames))
  end if
  close ( 12 )

  if ( doIdent ) then
    ! Output the references to "add_ident"
    ! Warn off users from editing Out_add
    if ( writeheader ) then
      write ( 11, '(a, a)' ) '! File name: ', trim(Out_add)
      do i = 1, size(header)
        write ( 11, '(a, a)' ) '! ', trim(header(i))
      end do
    end if

    do i = 1, numNames
      if ( margin /= 0 ) then
        nspaces = margin - index_Wid - 10 - len_trim(p_names(i))
      else
        nspaces = maxwid - len_trim(p_names(i))
      end if
      write ( 11, '(4x,a,"(",a,") = ", a, "add_ident ( ''",a,"'' )")' ) &
        & index_name(:index_Wid), trim(p_names(i)), &
        & line(:nspaces), trim(names(i))
    end do
    close ( 11 )
  end if

contains

  character function Cap ( TheChar )
    character, intent(in) :: TheChar
    cap = theChar
    if ( cap >= 'a' .and. cap <= 'z' ) &
      & cap = achar(iachar(cap) + iachar('A') - iachar('a'))
  end function Cap

  function Capitalize ( TheName ) result ( CapName )
    character(len=*), intent(in) :: TheName
    character(len(theName)) :: CapName
    integer :: J
    capName = theName
    if ( doCap ) then
      do j = 1, len_trim(theName)
        capName(j:j) = cap(capName(j:j))
      end do
    end if
  end function Capitalize

end program INIT_GEN

! $Log: init_gen.f90,v $
! Revision 1.11  2005/06/22 19:27:32  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.10  2001/10/15 17:20:49  pwagner
! Now trims header in out_add, too
!
! Revision 1.9  2001/10/12 22:13:44  vsnyder
! Put input file name in comment in output file
!
! Revision 1.8  2001/10/12 22:03:09  vsnyder
! Generate only the parameters if the add_ident file isn't specified
!
! Revision 1.7  2001/10/04 19:54:43  pwagner
! Now names file to be edited '<file_name_here>'
!
! Revision 1.6  2001/10/03 17:18:20  pwagner
! Added header warning against editing out_add, out_parm
!
! Revision 1.5  2001/07/25 19:57:30  vsnyder
! Correct blunder -- used 'names' instead of 'p_names'
!
! Revision 1.4  2001/07/25 19:47:22  vsnyder
! Added 'only' to 'use MACHINE'
!
! Revision 1.3  2001/07/25 18:49:08  vsnyder
! Change default input to stdin, add an option to specify otherwise
!
! Revision 1.2  2001/07/25 18:26:34  vsnyder
! Insert copyright notice
!
! Revision 1.1  2001/07/25 02:07:02  vsnyder
! Initial commit
!
@


1.11
log
@Reworded Copyright statement, moved rcs id
@
text
@d23 2
a24 1
  ! Blank lines don't count.
d33 1
a33 1
       "$RCSfile: MLSL2.f90,v $"
d35 1
a35 1
       "$Id: MLSL2.f90,v 2.138 2005/06/22 18:57:02 pwagner Exp $"
d216 1
a216 1
    if ( line(1:1) == '#' .or. line(1:1) == '!' ) cycle
d329 3
@


1.10
log
@Now trims header in out_add, too
@
text
@d1 10
a10 2
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d30 3
a32 1
!---------------------------- RCS Ident Info -------------------------------
d34 1
a34 1
       "$Id: init_gen.f90,v 1.9 2001/10/12 22:13:44 vsnyder Exp $"
a35 1
  character (len=*), parameter :: ModuleName = "$RCSfile: init_gen.f90,v $"
d328 3
@


1.9
log
@Put input file name in comment in output file
@
text
@d24 1
a24 1
       "$Id: init_gen.f90,v 1.8 2001/10/12 22:03:09 vsnyder Exp $"
d120 1
a120 1
      print *, 'Usage: ', trim(line), ' [options] out_parm out_add index_name'
d135 2
d278 1
a278 1
        write ( 11, '(a, a)' ) '! ', header(i)
d319 3
@


1.8
log
@Generate only the parameters if the add_ident file isn't specified
@
text
@d24 1
a24 1
       "$Id: init_gen.f90,v 1.7 2001/10/04 19:54:43 pwagner Exp $"
d52 1
a52 1
  character(len=*), dimension(3), parameter :: HEADER = (/ &
d77 9
d125 1
d238 1
a238 1
  if ( WRITEHEADER ) then
d240 2
a241 2
    do i = 1, size(HEADER)
      write ( 12, '(a, a)' ) '! ', HEADER(i)
d273 1
a273 1
    if ( WRITEHEADER ) then
d275 2
a276 2
      do i = 1, size(HEADER)
        write ( 11, '(a, a)' ) '! ', HEADER(i)
d317 3
@


1.7
log
@Now names file to be edited '<file_name_here>'
@
text
@d24 1
a24 1
       "$Id: init_gen.f90,v 1.6 2001/10/03 17:18:20 pwagner Exp $"
d31 2
d140 8
a147 3
  if ( out_add == ' ' ) then
    print *, 'No file name given for references to add_ident.'
    stop
a148 6
  call getarg ( i+2, index_name )
  if ( index_name == ' ' ) then
    print *, 'No name given for the array to store references to add_ident.'
    stop
  end if
  index_Wid = len_trim(index_name)
d158 6
a163 4
  open ( 11, file=out_add, form='formatted', iostat=iostat )
  if ( iostat /= 0 ) then
    call io_error ( 'Opening file for results of add_ident', iostat, inFile )
    stop
d194 1
a194 1
    if ( line(1:1) == '#' ) cycle
d200 6
d232 2
a233 2
    enddo
  endif
d260 9
a268 8
  ! Output the references to "add_ident"
  ! Warn off users from editing Out_add
  if ( WRITEHEADER ) then
    write ( 11, '(a, a)' ) '! File name: ', trim(Out_add)
    do i = 1, size(HEADER)
      write ( 11, '(a, a)' ) '! ', HEADER(i)
    enddo
  endif
d270 12
a281 11
  do i = 1, numNames
    if ( margin /= 0 ) then
      nspaces = margin - index_Wid - 10 - len_trim(p_names(i))
    else
      nspaces = maxwid - len_trim(p_names(i))
    end if
    write ( 11, '(4x,a,"(",a,") = ", a, "add_ident ( ''",a,"'' )")' ) &
      & index_name(:index_Wid), trim(p_names(i)), &
      & line(:nspaces), trim(names(i))
  end do
  close ( 11 )
d307 3
@


1.6
log
@Added header warning against editing out_add, out_parm
@
text
@d24 1
a24 1
       "$Id: init_gen.f90,v 1.5 2001/07/25 19:57:30 vsnyder Exp $"
d53 1
a53 1
    & 'Instead edit the file field_names.txt               ' &
d296 3
@


1.5
log
@Correct blunder -- used 'names' instead of 'p_names'
@
text
@d24 1
a24 1
       "$Id: init_gen.f90,v 1.4 2001/07/25 19:47:22 vsnyder Exp $"
d50 7
d218 8
d252 8
d296 3
@


1.4
log
@Added 'only' to 'use MACHINE'
@
text
@d24 1
a24 1
       "$Id: init_gen.f90,v 1.3 2001/07/25 18:49:08 vsnyder Exp $"
d215 1
a215 1
      nspaces = margin - decl_wid - len_trim(p_names(i)) - 4
d239 1
a239 1
      nspaces = margin - index_Wid - 10 - len_trim(names(i))
d273 3
@


1.3
log
@Change default input to stdin, add an option to specify otherwise
@
text
@d20 1
a20 1
  use MACHINE ! to get at least HP and IO_ERROR, and maybe GETARG
d24 1
a24 1
       "$Id: init_gen.f90,v 1.2 2001/07/25 18:26:34 vsnyder Exp $"
d273 3
@


1.2
log
@Insert copyright notice
@
text
@d24 1
a24 1
       "$Id: init_gen.f90,v 1.1 2001/07/25 02:07:02 vsnyder Exp $"
d34 1
a34 1
  character(len=127) :: InFile
d40 1
d62 6
d84 11
a94 1
    else if ( line(1:2) == '-p' ) then
d102 1
a102 1
      print *, 'Usage: ', trim(line), ' [options] input_file out_parm out_add index_name'
d106 1
d111 2
a114 1
      print *, ' input_file: The file of names'
d125 1
a125 6
  call getarg ( i, inFile )
  if ( inFile == ' ' ) then
    print *, 'No input file name given.'
    stop
  end if
  call getarg ( i+1, out_parm )
d130 1
a130 1
  call getarg ( i+2, out_add )
d135 1
a135 1
  call getarg ( i+3, index_name )
d142 6
a147 4
  open ( 10, file=inFile, form='formatted', status='old', iostat=iostat )
  if ( iostat /= 0 ) then
    call io_error ( 'Opening input file', iostat, inFile )
    stop
d162 2
a163 1
  ! Count the names
d165 3
a167 18
  do
    read ( 10, '(a)', iostat=iostat ) line
    if ( iostat < 0 ) exit
    if ( iostat > 0 ) then
      call io_error ( 'Reading input file', iostat, inFile )
      stop
    end if
    if ( line == ' ' ) cycle
    line = adjustl(line)
    if ( line(1:1) /= '#' ) numNames = numNames + 1
  end do
  rewind ( 10 )

  ! Allocate space for the names
  allocate ( names(numNames), stat=iostat )
  allocate ( P_names(numNames), stat=iostat )
  if ( iostat /= 0 ) then
    call io_error ( 'Allocating table to store the names', iostat )
a170 4
  ! Read the names.  Make sure the file size hasn't changed.  Calculate
  ! the width of the widest name.
  maxWid = 0
  i = 0
d172 4
a175 5
    read ( 10, '(a)', iostat=iostat ) line
    if ( iostat < 0 ) then
      if ( i == numNames ) exit
      print *, 'The file of names changed size!'
      stop
d177 1
d185 3
a187 3
    i = i + 1
    if ( i > numNames ) then
      print *, 'The file of names changed size!'
d191 1
a191 1
    p_names(i) = line(:j-1)
d194 1
a194 1
      names(i) = p_names(i)
d196 1
a196 1
      names(i) = line
d198 2
a199 2
    p_names(i) = trim(pfx) // p_names(i)
    maxWid = max(maxWid, len_trim(p_names(i)))
d273 3
@


1.1
log
@Initial commit
@
text
@d1 3
d17 1
a17 1
  ! The command line control everything else.  See the PRINT statements
d20 1
a20 1
  use MACHINE
d24 1
a24 1
       "$Id: machine.f90,v 1.2 2001/05/04 23:25:10 vsnyder Exp $"
d26 1
a26 1
  character (len=*), parameter :: ModuleName = "$RCSfile: machine.f90,v $"
d274 4
a277 1
! $Log: $
@

