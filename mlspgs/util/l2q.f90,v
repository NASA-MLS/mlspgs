head	1.40;
access;
symbols
	v5-02-NRT-19:1.40
	v6-00:1.40
	v5-02-NRT-18:1.40
	v5-02:1.40
	v5-01-NRT-17:1.40
	v5-01-NRT-16:1.40
	v5-01-NRT-15:1.40
	v5-01-NRT-14:1.40
	neuralnetworks-1-0:1.40.0.6
	cfm-single-freq-0-1:1.40.0.4
	v5-01:1.40
	v5-00:1.40
	v4-23-TA133:1.40.0.2
	mus-emls-1-70:1.39.0.4
	rel-1-0-englocks-work:1.39.0.2
	VUMLS1-00:1.39
	VPL1-00:1.39
	V4-22-NRT-08:1.38
	VAM1-00:1.38
	V4-21:1.37.0.2
	V4-13:1.37
	V4-12:1.36
	V4-11:1.36
	V4-10:1.36
	V3-43:1.29
	M4-00:1.32
	V3-41:1.29
	V3-40-PlusGM57:1.29.0.2
	V2-24-NRT-04:1.22
	V3-33:1.30
	V2-24:1.22
	V3-31:1.30
	V3-30-NRT-05:1.30
	cfm-01-00:1.30
	V3-30:1.29
	V3-20:1.29
	V3-10:1.27
	V2-23-NRT-02:1.22
	V2-23:1.22
	V2-22-NRT-01:1.22
	V2-22:1.22
	V2-21:1.18
	V2-20:1.14
	V2-11:1.11
	V2-10:1.11
	V2-00:1.10
	V1-51:1.4
	V1-50:1.3;
locks; strict;
comment	@# @;


1.40
date	2018.10.19.01.19.50;	author pwagner;	state Exp;
branches;
next	1.39;

1.39
date	2016.08.12.16.18.03;	author pwagner;	state Exp;
branches;
next	1.38;

1.38
date	2015.04.29.16.18.17;	author pwagner;	state Exp;
branches;
next	1.37;

1.37
date	2014.09.22.18.02.10;	author pwagner;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.09.00.31.26;	author pwagner;	state Exp;
branches;
next	1.35;

1.35
date	2013.08.23.02.51.48;	author vsnyder;	state Exp;
branches;
next	1.34;

1.34
date	2013.08.14.17.27.26;	author pwagner;	state Exp;
branches;
next	1.33;

1.33
date	2013.07.18.22.36.38;	author pwagner;	state Exp;
branches;
next	1.32;

1.32
date	2013.02.14.19.05.29;	author pwagner;	state Exp;
branches;
next	1.31;

1.31
date	2012.07.12.17.55.16;	author pwagner;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.03.23.36.07;	author pwagner;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.02.22.05.36;	author pwagner;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.17.20.25.46;	author pwagner;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.21.20.37.52;	author pwagner;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.09.17.06.19;	author pwagner;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.13.20.34.20;	author pwagner;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.10.17.52.04;	author pwagner;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.17.00.03.13;	author pwagner;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.06.23.37.36;	author pwagner;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.31.00.05.26;	author pwagner;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.29.21.00.21;	author pwagner;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.18.23.50.15;	author pwagner;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.09.21.24.22;	author pwagner;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.18.23.25.59;	author pwagner;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.12.00.41.16;	author pwagner;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.22.18.34.24;	author pwagner;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.03.21.27.26;	author pwagner;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.01.20.45.29;	author pwagner;	state Exp;
branches;
next	1.12;

1.12
date	2006.09.29.00.31.21;	author pwagner;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.02.22.48.22;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.15.22.39.58;	author pwagner;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.23.21.01.13;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2005.06.22.19.27.33;	author pwagner;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.12.20.32.19;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.18.00.59.36;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.03.19.10.11;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.20.00.54.25;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.14.21.39.04;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.23.00.19.30;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.09.00.42.46;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.40
log
@removed unused stuff; commented-out never-done do
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

program l2q
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, &
    & Test_Allocate, Test_Deallocate
  use Dates_Module, only: Dateform, Reformatdate
  use Dump_1, only: Dump
  use HighOutput, only: Output_Date_And_Time, OutputNamedValue, TimeStamp
  use L2ParInfo, only: Parallel, InitParallel
  use L2ParInfo, only: Machine_T, Parallel, &
    & Petitiontag, Giveuptag, Grantedtag, Masterdumptag, Notifytag, &
    & Sig_Finished, Sig_Register, Sig_Swearallegiance, Sig_Switchallegiance, &
    & Sig_Hostdied, Sig_Releasehost, Sig_Requesthost, Sig_Thankshost, &
    & Machinenamelen, Getmachinenames, &
    & Dump, AddmachinetoDatabase
  use Machine ! At Least Hp For Command Lines, And Maybe Getarg, Too
  use MLSCommon, only: FileNameLen
  use MLSL2Options, only: Current_Version_Id
  use MLSMessageModule, only: MLSMessage, MLSMessageConfig, MLSMessageExit, &
    & MLSMSG_Debug, MLSMSG_Error, &
    & MLSMSG_Info, MLSMSG_Success, MLSMSG_Warning, PVMErrorMessage
  use MLSFinds, only: Findfirst
  use MLSStringLists, only: CatLists, GetStringElement, NumStringElements, &
    & StringElementnum
  use MLSStrings, only: Lowercase, ReadIntsFromChars, Streq
  use Output_M, only: Blanks, Newline, &
    & Output, OutputOptions
  use PrintIt_M, only: Set_Config
  use PVM, only: PVMOK, &
    & ClearPVMArgs, Getmachinenamefromtid, &
    & PvmDatadefault, Pvmfinitsend, Pvmf90pack, Pvmfkill, Pvmfmytid, &
    & Pvmf90unpack, Pvmfpstat, &
    & Pvmfsend, Pvmfnotify, Pvmtaskexit, &
    & Pvmffreebuf
  use Sort_M, only: Sort
  use Time_M, only: Time_Now, Time_Config
  use Toggles, only: Gen, Levels, &
    & Toggle

  ! === (start of toc) ===
  !     c o n t e n t s
  !     - - - - - - - -

  ! Main program for queue manager of level 2 mastertasks
  ! === (end of toc) ===
  ! (It is assumed that pvm is already up and running)
  ! Usage:
  ! l2q [options] [--] [<] [list]
  ! where list is an ascii file which comes from one of
  ! (i)  a file named on the command line w/o the '<' redirection
  ! (ii) stdin or a file redirected as stdin using '<'
  
  ! For a list of options 
  ! l2q --help
  
  ! Bugs and limitations:
  ! --------------------
  ! (1) The dump_file, if used, is buffered by default (otherwise everything
  !       is slowed to an unacceptable pace during production)
  ! (2) The hosts named in the file list must match the names returned
  !       by the pvm subroutine PVMFConfig which normally takes its names
  !       from pvm's own input file;
  !       to be clearer, guard against the case where one file names its nodes
  !       "c0-nnn" and the other file something like "jet-0-nnn" because
  !       l2q won't recognize that they refer to the same machines

  implicit none

  integer :: BUFFERID
  character(len=2048) :: command_line ! All the opts
  logical, parameter :: COUNTEMPTY = .true.
  logical, parameter :: DEEBUG = .false.
  logical, parameter :: DUMPDBSONDEBUG = .false.
  integer :: ERROR
  integer :: I
  integer :: INFO
  integer :: INUNIT = -1       ! Input unit, * if < 0
  character(len=2048) :: LINE      ! Into which is read the command args
  integer, parameter :: LIST_UNIT = 20  ! Unit # for hosts file if not stdin
  character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES => null()
  integer, parameter :: MASTERNAMELEN = 16
  character(len=MasterNameLen) :: MASTERSNAME
  integer, parameter :: MAXNUMMASTERS = 100 ! Mas num running simultaneously
  integer :: RECL = 10000          ! Record length for list
  integer :: STATUS                ! From OPEN
  logical :: SWITCH                ! "First letter after -- was not n"
  real :: T0, T1, T2, T_CONVERSION ! For timing
  integer :: TAG
  integer :: TID                   ! Our own TID
  character(len=32) :: TIDSTR

  character(len=*), parameter :: GROUPNAME = "mlsl2"
  character(len=*), parameter :: LISTNAMEEXTENSION = ".txt"
  integer, parameter          :: AVOIDSELECTEDHOSTSTAG = GIVEUPTAG - 1
  integer, parameter          :: CHECKREVIVEDHOSTSTAG = AVOIDSELECTEDHOSTSTAG - 1
  integer, parameter          :: CHECKSELECTEDHOSTSTAG = CHECKREVIVEDHOSTSTAG - 1
  integer, parameter          :: CLEANMASTERDBTAG = CHECKSELECTEDHOSTSTAG - 1
  integer, parameter          :: DUMPDBTAG = CLEANMASTERDBTAG - 1
  integer, parameter          :: DUMPMASTERSDBTAG = DUMPDBTAG - 1
  integer, parameter          :: DUMPHOSTSDBTAG = DUMPMASTERSDBTAG - 1
  integer, parameter          :: FREEANYHOSTSTAG = DUMPHOSTSDBTAG - 1
  integer, parameter          :: FREEHOSTSTAG = FREEANYHOSTSTAG - 1
  integer, parameter          :: KILLMASTERSTAG = FREEHOSTSTAG - 1
  integer, parameter          :: SUICIDETAG = KILLMASTERSTAG - 1
  integer, parameter          :: SWITCHDUMPFILETAG = SUICIDETAG - 1
  integer, parameter          :: TELLMASTERDUMPTAG = SWITCHDUMPFILETAG - 1
  integer, parameter          :: TURNREVIVALSONTAG = TELLMASTERDUMPTAG - 1
  integer, parameter          :: TURNREVIVALSOFFTAG = TURNREVIVALSONTAG - 1

  ! These are special tid values
  integer, parameter          :: UNASSIGNED = -1
  integer, parameter          :: AWAITINGREVIVAL = UNASSIGNED - 1
  integer, parameter          :: AWAITINGTHANKS = AWAITINGREVIVAL - 1

  integer, parameter          :: DUMPUNIT = LIST_UNIT + 1
  integer, parameter          :: TEMPUNIT = DUMPUNIT + 1
  integer, parameter          :: HDBUNIT = TEMPUNIT + 1
  integer, parameter          :: MDBUNIT = HDBUNIT + 1
!---------------------------- RCS Ident Info ------------------------------
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: l2q.f90,v $"
  character (len=*), parameter :: IdParm = &
       "$Id: l2q.f90,v 1.39 2016/08/12 16:18:03 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
!---------------------------------------------------------------------------

  ! Our data type for the master tasks we'll be communicating with via pvm
  type master_T
    character(len=MACHINENAMELEN) :: name = ' '
    character(len=16            ) :: date = ' '
    integer                       :: tid = 0
    integer                       :: numChunks = 0
    integer                       :: numHosts = 0
    integer, dimension(:), pointer:: hosts => null() ! hosts assigned to this master
    logical                       :: needs_host = .false.
    logical                       :: owes_thanks = .false.
    logical                       :: finished = .false.
  end type master_T

!   ! This datatype logs a request for a host
!   type HostRequest_T
!     integer :: Master=0                 ! Which master made the request
!     integer :: CHUNK=0                  ! Which chunk is it for
!     integer :: TICKET=0                 ! What ticket number is it
!     integer :: STATUS=DW_INVALID        ! One of the DW_Status types
!   end type HostRequest_T

  type options_T
    logical            :: checkList = .false.
    logical            :: cleanMasterDB = .false. ! Regularly clean db of done
    logical            :: deferToElders = .true.  ! New masters defer to old
    logical            :: dumpEachNewMaster = .false.
    logical            :: verbose = .false.
    logical            :: freeHosts = .false.     ! Regularly check for abandoned
    logical            :: reviveHosts = .false.   ! Regularly check for revivals
    character(len=16)  :: command = 'run'         ! {run, kill, dumphdb, dumpmdb
    logical            :: debug = DEEBUG          !   dump, checkh, clean}
    integer            :: errorLevel = MLSMSG_Warning
    logical            :: exitOnError = .false.   ! quit if an error occurs
    character(len=FILENAMELEN) &
      &                :: LIST_file = '<STDIN>'   ! name of hosts file
    character(len=FILENAMELEN) &
      &                :: dump_file = '<STDIN>'   ! name of dump file
    character(len=FILENAMELEN) &
      &                :: HDBfile = ''            ! name of hosts DB file
    character(len=FILENAMELEN) &
      &                :: MDBfile = ''            ! name of masters DB file
    logical :: bufferedDumpFile = .true.          ! lack of buffering slows sips
    logical :: Rescue = .false.                   ! -R option is set
    logical :: Timing = .false.                   ! -T option is set
    logical :: date_and_times = .false.
    character(len=1)   :: timingUnits = 's'       ! l_s, l_m, l_h
    character(len=2048):: selectedHosts =''       ! E.g., 'c0-1,c0-23,c0-55'
    character(len=FILENAMELEN) &
      &                :: PMFile = ''        ! name of periodic Master dump file
    character(len=FILENAMELEN) &
      &                :: PHFile = ''        ! name of periodic host dump file
    real               :: MDBPeriod = 600.   ! Period (s) of Master dumps
    real               :: HDBPeriod = 600.   ! Periodic (s) host dumps
  end type options_T
  
  type ( options_T ) :: options
  type(Machine_T), dimension(:), pointer :: hosts => null()
  type(master_T), dimension(:), pointer :: masters => null()
  !
  call set_config ( useToolkit = .false., logFileUnit = -1 )
  MLSMessageConfig%CrashOnAnyError = .true.
  outputOptions%skipmlsmsglogging = .true.
  time_config%use_wall_clock = .true.
  parallel%master = .true.  ! not merely master, but master of masters
  parallel%slaveFilename = 'pvm' ! for later cures only
  !---------------- Task (0) ------------------
  call get_options
  options%verbose = options%verbose .or. options%debug
  select case (options%timingUnits)
  case ('m')
    t_conversion = 1./60
  case ('h')
    t_conversion = 1./3600
  case default
    t_conversion = 1.
  end select
  ! By default we won't to quit if an error occurs
  ! (unless you want us to)
  if ( options%exitOnError ) options%errorLevel = MLSMSG_Error
  ! Do we use buffered output?
  if ( options%dump_file /= '<STDIN>' ) then
    OutputOptions%prunit = DUMPUNIT
    OutputOptions%buffered = options%bufferedDumpFile ! .false.
    OutputOptions%name = options%dump_file
    ! print *, 'Opening ', prunit, ' as ', trim(options%dump_file)
    open(OutputOptions%prunit, file=trim(options%dump_file), &
      & status='replace', form='formatted')
  endif
  !---------------- Task (1) ------------------
  ! Is l2q already alive and running?
  call pvmfgettid(GROUPNAME, 0, tid)
  if ( tid > 0 ) then
    ! Have we been ordered to communicate with it?
    if ( options%command == 'inquire' ) then
      call timestamp( 'l2q queue manager already running' , advance='yes')
      call MLSMessageExit 
    elseif ( options%command /= 'run' ) then
      ! Our target will be listening for something like:
      ! call PVMFNRecv ( -1, GiveUpTag, bufferIDRcv )
      call PVMFInitSend ( PvmDataDefault, bufferID )
      call PVMF90Pack ( GROUPNAME, info )
      select case( trim(options%command) )
      case ( 'avoid' )
        tag = avoidSelectedHostsTag
      case ( 'check' )
        tag = checkSelectedHostsTag
      case ( 'checkall' )
        tag = checkRevivedHostsTag
      case ( 'clean' )
        tag = cleanMasterDBTag
      case ( 'dumpdb' )
        tag = dumpDBTag
      case ( 'dumphdb' )
        tag = dumpHostsDBTag
      case ( 'dumpmdb' )
        tag = dumpMastersDBTag
      case ( 'free' )
        tag = freeHostsTag
      case ( 'freeany' )
        tag = freeAnyHostsTag
      case ( 'kill' )
        tag = killMastersTag
      case ( 'revive=on' )
        tag = turnRevivalsOnTag
      case ( 'revive=off' )
        tag = turnRevivalsOffTag
      case ( 'suicide' )
        tag = suicideTag ! GiveUpTag
      case ( 'switch' )
        tag = switchDumpFileTag
      case ( 'tellmdump' )
        tag = tellMasterDumpTag
      case default
        call MLSMessage( MLSMSG_Error, ModuleName, &
          & 'l2q would not recognize unknown command '//trim(options%command) )
      end select
      if ( any(tag == &
        & (/avoidSelectedHostsTag, checkSelectedHostsTag, freeHostsTag, &
        & killMastersTag, tellMasterDumpTag/) )) &
        & then
        call PVMF90Pack ( trim(options%selectedHosts), info )
      else
        call PVMF90Pack ( trim(options%dump_file), info )
      endif
      call PVMFSend ( tid, Tag, info )
      if ( options%timing ) call sayTime
      call output('Already-running l2q tid: ', advance='no')
      call timestamp(tid, advance='yes')
      call timestamp(' commanded: '//trim(options%command), advance='yes')
      if ( any(tag == &
        & (/avoidSelectedHostsTag, checkSelectedHostsTag, freeHostsTag, &
        & killMastersTag, tellMasterDumpTag/) )) &
        & then
        call timestamp(trim(options%selectedHosts), advance='yes')
      elseif ( any(tag == (/dumpHostsDBTag, dumpMastersDBTag, dumpDBTag, &
        & switchDumpFileTag/) )) then
        call timestamp(trim(options%dump_file), advance='yes')
      endif
      call MLSMessageExit 
    else
      call MLSMessage( MLSMSG_Error, ModuleName, &
        & 'l2q queue manager already running' )
    endif
  endif

  if ( options%command == 'inquire' ) then                                 
    call timestamp( 'l2q queue manager not running' , advance='yes')   
    call MLSMessageExit                                                    
  elseif ( options%command /= 'run' ) then
    call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'l2q not running--ignoring command '//trim(options%command) )
  endif
  !---------------- Task (2) ------------------

  call time_now ( t0 )

  call InitParallel ( 0, 0 )
  call GetMachineNames ( machineNames )
  if ( .not. associated(machineNames) ) &
      & call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'unable to get machine names' )
  if ( size(machineNames) < 1 ) call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'machine names array of zero size' )
  ! Join (actually start) our group
  call PVMFJoinGroup ( GROUPNAME, status )
  if ( status < 0 ) &
    & call myPVMErrorMessage ( status, 'Joining '//GROUPNAME//' group' )
  ! Learn our own TID
  call pvmfmyTID( tid )
! Clear the command line arguments we're going to accumulate to pass
! to slave tasks
  call ClearPVMArgs

  !---------------- Task (3) ------------------
  ! Open the List of hosts
  status = 0
  options%LIST_file = '<STDIN>'
  if ( line /= ' ' ) then
    options%LIST_file = line
    open ( list_unit, file=line, status='old', &
     & form='formatted', access='sequential', recl=recl, iostat=status )
    if ( status /= 0 ) then
      options%LIST_file = trim(line) // LISTNAMEEXTENSION
       open ( list_unit, file=trim(line) // LISTNAMEEXTENSION, status='old', &
        & form='formatted', access='sequential', recl=recl, iostat=status )
    end if
    if ( status /= 0 ) then
      call io_error ( "While opening LIST", status, line )
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to open LIST file: " // trim(line) )
    elseif( options%verbose ) then                            
      call announce_success(options%LIST_file, list_unit)               
    end if
    inunit = list_unit
  end if
  error = status
  if ( .not. associated(machineNames) ) call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'unable to get machine names after reading list' )
  
  write( tidStr, * ) tid
  call output_date_and_time( msg='starting l2q  TID=' // trim(tidStr) )
  call time_now ( t1 )

  if( options%verbose  ) call dump_settings

  ! Read list of prospective hosts that will run slave tasks for masters
  call read_list
  call cure_host_database( hosts, silent=.true. )
  ! Are we rescuing an older l2q that died?
  if ( options%Rescue ) then
    ! Read Masters db
    open ( MDBUnit, file=options%MDBFile, status='old', &
     & form='formatted', access='sequential', recl=recl, iostat=status )
    if ( status /= 0 ) then
      call io_error ( "While opening MDBFile", status, options%MDBFile )
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to open MDB file: " // trim(options%MDBFile) )
    elseif( options%verbose ) then                            
      call announce_success( options%MDBFile, MDBUnit, 'rescued masters' ) 
    end if
    call read_master_database( Masters )
    close ( MDBUnit )
    ! Read Hosts db
    open ( HDBUnit, file=options%HDBFile, status='old', &
     & form='formatted', access='sequential', recl=recl, iostat=status )
    if ( status /= 0 ) then
      call io_error ( "While opening HDBFile", status, options%HDBFile )
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to open HDB file: " // trim(options%HDBFile) )
    elseif( options%verbose ) then                            
      call announce_success( options%HDBFile, HDBUnit, 'rescued hosts'  )               
    end if
    call read_host_database( Hosts )
    close ( HDBUnit )

    ! This was just a test
    ! call output_date_and_time(msg='ending l2q')
    ! if ( options%dump_file /= '<STDIN>' ) close(OutputOptions%prunit)
    ! stop

    ! call dump_master_database( Masters )
    do i=1, size(masters)
      call SwitchMastersAllegiance( Masters(i) )
    enddo
  end if
  if ( options%checkList ) then
    call dump(hosts)
  !---------------- Task (4) ------------------
  elseif (error == 0) then
    call dump(hosts, details=0)
    if ( .not. associated(machineNames) ) call MLSMessage( MLSMSG_Error, ModuleName, &
    & 'unable to get machine names before event_loop' )
    if ( size(machineNames) < 1 ) call MLSMessage( MLSMSG_Error, ModuleName, &
    & 'machine names array of zero size before event_loop' )
    if( options%verbose .or. DEEBUG ) call timestamp('Entering event loop', advance='yes')
    call event_loop( machineNames )
  else
    call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'error reading list of hosts' )
  end if

  call time_now ( t0 )
  t1 = t0
  if ( options%timing ) call sayTime ( 'Closing and deallocating' )
  call output_date_and_time(msg='ending l2q')
  if ( options%dump_file /= '<STDIN>' ) close(OutputOptions%prunit)

contains

  ! ---------------------------------------------  addMasterToDatabase  -----
  integer function  addMasterToDatabase( DATABASE, ITEM )
    ! This function adds a master data type to a database of said types,
    ! creating a new database if it doesn't exist.  The result value is
    ! the size -- where the new item is put.

    ! Dummy arguments
    type (master_t), dimension(:), pointer :: DATABASE
    type (master_t), intent(in) :: ITEM

    ! Local variables
    integer :: S
    type (Master_T), dimension(:), pointer :: tempDatabase
    !This include causes real trouble if you are compiling in a different 
    !directory.
    include "addItemToDatabase.f9h" 

    addMasterToDatabase = newSize
  end function  addMasterToDatabase

  ! ---------------------------------------------  announce_success  -----
  subroutine announce_success ( Name, unit_number, items )
    character(LEN=*), intent(in)             :: Name
    integer, intent(in)                      :: unit_number
    character(LEN=*), optional, intent(in)   :: items

    call output ( 'List of ' )
    if ( present(items) ) then
      call output ( trim(items) )
    else
    call output ( 'hosts' )
    endif
    call output ( ' file name : ' )
    call blanks(4)
    call output ( trim(Name), advance='no')
    call blanks(10)
    call output ( 'unit number : ' )
    call blanks(4)
    call timestamp ( unit_number, advance='yes')
  end subroutine announce_success

  ! ---------------------------------------------  assignHostToMaster  -----
  subroutine assignHostToMaster(host, master, hostsID)
    type(Machine_T) :: host
    type(master_t) :: master
    integer, intent(in) :: hostsID
    ! Internal variables
    integer :: bufferID
    integer :: hcid
    integer :: info
    integer, dimension(:), pointer :: tempHosts
    ! Executable
    ! 1st--check that host is free and OK
    if ( .not. (host%free .and. host%OK) ) then
      call dump(host)
      call dump_master(master)
      call myMLSMessage( options%errorLevel, ModuleName, &
      & 'Tried to assign an unqualified host to this master' )
    elseif( master%owes_thanks ) then
      call myMLSMessage( options%errorLevel, ModuleName, &
      & 'Tried to assign host to an ungrateful master' )
    endif      
    host%master_tid = master%tid
    host%free = .false.
    host%tid = AWAITINGTHANKS
    if ( options%debug ) then
       call output ('Number of machines free: ', advance='no')
       call timestamp (count(hosts%free .and. hosts%OK), advance='yes')
    endif
    hcid = 1
    if ( .not. associated(master%hosts) ) then
      nullify(master%hosts)
      call allocate_test(master%hosts, 1, 'master%hosts', moduleName)
    elseif( size(master%hosts) < 1 ) then
      call allocate_test(master%hosts, 1, 'master%hosts', moduleName)
    else
      ! We'll need a larger hosts component in master, so ..
      nullify(tempHosts)
      hcid = size(master%hosts) + 1
      call allocate_test(tempHosts, hcid, 'temphosts', moduleName)
      tempHosts(1:hcid-1) = master%hosts
      call deallocate_test(master%hosts, 'master%hosts', moduleName)
      master%hosts => tempHosts
    endif
    master%hosts(hcid) = hostsID
    ! Now use PVM to tell master he's got a new slave host
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( trim(host%name), info )
    mastersname = masterNameFun(master%Tid)
    if ( info /= 0 ) &
      & call myPVMErrorMessage ( info, 'packing host name' )
    if ( options%debug ) &
      & call proclaim('Sending new host ' // trim(host%name), &
      & mastersname)
    call PVMFSend ( master%tid, grantedTag, info )
    master%owes_thanks = .true.
    master%needs_host = .false.
    master%numHosts = master%numHosts + 1
  end subroutine assignHostToMaster
  
  ! ---------------------------------------------  clean_master_database  -----
  subroutine clean_master_database(Masters)
    ! clean master database of finished tasks
    type(Master_T), dimension(:), pointer :: Masters
    ! Internal variables
    integer :: i
    ! Executable
    ! call output('Trying to clean master db of finished tasks')
    do i=1, size(Masters)
      if (Masters(i)%finished) then
        call deallocate_test(Masters(i)%hosts, 'hosts', ModuleName)
        ! We can't delete the db entry because
        ! everybody knows masters by their db index
        ! All we can do is reclaim the little bit of the memory allocated
        ! for their hosts component
        ! call rmMasterFromDatabase(Masters, Masters(i))
      endif
    enddo
  end subroutine clean_master_database

  ! ---------------------------------------------  cure_host_database  -----
  subroutine cure_host_database(hosts, silent, selectedHosts)
    ! cure any recovered hosts in database--declare them useable ("OK")
    ! If optional selectedHosts is present, cure only them
    type(Machine_T), intent(inout), dimension(:) :: hosts
    logical, optional, intent(in) :: silent
    character(len=*), optional, intent(in) :: selectedHosts
    ! Internal variables
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES => null()
    logical :: mySilent
    integer :: i
    integer :: status
    ! Executable
    mySilent = .not. options%verbose
    if ( present(silent) ) mySilent = silent .or. mySilent
    ! No need to cure if none have died
    if ( .not. mySilent ) then
      call outputNamedValue( 'number hosts alive', count(hosts%OK) )
      call outputNamedValue( 'number hosts dead', count(.not. hosts%OK) )
    endif
    if ( all(hosts%OK) ) return    
    if ( .not. mySilent .and. present(selectedHosts) ) &
      & call dump( selectedHosts, 'selectedHosts' )
    call GetMachineNames ( machineNames )
    if ( .not. associated(machineNames) ) &
        & call myMLSMessage( MLSMSG_Error, ModuleName, &
        & 'unable to get machine names' )
    if ( size(machineNames) < 1 ) call myMLSMessage( MLSMSG_Error, ModuleName, &
        & 'machine names array of zero size' )
    if ( .not. mySilent .and. DEEBUG ) &
      & call dump( machineNames, 'machineNames' )
    do i=1, size(hosts)
      if ( hosts(i)%OK ) cycle
      ! Warning--following use of variable 'status' is non-standard
      ! status is good if non-zero, bad if 0
      status = 1
      if ( present(selectedHosts) ) &
        & status = StringElementNum(selectedHosts, trim(hosts(i)%name), .true.)
      if ( status < 1 ) cycle
      ! hosts(i)%OK = any( hosts(i)%name == machineNames )
      hosts(i)%OK = any( streq(hosts(i)%name, machineNames, '-f') )
      if ( hosts(i)%OK .and. .not. mySilent ) &
        & call proclaim('Host Cured', hosts(i)%Name)
      if ( .not. hosts(i)%OK .and. .not. mySilent ) &
        & call proclaim('Sorry--host still not useable', hosts(i)%Name)
      if ( .not. hosts(i)%OK .and. DEEBUG ) then
        call output( hosts(i)%name, advance='yes' )
        call dump( machineNames, 'machinenames' )
      endif
    enddo
    call deAllocate_test(machineNames, 'machineNames', moduleName )
  end subroutine cure_host_database

  ! ---------------------------------------------  dump_his_hosts  -----
  subroutine dump_his_hosts( hostIDs, sortUs )
    integer, dimension(:), intent(in)   :: hostIDs
    logical, intent(in), optional   :: sortUs
    ! Internal variables
    integer :: i
    integer, dimension(size(hostIDs)) :: myHostIDs
    character(len=MACHINENAMELEN), dimension(size(hostIDs)) :: myHostNames
    logical :: mySort
    integer :: maxNameLength
    ! Executable
    mySort = .false.
    if ( present(sortUs) ) mySort=sortUs
    myHostIDs = hostIDs
    if ( mySort ) call sort(myHostIDs, 1, size(hostIDs))
    maxNameLength = 1
    do i=1, size(hostIDs)
      myHostNames(i) = hosts(myHostIDs(i))%name
      maxNameLength = max(maxNameLength, len_trim(myHostNames(i)) + 1)
    enddo
    maxNameLength = min(maxNameLength, MACHINENAMELEN)
    call dump( myHostNames(:)(1:maxNameLength) )
  end subroutine dump_his_hosts

  ! ---------------------------------------------  dump_master_database  -----
  subroutine dump_master_database(Masters, Details)
    ! dump data type
    type(Master_T), dimension(:), pointer :: Masters
    integer, intent(in), optional :: DETAILS  ! 1: dump each master, too
    ! Internal variables
    integer :: i
    integer :: myDetails
    ! Executable
    if ( .not. associated(Masters) ) then
      call output('Master database not associated', advance='yes')
      return
    endif
    myDetails = 1
    if ( present(details) ) myDetails = details
    call output ('Size of Master database: ', advance='no')
    call output (size(Masters), advance='yes')
    call output ('Number of Masters active: ', advance='no')
    call output (count(.not. Masters%finished), advance='yes')
    call output ('Number of Masters waiting for hosts: ', advance='no')
    call output (count(Masters%needs_host), advance='yes')
    if ( myDetails < 1 ) return
    do i = 1, size(Masters)
      call dump_Master(Masters(i))
    enddo
  end subroutine dump_Master_database

  ! ---------------------------------------------  dump_Master  -----
  subroutine dump_Master(Master)
    ! dump data type
    type(Master_T), intent(in) :: Master
    call output('machine name: ', advance = 'no')
    call output(trim(Master%name), advance = 'yes')
    call output('date: ', advance = 'no')
    call output(trim(Master%date), advance = 'yes')
    call output('tid: ', advance = 'no')
    call output(Master%tid, advance = 'yes')
    call output('needs host?: ', advance = 'no')
    call output(Master%needs_host, advance = 'yes')
    call output('owes thanks?: ', advance = 'no')
    call output(Master%owes_thanks, advance = 'yes')
    call output('finished?: ', advance = 'no')
    call output(Master%finished, advance = 'yes')
  end subroutine dump_Master
   
  ! ---------------------------------------------  Dump_settings  -----
  subroutine Dump_settings
  ! Show current run-time settings
    call output(' l2q called with command line options: ', advance='no')
    call output(trim(command_line), advance='yes')
    call output(' LIST file:', advance='no')  
    call blanks(4, advance='no')                                     
    call output(trim(options%LIST_file), advance='yes')                            
    call output(' -------------- Summary of run time options'      , advance='no')
    call output(' -------------- ', advance='yes')
    call output(' Just check the host list:                       ', advance='no')
    call blanks(4, advance='no')
    call output(options%checkList, advance='yes')
    call output(' Debug               :                           ', advance='no')
    call blanks(4, advance='no')
    call output(options%debug, advance='yes')
    call output(' Verbose             :                           ', advance='no')
    call blanks(4, advance='no')
    call output(options%verbose, advance='yes')
    call output(' Dump each new master:                           ', advance='no')
    call blanks(4, advance='no')
    call output(options%dumpEachNewMaster, advance='yes')
    call output(' Regularly check for revived hosts:              ', advance='no')
    call blanks(4, advance='no')
    call output(options%reviveHosts, advance='yes')
    call output(' Regularly check and free abandoned hosts:       ', advance='no')
    call blanks(4, advance='no')
    call output(options%freeHosts, advance='yes')
    call output(' Regularly clean db of finished masters:         ', advance='no')
    call blanks(4, advance='no')
    call output(options%cleanMasterDB, advance='yes')
    call output(' New masters defer to old:                       ', advance='no')
    call blanks(4, advance='no')
    call output(options%deferToElders, advance='yes')
    if ( options%PMFile /= '') then
    call output(' Periodically dump Master DB to:                 ', advance='no')
    call blanks(4, advance='no')
    call output(trim(options%PMFile), advance='yes')
    call output(' Period (s):                                     ', advance='no')
    call blanks(4, advance='no')
    call output(options%MDBPeriod, advance='yes')
    endif
    if ( options%PHFile /= '') then
    call output(' Periodically dump host DB to:                   ', advance='no')
    call blanks(4, advance='no')
    call output(trim(options%PHFile), advance='yes')
    call output(' Period (s):                                     ', advance='no')
    call blanks(4, advance='no')
    call output(options%HDBPeriod, advance='yes')
    endif
    call output(' Dump other output to:                           ', advance='no')
    call blanks(4, advance='no')
    call output(trim(options%dump_File), advance='yes')
    call output(' Using unit number:                              ', advance='no')
    call blanks(4, advance='no')
    call output(OutputOptions%prunit, advance='yes')
    call output(' Time stamp each report:                         ', advance='no')
    call blanks(4, advance='no')
    call output(options%Timing, advance='yes')
    call output(' Show date and times:                            ', advance='no')
    call blanks(4, advance='no')
    call output(options%date_and_times, advance='yes')
    call output(' Stamp time in what units?:                       ', advance='no')
    call blanks(4, advance='no')
    call output(options%timingUnits, advance='yes' )
    call output(' Using wall clock instead of cpu time?:          ', advance='no')
    call blanks(4, advance='no')
    call output(time_config%use_wall_clock, advance='yes')
    call output(' Using buffered output?:                         ', advance='no')
    call blanks(4, advance='no')
    call output(Options%bufferedDumpFile, advance='yes')
    call output(' ----------------------------------------------------------', &
      & advance='yes')
  end subroutine Dump_settings

  ! ---------------------------------------------  event_loop  -----
  subroutine event_loop( machineNames )
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
    ! The main event loop
    ! l2q spends eternity circling endlessly, responding
    ! to the occasional promptings from master tasks via pvm
    ! or else initiating a contact with one
    ! or responding to commands sent by a fraternal l2q launched with
    ! "-c command" option
    integer :: bufferIDRcv
    integer :: BYTES                    ! Dummy from PVMFBufInfo
    logical :: CHECKREVIVEDHOSTS
    logical :: CLEANMASTERDB
    logical :: DUMPHOSTS
    logical :: DUMPMASTERS
    logical :: FREEABANDONEDHOSTS
    integer :: grandMastersID           ! index into database of an older master
    integer :: host
    integer :: hostsID                  ! index into database of a host
    integer :: i
    integer, dimension(MAXNUMMASTERS) :: IDs
    integer :: INFO                     ! From PVM
    character(len=MachineNameLen)  :: MACHINENAME
    integer :: mastersID                ! index into database of a master
    integer :: masterTid                ! TID of a master
    logical :: mayAssignAHost
    integer :: MSGTAG                   ! Dummy from PVMFBufInfo
    integer :: nextFree
    integer :: numHosts
    integer :: numMasters
    logical :: opened
    integer :: SIGNAL                   ! From a master
    character(len=16) :: SIGNALSTRING
    logical :: SIGNIFICANTEVENT
    logical :: SKIPDELAY            ! Don't wait before doing the next go round
    integer :: STATUS
    character(len=FileNameLen)  :: tempfile
    integer :: TID
    real    :: tLastHDBDump
    real    :: tLastMDBDump
    type(master_t) :: aMaster
    ! Executable
    if ( .not. associated(machineNames) ) call MLSMessage( MLSMSG_Error, ModuleName, &
    & 'unable to get machine names in event_loop' )
    if ( size(machineNames) < 1 ) call MLSMessage( MLSMSG_Error, ModuleName, &
    & 'machine names array of zero size in event_loop' )
    numMasters = 0
    tLastHDBDump = 0.
    tLastMDBDump = 0.
    ! call timeStamp( 'Looping over events', advance='yes' )
    do
      checkrevivedhosts = .false.
      dumpHosts = .false.
      dumpMasters = .false.
      freeabandonedhosts = .false.
      mayAssignAHost = .true.
      significantEvent = .false.
      skipDelay = .false.               ! Assume we're going to delay
      ! Listen out for pvm events
      call PVMFNRecv( -1, PETITIONTAG, bufferIDRcv )
      if ( bufferIDRcv < 0 ) then
        call myPVMErrorMessage ( info, "checking for Petition message" )
      else if ( bufferIDRcv > 0 ) then
        ! So we got a message.  There may be another one following on so don't 
        ! delay before going round this loop again.
        skipDelay = .true.
        ! Who sent this?
        call PVMFBufInfo ( bufferIDRcv, bytes, msgTag, masterTid, info )
        if ( info /= 0 ) &
          & call myPVMErrorMessage ( info, "calling PVMFBufInfo" )
        call PVMF90Unpack ( signal, info )
        if ( info /= 0 ) then
          call myPVMErrorMessage ( info, "unpacking signal" )
        endif
        ! if ( options%debug ) call proclaim('Master sent message', signal=signal)
        select case (signal) 

        case ( sig_register ) ! ----------------- Master registering ------
          call PVMF90Unpack ( aMaster%NumChunks, info )
          if ( info /= 0 ) then
            call myPVMErrorMessage ( info, "unpacking number of chunks" )
          endif
          call PVMF90Unpack ( aMaster%date, info )
          if ( info /= 0 ) then
            call myPVMErrorMessage ( info, "unpacking date string" )
          endif
          aMaster%tid = masterTid
          call GetMachineNameFromTid ( masterTid, aMaster%Name, info )
          if ( info == -1 ) & 
            & call myMLSMessage( options%errorLevel, ModuleName, &
            & 'Unable to get machine name from tid' )
          aMaster%NumHosts = 0
          aMaster%needs_Host = .false.
          aMaster%owes_thanks = .false.
          aMaster%finished = .false.
          numMasters = addMasterToDatabase(masters, aMaster)
          significantEvent = .true.
          ! masterName = catlists('m-', numMasters)
          ! Now ask to be notified when this master exits
          call PVMFNotify ( PVMTaskExit, NotifyTag, 1, (/ masterTid /), info )
          if ( info /= 0 ) call myPVMErrorMessage ( info, 'setting up notify' )
          if ( options%verbose ) then
            ! call proclaim('New Master', aMaster%Name, signal=MasterTid, advance='no')
            mastersname = masterNameFun(masterTid)
            call proclaim('New Master', mastersname, advance='no')
            call output(' (', advance='no')
            call output(count(.not. masters%finished), advance='no')
            call output(' active ', advance='no')
            call output(numMasters, advance='no')
            call timestamp(' total)', advance='yes')
          endif
          if ( options%dumpEachNewMaster ) call dump_master(aMaster)
          dumpMasters = .true.
        case ( sig_requestHost ) ! ----------------- Request for host ------
          ! Find master's index into masters array
          mastersID = FindFirst(masters%tid, masterTid)
          grandMastersID = FindFirst(masters%needs_host .and. &
            & .not. masters%owes_thanks)
          if ( options%deferToElders ) &
            grandMastersID = FindFirst(.not. masters%finished .and. &
            &  masters%needs_host )
          if ( grandMastersID < 1 ) grandMastersID = size(masters) + 100
          mastersname = masterNameFun(masterTid)
          if ( options%debug ) &
            & call proclaim('Master requested host', mastersname)
          ! Any free hosts?
          nextFree = FindFirst( hosts%free .and. hosts%OK )
          if ( masters(mastersID)%owes_thanks ) then
            ! Don't assign hosts to ungrateful masters
            mastersname = masterNameFun(masterTid)
            if ( options%verbose ) &
              & call proclaim('Ungrateful master requested another host', &
              & mastersname, advance='yes')
            masters(mastersID)%needs_host = .true.
          elseif ( nextFree == 0 ) then
            ! No hosts free; master put into needs_host state
            masters(mastersID)%needs_host = .true.
          elseif ( grandMastersID < mastersID ) then
            ! An older master has priority; master put into needs_host state
            masters(mastersID)%needs_host = .true.
          else
            ! Assign free host to master
            call assignHostToMaster( hosts(nextFree), masters(mastersID), nextFree )
            mayAssignAHost = .false. ! Already did one this cycle
          endif
        case ( sig_releaseHost ) ! ----------------- Done with this host ------
          ! Find master's index into masters array
          mastersID = FindFirst(masters%tid, masterTid)
          call IDHostFromMaster(sig_releaseHost, tid, hostsID)
          if ( mastersID < 1 ) then
            call myMLSMessage( MLSMSG_Warning, ModuleName, &
              & 'Unknown master attempted to free a host' )
          elseif ( hostsID > 0 ) then
            call releaseHostFromMaster( hosts(hostsID), masters(mastersID), &
              & hostsID )
            if ( options%debug ) then
              mastersname = masterNameFun(masterTid)
              call proclaim('Master ' // trim(mastersname) // &
                & ' freed host', hosts(hostsID)%name, advance='no')
              call output(' (Still has ', advance='no')
              call output(masters(mastersID)%numHosts, advance='no')
              call timestamp(' remaining)', advance='yes')
              call output ('Number of machines free: ', advance='no')
              call timestamp (count(hosts%free .and. hosts%OK), advance='yes')
            endif
            mayAssignAHost = ( mastersID < size(masters) ) ! .false. ! Don't assign to a later master
          else
            call timestamp ( 'Unknown host freed by master', advance='yes')
          endif

          ! In case the master's thanks was somehow lost
          if ( mastersID > 0 ) masters(mastersID)%owes_thanks = .false.
          dumpHosts = .true.
        case ( sig_ThanksHost ) ! -------------- Happy with this host ------
          ! Find master's index into masters array
          mastersID = FindFirst(masters%tid, masterTid)
          masters(mastersID)%owes_thanks = .false.
          ! if ( options%debug ) &
          !   & call proclaim('Master thanks for host', signal=masterTid)
          call PVMF90Unpack ( tid, info )
          if ( info /= 0 ) then
            call myPVMErrorMessage ( info, "unpacking tid" )
          endif
          call PVMF90Unpack ( machineName, info )
          if ( info /= 0 ) then
            call myPVMErrorMessage ( info, "unpacking machineName" )
          endif
          hostsID = FindFirst(  hosts%name==machineName .and. &
            & hosts%tid == AWAITINGTHANKS .and. hosts%master_tid == masterTid )
          if ( hostsID < 1 ) then
            call output(' mastersID ', advance='no')
            call output(mastersID , advance='yes')
            call output(' machineName ', advance='no')
            call output(trim(machineName) , advance='yes')
            call myMLSMessage( options%errorLevel, ModuleName, &
               & 'Master thanked us for unknown host' )
          endif
          hosts(hostsID)%tid = tid
          call PVMF90Unpack ( hosts(hostsID)%chunk, info )
          if ( info /= 0 ) then
            call myPVMErrorMessage ( info, "unpacking machine%chunk" )
          endif
          call PVMF90Unpack ( hosts(hostsID)%master_date, info )
          if ( info /= 0 ) then
            call myPVMErrorMessage ( info, "unpacking machine%master_date" )
          endif
          ! masters(mastersID)%date = hosts(hostsID)%master_date
          hosts(hostsID)%master_name = masterNameFun(masterTID)
          if ( options%verbose ) then
            mastersname = masterNameFun(masterTid)
            call proclaim('Master ' // trim(mastersname) // &
            & ' thanks for host', hosts(hostsID)%Name, advance='no')
            call output(' ; tid ', advance='no')
            call output(tid, advance='no')
            call output(' (Now has ', advance='no')
            call output(masters(mastersID)%numHosts, advance='no')
            call timestamp(' )', advance='yes')
          endif
          dumpHosts = .true.
        case ( sig_HostDied ) ! -------------- Done away with this host ------
          ! Find master's index into masters array
          mastersID = FindFirst(masters%tid, masterTid)
          mastersname = masterNameFun(masterTid)
          if ( options%debug ) &
            & call proclaim('Master ' // trim(mastersname) // &
            & ' reports host died', advance='no')
          call IDHostFromMaster(sig_HostDied, tid, hostsID)
          if ( hostsID > 0 ) then
            call releaseHostFromMaster( hosts(hostsID), masters(mastersID), &
              & hostsID )
            ! Mark this host and any others sharing the same node
            ! hosts(hostsID)%OK = .false.
            call mark_host_database(hosts, trim(hosts(hostsID)%name))
            significantEvent = .true.
            if ( options%debug ) then
              call output( ' Host ' // trim(hosts(hostsID)%Name), advance='no')
              call output(' (Now has ', advance='no')
              call output(masters(mastersID)%numHosts, advance='no')
              call timestamp(' )', advance='yes')
            elseif ( options%verbose ) then
              call proclaim('Host Died', hosts(hostsID)%Name)
            endif
          endif
          dumpHosts = .true.
          ! In case we were waiting for grateful acknowledgement
          masters(mastersID)%owes_thanks = .false.
        case ( sig_Finished ) ! ----------------- Done with this master ------
          ! Find master's index into masters array
          mastersID = FindFirst(masters%tid, masterTid)
          numHosts = 0
          if ( associated(masters(mastersID)%hosts) ) &
            & numHosts = size(masters(mastersID)%hosts) ! masters(mastersID)%numHosts
          if ( numHosts > 0 ) then
            do host = 1, numHosts
              hostsID = masters(mastersID)%hosts(host)
              if ( hostsID > 0 .and. hostsID <= size(hosts) ) &
                & call releaseHostFromMaster( &
                & hosts(hostsID), masters(mastersID), hostsID )
            enddo
          endif
          masters(mastersID)%finished = .true.
          masters(mastersID)%needs_host = .false.
          masters(mastersID)%owes_thanks = .false.
          ! call deAllocate_test(masters(mastersID)%hosts, 'hosts', moduleName )
          significantEvent = .true.
          if ( options%verbose ) then
            mastersname = masterNameFun(masterTid)
            call proclaim('Master ' // trim(mastersname) // &
              & ' Finished', advance='no')
            call output(' (', advance='no')
            call output(count(.not. masters%finished), advance='no')
            call output(' active ', advance='no')
            call output(numMasters, advance='no')
            call timestamp(' total)', advance='yes')
          endif
          dumpMasters = .true.
        case default
          write(SIGNALSTRING, *) signal
          mastersname = masterNameFun(masterTid)
          if ( options%debug ) &
            & call proclaim( 'Unrecognized signal from Master ' // &
            & mastersname )
          call myMLSMessage( options%errorLevel, ModuleName, &
             & 'Unrecognized signal from master' )
        end select
        call PVMFFreeBuf ( bufferIDRcv, info )
        if ( options%debug .and. info /= 0 ) &
          & call timestamp('Trouble freeing buf', advance='yes')
        if ( info /= 0 ) &
          & call myPVMErrorMessage ( info, 'freeing receive buffer' )
      endif
      ! ----------------------------------------------------- Master Task Died?
      ! Listen out for any message telling us one of our masters died
      call PVMFNRecv ( -1, NotifyTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        ! Get the TID for the dead task
        call PVMF90Unpack ( masterTid, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking dead masterTid' )
        ! Now this may well be a legitimate exit, 
        ! in which case, master finished normally.  
        mastersID = FindFirst(masters%tid, masterTid)
        if ( mastersID < 1 ) call myMLSMessage( options%errorLevel, ModuleName, &
           & 'Exit signal from unrecognized master' )
        if ( .not. masters(mastersID)%finished ) then
          ! Otherwise we need to tidy up.
          numHosts = 0
          if ( associated(masters(mastersID)%hosts) ) &
            & numHosts = size(masters(mastersID)%hosts) ! masters(mastersID)%numHosts
          if ( numHosts > 0 ) then
            do host = 1, numHosts
              hostsID = masters(mastersID)%hosts(host)
              if ( hostsID > 0 .and. hostsID <= size(hosts) ) &
                & call releaseHostFromMaster( &
                & hosts(hostsID), masters(mastersID), hostsID )
            enddo
          endif
          masters(mastersID)%finished = .true.
          masters(mastersID)%needs_host = .false.
          masters(mastersID)%owes_thanks = .false.
          significantEvent = .true.
          if ( options%verbose ) then
            mastersname = masterNameFun(masterTid)
            call proclaim('Master Died', mastersname)
            call output(' (', advance='no')
            call output(count(.not. masters%finished), advance='no')
            call output(' active ', advance='no')
            call output(numMasters, advance='no')
            call timestamp(' total)', advance='yes')
          endif
        endif
        dumpMasters = .true.
      endif
      ! ----------------------------------------------------- Administrative messages?
      ! Listen out for any message telling *us* to quit now
      call PVMFNRecv ( -1, suicideTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        if ( options%timing ) call sayTime
        call timestamp ( 'Received an external message to give up, so finishing now', &
          & advance='yes' )
        exit ! event_loop
      end if

      ! Listen out for any message telling us to stop regular revivals
      call PVMFNRecv ( -1, turnRevivalsOffTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        call timestamp ( 'Received an external message to stop regular revivals', &
          & advance='yes' )
        options%reviveHosts = .false.
      end if
      ! Listen out for any message telling us to resume regular revivals
      call PVMFNRecv ( -1, turnRevivalsOnTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        call timestamp ( 'Received an external message to resume regular revivals', &
          & advance='yes' )
        options%reviveHosts = .true.
      end if

      cleanMasterDB = significantEvent .and. options%cleanMasterDB
      ! Listen out for any message telling us to clean master database
      call PVMFNRecv ( -1, CleanMasterDBTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) &
        & call timestamp ( 'Received an external message to clean masterDB', &
          & advance='yes' )
      if ( bufferIDRcv > 0 .or. cleanMasterDB ) then
        if ( options%debug .and. bufferIDRcv < 1 ) &
          & call timestamp('Cleaning database of finished masters', advance='yes')
        call clean_master_database(Masters)
      endif

      checkrevivedhosts  = significantEvent .and. options%reviveHosts
      freeabandonedhosts = significantEvent .and. options%freeHosts
      ! Listen out for any message telling us to dump databases
      call PVMFNRecv ( -1, DumpDBTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        call PVMF90Unpack ( tempfile, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking dumpfile' )
        call redumpHosts( hosts, tempFile, tempUnit )
        call redumpMasters( masters, tempFile, tempUnit )
        dumpHosts = .true.
        dumpMasters = .true.
      end if
      call PVMFNRecv ( -1, DumpHostsDBTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        call PVMF90Unpack ( tempfile, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking dumpfile' )
        call redumpHosts( hosts, tempFile, tempUnit )
        dumpHosts = .true.
      end if
      call PVMFNRecv ( -1, DumpMastersDBTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        call PVMF90Unpack ( tempfile, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking dumpfile' )
        call redumpMasters( masters, tempFile, tempUnit )
        dumpMasters = .true.
      end if
      ! Listen out for any message telling us to kill selected masters
      call PVMFNRecv ( -1, killMastersTag, bufferIDRcv )
      ! Do it if so commanded
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        call PVMF90Unpack ( options%selectedHosts, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking selectedHosts' )
        call timestamp ( 'Received an external message to kill masters ' // &
          & trim(options%selectedHosts), advance='yes' )
        call IDMasterFromName( masters, options%selectedHosts, IDs )
        do i = 1, count( IDs > 0 )
          if ( Ids(i) < 1 .or. Ids(i) > size(masters) ) then
            call timestamp ( 'DB lacks any master matching ' // &
              & trim(options%selectedHosts), advance='yes' )
          else
            call timestamp ( 'killing master ' // &
              & trim(masters(Ids(i))%name), advance='yes' )
            if ( options%verbose ) call dump_Master( masters(Ids(i)) )
            call PVMFSend ( masters(Ids(i))%tid, giveUpTag, info )
            masters(Ids(i))%needs_host = .false. ! So we don't assign it hosts
          endif
        enddo
        dumpMasters = .true.
      end if
      ! Listen out for any message telling us to avoid selected hosts
      call PVMFNRecv ( -1, avoidSelectedHostsTag, bufferIDRcv )
      ! Do it if so commanded
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        call PVMF90Unpack ( options%selectedHosts, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking selectedHosts' )
        call timestamp ( 'Received an external message to avoid ' // &
          & trim(options%selectedHosts), advance='yes' )
        call mark_host_database(hosts, options%selectedHosts)
        dumpHosts = .true.
      end if
      ! Listen out for any message telling us to free hosts
      ! belonging to finished masters
      call PVMFNRecv ( -1, freeAnyHostsTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        call timestamp ( 'Received an external message to free hosts' &
        &  // ' belonging to finished masters', advance='yes' )
      endif
      if ( bufferIDRcv > 0 .or. freeabandonedhosts ) then
        call free_hosts( hosts, machineNames, masters=masters )
        dumpHosts = .true.
      endif
      ! Listen out for any message telling us to free specified hosts 
      call PVMFNRecv ( -1, freeHostsTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        call PVMF90Unpack ( options%selectedHosts, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking selectedHosts' )
        call timestamp ( 'Received an external message to free ' // &
          & trim(options%selectedHosts), advance='yes' )
        call free_hosts( hosts, machineNames )
        dumpHosts = .true.
      endif
      ! Listen out for any message telling us to check for revived hosts
      call PVMFNRecv ( -1, checkRevivedHostsTag, bufferIDRcv )
      ! Do it if so commanded, or if part of regular drill
      if ( bufferIDRcv > 0 ) call timestamp ( &
        & 'Received an external message to check for revivals', advance='yes' )
      if ( bufferIDRcv > 0 .or. checkrevivedhosts ) then
        call cure_host_database( hosts )
        dumpHosts = .true.
      endif
      ! Listen out for any message telling us to revive selected hosts
      call PVMFNRecv ( -1, checkSelectedHostsTag, bufferIDRcv )
      ! Do it if so commanded
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        call PVMF90Unpack ( options%selectedHosts, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking selectedHosts' )
        call timestamp ( 'Received an external message to check ' // &
          & trim(options%selectedHosts), advance='yes' )
        call cure_host_database(hosts, .false., options%selectedHosts)
        dumpHosts = .true.
      end if
      ! Listen out for any message telling us to flush current dumpfile
      ! and switch future output to new one
      call PVMFNRecv ( -1, switchDumpFileTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        if ( OutputOptions%prunit == DUMPUNIT ) then
          if ( options%timing ) call sayTime
          tempfile = options%dump_file
          call output('Switching dump file from '//trim(options%dump_file))
          call output(' to ')
          call PVMF90Unpack ( options%dump_file, info )
          if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking newdumpfile' )
          call timestamp(trim(options%dump_file), advance='yes')
          close(DUMPUNIT)
          ! print *, 'Opening ', prunit, ' as ', trim(options%dump_file)
          open( OutputOptions%prunit, file=trim(options%dump_file), &
            & status='replace', form='formatted', iostat=status )
          if ( status /= 0 ) then
            call myMLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'No new dumpfile; unable to open ' // &
              & trim(options%dump_file) )
            options%dump_file = tempfile
            open( OutputOptions%prunit, file=trim(options%dump_file), &
              & status='replace', form='formatted', iostat=status )
            if ( status /= 0 ) call myMLSMessage( options%errorLevel, ModuleName, &
              & 'Now we cant even revert to old dumpfile; unable to open ' // &
              & trim(options%dump_file) )
          else
            call timestamp('(new dump file opened)', advance='yes')
          endif
        else
          call timestamp('(switchDumpFileTag ignored--dumping to <STDIN>)', &
            & advance='yes')
        end if
      end if
      ! Listen out for any message telling us to tell selected masters to dump
      call PVMFNRecv ( -1, tellMasterDumpTag, bufferIDRcv )
      ! Do it if so commanded
      if ( bufferIDRcv > 0 ) then
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking GROUPNAME' )
        call PVMF90Unpack ( options%selectedHosts, info )
        if ( info /= 0 ) call myPVMErrorMessage ( info, 'unpacking selectedHosts' )
        call timestamp ( 'Received an external message to tell masters to dump ' // &
          & trim(options%selectedHosts), advance='yes' )
        call IDMasterFromName( masters, options%selectedHosts, IDs )
        do i = 1, count( IDs > 0 )
          if ( Ids(i) < 1 .or. Ids(i) > size(masters) ) then
            call timestamp ( 'DB lacks any master matching ' // &
              & trim(options%selectedHosts), advance='yes' )
          else
            call timestamp ( 'telling master ' // &
              & trim(masters(Ids(i))%name) // ' to dump', advance='yes' )
            if ( options%verbose ) call dump_Master( masters(Ids(i)) )
            call PVMFSend ( masters(Ids(i))%tid, masterDumpTag, info )
          endif
        enddo
        dumpMasters = .true.
      end if
      ! Unless there's a good reason not to do so,
      ! check if any hosts are currently free and any masters need hosts
      if ( mayAssignAHost .and. associated(masters) ) then
        ! Find oldest master needing a host and grateful for the ones he has
        mastersID = FindFirst( masters%needs_host .and. &
          & .not. masters%owes_thanks )
        grandMastersID = mastersID
        if ( options%deferToElders ) &
          grandMastersID = FindFirst(.not. masters%finished .and. &
            &  masters%needs_host )
        if ( grandMastersID < 1 ) grandMastersID = size(masters) + 100
        if ( mastersID > 0 .and. mastersID == grandMastersID ) then
          ! Find first free host
          nextFree = FindFirst( hosts%free .and. hosts%OK )
          if ( nextFree > 0 ) then
            call assignHostToMaster( hosts(nextFree), masters(mastersID), &
              & nextFree )
            skipDelay = .true.
          endif
        endif
      endif
      ! Now perform any other housekeeping, administration, etc. tasks
      ! Perhaps a periodic dump of hosts
      if ( options%PHFile /= ' ' ) then
        call time_now ( t2 )
        if ( (t2-tLastHDBDump > options%HDBPeriod) .or. dumpHosts ) then
          call reDumpHosts ( hosts, options%PHFile, tempUnit )
          tLastHDBDump = t2
          if ( options%debug .and. DUMPDBSONDEBUG ) then
            inquire(unit=OutputOptions%prunit, opened=opened)
            if ( .not. opened ) call myMLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Miscellaneous dump file not opened ' // &
              & trim(options%dump_file) )
            call dump(hosts)
          endif
        endif
      endif
      ! Perhaps a periodic dump of masters
      if ( options%PMFile /= ' ' ) then
        call time_now ( t2 )
        if ( (t2-tLastMDBDump > options%MDBPeriod) .or. dumpMasters ) then
          call reDumpMasters( masters, options%PMFile, tempUnit )
          tLastMDBDump = t2
          if ( options%debug .and. DUMPDBSONDEBUG ) then
            inquire(unit=OutputOptions%prunit, opened=opened)
            if ( .not. opened ) call myMLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Miscellaneous dump file not opened ' // &
              & trim(options%dump_file) )
            call dump_master_database(masters)
          endif
        endif
      endif
      ! Now, rather than chew up cpu time on this machine, we'll wait a
      ! bit here.
      if ( .not. skipDelay .and. parallel%delay > 0 ) then
        call usleep ( parallel%delay )
      endif
    enddo
  end subroutine event_loop
  
  ! ---------------------------------------------  free_hosts  -----
  subroutine free_hosts(hosts, machineNames, masters, silent)
    ! free any hosts in database 
    ! (1) specified in options%selectedHosts; or
    ! (2) belonging to finished masters
    type(Machine_T), intent(inout), dimension(:)       :: hosts
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
    type(Master_T), optional, intent(in), dimension(:) :: masters
    logical, optional, intent(in) :: silent
    ! Internal variables
    integer :: i
    integer :: masterID
    logical :: mySilent
    integer :: selected
    ! Executable
    mySilent = .not. options%verbose
    if ( present(silent) ) mySilent = silent .or. mySilent
    if ( size(hosts) < 1 ) return
    ! No need to free if all are
    if ( all(hosts%free) ) return
    if ( .not. present(masters) ) then
      ! usage (1) 
      if ( .not. associated(machineNames) ) call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'unable to get machine names in free_hosts' )
      if ( size(machineNames) < 1 ) call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'machine names array of zero size in free_hosts' )
      if ( DEEBUG ) call timeStamp('selected hosts to free: ' // trim(options%selectedHosts), advance='yes' )
      do i=1, size(hosts)
        if ( hosts(i)%free ) cycle
        if ( DEEBUG ) call timeStamp('checking: '// trim(hosts(i)%name) // ' ' )
        selected = StringElementNum(options%selectedHosts, trim(hosts(i)%name), .true.)
        if ( DEEBUG ) call timeStamp(selected, advance='yes' )
        if ( selected < 1 ) cycle
        ! hosts(i)%free = any( hosts(i)%name == machineNames )
        hosts(i)%free = any( streq(hosts(i)%name, machineNames, '-f') )
        if ( hosts(i)%free .and. .not. mySilent ) &
          & call proclaim('Host freed', hosts(i)%Name)
        if ( .not. hosts(i)%free .and. DEEBUG ) then
          call output( hosts(i)%name, advance='yes' )
          call dump( machineNames, 'machinenames' )
        endif
      enddo
      return
    endif
    ! usage (2) 
    if ( size(masters) < 1 ) return
    ! 
    if ( .not. any(masters%finished) ) return
    do i=1, size(hosts)
      if ( hosts(i)%free ) cycle
      masterID = findFirst( hosts(i)%master_tid == masters%tid )
      if ( masterID > 0 ) &
        & hosts(i)%free = masters(masterID)%finished
    enddo
  end subroutine free_hosts

  ! ---------------------------------------------  get_options  -----
  subroutine get_options
    ! Internal variables
    integer :: i
    integer :: j
    integer :: lineVal
    integer :: n
    character(len=8) :: subcase
    ! Executable
    i = 1+hp
    command_line = ' '
    do ! Process Lahey/Fujitsu run-time options; they begin with "-Wl,"
      call getarg ( i, line )
      if ( line(1:4) /= '-Wl,' ) exit
      i = i + 1
    end do
    do ! Process the command line options to set toggles
      call getarg ( i, line )
      ! call output( 'Processing ' // trim(line), advance='yes' )
      command_line = trim(command_line) // ' ' // trim(line)
      if ( line(1:2) == '--' ) then       ! "word" options
        n = 0
        switch = .true.
        if ( line(3:3) == 'n' .or. line(3:3) == 'N' ) then
          switch = .false.
          n = 1
        end if
        if ( line(3+n:5+n) == 'buf' ) then
          options%bufferedDumpFile = switch
        elseif ( line(3+n:7+n) == 'clean ' ) then
          options%cleanMasterDB = switch
        elseif ( line(3+n:7+n) == 'check ' ) then
          options%checklist = switch
        elseif ( line(3+n:7+n) == 'defer' ) then
          options%deferToElders = switch
        elseif ( line(3+n:5+n) == 'dhp' ) then
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          call readIntsFromChars(line, lineVal)
          options%HDBPeriod = lineVal
        elseif ( line(3+n:5+n) == 'dmp' ) then
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          call readIntsFromChars(line, lineVal)
          options%MDBPeriod = lineVal
        elseif ( lowerCase(line(3+n:10+n)) == 'dumpnewm' ) then
          options%dumpEachNewMaster = switch
        elseif ( lowerCase(line(3+n:10+n)) == 'help' ) then
          call option_usage
        elseif ( lowerCase(line(3+n:10+n)) == 'inquire' ) then
          options%command = 'inquire'
        else if ( line(3+n:10+n) == 'version ' ) then
          do j=1, size(current_version_id)
            print*, current_version_id(j)
          enddo
          stop
        else if ( line(3+n:6+n) == 'free' ) then
          options%freeHosts = switch
        else if ( line(3+n:7+n) == 'reviv' ) then
          options%reviveHosts = switch
        else if ( line(3+n:7+n) == 'wall ' ) then
          time_config%use_wall_clock = switch
        else if ( line(3:) == ' ' ) then  ! "--" means "no more options"
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          exit
        else
          print *, 'unrecognized option ', trim(line), ' ignored.'
          call option_usage
        end if
      else if ( line(1:1) == '-' ) then   ! "letter" options
        j = 1
        j = j + 1
        select case ( line(j:j) )
        case ( ' ' )
          exit
        case ( 'g' )
          toggle(gen) = .true.
          levels(gen) = 0
          if ( j < len(line) ) then
            if ( line(j+1:j+1) >= '0' .and. line(j+1:j+1) <= '9' ) then
              j = j + 1
              levels(gen) = ichar(line(j:j)) - ichar('0')
            end if
          end if
        case ( 'h', 'H', '?' )     ! Describe command line usage
          call option_usage
        case ( 'T' )
          options%timing = .true.
          do
            if ( j >= len(line) ) exit
            if ( line(j+1:j+1) > '0' .and. line(j+1:j+1) <= '9' ) then
              options%date_and_times = .true.
            elseif ( lowercase(line(j+1:j+1)) == 's' ) then
              options%timingUnits = 's'  ! l_seconds
            elseif ( lowercase(line(j+1:j+1)) == 'm' ) then
              options%timingUnits = 'm'
            elseif ( lowercase(line(j+1:j+1)) == 'h' ) then
              options%timingUnits = 'h'
            end if
            j = j + 1
          enddo
        case ( 'v' ); options%verbose = .true.
        case ( 'd' ); options%debug = .true.
        case ( 'k' ); options%command = 'suicide' ! options%killer = .true.
        case ( 'R' ); options%Rescue = .true.
        case ( 'c' )
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          options%command = lowercase(line)
          ! Special commands take yet another arg
          if ( index('check,avoid,kill,free,tellmdump', trim(options%command)) > 0 ) then
            i = i + 1
            call getarg ( i, line )
            command_line = trim(command_line) // ' ' // trim(line)
            options%selectedHosts = lowercase(line)
          endif
        case ( 'o' )
          subcase = line(j:j+2)
          i = i + 1
          call getarg ( i, line )
          ! print *, 'subcase: ', subcase
          ! print *, 'file: ', trim(line)
          command_line = trim(command_line) // ' ' // trim(line)
          if ( subcase == 'o') then
          options%dump_file = line
          elseif ( subcase == 'oph') then
          options%PHFile = line
          elseif ( subcase == 'opm') then
          options%PMFile = line
          else
          call option_usage
          endif
        case ( 'r' )
          subcase = line(j:j+3)
          i = i + 1
          call getarg ( i, line )
          ! print *, 'subcase: ', subcase
          ! print *, 'file: ', trim(line)
          command_line = trim(command_line) // ' ' // trim(line)
          if ( subcase == 'r') then
            ! We have no provision for a bare "r"
          call option_usage
          elseif ( subcase == 'rhdb') then
          options%HDBFile = line
          call output('Setting rescue HDB to: ' // trim(options%HDBFile), advance='yes' )
          elseif ( subcase == 'rmdb') then
          options%MDBFile = line
          call output('Setting rescue MDB to: ' // trim(options%MDBFile), advance='yes' )
          else
          call option_usage
          endif
        case ( 's' )
          options%command = 'switch'
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          options%dump_file = line
        case default
          print *, 'Unrecognized option -', line(j:j), ' ignored.'
          call option_usage
        end select
      else    
        exit ! This must be the hosts filename
      end if
      i = i + 1
    end do

  end subroutine get_options
   
  ! ---------------------------------------------  IDHostFromMaster  -----
  subroutine IDHostFromMaster(signal, tid, hostsID)
    ! Figure out which hosts ID a master is talking about
    ! Arguments
    integer, intent(in)  :: signal
    integer, intent(out) :: tid
    integer, intent(out) :: hostsID
    ! Internal variables
    integer :: info
    character(len=MACHINENAMELEN) :: machineName
    ! Executable
    hostsID = 0
    call PVMF90Unpack ( tid, info )
    if ( info /= 0 ) then
      call myPVMErrorMessage ( info, "unpacking tid" )
    endif
    call PVMF90Unpack ( machineName, info )
    if ( info /= 0 ) then
      call myPVMErrorMessage ( info, "unpacking machineName" )
    endif
    if ( options%debug  ) then
       if ( signal == SIG_RELEASEHOST ) then
         call output ('Freed host ', advance='no')
       elseif ( signal == sig_HostDied ) then
         call output ('Host died ', advance='no')
       endif
       call output ('tid: ', advance='no')
       call output (tid, advance='no')
       call output ('   machineName: ', advance='no')
       call output (trim(machineName), advance='yes')
    endif
    if ( tid < 1 ) then
      ! This means master couldn't start slave task on host
      ! So we'll look at machineName
      hostsID = FindFirst(hosts%name, machineName)
    else
      hostsID = FindFirst(hosts%tid, tid)
    endif
    if ( hostsID < 1 ) then
      ! Oops--the tid doesn't match any of the ones we've had so far
      if ( options%verbose ) then
        if ( options%timing ) call sayTime
        if ( signal == sig_HostDied ) then
          call output('Warning--unknown tid died', advance='no')
        else
          call output('Warning--unknown tid freed', advance='no')
        endif
        call output('  tid ', advance='no')
        call output(tid, advance='no')
        call output('  machineName ', advance='no')
        call output(trim(machineName), advance='no')
        call output('  hostsID ', advance='no')
        call timestamp(hostsID, advance='yes')
      endif
      if ( tid > 0 ) then
        ! if ( options%verbose ) call dump (hosts%tid, format='(i10)')
        ! We'll try again--using the machine name
        hostsID = FindFirst(hosts%name, machineName)
        if ( hostsID < 1 ) call myMLSMessage( MLSMSG_Warning, ModuleName, &
          & 'Even the machine name ' // trim(machineName) // &
          & ' yields an ID outside list of hosts' )
      else
        call myMLSMessage( MLSMSG_Warning, ModuleName, &
          & 'machine name yields an ID outside list of hosts' )
      endif
    endif
  end subroutine IDHostFromMaster
  
  ! ---------------------------------------------  IDMasterFromName  -----
  subroutine IDMasterFromName ( masters, names, IDs )
    ! Find which masterIDs match given list of names
    type(master_t), dimension(:)       :: masters
    character(*), intent(in)           :: names
    integer, dimension(:), intent(out) :: IDs
    ! Internal variables
    logical :: byName
    integer :: i, ivalue, n
    character(len=16) :: inputFormat
    character(len=16) :: masterFormat
    character(len=16) :: masDate
    character(len=16) :: masName
    ! Executable
    if ( options%debug ) then
    call output(' len_trim(names) ', advance='no')
    call output( len_trim(names) , advance='no')
    call output(' size(IDs) ', advance='no')
    call output( size(IDs) , advance='no')
    call output('   size(masters) ', advance='no')
    call output( size(masters) , advance='yes')
    endif
    if ( size(IDs) < 1 ) return
    IDs = 0
    if ( size(masters) < 1 .or. len_trim(names) < 1 ) return
    masterFormat = dateForm(masters(1)%date)
    n = NumStringElements( names,  countEmpty )
    n = min( n, size(IDs) )
    if ( options%debug ) then
    call timestamp ( 'n: ', advance='no' )
    call timestamp ( n, advance='yes' )
    endif
    do i=1, n
      call GetStringElement( names, masName, i, countEmpty )
      ! Two possible formats:
      ! master name (possibly prefixed by 'm-')
      ! We assume that we'll never have more than 10^6 masters in our db
      ! (a limitation, true, but unreasonable)
      ! and that date formats require at least 8 characters
      ! (which is captured by the next logical)
      byName = (len_trim(masName) < 8)
      if ( byName ) then
        if ( index(lowerCase(masName), 'm-') > 0 ) then
          ! e.g., 'm-1'
          call readIntsFromChars ( trim(masName(3:)), ivalue )
        else
          !  e.g., '1'
          call readIntsFromChars ( trim(masName), ivalue )
        endif
        if ( ivalue < 1 ) then
          ! Already zero
        elseif ( ivalue > size(masters) ) then
          ! Already zero
        elseif ( masters(ivalue)%finished ) then
          ! Already zero
        else
          IDs(i) = ivalue
        endif
      else
      ! master date; e.g. '2006-171'
        inputFormat = dateForm(masName)
        masDate = reFormatDate(masName, &
          & fromForm=trim(inputFormat), toForm=masterFormat)
        Ids(i) = findFirst( (masters%date == trim(masDate)) .and. &
          & .not. masters%finished )
        call output(' (inputFormat) ', advance='no')
        call output( trim(inputFormat) , advance='no')
        call output('   (masterFormat) ', advance='no')
        call output( trim(masterFormat) , advance='yes')
        call output(' (input) ', advance='no')
        call output( trim(masName) , advance='no')
        call output('   (reformatted) ', advance='no')
        call output( trim(masDate) , advance='yes')
      endif
      call timestamp ( 'ID: ', advance='no' )
      call timestamp ( Ids(i), advance='yes' )
    enddo
  end subroutine IDMasterFromName

  ! ---------------------------------------------  mark_host_database  -----
  subroutine mark_host_database(hosts, selectedHosts)
    ! mark selected hosts in database as not to be used
    type(Machine_T), intent(inout), dimension(:) :: hosts
    character(len=*), intent(in) :: selectedHosts
    ! Internal variables
    integer :: i
    integer :: status
    ! Executable
    ! No need to mark if none can be used
    if ( all(.not. hosts%OK) ) return
    do i=1, size(hosts)
      if ( .not. hosts(i)%OK ) cycle
      ! Warning--following use of variable 'status' is non-standard
      ! status is good if non-zero, bad if 0
      status = StringElementNum(selectedHosts, trim(hosts(i)%name), .true.)
      if ( status > 0 ) hosts(i)%OK = .false.
    enddo
  end subroutine mark_host_database

  ! ---------------------------------------------  masterNameFun  -----
  function masterNameFun ( masterTid ) result(name)
    character(LEN=MachineNameLen)  :: Name
    integer, intent(in)            :: masterTid
    ! Internal variables
    integer :: mastersID
    !
    mastersID = FindFirst(masters%tid, masterTid)
    name = catLists('m', mastersID, inseparator='-')
  end function masterNameFun

  ! ---------------------------------------------  myMLSMessage  -----
  subroutine myMLSMessage ( Severity, ModuleNameIn, Message )
    ! A 'safer' substitute for MLSMessage
    ! (in case we don't trust the toolkit)
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text

    select case ( severity )
    case ( MLSMSG_Success )
      call timeStamp('Success: ' // trim(Message), advance='yes')
    case ( MLSMSG_Debug )
      call timeStamp('Debug: ' // trim(Message), advance='yes')
    case ( MLSMSG_Info )
      call timeStamp('Info: ' // trim(Message), advance='yes')
    case ( MLSMSG_Warning )
      call timeStamp('Warning: ' // trim(Message), advance='yes')
    case ( MLSMSG_Error )
      call MLSMessage ( Severity, ModuleNameIn, Message )
    case default
      call timeStamp('Default: ' // trim(Message), advance='yes')
    end select
  end subroutine myMLSMessage

  ! ---------------------------------------------  myPVMErrorMessage  -----
  subroutine myPVMErrorMessage ( info, place )
    ! This routine is called to log a PVM error
    ! possibly because we may not wish to exit on such an error
    integer, intent(in) :: INFO
    character (LEN=*) :: PLACE
    character (LEN=132) :: LINE

    write (line, * ) info
    if ( options%exitOnError ) then
      call PVMErrorMessage ( info, place )
    else
      call myMLSMessage ( options%errorLevel, Place, &
        & 'PVM Error:  Info='//trim(adjustl(line)))
    endif
  end subroutine myPVMErrorMessage

  ! ---------------------------------------------  Option_usage  -----
  ! The following offer some information on the options
  ! available on the command-line
  
  subroutine Option_usage
    call getarg ( 0+hp, line )
    print *, 'Usage: ', trim(line), ' [options] [--] [LIST-name]'
    print *, ' Options:'
    print *, ' --[n]buf:    do [not] buffer dumpfile (if used)'
    print *, ' --check:     check LIST of hosts'
    print *, ' --[n]clean:  do [not] regularly clean db of finished masters'
    print *, ' --defer:     new masters defer to oldest (has enough hosts)'
    print *, ' --dhp n :    dump host db every n seconds (need phfile)'
    print *, ' --dmp m :    dump master db every m seconds (need pmfile)'
    print *, ' --dumpnewm:  dump each new master'
    print *, ' --help:      show help; stop'
    print *, ' --inquire:   show whether an instance of l2q already running'
    print *, ' --[n]free:   do [not] regularly check, free abandoned hosts'
    print *, ' --[n]revive: do [not] regularly check for revived hosts'
    print *, ' --version:   print version string; stop'
    print *, ' --wall:      show times according to wall clock (if T[0] set)'
    print *, ' -k:          kill currently-running l2q'
    print *, ' -oph phfile: dump db of hosts periodically to phfile'
    print *, ' -opm pmfile: dump db of masters periodically to pmfile'
    print *, ' -o dumpfile: direct most other output to dumpfile'
    print *, '               (if modifying an already-running l2q, direct only'
    print *, '               the requested output to dumpfile)'
    print *, ' -s newfile:  flush current dumpfile; direct later output'
    print *, '                to newfile ( same as -o newfile -c switch )'
    print *, ' -v:          verbose'
    print *, ' -h:          show help; stop'
    print *, ' -R:          Rescue: take over from a dead l2q'
    print *, ' -rhdb file:  read db of hosts from file (required by a rescue)'
    print *, ' -rmdb file:  read db of masters from file (required by a rescue)'
    print *, ' -T[0][smh]:  show timing [in s, m, h]'
    print *, ' -T1:         show dates with timing'
    print *, ' -c command [arg]:  issue command to currently-running l2q'
    print *, '        command may be one of'
    print *, ' avoid h1[,h2,..]:'
    print *, '              mark selected host[s] as unuseable'
    print *, ' check h1[,h2,..]:'
    print *, '              check for revival of selected host[s]'
    print *, ' checkall:    check for all revived hosts'
    print *, ' clean:       clean the db of finished master tasks'
    print *, ' freeany:     free any hosts held by finished master tasks'
    print *, ' free h1[,h2,..]:'
    print *, '              free specified hosts'
    print *, ' revive=on:   begin regularly checking for revived hosts'
    print *, ' revive=off:  cease regularly checking for revived hosts'
    print *, ' kill m1[,m2,..]:'
    print *, '              kill selected masters cleanly'
    print *, ' tellmdump m1[,m2,..]:'
    print *, '              tell selected masters to dump current status'
    print *, ' switch:      flush current dumpfile'
    print *, '              ( switch to one specified by -o newfile )'
    print *, '  ( if the following commands are accompanied by the option'
    print *, '    -o newfile, the output requested will be dumped to newfile )'
    print *, ' dumphdb:     dump host database'
    print *, ' dumpmdb:     dump master database'
    print *, ' dumpdb:      dump host and master databases'
    print *, ' N o t e :'
    print *, ' only the options:'
    print *, ' -o, -v, -T, --check, --clean, --defer, '
    print *, ' --dumpnewm, --[n]revive, --wall'
    print *, ' are appropriate for l2q when first launched'
    print *, ' all other options will modify an already-running l2q'
    print *, ' (and will generate an error if l2q not already running)'
    print *, ' '
    print *, ' commanding an already-running l2q to dump output to a file'
    print *, ' without specifying a path will select that working directory'
    print *, ' in force when the original l2q was launched '
    print *, ' (and not necessarily the current one)'
    stop
  end subroutine Option_usage

  ! ---------------------------------------------  proclaim  -----
  subroutine proclaim( Event, Name, Signal, advance )
    ! Yet another routine to print output
    ! This one sspecialized for signaling noteworthy events
    character(LEN=*), intent(in)   :: Event
    character(LEN=*), intent(in), optional   :: Name
    character(LEN=*), intent(in), optional   :: ADVANCE
    integer, intent(in), optional   :: Signal
    ! Internal variables
    character(len=3) :: myadvance
    ! Executable
    myadvance = 'yes'
    if ( present(advance) ) myAdvance=advance
    if ( options%timing ) call sayTime
    call output(trim(event), advance='no')
    if ( present(name) ) then
      call output(' associated with ', advance='no')
      call output(trim(name), advance='no')
    endif
    if ( present(signal) ) then
      call output(' signal ', advance='no')
      call output(signal, advance='no')
    endif
    if ( lowercase(myadvance) == 'yes' ) call newline
  end subroutine proclaim

  ! ---------------------------------------------  read_host_database  -----
  subroutine read_host_database( Hosts )
    type(machine_T), dimension(:), pointer :: Hosts
    ! Internal variables
    integer :: i
    character(len=32) :: irrelevant
    integer :: hostSize
    integer :: status
    ! Executable
    deallocate( hosts, stat=status )
    if ( status /= 0 ) call MLSMessage( MLSMSG_Error, ModuleName, &
          & 'Unable to deallocate Hosts before reading db' )
    hostSize = 0
    ! 1st--we need to go past the 7 lines at the start of the file
    if ( DEEBUG ) call timeStamp('1st--we need to go past the 7 lines at the start of the file', advance='yes')
    call read_oneline ( HDBUnit, status, string=irrelevant )
    if ( DEEBUG ) then
    call timeStamp( 'Read irrelevant: ' // trim(irrelevant), advance='yes' )
    call output( 'status after read_oneline' )
    call blanks(4)
    call timeStamp( status, advance='yes' )
    endif
    if ( status /= 0 ) then
      call output('Hosts database still empty', advance='yes')
      return
    endif
    call read_oneline ( HDBUnit, status, int=hostSize )
    if ( DEEBUG )  then
    call output( 'host size: ' )
    call output( hostsize, advance='yes' )
    endif
    do i=1, 5
      call read_oneline ( HDBUnit, status, string=irrelevant )
    enddo
    do i=1, hostSize
      call read_host(Hosts)
    enddo
    if ( DEEBUG ) call dump( Hosts, Details=1 )
  end subroutine read_host_database
  
  ! ---------------------------------------------  read_host  -----
  subroutine read_host( hosts )
    type(machine_T), dimension(:), pointer :: hosts
    ! Internal variables
    type(machine_t) :: ahost
    integer :: numhosts
    integer :: status
    ! Executable
    call read_oneline ( HDBUnit, status, ahost%Name )
    if ( DEEBUG ) then
    call timeStamp( 'Read aHost%name: ' // trim(aHost%name) )
    call output( 'status after read_oneline' )
    call blanks(4)
    call timeStamp( status, advance='yes' )
    endif
    if ( status == 0 ) call read_oneline ( HDBUnit, status, int=ahost%master_tid )
    if ( status == 0 ) call read_oneline ( HDBUnit, status, string=ahost%master_name )
    if ( status == 0 ) call read_oneline ( HDBUnit, status, string=ahost%master_date )
    if ( status == 0 ) call read_oneline ( HDBUnit, status, int=ahost%tid )
    if ( status == 0 ) call read_oneline ( HDBUnit, status, int=ahost%chunk )
    if ( status == 0 ) call read_oneline ( HDBUnit, status, log=ahost%OK )
    if ( status == 0 ) call read_oneline ( HDBUnit, status, log=ahost%free )
    if ( status == 0 ) numhosts = addMachineToDatabase(hosts, ahost)
  end subroutine read_host

  ! ---------------------------------------------  read_list  -----
  subroutine read_list
    type(Machine_T) :: newhost
    integer :: iostat
    integer :: nhosts
    nhosts = 0
    do
      if ( inunit >= 0 ) then
        read ( inunit, '(a)', advance='no', eor=100, end=200, err=400, &
          iostat=iostat ) newhost%name
      else
        read ( *, '(a)', advance='no', eor=100, end=200, err=400, &
          iostat=iostat ) newhost%name
      end if
100   newhost%name = adjustl( newhost%name )
      ! Ignore commented-out lines and comments
      if ( newhost%name(1:1) == '#' ) cycle
      if ( options%verbose ) &
          & call output(trim(newhost%name) // ' added', advance='yes')
      newhost%master_tid = -1
      ! newhost%tid = -1
      newhost%tid = UNASSIGNED
      newhost%chunk = -1
      newhost%OK = .false.
      newhost%free = .true.
      nhosts = addMachineToDatabase(hosts, newhost)
    enddo
200 if ( options%verbose ) then
      call output(nhosts, advance='no')
      call timestamp(' hosts read', advance='yes')
    endif
    return
400 call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'error in reading list of hosts' )
  end subroutine read_list

  ! ---------------------------------------------  read_master_database  -----
  subroutine read_master_database( Masters )
    type(Master_T), dimension(:), pointer :: Masters
    ! Internal variables
    integer :: i
    character(len=32) :: irrelevant
    integer :: masterSize
    integer :: status
    ! Executable
    masterSize = 0
    ! 1st--we need to go past the 4 lines at the start of the file
    if ( DEEBUG ) call timeStamp('1st--we need to go past the 4 lines at the start of the file', advance='yes')
    call read_oneline ( MDBUnit, status, string=irrelevant )
    if ( DEEBUG ) then
    call timeStamp( 'Read irrelevant: ' // trim(irrelevant), advance='yes' )
    call output( 'status after read_oneline' )
    call blanks(4)
    call timeStamp( status, advance='yes' )
    endif
    if ( status /= 0 ) then
      call output('Master database still empty', advance='yes')
      return
    endif
    call read_oneline ( MDBUnit, status, int=masterSize )
    call read_oneline ( MDBUnit, status, string=irrelevant )
    call read_oneline ( MDBUnit, status, string=irrelevant )
    if ( DEEBUG ) then
    call output( 'size of master db' )
    call blanks(4)
    call timeStamp( masterSize, advance='yes' )
    endif
    do i=1, masterSize
      call read_master(Masters)
    enddo
    if ( DEEBUG ) call dump_master_database( Masters, Details=1 )
  end subroutine read_master_database
  
  ! ---------------------------------------------  read_master  -----
  subroutine read_master( Masters )
    type(Master_T), dimension(:), pointer :: Masters
    ! Internal variables
    type(master_t) :: aMaster
    integer :: numMasters
    integer :: status
    ! Executable
    call read_oneline ( MDBUnit, status, aMaster%Name )
    if ( DEEBUG ) then
    call timeStamp( 'Read aMaster%name: ' // trim(aMaster%name) )
    call output( 'status after read_oneline' )
    call blanks(4)
    call timeStamp( status, advance='yes' )
    endif
    if ( status == 0 ) call read_oneline ( MDBUnit, status, string=amaster%Date )
    if ( status == 0 ) call read_oneline ( MDBUnit, status, int=amaster%tid )
    if ( status == 0 ) call read_oneline ( MDBUnit, status, log=amaster%needs_host )
    if ( status == 0 ) call read_oneline ( MDBUnit, status, log=amaster%owes_thanks )
    if ( status == 0 ) call read_oneline ( MDBUnit, status, log=amaster%finished )
    if ( status == 0 ) numMasters = addMasterToDatabase(masters, aMaster)
  end subroutine read_master

  ! ---------------------------------------------  read_oneline  -----
  subroutine read_oneline ( unit, status, string, int, log )
    ! Read one line from unit assuming it was formatted as
    ! Something: value
    ! returning value either as a string or as an int
    !
    ! status will be 0 unless EOR, ERROR, or somesuch
    integer, intent(in)                     :: unit
    integer, intent(out)                    :: status
    character(len=*), optional, intent(out) :: string
    integer, optional, intent(out)          :: int
    logical, optional, intent(out)          :: log
    ! Internal variables
    integer :: iColon
    character(len=256) :: last
    character(len=256) :: line
    ! logical, parameter :: DEEBUG = .false.
    ! Executable
    last = ' '
    line = ' '
    ! do
    read ( unit, '(a)', advance='no', eor=100, end=200, err=400, &
      & iostat=status ) line
    if ( DEEBUG ) call output( 'oneline: ' // trim(line), advance='yes' )
100 iColon = index ( line, ':' )
    if ( iColon > 0 ) then
      status = 0
      last = line(iColon+1:)
      if ( DEEBUG ) call output( 'value: ', advance='no' )
      if ( present(string) ) string = adjustl(last)
      if ( present(int) ) call readIntsFromChars( last, int )
      if ( present(log) ) log = ( index( lowerCase(last), 't' ) > 0 )
      if ( DEEBUG ) then
      if ( present(string) ) call output( trim(string), advance='yes' )
      if ( present(int) ) call output( int, advance='yes' )
      if ( present(log) ) call output( log, advance='yes' )
      endif
    else
      status = 1
    endif
    if ( DEEBUG ) then
    call output(trim(line), advance='no')
    call blanks(4)
    call timestamp(status, advance='yes')
    endif
    return
    ! enddo
200 status = 99
    if ( .not. DEEBUG ) return
    call output(trim(line), advance='no')
    call blanks(4)
    call timestamp(status, advance='yes')
    return
400 status = 999
    if ( .not. DEEBUG ) return
    call output(trim(line), advance='no')
    call blanks(4)
    call timestamp(status, advance='yes')
  end subroutine read_oneline
  
  ! ---------------------------------------------  reDumpHosts  -----
  subroutine reDumpHosts(hosts, tempFile, tempUnit)
    type(Machine_T), dimension(:), pointer :: hosts
    character(len=*), intent(in)           :: tempFile
    integer, intent(in)                    :: tempUnit
    ! Internal variables
    character(len=FILENAMELEN)             :: oldPrName
    integer                                :: oldPrUnit
    integer :: status
    logical :: switched
    ! Executable
    switched = .false.
    status = 0
    ! call timeStamp( 'dumping Hosts DB', advance='yes' )
    if ( tempfile /= '<STDIN>' ) then
      if ( options%dump_file /= '<STDIN>' ) then
        switched = .true.
        oldPrName = OutputOptions%name
        close(outputOptions%prunit)
        OutputOptions%name = tempFile
        ! print *, 'switching to ', trim(tempFile)
      endif
      oldPrUnit = OutputOptions%prunit
      OutputOptions%prunit = tempUnit
      ! print *, 'Opening ', prunit, ' as ', trim(tempfile)
      open( OutputOptions%prunit, file=trim(tempfile), &
        & status='replace', form='formatted', iostat=status )
    endif
    call timestamp ( 'Received an external message to dump hostDB', &
      & advance='yes' )
    if ( status == 0 ) then
      call dump(hosts)
    else
      call myMLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Ignoring message; unable to open ' // &
        & trim(tempfile) )
    endif
    if ( tempfile /= '<STDIN>' ) then
      close(OutputOptions%prunit)
      if ( switched ) then
        OutputOptions%name = oldPrName
        open( oldPrUnit, file=trim(options%dump_file), &
          & position='append', &
          & status='old', form='formatted', iostat=status )
        ! print *, 'switching back to ', trim(options%dump_file)
      endif
      OutputOptions%prunit = oldPrUnit
    endif
    if ( options%dump_file /= '<STDIN>' .and. DEEBUG ) &
    & call timeStamp( 'Reverting to ' // trim(options%dump_file), advance='yes' )
  end subroutine reDumpHosts

  ! ---------------------------------------------  reDumpMasters  -----
  subroutine reDumpMasters(masters, tempFile, tempUnit)
    type(Master_T), dimension(:), pointer :: masters
    character(len=*), intent(in)           :: tempFile
    integer, intent(in)                    :: tempUnit
    ! Internal variables
    character(len=FILENAMELEN)             :: oldPrName
    integer                                :: oldPrUnit
    integer :: status
    logical :: switched
    ! Executable
    switched = .false.
    ! call timeStamp( 'Dumping masters DB', advance='yes' )
    status = 0
    if ( tempfile /= '<STDIN>' ) then
      if ( options%dump_file /= '<STDIN>' ) then
        switched = .true.
        oldPrName = OutputOptions%name
        close(outputOptions%prunit)
        OutputOptions%name = tempFile
        ! print *, 'switching to ', trim(tempFile)
      endif
      oldPrUnit = OutputOptions%prunit
      OutputOptions%prunit = tempUnit
      ! print *, 'Opening ', prunit, ' as ', trim(tempfile)
      open( OutputOptions%prunit, file=trim(tempfile), &
        & status='replace', form='formatted', iostat=status )
    endif
    call timestamp ( 'Received an external message to dump masterDB', &
      & advance='yes' )
    if ( status == 0 ) then
      call dump_master_database(masters)
    else
      call myMLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Ignoring message; unable to open ' // &
        & trim(tempfile) )
    endif
    if ( tempfile /= '<STDIN>' ) then
      close(OutputOptions%prunit)
      if ( switched ) then
        OutputOptions%name = oldPrName
        open( oldPrUnit, file=trim(options%dump_file), &
          & position='append', &
          & status='old', form='formatted', iostat=status )
        ! print *, 'switching back to ', trim(options%dump_file)
      endif
      OutputOptions%prunit = oldPrUnit
    endif
    if ( options%dump_file /= '<STDIN>' .and. DEEBUG ) &
    & call timeStamp( 'Reverting to ' // trim(options%dump_file), advance='yes' )
  end subroutine reDumpMasters

  ! ---------------------------------------------  releaseHostFromMaster  -----
  subroutine releaseHostFromMaster(host, master, hostsID)
    type(Machine_T) :: host
    type(master_t) :: master
    integer, intent(in) :: hostsID
    ! Internal variables
    integer :: hcid
    integer, dimension(:), pointer :: tempHosts
    integer :: i, status
    ! Executable
    if ( options%debug ) &
      & call output( 'Releasing ' // trim(host%name) // '   ', advance='yes')
    if( size(master%hosts) < 1 .and. .not. master%owes_thanks ) then
      call myMLSMessage( MLSMSG_Warning, ModuleName, &
        & 'master lacks any hosts' )
      return
    elseif ( hostsID < 1 ) then
      call myMLSMessage( options%errorLevel, ModuleName, &
        & 'Programming error--hostsID=0 in releaseHostFromMaster' )
    elseif ( hostsID > size(hosts) ) then
      call myMLSMessage( options%errorLevel, ModuleName, &
        & 'Programming error--hostsID>size(hosts) in releaseHostFromMaster' )
    elseif ( .not. associated(master%hosts) ) then
      ! call myMLSMessage( MLSMSG_Warning, ModuleName, &
      !  & 'master lacks any hosts' )
      call timestamp('master lacks any hosts', advance='yes' )
      return
    elseif ( host%master_tid /= master%tid ) then
      call output('host%master_tid ', advance='no')
      call output(host%master_tid, advance='no')
      call output('   master%tid ', advance='no')
      call output(master%tid, advance='no')
      call timestamp('Host not assigned to that master', advance='yes' )
      return
    elseif ( .not. any(master%hosts == hostsID) ) then
      call output('hostsID ', advance='no')
      call output(hostsID, advance='no')
      call output('   name ', advance='no')
      call output(trim(host%name) // '   ', advance='no')
      call newline
      call dump_his_hosts(master%hosts, sortUs=.true.)
      ! call myMLSMessage( MLSMSG_Warning, ModuleName, &
      !  & 'master lacks that host' )
      call timestamp( '; master lacks that host, or did he forget?', advance='yes' )
      return
    elseif ( master%owes_thanks .and. .false. ) then
      call myMLSMessage( MLSMSG_Warning, ModuleName, &
        & 'master still owes thanks' )
    endif
    if ( host%tid > 0 ) then
      ! In case slave task is still running, try to kill it
      call pvmfpstat(host%tid, status)
      if ( status == PVMOK ) then
        call pvmfkill(host%tid, status)
        if ( status /= 0 ) then
          call proclaim('Failed to kill running task', &
            & trim(host%name), signal=host%tid)
        elseif ( options%debug ) then
          call timeStamp( 'Forcibly killed task ' // trim(host%name), advance='yes' )
        endif
      endif
    endif
    host%tid = UNASSIGNED
    ! host%tid = 0
    host%master_tid = 0
    host%free = .true.
    host%chunk = -1
    host%master_name = ' '
    host%master_date = ' '
    hcid = 0
    if( .not. associated(master%hosts) ) then
      call myMLSMessage( MLSMSG_Warning, ModuleName, &
        & 'this master has no hosts--how could it have released one?' )
    elseif( size(master%hosts) < 2 ) then
      call deallocate_test(master%hosts, 'master%hosts', moduleName)
    elseif( .not. any(master%hosts == hostsID) ) then
      call myMLSMessage( MLSMSG_Warning, ModuleName, &
        & 'this master does not have this host--how could it have released it?' )
    else
      ! We'll need a smaller hosts component in master, so ..
      nullify(tempHosts)
      hcid = size(master%hosts) - 1
      call allocate_test(tempHosts, hcid, 'temphosts', moduleName)
      hcid = 0
      do i=1, size(master%hosts)
        if ( master%hosts(i) == hostsID ) cycle
        hcid = hcid + 1
        tempHosts(hcid) = master%hosts(i)
      enddo
      call deallocate_test(master%hosts, 'master%hosts', moduleName)
      master%hosts => tempHosts
    endif
    master%numHosts = master%numHosts - 1
  end subroutine releaseHostFromMaster
  
  ! ---------------------------------------------  rmMasterFromDatabase  -----
  subroutine  rmMasterFromDatabase( DATABASE, ITEM )
    ! This function removes a master data type from a database of said types,
    ! creating a new database if it doesn't exist.  The result value is
    ! the reduced size
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    ! Dummy arguments
    type (master_t), dimension(:), pointer :: DATABASE
    type (master_t), intent(in)            :: ITEM

    ! Local variables
    integer :: S
    type (Master_T), dimension(:), pointer :: tempDatabase
    logical, parameter                     :: okToDeallocEmptyDB = .false.
    !This include causes real trouble if you are compiling in a different 
    !directory.
    include "rmItemFromDatabase.f9h" 

  end subroutine  rmMasterFromDatabase

  ! ---------------------------------------------  SayTime  -----
  subroutine SayTime ( What )
    character(len=*), intent(in), optional :: What
    ! Internal variables
    ! real :: t_conversion
    ! Executable
    call time_now ( t2 )
    if ( options%date_and_times ) then
      call output_date_and_time(advance='no')
    else
      call output ( "time (now) " )
      call output ( dble(t_conversion*t2), advance = 'no' )
    endif
    call blanks ( 4, advance = 'no' )
    ! call output ( "time (elapsed) " // what // " = " )
    ! call output ( dble(t2 - t1), advance = 'yes' )
    if ( present(What) ) call output ( trim(what), advance = 'yes' )
  end subroutine SayTime

  ! ---------------------------------------------  SwitchMastersAllegiance  -----
  subroutine SwitchMastersAllegiance( Master )
    type(Master_T) :: Master
    ! Internal variables
    integer :: bufferID
    integer :: i
    integer :: info
    ! Executable
    ! call dump_master( master )
    if ( master%finished ) then
      call output(master%tid)
      call timeStamp( ' This master already finished', advance='yes' )
      ! Sometimes we can't trust this claim, so try to send msg anyway
      ! return
    endif
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMFSend ( master%tid, SIG_Switchallegiance, info )
    call timeStamp( ' Sending notice to switch to master', advance='yes' )
    do i=1, 1000
      call PVMFNRecv ( master%tid, sig_swearallegiance, info )
      if ( info > 0 ) exit
      call usleep ( parallel%delay )
    enddo
    if ( i > 1000 ) then
      ! Here we face a choice:
      ! (1) We could kill the unresponsive master; e.g.
      !      call PVMFSend ( master%tid, giveUpTag, info )
      ! (2) We could just mark it as finished, relieving us of further worry
      ! (except that we haven't freed any hosts used by this master)
      master%finished = .true.
      call output(master%tid)
      call timeStamp( ' Received no oath from this master; finished? ', advance='yes' )
    else
      ! Got a response; was this master requesting a host?
      call PVMF90Unpack ( master%needs_Host, info )
      if ( info /= 0 ) &
        & call myPVMErrorMessage ( info, "unpacking signal" )
      call output(master%tid)
      call output( ' Received oath of allegiance from master; needs host? ' )
      call timeStamp( master%needs_Host, advance='yes' )
    endif
    ! In case master sent thanks after prior l2q died, we'll assume 
    ! it does not owe thanks anymore
    master%owes_thanks = .false.
  end subroutine SwitchMastersAllegiance

end program L2Q

! $Log: l2q.f90,v $
! Revision 1.39  2016/08/12 16:18:03  pwagner
! Made consistent with our split of Dump_0
!
! Revision 1.38  2015/04/29 16:18:17  pwagner
! Fixed bug due to changes in rmItemFromDatabase.f9h
!
! Revision 1.37  2014/09/22 18:02:10  pwagner
! Corrected to conform with new add/rmItemFromDatabase
!
! Revision 1.36  2014/01/09 00:31:26  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 1.35  2013/08/23 02:51:48  vsnyder
! Move PrintItOut to PrintIt_m
!
! Revision 1.34  2013/08/14 17:27:26  pwagner
! Moved FindSomethings into MLSFinds
!
! Revision 1.33  2013/07/18 22:36:38  pwagner
! Consistent with having deleted OutputOptions%opened
!
! Revision 1.32  2013/02/14 19:05:29  pwagner
! Added way for l2q to tell master to dump status
!
! Revision 1.31  2012/07/12 17:55:16  pwagner
! Added mdline option --free to regularly check, free abandoned hosts
!
! Revision 1.30  2010/06/03 23:36:07  pwagner
! Tried again to fix problem of freezing
!
! Revision 1.29  2009/09/02 22:05:36  pwagner
! Tried to fix bug preventing some hosts from being revived
!
! Revision 1.28  2009/08/17 20:25:46  pwagner
! Should fix the forgotten needs_host when a master is killed
!
! Revision 1.27  2009/07/21 20:37:52  pwagner
! Print tid when logging masters thanks for hostl2q.f90
!
! Revision 1.26  2009/06/09 17:06:19  pwagner
! Prevent using masters before it becomes allocated
!
! Revision 1.25  2009/04/13 20:34:20  pwagner
! Ignore comments in hosts list file
!
! Revision 1.24  2009/02/10 17:52:04  pwagner
! Fixed syntax error
!
! Revision 1.23  2008/06/17 00:03:13  pwagner
! More tweaking, less freezing
!
! Revision 1.22  2007/09/06 23:37:36  pwagner
! Delay before forcibly killing slaves is masters responsibility, not ours
!
! Revision 1.21  2007/08/31 00:05:26  pwagner
! Fixed bugs preventing mesgs after event_loop from going to stdout
!
! Revision 1.20  2007/06/29 21:00:21  pwagner
! Fixed bug causing crashes when checking for revivals
!
! Revision 1.19  2007/05/18 23:50:15  pwagner
! Now can successfully revive dead hosts
!
! Revision 1.18  2007/02/09 21:24:22  pwagner
! Fixed an error only NAG caught
!
! Revision 1.17  2007/01/18 23:25:59  pwagner
! Changed to use unbuffered output with -o dump_file
!
! Revision 1.16  2007/01/12 00:41:16  pwagner
! May start a new l2q to rescue things if old one dies
!
! Revision 1.15  2006/11/22 18:34:24  pwagner
! Tracks hosts freed by killed masters better
!
! Revision 1.14  2006/11/03 21:27:26  pwagner
! Another last-minute freezing bug fixed (or so we hope)
!
! Revision 1.13  2006/11/01 20:45:29  pwagner
! Fixed another freezing bug
!
! Revision 1.12  2006/09/29 00:31:21  pwagner
! Many life-prolonging changes; may kill masters if so commanded
!
! Revision 1.11  2006/08/02 22:48:22  pwagner
! prunit now a component of OutputOptions
!
! Revision 1.10  2005/11/15 22:39:58  pwagner
! More robust against failures while openeing dump files
!
! Revision 1.9  2005/09/23 21:01:13  pwagner
! use_wall_clock now a component of time_config
!
! Revision 1.8  2005/06/22 19:27:33  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.7  2005/04/12 20:32:19  pwagner
! May periodically autodump masters, hosts files
!
! Revision 1.6  2005/03/18 00:59:36  pwagner
! Now gets PVMERRORMESSAGE from MLSMessageModule
!
! Revision 1.5  2005/02/03 19:10:11  pwagner
! Receives master_date, master_time data from masters for each host
!
! Revision 1.4  2005/01/20 00:54:25  pwagner
! Implementing changes suggested at design review Jan 14 2005
!
! Revision 1.3  2005/01/14 21:39:04  pwagner
! Changes bring us into line with pw presentation of 20050114
!
! Revision 1.2  2004/12/23 00:19:30  pwagner
! New options; more convenient dumping to a file
!
! Revision 1.1  2004/12/09 00:42:46  pwagner
! First commit
!
@


1.39
log
@Made consistent with our split of Dump_0
@
text
@d12 4
a15 4
program L2Q
  use Allocate_Deallocate, only: allocate_test, deallocate_test, &
    & NoBytesAllocated, test_allocate, test_deallocate
  use dates_module, only: dateform, reformatdate
d17 11
a27 11
  use highOutput, only: output_date_and_time, outputNamedValue, timeStamp
  use L2ParInfo, only: parallel, initParallel
  use L2ParInfo, only: machine_t, parallel, &
    & petitiontag, giveuptag, grantedtag, masterdumptag, notifytag, &
    & sig_finished, sig_register, sig_swearallegiance, sig_switchallegiance, &
    & sig_hostdied, sig_releasehost, sig_requesthost, sig_thankshost, &
    & machinenamelen, getmachinenames, &
    & dump, addmachinetodatabase
  use machine ! at least hp for command lines, and maybe getarg, too
  use MLSCommon, only: fileNameLen
  use MLSL2Options, only: current_version_id
d29 1
a29 1
    & MLSMSG_Allocate, MLSMSG_DeAllocate, MLSMSG_Debug, MLSMSG_Error, &
d32 6
a37 6
  use MLSStringLists, only: catLists, getStringElement, numStringElements, &
    & stringelementnum
  use MLSStrings, only: lowercase, readIntsFromChars, streq
  use output_m, only: blanks, newline, &
    & output, OutputOptions
  use PrintIt_m, only: Set_Config
d39 5
a43 5
    & ClearPVMArgs, getmachinenamefromtid, &
    & pvmdatadefault, pvmfinitsend, pvmf90pack, pvmfkill, pvmfmytid, &
    & pvmf90unpack, pvmfpstat, &
    & pvmfsend, pvmfnotify, pvmtaskexit, &
    & pvmffreebuf
d45 3
a47 3
  use Time_M, only: Time_Now, time_config
  use toggles, only: gen, levels, &
    & toggle
a92 1
  integer, parameter :: MAXNUMMULTIPROCS = 8 ! For some architectures > 1000 
d132 1
a132 1
       "$Id: l2q.f90,v 1.38 2015/04/29 16:18:17 pwagner Exp $"
a135 8
! To use this, copy it into
! mlspgs/tests/lib
! then enter "make depends" followed by "make"


! Then run it
! LF95.Linux/test [options] [input files]

d359 1
a359 3
  if( options%verbose .or. .true. ) then
    call dump_settings
  end if
d761 1
d2077 1
a2077 1
    do
d2103 1
a2103 1
    enddo
d2405 3
@


1.38
log
@Fixed bug due to changes in rmItemFromDatabase.f9h
@
text
@d16 1
d18 2
a19 2
  use l2parinfo, only: parallel, initParallel
  use l2parinfo, only: machine_t, parallel, &
d30 1
a30 1
    & MLSMSG_Info, MLSMSG_Success, MLSMSG_Warning, PVMERRORMESSAGE
d32 1
a32 1
  use MLSStringlists, only: catlists, getstringelement, numstringelements, &
d34 1
a34 1
  use MLSStrings, only: lowercase, readintsfromchars, streq
d133 1
a133 1
       "$Id: l2q.f90,v 1.37 2014/09/22 18:02:10 pwagner Exp $"
d2415 3
@


1.37
log
@Corrected to conform with new add/rmItemFromDatabase
@
text
@d25 1
a25 1
  use mlscommon, only: filenamelen
d43 1
a43 1
  use Sort_M, only: SORT
d132 1
a132 1
       "$Id: l2q.f90,v 1.36 2014/01/09 00:31:26 pwagner Exp $"
d2330 1
d2414 3
@


1.36
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d13 14
a26 13
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use dates_module, only: DATEFORM, REFORMATDATE
  use HIGHOUTPUT, only: OUTPUT_DATE_AND_TIME, OUTPUTNAMEDVALUE, TIMESTAMP
  use L2PARINFO, only: PARALLEL, INITPARALLEL
  use L2ParInfo, only: MACHINE_T, PARALLEL, &
    & PETITIONTAG, GIVEUPTAG, GRANTEDTAG, MASTERDUMPTAG, NOTIFYTAG, &
    & SIG_FINISHED, SIG_REGISTER, SIG_SWEARALLEGIANCE, SIG_SWITCHALLEGIANCE, &
    & SIG_HOSTDIED, SIG_RELEASEHOST, SIG_REQUESTHOST, SIG_THANKSHOST, &
    & MACHINENAMELEN, GETMACHINENAMES, &
    & DUMP, ADDMACHINETODATABASE
  use MACHINE ! At least HP for command lines, and maybe GETARG, too
  use MLSCOMMON, only: FILENAMELEN
  use MLSL2Options, only: CURRENT_VERSION_ID
d30 6
a35 6
  use MLSFINDS, only: FINDFIRST
  use MLSSTRINGLISTS, only: CATLISTS, GETSTRINGELEMENT, NUMSTRINGELEMENTS, &
    & STRINGELEMENTNUM
  use MLSSTRINGS, only: LOWERCASE, READINTSFROMCHARS, STREQ
  use OUTPUT_M, only: BLANKS, NEWLINE, &
    & OUTPUT, OutputOptions
d38 5
a42 5
    & ClearPVMArgs, GETMACHINENAMEFROMTID, &
    & PVMDATADEFAULT, PVMFINITSEND, PVMF90PACK, PVMFKILL, PVMFMYTID, &
    & PVMF90UNPACK, PVMFPSTAT, &
    & PVMFSEND, PVMFNOTIFY, PVMTASKEXIT, &
    & PVMFFREEBUF
d45 2
a46 2
  use TOGGLES, only: GEN, LEVELS, &
    & TOGGLE
d132 1
a132 1
       "$Id: l2q.f90,v 1.35 2013/08/23 02:51:48 vsnyder Exp $"
d446 1
d2336 1
d2413 3
@


1.35
log
@Move PrintItOut to PrintIt_m
@
text
@d15 1
d34 1
a34 2
    & OUTPUT, OUTPUT_DATE_AND_TIME, outputNamedValue, OutputOptions, &
    & TIMESTAMP
d131 1
a131 1
       "$Id: l2q.f90,v 1.34 2013/08/14 17:27:26 pwagner Exp $"
d2410 3
@


1.34
log
@Moved FindSomethings into MLSFinds
@
text
@d35 1
d131 1
a131 1
       "$Id: l2q.f90,v 1.33 2013/07/18 22:36:38 pwagner Exp $"
d202 1
a202 2
  MLSMessageConfig%useToolkit = .false.
  MLSMessageConfig%logFileUnit = -1
d2410 3
@


1.33
log
@Consistent with having deleted OutputOptions%opened
@
text
@d28 1
a28 1
  use MLSSETS, only: FINDFIRST
d130 1
a130 1
       "$Id: l2q.f90,v 1.32 2013/02/14 19:05:29 pwagner Exp $"
d2410 3
@


1.32
log
@Added way for l2q to tell master to dump status
@
text
@d130 1
a130 1
       "$Id: l2q.f90,v 1.31 2012/07/12 17:55:16 pwagner Exp $"
d204 1
a225 1
    OutputOptions%opened = .true.
a2142 1
        OutputOptions%opened = .false.
a2164 1
        OutputOptions%opened = .true.
a2194 1
        OutputOptions%opened = .false.
a2216 1
        OutputOptions%opened = .true.
d2410 3
@


1.31
log
@Added mdline option --free to regularly check, free abandoned hosts
@
text
@d17 1
a17 1
    & PETITIONTAG, GIVEUPTAG, GRANTEDTAG, NOTIFYTAG, &
d113 2
a114 1
  integer, parameter          :: TURNREVIVALSONTAG = SWITCHDUMPFILETAG - 1
d130 1
a130 1
       "$Id: l2q.f90,v 1.30 2010/06/03 23:36:07 pwagner Exp $"
d273 2
d281 1
a281 1
        & killMastersTag/) )) &
d294 1
a294 1
        & killMastersTag/) )) &
d1269 24
d1524 1
a1524 1
          if ( index('check,avoid,kill,free', trim(options%command)) > 0 ) then
d1853 2
d2414 3
@


1.30
log
@Tried again to fix problem of freezing
@
text
@d129 1
a129 1
       "$Id: l2q.f90,v 1.29 2009/09/02 22:05:36 pwagner Exp $"
d168 1
d697 3
d762 1
d800 1
d1115 2
a1116 1
      checkrevivedhosts = significantEvent .and. options%reviveHosts
d1191 2
d1440 2
d1792 1
d2385 3
@


1.29
log
@Tried to fix bug preventing some hosts from being revived
@
text
@d87 2
d129 1
a129 1
       "$Id: l2q.f90,v 1.28 2009/08/17 20:25:46 pwagner Exp $"
a147 1
    integer                       :: numFreed = 0
a492 1
    ! host%tid = 0
d513 1
a513 1
    master%hosts(hcid) = hostsid
d517 1
d522 1
a522 1
      & masterNameFun(master%Tid))
d843 2
a844 1
            call proclaim('New Master', masterNameFun(masterTid), advance='no')
a860 1
              ! & masters%numChunks > (masters%numHosts+masters%numFreed) )
d862 1
d864 1
a864 1
            & call proclaim('Master requested host', masterNameFun(masterTid))
d869 1
d872 1
a872 1
              & masterNameFun(masterTid), advance='yes')
d896 2
a897 1
              call proclaim('Master ' // trim(masterNameFun(masterTid)) // &
d927 2
a928 2
          hostsID = FindFirst(  hosts%name==machineName .and. hosts%tid == AWAITINGTHANKS )
          ! hostsID = FindFirst(  hosts%name==machineName .and. hosts%tid < 1 )
d949 2
a950 1
            call proclaim('Master ' // trim(masterNameFun(masterTID)) // &
d962 1
d964 1
a964 1
            & call proclaim('Master ' // trim(masterNameFun(masterTID)) // &
d989 4
a992 2
          numHosts = masters(mastersID)%numHosts
          if ( numHosts > 0 .and. associated(masters(mastersID)%hosts) ) then
d1006 2
a1007 1
            call proclaim('Master ' // trim(masterNameFun(masterTid)) // &
d1018 1
d1021 1
a1021 1
            & masterNameFun(masterTid) )
d1045 3
a1047 1
          numHosts = masters(mastersID)%numHosts
d1061 2
a1062 1
            call proclaim('Master Died', masterNameFun(masterTid))
a1266 1
            ! & masters%numChunks > (masters%numHosts+masters%numFreed) )
d1547 1
a1547 1
    ! Figure out which master is talking about
a2212 3
    elseif ( master%owes_thanks ) then
      call myMLSMessage( MLSMSG_Warning, ModuleName, &
        & 'master still owes thanks' )
d2234 1
a2234 1
      call timestamp( '; master lacks that host', advance='yes' )
d2236 3
d2261 4
a2264 1
    if( size(master%hosts) == 1 ) then
d2266 3
a2283 1
    master%numFreed = master%numFreed + 1
d2373 3
@


1.28
log
@Should fix the forgotten needs_host when a master is killed
@
text
@d114 5
d127 1
a127 1
       "$Id: l2q.f90,v 1.27 2009/07/21 20:37:52 pwagner Exp $"
d492 2
a493 1
    host%tid = 0
d923 2
a924 1
          hostsID = FindFirst(  hosts%name==machineName .and. hosts%tid < 1 )
d1935 2
a1936 1
      newhost%tid = -1
d2241 2
a2242 1
    host%tid = 0
d2356 3
@


1.27
log
@Print tid when logging masters thanks for hostl2q.f90
@
text
@d122 1
a122 1
       "$Id: l2q.f90,v 1.26 2009/06/09 17:06:19 pwagner Exp $"
d1140 1
a1140 1
            masters(mastersID)%needs_host = .false. ! So we don't assign it hosts
d2347 3
@


1.26
log
@Prevent using masters before it becomes allocated
@
text
@d122 1
a122 1
       "$Id: l2q.f90,v 1.25 2009/04/13 20:34:20 pwagner Exp $"
d940 2
a1319 1
      ! call GetMachineNames ( machineNames )
d2347 3
@


1.25
log
@Ignore comments in hosts list file
@
text
@d122 1
a122 1
       "$Id: l2q.f90,v 1.24 2009/02/10 17:52:04 pwagner Exp $"
d1237 1
a1237 1
      if ( mayAssignAHost ) then
d2346 3
@


1.24
log
@Fixed syntax error
@
text
@d122 1
a122 1
       "$Id: l2q.f90,v 1.23 2008/06/17 00:03:13 pwagner Exp $"
d360 1
d1914 11
a1924 8
        if ( inunit >= 0 ) then
          read ( inunit, '(a)', advance='no', eor=100, end=200, err=400, &
            iostat=iostat ) newhost%name
        else
          read ( *, '(a)', advance='no', eor=100, end=200, err=400, &
            iostat=iostat ) newhost%name
        end if
100     if ( options%verbose ) &
d2346 3
@


1.23
log
@More tweaking, less freezing
@
text
@d122 1
a122 1
       "$Id: l2q.f90,v 1.22 2007/09/06 23:37:36 pwagner Exp $"
d1135 1
a1135 1
            if ( options%verbose ) call dump(masters(Ids(i)))
d2342 3
@


1.22
log
@Delay before forcibly killing slaves is masters responsibility, not ours
@
text
@d122 1
a122 1
       "$Id: l2q.f90,v 1.21 2007/08/31 00:05:26 pwagner Exp $"
d899 2
d1135 1
d1137 1
d2342 3
@


1.21
log
@Fixed bugs preventing mesgs after event_loop from going to stdout
@
text
@d122 1
a122 1
       "$Id: l2q.f90,v 1.20 2007/06/29 21:00:21 pwagner Exp $"
a2170 1
    integer, parameter :: FIXDELAYFORSLAVETOFINISH   = 15000000 ! 15 sec
a2216 1
          call usleep( FIXDELAYFORSLAVETOFINISH )
d2219 2
d2338 3
@


1.20
log
@Fixed bug causing crashes when checking for revivals
@
text
@d15 1
a15 1
  use L2PARINFO, only: PARALLEL, INITPARALLEL, ACCUMULATESLAVEARGUMENTS
d21 1
a21 1
    & DW_INVALID, DUMP, ADDMACHINETODATABASE
d28 1
a28 1
  use MLSSETS, only: FINDFIRST, FINDALL
d36 1
a36 1
    & ClearPVMArgs, FreePVMArgs, GETMACHINENAMEFROMTID, &
d39 1
a39 1
    & PVMFCATCHOUT, PVMFSEND, PVMFNOTIFY, PVMTASKEXIT, &
d43 1
a43 1
  use TOGGLES, only: CON, GEN, LEVELS, PAR, SYN, TAB, &
a74 1
  character(len=1) :: arg_rhs       ! 'n' part of 'arg=n'
a89 1
  integer :: RECORD_LENGTH
d122 1
a122 1
       "$Id: l2q.f90,v 1.19 2007/05/18 23:50:15 pwagner Exp $"
a647 1
    integer :: i
a744 1
    integer :: BUFFERIDSND              ! From PVM
a752 1
    integer :: i
a760 1
    integer :: NTIDS
a762 1
    integer :: oldPrUnit
a770 1
    integer, dimension(MAXNUMMULTIPROCS) :: TIDS
a1975 1
    character(len=128) :: machineName
d2063 1
d2065 1
d2070 1
d2075 1
d2094 1
a2094 1
      if ( options%dump_file /= '<STDIN>' ) then
d2097 1
a2097 1
        open( OutputOptions%prunit, file=trim(options%dump_file), &
d2100 1
d2104 1
a2104 1
    if ( options%dump_file /= '<STDIN>' ) &
d2117 1
d2119 1
d2124 1
d2129 1
d2148 1
a2148 1
      if ( options%dump_file /= '<STDIN>' ) then
d2151 1
a2151 1
        open( OutputOptions%prunit, file=trim(options%dump_file), &
d2154 1
d2158 1
a2158 1
    if ( options%dump_file /= '<STDIN>' ) &
d2171 1
d2218 1
d2338 3
@


1.19
log
@Now can successfully revive dead hosts
@
text
@d124 1
a124 1
       "$Id: l2q.f90,v 1.18 2007/02/09 21:24:22 pwagner Exp $"
d564 1
a564 1
    if ( .not. silent .and. present(selectedHosts) ) &
d2335 3
@


1.18
log
@Fixed an error only NAG caught
@
text
@d27 1
a27 1
    & MLSMSG_Info, MLSMSG_Warning, PVMERRORMESSAGE
d32 2
a33 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, OutputOptions, &
d58 14
d124 1
a124 1
       "$Id: l2q.f90,v 1.17 2007/01/18 23:25:59 pwagner Exp $"
d177 1
a202 3
  ! print *, 'dump file: ', trim(options%dump_file)
  ! print *, 'masters file: ', trim(options%PMFile)
  ! print *, 'hosts file: ', trim(options%PHfile)
d218 1
a218 1
    OutputOptions%buffered = .false.
d313 2
a314 1
  if ( .not. associated(machineNames) ) call MLSMessage( MLSMSG_Error, ModuleName, &
d363 1
a363 3
  call cure_host_database(hosts, machineNames, silent=.true.)
  if ( .not. associated(machineNames) ) call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'unable to get machine names after cure_host_database' )
d480 1
a480 1
      call MLSMessage( options%errorLevel, ModuleName, &
d483 1
a483 1
      call MLSMessage( options%errorLevel, ModuleName, &
d491 1
a491 1
       call timestamp (count(hosts%free), advance='yes')
d544 2
a545 2
  subroutine cure_host_database(hosts, machineNames, silent, selectedHosts)
    ! cure any recovered hosts in database--declare them fit for action
a547 1
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
d551 1
d559 15
a573 2
    if ( all(hosts%OK) ) return
    ! call GetMachineNames ( machineNames )
d586 2
d593 1
a593 1
    ! call deAllocate_test(machineNames, 'machineNames', moduleName )
d731 3
d829 1
a829 1
            & call MLSMessage ( options%errorLevel, ModuleName, &
d886 5
a890 2
          call IDHostFromMaster(sig_releaseHost, tid, mastersID, hostsID)
          if ( hostsID > 0 ) then
d902 1
a902 1
            mayAssignAHost = .false. ! Don't assign to a later master
d928 1
a928 1
            call MLSMessage( options%errorLevel, ModuleName, &
d956 1
a956 1
          call IDHostFromMaster(sig_HostDied, tid, mastersID, hostsID)
d1008 1
a1008 1
          call MLSMessage( options%errorLevel, ModuleName, &
d1027 1
a1027 1
        if ( mastersID < 1 ) call MLSMessage( options%errorLevel, ModuleName, &
d1186 1
a1186 1
        call cure_host_database( hosts, machineNames )
d1199 1
a1199 1
        call cure_host_database(hosts, machineNames, .true., options%selectedHosts)
d1221 1
a1221 1
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1227 1
a1227 1
            if ( status /= 0 ) call MLSMessage ( options%errorLevel, ModuleName, &
d1269 1
a1269 1
            if ( .not. opened ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1284 1
a1284 1
            if ( .not. opened ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1383 3
a1385 1
        if ( line(3+n:7+n) == 'clean ' ) then
d1529 1
a1529 1
  subroutine IDHostFromMaster(signal, tid, mastersID, hostsID)
a1533 1
    integer, intent(in)  :: mastersID
d1571 2
a1573 2
        else
          call output('Warning--unknown tid died', advance='no')
d1586 1
a1586 1
        if ( hostsID < 1 ) call MLSMessage( MLSMSG_Warning, ModuleName, &
d1590 1
a1590 1
        call MLSMessage( MLSMSG_Warning, ModuleName, &
d1706 24
d1733 1
d1742 1
a1742 1
      call MLSMessage ( options%errorLevel, Place, &
d1749 1
a1749 5
  ! available either on the command-line or via the PCF
  ! Note the unashamed use of 'print' statements which
  ! are officially discouraged in favor of calls to MLSMessage.
  ! Unfortunately, we have not yet decided which method to use
  ! until *after* processing all the options.
d1755 1
d1821 2
d2093 1
a2093 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2142 1
a2142 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2174 1
a2174 1
      call MLSMessage( MLSMSG_Warning, ModuleName, &
d2178 1
a2178 1
      call MLSMessage( options%errorLevel, ModuleName, &
d2181 1
a2181 1
      call MLSMessage( options%errorLevel, ModuleName, &
d2184 1
a2184 1
      call MLSMessage( MLSMSG_Warning, ModuleName, &
d2187 1
a2187 1
      ! call MLSMessage( MLSMSG_Warning, ModuleName, &
d2205 1
a2205 1
      ! call MLSMessage( MLSMSG_Warning, ModuleName, &
d2250 1
a2250 1
    ! This function removess a master data type from a database of said types,
d2327 3
d2335 3
@


1.17
log
@Changed to use unbuffered output with -o dump_file
@
text
@d109 1
a109 1
       "$Id: l2q.f90,v 1.16 2007/01/12 00:41:16 pwagner Exp $"
d947 1
a947 1
          if ( numHosts > 0 .and. associated(masters(mastersID)%hosts(host)) ) then
d2274 3
@


1.16
log
@May start a new l2q to rescue things if old one dies
@
text
@d109 1
a109 1
       "$Id: l2q.f90,v 1.15 2006/11/22 18:34:24 pwagner Exp $"
d202 10
a313 6
  if ( options%dump_file /= '<STDIN>' ) then
    OutputOptions%prunit = DUMPUNIT
    ! print *, 'Opening ', prunit, ' as ', trim(options%dump_file)
    open(OutputOptions%prunit, file=trim(options%dump_file), &
      & status='replace', form='formatted')
  endif
d1067 2
a1068 22
        status = 0
        if ( tempfile /= '<STDIN>' ) then
          oldPrUnit = OutputOptions%prunit
          OutputOptions%prunit = tempUnit
          ! print *, 'Opening ', prunit, ' as ', trim(tempfile)
          open( OutputOptions%prunit, file=trim(tempfile), &
            & status='replace', form='formatted', iostat=status )
        endif
        call timestamp ( 'Received an external message to dump databases', &
          & advance='yes' )
        if ( status == 0 ) then
          call dump_master_database(masters)
          call dump(hosts)
        else
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Ignoring message; unable to open ' // &
            & trim(tempfile) )
        endif
        if ( tempfile /= '<STDIN>' ) then
          close(OutputOptions%prunit)
          OutputOptions%prunit = oldPrUnit
        endif
d1078 1
a1078 21
        status = 0
        if ( tempfile /= '<STDIN>' ) then
          oldPrUnit = OutputOptions%prunit
          OutputOptions%prunit = tempUnit
          ! print *, 'Opening ', prunit, ' as ', trim(tempfile)
          open( OutputOptions%prunit, file=trim(tempfile), &
            & status='replace', form='formatted', iostat=status )
        endif
        call timestamp ( 'Received an external message to dump hostDB', &
          & advance='yes' )
        if ( status == 0 ) then
          call dump(hosts)
        else
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Ignoring message; unable to open ' // &
            & trim(tempfile) )
        endif
        if ( tempfile /= '<STDIN>' ) then
          close(OutputOptions%prunit)
          OutputOptions%prunit = oldPrUnit
        endif
d1087 1
a1087 21
        status = 0
        if ( tempfile /= '<STDIN>' ) then
          oldPrUnit = OutputOptions%prunit
          OutputOptions%prunit = tempUnit
          ! print *, 'Opening ', prunit, ' as ', trim(tempfile)
          open( OutputOptions%prunit, file=trim(tempfile), &
            & status='replace', form='formatted', iostat=status )
        endif
        call timestamp ( 'Received an external message to dump masterDB', &
          & advance='yes' )
        if ( status == 0 ) then
          call dump_master_database(masters)
        else
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Ignoring message; unable to open ' // &
            & trim(tempfile) )
        endif
        if ( tempfile /= '<STDIN>' ) then
          close(OutputOptions%prunit)
          OutputOptions%prunit = oldPrUnit
        endif
d1232 1
a1232 16
          oldPrUnit = OutputOptions%prunit
          OutputOptions%prunit = tempUnit
          ! print *, 'Opening ', prunit, ' as ', trim(options%PHfile)
          open( OutputOptions%prunit, file=trim(options%PHFile), &
            & status='replace', form='formatted', iostat=status )
          if ( status == 0 ) then
            call timestamp ( 'Performing periodic dump hostDB', &
              & advance='yes', date=.true. )
            call dump(hosts)
            close(OutputOptions%prunit)
          else
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'No periodic dump hostDB; unable to open ' // &
              & trim(options%PHFile) )
          endif
          OutputOptions%prunit = oldPrUnit
d1247 1
a1247 16
          oldPrUnit = OutputOptions%prunit
          OutputOptions%prunit = tempUnit
          ! print *, 'Opening ', prunit, ' as ', trim(options%PMfile)
          open( OutputOptions%prunit, file=trim(options%PMFile), &
            & status='replace', form='formatted', iostat=status )
          if ( status == 0 ) then
            call timestamp ( 'Performing periodic dump masterDB', &
              & advance='yes', date=.true. )
            call dump_master_database(masters)
            close(OutputOptions%prunit)
          else
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'No periodic dump masterDB; unable to open ' // &
              & trim(options%PMFile) )
          endif
          OutputOptions%prunit = oldPrUnit
d1523 1
a1523 1
       call output (trim(machineName), advance='no')
d2005 98
d2113 2
a2114 1
    if ( options%debug ) call output( 'Releasing ' // trim(host%name) // '   ', advance='no')
d2274 3
@


1.15
log
@Tracks hosts freed by killed masters better
@
text
@d17 2
a18 2
    & PETITIONTAG, GIVEUPTAG, GRANTEDTAG, &
    & SIG_FINISHED, SIG_REGISTER, NOTIFYTAG, &
d21 1
a21 1
    & DW_INVALID, DUMP, addMachineToDatabase
d31 1
a31 1
  use MLSSTRINGS, only: LOWERCASE, READINTSFROMCHARS
d58 1
a58 1
  implicit NONE
d64 1
d67 1
d72 1
d81 2
a82 1
  integer :: TID
d93 3
a95 1
  integer, parameter          :: KILLMASTERSTAG = DUMPHOSTSDBTAG - 1
d103 2
d109 1
a109 1
       "$Id: l2q.f90,v 1.14 2006/11/03 21:27:26 pwagner Exp $"
d151 1
a151 1
    logical            :: debug = .false.         !   dump, checkh, clean}
d158 5
d230 4
d249 2
a250 1
        & (/avoidSelectedHostsTag, checkSelectedHostsTag, killMastersTag/) )) &
d262 2
a263 1
        & (/avoidSelectedHostsTag, checkSelectedHostsTag, killMastersTag/) )) &
d289 5
d298 2
d333 2
d336 2
a337 1
  call output_date_and_time(msg='starting l2q')
d345 40
a384 1
  call cure_host_database(hosts, silent=.true.)
d390 6
a395 2
    if( options%verbose ) call timestamp('Entering event loop', advance='yes')
    call event_loop
d409 1
a409 51
  subroutine cure_host_database(hosts, silent, selectedHosts)
    ! cure any recovered hosts in database--declare them fit for action
    ! If optional selectedHosts is present, cure only them
    type(Machine_T), intent(inout), dimension(:) :: hosts
    logical, optional, intent(in) :: silent
    character(len=*), optional, intent(in) :: selectedHosts
    ! Internal variables
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
    logical :: mySilent
    integer :: i
    integer :: status
    ! Executable
    mySilent = .not. options%verbose
    if ( present(silent) ) mySilent = silent .or. mySilent
    ! No need to cure if none have died
    if ( all(hosts%OK) ) return
    call GetMachineNames ( machineNames )
    do i=1, size(hosts)
      if ( hosts(i)%OK ) cycle
      ! Warning--following use of variable 'status' is non-standard
      ! status is good if non-zero, bad if 0
      status = 1
      if ( present(selectedHosts) ) &
        & status = StringElementNum(selectedHosts, trim(hosts(i)%name), .true.)
      if ( status < 1 ) cycle
      hosts(i)%OK = any( hosts(i)%name == machineNames )
      if ( hosts(i)%OK .and. .not. mySilent ) &
        & call proclaim('Host Cured', hosts(i)%Name)
    enddo
    call deAllocate_test(machineNames, 'machineNames', moduleName )
  end subroutine cure_host_database

  subroutine mark_host_database(hosts, selectedHosts)
    ! mark selected hosts in database as not to be used
    type(Machine_T), intent(inout), dimension(:) :: hosts
    character(len=*), intent(in) :: selectedHosts
    ! Internal variables
    integer :: i
    integer :: status
    ! Executable
    ! No need to mark if none can be used
    if ( all(.not. hosts%OK) ) return
    do i=1, size(hosts)
      if ( .not. hosts(i)%OK ) cycle
      ! Warning--following use of variable 'status' is non-standard
      ! status is good if non-zero, bad if 0
      status = StringElementNum(selectedHosts, trim(hosts(i)%name), .true.)
      if ( status > 0 ) hosts(i)%OK = .false.
    enddo
  end subroutine mark_host_database

d428 20
a447 17
  subroutine  rmMasterFromDatabase( DATABASE, ITEM )
    ! This function removess a master data type from a database of said types,
    ! creating a new database if it doesn't exist.  The result value is
    ! the reduced size

    ! Dummy arguments
    type (master_t), dimension(:), pointer :: DATABASE
    type (master_t), intent(in)            :: ITEM

    ! Local variables
    type (Master_T), dimension(:), pointer :: tempDatabase
    logical, parameter                     :: okToDeallocEmptyDB = .false.
    !This include causes real trouble if you are compiling in a different 
    !directory.
    include "rmItemFromDatabase.f9h" 

  end subroutine  rmMasterFromDatabase
d449 59
d527 63
d616 1
d635 68
a702 151
  subroutine get_options
    ! Internal variables
    integer :: i
    integer :: j
    integer :: lineVal
    integer :: n
    character(len=3) :: subcase
    ! Executable
    i = 1+hp
    command_line = ' '
    do ! Process Lahey/Fujitsu run-time options; they begin with "-Wl,"
      call getarg ( i, line )
      if ( line(1:4) /= '-Wl,' ) exit
      i = i + 1
    end do
    do ! Process the command line options to set toggles
      call getarg ( i, line )
      command_line = trim(command_line) // ' ' // trim(line)
      if ( line(1:2) == '--' ) then       ! "word" options
        n = 0
        switch = .true.
        if ( line(3:3) == 'n' .or. line(3:3) == 'N' ) then
          switch = .false.
          n = 1
        end if
        if ( line(3+n:7+n) == 'clean ' ) then
          options%cleanMasterDB = switch
        elseif ( line(3+n:7+n) == 'check ' ) then
          options%checklist = switch
        elseif ( line(3+n:7+n) == 'defer' ) then
          options%deferToElders = switch
        elseif ( line(3+n:5+n) == 'dhp' ) then
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          call readIntsFromChars(line, lineVal)
          options%HDBPeriod = lineVal
        elseif ( line(3+n:5+n) == 'dmp' ) then
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          call readIntsFromChars(line, lineVal)
          options%MDBPeriod = lineVal
        elseif ( lowerCase(line(3+n:10+n)) == 'dumpnewm' ) then
          options%dumpEachNewMaster = switch
        elseif ( lowerCase(line(3+n:10+n)) == 'help' ) then
          call option_usage
        elseif ( lowerCase(line(3+n:10+n)) == 'inquire' ) then
          options%command = 'inquire'
        else if ( line(3+n:10+n) == 'version ' ) then
          do j=1, size(current_version_id)
            print*, current_version_id(j)
          enddo
          stop
        else if ( line(3+n:7+n) == 'reviv' ) then
          options%reviveHosts = switch
        else if ( line(3+n:7+n) == 'wall ' ) then
          time_config%use_wall_clock = switch
        else if ( line(3:) == ' ' ) then  ! "--" means "no more options"
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          exit
        else
          print *, 'unrecognized option ', trim(line), ' ignored.'
          call option_usage
        end if
      else if ( line(1:1) == '-' ) then   ! "letter" options
        j = 1
        j = j + 1
        select case ( line(j:j) )
        case ( ' ' )
          exit
        case ( 'g' )
          toggle(gen) = .true.
          levels(gen) = 0
          if ( j < len(line) ) then
            if ( line(j+1:j+1) >= '0' .and. line(j+1:j+1) <= '9' ) then
              j = j + 1
              levels(gen) = ichar(line(j:j)) - ichar('0')
            end if
          end if
        case ( 'h', 'H', '?' )     ! Describe command line usage
          call option_usage
        case ( 'T' )
          options%timing = .true.
          do
            if ( j >= len(line) ) exit
            if ( line(j+1:j+1) > '0' .and. line(j+1:j+1) <= '9' ) then
              options%date_and_times = .true.
            elseif ( lowercase(line(j+1:j+1)) == 's' ) then
              options%timingUnits = 's'  ! l_seconds
            elseif ( lowercase(line(j+1:j+1)) == 'm' ) then
              options%timingUnits = 'm'
            elseif ( lowercase(line(j+1:j+1)) == 'h' ) then
              options%timingUnits = 'h'
            end if
            j = j + 1
          enddo
        case ( 'v' ); options%verbose = .true.
        case ( 'd' ); options%debug = .true.
        case ( 'k' ); options%command = 'suicide' ! options%killer = .true.
        case ( 'c' )
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          options%command = lowercase(line)
          ! Special commands take yet another arg
          if ( index('check,avoid,kill', trim(options%command)) > 0 ) then
            i = i + 1
            call getarg ( i, line )
            command_line = trim(command_line) // ' ' // trim(line)
            options%selectedHosts = lowercase(line)
          endif
        case ( 'o' )
          subcase = line(j:j+2)
          i = i + 1
          call getarg ( i, line )
          ! print *, 'subcase: ', subcase
          ! print *, 'file: ', trim(line)
          command_line = trim(command_line) // ' ' // trim(line)
          if ( subcase == 'o') then
          options%dump_file = line
        ! case ( 'oph' )
          ! i = i + 1
          ! call getarg ( i, line )
          ! command_line = trim(command_line) // ' ' // trim(line)
          elseif ( subcase == 'oph') then
          options%PHFile = line
        ! case ( 'opm' )
          !  i = i + 1
          !call getarg ( i, line )
          !command_line = trim(command_line) // ' ' // trim(line)
          elseif ( subcase == 'opm') then
          options%PMFile = line
          endif
        case ( 's' )
          options%command = 'switch'
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
          options%dump_file = line
        case default
          print *, 'Unrecognized option -', line(j:j), ' ignored.'
          call option_usage
        end select
      else    
        exit ! This must be the hosts filename
      end if
      i = i + 1
    end do
d704 3
a706 3
  end subroutine get_options
   
  subroutine event_loop
d749 4
d756 1
a1019 1
      ! call PVMFNRecv ( -1, GiveUpTag, bufferIDRcv )
d1182 21
d1209 1
a1209 1
        call cure_host_database(hosts)
d1222 1
a1222 1
        call cure_host_database(hosts, .true., options%selectedHosts)
d1295 1
a1295 1
              & advance='yes' )
d1325 1
a1325 1
              & advance='yes' )
d1352 9
a1360 4
  subroutine assignHostToMaster(host, master, hostsID)
    type(Machine_T) :: host
    type(master_t) :: master
    integer, intent(in) :: hostsID
d1362 4
a1365 4
    integer :: bufferID
    integer :: hcid
    integer :: info
    integer, dimension(:), pointer :: tempHosts
d1367 29
a1395 16
    ! 1st--check that host is free and OK
    if ( .not. (host%free .and. host%OK) ) then
      call dump(host)
      call dump_master(master)
      call MLSMessage( options%errorLevel, ModuleName, &
      & 'Tried to assign an unqualified host to this master' )
    elseif( master%owes_thanks ) then
      call MLSMessage( options%errorLevel, ModuleName, &
      & 'Tried to assign host to an ungrateful master' )
    endif      
    host%master_tid = master%tid
    host%free = .false.
    host%tid = 0
    if ( options%debug) then
       call output ('Number of machines free: ', advance='no')
       call timestamp (count(hosts%free), advance='yes')
d1397 14
a1410 37
    hcid = 1
    if ( .not. associated(master%hosts) ) then
      nullify(master%hosts)
      call allocate_test(master%hosts, 1, 'master%hosts', moduleName)
    elseif( size(master%hosts) < 1 ) then
      call allocate_test(master%hosts, 1, 'master%hosts', moduleName)
    else
      ! We'll need a larger hosts component in master, so ..
      nullify(tempHosts)
      hcid = size(master%hosts) + 1
      call allocate_test(tempHosts, hcid, 'temphosts', moduleName)
      tempHosts(1:hcid-1) = master%hosts
      call deallocate_test(master%hosts, 'master%hosts', moduleName)
      master%hosts => tempHosts
    endif
    master%hosts(hcid) = hostsid
    ! Now use PVM to tell master he's got a new slave host
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( trim(host%name), info )
    if ( info /= 0 ) &
      & call myPVMErrorMessage ( info, 'packing host name' )
    if ( options%debug ) &
      & call proclaim('Sending new host ' // trim(host%name), &
      & masterNameFun(master%Tid))
    call PVMFSend ( master%tid, grantedTag, info )
    master%owes_thanks = .true.
    master%needs_host = .false.
    master%numHosts = master%numHosts + 1
  end subroutine assignHostToMaster
  
  subroutine IDHostFromMaster(signal, tid, mastersID, hostsID)
    ! Figure out which master is talking about
    ! Arguments
    integer, intent(in)  :: signal
    integer, intent(out) :: tid
    integer, intent(in)  :: mastersID
    integer, intent(out) :: hostsID
d1412 178
a1589 2
    integer :: info
    character(len=MACHINENAMELEN) :: machineName
d1648 1
d1727 5
a1731 4
  subroutine releaseHostFromMaster(host, master, hostsID)
    type(Machine_T) :: host
    type(master_t) :: master
    integer, intent(in) :: hostsID
d1733 2
a1734 3
    integer :: hcid
    integer, dimension(:), pointer :: tempHosts
    integer :: i, status
d1736 35
a1770 37
    if ( options%debug ) call output( 'Releasing ' // trim(host%name) // '   ', advance='no')
    if( size(master%hosts) < 1 .and. .not. master%owes_thanks ) then
      call MLSMessage( MLSMSG_Warning, ModuleName, &
        & 'master lacks any hosts' )
      return
    elseif ( hostsID < 1 ) then
      call MLSMessage( options%errorLevel, ModuleName, &
        & 'Programming error--hostsID=0 in releaseHostFromMaster' )
    elseif ( hostsID > size(hosts) ) then
      call MLSMessage( options%errorLevel, ModuleName, &
        & 'Programming error--hostsID>size(hosts) in releaseHostFromMaster' )
    elseif ( master%owes_thanks ) then
      call MLSMessage( MLSMSG_Warning, ModuleName, &
        & 'master still owes thanks' )
    elseif ( .not. associated(master%hosts) ) then
      ! call MLSMessage( MLSMSG_Warning, ModuleName, &
      !  & 'master lacks any hosts' )
      call timestamp('master lacks any hosts', advance='yes' )
      return
    elseif ( host%master_tid /= master%tid ) then
      call output('host%master_tid ', advance='no')
      call output(host%master_tid, advance='no')
      call output('   master%tid ', advance='no')
      call output(master%tid, advance='no')
      call timestamp('Host not assigned to that master', advance='yes' )
      return
    elseif ( .not. any(master%hosts == hostsID) ) then
      call output('hostsID ', advance='no')
      call output(hostsID, advance='no')
      call output('   name ', advance='no')
      call output(trim(host%name) // '   ', advance='no')
      call newline
      call dump_his_hosts(master%hosts, sortUs=.true.)
      ! call MLSMessage( MLSMSG_Warning, ModuleName, &
      !  & 'master lacks that host' )
      call timestamp( '; master lacks that host', advance='yes' )
      return
d1772 25
a1796 109
    if ( host%tid > 0 ) then
      ! In case slave task is still running, try to kill it
      call pvmfpstat(host%tid, status)
      if ( status == PVMOK ) then
        call pvmfkill(host%tid, status)
        if ( status /= 0 ) then
          call proclaim('Failed to kill running task', &
            & trim(host%name), signal=host%tid)
        endif
      endif
    endif
    host%tid = 0
    host%master_tid = 0
    host%free = .true.
    host%chunk = -1
    host%master_name = ' '
    host%master_date = ' '
    hcid = 0
    if( size(master%hosts) == 1 ) then
      call deallocate_test(master%hosts, 'master%hosts', moduleName)
    else
      ! We'll need a smaller hosts component in master, so ..
      nullify(tempHosts)
      hcid = size(master%hosts) - 1
      call allocate_test(tempHosts, hcid, 'temphosts', moduleName)
      hcid = 0
      do i=1, size(master%hosts)
        if ( master%hosts(i) == hostsID ) cycle
        hcid = hcid + 1
        tempHosts(hcid) = master%hosts(i)
      enddo
      call deallocate_test(master%hosts, 'master%hosts', moduleName)
      master%hosts => tempHosts
    endif
    master%numHosts = master%numHosts - 1
    master%numFreed = master%numFreed + 1
  end subroutine releaseHostFromMaster
  
  subroutine read_list
    type(Machine_T) :: newhost
    integer :: iostat
    integer :: nhosts
    nhosts = 0
    do
        if ( inunit >= 0 ) then
          read ( inunit, '(a)', advance='no', eor=100, end=200, err=400, &
            iostat=iostat ) newhost%name
        else
          read ( *, '(a)', advance='no', eor=100, end=200, err=400, &
            iostat=iostat ) newhost%name
        end if
100     if ( options%verbose ) &
          & call output(trim(newhost%name) // ' added', advance='yes')
      newhost%master_tid = -1
      newhost%tid = -1
      newhost%chunk = -1
      newhost%OK = .false.
      newhost%free = .true.
      nhosts = addMachineToDatabase(hosts, newhost)
    enddo
200 if ( options%verbose ) then
      call output(nhosts, advance='no')
      call timestamp(' hosts read', advance='yes')
    endif
    return
400 call MLSMessage( MLSMSG_Error, ModuleName, &
      & 'error in reading list of hosts' )
  end subroutine read_list

  subroutine SayTime ( What )
    character(len=*), intent(in), optional :: What
    ! Internal variables
    ! real :: t_conversion
    ! Executable
    call time_now ( t2 )
    if ( options%date_and_times ) then
      call output_date_and_time(advance='no')
    else
      call output ( "time (now) " )
      call output ( dble(t_conversion*t2), advance = 'no' )
    endif
    call blanks ( 4, advance = 'no' )
    ! call output ( "time (elapsed) " // what // " = " )
    ! call output ( dble(t2 - t1), advance = 'yes' )
    if ( present(What) ) call output ( trim(what), advance = 'yes' )
  end subroutine SayTime

  ! The following offer some information on the options
  ! available either on the command-line or via the PCF
  ! Note the unashamed use of 'print' statements which
  ! are officially discouraged in favor of calls to MLSMessage.
  ! Unfortunately, we have not yet decided which method to use
  ! until *after* processing all the options.
  
  subroutine Option_usage
    call getarg ( 0+hp, line )
    print *, 'Usage: ', trim(line), ' [options] [--] [LIST-name]'
    print *, ' Options:'
    print *, ' --check:     check LIST of hosts'
    print *, ' --[n]clean:  do [not] regularly clean db of finished masters'
    print *, ' --defer:     new masters defer to oldest (has enough hosts)'
    print *, ' --dhp n :    dump host db every n seconds (need phfile)'
    print *, ' --dmp m :    dump master db every m seconds (need pmfile)'
    print *, ' --dumpnewm:  dump each new master'
    print *, ' --help:      show help; stop'
    print *, ' --inquire:   show whether an instance of l2q already running'
    print *, ' --[n]revive: do [not] regularly check for revived hosts'
    print *, ' --version:   print version string; stop'
    print *, ' --wall:      show times according to wall clock (if T[0] set)'
d1807 3
d1820 3
a1848 92
  subroutine Dump_settings
  ! Show current run-time settings
    call output(' l2q called with command line options: ', advance='no')
    call output(trim(command_line), advance='yes')
    call output(' LIST file:', advance='no')  
    call blanks(4, advance='no')                                     
    call output(trim(options%LIST_file), advance='yes')                            
    call output(' -------------- Summary of run time options'      , advance='no')
    call output(' -------------- ', advance='yes')
    call output(' Just check the host list:                       ', advance='no')
    call blanks(4, advance='no')
    call output(options%checkList, advance='yes')
    call output(' Debug               :                           ', advance='no')
    call blanks(4, advance='no')
    call output(options%debug, advance='yes')
    call output(' Verbose             :                           ', advance='no')
    call blanks(4, advance='no')
    call output(options%verbose, advance='yes')
    call output(' Dump each new master:                           ', advance='no')
    call blanks(4, advance='no')
    call output(options%dumpEachNewMaster, advance='yes')
    call output(' Regularly check for revived hosts:              ', advance='no')
    call blanks(4, advance='no')
    call output(options%reviveHosts, advance='yes')
    call output(' Regularly clean db of finished masters:         ', advance='no')
    call blanks(4, advance='no')
    call output(options%cleanMasterDB, advance='yes')
    call output(' New masters defer to old:                       ', advance='no')
    call blanks(4, advance='no')
    call output(options%deferToElders, advance='yes')
    if ( options%PMFile /= '') then
    call output(' Periodically dump Master DB to:                 ', advance='no')
    call blanks(4, advance='no')
    call output(trim(options%PMFile), advance='yes')
    call output(' Period (s):                                     ', advance='no')
    call blanks(4, advance='no')
    call output(options%MDBPeriod, advance='yes')
    endif
    if ( options%PHFile /= '') then
    call output(' Periodically dump host DB to:                   ', advance='no')
    call blanks(4, advance='no')
    call output(trim(options%PHFile), advance='yes')
    call output(' Period (s):                                     ', advance='no')
    call blanks(4, advance='no')
    call output(options%HDBPeriod, advance='yes')
    endif
    call output(' Dump other output to:                           ', advance='no')
    call blanks(4, advance='no')
    call output(trim(options%dump_File), advance='yes')
    call output(' Using unit number:                              ', advance='no')
    call blanks(4, advance='no')
    call output(OutputOptions%prunit, advance='yes')
    call output(' Time stamp each report:                         ', advance='no')
    call blanks(4, advance='no')
    call output(options%Timing, advance='yes')
    call output(' Show date and times:                            ', advance='no')
    call blanks(4, advance='no')
    call output(options%date_and_times, advance='yes')
    call output(' Stamp time in what units?:                       ', advance='no')
    call blanks(4, advance='no')
    call output(options%timingUnits, advance='yes' )
    call output(' Using wall clock instead of cpu time?:          ', advance='no')
    call blanks(4, advance='no')
    call output(time_config%use_wall_clock, advance='yes')
    call output(' ----------------------------------------------------------', &
      & advance='yes')
  end subroutine Dump_settings

  ! ---------------------------------------------  dump_his_hosts  -----
  subroutine dump_his_hosts( hostIDs, sortUs )
    integer, dimension(:), intent(in)   :: hostIDs
    logical, intent(in), optional   :: sortUs
    ! Internal variables
    integer :: i
    integer, dimension(size(hostIDs)) :: myHostIDs
    character(len=MACHINENAMELEN), dimension(size(hostIDs)) :: myHostNames
    logical :: mySort
    integer :: maxNameLength
    ! Executable
    mySort = .false.
    if ( present(sortUs) ) mySort=sortUs
    myHostIDs = hostIDs
    if ( mySort ) call sort(myHostIDs, 1, size(hostIDs))
    maxNameLength = 1
    do i=1, size(hostIDs)
      myHostNames(i) = hosts(myHostIDs(i))%name
      maxNameLength = max(maxNameLength, len_trim(myHostNames(i)) + 1)
    enddo
    maxNameLength = min(maxNameLength, MACHINENAMELEN)
    call dump( myHostNames(:)(1:maxNameLength) )
  end subroutine dump_his_hosts

d1873 96
a1968 4
  ! ---------------------------------------------  announce_success  -----
  subroutine announce_success ( Name, unit_number )
    character(LEN=*), intent(in)   :: Name
    integer, intent(in)            :: unit_number
d1970 16
a1985 2
    call output ( 'List of hosts file ' )
    call output ( 'name : ' )
d1987 11
a1997 3
    call output ( trim(Name), advance='no')
    call blanks(10)
    call output ( 'unit number : ' )
d1999 11
a2009 7
    call timestamp ( unit_number, advance='yes')
  end subroutine announce_success

  ! ---------------------------------------------  masterNameFun  -----
  function masterNameFun ( masterTid ) result(name)
    character(LEN=MachineNameLen)  :: Name
    integer, intent(in)            :: masterTid
d2011 25
a2035 1
    integer :: mastersID
d2037 158
a2194 3
    mastersID = FindFirst(masters%tid, masterTid)
    name = catLists('m', mastersID, inseparator='-')
  end function masterNameFun
d2196 18
a2213 5
  subroutine myPVMErrorMessage ( info, place )
    ! This routine is called to log a PVM error
    integer, intent(in) :: INFO
    character (LEN=*) :: PLACE
    character (LEN=132) :: LINE
d2215 32
a2246 3
    write (line, * ) info
    if ( options%exitOnError ) then
      call PVMErrorMessage ( info, place )
d2248 7
a2254 2
      call MLSMessage ( options%errorLevel, Place, &
        & 'PVM Error:  Info='//trim(adjustl(line)))
d2256 2
a2257 1
  end subroutine myPVMErrorMessage
d2261 3
@


1.14
log
@Another last-minute freezing bug fixed (or so we hope)
@
text
@d64 1
d101 1
a101 1
       "$Id: l2q.f90,v 1.13 2006/11/01 20:45:29 pwagner Exp $"
d796 2
d799 1
d1215 1
a1215 1
          if ( options%debug ) then
d1245 1
a1245 1
          if ( options%debug ) then
d1339 11
d1400 1
d1407 1
d1414 1
d1417 1
d1474 1
d1494 4
d1826 3
@


1.13
log
@Fixed another freezing bug
@
text
@d100 1
a100 1
       "$Id: l2q.f90,v 1.12 2006/09/29 00:31:21 pwagner Exp $"
d754 2
a755 1
              & masters%numChunks > (masters%numHosts+masters%numFreed) )
d792 1
a792 1
              call timestamp (count(hosts%free), advance='yes')
d1176 2
a1177 1
            & masters%numChunks > (masters%numHosts+masters%numFreed) )
d1455 1
a1455 1
    if( size(master%hosts) < 1 ) then
d1465 3
d1802 3
@


1.12
log
@Many life-prolonging changes; may kill masters if so commanded
@
text
@d100 1
a100 1
       "$Id: l2q.f90,v 1.11 2006/08/02 22:48:22 pwagner Exp $"
d862 2
d868 1
a868 1
          if ( numHosts > 0 ) then
d1797 3
@


1.11
log
@prunit now a component of OutputOptions
@
text
@d14 1
d29 2
a30 1
  use MLSSTRINGLISTS, only: CATLISTS, STRINGELEMENTNUM
d63 1
d69 1
d88 3
a90 1
  integer, parameter          :: SWITCHDUMPFILETAG = DUMPHOSTSDBTAG - 1
d93 1
d100 1
a100 1
       "$Id: l2q.f90,v 1.10 2005/11/15 22:39:58 pwagner Exp $"
d115 1
d143 2
d146 1
a146 1
      &                :: LIST_file               ! name of hosts file
d185 3
d217 1
a217 1
        tag = GiveUpTag
d222 2
d230 3
a232 1
      if ( any(tag == (/avoidSelectedHostsTag, checkSelectedHostsTag/) )) then
d242 3
a244 1
      if ( any(tag == (/avoidSelectedHostsTag, checkSelectedHostsTag/) )) then
d246 1
a246 1
      elseif ( any(tag == (/dumpHostsDBTag,dumpMastersDBTag, dumpDBTag, &
d272 1
a272 1
    & call PVMErrorMessage ( status, 'Joining '//GROUPNAME//' group' )
a334 17
!   integer function  addHostToDatabase( DATABASE, ITEM )
!     ! This function adds a host data type to a database of said types,
!     ! creating a new database if it doesn't exist.  The result value is
!     ! the size -- where the new item is put.
! 
!     ! Dummy arguments
!     type (Machine_T), dimension(:), pointer :: DATABASE
!     type (Machine_T), intent(in) :: ITEM
! 
!     ! Local variables
!     type (Machine_T), dimension(:), pointer :: tempDatabase
!     !This include causes real trouble if you are compiling in a different 
!     !directory.
!     include "addItemToDatabase.f9h" 
! 
!     AddHostToDatabase = newSize
!   end function  addHostToDatabase
d474 2
d587 1
a587 1
        case ( 'k' ); options%command = 'kill' ! options%killer = .true.
d594 1
a594 1
          if ( index('check,avoid', trim(options%command)) > 0 ) then
d652 2
a653 1
    logical :: DUMPDB
d657 2
d670 1
d688 2
a689 1
      dumpdb = .false.
d696 1
a696 1
        call PVMErrorMessage ( info, "checking for Petition message" )
d704 1
a704 1
          & call PVMErrorMessage ( info, "calling PVMFBufInfo" )
d707 1
a707 1
          call PVMErrorMessage ( info, "unpacking signal" )
d715 5
a719 1
            call PVMErrorMessage ( info, "unpacking number of chunks" )
d724 1
a724 1
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
d735 1
a735 1
          if ( info /= 0 ) call PVMErrorMessage ( info, 'setting up notify' )
d746 1
d795 1
d804 1
a804 1
            call PVMErrorMessage ( info, "unpacking tid" )
d808 1
a808 1
            call PVMErrorMessage ( info, "unpacking machineName" )
d816 1
a816 1
            call MLSMessage( MLSMSG_Error, ModuleName, &
d822 1
a822 1
            call PVMErrorMessage ( info, "unpacking machine%chunk" )
d826 1
a826 1
            call PVMErrorMessage ( info, "unpacking machine%master_date" )
d828 1
a828 4
          ! call PVMF90Unpack ( hosts(hostsID)%master_name, info )
          ! if ( info /= 0 ) then
          !   call PVMErrorMessage ( info, "unpacking machine%master_name" )
          ! endif
d837 1
a859 12
            ! The next snippet has been superseded by mark_hosts_database
            ! Now see if any other hosts are associated with this machine name
            ! (we'll assume the processors on amultiprocessor node are either 
            !  all good or all bad)
            ! if ( tid < 1 ) then
            !   call FindAll(hosts%name, machineName, Tids, nTids)
            !   if ( nTids > 1 ) then
            !     do host=2, nTids
            !       hosts(host)%OK = .false.
            !     enddo
            !   endif
            ! endif
d861 1
d888 1
d894 1
a894 1
          call MLSMessage( MLSMSG_Error, ModuleName, &
d901 1
a901 1
          & call PVMErrorMessage ( info, 'freeing receive buffer' )
d909 1
a909 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking dead masterTid' )
d913 1
a913 1
        if ( mastersID < 1 ) call MLSMessage( MLSMSG_Error, ModuleName, &
d939 1
d943 2
a944 1
      call PVMFNRecv ( -1, GiveUpTag, bufferIDRcv )
d984 1
a984 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking GROUPNAME' )
d986 1
a986 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking dumpfile' )
d1009 2
d1015 1
a1015 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking GROUPNAME' )
d1017 1
a1017 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking dumpfile' )
d1039 1
d1044 1
a1044 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking GROUPNAME' )
d1046 1
a1046 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking dumpfile' )
d1068 24
d1098 1
a1098 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking GROUPNAME' )
d1100 1
a1100 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking selectedHosts' )
d1104 1
d1111 4
a1114 2
      if ( bufferIDRcv > 0 .or. checkrevivedhosts ) &
        & call cure_host_database(hosts)
d1120 1
a1120 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking GROUPNAME' )
d1122 1
a1122 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking selectedHosts' )
d1126 1
d1133 1
a1133 1
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking GROUPNAME' )
d1140 1
a1140 1
          if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking newdumpfile' )
d1153 1
a1153 1
            if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1189 1
a1189 1
        if ( t2-tLastHDBDump > options%HDBPeriod ) then
d1207 7
d1219 1
a1219 1
        if ( t2-tLastMDBDump > options%MDBPeriod ) then
d1237 7
d1268 1
a1268 1
      call MLSMessage( MLSMSG_Error, ModuleName, &
d1271 1
a1271 1
      call MLSMessage( MLSMSG_Error, ModuleName, &
a1298 3
    ! call PVMF90Pack ( sig_requestHost, info )
    ! if ( info /= 0 ) &
    !   & call PVMErrorMessage ( info, 'packing registration' )
d1301 1
a1301 1
      & call PVMErrorMessage ( info, 'packing host name' )
d1325 1
a1325 1
      call PVMErrorMessage ( info, "unpacking tid" )
d1329 1
a1329 1
      call PVMErrorMessage ( info, "unpacking machineName" )
d1367 74
d1456 1
a1456 1
      call MLSMessage( MLSMSG_Error, ModuleName, &
d1459 1
a1459 1
      call MLSMessage( MLSMSG_Error, ModuleName, &
a1589 1
    ! print *, ' -g:          turn tracing on'
a1590 1
    print *, '               ( same as -c kill )'
d1612 2
a1613 1
    print *, ' kill:        kill currently-running l2q'
d1685 3
d1778 14
d1795 3
@


1.10
log
@More robust against failures while openeing dump files
@
text
@d30 1
a30 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, PRUNIT, &
d93 1
a93 1
       "$Id: l2q.f90,v 1.9 2005/09/23 21:01:13 pwagner Exp $"
d259 1
a259 1
    prunit = DUMPUNIT
d261 1
a261 1
    open(prunit, file=trim(options%dump_file), &
d313 1
a313 1
  if ( options%dump_file /= '<STDIN>' ) close(prunit)
d984 2
a985 2
          oldPrUnit = prunit
          prUnit = tempUnit
d987 1
a987 1
          open( prunit, file=trim(tempfile), &
d1001 2
a1002 2
          close(prunit)
          prunit = oldPrUnit
d1013 2
a1014 2
          oldPrUnit = prunit
          prUnit = tempUnit
d1016 1
a1016 1
          open( prunit, file=trim(tempfile), &
d1029 2
a1030 2
          close(prunit)
          prunit = oldPrUnit
d1041 2
a1042 2
          oldPrUnit = prunit
          prUnit = tempUnit
d1044 1
a1044 1
          open( prunit, file=trim(tempfile), &
d1057 2
a1058 2
          close(prunit)
          prunit = oldPrUnit
d1098 1
a1098 1
        if ( prunit == DUMPUNIT ) then
d1108 1
a1108 1
          open( prunit, file=trim(options%dump_file), &
d1115 1
a1115 1
            open( prunit, file=trim(options%dump_file), &
d1154 2
a1155 2
          oldPrUnit = prunit
          prUnit = tempUnit
d1157 1
a1157 1
          open( prunit, file=trim(options%PHFile), &
d1163 1
a1163 1
            close(prunit)
d1169 1
a1169 1
          prunit = oldPrUnit
d1177 2
a1178 2
          oldPrUnit = prunit
          prUnit = tempUnit
d1180 1
a1180 1
          open( prunit, file=trim(options%PMFile), &
d1186 1
a1186 1
            close(prunit)
d1192 1
a1192 1
          prunit = oldPrUnit
d1658 3
@


1.9
log
@use_wall_clock now a component of time_config
@
text
@d93 1
a93 1
       "$Id: l2q.f90,v 1.8 2005/06/22 19:27:33 pwagner Exp $"
d667 1
d982 1
d987 2
a988 2
          open(prunit, file=trim(tempfile), &
            & status='replace', form='formatted')
d992 8
a999 2
        call dump_master_database(masters)
        call dump(hosts)
d1011 1
d1016 2
a1017 2
          open(prunit, file=trim(tempfile), &
            & status='replace', form='formatted')
d1021 7
a1027 1
        call dump(hosts)
d1039 1
d1044 2
a1045 2
          open(prunit, file=trim(tempfile), &
            & status='replace', form='formatted')
d1049 7
a1055 1
        call dump_master_database(masters)
d1100 1
d1108 15
a1122 3
          open(prunit, file=trim(options%dump_file), &
            & status='replace', form='formatted')
          call timestamp('(new dump file opened)', advance='yes')
d1157 12
a1168 6
          open(prunit, file=trim(options%PHFile), &
            & status='replace', form='formatted')
          call timestamp ( 'Performing periodic dump hostDB', &
            & advance='yes' )
          call dump(hosts)
          close(prunit)
d1180 12
a1191 6
          open(prunit, file=trim(options%PMFile), &
            & status='replace', form='formatted')
          call timestamp ( 'Performing periodic dump masterDB', &
            & advance='yes' )
          call dump_master_database(masters)
          close(prunit)
d1658 3
@


1.8
log
@Reworded Copyright statement, moved rcs id
@
text
@d39 1
a39 1
  use Time_M, only: Time_Now, Use_Wall_Clock
d91 1
a91 1
       "$RCSfile: MLSL2.f90,v $"
d93 1
a93 1
       "$Id: MLSL2.f90,v 2.138 2005/06/22 18:57:02 pwagner Exp $"
d158 1
a158 1
  use_wall_clock = .true.
d539 1
a539 1
          use_wall_clock = switch
d1529 1
a1529 1
    call output(use_wall_clock, advance='yes')
d1611 3
@


1.7
log
@May periodically autodump masters, hosts files
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d89 7
a95 6
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: IdParm = & 
     "$Id: l2q.f90,v 1.6 2005/03/18 00:59:36 pwagner Exp $"
  character(len=len(idParm)) :: Id = idParm
  character(len=*), parameter :: ModuleName="$RCSfile: l2q.f90,v $"
  !-----------------------------------------------------------------------------
d1611 3
@


1.6
log
@Now gets PVMERRORMESSAGE from MLSMessageModule
@
text
@d21 1
a21 1
  use MLSSTRINGS, only: LOWERCASE
d83 1
a83 1
     "$Id: l2q.f90,v 1.5 2005/02/03 19:10:11 pwagner Exp $"
d132 8
a139 2
    character(len=1) :: timingUnits = 's'         ! l_s, l_m, l_h
    character(len=2048) :: selectedHosts =''      ! E.g., 'c0-1,c0-23,c0-55'
d154 3
d251 1
d282 1
a282 1
  if( options%verbose ) then
d477 1
d479 1
d502 1
a502 1
        elseif ( line(3+n:6+n) == 'defer' ) then
d504 12
d534 1
d578 1
d584 1
d588 1
d591 4
d596 13
d613 1
d661 2
d666 2
d975 1
d997 1
d1018 1
d1075 1
d1106 34
d1405 2
d1416 3
a1418 1
    print *, ' -o dumpfile: direct most output to dumpfile'
d1490 19
d1602 3
@


1.5
log
@Receives master_date, master_time data from masters for each host
@
text
@d18 1
a18 1
    & MLSMSG_Info, MLSMSG_Warning
d27 1
a27 1
    & PVMF90UNPACK, PVMERRORMESSAGE, PVMFPSTAT, &
d83 1
a83 1
     "$Id: l2q.f90,v 1.4 2005/01/20 00:54:25 pwagner Exp $"
d609 1
d649 4
a652 1
          call GetMachineNameFromTid ( masterTid, aMaster%Name )
d827 1
d1491 3
@


1.4
log
@Implementing changes suggested at design review Jan 14 2005
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d83 1
a83 1
     "$Id: l2q.f90,v 1.3 2005/01/14 21:39:04 pwagner Exp $"
d732 8
d741 13
a836 1
      ! if ( options%debug ) call output('Listening for giveuptag', advance='yes')
a873 1
      ! if ( options%debug ) call output('Listening for giveuptag', advance='yes')
d1225 3
d1486 3
@


1.3
log
@Changes bring us into line with pw presentation of 20050114
@
text
@d18 1
a18 1
    & MLSMSG_Warning
d20 1
a20 1
  use MLSSTRINGLISTS, only: CATLISTS
d22 2
a23 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, PRUNIT
d43 1
a43 1
  ! l2q [options] [<] [list]
a65 1
  character(len=2048) :: WORD       ! Some text
d69 4
a72 2
  integer, parameter          :: CHECKREVIVEDHOSTSTAG = GIVEUPTAG - 1
  integer, parameter          :: CLEANMASTERDBTAG = CHECKREVIVEDHOSTSTAG - 1
a80 5
  ! integer, parameter          :: DELAYBETWEENASSIGNMENTS = 20  ! GMasters r slow
  ! Wait until the oldest master has all the hosts he'll need before assigning
  ! hosts to any of the young whippersnappers?
  ! logical, parameter          :: ALWAYSDEFERTOELDERS = .true.
  ! (moved to options%deferToElders)
d83 1
a83 1
     "$Id: l2q.f90,v 1.2 2004/12/23 00:19:30 pwagner Exp $"
a95 10
  ! Our data type for the hosts we'll be communicating with via pvm
!   type Machine_T
!     character(len=MACHINENAMELEN) :: name
!     integer                       :: master_tid
!     integer                       :: tid
!     integer                       :: chunk
!     logical                       :: alive
!     logical                       :: free
!   end type Machine_T

d109 7
a115 7
  ! This datatype logs a request for a host
  type HostRequest_T
    integer :: Master=0                 ! Which master made the request
    integer :: CHUNK=0                  ! Which chunk is it for
    integer :: TICKET=0                 ! What ticket number is it
    integer :: STATUS=DW_INVALID        ! One of the DW_Status types
  end type HostRequest_T
d123 2
a124 2
    logical            :: reviveHosts = .true.    ! Regularly check for revivals
    character(len=8)   :: command = 'run'         ! {run, kill, dumphdb, dumpmdb
d133 1
d158 1
a158 1
  ! Make sure no l2q is already alive and running
d161 5
a165 2
    ! Have we been ordered to communicate with an already-running task?
    if ( options%command /= 'run' ) then
d171 5
a175 1
      case ( 'checkh' )
d197 5
a201 1
      call PVMF90Pack ( trim(options%dump_file), info )
d205 8
a212 2
      call output(tid, advance='yes')
      call output(' commanded: '//trim(options%command), advance='yes')
d220 7
a226 2
  if ( options%command /= 'run' ) call MLSMessage( MLSMSG_Error, ModuleName, &
    & 'l2q not running--ignoring command '//trim(options%command) )
d283 1
a283 1
    if( options%verbose ) call output('Entering event loop', advance='yes')
d315 1
a315 1
  subroutine cure_host_database(hosts, silent)
d317 1
d320 1
d334 6
d347 19
d494 4
d554 6
a609 1
    ! integer :: sinceLastAssignment
a616 1
    ! sinceLastAssignment = 0
d666 1
a666 1
            call output(' total)', advance='yes')
a690 1
          ! elseif ( grandMastersID < mastersID .or. sinceLastAssignment > 0 ) then
a697 1
            ! sinceLastAssignment = DELAYBETWEENASSIGNMENTS
d711 1
a711 1
              call output(' remaining)', advance='yes')
d713 1
a713 1
              call output (count(hosts%free), advance='yes')
d738 1
a738 1
            call output(' )', advance='yes')
d750 3
a752 1
            hosts(hostsID)%OK = .false.
d758 1
a758 1
              call output(' )', advance='yes')
d762 1
d766 8
a773 8
            if ( tid < 1 ) then
              call FindAll(hosts%name, machineName, Tids, nTids)
              if ( nTids > 1 ) then
                do host=2, nTids
                  hosts(host)%OK = .false.
                enddo
              endif
            endif
d799 1
a799 1
            call output(' total)', advance='yes')
d809 2
a810 1
        if ( options%debug .and. info /= 0 ) call output('Trouble freeing buf', advance='yes')
d848 1
a848 1
            call output(' total)', advance='yes')
d858 1
a858 1
        call output ( 'Received an external message to give up, so finishing now', &
d866 2
d873 2
d881 3
d885 2
a886 2
        if ( options%debug ) &
          & call output('Cleaning database of finished masters', advance='yes')
d904 2
d925 2
d945 2
d953 12
d968 15
a982 2
      if ( bufferIDRcv > 0 .or. checkrevivedhosts ) then
        call cure_host_database(hosts)
d996 1
a996 1
          call output(trim(options%dump_file), advance='yes')
d1000 1
a1000 1
          call output('(new dump file opened)', advance='yes')
d1002 1
a1002 1
          call output('(switchDumpFileTag ignored--dumping to <STDIN>)', &
a1007 1
      ! if ( mayAssignAHost .and. sinceLastAssignment < 1 ) then
a1022 1
            ! sinceLastAssignment = delaybetweenAssignments
a1031 1
        ! sinceLastAssignment = max(0, sinceLastAssignment - 1)
a1032 2
      ! if ( any(masters%owes_thanks) ) &
      !   & call usleep ( 2*parallel%delay )
d1061 1
a1061 1
       call output (count(hosts%free), advance='yes')
d1137 1
a1137 1
        call output(hostsID, advance='yes')
d1175 1
a1175 1
      call output('master lacks any hosts', advance='yes' )
d1178 1
a1178 1
      call output('Host not assigned to that master', advance='yes' )
d1189 1
a1189 1
      call output( '; master lacks that host', advance='yes' )
d1240 2
a1241 1
100     if ( options%verbose ) call output(trim(newhost%name) // ' added', advance='yes')
d1251 1
a1251 1
      call output(' hosts read', advance='yes')
d1291 2
d1295 2
a1296 2
    print *, ' --wall:      show times according to wall clock'
    print *, ' -g:          turn tracing on'
d1308 1
a1308 1
    print *, ' -c command:  issue command to currently-running l2q'
d1310 6
a1317 2
    print *, ' checkh:      check for revived hosts'
    print *, ' clean:       clean the db of finished master tasks'
d1328 1
a1328 1
    print *, ' -g, -o, -v, -T, --check, --clean, --defer, '
d1333 5
d1447 1
a1447 1
    call output ( unit_number, advance='yes')
d1464 3
@


1.2
log
@New options; more convenient dumping to a file
@
text
@d22 1
a22 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, PRUNIT
d29 1
d62 1
a62 1
  real :: T0, T1, T2               ! For timing
d70 2
a71 1
  integer, parameter          :: DUMPDBTAG = CHECKREVIVEDHOSTSTAG - 1
d79 5
a83 1

d86 1
a86 1
     "$Id: l2q.f90,v 1.1 2004/12/09 00:42:46 pwagner Exp $"
d115 1
d132 2
d138 1
a138 1
    logical            :: debug = .false.         !   dump, checkh}
d144 2
a145 1
    logical :: total_times = .false.
d154 2
d161 8
d173 1
d175 1
a175 1
      ! Our target will be listening for:
d182 2
d204 1
d259 1
d267 1
a267 1
  call cure_host_database(hosts)
d272 2
d283 1
d305 1
a305 1
  subroutine cure_host_database(hosts)
d308 1
d311 1
d315 2
d323 1
a323 1
      if ( hosts(i)%OK .and. options%verbose ) &
d371 1
d375 5
a379 1
        call rmMasterFromDatabase(Masters, Masters(i))
d384 1
a384 1
  subroutine dump_master_database(Masters)
d387 1
d390 1
d396 2
d400 5
d449 3
a451 1
        if ( line(3+n:7+n) == 'check ' ) then
d453 2
d493 13
d527 1
a527 1
        exit ! This must be the l2cf filename
d539 2
d545 1
a552 1
    ! character(len=MachineNameLen)  :: MASTERNAME
d563 2
a564 1
    logical :: SKIPDELAY                ! Don't wait before doing the next go round
d571 1
d617 1
a617 1
            call output('(', advance='no')
d629 3
d646 1
d654 1
d666 1
a666 1
              call output('(Still has ', advance='no')
d669 2
d693 1
a693 1
            call output('(Now has ', advance='no')
d702 1
a702 1
            & 'reports host died', advance='no')
d710 2
a711 2
              call output( 'Host ' // trim(hosts(hostsID)%Name), advance='no')
              call output('(Now has ', advance='no')
d736 1
a736 1
              if ( hostsID > 0 ) &
d744 1
d749 1
a749 1
            call output('(', advance='no')
d768 1
a768 1
      ! Listen out for any message telling us to quit now
d786 1
a786 1
              if ( hostsID > 0 ) &
d797 1
a797 1
            call output('(', advance='no')
d810 1
d821 1
a821 1
      ! Listen out for any message telling us to stop regular revivals
d827 9
d906 1
d923 1
d928 6
a933 1
        if ( mastersID > 0 ) then
d939 1
d947 4
a950 2
      if ( .not. skipDelay .and. parallel%delay > 0 ) &
        & call usleep ( parallel%delay )
d979 4
d1046 1
d1093 6
a1098 2
      call MLSMessage( MLSMSG_Warning, ModuleName, &
        & 'master lacks any hosts' )
d1105 5
a1109 3
      ! call dump(master%hosts)
      call MLSMessage( MLSMSG_Warning, ModuleName, &
        & 'master lacks that host' )
d1144 1
d1178 4
a1181 1
    character(len=*), intent(in) :: What
d1183 5
a1187 4
    if ( options%total_times ) then
      call output ( "Total time = " )
      call output ( dble(t2), advance = 'no' )
      call blanks ( 4, advance = 'no' )
d1189 4
a1192 2
    call output ( "Timing for " // what // " = " )
    call output ( dble(t2 - t1), advance = 'yes' )
d1207 2
d1219 2
a1220 2
    print *, ' -s newfile:  flush current dumpfile; all later output to newfile'
    print *, '               ( same as -o newfile -c switch )'
d1223 2
a1224 1
    print *, ' -T:          show timing'
d1229 2
d1241 2
a1242 1
    print *, ' -g, -o, -v, -T, --check, --dumpnewm, --[n]revive, --wall'
d1264 3
d1270 10
a1279 1
    call output(' Time each master:                               ', advance='no')
d1282 1
a1282 1
    call output(' Show total times:                               ', advance='no')
d1284 4
a1287 1
    call output(options%total_times, advance='yes')
d1295 24
d1330 1
d1372 3
@


1.1
log
@First commit
@
text
@d72 3
d76 1
d80 1
a80 1
     "$Id: MLSL2.f90,v 2.91 2002/12/19 11:54:45 livesey Exp $"
d127 1
a127 1
    ! logical            :: killer = .false.      ! Kill currently-running l2q
d159 2
a160 2
      case ( 'kill' )
        tag = GiveUpTag
d167 8
a174 2
      case ( 'checkh' )
        tag = checkRevivedHostsTag
d179 1
d412 2
d454 5
d495 1
d499 1
d739 13
a751 2
      checkrevivedhosts = significantEvent
      ! dumpdb = (significantEvent .and. options%dumpEachNewMaster) .and. .false.
a752 1
      ! if ( options%debug ) call output('Listening for dumpdbtag', advance='yes')
a753 1
      ! if ( bufferIDRcv > 0 .or. dumpdb ) then
d755 10
d767 4
a772 1
      ! if ( bufferIDRcv > 0 .or. dumpdb ) then
d774 10
d785 4
a790 1
      ! if ( bufferIDRcv > 0 .or. dumpdb ) then
d792 10
d803 4
a808 1
      ! if ( options%debug ) call output('Listening for checkrevivedhosttagtag', advance='yes')
d810 1
d814 21
d839 2
a840 1
        mastersID = FindFirst( masters%needs_host .and. .not. masters%owes_thanks )
d845 2
a846 1
            call assignHostToMaster( hosts(nextFree), masters(mastersID), nextFree )
d856 2
a857 2
      if ( any(masters%owes_thanks) ) &
        & call usleep ( 2*parallel%delay )
d1093 5
d1100 6
a1105 2
    print *, ' -c command:  issue command to currently-running l2q'
    print *, ' -o dumpfile: direct supplemental dumps to dumpfile'
d1107 1
a1107 1
    print *, ' -h:          show help'
d1109 4
a1112 5
    print *, ' --check:     check LIST of hosts'
    print *, ' --dumpnewm:  dump each new master'
    print *, ' --version:   print version string'
    print *, ' --wall:      show times according to wall clock'
    print *, '     command may be one of'
d1114 4
d1120 7
d1212 4
a1215 1
! $Log: MLSL2.f90,v $
@

