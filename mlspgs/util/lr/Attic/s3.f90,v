head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2014.01.14.00.09.33;	author vsnyder;	state dead;
branches;
next	1.2;

1.2
date	2013.10.26.00.11.53;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.24.22.41.14;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Revised LR doesn't need it
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module S3
  use SIZES, only: MAXSHD, MXPRDC, MXPROD
  private
  integer, public, save ::  ACTION(MXPROD) ! Action for production
  integer, public, save ::  FRSPRD(MAXSHD) ! First production for a nonterminal
  integer, public, save ::  LFTUSE(MAXSHD) ! "token used on the LHS"
  integer, public, save ::  PRDIND(MXPROD)
  integer, public, save ::  PRODCN(MXPRDC)
  integer, public, save ::  RGTUSE(MAXSHD) ! "token used on the RHS"
  integer, public, save ::  VALUE(MAXSHD)
  integer, public, save ::  VOCAB(MAXSHD)
  integer, public, save ::  HEADCS(MAXSHD) ! Head of list of context sets
                                           ! for a nonterminal symbol
  integer, public, save ::  HEADEN(MAXSHD) ! Head of list of states entered
                                           ! by a terminal symbol

  public :: SORTGM

  ! First production data:
  data FRSPRD(2) /1/
  data PRDIND(1),PRDIND(2) /1,5/
  data PRODCN(1),PRODCN(2),PRODCN(4) /2,1,3/
  !
  data ACTION /MXPROD*0/
  data LFTUSE /MAXSHD*0/
  data RGTUSE /MAXSHD*0/
  data VALUE /MAXSHD*-1/

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: s3.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains
! =====     PUBLIC     ==============================     SORTGM     =====
  subroutine SORTGM
    use TABCOM, only: NUMPRD, NVOC
    implicit NONE

    ! Sort the vocabulary items into terminal non-terminal order,
    ! alphabetically within each group, using a heap sort.

    ! *****     Local Variables     ************************************

    ! I       is a loop induction variable and subscript.
    ! ITEMP   is used to exchange the root of the heap with the bottom left
    !         leaf.
    ! J       is a loop induction variable and subscript.
    ! K       is the production number.
    ! M1,M2,N1,N2
    !         are used to reorder arrays indexed by the token number.
    ! MOVED   is used to reorder arrays indexed by the token number.
    ! XLATE   is used to translate old token indices to new.

    integer :: I, ITEMP, J, K, M1, M2, N1, N2, MOVED(NVOC), XLATE(NVOC)

    ! *****     Procedures     *****************************************

    do i = 1, nvoc
      vocab(i) = i
    end do

    ! Build a heap.

    do i = nvoc/2, 1, -1
      call hepify (i, nvoc)
    end do

    ! Sort by exchanging the root of the heap with the rightmost leaf at
    ! the bottom level, and repairing the heap.

    do i = nvoc-1, 1, -1
      itemp = vocab(i+1)
      vocab(i+1) = vocab(1)
      vocab(1) = itemp
      call hepify (1, i)
    end do

    ! The vocabulary is sorted.  Build a translation table from old
    ! token numbers to new.

    do i = 1, nvoc
      xlate(vocab(i)) = i
      moved(i) = 0
    end do

    ! Translate old token numbers to new wherever they appear.

    do i = 1, prdind(numprd+1)-1
      prodcn(i) = xlate(prodcn(i))
    end do

    ! Reorder arrays indexed by token number.

    do i = 1, nvoc
      j = i
      n1 = frsprd(j)
      n2 = value(j)
      do while (moved(j) == 0)
        k = xlate(j)
        m1 = frsprd(k)
        m2 = value(k)
        frsprd(k) = n1
        value(k) = n2
        if (n2 < 0) value(k) = -k
        moved(j) = 1
        n1 = m1
        n2 = m2
        j = k
      end do
    end do
    return

  end subroutine SORTGM

! =====     PRIVATE     =============================     HEPIFY     =====
  subroutine HEPIFY (IPTR, IMAX)
    ! Remake the fragment of the heap in VOCAB from IPTR to IMAX.

    integer, intent(in) :: IPTR, IMAX

    !     *****     Local Variables     **********************************

    ! I       points to the root of the subtree being reconstructed.
    ! I0      points to the vocabulary symbol at I.
    ! I1      points to the vocabulary symbol at J.
    ! I2      points to the vocabulary symbol at J+1.
    ! ITEMP   is used to exchange two VOCAB objects.
    ! J       points to the larger of the sons of I.

    integer I, I0, I1, I2, ITEMP, J

    ! *****     Procedures     *******************************************

    i = iptr
    do
      j = i + i
      if (j > imax) return
      i0 = vocab(i)
      i1 = vocab(j)
      if (j < imax) then
        i2 = vocab(j+1)
        if (less(i1,i2) <0) then
          i1 = i2
          j = j + 1
        end if
      end if
      if (less(i0,i1) >= 0) return
      itemp = vocab(i)
      vocab(i) = vocab(j)
      vocab(j) = itemp
      i = j
    end do

  end subroutine HEPIFY

! =====     PRIVATE     ===============================     LESS     =====
  integer function LESS (IPTR1, IPTR2)
    use S1, only: STRCMP ! compares the strings that represent symbols.
    implicit NONE

    ! Compare the symbols indexed by IPTR1 and IPTR2.  Return -1 if the
    ! first should come before the second, or +1 if the second should
    ! come before the first.  All terminal symbols are sorted before
    ! any nonterminal symbols.

    integer, intent(in) :: IPTR1, IPTR2

    ! *****     Procedures     *******************************************

    less = lftuse(iptr1) - lftuse(iptr2)
    if ( less == 0 ) then
       less = strcmp(iptr1,iptr2)
    end if
    return
  end function LESS

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: s3.f90,v 1.2 2013/10/26 00:11:53 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module S3

! $Log: s3.f90,v $
! Revision 1.2  2013/10/26 00:11:53  vsnyder
! Add CVS stuff
!
@


1.2
log
@Add CVS stuff
@
text
@d42 1
a42 1
       "$RCSfile: lists.f90,v $"
d193 1
a193 1
       "$Id: lists.f90,v 1.1 2013/10/24 22:41:14 vsnyder Exp $"
d202 4
a205 1
! $Log: $
@


1.1
log
@Initial commit
@
text
@d1 11
d40 6
d190 10
d201 2
@

