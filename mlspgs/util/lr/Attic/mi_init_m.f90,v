head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2014.01.14.00.09.32;	author vsnyder;	state dead;
branches;
next	1.3;

1.3
date	2013.10.26.00.11.53;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.26.00.03.15;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.24.22.41.14;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Revised LR doesn't need it
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module MI_INIT_M

! Machine-independent initialization

  use IO, only : INUNIT, PRUNIT, TBUNIT

  implicit NONE
  private

  public :: MI_INIT, OPEN_INPUT, OPEN_LISTING, OPEN_OUTPUT

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: mi_init_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  subroutine MI_INIT
  ! Initialize various data structures
  end subroutine MI_INIT

  subroutine OPEN_INPUT ( FILE )
    character(len=*), intent(inout) :: FILE

    integer :: IOSTAT
    character(len=127) :: MSG ! in case of I/O error
    logical :: OPENED

    inquire ( unit=inunit, opened=opened )
    if ( opened ) return
    do
      if ( file /= ' ' ) then
        open ( inunit, file=file, status='OLD', form='FORMATTED', &
               iostat=IOSTAT, iomsg=MSG )
        if ( iostat == 0 ) exit
        write ( *, '(a,i0/3a/a)' ) 'Unable to open input file, IOSTAT = ', &
          & iostat, 'File: "', trim(file), '"', trim(msg)
      end if
      do
        write ( *, * ) 'Enter input file name: '
        read ( *, '(a)', iostat = iostat ) file
        if ( iostat /= 0 ) stop
        if ( file /= ' ' ) exit
        write ( *, * ) 'Nothing entered.'
      end do
    end do

  end subroutine OPEN_INPUT

  subroutine OPEN_LISTING ( FILE )
    character(len=*), intent(inout) :: FILE

    integer :: IOSTAT
    character(len=127) :: MSG ! in case of I/O error
    logical :: OPENED

    inquire ( unit=inunit, opened=opened )

    do
      if ( file /= ' ' ) then
        open ( prunit, file=file, status='UNKNOWN', form='FORMATTED', &
               iostat=IOSTAT, iomsg=MSG )
        if ( iostat == 0 ) exit
        write ( *, '(a,i0/3a/a)' ) 'Unable to open listing file, IOSTAT = ', &
          & iostat, 'File: "', trim(file), '"', trim(msg)
      end if
      do
        write ( *, * ) 'Enter listing file name: '
        read ( *, '(a)', iostat = iostat ) file
        if ( iostat /= 0 ) stop
        if ( file /= ' ' ) exit
        write ( *, * ) 'Nothing entered.'
      end do
    end do

  end subroutine OPEN_LISTING


  subroutine OPEN_OUTPUT ( FILE )
    character(len=*), intent(inout) :: FILE

    integer :: IOSTAT
    character(len=127) :: MSG ! in case of I/O error
    logical :: OPENED

    inquire ( unit=inunit, opened=opened )

    do
      if ( file /= ' ' ) then
        open ( tbunit, file=file, status='UNKNOWN', form='FORMATTED', &
               iostat=IOSTAT, iomsg=MSG )
        if ( iostat == 0 ) exit
        write ( *, '(a,i0/3a/a)' ) 'Unable to open output file, IOSTAT = ', &
          & iostat, 'File: "', trim(file), '"', trim(msg)
      end if
      do
        write ( *, * ) 'Enter output file name: '
        read ( *, '(a)', iostat = iostat ) file
        if ( iostat /= 0 ) stop
        if ( file /= ' ' ) exit
        write ( *, * ) 'Nothing entered.'
      end do
    end do

  end subroutine OPEN_OUTPUT

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: mi_init_m.f90,v 1.3 2013/10/26 00:11:53 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module MI_INIT_M

! $Log: mi_init_m.f90,v $
! Revision 1.3  2013/10/26 00:11:53  vsnyder
! Add CVS stuff
!
@


1.3
log
@Add CVS stuff
@
text
@d25 1
a25 1
       "$RCSfile: lists.f90,v $"
d123 1
a123 1
       "$Id: lists.f90,v 1.1 2013/10/24 22:41:14 vsnyder Exp $"
d132 4
a135 1
! $Log: $
@


1.2
log
@Eliminate dependence on 'machine' module
@
text
@d1 11
d23 6
d88 1
a88 1
    return
d117 1
a117 1
    return
d120 10
d131 2
@


1.1
log
@Initial commit
@
text
@a5 1
  use MACHINE, only : IO_ERROR
d22 1
d30 1
a30 1
               iostat=IOSTAT )
d32 2
a33 1
        call io_error ( 'Unable to open input file', iostat, file )
d43 1
a43 1
    return
d50 1
d58 1
a58 1
               iostat=IOSTAT )
d60 2
a61 1
        call io_error ( 'Unable to open listing file', iostat, file )
d79 1
d87 1
a87 1
               iostat=IOSTAT )
d89 2
a90 1
        call io_error ( 'Unable to open output file', iostat, file )
@

