head	1.3;
access;
symbols
	V4-10:1.2;
locks; strict;
comment	@# @;


1.3
date	2014.05.21.00.02.48;	author vsnyder;	state dead;
branches;
next	1.2;

1.2
date	2014.01.14.01.00.50;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2014.01.14.00.15.02;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Get parser.f90 from lib
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module PARSER

! Parser for MLS CF.  The grammar is processed by the LR processor.

  implicit NONE
  private

  public :: CONFIGURATION, LR_Parser, LR_Parser_TX

  interface Configuration
    module procedure LR_Parser, LR_Parser_TX
  end interface

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: parser.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains ! ====     Procedures     =====================================

  subroutine LR_Parser_TX ( Root )
    use Tree, only: TX
    type(tx), intent(out) :: ROOT   ! Root of the abstract syntax tree
    call lr_parser ( root%i )
  end subroutine LR_Parser_TX

  subroutine LR_Parser ( Root )

    use LEXER_CORE, only: PRINT_SOURCE, TOKEN
    use LEXER_M, only: LEXER
    use OUTPUT_M, only: Blanks, NEWLINE, OUTPUT
    use Parser_Tables, only: IFinal, NState, NTerms, NumPrd, NVoc, &
      & ENT, FRED, FTRN, TRAN, NSET, PROD, LSET, LS, LENS, LHS, &
      & ACT, VAL, Text, Prod_Ind, Productions, Indbas, BasProds, Dots, &
      & Init_Vocabulary_Names
    use SYMBOL_TABLE, only: DUMP_1_SYMBOL, DUMP_SYMBOL_CLASS
    use SYMBOL_TYPES, only: T_End_Of_Input, T_Last_Terminal, T_Null
    use TOGGLES, only: LEVELS, PAR, TOGGLE
    use TREE, only: BUILD_TREE, Dump_Top_Stack, N_TREE_STACK,&
                    PUSH_PSEUDO_TERMINAL,  STACK_SUBTREE
    use TREE_TYPES, only: N_CFS, N_Null

    integer, intent(out) :: Root   ! Index in tree of root of the parsed tree

    type :: Stack_Frame
      integer :: State         ! The parser state
      integer :: Tree_Index    ! Tree stack pointer of state's LHS
    end type Stack_Frame

    logical, save :: First = .true.
    logical :: Need            ! Need to get a token from the lexer
    integer :: Prev_Error

    integer :: LR_0(nstate)    ! If LR_0(I) /= 0, state I is an LR(0) state,
                               ! i.e., one reduction and no productions.
                               ! LR_0(I) is the production number to reduce.
    logical, save :: Machine = .false. ! Dump the grammar and parsing machine
    integer :: Map(t_null:t_last_terminal) ! Map token classes to parser
                               ! vocabulary indices
    integer :: Newsta, Nowsta  ! Next state, Current state
    logical, save :: Show_stack = .false. ! stack too
    logical, save :: Show_state = .false. ! automaton state too
    logical, save :: Show_work = .false. ! dump work table
    integer :: SP              ! stack pointer
    type(stack_frame), allocatable :: Stack(:)
    type(token) :: The_Token   ! from the lexer
    integer :: Voc             ! vocabulary index of token or LHS
    integer, save :: Work(nstate,nvoc)

    ! Put names of symbols not defined by the grammar into the string
    ! table
    if ( first ) then
      first = .false.
      call init_vocabulary_names ! put them in the string table so they can
                                 ! be output in messages

      show_stack = mod(levels(par),2) /= 0
      show_state = mod(levels(par)/2,2) /= 0
      machine = mod(levels(par)/4,2) /= 0
      show_work = mod(levels(par)/8,2) /= 0

      ! Convert the lists to search for transitions and reductions to the
      ! array WORK(nstate:nvoc).
      ! If Work(i,j) > 0 the next state is Work(i,j)
      ! If Work(i,j) < 0 reduce production -Work(i,j)
      ! If Work(i,j) == 0 a syntax error has occurred
      call make_work ( FTRN, TRAN, ENT, FRED, NSET, LSET, LS, PROD, VAL, &
                     & Work, LR_0, map )
    end if

    prev_error = 0              ! Line number of previous error
    sp = 0
    newsta = abs(tran(1))       ! The LR generator likes to put the <SOG>
                                ! symbol before the goal symbol.  The lexer
                                ! doesn't produce this symbol before the first
                                ! input.  Putting the parser in the state
                                ! adjacent to state 1 skips that symbol.
    voc = 0                     ! Don't display symbol in Transition routine

    call transition ( .false. ) ! push Newsta onto the parser stack and
                                ! make it Nowsta.

    need = .true.               ! Indicate a token is necessary

    do while ( nowsta /= ifinal )
      if ( lr_0(nowsta) > 0 ) then
        ! The current state is an LR(0) state, meaning it does one reduction
        ! and no transitions.  The production in lr_0(nowsta) can be
        ! reduced without needing to go to the lexer to get a token.
        call reduce_production ( lr_0(nowsta) )
      else
        if ( need ) then
          call lexer ( the_token )
          need = .false.
        end if
        ! Decide what to do
        if ( map(the_token%class) <= 0 .or. map(the_token%class) > nterms ) &
          & call catastrophic_error ( 'No vocabulary index mapping for', the_token )
        voc = work(nowsta,map(the_token%class))
        if ( voc > 0 ) then
          newsta = voc
          if ( the_token%pseudo ) then
            call push_pseudo_terminal ( the_token%string_index, &
                                      & the_token%where, class=the_token%class )
            if ( show_stack ) then
              call output ( 'Push pseudo terminal ' )
              call dump_1_symbol ( the_token%string_index )
              call print_source ( the_token%where, before=' at ' )
              call output ( n_tree_stack, before=' leaving n_tree_stack = ', &
                & advance='yes' )
            end if
          end if
          call transition ( .false. )
          need = .true.        ! Consume the token
        else if ( voc < 0 ) then
          call reduce_production ( -voc )
        else ! Syntax error
         call no_transition
        end if
      end if
    end do

    call build_tree ( n_cfs, n_tree_stack )  ! glue together everything on the

    if ( prev_error > 0 ) then
      call output ( prev_error, before='Last error at line ', advance='yes' )
      root = -1
    else
      if ( toggle(par) ) then
      call output ( 'Finished parsing and built ' )
      call dump_top_stack ( 0, advance='yes' )
      end if
      call build_tree ( n_null, 1 )          ! pop the n_cfs, leave the n_null
      root = stack_subtree(1)
    end if

  contains

! -------------------------------------------  Catastrophic_Error  -----
    subroutine Catastrophic_Error ( Text, The_Token, State, Nonterminal )
      use MLSMessageModule, only: MLSMessage, MLSMSG_Crash
      character(len=*), intent(in):: Text
      type(token), intent(in), optional  :: The_Token
      integer, intent(in), optional :: State, Nonterminal
      call output ( '***** Catastrophic Error *****', advance='yes' )
      if ( present(state) ) &
        & call output ( state, before='The current state is ', advance='yes' )
      if ( present(nonterminal) ) &
        & call output ( nonterminal, before='The nonterminal symbol is ', &
          & advance='yes' )
      if ( present(the_token) ) then
        call output ( 'Next token is ' )
        call dump_symbol_class ( the_token%class, advance='yes' )
      end if
      call MLSMessage ( MLSMSG_Crash, moduleName, trim(text) )
      stop 666
    end subroutine Catastrophic_Error

! ---------------------------------------------------  Do_Include  -----
    subroutine Do_Include
      ! Assuming "#include string" is reduced as an LR(0) production,
      ! both the top stack frame and the current token are "string".
      ! We don't want "string" in the tree, so pop it off the stack.
      use String_Table, only: Display_String, Open_Include
      use Tree, only: Pop
      call open_include ( the_token%string_index, the_token%where%source, &
                        & the_token%where%file )
      call pop ( 1 )
      if ( toggle(par) ) &
        & call display_string ( the_token%string_index, &
          & before='Opened include file ', advance='yes' )
    end subroutine Do_Include

! -----------------------------------------------  Error_Walkback  -----
    subroutine Error_Walkback ( Line )
      integer, intent(in) :: Line      ! Line number of error
      if ( prev_error > 0 ) call output ( prev_error, &
        & before='Previous error at line ', advance='yes' )
      prev_error = line
    end subroutine Error_Walkback

! ----------------------------------------------------  Make_Work  -----
    subroutine Make_Work ( FTRN, TRAN, ENT, FRED, NSET, LSET, LS, PROD, VAL, &
                         & Work, LR_0, Map )

    ! Make the Work, LR_0 and Map arrays, to avoid searching FTRN, TRAN,
    ! FRED, NSET, LSET, and LS to determine whether to reduce a production
    ! or make a transition.

    ! Positive elements of WORK are new state numbers and indicate transitions.
    ! Negative elements of WORK are indices of productions to reduce.
    ! Zero elements of WORK indicate syntax errors.

    ! Columns 1:NTERMS are indexed by terminal symbol vocabulary indices. 
    ! Columns NTERMS+1:NVOC are indexed by nonterminal symbol vocabulary
    ! indices, never indicate reductions, and errors are not possible.

      integer, intent(in) :: FTRN(0:), TRAN(:), ENT(:)
      integer, intent(in) :: FRED(0:), NSET(:), LSET(0:), LS(:)
      integer, intent(in) :: PROD(:), VAL(:)
      integer, intent(out) :: WORK(:,:) ! ( NSTATE : NVOC )
      integer, intent(out) :: LR_0(:)   ! ( NSTATE ), "state is an LR(0) state"
      integer, intent(out) :: Map(t_null:) ! Inverse of VAL

      ! FTRN(0:nstate): Indexed by state number.  First (actually last)
      ! transitions.  Transitions for state S are in TRAN(FTRN(S-1)+1:FTRN(S)).

      ! TRAN(1:ntrans): New state indices, indexed by FTRN, q.v.

      ! ENT(1:nstate): Indexed by state number.  Index of vocabulary symbol
      ! used to enter a state.

      ! FRED(0:nstate): Indexed by state number.  First (actually last)
      ! reductions.  Lookahead sets for state S are NSET(FRED(S-1)+1:FRED(S)).

      ! NSET(1:nlooks): Lookahead set indices, indexed by FRED, q.v.

      ! LSET(0:ncsets): Last elements of lookahead sets, indexed by NSET, q.v.
      ! For lookahead set L, elements are LS(LSET(L-1)+1:LSET(L)).

      ! LS(1:lsets): Elements of lookahead sets.

      ! PROD(1:nlooks): Production numbers to reduce if lookahead is in the
      ! set, indexed by FRED, q.v.

      logical :: Error
      integer :: I, J, L

      error = .false. ! Assume OK
      work = 0

      ! Fill in the transitions
      do i = 1, ubound(ftrn,1)
        work(i,ent(tran(ftrn(i-1)+1:ftrn(i)))) = tran(ftrn(i-1)+1:ftrn(i))
      end do

      ! Fill in the reductions
      do i = 1, ubound(fred,1)
        do j = fred(i-1)+1, fred(i)
          do l = lset(nset(j)-1)+1, lset(nset(j))
            if ( work(i,ls(l)) > 0 ) then
              write ( *, '(3(a,i0))' ) &
                & 'Grammar is not LR.  Intersection in state ', i, &
                & ' with transition to state ', work(i,ls(l)), &
                & ' on vocabulary symbol with internal index ', ls(l)
                error = .true.
            else if ( work(i,ls(l)) < 0 ) then
              write ( *, '(3(a,i0))' ) &
                & 'Grammar is not LR.  Intersection in state ', i, &
                & ' with reduction of production ', -work(i,ls(l)), &
                & ' on vocabulary symbol with internal index ', ls(l)
                error = .true.
            else
              work(i,ls(l)) = -prod(j)
            end if
          end do
        end do
      end do

      do i = 1, ubound(work,1)
        if ( ftrn(i) == ftrn(i-1) .and. &    ! No transitions
           & fred(i) == fred(i-1)+1 ) then   ! One reduction
          lr_0(i) = prod(fred(i))
        else
          lr_0(i) = 0
        end if
      end do

      do i = 1, ubound(val,1)
        if ( val(i) > 0 .and. val(i) < ubound(map,1) ) map(val(i)) = i
      end do

      if ( show_work ) then
        call output ( "Parser's WORK array:", advance='yes' )
        do i = 1, size(work,2), 20
          call output ( '      ' )
          do l = i, min(i+19,size(work,2))
            call output ( l, format='(i6)' )
          end do
          call newline
          do j = 1, size(work,1)
            call output ( j, format='(i5,":")' )
            do l = i, min(i+19,size(work,2))
              call output ( work(j,l), format='(i6)' )
            end do
            call newline
          end do
        end do
      end if

      if ( error ) then
        write ( *, '(a)' ) 'Error: Make_Work_m.Make_Work%E%- Grammar is not LR(1)'
        stop 1
      end if

      if ( machine ) then
        call print_grammar
        call output ( 'The parsing automaton (sans context sets for reductions):', &
          & advance='yes' )
        do i = 1, nstate
          call newLine
          call print_state ( i, number=.true. )
        end do
        call output ( 'End of the parsing automaton', advance='yes' )
      end if

    end subroutine Make_Work

! ------------------------------------------------  No_Transition  -----
    subroutine No_Transition ( Expected )
      ! This is a REALLY CRUDE error recovery routine.
      integer, intent(in), optional :: Expected
      integer :: I
      call output ( the_token%where%source / 256,5 )
      call output ( ': *** Error ***  Unexpected Input ')
      call dump_1_symbol ( the_token%string_index )
      if ( the_token%class /= t_end_of_input ) then
        call print_source ( the_token%where, before=' at ' )
        call output (' in parser state ' )
        call output ( nowsta, advance='yes' )
        call print_state ( nowsta )
        if ( present(expected) ) then
          call output ( 'Expected ', advance='no' )
          call dump_symbol_class ( expected, advance='yes' )
        else
          call output ( 'Expected one of: ', advance='yes' )
          do i = 1, nterms
            if ( work(nowsta,i) > 0 ) &
              & call dump_symbol_class ( map(i), advance='yes' )
          end do
        end if
        call lexer( the_token )
        call error_walkback ( the_token%where%source / 256 )
      else
        call output (' in parser state ' )
        call output ( nowsta, advance='yes' )
        call print_state ( nowsta )
        if ( present(expected) ) then
          call output ( 'Expected ', advance='no' )
          call dump_symbol_class ( expected, advance='yes' )
        else
          call output ( 'Expected one of: ', advance='yes' )
          do i = 1, nterms
            if ( work(nowsta,i) > 0 ) &
              & call dump_symbol_class ( map(i), advance='yes' )
          end do
        end if
        call error_walkback ( the_token%where%source / 256 )
        sp = sp - 1
        if ( sp <= 0 ) call catastrophic_error ( 'Parser stack underflow' )
        nowsta = stack(sp)%state
      end if
    end subroutine No_Transition

! -------------------------------------------------  Print_Action  -----
    subroutine Print_Action ( P )
    ! Print the action for production P
      use String_Table, only: Display_String
      use Tree, only: Tree_Text
      integer, intent(in) :: P ! The production number
      integer :: A
      a = act(p)
      if ( a /= 0 ) then
        select case ( mod(a,10) )
        case ( 1 )
          call display_string ( tree_text(a / 10), before=' => ' )
        case ( 2 )
          call display_string ( tree_text(a / 10), before=' => ' )
          call output ( ' ?' )
        case default
          call output ( a, before=' => ' )
        end select
      end if
    end subroutine Print_Action

! ------------------------------------------------  Print_Grammar  -----
    subroutine Print_Grammar
    ! Print the entire grammar, with actions.
      use String_Table, only: Get_String, String_Length
      integer :: J, K, LHS, P, PrevLHS
      character(120) :: Work ! To strip underscore off nonterminal names
      call output ( 'The grammar:', advance='yes' )
      prevLHS = -1
      do p = 1, numprd
        j = prod_ind(p)
        lhs = productions(j)
        if ( lhs /= prevLHS .and. p /= 1 ) call newLine
        call output ( p, 3 )
        call get_string ( text(lhs), work )
        k = merge(2,1,work(1:1)=='_')
        if ( lhs /= prevLHS ) then
          call output ( ' ' // trim(work(k:)) )
        else
          call blanks ( string_length(text(lhs)) + 2 - k )
        end if
        prevLHS = lhs
        call output ( ' ->' )
        do j = prod_ind(p)+1, prod_ind(p+1)-1
          call get_string ( text(productions(j)), work )
          k = merge(2,1,work(1:1)=='_')
          call output ( ' ' // trim(work(k:)) )
        end do
        call print_action ( p )
        call newLine
      end do
      call output ( 'End of the grammar', advance='yes' )
    end subroutine Print_Grammar

! --------------------------------------------------  Print_State  -----
    subroutine Print_State ( State, Number )
    ! Print the parser configuration in state STATE, i.e., the list of
    ! productions, with dots in them.
      use String_Table, only: Get_String
      integer, intent(in) :: State
      logical, intent(in), optional :: Number ! Print state number
      integer :: I, J, K, JDOT, P
      logical :: Num
      character(120) :: Work ! To strip underscore off nonterminal names
      num = .false.
      if ( present(number) ) num = number
      do i = indbas(state), indbas(state+1)-1
        p = basprods(i)
        if ( num ) then
          if ( i == indbas(state) ) then
            call output ( state, 5 )
          else
            call blanks ( 5 )
          end if
        end if
        call output ( p, 5 )
        j = prod_ind(p) ! p = production number
        call get_string ( text(productions(j)), work )
        k = merge(2,1,work(1:1)=='_')
        call output ( ' ' // trim(work(k:)) )
        call output ( ' ->' )
        jdot = 1
        do j = prod_ind(p)+1, prod_ind(p+1)-1
          if ( dots(i) == jdot ) call output ( ' .' )
          jdot = jdot + 1
          call get_string ( text(productions(j)), work )
          k = merge(2,1,work(1:1)=='_')
          call output ( ' ' // trim(work(k:)) )
        end do
        if ( dots(i) == jdot ) call output ( ' .' )
        call print_action ( p )
        call newLine
      end do
      if ( num ) then ! Print transitions if any
        if ( ftrn(state) > ftrn(state-1) ) then
          call blanks ( 11 )
          call output ( 'Transitions: ' )
          do i = ftrn(state-1)+1, ftrn(state)
            call output ( tran(i), 5 )
          end do
          call newLine
        end if
      end if
    end subroutine Print_State

! --------------------------------------------  Reduce_Production  -----
    subroutine Reduce_Production ( Prod )
      integer, intent(in) :: Prod ! Index of production to reduce
      integer :: Action       ! action when reducing a production:
                              !      1 = produce a node
                              !      2 = produce a node iff > 1 sons
      integer :: I            ! temporary variable
      integer :: LHS_TREE     ! tree stack index for lhs
      integer :: NEW_NODE     ! tree node to make
      integer :: NSONS        ! number of tree parts associated with rhs

      sp = sp - lens(prod)    ! Pop RHS-length frames from the stack
      nowsta = stack(sp)%state
      lhs_tree = stack(sp)%tree_index
      nsons = n_tree_stack - lhs_tree
      i = act(prod)           ! use i for temp while getting action
      new_node = i / 10
      action = mod(i, 10)

      if ( toggle(par) ) then
        call output ( prod, before='Reduce production ' )
        call output ( lens(prod), before=' consuming ' )
        call output ( trim(merge(' symbol ', ' symbols', lens(prod)==1)) )
      end if
      if ( i /= 0 ) then
        if ( action==1 .or. action==2 .and. nsons>1 ) then
          call build_tree ( new_node, nsons )
          if ( toggle(par) ) then
            call output ( ', building ' )
            call dump_top_stack ( 0 )
          end if
        else if ( action == 9 ) then
          call do_include
        end if
      else if ( toggle(par) .and. nsons>0 ) then
        call output ( nsons, before=', subsuming ' )
        call output ( trim(merge(' tree node ', ' tree nodes', nsons==1)) )
      end if
      if ( toggle(par) ) then
        call output ( nowsta, before=', returning to state ' )
        if ( show_stack ) then
          call output ( sp, before=', stack(' )
          call output ( stack(sp)%state, before=') = (' )
          call output ( stack(sp)%tree_index, before=',' )
          call output ( ')' )
        end if
        call output ( '.', advance='yes' )
      end if

      newsta = work(nowsta,lhs(prod))
      if ( newsta == 0 ) &
        & call catastrophic_error ( 'There is no state transition', &
          & state=nowsta, nonterminal=lhs(prod) )
      voc = text(lhs(prod))
      call transition ( .true. )

    end subroutine Reduce_Production

! ---------------------------------------------------  Transition  -----
    subroutine Transition ( LHS )
      ! Set the current state (Nowsta) to the new state (Newsta)
      ! and push it on the stack with N_Tree_Stack.
      use Allocate_Deallocate, only: Test_Allocate
      use String_Table, only: Display_String
      logical, intent(in) :: LHS ! VOC is index of LHS symbol of production
      integer :: N, S
      integer :: Stat
      type(stack_frame), allocatable :: TempStack(:)

      ! Make sure we have a stack, and it's big enough to push the new state
      n = 0
      if ( allocated(stack) ) n = ubound(stack,1)
      if ( sp >= n ) then
        s = max(100,2*n)
        allocate ( tempStack(s), stat=stat )
        call test_allocate ( stat, moduleName, 'Stack', [1], [s], &
                           & storage_size(stack) )
        if ( allocated(stack) ) tempStack(1:sp) = stack(1:sp)
        call move_alloc ( tempStack, stack )
      end if

      nowsta = newsta
      sp = sp + 1
      stack(sp) = stack_frame(nowsta,n_tree_stack)

      if ( toggle(par) ) then
        call output ( newsta, before='Enter state ' )
        if ( voc /= 0 ) then
          call output ( ' with ' )
          if ( voc < 0 ) then
            call output ( ent(nowsta), before='symbol number ' )
          else if ( lhs ) then
            call display_string ( voc, before='nonterminal symbol ' )
          else
            call dump_1_symbol ( the_token%string_index )
            call print_source ( the_token%where, before=' at ' )
          end if
        end if
        call output ( n_tree_stack, before=', n_tree_stack = ' )
        if ( show_stack ) then
          call output ( sp, before=', stack(' )
          call output ( stack(sp)%state, before=') = (' )
          call output ( stack(sp)%tree_index, before=',' )
          call output ( ')' )
        end if
        call newLine
        if ( show_state ) call print_state ( nowsta )
      end if

    end subroutine Transition

  end subroutine LR_Parser

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: parser.f90,v 1.2 2014/01/14 01:00:50 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module PARSER

! $Log: parser.f90,v $
! Revision 1.2  2014/01/14 01:00:50  vsnyder
! Remove dependence on Processor_Dependent, which was for debugging
!
! Revision 1.1  2014/01/14 00:15:02  vsnyder
! Initial commit of new module for new LR
!
! Revision 2.30  2013/12/12 02:01:54  vsnyder
! Entirely replaced with LR parser
!
! Revision 2.29  2013/10/02 01:35:46  vsnyder
! Add conditional expressions ?...! and variable assignment :=
!
! Revision 2.28  2013/09/30 23:03:04  vsnyder
! Add TX type for tree index and generics to use it
!
! Revision 2.27  2013/09/25 01:02:41  vsnyder
! Add include files
!
! Revision 2.26  2013/09/24 23:27:14  vsnyder
! Use Get_Where or Print_Source to start error messages
!
! Revision 2.25  2012/05/05 00:11:51  vsnyder
! Add support for 'not' operator
!
! Revision 2.24  2012/05/01 22:11:27  vsnyder
! Simplify node generation
!
! Revision 2.23  2012/05/01 22:10:26  vsnyder
! Add TrueList subroutine
!
! Revision 2.22  2012/04/24 20:37:24  vsnyder
! Include the complete grammar at the top
!
! Revision 2.21  2011/04/19 01:59:43  vsnyder
! Support == and /= relational operators too
!
! Revision 2.20  2011/04/18 19:33:26  vsnyder
! Add support for relational operators and boolean-valued expressions
!
! Revision 2.19  2009/06/23 18:25:43  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.18  2008/09/04 20:02:20  vsnyder
! Add PRINT statement in not_used_here + Cannonball polishing
!
! Revision 2.17  2008/09/04 00:46:17  vsnyder
! Reverse precedence of unary +/- and units
!
! Revision 2.16  2006/03/22 03:04:00  vsnyder
! Allow empty spec field values
!
! Revision 2.15  2005/06/22 17:25:50  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.14  2004/05/28 23:13:12  vsnyder
! Add power (^) operator, units coercion for (expr) and function result
!
! Revision 2.13  2004/01/20 19:43:33  vsnyder
! Cosmetic changes
!
! Revision 2.12  2004/01/17 03:04:48  vsnyder
! Provide for functions in expressions
!
! Revision 2.11  2004/01/16 23:49:32  vsnyder
! Add backslash for 'into' operator
!
! Revision 2.10  2003/01/29 03:14:14  vsnyder
! Print the line and column in ENTER debugging output
!
! Revision 2.9  2002/10/08 00:09:13  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.8  2001/11/28 03:05:54  vsnyder
! Implement arrays of arrays
!
! Revision 2.7  2001/11/27 00:54:37  vsnyder
! Implement (partially) open ranges
!
! Revision 2.6  2001/07/20 20:18:05  vsnyder
! Improve error recovery in a few cases -- more work probably needed
!
! Revision 2.5  2001/02/28 02:37:11  vsnyder
! Allow specification with no arguments to have a label
!
! Revision 2.4  2000/11/30 00:23:10  vsnyder
! Implement [] syntax for arrays
!
! Revision 2.3  2000/11/15 22:01:18  vsnyder
! Allow specification with no arguments.
!
! Revision 2.2  2000/11/15 21:15:27  vsnyder
! Corrected a loop on a bad primary; correct processing of spec with no fields
!
! Revision 2.1  2000/10/11 18:02:50  vsnyder
! Move from lib/cf_parser to lib; remove unused variables; add copyright
!
! Revision 2.0  2000/09/05 17:41:51  dcuddy
! Change revision to 2.0
!
! Revision 1.1  2000/07/06 01:43:12  vsnyder
! Initial check-in
!
@


1.2
log
@Remove dependence on Processor_Dependent, which was for debugging
@
text
@d608 1
a608 1
       "$Id: parser.f90,v 1.1 2014/01/14 00:15:02 vsnyder Exp $"
d618 3
@


1.1
log
@Initial commit of new module for new LR
@
text
@a47 1
    use Processor_Dependent, only: NewPage
a163 1
        call output ( newPage, dont_asciify=.true. )
d608 1
a608 1
       "$Id: parser.f90,v 2.30 2013/12/12 02:01:54 vsnyder Exp $"
d618 3
@

