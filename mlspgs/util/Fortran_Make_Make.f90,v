head	1.1;
access;
symbols
	v5-02-NRT-19:1.1
	v6-00:1.1
	v5-02-NRT-18:1.1
	v5-02:1.1
	v5-01-NRT-17:1.1
	v5-01-NRT-16:1.1
	v5-01-NRT-15:1.1
	v5-01-NRT-14:1.1
	neuralnetworks-1-0:1.1.0.10
	cfm-single-freq-0-1:1.1.0.8
	v5-01:1.1
	v5-00:1.1
	v4-23-TA133:1.1.0.6
	mus-emls-1-70:1.1.0.4
	rel-1-0-englocks-work:1.1.0.2
	VUMLS1-00:1.1;
locks; strict;
comment	@# @;


1.1
date	2016.11.02.23.05.25;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial Commit
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

program Fortran_Make_Make

  ! Read Fortran program units and generate makefile dependencies.
  ! We assume that:
  !   a file contains no more than one MODULE statement,
  !   the name of the used module is on the same line as the USE keyword, and
  !   a filename on an INCLUDE line does not contain whichever of quote or
  !     apostrophe is the first delimiter of the included file name,
  !   there are no include cycles (we'll hang),
  !   the name of the file generated by the processor for a module is the
  !     module name in lower case with .mod extension.

  use, intrinsic :: ISO_C_Binding, only: C_Associated, C_Null_Char,  C_Ptr
  use Posix, only: CloseDir, DT_Reg, GetCWD, OpenDir, ReadDir

  implicit NONE

  ! Simple list node type
  type :: Node_t
    character(:), allocatable :: Name
    class(node_t), pointer :: Next => NULL()
  end type Node_t

  ! Types for dependencies:
  type, extends(node_t) :: Incl_t
  end type Incl_t
  type, extends(node_t) :: Use_t
  end type Use_t

  ! Type for list node for non-module file with its dependencies
  type, extends(node_t) :: File_t
    ! Dynamic type will be Incl_t or Use_t, depending on the reason
    ! for the dependency:
    class(node_t), pointer  :: FirstDep => NULL(), LastDep => NULL()
  end type File_t

  ! Type for list node for module file with its dependencies
  type, extends(file_t) :: Module_t
    character(:), allocatable :: ModuleName
  end type Module_t

  ! List of directories to search for includes.
  class(node_t), pointer :: FirstDir => NULL(), LastDir => NULL()

  ! List of extensions to examine
  class(node_t), pointer :: FirstExt => NULL(), LastExt => NULL()

  ! List of files for which dependencies are generated.  Dynamic type is File_t
  class(node_t), pointer :: FirstFile => NULL(), LastFile => NULL()

  character(255) :: Arg, Arg2     ! A command-line argument
  character(255) :: CWD           ! Current working directory, to create
                                  ! complete path names
  type(C_Ptr) :: CWDHandle        ! Handle for reading the directory
  logical :: DumpStop = .false.   ! Dump lists and stop after processing cmd line
  integer :: I
  type(incl_t) :: InclMold        ! To allocate Incl_t list items
  character(255) :: IOMSG         ! From open
  character(255) :: Makefile      ! The output file name.
  integer :: MakeUnit             ! Unit attached to Makefile
  character(4) :: Obj = 'o'       ! Default extension for object files
  integer :: PathNameLen          ! Number of useful characters in PathName
  character(1023) :: PathName     ! Full path name of a file to read
  integer :: PathType
  character(255) :: Prefix = ''   ! to put before source file names
  integer :: Stat                 ! From OPEN or READ
  type(use_t) :: UseMold          ! To allocate Use_t list items
  character :: Which = 'C'        ! Which dependencies to include, 'C' => only
                                  ! those satisfied in current directory,
                                  ! 'A' => all dependencies
  integer :: Width = 80           ! of the output line
    
!---------------------------- RCS Info ------------------------------
  character (len=*), parameter :: ProgramName= &
       "$RCSfile: intrinsic.f90,v $"
!--------------------------------------------------------------------

  ! Make '.' the first directory in the list of directories to search for includes
  call addToList ( '.', firstDir, lastDir )

  ! Process the command line
  i = 0
  makefile = 'Makefile.dep'
  do
    i = i + 1
    call get_command_argument ( i, arg )
    if ( arg == '' ) exit
    if ( arg(1:1) /= '-' ) then
      makefile = arg
      exit
    end if
    select case ( arg(1:2) )
    case ( '-A' )
      which = 'A' ! Include all dependencies
    case ( '-C' )
      which = 'C' ! Include only dependencies upon current directory
    case ( '-d' )
      dumpStop = .true.
    case ( '-I' ) ! Directory to search for dependencies
      call getOptArg
      call addToList ( arg2, firstDir, lastDir )
    case ( '-X' ) ! Extension to search; strip off leading dots
      call getOptArg
      do while ( arg2(1:1) == '.' ); arg2 = arg2(2:); end do
      call addToList ( arg2, firstExt, lastExt )
    case ( '-O' )
      call getOptArg
      obj = arg2
    case ( '-P' )
      call getOptArg
      prefix = arg2
    case ( '-w' )
      call getOptArg
      read ( arg2, *, iostat=stat, iomsg=iomsg ) width
      if ( stat /= 0 ) then
        print '(a,i0)', 'Error while processing -w option, STAT = ', stat
        print '(a)', trim(iomsg)
        stop
      end if
    case default
      call usage
    end select
  end do

  if ( dumpStop ) then
    print '(2a)', 'Makefile: ', trim(makefile)
    call dumpList ( 'Directories to search:', firstDir )
    call dumpList ( 'Extensions of files to read:', firstExt )
    stop
  end if

  ! Get the current working directory, and eliminate C_Null_Char from
  ! it.
  if ( .not. C_Associated(getCWD ( cwd, len(cwd) )) ) then
    print '(a)', 'Unable to determine the current working directory'
    stop
  end if
  do
    i = index(cwd,c_null_char)
    if ( i == 0 ) exit
    cwd(i:) = cwd(i+1:)
  end do

  ! Read the file names from the current working directory.
  cwdHandle = OpenDir ( cwd )
  if ( .not. C_Associated(cwdHandle) ) then
    print '(a)', 'Unable to open current working directory.'
    stop
  end if

  do
    call readDir ( cwd, cwdHandle, pathName, pathNameLen, pathType )
    if ( pathNameLen < 1 ) exit
    if ( pathType == DT_Reg ) then   ! Only process regular files, not
                                     ! devices, directories, fifo, ....
      if ( checkExt(pathName) ) then ! Only process files with desired extensions
        call processFile ( pathName, .true. )
      end if
    end if
  end do

  if ( closeDir ( cwdHandle ) == 0 ) continue

  open ( newUnit=makeUnit, file=trim(makeFile), action='write', &
       & iostat=stat, iomsg=iomsg )
  if ( stat /= 0 ) then
    print '(3a,i0)', 'Unable to open ', trim(makeFile), ', STAT = ', stat
    print '(a)', trim(iomsg)
    stop
  end if

  call outputDependencies
  write ( makeUnit, * )
  call outputModuleNames
  write ( makeUnit, * )
  call outputObjectNames
  write ( makeUnit, * )
  call outputSourceNames

  close ( makeUnit )

contains

  subroutine AddToList ( Word, Head, Tail, Mold )
    ! Add an item to the list if it's not already there
    character(*), intent(in) :: Word
    class(node_t), pointer, intent(inout) :: Head, Tail
    class(node_t), optional :: Mold ! For allocating extension of Node_T
    integer :: N
    class(node_t), pointer :: Node
    n = len_trim(word)
    ! Look for Word in Head .. Tail
    node => head
    do while ( associated ( node ) )
      if ( present(mold) ) then
        if ( same_type_as ( node, mold ) ) then
          if ( len(node%name) == n ) then
            if ( node%name == word ) return
          end if
        end if
      else
        if ( len(node%name) == n ) then
          if ( node%name == word ) return
        end if
      end if
      node => node%next
    end do
    ! It's not in the list so add it
    if ( present(mold) ) then
      allocate ( node, mold=mold )
    else
      allocate ( node )
    end if
    node%name = word(:n)
    if ( .not. associated(head) ) then
      head => node
    else
      tail%next => node
    end if
    tail => node
  end subroutine AddToList

  subroutine AddToLine ( Line, Stuff, Big )
    ! Add Stuff to Line after one blank.  If it won't fit, with two characters
    ! to spare, put "\" at the end of the line, output the line to MakeUnit,
    ! and start a new line with ACHAR(9) = HTAB.
    character(*), intent(inout) :: Line
    character(*), intent(in) :: Stuff
    integer, intent(in) :: Big            ! Don't let line get bigger than this
    character(2), parameter :: BS2 = "\\" ! In case processor treats \ as escape
    character(2), parameter :: BS = " " // BS2(1:1)
    character :: HT = ACHAR(9)
    integer :: N, Q
    n = len_trim(line)
    q = 4
    if ( line(1:1) == ht ) q = 12 ! Assume tab is eight characters
    if ( n + len_trim(stuff) + q >= big ) then
      line(n+1:) = bs
      write ( makeUnit, '(a)' ) line(:n+2)
      line = ht
      n = 1
    end if
    line(n+2:) = stuff
  end subroutine AddToLine

  logical function CheckExt ( PathName )
    ! Check whether the extension of the filename in pathName is in the
    ! list of extensions to be processed
    character(*), intent(in) :: PathName
    integer :: Dot                ! Position of the last dot in PathName
    character(10) :: Ext          ! Extension from PathName
    integer :: N                  ! Length (number of nonblanks) of Ext
    type(node_t), pointer :: Step ! For looking through the list
    checkExt = .false.
    dot = index(pathName,'.',back=.true.)
    if ( dot == 0 ) return
    if ( index(pathName(dot:),'/') /= 0 ) return ! Dot isn't in file name
    ext = pathName(dot+1:)
    n = len_trim(ext)
    step => firstExt
    do while ( associated(step) )
      checkExt = len(step%name) == n .and. step%name == ext(:n)
      if ( checkExt ) return ! Extension is in the list
      step => step%next
    end do
  end function CheckExt

  subroutine DumpList ( Head, First )
    character(*), intent(in) :: Head
    class(node_t), pointer, intent(in) :: First
    class(node_t), pointer :: This
    print '(a)', trim(head)
    this => First
    do while ( associated(this) )
      select type ( this )
      type is ( module_t )
        print '(2(1x,a))', this%name, this%moduleName
      class default
        print '(1x,a)', this%name ! Don't need to trim
      end select
      this => this%next
    end do
  end subroutine DumpList

  pure integer function FindNull ( C )
    ! Find the position of a first C null character in the character string C
    character(len=*), intent(in) :: C
    do findNull = 1, len(c)
      if ( c(findNull:findNull) == c_null_char ) exit
    end do
  end function FindNull

  subroutine GetOptArg
    ! Get the argument of an option, either the characters following the
    ! option if the next one is nonblank, or the next option.
    if ( arg(3:3) /= '' ) then
      arg2 = arg(3:)
    else
      i = i + 1
      call get_command_argument ( i, arg2 )
    end if
  end subroutine GetOptArg

  logical function LookForInclude ( Name, FullName )
    ! Look for an include file in the list of directories to search for them
    character(*), intent(in) :: Name      ! Include file to find
    character(*), intent(out) :: FullName ! Full name if it's found
    class(node_t), pointer :: Node        ! To search the list of directories
    lookForInclude = .false. ! Assume we don't find it
    node => firstDir
    do while ( associated ( node ) )
      fullName = node%name // '/' // name
      inquire ( file=fullName, exist=lookForInclude )
      if ( lookForInclude ) return
      node => node%next
    end do
  end function LookForInclude

  logical function LookForModule ( Name )
    ! Look for a module name in the list of files
    character(*), intent(in) :: Name      ! Module name to find
    class(node_t), pointer :: Node
    lookForModule = .false. ! ! Assume we don't find it
    node => firstFile
    do while ( associated ( node ) )
      select type ( node )
      type is ( module_t )
        lookForModule = name == node%moduleName
        if ( lookForModule ) return
      end select
      node => node%next
    end do
  end function LookForModule

  function LowerCase ( A )
    character(*), intent(in) :: A
    character(len(a)) :: LowerCase
    integer :: I
    do i = 1, len(a)
      if ( a(i:i) >= 'A' .and. a(i:i) <= 'Z' ) then
        lowerCase(i:i) = achar(iachar(a(i:i)) + iachar('a') - iachar('A'))
      else
        lowerCase(i:i) = a(i:i)
      end if
    end do
  end function LowerCase

  subroutine OutputDependencies
    class(node_t), pointer :: Dep  ! Dependency being processed
    integer :: Dot                 ! Position of last dot in file name
    character(255) :: Line
    integer :: Slash               ! Position of last slash in file name
    class(node_t), pointer :: This ! list node being processed
    this => firstFile
    do while ( associated(this) )
      ! Get the positions of the last dot and slash
      dot = index(this%name,'.',back=.true.)
      if ( dot == 0 ) dot = len(this%name) + 1
      slash = max(index(this%name,'/',back=.true.),1)
      select type ( this )
      ! Assume stuff before : fits on the line
      type is ( file_t )
        line = this%name(slash+1:dot-1) // '.' // trim(obj) // ':'
      type is ( module_t )
        line = this%name(slash+1:dot-1) // '.' // trim(obj) // &
             & ' ' // this%moduleName // ':'
      end select
      call addToLine ( line, trim(prefix) // this%name(slash+1:), width )
      select type ( this )
      class is ( file_t )
        dep => this%firstDep
        do while ( associated ( dep ) )
          if ( which == 'A' ) then ! Include all dependencies
            call addToLine ( line, dep%name, width )
          else if ( .not. same_type_as ( dep, useMold ) ) then
            call addToLine ( line, dep%name, width )
          else if ( lookForModule ( dep%name ) ) then
            call addToLine ( line, dep%name, width )
          end if
          dep => dep%next
        end do
      end select
      if ( line /= '' ) write ( makeUnit, '(a)' ) trim(line)
      line = ''
      this => this%next
    end do
  end subroutine OutputDependencies

  subroutine OutputModuleNames
    ! Output names of modules
    character(255) :: Line
    class(node_t), pointer :: This ! list node being processed
    line = 'MODULES ='
    this => firstFile
    do while ( associated(this) )
      select type ( this )
      type is ( module_t )
        call addToLine ( line, this%moduleName, width )
      end select
      this => this%next
    end do
    if ( line /= '' ) write ( makeUnit, '(a)' ) trim(line)
  end subroutine OutputModuleNames

  subroutine OutputObjectNames
    ! Output names of object files
    integer :: Dot                 ! Position of last dot in file name
    character(255) :: Line
    integer :: Slash               ! Position of last slash in file name
    class(node_t), pointer :: This ! list node being processed
    line = 'OBJS ='
    this => firstFile
    do while ( associated(this) )
      ! Get the positions of the last dot and slash
      dot = index(this%name,'.',back=.true.)
      if ( dot == 0 ) dot = len(this%name) + 1
      slash = max(index(this%name,'/',back=.true.),1)
      call addToLine ( line, this%name(slash+1:dot-1) // '.' // trim(obj), width )
      this => this%next
    end do
    if ( line /= '' ) write ( makeUnit, '(a)' ) trim(line)
  end subroutine OutputObjectNames

  subroutine OutputSourceNames
    character(255) :: Line
    integer :: Slash               ! Position of last slash in file name
    class(node_t), pointer :: This ! list node being processed
    line = 'SRC ='
    this => firstFile
    do while ( associated(this) )
      slash = max(index(this%name,'/',back=.true.),1)
      call addToLine ( line, trim(prefix) // this%name(slash+1:), width )
      this => this%next
      end do
    if ( line /= '' ) write ( makeUnit, '(a)' ) trim(line)
  end subroutine OutputSourceNames

  recursive subroutine ProcessFile ( FileToProcess, AddIt )
    ! Generate dependencies for a file, if we don't have them already
    character(*), intent(in) :: FileToProcess
    logical, intent(in) :: AddIt     ! Add it to list of files; we don't add
                                     ! include files to the list, but we do
                                     ! hunt for more dependencies in them
    integer :: Dep                   ! Incl or Use or None
    class(node_t), pointer  :: FirstDep, LastDep
    type(file_t) :: FileMold         ! To allocate File_t list items
    integer :: I
    integer, parameter :: Incl = 1   ! Dependency is from INCLUDE
    character(1023) :: IncludePath   ! Full path name of include file
    character(255) :: IOMsg          ! From OPEN statement
    logical :: IsAModule             ! File contains a MODULE statement
    character(255) :: Line           ! of a Fortran program unit (standard max
                                     ! is only 132)
    type(module_t) :: ModuleMold     ! To allocate Module_t list items
    character(255) :: ModuleName     ! From the MODULE statement
    integer, parameter :: None = 0   ! No dependency (module statement)
    integer :: Stat                  ! From OPEN statement
    type(node_t), pointer :: Step
    integer :: Unit
    integer, parameter :: Use = 2    ! Dependency is from Use
    nullify ( firstDep, lastDep )
    step => FirstFile
    do while ( associated(step) )
      if ( step%name == fileToProcess ) return ! Don't do it again
      step => step%next
    end do
    open ( file=trim(fileToProcess), newUnit=unit, status='old', &
      & action='read', iostat=stat, iomsg=iomsg )
    if ( stat /= 0 ) then
      print '(2a)', 'Unable to open ', trim(fileToProcess)
      print '(a)', trim(iomsg)
      stop
    end if
    isAModule = .false.
    do
      dep = none
      read ( unit, '(a)', end=9 ) line
      line = adjustl(line)
      if ( upperCase(line(1:7)) == 'MODULE ' ) then
        isAModule = .true.
        line = adjustl(line(8:))
        i = trimToken(line)
        moduleName = lowerCase(line(:i-1)) // '.mod'
        dep = none
      else if ( upperCase(line(1:4)) == 'USE ' ) then
        line = adjustl(line(5:))
        i = trimToken(line)
        dep = use
      else if ( upperCase(line(1:4)) == 'USE,' ) then
        line = adjustl(line(5:))
        i = index(line,'::')
        line = adjustl(line(i+2:)) ! trim off module nature
        i = trimToken(line)
        dep = use
      else if ( upperCase(line(1:8)) == 'INCLUDE ' ) then
        line = adjustl(line(9:))
        dep = incl
        i = index(line(2:),line(1:1))
        line = line(2:i)           ! Trim off quotes
        if ( lookForInclude ( line, includePath ) ) then
          call processFile ( includePath, .false. )
        else
          print '(*(a))', 'Include file "', trim(line), '" not found'
          print '(a)', 'and therefore not searched for further dependencies'
        end if
      end if
      select case ( dep )
      case ( incl )
        call addToList ( trim(line), firstDep, lastDep, inclMold )
      case ( use )
        call addToList ( lowerCase(trim(line)) // '.mod', firstDep, lastDep, &
          & useMold )
      end select
    end do
  9 continue
    if ( addIt ) then
      if ( isAModule ) then
        call addToList ( fileToProcess, firstFile, lastFile, moduleMold )
        select type ( node => lastFile )
        type is ( module_t ) ! The only possibility
          allocate ( node%moduleName, source=trim(moduleName) )
        end select
      else
        call addToList ( fileToProcess, firstFile, lastFile, fileMold )
      end if
    end if
    select type ( node => lastFile ) ! to get at firstDep and lastDep
    class is ( file_t )    ! The only possibility
      node%firstDep => firstDep
      node%lastDep => lastDep
    end select
  end subroutine ProcessFile

  integer function TrimToken ( Line ) result ( I )
    ! Remove stuff from Line following a comma, exclamation point, or blank
    character(*), intent(inout) :: Line
    i = index(line,',')
    if ( i /= 0 ) line(i:) = ''
    i = index(line,'!')
    if ( i /= 0 ) line(i:) = ''
    i = index(line,' ')
  end function TrimToken

  function UpperCase ( A )
    character(*), intent(in) :: A
    character(len(a)) :: UpperCase
    integer :: I
    do i = 1, len(a)
      if ( a(i:i) >= 'a' .and. a(i:i) <= 'z' ) then
        upperCase(i:i) = achar(iachar(a(i:i)) + iachar('A') - iachar('a'))
      else
        upperCase(i:i) = a(i:i)
      end if
    end do
  end function UpperCase

  subroutine Usage
    print 1, 'Create Makefile dependencies for files in the current ', &
           & 'working directory'
    call get_command_argument ( 0, arg )
    print 1, 'Usage: ', trim(arg), ' [options] [makefile]'
    print 1, ' Options:'
    print 1, '  -A => Include module dependencies upon all directories,', &
           & ' default ', which
    print 1, '  -C => Include only module dependencies upon current directory,', &
           & ' default ', which
    print 1, '  -I[ ]Dir => Directory to search for includes, "." is always first'
    print 1, '  -O[ ]Ext => Extension for object files, default ', trim(obj)
    print 1, '  -P[ ]Prefix => Prefix to put before source files, default "', &
           & trim(prefix), '"'
    print 2, '  -w[ ]n => Width of line in output file, default ', width
    print 1, '  -X[ ]Ext => Extension of file to examine'
    print 1, '  -d => Dump lists from command line and stop'
    print 1, '  -h (or anything else) => This output'
    print 1, ' If makefile is omitted, Makefile.dep is created in the', &
           & ' current directory.'
    stop
  1 format ( 9a )
  2 format ( a, i0 )
  end subroutine Usage

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: intrinsic.f90,v 2.73 2014/05/20 22:16:24 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ProgramName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end program Fortran_Make_Make

! $Log: $
@
