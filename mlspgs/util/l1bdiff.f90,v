head	1.38;
access;
symbols
	v5-02-NRT-19:1.38
	v6-00:1.38
	v5-02-NRT-18:1.38
	v5-02:1.38
	v5-01-NRT-17:1.38
	v5-01-NRT-16:1.38
	v5-01-NRT-15:1.38
	v5-01-NRT-14:1.38
	neuralnetworks-1-0:1.38.0.10
	cfm-single-freq-0-1:1.38.0.8
	v5-01:1.38
	v5-00:1.38
	v4-23-TA133:1.38.0.6
	mus-emls-1-70:1.38.0.4
	rel-1-0-englocks-work:1.38.0.2
	VUMLS1-00:1.35
	VPL1-00:1.34
	V4-22-NRT-08:1.32
	VAM1-00:1.31
	V4-21:1.30.0.2
	V4-13:1.30
	V4-12:1.30
	V4-11:1.30
	V4-10:1.30
	V3-43:1.18
	M4-00:1.27
	V3-41:1.18
	V3-40-PlusGM57:1.18.0.2
	V2-24-NRT-04:1.8
	V3-33:1.19
	V2-24:1.7
	V3-31:1.19
	V3-30-NRT-05:1.19
	cfm-01-00:1.18
	V3-30:1.18
	V3-20:1.18
	V3-10:1.12
	V2-23-NRT-02:1.8
	V2-23:1.7
	V2-22-NRT-01:1.8
	V2-22:1.7
	V2-21:1.6
	V2-20:1.5
	V2-11:1.5
	V2-10:1.5
	V2-00:1.5;
locks; strict;
comment	@# @;


1.38
date	2018.01.26.01.03.03;	author pwagner;	state Exp;
branches;
next	1.37;

1.37
date	2017.10.20.20.20.08;	author pwagner;	state Exp;
branches;
next	1.36;

1.36
date	2017.10.12.18.58.27;	author pwagner;	state Exp;
branches;
next	1.35;

1.35
date	2016.10.05.20.14.53;	author pwagner;	state Exp;
branches;
next	1.34;

1.34
date	2016.08.09.22.41.40;	author pwagner;	state Exp;
branches;
next	1.33;

1.33
date	2016.07.28.01.46.38;	author vsnyder;	state Exp;
branches;
next	1.32;

1.32
date	2016.03.23.16.38.28;	author pwagner;	state Exp;
branches;
next	1.31;

1.31
date	2015.06.30.18.50.33;	author pwagner;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.07.21.43.27;	author pwagner;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.09.00.31.26;	author pwagner;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.23.02.51.47;	author vsnyder;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.09.18.48.05;	author pwagner;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.12.16.40.13;	author pwagner;	state Exp;
branches;
next	1.25;

1.25
date	2012.09.06.00.37.02;	author pwagner;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.14.00.01.16;	author pwagner;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.20.20.55.48;	author pwagner;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.20.17.57.51;	author pwagner;	state Exp;
branches;
next	1.21;

1.21
date	2012.02.13.23.41.31;	author pwagner;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.10.18.28.12;	author pwagner;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.23.17.51.26;	author pwagner;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.20.23.00.50;	author pwagner;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.02.19.54.06;	author pwagner;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.30.23.06.34;	author pwagner;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.11.23.24.01;	author pwagner;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.18.20.43.23;	author pwagner;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.04.20.45.12;	author pwagner;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.16.22.37.40;	author pwagner;	state Exp;
branches;
next	1.11;

1.11
date	2008.07.10.00.14.43;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.10.20.22.37;	author pwagner;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.28.01.34.07;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.28.19.35.21;	author pwagner;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.18.00.15.25;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.22.18.33.10;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.14.16.42.38;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.14.00.58.31;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.29.00.13.56;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.23.21.01.13;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.22.19.27.32;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Improved default settings
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=================================
program l1bdiff ! diffs two l1b or L2AUX files
!=================================

   use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
   use Diff_1, only: Diff, SelfDiff
   use Dump_Options, only: DiffRMSMeansrms, RMSFormat, StatsOnOneLine, &
     & DumpDumpOptions
   use Dump_1, only: Dump
   use HDF, only: Dfacc_Create, Dfacc_Read
   use HDF5, only: H5fis_HDF5_F, &
     & H5gclose_F, H5gopen_F, H5gcreate_F
   use HighOutput, only: OutputnamedValue
   use L1bData, only: L1BData_T, Namelen, &
     & ContractL1BData, DeallocateL1BData, Diff, ReadL1BData
   use Machine, only: Hp, Getarg, NeverCrash
   use MLSFiles, only: FileNotFound, WildcardHDFVersion, &
     & MLS_Exists, MLS_HDF_Version, MLS_Sfstart, MLS_Sfend, &
     & HDFVersion_5
   use MLSHDF5, only: GetAllHDF5DSNames, MLS_H5open, MLS_H5close
   use MLSKinds, only: R8
   use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, &
     & MLSMessageConfig, MLSMessage
   use MLSStringLists, only: GetStringElement, NumStringElements
   use MLSStrings, only: Lowercase, Replace, Streq, WriteIntsToChars
   use Output_M, only: ResumeOutput, SuspendOutput, Output
   use Printit_M, only: Set_Config
   use Time_M, only: Time_Now, Time_Config

   implicit none

!---------------------------- RCS Ident Info ------------------------------
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: l1bdiff.f90,v $"
  character (len=*), parameter :: IdParm = &
       "$Id: l1bdiff.f90,v 1.37 2017/10/20 20:20:08 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
!---------------------------------------------------------------------------

! Brief description of program
! diffs two l1b or l2aux files

! To use this, copy it into
! mlspgs/tests/lib
! then enter "make depends" followed by "make"
! Then run it
! LF95.Linux/test [options] [input files]

  type Options_T
    logical     :: halfwaves = .false.
    logical     :: self = .false.
    logical     :: silent = .false.
    logical     :: timing = .false.
    logical     :: unique = .false.
    logical     :: debug = .false.
    logical     :: verbose = .false.
    logical     :: list = .false.
    logical     :: stats = .false.
    logical     :: AuBrick         = .false.
    logical     :: rms = .false.
    logical     :: table = .false.
    logical     :: direct = .true.
    logical     :: oneD = .true.
    logical     :: l2aux = .false.
    logical     :: ascii = .false. ! If true, diff even character fields
    integer     :: hdfVersion = HDFVERSION_5
    integer     :: maf1 = 0
    integer     :: maf2 = 0
    integer     :: moff = 0
    integer     :: numDiffs = 0
    character(len=255) :: group= ''     ! if SDs are within a group, group path
    character(len=255) :: sdList= '*'   ! what SDs to diff
    character(len=255) :: skipList= ''  ! what SDs to skip
    character(len=255) :: referenceFileName= 'default.h5'  ! reference filename
    character(len=80)  :: dumpOptions       = ' '
  end type Options_T

  type ( Options_T ) ::          options
  integer, parameter ::          MAXDS = 300
  integer, parameter ::          MAXSDNAMESBUFSIZE = MAXDS*namelen
  integer, parameter ::          MAXFILES = 100
  ! character(len=8)   ::          options%dumpOptions
  character(len=255) ::          filename          ! input filename
  character(len=255), dimension(MAXFILES) :: filenames
  integer     ::                 i, error ! Counting indices & Error flags
  logical     ::                 is_hdf5
  integer ::                     maf1, maf2
  character (len=MAXSDNAMESBUFSIZE) :: mySdList
  integer            ::          n_filenames
  character(len=16) ::           string
  real        ::                 t1
  real        ::                 t2
  real        ::                 tFile
  !
  call set_config ( useToolkit = .false., logFileUnit = -1 )
  time_config%use_wall_clock = .true.
  DIFFRMSMEANSRMS = .false.
  CALL mls_h5open(error)
  NeverCrash = .false.
  MLSMessageConfig%crashOnAnyError = .true.
  statsOnOneLine = .false.
  n_filenames = 0
  do      ! Loop over filenames
     call get_options(filename, n_filenames, options)
     if ( filename(1:1) == '-' ) cycle
     if ( filename == ' ' ) exit
     call h5fis_hdf5_f(trim(filename), is_hdf5, error)
     if ( options%hdfVersion==HDFVERSION_5 .and. .not. is_hdf5 ) then
       print *, 'Sorry--not recognized as hdf5 file: ', trim(filename)
       cycle
     endif
     n_filenames = n_filenames + 1
     filenames(n_filenames) = filename
  enddo
  if ( n_filenames == 0 ) then
    if ( options%verbose ) print *, 'Sorry no input files supplied'
    stop
  elseif ( options%verbose .and. options%silent ) then
    print *, 'Sorry--either verbose or silent; cant be both'
    stop
  elseif ( options%self ) then
    ! We'll do diffs within each file
  elseif ( options%referenceFileName == 'default.h5' ) then
    options%referenceFileName = filenames(n_filenames)
    n_filenames = n_filenames - 1
  endif
  if ( options%rms .or. options%AuBrick ) rmsFormat = '(1pe9.2)'
  if ( options%silent ) call suspendOutput
  ! options%dumpOptions = '-'
  if ( options%rms ) options%dumpOptions = trim(options%dumpOptions) // 'r'
  if ( options%stats ) options%dumpOptions = trim(options%dumpOptions) // 's'
  if ( options%unique ) options%dumpOptions = trim(options%dumpOptions) // 'u'
  if ( options%silent ) options%dumpOptions = trim(options%dumpOptions) // 'h'
  if ( options%direct ) options%dumpOptions = trim(options%dumpOptions) // 'd'
  if ( options%table ) options%dumpOptions = trim(options%dumpOptions) // 'b'
  if ( options%AuBrick ) options%dumpOptions = trim(options%dumpOptions) // '@@'
  call time_now ( t1 )
  if ( options%verbose .and. .not. options%list ) &
    & print *, 'Compare l1b data to: ', trim(options%referenceFileName)
  do i=1, n_filenames
    call time_now ( tFile )
    if ( options%list ) then
      print *, 'DS Names in: ', trim(filenames(i))
      if ( len_trim(options%group) < 1 ) then
        call GetAllHDF5DSNames (trim(filenames(i)), '/', mysdList)
      else
        call GetAllHDF5DSNames (trim(filenames(i)), trim(options%group), mysdList)
      endif
      call dump(mysdList, 'DS names')
    elseif ( options%self )then
      if ( options%verbose ) then
        print *, 'diffing from: ', trim(filenames(i))
      endif
      call mySelfDiff(trim(filenames(i)), options%hdfVersion, options)
      if ( options%timing ) call sayTime('diffing this file', tFile)
    else
      if ( options%verbose ) then
        print *, 'diffing from: ', trim(filenames(i))
      endif
      call myDiff(trim(filenames(i)), &
      & trim(options%referenceFileName), &
      & options%hdfVersion, options)
      if ( options%timing ) call sayTime('diffing this file', tFile)
    endif
  enddo
  if ( options%timing ) call sayTime('diffing all files')
  call resumeOutput
  ! call outputnamedValue( 'num diffs', options%numDiffs )
  if ( options%silent .and. options%numDiffs > 0 ) then
    ! write(string, '(i)') options%numDiffs
    call WriteIntsToChars ( options%numDiffs, string )
    call print_string(string)
  endif
  call mls_h5close(error)
contains
!------------------------- get_options ---------------------
    subroutine get_options( filename, n_filenames, options )
    ! Added for command-line processing of options, filenames
     character(LEN=255), intent(out)       :: filename          ! filename
     integer, intent(in)                   :: n_filenames
     type ( Options_T ), intent(inout)     :: options
     ! Local variables
     integer ::                         error = 1
     integer, save ::                   i = 1
     character(LEN=16)       :: number
  ! Get inputfile name, process command-line args
  ! (which always start with -)
    do
      call getarg ( i+hp, filename )
      ! print *, i, ' th Arg: ', trim(filename)
      error = 0
      if ( filename(1:1) /= '-' ) exit
      if ( filename(1:3) == '-h ' ) then
        call print_help
      elseif ( filename(1:5) == '-maf ' ) then
        call getarg ( i+1+hp, number )
        read(number, *) options%maf1, options%maf2
        i = i + 1
        exit
      elseif ( filename(1:6) == '-moff ' ) then
        call getarg ( i+1+hp, number )
        read(number, *) options%moff
        i = i + 1
        exit
      elseif ( filename(1:3) == '-d ' ) then
        call getarg ( i+1+hp, options%sdList )
        i = i + 1
        exit
      elseif ( filename(1:3) == '-r ' ) then
        call getarg ( i+1+hp, options%referenceFileName )
        i = i + 1
        exit
      elseif ( filename(1:5) == '-half' ) then
        options%halfWaves = .true.
        exit
      else if ( filename(1:4) == '-hdf' ) then
        call getarg ( i+1+hp, number )
        read(number, *) options%hdfVersion
        i = i + 1
        exit
      elseif ( filename(1:4) == '-one' ) then
        statsOnOneLine = .true.
        exit
      elseif ( filename(1:5) == '-opt ' ) then
        call getarg ( i+1+hp, options%dumpOptions )
        if ( index( options%dumpOptions, '?' ) > 0 ) then
          call DumpDumpOptions( "?" )
          stop
        endif
        i = i + 1
        exit
      elseif ( filename(1:6) == '-self ' ) then
        options%self = .true.
        exit
      elseif ( filename(1:8) == '-silent ' ) then
        options%silent = .true.
        exit
      elseif ( filename(1:8) == '-unique ' ) then
        options%unique = .true.
        exit
      elseif ( filename(1:3) == '-v ' ) then
        options%verbose = .true.
        exit
      elseif ( filename(1:7) == '-ascii ' ) then
        options%ascii = .true.
        exit
      elseif ( filename(1:7) == '-l2aux ' ) then
        options%l2aux = .true.
        exit
      elseif ( filename(1:3) == '-l ' ) then
        options%list = .true.
        exit
      else if ( lowercase(filename(1:3)) == '-au' ) then
        options%AuBrick = .true.
        exit
      else if ( filename(1:5) == '-rms ' ) then
        options%rms = .true.
        exit
      else if ( filename(1:3) == '-s ' ) then
        options%stats = .true.
        exit
      else if ( filename(1:2) == '-t' ) then
        options%table = .true.
        exit
      elseif ( filename(1:6) == '-skip ' ) then
        call getarg ( i+1+hp, options%skipList )
        i = i + 1
        exit
      else if ( filename(1:3) == '-f ' ) then
        call getarg ( i+1+hp, filename )
        i = i + 1
        exit
      else if ( filename(1:3) == '-g ' ) then
        call getarg ( i+1+hp, options%group )
        i = i + 1
        exit
      else
        call print_help
      end if
      i = i + 1
    end do
    if ( error /= 0 ) then
      call print_help
    endif
    i = i + 1
    if (trim(filename) == ' ' .and. n_filenames == 0) then

    ! Last chance to enter filename
      print *,  "Enter the name of the HDF5 l1b or l2aux file. "
      read(*,'(a)') filename
    endif

  end subroutine get_options
!------------------------- print_help ---------------------
  subroutine print_help
  ! Print brief but helpful message
    write (*,*) &
    & 'Usage:l1bdiff [options] [filenames]'
    write (*,*) &
    & ' If no filenames supplied, you will be prompted to supply one'
    write (*,*) ' Options: -f filename => add filename to list of filenames'
    write (*,*) '                  (can do the same w/o the -f)'
    write (*,*) '   -d list     => just diff the SDs in list'
    write (*,*) '   -g group    => find SDs under group path'
    write (*,*) '   -ascii      => diff even character-valued fields'
    write (*,*) '   -l2aux      => the files are l2aux, not l1b'
    write (*,*) '   -v          => switch on verbose mode'
    write (*,*) '   -self       => dump successive differences'
    write (*,*) '                  between values in same file'
    write (*,*) '   -half       => (1) (if with -self) '
    write (*,*) '                  show no. of 1/2 waves'
    write (*,*) '                  (2) (otherwise)'
    write (*,*) '                  diff 1/2 of channels (so DACS wont crash)'
    write (*,*) '   -hdf version=> hdf version (default is 5)'
    write (*,*) '   -one        => print name on each line (dont)'
    write (*,*) '   -opt opts   => pass opts to dump routines'
    write (*,*) '                  e.g., "?" to list available ones'
    write (*,*) '   -silent     => switch on silent mode'
    write (*,*) '                 (printing only if diffs found)'
    write (*,*) '   -unique     => dump only unique elements'
    write (*,*) '   -l          => just list sd names in files'
    write (*,*) '   -maf m1,m2  => just diff in the range [m1,m2]'
    write (*,*) '   -moff offset=> 2nd data set starts after 1st'
    write (*,*) '   -au         => format like goldbrick'
    write (*,*) '   -rms        => just print mean, rms'
    write (*,*) '   -s          => just show number of differences'
    write (*,*) '   -skip list  => skip diffing the SDs in list'
    write (*,*) '   -t[able]    => table of % vs. amount of differences (pdf)'
    write (*,*) '   -h          => print brief help'
    stop
  end subroutine print_help
!------------------------- SayTime ---------------------
  subroutine SayTime ( What, startTime )
    character(len=*), intent(in) :: What
    real, intent(in), optional :: startTime
    real :: myt1
    if ( present(startTime) ) then
      myt1 = startTime
    else
      myt1 = t1
    endif
    call time_now ( t2 )
    call output ( "Timing for " // what // " = " )
    call output ( dble(t2 - myt1), advance = 'yes' )
  end subroutine SayTime

  ! ---------------------- myDiff  ---------------------------
  subroutine myDiff( file1, file2, hdfVersion, options )
  !------------------------------------------------------------------------

    ! Given file names file1 and file2,
    ! This routine prints the diffs between them

    ! Arguments

    character (len=*), intent(in) :: file1 ! Name of file 1
    character (len=*), intent(in) :: file2 ! Name of file 2
    integer, intent(in)           :: hdfVersion
    type ( Options_T )            :: options

    ! Local
    logical, parameter            :: countEmpty = .true.
    integer :: data_type
    integer, dimension(7) :: dimsizes
    logical :: file_exists
    integer :: file_access
    integer :: firstChannel
    integer :: grpid
    integer :: i
    integer :: iHalf
    logical :: isl1boa
    type(l1bdata_t) :: L1BDATA  ! Result
    type(l1bdata_t) :: L1BDATA2 ! for diff
    type(l1bdata_t) :: L1BDATAT
    real(r8), dimension(:), pointer :: l1bValues1 => null()
    real(r8), dimension(:), pointer :: l1bValues2 => null()
    integer :: lastChannel
    logical :: mustDiff
    character(len=8) :: myOptions
    character (len=MAXSDNAMESBUFSIZE) :: mySdList
    integer :: nHalves
    integer :: NoMAFs
    integer :: noSds
    integer :: nsize
    integer :: num_Attrs
    integer :: numDiffs
    integer :: rank
    integer :: sdfid1
    integer :: sdfid2
    character (len=80) :: sdName
    integer :: sds_id
    real :: stime
    integer :: status
    integer :: the_hdfVersion

    ! hdf4 externals
    integer :: sfstart, sffinfo, sfselect, sfginfo, sfend
    external :: sfstart, sffinfo, sfselect, sfginfo, sfend

    ! Executable code
    stime = t2
    ! the_hdfVersion = HDFVERSION_5
    the_hdfVersion = hdfVersion
    file_exists = ( mls_exists(trim(File1)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File 1 not found; make sure the name and path are correct' &
        & // trim(file1) )
    endif
    if ( the_hdfVersion == WILDCARDHDFVERSION ) then
      the_hdfVersion = mls_hdf_version(File1, hdfVersion)
      if ( the_hdfVersion == FILENOTFOUND ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File 1 not found; make sure the name and path are correct' &
          & // trim(file1) )
    endif
    if ( options%verbose ) print *, 'the hdf version: ', the_hdfVersion
    if ( the_hdfVersion == HDFVERSION_5 ) then
      if ( len_trim(options%group) < 1 ) then
        call GetAllHDF5DSNames (trim(File1), '/', mysdList)
      else
        call GetAllHDF5DSNames (trim(File1), trim(options%group), mysdList)
      endif
      if ( options%verbose ) then
        call output ( '============ DS names in ', advance='no' )
        call output ( trim(file1) //' ============', advance='yes' )
      endif
      if ( mysdList == ' ' .and. .not. options%silent ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'No way yet to find sdList in ' // trim(File1) )
        return
      else
        if ( options%verbose ) call dump(mysdList, 'DS names')
      endif
      if ( options%sdList /= '*' ) then
        call output( ' Selected SDs to diff', advance='yes' )
        mySDList = options%sdList
        call dump(mysdList, 'DS names')
      endif

      isl1boa = (index(trim(mysdList), '/GHz') > 0)
      file_access = DFACC_READ
      sdfid1 = mls_sfstart(File1, DFACC_READ, hdfVersion=hdfVersion)
      if (sdfid1 == -1 ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        &  'Failed to open l1b file ' // trim(File1) )
      end if
	   call h5gOpen_f (sdfid1,'/', grpID, status)
      if ( status /= 0 .and. .not. options%silent ) then
	     call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	  & 'Unable to open group to read attribute in l2aux file' )
      endif
      sdfId2 = mls_sfstart(trim(file2), file_access, &
                & hdfVersion=hdfVersion)
      if (sdfid2 == -1 ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Failed to open l1b ' // trim(File2) )
      end if
      noSds = NumStringElements(trim(mysdList), countEmpty)
      if ( noSds < 1 .and. .not. options%silent ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'No sdNames cp to file--unable to count sdNames in ' // trim(mysdList) )
      endif
      ! May need to create groups '/sc', '/GHz', and '/THz'
      if ( isL1boa .and. file_access == DFACC_CREATE ) then
        call h5gcreate_f(sdfId2, '/sc', grpID, status)
        if ( status /= 0 ) then
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	  & 'Unable to create group /sc in ' // trim(File2) )
        endif
        call h5gcreate_f(sdfId2, '/GHz', grpID, status)
        if ( status /= 0 ) then
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	  & 'Unable to create group /GHz in ' // trim(File2) )
        endif
        call h5gcreate_f(sdfId2, '/THz', grpID, status)
        if ( status /= 0 ) then
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	  & 'Unable to create group /THz in ' // trim(File2) )
        endif
      endif
    else
      sdfid1 = sfstart( trim(File1), DFACC_READ )
      status = sffinfo( sdfid1, noSds, nsize )
      mysdList = '*'
      sdfid2 = sfstart( trim(File2), DFACC_READ )
      status = sffinfo( sdfid1, noSds, nsize )
    endif
    if ( options%halfwaves ) then
      nHalves = 2
    else
      nHalves = 1
    endif
    ! Loop over sdNames in file 1
    ! (But skip PCF and HDFEOS INFORMATION/coremetadata.0)
    do i = 1, noSds
      numDiffs = 0
      if ( the_hdfversion == HDFVERSION_5 ) then
        call GetStringElement (trim(mysdList), sdName, i, countEmpty )
        if ( len_trim(options%group) > 1 ) sdName = trim(options%group) // sdName
      else
        sds_id = sfselect( sdfid1, i-1 ) ! "c" arrays begin with index 0
        status = sfginfo( sds_id, sdName, rank, dimsizes, data_type, num_attrs )
        ! print *, 'sdName: ', sdName
      endif
      if ( any( &
        & streq( &
        & (/ 'PCF ', 'meta', 'l2cf', 'utcp', 'leap', 'LCF ' /), &
        & sdname, options='-Pw' ) ) .or. &
        &  index(options%skipList, trim(sdName)) > 0 ) cycle
      do ihalf=1, nHalves
        ! Allocate and fill l2aux
        if ( options%debug ) print *, 'About to read ', trim(sdName)
        if ( options%halfwaves ) then
          call ReadL1BData ( sdfid1, trim(sdName), L1bDataT, NoMAFs, status, &
            & hdfVersion=the_hdfVersion, NEVERFAIL=.true., l2aux=options%l2aux )
          if ( noMAFs < 1 ) cycle
          if ( status /= 0 .and. .not. options%silent ) then
	         call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	  & 'Unable to find ' // trim(sdName) // ' in ' // trim(File1) )
            call DeallocateL1BData ( l1bData )
            cycle
          endif
          if ( iHalf == 1 ) then
            firstChannel = 1
            lastChannel = min(L1bDataT%NoAuxInds, L1bDataT%NoAuxInds/2 + 1)
          else
            if ( L1bDataT%NoAuxInds < 3 ) cycle
            firstChannel = L1bDataT%NoAuxInds/2 + 2
            lastChannel = L1bDataT%NoAuxInds
          endif
          call contractL1BData( L1bDataT, L1bData, noMAFs, &
            & firstChannel=firstChannel, lastChannel=lastChannel)
          call deallocateL1BData( L1bDataT )
        else
          call ReadL1BData ( sdfid1, trim(sdName), L1bData, NoMAFs, status, &
            & hdfVersion=the_hdfVersion, NEVERFAIL=.true., l2aux=options%l2aux )
          if ( status /= 0 .and. .not. options%silent ) then
	         call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	  & 'Unable to find ' // trim(sdName) // ' in ' // trim(File1) )
            call DeallocateL1BData ( l1bData )
            cycle
          endif
        endif
        if ( options%timing ) call SayTime( 'Reading l1bdata 1', stime )
        stime = t2
        if ( options%halfwaves ) then
          call ReadL1BData ( sdfid1, trim(sdName), L1bDataT, NoMAFs, status, &
            & hdfVersion=the_hdfVersion, NEVERFAIL=.true., l2aux=options%l2aux )
          call contractL1BData( L1bDataT, L1bData2, noMAFs, &
            & firstChannel=firstChannel, lastChannel=lastChannel )
          call deallocateL1BData( L1bDataT )
        else
          call ReadL1BData ( sdfid2, trim(sdName), L1bData2, NoMAFs, status, &
            & hdfVersion=the_hdfVersion, NEVERFAIL=.true., l2aux=options%l2aux )
          if ( status /= 0 .and. .not. options%silent ) then
	         call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	  & 'Unable to find ' // trim(sdName) // ' in ' // trim(File1) )
            call DeallocateL1BData ( l1bData )
            call DeallocateL1BData ( l1bData2 )
            cycle
          endif
        endif
        if ( options%timing ) call SayTime( 'Reading l1bdata 2', stime )
        stime = t2
        if ( associated(L1bData%charField) .and. .not. options%ascii .and. &
          & .not. options%silent ) then
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Skipping diff of char-valued ' // trim(sdName) )
          call DeallocateL1BData ( l1bData )
          call DeallocateL1BData ( l1bData2 )
          cycle
        endif
        maf1 = 1
        if ( options%maf1 > 0 ) maf1 = options%maf1
        maf2 = NoMAFs
        if ( options%maf2 > 0 ) maf2 = options%maf2
        if ( options%verbose ) then
          print *, 'About to diff :: ' // trim(sdName) // ' ::'
        elseif ( .not. options%silent ) then
          print *, ':: ' // trim(sdName) // ' ::'
        endif
        mustDiff = .true.
        if ( associated(L1bData%dpField) .and. associated(L1bData2%dpField) ) then
          if ( all(L1bData%dpField == L1bData2%dpField) ) mustDiff = .false.
        endif
        myOptions = options%dumpOptions
        if ( mustDiff ) myOptions = Replace ( myOptions, 'h', ' ' )
        if ( associated(L1bData%dpField) .and. mustDiff .and. options%debug ) &
          & call outputNamedValue( 'num diffs', &
          & count(L1bData%dpField /= L1bData2%dpField), &
          & advance='yes' )
        if ( .not. mustDiff ) then
          if ( .not. options%silent ) &
            & call output( '(The two arrays are exactly equal)', advance='yes' )
        elseif ( options%oneD .and. associated(L1bData%dpField) ) then
          ! We will store L1BData%dpField in a values array
          nsize = product(shape(L1bData%dpField))
          call dump( L1bData%dpField-L1bData2%dpField, &
            & options=myOptions )
          ! We use dump instead of diff (but why?)
          ! stop
          call allocate_test(l1bValues1, nsize, 'l1bValues1', ModuleName )
          l1bValues1 = reshape( L1bData%dpField, (/nsize/) )
          call deallocate_test( L1bData%dpField, 'l1bData%Values1', ModuleName )
          call allocate_test(l1bValues2, nsize, 'l1bValues2', ModuleName )
          l1bValues2 = reshape( L1bData2%dpField, (/nsize/) )
          call deallocate_test( L1bData2%dpField, 'l1bData%Values2', ModuleName )
          if ( options%timing ) call SayTime( 'Copying values to 1-d arrays', stime )
          stime = t2

          call diff(L1bData, L1bData2, numDiffs=numDiffs, options=myOptions, &
            & l1bValues1=l1bValues1, l1bValues2=l1bValues2 )
          call deallocate_test( L1bValues1, 'l1bValues1', ModuleName )
          call deallocate_test( L1bValues2, 'l1bValues2', ModuleName )
        elseif ( options%direct .or. .not. associated(L1bData%dpField) ) then
          if ( options%verbose ) print *, 'About to do it direct ' // myOptions
          call diff(L1bData, L1bData2, numDiffs=numDiffs, options=myOptions )
        else
          call diff(L1bData, L1bData2, details=0, &
            & numDiffs=numDiffs, options=myOptions )
          if ( .true. .and. associated(L1bData%dpField) .and. &
            & associated(L1bData2%dpField)) then
            if ( options%silent .and. numDiffs < 1 ) then
            elseif ( .false. .and. all(L1bData%dpField(:,:,maf1:maf2) == &
              & L1bData2%dpField(:,:,maf1+options%moff:maf2+options%moff)) ) then
              print *, '(The two fields are exactly equal)'
            elseif( options%moff /= 0 .or. options%maf1 > 0 ) then
              call diff( L1bData%dpField(:,:,maf1:maf2), &
                & '(1)', &
                & L1bData2%dpField(:,:,maf1+options%moff:maf2+options%moff), &
                & '(2)', &
                & options=myOptions )
            else
              call diff( L1bData%dpField, &
                & '(1)', &
                & L1bData2%dpField, &
                & '(2)', &
                & options=myOptions )
            endif
          else
            L1bData%dpField = L1bData%dpField - L1bData2%dpField(:,:,1+options%moff:)
            if ( options%silent ) then
            elseif ( .false. .and. all(L1bData%dpField == 0.d0) ) then
              print *, '(The two fields are exactly equal)'
            elseif ( options%maf1 /= 0 .and. options%maf2 /= 0 ) then
              call dump( L1bData%dpField(:,:,options%maf1:options%maf2), &
                & 'l1bData%dpField', options=myOptions )
            else
              call dump( L1bData%dpField, &
                & 'l1bData%dpField', options=myOptions )
            endif
          endif
        endif
        call DeallocateL1BData ( l1bData )
        call DeallocateL1BData ( l1bData2 )
        options%numDiffs = options%numDiffs + numDiffs
        if ( options%timing ) call SayTime( 'Doing the diff', stime )
        stime = t2
      enddo ! Loop of halves
      if ( options%debug ) print *, 'After ' // trim(sdName) // ' ', options%numDiffs
    enddo ! Loop of datasets
    if ( the_hdfVersion == HDFVERSION_5) call h5gClose_f (grpID, status)
    if ( status /= 0 .and. .not. options%silent ) then
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
       & 'Unable to close group in l2aux file: ' // trim(File1) // ' after diffing' )
    endif
    if ( the_hdfVersion == HDFVERSION_5 ) then
	   status = mls_sfend(sdfid1, hdfVersion=the_hdfVersion)
      if ( status /= 0 ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "Unable to close L2aux file: " // trim(File1) // ' after diffing')
	   status = mls_sfend(sdfid2, hdfVersion=the_hdfVersion)
      if ( status /= 0 ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
         & "Unable to close L2aux file: " // trim(File2) // ' after diffing')
    else
      ! print *, 'Ending MyDiff'
      status = sfend( sdfid1 )
      status = sfend( sdfid2 )
    endif
  end subroutine myDiff

  ! ---------------------- mySelfDiff  ---------------------------
  subroutine mySelfDiff( file1, hdfVersion, options )
  !------------------------------------------------------------------------

    ! Given file name file1
    ! This routine prints its selfdiffs

    ! Arguments

    character (len=*), intent(in) :: file1 ! Name of file 1
    integer, intent(in)           :: hdfVersion
    type ( Options_T )            :: options

    ! Local
    logical, parameter            :: countEmpty = .true.
    logical :: file_exists
    integer :: grpid
    integer :: i
    type(l1bdata_t) :: L1BDATA  ! Result
    character (len=MAXSDNAMESBUFSIZE) :: mySdList
    integer :: NoMAFs
    integer :: noSds
    integer :: numDiffs
    integer :: sdfid1
    character (len=80) :: sdName
    integer :: status
    integer :: the_hdfVersion
    logical, parameter :: SKIPIFRANKTOOHIGH = .false.

    ! Executable code
    ! the_hdfVersion = HDFVERSION_5
    the_hdfVersion = hdfVersion
    file_exists = ( mls_exists(trim(File1)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File 1 not found; make sure the name and path are correct' &
        & // trim(file1) )
    endif
    if ( the_hdfVersion == WILDCARDHDFVERSION ) then
      the_hdfVersion = mls_hdf_version(File1, hdfVersion)
      if ( the_hdfVersion == FILENOTFOUND ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File 1 not found; make sure the name and path are correct' &
          & // trim(file1) )
    endif
    call GetAllHDF5DSNames (trim(File1), '/', mysdList)
    if ( options%verbose) then
      call output ( '============ DS names in ', advance='no' )
      call output ( trim(file1) //' ============', advance='yes' )
    endif
    if ( mysdList == ' ' .and. .not. options%silent ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'No way yet to find sdList in ' // trim(File1) )
      return
    else
      if ( options%verbose ) call dump(mysdList, 'DS names')
    endif
    if ( options%sdList /= '*' ) then
      call output( ' Selected SDs to diff', advance='yes' )
      mySDList = options%sdList
      call dump(mysdList, 'DS names')
    endif

    sdfid1 = mls_sfstart(File1, DFACC_READ, hdfVersion=hdfVersion)
    if (sdfid1 == -1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  'Failed to open l1b file ' // trim(File1) )
    end if
	 call h5gOpen_f (sdfid1,'/', grpID, status)
    if ( status /= 0 .and. .not. options%silent ) then
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to open group to read attribute in l2aux file' )
    endif
    noSds = NumStringElements(trim(mysdList), countEmpty)
    if ( noSds < 1 .and. .not. options%silent ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'No sdNames cp to file--unable to count sdNames in ' // trim(mysdList) )
    endif
    ! Loop over sdNames in file 1
    ! (But skip PCF and HDFEOS INFORMATION/coremetadata.0)
    do i = 1, noSds
      call GetStringElement (trim(mysdList), sdName, i, countEmpty )
      if ( sdName == 'PCF' .or. &
        &  sdName == 'HDFEOS INFORMATION/coremetadata.0' .or. &
        &  sdName == 'l2cf' .or. &
        &  index(options%skipList, trim(sdName)) > 0 ) cycle
      ! Allocate and fill l2aux
      ! if ( options%verbose ) print *, 'About to read ', trim(sdName)
      call ReadL1BData ( sdfid1, trim(sdName), L1bData, NoMAFs, status, &
        & hdfVersion=the_hdfVersion, NEVERFAIL=.true., l2aux=options%l2aux )
      if ( status /= 0 .and. .not. options%silent ) then
	     call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to find ' // trim(sdName) // ' in ' // trim(File1) )
        call DeallocateL1BData ( l1bData )
        cycle
      endif
      if ( associated(L1bData%charField) .and. .not. options%silent ) then
	     call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Skipping diff of char-valued ' // trim(sdName) )
      elseif ( associated(L1bData%intField) .and. .not. options%silent ) then
        if ( ( size(L1bData%intField, 1) > 1 .or. &
          &  size(L1bData%intField, 2) > 1 ) .and. SKIPIFRANKTOOHIGH ) then
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Skipping diff high-rank ' // trim(sdName) )
        else
          call selfdiff( L1bData%intField(1, 1, :), trim(sdName), &
            & waves=options%halfWaves, options=options%dumpOptions )
        endif
      elseif ( associated(L1bData%dpField) ) then
        if ( ( size(L1bData%dpField, 1) > 1 .or. &
          &  size(L1bData%dpField, 2) > 1 ) .and. SKIPIFRANKTOOHIGH &
          & .and. .not. options%silent ) then
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Skipping diff high-rank ' // trim(sdName) )
        else
          call selfdiff( L1bData%dpField(1, 1, :), trim(sdName), &
            & waves=options%halfWaves, options=options%dumpOptions )
        endif
      endif
      call DeallocateL1BData ( l1bData )
    enddo
    call h5gClose_f (grpID, status)
    if ( status /= 0 .and. .not. options%silent ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & 'Unable to close group in l2aux file: ' // trim(File1) // ' after diffing' )
    endif
	 status = mls_sfend(sdfid1, hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Unable to close L2aux file: " // trim(File1) // ' after diffing')
  end subroutine mySelfDiff

!------------------------- print_string ---------------------
  subroutine print_string(string)
    character(len=*), intent(in) :: string
    write(*,'(a)') trim(string)
  end subroutine print_string

!==================
end program l1bdiff
!==================

! $Log: l1bdiff.f90,v $
! Revision 1.37  2017/10/20 20:20:08  pwagner
! Crash with a walkback if an error occurs
!
! Revision 1.36  2017/10/12 18:58:27  pwagner
! CamelCase more use statements
!
! Revision 1.35  2016/10/05 20:14:53  pwagner
! Implemented Au (Gold) option
!
! Revision 1.34  2016/08/09 22:41:40  pwagner
! Consistent with splitting of Dunp_0
!
! Revision 1.33  2016/07/28 01:46:38  vsnyder
! Refactor diff and dump
!
! Revision 1.32  2016/03/23 16:38:28  pwagner
! Added -one commandline option
!
! Revision 1.31  2015/06/30 18:50:33  pwagner
! Corrected error in passing dumpOptions to dump module; -opt '?' now dumps available dump options
!
! Revision 1.30  2014/03/07 21:43:27  pwagner
! Name_Len changed to nameLen; got from MLSCommon
!
! Revision 1.29  2014/01/09 00:31:26  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 1.28  2013/08/23 02:51:47  vsnyder
! Move PrintItOut to PrintIt_m
!
! Revision 1.27  2013/01/09 18:48:05  pwagner
! Dont omit sdname from output
!
! Revision 1.26  2012/09/12 16:40:13  pwagner
! Works more reliably with goldbrick
!
! Revision 1.25  2012/09/06 00:37:02  pwagner
! Works better with goldbrick
!
! Revision 1.24  2012/06/14 00:01:16  pwagner
! Willing to selfdiff higher-rank fields instance-wise
!
! Revision 1.23  2012/04/20 20:55:48  pwagner
! Restored silence to silent option
!
! Revision 1.22  2012/04/20 17:57:51  pwagner
! Fixed syntax error of dumpOptions
!
! Revision 1.21  2012/02/13 23:41:31  pwagner
! -opt opts passes opts to underlying dump routines
!
! Revision 1.20  2011/05/10 18:28:12  pwagner
! Avoid annoying messages unless verbose
!
! Revision 1.19  2010/07/23 17:51:26  pwagner
! Now able to diff hdf4-formatted files
!
! Revision 1.18  2009/11/20 23:00:50  pwagner
! Should not segfault when diffing DACS datasets
!
! Revision 1.17  2009/11/02 19:54:06  pwagner
! Fixed bug causing goldbrick to print excessively
!
! Revision 1.16  2009/10/30 23:06:34  pwagner
! Last change let executable land on bare stop; must fix oneD yet
!
! Revision 1.15  2009/09/11 23:24:01  pwagner
! options now include -t to be consistent with diff apis
!
! Revision 1.14  2009/08/18 20:43:23  pwagner
! Changes needed to diff DACS radiance files
!
! Revision 1.13  2009/08/04 20:45:12  pwagner
! silent option adds 'h' to options arg
!
! Revision 1.12  2009/06/16 22:37:40  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 1.11  2008/07/10 00:14:43  pwagner
! Added -self, -half, -unique options
!
! Revision 1.10  2008/04/10 20:22:37  pwagner
! Less voluminous output
!
! Revision 1.9  2008/02/28 01:34:07  pwagner
! Normally should skip diffing character-valued fields
!
! Revision 1.8  2007/11/28 19:35:21  pwagner
! May specify that files are l2aux
!
! Revision 1.7  2007/07/18 00:15:25  pwagner
! -rms outputs fractional diffs more clearly
!
! Revision 1.6  2006/11/22 18:33:10  pwagner
! New optional args to diff l1b files with different number MAFs
!
! Revision 1.5  2006/06/14 16:42:38  pwagner
! Should not run out of memory unless direct reset to TRUE
!
! Revision 1.4  2006/01/14 00:58:31  pwagner
! Added -silent option
!
! Revision 1.3  2005/10/29 00:13:56  pwagner
! Removed unused procedures from use statements
!
! Revision 1.2  2005/09/23 21:01:13  pwagner
! use_wall_clock now a component of time_config
!
! Revision 1.1  2005/06/22 19:27:32  pwagner
! Reworded Copyright statement, moved rcs id
!
@


1.37
log
@Crash with a walkback if an error occurs
@
text
@d47 1
a47 1
       "$Id: l1bdiff.f90,v 1.36 2017/10/12 18:58:27 pwagner Exp $"
d108 1
a108 1
  DIFFRMSMEANSRMS = .true.
d138 1
a138 1
  if ( options%rms ) rmsFormat = '(1pe9.2)'
d838 3
@


1.36
log
@CamelCase more use statements
@
text
@d27 1
a27 1
   use Machine, only: Hp, Getarg
d34 1
a34 1
     & MLSMessage
d47 1
a47 1
       "$Id: l1bdiff.f90,v 1.35 2016/10/05 20:14:53 pwagner Exp $"
d110 2
d838 3
@


1.35
log
@Implemented Au (Gold) option
@
text
@d16 4
a19 4
   use Allocate_deallocate, only: allocate_test, deallocate_test
   use Diff_1, only: Diff, selfDiff
   use Dump_Options, only: diffRMSMeansrms, RMSFormat, statsOnOneLine, &
     & dumpDumpOptions
d21 9
a29 9
   use HDF, only: dfacc_create, dfacc_read
   use HDF5, only: h5fis_HDF5_f, &
     & H5gclose_f, h5gopen_f, h5gcreate_f
   use Highoutput, only: outputnamedvalue
   use L1bdata, only: L1BData_t, namelen, &
     & ContractL1BData, deallocateL1BData, diff, readL1Bdata
   use Machine, only: hp, getarg
   use MLSFiles, only: fileNotFound, wildcardHDFVersion, &
     & MLS_exists, MLS_HDF_version, MLS_sfstart, MLS_sfend, &
d31 2
a32 2
   use MLSHDF5, only: getAllHDF5DSNames, MLS_h5open, MLS_h5close
   use MLSKinds, only: r8
d35 5
a39 5
   use MLSStringLists, only: getStringElement, numStringElements
   use MLSStrings, only: lowercase, replace, streq, writeIntsToChars
   use Output_m, only: resumeOutput, suspendOutput, output
   use Printit_m, only: set_config
   use Time_m, only: time_now, time_config
d47 1
a47 1
       "$Id: l1bdiff.f90,v 1.34 2016/08/09 22:41:40 pwagner Exp $"
d60 1
a60 1
  type options_T
d87 1
a87 1
  end type options_T
d89 1
a89 1
  type ( options_T ) ::          options
d190 1
a190 1
     type ( options_T ), intent(inout)     :: options
d306 34
a339 34
      write (*,*) &
      & 'Usage:l1bdiff [options] [filenames]'
      write (*,*) &
      & ' If no filenames supplied, you will be prompted to supply one'
      write (*,*) ' Options: -f filename => add filename to list of filenames'
      write (*,*) '                  (can do the same w/o the -f)'
      write (*,*) '   -d list     => just diff the SDs in list'
      write (*,*) '   -g group    => find SDs under group path'
      write (*,*) '   -ascii      => diff even character-valued fields'
      write (*,*) '   -l2aux      => the files are l2aux, not l1b'
      write (*,*) '   -v          => switch on verbose mode'
      write (*,*) '   -self       => dump successive differences'
      write (*,*) '                  between values in same file'
      write (*,*) '   -half       => (1) (if with -self) '
      write (*,*) '                  show no. of 1/2 waves'
      write (*,*) '                  (2) (otherwise)'
      write (*,*) '                  diff 1/2 of channels (so DACS wont crash)'
      write (*,*) '   -hdf version=> hdf version (default is 5)'
      write (*,*) '   -one        => print name on each line (dont)'
      write (*,*) '   -opt opts   => pass opts to dump routines'
      write (*,*) '                  e.g., "?" to list available ones'
      write (*,*) '   -silent     => switch on silent mode'
      write (*,*) '                 (printing only if diffs found)'
      write (*,*) '   -unique     => dump only unique elements'
      write (*,*) '   -l          => just list sd names in files'
      write (*,*) '   -maf m1,m2  => just diff in the range [m1,m2]'
      write (*,*) '   -moff offset=> 2nd data set starts after 1st'
      write (*,*) '   -au         => format like goldbrick'
      write (*,*) '   -rms        => just print mean, rms'
      write (*,*) '   -s          => just show number of differences'
      write (*,*) '   -skip list  => skip diffing the SDs in list'
      write (*,*) '   -t[able]    => table of % vs. amount of differences (pdf)'
      write (*,*) '   -h          => print brief help'
      stop
d368 1
a368 1
    type ( options_T )            :: options
a607 1

d610 1
a650 1
            ! print *, 'About to form dpField = dpField1 - dpField2'
d704 1
a704 1
    type ( options_T )            :: options
d836 3
@


1.34
log
@Consistent with splitting of Dunp_0
@
text
@d36 1
a36 1
   use MLSStrings, only: replace, streq, writeIntsToChars
d47 1
a47 1
       "$Id: l1bdiff.f90,v 1.33 2016/07/28 01:46:38 vsnyder Exp $"
d70 1
d145 1
d262 3
d333 1
a493 2
      ! print *, 'status ', status
      ! print *, 'noSds ', noSds
a496 2
      ! print *, 'status ', status
      ! print *, 'noSds ', noSds
a514 3
!      if ( sdName == 'PCF' .or. &
!        &  sdName == 'HDFEOS INFORMATION/coremetadata.0' .or. &
!        &  sdName == 'l2cf' .or. &
a519 4
   !    print *, trim(sdName)
   !    print *, streq( '*PCF*', sdname, '-w' )
   !    print *, streq( '*meta*', sdname, '-w' )
   !    print *, streq( '*l2cf*', sdname, '-w' )
a525 2
          ! call outputNamedValue( 'NoMAFs', noMAFs )
          ! call outputNamedValue( 'status', status )
a555 3
        ! if (associated(L1BData%dpField) ) &
        !   & call outputnamedValue('shape(l1bdata)', shape(L1BData%dpField) )
        ! if ( options%verbose ) print *, 'About to read ', trim(sdName), ' (2nd)'
a574 2
        ! if (associated(L1BData2%dpField) ) &
        !   & call outputnamedValue('shape(l1bdata2)', shape(L1BData2%dpField) )
a597 2
        ! print *, mustDiff
        ! print *, trim(myOptions)
d608 2
a609 3
          ! if ( options%verbose ) print *, 'About to do it 1-d ' // options%dumpOptions, nsize
          ! print *, 'Calling dump', maxval(L1bData%dpField-L1bData2%dpField)
          call dump( L1bData%dpField-L1bData2%dpField, 'L1bData%dpField diff', &
d620 1
a620 2
          ! if ( options%verbose ) print *, 'About to do it 1-d ' // options%dumpOptions, nsize
          ! print *, 'Calling diff', maxval(l1bValues2-l1bValues1)
a626 1
          ! print *, 'Calling direct diff'
a628 2
          ! print *, 'details=0'
          ! print *, 'Calling 3rd diff'
a630 3
          ! print *, 'done diffing'

          ! numDiffs = numDiffs + count( L1bData%dpField /= L1bData2%dpField )
a637 2
              ! print *, 'About to diff dpFields'
              ! print *, 'Calling 4th diff'
a656 2
              ! print *, shape( L1bData%dpField(:,:,options%maf1:options%maf2) )
              ! print *, 'Calling 2nd dump'
a659 2
              ! print *, shape( L1bData%dpField )
              ! print *, 'Calling 3rd dump'
d837 3
@


1.33
log
@Refactor diff and dump
@
text
@d17 4
a20 4
   use Diff_1, only: Diff
   use Dump_0, only: diffRMSMeansrms, RMSFormat, statsOnOneLine, &
     & Dump, dumpDumpOptions
   use Dump_1, only: selfDiff
d47 1
a47 1
       "$Id: l1bdiff.f90,v 1.32 2016/03/23 16:38:28 pwagner Exp $"
d865 3
@


1.32
log
@Added -one commandline option
@
text
@d17 1
d19 2
a20 1
     & Diff, dump, dumpDumpOptions, selfDiff
d47 1
a47 1
       "$Id: l1bdiff.f90,v 1.31 2015/06/30 18:50:33 pwagner Exp $"
d865 3
@


1.31
log
@Corrected error in passing dumpOptions to dump module; -opt '?' now dumps available dump options
@
text
@d17 1
a17 1
   use Dump_0, only: diffRMSMeansrms, RMSFormat, &
d45 1
a45 1
       "$Id: l1bdiff.f90,v 1.30 2014/03/07 21:43:27 pwagner Exp $"
d107 1
d226 3
d317 1
d863 3
@


1.30
log
@Name_Len changed to nameLen; got from MLSCommon
@
text
@d16 22
a37 21
   use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
   use Dump_0, only: DIFFRMSMEANSRMS, RMSFORMAT, DIFF, DUMP, SELFDIFF
   use Hdf, only: DFACC_CREATE, DFACC_READ
   use HDF5, only: H5FIS_HDF5_F, &
     & H5GCLOSE_F, H5GOPEN_F, H5GCREATE_F
   use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
   use L1BData, only: L1BDATA_T, NAMELEN, &
     & CONTRACTL1BDATA, DEALLOCATEL1BDATA, DIFF, READL1BDATA
   use MACHINE, only: HP, GETARG
   use MLSFiles, only: FILENOTFOUND, WILDCARDHDFVERSION, &
     & MLS_EXISTS, MLS_HDF_VERSION, MLS_SFSTART, MLS_SFEND, &
     & HDFVERSION_5
   use MLSHDF5, only: GETALLHDF5DSNAMES, MLS_H5OPEN, MLS_H5CLOSE
   use MLSKinds, only: R8
   use MLSMessageModule, only: MLSMSG_ERROR, MLSMSG_WARNING, &
     & MLSMESSAGE
   use MLSStringLists, only: GETSTRINGELEMENT, NUMSTRINGELEMENTS
   use MLSStrings, only: REPLACE, STREQ, WRITEINTSTOCHARS
   use output_m, only: RESUMEOUTPUT, SUSPENDOUTPUT, OUTPUT
   use PrintIt_m, only: SET_CONFIG
   use Time_M, only: TIME_NOW, TIME_CONFIG
d45 1
a45 1
       "$Id: l1bdiff.f90,v 1.29 2014/01/09 00:31:26 pwagner Exp $"
a89 1
  logical ::                     columnsOnly
d93 1
a93 1
  integer     ::                 i, status, error ! Counting indices & Error flags
d134 1
a134 1
  options%dumpOptions = '-'
d227 4
d314 1
a834 1
      cycle
d836 1
a836 1
	 call h5gClose_f (grpID, status)
d838 2
a839 2
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
       & 'Unable to close group in l2aux file: ' // trim(File1) // ' after diffing' )
d843 2
a844 2
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2aux file: " // trim(File1) // ' after diffing')
d858 3
@


1.29
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d20 1
a20 1
     & H5GCLOSE_F, H5GOPEN_F, H5DOPEN_F, H5DCLOSE_F, H5GCREATE_F
d22 1
a22 1
   use L1BData, only: L1BData_T, NAME_LEN, &
d24 1
a24 1
   use MACHINE, only: FILSEP, HP, IO_ERROR, GETARG
d27 1
a27 1
     & HDFVERSION_4, HDFVERSION_5
d30 1
a30 1
   use MLSMessageModule, only: MLSMESSAGECONFIG, MLSMSG_ERROR, MLSMSG_WARNING, &
d35 1
a35 1
   use PrintIt_m, only: Set_Config
d44 1
a44 1
       "$Id: l1bdiff.f90,v 1.28 2013/08/23 02:51:47 vsnyder Exp $"
d87 1
a87 1
  integer, parameter ::          MAXSDNAMESBUFSIZE = MAXDS*NAME_LEN
d165 1
a165 1
      & trim(options%referenceFileName), (i==1), &
d339 1
a339 1
  subroutine myDiff( file1, file2, create2, hdfVersion, options )
a348 1
    logical, intent(in)           :: create2
a725 1
    integer :: file_access
a727 1
    logical :: isl1boa
a772 2
    isl1boa = (index(trim(mysdList), '/GHz') > 0)
    file_access = DFACC_READ
d854 3
@


1.28
log
@Move PrintItOut to PrintIt_m
@
text
@d21 1
d34 1
a34 1
   use output_m, only: RESUMEOUTPUT, SUSPENDOUTPUT, OUTPUT, OUTPUTNAMEDVALUE
d44 1
a44 1
       "$Id: l1bdiff.f90,v 1.27 2013/01/09 18:48:05 pwagner Exp $"
d859 3
@


1.27
log
@Dont omit sdname from output
@
text
@d34 1
d36 1
a36 1
   
d43 1
a43 1
       "$Id: l1bdiff.f90,v 1.26 2012/09/12 16:40:13 pwagner Exp $"
d83 1
a83 1
  
d101 2
a102 3
  ! 
  MLSMessageConfig%useToolkit = .false.
  MLSMessageConfig%logFileUnit = -1
d159 1
a159 1
    else 
d285 1
a285 1
    
d386 1
a386 1
    
d390 1
a390 1
    
d475 1
a475 1
      status = sffinfo( sdfid1, noSds, nsize ) 
d480 1
a480 1
      status = sffinfo( sdfid1, noSds, nsize ) 
d498 1
a498 1
        status = sfginfo( sds_id, sdName, rank, dimsizes, data_type, num_attrs ) 
d740 1
a740 1
    
d858 3
@


1.26
log
@Works more reliably with goldbrick
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.25 2012/09/06 00:37:02 pwagner Exp $"
d588 1
a588 1
          print *, 'About to diff'
d858 3
@


1.25
log
@Works better with goldbrick
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.24 2012/06/14 00:01:16 pwagner Exp $"
a391 1
    numDiffs = 0
d492 1
d590 1
a590 1
          print *, trim(sdName)
d600 1
a600 1
        if ( associated(L1bData%dpField) .and. mustDiff .and. .not. options%silent ) &
d640 1
a640 1
          numDiffs = numDiffs + count( L1bData%dpField /= L1bData2%dpField )
d687 1
a687 1
      if ( .not. options%silent ) print *, 'After ' // trim(sdName) // ' ', options%numDiffs
d858 3
@


1.24
log
@Willing to selfdiff higher-rank fields instance-wise
@
text
@d32 1
a32 1
   use MLSStrings, only: WRITEINTSTOCHARS
d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.23 2012/04/20 20:55:48 pwagner Exp $"
d171 1
d370 1
d420 1
a420 1
      if ( mysdList == ' ' ) then
d441 1
a441 1
      if ( status /= 0 ) then
d452 1
a452 1
      if ( noSds < 1 ) then
d501 7
a507 3
      if ( sdName == 'PCF' .or. &
        &  sdName == 'HDFEOS INFORMATION/coremetadata.0' .or. &
        &  sdName == 'l2cf' .or. &
d509 4
d522 1
a522 1
          if ( status /= 0 ) then
d542 1
a542 1
          if ( status /= 0 ) then
d563 1
a563 1
          if ( status /= 0 ) then
d575 2
a576 1
        if ( associated(L1bData%charField) .and. .not. options%ascii ) then
d596 4
d610 2
a611 1
          if ( options%verbose ) print *, 'About to do it 1-d ' // options%dumpOptions, nsize
d613 1
a613 1
            & options=options%dumpOptions )
d623 3
a625 2
          if ( options%verbose ) print *, 'About to do it 1-d ' // options%dumpOptions, nsize
          call diff(L1bData, L1bData2, numDiffs=numDiffs, options=options%dumpOptions, &
d630 3
a632 2
          if ( options%verbose ) print *, 'About to do it direct ' // options%dumpOptions
          call diff(L1bData, L1bData2, numDiffs=numDiffs, options=options%dumpOptions )
d635 1
d637 1
a637 1
            & numDiffs=numDiffs, options=options%dumpOptions )
d643 1
a643 1
            if ( options%silent ) then
d649 1
d654 1
a654 1
                & options=options%dumpOptions )
d660 1
a660 1
                & options=options%dumpOptions )
d670 1
d672 1
a672 1
                & 'l1bData%dpField', options=options%dumpOptions )
d675 1
d677 1
a677 1
                & 'l1bData%dpField', options=options%dumpOptions )
d689 2
a690 2
	 if ( the_hdfVersion == HDFVERSION_5) call h5gClose_f (grpID, status)
    if ( status /= 0 ) then
d762 1
a762 1
    if ( mysdList == ' ' ) then
d783 1
a783 1
    if ( status /= 0 ) then
d788 1
a788 1
    if ( noSds < 1 ) then
d804 1
a804 1
      if ( status /= 0 ) then
d810 1
a810 1
      if ( associated(L1bData%charField) ) then
d813 1
a813 1
      elseif ( associated(L1bData%intField) ) then
d824 2
a825 1
          &  size(L1bData%dpField, 2) > 1 ) .and. SKIPIFRANKTOOHIGH ) then
d837 1
a837 1
    if ( status /= 0 ) then
d858 3
@


1.23
log
@Restored silence to silent option
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.22 2012/04/20 17:57:51 pwagner Exp $"
d717 1
d792 2
a793 2
        if ( size(L1bData%intField, 1) > 1 .or. &
          &  size(L1bData%intField, 2) > 1 ) then
d795 1
a795 1
            & 'Skipping diff of char-valued ' // trim(sdName) )
d801 2
a802 2
        if ( size(L1bData%dpField, 1) > 1 .or. &
          &  size(L1bData%dpField, 2) > 1 ) then
d804 1
a804 1
            & 'Skipping diff of char-valued ' // trim(sdName) )
d835 3
@


1.22
log
@Fixed syntax error of dumpOptions
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.21 2012/02/13 23:41:31 pwagner Exp $"
d665 1
a665 1
      print *, 'After ' // trim(sdName) // ' ', options%numDiffs
d834 3
@


1.21
log
@-opt opts passes opts to underlying dump routines
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.20 2011/05/10 18:28:12 pwagner Exp $"
d80 1
a80 1
    character(len=80) :: options%dumpOptions       = ' '
d834 3
@


1.20
log
@Avoid annoying messages unless verbose
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.19 2010/07/23 17:51:26 pwagner Exp $"
d76 2
a77 1
    character(len=255) :: sdList= '*'  ! what SDs to diff
d80 1
d88 1
a88 1
  character(len=8)   ::          dumpOptions
d133 7
a139 7
  dumpOptions = '-'
  if ( options%rms ) dumpOptions = trim(dumpOptions) // 'r'
  if ( options%stats ) dumpOptions = trim(dumpOptions) // 's'
  if ( options%unique ) dumpOptions = trim(dumpOptions) // 'u'
  if ( options%silent ) dumpOptions = trim(dumpOptions) // 'h'
  if ( options%direct ) dumpOptions = trim(dumpOptions) // 'd'
  if ( options%table ) dumpOptions = trim(dumpOptions) // 'b'
d147 5
a151 1
      call GetAllHDF5DSNames (trim(filenames(i)), '/', mysdList)
d223 4
d265 4
d294 25
a318 23
      write (*,*) '                         (can do the same w/o the -f)'
      write (*,*) '          -d list     => just diff the SDs in list'
      write (*,*) '          -ascii      => diff even character-valued fields'
      write (*,*) '          -l2aux      => the files are l2aux, not l1b'
      write (*,*) '          -v          => switch on verbose mode'
      write (*,*) '          -self       => dump successive differences'
      write (*,*) '                         between values in same file'
      write (*,*) '          -half       => (1) (if with -self) '
      write (*,*) '                         show no. of 1/2 waves'
      write (*,*) '                         (2) (otherwise)'
      write (*,*) '                         diff 1/2 of channels (so DACS wont crash)'
      write (*,*) '          -hdf version=> hdf version (default is 5)'
      write (*,*) '          -silent     => switch on silent mode'
      write (*,*) '                        (printing only if diffs found)'
      write (*,*) '          -unique     => dump only unique elements'
      write (*,*) '          -l          => just list sd names in files'
      write (*,*) '          -maf m1,m2  => just diff in the range [m1,m2]'
      write (*,*) '          -moff offset=> 2nd data set starts after 1st'
      write (*,*) '          -rms        => just print mean, rms'
      write (*,*) '          -s          => just show number of differences'
      write (*,*) '          -skip list  => skip diffing the SDs in list'
      write (*,*) '          -t[able]    => table of % vs. amount of differences (pdf)'
      write (*,*) '          -h          => print brief help'
d409 5
a413 1
      call GetAllHDF5DSNames (trim(File1), '/', mysdList)
d493 1
d595 1
a595 1
          if ( options%verbose ) print *, 'About to do it 1-d ' // dumpOptions, nsize
d597 1
a597 1
            & options=dumpOptions )
d607 2
a608 2
          if ( options%verbose ) print *, 'About to do it 1-d ' // dumpOptions, nsize
          call diff(L1bData, L1bData2, numDiffs=numDiffs, options=dumpOptions, &
d613 2
a614 2
          if ( options%verbose ) print *, 'About to do it direct ' // dumpOptions
          call diff(L1bData, L1bData2, numDiffs=numDiffs, options=dumpOptions )
d618 1
a618 1
            & numDiffs=numDiffs, options=dumpOptions )
d634 1
a634 1
                & options=dumpOptions )
d640 1
a640 1
                & options=dumpOptions )
d651 1
a651 1
                & 'l1bData%dpField', options=dumpOptions )
d655 1
a655 1
                & 'l1bData%dpField', options=dumpOptions )
d797 1
a797 1
            & waves=options%halfWaves, options=dumpOptions )
d806 1
a806 1
            & waves=options%halfWaves, options=dumpOptions )
d834 3
@


1.19
log
@Now able to diff hdf4-formatted files
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.18 2009/11/20 23:00:50 pwagner Exp $"
d555 5
a559 2
        ! if ( options%verbose ) print *, 'About to diff'
        if ( .not. options%silent ) print *, 'About to diff ', trim(sdName)
d574 1
a574 1
          if ( .not. options%silent ) print *, 'About to do it 1-d ' // dumpOptions, nsize
d586 1
a586 1
          print *, 'About to do it 1-d ' // dumpOptions, nsize
d592 1
a592 1
          if ( .not. options%silent ) print *, 'About to do it direct ' // dumpOptions
d813 3
@


1.18
log
@Should not segfault when diffing DACS datasets
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.17 2009/11/02 19:54:06 pwagner Exp $"
d71 1
d110 1
a110 1
     if ( .not. is_hdf5 ) then
d151 1
a151 1
      call mySelfDiff(trim(filenames(i)), HDFVERSION_5, options)
d159 1
a159 1
      & HDFVERSION_5, options)
d212 5
d291 1
d337 2
d358 1
d360 1
d364 1
d369 4
d376 1
a376 1
    the_hdfVersion = HDFVERSION_5
d391 19
a409 17
    call GetAllHDF5DSNames (trim(File1), '/', mysdList)
    if ( options%verbose) then
      call output ( '============ DS names in ', advance='no' )
      call output ( trim(file1) //' ============', advance='yes' )
    endif
    if ( mysdList == ' ' ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'No way yet to find sdList in ' // trim(File1) )
      return
    else
      if ( options%verbose ) call dump(mysdList, 'DS names')
    endif
    if ( options%sdList /= '*' ) then
      call output( ' Selected SDs to diff', advance='yes' )
      mySDList = options%sdList
      call dump(mysdList, 'DS names')
    endif
d411 8
a418 26
    isl1boa = (index(trim(mysdList), '/GHz') > 0)
    file_access = DFACC_READ
    sdfid1 = mls_sfstart(File1, DFACC_READ, hdfVersion=hdfVersion)
    if (sdfid1 == -1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  'Failed to open l1b file ' // trim(File1) )
    end if
	 call h5gOpen_f (sdfid1,'/', grpID, status)
    if ( status /= 0 ) then
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to open group to read attribute in l2aux file' )
    endif
    sdfId2 = mls_sfstart(trim(file2), file_access, &
              & hdfVersion=hdfVersion)
    if (sdfid2 == -1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Failed to open l1b ' // trim(File2) )
    end if
    noSds = NumStringElements(trim(mysdList), countEmpty)
    if ( noSds < 1 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'No sdNames cp to file--unable to count sdNames in ' // trim(mysdList) )
    endif
    ! May need to create groups '/sc', '/GHz', and '/THz'
    if ( isL1boa .and. file_access == DFACC_CREATE ) then
      call h5gcreate_f(sdfId2, '/sc', grpID, status)
d421 1
a421 1
          	& 'Unable to create group /sc in ' // trim(File2) )
d423 10
a432 4
      call h5gcreate_f(sdfId2, '/GHz', grpID, status)
      if ( status /= 0 ) then
	     call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to create group /GHz in ' // trim(File2) )
d434 17
a450 4
      call h5gcreate_f(sdfId2, '/THz', grpID, status)
      if ( status /= 0 ) then
	     call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to create group /THz in ' // trim(File2) )
d452 10
d471 7
a477 1
      call GetStringElement (trim(mysdList), sdName, i, countEmpty )
d641 1
a641 1
      ! print *, 'After ' // trim(sdName) // ' ', options%numDiffs
d643 1
a643 1
	 call h5gClose_f (grpID, status)
d648 14
a661 8
	 status = mls_sfend(sdfid1, hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2aux file: " // trim(File1) // ' after diffing')
	 status = mls_sfend(sdfid2, hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2aux file: " // trim(File2) // ' after diffing')
d695 1
a695 1
    the_hdfVersion = HDFVERSION_5
d810 3
@


1.17
log
@Fixed bug causing goldbrick to print excessively
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.16 2009/10/30 23:06:34 pwagner Exp $"
d68 1
a68 1
    logical     :: oneD = .false.
d537 3
a539 2
          call dump( L1bData%dpField-L1bData2%dpField, 'L1bData%dpField diff' )
          stop
d548 1
d769 3
@


1.16
log
@Last change let executable land on bare stop; must fix oneD yet
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.15 2009/09/11 23:24:01 pwagner Exp $"
d358 1
d536 1
a536 1
          print *, 'About to do it 1-d ' // dumpOptions, nsize
d552 1
a552 1
          print *, 'About to do it direct ' // dumpOptions
d604 1
d767 3
@


1.15
log
@options now include -t to be consistent with diff apis
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.14 2009/08/18 20:43:23 pwagner Exp $"
d61 1
d68 1
a68 1
    logical     :: oneD = .true.
d448 1
a448 1
        if ( options%verbose ) print *, 'About to read ', trim(sdName)
d452 2
a453 2
          call outputNamedValue( 'NoMAFs', noMAFs )
          call outputNamedValue( 'status', status )
d482 1
a482 1
        call SayTime( 'Reading l1bdata 1', stime )
d484 2
a485 2
        if (associated(L1BData%dpField) ) &
          & call outputnamedValue('shape(l1bdata)', shape(L1BData%dpField) )
d504 1
a504 1
        call SayTime( 'Reading l1bdata 2', stime )
d506 2
a507 2
        if (associated(L1BData2%dpField) ) &
          & call outputnamedValue('shape(l1bdata2)', shape(L1BData2%dpField) )
d544 1
a544 1
          call SayTime( 'Copying values to 1-d arrays', stime )
d600 1
a600 1
        call SayTime( 'Doing the diff', stime )
d765 3
@


1.14
log
@Changes needed to diff DACS radiance files
@
text
@d16 2
a17 2
   use Allocate_Deallocate, only: Allocate_test, DeAllocate_test
   use Dump_0, only: DIFFRMSMEANSRMS, rmsFormat, DIFF, DUMP, SELFDIFF
d19 2
a20 2
   use HDF5, only: h5fis_hdf5_f, &
     & H5GCLOSE_F, H5GOPEN_F, H5DOPEN_F, H5DCLOSE_F, h5gcreate_f
d22 1
a22 1
     & contractL1BData, DeallocateL1BData, Diff, ReadL1BData
d25 1
a25 1
     & mls_exists, mls_hdf_version, mls_sfstart, mls_sfend, &
d27 1
a27 2
   use MLSHDF5, only: GetAllHDF5DSNames, saveAsHDF5DS, &
     & IsHDF5AttributePresent, mls_h5open, mls_h5close
d29 6
a34 6
   use MLSMessageModule, only: MLSMessageConfig, MLSMSG_Error, MLSMSG_Warning, &
     & MLSMessage
   use MLSStringLists, only: GetStringElement, NumStringElements
   use MLSStrings, only: WriteIntsToChars
   use output_m, only: resumeOutput, suspendOutput, output, outputNamedValue
   use Time_M, only: Time_Now, time_config
d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.13 2009/08/04 20:45:12 pwagner Exp $"
d65 1
d135 1
d237 3
d272 23
a294 20
      write (*,*) ' Options: -f filename     => add filename to list of filenames'
      write (*,*) '                           (can do the same w/o the -f)'
      write (*,*) '          -d list         => just diff the SDs in list'
      write (*,*) '          -ascii          => diff even character-valued fields'
      write (*,*) '          -l2aux          => the files are l2aux, not l1b'
      write (*,*) '          -v              => switch on verbose mode'
      write (*,*) '          -self           => dump successive differences'
      write (*,*) '                             between values in same file'
      write (*,*) '          -half           => (if -self) show no. of 1/2 waves'
      write (*,*) '          -half           => diff 1/2 of channels (so DACS wont crash)'
      write (*,*) '          -silent         => switch on silent mode'
      write (*,*) '                            (printing only if diffs found)'
      write (*,*) '          -unique         => dump only unique elements'
      write (*,*) '          -l              => just list sd names in files'
      write (*,*) '          -maf m1,m2      => just diff in the range [m1,m2]'
      write (*,*) '          -moff offset    => 2nd data set starts after 1st'
      write (*,*) '          -rms            => just print mean, rms'
      write (*,*) '          -s              => just show statistics'
      write (*,*) '          -skip list      => skip diffing the SDs in list'
      write (*,*) '          -h              => print brief help'
d764 3
@


1.13
log
@silent option adds 'h' to options arg
@
text
@d16 1
d22 1
a22 1
     & DeallocateL1BData, Diff, ReadL1BData
a23 1
   use MLSCommon, only: R8
d29 1
d43 1
a43 1
       "$Id: l1bdiff.f90,v 1.12 2009/06/16 22:37:40 pwagner Exp $"
d66 2
a67 1
    logical     :: direct = .false.
d134 1
d276 2
a277 1
      write (*,*) '          -half           => show no. of 1/2 waves'
d324 1
d327 1
d331 5
d337 1
d340 1
d345 1
d350 1
d425 5
d438 35
a472 9
      ! Allocate and fill l2aux
      ! if ( options%verbose ) print *, 'About to read ', trim(sdName)
        call ReadL1BData ( sdfid1, trim(sdName), L1bData, NoMAFs, status, &
          & hdfVersion=the_hdfVersion, NEVERFAIL=.true., l2aux=options%l2aux )
        if ( status /= 0 ) then
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to find ' // trim(sdName) // ' in ' // trim(File1) )
          call DeallocateL1BData ( l1bData )
          cycle
d474 21
a494 9
      ! if ( options%verbose ) print *, 'About to read ', trim(sdName), ' (2nd)'
        call ReadL1BData ( sdfid2, trim(sdName), L1bData2, NoMAFs, status, &
          & hdfVersion=the_hdfVersion, NEVERFAIL=.true., l2aux=options%l2aux )
        if ( status /= 0 ) then
	       call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to find ' // trim(sdName) // ' in ' // trim(File1) )
          call DeallocateL1BData ( l1bData )
          call DeallocateL1BData ( l1bData2 )
          cycle
d496 4
d502 1
a502 1
          	& 'Skipping diff of char-valued ' // trim(sdName) )
d513 31
a543 2
        if ( options%direct .or. .not. associated(L1bData%dpField) ) then
          ! print *, 'About to do it direct'
d550 1
a550 1
          
a553 9
!             call outputNamedValue( 'maf1', maf1 )
!             call outputNamedValue( 'maf2', maf2 )
!             call outputNamedValue( 'options%moff', options%moff )
!             print *, shape(L1bData%dpField(:,:,maf1:maf2))
!             print *, shape(L1bData2%dpField(:,:,maf1+options%moff:maf2+options%moff))
!             print *, L1bData%dpField(1,1,maf1)
!             print *, L1bData%dpField(1,1,maf2)
!             print *, L1bData2%dpField(1,1,maf1+options%moff)
!             print *, L1bData2%dpField(1,1,maf2+options%moff)
d592 4
a595 1
    enddo
d757 3
@


1.12
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.11 2008/07/10 00:14:43 pwagner Exp $"
d131 1
d672 3
@


1.11
log
@Added -self, -half, -unique options
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.10 2008/04/10 20:22:37 pwagner Exp $"
d77 1
a77 3
  type ( options_T ) :: options


d81 3
a83 2
  logical ::          columnsOnly
  character(len=255) :: filename          ! input filename
d85 3
a87 4
  integer            :: n_filenames
  integer     ::  i, status, error ! Counting indices & Error flags
  logical     :: is_hdf5
  integer :: maf1, maf2
d89 5
a93 4
  character(len=16) :: string
  real        :: t1
  real        :: t2
  real        :: tFile
d127 4
d452 1
a452 3
          call diff(L1bData, L1bData2, &
            & stats=options%stats, rms=options%rms, &
            & silent=options%silent, numDiffs=numDiffs )
d456 1
a456 2
            & stats=options%stats, rms=options%rms, &
            & silent=options%silent, numDiffs=numDiffs )
d481 1
a481 1
                & stats=options%stats, rms=options%rms )
d487 1
a487 1
                & stats=options%stats, rms=options%rms )
d498 1
a498 2
                & 'l1bData%dpField', &
                & stats=options%stats, rms=options%rms, unique=options%unique )
d502 1
a502 2
                & 'l1bData%dpField', &
                & stats=options%stats, rms=options%rms, unique=options%unique )
d634 1
a634 2
            & stats=options%stats, rms=options%rms, unique=options%unique, &
            & waves=options%halfWaves )
d643 1
a643 2
            & stats=options%stats, rms=options%rms, unique=options%unique, &
            & waves=options%halfWaves )
d671 3
@


1.10
log
@Less voluminous output
@
text
@d16 1
a16 1
   use Dump_0, only: DIFFRMSMEANSRMS, rmsFormat, DIFF, DUMP
d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.9 2008/02/28 01:34:07 pwagner Exp $"
d56 2
d60 1
d120 2
d137 6
d199 6
d208 3
d267 3
d272 1
d499 1
a499 1
                & stats=options%stats, rms=options%rms )
d504 1
a504 1
                & stats=options%stats, rms=options%rms )
d527 137
d675 3
@


1.9
log
@Normally should skip diffing character-valued fields
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.8 2007/11/28 19:35:21 pwagner Exp $"
d57 1
d69 2
d100 1
a100 1
     call get_filename(filename, n_filenames, options)
d139 1
a139 1
      call sayTime('diffing this file', tFile)
d142 1
a142 1
  if ( .not. options%list) call sayTime('diffing all files')
d151 3
a153 3
!------------------------- get_filename ---------------------
    subroutine get_filename(filename, n_filenames, options)
    ! Added for command-line processing
d156 1
a156 1
     type ( options_T ), intent(inout) :: options
d180 4
d209 4
d233 1
a233 1
  end subroutine get_filename
d243 1
d254 1
d274 1
a274 1
  subroutine myDiff(file1, file2, create2, hdfVersion, options)
d335 5
d388 2
a389 1
        &  sdName == 'l2cf' ) cycle
d451 1
a451 1
            else
d458 6
d514 3
@


1.8
log
@May specify that files are l2aux
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.7 2007/07/18 00:15:25 pwagner Exp $"
d63 1
d187 3
d232 1
d391 7
d428 12
a439 5
            call diff( L1bData%dpField(:,:,maf1:maf2), &
              & '(1)', &
              & L1bData2%dpField(:,:,maf1+options%moff:maf2+options%moff), &
              & '(2)', &
              & stats=options%stats, rms=options%rms )
d441 1
d444 2
d489 3
@


1.7
log
@-rms outputs fractional diffs more clearly
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.6 2006/11/22 18:33:10 pwagner Exp $"
d62 1
d186 3
d228 1
a228 1
      ! write (*,*) '          -r reffile      => compare sds to reffile'
d360 1
d363 3
a365 1
      ! if ( sdName /= 'R1A:118.B32W:PT.S0.WF4-1' ) cycle
d369 1
a369 1
          & hdfVersion=the_hdfVersion, NEVERFAIL=.true. )
d378 1
a378 1
          & hdfVersion=the_hdfVersion, NEVERFAIL=.true. )
d467 3
@


1.6
log
@New optional args to diff l1b files with different number MAFs
@
text
@d16 1
a16 1
   use Dump_0, only: DUMP
d33 1
a33 1
   use output_m, only: resumeOutput, suspendOutput, output
d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.5 2006/06/14 16:42:38 pwagner Exp $"
d81 1
d91 1
d116 1
d360 1
a360 1
      if ( options%verbose ) print *, 'About to read ', trim(sdName)
d379 6
a384 1
      ! if ( options%verbose ) print *, 'About to diff'
d395 1
d398 15
a412 6
          L1bData%dpField = L1bData%dpField - L1bData2%dpField(:,:,1+options%moff:)
          if ( options%silent ) then
          elseif ( options%maf1 /= 0 .and. options%maf2 /= 0 ) then
            ! print *, shape( L1bData%dpField(:,:,options%maf1:options%maf2) )
            call dump( L1bData%dpField(:,:,options%maf1:options%maf2), &
              & 'l1bData%dpField', &
d415 13
a427 4
            ! print *, shape( L1bData%dpField )
            call dump( L1bData%dpField, &
              & 'l1bData%dpField', &
              & stats=options%stats, rms=options%rms )
d460 3
@


1.5
log
@Should not run out of memory unless direct reset to TRUE
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.4 2006/01/14 00:58:31 pwagner Exp $"
d62 3
d72 1
a72 1
  integer, parameter ::          MAXDS = 50
d162 10
d226 2
d355 1
d378 1
d383 1
d387 1
d389 13
a401 4
          L1bData%dpField = L1bData%dpField - L1bData2%dpField
          if ( .not. options%silent ) call dump( L1bData%dpField, &
            & 'l1bData%dpField', &
            & stats=options%stats, rms=options%rms )
d433 3
@


1.4
log
@Added -silent option
@
text
@d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.3 2005/10/29 00:13:56 pwagner Exp $"
d61 1
d76 1
a76 1
  integer     ::  i, count, status, error ! Counting indices & Error flags
d347 1
d350 1
d357 1
d360 15
a374 3
        call diff(L1bData, L1bData2, &
          & stats=options%stats, rms=options%rms, &
          & silent=options%silent, numDiffs=numDiffs )
d405 3
@


1.3
log
@Removed unused procedures from use statements
@
text
@d32 2
a33 1
   use output_m, only: output
d42 1
a42 1
       "$Id: l1bdiff.f90,v 1.2 2005/09/23 21:01:13 pwagner Exp $"
d56 1
d61 1
d78 1
d103 3
d110 1
d112 1
a112 1
  if ( options%verbose .and. .not. options%list) &
d131 6
d162 3
d209 2
d243 3
a245 3
    logical, intent(in) :: create2
    integer, intent(in) :: hdfVersion
    type ( options_T ), intent(in) :: options
d248 1
a248 5
    integer :: sdfid1
    integer :: sdfid2
    integer :: grpid
    integer :: status
    integer :: the_hdfVersion
d251 2
a252 3
    integer :: noSds
    character (len=MAXSDNAMESBUFSIZE) :: mySdList
    logical, parameter            :: countEmpty = .true.
a253 1
    ! type (L2AUXData_T) :: l2aux
d256 1
a256 1
    integer :: i
d258 4
d263 2
d356 3
a358 1
        call diff(L1bData, L1bData2, stats=options%stats, rms=options%rms)
d361 1
d378 6
d389 3
@


1.2
log
@use_wall_clock now a component of time_config
@
text
@a25 1
     & MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
d41 1
a41 1
       "$Id: l1bdiff.f90,v 1.1 2005/06/22 19:27:32 pwagner Exp $"
d361 3
@


1.1
log
@Reworded Copyright statement, moved rcs id
@
text
@d34 1
a34 1
   use Time_M, only: Time_Now, USE_WALL_CLOCK
d40 1
a40 1
       "$RCSfile: MLSL2.f90,v $"
d42 1
a42 1
       "$Id: MLSL2.f90,v 2.138 2005/06/22 18:57:02 pwagner Exp $"
d82 1
a82 1
  USE_WALL_CLOCK = .true.
d361 4
a364 1
! $Log: mangleL1BData.f90,v $
@

