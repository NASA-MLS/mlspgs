head	1.5;
access;
symbols
	v5-02-NRT-19:1.5
	v6-00:1.5
	v5-02-NRT-18:1.5
	v5-02:1.5
	v5-01-NRT-17:1.5
	v5-01-NRT-16:1.5
	v5-01-NRT-15:1.5
	v5-01-NRT-14:1.5
	neuralnetworks-1-0:1.5.0.14
	cfm-single-freq-0-1:1.5.0.12
	v5-01:1.5
	v5-00:1.5
	v4-23-TA133:1.5.0.10
	mus-emls-1-70:1.5.0.8
	rel-1-0-englocks-work:1.5.0.6
	VUMLS1-00:1.5
	VPL1-00:1.5
	V4-22-NRT-08:1.5
	VAM1-00:1.5
	V4-21:1.5.0.4
	V4-13:1.5
	V4-12:1.5
	V4-11:1.5
	V4-10:1.5
	V3-43:1.5
	M4-00:1.5
	V3-41:1.5
	V3-40-PlusGM57:1.5.0.2
	V2-24-NRT-04:1.5
	V3-33:1.5
	V2-24:1.5
	V3-31:1.5
	V3-30-NRT-05:1.5
	cfm-01-00:1.5
	V3-30:1.5
	V3-20:1.5
	V3-10:1.5
	V2-23-NRT-02:1.5
	V2-23:1.5
	V2-22-NRT-01:1.5
	V2-22:1.5
	V2-21:1.5
	V2-20:1.5
	V2-11:1.5
	V2-10:1.5
	V2-00:1.5
	V1-51:1.4
	V1-50:1.4
	V1-45:1.3
	V1-44:1.3
	V1-43:1.1;
locks; strict;
comment	@# @;


1.5
date	2005.06.23.22.20.45;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.03.19.09.33;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.28.00.15.25;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.13.21.23.22;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.13.22.51.58;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Reworded Copyright statement
@
text
@#!/bin/sh
#chunktimes.sh

# --------------- chunktimes.sh help
#Creates a table of chunk timings similar to the following
#chunk phase_1 phase_2 ..
#99 788.45 1288.13
#276 656.02 1326.15
#10 637.48 1267.51
#100 604.73 1393.60
#    .   .   .
#Usage:
#chunktimes.sh [opt1] [opt2] ..  mlsl2.log
#where mlsl2.log is the catenation of all the chunks' logs from a run
#
#    O p t i o n s
# -head list    creates table headed by comma-separated list of phases
#                 e.g., -head "core,corumba,corcorvado,papaya"
# -r            reverse sense of sort
# -sort k       where k is a number: sort by column k
#                 k=1: by chunk; k=2: by 1st phase; k=n: by (n-1)st phase
# -sortf        sort by the final column, usu. the total timing figure
# -s2h          convert timings from seconds to hours
# -h2s          convert timings from hours to seconds
# -node         include node numbers on each line
# -perl program  
#               use program instead of perl to run chunktimes.pl
# -h[elp]       print brief help message; exit
#
#Note:
#The option(s) marked with "-", if present,
#must precede the file mlsl2.log on the command line
# --------------- End chunktimes.sh help
# Bugs and limitations
#(1) See chunktimes.pl
#(2) If sorting, must have write access to cwd
# Copyright 2005, by the California Institute of Technology. ALL
# RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
# commercial use must be negotiated with the Office of Technology Transfer
# at the California Institute of Technology.

# This software may be subject to U.S. export control laws. By accepting this
# software, the user agrees to comply with all applicable U.S. export laws and
# regulations. User has the responsibility to obtain export licenses, or other
# export authority as may be required before exporting such information to
# foreign countries or providing access to foreign persons.

# "$Id: chunktimes.sh,v 1.4 2004/11/03 19:09:33 pwagner Exp $"

#
#---------------------------- get_unique_name
#
# Function returns a unique name based on arg, PID and HOSTNAME
# e.g.,
#           temp_file_name=`get_unique_name foo`
#           echo $temp_file_name
# might print foo.colossus.21455
# if no arg, defaults to "temp" (very original name)
# if two args present, assumes second is punctuation to
# use in pace of "."

get_unique_name()
{

   # How many args?
      if [ $# -gt 1 ]
      then
        pt="$2"
        temp="$1"
      elif [ $# -gt 0 ]
      then
        pt="."
        temp="$1"
      else
        pt="."
        temp="temp"
      fi
   # Is $HOST defined?
      if [ "$HOST" != "" ]
      then
         our_host_name="$HOST"
      elif [ "$HOSTNAME" != "" ]
      then
         our_host_name="$HOSTNAME"
      else
         our_host_name="host"
      fi
    #  echo $our_host_name
   # if in form host.moon.planet.star.. extract host
      our_host_name=`echo $our_host_name | sed 's/\./,/g'`
      our_host_name=`perl -e '@@parts=split(",","$ARGV[0]"); print $parts[0]' $our_host_name`
      echo $temp${pt}$our_host_name${pt}$$
}
      
#------------------------------- Main Program ------------

#****************************************************************
#                                                               *
#                  * * * Main Program  * * *                    *
#                                                               *
#                                                               *
#	The entry point where control is given to the script         *
#****************************************************************
#
USEHOMEFORTEMPS=1
#               ^  -- set this to 1 if may run in foreign directories
PRINT_TOO_MUCH=0
#              ^  -- set this to 1 if willing to try patience of users
me="$0"
my_name=chunktimes.sh
I=chunktimes
PERL=perl
# $reecho is reecho with me's path prepended
reecho="`echo $0 | sed 's/'$I'/reecho/'`"
# $the_perl_script is me but 'sh' -> 'pl'
the_perl_script="`echo $0 | sed 's/'$my_name'/chunktimes.pl/'`"
list=""
reverse="no"
nodeToo="no"
sort="no"
s_column="0"
convert=""
more_opts="yes"
while [ "$more_opts" = "yes" ] ; do

    case "$1" in

    -h2s )
	    shift
       convert="-h2s"
       ;;
    -head )
	    list="$2"
       shift
	    shift
       ;;
    -perl )
       PERL="$2"
       shift
	    shift
       ;;
    -r )
	    shift
       reverse="yes"
       ;;
    -s2h )
	    shift
       convert="-s2h"
       ;;
    -sort )
	    s_column=`expr "$2" - 1`
       shift
	    shift
       sort="yes"
       ;;
    -sortf )
	    s_column="final"
	    shift
       sort="yes"
       ;;
    -node )
	    shift
       nodeToo="yes"
       ;;
    -h | -help )
       sed -n '/'$my_name' help/,/End '$my_name' help/ p' $me \
           | sed -n 's/^.//p' | sed '1 d; $ d'
       exit
	     ;;

    -* )
	    k_column=`expr 0 - $2`
       shift
	    shift
       ;;
    * )
       more_opts="no"
       ;;
    esac
done

if [ "$list" != "" ]
then
  extra_args="-head $list $1"
else
  extra_args="$1"
fi
if [ "$convert" != "" ]
then
  extra_args="$convert $extra_args"
fi
if [ "$nodeToo" != "no" ]
then
  extra_args="-node $extra_args"
fi
if [ "$USEHOMEFORTEMPS" = "1" ]
then
  temp_file1=$HOME/`get_unique_name ct1`
  temp_file2=$HOME/`get_unique_name ct2`
else
  temp_file1=`get_unique_name ct1`
  temp_file2=`get_unique_name ct2`
fi
if [ $PRINT_TOO_MUCH = "1" ]                            
then                                                    
   echo " Summary of options to $me "  
   echo " sort?: $sort "  
   echo " sort column: $s_column "  
   echo " column number: $k_column "  
   echo " list of phases: $list "  
   echo " temp_file1: $temp_file1 "  
   echo " temp_file2: $temp_file2 "  
   echo " extra args: $extra_args "  
   echo " perl script: $the_perl_script "  
fi                                                      
rm -f $temp_file1 $temp_file2
if [ "$sort" = "no" ]
then
  # echo $PERL $the_perl_script $extra_args
  $PERL $the_perl_script $extra_args > $temp_file1
  # $PERL $the_perl_script $extra_args | head
else
  $PERL $the_perl_script -headonly $extra_args > $temp_file1
  $PERL $the_perl_script -nohead $extra_args > $temp_file2
  if [ "$s_column" = "final" ]
  then
    s_column=`cat $temp_file1 | wc -w`
    s_column=`expr $s_column - 1`
    if [ "$nodeToo" = "yes" ]
    then
      s_column=`expr $s_column - 1`
    fi
  fi
  if [ $PRINT_TOO_MUCH = "1" ]                          
  then                                                  
     echo " New sort column: $s_column "
     echo "sort -r -n +$s_column $temp_file2 "
  fi
  if [ "$reverse" = "yes" ]
  then
    sort -r -n +$s_column $temp_file2 >> $temp_file1
  else
    sort -n +$s_column $temp_file2 >> $temp_file1
  fi
fi
cat $temp_file1
# head $temp_file1
rm -f $temp_file1 $temp_file2
exit
# $Log: chunktimes.sh,v $
# Revision 1.4  2004/11/03 19:09:33  pwagner
# perl scripts now get launched via perl rather than as stand-alone executables
#
# Revision 1.3  2004/07/28 00:15:25  pwagner
# Added -node option
#
# Revision 1.2  2004/07/13 21:23:22  pwagner
# Fixed bugs; added -s2h and -h2s options
#
# Revision 1.1  2004/05/13 22:51:58  pwagner
# First commit
#
@


1.4
log
@perl scripts now get launched via perl rather than as stand-alone executables
@
text
@d37 10
a46 2
# Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
# U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d48 1
a48 1
# "$Id: chunktimes.sh,v 1.3 2004/07/28 00:15:25 pwagner Exp $"
d251 3
@


1.3
log
@Added -node option
@
text
@d26 2
d40 1
a40 1
# "$Id: chunktimes.sh,v 1.2 2004/07/13 21:23:22 pwagner Exp $"
d104 1
d129 5
d211 3
a213 3
  # echo $the_perl_script $extra_args
  $the_perl_script $extra_args > $temp_file1
  # $the_perl_script $extra_args | head
d215 2
a216 2
  $the_perl_script -headonly $extra_args > $temp_file1
  $the_perl_script -nohead $extra_args > $temp_file2
d243 3
@


1.2
log
@Fixed bugs; added -s2h and -h2s options
@
text
@d25 1
d38 1
a38 1
# "$Id: chunktimes.sh,v 1.1 2004/05/13 22:51:58 pwagner Exp $"
d95 2
d108 1
d145 4
d176 12
a187 2
temp_file1=`get_unique_name ct1`
temp_file2=`get_unique_name ct2`
d213 4
d235 3
@


1.1
log
@First commit
@
text
@d22 3
d37 1
a37 1
# "$Id: chunktimes.sh,v 1.24 2004/03/18 17:56:49 pwagner Exp $"
a83 26
#------------------------------- extant_files ------------
#
# Function to return only those files among the args
# that actually exist
# Useful when passed something like *.f which may 
# (1) expand to list of files, returned as extant_files_result, or
# (2) stay *.f, in which case a blank is returned as extant_files_result 
#     (unless you have perversely named a file '*.f')
# usage: extant_files arg1 [arg2] ..

extant_files()
{
   extant_files_result=
   # Trivial case ($# = 0)
   if [ "$1" != "" ]
   then
      for file
      do
         if [ -f "$file" ]
         then
               extant_files_result="$extant_files_result $file"
         fi
      done
   fi
}

d107 1
d113 4
d126 4
d131 1
a131 1
	    s_column="$2"
d136 5
d164 4
a187 5
elif [ "$reverse" = "yes" ]
then
  $the_perl_script -headonly $extra_args > $temp_file1
  $the_perl_script -nohead $extra_args > $temp_file2
  sort -r +$s_column $temp_file2 >> $temp_file1
d191 16
a206 1
  sort +$s_column $temp_file2 >> $temp_file1
d213 3
@

