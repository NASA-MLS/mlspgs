head	1.18;
access;
symbols
	v5-02-NRT-19:1.18
	v6-00:1.18
	v5-02-NRT-18:1.18
	v5-02:1.18
	v5-01-NRT-17:1.18
	v5-01-NRT-16:1.18
	v5-01-NRT-15:1.18
	v5-01-NRT-14:1.18
	neuralnetworks-1-0:1.18.0.10
	cfm-single-freq-0-1:1.18.0.8
	v5-01:1.18
	v5-00:1.18
	v4-23-TA133:1.18.0.6
	mus-emls-1-70:1.18.0.4
	rel-1-0-englocks-work:1.18.0.2
	VUMLS1-00:1.17
	VPL1-00:1.17
	V4-22-NRT-08:1.17
	VAM1-00:1.17
	V4-21:1.17.0.4
	V4-13:1.17
	V4-12:1.17
	V4-11:1.17
	V4-10:1.17
	V3-43:1.17
	M4-00:1.17
	V3-41:1.17
	V3-40-PlusGM57:1.17.0.2
	V2-24-NRT-04:1.16
	V3-33:1.17
	V2-24:1.16
	V3-31:1.17
	V3-30-NRT-05:1.17
	cfm-01-00:1.17
	V3-30:1.17
	V3-20:1.17
	V3-10:1.16
	V2-23-NRT-02:1.16
	V2-23:1.16
	V2-22-NRT-01:1.16
	V2-22:1.16
	V2-21:1.14
	V2-20:1.14
	V2-11:1.14
	V2-10:1.14
	V2-00:1.14
	V1-51:1.13
	V1-50:1.13
	V1-45:1.12
	V1-44:1.12
	V1-43:1.12
	V1-42:1.11
	V1-41:1.11
	V1-32:1.11
	V1-40:1.11
	V1-31:1.11
	V1-30:1.10
	V1-13:1.10
	V1-12:1.10
	V1-11:1.10
	V1-10:1.10
	newfwm-feb03:1.10.0.2
	V1-04:1.3
	V1-03:1.3
	V1-02:1.3
	V1-00:1.2
	newfwm-sep01:1.2.0.2
	V0-7:1.2
	V0-5-Level2:1.2
	V0-5-SIPS:1.2;
locks; strict;
comment	@# @;


1.18
date	2017.10.20.20.06.27;	author pwagner;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.05.01.52.43;	author pwagner;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.08.23.08.41;	author vsnyder;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.06.21.30.10;	author pwagner;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.23.22.22.46;	author pwagner;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.03.19.09.33;	author pwagner;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.18.17.58.09;	author pwagner;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.24.19.18.42;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.18.17.58.49;	author pwagner;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.01.20.51.22;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.01.17.27.08;	author pwagner;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.24.20.35.34;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.04.17.04.06;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.29.22.19.49;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.22.00.37.26;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.09.19.39.36;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.02.23.22.38;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.27.23.21.26;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Eliminate some deprecated defined
@
text
@# Usage: f90makedep.pl
#
# It has become a multipurpose tool, exploiting some of perl's
# text-handling prowess. In its main usage,
# generate a Makefile-ready dependency listing from the f90 sources 
# in the current directory. If there are any command line arguments,
# and   $ARG_DEPENDS   is set (which see)
# they will be interpreted as additional directories in which to
# find dependencies. In particular, if when a source file USEs a
# module, the file containing that USEd module will be printed among
# the list of dependencies if it is found in the current directory or
# else found among the directories named in the command line. If it is not
# found among any of these, it will be excluded from the dependencies.
# In addition, if  $SELF_DEPENDS  is set (which see) the source file
# will itself be included among the list of dependencies
#
# Main Usage:
# 	(1) f90makedep.pl [arg1 arg2 ..]
# Output:
# (printed to stdout)
# source1.o: source1.f90 source2.o .. $(d1)s1.o $(d1)s2.o .. $(d2)t1.o ..
# source2.o: source2.f90 source3.o .. $(d1)s1.o $(d1)s2.o .. $(d2)t1.o ..
# source3.o: source3.f90 .. $(d1)s1.o $(d1)s2.o .. $(d2)t1.o ..
# ...
# where the contents of the current directory (cwd), arg1, arg2 are
#    cwd         arg1       arg2
# source1.f90   s1.f90     t1.f90
# source2.f90   s2.f90     t2.f90
# source3.f90   s3.f90     t3.f90
#
# The theory behind the $(d1), $(d2) stuff is that you will define them
# with lines like 
# d1 = ../up_one/elsewhere/ 
# and similarly for d2 in the same Makefile where you plan to paste the output
#
# 	Variant (1)-mod: f90makedep.pl -mod case [arg1 arg2 ..]
#   where case is one of {U[PPER], l[ower]}
# Output:
# (printed to stdout)
# source1.mod Source1.o: Source1.f90 source2.mod .. $(d1)s1.mod \
#             $(d1)s2.mod .. $(d2)t1.mod ..
#     $(UTILDIR)/newAifBdiff.sh -a source1.mod \
#        $(FC) -c $(FOPTS) $(INC_PATHS) $(S)/Source1.f90
#   where we have shown the lower case. Note that the stem name preceding
# the .mod suffix is the module name, which may differ from the file name
# Also note the build command which comes below each target in this variant
# The build command is built out of parts $BUILD_PART(1 2)
#
# -----------------------------------------------------------------------
# Alternate Usages:
# 	(2) f90makedep.pl -s pattern1 -o pattern2
# Output:
# (printed to stdout) (assume that pattern1 is "tex" and pattern2 is "dvi"
# source1.dvi: source1.tex source2.tex .. $(d1)s1.tex $(d1)s2.tex .. $(d2)t1.tex ..
# source2.dvi: source2.tex .. $(d1)s1.tex $(d1)s2.tex .. $(d2)t1.tex ..
# ...
# (currently this alternative only works for m4 files;
#  a clever programmer could fix it to work for tex, too)
# (also, this usage ignores any subsequent command line args: thus
#   no additional directories)
#
# 	(3) f90makedep.pl -p very_long_line -d delimiter -t term_char
# Output: splits the very_long_line into 72-column long lines
# (printed to stdout)
#  
# 	(4) f90makedep.pl -f file_name -d delimiter -t term_char -c comment_char
#      reads each line of file_name
# Output: splits any of its long lines into 72-column long lines
# (except for comments)
# (printed to stdout)
#  
# -----------------------------------------------------------------------
#      Options
# -s pattern        suffix to be matched by source files
# -o pattern        suffix to be matched by object files
# -p text           text to be split among several lines; Usage (3)
# -d char           delimiter between words of text
# -t char           line termination at split
# -f file_name      file containing text to be split; Usage (4)
# -db file_name     don't add build commands below target file_name
#                    if "(1)-mod" variant
# -c char           comment character
# -mod case         use variant "(1)-mod" of dependency lines
#                    with module names all in case (UPPER, lower)
# -S file           calculate dependencies just for file
# -i regexp         regexp used to catch include dependencies; e.g.
#                    '\!include\(([^)]+)' catches "include('file.txt')"
#                    '\\input\{([^)]+)}'  catches "\input{cfm-reference.tex}"
#                    '\\includegraphics\[width=3in\]\{([^}]+)'  catches "\includegraphics[width=3in]{wvs-143-1}"
# -extra ext        add ".ext" to files caught by regexp
#
# P.A. Wagner (May 15 2002)
# Copyright 2005, by the California Institute of Technology. ALL
# RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
# commercial use must be negotiated with the Office of Technology Transfer
# at the California Institute of Technology.

# This software may be subject to U.S. export control laws. By accepting this
# software, the user agrees to comply with all applicable U.S. export laws and
# regulations. User has the responsibility to obtain export licenses, or other
# export authority as may be required before exporting such information to
# foreign countries or providing access to foreign persons.
# however ..
# based on f90mkmf from H. Pumphrey (check that this is true in fact)
#
# Based on Michael Wester <wester@@math.unm.edu> February 16, 1995
# Cotopaxi (Consulting), Albuquerque, New Mexico
# Bugs and limitations
#(1) Does too much--should be split up into dependency maker and
#     separate swiss army knife (especially usages (3) and (4))
#(2) Still too specialized--works well only with NAG-like compilers
#(3) Build commands used with (1)-mod variant are grotesque
#    shouldn't they be configurable at least?
#
# "$Id: f90makedep.pl,v 1.17 2010/01/05 01:52:43 pwagner Exp $"

#         Settings which affect how the script operates
#         * * * * * * * * * * * * * * * * * * * * * * * 
# if TRUE, debug by printing extra stuff
$DEBUG = 0;

# if TRUE, don't split long lines containing a quote mark "'"
$DONT_SPLIT_QUOTES = TRUE;

# if TRUE, include source file in list of dependencies
$SELF_DEPENDS = TRUE;

# if variant (1)-mod, what case to use in module names
$var_1_mod = 0;
$mod_case = "lower";

# if TRUE, include source files in directories named in arg list
# in list of dependencies (if arguments not empty)
# (only for usage (1) currently)
$ARG_DEPENDS = TRUE;

# if TRUE, for source files in directories named in arg list
# prepend $(d1), $(d2), .. stuff; else leave bare
$dir1_PREPENDS = TRUE;

#         * * * * * * * * * * * * * * * * * * * * * * * 
# Check command-line args for options -s etc.
$more_opts = TRUE;
$source_ext = '';
$source_file = '';
$obj_ext = '';
$long_line = '';
$long_file = '';
$delimiter = ' ';
$extra_ext = '';
$term_char = "\\";
$comment_char = "#";
$include_pattern = '\!include\(([^)]+)';
while ($more_opts) {
   if ($ARGV[0] =~ /^-db/) {
      $dont_build{$ARGV[1]} = 1;
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-i/) {
      $include_pattern = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-extra/) {
      $extra_ext = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-s/) {
      $source_ext = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-o/) {
      $obj_ext = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-p/) {
      $long_line = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-d/) {
      $delimiter = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-f/) {
      $long_file = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-c/) {
      $comment_char = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-t/) {
      $term_char = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-mod/) {
      $var_1_mod = TRUE;
      $mod_case = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-S/) {
      $source_file = $ARGV[1];
      shift;
      shift;
   } else {
      $more_opts = 0;
   }
}
# Fool the script into writing to stdout instead of an actual file
open(MAKEFILE, ">-");
# Dependency listings
#
if ($source_ext ne '') {
#  note: the final argument in the subroutine call below works for m4 files only
  if ($source_file ne '') {
  #  note: the final argument in the subroutine call below works for m4 files only
    &MakeDependsGeneral("$source_file", "$obj_ext", $extra_ext);
  } else {
  &MakeDependsGeneral("*.$source_ext", "$obj_ext", $include_pattern, $extra_ext);
  }
} elsif ($long_file ne '') {
  &ReadAndSplit("$long_file", "$delimiter", "$term_char", "$comment_char");
} elsif ($long_line ne '') {
  &SplitAndPrint("$long_line", "$delimiter", "$term_char");
} elsif ($source_file ne '') {
  &MakeDependsf90($ARGV[1],"$source_file");
} else {
  &MakeDependsf90($ARGV[1],"*.f90");
  # &MakeDepends("*.f *.F", '^\s*include\s+["\']([^"\']+)["\']');
  # &MakeDepends("*.c",     '^\s*#\s*include\s+["\']([^"\']+)["\']');
}
#
# &PrintWords(current output column, extra tab?, word list);
# --- print space-separated words nicely
#
sub PrintWords {
   local($columns) = 78 - shift(@@_);
   local($extratab) = shift(@@_);
   local($wordlength);
   #
   print MAKEFILE @@_[0];
   $columns -= length(shift(@@_));
   foreach $word (@@_) {
      $wordlength = length($word);
      if ($wordlength + 1 < $columns) {
         print MAKEFILE " $word";
         $columns -= $wordlength + 1;
         }
      else {
         #
         # Continue onto a new line
         #
         if ($extratab) {
            print MAKEFILE " \\\n\t\t$word";
            $columns = 62 - $wordlength;
            }
         else {
            print MAKEFILE " \\\n\t$word";
            $columns = 70 - $wordlength;
            }
         }
      }
   }

#
# &PrintElements(current output column, delimiter, line term, element list);
# --- print delimiter-separated words nicely, with line term at end of each line
#
sub PrintElements {
   local($columns) = 78 - shift(@@_);
   local($delimiter) = shift(@@_);
   local($line_term) = shift(@@_);
   local($wordlength);
   #
   print MAKEFILE @@_[0];
   $columns -= length(shift(@@_));
   foreach $word (@@_) {
      $wordlength = length($word);
      if ($wordlength + 1 < $columns) {
         print MAKEFILE "$delimiter" . "$word";
         $columns -= $wordlength + 1;
         }
      else {
         #
         # Continue onto a new line
         #
         print MAKEFILE "$delimiter" . "$line_term" . "\n\t$word";   
         $columns = 70 - $wordlength;     
         }                                
      }
   }

#
# &LanguageCompiler(compiler, sources); --- determine the correct language
#    compiler
#
sub LanguageCompiler {
   local($compiler) = &toLower(shift(@@_));
   local(@@srcs) = @@_;
   #
   if (length($compiler) > 0) {
      CASE: {
         grep(/^$compiler$/, ("fc", "f77")) &&
            do { $compiler = "FC"; last CASE; };
         grep(/^$compiler$/, ("cc", "c"))   &&
            do { $compiler = "CC"; last CASE; };
         $compiler = "F90";
         }
      }
   else {
      CASE: {
         grep(/\.f90$/, @@srcs)   && do { $compiler = "F90"; last CASE; };
         grep(/\.(f|F)$/, @@srcs) && do { $compiler = "FC";  last CASE; };
         grep(/\.c$/, @@srcs)     && do { $compiler = "CC";  last CASE; };
         $compiler = "???";
         }
      }
   $compiler;
   }

#
# &toLower(string); --- convert string into lower case
#
sub toLower {
   local($string) = @@_[0];
   $string =~ tr/A-Z/a-z/;
   $string;
   }

#
# &toUpper(string); --- convert string into upper case
#
sub toUpper {
   local($string) = @@_[0];
   $string =~ tr/a-z/A-Z/;
   $string;
   }

#
# &uniq(sorted word list); --- remove adjacent duplicate words
#
sub uniq {
   local(@@words);
   foreach $word (@@_) {
      if ($word ne $words[$#words]) {
         push(@@words, $word);
         }
      }
   @@words;
   }

#
# &MakeDepends(language pattern, include file sed pattern); --- dependency
#    maker
#
sub MakeDepends {
   local(@@incs);
   local($lang) = @@_[0];
   local($pattern) = @@_[1];
   #
   foreach $file (<${lang}>) {
      open(FILE, $file) || warn "Cannot open $file: $!\n";
      while (<FILE>) {
         /$pattern/i && push(@@incs, $1);
         }
      if (@@incs) {
         $file =~ s/\.[^.]+$/.o/;
         print MAKEFILE "$file: ";
         &PrintWords(length($file) + 2, 0, @@incs);
         print MAKEFILE "\n";
         undef @@incs;
         }
      }
   }

#
# &MakeDependsGeneral(source language pattern, object extension,
#   include file sed pattern); --- dependency maker
#
sub MakeDependsGeneral {
   local(@@incs);
   local($lang) = @@_[0];
   local($obj_ext) = @@_[1];
   local($pattern) = @@_[2];
   local($extra_ext) = @@_[3];
   #
   if ($extra_ext ne '') {
     $extra_ext =~ s/^/\./;
   }
   # print MAKEFILE "# $pattern: ";
   foreach $file (<${lang}>) {
      open(FILE, $file) || warn "Cannot open $file: $!\n";
      while (<FILE>) {
        if ($extra_ext ne '') {
         /$pattern/i && push(@@incs, $1.$extra_ext);
         }
        else {
         /$pattern/i && push(@@incs, $1);
        }
         }
      if (@@incs || $SELF_DEPENDS) {
         if ($SELF_DEPENDS) {
		     @@incs = reverse(@@incs);
           push(@@incs, $file);
		     @@incs = reverse(@@incs);
         }
         $file =~ s/\.[^.]+$/.$obj_ext/;
         print MAKEFILE "$file: ";
         &PrintWords(length($file) + 2, 0, @@incs);
         print MAKEFILE "\n";
         undef @@incs;
         }
      }
   }

#
# &ReadAndSplit(file to print, delimiter, term char, comment char
#
sub ReadAndSplit {
   local(@@incs);
   local($line);
   local($file_name) = @@_[0];
   local($delimiter) = @@_[1];
   local($term_char) = @@_[2];
   local($comment_char) = @@_[3];
   #
   open(LONGFILE, "$file_name");
   while (<LONGFILE>) {
      $line = $_;
      if ($line =~ /^\s*$comment_char/) {
         print MAKEFILE $line;
      } elsif ($DONT_SPLIT_QUOTES && $line =~ /'/) {
         print MAKEFILE $line;
      } else {
        chomp($line);
        @@incs = split("$delimiter","$line");
        &PrintElements(0, "$delimiter", "$term_char", @@incs); 
        print MAKEFILE "\n";                                 
      }
   }
   close LONGFILE;
}

#
# &SplitAndPrint(line to print, delimiter, term char at end of each line
#
sub SplitAndPrint {
   local(@@incs);
   local($line) = @@_[0];
   local($delimiter) = @@_[1];
   local($term_char) = @@_[2];
   #
   @@incs = split("$delimiter","$line");
   &PrintElements(0, "$delimiter", "$term_char", @@incs);      
   print MAKEFILE "\n";                                      
   }

#
# &MakeDependsf90(f90 compiler); --- FORTRAN 90 dependency maker
#
sub MakeDependsf90 {
   local($compiler) = &toLower(@@_[0]);
   local($lang) = @@_[1];
   local(@@dependencies);
#  To store object file name keyed by module name
   local(%filename);
#  To module file name keyed by object name
   local(%modulename_by_file);
#  To module file name keyed by module name
   local(%modulename_by_module);
   local(@@incs);
   local(@@modules);
   local($objfile);
   local($arg_number);
   local($prependant);
   local($key);
   local($value);
   local($TOUCH_PART1) = '$(UTILDIR)/mark_as_uptodate.sh -M $(MAKE) -t -T ';
   local($BUILD_PART1) = '$(UTILDIR)/newAifBdiff.sh -a ';
   local($BUILD_PART2) = '$(FC) -c $(FOPTS) $(PRE) $(INC_PATHS) $(S)/';
   local($BUILD_PART3) = ' $(FAFTER)';
   #
   # Associate each module with the name of the file that contains it
   #
#   foreach $file (<*.f90>) {
   foreach $file (<${lang}>) {
      open(FILE, $file) || warn "Cannot open $file: $!\n";
      while (<FILE>) {
         # This bit of filtering is to exclude statements that begin 
         # module procedure ...
         if ( /^\s*module\s+procedure/i ) {    
            $value = $key;                                                
         } else {                                                        
           /^\s*module\s+(\w+)/i &&
            ($filename{&toLower($1)} = $file) =~ s/\.f90$/.o/;
         }
       }
   }
   if ($DEBUG) {
      print "object file name keyed by module name (in home directory)\n";
      while (($key,$value) = each %filename) {     
                   print "$key=$value\n";          
           }                                       
      print "\n";
   }

   #
   # Do the same in every directory named in arg list
   #
   if ($ARG_DEPENDS) {
   #
   chomp($cwd = `pwd`);
 #   Now loop over list of directories which are command-line arguments
    $arg_number = 0;
    while ($#ARGV >= $[) {
   	die "Can't cd to $ARGV[$[]:$!\n"
        	unless chdir $ARGV[$[] ;
        shift @@ARGV;
        $arg_number++;
        if ($dir1_PREPENDS) {
           $prependant = '$(dir' . "$arg_number" . ')';
        } else {        
            $prependant = '';
       }
       # foreach $file (<*.f90>) {
       foreach $file (<${lang}>) {
          open(FILE, $file) || warn "Cannot open $file: $!\n";
          ($objfile = "$prependant" . "$file") =~ s/\.f90$/.o/;
          $key = '';
          while (<FILE>) {
             # This bit of filtering is to exclude statements that begin 
             # module procedure ...
             if ( /^\s*module\s+procedure/i ) {
                $value = $key;
             } else {
               /^\s*module\s+(\w+)/i &&
                ($key = &toLower($1));
    #            ($filename{&toLower($1)} = "$prependant" . "$file") =~ s/\.f90$/.o/;
             }
           }
          # Now add to our hash, but only if this is a new key  
          # W a r n i n g   W a r n i n g
          # This assumes the following behavior
          # if %hash defined for $key, then $hash{$key} != '' 
          # otherwise $hash{$key} = '' 
          # if instead $hash{$key} = '' for a defined $key
          # or else $hash{$key} dumps core for an undefined $key
          # then we will need to revisit and revise this
          $value = "$filename{$key}.suffix";
          # print "file ($file), key ($key), value ($value) \n";
          if ($value =~ /^\.suf/) {
            $filename{$key} = $objfile;
          }
       }
       chdir $cwd;
      }
    }

   # Find module name given object file name
   # We can't simply use the following:
   # %modulename_by_file = reverse %filename;
   # for two reasons
   # (1) filenames from outside directories come with "$(dirn)" prepended
   # (2) Depending on $mod_case we may want modulename lower or UPPER
   # So the 1st thing we do is acquire key, value pair from filename
   while (($key, $value) = each %filename) {
         # Next, value  => $(prependant)file
         if ( $value =~ /\(dir/) {
           $_ = $value;
            /\((.*?)\)(.*)/ && ($prependant=$1) && ($file=$2);
           if ($mod_case =~ /^U/) {
               $modulename_by_file{$file} = &toUpper($key);
               $modulename_by_module{$key} = &toUpper($key);
           } else {
               $modulename_by_file{$file} = &toLower($key);
               $modulename_by_module{$key} = &toLower($key);
           }
           # Finally, modulename_by_file  = $(prependant)module
           $prependant = '$(' . $prependant . ')';
           $modulename_by_file{$file} = $prependant .  $modulename_by_file{$file};
           $modulename_by_module{$key} = $prependant .  $modulename_by_module{$key};
         } else {
           if ($mod_case =~ /^U/) {
               $modulename_by_file{$value} = &toUpper($key);
               $modulename_by_module{$key} = &toUpper($key);
           } else {
               $modulename_by_file{$value} = &toLower($key);
               $modulename_by_module{$key} = &toLower($key);
           }
         }
       }  

   if ($DEBUG) {
      print "object file name keyed by module name \n";
      while (($key,$value) = each %filename) {     
                   print "$key=$value\n";          
           }                                       
      print "\n";
      print "module file name keyed by object name \n";
      while (($key,$value) = each %modulename_by_file) {   
                   print "$key=$value\n";          
           }                                       
      print "\n";
      print "module file name keyed by module name \n";
      while (($key,$value) = each %modulename_by_module) {  
                   print "$key=$value\n";          
           }                                       
      print "\n";
   }

   #
   # Print the dependencies of each file that has one or more include's or
   # references one or more modules
   #
   # foreach $file (<*.f90>) {
   foreach $file (<${lang}>) {
      open(FILE, $file);
      while (<FILE>) {
         #/^\s*use\s+([^\s,!]+)/i && push(@@modules, &toLower($1));
         #/^\s*include\s+["\'](\w+)["\']/i && push(@@incs, $1);
         /^\s*include\s+["\']([^"\']+)["\']/i && push(@@incs, $1);
         /^\s*use\s+(\w+)/i && push(@@modules, &toLower($1));
         }

      if ($DEBUG) {
           print "modules used by $file\n";
           foreach $module (@@modules) {
             print $module, " ";
           }
           print "\n";
         }
      if (@@incs || @@modules || $var_1_mod) {
         ($objfile = $file) =~ s/\.f90$/.o/;
         undef @@dependencies;
         if ( $var_1_mod ) {
# ------------------------
#   The case of .mod file-mediated dependencies
# ------------------------
#           print MAKEFILE "$modulename_by_file{$objfile}.mod $objfile: ";
#           print MAKEFILE "$objfile: ";
           if ("$modulename_by_file{$objfile}.mod" !~ /^\./) {
#   file_name.o: module_name.mod file_name.f90
              print MAKEFILE "$objfile: $modulename_by_file{$objfile}.mod ";
              print MAKEFILE "$file \n";
              if ($dont_build{$file} != 1) {
                print MAKEFILE "\t";
#                print MAKEFILE "touch $objfile \n";
                print MAKEFILE "$TOUCH_PART1";
                print MAKEFILE "$objfile ";
                print MAKEFILE "$modulename_by_file{$objfile}.mod \n";
              }
#   file_name.mod: file_name.f90
              print MAKEFILE "$modulename_by_file{$objfile}.mod: ";
           } else {
              print MAKEFILE "$objfile: ";
           }
#              print MAKEFILE "$modulename_by_file{$objfile}.mod ";
#           }
#           print MAKEFILE "$objfile: ";
           foreach $module (@@modules) {
              $value = "$modulename_by_module{$module}.mod";
              if ($value !~ /^\./) {
                push(@@dependencies, $value);
              }
           }
         } else {
           print MAKEFILE "$objfile: ";
           foreach $module (@@modules) {
              push(@@dependencies, $filename{$module});
           }
         }
         @@dependencies = &uniq(sort(@@dependencies));
         if ($SELF_DEPENDS) {
#         if ($SELF_DEPENDS && ($var_1_mod != TRUE)) {
#		     @@dependencies = reverse(push(reverse(@@dependencies), $file));
		     @@dependencies = reverse(@@dependencies);
                    push(@@dependencies, $file);
		     @@dependencies = reverse(@@dependencies);
         }
         &PrintWords(length($objfile) + 2, 0,
                     @@dependencies, &uniq(sort(@@incs)));
         print MAKEFILE "\n";
         if ( $var_1_mod && ("$modulename_by_file{$objfile}.mod" !~ /^\./)) {
#           print MAKEFILE "$modulename_by_file{$objfile}.mod: \n";
#           print MAKEFILE "$modulename_by_file{$objfile}.mod: $file\n";
           if ($dont_build{$file} != 1) {
             print MAKEFILE "\t";
             print MAKEFILE $BUILD_PART1;
             print MAKEFILE "$modulename_by_file{$objfile}.mod ";
             print MAKEFILE $BUILD_PART2;
             print MAKEFILE $file;
             print MAKEFILE $BUILD_PART3;
             print MAKEFILE "\n";
#             print MAKEFILE "$objfile: $file\n";
#             print MAKEFILE "\t";
#             print MAKEFILE $BUILD_PART1;
#             print MAKEFILE "$modulename_by_file{$objfile}.mod ";
#             print MAKEFILE $BUILD_PART2;
#             print MAKEFILE $file;
#             print MAKEFILE $BUILD_PART3;
#             print MAKEFILE "\n";
           }
         }
         undef @@incs;
         undef @@modules;
         }
      }
     if ( $var_1_mod ) {
         print MAKEFILE " MODULES=";
         while (($key, $value) = each %modulename_by_file) {
              $value = $value . ".mod";
              if ($value !~ /^\./ && $value !~ /\(dir/) {
                 push(@@modules, $value);
              }
         }
         &PrintWords(length($objfile) + 2, 0,
                     @@modules);
         print MAKEFILE "\n";
     }
   }
# $Log: f90makedep.pl,v $
# Revision 1.17  2010/01/05 01:52:43  pwagner
# More usefule with LaTeX files
#
# Revision 1.16  2007/06/08 23:08:41  vsnyder
# Add PRE reference to BUILD_PART2
#
# Revision 1.15  2007/03/06 21:30:10  pwagner
# Deleted outmoded lines concerning 'actua;l location of perl'
#
# Revision 1.14  2005/06/23 22:22:46  pwagner
# Reworded Copyright statement
#
# Revision 1.13  2004/11/03 19:09:33  pwagner
# perl scripts now get launched via perl rather than as stand-alone executables
#
# Revision 1.12  2004/03/18 17:58:09  pwagner
# Ended foolish use of temp file to learn cwd
#
# Revision 1.11  2003/09/24 19:18:42  pwagner
# Restored to proper functioning despite new perl
#
# Revision 1.10  2002/07/18 17:58:49  pwagner
# .o now depends on file_name even if .mod mediated
#
# Revision 1.9  2002/07/01 20:51:22  pwagner
# Rebuilds object file when deleted
#
# Revision 1.8  2002/07/01 17:27:08  pwagner
# No longer compiles some sources twice
#
# Revision 1.7  2002/06/24 20:35:34  pwagner
# Restored FAFTER to compiler invocation
#
# Revision 1.6  2002/06/04 17:04:06  pwagner
# fixed bare word assignment value =
#
# Revision 1.5  2002/05/29 22:19:49  pwagner
# New changes--hurriedly committed because of filesys errors
#
# Revision 1.4  2002/05/22 00:37:26  pwagner
# Work with new (1)-mod variant dependency files
#
# Revision 1.3  2002/04/09 19:39:36  pwagner
# Alternate usages 2-4 (depending on options) added
#
# Revision 1.2  2000/11/02 23:22:38  pwagner
# Dependencies may cross directories
#
# Revision 1.1  2000/10/27 23:21:26  pwagner
# First commit
#
@


1.17
log
@More usefule with LaTeX files
@
text
@d89 2
d115 1
a115 1
# "$Id: f90makedep.pl,v 1.16 2007/06/08 23:08:41 vsnyder Exp $"
d150 1
d163 4
d216 1
a216 1
    &MakeDependsGeneral("$source_file", "$obj_ext", $include_pattern);
d218 1
a218 1
  &MakeDependsGeneral("*.$source_ext", "$obj_ext", $include_pattern);
d365 1
a365 1
      if (defined @@incs) {
d384 1
d386 3
d393 4
d398 1
d400 1
a400 1
      if (defined @@incs || $SELF_DEPENDS) {
d631 1
a631 1
      if (defined @@incs || defined @@modules || $var_1_mod) {
d721 3
@


1.16
log
@Add PRE reference to BUILD_PART2
@
text
@d85 4
d113 1
a113 1
# "$Id: f90makedep.pl,v 1.15 2007/03/06 21:30:10 pwagner Exp $"
d143 1
d150 1
d156 4
d193 4
d207 6
a212 1
  &MakeDependsGeneral("*.$source_ext", "$obj_ext", '\!include\(([^)]+)');
d217 2
d220 1
a220 1
  &MakeDependsf90($ARGV[1]);
d378 1
d446 1
d468 2
a469 1
   foreach $file (<*.f90>) {
d508 2
a509 1
       foreach $file (<*.f90>) {
d598 2
a599 1
   foreach $file (<*.f90>) {
d705 3
@


1.15
log
@Deleted outmoded lines concerning 'actua;l location of perl'
@
text
@d109 1
a109 1
# "$Id: f90makedep.pl,v 1.14 2005/06/23 22:22:46 pwagner Exp $"
d440 1
a440 1
   local($BUILD_PART2) = '$(FC) -c $(FOPTS) $(INC_PATHS) $(S)/';
d679 3
@


1.14
log
@Reworded Copyright statement
@
text
@a35 3
# To run this, it will be necessary to modify the first line of this script
# to point to the actual location of Perl on your system.
#
d109 1
a109 1
# "$Id: f90makedep.pl,v 1.13 2004/11/03 19:09:33 pwagner Exp $"
d679 3
@


1.13
log
@perl scripts now get launched via perl rather than as stand-alone executables
@
text
@d90 10
a99 2
# Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
# U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d112 1
a112 1
# "$Id: f90makedep.pl,v 1.12 2004/03/18 17:58:09 pwagner Exp $"
d682 3
@


1.12
log
@Ended foolish use of temp file to learn cwd
@
text
@a0 2
#!/usr/local/bin/perl
#
d104 1
a104 1
# "$Id: f90makedep.pl,v 1.11 2003/09/24 19:18:42 pwagner Exp $"
d674 3
@


1.11
log
@Restored to proper functioning despite new perl
@
text
@d81 1
a81 1
# -p text           text to be split among several lines
d84 1
a84 1
# -f file_name      file containing text to be split
d92 1
a92 1
# Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d101 1
a101 1
#     separate swiss army knife
d106 1
a106 1
# "$Id: f90makedep.pl,v 1.10 2002/07/18 17:58:49 pwagner Exp $"
d468 1
a468 12
   # chop($cwd = \`pwd\`);
   # The above line, although found among man pages, won't pass muster
   #
   # The following is a poor way to fill $cwd with the current working directory
   # Ask a more perl-savvy programmer how to do this w/o creating temp file
     system "pwd > temp";
     open (TEMPFILE, temp);
     while (<TEMPFILE>) {
       chop;
       $cwd = $_;
       }
     unlink temp;
d676 3
@


1.10
log
@.o now depends on file_name even if .mod mediated
@
text
@d1 1
a1 1
#!/usr/bin/perl
d106 1
a106 1
# "$Id: f90makedep.pl,v 1.9 2002/07/01 20:51:22 pwagner Exp $"
d447 1
a447 1
         if ( /^\s*module\s+[pP][rR][oO][cC][eE][dD][uU][rR][eE]/ ) {    
d450 1
a450 1
           /^\s*module\s+([^\s!]+)/i &&
d499 1
a499 1
             if ( /^\s*module\s+[pP][rR][oO][cC][eE][dD][uU][rR][eE]/ ) {
d502 1
a502 1
               /^\s*module\s+([^\s!]+)/i &&
d584 2
d587 1
a587 1
         /^\s*use\s+([^\s,!]+)/i && push(@@modules, &toLower($1));
d590 7
d687 3
@


1.9
log
@Rebuilds object file when deleted
@
text
@d106 1
a106 1
# "$Id: f90makedep.pl,v 1.8 2002/07/01 17:27:08 pwagner Exp $"
d587 1
d592 3
d598 3
a600 1
              print MAKEFILE "$objfile: $modulename_by_file{$objfile}.mod \n";
d608 1
d678 3
@


1.8
log
@No longer compiles some sources twice
@
text
@d106 1
a106 1
# "$Id: f90makedep.pl,v 1.7 2002/06/24 20:35:34 pwagner Exp $"
d435 1
d597 4
a600 1
                print MAKEFILE "touch $objfile \n";
d671 3
@


1.7
log
@Restored FAFTER to compiler invocation
@
text
@d106 1
a106 1
# "$Id: f90makedep.pl,v 1.6 2002/06/04 17:04:06 pwagner Exp $"
d590 1
a590 1
           print MAKEFILE "$modulename_by_file{$objfile}.mod $objfile: ";
d592 10
a601 1
#           if ("$modulename_by_file{$objfile}.mod" !~ /^\./) {
d604 1
d667 3
@


1.6
log
@fixed bare word assignment value =
@
text
@d106 1
a106 1
# "$Id: f90makedep.pl,v 1.5 2002/05/29 22:19:49 pwagner Exp $"
d437 1
d627 1
d635 1
d657 3
@


1.5
log
@New changes--hurriedly committed because of filesys errors
@
text
@d106 1
a106 1
# "$Id: f90makedep.pl,v 1.4 2002/05/22 00:37:26 pwagner Exp $"
d446 1
a446 1
            value = $key;                                                
d498 1
a498 1
                value = $key;
d654 3
@


1.4
log
@Work with new (1)-mod variant dependency files
@
text
@d106 1
a106 1
# "$Id: f90makedep.pl,v 1.3 2002/04/09 19:39:36 pwagner Exp $"
d585 1
a585 1
      if (defined @@incs || defined @@modules) {
d589 5
a593 5
#           print MAKEFILE "$modulename_by_file{$objfile}.mod $objfile: ";
           print MAKEFILE "$objfile: ";
           if ("$modulename_by_file{$objfile}.mod" !~ /^\./) {
              print MAKEFILE "$modulename_by_file{$objfile}.mod ";
           }
d618 1
a618 1
           print MAKEFILE "$modulename_by_file{$objfile}.mod: \n";
d627 7
a633 7
             print MAKEFILE "$objfile: \n";
             print MAKEFILE "\t";
             print MAKEFILE $BUILD_PART1;
             print MAKEFILE "$modulename_by_file{$objfile}.mod ";
             print MAKEFILE $BUILD_PART2;
             print MAKEFILE $file;
             print MAKEFILE "\n";
d640 12
d654 3
@


1.3
log
@Alternate usages 2-4 (depending on options) added
@
text
@d41 13
d85 2
d88 2
d91 1
a91 1
# P.A. Wagner (March 27 2002)
d99 6
d106 1
a106 1
# "$Id: f90makedep.pl,v 1.2 2000/11/02 23:22:38 pwagner Exp $"
d110 3
d119 4
d143 5
a147 1
   if ($ARGV[0] =~ /^-s/) {
d175 5
d299 9
d422 1
d424 4
d433 4
d443 6
a448 1
         /^\s*module\s+([^\s!]+)/i &&
d451 10
a460 1
      }
d492 11
a502 3
           while (<FILE>) {
             /^\s*module\s+([^\s!]+)/i &&
                ($filename{&toLower($1)} = "$prependant" . "$file") =~ s/\.f90$/.o/;
d504 13
d518 1
d522 53
a586 1
         print MAKEFILE "$objfile: ";
d588 18
a605 3
         foreach $module (@@modules) {
            push(@@dependencies, $filename{$module});
            }
d608 1
d617 19
d642 3
@


1.2
log
@Dependencies may cross directories
@
text
@d5 3
a7 1
# Generate a Makefile-ready dependency listing from the f90 sources 
d19 2
a20 2
# Usage:
# 	f90makedep.pl [arg1 arg2 ..]
d23 3
a25 3
# source1.o: source1.f90 source2.f90 .. $(d1)s1.f90 $(d1)s2.f90 .. $(d2)t1.f90 ..
# source2.o: source2.f90 source3.f90 .. $(d1)s1.f90 $(d1)s2.f90 .. $(d2)t1.f90 ..
# source3.o: source3.f90 .. $(d1)s1.f90 $(d1)s2.f90 .. $(d2)t1.f90 ..
d41 12
a52 2
# P.A. Wagner (October 31 2000)
# (see mlsconfigure.sh for copyright statement)
d54 25
a78 1
# Based on f90mkmf from H. Pumphrey (check that this is true in fact)
d83 1
a83 1
# "$Id: f90makedep.pl,v 1.1 2000/10/27 23:21:26 pwagner Exp $"
d87 3
d95 1
d103 42
d149 12
a160 4
&MakeDependsf90($ARGV[1]);
# &MakeDepends("*.f *.F", '^\s*include\s+["\']([^"\']+)["\']');
# &MakeDepends("*.c",     '^\s*#\s*include\s+["\']([^"\']+)["\']');

d162 2
a163 2
# &PrintWords(current output column, extra tab?, word list); --- print words
#    nicely
d195 28
d297 72
d448 4
a451 4
#		@@dependencies = reverse(push(reverse(@@dependencies), $file));
		@@dependencies = reverse(@@dependencies);
               push(@@dependencies, $file);
		@@dependencies = reverse(@@dependencies);
d462 3
@


1.1
log
@First commit
@
text
@d6 30
a35 1
# in the current directory. 
d39 4
a42 1
# Based on f90mkmf from H. Pumphrey
d47 1
a47 1
# "$Id: f90mkmf,v 1.2 2000/03/11 00:41:59 vsnyder Exp $"
d49 2
d54 9
a64 2
# print "Why do I quit prematurely?";
# exit;
d188 2
d201 39
d271 3
a273 3
# $Log: f90mkmf,v $
# Revision 1.2  2000/03/11 00:41:59  vsnyder
# Inserted CVS id and log
@

