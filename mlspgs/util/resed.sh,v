head	1.12;
access;
symbols
	v5-02-NRT-19:1.12
	v6-00:1.12
	v5-02-NRT-18:1.12
	v5-02:1.12
	v5-01-NRT-17:1.12
	v5-01-NRT-16:1.12
	v5-01-NRT-15:1.12
	v5-01-NRT-14:1.12
	neuralnetworks-1-0:1.12.0.6
	cfm-single-freq-0-1:1.12.0.4
	v5-01:1.12
	v5-00:1.12
	v4-23-TA133:1.12.0.2
	mus-emls-1-70:1.11.0.8
	rel-1-0-englocks-work:1.11.0.6
	VUMLS1-00:1.11
	VPL1-00:1.11
	V4-22-NRT-08:1.11
	VAM1-00:1.11
	V4-21:1.11.0.4
	V4-13:1.11
	V4-12:1.11
	V4-11:1.11
	V4-10:1.11
	V3-43:1.11
	M4-00:1.11
	V3-41:1.11
	V3-40-PlusGM57:1.11.0.2
	V2-24-NRT-04:1.8
	V3-33:1.11
	V2-24:1.8
	V3-31:1.11
	V3-30-NRT-05:1.11
	cfm-01-00:1.11
	V3-30:1.11
	V3-20:1.11
	V3-10:1.10
	V2-23-NRT-02:1.8
	V2-23:1.8
	V2-22-NRT-01:1.8
	V2-22:1.8
	V2-21:1.8
	V2-20:1.8
	V2-11:1.8
	V2-10:1.8
	V2-00:1.8
	V1-51:1.5
	V1-50:1.5
	V1-45:1.5
	V1-44:1.5
	V1-43:1.5
	V1-42:1.5
	V1-41:1.5
	V1-32:1.5
	V1-40:1.5
	V1-31:1.5
	V1-30:1.5
	V1-13:1.3
	V1-12:1.3
	V1-11:1.3
	V1-10:1.2
	newfwm-feb03:1.2.0.2;
locks; strict;
comment	@# @;


1.12
date	2018.10.10.23.02.03;	author pwagner;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.10.18.50.16;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.28.21.57.23;	author pwagner;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.13.23.30.03;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.07.17.06.49;	author pwagner;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.23.22.20.46;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.27.23.32.48;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.22.23.35.41;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.01.23.14.25;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.28.19.14.09;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.30.01.11.21;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.29.00.56.57;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Added -Of and -Rf cmdline options
@
text
@#!/bin/sh
#resed.sh
# --------------- resed.sh help
# Runs the command line arguments through sed, possibly
# (depending on option(s) selected)
# replacing them with the changes sed brings about
# Useful for automating scripts that modify text files
# (1) comment/uncomment lines
# (2) add/remove line(s)
# (3) change hard-coded paths (e.g. in perl scripts)
# (3) create new files, based on contents of existing ones
#
# Usage:
# resed.sh [opt] ..  [file1] [file2 ..]
#
#    O p t i o n s
# -o options    pass options to sed (default is none)
# -c command    command to pass (surrounded by ') to sed
#                as an alternative to "-c command", you may use the next pair
# -os oldstring string to be replaced
# -rs oldstring string to replace it with
# -Of os_file   file with list of old strings to be replaced
# -Rf rs_file   file with list of replacement strings
# -g            "globally" replace old string with new
# -f file       file of commands to pass through to sed
# -d1 dir1      operate on every file in dir1
# -d2 dir2      storing results in dir2 (if dir2 doesn't exist, it creates it)
#                (if omitted, replace each file in dir1 with its result)
# -[n]grep text restrict sed to only those files [not] containing text
# -h[elp]       print brief help message; exit
# -example      print brief example; exit
# -name=xxx     name to use when renaming either new or old file
# -rn           rename new file, letting old file retain old_name
# -ro           rename old file, letting new file inherit old_name
# -rd           replace old file with new only if the editing commands change it
# -dryrun       instead of creating new file(s), print results to stdout
# -suffix=xxx   suffix to use when renaming either new or old file
#               (w/o any separator; e.g., to add ".bak" use -suffix=.bak)
# -sed mysed    run mysed instead of sed (e.g. /opt/enhanced/bin/mightysed)
# filen         file name (with path)
#
# Note:
# (1) The option(s) marked with "-", if present,
#     must precede any file on the command line
# (2) If you supply either -suffix=xxx or -name=xxx then
#     you must also choose one of -rn, -ro, or -rd
# (3) The options -c and -f are mutually exclusive, but one is mandatory
#     i.e., you must pass commands to sed either by file or by command-line
# (4) The options -rd, -rn and -ro are mutually exclusive
#     if you omit suffix=xxx and name=xxx, then with 
#     (option)    old file becomes       new file becomes
#      -rn            old_name           "old_name.new"
#      -ro          "old_name.old"          old_name
#      -rd            (deleted)             old_name
#      (none)         (deleted)             old_name
#     To repeat, if you choose -rd and the new file is different, or
#     if you choose none the new file will simply replace the old one
#     (leaving you with no backup--so test with -dryrun first)
# (5) The options -name=xxx and -sufffix=xxx are mutually exclusive
# (6) With the option -d1 dir1 don't name any files on the command line
#     -- they will be ignored
# (7) Unless you supply one of options -d2, -rn, or -ro resed will overwrite
#     each filen it modifies. This could be dangerous. You have been warned.
# (8) Using -Of and -Rf lets you you replace not just a single string
#     with another in each filen, but as many as you have in os_file and rs_file
# 
# Result:
# Files in the list may be modified or new files created
# according to the the options you supply
# --------------- End resed.sh help
# Copyright 2005, by the California Institute of Technology. ALL
# RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
# commercial use must be negotiated with the Office of Technology Transfer
# at the California Institute of Technology.

# This software may be subject to U.S. export control laws. By accepting this
# software, the user agrees to comply with all applicable U.S. export laws and
# regulations. User has the responsibility to obtain export licenses, or other
# export authority as may be required before exporting such information to
# foreign countries or providing access to foreign persons.

# "$Id: resed.sh,v 1.11 2009/12/10 18:50:16 pwagner Exp $"

#---------------------------- read_file_into_array
#
# read each line of stdin
# catenating them into an array which we will return
# Ignore any entries beginning with '#' character
# In fact, only first entry in each line is kept
# Possible improvements:
#   Other comment signifiers
#   Choose field number other than 1

read_file_into_array()
{
  array_result=''
  while read line; do
    element=`echo $line | awk '$1 !~ /^#/ {print $1}'`
    if [ "$element" != "" ]
    then
      array_result="$array_result $element"
    fi
  done
  echo $array_result
}

#---------------------------- print_nth_array_element
#
# Function to print the nth element in a space-delimited list
# where n is the first arg, the list is the second arg, 
# print_nth_array_element 3 'a b c d'
# writes 'c' to standard output

print_nth_array_element()
{

   # Do we have enough args?
      if [ $# -lt 2 ]
      then
         echo "Usage: print_nth_array_element n 'a b c ..'"
         exit 1
      fi
      
      perl -e '@@parts=split(" ","$ARGV[0]"); print $parts[$ARGV[1]-1]' "$2" "$1"
}

#
#------------------------------- Main Program ------------

#****************************************************************
#                                                               *
#                  * * * Main Program  * * *                    *
#                                                               *
#                                                               *
#	The entry point where control is given to the script    *
#****************************************************************
#
#   Notes
# Bugs: 
# (1) If the old_name+suffix exceeds the longest possible file name
#     the script does not fail gracefully
# (2) If filen+suffix is the same as filem for some pair (n,m)
#     one will replace the other w/o any warning of this possibility
# (3) The renaming mechanism suffix=xxx and name=xxx has not been
#     implemented for the option -rd yet; maybe it makes no sense to do so
# (4) When using -os "string1" -rs "string2"
#     you must not have both delimiters "/", ":" present among the strings
# Unimplemented improvements: 
# (1) Also allow inserting a block of text to be stored in a file after  
#     line nnn via -l nnn -b block_file
#****************************************************************
# --------------- resed.sh example
# Example:
# I have a set of files, in each of which I wish to change one line
# in which a variable "init_m_dir" is currently being set to a value "l1":
# ../mlspgs:76% grep 'init_m_dir = l1' tests/fwdmdl/platforms/[AD-Z]* tests/cloudfwdm/platforms/[AD-Z]*
# tests/fwdmdl/platforms/LF95.Linux:init_m_dir = l1
# tests/fwdmdl/platforms/NAG.Linux:init_m_dir = l1
# tests/fwdmdl/platforms/NAG.SGI:init_m_dir = l1
# tests/fwdmdl/platforms/NAG.Sun:init_m_dir = l1
# tests/fwdmdl/platforms/Sun.Sun:init_m_dir = l1
# tests/fwdmdl/platforms/Unknown.None:init_m_dir = l1
# tests/cloudfwdm/platforms/LF95.Linux:init_m_dir = l1
# tests/cloudfwdm/platforms/NAG.Linux:init_m_dir = l1
# tests/cloudfwdm/platforms/NAG.SGI:init_m_dir = l1
# tests/cloudfwdm/platforms/NAG.Sun:init_m_dir = l1
# tests/cloudfwdm/platforms/Sun.Sun:init_m_dir = l1
# tests/cloudfwdm/platforms/Unknown.None:init_m_dir = l1
# 
# So to set that variable instead to the value "l2" I would first test
# (to safely assure that my changes accomplish what I want):
# ../mlspgs:77% util/resed.sh -dryrun -c 's/init_m_dir = l1/init_m_dir = l2/' tests/fwdmdl/platforms/[AD-Z]* tests/cloudfwdm/platforms/[AD-Z]* | grep 'init_m_dir = l2'
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
# init_m_dir = l2
#
# and then reenter the last command w/o the -dryrun option
# --------------- End resed.sh example
#****************************************************************
me="$0"
my_name=resed.sh
I=resed
NORMAL_STATUS=0
return_status=0
# $unique_name is unique_name with me's path prepended
unique_name="`echo $0 | sed 's/'$I'/unique_name/'`"
# $the_splitter is split_path with me's path prepended
the_splitter="`echo $0 | sed 's/'$I'/split_path/'`"
# $mkpath is mkpath with me's path prepended
mkpath="`echo $0 | sed 's/'$I'/mkpath/'`"
# $reecho is reecho with me's path prepended
reecho="`echo $0 | sed 's/'$I'/reecho/'`"
DEEBUG=off
NO_REPLACE=off
if [ $DEEBUG = "on" ]
then
   echo "Called me as $0"
   echo "with args $@@"
fi

the_text=""
reecho_opt=""
command_file=""
the_command=""
the_opt=""
all_the_opts="$@@"
more_opts="yes"
# Possible values for rename_which: {new, old, neither, diff}
rename_which="neither"
the_suffix=""
dir1=""
dir2=""
new_name=""
old_string=""
new_string=""
os_file=""
rs_file=""
dryrun="no"
globally="no"
SED="sed"
while [ "$more_opts" = "yes" ] ; do

    case "$1" in

    -o )
       the_opt="$2"
       shift
       shift
       ;;
    -c )
       the_command="$2"
       shift
       shift
       ;;
    -os )
       old_string="$2"
       shift
       shift
       ;;
    -rs )
       new_string="$2"
       shift
       shift
       ;;
    -Of )
       os_file="$2"
       shift
       shift
       ;;
    -Rf )
       rs_file="$2"
       shift
       shift
       ;;
    -d1 )
       dir1="$2"
       shift
       shift
       ;;
    -d2 )
       dir2="$2"
       shift
       shift
       ;;
    -f )
       command_file="$2"
       shift
       shift
       ;;
    -sed )
       SED="$2"
       shift
       shift
       ;;
    -rn )
       rename_which="new"
       shift
       ;;
    -ro )
       rename_which="old"
       shift
       ;;
    -rd )
       rename_which="diff"
       shift
       ;;
    -dryrun )
       dryrun="yes"
       shift
       ;;
    -g )
       globally="yes"
       shift
       ;;
    -grep )
       shift
       the_text="$1"
       reecho_opt="-grep"
       shift
       ;;
    -ngrep )
       shift
       the_text="$1"
       reecho_opt="-ngrep"
       shift
       ;;
    -name=* )
       new_name=`echo $1 | sed 's/-name=//'`
       shift
       ;;
    -suffix=* )
       the_suffix=`echo $1 | sed 's/-suffix=//'`
       shift
       ;;
    -h | -help )
       sed -n '/'$my_name' help/,/End '$my_name' help/ p' $me \
           | sed -n 's/^.//p' | sed '1 d; $ d'
       exit
       ;;
    -example )
       sed -n '/'$my_name' example/,/End '$my_name' example/ p' $me \
           | sed -n 's/^.//p' | sed '1 d; $ d'
       exit
       ;;
    * )
       more_opts="no"
       ;;
    esac
done

if [ $DEEBUG = "on" ]
then
   echo "the_opt $the_opt"
   echo "command_file $command_file"
   echo "the_command $the_command"
   echo "old_string $old_string"
   echo "new_string $new_string"
   echo "os_file $os_file"
   echo "rs_file $rs_file"
   echo "the_suffix $the_suffix"
   echo "new_name $new_name"
   echo "rename_which? $rename_which"
   echo "dryrun? $dryrun"
   echo "sed command to use $SED"
   echo "remaining args $@@"
fi
# Check for forbidden arguments or inconsistencies
if [ "$the_command" != "" -a "$command_file" != "" ]
then
  echo 'You cannot have both a command file and command-line'
  exit
elif [ "$command_file" != "" ]
then
  the_opt="$the_opt -f $command_file"
elif [ "$old_string" != "" -a "$os_file" != "" ]
then
  echo 'You cannot have both an old string and a file of them'
  exit
elif [ "$new_string" != "" -a "$rs_file" != "" ]
then
  echo 'You cannot have both a replacement string and a file of them'
  exit
elif [ "$rs_file" != "" ]
then
  # We'll check later
  echo "$rs_file" > /dev/null
elif [ "$old_string" != "" ]
then
  # Which delimiter shall we use? / or : ?
  old_slashed=`echo "$old_string" | grep '/'`
  new_slashed=`echo "$new_string" | grep '/'`
  if [ "$old_slashed" = "" -a "$new_slashed" = "" ]
  then
    the_command='s/'$old_string'/'$new_string'/'
    # the_opt='s/'$old_string'/'$new_string'/'
  else
    the_command='s:'$old_string':'$new_string':'
    # the_opt='s:'$old_string':'$new_string':'
  fi
  if [ "$globally" = "yes" ]
  then
    the_command="$the_command"g
  fi
elif [ "$the_command" = "" ]
then
#
  echo 'You must have either a command file or a command-line'
  exit
fi

if [ "$new_name" != "" -a "$the_suffix" != "" ]
then
  echo 'You cannot specify both a new_name and a suffix'
  exit
elif [ "$rename_which" = "neither" ]
then
  if [ "$new_name" != "" -o "$the_suffix" != "" ]
  then
    echo 'You must specify whether to rename old or new'
    exit
  fi
fi

# Were we given -Of and -Rf?
# ------------------------------------------------------------
# Method: Create a new commandline for each old string and its replacement
# Then call ourself ($0) once for each new commandline
if [ "$os_file" != "" -a "$rs_file" != "" ]
then
  # Create arrays of old and replacement strings
  os_array=`read_file_into_array < "$os_file"`
  rs_array=`read_file_into_array < "$rs_file"`
  # Snip -Of and -Rf from the commandline to pass to $0
  temp_opts=$all_the_opts
  all_the_opts=`echo "$temp_opts" | sed "s/-Of $os_file//"`
  temp_opts=$all_the_opts
  all_the_opts=`echo "$temp_opts" | sed "s/-Rf $rs_file//"`
  # Iteratively call $0 with each old string and its replacement
  n=1
  for old_string in $os_array
  do
    new_string=`print_nth_array_element $n "$rs_array"`
    if [ $DEEBUG = "on" ]
    then
      echo "old_string $old_string"
      echo "new_string $new_string"
      echo "$0 -os $old_string -rs $new_string $all_the_opts"
    fi
    $0 -os $old_string -rs $new_string $all_the_opts
    n=`expr $n + 1`
  done
  # That's it
  exit 0
elif [ "$os_file" != "" ]
then
  echo "you must specify both -Of and -Rf files or neither"
  exit 1
elif [ "$rs_file" != "" ]
then
  echo "you must specify both -Of and -Rf files or neither"
  exit 1
fi
# ------------------------------------------------------------

if [ "$rename_which" = "new" -a "$the_suffix" = "" ]
then
  the_suffix=.new
elif [ "$rename_which" = "old" -a "$the_suffix" = "" ]
then
  the_suffix=.old
fi

if [ "$dir1" = "" ]
then
  the_list=`$reecho $reecho_opt $the_text "$@@"`
else
  the_list=`$reecho -dir "$dir1" $reecho_opt $the_text '*'`
fi

if [ $DEEBUG = "on" ]
then
   echo "the_command $the_command"
   echo "the_suffix $the_suffix"
   echo "the_list $the_list"
fi

if [ "$the_list" = "" ]
then
  echo 'No valid files were found among the command line arguments'
  echo 'Make sure you entered their path/names correctly  (resed.sh)'
  exit
fi

for anyfile in $the_list                                      
do
  file="$anyfile"
  file_name=`$the_splitter -f $file`
  if [ "$dir1" != "" ]
  then
    # The path is the arg
    path="$dir1"
    file="$dir1/$anyfile"
  elif [ "$file" = "$file_name" ]
  then
    # No path supplied
    path=""
  else
    path=`$the_splitter -p $file`
  fi
  temp_name=`$unique_name resed`
  if [ "$path" != "" ]
  then
    if [ -w "$path" ]
    then
      temp_name="$path"/"$temp_name"
    fi
  fi
  if [ "$the_command" != "" ]
  then
    # echo sed $the_opt "'"$the_command"'" $file
    # sed $the_opt "$the_command" $file > "$temp_name"
    $SED $the_opt "$the_command" $file > "$temp_name"
  else
    # echo sed $the_opt $file
    # sed $the_opt $file > "$temp_name"
    # the_opt='s/'$old_string'/'$new_string'/'
    $SED $the_opt $file > "$temp_name"
  fi
  # If sed failed, give up right now
  return_status=`expr $?`
  if [ "$return_status" != "$NORMAL_STATUS" ]; then       
     echo "Sorry--sed returned an error"   
    if [ "$the_command" != "" ]
    then
     echo "Possibly a syntax error in your command: $the_command"   
    else
     echo "Possibly a syntax error in your command-file: $command_file"   
    fi
    rm "$temp_name"
    exit 1                                               
  elif [ "$dryrun" = "yes" ]
  then
    echo "== $file =="  
    cat "$temp_name"    
    rm  "$temp_name"    
    # exit 0
  elif [ "$NO_REPLACE" = "on" ]
  then
    echo "Created $temp_name from $file"
  elif [ "$dir1" != "" -a "$dir2" != "" ]
  then
    if [ ! -d "$dir2" ]
    then
      $mkpath "$dir2"
    fi
    mv "$temp_name" "$dir2/$anyfile"
  elif [ "$dir1" != "" ]
  then
    mv "$temp_name" "$file"
  else
    # 1st--what do we call the renamed file
    if [ "$new_name" != "" ]
    then
      new_file_name=`$the_splitter -f $new_name`
      if [ "$new_name" != "$new_file_name" ]
      then
        new_path=`$the_splitter -p $new_name`
      elif [ -w "$path" ]
      then
        # No path supplied for new name--assume same as old path
        new_path="$path"
      else
        new_path=""
      fi
      call_it="$new_name"
      if [ "$new_path" != "" ]
      then
        call_it="$new_path"/"$new_name"
      fi
    else
      call_it="$file${the_suffix}"
    fi
    # Now, which file do we rename? (The other retains the original name)
    case $rename_which in
      new)
        mv "$temp_name" "$call_it"
        ;;
      old)
        mv "$file" "call_it"
        mv "$temp_name" "$file"
        ;;
      diff)
        if [ "`diff $file $temp_name`" != "" ]
        then
          mv "$temp_name" "$file"
        fi
        ;;
      *)
        mv "$temp_name" "$file"
        ;;
    esac
  fi                                                      
done                                                       
exit
# $Log: resed.sh,v $
# Revision 1.11  2009/12/10 18:50:16  pwagner
# Added debugging
#
# Revision 1.10  2009/07/28 21:57:23  pwagner
# print origin of error mesg
#
# Revision 1.9  2008/10/13 23:30:03  pwagner
# Added the -g option to globally do the subsitution old to new
#
# Revision 1.8  2006/06/07 17:06:49  pwagner
# Did this fix a longstanding bug, or create one?
#
# Revision 1.7  2005/06/23 22:20:46  pwagner
# Reworded Copyright statement
#
# Revision 1.6  2005/04/27 23:32:48  pwagner
# Many new options
#
# Revision 1.5  2003/05/22 23:35:41  pwagner
# Tried to fix problem with writing to read-only dirs
#
# Revision 1.4  2003/04/01 23:14:25  pwagner
# Added -name=xxx option as alternative to suffixing
#
# Revision 1.3  2003/02/28 19:14:09  pwagner
# Many new options, helpful example added
#
# Revision 1.2  2002/10/30 01:11:21  pwagner
# Actually works now
#
# Revision 1.1  2002/10/29 00:56:57  pwagner
# First commit
#
@


1.11
log
@Added debugging
@
text
@d22 3
a24 1
# -g            "globally" repalce old string with new
d62 4
d82 44
a125 1
# "$Id: resed.sh,v 1.10 2009/07/28 21:57:23 pwagner Exp $"
d135 1
a135 1
#	The entry point where control is given to the script         *
d215 1
d225 2
d254 10
d347 2
d356 1
a356 1
# Check for forbidden arguments
d364 12
d413 41
d595 3
@


1.10
log
@print origin of error mesg
@
text
@d76 1
a76 1
# "$Id: resed.sh,v 1.9 2008/10/13 23:30:03 pwagner Exp $"
d323 1
d352 7
d478 3
@


1.9
log
@Added the -g option to globally do the subsitution old to new
@
text
@d76 1
a76 1
# "$Id: resed.sh,v 1.8 2006/06/07 17:06:49 pwagner Exp $"
d354 1
a354 1
  echo 'Make sure you entered their path/names correctly'
d470 3
@


1.8
log
@Did this fix a longstanding bug, or create one?
@
text
@d22 1
d76 1
a76 1
# "$Id: resed.sh,v 1.7 2005/06/23 22:20:46 pwagner Exp $"
d176 1
d238 4
d313 4
d470 3
@


1.7
log
@Reworded Copyright statement
@
text
@d75 1
a75 1
# "$Id: resed.sh,v 1.6 2005/04/27 23:32:48 pwagner Exp $"
d301 2
a302 1
    the_opt='s/'$old_string'/'$new_string'/'
d304 2
a305 1
    the_opt='s:'$old_string':'$new_string':'
d460 3
@


1.6
log
@Many new options
@
text
@d64 10
a73 2
# Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
# U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d75 1
a75 1
# "$Id: resed.sh,v 1.5 2003/05/22 23:35:41 pwagner Exp $"
d458 3
@


1.5
log
@Tried to fix problem with writing to read-only dirs
@
text
@d14 1
a14 1
# resed.sh [opt] ..  file1 [file2 ..]
d18 4
a21 1
# -c command    command to pass (surrounded by 's) to sed
d23 4
d33 1
a33 1
# -print        instead of creating new file(s), print results of sed to stdout
d41 1
a41 1
#     must precede any filen on the command line
d55 1
a55 1
#     (leaving you with no backup--so test with -print first)
d57 2
d64 2
a65 2
# Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
# U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d67 1
a67 1
# "$Id: resed.sh,v 1.4 2003/04/01 23:14:25 pwagner Exp $"
d88 2
d91 1
a91 5
# (1) Why not allow the user to input original and replacement strings
#     via -os "string1" -rs "string2"
#     though you will have to check whether the delimiters "/", ":", etc.
#     are present among the strings
# (2) Also allow inserting a block of text to be stored in a file after  
a92 4
# (3) Instead of messing with new names, let the script edit files
#     from one dir, saving the modified versions in another
#     via -d1 d_orig -d2 d_mod
#     (you will have to disable reecho part if you do this)
d114 1
a114 1
# ../mlspgs:77% util/resed.sh -print -c 's/init_m_dir = l1/init_m_dir = l2/' tests/fwdmdl/platforms/[AD-Z]* tests/cloudfwdm/platforms/[AD-Z]* | grep 'init_m_dir = l2'
d128 1
a128 1
# and then reenter the last command w/o the -print option
d140 2
d152 2
d161 2
d164 3
a166 1
print_to_stdout="no"
d182 20
d224 14
a237 2
    -print )
       print_to_stdout="yes"
d269 2
d274 1
a274 1
   echo "print_to_stdout? $print_to_stdout"
d286 11
d324 7
a330 1
the_list=`$reecho "$@@"`
d338 1
a338 1
for file in $the_list                                      
d340 1
d342 6
a347 1
  if [ "$file" = "$file_name" ]
d370 1
d385 1
a385 1
  elif [ "$print_to_stdout" = "yes" ]
d394 10
d450 3
@


1.4
log
@Added -name=xxx option as alternative to suffixing
@
text
@d58 1
a58 1
# "$Id: resed.sh,v 1.3 2003/02/28 19:14:09 pwagner Exp $"
d289 4
a292 1
    temp_name="$path"/"$temp_name"
d329 11
d341 1
a341 1
      if [ "$path" != "" ]
d343 1
a343 1
        call_it="$path"/"$new_name"
d371 3
@


1.3
log
@Many new options, helpful example added
@
text
@d11 1
d22 4
a25 3
# -rn           rename new file "old_name"+suffix, keeping old as old_name
# -ro           rename new file "old_name", keeping old as old_name+suffix
# -rd           replace the file only if the editing commands change it
d35 3
a37 1
# (2) The options -c and -f are mutually exclusive, but one is mandatory
d39 8
a46 4
# (3) The options -rd, -rn and -ro are mutually exclusive
#     if you choose -rn but omit suffix, the new files will be "old_name.new"
#     if you choose -ro but omit suffix, the old files will be "old_name.old"
#     if you choose -rd and the new file is different, or
d49 1
d58 1
a58 1
# "$Id: resed.sh,v 1.2 2002/10/30 01:11:21 pwagner Exp $"
d77 2
d84 1
a84 1
# (2) Also allow inserting a block of text stored in a file after  
d86 1
a86 1
# (3) Instead of messing with suffixes, let the script edit files
d154 1
d197 4
d227 1
d247 13
d323 11
d337 1
a337 1
        mv "$temp_name" "$file${the_suffix}"
d340 1
a340 1
        mv "$file" "$file${the_suffix}"
d357 3
@


1.2
log
@Actually works now
@
text
@a2 1

d4 1
a4 1
# Runs the command line arguments through sed, replacing
d6 1
a6 1
# them with the changes sed brings about
d20 5
a24 2
# -n            rename new file "old_name"+suffix, keeping old as old_name
# -o            rename new file "old_name", keeping old as old_name+suffix
d27 1
d33 1
a33 1
# (2) The options -c and -f are mutually exclusive
d35 6
a40 5
# (3) The options -n and -o are mutually exclusive
#     if you choose -n but omit suffix, the new files will be "old_name.new"
#     if you choose -o but omit suffix, the old files will be "old_name.old"
#     if you choose neither the new file will simply replace the old one
#     (leaving you with no backup)
d43 2
a44 2
# Files in the list will be modified according to
# the conditions set up by the options
d46 1
a46 1
# Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d49 1
a49 1
# "$Id: resed.sh,v 1.1 2002/10/29 00:56:57 pwagner Exp $"
d71 2
d79 38
d128 1
a128 1
DEEBUG=on
d140 1
d143 2
d164 6
a169 1
    -n )
d173 1
a173 1
    -o )
d177 8
d194 5
d212 2
d220 1
d228 1
d243 1
d264 2
a265 1
    sed $the_opt "$the_command" $file > "$temp_name"
d268 2
a269 1
    sed $the_opt $file > "$temp_name"
d283 6
d291 21
a311 1
    exit 0
a312 13
  # Now, which file do we rename? (The other retains the original name)
  case $rename_which in
    new)
      mv "$temp_name" "$file${the_suffix}"
      ;;
    old)
      mv "$file" "$file${the_suffix}"
      mv "$temp_name" "$file"
      ;;
    *)
      mv "$temp_name" "$file"
      ;;
  esac
d316 3
@


1.1
log
@First commit
@
text
@d8 1
a8 1
# Useful 
d11 1
d24 1
d45 1
a45 1
# "$Id: resed.sh,v 1.4 2001/11/09 21:50:34 pwagner Exp $"
d59 14
a72 1
# (none)
d75 3
d79 1
a79 1
unique_name="`echo $0 | sed 's/resed/unique_name/'`"
d81 1
a81 1
the_splitter="`echo $0 | sed 's/resed/split_path/'`"
d83 3
a85 2
reecho="`echo $0 | sed 's/resed/reecho/'`"
DEEBUG=off
d193 2
a194 1
    sed $the_opt "'"$the_command"'" $file > "$temp_name"
d196 1
d199 16
d218 1
a218 1
      mv "$temp_name" "$file.$the_suffix"
d221 1
a221 1
      mv "$file" "$file.$the_suffix"
d231 3
@

