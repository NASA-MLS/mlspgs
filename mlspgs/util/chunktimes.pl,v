head	1.6;
access;
symbols
	v5-02-NRT-19:1.6
	v6-00:1.6
	v5-02-NRT-18:1.6
	v5-02:1.6
	v5-01-NRT-17:1.6
	v5-01-NRT-16:1.6
	v5-01-NRT-15:1.6
	v5-01-NRT-14:1.6
	neuralnetworks-1-0:1.6.0.14
	cfm-single-freq-0-1:1.6.0.12
	v5-01:1.6
	v5-00:1.6
	v4-23-TA133:1.6.0.10
	mus-emls-1-70:1.6.0.8
	rel-1-0-englocks-work:1.6.0.6
	VUMLS1-00:1.6
	VPL1-00:1.6
	V4-22-NRT-08:1.6
	VAM1-00:1.6
	V4-21:1.6.0.4
	V4-13:1.6
	V4-12:1.6
	V4-11:1.6
	V4-10:1.6
	V3-43:1.6
	M4-00:1.6
	V3-41:1.6
	V3-40-PlusGM57:1.6.0.2
	V2-24-NRT-04:1.6
	V3-33:1.6
	V2-24:1.6
	V3-31:1.6
	V3-30-NRT-05:1.6
	cfm-01-00:1.6
	V3-30:1.6
	V3-20:1.6
	V3-10:1.6
	V2-23-NRT-02:1.6
	V2-23:1.6
	V2-22-NRT-01:1.6
	V2-22:1.6
	V2-21:1.6
	V2-20:1.6
	V2-11:1.6
	V2-10:1.6
	V2-00:1.6
	V1-51:1.4
	V1-50:1.4
	V1-45:1.3
	V1-44:1.3
	V1-43:1.1;
locks; strict;
comment	@# @;


1.6
date	2005.06.29.20.54.04;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.23.22.22.46;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.03.19.09.33;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.28.00.15.25;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.13.21.23.22;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.13.22.51.58;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Changes for v1.51 finally made
@
text
@# Usage:
# chunktimes.pl mlsl2.log
# where mlsl2.log is the catenation of all the chunks' logs from a run
# in which each is mediated by a PCF and the switches include "time"
# so that each chunk outputs its own timing summary
# and phases are marked by special phase-setting Fill sections
#
# Output:
# A table of chunk timings similar to the following:
#chunk initptan updateptan inituth core coreplusr2 highcloud coreplusr3 coreplusr4 coreplusr5 (final)
#99 788.45 1288.13 2767.67 785.33 16979.92 2603.82 18267.70 11243.27 7146.03 68051.70
#276 656.02 1326.15 2349.71 783.88 30826.25 2608.30 14016.60 10608.34 6788.58 76286.80
#10 637.48 1267.51 2386.22 756.75 17297.47 2623.50 18777.74 11160.70 7106.07 68217.81
#100 604.73 1393.60 3215.92 788.31 30573.74 2614.37 13866.33 10129.87 6612.55 76165.96
#    .   .   .
#
# -----------------------------------------------------------------------
#      Options
# -nohead           skip writing header line to output
# -headonly         write only header line to output
# -head list        head table by comma-separated list of phases
#                     (instead of the default)
# -s2h              convert times from seconds to hours
# -h2s              convert times from hours to seconds
# -node             include node number on each line
#                     (assumes slave logs stored in pvmlog/compute-0-nn.mmm.log)
# Bugs and limitations:
# (1) Should be able to handle toolkitless runs
#      would need to change from $_[7] to $_[5] and
#      from $_[3] to $_[1]
# (2) list of phase names must be lower case
# (3) Wouldn't you like to be able to sort these by, e.g., (final) or chunk?
#      would need to master idea of perl references; see @@results array
#      (got past this by letting chunktimes.sh call this perl script)
# Copyright 2005, by the California Institute of Technology. ALL
# RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
# commercial use must be negotiated with the Office of Technology Transfer
# at the California Institute of Technology.

# This software may be subject to U.S. export control laws. By accepting this
# software, the user agrees to comply with all applicable U.S. export laws and
# regulations. User has the responsibility to obtain export licenses, or other
# export authority as may be required before exporting such information to
# foreign countries or providing access to foreign persons.

# "$Id: chunktimes.pl,v 1.5 2005/06/23 22:22:46 pwagner Exp $"
#
my @@a;
my @@b;
my $chunk;
my $headList;
my $headonly;
my $ishead;
my $lastChunk;
my $more_opts;
my $nohead;
my $nodeNumber;
my $nodeToo;
my $numChunks;
my $time;
my $timeConvert;
my @@results;
my $Sp;
my @@Sps;
my %times;
#An array of possible phase names
#@@Sps = split(',', "initptan,updateptan,inituth,core,coreplusr2,highcloud,coreplusr3,coreplusr4,coreplusr5,(final)");
#         * * * * * * * * * * * * * * * * * * * * * * * 
# Check command-line args for options -s etc.
#$headList = "initptan,updateptan,inituth,core,coreplusr2,highcloud,coreplusr3,coreplusr4,coreplusr5,(final)";
$headList = "initptan,updateptan,inituth,core,coreplusr2a,coreplusr2b,highcloud,coreplusr3,coreplusr4a,coreplusr4b,coreplusr5,(final)";
$headonly = 0;
$nohead = 0;
$nodeToo = 0;
$timeConvert = 1;
$more_opts = TRUE;
while ($more_opts) {
   if ($ARGV[0] =~ /^-nohead/) {
      $nohead = 1;
      shift;
   } elsif ($ARGV[0] =~ /^-headonly/) {
      $headonly = 1;
      shift;
   } elsif ($ARGV[0] =~ /^-head/) {
      $headList = $ARGV[1];
      shift;
      shift;
   } elsif ($ARGV[0] =~ /^-s2h/) {
      $timeConvert = 3600;
      shift;
   } elsif ($ARGV[0] =~ /^-h2s/) {
      $timeConvert = 1./3600;
      shift;
   } elsif ($ARGV[0] =~ /^-node/) {
      $nodeToo = 1;
      shift;
   } else {
      $more_opts = 0;
   }
}
@@Sps = split(',', $headList);
for $Sp (@@Sps) {
  $times{"$Sp"} = "$Sp";
  }
$times{chunk} = "chunk";
$times{node} = "node";
$results[0] = %times;
$lastChunk = 0;
# print $times{chunk}, "\n";
# print $times{initptan}, "\n";
# @@keys = keys(%times);
# @@values = values(%times);
# print @@keys, "\n";
# print @@values, "\n";
$ishead = TRUE;
while (<>) {
  if (/pvmlog/) {
    # Try to pull node number out of typical line like
    #/home/pwagner/l2tests/v1.42/pvmlog/compute-0-104.4919.log mlsl2.log
       # print $_, "\n";
       @@b = split;
       @@a = split/\//, $b[$#b-1];
       @@b = split/\./, $a[$#a];
       $nodeNumber = $b[0];
       # print $nodeNumber;
       # Why is the following inelegance necessary?
       if ( $nohead  && $nodeToo && $ishead ) {
         $times{node} = $nodeNumber;
       }
  }
  elsif (/\(Slave/) {
    chomp;
    split;
    # print "After split: @@_ \n";
    # print "chunk: $chunk\n";
    # print "lastChunk: $lastChunk\n";
    # $chunk = $_[7];
    $chunk = $_[4];
    if (/\(final\)/) {
      $chunk = $_[5];
    }
    if ( $chunk eq "" ) {
      print $chunk;
    }
    elsif ( $chunk ne $lastChunk ) {
      push(@@results, %times);
      # print "lastChunk: $lastChunk\n";
      # print "chunk: $chunk\n";
      # print values(%times), "\n";
      # for $Sp (values(%times)) {
      if (! ($ishead && $nohead)) {
        print "$times{chunk} ";
        for $Sp (@@Sps) {
          if ( $ishead ) {
            print "$times{$Sp} ";
          } else {
            $time = $times{$Sp} / $timeConvert;
            # print "$time ";
            # printf("%.2f %s", $time, ' ');
            &PrintTime($time);
          }
        }
        if ( $nodeToo ) {
          print $times{node};
          $times{node} = $nodeNumber;
        }
        print "\n";
      }
      if ($ishead && $headonly) {
        exit;
      }
      $lastChunk = $chunk;
      $times{chunk} = $chunk;
      $ishead = 0;
      if (/\(final\)/) {
        # $times{"(final)"} = $_[3];
        $times{"(final)"} = $_[1];
        # print "field: (final) set to $_[3] \n";
        # print "field: (final) set to $_[1] \n";
        }
    }
    $indx=0;
    tr/A-Z/a-z/;
    for $Sp (@@Sps) {
      # if (/\s$Sp\s/) {
      if (/$Sp\s/) {
        # $times{$Sp} = $_[3];
        $times{$Sp} = $_[1];
        # print "field: $Sp set to $_[3] \n";
        # print "field: $Sp set to $_[1] \n";
        # $indx++;
        }
    }
   }
}
#
# &PrintTime(time);
# --- print time nicely, with appropriate number of digits
#
sub PrintTime {
   local($ptime) = shift(@@_);
   if ( $ptime < 0.0001 ) {
     printf("%.8f %s", $ptime, ' ');
   } elsif ( $ptime < 0.01 ) {
     printf("%.6f %s", $ptime, ' ');
   } elsif ( $ptime < 1. ) {
     printf("%.4f %s", $ptime, ' ');
   } elsif ( $ptime < 100. ) {
     printf("%.2f %s", $ptime, ' ');
#   } elsif ( $ptime < 10000. ) {
#     printf("%.0f %s", $ptime, ' ');
   } else {
     print "$ptime ";
   }
}
# $Log: chunktimes.pl,v $
# Revision 1.5  2005/06/23 22:22:46  pwagner
# Reworded Copyright statement
#
# Revision 1.4  2004/11/03 19:09:33  pwagner
# perl scripts now get launched via perl rather than as stand-alone executables
#
# Revision 1.3  2004/07/28 00:15:25  pwagner
# Added -node option
#
# Revision 1.2  2004/07/13 21:23:22  pwagner
# Fixed bugs; added -s2h and -h2s options
#
# Revision 1.1  2004/05/13 22:51:58  pwagner
# First commit
#
@


1.5
log
@Reworded Copyright statement
@
text
@d46 1
a46 1
# "$Id: chunktimes.pl,v 1.4 2004/11/03 19:09:33 pwagner Exp $"
d70 2
a71 1
$headList = "initptan,updateptan,inituth,core,coreplusr2,highcloud,coreplusr3,coreplusr4,coreplusr5,(final)";
d135 7
a141 1
    $chunk = $_[7];
d176 2
a177 1
        $times{"(final)"} = $_[3];
d179 1
d185 4
a188 2
      if (/\s$Sp\s/) {
        $times{$Sp} = $_[3];
d190 1
d217 3
@


1.4
log
@perl scripts now get launched via perl rather than as stand-alone executables
@
text
@d35 4
a38 2
# Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
# U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d40 7
a46 1
# "$Id: chunktimes.pl,v 1.3 2004/07/28 00:15:25 pwagner Exp $"
d205 3
@


1.3
log
@Added -node option
@
text
@a0 2
#!/usr/local/bin/perl
# chunktimes.pl
d38 1
a38 1
# "$Id: chunktimes.pl,v 1.2 2004/07/13 21:23:22 pwagner Exp $"
d197 3
@


1.2
log
@Fixed bugs; added -s2h and -h2s options
@
text
@d27 2
d40 1
a40 1
# "$Id: chunktimes.pl,v 1.1 2004/05/13 22:51:58 pwagner Exp $"
d42 2
d51 2
d67 1
d87 3
d99 1
d110 15
a124 1
  if (/\(Slave/) {
d150 4
d199 3
@


1.1
log
@First commit
@
text
@d21 1
a21 1
# -nohead           skip writing header line to  output
d25 2
d34 1
d38 1
a38 1
# "$Id: chunktimes.sh,v 1.24 2004/03/18 17:56:49 pwagner Exp $"
d48 2
d61 1
d74 6
d116 8
a123 1
          print "$times{$Sp} ";
d149 24
a172 1
# $Log: chunktimes.sh,v $
@

