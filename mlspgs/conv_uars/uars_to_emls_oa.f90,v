head	1.9;
access;
symbols
	v5-02-NRT-19:1.9
	v6-00:1.9
	v5-02-NRT-18:1.9
	v5-02:1.9
	v5-01-NRT-17:1.9
	v5-01-NRT-16:1.9
	v5-01-NRT-15:1.9
	v5-01-NRT-14:1.9
	neuralnetworks-1-0:1.9.0.10
	cfm-single-freq-0-1:1.9.0.8
	v5-01:1.9
	v5-00:1.9
	v4-23-TA133:1.9.0.6
	mus-emls-1-70:1.9.0.4
	rel-1-0-englocks-work:1.9.0.2
	VUMLS1-00:1.9
	VPL1-00:1.8
	V4-22-NRT-08:1.8
	VAM1-00:1.8
	V4-21:1.7.0.2;
locks; strict;
comment	@# @;


1.9
date	2017.01.09.20.51.39;	author vsnyder;	state Exp;
branches;
next	1.8;

1.8
date	2015.04.21.01.13.25;	author vsnyder;	state Exp;
branches;
next	1.7;

1.7
date	2015.01.24.02.09.16;	author vsnyder;	state Exp;
branches;
next	1.6;

1.6
date	2015.01.22.02.18.56;	author vsnyder;	state Exp;
branches;
next	1.5;

1.5
date	2014.12.11.00.48.51;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2014.10.31.21.39.29;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2014.10.29.16.48.18;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2014.10.24.00.49.46;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2014.06.17.17.40.27;	author perun;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Rotate from the reference MIF, not the first one.  Add some error checking.
Use NORM2 intrinsic function.  Correct some comments.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module uars_to_emls_oa_m

  use MLSKinds, only: R8

  implicit NONE
  private

  public :: Frame_TAI, UARS_to_EMLS_OA

  character (len=*), parameter, public :: EarthEllipseTag = 'WGS84'
  integer, parameter, public :: noMIFs = 32

  ! Sine of the angle between the spacecraft velocity vector and the normal
  ! to the scan plane.  This angle was measured to be 0 +/- 0.0042 degrees.

  real(r8), parameter, private :: SinView = 0.0

  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: uars_to_emls_oa.f90,v $"
  private :: not_used_here 
  !---------------------------------------------------------------------------

contains ! ============= Public procedures ===================================

  subroutine uars_to_emls_oa ( N_Days, Limb_OA, EMLS_OA, dVI, dVIN )

    use Calc_GeodAngle_m, only: Calc_GeodAngle
    use Constants, only: Deg2Rad, Rad2Deg
    use Cross_m, only: Cross
    use Geometry, only: Omega => W, XYZ_to_Geod
    use OA_File_Contents, only: EMLS_OA_t
    use Rad_File_Contents, only: Limb_OA_t
    use Rotation_m, only: Rotate_3d
    use SDPToolkit, only: PGS_CSC_ECItoECR, PGS_CSC_ECRtoECI, PGS_CSC_GeoToECR, &
      & PGS_S_Success, PGS_SMF_GetMsg

    ! Args
    integer, intent(in) :: N_Days
    type(limb_oa_t), intent(in) :: Limb_OA
    type(emls_oa_t), intent(inout) :: EMLS_OA
    real(r8), intent(in) :: dVI    ! delta V angle per MIF, ECI
    real(r8), intent(in) :: dVIN   ! relative delta V length per MIF, ECI

    character(len=25) :: AsciiUTC
    integer :: I
    integer :: M
    integer :: MIF_Range(2)
    integer :: R                   ! Reference MIF number, from limb_oa%ref_mmif
    integer :: Stat
    real(r8) :: CosAlf
    real(r8) :: CosEps
    real(r8) :: CosPhi
    real(r8) :: CosTheta
    real(r8) :: CosXi
    real(r8) :: Delta
    real(r8) :: ECIV(6,noMIFs)
    real(r8) :: ECRToFOV(3,3,noMIFs)
    real(r8) :: ECRV(6,noMIFs)
    real(r8) :: FECR(3)
    real(r8) :: Flosf(3,3)
    real(r8) :: FMAF(3,3)
    real(r8) :: ForgedSecs
    real(r8) :: Ft(3)
    real(r8) :: Geod(3)
    real(r8) :: Ipf2ECI(3,3)
    real(r8) :: Los_Vec(3)
    real(r8) :: Orb_Norm(3)
    real(r8) :: Phi
    real(r8) :: PosECR(3)
    real(r8) :: SecTAI93
    real(r8) :: SinAlf
    real(r8) :: SinEps
    real(r8) :: SinPhi
    real(r8) :: SinTheta
    real(r8) :: SinXi
    real(r8) :: Theta
    real(r8) :: TngtVel(3)
    real(r8) :: Xi
    character(255) :: Err, Msg

    integer, parameter :: Moon_In_FOV = int(z'04000400') ! bits to set for EMLS
    real(r8), parameter :: MIF_Inc = 65.536 / noMIFs   ! increment per MIF in seconds

    ! Offsets from first MIF in milliseconds.  Offsets are from first MIF, not
    ! reference MIF, because the AsciiUTC used for PGS_CSC_ECRtoECI and
    ! PGS_CSC_ECItoECR is for the first MIF.
    real(r8), parameter :: Offsets(noMIFs) = [ ( (m-1) * mif_inc, m = 1, noMIFs ) ]

    ! Reference MIF number
    r = limb_oa%ref_mmif

    emls_oa%sc_geocalt = limb_oa%sat_gcrad * 1000.0   ! MIF resolved, meters

    emls_oa%geod_alt = limb_oa%tngt_geod_alt * 1000.0 ! MIF resolved, meters
    emls_oa%geod_lat = limb_oa%tngt_geod_lat          ! MIF resolved
    emls_oa%lon = limb_oa%tngt_long                   ! MIF resolved

  ! bright object status:

    emls_oa%bo_stat = 0  !clear to start
    if (limb_oa%ptg_fov_bo_diag_mmif_num /= 0) then  ! moon in FOV
      mif_range(1) = limb_oa%ptg_fov_bo_diag_mmif_fst - 1
      mif_range(2) = limb_oa%ptg_fov_bo_diag_mmif_lst - 1
      emls_oa%bo_stat(mif_range(1):mif_range(2)) = moon_in_fov
    end if

  ! Use same value for all MIFs:

    emls_oa%solartime = limb_oa%ref_solar_time
    emls_oa%solarzenith = limb_oa%ref_solar_zen
    do m = 1, noMIFs   ! same for every MIF
      emls_oa%sc_ypr(:,m) = limb_oa%ypr
      emls_oa%sc_ypr_rate(:,m) = limb_oa%ypr_rate
    end do

  ! Calculate TAI time at start of frame (MIF 1, not ref MIF):

    call frame_TAI ( limb_oa, secTAI93, asciiUTC, n_days, forgedSecs  )

    emls_oa%MAFStartTimeTAI= sectai93 - forgedSecs

  ! spacecraft MIF TAI:

    do m = 1, noMIFs
       emls_oa%sc_MIF_TAI(m) = secTAI93 + (m-1) * mif_inc - forgedsecs
    end do

  ! spacecraft ECR position at the reference MIF:

    stat = pgs_csc_geotoecr ( limb_oa%sat_long*Deg2Rad, &
                              limb_oa%sat_geod_lat*Deg2Rad, &
                              limb_oa%sat_geod_alt*1000.0d0, &
                              earthEllipseTag, posecr )
    if ( stat /= PGS_S_Success ) then
      print '(a,i0)', 'Status from PGS_CSC_GeoToECR = ', stat
      print '(a)', 'Is the environment variable PGSHOME set?'
      call PGS_SMF_GetMsg ( stat, err, msg )
      print '(a)', trim(err), trim(msg)
      stop
    end if

  ! Convert spacecraft ECR position in meters (and zero velocity) at the
  ! reference MIF to ECI:

    ecrV(1:3,r) = posECR
    ecrV(4:6,r) = 0
    stat = pgs_csc_ecrtoeci ( 1, asciiUTC, offsets(r), ecrV(:,r), eciV(:,r) )

  ! Get SC velocity (in meters/sec) at the reference MIF in ECI:

    eciV(4:6,r) = limb_oa%sat_vel * 1000.0

  ! Normal to the orbit plane in ECI, at the reference MIF, is the cross
  ! product of the spacecraft position and velocity vectors
    orb_norm = cross ( eciV(1:3,r), eciV(4:6,r) )

  !{ Angle between consecutive MIFs = $|V|\, T\, \sin(\theta) / |H|$, where
  !  $H$ is the spacecraft position vector, $V$ is the spacecraft velocity
  !  vector, $\sin\theta = |H \times V|\, /\, |H|\, |V|$, and $T$ is the MIF
  !  duration.
    delta = mif_inc * norm2 ( orb_norm ) / emls_oa%sc_geocalt(1)**2

  ! Rotate ECI positions and velocities before and after the reference MIF
  ! about the normal to the orbit plane by Delta * ( MIF# - R ).  Adjust the
  ! velocity vector length at each MIF according to the total relative change
  ! during the MAF.

    do m = 1, noMIFs
      if ( m == r ) cycle ! Don't rotate eciV at the reference MIF
      call rotate_3d ( eciV(1:3,r), delta * ( m-r ), orb_norm, eciV(1:3,m) )
      call rotate_3d ( eciV(4:6,r), dVI * ( m-r ), orb_norm, eciV(4:6,m) )
      eciV(4:6,m) = eciV(4:6,m) * ( ( m-r) * dVIN + 1.0 )
    end do
    ! Set the length of the SC ECR position vector to the SC Geocentric Altitude.
    ! The ECR length gotten using PGS_CSC_GeoToECR's computation of SC position
    ! from geodetic coordinates is different from the SC Geocentric Altitude by
    ! +/- 300 meters, with a period of about 120 MAFs.  We choose to believe the
    ! SC Geocentric Altitude.
    do m = 1, noMIFs
      eciV(1:3,m) = ( eciV(1:3,m) / norm2(eciV(1:3,m)) ) * emls_oa%sc_geocalt(m)
    end do

    emls_oa%sc_ECI = eciV(1:3,:)
    emls_oa%sc_VelECI = eciV(4:6,:)
  ! Now convert rotated positions and velocities to ECR.
    stat = pgs_csc_ecitoecr ( noMIFs, asciiUTC, offsets, eciV, ecrV )

    emls_oa%sc_ECR = ecrV(1:3,:)
    emls_oa%sc_VelECR = ecrV(4:6,:)

  ! Spacecraft geocentric geolocation
    emls_oa%sc_lon = atan2 ( ecrV(2,:), ecrV(1,:) ) * rad2deg
    emls_oa%sc_geoclat = atan2 ( ecrV(3,:), norm2(ecrV(1:2,:),1) ) * rad2deg

  ! Get SC geodetic latitude and altitude from ECR.  We already have longitude.

    do m = 1, noMIFs
      geod = xyz_to_geod ( ecrV(1:3,m) )
      emls_oa%sc_geodlat(m) = geod(1)*rad2deg
      emls_oa%sc_geodalt(m) = geod(3)
    end do

  ! Get GHz ECR, geoc_alt, geoc_lat from MIF-resolved quantities in the input.

    do m = 1, noMIFs
      stat = pgs_csc_geotoecr (limb_oa%tngt_long(m)*Deg2Rad, &
           limb_oa%tngt_geod_lat(m)*Deg2Rad, limb_oa%tngt_geod_alt(m)*1000.0d0, &
           earthEllipseTag, posecr) ! emls_oa%ECR(:,m))
      emls_oa%ECR(:,m) = posecr
      emls_oa%geoc_alt(m) = norm2 (emls_oa%ECR(:,m) )
      emls_oa%geoc_lat(m) = Rad2Deg * ATAN2 ( posecr(3), norm2(posecr(1:2)) )
    end do

  !{ Calculate ECRtoFOV.  Let $\alpha$ be the azimuth angle, $\epsilon$ be
  !  the scan angle, and $\xi$ be the scan angle as rotated during the scan.
  !  Then
  !  \begin{equation*}
  !  F_{\text{MAF}} = \left[ \begin{array}{ccccc}
  !    \cos\alpha \sin\epsilon \sin\xi + \sin\alpha \cos\xi &&
  !    \cos\alpha \sin\epsilon \cos\xi - \sin\alpha \sin\xi &&
  !    \cos\alpha \cos\epsilon \\
  !    \sin\alpha \sin\epsilon \sin\xi - \cos\alpha \cos\xi &&
  !    \sin\alpha \sin\epsilon \cos\xi - \cos\alpha \sin\xi &&
  !    \sin\alpha \cos\epsilon \\
  !    -\cos\epsilon \sin\xi && -\cos\epsilon \cos\xi && \sin\epsilon \\
  !    \end{array} \right]
  !  \end{equation*}

    do m = 1, noMIFs
      emls_oa%azimAngle(m) = limb_oa%ptg_fov_azim_offset(m) + 90.0
      cosalf = COS (emls_oa%azimAngle(m)*Deg2Rad)
      sinalf = SIN (emls_oa%azimAngle(m)*Deg2Rad)

      emls_oa%scanAngle(m) = limb_oa%ptg_fov_elev_offset(m) + 23.3
      coseps = COS (emls_oa%scanAngle(m)*Deg2Rad)
      sineps = SIN (emls_oa%scanAngle(m)*Deg2Rad)

      ! Changed to account for rotation of axes during a scan
      ! p.39 of UARS MLS cal.report, B1 is pointing reference
      xi = 113.6 + emls_oa%scanAngle(m) - 23.3
      cosxi = COS (xi*Deg2Rad)
      sinxi = SIN (xi*Deg2Rad)

      fmaf(:,1) = (/ cosalf*sineps*sinxi+sinalf*cosxi, sinalf*sineps*sinxi-cosalf*cosxi, -coseps*sinxi /)
      fmaf(:,2) = (/ cosalf*sineps*cosxi-sinalf*sinxi, sinalf*sineps*cosxi+cosalf*sinxi, -coseps*cosxi /)
      fmaf(:,3) = (/ cosalf*coseps,                    sinalf*coseps,                     sineps /)

      ipf2eci = TRANSPOSE (MATMUL (limb_oa%trans_inst2eci, fmaf))
      fmaf = TRANSPOSE (fmaf)
      do i = 1, 3
         eciV(1:3,m) = ipf2eci(i,:)
         eciV(4:6,m) = 0.0d0
         stat = pgs_csc_ecitoecr (1, asciiUTC, offsets(m), eciV(:,m), ecrV(:,m))
         ecrtofov(:,i,m) = ecrV(1:3,m)
      end do
      ecrtofov(:,:,m) = TRANSPOSE (ecrtofov(:,:,m))    ! Put in "right" order
      emls_oa%ECRtoFOV(:,m) = RESHAPE (ecrtofov(:,:,m), (/ 9 /))  ! make 2-d

  !{ Calculate GeodAngle (using REC's algorithm):
  !   Let $L =$ \text{limb_oa\%trans_inst2eci}.  Then
  !   ECI = $L\, F_{\text{MAF}}$.
  !
  !  \begin{equation*}
  !  F_{\text{LOS}} = \left[ \begin{array}{ccc}
  !  0           & 0          & -1 \\
  !  -\sin\alpha & \cos\alpha & 0  \\
  !  \cos\alpha  & \sin\alpha & 0  \\
  !    \end{array} \right]
  !  \end{equation*}

      flosf =  TRANSPOSE (RESHAPE ((/ &
           (/ 0.0d0,   0.0d0, -1.0d0 /), &
           (/ -sinalf, cosalf, 0.0d0 /), &
           (/  cosalf, sinalf, 0.0d0 /) /), (/ 3, 3 /)))
      call Calc_GeodAngle ( m, fmaf, flosf, emls_oa )

    end do

  ! Convert GHz ECR to ECI:

    ecrV(1:3,:) = emls_oa%ECR
    ecrV(4:6,:) = 0.0

    stat = pgs_csc_ecrtoeci (noMIFs, asciiUTC, offsets, ecrV, eciV)
    emls_oa%ECI = eciV(1:3,:)

  !{ Calculate LosAngle.  Let $\phi$ = longitude and $\theta$ = geodetic
  ! colatitude (90 degrees $-$ geodetic latitude).  Then
  !  \begin{equation*}
  !  F_{\text{MAF}} = \left[ \begin{array}{ccccc}
  !    -\sin\phi && -\cos\theta \cos\phi && \sin\theta \cos\phi \\
  !    \cos\phi  && -\cos\theta \sin\phi && \sin\theta \sin\phi \\
  !    0         && \sin\theta           && \cos\theta \\
  !    \end{array} \right]
  !  \end{equation*}
  !
  !  $F_{\text{ECR}_i} = \text{ECR to FOV}_{3,i}$, $i = 1 \dots 3$.
  !
  !  $F_t = F_{\text{ECR}}^T \, F_{\text{MAF}}$.
  !
  !  LosAngle = $\mod ( 90 - \tan^{-1} \frac{F_{t_2}}{F_{t_1}} + 360,\, 360)$.

    do m = 1, noMIFs
      phi = emls_oa%lon(m) * Deg2Rad
      cosphi = cos (phi)
      sinphi = sin (phi)
      theta = (90.0 - emls_oa%geod_lat(m)) * Deg2Rad
      costheta = cos (theta)
      sintheta = sin (theta)

      fmaf(:,1) = (/ -sinphi,           cosphi,          0.0_r8 /)
      fmaf(:,2) = (/ -costheta*cosphi, -costheta*sinphi, sintheta /)
      fmaf(:,3) = (/  sintheta*cosphi,  sintheta*sinphi, costheta /)
      fecr = [emls_oa%ecrtofov(3,m), emls_oa%ecrtofov(6,m), emls_oa%ecrtofov(9,m)]
      ft = matmul (fecr, fmaf)
      emls_oa%LosAngle(m) = mod ( 270.0_r8-atan2(ft(2), ft(1))*Rad2Deg, &
                                & 360.0_r8 )

    end do

  !{ Calculate LosVel.  Let $T$ be the tangent position in ECI, and $\omega$
  !  the Earth's angular rotation velocity. Then the tangent velocity, in ECI,
  !  is $V_t = \omega [ -T_y, T_x, 0 ]^T$.
  !  Let $S$ be the spacecraft position in ECI.  Then the line-of-sight vector,
  !  in ECI, is
  !  $L = T - S$.  Let $V_s$ be the spacecraft velocity in ECI and $\alpha$
  !  be the angle between $V_s$ and the normal to the scan plane.  Then the
  !  line-of-sight velocity,
  !  $V = ( ( V_t  - \sin(alpha) V_s ) \cdot L ) / |L|$.

    do m = 1, noMIFs
      tngtVel = omega * (/ -emls_oa%ECI(2,m), emls_oa%ECI(1,m), 0.0_r8 /)
      los_vec = emls_oa%ECI(:,m) - emls_oa%sc_ECI(:,m)
      ! Unlike limb_oa%sat_vel, emls_oa%sc_VelECI is now MIF resolved
      emls_oa%LosVel(m) = &
        & DOT_PRODUCT ( tngtVel - sinView * emls_oa%sc_VelECI(:,m), &
                      & los_vec ) / norm2 ( los_vec )
    end do

  !{ Calculate OrbY.  Let $\hat{n} = S \times V_s\, /\, | S \times V_s |$ be
  !  the unit normal to the orbit plane in ECI.  Then
  !  $Y_{\text{ORB}} = -T \cdot \hat{n}$.  Let $\gamma$ be the angle between
  !  the normal to the orbit plane and the tangent-point position vector, and
  !  $H_t = |T|$ be the tangent altitude in geocentric coordinates.  Then
  !  $Y_{\text{ORB}} = H_t \cos\gamma$.  This is the distance from the orbit
  !  plane to the small circle on which tangent positions appear.
  !
  !  Calculate orbit inclination as the inverse cosine of the Z component of
  !  the orbit normal vector.  We assume it's always near 57 degrees, so use
  !  the absolute value of the Z component so we get the correct value when
  !  the yaw maneuver has the velocity vector pointing such that the orbit
  !  normal is in the southern hemisphere.
  !
  !  The orbit inclination is not actually MIF resolved, because the spacecraft
  !  position and velocity vectors were MIF resolved by rotating in the ECI
  !  orbit plane.  Thus, the normal to the plane is the same throughout the MAF.

    do m = 1, noMIFs
    ! Unit normal to the orbit plane, in ECI
      orb_norm = cross ( emls_oa%sc_ECI(:,m), emls_oa%sc_VelECI(:,m), norm=.true. )
      emls_oa%OrbY(m) = - DOT_PRODUCT ( emls_oa%ECI(:,m), orb_norm )
      emls_oa%sc_orbIncl(m) = acos(orb_norm(3)) * rad2deg
    end do

    ! Remap GHz/Lon
    where (emls_oa%lon > 180.0) emls_oa%lon = emls_oa%lon - 360.0

  end subroutine uars_to_emls_oa

  subroutine Frame_TAI ( limb_oa, SecTAI93, AsciiUTC, n_days, ForgedSecs )

  ! Calculate TAI time at start of frame.

    use Dates_Module, only: SecondsBetween2UTCs
    use MLSKinds, only: R8
    use Rad_File_Contents, only: limb_oa_t

    type(limb_oa_t), intent(in) :: limb_oa
    real(r8), intent(out) :: SecTAI93
    character(len=25), intent(out), optional :: AsciiUTC
    integer, intent(in), optional :: n_days
    real(r8), intent(out), optional :: ForgedSecs

    integer, external :: pgs_td_utctotai

    character(len=25) :: MyAsciiUTC, ForgedAsciiUTC

    integer :: Hrs
    integer :: MIF1_ms
    integer :: Mins
    integer :: Ms
    integer :: N_Years
    real(r8) :: Secs
    integer :: Stat
    integer :: Year
    integer :: YrDoy

    mif1_ms = (limb_oa%ref_mmif - 1) * 2048   ! millisecs from MIF 1 to ref MIF
    yrdoy = limb_oa%ref_time(1)  ! - n_days   ! 1000*year plus day of year
    ms = limb_oa%ref_time(2)     ! millisecs of day for ref_mmif
    ms = ms - mif1_ms            ! millisecs at start of MAF
    if (ms < 0) then             ! in previous day!
      ms = ms + 86400000
      yrdoy = yrdoy - 1
    end if
    hrs = mod (ms/3600000, 24)
    mins = mod (ms/60000, 60)
    secs = mod (real(ms), 60000.0) /1000.0
    year = yrdoy / 1000
    if (year > 99) then      ! take care of years 2000 or greater
       year = mod(year, 100) + 2000
    else                     ! years in the 1900's
       year = year + 1900
    end if

    write (myAsciiUTC, fmt= &
     '(i4, "-", i3.3, "T", i2.2, ":", i2.2, ":", f9.6, "Z", TL10, i2.2)') &
     year, mod(yrdoy, 1000), hrs, mins, secs, int(secs)  ! force leading 0's
    stat = pgs_td_utctotai (myAsciiUTC, sectai93)

    if ( present(n_days) ) then
      ! Adjust for possible backdating
      if ( n_days > 999 ) then
        ! Account for our convention that a "year" has 1000 days
        n_years = (n_days/1000)
        write (forgedasciiutc, fmt= &
         '(i4, "-", i3.3, "T", i2.2, ":", i2.2, ":", f9.6, "Z", TL10, i2.2)') &
         year-n_years, mod(yrdoy, 1000), hrs, mins, secs, int(secs)  ! force leading 0's
         forgedsecs = secondsBetween2UTCs ( forgedasciiutc, myAsciiUTC )
      else if ( n_days > 0 ) then
        forgedsecs = n_days * 24 * 3600
      else
        forgedsecs = 0.d0
      end if
    end if

    if ( present(asciiUTC) ) asciiUTC = myAsciiUTC

  end subroutine Frame_TAI

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: uars_to_emls_oa.f90,v 1.8 2015/04/21 01:13:25 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module uars_to_emls_oa_m

! $Log: uars_to_emls_oa.f90,v $
! Revision 1.8  2015/04/21 01:13:25  vsnyder
! Comment out printing ForgedSecs
!
! Revision 1.7  2015/01/24 02:09:16  vsnyder
! MIF resolve most quantities
!
! Revision 1.6  2015/01/22 02:18:56  vsnyder
! PGS_Interfaces.f90
!
! Revision 1.5  2014/12/11 00:48:51  vsnyder
! Move external procedures into modules.  Add copyright and CVS lines.
! Compute MIF geolocation (except height) for SC.  Compute MIF-resolved
! SC velocity.  Some cannonball polishing.
!
@


1.8
log
@Comment out printing ForgedSecs
@
text
@d46 2
a47 1
    use SDPToolkit, only: PGS_CSC_ECItoECR, PGS_CSC_ECRtoECI, PGS_CSC_GeoToECR
d60 1
d91 1
d94 5
a98 1
    real, parameter :: MIF_Inc = 65.536 / noMIFs   ! increment per MIF in seconds
d101 3
d128 1
a128 1
  ! Calculate TAI time at start of frame:
d137 1
a137 1
       emls_oa%sc_MIF_TAI(m) = sectai93 + (m-1) * mif_inc - forgedsecs
d140 1
a140 1
  ! spacecraft ECR position at the first MIF:
d146 7
d154 2
a155 2
  ! Convert spacecraft ECR position in meters (and zero velocity) at the first
  ! MIF to ECI:
d157 3
a159 3
    ecrV(1:3,1) = posECR
    ecrV(4:6,1) = 0
    stat = pgs_csc_ecrtoeci ( 1, asciiUTC, offsets, ecrV, eciV )
d161 1
a161 1
  ! Get SC velocity (in meters/sec) at the first MIF in ECI:
d163 1
a163 1
    eciV(4:6,1) = limb_oa%sat_vel * 1000.0
d165 1
a165 1
  ! Normal to the orbit plane in ECI, at the first MIF, is the cross
d167 1
a167 1
    orb_norm = cross ( eciV(1:3,1), eciV(4:6,1) )
d175 10
a184 7
  ! Rotate ECI positions and velocities after the first MIF about the normal
  ! to the orbit plane by Delta * ( MIF# - 1 ).  Adjust the velocity vector
  ! length at each MIF according to the total relative change during the MAF.
    do m = 2, noMIFs
      call rotate_3d ( eciV(1:3,1), delta * ( m-1 ), orb_norm, eciV(1:3,m) )
      call rotate_3d ( eciV(4:6,1), dVI * ( m-1 ), orb_norm, eciV(4:6,m) )
      eciV(4:6,m) = eciV(4:6,m) * ( ( m-1) * dVIN + 1.0 )
d215 1
a215 1
  ! Get GHz ECR, geoc_alt, geoc_lat:
d220 1
a220 1
           earthEllipseTag, posecr) !emls_oa%ECR(:,m))
d222 2
a223 4
      emls_oa%geoc_alt(m) = SQRT (emls_oa%ECR(1,m)**2 + emls_oa%ECR(2,m)**2 + &
           emls_oa%ECR(3,m)**2)
      emls_oa%geoc_lat(m) = Rad2Deg * ATAN2 (posecr(3) , &
           SQRT (posecr(1)**2 + posecr(2)**2))
d250 3
a252 2
      ! Changed to account for rotation of axes during ascan
      xi = 113.6 + emls_oa%scanAngle(m) - 23.3 ! p.30 of UARS MLS cal.report, B1 is pointing reference
d384 1
a384 1
  ! Calculate TAI time at start of frame:
d410 1
a410 1
    mif1_ms = (limb_oa%ref_mmif - 1) * 2048   ! millisecs of MIF 1
a448 2
! print '(a,i0)', 'ForgedSecs ', forgedSecs

d456 1
a456 1
       "$Id: uars_to_emls_oa.f90,v 1.7 2015/01/24 02:09:16 vsnyder Exp $"
d466 3
@


1.7
log
@MIF resolve most quantities
@
text
@d120 1
a120 1
    call frame_TAI ( limb_oa, secTAI93, asciiUTC, n_days, forgedSecs )
d317 1
a317 1
  !  Let $S$ be the spacecraft position in ECI.  Then the line-of-sight vector
d422 1
a422 1
        forgedsecs = secondsBetween2UTCs ( forgedasciiutc, myAsciiUTC )
d430 2
d439 1
a439 1
       "$Id: uars_to_emls_oa.f90,v 1.6 2015/01/22 02:18:56 vsnyder Exp $"
d449 3
@


1.6
log
@PGS_Interfaces.f90
@
text
@d14 2
d24 4
a27 1
  logical, parameter, private :: Deebug = .false.
d37 1
a37 2
  subroutine uars_to_emls_oa ( n_days, limb_oa, emls_oa, dV, dVN, dVV, Sat_Vel, &
    & In_posECR, Vel_ECI, dVI, dVIN, In_AsciiUTC )
d40 1
a40 1
    use Constants, only: Deg2Rad, Rad2Deg, Pi
d42 3
a44 5
    use Geometry, only: GeocToGeodLat, Omega => W, XYZ_to_Geod
    use MLSKinds, only: R8
    use OA_File_Contents, only: emls_oa_t
    use PGS_Interfaces, only: pgs_csc_ecitoecr, pgs_csc_ecrtoeci, pgs_csc_geotoecr
    use Rad_File_Contents, only: limb_oa_t
d46 1
a46 1
    use SDPToolkit, only: PGS_S_SUCCESS
d49 3
a51 9
    integer, intent(in) :: n_days
    type(limb_oa_t), intent(in) :: limb_oa
    type(emls_oa_t), intent(inout) :: emls_oa
    real(r8), intent(in) :: dV     ! delta V angle per MIF, Radians, ECR
    real(r8), intent(in) :: dVN    ! relative delta V length per MIF (tiny) km/s
    real(r8), intent(in) :: dVV(3) ! delta V per MAF, in ECR, km/s
    real(r8), intent(in) :: Sat_Vel(3,2)   ! Satellite velocities, in ECR, m/s
    real(r8), intent(in) :: In_posECR(3,2) ! Satellite positions, ECR, meters
    real(r8), intent(in) :: Vel_ECI(3,2)   ! Satellite velocities, ECI, km/s
a53 1
    character(*), intent(in) :: In_AsciiUTC(2)
d55 37
a91 9
    integer :: i, m, mif_range(2), stat
    real(r8) :: forgedsecs
    real(r8) :: cosalf, sinalf, coseps, sineps, cosphi, sinphi, costheta, &
         sintheta
    real(r8) :: fmaf(3,3), flosf(3,3), fecr(3), &
         ft(3), ipf2eci(3,3), ecrtofov(3,3,noMIFs), phi, theta
    integer, parameter :: moon_in_fov = int(z'04000400')  ! bits to set for EMLS
    real, parameter :: orbincl = 57.0  ! orbit incline
    real, parameter :: mif_inc = 65.536 / noMIFs   ! increment per MIF in seconds
a92 6
    real(r8) :: eciV(6,noMIFs), ecrV(6,noMIFs), Geod(3), los_vec(3), &
         orb_norm(3), posecr(3), sectai93, tngtvel(3)
    real(r8) :: Delta, xi, cosxi, sinxi
    real(r8) :: dVVR(3) ! delta V, in ECR, per MIF
    real(r8) :: PosECI(3,2)
    character(len=25) :: asciiutc
a94 1
   !emls_oa%sc_orbincl = orbincl                      ! MIF resolved
a141 3
write ( 42, '(2x,2a)' ) '-------- In_PosECR -------- --------- PosECR ----------', &
' --------- Vel ECI ---------'
write ( 42, '(2x,5(3f9.2:","))' ) in_posECR(:,1)/1000, posECR/1000, limb_oa%sat_vel*1000
a147 16
  ! Convert position and velocity back to ECR (to get SC velocity in ECR):

    stat = pgs_csc_ecitoecr ( 1, asciiUTC, offsets, eciV, ecrV )
write ( 42,'(2x,2a)' ) ' ------------------------ ECIV ------------------------', &
& ' ------------------------ ECRV ------------------------'
write ( 42, '(2x,4(3f9.2:","))' ) eciV(1:3,1)/1000,eciV(4:6,1), ecrV(1:3,1)/1000,ecrV(4:6,1)
write ( 42, '(2x,3a)' ) '------- Vel ECR here ------ --------- Vel ECR 1 -------', &
& ' --------- Vel ECR 2 ------- --------- dVV ECR ---------', &
& ' -------- Delta Vel -------- --------- Vel ECI ---------'
write ( 42, '(2x,6(3f9.2:","))' ) ecrV(4:6,1), sat_vel, dVV, sat_vel(:,2)-sat_vel(:,1), limb_oa%sat_vel*1000
    dVVR = dVV / noMIFs

  ! Normal to the orbit plane in ECR, at the first MIF, is the cross
  ! product of the spacecraft position and velocity vectors
    orb_norm = cross ( ecrV(1:3,1), ecrV(4:6,1) )

a157 21
!   ! Rotate ECR positions and velocities after the first MIF about the normal
!   ! to the orbit plane by Delta * ( MIF# - 1 ).  Adjust the velocity vector
!   ! length at each MIF according to the total relative change during the MAF.
! write ( 42, '(2x,2a,3x,a)' ) '------- Vel ECR here ------ --------- dVV ECR ---------', &
! & ' --- |Vel|', asciiUTC
! write ( 42, '(i2, 5(3f9.2:","))' ) 1, ecrV(4:6,1), dVVR*noMIFs, norm2(ecrV(4:6,1))
!     do m = 2, noMIFs
!       call rotate_3d ( ecrV(1:3,1), delta * ( m-1 ), orb_norm, ecrV(1:3,m) )
!       call rotate_3d ( ecrV(4:6,1), dV * ( m-1 ), orb_norm, ecrV(4:6,m) )
!       ecrV(4:6,m) = ecrV(4:6,m) * ( ( m-1) * dVN + 1.0 )
! write ( 42, '(i2, 5(3f9.2:","))' ) m, ecrV(4:6,m), dVVR*(m-1), norm2(ecrV(4:6,m))
!     end do
!     ! Set the length of the SC ECR position vector to the SC Geocentric Altitude.
!     ! The ECR length gotten using PGS_CSC_GeoToECR's computation of SC position
!     ! from geodetic coordinates is different from the SC Geocentric Altitude by
!     ! +/- 300 meters, with a period of about 120 MAFs.  We choose to believe the
!     ! SC Geocentric Altitude.
!     do m = 1, noMIFs
!       ecrV(1:3,m) = ( ecrV(1:3,m) / norm2(ecrV(1:3,m)) ) * emls_oa%sc_geocalt(m)
!     end do

a160 3
write ( 42, '(2x,2a,3x,a)' ) '------- Vel ECI here ------ --------- dVV ECI ---------', &
& ' --- |Vel|', asciiUTC
write ( 42, '(i2, 5(3f9.2:","))' ) 1, eciV(4:6,1), dVV*noMIFs, norm2(eciV(4:6,1))
a164 1
write ( 42, '(i2, 5(3f9.2:","))' ) m, eciV(4:6,m), dVV*(m-1), norm2(eciV(4:6,m))
a182 5
!   ! Now convert rotated positions and velocities back to ECI.
!     stat = pgs_csc_ecrtoeci ( noMIFs, asciiUTC, offsets, ecrV, eciV )
!     emls_oa%sc_ECI = eciV(1:3,:)
!     emls_oa%sc_VelECI = eciV(4:6,:)

d316 1
a316 1
  !  $V_t = \omega [ -T_y, T_x, 0 ]^T$.
d318 3
a320 2
  !  in ECI,
  !  $L = T - S$.  Let $V_s$ be the spacecraft velocity in ECI.  Then the
d322 1
a322 1
  !  $V = ( ( V_t  - V_s ) \cdot L ) / |L|$.
d328 3
a330 2
      emls_oa%LosVel(m) = DOT_PRODUCT ( tngtVel - emls_oa%sc_VelECI(:,m), &
                                      & los_vec ) / norm2 ( los_vec )
d338 12
a349 1
  !  $Y_{\text{ORB}} = H_t \cos\gamma$.
d355 1
a360 15
  !!$write (30, *) limb_oa%ptg_fov_azim_offset
  !!$write (31, *) limb_oa%ptg_fov_elev_offset
  !!$write (32, *) limb_oa%sat_geod_alt
  !!$write (33, *) limb_oa%sat_geod_lat
  !!$write (34, *) limb_oa%sat_long
  !!$write (35, *) limb_oa%tngt_geod_alt
  !!$write (36, *) limb_oa%tngt_geod_lat
  !!$write (37, *) limb_oa%tngt_long
  !!$write (40, *) emls_oa%ECR
  !!$write (81, *) emls_oa%sc_ECI
  !!$write (82, *) emls_oa%sc_VelECI
  !!$write (83, *) emls_oa%ECI

  !write (3x, *) limb_oa%

a411 1
    if ( deebug ) print *, 'asciiutc: ', trim(myAsciiUTC)
d437 1
a437 1
       "$Id: uars_to_emls_oa.f90,v 1.5 2014/12/11 00:48:51 vsnyder Exp $"
d447 3
@


1.5
log
@Move external procedures into modules.  Add copyright and CVS lines.
Compute MIF geolocation (except height) for SC.  Compute MIF-resolved
SC velocity.  Some cannonball polishing.
@
text
@d17 4
a20 1
  public :: UARS_to_EMLS_OA
d26 1
a26 1
       "$RCSfile: ConstructQuantityTemplates.f90,v $"
d32 2
a33 1
  subroutine uars_to_emls_oa ( n_days, limb_oa, emls_oa, Angle )
d38 1
a38 2
    use Dates_Module, only: SecondsBetween2UTCs
    use Geometry, only: GeocToGeodLat, Omega => W
d41 1
d50 9
a58 1
    real, intent(in) :: Angle ! Between first MIFs of consecutive MAFs, radians
d60 1
a60 3
    integer, parameter :: noMIFs = 32
    integer :: n_years
    integer :: i, m, mif_range(2), ms, hrs, mins, yrdoy, stat, mif1_ms, year
d62 1
a62 1
    real(r8) :: secs, cosalf, sinalf, coseps, sineps, cosphi, sinphi, costheta, &
d64 2
a65 2
    real(r8) :: fcol1(3), fcol2(3), fcol3(3), fmaf(3,3), flosf(3,3), fecr(3), &
         ft(3), ipf2eci(3,3,noMIFs), ecrtofov(3,3,noMIFs), phi, theta
d69 3
a71 3
    real(r8) :: eciV(6,noMIFs), ecrV(6,noMIFs), los_vec(3,noMIFs), &
         offsets(noMIFs), orb_norm(3), posecr(3), rotated(3), sectai93, &
         tngtvel(3)
d73 10
a82 17
    character(len=25) :: asciiutc, forgedasciiutc, err, msg
    character (len=*), parameter :: earthellipstag = 'WGS84', nl = char(10)
    integer, external :: pgs_td_utctotai, pgs_csc_geotoecr, pgs_smf_getmsg, &
         pgs_csc_ecrtoeci, pgs_csc_ecitoecr

  ! Initialize offsets per mif in seconds:

    do m = 1, noMIFs
      offsets(m) = (m-1) * mif_inc
    end do

    emls_oa%sc_geocalt = limb_oa%sat_gcrad * 1000.0    ! array copy
   !emls_oa%sc_orbincl = orbincl                       ! array copy

    emls_oa%geod_alt = limb_oa%tngt_geod_alt * 1000.0  ! meters
    emls_oa%geod_lat = limb_oa%tngt_geod_lat
    emls_oa%lon = limb_oa%tngt_long
d104 1
a104 23
    mif1_ms = (limb_oa%ref_mmif - 1) * 2048   ! millisecs of MIF 1
    yrdoy = limb_oa%ref_time(1)  ! - n_days      ! year plus day of year
    ms = limb_oa%ref_time(2)     ! millisecs of day for ref_mmif
    ms = ms - mif1_ms            ! millisecs at start of MAF
    if (ms < 0) then             ! in previous day!
      ms = ms + 86400000
      yrdoy = yrdoy - 1
    end if
    hrs = mod (ms/3600000, 24)
    mins = mod (ms/60000, 60)
    secs = amod (float(ms), 60000.0) /1000.0
    year = yrdoy / 1000
    if (year > 99) then      ! take care of years 2000 or greater
       year = mod(year, 100) + 2000
    else                     ! years in the 1900's
       year = year + 1900
    end if

    write (asciiutc, fmt= &
     '(i4, "-", i3.3, "T", i2.2, ":", i2.2, ":", f9.6, "Z", TL10, i2.2)') &
     year, mod(yrdoy, 1000), hrs, mins, secs, int(secs)  ! force leading 0's
    if ( deebug ) print *, 'asciiutc: ', trim(asciiutc)
    stat = pgs_td_utctotai (asciiutc, sectai93)
d106 1
a106 16
    emls_oa%MAFStartTimeTAI= sectai93
    ! Adjust for possible backdating
    if ( n_days > 999 ) then
      ! Account for our convention that a "year" has 1000 days
      n_years = (n_days/1000)
      write (forgedasciiutc, fmt= &
       '(i4, "-", i3.3, "T", i2.2, ":", i2.2, ":", f9.6, "Z", TL10, i2.2)') &
       year-n_years, mod(yrdoy, 1000), hrs, mins, secs, int(secs)  ! force leading 0's
      forgedsecs = secondsbetween2utcs ( forgedasciiutc, asciiutc )
      emls_oa%MAFStartTimeTAI = sectai93 - forgedsecs
    elseif ( n_days > 0 ) then
      forgedsecs = n_days * 24 * 3600
      emls_oa%MAFStartTimeTAI = sectai93 - forgedsecs
    else
      forgedsecs = 0.d0
    end if
d114 1
a114 1
  ! spacecraft ECR positions, at first the same for all MIFs:
d119 1
a119 6
                              earthellipstag, posecr )
    do m = 1, noMIFs
      emls_oa%sc_ECR(:,m) = posecr ! Same ECR for every MIF
    end do
    emls_oa%sc_geoclat(:) = ATAN2 ( posecr(3), &
                                  & SQRT (posecr(1)**2 + posecr(2)**2)) * rad2deg
d121 2
a122 9
  ! Convert spacecraft ECR position to ECI:

    ecrV(1:3,:) = emls_oa%sc_ECR
    ecrV(4:6,:) = 0.0

    stat = pgs_csc_ecrtoeci ( noMIFs, asciiUTC, offsets, ecrV, eciV )
    emls_oa%sc_ECI = eciV(1:3,:)

  ! Get SC velocity (in meters/sec) in ECI:
d124 75
d200 1
a200 1
       eciV(4:6,m) = limb_oa%sat_vel * 1000.0 ! only need one set of values
d203 3
a205 2
  ! Convert back to ECR (to get SC velocity in ECR):

a207 11
  ! Rotate ECR positions and velocities after the first MIF about the normal
  ! to the orbit plane by Angle/noMIFs * ( MIF# - 1 ).

    orb_norm = cross ( ecrV(1:3,1), ecrV(4:6,1), norm=.true. )
    delta = angle / noMIFs
    do m = 2, noMIFs
      call rotate_3d ( ecrV(1:3,m), delta * ( m-1 ), orb_norm, rotated )
      ecrV(1:3,m) = rotated
      call rotate_3d ( ecrV(4:6,m), delta * ( m-1 ), orb_norm, rotated )
      ecrV(4:6,m) = rotated
    end do
d211 4
a214 4
  ! Now convert rotated positions and velocities back to ECI.
    stat = pgs_csc_ecrtoeci ( noMIFs, asciiUTC, offsets, ecrV, eciV )
    emls_oa%sc_ECI = eciV(1:3,:)
    emls_oa%sc_VelECI = eciV(4:6,:)
d216 1
a216 1
  ! Spacecraft geolocation
d218 3
a220 2
    emls_oa%sc_geoclat = atan2 ( ecrV(3,:), sqrt(ecrV(1,:)**2 + ecrV(2,:)**2) ) * &
                       & rad2deg
d222 5
a226 8
  ! Remap sc/Lon
    where (emls_oa%sc_lon > 180.0)
       emls_oa%sc_lon = emls_oa%sc_lon - 360.0
    end where
  ! Get SC geodetic latitude from its geocentric latitude  
    emls_oa%sc_geodlat = geocToGeodLat ( emls_oa%sc_geoclat )
  ! SC Geodetic altitude is the same for every MIF; hope that's OK
    emls_oa%sc_geodalt = limb_oa%sat_geod_alt * 1000.0  ! meters
d228 1
a228 1
  ! GHz ECR and geoc_alt and geoc_lat:
d233 1
a233 1
           earthellipstag, posecr) !emls_oa%ECR(:,m))
d241 14
a254 1
  ! Calculate ECRtoFOV:
d270 5
a274 9
      fcol1 = (/ cosalf*sineps*sinxi+sinalf*cosxi, sinalf*sineps*sinxi-cosalf*cosxi, -coseps*sinxi /)
      fcol2 = (/ cosalf*sineps*cosxi-sinalf*sinxi, sinalf*sineps*cosxi+cosalf*sinxi, -coseps*cosxi /)
      fcol3 = (/ cosalf*coseps, sinalf*coseps, sineps /)

      fmaf = RESHAPE((/ fcol1, fcol2, fcol3 /), (/ 3, 3 /))
      ipf2eci(:,:,m) = TRANSPOSE (MATMUL (limb_oa%trans_inst2eci, fmaf))
      flosf =  TRANSPOSE (RESHAPE ((/ (/ 0.0d0, 0.0d0, -1.0d0 /), &
           (/ -sinalf, cosalf, 0.0d0 /), &
           (/ cosalf, sinalf, 0.0d0 /) /), (/ 3, 3 /)))
d277 1
a277 1
         eciV(1:3,m) = ipf2eci(i,:,m)
d285 11
a295 1
    ! Calculate GeodAngle (using REC's algorithm):
d297 4
d313 15
a327 1
  ! Calculate LosAngle
d337 3
a339 4
      fcol1 = (/ -sinphi, cosphi, 0.0d0 /)
      fcol2 = (/ -costheta*cosphi, -costheta*sinphi, sintheta /)
      fcol3 = (/ sintheta*cosphi, sintheta*sinphi, costheta /)
      fmaf = RESHAPE((/ fcol1, fcol2, fcol3 /), (/ 3, 3 /))
d342 2
a343 2
      emls_oa%LosAngle(m) = mod ( 90.0d0-atan2 (ft(2), ft(1))*Rad2Deg+360.0, &
                                & 360.0d0 )
d347 8
a354 1
  ! Calculate LosVel
d357 5
a361 5
      tngtVel = omega * (/ -emls_oa%ECI(2,m), emls_oa%ECI(1,m), 0.0d0 /)
      los_vec(:,m) = emls_oa%ECI(:,m) - emls_oa%sc_ECI(:,m)
      los_vec(:,m) = los_vec(:,m) / SQRT (SUM (los_vec(:,m)**2))
      emls_oa%LosVel(m) = DOT_PRODUCT (tngtVel, los_vec(:,m)) - &
           DOT_PRODUCT (limb_oa%sat_vel*1000.0d0, los_vec(:,m))
d364 6
a369 1
  ! Calculate OrbY
d372 1
d374 1
a374 1
      emls_oa%OrbY(m) = DOT_PRODUCT (-emls_oa%ECI(:,m), orb_norm)
d397 72
d472 1
a472 1
       "$Id: ConstructQuantityTemplates.f90,v 2.177 2014/09/05 00:39:49 vsnyder Exp $"
d481 6
a486 1
! $Log: $
@


1.4
log
@Correct errors in MAFStartTimeTAI, lon, and MIF_TAI
@
text
@d1 200
a200 1
subroutine uars_to_emls_oa ( n_days )
a201 57
  use Constants, ONLY: Deg2Rad, Rad2Deg, Pi
  use dates_module, only: secondsBetween2UTCs
  use Geometry, ONLY: Omega => W
  use oa_file_contents, ONLY: emls_oa
  use rad_file_contents, ONLY: limb_oa
  use SDPToolkit, ONLY: PGS_S_SUCCESS

  implicit none
  ! Args
  integer, intent(in) :: n_days
  !
  integer, parameter :: nomifs = 32
  integer :: n_years
  integer :: i, m, mif_range(2), ms, hrs, mins, yrdoy, stat, mif1_ms, year
  real*8 :: forgedsecs
  real*8 :: secs, cosalf, sinalf, coseps, sineps, cosphi, sinphi, costheta, &
       sintheta
  real*8 :: fcol1(3), fcol2(3), fcol3(3), fmaf(3,3), flosf(3,3), fecr(3), &
       ft(3), ipf2eci(3,3,nomifs), ecrtofov(3,3,nomifs), phi, theta
  integer, parameter :: moon_in_fov = x'04000400'  ! bits to set for EMLS
  real, parameter :: orbincl = 57.0  ! orbit incline
  real, parameter :: mif_inc = 65.536 / 32   ! increment per MIF in seconds
  REAL*8 :: sectai93, eciV(6,nomifs), ecrV(6,nomifs), offsets(nomifs), &
       tngtvel(3), los_vec(3,nomifs), posecr(3), rv(3), orb_norm(3)
  real*8 :: xi, cosxi, sinxi
  character*25 asciiutc, forgedasciiutc, err, msg
  CHARACTER (LEN=*), PARAMETER :: earthellipstag = 'WGS84', nl = char(10)
  integer, external :: pgs_td_utctotai, pgs_csc_geotoecr, pgs_smf_getmsg, &
       pgs_csc_ecrtoeci, pgs_csc_ecitoecr

! Initialize offsets per mif in seconds:

  do m = 1, nomifs
     offsets(m) = (m-1) * mif_inc
  enddo

  emls_oa%sc_geocalt = limb_oa%sat_gcrad * 1000.0    ! array copy
  !emls_oa%sc_orbincl = orbincl                       ! array copy

  emls_oa%geod_alt = limb_oa%tngt_geod_alt * 1000.0  ! meters
  emls_oa%geod_lat = limb_oa%tngt_geod_lat
  emls_oa%lon = limb_oa%tngt_long

! bright object status:

  emls_oa%bo_stat = 0  !clear to start
  if (limb_oa%ptg_fov_bo_diag_mmif_num /= 0) then  ! moon in FOV
     mif_range(1) = limb_oa%ptg_fov_bo_diag_mmif_fst - 1
     mif_range(2) = limb_oa%ptg_fov_bo_diag_mmif_lst - 1
     emls_oa%bo_stat(mif_range(1):mif_range(2)) = moon_in_fov
  endif

! Use same value for all MIFs:

  emls_oa%solartime = limb_oa%ref_solar_time
  emls_oa%solarzenith = limb_oa%ref_solar_zen
  emls_oa%sc_lon = limb_oa%sat_long
d203 137
a339 205
  where (emls_oa%sc_lon > 180.0)
     emls_oa%sc_lon = emls_oa%sc_lon - 360.0
  end where
  emls_oa%sc_geodlat = limb_oa%sat_geod_lat
  emls_oa%sc_geodalt = limb_oa%sat_geod_alt * 1000.0  ! meters
  do m = 1, nomifs   ! same for every MIF
     emls_oa%sc_ypr(:,m) = limb_oa%ypr
     emls_oa%sc_ypr_rate(:,m) = limb_oa%ypr_rate
  enddo

! Calculate TAI time at start of frame:

  mif1_ms = (limb_oa%ref_mmif - 1) * 2048   ! millisecs of MIF 1
  yrdoy = limb_oa%ref_time(1)  ! - n_days      ! year plus day of year
  ms = limb_oa%ref_time(2)     ! millisecs of day for ref_mmif
  ms = ms - mif1_ms            ! millisecs at start of MAF
  if (ms < 0) then             ! in previous day!
     ms = ms + 86400000
     yrdoy = yrdoy - 1
  endif
  hrs = mod (ms/3600000, 24)
  mins = mod (ms/60000, 60)
  secs = amod (float(ms), 60000.0) /1000.0
  year = yrdoy / 1000
  if (year > 99) then      ! take care of years 2000 or greater
     year = mod(year, 100) + 2000
  else                     ! years in the 1900's
     year = year + 1900
  endif

  write (asciiutc, fmt= &
   '(i4, "-", i3.3, "T", i2.2, ":", i2.2, ":", f9.6, "Z", TL10, i2.2)') &
   year, mod(yrdoy, 1000), hrs, mins, secs, int(secs)  ! force leading 0's
  print *, 'asciiutc: ', trim(asciiutc)
  stat = pgs_td_utctotai (asciiutc, sectai93)

  emls_oa%MAFStartTimeTAI= sectai93
  ! Adjust for possible backdating
  if ( n_days > 999 ) then
    ! Account for our convention that a "year" has 1000 days
    n_years = (n_days/1000)
    write (forgedasciiutc, fmt= &
     '(i4, "-", i3.3, "T", i2.2, ":", i2.2, ":", f9.6, "Z", TL10, i2.2)') &
     year-n_years, mod(yrdoy, 1000), hrs, mins, secs, int(secs)  ! force leading 0's
    forgedsecs = secondsbetween2utcs ( forgedasciiutc, asciiutc )
    emls_oa%MAFStartTimeTAI = sectai93 - forgedsecs
  elseif ( n_days > 0 ) then
    forgedsecs = n_days * 24 * 3600
    emls_oa%MAFStartTimeTAI = sectai93 - forgedsecs
  else
    forgedsecs = 0.d0
  endif

! spacecraft MIF TAI:

  do m = 1, nomifs
     emls_oa%sc_MIF_TAI(m) = sectai93 + (m-1) * mif_inc - forgedsecs
  enddo

! spacecraft ECR:

  do m = 1, nomifs
     stat = pgs_csc_geotoecr (limb_oa%sat_long*Deg2Rad, &
          limb_oa%sat_geod_lat*Deg2Rad, limb_oa%sat_geod_alt*1000.0d0, &
          earthellipstag, posecr) !emls_oa%sc_ECR(:,m))
     emls_oa%sc_ECR(:,m) = posecr
     emls_oa%sc_geoclat(m) = Rad2Deg * ATAN (posecr(3) / &
          SQRT (posecr(1)**2 + posecr(2)**2))
  enddo

! Convert spacecraft ECR to ECI:

  ecrV(1:3,:) = emls_oa%sc_ECR
  ecrV(4:6,:) = 0.0

  stat = pgs_csc_ecrtoeci (nomifs, asciiUTC, offsets, ecrV, eciV)
  emls_oa%sc_ECI = eciV(1:3,:)

! Convert back to ECR and set velocity (in meters/sec):

  do m = 1, nomifs
     eciV(4:6,m) = limb_oa%sat_vel * 1000.0 ! only need one set of values
  enddo

  stat = pgs_csc_ecitoecr (nomifs, asciiUTC, offsets, eciV, ecrV)
  emls_oa%sc_VelECI = eciV(4:6,:)
  emls_oa%sc_VelECR = ecrV(4:6,:)

! GHz ECR and geoc_alt and geoc_lat:

  do m = 1, nomifs
     stat = pgs_csc_geotoecr (limb_oa%tngt_long(m)*Deg2Rad, &
          limb_oa%tngt_geod_lat(m)*Deg2Rad, limb_oa%tngt_geod_alt(m)*1000.0d0, &
          earthellipstag, posecr) !emls_oa%ECR(:,m))
     emls_oa%ECR(:,m) = posecr
     emls_oa%geoc_alt(m) = SQRT (emls_oa%ECR(1,m)**2 + emls_oa%ECR(2,m)**2 + &
          emls_oa%ECR(3,m)**2)
     emls_oa%geoc_lat(m) = Rad2Deg * ATAN (posecr(3) / &
          SQRT (posecr(1)**2 + posecr(2)**2))
  enddo

! Calculate ECRtoFOV:

  do m = 1, nomifs
     emls_oa%azimAngle(m) = limb_oa%ptg_fov_azim_offset(m) + 90.0
     cosalf = COS (emls_oa%azimAngle(m)*Deg2Rad)
     sinalf = SIN (emls_oa%azimAngle(m)*Deg2Rad)

     emls_oa%scanAngle(m) = limb_oa%ptg_fov_elev_offset(m) + 23.3
     coseps = COS (emls_oa%scanAngle(m)*Deg2Rad)
     sineps = SIN (emls_oa%scanAngle(m)*Deg2Rad)

     ! Changed to account for rotation of axes during ascan
     xi = 113.6 + emls_oa%scanAngle(m) - 23.3 ! p.30 of UARS MLS cal.report, B1 is pointing reference
     cosxi = COS (xi*Deg2Rad)
     sinxi = SIN (xi*Deg2Rad)

     fcol1 = (/ cosalf*sineps*sinxi+sinalf*cosxi, sinalf*sineps*sinxi-cosalf*cosxi, -coseps*sinxi /)
     fcol2 = (/ cosalf*sineps*cosxi-sinalf*sinxi, sinalf*sineps*cosxi+cosalf*sinxi, -coseps*cosxi /)
     fcol3 = (/ cosalf*coseps, sinalf*coseps, sineps /)
  
     fmaf = RESHAPE((/ fcol1, fcol2, fcol3 /), (/ 3, 3 /))
     ipf2eci(:,:,m) = TRANSPOSE (MATMUL (limb_oa%trans_inst2eci, fmaf))
     flosf =  TRANSPOSE (RESHAPE ((/ (/ 0.0d0, 0.0d0, -1.0d0 /), &
          (/ -sinalf, cosalf, 0.0d0 /), &
          (/ cosalf, sinalf, 0.0d0 /) /), (/ 3, 3 /)))
     fmaf = TRANSPOSE (fmaf)
     do i = 1, 3
        eciV(1:3,m) = ipf2eci(i,:,m)
        eciV(4:6,m) = 0.0d0
        stat = pgs_csc_ecitoecr (1, asciiUTC, offsets(m), eciV(:,m), ecrV(:,m))
        ecrtofov(:,i,m) = ecrV(1:3,m)
     enddo
     ecrtofov(:,:,m) = TRANSPOSE (ecrtofov(:,:,m))    ! Put in "right" order
     emls_oa%ECRtoFOV(:,m) = RESHAPE (ecrtofov(:,:,m), (/ 9 /))  ! make 2-d

! Calculate GeodAngle (using REC's algorithm):

     call Calc_GeodAngle (m, fmaf, flosf)

  enddo

! Convert GHz ECR to ECI:

  ecrV(1:3,:) = emls_oa%ECR
  ecrV(4:6,:) = 0.0

  stat = pgs_csc_ecrtoeci (nomifs, asciiUTC, offsets, ecrV, eciV)
  emls_oa%ECI = eciV(1:3,:)

! Calculate LosAngle

  DO m = 1, nomifs
     phi = emls_oa%lon(m) * Deg2Rad
     cosphi = cos (phi)
     sinphi = sin (phi)
     theta = (90.0 - emls_oa%geod_lat(m)) * Deg2Rad
     costheta = cos (theta)
     sintheta = sin (theta)

     fcol1 = (/ -sinphi, cosphi, 0.0d0 /)
     fcol2 = (/ -costheta*cosphi, -costheta*sinphi, sintheta /)
     fcol3 = (/ sintheta*cosphi, sintheta*sinphi, costheta /)
     fmaf = RESHAPE((/ fcol1, fcol2, fcol3 /), (/ 3, 3 /))
     fecr = [emls_oa%ecrtofov(3,m), emls_oa%ecrtofov(6,m), emls_oa%ecrtofov(9,m)]
     ft = matmul (fecr, fmaf)
     emls_oa%LosAngle(m) = mod (90.0d00-atan2 (ft(2), ft(1))*Rad2Deg+360.0 , 360.0)

  ENDDO

! Calculate LosVel

  DO m = 1, nomifs
     tngtVel = omega * (/ -emls_oa%ECI(2,m), emls_oa%ECI(1,m), 0.0d0 /)
     los_vec(:,m) = emls_oa%ECI(:,m) - emls_oa%sc_ECI(:,m)
     los_vec(:,m) = los_vec(:,m) / SQRT (SUM (los_vec(:,m)**2))
     emls_oa%LosVel(m) = DOT_PRODUCT (tngtVel, los_vec(:,m)) - &
          DOT_PRODUCT (limb_oa%sat_vel*1000.0d0, los_vec(:,m))
  ENDDO

! Calculate OrbY

  DO m = 1, nomifs
     call cross_product (emls_oa%sc_ECI(:,m), emls_oa%sc_VelECI(:,m), rv)
     orb_norm = rv / sqrt (rv(1)*rv(1) + rv(2)*rv(2) + rv(3)*rv(3))
     emls_oa%OrbY(m) = DOT_PRODUCT (-emls_oa%ECI(:,m), orb_norm)
  ENDDO

  ! Remap GHz/Lon
  where (emls_oa%lon > 180.0)
     emls_oa%lon = emls_oa%lon - 360.0
  end where

!!$write (30, *) limb_oa%ptg_fov_azim_offset
!!$write (31, *) limb_oa%ptg_fov_elev_offset
!!$write (32, *) limb_oa%sat_geod_alt
!!$write (33, *) limb_oa%sat_geod_lat
!!$write (34, *) limb_oa%sat_long
!!$write (35, *) limb_oa%tngt_geod_alt
!!$write (36, *) limb_oa%tngt_geod_lat
!!$write (37, *) limb_oa%tngt_long
!!$write (40, *) emls_oa%ECR
!!$write (81, *) emls_oa%sc_ECI
!!$write (82, *) emls_oa%sc_VelECI
!!$write (83, *) emls_oa%ECI
d341 1
a341 1
!write (3x, *) limb_oa%
d343 1
a343 1
end subroutine uars_to_emls_oa
@


1.3
log
@Added option to backdate by n_days
@
text
@d3 6
a8 5
  USE rad_file_contents, ONLY: limb_oa
  USE oa_file_contents, ONLY: emls_oa
  USE SDPToolkit, ONLY: PGS_S_SUCCESS
  USE Constants, ONLY: Deg2Rad, Rad2Deg, Pi
  USE Geometry, ONLY: Omega => W
d15 1
d17 1
d28 1
a28 1
  character*25 asciiutc, err, msg
d60 1
d101 6
a106 1
    emls_oa%MAFStartTimeTAI = sectai93 - (n_days/1000) * 365 * 24 * 3600
d108 4
a111 1
    emls_oa%MAFStartTimeTAI = sectai93 - n_days * 24 * 3600
d117 1
a117 1
     emls_oa%sc_MIF_TAI(m) = sectai93 + (m-1) * mif_inc
d249 5
@


1.2
log
@Now accounts for rotation of axes during a scan
@
text
@d1 1
a1 1
subroutine uars_to_emls_oa
d10 3
a12 1

d70 1
a70 1
  yrdoy = limb_oa%ref_time(1)  ! year plus day of year
d90 1
d94 7
@


1.1
log
@Initial commit
@
text
@d22 1
d151 7
a157 2
     fcol1 = (/ cosalf*sineps, sinalf*sineps, -coseps /)
     fcol2 = (/ -sinalf, cosalf, 0.0d0 /)
d159 1
@

