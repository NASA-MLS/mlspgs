head	1.10;
access;
symbols
	v5-02-NRT-19:1.10
	v6-00:1.10
	v5-02-NRT-18:1.10
	v5-02:1.10
	v5-01-NRT-17:1.10
	v5-01-NRT-16:1.10
	v5-01-NRT-15:1.10
	v5-01-NRT-14:1.10
	neuralnetworks-1-0:1.10.0.10
	cfm-single-freq-0-1:1.10.0.8
	v5-01:1.10
	v5-00:1.10
	v4-23-TA133:1.10.0.6
	mus-emls-1-70:1.10.0.4
	rel-1-0-englocks-work:1.10.0.2
	VUMLS1-00:1.10
	VPL1-00:1.8
	V4-22-NRT-08:1.8
	VAM1-00:1.8
	V4-21:1.6.0.2;
locks; strict;
comment	@# @;


1.10
date	2017.01.04.02.18.46;	author vsnyder;	state Exp;
branches;
next	1.9;

1.9
date	2016.12.21.20.37.41;	author vsnyder;	state Exp;
branches;
next	1.8;

1.8
date	2015.04.21.02.27.08;	author vsnyder;	state Exp;
branches;
next	1.7;

1.7
date	2015.04.21.01.18.54;	author vsnyder;	state Exp;
branches;
next	1.6;

1.6
date	2015.01.24.02.09.16;	author vsnyder;	state Exp;
branches;
next	1.5;

1.5
date	2015.01.22.02.18.56;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2014.12.11.00.48.51;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2014.11.25.01.08.18;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2014.10.29.16.47.55;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2014.06.17.17.40.27;	author perun;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Add status check after PGS_TD_UTCtoTAI to detect missing env variable
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

program Conv_UARS

  use HDF5, only:  H5GClose_f, H5GOpen_f
  use ISO_Fortran_Env, only: Output_Unit
  use MLSAuxData, ONLY: CreateGroup_MLSAuxData
  use MLSCommon, ONLY: FileNameLen
  use MLSFiles, ONLY: MLS_openFile, MLS_closeFile
  use MLSHDF5, ONLY: MakeHDF5Attribute, MLS_h5open, MLS_h5close
  use MLSKinds, only: R8
  use Output_UARS_L1B, only: OutputL1B_OA, OutputL1B_Rad
  use Rad_File_Contents, only: Lvl1_Hdr_t, Limb_Hdr_t, Limb_Stat_t, Limb_Rad_t, &
                             & Limb_OA_t, Pad_t
  use Set_Attributes_m, only: Set_Attributes
  use Swap_OA_Rec_m, only: Swap_Limb_Hdr_Rec, Swap_Limb_Stat_Rec, &
                         & Swap_Lvl1_Hdr_Rec, Swap_Rad_Rec, Swap_OA_Rec
  use UARS_Dumps, only: Show_Time
  use UARS_to_EMLS_OA_m, only: EarthEllipseTag, Frame_TAI, NoMIFs

  implicit NONE

  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: conv_uars.f90,v $"
  !---------------------------------------------------------------------------

  ! Is the input file name stored as an attribute in the output file?
  logical, parameter :: Input_File_Attrib = .true.

  integer, parameter :: In_Unit=101, HDFversion=5
  character (len=FileNameLen) :: Arg
  character (len=FileNameLen) :: InFile='uars.dat'
  character (len=FileNameLen) :: OA_File='OA.h5'
  character (len=FileNameLen) :: Out_Dir='/data/'
  character (len=FileNameLen) :: Rad_File='RAD.h5'
  integer :: DOY
  integer :: Error
  integer :: Grp_ID  ! of root directory of output file
  integer :: I
  integer :: InLen
  integer :: MAF1    ! First MAF, default 1
  integer :: MAFn    ! Last MAF, default from header
  integer :: MAFno
  integer :: n_days = 0
  integer :: NoArgs
  integer :: NummMAF
  integer :: OA_SD_id
  integer :: Rad_SD_id
  integer :: Recno
  integer :: Stat
  integer :: W ! zero or one, to select Limb_Hdr etc.
  integer :: Year
  integer :: YrDOY

  ! Inputs
  type(lvl1_hdr_t) :: Lvl1_Hdr
  type(limb_hdr_t) :: Limb_Hdr(0:1)
  type(limb_stat_t) :: Limb_Stat(0:1)
  type(limb_rad_t) :: Limb_Rad(0:1)
  type(limb_oa_t) :: Limb_OA(0:1)
  type(pad_t) :: Pad

  character (len=25) :: AsciiUTC(0:1)
  character (len=17) :: UTC_Time
  character (len=8) :: N_Str
  character (len=8) :: YrDoy_str = 'yyyydnnn'
  character (len=2048) :: CmdLine
  character (len=127) :: IOMSG
  real(r8) :: dVI, dVIN                ! delta V angle, |delta V|, ECI, per MAF
  real(r8) :: ECI(6,1), ECR(6,1)       ! Position, velocity, for conversions
  real(r8) :: GIRD_Time
  real(r8), parameter :: TAItoGIRD = 1104537627.0_r8
  real(r8) :: SecTAI93
  real(r8) :: TAI_Time
  real(r8) :: Vel_ECI(3,0:1), vNI(0:1) ! SC Velocity in ECR, its length, km/s

  ! Source code:

  ! Open UARS input file:

  MAF1 = 1
  MAFn = -1  ! Signal to get it from the header

  noargs = command_argument_count()
  if (noargs == 0) then
    print '(a)', 'No input file provided.'
    print '(2a)', 'Using defaults: Input ', trim(inFile)
    print '(2a)', 'output directory      ', trim(out_dir)
    print '(2a)', 'output OA file        ', trim(oa_file)
    print '(2a)', 'output Rad file       ', trim(rad_file)
  else
    i = 1

    do while (i <= noargs)

      call get_command_argument (i, arg)

      select case (arg)
      case default
        if ( arg(1:1) == '-' ) then
          call usage
          go to 9
        end if
        infile = TRIM(arg)                 ! input filename
        if (noargs < 3) then
          print *, 'Missing output directory argument? Too few args!'
          go to 9
        end if
      case ('-b', '--backdate')
        i = i + 1
        call get_command_argument (i, n_str)  ! how many days to backdate times in file
        read( n_str, * ) n_days
        ! Now we must take account for how mmaf_time actually encodes dates
        ! It uses a convention that the year contains 1000 days
        ! if the year y = 1900 + p
        ! and the doy   = d
        ! then mmaf_time = 1000*y + d (yes, I know this is ugh--
        ! "It was like that when I got here!")
        ! So we're assuming you either want to backdate by one day or so 
        ! or else by a number of years
        ! E.g., to backdate 10 years, set n_days to 3650 (we ignore leap years)
        if ( n_days > 364 ) n_days = 1000 * (n_days/365)
      case ( '-M', '--MAF' )
        i = i + 1
        call get_command_argument (i, n_str) ! First MAF
        read ( n_str, * ) MAF1
        i = i + 1
        call get_command_argument (i, n_str) ! Last MAF
        read ( n_str, * ) MAFn
      case ('-o', '--outdir')
        i = i + 1
        call get_command_argument (i, out_dir)  ! next argument for out dir
      case ('-h', '--help')
        call usage
        go to 9
      end select
      i = i + 1   ! Next argument
    end do
  end if

  call get_command ( cmdLine )
  print '(a)', trim(cmdLine)

  ! The length computed by
  ! inquire ( iolength=i ) limb_hdr(1), limb_stat(1), limb_rad(1), limb_oa(1)
  ! is 90 less than inlen.  What do the other 360 bytes contain?  It looks
  ! like zeroes, but is it just padding or do some records contain
  ! something useful there?

  inquire ( iolength = inlen ) &
    & limb_hdr(0), limb_stat(0), limb_rad(0), limb_oa(0), pad
  open ( unit=in_unit, file=infile, status="OLD", form="UNFORMATTED", &
       & access="DIRECT", recl=inlen, iostat=error, iomsg=iomsg )

  if (error /= 0) then
    print '(a,i0,2a/a)', 'Error status ', error, ' while opening ', trim(infile), &
      & trim(iomsg)
    go to 9
  end if

  ! read and convert header part:

  do recno = 1, 3

    read (unit=in_unit, rec=recno) lvl1_hdr

    if ( lvl1_hdr%rec_type /= 'H' ) then
      print '(a,i0,3a)', 'Something is wrong.  Record ', i, &
                       & ' is not type H.  Type is "', lvl1_hdr%rec_type, '"'
      stop
    end if
    ! convert to little endian as needed:
    call swap_lvl1_hdr_rec ( lvl1_hdr )

  end do

  nummmaf = lvl1_hdr%nummmaf
  if ( MAFn < 0 ) MAFn = nummmaf
  if ( MAF1 < 1 .or. MAFn > nummmaf .or. MAF1 > MAFn) then
    print '(3(a,i0))', 'MAF numbers out of range.  MAF1 = ', MAF1, &
      & ' MAFn = ', MAFn, ' Valid range is 1 .. ', nummmaf
    stop
  end if

  if (nummmaf == 0) then
    print *, 'No data in file: '//infile
    go to 9
  end if

  ! get the yrdoy of file:

  recno = nummmaf / 2
  read ( unit=in_unit, rec=recno ) limb_hdr(0)
  call Swap_Limb_Hdr_Rec ( limb_hdr(0) )
  yrdoy = limb_hdr(0)%mmaf_time(1) - n_days ! This lets us backdate the files; e.g., for sids

  if ( noargs > 0 ) then   ! use passed input for setting outputs
    year = yrdoy / 1000 + 1900
    doy = mod (yrdoy, 1000)
    write (yrdoy_str, '(i4.4, "d", i3.3)') year, doy
!     print '(a,1x,i0,1x,a)', 'yrdoy str: ', yrdoy, yrdoy_str

    Rad_File = TRIM(out_dir) // '/MLS-UARS_L1BRAD_' // yrdoy_str // '.h5'
    OA_File = TRIM(out_dir) // '/MLS-UARS_L1BOA_' // yrdoy_str // '.h5'
  end if

  print '(a)',    'infile: ' // trim(infile)
  print '(a)',    'rad file: ' // trim(Rad_File)
  print '(a)',    'OA file: ' // trim(OA_File)
  print '(a,1x,i0)', 'num. days backdated:   ', n_days

  ! Open output RAD and OA HDF files:

  error = 0
  call MLS_h5open ( error )

  call MLS_openFile ( Rad_File, 'create', rad_sd_id, HDFversion )

  call MLS_openFile ( OA_File, 'create', oa_sd_id, HDFversion )
  call CreateGroup_MLSAuxData ( oa_sd_id, 'GHz' )
  call CreateGroup_MLSAuxData ( oa_sd_id, 'sc' )

  ! save attributes for both HDF files:

  call set_attributes ( rad_sd_id, yrdoy, lvl1_hdr%start_time, lvl1_hdr%stop_time )
  call set_attributes ( oa_sd_id, yrdoy, lvl1_hdr%start_time, lvl1_hdr%stop_time )

  if ( input_file_attrib ) then
    call h5gopen_f ( oa_sd_id, '/', grp_id, stat )
    call MakeHDF5Attribute(grp_id, 'InputFileName', trim(infile), .true.)
    call h5gclose_f ( grp_id, stat )
  end if

  ! print stuff

  print '(a,1x,i0)',         'UARS day:              ', lvl1_hdr%uars_day
  print '(a,2(1x,i0),1x,a)', 'Start time:            ', lvl1_hdr%start_time, &
    & show_time ( lvl1_hdr%start_time )
  print '(a,2(1x,i0),1x,a)', 'Stop time:             ', lvl1_hdr%stop_time, &
    & show_time ( lvl1_hdr%stop_time )
  print '(a,2(1x,i0))',      'nummmaf:               ', nummmaf
  print '(a,2(1x,i0))',      'mafs:                  ', MAF1, MAFn
  ! read and convert data:

  MAFno = MAF1 - 1

  w = 0
  read ( unit=in_unit, rec=MAF1+3 ) &
    & limb_hdr(w), limb_stat(w), limb_rad(w), limb_oa(w)

  if ( limb_hdr(w)%rec_type /= 'D' ) then
    print '(a,i0,3a)', 'Something is wrong.  Record ', MAF1+3, &
                     & ' is not type D.  Type is "', limb_hdr(w)%rec_type, '"'
    stop
  end if
  ! convert to little endian as needed:
  call swap_limb_hdr_rec ( limb_hdr(w) )
  call swap_limb_stat_rec ( limb_stat(w) )
  call swap_rad_rec ( limb_rad(w) )
  call swap_OA_rec ( limb_oa(w) )

  vel_ECI(:,w) = limb_oa(w)%sat_vel
  vNI(w) = norm2(vel_ECI(:,w))

  dVI = 0.0
  dVIN = 0.0

  do recno = MAF1+3, MAFn+3

    ! Get the record for the next MAF, if there is one.
    ! Calculate the change in velocity vector angle.
    ! This is used to rotate the ECR velocity vectors for each MIF.  If there
    ! is no next record, use the difference of the last two records.
    if ( recno < nummmaf+3 ) then
      read ( unit=in_unit, rec=recno+1 ) &
        & limb_hdr(1-w), limb_stat(1-w), limb_rad(1-w), limb_oa(1-w)
      if ( limb_hdr(1-w)%rec_type /= 'D' ) then
        print '(a,i0,3a)', 'Something is wrong.  Record ', recno, &
                         & ' is not type D.  Type is "', limb_hdr(1-w)%rec_type, '"'
        stop
      end if
      ! convert to little endian as needed:
      call swap_limb_hdr_rec ( limb_hdr(1-w) )
      call swap_limb_stat_rec ( limb_stat(1-w) )
      call swap_rad_rec ( limb_rad(1-w) )
      call swap_OA_rec ( limb_oa(1-w) )

      vel_ECI(:,1-w) = limb_oa(1-w)%sat_vel
      vNI(1-w) = norm2(vel_ECI(:,1-w))

      dVI = acos(dot_product(vel_ECI(:,w),vel_ECI(:,1-w))/(vNI(w)*vNI(1-w))) / noMIFs
      dVIN = ( vNI(1-w) / vNI(w) - 1.0 ) / noMIFs
    end if

    MAFno = MAFno + 1

    call process_one_MAF ( MAFno, rad_sd_id, oa_sd_id, &
                         & dVI, dVIN, &
                         & limb_hdr(w), limb_stat(w), limb_rad(w), limb_oa(w) )

    ! Swap buffers
    w = 1 - w

  end do

  close (in_unit)

  call MLS_closeFile (rad_sd_id, HDFversion=HDFversion)
  call MLS_closeFile (oa_sd_id, HDFversion=HDFversion)
  call MLS_h5close (error)

9 continue

contains

  subroutine Process_One_MAF ( MAFNo, Rad_SD_id, OA_SD_id, &
                             & dVI, dVIN, &
                             & Limb_Hdr, Limb_Stat, Limb_Rad, Limb_OA )

    use OA_File_Contents, only: EMLS_OA_t
    use SDPToolkit, only: PGS_SMF_GetMsg, PGS_S_Success, PGS_TD_UTCtoTAI
    use Time_m, only: MS_to_HMS
    use UARS_to_EMLS_OA_m, only: UARS_to_EMLS_OA

    integer, intent(in) :: MAFNo, Rad_SD_id, OA_SD_id
    real(r8), intent(in) :: dVI    ! delta V angle per MIF, ECI
    real(r8), intent(in) :: dVIN   ! relative delta V length per MIF, ECI
    type(limb_hdr_t), intent(inout) :: Limb_Hdr
    type(limb_stat_t), intent(inout) :: Limb_Stat
    type(limb_rad_t), intent(inout) :: Limb_Rad
    type(limb_oa_t), intent(inout) :: Limb_OA
    character(255) :: Err, Msg

    real :: rad(15*6,32), rad6(15,6,32), prec(15*6,32), prec6(15,6,32)
    equivalence (rad, rad6), (prec, prec6)

    integer :: DOY
    type(emls_oa_t) :: EMLS_OA
    integer :: Hrs, I, J, K, Mins, MS, Secs
    integer :: Stat ! From PGS_TD_UTCtoTAI
    integer :: Year

    character (len=*), parameter :: &
      DateFmt = "(I4, '-', I3.3, 'T', I2.2, ':', I2.2, ':', I2.2)"

    ! convert radiances:

    rad = limb_rad%rad_l1(:,1,:)
    prec = limb_rad%rad_l1(:,2,:)
    where ( rad < 0.0 .AND. rad /= -1000.0 ) rad = rad + 65536.0
    where ( prec < 0.0 .AND. prec /= -1000.0 ) prec = prec + 65536.0
    where ( rad /= -1000.0 ) rad = rad * 0.01   ! scale radiances

    where ( prec == -1000.0 ) prec = -1.0
    where ( prec /= -1.0 ) prec = prec * 0.01   ! scale precisions

    year = limb_hdr%mmaf_time(1) / 1000 + 1900
    doy = MOD (limb_hdr%mmaf_time(1), 1000)

    ! convert millisecs to HMS:

    call ms_to_hms ( limb_hdr%mmaf_time(2), hrs, mins, secs )
    write ( utc_time, fmt=DateFmt ) year, doy, hrs, mins, secs

    ! get and save the GIRD time:

    stat = PGS_TD_UTCtoTAI (utc_time, tai_time)
    if ( stat /= PGS_S_Success ) then
      print '(a,i0)', 'Status from PGS_TD_UTCtoTAI = ', stat
      print '(a)', 'Is the environment variable PGSHOME set?'
      call PGS_SMF_GetMsg ( stat, err, msg )
      print '(a)', trim(err), trim(msg)
      stop
    end if
    gird_time = tai_time + TAItoGIRD

    ! write radiances etc. to file:

    call OutputL1B_rad ( rad_sd_id, mafno, limb_hdr%mmafno, rad6, prec6, &
                       & gird_time, limb_hdr )

    ! convert to EMLS OA:

    call UARS_to_EMLS_OA ( n_days, limb_oa, emls_oa, dVI, dVIN )

    ! write to OA file:

    call OutputL1B_OA ( oa_sd_id, mafno, limb_hdr%mmafno, limb_oa, emls_oa )

  end subroutine Process_One_MAF

  subroutine Usage
    character(255) :: Line
    call get_command_argument ( 0, line )
    print '(3a)', 'Usage: ', trim(line), ' [options] [input [output directory]]'
    print '( a)', ' Options: -b n_days           => number of days to backdate'
    print '( a)', '          --backdate n_days   => number of days to backdate'
    print '( a)', '          -M first last       => MAFs to run'
    print '( a)', '          --MAF first last    => MAFs to run'
    print '( a)', '          -o output_dir       => output directory'
    print '( a)', '          --outdir output_dir => output directory'
    print '( a)', '          -h                  => print help'
    print '( a)', '          --help              => print help'
    print '( a)', ' Defaults: options: None'
    print '(2a)', '  input file:       ', trim(inFile)
    print '(2a)', '  output directory: ', trim(out_dir)
    print '(2a)', '  OA file:          ', trim(oa_file)
    print '(2a)', '  RAD file:         ', trim(rad_file)
  end subroutine Usage

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: conv_uars.f90,v 1.9 2016/12/21 20:37:41 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end program Conv_UARS

! $Log: conv_uars.f90,v $
! Revision 1.9  2016/12/21 20:37:41  vsnyder
! Fiddle some command-line stuff
!
! Revision 1.8  2015/04/21 02:27:08  vsnyder
! Create attributes for some components' units
!
! Revision 1.7  2015/04/21 01:18:54  vsnyder
! Use swap routines in Swap_OA_Rec_m.  Get record size using INQUIRE with
! IOLENGTH=.  Spiff some printing.  Print usage with -h or --help option.
! Check record types.  Calculate highest record number properly.
!
! Revision 1.6  2015/01/24 02:09:16  vsnyder
! MIF resolve most quantities
!
! Revision 1.5  2015/01/22 02:18:56  vsnyder
! PGS_Interfaces.f90
!
! Revision 1.4  2014/12/11 00:48:51  vsnyder
! Move external procedures into modules.  Add copyright and CVS lines.
! Compute MIF geolocation (except height) for SC.  Compute MIF-resolved
! SC velocity.  Some cannonball polishing.
!
@


1.9
log
@Fiddle some command-line stuff
@
text
@d331 1
a331 1
    use SDPToolkit, only: PGS_TD_UTCtoTAI
d342 1
d378 7
d424 1
a424 1
       "$Id: conv_uars.f90,v 1.8 2015/04/21 02:27:08 vsnyder Exp $"
d434 3
@


1.8
log
@Create attributes for some components' units
@
text
@d73 1
a74 1
  character (len=25) :: AsciiUTC(0:1)
d77 2
d94 1
a94 1
  noargs = COMMAND_ARGUMENT_COUNT()
d106 1
a106 1
      call GET_COMMAND_ARGUMENT (i, arg)
d110 4
d121 1
a121 1
        call GET_COMMAND_ARGUMENT (i, n_str)  ! how many days to backdate times in file
d135 1
a135 1
        call GET_COMMAND_ARGUMENT (i, n_str) ! First MAF
d138 1
a138 1
        call GET_COMMAND_ARGUMENT (i, n_str) ! Last MAF
d142 1
a142 1
        call GET_COMMAND_ARGUMENT (i, out_dir)  ! next argument for out dir
d151 3
d163 1
a163 1
       & access="DIRECT", recl=inlen, iostat=error )
d166 2
a167 1
    print *, 'No such input file: '//infile
d416 1
a416 1
       "$Id: conv_uars.f90,v 1.7 2015/04/21 01:18:54 vsnyder Exp $"
d426 3
@


1.7
log
@Use swap routines in Swap_OA_Rec_m.  Get record size using INQUIRE with
IOLENGTH=.  Spiff some printing.  Print usage with -h or --help option.
Check record types.  Calculate highest record number properly.
@
text
@d210 1
a210 1
  print '(a,1x,i0)', 'n days backdated:      ', n_days
d231 1
d406 1
a406 1
       "$Id: conv_uars.f90,v 1.6 2015/01/24 02:09:16 vsnyder Exp $"
d416 5
@


1.6
log
@MIF resolve most quantities
@
text
@d23 1
a23 1
                             & Limb_OA_t
d25 3
a27 2
  use SwapEndian, only: SwapBig
  use Swap_OA_Rec_m, only: Swap_OA_Rec
d40 1
a40 1
  integer, parameter :: In_Unit=101, InLen=14336/4, HDFversion=5
d50 1
d71 1
d94 5
a98 2
    print *, 'No input file provided.'
    print *, 'Using defaults...'
d138 1
a138 7
        call GET_COMMAND_ARGUMENT ( 0, arg )
        print '(a)', 'usage: ' // trim(arg) // ' [options] input_file' 
        print '(a)', '      options' 
        print '(a)', '  -b n_days         backdate converted files in time by n_days' 
        print '(a)', '  -M MAF1 MAFn      MAF range to process'
        print '(a)', '  -o output_dir     write converted files to output_dir' 
        print '(a)', '  -h                print help' 
d151 2
d167 5
d173 1
a173 10

    lvl1_hdr%recordno = SwapBig (lvl1_hdr%recordno)
    do i = 1, 2
      lvl1_hdr%write_time(i) = SwapBig (lvl1_hdr%write_time(i))
      lvl1_hdr%start_time(i) = SwapBig (lvl1_hdr%start_time(i))
      lvl1_hdr%stop_time(i) = SwapBig (lvl1_hdr%stop_time(i))
    end do
    lvl1_hdr%nummmaf = SwapBig (lvl1_hdr%nummmaf)
    lvl1_hdr%uars_day = SwapBig (lvl1_hdr%uars_day)
    lvl1_hdr%mls_status_day = SwapBig (lvl1_hdr%mls_status_day)
d194 2
a195 1
  yrdoy = SwapBig (limb_hdr(0)%mmaf_time(1)) - n_days ! This lets us backdate the files; e.g., for sids
d201 1
a201 1
    print *, 'yrdoy, year, doy, str: ', yrdoy, year, doy, yrdoy_str
d207 4
a210 4
  write( 6, '(a)' ) 'infile: ' // trim(infile)
  write( 6, '(a)' ) 'rad file: ' // trim(Rad_File)
  write( 6, '(a)' ) 'OA file: ' // trim(OA_File)
  print *, 'n days backdated: ', n_days
d235 7
a241 6
  print *, 'UARS day', lvl1_hdr%uars_day
  print *, 'Start time: ', lvl1_hdr%start_time
  print *, 'Stop time:  ', lvl1_hdr%stop_time
  print *, 'yrdoy: ', yrdoy

  print *, 'nummmaf: ', nummmaf
d249 10
a258 1
  ! swap all OA bytes:
d273 1
a273 1
    if ( recno < nummmaf ) then
d276 9
a284 1
      ! swap all OA bytes:
a304 2
  print *, 'mafs: ', MAF1, MAFn

a320 1
    use SwapEndian, only: SwapShort
a343 15
    ! convert to little endian as needed:
    limb_hdr%recordno = SwapBig (limb_hdr%recordno)
    limb_hdr%mmafno = SwapBig (limb_hdr%mmafno)
    do i = 1, 2
       limb_hdr%mmaf_time(i) = SwapBig (limb_hdr%mmaf_time(i)) ! - n_days
    end do
    do i = 1, 16
       limb_stat%prd_temps(i) = SwapBig (limb_stat%prd_temps(i))
    end do
    limb_stat%maneuver_stat = SwapBig (limb_stat%maneuver_stat)
    limb_stat%mls_status = SwapBig (limb_stat%mls_status)
    do i = 1, 90
        limb_stat%wall_mmaf(i) = SwapShort (limb_stat%wall_mmaf(i))
    end do

a345 8
    do k = 1, 32         ! MIF number
      do j = 1, 2        ! radiance/error
        do i = 1, 90     ! radiometer and channel
          limb_rad%rad_l1(i,j,k) = SwapShort (limb_rad%rad_l1(i,j,k))
        end do
      end do
    end do

d375 1
a375 2
    call UARS_to_EMLS_OA ( n_days, limb_oa, emls_oa, &
      & dVI, dVIN )
d383 19
d405 1
a405 1
       "$Id: conv_uars.f90,v 1.5 2015/01/22 02:18:56 vsnyder Exp $"
d415 3
@


1.5
log
@PGS_Interfaces.f90
@
text
@a13 2
  use Constants, only: Deg2Rad
use Constants, only: Rad2Deg
d59 1
a61 1
  integer :: W ! zero or one, to select Limb_Hdr etc.
d70 1
d72 1
a72 2
  character (len=8) :: n_str
  character (len=17) :: UTC_Time
d74 2
d77 1
d79 1
a79 1
  real(r8) :: Sat_Vel(3,0:1), vN(0:1)  ! SC Velocity in ECR, its length, km/s
a80 7
  real(r8) :: PosECR(3,0:1)            ! SC Position, in ECR, meters
  real(r8) :: dVV(3)                   ! delta V in ECR
  real(r8) :: dV, dVN                  ! delta V angle, |delta V|, ECR, per MAF
  real(r8) :: dVI, dVIN                ! delta V angle, |delta V|, ECI, per MAF
  real(r8) :: ECI(6,1), ECR(6,1)       ! Position, velocity, for conversions
  real(r8) :: TAI_Time
  real(r8), parameter :: TAItoGIRD = 1104537627.0d00
a82 2
  ! Don't wrap stdout at 80 chars
  open ( unit=output_unit, recl=4096 )
a254 5
  call sat_vel_in_ecr ( limb_oa(w), asciiUTC(w), sat_vel(:,w), posecr(:,w) )

  vN(w) = norm2(sat_vel(:,w))
  
  dV = 0.0
a255 1
  dVN = 0.0
a256 4
  dVV = 0.0
write ( 42,'(a/2x,3f9.2,1p,4g15.6)' ) &
& '     VelECI   VelECR      vNI ----- dV ----- ----- dVN ---- ----- dVI ---- ---- dVIN ----', &
& vN(w), vNI(w), norm2(posecr(:,w))/1000, dV*rad2deg, dVN*1.0e6, dVI*rad2deg, dVIN*1.0e6
a272 5
      call sat_vel_in_ecr ( limb_oa(1-w), asciiUTC(1-w), sat_vel(:,1-w), posecr(:,1-w) )

      vN(1-w) = norm2(sat_vel(:,1-w))
      dV = acos(dot_product(sat_vel(:,w),sat_vel(:,1-w))/(vN(w)*vN(1-w))) / noMIFs
      dVN = ( vN(1-w) / vN(w) - 1.0 ) / noMIFs
a274 4
write ( 42,'(a/2x,3f9.2,1p,4g15.6)' ) &
& '     VelECI   VelECR      vNI ----- dV ----- ----- dVN ---- ----- dVI ---- ---- dVIN ----', &
& vN(1-w), vNI(1-w), norm2(posecr(:,1-w))/1000, dV*rad2deg, dVN*1.0e6, dVI*rad2deg, dVIN*1.0e6
      dVV = sat_vel(:,1-w) - sat_vel(:,w)
d278 3
a280 7
write ( 42, '(1x,2(31x,a25),a)' ) AsciiUTC(w:1-w:1-2*w), &
& ' ----------------------- PosECR -----------------------'
write ( 42, '(2x,6(3f9.2:","))' ) ( limb_oa(i)%sat_vel*1000, sat_vel(:,i), i=w,1-w,1-2*w), posECR/1000

    call process_one_MAF ( MAFno, rad_sd_id, oa_sd_id, dV, dVN, dVV, &
                         & Sat_Vel(:,w:1-w:1-2*w), posECR(:,w:1-w:1-2*w), &
                         & Vel_ECI(:,w:1-w:1-2*w), dVI, dVIN, AsciiUTC, &
d300 2
a301 2
  subroutine Process_One_MAF ( MAFNo, Rad_SD_id, OA_SD_id, dV, dVN, dVV, &
                             & Sat_Vel, PosECR, Vel_ECI, dVI, dVIN, AsciiUTC, &
a310 5
    real(r8), intent(in) :: dV     ! delta V angle per MIF, ECR
    real(r8), intent(in) :: dVN    ! relative delta V length per MIF, ECR
    real(r8), intent(in) :: dVV(3) ! delta V per MAF, ECR
    real(r8), intent(in) :: Sat_Vel(3,0:1) ! Satellite velocities, ECR, km/s
    real(r8), intent(in) :: Vel_ECI(3,0:1) ! Satellite velocities, ECI, km/s
a312 2
    real(r8), intent(in) :: PosECR(3,0:1)  ! Satellite positions, ECI, meters
    character(*), intent(in) :: AsciiUTC(2)
d384 2
a385 2
    call UARS_to_EMLS_OA ( n_days, limb_oa, emls_oa, dV, dVN, dVV, Sat_Vel, &
      & posECR, Vel_ECI, dVI, dVIN, AsciiUTC )
a392 32
  subroutine Sat_Vel_In_ECR ( Limb_OA, AsciiUTC, Sat_vel, PosECR )
    use PGS_Interfaces, only: pgs_csc_ecitoecr, pgs_csc_ecrtoeci, pgs_csc_geotoecr

    type(limb_oa_t), intent(in) :: Limb_OA
    character(*), intent(out) :: AsciiUTC
    real(r8), intent(out) :: Sat_Vel(3)    ! ECR, m/s
    real(r8), intent(out) :: PosECR(3)     ! Meters

    real(r8) :: ECI(6,1), ECR(6,1)
    integer :: Stat

    stat = pgs_csc_geotoecr ( limb_oa%sat_long*Deg2Rad, &
                              limb_oa%sat_geod_lat*Deg2Rad, &
                              limb_oa%sat_geod_alt*1000.0d0, &
                              earthEllipseTag, posecr )

    call frame_TAI ( limb_oa, secTAI93, asciiUTC )

    ecr(1:3,1) = posECR
    ecr(4:6,1) = 0.0 ! Velocity
    ! Compute position in ECI
    stat = pgs_csc_ecrtoeci ( 1, asciiUTC, [0.0d0], ecr, eci )
    ! Now convert position and velocity to ECR
    eci(4:6,1) = limb_oa%sat_vel * 1000 ! ECI, m/s
    stat = pgs_csc_ecitoecr ( 1, asciiUTC, [0.0d0], eci, ecr )
    sat_vel = ecr(4:6,1)                ! Now in ECR, m/s

write ( 42,'(2x,2a)' ) ' ------------------------ ECI -------------------------', &
& ' ------------------------ ECR -------------------------'
write ( 42, '(2x,4(3f9.2:","))' ) eci(1:3,1)/1000,eci(4:6,1), ecr(1:3,1)/1000,ecr(4:6,1)
  end subroutine Sat_Vel_In_ECR

d396 1
a396 1
       "$Id: conv_uars.f90,v 1.4 2014/12/11 00:48:51 vsnyder Exp $"
d406 3
@


1.4
log
@Move external procedures into modules.  Add copyright and CVS lines.
Compute MIF geolocation (except height) for SC.  Compute MIF-resolved
SC velocity.  Some cannonball polishing.
@
text
@d15 2
a16 1
  use Geometry, only: GeodToGeocLat, To_XYZ
d21 1
a22 1
  use MLSHDF5, ONLY: MLS_h5open, MLS_h5close
d29 1
d35 1
a35 1
       "$RCSfile: ConstructQuantityTemplates.f90,v $"
d38 2
a39 1
  integer, external :: PGS_csc_GeoToECR
a41 1
  character (len=*), parameter :: earthellipstag = 'WGS84'
d49 1
d51 2
a52 2
  integer :: MAF1 ! First MAF, default 1
  integer :: MAFn ! Last MAF, default from header
d54 1
a60 1
  integer :: W    ! Selects current set of data
d63 1
d72 2
a75 1
  real :: Angle    ! Along track, between first MIFs of consecutive MAFs
d77 8
a86 5
  real :: XYZ(3,0:1) ! Satellite positions in ECR
! double precision :: PosECR(3)

  integer :: n_days = 0
  character (len=8) :: n_str
d203 2
a204 2
  read ( unit=in_unit, rec=recno ) limb_hdr(1)
  yrdoy = SwapBig (limb_hdr(1)%mmaf_time(1)) - n_days ! This lets us backdate the files; e.g., for sids
d237 5
d246 1
a246 1
  print *, 'Stop time: ', lvl1_hdr%stop_time
d252 2
a253 1
  MAFno = 0
d256 1
a256 1
      & limb_hdr(0), limb_stat(0), limb_rad(0), limb_oa(0)
d259 17
a275 3
  ! Get position in ECR
  xyz(:,w) = to_xyz ( geodToGeocLat(limb_oa(w)%sat_geod_lat), &
                    & real(limb_oa(w)%sat_long*deg2rad), radians=.true. )
d278 6
a283 4
    ! Get an adjacent MAF, usually the next one, to compute MIF
    ! geolocations for the spacecraft.
    if ( recno < nummmaf+3 ) then
      read (unit=in_unit, rec=recno+1) &
d287 15
a301 11
      ! Get position in ECR
      xyz(:,1-w) = to_xyz ( geodToGeocLat(limb_oa(1-w)%sat_geod_lat), &
                         & real(limb_oa(1-w)%sat_long*deg2rad), radians=.true. )
      ! This isn't quite as accurate (and we don't need the altitude).  The reason
      ! is that it computes the square of the Earth axis ratio, F2, as
      ! 1 - ( 1 - F2 ), losing three digits in the process.
      ! stat = PGS_csc_GeoToECR ( limb_oa(1-w)%sat_long*Deg2Rad*1.0d0, &
      !                           limb_oa(1-w)%sat_geod_lat*Deg2Rad*1.0d0, &
      !                           limb_oa(1-w)%sat_geod_alt*1000.0d0, &
      !                           earthellipstag, posecr )
      ! xyz(:,1-w) = posecr / norm2(posecr)
d304 8
a311 10
    ! Get along-track angle between first MIFs of consecutive MAFs
    ! Usually, this is the angle between the first MIF of the current MAF,
    ! and the first MIF of the next one.  For the last MAF, this is the angle
    ! between the first MIF of the current MAF, and the first of the previous
    ! one.  There oughtn't to be much difference between this value and the
    ! one we would get by looking at the next file.
    angle = acos ( dot_product ( xyz(:,0), xyz(:,1) ) )
    mafno = mafno + 1

    call process_one_MAF ( mafno, rad_sd_id, oa_sd_id, angle, &
d314 1
a314 1
    ! Swap records
d316 1
d319 1
a319 1
  print *, 'mafs: ', mafno 
d331 2
a332 1
  subroutine Process_One_MAF ( MAFNo, Rad_SD_id, OA_SD_id, angle, &
d342 9
a350 1
    real, intent(in) :: Angle   ! Between first MIFs of consecutive MAFs, radians
d422 2
a423 1
    call UARS_to_EMLS_OA ( n_days, limb_oa, emls_oa, angle )
d431 32
d466 1
a466 1
       "$Id: ConstructQuantityTemplates.f90,v 2.177 2014/09/05 00:39:49 vsnyder Exp $"
d475 6
a480 1
! $Log: $
@


1.3
log
@Does not wrap or truncate file names longer than 80 characters
@
text
@d1 143
a143 1
PROGRAM conv_uars
d145 5
a149 87
USE rad_file_contents
USE swapendian
USE MLSCommon, ONLY: FileNameLen
USE MLSFiles, ONLY: MLS_openFile, MLS_closeFile
USE MLSAuxData, ONLY: CreateGroup_MLSAuxData
USE MLSHDF5, ONLY: MLS_h5open, MLS_h5close
USE Output_UARS_L1B
USE SDPToolkit
USE oa_file_contents

IMPLICIT NONE

CHARACTER (len=FileNameLen) :: arg, infile='uars.dat', Rad_File='RAD.h5', &
     OA_File='OA.h5', out_dir='/data/'
INTEGER, PARAMETER :: in_unit=101, inlen=14336/4, HDFversion=5
INTEGER :: i, j, k, mafno=0, nummmaf, recno, rad_sd_id, error, oa_sd_id, stat
INTEGER :: year, doy, month, day, ms, hrs, mins, secs, yrdoy, noargs
INTEGER, DIMENSION(32) :: mifno = (/ (i, i=1,32) /)

REAL :: allrad(15*6*32), rad(15*6,32), rad6(15,6,32), &
     allprec(15*6*32), prec(15*6,32), prec6(15,6,32)
EQUIVALENCE (allrad, rad), (allprec, prec), (rad, rad6), (prec, prec6)
CHARACTER (LEN=*), PARAMETER :: &
     DateFmt = "(I4, '-', I3.3, 'T', I2.2, ':', I2.2, ':', I2.2)", &
     data_dir = '/data/umls/l1/'
CHARACTER (len=17) :: utc_time
CHARACTER (len=8) :: yrdoy_str = 'yyyydnnn'
REAL*8 :: tai_time, gird_time
REAL*8, PARAMETER :: TAItoGIRD = 1104537627.0d00

INTEGER*2, EXTERNAL :: SwapShort  ! should put into SwapEndian later!!!
integer :: n_days = 0
CHARACTER (len=8) :: n_str

! Source code:
! Don't warp stdout at 80 chars
open(unit=6,recl=4096)

! Open UARS input file:

noargs = COMMAND_ARGUMENT_COUNT()
IF (noargs == 0) THEN
   PRINT *, 'No input file provided.'
   PRINT *, 'Using defaults...'
ELSE
   i = 1

   DO WHILE (i <= noargs)

      CALL GET_COMMAND_ARGUMENT (i, arg)

      SELECT CASE (arg)
      CASE default
         !infile = data_dir // TRIM(arg)     ! input filename (with dir)
         infile = TRIM(arg)                 ! input filename
         IF (noargs < 3) THEN
            PRINT *, 'Missing output directory argument? Too few args!'
            CALL EXIT
         ENDIF
      CASE ('-b', '--backdate')
         i = i + 1
         CALL GET_COMMAND_ARGUMENT (i, n_str)  ! how many days to backdate times in file
         read( n_str, * ) n_days
         ! Now we must take account for how mmaf_time actually encodes dates
         ! It uses a convention that the year contains 1000 days
         ! if the year y = 1900 + p
         ! and the doy   = d
         ! then mmaf_time = 1000*y + d (yes, I know this is ugh--
         ! "It was like that when I got here!")
         ! So we're assuming you either want to backdate by one day or so 
         ! or else by a number of years
         ! E.g., to backdate 10 years, set n_days to 3650 (we ignore leap years)
         if ( n_days > 364 ) n_days = 1000 * (n_days/365)
      CASE ('-o', '--outdir')
         i = i + 1
         CALL GET_COMMAND_ARGUMENT (i, out_dir)  ! next argument for out dir
      CASE ('-h', '--help')
         PRINT '(a)', 'usage: conv_uars [options] input_file' 
         PRINT '(a)', '      options' 
         PRINT '(a)', '  -o output_dir     write converted files to output_dir' 
         PRINT '(a)', '  -b n_days         backdate converted files in time by n_days' 
         PRINT '(a)', '  -h                print help' 
         CALL EXIT
      END SELECT
      i = i + 1   ! Next argument
   ENDDO
ENDIF
d151 2
a152 2
OPEN (unit=in_unit, file=infile, status="OLD", form="UNFORMATTED", &
     access="DIRECT", recl=inlen, iostat=error)
d154 4
a157 4
IF (error /= 0) THEN
   PRINT *, 'No such input file: '//infile
   CALL EXIT
ENDIF
d159 1
a159 1
! read and convert header part:
d161 1
a161 1
DO recno = 1, 3
d163 1
a163 1
   READ (unit=in_unit, rec=recno) lvl1_hdr
d165 1
a165 1
   ! convert to little endian as needed:
d167 2
a168 2
   lvl1_hdr%recordno = SwapBig (lvl1_hdr%recordno)
   DO i = 1, 2
d172 225
a396 137
   ENDDO
   lvl1_hdr%nummmaf = SwapBig (lvl1_hdr%nummmaf)
   lvl1_hdr%uars_day = SwapBig (lvl1_hdr%uars_day)
   lvl1_hdr%mls_status_day = SwapBig (lvl1_hdr%mls_status_day)

ENDDO

nummmaf = lvl1_hdr%nummmaf

IF (nummmaf == 0) THEN
   PRINT *, 'No data in file: '//infile
   CALL EXIT
ENDIF

! get the yrdoy of file:

recno = nummmaf / 2
READ (unit=in_unit, rec=recno) limb_hdr
yrdoy = SwapBig (limb_hdr%mmaf_time(1)) - n_days ! This lets us backdate the files; e.g., for sids

IF (noargs > 0) THEN   ! use passed input for setting outputs
   year = yrdoy / 1000 + 1900
   doy = MOD (yrdoy, 1000)
   WRITE (yrdoy_str, '(i4.4, "d", i3.3)') year, doy
   PRINT *, 'yrdoy, year, doy, str: ', yrdoy, year, doy, yrdoy_str

   Rad_File = TRIM(out_dir) // '/MLS-UARS_L1BRAD_' // yrdoy_str // '.h5'
   OA_File = TRIM(out_dir) // '/MLS-UARS_L1BOA_' // yrdoy_str // '.h5'
ENDIF

write( 6, '(a)' ) 'infile: ' // trim(infile)
write( 6, '(a)' ) 'rad file: ' // trim(Rad_File)
write( 6, '(a)' ) 'OA file: ' // trim(OA_File)
PRINT *, 'n days backdated: ', n_days

! Open output RAD and OA HDF files:

error = 0
CALL MLS_h5open (error)
 
CALL MLS_openFile (Rad_File, 'create', rad_sd_id, HDFversion)

CALL MLS_openFile (OA_File, 'create', oa_sd_id, HDFversion)
CALL CreateGroup_MLSAuxData (oa_sd_id, 'GHz')
CALL CreateGroup_MLSAuxData (oa_sd_id, 'sc')

! save attributes for both HDF files:

CALL set_attributes (rad_sd_id, yrdoy, lvl1_hdr%start_time, lvl1_hdr%stop_time)
CALL set_attributes (oa_sd_id, yrdoy, lvl1_hdr%start_time, lvl1_hdr%stop_time)

! print stuff!

PRINT *, 'uars day', lvl1_hdr%uars_day
PRINT *, 'start time: ', lvl1_hdr%start_time
PRINT *, 'stop time: ', lvl1_hdr%stop_time
PRINT *, 'yrdoy: ', yrdoy

PRINT *, 'nummmaf: ', nummmaf
! read and convert data:

DO recno = 4, nummmaf+3

   READ (unit=in_unit, rec=recno) limb_hdr, limb_stat, limb_rad, limb_oa
   mafno = mafno + 1

   ! convert to little endian as needed:

   limb_hdr%recordno = SwapBig (limb_hdr%recordno)
   limb_hdr%mmafno = SwapBig (limb_hdr%mmafno)
   DO i = 1, 2
      limb_hdr%mmaf_time(i) = SwapBig (limb_hdr%mmaf_time(i)) ! - n_days
   ENDDO
   DO i = 1, 16
      limb_stat%prd_temps(i) = SwapBig (limb_stat%prd_temps(i))
   ENDDO
   limb_stat%maneuver_stat = SwapBig (limb_stat%maneuver_stat)
   limb_stat%mls_status = SwapBig (limb_stat%mls_status)
   DO i = 1, 90
       limb_stat%wall_mmaf(i) = SwapShort (limb_stat%wall_mmaf(i))
   ENDDO

   ! convert radiances:

   DO k = 1, 32           ! MIF number
      DO j = 1, 2         ! radiance/error
         DO i = 1, 90     ! radiometer and channel
            limb_rad%rad_l1(i,j,k) = SwapShort (limb_rad%rad_l1(i,j,k))
         ENDDO
      ENDDO
   ENDDO

   rad = limb_rad%rad_l1(:,1,:)
   prec = limb_rad%rad_l1(:,2,:)
   WHERE (allrad .LT. 0.0 .AND. allrad .NE. -1000.0) allrad = allrad + 65536.0
   WHERE (allprec .LT. 0.0 .AND. allprec .NE. -1000.0) &
        allprec = allprec + 65536.0
   WHERE (allrad .NE. -1000.0) allrad = allrad * 0.01   ! scale radiances

   WHERE (allprec .EQ. -1000.0) allprec = -1.0
   WHERE (allprec .NE. -1.0) allprec = allprec * 0.01   ! scale precisions

   year = limb_hdr%mmaf_time(1) / 1000 + 1900
   doy = MOD (limb_hdr%mmaf_time(1), 1000)

   ! convert millisecs to HMS:

   CALL ms_to_hms (limb_hdr%mmaf_time(2), hrs, mins, secs)
   WRITE (utc_time, fmt=DateFmt) year, doy, hrs, mins, secs

   ! get and save the GIRD time:

   stat = PGS_TD_UTCtoTAI (utc_time, tai_time)
   gird_time = tai_time + TAItoGIRD

   ! write radiances etc. to file:

   CALL OutputL1B_rad (rad_sd_id, mafno, limb_hdr%mmafno, rad6, prec6, &
                       gird_time)

   ! swap all OA bytes:

   CALL swap_oa_rec

   ! convert to EMLS OA:

   CALL uars_to_emls_oa ( n_days )

   ! write to OA file:

   CALL OutputL1B_OA (oa_sd_id, mafno, limb_hdr%mmafno)

ENDDO

PRINT *, 'mafs: ', mafno 

CLOSE (in_unit)
d398 1
a398 3
CALL MLS_closeFile (rad_sd_id, HDFversion=HDFversion)
CALL MLS_closeFile (oa_sd_id, HDFversion=HDFversion)
CALL MLS_h5close (error)
d400 1
a400 1
END PROGRAM conv_uars
@


1.2
log
@Added option to backdate by n_days
@
text
@d5 1
d15 1
a15 1
CHARACTER (len=80) :: arg, infile='uars.dat', Rad_File='RAD.h5', &
d38 2
d142 3
a144 3
PRINT *, 'infile: ', infile
PRINT *, 'rad file: ', Rad_File
PRINT *, 'OA file: ', OA_File
@


1.1
log
@Initial commit
@
text
@d33 2
d55 2
a56 2
         IF (noargs /= 3) THEN
            PRINT *, 'Missing output directory argument!'
d59 14
d77 5
a81 1
         PRINT '(a)', 'usage: conv_uars [-h] input_file -o output_dir' 
d127 1
a127 1
yrdoy = SwapBig (limb_hdr%mmaf_time(1))
d142 1
d180 1
a180 1
      limb_hdr%mmaf_time(i) = SwapBig (limb_hdr%mmaf_time(i))
d235 1
a235 1
   CALL uars_to_emls_oa
@

