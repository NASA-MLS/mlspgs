head	1.4;
access;
symbols
	v5-02-NRT-19:1.4
	v6-00:1.4
	v5-02-NRT-18:1.4
	v5-02:1.4
	v5-01-NRT-17:1.4
	v5-01-NRT-16:1.4
	v5-01-NRT-15:1.4
	v5-01-NRT-14:1.4
	neuralnetworks-1-0:1.4.0.12
	cfm-single-freq-0-1:1.4.0.10
	v5-01:1.4
	v5-00:1.4
	v4-23-TA133:1.4.0.8
	mus-emls-1-70:1.4.0.6
	rel-1-0-englocks-work:1.4.0.4
	VUMLS1-00:1.4
	VPL1-00:1.4
	V4-22-NRT-08:1.4
	VAM1-00:1.4
	V4-21:1.4.0.2;
locks; strict;
comment	@# @;


1.4
date	2015.01.24.02.16.25;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2015.01.22.02.18.56;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2014.12.11.00.48.51;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2014.06.17.17.40.27;	author perun;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Remove debugging cruft, remove orbit inclination -- which appeared to be wrong
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Calc_GeodAngle_m

  implicit NONE
  private

  public :: Calc_GeodAngle

  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Calc_GeodAngle.f90,v $"
  private :: not_used_here 
  !---------------------------------------------------------------------------

contains ! ============= Public procedures ===================================


  subroutine Calc_GeodAngle ( mif, fmaf, flosf, emls_oa )

    use Constants, only: Deg2Rad, Rad2Deg, Pi
    use Cross_m, only: Cross
    use Geometry, only: EarthRadA, EarthRadB ! Equatorial, polar radii
    use MLSKinds, only: R8
    use OA_File_contents, only: emls_oa_t

    implicit none

    ! Args
    integer, intent(in) :: MIF
    real(r8), intent(in) :: FMAF(3,3), FLOSF(3,3)
    type(emls_oa_t), intent(inout) :: EMLS_OA

    real(r8), parameter :: A = EarthRadA / 1000.0_r8, B = EarthRadB / 1000.0_r8
    real :: tngt_clat, clat_t, slat_t, clong_t, slong_t, clat, slat
    real(r8) :: r_e, n_e(3), n_s(3), ABCDEF(3,3), n_fovd(3), n_pp(3), beta_r, &
         del_phi_t, cbeta_r, sbeta_r, mu_r, los_ascdsc, cmu_r, phi, phi_t_inst, &
         gamma, c_e, los_mat(3,3)
    character (len=*), parameter :: nl = char(10)

    tngt_clat = emls_oa%geoc_lat(mif) * Deg2Rad
    slat_t = SIN (tngt_clat)
    clat_t = COS (tngt_clat)
    slong_t = SIN (emls_oa%lon(mif) * Deg2Rad)
    clong_t = COS (emls_oa%lon(mif) * Deg2Rad)
    r_e = SQRT ((a*clat_t)**2 + (b*slat_t)**2)
    n_e = [ a*clat_t*clong_t, a*clat_t*slong_t, &
          & b*slat_t ] / r_e
    n_s = emls_oa%sc_ECR(:,mif) / norm2(emls_oa%sc_ECR(:,mif))
    del_phi_t = ACOS (dot_product (n_s, n_e)) * Rad2Deg
    ABCDEF = RESHAPE (emls_oa%ECRtoFOV(:,mif), (/ 3, 3 /))

    n_fovd = ABCDEF(3,:)
    slat = SIN (emls_oa%sc_geoclat(mif) * Deg2Rad)
    clat = COS (emls_oa%sc_geoclat(mif) * Deg2Rad)
    n_pp = cross ( n_s, n_fovd, norm=.true. )
    beta_r = ACOS (n_pp(3)) * Rad2Deg
    sbeta_r = SIN (0.5*Pi - beta_r*Deg2Rad)
    cbeta_r = COS (0.5*Pi - beta_r*Deg2Rad)
    mu_r = ASIN (MAX (MIN (-slat*sbeta_r / (clat*cbeta_r), 1.0d0), -1.0d0)) * &
         Rad2Deg

    los_mat = TRANSPOSE (MATMUL ((MATMUL (TRANSPOSE (ABCDEF), fmaf)), &
         TRANSPOSE (flosf)))   ! matches IDL output!!!
    los_ascdsc = los_mat(3,3)  ! n_fovd(3)
    if (los_ascdsc > 0.0) mu_r = 180.0d0 - mu_r

    cmu_r = COS (mu_r * Deg2Rad)
    phi = ACOS (cmu_r * clat ) * Rad2Deg
    if (emls_oa%sc_geoclat(mif) >= 0.0) then
       phi = 180.0d0 - phi
    else
       phi = 180.0d0 + phi
    end if
    gamma = phi + del_phi_t
    c_e = SQRT ( (a*b)**2 / &
         ( (a * COS (Deg2Rad * (beta_r - 90.0d0)))**2 &
         + (b * SIN (Deg2Rad * (beta_r - 90.0d0)))**2) )
    phi_t_inst = ATAN2 ( a**2 * SIN (Deg2Rad * gamma), &
                         c_e**2 * COS (Deg2Rad*gamma) ) * Rad2Deg
    if (phi_t_inst < 0.0d0) phi_t_inst = 360.0d0 + phi_t_inst

    ! Save the Geodetic Angle:

    emls_oa%geod_ang(mif) = phi_t_inst

  end subroutine Calc_GeodAngle

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Calc_GeodAngle.f90,v 1.3 2015/01/22 02:18:56 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Calc_GeodAngle_m

! $Log: Calc_GeodAngle.f90,v $
! Revision 1.3  2015/01/22 02:18:56  vsnyder
! PGS_Interfaces.f90
!
! Revision 1.2  2014/12/11 00:48:51  vsnyder
! Move external procedures into modules.  Add copyright and CVS lines.
! Compute MIF geolocation (except height) for SC.  Compute MIF-resolved
! SC velocity.  Some cannonball polishing.
!
@


1.3
log
@PGS_Interfaces.f90
@
text
@a76 8
  if (mif == 9916) then
     print *, 'matmuls:'
     print *, 'los_ascdsc: ', los_ascdsc
     !print *, 'los_mat:'
     !print *, los_mat
     !print *, 'mu_r: ', mu_r
  end if

a95 19
    ! Save the OrbIncl:

    emls_oa%sc_orbincl = beta_r

  if (mif == 9916) then
     print *, 'c_e: ', c_e
     print *, 'r_e: ', r_e
     print *, 'n_e: ', n_e
     print *, 'ECR: ', emls_oa%ECR(:,mif)
     print *, 'ABCDEF: '
     print *, ABCDEF
     print *, 'phi_t_inst: ', phi_t_inst
     print *, 'beta_r: ', beta_r
     print *, 'del_phi_t: ', del_phi_t
     print *, 'mu_r: ', mu_r
     print *, 'phi: ', phi
     print *, 'gamma: ', gamma
  end if

d101 1
a101 1
       "$Id: Calc_GeodAngle.f90,v 1.2 2014/12/11 00:48:51 vsnyder Exp $"
d111 3
@


1.2
log
@Move external procedures into modules.  Add copyright and CVS lines.
Compute MIF geolocation (except height) for SC.  Compute MIF-resolved
SC velocity.  Some cannonball polishing.
@
text
@d21 1
a21 1
       "$RCSfile: ConstructQuantityTemplates.f90,v $"
a29 1
    use OA_File_contents, only: emls_oa_t
d32 1
d34 1
d43 1
a43 1
    real(r8), parameter :: ellipse(0:1) = (/ 6378.137D0, 6356.7523141D0 /)
d55 5
a59 5
    r_e = SQRT ((ellipse(0)*clat_t)**2 + (ellipse(1)*slat_t)**2)
    n_e = [ellipse(0)*clat_t*clong_t, ellipse(0)*clat_t*slong_t, &
         ellipse(1)*slat_t] / r_e
    n_s = emls_oa%sc_ECR(:,mif) / SQRT (SUM (emls_oa%sc_ECR(:,mif)**2))
    del_phi_t = ACOS (SUM (n_s * n_e)) * Rad2Deg
d74 1
a74 1
    los_ascdsc = los_mat(3,3) !n_fovd(3)
d93 5
a97 5
    c_e = SQRT ((ellipse(0)*ellipse(1))**2 / &
         ((ellipse(0) * COS (Deg2Rad * (beta_r - 90.0d0)))**2 &
         + (ellipse(1) * SIN (Deg2Rad * (beta_r - 90.0d0)))**2))
    phi_t_inst = ATAN2 (ellipse(0)**2 * SIN (Deg2Rad * gamma), &
         c_e**2 * COS (Deg2Rad*gamma)) * Rad2Deg
d128 1
a128 1
       "$Id: ConstructQuantityTemplates.f90,v 2.177 2014/09/05 00:39:49 vsnyder Exp $"
d137 6
a142 1
! $Log: ConstructQuantityTemplates.f90,v $
@


1.1
log
@Initial commit
@
text
@d1 132
a132 1
subroutine Calc_GeodAngle (mif, fmaf, flosf)
d134 1
a134 2
  USE oa_file_contents, ONLY: emls_oa
  USE Constants, ONLY: Deg2Rad, Rad2Deg, Pi
d136 1
a136 87
  implicit none

  integer, INTENT(IN) :: mif
  real*8, INTENT(IN) :: fmaf(3,3), flosf(3,3)

  REAL*8, parameter :: ellipse(0:1) = (/ 6378.137D0, 6356.7523141D0 /)
  real :: tngt_clat, clat_t, slat_t, clong_t, slong_t, clat, slat
  REAL*8 :: r_e, n_e(3), n_s(3), ABCDEF(3,3), n_fovd(3), n_pp(3), beta_r, &
       del_phi_t, cbeta_r, sbeta_r, mu_r, los_ascdsc, cmu_r, phi, phi_t_inst, &
       gamma, c_e, los_mat(3,3)
  CHARACTER (LEN=*), PARAMETER :: nl = char(10)

  tngt_clat = emls_oa%geoc_lat(mif) * Deg2Rad
  slat_t = SIN (tngt_clat)
  clat_t = COS (tngt_clat)
  slong_t = SIN (emls_oa%lon(mif) * Deg2Rad)
  clong_t = COS (emls_oa%lon(mif) * Deg2Rad)
  r_e = SQRT ((ellipse(0)*clat_t)**2 + (ellipse(1)*slat_t)**2)
  n_e = [ellipse(0)*clat_t*clong_t, ellipse(0)*clat_t*slong_t, &
       ellipse(1)*slat_t] / r_e
  n_s = emls_oa%sc_ECR(:,mif) / SQRT (SUM (emls_oa%sc_ECR(:,mif)**2))
  del_phi_t = ACOS (SUM (n_s * n_e)) * Rad2Deg
  ABCDEF = RESHAPE (emls_oa%ECRtoFOV(:,mif), (/ 3, 3 /))

  n_fovd = ABCDEF(3,:)
  slat = SIN (emls_oa%sc_geoclat(mif) * Deg2Rad)
  clat = COS (emls_oa%sc_geoclat(mif) * Deg2Rad)
  call cross_product (n_s, n_fovd, n_pp)
  n_pp = n_pp / SQRT (SUM (n_pp**2))
  beta_r = ACOS (n_pp(3)) * Rad2Deg
  sbeta_r = SIN (0.5*Pi - beta_r*Deg2Rad)
  cbeta_r = COS (0.5*Pi - beta_r*Deg2Rad)
  mu_r = ASIN (MAX (MIN (-slat*sbeta_r / (clat*cbeta_r), 1.0d0), -1.0d0)) * &
       Rad2Deg

  los_mat = TRANSPOSE (MATMUL ((MATMUL (TRANSPOSE (ABCDEF), fmaf)), &
       TRANSPOSE (flosf)))   ! matches IDL output!!!
  los_ascdsc = los_mat(3,3) !n_fovd(3)
  if (los_ascdsc > 0.0) mu_r = 180.0d0 - mu_r

if (mif == 9916) then
   print *, 'matmuls:'
   print *, 'los_ascdsc: ', los_ascdsc
   !print *, 'los_mat:'
   !print *, los_mat
   !print *, 'mu_r: ', mu_r
endif

  cmu_r = COS (mu_r * Deg2Rad)
  phi = ACOS (cmu_r * clat ) * Rad2Deg
  if (emls_oa%sc_geoclat(mif) >= 0.0) then
     phi = 180.0d0 - phi
  else
     phi = 180.0d0 + phi
  endif
  gamma = phi + del_phi_t
  c_e = SQRT ((ellipse(0)*ellipse(1))**2 / &
       ((ellipse(0) * COS (Deg2Rad * (beta_r - 90.0d0)))**2 &
       + (ellipse(1) * SIN (Deg2Rad * (beta_r - 90.0d0)))**2))
  phi_t_inst = ATAN2 (ellipse(0)**2 * SIN (Deg2Rad * gamma), &
       c_e**2 * COS (Deg2Rad*gamma)) * Rad2Deg
  if (phi_t_inst < 0.0d0) phi_t_inst = 360.0d0 + phi_t_inst

  ! Save the Geodetic Angle:

  emls_oa%geod_ang(mif) = phi_t_inst

  ! Save the OrbIncl:

  emls_oa%sc_orbincl = beta_r

if (mif == 9916) then
   print *, 'c_e: ', c_e
   print *, 'r_e: ', r_e
   print *, 'n_e: ', n_e
   print *, 'ECR: ', emls_oa%ECR(:,mif)
   print *, 'ABCDEF: '
   print *, ABCDEF
   print *, 'phi_t_inst: ', phi_t_inst
   print *, 'beta_r: ', beta_r
   print *, 'del_phi_t: ', del_phi_t
   print *, 'mu_r: ', mu_r
   print *, 'phi: ', phi
   print *, 'gamma: ', gamma
endif

end subroutine Calc_GeodAngle
@

