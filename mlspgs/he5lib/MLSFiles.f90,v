head	1.13;
access;
symbols
	v5-02-NRT-19:1.13
	v6-00:1.13
	v5-02-NRT-18:1.13
	v5-02:1.13
	v5-01-NRT-17:1.13
	v5-01-NRT-16:1.13
	v5-01-NRT-15:1.13
	v5-01-NRT-14:1.13
	neuralnetworks-1-0:1.13.0.16
	cfm-single-freq-0-1:1.13.0.14
	v5-01:1.13
	v5-00:1.13
	v4-23-TA133:1.13.0.12
	mus-emls-1-70:1.13.0.10
	rel-1-0-englocks-work:1.13.0.8
	VUMLS1-00:1.13
	VPL1-00:1.13
	V4-22-NRT-08:1.13
	VAM1-00:1.13
	V4-21:1.13.0.6
	V4-13:1.13
	V4-12:1.13
	V4-11:1.13
	V4-10:1.13
	V3-43:1.13
	M4-00:1.13
	V3-41:1.13
	V3-40-PlusGM57:1.13.0.4
	V2-24-NRT-04:1.13
	V3-33:1.13
	V2-24:1.13
	V3-31:1.13
	V3-30-NRT-05:1.13
	cfm-01-00:1.13
	V3-30:1.13
	V3-20:1.13
	V3-10:1.13
	V2-23-NRT-02:1.13
	V2-23:1.13
	V2-22-NRT-01:1.13
	V2-22:1.13
	V2-21:1.13
	V2-20:1.13
	V2-11:1.13
	V2-10:1.13
	V2-00:1.13
	V1-51:1.13
	V1-50:1.13
	V1-45:1.13
	V1-44:1.13
	V1-43:1.13
	V1-32:1.13
	V1-31:1.13
	V1-13:1.13
	V1-12:1.13
	V1-11:1.13
	V1-10:1.13
	newfwm-feb03:1.13.0.2
	V1-04:1.11
	V1-03:1.11
	V1-02:1.11
	V1-00:1.11;
locks; strict;
comment	@# @;


1.13
date	2002.06.12.17.59.37;	author livesey;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.28.23.11.23;	author pwagner;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.23.31.57;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.13.18.32.05;	author pwagner;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.23.39.29;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.31.00.36.41;	author pwagner;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.29.23.46.30;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.29.00.48.43;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.26.00.14.47;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.23.22.41.21;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.23.00.54.10;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.18.23.55.49;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.18.00.51.22;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Brought get_free_lun in from lib version
@
text
@! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

!===============================================================================
module MLSFiles               ! Utility file routines
  !===============================================================================
  use Hdf, only: DFACC_CREATE, DFACC_RDONLY, DFACC_READ, DFACC_RDWR, &
    & sfstart, sfend
  use Hdf5, only: h5fopen_f, h5fclose_f, h5fis_hdf5_f
  use Hdf5_params, only: H5F_ACC_RDONLY, H5F_ACC_RDWR, H5F_ACC_TRUNC
  use HDFEOS, only: gdclose, gdopen, swclose, swopen, swinqswath
  use HDFEOS5, only: he5_swclose, he5_swopen, he5_swinqswath, &
    & he5_gdopen, he5_gdclose, &
    & HE5F_ACC_TRUNC, HE5F_ACC_RDONLY, HE5F_ACC_RDWR
  use machine, only: io_error
  use MLSCommon, only: i4, BareFNLen
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
  use MLSStrings, only: Capitalize, LowerCase, Reverse, SortArray
  use output_m, only: blanks, output
  use SDPToolkit, only: &
    & HDF5_ACC_CREATE, HDF5_ACC_RDONLY, HDF5_ACC_RDWR,  &
    & Pgs_pc_getReference, PGS_S_SUCCESS, &
    & PGSd_IO_Gen_RSeqFrm, PGSd_IO_Gen_RSeqUnf, & 
    & PGSd_IO_Gen_RDirFrm, PGSd_IO_Gen_RDirUnf, & 
    & PGSd_IO_Gen_WSeqFrm, PGSd_IO_Gen_WSeqUnf, & 
    & PGSd_IO_Gen_WDirFrm, PGSd_IO_Gen_WDirUnf, & 
    & PGSd_IO_Gen_USeqFrm, PGSd_IO_Gen_USeqUnf, & 
    & PGSd_IO_Gen_UDirFrm, PGSd_IO_Gen_UDirUnf, & 
    & PGSd_IO_Gen_ASeqFrm, PGSd_IO_Gen_ASeqUnf, &
    & PGS_IO_GEN_CloseF, PGS_IO_GEN_OpenF, PGSd_PC_FILE_PATH_MAX, &
    & UseSDPToolkit
!   In the long run, we'll try putting interfaces to these in SDPToolkit.f90
!   Until then, just declare them as external
!    & PGS_MET_SFstart, PGS_MET_SFend, &
  implicit none

  private 

  public :: GetPCFromRef, get_free_lun, mls_io_gen_openF, &
  & mls_io_gen_closeF, split_path_name, &
  & mls_hdf_version, mls_inqswath, mls_sfstart, mls_sfend

  !------------------- RCS Ident Info -----------------------
  character(LEN=130) :: Id = &
    "$Id: MLSFiles.f90,v 2.32 2002/06/04 18:11:39 bill Exp $"
  character (len=*), private, parameter :: ModuleName= &
    "$RCSfile: MLSFiles.f90,v $"
  !----------------------------------------------------------

!     c o n t e n t s
!     - - - - - - - -

! GetPCFromRef       Turns a FileName into the corresponding PC
! get_free_lun       Gets a free logical unit number
! mls_hdf_version    Returns one of 'hdf4', 'hdf5', or '????'
! mls_inqswath       A wrapper for doing swingswath for versions 4 and 5
! mls_io_gen_openF   Opens a generic file using either the toolbox or else a Fortran OPEN statement
! mls_io_gen_closeF  Closes a generic file using either the toolbox or else a Fortran OPEN statement
! mls_sfstart        Opens an hdf file for writing metadata
! mls_sfend          Closes a file opened by mls_sfstart
! split_path_name    splits the input full_file_name into its components path and name
! hdf2hdf5_fileaccess
!                    Translates version 4 hdf access codes to version 5

   ! Assume hdf files w/o explicit hdfVersion field are this
   ! 4 corresponds to hdf4, 5 to hdf5 in L2GP, L2AUX, etc.
   integer, parameter, public :: HDFVERSION_4 = 4
   integer, parameter, public :: HDFVERSION_5 = 5
   integer, parameter         :: DEFAULT_HDFVERSION = HDFVERSION_5
   
  ! Given this hdfVersion, try to autorecognize hdfversion
  ! then perform appropriate version of open/close; i.e., forgiving
  ! (must *not* be 4 or 5)
  integer, parameter, public :: WILDCARDHDFVERSION=HDFVERSION_4+HDFVERSION_5

  ! This isn't NameLen because it may have a path prefixed
  integer, parameter :: MAXFILENAMELENGTH=PGSd_PC_FILE_PATH_MAX

  ! These are error codes that may be returned by GetPCFromRef

  integer, parameter, public :: NAMENOTFOUND=-1
  integer, parameter, public :: INVALIDPCRANGE=NAMENOTFOUND-1
  integer, parameter, public :: CANTALLOCATENAMEARRAY=INVALIDPCRANGE-1

  ! These are error codes that may be returned by mls_io_gen_openF

  integer, parameter, public :: UNKNOWNFILEACCESSTYPE=-999
  integer, parameter, public :: UNKNOWNTOOLBOXMODE=UNKNOWNFILEACCESSTYPE+1
  integer, parameter, public :: NOFREEUNITS=UNKNOWNTOOLBOXMODE+1
  integer, parameter, public :: MUSTSUPPLYFILENAMEORPC=NOFREEUNITS+1
  integer, parameter, public :: NOPCIFNOTOOLKIT=MUSTSUPPLYFILENAMEORPC+1
  integer, parameter, public :: NOSUCHHDFVERSION=NOPCIFNOTOOLKIT+1

  ! These are error codes that may be returned by mls_io_gen_openF
  ! or by mls_hdf_version if you call it directly

  integer, parameter, public :: MUSTSUPPLYFILENAME=NOSUCHHDFVERSION+1
  integer, parameter, public :: ERRORINH5FFUNCTION=MUSTSUPPLYFILENAME+1
  integer, parameter, public :: WRONGHDFVERSION=ERRORINH5FFUNCTION+1
  
  ! Whether to use PGS_MET commands in mls_sf(start)(end)
  ! (The alternative is to use hdf5 calls directly)
  logical, parameter :: PGS_MET4MLS_SF = .true.
  ! Whether to pass hdf5_acc types to PGS_MET 
  ! (The alternative is to pass h5f_acc directly)
  ! Contradicting what the documents say,
  ! currently (TK 5.2.7.4) the toolkit routine
  ! PGS_MET_HDFSDStart.c assumes the File Access is of
  ! one of the following types:
  ! (1) hdf4_acc: DFACC_RDWR, DFACC_RDONLY, or DFACC_CREATE
  !      (equiv. to HDF4_ACC_RDWR, etc.)
  ! (2) hdf5_acc: HDF5_ACC_RDWR, HDF5_ACC_RDONLY, or HDF5_ACC_CREATE
  !          * * *    w a r n i n g   * * *
  ! According to mls/hirdls telecom of 03-12-2002 this will change
  ! in a future release of the toolkit
  ! That means some programmer (paw?) will have to revisit
  ! this and see what the toolkit code actually does,
  ! not just what the docs say
  logical, parameter :: HDF5_ACC_TYPES_TO_MET = .true.
  integer, parameter :: HDF5_ACC_DEFAULT = HE5F_ACC_RDWR ! HDF5_ACC_RDWR
  
  ! The only legal unit numbers that files may be assigned
  ! for use by Fortran opens, closes, reads and writes
  integer, parameter :: bottom_unit_num=1
  integer, parameter :: top_unit_num=99

contains

  ! ---------------------------------------------  GetPCFromRef  -----

  ! This function takes a FileName as an arg and a range of PC numbers
  ! [PCBottom, PCTop] which are integers
  ! It returns thePC corresponding to the FileName

  ! FileName may be a fragment such as l2gp_temp of a longer name
  ! such as mls_l2_temp_v0.5_01-01-2004.dat

  ! If no matching file found, it sets ErrType=NAMENOTFOUND
  ! otherwise ErrType=0

  ! This is useful because all the Toolbox routines refer to files
  ! by their PC numbers, not their names

  ! Optionally you may require the match to be case-sensitive
  !   (by default it is not: l2_temp will match MLS_L2_TEMP_...)

  ! If you pass in a path, it will require that the paths also match

  ! Optionally you may pass in a version number and a debug flag

  ! optionally returns the exact name of the matching file

  function GetPCFromRef(FileName, PCBottom, PCTop, &
    & caseSensitive, ErrType, versionNum, debugOption, path, ExactName) &
    & result (thePC)

    ! Dummy arguments
    character (LEN=*), intent(IN)            :: FileName
    integer(i4),  intent(IN)                 :: PCBottom, PCTop
    integer(i4)                              :: thePC, notThePC
    integer(i4),  intent(OUT)                :: ErrType
    logical,  intent(IN)                     :: caseSensitive
    integer(i4),  optional                   :: versionNum
    logical,  optional, intent(IN)           :: debugOption
    character (LEN=*),  optional, intent(IN) :: path
    character (LEN=*), optional, intent(out) :: ExactName

    ! Local variables
    character (LEN=BareFNLen), dimension(:), allocatable &
     &                                :: nameArray
    integer, dimension(:), allocatable &
     &                                :: intArray
    character (LEN=*), parameter      :: UNASSIGNEDFILENAME = '*'
    character (LEN=MAXFILENAMELENGTH) :: MatchName, TryName, NameOnly
    character (LEN=MAXFILENAMELENGTH) :: PhysicalName, MatchPath
	 integer                       ::     version, returnStatus
    integer                       ::     numberPCs
    logical ::                            debug

   if(.not. UseSDPToolkit) then
      ErrType = NOPCIFNOTOOLKIT
      thePC = 0
      return
   endif

    if(present(debugOption)) then
      debug = debugOption
   else
      debug = .false.
   endif
   
    if(debug) then
      call output('get pc from ref', advance='yes')
      call output('FileName: ' // trim(FileName), advance='yes')
      call output('lower PCF limit: ' )
      call output(PCBottom, advance='yes')
      call output('upper PCF limit: ' )
      call output(PCTop, advance='yes')
      call output('case sensitive?: ' )
      call output(caseSensitive, advance='yes')
      call output('version number: ' )
      call output(versionNum, advance='yes')
    endif

    thePC = 0
    if(PCTop < PCBottom) then
      ErrType = INVALIDPCRANGE
      return
    endif

    if(caseSensitive) then
      MatchName = FileName
    else
      MatchName = Capitalize(FileName)
    endif

    if(debug) then
      call output('getting ref from pc:', advance='no')
    endif

    numberPCs = PCTop - PCBottom + 1
    Allocate(nameArray(numberPCs), intArray(numberPCs), STAT=ErrType)
    if ( ErrType /= 0 ) then
      ErrType = CANTALLOCATENAMEARRAY
      return
    endif

    ErrType = NAMENOTFOUND
    nameArray = UNASSIGNEDFILENAME
    do thePC = PCBottom, PCTop

      if(present(versionNum)) then
        version = versionNum
      else
        version = 1
      endif

      returnStatus = Pgs_pc_getReference(thePC, version, &
        & PhysicalName)

      if ( returnStatus == PGS_S_SUCCESS ) then

        if(.not. caseSensitive) then
          TryName = Capitalize(PhysicalName)
        else
          TryName = PhysicalName
        endif
        
        call split_path_name(TryName, MatchPath, NameOnly)
        nameArray(thePC-PCBottom+1) = NameOnly
      endif

    enddo
    ! Sort the file names from short to long
    ! to prevent unwanted matches between "O3" and "HNO3"
    call SortArray(nameArray, intArray, caseSensitive, &
     & sortedArray=nameArray, shorterFirst=.true., leftRight='r')
    do notThePC = 1, numberPCs
      thePC = intArray(notThePC) + PCBottom - 1         
      NameOnly = nameArray(notThePC)            
      if ( index(NameOnly, trim(MatchName)) /= 0 )then  
        ErrType = 0                                     
        exit                                            
      endif                                             
    enddo

    if(present(versionNum)) then  
      version = versionNum        
    else                          
      version = 1                 
    endif                         
    returnStatus = Pgs_pc_getReference(thePC, version, &
        & PhysicalName)
    if ( returnStatus == PGS_S_SUCCESS ) then             

      if(.not. caseSensitive) then                        
        TryName = Capitalize(PhysicalName)                
      else                                                
        TryName = PhysicalName                            
      endif                                               
                                                          
      call split_path_name(TryName, MatchPath, NameOnly)
    else
      ErrType = NAMENOTFOUND
    endif  
    if(present(path) .and. ErrType == 0) then
        if ( index(MatchPath, trim(path)) == 0 )then
          ErrType = NAMENOTFOUND
        endif
    endif

    if(present(ExactName) .and. ErrType == 0) then
      ExactName = PhysicalName
    endif

    Deallocate(nameArray, intArray)
  end function GetPCFromRef

! ---------------------------------------------- get_free_lun ------

! This function returns a free logical unit number

  INTEGER(i4) FUNCTION get_free_lun()
  LOGICAL :: exist                    ! Flag from inquire
  LOGICAL :: opened                   ! Flag from inquire
  DO get_free_lun = bottom_unit_num, top_unit_num
    INQUIRE(UNIT=get_free_lun, EXIST=exist, OPENED=opened)
    IF(exist .and. .not. opened) EXIT
  END DO
  IF (opened .or. .not. exist) CALL MLSMessage ( MLSMSG_Error, moduleName,  &
     "No logical unit numbers available" )
  END FUNCTION get_free_lun

  ! ---------------------------------------------  mls_io_gen_openF  -----

  ! This function opens a generic file using either the toolbox
  ! or else a Fortran OPEN statement
  ! according to toolbox_mode:
  ! 'sw' for swath files opened with swopen
  ! 'gd' for grid files opened with gdopen
  ! 'pg' for generic files opened with pgs_io_gen_openF
  ! 'op' for l3ascii files opened with simple fortran 'open'

  ! It returns theFileHandle corresponding to the FileName or the PC

  ! If given a FileName as an arg and a range of PC numbers
  ! [PCBottom, PCTop] which are integers
  ! it will attempt to find a corresponding PC

  ! If given a PC it will attempt to find the corresponding FileName

  ! toolbox_mode                  meaning
  ! PGS_IO_GEN_OpenF              use PGS_IO_Gen_OpenF or fail
  !      swopen                   use swopen or fail
  !      gdopen                   use gdopen or fail
  !       open                    use Fortran or fail

  ! If the FileName is not found, it sets ErrType=NAMENOTFOUND
  ! otherwise ErrType=0

  ! This is useful because all the Toolbox routines refer to files
  ! by their PC numbers, not their names

  function mls_io_gen_openF(toolbox_mode, caseSensitive, ErrType, &
    & record_length, FileAccessType, &
    & FileName, PCBottom, PCTop, versionNum, unknown, thePC, &
    & hdfVersion, debugOption) &
    &  result (theFileHandle)

    ! Dummy arguments
    integer(i4),  intent(OUT)  :: ErrType
    integer(i4),  intent(OUT)  :: record_length
    logical,  intent(IN)       :: caseSensitive
    character (LEN=*), intent(IN) :: toolbox_mode
    integer(i4), intent(IN)       :: FileAccessType
    integer(i4)  :: theFileHandle
    character (LEN=*), optional, intent(IN)   :: FileName
    integer(i4),  optional, intent(IN)   :: PCBottom, PCTop
    integer(i4), optional, intent(IN)                :: thePC
    integer(i4),  optional     :: versionNum
    logical, optional, intent(in) :: unknown
    logical, optional, intent(in) :: debugOption

    integer, optional, intent(in) :: hdfVersion

    ! Local
    integer :: myhdfVersion

    logical, parameter :: DEFAULT_PRINT_EVERY_OPEN=.false.
    integer, parameter :: FH_ON_ERROR=-99
    integer, parameter :: DEFAULTRECLEN=0
    integer, parameter :: KEYWORDLEN=12			! Max length of keywords in OPEN(...)
    character (LEN=MAXFILENAMELENGTH) :: myName
    integer(i4) :: myPC
    integer                       :: version, returnStatus, your_version
    logical       :: tiedup
    character (LEN=KEYWORDLEN) :: access, action, form, position, status
    character (LEN=2) :: the_eff_mode
    integer                       :: unit
    logical ::                            debug
    logical ::                            PRINT_EVERY_OPEN

    ! begin

    if(present(debugOption)) then
      debug = debugOption
   else
      debug = .false.
   endif

   PRINT_EVERY_OPEN = DEFAULT_PRINT_EVERY_OPEN .or. debug
   returnStatus = 0           ! In case using Toolkit but supplied FileName
    ! In case of premature return
    theFileHandle = FH_ON_ERROR
    record_length = DEFAULTRECLEN

    if(present(versionNum)) then
      version = versionNum
    else
      version = 1
    endif

   if(UseSDPToolkit) then
    the_eff_mode = LowerCase(toolbox_mode(1:2))
    your_version = version
   ! Using Toolkit
    if(present(thePC)) then
      myPC = thePC
      returnStatus = Pgs_pc_getReference(thePC, your_version, &
        & myName)
      if ( debug ) then
          call output('Call to Pgs_pc_getReference', &
          & advance='yes')
          call output('returnStatus: ', advance='no')
          call blanks(2)
          call output(returnStatus, advance='yes')
          call output('thePC: ', advance='no')
          call blanks(2)
          call output(thePC, advance='yes')
          call output('your_version: ', advance='no')
          call blanks(2)
          call output(your_version, advance='yes')
      endif
    elseif(present(FileName)) then
      myName = FileName
      if(LowerCase(toolbox_mode(1:2)) == 'pg') then
        myPC = GetPCFromRef(trim(FileName), PCBottom, PCTop, &
          &	 caseSensitive, returnStatus, your_version, &
          & debugOption=debugOption)
      endif

    else
      ErrType = MUSTSUPPLYFILENAMEORPC
      if ( debug ) & 
       & call output('Must supply file name or pc to mls_io_gen_openF', &
       & advance='yes')
      return
    endif

   ! Not Using Toolkit
   ! Must supply FileName, use generic Fortran open
   elseif(.not. present(FileName)) then
      ErrType = NOPCIFNOTOOLKIT
      if ( debug ) & 
       & call output('No toolkit: must supply file name to mls_io_gen_openF', &
       & advance='yes')
      return
      
   else
      myName = FileName
      the_eff_mode = LowerCase(toolbox_mode(1:2))
      if(the_eff_mode == 'pg') the_eff_mode = 'op'
   endif

   ! hdfVersion unimportant for 'pg' or 'op' operations
   if (the_eff_mode == 'pg' .or. the_eff_mode == 'op' ) then
     myhdfVersion = WILDCARDHDFVERSION
   else
     myhdfVersion = mls_hdf_version(trim(myName), hdfVersion, FileAccessType)             
   endif

   if ( debug ) then
       call output('Arguments and options in call to mls_io_gen_openF', &
       & advance='yes')
       call output('Mode: ', advance='no')
       call blanks(2)
       call output(the_eff_mode, advance='yes')
       call output('File Name: ', advance='no')
       call blanks(2)
       call output(trim(myName), advance='yes')
       call output('PCF-supplied number: ', advance='no')
       call blanks(2)
       call output(myPC, advance='yes')
       call output('Case sensitive? ', advance='no')
       call blanks(2)
       call output(caseSensitive, advance='yes')
       call output('File access type ', advance='no')
       call blanks(2)
       call output(FileAccessType, advance='yes')
       call output('Return status ', advance='no')
       call blanks(2)
       call output(returnStatus, advance='yes')
   endif

   if ( myhdfVersion < 0 ) then
     ErrType = myhdfVersion
     return
   endif
    your_version = version
    select case (the_eff_mode)

    case('pg')
      if(returnStatus == 0) then
         ErrType = PGS_IO_Gen_OpenF(myPC, FileAccessType, record_length, &
          & theFileHandle, your_version)
      else
        ErrType = returnStatus
       endif

    case('sw')
      if(returnStatus /= 0) then
        ErrType = returnStatus
        return
      elseif(myhdfVersion == HDFVERSION_5) then
        theFileHandle = he5_swopen(trim(myName), &
          & hdf2hdf5_fileaccess(FileAccessType))
      elseif(myhdfVersion == HDFVERSION_4) then
        theFileHandle = swopen(trim(myName), FileAccessType)
      else
        ErrType = NOSUCHHDFVERSION
        return
      endif
      if(theFileHandle <= 0) then                                          
        ErrType = min(theFileHandle, -1)                                   
      else                                                                 
        ErrType = 0                                                        
      endif                                                                
      if ( debug ) then                                                    
          call output('Args and results from he5_swopen', &                
          & advance='yes')                                                 
          call output('File Name: ', advance='no')                         
          call blanks(2)                                                   
          call output(trim(myName), advance='yes')                         
          call output('File Access: ', advance='no')                       
          call blanks(2)                                                   
          call output(hdf2hdf5_fileaccess(FileAccessType), advance='yes')  
          call output('theFileHandle: ', advance='no')                     
          call blanks(2)                                                   
          call output(theFileHandle, advance='yes')                        
      endif                                                                

    case('gd')
      if(returnStatus /= 0) then
        ErrType = returnStatus
        return
      elseif(myhdfVersion == HDFVERSION_5) then
        theFileHandle = he5_gdopen(trim(myName), &
          & hdf2hdf5_fileaccess(FileAccessType))
      elseif(myhdfVersion == HDFVERSION_4) then
        theFileHandle = gdopen(trim(myName), FileAccessType)
      else
        ErrType = NOSUCHHDFVERSION
        return
      endif
      if(theFileHandle <= 0) then         
        ErrType = min(theFileHandle, -1)  
      else                                
        ErrType = 0                       
      endif                               

    case('op')
      theFileHandle = FH_ON_ERROR
      if(FileAccessType == PGSd_IO_Gen_RSeqFrm) then
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'read'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_RSeqUnf) then
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'read'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_RDirFrm) then
        status = 'old'
        access = 'direct'
        form = 'formatted'
        action = 'read'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_RDirUnf) then
        status = 'old'
        access = 'direct'
        form = 'unformatted'
        action = 'read'
        position = 'rewind'

      elseif(FileAccessType == PGSd_IO_Gen_WSeqFrm) then
        status = 'new'
        access = 'sequential'
        form = 'formatted'
        action = 'write'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_WSeqUnf) then
        status = 'new'
        access = 'sequential'
        form = 'unformatted'
        action = 'write'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_WDirFrm) then
        status = 'new'
        access = 'direct'
        form = 'formatted'
        action = 'write'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_WDirUnf) then
        status = 'new'
        access = 'direct'
        form = 'unformatted'
        action = 'write'
        position = 'rewind'

      elseif(FileAccessType == PGSd_IO_Gen_USeqFrm) then
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_USeqUnf) then
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'readwrite'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_UDirFrm) then
        status = 'old'
        access = 'direct'
        form = 'formatted'
        action = 'readwrite'
        position = 'rewind'
      elseif(FileAccessType == PGSd_IO_Gen_UDirUnf) then
        status = 'old'
        access = 'direct'
        form = 'unformatted'
        action = 'readwrite'
        position = 'rewind'

      elseif(FileAccessType == PGSd_IO_Gen_ASeqFrm) then
        status = 'old'
        access = 'sequential'
        form = 'formatted'
        action = 'readwrite'
        position = 'append'
      elseif(FileAccessType == PGSd_IO_Gen_ASeqUnf) then
        status = 'old'
        access = 'sequential'
        form = 'unformatted'
        action = 'readwrite'
        position = 'append'

      else
        ErrType = UNKNOWNFILEACCESSTYPE
        if ( debug ) &
         & call output('Unknown file access type', advance='yes')
        return
      endif

      tiedup = .true.

      do unit = bottom_unit_num, top_unit_num
      	inquire ( unit=unit, opened=tiedup )
        if (.not. tiedup) then
          exit
        endif
      enddo

      if(tiedup) then
        ErrType = NOFREEUNITS
        if ( debug ) &
         & call output('No free io units available', advance='yes')
        return
      endif

      if (present(unknown)) then
        if (unknown) status = 'unknown'
      end if

      if(access /= 'direct') then
        open(unit=unit, access=access, action=action, form=form, &
          & position=position, status=status, file=trim(myName), iostat=ErrType)
      else
        open(unit=unit, access=access, action=action, form=form, &
          & status=status, file=trim(myName), iostat=ErrType)
      endif

      if(ErrType /= 0 .or. PRINT_EVERY_OPEN) then
        call output( 'Fortran opening unit ', advance='no')
        call output(  unit, advance='yes')
        call output( 'access ' // access, advance='yes')
        call output( 'action ' // action, advance='yes')
        call output( 'form ' // form, advance='yes')
        call output( 'position ' // position, advance='yes')
        call output( 'status ' // status, advance='yes')
        call output( 'file ' // trim(myName), advance='yes')
      endif

      if(ErrType /= 0) then
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: mls_io_gen_openF' // &
          & ' Fortran open', ErrType, trim(myName))
      else
        theFileHandle = unit
      endif

    case default
      ErrType = UNKNOWNTOOLBOXMODE

    end select

    if(ErrType /= 0) then
      theFileHandle = FH_ON_ERROR
    endif
    
    if( debug ) then
       call output('Error Type (0 means none): ', advance='no')
       call blanks(2)
       call output(ErrType, advance='yes')
       call output('record_length: ', advance='no')
       call blanks(2)
       call output(record_length, advance='yes')
       call output('theFileHandle: ', advance='no')
       call blanks(2)
       call output(theFileHandle, advance='yes')
    endif

  end function mls_io_gen_openF

  ! ---------------------------------------------  mls_io_gen_closeF  -----

  ! This function closes a generic file using either the toolbox
  ! or else a Fortran CLOSE statement
  ! according to toolbox_mode:
  ! 'sw' for swath files opened with swopen
  ! 'gd' for grid files opened with gdopen
  ! 'pg' for generic files opened with pgs_io_gen_openF
  ! 'cl' for l3ascii files opened with simple fortran 'open'

  ! It returns a non-zero error status only if unsuccessful

  ! It must be given a FileHandle as an arg
  ! (A later version may allow choice between file handle and file name)
  ! (This version only uses a file name in autodetecting its hdf version)
  function mls_io_gen_closeF(toolbox_mode, theFileHandle, &
    & FileName, hdfVersion) &
    &  result (ErrType)

    ! Dummy arguments
    integer(i4)  :: ErrType
    integer(i4), intent(IN)  :: theFileHandle
    character (LEN=*), intent(IN)   :: toolbox_mode
    character (LEN=*), optional, intent(IN)   :: FileName

    integer, optional, intent(in) :: hdfVersion

    ! Local
    integer :: myhdfVersion

    logical, parameter :: PRINT_EVERY_CLOSE=.false.
    character (LEN=2) :: the_eff_mode

    ! begin

   if(UseSDPToolkit) then
   ! Using Toolkit
    the_eff_mode = LowerCase(toolbox_mode(1:2))
   ! Not Using Toolkit
   else
      the_eff_mode = LowerCase(toolbox_mode(1:2))
      if(the_eff_mode == 'pg') the_eff_mode = 'cl'
   endif

   ! hdfVersion unimportant for 'pg' or 'cl' operations
   if (the_eff_mode == 'pg' .or. the_eff_mode == 'cl' ) then
     ErrType = 0
   elseif ( present(FileName) ) then
     myhdfVersion = mls_hdf_version(trim(FileName), hdfVersion, DFACC_READ)
     if ( myhdfVersion < 0 ) then
        ErrType = myhdfVersion
        return
     endif
   elseif ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
    select case (the_eff_mode)

    case('pg')
      ErrType = PGS_IO_Gen_CLoseF(theFileHandle)

    case('sw')
      if(myhdfVersion == HDFVERSION_5) then
        ErrType = he5_swclose(theFileHandle)
      elseif(myhdfVersion == HDFVERSION_4) then
        ErrType = swclose(theFileHandle)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    case('gd')
      if(myhdfVersion == HDFVERSION_5) then
        ErrType = he5_gdclose(theFileHandle)
      elseif(myhdfVersion == HDFVERSION_4) then
        ErrType = gdclose(theFileHandle)
      else
        ErrType = NOSUCHHDFVERSION
      endif

    case('cl')
      close(unit=theFileHandle, iostat=ErrType)		

      if(ErrType /= 0 .or. PRINT_EVERY_CLOSE) then
        call output( 'Fortran closing unit ', advance='no')
        call output(  theFileHandle, advance='yes')
      endif

      if(ErrType /= 0) then
        call output( 'iostat ', advance='no')
        call output(  ErrType, advance='yes')
        call io_error('io error in MLSFiles: mls_io_gen_closeF' // &
          & ' Fortran close', ErrType, 'unknown')
      endif

    case default
      ErrType = UNKNOWNTOOLBOXMODE

    end select

  end function mls_io_gen_closeF

  ! ---------------------------------------------  split_path_name  -----

  ! This routine splits the input full_file_name
  ! into its components path and name
  ! where path may include one or more "/" or slash elements
  ! (but one must be the terminating one; e.g., 'System/')
  ! while name must have none
  ! special cases by example: full_file_name -> (path, name)
  ! look.ma.no.slash -> (' ', 'look.ma.no.slash')
  ! Luke/I/am/your/father/ -> ('Luke/I/am/your/father/', ' ')

  ! optionally you may supply the slash divider
  ! which must be a single character

  subroutine split_path_name(full_file_name, path, name, slash)

    ! Arguments

    character (len=*), intent(in) :: full_file_name
    character (len=*), intent(out) :: path
    character (len=*), intent(out) :: name
    character (len=1), optional, intent(in) :: slash

    ! Local

    character (len=1) :: mySlash
    character (len=MAXFILENAMELENGTH) :: mirrored_ffn
    integer :: loc
!   logical, parameter :: DEBUG = .false.

    ! Begin

    if(present(slash)) then
      mySlash = slash
    else
      mySlash = '/'
    endif

    if(len(full_file_name) <= 0) then
      path = ' '
      name = ' '
      return
    endif

    mirrored_ffn = Reverse(full_file_name)
    loc = index(mirrored_ffn, mySlash)
    

    if(loc <= 0) then
      path = ' '
      name = adjustl(full_file_name)
    elseif(loc == 1) then
      path = adjustl(full_file_name)
      name = ' '
    else
      path = adjustl(Reverse(mirrored_ffn(loc:)))
      name = adjustl(Reverse(mirrored_ffn(:loc-1)))
    endif

  end subroutine split_path_name

  ! ---------------------------------------------  hdf2hdf5_fileaccess  -----

  ! This function converts hdf4 file access types to
  ! corresponding hdf5 numbers

  function hdf2hdf5_fileaccess(FileAccesshdf4) result (FileAccesshdf5)

    ! Arguments

    integer(i4), intent(IN)       :: FileAccesshdf4
    integer(i4)                   :: FileAccesshdf5
    
!    integer(i4), parameter        :: H5F_ACC_RDONLY = 0
!    integer(i4), parameter        :: H5F_ACC_RDWR   = 1
!    integer(i4), parameter        :: H5F_ACC_TRUNC  = 2

    ! begin
    select case (FileAccesshdf4)

    case(DFACC_CREATE)
      FileAccesshdf5 = HE5F_ACC_TRUNC   ! H5F_ACC_TRUNC

    case(DFACC_READ)
      FileAccesshdf5 = HE5F_ACC_RDONLY   ! H5F_ACC_RDONLY

    case default
      FileAccesshdf5 = HE5F_ACC_RDWR   ! H5F_ACC_RDWR

    end select

  end function hdf2hdf5_fileaccess

  ! ---------------------------------------------  mls_inqswath  -----

  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called

  function mls_inqswath(FileName, swathList, strBufSize, hdfVersion)

    ! Arguments

      character (len=*), intent(in) :: FILENAME
      character (len=*), intent(out) :: SWATHLIST
      integer, intent(out):: STRBUFSIZE
      integer :: mls_inqswath
    integer, optional, intent(in) :: hdfVersion

    ! Local
    integer :: myhdfVersion

    ! Executable code
    if (present(hdfVersion)) then
      myhdfVersion = hdfVersion
    else
      myhdfVersion = DEFAULT_HDFVERSION
    endif

    ! begin
    if(myhdfVersion == HDFVERSION_5) then
      mls_inqswath = he5_swinqswath(trim(FileName), swathList, strBufSize)
    elseif(myhdfVersion == HDFVERSION_4) then
      mls_inqswath = swinqswath(FileName, swathList, strBufSize)
    else                          
      mls_inqswath = NOSUCHHDFVERSION  
    endif                         

  end function mls_inqswath

  ! ---------------------------------------------  mls_sfstart  -----

  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called
  ! Right now, it works for hdf4 files in general, but only for adding
  ! metadata to hdf5 files
  
  ! Therefore, when the grand unified hdf4/hdf5 interfaces are
  ! implemented this will probably need to take an added arg:
  ! the logical addingMetadata

! function mls_sfstart(FileName, FileAccess, addingMetadata, hdfVersion)
  function mls_sfstart(FileName, FileAccess, hdfVersion)

    ! Arguments

    character (len=*), intent(in) :: FILENAME
    integer(i4), intent(IN)       :: FileAccess ! (one of the hdf4 types)
!   logical, intent(IN)           :: addingMetadata
    integer, optional, intent(in) :: hdfVersion
    integer                       :: mls_sfstart
    integer                       :: returnStatus
    integer                       :: access_prp_default
    integer                       :: myhdfVersion
    integer                       :: myAccess
    
    integer, parameter :: h5p_default_f = 0
    integer, external :: PGS_MET_SFstart
    logical, parameter :: DEBUG = .true.

    ! begin
   if ( DEBUG ) then
     call output ('Entering mls_sfstart with args ', advance='no')
     call output ('File name: ', advance='no')
     call output (trim(Filename), advance='no')
     call blanks (2)
     call output ('FileAccess: ', advance='no')
     call output (FileAccess, advance='no')
     call blanks (2)
     call output ('hdfVersion: ', advance='no')
     call output (hdfVersion, advance='yes')
   endif
   if ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
   if ( myhdfVersion == HDFVERSION_4) then
     mls_sfstart = sfstart (FileName, FileAccess)
     return
   elseif ( myhdfVersion /= HDFVERSION_5) then
     mls_sfstart = WRONGHDFVERSION
     return
   endif
   if ( PGS_MET4MLS_SF ) then
     if ( .not. HDF5_ACC_TYPES_TO_MET ) then
       myAccess = hdf2hdf5_fileaccess(FileAccess)
     elseif ( FileAccess == DFACC_RDWR ) then
       myAccess = HE5F_ACC_RDWR  ! HDF5_ACC_RDWR
     elseif ( FileAccess == DFACC_CREATE ) then
       myAccess = HE5F_ACC_TRUNC ! HDF5_ACC_CREATE
     elseif ( FileAccess == DFACC_RDONLY ) then
       myAccess = HE5F_ACC_RDONLY ! HDF5_ACC_RDONLY
     else
       myAccess = HDF5_ACC_DEFAULT
     endif
     returnStatus = PGS_MET_SFstart(trim(FileName), myAccess, mls_sfstart)
   else
     access_prp_default = h5p_default_f
     call h5fopen_f(trim(FileName), hdf2hdf5_fileaccess(FileAccess), &
      & mls_sfstart, returnStatus, access_prp_default)
   endif
     if (returnStatus /= 0 ) then
       call output ('Try again--PGS_MET_SFstart still unhappy; returns ')
       call output (returnStatus, advance='yes')
       mls_sfstart = -1
      endif
   if ( DEBUG ) then
     call output ('Returning from mls_sfstart an sdid: ', advance='no')
     call output (mls_sfstart, advance='yes')
   endif

  end function mls_sfstart

  ! ---------------------------------------------  mls_sfend  -----

  ! This function acts as a wrapper to allow hdf5 or hdf4 routines to be called
  ! Right now, it works for hdf4 files in general, but only for adding
  ! metadata to hdf5 files
  
  ! Therefore, when the grand unified hdf4/hdf5 interfaces are
  ! implemented this will probably need to take an added arg:
  ! the logical addingMetadata

  function mls_sfend(sdid, hdfVersion)
! function mls_sfend(sdid, addingMetadata, hdfVersion)

    ! Arguments

    integer, intent(IN)       :: sdid  
    integer :: mls_sfend            
!   logical, intent(IN)           :: addingMetadata
    integer, optional, intent(in) :: hdfVersion

    integer                       :: myhdfVersion
    integer, external :: PGS_MET_SFend
    logical, parameter :: DEBUG = .true.

    ! begin
   if ( DEBUG ) then
     call output ('Entering mls_sfend with args ', advance='no')
     call output ('sdid: ', advance='no')
     call output (sdid, advance='yes')
   endif
   if ( present(hdfVersion) ) then
     myhdfVersion = hdfVersion
   else
     myhdfVersion = DEFAULT_HDFVERSION
   endif
   if ( myhdfVersion == HDFVERSION_4) then
     mls_sfend = sfend (sdid)
     return
   elseif ( myhdfVersion /= HDFVERSION_5) then
     mls_sfend = WRONGHDFVERSION
     return
   endif
!    mls_sfend = h5fclose_c(sdid)
   if ( PGS_MET4MLS_SF ) then
     mls_sfend = PGS_MET_SFend(sdid)
   else
     call h5fclose_f(sdid, mls_sfend)
   endif
!    mls_sfend = 0
   if ( DEBUG ) then
     call output ('Returning from mls_sfend a status: ', advance='no')
     call output (mls_sfend, advance='yes')
   endif

  end function mls_sfend

  ! ---------------------------------------------  mls_hdf_version  -----

  ! This function returns the hdf version of the file:
  ! hdf version         returned value   integer
  !    hdf4                 hdf4           4
  !    hdf5                 hdf5           5
  !  unknown                ????      ERRORINH5FFUNCTION

  function mls_hdf_version(FileName, preferred_version, AccessType) &
   & result (hdf_version)

   ! Arguments

    character (len=*), intent(in)  :: FILENAME                                  
   ! character (len=4)             :: hdf_version                               
    integer(i4), optional, intent(in)  :: PREFERRED_VERSION                     
    integer(i4), optional, intent(in)  :: ACCESSTYPE   ! one of the hdf4 types  
    integer(i4)                        :: HDF_VERSION                           

    integer :: returnStatus                                                     
    integer :: myPreferred_Version                                              
    integer :: myAccessType                                                     
    logical :: is_hdf5                                                          

    ! begin

    if (FileName == '') then
      HDF_VERSION = MUSTSUPPLYFILENAME
      return
    endif
    
    if ( present(preferred_version) ) then
      myPreferred_Version = preferred_version
    else
      myPreferred_Version = WILDCARDHDFVERSION
    endif
    if ( present(accesstype) ) then
      myAccessType = accesstype
    else
      myAccessType = DFACC_READ
    endif

   ! If the file is being newly created, no way to find its hdf version yet
    if ( myAccessType == DFACC_CREATE ) then
      hdf_version = myPreferred_Version
      return
    endif
    
    returnStatus = 0
    is_hdf5 = (DEFAULT_HDFVERSION == HDFVERSION_5) ! was ... == 5
    call h5fis_hdf5_f(trim(FileName), is_hdf5, returnStatus)
    if ( returnStatus /= 0 ) then
!      hdf_version = '????'
      hdf_version = ERRORINH5FFUNCTION
    elseif ( is_hdf5 ) then
!      hdf_version = 'hdf5'
      hdf_version = HDFVERSION_5       ! 5
    else
!      hdf_version = 'hdf4'
      hdf_version = HDFVERSION_4       ! 4
    endif

   ! hdf_version ==  myPreferred_Version ?
   if ( myPreferred_Version /= WILDCARDHDFVERSION &
     & .and. &
     & hdf_version /= myPreferred_Version ) &
     & hdf_version = WRONGHDFVERSION

  end function mls_hdf_version

  !====================
end module MLSFiles
!====================

!
! $Log: MLSFiles.f90,v $
! Revision 1.12  2002/05/28 23:11:23  pwagner
! Changed to comply with hdf5.1.4.3/hdfeos5.1.2
!
! Revision 1.11  2002/03/14 23:31:57  pwagner
! HDFVERSION_4 and 5 now public
!
! Revision 1.10  2002/03/13 18:32:05  pwagner
! No longer dumps core after writing metadata to hdf5 files
!
! Revision 1.9  2002/02/19 23:39:29  pwagner
! Eliminated unwanted match between o3 and hno3
!
! Revision 1.8  2002/01/31 00:36:41  pwagner
! Repaired comment statements
!
! Revision 1.7  2002/01/29 23:46:30  pwagner
! Added WILDCARDHDFVERSION as public param
!
! Revision 1.6  2002/01/29 00:48:43  pwagner
! Now should handle both hdfVersions; not tested yet
!
! Revision 1.5  2002/01/26 00:14:47  pwagner
! Accepts hdfVersion optional arg; restored hdf5 module use
!
! Revision 1.4  2002/01/23 22:41:21  pwagner
! Handles optional hdfVersion parameter
!
! Revision 1.3  2002/01/23 00:54:10  pwagner
! Added mls_hdf_version function
!
! Revision 1.2  2002/01/18 23:55:49  pwagner
! Various strategems to try writing metadata; all fail
!
! Revision 1.1  2002/01/18 00:51:22  pwagner
! First commit
!
@


1.12
log
@Changed to comply with hdf5.1.4.3/hdfeos5.1.2
@
text
@d17 1
d39 1
a39 1
  public :: GetPCFromRef, mls_io_gen_openF, &
d45 3
a47 1
    "$Id: MLSFiles.f90,v 1.11 2002/03/14 23:31:57 pwagner Exp $"
d54 1
d299 15
d1165 3
@


1.11
log
@HDFVERSION_4 and 5 now public
@
text
@d13 2
a14 1
    & he5_gdopen, he5_gdclose
d44 1
a44 1
    "$Id: MLSFiles.f90,v 1.10 2002/03/13 18:32:05 pwagner Exp $"
d116 1
a116 1
  integer, parameter :: HDF5_ACC_DEFAULT = HDF5_ACC_RDWR
d884 1
a884 1
      FileAccesshdf5 = H5F_ACC_TRUNC
d887 1
a887 1
      FileAccesshdf5 = H5F_ACC_RDONLY
d890 1
a890 1
      FileAccesshdf5 = H5F_ACC_RDWR
d988 1
a988 1
       myAccess = HDF5_ACC_RDWR
d990 1
a990 1
       myAccess = HDF5_ACC_CREATE
d992 1
a992 1
       myAccess = HDF5_ACC_RDONLY
d1146 3
@


1.10
log
@No longer dumps core after writing metadata to hdf5 files
@
text
@d43 1
a43 1
    "$Id: MLSFiles.f90,v 1.9 2002/02/19 23:39:29 pwagner Exp $"
d62 3
a64 3
   integer, parameter :: HDFVERSION_4 = 4
   integer, parameter :: HDFVERSION_5 = 5
   integer, parameter :: DEFAULT_HDFVERSION = HDFVERSION_5
d1145 3
@


1.9
log
@Eliminated unwanted match between o3 and hno3
@
text
@d7 2
a8 1
  use Hdf, only: DFACC_CREATE, DFACC_READ, sfstart, sfend
d15 1
a15 1
  use MLSCommon, only: i4, NameLen, BareFNLen
d18 3
a20 1
  use SDPToolkit, only: Pgs_pc_getReference, PGS_S_SUCCESS, &
d43 1
a43 1
    "$Id: MLSFiles.f90,v 1.8 2002/01/31 00:36:41 pwagner Exp $"
d99 17
d933 6
d940 1
d945 3
a947 2
      character (len=*), intent(in) :: FILENAME
    integer(i4), intent(IN)       :: FileAccess
a950 1
    integer                       :: nameLength
d953 1
d957 1
d960 11
d979 3
a982 1
!    mls_sfstart = PGS_MET_SFstart(FileName, hdf2hdf5_fileaccess(FileAccess))
d984 12
a995 2
     returnStatus = PGS_MET_SFstart(trim(FileName), &
      & hdf2hdf5_fileaccess(FileAccess), mls_sfstart)
a1000 5
!     nameLength = LEN(FileName)
!     returnStatus = h5fopen_c(FileName, nameLength, &
!      & hdf2hdf5_fileaccess(FileAccess), access_prp_default, &
!      & mls_sfstart)
!     mls_sfstart he5_swopen(trim(
d1006 4
d1016 6
d1024 1
d1030 1
d1035 1
d1038 5
d1051 3
d1062 4
d1075 1
a1075 1
  !  unknown                ????      NOSUCHHDFVERSION
d1080 1
a1080 1
    ! Arguments
d1082 10
a1091 10
      character (len=*), intent(in)  :: FILENAME
   !   character (len=4)             :: hdf_version
      integer(i4), optional, intent(in)  :: PREFERRED_VERSION
      integer(i4), optional, intent(in)  :: ACCESSTYPE
      integer(i4)                        :: HDF_VERSION

      integer :: returnStatus
      integer :: myPreferred_Version
      integer :: myAccessType
      logical :: is_hdf5
d1118 1
a1118 1
    is_hdf5 = (DEFAULT_HDFVERSION == 5)
d1125 1
a1125 1
      hdf_version = 5
d1128 1
a1128 1
      hdf_version = 4
d1145 3
@


1.8
log
@Repaired comment statements
@
text
@d14 2
a15 2
  use MLSCommon, only: i4
  use MLSStrings, only: Capitalize, LowerCase, Reverse
d40 1
a40 1
    "$Id: MLSFiles.f90,v 1.7 2002/01/29 23:46:30 pwagner Exp $"
d75 1
d135 1
a135 1
    integer(i4)                              :: thePC
d140 1
a140 1
    character (LEN=*),  optional, intent(IN)       :: path
d144 5
a148 1

d151 2
a152 1
    integer                       ::     version, returnStatus
a191 2
    ErrType = NAMENOTFOUND

d196 9
d225 1
a225 6

        if ( index(NameOnly, trim(MatchName)) /= 0 )then
          ErrType = 0
          exit
        endif

d229 12
d242 19
d271 1
d1073 3
@


1.7
log
@Added WILDCARDHDFVERSION as public param
@
text
@d40 1
a40 1
    "$Id: MLSFiles.f90,v 1.6 2002/01/29 00:48:43 pwagner Exp $"
d642 1
a642 1
  ! or else a Fortran OPEN statement
d651 1
a651 1
  ! If must be given a FileHandle as an arg
d653 1
d1033 3
@


1.6
log
@Now should handle both hdfVersions; not tested yet
@
text
@d40 1
a40 1
    "$Id: MLSFiles.f90,v 1.5 2002/01/26 00:14:47 pwagner Exp $"
d59 3
a61 1
   integer, parameter :: DEFAULT_HDFVERSION = 5
d66 1
a66 1
  integer, parameter, public :: WILDCARDHDFVERSION=9
d424 1
a424 1
      elseif(myhdfVersion == 5) then
d427 1
a427 1
      elseif(myhdfVersion == 4) then
d456 1
a456 1
      elseif(myhdfVersion == 5) then
d459 1
a459 1
      elseif(myhdfVersion == 4) then
d702 1
a702 1
      if(myhdfVersion == 5) then
d704 1
a704 1
      elseif(myhdfVersion == 4) then
d711 1
a711 1
      if(myhdfVersion == 5) then
d713 1
a713 1
      elseif(myhdfVersion == 4) then
d859 1
a859 1
    if(myhdfVersion == 5) then
d861 1
a861 1
    elseif(myhdfVersion == 4) then
d895 1
a895 1
   if ( myhdfVersion == 4) then
d942 1
a942 1
   if ( myhdfVersion == 4) then
d1032 3
@


1.5
log
@Accepts hdfVersion optional arg; restored hdf5 module use
@
text
@d10 3
a12 2
  use HDFEOS, only: gdclose, gdopen, swclose, swopen
  use HDFEOS5, only: he5_swclose, he5_swopen, he5_swinqswath
d17 1
a17 1
  use SDPToolkit, only: Pgs_pc_getReference, PGS_S_SUCCESS, Pgs_smf_getMsg, &
a30 1
  public
d32 5
a36 1
  private :: ID
d40 1
a40 1
    "$Id: MLSFiles.f90,v 1.4 2002/01/23 22:41:21 pwagner Exp $"
d60 5
d70 3
a72 2
  integer, parameter :: NAMENOTFOUND=-1
  integer, parameter :: INVALIDPCRANGE=NAMENOTFOUND-1
a74 5
  integer, parameter :: UNKNOWNFILEACCESSTYPE=-999
  integer, parameter :: UNKNOWNTOOLBOXMODE=UNKNOWNFILEACCESSTYPE+1
  integer, parameter :: NOFREEUNITS=UNKNOWNTOOLBOXMODE+1
  integer, parameter :: MUSTSUPPLYFILENAMEORPC=NOFREEUNITS+1
  integer, parameter :: NOPCIFNOTOOLKIT=MUSTSUPPLYFILENAMEORPC+1
d76 14
d284 2
a285 1
    ! Local variables
d373 7
d403 4
d419 4
a422 1
      if(returnStatus == 0) then
d425 2
a426 18
        if(theFileHandle <= 0) then
          ErrType = min(theFileHandle, -1)
        else
          ErrType = 0
        endif
        if ( debug ) then
            call output('Args and results from he5_swopen', &
            & advance='yes')
            call output('File Name: ', advance='no')
            call blanks(2)
            call output(trim(myName), advance='yes')
            call output('File Access: ', advance='no')
            call blanks(2)
            call output(hdf2hdf5_fileaccess(FileAccessType), advance='yes')
            call output('theFileHandle: ', advance='no')
            call blanks(2)
            call output(theFileHandle, advance='yes')
        endif
d428 2
a429 1
        ErrType = returnStatus
d431 18
d451 7
a457 1
      if(returnStatus == 0) then
a458 10

!  (((((((( When we convert gridded data types to hdf5 ))))))
!        theFileHandle = he5_gdopen(trim(myName), &
!          & hdf2hdf5_fileaccess(FileAccessType))

        if(theFileHandle <= 0) then
          ErrType = min(theFileHandle, -1)
        else
          ErrType = 0
        endif
d460 2
a461 1
        ErrType = returnStatus
d463 5
d651 2
a652 1
  function mls_io_gen_closeF(toolbox_mode, theFileHandle, hdfVersion) &
d659 1
d662 3
a664 1
    ! Local variables
d669 2
d680 14
d700 7
a706 1
      ErrType = he5_swclose(theFileHandle)
d709 7
a715 1
      ErrType = gdclose(theFileHandle)
d846 10
d857 7
a863 1
    mls_inqswath = he5_swinqswath(trim(FileName), swathList, strBufSize)
d956 5
a960 5
  ! This function returns a character string depending on hdf version:
  ! hdf version         returned value
  !    hdf4                 hdf4
  !    hdf5                 hdf5
  !  unknown                ????
d962 2
a963 1
  function mls_hdf_version(FileName)  result (hdf_version)
d967 5
a971 2
      character (len=*), intent(in) :: FILENAME
      character (len=4)             :: hdf_version
d974 2
d977 1
d979 23
a1003 4
!    if ( PGS_MET4MLS_SF ) then
!      hdf_version = '????'
!      return
!    endif
d1006 2
a1007 1
      hdf_version = '????'
d1009 2
a1010 1
      hdf_version = 'hdf5'
d1012 2
a1013 1
      hdf_version = 'hdf4'
d1016 5
d1030 3
@


1.4
log
@Handles optional hdfVersion parameter
@
text
@d7 2
a8 2
  use Hdf, only: DFACC_CREATE, DFACC_READ
!  use Hdf5, only: h5fopen_f, h5fclose_f, h5fis_hdf5_f
d36 1
a36 1
    "$Id: MLSFiles.f90,v 1.3 2002/01/23 00:54:10 pwagner Exp $"
d53 4
d795 1
d801 9
d816 2
a817 2
!     call h5fopen_f(trim(FileName), hdf2hdf5_fileaccess(FileAccess), &
!      & mls_sfstart, returnStatus, access_prp_default)
d844 1
d848 9
d861 1
a861 1
!     call h5fclose_f(sdid, mls_sfend)
d885 7
a891 5
    if ( PGS_MET4MLS_SF ) then
      hdf_version = '????'
      return
    endif
!    call h5fis_hdf5_f(trim(FileName), is_hdf5, returnStatus)
d909 3
@


1.3
log
@Added mls_hdf_version function
@
text
@d36 1
a36 1
    "$Id: MLSFiles.f90,v 1.2 2002/01/18 23:55:49 pwagner Exp $"
a46 1
! mls_inqswath       A wrapper for doing swingswath for versions 4 and 5
d241 2
a242 1
    & FileName, PCBottom, PCTop, versionNum, unknown, thePC, debugOption) &
d259 2
d608 1
a608 1
  function mls_io_gen_closeF(toolbox_mode, theFileHandle) &
d616 1
d761 1
a761 1
  function mls_inqswath(FileName, swathList, strBufSize)
d769 1
d780 1
a780 1
  function mls_sfstart(FileName, FileAccess)
d786 1
d822 1
a822 1
  function mls_sfend(sdid)
d828 1
d883 3
@


1.2
log
@Various strategems to try writing metadata; all fail
@
text
@d8 2
a9 1
!  use Hdf5, only: h5fopen_f, h5fclose_f
d36 1
a36 1
    "$Id: MLSFiles.f90,v 1.1 2002/01/18 00:51:22 pwagner Exp $"
d43 2
a57 1

a61 1

d68 4
a73 1

d734 3
a736 3
    integer(i4), parameter        :: H5F_ACC_RDONLY = 0
    integer(i4), parameter        :: H5F_ACC_RDRW   = 1
    integer(i4), parameter        :: H5F_ACC_TRUNC  = 2
d748 1
a748 1
      FileAccesshdf5 = H5F_ACC_RDRW
d792 1
d795 5
d828 5
a832 1
    mls_sfend = PGS_MET_SFend(sdid)
d837 34
d877 3
@


1.1
log
@First commit
@
text
@d8 1
d35 1
a35 1
    "$Id: MLSFiles.f90,v 2.23 2002/01/11 00:44:37 pwagner Exp $"
d44 3
d48 2
d67 2
a68 1
  ! Now we have the legal unit numbers that files may be assigned
d764 1
a764 1
    mls_inqswath = he5_swinqswath(FileName, swathList, strBufSize)
d780 2
d783 1
d788 7
a794 2
     returnStatus = PGS_MET_SFstart(FileName, hdf2hdf5_fileaccess(FileAccess), &
      & mls_sfstart)
d817 1
d819 1
d829 3
@

