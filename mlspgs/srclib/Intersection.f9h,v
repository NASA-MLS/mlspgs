head	1.4;
access;
symbols
	v5-02-NRT-19:1.4
	v6-00:1.4
	v5-02-NRT-18:1.4
	v5-02:1.4
	v5-01-NRT-17:1.4
	v5-01-NRT-16:1.4
	v5-01-NRT-15:1.4
	v5-01-NRT-14:1.4
	neuralnetworks-1-0:1.4.0.8
	cfm-single-freq-0-1:1.4.0.6
	v5-01:1.4
	v5-00:1.4
	v4-23-TA133:1.4.0.4
	mus-emls-1-70:1.4.0.2
	rel-1-0-englocks-work:1.3.0.2
	VUMLS1-00:1.3
	VPL1-00:1.2
	V4-22-NRT-08:1.2
	VAM1-00:1.2
	V4-21:1.2.0.2
	V4-13:1.2
	V4-12:1.2
	V4-11:1.2
	V4-10:1.2
	V3-43:1.1
	M4-00:1.2
	V3-41:1.1
	V3-40-PlusGM57:1.1.0.2
	V3-33:1.1
	V3-31:1.1
	V3-30-NRT-05:1.1
	cfm-01-00:1.1
	V3-30:1.1
	V3-20:1.1
	V3-10:1.1;
locks; strict;
comment	@# @;


1.4
date	2018.04.18.22.36.06;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2017.03.10.00.41.56;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2012.12.04.17.23.45;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.24.19.24.16;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Return zero-size instead of unallocated array for zero-size set
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id: Intersection.f9h,v 1.3 2017/03/10 00:41:56 vsnyder Exp $

  ! ---------------------------------------------  Intersection  -----
  ! This family of routines finds the intersection between
  ! two sets represented by arrays

  ! function IntersectionCharacter ( A, B, options ) result ( C )
    ! method:
    ! Go though a, checking for each element whether a match is found in (b)
    ! If  so found, add the element
    ! options, if present, can modify this behavior: 
    !   char    effect
    !  ------   ------
    !    r      The set of elements in a or b but not in both
    !            which is Union(A, B) - Intersection(A, B)
    !    c      The set of elements in a but not in b
    !            which is A - B, or as our notation has it, RC ( B, A )
    ! The 'c' option exists only to allow the family of functions
    ! to be reused internally for finding the relative complement of two sets
  
    ! use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Error

    ! character(len=*), dimension(:), intent(in) :: A(:), B(:)
    ! character(len=len(a)), dimension(:), pointer :: C(:) ! Intent(out) -- nullified and then allocated here
    ! character(len=*), optional, intent(in) :: options
    ! Local variables
    ! integer :: i, j, size_c, status
    ! character(len=len(a)), dimension(size(a)+size(b)) :: TC
    ! logical :: myComplement
    ! logical :: myReverse
    ! logical :: stdIntersection
    
    ! Executable
    myComplement = .false.
    myReverse = .false.
    if ( present(options) ) myComplement = index( options, 'c' ) > 0
    if ( present(options) ) myReverse = index( options, 'r' ) > 0
    stdIntersection = .not. (myComplement .or. myReverse )
    size_c = 0
    do i=1, size(a)
      ! Don't redo a repeated element
      if ( i > 1 ) then
        j = findFirst( a(:i-1), a(i) )
        if ( j > 0 ) cycle
      endif
      j = findFirst( b, a(i) )
      if ( (stdIntersection .and. j > 0) .or. &
        & (.not. stdIntersection .and. j < 1) ) then
        size_c = size_c + 1
        TC(size_c) = a(i)
      endif
    enddo
    ! Now switch to looping over B
    if ( myReverse ) then
      do i=1, size(b)
        ! Don't redo a repeated element
        if ( i > 1 ) then
          j = findFirst( b(:i-1), b(i) )
          if ( j > 0 ) cycle
        endif
        j = findFirst( a, b(i) )
        if ( j < 1 ) then
          size_c = size_c + 1
          TC(size_c) = b(i)
        endif
      enddo
    endif
    c = tc(:size_c)
!  end function IntersectionCharacter
! $Log: Intersection.f9h,v $
! Revision 1.3  2017/03/10 00:41:56  vsnyder
! Make result of Intersection allocatable
!
! Revision 1.2  2012/12/04 17:23:45  pwagner
! Consistent with new api
!
! Revision 1.1  2008/11/24 19:24:16  pwagner
! First commit
!
@


1.3
log
@Make result of Intersection allocatable
@
text
@d12 1
a12 1
! $Id: Intersection.f9h,v 1.2 2012/12/04 17:23:45 pwagner Exp $
a78 6
    ! print *, 'size(c): ', size_c    
    ! print *, 'tc: ', tc(1:size_c)
    if ( size_c < 1 ) return
    allocate ( c(size_c), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      MLSMSG_Allocate // 'C in IntersectionGeneric' )
d82 3
@


1.2
log
@Consistent with new api
@
text
@d12 1
a12 1
! $Id: Intersection.f9h,v 1.1 2008/11/24 19:24:16 pwagner Exp $
a80 1
    nullify(c)
d88 3
@


1.1
log
@First commit
@
text
@d12 1
a12 1
! $Id: Intersection.f9h,v 1.1 2007/02/26 23:52:37 pwagner Exp $
d18 1
a18 1
  ! function IntersectionCharacter ( A, B, reverse ) result ( C )
d22 10
d36 1
a36 1
    ! logical, optional, intent(in) :: reverse
d40 1
d42 1
d45 1
d47 3
a49 1
    if ( present(reverse) ) myReverse = reverse
d58 2
a59 2
      if ( (.not. myReverse .and. j > 0) .or. &
        & (myReverse .and. j < 1) ) then
d64 15
d89 3
@

