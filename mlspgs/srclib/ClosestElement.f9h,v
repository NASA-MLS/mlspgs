head	1.4;
access;
symbols
	v5-02-NRT-19:1.4
	v6-00:1.4
	v5-02-NRT-18:1.4
	v5-02:1.4
	v5-01-NRT-17:1.4
	v5-01-NRT-16:1.4
	v5-01-NRT-15:1.4
	v5-01-NRT-14:1.4
	neuralnetworks-1-0:1.4.0.14
	cfm-single-freq-0-1:1.4.0.12
	v5-01:1.4
	v5-00:1.4
	v4-23-TA133:1.4.0.10
	mus-emls-1-70:1.4.0.8
	rel-1-0-englocks-work:1.4.0.6
	VUMLS1-00:1.4
	VPL1-00:1.4
	V4-22-NRT-08:1.4
	VAM1-00:1.4
	V4-21:1.4.0.4
	V4-13:1.4
	V4-12:1.4
	V4-11:1.4
	V4-10:1.4
	V3-43:1.4
	M4-00:1.4
	V3-41:1.4
	V3-40-PlusGM57:1.4.0.2
	V2-24-NRT-04:1.3
	V3-33:1.4
	V2-24:1.3
	V3-31:1.4
	V3-30-NRT-05:1.4
	cfm-01-00:1.4
	V3-30:1.4
	V3-20:1.4
	V3-10:1.4
	V2-23-NRT-02:1.3
	V2-23:1.3
	V2-22-NRT-01:1.3
	V2-22:1.3
	V2-21:1.1
	V2-20:1.1
	V2-11:1.1
	V2-10:1.1
	V2-00:1.1;
locks; strict;
comment	@# @;


1.4
date	2008.09.16.18.16.26;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.07.23.56.43;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.02.18.20.17;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.05.00.54.49;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Had wrongly presumed presorted meant uniformly spaced
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id: ClosestElement.f9h,v 1.3 2007/08/07 23:56:43 pwagner Exp $
!  subroutine ClosestElement_r* ( test, array, indices, options )

  ! local variables
  real(rk) :: diff, dx
  integer :: i
  integer :: ibegin
  integer :: ibest
  integer :: idn, iup
  character(len=8) :: myOptions
  integer :: N
  ! Executable code
  myOptions = ' '
  if ( present(options) ) myOptions = options
  N = size(array)
  indices(1) = N

  ! A quicker calculation is possible if a presorted array
  if ( index(myOptions, 'p') > 0 ) then
    if ( N < 2 ) return
    dx = ( array(N) - array(1) ) / ( N - 1 )
    if ( dx == 0._rk ) return
    ibest = FindFirst( test == array )
    iup = FindFirst( array > test )
    idn = FindLast( array < test )
    if ( idn < 1 ) idn = 1
    if ( iup < 1 ) iup = N
    if ( ibest > 0 ) then
      ! This is the one we want, no question
    elseif ( index(myOptions, 'l') > 0 ) then
      ! always choose the lower, which is i (due to truncation)
      ibest = idn
    elseif ( index(myOptions, 'u') > 0 ) then
      ! always choose the upper, which is i
      ibest = iup
    elseif ( iup <= idn ) then
      ! it does not matter
      ibest = iup
    else
      ! always choose the closer
      ibest = iup
      diff = abs( test - array(idn) )
      if ( abs( array(ibest) - test ) > diff ) ibest = idn
    endif
    indices(1) = ibest
    return
  endif
  ! Do we really need messing around with whether we have fillvalues?
  ibest = FindFirst( .not. IsFillValue(array) )
  ! call outputNamedValue( '1st non-fill index', ibest )
  if ( ibest < 1 .or. ibest > N-1 ) then
    indices(1) = ibest
    return
  endif
  if ( test < minval(array) ) then
    indices = minloc(array)
    return
  elseif ( test > maxval(array) ) then
    indices = maxloc(array)
    return
  endif
  diff = abs ( test - array(ibest) )
  ! call outputNamedValue( '1st diff', diff )
  ! call outputNamedValue( 'N', N )
  ! call outputNamedValue( 'test', test )
  ibegin = ibest + 1
  do i = ibegin, N
    ! call outputNamedValue( 'abs(test-array(i))', abs( test - array(i) ) )
    ! Don't select elements that are
    ! (1) Fill values
    ! (2) greater than the test if we're told to pick only lower 'l'
    ! (3) less than the test if we're told to pick only upper 'u'
    if ( IsFillValue(array(i)) ) then
      cycle
    elseif ( index(myOptions, 'l') > 0 .and. test < array(i) ) then
      cycle
    elseif ( index(myOptions, 'u') > 0 .and. test > array(i) ) then
      cycle
    elseif ( abs( test - array(i) ) < diff ) then
      ibest = i
      diff = abs( test - array(i) )
    endif
  enddo
  indices(1) = ibest

!  end subroutine ClosestElement_r*

! $Log: ClosestElement.f9h,v $
! Revision 1.3  2007/08/07 23:56:43  pwagner
! Exploit quicker operation with pre-sorted array
!
! Revision 1.2  2007/03/02 18:20:17  pwagner
! Add options to require closest but lower (upper)
!
! Revision 1.1  2006/01/05 00:54:49  pwagner
! First commit
!
@


1.3
log
@Exploit quicker operation with pre-sorted array
@
text
@d12 1
a12 1
! $Id: ClosestElement.f9h,v 1.2 2007/03/02 18:20:17 pwagner Exp $
d20 1
d34 8
a41 4
    i = ( test - array(1) ) / dx
    i = min(i, N)
    i = max(i, 1)
    if ( index(myOptions, 'l') > 0 ) then
d43 1
a43 1
      ibest = i
d46 4
a49 1
      ibest = i + 1
d51 4
a54 3
      ibest = min( i + 1, N )
      diff = abs( test - array(i) )
      if ( abs( array(ibest) - test ) > diff ) ibest = i
d100 3
@


1.2
log
@Add options to require closest but lower (upper)
@
text
@d12 1
a12 1
! $Id: ClosestElement.f9h,v 1.1 2006/01/05 00:54:49 pwagner Exp $
d16 1
a16 1
  real(rk) :: diff
d21 25
a45 8
    ! Executable code
    myOptions = ' '
    if ( present(options) ) myOptions = options
    ! Do we really need messing around with whether we have fillvalues?
    ibest = FindFirst( .not. IsFillValue(array) )
    if ( ibest < 1 .or. ibest > size(array)-1 ) then
      indices(1) = ibest
      return
d47 37
a83 6
    if ( test < minval(array) ) then
      indices = minloc(array)
      return
    elseif ( test > maxval(array) ) then
      indices = maxloc(array)
      return
d85 2
a86 19
    diff = abs ( test - array(ibest) )
    ibegin = ibest + 1
    do i = ibegin, size(array)
      ! Don't select elements that are
      ! (1) Fill values
      ! (2) greater than the test if we're told to pick only lower 'l'
      ! (3) less than the test if we're told to pick only upper 'u'
      if ( IsFillValue(array(i)) ) then
        cycle
      elseif ( index(myOptions, 'l') > 0 .and. test < array(i) ) then
        cycle
      elseif ( index(myOptions, 'u') > 0 .and. test > array(i) ) then
        cycle
      elseif ( abs( test - array(i) ) < diff ) then
        ibest = i
        diff = abs( test - array(i) )
      endif
    enddo
    indices(1) = ibest
d91 3
@


1.1
log
@First commit
@
text
@d12 2
a13 2
! $Id: ClosestElement.f9h,v 1.4 2005/08/03 17:53:54 vsnyder Exp $
!  subroutine ClosestElement_r* ( test, array, indices )
d20 1
d22 2
d30 7
d40 4
d46 4
d60 3
@

