head	1.8;
access;
symbols
	v5-02-NRT-19:1.8
	v6-00:1.8
	v5-02-NRT-18:1.8
	v5-02:1.8
	v5-01-NRT-17:1.8
	v5-01-NRT-16:1.8
	v5-01-NRT-15:1.8
	v5-01-NRT-14:1.8
	neuralnetworks-1-0:1.8.0.10
	cfm-single-freq-0-1:1.8.0.8
	v5-01:1.8
	v5-00:1.8
	v4-23-TA133:1.8.0.6
	mus-emls-1-70:1.8.0.4
	rel-1-0-englocks-work:1.8.0.2
	VUMLS1-00:1.8
	VPL1-00:1.8
	V4-22-NRT-08:1.8
	VAM1-00:1.8
	V4-21:1.7.0.4
	V4-13:1.7
	V4-12:1.7
	V4-11:1.7
	V4-10:1.7
	V3-43:1.7
	M4-00:1.7
	V3-41:1.7
	V3-40-PlusGM57:1.7.0.2
	V2-24-NRT-04:1.7
	V3-33:1.7
	V2-24:1.7
	V3-31:1.7
	V3-30-NRT-05:1.7
	cfm-01-00:1.7
	V3-30:1.7
	V3-20:1.7
	V3-10:1.7
	V2-23-NRT-02:1.7
	V2-23:1.7
	V2-22-NRT-01:1.7
	V2-22:1.7
	V2-21:1.7
	V2-20:1.7
	V2-11:1.7
	V2-10:1.7
	V2-00:1.7
	V1-51:1.5
	V1-50:1.5
	V1-45:1.5
	V1-44:1.5
	V1-43:1.5
	V1-42:1.5
	V1-41:1.5
	V1-32:1.5
	V1-40:1.5
	V1-31:1.5
	V1-30:1.5
	V1-13:1.5
	V1-12:1.5
	V1-11:1.5
	V1-10:1.5
	newfwm-feb03:1.5.0.2;
locks; strict;
comment	@# @;


1.8
date	2015.04.11.01.28.50;	author vsnyder;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.03.16.34.20;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.22.20.03.55;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.23.03.12.53;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.23.02.32.09;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.22.23.59.10;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.04.00.46.12;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.13.18.01.33;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Handle 'Second' argument
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id: InterpolateArray.f9h,v 1.7 2005/08/03 16:34:20 pwagner Exp $

!  subroutine InterpolateArray_r* ( oldX, oldY, newX, newY, method, extrapolate, &
!    & badValue, missingRegions, dyByDx, dNewByDOld, skipNewY, IntYdX )

    character :: ExtrapolateMethod
    integer :: D, I, Ind, NoNew, NoOld
    real(rk), pointer :: My_dyByDx(:), My_IntYdX(:)
    target :: dyByDx, IntYdX

    noNew = size(newX,1)
    noOld = size(oldX,1)
    d = 1
    if ( present(second) ) d = merge(2,1,second)

    ! Special case where only one input point
    if ( noOld == 1 ) then
      extrapolateMethod="A"
      if ( present(extrapolate)) extrapolateMethod=Capitalize(extrapolate(1:1))

      if ( d == 1 ) then
        ! If extrapolating allowed or clamped, out values same as in
        if ( extrapolateMethod=="A" .or. extrapolateMethod=="C" ) then
          do ind = 1, noNew
            newY(ind,:) = oldY(1,:)
          end do
          ! Note these next two aren't totally graceful with respect to 
          ! the missingRegions flag.
          if ( present(dyByDx) ) dyByDx = 0.0_rk
        else
          ! Else extrapolation forbidden
          do ind = 1, noNew
            if ( newX(ind) == oldX(1) ) then
              newY(ind,:) = oldY(1,:)
              if ( present(dyByDx) ) dyByDx = 0.0_rk
            else
              newY(ind,:) = badValue
              if ( present(dyByDx) ) dyByDx = badValue
            end if
          end do
        end if
      else
        ! If extrapolating allowed or clamped, out values same as in
        if ( extrapolateMethod=="A" .or. extrapolateMethod=="C" ) then
          do ind = 1, noNew
            newY(:,ind) = oldY(:,1)
          end do
          ! Note these next two aren't totally graceful with respect to 
          ! the missingRegions flag.
          if ( present(dyByDx) ) dyByDx = 0.0_rk
        else
          ! Else extrapolation forbidden
          do ind = 1, noNew
            if ( newX(ind) == oldX(1) ) then
              newY(:,ind) = oldY(:,1)
              if ( present(dyByDx) ) dyByDx = 0.0_rk
            else
              newY(:,ind) = badValue
              if ( present(dyByDx) ) dyByDx = badValue
            end if
          end do
        end if
      end if
      return
    end if

    ! Calculate the coefficients
    call interpolateArraySetup ( oldX, newX, method, coeffs, extrapolate, &
      size(oldY,3-d), present(dyByDx), dNewByDOld, present(intYdX) )

    ! Do the interpolation
    if ( d == 1 ) then
      call interpolateValues ( coeffs, oldX, oldY, newX, newY, &
        & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, intYdX )
    else
      nullify ( my_dyByDx, my_intYdX )
      do i = 1, size(newY,1)
        if ( present(dyByDx) ) my_dyByDx => dyByDx(i,:)
        if ( present(intYdX) ) my_intYdX => intYdX(i,:)
        call interpolateValues ( coeffs, oldX, oldY(i,:), newX, newY(i,:), &
          & method, extrapolate, badValue, missingRegions, my_dyByDx, &
          & skipNewY, my_intYdX )
      end do
    end if

    ! Dispose of the coefficients
    call interpolateArrayTeardown ( coeffs )

! end subroutine InterpolateArray_r*

! $Log: InterpolateArray.f9h,v $
! Revision 1.7  2005/08/03 16:34:20  pwagner
! InterpolateArray optionally finds antiderivatives
!
! Revision 1.6  2005/06/22 20:03:55  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.5  2002/11/23 03:12:53  vsnyder
! Can't use setup with noOld == 1
!
! Revision 1.4  2002/11/23 02:32:09  vsnyder
! Modifications to accomodate InterpolateScalarUsingSetup
!
! Revision 1.3  2002/11/22 23:59:10  vsnyder
! Separate setup and teardown from interpolation
!
! Revision 1.2  2002/10/04 00:46:12  vsnyder
! Move declarations of local variables here
!
! Revision 1.1  2002/09/13 18:01:33  pwagner
! First commit
!
@


1.7
log
@InterpolateArray optionally finds antiderivatives
@
text
@d12 1
a12 1
! $Id: InterpolateArray.f9h,v 1.6 2005/06/22 20:03:55 pwagner Exp $
d18 3
a20 1
    integer :: Ind, NoNew, NoOld
d24 2
d32 21
a52 8
      ! If extrapolating allowed or clamped, out values same as in
      if ( extrapolateMethod=="A" .or. extrapolateMethod=="C" ) then
        do ind = 1, noNew
          newY(ind,:) = oldY(1,:)
        end do
        ! Note these next two aren't totally gracefull with respect to 
        ! the missingRegions flag.
        if ( present(dyByDx) ) dyByDx = 0.0_rk
d54 20
a73 10
        ! Else extrapolation forbidden
        do ind = 1, noNew
          if ( newX(ind) == oldX(1) ) then
            newY(ind,:) = oldY(1,:)
            if ( present(dyByDx) ) dyByDx = 0.0_rk
          else
            newY(ind,:) = badValue
            if ( present(dyByDx) ) dyByDx = badValue
          end if
        end do
d80 1
a80 1
      size(oldY,2), present(dyByDx), dNewByDOld, present(intYdX) )
d83 13
a95 2
    call interpolateValues ( coeffs, oldX, oldY, newX, newY, &
      & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, intYdX )
d103 3
@


1.6
log
@Reworded Copyright statement, moved rcs id
@
text
@d12 1
a12 1
! $Id: InterpolateArray.f9h,v 1.5 2002/11/23 03:12:53 vsnyder Exp $
d15 1
a15 1
!    & badValue, missingRegions, dyByDx, dNewByDOld )
d53 1
a53 1
      size(oldY,2), present(dyByDx), dNewByDOld )
d57 1
a57 1
      & method, extrapolate, badValue, missingRegions, dyByDx )
d65 3
@


1.5
log
@Can't use setup with noOld == 1
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d12 1
a12 1
! $Id: InterpolateArray.f9h,v 1.4 2002/11/23 02:32:09 vsnyder Exp $
d65 3
@


1.4
log
@Modifications to accomodate InterpolateScalarUsingSetup
@
text
@d4 1
a4 1
! $Id: InterpolateArray.f9h,v 1.3 2002/11/22 23:59:10 vsnyder Exp $
d9 34
d57 3
@


1.3
log
@Separate setup and teardown from interpolation
@
text
@d4 1
a4 1
! $Id: InterpolateArray.f9h,v 1.2 2002/10/04 00:46:12 vsnyder Exp $
d11 1
a11 1
      size(oldY,2), dyByDx, dNewByDOld )
d23 3
@


1.2
log
@Move declarations of local variables here
@
text
@d4 1
a4 1
! $Id: $
a7 30
    ! Local variables
    real(rk), dimension(:),   pointer :: A
    real(rk), dimension(:,:), pointer :: AA
    real(rk), dimension(:),   pointer :: B
    real(rk), dimension(:,:), pointer :: BB
    real(rk), dimension(:),   pointer :: C
    real(rk), dimension(:,:), pointer :: CC
    real(rk), dimension(:),   pointer :: D ! Coefficients
    real(rk), dimension(:,:), pointer :: DD ! Spread coefs.
    real(rk), dimension(:),   pointer :: gap
    real(rk), dimension(:),   pointer :: gap2
    integer, dimension(:),    pointer :: lowerInds
    real(rk), dimension(:),   pointer :: maskVector
    real(rk), dimension(:,:), pointer :: oldSecond
    real(rk), dimension(:,:), pointer :: oldSecondLower
    real(rk), dimension(:,:), pointer :: oldSecondUpper
    real(rk), dimension(:,:), pointer :: oldYlower
    real(rk), dimension(:,:), pointer :: oldYupper
    real(rk), dimension(:),   pointer :: p ! For 2nd der. guess
    real(rk), dimension(:,:), pointer :: spreadGap
    real(rk), dimension(:,:), pointer :: temp ! For 2nd der. guess
    real(rm), dimension(:,:), pointer :: tempDNewByDOld ! Dense version.
    integer, dimension(:),    pointer :: upperInds
    real(rk) :: sig       ! For second derivative guesser
    real(rk) :: dyByDxFill              ! Fill value for dyByDx
    integer :: noOld, noNew, width ! Dimensions
    logical :: spline              ! Flag
    logical :: useMissingRegions   ! Copy of missing regions
    integer :: ind, newInd         ! Loop counters
    logical :: computeDNewByDOld   ! Set if dNewByDOld is present
d9 7
a15 2
    character :: extrapolateMethod ! Tidy copy of extrapolate parameter
    integer, parameter:: rA=kind(A)
d17 2
a18 251
    ! Executable code

    nullify ( a, aa, b, bb, c, cc, d, dd, gap, gap2, lowerInds, maskVector, &
      &       oldSecond, oldSecondLower, oldSecondUpper, oldYlower, oldYupper, p, &
      &       spreadGap, temp, tempDNewByDOld, upperInds )

    ! Size the problem, check sanity, set up arrays etc.

    noOld=size(oldX,1)
    noNew=size(newX,1)
    width=size(oldY,2)

    spline=(Capitalize(method(1:1))=="S")

    extrapolateMethod="A"
    if ( present(extrapolate)) extrapolateMethod=Capitalize(extrapolate(1:1))

    useMissingRegions=.false.
    if ( present(missingRegions)) useMissingRegions=missingRegions

    computeDNewByDOld=present(dNewByDOld)

    if ( useMissingRegions.and.spline ) call MLSMessage &
      & ( MLSMSG_Error, ModuleName, "Cannot use missing regions with spline")

    if ( computeDNewByDOld .and. spline ) call MLSMessage &
      & ( MLSMSG_Error, ModuleName, "Cannot get dNewBydOld from spline")

    ! Special case where only one input point
    if ( noOld == 1 ) then
      ! If extrapolating allowed or clamped, out values same as in
      if ( extrapolateMethod=="A" .or. extrapolateMethod=="C" ) then
        do ind = 1, noNew
          newY(ind,:) =oldY(1,:)
        end do
        ! Note these next two aren't totally gracefull with respect to 
        ! the missingRegions flag.
        if ( present(dyByDx) ) dyByDx = 0.0
      else
        ! Else extrapolation forbidden
        do ind = 1, noNew
          if ( newX(ind) == oldX(1) ) then
            newY(ind,:) = oldY(1,:)
            if ( present(dyByDx) ) dyByDx = 0.0
          else
            newY(ind,:) = badValue
            if ( present(dyByDx) ) dyByDx = badValue
          end if
        end do
      end if
      if ( computeDNewByDOld ) call CreateBlock ( dNewByDOld, &
        & noNew*width, noOld*width, M_Absent )
      return
    end if

    call Allocate_Test ( lowerInds, noNew, "lowerInds", ModuleName )
    call Allocate_Test ( upperInds, noNew, "upperInds", ModuleName )
    call Allocate_Test ( gap, noNew, "gap", ModuleName )
    call Allocate_Test ( A, noNew, "A", ModuleName )
    call Allocate_Test ( B, noNew, "B", ModuleName )
    call Allocate_Test ( AA, noNew, width, "AA", ModuleName )
    call Allocate_Test ( BB, noNew, width, "BB", ModuleName )
    call Allocate_Test ( oldYlower, noNew, width, "oldYlower", ModuleName )
    call Allocate_Test ( oldYupper, noNew, width, "oldYupper", ModuleName )

    ! Setup arrays needed if dyByDx is requested

    if ( present(dyByDx)) call Allocate_Test(spreadGap,noNew,width,&
      "spreadGap",ModuleName)

    ! Setup Matrix block needed if DNewByDOld is needed.
    if ( computeDNewByDOld ) then
      call CreateBlock ( dNewByDOld, noNew*width, noOld*width, &
        M_Column_Sparse, NumberNonZero=2*noNew*width )
    end if

    ! Do special stuff for the case of spline, allocate arrays, find 2nd
    ! derivatives etc.

    if ( spline ) then
      call Allocate_Test ( oldSecond, noOld, width, "oldSecond", ModuleName )
      call Allocate_Test ( C, noNew, "C", ModuleName )
      call Allocate_Test ( D, noNew, "D", ModuleName )
      call Allocate_Test ( CC, noNew, width, "CC", ModuleName )
      call Allocate_Test ( DD, noNew, width, "DD", ModuleName )
      call Allocate_Test ( oldSecondlower, noNew, width, "oldSecondlower", ModuleName )
      call Allocate_Test ( oldSecondupper, noNew, width, "oldSecondupper", ModuleName )
      call Allocate_Test ( gap2, noNew, "gap2", ModuleName )
      call Allocate_Test ( temp, noOld, width, "temp", ModuleName )
      call Allocate_Test ( p, width, "p", ModuleName )

      ! Here we have to solve the a tridiagonal equation
      ! This is a straight copy of my idl code
      oldSecond(1,:) = 0.0
      temp(1,:) = 0.0
      do ind = 2, noOld-1
        sig = (oldX(ind)-oldX(ind-1))/(oldX(ind+1)-oldX(ind-1))
        p = sig*oldSecond(ind-1,:)+2.0
        oldSecond(ind,:) = (sig-1.0)/p
        temp(ind,:) = (oldY(ind+1,:)-oldY(ind,:))/(oldX(ind+1)-oldX(ind)) - &
          & (oldY(ind,:)-oldY(ind-1,:))/(oldX(ind)-oldX(ind-1))
        temp(ind,:) = (6.0*temp(ind,:)/ &
          & (oldX(ind+1)-oldX(ind-1))-sig*temp(ind-1,:))/p
      end do
      oldSecond(noOld,:) = 0.0

      ! Now do the back substitution
      do ind = noOld-1, 1, -1
        oldSecond(ind,:) = oldSecond(ind,:)*oldSecond(ind+1,:)+temp(ind,:)
      end do

      call Deallocate_test ( temp, "Temp", ModuleName ) 
      call Deallocate_test ( p, "p", ModuleName )
    end if

    ! Now we're ready to begin the real work.

    ! Clear the result array(s)
    newY = 0.0
    if ( present(dyByDx) ) dyByDx = 0.0

    ! Now hunt for the indices

    call Hunt ( oldX, newX, lowerInds )
    upperInds = lowerInds+1
    gap = oldX(upperInds)-oldX(lowerInds)
    if ( present(dyByDx) ) spreadGap = spread(gap,2,width)

    A = (oldX(upperInds)-newX)/gap

    ! If extrapolate is "C"onstant, deal with that
    if ( extrapolateMethod=="C" ) A = max(min(A,1.0_rA),0.0_rA)

    B=1.0_r8-A

    ! If extrapolate mode is "B"ad, deal with that
    if ( extrapolateMethod=="B" ) then
      call Allocate_Test ( maskVector, noNew, "maskVector", ModuleName )
      maskVector = 0.0
      where ( (A<0.0) .or. (A>1.0) )
        maskVector = badValue
        A = 0.0
        B = 0.0
      end where
      newY = spread(maskVector,2,width)
      if ( present(dyByDx) ) dyByDx = newY
      call Deallocate_Test ( maskVector, "maskVector", ModuleName )
    end if

    ! Now spread out the coefficients
    AA = spread(A,2,width)
    BB = spread(B,2,width)
    oldYlower = oldY(lowerInds,:)
    oldYupper = oldY(upperInds,:)

    ! Now worry about the missing regions flag
    if ( useMissingRegions ) then
      where( (oldYlower==badValue) .or. (oldYupper==badValue))
        newY = badValue
        AA = 0.0
        BB = 0.0
      end where
      if ( present(dyByDx) ) then
        where( (oldYlower==badValue) .or. &
          & (oldYupper==badValue) )
        dyByDx = badValue
        oldYlower = 0.0      ! Only way to guarentee bad derivative
        oldYupper = 0.0      ! But don't need to worry about spline
      end where
    end if
  end if

  ! Now do the linear interpolation calculation
  newY = newY+AA*oldYlower+BB*oldYupper
  if ( present(dyByDx) ) dyByDx = (oldYupper-oldYlower)/spreadGap

  ! Write the output derivative matrix if needed
  if ( computeDNewByDOld ) then
    ! While the matrix is ideally suited to row sparse, our storage method
    ! is column sparse, so to be lazy we'll create it full and then sparsify
    ! it.

    call Allocate_Test ( tempDNewByDOld, noNew*width, noOld*width, &
      & "tempDNewByDOld", ModuleName )
    do newInd = 1, noNew
      do ind = 1, width
        tempDNewByDOld(newInd+ind*noNew,lowerInds(newInd)+ind*noOld) = A(newInd)
        tempDNewByDOld(newInd+ind*noNew,upperInds(newInd)+ind*noOld) = B(newInd)
      end do
    end do
    call Sparsify ( tempDNewByDOld, dNewbyDOld, &
      & "tempDNewByDOld", ModuleName ) ! dNewbyDOld := tempDNewByDOld
  end if

  ! Now do the spline calculation
  if ( spline ) then
    gap2 = gap**2
    C = (A**3-A)*gap2/6.0    ! Note the extrapolate bad case is covered as..
    D = (B**3-B)*gap2/6.0    !   A=B=0.0

    ! Spread out the coefficients etc.
    CC = spread(C,2,width)
    DD = spread(D,2,width)
    oldSecondLower = oldSecond(lowerInds,:)
    oldSecondUpper = oldSecond(upperInds,:)

    newY = newY+CC*oldSecondLower+DD*oldSecondUpper
    if ( present(dyByDx)) dyByDx=dyByDx+(spreadGap/6.0)*( &
      & (3.0*BB**2-1.0)*oldSecondUpper- &
      & (3.0*AA**2-1.0)*oldSecondLower)
  end if

  ! Now make sure the dyByDX's are correct for extrapolated regions
  if ( present ( dyByDx ) .and. scan(extrapolateMethod(1:1),"BC") > 0) then
    select case ( extrapolateMethod(1:1) )
    case ( "C" )
      dyByDxFill = 0.0
    case ( "B" )
      dyByDxFill = badValue
    end select
    do ind = 1, noNew
      if ( ( newX(ind) >= oldX(noOld) ) .or. ( newX(ind) < oldX(1) ) ) &
        & dyByDx ( ind, : ) = dyByDXFill
    end do
  end if

  ! Tidy up
  call Deallocate_Test ( lowerInds, "lowerInds", ModuleName )
  call Deallocate_Test ( upperInds, "upperInds", ModuleName )
  call Deallocate_Test ( gap, "gap", ModuleName )
  call Deallocate_Test ( A, "A", ModuleName )
  call Deallocate_Test ( B, "B", ModuleName )
  call Deallocate_Test ( AA, "AA", ModuleName )
  call Deallocate_Test ( BB, "BB", ModuleName )
  call Deallocate_Test ( oldYlower, "oldYlower", ModuleName )
  call Deallocate_Test ( oldYupper, "oldYupper", ModuleName )

  if ( spline ) then
    call Deallocate_Test( oldSecond, "oldSecond", ModuleName )
    call Deallocate_Test( C, "C", ModuleName )
    call Deallocate_Test( D, "D", ModuleName )
    call Deallocate_Test( CC, "CC", ModuleName )
    call Deallocate_Test( DD, "DD", ModuleName )
    call Deallocate_Test( oldSecondlower, "oldSecondlower", ModuleName )
    call Deallocate_Test( oldSecondupper, "oldSecondupper", ModuleName )
    call Deallocate_Test( gap2, "gap2", ModuleName )
    call Deallocate_Test( temp, "temp", ModuleName )
    call Deallocate_Test( p, "p", ModuleName )
  end if
  if ( present(dyByDx) ) &
    & call Deallocate_Test ( spreadGap, "spreadGap", ModuleName )
d23 3
@


1.1
log
@First commit
@
text
@d4 2
d8 25
d92 1
a92 1
      if ( computeDNewByDOld ) call CreateBlock_0 ( dNewByDOld, &
d114 1
a114 1
      call CreateBlock_0 ( dNewByDOld, noNew*width, noOld*width, &
d297 3
@

