head	1.6;
access;
symbols
	v5-02-NRT-19:1.6
	v6-00:1.6
	v5-02-NRT-18:1.6
	v5-02:1.6
	v5-01-NRT-17:1.6
	v5-01-NRT-16:1.6
	v5-01-NRT-15:1.6
	v5-01-NRT-14:1.6
	neuralnetworks-1-0:1.6.0.12
	cfm-single-freq-0-1:1.6.0.10
	v5-01:1.6
	v5-00:1.6
	v4-23-TA133:1.6.0.8
	mus-emls-1-70:1.6.0.6
	rel-1-0-englocks-work:1.6.0.4
	VUMLS1-00:1.6
	VPL1-00:1.6
	V4-22-NRT-08:1.6
	VAM1-00:1.6
	V4-21:1.6.0.2
	V4-13:1.6
	V4-12:1.6
	V4-11:1.6
	V4-10:1.6
	V3-43:1.5
	M4-00:1.6
	V3-41:1.5
	V3-40-PlusGM57:1.5.0.2
	V2-24-NRT-04:1.5
	V3-33:1.5
	V2-24:1.5
	V3-31:1.5
	V3-30-NRT-05:1.5
	cfm-01-00:1.5
	V3-30:1.5
	V3-20:1.5
	V3-10:1.5
	V2-23-NRT-02:1.5
	V2-23:1.5
	V2-22-NRT-01:1.5
	V2-22:1.5
	V2-21:1.4
	V2-20:1.4
	V2-11:1.4
	V2-10:1.4
	V2-00:1.4
	V1-51:1.2
	V1-50:1.2
	V1-45:1.2
	V1-44:1.2
	V1-43:1.2
	V1-42:1.2
	V1-41:1.2
	V1-32:1.2
	V1-40:1.2
	V1-31:1.2
	V1-30:1.2
	V1-13:1.2
	V1-12:1.2
	V1-11:1.2
	V1-10:1.2
	newfwm-feb03:1.2.0.2;
locks; strict;
comment	@# @;


1.6
date	2011.08.26.00.35.04;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.25.20.29.24;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.03.17.53.54;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.22.20.03.55;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.21.02.28.48;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.04.00.45.50;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.6
log
@CSpline functionality here from fwdmdl
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id: InterpolateScalar.f9h,v 1.5 2007/06/25 20:29:24 vsnyder Exp $
!  subroutine InterpolateScalar_r* ( oldX, oldY, newX, newY, method, extrapolate, &
!    & badValue, missingRegions, dyByDx, RangeOfPeriod, skipNewY, IntYdX, YMIN, YMAX )

  ! local working space
    real(rk), dimension(:,:), pointer  :: tempDerivative, tempIntegral
    real(rk), dimension(size(newX), 1) :: tempResult
    real(rk), dimension(size(oldY))    :: tempY
    real(rk)                           :: period
    integer                            :: jump, j

    ! Executable code

    if ( Capitalize(method(1:1)) == 'C' ) then
      call cspline( oldX, newX, oldY, newY, size(oldX), size(newX), yMin, yMax )
      return
    endif

    tempY = oldY

    if ( present(rangeofperiod) ) then
      period  = rangeofPeriod(2)-rangeofPeriod(1)
      jump = -1
      do j = 1, size(oldY)-1
        if ( abs(tempY(j+1)-tempY(j)) > 0.5*period ) jump = j 
      end do
      if(jump /= -1) then
        if ( tempY(jump+1) > tempY(jump) ) then
          tempY(jump+1:) = tempY(jump+1:) - period
        else 
          tempY(jump+1:) = tempY(jump+1:) + period
        end if
      end if
    end if

    nullify ( tempDerivative )

    if ( present(dyByDx) ) then
      call Allocate_Test ( tempDerivative, size(newX), 1, &
        & "tempDerivative", ModuleName )
      if ( present(intYdX) ) then

        call Allocate_Test ( tempIntegral, size(newX), 1, &
          & "tempIntegral", ModuleName )
        call InterpolateValues ( oldX, spread(tempY,2,1), newX, tempResult, method, &
          & extrapolate=extrapolate, badValue=badValue, &
          & missingRegions=missingRegions, skipNewY=skipNewY, &
          & dyByDx=tempDerivative, &
          & intYdX=tempIntegral )
        dyByDx = tempDerivative(:,1)
        intYdX = tempIntegral(:,1)
        call Deallocate_Test ( tempIntegral, "tempIntegral", ModuleName )

      else

        call InterpolateValues ( oldX, spread(tempY,2,1), newX, tempResult, method, &
          & extrapolate=extrapolate, badValue=badValue, &
          & missingRegions=missingRegions, skipNewY=skipNewY, &
          & dyByDx=tempDerivative )
        dyByDx = tempDerivative(:,1)

      end if

      call Deallocate_Test ( tempDerivative, "tempDerivative", ModuleName )
    else
      if ( present(intYdX) ) then

        call Allocate_Test ( tempIntegral, size(newX), 1, &
          & "tempIntegral", ModuleName )
        call InterpolateValues ( oldX, spread(tempY,2,1), newX, tempResult, method, &
          & extrapolate=extrapolate, badValue=badValue, &
          & missingRegions=missingRegions, skipNewY=skipNewY, &
          & intYdX=tempIntegral )
        intYdX = tempIntegral(:,1)
        call Deallocate_Test ( tempIntegral, "tempIntegral", ModuleName )

      else

        call InterpolateValues ( oldX, spread(tempY,2,1), newX, tempResult, method, &
          & extrapolate=extrapolate, badValue=badValue, &
          & missingRegions=missingRegions, skipNewY=skipNewY )
      end if
    end if
    newY = tempResult(:,1)

    if ( present(rangeofperiod) ) then
      period  = rangeofPeriod(2)-rangeofPeriod(1)
      where ( newY > rangeofperiod(2) ) 
        newY = newY - period
      elsewhere (newY < rangeofperiod(1)) 
        newY = newY + period
      end where
    end if
!  end subroutine InterpolateScalar_r*

! $Log: InterpolateScalar.f9h,v $
! Revision 1.5  2007/06/25 20:29:24  vsnyder
! Replace tabs by spaces, since tabs are nonstandard
!
! Revision 1.4  2005/08/03 17:53:54  vsnyder
! Add antiderivatives
!
! Revision 1.3  2005/06/22 20:03:55  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.2  2002/11/21 02:28:48  vsnyder
! Cosmetic changes
!
! Revision 1.1  2002/10/04 00:45:50  vsnyder
! First commit
!
@


1.5
log
@Replace tabs by spaces, since tabs are nonstandard
@
text
@d12 1
a12 1
! $Id: InterpolateScalar.f9h,v 1.4 2005/08/03 17:53:54 vsnyder Exp $
d14 1
a14 1
!    & badValue, missingRegions, dyByDx, RangeOfPeriod, skipNewY, IntYdX )
d17 1
a17 1
    real(rk), dimension(:,:), pointer :: tempDerivative, tempIntegral
d19 3
a21 3
    real(rk), dimension(size(oldY)) :: tempY
    real(rk) period
    integer jump, j
d25 5
d108 3
@


1.4
log
@Add antiderivatives
@
text
@d12 1
a12 1
! $Id: InterpolateScalar.f9h,v 1.3 2005/06/22 20:03:55 pwagner Exp $
d31 1
a31 1
	if ( abs(tempY(j+1)-tempY(j)) > 0.5*period ) jump = j 
d34 5
a38 5
	if ( tempY(jump+1) > tempY(jump) ) then
	  tempY(jump+1:) = tempY(jump+1:) - period
	else 
	  tempY(jump+1:) = tempY(jump+1:) + period
	end if
d95 1
a95 1
	newY = newY - period
d97 1
a97 1
	newY = newY + period
d103 3
@


1.3
log
@Reworded Copyright statement, moved rcs id
@
text
@d12 1
a12 1
! $Id: InterpolateScalar.f9h,v 1.2 2002/11/21 02:28:48 vsnyder Exp $
d14 1
a14 1
!    & badValue, missingRegions, dyByDx, RangeOfPeriod )
d17 1
a17 1
    real(rk), dimension(:,:), pointer :: tempDerivative
d47 1
d49 20
a68 4
      call InterpolateValues ( oldX, spread(tempY,2,1), newX, tempResult, method, &
        & extrapolate=extrapolate, badValue=badValue, &
        & missingRegions=missingRegions, dyByDx=tempDerivative )
      dyByDx = tempDerivative(:,1)
d72 17
a88 3
      call InterpolateValues ( oldX, spread(tempY,2,1), newX, tempResult, method, &
        & extrapolate=extrapolate, badValue=badValue, &
        & missingRegions=missingRegions )
d103 3
@


1.2
log
@Cosmetic changes
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d12 1
a12 1
! $Id: InterpolateScalar.f9h,v 1.1 2002/10/04 00:45:50 vsnyder Exp $
d72 3
@


1.1
log
@First commit
@
text
@d4 1
a4 1
! $Id: $
d20 12
a31 12
	  period  = rangeofPeriod(2)-rangeofPeriod(1)
	  jump = -1
	  do j =1, size(oldY)-1
		  if(abs(tempY(j+1)-tempY(j)) > period/2. ) jump = j 
	  end do
	  if(jump /= -1) then
	     if(tempY(jump+1) > tempY(jump)) then
		  tempY(jump+1:) = tempY(jump+1:) - period
	     else 
		  tempY(jump+1:) = tempY(jump+1:) + period
	     end if
	  end if
d54 6
a59 6
	  period  = rangeofPeriod(2)-rangeofPeriod(1)
	  where (newY > rangeofperiod(2)) 
	    newY = newY - period
	  elsewhere (newY < rangeofperiod(1)) 
	    newY = newY + period
	  end where
d63 4
a66 1
! $Log: $
@

