head	1.3;
access;
symbols
	v5-02-NRT-19:1.3
	v6-00:1.3
	v5-02-NRT-18:1.3
	v5-02:1.3
	v5-01-NRT-17:1.3
	v5-01-NRT-16:1.3
	v5-01-NRT-15:1.3
	v5-01-NRT-14:1.3
	neuralnetworks-1-0:1.3.0.12
	cfm-single-freq-0-1:1.3.0.10
	v5-01:1.3
	v5-00:1.3
	v4-23-TA133:1.3.0.8
	mus-emls-1-70:1.3.0.6
	rel-1-0-englocks-work:1.3.0.4
	VUMLS1-00:1.3
	VPL1-00:1.3
	V4-22-NRT-08:1.3
	VAM1-00:1.3
	V4-21:1.3.0.2
	V4-13:1.3
	V4-12:1.3
	V4-11:1.3
	V4-10:1.3
	M4-00:1.2;
locks; strict;
comment	@# @;


1.3
date	2013.06.12.01.05.28;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2013.02.11.17.19.39;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2012.06.12.18.10.54;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove unused cruft
@
text
@! Copyright 2012, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! How to handle dumping stats in every module procedure of dump_0
! where it makes sense to dump stats
! 
! $Id: Battleship.f9h,v 1.2 2013/02/11 17:19:39 pwagner Exp $
! $RCSfile: Battleship.f9h,v $

    ! Args
    real(rk), external                          :: fun
    real(rk), intent(in)                        :: arg1 ! 1st circle
    real(rk), intent(in)                        :: delta ! tolerance
    integer, optional, intent(in)               :: maxPhase1 ! max phase1 shots
    integer, optional, dimension(:), intent(in) :: ns ! array of phase1 shots
    real(rk), intent(out)                       :: root ! root
    integer, optional, intent(out)              :: status ! /= 0 if failed
    ! Internal variables
    real(rk) :: flast
    real(rk) :: fnext
    integer  :: shot
    real(rk) :: f1
    real(rk) :: f2
    real(rk) :: x0
    real(rk) :: x1
    real(rk) :: x2
    logical, parameter :: DEEBUG = .false.
    ! Executable
    root = -1 ! in case we can't find root
    if ( present(status) ) status = 1
    ! Phase 1
    ! Some error checks
    if ( present(maxPhase1) ) then
      if ( maxPhase1 < 1 ) return
      x2 = arg1 ! Initialize things
      fnext = fun(x2)
      do shot = 1, maxPhase1
        x1 = x2
        x2 = 2*x1
        flast = fnext
        fnext = fun(x2)
        if ( flast*fnext <= 0._rk ) exit
      enddo
      if ( shot > maxPhase1 ) return ! No shot was long enough
    else
      if ( .not. present(ns) ) return
      x2 = arg1 ! Initialize things
      fnext = fun(x2)
      do shot = 1, size(ns)
        x1 = x2
        x2 = x1 + ns(shot)*delta
        flast = fnext
        fnext = fun(x2)
        if ( flast*fnext <= 0._rk ) exit
      enddo
      if ( shot > size(ns) ) return ! No shot was long enough
    end if
    ! Phase 2
    if ( present(status) ) status = 0
    ! Narrow the spashes, always keeping root between x0 and x2
    if ( DEEBUG ) then
      call outputnamedValue ('No. of phase 1 shots', shot )
      call outputnamedValue ('x1, x2', (/x1, x2/) )
      shot = 0
    endif
    x0 = x1
    f1 = flast
    f2 = fun(x2)
    if ( DEEBUG ) call outputnamedValue ('f1, f2', (/f1, f2/) )
    if ( f2*f1 == 0._rk ) then
      if ( fun(x2) == 0._rk ) then
        root = x2
      else
        root = x1
      end if
      return
    end if
    do
      if ( DEEBUG ) shot = shot + 1
      x1 = (x0 + x2) / 2
      f1 = fun(x1)
      ! This test should prevent us from looping endlessly
      if ( abs((x1-x0)/delta) < 2 ) then
        ! apparently x0 = x2 - 1, so we've found our root
        if ( abs(f1) < abs(f2) ) then
          root = x1
        else
          root = x2
        end if
        if ( DEEBUG ) call outputnamedValue ('No. of phase 2 shots', shot )
        return
      end if
      if ( f2*f1 == 0._rk ) then
        if ( fun(x2) == 0._rk ) then
          root = x2
        else
          root = x1
        end if
        if ( DEEBUG ) call outputnamedValue ('No. of phase 2 shots', shot )
        return
      elseif ( f2*f1 < 0._rk ) then
        x0 = x1
      else
        x2 = x1
        f2 = f1
      end if
    enddo
! $Log: Battleship.f9h,v $
! Revision 1.2  2013/02/11 17:19:39  pwagner
! Battleship returns nonzero status if cant find root
!
! Revision 1.1  2012/06/12 18:10:54  pwagner
! First commit
!
@


1.2
log
@Battleship returns nonzero status if cant find root
@
text
@d15 1
a15 1
! $Id: Battleship.f9h,v 1.1 2012/06/12 18:10:54 pwagner Exp $
a29 1
    real(rk) :: f0
a110 1
        f0 = f1
d117 3
@


1.1
log
@First commit
@
text
@d15 1
a15 1
! $Id: Battleship.f9h,v 2.29 2012/05/25 20:38:00 pwagner Exp $
d25 1
d39 1
d68 1
d119 3
@

