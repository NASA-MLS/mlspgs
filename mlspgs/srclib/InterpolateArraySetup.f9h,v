head	1.9;
access;
symbols
	v5-02-NRT-19:1.9
	v6-00:1.9
	v5-02-NRT-18:1.9
	v5-02:1.9
	v5-01-NRT-17:1.9
	v5-01-NRT-16:1.9
	v5-01-NRT-15:1.9
	v5-01-NRT-14:1.9
	neuralnetworks-1-0:1.9.0.10
	cfm-single-freq-0-1:1.9.0.8
	v5-01:1.9
	v5-00:1.9
	v4-23-TA133:1.9.0.6
	mus-emls-1-70:1.9.0.4
	rel-1-0-englocks-work:1.9.0.2
	VUMLS1-00:1.9
	VPL1-00:1.9
	V4-22-NRT-08:1.8
	VAM1-00:1.8
	V4-21:1.8.0.4
	V4-13:1.8
	V4-12:1.8
	V4-11:1.8
	V4-10:1.8
	V3-43:1.8
	M4-00:1.8
	V3-41:1.8
	V3-40-PlusGM57:1.8.0.2
	V2-24-NRT-04:1.4
	V3-33:1.8
	V2-24:1.4
	V3-31:1.8
	V3-30-NRT-05:1.8
	cfm-01-00:1.8
	V3-30:1.8
	V3-20:1.8
	V3-10:1.5
	V2-23-NRT-02:1.4
	V2-23:1.4
	V2-22-NRT-01:1.4
	V2-22:1.4
	V2-21:1.4
	V2-20:1.4
	V2-11:1.4
	V2-10:1.4
	V2-00:1.4
	V1-51:1.1
	V1-50:1.1
	V1-45:1.1
	V1-44:1.1
	V1-43:1.1
	V1-42:1.1
	V1-41:1.1
	V1-32:1.1
	V1-40:1.1
	V1-31:1.1
	V1-30:1.1
	V1-13:1.1
	V1-12:1.1
	V1-11:1.1
	V1-10:1.1
	newfwm-feb03:1.1.0.2;
locks; strict;
comment	@# @;


1.9
date	2016.08.23.20.30.26;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.02.01.32.11;	author vsnyder;	state Exp;
branches;
next	1.7;

1.7
date	2009.12.10.02.56.14;	author vsnyder;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.08.21.44.21;	author vsnyder;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.20.02.32.44;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.06.01.35.47;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.03.16.34.20;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.22.20.03.55;	author pwagner;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.22.23.58.48;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


1.9
log
@InterpolateArraySetup may return after failure if optional arg fail present
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! subroutine InterpolateArraySetup_r* ( OldX, NewX, Method, Coeffs, &
!   & Extrapolate, Width, DyByDx, dNewByDOld, intYdX, fail )

    ! Method = S for spline, else linear
    ! ExtrapolateMethod = C for constant, B for bad, P for periodic
    !   continuity if Method = S, else linear

    ! If ExtrapolateMethod == P, make OldX one element longer than you
    ! would otherwise, with OldX(last) = OldX(first) + Period.  NewX is
    ! then put within the range OldX(1)..OldX(last) using
    !   NewX_P = modulo(NewX - OldX(1),Period)
    !   where ( NewX_P < 0 ) NewX_P = NewX_P + Period
    !   NewX_P = NewX_P + OldX(1)

    target :: NewX

    ! Local variables
    logical :: ComputeDNewByDOld
    character :: ExtrapolateMethod
    real(rk) :: Gap2(size(newX,1)), Period
    real(rk), pointer :: NewX_P(:) ! NewX reduced modulo Period, or => NewX
    integer :: Ind, NewInd, NoNew, NoOld
    integer :: LB, UB              ! Bounds for Coeffs%P
    integer, parameter :: RA = kind(coeffs%a)
    real(rm), pointer :: TempDNewByDOld(:,:)
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: InterpolateArraySetup.f9h,v 1.8 2010/02/02 01:32:11 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------

    ! Size the problem, check sanity, set up arrays etc.

    extrapolateMethod = "A"
    if ( present(extrapolate)) extrapolateMethod = Capitalize(extrapolate(1:1))

    noNew = size(newX,1)
    noOld = size(oldX,1)

    computeDNewByDOld = present(dNewByDOld)
    if ( computeDNewByDOld .and. .not. present(width) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Cannot compute dNewByDOld without knowing Width" )

    ! Components of coeffs spring into existence nullified, not undefined
    call allocate_test ( coeffs%a, noNew, "Coeffs%A", ModuleName )
    call allocate_test ( coeffs%b, noNew, "Coeffs%B", ModuleName )
    call allocate_test ( coeffs%gap, noNew, "Coeffs%Gap", ModuleName )
    call allocate_test ( coeffs%lowerInds, noNew, "Coeffs%LowerInds", ModuleName )

    lb = 1
    ub = noOld-2
    if ( extrapolateMethod /= "P" .or. capitalize(method(1:1)) /= 'S' ) then
      newX_P => newX
    else
      lb = 0
      nullify ( newX_P )
      call allocate_test ( newX_P, noNew, "NewX_P", moduleName )
      period = oldX(noOld)-oldX(1)
      NewX_P = modulo(NewX - OldX(1),Period)
      where ( NewX_P < 0 ) NewX_P = NewX_P + Period
      NewX_P = NewX_P + OldX(1)
    end if
    call Hunt ( oldX, newX_P, coeffs%lowerInds, fail=fail )
    if ( present(fail) ) then
      if ( fail ) return
    endif
    coeffs%gap = oldX(coeffs%lowerInds+1) - oldX(coeffs%lowerInds)
    coeffs%A = (oldX(coeffs%lowerInds+1)-newX_P)/coeffs%gap

    ! If extrapolate is "C"onstant, deal with that
    if ( extrapolateMethod == "C" ) coeffs%A = max(min(coeffs%A,1.0_rA),0.0_rA)

    coeffs%B = 1.0 - coeffs%A

    ! If extrapolate mode is "B"ad, deal with that
    if ( extrapolateMethod == "B" ) then
      call Allocate_Test ( coeffs%badValue, noNew, "maskVector", ModuleName )
      coeffs%badValue = (coeffs%A<0.0) .or. (coeffs%A>1.0)
      where ( coeffs%badValue )
        coeffs%A = 0.0
        coeffs%B = 0.0
      end where
    end if

    ! Spline stuff
    if ( capitalize(method(1:1)) == 'S' ) then
      if ( computeDNewByDOld ) call MLSMessage &
        & ( MLSMSG_Error, ModuleName, "Cannot get dNewBydOld from spline")
      call allocate_test ( coeffs%c, noNew, "Coeffs%C", ModuleName )
      call allocate_test ( coeffs%d, noNew, "Coeffs%D", ModuleName )
      call allocate_test ( coeffs%dX, noOld-1, "Coeffs%dX", ModuleName )
      call allocate_test ( coeffs%o, ub-1, "Coeffs%O", ModuleName )
      call allocate_test ( coeffs%p, ub, "Coeffs%P", ModuleName, lowBound=lb )
      ! Note the extrapolate bad case is covered as A=B=0.0
      gap2 = coeffs%gap ** 2 / 6.0
      coeffs%C = (coeffs%A**3-coeffs%A) * gap2
      coeffs%D = (coeffs%B**3-coeffs%B) * gap2
      coeffs%dX = oldX(2:noOld)-oldX(1:noOld-1)

      ! Set up the system to solve
      coeffs%p(1:noOld-2) = 2.0 * ( coeffs%dx(1:noOld-2) + coeffs%dx(2:noOld-1) )
      ! Factor the system
      if ( extrapolateMethod /= "P" ) then ! Not periodic continuity
        call factor_symm_tri ( coeffs%p(1:ub), coeffs%dx(2:ub), coeffs%o )
      else
        call allocate_test ( coeffs%row, ub, "Coeffs%Row", ModuleName )
        call allocate_test ( coeffs%col, ub, "Coeffs%Col", ModuleName )
      ! coeffs%dx(noOld-1) = coeffs%dx(noOld-1) ! Corners of the matrix
        coeffs%p(0) = 2.0 * ( coeffs%dx(1) + coeffs%dx(noOld-1) )
        call factor_symm_tri ( coeffs%p, coeffs%dx, &
          & coeffs%row, coeffs%o, coeffs%col )
      end if

      ! Compute some more coefficients for splines if DyByDx is present
      if ( present(dyByDx) ) then
        if ( dyByDx ) then
          call allocate_test ( coeffs%e, noNew, "Coeffs%C", ModuleName )
          call allocate_test ( coeffs%f, noNew, "Coeffs%D", ModuleName )
          coeffs%e = 3.0*coeffs%a**2 - 1.0
          coeffs%f = 3.0*coeffs%b**2 - 1.0
        end if
      end if
    end if

    ! Write the output derivative matrix if needed
    if ( computeDNewByDOld ) then
      call CreateBlock ( dNewByDOld, noNew*width, noOld*width, M_Absent )
      ! While the matrix is ideally suited to row sparse, our storage method
      ! is column sparse, so to be lazy we'll create it full and then sparsify
      ! it.

      call Allocate_Test ( tempDNewByDOld, noNew*width, noOld*width, &
        & "tempDNewByDOld", ModuleName )
      do newInd = 1, noNew
        do ind = 1, width
          tempDNewByDOld(newInd+ind*noNew,coeffs%lowerInds(newInd)+ind*noOld) = &
            &  coeffs%A(newInd)
          tempDNewByDOld(newInd+ind*noNew,coeffs%lowerInds(newInd)+1+ind*noOld) = &
            &  coeffs%B(newInd)
        end do
      end do
      call Sparsify ( tempDNewByDOld, dNewbyDOld, &
        & "tempDNewByDOld", ModuleName ) ! dNewbyDOld := tempDNewByDOld
      call Deallocate_Test ( tempDNewByDOld, "tempDNewByDOld", ModuleName )
    end if

    if ( present(intYdX) ) then
      if ( intYdX ) then
        call allocate_test ( coeffs%ai, noNew, "Coeffs%AI", ModuleName )
        call allocate_test ( coeffs%bi, noNew, "Coeffs%BI", ModuleName )
        call allocate_test ( coeffs%ci, noNew, "Coeffs%CI", ModuleName )
        call allocate_test ( coeffs%di, noNew, "Coeffs%DI", ModuleName )
        coeffs%AI = newX_P * (oldX(coeffs%lowerInds+1) - 0.5 * newX_P) / coeffs%gap
        coeffs%BI = newX_P - coeffs%AI
        coeffs%CI = -gap2 * ( coeffs%AI + 0.25 * coeffs%gap * coeffs%A**4 )
        coeffs%DI = -gap2 * ( coeffs%BI - 0.25 * coeffs%gap * coeffs%B**4 )
      end if
    end if

    if ( extrapolateMethod == "P" .and. capitalize(method(1:1)) == 'S' ) &
      & call deallocate_test ( newX_P, "newX_P", moduleName )

! end subroutine InterpolateArraySetup_r*

! $Log: InterpolateArraySetup.f9h,v $
! Revision 1.8  2010/02/02 01:32:11  vsnyder
! Deallocate TempDNewByDOld to plug a memory leak
!
! Revision 1.7  2009/12/10 02:56:14  vsnyder
! Put NewX into the period of OldX correctly
!
! Revision 1.6  2009/12/08 21:44:21  vsnyder
! Provide splines with periodic boundary conditions, use Symm_Tri
!
! Revision 1.5  2009/06/20 02:32:44  vsnyder
! Precompute more stuff, handle identical abscissae, in spline case
!
! Revision 1.4  2005/08/06 01:35:47  vsnyder
! Cannonball polishing
!
! Revision 1.3  2005/08/03 16:34:20  pwagner
! InterpolateArray optionally finds antiderivatives
!
! Revision 1.2  2005/06/22 20:03:55  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.1  2002/11/22 23:58:48  vsnyder
! Initial Commit
!
@


1.8
log
@Deallocate TempDNewByDOld to plug a memory leak
@
text
@d13 1
a13 1
!   & Extrapolate, Width, DyByDx, dNewByDOld, intYdX )
d39 1
a39 1
       "$Id: InterpolateArraySetup.f9h,v 1.7 2009/12/10 02:56:14 vsnyder Exp $"
d75 4
a78 1
    call Hunt ( oldX, newX_P, coeffs%lowerInds )
d178 3
@


1.7
log
@Put NewX into the period of OldX correctly
@
text
@d39 1
a39 1
       "$Id: InterpolateArraySetup.f9h,v 1.6 2009/12/08 21:44:21 vsnyder Exp $"
d153 1
d175 3
@


1.6
log
@Provide splines with periodic boundary conditions, use Symm_Tri
@
text
@d21 4
a24 1
    ! then reduced modulo Period.
d39 1
a39 1
       "$Id: InterpolateArraySetup.f9h,v 1.5 2009/06/20 02:32:44 vsnyder Exp $"
d71 3
a73 1
      newX_P = modulo(newX,period)
d174 3
@


1.5
log
@Precompute more stuff, handle identical abscissae, in spline case
@
text
@d15 10
d28 2
a29 1
    real(rk) :: Gap2(size(newX,1))
d31 1
d36 1
a36 1
       "$Id: InterpolateArraySetup.f9h,v 1.4 2005/08/06 01:35:47 vsnyder Exp $"
d42 3
a47 3
    extrapolateMethod = "A"
    if ( present(extrapolate)) extrapolateMethod = Capitalize(extrapolate(1:1))

d59 12
a70 1
    call Hunt ( oldX, newX, coeffs%lowerInds )
d72 1
a72 2

    coeffs%A = (oldX(coeffs%lowerInds+1)-newX)/coeffs%gap
d95 3
a97 3
      call allocate_test ( coeffs%dX, noOld, "Coeffs%dX", ModuleName, lowBound=2 )
      call allocate_test ( coeffs%o, noOld-1, "Coeffs%O", ModuleName, lowBound=2 )
      call allocate_test ( coeffs%p, noOld-1, "Coeffs%P", ModuleName, lowBound=2 )
d104 12
a115 3
      if ( noOld > 2 ) then ! to avoid needing coeffs%o(1) to start the iteration
        coeffs%p(2) = 0.5 / ( oldX(3) - oldX(1) )
        coeffs%o(2) = -coeffs%dx(3) * coeffs%p(2)
a116 6
      do ind = 3, noOld-1
        coeffs%p(ind) = 1.0 / &
                      & ( coeffs%dx(ind) * coeffs%o(ind-1) + &
                      &   2.0 * ( oldX(ind+1) - oldX(ind-1) ) )
        coeffs%o(ind) = -coeffs%dx(ind+1) * coeffs%p(ind)
      end do
d156 2
a157 2
        coeffs%AI = newX * (oldX(coeffs%lowerInds+1) - 0.5 * newX) / coeffs%gap
        coeffs%BI = newX - coeffs%AI
d162 4
a165 1
        
d169 3
@


1.4
log
@Cannonball polishing
@
text
@a11 2
! $Id: InterpolateArraySetup.f9h,v 1.3 2005/08/03 16:34:20 pwagner Exp $

d22 5
a45 1
    call allocate_test ( coeffs%upperInds, noNew, "Coeffs%UpperInds", ModuleName )
d48 1
a48 2
    coeffs%upperInds = coeffs%lowerInds + 1
    coeffs%gap = oldX(coeffs%upperInds) - oldX(coeffs%lowerInds)
d50 1
a50 1
    coeffs%A = (oldX(coeffs%upperInds)-newX)/coeffs%gap
d73 3
a75 2
      call allocate_test ( coeffs%sig, noOld-1, "Coeffs%Sig", ModuleName, &
        & lowBound=2 )
d80 12
a91 2
      coeffs%sig = (oldX(2:noOld-1)-oldX(1:noOld-2)) / &
        &          (oldX(3:noOld)-oldX(1:noOld-2))
d117 2
a118 2
          tempDNewByDOld(newInd+ind*noNew,coeffs%upperInds(newInd)+ind*noOld) = &
            & coeffs%B(newInd)
d131 1
a131 1
        coeffs%AI = newX * (oldX(coeffs%upperInds) - 0.5 * newX) / coeffs%gap
d141 3
@


1.3
log
@InterpolateArray optionally finds antiderivatives
@
text
@d12 1
a12 1
! $Id: InterpolateArraySetup.f9h,v 1.2 2005/06/22 20:03:55 pwagner Exp $
d119 1
a119 1
        coeffs%AI = newX * (oldX(coeffs%upperInds)-0.5 * newX)/coeffs%gap
d129 3
@


1.2
log
@Reworded Copyright statement, moved rcs id
@
text
@d12 1
a12 1
! $Id: InterpolateArraySetup.f9h,v 1.1 2002/11/22 23:58:48 vsnyder Exp $
d15 1
a15 1
!   & Extrapolate, Width, DyByDx, dNewByDOld )
d20 1
d54 1
a54 1
    coeffs%B = 1.0_rk - coeffs%A
a71 1
      call allocate_test ( coeffs%gap2, noNew, "Coeffs%Gap2", ModuleName )
d75 3
a77 3
      coeffs%gap2 = coeffs%gap ** 2
      coeffs%C = (coeffs%A**3-coeffs%A)*coeffs%gap2/6.0    
      coeffs%D = (coeffs%B**3-coeffs%B)*coeffs%gap2/6.0
d83 6
a88 4
        call allocate_test ( coeffs%e, noNew, "Coeffs%C", ModuleName )
        call allocate_test ( coeffs%f, noNew, "Coeffs%D", ModuleName )
        coeffs%e = 3.0_rk*coeffs%a**2 - 1.0_rk
        coeffs%f = 3.0_rk*coeffs%b**2 - 1.0_rk
d113 13
d129 3
@


1.1
log
@Initial Commit
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d12 1
a12 1
! $Id: InterpolateArray.f9h,v 1.2 2002/10/04 00:46:12 vsnyder Exp $
d113 4
a116 1
! $Log: $
@

