head	1.1;
access;
symbols
	v5-02-NRT-19:1.1
	v6-00:1.1
	v5-02-NRT-18:1.1
	v5-02:1.1
	v5-01-NRT-17:1.1
	v5-01-NRT-16:1.1
	v5-01-NRT-15:1.1
	v5-01-NRT-14:1.1
	neuralnetworks-1-0:1.1.0.16
	cfm-single-freq-0-1:1.1.0.14
	v5-01:1.1
	v5-00:1.1
	v4-23-TA133:1.1.0.12
	mus-emls-1-70:1.1.0.10
	rel-1-0-englocks-work:1.1.0.8
	VUMLS1-00:1.1
	VPL1-00:1.1
	V4-22-NRT-08:1.1
	VAM1-00:1.1
	V4-21:1.1.0.6
	V4-13:1.1
	V4-12:1.1
	V4-11:1.1
	V4-10:1.1
	V3-43:1.1
	M4-00:1.1
	V3-41:1.1
	V3-40-PlusGM57:1.1.0.4
	V2-24-NRT-04:1.1
	V3-33:1.1
	V2-24:1.1
	V3-31:1.1
	V3-30-NRT-05:1.1
	cfm-01-00:1.1
	V3-30:1.1
	V3-20:1.1
	V3-10:1.1
	V2-23-NRT-02:1.1
	V2-23:1.1
	V2-22-NRT-01:1.1
	V2-22:1.1
	V2-21:1.1
	V2-20:1.1
	V2-11:1.1
	V2-10:1.1
	V2-00:1.1
	V1-51:1.1
	V1-50:1.1
	V1-45:1.1
	V1-44:1.1
	V1-43:1.1
	V1-42:1.1
	V1-41:1.1
	V1-32:1.1
	V1-40:1.1
	V1-31:1.1
	V1-13:1.1
	V1-12:1.1
	V1-11:1.1
	V1-10:1.1
	newfwm-feb03:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2002.09.25.23.01.56;	author pwagner;	state Exp;
branches;
next	;


desc
@@


1.1
log
@First commit
@
text
@!=================================
PROGRAM blastest ! tests blas routines
!=================================

   USE MLSCommon , ONLY: r4, r8
   USE time_m , ONLY: wait, time_now  
   use DOT_M, only: DOT
   use Gemm_M, only: GEMM
   use Gemv_M, only: GEMV
   
   IMPLICIT NONE

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &                                                    
   "$Id: wait_test.f90,v 1.3 2001/01/30 17:24:25 nakamura Exp nakamura $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: rl2_sub.f90,v $"
!----------------------------------------------------------

! Brief description of program
! This program tests the blas subroutines.

! To use this, copy it into
! mlspgs/tests/lib
! then enter "make depends" followed by "make"


! Then run it

! Variables
   integer, parameter          :: ntests = 6
   real(r8), dimension(ntests) :: times
   integer, dimension(ntests)  :: lengths
   integer                     :: test, loops

   lengths = (/ 5000, 7500, 10000, 12500, 15000, 17500 /)
   print *, 'How many loops (e.g., 100)'
   read *, loops
  ! vector - vector products
	do test=1, ntests
 	  times(test) = dot_test(lengths(test), loops)
	enddo
   print *, 'Test results (dot)'
   print *, 'Test      Length          Time          time/mflop'
   do test=1, ntests
     print*, test, lengths(test), times(test), 1d6*times(test)/lengths(test)
   enddo
   lengths = (/ 500, 750, 1000, 1250, 1500, 2000 /)
  ! Matrix - vector products
	do test=1, ntests
 	  times(test) = gemv_test(lengths(test), loops)
	enddo
   print *, 'Test results (gemv)'
   print *, 'Test      Length          Time          time/mflop'
   do test=1, ntests
     print*, test, lengths(test), times(test), 1d6*times(test)/lengths(test)**2
   enddo
   lengths = (/ 50, 75, 100, 125, 150, 200 /)
  ! Matrix - matrix products (r4)
	do test=1, ntests
 	  times(test) = sgemm_test(lengths(test), loops)
	enddo
   print *, 'Test results (sgemm)'
   print *, 'Test      Length          Time          time/mflop'
   do test=1, ntests
     print*, test, lengths(test), times(test), 1d6*times(test)/lengths(test)**3
   enddo
   lengths = (/ 50, 75, 100, 125, 150, 200 /)
  ! Matrix - matrix products (r8)
	do test=1, ntests
 	  times(test) = dgemm_test(lengths(test), loops)
	enddo
   print *, 'Test results (dgemm)'
   print *, 'Test      Length          Time          time/mflop'
   do test=1, ntests
     print*, test, lengths(test), times(test), 1d6*times(test)/lengths(test)**3
   enddo
contains
  function dot_test ( length, loops )
    ! Time how long it takes to dot two vectors of length length
    integer, intent(in)   :: length, loops
    real(r8)                  :: dot_test
    real(r8) :: t0, t1
    integer :: i
    
    ! Private
    real(r8), parameter :: startv=-1.d0, endv = 1.d0
    real(r8), dimension(:), pointer :: v1, v2
    real(r8) :: v1sq, v2sq, v1dotv2, v2dotv1
    real(r8), external :: ddot
    
    allocate(v1(length), v2(length))
    call fill_vector(v1, startv, endv)
    call fill_vector(v2, startv, endv)
    dot_test = 0.d0
    call time_now(t0)
    do i=1, loops
      v1sq = dot(length, v1(1), 1, v1(1), 1)
      v1dotv2 = dot(length, v1(1), 1, v2(1), 1)
      v2dotv1 = dot(length, v2(1), 1, v1(1), 1)
      v2sq = dot(length, v2(1), 1, v2(1), 1)
!      v1sq = ddot(length, v1, 1, v1, 1)
!      v1dotv2 = ddot(length, v1, 1, v2, 1)
!      v2dotv1 = ddot(length, v2, 1, v1, 1)
!      v2sq = ddot(length, v2, 1, v2, 1)
    enddo
    call time_now(t1)
    dot_test = t1 - t0
    deallocate(v1, v2)
  end function dot_test

  subroutine fill_vector ( vector, startv, endv )
    ! Fill vector from vector(1) to vector (length) with values
    ! ranging from startv to endv linearly
    real(r8), dimension(:), intent(out)   :: vector
    real(r8), intent(in)                  :: startv
    real(r8), intent(in)                  :: endv
    
    ! Private
    real(r8) :: dv
    integer ::   i, length
    if (size(vector) <= 0) return
    length = size(vector)
    vector(1) = startv
    if ( length == 1) return
    dv = (endv - startv) / (length-1)
    do i = 2, length
      vector(i) = startv + (i-1)*dv
    enddo
  end subroutine fill_vector

  subroutine fill_svector ( vector, startv, endv )
    ! Fill vector from vector(1) to vector (length) with values
    ! ranging from startv to endv linearly
    real(r4), dimension(:), intent(out)   :: vector
    real(r4), intent(in)                  :: startv
    real(r4), intent(in)                  :: endv
    
    ! Private
    real(r4) :: dv
    integer ::   i, length
    if (size(vector) <= 0) return
    length = size(vector)
    vector(1) = startv
    if ( length == 1) return
    dv = (endv - startv) / (length-1)
    do i = 2, length
      vector(i) = startv + (i-1)*dv
    enddo
  end subroutine fill_svector

  function gemv_test ( length, loops )
    ! Time how long it takes to perform matrix-vector product of length length
    integer, intent(in)   :: length, loops
    real(r8)                  :: gemv_test
    real(r8) :: t0, t1
    integer :: i
    
    ! Private
    real(r8), parameter :: startv=-1.d0, endv = 1.d0
    real(r8), dimension(:), pointer   :: v1, v2
    real(r8), dimension(:,:), pointer :: m
    real(r8) :: v1sq, v2sq, v1dotv2, v2dotv1
    
    allocate(v1(length), v2(length), m(length, length))
    call fill_vector(v1, startv, endv)
    call fill_vector(v2, startv, endv)
    do i=1, length
      call fill_vector(m(:,i), startv, endv)
    enddo
    call time_now(t0)
    do i=1, loops
!    call dgemv('n', length, length, 1.d0, m, length, v1, 1, &
!      & 1.d0, v2, 1)
    call gemv('n', length, length, 1.d0, m, length, v1, 1, &
      & 1.d0, v2, 1)
    enddo
    call time_now(t1)
    gemv_test = t1 - t0
    deallocate(v1, v2, m)
  end function gemv_test

  function dgemm_test ( length, loops )
    ! Time how long it takes to perform matrix-matrix product of length length
    ! (type r8)
    integer, intent(in)   :: length, loops
    real(r8)                  :: dgemm_test
    real(r8) :: t0, t1
    integer :: i
    
    ! Private
    real(r8), parameter :: startv=-1.d0, endv = 1.d0
    real(r8), dimension(:,:), pointer   :: m1, m2
    real(r8), dimension(:,:), pointer :: m
    real(r8) :: v1sq, v2sq, v1dotv2, v2dotv1
    
    allocate(m1(length, length), m2(length, length), m(length, length))
    do i=1, length
      call fill_vector(m(:,i), startv, endv)
      call fill_vector(m1(:,i), startv, endv)
      call fill_vector(m2(:,i), startv, endv)
    enddo
    call time_now(t0)
    do i=1, loops
!    call dgemm('n', 'n', length, length, length, 1.d0, m1, length, m2, length, &
!      & 1.d0, m, length)
    call gemm('n', 'n', length, length, length, 1.d0, m1, length, m2, length, &
      & 1.d0, m, length)
    enddo
    call time_now(t1)
    dgemm_test = t1 - t0
    deallocate(m1, m2, m)
  end function dgemm_test

  function sgemm_test ( length, loops )
    ! Time how long it takes to perform matrix-vector product of length length
    ! (type r4)
    integer, intent(in)   :: length, loops
    real(r4)                  :: sgemm_test
    real(r8) :: t0, t1
    integer :: i
    
    ! Private
    real(r4), parameter :: startv=-1.0, endv = 1.0
    real(r4), dimension(:,:), pointer   :: m1, m2
    real(r4), dimension(:,:), pointer :: m
    real(r4) :: v1sq, v2sq, v1dotv2, v2dotv1
    
    allocate(m1(length, length), m2(length, length), m(length, length))
    do i=1, length
      call fill_svector(m(:,i), startv, endv)
      call fill_svector(m1(:,i), startv, endv)
      call fill_svector(m2(:,i), startv, endv)
    enddo
    call time_now(t0)
    do i=1, loops
!    call sgemm('n', 'n', length, length, length, 1.0, m1, length, m2, length, &
!      & 1.0, m, length)
    call gemm('n', 'n', length, length, length, 1.0, m1, length, m2, length, &
      & 1.0, m, length)
    enddo
    call time_now(t1)
    sgemm_test = t1 - t0
    deallocate(m1, m2, m)
  end function sgemm_test

!==================
END PROGRAM blastest
!==================

!# $Log: wait_test.f90,v $
!#
@
