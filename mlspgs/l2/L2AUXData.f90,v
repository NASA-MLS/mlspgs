head	2.105;
access;
symbols
	v5-02-NRT-19:2.105
	v6-00:2.105
	v5-02-NRT-18:2.105
	v5-02:2.105
	v5-01-NRT-17:2.105
	v5-01-NRT-16:2.105
	v5-01-NRT-15:2.105
	v5-01-NRT-14:2.105
	neuralnetworks-1-0:2.105.0.6
	cfm-single-freq-0-1:2.105.0.4
	v5-01:2.105
	v5-00:2.105
	v4-23-TA133:2.105.0.2
	mus-emls-1-70:2.104.0.2
	rel-1-0-englocks-work:2.103.0.2
	VUMLS1-00:2.100
	VPL1-00:2.100
	V4-22-NRT-08:2.98
	VAM1-00:2.97
	V4-21:2.95.0.2
	V4-13:2.95
	V4-12:2.93
	V4-11:2.92
	V4-10:2.92
	V3-43:2.84
	M4-00:2.86
	V3-41:2.84
	V3-40-PlusGM57:2.84.0.2
	V2-24-NRT-04:2.82
	V3-33:2.84
	V2-24:2.82
	V3-31:2.84
	V3-30-NRT-05:2.84
	cfm-01-00:2.84
	V3-30:2.84
	V3-20:2.84
	V3-10:2.84
	V2-23-NRT-02:2.82
	V2-23:2.82
	V2-22-NRT-01:2.82
	V2-22:2.82
	V2-21:2.80
	V2-20:2.80
	V2-11:2.80
	V2-10:2.80
	V2-00:2.80
	V1-51:2.67
	V1-50:2.67
	V1-45:2.67
	V1-44:2.66
	V1-43:2.62
	V1-32:2.61
	V1-31:2.57
	V1-30:2.57
	V1-13:2.50
	V1-12:2.50
	V1-11:2.50
	V1-10:2.46
	newfwm-feb03:2.48.0.2
	V1-04:2.22
	V1-03:2.22
	V1-02:2.22
	JointForwardModel:2.22.0.2
	V1-00:2.22
	newfwm-sep01:2.18.0.2
	V0-7:2.18
	V0-5-Level2:2.14
	V0-5-SIPS:2.11;
locks; strict;
comment	@# @;


2.105
date	2019.01.31.19.50.55;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2018.04.19.01.14.16;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2017.10.20.20.05.07;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2017.10.11.23.55.55;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2017.08.10.22.46.13;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2016.08.26.00.17.52;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2016.07.28.01.45.07;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2016.05.19.23.19.02;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2015.08.03.21.43.03;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2015.03.28.02.47.33;	author vsnyder;	state Exp;
branches;
next	2.95;

2.95
date	2014.09.05.01.03.35;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2014.09.05.00.49.06;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2014.07.18.23.17.11;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2014.04.07.18.06.58;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2014.03.31.23.43.29;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2013.08.31.02.29.12;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2013.07.19.01.24.29;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2013.07.18.01.10.57;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2012.01.25.01.16.41;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2011.07.07.00.39.15;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2007.10.24.00.15.53;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2007.08.13.17.39.42;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2007.06.21.00.54.08;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2006.05.19.22.49.15;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2006.01.26.00.34.50;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2005.12.21.18.45.29;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2005.12.14.01.45.21;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2005.10.11.17.39.58;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2005.09.21.23.17.34;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2005.08.25.20.21.41;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2005.08.19.23.27.02;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2005.08.05.20.38.31;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2005.07.06.00.29.26;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2005.06.22.18.57.01;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2005.06.14.20.41.02;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2005.03.03.02.10.51;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2004.08.19.00.19.28;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2004.08.17.17.09.45;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2004.08.16.23.43.22;	author livesey;	state Exp;
branches;
next	2.64;

2.64
date	2004.08.04.23.19.57;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2004.06.29.18.05.26;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2004.04.16.00.48.13;	author livesey;	state Exp;
branches;
next	2.61;

2.61
date	2004.03.08.22.33.29;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2004.02.26.22.05.06;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2004.02.05.23.36.41;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2004.01.27.21.38.09;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2003.09.03.05.25.49;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2003.07.15.23.39.47;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2003.05.30.00.10.02;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2003.05.30.00.08.54;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2003.05.29.16.43.02;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2003.05.12.02.06.32;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2003.04.25.19.55.09;	author livesey;	state Exp;
branches;
next	2.50;

2.50
date	2003.03.07.00.42.13;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2003.02.21.23.42.21;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2003.02.12.21.52.34;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2003.02.07.21.44.56;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2003.01.30.01.02.28;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2003.01.18.02.37.03;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2003.01.17.23.11.26;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2003.01.14.00.41.43;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2002.12.10.00.41.28;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2002.12.07.00.25.42;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2002.12.06.01.06.13;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2002.12.05.19.46.23;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2002.12.03.18.04.02;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2002.12.02.23.42.12;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2002.12.02.19.11.13;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2002.11.29.22.46.28;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2002.11.29.18.50.07;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2002.11.26.22.16.41;	author jonathan;	state Exp;
branches;
next	2.32;

2.32
date	2002.11.25.18.04.52;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2002.11.22.21.48.02;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2002.11.13.01.09.47;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2002.11.08.23.14.41;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2002.11.08.18.25.33;	author jonathan;	state Exp;
branches;
next	2.27;

2.27
date	2002.11.06.02.01.06;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2002.11.06.00.18.37;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2002.10.08.17.36.21;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2002.08.21.01.04.53;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2002.08.15.21.47.04;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2001.11.01.21.03.59;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2001.10.26.23.13.18;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2001.10.08.23.41.27;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2001.10.05.23.32.27;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2001.08.06.18.35.24;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2001.07.11.20.50.46;	author dwu;	state Exp;
branches;
next	2.16;

2.16
date	2001.05.30.23.53.31;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.05.12.00.18.40;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.05.03.20.32.19;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.05.02.22.24.20;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.12.22.19.33;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.10.22.27.47;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.07.00.14.27;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.15.18.42.29;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.08.02.20.12;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.06.22.40.47;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.02.14.23.41.33;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.01.03.00.46.19;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2000.12.04.23.34.38;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.12.04.21.48.29;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2000.12.02.01.12.00;	author pwagner;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.02;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.02.02.05.04;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.105
log
@Removed unused stuff
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module L2AUXData                 ! Data types for storing L2AUX data internally

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, &
    & Test_Allocate, Test_Deallocate
  use Dump_0, only: Dump
  use HDF, only: Dfacc_Create, Dfacc_Rdonly, Dfacc_Rdwr, Dfnt_Float32, &
    & Dfnt_Int32, Sfcreate, Sfdimid, Sfendacc, Sfgdinfo, Sfginfo, &
    & Sfn2index, SfrData_F90, Sfsdmname, Sfsdscale, Sfselect, SfwData_F90
  use Init_Tables_Module, only: L_Baseline, L_Channel, L_Chisqchan, &
    & L_ChisqmMAF, L_ChisqmMIF, L_Chunk, L_Cloudextinction, &
    & L_CloudinducedRadiance, L_Cloudradsensitivity, L_Cloudwater, &
    & L_Dnwt_Ajn, L_Dnwt_Axmax, L_Dnwt_Cait, L_Dnwt_Chisqminnorm, &
    & L_Dnwt_Chisqnorm, L_Dnwt_Diag, L_Dnwt_Dxdx, L_Dnwt_Dxdxl, &
    & L_Dnwt_Dxn, L_Dnwt_Dxnl, L_Dnwt_Flag, L_Dnwt_Fnmin, L_Dnwt_Fnorm, &
    & L_Dnwt_Gdx, L_Dnwt_Gfac, L_Dnwt_Gradn, L_Dnwt_Sq, L_Dnwt_Sqt, &
    & L_Effectiveopticaldepth, L_Elevoffset, L_Frequency, L_Geodangle, &
    & L_Height, L_Heightoffset, L_Intermediatefrequency, L_Iteration, &
    & L_Jacobian_Cols, L_Jacobian_Rows, L_Limbsidebandfraction, &
    & L_Lostransfunc, L_Losvel, L_Lsbfrequency, L_Maf, &
    & L_Massmeandiameterice, L_Massmeandiameterwater, L_Mif, &
    & L_Mifextinction, L_Mifextinctionv2, L_Noisebandwidth, L_None, &
    & L_NoradsperMIF, L_Numj, L_Opticaldepth, L_Orbitinclination, L_Ascdescmode, &
    & L_Phasetiming, L_Phitan, L_Pressure, L_Ptan, L_Radiance, &
    & L_Reflspill, L_Refltemp, L_Scanresidual, L_Sceci, L_Scgeocalt, &
    & L_Scveleci, L_Scvelecr, L_SingleChannelRadiance, L_Sizedistribution, &
    & L_SpaceRadiance, L_StrayRadiance, L_Surfacetype, &
    & L_Systemtemperature, L_Tngteci, L_Tngtgeocalt, L_Tngtgeodalt, &
    & L_Totalextinction, L_Usbfrequency, L_Vmr, L_Xyz
  use Intrinsic, only: L_HDF, Lit_Indices
  use Lexer_Core, only: Print_Source
  use MLSCommon, only: DefaultUndefinedValue, MLSFile_T
  use MLSKinds, only: R8, R4
  use MLSL2Options, only: Default_HDFversion_Read, Default_HDFversion_Write
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate, &
    & MLSMSG_Error, MLSMSG_Warning
  use MLSSignals_M, only: GetModuleName, Modules
  use MLSStrings, only: Lowercase
  use MLSStringLists, only: Array2List, GetStringElement, List2Array, &
    & NumStringElements, StringElement
  use Output_M, only: Output
  use QuantityTemplates, only: QuantityTemplate_T
  use String_Table, only: Get_String, Display_String

  implicit none

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (data types and parameters)
! L2AUX_Dimension_T               Dimension for an L2AUX quantity
! L2AUXData_T                     An L2AUX quantity
! L2AUXRANK                       Rank (num of dims) of L2AUXData_T%values

!     (subroutines and functions)
! AddL2AUXToDatabase              Adds an l2aux data type to a database of that type
! cpL2AUXData                     Copies an l2aux quantity from file1 to file2
! DestroyL2AUXContents            Deallocates all the arrays for one l2aux
! DestroyL2AUXDatabase            Deallocates all the arrays for entire database
! Dump                            Prints info on one quantity or entire database
! ResizeL2AUXData                 Expands an l2aux quantity to take more profiles
! ReadL2AUXData                   Reads an l2aux quantity from a file
! SetupNewL2AUXRecord             Allocates the arrays for an l2aux quantity
! WriteHDF5Data                   Writes a named array to a file as an hdf dataset
! WriteL2AUXData                  Writes an l2aux quantity to a file
! WriteL2AUXAttributes            Writes l2aux sttributes to a file
! === (end of toc) ===

! === (start of api) ===
! int L2AUXRANK
!     (user-defined types)
! L2AUX_Dimension_T  ( int NoValues, int DIMENSIONFAMILY, *r8 values(:) )
! L2AUXData_T  ( int name, int INSTRUMENTMODULE,
!     log minorframe, log majorframe, L2AUX_Dimension_T dimensions(:),
!     *r8 values(:,:,:) )

!     (subroutines and functions)
! SetupNewL2AUXRecord ( int dimensionFamilies(L2AUXRANK), 
!    int dimSizes(L2AUXRANK), int dimStarts(L2AUXRANK), L2AUXData_T l2aux )
! CpL2AUXData ( MLSFile_t L2AUXFile1,  MLSFile_t L2AUXFile1, &
!    [log create], [char* sdList], [char* rename], [char* options] )
! DestroyL2AUXContents ( L2AUXData_T l2aux )
! ResizeL2AUXData ( L2AUXData_T l2aux, int newSize )
! int AddL2AUXToDatabase ( *L2AUXData_T DATABASE(:), L2AUXData_T ITEM )
! DestroyL2AUXDatabase ( *L2AUXData_T DATABASE(:) )
! Dump ( l2auxData_T L2aux(:), [char* Name], [int Details], [char* options] )
!    or Dump ( l2auxData_T L2aux, [int Details], [char* options] )
! ReadL2AUXData ( int sd_id, char* quantityname, l2auxData_T l2aux, 
!    [int firstProf], [int lastProf] )
! WriteHDF5Data ( real(r8) array(:,:,:), int l2FileHandle, int returnStatus, 
!    char* sdName )
! WriteL2AUXData ( l2auxData_T l2aux, int l2FileHandle, int returnStatus, 
!    [char* sdName], [int NoMAFS], [log WriteCounterMAF], [char* DimNames] )
! === (end of api) ===

  private
  public :: L2AUX_Dimension_T, L2AUXData_T, L2AUXRANK
  public :: AddL2AUXToDatabase, cpL2AUXData, DestroyL2AUXDatabase, Dump
  public :: SetupNewL2AUXRecord, DestroyL2AUXContents, ResizeL2AUXData
  public :: ReadL2AUXData, WriteHDF5Data, WriteL2AUXData, WriteL2AUXAttributes

  interface cpL2AUXData
    module procedure cpL2AUXData_Name
    module procedure cpL2AUXData_MLSFile
  end interface

  interface Dump
    module procedure Dump_L2AUX
    module procedure Dump_L2AUX_Database
  end interface

  interface ReadL2AUXData
    module procedure ReadL2AUXData_FileHandle
    module procedure ReadL2AUXData_MLSFile
  end interface

  interface WriteHDF5Data
    module procedure WriteHDF5Data_2d
    module procedure WriteHDF5Data_3d
  end interface

  interface WriteL2AUXData
    module procedure WriteL2AUXData_FileHandle
    module procedure WriteL2AUXData_MLSFile
  end interface

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L2AUXData.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! This module defines datatypes and gives basic routines for storing and
  ! manipulating L2AUX data.
  ! L2AUX data is a rank three array, with the first index being a channel like
  ! index, the second a height like index, and the last an instance index.  It
  ! is directly conformable to a vector quantity.
  ! If a dimension is absent, it is flagged appropriately but the array is still
  ! rank 3.  However, when an HDF file is written or read missing dimensions
  ! are swallowed.

  ! For Announce_Error
    integer :: ERROR

  real, parameter    :: UNDEFINED_VALUE = DEFAULTUNDEFINEDVALUE ! -999.99 
  integer, parameter :: L2AUXRANK=3     ! Dimensionality of L2AUXData_T%values
  logical, parameter :: DEEBUG = .false.
  ! Write phase and section names as file-level attributes? (only for hdf5)
  logical, public, save :: PHASENAMEATTRIBUTES = .true.

  ! This datatype describes a dimension for an L2AUX quantity
  type L2AUX_Dimension_T
     integer :: NOVALUES = 0    ! Length of this dimension
     integer :: DIMENSIONFAMILY ! What is this dimension
     real(r8), dimension(:), pointer :: VALUES=>NULL() ! (noValues)
  end type L2AUX_Dimension_T

  ! This datatype describes an l2aux quantity itself.
  ! The dimensions will typically be ordered as follows:
  ! [Channel or frequency], MIF, [MAF or time or geodAngle]

  type L2AUXData_T
    integer :: NAME                     ! String index of name to be output
    integer :: INSTRUMENTMODULE = 0     ! From source vector
    integer :: QUANTITYTYPE = 0         ! From source vector
    logical :: MINORFRAME               ! Is this a minor frame quantity
    logical :: MAJORFRAME               ! Is this a major frame quantity
    ! type (QuantityTemplate_T) :: TEMPLATE = 0 ! Template for this l2aux quantity.
    ! The dimensions for the quantity
    type (L2AUX_Dimension_T), dimension(L2AUXRank) :: DIMENSIONS
    character(len=48)                              :: DIM_Names ! ','-separated
    character(len=48)                              :: DIM_Units ! ','-separated
    ! The values of the quantity
    real(r8), pointer, dimension(:,:,:)            :: VALUES=>NULL()
    character(len=24)                              :: VALUE_Units
  end type L2AUXData_T

  ! How long may the list of sd names grow (~80 x max num. of sds/file)
  integer, public, parameter :: MAXNUMSDPERFILE = 500
  integer, public, parameter :: MAXSDNAMESBUFSIZE = 80*MAXNUMSDPERFILE
  
  ! One quantity is recognized, but not copied, the other uncrecognized
  integer, private, parameter :: UNRECOGNIZEDQUANTITYTYPE = -999
  integer, private, parameter :: RECOGNIZEDBUTNOTCOPIEDQT = UNRECOGNIZEDQUANTITYTYPE + 1

contains ! =====     Public Procedures     =============================

  ! ------------------------------------------------- cpL2AUXData_MLSFile  -----

  subroutine cpL2AUXData_MLSFile( L2AUXFile1, L2AUXFile2, &
    & create2, sdList, rename, options )
    use Dump_1, only: Dump
    use MLSFiles, only: AreTheSameFile
    use MLSHDF5, only: GetAllHDF5DSNames
    !-------------------------------------------------------------------

    ! Given file names file1 and file2,
    ! This routine copies all the l2auxdata from 1 to 2
    ! If file2 doesn't exist yet, or if create2 is TRUE, it'll create it

    ! Arguments

    type(MLSFile_T), pointer      :: L2AUXfile1 ! file 1
    type(MLSFile_T), pointer      :: L2AUXfile2 ! file 2
    logical, optional, intent(in) :: create2 ! Force creation of new file2
    character (len=*), optional, intent(in) :: sdList ! Copy only these, unless
    character (len=*), optional, intent(in) :: rename
    character (len=*), optional, intent(in) :: options ! E.g., '-v'

    ! Local
    logical :: allSDs
    logical, parameter            :: countEmpty = .true.
    integer :: i
    type (L2AUXData_T) :: l2aux
    logical :: myCreate2
    character (len=8) :: myOptions
    character (len=MAXSDNAMESBUFSIZE) :: mySdList
    integer :: noSds
    integer :: originalAccess
    integer :: QuantityType
    logical :: renameSwaths
    character (len=80) :: sdName
    integer :: status
    logical :: verbose

    myOptions = ' '
    if ( present(options) ) myOptions = options
    verbose = ( index(myOptions, 'v') > 0 )
    renameSwaths  = present(rename)
    if ( renameSwaths ) renameSwaths = ( rename /= ' ' )
    myCreate2 = .false.
    if ( present(create2) ) myCreate2 = create2
    originalAccess = L2AUXFile2%access
    if ( myCreate2 ) L2AUXFile2%access = DFACC_CREATE
    allSDs = .not. present(sdList)
    if ( present(sdList) ) allSDs = (sdList == '*')
    if ( .not. allSDs ) then
      mysdList = sdList
      if ( verbose ) call dump(mysdList, 'DS names')
    else
      call GetAllHDF5DSNames (trim(L2AUXFile1%Name), '/', mysdList)
      if ( verbose ) call output ( '============ DS names in ', advance='no' )
      if ( verbose ) call output ( trim(L2AUXfile1%Name) //' ============', &
        & advance='yes' )
      if ( mysdList == ' ' ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'No way yet to find sdList ', MLSFile=L2AUXFile1 )
        return
      else
        if ( verbose ) call dump(mysdList, 'DS names')
      end if
    end if

    if ( AreTheSameFile( L2AUXfile1, L2AUXfile2 ) ) &
      & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // ' cpL2AUXData', &
      & 'input and output files are the same', MLSFile=L2AUXFile1 )
    noSds = NumStringElements(trim(mysdList), countEmpty)
    if ( noSds < 1 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'No sdNames cp to file--unable to count sdNames in ' // trim(mysdList) )
    end if
    ! Loop over sdNames in file 1
    do i = 1, noSds
      call GetStringElement (trim(mysdList), sdName, i, countEmpty )
        QuantityType = GetQuantityTypeFromName(trim(sdName)) ! l_radiance
      if ( QuantityType == RECOGNIZEDBUTNOTCOPIEDQT ) then
        cycle
      elseif ( QuantityType < 1 ) then
        call output('Quantity type: ', advance='no')
        call output(QuantityType, advance='yes')
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Unrecognized quantity type for sd:' // trim(sdName) )
        cycle
      end if
      call ReadL2AUXData ( L2AUXFile1, trim(sdName), l2aux, QuantityType, &
           & checkDimNames=.false. )
      ! Write the filled l2aux to file2
      ! print *, 'writing ', trim(sdName)
      if ( renameSwaths ) sdName = StringElement ( rename, i, countEmpty )
      call WriteL2AUXData( l2aux, L2AUXFile2, status, trim(sdName) )
      ! Deallocate memory used by the l2aux
      call DestroyL2AUXContents ( l2aux )
      L2AUXFile2%access = originalAccess
    end do
  end subroutine cpL2AUXData_MLSFile

  ! ------------------------------------------------- cpL2AUXData_Name  -----

  subroutine cpL2AUXData_Name(file1, file2, create2, hdfVersion, sdList, rename, &
    & options)
    use Dump_1, only: Dump
    use HDF, only: Dfacc_Read, Dfacc_Rdwr
    use HDF5, only: H5gclose_F, H5gopen_F, H5dopen_F, H5dclose_F
    use MLSFiles, only: FileNotFound, WildCardHDFVersion, &
      & MLS_Exists, MLS_HDF_Version, MLS_Sfstart, MLS_Sfend
    use MLSHDF5, only: GetAllHDF5DSNames, GetHDF5Attribute, &
      & IsHDF5AttributePresent
    !-------------------------------------------------------------------

    ! Given file names file1 and file2,
    ! This routine copies all the l2auxdata from 1 to 2
    ! If file2 doesn't exist yet, or if create2 is TRUE, it'll create it

    ! Arguments

    character (len=*), intent(in) :: file1 ! Name of file 1
    character (len=*), intent(in) :: file2 ! Name of file 2
    logical, optional, intent(in) :: create2 ! Force creation of new file2
    integer, optional, intent(in) :: hdfVersion       !                      '*'
    character (len=*), optional, intent(in) :: sdList ! Copy only these, unless
    character (len=*), optional, intent(in) :: rename
    character (len=*), optional, intent(in) :: options ! E.g., '-v'

    ! Local
    logical :: allSDs
    logical, parameter            :: countEmpty = .true.
    logical :: file_exists
    integer :: file_access
    integer :: grpid
    integer :: i
    type (L2AUXData_T) :: l2aux
    character (len=8) :: myOptions
    character (len=MAXSDNAMESBUFSIZE) :: mySdList
    integer :: noSds
    integer :: QuantityType
    logical :: renameSwaths
    integer :: sd_id
    integer :: sdfid1
    integer :: sdfid2
    character (len=80) :: sdName
    integer :: status
    integer :: the_hdfVersion
    logical :: verbose
    
    ! Executable code
    the_hdfVersion = DEFAULT_HDFVERSION_WRITE
    if ( present(hdfVersion) ) the_hdfVersion = hdfVersion
    myOptions = ' '
    if ( present(options) ) myOptions = options
    verbose = ( index(myOptions, 'v') > 0 )
    renameSwaths  = present(rename)
    if ( renameSwaths ) renameSwaths = ( rename /= ' ' )
    file_exists = ( mls_exists(trim(File1)) == 0 )
    if ( .not. file_exists ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File 1 not found; make sure the name and path are correct' &
        & // trim(file1) )
    end if
    if ( the_hdfVersion == WILDCARDHDFVERSION ) then
      the_hdfVersion = mls_hdf_version(File1, hdfVersion)
      if ( the_hdfVersion == FILENOTFOUND ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'File 1 not found; make sure the name and path are correct' &
          & // trim(file1) )
    end if
    allSDs = .not. present(sdList)
    if ( present(sdList) ) allSDs = (sdList == '*')
    if ( .not. allSDs ) then
      mysdList = sdList
      if ( verbose ) call dump(mysdList, 'DS names')
    else
      call GetAllHDF5DSNames (trim(File1), '/', mysdList)
      if ( verbose ) call output ( '============ DS names in ', advance='no' )
      if ( verbose ) call output ( trim(file1) //' ============', advance='yes' )
      if ( mysdList == ' ' ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'No way yet to find sdList in ' // trim(File1) )
        return
      else
        if ( verbose ) call dump(mysdList, 'DS names')
      end if
    end if

    file_exists = ( mls_exists(trim(File2)) == 0 )
    if ( file_exists ) then
      file_access = DFACC_RDWR
    else
      file_access = DFACC_CREATE
    end if
    if ( present(create2) ) then
      if ( create2 ) file_access = DFACC_CREATE
    end if
    sdfid1 = mls_sfstart(File1, DFACC_READ, hdfVersion=hdfVersion)
    if (sdfid1 == -1 ) then
      call announce_error ( 0, 'Failed to open l2aux ' // &
      &  trim(File1) )
    end if
      call h5gOpen_f (sdfid1,'/', grpID, status)
    if ( status /= 0 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
           & 'Unable to open group to read attribute in l2aux file' )
    end if
    sdfId2 = mls_sfstart(trim(file2), file_access, &
              & hdfVersion=hdfVersion)
    if (sdfid2 == -1 ) then
      call announce_error ( 0, 'Failed to open l2aux ' // &
      &  trim(File2) )
    end if
    noSds = NumStringElements(trim(mysdList), countEmpty)
    if ( noSds < 1 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'No sdNames cp to file--unable to count sdNames in ' // trim(mysdList) )
    end if
    ! Loop over sdNames in file 1
    do i = 1, noSds
      call GetStringElement (trim(mysdList), sdName, i, countEmpty )
      ! Allocate and fill l2aux
      call h5dOpen_f (grpid,trim(sdName), sd_ID, status)
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Unable to open sd to read attribute in l2aux file' )
      end if
      ! Get QuantityType attribute--unfortunately they're all 0; what gives?
      if ( .not. IsHDF5AttributePresent(sd_id, 'QuantityType') .or. .true.) then
        QuantityType = GetQuantityTypeFromName(trim(sdName)) ! l_radiance
      else
        call GetHDF5Attribute ( sd_id, 'QuantityType', QuantityType )
      end if
      call h5dClose_f (sd_ID, status)
      if ( status /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Unable to close sd to read attribute in l2aux file' )
      end if
      if ( QuantityType < 1 ) then
        call output('Quantity type: ', advance='no')
        call output(QuantityType, advance='yes')
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Unrecognized quantity type for sd:' // trim(sdName) )
        cycle
      end if
      call ReadL2AUXData ( sdfid1, trim(sdName), l2aux, QuantityType, &
           & checkDimNames=.false., hdfVersion=hdfVersion )
      if ( renameSwaths ) sdName = StringElement ( rename, i, countEmpty )
      ! Write the filled l2aux to file2
      call WriteL2AUXData(l2aux, sdfid2, status, trim(sdName), &
        & hdfVersion=hdfVersion)
      ! Deallocate memory used by the l2aux
      call DestroyL2AUXContents ( l2aux )
    end do
    call h5gClose_f (grpID, status)
    if ( status /= 0 ) then
    call MLSMessage ( MLSMSG_Warning, ModuleName, &
       & 'Unable to close group in l2aux file: ' // trim(File1) // ' after cping' )
    end if
    status = mls_sfend(sdfid1, hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2aux file: " // trim(File1) // ' after cping')
    status = mls_sfend(sdfid2, hdfVersion=the_hdfVersion)
    if ( status /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2aux file: " // trim(File2) // ' after cping')
  end subroutine cpL2AUXData_Name

  ! ---------------------------------------  SetupNewL2AUXRecord   -----
  !   (option 1)
  ! subroutine SetupNewL2AUXRecord ( l2aux, &
  !  & quantityTemplate, firstMAF, noMAFs )
  !   (option 2)
  ! subroutine SetupNewL2AUXRecord ( l2aux, dimFamilies, dimSizes, dimStarts, &
  !  & quantityType )
  subroutine SetupNewL2AUXRecord ( l2aux, &
   & quantityTemplate, firstMAF, noMAFs, &
   & inputDimFamilies, inputDimSizes, inputDimStarts, inputQuantityType )

    ! This first routine sets up the arrays for an l2aux datatype.
    ! (Option 1)
    ! The user supplies a Quantity template, 1st MAF and number of MAFs
    ! Then we deduce the dimension families and their sizes
    ! (Option 2)
    ! The user supplies a set of three dimensionFamilies (e.g. l_maf)
    ! and their sizes and starts
    ! Quantities can have up to three valid dimensions.  l_none can be used
    ! to indicate later dimensions are invalid.

    ! Dummy arguments
    type (L2AUXData_T), intent(out)       :: l2aux
    !    ( option 1 )
    type (QuantityTemplate_T), intent(in), optional :: quantityTemplate
    integer, intent(in), optional                   :: firstMAF
    integer, intent(in), optional                   :: noMAFs
    !    ( option 2 )
    integer, dimension(L2AUXRank), optional, intent(in) :: &
                                                    & inputDimFamilies
    integer, dimension(L2AUXRank), optional, intent(in) :: inputDimSizes
    integer, dimension(L2AUXRank), optional, intent(in) :: inputDimStarts
    integer, optional, intent(in) :: inputQuantityType
    ! Local variables
    integer, dimension(L2AUXRank) :: dimSizes
    integer, dimension(L2AUXRank) :: dimStarts
    integer             :: quantityType
    integer :: dimIndex
    integer :: status
    integer, dimension(L2AUXRank)   :: dimEnds
    integer, dimension(3        )   :: dim_names
    character(len=16), dimension(3) :: extra_name
    character(len=16)               :: framing
    ! integer                         :: option_number   ! (1 or 2; see above)

    ! Executable
    if ( present(quantityTemplate) ) then
      ! option_number = 1
      quantityType = quantityTemplate%quantityType
    else if ( present(inputQuantityType) ) then
      ! option_number = 1
      quantityType = inputQuantityType
      dimSizes = inputDimSizes
      dimStarts = inputdimStarts
    else
      call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'args to SetupL2AUXData incompatible with options 1 or 2')
    end if
    ! Fill the dimensions data structure
    call GetQuantityAttributes( quantityType, &
       & framing, l2aux%VALUE_Units, dim_names )
    l2aux%dimensions%dimensionFamily = dim_names
    ! end if
    l2aux%minorFrame = (framing == 'minor')
    l2aux%majorFrame = (framing == 'major')
    ! Name the dimensions (e.g. 'frequency')
    do dimIndex=1, L2AUXRank
      call GetDimString( l2aux%dimensions(dimIndex)%dimensionFamily, &
        & extra_name(dimIndex) )
      if ( present (firstMAF) ) then
        call GetDimStart( l2aux%dimensions(dimIndex)%dimensionFamily, &
        & quantityTemplate, firstMAF, dimStarts(dimIndex) )
      end if
      if ( present (noMAFs) ) then
        call GetDimSize( l2aux%dimensions(dimIndex)%dimensionFamily, &
        & quantityTemplate, noMAFs, dimSizes(dimIndex) )
      end if
    end do
    call Array2List(extra_name, l2aux%DIM_Names)
    ! Name the dimensions' units (e.g. 'K')
    do dimIndex=1, L2AUXRank
      call GetQuantityAttributes( l2aux%dimensions(dimIndex)%dimensionFamily, &
       & units_name=extra_name(dimIndex) )
    end do
    call Array2List(extra_name, l2aux%DIM_Units)
    l2aux%dimensions%noValues = dimSizes

    dimEnds = dimStarts + max(1,dimSizes) - 1

    ! Allocate the values for each dimension
    do dimIndex = 1, L2AUXRank
      if ( l2aux%dimensions(dimIndex)%dimensionFamily /= L_None ) then
        allocate (l2aux%dimensions(dimIndex)%values( &
          & dimStarts(dimIndex):dimEnds(dimIndex)), &
          & STAT=status)
        if ( status/=0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate // "l2aux dimension values" )
        if ( present (quantityTemplate) ) then
          call GetDimValues( l2aux%dimensions(dimIndex)%dimensionFamily, &
          & quantityTemplate, l2aux%dimensions(dimIndex)%values )
        end if
      else
        l2aux%dimensions(dimIndex)%noValues=1
      end if
    end do

    ! Allocate the values for the data itself

    nullify ( l2aux%values )
    call allocate_test( l2aux% values, &
      & dimEnds(1), &
      & dimEnds(2), &
      & dimEnds(3), &
      & 'l2aux%values', ModuleName, &
      & dimStarts(1), &
      & dimStarts(2), &
      & dimStarts(3) &
      )
  end subroutine SetupNewL2AUXRecord
    
  !----------------------------------------  DestroyL2AUXContents  -----
  subroutine DestroyL2AUXContents ( l2aux )

  ! This routine deallocates all the arrays allocated above.

    ! Dummy arguments
    type (L2AUXData_T), intent(inout) :: l2aux
    ! Local variables
    integer :: dim
    ! Executable code
    
    do dim=1,L2AUXRank
      if (l2aux%dimensions(dim)%dimensionFamily /= L_None) &
        call deallocate_test(l2aux%dimensions(dim)%values, &
        "l2aux%dimensions", ModuleName)
    end do
    call deallocate_test(l2aux%values,"l2aux%values",ModuleName ) 
  end subroutine DestroyL2AUXContents

  !--------------------------------------  ResizeL2AUXData  -----
  subroutine ResizeL2AUXData ( l2aux, newSize )

  ! This subroutine resizes an L2AUXData_T in place, allowing the user to
  ! add more `profiles' to it.  Note that the `profile' dimension is the last
  ! one.
  
  ! New feature: if newSize is < old size
  ! we effectively contract the l2AUXData_T

    ! Dummy arguments
    type (L2AUXData_T), intent(inout) :: L2aux
    integer, intent(in) :: NewSize

    ! Local variables
    integer :: OldSize
    ! The following are temporary arrays for copying data around
    real (r8), dimension(:), pointer :: Temp1D
    real (r8), dimension(:,:,:), pointer :: Temp3D

    ! Executable code

    nullify ( temp1D, temp3D )

    if ( l2aux%dimensions(3)%dimensionFamily == L_None ) &
      call MLSMessage (MLSMSG_Error, ModuleName, &
        & "This l2aux is not expandable") ! Why not?

    ! Now see how long this is
    oldSize = l2aux%dimensions(3)%noValues
    ! Do a usage check
    if ( newSize < oldSize ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & "This l2aux is getting smaller not bigger" )

    ! Now expand this dimension
    temp1D => l2aux%dimensions(3)%values
    ! Nullify old one so allocate_test doesn't clobber temp1D
    nullify ( l2aux%dimensions(3)%values )
    call allocate_test(l2aux%dimensions(3)%values,newSize, &
      & 'New l2aux%dimensions(3)%values', ModuleName)
    l2aux%dimensions(3)%noValues = newSize
    if ( oldSize < newSize ) then
      l2aux%dimensions(3)%values(1:oldSize) = temp1D
    else
      l2aux%dimensions(3)%values = temp1D(1:newSize)
    end if
    ! Now we can loose the old values
    call deallocate_test ( temp1D, "temp1D", ModuleName )

    ! Now expand the data in this dimension, save old field
    temp3d => l2aux%values
    ! Need to nullify old one, else next call will clobber it
    ! loosing us temp3d
    nullify ( l2aux%values )
    call allocate_test ( l2aux%values, &
      & max(1, l2aux%dimensions(1)%noValues), &
      & max(1, l2aux%dimensions(2)%noValues), &
      & newSize, "l2aux%values", ModuleName )
    if ( oldSize < newSize ) then
      l2aux%values(:,:,1:oldSize) = temp3d
    else
      l2aux%values = temp3d(:,:,1:newSize)
    end if

    ! Now we can set temp3d loose
    call deallocate_test ( temp3d, "temp3d", ModuleName )

  end subroutine ResizeL2AUXData

  !------------------------------------------  AddL2AUXToDatabase  -----
  integer function AddL2AUXToDatabase ( DATABASE, ITEM )

  ! This subroutine adds an l2aux data type to a database of said types,
  ! creating a new database if it doesn't exist.  The result value is
  ! the length of the database -- where L2aux is put.

    ! Dummy arguments
    type (L2AUXData_T), dimension(:), pointer :: DATABASE
    type (L2AUXData_T), intent(in) :: ITEM

    ! local variables
    type (L2AUXData_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddL2AUXToDatabase = newSize
  end function AddL2AUXToDatabase

  ! ---------------------------------------  DestroyL2AUXDatabase  -----
  subroutine DestroyL2AUXDatabase ( DATABASE )

  ! This subroutine destroys the l2aux database

    use Toggles, only: Gen, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

    ! Dummy argument
    type (L2AUXData_T), dimension(:), pointer :: DATABASE

    ! Local variables
    integer :: l2auxIndex, status
    integer :: Me = -1       ! String index for trace

    call trace_begin ( me, "DestroyL2AUXDatabase", cond=toggle(gen) )

    if ( associated(database) ) then
      do l2auxIndex = 1, size(database)
        call DestroyL2AUXContents ( database(l2auxIndex) )
      end do
      deallocate ( database, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning,ModuleName, &
        & MLSMSG_DeAllocate // "database")
    end if
    call trace_end ( "DestroyL2AUXDatabase", cond=toggle(gen) )
  end subroutine DestroyL2AUXDatabase

  ! ----------------------------------------  Dump_L2AUX_DataBase  -----

  subroutine Dump_L2AUX_DataBase ( L2aux, Name, Details, Options )
    use HighOutput, only: StyledOutput

    ! Dummy arguments
    type (l2auxData_T), intent(in) ::          L2AUX(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: DETAILS
    character(len=*), intent(in), optional :: options

    ! Local variables
    integer :: i
    
    call output ( '============ L2AUX Data Base ============', advance='yes' )
    call output ( ' ', advance='yes' )
    if ( present(name) ) then
      call StyledOutput ( name, options )
    end if
    if ( size(l2aux) < 1 ) then
      call output ( '**** L2AUX Database empty ****', advance='yes' )
      return
    end if
    do i = 1, size(l2aux)
      call dump( l2aux(i), Details, options )
    end do
      
  end subroutine Dump_L2AUX_DATABASE

  ! -------------------------------------------------  Dump_L2AUX  -----

  subroutine Dump_L2AUX ( L2aux, Details, Options )

    ! Dummy arguments
    type (l2auxData_T), intent(in) ::          L2AUX
    integer, intent(in), optional :: DETAILS ! <=0 => Don't dump multidim arrays
    !                                        ! -1 Skip even 1-d arrays
    !                                        ! -2 Skip all but name
    !                                        ! >0 Dump even multi-dim arrays
    !                                        ! Default 1
    character(len=*), intent(in), optional :: options

    ! Local variables
    integer :: dim, ierr
    integer :: MYDETAILS

    ! Executable code
    myDetails = 1
    if ( present(details) ) myDetails = details
    
    call output ( 'L2AUX Data: ')
    call display_string ( l2aux%name, ierr=ierr )
    if ( ierr /= 0 ) call output ( '(not found in string table)')
    if ( myDetails < -1 ) return
    if ( associated(modules) ) then
      call output ( '    instrumentmodule: ')
      call display_string ( modules(l2aux%instrumentmodule)%name, &
        & advance='no', ierr=ierr ) 
      if ( ierr /= 0 ) then
        call output ( ' (not found in string table)', advance='no')
      else
        call output ( l2aux%instrumentmodule, before=' = ', advance='no')
      end if
    end if
    call output ( '', advance='yes')
    call output ( '  Minor Frame? (t/f): ')
    call output ( l2aux%minorframe, advance='no')
    call output ( '  Major Frame? (t/f): ')
    call output ( l2aux%majorframe, advance='yes')
    if ( myDetails < 0 ) return
    do dim=1, l2auxrank
      call output ( '  dimension: ')
      call output ( dim )
      call output ( '           ')
      if ( associated(l2aux%dimensions(dim)%values) ) then
        call output ( '  nValues: ')
        call output ( l2aux%dimensions(dim)%novalues, 3, advance='no')
        call output ( '           ')
        call output ( '  dimension family: ')
        call output ( l2aux%dimensions(dim)%dimensionfamily, 3, advance='yes')
        call dump ( l2aux%dimensions(dim)%values, &
          & 'dim values:', options=options )
       else
        call output ( ' is not associated', advance='yes')
       end if
    end do
    if ( myDetails < 1 ) return
    call dump ( l2aux%values, 'values:', options=options )
 
  end subroutine Dump_L2AUX
    
  !-----------------------------------------------  ReadL2AUXData_FileHandle  -----
  subroutine ReadL2AUXData_FileHandle( sd_id, quantityname, l2aux, inQuantityType, &
    & firstProf, lastProf, checkDimNames, hdfVersion )

  use MLSFiles, only: InitializeMLSFile

    ! This routine reads an l2aux file, returning a filled data structure
    ! and the number of profiles read.

    ! Arguments

    character (len=*), intent(in) :: quantityname ! Name of L2AUX quantity = sdname in writing routine
    integer, intent(in) :: sd_id ! Returned by sfstart before calling us
    integer, intent(in), optional :: inQuantityType ! Lit index
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( L2AUXData_T ), intent(OUT) :: l2aux ! Result
    logical, optional, intent(in) :: checkDimNames
    integer, intent(in), optional :: hdfVersion
    ! Local variables
    integer :: myhdfVersion
    integer :: QuantityType
    type( MLSFile_T ), target  :: l2auxFile
    type( MLSFile_T ), pointer :: l2auxPointer
    integer :: status
    ! Executable code
    myhdfVersion = default_hdfversion_read
    if ( present(hdfVersion) ) myhdfVersion = hdfVersion
    if ( present(inQuantityType) ) then
      QuantityType = inQuantityType
    else
      QuantityType = GetQuantityTypeFromName(trim(quantityname))
    endif
    status = InitializeMLSFile(l2auxFile, type=l_hdf, access=DFACC_RDONLY, &
      & content='l2aux', name='unknown', hdfVersion=myhdfVersion)
    l2auxFile%FileID%f_id = sd_id
    l2auxFile%stillOpen = .true.
    l2auxPointer => l2auxFile
    if ( deebug ) print *, 'About to call ReadL2AUXData_MLSFile'
    call ReadL2AUXData( l2auxPointer, quantityname, l2aux, &
      & quantityType, firstProf, lastProf, checkDimNames )

  end subroutine ReadL2AUXData_FileHandle

  !-----------------------------------------------  ReadL2AUXData_MLSFile  -----
  subroutine ReadL2AUXData_MLSFile( L2AUXFile, quantityname, l2aux, inQuantityType, &
    & firstProf, lastProf, checkDimNames )

 use MLSFiles, only: Dump, HDFVersion_4, HDFVersion_5, &
   & MLS_CloseFile, MLS_OpenFile
 use Trace_M, only: Trace_Begin, Trace_End

    ! This routine reads an l2aux file, returning a filled data structure
    ! and the number of profiles read.

    ! Arguments

    character (len=*), intent(in) :: quantityname ! Name of L2AUX quantity = sdname in writing routine
    type(MLSFile_T), pointer      :: L2AUXFile
    integer, intent(in), optional :: inQuantityType ! Lit index
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( L2AUXData_T ), intent(OUT) :: l2aux ! Result
    logical, optional, intent(in) :: checkDimNames

    ! Local variables
    logical :: alreadyOpen
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: returnStatus
    integer :: QuantityType

    ! Executable code
    call trace_begin ( me, 'ReadL2AUXData_MLSFile', cond=.false. )
    returnStatus = 0
    if ( present(inQuantityType) ) then
      QuantityType = inQuantityType
    else
      QuantityType = GetQuantityTypeFromName(trim(quantityname))
    endif
    alreadyOpen = L2AUXFile%stillOpen
    if ( L2AUXFile%access == DFACC_CREATE ) then
      call MLSMessage(MLSMSG_Error, trim(ModuleName) // ' ReadL2AUXData_MLSFile', &
        & 'Attempt to open l2aux file for reading with create access', MLSFile=L2AUXFile)
    end if
    if ( .not. alreadyOpen ) then
      call mls_openFile(L2AUXFile, returnStatus)
      if ( returnStatus /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2aux file for reading', MLSFile=L2AUXFile)
    end if
    if ( deebug ) print *, 'Must choose to read based on ', L2AUXFile%hdfVersion
    if ( deebug ) call Dump ( L2AUXFILE )
    select case (L2AUXFile%hdfVersion)
    case (HDFVERSION_4)
      call ReadL2AUXData_MF_hdf4(L2AUXFile, quantityname, quantityType, l2aux, &
       & firstProf, lastProf, checkDimNames)
    case (HDFVERSION_5)
      call ReadL2AUXData_MF_hdf5(L2AUXFile, quantityname, quantityType, l2aux, &
        & firstProf, lastProf, checkDimNames)
    case default
    end select
    if ( .not. alreadyOpen )  call mls_closeFile(L2AUXFile, returnStatus)

    L2AUXFile%errorCode = returnStatus
    L2AUXFile%lastOperation = 'read'
    call trace_end ( 'ReadL2AUXData_MLSFile', cond=.false. )
  end subroutine ReadL2AUXData_MLSFile

  ! -----------------------------------------  ReadL2AUXData_MF_hdf4  -----
  subroutine ReadL2AUXData_MF_hdf4( L2AUXFile, quantityname, quantityType, l2aux, &
    & firstProf, lastProf, checkDimNames )

    ! This routine reads an l2aux file, returning a filled data structure and the
    ! number of profiles read.

    ! Arguments

    ! Name of L2AUX quantity = sdname in writing routine
    character (len=*), intent(in) :: quantityname 
    type(MLSFile_T), pointer      :: L2AUXFile
    integer, intent(in) :: QuantityType
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( L2AUXData_T ), intent(OUT) :: l2aux ! Result
    logical, optional, intent(in) :: checkDimNames

    ! Parameters

    integer, parameter :: MAXRANK = 3
    logical            :: myCHECKDIMNAMES ! .TRUE. only for actual l2auxfiles

    ! Variables

    character (LEN=480) :: msr

    integer :: sds_index, sds_id, rank, data_type, num_attrs, dim, dim_id
    integer :: data_dim_sizes(MAXRANK), file_dim_sizes(MAXRANK), dim_size1
    integer :: dim_families(MAXRANK)
    character (LEN=len(quantityname)) :: sds_name
    character (LEN=132) :: dim_name
    character (LEN=1)                  :: dim_char

    integer :: status
    integer :: start(3), stride(3)

    ! logical :: firstCheck, lastCheck
    real (r4), dimension(:,:,:), pointer :: TMPVALUES

    myCHECKDIMNAMES = .false.
    if ( present(checkDimNames) ) myCHECKDIMNAMES = checkDimNames
    ! Attach to the file for reading

    ! find SD data set identifier
    sds_index = sfn2index(L2AUXFile%FileID%f_id, quantityname)
    if (sds_index == -1) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Failed to get sds_index for '//trim(quantityName), MLSFile=L2AUXFile )

    sds_id = sfselect(L2AUXFile%FileID%f_id, sds_index)
    if (sds_id == -1) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Failed to get sds_id.', MLSFile=L2AUXFile )

    status = sfginfo(sds_id, sds_name, rank, file_dim_sizes, data_type, &
      & num_attrs)

    if (status == -1) then
      call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to get sf info.', MLSFile=L2AUXFile)
    else if (sds_name /= quantityname) then
      call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'quantityname  fails to match sf info.', MLSFile=L2AUXFile)
    end if

    ! Check optional input arguments

    ! firstCheck = present(firstProf)
    ! lastCheck = present(lastProf)

    ! Uncertain what to do with those just yet
    ! Now find dimension family of dimension; e.g., MAF
    dim_families = l_none
    data_dim_sizes = 1
    file_dim_sizes = 1

    do dim=1, rank
      write(dim_char, '(I1)') dim
      dim_id = sfdimid(sds_id, dim-1)  ! dim starts from 0
      if(dim_id == -1) then
        msr = 'Failed to get dim_id for dim index number ' // dim_char
        call MLSMessage(MLSMSG_Error, ModuleName, msr, MLSFile=L2AUXFile)
      else
        status = sfgdinfo(dim_id, dim_name, dim_size1, data_type, &
          & num_attrs)
        if(status == -1) then
          msr = 'Failed to get dim_info for dim index number ' // &
            & dim_char
          call MLSMessage(MLSMSG_Error, ModuleName, msr, MLSFile=L2AUXFile)
        else
          file_dim_sizes(dim) = dim_size1
          select case ( trim(dim_name) )
          case ( 'channel' )
            dim_families(1) = l_channel
            data_dim_sizes(1) = dim_size1
          case ( 'GHz.mif' )
            dim_families(2) = l_mif
            data_dim_sizes(2) = dim_size1
          case ( 'GHz.maf' )
            dim_families(3) = l_maf
            data_dim_sizes(3) = dim_size1
          case default
            if ( myCHECKDIMNAMES ) then
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unrecognized dimension in l2aux:'//trim(dim_name), MLSFile=L2AUXFile )
            else
              dim_families(dim) = l_channel
              data_dim_sizes(dim) = dim_size1
            end if
          end select
        end if
      end if
    end do

    ! Allocate result
!   call SetupNewl2auxRecord ( dim_families, data_dim_sizes, (/1,1,1/), l2aux )
    call SetupNewl2auxRecord ( l2aux, inputDimFamilies=dim_families, &
      & inputDimSizes=data_dim_sizes, inputDimStarts=(/1,1,1/), inputQuantityType=quantityType )

    ! Read the SD
    start = 0
    stride = 1
    nullify ( tmpValues )
    call Allocate_test ( tmpValues, max(file_dim_sizes(1),1), &
      & max(file_dim_sizes(2),1), max(file_dim_sizes(3),1), &
      & 'tmpValues', ModuleName )

    ! Not sure this isn't cheating with the array but we'll see
    status = sfrdata_f90(sds_id, start(1:rank), stride(1:rank), file_dim_sizes(1:rank), &
      & tmpValues )
    if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Failed to read SD.', MLSFile=L2AUXFile)
    l2aux%values = reshape ( tmpValues, &
      & (/ data_dim_sizes(1), data_dim_sizes(2), data_dim_sizes(3) /) )

    call Deallocate_test ( tmpValues, 'tmpValues', ModuleName )

    ! Deallocate local variables


    ! Terminate access to the data set

    status = sfendacc(sds_id)
    if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
      &end access to sds_id after reading.', MLSFile=L2AUXFile)

  end subroutine ReadL2AUXData_MF_hdf4


  ! -----------------------------------------  ReadL2AUXData_MF_hdf5  -----
  subroutine ReadL2AUXData_MF_hdf5( L2AUXFile, quantityname, quantityType, &
    & L2AUX, firstProf, lastProf, checkDimNames )
    use HighOutput, only: BeVerbose
    use L1BData, only: L1BData_T, ReadL1BData

    ! This routine reads an l2aux file, returning a filled data structure and the
    ! number of profiles read.
    ! Assumptions
    ! The data format is radiance-like, single- or double-precision
    ! You don't really care which names the original dimensions had
    ! You want the new dimension families to be 'channel', 'MIF', 'MAF'
    ! and in that order

    ! Arguments

    ! Name of L2AUX quantity = sdname in writing routine
    character (len=*), intent(in) :: quantityname 
    type(MLSFile_T), pointer      :: L2AUXFile
    integer, intent(in) :: QUANTITYTYPE ! Lit index
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    type( L2AUXData_T ), intent(OUT) :: l2aux ! Result
    logical, optional, intent(in) :: checkDimNames

    ! Parameters
    type(l1bdata_t)               :: L1BDATA1 ! Intermediate Result
    integer                       :: NoMAFs
    logical, parameter            :: NEVERFAIL = .TRUE.
    integer, dimension(L2AUXRank) :: dim_families
    integer, dimension(L2AUXRank) :: data_dim_sizes
    integer                       :: status
    ! Executable
    if ( BeVerbose( 'l2aux', 0 ) ) &
      & call output( 'Attempting to read ' // trim(quantityname), advance='yes' )
    CALL ReadL1BData( L2AUXFile, QuantityName, L1BDATA1, NoMAFs, status, &
      & FirstMAF=firstProf, LastMAF=lastProf, NEVERFAIL=NEVERFAIL, &
      & dontPad=.true., L2AUX=.true. )
    if ( status /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to read ' &
      & // trim(QuantityName) // ' (perhaps too unlike a radiance)', MLSFile=L2AUXFile )

    dim_families(1) = l_channel
    select case ( L1BDATA1%data_type(1:1) )
    case ( 'd' )
      data_dim_sizes = shape(L1BDATA1%DpField)
      if ( deebug ) print *, 'shape(L1BDATA1%DpField): ', shape(L1BDATA1%DpField)
      dim_families(2) = l_mif                          
      dim_families(3) = l_maf                          
      call SetupNewl2auxRecord ( l2aux, inputDimFamilies=dim_families, &
       & inputDimSizes=data_dim_sizes, inputDimStarts=(/1,1,1/), &
       & inputQuantityType=quantityType )
      l2aux%values = L1BDATA1%DpField
      deallocate( L1BDATA1%DpField, stat=status )
    case ( 'i' )
      data_dim_sizes = shape(L1BDATA1%IntField)
      if ( deebug ) print *, 'shape(L1BDATA1%IntField): ', shape(L1BDATA1%IntField)
      dim_families(2) = l_mif                          
      dim_families(3) = l_maf                          
      call SetupNewl2auxRecord ( l2aux, inputDimFamilies=dim_families, &
       & inputDimSizes=data_dim_sizes, inputDimStarts=(/1,1,1/), &
       & inputQuantityType=quantityType )
      l2aux%values = L1BDATA1%IntField
      deallocate( L1BDATA1%IntField, stat=status )
    case ( 'c' )
      data_dim_sizes = shape(L1BDATA1%CharField)
      if ( deebug ) print *, 'shape(L1BDATA1%CharField): ', shape(L1BDATA1%CharField)
      dim_families(2) = l_mif                          
      dim_families(3) = l_maf                          
      call SetupNewl2auxRecord ( l2aux, inputDimFamilies=dim_families, &
       & inputDimSizes=data_dim_sizes, inputDimStarts=(/1,1,1/), &
       & inputQuantityType=quantityType )
      l2aux%values = iachar(L1BDATA1%CharField(:,:,:)(1:1))
      deallocate( L1BDATA1%CharField, stat=status )
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to cope with type l1bdata%' // trim(L1BDATA1%data_type) // &
      &  'while reading' // &
      & trim(QuantityName), MLSFile=L2AUXFile )
    end select
    if ( status /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to deallocate l1bdata%' // trim(L1BDATA1%data_type) // &
      &  'while reading' // &
      & trim(QuantityName), MLSFile=L2AUXFile )
  end subroutine ReadL2AUXData_MF_hdf5

  ! ---------------------------------------------  WriteHDF5Data  -----

  subroutine WriteHDF5Data_2d( array, sd_id, returnStatus, sdName, &
    & already_there, start, sizes )

  use MLSFiles, only: Split_Path_Name
  use MLSHDF5, only: IsHDF5GroupPresent, MakeNestedGroups, SaveasHDF5ds

  ! Write an array to the file with l2FileHandle
  ! Optionally, write a bogus CounterMAF sd so the
  ! resulting file can masquerade as an l1BRad
  ! (Note that this bogus sd should only be written once for each file)
    real, dimension(:,:), intent(in)      :: array
    integer, intent(in)                     :: sd_id  ! From h5fopen or sfstart
    character (len=*), intent(in)           :: SDNAME ! may contain "/"
    integer, intent(out)                    :: returnStatus ! 0 unless error
    logical, intent(in), optional           :: already_there
    integer, dimension(:), intent(in), optional :: start
    integer, dimension(:), intent(in), optional :: sizes

    ! Local variables
    character(len=128)                      :: barename
    logical, parameter                      :: countEmpty = .true.
    character(len=128), dimension(25)       :: groupNames
    integer                                 :: grp_id ! Perhaps just root
    integer                                 :: n
    character(len=1024)                     :: path
    ! Executable
    grp_id = sd_id
    ! Is here a '/' in sdname?
    if ( index( sdname, '/' ) > 0 ) then
      ! Do the containing groups exist yet?
      call split_path_name ( sdname, path, bareName )
      if ( .not. IsHDF5GroupPresent( sd_id, trim(path)) ) then
        call List2Array ( path, groupnames, countEmpty, inseparator='/' )
        n = NumStringElements ( path, countEmpty, inseparator='/' )
        n = max( n, 2 )
        call MakeNestedGroups( grp_id, groupNames(1:n-1) )
      endif
    endif
    call SaveAsHDF5DS( grp_id, trim(sdName), &
      & array, start, sizes, may_add_to=.true., adding_to=already_there, &
      & fillValue=DEFAULTUNDEFINEDVALUE )
    returnStatus = 0

  end subroutine WriteHDF5Data_2d

  subroutine WriteHDF5Data_3d( array, sd_id, returnStatus, sdName, &
    & already_there, start, sizes )

  use MLSFiles, only: Split_Path_Name
  use MLSHDF5, only: IsHDF5GroupPresent, MakeNestedGroups, SaveasHDF5ds

  ! Write an array to the file with l2FileHandle
  ! Optionally, write a bogus CounterMAF sd so the
  ! resulting file can masquerade as an l1BRad
  ! (Note that this bogus sd should only be written once for each file)
    real, dimension(:,:,:), intent(in)      :: array
    integer, intent(in)                     :: sd_id  ! From h5fopen or sfstart
    character (len=*), intent(in)           :: SDNAME ! may contain "/"
    integer, intent(out)                    :: returnStatus ! 0 unless error
    logical, intent(in), optional           :: already_there
    integer, dimension(:), intent(in), optional :: start
    integer, dimension(:), intent(in), optional :: sizes

    ! Local variables
    character(len=128)                      :: barename
    logical, parameter                      :: countEmpty = .true.
    character(len=128), dimension(25)       :: groupNames
    integer                                 :: grp_id ! Perhaps just root
    integer                                 :: n
    character(len=1024)                     :: path
    ! Executable
    grp_id = sd_id
    ! Is here a '/' in sdname?
    if ( index( sdname, '/' ) > 0 ) then
      ! Do the containing groups exist yet?
      call split_path_name ( sdname, path, bareName )
      if ( .not. IsHDF5GroupPresent( sd_id, trim(path)) ) then
        call List2Array ( path, groupnames, countEmpty, inseparator='/' )
        n = NumStringElements ( path, countEmpty, inseparator='/' )
        n = max( n, 2 )
        call MakeNestedGroups( grp_id, groupNames(1:n-1) )
      endif
    endif
    call SaveAsHDF5DS( grp_id, trim(sdName), &
      & array, start, sizes, may_add_to=.true., adding_to=already_there, &
      & fillValue=DEFAULTUNDEFINEDVALUE )
    returnStatus = 0

  end subroutine WriteHDF5Data_3d

  ! ---------------------------------------------  WriteL2AUXData_FileHandle  -----

  subroutine WriteL2AUXData_FileHandle(l2aux, sd_id, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF, DimNames, Reuse_dimNames, hdfVersion)

  use MLSFiles, only: InitializeMLSFile

  ! Write l2aux to the file with l2FileHandle
  ! Optionally, write a bogus CounterMAF sd so the
  ! resulting file can masquerade as an l1BRad
  ! (Note that this bogus sd should only be written once for each file)
    type (L2AUXData_T), intent(inout) :: L2AUX
    integer, intent(in) :: sd_id                      ! From h5fopen or sfstart
    character (len=*), optional, intent(in) :: SDNAME ! Defaults to l2aux%name
    character (len=*), optional, intent(in) :: DimNames ! Comma-separated list
                                                        ! Otherwise automatic
                                                        ! (Requiring l2cf)
    integer, intent(in), optional :: NoMAFS
    logical, intent(in), optional :: WriteCounterMAF  ! Write bogus CounterMAF
    logical, intent(in), optional :: Reuse_dimNames   ! We already wrote them
    integer, intent(in), optional :: hdfVersion
    integer, intent(out) :: returnStatus           ! 0 unless error

    ! Local variables
    integer :: myhdfVersion
    type( MLSFile_T ) :: l2auxFile
    ! Executable code
    myhdfVersion = default_hdfversion_write
    if ( present(hdfVersion) ) myhdfVersion = hdfVersion
    returnStatus = InitializeMLSFile(l2auxFile, type=l_hdf, access=DFACC_RDWR, &
      & content='l2aux', name='unknown', hdfVersion=myhdfVersion)
    l2auxFile%FileID%f_id = sd_id
    l2auxFile%stillOpen = .true.
    call WriteL2AUXData(l2aux, l2auxFile, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF, DimNames, Reuse_dimNames)
  end subroutine WriteL2AUXData_FileHandle

  ! ---------------------------------------------  WriteL2AUXData_MLSFile  -----

  subroutine WriteL2AUXData_MLSFile(l2aux, L2AUXFile, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF, DimNames, Reuse_dimNames)

    use MLSFiles, only: HDFversion_4, HDFversion_5, &
      & MLS_CloseFile, MLS_OpenFile
    use Trace_M, only: Trace_Begin, Trace_End

  ! Write l2aux to the file with l2FileHandle
  ! Optionally, write a bogus CounterMAF sd so the
  ! resulting file can masquerade as an l1BRad
  ! (Note that this bogus sd should only be written once for each file)
    type (L2AUXData_T), intent(inout) :: L2AUX
    type(MLSFile_T)                :: L2AUXFile
    character (len=*), optional, intent(in) :: SDNAME ! Defaults to l2aux%name
    character (len=*), optional, intent(in) :: DimNames ! Comma-separated list
                                                        ! Otherwise automatic
                                                        ! (Requiring l2cf)
    integer, intent(in), optional :: NoMAFS
    logical, intent(in), optional :: WriteCounterMAF  ! Write bogus CounterMAF
    logical, intent(in), optional :: Reuse_dimNames   ! We already wrote them
    integer, intent(out) :: returnStatus           ! 0 unless error

    ! Local variables
    logical :: alreadyOpen
    integer :: Me = -1                  ! String index for trace cacheing

    ! Executable code
    call trace_begin ( me, 'WriteL2AUXData_MLSFile', cond=.false. )
    alreadyOpen = L2AUXFile%stillOpen
    if ( .not. alreadyOpen ) then
      call mls_openFile(L2AUXFile, returnStatus)
      if ( returnStatus /= 0 ) &
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2aux file for writing', MLSFile=L2AUXFile)
    end if
    if ( L2AUXFile%access == DFACC_RDONLY )  &
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'l2aux file is rdonly', MLSFile=L2AUXFile)
    select case (L2AUXFile%hdfVersion)
    case (HDFVERSION_4)
      call WriteL2AUXData_MF_hdf4(l2aux, L2AUXFile, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF, DimNames, Reuse_dimNames)
    case (HDFVERSION_5)
      call WriteL2AUXData_MF_hdf5( l2aux, L2AUXFile, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF )
    case default
      call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unrecognized hdfVersion for l2aux file', MLSFile=L2AUXFile)
    end select
    if ( .not. alreadyOpen )  call mls_closeFile(L2AUXFile, returnStatus)
    L2AUXFile%errorCode = returnStatus
    L2AUXFile%lastOperation = 'write'
    call trace_end ( 'WriteL2AUXData_MLSFile', cond=.false. )
  end subroutine WriteL2AUXData_MLSFile

  ! ----------------------------------------  WriteL2AUXData_MF_hdf5  -----
  subroutine WriteL2AUXData_MF_hdf5(l2aux, L2AUXFile, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF )
  ! Write l2aux to the L2AUXFile
  ! Optionally, write a bogus CounterMAF sd so the
  ! resulting file can masquerade as an l1BRad
  ! (Note that this bogus sd should only be written once for each file;
  !  also note the attempt to convert l2aux%values to KIND of l1b radiances)
    use HDF5, only: H5gclose_F, H5gopen_F
    use MLS_DataProducts, only: DataProducts_T
    use MLSAUXData, only: Build_MLSAUXData
    use MLSHDF5, only: IsHDF5attributepresent, MakeHDF5Attribute
    use MLSL2Timings, only: ShowTimingNames
    use PCFHDR, only: H5_WriteGlobalAttr

    type (L2AUXData_T), intent(inout) :: L2AUX
    type(MLSFile_T)                :: L2AUXFile
    character (len=*), optional, intent(in) :: SDNAME ! Defaults to l2aux%name
    integer, intent(in), optional :: NoMAFS
    logical, intent(in), optional :: WriteCounterMAF  ! Write bogus CounterMAF
    integer, intent(out) :: returnStatus           ! 0 unless error

    ! Local variables
    integer :: grp_id
    integer :: myNoMAFS, MAF
    type(DataProducts_T) :: dataProduct
    logical :: myWriteCounterMAF
    integer, dimension(:), pointer :: CounterMAF ! bogus array
    logical, parameter             :: ALWAYSWRITEAS32BITS = .true.

    ! Executable code
    returnStatus = 0
    myWriteCounterMAF = .false.
    if ( present(WriteCounterMAF) ) myWriteCounterMAF = WriteCounterMAF
    myNoMAFS = 1
    if ( any(l2aux%dimensions%dimensionFamily == L_MAF) ) &
     & myNoMAFS = l2aux%dimensions(3)%noValues
    if ( present(NoMAFS) ) myNoMAFS = NoMAFS
    
    if ( .not. L2AUXFile%stillOpen ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'File not opened' , MLSFile=L2AUXFile )
    
    if ( .not. associated ( l2aux%values ) ) then
      call announce_error (0,&
        & "l2aux values not associated yet ", L2AUXFile=L2AUXFile )
      returnStatus = 1
    else
      if ( present(sdName) ) then
        dataProduct%name = sdName
      else
        call get_string ( l2aux%name, dataProduct%name, strip=.true. )
      end if
      if ( myWriteCounterMAF .or. ALWAYSWRITEAS32BITS ) then
        dataProduct%data_type = 'real'    ! same type as l1bradiances
      else
        dataProduct%data_type = 'double'  ! type of L2AUXData_T%values
      end if
      ! dims(1) = size(l2aux%values, 1)
      ! dims(2) = size(l2aux%values, 2)
      ! dims(3) = size(l2aux%values, 3)
      ! call Dump_L2AUX(l2AUX)
      if ( myWriteCounterMAF .or. ALWAYSWRITEAS32BITS ) then
        call WriteHDF5Data (  real(l2aux%values, r4), L2AUXFile%FileID%f_id, &
          & returnStatus, trim(dataProduct%name) )
        call WriteL2AUXAttributes(L2AUXFile%FileID%f_id, l2aux, trim(dataProduct%name))
      else
        call MLSMessage ( MLSMSG_Error, ModuleName // '%WriteL2AUXData_MF_hdf5', &
          & 'Unexpected execution path' , MLSFile=L2AUXFile )
      end if
      call h5_writeglobalattr(L2AUXFile%FileID%f_id, skip_if_already_there=.false.)
      ! Write phase and section names as file-level attributes?
      if ( PHASENAMEATTRIBUTES ) then
        call h5gopen_f(L2AUXFile%FileID%f_id, '/', grp_id, returnstatus)
        if ( .not. &
          & IsHDF5AttributePresent('/', L2AUXFile%FileID%f_id, 'Phase Names') ) &
          & call MakeHDF5Attribute(grp_id, &
          & 'Phase Names', trim(showTimingNames('phases', .true.)), .true.)
        if ( .not. &
          & IsHDF5AttributePresent('/', L2AUXFile%FileID%f_id, 'Section Names') ) &
          & call MakeHDF5Attribute(grp_id, &
          & 'Section Names', trim(showTimingNames('sections', .true.)), .true.)
        call h5gclose_f(grp_id, returnstatus)
      end if
      if ( .not. myWriteCounterMAF ) return
    
      ! Now create and write bogus counterMAF array
      if ( myNoMAFS < 1 ) then
        call announce_error(0, &
        & "Too few MAFs to fake CounterMAFs in l2aux file:  ", L2AUXFile=L2AUXFile )
        return
      end if
      nullify (CounterMAF)
      call allocate_test(CounterMAF,myNoMAFS,'counterMAF',ModuleName)
      ! dims(1) = myNoMAFS
      dataProduct%name = 'counterMAF'
      dataProduct%data_type = 'integer'
      do MAF=0, myNoMAFS-1
        counterMAF(MAF+1) = MAF
      end do
      call Build_MLSAuxData(L2AUXFile%FileID%f_id, dataProduct, counterMAF, &
      & myNoMAFS )
      call Deallocate_Test(CounterMAF,"CounterMAF",ModuleName)
    end if
  end subroutine WriteL2AUXData_MF_hdf5

  ! ----------------------------------------  WriteL2AUXData_MF_hdf4  -----
  subroutine WriteL2AUXData_MF_hdf4( l2aux, L2AUXFile, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF, DimNames, Reuse_dimNames )
  ! Write l2aux to the file with l2FileHandle
  ! Optionally, write a bogus CounterMAF sd so the
  ! resulting file can masquerade as an l1BRad
  ! (Note that this bogus sd should only be written once for each file)
    type (L2AUXData_T), intent(inout) :: L2AUX
    type(MLSFile_T)                :: L2AUXFile
    character (len=*), optional, intent(in) :: SDNAME ! Defaults to l2aux%name
    character (len=*), optional, intent(in) :: DimNames ! Comma-separated list
                                                        ! Otherwise automatic
                                                        ! (Requiring l2cf)
    integer, intent(in), optional :: NoMAFS
    logical, intent(in), optional :: WriteCounterMAF  ! Write bogus CounterMAF
    logical, intent(in), optional :: Reuse_dimNames   ! We already wrote them
    integer, intent(out) :: returnStatus           ! 0 unless error

    ! Local variables
    integer :: NODIMENSIONSUSED         ! No. real dimensions
    integer, dimension(:), pointer :: DIMSIZES ! Size of each dimension
    integer :: sdId                   ! sd id from sfcreate
    logical, dimension(L2AUXRank) :: GOODDIM ! Not L_None
    integer :: dimensionInData     ! Index
    integer :: dimensionInFile          ! Index
    integer :: dimID                    ! ID for HDF
    character (len=132) :: NAMESTRING   ! Name for sd
    character (len=132) :: DIMNAME      ! Name for dimension
    integer :: status                   ! Flag
    integer, parameter, dimension(L2AUXRank) :: stride = (/ 1, 1, 1/)
    integer, parameter, dimension(L2AUXRank) :: start = (/ 0, 0, 0/)
    logical :: myWriteCounterMAF
    logical :: myReuse_dimNames
    integer :: myNoMAFS, MAF
    integer :: myL2AUXRANK
    integer, dimension(:), pointer :: CounterMAF ! bogus array
    real(r8) :: HUGER4

    ! Executable code
    hugeR4 = real ( huge ( 0.0_r4), r8 )
    myWriteCounterMAF = .false.
    if ( present(WriteCounterMAF) ) myWriteCounterMAF = WriteCounterMAF
    myReuse_dimNames = .false.
    if ( present(Reuse_dimNames) ) myReuse_dimNames = Reuse_dimNames
    myNoMAFS = 1
    if ( any(l2aux%dimensions%dimensionFamily == L_MAF) ) &
     & myNoMAFS = l2aux%dimensions(3)%noValues
    if ( present(NoMAFS) ) myNoMAFS = NoMAFS
    myL2AUXRANK = L2AUXRANK
    if ( present(DimNames) ) myL2AUXRANK = NumStringElements(DimNames, countEmpty=.true.)
    nullify ( dimSizes )
    error = 0

    if (present(sdName)) then
      nameString=sdName
    else
      call get_string ( l2aux%name, nameString, strip=.true. )
    end if

    goodDim=l2aux%dimensions%dimensionFamily /= L_None
    noDimensionsUsed = min(COUNT(goodDim), myL2AUXRank)
    call allocate_test(dimSizes,noDimensionsUsed,'dimSizes',ModuleName)
    if ( present(DimNames) ) then
      dimSizes = PACK(l2aux%dimensions(1:noDimensionsUsed)%noValues, &
        & goodDim(1:noDimensionsUsed))
    else
      dimSizes = PACK(l2aux%dimensions%noValues, &
        & goodDim)
    end if

    ! Create the sd within the file
    sdId= SFcreate ( L2AUXFile%FileID%f_id, nameString, DFNT_FLOAT32, &
      & noDimensionsUsed, dimSizes)

    if ( .not. myReuse_dimNames ) then
    ! Now define the dimensions
    dimensionInFile=0
    do dimensionInData=1, myL2AUXRank
      if (l2aux%dimensions(dimensionInData)%dimensionFamily &
        &    /= L_None) then
        dimID=SFDIMID(sdId,dimensionInFile)
        ! Construct dimension name. For minor frame quantities MIF and MAF
        ! names are global, otherwise specific
        if ( present(DimNames) ) then
          call GetStringElement(trim(DimNames), dimName, dimensionInData, &
            & countEmpty=.TRUE.)
        else if ( (dimensionInData > 1) .and. (l2aux%minorFrame) ) then
          call GetModuleName( l2aux%instrumentModule, dimName)
          if (len_trim(dimName) < len(dimName)) dimName=TRIM(dimName)//'.'
          call get_string (lit_indices(l2aux%dimensions(dimensionInData)%dimensionFamily), &
            & dimName(LEN_TRIM(dimName)+1:))
        else
          call get_string (l2aux%name, dimName, strip=.true. )
          if (len_trim(dimName) < len(dimName)) dimName=TRIM(dimName)//'.'
          call get_string (lit_indices(l2aux%dimensions(dimensionInData)%dimensionFamily), &
            & dimName(LEN_TRIM(dimName)+1:))
        end if
        ! Write dimension name
        status=SFSDMName(dimID,TRIM(dimName))
        if ( status /= 0 ) then
          call output("dim name: ")
          call output(TRIM(dimName), advance='yes')
          call announce_error (  0, &
          & "Error setting dimension name to SDS l2aux file:", L2AUXFile=L2AUXFile)
        end if
        ! Write dimension scale
        status=SFSDScale(dimID, dimSizes(dimensionInFile+1), DFNT_FLOAT32, &
          & l2aux%dimensions(dimensionInData)%values)
        if ( status /= 0 ) then
          call output("dimID: ")
          call output(dimID, advance='yes')
          call output("dim name: ")
          call output(TRIM(dimName), advance='yes')
          call announce_error ( 0, &
          & "Error writing dimension scale in l2auxFile:", L2AUXFile=L2AUXFile )
        end if
        dimensionInFile=dimensionInFile+1
      end if
    end do
    end if

    ! Now write the data
    ! Make sure the data can be placed in a real
    status= SFWDATA_F90(sdId, start(1:noDimensionsUsed), &
      & stride(1:noDimensionsUsed), dimSizes, real ( &
      & max ( -hugeR4, min ( hugeR4, l2aux%values ) ) ) )
    if ( status /= 0 ) then
      call announce_error (0, &
      & "Error writing SDS data to  l2aux file:  ", L2AUXFile=L2AUXFile )
    end if

    call Deallocate_Test(dimSizes,"dimSizes",ModuleName)
    
    ! Terminate access to sd
    status = sfendacc(sdId)
    if ( status /= 0 ) then
      call announce_error (0,&
      & "Error ending access to the sd  ", L2AUXFile=L2AUXFile )
    end if
    returnStatus = error
    if ( .not. myWriteCounterMAF ) return
    
    ! Now create and write bogus counterMAF array
    if ( myNoMAFS < 1 ) then
      call announce_error(0, &
      & "Too few MAFs to fake CounterMAFs in l2aux file:  ", L2AUXFile=L2AUXFile )
      return
    end if
    nullify (CounterMAF, dimSizes)
    call allocate_test(CounterMAF,myNoMAFS,'counterMAF',ModuleName)
    call allocate_test(dimSizes,1,'dimSizes',ModuleName)
    dimSizes(1) = myNoMAFS
    sdId= SFcreate ( L2AUXFile%FileID%f_id, 'counterMAF', DFNT_INT32, &
      & 1, dimSizes)
    do MAF=0, myNoMAFS-1
      counterMAF(MAF+1) = MAF
    end do
    status= SFWDATA_F90(sdId, (/ 0 /), &
      & (/ 1 /) , dimSizes, CounterMAF)
    if ( status /= 0 ) then
      call announce_error (0,&
      & "Error writing counterMAF data to  l2aux file:  ", L2AUXFile=L2AUXFile )
    end if
    call Deallocate_Test(dimSizes,"dimSizes",ModuleName)
    call Deallocate_Test(CounterMAF,"CounterMAF",ModuleName)
    
    ! Terminate access to sd
    status = sfendacc(sdId)
    if ( status /= 0 ) then
      call announce_error (0,&
      & "Error ending access to the sd  ", L2AUXFile=L2AUXFile )
    end if
    returnStatus = error
    ! call Dump_L2AUX(l2AUX)

  end subroutine WriteL2AUXData_MF_hdf4

  ! ---------------------------------------  WriteL2AUXAttributes  -----
  subroutine WriteL2AUXAttributes ( L2FileHandle, l2aux, name)
    use MLSHDF5, only: MakeHDF5Attribute
    ! Writes the pertinent attributes for an l2aux
    ! Arguments
    integer, intent(in) :: L2FileHandle
    type (L2AUXData_T), intent(inout) :: L2AUX
    character(len=*) :: name
    ! Internal variables
    integer :: dim
    character(len=16), dimension(L2AUXRank) :: dim_name
    character(len=16), dimension(L2AUXRank) :: dim_unit
    character(len=16) :: dim_of_i
    character(len=16) :: framing
    character(len=2) :: i_char
    logical :: is_timing
    integer :: ndims
    character(len=*), parameter :: ottff = '1,2,3,4,5'
    ! Executable
    is_timing = ( index( lowercase(name), 'timing') > 0 )
    if ( is_timing ) then
      l2aux%majorframe = .false.
      l2aux%minorframe = .false.
      l2aux%minorframe = .false.
      l2aux%DIM_Names  = 'chunk,' // name(1:5) // ',none'
      l2aux%DIM_Units  =  'none,none,none'
      l2aux%VALUE_Units=  's'
    end if
    if ( DEEBUG ) then
      call output('Writing attributes to: ', advance='no')
      call output(trim(Name), advance='yes')
    end if
    call MakeHDF5Attribute(L2FileHandle, name, 'Title', name)
    call MakeHDF5Attribute(L2FileHandle, name, 'Units', &
      & trim(l2aux%VALUE_Units))
    call MakeHDF5Attribute(L2FileHandle, name, 'DimensionNames', &
      & trim(l2aux%DIM_Names))
    if ( l2aux%majorframe ) then
      framing = 'major'
    else if ( l2aux%minorframe ) then
      framing = 'minor'
    else
      framing = 'neither'
    end if
    call MakeHDF5Attribute(L2FileHandle, name, 'Framing', trim(framing))
    call MakeHDF5Attribute(L2FileHandle, name, 'InstrumentModule', &
      & l2aux%instrumentmodule)
    call MakeHDF5Attribute(L2FileHandle, name, 'QuantityType', &
      & l2aux%quantitytype)
    call MakeHDF5Attribute(L2FileHandle, name, 'MissingValue', &
      & (/ real(UNDEFINED_VALUE, r8) /) )
    dim_name = ' '
    dim_unit = ' '
    ndims = min( NumStringElements(trim(l2aux%DIM_Names), .true.), L2AUXRank )
    if ( ndims < 1 ) return
    call List2Array(trim(l2aux%DIM_Names), dim_name, .true.)
    call List2Array(trim(l2aux%DIM_Units), dim_unit, .true.)
    ! loop of dimensions
    do dim=1, ndims
      call GetStringElement (ottff, i_char, dim, .true.)
      dim_of_i = 'dim ' // trim(i_char)
      if ( trim(dim_unit(dim)) == ' ' ) dim_unit(dim) = 'none'
      call MakeHDF5Attribute(L2FileHandle, name, trim(dim_of_i), &
        & trim(dim_name(dim)))
      call MakeHDF5Attribute(L2FileHandle, name, trim(dim_of_i) // ' units', &
        & trim(dim_unit(dim)))
      if ( l2aux%dimensions(dim)%noValues > 0 ) then
        if ( AreDimValuesNonTrivial(l2aux%dimensions(dim)%DimensionFamily) ) then
          call MakeHDF5Attribute(L2FileHandle, name, trim(dim_of_i)// ' values', &
          & real(l2aux%dimensions(dim)%values))
        end if
      end if
    end do
  end subroutine WriteL2AUXAttributes

  ! -------------------------------------------------  GetDimSize  -----
  subroutine GetDimSize ( nameType, quantityTemplate, noMAFs, dim_size)

  ! Given a dim name type, e.g. l_MIF,
  ! returns corresponding dimension size, e.g. quantityTemplate%noSurfs

    ! Dummy arguments
    integer, intent(in)                :: noMAFs
    integer, intent(in)                :: nameType
    integer, intent(out)               :: dim_size
    type (QuantityTemplate_T), intent(in) :: quantityTemplate

    ! Executable code
    dim_size = 1
    select case (nameType)                                       
    case ( l_channel )  
      dim_size = quantityTemplate%noChans
    case ( l_frequency )  
      dim_size = quantityTemplate%noChans
    case ( l_geodAngle )  
      dim_size = quantityTemplate%noInstances
    case ( l_height )  
      dim_size = quantityTemplate%noSurfs
    case ( l_MAF )  
      dim_size = noMAFs
    case ( l_MIF )  
      dim_size = quantityTemplate%noSurfs
    case ( l_pressure )  
      dim_size = quantityTemplate%noSurfs
    case ( l_xyz )  
      dim_size = 3

    end select                                                       

  end subroutine GetDimSize

  ! ------------------------------------------------  GetDimStart  -----
  subroutine GetDimStart ( nameType, quantityTemplate, firstMaf, dim_start)

  ! Given a dim name type, e.g. l_MAF,
  ! returns corresponding dimension start, e.g. firstMaf

    ! Dummy arguments
    integer, intent(in)                :: firstMaf
    integer, intent(in)                :: nameType
    integer, intent(out)               :: dim_start
    type (QuantityTemplate_T), intent(in) :: quantityTemplate

    ! Executable code
    dim_start = 1
    select case (nameType)                                       
    case ( l_MAF )  
      dim_start = firstMaf

    end select                                                       

  end subroutine GetDimStart

  ! -----------------------------------------------  GetDimString  -----
  subroutine GetDimString ( nameType, dim_string)

  ! Given a dim name type, e.g. l_vmr,
  ! returns corresponding character string

    ! Dummy arguments
    integer, intent(in)                :: nameType
    character(len=*), intent(out)      :: dim_string

    ! Executable code
    dim_string = 'none'
    select case (nameType)                                       
    case ( l_channel )  
      dim_string = 'channel'
    case ( l_chunk )  
      dim_string = 'chunk'
    case ( l_frequency )  
      dim_string = 'frequency'
    case ( l_geodAngle )  
      dim_string = 'geodAngle'
    case ( l_height )  
      dim_string = 'height'
    case ( l_iteration )  
      dim_string = 'iteration'
    case ( l_MAF )  
      dim_string = 'MAF'
    case ( l_MIF )  
      dim_string = 'MIF'
    case ( l_pressure )  
      dim_string = 'pressure'
    case ( l_xyz )  
      dim_string = 'xyz'

    end select                                                       

  end subroutine GetDimString

  ! -------------------------------------  AreDimValuesNonTrivial  -----
  function AreDimValuesNonTrivial ( nameType )

  ! Given a dim name type, e.g. l_channel,
  ! tell whether the corresponding values are non-trivial
  ! Trivial means, e.g. {1 2 3 4} or {0 0 0 0}
    integer, intent(in)                   :: nameType
    logical                               :: AreDimValuesNonTrivial
    AreDimValuesNonTrivial = any( &
      & nameType == (/ &
      & l_frequency, &
      & L_IntermediateFrequency, l_USBFrequency, L_LSBFrequency, &
      & l_geodAngle, l_height, l_pressure &
      & /) &
      & )
  end function AreDimValuesNonTrivial

  ! -----------------------------------------------  GetDimValues  -----
  subroutine GetDimValues ( nameType, quantityTemplate, dim_values )

  ! Given a dim name type, e.g. l_channel,
  ! fills dimension with appropriate values, e.g. channels
  ! (Assumes dim_values already allocated)

    ! Dummy arguments
    integer, intent(in)                   :: nameType
    real(r8), dimension(:), intent(out)   :: dim_values
    type (QuantityTemplate_T), intent(in) :: quantityTemplate

    ! Internal variables
    integer :: i
    ! Executable code
    dim_values = 0._r8
    select case (nameType)                                       
    case ( l_channel, l_MAF, l_MIF, l_xyz )  
      do i=1, SIZE(dim_values)
       dim_values(i) = i
      end do
    case ( l_frequency, &
         & L_IntermediateFrequency, l_USBFrequency, L_LSBFrequency )  
      dim_values = quantityTemplate%frequencies
    case ( l_geodAngle )  
      dim_values = quantityTemplate%phi(1,:)   ! If not stacked, phi(surf, :)
    case ( l_height, l_pressure )  
      dim_values = quantityTemplate%surfs(:,1) ! If incoherent, surfs(:, inst)

    end select

  end subroutine GetDimValues

  ! --------------------------------------  GetQuantityAttributes  -----
  subroutine GetQuantityAttributes ( quantityType, &
   & framing, units_name, dim_names)

  ! Given a quantity type, e.g. l_vmr,
  ! returns major/minor/neither framing distinction, default unit name,
  ! and the 3 dimension names, e.g. (/l_channel, l_MIF, l_MAF/)

    use Init_Tables_Module, only: First_Lit, Last_Lit

    ! Dummy arguments
    integer, intent(in)                :: quantityType
    character(len=*), intent(out), optional      :: framing
    character(len=*), intent(out), optional      :: units_name
    integer, dimension(3), intent(out), optional :: dim_names

    type :: Attrib_t
      character(7) :: Framing = 'neither'
      character(10) :: Units_Name = 'NoUnits'
      integer :: dim_names(3) = (/ l_channel, l_MIF, l_MAF /)
    end type

    type(attrib_t), save :: Attrib(first_lit:last_lit)
    logical, save :: First = .true.

    if ( first ) then ! Can't do this with a DATA statement because Attrib_t has default initialization
      first = .false.
    ! Units should be consistent with InitQuantityTemplates in
    ! ConstructQuantitytypes. The ones that are commented out are in the list
    ! of members of the "quantity" type in init_tables_module.  If they become
    ! eligible to be written in L2AUX, they need to be in this list.  But
    ! check the fields first!
    !                                                  framing    units           dim_names
    ! Default for those not listed here is:           'neither', 'NoUnits   ', (/ l_channel, l_MIF, l_MAF /)
!     attrib(l_azimuth)                    = attrib_t('neither', 'deg       ', (/ l_none, l_none, l_none /) )
      attrib(l_baseline)                   = attrib_t('minor  ', 'K         ', (/ l_frequency, l_MIF, l_MAF /) )
!     attrib(l_boundaryPressure)           = attrib_t('major  ', 'hPa       ', (/ l_none, l_none, l_MAF /) )
      attrib(l_channel)                    = attrib_t('major  ', 'channel   ', (/ l_none, l_none, l_none /) )
      attrib(l_chisqchan)                  = attrib_t('major  ', 'channel   ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_chisqmmaf)                  = attrib_t('major  ', 'NoUnits   ', (/ l_none, l_none, l_MAF /) )
      attrib(l_chisqmmif)                  = attrib_t('minor  ', 'NoUnits   ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_chunk)                      = attrib_t('major  ', 'chunk     ', (/ l_none, l_none, l_none /) )
      attrib(l_cloudExtinction)            = attrib_t('neither', 'NoUnits   ', (/ l_channel, l_none, l_MAF /) )
!     attrib(l_cloudIce)                   = attrib_t('minor  ', 'gm/m^3    ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_cloudInducedRadiance)       = attrib_t('minor  ', 'K         ', (/ l_channel, l_MIF, l_MAF /) )
!     attrib(l_cloudMinMax)                = attrib_t('minor  ', 'K         ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_cloudRadSensitivity)        = attrib_t('minor  ', 'K         ', (/ l_channel, l_none, l_MAF /) )
!     attrib(l_cloudTemperature)           = attrib_t('minor  ', 'K         ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_cloudWater)                 = attrib_t('neither', 'NoUnits   ', (/ l_channel, l_none, l_MAF /) )
!     attrib(l_columnAbundance)            = attrib_t('major  ', 'mol/cm^2  ', (/ l_none, l_none, l_MAF /) )
      attrib(l_dnwt_ajn)                   = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_axmax)                 = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_cait)                  = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_chiSqMinNorm)          = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_chiSqNorm)             = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
!     attrib(l_dnwt_chiSqRatio)            = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
!     attrib(l_dnwt_count)                 = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_diag)                  = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_dxdx)                  = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_dxdxl)                 = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_dxn)                   = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_dxnl)                  = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_flag)                  = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_fnmin)                 = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_fnorm)                 = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_gdx)                   = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_gfac)                  = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_gradn)                 = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_sq)                    = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_sqt)                   = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
!     attrib(l_earthRadius)                = attrib_t('major  ', 'm         ', (/ l_none, l_none, l_MAF /) )
!     attrib(l_earthRefl)                  = attrib_t('neither', 'NoUnits   ', (/ l_none, l_none, l_none /) )
!     attrib(l_ecrToFOV)                   = attrib_t('minor  ', 'NoUnits   ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_effectiveOpticalDepth)      = attrib_t('minor  ', 'NoUnits   ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_elevOffset)                 = attrib_t('neither', 'deg       ', (/ l_channel, l_MIF, l_MAF /) )
!     attrib(l_extinction)                 = attrib_t('neither', '1/km      ', (/ l_channel, l_none, l_MAF /) )
!     attrib(l_extinctionV2)               = attrib_t('neither', '1/km      ', (/ l_channel, l_none, l_MAF /) )
!     attrib(l_fieldAzimuth)               = attrib_t('minor  ', 'deg       ', (/ l_none, l_MIF, l_MAF /) )
!     attrib(l_fieldElevation)             = attrib_t('minor  ', 'deg       ', (/ l_none, l_MIF, l_MAF /) )
!     attrib(l_fieldStrength)              = attrib_t('minor  ', 'gauss     ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_frequency)                  = attrib_t('major  ', 'MHz       ', (/ l_none, l_none, l_none /) )
!     attrib(l_geolocation)                = attrib_t('major  ', 'NoUnits   ', (/ l_none, l_none, l_none /) )
!     attrib(l_gph)                        = attrib_t('major  ', 'm         ', (/ l_none, l_none, l_MAF /) )
      attrib(l_heightOffset)               = attrib_t('minor  ', 'm         ', (/ l_channel, l_MIF, l_MAF /) )
!     attrib(l_isotopeRatio)               = attrib_t('neither', 'NoUnits   ', (/ l_none, l_none, l_none /) )
!     attrib(l_iwc)                        = attrib_t('minor  ', 'gm/m^3    ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_jacobian_cols)              = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_jacobian_rows)              = attrib_t('neither', 'NoUnits   ', (/ l_none, l_iteration, l_chunk /) )
!     attrib(l_l1bMAFBaseline)             = attrib_t('major  ', 'K         ', (/ l_none, l_none, l_MAF /) )
!     attrib(l_l1bMIF_TAI)                 = attrib_t('minor  ', 's         ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_limbSidebandFraction)       = attrib_t('neither', 'NoUnits   ', (/ l_channel, l_none, l_none /) )
!     attrib(l_lineCenter)                 = attrib_t('neither', 'MHz       ', (/ l_none, l_none, l_none /) )
!     attrib(l_lineWidth)                  = attrib_t('neither', 'MHz       ', (/ l_none, l_none, l_none /) )
!     attrib(l_lineWidth_TDep)             = attrib_t('neither', 'MHz       ', (/ l_none, l_none, l_none /) )
      attrib(l_losTransFunc)               = attrib_t('neither', 'NoUnits   ', (/ l_frequency, l_MIF, l_MAF /) )
      attrib(l_losVel)                     = attrib_t('minor  ', 'm/s       ', (/ l_xyz, l_MIF, l_MAF /) )
!     attrib(l_lowestRetrievedPressure)    = attrib_t('neither', 'log10(hPa)', (/ l_none, l_none, l_none /) )
!     attrib(l_magneticField)              = attrib_t('minor  ', 'gauss     ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_massMeanDiameterIce)        = attrib_t('minor  ', 'NoUnits   ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_massMeanDiameterWater)      = attrib_t('minor  ', 'NoUnits   ', (/ l_none, l_MIF, l_MAF /) )
!     attrib(l_mifDeadTime)                = attrib_t('neither', 's         ', (/ l_none, l_none, l_none /) )
      attrib(l_mifExtinction)              = attrib_t('minor  ', '1/km      ', (/ l_channel, l_MIF, l_MAF /) )
!     attrib(l_mifExtinctionExtrapolation) = attrib_t('neither', 'NoUnits   ', (/ l_none, l_none, l_none /) )
!     attrib(l_mifExtinctionForm)          = attrib_t('neither', 'NoUnits   ', (/ l_none, l_none, l_none /) )
      attrib(l_mifExtinctionV2)            = attrib_t('minor  ', '1/km      ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_noiseBandwidth)             = attrib_t('neither', 'MHz       ', (/ l_channel, l_none, l_none /) )
!     attrib(l_noRadsBinned)               = attrib_t('minor  ', 'NoUnits   ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_noRadsPerMIF)               = attrib_t('minor  ', 'NoUnits   ', (/ l_none, l_MIF, l_MAF /) )
!     attrib(l_numGrad)                    = attrib_t('neither', 'iteration ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_numJ)                       = attrib_t('neither', 'iteration ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_opticalDepth)               = attrib_t('minor  ', 'NoUnits   ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_orbitInclination)           = attrib_t('minor  ', 'deg       ', (/ l_none, l_none, l_none /) )
      attrib(l_AscDescMode)                  = attrib_t('neither', 'NoUnits   ', (/ l_none, l_none, l_none /) )
      attrib(l_phaseTiming)                = attrib_t('minor  ', 's         ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_phiTan)                     = attrib_t('minor  ', 'deg       ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_ptan)                       = attrib_t('minor  ', 'log10(hPa)', (/ l_none, l_MIF, l_MAF /) )
!     attrib(l_quality)                    = attrib_t('major  ', 'NoUnits   ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_radiance)                   = attrib_t('minor  ', 'K         ', (/ l_channel, l_MIF, l_MAF /) )
!     attrib(l_refGPH)                     = attrib_t('major  ', 'm         ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_reflTemp)                   = attrib_t('major  ', 'K         ', (/ l_none, l_none, l_MAF /) )
      attrib(l_reflSpill)                  = attrib_t('major  ', 'NoUnits   ', (/ l_channel, l_none, l_MAF /) )
!     attrib(l_RHI)                        = attrib_t('minor  ', 'NoUnits   ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_scanResidual)               = attrib_t('minor  ', 'm         ', (/ l_none, l_MIF, l_MAF /) )
!     attrib(l_scatteringAngle)            = attrib_t('minor  ', 'deg       ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_scECI)                      = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_scGeocAlt)                  = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_scVelECI)                   = attrib_t('minor  ', 'm/s       ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_scVelECR)                   = attrib_t('minor  ', 'm/s       ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_singleChannelRadiance)      = attrib_t('minor  ', 'K         ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_sizeDistribution)           = attrib_t('minor  ', 'NoUnits   ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_spaceRadiance)              = attrib_t('neither', 'K         ', (/ l_none, l_none, l_none /) )
!     attrib(l_status)                     = attrib_t('major  ', 'NoUnits   ', (/ l_none, l_none, l_MAF /) )
      attrib(l_strayRadiance)              = attrib_t('major  ', 'K         ', (/ l_channel, l_none, l_MAF /) )
!     attrib(l_surfaceHeight)              = attrib_t('major  ', 'm         ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_surfacetype)                = attrib_t('neither', 'NoUnits   ', (/ l_none, l_none, l_none /) )
      attrib(l_systemTemperature)          = attrib_t('neither', 'K         ', (/ l_channel, l_none, l_none /) )
!     attrib(l_totalPowerWeight)           = attrib_t('neither', 'NoUnits   ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_tngtECI)                    = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_tngtGeocAlt)                = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_tngtGeodAlt)                = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
!     attrib(l_TScat)                      = attrib_t('major  ', 'K         ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_vmr)                        = attrib_t('neither', 'vmr       ', (/ l_channel, l_none, l_MAF /) )
      ! The following are not quantity types listed under t_quantityType in
      ! init_tables_module, or in InitQuantityTemplates in
      ! ConstructQuantityTemplates.  At least some of them are dimension
      ! types, for which a second call to this subroutine fetches the units
      ! attribute of the dimension (instead of the vector quantity).
      ! Others might be fossils.
      attrib(l_geodAngle)                  = attrib_t('neither', 'deg       ', (/ l_none, l_none, l_none /) )
      attrib(l_iteration)                  = attrib_t('major  ', 'iteration ', (/ l_none, l_none, l_none /) )
      attrib(l_MAF)                        = attrib_t('major  ', 'MAF       ', (/ l_none, l_none, l_none /) )
      attrib(l_MIF)                        = attrib_t('major  ', 'MIF       ', (/ l_none, l_none, l_none /) )
      attrib(l_totalExtinction)            = attrib_t('neither', 'NoUnits   ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_xyz)                        = attrib_t('major  ', 'xyz       ', (/ l_none, l_none, l_none /) )
    end if

    ! Executable code
    if ( present(framing) )    framing    = attrib(quantityType)%framing
    if ( present(units_name) ) units_name = attrib(quantityType)%units_name
    if ( present(dim_names) )  dim_names  = attrib(quantityType)%dim_names

  end subroutine GetQuantityAttributes

  ! ------------------------------------  GetQuantityTypeFromName  -----
  function GetQuantityTypeFromName (name)  result(quantityType)

  ! Given quantity name, e.g. '/R4:640.B29M:HOCL.S0.MB11-3 chisqMMIF CorePlusR4'
  ! return a quantity type, e.g. l_chisqmmif

    ! Dummy arguments
    integer                :: quantityType
    character(len=*), intent(in)       :: name
    ! Local variables
    character(len=len(name)) :: myName
    ! Executable code
    quantityType = -999
    if ( name == '' ) return
    myName = lowerCase(name)
    if ( index(trim(myName), 'chisq') > 0 ) then
      if ( index(trim(myName), 'mmaf') > 0 ) then
        quantityType = l_chisqmmaf
      else if ( index(trim(myName), 'mmif') > 0 ) then
        quantityType = l_chisqmmif
      else if ( index(trim(myName), 'chan') > 0 ) then
        quantityType = l_chisqchan
      else
        ! This is binned chi^2
        ! unlike the others, it is neither major nor minor frame
        ! we'll say it is most like dnwt_chisqnorm
        quantityType = l_dnwt_chiSqNorm
      end if
    else if ( index(trim(myName), 'noradspermif') > 0 ) then
      ! Just like chisqmmif
      quantityType = l_chisqmmif
    else if ( index(trim(myName), 'pcf') > 0 ) then
      quantityType = RECOGNIZEDBUTNOTCOPIEDQT ! was -999
    else if ( index(trim(myName), 'coremetadata') > 0 ) then
      quantityType = RECOGNIZEDBUTNOTCOPIEDQT ! was -999
    else
      quantityType = l_radiance
    end if                      
                      
  end function GetQuantityTypeFromName

  ! ---------------------------------------------  ANNOUNCE_ERROR  -----
  subroutine ANNOUNCE_ERROR ( WHERE, full_message, CODE, L2AUXFile )
    use MLSFiles, only: Dump
    use Tree, only: Where_At => Where
    integer, intent(in) :: WHERE   ! Tree node where error was noticed
    character(len=*), intent(in)    :: full_message
    integer, intent(in), optional :: CODE    ! Code for error message
    type(MLSFile_T), optional :: L2AUXFile

    error = max(error,1)
    call output ( '***** At ' )
    if ( where > 0 ) then
      call print_source ( where_at(where) )
    else
      call output ( '(no lcf node available)' )
    end if
    call output ( ' L2AUXData complained: ' )


    call output ( " Caused the following error: ", advance='yes', &
      & from_where=ModuleName )
    call output ( trim(full_message), advance='yes', &
      & from_where=ModuleName )
    if ( present(code) ) then
      select case ( code )
      end select
    end if
    if ( present(L2AUXFile) ) call dump(L2AUXFile)
  end subroutine ANNOUNCE_ERROR

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: L2AUXData.f90,v 2.104 2018/04/19 01:14:16 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module L2AUXData
!=============================================================================


! $Log: L2AUXData.f90,v $
! Revision 2.104  2018/04/19 01:14:16  vsnyder
! Remove USE statements for unused names
!
! Revision 2.103  2017/10/20 20:05:07  pwagner
! Reduce default printing
!
! Revision 2.102  2017/10/11 23:55:55  pwagner
! Take pains to read int- and char-valued datasets, too
!
! Revision 2.101  2017/08/10 22:46:13  pwagner
! Add WriteHDF5Data
!
! Revision 2.100  2016/08/26 00:17:52  pwagner
! Removed two unused dummy args
!
! Revision 2.99  2016/07/28 01:45:07  vsnyder
! Refactor dump and diff
!
! Revision 2.98  2016/05/19 23:19:02  pwagner
! Added api for cpL2AUXData
!
! Revision 2.97  2015/08/03 21:43:03  pwagner
! Made quantityType optional in call to ReadL2AUXData
!
! Revision 2.96  2015/03/28 02:47:33  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.95  2014/09/05 01:03:35  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.94  2014/09/05 00:49:06  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.93  2014/07/18 23:17:11  pwagner
! Aimed for consistency in names passed to allocate_test
!
! Revision 2.92  2014/04/07 18:06:58  pwagner
! May specify AscDescMode when DirectWrite-ing swaths
!
! Revision 2.91  2014/03/31 23:43:29  pwagner
! Commented-out unused stuff; renamed procedure ResizeL2AUXData, generalizing it to expand or contract
!
! Revision 2.90  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.89  2013/08/31 02:29:12  vsnyder
! Replace MLSMessageCalls with trace_begin and trace_end
!
! Revision 2.88  2013/07/19 01:24:29  vsnyder
! Sort some stuff, revise GetQuantityAttributes a bit more
!
! Revision 2.87  2013/07/18 01:10:57  vsnyder
! Remove scVel since it's ambiguous whether it's ECI or ECR, and nobody
! uses it anyway.

! Revision 2.86  2012/01/25 01:16:41  pwagner
! Improved error msg; snipped commented-out lines

! Revision 2.85  2011/07/07 00:39:15  pwagner
! Accepts options as arg for dumps

! Revision 2.84  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away

! Revision 2.83  2007/10/24 00:15:53  pwagner
! Removed unused declarations

! Revision 2.82  2007/08/13 17:39:42  pwagner
! Push some procedures onto new MLSCallStack

! Revision 2.81  2007/06/21 00:54:08  vsnyder
! Remove tabs, which are not part of the Fortran standard

! Revision 2.80  2006/05/19 22:49:15  pwagner
! May rename copied SDs

! Revision 2.79  2006/01/26 00:34:50  pwagner
! demoted more use statements from module level to speed Lahey compiles

! Revision 2.78  2005/12/21 18:45:29  pwagner
! Should recognize but not copy coremetadata, pcf

! Revision 2.77  2005/12/14 01:45:21  pwagner
! Attribute values to phase, section timing more reasonable

! Revision 2.76  2005/10/11 17:39:58  pwagner
! Added MLSFile interface to cpL2AUXData

! Revision 2.75  2005/09/21 23:17:34  pwagner
! Unnecessary changes

! Revision 2.74  2005/08/25 20:21:41  pwagner
! Ensure returnStatus defined in ReadL2AUXData_MLSFile

! Revision 2.73  2005/08/19 23:27:02  pwagner
! Uses '*' as wildcard sdList string in cpL2AUXData

! Revision 2.72  2005/08/05 20:38:31  pwagner
! L2AUXFile arg to ReadL2AUXFile now a pointer

! Revision 2.71  2005/07/06 00:29:26  pwagner
! optional arg options determines whether cpL2AUXData dumps DS names

! Revision 2.70  2005/06/22 18:57:01  pwagner
! Reworded Copyright statement, moved rcs id

! Revision 2.69  2005/06/14 20:41:02  pwagner
! Interfaces changed to accept MLSFile_T args

! Revision 2.68  2005/03/03 02:10:51  vsnyder
! Remove unused symbols, spiff up some dumps

! Revision 2.67  2004/08/19 00:19:28  pwagner
! Tells ReadL1BData to skip warnings about missing counterMAFs

! Revision 2.66  2004/08/17 17:09:45  pwagner
! L2AUX files shouldn't need padding when read as l1b

! Revision 2.65  2004/08/16 23:43:22  livesey
! Added ability to output minor frame baselines

! Revision 2.64  2004/08/04 23:19:57  pwagner
! Much moved from MLSStrings to MLSStringLists

! Revision 2.63  2004/06/29 18:05:26  pwagner
! May write phase, section names as file-level attributes

! Revision 2.62  2004/04/16 00:48:13  livesey
! Added singleChannelRadiance output

! Revision 2.61  2004/03/08 22:33:29  pwagner
! Bypass reading QuantityType attribute (why always 0)

! Revision 2.60  2004/02/26 22:05:06  pwagner
! Can copy l2aux file w/o knowing ds names; acts more gracefully if no attributes

! Revision 2.59  2004/02/05 23:36:41  pwagner
! WriteL2AUXAttributes now public

! Revision 2.58  2004/01/27 21:38:09  pwagner
! Added cpL2AUXData

! Revision 2.57  2003/09/03 05:25:49  livesey
! Bug fix in hdf5 readl2auxdata.

! Revision 2.56  2003/07/15 23:39:47  pwagner
! Disabled most printing

! Revision 2.55  2003/05/30 00:10:02  livesey
! Bug fix with reflTemp

! Revision 2.54  2003/05/30 00:08:54  livesey
! Added antenna loss terms

! Revision 2.53  2003/05/29 16:43:02  livesey
! Renamed sideband fraction

! Revision 2.52  2003/05/12 02:06:32  livesey
! Bound r8->r4 conversion

! Revision 2.51  2003/04/25 19:55:09  livesey
! Added more useful error message

! Revision 2.50  2003/03/07 00:42:13  pwagner
! Abbreviated Units names; removed spaces from attribute names

! Revision 2.49  2003/02/21 23:42:21  pwagner
! Also writes Fill Value attribute

! Revision 2.48  2003/02/12 21:52:34  pwagner
! Renames blank dim units to none

! Revision 2.47  2003/02/07 21:44:56  pwagner
! Capitalized 1st letter of each attribute name

! Revision 2.46  2003/01/30 01:02:28  pwagner
! Writing attributes for hdf5 files; global and data set

! Revision 2.45  2003/01/18 02:37:03  livesey
! Made the readl2aux data stuff work from the l2cf by adding the
! quantityType argument.

! Revision 2.44  2003/01/17 23:11:26  pwagner
! Moved most ops out of LoinL2AUXData to SetupL2AUXData

! Revision 2.43  2003/01/14 00:41:43  pwagner
! Added GetQuantityAttributes and getDimString; new fields in L2AUXData_T

! Revision 2.42  2002/12/10 00:41:28  pwagner
! In principle can now read hdf5-formatted l2aux files; untested; njl has other plans

! Revision 2.41  2002/12/07 00:25:42  pwagner
! Using SaveAsHDF5DS to write l2aux%values; it works

! Revision 2.40  2002/12/06 01:06:13  pwagner
! Finally writes radaiance-like l2aux as hdf5 files

! Revision 2.39  2002/12/05 19:46:23  pwagner
! Changes to speed up compiling tree-walker

! Revision 2.38  2002/12/03 18:04:02  pwagner
! Repaired bug that caused WriteL2AUXData files to be tiny

! Revision 2.37  2002/12/02 23:42:12  pwagner
! Optional param checkDimNames to ReadL2AUXData; defaults to FALSE

! Revision 2.36  2002/12/02 19:11:13  pwagner
! Corrected data types of counterMAF and dimensions

! Revision 2.35  2002/11/29 22:46:28  livesey
! Various bug fixes / improvements.

! Revision 2.34  2002/11/29 18:50:07  livesey
! Initialised a variable

! Revision 2.33  2002/11/26 22:16:41  jonathan
! Comment-out dump_l2aux diagnostics

! Revision 2.32  2002/11/25 18:04:52  pwagner
! Consistent with latest changes to MLSAuxData

! Revision 2.31  2002/11/22 21:48:02  pwagner
! Fleshed out WriteL2AUXData_hdf5; untested yet

! Revision 2.30  2002/11/13 01:09:47  pwagner
! Beginnings of attempt to write hdf5 L2AUX; incomplete

! Revision 2.29  2002/11/08 23:14:41  pwagner
! Should work again with mlsl2

! Revision 2.28  2002/11/08 18:25:33  jonathan
! Changes to allow writing rank 2; also reuse_DimNames

! Revision 2.27  2002/11/06 02:01:06  livesey
! Changes to fill from l2aux

! Revision 2.26  2002/11/06 00:18:37  pwagner
! Can WriteL2AUXData w/o l2cf: useable by small utility programs

! Revision 2.25  2002/10/08 17:36:21  pwagner
! Added idents to survive zealous Lahey optimizer

! Revision 2.24  2002/08/21 01:04:53  livesey
! Changed to single precision for data

! Revision 2.23  2002/08/15 21:47:04  pwagner
! WriteL2AuxData now returns non-zero status if it fails

! Revision 2.22  2001/11/01 21:03:59  pwagner
! Uses new sfwdata_f90 generic; added toc

! Revision 2.21  2001/10/26 23:13:18  pwagner
! Provides a single dump module interface and details

! Revision 2.20  2001/10/08 23:41:27  pwagner
! Improved dump routines

! Revision 2.19  2001/10/05 23:32:27  pwagner
! Added majorframe to data type; trimmed unused stuff

! Revision 2.18  2001/08/06 18:35:24  pwagner
! Added dump_l2aux

! Revision 2.17  2001/07/11 20:50:46  dwu
! fix problem in readl2auxdata

! Revision 2.16  2001/05/30 23:53:31  livesey
! Changed for new version of L1BData

! Revision 2.15  2001/05/12 00:18:40  livesey
! Tidied up issues with array bounds etc.

! Revision 2.14  2001/05/03 20:32:19  vsnyder
! Cosmetic changes

! Revision 2.13  2001/05/02 22:24:20  pwagner
! Removed SDPToolkit use

! Revision 2.12  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic

! Revision 2.11  2001/04/12 22:19:33  vsnyder
! Improved an error message

! Revision 2.10  2001/04/10 22:27:47  vsnyder
! Nullify explicitly instead of with <initialization> so as not to give
! pointers the SAVE attribute.  <initialization> is NOT executed on each
! entry to a procedure.

! Revision 2.9  2001/04/07 00:14:27  pwagner
! Added announce_error

! Revision 2.8  2001/03/15 18:42:29  livesey
! Removed quotes from dimension name prefixes

! Revision 2.7  2001/03/08 02:20:12  livesey
! Added strip argument to a call to get_string

! Revision 2.6  2001/03/06 22:40:47  livesey
! Working version

! Revision 2.5  2001/02/14 23:41:33  livesey
! Removed irrelevant numProfs argument

! Revision 2.4  2001/01/03 00:46:19  pwagner
! Changed sfgetinfo to sfginfo

! Revision 2.3  2000/12/04 23:34:38  vsnyder
! Move more of addItemToDatabase into the include.

! Revision 2.2  2000/12/04 21:48:29  pwagner
! ReadL2AUXData completed

! Revision 2.1  2000/12/02 01:12:00  pwagner
! Added ReadL2AUXData

! Revision 2.0  2000/09/05 18:57:02  ahanzel
! Changing file revision to 2.0.

! Revision 1.1  2000/09/02 02:05:04  vsnyder
! Initial entry


@


2.104
log
@Remove USE statements for unused names
@
text
@d14 2
a15 1
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d118 1
a118 1
  interface DUMP
a680 2
    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

d823 2
a824 2
    character (LEN=*), intent(IN) :: quantityname ! Name of L2AUX quantity = sdname in writing routine
    integer, intent(IN) :: sd_id ! Returned by sfstart before calling us
d826 1
a826 1
    integer, intent(IN), optional :: firstProf, lastProf ! Defaults to first and last
d868 1
a868 1
    character (LEN=*), intent(IN) :: quantityname ! Name of L2AUX quantity = sdname in writing routine
d871 1
a871 1
    integer, intent(IN), optional :: firstProf, lastProf ! Defaults to first and last
d928 1
a928 1
    character (LEN=*), intent(IN) :: quantityname 
d931 1
a931 1
    integer, intent(IN), optional :: firstProf, lastProf ! Defaults to first and last
a936 5
    ! character (LEN=*), parameter :: SZ_ERR = 'Failed to get size of &
    !  &dimension '
    ! character (LEN=*), parameter :: MLSMSG_INPUT = 'Error in input argument '
    ! character (LEN=*), parameter :: MLSMSG_l2auxRead = 'Unable to read l2aux &
    !  &field:'
a937 1
    ! integer, parameter :: MAXDIMSIZES = 300
a939 4
    ! Functions

    !INTEGER, EXTERNAL :: swattach, swdetach, swdiminfo, swinqdims, swrdfld

d1081 1
a1081 1
    character (LEN=*), intent(IN) :: quantityname 
d1084 1
a1084 1
    integer, intent(IN), optional :: firstProf, lastProf ! Defaults to first and last
a1094 1
    integer                       :: L1BNumType
d2050 1
a2050 1
    character(LEN=*), intent(in)    :: full_message
d2079 1
a2079 1
       "$Id: L2AUXData.f90,v 2.103 2017/10/20 20:05:07 pwagner Exp $"
d2091 3
@


2.103
log
@Reduce default printing
@
text
@a680 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d2091 1
a2091 1
       "$Id: L2AUXData.f90,v 2.102 2017/10/11 23:55:55 pwagner Exp $"
d2103 3
@


2.102
log
@Take pains to read int- and char-valued datasets, too
@
text
@d200 2
a201 2
  subroutine cpL2AUXData_MLSFile(L2AUXFile1, L2AUXFile2, &
    & create2, sdList, rename, options)
d1077 3
a1079 2
  subroutine ReadL2AUXData_MF_hdf5( L2AUXFile, quantityname, quantityType, l2aux, &
    & firstProf, lastProf, checkDimNames )
d1109 2
a1110 1
    call output( 'Attempting to read ' // trim(quantityname), advance='yes' )
d2092 1
a2092 1
       "$Id: L2AUXData.f90,v 2.101 2017/08/10 22:46:13 pwagner Exp $"
d2104 3
@


2.101
log
@Add WriteHDF5Data
@
text
@d726 1
d740 1
a740 2
      call output ( 'L2AUX Database name: ', advance='no' )
      call output ( name, advance='yes' )
d858 2
a859 2
  subroutine ReadL2AUXData_MLSFile(L2AUXFile, quantityname, l2aux, inQuantityType, &
    & firstProf, lastProf, checkDimNames)
d861 1
a861 1
 use MLSFiles, only: HDFVersion_4, HDFVersion_5, &
d903 1
d921 1
a921 1
  subroutine ReadL2AUXData_MF_hdf4(L2AUXFile, quantityname, quantityType, l2aux, &
d1077 2
a1078 2
  subroutine ReadL2AUXData_MF_hdf5(L2AUXFile, quantityname, quantityType, l2aux, &
    & firstProf, lastProf, checkDimNames)
d1106 1
d1108 2
a1109 1
    CALL ReadL1BData(L2AUXFile, QuantityName, L1BDATA1, NoMAFs, status, &
d1117 38
a1154 10
    dim_families(1) = l_channel                      
    data_dim_sizes = shape(L1BDATA1%DpField)
    if ( deebug ) print *, 'shape(L1BDATA1%DpField): ', shape(L1BDATA1%DpField)
    dim_families(2) = l_mif                          
    dim_families(3) = l_maf                          
    call SetupNewl2auxRecord ( l2aux, inputDimFamilies=dim_families, &
     & inputDimSizes=data_dim_sizes, inputDimStarts=(/1,1,1/), &
     & inputQuantityType=quantityType )
    l2aux%values = L1BDATA1%DpField
    deallocate(L1BDATA1%DpField, stat=status)
d1157 3
a1159 2
      & 'Unable to deallocate l1bdata%dpField while reading' &
      & // trim(QuantityName), MLSFile=L2AUXFile )
d1455 2
a1456 2
  subroutine WriteL2AUXData_MF_hdf4(l2aux, L2AUXFile, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF, DimNames, Reuse_dimNames)
d2090 1
a2090 1
       "$Id: L2AUXData.f90,v 2.100 2016/08/26 00:17:52 pwagner Exp $"
d2102 3
@


2.100
log
@Removed two unused dummy args
@
text
@d14 1
a14 1
  use Allocate_deallocate, only: Allocate_test, Deallocate_test
d16 28
a43 28
  use HDF, only: dfacc_create, dfacc_rdonly, dfacc_rdwr, dfnt_float32, &
    & Dfnt_int32, sfcreate, sfdimid, sfendacc, sfgdinfo, sfginfo, &
    & Sfn2index, sfrdata_f90, sfsdmname, sfsdscale, sfselect, sfwdata_f90
  use Init_tables_module, only: l_baseline, l_channel, l_chisqchan, &
    & L_chisqmmaf, l_chisqmmif, l_chunk, l_cloudextinction, &
    & L_cloudinducedradiance, l_cloudradsensitivity, l_cloudwater, &
    & L_dnwt_ajn, l_dnwt_axmax, l_dnwt_cait, l_dnwt_chisqminnorm, &
    & L_dnwt_chisqnorm, l_dnwt_diag, l_dnwt_dxdx, l_dnwt_dxdxl, &
    & L_dnwt_dxn, l_dnwt_dxnl, l_dnwt_flag, l_dnwt_fnmin, l_dnwt_fnorm, &
    & L_dnwt_gdx, l_dnwt_gfac, l_dnwt_gradn, l_dnwt_sq, l_dnwt_sqt, &
    & L_effectiveopticaldepth, l_elevoffset, l_frequency, l_geodangle, &
    & L_height, l_heightoffset, l_intermediatefrequency, l_iteration, &
    & L_jacobian_cols, l_jacobian_rows, l_limbsidebandfraction, &
    & L_lostransfunc, l_losvel, l_lsbfrequency, l_maf, &
    & L_massmeandiameterice, l_massmeandiameterwater, l_mif, &
    & L_mifextinction, l_mifextinctionv2, l_noisebandwidth, l_none, &
    & L_noradspermif, l_numj, l_opticaldepth, l_orbitinclination, l_ascdescmode, &
    & L_phasetiming, l_phitan, l_pressure, l_ptan, l_radiance, &
    & L_reflspill, l_refltemp, l_scanresidual, l_sceci, l_scgeocalt, &
    & L_scveleci, l_scvelecr, l_singlechannelradiance, l_sizedistribution, &
    & L_spaceradiance, l_strayradiance, l_surfacetype, &
    & L_systemtemperature, l_tngteci, l_tngtgeocalt, l_tngtgeodalt, &
    & L_totalextinction, l_usbfrequency, l_vmr, l_xyz
  use Intrinsic, only: l_HDF, lit_indices
  use Lexer_core, only: print_source
  use MLSCommon, only: defaultUndefinedValue, MLSFile_t
  use MLSKinds, only: r8, r4
  use MLSL2Options, only: default_HDFversion_read, default_HDFversion_write
d46 7
a52 7
  use MLSSignals_m, only: getModuleName, modules
  use MLSStrings, only: lowercase
  use MLSStringLists, only: array2List, getStringElement, list2Array, &
    & NumStringElements, stringElement
  use Output_m, only: output
  use QuantityTemplates, only: quantityTemplate_t
  use String_table, only: get_string, display_string
d74 1
d100 2
d110 1
a110 1
  public :: ReadL2AUXData, WriteL2AUXData, WriteL2AUXAttributes
d127 5
d184 1
a184 1
    real(r8), pointer, dimension(:,:,:) :: VALUES=>NULL()
d203 2
a204 2
    use MLSFiles, only: areTheSameFile
    use MLSHdf5, only: getAllHDF5DSNames
d302 6
a307 6
    use HDF, only: dfacc_read, dfacc_rdwr
    use HDF5, only: h5gclose_f, h5gopen_f, h5dopen_f, h5dclose_f
    use MLSFiles, only: fileNotFound, wildCardHDFVersion, &
      & MLS_exists, MLS_hdf_version, MLS_sfstart, MLS_sfend
    use MLSHDF5, only: getAllHDF5DSNames, getHDF5Attribute, &
      & isHDF5AttributePresent
d818 1
a818 1
  use MLSFiles, only: initializeMLSFile
d861 3
a863 3
    use MLSFiles, only: HDFVersion_4, HDFVersion_5, &
      & MLS_closefile, MLS_openfile
    use trace_m, only: trace_begin, trace_end
d1078 1
a1078 1
    use L1BData, only: L1BData_T, readL1BData
d1130 92
d1227 1
a1227 1
  use MLSFiles, only: initializeMLSFile
d1264 3
a1266 3
    use MLSFiles, only: hdfversion_4, hdfversion_5, &
      & mls_closefile, mls_openfile
    use trace_m, only: trace_begin, trace_end
d1324 6
a1329 6
    use HDF5, only: h5gclose_f, h5gopen_f
    use MLS_DataProducts, only: dataProducts_t
    use MLSAUXdata, only: build_MLSAUXData
    use MLSHDF5, only: ishdf5attributepresent, makeHDF5Attribute, saveAsHDF5DS
    use MLSL2Timings, only: showTimingNames
    use PCFHDR, only: h5_writeGlobalAttr
a1340 1
    ! integer, dimension(3) :: dims
a1342 1
    ! logical :: myReuse_dimNames
a1349 2
    ! myReuse_dimNames = .false.
    ! if ( present(Reuse_dimNames) ) myReuse_dimNames = Reuse_dimNames
d1379 2
a1380 2
        call SaveAsHDF5DS (L2AUXFile%FileID%f_id, trim(dataProduct%name), &
         & real(l2aux%values, r4))
a1382 2
        ! call Build_MLSAuxData(l2FileHandle, dataProduct, l2aux%values)
        ! call SaveAsHDF5DS (l2FileHandle, trim(dataProduct%name), l2aux%values)
d1601 1
a1601 1
    use MLSHDF5, only: makeHDF5Attribute
d2058 1
a2058 1
       "$Id: L2AUXData.f90,v 2.99 2016/07/28 01:45:07 vsnyder Exp $"
d2070 3
@


2.99
log
@Refactor dump and diff
@
text
@d14 27
a40 27
  use allocate_deallocate, only: allocate_test, deallocate_test
  use dump_0, only: dump
  use hdf, only: dfacc_create, dfacc_rdonly, dfacc_rdwr, dfnt_float32, &
    & dfnt_int32, sfcreate, sfdimid, sfendacc, sfgdinfo, sfginfo, &
    & sfn2index, sfrdata_f90, sfsdmname, sfsdscale, sfselect, sfwdata_f90
  use init_tables_module, only: l_baseline, l_channel, l_chisqchan, &
    & l_chisqmmaf, l_chisqmmif, l_chunk, l_cloudextinction, &
    & l_cloudinducedradiance, l_cloudradsensitivity, l_cloudwater, &
    & l_dnwt_ajn, l_dnwt_axmax, l_dnwt_cait, l_dnwt_chisqminnorm, &
    & l_dnwt_chisqnorm, l_dnwt_diag, l_dnwt_dxdx, l_dnwt_dxdxl, &
    & l_dnwt_dxn, l_dnwt_dxnl, l_dnwt_flag, l_dnwt_fnmin, l_dnwt_fnorm, &
    & l_dnwt_gdx, l_dnwt_gfac, l_dnwt_gradn, l_dnwt_sq, l_dnwt_sqt, &
    & l_effectiveopticaldepth, l_elevoffset, l_frequency, l_geodangle, &
    & l_height, l_heightoffset, l_intermediatefrequency, l_iteration, &
    & l_jacobian_cols, l_jacobian_rows, l_limbsidebandfraction, &
    & l_lostransfunc, l_losvel, l_lsbfrequency, l_maf, &
    & l_massmeandiameterice, l_massmeandiameterwater, l_mif, &
    & l_mifextinction, l_mifextinctionv2, l_noisebandwidth, l_none, &
    & l_noradspermif, l_numj, l_opticaldepth, l_orbitinclination, l_ascdescmode, &
    & l_phasetiming, l_phitan, l_pressure, l_ptan, l_radiance, &
    & l_reflspill, l_refltemp, l_scanresidual, l_sceci, l_scgeocalt, &
    & l_scveleci, l_scvelecr, l_singlechannelradiance, l_sizedistribution, &
    & l_spaceradiance, l_strayradiance, l_surfacetype, &
    & l_systemtemperature, l_tngteci, l_tngtgeocalt, l_tngtgeodalt, &
    & l_totalextinction, l_usbfrequency, l_vmr, l_xyz
  use intrinsic, only: l_hdf, lit_indices
  use lexer_core, only: print_source
d43 2
a44 2
  use MLSL2options, only: default_hdfversion_read, default_hdfversion_write
  use MLSMessagemodule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate, &
d49 4
a52 4
    & numStringElements, stringElement
  use output_m, only: output
  use quantityTemplates, only: quantityTemplate_t
  use string_table, only: get_string, display_string
d297 2
a298 2
      & MLS_exists, mls_hdf_version, mls_sfstart, mls_sfend
    use MLSHdf5, only: getAllHDF5DSNames, getHDF5Attribute, &
d854 1
a854 1
      & mls_closefile, mls_openfile
d1127 1
a1127 1
  use MLSFiles, only: initializemlsfile
d1204 2
a1205 2
      call WriteL2AUXData_MF_hdf5(l2aux, L2AUXFile, returnStatus, sdName, &
    & NoMAFS, WriteCounterMAF, DimNames, Reuse_dimNames)
a1216 1

d1218 1
a1218 1
    & NoMAFS, WriteCounterMAF, DimNames, Reuse_dimNames)
d1225 1
a1225 1
    use MLS_Dataproducts, only: dataproducts_t
a1233 3
    character (len=*), optional, intent(in) :: DimNames ! Comma-separated list
                                                        ! Otherwise automatic
                                                        ! (Requiring l2cf)
a1235 1
    logical, intent(in), optional :: Reuse_dimNames   ! We already wrote them
a1328 1

d1964 1
a1964 1
       "$Id: L2AUXData.f90,v 2.98 2016/05/19 23:19:02 pwagner Exp $"
d1976 3
@


2.98
log
@Added api for cpL2AUXData
@
text
@d194 1
d293 1
d1970 1
a1970 1
       "$Id: L2AUXData.f90,v 2.97 2015/08/03 21:43:03 pwagner Exp $"
d1982 3
@


2.97
log
@Made quantityType optional in call to ReadL2AUXData
@
text
@d89 2
d1968 1
a1968 1
       "$Id: L2AUXData.f90,v 2.96 2015/03/28 02:47:33 vsnyder Exp $"
d1980 3
@


2.96
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d14 39
a52 39
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DUMP
  use HDF, only: DFACC_CREATE, DFACC_RDonly, DFACC_RDWR, DFNT_FLOAT32, &
    & DFNT_INT32, SFCREATE, SFDIMID, SFENDACC, SFGDINFO, SFGINFO, &
    & SFN2INDEX, SFRDATA_F90, SFSDMNAME, SFSDSCALE, SFSELECT, SFWDATA_F90
  use INIT_TABLES_MODULE, only: L_BASELINE, L_CHANNEL, L_CHISQCHAN, &
    & L_CHISQMMAF, L_CHISQMMIF, L_CHUNK, L_CLOUDEXTINCTION, &
    & L_CLOUDINDUCEDRADIANCE, L_CLOUDRADSENSITIVITY, L_CLOUDWATER, &
    & L_DNWT_AJN, L_DNWT_AXMAX, L_DNWT_CAIT, L_DNWT_CHISQMINNORM, &
    & L_DNWT_CHISQNORM, L_DNWT_DIAG, L_DNWT_DXDX, L_DNWT_DXDXL, &
    & L_DNWT_DXN, L_DNWT_DXNL, L_DNWT_FLAG, L_DNWT_FNMIN, L_DNWT_FNORM, &
    & L_DNWT_GDX, L_DNWT_GFAC, L_DNWT_GRADN, L_DNWT_SQ, L_DNWT_SQT, &
    & L_EFFECTIVEOPTICALDEPTH, L_ELEVOFFSET, L_FREQUENCY, L_GEODANGLE, &
    & L_HEIGHT, L_HEIGHTOFFSET, L_INTERMEDIATEFREQUENCY, L_ITERATION, &
    & L_JACOBIAN_COLS, L_JACOBIAN_ROWS, L_LIMBSIDEBANDFRACTION, &
    & L_LOSTRANSFUNC, L_LOSVEL, L_LSBFREQUENCY, L_MAF, &
    & L_MASSMEANDIAMETERICE, L_MASSMEANDIAMETERWATER, L_MIF, &
    & L_MIFEXTINCTION, L_MIFEXTINCTIONV2, L_NOISEBANDWIDTH, L_NONE, &
    & L_NORADSPERMIF, L_NUMJ, L_OPTICALDEPTH, L_ORBITINCLINATION, L_AscDescMode, &
    & L_PHASETIMING, L_PHITAN, L_PRESSURE, L_PTAN, L_RADIANCE, &
    & L_REFLSPILL, L_REFLTEMP, L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, &
    & L_SCVELECI, L_SCVELECR, L_SINGLECHANNELRADIANCE, L_SIZEDISTRIBUTION, &
    & L_SPACERADIANCE, L_STRAYRADIANCE, L_SURFACETYPE, &
    & L_SYSTEMTEMPERATURE, L_TNGTECI, L_TNGTGEOCALT, L_TNGTGEODALT, &
    & L_TOTALEXTINCTION, L_USBFREQUENCY, L_VMR, L_XYZ
  use INTRINSIC, only: L_HDF, LIT_INDICES
  use LEXER_CORE, only: PRINT_SOURCE
  use MLSCOMMON, only: DEFAULTUNDEFINEDVALUE, MLSFILE_T
  use MLSKINDS, only: R8, R4
  use MLSL2OPTIONS, only: DEFAULT_HDFVERSION_READ, DEFAULT_HDFVERSION_WRITE
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
    & MLSMSG_ERROR, MLSMSG_WARNING
  use MLSSIGNALS_M, only: GETMODULENAME, MODULES
  use MLSSTRINGS, only: LOWERCASE
  use MLSSTRINGLISTS, only: ARRAY2LIST, GETSTRINGELEMENT, LIST2ARRAY, &
    & NUMSTRINGELEMENTS, STRINGELEMENT
  use OUTPUT_M, only: OUTPUT
  use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T
  use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
d71 1
a71 1
! ResizeL2AUXData          Expands an l2aux quantity to take more profiles
d179 1
a179 1
  integer, public, parameter :: MAXNUMSDPERFILE = 200
d192 2
a193 2
    use MLSFILES, only: ARETHESAMEFILE
    use MLSHDF5, only: GETALLHDF5DSNAMES
d274 1
a274 1
      call ReadL2AUXData ( L2AUXFile1, trim(sdName), QuantityType, l2aux, &
d290 6
a295 6
    use Hdf, only: DFACC_READ, DFACC_RDWR
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F, H5DOPEN_F, H5DCLOSE_F
    use MLSFILES, only: FILENOTFOUND, WILDCARDHDFVERSION, &
      & MLS_EXISTS, MLS_HDF_VERSION, MLS_SFSTART, MLS_SFEND
    use MLSHDF5, only: GETALLHDF5DSNAMES, GETHDF5ATTRIBUTE, &
      & ISHDF5ATTRIBUTEPRESENT
d429 1
a429 1
      call ReadL2AUXData ( sdfid1, trim(sdName), QuantityType, l2aux, &
d803 2
a804 2
  subroutine ReadL2AUXData_FileHandle(sd_id, quantityname, quantityType, l2aux, &
    & firstProf, lastProf, checkDimNames, hdfVersion)
d806 1
a806 1
  use MLSFiles, only: INITIALIZEMLSFILE
d815 1
a815 1
    integer, intent(in) :: QuantityType ! Lit index
d822 1
d829 5
d839 3
a841 2
    call ReadL2AUXData(l2auxPointer, quantityname, quantityType, l2aux, firstProf, lastProf, &
      & checkDimNames)
d846 1
a846 1
  subroutine ReadL2AUXData_MLSFile(L2AUXFile, quantityname, quantityType, l2aux,&
d849 3
a851 3
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
      & MLS_CLOSEFILE, MLS_OPENFILE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d860 1
a860 1
    integer, intent(in) :: QuantityType ! Lit index
d869 1
d874 5
d890 1
d1066 1
a1066 1
    use L1BData, only: L1BDATA_T, READL1BDATA
d1103 2
a1104 1
    data_dim_sizes = shape(L1BDATA1%DpField)          
d1123 1
a1123 1
  use MLSFiles, only: INITIALIZEMLSFILE
d1160 3
a1162 3
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
      & MLS_CLOSEFILE, MLS_OPENFILE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d1221 6
a1226 6
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
    use MLS_DATAPRODUCTS, only: DATAPRODUCTS_T
    use MLSAUXDATA, only: BUILD_MLSAUXDATA
    use MLSHDF5, only: ISHDF5ATTRIBUTEPRESENT, MAKEHDF5ATTRIBUTE, SAVEASHDF5DS
    use MLSL2TIMINGS, only: SHOWTIMINGNAMES
    use PCFHDR, only: H5_WRITEGLOBALATTR
d1509 1
a1509 1
    use MLSHDF5, only: MAKEHDF5ATTRIBUTE
d1934 2
a1935 2
    use MLSFiles, only: DUMP
    use TREE, only: Where_At => Where
d1966 1
a1966 1
       "$Id: L2AUXData.f90,v 2.95 2014/09/05 01:03:35 vsnyder Exp $"
d1978 3
@


2.95
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d637 1
a637 1
    endif
d654 1
a654 1
    endif
d669 1
d870 1
a870 1
    endif
d876 1
a876 1
    endif
d1176 1
a1176 1
    endif
d1519 1
a1519 1
    endif
d1951 1
a1951 1
       "$Id: L2AUXData.f90,v 2.94 2014/09/05 00:49:06 vsnyder Exp $"
d1963 3
@


2.94
log
@EmpiricalGeometry.f90
@
text
@d1950 1
a1950 1
       "$Id: L2AUXData.f90,v 2.93 2014/07/18 23:17:11 pwagner Exp $"
d1962 3
@


2.93
log
@Aimed for consistency in names passed to allocate_test
@
text
@d668 2
d687 3
d695 3
d707 1
d1950 1
a1950 1
       "$Id: L2AUXData.f90,v 2.92 2014/04/07 18:06:58 pwagner Exp $"
d1962 3
@


2.92
log
@May specify AscDescMode when DirectWrite-ing swaths
@
text
@d561 10
a570 13
    allocate ( l2aux%values( &
      & dimStarts(1):dimEnds(1), &
      & dimStarts(2):dimEnds(2), &
      & dimStarts(3):dimEnds(3)), STAT=status )
    if ( status/=0 .or. DEEBUG ) then
      print *, 'status: ', status
      print *, 'dimStarts: ', dimStarts
      print *, 'dimEnds: ', dimEnds
    end if
    if ( status/=0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate// "l2aux values" )
    end if
d1941 1
a1941 1
       "$Id: L2AUXData.f90,v 2.91 2014/03/31 23:43:29 pwagner Exp $"
d1953 3
@


2.91
log
@Commented-out unused stuff; renamed procedure ResizeL2AUXData, generalizing it to expand or contract
@
text
@d32 1
a32 1
    & L_NORADSPERMIF, L_NUMJ, L_OPTICALDEPTH, L_ORBITINCLINATION, &
d1818 1
d1944 1
a1944 1
       "$Id: L2AUXData.f90,v 2.90 2013/09/24 23:47:22 vsnyder Exp $"
d1956 3
@


2.90
log
@Use Where instead of Source_Ref for messages
@
text
@d71 1
a71 1
! ExpandL2AUXDataInPlace          Expands an l2aux quantity to take more profiles
d90 1
a90 1
! ExpandL2AUXDataInPlace ( L2AUXData_T l2aux, int newSize )
d104 1
a104 1
  public :: SetupNewL2AUXRecord, DestroyL2AUXContents, ExpandL2AUXDataInPlace
d496 1
a496 1
    integer                         :: option_number   ! (1 or 2; see above)
d500 1
a500 1
      option_number = 1
d503 1
a503 1
      option_number = 1
d595 2
a596 2
  !--------------------------------------  ExpandL2AUXDataInPlace  -----
  subroutine ExpandL2AUXDataInPlace ( l2aux, newSize )
d598 1
a598 1
  ! This subroutine expands an L2AUXData_T in place, allowing the user to
d601 3
d619 1
a619 1
    if (l2aux%dimensions(3)%dimensionFamily==L_None) &
d621 1
a621 1
        & "This l2aux is not expandable")
d625 2
a626 2
    ! Do a sanity check
    if ( newSize<oldSize ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d636 5
a640 1
    l2aux%dimensions(3)%values(1:oldSize)=temp1D
d653 5
a657 1
    l2aux%values(:,:,1:oldSize) = temp3d
d659 1
a659 1
    ! Now we can loose temp3d
d662 1
a662 1
  end subroutine ExpandL2AUXDataInPlace
d905 5
a909 5
    character (LEN=*), parameter :: SZ_ERR = 'Failed to get size of &
      &dimension '
    character (LEN=*), parameter :: MLSMSG_INPUT = 'Error in input argument '
    character (LEN=*), parameter :: MLSMSG_l2auxRead = 'Unable to read l2aux &
      &field:'
d911 1
a911 1
    integer, parameter :: MAXDIMSIZES = 300
d932 1
a932 1
    logical :: firstCheck, lastCheck
d960 2
a961 2
    firstCheck = present(firstProf)
    lastCheck = present(lastProf)
d1220 1
a1220 1
    integer, dimension(3) :: dims
d1223 1
a1223 1
    logical :: myReuse_dimNames
d1231 2
a1232 2
    myReuse_dimNames = .false.
    if ( present(Reuse_dimNames) ) myReuse_dimNames = Reuse_dimNames
d1257 3
a1259 3
      dims(1) = size(l2aux%values, 1)
      dims(2) = size(l2aux%values, 2)
      dims(3) = size(l2aux%values, 3)
d1295 1
a1295 1
      dims(1) = myNoMAFS
d1943 1
a1943 1
       "$Id: L2AUXData.f90,v 2.89 2013/08/31 02:29:12 vsnyder Exp $"
d1955 3
@


2.89
log
@Replace MLSMessageCalls with trace_begin and trace_end
@
text
@a52 1
  use TREE, only: SOURCE_REF
d1900 2
a1901 1
  use MLSFiles, only: DUMP
d1910 1
a1910 1
      call print_source ( source_ref(where) )
d1932 1
a1932 1
       "$Id: L2AUXData.f90,v 2.88 2013/07/19 01:24:29 vsnyder Exp $"
d1944 3
@


2.88
log
@Sort some stuff, revise GetQuantityAttributes a bit more
@
text
@d45 1
a45 1
    & MLSMSG_ERROR, MLSMSG_WARNING, MLSMESSAGECALLS
d744 12
a755 13
      call output ( 'L2AUX Data: ')
      call display_string ( l2aux%name, ierr=ierr )
      if ( ierr /= 0 ) call output ( '(not found in string table)')
      if ( myDetails < -1 ) return
      if ( associated(modules) ) then
        call output ( '    instrumentmodule: ')
        call display_string ( modules(l2aux%instrumentmodule)%name, &
          & advance='no', ierr=ierr ) 
        if ( ierr /= 0 ) then
          call output ( ' (not found in string table)', advance='no')
        else
          call output ( l2aux%instrumentmodule, before=' = ', advance='no')
        end if
d757 14
a770 9
      call output ( '', advance='yes')
      call output ( '  Minor Frame? (t/f): ')
      call output ( l2aux%minorframe, advance='no')
      call output ( '  Major Frame? (t/f): ')
      call output ( l2aux%majorframe, advance='yes')
      if ( myDetails < 0 ) return
      do dim=1, l2auxrank
        call output ( '  dimension: ')
        call output ( dim )
d772 10
a781 14
        if ( associated(l2aux%dimensions(dim)%values) ) then
          call output ( '  nValues: ')
          call output ( l2aux%dimensions(dim)%novalues, 3, advance='no')
          call output ( '           ')
          call output ( '  dimension family: ')
          call output ( l2aux%dimensions(dim)%dimensionfamily, 3, advance='yes')
          call dump ( l2aux%dimensions(dim)%values, &
            & 'dim values:', options=options )
         else
          call output ( ' is not associated', advance='yes')
         end if
      end do
      if ( myDetails < 1 ) return
      call dump ( l2aux%values, 'values:', options=options )
d825 3
a827 2
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
    & MLS_CLOSEFILE, MLS_OPENFILE
d840 1
d843 1
d845 1
d847 1
a847 1
    call MLSMessageCalls( 'push', constantName='ReadL2AUXData_MLSFile' )
d873 1
a873 1
    call MLSMessageCalls( 'pop' )
d1128 3
a1130 2
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
    & MLS_CLOSEFILE, MLS_OPENFILE
d1149 2
d1152 1
a1152 1
    call MLSMessageCalls( 'push', constantName='WriteL2AUXData_MLSFile' )
d1177 1
a1177 1
    call MLSMessageCalls( 'pop' )
d1189 6
a1194 6
  use HDF5, only: H5GCLOSE_F, H5GOPEN_F
  use MLS_DATAPRODUCTS, only: DATAPRODUCTS_T
  use MLSAUXDATA, only: BUILD_MLSAUXDATA
  use MLSHDF5, only: ISHDF5ATTRIBUTEPRESENT, MAKEHDF5ATTRIBUTE, SAVEASHDF5DS
  use MLSL2TIMINGS, only: SHOWTIMINGNAMES
  use PCFHDR, only: H5_WRITEGLOBALATTR
d1477 69
a1545 68
  use MLSHDF5, only: MAKEHDF5ATTRIBUTE
  ! Writes the pertinent attributes for an l2aux
  ! Arguments
  integer, intent(in) :: L2FileHandle
  type (L2AUXData_T), intent(inout) :: L2AUX
  character(len=*) :: name
  ! Internal variables
  integer :: dim
  character(len=16), dimension(L2AUXRank) :: dim_name
  character(len=16), dimension(L2AUXRank) :: dim_unit
  character(len=16) :: dim_of_i
  character(len=16) :: framing
  character(len=2) :: i_char
  logical :: is_timing
  integer :: ndims
  character(len=*), parameter :: ottff = '1,2,3,4,5'
  ! Executable
  is_timing = ( index( lowercase(name), 'timing') > 0 )
  if ( is_timing ) then
    l2aux%majorframe = .false.
    l2aux%minorframe = .false.
    l2aux%minorframe = .false.
    l2aux%DIM_Names  = 'chunk,' // name(1:5) // ',none'
    l2aux%DIM_Units  =  'none,none,none'
    l2aux%VALUE_Units=  's'
  endif
  if ( DEEBUG ) then
    call output('Writing attributes to: ', advance='no')
    call output(trim(Name), advance='yes')
  end if
  call MakeHDF5Attribute(L2FileHandle, name, 'Title', name)
  call MakeHDF5Attribute(L2FileHandle, name, 'Units', &
    & trim(l2aux%VALUE_Units))
  call MakeHDF5Attribute(L2FileHandle, name, 'DimensionNames', &
    & trim(l2aux%DIM_Names))
  if ( l2aux%majorframe ) then
    framing = 'major'
  else if ( l2aux%minorframe ) then
    framing = 'minor'
  else
    framing = 'neither'
  end if
  call MakeHDF5Attribute(L2FileHandle, name, 'Framing', trim(framing))
  call MakeHDF5Attribute(L2FileHandle, name, 'InstrumentModule', &
    & l2aux%instrumentmodule)
  call MakeHDF5Attribute(L2FileHandle, name, 'QuantityType', &
    & l2aux%quantitytype)
  call MakeHDF5Attribute(L2FileHandle, name, 'MissingValue', &
    & (/ real(UNDEFINED_VALUE, r8) /) )
  dim_name = ' '
  dim_unit = ' '
  ndims = min( NumStringElements(trim(l2aux%DIM_Names), .true.), L2AUXRank )
  if ( ndims < 1 ) return
  call List2Array(trim(l2aux%DIM_Names), dim_name, .true.)
  call List2Array(trim(l2aux%DIM_Units), dim_unit, .true.)
  ! loop of dimensions
  do dim=1, ndims
    call GetStringElement (ottff, i_char, dim, .true.)
    dim_of_i = 'dim ' // trim(i_char)
    if ( trim(dim_unit(dim)) == ' ' ) dim_unit(dim) = 'none'
    call MakeHDF5Attribute(L2FileHandle, name, trim(dim_of_i), &
      & trim(dim_name(dim)))
    call MakeHDF5Attribute(L2FileHandle, name, trim(dim_of_i) // ' units', &
      & trim(dim_unit(dim)))
    if ( l2aux%dimensions(dim)%noValues > 0 ) then
      if ( AreDimValuesNonTrivial(l2aux%dimensions(dim)%DimensionFamily) ) then
        call MakeHDF5Attribute(L2FileHandle, name, trim(dim_of_i)// ' values', &
        & real(l2aux%dimensions(dim)%values))
d1547 1
a1547 2
    end if
  end do
d1932 1
a1932 1
       "$Id: L2AUXData.f90,v 2.87 2013/07/18 01:10:57 vsnyder Exp $"
d1944 3
@


2.87
log
@Remove scVel since it's ambiguous whether it's ECI or ECR, and nobody
uses it anyway.
@
text
@d16 23
a38 29
  use HDF, only: &
    & DFACC_CREATE, DFACC_RDonly, DFACC_RDWR, DFNT_FLOAT32, DFNT_INT32, &
    & SFCREATE, SFDIMID, SFSDSCALE, &
    & SFENDACC, SFRDATA_F90, SFN2INDEX, SFSELECT, SFGINFO, &
    & SFGDINFO, SFSDMNAME, SFWDATA_F90
  use INIT_TABLES_MODULE, only: &
    L_BASELINE, &
    L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CHUNK, &
    L_CLOUDEXTINCTION, L_CLOUDWATER, &
    L_CLOUDINDUCEDRADIANCE, L_CLOUDRADSENSITIVITY, &
    L_DNWT_AJN, L_DNWT_AXMAX, &
    L_DNWT_CAIT, L_DNWT_CHISQMINNORM, L_DNWT_CHISQNORM, L_DNWT_DIAG, &
    L_DNWT_DXDX, L_DNWT_DXDXL, L_DNWT_DXN, L_DNWT_DXNL, L_DNWT_FLAG, &
    L_DNWT_FNMIN, L_DNWT_FNORM, L_DNWT_GDX, L_DNWT_GFAC, L_DNWT_GRADN, &
    L_DNWT_SQ, L_DNWT_SQT, &
    L_EFFECTIVEOPTICALDEPTH, L_ELEVOFFSET, &
    L_FREQUENCY, L_GEODANGLE, &
    L_HEIGHT, L_HEIGHTOFFSET, L_INTERMEDIATEFREQUENCY, &
    L_ITERATION, L_JACOBIAN_COLS, L_JACOBIAN_ROWS, &
    L_LOSTRANSFUNC, L_LOSVEL, L_LSBFREQUENCY, &
    L_MAF, L_MASSMEANDIAMETERICE, L_MASSMEANDIAMETERWATER, L_MIF, &
    L_NOISEBANDWIDTH, L_NONE, L_NUMJ, L_ORBITINCLINATION, L_OPTICALDEPTH, &
    L_PHITAN, L_PRESSURE, L_PTAN, L_RADIANCE, L_REFLSPILL, L_REFLTEMP, &
    L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, &
    L_SCVELECI, L_SCVELECR, L_SINGLECHANNELRADIANCE, &
    L_LIMBSIDEBANDFRACTION, L_SIZEDISTRIBUTION, &
    L_SPACERADIANCE, L_STRAYRADIANCE, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
    L_TNGTECI, L_TNGTGEOCALT, L_TNGTGEODALT, &
    L_TOTALEXTINCTION, L_USBFREQUENCY, L_VMR, L_XYZ
d225 1
a225 1
    !
d536 1
a536 1
       & framing, extra_name(dimIndex), dim_names )
d876 1
a876 1
    ! This routine reads an l2aux file, returning a filled data structure and the !
d1033 1
a1033 1
    ! This routine reads an l2aux file, returning a filled data structure and the !
d1425 1
a1425 1
    status = sfendacc(sdId)      ! 
d1701 3
a1703 3
    character(len=*), intent(out)      :: framing
    character(len=*), intent(out)      :: units_name
    integer, dimension(3), intent(out) :: dim_names
d1707 1
a1707 1
      character(10) :: Units_Name = ''
d1716 126
a1841 68
    !                                             framing    units           dim_names
    ! Default is                                 'neither', '          ', (/ l_channel, l_MIF, l_MAF /)
      attrib(l_baseline)              = attrib_t('minor  ', 'K         ', (/ l_frequency, l_MIF, l_MAF /) )
      attrib(l_channel)               = attrib_t('major  ', 'channel   ', (/ l_none, l_none, l_none /) )
      attrib(l_chisqchan)             = attrib_t('major  ', 'channel   ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_chisqmmaf)             = attrib_t('major  ', '          ', (/ l_none, l_none, l_MAF /) )
      attrib(l_chisqmmif)             = attrib_t('minor  ', '          ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_chunk)                 = attrib_t('major  ', 'chunk     ', (/ l_none, l_none, l_none /) )
      attrib(l_cloudInducedRadiance)  = attrib_t('minor  ', 'K         ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_cloudExtinction)       = attrib_t('neither', '          ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_cloudRadSensitivity)   = attrib_t('minor  ', 'K         ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_cloudWater)            = attrib_t('neither', '          ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_dnwt_ajn)              = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_ajn)              = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_cait)             = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_chiSqMinNorm)     = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_chiSqNorm)        = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_diag)             = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_dxdx)             = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_dxdxl)            = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_dxn)              = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_dxnl)             = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_flag)             = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_fnmin)            = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_fnorm)            = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_gdx)              = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_gfac)             = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_gradn)            = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_sq)               = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_dnwt_sqt)              = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_effectiveOpticalDepth) = attrib_t('minor  ', '          ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_elevOffset)            = attrib_t('neither', 'deg       ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_frequency)             = attrib_t('major  ', 'frequency ', (/ l_none, l_none, l_none /) )
      attrib(l_geodAngle)             = attrib_t('neither', 'deg       ', (/ l_none, l_none, l_none /) )
      attrib(l_heightOffset)          = attrib_t('minor  ', 'deg       ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_iteration)             = attrib_t('major  ', 'iteration ', (/ l_none, l_none, l_none /) )
      attrib(l_jacobian_cols)         = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_jacobian_rows)         = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_losTransFunc)          = attrib_t('neither', '          ', (/ l_frequency, l_MIF, l_MAF /) )
      attrib(l_losVel)                = attrib_t('minor  ', '          ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_MAF)                   = attrib_t('major  ', 'MAF       ', (/ l_none, l_none, l_none /) )
      attrib(l_MIF)                   = attrib_t('major  ', 'MIF       ', (/ l_none, l_none, l_none /) )
      attrib(l_noiseBandwidth)        = attrib_t('neither', 'MHz       ', (/ l_channel, l_none, l_none /) )
      attrib(l_numJ)                  = attrib_t('neither', '          ', (/ l_none, l_iteration, l_chunk /) )
      attrib(l_opticalDepth)          = attrib_t('minor  ', '          ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_orbitInclination)      = attrib_t('minor  ', 'deg       ', (/ l_none, l_none, l_none /) )
      attrib(l_phiTan)                = attrib_t('minor  ', 'deg       ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_ptan)                  = attrib_t('minor  ', 'log10(hPa)', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_radiance)              = attrib_t('minor  ', 'K         ', (/ l_channel, l_MIF, l_MAF /) )
      attrib(l_singleChannelRadiance) = attrib_t('minor  ', 'K         ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_scanResidual)          = attrib_t('minor  ', 'm         ', (/ l_none, l_MIF, l_MAF /) )
      attrib(l_scECI)                 = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_scVelECI)              = attrib_t('minor  ', 'm/s       ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_scVelECR)              = attrib_t('minor  ', 'm/s       ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_scGeocAlt)             = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_limbSidebandFraction)  = attrib_t('neither', '          ', (/ l_channel, l_none, l_none /) )
      attrib(l_reflSpill)             = attrib_t('major  ', '          ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_reflTemp)              = attrib_t('major  ', '          ', (/ l_none, l_none, l_MAF /) ) ! ??? K ???
      attrib(l_spaceRadiance)         = attrib_t('neither', 'K         ', (/ l_none, l_none, l_none /) )
      attrib(l_strayRadiance)         = attrib_t('major  ', '          ', (/ l_channel, l_none, l_MAF /) ) ! ??? K ???
      attrib(l_surfacetype)           = attrib_t('neither', '          ', (/ l_none, l_none, l_none /) )
      attrib(l_systemTemperature)     = attrib_t('neither', 'K         ', (/ l_channel, l_none, l_none /) )
      attrib(l_tngtECI)               = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_tngtGeodAlt)           = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_tngtGeocAlt)           = attrib_t('minor  ', 'm         ', (/ l_xyz, l_MIF, l_MAF /) )
      attrib(l_totalExtinction)       = attrib_t('neither', '          ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_vmr)                   = attrib_t('neither', 'vmr       ', (/ l_channel, l_none, l_MAF /) )
      attrib(l_xyz)                   = attrib_t('major  ', 'xyz       ', (/ l_none, l_none, l_none /) )
d1845 3
a1847 3
    framing =    attrib(quantityType)%framing
    units_name = attrib(quantityType)%units_name
    dim_names =  attrib(quantityType)%dim_names
d1925 1
a1925 1
       "$Id: L2AUXData.f90,v 2.86 2012/01/25 01:16:41 pwagner Exp $"
d1935 1
a1935 1
!
d1937 4
d1943 1
a1943 1
!
d1946 1
a1946 1
!
d1949 1
a1949 1
!
d1952 1
a1952 1
!
d1955 1
a1955 1
!
d1958 1
a1958 1
!
d1961 1
a1961 1
!
d1964 1
a1964 1
!
d1967 1
a1967 1
!
d1970 1
a1970 1
!
d1973 1
a1973 1
!
d1976 1
a1976 1
!
d1979 1
a1979 1
!
d1982 1
a1982 1
!
d1985 1
a1985 1
!
d1988 1
a1988 1
!
d1991 1
a1991 1
!
d1994 1
a1994 1
!
d1997 1
a1997 1
!
d2000 1
a2000 1
!
d2003 1
a2003 1
!
d2006 1
a2006 1
!
d2009 1
a2009 1
!
d2012 1
a2012 1
!
d2015 1
a2015 1
!
d2018 1
a2018 1
!
d2021 1
a2021 1
!
d2024 1
a2024 1
!
d2027 1
a2027 1
!
d2030 1
a2030 1
!
d2033 1
a2033 1
!
d2036 1
a2036 1
!
d2039 1
a2039 1
!
d2042 1
a2042 1
!
d2045 1
a2045 1
!
d2048 1
a2048 1
!
d2051 1
a2051 1
!
d2054 1
a2054 1
!
d2057 1
a2057 1
!
d2060 1
a2060 1
!
d2063 1
a2063 1
!
d2067 1
a2067 1
!
d2070 1
a2070 1
!
d2073 1
a2073 1
!
d2076 1
a2076 1
!
d2079 1
a2079 1
!
d2082 1
a2082 1
!
d2085 1
a2085 1
!
d2088 1
a2088 1
!
d2091 1
a2091 1
!
d2094 1
a2094 1
!
d2097 1
a2097 1
!
d2100 1
a2100 1
!
d2103 1
a2103 1
!
d2106 1
a2106 1
!
d2109 1
a2109 1
!
d2112 1
a2112 1
!
d2115 1
a2115 1
!
d2118 1
a2118 1
!
d2121 1
a2121 1
!
d2124 1
a2124 1
!
d2127 1
a2127 1
!
d2130 1
a2130 1
!
d2133 1
a2133 1
!
d2136 1
a2136 1
!
d2139 1
a2139 1
!
d2142 1
a2142 1
!
d2145 1
a2145 1
!
d2148 1
a2148 1
!
d2151 1
a2151 1
!
d2154 1
a2154 1
!
d2157 1
a2157 1
!
d2160 1
a2160 1
!
d2163 1
a2163 1
!
d2166 1
a2166 1
!
d2169 1
a2169 1
!
d2174 1
a2174 1
!
d2177 1
a2177 1
!
d2180 1
a2180 1
!
d2183 1
a2183 1
!
d2186 1
a2186 1
!
d2189 1
a2189 1
!
d2192 1
a2192 1
!
d2195 1
a2195 1
!
d2198 1
a2198 1
!
d2201 1
a2201 1
!
d2204 1
a2204 1
!
d2207 1
a2207 1
!
@


2.86
log
@Improved error msg; snipped commented-out lines
@
text
@d39 1
a39 1
    L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, L_SCVEL, &
d1703 2
d1711 81
d1793 3
a1795 205
    units_name = ' '
    select case (quantityType)                                       
    case ( l_baseline )
      framing = 'minor'
      units_name = 'K'
      dim_names = (/ l_frequency, l_MIF, l_MAF /)
    case ( l_channel )  
      framing = 'major'
      units_name = 'channel'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_chisqchan )  
      framing = 'major'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_chisqmmaf )  
      framing = 'major'
      dim_names = (/ l_none, l_none, l_MAF /)                  
    case ( l_chisqmmif )  
      framing = 'minor'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_chunk )  
      framing = 'major'
      units_name = 'chunk'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_cloudInducedRadiance )  
      framing = 'minor'
      units_name = 'K'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_cloudExtinction )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_cloudRadSensitivity )  
      framing = 'minor'
      units_name = 'K'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_cloudWater )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_dnwt_ajn )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_dnwt_axmax )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_dnwt_cait, l_dnwt_chiSqMinNorm, l_dnwt_chiSqNorm, l_dnwt_diag, &
      & l_dnwt_dxdx, l_dnwt_dxdxl, l_dnwt_dxn, l_dnwt_dxnl, l_dnwt_flag, &
      & l_dnwt_fnmin, l_dnwt_fnorm, l_dnwt_gdx, l_dnwt_gfac, l_dnwt_gradn, &
      & l_dnwt_sq, l_dnwt_sqt )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_effectiveOpticalDepth )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_elevOffset )  
      framing = 'neither'
      units_name = 'deg'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_frequency )  
      framing = 'major'
      units_name = 'frequency'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_geodAngle )  
      framing = 'neither'
      units_name = 'deg'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_heightOffset )  
      framing = 'minor'
      units_name = 'deg'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_iteration )  
      framing = 'major'
      units_name = 'iteration'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_jacobian_cols )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_jacobian_rows )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_losTransFunc )  
      framing = 'neither'
      dim_names = (/ l_frequency, l_MIF, l_MAF /)                  
    case ( l_losVel )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_MAF )  
      framing = 'major'
      units_name = 'MAF'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_massMeanDiameterIce )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_massMeanDiameterWater )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_MIF )  
      framing = 'major'
      units_name = 'MIF'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_noiseBandwidth )  
      framing = 'neither'
      units_name = 'MHz'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_numJ )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_opticalDepth )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_orbitInclination )  
      framing = 'minor'
      units_name = 'deg'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_phiTan )  
      framing = 'minor'
      units_name = 'deg'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_ptan )  
      framing = 'minor'
      units_name = 'log10(hPa)'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_radiance )  
      framing = 'minor'
      units_name = 'K'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_singleChannelRadiance )  
      framing = 'minor'
      units_name = 'K'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_sizedistribution )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_scanResidual )  
      framing = 'minor'
      units_name = 'm'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_scECI )  
      framing = 'minor'
      units_name = 'm'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_scVel )  
      framing = 'minor'
      units_name = 'm/s'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_scVelECI )  
      framing = 'minor'
      units_name = 'm/s'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_scVelECR )  
      framing = 'minor'
      units_name = 'm/s'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_scGeocAlt )  
      framing = 'minor'
      units_name = 'm'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_limbSidebandFraction )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_reflSpill )
      framing = 'major'
      dim_names = (/ l_channel, l_none, l_MAF /)
    case ( l_reflTemp )
      framing = 'major'
      dim_names = (/ l_none, l_none, l_MAF /)
    case ( l_spaceRadiance )  
      framing = 'neither'
      units_name = 'K'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_strayRadiance )
      framing = 'major'
      dim_names = (/ l_channel, l_none, l_MAF /)
    case ( l_surfacetype )  
      framing = 'neither'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_systemTemperature )  
      framing = 'neither'
      units_name = 'K'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_tngtECI )  
      framing = 'minor'
      units_name = 'm'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_tngtGeodAlt )  
      framing = 'minor'
      units_name = 'm'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_tngtGeocAlt )  
      framing = 'minor'
      units_name = 'm'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_totalExtinction )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_vmr )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
      units_name = 'vmr'
    case ( l_xyz )  
      framing = 'major'
      units_name = 'xyz'
      dim_names = (/ l_none, l_none, l_none /)                  
    case default                                                     
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    end select                                                       
d1873 1
a1873 1
       "$Id: L2AUXData.f90,v 2.85 2011/07/07 00:39:15 pwagner Exp $"
d1885 3
@


2.85
log
@Accepts options as arg for dumps
@
text
@d175 1
a362 1
    ! if ( present(sdList) ) then
a493 1
    ! integer, dimension(L2AUXRank) :: dimensionFamilies
a518 2
    ! l2aux%dimensions%dimensionFamily = dimensionFamilies
    ! if ( present(quantityType) ) then
a550 1
      ! if ( dimensionFamilies(dimIndex)/=L_None ) then
a1076 1
!   call SetupNewl2auxRecord ( dim_families, data_dim_sizes, (/1,1,1/), l2aux )
d1257 2
a1968 1
!    call print_source ( source_ref(where) )
d1992 1
a1992 1
       "$Id: L2AUXData.f90,v 2.84 2009/06/23 18:46:18 pwagner Exp $"
d2004 3
@


2.84
log
@Prevent Intel from optimizing ident string away
@
text
@d14 4
a17 4
  use Allocate_Deallocate, only: Allocate_test, Deallocate_test
  use Dump_0, only: DUMP
  use Hdf, only: &
    & DFACC_CREATE, DFACC_RDONLY, DFACC_RDWR, DFNT_FLOAT32, DFNT_INT32, &
d45 1
a45 1
  use intrinsic, only: l_hdf, LIT_INDICES
d47 11
a57 10
  use MLSCommon, only: R8, R4, DEFAULTUNDEFINEDVALUE, MLSFile_T
  use MLSL2Options, only: DEFAULT_HDFVERSION_READ, DEFAULT_HDFVERSION_WRITE
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
    & MLSMSG_ERROR, MLSMSG_WARNING, MLSMessageCalls
  use MLSSignals_m, only: GETMODULENAME, MODULES
  use MLSStrings, only: LowerCase
  use MLSStringLists, only: Array2List, GetStringElement, List2Array, &
    & NumStringElements, StringElement
  use Output_M, only: OUTPUT
  use QuantityTemplates, only: QuantityTemplate_T
d59 1
a59 1
  use Tree, only: SOURCE_REF
d100 6
a105 6
! Dump ( l2auxData_T L2aux(:), [char* Name], [int Details] )
!    or Dump ( l2auxData_T L2aux, [int Details] )
! ReadL2AUXData (int sd_id, char* quantityname, l2auxData_T l2aux, 
!    [int firstProf], [int lastProf])
! WriteL2AUXData(l2auxData_T l2aux, int l2FileHandle, int returnStatus, 
!    [char* sdName], [int NoMAFS], [log WriteCounterMAF], [char* DimNames])
d136 1
a136 1
       "$RCSfile: $"
d198 2
a199 3
    use Hdf, only: DFACC_CREATE
    use MLSFILES, only: AreTheSameFile
    use MLSHDF5, only: GetAllHDF5DSNames
d296 1
a296 1
    use Hdf, only: DFACC_READ, DFACC_CREATE, DFACC_RDWR
d299 3
a301 3
      & mls_exists, mls_hdf_version, mls_sfstart, mls_sfend
    use MLSHDF5, only: GetAllHDF5DSNames, GetHDF5Attribute, &
      & IsHDF5AttributePresent
d706 1
a706 1
  subroutine Dump_L2AUX_DataBase ( L2aux, Name, Details )
d712 1
d728 1
a728 1
      call dump(l2aux(i), Details)
d735 1
a735 1
  subroutine Dump_L2AUX ( L2aux, Details )
d744 1
d784 2
a785 1
          call dump ( l2aux%dimensions(dim)%values, 'dim values:' )
d791 1
a791 1
      call dump ( l2aux%values, 'values:' )
d796 2
a797 2
  subroutine ReadL2AUXData_FileHandle(sd_id, quantityname, quantityType, l2aux, firstProf, lastProf, &
    & checkDimNames, hdfVersion)
d836 1
a836 1
    & mls_closeFile, mls_openFile
d883 2
a884 2
  subroutine ReadL2AUXData_MF_hdf4(L2AUXFile, quantityname, quantityType, l2aux, firstProf, lastProf, &
    & checkDimNames )
d891 2
a892 1
    character (LEN=*), intent(IN) :: quantityname ! Name of L2AUX quantity = sdname in writing routine
d1039 2
a1040 2
  subroutine ReadL2AUXData_MF_hdf5(L2AUXFile, quantityname, quantityType, l2aux, firstProf, lastProf, &
    & checkDimNames)
d1053 2
a1054 1
    character (LEN=*), intent(IN) :: quantityname ! Name of L2AUX quantity = sdname in writing routine
d1083 2
a1084 1
     & inputDimSizes=data_dim_sizes, inputDimStarts=(/1,1,1/), inputQuantityType=quantityType )
d1136 1
a1136 1
    & mls_closeFile, mls_openFile
d1193 6
a1198 6
  use HDF5, only: h5gclose_f, h5gopen_f
  use MLS_DataProducts, only: DATAPRODUCTS_T
  use MLSAuxData, only: BUILD_MLSAUXDATA
  use MLSHDF5, only: IsHDF5AttributePresent, MakeHDF5Attribute, SaveAsHDF5DS
  use MLSL2Timings, only: showTimingNames
  use PCFHdr, only: h5_writeglobalattr
d1479 1
a1479 1
  use MLSHDF5, only: MakeHDF5Attribute
d1964 1
a1964 1
  use MLSFiles, only: dump
d1996 1
a1996 1
       "$Id: read_apriori.f90 is it here $"
d2008 3
@


2.83
log
@Removed unused declarations
@
text
@d135 1
a135 1
       "$RCSfile: L2AUXData.f90,v $"
d1987 1
a1988 1
!---------------------------- RCS Ident Info -------------------------------
d1990 2
a1991 3
       "$Id: L2AUXData.f90,v 2.82 2007/08/13 17:39:42 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1993 1
d1995 1
d2002 3
@


2.82
log
@Push some procedures onto new MLSCallStack
@
text
@d197 3
a199 6
    use Hdf, only: DFACC_READ, DFACC_CREATE, DFACC_RDWR
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F, H5DOPEN_F, H5DCLOSE_F
    use MLSFILES, only: FILENOTFOUND, WILDCARDHDFVERSION, &
      & AreTheSameFile, mls_exists, mls_hdf_version, mls_sfstart, mls_sfend
    use MLSHDF5, only: GetAllHDF5DSNames, GetHDF5Attribute, &
      & IsHDF5AttributePresent
a334 1
    character (len=80) :: sdNameNew
d796 1
a796 1
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, INITIALIZEMLSFILE
a1037 1
    use MLSFiles, only: HDFVERSION_5
d1092 1
a1092 1
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, INITIALIZEMLSFILE
d1990 1
a1990 1
       "$Id: L2AUXData.f90,v 2.81 2007/06/21 00:54:08 vsnyder Exp $"
d2001 3
@


2.81
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d50 1
a50 1
    & MLSMSG_ERROR, MLSMSG_WARNING
d854 1
d880 1
d1155 1
d1180 1
d1995 1
a1995 1
       "$Id: L2AUXData.f90,v 2.80 2006/05/19 22:49:15 pwagner Exp $"
d2006 3
@


2.80
log
@May rename copied SDs
@
text
@d397 1
a397 1
	 call h5gOpen_f (sdfid1,'/', grpID, status)
d399 2
a400 2
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
          	& 'Unable to open group to read attribute in l2aux file' )
d417 1
a417 1
	   call h5dOpen_f (grpid,trim(sdName), sd_ID, status)
d419 1
a419 1
	     call MLSMessage ( MLSMSG_Warning, ModuleName, &
d428 1
a428 1
	   call h5dClose_f (sd_ID, status)
d430 1
a430 1
	     call MLSMessage ( MLSMSG_Warning, ModuleName, &
d449 1
a449 1
	 call h5gClose_f (grpID, status)
d451 1
a451 1
	   call MLSMessage ( MLSMSG_Warning, ModuleName, &
d454 1
a454 1
	 status = mls_sfend(sdfid1, hdfVersion=the_hdfVersion)
d458 1
a458 1
	 status = mls_sfend(sdfid2, hdfVersion=the_hdfVersion)
d906 1
a906 1
    logical            :: myCHECKDIMNAMES	! .TRUE. only for actual l2auxfiles
d965 1
a965 1
      dim_id = sfdimid(sds_id, dim-1)		! dim starts from 0
d1232 1
a1232 1
	   call announce_error (0,&
d1395 3
a1397 3
		  		call output("dim name: ")
		  		call output(TRIM(dimName), advance='yes')
		  		call announce_error (  0, &
d1399 1
a1399 1
	     end if
d1404 5
a1408 5
		  		call output("dimID: ")
		  		call output(dimID, advance='yes')
		  		call output("dim name: ")
		  		call output(TRIM(dimName), advance='yes')
		      call announce_error ( 0, &
d1410 1
a1410 1
	     end if
d1422 1
a1422 1
	   call announce_error (0, &
d1431 1
a1431 1
	   call announce_error (0,&
d1455 1
a1455 1
	   call announce_error (0,&
d1464 1
a1464 1
	   call announce_error (0,&
d1961 1
a1961 1
	character(LEN=*), intent(in)    :: full_message
d1991 1
a1991 1
       "$Id: L2AUXData.f90,v 2.79 2006/01/26 00:34:50 pwagner Exp $"
d2002 3
@


2.79
log
@demoted more use statements from module level to speed Lahey compiles
@
text
@d54 1
a54 1
    & NumStringElements
d196 1
a196 1
    & create2, sdList, options)
d215 1
d229 1
d237 2
d287 1
d297 2
a298 1
  subroutine cpL2AUXData_Name(file1, file2, create2, hdfVersion, sdList, options)
d318 1
d333 1
d338 1
d349 2
d442 1
d1991 1
a1991 1
       "$Id: L2AUXData.f90,v 2.78 2005/12/21 18:45:29 pwagner Exp $"
d2002 3
@


2.78
log
@Should recognize but not copy coremetadata, pcf
@
text
@a45 1
  use L1BData, only: L1BDATA_T, READL1BDATA
d1027 1
d1048 1
a1048 1
    type(l1bdata_t)               :: L1BDATA ! Intermediate Result
d1055 1
a1055 1
    CALL ReadL1BData(L2AUXFile, QuantityName, L1bData, NoMAFs, status, &
d1064 1
a1064 1
    data_dim_sizes = shape(L1BDATA%DpField)          
d1070 2
a1071 2
    l2aux%values = L1BDATA%DpField
    deallocate(L1BDATA%DpField, stat=status)
d1979 1
a1979 1
       "$Id: L2AUXData.f90,v 2.77 2005/12/14 01:45:21 pwagner Exp $"
d1990 3
@


2.77
log
@Attribute values to phase, section timing more reasonable
@
text
@d187 4
d201 1
a201 1
      & mls_exists, mls_hdf_version, mls_sfstart, mls_sfend
d259 3
d271 3
a273 1
      if ( QuantityType < 1 ) then
d845 4
d1936 1
a1936 1
      quantityType = -999
d1938 1
a1938 1
      quantityType = -999
d1979 1
a1979 1
       "$Id: L2AUXData.f90,v 2.76 2005/10/11 17:39:58 pwagner Exp $"
d1990 3
@


2.76
log
@Added MLSFile interface to cpL2AUXData
@
text
@d1076 1
a1076 1
    type (L2AUXData_T), intent(in) :: L2AUX
d1114 1
a1114 1
    type (L2AUXData_T), intent(in) :: L2AUX
d1170 1
a1170 1
    type (L2AUXData_T), intent(in) :: L2AUX
d1277 1
a1277 1
    type (L2AUXData_T), intent(in) :: L2AUX
d1453 1
a1453 1
  type (L2AUXData_T), intent(in) :: L2AUX
a1456 1
  integer :: ndims
d1462 2
d1466 9
d1484 1
a1484 1
  if ( l2aux%majorframe) then
d1486 1
a1486 1
  else if ( l2aux%minorframe) then
d1966 1
a1966 1
       "$Id: L2AUXData.f90,v 2.75 2005/09/21 23:17:34 pwagner Exp $"
d1977 3
@


2.75
log
@Unnecessary changes
@
text
@d113 5
a117 1
! public :: GetDimString, GetQuantityAttributes
d190 1
a190 1
  ! ------------------------------------------------- cpL2AUXData  -----
d192 93
a284 1
  subroutine cpL2AUXData(file1, file2, create2, hdfVersion, sdList, options)
d442 1
a442 1
  end subroutine cpL2AUXData
d840 1
a840 1
        & 'Unable to open l2aux file', MLSFile=L2AUXFile)
d1133 1
a1133 1
        & 'Unable to open l2aux file', MLSFile=L2AUXFile)
d1202 4
d1956 1
a1956 1
       "$Id: L2AUXData.f90,v 2.74 2005/08/25 20:21:41 pwagner Exp $"
d1967 3
@


2.74
log
@Ensure returnStatus defined in ReadL2AUXData_MLSFile
@
text
@d206 2
a207 2
    integer, optional, intent(in) :: hdfVersion
    character (len=*), optional, intent(in) :: sdList ! If not all SDs
d1856 1
a1856 1
       "$Id: L2AUXData.f90,v 2.73 2005/08/19 23:27:02 pwagner Exp $"
d1867 3
@


2.73
log
@Uses '*' as wildcard sdList string in cpL2AUXData
@
text
@d45 1
a45 2
  use intrinsic, only: l_hdf, LIT_INDICES !, L_CHANNEL, &
!    & L_MAF, L_MIF, L_NONE
d738 1
a912 6
    !  After reading, detach from hdf interface

    !     status = sfend(sd_id)
    !     if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
    !          &detach from SD file after reading.')

a1273 2
!		  		call MLSMessage ( MLSMSG_Error, ModuleName, &
!          & "Error setting dimension name to SDS l2aux file:")
a1284 2
!		      call MLSMessage ( MLSMSG_Error, ModuleName, &
!          & "Error writing dimension scale in l2auxFile:" )
d1856 1
a1856 1
       "$Id: L2AUXData.f90,v 2.72 2005/08/05 20:38:31 pwagner Exp $"
d1867 3
@


2.72
log
@L2AUXFile arg to ReadL2AUXFile now a pointer
@
text
@d206 1
a206 1
    logical, optional, intent(in) :: create2
d208 1
a208 1
    character (len=*), optional, intent(in) :: sdList
d212 1
d250 4
a253 1
    if ( present(sdList) ) then
d1866 1
a1866 1
       "$Id: L2AUXData.f90,v 2.71 2005/07/06 00:29:26 pwagner Exp $"
d1877 3
@


2.71
log
@optional arg options determines whether cpL2AUXData dumps DS names
@
text
@d697 2
a698 1
    type( MLSFile_T ) :: l2auxFile
d707 2
a708 1
    call ReadL2AUXData(l2AUXFile, quantityname, quantityType, l2aux, firstProf, lastProf, &
d726 1
a726 1
    type(MLSFile_T)                :: L2AUXFile
d767 1
a767 1
    type(MLSFile_T)                :: L2AUXFile
d934 1
a934 1
    type(MLSFile_T)                :: L2AUXFile
d1862 1
a1862 1
       "$Id: L2AUXData.f90,v 2.70 2005/06/22 18:57:01 pwagner Exp $"
d1873 3
@


2.70
log
@Reworded Copyright statement, moved rcs id
@
text
@d133 1
a133 1
       "$RCSfile: $"
d189 1
a189 1
  subroutine cpL2AUXData(file1, file2, create2, hdfVersion, sdList)
d209 1
d212 9
d222 1
d225 1
a225 2
    integer :: grpid
    integer :: sd_id
d228 1
a228 8
    logical :: file_exists
    integer :: file_access
    integer :: noSds
    character (len=MAXSDNAMESBUFSIZE) :: mySdList
    logical, parameter            :: countEmpty = .true.
    type (L2AUXData_T) :: l2aux
    integer :: i
    character (len=80) :: sdName
d233 3
d251 1
a251 1
      call dump(mysdList, 'DS names')
d254 2
a255 2
      call output ( '============ DS names in ', advance='no' )
      call output ( trim(file1) //' ============', advance='yes' )
d261 1
a261 1
        call dump(mysdList, 'DS names')
d1860 1
a1860 1
       "$Id: $"
d1871 3
@


2.69
log
@Interfaces changed to accept MLSFile_T args
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d131 1
a131 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: L2AUXData.f90,v 2.68 2005/03/03 02:10:51 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d133 1
a133 1
       "$RCSfile: L2AUXData.f90,v $"
d1852 5
d1865 3
@


2.68
log
@Remove unused symbols, spiff up some dumps
@
text
@d9 1
a9 1
    & DFNT_FLOAT32, DFNT_INT32, &
d37 1
a37 1
  use intrinsic, only: LIT_INDICES !, L_CHANNEL, &
d41 1
a41 1
  use MLSCommon, only: R8, R4, DEFAULTUNDEFINEDVALUE
d113 10
d125 1
a125 1
       "$Id: L2AUXData.f90,v 2.67 2004/08/19 00:19:28 pwagner Exp $"
a310 1
      ! print *, 'About to read ', trim(sdName)
a313 1
      ! print *, 'About to write ', trim(sdName)
d666 2
a667 2
  !-----------------------------------------------  ReadL2AUXData  -----
  subroutine ReadL2AUXData(sd_id, quantityname, quantityType, l2aux, firstProf, lastProf, &
d670 1
a670 1
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5
d686 2
d691 39
a729 1
    select case (myhdfVersion)
d731 2
a732 2
      call ReadL2AUXData_hdf4(sd_id, quantityname, quantityType, l2aux, firstProf, lastProf, &
    & checkDimNames)
d734 2
a735 2
      call ReadL2AUXData_hdf5(sd_id, quantityname, quantityType, l2aux, firstProf, lastProf, &
    & checkDimNames)
d738 1
d740 3
a742 1
  end subroutine ReadL2AUXData
d744 2
a745 2
  ! -----------------------------------------  ReadL2AUXData_hdf4  -----
  subroutine ReadL2AUXData_hdf4(sd_id, quantityname, quantityType, l2aux, firstProf, lastProf, &
d754 1
a754 1
    integer, intent(IN) :: sd_id ! Returned by sfstart before calling us
d797 1
a797 1
    sds_index = sfn2index(sd_id, quantityname)
d799 1
a799 1
      & 'Failed to get sds_index for '//trim(quantityName) )
d801 1
a801 1
    sds_id = sfselect(sd_id, sds_index)
d803 1
a803 1
      & 'Failed to get sds_id.' )
d809 1
a809 1
      call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to get sf info.')
d812 1
a812 1
        & 'quantityname  fails to match sf info.')
d831 1
a831 1
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
d838 1
a838 1
          call MLSMessage(MLSMSG_Error, ModuleName, msr)
d854 1
a854 1
                & 'Unrecognized dimension in l2aux:'//trim(dim_name) )
d881 1
a881 1
      & 'Failed to read SD.')
d894 1
a894 1
      &end access to sds_id after reading.')
d902 1
a902 1
  end subroutine ReadL2AUXData_hdf4
d905 2
a906 2
  ! -----------------------------------------  ReadL2AUXData_hdf5  -----
  subroutine ReadL2AUXData_hdf5(sd_id, quantityname, quantityType, l2aux, firstProf, lastProf, &
d921 1
a921 1
    integer, intent(IN) :: sd_id ! Returned by sfstart before calling us
d935 1
a935 1
    CALL ReadL1BData(sd_id, QuantityName, L1bData, NoMAFs, status, &
d937 1
a937 1
      & HDFVersion=HDFVERSION_5, dontPad=.true., L2AUX=.true. )
d941 1
a941 1
      & // trim(QuantityName) // ' (perhaps too unlike a radiance)' )
d955 2
a956 2
      & // trim(QuantityName) )
  end subroutine ReadL2AUXData_hdf5
d958 1
a958 1
  ! ---------------------------------------------  WriteL2AUXData  -----
d960 1
a960 1
  subroutine WriteL2AUXData(l2aux, l2FileHandle, returnStatus, sdName, &
d963 1
a963 1
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5
d970 1
a970 1
    integer, intent(in) :: L2FILEHANDLE                 ! From h5fopen or sfstart
d983 1
d987 45
a1031 1
    select case (myhdfVersion)
d1033 1
a1033 1
      call WriteL2AUXData_hdf4(l2aux, l2FileHandle, returnStatus, sdName, &
d1036 1
a1036 1
      call WriteL2AUXData_hdf5(l2aux, l2FileHandle, returnStatus, sdName, &
d1039 2
d1042 4
a1045 1
  end subroutine WriteL2AUXData
d1047 1
a1047 1
  ! ----------------------------------------  WriteL2AUXData_hdf5  -----
d1049 1
a1049 1
  subroutine WriteL2AUXData_hdf5(l2aux, l2FileHandle, returnStatus, sdName, &
d1051 1
a1051 1
  ! Write l2aux to the file with l2FileHandle
d1064 1
a1064 1
    integer, intent(in) :: L2FILEHANDLE                 ! From h5fopen
d1097 1
a1097 1
        & "l2aux values not associated yet " )
d1115 1
a1115 2
        ! call Build_MLSAuxData(l2FileHandle, dataProduct, real(l2aux%values, r4))
        call SaveAsHDF5DS (l2FileHandle, trim(dataProduct%name), &
d1117 1
a1117 1
        call WriteL2AUXAttributes(l2FileHandle, l2aux, trim(dataProduct%name))
d1122 1
a1122 1
      call h5_writeglobalattr(l2FileHandle, skip_if_already_there=.false.)
d1125 1
a1125 1
        call h5gopen_f(l2FileHandle, '/', grp_id, returnstatus)
d1127 1
a1127 1
          & IsHDF5AttributePresent('/', l2FileHandle, 'Phase Names') ) &
d1131 1
a1131 1
          & IsHDF5AttributePresent('/', l2FileHandle, 'Section Names') ) &
d1141 1
a1141 1
        & "Too few MAFs to fake CounterMAFs in l2aux file:  " )
a1148 2
      ! sdId= SFcreate ( l2FileHandle, 'counterMAF', DFNT_INT8, &
      !  & 1, dimSizes)
d1152 1
a1152 3
      ! status= SFWDATA_F90(sdId, (/ 0 /), &
      !  & (/ 1 /) , dimSizes, CounterMAF)
      call Build_MLSAuxData(l2FileHandle, dataProduct, counterMAF, &
d1156 1
a1156 1
  end subroutine WriteL2AUXData_hdf5
d1158 1
a1158 1
  ! ----------------------------------------  WriteL2AUXData_hdf4  -----
d1160 1
a1160 1
  subroutine WriteL2AUXData_hdf4(l2aux, l2FileHandle, returnStatus, sdName, &
d1167 1
a1167 1
    integer, intent(in) :: L2FILEHANDLE
d1230 1
a1230 1
    sdId= SFcreate ( l2FileHandle, nameString, DFNT_FLOAT32, &
d1262 1
a1262 1
          & "Error setting dimension name to SDS l2aux file:")
d1275 1
a1275 1
          & "Error writing dimension scale in l2auxFile:" )
d1291 1
a1291 1
      & "Error writing SDS data to  l2aux file:  " )
d1300 1
a1300 1
      & "Error ending access to the sd  " )
d1308 1
a1308 1
      & "Too few MAFs to fake CounterMAFs in l2aux file:  " )
d1315 1
a1315 1
    sdId= SFcreate ( l2FileHandle, 'counterMAF', DFNT_INT32, &
d1324 1
a1324 1
      & "Error writing counterMAF data to  l2aux file:  " )
d1333 1
a1333 1
      & "Error ending access to the sd  " )
d1338 1
a1338 1
  end subroutine WriteL2AUXData_hdf4
d1816 2
a1817 1
  subroutine ANNOUNCE_ERROR ( WHERE, full_message, CODE )
d1821 1
d1842 1
d1855 3
@


2.67
log
@Tells ReadL1BData to skip warnings about missing counterMAFs
@
text
@d14 2
a15 2
    L_BASELINE, L_BOUNDARYPRESSURE, &
    L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CHUNK, L_CLOUDICE, &
d18 1
a18 1
    L_COLUMNABUNDANCE, L_DNWT_AJN, L_DNWT_AXMAX, &
d23 2
a24 2
    L_EARTHREFL, L_EARTHRADIUS, L_EFFECTIVEOPTICALDEPTH, L_ELEVOFFSET, &
    L_EXTINCTION, L_FREQUENCY, L_GEODALTITUDE, L_GEODANGLE, &
d27 1
a27 1
    L_LOSTRANSFUNC, L_LOSVEL, L_LSBFREQUENCY, L_MAGNETICFIELD, &
d115 1
a115 1
       "$Id: L2AUXData.f90,v 2.66 2004/08/17 17:09:45 pwagner Exp $"
d172 1
a172 1
  ! ---------------------- cpL2AUXData  ---------------------------
d175 1
a175 2
    use Hdf, only: DFACC_READ, DFACC_CREATE, DFACC_RDWR, &
      & DFNT_CHAR8, DFNT_FLOAT32, DFNT_INT32, DFNT_FLOAT64
d181 1
a181 1
    !------------------------------------------------------------------------
a204 1
    integer :: listsize
d220 1
a220 1
    endif
d227 1
a227 1
    endif
d241 2
a242 2
      endif
    endif
d249 1
a249 1
    endif
d252 1
a252 1
    endif
d262 1
a262 1
    endif
d273 1
a273 1
    endif
d282 1
a282 1
      endif
d288 1
a288 1
      endif
d293 1
a293 1
      endif
d300 1
a300 1
      endif
d310 1
a310 1
    enddo
d315 1
a315 1
    endif
d376 1
a376 1
    elseif ( present(inputQuantityType) ) then
d384 1
a384 1
    endif
d391 1
a391 1
    ! endif
d401 1
a401 1
      endif
d405 2
a406 2
      endif
    enddo
d412 1
a412 1
    enddo
d430 1
a430 1
        endif
d446 1
a446 1
    endif
d450 1
a450 1
    endif
d570 1
a570 1
  ! ------------------------------------------ Dump_L2AUX_DataBase ------------
d587 1
a587 1
    endif
d591 1
a591 1
    endif
d598 1
a598 1
  ! ------------------------------------------ Dump_L2AUX ------------
d625 8
a632 7
          & advance='yes', ierr=ierr ) 
        if ( ierr /= 0 ) call output ( '(not found in string table)', &
          & advance='yes')
        call output ( '    (its index): ')
        call output ( l2aux%instrumentmodule, advance='no')
      endif
      call output ( ' ', advance='yes')
d651 2
a652 2
         endif
      enddo
d658 1
a658 1
  !------------------------------------------------ ReadL2AUXData ------------
d693 1
a693 1
  !------------------------------------------------ ReadL2AUXData_hdf4 ------------
d759 1
a759 1
    elseif (sds_name /= quantityname) then
d762 1
a762 1
    endif
d807 1
a807 1
            endif
d809 3
a811 3
        endif
      endif
    enddo
d854 1
a854 1
  !------------------------------------------------ ReadL2AUXData_hdf5 ------------
d907 1
a907 1
  !----------------------------------------------------- WriteL2AUXData ------
d946 1
a946 1
  !----------------------------------------------------- WriteL2AUXData_hdf5 ------
d1003 1
a1003 1
      endif
d1008 1
a1008 1
      endif
d1021 1
a1021 1
      endif
d1035 1
a1035 1
      endif
d1043 1
a1043 1
      endif
d1053 1
a1053 1
      enddo
d1059 1
a1059 1
    endif
d1062 1
a1062 1
  !----------------------------------------------------- WriteL2AUXData_hdf4 ------
d1120 1
a1120 1
    endif
d1131 1
a1131 1
    endif
d1149 1
a1149 1
        elseif ( (dimensionInData > 1) .and. (l2aux%minorFrame) ) then
d1159 1
a1159 1
        endif
d1169 1
a1169 1
	     endif
d1182 1
a1182 1
	     endif
d1184 1
a1184 1
      endif
d1186 1
a1186 1
    endif
d1196 1
a1196 1
    endif
d1205 1
a1205 1
    endif
d1214 1
a1214 1
    endif
d1223 1
a1223 1
    enddo
d1229 1
a1229 1
    endif
d1238 1
a1238 1
    endif
d1244 1
a1244 1
  ! ----------------------------------  WriteL2AUXAttributes  -----
d1265 1
a1265 1
  endif
d1273 1
a1273 1
  elseif ( l2aux%minorframe) then
d1277 1
a1277 1
  endif
d1304 3
a1306 3
      endif
    endif
  enddo
d1309 1
a1309 1
  ! ----------------------------------  GetDimSize  -----
d1345 1
a1345 1
  ! ----------------------------------  GetDimStart  -----
d1367 1
a1367 1
  ! ----------------------------------  GetDimString  -----
d1405 1
a1405 1
  ! ----------------------------------  AreDimValuesNonTrivial  -----
d1422 1
a1422 1
  ! ----------------------------------  GetDimValues  -----
d1442 1
a1442 1
      enddo
d1455 1
a1455 1
  ! ----------------------------------  GetQuantityAttributes  -----
d1678 1
a1678 1
  ! ----------------------------------  GetQuantityTypeFromName  -----
d1696 1
a1696 1
      elseif ( index(trim(myName), 'mmif') > 0 ) then
d1698 1
a1698 1
      elseif ( index(trim(myName), 'chan') > 0 ) then
d1705 2
a1706 2
      endif
    elseif ( index(trim(myName), 'noradspermif') > 0 ) then
d1709 1
a1709 1
    elseif ( index(trim(myName), 'pcf') > 0 ) then
d1711 1
a1711 1
    elseif ( index(trim(myName), 'coremetadata') > 0 ) then
d1715 1
a1715 1
    endif                      
d1756 3
@


2.66
log
@L2AUX files shouldn't need padding when read as l1b
@
text
@d115 1
a115 1
       "$Id: L2AUXData.f90,v 2.65 2004/08/16 23:43:22 livesey Exp $"
d887 1
a887 1
      & HDFVersion=HDFVERSION_5, dontPad=.true. )
d1757 3
@


2.65
log
@Added ability to output minor frame baselines
@
text
@d115 1
a115 1
       "$Id: L2AUXData.f90,v 2.64 2004/08/04 23:19:57 pwagner Exp $"
a884 2
    ! call MLSMessage ( MLSMSG_Error,ModuleName, &
    !      & 'Sorry--unable to read hdf5-formatted l2aux files yet' )
d886 2
a887 1
    & FirstMAF=firstProf, LastMAF=lastProf, NEVERFAIL=NEVERFAIL, HDFVersion=HDFVERSION_5 )
a994 3
	 !  call announce_error (0,&
    !  & "hdf5 version of WriteL2AUXData_hdf5 not ready yet " )
    !  returnStatus = 1
d1757 3
@


2.64
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d115 1
a115 1
       "$Id: L2AUXData.f90,v 2.63 2004/06/29 18:05:26 pwagner Exp $"
d1477 4
d1761 3
@


2.63
log
@May write phase, section names as file-level attributes
@
text
@d41 1
a41 1
  use MLSCommon, only: R8, R4
d46 2
a47 1
  use MLSStrings, only: Array2List, GetStringElement, List2Array, LowerCase, &
d115 1
a115 1
       "$Id: L2AUXData.f90,v 2.62 2004/04/16 00:48:13 livesey Exp $"
d134 1
a134 1
  real, parameter    :: UNDEFINED_VALUE = -999.99 ! Same as %template%badvalue
d1757 3
@


2.62
log
@Added singleChannelRadiance output
@
text
@d114 1
a114 1
       "$Id: L2AUXData.f90,v 2.61 2004/03/08 22:33:29 pwagner Exp $"
d136 3
a139 1

d956 1
d959 2
a960 1
  use MLSHDF5, only: SaveAsHDF5DS
d975 1
d1027 13
d1756 3
@


2.61
log
@Bypass reading QuantityType attribute (why always 0)
@
text
@d32 2
a33 1
    L_SCVELECI, L_SCVELECR, L_LIMBSIDEBANDFRACTION, L_SIZEDISTRIBUTION, &
d114 1
a114 1
       "$Id: L2AUXData.f90,v 2.60 2004/02/26 22:05:06 pwagner Exp $"
d1576 4
d1738 3
@


2.60
log
@Can copy l2aux file w/o knowing ds names; acts more gracefully if no attributes
@
text
@d113 1
a113 1
       "$Id: L2AUXData.f90,v 2.59 2004/02/05 23:36:41 pwagner Exp $"
d228 1
d270 1
a270 1
        & 'No sdNames cp to file--unable to count sdNames in ' // trim(sdList) )
d281 2
a282 2
      ! Get QuantityType attribute
      if ( .not. IsHDF5AttributePresent(sd_id, 'QuantityType') ) then
d292 8
a299 1
      if ( QuantityType < 1 ) cycle
d303 1
d312 1
a312 1
            & 'Unable to close group to read attribute in l2aux file' )
d1733 3
@


2.59
log
@WriteL2AUXAttributes now public
@
text
@d45 1
a45 1
  use MLSStrings, only: Array2List, GetStringElement, List2Array, &
d113 1
a113 1
       "$Id: L2AUXData.f90,v 2.58 2004/01/27 21:38:09 pwagner Exp $"
d176 2
a177 1
    use MLSHDF5, only: GetHDF5Attribute
d229 10
a238 3
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'No way yet to find sdList in ' // trim(File1) )
      return
d281 5
a285 1
      call GetHDF5Attribute ( sd_id, 'QuantityType', QuantityType )
d291 1
d1646 41
d1724 3
@


2.58
log
@Added cpL2AUXData
@
text
@d65 1
d73 1
d103 1
a103 1
  public :: ReadL2AUXData, WriteL2AUXData
d113 1
a113 1
       "$Id: L2AUXData.f90,v 2.57 2003/09/03 05:25:49 livesey Exp $"
d228 3
a230 2
       call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No way yet to find sdList in ' // trim(File1) )
d320 1
a320 1
    ! Quantities can have upto three valid dimensions.  l_none can be used
d1225 4
d1670 3
@


2.57
log
@Bug fix in hdf5 readl2auxdata.
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d99 1
a99 1
  public :: AddL2AUXToDatabase, DestroyL2AUXDatabase, Dump
d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.56 2003/07/15 23:39:47 pwagner Exp $"
d160 4
d166 133
d1663 3
@


2.56
log
@Disabled most printing
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.55 2003/05/30 00:10:02 livesey Exp $"
d692 1
d722 1
a722 1
    & FirstMAF=firstProf, LastMAF=lastProf, NEVERFAIL=NEVERFAIL)
d1526 3
@


2.55
log
@Bug fix with reflTemp
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.54 2003/05/30 00:08:54 livesey Exp $"
d132 1
a132 1

d278 7
a284 1
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d286 1
a286 1

d1525 3
@


2.54
log
@Added antenna loss terms
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.53 2003/05/29 16:43:02 livesey Exp $"
d1437 1
a1437 1
      dim_names = (/ l_channel, l_none, l_MAF /)
d1519 3
@


2.53
log
@Renamed sideband fraction
@
text
@d30 1
a30 1
    L_PHITAN, L_PRESSURE, L_PTAN, L_RADIANCE, &
d33 1
a33 1
    L_SPACERADIANCE, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.52 2003/05/12 02:06:32 livesey Exp $"
d1432 6
d1442 3
d1519 3
@


2.52
log
@Bound r8->r4 conversion
@
text
@d32 1
a32 1
    L_SCVELECI, L_SCVELECR, L_SIDEBANDRATIO, L_SIZEDISTRIBUTION, &
d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.51 2003/04/25 19:55:09 livesey Exp $"
d1429 1
a1429 1
    case ( l_sidebandRatio )  
d1510 3
@


2.51
log
@Added more useful error message
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.50 2003/03/07 00:42:13 pwagner Exp $"
d915 1
d918 1
d1005 1
d1007 2
a1008 1
      & stride(1:noDimensionsUsed), dimSizes, real(l2aux%values))
d1010 1
a1010 1
	   call announce_error (0,&
d1510 3
@


2.50
log
@Abbreviated Units names; removed spaces from attribute names
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.49 2003/02/21 23:42:21 pwagner Exp $"
d577 1
a577 1
      & 'Failed to get sds_index.' )
d1506 3
@


2.49
log
@Also writes Fill Value attribute
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.48 2003/02/12 21:52:34 pwagner Exp $"
d1077 1
a1077 1
  call MakeHDF5Attribute(L2FileHandle, name, 'Dimension Names', &
d1087 1
a1087 1
  call MakeHDF5Attribute(L2FileHandle, name, 'Instrument Module', &
d1089 1
a1089 1
  call MakeHDF5Attribute(L2FileHandle, name, 'Quantity Type', &
d1091 1
a1091 1
  call MakeHDF5Attribute(L2FileHandle, name, 'Missing Value', &
a1102 3
    ! print *, 'dim_of_i: ', dim_of_i
    ! print *, 'dim_name: ', trim(dim_name(dim))
    ! print *, 'trim(dim_of_i) ' // ' units: ', trim(dim_unit(dim))
d1328 1
a1328 1
      units_name = 'degrees'
d1336 1
a1336 1
      units_name = 'degrees'
d1340 1
a1340 1
      units_name = 'degrees'
d1384 1
a1384 1
      units_name = 'degrees'
d1388 1
a1388 1
      units_name = 'degrees'
d1403 1
a1403 1
      units_name = 'meter'
d1407 1
a1407 1
      units_name = 'meter'
d1423 1
a1423 1
      units_name = 'meter'
d1441 1
a1441 1
      units_name = 'meter'
d1445 1
a1445 1
      units_name = 'meter'
d1449 1
a1449 1
      units_name = 'meter'
d1506 3
@


2.48
log
@Renames blank dim units to none
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.47 2003/02/07 21:44:56 pwagner Exp $"
d130 1
d1091 2
d1509 3
@


2.47
log
@Capitalized 1st letter of each attribute name
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.46 2003/01/30 01:02:28 pwagner Exp $"
d850 1
a873 1
      call h5_writeglobalattr(l2FileHandle)
d1100 4
d1506 3
@


2.46
log
@Writing attributes for hdf5 files; global and data set
@
text
@d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.45 2003/01/18 02:37:03 livesey Exp $"
d1073 2
a1074 2
  call MakeHDF5Attribute(L2FileHandle, name, 'name', name)
  call MakeHDF5Attribute(L2FileHandle, name, 'units', &
d1076 1
a1076 1
  call MakeHDF5Attribute(L2FileHandle, name, 'dimension names', &
d1085 2
a1086 2
  call MakeHDF5Attribute(L2FileHandle, name, 'framing', trim(framing))
  call MakeHDF5Attribute(L2FileHandle, name, 'instrument module', &
d1088 1
a1088 1
  call MakeHDF5Attribute(L2FileHandle, name, 'quantity type', &
d1502 3
@


2.45
log
@Made the readl2aux data stuff work from the l2cf by adding the
quantityType argument.
@
text
@d45 2
a46 1
  use MLSStrings, only: Array2List, GetStringElement, NumStringElements
d111 1
a111 1
       "$Id: L2AUXData.f90,v 2.44 2003/01/17 23:11:26 pwagner Exp $"
d135 1
a135 1
     integer :: NOVALUES        ! Length of this dimension
d146 2
a147 1
    integer :: INSTRUMENTMODULE         ! From source vector
d154 1
a154 1
    ! The values of the quantitiy
d786 1
d845 1
d873 1
a873 1
    
d1055 58
d1209 17
d1227 1
a1227 1
  subroutine GetDimValues ( nameType, quantityTemplate, dim_values)
d1255 1
a1255 1
    end select                                                       
d1502 4
@


2.44
log
@Moved most ops out of LoinL2AUXData to SetupL2AUXData
@
text
@d110 1
a110 1
       "$Id: L2AUXData.f90,v 2.43 2003/01/14 00:41:43 pwagner Exp $"
d485 1
a485 1
  subroutine ReadL2AUXData(sd_id, quantityname, l2aux, firstProf, lastProf, &
d497 1
d509 1
a509 1
      call ReadL2AUXData_hdf4(sd_id, quantityname, l2aux, firstProf, lastProf, &
d512 1
a512 1
      call ReadL2AUXData_hdf5(sd_id, quantityname, l2aux, firstProf, lastProf, &
d520 2
a521 2
  subroutine ReadL2AUXData_hdf4(sd_id, quantityname, l2aux, firstProf, lastProf, &
    & checkDimNames)
d530 1
d642 1
a642 1
     & inputDimSizes=data_dim_sizes, inputDimStarts=(/1,1,1/) )
d681 1
a681 1
  subroutine ReadL2AUXData_hdf5(sd_id, quantityname, l2aux, firstProf, lastProf, &
d696 1
d724 1
a724 1
     & inputDimSizes=data_dim_sizes, inputDimStarts=(/1,1,1/) )
d1423 3
@


2.43
log
@Added GetQuantityAttributes and getDimString; new fields in L2AUXData_T
@
text
@d14 1
a14 1
    FIRST_LIT, LAST_LIT, L_BASELINE, L_BOUNDARYPRESSURE, &
a16 1
    L_TOTALEXTINCTION, L_MASSMEANDIAMETERICE, &
d23 5
a27 4
    L_EARTHREFL, L_EARTHRADIUS, L_EFFECTIVEOPTICALDEPTH, &
    L_ELEVOFFSET, L_EXTINCTION, L_FREQUENCY, L_GEODALTITUDE, L_GPH, &
    L_HEIGHT, L_HEIGHTOFFSET, L_ITERATION, L_JACOBIAN_COLS, L_JACOBIAN_ROWS, &
    L_LOSTRANSFUNC, L_LOSVEL, L_MAGNETICFIELD, &
d30 2
a31 2
    L_PHITAN, L_PRESSURE, L_PTAN, L_RADIANCE, L_RHI, &
    L_REFGPH, L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, L_SCVEL, &
d34 2
a35 3
    L_TEMPERATURE, L_TNGTECI, L_TNGTGEOCALT, L_TNGTGEODALT, &
    L_TRUE,&
    L_VMR, L_XYZ
d47 1
d101 1
a101 1
  public :: GetDimString, GetQuantityAttributes
d110 1
a110 1
       "$Id: L2AUXData.f90,v 2.42 2002/12/10 00:41:28 pwagner Exp $"
d160 9
a168 2
  subroutine SetupNewL2AUXRecord ( dimensionFamilies, dimSizes, dimStarts, &
   & l2aux, quantityType )
d171 4
d176 1
d181 11
a191 6
    integer, dimension(L2AUXRank), intent(in) :: dimensionFamilies
    integer, dimension(L2AUXRank), intent(in) :: dimSizes
    integer, dimension(L2AUXRank), intent(in) :: dimStarts
    type (L2AUXData_T), intent(out)           :: l2aux
    integer, optional, intent(in)             :: quantityType

d193 4
d203 1
d205 13
d219 3
a221 3
    l2aux%dimensions%dimensionFamily = dimensionFamilies
    if ( present(quantityType) ) then
      call GetQuantityAttributes( quantityType, &
d223 4
a226 3
      l2aux%dimensions%dimensionFamily = dim_names
    endif
    l2aux%dimensions%noValues = dimSizes
d231 8
d247 1
d253 2
a254 1
      if ( dimensionFamilies(dimIndex)/=L_None ) then
d260 4
d638 3
a640 1
    call SetupNewl2auxRecord ( dim_families, data_dim_sizes, (/1,1,1/), l2aux )
d719 3
a721 1
    call SetupNewl2auxRecord ( dim_families, data_dim_sizes, (/1,1,1/), l2aux )
d1048 58
d1125 2
d1144 33
d1248 4
d1420 3
@


2.42
log
@In principle can now read hdf5-formatted l2aux files; untested; njl has other plans
@
text
@d13 26
a38 2
  use intrinsic, only: LIT_INDICES, L_CHANNEL, &
    & L_MAF, L_MIF, L_NONE
d46 1
a46 1
  use MLSStrings, only: GetStringElement, NumStringElements
d101 1
d110 1
a110 1
       "$Id: L2AUXData.f90,v 2.41 2002/12/07 00:25:42 pwagner Exp $"
d150 2
d154 1
d160 2
a161 1
  subroutine SetupNewL2AUXRecord ( dimensionFamilies, dimSizes, dimStarts, l2aux )
d172 2
a173 1
    type (L2AUXData_T), intent(out) :: l2aux
d178 4
a181 1
    integer, dimension(L2AUXRank) :: dimEnds
d185 5
d191 12
d994 238
d1269 3
@


2.41
log
@Using SaveAsHDF5DS to write l2aux%values; it works
@
text
@d8 4
a11 4
  use Hdf, only: DFACC_READ, &
    & DFNT_FLOAT64, DFNT_FLOAT32, DFNT_INT32, DFNT_INT8, &
    & SFCREATE, SFDIMID, SFSDSCALE, SFEND, &
    & SFENDACC, SFSTART, SFRDATA_F90, SFN2INDEX, SFSELECT, SFGINFO, &
d13 3
a15 2
  use intrinsic, only: LIT_INDICES, L_CHANNEL, L_GEODANGLE, L_LSBFREQUENCY, &
    & L_MAF, L_MIF, L_NONE, L_TIME, L_USBFREQUENCY
d25 1
a25 1
  use Tree, only: DUMP_TREE_NODE, SOURCE_REF
d85 1
a85 1
       "$Id: L2AUXData.f90,v 2.40 2002/12/06 01:06:13 pwagner Exp $"
d307 1
a307 1
    integer :: i, dim
d459 2
a460 2
    integer :: nDims, status
    integer :: start(3), stride(3), edge(3), dims(3)
d582 5
d597 6
d604 20
a623 3
    call MLSMessage ( MLSMSG_Error,ModuleName, &
          & 'Sorry--unable to read hdf5-formatted l2aux files yet' )

d873 1
a873 1
        status=SFSDScale(dimID, dimSizes(dimensionInFile+1), DFNT_FLOAT32,&
d981 3
@


2.40
log
@Finally writes radaiance-like l2aux as hdf5 files
@
text
@d84 1
a84 1
       "$Id: L2AUXData.f90,v 2.39 2002/12/05 19:46:23 pwagner Exp $"
d647 1
d703 3
a705 2
        call Build_MLSAuxData(l2FileHandle, dataProduct, real(l2aux%values, r4), &
        & dims )
d707 2
a708 2
        call Build_MLSAuxData(l2FileHandle, dataProduct, l2aux%values, &
        & dims )
d952 3
@


2.39
log
@Changes to speed up compiling tree-walker
@
text
@d17 1
a17 1
  use MLSL2Options, only: DEFAULT_HDFVERSION_WRITE
d84 1
a84 1
       "$Id: L2AUXData.f90,v 2.38 2002/12/03 18:04:02 pwagner Exp $"
d385 34
d572 24
a595 1
  end subroutine ReadL2AUXData
d643 2
a644 1
  ! (Note that this bogus sd should only be written once for each file)
d666 1
d692 5
a696 1
      dataProduct%data_type = 'double'  ! Depends on type of L2AUXData_T%values
d701 7
a707 2
      call Build_MLSAuxData(l2FileHandle, dataProduct, l2aux%values, &
      & dims )
d950 3
@


2.38
log
@Repaired bug that caused WriteL2AUXData files to be tiny
@
text
@a16 2
  use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
    & MLS_HDF_VERSION
d84 1
a84 1
       "$Id: L2AUXData.f90,v 2.37 2002/12/02 23:42:12 pwagner Exp $"
d544 3
d882 3
@


2.37
log
@Optional param checkDimNames to ReadL2AUXData; defaults to FALSE
@
text
@d86 1
a86 1
       "$Id: L2AUXData.f90,v 2.36 2002/12/02 19:11:13 pwagner Exp $"
d350 9
a358 5
      call output ( '    instrumentmodule: ')
      call display_string ( modules(l2aux%instrumentmodule)%name, advance='yes', ierr=ierr ) 
      if ( ierr /= 0 ) call output ( '(not found in string table)', advance='yes')
      call output ( '    (its index): ')
      call output ( l2aux%instrumentmodule, advance='no')
d496 2
a497 2
              dim_families(1) = l_channel
              data_dim_sizes(1) = dim_size1
d881 3
@


2.36
log
@Corrected data types of counterMAF and dimensions
@
text
@d86 1
a86 1
       "$Id: L2AUXData.f90,v 2.35 2002/11/29 22:46:28 livesey Exp $"
d382 2
a383 1
  subroutine ReadL2AUXData(sd_id, quantityname, l2aux, firstProf, lastProf)
d394 1
d405 1
a405 1
    logical, parameter :: CHECKDIMSIZES = .true.	! .TRUE. only while debugging
d428 2
d488 7
a494 2
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unrecognized dimension in l2aux:'//trim(dim_name) )
d877 3
@


2.35
log
@Various bug fixes / improvements.
@
text
@d8 3
a10 2
  use Hdf, only: DFACC_READ, DFNT_FLOAT64, DFNT_FLOAT32, DFNT_INT8, SFCREATE, SFDIMID, &
    & SFSDSCALE, SFEND, &
d86 1
a86 1
       "$Id: L2AUXData.f90,v 2.34 2002/11/29 18:50:07 livesey Exp $"
d760 1
a760 1
        status=SFSDScale(dimID, dimSizes(dimensionInFile+1), DFNT_FLOAT64,&
d806 1
a806 1
    sdId= SFcreate ( l2FileHandle, 'counterMAF', DFNT_INT8, &
d868 3
@


2.34
log
@Initialised a variable
@
text
@d85 1
a85 1
       "$Id: L2AUXData.f90,v 2.33 2002/11/26 22:16:41 jonathan Exp $"
d382 1
a382 1
    
d396 1
a396 1
         &dimension '
d399 1
a399 1
                                                     &field:'
d413 1
a413 1
    integer :: dim_sizes(MAXRANK), dim_size1
d429 3
a431 3
    if (sds_index == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &get sds_index.')
         
d433 5
a437 5
    if (sds_id == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &get sds_id.')
         
    status = sfginfo(sds_id, sds_name, rank, dim_sizes, data_type, &
    & num_attrs)
d440 1
a440 2
       call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         & get sf info.')
d442 2
a443 2
       call MLSMessage(MLSMSG_Error, ModuleName, 'quantityname &
         & fails to match sf info.')
d453 17
a469 11
    dim_families = 0
    dim_size1 = 0
     do dim=1, rank

    	write(dim_char, '(I1)') dim
    	dim_id = sfdimid(sds_id, dim-1)		! dim starts from 0
        if(dim_id == -1) then

           msr = 'Failed to &
           & get dim_id for dim index number ' // dim_char
           call MLSMessage(MLSMSG_Error, ModuleName, msr)
d471 18
a488 2
            status = sfgdinfo(dim_id, dim_name, dim_size1, data_type, &
            & num_attrs)
a489 14
            if(status == -1) then
                  msr = 'Failed to &
                  & get dim_info for dim index number ' // dim_char
                  call MLSMessage(MLSMSG_Error, ModuleName, msr)
            else
                dim_families(dim) = dim_size1
                if(dim_families(dim) == 0) then
                     msr = 'Failed to &
                     & find ' //dim_name // ' among L2AuxDimNames'
                     call MLSMessage(MLSMSG_Error, ModuleName, msr)
                endif
            endif
         endif
    enddo
d491 1
a491 4

    call SetupNewl2auxRecord ( dim_families, dim_sizes, (/1,1,1/), l2aux )

    ! Allocate temporary arrays
d497 2
a498 2
    call Allocate_test ( tmpValues, max ( dim_sizes(1), 1), &
      & max(dim_sizes(2),1), max(dim_sizes(3),1), &
d501 3
a503 1
    status = sfrdata_f90(sds_id, start, stride, dim_sizes, tmpValues )
d506 2
a507 1
    l2aux%values = tmpValues
d518 1
a518 1
         &end access to sds_id after reading.')
d522 3
a524 3
!     status = sfend(sd_id)
!     if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
!          &detach from SD file after reading.')
d867 3
@


2.33
log
@Comment-out dump_l2aux diagnostics
@
text
@d85 1
a85 1
       "$Id: L2AUXData.f90,v 2.32 2002/11/25 18:04:52 pwagner Exp $"
d454 1
d860 3
@


2.32
log
@Consistent with latest changes to MLSAuxData
@
text
@d85 1
a85 1
       "$Id: L2AUXData.f90,v 2.31 2002/11/22 21:48:02 pwagner Exp $"
d614 1
a614 1
      call Dump_L2AUX(l2AUX)
d818 1
a818 1
    call Dump_L2AUX(l2AUX)
d859 3
@


2.31
log
@Fleshed out WriteL2AUXData_hdf5; untested yet
@
text
@d85 1
a85 1
       "$Id: L2AUXData.f90,v 2.30 2002/11/13 01:09:47 pwagner Exp $"
d564 2
a565 1
  use MLSAuxData, only: BUILD_MLSAUXDATA, DATAPRODUCTS_T
d859 3
@


2.30
log
@Beginnings of attempt to write hdf5 L2AUX; incomplete
@
text
@d85 1
a85 1
       "$Id: L2AUXData.f90,v 2.29 2002/11/08 23:14:41 pwagner Exp $"
d529 1
a529 1
    integer, intent(in) :: L2FILEHANDLE
d564 2
d567 1
a567 1
    integer, intent(in) :: L2FILEHANDLE
d578 7
d586 14
d601 1
a601 1
      & "hdf5 version of WriteL2AUXData_hdf5 not ready yet " )
d603 38
d817 1
d858 3
@


2.29
log
@Should work again with mlsl2
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d16 3
d85 1
a85 1
       "$Id: L2AUXData.f90,v 2.28 2002/11/08 18:25:33 jonathan Exp $"
d523 62
d757 1
a757 1
  end subroutine WriteL2AUXData
d796 3
@


2.28
log
@Changes to allow writing rank 2; also reuse_DimNames
@
text
@d82 1
a82 1
       "$Id: L2AUXData.f90,v 2.27 2002/11/06 02:01:06 livesey Exp $"
d578 7
a584 1
    dimSizes=PACK(l2aux%dimensions(1:noDimensionsUsed)%noValues, goodDim(1:noDimensionsUsed))
d731 3
@


2.27
log
@Changes to fill from l2aux
@
text
@d19 1
a19 1
  use MLSStrings, only: GetStringElement
d82 1
a82 1
       "$Id: L2AUXData.f90,v 2.26 2002/11/06 00:18:37 pwagner Exp $"
d520 1
a520 1
    & NoMAFS, WriteCounterMAF, DimNames)
d533 1
d550 1
d552 1
d558 2
d564 2
d576 1
a576 1
    noDimensionsUsed=COUNT(goodDim)
d578 1
a578 1
    dimSizes=PACK(l2aux%dimensions%noValues, goodDim)
d584 1
d587 1
a587 1
    do dimensionInData=1,L2AUXRank
d633 1
d660 1
d725 3
@


2.26
log
@Can WriteL2AUXData w/o l2cf: useable by small utility programs
@
text
@d82 1
a82 1
       "$Id: L2AUXData.f90,v 2.25 2002/10/08 17:36:21 pwagner Exp $"
d489 2
a490 1
    call Allocate_test ( tmpValues, dim_sizes(1), dim_sizes(2), dim_sizes(3), &
d511 3
a513 3
    status = sfend(sd_id)
    if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         &detach from SD file after reading.')
d715 3
@


2.25
log
@Added idents to survive zealous Lahey optimizer
@
text
@d19 1
a19 1
  use MLSStrings, only: LINEARSEARCHSTRINGARRAY
d26 1
d44 24
d82 1
a82 1
       "$Id: L2AUXData.f90,v 2.24 2002/08/21 01:04:53 livesey Exp $"
d519 1
a519 1
    & NoMAFS, WriteCounterMAF)
d527 3
d584 4
a587 1
        if ( (dimensionInData > 1) .and. (l2aux%minorFrame) ) then
d590 2
d595 2
a597 2
        call get_string (lit_indices(l2aux%dimensions(dimensionInData)%dimensionFamily), &
          & dimName(LEN_TRIM(dimName)+1:))
d714 3
@


2.24
log
@Changed to single precision for data
@
text
@d57 1
a57 1
       "$Id: L2AUXData.f90,v 2.23 2002/08/15 21:47:04 pwagner Exp $"
d61 1
d672 4
d681 3
@


2.23
log
@WriteL2AuxData now returns non-zero status if it fails
@
text
@d8 1
a8 1
  use Hdf, only: DFACC_READ, DFNT_FLOAT64, DFNT_INT8, SFCREATE, SFDIMID, &
d15 1
a15 1
  use MLSCommon, only: R8
d57 1
a57 1
       "$Id: L2AUXData.f90,v 2.22 2001/11/01 21:03:59 pwagner Exp $"
d394 1
d462 10
a471 3
    status = sfrdata_f90(sds_id, start, stride, dim_sizes, l2aux%values)
    if (status == -1) call MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
         & write SD.')
d544 1
a544 1
    sdId= SFcreate ( l2FileHandle, nameString, DFNT_FLOAT64, &
d593 1
a593 1
      & stride(1:noDimensionsUsed), dimSizes, l2aux%values)
d676 3
@


2.22
log
@Uses new sfwdata_f90 generic; added toc
@
text
@d57 1
a57 1
       "$Id: L2AUXData.f90,v 2.21 2001/10/26 23:13:18 pwagner Exp $"
d484 1
a484 1
  subroutine WriteL2AUXData(l2aux, l2FileHandle, sdName, &
d495 1
d572 2
d594 6
a599 1
    status = sfendacc(sdId)
d627 5
a631 1
    
d649 1
a649 1
    call output ( ' OutputAndClose complained: ' )
d668 3
@


2.21
log
@Provides a single dump module interface and details
@
text
@d8 2
a9 1
  use Hdf, only: DFACC_READ, DFNT_FLOAT64, SFCREATE, SFDIMID, SFSDSCALE, SFEND, &
d11 1
a11 1
    & SFGDINFO, SFSDMNAME, SFWDATA
d26 18
d57 1
a57 1
       "$Id: L2AUXData.f90,v 2.20 2001/10/08 23:41:27 pwagner Exp $"
d250 1
a250 1
  ! This subroutine destroys a quantity template database
d484 6
a489 1
  subroutine WriteL2AUXData(l2aux, l2FileHandle, sdName)
d493 2
d509 3
a511 1

d514 6
d564 1
a564 1
	endif
d575 1
a575 1
	endif
d581 1
a581 1
    status= SFWData(sdId, start(1:noDimensionsUsed), &
a585 2
!	   call MLSMessage ( MLSMSG_Error, ModuleName,&
!      & "Error writing SDS data to  l2aux file:  " )
d592 28
d656 3
@


2.20
log
@Improved dump routines
@
text
@d25 10
a34 1
  ! Externals
d38 1
a38 1
       "$Id: L2AUXData.f90,v 2.19 2001/10/05 23:32:27 pwagner Exp $"
d249 1
a249 1
  ! ------------------------------------------ Dump_L2AUX ------------
d251 1
a251 1
  subroutine Dump_L2AUX ( L2aux, Name )
d256 1
d261 10
a270 1
    if ( present(name) ) call output ( name, advance='yes' )
d272 25
d298 3
a300 1
      call display_string ( l2aux(i)%name )
d302 2
a303 2
!      call display_string ( l2aux(i)%instrumentmodule )
      call display_string ( modules(l2aux(i)%instrumentmodule)%name, advance='yes' ) 
d305 1
a305 1
      call output ( l2aux(i)%instrumentmodule, advance='no')
d308 1
a308 1
      call output ( l2aux(i)%minorframe, advance='no')
d310 2
a311 1
      call output ( l2aux(i)%majorframe, advance='yes')
d316 1
a316 1
        if ( associated(l2aux(i)%dimensions(dim)%values) ) then
d318 1
a318 1
          call output ( l2aux(i)%dimensions(dim)%novalues, 3, advance='no')
d321 2
a322 2
          call output ( l2aux(i)%dimensions(dim)%dimensionfamily, 3, advance='yes')
          call dump ( l2aux(i)%dimensions(dim)%values, 'dim values:' )
d324 1
a324 1
        call output ( ' is not associated', advance='yes')
d327 2
a328 1
      call dump ( l2aux(i)%values, 'values:' )
a329 1
    end do
d596 3
@


2.19
log
@Added majorframe to data type; trimmed unused stuff
@
text
@d17 1
a17 1
  use MLSSignals_m, only: GETMODULENAME
d29 1
a29 1
       "$Id: L2AUXData.f90,v 2.18 2001/08/06 18:35:24 pwagner Exp $"
d255 6
a260 2
      call output ( 'INSTRUMENTMODULE: ')
      call display_string ( l2aux(i)%name )
d262 1
a262 1
      call output ( l2aux(i)%minorframe, advance='yes')
d269 10
a278 6
        call output ( '  nValues: ')
        call output ( l2aux(i)%dimensions(dim)%novalues, 3, advance='no')
        call output ( '           ')
        call output ( '  dimension family: ')
        call output ( l2aux(i)%dimensions(dim)%dimensionfamily, 3, advance='yes')
        call dump ( l2aux(i)%dimensions(dim)%values, 'dim values:' )
d549 3
@


2.18
log
@Added dump_l2aux
@
text
@d29 1
a29 1
       "$Id: L2AUXData.f90,v 2.17 2001/07/11 20:50:46 dwu Exp $"
d65 1
d131 1
a131 1
    integer :: status,dim
a153 2
    integer :: Status           ! From ALLOCATE
    integer :: ExpandingDimension
d259 2
a306 1
    character (LEN=80) :: list
d316 1
a316 1
    integer :: alloc_err, first, freq, lev, nDims, size, status
a317 1
    integer :: nFreqs, nLevels, nTimes, nFreqsOr1, nLevelsOr1
a320 2
    real, allocatable :: realFreq(:), realSurf(:), realProf(:), real3(:,:,:)

d541 3
@


2.17
log
@fix problem in readl2auxdata
@
text
@d20 1
a20 1
  use STRING_TABLE, only: GET_STRING
d29 1
a29 1
       "$Id: L2AUXData.f90,v 2.16 2001/05/30 23:53:31 livesey Exp $"
d241 35
d544 3
@


2.16
log
@Changed for new version of L1BData
@
text
@d29 1
a29 1
       "$Id: L2AUXData.f90,v 2.15 2001/05/12 00:18:40 livesey Exp $"
d249 1
a249 1
    character (LEN=*), intent(IN) :: quantityname ! Name of L2AUX quantity
d275 1
a275 1
    integer :: dim_sizes(MAXRANK)
d302 1
a315 1

d318 3
a320 1
    do dim=1, rank
d322 1
a322 1
    	dim_id = sfdimid(sds_id, dim)
d324 1
d329 1
a329 1
            status = sfgdinfo(dim_id, dim_name, dim_sizes(dim), data_type, &
d331 1
d337 1
a337 1
                dim_families(dim) = 0 !LinearSearchStringArray(L2AUXDimNames, dim_name)
d443 1
a443 1
			endif
d454 1
a454 1
		  endif
d509 3
@


2.15
log
@Tidied up issues with array bounds etc.
@
text
@d9 1
a9 1
    & SFENDACC, SFSTART, SFRDATA, SFN2INDEX, SFSELECT, SFGINFO, &
d29 1
a29 1
       "$Id: L2AUXData.f90,v 2.14 2001/05/03 20:32:19 vsnyder Exp $"
d351 1
a351 1
    status = sfrdata(sds_id, start, stride, dim_sizes, l2aux%values)
d505 3
@


2.14
log
@Cosmetic changes
@
text
@d29 1
a29 1
       "$Id: L2AUXData.f90,v 2.13 2001/05/02 22:24:20 pwagner Exp $"
d74 1
a74 1
  subroutine SetupNewL2AUXRecord ( dimensionFamilies, dimSizes, l2aux )
d84 1
d90 1
d96 2
d101 2
a102 1
        allocate (l2aux%dimensions(dimIndex)%values(dimSizes(dimIndex)), &
d114 3
a116 3
         & max(1,l2aux%dimensions(1)%noValues), &
         & max(1,l2aux%dimensions(2)%noValues), &
         & max(1,l2aux%dimensions(3)%noValues)), STAT=status)
d344 1
a344 1
    call SetupNewl2auxRecord ( dim_families, dim_sizes, l2aux )
d505 3
@


2.13
log
@Removed SDPToolkit use
@
text
@d29 1
a29 1
       "$Id: L2AUXData.f90,v 2.12 2001/04/26 02:44:17 vsnyder Exp $"
d144 2
a145 2
    type (L2AUXData_T), intent(inout) :: l2aux
    integer, intent(in) :: newSize
d148 3
a150 1
    integer :: status           ! From ALLOCATE
d152 2
a153 4
    real (r8), dimension(:), pointer :: temp1D
    real (r8), dimension(:,:,:), pointer :: temp3D
    integer :: expandingDimension
    integer :: oldSize
d500 3
@


2.12
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@a19 1
  use SDPToolkit, only: PGS_S_SUCCESS
d29 1
a29 1
       "$Id: $"
d32 1
a32 1
       "$RCSfile: $"
d500 3
@


2.11
log
@Improved an error message
@
text
@d7 1
d11 2
d19 1
d22 1
a22 6
  use tree, only: DUMP_TREE_NODE, SOURCE_REF
  use Output_M, only: OUTPUT
  use Dump_0, only: DUMP
  use intrinsic, only: L_NONE, L_CHANNEL, L_USBFREQUENCY, &
    & L_LSBFREQUENCY, L_MIF, L_MAF, L_GEODANGLE, L_TIME
  use INIT_TABLES_MODULE, only: LIT_INDICES
d28 7
a34 6
  !---------------------------- RCS Ident Info -------------------------------
  character(len=256), private :: Id = &
    & "$Id: L2AUXData.f90,v 2.10 2001/04/10 22:27:47 vsnyder Exp $"
  character(len=*), private, parameter :: ModuleName= &
    & "$RCSfile: L2AUXData.f90,v $"
  !---------------------------------------------------------------------------
d501 3
@


2.10
log
@Nullify explicitly instead of with <initialization> so as not to give
pointers the SAVE attribute.  <initialization> is NOT executed on each
entry to a procedure.
@
text
@d31 1
a31 1
    & "$Id: L2AUXData.f90,v 2.9 2001/04/07 00:14:27 pwagner Exp $"
d477 5
a481 5
	if(where > 0) then
	    call print_source ( source_ref(where) )
		else
    call output ( '(no lcf node available)' )
		endif
d485 9
a493 9
		CALL output("Caused the following error:", advance='yes', &
		& from_where=ModuleName)
		CALL output(trim(full_message), advance='yes', &
		& from_where=ModuleName)
		if(present(code)) then
			select case ( code )
			end select
		endif
    end subroutine ANNOUNCE_ERROR
d501 5
@


2.9
log
@Added announce_error
@
text
@d31 1
a31 1
    & "$Id: L2AUXData.f90,v 2.8 2001/03/15 18:42:29 livesey Exp $"
d151 2
a152 2
    real (r8), dimension(:), pointer :: temp1D=>NULL()
    real (r8), dimension(:,:,:), pointer :: temp3D=>NULL()
d158 2
d173 1
a173 1
    nullify(l2aux%dimensions(3)%values)
d185 1
a185 1
    nullify(l2aux%values)
d209 1
a209 1
    type (L2AUXData_T), dimension(:), pointer :: tempDatabase=>NULL()
d377 1
a377 1
    integer, dimension(:), pointer :: DIMSIZES=>NULL() ! Size of each dimension
d391 1
d501 3
@


2.8
log
@Removed quotes from dimension name prefixes
@
text
@d10 1
d18 1
d31 1
a31 1
    & "$Id: L2AUXData.f90,v 2.7 2001/03/08 02:20:12 livesey Exp $"
d45 3
d389 2
d425 4
a428 1
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d430 3
d436 4
a439 1
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d441 3
d451 2
a452 1
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
d454 3
d465 27
d498 3
@


2.7
log
@Added strip argument to a call to get_string
@
text
@d29 1
a29 1
    & "$Id: L2AUXData.f90,v 2.6 2001/03/06 22:40:47 livesey Exp $"
d411 1
a411 1
          call get_string (l2aux%name, dimName )
d448 3
@


2.6
log
@Working version
@
text
@d29 1
a29 1
    & "$Id: L2AUXData.f90,v 2.5 2001/02/14 23:41:33 livesey Exp $"
d387 1
a387 1
      call get_string ( l2aux%name, nameString )
d448 3
@


2.5
log
@Removed irrelevant numProfs argument
@
text
@a3 1
!=============================================================================
a4 1
!=============================================================================
d7 3
a9 5
  use Hdf, only: DFACC_READ, DFNT_FLOAT64, SFCREATE, SFDIMID, SFEND, &
    & SFENDACC, SFSTART, SFRDATA, sfn2index, sfselect, sfginfo, &
    & sfgdinfo
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    & MLSMSG_Error, MLSMSG_Warning
d11 11
a21 1
  use MLSStrings, only: LinearSearchStringArray
d25 2
d29 1
a29 1
    & "$Id: L2AUXData.f90,v 2.4 2001/01/03 00:46:19 pwagner Exp $"
a33 1

d36 6
d43 1
a43 35
  integer, parameter :: L2AUXNameLen = 80
  integer, parameter :: CCSDSLen = 27

  ! This is a set of possible values for dimension%dimensionFamily

  integer, parameter :: NoL2AUXDimTypes = 7
  integer, parameter :: L2AUXDimNameLen = 25
  character(len=L2AUXDimNameLen), dimension(NoL2AUXDimTypes), parameter :: &
    & L2AUXDimNames= (/ &
       & "MLS Channel             ", &
       & "Intermediate Frequency  ", &
       & "Upper sideband Frequency", &
       & "Lower sideband Frequency", &
       & "Minor Frame             ", &
       & "Major Frame             ", &
       & "Geodetic Angle          " /)
  integer, parameter :: L2AUXDimUnitLen = 10
  character (len=L2AUXDimUnitLen), dimension(NoL2AUXDimTypes), parameter :: &
    & L2AUXDimUnits= (/ &
       & "          ", &
       & "MHz       ", &
       & "MHz       ", &
       & "MHz       ", &
       & "          ", &
       & "          ", &
       & "Degrees   "/)

  integer, parameter :: L2AUXDim_None = 0
  integer, parameter :: L2AUXDim_Channel = 1
  integer, parameter :: L2AUXDim_IntermediateFrequency = 2
  integer, parameter :: L2AUXDim_USBFrequency = 3
  integer, parameter :: L2AUXDim_LSBFrequency = 4
  integer, parameter :: L2AUXDim_MIF = 5
  integer, parameter :: L2AUXDim_MAF = 6
  integer, parameter :: L2AUXDim_GeodAngle = 7
d48 3
a50 3
     integer :: noValues        ! Length of this dimension
     integer :: dimensionFamily ! What is this dimension
     real(r8), dimension(:), pointer :: values ! (noValues)
d58 3
a60 6

    ! A name for the L2AUX quantity, goes into SD name
    integer :: Name              ! String index of name for quantity to
                                 ! be output
    integer :: noDimensionsUsed  ! Number of dimensions used in quantity (max 3)

d62 3
a64 3
    type (L2AUX_Dimension_T), dimension(3) :: dimensions

    real(r8), pointer, dimension(:,:,:) :: values
d68 1
d72 4
a75 4
  ! This first routine sets up the arrays for an l2aux datatype.
  ! The user supplies a set of three dimensionFamilies (e.g. L2AUXDim_MAF)
  ! Quantities can have upto three valid dimensions.  L2AUXDim_None can be used
  ! to indicate later dimensions are invalid.
d78 2
a79 2
    integer, dimension(3), intent(in) :: dimensionFamilies
    integer, dimension(3), intent(in) :: dimSizes
a86 2

    l2aux%noDimensionsUsed = COUNT(dimensionFamilies /= L2AUXDim_None)
d91 3
a93 3
    do dimIndex = 1, 3
      if ( dimensionFamilies(dimIndex)/=L2AUXDim_None ) then
        allocate ( l2aux%dimensions(dimIndex)%values(dimSizes(dimIndex)), &
d105 3
a107 3
         & l2aux%dimensions(1)%noValues, &
         & l2aux%dimensions(2)%noValues, &
         & l2aux%dimensions(3)%noValues), STAT=status)
d121 1
a121 1
    integer :: status
d123 7
a129 8
    deallocate ( l2aux%dimensions(1)%values, &
         & l2aux%dimensions(2)%values, &
         & l2aux%dimensions(3)%values, stat=status)
    if (status /= 0) call MLSMessage ( MLSMSG_Warning, ModuleName, &
         & MLSMSG_DeAllocate // "l2aux%dimensions" ) 
    deallocate ( l2aux%values, stat=status)
    if (status /= 0) call MLSMessage ( MLSMSG_Warning, ModuleName, &
         & MLSMSG_DeAllocate // "l2aux%values" ) 
d146 2
a147 2
    real (r8), dimension(:), pointer :: temp1D
    real (r8), dimension(:,:,:), pointer :: temp3D
d153 3
a155 3
    ! First identity which is the `last' dimension, this is the one to expand

    expandingDimension = l2aux%noDimensionsUsed
d158 1
a158 1
    oldSize = l2aux%dimensions(expandingDimension)%noValues
d164 8
a171 7
    temp1D => l2aux%dimensions(expandingDimension)%values
    l2aux%dimensions(expandingDimension)%noValues = newSize
    allocate ( l2aux%dimensions(expandingDimension)%values(newSize), &
      & STAT=status )
    if (status/=0) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "New dimension information")
    l2aux%dimensions(expandingDimension)%values(1:oldSize)=temp1D
d174 1
a174 1
    ! Now expand the data in this dimension
d176 10
a185 15
    select case (expandingDimension)
    case (1)
      call allocate_test ( l2aux%values, newSize, 1, 1, "l2aux%values", &
        & ModuleName )
      l2aux%values(1:oldSize,:,:) = temp3d
    case(2)
      call allocate_test ( l2aux%values, &
        & l2aux%dimensions(1)%noValues, newSize, 1, "l2aux%values", ModuleName )
      l2aux%values(:,1:oldSize,:) = temp3d
    case(3)
      call allocate_test ( l2aux%values, &
        & l2aux%dimensions(1)%noValues, l2aux%dimensions(2)%noValues, &
        & newSize, "l2aux%values", ModuleName )
      l2aux%values(:,:,1:oldSize) = temp3d
    end select
a187 2
    ! That's it.

d202 1
a202 1
    type (L2AUXData_T), dimension(:), pointer :: tempDatabase
d210 1
a210 1
  SUBROUTINE DestroyL2AUXDatabase ( DATABASE )
d221 1
a221 1
      do l2auxIndex = 1, SIZE(database)
d230 3
a232 6

  ! -------------------------------------------------------------------------

  SUBROUTINE ReadL2AUXData(sd_id, quantityname, l2aux, firstProf, lastProf)
    !------------------------------------------------------------------------

d238 4
a241 4
    CHARACTER (LEN=*), INTENT(IN) :: quantityname ! Name of L2AUX quantity
    INTEGER, INTENT(IN) :: sd_id ! Returned by sfstart before calling us
    INTEGER, INTENT(IN), OPTIONAL :: firstProf, lastProf ! Defaults to first and last
    TYPE( L2AUXData_T ), INTENT(OUT) :: l2aux ! Result
d245 1
a245 1
    CHARACTER (LEN=*), PARAMETER :: SZ_ERR = 'Failed to get size of &
d247 2
a248 2
    CHARACTER (LEN=*), PARAMETER :: MLSMSG_INPUT = 'Error in input argument '
    CHARACTER (LEN=*), PARAMETER :: MLSMSG_l2auxRead = 'Unable to read l2aux &
d250 3
a252 3
    INTEGER, PARAMETER :: MAXRANK = 3
    INTEGER, PARAMETER :: MAXDIMSIZES = 300
    LOGICAL, PARAMETER :: CHECKDIMSIZES = .TRUE.	! .TRUE. only while debugging
d260 2
a261 2
    CHARACTER (LEN=80) :: list
    CHARACTER (LEN=480) :: msr
d263 10
a272 10
    INTEGER :: sds_index, sds_id, rank, data_type, num_attrs, dim, dim_id
    INTEGER :: dim_sizes(MAXRANK)
    INTEGER :: dim_families(MAXRANK)
    CHARACTER (LEN=LEN(quantityname)) :: sds_name
    CHARACTER (LEN=L2AUXDimNameLen) :: dim_name
    CHARACTER (LEN=1)                  :: dim_char

    INTEGER :: alloc_err, first, freq, lev, nDims, size, status
    INTEGER :: start(3), stride(3), edge(3), dims(3)
    INTEGER :: nFreqs, nLevels, nTimes, nFreqsOr1, nLevelsOr1
d274 1
a274 1
    LOGICAL :: firstCheck, lastCheck
d276 1
a276 1
    REAL, ALLOCATABLE :: realFreq(:), realSurf(:), realProf(:), real3(:,:,:)
a279 3
! found below in sfginfo--where we will check it for self consistency
!    l2aux%Name = quantityname

d282 1
a282 1
    IF (sds_index == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d286 1
a286 1
    IF (sds_id == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d291 2
a292 2
    IF (status == -1) THEN
       CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d294 2
a295 2
    ELSEIF (sds_name /= quantityname) THEN
       CALL MLSMessage(MLSMSG_Error, ModuleName, 'quantityname &
d297 1
a297 1
    ENDIF
d301 2
a302 2
    firstCheck = PRESENT(firstProf)
    lastCheck = PRESENT(lastProf)
d307 2
a308 2
    DO dim=1, rank
    	WRITE(dim_char, '(I1)') dim
d310 1
a310 1
        if(dim_id == -1) THEN
d313 2
a314 2
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ELSE
d317 1
a317 1
            IF(status == -1) THEN
d320 4
a323 4
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ELSE
                dim_families(dim) = LinearSearchStringArray(L2AUXDimNames, dim_name)
                IF(dim_families(dim) == 0) THEN
d326 5
a330 5
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
            ENDIF
         ENDIF
    ENDDO
d333 1
a333 1
    CALL SetupNewl2auxRecord ( dim_families, dim_sizes, l2aux )
d341 1
a341 1
    IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d350 1
a350 1
    IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d356 1
a356 1
    IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
d359 82
a440 3
    !-----------------------------
  END SUBROUTINE ReadL2AUXData
  !-----------------------------
d448 3
@


2.4
log
@Changed sfgetinfo to sfginfo
@
text
@d21 1
a21 1
    & "$Id: L2AUXData.f90,v 2.3 2000/12/04 23:34:38 vsnyder Exp $"
d265 1
a265 2
  SUBROUTINE ReadL2AUXData(sd_id, quantityname, l2aux, numProfs, &
       firstProf, lastProf)
a276 1
    INTEGER, INTENT(OUT) :: numProfs ! Number actually read
d407 3
@


2.3
log
@Move more of addItemToDatabase into the include.
@
text
@d10 1
a10 1
    & SFENDACC, SFSTART, SFRDATA, sfn2index, sfselect, sfgetinfo, &
d21 1
a21 1
    & "$Id: L2AUXData.f90,v 2.2 2000/12/04 21:48:29 pwagner Exp $"
d317 1
a317 1
! found below in sfgetinfo--where we will check it for self consistency
d329 1
a329 1
    status = sfgetinfo(sds_id, sds_name, rank, dim_sizes, data_type, &
d409 3
@


2.2
log
@ReadL2AUXData completed
@
text
@d21 1
a21 1
    & "$Id: L2AUXData.f90,v 2.1 2000/12/02 01:12:00 pwagner Exp $"
a237 1
    database(newSize) = item
d409 3
@


2.1
log
@Added ReadL2AUXData
@
text
@d10 2
a11 1
    & SFENDACC, SFSTART, SFRDATA, sfn2index, sfselect, sfgetinfo
d15 1
d21 1
a21 1
    & "$Id: L2AUXData.f90,v 2.0 2000/09/05 18:57:02 ahanzel Exp $"
d36 2
a37 1
  character(len=25), dimension(NoL2AUXDimTypes), parameter :: &
d46 2
a47 1
  character (len=10), dimension(NoL2AUXDimTypes), parameter :: &
d301 1
a301 1
    INTEGER :: sds_index, sds_id, rank, data_type, num_attrs
d305 2
d346 26
d378 6
a383 5
!    nFreqsOr1=MAX(nFreqs,1)
!    nLevelsOr1=MAX(nLevels, 1)
!    ALLOCATE(realProf(numProfs), realSurf(l2aux%nLevels), &
!         realFreq(l2aux%nFreqs), &
!         real3(nFreqsOr1,nLevelsOr1,numProfs), STAT=alloc_err)
d385 1
a385 1
    ! Read the horizontal geolocation fields
d388 1
a388 7
    ! Read the pressures vertical geolocation field, if it exists


    ! Read the frequency geolocation field, if it exists


    ! Read the data fields that may have 1-3 dimensions
d390 3
d394 1
a394 7
    ! Read the data fields that are 1-dimensional


    ! Deallocate local variables


    !  After reading, detach from swath interface
d410 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@d9 2
d19 1
a19 1
    & "$Id: L2AUXData.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
d260 120
d386 3
@


1.1
log
@Initial entry
@
text
@d17 1
a17 1
    & "$Id: L2AUXData.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
d264 3
d270 1
a270 44
! Revision 1.14  2000/06/30 00:39:07  lungu
! Downgraded deallocation errors to warnings.
!
! Revision 1.13  2000/06/19 22:57:08  lungu
! Added status check after each DEALLOCATE.
!
! Revision 1.12  2000/05/17 23:36:58  lungu
! Added check "IF (ASSOCIATED(database))DEALLOCATE(database)" so it doesn't chrash trying to dealocate
! an "empty" database.
!
! Revision 1.11  2000/01/20 00:26:50  livesey
! Added some extra dimensions, took away time, just have geodetic angle
! or MAF now.  Also added the L2AUXDimUnits array.
!
! Revision 1.10  2000/01/19 23:52:15  livesey
! Added the noDimensionsUsed field.
!
! Revision 1.9  2000/01/19 23:45:42  livesey
! Added ExpandL2AUXDataInPlace routine for Join.
!
! Revision 1.8  2000/01/19 21:42:18  livesey
! Just tided up some comments.
!
! Revision 1.7  2000/01/07 23:53:34  livesey
! Nearly integrated, just a few tweaks.
!
! Revision 1.6  1999/12/18 01:06:28  livesey
! Added USE of MLSStrings
!
! Revision 1.5  1999/12/17 21:41:00  livesey
! Added check for duplicate name
!
! Revision 1.4  1999/12/14 00:53:17  livesey
! Changed DOUBLE PRECISION to REAL(r8)
!
! Revision 1.3  1999/12/03 22:25:57  livesey
! Tidied up some of the INTENT stuff
!
! Revision 1.2  1999/12/03 21:22:23  livesey
! Removed old log data
!
! Revision 1.1  1999/12/03 21:22:02  livesey
! First versions, modified from L2GPData module
!
@


