head	2.236;
access;
symbols
	v5-02-NRT-19:2.236
	v6-00:2.236
	v5-02-NRT-18:2.236
	v5-02:2.232
	v5-01-NRT-17:2.236
	v5-01-NRT-16:2.236
	v5-01-NRT-15:2.236
	v5-01-NRT-14:2.235
	neuralnetworks-1-0:2.234.0.4
	cfm-single-freq-0-1:2.234.0.2
	v5-01:2.232
	v5-00:2.232
	v4-23-TA133:2.231.0.2
	mus-emls-1-70:2.225.0.2
	rel-1-0-englocks-work:2.224.0.2
	VUMLS1-00:2.222
	VPL1-00:2.218
	V4-22-NRT-08:2.217
	VAM1-00:2.214
	V4-21:2.212.0.2
	V4-13:2.211
	V4-12:2.207
	V4-11:2.206
	V4-10:2.205
	V3-43:2.172
	M4-00:2.191
	V3-41:2.172
	V3-40-PlusGM57:2.172.0.2
	V2-24-NRT-04:2.170
	V3-33:2.176
	V2-24:2.169
	V3-31:2.176
	V3-30-NRT-05:2.175
	cfm-01-00:2.173
	V3-30:2.172
	V3-20:2.172
	V3-10:2.170
	V2-23-NRT-02:2.170
	V2-23:2.169
	V2-22-NRT-01:2.170
	V2-22:2.169
	V2-21:2.163
	V2-20:2.159
	V2-11:2.153
	V2-10:2.153
	V2-00:2.148
	V1-51:2.129
	V1-50:2.129
	V1-45:2.125
	V1-44:2.124
	V1-43:2.119
	V1-32:2.113
	V1-31:2.110
	V1-30:2.99
	V1-13:2.93
	V1-12:2.93
	V1-11:2.93
	V1-10:2.91
	newfwm-feb03:2.92.0.2
	V1-04:2.71
	V1-03:2.71
	V1-02:2.71
	JointForwardModel:2.75.0.2
	V1-00:2.69
	newfwm-sep01:2.52.0.2
	V0-7:2.52
	V0-5-Level2:2.30
	V0-5-SIPS:2.20
	V0_1:1.16;
locks; strict;
comment	@# @;


2.236
date	2021.08.20.15.58.17;	author pwagner;	state Exp;
branches;
next	2.235;

2.235
date	2021.07.08.23.34.08;	author pwagner;	state Exp;
branches;
next	2.234;

2.234
date	2020.04.30.23.29.42;	author pwagner;	state Exp;
branches;
next	2.233;

2.233
date	2020.04.09.23.17.46;	author pwagner;	state Exp;
branches;
next	2.232;

2.232
date	2019.08.01.23.46.50;	author pwagner;	state Exp;
branches;
next	2.231;

2.231
date	2019.04.11.23.43.43;	author pwagner;	state Exp;
branches;
next	2.230;

2.230
date	2019.03.08.17.15.49;	author pwagner;	state Exp;
branches;
next	2.229;

2.229
date	2019.02.13.17.31.27;	author pwagner;	state Exp;
branches;
next	2.228;

2.228
date	2019.01.31.19.23.05;	author pwagner;	state Exp;
branches;
next	2.227;

2.227
date	2018.12.07.00.20.47;	author pwagner;	state Exp;
branches;
next	2.226;

2.226
date	2018.09.13.20.25.19;	author pwagner;	state Exp;
branches;
next	2.225;

2.225
date	2018.05.22.23.08.40;	author pwagner;	state Exp;
branches;
next	2.224;

2.224
date	2017.12.22.00.32.00;	author pwagner;	state Exp;
branches;
next	2.223;

2.223
date	2017.03.23.16.57.38;	author pwagner;	state Exp;
branches;
next	2.222;

2.222
date	2017.01.25.18.10.22;	author pwagner;	state Exp;
branches;
next	2.221;

2.221
date	2017.01.11.23.56.53;	author pwagner;	state Exp;
branches;
next	2.220;

2.220
date	2016.11.08.17.30.57;	author pwagner;	state Exp;
branches;
next	2.219;

2.219
date	2016.11.04.19.32.11;	author pwagner;	state Exp;
branches;
next	2.218;

2.218
date	2016.05.27.00.05.22;	author pwagner;	state Exp;
branches;
next	2.217;

2.217
date	2016.03.18.18.00.15;	author pwagner;	state Exp;
branches;
next	2.216;

2.216
date	2016.02.29.19.51.07;	author pwagner;	state Exp;
branches;
next	2.215;

2.215
date	2015.10.06.00.22.09;	author pwagner;	state Exp;
branches;
next	2.214;

2.214
date	2015.09.24.22.07.57;	author pwagner;	state Exp;
branches;
next	2.213;

2.213
date	2015.07.16.22.13.15;	author pwagner;	state Exp;
branches;
next	2.212;

2.212
date	2014.12.10.23.04.54;	author pwagner;	state Exp;
branches;
next	2.211;

2.211
date	2014.09.11.18.28.35;	author pwagner;	state Exp;
branches;
next	2.210;

2.210
date	2014.09.05.01.07.49;	author vsnyder;	state Exp;
branches;
next	2.209;

2.209
date	2014.09.05.00.49.07;	author vsnyder;	state Exp;
branches;
next	2.208;

2.208
date	2014.09.02.18.18.23;	author pwagner;	state Exp;
branches;
next	2.207;

2.207
date	2014.06.30.23.26.58;	author pwagner;	state Exp;
branches;
next	2.206;

2.206
date	2014.05.20.23.56.53;	author vsnyder;	state Exp;
branches;
next	2.205;

2.205
date	2014.03.25.18.19.00;	author pwagner;	state Exp;
branches;
next	2.204;

2.204
date	2014.03.20.01.42.32;	author vsnyder;	state Exp;
branches;
next	2.203;

2.203
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.202;

2.202
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.201;

2.201
date	2013.12.12.02.10.58;	author vsnyder;	state Exp;
branches;
next	2.200;

2.200
date	2013.11.26.22.40.51;	author vsnyder;	state Exp;
branches;
next	2.199;

2.199
date	2013.11.04.22.56.59;	author pwagner;	state Exp;
branches;
next	2.198;

2.198
date	2013.10.09.23.46.38;	author vsnyder;	state Exp;
branches;
next	2.197;

2.197
date	2013.09.25.18.51.55;	author pwagner;	state Exp;
branches;
next	2.196;

2.196
date	2013.09.06.20.58.18;	author pwagner;	state Exp;
branches;
next	2.195;

2.195
date	2013.09.04.17.34.52;	author pwagner;	state Exp;
branches;
next	2.194;

2.194
date	2013.08.23.02.52.13;	author vsnyder;	state Exp;
branches;
next	2.193;

2.193
date	2013.08.17.00.22.14;	author pwagner;	state Exp;
branches;
next	2.192;

2.192
date	2013.06.28.19.18.42;	author pwagner;	state Exp;
branches;
next	2.191;

2.191
date	2013.02.12.18.14.38;	author pwagner;	state Exp;
branches;
next	2.190;

2.190
date	2012.12.04.00.16.09;	author pwagner;	state Exp;
branches;
next	2.189;

2.189
date	2012.08.21.23.54.01;	author pwagner;	state Exp;
branches;
next	2.188;

2.188
date	2012.08.16.17.48.47;	author pwagner;	state Exp;
branches;
next	2.187;

2.187
date	2012.07.18.00.39.34;	author pwagner;	state Exp;
branches;
next	2.186;

2.186
date	2012.07.10.15.22.25;	author pwagner;	state Exp;
branches;
next	2.185;

2.185
date	2012.07.02.20.34.41;	author pwagner;	state Exp;
branches;
next	2.184;

2.184
date	2012.06.27.18.02.59;	author pwagner;	state Exp;
branches;
next	2.183;

2.183
date	2012.06.06.20.36.37;	author vsnyder;	state Exp;
branches;
next	2.182;

2.182
date	2012.04.26.23.12.45;	author pwagner;	state Exp;
branches;
next	2.181;

2.181
date	2012.04.20.01.30.38;	author vsnyder;	state Exp;
branches;
next	2.180;

2.180
date	2012.03.28.20.06.44;	author pwagner;	state Exp;
branches;
next	2.179;

2.179
date	2012.02.09.02.45.26;	author vsnyder;	state Exp;
branches;
next	2.178;

2.178
date	2012.02.09.01.48.11;	author vsnyder;	state Exp;
branches;
next	2.177;

2.177
date	2011.06.29.21.43.59;	author pwagner;	state Exp;
branches;
next	2.176;

2.176
date	2010.11.05.22.36.16;	author pwagner;	state Exp;
branches;
next	2.175;

2.175
date	2010.09.17.00.11.19;	author pwagner;	state Exp;
branches;
next	2.174;

2.174
date	2010.08.06.23.08.48;	author pwagner;	state Exp;
branches;
next	2.173;

2.173
date	2010.05.23.03.25.37;	author honghanh;	state Exp;
branches;
next	2.172;

2.172
date	2010.02.02.01.41.03;	author vsnyder;	state Exp;
branches;
next	2.171;

2.171
date	2009.10.21.16.59.10;	author pwagner;	state Exp;
branches;
next	2.170;

2.170
date	2008.01.08.00.22.02;	author pwagner;	state Exp;
branches;
next	2.169;

2.169
date	2007.09.13.21.52.22;	author pwagner;	state Exp;
branches;
next	2.168;

2.168
date	2007.09.06.23.35.16;	author pwagner;	state Exp;
branches;
next	2.167;

2.167
date	2007.08.23.22.18.35;	author pwagner;	state Exp;
branches;
next	2.166;

2.166
date	2007.08.17.00.36.29;	author pwagner;	state Exp;
branches;
next	2.165;

2.165
date	2007.07.27.00.18.20;	author vsnyder;	state Exp;
branches;
next	2.164;

2.164
date	2007.06.07.20.38.45;	author pwagner;	state Exp;
branches;
next	2.163;

2.163
date	2007.02.14.20.48.59;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2007.02.14.17.31.45;	author pwagner;	state Exp;
branches;
next	2.161;

2.161
date	2007.02.07.20.58.03;	author pwagner;	state Exp;
branches;
next	2.160;

2.160
date	2007.01.12.00.35.08;	author pwagner;	state Exp;
branches;
next	2.159;

2.159
date	2006.10.09.18.38.41;	author pwagner;	state Exp;
branches;
next	2.158;

2.158
date	2006.10.05.23.32.14;	author pwagner;	state Exp;
branches;
next	2.157;

2.157
date	2006.09.21.18.46.49;	author pwagner;	state Exp;
branches;
next	2.156;

2.156
date	2006.08.14.16.21.22;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2006.08.10.21.46.49;	author pwagner;	state Exp;
branches;
next	2.154;

2.154
date	2006.08.05.02.13.33;	author vsnyder;	state Exp;
branches;
next	2.153;

2.153
date	2006.07.29.03.42.09;	author vsnyder;	state Exp;
branches;
next	2.152;

2.152
date	2006.07.27.03.49.12;	author vsnyder;	state Exp;
branches;
next	2.151;

2.151
date	2006.07.21.20.10.37;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2006.06.28.00.00.18;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2006.06.24.23.11.29;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2006.04.20.23.22.39;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2006.04.11.23.28.49;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2006.03.04.00.17.20;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2006.02.21.19.15.17;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2006.02.10.21.14.32;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2005.11.17.20.11.46;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2005.09.22.23.38.54;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2005.08.19.23.29.04;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2005.07.21.23.39.49;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2005.06.29.17.57.40;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2005.06.14.20.45.22;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2005.05.31.17.51.17;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2005.04.12.18.12.30;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2005.04.01.00.15.37;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2005.03.15.23.58.42;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2005.03.12.00.49.18;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2005.03.03.00.23.42;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2005.01.22.00.39.08;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2004.12.27.23.05.27;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2004.12.14.21.55.37;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2004.10.30.00.28.00;	author vsnyder;	state Exp;
branches;
next	2.126;

2.126
date	2004.10.11.16.57.03;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2004.08.19.00.20.21;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2004.08.16.17.12.20;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2004.08.05.22.47.47;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2004.08.04.23.19.57;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2004.07.08.22.48.44;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2004.06.29.00.10.17;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2004.04.27.23.50.24;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2004.04.15.22.48.30;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2004.04.06.23.50.09;	author livesey;	state Exp;
branches;
next	2.116;

2.116
date	2004.04.03.05.44.16;	author livesey;	state Exp;
branches;
next	2.115;

2.115
date	2004.03.24.23.54.06;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2004.03.24.01.03.34;	author livesey;	state Exp;
branches;
next	2.113;

2.113
date	2004.02.05.23.26.22;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2004.01.09.00.22.12;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2004.01.07.23.50.16;	author livesey;	state Exp;
branches;
next	2.110;

2.110
date	2003.12.11.22.56.04;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2003.12.07.23.06.29;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2003.12.05.00.40.11;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2003.11.15.00.33.37;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2003.11.14.23.37.13;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2003.11.07.00.46.51;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2003.11.05.21.27.54;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2003.10.21.00.02.32;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2003.10.14.18.17.02;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2003.10.09.23.57.35;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2003.10.09.23.35.21;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2003.09.05.23.22.08;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2003.08.01.20.26.01;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2003.06.13.20.02.50;	author vsnyder;	state Exp;
branches;
next	2.96;

2.96
date	2003.06.09.22.49.33;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2003.05.14.00.59.40;	author livesey;	state Exp;
branches;
next	2.94;

2.94
date	2003.05.13.04.48.20;	author livesey;	state Exp;
branches;
next	2.93;

2.93
date	2003.02.27.18.40.29;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2003.02.08.00.30.57;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2002.12.19.11.54.45;	author livesey;	state Exp;
branches;
next	2.90;

2.90
date	2002.12.10.00.39.06;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2002.12.06.22.33.41;	author livesey;	state Exp;
branches;
next	2.88;

2.88
date	2002.12.05.19.45.20;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2002.12.04.01.18.21;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2002.11.13.01.08.40;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2002.10.30.00.56.51;	author livesey;	state Exp;
branches;
next	2.84;

2.84
date	2002.10.08.17.41.20;	author livesey;	state Exp;
branches;
next	2.83;

2.83
date	2002.10.05.00.44.14;	author livesey;	state Exp;
branches;
next	2.82;

2.82
date	2002.10.03.23.00.03;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2002.09.24.18.17.20;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2002.08.29.21.47.51;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2002.08.21.18.22.26;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2002.08.15.21.48.51;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2002.07.23.23.15.05;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2002.07.18.21.59.28;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2002.05.28.22.34.59;	author livesey;	state Exp;
branches;
next	2.74;

2.74
date	2002.05.24.17.27.18;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2002.05.23.20.57.57;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2002.05.14.00.26.49;	author livesey;	state Exp;
branches;
next	2.71;

2.71
date	2002.04.24.20.21.13;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2002.04.24.16.54.02;	author livesey;	state Exp;
branches;
next	2.69;

2.69
date	2002.03.20.00.48.29;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2002.02.20.00.29.04;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2002.02.12.00.25.00;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2002.02.05.00.44.03;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2002.01.18.18.55.25;	author livesey;	state Exp;
branches;
next	2.64;

2.64
date	2002.01.09.22.56.46;	author livesey;	state Exp;
branches;
next	2.63;

2.63
date	2002.01.09.00.00.48;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2001.12.13.23.21.20;	author livesey;	state Exp;
branches;
next	2.61;

2.61
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2001.11.09.18.12.38;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2001.10.12.23.11.28;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2001.10.09.22.37.55;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2001.10.04.23.50.25;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2001.10.04.00.16.45;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2001.09.28.23.59.20;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2001.09.28.17.50.30;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2001.09.19.23.43.49;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2001.07.19.22.00.09;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2001.07.18.23.56.24;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2001.07.18.00.16.54;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2001.07.16.23.43.15;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2001.05.25.01.03.47;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2001.05.23.23.21.51;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2001.05.23.22.31.30;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2001.05.23.21.59.43;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2001.05.23.01.44.24;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2001.05.18.01.14.21;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2001.05.17.22.34.55;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2001.05.15.23.46.07;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2001.05.11.23.47.00;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2001.05.11.17.34.31;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2001.05.09.23.33.00;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2001.05.08.20.33.41;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2001.05.07.23.30.51;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.07.21.53.28;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2001.05.07.21.05.03;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2001.05.07.18.16.11;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2001.05.07.17.17.31;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2001.05.04.22.55.36;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2001.05.03.01.58.52;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2001.05.02.23.22.48;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2001.05.01.17.51.47;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.28.01.44.47;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.27.20.59.16;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2001.04.24.23.04.42;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2001.04.21.01.44.05;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.21.01.42.21;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.20.20.44.18;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.17.22.08.56;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2001.04.16.23.46.58;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2001.04.06.20.11.53;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.05.01.33.46;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.03.28.01.29.48;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.03.16.21.47.57;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2001.03.14.18.59.03;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.03.08.00.39.37;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.03.02.02.38.17;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.02.28.03.01.48;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.02.28.02.52.32;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.02.28.02.44.24;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.02.28.01.59.29;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.02.23.02.39.56;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.02.23.02.38.34;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.02.22.23.51.00;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.22.23.05.12;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2000.10.12.00.33.47;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.10.12.00.31.50;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.09.08.22.55.56;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.03;	author ahanzel;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.29.23.55.35;	author lungu;	state Exp;
branches;
next	;


desc
@@


2.236
log
@-Salloc prints Memory summary while tracing
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

program MLSL2
  use Allocate_DeAllocate, only: AllocateLogUnit, FinalMemoryReport, &
    & Set_Garbage_Collection, TrackAllocates
  use Call_Stack_M, only: Show_Final_Summary, Show_Sys_Memory, &
    & Sys_Memory_Ch, Sys_Memory_Convert
  use ChunkDivide_M, only: ChunkDivideConfig
  use Declaration_Table, only: Allocate_Decl, DeAllocate_Decl, Dump_Decl
  use Dump_1, only: Dump
  use EmpiricalGeometry, only: DestroyEmpiricalGeometry
  use HDF, only: Dfacc_Rdonly
  use HighOutput, only: Dump, HeadLine, OutputNamedValue
  use Init_Tables_Module, only: Init_Tables
  use Io_Stuff, only: Write_TextFile
  use Intrinsic, only: Get_Type, L_Ascii, L_Tkgen, Lit_Indices
  use L2GPData, only: AvoidUnlimitedDims
  use L2ParInfo, only: Parallel, InitParallel, AccumulateSlaveArguments, &
    & TransmitSlaveArguments
  use LeakCheck_M, only: LeakCheck
  use Lexer_Core, only: Init_Lexer
  use Machine, only: Getarg, Hp, Io_Error, USleep
  use MLSCommon, only: MLSFile_T, MLSNamesAreDebug, MLSNamesAreVerbose
  use MLSFiles, only: FileStringTable, &
    & AddFileToDatabase, DeAllocate_FileDatabase, Dump, &
    & InitializeMLSFile, MLS_OpenFile, MLS_CloseFile
  use MLSHDF5, only: MLS_H5Open, MLS_H5Close
  use MLSL2Options, only: AllocFile, Aura_L1BFiles, &
    & CheckL2CF, CheckLeak, CheckPaths, CountChunks, Current_Version_Id, &
    & Default_HDFVersion_Read, Default_HDFVersion_Write, Do_Dump, Dump_Tree, &
    & DumpOptions, L2cf_Unit, Level1_HDFVersion, MaxChunkSize, MLSL2Message, &
    & Need_L1BFiles, Normal_Exit_Status, NoteFile, NumSwitches, &
    & L2Options, OriginalOptions, &
    & Patch, PhasesToSkip, ProcessOptions, Quit_Error_Threshold, &
    & Recl, RestartWarnings, RunTimeValues, &
    & SectionsToSkip, SectionTimes, SectionTimingUnits, &
    & SharedPCF, ShowDefaults, & ! Sips_Version, &
    & SkipDirectWrites, SkipDirectWritesOriginal, &
    & SlavesCleanUpSelves, SlaveMAF, &
    & SpecialDumpFile, StateFilledBySkippedRetrievals, &
    & StopAfterSection, StopWithError, &
    & Timing, Toolkit, TotalTimes, UniqueID
  use MLSL2Timings, only: Run_Start_Time, Section_Times, Total_Times, &
    & Add_To_Section_Timing, Dump_Section_Timings
  use MLSMessageModule, only: MLSMSG_Debug, &
    & MLSMessageConfig, MLSMSG_Error, MLSMSG_Severity_To_Quit, &
    & MLSMSG_Success, MLSMSG_Warning, DumpConfig, MLSMessage, MLSMessageExit
  use MLSPCF2 ! Everything
  use MLSStrings, only: Trim_Safe
  use MLSStringLists, only: ExpandStringRange, PutHashElement, SwitchDetail
  use Output_M, only: Blanks, FlushStdout, Output, &
    & BothPrUnit, InvalidPrUnit, MSGLogPrUnit, OutputOptions, PrUnitName, &
    & SetOutputStatus, StampOptions, StdoutPrUnit, SwitchOutput, RevertOutput
  use Parser, only: Clean_Up_Parser, Configuration
  use Parser_Table_M, only: Destroy_Parser_Table, Parser_Table_T
  use Parser_Tables_L2cf, only: Init_Parser_Table
  ! use PCFHdr, only: DumpGlobalAttributes
  use Printit_M, only: Set_Config, StdoutLogUnit
  use PVM, only: ClearPVMArgs, FreePVMArgs
  use SDPToolkit, only: PGSD_DEM_30arc, PGSD_DEM_90arc, &
    & PGSD_DEM_Elev, PGSD_DEM_Water_Land, UseSDPToolkit, PGS_DEM_Close
  use String_Table, only: Destroy_Char_Table, Destroy_Hash_Table, &
    & Destroy_String_Table, Get_String, AddinUnit
  use Symbol_Table, only: Destroy_Symbol_Table
  use Time_M, only: SayTime_Config, Time_Config, &
    & Begin, Dump, Finish, SayTime, Time_Now
  use Toggles, only: Levels, Syn, Switches, Toggle
  use Track_M, only: ReportLeaks
  use Tree, only: Allocate_Tree, DeAllocate_Tree, NSons, SubTree
  use Tree_Checker, only: Check_Tree
  use Tree_Walker, only: Walk_Tree_To_Do_MLS_L2

  ! === (start of toc) ===
  !     c o n t e n t s
  !     - - - - - - - -

  ! Main program for level 2 processing
  ! === (end of toc) ===
  ! (It is assumed that mlsl1 has already been run successfully)
  ! Usage:
  ! mlsl2 [options] [<] [l2cf]
  ! where l2cf is an ascii file which comes from one of
  ! (i)   a file named by a line in the pcf
  !        (if and only if toolkit is TRUE)
  ! (ii)  a file named on the command line w/o the '<' redirection
  ! (iii) stdin or a file redirected as stdin using '<'
  ! and where we expand 'mlsl2 [options]' below
  ! mlsl2 -slo1 -slo2 .. --mlo1 --mlo2 ..
  !    where slon are single-letter options and mlon are multiletter options
  !    E.g., mlsl2 -m -p --nmeta -Sglo,jac
  !    For a list of available options enter 'mlsl2 --help'
  !    For a list of available switches enter 'mlsl2 -S"?"'
  ! In case the l2cf is named, say, "file_name" by (ii), we will try:
  ! First, to find file_name in the current directory
  ! If that fails, we will try file_name.l2cf in the same directory
  ! If that fails, woe is us and we exit with an error

  ! Overview
  ! Level 2 must accomplish some operational tasks (opening and reading files),
  ! prior to any scientific tasks (processing data)
  ! The operational tasks are under the control of any and all of
  ! (a) hard-wired options (see MLSL2Options module)
  ! (b) command-line options (see /mlspgs/notes/options and
  !         /mlspgs/notes/switches)
  ! (c) the l2cf
  ! (d) the pcf (unless the variable 'pcf' is FALSE)
  ! Tasks
  ! (1) Accept hard-wired options (see module MLSL2OPtions.f90)
  ! (2) Initialize parser structures
  ! (3) Read command-line options
  ! (4) Open the l2cf (if not stdin)
  ! (5) Parse the l2cf
  ! (6) Close the l2cf (if not stdin)
  ! (7) Call walk_tree_to_do_MLS_L2 to do the (mostly) scientific tasks
  ! (8) Close down some remaining things and exit with an appropriate status

  ! Parallel processing
  ! In parallel with this, there is a possible cooperation where
  ! a single master process starts up, then tries to pass messages
  ! to slave processes which may be running. Master and slaves, all,
  ! will be running mlsl2
  ! The interprocess communication is handled by pvm
  !
  ! Three alternatives are available to manage these tasks
  ! (1) "submit", where you specify --submit "command" as
  !       a command-line option, and the master uses "command"
  !       with a generic, non-mlsl2-aware batch queue system;
  !       (this has been successfully tested via --submit mlssubmit)
  ! (2) l2q, where you specify --submit l2q as the command-line option;
  !      l2q is a special-purpose mlsl2-aware executable
  !      (Different from (1), but option line looks like (1))
  ! (3) Direct control, where the master has sole responsibilty for
  !      inquiring from pvm as to available hosts, and using them
  !
  ! Notes on parallel processing:
  ! (a) (1) and (2) may permit more than one master task to run
  !     simultaneously. They require a queue manager to be running already.
  !     In contrast, (3) requires only the pvm demon, but you are limited
  !     to one master at a time
  ! (b) The l2cf must be specified; you can't use stdin (the slaves wouldn't
  !     see the master's stdin)
  implicit none
  ! ********************************************************
  ! Should we move these next 4 to MLSL2Options?
  character(len=*), parameter :: L2CFNameExtension = ".l2cf"
  logical, parameter          :: WaitForscript     = .true.
  logical, parameter          :: Wrap              = .false.
  integer, parameter          :: WrapPastColumn    = 0 ! 140 ! 192
  ! ********************************************************

  integer :: Error                 ! Error flag from check_tree
  integer :: First_Section         ! Index of son of root of first n_cf node
  logical :: garbage_collection_by_dt = .false. ! Collect garbage after each deallocate_test?
  integer :: I                     ! counter for command line arguments
  integer, dimension(1) :: IChunks
  integer :: J                     ! index within option
  character(len=2048) :: Line      ! Into which is read the command args
  character(len=1) :: null
  integer :: Numfiles
  type(Parser_Table_t) :: Parser_Table
  integer :: Root                  ! of the abstract syntax tree
  integer :: Status                ! From OPEN
  real :: T0, T1, T2               ! For timing
  integer :: inunit = -1

!---------------------------- RCS Ident Info ------------------------------
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: MLSL2.f90,v $"
!---------------------------------------------------------------------------

  type (MLSFile_T), dimension(:), pointer ::     FileDatabase
  type (MLSFile_T)                        ::     MLSL2CF
  ! DEM nonsense
  integer, dimension(2) :: resolutionList
  integer   :: numResolutions
  integer, dimension(2) :: layerList
  integer   :: numLayers
  ! Executable
  nullify (FileDatabase)
  null = achar(0)
  !---------------- Task (1) ------------------

  call time_now ( t0 )
  call MLS_H5Open ( error )
  if (error /= 0) then
      call MLSL2Message ( MLSMSG_Error, moduleName, &
        & "Unable to MLS_H5Open" )
      if ( not_used_here() ) print *, "This never gets executed"
  end if
! Initialize the lexer, symbol table, and tree checker's tables:
!  ( Under some circumstances, you may need to increase these )
  call init_lexer ( n_chars=80000, n_symbols=4000, hash_table_size=611957, &
    & DEBUG=0 )
  call allocate_decl ( ndecls=8000 )
  call allocate_tree ( n_tree=2000000 )
! call init_tables ! Postpone this until after toggles get set
  FileStringTable = .true.
  !---------------- Task (2) ------------------
! Where to send output, how severe an error to quit
! call SwitchOutput ( 'stdout' )
! call Dump( OutputOptions )
! call DumpConfig
! call RevertOutput
  outputOptions%prunit = L2Options%Output_print_unit
  MLSMSG_Severity_to_quit = MAX(Quit_Error_Threshold, MLSMSG_Debug+1)
  call set_config ( severity_to_quit = MLSMSG_Severity_to_quit )

! Clear the command line arguments we're going to accumulate to pass
! to slave tasks
  call ClearPVMArgs

  ! We set up a mirror command line for launching slaves
  call getarg ( hp, parallel%executable )

  !---------------- Task (3) ------------------
  !---------------- Task (3a) ------------------
  ! Command line options
  i = 1+hp
  L2Options%Originalcmds = ' '
  do ! Process Lahey/Fujitsu run-time options; they begin with "-Wl,"
    call getarg ( i, line )
    if ( line(1:4) /= '-Wl,' ) exit
    call AccumulateSlaveArguments(line) ! pass them to slave processes
    i = i + 1
  end do
  do ! Process the command line options to set toggles
    call getarg ( i, line )
    ! print *, trim(line)
    if ( len_trim(line) < 1 ) exit
    i = i + 1
    L2Options%Originalcmds = trim(L2Options%Originalcmds) // null // trim(line)
  enddo
  line = processOptions( trim(L2Options%Originalcmds), null )
  OriginalOptions = L2Options
! call SwitchOutput ( 'stdout' )
! call Dump( OutputOptions )
! call DumpConfig
! call RevertOutput
! stop
  if ( line == 'help' ) then
    call option_usage
  elseif( switchDetail(switches, '?') > -1 .or. &
    & switchDetail(switches, 'help') > -1 ) then
    call switch_usage
  end if
  MLSMSG_Severity_to_quit = MAX(Quit_Error_Threshold, MLSMSG_Debug+1)
  ! print *, 'slaveArguments: ', trim(slaveArguments)
  ! The following no longer does anything
  call Set_garbage_collection(garbage_collection_by_dt)

! Done with command-line parameters; enforce cascading negative options
! (waited til here in case any were (re)set on command line)
! print *, 'Enforcing output destinations'! 
! print *, 'tookit: ', toolkit
! print *, 'showDefaults: ', showDefaults
! print *, 'switches: ', trim(switches)

  !---------------- Task (3b) ------------------
  ! Redirecting output and optional logging by the Toolkit
  if ( L2Options%Overridden .and. .not. parallel%slave ) then
    ! Getting these things from L2Options
     call MLSMessage( MLSMSG_Warning, ModuleName, &
      & 'Setting output destination based on L2Options' )
  elseif ( .not. toolkit .or. showDefaults ) then
     outputOptions%prunit = max( StdoutPrUnit, &
       & outputOptions%prunit)   ! stdout or Fortran unit
  else if ( outputOptions%prunit == INVALIDPRUNIT ) then
     call MLSMessage( MLSMSG_Warning, ModuleName, &
      & 'Avoding all output except possibly MLSMessages' )
  else if ( parallel%master ) then
     outputOptions%prunit = BothPrUnit ! MSGLOGPRUNIT   ! output both logged, not sent to stdout
     call set_config( LogFileUnit=BothPrUnit )
  else if ( parallel%slave ) then
     outputOptions%prunit = StdoutPrUnit   ! output sent only to stdout, not logged
     call set_config( useToolkit=.false. )
  end if
  i = SwitchDetail(switches, 'log')
! print *, 'i: ', i
  if( .not. L2Options%Overridden .and. (i == 0 .or. i > 5 .or. .not. toolkit) ) then
     call set_config ( LogFileUnit = StdoutLogUnit ) ! -1
  end if
  if ( i > 9 ) then
    MLSMessageConfig%MaxModuleNameLength   = i - 10
    MLSMessageConfig%MaxSeverityNameLength = i - 10
  endif

  ! Dont log parent module names unless asked by -Sparent
  outputOptions%logparent = ( SwitchDetail(switches, 'parent') > -1 ) 
  ! How to prefix logged messages?
  ! But don't stomp on effect of laconic
  i = SwitchDetail(switches, 'mess')
  select case (i)
  case (0)
    ! Skip writing module names, severity to log file for routine output
    MLSMessageConfig%skipModuleNamesThr = MLSMSG_Warning
    MLSMessageConfig%skipSeverityThr    = MLSMSG_Warning
  case (1)
    ! Skip writing module names to log file for routine output
    MLSMessageConfig%skipModuleNamesThr = MLSMSG_Warning
  case (2)
    ! Skip writing severity to log file for routine output
    MLSMessageConfig%skipSeverityThr    = MLSMSG_Warning
  case default
    ! Write both module names, severity to log file for routine output
    ! unless countermanded by --laconic commandline option
    if ( MLSMessageConfig%skipModuleNamesThr < MLSMSG_Warning) then
      MLSMessageConfig%skipModuleNamesThr = MLSMSG_Success
      MLSMessageConfig%skipSeverityThr    = MLSMSG_Success
    endif
  end select
  
  ! Report on memory usage during traces?
  Show_Final_Summary = ( SwitchDetail(switches, 'alloc') > -1 )
  section_times = sectiontimes
  total_times = totaltimes

  UseSDPToolkit = toolkit    ! Redundant, but may be needed in lib
  ! Try to prevent calls to output being lost 
  ! between output_m and MLSMessage modules
  if ( MLSMessageConfig%LogFileUnit == StdoutLogUnit ) &
    & outputOptions%prunit = StdoutPrUnit

  if ( time_config%use_wall_clock ) call time_now( run_start_time )
  ! If checking paths, run as a single-chunk case in serial mode
  if ( checkPaths ) then
    parallel%master = .false.
    parallel%slave = .false.
    parallel%chunkRange = '1'
    stopWithError = .false.
    ! Nio longer issue warning about l2pc files
    if ( .false. ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
    & 'checkPaths will fail if l2pc files only on local disks but master runs' &
    & // ' on front end' )
  end if
  ! If doing a range of chunks, the avoidance of unlimited dimensions
  ! in directwrites of l2gp files currently fails
  ! (when will this be fixed? By whom? HDF people or us?)
  if ( parallel%chunkRange /= ' ' ) then
    ! avoidUnlimitedDims = .false.
    call ExpandStringRange( parallel%chunkRange, iChunks )
  else
    iChunks = 0
  endif

  outputOptions%parentName = 'MLSL2'
  if ( Wrap ) then
    call SetOutputStatus ( 'wrap', 1 )
    call SetOutputStatus ( 'wrappast', WrapPastColumn )
  endif
  ! stop

  !---------------- Task (3c) ------------------
  ! Are we sharing our PCF with level 1?
  ! Are we part of a parallel run? If so, master or slave?
  ! If sharing a single PCF with level 1, we need to move any "mobile" PCF ids
  if ( sharedPCF ) call MovePCFIDs
  ! Setup the parallel stuff.  Register our presence with the master if we're a
  ! slave.
  if ( parallel%master ) call TransmitSlaveArguments
  if ( parallel%master .and. parallel%myTid <= 0 ) &
    & call MLSL2Message ( MLSMSG_Error, ModuleName, &
    & 'master Tid <= 0; probably pvm trouble' )
  if ( parallel%fwmParallel .and. parallel%master .and. parallel%chunkRange == ' ' ) &
    & call MLSL2Message ( MLSMSG_Error, ModuleName, &
    & 'fwmParallel mode can only be run for a single chunk' )
  if ( parallel%fwmParallel ) &
    & call MLSL2Message ( MLSMSG_Error, ModuleName, &
    & 'The fwmParallel option is currently inoperative, it needs significant work to fix - NJL' )
  call init_tables
  status = 0
  if ( parallel%slave ) then
    if ( parallel%masterTid <= 0 ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'masterTid of this slave <= 0' )
    call dump_settings
    call InitParallel ( iChunks(1), slaveMAF )
    if ( parallel%myTid <= 0 ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'slave Tid <= 0; probably pvm trouble' )
  end if
  !---------------- Task (4) ------------------
  ! Open the L2CF
  ! First, set up type checking for it
  status = InitializeMLSFile(MLSL2CF, content = 'l2cf', name='<STDIN>', &
      & type=l_ascii, access=DFACC_RDONLY, recordLength=recl, &
      & PCBottom=MLSPCF_L2CF_Start, PCTop=MLSPCF_L2CF_Start)
  MLSL2CF%FileID%f_id = l2cf_unit
  ! print *, 'l2cf from line? ', trim(line)
  ! print *, 'len_trim(line) ', len_trim(line)
  if ( line /= ' ' ) then
    MLSL2CF%name = line
    call mls_openFile( MLSL2CF, status )
    if ( status /= 0 ) then
      MLSL2CF%name = trim(line) // L2CFNAMEEXTENSION
      call MLS_OpenFile(MLSL2CF, status)
    end if
    if ( status /= 0 ) then
      call io_error ( "While opening L2CF", status, line )
      call MLSL2Message ( MLSMSG_Error, moduleName, &
        & "Unable to open L2CF file: " // trim(line), MLSFile=MLSL2CF )
    else if(switchDetail(switches, 'pro') >= 0) then
      call announce_success( MLSL2CF%name, l2cf_unit )
    end if
    inunit = l2cf_unit
  else if ( TOOLKIT .and. .not. showDefaults ) then
    MLSL2CF%name = '' ! To force reference to PCF entry
    MLSL2CF%type = l_tkgen
    call mls_openFile(MLSL2CF, status)
    ! call dump(MLSL2CF)
    inunit = MLSL2CF%FileID%f_id
    if(status /= 0) then
      call output( 'Non-zero status returned from open_MLSCF: ', &
      & advance='no')
      call output(status, advance='yes')
      call MLSL2Message ( MLSMSG_Error, moduleName, &
        & "Unable to open L2CF file named in pcf", MLSFile=MLSL2CF )
    else if(switchDetail(switches, 'pro') >= 0) then
      call announce_success( MLSL2CF%name, inunit )
    end if
  end if
  error = status
  if ( MLSL2CF%name == '<STDIN>' ) then
    MLSL2CF%FileID%f_id = -1
  else
    inunit = MLSL2CF%FileID%f_id
    ! We will store the l2cf file name in the Boolean 'l2cf'
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'l2cf', MLSL2CF%name, &
      & countEmpty=.true., &
      & inseparator=runTimeValues%sep )
  end if
  if (inunit /= -1) call AddInUnit(inunit)
  numfiles = AddFileToDataBase(FileDatabase, MLSL2CF)

  Show_Sys_Memory = Show_Sys_Memory .or. switchDetail(switches, 'mem') > -1
  if ( switchDetail(switches, 'memkb', options='-fc') > -1 ) then
    Show_Sys_Memory = .true.
    sys_memory_ch = 'kB'
    sys_memory_convert = 1.0
  elseif ( switchDetail(switches, 'memmb', options='-fc') > -1 ) then
    Show_Sys_Memory = .true.
    sys_memory_ch = 'MB'
    sys_memory_convert = 1.0e-3
  elseif ( switchDetail(switches, 'memgb', options='-fc') > -1 ) then
    Show_Sys_Memory = .true.
    sys_memory_ch = 'GB'
    sys_memory_convert = 1.0e-6
  endif
  call time_now ( t1 )

  if( switchDetail(switches, 'opt') > -1 .or. showDefaults ) then
    do j=1, size(current_version_id)
      call output(trim(current_version_id(j)), advance='yes')
    end do
    ! Don't dump_settings more than once
    if ( .not. parallel%slave ) call dump_settings
  end if
  if ( showDefaults ) stop
  ! In case we set skip retrievals on the commandline
  ! we won't want to accidentally override it later
  L2Options%SkipRetrievalOriginal = L2Options%SkipRetrieval
  call begin('starting mlsl2')
  !---------------- Task (5) ------------------
  if (error == 0) then
    ! Parse the L2CF, producing an abstract syntax tree
    call init_parser_table ( parser_table )
    call configuration ( root, parser_table )
    call destroy_parser_table ( parser_table )
    call clean_up_parser
  else
    root = -1
  end if
  ! call configureSayTime ( Coda=' ** (in s) **' )
  call dump ( Time_config )
  call dump ( sayTime_config )
  if ( timing ) call SayTime ( 'Parsing the L2CF', cumulative=.false. )

  !---------------- Task (6) ------------------
  if ( TOOLKIT .and. error==0) then
    call mls_closeFile ( FileDatabase(numfiles), error )
  else
    if ( inunit >= 0 ) close ( inunit )  ! Don't worry about the status
  end if
  if ( error /= 0) then
    call output ( &
      'An io error occurred with the l2cf -- there is no abstract syntax tree', &
      advance='yes' )
    call dump(MLSL2CF)
  else if ( root <= 0 ) then
    call output ( &
      'A syntax error occurred -- there is no abstract syntax tree', &
      advance='yes' )
      error = 1
  else
    if ( dump_tree >= 0 ) then
      call output ( 'Begin un-type-checked abstract syntax tree:', &
        & advance='yes' )
      call print_interesting_subtrees ( dump_tree )
      call output ( 'End un-type-checked abstract syntax tree', &
        & advance='yes' )
    end if

    ! Check that supra-syntactic conditions are met, e.g. correct
    ! types for fields of commands, correct command order, etc.
    call time_now ( t1 )
    call check_tree ( root, error, first_section )
    if ( timing ) call SayTime ( 'Type checking the L2CF', cumulative=.false. )
    if ( do_dump > 0 ) call dump_decl ( do_dump )
    if ( toggle(syn) ) then
      call output ( 'Begin type-checked abstract syntax tree:', advance='yes' )
      call print_interesting_subtrees ( levels(syn), type_name=get_type )
      call output ( 'End type-checked abstract syntax tree', advance='yes' )
    end if

    t2 = t0
    call add_to_section_timing( 'main', t2 )

    if(error /= 0) then
       call MLSL2Message( MLSMSG_Error, ModuleName, &
       & 'error in check_tree: probably need to repair l2cf ', MLSFile=MLSL2CF )
    end if

    if ( checkLeak ) then
      call time_now ( t1 )
      call leakCheck ( root )
      t2 = t0
      call add_to_section_timing( 'main', t2 )
    end if

! call SwitchOutput ( 'stdout' )
! call Dump( OutputOptions )
! call DumpConfig
! call RevertOutput

    !---------------- Task (7) ------------------
    if ( error == 0 .and. first_section /= 0 .and. .not. checkl2cf ) then
      ! Now do the L2 processing.
      ! stop-early flags => no writing, no retrieval
      skipDirectwrites = ( skipDirectwrites .or. stopAfterSection /= ' ' )
      L2Options%SkipRetrieval = ( L2Options%SkipRetrieval .or.  stopAfterSection /= ' ' )
      skipDirectwritesOriginal = skipDirectwrites
      OriginalOptions = L2Options
      call time_now ( t1 )
      if ( timing ) &
        & call output ( "-------- Processing Begun ------ ", advance='yes' )
      call walk_tree_to_do_MLS_L2 ( root, error, first_section, countChunks, &
        & FileDatabase )
      if ( timing ) then
        call output ( "-------- Processing Ended ------ ", advance='yes' )
        call SayTime ( 'Processing mlsl2', t1=0., cumulative=.false. )
      end if
    end if
  end if

  call time_now ( t0 )
  t1 = t0
  ! Moved up here because we're having chunks die during Task (8)
  ! (Why don't you find out why and fix it?)
  call add_to_section_timing( 'main', t0 )
  if ( switchDetail(switches, 'time') >= 0 ) then
    call output('(Now for the timings summary)', advance='yes')
    call dump_section_timings
  endif
  
  ! Tell wrapper script we Finished by way of noteFile
  if ( parallel%slave .and. len_trim(noteFile) > 0 ) then
    call output('Telling wrapper script we Finished', advance='yes')
    call write_textFile ( noteFile, 'Finished' )
  endif
  !---------------- Task (8) ------------------
  if ( .not. parallel%slave .or. slavesCleanUpSelves ) then
    call destroyEmpiricalGeometry
    call destroy_char_table
    call output('Destroyed char table', advance='yes')
    call destroy_hash_table
    call output('Destroyed hash table', advance='yes')
    call destroy_string_table
    call output('Destroyed string table', advance='yes')
    call destroy_symbol_table
    call output('Destroyed symbol table', advance='yes')
    call deallocate_decl
    call output('Deallocated decl', advance='yes')
    call deallocate_tree
    call output('Deallocated tree', advance='yes')
    call FreePVMArgs
    call output('Freed PVM args', advance='yes')
    if ( parallel%slave .and. &
      & (SKIPDIRECTWRITES .or. L2Options%SkipRetrieval .or. sectionsToSkip /= ' ' ) ) then
      ! call mls_h5close(error)
      ! call MLSMessageExit
    else if ( error == 0 ) then
      if ( .not. parallel%slave ) then
        call Deallocate_FileDatabase(FileDatabase)
        call output('Deallocated FileDatabase', advance='yes')
        call mls_h5close(error)
        call output('Closed hdf5 library', advance='yes')
      else
        call MLSMessage ( MLSMSG_Warning, moduleName, &
          & "We are a slave, unable to mls_*close in this version" )
      endif
      if (error /= 0) then
         call MLSL2Message ( MLSMSG_Error, moduleName, &
          & "Unable to MLS_Close" )
      end if
    end if
  end if
  if ( Toolkit ) then
    ! Coda
    numResolutions = 2
    numLayers = 2
    resolutionList(1) = PGSD_DEM_30ARC
    resolutionList(2) = PGSD_DEM_90ARC
    layerList(1) = PGSD_DEM_ELEV
    layerList(2) = PGSD_DEM_WATER_LAND
    status = PGS_DEM_Close ( resolutionList, numResolutions, &
      & layerList, numLayers )
    call outputNamedValue( 'PGS_DEM_Close status', status )
  end if
  if ( AllocateLogUnit > 0 ) close( Unit=AllocateLogUnit )
  if ( timing ) call SayTime ( 'Closing and deallocating', cumulative=.false. )
  call add_to_section_timing( 'main', t0 )
  if ( trackAllocates > 0 ) call ReportLeaks ( "At end of program execution..." )
  call FinalMemoryReport ( isFinal=.true. )
  call finish ( 'ending mlsl2' )
  if ( parallel%slave .and. len_trim(noteFile) > 0 .and. WAITFORSCRIPT ) then
    ! cycle endlessly until wrapper script kills us
    call output( ' Waiting for wrapper script to kill us', advance='yes' )
    call flushStdout
    do
      call usleep ( 10000*parallel%delay )
    enddo
  endif
  if( error /= 0 .or. STOPWITHERROR ) then
     call MLSMessageExit(1)
  else if( NORMAL_EXIT_STATUS /= 0 .and. .not. parallel%slave ) then
     call MLSMessageExit( NORMAL_EXIT_STATUS )
  else
     call MLSMessageExit
  end if

contains

  subroutine Print_Interesting_Subtrees ( Level, Type_Name )
    use Tree, only: Dump_Tree_Node, Node_ID, Print_Subtree
    use Tree_Types, only: N_CF, N_If, N_Select
    integer, intent(in) :: Level ! If > 0, print the entire tree rooted at
                               ! Root, else print only subtrees with roots
                               ! having tree indices of n_cf, n_if and n_select
    optional :: Type_Name
    interface
      integer function Type_Name ( Decor )
      ! Return the string index to print for the decoration
        integer, intent(in) :: Decor ! Tree(where)%Decor
      end function Type_Name
    end interface
    integer :: I ! Subtree index
    if ( level > 0 ) then
      call print_subtree ( root, 0, type_name=type_name )
    else
      call output ( root, 5 )
      call output ( ':' )
      call dump_tree_node ( root, 0, type_name=type_name, advance='yes' )
      do i = 1, nsons(root)
        select case ( node_id(subtree(i,root)) )
        case ( N_CF, N_If, N_Select )
          call print_subtree ( subtree(i,root), 1, type_name=type_name )
        end select
      end do
    end if
  end subroutine Print_Interesting_Subtrees

  ! The following offer some information on the options
  ! available either on the command-line or via the PCF
  ! Note the unashamed use of 'print' statements which
  ! are officially discouraged in favor of calls to MLSMessage.
  ! Unfortunately, we have not yet decided which method to use
  ! until *after* processing all the options.

  subroutine Switch_usage
    print *, 'Switch usage: -S"sw1,sw2,..,swn" or -Ssw1 -Ssw2 ..'
    print *, ' where each of the swk may be one of the following'
   ! (This incorporates automatic source code replacement by
   !  a custom build command in the Makefile --
   !  Please don't edit/remove the following 3 lines)
   !  See mlspgs/notes/switches
   ! === (start of automatic usage lines) ===
    print *, '  A => AntennaPatterns'
   ! === (end of automatic usage lines) ===
    stop
  end subroutine Switch_usage

  subroutine Option_usage
    call getarg ( 0+hp, line )
    print *, 'Usage: ', trim(line), ' [options] [--] [L2CF-name]'
    print *, ' Options:'
   ! (This incorporates automatic source code replacement by
   !  a custom build command in the Makefile --
   !  Please don't edit/remove the following 3 lines)
   !  See mlspgs/notes/options
   ! === (start of automatic option lines) ===
    print *, '  -A: Dump the un-decorated abstract syntax tree.'
   ! === (end of automatic option lines) ===
    stop
  end subroutine Option_usage

  subroutine Dump_settings
  ! Show current run-time settings resulting from
  ! command-line, MLSL2Options, etc.
  ! Intel's ifort does not yet support the following USE statement
  !     use, intrinsic :: ISO_FORTRAN_ENV, only: Compiler_Options, Compiler_Version
    use Printit_m, only: Get_Config
    character(len=1), parameter :: fillChar = '1' ! fill blanks with '. .'
    character(len=255) :: Command ! Command that executed the program
    integer :: LogFileUnit
    character(len=8) :: string
    ! Executable
    ! Always show how we were invoked and what the l2cf is
    call getarg ( 0, command )
    if ( command /= '' ) then
      call output ( ' mlsl2 invoked as: ', advance='no' )
      call output ( trim(command), advance='yes' )
    end if
    call output ( ' mlsl2 called with command line options: ', advance='no' )
    call output ( trim(L2Options%Originalcmds), advance='yes' )
    call output ( ' l2cf file:', advance='no' )
    call blanks ( 4, advance='no' )
    call output ( trim(MLSL2CF%name), advance='yes' )
!     call output ( 'Compiler options ' )
!     call output ( compiler_options(), advance='yes' )
!     call output ( 'Compiler version ' )
!     call output ( compiler_version(), advance='yes' )
    ! Now show a nicely-formatted list of all run-time options
    if( SwitchDetail( switches, 'opt') > 0 .or. showDefaults ) then
      call blanks( 80, fillChar='-', advance='yes' )
      call headline( 'Summary of run time options', fillChar='-', before='*', after='*' )
      call outputNamedValue ( 'Use toolkit panoply', toolkit, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Error threshold before halting', Quit_Error_Threshold, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Status on normal exit', normal_exit_status, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'PCF shared with level 1?', SHAREDPCF, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Range of chunks', trim_safe(parallel%chunkRange), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Unique job ID', trim(uniqueID), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Show system memory usage?', &
        & Show_Sys_Memory, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Is this the master task in pvm?', parallel%master, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      if ( parallel%master .or. showDefaults ) then
        call outputNamedValue ( 'Master task number', parallel%myTid, advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
        call outputNamedValue ( 'Command line sent to slaves', trim_safe(parallel%pgeName), advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
        call outputNamedValue ( 'Command to queue slave tasks', trim_safe(parallel%submit), advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
        call outputNamedValue ( 'Maximum failures per chunk', parallel%maxFailuresPerChunk, advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
        call outputNamedValue ( 'Maximum failures per machine', parallel%maxFailuresPerMachine, advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
        call outputNamedValue ( 'Sleep time in masterLoop (mus)', parallel%delay, advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      end if
      call outputNamedValue ( 'Is this a slave task in pvm?', parallel%slave, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      if ( parallel%slave ) then
        call outputNamedValue ( 'Master task number', parallel%masterTid, advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
        if ( len_trim(noteFile) > 0 ) then
          call output ( '*  Note file:', advance='yes' )
          call output ( '*    ' // trim(noteFile), advance='yes' )
        end if
      end if
      if ( len_trim(stopAfterSection) > 0 ) then
        call outputNamedValue ( 'Stop after section', trim_safe(stopAfterSection), advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      endif
      call outputNamedValue ( 'Preflight check paths?', checkPaths, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Need L1B files?', NEED_L1BFILES, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Reading Aura L1B files?', AURA_L1BFILES, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Skip all direct writes?', SKIPDIRECTWRITES, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Skip all retrievals?', L2Options%SkipRetrieval, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Filling unretrieved states with', STATEFILLEDBYSKIPPEDRETRIEVALS, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Using wall clock instead of cpu time?', time_config%use_wall_clock, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call get_string ( lit_indices(sectionTimingUnits), string, strip=.true. )
      call outputNamedValue ( 'Summarize time in what units', trim_safe(string), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Number of switches set', numSwitches, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Standard output unit', PrUnitName(outputOptions%prunit), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call get_config ( logFileUnit = logFileUnit )
      call outputNamedValue ( 'Log file unit', PrUnitname(logFileUnit), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Crash on any error?', MLSMessageConfig%crashOnAnyError, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Suppress identical warnings after', MLSMessageConfig%limitWarnings, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Restart warnings count at each phase?', restartWarnings, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Set error before stopping?', StopWithError, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      if ( specialDumpFile /= ' ' ) then
        call outputNamedValue ( 'Save special dumps to', trim(specialDumpFile), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Default hdf version for l1b files', level1_hdfversion, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Default hdfeos version on reads', default_hdfversion_read, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Default hdfeos version on writes', default_hdfversion_write, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Max Chunk size Appended to l2gp files', maxChunkSize, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      end if
      if ( len_trim(AllocFile%Name) > 0 ) then
        call outputNamedValue ( 'Log Allocates to', trim(AllocFile%Name), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      endif
      call outputNamedValue ( 'Avoiding unlimited dimensions in directwrites?', &
        & avoidUnlimitedDims, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Allow overlaps outside proc. range?', &
        & (/ChunkDivideConfig%allowPriorOverlaps, ChunkDivideConfig%allowPostOverlaps/), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Time some processes?', timing, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Is this run in forward model parallel?', parallel%fwmParallel, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Avoid creating file on first directWrite?', patch, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call Blanks( 80, fillChar='-', advance='yes' )
      ! Dump special settings and configurations
      if ( len_trim(switches) > 0 ) &
        & call Dump( switches, 'All Switches' )
      if ( len_trim(MLSNamesAreDebug) > 0 ) &
        & call Dump( MLSNamesAreDebug, 'Modules to debug' )
      if ( len_trim(MLSNamesAreVerbose) > 0 ) &
        & call Dump( MLSNamesAreDebug, 'Modules are verbose' )
      if ( len_trim(SectionsToSkip) > 0 ) &
        & call Dump( SectionsToSkip, 'Sections to Skip' )
      if ( len_trim(PhasesToSkip) > 0 ) &
        & call Dump( PhasesToSkip, 'Phases to Skip' )
      if ( L2Options%Overridden ) call DumpOptions
      call SwitchOutput ( 'stdout' )
      call Dump( OutputOptions )
      call Dump( StampOptions )
      call DumpConfig
      call RevertOutput
      call Blanks( 80, fillChar='-', advance='yes' )
      ! Many of these are defined in the PCF or in the global settings
      ! Neither of these sections have been completed yet
      ! call DumpGlobalAttributes
    end if
  end subroutine Dump_settings

  ! ---------------------------------------------  MovePCFIDs  -----
  subroutine MovePCFIDs
    ! We need to move any "mobile" PCFids
    include 'sharedpcf2.f9h'
    print *, 'Moved PCFIds'
    print *, 'mlspcf_l2cf_start: ', mlspcf_l2cf_start

  end subroutine MovePCFIDs

  ! ---------------------------------------------  announce_success  -----
  subroutine announce_success ( Name, unit_number )
    character(len=*), intent(in)   :: Name
    integer, intent(in)            :: unit_number

    call output ( 'Level 2 configuration file ' )
    call output ( 'unit number : ' )
    call blanks(4)
    call output ( unit_number, advance='no')
    call blanks(10)
    call output ( 'name : ' )
    call blanks(4)
    call output ( trim(Name), advance='yes')
  end subroutine announce_success

!-----------------------------------------------------------------------
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSL2.f90,v 2.235 2021/07/08 23:34:08 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
!---------------------------------------------------------------------------

end program MLSL2

! $Log: MLSL2.f90,v $
! Revision 2.235  2021/07/08 23:34:08  pwagner
! Wider use of MLSL2Message
!
! Revision 2.234  2020/04/30 23:29:42  pwagner
! Add Final call to FinalMemoryReport at end
!
! Revision 2.233  2020/04/09 23:17:46  pwagner
! Improved wording in Dump_settings
!
! Revision 2.232  2019/08/01 23:46:50  pwagner
! Some Housekeeping
!
! Revision 2.231  2019/04/11 23:43:43  pwagner
! cmdline options --help,--version, and -S'?' now print only relevant stuff
!
! Revision 2.230  2019/03/08 17:15:49  pwagner
! Still correcting mis-directed output
!
! Revision 2.229  2019/02/13 17:31:27  pwagner
! change outputOptions%prunit to L2Options only if default value is Overriden
!
! Revision 2.228  2019/01/31 19:23:05  pwagner
! Removed more unused stuff
!
! Revision 2.227  2018/12/07 00:20:47  pwagner
! If cmdline says to skip retrievals, must skip even if l2cf says otherwise
!
! Revision 2.226  2018/09/13 20:25:19  pwagner
! Moved changeable options to new L2Options; added DumpOptions
!
! Revision 2.225  2018/05/22 23:08:40  pwagner
! Dumped settings include GlobalAttributes
!
! Revision 2.224  2017/12/22 00:32:00  pwagner
! Try harder to make slaves flush stdout buffer
!
! Revision 2.223  2017/03/23 16:57:38  pwagner
! Improved Dump_settings appearance
!
! Revision 2.222  2017/01/25 18:10:22  pwagner
! May skip certain Phases named in phasesToSkip cmdline opt
!
! Revision 2.221  2017/01/11 23:56:53  pwagner
! Dumps both time configs; Dump MLSFile type if l2cf error
!
! Revision 2.220  2016/11/08 17:30:57  pwagner
! Use SayTime subroutine from time_m module
!
! Revision 2.219  2016/11/04 19:32:11  pwagner
! Locate calculation of MLSMSG_Severity_to_quit appropriately
!
! Revision 2.218  2016/05/27 00:05:22  pwagner
! Should now correctly process options containing an embedded space
!
! Revision 2.217  2016/03/18 18:00:15  pwagner
! Dont let -Smess override effect of --loconic option
!
! Revision 2.216  2016/02/29 19:51:07  pwagner
! Usleep got from machine module instead of being an external
!
! Revision 2.215  2015/10/06 00:22:09  pwagner
! Automatically store l2cf name in runtime Boolean 'l2cf'
!
! Revision 2.214  2015/09/24 22:07:57  pwagner
! Dump_settings shows max chunk size appended to l2gp files
!
! Revision 2.213  2015/07/16 22:13:15  pwagner
! Dump of settings says whether it will stop after a named section
!
! Revision 2.212  2014/12/10 23:04:54  pwagner
! Removed unused stuff
!
! Revision 2.211  2014/09/11 18:28:35  pwagner
! Added -Smem[units] switch to show sys memory
!
! Revision 2.210  2014/09/05 01:07:49  vsnyder
! Remove ProcessID stuff.  Destroy Empirical Geometry explicitly
!
! Revision 2.209  2014/09/05 00:49:07  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.208  2014/09/02 18:18:23  pwagner
! Uses noteFile mechanism for telling our wrapper script we finished
!
! Revision 2.207  2014/06/30 23:26:58  pwagner
! Can log allocations/deallocations to separate file
!
! Revision 2.206  2014/05/20 23:56:53  vsnyder
! New parser gets its tables from an argument instead of an include
!
! Revision 2.205  2014/03/25 18:19:00  pwagner
! Moved init_tables before dump_settings to avoid crash
!
! Revision 2.204  2014/03/20 01:42:32  vsnyder
! Get Get_Type from Intrinsic, do init_tables later
!
! Revision 2.203  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.202  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.201  2013/12/12 02:10:58  vsnyder
! Add 'debug' to init_lexer, move syntax tree printing into internal subroutine
!
! Revision 2.200  2013/11/26 22:40:51  vsnyder
! Change -A to -A[n] with n>0 meaning dump the entire tree, including the
! type-checking stuff, and n==0 or absent meaning dump only the parser output.
!
! Revision 2.199  2013/11/04 22:56:59  pwagner
! Print which modules are berbose, debugged
!
! Revision 2.198  2013/10/09 23:46:38  vsnyder
! Pass Get_Type to tree dumper
!
! Revision 2.197  2013/09/25 18:51:55  pwagner
! Closes DEM stuff before exiting
!
! Revision 2.196  2013/09/06 20:58:18  pwagner
! Trying again to prevent slaves from logging to toolkit
!
! Revision 2.195  2013/09/04 17:34:52  pwagner
! Replaced '--cat' cmdline option; 'Catenate' now an Output section command
!
! Revision 2.194  2013/08/23 02:52:13  vsnyder
! Move PrintItOut to PrintIt_m
!
! Revision 2.193  2013/08/17 00:22:14  pwagner
! New cmdline arg relaxes some for non-Aura l1b datasets
!
! Revision 2.192  2013/06/28 19:18:42  pwagner
! -Smess[n] and -Sparent switches; other tweaks to output
!
! Revision 2.191  2013/02/12 18:14:38  pwagner
! Removed SIPS_VERSION
!
! Revision 2.190  2012/12/04 00:16:09  pwagner
! Removed confisuion-causing OUTSIDEOVERLAPS and its cmdline option
!
! Revision 2.189  2012/08/21 23:54:01  pwagner
! Fixed certain problems when showing settings
!
! Revision 2.188  2012/08/16 17:48:47  pwagner
! Exploit new features to fleexibly change how and when to log output
!
! Revision 2.187  2012/07/18 00:39:34  pwagner
! Consistent with module parameters for prUnit, LogFileUnit
!
! Revision 2.186  2012/07/10 15:22:25  pwagner
! Moved stuff to MLSL2Options module so it works right
!
! Revision 2.185  2012/07/02 20:34:41  pwagner
! Avoid dumping settings more than one time
!
! Revision 2.184  2012/06/27 18:02:59  pwagner
! May overwrite command line options with options field to phase spec
!
! Revision 2.183  2012/06/06 20:36:37  vsnyder
! Use Set_Toggles for -aefglpt options
!
! Revision 2.182  2012/04/26 23:12:45  pwagner
! --crash turns off neverCrash; maybe we should change default for neverCrash to .false.
!
! Revision 2.181  2012/04/20 01:30:38  vsnyder
! Use Begin, Finish instead of Output_Date_and_Time
!
! Revision 2.180  2012/03/28 20:06:44  pwagner
! Removed stgmem option--slave tasks lost ability to join quantities
!
! Revision 2.179  2012/02/09 02:45:26  vsnyder
! Remove -C option -- I didn't notice --crash was already there
!
! Revision 2.178  2012/02/09 01:48:11  vsnyder
! Add -C option to crash on any error, to get traceback for debugging
!
! Revision 2.177  2011/06/29 21:43:59  pwagner
! Some cases may safely omit l1b files
!
! Revision 2.176  2010/11/05 22:36:16  pwagner
! Consistent with new unquote api
!
! Revision 2.175  2010/09/17 00:11:19  pwagner
! Fixed misuse of switchDetail function
!
! Revision 2.174  2010/08/06 23:08:48  pwagner
! Pass Hessians, matrices to DumpCommand
!
! Revision 2.173  2010/05/23 03:25:37  honghanh
! Use AddInUnit instead of inunit to adapt with change in the string_table
!
! Revision 2.172  2010/02/02 01:41:03  vsnyder
! Move declaration of Id to a place where it is more difficult for a
! compiler to notice it's not actually referenced.
!
! Revision 2.171  2009/10/21 16:59:10  pwagner
! No longer insist on unlimited dims when given chunkrange
!
! Revision 2.170  2008/01/08 00:22:02  pwagner
! Levels 1 and 2 can use same shared PCF now if --shared option set
!
! Revision 2.169  2007/09/13 21:52:22  pwagner
! Reduced sips limitwarnings to 4
!
! Revision 2.168  2007/09/06 23:35:16  pwagner
! slaves need not do own cleanup
!
! Revision 2.167  2007/08/23 22:18:35  pwagner
! 'walk' switch prints walkback fo calling stack even for warnings
!
! Revision 2.166  2007/08/17 00:36:29  pwagner
! Removed now-redundant [n]everCrash option
!
! Revision 2.165  2007/07/27 00:18:20  vsnyder
! Print the command that invoked MLSL2
!
! Revision 2.164  2007/06/07 20:38:45  pwagner
! Should prevent unit collisions (not as good as get_lun)
!
! Revision 2.163  2007/02/14 20:48:59  pwagner
! Slaves bypass mls_h5close to avoid another bomb
!
! Revision 2.162  2007/02/14 17:31:45  pwagner
! Moved timing summary before statements possibly killing slaves
!
! Revision 2.161  2007/02/07 20:58:03  pwagner
! Permit slaves to write unbuffered stdout when master does
!
! Revision 2.160  2007/01/12 00:35:08  pwagner
! Renamed routine outputNamedValue; may set host name and unbuffered stdout
!
! Revision 2.159  2006/10/09 18:38:41  pwagner
! Trims parallel%chunkRange before outputting
!
! Revision 2.158  2006/10/05 23:32:14  pwagner
! skipSections can skip named sections
!
! Revision 2.157  2006/09/21 18:46:49  pwagner
! Reduce level of dumps in SIDS version
!
! Revision 2.156  2006/08/14 16:21:22  pwagner
! pass chunk range correctly to slave tasks
!
! Revision 2.155  2006/08/10 21:46:49  pwagner
! --chunk commandline option now synonym for --chunkRange
!
! Revision 2.154  2006/08/05 02:13:33  vsnyder
! Add 'where' argument for ReportLeaks
!
! Revision 2.153  2006/07/29 03:42:09  vsnyder
! New --memtrack interpretation
!
! Revision 2.152  2006/07/27 03:49:12  vsnyder
! Detect --leak option, attach leak checker
!
! Revision 2.151  2006/07/21 20:10:37  pwagner
! Can fill state even if skipping retrievals; select what section to stop after
!
! Revision 2.150  2006/06/28 00:00:18  pwagner
! Uses new outputNamedValue
!
! Revision 2.149  2006/06/24 23:11:29  pwagner
! prunit now a component of outputOptions
!
! Revision 2.148  2006/04/20 23:22:39  pwagner
! Show both kinds of allowed extra-range overlaps
!
! Revision 2.147  2006/04/11 23:28:49  pwagner
! Whether to allow overlaps outside of processing range
!
! Revision 2.146  2006/03/04 00:17:20  pwagner
! May skip retrieval, directWrites depending on runtime Booleans
!
! Revision 2.145  2006/02/21 19:15:17  pwagner
! Uses switchDetail only now
!
! Revision 2.144  2006/02/10 21:14:32  pwagner
! May specify skipRetrivel for particular Phases; dumps may go to special dumpfile
!
! Revision 2.143  2005/11/17 20:11:46  pwagner
! Was printing wrong thing for parallel sleeptime
!
! Revision 2.142  2005/09/22 23:38:54  pwagner
! time_config and retry_config now hold config settings
!
! Revision 2.141  2005/08/19 23:29:04  pwagner
! Wider use of SwitchDetail function
!
! Revision 2.140  2005/07/21 23:39:49  pwagner
! use_wall_clock tied to SIPS_VERSION
!
! Revision 2.139  2005/06/29 17:57:40  pwagner
! FILESTRINGTABLE set to TRUE
!
! Revision 2.138  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.137  2005/06/14 20:45:22  pwagner
! Many changes to accommodate the new fields in MLSFile_T
!
! Revision 2.136  2005/05/31 17:51:17  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.135  2005/04/12 18:12:30  pwagner
! SIPS version limits warnings to 50; reads scalar intfromchars
!
! Revision 2.134  2005/04/01 00:15:37  pwagner
! Automatcially remove slv switch from SIPS version
!
! Revision 2.133  2005/03/15 23:58:42  pwagner
! Sets MLSMessageConfig appropriately for slaves
!
! Revision 2.132  2005/03/12 00:49:18  pwagner
! -w option added
!
! Revision 2.131  2005/03/03 00:23:42  pwagner
! Added -Rs1,s2,.. Removeswitches option
!
! Revision 2.130  2005/01/22 00:39:08  pwagner
! Reversed buggy evercrash option
!
! Revision 2.129  2004/12/27 23:05:27  pwagner
! Commented out useless prints; warns on checkPaths option
!
! Revision 2.128  2004/12/14 21:55:37  pwagner
! May skip sections, stop early
!
! Revision 2.127  2004/10/30 00:28:00  vsnyder
! Commented out some unused stuff to make NAG stop nagging
!
! Revision 2.126  2004/10/11 16:57:03  pwagner
! Bug fix for options; slaves output not logged; prints proc start, end date_and_time
!
! Revision 2.125  2004/08/19 00:20:21  pwagner
! New crash-related, defaults options
!
! Revision 2.124  2004/08/16 17:12:20  pwagner
! Fixed clearonallocate setting
!
! Revision 2.123  2004/08/05 22:47:47  pwagner
! New --chunkRange option to run selected chunks in parallel mode
!
! Revision 2.122  2004/08/04 23:19:57  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.121  2004/07/08 22:48:44  pwagner
! Made SIPS_VERSION public
!
! Revision 2.120  2004/06/29 00:10:17  pwagner
! Exploit catlist function
!
! Revision 2.119  2004/04/27 23:50:24  pwagner
! Added SKIPDIRECTWRITES option
!
! Revision 2.118  2004/04/15 22:48:30  pwagner
! Multiword options like maxFailuresPerChunk made case-insensitive
!
! Revision 2.117  2004/04/06 23:50:09  livesey
! Added clearOnAllocate flag
!
! Revision 2.116  2004/04/03 05:44:16  livesey
! Added memTrack option
!
! Revision 2.115  2004/03/24 23:54:06  pwagner
! Switched from h5_open/close_f to mls_open/close
!
! Revision 2.114  2004/03/24 01:03:34  livesey
! Increased tree size.
!
! Revision 2.113  2004/02/05 23:26:22  pwagner
! Added --cat option
!
! Revision 2.112  2004/01/09 00:22:12  pwagner
! Unsets avoidUnlimitedDims to bypass bug directWriting range of chunks
!
! Revision 2.111  2004/01/07 23:50:16  livesey
! Added error message about fwmParallel being broken at the moment
!
! Revision 2.110  2003/12/11 22:56:04  pwagner
! Transmits --idents option to slaves; unquotes switches
!
! Revision 2.109  2003/12/07 23:06:29  pwagner
! Should not dump all the chunks agagin and again for each slaves chunk
!
! Revision 2.108  2003/12/05 00:40:11  pwagner
! Added patch option, section timing units
!
! Revision 2.107  2003/11/15 00:33:37  pwagner
! New commandline opts: maxfailuresperchunk, maxfailurespermachine
!
! Revision 2.106  2003/11/14 23:37:13  pwagner
! Lets user change masterLoop delay via commandline option
!
! Revision 2.105  2003/11/07 00:46:51  pwagner
! New quicker preflight option: --checkPaths
!
! Revision 2.104  2003/11/05 21:27:54  pwagner
! Can enter range of chunks to be processed instead of single
!
! Revision 2.103  2003/10/21 00:02:32  pwagner
! Revert to writing just once if toolkit and parallel
!
! Revision 2.102  2003/10/14 18:17:02  pwagner
! Fixed problem with reducing switches to unique list
!
! Revision 2.101  2003/10/09 23:57:35  pwagner
! A few more SIPS-related tweaks
!
! Revision 2.100  2003/10/09 23:35:21  pwagner
! Treats SIPS version special; switches ,-separated
!
! Revision 2.99  2003/09/05 23:22:08  pwagner
! Takes in new --skipRetrieval option
!
! Revision 2.98  2003/08/01 20:26:01  pwagner
! gets slave pge name from command line
!
! Revision 2.97  2003/06/13 20:02:50  vsnyder
! Put snoopMAF before snoop, so it can be found, futzing
!
! Revision 2.96  2003/06/09 22:49:33  pwagner
! Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
!
! Revision 2.95  2003/05/14 00:59:40  livesey
! Increased hash table size.
!
! Revision 2.94  2003/05/13 04:48:20  livesey
! Added stgmem option
!
! Revision 2.93  2003/02/27 18:40:29  pwagner
! recl passed to let NAG open l2cf with long lines
!
! Revision 2.92  2003/02/08 00:30:57  pwagner
! Increased default RECL due to new l2cfs in lib
!
! Revision 2.91  2002/12/19 11:54:45  livesey
! Upped tree size
!
! Revision 2.90  2002/12/10 00:39:06  pwagner
! Announces success a la read_apriori
!
! Revision 2.89  2002/12/06 22:33:41  livesey
! Added the snoop name stuff
!
! Revision 2.88  2002/12/05 19:45:20  pwagner
! Moved MLSFile_T from MLSFiles to MLSCommon
!
! Revision 2.87  2002/12/04 01:18:21  pwagner
! First halting steps toward using filedatabase
!
! Revision 2.86  2002/11/13 01:08:40  pwagner
! Prints more info when called asked to print opts
!
! Revision 2.85  2002/10/30 00:56:51  livesey
! Increased size of hash table
!
! Revision 2.84  2002/10/08 17:41:20  livesey
! Now passes chunk argument to slaves if present.  Needed for
! fwmParallel mode.
!
! Revision 2.83  2002/10/05 00:44:14  livesey
! Included the FMWParallel stuff
!
! Revision 2.82  2002/10/03 23:00:03  pwagner
! You can set l1b, l2gp hdfversions on command line
!
! Revision 2.81  2002/09/24 18:17:20  pwagner
! Consistent with add_to_section_timing now calling time_now at its end
!
! Revision 2.80  2002/08/29 21:47:51  livesey
! Added subblock option
!
! Revision 2.79  2002/08/21 18:22:26  vsnyder
! Revise processing of Lahey/Fujitsy runtime (-Wl) options
!
! Revision 2.78  2002/08/15 21:48:51  pwagner
! h5open(close)_f now called at start (end)
!
! Revision 2.77  2002/07/23 23:15:05  pwagner
! Moved dump_settings call after learning name of l2cf file
!
! Revision 2.76  2002/07/18 21:59:28  vsnyder
! Cosmetic changes, move some stuff around so PRUNIT is stdout in init_tables
!
! Revision 2.75  2002/05/28 22:34:59  livesey
! Increased tree size
!
! Revision 2.74  2002/05/24 17:27:18  pwagner
! Added recl=recl to second-chance open of l2cf
!
! Revision 2.73  2002/05/23 20:57:57  vsnyder
! Add --recl option, some cosmetic changes
!
! Revision 2.72  2002/05/14 00:26:49  livesey
! Larger table sizes (may be unnecessary)
!
! Revision 2.71  2002/04/24 20:21:13  livesey
! Upped some string sizes.
!
! Revision 2.70  2002/04/24 16:54:02  livesey
! Changes for submit option
!
! Revision 2.69  2002/03/20 00:48:29  pwagner
! Option -check just checks l2cf then quits
!
! Revision 2.68  2002/02/20 00:29:04  pwagner
! Retries FN+.l2cf; tracks successful l2cf file name
!
! Revision 2.67  2002/02/12 00:25:00  pwagner
! New switch -opt[n] and new --version option
!
! Revision 2.66  2002/02/05 00:44:03  pwagner
! Added garbage collection stuff
!
! Revision 2.65  2002/01/18 18:55:25  livesey
! Added the --chunk option
!
! Revision 2.64  2002/01/09 22:56:46  livesey
! Tidied up parsing of master option.
!
! Revision 2.63  2002/01/09 00:00:48  pwagner
! Fixed small comment; added others explaining unavoidable use of print
!
! Revision 2.62  2001/12/13 23:21:20  livesey
! Added countChunks option
!
! Revision 2.61  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.60  2001/11/09 18:12:38  livesey
! Added --nckbk option.
!
! Revision 2.59  2001/10/12 23:11:28  pwagner
! Clarified what Processing time means?
!
! Revision 2.58  2001/10/09 22:37:55  livesey
! Increased tree size and hash table size to accomodate new
! spectroscopy database from Bill
!
! Revision 2.57  2001/10/04 23:50:25  livesey
! Added the ckbk option
!
! Revision 2.56  2001/10/04 00:16:45  pwagner
! Increased hash table size; added note that size(s) may need to grow
!
! Revision 2.55  2001/09/28 23:59:20  pwagner
! Fixed various timing problems
!
! Revision 2.54  2001/09/28 17:50:30  pwagner
! MLSL2Timings module keeps timing info
!
! Revision 2.53  2001/09/19 23:43:49  livesey
! Added --snoop option
!
! Revision 2.52  2001/07/19 22:00:09  pwagner
! Better behaved when l2cf is stdin
!
! Revision 2.51  2001/07/18 23:56:24  pwagner
! Gets error from close_mlscf
!
! Revision 2.50  2001/07/18 00:16:54  pwagner
! Better control over when to exit with status
!
! Revision 2.49  2001/07/16 23:43:15  pwagner
! With settable NORMAL_EXIT_STATUS
!
! Revision 2.48  2001/05/25 01:03:47  livesey
! Working parallel version
!
! Revision 2.47  2001/05/23 23:21:51  pwagner
! Did the same for options, switches
!
! Revision 2.46  2001/05/23 22:31:30  pwagner
! Automatically updates based on notes/switches
!
! Revision 2.45  2001/05/23 21:59:43  livesey
! Interim version, almost there
!
! Revision 2.44  2001/05/23 01:44:24  livesey
! Parallel code starting to fit into place
!
! Revision 2.43  2001/05/18 01:14:21  vsnyder
! Add a 'stop' in 'switch_usage', plus cosmetic changes
!
! Revision 2.42  2001/05/17 22:34:55  pwagner
! output and MLSMessage modules cooperate better w/o toolkit; switch_usage
!
! Revision 2.41  2001/05/15 23:46:07  pwagner
! Removed 2 settings from MLSL2Opts; now in switches
!
! Revision 2.40  2001/05/11 23:47:00  pwagner
! (Re)Sets prunit depending on toolkit
!
! Revision 2.39  2001/05/11 17:34:31  vsnyder
! Improve built-in usage display
!
! Revision 2.38  2001/05/09 23:33:00  pwagner
! Sets new MLSL2Options
!
! Revision 2.37  2001/05/08 20:33:41  vsnyder
! Moved usage display into a subroutine
!
! Revision 2.36  2001/05/07 23:30:51  pwagner
! Sets USESDPToolkit
!
! Revision 2.35  2001/05/07 21:53:28  vsnyder
! Improve built-in usage display
!
! Revision 2.34  2001/05/07 21:05:03  vsnyder
! Separated '[n]pcf' and [n]cfpcf'
!
! Revision 2.33  2001/05/07 18:16:11  vsnyder
! Added "do [not] output MLSMessage messages through the toolkit" option.
! Resolved conflicts on merge.
!
! Revision 2.32  2001/05/07 17:17:31  pwagner
! Calls MLSMessage to exit with error if check_tree fails
!
! Revision 2.31  2001/05/04 22:55:36  pwagner
! Added cascading negatives; new command line options
!
! Revision 2.30  2001/05/03 01:58:52  vsnyder
! Add error checking for --slave option
!
! Revision 2.29  2001/05/02 23:22:48  livesey
! Added parallel stuff
!
! Revision 2.28  2001/05/01 17:51:47  vsnyder
! Ignore Lahey/Fujitsu run-time library's command-line arguments
!
! Revision 2.27  2001/04/28 01:44:47  vsnyder
! Provide to set levels(emit)
!
! Revision 2.26  2001/04/27 20:59:16  vsnyder
! Change -G option to -S
!
! Revision 2.25  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.24  2001/04/24 23:04:42  vsnyder
! Add -f[digit] to set toggle(emit) and levels(emit)
!
! Revision 2.23  2001/04/21 01:44:05  vsnyder
! Make the timing message prettier
!
! Revision 2.22  2001/04/21 01:42:21  vsnyder
! Add -T option for timing
!
! Revision 2.21  2001/04/20 20:44:18  pwagner
! Sets MLSMSG_Severity_to_quit
!
! Revision 2.20  2001/04/17 22:08:56  pwagner
! Sets prunit according to OUTPUT_PRINT_UNIT
!
! Revision 2.19  2001/04/16 23:46:58  pwagner
! Gets PCF_FOR_INPUT flag from MLSL2Options
!
! Revision 2.18  2001/04/06 20:11:53  vsnyder
! Add -e option
!
! Revision 2.17  2001/04/05 01:33:46  vsnyder
! Increase initial sizes for sevaral paraer tables
!
! Revision 2.16  2001/03/28 01:29:48  vsnyder
! Add description of -G to -h output
!
! Revision 2.15  2001/03/16 21:47:57  vsnyder
! Add -G option
!
! Revision 2.14  2001/03/14 18:59:03  vsnyder
! Add K and k options to control whether the lexer capitalizes identifiers
!
! Revision 2.13  2001/03/08 00:39:37  vsnyder
! Improve some debugging output
!
! Revision 2.12  2001/03/02 02:38:17  vsnyder
! Expand LINE, alphabetize USEs
!
! Revision 2.11  2001/02/28 03:01:48  vsnyder
! Make presence of L2CF-name on command line take precedence over --[n]pcf
!
! Revision 2.10  2001/02/28 02:52:32  vsnyder
! Improve usage description
!
! Revision 2.9  2001/02/28 02:44:24  vsnyder
! Identify abstract syntax tree dumps, show default --[n]pcf in usage
!
! Revision 2.8  2001/02/28 01:59:29  vsnyder
! Access Open_MLSCF and Close_MLSCF from Obtain_MLSCF instead of Open_Init
!
! Revision 2.7  2001/02/23 02:39:56  vsnyder
! Add description of --pcf option to usage instructions.
!
! Revision 2.6  2001/02/23 02:38:34  vsnyder
! Open L2CF either by PCF or by Fortran OPEN or expect it on stdin
!
! Revision 2.5  2001/02/22 23:51:00  vsnyder
! Improved usage messages
!
! Revision 2.4  2001/02/22 23:05:12  vsnyder
! Display usage if -h, -H or -? option is present.
!
! Revision 2.3  2000/10/12 00:33:47  vsnyder
! Insert CVS variables and copyright notice
!
@


2.235
log
@Wider use of MLSL2Message
@
text
@d15 2
a16 1
  use Call_Stack_M, only: Show_Sys_Memory, Sys_Memory_Ch, Sys_Memory_Convert
d320 3
d903 1
a903 1
       "$Id: MLSL2.f90,v 2.234 2020/04/30 23:29:42 pwagner Exp $"
d912 3
@


2.234
log
@Add Final call to FinalMemoryReport at end
@
text
@d39 2
a40 2
    & DumpOptions, L2cf_Unit, Level1_HDFVersion, MaxChunkSize, Need_L1BFiles, &
    & Normal_Exit_Status, NoteFile, NumSwitches, &
d194 1
a194 1
      call MLSMessage ( MLSMSG_Error, moduleName, &
d366 1
a366 1
    & call MLSMessage ( MLSMSG_Error, ModuleName, &
d369 1
a369 1
    & call MLSMessage ( MLSMSG_Error, ModuleName, &
d372 1
a372 1
    & call MLSMessage ( MLSMSG_Error, ModuleName, &
d378 1
a378 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d383 1
a383 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d404 1
a404 1
      call MLSMessage ( MLSMSG_Error, moduleName, &
d420 1
a420 1
      call MLSMessage ( MLSMSG_Error, moduleName, &
d524 1
a524 1
       call MLSMessage( MLSMSG_Error, ModuleName, &
d607 1
a607 1
         call MLSMessage ( MLSMSG_Error, moduleName, &
d899 1
a899 1
       "$Id: MLSL2.f90,v 2.233 2020/04/09 23:17:46 pwagner Exp $"
d908 3
@


2.233
log
@Improved wording in Dump_settings
@
text
@d13 2
a14 2
  use Allocate_DeAllocate, only: AllocateLogUnit, Set_Garbage_Collection, &
    & TrackAllocates
d628 1
d899 1
a899 1
       "$Id: MLSL2.f90,v 2.232 2019/08/01 23:46:50 pwagner Exp $"
d908 3
@


2.232
log
@Some Housekeeping
@
text
@d795 1
a795 1
      call outputNamedValue ( 'Unretrieved states fill', STATEFILLEDBYSKIPPEDRETRIEVALS, advance='yes', &
d813 1
a813 1
      call outputNamedValue ( 'Restart counting warnings at each phase?', restartWarnings, advance='yes', &
d865 1
a865 1
      ! Neither of these sections have been complted yet
d898 1
a898 1
       "$Id: MLSL2.f90,v 2.231 2019/04/11 23:43:43 pwagner Exp $"
d907 3
@


2.231
log
@cmdline options --help,--version, and -S'?' now print only relevant stuff
@
text
@d59 1
a59 1
  use Output_M, only: Blanks, flushStdout, Output, &
d61 1
a61 1
    & StampOptions, StdoutPrUnit, SwitchOutput, RevertOutput
d65 1
a65 1
  use PCFHdr, only: DumpGlobalAttributes
d151 7
d159 2
a160 5
  character(len=*), parameter :: L2CFNAMEEXTENSION = ".l2cf"
  logical, parameter          :: WAITFORSCRIPT     = .true.

  integer :: ERROR                 ! Error flag from check_tree
  integer :: FIRST_SECTION         ! Index of son of root of first n_cf node
d163 1
a163 1
  integer, dimension(1) :: ICHUNKS
d165 1
a165 1
  character(len=2048) :: LINE      ! Into which is read the command args
d167 1
a167 1
  integer :: NUMFILES
d169 2
a170 2
  integer :: ROOT                  ! of the abstract syntax tree
  integer :: STATUS                ! From OPEN
d179 1
a179 1
  type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
d187 1
a187 1
  nullify (filedatabase)
d205 1
a205 1
  FILESTRINGTABLE = .true.
d213 1
a213 1
  MLSMSG_Severity_to_quit = MAX(QUIT_ERROR_THRESHOLD, MLSMSG_Debug+1)
d224 2
d254 1
a254 1
  MLSMSG_Severity_to_quit = MAX(QUIT_ERROR_THRESHOLD, MLSMSG_Debug+1)
d266 2
d273 1
a273 1
     outputOptions%prunit = max( STDOUTPRUNIT, &
d282 1
a282 1
     outputOptions%prunit = STDOUTPRUNIT   ! output sent only to stdout, not logged
d288 1
a288 1
     call set_config ( LogFileUnit = STDOUTLOGUNIT ) ! -1
d325 2
a326 2
  if ( MLSMessageConfig%LogFileUnit == STDOUTLOGUNIT ) &
    & outputOptions%prunit = STDOUTPRUNIT
d342 1
a342 1
  ! (when will this be fixed?)
d351 9
d438 1
a438 1
  numfiles = AddFileToDataBase(filedatabase, MLSL2CF)
d485 1
a485 1
    call mls_closeFile ( filedatabase(numfiles), error )
d552 1
a552 1
        & filedatabase )
d598 2
a599 2
        call Deallocate_filedatabase(filedatabase)
        call output('Deallocated filedatabase', advance='yes')
d713 2
a714 1
!     use, intrinsic :: ISO_FORTRAN_ENV, only: Compiler_Options, Compiler_Version
d742 1
a742 1
      call outputNamedValue ( 'Error threshold before halting', quit_error_threshold, advance='yes', &
d750 1
a750 1
      call outputNamedValue ( 'uniqueID ID', trim(uniqueID), advance='yes', &
d898 1
a898 1
       "$Id: MLSL2.f90,v 2.230 2019/03/08 17:15:49 pwagner Exp $"
d907 3
@


2.230
log
@Still correcting mis-directed output
@
text
@d204 4
a207 4
call SwitchOutput ( 'stdout' )
call Dump( OutputOptions )
call DumpConfig
call RevertOutput
d255 1
a255 1
! print *, 'Enforcing output destinations'
d846 3
a848 1
      call DumpGlobalAttributes
d880 1
a880 1
       "$Id: MLSL2.f90,v 2.229 2019/02/13 17:31:27 pwagner Exp $"
d889 3
@


2.229
log
@change outputOptions%prunit to L2Options only if default value is Overriden
@
text
@d39 1
a39 1
    & L2cf_Unit, Level1_HDFVersion, MaxChunkSize, Need_L1BFiles, &
d61 1
a61 1
    & StampOptions, StdoutPrUnit
d204 4
d237 5
a241 1
  ! stop
d255 4
d260 5
a264 1
  if ( .not. toolkit .or. showDefaults ) then
d270 1
a270 1
  else if ( parallel%master .and. .not. L2Options%Overriden ) then
d272 2
a273 1
  else if ( parallel%slave .and. .not. L2Options%Overriden ) then
d278 2
a279 1
  if( i == 0 .or. i > 5 .or. .not. toolkit ) then
d315 4
d518 6
a523 1
  !---------------- Task (7) ------------------
d839 2
d844 1
d878 1
a878 1
       "$Id: MLSL2.f90,v 2.228 2019/01/31 19:23:05 pwagner Exp $"
d887 3
@


2.228
log
@Removed more unused stuff
@
text
@d60 1
a60 1
    & InvalidPrUnit, MSGLogPrUnit, OutputOptions, PrUnitName, &
d254 3
a256 3
  else if (parallel%master) then
     outputOptions%prunit = MSGLOGPRUNIT   ! output both logged, not sent to stdout
  else if (parallel%slave) then
d848 1
a848 1
       "$Id: MLSL2.f90,v 2.227 2018/12/07 00:20:47 pwagner Exp $"
d857 3
@


2.227
log
@If cmdline says to skip retrievals, must skip even if l2cf says otherwise
@
text
@d27 1
a27 1
    & SlaveArguments, TransmitSlaveArguments
d59 1
a59 1
  use Output_M, only: Beep, Blanks, flushStdout, Output, &
d73 2
a74 2
  use Time_M, only: SayTime_Config, Time_Config, Begin, ConfigureSayTime, Dump, Finish, &
    & SayTime, Time_Now
a160 1
  ! integer :: LastCHUNK = 0         ! Just run range [SINGLECHUNK-LastCHUNK]
a164 1
  ! integer :: RECL = 20000          ! Record length for l2cf (but see --recl opt)
a165 1
  integer, parameter :: sleepSeconds = 1000000 ! 1 second in microseconds
d848 1
a848 1
       "$Id: MLSL2.f90,v 2.226 2018/09/13 20:25:19 pwagner Exp $"
d857 3
@


2.226
log
@Moved changeable options to new L2Options; added DumpOptions
@
text
@d428 3
a505 1
      ! skipRetrievalOriginal = skipRetrieval
d851 1
a851 1
       "$Id: MLSL2.f90,v 2.225 2018/05/22 23:08:40 pwagner Exp $"
d860 3
@


2.225
log
@Dumped settings include GlobalAttributes
@
text
@d41 1
a41 1
    & OriginalCmds, Output_Print_Unit, &
d47 1
a47 1
    & SkipRetrieval, SkipRetrievalOriginal, SlavesCleanUpSelves, SlaveMAF, &
d60 2
a61 1
    & InvalidPrUnit, MSGLogPrUnit, OutputOptions, StampOptions, StdoutPrUnit
d69 1
a69 1
    & PGSD_DEM_Elev, PGSD_DEM_Water_Land, useSDPToolkit, PGS_DEM_Close
d207 1
a207 1
  outputOptions%prunit = OUTPUT_PRINT_UNIT
d220 1
a220 1
  ORIGINALCMDS = ' '
d232 1
a232 1
    ORIGINALCMDS = trim(ORIGINALCMDS) // null // trim(line)
d234 2
a235 1
  line = processOptions( trim(ORIGINALCMDS), null )
d501 1
a501 1
      skipRetrieval = ( skipRetrieval .or.  stopAfterSection /= ' ' )
d503 2
a504 1
      skipRetrievalOriginal = skipRetrieval
d550 1
a550 1
      & (SKIPDIRECTWRITES .or. SKIPRETRIEVAL .or. sectionsToSkip /= ' ' ) ) then
d684 1
a684 1
    call output ( trim(ORIGINALCMDS), advance='yes' )
d749 1
a749 1
      call outputNamedValue ( 'Skip all retrievals?', SKIPRETRIEVAL, advance='yes', &
d760 1
a760 1
      call outputNamedValue ( 'Standard output unit', outputOptions%prunit, advance='yes', &
d763 1
a763 1
      call outputNamedValue ( 'Log file unit', logFileUnit, advance='yes', &
d849 1
a849 1
       "$Id: MLSL2.f90,v 2.224 2017/12/22 00:32:00 pwagner Exp $"
d858 3
@


2.224
log
@Try harder to make slaves flush stdout buffer
@
text
@d64 1
d814 1
d846 1
a846 1
       "$Id: MLSL2.f90,v 2.223 2017/03/23 16:57:38 pwagner Exp $"
d855 3
@


2.223
log
@Improved Dump_settings appearance
@
text
@d59 1
a59 1
  use Output_M, only: Blanks, Output, &
d584 2
d844 1
a844 1
       "$Id: MLSL2.f90,v 2.222 2017/01/25 18:10:22 pwagner Exp $"
d853 3
@


2.222
log
@May skip certain Phases named in phasesToSkip cmdline opt
@
text
@a152 1
  character(len=24) :: arg
d700 1
a700 1
      call outputNamedValue ( 'uniqueID ID', uniqueID, advance='yes', &
d725 5
a729 3
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
        call outputNamedValue ( 'Note file', trim(noteFile), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
d842 1
a842 1
       "$Id: MLSL2.f90,v 2.221 2017/01/11 23:56:53 pwagner Exp $"
d851 3
@


2.221
log
@Dumps both time configs; Dump MLSFile type if l2cf error
@
text
@d13 1
a13 1
  use Allocate_DeAllocate, only: AllocateLogUnit, set_garbage_collection, &
d15 4
a18 3
  use Call_Stack_m, only: Show_Sys_Memory, sys_memory_ch, sys_memory_convert
  use ChunkDivide_m, only: ChunkDivideConfig
  use Declaration_Table, only: Allocate_decl, deAllocate_decl, Dump_decl
d20 12
a31 12
  use HDF, only: dfacc_rdonly
  use HighOutput, only: Dump, headLine, OutputNamedValue
  use Init_Tables_module, only: init_Tables
  use Io_stuff, only: Write_textFile
  use Intrinsic, only: Get_type, l_ascii, l_tkgen, lit_indices
  use L2GPData, only: avoidUnlimitedDims
  use L2ParInfo, only: parallel, initParallel, accumulateSlaveArguments, &
    & SlaveArguments, transmitSlaveArguments
  use LeakCheck_m, only: LeakCheck
  use Lexer_core, only: init_lexer
  use Machine, only: Getarg, hp, io_error, USleep
  use MLSCommon, only: MLSFile_t, MLSNamesAreDebug, MLSNamesAreVerbose
d37 7
a43 7
    & CheckL2CF, CheckLeak, checkPaths, countChunks, current_Version_id, &
    & Default_HDFVersion_Read, default_HDFVersion_Write, do_Dump, Dump_Tree, &
    & L2cf_Unit, level1_HDFVersion, maxChunkSize, need_L1BFiles, &
    & Normal_exit_status, noteFile, numSwitches, &
    & OriginalCmds, Output_print_Unit, &
    & Patch, processOptions, Quit_error_threshold, &
    & Recl, restartWarnings, runTimeValues, &
d45 1
a45 1
    & SharedPCF, showDefaults, & ! sips_Version, &
d48 5
a52 5
    & SpecialDumpFile, stateFilledBySkippedRetrievals, &
    & StopAfterSection, stopWithError, &
    & Timing, toolkit, totalTimes, uniqueID
  use MLSL2Timings, only: run_start_Time, Section_Times, total_Times, &
    & Add_to_Section_Timing, Dump_Section_Timings
d54 1
a54 1
    & MLSMessageConfig, MLSMSG_Error, MLSMSG_Severity_to_Quit, &
d56 2
a57 2
  use MLSPCF2 ! everything
  use MLSStrings, only: trim_safe
d59 1
a59 1
  use Output_m, only: Blanks, Output, &
d61 4
a64 4
  use Parser, only: clean_up_Parser, Configuration
  use Parser_Table_m, only:  Destroy_Parser_Table, Parser_Table_t
  use Parser_Tables_l2cf, only: init_Parser_Table
  use Printit_m, only: Set_Config, StdoutLogUnit
d67 11
a77 11
    & PGSD_DEM_elev, PGSD_DEM_water_land, UseSDPToolkit, PGS_DEM_Close
  use String_Table, only: Destroy_char_Table, Destroy_hash_Table, &
    & Destroy_String_Table, Get_String, addinUnit
  use Symbol_Table, only: Destroy_symbol_Table
  use Time_m, only: sayTime_Config, Time_Config, begin, ConfigureSayTime, Dump, finish, &
    & SayTime, Time_now
  use Toggles, only: levels, syn, switches, toggle
  use Track_m, only: ReportLeaks
  use Tree, only: Allocate_Tree, deAllocate_Tree, nsons, subTree
  use Tree_checker, only: check_Tree
  use Tree_Walker, only: Walk_Tree_to_do_MLS_l2
d506 1
a506 1
        & filedatabase, sectionsToSkip )
d666 1
a666 1
    use PRINTIT_M, only: GET_CONFIG
d671 2
d687 3
a689 2
    if( SwitchDetail(switches, 'opt') > 0 .or. showDefaults ) then
      call blanks(80, fillChar='-', advance='yes')
d727 1
a727 1
        call outputNamedValue ( 'Note file', noteFile, advance='yes', &
a743 2
      call outputNamedValue ( 'Skip these sections?', trim_safe(sectionsToSkip), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
a752 12
      if ( switches /= ' ' ) then
        call outputNamedValue ( '(All switches)', trim(switches), advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      end if
      if ( MLSNamesAreDebug /= ' ' ) then
        call outputNamedValue ( '(Modules to debug)', trim(MLSNamesAreDebug), advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      end if
      if ( MLSNamesAreVerbose /= ' ' ) then
        call outputNamedValue ( '(Modules are verbose)', trim(MLSNamesAreVerbose), advance='yes', &
          & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      end if
d794 16
a809 5
      call blanks(80, fillChar='-', advance='yes')
      call dump(outputOptions)
      call dump(stampOptions)
      call dumpConfig
      call blanks(80, fillChar='-', advance='yes')
d841 1
a841 1
       "$Id: MLSL2.f90,v 2.220 2016/11/08 17:30:57 pwagner Exp $"
d850 3
@


2.220
log
@Use SayTime subroutine from time_m module
@
text
@d13 2
a14 2
  use allocate_deallocate, only: allocatelogunit, set_garbage_collection, &
    & trackallocates
d16 2
a17 2
  use chunkDivide_m, only: chunkDivideConfig
  use declaration_table, only: allocate_decl, deallocate_decl, dump_decl
d20 4
a23 4
  use highoutput, only: dump, headLine, outputNamedValue
  use init_tables_module, only: init_tables
  use io_stuff, only: write_textFile
  use intrinsic, only: get_type, l_ascii, l_tkgen, lit_indices
d27 28
a54 28
  use leakcheck_m, only: leakcheck
  use lexer_core, only: init_lexer
  use machine, only: getarg, hp, io_error, USleep
  use MLSCommon, only: MLSFile_t, MLSNamesAreDebug, MLSnamesAreVerbose
  use MLSFiles, only: filestringtable, &
    & addFileToDatabase, deallocate_filedatabase, dump, &
    & initializeMLSfile, MLS_openfile, MLS_closefile
  use MLSHDF5, only: MLS_h5open, MLS_h5close
  use MLSL2Options, only: allocFile, aura_l1bfiles, &
    & checkl2cf, checkleak, checkPaths, countchunks, current_version_id, &
    & default_hdfversion_read, default_hdfversion_write, do_dump, dump_tree, &
    & l2cf_unit, level1_hdfversion, maxChunkSize, need_l1bfiles, &
    & normal_exit_status, noteFile, numSwitches, &
    & originalCmds, output_print_unit, &
    & patch, processOptions, quit_error_threshold, &
    & recl, restartWarnings, runtimeValues, &
    & sectionsToSkip, sectionTimes, sectionTimingUnits, &
    & sharedPCF, showDefaults, & ! sips_version, &
    & skipDirectWrites, skipDirectWritesOriginal, &
    & skipRetrieval, skipRetrievalOriginal, slavesCleanUpSelves, slaveMAF, &
    & specialDumpFile, stateFilledBySkippedRetrievals, &
    & stopAfterSection, stopWithError, &
    & timing, toolkit, totaltimes, uniqueID
  use MLSL2Timings, only: run_start_time, section_times, total_times, &
    & add_to_section_timing, dump_section_timings
  use MLSMessageModule, only: MLSMessage, MLSMSG_Debug, &
    & MLSMessageConfig, MLSMSG_Error, MLSMSG_Severity_to_quit, &
    & MLSMSG_Success, MLSMSG_Warning, dumpConfig, MLSMessageExit
d57 20
a76 19
  use MLSStringLists, only: expandstringrange, PutHashElement, switchdetail
  use output_m, only: blanks, output, &
    & invalidprunit, msglogprunit, outputoptions, stampoptions, stdoutprunit
  use parser, only: clean_up_parser, configuration
  use parser_table_m, only:  destroy_parser_table, parser_table_t
  use parser_tables_l2cf, only: init_parser_table
  use printit_m, only: set_config, stdoutlogunit
  use pvm, only: clearpvmargs, freepvmargs
  use SDPToolkit, only: PGSD_dem_30arc, PGSD_dem_90arc, &
    & PGSD_dem_elev, PGSD_dem_water_land, usesdptoolkit, pgs_dem_close
  use string_table, only: destroy_char_table, destroy_hash_table, &
    & destroy_string_table, get_string, addinunit
  use symbol_table, only: destroy_symbol_table
  use time_m, only: begin, finish, SayTime, time_now, time_config
  use toggles, only: levels, syn, switches, toggle
  use track_m, only: reportleaks
  use tree, only: allocate_tree, deallocate_tree, nsons, subtree
  use tree_checker, only: check_tree
  use tree_walker, only: walk_tree_to_do_MLS_l2
d189 1
a189 1
  call mls_h5open ( error )
d192 1
a192 1
        & "Unable to mls_h5open" )
d298 1
a298 1
  if ( time_config%use_wall_clock ) call time_now(run_start_time)
d305 2
a306 2
    ! Issue warning about l2pc files
    call MLSMessage ( MLSMSG_Warning, ModuleName, &
d358 1
a358 1
    call mls_openFile(MLSL2CF, status)
d361 1
a361 1
      call mls_openFile(MLSL2CF, status)
d368 1
a368 1
      call announce_success(MLSL2CF%name, l2cf_unit)
d384 1
a384 1
      call announce_success(MLSL2CF%name, inunit)
d436 3
d482 2
a483 2
       call MLSMessage(MLSMSG_Error, ModuleName, &
       & 'error in check_tree: probably need to repair l2cf ' )
d561 1
a561 1
          & "Unable to mls_close" )
d840 1
a840 1
       "$Id: MLSL2.f90,v 2.219 2016/11/04 19:32:11 pwagner Exp $"
d849 3
@


2.219
log
@Locate calculation of MLSMSG_Severity_to_quit appropriately
@
text
@d70 1
a70 1
  use time_m, only: begin, finish, time_now, time_config
d435 1
a435 1
  if ( timing ) call sayTime ( 'Parsing the L2CF' )
d466 1
a466 1
    if ( timing ) call sayTime ( 'Type checking the L2CF' )
d504 1
a504 1
        call sayTime ( 'Processing' )
d574 1
a574 1
  if ( timing ) call sayTime ( 'Closing and deallocating' )
a622 12
  subroutine SayTime ( What )
    character(len=*), intent(in) :: What
    call time_now ( t2 )
    if ( total_times ) then
      call output ( "Total time = " )
      call output ( dble(t2), advance = 'no' )
      call blanks ( 4, advance = 'no' )
    end if
    call output ( "Timing for " // what // " = " )
    call output ( dble(t2 - t1), advance = 'yes' )
  end subroutine SayTime

a697 10
      call outputNamedValue ( 'Avoiding unlimited dimensions in directwrites?', &
        & avoidUnlimitedDims, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Allow overlaps outside proc. range?', &
        & (/ChunkDivideConfig%allowPriorOverlaps, ChunkDivideConfig%allowPostOverlaps/), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Is this run in forward model parallel?', parallel%fwmParallel, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Avoid creating file on first directWrite?', patch, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
d788 12
d836 1
a836 1
       "$Id: MLSL2.f90,v 2.218 2016/05/27 00:05:22 pwagner Exp $"
d845 3
@


2.218
log
@Should now correctly process options containing an embedded space
@
text
@d239 1
d846 1
a846 1
       "$Id: MLSL2.f90,v 2.217 2016/03/18 18:00:15 pwagner Exp $"
d855 3
@


2.217
log
@Dont let -Smess override effect of --loconic option
@
text
@d26 1
a26 1
    & transmitSlaveArguments
d160 1
d184 1
d229 1
a229 1
    ORIGINALCMDS = trim(ORIGINALCMDS) // ' ' // trim(line)
d231 1
a231 1
  line = processOptions( trim(ORIGINALCMDS ) )
d239 1
a239 1

d845 1
a845 1
       "$Id: MLSL2.f90,v 2.216 2016/02/29 19:51:07 pwagner Exp $"
d854 3
@


2.216
log
@Usleep got from machine module instead of being an external
@
text
@d268 1
d283 5
a287 2
    MLSMessageConfig%skipModuleNamesThr = MLSMSG_Success
    MLSMessageConfig%skipSeverityThr    = MLSMSG_Success
d843 1
a843 1
       "$Id: MLSL2.f90,v 2.215 2015/10/06 00:22:09 pwagner Exp $"
d852 3
@


2.215
log
@Automatically store l2cf name in runtime Boolean 'l2cf'
@
text
@d29 1
a29 1
  use machine, only: getarg, hp, io_error
a180 1
  external :: USLEEP
d839 1
a839 1
       "$Id: MLSL2.f90,v 2.214 2015/09/24 22:07:57 pwagner Exp $"
d848 3
@


2.214
log
@Dump_settings shows max chunk size appended to l2gp files
@
text
@d25 2
a26 2
  use L2ParInfo, only: parallel, initparallel, accumulateslavearguments, &
    & transmitslavearguments
d30 1
a30 1
  use MLScommon, only: MLSFile_t, MLSNamesAreDebug, MLSnamesAreVerbose
d35 15
a49 14
  use MLSL2Options, only: allocFile, checkPaths, current_version_id, &
    & default_hdfversion_read, default_hdfversion_write, &
    & level1_hdfversion, aura_l1bfiles, maxChunkSize, need_l1bfiles, &
    & normal_exit_status, noteFile, output_print_unit, &
    & patch, quit_error_threshold, restartWarnings, &
    & sectionTimes, sectionTimingUnits, sharedPCF, & ! sips_version, &
    & skipDirectWrites, skipDirectWritesOriginal, slavesCleanUpSelves, &
    & skipRetrieval, skipretrievaloriginal, &
    & specialdumpfile, statefilledbyskippedretrievals, &
    & stopaftersection, stopwitherror, &
    & toolkit, totaltimes, processoptions, &
    & checkl2cf, checkleak, countchunks, do_dump, dump_tree, l2cf_unit, &
    & numswitches, originalcmds, recl, &
    & sectionstoskip, showdefaults, slavemaf, stopAfterSection, timing, uniqueID
d52 3
a54 3
  use MLSMessagemodule, only: MLSMessage, MLSMsg_debug, &
    & MLSMessageconfig, MLSMsg_error, MLSMsg_severity_to_quit, &
    & MLSMsg_success, MLSMsg_warning, dumpconfig, MLSMessageexit
d57 1
a57 2
  use MLSStringlists, only: expandstringrange, &
    & switchdetail
d385 5
d840 1
a840 1
       "$Id: MLSL2.f90,v 2.213 2015/07/16 22:13:15 pwagner Exp $"
d849 3
@


2.213
log
@Dump of settings says whether it will stop after a named section
@
text
@d37 1
a37 1
    & level1_hdfversion, aura_l1bfiles, need_l1bfiles, &
d792 2
d835 1
a835 1
       "$Id: MLSL2.f90,v 2.212 2014/12/10 23:04:54 pwagner Exp $"
d844 3
@


2.212
log
@Removed unused stuff
@
text
@d48 1
a48 1
    & sectionstoskip, showdefaults, slavemaf, timing, uniqueID
d733 4
d833 1
a833 1
       "$Id: MLSL2.f90,v 2.211 2014/09/11 18:28:35 pwagner Exp $"
d842 3
@


2.211
log
@Added -Smem[units] switch to show sys memory
@
text
@d16 1
a16 1
  use chunkdivide_m, only: chunkdivideconfig
d19 2
a20 3
  use GetResourceUsage_m, only: GetPID
  use hdf, only: dfacc_rdonly
  use highoutput, only: dump, headline, outputNamedValue
d22 1
a22 1
  use io_stuff, only: read_textFile, write_textFile
d24 2
a25 2
  use l2gpdata, only: avoidunlimiteddims
  use l2parinfo, only: parallel, initparallel, accumulateslavearguments, &
d34 2
a35 2
  use MLShdf5, only: MLS_h5open, MLS_h5close
  use MLSl2options, only: allocFile, checkPaths, current_version_id, &
d49 1
a49 1
  use MLSl2timings, only: run_start_time, section_times, total_times, &
d51 6
a56 6
  use MLSmessagemodule, only: MLSmessage, MLSmsg_debug, &
    & MLSmessageconfig, MLSmsg_error, MLSmsg_severity_to_quit, &
    & MLSmsg_success, MLSmsg_warning, dumpconfig, MLSmessageexit
  use MLSpcf2 ! everything
  use MLSstrings, only: asciify, trim_safe
  use MLSstringlists, only: expandstringrange, &
d65 2
a66 2
  use sdptoolkit, only: pgsd_dem_30arc, pgsd_dem_90arc, &
    & pgsd_dem_elev, pgsd_dem_water_land, usesdptoolkit, pgs_dem_close
d554 4
a557 4
    resolutionList(1) = PGSd_DEM_30ARC
    resolutionList(2) = PGSd_DEM_90ARC
    layerList(1) = PGSd_DEM_ELEV
    layerList(2) = PGSd_DEM_WATER_LAND
d829 1
a829 1
       "$Id: MLSL2.f90,v 2.210 2014/09/05 01:07:49 vsnyder Exp $"
d838 3
@


2.210
log
@Remove ProcessID stuff.  Destroy Empirical Geometry explicitly
@
text
@d15 1
d21 1
a21 1
  use highoutput, only: dump, headline, outputnamedvalue
d390 14
d697 3
d830 1
a830 1
       "$Id: MLSL2.f90,v 2.209 2014/09/05 00:49:07 vsnyder Exp $"
d839 3
@


2.209
log
@EmpiricalGeometry.f90
@
text
@d812 1
a812 1
       "$Id: MLSL2.f90,v 2.208 2014/09/02 18:18:23 pwagner Exp $"
d821 3
@


2.208
log
@Uses noteFile mechanism for telling our wrapper script we finished
@
text
@d17 2
d30 1
a30 2
  use MLScommon, only: MLSFile_t, MLSNamesAreDebug, MLSnamesAreVerbose, &
    & processID
a338 8
    if ( len_trim(notefile) > 0 ) then
      call USleep( 25*sleepSeconds )
      call read_textFile ( notefile, arg )
      processID = asciify ( arg, how='snip' )
      call output( 'Read process ID from note file', advance='no' )
      call output( '  ' // trim(processID), advance='no' )
      call output( '  ' // trim(notefile), advance='yes' )
    endif
a494 2
  ! (Yes, this is the very same noteFile we read our processID
  ! from earlier; we don't need it any more; hope no one else will, either)
d501 1
d547 1
a547 1
  endif
a679 2
      call outputNamedValue ( 'Process ID', processID, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
d812 1
a812 1
       "$Id: MLSL2.f90,v 2.207 2014/06/30 23:26:58 pwagner Exp $"
d821 3
@


2.207
log
@Can log allocations/deallocations to separate file
@
text
@d20 1
d28 4
a31 3
  use MLScommon, only: MLSfile_t, MLSnamesaredebug, MLSnamesareverbose
  use MLSfiles, only: filestringtable, &
    & addfiletodatabase, deallocate_filedatabase, dump, &
d37 1
a37 1
    & normal_exit_status, output_print_unit, &
d47 1
a47 1
    & sectionstoskip, showdefaults, slavemaf, timing
d54 1
a54 1
  use MLSstrings, only: trim_safe
d148 1
d150 1
d163 1
d180 1
d338 8
d500 8
d561 6
d569 2
a570 2
  else if(NORMAL_EXIT_STATUS /= 0 .and. .not. parallel%slave) then
     call MLSMessageExit(NORMAL_EXIT_STATUS)
d684 1
a684 1
      call outputNamedValue ( 'Default hdf version for l1b files', level1_hdfversion, advance='yes', &
d686 1
a686 3
      call outputNamedValue ( 'Default hdfeos version on reads', default_hdfversion_read, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Default hdfeos version on writes', default_hdfversion_write, advance='yes', &
d688 1
a688 1
      call outputNamedValue ( 'PCF shared with level 1?', SHAREDPCF, advance='yes', &
d690 1
a690 1
      call outputNamedValue ( 'Range of chunks', trim_safe(parallel%chunkRange), advance='yes', &
d723 2
d775 6
d822 1
a822 1
       "$Id: MLSL2.f90,v 2.206 2014/05/20 23:56:53 vsnyder Exp $"
d831 3
@


2.206
log
@New parser gets its tables from an argument instead of an include
@
text
@d13 60
a72 60
  use ALLOCATE_DEALLOCATE, only: SET_GARBAGE_COLLECTION, TRACKALLOCATES
  use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG
  use DECLARATION_TABLE, only: ALLOCATE_DECL, DEALLOCATE_DECL, DUMP_DECL
  use HDF, only: DFACC_RDONLY
  use HIGHOUTPUT, only: DUMP, HEADLINE, OUTPUTNAMEDVALUE
  use INIT_TABLES_MODULE, only: INIT_TABLES
  use Intrinsic, only: Get_Type
  use INTRINSIC, only: L_ASCII, L_TKGEN, LIT_INDICES
  use L2GPDATA, only: AVOIDUNLIMITEDDIMS
  use L2PARINFO, only: PARALLEL, INITPARALLEL, ACCUMULATESLAVEARGUMENTS, &
    & TRANSMITSLAVEARGUMENTS
  use LEAKCHECK_M, only: LEAKCHECK
  use LEXER_CORE, only: INIT_LEXER
  use MACHINE, only: GETARG, HP, IO_ERROR
  use MLSCOMMON, only: MLSFILE_T, MLSNAMESAREDEBUG, MLSNAMESAREVERBOSE
  use MLSFILES, only: FILESTRINGTABLE, &
    & ADDFILETODATABASE, DEALLOCATE_FILEDATABASE, DUMP, &
    & INITIALIZEMLSFILE, MLS_OPENFILE, MLS_CLOSEFILE
  use MLSHDF5, only: MLS_H5OPEN, MLS_H5CLOSE
  use MLSL2OPTIONS, only: CHECKPATHS, CURRENT_VERSION_ID, &
    & DEFAULT_HDFVERSION_READ, DEFAULT_HDFVERSION_WRITE, &
    & LEVEL1_HDFVERSION, AURA_L1BFILES, NEED_L1BFILES, &
    & NORMAL_EXIT_STATUS, OUTPUT_PRINT_UNIT, &
    & PATCH, QUIT_ERROR_THRESHOLD, RESTARTWARNINGS, &
    & SECTIONTIMES, SECTIONTIMINGUNITS, SHAREDPCF, & ! SIPS_VERSION, &
    & SKIPDIRECTWRITES, SKIPDIRECTWRITESORIGINAL, SLAVESDOOWNCLEANUP, &
    & SKIPRETRIEVAL, SKIPRETRIEVALORIGINAL, &
    & SPECIALDUMPFILE, STATEFILLEDBYSKIPPEDRETRIEVALS, &
    & STOPAFTERSECTION, STOPWITHERROR, &
    & TOOLKIT, TOTALTIMES, PROCESSOPTIONS, &
    & CHECKL2CF, CHECKLEAK, COUNTCHUNKS, DO_DUMP, DUMP_TREE, L2CF_UNIT, &
    & NUMSWITCHES, ORIGINALCMDS, RECL, &
    & SECTIONSTOSKIP, SHOWDEFAULTS, SLAVEMAF, TIMING
  use MLSL2TIMINGS, only: RUN_START_TIME, SECTION_TIMES, TOTAL_TIMES, &
    & ADD_TO_SECTION_TIMING, DUMP_SECTION_TIMINGS
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_DEBUG, &
    & MLSMESSAGECONFIG, MLSMSG_ERROR, MLSMSG_SEVERITY_TO_QUIT, &
    & MLSMSG_SUCCESS, MLSMSG_WARNING, DUMPCONFIG, MLSMESSAGEEXIT
  use MLSPCF2 ! EVERYTHING
  use MLSSTRINGS, only: TRIM_SAFE
  use MLSSTRINGLISTS, only: EXPANDSTRINGRANGE, &
    & SWITCHDETAIL
  use OUTPUT_M, only: BLANKS, OUTPUT, &
    & INVALIDPRUNIT, MSGLOGPRUNIT, OUTPUTOPTIONS, STAMPOPTIONS, STDOUTPRUNIT
  use Parser, only: Clean_Up_Parser, Configuration
  use Parser_Table_m, only:  Destroy_Parser_Table, Parser_Table_t
  use Parser_Tables_L2CF, only: Init_Parser_Table
  use PRINTIT_M, only: SET_CONFIG, STDOUTLOGUNIT
  use PVM, only: CLEARPVMARGS, FREEPVMARGS
  use SDPTOOLKIT, only: PGSd_DEM_30ARC, PGSd_DEM_90ARC, &
    & PGSd_DEM_ELEV, PGSd_DEM_WATER_LAND, USESDPTOOLKIT, PGS_DEM_CLOSE
  use STRING_TABLE, only: DESTROY_CHAR_TABLE, DESTROY_HASH_TABLE, &
    & DESTROY_STRING_TABLE, GET_STRING, ADDINUNIT
  use SYMBOL_TABLE, only: DESTROY_SYMBOL_TABLE
  use TIME_M, only: BEGIN, FINISH, TIME_NOW, TIME_CONFIG
  use TOGGLES, only: LEVELS, SYN, SWITCHES, TOGGLE
  use TRACK_M, only: REPORTLEAKS
  use TREE, only: ALLOCATE_TREE, DEALLOCATE_TREE, NSONS, SUBTREE
  use TREE_CHECKER, only: CHECK_TREE
  use TREE_WALKER, only: WALK_TREE_TO_DO_MLS_L2
d340 2
d487 1
a487 1
  if ( .not. parallel%slave .or. SLAVESDOOWNCLEANUP ) then
d534 1
d679 12
a690 12
      call outputNamedValue ( 'Master task number', parallel%myTid, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Command line sent to slaves', trim_safe(parallel%pgeName), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Command to queue slave tasks', trim_safe(parallel%submit), advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Maximum failures per chunk', parallel%maxFailuresPerChunk, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Maximum failures per machine', parallel%maxFailuresPerMachine, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
      call outputNamedValue ( 'Sleep time in masterLoop (mus)', parallel%delay, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
d695 1
a695 1
      call outputNamedValue ( 'Master task number', parallel%masterTid, advance='yes', &
d745 1
a745 1
      call outputNamedValue ( 'Save special dumps to', trim(specialDumpFile), advance='yes', &
d748 4
d788 1
a788 1
       "$Id: MLSL2.f90,v 2.205 2014/03/25 18:19:00 pwagner Exp $"
d797 3
@


2.205
log
@Moved init_tables before dump_settings to avoid crash
@
text
@d57 3
a59 1
  use PARSER, only: CONFIGURATION
d156 1
d394 4
a397 1
    call configuration ( root )
d624 1
d640 4
d781 1
a781 1
       "$Id: MLSL2.f90,v 2.204 2014/03/20 01:42:32 vsnyder Exp $"
d790 3
@


2.204
log
@Get Get_Type from Intrinsic, do init_tables later
@
text
@d318 2
a332 2
  call init_tables
  status = 0
d770 1
a770 1
       "$Id: MLSL2.f90,v 2.203 2014/01/11 01:44:18 vsnyder Exp $"
d779 3
@


2.203
log
@Decruftification
@
text
@d15 1
a15 2
  use DECLARATION_TABLE, only: ALLOCATE_DECL, DEALLOCATE_DECL, DUMP_DECL, &
    & GET_TYPE
d19 1
d189 1
a189 1
  call init_tables
d330 2
d770 1
a770 1
       "$Id: MLSL2.f90,v 2.202 2014/01/09 00:30:24 pwagner Exp $"
d779 3
@


2.202
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d34 1
a34 1
    & LEVEL1_HDFVERSION, AURA_L1BFILES, MLSL2DEBUG, NEED_L1BFILES, &
d768 1
a768 1
       "$Id: MLSL2.f90,v 2.201 2013/12/12 02:10:58 vsnyder Exp $"
d777 3
@


2.201
log
@Add 'debug' to init_lexer, move syntax tree printing into internal subroutine
@
text
@d18 1
d55 1
a55 2
  use OUTPUT_M, only: BLANKS, DUMP, HEADLINE, OUTPUT, &
    & OUTPUTNAMEDVALUE, &
d768 1
a768 1
       "$Id: MLSL2.f90,v 2.200 2013/11/26 22:40:51 vsnyder Exp $"
d777 3
@


2.200
log
@Change -A to -A[n] with n>0 meaning dump the entire tree, including the
type-checking stuff, and n==0 or absent meaning dump only the parser output.
@
text
@d68 1
a68 1
  use TREE, only: ALLOCATE_TREE, DEALLOCATE_TREE, NSONS, PRINT_SUBTREE, SUBTREE
d185 2
a186 1
  call init_lexer ( n_chars=80000, n_symbols=4000, hash_table_size=611957 )
d415 1
a415 5
      if ( dump_tree > 0 ) then
        call print_subtree ( root, 0 )
      else
        call print_subtree ( subtree(nsons(root),root), 0 )
      end if
d425 1
a425 1
    if ( do_dump ) call dump_decl
d428 1
a428 5
      if ( levels(syn) > 0 ) then
        call print_subtree ( root, 0, type_name=get_type )
      else
        call print_subtree ( subtree(nsons(root),root), 0, type_name=get_type )
      end if
d537 30
d768 1
a768 1
       "$Id: MLSL2.f90,v 2.199 2013/11/04 22:56:59 pwagner Exp $"
d777 4
@


2.199
log
@Print which modules are berbose, debugged
@
text
@d66 1
a66 1
  use TOGGLES, only: SYN, SWITCHES, TOGGLE
d68 1
a68 1
  use TREE, only: ALLOCATE_TREE, DEALLOCATE_TREE, PRINT_SUBTREE
d411 1
a411 1
    if ( dump_tree ) then
d414 5
a418 1
      call print_subtree ( root, 0 )
d431 5
a435 1
      call print_subtree ( root, 0, type_name=get_type )
d745 1
a745 1
       "$Id: MLSL2.f90,v 2.198 2013/10/09 23:46:38 vsnyder Exp $"
d754 3
@


2.198
log
@Pass Get_Type to tree dumper
@
text
@d16 1
a16 1
    & Get_Type
d26 1
a26 1
  use MLSCOMMON, only: MLSFILE_T
d58 1
a58 1
  use PrintIt_m, only: Set_Config, StdoutLogUnit
a154 1
! integer :: RECORD_LENGTH
d585 1
a585 1
    use PrintIt_m, only: Get_Config
d676 8
d737 1
a737 1
       "$Id: MLSL2.f90,v 2.197 2013/09/25 18:51:55 pwagner Exp $"
d746 3
@


2.197
log
@Closes DEM stuff before exiting
@
text
@d15 2
a16 1
  use DECLARATION_TABLE, only: ALLOCATE_DECL, DEALLOCATE_DECL, DUMP_DECL
d19 1
a19 2
  use INTRINSIC, only: L_ASCII, L_TKGEN, &
    & LIT_INDICES
d428 1
a428 1
      call print_subtree ( root, 0 )
d730 1
a730 1
       "$Id: MLSL2.f90,v 2.196 2013/09/06 20:58:18 pwagner Exp $"
d739 3
@


2.196
log
@Trying again to prevent slaves from logging to toolkit
@
text
@d60 2
a61 1
  use SDPTOOLKIT, only: USESDPTOOLKIT
d168 5
d512 12
d730 1
a730 1
       "$Id: MLSL2.f90,v 2.195 2013/09/04 17:34:52 pwagner Exp $"
d739 3
@


2.195
log
@Replaced '--cat' cmdline option; 'Catenate' now an Output section command
@
text
@d33 1
a33 1
    & LEVEL1_HDFVERSION, AURA_L1BFILES, NEED_L1BFILES, &
d239 1
d712 1
a712 1
       "$Id: MLSL2.f90,v 2.194 2013/08/23 02:52:13 vsnyder Exp $"
d721 3
@


2.194
log
@Move PrintItOut to PrintIt_m
@
text
@d31 1
a31 1
  use MLSL2OPTIONS, only: CATENATESPLITS, CHECKPATHS, CURRENT_VERSION_ID, &
a606 2
      call outputNamedValue ( 'Catenate split dgg/dgm after run completes?', catenateSplits, advance='yes', &
        & fillChar=fillChar, before='* ', after='*', tabn=4, tabc=62, taba=80 )
d711 1
a711 1
       "$Id: MLSL2.f90,v 2.193 2013/08/17 00:22:14 pwagner Exp $"
d720 3
@


2.193
log
@New cmdline arg relaxes some for non-Aura l1b datasets
@
text
@d49 1
a49 1
    & MLSMSG_SUCCESS, MLSMSG_WARNING, DUMPCONFIG, MLSMESSAGEEXIT, STDOUTLOGUNIT
d58 1
d187 3
a189 2
   outputOptions%prunit = OUTPUT_PRINT_UNIT
   MLSMSG_Severity_to_quit = MAX(QUIT_ERROR_THRESHOLD, MLSMSG_Debug+1)
d242 1
a242 1
     MLSMessageConfig%LogFileUnit = STDOUTLOGUNIT  ! -1
d567 1
d570 1
d662 2
a663 1
      call outputNamedValue ( 'Log file unit', MLSMessageConfig%LogFileUnit, advance='yes', &
d713 1
a713 1
       "$Id: MLSL2.f90,v 2.192 2013/06/28 19:18:42 pwagner Exp $"
d722 3
@


2.192
log
@-Smess[n] and -Sparent switches; other tweaks to output
@
text
@d33 2
a34 1
    & LEVEL1_HDFVERSION, NORMAL_EXIT_STATUS, OUTPUT_PRINT_UNIT, &
a487 2
      call Deallocate_filedatabase(filedatabase)
      call output('Deallocated filedatabase', advance='yes')
d489 2
d495 1
a495 1
          & "We are a slave, thus unable to mls_close in this version" )
d633 3
a635 1
      call outputNamedValue ( 'Need L1B files?', checkPaths, advance='yes', &
d708 1
a708 1
       "$Id: MLSL2.f90,v 2.191 2013/02/12 18:14:38 pwagner Exp $"
d717 3
@


2.191
log
@Removed SIPS_VERSION
@
text
@d46 3
a48 3
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECONFIG, MLSMSG_DEBUG, &
    & MLSMSG_ERROR, MLSMSG_SEVERITY_TO_QUIT, &
    & MLSMSG_WARNING, DUMPCONFIG, MLSMESSAGEEXIT, STDOUTLOGUNIT
a236 1

a239 2
  ! else
    !  MLSMessageConfig%LogFileUnit = DEFAULTLOGUNIT ! -2
d245 21
a265 1
  
d277 1
d293 1
a370 6
    call output('Version built for  ', advance='no')
    if ( .true. ) then ! SIPS_VERSION
      call output('S I P S', advance='yes')
    else
      call output('S C F', advance='yes')
    end if
d489 1
a489 1
      if ( .not. parallel%slave) then
d688 1
a688 1
    character(LEN=*), intent(in)   :: Name
d692 1
a692 1
    call output ( 'name : ' )
d694 1
a694 1
    call output ( trim(Name), advance='no')
d696 1
a696 1
    call output ( 'unit number : ' )
d698 1
a698 1
    call output ( unit_number, advance='yes')
d705 1
a705 1
       "$Id: MLSL2.f90,v 2.190 2012/12/04 00:16:09 pwagner Exp $"
d714 3
@


2.190
log
@Removed confisuion-causing OUTSIDEOVERLAPS and its cmdline option
@
text
@d35 1
a35 1
    & SECTIONTIMES, SECTIONTIMINGUNITS, SHAREDPCF, SIPS_VERSION, &
d54 2
a55 1
    & OUTPUTNAMEDVALUE, OUTPUTOPTIONS, STAMPOPTIONS, STDOUTPRUNIT, MSGLOGPRUNIT
d226 1
a226 1
  if ( .not. toolkit .or. showDefaults .or. .not. outputOptions%buffered ) then
d229 3
d353 1
a353 1
    if ( SIPS_VERSION ) then
d692 1
a692 1
       "$Id: MLSL2.f90,v 2.189 2012/08/21 23:54:01 pwagner Exp $"
d701 3
@


2.189
log
@Fixed certain problems when showing settings
@
text
@d42 1
a42 1
    & NUMSWITCHES, ORIGINALCMDS, OUTSIDEOVERLAPS, RECL, &
a244 2
  chunkdivideconfig%allowPriorOverlaps = OUTSIDEOVERLAPS
  chunkdivideconfig%allowPostOverlaps = OUTSIDEOVERLAPS
d688 1
a688 1
       "$Id: MLSL2.f90,v 2.188 2012/08/16 17:48:47 pwagner Exp $"
d697 3
@


2.188
log
@Exploit new features to fleexibly change how and when to log output
@
text
@d346 1
a346 1
  if( switchDetail(switches, 'opt') > 0 .or. showDefaults ) then
d566 1
a566 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d568 1
a568 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d570 1
a570 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d572 1
a572 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d574 1
a574 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d576 1
a576 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d578 1
a578 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d580 1
a580 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d583 1
a583 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d586 1
a586 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d588 1
a588 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d590 1
a590 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d592 1
a592 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d594 1
a594 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d597 1
a597 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d599 1
a599 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d601 1
a601 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d603 1
a603 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d605 1
a605 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d607 1
a607 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d610 1
a610 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d613 1
a613 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d616 1
a616 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d618 1
a618 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d620 1
a620 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d622 1
a622 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d624 1
a624 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d626 1
a626 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d628 1
a628 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d631 1
a631 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d633 1
a633 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d636 1
a636 1
          & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d639 1
a639 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d641 1
a641 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d643 1
a643 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d645 1
a645 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d647 1
a647 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d649 1
a649 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d652 1
a652 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=80 )
d690 1
a690 1
       "$Id: MLSL2.f90,v 2.187 2012/07/18 00:39:34 pwagner Exp $"
d699 3
@


2.187
log
@Consistent with module parameters for prUnit, LogFileUnit
@
text
@a27 1
    & HDFVERSION_5, &
d48 1
a48 1
    & MLSMSG_WARNING, DUMPCONFIG, MLSMESSAGEEXIT, STDOUTLOGUNIT, DEFAULTLOGUNIT
a151 1
  character(len=len(switches)) :: removeSwitches = ''
a209 1
  print *, 'original CMDS: ', trim(ORIGINALCMDS)
a210 1
  print *, 'Return from processing CMDS: ', trim(line)
d234 2
a235 1
  if( SwitchDetail(switches, 'log') >= 0 .or. .not. toolkit ) then
d237 2
a238 2
  else
     MLSMessageConfig%LogFileUnit = DEFAULTLOGUNIT ! -2
d240 5
d690 1
a690 1
       "$Id: MLSL2.f90,v 2.186 2012/07/10 15:22:25 pwagner Exp $"
d699 3
@


2.186
log
@Moved stuff to MLSL2Options module so it works right
@
text
@d49 1
a49 1
    & MLSMSG_WARNING, DUMPCONFIG, MLSMESSAGEEXIT
d54 2
a55 2
  use OUTPUT_M, only: BLANKS, DUMP, OUTPUT, &
    & OUTPUTNAMEDVALUE, OUTPUTOPTIONS, STAMPOPTIONS
d230 2
a231 1
     outputOptions%prunit = max(-1, outputOptions%prunit)   ! stdout or Fortran unit
d233 1
a233 1
     outputOptions%prunit = -2          ! output both logged and sent to stdout
d235 1
a235 1
     outputOptions%prunit = -1          ! output sent only to stdout, not logged
d239 1
a239 1
     MLSMessageConfig%LogFileUnit = -1
d241 1
a241 1
     MLSMessageConfig%LogFileUnit = -2   ! the default in MLSMessageModule
d561 2
a562 3
      call blanks(70, fillChar='-', advance='yes')
      call output(' -------------- Summary of run time options'      , advance='no')
      call output(' -------------- ', advance='yes')
d564 1
a564 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d566 1
a566 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d568 1
a568 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d570 1
a570 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d572 1
a572 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d574 1
a574 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d576 1
a576 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d578 1
a578 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d581 1
a581 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d584 1
a584 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d586 1
a586 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d588 1
a588 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d590 1
a590 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d592 1
a592 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d595 5
a599 5
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
      call outputNamedValue ( 'Command line sent to slaves', trim(parallel%pgeName), advance='yes', &
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
      call outputNamedValue ( 'Command to queue slave tasks', trim(parallel%submit), advance='yes', &
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d601 1
a601 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d603 1
a603 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d605 1
a605 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d608 1
a608 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d611 1
a611 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d614 1
a614 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d616 1
a616 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d618 1
a618 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d620 1
a620 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d622 1
a622 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d624 1
a624 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d626 1
a626 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d628 2
a629 2
      call outputNamedValue ( 'Summarize time in what units', trim(string), advance='yes', &
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d631 1
a631 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d634 1
a634 1
          & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d637 1
a637 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d639 1
a639 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d641 1
a641 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d643 1
a643 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d645 1
a645 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d647 1
a647 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d650 1
a650 1
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d652 1
a652 1
      call blanks(70, fillChar='-', advance='yes')
d656 1
a656 1
      call blanks(70, fillChar='-', advance='yes')
d688 1
a688 1
       "$Id: MLSL2.f90,v 2.185 2012/07/02 20:34:41 pwagner Exp $"
d697 3
@


2.185
log
@Avoid dumping settings more than one time
@
text
@a176 15
  ! Before looking at command-line options, TOOLKIT is set to SIPS_VERSION
  ! So here's a good place to put any SIPS-specific settings overriding defaults
  if ( SIPS_VERSION ) then
    ! SIPS_VERSION
    parallel%maxFailuresPerMachine = 2
    parallel%maxFailuresPerChunk = 1
    removeSwitches='slv' ! Since slave output already saved to separate files
    switches='red'  ! Usually won't want to dump things looked for in testing
    DEFAULT_HDFVERSION_WRITE = HDFVERSION_5
    MLSMessageConfig%limitWarnings = 4 ! 50 ! Why print all that stuff?
  else
    ! SCF_VERSION
    switches='0sl'
  end if
  time_config%use_wall_clock = SIPS_VERSION
d688 1
a688 1
       "$Id: MLSL2.f90,v 2.184 2012/06/27 18:02:59 pwagner Exp $"
d697 3
@


2.184
log
@May overwrite command line options with options field to phase spec
@
text
@d368 2
a369 1
    call dump_settings
a639 2
!     call outputNamedValue ( 'Stage in memory instead of a file?', parallel%stageInMemory, advance='yes', &
!        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d703 1
a703 1
       "$Id: MLSL2.f90,v 2.183 2012/06/06 20:36:37 vsnyder Exp $"
d712 3
@


2.183
log
@Use Set_Toggles for -aefglpt options
@
text
@d13 1
a13 2
  use ALLOCATE_DEALLOCATE, only: SET_GARBAGE_COLLECTION, TRACKALLOCATES, &
    & CLEARONALLOCATE
d18 1
a18 1
  use INTRINSIC, only: L_ASCII, L_HOURS, L_MINUTES, L_SECONDS, L_TKGEN, &
a19 1
  use IO_STUFF, only: GET_LUN
d21 2
a22 1
  use L2PARINFO, only: PARALLEL, INITPARALLEL, ACCUMULATESLAVEARGUMENTS
d25 1
a25 2
  use LEXER_M, only: CAPIDENTIFIERS
  use MACHINE, only: GETARG, HP, IO_ERROR, NEVERCRASH
d28 1
a28 1
    & HDFVERSION_4, HDFVERSION_5, WILDCARDHDFVERSION, &
d34 1
a34 1
    & LEVEL1_HDFVERSION, NEED_L1BFILES, NORMAL_EXIT_STATUS, OUTPUT_PRINT_UNIT, &
d36 1
a36 1
    & SECTIONTIMINGUNITS, SHAREDPCF, SIPS_VERSION, &
d41 4
a44 1
    & TOOLKIT
d48 1
a48 1
    & MLSMSG_ERROR, MLSMSG_SEVERITY_TO_QUIT, MLSMSG_SEVERITY_TO_WALKBACK, &
d51 3
a53 4
  use MLSSTRINGS, only: LOWERCASE, READINTSFROMCHARS, TRIM_SAFE
  use MLSSTRINGLISTS, only: CATLISTS, EXPANDSTRINGRANGE, &
    & GETSTRINGELEMENT, GETUNIQUELIST, &
    & NUMSTRINGELEMENTS, REMOVEELEMFROMLIST, SWITCHDETAIL, UNQUOTE
a56 1
  use PCFHDR, only: GLOBALATTRIBUTES
d58 1
a58 3
  use SDPTOOLKIT, only: useSDPTOOLKIT
  use Set_Toggles_m, only: Set_Toggles
  use SNOOPMLSL2, only: SNOOPINGACTIVE, SNOOPNAME
d60 1
a60 1
    & DESTROY_STRING_TABLE, DO_LISTING, GET_STRING, ADDINUNIT
a67 1
  use MATRIXMODULE_0, only: CHECKBLOCKS, SUBBLOCKLENGTH
a139 2
  ! Wouldn't it be better to use get_lun at the moment we open the l2cf?
  integer, parameter :: L2CF_UNIT = 20  ! Unit # if L2CF is opened by Fortran
a141 9
  character(len=1) :: arg_rhs      ! 'n' part of 'arg=n'
  character(len=16) :: aSwitch
  character(len=2048) :: command_line ! All the opts
  logical :: COPYARG               ! Copy this argument to parallel command line
  logical :: COUNTCHUNKS = .false. ! Just count the chunks and quit
  logical :: CHECKL2CF = .false.   ! Just check the l2cf and quit
  logical :: CheckLeak = .false.   ! Check parse tree for potential memory leaks
  logical :: DO_DUMP = .false.     ! Dump declaration table
  logical :: DUMP_TREE = .false.   ! Dump tree after parsing
a142 1
  logical :: EXIST
a147 1
  integer :: DEGREE                ! index affecting degree of option
a149 1
  integer :: N                     ! Offset for start of --'s text
d151 1
a151 3
  integer :: NUMSWITCHES
  logical :: OPENED
  integer :: RECL = 20000          ! Record length for l2cf (but see --recl opt)
a154 3
  character(len=128) :: sectionsToSkip = ''
  logical :: showDefaults = .false. ! Just print default opts and quit
  integer :: SLAVEMAF = 0          ! Slave MAF for fwmParallel mode
a155 1
  logical :: SWITCH                ! "First letter after -- was not n"
a156 4
  character(len=len(switches)) :: tempSwitches
  logical :: Timing = .false.      ! -T option is set
  integer :: V                     ! Numeric value after an option
  character(len=2048) :: WORD      ! Some text
a165 1
  character(len=2) :: quotes
a166 1
  quotes = char(34) // char(39)   ! {'"}
d213 1
a213 1
  command_line = ' '
a220 1
    copyArg = .true.
d223 1
a223 410
    command_line = trim(command_line) // ' ' // trim(line)
    if ( line(1:2) == '--' ) then       ! "word" options
      n = 0
      switch = .true.
      if ( line(3:3) == 'n' .or. line(3:3) == 'N' ) then
        switch = .false.
        n = 1
      end if
      if ( lowercase(line(3+n:5+n)) == 'cat' ) then
        catenateSplits = switch
      else if ( line(3+n:8+n) == 'check ' ) then
        checkl2cf = switch
      ! Using lowercase so either --checkPaths or --checkpaths work
      ! Perhaps we should do this for all multiletter options
      ! (single-letter options are case-sensitive)
      else if ( lowercase(line(3+n:8+n)) == 'checkp' ) then
        checkPaths = switch
      else if ( lowercase(line(3+n:7)) == 'chunk' ) then
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        parallel%chunkRange = line
        command_line = trim(command_line) // ' ' // trim(parallel%chunkRange)
      else if ( lowercase(line(3+n:18+n)) == 'clearonallocate ' ) then
        clearonallocate = switch
      else if ( lowercase(line(3+n:7+n)) == 'ckbk ' ) then
        checkBlocks = switch
      else if ( lowercase(line(3+n:14+n)) == 'countchunks ' ) then
        countChunks = switch
      else if ( lowercase(line(3+n:7+n)) == 'crash' ) then
        MLSMessageConfig%crashOnAnyError = switch
        neverCrash = .not. switch
      else if ( lowercase(line(3+n:8+n)) == 'defaul' ) then
        showDefaults = switch
      else if ( line(3+n:7+n) == 'delay' ) then
        call AccumulateSlaveArguments ( line )
        if ( line(8+n:) /= ' ' ) then
          copyArg = .false.
          line(:7+n) = ' '
        else
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
        end if
        read ( line, *, iostat=status ) parallel%Delay
        if ( status /= 0 ) then
          call io_error ( "After --delay option", status, line )
          stop
        end if
      else if ( line(3+n:7+n) == 'dump ' ) then
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        specialDumpFile = trim(line)
      else if ( lowercase(line(3+n:14+n)) == 'fwmparallel ' ) then
        parallel%fwmParallel = .true.
      else if ( lowercase(line(3+n:7+n)) == 'host ' ) then
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        GlobalAttributes%hostName = trim(line)
      else if ( line(3+n:9+n) == 'idents ' ) then
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
      else if ( line(3+n:6+n) == 'kit ' ) then
        MLSMessageConfig%useToolkit = switch
      else if ( lowercase(line(3+n:6+n)) == 'l1b=' ) then
        arg_rhs = line(7+n:7+n)
        select case(arg_rhs)
        case('4')
          LEVEL1_HDFVERSION = HDFVERSION_4
        case('5')
          LEVEL1_HDFVERSION = HDFVERSION_5
        case default
          LEVEL1_HDFVERSION = WILDCARDHDFVERSION
        end select
      else if ( lowercase(line(3+n:8+n)) == 'l2gpr=' ) then
        arg_rhs = line(9+n:9+n)
        select case(arg_rhs)
        case('4')
          DEFAULT_HDFVERSION_READ = HDFVERSION_4
        case('5')
          DEFAULT_HDFVERSION_READ = HDFVERSION_5
        case default
          DEFAULT_HDFVERSION_READ = WILDCARDHDFVERSION
        end select
      else if ( lowercase(line(3+n:8+n)) == 'l2gpw=' ) then
        arg_rhs = line(9+n:9+n)
        select case(arg_rhs)
        case('4')
          DEFAULT_HDFVERSION_WRITE = HDFVERSION_4
        case('5')
          DEFAULT_HDFVERSION_WRITE = HDFVERSION_5
        case default
          DEFAULT_HDFVERSION_WRITE = HDFVERSION_5
        end select
      else if ( line(3+n:5+n) == 'lac' ) then
        ! print *, 'Got the laconic option'
        ! The laconic command-line option trims logged output
        ! resulting from calls to MLSMessageModule which normally prefix
        ! each line with severity and module name; e.g.,
        ! Info (output_m):         ..Exit ReadCompleteHDF5L2PC at 11:37:19.932 
        ! Usage: laconic n where if n is
        ! 0  abbreviate module names 
        ! 1  omit module names and severity unless Warning or worse
        ! 2  omit module names and severity unless Error
        ! 11 skip printing anything unless Warning or worse
        ! 12 skip printing anything unless Error
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        read ( line, *, iostat=status ) degree
        if ( status /= 0 ) then
          call io_error ( "After --lac[onic] option", status, line )
          stop
        end if
        MLSMessageConfig%suppressDebugs = (degree > 0)
        MLSMessageConfig%AbbreviateModSevNames = (degree == 0)
        MLSMessageConfig%skipModuleNamesThr = mod(degree, 10) + 2
        MLSMessageConfig%skipSeverityThr = mod(degree, 10) + 2
        MLSMessageConfig%skipMessageThr = degree - 10 + 2
      else if ( line(3+n:7+n) == 'leak' ) then
        checkLeak = .true.
      else if ( line(3+n:9+n) == 'master ' ) then
        copyArg = .false.
        parallel%master = .true.
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        parallel%slaveFilename = trim ( line )
        call InitParallel ( 0, 0 )
        word = '--slave'
        write ( word(len_trim(word)+1:), * ) parallel%myTid
        call AccumulateSlaveArguments(word)
      else if ( lowercase(line(3+n:21+n)) == 'maxfailuresperchunk' ) then
        call AccumulateSlaveArguments ( line )
        if ( line(22+n:) /= ' ' ) then
          copyArg = .false.
          line(:21+n) = ' '
        else
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
        end if
        read ( line, *, iostat=status ) parallel%maxFailuresPerChunk
        if ( status /= 0 ) then
          call io_error ( "After --maxFailuresPerChunk option", status, line )
          stop
        end if
      else if ( lowercase(line(3+n:23+n)) == 'maxfailurespermachine' ) then
        call AccumulateSlaveArguments ( line )
        if ( line(24+n:) /= ' ' ) then
          copyArg = .false.
          line(:23+n) = ' '
        else
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
        end if
        read ( line, *, iostat=status ) parallel%maxFailuresPerMachine
        if ( status /= 0 ) then
          call io_error ( "After --maxFailuresPerMachine option", status, line )
          stop
        end if
      else if ( lowercase(line(3+n:10+n)) == 'memtrack' ) then
        v = 1
        if ( line(11+n:) /= ' ' ) then
          copyArg = .false.
          read ( line(11+n:), *, iostat=status ) v
          if ( status /= 0 ) then
            call io_error ( "After --memtrack option", status, line )
            stop
          end if
        else
          call getarg ( i+1, line )
          read ( line, *, iostat=status ) j
          if ( status == 0 ) then
            i = i + 1
            command_line = trim(command_line) // ' ' // trim(line)
            v = j
          end if
        end if
        if ( switch ) then
          trackAllocates = v
        else
          trackAllocates = 0
        end if
      else if ( line(3+n:4+n) == 'oa' ) then
        NEED_L1BFILES = switch
      else if ( line(3+n:7+n) == 'overl' ) then
        ChunkDivideConfig%allowPriorOverlaps = switch
        ChunkDivideConfig%allowPostOverlaps = switch
      else if ( line(3+n:8+n) == 'patch ' ) then
        patch = switch
      else if ( lowercase(line(3+n:5+n)) == 'pge ' ) then
        i = i + 1
        call getarg ( i, line )
        parallel%pgeName = trim(line)
        command_line = trim(command_line) // ' ' // trim(adjustl(line))
      else if ( lowercase(line(3+n:6+n)) == 'recl' ) then
        if ( line(7+n:) /= ' ' ) then
          line(:6+n) = ' '
        else
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
        end if
        read ( line, *, iostat=status ) recl
        if ( status /= 0 ) then
          call io_error ( "After --recl option", status, line )
          stop
        end if
      else if ( line(3+n:6+n) == 'shar' ) then
        SHAREDPCF = switch
      else if ( lowercase(line(3+n:9+n))  == 'skipdir' ) then
        SKIPDIRECTWRITES = switch
      else if ( lowercase(line(3+n:10+n)) == 'skipretr' ) then
        SKIPRETRIEVAL = switch
      else if ( lowercase(line(3+n:9+n)) == 'skipsec' ) then
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(adjustl(line))
        sectionsToSkip = lowercase(line)
      else if ( lowercase(line(3+n:10+n)) == 'slavemaf' ) then
        copyArg=.false.
        if ( line(11+n:) /= ' ' ) then
          line(:10+n) = ' '
        else
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(adjustl(line))
        end if
        read ( line, *, iostat=status ) slaveMAF
        if ( status /= 0 ) then
          call io_error ( "After --slaveMAF option", status, line )
          stop
        end if
      else if ( line(3+n:7+n) == 'slave' ) then
        copyArg=.false.
        parallel%slave = .true.
        if ( line(8+n:) /= ' ' ) then
          line(:7+n) = ' '
        else
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(adjustl(line))
        end if
        read ( line, *, iostat=status ) parallel%masterTid
        if ( status /= 0 ) then
          call io_error ( "After --slave option", status, line )
          stop
        end if
        MLSMessageConfig%SendErrMsgToMaster = .true.
        MLSMessageConfig%masterTID = parallel%masterTid
      else if ( line(3+n:8+n) == 'snoop ' ) then
        snoopingActive = .true.
      else if ( lowercase(line(3+n:12+n)) == 'snoopname' ) then
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        snoopName = line
      else if ( line(3+n:7+n) == 'state' ) then
        if ( line(8+n:) /= ' ' ) then
          line(:7+n) = ' '
        else
          i = i + 1
          call AccumulateSlaveArguments ( line )
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(adjustl(line))
        end if
        read ( line, *, iostat=status ) stateFilledBySkippedRetrievals
        if ( status /= 0 ) then
          call io_error ( "After --state option", status, line )
          stop
        end if
      else if ( line(3+n:9+n) == 'stdout ' ) then
        ! copyArg = .false. ! else all the the slaves would try to write to the same file
        copyArg = .true.
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        OutputOptions%name = trim(line)
        OutputOptions%buffered = .false.
        ! outputOptions%debugUnit = 32
        ! Make certain prUnit won't be l2cf_unit
        open( unit=l2cf_unit, status='unknown' )
        call get_lun ( OutputOptions%prUnit, msg=.false. )
        close( unit=l2cf_unit )
        inquire( unit=OutputOptions%prUnit, exist=exist, opened=opened )
      ! else if ( lowercase(line(3+n:9+n)) ==  'stgmem ' ) then
      ! parallel%stageInMemory = .true.
      else if ( lowercase(line(3+n:12+n)) ==  'stopafter ' ) then
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, stopAfterSection )
        command_line = trim(command_line) // ' ' // trim(adjustl(stopAfterSection))
      else if ( lowercase(line(3+n:12+n)) ==  'stopwither' ) then
        stopWithError = switch
      else if ( lowercase(line(3+n:11+n)) == 'subblock ' ) then
        call AccumulateSlaveArguments ( line )
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        read ( line, *, iostat=status ) subBlockLength
        if ( status /= 0 ) then
          call io_error ( "After --subblock option", status, line )
          stop
        end if
      else if ( line(3+n:9+n) == 'submit ' ) then
        copyArg = .false.
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        parallel%submit = trim ( line )
      else if ( lowercase(line(3+n:5+n)) == 'tk ' ) then
        toolkit = switch
      else if ( line(3+n:10+n) == 'version ' ) then
        do j=1, size(current_version_id)
          print *, current_version_id(j)
        end do
        stop
      else if ( line(3+n:7+n) == 'wall ' ) then
        time_config%use_wall_clock = switch
      else if ( line(3:) == ' ' ) then  ! "--" means "no more options"
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        call AccumulateSlaveArguments(line)
        exit
      else
        print *, 'unrecognized option ', trim(line), ' ignored.'
        call option_usage
      end if
    else if ( line(1:1) == '-' ) then   ! "letter" options
      j = 1
      do while ( j < len_trim(line) )
        j = j + 1
        select case ( line(j:j) )
        case ( ' ' )
          exit
        case ( 'A' ); dump_tree = .true.
        case ( 'a', 'c', 'f', 'g', 'l', 'p', 't' )
          if ( line(j+1:j+1) >= '0' .and. line(j+1:j+1) <= '9' ) then
            call set_toggles ( line(j:j+1) )
            j = j + 1
          else
            call set_toggles ( line(j:j) )
          end if
        case ( 'd' ); do_dump = .true.
        case ( 'h', 'H', '?' )     ! Describe command line usage
          call option_usage
        case ( 'K' ); capIdentifiers = .true.
        case ( 'k' ); capIdentifiers = .false.
        case ( 'M' ); outputOptions%prunit = -2
        case ( 'm' ); outputOptions%prunit = -1
        case ( 'R' ) ! This does the opposite of what S does
          removeSwitches = catLists(trim(removeSwitches), line(j+1:))
          exit ! Took the rest of the string, so there can't be more options
        case ( 'S' )
          switches = catLists(trim(switches), line(j+1:))
          exit ! Took the rest of the string, so there can't be more options
        case ( 'T' )
          timing = .true.
          do
            if ( j >= len(line) ) exit
            if ( line(j+1:j+1) >= '0' .and. line(j+1:j+1) <= '9' ) then
              if( line(j+1:j+1) /= '0' ) &
                & switches = catLists(trim(switches), 'time')
              section_times = &
                & switchDetail(switches, 'time') > -1 &
                & .and. &
                & switchDetail(switches, 'time') /= 1
              total_times = section_times .and. switchDetail(switches, 'time') /= 2
            else if ( lowercase(line(j+1:j+1)) == 's' ) then
              sectionTimingUnits = l_seconds
            else if ( lowercase(line(j+1:j+1)) == 'm' ) then
              sectionTimingUnits = l_minutes
            else if ( lowercase(line(j+1:j+1)) == 'h' ) then
              sectionTimingUnits = l_hours
            end if
            j = j + 1
          end do
        case ( 'v' ); do_listing = .true.
        case ( 'w' )
          MLSMessageConfig%limitWarnings = 1
          if ( line(j+1:j+1) == 'p' ) then
            RESTARTWARNINGS = .false.
            j = j + 1
          end if
          if ( j < len_trim(line) ) then
            call readIntsFromChars(line(j+1:), MLSMessageConfig%limitWarnings)
            j = j + len_trim(line(j+1:))
          end if
        case default
          print *, 'Unrecognized option -', line(j:j), ' ignored.'
          call option_usage
        end select
      end do
    else
      call AccumulateSlaveArguments(line)
      exit ! This must be the l2cf filename
    end if
d225 5
a229 3
    if ( copyArg ) call AccumulateSlaveArguments(line)
  end do

d231 3
a233 1
  if( switchDetail(switches, '?') > -1 .or. &
d235 1
a235 1
   call switch_usage
a237 22
  ! Are any switches inappropriate for master or for slave?
    if ( parallel%master ) &
      & removeSwitches = catLists( trim(removeSwitches), 'bool,walk' )
    if ( parallel%slave ) &
      & removeSwitches = catLists( trim(removeSwitches), 'chu,chu1,l2q,mas,slv' )
  ! Remove any quote marks from RemoveSwitches array
  tempSwitches = unquote(removeSwitches, quotes=quotes, options='-p')
  call GetUniqueList(tempSwitches, removeSwitches, numSwitches, countEmpty=.true., &
        & ignoreLeadingSpaces=.true.)
  ! Remove any quote marks from switches array
  tempSwitches = unquote(switches, quotes=quotes, options='-p')
  call GetUniqueList(tempSwitches, Switches, numSwitches, countEmpty=.true., &
        & ignoreLeadingSpaces=.true.)
  ! Remove any switches embedded in the removeSwitches option 'R'
  do i=1, NumStringElements(removeSwitches, countEmpty=.true.)
    call GetStringElement(trim(removeSwitches), aSwitch, i, countEmpty=.true.)
    call RemoveElemFromList(switches, tempSwitches, trim(aSwitch))
    switches = tempSwitches
  end do

  if ( switchDetail(switches, 'walk') > -1 ) &
    & MLSMSG_Severity_to_walkback = MLSMSG_Warning
d257 4
d289 1
d569 1
a569 1
    call output ( trim(command_line), advance='yes' )
d704 1
a704 1
       "$Id: MLSL2.f90,v 2.182 2012/04/26 23:12:45 pwagner Exp $"
d713 3
@


2.182
log
@--crash turns off neverCrash; maybe we should change default for neverCrash to .false.
@
text
@d60 1
d66 1
a66 2
  use TOGGLES, only: CON, EMIT, GEN, LEVELS, LEX, PAR, SYN, SWITCHES, TAB, &
    & TOGGLE
d603 7
a609 2
        case ( 'a' ); toggle(syn) = .true.
        case ( 'c' ); toggle(con) = .true.
a610 18
        case ( 'f' )
          toggle(emit) = .true.
          levels(emit) = 0
          if ( j < len_trim(line) ) then
            if ( line(j+1:j+1) >= '0' .and. line(j+1:j+1) <= '9' ) then
              j = j + 1
              levels(emit) = ichar(line(j:j)) - ichar('0')
            end if
          end if
        case ( 'g' )
          toggle(gen) = .true.
          levels(gen) = 0
          if ( j < len_trim(line) ) then
            if ( line(j+1:j+1) >= '0' .and. line(j+1:j+1) <= '9' ) then
              j = j + 1
              levels(gen) = ichar(line(j:j)) - ichar('0')
            end if
          end if
a614 1
        case ( 'l' ); toggle(lex) = .true.
a616 1
        case ( 'p' ); toggle(par) = .true.
a643 1
        case ( 't' ); toggle(tab) = .true.
d1157 1
a1157 1
       "$Id: MLSL2.f90,v 2.181 2012/04/20 01:30:38 vsnyder Exp $"
d1166 3
@


2.181
log
@Use Begin, Finish instead of Output_Date_and_Time
@
text
@d27 1
a27 1
  use MACHINE, only: GETARG, HP, IO_ERROR
d285 1
d1173 1
a1173 1
       "$Id: MLSL2.f90,v 2.180 2012/03/28 20:06:44 pwagner Exp $"
d1182 3
@


2.180
log
@Removed stgmem option--slave tasks lost ability to join quantities
@
text
@d54 1
a54 1
  use OUTPUT_M, only: BLANKS, DUMP, OUTPUT, OUTPUT_DATE_AND_TIME, &
d64 1
a64 1
  use TIME_M, only: TIME_NOW, TIME_CONFIG
d839 1
a839 1
  call output_date_and_time(msg='starting mlsl2')
d969 1
a969 1
  call output_date_and_time(msg='ending mlsl2')
d1172 1
a1172 1
       "$Id: MLSL2.f90,v 2.179 2012/02/09 02:45:26 vsnyder Exp $"
d1181 3
@


2.179
log
@Remove -C option -- I didn't notice --crash was already there
@
text
@d17 1
a17 1
  use HDF, only: DFACC_RDonly
d550 2
a551 2
      else if ( lowercase(line(3+n:9+n)) ==  'stgmem ' ) then
        parallel%stageInMemory = .true.
d1107 2
a1108 2
      call outputNamedValue ( 'Stage in memory instead of a file?', parallel%stageInMemory, advance='yes', &
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d1172 1
a1172 1
       "$Id: MLSL2.f90,v 2.178 2012/02/09 01:48:11 vsnyder Exp $"
d1181 3
@


2.178
log
@Add -C option to crash on any error, to get traceback for debugging
@
text
@d47 2
a48 2
    & MLSMSG_ERROR, MLSMessageSetup, MLSMSG_SEVERITY_TO_QUIT, &
    & MLSMSG_SEVERITY_TO_WALKBACK, MLSMSG_WARNING, DUMPCONFIG, MLSMESSAGEEXIT
a602 1
        case ( 'C' ); call MLSMessageSetup ( crashOnAnyError=.true. )
d1172 1
a1172 1
       "$Id: MLSL2.f90,v 2.177 2011/06/29 21:43:59 pwagner Exp $"
d1181 3
@


2.177
log
@Some cases may safely omit l1b files
@
text
@d47 2
a48 2
    & MLSMSG_ERROR, MLSMSG_SEVERITY_TO_QUIT, MLSMSG_SEVERITY_TO_WALKBACK, &
    & MLSMSG_WARNING, DUMPCONFIG, MLSMESSAGEEXIT
d603 1
d1173 1
a1173 1
       "$Id: MLSL2.f90,v 2.176 2010/11/05 22:36:16 pwagner Exp $"
d1182 3
@


2.176
log
@Consistent with new unquote api
@
text
@d13 1
a13 1
  use Allocate_Deallocate, only: SET_GARBAGE_COLLECTION, TRACKALLOCATES, &
d15 1
a15 1
  use ChunkDivide_m, only: ChunkDivideConfig
d17 1
a17 1
  use Hdf, only: DFACC_RDONLY
d19 1
a19 1
  use INTRINSIC, only: L_ASCII, L_HOURS, L_MINUTES, L_SECONDS, l_TKGEN, &
d21 2
a22 2
  use IO_Stuff, only: Get_Lun
  use L2GPData, only: avoidUnlimitedDims
d24 1
a24 1
  use LeakCheck_m, only: LeakCheck
d26 1
a26 1
  use LEXER_M, only: CapIdentifiers
d28 2
a29 2
  use MLSCOMMON, only: MLSFile_T
  use MLSFiles, only: FILESTRINGTABLE, &
d32 3
a34 3
    & InitializeMLSFile, mls_openFile, mls_closeFile
  use MLSHDF5, only: mls_h5open, mls_h5close
  use MLSL2Options, only: CATENATESPLITS, CHECKPATHS, CURRENT_VERSION_ID, &
d36 2
a37 2
    & LEVEL1_HDFVERSION, NORMAL_EXIT_STATUS, OUTPUT_PRINT_UNIT, &
    & PATCH, PENALTY_FOR_NO_METADATA, QUIT_ERROR_THRESHOLD, RESTARTWARNINGS, &
d44 1
a44 1
  use MLSL2Timings, only: RUN_START_TIME, SECTION_TIMES, TOTAL_TIMES, &
d46 8
a53 8
  use MLSMessageModule, only: MLSMessage, MLSMessageConfig, MLSMSG_Debug, &
    & MLSMSG_Error, MLSMSG_Severity_to_quit, MLSMSG_Severity_to_walkback, &
    & MLSMSG_Warning, MLSMessageExit
  use MLSPCF2 ! Everything
  use MLSStrings, only: lowerCase, readIntsFromChars, trim_safe
  use MLSStringLists, only: catLists, ExpandStringRange, &
    & GetStringElement, GetUniqueList, &
    & NumStringElements, RemoveElemFromList, SwitchDetail, unquote
d55 1
a55 1
    & outputNamedValue, OUTPUTOPTIONS, STAMPOPTIONS
d57 4
a60 4
  use PCFHdr, only: GlobalAttributes
  use PVM, only: ClearPVMArgs, FreePVMArgs
  use SDPToolkit, only: UseSDPToolkit
  use SnoopMLSL2, only: SNOOPINGACTIVE, SNOOPNAME
d64 1
a64 1
  use Time_M, only: Time_Now, time_config
d67 1
a67 1
  use Track_m, only: ReportLeaks
d164 1
d253 1
d277 2
d353 26
a421 2
      else if ( lowercase(line(3+n:18+n)) == 'clearonallocate ' ) then
        clearonallocate = switch
d445 2
d683 1
a732 4
  if ( .not. toolkit ) then
     penalty_for_no_metadata = 0
  end if

d1097 2
d1139 2
d1172 1
a1172 1
       "$Id: MLSL2.f90,v 2.175 2010/09/17 00:11:19 pwagner Exp $"
d1181 3
@


2.175
log
@Fixed misuse of switchDetail function
@
text
@d664 1
a664 1
  tempSwitches = unquote(removeSwitches, quotes=quotes, stripany=.true.)
d668 1
a668 1
  tempSwitches = unquote(switches, quotes=quotes, stripany=.true.)
d1141 1
a1141 1
       "$Id: MLSL2.f90,v 2.174 2010/08/06 23:08:48 pwagner Exp $"
d1150 3
@


2.174
log
@Pass Hessians, matrices to DumpCommand
@
text
@d799 1
a799 1
  if( switchDetail(switches, 'opt') >= 0 .or. showDefaults ) then
d1014 1
a1014 1
    if( SwitchDetail(switches, 'opt1') > 0 .or. showDefaults ) then
d1141 1
a1141 1
       "$Id: MLSL2.f90,v 2.173 2010/05/23 03:25:37 honghanh Exp $"
d1150 3
@


2.173
log
@Use AddInUnit instead of inunit to adapt with change in the string_table
@
text
@d744 1
d1141 1
a1141 1
       "$Id: MLSL2.f90,v 2.172 2010/02/02 01:41:03 vsnyder Exp $"
d1150 3
@


2.172
log
@Move declaration of Id to a place where it is more difficult for a
compiler to notice it's not actually referenced.
@
text
@d62 1
a62 1
    & DESTROY_STRING_TABLE, DO_LISTING, GET_STRING, INUNIT
d83 1
a83 1
  ! (i)   a file named by a line in the pcf 
d93 1
a93 1
  ! In case the l2cf is named, say, "file_name" by (ii), we will try: 
d103 1
a103 1
  ! (b) command-line options (see /mlspgs/notes/options and 
d105 2
a106 2
  ! (c) the l2cf 
  ! (d) the pcf (unless the variable 'pcf' is FALSE) 
d127 1
a127 1
  !       with a generic, non-mlsl2-aware batch queue system; 
d184 1
a274 1
        ! call outputNamedValue('chunkRange', trim(parallel%chunkRange) )
a519 4
        ! call outputnamedValue('l2cf unit', inunit )
        ! call outputnamedValue('pr unit', OutputOptions%prUnit )
        ! call outputnamedValue('exist', exist )
        ! call outputnamedValue('opened', opened )
d645 1
a645 1
    else    
d657 1
a657 1
  
d705 1
a705 1
  
d718 1
a718 1
  ! in directwrites of l2gp files currently fails 
d767 2
a768 2
    else if(switchDetail(switches, 'pro') >= 0) then                            
      call announce_success(MLSL2CF%name, l2cf_unit)               
d783 2
a784 2
    else if(switchDetail(switches, 'pro') >= 0) then                            
      call announce_success(MLSL2CF%name, inunit)               
d793 1
d795 1
a795 1
  
d921 1
a921 1
      ! call MLSMessageExit 
d935 1
a935 1
      end if    
d946 3
a948 3
  else                  
     call MLSMessageExit 
  end if                 
d969 1
a969 1
  
d1010 2
a1011 2
    call output ( ' l2cf file:', advance='no' )  
    call blanks ( 4, advance='no' )                                     
d1013 1
a1013 1
    if( SwitchDetail(switches, 'opt1') > 0 .or. showDefaults ) then                                 
d1066 1
a1066 1
      end if                      
d1118 1
a1118 1
    
d1140 1
a1140 1
       "$Id: MLSL2.f90,v 2.171 2009/10/21 16:59:10 pwagner Exp $"
d1149 4
@


2.171
log
@No longer insist on unlimited dims when given chunkrange
@
text
@a187 3
  character (len=*), parameter :: IdParm = &
       "$Id: MLSL2.f90,v 2.170 2008/01/08 00:22:02 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
d199 1
a199 1
  call mls_h5open(error)
d202 2
a203 1
        & "Unable to mls_open" )
d1139 10
d1152 3
@


2.170
log
@Levels 1 and 2 can use same shared PCF now if --shared option set
@
text
@d189 1
a189 1
       "$Id: MLSL2.f90,v 2.169 2007/09/13 21:52:22 pwagner Exp $"
d727 1
a727 1
    avoidUnlimitedDims = .false.
d1144 3
@


2.169
log
@Reduced sips limitwarnings to 4
@
text
@d38 1
a38 1
    & SECTIONTIMINGUNITS, SIPS_VERSION, &
d49 1
a49 1
  use MLSPCF2, only: MLSPCF_L2CF_START
d189 1
a189 1
       "$Id: MLSL2.f90,v 2.168 2007/09/06 23:35:16 pwagner Exp $"
d442 2
d732 3
d1034 2
d1117 9
d1144 3
@


2.168
log
@slaves need not do own cleanup
@
text
@d189 1
a189 1
       "$Id: MLSL2.f90,v 2.167 2007/08/23 22:18:35 pwagner Exp $"
d216 1
a216 1
    MLSMessageConfig%limitWarnings = 50 ! Why print all that stuff?
d1128 3
@


2.167
log
@'walk' switch prints walkback fo calling stack even for warnings
@
text
@d39 1
a39 1
    & SKIPDIRECTWRITES, SKIPDIRECTWRITESORIGINAL, &
d189 1
a189 1
       "$Id: MLSL2.f90,v 2.166 2007/08/17 00:36:29 pwagner Exp $"
d903 35
a937 33
  call destroy_char_table
  call output('Destroyed char table', advance='yes')
  call destroy_hash_table
  call output('Destroyed hash table', advance='yes')
  call destroy_string_table
  call output('Destroyed string table', advance='yes')
  call destroy_symbol_table
  call output('Destroyed symbol table', advance='yes')
  call deallocate_decl
  call output('Deallocated decl', advance='yes')
  call deallocate_tree
  call output('Deallocated tree', advance='yes')
  call FreePVMArgs
  call output('Freed PVM args', advance='yes')
  if ( parallel%slave .and. &
    & (SKIPDIRECTWRITES .or. SKIPRETRIEVAL .or. sectionsToSkip /= ' ' ) ) then
    ! call mls_h5close(error)
    ! call MLSMessageExit 
  else if ( error == 0 ) then
    call Deallocate_filedatabase(filedatabase)
    call output('Deallocated filedatabase', advance='yes')
    if ( .not. parallel%slave) then
      call mls_h5close(error)
      call output('Closed hdf5 library', advance='yes')
    else
      call MLSMessage ( MLSMSG_Warning, moduleName, &
        & "We are a slave, thus unable to mls_close in this version" )
    endif
    if (error /= 0) then
       call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to mls_close" )
    end if    
  end if    
d1128 3
@


2.166
log
@Removed now-redundant [n]everCrash option
@
text
@d47 2
a48 1
    & MLSMSG_Error, MLSMSG_Severity_to_quit, MLSMSG_Warning, MLSMessageExit
d189 1
a189 1
       "$Id: MLSL2.f90,v 2.165 2007/07/27 00:18:20 vsnyder Exp $"
d664 1
a664 1
      & removeSwitches = catLists( trim(removeSwitches), 'bool' )
d681 3
a683 5
  if ( parallel%slave ) then
  ! Don't dump all the chunks again and again for each slave's chunk
    call RemoveElemFromList(switches, tempSwitches, 'chu')
    switches = tempSwitches
  end if
d1126 3
@


2.165
log
@Print the command that invoked MLSL2
@
text
@d27 1
a27 1
  use MACHINE, only: GETARG, HP, IO_ERROR, NEVERCRASH
d188 1
a188 1
       "$Id: MLSL2.f90,v 2.164 2007/06/07 20:38:45 pwagner Exp $"
a218 1
    NeverCrash = .false.
a304 2
      else if ( lowercase(line(3+n:8+n)) == 'evercr' ) then
        neverCrash = .not. switch ! Because "neverCrash" makes NEVERCRASH TRUE
d660 6
a1092 2
      call outputNamedValue ( 'Ever crash?', .not. neverCrash, advance='yes', &
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d1127 3
@


2.164
log
@Should prevent unit collisions (not as good as get_lun)
@
text
@d188 1
a188 1
       "$Id: MLSL2.f90,v 2.163 2007/02/14 20:48:59 pwagner Exp $"
d997 1
d999 10
a1008 5
    call output(' mlsl2 called with command line options: ', advance='no')
    call output(trim(command_line), advance='yes')
    call output(' l2cf file:', advance='no')  
    call blanks(4, advance='no')                                     
    call output(trim(MLSL2CF%name), advance='yes')                            
d1126 3
@


2.163
log
@Slaves bypass mls_h5close to avoid another bomb
@
text
@d143 1
d157 1
d168 1
d188 1
a188 1
       "$Id: MLSL2.f90,v 2.162 2007/02/14 17:31:45 pwagner Exp $"
d516 3
d520 6
d1120 3
@


2.162
log
@Moved timing summary before statements possibly killing slaves
@
text
@d185 1
a185 1
       "$Id: MLSL2.f90,v 2.161 2007/02/07 20:58:03 pwagner Exp $"
d910 7
a916 2
    call mls_h5close(error)
    call output('Closed hdf5 library', advance='yes')
d1108 3
@


2.161
log
@Permit slaves to write unbuffered stdout when master does
@
text
@d185 1
a185 1
       "$Id: MLSL2.f90,v 2.160 2007/01/12 00:35:08 pwagner Exp $"
d881 7
d890 1
d892 1
d894 1
d896 1
d898 1
d900 1
d902 1
d909 1
d911 1
a918 1
  if ( switchDetail(switches, 'time') >= 0 ) call dump_section_timings
d1103 3
@


2.160
log
@Renamed routine outputNamedValue; may set host name and unbuffered stdout
@
text
@d185 1
a185 1
       "$Id: MLSL2.f90,v 2.159 2006/10/09 18:38:41 pwagner Exp $"
d505 3
a507 1
        copyArg = .false. ! else all the the slaves would try to write to the same file
d1088 3
@


2.159
log
@Trims parallel%chunkRange before outputting
@
text
@d21 1
d31 1
a31 1
    & ADDFILETODATABASE, Deallocate_filedatabase, dump, &
d53 2
a54 2
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUT_DATE_AND_TIME, &
    & OUTPUT_Name_V_Pair, OutputOptions
d56 1
d141 1
a141 1
  implicit NONE
d185 1
a185 1
       "$Id: MLSL2.f90,v 2.158 2006/10/05 23:32:14 pwagner Exp $"
d273 1
a273 1
        call output_name_v_pair('chunkRange', trim(parallel%chunkRange) )
d307 6
d504 8
d674 1
a674 1
  if ( .not. toolkit .or. showDefaults ) then
d973 1
a973 1
      call output_name_v_pair ( 'Use toolkit panoply', toolkit, advance='yes', &
d975 1
a975 1
      call output_name_v_pair ( 'Error threshold before halting', quit_error_threshold, advance='yes', &
d977 1
a977 1
      call output_name_v_pair ( 'Status on normal exit', normal_exit_status, advance='yes', &
d979 1
a979 1
      call output_name_v_pair ( 'Default hdf version for l1b files', level1_hdfversion, advance='yes', &
d981 1
a981 1
      call output_name_v_pair ( 'Default hdfeos version on reads', default_hdfversion_read, advance='yes', &
d983 1
a983 1
      call output_name_v_pair ( 'Default hdfeos version on writes', default_hdfversion_write, advance='yes', &
d985 1
a985 1
      call output_name_v_pair ( 'Range of chunks', trim_safe(parallel%chunkRange), advance='yes', &
d987 1
a987 1
      call output_name_v_pair ( 'Avoiding unlimited dimensions in directwrites?', &
d990 1
a990 1
      call output_name_v_pair ( 'Allow overlaps outside proc. range?', &
d993 1
a993 1
      call output_name_v_pair ( 'Catenate split dgg/dgm after run completes?', catenateSplits, advance='yes', &
d995 1
a995 1
      call output_name_v_pair ( 'Is this run in forward model parallel?', parallel%fwmParallel, advance='yes', &
d997 1
a997 1
      call output_name_v_pair ( 'Avoid creating file on first directWrite?', patch, advance='yes', &
d999 1
a999 1
      call output_name_v_pair ( 'Is this the master task in pvm?', parallel%master, advance='yes', &
d1002 1
a1002 1
      call output_name_v_pair ( 'Master task number', parallel%myTid, advance='yes', &
d1004 1
a1004 1
      call output_name_v_pair ( 'Command line sent to slaves', trim(parallel%pgeName), advance='yes', &
d1006 1
a1006 1
      call output_name_v_pair ( 'Command to queue slave tasks', trim(parallel%submit), advance='yes', &
d1008 1
a1008 1
      call output_name_v_pair ( 'Maximum failures per chunk', parallel%maxFailuresPerChunk, advance='yes', &
d1010 1
a1010 1
      call output_name_v_pair ( 'Maximum failures per machine', parallel%maxFailuresPerMachine, advance='yes', &
d1012 1
a1012 1
      call output_name_v_pair ( 'Sleep time in masterLoop (mus)', parallel%delay, advance='yes', &
d1015 1
a1015 1
      call output_name_v_pair ( 'Is this a slave task in pvm?', parallel%slave, advance='yes', &
d1018 1
a1018 1
      call output_name_v_pair ( 'Master task number', parallel%masterTid, advance='yes', &
d1021 1
a1021 1
      call output_name_v_pair ( 'Preflight check paths?', checkPaths, advance='yes', &
d1023 1
a1023 1
      call output_name_v_pair ( 'Skip all direct writes?', SKIPDIRECTWRITES, advance='yes', &
d1025 1
a1025 1
      call output_name_v_pair ( 'Skip all retrievals?', SKIPRETRIEVAL, advance='yes', &
d1027 1
a1027 1
      call output_name_v_pair ( 'Skip these sections?', trim_safe(sectionsToSkip), advance='yes', &
d1029 1
a1029 1
      call output_name_v_pair ( 'Unretrieved states fill', STATEFILLEDBYSKIPPEDRETRIEVALS, advance='yes', &
d1031 1
a1031 1
      call output_name_v_pair ( 'Stage in memory instead of a file?', parallel%stageInMemory, advance='yes', &
d1033 1
a1033 1
      call output_name_v_pair ( 'Using wall clock instead of cpu time?', time_config%use_wall_clock, advance='yes', &
d1036 1
a1036 1
      call output_name_v_pair ( 'Summarize time in what units', trim(string), advance='yes', &
d1038 1
a1038 1
      call output_name_v_pair ( 'Number of switches set', numSwitches, advance='yes', &
d1041 1
a1041 1
        call output_name_v_pair ( '(All switches)', trim(switches), advance='yes', &
d1044 1
a1044 1
      call output_name_v_pair ( 'Standard output unit', outputOptions%prunit, advance='yes', &
d1046 1
a1046 1
      call output_name_v_pair ( 'Log file unit', MLSMessageConfig%LogFileUnit, advance='yes', &
d1048 1
a1048 1
      call output_name_v_pair ( 'Crash on any error?', MLSMessageConfig%crashOnAnyError, advance='yes', &
d1050 1
a1050 1
      call output_name_v_pair ( 'Ever crash?', .not. neverCrash, advance='yes', &
d1052 1
a1052 1
      call output_name_v_pair ( 'Suppress identical warnings after', MLSMessageConfig%limitWarnings, advance='yes', &
d1054 1
a1054 1
      call output_name_v_pair ( 'Restart counting warnings at each phase?', restartWarnings, advance='yes', &
d1056 1
a1056 1
      call output_name_v_pair ( 'Set error before stopping?', StopWithError, advance='yes', &
d1059 1
a1059 1
      call output_name_v_pair ( 'Save special dumps to', trim(specialDumpFile), advance='yes', &
d1063 2
d1086 3
d1114 1
a1114 1
! Uses new output_name_v_pair
@


2.158
log
@skipSections can skip named sections
@
text
@d183 1
a183 1
       "$Id: MLSL2.f90,v 2.157 2006/09/21 18:46:49 pwagner Exp $"
d969 1
a969 1
      call output_name_v_pair ( 'Range of chunks', parallel%chunkRange, advance='yes', &
d1068 3
@


2.157
log
@Reduce level of dumps in SIDS version
@
text
@d48 1
a48 1
  use MLSStrings, only: lowerCase, readIntsFromChars
d168 1
d183 1
a183 1
       "$Id: MLSL2.f90,v 2.156 2006/08/14 16:21:22 pwagner Exp $"
d437 6
d853 1
a853 1
        & filedatabase )
d872 1
a872 1
    & (SKIPDIRECTWRITES .or. SKIPRETRIEVAL) ) then
d1011 2
d1068 3
@


2.156
log
@pass chunk range correctly to slave tasks
@
text
@d182 1
a182 1
       "$Id: MLSL2.f90,v 2.155 2006/08/10 21:46:49 pwagner Exp $"
d207 1
a207 1
    switches=''
d1059 3
@


2.155
log
@--chunk commandline option now synonym for --chunkRange
@
text
@d182 1
a182 1
       "$Id: MLSL2.f90,v 2.154 2006/08/05 02:13:33 vsnyder Exp $"
d265 1
d267 2
a268 1
        call getarg ( i, parallel%chunkRange )
d1059 3
@


2.154
log
@Add 'where' argument for ReportLeaks
@
text
@d49 2
a50 1
  use MLSStringLists, only: catLists, GetStringElement, GetUniqueList, &
d157 1
d159 1
a159 1
  integer :: LastCHUNK = 0         ! Just run range [SINGLECHUNK-LastCHUNK]
a168 1
  integer :: SINGLECHUNK = 0       ! Just run one chunk; unless lastChunk nonzero
d182 1
a182 1
       "$Id: MLSL2.f90,v 2.153 2006/07/29 03:42:09 vsnyder Exp $"
d189 1
d264 1
a264 2
      else if ( line(3+n:8+n) == 'chunk ' ) then
        call AccumulateSlaveArguments ( line )
d266 3
a268 15
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
        if ( singleChunk == 0 ) then
          read ( line, *, iostat=status ) singleChunk
          if ( status /= 0 ) then
            call io_error ( "After --chunk option", status, line )
            stop
          end if
        else
          read ( line, *, iostat=status ) lastChunk
          if ( status /= 0 ) then
            call io_error ( "After --chunk option", status, line )
            stop
          end if
        end if
a429 4
      else if ( lowercase(line(3+n:8)) == 'chunkr' ) then
        i = i + 1
        call getarg ( i, parallel%chunkRange )
        command_line = trim(command_line) // ' ' // trim(parallel%chunkRange)
d674 1
a674 2
    singleChunk = 1
    lastChunk = 0
d683 6
a688 2
  if ( max(singleChunk, lastChunk) /= 0 .or. parallel%chunkRange /= ' ' ) &
    & avoidUnlimitedDims = .false.
d694 1
a694 1
  if ( parallel%fwmParallel .and. parallel%master .and. singleChunk == 0 ) &
d704 1
a704 1
    call InitParallel ( singleChunk, slaveMAF )
d844 1
a844 1
        & singleChunk, lastChunk, filedatabase )
d960 1
a960 5
      if ( singleChunk /= 0 .and. lastChunk == 0 ) then
      call output_name_v_pair ( 'Compute only the single chunk', singleChunk, advance='yes', &
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
      else if ( singleChunk /= 0 .and. lastChunk /= 0 ) then
      call output_name_v_pair ( 'Compute chunks in range', (/singleChunk, lastChunk/), advance='yes', &
a961 1
      end if                      
a988 5
      call output_name_v_pair ( 'Range of chunks run in parallel', parallel%chunkRange, advance='yes', &
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
      else
      call output_name_v_pair ( 'Range of chunks run serially', (/singleChunk, lastChunk/), advance='yes', &
        & fillChar=fillChar, before='* ', after=' *', tabn=4, tabc=62, taba=70 )
d1057 3
@


2.153
log
@New --memtrack interpretation
@
text
@d181 1
a181 1
       "$Id: MLSL2.f90,v 2.152 2006/07/27 03:49:12 vsnyder Exp $"
d889 1
a889 1
  if ( trackAllocates > 0 ) call ReportLeaks
d1079 3
@


2.152
log
@Detect --leak option, attach leak checker
@
text
@d63 1
d174 1
d181 1
a181 1
       "$Id: MLSL2.f90,v 2.151 2006/07/21 20:10:37 pwagner Exp $"
d395 23
a417 2
      else if ( lowercase(line(3+n:11+n)) == 'memtrack ' ) then
        trackAllocates = switch
d889 1
d1079 3
@


2.151
log
@Can fill state even if skipping retrievals; select what section to stop after
@
text
@d23 1
d148 1
d179 1
a179 1
       "$Id: MLSL2.f90,v 2.150 2006/06/28 00:00:18 pwagner Exp $"
d195 1
a195 1
  endif
d210 1
a210 1
  endif
d348 2
d578 1
a578 1
            elseif ( lowercase(line(j+1:j+1)) == 's' ) then
d580 1
a580 1
            elseif ( lowercase(line(j+1:j+1)) == 'm' ) then
d582 1
a582 1
            elseif ( lowercase(line(j+1:j+1)) == 'h' ) then
d586 1
a586 1
          enddo
d594 1
a594 1
          endif
d629 1
a629 1
  enddo
d634 1
a634 1
  endif
d643 1
a643 1
  elseif (parallel%master) then
d645 1
a645 1
  elseif (parallel%slave) then
d672 1
a672 1
  endif
d697 1
a697 1
  endif
d716 1
a716 1
    elseif(switchDetail(switches, 'pro') >= 0) then                            
d732 1
a732 1
    elseif(switchDetail(switches, 'pro') >= 0) then                            
d741 1
a741 1
  endif
d755 1
a755 1
    endif
d766 1
a766 1
  endif
d814 7
d855 1
a855 1
  elseif ( error == 0 ) then
d861 2
a862 2
    endif    
  endif    
d869 1
a869 1
  elseif(NORMAL_EXIT_STATUS /= 0 .and. .not. parallel%slave) then
d873 1
a873 1
  endif                 
d883 1
a883 1
    endif
d951 1
a951 1
      elseif ( singleChunk /= 0 .and. lastChunk /= 0 ) then
d954 1
a954 1
      endif                      
d987 1
a987 1
      endif
d993 1
a993 1
      endif                      
d1014 1
a1014 1
      endif
d1032 1
a1032 1
      endif
d1034 1
a1034 1
    endif
d1055 3
@


2.150
log
@Uses new output_name_v_pair
@
text
@d39 2
a40 1
    & SPECIALDUMPFILE, STOPAFTERCHUNKDIVIDE, STOPAFTERGLOBAL, STOPWITHERROR, &
d177 1
a177 1
       "$Id: MLSL2.f90,v 2.149 2006/06/24 23:11:29 pwagner Exp $"
d461 14
d477 5
a481 4
      else if ( lowercase(line(3+n:12+n)) ==  'stopafterc' ) then
        stopAfterChunkDivide = switch
      else if ( lowercase(line(3+n:12+n)) ==  'stopafterg' ) then
        stopAfterGlobal = switch
d814 2
a815 4
      skipDirectwrites = (skipDirectwrites .or. stopAfterChunkDivide .or. &
        & stopAfterGlobal)
      skipRetrieval = (skipRetrieval .or. stopAfterChunkDivide .or. &
        & stopAfterGlobal)
d989 2
d1044 3
@


2.149
log
@prunit now a component of outputOptions
@
text
@d26 1
a26 1
  use MLSCOMMON, only: FILENAMELEN, MLSFile_T
d49 2
a50 2
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, &
    & OutputOptions
d56 1
a56 1
    & DESTROY_STRING_TABLE, DISPLAY_STRING, DO_LISTING, INUNIT
a152 1
  ! character(len=FILENAMELEN) :: L2CF_file       ! Some text
d176 1
a176 1
       "$Id: MLSL2.f90,v 2.148 2006/04/20 23:22:39 pwagner Exp $"
d900 2
d908 1
d911 12
a922 18
      call output(' Use toolkit panoply:                            ', advance='no')
      call blanks(4, advance='no')
      call output(toolkit, advance='yes')
      call output(' Error threshold before halting:                 ', advance='no')
      call blanks(5, advance='no')
      call output(quit_error_threshold, advance='yes')
      call output(' Status on normal exit:                          ', advance='no')
      call blanks(5, advance='no')
      call output(normal_exit_status, advance='yes')
      call output(' Default hdf version for l1b files:              ', advance='no')
      call blanks(5, advance='no')
      call output(level1_hdfversion, advance='yes')
      call output(' Default hdfeos version on reads:                ', advance='no')
      call blanks(5, advance='no')
      call output(default_hdfversion_read, advance='yes')
      call output(' Default hdfeos version on writes:               ', advance='no')
      call blanks(5, advance='no')
      call output(default_hdfversion_write, advance='yes')
d924 2
a925 3
      call output(' Compute only the single chunk:                  ', advance='no') 
      call blanks(5, advance='no')                                                   
      call output(singleChunk, advance='yes')
d927 2
a928 5
      call output(' Compute chunks in range:                        ', advance='no') 
      call blanks(5, advance='no')                                                   
      call output(singleChunk, advance='no')
      call blanks(1, advance='no')                                                   
      call output(lastChunk, advance='yes')
d930 14
a943 20
      call output(' Avoiding unlimited dimensions in directwrites?: ', advance='no')
      call blanks(4, advance='no')
      call output(avoidUnlimitedDims, advance='yes')
      call output(' Allow overlaps outside proc. range?:            ', advance='no')
      call blanks(4, advance='no')
      call output(ChunkDivideConfig%allowPriorOverlaps, advance='no')
      call blanks(4, advance='no')
      call output(ChunkDivideConfig%allowPostOverlaps, advance='yes')
      call output(' Catenate split dgg/dgm after run completes?:    ', advance='no')
      call blanks(4, advance='no')
      call output(catenateSplits, advance='yes')
      call output(' Is this run in forward model parallel?:         ', advance='no')
      call blanks(4, advance='no')
      call output(parallel%fwmParallel, advance='yes')
      call output(' Avoid creating file on first directWrite?:      ', advance='no')
      call blanks(4, advance='no')
      call output(patch, advance='yes')
      call output(' Is this the master task in pvm?:                ', advance='no')
      call blanks(4, advance='no')
      call output(parallel%master, advance='yes')
d945 14
a958 19
      call output(' Master task number:                             ', advance='no') 
      call blanks(4, advance='no')                                                   
      call output(parallel%myTid, advance='yes')
      call output(' Command line sent to slaves:                    ', advance='no') 
      call blanks(4, advance='no')                                                   
      call output(trim(parallel%pgeName), insteadofblank='(none)', advance='yes')
      call output(' Command to queue slave tasks:                   ', advance='no') 
      call blanks(4, advance='no')                                                   
      call output(trim(parallel%submit), insteadofblank='(none)', advance='yes')
      call output(' Maximum failures per chunk:                     ', advance='no') 
      call blanks(5, advance='no')                                                   
      call output(parallel%maxFailuresPerChunk, advance='yes')
      call output(' Maximum failures per machine:                   ', advance='no') 
      call blanks(5, advance='no')                                                   
      call output(parallel%maxFailuresPerMachine, advance='yes')
      call output(' Sleep time in masterLoop (mus):                 ', advance='no') 
      call blanks(5, advance='no')                                                   
      call output(parallel%delay, advance='yes')
      call output(' Range of chunks run in parallel:                ', advance='no') 
d960 2
a961 1
      call output(' Range of chunks run serially:                   ', advance='no') 
d963 2
a964 14
      call blanks(4, advance='no')
      if ( max(singleChunk, lastChunk) /= 0 ) then
        call output(singleChunk, advance='no')
        if ( lastChunk /= 0 ) then
          call output(lastChunk, advance='yes')
        else
          call newLine
        endif
      else
        call output(trim(parallel%chunkRange), insteadofblank='(all)', advance='yes')
      endif
      call output(' Is this a slave task in pvm?:                   ', advance='no')
      call blanks(4, advance='no')
      call output(parallel%slave, advance='yes')
d966 2
a967 3
      call output(' Master task number:                             ', advance='no') 
      call blanks(4, advance='no')                                                   
      call output(parallel%masterTid, advance='yes')
d969 15
a983 22
      call output(' Preflight check paths?:                         ', advance='no')
      call blanks(4, advance='no')
      call output(checkPaths, advance='yes')
      call output(' Skip all direct writes?:                        ', advance='no')
      call blanks(4, advance='no')
      call output(SKIPDIRECTWRITES, advance='yes')
      call output(' Skip all retrievals?:                           ', advance='no')
      call blanks(4, advance='no')
      call output(SKIPRETRIEVAL, advance='yes')
      call output(' Stage in memory instead of a file?:             ', advance='no')
      call blanks(4, advance='no')
      call output(parallel%stageInMemory, advance='yes')
      call output(' Using wall clock instead of cpu time?:          ', advance='no')
      call blanks(4, advance='no')
      call output(time_config%use_wall_clock, advance='yes')
      call output(' Summarize time in what units?:                   ', advance='no')
      call blanks(4, advance='no')
      call display_string ( lit_indices(sectionTimingUnits), &
        &             strip=.true., advance='yes' )
      call output(' Number of switches set:                         ', advance='no')
      call blanks(5, advance='no')
      call output(numSwitches, advance='yes')
d985 2
a986 3
        call output(' (All switches)', advance='no')
        call blanks(4, advance='no')
        call output(trim(switches), insteadofblank='(none)', advance='yes')
d988 14
a1001 27
      call output(' Standard output unit:                           ', advance='no')
      call blanks(4, advance='no')
      call output(outputOptions%prunit, advance='yes')
      call output(' Log file unit:                                  ', advance='no')
      call blanks(4, advance='no')
      call output(MLSMessageConfig%LogFileUnit, advance='yes')
      call output(' Crash on any error:                             ', advance='no')
      call blanks(4, advance='no')
      call output(MLSMessageConfig%crashOnAnyError, advance='yes')
      call output(' Ever crash:                                     ', advance='no')
      call blanks(4, advance='no')
      call output(.not. neverCrash, advance='yes')
      call output(' Suppress identical warnings after:               ', advance='no')
      call blanks(4, advance='no')
      call output(MLSMessageConfig%limitWarnings, advance='yes')
      call output(' Restart counting warnings at each phase:        ', advance='no')
      call blanks(4, advance='no')
      call output(restartWarnings, advance='yes')
      call output(' Stop after Chunk Divide:                        ', advance='no')
      call blanks(4, advance='no')
      call output(StopAfterChunkDivide, advance='yes')
      call output(' Stop after global settings:                     ', advance='no')
      call blanks(4, advance='no')
      call output(StopAfterGlobal, advance='yes')
      call output(' Set error before stopping:                      ', advance='no')
      call blanks(4, advance='no')
      call output(StopWithError, advance='yes')
d1003 2
a1004 3
      call output(' Save special dumps to:                          ', advance='no')
      call blanks(4, advance='no')
      call output(trim(specialDumpFile), advance='yes')
d1006 1
a1006 2
      call output(' ----------------------------------------------------------', &
        & advance='yes')
d1028 3
@


2.148
log
@Show both kinds of allowed extra-range overlaps
@
text
@d49 2
a50 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, OUTPUT_DATE_AND_TIME, PRUNIT
d177 1
a177 1
       "$Id: MLSL2.f90,v 2.147 2006/04/11 23:28:49 pwagner Exp $"
d219 1
a219 1
   prunit = OUTPUT_PRINT_UNIT
d538 2
a539 2
        case ( 'M' ); prunit = -2
        case ( 'm' ); prunit = -1
d623 1
a623 1
     prunit = max(-1, prunit)   ! stdout or Fortran unit
d625 1
a625 1
     prunit = -2          ! output both logged and sent to stdout
d627 1
a627 1
     prunit = -1          ! output sent only to stdout, not logged
d1029 1
a1029 1
      call output(PrUnit, advance='yes')
d1082 3
@


2.147
log
@Whether to allow overlaps outside of processing range
@
text
@d176 1
a176 1
       "$Id: MLSL2.f90,v 2.146 2006/03/04 00:17:20 pwagner Exp $"
d942 3
a944 1
      call output(ChunkDivideConfig%allowPriorOverlaps, advance='yes')
d1081 3
@


2.146
log
@May skip retrieval, directWrites depending on runtime Booleans
@
text
@d15 1
d176 1
a176 1
       "$Id: MLSL2.f90,v 2.145 2006/02/21 19:15:17 pwagner Exp $"
d390 3
d656 2
a657 1
  if ( max(singleChunk, lastChunk) /= 0 ) avoidUnlimitedDims = .false.
d940 3
d975 3
a988 1
      endif                      
d1079 3
@


2.145
log
@Uses switchDetail only now
@
text
@d35 2
a36 1
    & SECTIONTIMINGUNITS, SIPS_VERSION, SKIPDIRECTWRITES, &
d175 1
a175 1
       "$Id: MLSL2.f90,v 2.144 2006/02/10 21:14:32 pwagner Exp $"
d793 6
a798 5
      SKIPDIRECTWRITES = (SKIPDIRECTWRITES .or. STOPAFTERCHUNKDIVIDE .or. &
        & STOPAFTERGLOBAL)
      SKIPRETRIEVAL = (SKIPRETRIEVAL .or. STOPAFTERCHUNKDIVIDE .or. &
        & STOPAFTERGLOBAL)
      SKIPRETRIEVALORIGINAL = SKIPRETRIEVAL
d1069 3
@


2.144
log
@May specify skipRetrivel for particular Phases; dumps may go to special dumpfile
@
text
@d174 1
a174 1
       "$Id: MLSL2.f90,v 2.143 2005/11/17 20:11:46 pwagner Exp $"
d587 2
a588 1
  if( index(switches, '?') /= 0 .or. index(switches, 'hel') /= 0 ) then
a897 1
    ! if( index(switches, 'opt1') /= 0 .or. showDefaults ) then                                 
d1067 3
@


2.143
log
@Was printing wrong thing for parallel sleeptime
@
text
@d35 4
a38 2
    & SECTIONTIMINGUNITS, SIPS_VERSION, SKIPDIRECTWRITES, SKIPRETRIEVAL, &
    & STOPAFTERCHUNKDIVIDE, STOPAFTERGLOBAL, STOPWITHERROR, TOOLKIT
d174 1
a174 1
       "$Id: MLSL2.f90,v 2.142 2005/09/22 23:38:54 pwagner Exp $"
d296 6
d795 1
d1039 5
d1067 3
@


2.142
log
@time_config and retry_config now hold config settings
@
text
@d172 1
a172 1
       "$Id: MLSL2.f90,v 2.141 2005/08/19 23:29:04 pwagner Exp $"
a665 2
  ! status = InitializeMLSFile(MLSL2CF, content = 'l2cf', name='<STDIN>', &
  !    & type=l_ascii, access='nonhdf', recordLength=recl, &
a670 1
    ! L2CF_file = line
a671 3
    ! open ( l2cf_unit, file=line, status='old', &
    ! & form='formatted', access='sequential', recl=recl, iostat=status )
    ! print *, '1st attempt to open ' // trim(MLSL2CF%name)
a672 1
    ! print *, 'status ', status
a673 1
      ! L2CF_file = trim(line) // L2CFNAMEEXTENSION
a674 1
      ! print *, '1st attempt to open ' // trim(MLSL2CF%name)
a675 3
      ! print *, 'status ', status
       !open ( l2cf_unit, file=trim(line) // L2CFNAMEEXTENSION, status='old', &
       ! & form='formatted', access='sequential', recl=recl, iostat=status )
a685 1
    ! call open_MLSCF ( MLSPCF_L2CF_Start, inunit, L2CF_file, status, recl )
a687 1
    ! print *, 'About to try to open l2cf file'
a735 1
    ! call close_MLSCF ( inunit, error )
d954 1
a954 1
      call output(parallel%maxFailuresPerMachine, advance='yes')
d1053 3
@


2.141
log
@Wider use of SwitchDetail function
@
text
@d53 1
a53 1
  use Time_M, only: Time_Now, Use_Wall_Clock
d172 1
a172 1
       "$Id: MLSL2.f90,v 2.140 2005/07/21 23:39:49 pwagner Exp $"
d204 1
a204 1
  use_wall_clock = SIPS_VERSION
d479 1
a479 1
        use_wall_clock = switch
d627 1
a627 1
  if ( use_wall_clock ) call time_now(run_start_time)
d1005 1
a1005 1
      call output(use_wall_clock, advance='yes')
d1068 3
@


2.140
log
@use_wall_clock tied to SIPS_VERSION
@
text
@d44 1
a44 1
    & NumStringElements, RemoveElemFromList, unquote
d172 1
a172 1
       "$Id: MLSL2.f90,v 2.139 2005/06/29 17:57:40 pwagner Exp $"
d541 4
a544 2
                & ( index(switches, 'time') /= 0 .and. (line(j+1:j+1) /= '1') )
              total_times = section_times .and. (line(j+1:j+1) /= '2')
d615 1
a615 1
  if( index(switches, 'log') /= 0 .or. .not. toolkit ) then
d693 1
a693 1
    elseif(index(switches, 'pro') /= 0) then                            
d711 1
a711 1
    elseif(index(switches, 'pro') /= 0) then                            
d725 1
a725 1
  if( index(switches, 'opt') /= 0 .or. showDefaults ) then
d838 1
a838 1
  if ( index(switches, 'time') /= 0 ) call dump_section_timings
d903 2
a904 1
    if( index(switches, 'opt1') /= 0 .or. showDefaults ) then                                 
d1068 3
@


2.139
log
@FILESTRINGTABLE set to TRUE
@
text
@d172 1
a172 1
       "$Id: MLSL2.f90,v 2.138 2005/06/22 18:57:02 pwagner Exp $"
d204 1
d1065 3
@


2.138
log
@Reworded Copyright statement, moved rcs id
@
text
@d26 2
a27 1
  use MLSFiles, only: WILDCARDHDFVERSION, HDFVERSION_4, HDFVERSION_5, &
d170 1
a170 1
       "$RCSfile: $"
d172 1
a172 1
       "$Id: $"
d210 1
a210 1

d1064 3
@


2.137
log
@Many changes to accommodate the new fields in MLSFile_T
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d167 7
a173 6
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: IdParm = & 
     "$Id: MLSL2.f90,v 2.136 2005/05/31 17:51:17 pwagner Exp $"
  character(len=len(idParm)) :: Id = idParm
  character(len=*), parameter :: ModuleName="$RCSfile: MLSL2.f90,v $"
  !-----------------------------------------------------------------------------
d1063 3
@


2.136
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d8 1
d10 2
a11 1
  use INTRINSIC, only: L_HOURS, L_MINUTES, L_SECONDS, LIT_INDICES
a35 1
  ! use OBTAIN_MLSCF, only: Close_MLSCF, Open_MLSCF
d161 1
a161 1
     "$Id: MLSL2.f90,v 2.135 2005/04/12 18:12:30 pwagner Exp $"
d653 2
d656 1
a656 1
      & type='ascii', access='nonhdf', recordLength=recl, &
d687 1
a687 1
    MLSL2CF%type = 'tkgen'
d1054 3
@


2.135
log
@SIPS version limits warnings to 50; reads scalar intfromchars
@
text
@d17 2
a18 2
!   & MLS_IO_GEN_OPENF, &
    & ADDFILETODATABASE, Deallocate_filedatabase
d34 1
a34 1
  use OBTAIN_MLSCF, only: Close_MLSCF, Open_MLSCF
d38 1
a38 1
  use SDPToolkit, only: UseSDPToolkit !, PGSD_IO_GEN_RSEQFRM
d138 1
a138 1
  character(len=FILENAMELEN) :: L2CF_file       ! Some text
d160 1
a160 1
     "$Id: MLSL2.f90,v 2.134 2005/04/01 00:15:37 pwagner Exp $"
d166 1
a166 1
  type (MLSFile_T)                        ::     theFile
d652 4
a655 1
  L2CF_file = '<STDIN>'
d657 7
a663 6
    L2CF_file = line
    open ( l2cf_unit, file=line, status='old', &
     & form='formatted', access='sequential', recl=recl, iostat=status )
    ! inunit = mls_io_gen_openF('op', .true., status, &
     ! & record_length, PGSd_IO_Gen_RSeqFrm, FileName=trim(line), &
     ! & inp_rec_length=recl)
d665 7
a671 7
      L2CF_file = trim(line) // L2CFNAMEEXTENSION
       open ( l2cf_unit, file=trim(line) // L2CFNAMEEXTENSION, status='old', &
        & form='formatted', access='sequential', recl=recl, iostat=status )
    ! inunit = mls_io_gen_openF('op', .true., status, &
     ! & record_length, PGSd_IO_Gen_RSeqFrm, &
     ! & FileName=trim(line) // L2CFNAMEEXTENSION, &
     ! & inp_rec_length=recl)
d676 1
a676 1
        & "Unable to open L2CF file: " // trim(line) )
d678 1
a678 1
      call announce_success(L2CF_file, l2cf_unit)               
d682 7
a688 1
    call open_MLSCF ( MLSPCF_L2CF_Start, inunit, L2CF_file, status, recl )
d694 1
a694 1
        & "Unable to open L2CF file named in pcf" )
d696 1
a696 1
      call announce_success(L2CF_file, inunit)               
d700 6
a705 1
  numfiles = AddFileToDataBase(filedatabase, theFile)
d734 2
a735 1
    call close_MLSCF ( inunit, error )
d743 1
d886 1
a886 1
    call output(trim(L2CF_file), advance='yes')                            
d1051 3
@


2.134
log
@Automatcially remove slv switch from SIPS version
@
text
@d123 1
d125 2
a136 1
  integer, dimension(1) :: ints
d138 1
d146 1
d154 1
a155 5
  character(len=FILENAMELEN) :: L2CF_file       ! Some text
  character(len=len(switches)) :: removeSwitches = ''
  character(len=16) :: aSwitch
  character(len=16), dimension(1) :: strings
  character(len=len(switches)) :: tempSwitches
a156 2
  character(len=1) :: arg_rhs      ! 'n' part of 'arg=n'
  character(len=*), parameter :: L2CFNAMEEXTENSION = ".l2cf"
d160 1
a160 1
     "$Id: MLSL2.f90,v 2.133 2005/03/15 23:58:42 pwagner Exp $"
d187 1
a542 1
          ! print *, 'w option: ', trim(line(j+1:))
d549 1
a549 2
            strings(1) = line(j+1:)
            call readIntsFromChars(strings, ints)
a550 1
            MLSMessageConfig%limitWarnings = ints(1)
d1034 3
@


2.133
log
@Sets MLSMessageConfig appropriately for slaves
@
text
@d162 1
a162 1
     "$Id: MLSL2.f90,v 2.132 2005/03/12 00:49:18 pwagner Exp $"
d186 1
d1038 3
@


2.132
log
@-w option added
@
text
@d162 1
a162 1
     "$Id: MLSL2.f90,v 2.131 2005/03/03 00:23:42 pwagner Exp $"
d425 2
d1037 3
@


2.131
log
@Added -Rs1,s2,.. Removeswitches option
@
text
@d23 1
a23 1
    & PATCH, PENALTY_FOR_NO_METADATA, QUIT_ERROR_THRESHOLD, &
d31 1
a31 1
  use MLSStrings, only: lowerCase
d68 1
a68 1
  !    E.g., mlsl2 -m -p --nmeta -S"glo jac"
d102 1
a102 1
  ! Three alternatives are avialable to manage these tasks
d113 7
a119 3
  ! Note that (1) and (2) may permit more than one master task to run
  ! simultaneously. They require a queue manager to be running already.
  ! In contrast, (3) requires only the pvm demon.
d134 1
d154 1
d162 1
a162 1
     "$Id: MLSL2.f90,v 2.130 2005/01/22 00:39:08 pwagner Exp $"
d238 1
d478 1
a478 1
      do while ( j < len(line) )
d490 1
a490 1
          if ( j < len(line) ) then
d499 1
a499 1
          if ( j < len(line) ) then
d540 13
d584 1
a584 1
  ! Don't dump all the chunks agagin and again for each slave's chunk
d588 1
a621 2
    ! Maybe we should do away with checkPaths option altogether?
    ! or fix it somehow?
d623 1
a623 1
    & 'checkPaths will fail if l2pc files are on local disks but master runs' &
a784 1
  ! print *, 'destroy_char_table'
a785 1
  ! print *, 'destroy_hash_table'
a786 1
  ! print *, 'destroy_string_table'
a787 1
  ! print *, 'destroy_symbol_table'
a788 1
  ! print *, 'deallocate_decl'
a789 1
  ! print *, 'deallocate_tree'
a790 1
  ! print *, 'freepvmargs'
a804 1
  ! print *, 'add_to_section_timing'
a805 1
  ! print *, 'dump_section_timings'
d997 6
d1035 3
@


2.130
log
@Reversed buggy evercrash option
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d32 2
a33 2
  use MLSStringLists, only: catLists, GetUniqueList, &
    & RemoveElemFromList, unquote
d147 2
d156 1
a156 1
     "$Id: MLSL2.f90,v 2.129 2004/12/27 23:05:27 pwagner Exp $"
d506 3
d549 4
d557 6
d1019 3
@


2.129
log
@Commented out useless prints; warns on checkPaths option
@
text
@d154 1
a154 1
     "$Id: MLSL2.f90,v 2.128 2004/12/14 21:55:37 pwagner Exp $"
d274 1
a274 1
        neverCrash = switch
d1004 3
@


2.128
log
@May skip sections, stop early
@
text
@d29 1
a29 1
    & MLSMSG_Error, MLSMSG_Severity_to_quit, MLSMessageExit
d101 15
a115 1

d154 1
a154 1
     "$Id: MLSL2.f90,v 2.127 2004/10/30 00:28:00 vsnyder Exp $"
a276 4
      ! else if ( line(3+n:7+n) == 'gcch ' ) then
      !  garbage_collection_by_chunk = switch
      ! else if ( line(3+n:7+n) == 'gcdt ' ) then
      !  garbage_collection_by_dt = switch
d585 6
d751 1
a751 1
  print *, 'destroy_char_table'
d753 1
a753 1
  print *, 'destroy_hash_table'
d755 1
a755 1
  print *, 'destroy_string_table'
d757 1
a757 1
  print *, 'destroy_symbol_table'
d759 1
a759 1
  print *, 'deallocate_decl'
d761 1
a761 1
  print *, 'deallocate_tree'
d763 1
a763 1
  print *, 'freepvmargs'
d778 1
a778 1
  print *, 'add_to_section_timing'
d780 1
a780 1
  print *, 'dump_section_timings'
d1004 3
@


2.127
log
@Commented out some unused stuff to make NAG stop nagging
@
text
@d24 2
a25 2
    & SKIPDIRECTWRITES, SKIPRETRIEVAL, SECTIONTIMINGUNITS, SIPS_VERSION, &
    & TOOLKIT
d35 1
a35 1
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUT_DATE_AND_TIME, PRUNIT
d140 1
a140 1
     "$Id: MLSL2.f90,v 2.126 2004/10/11 16:57:03 pwagner Exp $"
d185 1
a185 1
   call ClearPVMArgs
d416 6
d715 5
d721 2
a722 1
      if ( timing ) call output ( "-------- Processing Begun ------ ", advance='yes' )
d735 1
d737 1
d739 1
d741 1
d743 1
d745 1
d747 1
d749 6
a754 5
  call Deallocate_filedatabase(filedatabase)
  if ( timing ) call sayTime ( 'Closing and deallocating' )
  call add_to_section_timing( 'main', t0 )
  if ( index(switches, 'time') /= 0 ) call dump_section_timings
  if ( error == 0 ) then
d756 1
a756 1
     if (error /= 0) then
d759 1
a759 1
     endif    
d761 5
d767 1
a767 1
  if(error /= 0) then
d883 1
a883 1
      call output(trim(parallel%pgeName), advance='yes')
d886 1
a886 1
      call output(trim(parallel%submit), advance='yes')
d888 1
a888 1
      call blanks(4, advance='no')                                                   
d891 1
a891 1
      call blanks(4, advance='no')                                                   
d894 1
a894 1
      call blanks(4, advance='no')                                                   
d897 11
a907 2
      call blanks(4, advance='no')                                                   
      call output(trim(parallel%chunkRange), advance='yes')
d937 1
a937 1
      call blanks(4, advance='no')
d942 1
a942 1
        call output(trim(switches), advance='yes')
d956 9
d988 3
@


2.126
log
@Bug fix for options; slaves output not logged; prints proc start, end date_and_time
@
text
@d17 2
a18 1
    & MLS_IO_GEN_OPENF, ADDFILETODATABASE, Deallocate_filedatabase
d38 1
a38 1
  use SDPToolkit, only: UseSDPToolkit, PGSD_IO_GEN_RSEQFRM
d123 1
a123 1
  integer :: RECORD_LENGTH
d140 1
a140 1
     "$Id: MLSL2.f90,v 2.125 2004/08/19 00:20:21 pwagner Exp $"
d945 3
@


2.125
log
@New crash-related, defaults options
@
text
@d34 1
a34 1
  use OUTPUT_M, only: BLANKS, OUTPUT, PRUNIT
d139 1
a139 1
     "$Id: MLSL2.f90,v 2.124 2004/08/16 17:12:20 pwagner Exp $"
d211 1
a211 1
      else if ( line(3+n:7+n) == 'check ' ) then
d543 1
a543 1
  elseif (parallel%slave .or. parallel%master) then
d545 2
d651 1
a651 1

d740 1
d944 3
@


2.124
log
@Fixed clearonallocate setting
@
text
@d14 1
a14 1
  use MACHINE ! At least HP for command lines, and maybe GETARG, too
d116 1
d124 1
a125 1
  integer :: LastCHUNK = 0         ! Just run range [SINGLECHUNK-LastCHUNK]
d139 1
a139 1
     "$Id: MLSL2.f90,v 2.123 2004/08/05 22:47:47 pwagner Exp $"
d168 1
d239 4
d258 2
d541 1
a541 1
  if ( .not. toolkit ) then
d619 1
a619 1
  else if ( TOOLKIT ) then
d636 1
a636 1
  if( index(switches, 'opt') /= 0 ) then
d648 1
d801 1
a801 1
    if( index(switches, 'opt1') /= 0 ) then                                 
d848 1
a848 1
      if ( parallel%master ) then
d912 6
d941 3
@


2.123
log
@New --chunkRange option to run selected chunks in parallel mode
@
text
@d5 2
a6 1
  use Allocate_Deallocate, only: SET_GARBAGE_COLLECTION, TRACKALLOCATES, CLEARONALLOCATE
d138 1
a138 1
     "$Id: MLSL2.f90,v 2.122 2004/08/04 23:19:57 pwagner Exp $"
d337 1
a337 1
        trackAllocates = switch
d926 3
@


2.122
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d123 1
a123 1
  integer :: LastCHUNK = 0         ! Just run range [SINGLECHUNK, LastCHUNK]
d137 1
a137 1
     "$Id: MLSL2.f90,v 2.121 2004/07/08 22:48:44 pwagner Exp $"
d214 1
a214 1
      else if ( line(3+n:7+n) == 'chunk' ) then
d216 3
a218 8
        if ( line(8+n:) /= ' ' ) then
          copyArg = .false.
          line(:7+n) = ' '
        else
          i = i + 1
          call getarg ( i, line )
          command_line = trim(command_line) // ' ' // trim(line)
        end if
d359 4
d857 3
d925 3
@


2.121
log
@Made SIPS_VERSION public
@
text
@d29 2
a30 1
  use MLSStrings, only: catLists, GetUniqueList, lowerCase, &
d137 1
a137 1
     "$Id: MLSL2.f90,v 2.120 2004/06/29 00:10:17 pwagner Exp $"
d923 3
@


2.120
log
@Exploit catlist function
@
text
@d22 2
a23 1
    & SKIPDIRECTWRITES, SKIPRETRIEVAL, SECTIONTIMINGUNITS, TOOLKIT
d136 1
a136 1
     "$Id: MLSL2.f90,v 2.119 2004/04/27 23:50:24 pwagner Exp $"
d156 1
a156 1
  if ( TOOLKIT ) then
d631 6
d922 3
@


2.119
log
@Added SKIPDIRECTWRITES option
@
text
@d28 2
a29 1
  use MLSStrings, only: GetUniqueList, lowerCase, RemoveElemFromList, unquote
d135 1
a135 1
     "$Id: MLSL2.f90,v 2.118 2004/04/15 22:48:30 pwagner Exp $"
d478 1
a478 1
          switches = trim(switches) // ',' // line(j+1:)
d486 1
a486 1
                & switches = trim(switches) // ',' // 'time'
d915 3
@


2.118
log
@Multiword options like maxFailuresPerChunk made case-insensitive
@
text
@d22 1
a22 1
    & SKIPRETRIEVAL, SECTIONTIMINGUNITS, TOOLKIT
d134 1
a134 1
     "$Id: MLSL2.f90,v 2.117 2004/04/06 23:50:09 livesey Exp $"
d361 2
d861 3
d914 3
@


2.117
log
@Added clearOnAllocate flag
@
text
@d134 1
a134 1
     "$Id: MLSL2.f90,v 2.116 2004/04/03 05:44:16 livesey Exp $"
d234 1
a234 1
      else if ( line(3+n:7+n) == 'ckbk ' ) then
d236 1
a236 1
      else if ( line(3+n:14+n) == 'countChunks ' ) then
d253 1
a253 1
      else if ( line(3+n:14+n) == 'fwmParallel ' ) then
d266 1
a266 1
      else if ( line(3+n:6+n) == 'l1b=' ) then
d276 1
a276 1
      else if ( line(3+n:8+n) == 'l2gpr=' ) then
d286 1
a286 1
      else if ( line(3+n:8+n) == 'l2gpw=' ) then
d307 1
a307 1
      else if ( line(3+n:21+n) == 'maxfailuresperchunk' ) then
d322 1
a322 1
      else if ( line(3+n:23+n) == 'maxfailurespermachine' ) then
d337 1
a337 1
      else if ( line(3+n:18+n) == 'clearOnAllocate ' ) then
d339 1
a339 1
      else if ( line(3+n:11+n) == 'memTrack ' ) then
d343 1
a343 1
      else if ( line(3+n:5+n) == 'pge ' ) then
d348 1
a348 1
      else if ( line(3+n:6+n) == 'recl' ) then
d361 1
a361 1
      else if ( line(3+n:10+n) == 'skipRetr' ) then
d363 1
a363 1
      else if ( line(3+n:10+n) == 'slaveMAF' ) then
d394 1
a394 1
      else if ( line(3+n:12+n) == 'snoopname' ) then
d400 1
a400 1
      else if ( line(3+n:9+n) ==  'stgmem ' ) then
d402 1
a402 1
      else if ( line(3+n:11+n) == 'subblock ' ) then
d418 1
a418 1
      else if ( line(3+n:5+n) == 'tk ' ) then
d909 3
@


2.116
log
@Added memTrack option
@
text
@d5 1
a5 1
  use Allocate_Deallocate, only: SET_GARBAGE_COLLECTION, TRACKING
d134 1
a134 1
     "$Id: MLSL2.f90,v 2.115 2004/03/24 23:54:06 pwagner Exp $"
d337 2
d340 1
a340 1
        tracking = switch
d909 3
@


2.115
log
@Switched from h5_open/close_f to mls_open/close
@
text
@d5 1
a5 1
  use Allocate_Deallocate, only: SET_GARBAGE_COLLECTION
d134 1
a134 1
     "$Id: MLSL2.f90,v 2.114 2004/03/24 01:03:34 livesey Exp $"
d337 3
a339 1
      else if ( line(3+n:14+n) == 'patch ' ) then
d907 3
@


2.114
log
@Increased tree size.
@
text
@d15 1
a15 1
  USE MLSFiles, only: WILDCARDHDFVERSION, HDFVERSION_4, HDFVERSION_5, &
d17 1
d134 1
a134 1
     "$Id: MLSL2.f90,v 2.113 2004/02/05 23:26:22 pwagner Exp $"
d147 1
a147 1
  call h5open_f(error)
d150 1
a150 1
        & "Unable to h5_open_f" )
d708 1
a708 1
     call h5close_f(error)
d711 1
a711 1
        & "Unable to h5_close_f" )
d905 3
@


2.113
log
@Added --cat option
@
text
@d133 1
a133 1
     "$Id: MLSL2.f90,v 2.112 2004/01/09 00:22:12 pwagner Exp $"
d167 1
a167 1
  call allocate_tree ( n_tree=360000 )
d904 3
@


2.112
log
@Unsets avoidUnlimitedDims to bypass bug directWriting range of chunks
@
text
@d17 1
a17 1
  use MLSL2Options, only: CHECKPATHS, CURRENT_VERSION_ID, &
d133 1
a133 1
     "$Id: MLSL2.f90,v 2.111 2004/01/07 23:50:16 livesey Exp $"
d202 3
a204 1
      if ( line(3+n:7+n) == 'check ' ) then
d552 1
a552 1
  if ( lastChunk /= 0 ) avoidUnlimitedDims = .false.
d811 3
d904 3
@


2.111
log
@Added error message about fwmParallel being broken at the moment
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d9 1
d133 1
a133 1
     "$Id: MLSL2.f90,v 2.110 2003/12/11 22:56:04 pwagner Exp $"
d204 3
a206 1
      else if ( line(3+n:12+n) == 'checkpaths' ) then
d547 4
d803 1
a803 1
      call blanks(5, advance='no')                                                   
d806 3
d899 3
@


2.110
log
@Transmits --idents option to slaves; unquotes switches
@
text
@d132 1
a132 1
     "$Id: MLSL2.f90,v 2.109 2003/12/07 23:06:29 pwagner Exp $"
d514 1
d552 3
d889 3
@


2.109
log
@Should not dump all the chunks agagin and again for each slaves chunk
@
text
@d8 1
a8 1
  use INTRINSIC, only: L_HOURS, L_MINUTES, L_SECONDS
a15 1
  !    & MLSFile_T, MLS_IO_GEN_OPENF, ADDFILETODATABASE, Deallocate_filedatabase
d26 1
a26 1
  use MLSStrings, only: GetUniqueList, lowerCase, RemoveElemFromList
d132 1
a132 1
     "$Id: MLSL2.f90,v 2.108 2003/12/05 00:40:11 pwagner Exp $"
d139 2
d253 5
d505 2
a506 1
  call GetUniqueList(switches, tempSwitches, numSwitches, countEmpty=.true., &
a507 1
  switches = tempSwitches
d798 1
a798 1
      call output(' Avoid creating file on first directWrite?:                ', advance='no')
d846 2
a847 1
      call display_string ( sectionTimingUnits, strip=.true., advance='yes' )
d885 3
@


2.108
log
@Added patch option, section timing units
@
text
@d27 1
a27 1
  use MLSStrings, only: GetUniqueList, lowerCase
d133 1
a133 1
     "$Id: MLSL2.f90,v 2.107 2003/11/15 00:33:37 pwagner Exp $"
d498 1
d502 5
d878 3
@


2.107
log
@New commandline opts: maxfailuresperchunk, maxfailurespermachine
@
text
@d8 1
d17 6
a22 8
  use MLSL2Options, only: OUTPUT_PRINT_UNIT, &
    & QUIT_ERROR_THRESHOLD, TOOLKIT, CURRENT_VERSION_ID, &
    & PENALTY_FOR_NO_METADATA, NORMAL_EXIT_STATUS, &
    & GARBAGE_COLLECTION_BY_CHUNK, &
    & DEFAULT_HDFVERSION_READ, &
    & DEFAULT_HDFVERSION_WRITE, DEFAULT_HDFVERSION_READ, LEVEL1_HDFVERSION, &
    & SKIPRETRIEVAL, CHECKPATHS
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES, &
d27 1
a27 1
  use MLSStrings, only: GetUniqueList
d35 1
a35 1
    & DESTROY_STRING_TABLE, DO_LISTING, INUNIT
d133 1
a133 1
     "$Id: MLSL2.f90,v 2.106 2003/11/14 23:37:13 pwagner Exp $"
d248 4
a251 4
      else if ( line(3+n:7+n) == 'gcch ' ) then
        garbage_collection_by_chunk = switch
      else if ( line(3+n:7+n) == 'gcdt ' ) then
        garbage_collection_by_dt = switch
d325 2
d463 2
a464 1
          if ( j < len(line) ) then
d471 6
a476 1
              j = j + 1
d478 2
a479 1
          end if
d523 1
d786 3
d832 3
d872 3
@


2.106
log
@Lets user change masterLoop delay via commandline option
@
text
@d134 1
a134 1
     "$Id: MLSL2.f90,v 2.105 2003/11/07 00:46:51 pwagner Exp $"
d296 30
d857 3
@


2.105
log
@New quicker preflight option: --checkPaths
@
text
@d134 1
a134 1
     "$Id: MLSL2.f90,v 2.104 2003/11/05 21:27:54 pwagner Exp $"
d232 15
d766 3
d827 3
@


2.104
log
@Can enter range of chunks to be processed instead of single
@
text
@d22 1
a22 1
    & SKIPRETRIEVAL
d134 1
a134 1
     "$Id: MLSL2.f90,v 2.103 2003/10/21 00:02:32 pwagner Exp $"
d203 2
d469 8
a476 1

d760 3
d809 3
@


2.103
log
@Revert to writing just once if toolkit and parallel
@
text
@d119 2
a120 1
  integer :: SINGLECHUNK = 0       ! Just run one chunk
d134 1
a134 1
     "$Id: MLSL2.f90,v 2.102 2003/10/14 18:17:02 pwagner Exp $"
d213 12
a224 4
        read ( line, *, iostat=status ) singleChunk
        if ( status /= 0 ) then
          call io_error ( "After --chunk option", status, line )
          stop
d596 1
a596 1
        & singleChunk, filedatabase )
d709 1
a709 1
      if ( singleChunk /= 0 ) then
d713 6
d797 3
@


2.102
log
@Fixed problem with reducing switches to unique list
@
text
@d133 1
a133 1
     "$Id: MLSL2.f90,v 2.101 2003/10/09 23:57:35 pwagner Exp $"
d444 1
a444 1
     prunit = -3          ! output both logged and sent to stdout
d782 3
@


2.101
log
@A few more SIPS-related tweaks
@
text
@d126 1
d133 1
a133 1
     "$Id: MLSL2.f90,v 2.100 2003/10/09 23:35:21 pwagner Exp $"
d434 1
a434 1
  call GetUniqueList(switches, switches, numSwitches, countEmpty=.true., &
d436 1
d782 3
@


2.100
log
@Treats SIPS version special; switches ,-separated
@
text
@d20 1
a20 1
    & DEFAULT_HDFVERSION_READ, DEFAULT_HDFVERSION_WRITE, &
d132 1
a132 1
     "$Id: MLSL2.f90,v 2.99 2003/09/05 23:22:08 pwagner Exp $"
d155 1
d256 1
a256 1
          DEFAULT_HDFVERSION_WRITE = WILDCARDHDFVERSION
d743 8
a753 3
      call output(' Number of switches set:                         ', advance='no')
      call blanks(4, advance='no')
      call output(numSwitches, advance='yes')
d780 3
@


2.99
log
@Takes in new --skipRetrieval option
@
text
@d28 1
d95 1
d115 1
d132 1
a132 1
     "$Id: MLSL2.f90,v 2.98 2003/08/01 20:26:01 pwagner Exp $"
d147 12
a158 2
  endif    

d400 1
a400 1
          switches = trim(switches) // line(j+1:)
d407 1
a407 1
                & switches = trim(switches) // 'time'
d432 2
d440 2
d458 3
d464 9
a472 2
  if ( parallel%slave ) call InitParallel ( singleChunk, slaveMAF )

d519 3
d642 1
a642 1
    print *, 'Switch usage: -S"sw1 sw2 .. swn" or -Ssw1 -Ssw2 ..'
a701 3
!     call output(' Manually collect garbage after each deallocate: ', advance='no') 
!     call blanks(4, advance='no')                                                   
!     call output(garbage_collection_by_dt, advance='yes')                           
d718 6
d745 3
d774 3
@


2.98
log
@gets slave pge name from command line
@
text
@d21 2
a22 1
    & DEFAULT_HDFVERSION_WRITE, DEFAULT_HDFVERSION_READ, LEVEL1_HDFVERSION
d129 1
a129 1
     "$Id: MLSL2.f90,v 2.97 2003/06/13 20:02:50 vsnyder Exp $"
d273 2
d667 5
a671 3
!     call output(' Manually collect garbage after each chunk:      ', advance='no') 
!     call blanks(4, advance='no')                                                   
!     call output(garbage_collection_by_chunk, advance='yes')                        
d675 3
d681 11
d695 11
d738 3
@


2.97
log
@Put snoopMAF before snoop, so it can be found, futzing
@
text
@d128 1
a128 1
     "$Id: MLSL2.f90,v 2.96 2003/06/09 22:49:33 pwagner Exp $"
d254 5
d708 3
@


2.96
log
@Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
@
text
@d128 1
a128 1
     "$Id: MLSL2.f90,v 2.95 2003/05/14 00:59:40 livesey Exp $"
d254 8
a261 4
      else if ( line(3+n:7+n) == 'recl ' ) then
        i = i + 1
        call getarg ( i, line )
        command_line = trim(command_line) // ' ' // trim(line)
d267 1
a267 1
      else if ( line(3+n:7+n) == 'slave' ) then
d269 2
a270 3
        parallel%slave = .true.
        if ( line(8+n:) /= ' ' ) then
          line(:7+n) = ' '
d274 1
a274 1
          command_line = trim(command_line) // ' ' // trim(line)
d276 1
a276 1
        read ( line, *, iostat=status ) parallel%masterTid
d278 1
a278 1
          call io_error ( "After --slave option", status, line )
d281 1
a281 1
      else if ( line(3+n:10+n) == 'slaveMAF' ) then
d283 1
d289 1
a289 1
          command_line = trim(command_line) // ' ' // trim(line)
d291 1
a291 1
        read ( line, *, iostat=status ) slaveMAF
d293 1
a293 1
          call io_error ( "After --slaveMAF option", status, line )
d326 2
a327 2
          print*, current_version_id(j)
        enddo
d703 3
@


2.95
log
@Increased hash table size.
@
text
@d16 3
a18 3
  use MLSL2Options, only: PCF_FOR_INPUT, PCF, OUTPUT_PRINT_UNIT, &
    & QUIT_ERROR_THRESHOLD, TOOLKIT, CREATEMETADATA, CURRENT_VERSION_ID, &
    & PENALTY_FOR_NO_METADATA, PUNISH_FOR_INVALID_PCF, NORMAL_EXIT_STATUS, &
d55 1
a55 1
  !        (if and only if pcf_for_input is TRUE)
d128 1
a128 1
     "$Id: MLSL2.f90,v 2.94 2003/05/13 04:48:20 livesey Exp $"
d184 1
a184 3
      if ( line(3+n:8+n) == 'cfpcf ' ) then
        pcf_for_input = switch
      else if ( line(3+n:7+n) == 'check ' ) then
a253 4
      else if ( line(3+n:7+n) == 'meta ' ) then
        createMetadata = switch
      else if ( line(3+n:6+n) == 'pcf ' ) then
        pcf = switch
a411 1
     pcf = .false.
d421 1
a421 1
  UseSDPToolkit = pcf    ! Redundant, but may be needed in lib
d423 1
a423 4
  if ( .not. pcf ) then
     pcf_for_input = .false.
     punish_for_invalid_pcf = .false.
     createMetadata = .false.
d462 1
a462 1
  else if ( pcf_for_input ) then
d493 1
a493 1
  if ( PCF_FOR_INPUT .and. error==0) then
a639 15
      call output(' Use PCF file:                                   ', advance='no')
      call blanks(4, advance='no')
      call output(pcf, advance='yes')
      call output(' Get l2cf from pcf:                              ', advance='no')
      call blanks(4, advance='no')
      call output(pcf_for_input, advance='yes')
      call output(' Punish for errors in pcf:                       ', advance='no')
      call blanks(4, advance='no')
      call output(punish_for_invalid_pcf, advance='yes')
      call output(' Create metadata for each output file:           ', advance='no')
      call blanks(4, advance='no')
      call output(createMetadata, advance='yes')
      call output(' Punish for metadata creation errors:            ', advance='no')
      call blanks(5, advance='no')
      call output(penalty_for_no_metadata, advance='yes')
d699 3
@


2.94
log
@Added stgmem option
@
text
@d128 1
a128 1
     "$Id: MLSL2.f90,v 2.93 2003/02/27 18:40:29 pwagner Exp $"
d147 1
a147 1
  call init_lexer ( n_chars=80000, n_symbols=4000, hash_table_size=50207 )
d724 3
@


2.93
log
@recl passed to let NAG open l2cf with long lines
@
text
@d128 1
a128 1
     "$Id: MLSL2.f90,v 2.92 2003/02/08 00:30:57 pwagner Exp $"
d306 2
d724 3
@


2.92
log
@Increased default RECL due to new l2cfs in lib
@
text
@d128 1
a128 1
     "$Id: MLSL2.f90,v 2.91 2002/12/19 11:54:45 livesey Exp $"
d471 1
a471 1
    call open_MLSCF ( MLSPCF_L2CF_Start, inunit, L2CF_file, status )
d722 3
@


2.91
log
@Upped tree size
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d79 1
a79 1
  ! (1) Accept hard-wired options 
d109 1
a109 1
  character(len=2048) :: LINE           ! Into which is read the command args
d112 1
a112 1
  integer :: RECL = 10000          ! Record length for l2cf
d122 2
a123 2
  character(len=2048) :: WORD       ! Some text
  character(len=1) :: arg_rhs       ! 'n' part of 'arg=n'
d128 1
a128 1
     "$Id: MLSL2.f90,v 2.90 2002/12/10 00:39:06 pwagner Exp $"
d196 1
d250 1
d263 1
d277 1
d291 1
d304 1
d310 1
d320 1
d334 1
d722 3
@


2.90
log
@Announces success a la read_apriori
@
text
@d128 1
a128 1
     "$Id: MLSL2.f90,v 2.89 2002/12/06 22:33:41 livesey Exp $"
d149 1
a149 1
  call allocate_tree ( n_tree=120000 )
d713 3
@


2.89
log
@Added the snoop name stuff
@
text
@d128 1
a128 1
     "$Id: MLSL2.f90,v 2.88 2002/12/05 19:45:20 pwagner Exp $"
d457 2
d469 2
d695 15
d713 3
@


2.88
log
@Moved MLSFile_T from MLSFiles to MLSCommon
@
text
@d32 1
a32 1
  use SnoopMLSL2, only: SNOOPINGACTIVE
d128 1
a128 1
     "$Id: MLSL2.f90,v 2.87 2002/12/04 01:18:21 pwagner Exp $"
d295 5
d694 3
@


2.87
log
@First halting steps toward using filedatabase
@
text
@d12 1
a12 1
  use MLSCOMMON, only: FILENAMELEN
d14 2
a15 1
    & MLSFile_T, MLS_IO_GEN_OPENF, ADDFILETODATABASE, Deallocate_filedatabase
d128 1
a128 1
     "$Id: MLSL2.f90,v 2.86 2002/11/13 01:08:40 pwagner Exp $"
d689 3
@


2.86
log
@Prints more info when called asked to print opts
@
text
@d13 2
a14 1
  USE MLSFiles, only: WILDCARDHDFVERSION, HDFVERSION_4, HDFVERSION_5
d30 1
a30 1
  use SDPToolkit, only: UseSDPToolkit
d110 1
d112 1
d127 1
a127 1
     "$Id: MLSL2.f90,v 2.85 2002/10/30 00:56:51 livesey Exp $"
d132 3
d434 4
a437 1
      & form='formatted', access='sequential', recl=recl, iostat=status )
d440 1
a440 1
      open ( l2cf_unit, file=trim(line) // L2CFNAMEEXTENSION, status='old', &
d442 4
d464 2
d531 1
a531 1
        & singleChunk )
d549 1
d688 3
@


2.85
log
@Increased size of hash table
@
text
@d124 1
a124 1
     "$Id: MLSL2.f90,v 2.84 2002/10/08 17:41:20 livesey Exp $"
d634 4
a637 1
      call output(' Default hdf version on reads:                   ', advance='no')
d640 1
a640 1
      call output(' Default hdf version on writes:                  ', advance='no')
d643 6
a648 6
      call output(' Manually collect garbage after each chunk:      ', advance='no')
      call blanks(4, advance='no')
      call output(garbage_collection_by_chunk, advance='yes')
      call output(' Manually collect garbage after each deallocate: ', advance='no')
      call blanks(4, advance='no')
      call output(garbage_collection_by_dt, advance='yes')
d672 3
@


2.84
log
@Now passes chunk argument to slaves if present.  Needed for
fwmParallel mode.
@
text
@d124 1
a124 1
     "$Id: MLSL2.f90,v 2.83 2002/10/05 00:44:14 livesey Exp $"
d140 1
a140 1
  call init_lexer ( n_chars=80000, n_symbols=4000, hash_table_size=7841 )
d669 4
@


2.83
log
@Included the FMWParallel stuff
@
text
@d124 1
a124 1
     "$Id: MLSL2.f90,v 2.82 2002/10/03 23:00:03 pwagner Exp $"
d182 1
a182 1
        copyArg=.false.
d184 1
d669 3
@


2.82
log
@You can set l1b, l2gp hdfversions on command line
@
text
@d112 1
d124 1
a124 1
     "$Id: MLSL2.f90,v 2.81 2002/09/24 18:17:20 pwagner Exp $"
d198 2
d242 1
a242 1
        call InitParallel ( 0 )
d272 13
d415 4
a418 1
  if ( parallel%slave ) call InitParallel ( singleChunk )
d514 2
a515 1
      call walk_tree_to_do_MLS_L2 ( root, error, first_section, countChunks, singleChunk )
d668 3
@


2.81
log
@Consistent with add_to_section_timing now calling time_now at its end
@
text
@d13 1
d18 2
a19 1
    & DEFAULT_HDFVERSION_READ, DEFAULT_HDFVERSION_WRITE
d42 4
d47 1
d118 1
d123 1
a123 1
     "$Id: MLSL2.f90,v 2.80 2002/08/29 21:47:51 livesey Exp $"
d203 30
d648 3
@


2.80
log
@Added subblock option
@
text
@d115 1
a115 1
     "$Id: MLSL2.f90,v 2.79 2002/08/21 18:22:26 vsnyder Exp $"
d444 2
a445 1
    call add_to_section_timing( 'main', t0 )
d610 3
@


2.79
log
@Revise processing of Lahey/Fujitsy runtime (-Wl) options
@
text
@d38 1
a38 1
  use MATRIXMODULE_0, only: CHECKBLOCKS
d115 1
a115 1
     "$Id: MLSL2.f90,v 2.78 2002/08/15 21:48:51 pwagner Exp $"
d233 9
d609 3
@


2.78
log
@h5open(close)_f now called at start (end)
@
text
@d115 1
a115 1
     "$Id: MLSL2.f90,v 2.77 2002/07/23 23:15:05 pwagner Exp $"
d151 6
a160 4
    if ( line(1:4) == '-Wl,' ) then     ! skip Lahey/Fujitsu run-time options
      i = i + 1
      call AccumulateSlaveArguments(line)
    end if
d600 3
@


2.77
log
@Moved dump_settings call after learning name of l2cf file
@
text
@d115 1
a115 1
     "$Id: MLSL2.f90,v 2.76 2002/07/18 21:59:28 vsnyder Exp $"
d123 5
d466 7
d598 3
@


2.76
log
@Cosmetic changes, move some stuff around so PRUNIT is stdout in init_tables
@
text
@d115 1
a115 1
     "$Id: MLSL2.f90,v 2.75 2002/05/28 22:34:59 livesey Exp $"
a342 4
  if( index(switches, 'opt') /= 0 ) then
    call dump_settings
  end if

d379 4
d495 1
d509 1
d586 3
@


2.75
log
@Increased tree size
@
text
@d115 1
a115 1
     "$Id: MLSL2.f90,v 2.74 2002/05/24 17:27:18 pwagner Exp $"
d124 8
a138 8
   
  !---------------- Task (2) ------------------
! Initialize the lexer, symbol table, and tree checker's tables:
!  ( Under some circumstances, you may need to increase these )
  call init_lexer ( n_chars=80000, n_symbols=4000, hash_table_size=7841 )
  call allocate_decl ( ndecls=1000 )
  call allocate_tree ( n_tree=120000 )
  call init_tables
a141 1
  i = 1+hp
d144 1
d323 19
a341 19
   if ( .not. toolkit ) then
      pcf = .false.
      prunit = max(-1, prunit)   ! stdout or Fortran unit
   end if

   if( index(switches, 'log') /= 0 .or. .not. toolkit ) then
      MLSMessageConfig%LogFileUnit = -1
   else
      MLSMessageConfig%LogFileUnit = -2   ! the default in MLSMessageModule
   end if

   UseSDPToolkit = pcf    ! Redundant, but may be needed in lib

   if ( .not. pcf ) then
      pcf_for_input = .false.
      punish_for_invalid_pcf = .false.
      createMetadata = .false.
      penalty_for_no_metadata = 0
   end if
d345 1
a345 1
  endif
a349 1
! Parse the L2CF, producing an abstract syntax tree
d352 1
d385 1
d402 1
a402 1
  elseif ( root <= 0 ) then
a419 4
    if(error /= 0) then
       call MLSMessage(MLSMSG_Error, ModuleName, &
       & 'error in check_tree: probably need to repair l2cf ' )
    end if
d430 5
d584 3
@


2.74
log
@Added recl=recl to second-chance open of l2cf
@
text
@d115 1
a115 1
     "$Id: MLSL2.f90,v 2.73 2002/05/23 20:57:57 vsnyder Exp $"
d137 1
a137 1
  call allocate_tree ( n_tree=60000 )
d582 3
@


2.73
log
@Add --recl option, some cosmetic changes
@
text
@d115 1
a115 1
     "$Id: MLSL2.f90,v 2.72 2002/05/14 00:26:49 livesey Exp $"
d362 1
a362 1
        & form='formatted', access='sequential', iostat=status )
d582 3
@


2.72
log
@Larger table sizes (may be unnecessary)
@
text
@d102 1
d115 1
a115 1
     "$Id: MLSL2.f90,v 2.71 2002/04/24 20:21:13 livesey Exp $"
a187 2
      else if ( line(3+n:7+n) == 'meta ' ) then
        createMetadata = switch
d198 2
d202 1
a202 2
      else if ( line(3+n:9+n) == 'submit ' ) then
        copyArg = .false.
d205 5
a209 1
        parallel%submit = trim ( line )
d226 5
d358 1
a358 1
      & form='formatted', access='sequential', iostat=status )
d487 1
a487 1
  subroutine switch_usage
d497 1
a497 1
  end subroutine switch_usage
d499 1
a499 1
  subroutine option_usage
d510 1
a510 1
  end subroutine option_usage
d512 1
a512 1
  subroutine dump_settings
d577 1
a577 1
  end subroutine dump_settings
d582 3
@


2.71
log
@Upped some string sizes.
@
text
@d114 1
a114 1
     "$Id: MLSL2.f90,v 2.70 2002/04/24 16:54:02 livesey Exp $"
d134 1
a134 1
  call init_lexer ( n_chars=10000, n_symbols=1000, hash_table_size=4051 )
d573 3
@


2.70
log
@Changes for submit option
@
text
@d89 1
a89 1
  character(len=255) :: command_line ! All the opts
d100 1
a100 1
  character(len=255) :: LINE       ! Into which is read the command args
d109 1
a109 1
  character(len=255) :: WORD       ! Some text
d114 1
a114 1
     "$Id: MLSL2.f90,v 2.69 2002/03/20 00:48:29 pwagner Exp $"
d573 3
@


2.69
log
@Option -check just checks l2cf then quits
@
text
@d8 1
a8 1
  use L2PARINFO, only: PARALLEL, INITPARALLEL
d26 1
a26 1
  use PVM, only: ClearPVMArgs, NextPVMArg, FreePVMArgs
d114 1
a114 1
     "$Id: MLSL2.f90,v 2.68 2002/02/20 00:29:04 pwagner Exp $"
d140 1
d151 1
a151 2
      call NextPVMArg(trim(line)//' ')
      cycle
d195 1
a195 1
        call InitParallel
d198 1
a198 1
        call NextPVMArg(trim(word)//' ')
d201 5
a214 1
        call InitParallel
d234 1
a234 1
        call NextPVMArg(trim(line)//' ')
d300 1
a300 1
      call NextPVMArg(trim(line)//' ')
d304 1
a304 1
    if ( copyArg ) call NextPVMArg(trim(line)//' ')
d337 4
d573 3
@


2.68
log
@Retries FN+.l2cf; tracks successful l2cf file name
@
text
@d76 1
a76 1
  ! (7) call walk_tree_to_do_MLS_L2 to do the (mostly) scientific tasks
d92 1
d114 1
a114 1
     "$Id: MLSL2.f90,v 2.67 2002/02/12 00:25:00 pwagner Exp $"
d162 2
d402 4
a405 4
   if(error /= 0) then
      call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'error in check_tree: probably need to repair l2cf ' )
   end if
d417 1
a417 1
    if ( error == 0 .and. first_section /= 0 ) then
d446 3
a448 3
   else
     call MLSMessageExit
   endif
d565 3
@


2.67
log
@New switch -opt[n] and new --version option
@
text
@d12 1
d55 4
d107 1
d109 1
d113 1
a113 1
     "$Id: MLSL2.f90,v 2.66 2002/02/05 00:44:03 pwagner Exp $"
d334 1
d336 1
d340 5
d351 1
a351 1
    call open_MLSCF ( MLSPCF_L2CF_Start, inunit, status )
d497 3
d562 3
@


2.66
log
@Added garbage collection stuff
@
text
@d13 1
a13 1
    & QUIT_ERROR_THRESHOLD, TOOLKIT, CREATEMETADATA, &
d15 2
a16 1
    & GARBAGE_COLLECTION_BY_CHUNK
d37 1
a37 1
  use MATRIXMODULE_0, only :CHECKBLOCKS
d84 1
d106 1
a106 1
     "$Id: MLSL2.f90,v 2.65 2002/01/18 18:55:25 livesey Exp $"
d135 1
d139 1
d210 5
d224 1
a224 1
        call usage
d256 1
a256 1
          call usage
d282 1
a282 1
          call usage
d320 3
d465 1
a465 1
  subroutine Usage
d476 66
a541 1
  end subroutine Usage
d545 3
@


2.65
log
@Added the --chunk option
@
text
@d1 1
a1 2

! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d5 1
d14 2
a15 1
    & PENALTY_FOR_NO_METADATA, PUNISH_FOR_INVALID_PCF, NORMAL_EXIT_STATUS
d89 1
d104 1
a104 1
     "$Id: MLSL2.f90,v 2.64 2002/01/09 22:56:46 livesey Exp $"
d167 4
d287 1
d468 3
@


2.64
log
@Tidied up parsing of master option.
@
text
@d93 1
d102 1
a102 1
     "$Id: MLSL2.f90,v 2.63 2002/01/09 00:00:48 pwagner Exp $"
d148 13
d385 1
a385 1
      call walk_tree_to_do_MLS_L2 ( root, error, first_section, countChunks )
d461 3
@


2.63
log
@Fixed small comment; added others explaining unavoidable use of print
@
text
@d101 1
a101 1
     "$Id: MLSL2.f90,v 2.62 2001/12/13 23:21:20 livesey Exp $"
d160 1
a160 5
        read ( line, *, iostat=status ) parallel%slaveFilename
        if ( status /= 0 ) then
          call io_error ( "After --master option", status, line )
          stop
        end if
d447 3
@


2.62
log
@Added countChunks option
@
text
@d60 1
a60 1
  ! (b) the l2cf 
d101 1
a101 1
     "$Id: MLSL2.f90,v 2.61 2001/11/09 23:17:22 vsnyder Exp $"
d417 7
d451 3
@


2.61
log
@Use Time_Now instead of CPU_TIME
@
text
@d83 1
d101 1
a101 1
     "$Id: MLSL2.f90,v 2.60 2001/11/09 18:12:38 livesey Exp $"
d149 2
d375 1
a375 1
      call walk_tree_to_do_MLS_L2 ( root, error, first_section )
d444 3
@


2.60
log
@Added --nckbk option.
@
text
@d29 1
d100 1
a100 1
     "$Id: MLSL2.f90,v 2.59 2001/10/12 23:11:28 pwagner Exp $"
d107 1
a107 1
  call cpu_time ( t0 )
d146 2
a149 2
      else if ( line(3+n:8+n) == 'snoop ' ) then
        snoopingActive = .true.
a151 8
      else if ( line(3+n:6+n) == 'pcf ' ) then
        pcf = switch
      else if ( line(3+n:5+n) == 'tk ' ) then
        toolkit = switch
      else if ( line(3+n:7+n) == 'ckbk ' ) then
        checkBlocks = .true.
      else if ( line(3+n:8+n) == 'nckbk ' ) then
        checkBlocks = .false.
d166 2
d183 6
d315 1
a315 1
  call cpu_time ( t1 )
d351 1
a351 1
    call cpu_time ( t1 )
d370 1
a370 1
      call cpu_time ( t1 )
d380 1
a380 1
  call cpu_time ( t0 )
d404 1
a404 1
    call cpu_time ( t2 )
d441 3
@


2.59
log
@Clarified what Processing time means?
@
text
@d99 1
a99 1
     "$Id: MLSL2.f90,v 2.58 2001/10/09 22:37:55 livesey Exp $"
d157 2
d440 3
@


2.58
log
@Increased tree size and hash table size to accomodate new
spectroscopy database from Bill
@
text
@d99 1
a99 1
     "$Id: MLSL2.f90,v 2.57 2001/10/04 23:50:25 livesey Exp $"
d368 1
d370 4
a373 1
      if ( timing ) call sayTime ( 'Processing' )
d438 4
@


2.57
log
@Added the ckbk option
@
text
@d99 1
a99 1
     "$Id: MLSL2.f90,v 2.56 2001/10/04 00:16:45 pwagner Exp $"
d119 1
a119 1
  call init_lexer ( n_chars=10000, n_symbols=1000, hash_table_size=2117 )
d121 1
a121 1
  call allocate_tree ( n_tree=15000 )
d434 3
@


2.56
log
@Increased hash table size; added note that size(s) may need to grow
@
text
@d34 1
d99 1
a99 1
     "$Id: MLSL2.f90,v 2.55 2001/09/28 23:59:20 pwagner Exp $"
d155 2
d434 3
@


2.55
log
@Fixed various timing problems
@
text
@d98 1
a98 1
     "$Id: MLSL2.f90,v 2.54 2001/09/28 17:50:30 pwagner Exp $"
d117 2
a118 1
  call init_lexer ( n_chars=10000, n_symbols=1000, hash_table_size=2017 )
d431 3
@


2.54
log
@MLSL2Timings module keeps timing info
@
text
@d92 1
a92 1
  real :: T1, T2                   ! For timing
d98 1
a98 1
     "$Id: MLSL2.f90,v 2.53 2001/09/19 23:43:49 livesey Exp $"
d105 2
d358 2
d369 2
d380 1
d430 3
@


2.53
log
@Added --snoop option
@
text
@d13 4
a16 2
  & QUIT_ERROR_THRESHOLD, TOOLKIT, CREATEMETADATA, &
  & PENALTY_FOR_NO_METADATA, PUNISH_FOR_INVALID_PCF, NORMAL_EXIT_STATUS
d21 1
a21 1
  use OUTPUT_M, only: OUTPUT, PRUNIT
d23 1
d25 1
d34 41
a74 2
  use PVM, only: ClearPVMArgs, NextPVMArg, FreePVMArgs
  use SnoopMLSL2, only: SNOOPINGACTIVE
d80 1
d92 1
a93 2
  logical :: COPYARG               ! Copy this argument to parallel command line
  real :: T1, T2                   ! For timing
d98 1
a98 1
     "$Id: MLSL2.f90,v 2.52 2001/07/19 22:00:09 pwagner Exp $"
d103 1
d113 1
d122 2
d195 1
a195 1
      exit
d228 13
a240 2
      exit ! Took the rest of the string, so there can't be more options
        case ( 'T' ); timing = .true.
d283 2
d307 2
d315 2
d355 2
d364 2
d373 2
d387 5
d399 3
d412 3
d423 3
@


2.52
log
@Better behaved when l2cf is stdin
@
text
@d31 1
d55 1
a55 1
     "$Id: MLSL2.f90,v 2.51 2001/07/18 23:56:24 pwagner Exp $"
d96 2
d342 3
@


2.51
log
@Gets error from close_mlscf
@
text
@d54 1
a54 1
     "$Id: MLSL2.f90,v 2.50 2001/07/18 00:16:54 pwagner Exp $"
d222 1
d339 3
@


2.50
log
@Better control over when to exit with status
@
text
@d54 1
a54 1
     "$Id: MLSL2.f90,v 2.49 2001/07/16 23:43:15 pwagner Exp $"
d249 2
a250 2
  if ( PCF_FOR_INPUT ) then
    call close_MLSCF ( inunit )
d254 5
a258 1
  if ( root <= 0 ) then
d338 3
@


2.49
log
@With settable NORMAL_EXIT_STATUS
@
text
@d54 1
a54 1
     "$Id: MLSL2.f90,v 2.48 2001/05/25 01:03:47 livesey Exp $"
d228 1
a228 1
        & "Unable to open L2CF file " // trim(line) )
d234 3
d238 1
a238 1
        & "Unable to open L2CF file " // trim(line) )
d241 1
d243 5
a247 1
  call configuration ( root )
d258 1
d297 3
a299 1
  if(NORMAL_EXIT_STATUS /= 0 .and. .not. parallel%slave) then
d334 3
@


2.48
log
@Working parallel version
@
text
@d14 1
a14 1
  & PENALTY_FOR_NO_METADATA, PUNISH_FOR_INVALID_PCF
d16 1
a16 1
    & MLSMSG_Error, MLSMSG_Severity_to_quit
d54 1
a54 1
     "$Id: MLSL2.f90,v 2.47 2001/05/23 23:21:51 pwagner Exp $"
d288 5
d323 3
@


2.47
log
@Did the same for options, switches
@
text
@d54 1
a54 1
     "$Id: MLSL2.f90,v 2.46 2001/05/23 22:31:30 pwagner Exp $"
d81 1
a81 1
      call NextPVMArg(trim(line))
d114 1
a114 1
        call NextPVMArg(trim(word))
d133 1
a133 1
        call NextPVMArg(trim(line))
d188 1
a188 1
      call NextPVMArg(trim(line))
d192 1
a192 1
    if ( copyArg ) call NextPVMArg(trim(line))
d318 3
@


2.46
log
@Automatically updates based on notes/switches
@
text
@d54 1
a54 1
     "$Id: MLSL2.f90,v 2.45 2001/05/23 21:59:43 livesey Exp $"
a301 20
    print *, '  C => SpectroscopyCatalog'
    print *, '  F => FilterShapes'
    print *, '  O => Open_init'
    print *, '  P => PointingGrids'
    print *, '  S => MLSSignals'
    print *, '  V => VGrids (in globalSettings)'
    print *, ' '
    print *, '  fac => Factors of normal equations during retriever iterations'
    print *, '  glo => Global settings'
    print *, '  jac => Jacobian during retriever iterations'
    print *, '  log => Log file messages'
    print *, '  mas => Activities of the PVM master task'
    print *, '  neq => Normal equations during retriever iterations'
    print *, '  nwt => Action flag at each return from Newton solver'
    print *, '  pro => Product files: l2gp, l2aux, l2dgg, l2pc, meta'
    print *, '  rad => Radiances in ForwardModelInterface'
    print *, '  sca => Scalars of interest to the Newton method'
    print *, '  slv => Output from slave processes (using pvmfcatchout)'
    print *, '  spa => Sparsity structure of fac, jac, neq'
    print *, '  tps => Test_Parse_Signals'
d310 1
d312 1
a312 55
    print *, '  -a: Dump the decorated type-checked abstract syntax tree.'
    print *, '  -c: Trace expression evaluation and tree decoration.'
    print *, '  -d: Dump the declaration table after type checking'
    print *, '  -f[digit]: Trace Forward model.  Bigger digit means ', &
      &                    'more output.'
    print *, '  -g[digit]: Trace "generation".  Bigger digit means ', &
      &                    'more output.'
    print *, '  -h or -H or -?: This output.'
    print *, '  -l: Trace lexical analysis.'
    print *, '  -K: Capitalize identifiers.'
    print *, "  -k: Don't capitalize identifiers."
    print *, '  -M: Send output through MLSMessage.'
    print *, "  -m: Don't send output through MLSMessage."
    print *, '  -p: Trace parsing.'
    print *, '  -Sstring: Set "switches" = "string".  Characters in'
    print *, '            "string" may control individual outputs.  If -S is'
    print *, '            specified several times, the strings are concatenated.'
    print *, '     (For specific strings and their effects, use -S"?")'
    print *, '  -T: Time parsing, type checking and processing separately.'
    print *, '  -t: Trace declaration table construction.'
    print *, '  -v: List the configuration file.'
    print *, '  The above options can be concatenated after one hyphen,'
    print *, '  except that -S takes the rest of the option as its ', &
      &         '"string".'
    print *, '  --[n]cfpcf: Open the L2CF [without] using the Toolkit ', &
      &        'and the PCF.'
    if ( pcf_for_input ) then
      print *, '    --ncfpcf assumed if L2CF-name is present.  ', &
        &      'Default: --cfpcf'
    else
      print *, '    --ncfpcf assumed if L2CF-name is present.  ', &
        &      'Default: --ncfpcf'
    end if
    print *, '  --[n]kit: Output error messages [not] using the SDP Toolkit'
!    print *, '  --[n]echo: [Do not]Echo logged error messages to stdout'
!    print *, '  --[n]global: [Do not]Show global settings in log'
    print *, '  --[n]meta: [Do not] Create metadata files.'
    print *, '  --[n]pcf: [Do not] Use the PCF for file names, parameters, etc.'
    print *, '    (--npcf sets --nmeta and --ncfpcf.)'
    print *, '  --[n]tk: [Do not] Use the panoply of the PGS_toolkit'
    print *, '    (--ntk sets --npcf, --ncfpcf and --nmeta).'
    print *, '  --master <filename>: This is the master task in a PVM setup'
    print *, '    filename contains simply ascii list of slave host names'
    print *, '    can list a machine more than once (e.g. for SMP slaves)'
    print *, '  --slave[ ]<master-tid>: This is a slave; <master-tid>'
    print *, '    is the id of the master.  This option is set by a master'
    print *, '    task and is not recommneded for manual invocations.'
    print *, '  Options a, c, f0, g0, l, p and t can be toggled in the ', &
      &        'configuration file'
    print *, '  by @@A, @@C, @@E, @@G, @@L, @@P and @@S respectively.  @@L and ', &
      &        '@@P are processed'
    print *, '  synchronously with the input.  The others are ', &
      &         'examined later.'
    print *, '  @@T in the configuration file dumps the string table ', &
      &         'at that instant.'
d318 3
@


2.45
log
@Interim version, almost there
@
text
@d54 1
a54 1
     "$Id: MLSL2.f90,v 2.44 2001/05/23 01:44:24 livesey Exp $"
d300 1
d322 1
d391 3
@


2.44
log
@Parallel code starting to fit into place
@
text
@d1 1
d8 1
a8 1
  use L2PARALLEL, only: PARALLEL, INITPARALLEL
d54 1
a54 1
     "$Id: MLSL2.f90,v 2.43 2001/05/18 01:14:21 vsnyder Exp $"
d312 1
a312 1
    print *, '  pro => Product files: l2gp, l2aux, l2dgg, l2pc, meta'
d315 1
d318 1
d389 3
@


2.43
log
@Add a 'stop' in 'switch_usage', plus cosmetic changes
@
text
@d7 1
a7 1
  use L2PARALLEL, only: PARALLEL
d29 1
d47 1
d49 1
d53 1
a53 1
     "$Id: MLSL2.f90,v 2.42 2001/05/17 22:34:55 pwagner Exp $"
d58 1
d62 4
d73 1
d76 1
d80 2
a81 1
  cycle
d101 1
d103 11
d115 1
d123 2
a124 1
        read ( line(8:), *, iostat=status ) parallel%masterTid
d132 2
a133 1
  exit
d187 2
a188 1
  exit
d191 1
d286 1
d367 3
a369 1
    print *, '  --master: This is the master task in a PVM setup'
d386 3
@


2.42
log
@output and MLSMessage modules cooperate better w/o toolkit; switch_usage
@
text
@d50 1
a50 1
     "$Id: MLSL2.f90,v 2.41 2001/05/15 23:46:07 pwagner Exp $"
d168 1
a168 1
  endif
d175 1
a175 1
   endif
d181 1
a181 1
   endif
d237 1
a237 1
   endif
d289 1
d355 3
@


2.41
log
@Removed 2 settings from MLSL2Opts; now in switches
@
text
@d50 1
a50 1
     "$Id: MLSL2.f90,v 2.40 2001/05/11 23:47:00 pwagner Exp $"
d166 3
d172 6
a177 1
   if( index(switches, 'log') /= 0 ) then
a182 6
   if ( .not. toolkit ) then
      pcf = .false.
      OUTPUT_PRINT_UNIT = max(-1, OUTPUT_PRINT_UNIT)   ! stdout or Fortran unit
      prunit = OUTPUT_PRINT_UNIT
   endif

d267 24
d313 1
d354 3
@


2.40
log
@(Re)Sets prunit depending on toolkit
@
text
@d13 1
a13 2
  & PENALTY_FOR_NO_METADATA, PUNISH_FOR_INVALID_PCF, ECHO_GLOBAL_STNGS, &
  & LOG_TO_STDOUT
d50 1
a50 1
     "$Id: MLSL2.f90,v 2.39 2001/05/11 17:34:31 vsnyder Exp $"
a82 4
      else if ( line(3+n:7+n) == 'echo ' ) then
        LOG_TO_STDOUT = switch
      else if ( line(3+n:9+n) == 'global ' ) then
        ECHO_GLOBAL_STNGS = switch
d169 2
a170 2
   if( LOG_TO_STDOUT ) then
!   MLSMessageConfig%LogFileUnit = -1     ! the default in MLSMessageModule
d172 1
a172 1
      MLSMessageConfig%LogFileUnit = -2
d303 2
a304 2
    print *, '  --[n]echo: [Do not]Echo logged error messages to stdout'
    print *, '  --[n]global: [Do not]Show global settings in log'
d327 3
@


2.39
log
@Improve built-in usage display
@
text
@d51 1
a51 1
     "$Id: MLSL2.f90,v 2.38 2001/05/09 23:33:00 pwagner Exp $"
d180 5
a184 1
   if ( .not. toolkit ) pcf = .false.
d332 3
@


2.38
log
@Sets new MLSL2Options
@
text
@d51 1
a51 1
     "$Id: MLSL2.f90,v 2.37 2001/05/08 20:33:41 vsnyder Exp $"
d155 1
a155 1
          switches = line(j+1:)
d286 2
a287 1
    print *, '            "string" may control individual outputs.'
d328 3
@


2.37
log
@Moved usage display into a subroutine
@
text
@d13 2
a14 1
  & PENALTY_FOR_NO_METADATA, PUNISH_FOR_INVALID_PCF
d51 1
a51 1
     "$Id: MLSL2.f90,v 2.36 2001/05/07 23:30:51 pwagner Exp $"
d84 4
d174 5
a178 1
   UseSDPToolkit = toolkit    ! Redundant, but may be needed in lib
d182 2
d303 2
d327 3
@


2.36
log
@Sets USESDPToolkit
@
text
@d50 1
a50 1
     "$Id: MLSL2.f90,v 2.35 2001/05/07 21:53:28 vsnyder Exp $"
d147 1
d272 1
d314 3
@


2.35
log
@Improve built-in usage display
@
text
@d20 1
d50 1
a50 1
     "$Id: MLSL2.f90,v 2.34 2001/05/07 21:05:03 vsnyder Exp $"
d168 2
d312 3
@


2.34
log
@Separated '[n]pcf' and [n]cfpcf'
@
text
@d40 1
d43 1
d49 1
a49 1
     "$Id: MLSL2.f90,v 2.33 2001/05/07 18:16:11 vsnyder Exp $"
d72 17
a88 21
      if ( line(3:8) == 'cfpcf ' ) then
        pcf_for_input = .true.
      else if ( line(3:9) == 'ncfpcf ' ) then
        pcf_for_input = .false.
      else if ( line(3:6) == 'kit ' ) then
        MLSMessageConfig%useToolkit = .true.
      else if ( line(3:6) == 'nkit ' ) then
        MLSMessageConfig%useToolkit = .false.
      else if ( line(3:7) == 'meta ' ) then
        createMetadata = .true.
      else if ( line(3:8) == 'nmeta ' ) then
        createMetadata = .false.
      else if ( line(3:6) == 'pcf ' ) then
        pcf = .true.
      else if ( line(3:7) == 'npcf ' ) then
        pcf = .false.
      else if ( line(3:5) == 'tk ' ) then
        toolkit = .true.
      else if ( line(3:6) == 'ntk ' ) then
        toolkit = .false.
      else if ( line(3:9) == 'master ' ) then
d90 1
a90 1
      else if ( line(3:7) == 'slave' ) then
d92 2
a93 2
        if ( line(8:) /= ' ' ) then
          line(:7) = ' '
d109 1
d141 1
a141 51
          call getarg ( 0+hp, line )
          print *, 'Usage: ', trim(line), ' [options] [--] [L2CF-name]'
          print *, ' Options:'
          print *, '  -A: Dump the un-decorated abstract syntax tree.'
          print *, '  -a: Dump the decorated type-checked abstract syntax tree.'
          print *, '  -c: Trace expression evaluation and tree decoration.'
          print *, '  -d: Dump the declaration table after type checking'
          print *, '  -f[digit]: Trace Forward model.  Bigger digit means ', &
            &                    'more output.'
          print *, '  -g[digit]: Trace "generation".  Bigger digit means ', &
            &                    'more output.'
          print *, '  -l: Trace lexical analysis.'
          print *, '  -K: Capitalize identifiers.'
          print *, "  -k: Don't capitalize identifiers."
          print *, '  -M: Send output through MLSMessage.'
          print *, '  -p: Trace parsing.'
          print *, '  -Sstring: Set "switches" = "string".  Characters in'
          print *, '            "string" may control individual outputs.'
          print *, '  -T: Time parsing, type checking and processing separately.'
          print *, '  -t: Trace declaration table construction.'
          print *, '  -v: List the configuration file.'
          print *, '  The above options can be concatenated after one hyphen,'
          print *, '  except that -S takes the rest of the option as its ', &
            &         '"string".'
          print *, '  --[n]cfpcf: Open the L2CF [without] using the Toolkit ', &
            &        'and the PCF.'
          if ( pcf_for_input ) then
            print *, '    --ncfpcf assumed if L2CF-name is present.  ', &
              &      'Default: --cfpcf'
          else
            print *, '    --ncfpcf assumed if L2CF-name is present.  ', &
              &      'Default: --ncfpcf'
          end if
          print *, '  --[n]kit: Output error messages [not] using the SDP Toolkit'
          print *, '  --[n]meta: [Do not] Create metadata files.'
          print *, '  --[n]pcf: [Do not] Use the PCF for file names, parameters, etc.'
          print *, '  --[n]tk: [Do not] Use the panoply of the PGS_toolkit'
          print *, '    (--ntk automatically sets --npcf and --nmeta).'
          print *, '  --master: This is the master task in a PVM setup'
          print *, '  --slave[ ]<master-tid>: This is a slave; <master-tid>'
          print *, '    is the id of the master.  This option is set by a master'
          print *, '    task and is not recommneded for manual invocations.'
          print *, '  Options a, c, f0, g0, l, p and t can be toggled in the ', &
            &        'configuration file'
          print *, '  by @@A, @@C, @@E, @@G, @@L, @@P and @@S respectively.  @@L and ', &
            &        '@@P are processed'
          print *, '  synchronously with the input.  The others are ', &
            &         'examined later.'
          print *, '  @@T in the configuration file dumps the string table ', &
            &         'at that instant.'
          stop
d155 1
d250 56
d309 3
@


2.33
log
@Added "do [not] output MLSMessage messages through the toolkit" option.
Resolved conflicts on merge.
@
text
@d47 1
a47 1
     "$Id: MLSL2.f90,v 2.32 2001/05/07 17:17:31 pwagner Exp $"
d70 5
a74 1
      if ( line(3:6) == 'kit ' ) then
d166 1
a166 3
          print *, '  --[n]kit: Output error messages [not] using the SDP Toolkit'
          print *, '  --[n]meta: [Do not] Create metadata files.'
          print *, '  --[n]pcf: Open the L2CF [without] using the Toolkit ', &
d168 3
a170 3
          if ( pcf ) then
            print *, '    --npcf assumed if L2CF-name is present.  ', &
              &      'Default: --pcf'
d172 2
a173 2
            print *, '    --npcf assumed if L2CF-name is present.  ', &
              &      'Default: --npcf'
d175 3
d236 1
a236 1
  else if ( PCF_FOR_INPUT ) then
d303 4
@


2.32
log
@Calls MLSMessage to exit with error if check_tree fails
@
text
@d14 2
a15 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Debug, &
  & MLSMSG_Severity_to_quit
d47 1
a47 1
     "$Id: MLSL2.f90,v 2.31 2001/05/04 22:55:36 pwagner Exp $"
d70 16
a85 2
      if ( line(3:6) == 'pcf ' ) then
        PCF_FOR_INPUT = .true.
a100 10
      else if ( line(3:7) == 'npcf ' ) then
        PCF_FOR_INPUT = .false.
      else if ( line(3:5) == 'tk ' ) then
        TOOLKIT = .true.
      else if ( line(3:6) == 'ntk ' ) then
        TOOLKIT = .false.
      else if ( line(3:7) == 'meta ' ) then
        CREATEMETADATA = .true.
      else if ( line(3:8) == 'nmeta ' ) then
        CREATEMETADATA = .false.
d146 1
a146 1
            &                    'more output.  @@E in the CF does -f0.'
d162 2
a163 4
          print *, '  --master: This is the master task in a pvm setup'
          print *, '  --slave[ ]<master-tid>: This is a slave, <master-tid>'
          print *, '    is the id of the master.  This option is set by a master'
          print *, '    task and is not recommneded for manual invocations.'
a165 3
          print *, '  --[n]meta: [Do not]Create metadata files.'
          print *, '  --[n]tk: [Do not]Use the panoply of the PGS_ toolkit.  ', &
            &        '(ntk automatically sets npcf and nmeta)'
d173 7
a179 1
          print *, '  Options a, c, g1, l, p and t can be toggled in the ', &
d181 1
a181 1
          print *, '  by @@A, @@C, @@G, @@L, @@P and @@S respectively.  @@L and ', &
a210 3
   if ( .not. TOOLKIT) then
      PCF = .false.
   endif
d212 9
a220 6
   if ( .not. PCF) then
      PCF_FOR_INPUT = .false.
      PUNISH_FOR_INVALID_PCF = .false.
      CREATEMETADATA = .false.
      PENALTY_FOR_NO_METADATA = 0
   endif
d298 3
@


2.31
log
@Added cascading negatives; new command line options
@
text
@d47 1
a47 1
     "$Id: MLSL2.f90,v 2.30 2001/05/03 01:58:52 vsnyder Exp $"
d258 4
d293 3
@


2.30
log
@Add error checking for --slave option
@
text
@d11 3
a13 1
  use MLSL2Options, only: PCF, OUTPUT_PRINT_UNIT, QUIT_ERROR_THRESHOLD
a17 1
! use Open_Init, only: Close_MLSCF, Open_MLSCF !!! Enormous compile time !!!
a39 1
!  logical :: PCF = .false.         ! Open L2CF using PCF
d47 1
a47 1
     "$Id: MLSL2.f90,v 2.29 2001/05/02 23:22:48 livesey Exp $"
d71 1
a71 1
        pcf = .true.
d88 9
a96 1
        pcf = .false.
d164 3
d204 12
d226 1
a226 1
  else if ( pcf ) then
d236 1
a236 1
  if ( pcf ) then
d289 3
d323 1
a323 1
! Gets PCF flag from MLSL2Options
@


2.29
log
@Added parallel stuff
@
text
@d47 1
a47 1
     "$Id: MLSL2.f90,v 2.28 2001/05/01 17:51:47 vsnyder Exp $"
d75 12
a86 2
        parallel%slave = .true. 
        read ( line(8:), * ) parallel%masterTid
d151 3
a153 4
          print *, '  --slave<master-tid>: This is a slave, <master-tid>'
          print *, '  is the id of the master, note there is no space between these.'
          print *, '  This option is set by a master task and not recommneded'
          print *, '  for manual invocations.'
d266 3
@


2.28
log
@Ignore Lahey/Fujitsu run-time library's command-line arguments
@
text
@d7 1
d47 1
a47 1
     "$Id: MLSL2.f90,v 2.27 2001/04/28 01:44:47 vsnyder Exp $"
d72 5
d140 5
d257 3
@


2.27
log
@Provide to set levels(emit)
@
text
@d46 1
a46 1
     "$Id: MLSL2.f90,v 2.26 2001/04/27 20:59:16 vsnyder Exp $"
d64 4
a90 8
        case ( 'e' )
          toggle(emit) = .true.
          if ( j < len(line) ) then
            if ( line(j+1:j+1) >= '0' .and. line(j+1:j+1) <= '9' ) then
              j = j + 1
              levels(emit) = ichar(line(j:j)) - ichar('0')
            end if
          end if
a116 2
          print *, '  -e[digit]: Turn on the "emit" toggle.  Bigger digit means ', &
            &                    'more output.'
d118 1
a118 1
            &                    'more output.'
d246 3
@


2.26
log
@Change -G option to -S
@
text
@d46 1
a46 1
     "$Id: MLSL2.f90,v 2.25 2001/04/26 02:44:17 vsnyder Exp $"
d87 8
a94 1
        case ( 'e' ); toggle(emit) = .true.
d121 2
a122 1
          print *, '  -e: Turn on the "emit" toggle'
d252 3
@


2.25
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d46 1
a46 1
     "$Id: MLSL2.f90,v 2.24 2001/04/24 23:04:42 vsnyder Exp $"
a105 4
        case ( 'G' )
          toggle(gen) = .true.
          switches = line(j+1:)
      exit
a118 2
          print *, '  -Gstring: Trace "generation".  Characters in "string" '
          print *, '            may control individual outputs.'
d124 2
d130 1
a130 1
          print *, '  except that -G takes the rest of the option as its ', &
d155 3
d244 3
@


2.24
log
@Add -f[digit] to set toggle(emit) and levels(emit)
@
text
@d6 1
a6 1
  use INIT_TABLES_MODULE, only: INIT_TABLES, LIT_INDICES
a25 1
  use UNITS, only: INIT_UNITS
d46 1
a46 1
     "$Id: MLSL2.f90,v 2.23 2001/04/21 01:44:05 vsnyder Exp $"
a59 1
  call init_units ( lit_indices )
d245 3
@


2.23
log
@Make the timing message prettier
@
text
@d47 1
a47 1
     "$Id: MLSL2.f90,v 2.22 2001/04/21 01:42:21 vsnyder Exp $"
d90 9
d121 2
d247 3
@


2.22
log
@Add -T option for timing
@
text
@d47 1
a47 1
     "$Id: MLSL2.f90,v 2.21 2001/04/20 20:44:18 pwagner Exp $"
d230 1
a230 1
    call output ( "Timing for " // what // " =" )
d236 3
@


2.21
log
@Sets MLSMSG_Severity_to_quit
@
text
@d5 1
a5 1
  use DECLARATION_TABLE, only: ALLOCATE_DECL, DUMP_DECL
d18 3
a20 1
  use STRING_TABLE, only: DO_LISTING, INUNIT
d23 1
a23 1
  use TREE, only: ALLOCATE_TREE, PRINT_SUBTREE
d42 2
d46 4
a49 3
  CHARACTER(LEN=130) :: Id = & 
     "$Id: MLSL2.f90,v 2.20 2001/04/17 22:08:56 pwagner Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: MLSL2.f90,v $"
d121 1
d150 1
d178 1
a178 1
    endif
d180 1
d182 1
d203 1
d205 1
d214 1
d216 1
d219 14
d236 3
@


2.20
log
@Sets prunit according to OUTPUT_PRINT_UNIT
@
text
@d10 3
a12 2
  use MLSL2Options, only: PCF, OUTPUT_PRINT_UNIT
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d43 1
a43 1
     "$Id: MLSL2.f90,v 2.19 2001/04/16 23:46:58 pwagner Exp $"
d47 1
a47 1
! Where to send output
d49 1
d209 3
@


2.19
log
@Gets PCF flag from MLSL2Options
@
text
@d10 1
a10 1
  use MLSL2Options, only: PCF
d42 1
a42 1
     "$Id: MLSL2.f90,v 2.18 2001/04/06 20:11:53 vsnyder Exp $"
d46 3
d207 3
@


2.18
log
@Add -e option
@
text
@d10 1
d36 1
a36 1
  logical :: PCF = .false.         ! Open L2CF using PCF
d42 1
a42 1
     "$Id: MLSL2.f90,v 2.17 2001/04/05 01:33:46 vsnyder Exp $"
d162 5
a166 1
    call open_MLSCF ( MLSPCF_L2CF_Start, inunit )
d204 3
@


2.17
log
@Increase initial sizes for sevaral paraer tables
@
text
@d17 2
a18 1
  use TOGGLES, only: CON, GEN, LEVELS, LEX, PAR, SYN, SWITCHES, TAB, TOGGLE
d41 1
a41 1
     "$Id: MLSL2.f90,v 2.16 2001/03/28 01:29:48 vsnyder Exp $"
d78 1
d100 1
d199 3
@


2.16
log
@Add description of -G to -h output
@
text
@d40 1
a40 1
     "$Id: MLSL2.f90,v 2.15 2001/03/16 21:47:57 vsnyder Exp $"
d45 1
a45 1
  call init_lexer ( n_chars=10000, n_symbols=1000, hash_table_size=1003 )
d47 1
a47 1
  call allocate_tree ( n_tree=10000 )
d196 3
@


2.15
log
@Add -G option
@
text
@d40 1
a40 1
     "$Id: MLSL2.f90,v 2.14 2001/03/14 18:59:03 vsnyder Exp $"
d100 2
a101 2
          print *, '  -Gstring: Trace "generation".  Characters in "string" ', &
            &                   ' may control individual outputs.'
d196 3
@


2.14
log
@Add K and k options to control whether the lexer capitalizes identifiers
@
text
@d17 1
a17 1
  use TOGGLES, only: CON, GEN, LEVELS, LEX, PAR, SYN, TAB, TOGGLE
d40 1
a40 1
     "$Id: MLSL2.f90,v 2.13 2001/03/08 00:39:37 vsnyder Exp $"
d79 1
d86 4
d100 2
d109 3
a111 1
          print *, '  The above options can be concatenated after one hyphen.'
d196 3
@


2.13
log
@Improve some debugging output
@
text
@d8 1
d40 1
a40 1
     "$Id: MLSL2.f90,v 2.12 2001/03/02 02:38:17 vsnyder Exp $"
d73 4
a76 8
        case ( 'A' )
          dump_tree = .true.
        case ( 'a' )
          toggle(syn) = .true.
        case ( 'c' )
          toggle(con) = .true.
        case ( 'd' )
          do_dump = .true.
d94 1
a94 1
          &                      'more output.'
d96 2
d104 1
a104 1
          &          'and the PCF.'
d107 1
a107 1
            &        'Default: --pcf'
d110 1
a110 1
            &        'Default: --npcf'
d113 1
a113 1
          &          'configuration file'
d115 1
a115 1
          &          '@@P are processed'
d117 1
a117 1
          &           'examined later.'
d119 1
a119 1
          &           'at that instant.'
d121 7
a127 10
        case ( 'l' )
          toggle(lex) = .true.
        case ( 'M' )
          prunit = -2
        case ( 'p' )
          toggle(par) = .true.
        case ( 't' )
          toggle(tab) = .true.
        case ( 'v' )
          do_listing = .true.
d187 3
@


2.12
log
@Expand LINE, alphabetize USEs
@
text
@d39 1
a39 1
     "$Id: MLSL2.f90,v 2.11 2001/02/28 03:01:48 vsnyder Exp $"
d170 1
a170 1
      call output ( 'End un-type-checked abstract syntax tree:', &
d191 3
@


2.11
log
@Make presence of L2CF-name on command line take precedence over --[n]pcf
@
text
@a8 1
  use OBTAIN_MLSCF, only: Close_MLSCF, Open_MLSCF
d11 1
d32 1
a32 1
  character(len=80) :: LINE        ! Into which is read the command args
d39 1
a39 1
     "$Id: MLSL2.f90,v 2.10 2001/02/28 02:52:32 vsnyder Exp $"
d191 3
@


2.10
log
@Improve usage description
@
text
@d24 1
a24 1
  integer, parameter :: L2CF_UNIT = 20  ! Unit # if L2CF is read by Fortran
d39 1
a39 1
     "$Id: MLSL2.f90,v 2.9 2001/02/28 02:44:24 vsnyder Exp $"
d88 1
a88 1
        case ( 'h', 'H', '?' )
d107 2
a108 1
            print *, '            Default: --pcf'
d110 2
a111 1
            print *, '            Default: --npcf'
d143 1
a143 3
  if ( pcf ) then
    call open_MLSCF ( MLSPCF_L2CF_Start, inunit )
  else if ( line /= ' ' ) then
d152 2
d191 3
@


2.9
log
@Identify abstract syntax tree dumps, show default --[n]pcf in usage
@
text
@d39 1
a39 1
     "$Id: MLSL2.f90,v 2.8 2001/02/28 01:59:29 vsnyder Exp $"
a111 2
          &          'configuration file by'
          print *, '  @@A, @@C, @@G, @@L, @@P and @@S respectively.  @@T in the ', &
d113 6
a118 1
          print *, '  dumps the string table at that instant.'
d189 3
@


2.8
log
@Access Open_MLSCF and Close_MLSCF from Obtain_MLSCF instead of Open_Init
@
text
@d39 1
a39 1
     "$Id: MLSL2.f90,v 2.7 2001/02/23 02:39:56 vsnyder Exp $"
d161 7
a167 1
    if ( dump_tree ) call print_subtree ( root, 0 )
d174 1
a174 1
      call output ( 'Begin abstract syntax tree:', advance='yes' )
d176 1
a176 1
      call output ( 'End abstract syntax tree', advance='yes' )
d186 3
@


2.7
log
@Add description of --pcf option to usage instructions.
@
text
@d9 1
d11 2
a13 1
  use Open_Init, only: CloseMLSCF, OpenMLSCF
d39 1
a39 1
     "$Id: MLSL2.f90,v 2.6 2001/02/23 02:38:34 vsnyder Exp $"
d56 2
d104 7
a110 1
          print *, '  --pcf: Open the L2CF using the Toolkit and the PCF.'
d139 1
a139 1
    call openMLSCF
d152 1
a152 1
    call closeMLSCF
d154 1
a154 1
    close ( l2cf_unit )  ! Don't worry about the status
d180 3
@


2.6
log
@Open L2CF either by PCF or by Fortran OPEN or expect it on stdin
@
text
@d37 1
a37 1
     "$Id: MLSL2.f90,v 2.5 2001/02/22 23:51:00 vsnyder Exp $"
d100 1
d170 3
@


2.5
log
@Improved usage messages
@
text
@d9 1
d11 1
a11 1
! use Open_Init, only: CloseMLSCF, OpenMLSCF
d13 1
a13 1
  use STRING_TABLE, only: DO_LISTING
d22 2
d31 1
d33 1
d37 1
a37 1
     "$Id: MLSL2.f90,v 2.4 2001/02/22 23:05:12 vsnyder Exp $"
d51 11
a61 1
    if ( line(1:1) == '-' ) then
d66 2
d86 1
a86 1
          print *, 'Usage: ', trim(line), ' [options]'
d99 1
d116 2
d127 12
a138 1
! call openMLSCF
d140 5
a144 1
! call closeMLSCF
d169 3
@


2.4
log
@Display usage if -h, -H or -? option is present.
@
text
@d32 1
a32 1
     "$Id: MLSL2.f90,v 2.3 2000/10/12 00:33:47 vsnyder Exp $"
d71 3
a73 3
          print *, '  -A: Dump the un-decorated abstract syntax tree'
          print *, '  -a: Dump the decorated type-checked abstract syntax tree'
          print *, '  -c: Trace expression evaluation and tree decoration'
d76 6
a81 6
          &                      'more output'
          print *, '  -l: Trace lexical analysis'
          print *, '  -M: Send output through MLSMessage'
          print *, '  -p: Trace parsing'
          print *, '  -t: Trace declaration table construction'
          print *, '  -v: List the configuration file'
d134 3
@


2.3
log
@Insert CVS variables and copyright notice
@
text
@d9 1
a9 1
  use OUTPUT_M, only: OUTPUT
d32 2
a33 2
     "$Id: obtainncep.f90,v 2.0 2000/09/05 18:57:06 ahanzel Exp $"
  CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: obtainncep.f90,v $"
d50 6
a55 1
        if ( line(j:j) == 'c' ) then
d57 3
a59 1
        else if ( line(j:j) == 'g' ) then
d67 22
a88 1
        else if ( line(j:j) == 'l' ) then
d90 3
a92 1
        else if ( line(j:j) == 'p' ) then
d94 1
a94 7
        else if ( line(j:j) == 'a' ) then
          toggle(syn) = .true.
        else if ( line(j:j) == 'A' ) then
          dump_tree = .true.
        else if ( line(j:j) == 'd' ) then
          do_dump = .true.
        else if ( line(j:j) == 't' ) then
d96 1
a96 1
        else if ( line(j:j) == 'v' ) then
d98 1
a98 1
        end if
a126 2
      if ( do_dump ) call dump_decl

d133 4
a136 1
! $Log: $
@


2.2
log
@Account for changed usage of init_tables
@
text
@d1 3
d30 6
d110 2
@


2.1
log
@Revised to use the tree output by the parser
@
text
@d3 1
a3 1
  use INIT_TABLES_MODULE, only: INIT_TABLES
d32 1
a32 1
  call init_units
@


2.0
log
@Changing file revision to 2.0.
@
text
@d1 100
a100 153
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

!============================================================================
PROGRAM MLSL2                   ! MLS Level 2 software
!============================================================================

  ! External modules

  USE MLSCommon
  USE MLSMessageModule
  USE L2GPData
  USE L2AUXData
  USE QuantityTemplates
  USE VectorsModule
  USE MLSCF
  USE OpenInit
  USE ScanDivide
  USE Construct
  USE Fill
  USE Join
  USE OutputAndClose

  IMPLICIT NONE

  !--------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=130) :: Id = &
       "$Id: MLSL2.f90,v 1.16 2000/06/29 23:55:35 lungu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: MLSL2.f90,v $"
  !--------------------------------------------------------------------------

  ! This is the Level 2 processing software for the EOS Microwave Limb Sounder.
  ! For more information see:

  ! EOS MLS Retrieval Processes Algorithm Theoretical Basis Document
  !   JPL D-16159
  ! Functional Requirements for the EOS MLS Level 2 software
  !   JPL D-18027
  ! EOS MLS Level 2 file description document
  !   JPL D-18028
  ! EOS MLS Level 2 software users' guide
  !   JPL D-18029
  ! Design of the EOS MLS Level 2 software for version 0.1
  !   JPL D-18030.

  !--------------------------------------------------------------------------

  ! Local parameters

  !--------------------------------------------------------------------------

  ! Local variables roughly ordered increasing triviality

  TYPE (TAI93_Range_T) :: processingRange ! Data processing range
  TYPE (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
  TYPE (MLSCF_T) :: l2cf        ! The information from the l2cf file
  TYPE (GriddedData_T), DIMENSION(:), POINTER :: aprioriData 
  ! Input a priori database
  TYPE (MLSChunk_T), DIMENSION(:), POINTER :: chunks ! Chunks for data

  TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: qtyTemplates
  TYPE (QuantityTemplate_T), DIMENSION(:), POINTER :: mifGeolocation
  TYPE (VectorTemplate_T), DIMENSION(:), POINTER :: vectorTemplates
  TYPE (Vector_T), DIMENSION(:), POINTER :: vectors

  TYPE (L2GPData_T), DIMENSION(:), POINTER :: l2gpDatabase ! L2GP products
  TYPE (L2AUXData_T), DIMENSION(:), POINTER :: l2auxDatabase ! L2AUX products

  INTEGER :: chunkNo,instrumentModule, n            ! Loop counter
  CHARACTER (LEN=132) :: message ! Line of message output

  !--------------------------------------------------------------------------

  ! Executable code


  CALL MLSMessage(MLSMSG_Info,ModuleName, &
       & "EOS MLS Level 2 data processing commenced")

  ! Before we do anything we nullify the database pointers.  This is needed
  ! because apparently f90 does not set pointers to .not. associated when
  ! they are first created.

  NULLIFY (aprioriData,chunks,qtyTemplates,mifGeolocation,vectorTemplates,&
       & vectors,l2gpDatabase,l2auxDatabase)

  ! The first thing to do is to open the input Level 1 files, l2cf files and do
  ! other initialization stuff.


  CALL OpenAndInitialize(processingRange, l1bInfo, l2cf, &
       & aprioriData)

  ! The next stage is to divide the input L1B dataset into chunks.

  CALL ScanAndDivide(processingRange, l1bInfo, l2cf, chunks)
  ! Now we loop over the chunks and do the data processing

  n= SIZE(chunks)
  DO chunkNo=1,n
     WRITE (UNIT=message,FMT=*) "Processing chunk #",chunkNo
     CALL MLSMessage(MLSMSG_Info,ModuleName,TRIM(message))
     ! This will need to change a lot in 0.5 and above
     ! First construct the vector quantity templates and vector templates

     CALL MLSL2Construct(l2cf,l1bInfo,chunks(chunkNo),qtyTemplates, &
          & vectorTemplates,mifGeolocation)

     ! Now fill those templates with the a priori and/or l1b data
     CALL MLSL2Fill(l2cf,l1bInfo,aprioriData, vectorTemplates, vectors)

     ! In later versions there will be retrieve etc. and also repeats, but for
     ! the moment we'll leave it at this.

     CALL MLSL2Join(l2cf,vectors,l2gpDatabase,l2auxDatabase,chunks,chunkNo)
     ! At the end of each chunk, destroy the vectorTemplate and vector
     ! information.

     CALL DestroyVectorDatabase(vectors)
     CALL DestroyVectorTemplateDatabase(vectorTemplates)
     CALL DestroyQuantityTemplateDatabase(qtyTemplates)
     CALL DestroyQuantityTemplateDatabase(mifGeolocation)
     CALL DestroyGridTemplateDatabase(aprioriData)
  END DO
  ! Now we write out the data
 CALL Ouput_Close(l2cf,l2gpDatabase,l2auxDatabase)
  ! Now we tidy up any remaining `pointer' data, do this in order of variable
  ! declaration above.

  ! processingRange needs no deallocation
  DEALLOCATE(l1bInfo%L1BRADIDs)
  ! CALL DestroyMLSCFInfo(l2cf) MLSCF is currently fixed arrays. 
  CALL DestroyGridTemplateDatabase(aprioriData)
  DEALLOCATE(chunks)
  ! vectors, vectorTemplates and qtyTemplates destroyed at the 
  ! end of each chunk
  CALL DestroyL2GPDatabase(l2gpDatabase)
  CALL DestroyL2AUXDatabase(l2auxDatabase)
  CALL MLSMessage(MLSMSG_Info,ModuleName, &
       & "EOS MLS Level 2 data processing ended")
   STOP
!=============================================================================
END PROGRAM MLSL2
!=============================================================================

!
! $Log: MLSL2.f90,v $
! Revision 1.16  2000/06/29 23:55:35  lungu
! Uncommented:
!   CALL DestroyL2GPDatabase(l2gpDatabase)
!   CALL DestroyL2AUXDatabase(l2auxDatabase).
!

@


1.16
log
@Uncommented:
  CALL DestroyL2GPDatabase(l2gpDatabase)
  CALL DestroyL2AUXDatabase(l2auxDatabase).
@
text
@d28 1
a28 1
       "$Id: MLSL2.f90,v 1.16 2000/06/29 23:55:35 lungu Exp $"
d148 3
d156 1
a156 47
! Revision 1.15  2000/06/19 22:21:06  lungu
! Uncommented calls to subroutines which were untested.
! Added end processing info message.
!
! Revision 1.14  2000/05/18 00:25:19  lungu
! Commented out temporarily stuff related to l2aux.
!
! Revision 1.13  2000/02/11 16:36:17  nakamura
! Removed superfluous USE MLSL2Common statement.
!
! Revision 1.12  2000/02/08 20:11:27  nakamura
! Replaced DataProcessingRange_T with TAI93_Range_T.
!
! Revision 1.11  2000/02/05 00:30:29  livesey
! Added nullify call for all databases.
!
! Revision 1.10  2000/01/21 21:04:46  livesey
! Now incorporated fill.
!
! Revision 1.9  2000/01/11 23:40:08  livesey
! This version compiles and links for the first time!
!
! Revision 1.8  2000/01/07 23:53:34  livesey
! Nearly integrated, just a few tweaks.
!
! Revision 1.7  1999/12/18 00:33:08  livesey
! Added the mifGeolocation functionality.
!
! Revision 1.6  1999/12/14 22:56:18  livesey
! Regular commit
!
! Revision 1.5  1999/12/14 04:54:50  livesey
! Minor changes, routine spelt wrong
!
! Revision 1.4  1999/12/06 21:28:55  livesey
! Quantity templates wern't getting deallocated correctly, added explicit call.
!
! Revision 1.3  1999/12/04 00:27:42  livesey
! Regular end of day checkin
!
! Revision 1.2  1999/12/03 00:14:11  livesey
! Nightly checkin
!
! Revision 1.1  1999/12/02 01:56:11  livesey
! Changed filenames to mixed case, redid makefiles.
!
!
@


