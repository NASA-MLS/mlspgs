head	2.7;
access;
symbols
	v5-02-NRT-19:2.7
	v6-00:2.6
	v5-02-NRT-18:2.6
	v5-02:2.6
	v5-01-NRT-17:2.6
	v5-01-NRT-16:2.6
	v5-01-NRT-15:2.6
	v5-01-NRT-14:2.6
	neuralnetworks-1-0:2.6.0.4
	cfm-single-freq-0-1:2.6.0.2
	v5-01:2.6
	v5-00:2.6
	v4-23-TA133:2.5.0.6
	mus-emls-1-70:2.5.0.4
	rel-1-0-englocks-work:2.5.0.2
	VUMLS1-00:2.4
	VPL1-00:2.4
	V4-22-NRT-08:2.4
	VAM1-00:2.4
	V4-21:2.4.0.2
	V4-13:2.4
	V4-12:2.3
	V4-11:2.3
	V4-10:2.3;
locks; strict;
comment	@# @;


2.7
date	2024.08.08.20.43.39;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2019.07.09.20.46.35;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2017.09.14.23.17.26;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2014.08.06.23.26.45;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2013.09.21.00.26.14;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.7
log
@s/c velocity above maxScVel means an invalid MAF now
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module ChunkDivideConfig_m

  ! This module provides ChunkDivideConfig_t, ChunkDivideConfig, and
  ! its dumpers.
  ! The main purpose is to avoid a circular dependence between
  ! ChunkDivide_m and Dump_Command.

  use Intrinsic, only: L_None, Phyq_Invalid
  use MLSKinds, only: Rp

  implicit none
  private

  public :: ChunkDivideConfig_t, Dump, Dump_Config, Dump_criticalSignals

  ! This type is filled by the l2cf and describes the configuration of the
  ! chunk division process.
  type ChunkDivideConfig_T
    integer :: method = l_none          ! See below.
    real(rp) :: maxLength = 0           ! Maximum length of chunks
    integer :: maxLengthFamily = PHYQ_Invalid ! PHYQ_Angle etc.
    integer :: noChunks = 0             ! Number of chunks for [fixed]
    real(rp) :: overlap = 0.0           ! Desired length of overlaps
    real(rp) :: lowerOverlap = 0.0      ! Desired length of lower overlaps
    real(rp) :: upperOverlap = 0.0      ! Desired length of lower overlaps
    integer :: overlapFamily = PHYQ_Invalid ! PHYQ_MAF, PHYQ_Time etc.
    integer :: lowerOverlapFamily = PHYQ_Invalid
    integer :: upperOverlapFamily = PHYQ_Invalid
    integer :: noSlaves = 0             ! Number of slave nodes [even]
    integer :: homeModule = l_none      ! Which module to consider [orbital]
    integer :: module = l_none  
    real(rp) :: homeGeodAngle = 0.0     ! Aim for one chunk to start here [orbital]
    logical   :: scanLLSet = .false.    ! True if scan lower limit should be used
    logical   :: scanULSet = .false.    ! True if scan upper limit should be used
    real(rp), dimension(2) :: scanLowerLimit ! Range for bottom of scan
    real(rp), dimension(2) :: scanUpperLimit ! Range for top of scan
    real(rp) :: maxOrbY = -1.0                 ! Maximum out of plane distance allowed <=0.0 default
    real(rp) :: maxScVel = 1000000000.         ! Maximum s/c velocity (abs val)
    character(len=128) :: criticalBands = ' ' ! Which bands must be scanning
    integer   :: criticalModules = l_none ! Which modules must be scanning
    logical   :: chooseCriticalSignals = .true. ! Use criticalModules, Bands?
    character(len=160), dimension(:), pointer &
      & :: criticalSignals => null()    ! Which signals must be on
    real(rp)  :: maxGap = 0.0           ! Length of time/MAFs/orbits allowed for gap
    integer   :: maxGapFamily = PHYQ_Invalid ! PHYQ_MAF, PHYQ_Time etc.
    logical   :: skipL1BCheck = .false. ! Don't check for l1b data probs
    logical   :: crashIfPhiNotMono = .false. ! If l1b contains non-monotonic phi
    logical   :: allowPriorOverlaps = .true. ! Use MAFs before start time
    logical   :: allowPostOverlaps = .true. ! Use MAFs after end time
    logical   :: saveObstructions = .true. ! Save obstructions for Output_Close
    logical   :: DACSDeconvolved = .true. ! Don't need to do this in level 2
    integer   :: numPriorOverlaps = 0   ! How many profiles before processingRanges
    integer   :: numPostOverlaps = 0    ! How many profiles after processingRanges
    integer   :: Where = 0              ! in the l2cf tree it was defined
  end type ChunkDivideConfig_T

  type(ChunkDivideConfig_T), public, save :: ChunkDivideConfig

  interface Dump
    module procedure Dump_config
  end interface

  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
    "$RCSfile: ChunkDivideConfig_m.f90,v $"
  private :: not_used_here
  !---------------------------------------------------------------------------

contains ! ===================================  Public Procedures  =====

  ! -------------------------------------------- Dump_Config -----
  subroutine Dump_Config ( config )

    use HighOutput, only: AddRow, AddRow_Divider, AddRow_Header, &
      & OutputTable, StartTable
    use Intrinsic, only: Lit_Indices, PHYQ_Indices
    use Lexer_core, only: Print_Source
    use MLSStrings, only: LowerCase
    use String_Table, only: Get_String
    use Tree, only: Where

    ! Args
    type(ChunkDivideConfig_T), intent(in) :: Config

    ! Executable code
    call print_source ( where(config%where), &
      & before='ChunkDivide configuration at ', advance='yes' )
    call startTable
    call addRow_header ( 'ChunkDivide configuration', 'c' )
    call addRow_divider ( '-' )
    call addRow ( 'Method                    ', trim(string_function(Config%method, 'lit')  ) )
    call addRow ( 'Max length                ', config%maxLength )
    call addRow ( 'Max length   family       ', trim(string_function(Config%maxLengthFamily, 'phy')  ) )
    
    call addRow ( 'Num chunks                ', config%noChunks )
    call addRow ( 'Overlap                   ', config%overlap )
    call addRow ( 'Overlap  family           ', trim(string_function(Config%overlapFamily, 'phy')  ) )
    call addRow ( 'Lower overlap             ', config%loweroverlap )
    call addRow ( 'Its  family               ', trim(string_function(Config%loweroverlapFamily, 'phy')  ) )
    call addRow ( 'Upper overlap             ', config%upperoverlap )
    call addRow ( 'Its  family               ', trim(string_function(Config%upperoverlapFamily, 'phy')  ) )
    call addRow ( 'Num slaves                ', config%noSlaves )
    call addRow ( 'Home Module               ', trim(string_function(Config%homeModule, 'lit')  ) )
    call addRow ( 'Home Geod Ang             ', config%homeGeodAngle )
    call addRow ( 'Set Scan Lower Limit?     ', config%ScanLLSet )
    if ( config%scanLLSet ) &
  & call addRow ( 'Bottom Scan Range         ', config%scanlowerLimit )

    call addRow ( 'Set Scan Upper Limit?     ', config%ScanULSet )
    if ( config%scanULSet ) &
  & call addRow ( 'Top Scan Range            ', config%scanUpperLimit )
    call addRow ( 'Max Out-of-plane Dist     ', config%MaxOrbY )
    call addRow ( 'Max s/c vel               ', config%MaxScVel )
    call addRow ( 'Critical Modules          ', trim(string_function(Config%criticalModules, 'lit')  ) )
    call addRow ( 'Critical Bands            ', trim(Config%criticalBands) )
    call addRow ( 'Use Crit. Modules?        ', config%chooseCriticalSignals )
    call addRow ( 'Max Gap                   ', config%MaxGap )
    call addRow ( 'Max Gap  family           ', trim(string_function(Config%maxGapFamily, 'phy')  ) )
    call addRow ( 'Skip L1B Check?           ', config%skipL1BCheck )
    call addRow ( 'Allow Prior Overlaps?     ', config%allowPriorOverlaps )
    call addRow ( 'Allow Next Day Overlaps?  ', config%allowPostOverlaps )
    call addRow ( 'Save Obstructions?        ', config%saveObstructions )
    call addRow ( 'DACS Already Deconvolved? ', config%DACSDeconvolved )
    call outputTable ( sep='|', border='-' )
    ! Critical signals?
    call Dump_criticalSignals(config%criticalSignals)
  contains
    function string_function ( arg, typ ) result ( the_string )
      ! Returns the value get_string computes
      ! Args
      integer, intent(in)           :: arg
      character(len=*), intent(in)  :: typ
      character(len=128)            :: the_string
      ! Executable
      select case (lowercase(typ(1:3)))
      case ( 'lit' )
        call Get_string ( lit_indices(arg), the_string, strip=.true. )
      case ( 'phy' )
        call Get_string ( phyq_indices(arg), the_string, strip=.true. )
      case default
        call Get_string ( arg, the_string, strip=.true. )
      end select
    end function string_function
  end subroutine Dump_Config

  ! -------------------------------------------- Dump_CriticalSignals -----
  subroutine Dump_CriticalSignals(criticalSignals)
    ! Some day we'll use the Table apis from highOutput (see Dump_Config)

    use Output_M, only: Output

    character(len=160), dimension(:), pointer &
      & :: criticalSignals       ! Which signals must be on

    ! Local variables
    integer :: i                        ! Loop counter

    ! Executable code
    if ( associated ( criticalSignals ) ) then
      if ( size(criticalSignals) == 0 ) then
        call output ( 'criticalSignals is a zero size array.', advance='yes' )
      else
        call output ( 'Dumping ' )
        call output ( size(criticalSignals) )
        call output ( ' criticalSignals:', advance='yes' )
        do i = 1, size(criticalSignals)
          call output ( i )
          call output ( ': ' )
          call output ( trim(criticalSignals(i)), advance='yes' )
        end do
      end if
    else
      call output ( 'critical Signals is not associated.', advance='yes')
    end if
  end subroutine Dump_CriticalSignals

! ===========================================  Private Procedures  =====

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ChunkDivideConfig_m.f90,v 2.6 2019/07/09 20:46:35 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ChunkDivideConfig_m

! $Log: ChunkDivideConfig_m.f90,v $
! Revision 2.6  2019/07/09 20:46:35  pwagner
! Use Table ccells to Dump_Config
!
! Revision 2.5  2017/09/14 23:17:26  pwagner
! Added module component to ChunkDivideConfig_T
!
! Revision 2.4  2014/08/06 23:26:45  vsnyder
! Remove USE for Switches and SwitchDetail, which are not referenced
!
! Revision 2.3  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.2  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.1  2013/09/21 00:26:14  vsnyder
! Initial commit; avoid circular dependence between ChunkDivide and DumpCommand
!
@


2.6
log
@Use Table ccells to Dump_Config
@
text
@d49 1
d124 1
d193 1
a193 1
       "$Id: ChunkDivideConfig_m.f90,v 2.5 2017/09/14 23:17:26 pwagner Exp $"
d203 3
@


2.5
log
@Added module component to ChunkDivideConfig_T
@
text
@d19 2
a20 2
  use INTRINSIC, only: L_NONE, PHYQ_INVALID
  use MLSKinds, only: RP
d22 1
a22 1
  implicit NONE
d67 1
a67 1
  type(ChunkDivideConfig_T), public, save :: CHUNKDIVIDECONFIG
d69 2
a70 2
  interface dump
    module procedure DUMP_CONFIG
d84 2
d87 4
a90 4
    use LEXER_CORE, only: PRINT_SOURCE
    use Output_m, only: Output
    use String_Table, only: Display_String
    use TREE, only: WHERE
d98 37
a134 50
    call display_string ( lit_indices(Config%method), &
      &             strip=.true., before='  method ', advance='yes' )
    call output ( config%maxLength, before='  max Length ', advance='yes' )
    call display_string ( phyq_indices(Config%maxLengthFamily), &
      &             strip=.true., before='  max Length Family ', advance='yes' )
    call output ( config%noChunks, before='  num chunks ', advance='yes' )
    call output ( config%overlap, before='  overlap ', advance='yes' )
    call display_string ( phyq_indices(Config%overlapFamily), &
      &             strip=.true., before='  overlap Family ', advance='yes' )
    call output ( config%loweroverlap, before='  lower overlap ', advance='yes' )
    call display_string ( phyq_indices(Config%loweroverlapFamily), &
      &             strip=.true., before='  lower overlap Family ', advance='yes' )
    call output ( config%upperoverlap, before='  upper overlap ', advance='yes' )
    call display_string ( phyq_indices(Config%upperoverlapFamily), &
      &             strip=.true., before='  upper overlap Family ', advance='yes' )
    call output ( config%noSlaves, before='  num slaves ', advance='yes' )
    call display_string ( lit_indices(Config%homeModule), &
      &             strip=.true., before='  home module ', advance='yes' )
    call output ( config%homeGeodAngle, before='  home Geod Angle ', advance='yes' )
    call output ( config%scanLLSet, before='  set scan lower limit? ', advance='yes' )
    if ( config%scanLLSet ) then
      call output ( '  Bottom scan range ' )
      call output ( config%scanLowerLimit, advance='yes' )
    end if
    call output ( config%scanULSet, before='  set scan upper limit? ', advance='yes' )
    if ( config%scanULSet ) then
      call output ( '  Top scan range ' )
      call output ( config%scanUpperLimit, advance='yes' )
    end if
    call output ( config%maxOrbY, before='  max out-of-plane distance ', &
      & advance='yes' )
    call display_string ( lit_indices(Config%criticalModules), &
      &             strip=.true., before='  critical modules ', advance='yes' )
    call output ( '  critical bands ' )
    call output ( trim(config%criticalBands), advance='yes' )
    call output ( config%chooseCriticalSignals, &
      & before='  use critical modules to choose critical signals? ', advance='yes' )
    call output ( config%maxGap, before='  max gap ', advance='yes' )
    call display_string ( phyq_indices(Config%maxGapFamily), &
      &             strip=.true., before='  max Gap Family ', advance='yes' )
    call output ( config%skipL1BCheck, before='  skip check of l1b files ', &
      & advance='yes' )
    call output ( config%allowPriorOverlaps, &
      & before='  allow overlaps to prior day? ',advance='yes' )
    call output ( config%allowPostOverlaps, &
      & before='  allow overlaps to next day? ', advance='yes' )
    call output ( config%saveObstructions, before='  save obstructions? ', &
      & advance='yes' )
    call output ( config%DACSDeconvolved, before='  DACS already deconvolved? ', &
      & advance='yes' )
d136 17
d157 1
d159 1
a159 1
    use Output_M, only: OUTPUT
d191 1
a191 1
       "$Id: ChunkDivideConfig_m.f90,v 2.4 2014/08/06 23:26:45 vsnyder Exp $"
d201 3
@


2.4
log
@Remove USE for Switches and SwitchDetail, which are not referenced
@
text
@d42 1
d184 1
a184 1
       "$Id: ChunkDivideConfig_m.f90,v 2.3 2014/01/11 01:44:18 vsnyder Exp $"
d194 3
@


2.3
log
@Decruftification
@
text
@a20 2
  use MLSSTRINGLISTS, only: SWITCHDETAIL
  use TOGGLES, only: SWITCHES
d183 1
a183 1
       "$Id: ChunkDivideConfig_m.f90,v 2.2 2013/09/24 23:47:22 vsnyder Exp $"
d193 3
@


2.2
log
@Use Where instead of Source_Ref for messages
@
text
@a93 2
    integer :: swLevel ! How much extra debugging info to print (-1 means none)

a94 1
    swlevel = switchDetail(switches, 'chu' )
a159 1
    integer :: swLevel ! How much extra debugging info to print (-1 means none)
a161 1
    swlevel = switchDetail(switches, 'chu' )
d185 1
a185 1
       "$Id: ChunkDivideConfig_m.f90,v 2.1 2013/09/21 00:26:14 vsnyder Exp $"
d195 3
@


2.1
log
@Initial commit; avoid circular dependence between ChunkDivide and DumpCommand
@
text
@d76 1
a76 1
    "$RCSfile: ChunkDivide_m.f90,v $"
d89 1
a89 1
    use TREE, only: SOURCE_REF
d98 1
a98 1
    call print_source ( source_ref(config%where), &
d190 1
a190 1
       "$Id: ChunkDivide_m.f90,v 2.105 2013/08/30 02:45:34 vsnyder Exp $"
d199 4
a202 1
! $Log: $
@

