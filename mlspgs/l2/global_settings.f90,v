head	2.183;
access;
symbols
	v5-02-NRT-19:2.183
	v6-00:2.183
	v5-02-NRT-18:2.183
	v5-02:2.179
	v5-01-NRT-17:2.183
	v5-01-NRT-16:2.183
	v5-01-NRT-15:2.183
	v5-01-NRT-14:2.183
	neuralnetworks-1-0:2.179.0.4
	cfm-single-freq-0-1:2.179.0.2
	v5-01:2.179
	v5-00:2.179
	v4-23-TA133:2.178.0.2
	mus-emls-1-70:2.176.0.4
	rel-1-0-englocks-work:2.176.0.2
	VUMLS1-00:2.173
	VPL1-00:2.167
	V4-22-NRT-08:2.161
	VAM1-00:2.161
	V4-21:2.160.0.2
	V4-13:2.160
	V4-12:2.160
	V4-11:2.160
	V4-10:2.160
	V3-43:2.136
	M4-00:2.145
	V3-41:2.136
	V3-40-PlusGM57:2.136.0.2
	V2-24-NRT-04:2.128
	V3-33:2.138
	V2-24:2.128
	V3-31:2.138
	V3-30-NRT-05:2.137
	cfm-01-00:2.137
	V3-30:2.136
	V3-20:2.136
	V3-10:2.132
	V2-23-NRT-02:2.128
	V2-23:2.128
	V2-22-NRT-01:2.128
	V2-22:2.128
	V2-21:2.122
	V2-20:2.121
	V2-11:2.119
	V2-10:2.119
	V2-00:2.116
	V1-51:2.92
	V1-50:2.92
	V1-45:2.89
	V1-44:2.89
	V1-43:2.80
	V1-32:2.79
	V1-31:2.77
	V1-30:2.74
	V1-13:2.64
	V1-12:2.64
	V1-11:2.64
	V1-10:2.63
	newfwm-feb03:2.63.0.2
	V1-04:2.55
	V1-03:2.55
	V1-02:2.55
	JointForwardModel:2.55.0.2
	V1-00:2.52
	newfwm-sep01:2.40.0.2
	V0-7:2.40
	V0-5-Level2:2.22
	V0-5-SIPS:2.14;
locks; strict;
comment	@# @;


2.183
date	2021.05.28.15.51.38;	author pwagner;	state Exp;
branches;
next	2.182;

2.182
date	2021.04.01.23.51.37;	author pwagner;	state Exp;
branches;
next	2.181;

2.181
date	2021.03.19.15.20.49;	author pwagner;	state Exp;
branches;
next	2.180;

2.180
date	2021.02.05.05.20.06;	author pwagner;	state Exp;
branches;
next	2.179;

2.179
date	2019.04.18.16.30.10;	author pwagner;	state Exp;
branches;
next	2.178;

2.178
date	2018.11.01.23.16.00;	author pwagner;	state Exp;
branches;
next	2.177;

2.177
date	2018.07.27.23.19.53;	author pwagner;	state Exp;
branches;
next	2.176;

2.176
date	2017.11.15.00.11.44;	author pwagner;	state Exp;
branches;
next	2.175;

2.175
date	2017.07.27.16.42.38;	author pwagner;	state Exp;
branches;
next	2.174;

2.174
date	2017.07.10.18.58.16;	author pwagner;	state Exp;
branches;
next	2.173;

2.173
date	2017.01.19.23.52.03;	author pwagner;	state Exp;
branches;
next	2.172;

2.172
date	2017.01.07.01.14.51;	author pwagner;	state Exp;
branches;
next	2.171;

2.171
date	2016.11.09.17.20.01;	author pwagner;	state Exp;
branches;
next	2.170;

2.170
date	2016.11.08.17.32.35;	author pwagner;	state Exp;
branches;
next	2.169;

2.169
date	2016.09.23.00.11.52;	author pwagner;	state Exp;
branches;
next	2.168;

2.168
date	2016.09.14.20.08.45;	author pwagner;	state Exp;
branches;
next	2.167;

2.167
date	2016.08.09.21.47.42;	author pwagner;	state Exp;
branches;
next	2.166;

2.166
date	2016.07.28.23.39.32;	author pwagner;	state Exp;
branches;
next	2.165;

2.165
date	2016.07.28.19.54.30;	author pwagner;	state Exp;
branches;
next	2.164;

2.164
date	2016.07.28.01.45.07;	author vsnyder;	state Exp;
branches;
next	2.163;

2.163
date	2016.07.27.23.02.59;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2016.07.22.20.07.16;	author pwagner;	state Exp;
branches;
next	2.161;

2.161
date	2015.09.02.23.17.43;	author pwagner;	state Exp;
branches;
next	2.160;

2.160
date	2014.03.31.23.50.47;	author pwagner;	state Exp;
branches;
next	2.159;

2.159
date	2014.03.26.17.49.05;	author pwagner;	state Exp;
branches;
next	2.158;

2.158
date	2014.03.19.19.54.47;	author pwagner;	state Exp;
branches;
next	2.157;

2.157
date	2014.03.19.17.37.07;	author pwagner;	state Exp;
branches;
next	2.156;

2.156
date	2014.03.18.17.46.09;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2014.03.18.17.15.24;	author pwagner;	state Exp;
branches;
next	2.154;

2.154
date	2014.03.07.19.23.17;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.152;

2.152
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.151;

2.151
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.150;

2.150
date	2013.10.09.23.43.17;	author vsnyder;	state Exp;
branches;
next	2.149;

2.149
date	2013.09.25.01.04.33;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.147;

2.147
date	2013.08.30.02.45.49;	author vsnyder;	state Exp;
branches;
next	2.146;

2.146
date	2013.08.21.00.27.13;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2012.08.16.17.51.07;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2012.04.20.00.46.13;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2012.03.28.20.08.24;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2012.03.15.22.51.15;	author vsnyder;	state Exp;
branches;
next	2.141;

2.141
date	2011.11.04.00.08.01;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2011.10.05.00.14.45;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2011.06.29.21.50.48;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2010.10.19.00.04.36;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2010.05.23.03.19.48;	author honghanh;	state Exp;
branches;
next	2.136;

2.136
date	2010.02.04.23.12.44;	author vsnyder;	state Exp;
branches;
next	2.135;

2.135
date	2009.10.05.23.40.35;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2009.10.01.19.56.35;	author vsnyder;	state Exp;
branches;
next	2.133;

2.133
date	2009.08.26.17.16.15;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2009.03.05.16.21.36;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2008.12.18.21.13.46;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2008.08.27.20.00.59;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2007.12.14.01.50.47;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2007.10.04.20.43.12;	author vsnyder;	state Exp;
branches;
next	2.126;

2.126
date	2007.09.24.20.26.03;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2007.08.17.00.32.41;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2007.06.21.00.55.22;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2007.03.26.18.06.59;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2007.01.12.00.36.41;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2006.10.20.16.52.26;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2006.09.21.18.48.07;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2006.07.24.20.35.21;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2006.07.21.20.12.48;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2006.07.20.23.39.53;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2006.06.12.19.28.52;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2006.04.21.22.28.45;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2006.03.15.23.52.24;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2006.02.15.00.02.05;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2006.02.10.21.16.43;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2006.02.06.22.54.51;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2006.01.26.00.35.12;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2006.01.10.23.51.11;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2005.11.12.00.58.10;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2005.11.11.21.46.07;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2005.09.22.23.37.45;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2005.08.19.23.33.03;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2005.07.21.23.45.33;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2005.07.12.17.36.16;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2005.06.14.20.42.38;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2005.06.04.00.14.53;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2005.06.03.23.58.48;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2005.06.03.02.11.14;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2005.05.31.17.51.17;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2005.05.26.22.34.58;	author vsnyder;	state Exp;
branches;
next	2.96;

2.96
date	2005.05.02.22.59.59;	author vsnyder;	state Exp;
branches;
next	2.95;

2.95
date	2005.01.27.21.22.04;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2005.01.12.03.18.22;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2004.12.31.02.43.05;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2004.12.14.22.52.38;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2004.12.13.20.19.48;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2004.10.13.00.52.52;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2004.08.17.23.49.36;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2004.08.16.17.14.42;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2004.08.04.23.19.58;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2004.07.26.18.22.48;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2004.06.17.22.49.36;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2004.06.17.00.39.02;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2004.06.08.19.28.07;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2004.05.29.02.50.49;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2004.05.22.02.31.40;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2004.03.24.01.02.55;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2004.01.23.01.09.48;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2004.01.22.00.54.36;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2003.12.11.22.59.08;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2003.11.15.00.46.41;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2003.09.26.21.55.54;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2003.09.12.16.28.49;	author cvuu;	state Exp;
branches;
next	2.73;

2.73
date	2003.09.02.18.03.23;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2003.07.15.18.18.06;	author livesey;	state Exp;
branches;
next	2.71;

2.71
date	2003.07.07.23.50.04;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2003.06.09.22.49.34;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2003.05.14.22.04.49;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2003.05.12.20.57.21;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2003.05.10.22.20.50;	author livesey;	state Exp;
branches;
next	2.66;

2.66
date	2003.05.07.23.58.04;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2003.04.02.23.54.53;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2003.02.27.21.55.14;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2003.02.01.00.50.14;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2002.12.11.22.17.55;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2002.11.13.01.07.40;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2002.10.08.17.36.20;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2002.10.03.23.01.19;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2002.09.25.20.09.14;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2002.08.28.22.26.39;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2002.08.20.23.02.17;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2002.05.01.22.03.50;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2002.05.01.16.14.13;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2002.04.29.17.42.16;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2002.02.08.22.52.56;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2002.01.24.00.14.26;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2001.12.16.00.57.26;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2001.12.10.20.22.22;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2001.10.31.18.36.42;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2001.10.30.00.37.09;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2001.10.26.23.18.35;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2001.10.25.23.35.52;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2001.09.28.23.59.20;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2001.09.28.17.50.30;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2001.09.17.23.13.09;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2001.07.12.23.28.15;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2001.07.09.22.53.20;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2001.06.07.21.58.28;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2001.05.30.23.56.23;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2001.05.30.23.04.40;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.29.23.21.07;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2001.05.26.00.06.49;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2001.05.24.20.54.15;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2001.05.24.20.36.13;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2001.05.17.00.29.03;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2001.05.15.23.46.32;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2001.05.14.23.45.08;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2001.05.11.23.44.43;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2001.05.11.01.56.17;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.05.11.00.09.05;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2001.05.10.18.26.22;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2001.05.09.23.35.04;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2001.05.04.17.15.36;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.26.20.02.09;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.26.02.52.17;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.04.26.00.07.33;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.04.24.00.31.42;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.23.23.48.41;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.23.23.42.00;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.21.01.25.54;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.10.23.44.44;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.10.02.46.17;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.07.01.50.49;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.03.28.22.00.33;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.03.28.01.24.55;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.17.03.24.23;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.17.00.57.36;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.17.00.45.38;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.09.02.30.13;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.09.00.24.30;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.08.03.23.09;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.07.22.46.05;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.11.16.01.53.40;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.11.16.01.45.25;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.05;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.02.02.05.04;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.183
log
@Optional arg MIF triggers match for GHz/GeodAngle instead of time
@
text
@! C/pyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Global_Settings

  use MLSCommon, only: FileNameLen, MLSFile_T, NameLen, Tai93_Range_T
  use HighOutput, only: AddRow, AddRow_Divider, AddRow_Header, &
    & BeVerbose, OutputCalendar, OutputNamedValue, OutputTable, StartTable, &
    & StyledOutput
  use MLSL2Options, only: CheckPaths, L2CFNode, Level1_HDFVersion, &
    & Need_L1BFiles, SpecialDumpFile, StopAfterSection, Toolkit, &
    & MLSL2Message
  use Output_M, only: Blanks, NewLine, Output, &
    & RevertOutput, SwitchOutput

  implicit none

  private

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (data types and parameters)
! Leapsecfilename                 For time conversions (if avoiding PCF)
! BrightObjects                   As determined by l1b

!     (subroutines and functions)
! Set_Global_Settings             Get global settings from l2cf
! L1MAFToL2Profile                Find profile number closest to a MAF
! L2ProfileToL1MAF                Find MAF closest to a profile number
! === (end of toc) ===

  public :: L1maftol2profile, L2Profiletol1maf, Set_Global_Settings

  character(len=FileNameLen), public :: LEAPSECFILENAME = ''

  ! These must be values consistent with level 1
  ! (Some canny coding below could make this more robust)
  integer, parameter :: BO_NAMEDIMS = 14
  integer, parameter :: BO_NAMELEN  = 14

  ! This next should be large enough to hold the entire list of BO names
  integer, parameter :: BONAMELISTLEN = 256
  character(len=BONAMELISTLEN), public, save :: brightObjects = &
    & 'MERCURY, VENUS, EARTH, MARS, JUPITER, SATURN, URANUS, NEPTUNE, PLUTO, ' // &
    & 'MOON, SUN, SOLAR-BARYCNTR, EARTH-BARYCNTR, GALACTICCENTER'

  ! Do we check for the correct month's l2pc files during checkPaths preflight?
  logical, parameter :: CHECKL2PCMONTHCORRECT = .true.
  ! Do we output this month's calendar
  logical, parameter :: OUTPUTTHISMONTHSCAL = .true.
  ! Consult dates_module for leap seconds
  logical, parameter :: LEAPSINDATESMODULE  = .true.
  ! Can tai93 times be < 0?
  logical, parameter :: NEGATIVETAI93OK     = .true.
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: global_settings.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  integer, private              :: ERROR, WARNING
  logical, parameter            :: countEmpty = .true.
  logical, parameter            :: DEEBUG = .false.

contains

  ! Given a MAF, returns the closest profile
  ! Return -1 if something goes wrong
  ! Remember--MAFs start at 0, not 1 (?)
  !
  ! Does anyone really think that having MAFs start at 0 wasn't a mistake?
  ! It's probably too late to reverse that decision, but
  ! because profiles, MIFs, and every other geolocation index start at 1
  ! "singling" out MAFs and treating them in a manner inconsistent with
  ! with normal expectations is a recipe for .. mistakes.
  ! **
  ! Here's a good software design rule:
  ! Given a choice between 2 designs, where one design is more likely
  ! to lead to mistakes and the other is less likely to lead to mistakes
  !    ===>   choose the design less likely to lead to mistakes    <===
  ! **
  !
  function L1MAFToL2Profile ( MAF, fileDatabase, &
    & MIF, Debugging, Phi, Lat ) result( profile )
    use L1BData, only: L1BData_t, &
      & AssembleL1BQtyName, DeallocateL1BData, &
      & ReadL1BData 
    use L2GPData, only: L2GPData_t, L2GPNameLen, MaxSwathNamesBufSize, &
      & ReadL2GPData, DestroyL2GPContents
    use MLSFiles, only: HDFVersion_5, &
      & MLS_InqSwath, GetMLSFileByType
    use MLSKinds, only: R4, R8
    use MLSMessageModule, only: MLSMSG_Warning
    use MLSNumerics, only: ClosestElement
    use MLSStringLists, only: GetStringElement
    ! Args
    integer, intent(in)                 :: MAF
    type (MLSFile_T), pointer           :: FILEDATABASE(:)
    integer, optional, intent(in)       :: MIF ! Not for MAFStartTimeTAI
    logical, optional, intent(in)       :: Debugging
    real(r4), optional, intent(out)     :: Phi
    real(r4), optional, intent(out)     :: Lat
    integer :: profile
    ! Internal variables
    integer, dimension(1) :: indices
    integer :: L1BFLAG
    character(len=namelen) :: l1bItemName
    type (L1BData_T) :: l1bField   ! L1B data
    type(MLSFile_T), pointer :: L1BFile, L2GPFile
    type (L2GPData_T) :: l2gp
    integer :: myMIF ! To be used in diagnostic dumps
    integer :: LISTSIZE, NOMAFS, NOSWATHS
    character (len=namelen) :: QUANTITY
    character (len=L2GPNameLen) :: swath
    character (len=MAXSWATHNAMESBUFSIZE) :: SwathList
    ! logical, parameter          :: DEEBug = .true.
    logical                     :: DEEBug
    logical, parameter          :: DumpLats = .true.
    ! Executable
    DeeBug = .false.
    if ( present(Debugging) ) DeeBug = Debugging
    profile = -1
    myMIF = 1
    if ( present(MIF) ) myMIF = MIF
    ! 1st--read the MAF times (or geodAngle if that's what you're matching)
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName // 'L1MAFToL2Profile', &                      
      & 'l1boa File not found--hope you dont need one' )
      return
    endif
    if ( myMIF == 1 ) then
      quantity = 'MAFStartTimeTAI'
    else
      quantity = 'GHz/GeodAngle'
    endif
    l1bItemName = AssembleL1BQtyName ( quantity, HDFVERSION_5, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
      & l1bFlag, dontPad=.true.)
    ! 2nd--read the profile
    L2GPFile => GetMLSFileByType ( filedatabase, content='l2gp' )
    if ( .not. associated(L2GPFile) ) &
      & L2GPFile => GetMLSFileByType ( filedatabase, content='l2dgg' )
    noSwaths = mls_InqSwath ( L2GPFile%name, SwathList, listSize, &
           & hdfVersion=HDFVERSION_5 )
    call GetStringElement (trim(swathList), swath, 1, countEmpty )
    call ReadL2GPData ( L2GPFile, trim(swath), l2gp )
    if ( DEEBUG ) call outputNamedValue( 'shape(l2gp%time)', shape(l2gp%time) )
    if ( DEEBUG ) call outputNamedValue( 'shape(l1bField%dpField)', shape(l1bField%dpField) )
    if ( DEEBUG ) call outputNamedValue( 'lbound(l1bField%dpField(1,1,:))', lbound(l1bField%dpField(1,1,:)) )
    if ( myMIF == 1 ) then
      call ClosestElement( l1bField%dpField(1,myMIF,MAF+1)*1._r8, &
        & l2gp%time, indices )
    else
      call ClosestElement( l1bField%dpField(1,myMIF,MAF+1), &
        & l2gp%geodAngle*1._r8, indices )
      call OutputNamedValue( 'phi(MAF)', l1bField%dpField(1,myMIF,MAF+1) )
      call OutputNamedValue( 'phi(nearestprofile)', l2gp%geodAngle(indices(1)) )
    endif
    profile = indices(1)
    if ( DEEBUG ) then
      call outputNamedValue( 'l2gp profile', profile )
      call outputNamedValue( 'l1b MAF', MAF )
      call output ( '-----------', advance='yes' )
      call output ( 'MAFStartTimesTAI', advance='yes' )
      call outputNamedValue( 'l2gpvalue', l2gp%time(profile) )
      call outputNamedValue( 'l1bvalue', l1bField%dpField(1,1,MAF) )
      call outputNamedValue( 'l1bvalue[+1]', l1bField%dpField(1,1,MAF+1) )
      call output ( '-----------', advance='yes' )
    endif
    call deallocatel1bdata( l1bfield )
    if ( (DEEBug .and. DumpLats) .or. present(Phi) ) then
      call ReadL1BData ( L1BFile, '/GHz/GeodAngle', l1bField, noMAFs, &
        & l1bFlag, dontPad=.true.)
      if ( DeeBug ) then
      call output ( '-----------', advance='yes' )
      call output ( 'Geod Angles', advance='yes' )
      call outputNamedValue( 'shape(l1b)', shape(l1bField%dpField) )
      call outputNamedValue( 'l2gpvalues', &
        & (/ l2gp%GeodAngle(profile) /) )
      call outputNamedValue( 'MAFs', &
        & (/ MAF, MAF+1, MAF+2 /) )
      call outputNamedValue( 'l1bvalues', &
        & (/ l1bField%dpField(1,myMIF,MAF-1), l1bField%dpField(1,myMIF,MAF), &
        & l1bField%dpField(1,myMIF,MAF+1), l1bField%dpField(1,myMIF,MAF+2) /)  )
      call outputNamedValue( 'their MAFs', &
        & (/ MAF-1, MAF, &
        & MAF+1, MAF+2 /)  )
      call output ( '-----------', advance='yes' )
      endif
      if ( present(Phi) ) Phi = l1bField%dpField(1,myMIF,MAF)

      call deallocatel1bdata( l1bfield )
      
      call ReadL1BData ( L1BFile, '/GHz/GeodLat', l1bField, noMAFs, &
        & l1bFlag, dontPad=.true.)
      if ( DeeBug ) then
      call output ( '-----------', advance='yes' )
      call output ( 'Geod Lats', advance='yes' )
      call outputNamedValue( 'shape(l1b)', shape(l1bField%dpField) )
      call outputNamedValue( 'l2gpvalues', &
        & (/ l2gp%Latitude(profile) /) )
      call outputNamedValue( 'l1bvalues', &
        & (/ l1bField%dpField(1,myMIF,MAF-1), l1bField%dpField(1,myMIF,MAF), &
        & l1bField%dpField(1,myMIF,MAF+1), l1bField%dpField(1,myMIF,MAF+2) /)  )
      call outputNamedValue( 'their MAFs', &
        & (/ MAF-1, MAF, &
        & MAF+1, MAF+2 /)  )
      call output ( '-----------', advance='yes' )
      endif
      if ( present(Lat) ) Lat = l1bField%dpField(1,myMIF,MAF)
    endif
    call destroyl2gpcontents( l2gp )
  end function L1MAFToL2Profile

  ! Given a profile, returns the closest MAF
  ! Return -1 if something goes wrong
  ! Remember--MAFs start at 0, not 1
  function L2ProfileToL1MAF ( profile, fileDatabase, MIF ) result( MAF )
    use Dump_0, only: Dump
    use L1BData, only: L1BData_T, NameLen, &
      & AssembleL1BQtyName, DeallocateL1BData, &
      & ReadL1BData 
    use L2GPData, only: L2GPData_t, L2GPNameLen, MaxSwathNamesBufSize, &
      & ReadL2GPData, DestroyL2GPContents
    use MLSFiles, only: HDFVersion_5, &
      & MLS_InqSwath, GetMLSFileByType
    use MLSKinds, only: R8
    use MLSMessageModule, only: MLSMSG_Warning
    use MLSNumerics, only: ClosestElement
    use MLSStringLists, only: GetStringElement
    ! Args
    integer, intent(in)                 :: profile
    type (MLSFile_T), pointer           :: FILEDATABASE(:)
    integer, intent(in), optional       :: MIF
    integer :: MAF
    ! Internal variables
    integer, dimension(1) :: indices
    integer :: L1BFLAG
    character(len=namelen) :: l1bItemName
    type (L1BData_T) :: l1bField   ! L1B data
    type(MLSFile_T), pointer :: L1BFile, L2GPFile
    type (L2GPData_T) :: l2gp
    integer :: myMIF ! To be used in diagnostic dumps
    integer :: LISTSIZE, NOMAFS, NOSWATHS
    character (len=namelen) :: QUANTITY
    character (len=L2GPNameLen) :: swath
    character (len=MAXSWATHNAMESBUFSIZE) :: SwathList
    ! Executable
    MAF = -1
    myMIF = 1
    if ( present(MIF) ) myMIF = MIF
    ! 1st--read the MAF times (or geodAngle if that's what you're matching)
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName // 'L2ProfileToL1MAF', &                      
      & 'l1boa File not found--hope you dont need one' )
      return
    end if
    if ( myMIF == 1 ) then
      quantity = 'MAFStartTimeTAI'
    else
      quantity = 'GHz/GeodAngle'
    endif
    l1bItemName = AssembleL1BQtyName ( quantity, HDFVERSION_5, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
      & l1bFlag, dontPad=.true.)
    ! 2nd--read the profile
    L2GPFile => GetMLSFileByType ( filedatabase, content='l2gp' )
    if ( .not. associated(L2GPFile) ) &
      & L2GPFile => GetMLSFileByType ( filedatabase, content='l2dgg' )
    noSwaths = mls_InqSwath ( L2GPFile%name, SwathList, listSize, &
           & hdfVersion=HDFVERSION_5 )
    if ( DEEBUG ) call outputNamedValue( 'profile', profile )
    if ( DEEBUG ) call outputNamedValue( 'noSwaths', noSwaths )
    call GetStringElement (trim(swathList), swath, 1, countEmpty )
    if ( DEEBUG ) call outputNamedValue( 'swath', swath )
    call ReadL2GPData ( L2GPFile, trim(swath), l2gp )
    if ( DEEBUG ) call dump( l2gp%time, 'l2gp%time' )
    if ( l2gp%time(profile) < 0.d0 ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName // 'L2ProfileToL1MAF', &                      
      & 'time for this profile < 0; did the chunk crash?' )
      call deallocatel1bdata( l1bfield )
      call destroyl2gpcontents( l2gp )
      return
    end if
    if ( myMIF == 1 ) then
      call ClosestElement( l2gp%time(profile), &
        & l1bField%dpField(1,myMIF,:)*1._r8, indices )
    else
      call ClosestElement( l2gp%geodAngle(profile)*1._r8, &
        & l1bField%dpField(1,myMIF,:), indices )
      call OutputNamedValue( 'phi(profile)', l2gp%geodAngle(profile) )
      call OutputNamedValue( 'phi(nearest MAF)', l1bField%dpField(1,myMIF,indices(1)) )
    endif
    MAF = indices(1) - 1
    if ( DEEBUG ) call outputNamedValue( 'size(time)', size(l2gp%time) )
    if ( DEEBUG ) call outputNamedValue( 'time(l2gp)', l2gp%time(profile) )
    if ( DEEBUG .and. MAF > 0 ) call outputNamedValue( 'l1bvalue', l1bField%dpField(1,1,MAF) )
    if ( DEEBUG ) call outputNamedValue( 'l1bvalue[+1]', l1bField%dpField(1,1,MAF+1) )
    call deallocatel1bdata( l1bfield )
    call destroyl2gpcontents( l2gp )
  end function L2ProfileToL1MAF

  subroutine Set_Global_Settings ( root, forwardModelConfigDatabase, &
    & fileDatabase, FGrids, L2GPDatabase, directDatabase, processingRange )

    use BitStuff, only: IsBitSet
    use Dates_Module, only: IsUTCInRange, PrecedesUTC, ResetStartingDate, &
      & SecondsBetween2UTCs, Utc2tai93s, UTC_To_Yyyymmdd, YyyyDoy_To_Mmdd
    use Declaration_Table, only: Named_Value, Redeclare, Str_Value
    use DirectWrite_M, only: DirectData_T, &
      & AddDirectToDatabase, Dump, SetupNewDirect
    use DumpCommand_M, only: DumpCommand
    use Dump_1, only: Dump
    use EmpiricalGeometry, only: InitEmpiricalGeometry
    use FGrid, only: AddFGridToDatabase, CreateFGridFromMLSCFInfo, Dump, Fgrid_T
    use ForwardModelConfig, only: AddForwardModelConfigToDatabase, Dump, &
      & ForwardModelConfig_T
    use ForwardModelSupport, only: ConstructForwardModelConfig, &
      & ForwardModelGlobalsetup, CreateBinSelectorFromMLSCFInfo
    use HDF, only: Dfacc_Create
    use IGRF_Int, only: Read_Gh
    use Init_Tables_Module, only: F_File, F_Reset, F_Type, &
      & L_L2GP, L_L2dgg, L_L2fwm, &
      & Parm_Indices, &
      & First_Parm, Last_Parm, P_Brightobjects, &
      & P_Cycle, P_Endtime, P_Igrf_File, P_Instrument, &
      & P_LeapsecFile, P_Output_Version_String, P_PFAFile, P_Starttime, &
      & S_Binselector, S_DirectwriteFile, S_Dump, S_Empiricalgeometry, &
      & S_Fgrid, S_FlushPFA, S_ForwardModel, S_ForwardModelglobal, &
      & S_L1boa, S_L1brad, S_L2parsf, S_MakePFA, S_PFAData, S_ReadPFA, &
      & S_Tgrid, S_Time, S_Vgrid, S_WritePFA
    use Intrinsic, only: L_HDF, L_Swath, Spec_Indices
    use L1BData, only: L1BData_T, NameLen, &
      & AssembleL1BQtyName, DeallocateL1BData, Dump, FindMaxMaf, &
      & L1BRadsetup, L1BOASetup, ReadL1BAttribute, ReadL1BData
    use L2GPData, only: L2GPData_T
    use L2PC_M, only: AddbinselectortoDatabase, Binselectors
    use MLSFiles, only: Filenotfound, HDFVersion_5, &
      & AddFiletoDatabase, GetPCFromref, GetMLSFileByName, GetMLSFileByType, &
      & InitializeMLSFile, MLS_CloseFile, MLS_OpenFile, Split_Path_Name
    use MLSHDF5, only: GetAllHDF5GroupNames
    use MLSKinds, only: R8
    use MLSL2Timings, only: Section_Times
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning
    use MLSPCF2, only: MLSPCF_L2GP_Start, MLSPCF_L2GP_End, &
      & MLSPCF_L2dgm_Start, MLSPCF_L2dgm_End, MLSPCF_L2fwm_Full_Start, &
      & MLSPCF_L2fwm_Full_End, &
      & MLSPCF_L2dgg_Start, MLSPCF_L2dgg_End
    use MLSStrings, only: Hhmmss_Value, LowerCase, Trim_Safe
    use MLSStringLists, only: Array2List, CatLists, SwitchDetail, &
      & NumStringElements, StringElement, StringElementNum
    use MLSSignals_M, only: Instrument, Modules, Dump_Modules, GetModuleName
    use MoreTree, only: Get_Boolean, Get_Field_Id, Get_Label_And_Spec, &
      & Get_Spec_Id, StartErrorMessage
    use Next_Tree_Node_M, only: Next_Tree_Node, Next_Tree_Node_State
    use PFAData_M, only: Get_PFAData_From_L2cf, Flush_PFAData, Make_PFAData, &
      & Read_PFAData, Write_PFAData
    use PFADatabase_M, only: Process_PFA_File
    use PCFHDR, only: GlobalAttributes, FillTAI93Attribute
    use ReadAPriori, only: APrioriFiles
    use SDPToolkit, only: Max_Orbits, MLS_UTCToTAI, &
      & PGSD_Dem_30arc, PGSD_Dem_90arc, &
      & PGSD_Dem_Elev, PGSD_Dem_Water_Land, &
      & PGS_Dem_Open, PGS_S_Success
    use String_Table, only: Display_String, Get_String
    use Time_M, only: SayTime, Time_Now
    use Toggles, only: Gen, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decorate, Decoration, Node_Id, Nsons, Sub_Rosa, Subtree, &
      & Dump_Tree_Node
    use Tree_Types, only: N_Equal
    use VGrid, only: CreateVGridFromMLSCFInfo
    use VGridsDatabase, only: AddVGridToDatabase, VGrids
    use WriteMetaData, only: L2PCF

    ! placed non-alphabetically due to Lahey internal compiler error
    ! (How much longer must we endure these onerous work-arounds?)
    use MLSHDF5, only: GetHDF5Attribute, IsHDF5AttributeInFile
    use HDF5, only: H5GClose_f, H5GOpen_f

    integer, intent(in)                    :: ROOT    ! Index of N_CF node in abstract syntax tree
    type(ForwardModelConfig_T), pointer    :: FORWARDMODELCONFIGDATABASE(:)
    type (MLSFile_T), pointer              :: FILEDATABASE(:)
    type ( fGrid_T ), pointer, optional    :: FGRIDS(:)
    type ( l2gpData_T), pointer, optional  :: L2GPDATABASE(:)
    type (DirectData_T), pointer, optional :: DIRECTDATABASE(:)
    type (TAI93_Range_T), optional         :: PROCESSINGRANGE ! Data processing range

    ! Local variables
    character(len=BO_NAMELEN), dimension(BO_NAMEDIMS) :: BO_names
    type (l1bData_T)                      :: BO_stat
    character(len=BONAMELISTLEN) :: BO_today
    logical, parameter :: DEEBUG = .false.
    integer :: DetailReduction
    integer :: Details             ! How much info about l1b files to dump
    type (MLSFile_T) :: DirectFile
    character(len=NameLen) :: End_time_string, Start_time_string
    character(len=FileNameLen) :: FilenameString
    logical :: GOT(FIRST_PARM:LAST_PARM)
    integer :: Gson
    integer :: Field
    integer :: I, J                ! Index of son, grandson of root
    logical ::  ItExists
    character(len=namelen) :: itsname
    integer :: Key
    type (L1BData_T) :: L1bField   ! L1B data
    type(MLSFile_T), pointer :: L1BFile
    character(len=namelen) :: L1bItemName
    integer :: L1BFLAG
    integer :: Me = -1             ! String index for trace
    integer :: MM, DD
    real(r8) :: MINTIME, MAXTIME   ! Time Span in L1B file data
    character(len=namelen) :: modulenames
    integer :: NAME                ! Sub-rosa index of name of vGrid or hGrid
    character(len=NameLen) :: Name_string
    integer :: NOMAFS              ! Number of MAFs of L1B data read
    integer :: NUMFILES
    integer :: OrbNum(max_orbits)
    real(r8) :: OrbPeriod(max_orbits)
    integer :: OUTPUT_VERSION_STRING ! Sub_rosa index
    integer :: Param               ! Tree index of param i.e., name before =
    integer :: Param_id            ! e.g., p_brightObjects
    character (len=namelen) :: QUANTITY
    logical :: Reset
    logical :: Restricted          ! Some commands not available
    integer :: ReturnStatus        ! non-zero means trouble
    integer :: SON                 ! Son of root
    integer :: spec_id             ! e.g., s_binSelector
    type(next_tree_node_state) :: State ! of tree traverser
    logical :: StopEarly
    integer :: Sub_rosa_index
    integer :: The_HDF_version     ! 4 or 5 (corresp. to hdf4 or hdf5)
    logical :: TIMING              ! For S_Time
    logical :: StartTimeIsAbsolute, stopTimeIsAbsolute
    integer :: Status
    real :: T1                 ! For S_Time
    real(r8) :: Start_time_from_1stMAF, End_time_from_1stMAF
    logical :: verbose
    logical :: verboser
    logical :: wasAlreadyOpen

    integer, parameter :: Param_restricted = 1 ! Parameter not allowed
    integer, parameter :: Spec_restricted = param_restricted + 1 ! Spec not allowed
    ! DEM nonsense
    integer, dimension(2) :: resolutionList
    integer   :: numResolutions
    integer, dimension(2) :: layerList
    integer   :: numLayers
    ! Executable

    restricted = .not. all( (/present(FGrids), present(l2gpDatabase), &
                           present(DirectDatabase), present(processingRange) /))
    timing = section_times
    if ( timing ) call time_now ( t1 )
    stopEarly = ( &
      & index('global_setting,chunk_divide', &
      & lowercase( trim(stopAfterSection) ) ) > 0 )
    stopEarly = ( stopearly .and. stopAfterSection /= ' ' )
    error = 0
    warning = 0
    got = .false.
    startTimeIsAbsolute = .false.
    stopTimeIsAbsolute = .false.
    LeapSecFileName = ''

    call trace_begin ( me, 'SET_GLOBAL_SETTINGS', root, cond=toggle(gen) )

    Details = switchDetail(switches, 'glo') - 3

    DetailReduction = switchDetail(switches, 'red')
    if ( DetailReduction < 0 ) then ! The 'red' switch is absent
      DetailReduction = 0
    elseif ( DetailReduction == 0 ) then ! By default, reduce details level by 2
      DetailReduction = 2
    end if
    verbose = BeVerbose( 'glo', -1 )
    verboser = BeVerbose( 'glo', 0 )
    
    ! Start Digital Elevation Model
    if ( Toolkit ) then
      ! Initialize
      numResolutions = 2
      numLayers = 2
      resolutionList(1) = PGSd_DEM_30ARC
      resolutionList(2) = PGSd_DEM_90ARC
      layerList(1) = PGSd_DEM_ELEV
      layerList(2) = PGSd_DEM_WATER_LAND
      status = PGS_DEM_Open ( resolutionList, numResolutions, &
        & layerList, numLayers )
      if ( verbose .or. status /= PGS_S_SUCCESS ) &
        & call outputNamedValue( 'PGS_DEM_Open status', status )
      if ( status /= PGS_S_SUCCESS )  call announce_error( 0, &
        & '*** Error: Unable to open Digital Elevation Model (DEM) files;' // &
        & ' missing from PCF? ***', just_a_warning = .false.)
    end if

    do
      son = next_tree_node ( root, state )
      call get_label_and_spec ( son, name, key )
      if ( son == 0 ) exit
      L2CFNODE = son
      reset = .false.
      do j = 2, nsons(key) ! fields of the "time" specification
        gson = subtree(j, key)
        if ( gson == 0 ) exit
        if ( node_id(son) == n_equal ) cycle ! Why can't we loop over params ?
        field = get_field_id(gson)   ! tree_checker prevents duplicates
        if (nsons(gson) > 1 ) gson = subtree(2,gson) ! Gson is value
        select case ( field )
        case ( f_reset )
          reset = Get_Boolean ( gson )
        case default
          ! Shouldn't get here if the type checker worked
        end select
      end do ! j = 2, nsons(key)

      if ( node_id(son) == n_equal ) then
        sub_rosa_index = sub_rosa(subtree(2,son))
        param = subtree(1,son)
        call redeclare ( sub_rosa(param), 0.0d0+sub_rosa_index, named_value, &
          & str_value, son ) ! Put its value in the declaration table
        param_id = decoration(param)
        if ( TOOLKIT .and. &
          & any( param_id == &
          & (/ p_output_version_string, p_cycle, p_starttime, p_endtime, &
          & p_leapsecfile /) ) ) then
          if ( verboser ) call announce_error(0, &
            & '*** l2cf parameter global setting ignored ***', &
            & just_a_warning = .true.)
          cycle
        end if
        if ( param_id < first_parm .or. param_id > last_parm ) cycle ! how?
        got(param_id) = .true.
        if ( DEEBUG ) call display_string( parm_indices(param_id), advance='yes' )
        select case ( param_id )
        ! This will allow us to use different names from the toolkit
        ! (Now why would you want to do that?)
        case ( p_brightObjects )
          call get_string ( sub_rosa_index, brightObjects, strip=.true. )
        case ( p_cycle )
          call get_string ( sub_rosa_index, l2pcf%cycle, strip=.true. )
        case ( p_endtime )
          if ( restricted ) call NotAllowed ( son, param_restricted )
          call get_string ( sub_rosa_index, name_string, strip=.true. )
          end_time_string = name_string
          if ( index(name_string, ':') > 0 ) then
            end_time_from_1stMAF = hhmmss_value(name_string, returnStatus)
            error = max(error,returnStatus)
            stopTimeIsAbsolute = .false.
            l2pcf%endutc = end_time_string
          else
            read ( name_string, * ) end_time_from_1stMAF
            stopTimeIsAbsolute = .true.
          end if
        case ( p_IGRF_file )
          if ( restricted ) call NotAllowed ( son, param_restricted )
          call read_gh ( son )
        case ( p_instrument )
          instrument = decoration(subtree(2,son))
        case ( p_leapsecfile )
          if ( restricted ) call NotAllowed ( son, param_restricted )
          call get_string ( sub_rosa_index, LeapSecFileName, strip=.true. )
          inquire(file=trim(LeapSecFileName), exist=itExists)
          if ( .not. itExists ) then
            call announce_error(son, &
            & '*** Leap Second File ' // trim(LeapSecFileName) // &
            & ' not found', &
            & just_a_warning = .false.)
            call MLSL2Message ( MLSMSG_Error, ModuleName, &                      
            & '(Please check file name and path)' )    
          end if
        case ( p_output_version_string )
          output_version_string = sub_rosa_index
          call get_string ( output_version_string, l2pcf%PGEVersion, strip=.true. )
        case ( p_PFAFile )
          if ( restricted ) call NotAllowed ( son, param_restricted )
          do j = 2, nsons(son)
            if ( process_PFA_File ( sub_rosa(subtree(j,son)), &
              & subtree(j,son) ) /= 0 ) continue
          end do
        case ( p_starttime )
          if ( restricted ) call NotAllowed ( son, param_restricted )
          call get_string ( sub_rosa_index, name_string, strip=.true. )
          start_time_string = name_string
          if ( index(name_string, ':') > 0 ) then
            start_time_from_1stMAF = hhmmss_value(name_string, returnStatus)
            error = max(error,returnStatus)
            startTimeIsAbsolute = .false.
            l2pcf%startutc = start_time_string
          else
            read ( name_string, * ) start_time_from_1stMAF
            startTimeIsAbsolute = .true.
          end if
        case default
          call announce_error(son, 'unrecognized global settings parameter')
        end select
      else
        call get_label_and_spec ( son, name )
        L2CFNODE = son
        spec_id = get_spec_id(son)
        if ( TOOLKIT .and. &
          & any( spec_id == &
          & (/ s_l1boa, s_l1brad, s_l2parsf /) ) ) then
          if ( verboser ) call announce_error(0, &
            & '*** l2cf spec global setting ignored ***', &
            & just_a_warning = .true.)
          cycle
        endif
        if ( DEEBUG ) call display_string( spec_indices(spec_id), advance='yes' )
        select case ( spec_id )
        case ( s_binSelector )
          call decorate (son, AddBinSelectorToDatabase ( &
            & binSelectors, CreateBinSelectorFromMLSCFInfo ( son ) ) )
        case ( s_directWriteFile )
          if ( restricted ) call notAllowed ( son, spec_restricted )
          call decorate (son, AddDirectToDatabase ( &
            & DirectDatabase, &
            & CreateDirectTypeFromMLSCFInfo ( son, DirectFile ) ) )
          numFiles = AddFileToDataBase(fileDataBase, DirectFile)
        case ( s_dump )
          if ( error == 0 ) then
            call dumpCommand ( son, &
              & forwardModelConfigs=forwardModelConfigDatabase, &
              & fileDatabase=fileDatabase )
          else
            call announce_error ( subtree(1,son), &
              & 'Preceeding errors prevent doing a dump here.' )
          end if
        case ( s_empiricalGeometry )
          if ( restricted ) call NotAllowed ( son, param_restricted )
          call InitEmpiricalGeometry ( son )
        case ( s_flushPFA )
          call flush_PFAData ( son, status )
          error = max(error,status)
        case ( s_fgrid )
          if ( restricted ) call notAllowed ( son, spec_restricted )
          call decorate ( son, AddFGridToDatabase ( fGrids, &
            & CreateFGridFromMLSCFInfo ( name, son ) ) )
          if ( switchDetail(switches, 'fgrid') > -1 ) &
            & call dump( fgrids(size(fGrids) ) )
        case ( s_forwardModelGlobal ) !??? Begin temporary stuff for l2load
          if ( restricted ) call notAllowed ( son, spec_restricted )
          if ( stopEarly .or. &
            & ( checkPaths .and. .not. CHECKL2PCMONTHCORRECT ) ) cycle
          call forwardModelGlobalSetup ( son, returnStatus, fileDataBase )
          error = max(error, returnStatus)
        case ( s_forwardModel )
          if ( .not. stopEarly ) then
            call decorate (son, AddForwardModelConfigToDatabase ( &
            & forwardModelConfigDatabase, &
            & ConstructForwardModelConfig ( name, son, .true. ) ) )
          end if
        case ( s_l1boa )
          if ( restricted ) call notAllowed ( son, spec_restricted )
          if ( .not. NEED_L1BFILES ) then
            call MLSL2Message ( MLSMSG_Warning, ModuleName, &                      
            & 'l1boa File not needed -- and so ignored' )
            cycle
          endif
          the_hdf_version = LEVEL1_HDFVERSION
          call l1boaSetup ( son, filedatabase, F_FILE, hdfVersion=the_hdf_version )
          if( switchDetail(switches, 'pro') > -1 ) then                            
            sub_rosa_index = sub_rosa(subtree(2,subtree(2, son)))
            call get_string ( sub_rosa_index, FilenameString, strip=.true. )
            call proclaim(FilenameString, 'l1boa', &                   
            & hdfVersion=the_hdf_version) 
          end if
          L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
          if ( associated(L1BFile) ) then
            call ReadL1BAttribute (L1BFile, OrbNum, 'OrbitNumber', &
               & l1bFlag)
               if ( l1bFlag == -1 ) then
                  GlobalAttributes%OrbNum = -1
               else
                  GlobalAttributes%OrbNum = OrbNum
               end if
              call ReadL1BAttribute (L1BFile, OrbPeriod, 'OrbitPeriod', &
               & l1bFlag)
               if ( l1bFlag == -1 ) then
                  GlobalAttributes%OrbPeriod = -1.0
               else
                  GlobalAttributes%OrbPeriod = OrbPeriod
               end if
            if ( details > -4 ) call output &
              & ('finished readL1BAttribute in global_setting', advance='yes')
          else
            call announce_error(0, &
            & '*** Unable to find L1BOA file ***', &
            & just_a_warning = .true.)
          end if
        case ( s_l1brad )
          if ( restricted ) call notAllowed ( son, spec_restricted )
          if ( .not. NEED_L1BFILES ) then
            call MLSL2Message ( MLSMSG_Warning, ModuleName, &                      
            & 'l1brad File not needed -- and so ignored' )
            cycle
          endif
          the_hdf_version = LEVEL1_HDFVERSION
          call l1bradSetup ( son, filedatabase, F_FILE, &
            & hdfVersion=the_hdf_version )
          sub_rosa_index = sub_rosa(subtree(2,subtree(2, son)))
          call get_string ( sub_rosa_index, FilenameString, strip=.true. )
          if( switchDetail(switches, 'pro') > -1 ) then                            
            call proclaim(FilenameString, 'l1brad', &                   
            & hdfVersion=the_hdf_version) 
          end if
          L1BFile => GetMLSFileByName(filedatabase, FilenameString)
          if ( .not. associated(L1BFile) ) then
            call announce_error(0, &
            & '*** Unable to find L1BRAD file ***' // trim(FilenameString), &
            & just_a_warning = .true.)
          end if
        case ( s_l2parsf )
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'This version does not use staging file for slave Join commands' )
        case ( s_makePFA )
          call Make_PFAData ( son, returnStatus )
          error = max(error, returnStatus)
        case ( s_pfaData )
          call Get_PFAdata_from_l2cf ( son, name, returnStatus )
          error = max(error, returnStatus)
        case ( s_readPFA )
          call read_PFAdata ( son, name, returnStatus )
          error = max(error, returnStatus)
        case ( s_writePFA )
          call write_PFAdata ( son, returnStatus )
          error = max(error, returnStatus)
        case ( s_time )
          if ( timing .and. .not. reset ) then
            call sayTime ( 'global_settings', t1=t1, cumulative=.false. )
          else
            call time_now ( t1 )
            timing = .true.
          end if
          call output ( ' Finished time command in global settings', advance='yes' )
        case ( s_tGrid, s_vGrid )
          call decorate ( son, AddVGridToDatabase ( vGrids, &
            & CreateVGridFromMLSCFInfo ( name, son, l2gpDatabase, returnStatus ) ) )
          error = max(error, returnStatus)
        case default
          call announce_error(son, 'unrecognized global settings spec')
        end select
      end if
    end do

    if ( DEEBUG ) call output( 'done with statements', advance='yes' )

    ! Any time conversions?
    if ( restricted ) then
      ! Not if we're a callable forward model server
      call FinishUp
      return
    elseif( .not. NEED_L1BFILES ) then
      ! w/o an l1boa file we'll trust the user to have supplied start, end times
      ! (So we check that she did)
      if ( .not. ( &
        & got(p_starttime) .and. got(p_endtime) ) &
        & ) then
        error = 1
        call MLSL2Message( MLSMSG_Warning, ModuleName, &
          & 'start, end times must be supplied if there is no l1boa file' )
      elseif ( LeapSecFileName /= '' ) then
        call ToolkitTimeConversion
      elseif ( LEAPSINDATESMODULE ) then
        ! Without a leapsec file, let's use date_module's built-in feature
        call datesModuleTimeConversion
      endif
      call FinishUp
      return
    endif

    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &                      
      & 'l1boa File not found--hope you dont need one' )
      call FinishUp
      return
    elseif ( L1BFile%hdfVersion /= hdfversion_5 ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &                      
      & 'l1boa File is the older hdf4' )
    else
      ! Check on module names--do they agree with group names in L1BOA file?
      ! If not, overwrite them
      call MLS_OpenFile ( L1BFile )
      call GetAllHDF5GroupNames ( L1BFile%FileID%f_id, moduleNames )
      if ( verboser ) call outputNamedValue ( 'group names', trim(moduleNames) )
      call mls_closeFile ( L1BFile )
      do i=1, size(modules)
        call GetModuleName ( i, itsName )
        if ( verboser ) call outputNamedValue ( 'module name', trim(itsname) )
        j = StringElementNum( lowercase(moduleNames), lowercase(itsName), countEmpty )
        if ( verboser ) call outputNamedValue ( 'element num', j )
        if ( j > 0 ) then
          if ( itsName /= &
            & StringElement( moduleNames, j, countEmpty ) ) &
            & modules(i)%nameString = &
            & StringElement( moduleNames, j, countEmpty )
        else
            modules(i)%nameString = StringElement( moduleNames, i, countEmpty )
        endif
      enddo
      if ( verbose ) then
        call Dump( modulenames, 'module names' )
        call Dump_Modules
      endif
    endif

    the_hdf_version = &
      & L1BFile%HDFVersion
    if ( the_hdf_version == FILENOTFOUND ) then                                          
      call MLSL2Message ( MLSMSG_Error, ModuleName, &                      
      & 'File not found; make sure the name and path are correct' &
      & // trim(L1BFile%Name) )
    else if ( the_hdf_version <= 0 ) then                                          
      call MLSL2Message ( MLSMSG_Error, ModuleName, &                      
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
    end if

    if ( TOOLKIT ) then
      if ( DEEBUG ) call output( 'Using toolkit', advance='yes' )
    elseif ( .not. (got(p_starttime) .or. got(p_endtime) ) ) then
       call timesFromMafOffsets
    elseif ( LeapSecFileName == '' .and. .not. LEAPSINDATESMODULE ) then
      ! add maf offsets to start, end times
      ! or convert them to tai93
      ! This is optional way to define processingRange if using PCF
      ! It becomes mandatory if not using PCF
       call timesFromMafOffsets
    elseif ( len_trim(LeapSecFileName) > 0 ) then
      call ToolkitTimeConversion
    elseif ( got(p_starttime) .and. got(p_endtime) ) then
      call datesModuleTimeConversion
    end if
    ! call outputNamedValue( 'processingRange%startTime', processingRange%startTime )
    ! call outputNamedValue( 'processingRange%EndTime', processingRange%EndTime )

    if ( .not. TOOLKIT ) then
      call startTable
      call addRow_header ( 'Global Settings', 'c' )
      call addRow_divider ( '-' )
      ! Store appropriate user input as global attributes
      GlobalAttributes%StartUTC = l2pcf%StartUTC
      GlobalAttributes%EndUTC = l2pcf%EndUTC
      if ( len_trim(GlobalAttributes%PGEVersion) < 1 ) &
        & GlobalAttributes%PGEVersion = l2pcf%PGEVersion
      if ( LeapSecFileName /= '' ) call FillTAI93Attribute ( LeapSecFileName )
      ! We don't check on returnStatus--dateless or absolute utc are ok
      call utc_to_yyyymmdd(GlobalAttributes%StartUTC, returnStatus, &
        & GlobalAttributes%GranuleYear, GlobalAttributes%GranuleMonth, &
        & GlobalAttributes%GranuleDay) 
      ! If mm < 0, then it's yyyy-Doy format, so let's find the actual
      ! month and store it as a negative integer in GranuleMonth
      if ( GlobalAttributes%GranuleMonth == -1 ) then
        call yyyyDoy_to_mmdd( GlobalAttributes%GranuleYear, &
          & mm, dd, GlobalAttributes%GranuleDay )
        GlobalAttributes%GranuleMonth = -mm
      endif
      ! We'll possibly need the first and last MAF counter numbers, especially
      ! if gaps occur
      ! For now, just look for them in l1boa
      ! Later you may look also in l1brad files
      GlobalAttributes%LastMAFCtr = FindMaxMAF ( L1BFile, &
        & GlobalAttributes%FirstMAFCtr )
      ! call outputNamedValue ( 'Last MAF', GlobalAttributes%LastMAFCtr )
      ! call outputNamedValue ( 'First MAF', GlobalAttributes%FirstMAFCtr )
      call addRow ( 'Last MAF', GlobalAttributes%LastMAFCtr )
      call addRow ( 'First MAF', GlobalAttributes%FirstMAFCtr )
      call outputTable ( sep='|', border='-' )
    end if

    ! Have we overridden the Bright Object names? Can we find them in l1boa?
    if ( got(p_brightObjects) ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &                      
      & 'You overrode names of Bright objects found in l1boa file' )    
    elseif( L1BFile%hdfVersion /= HDFVERSION_5 ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &                      
      & 'Names of Bright objects missing from (hdf4) l1boa file' )    
    elseif( .not. IsHDF5AttributeInFile(L1BFile%name, 'BO_name') ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &                      
      & 'Names of Bright objects missing from l1boa file' )    
    else
      if ( DEEBUG ) call output( 'About to read Bright Objects', advance='yes' )
      wasAlreadyOpen = L1BFile%stillOpen
      if ( .not. wasAlreadyOpen ) call mls_OpenFile(L1BFile)
      L1BFile%fileID%sd_id = 0 ! So we don't look here for the attribute
      ! We still need to open the root group '/'
      call h5gopen_f ( L1BFile%fileID%f_id, '/', L1BFile%fileID%grp_id, ReturnStatus )
      call GetHDF5Attribute( L1BFile, 'BO_name', BO_names )
      call Array2List ( BO_names, BrightObjects )
      call h5gclose_f ( L1BFile%fileID%grp_id, ReturnStatus )
      ! Now were any bright objects visible today?
      call ReadL1BData ( L1BFile,'/GHz/BO_stat', BO_stat, noMAFs, &
        & l1bflag, NeverFail= .true. )
      ! We will pay no mind to "Fill" values
      ! meaning we must zero them out
      BO_stat%intField = max( 0, BO_stat%intField )
      BO_today = ' '
      do i=0, size(BO_names)
        if ( len_trim(BO_names( max(i,1) )) < 1 ) cycle
        if ( any( isBitSet( BO_stat%intField(1, :, :), i ) ) ) then
          if ( i == 0 ) then
            BO_today = catLists( BO_today, 'moon(sp.port)', inseparator=' ')
          else
            BO_today = catLists( BO_today, trim(BO_names(i)), inseparator=' ')
          endif
        endif
      enddo
      if ( .not. wasAlreadyOpen ) call mls_CloseFile(L1BFile)
      call DeallocateL1BData ( BO_stat )
      if ( OUTPUTTHISMONTHSCAL ) then
        call outputCalendar( l2pcf%startutc, dateNote=BO_today, moonphases=.true. )
      else
        call output ( 'Bright objects today:', advance='yes' )
        call output ( trim_safe(BO_today), advance='yes' )
      endif
    endif

    if ( specialDumpFile /= ' ' ) &
      & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
    ! Perhaps dump global settings
    if ( details > -4 ) &
      & call dump_global_settings( processingRange, filedatabase, &
      & DirectDatabase, ForwardModelConfigDatabase, &
      & LeapSecFileName, details-detailReduction )

    ! Take notice of the types of apriori files being used
    if ( APrioriFiles%dao // AprioriFiles%ncep // AprioriFiles%geos5 &
      &  == ' ' ) then
      GlobalAttributes%MiscNotes = catLists(GlobalAttributes%MiscNotes, &
        & 'No gmao or ncep files--falling back to climatology', '\')
    elseif ( APrioriFiles%dao // AprioriFiles%geos5 == ' ' ) then
      GlobalAttributes%MiscNotes = catLists(GlobalAttributes%MiscNotes, &
        & 'No gmao files--falling back to ncep', '\')
    endif

    if ( len_trim(APrioriFiles%dao) > 0 ) then
      GlobalAttributes%MiscNotes = catlists( GlobalAttributes%MiscNotes, &
        & 'apriori(dao)' )
      GlobalAttributes%MiscNotes = catlists( GlobalAttributes%MiscNotes, &
        & trim(APrioriFiles%dao) )
    endif
    if ( len_trim(APrioriFiles%ncep) > 0 ) then
      GlobalAttributes%MiscNotes = catlists( GlobalAttributes%MiscNotes, &
        & 'apriori(ncep)' )
      GlobalAttributes%MiscNotes = catlists( GlobalAttributes%MiscNotes, &
        & trim(APrioriFiles%ncep) )
    endif
    if ( len_trim(APrioriFiles%geos5) > 0 ) then
      GlobalAttributes%MiscNotes = catlists( GlobalAttributes%MiscNotes, &
        & 'apriori(geos5)' )
      GlobalAttributes%MiscNotes = catlists( GlobalAttributes%MiscNotes, &
        & trim(APrioriFiles%geos5) )
    endif
    call FinishUp

  contains

    ! ---------------------------------------------  FinishUp  -----
    ! Any last minute housekeeping tasks
    subroutine FinishUp
      if ( error /= 0 ) &
        & call MLSL2Message ( MLSMSG_Error,ModuleName, &
        & 'Problem with global settings section' )
      if ( warning /= 0 ) &
        & call MLSL2Message ( MLSMSG_Warning,ModuleName, &
        & 'Possible problem with global settings section' )

      if ( specialDumpFile /= ' ' ) &
        & call revertOutput
      call trace_end ( 'SET_GLOBAL_SETTINGS', cond=toggle(gen) )
      if ( timing ) call sayTime ( 'global_settings', cumulative=.false. )

    end subroutine FinishUp

    ! ---------------------------------------  datesModuleTimeConversion  -----
    ! Convert utc time strings to tai93 using dates module
    subroutine datesModuleTimeConversion
      if ( isUTCInRange(start_time_string) .and. &
        & isUTCInRange(end_time_string) ) then
        call output( 'Using datesModule to convert times', advance='yes' )
        processingrange%starttime = utc2tai93s ( start_time_string, leapsec=.true. )
        processingrange%endtime = utc2tai93s ( end_time_string, leapsec=.true. )
      else
        error = 1
        call outputNamedValue ( 'start time', trim(start_time_string) )
        call outputNamedValue ( 'end time', trim(end_time_string) )
        call MLSL2Message( MLSMSG_Warning, ModuleName, &
          & 'start, end times not in range' )
      endif
    end subroutine datesModuleTimeConversion

    ! ---------------------------------------  timesFromMafOffsets  -----
    ! add maf offsets to start, end times
    ! (unless you didn't input start, end times)
    subroutine timesFromMafOffsets
      if ( DEEBUG ) call output( 'Using mafOffsts to convert times', advance='yes' )
      ! 1st--check that have L1BOA
      if ( L1BFile%FileID%f_id < 1 ) then
        call announce_error(son, &
          & 'L1BOA file required by global data--but not set')
      end if

      quantity = 'MAFStartTimeTAI'
      l1bItemName = AssembleL1BQtyName ( quantity, the_hdf_version, .false. )
      if ( DEEBUG ) call output( 'About to read L1B file: ' // trim(l1bItemName), &
        & advance='yes' )
      call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, dontPad=.true.)
      if ( l1bFlag==-1 ) then
        call announce_error(son, &
          & 'unrecognized MAFStartTimeTAI in L1BOA file')
        minTime = 0.
        maxTime = 0.
      else
        minTime = l1bField%dpField(1,1,1)
        maxTime = l1bField%dpField(1,1,noMAFs) ! This is start time of last MAF
      end if
      call DeallocateL1BData ( l1bField )

    if ( .not. got(p_starttime) ) then
      processingRange%startTime = minTime
    elseif ( startTimeIsAbsolute ) then
      processingRange%startTime = start_time_from_1stMAF
    elseif ( LeapSecFileName /= '' ) then
      if ( DEEBUG ) call output( 'About to read leapsec file' // &
        & trim(LeapSecFileName), advance='yes' )
      if ( precedesUTC ( '1993-01-01', start_time_string )  ) then
        returnStatus = mls_utctotai(trim(LeapSecFileName), start_time_string, &
        & processingrange%starttime)
        if ( DEEBUG ) call output( 'Read leapsec file', advance='yes' )
        if ( returnStatus /= 0 ) then
          call announce_error(0, &
          & 'Error converting start time in mls_utctotai; code number: ')
          call output(returnStatus, advance='yes')
        end if
      elseif ( NEGATIVETAI93OK ) then
        if ( .false. ) call ResetStartingDate( '1961-01-01' )
        call output( 'The starting time is before our nominal 1993 start date', advance='yes' )
        call output( '(but we allow it to go negative)', advance='yes' )
        processingrange%starttime = &
          & -secondsbetween2utcs ( start_time_string, '1993-01-01' )
        if ( .false. ) call ResetStartingDate( '1961-01-01' ) ! ( '1993-01-01' )
      else
        ! The starting time is before our nominal 1993 start date
        ! We'll use the dates_module as a fallback
        call output( 'The starting time is before our nominal 1993 start date', advance='yes' )
        if ( .false. ) call ResetStartingDate( '1961-01-01' )
        processingrange%starttime = &
          & secondsbetween2utcs ( '1961-01-01', start_time_string )
      endif
    else if ( got(p_starttime) ) then
      processingrange%starttime = minTime + start_time_from_1stMAF
    else if ( .not. TOOLKIT ) then
      processingrange%starttime = minTime
    end if

    if ( .not. got(p_starttime) ) then
      processingRange%endTime = maxTime
    elseif ( stopTimeIsAbsolute ) then
      processingRange%endTime = end_time_from_1stMAF
    elseif ( LeapSecFileName /= '' ) then
      if ( precedesUTC ( '1993-01-01', end_time_string ) ) then
        returnStatus = mls_utctotai(trim(LeapSecFileName), end_time_string, &
        & processingrange%endtime)
        if ( returnStatus /= 0 ) then
          call announce_error(0, &
          & 'Error converting end time in mls_utctotai; code number: ')
          call output(returnStatus, advance='yes')
        end if
      elseif ( NEGATIVETAI93OK ) then
        if ( .false. ) call ResetStartingDate( '1961-01-01' )
        call output( 'The ending time is before our nominal 1993 start date', advance='yes' )
        call output( '(but we allow it to go negative)', advance='yes' )
        processingrange%endtime = &
          & -secondsbetween2utcs ( end_time_string, '1993-01-01' )
        if ( .false. ) call ResetStartingDate( '1961-01-01' ) ! ( '1993-01-01' )
      else
        ! The starting time is before our nominal 1993 start date
        ! We'll use the dates_module as a fallback
        call output( 'The starting time is before our nominal 1993 start date', advance='yes' )
        if ( .false. ) call ResetStartingDate( '1961-01-01' )
        processingrange%endtime = &
          & secondsbetween2utcs ( '1961-01-01', end_time_string )
      endif
    else if ( LEAPSINDATESMODULE ) then
      ! Without a leapsec file, let's use date_module's built-in feature
      processingrange%endtime = utc2tai93s ( end_time_string, leapsec=.true. )
    else if ( got(p_endtime) ) then
      processingrange%endtime = minTime + end_time_from_1stMAF
    else if ( .not. TOOLKIT ) then
      processingrange%endtime = maxTime + 1.0
    end if
    end subroutine timesFromMafOffsets

    ! ------------------------------------------  ToolkitTimeConversion  -----
    ! Convert utc time strings to tai93 using toolkit procedures
    subroutine ToolkitTimeConversion
      call output( 'Using toolkit to convert times', advance='yes' )
      if ( DEEBUG ) call output( 'About to read leapsec file' // &
        & trim(LeapSecFileName), advance='yes' )
      if ( precedesUTC ( '1993-01-01', start_time_string ) ) then
        returnStatus = mls_utctotai(trim(LeapSecFileName), start_time_string, &
          & processingrange%starttime)
        returnStatus = mls_utctotai(trim(LeapSecFileName), end_time_string, &
          & processingrange%endtime)
        if ( DEEBUG ) call output( 'Read leapsec file', advance='yes' )
        if ( returnStatus /= 0 ) then
          call announce_error(0, &
          & 'Error converting start, end time in mls_utctotai; code number: ')
          call output(returnStatus, advance='yes')
        end if
      elseif ( NEGATIVETAI93OK ) then
        if ( .false. ) call ResetStartingDate( '1961-01-01' )
        call output( 'The starting time is before our nominal 1993 start date', advance='yes' )
        call output( '(but we allow it to go negative)', advance='yes' )
        call outputNamedValue( 'start_time_string', trim(start_time_string) )
        call outputNamedValue( 'end_time_string', trim(end_time_string) )
        processingrange%starttime = &
          & -secondsbetween2utcs ( start_time_string, '1993-01-01' )
        processingrange%endtime = &
          & -secondsbetween2utcs ( end_time_string, '1993-01-01' )
        if ( .false. ) call ResetStartingDate( '1961-01-01' ) ! ( '1993-01-01' )
      else
        ! The starting time is before our nominal 1993 start date
        ! We'll use the dates_module as a fallback
        if ( .false. ) call ResetStartingDate( '1961-01-01' )
        processingrange%starttime = &
          & secondsbetween2utcs ( '1961-01-01', start_time_string )
        processingrange%endtime = &
          & secondsbetween2utcs ( '1961-01-01', end_time_string )
      endif
    end subroutine ToolkitTimeConversion

    ! ---------------------------------------------  Announce_Error  -----
    subroutine Announce_Error ( Lcf_where, Full_message, Use_toolkit, &
      & Error_number, just_a_warning )

      ! Arguments

      integer, intent(in) :: Lcf_where
      character(len=*), intent(in) :: Full_message
      logical, intent(in), optional :: Use_toolkit
      integer, intent(in), optional :: Error_number
      logical, intent(in), optional :: just_a_warning

      ! Local
      logical :: Just_print_it, my_warning
      logical, parameter :: Default_output_by_toolkit = .true.

      just_print_it = .not. default_output_by_toolkit
      if ( present(use_toolkit) ) just_print_it = .not. use_toolkit
      if ( present(just_a_warning) ) then
        my_warning = just_a_warning
      else
        my_warning = .false.
      end if
      if ( my_warning ) warning = max(warning,1)

      if ( .not. just_print_it ) then
        if ( .not. my_warning ) then
          error = max(error,1)
          call startErrorMessage ( lcf_where )

          call output ( "The " );
          if ( lcf_where > 0 ) then
            call dump_tree_node ( lcf_where, 0 )
          else
            call output ( '(no lcf tree available)' )
          end if

          call output ( " Caused the following error:", advance='yes', &
           & from_where=ModuleName)

        end if

        call output ( trim(full_message), advance='yes', &
          & from_where=ModuleName)

        if ( present(error_number) ) then
          if ( my_warning ) then
           call output ( 'Warning number ', advance='no' )
          else
            call output ( 'Error number ', advance='no' )
          end if

          call output ( error_number, places=9, advance='yes' )
        end if
      else

        if ( .not. my_warning ) then
        call output ( '***Error in module ' )
        call output ( ModuleName, advance='yes' )
        end if

        call output ( trim(full_message), advance='yes' )
        if ( present(error_number) ) then
         if ( my_warning ) then
          call output ( 'Warning number ' )
        else
          call output ( 'Error number ' )
         end if
          call output ( error_number, advance='yes' )
        end if
      end if

    end subroutine Announce_Error

    ! ------------------------------------------  dump_global_settings  -----
    subroutine dump_global_settings ( processingRange, &
      & filedatabase, DirectDatabase, ForwardModelConfigDatabase, &
      & LeapSecFileName, details )
    use Dump_1, only: Dump
    use Open_Init, only: DumpL1BDatabase
      ! Dump info obtained during OpenAndInitialize and global_settings:
      ! L1B databse
      ! L1OA file
      ! Start and end times
      ! output version
      ! cycle number
      ! logfile name

      ! Arguments
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (TAI93_Range_T) :: processingRange ! Data processing range
      type (DirectData_T), dimension(:), pointer :: DirectDatabase
      type(ForwardModelConfig_T), dimension(:), pointer :: &
        & ForwardModelConfigDatabase

      character(len=*), intent(in) :: LeapSecFileName
      ! The following determines the level of detail to expose:
      ! -1 Skip even counterMAF
      ! -2 Skip all but name (default)
      ! >0 Dump even multi-dim arrays
      integer, intent(in) :: details

      ! Local
      integer ::                              i
      character (len=*), parameter ::         TIME_FORMAT = '(1pD18.12)'
      integer                              ::  hdfVersion
      type(MLSFile_T), pointer             :: L1BFile

      ! Begin
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      hdfVersion = L1BFile%HDFVersion
      if ( hdfversion <= 0 ) &                                          
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &                    
        & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )  
      ! version = 1

      call output ( '============ Global Settings ============', advance='yes' )
      call output ( ' ', advance='yes' )

      call output ( 'L1B database:', advance='yes' )
      call DumpL1BDatabase ( filedatabase, Details )
      call dump(DirectDatabase, Details)

      call startTable
      call addRow_header ( 'Run Info', 'c' )
      call addRow_divider ( '-' )
      call addRow ( 'Start Time', l2pcf%startutc )
      call addRow ( 'End Time', l2pcf%endutc )

      call addRow ( 'Start Time (tai)', processingrange%starttime, format=time_format )
      call addRow ( 'End Time (tai)', processingrange%endtime, format=time_format )
      call addRow ( 'Processing Range', processingrange%endtime-processingrange%starttime )
      if ( LeapSecFileName /= '' ) then
        call addRow ( 'Leap Seconds File', LeapSecFileName )
      endif
      call addRow ( 'PGE version', l2pcf%PGEVersion )
      call addRow ( 'cycle', l2pcf%cycle )
      call addRow ( 'RunID', l2pcf%RunID )
      call addRow ( 'Log file name', l2pcf%logGranID )
      call outputTable ( sep=' ', border='-' )

      ! Dump special hashes
      call NewLine
      call Dump ( countEmpty=.true., &
        & keys=l2pcf%spec_keys, values=l2pcf%spec_mcfnames, &
        & name='l2gp species, mcf : doi', separator=',', &
        & ExtraValues= l2pcf%spec_doinames)
      call blanks ( 80, FillChar='-', advance='yes' )

      call output ( 'Bright Objects:   ', advance='yes' )
      call output ( 'bit #             Cause   ', advance='yes' )
      call output ( '0' )
      call blanks (2)
      call output ( 'Moon in space port', advance='yes' )
      do i=1, NumStringElements(brightObjects, countEmpty)
        call output ( i )
        call blanks (2)
        call output ( TRIM(stringElement(brightObjects, i, .true.)), &
          & advance='yes' )
      enddo

      if ( details > -2 ) then
        call output ( ' ', advance='yes' )
        call dump(ForwardModelConfigDatabase, details=9, skipPFA=.true.)
      endif
      call output ( '============ End Global Settings ============', advance='yes' )

    end subroutine dump_global_settings

    ! -----------------------------------------------  NotAllowed  -----
    subroutine NotAllowed ( where, why )
      integer, intent(in) :: Where ! tree index
      integer, intent(in) :: Why   ! param_restricted or spec_restricted

      call startErrorMessage ( where )
      select case ( why )
      case ( param_restricted )
        call output ( 'Parameter ' )
        call display_string( parm_indices(param_id) )
      case ( spec_restricted )
        call output ( ' Specification ' )
        call display_string( spec_indices(spec_id) )
      end select
      call output ( ' is not allowed.', advance='yes' )
      call MLSL2Message ( MLSMSG_Error, moduleName, &
        'Prohibited parameter or specification in GlobalSettings section' )
    end subroutine NotAllowed

  ! ---------------------------------------------  proclaim  -----
  subroutine proclaim ( FullName, l1_type, hdfVersion )
    use MLSFiles, only: MLS_HDF_Version, Split_Path_Name, WildCardHDFVersion
    character(len=*), intent(in)   :: FullName
    character(len=*), intent(in)   :: l1_type
    integer, optional,  intent(in) :: hdfVersion

    ! Local variables
    integer                        :: myhdfVersion
    character(len=len(FullName))   :: name, path
    integer, save                  :: trip = 0
    ! Executable
    trip = trip + 1
    if ( trip < 2 ) call StyledOutput ( 'Level 1 products', options='--Banner' )
    call split_path_name ( FullName, path, name )
    call StartTable
    call addRow ( 'type', trim(l1_type) )
    if ( present(hdfVersion) ) then
      if ( hdfVersion == WildCardHDFVersion ) then
        myhdfVersion = mls_hdf_version(trim(Name))
      else
        myhdfVersion = hdfVersion
      end if
      call addRow ( 'hdf version', myhdfVersion )
    end if
    call addRow ( 'path', trim(path) )
    call addRow ( 'name', trim(name) )
    Call OutputTable ( sep='|', border='-' )
  end subroutine proclaim

    ! --------------------------  CreateDirectTypeFromMLSCFInfo  -----
    function CreateDirectTypeFromMLSCFInfo ( root, DirectFile ) result (Direct)
    integer, intent(in) :: ROOT         ! Tree node
    type (DirectData_T) :: Direct
    type (MLSFile_T)    :: DirectFile
    ! Local variables
    integer :: SON                      ! Tree node
    integer :: GSON                     ! Tree node
    integer :: I                        ! Loop counters
    integer :: FIELD                    ! Field identifier
    integer :: FILE
    character(len=1024) :: FILENAME     ! Output full filename
    character(len=1024) :: FILE_BASE    ! made up of
    integer :: l2gp_Version
    character(len=1024) :: PATH         ! path/file_base
    integer :: RETURNSTATUS
    logical, parameter :: DEEBUG = .false.
    ! Executable
    call SetupNewDirect(Direct, 0)
    l2gp_Version = 1
    do i = 2, nsons(root)               ! Skip DirectFileName command
      son = subtree ( i, root )
      field = get_field_id ( son )
      if ( nsons(son) == 2 ) gson = subtree(2,son)
      select case ( field )
      case ( f_type )
        Direct%Type = decoration(gson)
        Direct%autoType = Direct%Type
      case ( f_file )
        file = sub_rosa(subtree(2,son))
        Direct%fileIndex = file
      end select
    end do
    RETURNSTATUS = 0
    call get_string ( file, filename, strip=.true. )
    call split_path_name(filename, path, file_base)
    Direct%filenameBase = file_base
    if ( .not. TOOLKIT ) then
      Direct%handle = 0
      Direct%filename = filename
    endif
    if ( Direct%Type ==  l_l2gp ) then
      if ( TOOLKIT ) &
        & Direct%Handle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
        & mlspcf_l2gp_end, &
        & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
        & exactName=Direct%Filename)
      returnStatus = InitializeMLSFile(DirectFile, content = 'l2gp', &
        & name=Direct%Filename, shortName=file_base, &
        & type=l_swath, access=DFACC_CREATE, HDFVersion=HDFVERSION_5, &
        & PCBottom=mlspcf_l2gp_start, PCTop=mlspcf_l2gp_end)
    else if ( Direct%Type ==  l_l2dgg ) then
      if ( TOOLKIT ) &
        & Direct%Handle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
        & mlspcf_l2dgg_end, &
        & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
        & exactName=Direct%Filename)
      returnStatus = InitializeMLSFile(DirectFile, content = 'l2dgg', &
        & name=Direct%Filename, shortName=file_base, &
        & type=l_swath, access=DFACC_CREATE, HDFVersion=HDFVERSION_5, &
        & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
    else if ( Direct%Type ==  l_l2fwm ) then
      if ( TOOLKIT ) &
        & Direct%Handle = GetPCFromRef(file_base, mlspcf_l2fwm_full_start, &
        & mlspcf_l2fwm_full_end, &
        & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
        & exactName=Direct%Filename)
      returnStatus = InitializeMLSFile(DirectFile, content = 'l2fwm', &
        & name=Direct%Filename, shortName=file_base, &
        & type=l_hdf, access=DFACC_CREATE, HDFVersion=HDFVERSION_5, &
        & PCBottom=mlspcf_l2fwm_full_start, PCTop=mlspcf_l2fwm_full_end)
    else
      if ( TOOLKIT ) &
        & Direct%Handle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
        & mlspcf_l2dgm_end, &
        & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
        & exactName=Direct%Filename)
      returnStatus = InitializeMLSFile(DirectFile, content = 'l2dgm', &
        & name=Direct%Filename, shortName=file_base, &
        & type=l_hdf, access=DFACC_CREATE, HDFVersion=HDFVERSION_5, &
        & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
    end if
    if ( returnStatus /= 0 ) call MLSL2Message ( &
       & MLSMSG_Error, ModuleName, &
       & 'Failed in GetPCFromRef for ' // trim(filename) )

    end function CreateDirectTypeFromMLSCFInfo

  end subroutine Set_Global_Settings

! =====     Private Procedures     =====================================

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: global_settings.f90,v 2.182 2021/04/01 23:51:37 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Global_Settings

! $Log: global_settings.f90,v $
! Revision 2.182  2021/04/01 23:51:37  pwagner
! L1MAFToL2Profile may return matching Lat and Phi
!
! Revision 2.181  2021/03/19 15:20:49  pwagner
! Added the optional arg MIF to MAF v. profile functions
!
! Revision 2.180  2021/02/05 05:20:06  pwagner
! Avoids unassocialed L2GPData
!
! Revision 2.179  2019/04/18 16:30:10  pwagner
! Overwrite GlobalAttributes%PGEVersion only if currently blank
!
! Revision 2.178  2018/11/01 23:16:00  pwagner
! Improve appearance of settings when dumped
!
! Revision 2.177  2018/07/27 23:19:53  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.176  2017/11/15 00:11:44  pwagner
! Use OutputTable to Dump list of level 1 files
!
! Revision 2.175  2017/07/27 16:42:38  pwagner
! If yyyy-Doy, store actual actual month number as neg int. in GlobalAttributes%GranuleMonth
!
! Revision 2.174  2017/07/10 18:58:16  pwagner
! CamelCase; abandon all the extra ResetStartingDates
!
! Revision 2.173  2017/01/19 23:52:03  pwagner
! Improve appeearance when dumping Run Info
!
! Revision 2.172  2017/01/07 01:14:51  pwagner
! Print moon phases on calendar
!
! Revision 2.171  2016/11/09 17:20:01  pwagner
! Fixed error when l2cf processes param
!
! Revision 2.170  2016/11/08 17:32:35  pwagner
! Use SayTime subroutine from time_m module; process /reset field
!
! Revision 2.169  2016/09/23 00:11:52  pwagner
! Improve appearance of Dumps
!
! Revision 2.168  2016/09/14 20:08:45  pwagner
! heck if we set start, end times if no l1boa; also that they are reasonable
!
! Revision 2.167  2016/08/09 21:47:42  pwagner
! Fix error in FindMaxMAF; print module names only if verbose
!
! Revision 2.166  2016/07/28 23:39:32  pwagner
! Fixed error introduced with last commit
!
! Revision 2.165  2016/07/28 19:54:30  pwagner
! Guard against older hdf4 l1boa
!
! Revision 2.164  2016/07/28 01:45:07  vsnyder
! Refactor dump and diff
!
! Revision 2.163  2016/07/27 23:02:59  pwagner
! Works better with Aircraft-borne instrument data
!
! Revision 2.162  2016/07/22 20:07:16  pwagner
! Fix typos in output
!
! Revision 2.161  2015/09/02 23:17:43  pwagner
! Bomb promptly if no DEM files instead of waiting until run ends
!
! Revision 2.160  2014/03/31 23:50:47  pwagner
! Let tai93 times become negative
!
! Revision 2.159  2014/03/26 17:49:05  pwagner
! Fixed old bugs when startTime, endTime omitted
!
! Revision 2.158  2014/03/19 19:54:47  pwagner
! Fixed a gold-bick breaking bug introduced with last fix
!
! Revision 2.157  2014/03/19 17:37:07  pwagner
! Repaired bug breaking gold brick
!
! Revision 2.156  2014/03/18 17:46:09  pwagner
! Fixed bug in use of got(:) array
!
! Revision 2.155  2014/03/18 17:15:24  pwagner
! Can get leapseconds from dates module if run sans toolkit
!
! Revision 2.154  2014/03/07 19:23:17  pwagner
! Name_Len changed to nameLen; got from MLSCommon
!
! Revision 2.153  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.152  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.151  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.150  2013/10/09 23:43:17  vsnyder
! Add Evaluate_Variable, declare param correctly
!
! Revision 2.149  2013/09/25 01:04:33  pwagner
! Added DEM stuff
!
! Revision 2.148  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.147  2013/08/30 02:45:49  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.146  2013/08/21 00:27:13  pwagner
! Code around nominal 1993 starting date limitation; awaiting better solution
!
! Revision 2.145  2012/08/16 17:51:07  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.144  2012/04/20 00:46:13  pwagner
! Treats MAF as 0-based; more robustly handles crashed chunks
!
! Revision 2.143  2012/03/28 20:08:24  pwagner
! l2parsf spec generates warning--slave tasks lost ability to join quantities
!
! Revision 2.142  2012/03/15 22:51:15  vsnyder
! Add IGRF_file parameter, some cannonball polishing
!
! Revision 2.141  2011/11/04 00:08:01  pwagner
! Made USEd entities all caps
!
! Revision 2.140  2011/10/05 00:14:45  pwagner
! Added functions to convert between MAFs, profile numbers
!
! Revision 2.139  2011/06/29 21:50:48  pwagner
! Some cases may safely omit l1b files
!
! Revision 2.138  2010/10/19 00:04:36  pwagner
! Tried to fix callstack overflow when restricted
!
! Revision 2.137  2010/05/23 03:19:48  honghanh
! Modify the restriction for the callable forward model
!
! Revision 2.136  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
! Revision 2.135  2009/10/05 23:40:35  pwagner
! Moved use statements to module scope to speedup Lahey; this is the last time we do that
!
! Revision 2.134  2009/10/01 19:56:35  vsnyder
! Restrict some functionality in callable forward model mode
!
! Revision 2.133  2009/08/26 17:16:15  pwagner
! Note types of apriori files in file attribute MiscNotes
!
! Revision 2.132  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.131  2009/03/05 16:21:36  pwagner
! fgrid switch dumps each fgrid
!
! Revision 2.130  2008/12/18 21:13:46  pwagner
! May now dump an l2pc or allL2PCs (use with caution)
!
! Revision 2.129  2008/08/27 20:00:59  vsnyder
! Add PRINT to not_used_here
!
! Revision 2.128  2007/12/14 01:50:47  pwagner
! Zero out Fill values from BO_stat
!
! Revision 2.127  2007/10/04 20:43:12  vsnyder
! Remove unused symbols
!
! Revision 2.126  2007/09/24 20:26:03  pwagner
! Prints this months calendar and shows todays bright objects
!
! Revision 2.125  2007/08/17 00:32:41  pwagner
! Unneeded changes
!
! Revision 2.124  2007/06/21 00:55:22  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.123  2007/03/26 18:06:59  pwagner
! Extra debuggung statements; may be useful if get 'Filesize limit exceeded'
!
! Revision 2.122  2007/01/12 00:36:41  pwagner
! New but unused option to skip check for correct month l2pc files
!
! Revision 2.121  2006/10/20 16:52:26  pwagner
! toolkit-using runs will warn but ignore unwanted global settings
!
! Revision 2.120  2006/09/21 18:48:07  pwagner
! Reduce level of dumps in SIDS version
!
! Revision 2.119  2006/07/24 20:35:21  pwagner
! Fixed bug when stopAfterSection is blank
!
! Revision 2.118  2006/07/21 20:12:48  pwagner
! Can select what section to stop after
!
! Revision 2.117  2006/07/20 23:39:53  vsnyder
! Remove unused declarations and USEs
!
! Revision 2.116  2006/06/12 19:28:52  pwagner
! Fallback to climatology noted only if all of ncep, goes4/5 missing
!
! Revision 2.115  2006/04/21 22:28:45  vsnyder
! Allow FlushPFA in global settings section
!
! Revision 2.114  2006/03/15 23:52:24  pwagner
! Removed InputVersion component from PCF, l2cf
!
! Revision 2.113  2006/02/15 00:02:05  pwagner
! Moved revertOutput call
!
! Revision 2.112  2006/02/10 21:16:43  pwagner
! dumps may go to special dumpfile
!
! Revision 2.111  2006/02/06 22:54:51  pwagner
! Should print warnings, not bomb if l1b files not found
!
! Revision 2.110  2006/01/26 00:35:12  pwagner
! demoted more use statements from module level to speed Lahey compiles
!
! Revision 2.109  2006/01/10 23:51:11  pwagner
! Fixed segment fault when hdf4 l1boa file
!
! Revision 2.108  2005/11/12 00:58:10  pwagner
! Fixed bug in reading BO_names attribute from l1boa file
!
! Revision 2.107  2005/11/11 21:46:07  pwagner
! Added reading bright objects from l1boa; removed unused settings
!
! Revision 2.106  2005/09/22 23:37:45  pwagner
! date conversion procedures and functions all moved into dates module
!
! Revision 2.105  2005/08/19 23:33:03  pwagner
! FwdMdlDB now dumped when dumping global settings
!
! Revision 2.104  2005/07/21 23:45:33  pwagner
! Removed unused l1b fileinfo fields from l2pcf
!
! Revision 2.103  2005/07/12 17:36:16  pwagner
! Dropped global attribute InputVersion; fills MiscNotes if no dao
!
! Revision 2.102  2005/06/14 20:42:38  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.101  2005/06/04 00:14:53  vsnyder
! Import MLSMSG_Warning
!
! Revision 2.100  2005/06/03 23:58:48  pwagner
! Hope it wont bomb if no l1boa
!
! Revision 2.99  2005/06/03 02:11:14  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! get VGrids from VGridsDatabase instead of a dummy argument.
!
! Revision 2.98  2005/05/31 17:51:17  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.97  2005/05/26 22:34:58  vsnyder
! use if (...) continue to ignore a function result
!
! Revision 2.96  2005/05/02 22:59:59  vsnyder
! Add PFAFile command
!
! Revision 2.95  2005/01/27 21:22:04  vsnyder
! Different interface to ReadPFAData
!
! Revision 2.94  2005/01/12 03:18:22  vsnyder
! Read and write PFAData in HDF5
!
! Revision 2.93  2004/12/31 02:43:05  vsnyder
! Working on read/write PFA database
!
! Revision 2.92  2004/12/14 22:52:38  pwagner
! Changes related to stopping early
!
! Revision 2.91  2004/12/13 20:19:48  vsnyder
! Added MakePFA, PFAData, WritePFA.  Improved error handling.  Removed dumps
! triggered by switches == vgrid2 or vgrid, since the dump command can do it now.
!
! Revision 2.90  2004/10/13 00:52:52  vsnyder
! Get HHMMSS_value from MLSStrings, its new home
!
! Revision 2.89  2004/08/17 23:49:36  pwagner
! Dont pad when getting MAFStartTime
!
! Revision 2.88  2004/08/16 17:14:42  pwagner
! Obtains First,LastMAFCtr global attributes from l1boa file
!
! Revision 2.87  2004/08/04 23:19:58  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.86  2004/07/26 18:22:48  pwagner
! Fixed failure to set returnStatus bug in CreateDirectTypeFromMLSCFInfo
!
! Revision 2.85  2004/06/17 22:49:36  pwagner
! Details for dumping VGrids determined by switch setting
!
! Revision 2.84  2004/06/17 00:39:02  vsnyder
! Make output of 'finished readL1BAttribute...' conditional on 'glo' switch
!
! Revision 2.83  2004/06/08 19:28:07  vsnyder
! Add tGrid, improve error detection and reporting
!
! Revision 2.82  2004/05/29 02:50:49  vsnyder
! Added more dumps
!
! Revision 2.81  2004/05/22 02:31:40  vsnyder
! Hook in PFAData, dump
!
! Revision 2.80  2004/03/24 01:02:55  livesey
! Make LeapSecFile public
!
! Revision 2.79  2004/01/23 01:09:48  pwagner
! Only directwrite files entered in global settings eligible to be auto-sourced
!
! Revision 2.78  2004/01/22 00:54:36  pwagner
! Fixed mistaken impression that direct arg is a pointer
!
! Revision 2.77  2003/12/11 22:59:08  pwagner
! May fill DirectWriteDatabase in global settings
!
! Revision 2.76  2003/11/15 00:46:41  pwagner
! maxfailurespermachine, maxfailuresperchunk no longer configuration settings (see comline opts)
!
! Revision 2.75  2003/09/26 21:55:54  pwagner
! Less likely to complain about missing attributes from hdf4 l1boa files
!
! Revision 2.74  2003/09/12 16:28:49  cvuu
! Read OrbitNumber and OrbitPeriod attributes from L1BOA
!
! Revision 2.73  2003/09/02 18:03:23  pwagner
! Now can reset maxfailuresper chunk, machine from global settings
!
! Revision 2.72  2003/07/15 18:18:06  livesey
! Change of forward model config call.
!
! Revision 2.71  2003/07/07 23:50:04  pwagner
! Now uses saved variable L2pcf from writeMetaData
!
! Revision 2.70  2003/06/09 22:49:34  pwagner
! Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
!
! Revision 2.69  2003/05/14 22:04:49  pwagner
! Bad leapsecfile name now prints sensibly & stops
!
! Revision 2.68  2003/05/12 20:57:21  pwagner
! Added L2ParSF spec to allow changing staging file name in global settings
!
! Revision 2.67  2003/05/10 22:20:50  livesey
! Tried to calm down -g1..
!
! Revision 2.66  2003/05/07 23:58:04  pwagner
! outputs trimmed LeapSecFileName
!
! Revision 2.65  2003/04/02 23:54:53  pwagner
! Checks for FILENOTFOUND
!
! Revision 2.64  2003/02/27 21:55:14  pwagner
! Calls FillTAI93Attribute
!
! Revision 2.63  2003/02/01 00:50:14  pwagner
! Picks up GlobalAttributes from settings
!
! Revision 2.62  2002/12/11 22:17:55  pwagner
! Added error checks on hdf version
!
! Revision 2.61  2002/11/13 01:07:40  pwagner
! Actually reads hdf5 radiances
!
! Revision 2.60  2002/10/08 17:36:20  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.59  2002/10/03 23:01:19  pwagner
! gets the_hdf_version from l1b..setup
!
! Revision 2.58  2002/09/25 20:09:14  livesey
! New global argument to ConstructForwardModelConfig
!
! Revision 2.57  2002/08/28 22:26:39  pwagner
! Moved LEVEL1_HDFVERSION, ILLEGALL1BRADID, MAXNUML1BRADIDS to MLSL2Options
!
! Revision 2.56  2002/08/20 23:02:17  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.55  2002/05/01 22:03:50  pwagner
! If leapsecfile parameter set, will convert start, end times
!
! Revision 2.54  2002/05/01 16:14:13  pwagner
! Dropped S_LEAPSECFILE
!
! Revision 2.53  2002/04/29 17:42:16  pwagner
! Can convert starttime, endtime to tai w/o pcf
!
! Revision 2.52  2002/02/08 22:52:56  livesey
! Hooked up bin selectors
!
! Revision 2.51  2002/01/24 00:14:26  pwagner
! Proclaims level 1 files as input; comments concerning hdf5 conversion
!
! Revision 2.50  2001/12/16 00:57:26  livesey
! Temporary fix to deal with tai93 time issues for sids
!
! Revision 2.49  2001/12/10 20:22:22  livesey
! Added code for EmpiricalGeometry
!
! Revision 2.48  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.47  2001/10/31 18:36:42  livesey
! Added fGrids stuff
!
! Revision 2.46  2001/10/30 00:37:09  pwagner
! Now can dump more l1b data
!
! Revision 2.45  2001/10/26 23:18:35  pwagner
! Complies with l1b data dump
!
! Revision 2.44  2001/10/25 23:35:52  pwagner
! Responds to global switch with bigger dump than glo switch
!
! Revision 2.43  2001/09/28 23:59:20  pwagner
! Fixed various timing problems
!
! Revision 2.42  2001/09/28 17:50:30  pwagner
! MLSL2Timings module keeps timing info
!
! Revision 2.41  2001/09/17 23:13:09  livesey
! Added instrument stuff to global settings etc
!
! Revision 2.40  2001/07/12 23:28:15  livesey
! Got rid of s_cloudForwardModel
!
! Revision 2.39  2001/07/09 22:53:20  pwagner
! Obeys CloudForwardModel; for now same as ForwardModel
!
! Revision 2.38  2001/06/07 21:58:28  pwagner
! Added Copyright statement
!
! Revision 2.37  2001/05/30 23:56:23  livesey
! Changed for new L1BData
!
! Revision 2.36  2001/05/30 23:04:40  pwagner
! Gets returnStatus from forwardModelGlobalSetup
!
! Revision 2.35  2001/05/29 23:21:07  livesey
! Now uses ForwardModelSupport, not ForwardModelInterface
!
! Revision 2.34  2001/05/26 00:06:49  livesey
! Added call to DealloteL1BData
!
! Revision 2.33  2001/05/24 20:54:15  pwagner
! Deleted p_ccs..times
!
! Revision 2.32  2001/05/24 20:36:13  pwagner
! Warns if glob. stg. overrides pcf
!
! Revision 2.31  2001/05/17 00:29:03  pwagner
! Works without toolkit, PCF at last
!
! Revision 2.30  2001/05/15 23:46:32  pwagner
! Now optionally uses hhmmss_value
!
! Revision 2.29  2001/05/14 23:45:08  pwagner
! Start, end times now added to MAF offsets from L1BOA
!
! Revision 2.28  2001/05/11 23:44:43  pwagner
! Better dump; uses strip=TRUE
!
! Revision 2.27  2001/05/11 01:56:17  vsnyder
! Move the getting of sub_rosa_index
!
! Revision 2.26  2001/05/11 00:09:05  pwagner
! Gets p_.. from init_tables; unquotes strings
!
! Revision 2.25  2001/05/10 18:26:22  pwagner
! Improved dump_global_settings
!
! Revision 2.24  2001/05/09 23:35:04  pwagner
! Added dump_global_settings
!
! Revision 2.23  2001/05/04 17:15:36  pwagner
! Many added settings, esp. L1B files, so level2 can run w/o PCF
!
! Revision 2.22  2001/04/26 20:02:09  livesey
! Made l2pc database a saved array in L2PC_m
!
! Revision 2.21  2001/04/26 02:52:17  vsnyder
! Fix up CVS stuff
!
! Revision 2.20  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.19  2001/04/26 00:07:33  livesey
! Stuff to support reading of l2pc files
!
! Revision 2.18  2001/04/24 00:31:42  vsnyder
! Finish adding 'time' command
!
! Revision 2.17  2001/04/23 23:48:41  vsnyder
! Finish adding 'time' command
!
! Revision 2.16  2001/04/23 23:42:00  vsnyder
! Add 'time' command
!
! Revision 2.15  2001/04/21 01:25:54  livesey
! Now passes l2gpdatabase to more people who need it.
!
! Revision 2.14  2001/04/10 23:44:44  vsnyder
! Improve 'dump'
!
! Revision 2.13  2001/04/10 02:46:17  livesey
! Working version, no more FMI/TFMI
!
! Revision 2.12  2001/04/07 01:50:49  vsnyder
! Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
! some related stuff to fwdmdl/ForwardModelConfig.
!
! Revision 2.11  2001/03/28 22:00:33  livesey
! Interim version, now handles vGrids as part of forwardModelConfig
!
! Revision 2.10  2001/03/28 01:24:55  vsnyder
! Move vGrid from construct section to global settings section
!
! Revision 2.9  2001/03/17 03:24:23  vsnyder
! Work on forwardModelGlobalSetup
!
! Revision 2.8  2001/03/17 00:57:36  livesey
! Removed dump.
!
! Revision 2.7  2001/03/17 00:45:38  livesey
! Added ForwardModelConfigDatabase
!
! Revision 2.6  2001/03/09 02:30:13  vsnyder
! Allocate correct size for FMI and TFMI
!
! Revision 2.5  2001/03/09 00:24:30  vsnyder
! Do subscripts right
!
! Revision 2.4  2001/03/08 03:23:09  vsnyder
! More stuff to work with L2_Load
!
! Revision 2.3  2001/03/07 22:46:05  vsnyder
! Add temporary stuff for Zvi's "l2_load", which will wither away.
!
! Revision 2.2  2000/11/16 01:53:40  vsnyder
! Take timing back out.  Don't do it in sections that are only parameter settings.
!
! Revision 2.1  2000/11/16 01:45:25  vsnyder
! Implement timing.
!
! Revision 2.0  2000/09/05 18:57:05  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:04  vsnyder
! Initial entry
!
@


2.182
log
@L1MAFToL2Profile may return matching Lat and Phi
@
text
@d135 1
a135 1
    ! 1st--read the MAF times
d142 5
a146 1
    quantity = 'MAFStartTimeTAI'
d161 9
a169 1
    call ClosestElement( l1bField%dpField(1,1,MAF+1)*1._r8, l2gp%time, indices )
d263 1
a263 1
    ! 1st--read the MAF times
d270 5
a274 1
    quantity = 'MAFStartTimeTAI'
d297 9
a305 1
    call ClosestElement( l2gp%time(profile), l1bField%dpField(1,1,:)*1._r8, indices )
d1459 1
a1459 1
       "$Id: global_settings.f90,v 2.181 2021/03/19 15:20:49 pwagner Exp $"
d1469 3
@


2.181
log
@Added the optional arg MIF to MAF v. profile functions
@
text
@d79 16
a94 2
  ! Remember--MAFs start at 0, not 1
  function L1MAFToL2Profile ( MAF, fileDatabase, MIF ) result( profile )
d102 1
a102 1
    use MLSKinds, only: R8
d110 3
d126 2
a127 1
    logical, parameter          :: DEEBug = .true.
d130 2
d170 1
a170 1
    if ( DEEBug .and. DumpLats ) then
d173 1
d184 3
d188 2
d195 1
d204 3
d208 2
d1435 1
a1435 1
       "$Id: global_settings.f90,v 2.180 2021/02/05 05:20:06 pwagner Exp $"
d1445 3
@


2.180
log
@Avoids unassocialed L2GPData
@
text
@d80 1
a80 1
  function L1MAFToL2Profile ( MAF, fileDatabase ) result( profile )
d93 3
a95 2
    integer, intent(in) :: MAF
    type (MLSFile_T), pointer :: FILEDATABASE(:)
d104 1
d109 2
d113 2
a133 1
    call ClosestElement( l1bField%dpField(1,1,MAF+1)*1._r8, l2gp%time, indices )
d137 1
d139 10
a148 3
    if ( DEEBUG ) call outputNamedValue( 'l2gpvalue', l2gp%time(profile) )
    if ( DEEBUG ) call outputNamedValue( 'l1bvalue', l1bField%dpField(1,1,MAF) )
    if ( DEEBUG ) call outputNamedValue( 'l1bvalue[+1]', l1bField%dpField(1,1,MAF+1) )
d150 29
d185 1
a185 1
  function L2ProfileToL1MAF ( profile, fileDatabase ) result( MAF )
d199 3
a201 2
    integer, intent(in) :: profile
    type (MLSFile_T), pointer :: FILEDATABASE(:)
d210 1
d217 2
d1403 1
a1403 1
       "$Id: global_settings.f90,v 2.179 2019/04/18 16:30:10 pwagner Exp $"
d1413 3
@


2.179
log
@Overwrite GlobalAttributes%PGEVersion only if currently blank
@
text
@d121 3
a123 1
    L2GPFile => GetMLSFileByType(filedatabase, content='l2gp')
d185 3
a187 1
    L2GPFile => GetMLSFileByType(filedatabase, content='l2gp')
d1357 1
a1357 1
       "$Id: global_settings.f90,v 2.178 2018/11/01 23:16:00 pwagner Exp $"
d1367 3
@


2.178
log
@Improve appearance of settings when dumped
@
text
@d750 2
a751 1
      GlobalAttributes%PGEVersion = l2pcf%PGEVersion
d1353 1
a1353 1
       "$Id: global_settings.f90,v 2.177 2018/07/27 23:19:53 pwagner Exp $"
d1363 3
@


2.177
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d12 1
a12 1
module GLOBAL_SETTINGS
d33 2
a34 2
! LEAPSECFILENAME                 For time conversions (if avoiding PCF)
! brightObjects                   As determined by l1b
d37 1
a37 1
! SET_GLOBAL_SETTINGS             Get global settings from l2cf
d42 1
a42 1
  public :: L1MAFTOL2PROFILE, L2PROFILETOL1MAF, SET_GLOBAL_SETTINGS
d49 1
a49 1
  integer, parameter :: BO_NAMELEN = 14
d89 1
a89 2
    use MLSMessageModule, only: MLSMessage, &
      & MLSMSG_Warning
d151 1
a151 2
    use MLSMessageModule, only: MLSMessage, &
      & MLSMSG_Warning
d209 1
a209 1
  subroutine SET_GLOBAL_SETTINGS ( root, forwardModelConfigDatabase, &
d744 3
d769 5
a773 2
      call outputNamedValue ( 'Last MAF', GlobalAttributes%LastMAFCtr )
      call outputNamedValue ( 'First MAF', GlobalAttributes%FirstMAFCtr )
d1345 1
a1345 1
  end subroutine SET_GLOBAL_SETTINGS
d1352 1
a1352 1
       "$Id: global_settings.f90,v 2.176 2017/11/15 00:11:44 pwagner Exp $"
d1359 1
a1359 1
end module GLOBAL_SETTINGS
d1362 3
@


2.176
log
@Use OutputTable to Dump list of level 1 files
@
text
@d18 3
d44 1
a44 1
  character(LEN=FileNameLen), public :: LEAPSECFILENAME = ''
d113 1
a113 1
      call MLSMessage ( MLSMSG_Warning, ModuleName // 'L1MAFToL2Profile', &                      
d176 1
a176 1
      call MLSMessage ( MLSMSG_Warning, ModuleName // 'L2ProfileToL1MAF', &                      
d195 1
a195 1
      call MLSMessage ( MLSMSG_Warning, ModuleName // 'L2ProfileToL1MAF', &                      
a250 3
    use MLSL2Options, only: CheckPaths, L2CFNode, Level1_HDFVersion, &
      & Need_L1BFiles, SpecialDumpFile, StopAfterSection, Toolkit, &
      & MLSMessage
d477 1
a477 1
            call MLSMessage ( MLSMSG_Error, ModuleName, &                      
d564 1
a564 1
            call MLSMessage ( MLSMSG_Warning, ModuleName, &                      
d602 1
a602 1
            call MLSMessage ( MLSMSG_Warning, ModuleName, &                      
d622 1
a622 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d668 1
a668 1
        call MLSMessage( MLSMSG_Warning, ModuleName, &
d682 1
a682 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &                      
d687 1
a687 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &                      
d719 1
a719 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &                      
d723 1
a723 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &                      
d774 1
a774 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &                      
d777 1
a777 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &                      
d780 1
a780 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &                      
d863 2
a864 2
        & call MLSMessage(MLSMSG_Error,ModuleName, &
        & 'Problem with global settings section')
d866 2
a867 2
        & call MLSMessage(MLSMSG_Warning,ModuleName, &
        & 'Possible problem with global settings section')
d888 1
a888 1
        call MLSMessage( MLSMSG_Warning, ModuleName, &
d1042 1
a1042 1
      character(LEN=*), intent(in) :: Full_message
d1147 1
a1147 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &                    
d1219 1
a1219 1
      call MLSMessage ( MLSMSG_Error, moduleName, &
d1335 1
a1335 1
    if ( returnStatus /= 0 ) call MLSMessage ( &
d1348 1
a1348 1
       "$Id: global_settings.f90,v 2.175 2017/07/27 16:42:38 pwagner Exp $"
d1358 3
@


2.175
log
@If yyyy-Doy, store actual actual month number as neg int. in GlobalAttributes%GranuleMonth
@
text
@d15 3
a17 1
  use HighOutput, only: BeVerbose, OutputCalendar, OutputNamedValue
d141 1
a141 1
    use L1BData, only: L1BData_t, NameLen, &
a1113 2
    use HighOutput, only: AddRow, AddRow_Divider, AddRow_Header, &
      & OutputTable, StartTable
d1223 20
a1242 12
    ! ---------------------------------------------  proclaim  -----
    subroutine proclaim ( Name, l1_type, hdfVersion )
      character(LEN=*), intent(in)   :: Name
      character(LEN=*), intent(in)   :: l1_type
      integer, optional,  intent(in) :: hdfVersion

      call output ( 'Level 1 product type : ' )
      call output ( trim(l1_type), advance='no')
      if ( present(hdfVersion) ) then
        call blanks(4)
        call output ( 'hdf ' )
        call output ( hdfVersion, advance='yes')
d1244 1
a1244 1
        call output ( ' ', advance='yes')
d1246 6
a1251 5
      call blanks(15)
      call output ( 'name : ' )
      call blanks(8)
      call output ( trim(Name), advance='yes')
    end subroutine proclaim
d1348 1
a1348 1
       "$Id: global_settings.f90,v 2.174 2017/07/10 18:58:16 pwagner Exp $"
d1358 3
@


2.174
log
@CamelCase; abandon all the extra ResetStartingDates
@
text
@d211 1
a211 1
      & SecondsBetween2UTCs, Utc2tai93s, UTC_To_Yyyymmdd
d317 1
d753 7
d1339 1
a1339 1
       "$Id: global_settings.f90,v 2.173 2017/01/19 23:52:03 pwagner Exp $"
d1349 3
@


2.173
log
@Improve appeearance when dumping Run Info
@
text
@d14 1
a14 1
  use MLSCommon, only: FileNameLen, MLSFile_t, nameLen, tai93_range_t
d16 1
a16 1
  use Output_m, only: Blanks, NewLine, Output, &
d210 4
a213 4
    use Dates_module, only: isUTCInRange, PrecedesUTC, resetStartingDate, &
      & SecondsBetween2UTCs, Utc2tai93s, UTC_To_yyyymmdd
    use Declaration_table, only: Named_value, Redeclare, str_value
    use DirectWrite_m, only: DirectData_t, &
d215 1
a215 1
    use DumpCommand_m, only: DumpCommand
d217 24
a240 24
    use EmpiricalGeometry, only: initEmpiricalGeometry
    use FGrid, only: addFGridToDatabase, createFGridFromMLSCFInfo, Dump, fgrid_t
    use ForwardModelConfig, only: addForwardModelConfigToDatabase, Dump, &
      & ForwardModelConfig_t
    use ForwardModelSupport, only: constructForwardModelConfig, &
      & ForwardModelGlobalsetup, createBinSelectorFromMLSCFInfo
    use HDF, only: dfacc_create
    use IGRF_Int, only: Read_gh
    use Init_tables_module, only: f_File, f_reset, f_type, &
      & L_L2GP, l_l2dgg, l_l2fwm, &
      & Parm_indices, &
      & First_parm, last_parm, p_brightobjects, &
      & P_cycle, p_endtime, p_igrf_File, p_instrument, &
      & P_leapsecFile, p_output_version_String, p_PFAFile, p_Starttime, &
      & S_binselector, s_directwriteFile, s_Dump, s_empiricalgeometry, &
      & S_fgrid, s_flushPFA, s_forwardModel, s_forwardModelglobal, &
      & S_l1boa, s_l1brad, s_l2parsf, s_makePFA, s_PFAData, s_ReadPFA, &
      & S_tgrid, s_time, s_vgrid, s_writePFA
    use Intrinsic, only: l_hdf, l_swath, spec_indices
    use L1BData, only: L1BData_t, NameLen, &
      & AssembleL1BQtyName, deallocateL1BData, Dump, findMaxMaf, &
      & L1BRadsetup, L1BOASetup, ReadL1BAttribute, ReadL1BData 
    use L2GPData, only: L2GPData_t
    use L2PC_m, only: addbinselectortoDatabase, binselectors
d243 1
a243 1
      & InitializemlsFile, MLS_CloseFile, MLS_OpenFile, split_path_Name
d245 3
a247 3
    use MLSKinds, only: r8
    use MLSL2Options, only: checkPaths, L2CFNode, level1_HDFVersion, &
      & Need_L1BFiles, specialDumpFile, stopAfterSection, toolkit, &
d249 1
a249 1
    use MLSL2Timings, only: section_times
d251 6
a256 6
    use MLSPCF2, only: MLSPCF_L2GP_Start, MLSPCF_L2GP_end, &
      & MLSPCF_l2dgm_Start, MLSPCF_l2dgm_end, MLSPCF_l2fwm_full_Start, &
      & MLSPCF_l2fwm_full_end, &
      & MLSPCF_l2dgg_Start, MLSPCF_l2dgg_end
    use MLSStrings, only: hhmmss_value, lowerCase, trim_safe
    use MLSStringLists, only: array2List, catLists, switchDetail, &
d258 8
a265 8
    use MLSSignals_m, only: instrument, modules, Dump_Modules, GetModuleName
    use MoreTree, only: Get_boolean, Get_field_id, Get_label_and_spec, &
      & Get_spec_id, StartErrorMessage
    use Next_tree_node_m, only: next_tree_node, next_tree_node_state
    use PFAData_m, only: Get_PFAData_from_l2cf, flush_PFAData, make_PFAData, &
      & Read_PFAData, write_PFAData
    use PFADatabase_m, only: process_PFA_File
    use PCFHDR, only: globalAttributes, fillTAI93Attribute
d267 11
a277 11
    use SDPToolkit, only: Max_orbits, MLS_UTCToTAI, &
      & PGSD_dem_30arc, PGSD_dem_90arc, &
      & PGSD_dem_elev, PGSD_dem_water_land, &
      & PGS_dem_open, PGS_s_success
    use String_table, only: display_String, Get_String
    use Time_m, only: SayTime, time_now
    use Toggles, only: gen, switches, toggle
    use Trace_m, only: trace_begin, trace_end
    use Tree, only: decorate, decoration, node_id, nsons, sub_rosa, subtree, &
      & Dump_tree_node
    use Tree_types, only: n_equal
d928 1
a928 1
        call ResetStartingDate( '1961-01-01' )
d933 1
a933 1
        call ResetStartingDate( '1993-01-01' )
d938 1
a938 1
        call ResetStartingDate( '1961-01-01' )
d962 1
a962 1
        call ResetStartingDate( '1961-01-01' )
d967 1
a967 1
        call ResetStartingDate( '1993-01-01' )
d972 1
a972 1
        call ResetStartingDate( '1961-01-01' )
d1004 1
a1004 1
        call ResetStartingDate( '1961-01-01' )
d1013 1
a1013 1
        call ResetStartingDate( '1993-01-01' )
d1017 1
a1017 1
        call ResetStartingDate( '1961-01-01' )
d1104 1
a1104 1
    use HighOutput, only: AddRow, AddRow_divider, AddRow_header, &
d1106 1
a1106 1
    use Open_init, only: DumpL1BDatabase
d1331 1
a1331 1
       "$Id: global_settings.f90,v 2.172 2017/01/07 01:14:51 pwagner Exp $"
d1341 3
@


2.172
log
@Print moon phases on calendar
@
text
@d14 4
a17 4
  use MLSCommon, only: fileNameLen, MLSFile_t, nameLen, tai93_range_t
  use highOutput, only: beVerbose, outputCalendar, outputNamedValue
  use Output_m, only: blanks, newLine, output, &
    & RevertOutput, switchOutput
d77 7
a83 7
      & assembleL1BQtyName, deallocateL1BData, &
      & readL1BData 
    use L2GPData, only: L2GPData_t, L2GPNameLen, maxSwathNamesBufSize, &
      & readL2GPData, destroyL2GPContents
    use MLSFiles, only: hdfversion_5, &
      & MLS_inqswath, getmlsfilebytype
    use MLSKinds, only: r8
d86 2
a87 2
    use MLSNumerics, only: closestElement
    use MLSStringLists, only: getStringElement
d138 6
a143 6
    use dump_0, only: dump
    use L1BData, only: L1BData_t, nameLen, &
      & assembleL1BQtyName, deallocateL1BData, &
      & readL1BData 
    use L2GPData, only: L2GPData_t, L2GPNameLen, maxSwathNamesBufSize, &
      & readL2GPData, destroyL2GPContents
d145 2
a146 2
      & MLS_inqswath, getMLSFileByType
    use MLSKinds, only: r8
d149 2
a150 2
    use MLSNumerics, only: closestElement
    use MLSStringLists, only: getStringElement
d209 7
a215 7
    use BitStuff, only: isBitSet
    use Dates_module, only: isUTCInRange, precedesUTC, resetStartingDate, &
      & secondsBetween2UTCs, Utc2tai93s, utc_to_yyyymmdd
    use Declaration_table, only: named_value, redeclare, str_value
    use DirectWrite_m, only: directData_t, &
      & AddDirectToDatabase, dump, setupNewDirect
    use DumpCommand_m, only: dumpCommand
d218 2
a219 2
    use FGrid, only: addFGridToDatabase, createFGridFromMLSCFInfo, dump, fgrid_t
    use ForwardModelConfig, only: addForwardModelConfigToDatabase, dump, &
d224 11
a234 11
    use IGRF_Int, only: read_gh
    use init_tables_module, only: f_file, f_reset, f_type, &
      & l_l2gp, l_l2dgg, l_l2fwm, &
      & parm_indices, &
      & first_parm, last_parm, p_brightobjects, &
      & p_cycle, p_endtime, p_igrf_file, p_instrument, &
      & p_leapsecfile, p_output_version_string, p_pfafile, p_starttime, &
      & s_binselector, s_directwritefile, s_dump, s_empiricalgeometry, &
      & s_fgrid, s_flushpfa, s_forwardmodel, s_forwardmodelglobal, &
      & s_l1boa, s_l1brad, s_l2parsf, s_makepfa, s_pfadata, s_readpfa, &
      & s_tgrid, s_time, s_vgrid, s_writepfa
d236 3
a238 3
    use L1BData, only: L1BData_t, nameLen, &
      & assembleL1BQtyName, deallocateL1BData, Dump, findMaxMaf, &
      & L1BRadsetup, L1BOASetup, readL1BAttribute, readL1BData 
d240 4
a243 4
    use L2PC_m, only: addbinselectortodatabase, binselectors
    use MLSFiles, only: filenotfound, HDFVersion_5, &
      & addfiletodatabase, getpcfromref, getMLSFileByName, getMLSFileByType, &
      & initializemlsfile, MLS_CloseFile, MLS_OpenFile, split_path_name
d247 1
a247 1
      & need_L1BFiles, specialDumpFile, stopAfterSection, toolkit, &
d251 2
a252 2
    use MLSPCF2, only: MLSPCF_l2gp_start, MLSPCF_l2gp_end, &
      & MLSPCF_l2dgm_start, MLSPCF_l2dgm_end, MLSPCF_l2fwm_full_start, &
d254 1
a254 1
      & MLSPCF_l2dgg_start, MLSPCF_l2dgg_end
d257 1
a257 1
      & numStringElements, stringElement, stringElementNum
d259 2
a260 2
    use MoreTree, only: get_boolean, get_field_id, get_label_and_spec, &
      & get_spec_id, StartErrorMessage
d262 1
a262 1
    use PFAData_m, only: get_PFAData_from_l2cf, flush_PFAData, make_PFAData, &
d264 1
a264 1
    use PFADatabase_m, only: process_pfa_file
d268 4
a271 4
      & Pgsd_dem_30arc, pgsd_dem_90arc, &
      & Pgsd_dem_elev, pgsd_dem_water_land, &
      & Pgs_dem_open, pgs_s_success
    use String_table, only: display_string, get_string
d278 3
a280 3
    use VGrid, only: createVGridFromMLSCFInfo
    use VGridsDatabase, only: addVGridToDatabase, VGrids
    use WriteMetadata, only: L2PCF
d1104 2
a1105 1
    use HighOutput, only: addRow, outputTable, startTable
d1151 2
d1331 1
a1331 1
       "$Id: global_settings.f90,v 2.171 2016/11/09 17:20:01 pwagner Exp $"
d1341 3
@


2.171
log
@Fixed error when l2cf processes param
@
text
@d139 3
a141 3
    use l1bdata, only: l1bdata_t, namelen, &
      & assemblel1bqtyname, deallocatel1bdata, &
      & readl1bdata 
d144 2
a145 2
    use MLSFiles, only: hdfversion_5, &
      & MLS_inqswath, getmlsfilebytype
d249 1
a249 1
    use MLSL2Timings, only: section_times, total_times
d341 1
a341 1
    real :: T1, T2                 ! For S_Time
d802 1
a802 1
        call outputCalendar( l2pcf%startutc, dateNote=BO_today )
d1328 1
a1328 1
       "$Id: global_settings.f90,v 2.170 2016/11/08 17:32:35 pwagner Exp $"
d1338 3
@


2.170
log
@Use SayTime subroutine from time_m module; process /reset field
@
text
@a407 1

d410 2
d421 1
d640 1
d1328 1
a1328 1
       "$Id: global_settings.f90,v 2.169 2016/09/23 00:11:52 pwagner Exp $"
d1338 3
@


2.169
log
@Improve appearance of Dumps
@
text
@d225 1
a225 1
    use init_tables_module, only: f_file, f_type, &
d259 2
a260 2
    use MoreTree, only: get_field_id, get_label_and_spec, get_spec_id, &
      & StartErrorMessage
d272 1
a272 1
    use Time_m, only: time_now
d306 2
d311 1
d329 1
d404 1
d407 13
d632 2
a633 2
          if ( timing ) then
            call sayTime
d859 1
a859 1
      if ( timing ) call sayTime
a1229 18
    ! --------------------------------------------------  SayTime  -----
    subroutine SayTime ( msg )
      character(len=*), optional, intent(in) :: msg
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      if ( present(msg) ) then
        call output ( trim_safe(msg) )
      else
        call output ( "Timing for GlobalSettings = " )
      endif
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime

d1325 1
a1325 1
       "$Id: global_settings.f90,v 2.168 2016/09/14 20:08:45 pwagner Exp $"
d1335 3
@


2.168
log
@heck if we set start, end times if no l1boa; also that they are reasonable
@
text
@d16 2
d236 1
a236 1
    use L1BData, only: L1BData_t, nameLen, precisionSuffix, &
a261 2
    use Output_m, only: blanks, output, &
      & RevertOutput, switchOutput
d340 1
d378 1
d412 1
a412 1
          if ( verbose ) call announce_error(0, &
d489 1
a489 1
          if ( verbose ) call announce_error(0, &
d670 1
a670 1
      if ( verbose ) call outputNamedValue ( 'group names', trim(moduleNames) )
d674 1
a674 1
        if ( verbose ) call outputNamedValue ( 'module name', trim(itsname) )
d676 1
a676 1
        if ( verbose ) call outputNamedValue ( 'element num', j )
d1082 3
a1084 1

d1108 1
a1108 2
      type (L1BData_T) :: l1bData   ! L1B dataset
      integer ::                              i, NoMAFs, IERR
d1110 2
a1111 9
      ! This next is in case we're to dump at greatest possible detail
      character (len=namelen), parameter ::  BASE_QUANT_NAME = &
                                      &       'R2:190.B3F:N2O.S2.FB25-3'
  !                                    &       'R1A:118.B1F:PT.S0.FB25-1'
      character (len=LEN(BASE_QUANT_NAME)) :: l1b_quant_name
      logical, parameter ::                   DUMPPRECISIONTOO = .true.
      integer ::  hdfVersion
      character(len=namelen) :: l1bItemName
      type(MLSFile_T), pointer :: L1BFile
d1125 1
a1125 51

        do i = 1, size(filedatabase)
         L1BFile => filedatabase(i)
         if ( L1BFile%content == 'l1brad' ) then
           call output ( 'fileid:   ' )
           call output ( L1BFile%FileID%f_id, advance='yes' )
           call output ( 'name:   ' )
           call output ( TRIM(L1BFile%name), advance='yes' )
           if ( details > -2 ) then
             l1b_quant_name = BASE_QUANT_NAME
             l1bItemName = AssembleL1BQtyName ( l1b_quant_name, hdfVersion, .false. )
             call ReadL1BData ( L1BFile, l1bItemName, L1bData, &
              & NoMAFs, IERR, NeverFail=.true. )
             if ( IERR == 0 ) then
               call Dump(l1bData, details )
               call DeallocateL1BData ( l1bData )
             else
               call output ( 'Error number  ' )
               call output ( IERR )
               call output ( ' while reading quantity named  ' )
               call output ( trim(l1b_quant_name), advance='yes' )
             end if
           end if
           if ( details > -2 .and. DUMPPRECISIONTOO ) then
             l1b_quant_name = trim(BASE_QUANT_NAME) // PRECISIONSUFFIX
             l1bItemName = AssembleL1BQtyName ( l1b_quant_name, hdfVersion, .false. )
             call ReadL1BData ( L1BFile, l1bItemName, L1bData, &
              & NoMAFs, IERR, NeverFail=.true. )
             if ( IERR == 0 ) then
               call Dump(l1bData, details )
               call DeallocateL1BData ( l1bData )
             else
               call output ( 'Error number  ' )
               call output ( IERR )
               call output ( ' while reading quantity named  ' )
               call output ( trim(l1b_quant_name), advance='yes' )
             end if
           end if
         elseif ( L1BFile%content == 'l1boa' ) then
           call output ( ' ', advance='yes' )
           call output ( 'L1OA file:', advance='yes' )

           call output ( 'fileid:   ' )
           call output ( L1BFile%FileID%f_id, advance='yes' )
           call output ( 'name:   ' )
           call output ( TRIM(L1BFile%Name), advance='yes' )
         end if
        end do



a1126 15
      call output ( ' ', advance='yes' )
      call output ( 'Start Time:   ' )
      call output ( l2pcf%startutc, advance='yes' )

      call output ( 'End Time:     ' )
      call output ( l2pcf%endutc, advance='yes' )

      call output ( 'Start Time (tai):   ' )
      call output ( processingrange%starttime, format=TIME_FORMAT, advance='yes' )

      call output ( 'End Time (tai):     ' )
      call output ( processingrange%endtime, format=TIME_FORMAT, advance='yes' )

      call output ( 'Processing Range:     ' )
      call output ( processingrange%endtime-processingrange%starttime, advance='yes' )
d1128 7
d1136 15
a1150 21
        call output ( 'Leap Seconds File:   ' )
        call output ( trim(LeapSecFileName), advance='yes' )
      end if

      call output ( 'PGE version:   ' )
      call output ( l2pcf%PGEVersion, advance='yes' )

      ! call output ( 'input version:   ' )
      ! call output ( l2pcf%InputVersion, advance='yes' )

      call output ( 'cycle:   ' )
      call output ( l2pcf%cycle, advance='yes' )

      call output ( 'Log file name:   ' )
      call output ( TRIM(l2pcf%logGranID), advance='yes' )

      call output ( 'l2gp species name keys:   ' )
      call output ( TRIM(l2pcf%spec_keys), advance='yes' )

      call output ( 'corresponding mcf names:   ' )
      call output ( TRIM(l2pcf%spec_mcfnames), advance='yes' )
d1325 1
a1325 1
       "$Id: global_settings.f90,v 2.167 2016/08/09 21:47:42 pwagner Exp $"
d1335 3
@


2.167
log
@Fix error in FindMaxMAF; print module names only if verbose
@
text
@d14 1
a14 1
  use MLSCommon, only: fileNameLen
a78 1
    use MLSCommon, only: MLSFile_t, namelen
a141 1
    use MLSCommon, only: mlsfile_t
d204 2
a205 2
  subroutine SET_GLOBAL_SETTINGS ( ROOT, FORWARDMODELCONFIGDATABASE, &
    & FILEDATABASE, FGRIDS, L2GPDATABASE, DIRECTDATABASE, PROCESSINGRANGE )
d208 2
a209 2
    use Dates_module, only: precedesUTC, resetStartingDate, secondsBetween2UTCs, &
      & Utc2tai93s, utc_to_yyyymmdd
a238 2
    use MLSCommon, only: mlsfile_t, nameLen, &
      & tai93_range_t
d284 2
a285 2
    use MLSHDF5, only: GETHDF5ATTRIBUTE, ISHDF5ATTRIBUTEINFILE
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
d637 8
a644 2
      ! (Shouldn't we check that she did?)
      if ( LeapSecFileName /= '' ) then
d846 12
a857 3
      call output( 'Using datesModule to convert times', advance='yes' )
      processingrange%starttime = utc2tai93s ( start_time_string, leapsec=.true. )
      processingrange%endtime = utc2tai93s ( end_time_string, leapsec=.true. )
d1393 1
a1393 1
       "$Id: global_settings.f90,v 2.166 2016/07/28 23:39:32 pwagner Exp $"
d1403 3
@


2.166
log
@Fixed error introduced with last commit
@
text
@d236 2
a237 2
    use L1BData, only: L1BData_t, namelen, precisionSuffix, &
      & assemblel1bqtyname, deallocateL1BData, dump, findmaxmaf, &
d243 3
a245 3
    use MLSFiles, only: filenotfound, hdfversion_5, &
      & addfiletodatabase, getpcfromref, getmlsfilebyname, getmlsfilebytype, &
      & initializemlsfile, mls_closefile, mls_openfile, split_path_name
d664 1
a664 1
      call mls_openFile ( L1BFile )
d666 1
a666 1
      call outputNamedValue ( 'group names', trim(moduleNames) )
d670 1
a670 1
        call outputNamedValue ( 'module name', trim(itsname) )
d672 1
a672 1
        call outputNamedValue ( 'element num', j )
d682 4
a685 2
      call Dump( modulenames, 'module names' )
      call Dump_Modules
d731 1
a731 1
      GlobalAttributes%LastMAFCtr = FindMaxMAF ( (/L1BFile/), &
d733 2
d1382 1
a1382 1
       "$Id: global_settings.f90,v 2.165 2016/07/28 19:54:30 pwagner Exp $"
d1392 3
@


2.165
log
@Guard against older hdf4 l1boa
@
text
@a660 2
      call FinishUp
      return
d712 2
a713 1

d1378 1
a1378 1
       "$Id: global_settings.f90,v 2.164 2016/07/28 01:45:07 vsnyder Exp $"
d1388 3
@


2.164
log
@Refactor dump and diff
@
text
@d658 5
d668 1
d674 1
d1379 1
a1379 1
       "$Id: global_settings.f90,v 2.163 2016/07/27 23:02:59 pwagner Exp $"
d1389 3
@


2.163
log
@Works better with Aircraft-borne instrument data
@
text
@d209 9
a217 8
    use bitStuff, only: isBitSet
    use dates_module, only: precedesUTC, resetStartingDate, secondsBetween2UTCs, &
      & utc2tai93s, utc_to_yyyymmdd
    use declaration_table, only: named_value, redeclare, str_value
    use directWrite_m, only: directData_t, &
      & addDirectToDatabase, dump, setupNewDirect
    use dumpCommand_m, only: dumpCommand
    use empiricalGeometry, only: initEmpiricalGeometry
d219 6
a224 6
    use forwardModelConfig, only: addForwardModelConfigToDatabase, dump, &
      & forwardModelConfig_t
    use forwardModelSupport, only: constructForwardModelConfig, &
      & forwardModelGlobalsetup, createBinSelectorFromMLSCFInfo
    use hdf, only: dfacc_create
    use igrf_int, only: read_gh
d235 1
a235 1
    use intrinsic, only: l_hdf, l_swath, spec_indices
d261 5
a265 5
    use moreTree, only: get_field_id, get_label_and_spec, get_spec_id, &
      & startErrorMessage
    use next_tree_node_m, only: next_tree_node, next_tree_node_state
    use output_m, only: blanks, output, &
      & revertOutput, switchOutput
d267 1
a267 1
      & read_PFAData, write_PFAData
d270 12
a281 12
    use readAPriori, only: APrioriFiles
    use sdptoolkit, only: max_orbits, mls_utctotai, &
      & pgsd_dem_30arc, pgsd_dem_90arc, &
      & pgsd_dem_elev, pgsd_dem_water_land, &
      & pgs_dem_open, pgs_s_success
    use string_table, only: display_string, get_string
    use time_m, only: time_now
    use toggles, only: gen, switches, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: decorate, decoration, node_id, nsons, sub_rosa, subtree, &
      & dump_tree_node
    use tree_types, only: n_equal
d284 1
a284 1
    use writeMetadata, only: L2PCF
d1372 1
a1372 1
       "$Id: global_settings.f90,v 2.162 2016/07/22 20:07:16 pwagner Exp $"
d1382 3
@


2.162
log
@Fix typos in output
@
text
@d64 3
a66 2
  integer, private :: ERROR, WARNING
  logical, parameter :: DEEBUG = .false.
a91 1
    logical, parameter            :: countEmpty = .true.
a155 1
    logical, parameter            :: countEmpty = .true.
d245 1
d250 1
a250 1
    use MLSL2timings, only: section_times, total_times
d258 2
a259 2
      & numStringElements, stringElement
    use MLSSignals_m, only: instrument
d268 1
a268 1
    use pcfhdr, only: globalattributes, filltai93attribute
d283 1
a283 1
    use writeMetadata, only: l2pcf
d311 1
d318 1
d655 1
d657 21
a1081 1
      logical, parameter :: countEmpty = .true.
d1371 1
a1371 1
       "$Id: global_settings.f90,v 2.161 2015/09/02 23:17:43 pwagner Exp $"
d1381 3
@


2.161
log
@Bomb promptly if no DEM files instead of waiting until run ends
@
text
@d818 1
a818 1
      call output( 'Using mafOffsts to convert times', advance='yes' )
d827 2
a828 1
      if ( DEEBUG ) call output( 'About to read L1B file', advance='yes' )
d833 1
a833 1
          & 'unrecognized MAFStarttimeTAI in L1BOA file')
d1348 1
a1348 1
       "$Id: global_settings.f90,v 2.160 2014/03/31 23:50:47 pwagner Exp $"
d1358 3
@


2.160
log
@Let tai93 times become negative
@
text
@d14 2
a15 2
  use MLSCOMMON, only: FILENAMELEN
  use HIGHOUTPUT, only: BEVERBOSE, OUTPUTCALENDAR, OUTPUTNAMEDVALUE
d73 13
a85 13
    use L1BDATA, only: L1BDATA_T, &
      & ASSEMBLEL1BQTYNAME, DEALLOCATEL1BDATA, &
      & READL1BDATA 
    use L2GPData, only: L2GPDATA_T, L2GPNAMELEN, MAXSWATHNAMESBUFSIZE, &
      & READL2GPDATA, DESTROYL2GPCONTENTS
    use MLSCOMMON, only: MLSFILE_T, NAMELEN
    use MLSFILES, only: HDFVERSION_5, &
      & MLS_INQSWATH, GETMLSFILEBYTYPE
    use MLSKINDS, only: R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, &
      & MLSMSG_WARNING
    use MLSNumerics, only: CLOSESTELEMENT
    use MLSStringLists, only: GETSTRINGELEMENT
d137 14
a150 14
    use DUMP_0, only: DUMP
    use L1BDATA, only: L1BDATA_T, namelen, &
      & ASSEMBLEL1BQTYNAME, DEALLOCATEL1BDATA, &
      & READL1BDATA 
    use L2GPData, only: L2GPDATA_T, L2GPNAMELEN, MAXSWATHNAMESBUFSIZE, &
      & READL2GPDATA, DESTROYL2GPCONTENTS
    use MLSCOMMON, only: MLSFILE_T
    use MLSFILES, only: HDFVERSION_5, &
      & MLS_INQSWATH, GETMLSFILEBYTYPE
    use MLSKINDS, only: R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, &
      & MLSMSG_WARNING
    use MLSNumerics, only: CLOSESTELEMENT
    use MLSStringLists, only: GETSTRINGELEMENT
d210 74
a283 74
    use BITSTUFF, only: ISBITSET
    use DATES_MODULE, only: PRECEDESUTC, RESETSTARTINGDATE, SECONDSBETWEEN2UTCS, &
      & UTC2TAI93S, UTC_TO_YYYYMMDD
    use Declaration_Table, only: NAMED_VALUE, REDECLARE, STR_VALUE
    use DIRECTWRITE_M, only: DIRECTDATA_T, &
      & ADDDIRECTTODATABASE, DUMP, SETUPNEWDIRECT
    use DUMPCOMMAND_M, only: DUMPCOMMAND
    use EMPIRICALGEOMETRY, only: INITEMPIRICALGEOMETRY
    use FGRID, only: ADDFGRIDTODATABASE, CREATEFGRIDFROMMLSCFINFO, DUMP, FGRID_T
    use FORWARDMODELCONFIG, only: ADDFORWARDMODELCONFIGTODATABASE, DUMP, &
      & FORWARDMODELCONFIG_T
    use FORWARDMODELSUPPORT, only: CONSTRUCTFORWARDMODELCONFIG, &
      & FORWARDMODELGLOBALSETUP, CREATEBINSELECTORFROMMLSCFINFO
    use HDF, only: DFACC_CREATE
    use IGRF_INT, only: Read_GH
    use INIT_TABLES_MODULE, only: F_FILE, F_TYPE, &
      & L_L2GP, L_L2DGG, L_L2FWM, &
      & PARM_INDICES, &
      & FIRST_PARM, LAST_PARM, P_BRIGHTOBJECTS, &
      & P_CYCLE, P_ENDTIME, P_IGRF_FILE, P_INSTRUMENT, &
      & P_LEAPSECFILE, P_OUTPUT_VERSION_STRING, P_PFAFILE, P_STARTTIME, &
      & S_BINSELECTOR, S_DIRECTWRITEFILE, S_DUMP, S_EMPIRICALGEOMETRY, &
      & S_FGRID, S_FLUSHPFA, S_FORWARDMODEL, S_FORWARDMODELGLOBAL, &
      & S_L1BOA, S_L1BRAD, S_L2PARSF, S_MAKEPFA, S_PFADATA, S_READPFA, &
      & S_TGRID, S_TIME, S_VGRID, S_WRITEPFA
    use INTRINSIC, only: L_HDF, L_SWATH, SPEC_INDICES
    use L1BDATA, only: L1BDATA_T, NAMELEN, PRECISIONSUFFIX, &
      & ASSEMBLEL1BQTYNAME, DEALLOCATEL1BDATA, DUMP, FINDMAXMAF, &
      & L1BRADSETUP, L1BOASETUP, READL1BATTRIBUTE, READL1BDATA 
    use L2GPDATA, only: L2GPDATA_T
    use L2PC_M, only: ADDBINSELECTORTODATABASE, BINSELECTORS
    use MLSCOMMON, only: MLSFILE_T, NAMELEN, &
      & TAI93_RANGE_T
    use MLSFILES, only: FILENOTFOUND, HDFVERSION_5, &
      & ADDFILETODATABASE, GETPCFROMREF, GETMLSFILEBYNAME, GETMLSFILEBYTYPE, &
      & INITIALIZEMLSFILE, MLS_CLOSEFILE, MLS_OPENFILE, SPLIT_PATH_NAME
    use MLSKINDS, only: R8
    use MLSL2OPTIONS, only: CHECKPATHS, L2CFNODE, LEVEL1_HDFVERSION, &
      & NEED_L1BFILES, SPECIALDUMPFILE, STOPAFTERSECTION, TOOLKIT, &
      & MLSMESSAGE
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING
    use MLSPCF2, only: MLSPCF_L2GP_START, MLSPCF_L2GP_END, &
      & MLSPCF_L2DGM_START, MLSPCF_L2DGM_END, MLSPCF_L2FWM_FULL_START, &
      & MLSPCF_L2FWM_FULL_END, &
      & MLSPCF_L2DGG_START, MLSPCF_L2DGG_END
    use MLSSTRINGS, only: HHMMSS_VALUE, LOWERCASE, TRIM_SAFE
    use MLSSTRINGLISTS, only: ARRAY2LIST, CATLISTS, SWITCHDETAIL, &
      & NUMSTRINGELEMENTS, STRINGELEMENT
    use MLSSIGNALS_M, only: INSTRUMENT
    use MORETREE, only: GET_FIELD_ID, GET_LABEL_AND_SPEC, GET_SPEC_ID, &
      & STARTERRORMESSAGE
    use Next_Tree_Node_m, only: NEXT_TREE_NODE, NEXT_TREE_NODE_STATE
    use OUTPUT_M, only: BLANKS, OUTPUT, &
      & REVERTOUTPUT, SWITCHOUTPUT
    use PFADATA_M, only: GET_PFADATA_FROM_L2CF, FLUSH_PFADATA, MAKE_PFADATA, &
      & READ_PFADATA, WRITE_PFADATA
    use PFADATABASE_M, only: PROCESS_PFA_FILE
    use PCFHDR, only: GLOBALATTRIBUTES, FILLTAI93ATTRIBUTE
    use READAPRIORI, only: APRIORIFILES
    use SDPTOOLKIT, only: MAX_ORBITS, MLS_UTCTOTAI, &
      & PGSd_DEM_30ARC, PGSd_DEM_90ARC, &
      & PGSd_DEM_ELEV, PGSd_DEM_WATER_LAND, &
      & PGS_DEM_OPEN
    use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
    use TIME_M, only: TIME_NOW
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, SUB_ROSA, SUBTREE, &
      & DUMP_TREE_NODE
    use TREE_TYPES, only: N_EQUAL
    use VGRID, only: CREATEVGRIDFROMMLSCFINFO
    use VGRIDSDATABASE, only: ADDVGRIDTODATABASE, VGRIDS
    use WRITEMETADATA, only: L2PCF
d390 5
a394 1
      if ( verbose ) call outputNamedValue( 'PGS_DEM_Open status', status )
d1347 1
a1347 1
       "$Id: global_settings.f90,v 2.159 2014/03/26 17:49:05 pwagner Exp $"
d1357 3
@


2.159
log
@Fixed old bugs when startTime, endTime omitted
@
text
@d55 3
a57 1
  logical, parameter :: LEAPSINDATESMODULE = .true.
d841 31
a871 26
    else
      if ( LeapSecFileName /= '' ) then
        if ( DEEBUG ) call output( 'About to read leapsec file' // &
          & trim(LeapSecFileName), advance='yes' )
        if ( precedesUTC ( '1993-01-01', start_time_string ) ) then
          returnStatus = mls_utctotai(trim(LeapSecFileName), start_time_string, &
          & processingrange%starttime)
          if ( DEEBUG ) call output( 'Read leapsec file', advance='yes' )
          if ( returnStatus /= 0 ) then
            call announce_error(0, &
            & 'Error converting start time in mls_utctotai; code number: ')
            call output(returnStatus, advance='yes')
          end if
        else
          ! The starting time is before our nominal 1993 start date
          ! We'll use the dates_module as a fallback
          call output( 'The starting time is before our nominal 1993 start date', advance='yes' )
          call ResetStartingDate( '1961-01-01' )
          processingrange%starttime = &
            & secondsbetween2utcs ( '1961-01-01', start_time_string )
        endif
      else if ( got(p_starttime) ) then
        processingrange%starttime = minTime + start_time_from_1stMAF
      else if ( .not. TOOLKIT ) then
        processingrange%starttime = minTime
      end if
d878 31
a908 26
    else
      if ( LeapSecFileName /= '' ) then
        if ( precedesUTC ( '1993-01-01', end_time_string ) ) then
          returnStatus = mls_utctotai(trim(LeapSecFileName), end_time_string, &
          & processingrange%endtime)
          if ( returnStatus /= 0 ) then
            call announce_error(0, &
            & 'Error converting end time in mls_utctotai; code number: ')
            call output(returnStatus, advance='yes')
          end if
        else
          ! The starting time is before our nominal 1993 start date
          ! We'll use the dates_module as a fallback
          call output( 'The starting time is before our nominal 1993 start date', advance='yes' )
          call ResetStartingDate( '1961-01-01' )
          processingrange%endtime = &
            & secondsbetween2utcs ( '1961-01-01', end_time_string )
        endif
      else if ( LEAPSINDATESMODULE ) then
        ! Without a leapsec file, let's use date_module's built-in feature
        processingrange%endtime = utc2tai93s ( end_time_string, leapsec=.true. )
      else if ( got(p_endtime) ) then
        processingrange%endtime = minTime + end_time_from_1stMAF
      else if ( .not. TOOLKIT ) then
        processingrange%endtime = maxTime + 1.0
      end if
d929 11
d1343 1
a1343 1
       "$Id: global_settings.f90,v 2.158 2014/03/19 19:54:47 pwagner Exp $"
d1353 3
@


2.158
log
@Fixed a gold-bick breaking bug introduced with last fix
@
text
@d663 3
a665 3
    elseif ( LeapSecFileName == '' .and. ( &
      &  .not. (got(p_starttime) .or. got(p_endtime) ) &
      &  .or. .not. LEAPSINDATESMODULE ) ) then
d673 1
a673 1
    else
d803 3
a805 3
        processingrange%starttime = utc2tai93s ( start_time_string, leapsec=.true. )
        processingrange%endtime = utc2tai93s ( end_time_string, leapsec=.true. )

d810 1
d812 1
a812 1

d835 3
a837 1
    if ( startTimeIsAbsolute ) then
d867 3
a869 1
    if ( stopTimeIsAbsolute ) then
d903 23
a925 23

        if ( DEEBUG ) call output( 'About to read leapsec file' // &
          & trim(LeapSecFileName), advance='yes' )
        if ( precedesUTC ( '1993-01-01', start_time_string ) ) then
          returnStatus = mls_utctotai(trim(LeapSecFileName), start_time_string, &
            & processingrange%starttime)
          returnStatus = mls_utctotai(trim(LeapSecFileName), end_time_string, &
            & processingrange%endtime)
          if ( DEEBUG ) call output( 'Read leapsec file', advance='yes' )
          if ( returnStatus /= 0 ) then
            call announce_error(0, &
            & 'Error converting start, end time in mls_utctotai; code number: ')
            call output(returnStatus, advance='yes')
          end if
        else
          ! The starting time is before our nominal 1993 start date
          ! We'll use the dates_module as a fallback
          call ResetStartingDate( '1961-01-01' )
          processingrange%starttime = &
            & secondsbetween2utcs ( '1961-01-01', start_time_string )
          processingrange%endtime = &
            & secondsbetween2utcs ( '1961-01-01', end_time_string )
        endif
d1144 2
a1145 2
      call output ( 'corresponding mcf hash:   ' )
      call output ( TRIM(l2pcf%spec_hash), advance='yes' )
d1320 1
a1320 1
       "$Id: global_settings.f90,v 2.157 2014/03/19 17:37:07 pwagner Exp $"
d1330 3
@


2.157
log
@Repaired bug breaking gold brick
@
text
@d661 3
a663 1
    if ( LeapSecFileName == '' .and. ( &
d1315 1
a1315 1
       "$Id: global_settings.f90,v 2.156 2014/03/18 17:46:09 pwagner Exp $"
d1325 3
@


2.156
log
@Fixed bug in use of got(:) array
@
text
@d661 3
a663 4
    if ( LeapSecFileName == '' .and. .not. LEAPSINDATESMODULE &
     & .and. &
     & (got(p_starttime) .or. got(p_endtime) .or. .not. TOOLKIT) &
     & ) then
d1313 1
a1313 1
       "$Id: global_settings.f90,v 2.155 2014/03/18 17:15:24 pwagner Exp $"
d1323 3
@


2.155
log
@Can get leapseconds from dates module if run sans toolkit
@
text
@d856 1
a856 1
      else if ( got(1) ) then
d886 1
a886 1
      else if ( got(2) ) then
d1314 1
a1314 1
       "$Id: global_settings.f90,v 2.154 2014/03/07 19:23:17 pwagner Exp $"
d1324 3
@


2.154
log
@Name_Len changed to nameLen; got from MLSCommon
@
text
@d15 1
a15 1
  use HIGHOUTPUT, only: OUTPUTCALENDAR, OUTPUTNAMEDVALUE
d54 2
d210 2
a211 2
      & UTC_TO_YYYYMMDD
    use Declaration_Table, only: Named_Value, Redeclare, Str_Value
d226 1
a226 1
      & P_BRIGHTOBJECTS, &
d234 1
a234 1
    use L1BDATA, only: L1BDATA_T, namelen, PRECISIONSUFFIX, &
d260 1
a260 1
    use Next_Tree_Node_m, only: Next_Tree_Node, Next_Tree_Node_State
d304 3
a306 1
    logical :: GOT(3)              ! Used non-canonically--a bad practice
a307 1
    ! integer :: INPUT_VERSION_STRING  ! Sub_rosa index
d316 1
d324 1
d338 1
a339 4
    character(len=NameLen) :: Name_string
    character(len=NameLen) :: End_time_string, Start_time_string
    character(len=FileNameLen) :: FilenameString
    character (len=namelen) :: QUANTITY
d375 1
d388 1
a388 1
      call outputNamedValue( 'PGS_DEM_Open status', status )
d405 1
a405 1
          call announce_error(0, &
d410 2
a417 1
          got(3) = .true.
a421 1
          got(2) = .true.
a460 1
          got(1) = .true.
d482 1
a482 1
          call announce_error(0, &
d625 1
d627 1
d632 1
d634 4
a637 18
        if ( DEEBUG ) call output( 'About to read leapsec file' // &
          & trim(LeapSecFileName), advance='yes' )
        if ( precedesUTC ( '1993-01-01', start_time_string ) ) then
          returnStatus = mls_utctotai(trim(LeapSecFileName), start_time_string, &
            & processingrange%starttime)
          if ( DEEBUG ) call output( 'Read leapsec file', advance='yes' )
          if ( returnStatus /= 0 ) then
            call announce_error(0, &
            & 'Error converting start time in mls_utctotai; code number: ')
            call output(returnStatus, advance='yes')
          end if
        else
          ! The starting time is before our nominal 1993 start date
          ! We'll use the dates_module as a fallback
          call ResetStartingDate( '1961-01-01' )
          processingrange%starttime = &
            & secondsbetween2utcs ( '1961-01-01', start_time_string )
        endif
d660 2
a661 5
    ! add maf offsets to start, end times
    ! or convert them to tai93
    ! This is optional way to define processingRange if using PCF
    ! It becomes mandatory if not using PCF
    if ( LeapSecFileName == '' &
d663 1
a663 1
     & (got(1) .or. got(2) .or. .not. TOOLKIT) &
d665 7
a671 26

      ! 1st--check that have L1BOA
      if ( L1BFile%FileID%f_id < 1 ) then
        call announce_error(son, &
          & 'L1BOA file required by global data--but not set')
      end if

      quantity = 'MAFStartTimeTAI'
      l1bItemName = AssembleL1BQtyName ( quantity, the_hdf_version, .false. )
      if ( DEEBUG ) call output( 'About to read L1B file', advance='yes' )
      call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, dontPad=.true.)
      if ( l1bFlag==-1 ) then
        call announce_error(son, &
          & 'unrecognized MAFStarttimeTAI in L1BOA file')
        minTime = 0.
        maxTime = 0.
      else
        minTime = l1bField%dpField(1,1,1)
        maxTime = l1bField%dpField(1,1,noMAFs) ! This is start time of last MAF
      end if
      call DeallocateL1BData ( l1bField )
    end if

    if ( startTimeIsAbsolute ) then
      processingRange%startTime = start_time_from_1stMAF
d673 1
a673 25
      if ( LeapSecFileName /= '' ) then
        if ( DEEBUG ) call output( 'About to read leapsec file' // &
          & trim(LeapSecFileName), advance='yes' )
        if ( precedesUTC ( '1993-01-01', start_time_string ) ) then
          returnStatus = mls_utctotai(trim(LeapSecFileName), start_time_string, &
          & processingrange%starttime)
          if ( DEEBUG ) call output( 'Read leapsec file', advance='yes' )
          if ( returnStatus /= 0 ) then
            call announce_error(0, &
            & 'Error converting start time in mls_utctotai; code number: ')
            call output(returnStatus, advance='yes')
          end if
        else
          ! The starting time is before our nominal 1993 start date
          ! We'll use the dates_module as a fallback
          call output( 'The starting time is before our nominal 1993 start date', advance='yes' )
          call ResetStartingDate( '1961-01-01' )
          processingrange%starttime = &
            & secondsbetween2utcs ( '1961-01-01', start_time_string )
        endif
      else if ( got(1) ) then
        processingrange%starttime = minTime + start_time_from_1stMAF
      else if ( .not. TOOLKIT ) then
        processingrange%starttime = minTime
      end if
a675 26
    if ( stopTimeIsAbsolute ) then
      processingRange%endTime = end_time_from_1stMAF
    else
      if ( LeapSecFileName /= '' ) then
        if ( precedesUTC ( '1993-01-01', end_time_string ) ) then
          returnStatus = mls_utctotai(trim(LeapSecFileName), end_time_string, &
          & processingrange%endtime)
          if ( returnStatus /= 0 ) then
            call announce_error(0, &
            & 'Error converting end time in mls_utctotai; code number: ')
            call output(returnStatus, advance='yes')
          end if
        else
          ! The starting time is before our nominal 1993 start date
          ! We'll use the dates_module as a fallback
          call output( 'The starting time is before our nominal 1993 start date', advance='yes' )
          call ResetStartingDate( '1961-01-01' )
          processingrange%endtime = &
            & secondsbetween2utcs ( '1961-01-01', end_time_string )
        endif
      else if ( got(2) ) then
        processingrange%endtime = minTime + end_time_from_1stMAF
      else if ( .not. TOOLKIT ) then
        processingrange%endtime = maxTime + 1.0
      end if
    end if
d696 1
a696 1
    if ( got(3) ) then
d799 123
d1314 1
a1314 1
       "$Id: global_settings.f90,v 2.153 2014/01/11 01:44:18 vsnyder Exp $"
d1324 3
@


2.153
log
@Decruftification
@
text
@d69 1
a69 1
    use L1BDATA, only: L1BDATA_T, NAME_LEN, &
d74 1
a74 1
    use MLSCOMMON, only: MLSFILE_T
d90 1
a90 1
    character(len=Name_Len) :: l1bItemName
d95 1
a95 1
    character (len=name_len) :: QUANTITY
d134 1
a134 1
    use L1BDATA, only: L1BDATA_T, NAME_LEN, &
d155 1
a155 1
    character(len=Name_Len) :: l1bItemName
d160 1
a160 1
    character (len=name_len) :: QUANTITY
d232 1
a232 1
    use L1BDATA, only: L1BDATA_T, NAME_LEN, PRECISIONSUFFIX, &
d308 1
a308 1
    character(len=Name_Len) :: L1bItemName
d337 1
a337 1
    character (len=name_len) :: QUANTITY
d984 1
a984 1
      integer ::                              i, version, NoMAFs, IERR
d987 1
a987 1
      character (len=NAME_LEN), parameter ::  BASE_QUANT_NAME = &
d993 1
a993 1
      character(len=Name_Len) :: l1bItemName
d1002 1
a1002 1
      version = 1
d1272 1
a1272 1
       "$Id: global_settings.f90,v 2.152 2014/01/09 00:30:24 pwagner Exp $"
d1282 3
@


2.152
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d267 1
a267 1
      & PGSd_DEM_3ARC, PGSd_DEM_30ARC, PGSd_DEM_90ARC, &
d276 1
a276 1
    use TREE_TYPES, only: N_EQUAL, N_IF, N_NAMED, N_Select, N_Variable
a337 1
    character(len=*), parameter :: Time_conversion='(F32.0)'
d1272 1
a1272 1
       "$Id: global_settings.f90,v 2.151 2013/12/12 02:11:26 vsnyder Exp $"
d1282 3
@


2.151
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d15 1
a15 1
  use OUTPUT_M, only: OUTPUTNAMEDVALUE
d259 1
a259 1
    use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTCALENDAR, &
d1273 1
a1273 1
       "$Id: global_settings.f90,v 2.150 2013/10/09 23:43:17 vsnyder Exp $"
d1283 3
@


2.150
log
@Add Evaluate_Variable, declare param correctly
@
text
@d171 1
a171 1
    endif
d192 1
a192 1
    endif
a213 1
    use Evaluate_Variable_m, only: Evaluate_Variable
d256 3
a258 1
    use MORETREE, only: GET_FIELD_ID, GET_SPEC_ID, STARTERRORMESSAGE
d276 1
a276 1
    use TREE_TYPES, only: N_EQUAL, N_NAMED, N_Variable
d324 1
d387 1
a387 1
    endif
d389 3
a391 2
    do i = 2, nsons(root)-1 ! Skip names at beginning and end of section
      son = subtree(i,root)
a473 2
      else if ( node_id(son) == n_variable ) then
        call evaluate_variable ( son )
d475 2
a476 7
        if ( node_id(son) == n_named ) then
          name = sub_rosa(subtree(1,son))
          son = subtree(2,son)
        else
          name = 0
        end if
      L2CFNODE = son
d1273 1
a1273 1
       "$Id: global_settings.f90,v 2.149 2013/09/25 01:04:33 pwagner Exp $"
d1283 3
@


2.149
log
@Added DEM stuff
@
text
@d209 1
d214 1
d275 1
a275 1
    use TREE_TYPES, only: N_EQUAL, N_NAMED
d317 2
a318 1
    integer :: param_id            ! e.g., p_brightObjects
d392 4
a395 1
        param_id = decoration(subtree(1,son))
d471 2
d1277 1
a1277 1
       "$Id: global_settings.f90,v 2.147 2013/08/30 02:45:49 vsnyder Exp $"
d1287 3
@


2.148
log
@Use Where instead of Source_Ref for messages
@
text
@d263 4
a266 1
    use SDPTOOLKIT, only: MAX_ORBITS, MLS_UTCTOTAI
d337 6
d369 14
d1279 3
@


2.147
log
@Revise calls to trace_begin and trace_end
@
text
@d269 1
a269 1
      & DUMP_TREE_NODE, SOURCE_REF
d423 1
a423 1
              & source_ref(subtree(j,son)) ) /= 0 ) continue
d1246 1
a1246 1
       "$Id: global_settings.f90,v 2.146 2013/08/21 00:27:13 pwagner Exp $"
d1256 3
@


2.146
log
@Code around nominal 1993 starting date limitation; awaiting better solution
@
text
@d246 1
a246 2
    use MLSMESSAGEMODULE, only: MLSMESSAGECALLS, &
      & MLSMSG_ERROR, MLSMSG_WARNING
d300 3
a302 1
    type (L1BData_T) :: l1bField   ! L1B data
d304 1
d309 3
a311 1
    integer :: OUTPUT_VERSION_STRING  ! Sub_rosa index
a330 4
    character(len=Name_Len) :: l1bItemName
    integer :: OrbNum(max_orbits)
    real(r8) :: OrbPeriod(max_orbits)
    type(MLSFile_T), pointer :: L1BFile
d350 1
a350 5
    if ( toggle(gen) ) then
      call trace_begin ( 'SET_GLOBAL_SETTINGS', root )
    else
      call MLSMessageCalls( 'push', constantName=ModuleName )
    endif
d359 1
a359 1
    endif
d849 1
a849 5
      if ( toggle(gen) ) then
        call trace_end ( 'SET_GLOBAL_SETTINGS' )
      else
        call MLSMessageCalls( 'pop' )
      end if
d1246 1
a1246 1
       "$Id: global_settings.f90,v 2.145 2012/08/16 17:51:07 pwagner Exp $"
d1256 3
@


2.145
log
@Exploit level 2-savvy MLSMessage
@
text
@d14 2
a15 2
  use MLSCommon, only: FILENAMELEN
  use output_m, only: OUTPUTNAMEDVALUE
d35 1
a35 1
  public :: L1MAFToL2Profile, L2ProfileToL1MAF, SET_GLOBAL_SETTINGS
d203 2
a204 2
  subroutine SET_GLOBAL_SETTINGS ( ROOT, ForwardModelConfigDatabase, &
    & filedatabase, FGrids, l2gpDatabase, DirectDatabase, processingRange )
d207 2
a208 1
    use DATES_MODULE, only: UTC_TO_YYYYMMDD
d270 1
a270 1
    & DUMP_TREE_NODE, SOURCE_REF
d281 7
a287 7
    integer, intent(in) :: ROOT    ! Index of N_CF node in abstract syntax tree
    type(ForwardModelConfig_T), pointer :: ForwardModelConfigDatabase(:)
    type (MLSFile_T), pointer :: FILEDATABASE(:)
    type ( fGrid_T ), pointer, optional :: FGrids(:)
    type ( l2gpData_T), pointer, optional :: L2GPDATABASE(:)
    type (DirectData_T), pointer, optional :: DirectDatabase(:)
    type (TAI93_Range_T), optional :: processingRange ! Data processing range
d609 16
a624 8
        returnStatus = mls_utctotai(trim(LeapSecFileName), start_time_string, &
        & processingrange%starttime)
        if ( DEEBUG ) call output( 'Read leapsec file', advance='yes' )
        if ( returnStatus /= 0 ) then
          call announce_error(0, &
          & 'Error converting start time in mls_utctotai; code number: ')
          call output(returnStatus, advance='yes')
        end if
d685 17
a701 8
        returnStatus = mls_utctotai(trim(LeapSecFileName), start_time_string, &
        & processingrange%starttime)
        if ( DEEBUG ) call output( 'Read leapsec file', advance='yes' )
        if ( returnStatus /= 0 ) then
          call announce_error(0, &
          & 'Error converting start time in mls_utctotai; code number: ')
          call output(returnStatus, advance='yes')
        end if
d713 16
a728 7
        returnStatus = mls_utctotai(trim(LeapSecFileName), end_time_string, &
        & processingrange%endtime)
        if ( returnStatus /= 0 ) then
          call announce_error(0, &
          & 'Error converting end time in mls_utctotai; code number: ')
          call output(returnStatus, advance='yes')
        end if
d1254 1
a1254 1
       "$Id: global_settings.f90,v 2.144 2012/04/20 00:46:13 pwagner Exp $"
d1264 3
@


2.144
log
@Treats MAF as 0-based; more robustly handles crashed chunks
@
text
@a233 1
    use L2PARINFO, only: PARALLEL
d241 3
a243 2
    use MLSL2OPTIONS, only: CHECKPATHS, LEVEL1_HDFVERSION, NEED_L1BFILES, &
      & SPECIALDUMPFILE, STOPAFTERSECTION, TOOLKIT
d245 1
a245 1
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECALLS, &
d366 1
d452 1
d1227 1
a1227 1
       "$Id: global_settings.f90,v 2.143 2012/03/28 20:08:24 pwagner Exp $"
d1237 3
@


2.143
log
@l2parsf spec generates warning--slave tasks lost ability to join quantities
@
text
@d15 1
d61 1
d66 2
d99 1
d117 4
a120 2
    ! call Hunt( l2gp%time, l1bField%dpField(1,1,MAF)*1._r8, profile )
    call ClosestElement( l1bField%dpField(1,1,MAF)*1._r8, l2gp%time, indices )
d122 3
d130 2
d133 1
d164 1
d180 2
d183 1
d185 8
a192 1
    ! call Hunt( l1bField%dpField(1,1,:)*1._r8, l2gp%time(profile), MAF )
d194 5
a198 1
    MAF = indices(1)
d1225 1
a1225 1
       "$Id: global_settings.f90,v 2.142 2012/03/15 22:51:15 vsnyder Exp $"
d1235 3
@


2.142
log
@Add IGRF_file parameter, some cannonball polishing
@
text
@d537 2
a538 7
          if ( restricted ) call notAllowed ( son, spec_restricted )
          sub_rosa_index = sub_rosa(subtree(2,subtree(2, son)))
          call get_string ( sub_rosa_index, FilenameString, strip=.true. )
          parallel%stagingFile = FilenameString
          if( switchDetail(switches, 'pro') > -1 ) then                            
            call proclaim(FilenameString, 'l2 parallel staging file') 
          end if
d1197 1
a1197 1
       "$Id: global_settings.f90,v 2.141 2011/11/04 00:08:01 pwagner Exp $"
d1207 3
@


2.141
log
@Made USEd entities all caps
@
text
@d190 1
d195 1
a195 1
      & P_CYCLE, P_ENDTIME, P_INSTRUMENT, &
a356 5
        case ( p_output_version_string )
          output_version_string = sub_rosa_index
          call get_string ( output_version_string, l2pcf%PGEVersion, strip=.true. )
        case ( p_instrument )
          instrument = decoration(subtree(2,son))
a358 14
        case ( p_starttime )
          if ( restricted ) call NotAllowed ( son, param_restricted )
          got(1) = .true.
          call get_string ( sub_rosa_index, name_string, strip=.true. )
          start_time_string = name_string
          if ( index(name_string, ':') > 0 ) then
            start_time_from_1stMAF = hhmmss_value(name_string, returnStatus)
            error = max(error,returnStatus)
            startTimeIsAbsolute = .false.
            l2pcf%startutc = start_time_string
          else
            read ( name_string, * ) start_time_from_1stMAF
            startTimeIsAbsolute = .true.
          end if
d373 5
d390 3
d399 14
d1202 1
a1202 1
       "$Id: global_settings.f90,v 2.140 2011/10/05 00:14:45 pwagner Exp $"
d1212 3
@


2.140
log
@Added functions to convert between MAFs, profile numbers
@
text
@d65 8
a72 10
    use L1BDATA, only: L1BDATA_T, NAME_LEN, PRECISIONSUFFIX, &
      & ASSEMBLEL1BQTYNAME, DEALLOCATEL1BDATA, DUMP, FINDMAXMAF, &
      & L1BRADSETUP, L1BOASETUP, READL1BATTRIBUTE, READL1BDATA 
    use L2GPData, only: L2GPDATA_T, L2GPNAMELEN, MAXSWATHNAMESBUFSIZE, RGP, &
      & DUMP, DUMPRANGE, READL2GPDATA, DESTROYL2GPCONTENTS
    use MLSCOMMON, only: MLSFILE_T, NAMELEN, &
      & TAI93_RANGE_T
    use MLSFILES, only: FILENOTFOUND, HDFVERSION_5, &
      & MLS_INQSWATH, GETMLSFILEBYTYPE, &
      & INITIALIZEMLSFILE, MLS_CLOSEFILE, MLS_OPENFILE, SPLIT_PATH_NAME
d74 2
a75 2
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECALLS, &
      & MLSMSG_ERROR, MLSMSG_WARNING
d121 8
a128 10
    use L1BDATA, only: L1BDATA_T, NAME_LEN, PRECISIONSUFFIX, &
      & ASSEMBLEL1BQTYNAME, DEALLOCATEL1BDATA, DUMP, FINDMAXMAF, &
      & L1BRADSETUP, L1BOASETUP, READL1BATTRIBUTE, READL1BDATA 
    use L2GPData, only: L2GPDATA_T, L2GPNAMELEN, MAXSWATHNAMESBUFSIZE, RGP, &
      & DUMP, DUMPRANGE, READL2GPDATA, DESTROYL2GPCONTENTS
    use MLSCOMMON, only: MLSFILE_T, NAMELEN, &
      & TAI93_RANGE_T
    use MLSFILES, only: FILENOTFOUND, HDFVERSION_5, &
      & MLS_INQSWATH, GETMLSFILEBYTYPE, &
      & INITIALIZEMLSFILE, MLS_CLOSEFILE, MLS_OPENFILE, SPLIT_PATH_NAME
d130 2
a131 2
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECALLS, &
      & MLSMSG_ERROR, MLSMSG_WARNING
d248 2
a249 2
    use MLSHDF5, only: GetHDF5Attribute, IsHDF5AttributeInFile
    use HDF5, only: h5gclose_f, h5gopen_f
d1198 1
a1198 1
       "$Id: global_settings.f90,v 2.139 2011/06/29 21:50:48 pwagner Exp $"
d1208 3
@


2.139
log
@Some cases may safely omit l1b files
@
text
@d30 2
d34 1
a34 1
  public :: SET_GLOBAL_SETTINGS
d63 116
d1202 1
a1202 1
       "$Id: global_settings.f90,v 2.138 2010/10/19 00:04:36 pwagner Exp $"
d1212 3
@


2.138
log
@Tried to fix callstack overflow when restricted
@
text
@d16 1
a16 1
  implicit NONE
d57 1
a57 1
  integer, private :: ERROR
d64 12
a75 12
    use BitStuff, only: isBitSet
    use dates_module, only: utc_to_yyyymmdd
    use DirectWrite_m, only: DirectData_T, &
      & AddDirectToDatabase, Dump, SetupNewDirect
    use DumpCommand_m, only: DumpCommand
    use EmpiricalGeometry, only: INITEMPIRICALGEOMETRY
    use FGrid, only: AddFGridToDatabase, CreateFGridFromMLSCFInfo, DUMP, FGrid_T
    use ForwardModelConfig, only: AddForwardModelConfigToDatabase, Dump, &
      & ForwardModelConfig_T
    use ForwardModelSupport, only: ConstructForwardModelConfig, &
      & ForwardModelGlobalSetup, CreateBinSelectorFromMLSCFInfo
    use Hdf, only: DFACC_CREATE
d78 1
a78 1
      & parm_indices, &
d86 37
a122 36
    use intrinsic, only: l_hdf, l_swath, Spec_indices
    use L1BData, only: L1BData_T, NAME_LEN, PRECISIONSUFFIX, &
      & AssembleL1BQtyName, DeallocateL1BData, Dump, FindMaxMAF, &
      & l1bradSetup, l1boaSetup, ReadL1BAttribute, ReadL1BData 
    use L2GPData, only: L2GPDATA_T
    use L2ParInfo, only: parallel
    use L2PC_M, only: AddBinSelectorToDatabase, BinSelectors
    use MLSCommon, only: R8, FileNameLen, MLSFile_T, NameLen, &
      & TAI93_Range_T
    use MLSFiles, only: FILENOTFOUND, HDFVERSION_5, &
      & AddFileToDataBase, GetPCFromRef, GetMLSFileByName, GetMLSFileByType, &
      & InitializeMLSFile, mls_CloseFile, mls_OpenFile, split_path_name
    use MLSL2Options, only: CHECKPATHS, LEVEL1_HDFVERSION, SPECIALDUMPFILE, &
      & STOPAFTERSECTION, Toolkit
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
    use MLSMessageModule, only: MLSMessage, MLSMessageCalls, &
      & MLSMSG_Error, MLSMSG_Warning
    use MLSPCF2, only: mlspcf_l2gp_start, mlspcf_l2gp_end, &
      & mlspcf_l2dgm_start, mlspcf_l2dgm_end, mlspcf_l2fwm_full_start, &
      & mlspcf_l2fwm_full_end, &
      & mlspcf_l2dgg_start, mlspcf_l2dgg_end
    use MLSStrings, only: hhmmss_value, lowerCase, trim_safe
    use MLSStringLists, only: Array2List, catLists, SWITCHDETAIL, &
      & NumStringElements, StringElement
    use MLSSignals_m, only: INSTRUMENT
    use MoreTree, only: GET_FIELD_ID, GET_SPEC_ID, StartErrorMessage
    use OUTPUT_M, only: BLANKS, OUTPUT, outputCalendar, &
      & revertoutput, switchOutput
    use PFAData_m, only: Get_PFAdata_from_l2cf, Flush_PFAData, Make_PFAData, &
      & Read_PFAData, Write_PFAData
    use PFADataBase_m, only: Process_PFA_File
    use PCFHdr, only: GlobalAttributes, FillTAI93Attribute
    use readAPriori, only: APrioriFiles
    use SDPToolkit, only: max_orbits, mls_utctotai
    use String_Table, only: display_string, Get_String
    use Time_M, only: Time_Now
d128 3
a130 3
    use VGrid, only: CreateVGridFromMLSCFInfo
    use VGridsDatabase, only: AddVGridToDatabase, VGrids
    use WriteMetadata, only: L2PCF
d200 1
d360 5
d398 5
d460 16
d677 3
d715 1
d1084 1
a1084 1
       "$Id: global_settings.f90,v 2.137 2010/05/23 03:19:48 honghanh Exp $"
d1094 3
@


2.137
log
@Modify the restriction for the callable forward model
@
text
@d445 4
a448 1
    if ( restricted ) return
d639 1
d641 1
a641 3
    if ( error /= 0 ) &
      & call MLSMessage(MLSMSG_Error,ModuleName, &
      & 'Problem with global settings section')
d643 15
a657 8
    if ( specialDumpFile /= ' ' ) &
      & call revertOutput
    if ( toggle(gen) ) then
      call trace_end ( 'SET_GLOBAL_SETTINGS' )
    else
      call MLSMessageCalls( 'pop' )
    end if
    if ( timing ) call sayTime
d659 1
a659 1
  contains
d1052 1
a1052 1
       "$Id: global_settings.f90,v 2.136 2010/02/04 23:12:44 vsnyder Exp $"
d1062 3
@


2.136
log
@Remove USE or declaration for unreferenced names
@
text
@d1 1
a1 1
! Copyright 2005, by the California Institute of Technology. ALL
d248 1
d262 1
d288 1
a314 1
          if ( restricted ) call notAllowed ( son, spec_restricted )
d333 1
d345 1
d351 2
a352 1
          if ( .not. stopEarly ) call decorate (son, AddForwardModelConfigToDatabase ( &
d355 1
a433 1
          if ( restricted ) call notAllowed ( son, spec_restricted )
d1043 1
a1043 1
       "$Id: global_settings.f90,v 2.135 2009/10/05 23:40:35 pwagner Exp $"
d1053 3
@


2.135
log
@Moved use statements to module scope to speedup Lahey; this is the last time we do that
@
text
@a163 1
    character(32) :: Param_Name
a167 1
    character(32) :: Spec_Name
d1038 1
a1038 1
       "$Id: global_settings.f90,v 2.134 2009/10/01 19:56:35 vsnyder Exp $"
d1048 3
@


2.134
log
@Restrict some functionality in callable forward model mode
@
text
@d75 1
d108 2
a109 1
    use MLSStringLists, only: Array2List, catLists, SWITCHDETAIL
a726 1
      use MLSStringLists, only: NumStringElements, StringElement
a928 1
      use MLSStrings, only: trim_safe
a946 1
    use Hdf, only: DFACC_CREATE
d1040 1
a1040 1
       "$Id: global_settings.f90,v 2.133 2009/08/26 17:16:15 pwagner Exp $"
d1050 3
@


2.133
log
@Note types of apriori files in file attribute MiscNotes
@
text
@d62 1
a62 1
    & FGrids, l2gpDatabase, DirectDatabase, processingRange, filedatabase )
d109 1
a109 1
    use MoreTree, only: GET_FIELD_ID, GET_SPEC_ID
d135 6
a140 7
    type(ForwardModelConfig_T), dimension(:), pointer :: &
      & ForwardModelConfigDatabase
    type ( fGrid_T ), pointer, dimension(:) :: FGrids
    type ( l2gpData_T), dimension(:), pointer :: L2GPDATABASE
    type (DirectData_T), dimension(:), pointer :: DirectDatabase
    type (TAI93_Range_T) :: processingRange ! Data processing range
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
d162 2
d167 1
d187 5
d232 1
a232 1
        endif
d274 1
d278 1
a278 1
            call announce_error(0, &
d312 1
d316 1
d336 1
d351 1
d384 1
d401 1
d428 1
d440 2
a650 2
      use LEXER_CORE, only: PRINT_SOURCE

d672 3
a674 3
       if ( .not. my_warning ) then
        error = max(error,1)
        call output ( '***** At ' )
d676 6
a681 5
        if ( lcf_where > 0 ) then
          call print_source ( source_ref(lcf_where) )
        else
          call output ( '(no lcf node available)' )
        end if
d683 2
a684 9
        call output ( ": The " );
        if ( lcf_where > 0 ) then
          call dump_tree_node ( lcf_where, 0 )
        else
          call output ( '(no lcf tree available)' )
        end if

        call output ( " Caused the following error:", advance='yes', &
         & from_where=ModuleName)
d692 5
a696 5
         if ( my_warning ) then
          call output ( 'Warning number ', advance='no' )
        else
          call output ( 'Error number ', advance='no' )
        end if
d886 19
d1041 1
a1041 1
       "$Id: global_settings.f90,v 2.132 2009/06/23 18:46:18 pwagner Exp $"
d1051 3
@


2.132
log
@Prevent Intel from optimizing ident string away
@
text
@d586 1
d596 19
d1013 1
a1013 1
       "$Id: read_apriori.f90 is it here $"
d1023 3
@


2.131
log
@fgrid switch dumps each fgrid
@
text
@d990 1
a991 1
!---------------------------- RCS Ident Info -------------------------------
d993 1
a993 1
       "$Id: global_settings.f90,v 2.130 2008/12/18 21:13:46 pwagner Exp $"
a994 1
!---------------------------------------------------------------------------
d996 1
a996 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d998 1
d1003 3
@


2.130
log
@May now dump an l2pc or allL2PCs (use with caution)
@
text
@d70 1
a70 1
    use FGrid, only: AddFGridToDatabase, CreateFGridFromMLSCFInfo, FGrid_T
a202 12
! The following tries to convert a switch like glo[n]
! into the numerical value (n-3)
!     i = index(switches, 'glo')
!     if ( i /= 0 ) then
!       if ( switches(i+3:i+3) >= '0' .and. switches(i+3:i+3) <= '9' ) then
!         details = iachar(switches(i+3:i+3)) - iachar('0') - 2
!       else
!         details = -3
!       end if
!     else
!       details = -4
!     end if
d328 2
d993 1
a993 1
       "$Id: global_settings.f90,v 2.129 2008/08/27 20:00:59 vsnyder Exp $"
d1003 3
@


2.129
log
@Add PRINT to not_used_here
@
text
@d325 3
a327 1
            call dumpCommand ( son, forwardModelConfigs=forwardModelConfigDatabase )
d1003 1
a1003 1
       "$Id: global_settings.f90,v 2.128 2007/12/14 01:50:47 pwagner Exp $"
d1013 3
@


2.128
log
@Zero out Fill values from BO_stat
@
text
@d1001 1
a1001 1
       "$Id: global_settings.f90,v 2.127 2007/10/04 20:43:12 vsnyder Exp $"
d1005 1
d1011 3
@


2.127
log
@Remove unused symbols
@
text
@d562 3
d1001 1
a1001 1
       "$Id: global_settings.f90,v 2.126 2007/09/24 20:26:03 pwagner Exp $"
d1010 3
@


2.126
log
@Prints this months calendar and shows todays bright objects
@
text
@d579 1
a579 1
        call output ( 'trim_safe(BO_today)', advance='yes' )
d998 1
a998 1
       "$Id: global_settings.f90,v 2.125 2007/08/17 00:32:41 pwagner Exp $"
d1007 3
@


2.125
log
@Unneeded changes
@
text
@d49 2
d64 1
d106 1
a106 1
    use MLSStrings, only: hhmmss_value, lowerCase
d110 2
a111 1
    use OUTPUT_M, only: BLANKS, OUTPUT, revertoutput, switchOutput
d145 2
d559 14
d574 7
d587 3
a589 2
      & call dump_global_settings( processingRange, filedatabase, DirectDatabase, &
      & ForwardModelConfigDatabase, LeapSecFileName, details-detailReduction )
d717 2
a718 1
      ! The following dtermines the level of detail to expose:
a722 1
      character(len=*) LeapSecFileName
d998 1
a998 1
       "$Id: global_settings.f90,v 2.124 2007/06/21 00:55:22 vsnyder Exp $"
d1007 3
@


2.124
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d97 2
a98 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d191 5
a195 1
    if ( toggle(gen) ) call trace_begin ( 'SET_GLOBAL_SETTINGS', root )
d197 13
a209 10
    i = index(switches, 'glo')
    if ( i /= 0 ) then
      if ( switches(i+3:i+3) >= '0' .and. switches(i+3:i+3) <= '9' ) then
        details = iachar(switches(i+3:i+3)) - iachar('0') - 2
      else
        details = -3
      end if
    else
      details = -4
    end if
d344 1
a344 1
          if ( index(switches, 'pro') /= 0 ) then  
d379 1
a379 1
          if ( index(switches, 'pro') /= 0 ) then  
d393 1
a393 1
          if ( index(switches, 'pro') /= 0 ) then  
d580 2
d970 1
a970 1
       "$Id: global_settings.f90,v 2.123 2007/03/26 18:06:59 pwagner Exp $"
d979 3
@


2.123
log
@Extra debuggung statements; may be useful if get 'Filesize limit exceeded'
@
text
@d717 1
a717 1
  	        call output ( 'fileid:   ' )
d720 1
a720 1
    	     call output ( TRIM(L1BFile%name), advance='yes' )
d960 1
a960 1
       "$Id: global_settings.f90,v 2.122 2007/01/12 00:36:41 pwagner Exp $"
d969 3
@


2.122
log
@New but unused option to skip check for correct month l2pc files
@
text
@d74 1
d82 1
a82 1
    use intrinsic, only: l_hdf, l_swath
d113 1
a113 1
    use String_Table, only: Get_String
d140 1
d224 1
d299 1
d417 2
d453 1
d472 2
d476 1
d536 1
d960 1
a960 1
       "$Id: global_settings.f90,v 2.121 2006/10/20 16:52:26 pwagner Exp $"
d969 3
@


2.121
log
@toolkit-using runs will warn but ignore unwanted global settings
@
text
@d47 2
d93 1
a93 1
    use MLSL2Options, only: LEVEL1_HDFVERSION, SPECIALDUMPFILE, &
d321 3
a323 2
          if ( .not. stopEarly ) call forwardModelGlobalSetup ( son, returnStatus, &
            & fileDataBase )
d835 3
a837 1
    subroutine SayTime
d844 5
a848 1
      call output ( "Timing for GlobalSettings = " )
d949 1
a949 1
       "$Id: global_settings.f90,v 2.120 2006/09/21 18:48:07 pwagner Exp $"
d958 3
@


2.120
log
@Reduce level of dumps in SIDS version
@
text
@d151 1
d154 1
d210 11
a220 1
        select case ( decoration(subtree(1,son)) )
a228 4
          if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for PGE version ***', &
            & just_a_warning = .true.)
a232 4
          if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for cycle number ***', &
            & just_a_warning = .true.)
a245 4
          if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for start time ***', &
            & just_a_warning = .true.)
a258 4
          if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for end time ***', &
            & just_a_warning = .true.)
a268 4
          else if ( TOOLKIT ) then
            call announce_error(0, &
            & '*** Leap Second File supplied global settings despite pcf ***', &
            & just_a_warning = .true.)
d285 10
a294 1
        select case ( get_spec_id(son) )
a352 4
            if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for L1BOA file ***', &
            & just_a_warning = .true.)
d369 1
a369 6
          if ( associated(L1BFile) ) then
            if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for L1B Rad. file(s) ***', &
            & just_a_warning = .true.)
          else
a380 4
          if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for L2 Parallel staging file ***', &
            & just_a_warning = .true.)
d940 1
a940 1
       "$Id: global_settings.f90,v 2.119 2006/07/24 20:35:21 pwagner Exp $"
d949 3
@


2.119
log
@Fixed bug when stopAfterSection is blank
@
text
@d100 1
a100 1
    use MLSStringLists, only: Array2List, catLists
d137 1
d197 7
d551 1
a551 1
      & ForwardModelConfigDatabase, LeapSecFileName, details )
d659 1
a659 1
      & LeapSecFileName, dumpL1BDetails )
d681 1
a681 1
      integer, optional, intent(in) :: dumpL1BDetails
a687 1
      integer ::                              myL1BDetails
a704 2
      myL1BDetails = -2
      if ( present(dumpL1BDetails) ) myL1BDetails = dumpL1BDetails
d719 1
a719 1
           if ( myL1BDetails > -2 ) then
d725 1
a725 1
               call Dump(l1bData, myL1BDetails )
d734 1
a734 1
           if ( myL1BDetails > -2 .and. DUMPPRECISIONTOO ) then
d740 1
a740 1
               call Dump(l1bData, myL1BDetails )
d814 4
a817 2
      call output ( ' ', advance='yes' )
      call dump(ForwardModelConfigDatabase, details=9, skipPFA=.true.)
d952 1
a952 1
       "$Id: global_settings.f90,v 2.118 2006/07/21 20:12:48 pwagner Exp $"
d961 3
@


2.118
log
@Can select what section to stop after
@
text
@d176 1
d945 1
a945 1
       "$Id: global_settings.f90,v 2.117 2006/07/20 23:39:53 vsnyder Exp $"
d954 3
@


2.117
log
@Remove unused declarations and USEs
@
text
@d92 1
a92 1
      & STOPAFTERGLOBAL, STOPAFTERCHUNKDIVIDE, Toolkit
d99 1
a99 1
    use MLSStrings, only: hhmmss_value
d173 3
a175 2
    stopEarly = STOPAFTERCHUNKDIVIDE .or. STOPAFTERGLOBAL

d944 1
a944 1
       "$Id: global_settings.f90,v 2.116 2006/06/12 19:28:52 pwagner Exp $"
d953 3
@


2.116
log
@Fallback to climatology noted only if all of ncep, goes4/5 missing
@
text
@d71 1
a71 1
      & L_TRUE, L_L2GP, L_L2DGG, L_L2FWM, &
d943 1
a943 1
       "$Id: global_settings.f90,v 2.115 2006/04/21 22:28:45 vsnyder Exp $"
d952 3
@


2.115
log
@Allow FlushPFA in global settings section
@
text
@a203 8
        ! case ( p_input_version_string )
          ! input_version_string = sub_rosa_index
          ! call get_string ( input_version_string, l2pcf%inputVersion, &
          !   & strip=.true. )
          ! if ( TOOLKIT ) &
          !   & call announce_error(0, &
          !   & '*** l2cf overrides pcf for input version ***', &
          !   & just_a_warning = .true.)
a497 1
      ! GlobalAttributes%InputVersion = l2pcf%inputVersion
d543 2
a544 1
    if ( APrioriFiles%dao // AprioriFiles%ncep == ' ' ) then
d546 2
a547 2
        & 'No dao or ncep files--falling back to climatology', '\')
    elseif ( APrioriFiles%dao == ' ' ) then
d549 1
a549 1
        & 'No dao files--falling back to ncep', '\')
d943 1
a943 1
       "$Id: global_settings.f90,v 2.114 2006/03/15 23:52:24 pwagner Exp $"
d952 3
@


2.114
log
@Removed InputVersion component from PCF, l2cf
@
text
@d76 3
a78 3
      & S_FGRID, S_FORWARDMODEL, S_FORWARDMODELGLOBAL, S_L1BOA, S_L1BRAD, &
      & S_L2PARSF, S_MAKEPFA, S_PFADATA, S_READPFA, S_TGRID, S_TIME, S_VGRID, &
      & S_WRITEPFA
d104 1
a104 1
    use PFAData_m, only: Get_PFAdata_from_l2cf, Make_PFAData, &
d157 1
d309 3
d951 1
a951 1
       "$Id: global_settings.f90,v 2.113 2006/02/15 00:02:05 pwagner Exp $"
d960 3
@


2.113
log
@Moved revertOutput call
@
text
@d73 1
a73 1
      & P_CYCLE, P_ENDTIME, P_INPUT_VERSION_STRING, P_INSTRUMENT, &
d141 1
a141 1
    integer :: INPUT_VERSION_STRING  ! Sub_rosa index
a197 2
!         case ( p_allow_climatology_overloads )
!           allow_climatology_overloads = decoration(subtree(2,son)) == l_true
d203 8
a210 7
        case ( p_input_version_string )
          input_version_string = sub_rosa_index
          call get_string ( input_version_string, l2pcf%inputVersion, strip=.true. )
          if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for input version ***', &
            & just_a_warning = .true.)
a217 2
!         case ( p_version_comment )
!           version_comment = sub_rosa_index
d784 2
a785 2
      call output ( 'input version:   ' )
      call output ( l2pcf%InputVersion, advance='yes' )
a810 3
!       call output ( 'Allow climatology overloads?:   ' )
!       call output ( allow_climatology_overloads, advance='yes' )

d947 1
a947 1
       "$Id: global_settings.f90,v 2.112 2006/02/10 21:16:43 pwagner Exp $"
d956 3
@


2.112
log
@dumps may go to special dumpfile
@
text
@d563 2
a568 2
    if ( specialDumpFile /= ' ' ) &
      & call revertOutput
d953 1
a953 1
       "$Id: global_settings.f90,v 2.111 2006/02/06 22:54:51 pwagner Exp $"
d962 3
@


2.111
log
@Should print warnings, not bomb if l1b files not found
@
text
@a33 5
  ! logical         :: ALLOW_CLIMATOLOGY_OVERLOADS = .false.
  ! integer         :: INPUT_VERSION_STRING = 0     ! Sub_rosa index
  ! integer         :: OUTPUT_VERSION_STRING = 0    ! Sub_rosa index
  ! integer         :: VERSION_COMMENT = 0          ! Sub_rosa index

d91 1
a91 1
    use MLSL2Options, only: LEVEL1_HDFVERSION, &
d103 1
a103 1
    use OUTPUT_M, only: BLANKS, OUTPUT
d544 2
d567 2
d953 1
a953 1
       "$Id: global_settings.f90,v 2.110 2006/01/26 00:35:12 pwagner Exp $"
d962 3
@


2.110
log
@demoted more use statements from module level to speed Lahey compiles
@
text
@d94 1
a94 1
      & AddFileToDataBase, GetPCFromRef, GetMLSFileByType, &
d337 2
a338 1
          call ReadL1BAttribute (L1BFile, OrbNum, 'OrbitNumber', &
d345 1
a345 1
          call ReadL1BAttribute (L1BFile, OrbPeriod, 'OrbitPeriod', &
d352 3
a354 3
          if ( details > -4 ) call output &
            & ('finished readL1BAttribute in global_setting', advance='yes')
          if ( TOOLKIT ) &
d358 5
d367 2
a369 2
            sub_rosa_index = sub_rosa(subtree(2,subtree(2, son)))
            call get_string ( sub_rosa_index, FilenameString, strip=.true. )
d373 3
a375 1
          if ( TOOLKIT ) &
d379 5
d954 1
a954 1
       "$Id: global_settings.f90,v 2.109 2006/01/10 23:51:11 pwagner Exp $"
d963 3
@


2.109
log
@Fixed segment fault when hdf4 l1boa file
@
text
@a13 1
  use Hdf, only: DFACC_CREATE
d847 1
d941 1
a941 1
       "$Id: global_settings.f90,v 2.108 2005/11/12 00:58:10 pwagner Exp $"
d950 3
@


2.108
log
@Fixed bug in reading BO_names attribute from l1boa file
@
text
@d418 1
d519 3
d941 1
a941 1
       "$Id: global_settings.f90,v 2.107 2005/11/11 21:46:07 pwagner Exp $"
d950 3
@


2.107
log
@Added reading bright objects from l1boa; removed unused settings
@
text
@d41 7
d106 1
a106 1
    use MLSStringLists, only: catLists
a139 1
    type (L1BData_T) :: l1bField   ! L1B data
d141 2
d149 1
d527 2
a528 1
      call GetHDF5Attribute( L1BFile, '/BO_name', BrightObjects )
d937 1
a937 1
       "$Id: global_settings.f90,v 2.106 2005/09/22 23:37:45 pwagner Exp $"
d946 3
@


2.106
log
@date conversion procedures and functions all moved into dates module
@
text
@d26 2
a27 4
! ALLOW_CLIMATOLOGY_OVERLOADS     Not used yet
! INPUT_VERSION_STRING            Not used yet
! OUTPUT_VERSION_STRING           stored as pgeversion among metadata
! VERSION_COMMENT                 Not used yet
d35 5
a39 4
  logical, public :: ALLOW_CLIMATOLOGY_OVERLOADS = .false.
  integer, public :: INPUT_VERSION_STRING = 0     ! Sub_rosa index
  integer, public :: OUTPUT_VERSION_STRING = 0    ! Sub_rosa index
  integer, public :: VERSION_COMMENT = 0          ! Sub_rosa index
d41 4
d71 1
a71 1
      & P_ALLOW_CLIMATOLOGY_OVERLOADS, &
a73 1
      & P_VERSION_COMMENT, &
d75 1
a75 1
      & S_FGRID, S_FORWARDMODEL, S_ForwardModelGlobal, S_L1BOA, S_L1BRAD, &
d89 1
a89 1
      & InitializeMLSFile, split_path_name
d120 5
d137 1
a137 1
    logical :: GOT(2)
d139 2
d146 1
d156 1
a156 3
    logical ::  ItExists


d195 7
a201 2
        case ( p_allow_climatology_overloads )
          allow_climatology_overloads = decoration(subtree(2,son)) == l_true
d216 2
a217 2
        case ( p_version_comment )
          version_comment = sub_rosa_index
d504 20
d630 2
a631 1
      & filedatabase, DirectDatabase, ForwardModelConfigDatabase, LeapSecFileName, dumpL1BDetails )
d633 1
a654 1
  !    character(len=CCSDSlen) CCSDSStartTime
d657 1
a657 1

d662 1
d777 14
a790 2
      call output ( 'Allow climatology overloads?:   ' )
      call output ( allow_climatology_overloads, advance='yes' )
d927 1
a927 1
       "$Id: global_settings.f90,v 2.105 2005/08/19 23:33:03 pwagner Exp $"
d936 3
@


2.105
log
@FwdMdlDB now dumped when dumping global settings
@
text
@a54 1
    ! & FGrids, l2gpDatabase, DirectDatabase, processingRange, l1bInfo )
d56 1
a60 1
!   use EXPR_M, only: EXPR
d97 1
a97 1
    use MLSStringLists, only: catLists,  utc_to_yyyymmdd
a144 2
!   integer :: UNITS(2)            ! Output from Expr
!   double precision :: VALUE(2)   ! Output from Expr
a212 4
          !        case ( p_ccsdsstarttime )
          !          call get_string ( sub_rosa_index, l2pcf%startutc, strip=.true. )
          !        case ( p_ccsdsendtime )
          !          call get_string ( sub_rosa_index, l2pcf%endutc, strip=.true. )
a222 2
!             call expr ( subtree(2,son), units, value )
!             start_time_from_1stMAF = value(1)
a239 2
!             call expr ( subtree(2,son), units, value )
!             end_time_from_1stMAF = value(1)
a266 6
        ! case ( p_maxfailurespermachine )
        !  call expr ( subtree(2,son), units, value )
        !  parallel%maxfailurespermachine = value(1)
        ! case ( p_maxfailuresperchunk )
        !  call expr ( subtree(2,son), units, value )
        !  parallel%maxfailuresperchunk = value(1)
a307 1
          ! call l1boaSetup ( son, l1bInfo, F_FILE, hdfVersion=the_hdf_version )
a337 1
          ! call l1bradSetup ( son, l1bInfo, F_FILE, &
a651 2
     ! if ( associated(l1bInfo%L1BRADIDs) ) then
     ! if ( num_l1b_files > 0 ) then
a652 1
        ! if ( l1bInfo%L1BRADIDs(i) /= ILLEGALL1BRADID ) then
a787 1
    ! type (DirectData_T), pointer :: Direct
a802 1
    ! nullify(Direct)
d880 1
a880 1
       "$Id: global_settings.f90,v 2.104 2005/07/21 23:45:33 pwagner Exp $"
d889 3
@


2.104
log
@Removed unused l1b fileinfo fields from l2pcf
@
text
@d63 1
a63 1
    use ForwardModelConfig, only: AddForwardModelConfigToDatabase, &
d512 1
a512 1
      & LeapSecFileName, details )
d616 1
a616 1
      & filedatabase, DirectDatabase, LeapSecFileName, dumpL1BDetails )
d630 2
d768 1
d904 1
a904 1
       "$Id: global_settings.f90,v 2.103 2005/07/12 17:36:16 pwagner Exp $"
d913 3
@


2.103
log
@Dropped global attribute InputVersion; fills MiscNotes if no dao
@
text
@d89 2
a90 2
    use MLSL2Options, only: ILLEGALL1BRADID, LEVEL1_HDFVERSION, &
      & MAXNUML1BRADIDS, STOPAFTERGLOBAL, STOPAFTERCHUNKDIVIDE, Toolkit
d358 1
a358 1
            & MAXNUML1BRADIDS, ILLEGALL1BRADID, hdfVersion=the_hdf_version )
d901 1
a901 1
       "$Id: global_settings.f90,v 2.102 2005/06/14 20:42:38 pwagner Exp $"
d910 3
@


2.102
log
@Interfaces changed to accept MLSFile_T args
@
text
@d98 1
a98 1
    use MLSStringLists, only: utc_to_yyyymmdd
d106 1
d494 1
a494 1
      GlobalAttributes%InputVersion = l2pcf%inputVersion
d514 8
a614 1
    ! subroutine dump_global_settings ( processingRange, l1bInfo, DirectDatabase, &
a627 2
      ! type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
      ! type(PCFData_T) :: l2pcf
d901 1
a901 1
       "$Id: global_settings.f90,v 2.101 2005/06/04 00:14:53 vsnyder Exp $"
d910 3
@


2.101
log
@Import MLSMSG_Warning
@
text
@d14 1
d77 1
d315 2
a316 1
          if ( .not. stopEarly ) call forwardModelGlobalSetup ( son, returnStatus )
d848 2
a849 2
        & name=Direct%Filename, &
        & type='hdf', access='create', HDFVersion=HDFVERSION_5, &
d858 2
a859 2
        & name=Direct%Filename, &
        & type='hdf', access='create', HDFVersion=HDFVERSION_5, &
d868 2
a869 2
        & name=Direct%Filename, &
        & type='hdf', access='create', HDFVersion=HDFVERSION_5, &
d878 2
a879 2
        & name=Direct%Filename, &
        & type='hdf', access='create', HDFVersion=HDFVERSION_5, &
d895 1
a895 1
       "$Id: global_settings.f90,v 2.100 2005/06/03 23:58:48 pwagner Exp $"
d904 3
@


2.100
log
@Hope it wont bomb if no l1boa
@
text
@d90 1
a90 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d892 1
a892 1
       "$Id: global_settings.f90,v 2.99 2005/06/03 02:11:14 vsnyder Exp $"
d901 3
@


2.99
log
@New copyright notice, move Id to not_used_here to avoid cascades,
get VGrids from VGridsDatabase instead of a dummy argument.
@
text
@d84 3
a86 2
    use MLSFiles, only: FILENOTFOUND, &
      & GetPCFromRef, GetMLSFileByType, split_path_name
a123 1
    ! type (L1BInfo_T) :: l1bInfo    ! File handles etc. for L1B dataset
a124 1
    ! type (PCFData_T) :: l2pcf
d127 1
d134 1
d297 3
a299 1
            & DirectDatabase, CreateDirectTypeFromMLSCFInfo ( son ) ) )
d406 5
d796 1
a796 1
    function CreateDirectTypeFromMLSCFInfo ( root ) result (Direct)
d800 1
d837 4
a840 2
    else if ( Direct%Type ==  l_l2gp ) then
      Direct%Handle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
d844 4
d849 2
a850 1
      Direct%Handle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
d854 4
d859 2
a860 1
         Direct%Handle = GetPCFromRef(file_base, mlspcf_l2fwm_full_start, &
d864 4
d869 2
a870 1
      Direct%Handle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
d874 4
d892 1
a892 1
       "$Id: global_settings.f90,v 2.98 2005/05/31 17:51:17 pwagner Exp $"
d901 4
@


2.98
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d1 10
a10 2
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a42 3
  character (len=*), private, parameter :: IdParm = &
       "$Id: global_settings.f90,v 2.96 2005/05/02 22:59:59 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d53 2
a54 2
    & FGrids, VGrids, l2gpDatabase, DirectDatabase, processingRange, filedatabase )
    ! & FGrids, VGrids, l2gpDatabase, DirectDatabase, processingRange, l1bInfo )
d112 1
a112 1
    use VGridsDatabase, only: AddVGridToDatabase, Dump, VGrid_T
a118 1
    type ( vGrid_T ), pointer, dimension(:) :: VGrids
d299 1
a299 2
            call dumpCommand ( son, forwardModelConfigs=forwardModelConfigDatabase, &
              & vGrids=vGrids )
d315 1
a315 1
            & ConstructForwardModelConfig ( name, son, vGrids, .true. ) ) )
d374 1
a374 1
          call Make_PFAData ( son, vGrids, returnStatus )
d377 1
a377 1
          call Get_PFAdata_from_l2cf ( son, name, vGrids, returnStatus )
d380 1
a380 1
          call read_PFAdata ( son, name, vGrids, returnStatus )
a505 8
    if ( index(switches, 'vgrid2') /= 0 ) then
      Details = 1
    else
      Details = 0
    end if
    if ( index(switches, 'vgrid') /= 0 ) &
      & call dump ( vgrids, details=Details )

d860 5
d871 3
@


2.97
log
@use if (...) continue to ignore a function result
@
text
@d48 2
a49 1
    & FGrids, VGrids, l2gpDatabase, DirectDatabase, processingRange, l1bInfo )
d77 2
a78 1
    use MLSCommon, only: R8, FileNameLen, NameLen, L1BInfo_T, TAI93_Range_T
d80 1
a80 1
      & GetPCFromRef, mls_hdf_version, split_path_name
d118 2
a119 1
    type (L1BInfo_T) :: l1bInfo    ! File handles etc. for L1B dataset
d152 1
d315 2
a316 1
          call l1boaSetup ( son, l1bInfo, F_FILE, hdfVersion=the_hdf_version )
d323 3
a325 2
          call ReadL1BAttribute (l1bInfo%l1boaID, OrbNum, 'OrbitNumber', &
               & l1bFlag, hdfVersion=the_hdf_version)
d331 2
a332 2
          call ReadL1BAttribute (l1bInfo%l1boaID, OrbPeriod, 'OrbitPeriod', &
               & l1bFlag, hdfVersion=the_hdf_version)
d346 2
a347 1
          call l1bradSetup ( son, l1bInfo, F_FILE, &
d399 1
d401 1
a401 1
      & mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
d405 1
a405 1
      & // trim(l1bInfo%L1BOAFileName) )
d420 1
a420 1
      if ( l1bInfo%L1BOAID == ILLEGALL1BRADID ) then
d427 2
a428 2
      call ReadL1BData ( l1bInfo%l1boaID, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, hdfVersion=the_hdf_version, dontPad=.true.)
d492 1
a492 2
      GlobalAttributes%LastMAFCtr = FindMaxMAF ( (/l1bInfo%L1BOAID/), &
        & the_hdf_version, &
d496 1
a496 1
      & call dump_global_settings( processingRange, l1bInfo, DirectDatabase, &
d600 3
a602 2
    subroutine dump_global_settings ( processingRange, l1bInfo, DirectDatabase, &
      & LeapSecFileName, dumpL1BDetails )
a611 2
      integer :: num_l1b_files = MAXNUML1BRADIDS

d613 2
a614 1
      type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
d640 1
d643 2
a644 2
      hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), &
        & LEVEL1_HDFVERSION)
d657 24
a680 21
     if ( associated(l1bInfo%L1BRADIDs) ) then
      if ( num_l1b_files > 0 ) then
        do i = 1, num_l1b_files
        if ( l1bInfo%L1BRADIDs(i) /= ILLEGALL1BRADID ) then
  	      call output ( 'fileid:   ' )
              call output ( l1bInfo%L1BRADIDs(i), advance='yes' )
         call output ( 'name:   ' )
    	   call output ( TRIM(l1bInfo%L1BRADFileNames(i)), advance='yes' )
         if ( myL1BDetails > -2 ) then
           l1b_quant_name = BASE_QUANT_NAME
           l1bItemName = AssembleL1BQtyName ( l1b_quant_name, hdfVersion, .false. )
           call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1bItemName, L1bData, &
            & NoMAFs, IERR, NeverFail=.true., hdfVersion=hdfVersion )
           if ( IERR == 0 ) then
             call Dump(l1bData, myL1BDetails )
             call DeallocateL1BData ( l1bData )
           else
             call output ( 'Error number  ' )
             call output ( IERR )
             call output ( ' while reading quantity named  ' )
             call output ( trim(l1b_quant_name), advance='yes' )
d682 14
a695 14
         end if
         if ( myL1BDetails > -2 .and. DUMPPRECISIONTOO ) then
           l1b_quant_name = trim(BASE_QUANT_NAME) // PRECISIONSUFFIX
           l1bItemName = AssembleL1BQtyName ( l1b_quant_name, hdfVersion, .false. )
           call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1bItemName, L1bData, &
            & NoMAFs, IERR, NeverFail=.true., hdfVersion=hdfVersion )
           if ( IERR == 0 ) then
             call Dump(l1bData, myL1BDetails )
             call DeallocateL1BData ( l1bData )
           else
             call output ( 'Error number  ' )
             call output ( IERR )
             call output ( ' while reading quantity named  ' )
             call output ( trim(l1b_quant_name), advance='yes' )
d697 8
a705 1
        end if
a707 6
      else
        call output ( '(empty database)', advance='yes' )
      end if

     else
      call output ( '(null database)', advance='yes' )
a708 13
     end if

      call output ( ' ', advance='yes' )
      call output ( 'L1OA file:', advance='yes' )

        if ( l1bInfo%L1BOAID /= ILLEGALL1BRADID ) then
        call output ( 'fileid:   ' )
        call output ( l1bInfo%L1BOAID, advance='yes' )
        call output ( 'name:   ' )
        call output ( TRIM(l1bInfo%L1BOAFileName), advance='yes' )
      else
        call output ( '(file unknown)', advance='yes' )
      end if
d871 3
@


2.96
log
@Add PFAFile command
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.95 2005/01/27 21:22:04 vsnyder Exp $"
a120 1
    integer :: F                   ! Index in PFAFiles -- unused function output
d263 2
a264 2
            f = process_PFA_File ( sub_rosa(subtree(j,son)), &
              & source_ref(subtree(j,son)) )
d872 3
@


2.95
log
@Different interface to ReadPFAData
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.94 2005/01/12 03:18:22 vsnyder Exp $"
d64 1
a64 1
      & P_LEAPSECFILE, P_OUTPUT_VERSION_STRING, P_STARTTIME, &
d92 3
a94 2
    use PFAData_m, only: Get_PFAdata_from_l2cf, Make_PFAData, Read_PFAData, &
      & Write_PFAData
d121 1
d123 1
a123 1
    integer :: I                   ! Index of son of root
d262 5
d873 3
@


2.94
log
@Read and write PFAData in HDF5
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.93 2004/12/31 02:43:05 vsnyder Exp $"
d66 4
a69 3
      & S_BINSELECTOR, S_DIRECTWRITEFILE, S_DUMP, S_EMPIRICALGEOMETRY, S_FGRID, &
      & S_FORWARDMODEL, S_ForwardModelGlobal, S_L1BOA, S_L1BRAD, S_L2PARSF, &
      & S_MAKEPFA, S_PFADATA, S_READPFA, S_TGRID, S_TIME, S_VGRID, S_WRITEPFA
d364 2
a365 1
          call read_PFAdata ( son, vGrids )
d866 3
@


2.93
log
@Working on read/write PFA database
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.92 2004/12/14 22:52:38 pwagner Exp $"
d363 1
a363 1
          call read_PFAdata ( son )
d864 3
@


2.92
log
@Changes related to stopping early
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.91 2004/12/13 20:19:48 vsnyder Exp $"
d67 2
a68 2
      & S_FORWARDMODEL, S_ForwardModelGlobal, S_L1BOA, S_L1BRAD, &
      & S_L2PARSF, S_MAKEPFA, S_PFADATA, S_TGRID, S_TIME, S_VGRID, S_WRITEPFA
d91 2
a92 1
    use PFAData_m, only: Get_PFAdata_from_l2cf, Make_PFAData, Write_PFAData
d97 1
a97 1
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
d119 1
a119 1
    logical :: GOT(2) = .false.
d127 1
a127 2
    integer :: Status              ! From CreateVGridFromMLSCFInfo
    logical :: stopEarly
d129 1
a129 1
    integer :: the_hdf_version     ! 4 or 5 (corresp. to hdf4 or hdf5)
d134 1
a134 1
!   double precision :: VALUE(2)  ! Output from Expr
d139 3
a141 3
    character(LEN=NameLen) :: Name_string
    character(LEN=NameLen) :: End_time_string, Start_time_string
    character(LEN=FileNameLen) :: FilenameString
d143 1
a143 1
    character(LEN=*), parameter :: Time_conversion='(F32.0)'
d153 1
d254 1
a254 1
          elseif ( TOOLKIT ) then
d305 1
a305 1
          if(index(switches, 'pro') /= 0) then  
d313 1
a313 1
               if (l1bFlag == -1) then
d320 1
a320 1
               if (l1bFlag == -1) then
d335 1
a335 1
          if(index(switches, 'pro') /= 0) then  
d349 1
a349 1
          if(index(switches, 'pro') /= 0) then  
d362 2
d390 1
a390 1
    elseif ( the_hdf_version <= 0 ) then                                          
d393 1
a393 1
    endif
d404 1
a404 1
      if(l1bInfo%L1BOAID == ILLEGALL1BRADID) then
d413 1
a413 1
      if ( l1bFlag==-1) then
d436 1
a436 1
      elseif(got(1)) then
d438 1
a438 1
      elseif(.not. TOOLKIT) then
d454 1
a454 1
      elseif(got(2)) then
d456 1
a456 1
      elseif(.not. TOOLKIT) then
d492 1
a492 1
    endif
d556 1
a556 1
         if (my_warning) then
d566 1
a566 1
        if ( .not. my_warning) then
d573 1
a573 1
         if(my_warning) then
d641 1
a641 1
     if(associated(l1bInfo%L1BRADIDs)) then
d644 1
a644 1
        if(l1bInfo%L1BRADIDs(i) /= ILLEGALL1BRADID) then
d694 1
a694 1
        if(l1bInfo%L1BOAID /= ILLEGALL1BRADID) then
d826 1
a826 1
    elseif ( Direct%Type ==  l_l2gp  ) then
d831 1
a831 1
    elseif ( Direct%Type ==  l_l2dgg ) then
d836 1
a836 1
    elseif ( Direct%Type ==  l_l2fwm  ) then
d864 3
@


2.91
log
@Added MakePFA, PFAData, WritePFA.  Improved error handling.  Removed dumps
triggered by switches == vgrid2 or vgrid, since the dump command can do it now.
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.90 2004/10/13 00:52:52 vsnyder Exp $"
d78 2
a79 2
    use MLSL2Options, only: ILLEGALL1BRADID, LEVEL1_HDFVERSION, MAXNUML1BRADIDS, &
      & Toolkit
d126 2
d150 1
d295 1
a295 1
          call forwardModelGlobalSetup ( son, returnStatus )
d298 1
a298 1
          call decorate (son, AddForwardModelConfigToDatabase ( &
d485 8
d861 4
@


2.90
log
@Get HHMMSS_value from MLSStrings, its new home
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.89 2004/08/17 23:49:36 pwagner Exp $"
d68 1
a68 1
      & S_L2PARSF, S_PFADATA, S_TGRID, S_TIME, S_VGRID
d91 1
a91 1
    use PFAData_m, only: Get_PFAdata_from_l2cf
a125 1
    integer :: Status              ! From CreateVGridFromMLSCFInfo
d207 2
a208 1
            start_time_from_1stMAF = hhmmss_value(name_string, error)
d226 2
a227 1
            end_time_from_1stMAF = hhmmss_value(name_string, error)
d308 2
a309 2
	       & l1bFlag, hdfVersion=the_hdf_version)
	       if (l1bFlag == -1) then
d311 1
a311 1
	       else
d313 1
a313 1
	       end if
d315 2
a316 2
	       & l1bFlag, hdfVersion=the_hdf_version)
	       if (l1bFlag == -1) then
d318 1
a318 1
	       else
d320 1
a320 1
	       end if
d352 3
d356 5
a360 2
          call Get_PFAdata_from_l2cf ( son, name, vGrids, status )
          error = max(error,status)
d370 2
a371 2
            & CreateVGridFromMLSCFInfo ( name, son, l2gpDatabase, status ) ) )
          error = max(error,status)
a481 8
    if ( index(switches, 'vgrid2') /= 0 ) then
      Details = 1
    else
      Details = 0
    endif
    if ( index(switches, 'vgrid') /= 0 ) &
      & call dump ( vgrids, details=Details )
      ! & call dump ( vgrids, details=levels(gen)-1+min(index(switches, 'V'),1) )
d632 1
a632 1
	      call output ( l1bInfo%L1BRADIDs(i), advance='yes' )
d850 3
@


2.89
log
@Dont pad when getting MAFStartTime
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.88 2004/08/16 17:14:42 pwagner Exp $"
d86 2
a87 1
    use MLSStringLists, only: hhmmss_value, utc_to_yyyymmdd
d117 1
a117 1
    integer :: Details   ! How much info about l1b files to dump
d851 3
@


2.88
log
@Obtains First,LastMAFCtr global attributes from l1boa file
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.87 2004/08/04 23:19:58 pwagner Exp $"
d398 1
a398 1
        & l1bFlag, hdfVersion=the_hdf_version)
d850 3
@


2.87
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.86 2004/07/26 18:22:48 pwagner Exp $"
d69 3
a71 3
    use L1BData, only: l1bradSetup, l1boaSetup, ReadL1BData, L1BData_T, &
      & AssembleL1BQtyName, DeallocateL1BData, Dump, NAME_LEN, &
      & PRECISIONSUFFIX, ReadL1BAttribute
d458 7
d850 3
@


2.86
log
@Fixed failure to set returnStatus bug in CreateDirectTypeFromMLSCFInfo
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.85 2004/06/17 22:49:36 pwagner Exp $"
d86 1
a86 2
    use MLSStrings, only: hhmmss_value, utc_to_yyyymmdd
    use MLSStrings, only: 
d843 3
@


2.85
log
@Details for dumping VGrids determined by switch setting
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.84 2004/06/17 00:39:02 vsnyder Exp $"
d799 1
d801 29
a829 29
      call split_path_name(filename, path, file_base)
      Direct%filenameBase = file_base
      if ( .not. TOOLKIT ) then
        Direct%handle = 0
        Direct%filename = filename
      elseif ( Direct%Type ==  l_l2gp  ) then
        Direct%Handle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
          & mlspcf_l2gp_end, &
          & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
          & exactName=Direct%Filename)
      elseif ( Direct%Type ==  l_l2dgg ) then
        Direct%Handle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
          & mlspcf_l2dgg_end, &
          & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
          & exactName=Direct%Filename)
      elseif ( Direct%Type ==  l_l2fwm  ) then
           Direct%Handle = GetPCFromRef(file_base, mlspcf_l2fwm_full_start, &
          & mlspcf_l2fwm_full_end, &
          & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
          & exactName=Direct%Filename)
      else
        Direct%Handle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
          & mlspcf_l2dgm_end, &
          & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
          & exactName=Direct%Filename)
      end if
      if ( returnStatus /= 0 ) call MLSMessage ( &
         & MLSMSG_Error, ModuleName, &
         & 'Failed in GetPCFromRef for ' // trim(filename) )
d844 3
@


2.84
log
@Make output of 'finished readL1BAttribute...' conditional on 'glo' switch
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.83 2004/06/08 19:28:07 vsnyder Exp $"
d468 5
d474 2
a475 1
      & call dump ( vgrids, details=levels(gen)-1+min(index(switches, 'V'),1) )
d843 3
@


2.83
log
@Add tGrid, improve error detection and reporting
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.82 2004/05/29 02:50:49 vsnyder Exp $"
d157 11
d320 2
a321 2
          call output ('finished readL1BAttribute in global_setting', &
		    & advance='yes')
a458 10
    endif

    if ( index(switches, 'glo3') /= 0 ) then
      Details = 1
    elseif ( index(switches, 'glo2') /= 0 ) then
      Details = 0
    elseif ( index(switches, 'glo1') /= 0 ) then
      Details = -1
    else
      Details = -2
d460 1
a460 1
    if( index(switches, 'glo') /= 0 ) &
d837 3
@


2.82
log
@Added more dumps
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.81 2004/05/22 02:31:40 vsnyder Exp $"
d68 1
a68 1
      & S_L2PARSF, S_PFADATA, S_TIME, S_VGRID
d126 1
d267 7
a273 2
          call dumpCommand ( son, forwardModelConfigs=forwardModelConfigDatabase, &
            & vGrids=vGrids )
d341 2
a342 1
          call Get_PFAdata_from_l2cf ( son, name, vGrids )
d350 1
a350 1
        case ( s_vgrid )
d352 2
a353 1
            & CreateVGridFromMLSCFInfo ( name, son, l2gpDatabase ) ) )
d836 3
@


2.81
log
@Hook in PFAData, dump
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.80 2004/03/24 01:02:55 livesey Exp $"
d266 2
a267 1
          call dumpCommand ( son, vGrids=vGrids )
d335 1
a335 1
          call Get_PFAdata_from_l2cf ( son, vGrids )
d828 3
@


2.80
log
@Make LeapSecFile public
@
text
@a5 5
  use MLSL2Options, only: TOOLKIT, MAXNUML1BRADIDS, ILLEGALL1BRADID, &
    & LEVEL1_HDFVERSION
  use MLSStrings, only: utc_to_yyyymmdd
  use PCFHdr, only: GlobalAttributes, FillTAI93Attribute
  use SDPToolkit, only: max_orbits
d36 1
a36 1
       "$Id: global_settings.f90,v 2.79 2004/01/23 01:09:48 pwagner Exp $"
d52 1
d54 1
a54 1
    use EXPR_M, only: EXPR
d61 1
a61 1
      & L_TRUE, L_L2GP, L_L2AUX, L_L2DGG, L_L2FWM, &
d66 1
a66 1
      & S_BINSELECTOR, S_DIRECTWRITEFILE, S_EMPIRICALGEOMETRY, S_FGRID, &
d68 1
a68 1
      & S_L2PARSF, S_TIME, S_VGRID
d78 2
a79 1
    use MLSL2Options, only: LEVEL1_HDFVERSION
d86 2
a87 1
    use MLSStrings, only: hhmmss_value
d91 3
a93 1
    use SDPTOOLKIT, only: mls_utctotai
d131 2
a132 2
    integer :: UNITS(2)            ! Output from Expr
    double precision :: VALUE(2)  ! Output from Expr
d265 7
a278 20
        case ( s_vgrid )
          call decorate ( son, AddVGridToDatabase ( vGrids, &
            & CreateVGridFromMLSCFInfo ( name, son, l2gpDatabase ) ) )
        case ( s_fgrid )
          call decorate ( son, AddFGridToDatabase ( fGrids, &
            & CreateFGridFromMLSCFInfo ( name, son ) ) )
        case ( s_l1brad )
          the_hdf_version = LEVEL1_HDFVERSION
          call l1bradSetup ( son, l1bInfo, F_FILE, &
            & MAXNUML1BRADIDS, ILLEGALL1BRADID, hdfVersion=the_hdf_version )
          if(index(switches, 'pro') /= 0) then  
            sub_rosa_index = sub_rosa(subtree(2,subtree(2, son)))
            call get_string ( sub_rosa_index, FilenameString, strip=.true. )
            call proclaim(FilenameString, 'l1brad', &                   
            & hdfVersion=the_hdf_version) 
          end if
          if ( TOOLKIT ) &
            & call announce_error(0, &
            & '*** l2cf overrides pcf for L1B Rad. file(s) ***', &
            & just_a_warning = .true.)
d308 14
d333 2
a334 2
        case ( s_empiricalGeometry )
          call InitEmpiricalGeometry ( son )
d342 3
d827 3
@


2.79
log
@Only directwrite files entered in global settings eligible to be auto-sourced
@
text
@d11 1
d37 1
d41 1
a41 1
       "$Id: global_settings.f90,v 2.78 2004/01/22 00:54:36 pwagner Exp $"
d139 1
a139 1
    character(LEN=FileNameLen) :: FilenameString, LeapSecFileName
d823 3
@


2.78
log
@Fixed mistaken impression that direct arg is a pointer
@
text
@d39 1
a39 1
       "$Id: global_settings.f90,v 2.77 2003/12/11 22:59:08 pwagner Exp $"
d771 1
d821 3
@


2.77
log
@May fill DirectWriteDatabase in global settings
@
text
@d39 1
a39 1
       "$Id: global_settings.f90,v 2.76 2003/11/15 00:46:41 pwagner Exp $"
d54 1
a54 1
      & AddDirectToDatabase, SetupNewDirect
d445 1
a445 1
      & call dump_global_settings( processingRange, l1bInfo, &
d543 1
a543 1
    subroutine dump_global_settings ( processingRange, l1bInfo, &
d560 1
d661 1
d746 2
a747 1
    type (DirectData_T), pointer :: Direct
d761 1
a761 1
    nullify(Direct)
d773 1
d778 1
d793 1
a793 1
        Direct%Handle = GetPCFromRef(file_base, mlspcf_l2fwm_full_start, &
d820 3
@


2.76
log
@maxfailurespermachine, maxfailuresperchunk no longer configuration settings (see comline opts)
@
text
@d39 1
a39 1
       "$Id: global_settings.f90,v 2.75 2003/09/26 21:55:54 pwagner Exp $"
d51 1
a51 1
    & FGrids, VGrids, l2gpDatabase, processingRange, l1bInfo )
d53 2
d62 2
a63 1
    use INIT_TABLES_MODULE, only: F_FILE, L_TRUE, &
d68 1
a68 1
      & S_BINSELECTOR, S_EMPIRICALGEOMETRY, S_FGRID, &
d78 2
a79 1
    use MLSFiles, only: FILENOTFOUND, mls_hdf_version
d83 4
d89 1
a89 1
    use MoreTree, only: GET_SPEC_ID
d109 1
d260 3
d741 63
d815 3
@


2.75
log
@Less likely to complain about missing attributes from hdf4 l1boa files
@
text
@d39 1
a39 1
       "$Id: global_settings.f90,v 2.74 2003/09/12 16:28:49 cvuu Exp $"
d60 2
a61 1
    use INIT_TABLES_MODULE, only: F_FILE, L_TRUE, P_ALLOW_CLIMATOLOGY_OVERLOADS, &
d64 1
a64 1
      & P_VERSION_COMMENT, P_MAXFAILURESPERMACHINE, P_MAXFAILURESPERCHUNK, &
d231 6
a236 6
        case ( p_maxfailurespermachine )
          call expr ( subtree(2,son), units, value )
          parallel%maxfailurespermachine = value(1)
        case ( p_maxfailuresperchunk )
          call expr ( subtree(2,son), units, value )
          parallel%maxfailuresperchunk = value(1)
d740 3
@


2.74
log
@Read OrbitNumber and OrbitPeriod attributes from L1BOA
@
text
@d39 1
a39 1
       "$Id: global_settings.f90,v 2.73 2003/09/02 18:03:23 pwagner Exp $"
a129 1
    integer ::  hdfVersion
a263 2
  ! ((( If we convert level 1 files to hdf5, return hdfVersion  )))
  !      as an argument from l1bradSetup
a277 2
  ! ((( If we convert level 1 files to hdf5, return hdfVersion  )))
  !      as an argument from l1boaSetup
d287 6
a292 6
	     & l1bFlag, hdfVersion=hdfVersion)
	  if (l1bFlag == -1) then
             GlobalAttributes%OrbNum = -1
	  else
             GlobalAttributes%OrbNum = OrbNum
	  end if
d294 6
a299 6
	     & l1bFlag, hdfVersion=hdfVersion)
	  if (l1bFlag == -1) then
             GlobalAttributes%OrbPeriod = -1.0
	  else
             GlobalAttributes%OrbPeriod = OrbPeriod
	  end if
d301 1
a301 1
		& advance='yes')
d332 3
a334 2
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
    if ( hdfversion == FILENOTFOUND ) then                                          
d338 1
a338 1
    elseif ( hdfversion <= 0 ) then                                          
d358 1
a358 1
      l1bItemName = AssembleL1BQtyName ( quantity, hdfVersion, .false. )
d360 1
a360 1
        & l1bFlag, hdfVersion=hdfVersion)
d739 3
@


2.73
log
@Now can reset maxfailuresper chunk, machine from global settings
@
text
@d10 1
d39 1
a39 1
       "$Id: global_settings.f90,v 2.72 2003/07/15 18:18:06 livesey Exp $"
d68 2
a69 1
      & AssembleL1BQtyName, DeallocateL1BData, Dump, NAME_LEN, PRECISIONSUFFIX
d132 2
d271 1
a271 1
            sub_rosa_index = sub_rosa(subtree(2,subtree(2, son)))                         
d291 16
d360 1
d743 3
@


2.72
log
@Change of forward model config call.
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.71 2003/07/07 23:50:04 pwagner Exp $"
d53 1
d62 2
a63 1
      & P_VERSION_COMMENT, S_BINSELECTOR, S_EMPIRICALGEOMETRY, S_FGRID, &
d117 2
d227 6
d722 3
@


2.71
log
@Now uses saved variable L2pcf from writeMetaData
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.70 2003/06/09 22:49:34 pwagner Exp $"
d243 1
a243 1
            & ConstructForwardModelConfig ( son, vGrids, .true. ) ) )
d712 3
@


2.70
log
@Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.69 2003/05/14 22:04:49 pwagner Exp $"
d50 1
a50 1
    & FGrids, VGrids, l2gpDatabase, l2pcf, processingRange, l1bInfo )
d88 1
a88 1
    use WriteMetadata, only: PCFData_T
d99 1
a99 1
    type (PCFData_T) :: l2pcf
d405 1
a405 1
      & call dump_global_settings( l2pcf, processingRange, l1bInfo, &
d503 1
a503 1
    subroutine dump_global_settings ( l2pcf, processingRange, l1bInfo, &
d518 1
a518 1
      type(PCFData_T) :: l2pcf
d712 3
@


2.69
log
@Bad leapsecfile name now prints sensibly & stops
@
text
@d6 1
a6 1
  use MLSL2Options, only: PCF, MAXNUML1BRADIDS, ILLEGALL1BRADID, &
d38 1
a38 1
       "$Id: global_settings.f90,v 2.68 2003/05/12 20:57:21 pwagner Exp $"
d147 1
a147 1
          if ( pcf ) &
d154 1
a154 1
          if ( pcf ) &
d164 1
a164 1
          if ( pcf ) &
d186 1
a186 1
          if ( pcf ) &
d204 1
a204 1
          if ( pcf ) &
d218 1
a218 1
          elseif ( pcf ) then
d262 1
a262 1
          if ( pcf ) &
d277 1
a277 1
          if ( pcf ) &
d288 1
a288 1
          if ( pcf ) &
d322 1
a322 1
     & (got(1) .or. got(2) .or. .not. PCF) &
d359 1
a359 1
      elseif(.not. PCF) then
d377 1
a377 1
      elseif(.not. PCF) then
d382 1
a382 1
    if ( .not. PCF ) then
d712 3
@


2.68
log
@Added L2ParSF spec to allow changing staging file name in global settings
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.67 2003/05/10 22:20:50 livesey Exp $"
d216 2
d712 3
@


2.67
log
@Tried to calm down -g1..
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.66 2003/05/07 23:58:04 pwagner Exp $"
d62 2
a63 1
      & S_FORWARDMODEL, S_ForwardModelGlobal, S_L1BOA, S_L1BRAD, S_TIME, S_VGRID
d67 1
d279 11
a289 12
!        Not a spec but a parameter
!        case ( s_leapsecfile )
!          if ( .not. pcf ) then  
!            sub_rosa_index = sub_rosa(subtree(2,subtree(2, son)))
!            call get_string ( sub_rosa_index, LeapSecFileName, strip=.true. )
!            if(index(switches, 'pro') /= 0) &  
!            & call proclaim(LeapSecFileName, 'leapsecfile')
!          else
!            call announce_error(0, &
!            & '*** Leap Second File in global settings despite pcf ***', &
!            & just_a_warning = .true.)
!          end if
d710 3
@


2.66
log
@outputs trimmed LeapSecFileName
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.65 2003/04/02 23:54:53 pwagner Exp $"
d401 1
a401 2
    if( levels(gen) > 0 .or. &
      & index(switches, 'glo') /= 0 ) &
d409 2
a411 2
      if (  levels(gen) > 0 .or. index(switches, 'V') /= 0 ) &
        & call dump ( vgrids, details=levels(gen)-1+min(index(switches, 'V'),1) )
d709 3
@


2.65
log
@Checks for FILENOTFOUND
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.64 2003/02/27 21:55:14 pwagner Exp $"
d636 1
a636 1
        call output ( LeapSecFileName, advance='yes' )
d710 3
@


2.64
log
@Calls FillTAI93Attribute
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.63 2003/02/01 00:50:14 pwagner Exp $"
d68 1
a68 1
    use MLSFiles, only: mls_hdf_version
d305 6
a310 2
    if ( hdfversion <= 0 ) &                                            
      & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
d312 1
d710 3
@


2.63
log
@Picks up GlobalAttributes from settings
@
text
@d9 1
a9 1
  use PCFHdr, only: GlobalAttributes
d38 1
a38 1
       "$Id: global_settings.f90,v 2.62 2002/12/11 22:17:55 pwagner Exp $"
d380 1
d705 3
@


2.62
log
@Added error checks on hdf version
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d8 2
d38 1
a38 1
       "$Id: global_settings.f90,v 2.61 2002/11/13 01:07:40 pwagner Exp $"
d374 12
d704 3
@


2.61
log
@Actually reads hdf5 radiances
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.60 2002/10/08 17:36:20 pwagner Exp $"
d303 3
d522 5
a526 1
      hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
d690 3
@


2.60
log
@Added idents to survive zealous Lahey optimizer
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.59 2002/10/03 23:01:19 pwagner Exp $"
d62 1
a62 1
      & DeallocateL1BData, Dump, NAME_LEN, PRECISIONSUFFIX
d66 2
a98 1
    integer :: hdfVersion          ! 4 or 5 (corresp. to hdf4 or hdf5)
d107 1
a107 1
    integer :: the_hdf_version
d120 2
d302 1
d318 3
a320 2
      call ReadL1BData ( l1bInfo%l1boaID, quantity, l1bField, noMAFs, &
        & l1bFlag)
d515 2
d519 1
d539 3
a541 2
           call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1b_quant_name, L1bData, &
            & NoMAFs, IERR, NeverFail=.true. )
d554 3
a556 2
           call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1b_quant_name, L1bData, &
            & NoMAFs, IERR, NeverFail=.true. )
d683 3
@


2.59
log
@gets the_hdf_version from l1b..setup
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.58 2002/09/25 20:09:14 livesey Exp $"
d40 1
d666 4
d673 3
@


2.58
log
@New global argument to ConstructForwardModelConfig
@
text
@d13 14
d36 1
a36 1
       "$Id: global_settings.f90,v 2.57 2002/08/28 22:26:39 pwagner Exp $"
d105 1
d243 1
d245 1
a245 1
            & MAXNUML1BRADIDS, ILLEGALL1BRADID )
d250 1
a250 1
            & hdfVersion=LEVEL1_HDFVERSION) 
d259 2
a260 1
          call l1boaSetup ( son, l1bInfo, F_FILE )
d265 1
a265 1
            & hdfVersion=LEVEL1_HDFVERSION) 
d668 3
@


2.57
log
@Moved LEVEL1_HDFVERSION, ILLEGALL1BRADID, MAXNUML1BRADIDS to MLSL2Options
@
text
@d22 1
a22 1
       "$Id: global_settings.f90,v 2.56 2002/08/20 23:02:17 vsnyder Exp $"
d217 2
a218 1
            & forwardModelConfigDatabase, ConstructForwardModelConfig ( son, vGrids ) ) )
d651 3
@


2.56
log
@Move USE statements from module scope to procedure scope
@
text
@d6 2
a7 1
  use MLSPCF2, only: MLSPCF_L1B_RAD_END, MLSPCF_L1B_RAD_START
a14 6
  integer, parameter :: LEVEL1_HDFVERSION = 4  ! Until we convert level 1 to hdf5

  integer, public, parameter :: ILLEGALL1BRADID=-1      ! something sfstart should catch
  integer, public, parameter :: MAXNUML1BRADIDS=&
  & mlspcf_l1b_rad_end-mlspcf_l1b_rad_start+1   ! In case more than one

d22 1
a22 1
       "$Id: global_settings.f90,v 2.55 2002/05/01 22:03:50 pwagner Exp $"
a50 1
    use MLSL2Options, only: PCF
d650 3
@


2.55
log
@If leapsecfile parameter set, will convert start, end times
@
text
@a5 21
  use EmpiricalGeometry, only: INITEMPIRICALGEOMETRY
  use FGrid, only: AddFGridToDatabase, CreateFGridFromMLSCFInfo, FGrid_T
  use ForwardModelConfig, only: AddForwardModelConfigToDatabase, &
    & ForwardModelConfig_T
  use ForwardModelSupport, only: ConstructForwardModelConfig, &
    & ForwardModelGlobalSetup, CreateBinSelectorFromMLSCFInfo
  use INIT_TABLES_MODULE, only: L_TRUE, P_ALLOW_CLIMATOLOGY_OVERLOADS, &
    & P_INPUT_VERSION_STRING, P_OUTPUT_VERSION_STRING, P_VERSION_COMMENT, &
    & S_FGRID, S_FORWARDMODEL, S_ForwardModelGlobal, S_TIME, S_VGRID, F_FILE, &
    & P_CYCLE, P_STARTTIME, P_ENDTIME, P_LEAPSECFILE, &
    & S_L1BRAD, S_L1BOA, P_INSTRUMENT, S_EMPIRICALGEOMETRY, &
    & S_BINSELECTOR
  use L1BData, only: l1bradSetup, l1boaSetup, ReadL1BData, L1BData_T, &
    & DeallocateL1BData, Dump, NAME_LEN, PRECISIONSUFFIX
  use L2GPData, only: L2GPDATA_T
  use L2PC_M, only: AddBinSelectorToDatabase, BinSelectors
  use LEXER_CORE, only: PRINT_SOURCE
  use MLSCommon, only: R8, FileNameLen, NameLen, L1BInfo_T, TAI93_Range_T
  use MLSL2Options, only: PCF
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
a6 15
  use MLSStrings, only: hhmmss_value
  use MLSSignals_m, only: INSTRUMENT
  use MoreTree, only: GET_SPEC_ID
  use OUTPUT_M, only: BLANKS, OUTPUT
  use SDPTOOLKIT, only: mls_utctotai
  use String_Table, only: Get_String
  use Time_M, only: Time_Now
  use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, SUB_ROSA, SUBTREE, &
  & DUMP_TREE_NODE, SOURCE_REF
  use TREE_TYPES, only: N_EQUAL, N_NAMED
  use VGrid, only: CreateVGridFromMLSCFInfo
  use VGridsDatabase, only: AddVGridToDatabase, Dump, VGrid_T
  use WriteMetadata, only: PCFData_T
d27 1
a27 1
       "$Id: global_settings.f90,v 2.54 2002/05/01 16:14:13 pwagner Exp $"
d40 35
d82 3
a84 3
    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
    type (L1BData_T) :: l1bField ! L1B data
    type(PCFData_T) :: l2pcf
d88 2
a89 2
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: I         ! Index of son of root
d91 11
a101 11
    real(r8) :: MINTIME, MAXTIME        ! Time Span in L1B file data
    integer :: NAME      ! Sub-rosa index of name of vGrid or hGrid
    integer :: NOMAFS             ! Number of MAFs of L1B data read
    integer :: returnStatus             ! non-zero means trouble
    integer :: SON       ! Son of root
    integer :: sub_rosa_index
    logical :: TIMING    ! For S_Time
    logical :: startTimeIsAbsolute, stopTimeIsAbsolute
    real :: T1, T2       ! For S_Time
    real(r8) :: start_time_from_1stMAF, end_time_from_1stMAF
    logical ::  itExists
d104 2
a105 2
    character(LEN=NameLen) :: name_string
    character(LEN=NameLen) :: end_time_string, start_time_string
d108 1
a108 1
    character(LEN=*), parameter :: time_conversion='(F32.0)'
d168 1
a168 1
          endif
d186 1
a186 1
          endif
d203 1
a203 1
          endif
d240 1
a240 1
          endif
d254 1
a254 1
          endif
d270 1
a270 1
!          endif
d299 1
a299 1
      endif
d311 1
a311 1
      endif
d313 1
a313 1
    endif
d325 1
a325 1
        endif
d330 1
a330 1
      endif
d343 1
a343 1
        endif
d348 1
a348 1
      endif
d359 1
a359 1
    endif
d378 36
a413 12
    ! --------------------------------------------------  SayTime  -----
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      endif
      call output ( "Timing for GlobalSettings = " )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime
d415 6
a420 1
  end subroutine SET_GLOBAL_SETTINGS
d422 2
a423 1
! =====     Private Procedures     =====================================
d425 1
a425 108
  ! ---------------------------------------------  proclaim  -----
  subroutine proclaim ( Name, l1_type, hdfVersion )
    character(LEN=*), intent(in)   :: Name
    character(LEN=*), intent(in)   :: l1_type
    integer, optional,  intent(in) :: hdfVersion

    call output ( 'Level 1 product type : ' )
    call output ( trim(l1_type), advance='no')
    if ( present(hdfVersion) ) then
      call blanks(4)
      call output ( 'hdf ' )
      call output ( hdfVersion, advance='yes')
    else
      call output ( ' ', advance='yes')
    endif
    call blanks(15)
    call output ( 'name : ' )
    call blanks(8)
    call output ( trim(Name), advance='yes')
  end subroutine proclaim

  ! ------------------------------------------  dump_global_settings  -----
  subroutine dump_global_settings ( l2pcf, processingRange, l1bInfo, &
    & LeapSecFileName, dumpL1BDetails )
  
    ! Dump info obtained during OpenAndInitialize and global_settings:
    ! L1B databse
    ! L1OA file
    ! Start and end times
    ! output version
    ! cycle number
    ! logfile name
  
    integer :: num_l1b_files = MAXNUML1BRADIDS

    ! Arguments
    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
    type(PCFData_T) :: l2pcf
    type (TAI93_Range_T) :: processingRange ! Data processing range
    
    ! The following dtermines the level of detail to expose:
    ! -1 Skip even counterMAF
    ! -2 Skip all but name (default)
    ! >0 Dump even multi-dim arrays
    integer, optional, intent(in) :: dumpL1BDetails
    character(len=*) LeapSecFileName
!    character(len=CCSDSlen) CCSDSStartTime
	
    ! Local

    type (L1BData_T) :: l1bData   ! L1B dataset
    integer ::                              i, version, NoMAFs, IERR
    integer ::                              myL1BDetails
    character (len=*), parameter ::         TIME_FORMAT = '(1pD18.12)'
    character (len=NAME_LEN), parameter ::  BASE_QUANT_NAME = &
                                    &       'R2:190.B3F:N2O.S2.FB25-3'
!                                    &       'R1A:118.B1F:PT.S0.FB25-1'
    character (len=LEN(BASE_QUANT_NAME)) :: l1b_quant_name
    logical, parameter ::                   DUMPPRECISIONTOO = .true.

    ! Begin
    myL1BDetails = -2
    if ( present(dumpL1BDetails) ) myL1BDetails = dumpL1BDetails
    version = 1

    call output ( '============ Global Settings ============', advance='yes' )
    call output ( ' ', advance='yes' )
  
    call output ( 'L1B database:', advance='yes' )
  
   if(associated(l1bInfo%L1BRADIDs)) then
    if ( num_l1b_files > 0 ) then
      do i = 1, num_l1b_files
      if(l1bInfo%L1BRADIDs(i) /= ILLEGALL1BRADID) then
  	    call output ( 'fileid:   ' )
	    call output ( l1bInfo%L1BRADIDs(i), advance='yes' )
       call output ( 'name:   ' )
    	 call output ( TRIM(l1bInfo%L1BRADFileNames(i)), advance='yes' )
       if ( myL1BDetails > -2 ) then
         l1b_quant_name = BASE_QUANT_NAME
         call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1b_quant_name, L1bData, &
          & NoMAFs, IERR, NeverFail=.true. )
         if ( IERR == 0 ) then
           call Dump(l1bData, myL1BDetails )
           call DeallocateL1BData ( l1bData )
         else
           call output ( 'Error number  ' )
           call output ( IERR )
           call output ( ' while reading quantity named  ' )
           call output ( trim(l1b_quant_name), advance='yes' )
         endif
       endif
       if ( myL1BDetails > -2 .and. DUMPPRECISIONTOO ) then
         l1b_quant_name = trim(BASE_QUANT_NAME) // PRECISIONSUFFIX
         call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1b_quant_name, L1bData, &
          & NoMAFs, IERR, NeverFail=.true. )
         if ( IERR == 0 ) then
           call Dump(l1bData, myL1BDetails )
           call DeallocateL1BData ( l1bData )
         else
           call output ( 'Error number  ' )
           call output ( IERR )
           call output ( ' while reading quantity named  ' )
           call output ( trim(l1b_quant_name), advance='yes' )
         endif
       endif
      endif
      end do
d427 2
a428 3
    else
      call output ( '(empty database)', advance='yes' )
    end if
d430 6
a435 2
   else
    call output ( '(null database)', advance='yes' )
d437 3
a439 1
   endif
d441 4
a444 11
    call output ( ' ', advance='yes' )
    call output ( 'L1OA file:', advance='yes' )
  
      if(l1bInfo%L1BOAID /= ILLEGALL1BRADID) then
      call output ( 'fileid:   ' )
      call output ( l1bInfo%L1BOAID, advance='yes' )
      call output ( 'name:   ' )
      call output ( TRIM(l1bInfo%L1BOAFileName), advance='yes' )
    else
      call output ( '(file unknown)', advance='yes' )
    end if
d446 10
a455 3
    call output ( ' ', advance='yes' )
    call output ( 'Start Time:   ' )
    call output ( l2pcf%startutc, advance='yes' )
d457 1
a457 2
    call output ( 'End Time:     ' )
    call output ( l2pcf%endutc, advance='yes' )
d459 87
a545 2
    call output ( 'Start Time (tai):   ' )
    call output ( processingrange%starttime, format=TIME_FORMAT, advance='yes' )
d547 3
a549 2
    call output ( 'End Time (tai):     ' )
    call output ( processingrange%endtime, format=TIME_FORMAT, advance='yes' )
d551 2
a552 2
    call output ( 'Processing Range:     ' )
    call output ( processingrange%endtime-processingrange%starttime, advance='yes' )
d554 1
a554 4
    if ( LeapSecFileName /= '' ) then
      call output ( 'Leap Seconds File:   ' )
      call output ( LeapSecFileName, advance='yes' )
    endif
d556 2
a557 2
    call output ( 'PGE version:   ' )
    call output ( l2pcf%PGEVersion, advance='yes' )
d559 8
a566 2
    call output ( 'input version:   ' )
    call output ( l2pcf%InputVersion, advance='yes' )
d568 3
a570 2
    call output ( 'cycle:   ' )
    call output ( l2pcf%cycle, advance='yes' )
d572 2
a573 2
    call output ( 'Log file name:   ' )
    call output ( TRIM(l2pcf%logGranID), advance='yes' )
d575 2
a576 2
    call output ( 'l2gp species name keys:   ' )
    call output ( TRIM(l2pcf%spec_keys), advance='yes' )
d578 2
a579 2
    call output ( 'corresponding mcf hash:   ' )
    call output ( TRIM(l2pcf%spec_hash), advance='yes' )
d581 2
a582 2
    call output ( 'Allow climatology overloads?:   ' )
    call output ( allow_climatology_overloads, advance='yes' )
d584 4
a587 2
    call output ( ' ', advance='yes' )
    call output ( '============ End Global Settings ============', advance='yes' )
d589 2
a590 1
  end subroutine dump_global_settings
d592 2
a593 5
  ! ---------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( Lcf_where, Full_message, Use_toolkit, &
    & Error_number, just_a_warning )
  
    ! Arguments
d595 2
a596 5
    integer, intent(in) :: Lcf_where
    character(LEN=*), intent(in) :: Full_message
    logical, intent(in), optional :: Use_toolkit
    integer, intent(in), optional :: Error_number
    logical, intent(in), optional :: just_a_warning
d598 2
a599 3
    ! Local
    logical :: Just_print_it, my_warning
    logical, parameter :: Default_output_by_toolkit = .true.
d601 2
a602 7
    just_print_it = .not. default_output_by_toolkit
    if ( present(use_toolkit) ) just_print_it = .not. use_toolkit
    if ( present(just_a_warning) ) then
      my_warning = just_a_warning
    else
      my_warning = .false.
    endif
d604 2
a605 4
    if ( .not. just_print_it ) then
     if ( .not. my_warning ) then
      error = max(error,1)
      call output ( '***** At ' )
d607 2
a608 5
      if ( lcf_where > 0 ) then
        call print_source ( source_ref(lcf_where) )
      else
        call output ( '(no lcf node available)' )
      end if
d610 2
a611 6
      call output ( ": The " );
      if ( lcf_where > 0 ) then
        call dump_tree_node ( lcf_where, 0 )
      else
        call output ( '(no lcf tree available)' )
      end if
d613 1
a613 2
      call output ( " Caused the following error:", advance='yes', &
       & from_where=ModuleName)
d615 5
a619 4
      endif
      
      call output ( trim(full_message), advance='yes', &
        & from_where=ModuleName)
d621 6
a626 3
      if ( present(error_number) ) then
       if (my_warning) then
        call output ( 'Warning number ', advance='no' )
d628 7
a634 2
        call output ( 'Error number ', advance='no' )
      endif
d636 7
a642 1
        call output ( error_number, places=9, advance='yes' )
d644 4
a647 1
    else
d649 1
a649 15
      if ( .not. my_warning) then
      call output ( '***Error in module ' )
      call output ( ModuleName, advance='yes' )
      endif
      
      call output ( trim(full_message), advance='yes' )
      if ( present(error_number) ) then
       if(my_warning) then
        call output ( 'Warning number ' )
      else
        call output ( 'Error number ' )
       endif
        call output ( error_number, advance='yes' )
      end if
    end if
d651 1
a651 3
!===========================
  end subroutine Announce_Error
!===========================
d656 3
@


2.54
log
@Dropped S_LEAPSECFILE
@
text
@d15 1
a15 1
    & P_CYCLE, P_STARTTIME, P_ENDTIME, &
d63 1
a63 1
       "$Id: global_settings.f90,v 2.53 2002/04/29 17:42:16 pwagner Exp $"
d102 1
d163 1
d181 1
d192 13
d260 1
d288 1
d291 4
a294 1
    if(got(1) .or. got(2) .or. .not. PCF) then
d363 2
a364 1
      & call dump_global_settings( l2pcf, processingRange, l1bInfo, details )
d419 1
a419 1
    & dumpL1BDetails )
d441 1
a441 1
!    character(len=CCSDSlen) CCSDSEndTime
d542 5
d657 3
@


2.53
log
@Can convert starttime, endtime to tai w/o pcf
@
text
@d16 1
a16 1
    & S_L1BRAD, S_L1BOA, S_LEAPSECFILE, P_INSTRUMENT, S_EMPIRICALGEOMETRY, &
d63 1
a63 1
       "$Id: global_settings.f90,v 2.52 2002/02/08 22:52:56 livesey Exp $"
d244 11
a254 11
        case ( s_leapsecfile )
          if ( .not. pcf ) then  
            sub_rosa_index = sub_rosa(subtree(2,subtree(2, son)))
            call get_string ( sub_rosa_index, LeapSecFileName, strip=.true. )
            if(index(switches, 'pro') /= 0) &  
            & call proclaim(LeapSecFileName, 'leapsecfile')
          else
            call announce_error(0, &
            & '*** Leap Second File in global settings despite pcf ***', &
            & just_a_warning = .true.)
          endif
d630 3
@


2.52
log
@Hooked up bin selectors
@
text
@d16 2
a17 1
    & S_L1BRAD, S_L1BOA, P_INSTRUMENT, S_EMPIRICALGEOMETRY, S_BINSELECTOR
d32 1
d63 1
a63 1
       "$Id: global_settings.f90,v 2.51 2002/01/24 00:14:26 pwagner Exp $"
d105 2
a106 1
    character(LEN=FileNameLen) :: FilenameString
d116 1
d158 1
d175 1
d244 11
d298 9
a306 1
      if(got(1)) then
d316 9
a324 1
      if(got(2)) then
d630 3
@


2.51
log
@Proclaims level 1 files as input; comments concerning hdf5 conversion
@
text
@d11 1
a11 1
    & ForwardModelGlobalSetup
d16 1
a16 1
    & S_L1BRAD, S_L1BOA, P_INSTRUMENT, S_EMPIRICALGEOMETRY
d20 1
d61 1
a61 1
       "$Id: global_settings.f90,v 2.50 2001/12/16 00:57:26 livesey Exp $"
d194 3
d597 3
@


2.50
log
@Temporary fix to deal with tai93 time issues for sids
@
text
@d1 1
a1 1
 ! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
a6 1
  use EXPR_M, only: EXPR   
d21 1
a21 1
  use MLSCommon, only: R8, NameLen, L1BInfo_T, TAI93_Range_T
d47 2
d60 1
a60 1
       "$Id: global_settings.f90,v 2.49 2001/12/10 20:22:22 livesey Exp $"
d86 1
a97 2
    integer :: UNITS(2)  ! Units of expression
    real(r8) :: VALUE(2)   ! Value of expression
d102 1
d206 2
d210 6
d221 2
d224 6
d335 23
d593 3
@


2.49
log
@Added code for EmpiricalGeometry
@
text
@d59 1
a59 1
       "$Id: global_settings.f90,v 2.48 2001/11/09 23:17:22 vsnyder Exp $"
d82 1
a82 1
    
d94 1
d100 1
d108 3
a110 1
   error = 0
d145 4
a148 4
!        case ( p_ccsdsstarttime )
!          call get_string ( sub_rosa_index, l2pcf%startutc, strip=.true. )
!        case ( p_ccsdsendtime )
!          call get_string ( sub_rosa_index, l2pcf%endutc, strip=.true. )
d154 1
d156 4
a159 2
            call expr ( subtree(2,son), units, value )
            start_time_from_1stMAF = value(1)
d170 1
d172 4
a175 2
            call expr ( subtree(2,son), units, value )
            end_time_from_1stMAF = value(1)
d182 1
a182 1
         call announce_error(son, 'unrecognized global settings parameter')
d206 1
a206 1
          & MAXNUML1BRADIDS, ILLEGALL1BRADID )
d227 1
a227 1
         call announce_error(son, 'unrecognized global settings spec')
d232 13
a244 13
   ! add maf offsets to start, end times
   ! This is optional way to define processingRange if using PCF
   ! It becomes mandatory if not using PCF
   if(got(1) .or. got(2) .or. .not. PCF) then
   
   ! 1st--check that have L1BOA
     if(l1bInfo%L1BOAID == ILLEGALL1BRADID) then
       call announce_error(son, &
       & 'L1BOA file required by global data--but not set')
     endif
     quantity = 'MAFStartTimeTAI'
     call ReadL1BData ( l1bInfo%l1boaID, quantity, l1bField, noMAFs, &
          & l1bFlag)
d246 1
a246 1
            call announce_error(son, &
d248 2
a249 2
           minTime = 0.
           maxTime = 0.
d251 2
a252 2
           minTime = l1bField%dpField(1,1,1)
           maxTime = l1bField%dpField(1,1,noMAFs) ! This is start time of last MAF
d255 11
a265 6
   endif
   if(got(1)) then
      processingrange%starttime = minTime + start_time_from_1stMAF
   elseif(.not. PCF) then
      processingrange%starttime = minTime
   endif
d267 9
a275 5
   if(got(2)) then
      processingrange%endtime = minTime + end_time_from_1stMAF
   elseif(.not. PCF) then
      processingrange%endtime = maxTime + 1.0
   endif
d277 12
a288 12
   if ( index(switches, 'glo3') /= 0 ) then
     Details = 1
   elseif ( index(switches, 'glo2') /= 0 ) then
     Details = 0
   elseif ( index(switches, 'glo1') /= 0 ) then
     Details = -1
   else
     Details = -2
   endif
   if( levels(gen) > 0 .or. &
   & index(switches, 'glo') /= 0 ) &
   & call dump_global_settings( l2pcf, processingRange, l1bInfo, details )
d292 1
a292 1
        & 'Problem with global settings section')
d553 3
@


2.48
log
@Use Time_Now instead of CPU_TIME
@
text
@d6 1
d17 1
a17 1
    & S_L1BRAD, S_L1BOA, P_INSTRUMENT
d59 1
a59 1
       "$Id: global_settings.f90,v 2.47 2001/10/31 18:36:42 livesey Exp $"
d207 2
a208 1

d534 3
@


2.47
log
@Added fGrids stuff
@
text
@d31 1
d58 1
a58 1
       "$Id: global_settings.f90,v 2.46 2001/10/30 00:37:09 pwagner Exp $"
d103 1
a103 1
    if ( timing ) call cpu_time ( t1 )
d211 1
a211 1
            call cpu_time ( t1 )
d284 1
a284 1
      call cpu_time ( t2 )
d532 3
@


2.46
log
@Now can dump more l1b data
@
text
@d7 1
d14 1
a14 1
    & S_FORWARDMODEL, S_ForwardModelGlobal, S_TIME, S_VGRID, F_FILE, &
d57 1
a57 1
       "$Id: global_settings.f90,v 2.45 2001/10/26 23:18:35 pwagner Exp $"
d68 1
a68 1
    & VGrids, l2gpDatabase, l2pcf, processingRange, l1bInfo )
d73 1
d189 3
d531 3
@


2.45
log
@Complies with l1b data dump
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d17 1
a17 1
    & DeallocateL1BData, Dump, NAME_LEN
d25 1
a25 1
  use MLSStrings, only: unquote, hhmmss_value
d56 1
a56 1
       "$Id: global_settings.f90,v 2.44 2001/10/25 23:35:52 pwagner Exp $"
a153 6
 !         print *, 'starttime'
 !         print *, trim(name_string)
 !         print *, trim(unquote(name_string))
 !         name_string = unquote(name_string)
 !         read(name_string, time_conversion) &
 !         &           processingrange%starttime
a166 7
 !         call get_string ( sub_rosa_index, name_string, strip=.true. )
 !         print *, 'endtime'
 !         print *, trim(name_string)
 !         print *, trim(unquote(name_string))
 !         name_string = unquote(name_string)
 !         read(name_string, time_conversion) &
 !         &           processingrange%endtime
d321 8
a328 6
    integer :: i, version, NoMAFs, IERR
    integer :: myL1BDetails
    character (len=*), parameter :: time_format='(1pD18.12)'
    character (len=*), parameter :: l1b_quant_name='R1A:118.B1F:PT.S0.FB25-1'

    type (L1BData_T) :: l1bField ! L1B data
d349 15
d373 1
a373 1
           call output ( trim(l1b_quant_name) )
d408 1
a408 1
    call output ( processingrange%starttime, format=time_format, advance='yes' )
d411 1
a411 1
    call output ( processingrange%endtime, format=time_format, advance='yes' )
d526 3
@


2.44
log
@Responds to global switch with bigger dump than glo switch
@
text
@d16 2
a17 2
  use L1BData, only: l1bradSetup, l1boaSetup, ReadL1BData, L1BData_T, NAME_LEN, &
    & DeallocateL1BData, DumpL1BData
d56 1
a56 1
       "$Id: global_settings.f90,v 2.43 2001/09/28 23:59:20 pwagner Exp $"
d79 1
a79 1
    integer :: Details
d263 1
a263 1
   if ( index(switches, 'global') /= 0 ) then
d265 4
d363 1
a363 1
           call DumpL1BData(l1bData, myL1BDetails )
d522 3
@


2.43
log
@Fixed various timing problems
@
text
@d17 1
a17 1
    & DeallocateL1BData
d56 1
a56 1
       "$Id: global_settings.f90,v 2.42 2001/09/28 17:50:30 pwagner Exp $"
d79 1
d263 5
d270 1
a270 1
   & call dump_global_settings( l2pcf, processingRange, l1bInfo )
d301 2
a302 1
  subroutine dump_global_settings ( l2pcf, processingRange, l1bInfo )
d318 6
d329 3
a331 1
    integer :: i, version
d333 3
d338 2
d353 15
a367 2
      	call output ( 'name:   ' )
    	   call output ( TRIM(l1bInfo%L1BRADFileNames(i)), advance='yes' )
d518 3
@


2.42
log
@MLSL2Timings module keeps timing info
@
text
@d20 1
a20 1
  use MLSCommon, only: R8, NameLen, L1BInfo_T, TAI93_Range_T, FileNameLen
d23 1
a23 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate
d27 1
a27 1
  use MoreTree, only: GET_FIELD_ID, GET_SPEC_ID
a38 2
  use Intrinsic, only: L_EMLS, L_UMLS

d56 1
a56 1
       "$Id: global_settings.f90,v 2.41 2001/09/17 23:13:09 livesey Exp $"
a80 1
    integer :: KEY       ! A P_... parameter from Init_Tables_Module
d99 2
a100 1
    
d316 1
a316 2
    character (LEN=FileNameLen) :: physicalFilename
    integer :: i, returnStatus, version
d485 3
@


2.41
log
@Added instrument stuff to global settings etc
@
text
@d22 1
d28 1
a28 1
  use Output_m, only: Output
d58 1
a58 1
       "$Id: global_settings.f90,v 2.40 2001/07/12 23:28:15 livesey Exp $"
d101 1
a101 1
    timing = .false.
d284 5
d488 3
@


2.40
log
@Got rid of s_cloudForwardModel
@
text
@d15 1
a15 1
    & S_L1BRAD, S_L1BOA
d25 1
d38 2
d57 1
a57 1
       "$Id: global_settings.f90,v 2.39 2001/07/09 22:53:20 pwagner Exp $"
d129 2
d482 3
@


2.39
log
@Obeys CloudForwardModel; for now same as ForwardModel
@
text
@d15 1
a15 2
    & S_L1BRAD, S_L1BOA, &
    & S_CLOUDFORWARDMODEL
d54 1
a54 1
       "$Id: global_settings.f90,v 2.38 2001/06/07 21:58:28 pwagner Exp $"
a188 3
        case ( s_cloudforwardModel )
          call decorate (son, AddForwardModelConfigToDatabase ( &
            & forwardModelConfigDatabase, ConstructForwardModelConfig ( son, vGrids ) ) )
d477 3
@


2.38
log
@Added Copyright statement
@
text
@d15 2
a16 1
    & S_L1BRAD, S_L1BOA
d55 1
a55 1
       "$Id: global_settings.f90,v 2.37 2001/05/30 23:56:23 livesey Exp $"
d190 3
d481 3
@


2.37
log
@Changed for new L1BData
@
text
@d1 3
d54 1
a54 1
       "$Id: global_settings.f90,v 2.36 2001/05/30 23:04:40 pwagner Exp $"
d477 3
@


2.36
log
@Gets returnStatus from forwardModelGlobalSetup
@
text
@d51 1
a51 1
       "$Id: global_settings.f90,v 2.35 2001/05/29 23:21:07 livesey Exp $"
d241 1
a241 1
      call DeallocateL1BData ( l1bField, l1bFlag )
d474 3
@


2.35
log
@Now uses ForwardModelSupport, not ForwardModelInterface
@
text
@d51 1
a51 1
       "$Id: global_settings.f90,v 2.34 2001/05/26 00:06:49 livesey Exp $"
d81 1
d184 2
a185 1
          call forwardModelGlobalSetup ( son )
d474 3
@


2.34
log
@Added call to DealloteL1BData
@
text
@d6 1
a6 1
  use ForwardModelInterface, only: ConstructForwardModelConfig, &
d51 1
a51 1
       "$Id: global_settings.f90,v 2.33 2001/05/24 20:54:15 pwagner Exp $"
d472 3
@


2.33
log
@Deleted p_ccs..times
@
text
@d13 2
a14 1
  use L1BData, only: l1bradSetup, l1boaSetup, ReadL1BData, L1BData_T, NAME_LEN
d51 1
a51 1
       "$Id: global_settings.f90,v 2.32 2001/05/24 20:36:13 pwagner Exp $"
d239 1
d472 3
@


2.32
log
@Warns if glob. stg. overrides pcf
@
text
@d11 1
a11 1
    & P_CYCLE, P_CCSDSSTARTTIME, P_CCSDSENDTIME, P_STARTTIME, P_ENDTIME, &
d50 1
a50 1
       "$Id: global_settings.f90,v 2.31 2001/05/17 00:29:03 pwagner Exp $"
a90 5
! Just until init_tables_module is updated
!   integer, parameter :: P_CYCLE=-99, P_CCSDSSTARTTIME=-98, &
!   & P_CCSDSENDTIME=-97, &
!   & P_STARTTIME=-96, P_ENDTIME=-95, &
!    & S_L1BRAD=-94, S_L1BOA=-93
d470 3
@


2.31
log
@Works without toolkit, PCF at last
@
text
@d50 1
a50 1
       "$Id: global_settings.f90,v 2.30 2001/05/15 23:46:32 pwagner Exp $"
d113 4
d120 4
d128 4
d145 4
d164 4
d197 4
d203 4
d228 2
a229 1
       call announce_error(son, 'L1BOA required but not set')
d393 1
a393 1
    & Error_number )
d401 1
d404 1
a404 1
    logical :: Just_print_it
d409 5
d416 1
d435 3
d440 1
d442 3
d446 2
d451 2
d455 2
d459 3
d463 1
d475 3
@


2.30
log
@Now optionally uses hhmmss_value
@
text
@a7 2
  use HGrid, only: AddHGridToDatabase, CreateHGridFromMLSCFInfo, &
    & DestroyHGridDatabase, HGrid_T
d13 1
a13 1
  use L1BData, only: l1bradSetup, l1boaSetup, ReadL1BData, L1BData_T
d17 1
d50 1
a50 1
       "$Id: global_settings.f90,v 2.29 2001/05/14 23:45:08 pwagner Exp $"
d89 1
d194 10
a203 2
   if(got(1) .or. got(2)) then
    call ReadL1BData ( l1bInfo%l1boaID, "MAFStartTimeTAI", l1bField, noMAFs, &
d212 1
a212 1
           maxTime = l1bField%dpField(1,1,noMAFs)
d217 2
d223 2
d333 3
d422 3
@


2.29
log
@Start, end times now added to MAF offsets from L1BOA
@
text
@a18 1
  use MLSL2Options, only: ECHO_GLOBAL_STNGS
d21 1
a21 1
  use MLSStrings, only: unquote
d51 1
a51 1
       "$Id: global_settings.f90,v 2.28 2001/05/11 23:44:43 pwagner Exp $"
d126 5
a130 1
          call expr ( subtree(2,son), units, value )
d132 1
a132 1
 !        call get_string ( sub_rosa_index, name_string, strip=.true. )
d141 5
a145 1
          call expr ( subtree(2,son), units, value )
d147 1
a178 6
          call ReadL1BData ( l1bInfo%l1boaID, "MAFStartTimeTAI", l1bField, noMAFs, &
          & l1bFlag)
          if ( l1bFlag==-1) call announce_error(son, &
          & 'unrecognized MAFStarttimeTAI in L1BOA file')
           minTime = l1bField%dpField(1,1,1)
           maxTime = l1bField%dpField(1,1,noMAFs)
d194 13
d215 1
a215 1
   if( ECHO_GLOBAL_STNGS .or. levels(gen) > 0 .or. &
d407 3
@


2.28
log
@Better dump; uses strip=TRUE
@
text
@d3 1
d15 1
a15 1
  use L1BData, only: l1bradSetup, l1boaSetup
d52 1
a52 1
       "$Id: global_settings.f90,v 2.27 2001/05/11 01:56:17 vsnyder Exp $"
d72 1
d75 1
d77 3
d81 1
d86 4
d121 4
a124 4
        case ( p_ccsdsstarttime )
          call get_string ( sub_rosa_index, l2pcf%startutc, strip=.true. )
        case ( p_ccsdsendtime )
          call get_string ( sub_rosa_index, l2pcf%endutc, strip=.true. )
d126 4
a129 1
          call get_string ( sub_rosa_index, name_string, strip=.true. )
d134 2
a135 2
          read(name_string, time_conversion) &
          &           processingrange%starttime
d137 4
a140 1
          call get_string ( sub_rosa_index, name_string, strip=.true. )
d145 2
a146 2
          read(name_string, time_conversion) &
          &           processingrange%endtime
d171 6
d191 9
d392 3
@


2.27
log
@Move the getting of sub_rosa_index
@
text
@d51 1
a51 1
       "$Id: global_settings.f90,v 2.26 2001/05/11 00:09:05 pwagner Exp $"
d102 1
a102 1
          call get_string ( input_version_string, l2pcf%inputVersion )
d105 1
a105 1
          call get_string ( output_version_string, l2pcf%PGEVersion )
d109 1
a109 1
          call get_string ( sub_rosa_index, l2pcf%cycle )
d111 1
a111 1
          call get_string ( sub_rosa_index, l2pcf%startutc )
d113 1
a113 1
          call get_string ( sub_rosa_index, l2pcf%endutc )
d115 5
a119 5
          call get_string ( sub_rosa_index, name_string )
          print *, 'starttime'
          print *, trim(name_string)
          print *, trim(unquote(name_string))
          name_string = unquote(name_string)
d123 5
a127 5
          call get_string ( sub_rosa_index, name_string )
          print *, 'endtime'
          print *, trim(name_string)
          print *, trim(unquote(name_string))
          name_string = unquote(name_string)
d168 2
a169 1
   if( ECHO_GLOBAL_STNGS ) &
d360 3
@


2.26
log
@Gets p_.. from init_tables; unquotes strings
@
text
@d51 1
a51 1
       "$Id: global_settings.f90,v 2.25 2001/05/10 18:26:22 pwagner Exp $"
a94 1
      sub_rosa_index = sub_rosa(subtree(2,son))
d96 1
d359 3
@


2.25
log
@Improved dump_global_settings
@
text
@d11 3
a13 3
    & S_FORWARDMODEL, S_ForwardModelGlobal, S_TIME, S_VGRID, F_FILE!, &
!    & P_CYCLE, P_CCSDSSTARTTIME, P_CCSDSENDTIME, P_STARTTIME, P_ENDTIME, &
!    & S_L1BRAD, S_L1BOA
d16 1
d21 1
d27 2
a28 1
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, SUB_ROSA, SUBTREE
d51 1
a51 1
       "$Id: global_settings.f90,v 2.24 2001/05/09 23:35:04 pwagner Exp $"
d57 2
d76 1
d80 1
d82 4
a85 4
   integer, parameter :: P_CYCLE=-99, P_CCSDSSTARTTIME=-98, &
   & P_CCSDSENDTIME=-97, &
   & P_STARTTIME=-96, P_ENDTIME=-95, &
    & S_L1BRAD=-94, S_L1BOA=-93
d89 2
d95 1
d101 1
a101 1
          input_version_string = sub_rosa(subtree(2,son))
d104 1
a104 1
          output_version_string = sub_rosa(subtree(2,son))
d107 1
a107 1
          version_comment = sub_rosa(subtree(2,son))
d109 1
a109 1
          call get_string ( sub_rosa(subtree(2,son)), l2pcf%cycle )
d111 1
a111 1
          call get_string ( sub_rosa(subtree(2,son)), l2pcf%startutc )
d113 1
a113 1
          call get_string ( sub_rosa(subtree(2,son)), l2pcf%endutc )
d115 7
a121 2
          call get_string ( sub_rosa(subtree(2,son)), name_string )
          read(name_string, '(A32)') processingrange%starttime
d123 9
a131 2
          call get_string ( sub_rosa(subtree(2,son)), name_string )
          read(name_string, '(A32)') processingrange%endtime
d162 2
d171 4
d299 57
d359 3
@


2.24
log
@Added dump_global_settings
@
text
@d48 1
a48 1
       "$Id: global_settings.f90,v 2.23 2001/05/04 17:15:36 pwagner Exp $"
d92 1
d95 1
d190 1
d195 3
a202 2
!        returnStatus = Pgs_pc_getReference(l1bInfo%L1BRADIDs(i), version, &
!        & physicalFilename)
d220 1
d223 1
a223 3
!    returnStatus = Pgs_pc_getReference(l1bInfo%L1BOAID, version, &
!      & physicalFilename)
!    if ( returnStatus == PGS_S_SUCCESS ) then
d228 3
a230 3
!    else
!      call output ( '(file unknown)', advance='yes' )
!    end if
d232 1
d236 1
a236 1
    call output ( 'End Time:   ' )
d240 1
a240 1
    call output ( processingrange%starttime, advance='yes' )
d242 2
a243 2
    call output ( 'End Time:   ' )
    call output ( processingrange%endtime, advance='yes' )
d263 6
d274 3
@


2.23
log
@Many added settings, esp. L1B files, so level2 can run w/o PCF
@
text
@d16 2
a17 1
  use MLSCommon, only: R8, NameLen, L1BInfo_T, TAI93_Range_T
d48 1
a48 1
       "$Id: global_settings.f90,v 2.22 2001/04/26 20:02:09 livesey Exp $"
d142 3
d164 97
d264 3
@


2.22
log
@Made l2pc database a saved array in L2PC_m
@
text
@d11 4
a14 1
    & S_FORWARDMODEL, S_ForwardModelGlobal, S_TIME, S_VGRID
d16 1
a16 1
  use MLSCommon, only: R8
d18 1
d25 1
d28 1
a28 1
  use TREE_TYPES, only: N_EQUAL, N_NAMED
d36 4
d47 1
a47 1
       "$Id: global_settings.f90,v 2.21 2001/04/26 02:52:17 vsnyder Exp $"
d56 1
a56 1
    & VGrids, l2gpDatabase )
d63 3
d72 6
d95 12
d124 6
d163 3
@


2.21
log
@Fix up CVS stuff
@
text
@a12 1
  use L2PC_m,only: L2PC_T
d38 1
a38 1
       "$Id: $"
d41 1
a41 1
       "$RCSfile: $"
d47 1
a47 1
    & VGrids, l2gpDatabase, l2pcDatabase )
a53 1
    type ( l2pc_T), dimension(:), pointer :: L2PCDATABASE
d87 1
a87 1
          call forwardModelGlobalSetup ( son, l2pcDatabase )
d127 3
@


2.20
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d37 7
a43 6
!---------------------------- RCS Ident Info ---------------------------
  character (len=256) :: Id = &
       "$Id: global_settings.f90,v 2.19 2001/04/26 00:07:33 livesey Exp $"
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: global_settings.f90,v $"
!-----------------------------------------------------------------------
d129 3
@


2.19
log
@Stuff to support reading of l2pc files
@
text
@d22 2
a23 2
  use VGrid, only: CreateVGridFromMLSCFInfo, Dump
  use VGridsDatabase, only: AddVGridToDatabase, VGrid_T
d39 1
a39 1
       "$Id: global_settings.f90,v 2.18 2001/04/24 00:31:42 vsnyder Exp $"
d128 3
@


2.18
log
@Finish adding 'time' command
@
text
@d13 1
d39 1
a39 1
       "$Id: global_settings.f90,v 2.17 2001/04/23 23:48:41 vsnyder Exp $"
d47 1
a47 1
    & VGrids, l2gpDatabase )
d54 1
d88 1
a88 1
          call forwardModelGlobalSetup ( son )
d128 3
@


2.17
log
@Finish adding 'time' command
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.16 2001/04/23 23:42:00 vsnyder Exp $"
d60 2
d126 3
@


2.16
log
@Add 'time' command
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.15 2001/04/21 01:25:54 livesey Exp $"
d114 1
a114 1
      call output ( "Timing for MLSSignals = " )
d124 3
@


2.15
log
@Now passes l2gpdatabase to more people who need it.
@
text
@d3 4
d11 2
a12 1
    & S_FORWARDMODEL, S_VGRID
d14 1
d16 2
a24 9
  use ForwardModelConfig, only: AddForwardModelConfigToDatabase, &
    & ForwardModelConfig_T
  use ForwardModelInterface, only: ConstructForwardModelConfig, &
    & ForwardModelGlobalSetup
  use INIT_TABLES_MODULE, only: S_ForwardModelGlobal
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate
  use String_Table, only: Get_String
  use L2GPData, only: L2GPDATA_T

d38 1
a38 1
       "$Id: global_settings.f90,v 2.14 2001/04/10 23:44:44 vsnyder Exp $"
d57 2
d91 7
d107 11
d124 3
@


2.14
log
@Improve 'dump'
@
text
@d24 1
d39 1
a39 1
       "$Id: global_settings.f90,v 2.13 2001/04/10 02:46:17 livesey Exp $"
d47 1
a47 1
    & VGrids )
d53 1
d89 1
a89 1
            & CreateVGridFromMLSCFInfo ( name, son ) ) )
d105 3
@


2.13
log
@Working version, no more FMI/TFMI
@
text
@d38 1
a38 1
       "$Id: global_settings.f90,v 2.12 2001/04/07 01:50:49 vsnyder Exp $"
d94 1
a94 1
        & call dump ( vgrids )
d103 3
@


2.12
log
@Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
some related stuff to fwdmdl/ForwardModelConfig.
@
text
@a16 1
!??? Begin temporary stuff to start up the forward model
d21 1
a21 4
  use INIT_TABLES_MODULE, only: F_ZVI, S_ForwardModelGlobal, S_L2LOAD
  use L2_Load_M, only: L2_Load
  use L2_test_structures_m, only: FWD_MDL_CONFIG, FWD_MDL_INFO, &
    & TEMPORARY_FWD_MDL_INFO
a23 1
!??? End of temporary stuff to start up the forward model
d38 1
a38 1
       "$Id: global_settings.f90,v 2.11 2001/03/28 22:00:33 livesey Exp $"
d46 1
a46 2
!   & VGrids ) !??? Restore when l2load isn't needed
    & VGrids, FMC, FMI, TFMI ) !??? Remove when l2load isn't needed
d52 1
a52 12

!??? Begin temporary stuff to start up the forward model
  type(fwd_mdl_config) :: FMC
  type(fwd_mdl_info), dimension(:), pointer :: FMI
  type(temporary_fwd_mdl_info), dimension(:), pointer :: TFMI

  integer :: IER
!??? End of temporary stuff to start up the forward model

    integer :: GSON                !??? Temporary for l2load
    character(len=255) :: LINE     !??? Temporary for l2load

a84 10
        case ( s_l2load ) !??? More temporary stuff for l2load
          ! The only allowed field is the required ZVI field
          gson = subtree(2,son)
          call get_string ( sub_rosa(subtree(2,gson)), line ) ! ZVI file
          fmc%z = line(2:len_trim(line)-1)
          call l2_load ( fmc, ier=ier )
          allocate(tfmi(1),fmi(1))
          call l2_load(fmc, fmi(1), tfmi(1), ier)

          !??? End temporary stuff for l2load
d103 4
@


2.11
log
@Interim version, now handles vGrids as part of forwardModelConfig
@
text
@d13 2
a14 1
  use VGrid, only: AddVGridToDatabase, CreateVGridFromMLSCFInfo, Dump, VGrid_T
d18 4
a21 2
  use ForwardModelInterface, only: AddForwardModelConfigToDatabase, &
    ConstructForwardModelConfig, ForwardModelGlobalSetup, ForwardModelConfig_T
d43 1
a43 1
       "$Id: global_settings.f90,v 2.10 2001/03/28 01:24:55 vsnyder Exp $"
d130 3
@


2.10
log
@Move vGrid from construct section to global settings section
@
text
@d40 1
a40 1
       "$Id: global_settings.f90,v 2.9 2001/03/17 03:24:23 vsnyder Exp $"
d49 1
a49 1
    & VGrids, FMC ) !??? Remove when l2load isn't needed
d58 3
d98 1
a98 1
            & forwardModelConfigDatabase, ConstructForwardModelConfig ( son ) ) )
d105 3
d127 3
@


2.9
log
@Work on forwardModelGlobalSetup
@
text
@d3 2
d7 1
a7 1
    & S_FORWARDMODEL
d9 2
a10 1
  use TOGGLES, only: GEN, TOGGLE
d12 3
a14 1
  use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
a23 1
  use MoreTree, only: GET_FIELD_ID, GET_SPEC_ID
a24 2
  use TREE, only: NODE_ID, DECORATE
  use TREE_TYPES, only: N_EQUAL, N_NAMED
d40 1
a40 1
       "$Id: global_settings.f90,v 2.8 2001/03/17 00:57:36 livesey Exp $"
d47 4
a50 2
! subroutine SET_GLOBAL_SETTINGS ( ROOT, ForwardModelConfigDatabase ) !??? Restore when l2load isn't needed
  subroutine SET_GLOBAL_SETTINGS ( ROOT, ForwardModelConfigDatabase, FMC )
d52 3
a54 2
    type(ForwardModelConfig_T), dimension(:), pointer :: FORWARDMODELCONFIGDATABASE

d65 1
d84 6
a89 1
        if ( node_id(son) == n_named ) son = subtree(2,son)
d103 3
d110 5
a114 1
    if ( toggle(gen) ) call trace_end ( 'SET_GLOBAL_SETTINGS' )
d121 3
@


2.8
log
@Removed dump.
@
text
@d14 1
a14 1
  use INIT_TABLES_MODULE, only: F_BILL, F_ZVI, S_ForwardModelGlobal, S_L2LOAD
d38 1
a38 1
       "$Id: global_settings.f90,v 2.7 2001/03/17 00:45:38 livesey Exp $"
d46 1
a46 1
  subroutine SET_GLOBAL_SETTINGS ( ROOT, ForwardModelConfigDatabase, FMC, FMI, TFMI )
a52 2
  type(fwd_mdl_info), dimension(:), pointer :: FMI
  type(temporary_fwd_mdl_info), dimension(:), pointer :: TFMI
a56 1
    integer :: J, K                !??? Temporary for l2load
a60 1
    integer :: N                        ! Size of forwardModelConfigDatabase
d81 1
a81 1
          ! Nothing here yet
d86 5
a90 27
          do j = 2, nsons(son)
            gson = subtree(j,son)
            if ( get_field_id(gson) == f_zvi ) then
              call get_string ( sub_rosa(subtree(2,gson)), line ) ! ZVI file
              fmc%z = line(2:len_trim(line)-1)
              call l2_load ( fmc, ier=ier )
          exit
            end if
          end do
          do j = 2, nsons(son)
            gson = subtree(j,son)
            if ( get_field_id(gson) == f_bill ) then
              if ( associated(fmi) ) deallocate ( fmi, stat=ier )
              if ( associated(tfmi) ) deallocate ( tfmi, stat=ier )
              allocate ( fmi(nsons(son)-1), stat=ier )
              if ( ier /= 0 ) call MLSMessage ( MLSmsg_Error, moduleName, &
                & MLSmsg_allocate // "fmi" )
              allocate ( tfmi(nsons(son)-1), stat=ier )
              if ( ier /= 0 ) call MLSMessage ( MLSmsg_Error, moduleName, &
                & MLSmsg_allocate // "tfmi" )
              do k = 2, nsons(gson)
                call get_string ( sub_rosa(subtree(k,gson)), line ) ! Bill file
                fmc%b = line(2:len_trim(line)-1)
                call l2_load ( fmc, fmi(k-1), tfmi(k-1), ier=ier )
              end do
            end if
          end do
d103 3
@


2.7
log
@Added ForwardModelConfigDatabase
@
text
@a22 1
  use ForwardModelInterface, only: dump
d38 1
a38 1
       "$Id: global_settings.f90,v 2.6 2001/03/09 02:30:13 vsnyder Exp $"
a123 2
    call dump(forwardModelConfigDatabase)

d129 3
@


2.6
log
@Allocate correct size for FMI and TFMI
@
text
@d4 2
a5 1
    & P_INPUT_VERSION_STRING, P_OUTPUT_VERSION_STRING, P_VERSION_COMMENT
d12 2
a13 1
  use ForwardModelInterface, only: ForwardModelGlobalSetup, ForwardModelInfo_T
d21 1
a21 1
  use TREE, only: NODE_ID
d23 1
d39 1
a39 1
       "$Id: global_settings.f90,v 2.5 2001/03/09 00:24:30 vsnyder Exp $"
d46 2
a47 2
! subroutine SET_GLOBAL_SETTINGS ( ROOT, FwdModelInfo ) !??? Restore when l2load isn't needed
  subroutine SET_GLOBAL_SETTINGS ( ROOT, FwdModelInfo, FMC, FMI, TFMI )
d49 2
a50 1
    type(forwardModelInfo_T), intent(inout) :: FwdModelInfo ! From ForwardModelSetup
d65 1
a68 2
    fwdModelInfo = forwardModelInfo_T(.false., .false., .false., 0.0_r8, &
      & .false., .false.)
d86 4
a89 7
          call forwardModelGlobalSetup ( son, fwdModelInfo )
          fmc%atmos_der = fwdModelInfo%atmos_der
          fmc%do_conv = fwdModelInfo%do_conv
          fmc%do_frqavg = fwdModelInfo%do_Freq_Avg
          fmc%spect_Der = fwdModelInfo%spect_Der
          fmc%temp_Der = fwdModelInfo%temp_Der
          fmc%zfrq = fwdModelInfo%the_Freq
d125 2
d132 3
@


2.5
log
@Do subscripts right
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.4 2001/03/08 03:23:09 vsnyder Exp $"
d105 1
a105 1
              allocate ( fmi(nsons(son)), stat=ier )
d108 1
a108 1
              allocate ( tfmi(nsons(son)), stat=ier )
d130 3
@


2.4
log
@More stuff to work with L2_Load
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.3 2001/03/07 22:46:05 vsnyder Exp $"
d114 1
a114 1
                call l2_load ( fmc, fmi(k), tfmi(k), ier=ier )
d130 3
@


2.3
log
@Add temporary stuff for Zvi's "l2_load", which will wither away.
@
text
@d36 1
a36 1
       "$Id: global_settings.f90,v 2.2 2000/11/16 01:53:40 vsnyder Exp $"
d43 2
a44 2
! subroutine SET_GLOBAL_SETTINGS ( ROOT ) !??? Restore when l2load isn't needed
  subroutine SET_GLOBAL_SETTINGS ( ROOT, FMC, FMI, TFMI )
d46 1
a48 1
  type(forwardModelInfo_T) :: FwdMdlInfo
d64 1
a64 1
    fwdMdlInfo = forwardModelInfo_T(.false., .false., .false., 0.0_r8, &
d83 7
a89 7
          call forwardModelGlobalSetup ( son, fwdMdlInfo )
          fmc%atmos_der = fwdMdlInfo%atmos_der
          fmc%do_conv = fwdMdlInfo%do_conv
          fmc%do_frqavg = fwdMdlInfo%do_Freq_Avg
          fmc%spect_Der = fwdMdlInfo%spect_Der
          fmc%temp_Der = fwdMdlInfo%temp_Der
          fmc%zfrq = fwdMdlInfo%the_Freq
d130 3
@


2.2
log
@Take timing back out.  Don't do it in sections that are only parameter settings.
@
text
@d4 2
a5 2
    & P_INPUT_VERSION_STRING, P_OUTPUT_VERSION_STRING, P_VERSION_COMMENT, &
    & S_TIME
d10 15
d36 1
a36 1
       "$Id: global_settings.f90,v 2.1 2000/11/16 01:45:25 vsnyder Exp $"
d43 2
a44 1
  subroutine SET_GLOBAL_SETTINGS ( ROOT )
d47 12
d64 2
d68 53
a120 10
      select case ( decoration(subtree(1,son)) )
      case ( p_allow_climatology_overloads )
        allow_climatology_overloads = decoration(subtree(2,son)) == l_true
      case ( p_input_version_string )
        input_version_string = sub_rosa(subtree(2,son))
      case ( p_output_version_string )
        output_version_string = sub_rosa(subtree(2,son))
      case ( p_version_comment )
        version_comment = sub_rosa(subtree(2,son))
      end select
d123 1
a123 1
  if ( toggle(gen) ) call trace_end ( 'SET_GLOBAL_SETTINGS' )
d130 3
@


2.1
log
@Implement timing.
@
text
@a5 1
  use OUTPUT_M, only: OUTPUT
d21 1
a21 1
       "$Id: global_settings.f90,v 2.0 2000/09/05 18:57:05 ahanzel Exp $"
a32 2
    double precision :: T1, T2     ! for timing
    logical :: TIMING
a35 1
    timing = .false.     ! timing isn't on.
a46 10
      case ( s_time )
        if ( timing ) then
          call cpu_time ( t2 )
          call output ( "Timing for Set_Global_Settings = " )
          call output ( t2-t1, advance = 'yes' )
          timing = .false.
        else
          call cpu_time ( t1 )
          timing = .true.
        end if
a48 5
    if ( timing ) then
      call cpu_time ( t2 )
      call output ( "Timing for Set_Global_Settings = " )
      call output ( t2-t1, advance = 'yes' )
    end if
d57 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@d4 3
a6 1
    & P_INPUT_VERSION_STRING, P_OUTPUT_VERSION_STRING, P_VERSION_COMMENT
d22 1
a22 1
       "$Id: global_settings.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
d34 2
d39 1
d51 10
d63 5
d76 3
@


1.1
log
@Initial entry
@
text
@d20 1
a20 1
       "$Id: global_settings.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
d56 3
@


