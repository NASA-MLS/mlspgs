head	2.18;
access;
symbols
	v5-02-NRT-19:2.18
	v6-00:2.18
	v5-02-NRT-18:2.18
	v5-01-NRT-17:2.18
	v5-01-NRT-16:2.18
	v5-01-NRT-15:2.15
	v5-01-NRT-14:2.14;
locks; strict;
comment	@# @;


2.18
date	2022.05.19.17.28.35;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2022.04.28.20.46.32;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2022.04.13.21.33.03;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2021.10.14.22.25.25;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2021.07.28.23.43.12;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2021.07.22.23.18.26;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2021.07.08.23.33.03;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2021.06.24.23.31.17;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2021.06.18.15.18.25;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2021.06.10.23.49.11;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2021.05.27.23.52.30;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2021.05.18.15.53.56;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2021.04.01.23.52.57;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2021.03.18.23.48.18;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2021.03.05.00.55.30;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2021.02.19.00.28.08;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2021.02.05.05.16.37;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2021.01.22.00.22.18;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.18
log
@Fixed bug preventing non-deebug setting Activation_Function
@
text
@! Copyright 2021, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module NeuralNet_m              ! Use Neural Net Model to Retrieve State
!=============================================================================

  use Chunks_m, only: Dump
  use Global_Settings, only: L1MAFToL2Profile, L2ProfileToL1MAF
  use HGridsDatabase, only: L1BGeolocation
  use HighOutput, only: BeVerbose, Dump, LetsDebug, OutputNamedValue
  use Hunt_M, only: Hunt
  use MLSCommon, only: MLSChunk_T, MLSFile_T, UndefinedValue
  use MLSFiles, only: MLS_CloseFile, MLS_OpenFile, MLS_SFEnd, MLS_SFStart, &
    & AddInitializeMLSFile, Dump, HDFVersion_5
  use MLSFinds, only: FindFirst, FindLast
  use MLSKinds, only: R4, R8, Rv, Rk => R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use MLSSignals_M, only: GetSignalName
  use MLSStats1, only: MLSMax, MLSMin
  use MLSStrings, only: Capitalize, ReplaceNonAscii
  use MoreTree, only: Get_Field_Id
  use NeuralNetUtils_m, only: NeuralNetCoeffs_T, &
    & NeuralNetInputData_T, NeuralNetInputData_2_T, &
    & MatchedBinNum, MatchedMAF, MatchedStdRadiances, &
    & CheckMAFs, CheckTemperatures, Dump, NeuralNetFit, StandardizeRadiances
  use Output_M, only: Output
  use QuantityTemplates, only: Dump
  use String_Table, only: Get_String
  use Toggles, only: Gen, Levels, Switches, Toggle
  use Trace_M, only: Trace_Begin, Trace_End
  use Tree, only: Decoration, Sub_Rosa, Subtree, Nsons, Subtree
  use VectorsModule, only: &
    & Dump, &
    & Vector_T, &
    & VectorValue_T
  ! ----------------------------------------------------------------------------
  ! This module performs the NeuralNet operation in the Level 2 software.
  ! This takes a measurement vector, 
  ! then returns a state vector with values calculated
  ! using a file of weight coefficients.
  !
  ! Note that it currently supports only the retrieval of Temperature
  ! Also it assumes Bands 1, 8, and 22 are supplied
  ! The current weights file format is hard-coded here. 
  ! It would require changes and testing if that format should ever change.
  ! We also assume the weights are stored in a manner consistent
  ! with the following order for the "collapsed" measurement vector:
  !   [b1c1m1,b1c2m1,..,b1c1m2,b1c2m2,..,b2c1m1,..,..,b22c1m1,..]
  ! where
  !   bk is Band k
  !   cj is channel j
  !   mi is MIF i
  !
  ! Another wrinkle is the infamous decision that MAFs start at 0 rather than 1
  ! ----------------------------------------------------------------------------

  implicit none
  private
  public :: NeuralNet

! === (start of toc) ===
! NeuralNet          Given a measurement vector and a file of coefficients
!                      calculate the resulting state vector
! === (end of toc) ===

! === (start of api) ===
! NeuralNet ( int key, 
!        *Vector_t VectorsDatabase(:),
!        *MLSChunk_T Chunk, 
!        *MLSFile_T FileDatabase(:) )
! === (end of api) ===
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= "$RCSfile: NeuralNet_m.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

  ! The following must someday also be read from the file of weight coefficients
  !  integer, parameter              :: NumHiddenLayers  = 2
  ! The type of activation function is now read from the weights file
  ! (and anyway, it could be and in fact ultimately is 'relu'
  ! character(len=*), parameter     :: switchOver       = 'tanh' ! or 'sigmoid'
  ! Instead of plopping these constants into parameter declarations
  ! we'll either
  ! (1) Read them from the coefficients file; or
  ! (2) Make them fields of the l2cf's NeuralNet specification
  integer, parameter              :: NumChnnelsBand1  = 25
  integer, parameter              :: NumChnnelsBand8  = 25
  integer, parameter              :: NumChnnelsBand22 = 51
  integer, parameter              :: NumMIFs          = 75
  integer, parameter              :: NumLevels        = 42
  
  Logical, parameter              :: StandardizeRadiancesHere = .true.
  Logical, parameter              :: CheckTempsAndRads        = .false.
  Logical, parameter              :: UseMatchedRadiances      = .false.
  Logical, parameter              :: UseMatchedTemps          = .false.

contains ! =====     Public Procedures     =============================

  !---------------------------------------------------  NeuralNet  -----


  subroutine NeuralNet ( Key, VectorsDatabase, Chunk, FileDatabase )
    use Init_Tables_Module, only: L_H2O, L_HDF, L_Temperature, L_Radiance
    use Init_Tables_Module, only: F_State, F_Measurements, F_File, F_OutputSD
    integer, intent(in)                        :: Key
    type(vector_T), dimension(:), target       :: VectorsDatabase
    type (MLSChunk_T), intent(in)              :: Chunk
    type (MLSFile_T), dimension(:), pointer    :: FileDatabase
    integer                   :: Me = -1 ! String index for trace

    ! Local variables
    logical, dimension(23) :: NeededBands
    integer :: BinNum                 ! Loop counter
    logical :: DeeBug
    integer :: FIELD                  ! Entry in tree
    integer :: File
    integer :: FirstBin
    integer :: FirstProfile
    integer :: GSON                    ! Tree node
    ! These set how we match MAF numbers to the profile
    ! 3  methods are possible: Hunt, minloc, and FindFirst
    integer, parameter :: MMinLoc    = 1
    integer, parameter :: MHunt      = 2
    integer, parameter :: MFindFirst = 3
    integer, parameter :: howMatched = MMinLoc
    integer :: I                      ! Loop counter
    integer :: J                      ! Tree index
    integer :: LastBin
    integer :: LastProfile
    real(r4):: Lat
    integer :: MAF
    real(r4):: MaxLat
    real(r4):: MinLat
    integer :: MyFile                 ! FileDatabase index
    integer :: NumHiddenLayers        ! = 2
    integer :: NumMAFs                ! In this chunk
    real(r4):: Phi
    integer :: Profile
    integer :: RadfileID
    integer :: SON                    ! Tree node
    integer :: SIGNAL                 ! the signal we're looking for
    character(len=32) :: SignalStr    ! its string value
    integer :: Status
    real(Rv), allocatable, dimension(:) :: FranksValues
    real(Rv), allocatable, dimension(:) :: PrecisionValues
    real(Rv), allocatable, dimension(:) :: Values
    integer :: TempfileID
    integer, dimension(3) :: theseMAFs
    integer :: thisMAF
    integer :: thisProfile
    logical :: verbose

    type (Vector_T), pointer        :: Measurements ! The measurement vector
    type (Vector_T), pointer        :: State ! The state vector to fill
    type (Vector_T), pointer        :: OutputSD ! The Precision vector to fill

    type (MLSFile_T), pointer       :: CoeffsFile
    type (MLSFile_T), pointer       :: RadiancesFile
    type (VectorValue_T), pointer   :: Radiances ! The radiances for this band
    character(len=16)               :: RetrievedQty ! 'Temperature' or 'H2O'
    type (VectorValue_T), pointer   :: H2O ! The quantity to fill
    type (VectorValue_T), pointer   :: H2OPrecision ! Another quantity to fill
    type (VectorValue_T), pointer   :: Temperature ! The quantity to fill
    type (VectorValue_T), pointer   :: TemperaturePrecision ! Another quantity to fill
    type (VectorValue_T), pointer   :: Qty ! The quantity to fill
    type (VectorValue_T), pointer   :: Precision ! Another quantity to fill
    
    type(NeuralNetCoeffs_T)         :: Coeffs
    type(NeuralNetInputData_T)      :: NNMeasurements
    type(NeuralNetInputData_2_T)    :: NNMeasurements_2
    character (len=1024)            :: FileName
    real(rk), dimension(:,:), pointer :: GeodAngle
    real(rk), dimension(:,:), pointer :: GeodLat
    ! The next file holds the coefficients
    ! although we should try to supply the filename in the l2cf/PCF
    character (len=*), parameter    :: DefaultFileName = &
      & '/users/fwerner/Documents/database/trained_neural_nets/temperature/v1.14/1/' &
      & // &
      & 'Temperature_trained_neural_net.h5' ! For coefficients
    character (len=*), parameter    :: DefaultRadiances = &
      & 'Radiances_used_in_nn.h5' ! For radiances
    character (len=*), parameter    :: DefaultTemperatures = &
      & 'Temperature_20190101.h5' ! For results to compare with
    ! Beware if the following ever change
    ! For we will then need to read them from the file of coefficients
    ! For now we have 18 bins, each of size 10, spanning latitudes from the
    ! South Pole to the North
    integer, parameter              :: NumBins = 18
    real(r4), dimension(NumBins), parameter :: BinArray = &
      & (/ -90., -80., -70., -60., -50., -40., -30., -20., -10., &
      &      0.,  10.,  20.,  30.,  40.,  50.,  60.,  70.,  80. /)
    real(r4), parameter             :: BinSz = 10.
        
    ! Executable code
    DEEBUG = LetsDebug ( 'neu', 0 )
    verbose = BeVerbose ( 'neu', 0 )
    call trace_begin ( me, 'NeuralNet_m.NeuralNet', key, &
      & cond=toggle(gen) .and. levels(gen) > 1 )
    NeededBands = .false.
    nullify ( GeodAngle, GeodLat )

    do i = 2, nsons(key)
      son = subtree(i,key)
      gson = subtree(i,key) ! The argument
      if ( nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
      field = get_field_id(son)
      select case ( field )
      case ( f_measurements )
        measurements => VectorsDatabase(decoration(decoration(subtree(2,son))))
      case ( f_state )
        state => VectorsDatabase(decoration(decoration(subtree(2,son))))
      case ( f_outputSD )
        outputSD => VectorsDatabase(decoration(decoration(subtree(2,son))))
      case ( f_file )
        file = sub_rosa(gson)
        call outputNamedValue ( 'Processing file field', file )
      end select
    end do ! i = 2, nsons(key)

    if ( file > 0 ) then
      call get_string ( file, filename, strip=.true. )
      if ( verbose ) print *, 'filename read: ', trim(filename)
      myFile =  FileNameToID( trim(filename), FileDataBase ) 
    else
      myFile = 0
      if ( verbose ) print *, 'No filename read'
    end if
    if ( myFile < 1 ) then
      filename = defaultFileName
      if ( verbose ) print *, 'Must use default filename: ', trim(defaultFileName)
    endif
    if ( DeeBug ) then
      call outputNamedValue ( 'filename', trim(filename) )
    endif
    ! Loop over the quantities in the vectors

    if ( DeeBug ) then
      call outputNamedValue ( 'num quantities in state', state%template%noQuantities )
    endif
    do i = 1, state%template%noQuantities
      if ( state%quantities(i)%template%quantityType == l_temperature ) then
        TemperaturePrecision => OutputSD%quantities(i)
        Temperature => state%quantities(i)
        Temperature%values = 0.0_rv
        RetrievedQty = 'Temperature'
        NumHiddenLayers = 2
        if ( .not. associated(Temperature%BinNumber) ) &
          & allocate(Temperature%BinNumber(Temperature%template%NoInstances) )
        if ( .not. associated(Temperature%MAF) ) &
          & allocate(Temperature%MAF(Temperature%template%NoInstances) )
        Qty => Temperature
        Precision => TemperaturePrecision
      elseif ( state%quantities(i)%template%quantityType == l_h2o ) then
        H2OPrecision => OutputSD%quantities(i)
        H2O => state%quantities(i)
        H2O%values = 0.0_rv
        RetrievedQty = 'H2O'
        NumHiddenLayers = 4
        if ( .not. associated(H2O%BinNumber) ) &
          & allocate(H2O%BinNumber(H2O%template%NoInstances) )
        if ( .not. associated(H2O%MAF) ) &
          & allocate(H2O%MAF(H2O%template%NoInstances) )
        Qty => H2O
        Precision => H2OPrecision
      else
        if ( verbose ) &
          & print *, 'Skipping non-Temperature, non-H2O state quantity'
        cycle
      end if
    end do                          ! End loop over state quantities

      ! Now go through all the bands in the measurement vector that are in this radiometer
    do j = 1, measurements%template%noQuantities
      if ( measurements%quantities(j)%template%quantityType /= l_radiance ) then
        if ( verbose ) print *, 'measurement quantity type is not a radiance'
        cycle
      endif
!       We discover (to our spine-tingling horror)
!       that not all quantity templates have a radiometer; or bother to store
!       their radiometer index in the appropriate component.
!       if ( measurements%quantities(j)%template%radiometer /= Temperature%template%radiometer ) then
!         print *, 'measurement and Tmperature radiometers do not match '
!         call displayRadiometer ( measurements%quantities(j)%template%radiometer )
!         call displayRadiometer ( Temperature%template%radiometer )
!         cycle
!       endif
      radiances => measurements%quantities(j)
      signal = measurements%quantities(j)%template%signal
      NumMAFs = measurements%quantities(j)%template%NoInstances
      call GetSignalName ( signal, signalStr )
      signalStr = ReplaceNonAscii( signalStr, ' ' )
      select case (Capitalize(signalStr) )
      case ('R1A:118.B1F:PT.S0.FB25-1')
        if ( verbose ) print *, 'Got Band 1'
        NeededBands(1) = .true.
        ! Band 1 radiances are used in retrieving both T and H2O
        if ( RetrievedQty == 'Temperature' ) then
          NNMeasurements%Band_1_Radiances%NumChannels = NumChnnelsBand1
          NNMeasurements%Band_1_Radiances%NumMIFs     = NumMIFs
          allocate( &
            & NNMeasurements%Band_1_Radiances%&
            &   values(NumChnnelsBand1, NumMIFs) )
        else
          NNMeasurements_2%Band_1_Radiances%NumChannels = NumChnnelsBand1
          NNMeasurements_2%Band_1_Radiances%NumMIFs     = NumMIFs
          allocate( &
            & NNMeasurements_2%Band_1_Radiances%&
            &   values(NumChnnelsBand1, NumMIFs) )
        endif
      case ('R2:190.B2F:H2O.S0.FB25-1')
        if ( verbose ) print *, 'Got Band 2'
        NeededBands(2) = .true.
        NNMeasurements_2%Band_2_Radiances%NumChannels = NumChnnelsBand1
        NNMeasurements_2%Band_2_Radiances%NumMIFs     = NumMIFs
        allocate( &
          & NNMeasurements_2%Band_2_Radiances%&
          &   values(NumChnnelsBand1, NumMIFs) )
      case ('R2:190.B3F:N2O.S0.FB25-1')
        if ( verbose ) print *, 'Got Band 3'
        NeededBands(3) = .true.
        NNMeasurements_2%Band_3_Radiances%NumChannels = NumChnnelsBand1
        NNMeasurements_2%Band_3_Radiances%NumMIFs     = NumMIFs
        allocate( &
          & NNMeasurements_2%Band_3_Radiances%&
          &   values(NumChnnelsBand1, NumMIFs) )
      case ('R3:240.B8F:PT.S3.FB25-8')
        if ( verbose ) print *, 'Got Band 8'
        NeededBands(8) = .true.
        NNMeasurements%Band_8_Radiances%NumChannels = NumChnnelsBand8
        NNMeasurements%Band_8_Radiances%NumMIFs     = NumMIFs
        allocate( &
          & NNMeasurements%Band_8_Radiances%&
          &   values(NumChnnelsBand8, NumMIFs) )
      case ('R1A:118.B22D:PT.S0.DACS-4')
        if ( verbose ) print *, 'Got Band 22'
        NeededBands(22) = .true.
        NNMeasurements%Band_22_Radiances%NumChannels = NumChnnelsBand22
        NNMeasurements%Band_22_Radiances%NumMIFs     = NumMIFs
        allocate( &
          & NNMeasurements%Band_22_Radiances%&
          &   values(NumChnnelsBand22, NumMIFs) )
      case ('R2:190.B23D:H2O.S0.DACS-4')
        if ( verbose ) print *, 'Got Band 23'
        NeededBands(23) = .true.
        NNMeasurements_2%Band_23_Radiances%NumChannels = NumChnnelsBand22
        NNMeasurements_2%Band_23_Radiances%NumMIFs     = NumMIFs
        allocate( &
          & NNMeasurements_2%Band_23_Radiances%&
          &   values(NumChnnelsBand22, NumMIFs) )
      case default
        call output ( 'Unrecognized or unwanted signal string:', advance='no' )
        call output ( Capitalize(trim(signalStr)), advance='yes' )
        call announce_error ( key, &
          & 'Signal error' )
      end select
    end do                          ! End loop over bands

    ! Sanity checks
    ! Must have all needed Bands
    if ( RetrievedQty == 'Temperature') then
      if ( .not. &
        & (NeededBands(1) .and. NeededBands(8) .and. NeededBands(22) ) &
        &  ) then
        call announce_error ( key, &
        & 'Must have all 3 needed bands to retrieve T; check your l2cf' )
      endif
    else ! H2O
      if ( .not. &
        & (NeededBands(1) .and. NeededBands(2) .and. &
        &  NeededBands(3) .and. NeededBands(23) ) &
        &  ) then
        call announce_error ( key, &
        & 'Must have all 4 needed bands to retrieve H2O; check your l2cf' )
      endif
    endif
    if ( myFile > 0 ) then
      CoeffsFile => FileDatabase(myFile)
    else
      CoeffsFile => AddInitializeMLSFile ( FileDatabase, name=fileName, &
        & shortName=RetrievedQty, &
        & type=l_hdf, content='NNCoeffs', HDFVersion=HDFVersion_5 )
    endif
    call MLS_OpenFile( CoeffsFile, Status )
    ! These are absolute profile numbers, i.e. they start at '1' only
    ! for the first chunk
    call Dump ( Chunk )
    call L1BGeoLocation ( filedatabase, 'GHz/GeodAngle    ', &
      & 'GHz', values2d=GeodAngle )
    call L1BGeoLocation ( filedatabase, 'GHz/GeodLat    ', &
      & 'GHz', values2d=GeodLat )
    ! We'll use the Geod angles directly
    call Hunt ( Qty%template%phi(1,:),  &
      & GeodAngle(36,Chunk%firstMAFIndex+1), firstProfile, &
      & allowTopValue=.true. )
    call Hunt ( Qty%template%phi(1,:),  &
      & GeodAngle(36,Chunk%lastMAFIndex+1), lastProfile, &
      & allowTopValue=.true. )
    ! Now we actually want the profile numbers in the entire
    ! precessing range, not just this chunk
    firstProfile = firstprofile + chunk%hGridOffsets(1)
    lastProfile  = lastprofile  + chunk%hGridOffsets(1)
    if ( verbose ) print *, 'chunkNumber  ', chunk%ChunkNumber
    if ( verbose ) print *, 'HGrid offset  ', chunk%hGridOffsets(1)
    if ( verbose ) print *, 'firstProfile ', firstProfile
    if ( verbose ) print *, 'lastProfile  ',  lastProfile
    allocate(Values(NumLevels))
    allocate(PrecisionValues(NumLevels))
    allocate(FranksValues(Qty%template%NoSurfs))
    
    ! Here's something new: must find first and last latitude bins
    minLat = mlsmin( Qty%template%geodLat(1,:) )
    maxLat = mlsmax( Qty%template%geodLat(1,:) )
    firstBin = FindLast ( BinArray - minLat < 0._r4 )
    lastBin  = FindFirst ( BinArray - maxLat > 0._r4 )
    ! if ( lastBin < firstBin ) lastBin = firstBin ! In case firstBin == NumBins
    ! *** We ought to be careful to handle all anomalous cases ***
    if ( firstBin < 1 ) then
      firstBin = NumBins
      lastBin = NumBins
    elseif ( lastBin < 1 ) then
      lastBin = NumBins
    elseif ( firstBin > lastBin ) then
      lastBin = firstBin
    endif
    if ( verbose ) print *, 'minLat ', minLat
    if ( verbose ) print *, 'maxLat ', maxLat
    if ( verbose ) print *, 'firstBin ', firstBin
    if ( verbose ) print *, 'lastBin  ',  lastBin
    do BinNum = firstBin, lastBin
      if ( verbose ) call outputNamedValue ( 'BinNum', BinNum )
      call ReadCoeffsFile ( CoeffsFile, BinNum, &
        & Coeffs, &
        & BinNum==firstBin ) ! MustAllocate Coeffs arrays on the 1st time through
      if ( verbose ) print *, 'Done reading Coeffs file'
      ! call OutputNamedValue ( 'Num profiles', Qty%template%NoInstances )
      do profile = 1, Qty%template%NoInstances ! firstProfile, lastProfile
        if ( verbose ) call outputNamedValue ( 'instance number in chunk ', profile )
        ! Does this profile fall within this bin num?
        if ( &
          & Qty%template%geodLat(1,profile) < BinArray(BinNum) &
          & .or. &
          & Qty%template%geodLat(1,profile) > BinArray(BinNum) + BinSz &
          & ) &
          & cycle
        if ( verbose ) print *, 'lat of profile ', profile, ' ', Qty%template%geodLat(1,profile)
        if ( verbose ) print *, 'bin range ', BinArray(BinNum), BinArray(BinNum)+BinSz
        thisProfile = profile + firstProfile - 1
        ! Find thisMAF matching profile
        ! Choose which method by which to match MAF to profile
        call Hunt ( GeodAngle(36,:), &
          & Qty%template%phi(1,profile), thisMaf, &
          & allowTopValue=.true. )
        if ( verbose ) call OutputNamedValue ( 'Hunt returned MAF', thisMAF )
        theseMAFs(2) = thisMAF
        ! Do we need to scale?
        theseMAFs(1:1) = minloc( &
          & abs(GeodAngle(36,:)-Qty%template%phi(1,profile)) &
          & + &
          & abs(GeodLat(36,:)-Qty%template%GeodLat(1,profile)) &
          & ) - 1
        thisMAF = theseMAFs(1) ! minloc insists on returning an array 
        if ( verbose ) call OutputNamedValue ( 'minloc returned MAF', thisMAF )
        thisMAF = FindFirst( &
          & (abs(GeodAngle(36,:)-Qty%template%phi(1,profile)) < 2.) &
          & .and. &
          & (abs(GeodLat(36,:)-Qty%template%GeodLat(1,profile)) < 1.) &
          & )
        if ( verbose ) call OutputNamedValue ( 'FindFirst returned MAF', thisMAF )
        theseMAFs(3) = thisMAF
        thisMAF = theseMAFs(howMatched)
        MAF = thisMAF - Chunk%firstMAFIndex ! + 1
        ! Must constrain MAF to be within range
        !   [0, NumMAFs-1]
        MAF = max( MAF, 0 )
        MAF = min( MAF, NumMAFs - 1 )
        thisMAF = MAF + Chunk%firstMAFIndex
        if ( verbose ) print *, 'thisprofile, thisMAF ', thisprofile, thisMAF
        if ( verbose ) print *, 'firstProfile, firstMAFIndex ', firstProfile, Chunk%firstMAFIndex
        if ( verbose ) print *, 'binNum, profile, MAF, chunk ', binNum, profile, MAF, Chunk%ChunkNumber
        if ( verbose ) print *, 'binNum, thisprofile, thisMAF, chunk ', binNum, thisprofile, thisMAF, Chunk%ChunkNumber
        if ( verbose ) print *, 'Num measurement quantities ', measurements%template%noQuantities
        if ( verbose ) print *, 'Qty radiometer ', Qty%template%radiometer
        Qty%BinNumber(profile) = binNum
        Qty%MAF(profile)       = thisMAF
        ! MAF and profile are indices inside the chunk, not absolute indices
        do j = 1, measurements%template%noQuantities
          ! call Dump ( measurements%quantities(j)%template )
          if ( measurements%quantities(j)%template%quantityType /= l_radiance ) cycle
          !
          ! Because there is no radiometer defined for Temperature,
          ! we can hardly compare it to whatever radiometer the measurement
          ! quantity uses
          ! if ( measurements%quantities(j)%template%radiometer /= Temperature%template%radiometer ) cycle
          !
          radiances => measurements%quantities(j)
          signal = measurements%quantities(j)%template%signal
          ! print *, 'Calling AssembleNNMeasurement for MAF ', thisMAF
          if ( RetrievedQty == 'Temperature' ) then
            call AssembleNNMeasurement ( NNMeasurements, &
              & radiances, signal, &
              & Coeffs%MIFs, Coeffs%Channels_In_Each_Band, MAF, DeeBug )
          else ! H2O
            call AssembleNNMeasurement_2 ( NNMeasurements_2, &
              & radiances, signal, &
              & Coeffs%MIFs, Coeffs%Channels_In_Each_Band, MAF, DeeBug )
          endif
        end do     
        ! End loop over bands
        if ( RetrievedQty == 'Temperature' ) then
          if ( all(NNMeasurements%Band_1_Radiances%values == 0._r8) ) &
            print *, 'All band 1 radiances vanish'
          if ( all(NNMeasurements%Band_8_Radiances%values == 0._r8) ) &
            print *, 'All band 8 radiances vanish'
          if ( all(NNMeasurements%Band_22_Radiances%values == 0._r8) ) &
            print *, 'All band 22 radiances vanish'
          if ( StandardizeRadiancesHere ) then
            call StandardizeRadiances ( NNMeasurements, &
              & Coeffs%Standardization_Brightness_Temperature_Mean, &
              & Coeffs%Standardization_Brightness_Temperature_Std )
          endif
          ! stop
          ! print *, 'Calling NeuralNetFit'
          if ( verbose ) print *, 'Using NeuralNetFit with our own raw Radiances'
          call NeuralNetFit ( NNMeasurements, &
            & Coeffs, NumHiddenLayers, Values, PrecisionValues, &
            & Debugging=.false. )
          do j=1, NumLevels
            Temperature%values(Coeffs%Output_Pressure_Levels_Indices(j), profile) = &
              & Values(j)
          enddo
          if ( any(PrecisionValues == UndefinedValue) ) &
            & TemperaturePrecision%values(:,profile) = UndefinedValue
          ! if ( StandardizeRadiancesHere ) &
          !  & call Dump ( FranksValues, 'Temps (Franks ANN)' )
        else ! H2O
          if ( all(NNMeasurements_2%Band_1_Radiances%values == 0._r8) ) &
            print *, 'All band 1 radiances vanish'
          if ( all(NNMeasurements_2%Band_2_Radiances%values == 0._r8) ) &
            print *, 'All band 2 radiances vanish'
          if ( all(NNMeasurements_2%Band_3_Radiances%values == 0._r8) ) &
            print *, 'All band 3 radiances vanish'
          if ( all(NNMeasurements_2%Band_23_Radiances%values == 0._r8) ) &
            print *, 'All band 23 radiances vanish'
          if ( StandardizeRadiancesHere ) then
            call StandardizeRadiances ( NNMeasurements_2, &
              & Coeffs%Standardization_Brightness_Temperature_Mean, &
              & Coeffs%Standardization_Brightness_Temperature_Std )
          endif
          ! stop
          ! print *, 'Calling NeuralNetFit'
          if ( verbose ) print *, 'Using NeuralNetFit with our own raw Radiances'
          call NeuralNetFit ( NNMeasurements_2, &
            & Coeffs, NumHiddenLayers, Values, PrecisionValues, &
            & Debugging=.false. )
          do j=1, NumLevels
            Qty%values(Coeffs%Output_Pressure_Levels_Indices(j), profile) = &
              & Values(j)
          enddo
          if ( any(PrecisionValues == UndefinedValue) ) &
            & Precision%values(:,profile) = UndefinedValue
          ! if ( StandardizeRadiancesHere ) &
          !  & call Dump ( FranksValues, 'Temps (Franks ANN)' )
        endif
      enddo ! Loop of profiles
    enddo ! Loop of BinNums
    call MLS_CloseFile( CoeffsFile, Status )


    ! stop
!debug
!call dump(Temperature%values, 'beforedivide')

    call Dump( Temperature%BinNumber, 'BinNumbers' )
    call Dump( Temperature%MAF, 'MAFs' )

    if ( BeVerbose( 'neu', 0 ) .or. DeeBug ) then
      call Dump( Temperature%values )
      call Dump( Coeffs )
      call output ( '*** Neural Net complete ***', advance='yes' )
    endif
    call trace_end ( 'NeuralNet_m.NeuralNet', &
      & cond=toggle(gen) .and. levels(gen) > 1 )
  end subroutine NeuralNet

  ! ------------------ Private ---------------------------------
    ! ---------------------------------------------  ANNOUNCE_ERROR  -----
    subroutine announce_error ( wherewasit, &
      & extramessage, qty, extrainfo )

      use Moretree, only: StartErrorMessage

      integer, intent(in) :: WhereWasIt   ! Tree node WhereWasIt error was noticed
      character (len=*), intent(in), optional     :: EXTRAMESSAGE
      type (VectorValue_T), optional, intent(in)  :: QTY
      integer, intent(in), dimension(:), optional :: EXTRAINFO

      if ( present(extraMessage) ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & trim(extraMessage) )
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Calling ANNOUNCE_ERROR' )
      end if
      call StartErrorMessage ( WhereWasIt )
      if ( present(ExtraMessage) )  call output(ExtraMessage, advance='yes')
      if ( present(extraInfo) ) &
        & call dump ( extraInfo, name='Extra info' )
      if ( present(qty) ) call dump( qty )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
          & ' ' )
    end subroutine announce_error
  
  !------------------------------------------  AssembleNNMeasurements  -----
    ! Assemble masurements array to be used by RunNeuralNet
    subroutine AssembleNNMeasurement ( NNMeasurements, &
             & radiances, signal, MIFs, ChannelNums, MAF, DeeBug )
      type (VectorValue_T), pointer   :: Radiances ! The radiances for this band
      type(NeuralNetInputData_T)      :: NNMeasurements
      integer                         :: SIGNAL    ! the signal we're looking for
      integer, dimension(:)           :: MIFs      ! MIF numbers in radiances
      integer, dimension(:,:)         :: ChannelNums! channel numbers in radiances
      integer                         :: MAF ! Remember--1st MAF is 0
      logical, intent(in)             :: DeeBug
      ! Local variables
      integer                         :: channel
      integer                         :: chanNum
      integer                         :: MIF
      character(len=32)               :: SignalStr  ! its string value
      ! logical, parameter              :: DeeBug = .true.
      ! Executable
      call GetSignalName ( signal, signalStr )
      signalStr = ReplaceNonAscii( signalStr, ' ' )
      select case (Capitalize(signalStr) )
      case ('R1A:118.B1F:PT.S0.FB25-1')
        do MIF = 1, NumMIFs
          do channel = 1, NumChnnelsBand1
            chanNum = ChannelNums(channel, 1)
            NNMeasurements%Band_1_Radiances%values(channel,MIF) = &
              & radiances%value3(chanNum, MIFs(MIF), MAF+1)
          enddo
        enddo
        if ( DeeBug ) call OutputNamedValue ( 'Band 1 rad', &
          & NNMeasurements%Band_1_Radiances%values(1,1) )
      case ('R3:240.B8F:PT.S3.FB25-8')
        do MIF = 1, NumMIFs
          do channel = 1, NumChnnelsBand8
            chanNum = ChannelNums(channel, 2)
            NNMeasurements%Band_8_Radiances%values(channel,MIF) = &
              & radiances%value3(chanNum, MIFs(MIF), MAF+1)
          enddo
        enddo
        if ( DeeBug ) call OutputNamedValue ( 'Band 8 rad', &
          & NNMeasurements%Band_8_Radiances%values(1,1) )
      case ('R1A:118.B22D:PT.S0.DACS-4')
        do MIF = 1, NumMIFs
          do channel = 1, NumChnnelsBand22
            chanNum = ChannelNums(channel, 3)
            NNMeasurements%Band_22_Radiances%values(channel,MIF) = &
              & radiances%value3(chanNum, MIFs(MIF), MAF+1)
          enddo
        enddo
        if ( DeeBug ) call OutputNamedValue ( 'Band 22 rad', &
          & NNMeasurements%Band_22_Radiances%values(1,1) )
      case  default
        print *, 'Failed to recognize: ', Capitalize(signalStr)
      end select
    end subroutine AssembleNNMeasurement

    subroutine AssembleNNMeasurement_2 ( NNMeasurements, &
             & radiances, signal, MIFs, ChannelNums, MAF, DeeBug )
      ! real(r4), allocatable, dimension(:,:) :: NNMeasurements
      type (VectorValue_T), pointer   :: Radiances ! The radiances for this band
      type(NeuralNetInputData_2_T)    :: NNMeasurements
      integer                         :: SIGNAL    ! the signal we're looking for
      integer, dimension(:)           :: MIFs      ! MIF numbers in radiances
      integer, dimension(:,:)         :: ChannelNums! channel numbers in radiances
      integer                         :: MAF ! Remember--1st MAF is 0
      logical, intent(in)             :: DeeBug
      ! Local variables
      integer                         :: channel
      integer                         :: chanNum
      integer                         :: MIF
      character(len=32)               :: SignalStr  ! its string value
      ! logical, parameter              :: DeeBug = .true.
      ! Executable
      call GetSignalName ( signal, signalStr )
      signalStr = ReplaceNonAscii( signalStr, ' ' )
      select case (Capitalize(signalStr) )
      case ('R1A:118.B1F:PT.S0.FB25-1')
        do MIF = 1, NumMIFs
          do channel = 1, NumChnnelsBand1
            chanNum = ChannelNums(channel, 1)
            NNMeasurements%Band_1_Radiances%values(channel,MIF) = &
              & radiances%value3(chanNum, MIFs(MIF), MAF+1)
          enddo
        enddo
        if ( DeeBug ) call OutputNamedValue ( 'Band 1 rad', &
          & NNMeasurements%Band_1_Radiances%values(1,1) )
      case ('R2:190.B2F:H2O.S3.FB25-8')
        do MIF = 1, NumMIFs
          do channel = 1, NumChnnelsBand8
            chanNum = ChannelNums(channel, 2)
            NNMeasurements%Band_2_Radiances%values(channel,MIF) = &
              & radiances%value3(chanNum, MIFs(MIF), MAF+1)
          enddo
        enddo
        if ( DeeBug ) call OutputNamedValue ( 'Band 2 rad', &
          & NNMeasurements%Band_2_Radiances%values(1,1) )
      case ('R2:190.B3F:N2O.S3.FB25-8')
        do MIF = 1, NumMIFs
          do channel = 1, NumChnnelsBand8
            chanNum = ChannelNums(channel, 2)
            NNMeasurements%Band_3_Radiances%values(channel,MIF) = &
              & radiances%value3(chanNum, MIFs(MIF), MAF+1)
          enddo
        enddo
        if ( DeeBug ) call OutputNamedValue ( 'Band 3 rad', &
          & NNMeasurements%Band_3_Radiances%values(1,1) )
      case ('R1A:118.B23D:H2O.S0.DACS-4')
        do MIF = 1, NumMIFs
          do channel = 1, NumChnnelsBand22
            chanNum = ChannelNums(channel, 3)
            NNMeasurements%Band_23_Radiances%values(channel,MIF) = &
              & radiances%value3(chanNum, MIFs(MIF), MAF+1)
          enddo
        enddo
        if ( DeeBug ) call OutputNamedValue ( 'Band 23 rad', &
          & NNMeasurements%Band_23_Radiances%values(1,1) )
      case  default
        print *, 'Failed to recognize: ', Capitalize(signalStr)
      end select
    end subroutine AssembleNNMeasurement_2

  !------------------------------------------  InitializeNNMeasurements  -----
    subroutine InitializeNNMeasurements ! ( NNMeasurements )
      ! allocate and initialize masurements array to be used by RunNeuralNet
      ! real(r4), allocatable, dimension(:,:) :: NNMeasurements
    end subroutine InitializeNNMeasurements

  !------------------------------------------  ReadCoeffsFile  -----
    subroutine ReadCoeffsFile ( CoeffsFile, &
      & binNum, &
      & Coeffs, &
      & MustAllocate, &
      & Debugging )
      use MLSHDF5, only: IsHDF5DSPresent, LoadFromHDF5DS
      use MLSStrings, only: Asciify
      
      type (MLSFile_T)                        :: CoeffsFile
      integer, intent(in)                     :: BinNum
      ! real, dimension(:,:,:), allocatable     :: Coeffs
      type(NeuralNetCoeffs_T)                 :: Coeffs
      logical, intent(in)                     :: MustAllocate
      logical, optional, intent(in)           :: Debugging
      ! Local variables
      integer, dimension(2)                   :: shp    ! So we can reshape
      integer, dimension(3)                   :: start
      integer, dimension(3)                   :: count
      integer, dimension(3)                   :: stride
      integer, dimension(3)                   :: block
      character(len=35), dimension(:), allocatable     :: bands
      character(len=35), dimension(:), allocatable     :: charvalues
      integer, dimension(:), allocatable      :: Channels
      logical                                 :: DeeBug
      integer, dimension(:), allocatable      :: Levels
      real(r4), dimension(:), allocatable     :: values1
      real(r4), dimension(:,:), allocatable   :: values2
      real(r4), dimension(:,:,:), allocatable :: values3
      ! Executable
      DeeBug = .false.
      if ( present(Debugging) ) DeeBug = Debugging
      ! DeeBug = .true.
      if ( DeeBug ) print *, 'Now in ReadCoeffsFile with BinNum ', BinNum
      ! stop
      ! Allocate the max space we'll need
      allocate ( values1(5078) )
      allocate ( values2(1, 7575) )
      allocate ( values3(1, 5078, 7575) )
      if ( MustAllocate ) then
        ! Allocate the fields of our datatype to be read
        if ( DeeBug ) print *, 'Allocating ..'
        allocate ( Coeffs%Channels_In_Each_Band(51,3) )
        allocate ( Coeffs%Intercepts_Hidden_Layer_1(5078) )
        allocate ( Coeffs%Intercepts_Hidden_Layer_2(5078) )
        allocate ( Coeffs%Weights_Hidden_Labels_Layer(5078, 42) )
        allocate ( Coeffs%Weights_Hidden_Layer_1     (7575, 5078) )
        allocate ( Coeffs%Weights_Hidden_Layer_2     (5078, 5078) )
        allocate ( Coeffs%Normalization_Labels_Max(42) )
        allocate ( Coeffs%Normalization_Labels_Min(42) )
        allocate ( Coeffs%Output_Pressure_Levels(42) )
        allocate ( Coeffs%Output_Pressure_Levels_Indices(42) )
        allocate ( Coeffs%Standardization_Brightness_Temperature_Mean(7575) )
        allocate ( Coeffs%Standardization_Brightness_Temperature_Std (7575) )
        allocate ( Coeffs%MIFs(75) )
        allocate ( Coeffs%Bands(3) )
        ! Just for debugging
        allocate ( Coeffs%Means(18,7575) )
        allocate ( Coeffs%Stddevs (18,7575) )
      endif
      if ( .not. allocated(Coeffs%Channels_In_Each_Band) ) &
        & call announce_error(0, &
        & 'Allocation failed somehow' )
      ! Now read each dataset, 
      ! using a rank 2 or rank 3 temporary as appropriate
      ! Remember: 
      ! hyperslabs in hdf5 treat the "start" array as if it means "offset"
      !
      
      ! Bands
      allocate( Bands(3) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Bands", &
        & Bands )
        Coeffs%Bands = &
          Bands

      ! MIFs
      allocate( Levels(75) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "MIFs", &
        & Levels )
        Coeffs%MIFs = &
          Levels

      ! Output pressure levels (indices)
      deallocate( Levels )
      allocate( Levels(42) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Output_Pressure_Levels_Indices", &
        & Levels )
        Coeffs%Output_Pressure_Levels_Indices = &
          Levels

      ! Channels in each Band (indices)
      allocate( Channels(25) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Channels_Band_#1", &
        & Channels )
        Coeffs%Channels_In_Each_Band(1:25,1) = &
          Channels(1:25)

      call LoadFromHDF5DS ( CoeffsFile, &
        & "Channels_Band_#2", &
        & Channels )
        Coeffs%Channels_In_Each_Band(1:25,2) = &
          Channels(1:25)

      deallocate( Channels )
      allocate( Channels(51) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Channels_Band_#3", &
        & Channels )
        Coeffs%Channels_In_Each_Band(1:51,3) = &
          Channels(1:51)
      if ( DeeBug ) print *, 'Channels in each band'

      !
!       start = (/ binNum-1, 0, 0 /)
!       stride = (/ 1, 1, 1 /)
!       count = (/ 1, 5078, 0 /)
!       block = (/ 1, 1, 0 /)
!       print *, start(1:1), count(1:1), stride(1:1), block(1:1)
!       call LoadFromHDF5DS ( CoeffsFile, &
!         & "Intercepts_Hidden_Layer_1", &
!         & values2(:,1:count(2)), &
!         & start(1:2), count(1:2) )
! !        & start(1:2), count(1:2), stride(1:2), block(1:2) )
!         Coeffs%Intercepts_Hidden_Layer_1 = &
!           values2(1,1:count(2))
      deallocate ( values2 )

      start = (/ binNum-1, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 42, 0 /)
      block = (/ 1, 1, 0 /)
      allocate ( values2(1, 42) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Intercepts_Hidden_Labels_Layer", &
        & values2, &
        & start(1:2), count(1:2), stride(1:2), block(1:2) )
!       & values2 )
        Coeffs%Intercepts_Hidden_Labels_Layer = &
          values2(1,:)
      if ( DeeBug ) print *, 'Intercepts_Hidden_Labels_Layer'

      deallocate ( values1 )
      allocate ( values1(42) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Output_Pressure_Levels", &
        & values1 )
        Coeffs%Output_Pressure_Levels = &
          values1
      if ( DeeBug ) print *, 'Intercepts_Hidden_Labels_Layer'

      deallocate ( values2 )

      start = (/ binNum-1, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 5078, 0 /)
      block = (/ 1, 1, 0 /)
      allocate ( values2(1, 5078) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Intercepts_Hidden_Layer_1", &
        & values2, &
        & start(1:2), count(1:2), stride(1:2), block(1:2) )
        Coeffs%Intercepts_Hidden_Layer_1 = &
          values2(1,:)

      if ( DeeBug ) print *, 'Loaded Intercepts_Hidden_Layer_1'
!       call LoadFromHDF5DS ( CoeffsFile, &
!         & "Intercepts_Hidden_Layer_2", &
!         & values1, &
!         & start, count, stride, block )
!         Coeffs%Intercepts_Hidden_Layer_2 = &
!           (:)
! 
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Intercepts_Hidden_Layer_2", &
        & values2, &
        & start(1:2), count(1:2), stride(1:2), block(1:2) )
        Coeffs%Intercepts_Hidden_Layer_2 = &
          values2(1,:)

      if ( DeeBug ) print *, 'Loaded Intercepts_Hidden_Layer_2'

      deallocate ( values2 )

      ! Just for debugging
      start = (/ 0, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 18, 7575, 0 /)
      block = (/ 1, 1, 0 /)
      allocate ( values2(18, 7575) )

      call LoadFromHDF5DS ( CoeffsFile, &
        & "Standardization_Brightness_Temperatures_Mean", &
        & values2, &
        & start(1:2), count(1:2), stride(1:2), block(1:2) )
        Coeffs%Means = &
          values2

      call LoadFromHDF5DS ( CoeffsFile, &
        & "Standardization_Brightness_Temperatures_Std", &
        & values2, &
        & start(1:2), count(1:2), stride(1:2), block(1:2) )
        Coeffs%Stddevs = &
          values2

      if ( DeeBug ) print *, 'Loaded means, Stddevs for debugging'

      ! Back to stuff just for this bin
      deallocate ( values2 )
      start = (/ binNum-1, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 7575, 0 /)
      block = (/ 1, 1, 0 /)
      allocate ( values2(1, 7575) )

      call LoadFromHDF5DS ( CoeffsFile, &
        & "Standardization_Brightness_Temperatures_Mean", &
        & values2, &
        & start(1:2), count(1:2), stride(1:2), block(1:2) )
        Coeffs%Standardization_Brightness_Temperature_Mean = &
          values2(1,:)

      if ( DeeBug ) print *, 'Standardization_Brightness_Temperatures_Mean'

      call LoadFromHDF5DS ( CoeffsFile, &
        & "Standardization_Brightness_Temperatures_Std", &
        & values2, &
        & start(1:2), count(1:2), stride(1:2), block(1:2) )
        Coeffs%Standardization_Brightness_Temperature_Std = &
          values2(1,:)
      if ( DeeBug ) print *, 'Standardization_Brightness_Temperatures_Std'

      deallocate ( values3 )

      start = (/ binNum-1, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 42, 5078 /)
      block = (/ 1, 1, 1 /)
      allocate ( values3(1, 42, 5078) )
      shp = (/ 5078, 42 /)
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Weights_Hidden_Labels_Layer", &
        & values3, start, count, stride, block )
        Coeffs%Weights_Hidden_Labels_Layer = &
          Reshape( values3(1,:,:), shp, order=(/2,1/) )
      if ( DeeBug ) then
        print *, 'Weights_Hidden_Labels_Layer'
        print *, shape(values3)
        print *, shape(Coeffs%Weights_Hidden_Labels_Layer)
      endif
      ! stop

      deallocate ( values3 )

      start = (/ binNum-1, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 5078, 7575 /)
      block = (/ 1, 1, 1 /)
      allocate ( values3(1, 5078, 7575) )
      shp = (/ 7575, 5078 /)

      call LoadFromHDF5DS ( CoeffsFile, &
        & "Weights_Hidden_Layer_1", &
        & values3, start, count, stride, block )
        Coeffs%Weights_Hidden_Layer_1 = &
          Reshape( values3(1,:,:), shp, order=(/2,1/) )
      if ( DeeBug ) print *, 'Weights_Hidden_Layer_1'

      deallocate ( values3 )

      start = (/ binNum-1, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 5078, 5078 /)
      block = (/ 1, 1, 1 /)
      allocate ( values3(1, 5078, 5078) )
      shp = (/ 5078, 5078 /)
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Weights_Hidden_Layer_2", &
        & values3, start, count, stride, block )
        Coeffs%Weights_Hidden_Layer_2 = &
          Reshape( values3(1,:,:), shp, order=(/2,1/) )
      if ( DeeBug ) print *, 'Weights_Hidden_Layer_2'

      deallocate ( values2 )

      start = (/ binNum-1, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 42, 0 /)
      block = (/ 1, 1, 0 /)
      allocate ( values2(1, 42) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Normalization_Labels_Max", &
        & values2, start(1:2), count(1:2), &
        & stride(1:2), block(1:2) )
        Coeffs%Normalization_Labels_Max = &
          values2(1, :)
      if ( DeeBug ) print *, 'Normalization_Labels_Max'

      call LoadFromHDF5DS ( CoeffsFile, &
        & "Normalization_Labels_Min", &
        & values2, start(1:2), count(1:2), &
        & stride(1:2), block(1:2) )
        Coeffs%Normalization_Labels_Min = &
          values2(1, :)
      if ( DeeBug ) print *, 'Normalization_Labels_Min'
      
      ! The newer weights files include the dataset Activation_Function
      ! Older ones did not
      ! print *, 'Is activation function present? ', &
      !  & IsHDF5DSPresent ( CoeffsFile%fileID%f_id, "Activation_Function" )
      if ( .not. &
        & IsHDF5DSPresent ( CoeffsFile%fileID%f_id, "Activation_Function" ) &
        & ) then
        Coeffs%Activation_Function = 'tanh'
        if ( DeeBug ) print *, 'Activation_Function (default): ', &
          & trim(Coeffs%Activation_Function)
        return
      endif

      start = (/ 0, 0, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 42, 0 /)
      block = (/ 1, 1, 0 /)
      allocate ( charvalues(1) )
      call LoadFromHDF5DS ( CoeffsFile, &
        & "Activation_Function", &
        & charvalues, start(1:1), count(1:1), &
        & stride(1:1), block(1:1) )
      if ( DeeBug ) print *, 'Activation_Function (read): ', &
        & trim(charvalues(1))
      Coeffs%Activation_Function = &
        Asciify( charvalues(1), how='snip' )
      if ( DeeBug ) print *, 'Activation_Function (asciified): ', &
        & trim(Coeffs%Activation_Function)
    end subroutine ReadCoeffsFile

  !------------------------------------------  FileNameToID  -----
  ! Given a file name or a fragment of a file name found in the PCF
  ! return its index number into the file database.
  ! If the file is not found in the database, add it to the database.
  function FileNameToID ( fileName, DataBase )  result( ID )
    use Hdf, only: Dfacc_Rdonly
    use Intrinsic, only: L_HDF
    use MLSCommon, only: MLSFile_T
    use MLSFiles, only: HDFVersion_5, &
      & AddInitializeMLSFile, GetPCFromRef
    use MLSL2Options, only: Toolkit
    use MLSPCF2, only: MLSPCF_L2NeurNet_Start, MLSPCF_L2NeurNet_End

    ! Dummy arguments
    type (MLSFile_T), dimension(:), pointer :: DATABASE
    character(len=*), intent(in)            :: FileName ! full name or fragment
    integer                                 :: ID ! Index of file in database

    ! Local variables
    integer :: lun
    type (MLSFile_T), pointer   :: MLSFile
    integer :: mypcfEndCode
    integer :: PCBottom
    integer :: PCTop
    character(len=255) :: PCFFileName
    integer :: returnStatus
    integer :: Version
    ! Executable
    mypcfEndCode = 0
    lun = 0
    version = 1
    id = 0
    PCBottom = MLSPCF_L2NeurNet_Start
    PCTop    = MLSPCF_L2NeurNet_End
    print *, 'associated database: ', associated(dataBase)
    print *, 'len_trim(filename): ', len_trim(filename)
    ! if ( .not. associated(dataBase) .or. len_trim(filename) < 1 ) return
    if ( associated(database) ) then
      do id =1, size(database)
        if ( fileName == dataBase(id)%Name ) exit
        if ( fileName == dataBase(id)%ShortName ) exit
      enddo
      if ( id > size(database) ) id = 0
      if ( id > 0 ) return
    endif
    ! Must add file to database
    lun = GetPCFromRef( fileName, PCBottom, &
      & PCTop, &
      & TOOLKIT, returnStatus, Version, .false., &
      & exactName=PCFFileName )
    MLSFile => AddInitializeMLSFile( database, &
      & content='NeuralNetCoeffs', &
      & name=PCFFilename, shortName=fileName, &
      & type=l_hdf, access=dfacc_rdonly, HDFVersion=HDFVERSION_5 )
    call Dump ( MLSFile )
    ! Because we just now added a new item to the database, id is its new size
    id = size(database)
    print *, 'id: ', id
    print *, 'len_trim(exact filename): ', len_trim(PCFfilename)
  end function FileNameToID

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: NeuralNet_m.f90,v 2.17 2022/04/28 20:46:32 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module NeuralNet_m
!=============================================================================

!
! $Log: NeuralNet_m.f90,v $
! Revision 2.17  2022/04/28 20:46:32  pwagner
! First steps toward a 2nd n-n retrieval
!
! Revision 2.16  2022/04/13 21:33:03  pwagner
! Removed a lot of unneeded debugging stuff
!
! Revision 2.15  2021/10/14 22:25:25  pwagner
! Changes to acommodate setting precisions
!
! Revision 2.14  2021/07/28 23:43:12  pwagner
! Take care not to read Activation_Function unless it is present
!
! Revision 2.13  2021/07/22 23:18:26  pwagner
! Strip out extraordinary diagnostics relying on separate rad,temp files
!
! Revision 2.12  2021/07/08 23:33:03  pwagner
! Read Activation_Function from weights file; obey new api for NeuralNetFit; housekeeping
!
! Revision 2.11  2021/06/24 23:31:17  pwagner
! Coded 3 different approaches to matching profile to MAF
!
! Revision 2.10  2021/06/18 15:18:25  pwagner
! Distinguish StandardizeRadiancesHere (should always) from CheckTempsAndRads (optional)
!
! Revision 2.9  2021/06/10 23:49:11  pwagner
! Store BinNumber and MAF for retrieved qty
!
! Revision 2.8  2021/05/27 23:52:30  pwagner
! Now gets coeffs file from PCF; MAF index starts at 0; avoid use of L1MAF To and From functions in favor of L1BGeoLocation
!
! Revision 2.7  2021/05/18 15:53:56  pwagner
! Many bugs fixed; still in debug mode
!
! Revision 2.6  2021/04/01 23:52:57  pwagner
! Debugging til the cows come home (moo)
!
! Revision 2.5  2021/03/18 23:48:18  pwagner
! Fixed some more errors; added more debugging aids
!
! Revision 2.4  2021/03/05 00:55:30  pwagner
! A tiny bit of progress
!
! Revision 2.3  2021/02/19 00:28:08  pwagner
! repaired many bugs; still unsatisfactory imo
!
! Revision 2.2  2021/02/05 05:16:37  pwagner
! Repaired many errors; others doubtless remain
!
! Revision 2.1  2021/01/22 00:22:18  pwagner
! First commit
!
@


2.17
log
@First steps toward a 2nd n-n retrieval
@
text
@d781 1
d1061 2
d1081 6
a1086 8
      if ( DeeBug ) then
        print *, 'Activation_Function (read): ', &
          & trim(charvalues(1))
          Coeffs%Activation_Function = &
            Asciify( charvalues(1), how='snip' )
        print *, 'Activation_Function (asciified): ', &
          & trim(Coeffs%Activation_Function)
      endif
d1153 1
a1153 1
       "$Id: NeuralNet_m.f90,v 2.16 2022/04/13 21:33:03 pwagner Exp $"
d1165 3
@


2.16
log
@Removed a lot of unneeded debugging stuff
@
text
@a17 1
  use HDF, only: DFAcc_Create, DFAcc_RDOnly
d31 2
a32 1
  use NeuralNetUtils_m, only: NeuralNetCoeffs_T, NeuralNetInputData_T, &
d87 1
a87 1
  integer, parameter              :: NumHiddenLayers  = 2
d112 1
a112 1
    use Init_Tables_Module, only: L_HDF, L_Temperature, L_Radiance
d121 1
a121 1
    logical, dimension(3) :: NeededBands
d144 1
d155 1
a155 1
    real(Rv), allocatable, dimension(:) :: TemperatureValues
d169 3
d174 2
d179 1
d250 27
a276 2
      if ( state%quantities(i)%template%quantityType /= l_temperature ) then
        if ( verbose ) print *, 'Skipping non-Temperature state quantity'
a278 4
      TemperaturePrecision => OutputSD%quantities(i)
      Temperature => state%quantities(i)
      Temperature%values = 0.0_rv
      ! Now go through all the bands in the measurement vector that are in this radiometer
a279 4
    if ( .not. associated(Temperature%BinNumber) ) &
      & allocate(Temperature%BinNumber(Temperature%template%NoInstances) )
    if ( .not. associated(Temperature%MAF) ) &
      & allocate(Temperature%MAF(Temperature%template%NoInstances) )
d281 1
d305 19
a323 2
        NNMeasurements%Band_1_Radiances%NumChannels = NumChnnelsBand1
        NNMeasurements%Band_1_Radiances%NumMIFs     = NumMIFs
d325 9
a333 1
          & NNMeasurements%Band_1_Radiances%&
d337 1
a337 1
        NeededBands(2) = .true.
d345 1
a345 1
        NeededBands(3) = .true.
d351 8
d369 15
a383 3
    if ( .not. any(NeededBands) ) then
      call announce_error ( key, &
        & 'Must have all 3 needed bands; check your l2cf' )
d389 1
a389 1
        & shortName='Temperature', &
d401 1
a401 1
    call Hunt ( temperature%template%phi(1,:),  &
d404 1
a404 1
    call Hunt ( temperature%template%phi(1,:),  &
d415 1
a415 1
    allocate(TemperatureValues(NumLevels))
d417 1
a417 1
    allocate(FranksValues(Temperature%template%NoSurfs))
d420 2
a421 2
    minLat = mlsmin( temperature%template%geodLat(1,:) )
    maxLat = mlsmax( temperature%template%geodLat(1,:) )
d444 2
a445 2
      ! call OutputNamedValue ( 'Num profiles', temperature%template%NoInstances )
      do profile = 1, temperature%template%NoInstances ! firstProfile, lastProfile
d449 1
a449 1
          & temperature%template%geodLat(1,profile) < BinArray(BinNum) &
d451 1
a451 1
          & temperature%template%geodLat(1,profile) > BinArray(BinNum) + BinSz &
d454 1
a454 1
        if ( verbose ) print *, 'lat of profile ', profile, ' ', temperature%template%geodLat(1,profile)
d460 1
a460 1
          & temperature%template%phi(1,profile), thisMaf, &
d466 1
a466 1
          & abs(GeodAngle(36,:)-temperature%template%phi(1,profile)) &
d468 1
a468 1
          & abs(GeodLat(36,:)-temperature%template%GeodLat(1,profile)) &
d473 1
a473 1
          & (abs(GeodAngle(36,:)-temperature%template%phi(1,profile)) < 2.) &
d475 1
a475 1
          & (abs(GeodLat(36,:)-temperature%template%GeodLat(1,profile)) < 1.) &
d491 3
a493 3
        if ( verbose ) print *, 'Temperature radiometer ', Temperature%template%radiometer
        Temperature%BinNumber(profile) = binNum
        Temperature%MAF(profile)       = thisMAF
d507 9
a515 3
          call AssembleNNMeasurement ( NNMeasurements, &
            & radiances, signal, &
            & Coeffs%MIFs, Coeffs%Channels_In_Each_Band, MAF, DeeBug )
d518 54
a571 10
        if ( all(NNMeasurements%Band_1_Radiances%values == 0._r8) ) &
          print *, 'All band 1 radiances vanish'
        if ( all(NNMeasurements%Band_8_Radiances%values == 0._r8) ) &
          print *, 'All band 8 radiances vanish'
        if ( all(NNMeasurements%Band_22_Radiances%values == 0._r8) ) &
          print *, 'All band 22 radiances vanish'
        if ( StandardizeRadiancesHere ) then
          call StandardizeRadiances ( NNMeasurements, &
            & Coeffs%Standardization_Brightness_Temperature_Mean, &
            & Coeffs%Standardization_Brightness_Temperature_Std )
a572 14
        ! stop
        ! print *, 'Calling NeuralNetFit'
        if ( verbose ) print *, 'Using NeuralNetFit with our own raw Radiances'
        call NeuralNetFit ( NNMeasurements, &
          & Coeffs, NumHiddenLayers, TemperatureValues, PrecisionValues, &
          & Debugging=.false. )
        do j=1, NumLevels
          Temperature%values(Coeffs%Output_Pressure_Levels_Indices(j), profile) = &
            & TemperatureValues(j)
        enddo
        if ( any(PrecisionValues == UndefinedValue) ) &
          & TemperaturePrecision%values(:,profile) = UndefinedValue
        ! if ( StandardizeRadiancesHere ) &
        !  & call Dump ( FranksValues, 'Temps (Franks ANN)' )
d623 1
a625 2
      ! Assemble masurements array to be used by RunNeuralNet
      ! real(r4), allocatable, dimension(:,:) :: NNMeasurements
d678 65
d1078 8
a1085 6
      print *, 'Activation_Function (read): ', &
        & trim(charvalues(1))
        Coeffs%Activation_Function = &
          Asciify( charvalues(1), how='snip' )
      if ( DeeBug ) print *, 'Activation_Function (asciified): ', &
        & trim(Coeffs%Activation_Function)
d1152 1
a1152 1
       "$Id: NeuralNet_m.f90,v 2.15 2021/10/14 22:25:25 pwagner Exp $"
d1164 3
@


2.15
log
@Changes to acommodate setting precisions
@
text
@d89 1
d91 4
a181 5
    ! These next two are for debugging the date 2019d001
!     character (len=*), parameter    :: DefaultRadiances = &
!       & '/users/pwagner/' &
!       & // &
!       & 'Radiances_used_in_nn.h5' ! For radiances
a183 4
!     character (len=*), parameter    :: DefaultTemperatures = &
!       & '/users/fwerner/Documents/database/trained_neural_nets/test_data/temperature/v1.13/' &
!       & // &
!       & 'Temperature_20190101.h5' ! For results to compare with
a243 2
        ! call announce_error ( key, &
        !   & "state vector must contain only Temperature" )
a321 1
    if ( DeeBug .and. .false. ) call Dump ( FileDatabase )
a322 6
    ! call Dump( RadiancesFile )
!     call MLS_OpenFile( RadiancesFile, Status )
!     if ( Status /= 0 ) then
!       call announce_error ( key, &
!         & 'Failed to Open/Create Radiances File' )
!     endif
d326 15
a340 24
    if ( .false. ) then
      firstProfile = L1MAFToL2Profile ( &
        & Chunk%firstMAFIndex, FileDatabase, MIF=36, Debugging=.true. &
        & )
      lastProfile  = L1MAFToL2Profile ( &
        & Chunk%lastMAFIndex , FileDatabase, MIF=36, Debugging=.false. &
        & )
    else
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAngle    ', &
        & 'GHz', values2d=GeodAngle )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodLat    ', &
        & 'GHz', values2d=GeodLat )
      ! We'll use the Geod angles directly
      call Hunt ( temperature%template%phi(1,:),  &
        & GeodAngle(36,Chunk%firstMAFIndex+1), firstProfile, &
        & allowTopValue=.true. )
      call Hunt ( temperature%template%phi(1,:),  &
        & GeodAngle(36,Chunk%lastMAFIndex+1), lastProfile, &
        & allowTopValue=.true. )
      ! Now we actually want the profile numbers in the entire
      ! precessing range, not just this chunk
      firstProfile = firstprofile + chunk%hGridOffsets(1)
      lastProfile  = lastprofile  + chunk%hGridOffsets(1)
    endif
a376 1
!         call InitializeNNMeasurements ( NNMeasurements )
d388 22
a409 33
        if ( .false. ) then
          thisMAF = L2ProfileToL1MAF ( thisProfile, fileDatabase, MIF=36 )
        elseif ( .false. ) then
          ! We'll use the Geod angles directly
          ! Alas, sometimes this Hunt returns the wrong answer
          call Hunt ( GeodAngle(36,:), &
            & temperature%template%phi(1,profile), thisMaf, &
            & allowTopValue=.true. )
          call OutputNamedValue ( 'Hunt returned MAF', thisMAF )
        else
          ! Choose which method by which to match MAF to profile
          call Hunt ( GeodAngle(36,:), &
            & temperature%template%phi(1,profile), thisMaf, &
            & allowTopValue=.true. )
          if ( verbose ) call OutputNamedValue ( 'Hunt returned MAF', thisMAF )
          theseMAFs(2) = thisMAF
          ! Do we need to scale?
          theseMAFs(1:1) = minloc( &
            & abs(GeodAngle(36,:)-temperature%template%phi(1,profile)) &
            & + &
            & abs(GeodLat(36,:)-temperature%template%GeodLat(1,profile)) &
            & ) - 1
          thisMAF = theseMAFs(1) ! minloc insists on returning an array 
          if ( verbose ) call OutputNamedValue ( 'minloc returned MAF', thisMAF )
          thisMAF = FindFirst( &
            & (abs(GeodAngle(36,:)-temperature%template%phi(1,profile)) < 2.) &
            & .and. &
            & (abs(GeodLat(36,:)-temperature%template%GeodLat(1,profile)) < 1.) &
            & )
          if ( verbose ) call OutputNamedValue ( 'FindFirst returned MAF', thisMAF )
          theseMAFs(3) = thisMAF
          thisMAF = theseMAFs(howMatched)
        endif
a428 8
          if ( .false. ) then
          call outputNamedValue ( 'j ', j )
          call outputNamedValue ( 'Qty radiometer ', measurements%quantities(j)%template%radiometer )
          call outputNamedValue ( 'Phi', measurements%quantities(j)%template%Phi(1,MAF+1) )
          call outputNamedValue ( 'longitude', measurements%quantities(j)%template%lon(1,MAF+1) )
          call outputNamedValue ( 'latitude', measurements%quantities(j)%template%GeodLat(1,MAF+1) )
          call outputNamedValue ( 'bin latitude', BinArray(BinNum) )
          endif
d980 1
a980 1
       "$Id: NeuralNet_m.f90,v 2.14 2021/07/28 23:43:12 pwagner Exp $"
d992 3
@


2.14
log
@Take care not to read Activation_Function unless it is present
@
text
@d22 1
a22 1
  use MLSCommon, only: MLSChunk_T, MLSFile_T
d108 1
a108 1
    use Init_Tables_Module, only: F_State, F_Measurements, F_File
d148 1
d158 1
d164 1
d218 2
d253 1
d368 1
d498 3
a500 2
        TemperatureValues = NeuralNetFit ( NNMeasurements, &
          & Coeffs, NumHiddenLayers, Debugging=.false. )
d505 2
d1022 1
a1022 1
       "$Id: NeuralNet_m.f90,v 2.13 2021/07/22 23:18:26 pwagner Exp $"
d1034 3
@


2.13
log
@Strip out extraordinary diagnostics relying on separate rad,temp files
@
text
@d617 1
a617 1
      use MLSHDF5, only: LoadFromHDF5DS
d919 11
d1012 1
a1012 1
       "$Id: NeuralNet_m.f90,v 2.12 2021/07/08 23:33:03 pwagner Exp $"
d1024 3
@


2.12
log
@Read Activation_Function from weights file; obey new api for NeuralNetFit; housekeeping
@
text
@a204 16
    if ( CheckTempsAndRads ) then
      RadfileID = mls_sfstart ( trim(DefaultRadiances), DFAcc_Create, &
          &                                          hdfVersion=HDFVersion_5 )
      TempfileID = mls_sfstart ( trim(DefaultTemperatures), DFAcc_RDOnly, &
          &                                          hdfVersion=HDFVersion_5 )
      if ( verbose ) print *, 'Opened RadFile id ', RadfileID
      if ( verbose ) print *, 'Opened TempFile id ', TempfileID
      if ( RadfileID < 0 ) then
        call announce_error ( key, &
          & 'Failed to Open/Create Radiances File: ' // trim(DefaultRadiances) )
      endif
    endif
!       RadiancesFile => AddInitializeMLSFile ( FileDatabase, name=DefaultRadiances, &
!         & shortName='Radiances', access=Dfacc_Create,  &
!         & type=l_hdf, content='NNRadiances', HDFVersion=HDFVersion_5 )

a314 4
    if ( UseMatchedTemps .and. .not. CheckTempsAndRads ) then
      call announce_error ( key, &
        & 'If UseMatchedTemps then must CheckTempsAndRads' )
    endif
d484 3
a486 14
          if ( CheckTempsAndRads ) then
            call StandardizeRadiances ( NNMeasurements, &
              & Coeffs%Standardization_Brightness_Temperature_Mean, &
              & Coeffs%Standardization_Brightness_Temperature_Std, &
              & TempFileID, thisMAF, Coeffs )
            if ( verbose ) print *, 'As we know them: thisProfile, thisMAF, thisBin ', &
              & thisprofile, thisMAF, binNum
            call CheckTemperatures( TempFileID, (/ thisProfile, thisProfile /), &
              & FranksValues )
          else
            call StandardizeRadiances ( NNMeasurements, &
              & Coeffs%Standardization_Brightness_Temperature_Mean, &
              & Coeffs%Standardization_Brightness_Temperature_Std )
          endif
d490 3
a492 12
        if ( CheckTempsAndRads ) &
          & print *, 'Rad FileID: ', RadfileID
        if ( CheckTempsAndRads ) then
          print *, 'Calling NeuralNetFit with diagn rad and temp files'
          TemperatureValues = NeuralNetFit ( NNMeasurements, &
            & Coeffs, NumHiddenLayers, &
            & RadfileID, TempFileID, thisMAF, thisProfile, Debugging=.false. )
        else
          if ( verbose ) print *, 'Using NeuralNetFit with our own raw Radiances'
          TemperatureValues = NeuralNetFit ( NNMeasurements, &
            & Coeffs, NumHiddenLayers, Debugging=.false. )
        endif
a496 31
        if ( CheckTempsAndRads ) then
          call OutputNamedValue ( 'Our profile num', thisProfile )
          call OutputNamedValue ( 'MAF ours and Franks', (/thisMAF, matchedMAF/) )
          call OutputNamedValue ( 'Bin Number ours and Franks', (/BinNum, matchedBinNum/) )
!           j  = L1MAFToL2Profile ( &
!             & thisMAF , FileDatabase, MIF=36, Debugging=.false., &
!             & Phi=Phi, Lat=Lat )
!           call OutputNamedValue ( 'Our phi, lat', (/Phi, Lat/) )
!           j = FindFirst ( BinArray - Lat > 0._r4 )
!           call OutputNamedValue ( 'Our bin', j )
!           j  = L1MAFToL2Profile ( &
!             & matchedMAF , FileDatabase, MIF=36, Debugging=.false., &
!             & Phi=Phi, Lat=Lat )
!           ! call OutputNamedValue ( 'Franks phi, lat', (/Phi, Lat/) )
!           j = FindFirst ( BinArray - Lat > 0._r4 )
!           call OutputNamedValue ( 'Matched bin using Franks l1boa Latitude', j )
          call Dump ( Temperature%values(:, profile), 'Temps (nn)', Width=5 )
          ! do j=1, NumLevels
          !  Temperature%values(Coeffs%Output_Pressure_Levels_Indices(j), profile) = &
          !     & FranksValues(j)
          ! enddo
          call Dump ( FranksValues, 'Temps (Franks ANN)', Width=5 )
          if ( UseMatchedTemps ) then
            do j=1, Temperature%template%NoSurfs
              Temperature%values(j, profile) = &
                & FranksValues(j)
            enddo
            Temperature%BinNumber(profile) = matchedBinNum
            Temperature%MAF(profile)       = matchedMAF
          endif
        endif
a498 36
        if ( UseMatchedRadiances .and. .not. UseMatchedTemps ) then
          if ( CheckMAFs( TempFileID, matchedStdRadiances ) /= matchedMAF ) &
            & call announce_error ( key, &
            & 'Inconsistent matched MAF number' )
          call ReadCoeffsFile ( CoeffsFile, matchedBinNum, &
            & Coeffs, .false. ) ! MustAllocate Coeffs arrays on the 1st time through
          FranksValues = NeuralNetFit ( NNMeasurements, &
            & Coeffs, NumHiddenLayers, &
            & MAF=matchedMAF, &
            & Profile=thisProfile, Debugging=.false., &
            & StdRadiances=matchedStdRadiances )
          call OutputNamedValue ( 'his bin num', matchedBinNum )
          do j=1, NumLevels
            Temperature%values(Coeffs%Output_Pressure_Levels_Indices(j), profile) = &
              & FranksValues(j)
          enddo
          call Dump ( Temperature%values(:, profile), &
            & 'Temps (Matching Franks StdRads, his BinNum)', Width=5 )
!          call Dump ( FranksValues, 'Temps (Matching Franks StdRads, his BinNum)' )

          call ReadCoeffsFile ( CoeffsFile, BinNum, &
            & Coeffs, .false. ) ! MustAllocate Coeffs arrays on the 1st time through
          FranksValues = NeuralNetFit ( NNMeasurements, &
            & Coeffs, NumHiddenLayers, &
            & MAF=matchedMAF, &
            & Profile=thisProfile, Debugging=.false., &
            & StdRadiances=matchedStdRadiances )
          do j=1, NumLevels
            Temperature%values(Coeffs%Output_Pressure_Levels_Indices(j), profile) = &
              & FranksValues(j)
          enddo
          call OutputNamedValue ( 'our bin num', BinNum )
          call Dump ( Temperature%values(:, profile), &
            & 'Temps (Matching Franks StdRads, our Bin Num)', Width=5 )
!          call Dump ( FranksValues, 'Temps (Matching Franks StdRads, ourBinNum)' )
        endif
a502 17
    if ( CheckTempsAndRads ) then
      Status = MLS_SFEnd( RadfileID, hdfVersion=HDFVersion_5 )
      if ( verbose ) print *, 'Closed RadFile id ', RadfileID
      if ( verbose ) print *, Status
      if ( Status /= 0 ) then
        print *, 'Error in ending hdf access to file'
        stop
      endif

      Status = MLS_SFEnd( TempfileID, hdfVersion=HDFVersion_5 )
      if ( verbose ) print *, 'Closed TempFile id ', TempfileID
      if ( verbose ) print *, Status
      if ( Status /= 0 ) then
        print *, 'Error in ending hdf access to file'
        stop
      endif
    endif
d1001 1
a1001 1
       "$Id: NeuralNet_m.f90,v 2.11 2021/06/24 23:31:17 pwagner Exp $"
d1013 3
@


2.11
log
@Coded 3 different approaches to matching profile to MAF
@
text
@d88 2
a89 1
  character(len=*), parameter     :: switchOver       = 'tanh' ! or 'sigmoid'
d153 1
d198 2
a199 1
    DEEBUG = LetsDebug ( 'neu', 0 ) .or. .true.
d210 2
a211 2
      print *, 'Opened RadFile id ', RadfileID
      print *, 'Opened TempFile id ', TempfileID
d239 1
a239 1
      print *, 'filename read: ', trim(filename)
d243 1
a243 1
      print *, 'No filename read'
d247 1
a247 1
      print *, 'Must use default filename: ', trim(defaultFileName)
d261 1
a261 1
        print *, 'Skipping non-Temperature state quantity'
d275 1
a275 1
        print *, 'measurement quantity type is not a radiance'
d294 1
a294 1
        print *, 'Got Band 1'
d302 1
a302 1
        print *, 'Got Band 8'
d310 1
a310 1
        print *, 'Got Band 22'
d377 4
a380 4
    print *, 'chunkNumber  ', chunk%ChunkNumber
    print *, 'HGrid offset  ', chunk%hGridOffsets(1)
    print *, 'firstProfile ', firstProfile
    print *, 'lastProfile  ',  lastProfile
d399 4
a402 4
    print *, 'minLat ', minLat
    print *, 'maxLat ', maxLat
    print *, 'firstBin ', firstBin
    print *, 'lastBin  ',  lastBin
d404 1
a404 1
      call outputNamedValue ( 'BinNum', BinNum )
d408 1
a408 1
      print *, 'Done reading Coeffs file'
d411 1
a411 1
        call outputNamedValue ( 'instance number in chunk ', profile )
d420 2
a421 2
        print *, 'lat of profile ', profile, ' ', temperature%template%geodLat(1,profile)
        print *, 'bin range ', BinArray(BinNum), BinArray(BinNum)+BinSz
d438 1
a438 1
          call OutputNamedValue ( 'Hunt returned MAF', thisMAF )
d447 1
a447 1
          call OutputNamedValue ( 'minloc returned MAF', thisMAF )
d453 1
a453 1
          call OutputNamedValue ( 'FindFirst returned MAF', thisMAF )
d463 6
a468 6
        print *, 'thisprofile, thisMAF ', thisprofile, thisMAF
        print *, 'firstProfile, firstMAFIndex ', firstProfile, Chunk%firstMAFIndex
        print *, 'binNum, profile, MAF, chunk ', binNum, profile, MAF, Chunk%ChunkNumber
        print *, 'binNum, thisprofile, thisMAF, chunk ', binNum, thisprofile, thisMAF, Chunk%ChunkNumber
        print *, 'Num measurement quantities ', measurements%template%noQuantities
        print *, 'Temperature radiometer ', Temperature%template%radiometer
d509 1
a509 1
            print *, 'As we know them: thisProfile, thisMAF, thisBin ', &
a522 2
        ! Temperature%values(8:49, profile) = NeuralNetFit ( NNMeasurements, &
        !   & Coeffs, NumHiddenLayers, switchOver )
d526 1
a526 1
            & Coeffs, NumHiddenLayers, switchOver, &
d529 1
a529 1
          print *, 'Using NeuralNetFit with our own raw Radiances'
d531 1
a531 1
            & Coeffs, NumHiddenLayers, switchOver, Debugging=.false. )
d577 1
a577 1
            & Coeffs, NumHiddenLayers, switchOver, &
d593 1
a593 1
            & Coeffs, NumHiddenLayers, switchOver, &
d612 2
a613 2
      print *, 'Closed RadFile id ', RadfileID
      print *, Status
d620 2
a621 2
      print *, 'Closed TempFile id ', TempfileID
      print *, Status
d742 1
d757 1
d1043 16
d1125 1
a1125 1
       "$Id: NeuralNet_m.f90,v 2.10 2021/06/18 15:18:25 pwagner Exp $"
d1137 3
@


2.10
log
@Distinguish StandardizeRadiancesHere (should always) from CheckTempsAndRads (optional)
@
text
@d123 6
d149 1
d165 1
d200 1
a200 1
    nullify ( GeodAngle )
d360 2
d420 1
d423 7
d431 1
a431 1
          ! We'll use the Geod angles directly
d436 17
d1106 1
a1106 1
       "$Id: NeuralNet_m.f90,v 2.9 2021/06/10 23:49:11 pwagner Exp $"
d1118 3
@


2.9
log
@Store BinNumber and MAF for retrieved qty
@
text
@d96 3
a98 2
  Logical, parameter              :: UseMatchedRadiances      = .true.
  Logical, parameter              :: UseMatchedTemps          = .true.
d194 1
a194 1
    if ( StandardizeRadiancesHere ) then
d320 1
a320 1
    if ( UseMatchedTemps .and. .not. StandardizeRadiancesHere ) then
d322 1
a322 1
        & 'If UseMatchedTemps then must StandardizeRadiancesHere' )
d396 1
a396 1
      call OutputNamedValue ( 'Num profiles', temperature%template%NoInstances )
d398 1
a398 1
        call outputNamedValue ( 'profile ', profile )
d438 1
d445 1
d453 1
a453 1
          print *, 'Calling AssembleNNMeasurement for MAF ', thisMAF
d466 14
a479 9
          call StandardizeRadiances ( NNMeasurements, &
            & Coeffs%Standardization_Brightness_Temperature_Mean, &
            & Coeffs%Standardization_Brightness_Temperature_Std, &
            & TempFileID, thisMAF, Coeffs )
          print *, 'As we know them: thisProfile, thisMAF, thisBin ', &
            & thisprofile, thisMAF, binNum
          call CheckTemperatures( TempFileID, (/ thisProfile, thisProfile /), &
            & FranksValues )
          
d482 2
a483 2
        print *, 'Calling NeuralNetFit'
        if ( StandardizeRadiancesHere ) &
d487 2
a488 1
        if ( StandardizeRadiancesHere ) then
d493 1
d501 1
a501 1
        if ( StandardizeRadiancesHere ) then
d574 1
a574 1
    if ( StandardizeRadiancesHere ) then
d1071 1
a1071 1
       "$Id: NeuralNet_m.f90,v 2.8 2021/05/27 23:52:30 pwagner Exp $"
d1083 3
@


2.8
log
@Now gets coeffs file from PCF; MAF index starts at 0; avoid use of L1MAF To and From functions in favor of L1BGeoLocation
@
text
@d95 3
a97 2
  Logical, parameter              :: StandardizeRadiancesHere = .false.
  Logical, parameter              :: UseMatchedRadiances      = .false.
d131 1
d164 4
a168 2
      & '/users/pwagner/' &
      & // &
d170 4
a174 2
      & '/users/fwerner/Documents/database/trained_neural_nets/test_data/temperature/v1.13/' &
      & // &
d255 5
a259 1
    end do                          ! End loop over bands
d277 1
d319 4
d375 10
a384 1
    if ( lastBin < firstBin ) lastBin = firstBin ! In case firstBin == NumBins
a399 2
        print *, 'lat of profile ', profile, ' ', temperature%template%geodLat(1,profile)
        print *, 'bin range ', BinArray(BinNum), BinArray(BinNum)+BinSz
d406 2
d416 1
d419 5
d426 2
a427 1
        print *, 'binNum, profile, MAF ', binNum, profile, MAF
d430 2
d442 1
d495 12
a506 12
          j  = L1MAFToL2Profile ( &
            & thisMAF , FileDatabase, MIF=36, Debugging=.false., &
            & Phi=Phi, Lat=Lat )
          call OutputNamedValue ( 'Our phi, lat', (/Phi, Lat/) )
          j = FindFirst ( BinArray - Lat > 0._r4 )
          call OutputNamedValue ( 'Our bin', j )
          j  = L1MAFToL2Profile ( &
            & matchedMAF , FileDatabase, MIF=36, Debugging=.false., &
            & Phi=Phi, Lat=Lat )
          ! call OutputNamedValue ( 'Franks phi, lat', (/Phi, Lat/) )
          j = FindFirst ( BinArray - Lat > 0._r4 )
          call OutputNamedValue ( 'Franks bin', j )
d513 8
d524 1
a524 1
        if ( UseMatchedRadiances ) then
d586 2
a587 1

d1061 1
a1061 1
       "$Id: NeuralNet_m.f90,v 2.7 2021/05/18 15:53:56 pwagner Exp $"
d1073 3
@


2.7
log
@Many bugs fixed; still in debug mode
@
text
@d19 1
d21 1
d26 1
a26 1
  use MLSKinds, only: R4, R8, Rv
d28 1
a28 1
  use MLSSignals_M, only: DisplayRadiometer, GetSignalName
d62 2
d95 2
a96 2
  Logical, parameter              :: StandardizeRadiancesHere = .true.
  Logical, parameter              :: UseMatchedRadiances      = .true.
d120 1
d154 3
d161 1
d185 1
d187 11
a197 9
    RadfileID = mls_sfstart ( trim(DefaultRadiances), DFAcc_Create, &
        &                                          hdfVersion=HDFVersion_5 )
    TempfileID = mls_sfstart ( trim(DefaultTemperatures), DFAcc_RDOnly, &
        &                                          hdfVersion=HDFVersion_5 )
    print *, 'Opened RadFile id ', RadfileID
    print *, 'Opened TempFile id ', TempfileID
    if ( RadfileID < 0 ) then
      call announce_error ( key, &
        & 'Failed to Open/Create Radiances File: ' // trim(DefaultRadiances) )
d205 2
d214 2
a215 1
        file = sub_rosa(subtree(2,son))
d221 1
d225 1
d229 1
d326 24
a349 6
    firstProfile = L1MAFToL2Profile ( &
      & Chunk%firstMAFIndex, FileDatabase, MIF=36, Debugging=.true. &
      & )
    lastProfile  = L1MAFToL2Profile ( &
      & Chunk%lastMAFIndex , FileDatabase, MIF=36, Debugging=.false. &
      & )
d360 1
d385 11
a395 2
        thisMAF = L2ProfileToL1MAF ( thisProfile, fileDatabase, MIF=36 )
        MAF = thisMAF - Chunk%firstMAFIndex + 1
a396 1
        print *, 'thisprofile, thisMAF ', thisprofile, thisMAF
d406 3
a408 3
          call outputNamedValue ( 'Phi', measurements%quantities(j)%template%Phi(1,MAF) )
          call outputNamedValue ( 'longitude', measurements%quantities(j)%template%lon(1,MAF) )
          call outputNamedValue ( 'latitude', measurements%quantities(j)%template%GeodLat(1,MAF) )
d439 1
a439 1
!         call RunNeuralNet ( NNMeasurements, c, MyNeuralNet )
d441 2
a442 1
        print *, 'Rad FileID: ', RadfileID
d445 8
a452 3
        TemperatureValues = NeuralNetFit ( NNMeasurements, &
          & Coeffs, NumHiddenLayers, switchOver, &
          & RadfileID, TempFileID, thisMAF, thisProfile, Debugging=.false. )
a456 16
        call OutputNamedValue ( 'Our profile num', thisProfile )
        call OutputNamedValue ( 'MAF ours and Franks', (/thisMAF, matchedMAF/) )
        call OutputNamedValue ( 'Bin Number ours and Franks', (/BinNum, matchedBinNum/) )
        j  = L1MAFToL2Profile ( &
          & thisMAF , FileDatabase, MIF=36, Debugging=.false., &
          & Phi=Phi, Lat=Lat )
        call OutputNamedValue ( 'Our phi, lat', (/Phi, Lat/) )
        j = FindFirst ( BinArray - Lat > 0._r4 )
        call OutputNamedValue ( 'Our bin', j )
        j  = L1MAFToL2Profile ( &
          & matchedMAF , FileDatabase, MIF=36, Debugging=.false., &
          & Phi=Phi, Lat=Lat )
        ! call OutputNamedValue ( 'Franks phi, lat', (/Phi, Lat/) )
        j = FindFirst ( BinArray - Lat > 0._r4 )
        call OutputNamedValue ( 'Franks bin', j )
        call Dump ( Temperature%values(:, profile), 'Temps (nn)', Width=5 )
d458 16
d522 8
a529 7
    Status = MLS_SFEnd( RadfileID, hdfVersion=HDFVersion_5 )
    print *, 'Closed RadFile id ', RadfileID
    print *, Status
    if ( Status /= 0 ) then
      print *, 'Error in ending hdf access to file'
      stop
    endif
d531 7
a537 6
    Status = MLS_SFEnd( TempfileID, hdfVersion=HDFVersion_5 )
    print *, 'Closed TempFile id ', TempfileID
    print *, Status
    if ( Status /= 0 ) then
      print *, 'Error in ending hdf access to file'
      stop
d540 1
a540 1
    stop
d593 1
a593 1
      integer                         :: MAF
d610 1
a610 1
              & radiances%value3(chanNum, MIFs(MIF), MAF)
d620 1
a620 1
              & radiances%value3(chanNum, MIFs(MIF), MAF)
d630 1
a630 1
              & radiances%value3(chanNum, MIFs(MIF), MAF)
d955 11
a965 3
  function FileNameToID ( fileName, DataBase )  result(ID)

    ! Given filename, returns index; if name not found in db, returns 0
d969 2
a970 2
    character(len=*), intent(in)            :: FileName
    integer                                 :: ID
d973 8
d982 3
d986 27
a1012 6
    if ( .not. associated(dataBase) .or. len_trim(filename) < 1 ) return
    do id =1, size(database)
      if ( fileName == dataBase(id)%Name ) exit
      if ( fileName == dataBase(id)%ShortName ) exit
    enddo
    if ( id > size(database) ) id = 0
d1018 1
a1018 1
       "$Id: NeuralNet_m.f90,v 2.6 2021/04/01 23:52:57 pwagner Exp $"
d1030 3
@


2.6
log
@Debugging til the cows come home (moo)
@
text
@d655 2
a656 1
      ! Sadly, our implementation of hyperslabs seems to be buggy.
a657 5
      !  For an example of how to do it right, see
      ! /software/toolkit/ifc17/hdf5/fortran/examples//hyperslab.f90
      !
      ! Until we repair the hyperslab in LoadFromHDF5DS, we must resort to
      ! reading all 18 latitude bins every time (oof!)
d708 4
a711 4
      start = (/ binNum, 1, 0 /)
      stride = (/ 1, 1, 1 /)
      count = (/ 1, 5078, 0 /)
      block = (/ 1, 1, 0 /)
d722 5
a726 1
      allocate ( values2(18, 42) )
d729 3
a731 1
        & values2 )
d733 1
a733 1
          values2(binNum,:)
d747 5
a751 1
      allocate ( values2(18, 5078) )
d754 2
a755 1
        & values2 )
d757 1
a757 1
          values2(binNum,:)
d769 2
a770 1
        & values2 )
d772 1
a772 1
          values2(binNum,:)
d778 5
d787 2
a788 3
        & values2 )
        Coeffs%Standardization_Brightness_Temperature_Mean = &
          values2(binNum,:)
d792 24
d820 2
a821 1
        & values2 )
d823 1
a823 3
          values2(binNum,:)
        Coeffs%Stddevs = &
          values2
d828 5
a832 1
      allocate ( values3(18, 42,5078) )
d836 1
a836 1
        & values3 )
d838 1
a838 1
          Reshape( values3(binNum,:,:), shp, order=(/2,1/) )
d848 5
a852 1
      allocate ( values3(18, 5078, 7575) )
d857 1
a857 1
        & values3 )
d859 1
a859 1
          Reshape( values3(binNum,:,:), shp, order=(/2,1/) )
d864 5
a868 1
      allocate ( values3(18, 5078, 5078) )
d872 1
a872 1
        & values3 )
d874 1
a874 1
          Reshape( values3(binNum,:,:), shp, order=(/2,1/) )
d879 5
a883 1
      allocate ( values2(18, 42) )
d886 2
a887 1
        & values2 )
d889 1
a889 1
          values2(binNum, :)
d894 2
a895 1
        & values2 )
d897 1
a897 1
          values2(binNum, :)
d925 1
a925 1
       "$Id: NeuralNet_m.f90,v 2.5 2021/03/18 23:48:18 pwagner Exp $"
d937 3
@


2.5
log
@Fixed some more errors; added more debugging aids
@
text
@d31 2
a32 1
    & Dump, NeuralNetFit, StandardizeRadiances
d92 1
d120 1
d125 1
d132 1
d218 3
d308 6
a313 2
    firstProfile = L1MAFToL2Profile ( Chunk%firstMAFIndex, FileDatabase, MIF=36 )
    lastProfile  = L1MAFToL2Profile ( Chunk%lastMAFIndex , FileDatabase, MIF=36 )
d317 1
d329 1
d333 2
d336 1
d359 1
d361 1
a361 1
          call outputNamedValue ( 'latitude', measurements%quantities(j)%template%Phi(1,MAF) )
d363 1
a363 1
          call outputNamedValue ( 'geodLat', measurements%quantities(j)%template%GeodLat(1,MAF) )
d374 1
a374 1
            & Coeffs%MIFs, Coeffs%Channels_In_Each_Band, MAF )
a383 2
          print *, 'thisProfile, thisMAF, thisBin ', &
            & thisprofile, thisMAF, binNum
d388 5
d401 1
a401 1
          & RadfileID, TempFileID, thisMAF, thisProfile )
d406 63
a468 3
        call Dump ( Temperature%values(:, profile), 'Temps (nn)' )
      enddo
    enddo
d487 1
d496 1
a499 1
    stop
d532 1
a532 1
             & radiances, signal, MIFs, ChannelNums, MAF )
d541 1
d547 1
a547 1
      logical, parameter              :: DeeBug = .true.
d597 2
a598 1
      & MustAllocate )
d606 1
d615 1
d621 3
a623 1
      print *, 'Now in ReadCoeffsFile'
d631 1
a631 1
        print *, 'Allocating ..'
d709 1
a709 1
      print *, 'Channels in each band'
d732 1
a732 1
      print *, 'Intercepts_Hidden_Labels_Layer'
d741 1
a741 1
      print *, 'Intercepts_Hidden_Labels_Layer'
d752 1
a752 1
      print *, 'Loaded Intercepts_Hidden_Layer_1'
d766 1
a766 1
      print *, 'Loaded Intercepts_Hidden_Layer_2'
d780 1
a780 1
      print *, 'Standardization_Brightness_Temperatures_Mean'
d789 1
a789 1
      print *, 'Standardization_Brightness_Temperatures_Std'
d800 5
a804 3
      print *, 'Weights_Hidden_Labels_Layer'
      print *, shape(values3)
      print *, shape(Coeffs%Weights_Hidden_Labels_Layer)
d817 1
a817 1
      print *, 'Weights_Hidden_Layer_1'
d828 1
a828 1
      print *, 'Weights_Hidden_Layer_2'
d838 1
a838 1
      print *, 'Normalization_Labels_Max'
d845 1
a845 1
      print *, 'Normalization_Labels_Min'
d872 1
a872 1
       "$Id: NeuralNet_m.f90,v 2.4 2021/03/05 00:55:30 pwagner Exp $"
d884 3
@


2.4
log
@A tiny bit of progress
@
text
@d42 1
d47 13
d81 1
a81 1
  ! The following must someday also be read from the file of n-n coefficients
d300 2
a301 2
    firstProfile = L1MAFToL2Profile ( Chunk%firstMAFIndex, FileDatabase )
    lastProfile  = L1MAFToL2Profile ( Chunk%lastMAFIndex , FileDatabase )
d311 2
d331 1
a331 1
        thisMAF = L2ProfileToL1MAF ( thisProfile, fileDatabase )
d339 1
a339 1
          call Dump ( measurements%quantities(j)%template )
d342 4
a345 1
          print *, 'Qty radiometer ', measurements%quantities(j)%template%radiometer
d353 1
a353 1
          print *, 'Calling AssembleNNMeasurement'
d366 2
d371 1
a371 1
            & TempFileID, thisMAF)
d464 1
d477 2
a478 1
        
d487 2
d497 2
d558 3
d689 2
d699 2
d782 1
a782 1
       "$Id: NeuralNet_m.f90,v 2.3 2021/02/19 00:28:08 pwagner Exp $"
d794 3
@


2.3
log
@repaired many bugs; still unsatisfactory imo
@
text
@d16 1
d18 1
a18 1
  use HDF, only: Dfacc_Create
d21 1
a21 1
  use MLSFiles, only: MLS_CloseFile, MLS_OpenFile, &
d24 1
a24 1
  use MLSKinds, only: R4, Rv
d31 1
a31 1
    & Dump, NeuralNetFit
d33 1
a33 1
  ! use QuantityTemplates, only: Rt
d75 2
d109 1
d115 1
a126 1
    ! real, dimension(:,:,:), allocatable     :: Coeffs
a128 1
    ! type (NeuralNet_T)              :: MyNeuralNet
d138 4
d158 14
d203 1
a203 1
        print *, 'Skipping non-Temperarture state quantity'
a273 3
      RadiancesFile => AddInitializeMLSFile ( FileDatabase, name=DefaultRadiances, &
        & shortName='Radiances', access=Dfacc_Create,  &
        & type=l_hdf, content='NNRadiances', HDFVersion=HDFVersion_5 )
d275 1
a275 1
    if ( DeeBug ) call Dump ( FileDatabase )
d277 6
a282 2
    call Dump( RadiancesFile )
    call MLS_OpenFile( RadiancesFile, Status )
d285 1
d319 2
d323 1
d325 7
a331 1
          if ( measurements%quantities(j)%template%radiometer /= Temperature%template%radiometer ) cycle
d338 14
a351 1
        end do                          ! End loop over bands
d354 1
d358 2
a359 1
          & Coeffs, NumHiddenLayers, switchOver, RadiancesFile%FileID%f_id )
d364 1
d368 17
d396 1
d472 2
d748 1
a748 1
       "$Id: NeuralNet_m.f90,v 2.2 2021/02/05 05:16:37 pwagner Exp $"
d760 3
@


2.2
log
@Repaired many errors; others doubtless remain
@
text
@d17 1
d25 1
a25 1
  use MLSSignals_M, only: GetSignalName
d73 1
d90 1
d110 1
d118 1
d128 1
a128 1
      & '/users/fwerner/Documents/database/trained_neural_nets/temperature/v1.13/1/' &
d130 5
a134 1
      & 'Temperature_trained_neural_net.h5'
d149 1
d191 13
a203 2
      if ( measurements%quantities(j)%template%quantityType /= l_radiance ) cycle
      if ( measurements%quantities(j)%template%radiometer /= Temperature%template%radiometer ) cycle
d210 2
d218 2
d226 2
a229 1
        
d233 5
d241 6
d253 3
d259 2
d267 1
d278 2
a279 1
        & Coeffs ) ! Should be & MyNeuralNet
d304 2
a305 1
            & radiances, signal, Coeffs%MIFs, MAF )
d309 8
a316 2
        Temperature%values(:, profile) = NeuralNetFit ( NNMeasurements, &
          & Coeffs, NumHiddenLayers, switchOver )
d363 1
a363 1
             & radiances, signal, MIFs, MAF )
d370 1
d374 1
d384 1
d386 1
a386 1
              & radiances%value3(channel, MIFs(MIF), MAF)
d393 1
d395 1
a395 1
              & radiances%value3(channel, MIFs(MIF), MAF)
d401 1
d403 1
a403 1
              & radiances%value3(channel, MIFs(MIF), MAF)
d418 2
a419 1
      & Coeffs )
d426 1
d434 2
a435 1
      integer, dimension(:), allocatable      :: MIFs
d446 21
a466 12
      ! Allocate the fields of our datatype to be read
      allocate ( Coeffs%Intercepts_Hidden_Layer_1(5078) )
      allocate ( Coeffs%Intercepts_Hidden_Layer_2(5078) )
      allocate ( Coeffs%Weights_Hidden_Labels_Layer(5078, 42) )
      allocate ( Coeffs%Weights_Hidden_Layer_1     (7575, 5078) )
      allocate ( Coeffs%Weights_Hidden_Layer_2     (5078, 5078) )
      allocate ( Coeffs%Normalization_Labels_Max(42) )
      allocate ( Coeffs%Normalization_Labels_Min(42) )
      allocate ( Coeffs%Standardization_Brightness_Temperature_Mean(7575) )
      allocate ( Coeffs%Standardization_Brightness_Temperature_Std (7575) )
      allocate ( Coeffs%MIFs(75) )
      allocate ( Coeffs%Bands(3) )
d486 1
a486 1
      allocate( MIFs(75) )
d489 1
a489 1
        & MIFs )
d491 33
a523 1
          MIFs
d525 1
d548 9
d572 1
a572 1
!           values1(:)
d680 1
a680 1
       "$Id: NeuralNet_m.f90,v 2.1 2021/01/22 00:22:18 pwagner Exp $"
d692 3
@


2.1
log
@First commit
@
text
@d19 4
a22 3
  use MLSFiles, only: MLS_CloseFile, MLS_OpenFile
  use MLSFinds, only: FindFirst
  use MLSKinds, only: Rv
d24 1
d26 1
d28 2
a29 1
  ! use NeuralNetUtils_m, only: NeuralNet_T, RunNeuralNet
d31 2
a32 2
  use QuantityTemplates, only: Rt
  use String_Table, only: Display_String, Get_String
d50 1
a50 1
! NeuralNet          Given a measurement vector and file of coefficients
d61 1
a61 1
  character (len=*), private, parameter :: ModuleName= "$RCSfile: Fill.f90,v $"
d65 7
a71 1
  logical, parameter :: countEmpty = .true. ! Except where overriden locally
d79 1
a79 1
    use Init_Tables_Module, only: L_Temperature, L_Radiance
d99 2
a100 2
    real(rt):: MaxLat
    real(rt):: MinLat
d105 1
d117 3
a119 1
    real, dimension(:,:,:), allocatable     :: Coeffs
d131 1
a131 1
    real(rt), dimension(NumBins), parameter :: BinArray = &
d134 1
a134 1
    real(rt), parameter             :: BinSz = 10.
d137 1
a137 1
    DEEBUG = LetsDebug ( 'neu', 0 )
d156 1
d158 3
d162 1
a162 2
    end if
    myFile =  FileNameToID( trim(filename), FileDataBase ) 
d170 4
a173 2
        call announce_error ( key, &
          & "state vector must contain only Temperature" )
d185 23
d210 8
a217 1
    CoeffsFile => FileDatabase(myFile)
d223 2
d229 4
a232 2
    firstBin = FindFirst ( BinArray - minLat > 0._rt )
    lastBin  = FindFirst ( BinArray - maxLat > 0._rt )
d239 2
d250 2
d258 3
a260 3
!           call AssembleNNMeasurement ( NNMeasurements, &
!             & radiances%value3(:,:,MAF), &
!             & MyNeuralNet )
d262 4
a265 1
!         call RunNeuralNet ( NNMeasurements, Temperature%values, MyNeuralNet )
d274 1
a274 1
    if ( BeVerbose( 'neu', 0 ) ) then
a293 2
      integer :: I

d311 2
a312 3
    subroutine AssembleNNMeasurements ! ( NNMeasurements, &
!             & radiances%value3(:,:,MAF), &
!             & MyNeuralNet )
d314 38
a351 2
      ! real(rt), allocatable, dimension(:,:) :: NNMeasurements
    end subroutine AssembleNNMeasurements
d356 1
a356 1
      ! real(rt), allocatable, dimension(:,:) :: NNMeasurements
d367 2
a368 1
      real, dimension(:,:,:), allocatable     :: Coeffs
d370 1
d375 5
a379 2
      real(rt), dimension(:,:), allocatable   :: values2
      real(rt), dimension(:,:,:), allocatable :: values3
d381 2
d384 15
a398 2
      allocate ( values2(7575, 1) )
      allocate ( values3(7575, 5078, 1) )
d401 25
a425 1
      start = (/ 1, binNum, 0 /)
d427 1
a427 1
      count = (/ 5078, 1, 0 /)
d429 47
d478 66
a543 2
        & values2, &
        & start(1:2), count(1:2), stride(1:2), block(1:2) )
d570 1
a570 1
       "$Id: NeuralNet_m.f90,v 2.150 2020/01/27 18:03:13 pwagner Exp $"
d582 3
@

