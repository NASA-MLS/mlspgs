head	2.78;
access;
symbols
	v5-02-NRT-19:2.78
	v6-00:2.78
	v5-02-NRT-18:2.78
	v5-02:2.76
	v5-01-NRT-17:2.78
	v5-01-NRT-16:2.78
	v5-01-NRT-15:2.78
	v5-01-NRT-14:2.78
	neuralnetworks-1-0:2.78.0.4
	cfm-single-freq-0-1:2.78.0.2
	v5-01:2.76
	v5-00:2.76
	v4-23-TA133:2.73.0.2
	mus-emls-1-70:2.71.0.4
	rel-1-0-englocks-work:2.71.0.2
	VUMLS1-00:2.67
	VPL1-00:2.67
	V4-22-NRT-08:2.65
	VAM1-00:2.63
	V4-21:2.59.0.2
	V4-13:2.59
	V4-12:2.56
	V4-11:2.55
	V4-10:2.55
	V3-43:2.41
	M4-00:2.46
	V3-41:2.41
	V3-40-PlusGM57:2.41.0.2
	V2-24-NRT-04:2.40
	V3-33:2.41
	V2-24:2.40
	V3-31:2.41
	V3-30-NRT-05:2.41
	cfm-01-00:2.41
	V3-30:2.41
	V3-20:2.41
	V3-10:2.41
	V2-23-NRT-02:2.40
	V2-23:2.40
	V2-22-NRT-01:2.40
	V2-22:2.40
	V2-21:2.35
	V2-20:2.35
	V2-11:2.35
	V2-10:2.35
	V2-00:2.33
	V1-51:2.26
	V1-50:2.26
	V1-45:2.25
	V1-44:2.25
	V1-43:2.22
	V1-32:2.21
	V1-31:2.19
	V1-30:2.15
	V1-13:2.13
	V1-12:2.13
	V1-11:2.13
	V1-10:2.12
	newfwm-feb03:2.12.0.2
	V1-04:2.6
	V1-03:2.6
	V1-02:2.6
	JointForwardModel:2.6.0.2
	V1-00:2.6;
locks; strict;
comment	@# @;


2.78
date	2020.07.29.23.35.01;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2020.04.30.23.31.09;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2019.09.19.16.10.28;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2019.09.05.17.52.54;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2019.07.17.20.21.11;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2018.10.27.01.20.08;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2018.09.13.20.27.46;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2018.03.14.22.16.43;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2017.11.30.20.52.08;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2017.11.15.00.18.11;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2017.10.18.00.01.08;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2016.07.28.01.44.41;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2016.05.27.00.06.14;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2016.05.19.23.22.58;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2015.10.13.23.50.05;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2015.09.17.23.18.28;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2015.09.10.17.50.35;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2015.07.16.22.11.24;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2015.05.06.20.48.14;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2014.09.29.20.50.03;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2014.08.12.23.29.40;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2014.08.06.23.33.18;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2014.06.25.20.43.25;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2014.04.10.00.44.21;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2013.11.20.00.58.08;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2013.11.18.22.26.07;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2013.06.14.18.49.46;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2013.06.13.00.43.08;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2013.06.12.02.37.49;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2013.05.17.00.53.57;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2013.04.05.23.26.04;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2013.02.04.22.02.28;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2012.07.02.20.33.41;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2012.06.27.18.00.34;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2012.04.26.23.14.30;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2007.09.06.23.32.47;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2007.08.31.00.04.06;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2007.08.13.17.40.55;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2007.06.21.00.54.08;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2007.06.04.23.24.46;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2006.07.21.20.11.54;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2006.06.24.23.10.17;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2006.06.12.18.44.25;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2006.03.04.00.16.38;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2006.02.16.00.12.02;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2006.02.10.21.11.29;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2006.01.06.01.15.32;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2005.09.22.23.39.38;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2004.12.14.21.40.20;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2004.08.16.17.13.06;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2004.08.04.23.19.58;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2004.06.29.00.08.41;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2004.05.06.20.42.24;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2004.02.10.19.26.23;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2004.01.14.18.49.58;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2003.12.05.00.50.44;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2003.10.23.22.20.16;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2003.10.22.21.19.14;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2003.10.20.18.21.45;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2003.08.11.23.24.48;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2003.06.09.22.51.36;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2003.02.27.21.56.07;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2002.10.08.17.36.22;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2002.09.24.18.15.12;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2002.09.19.19.07.05;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2002.09.18.23.56.01;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2002.07.23.00.06.05;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2002.07.22.22.53.10;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2001.11.27.23.34.49;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.10.01.23.30.50;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2001.10.01.22.54.22;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.09.28.23.59.20;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2001.09.28.17.50.30;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.78
log
@Attempt to keep closer track of maximumMemory used
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module MLSL2Timings              !  Timings for the MLSL2 program sections
!=============================================================================

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, FinalMemoryReport
  use Call_Stack_M, only: Sys_Memory_Ch, Sys_Memory_Convert, Sys_Memory_Max
  use HighOutput, only: Banner, BeVerbose, OutputNamedValue
  use Init_Tables_Module, only: F_Additional, F_Debug, F_Options, F_Reset, &
    & F_Silent, F_Skipdirectwrites, F_Skipdirectwritesif, &
    & F_Skipretrieval, F_Skipretrievalif, F_Stamp, F_Verbose, &
    & Field_First, Field_Last
  use Intrinsic, only: L_Hours, L_Minutes, L_Seconds
  use L2Parinfo, only: Parallel
  use MLSCommon, only: MLSDebug, MLSVerbose, &
    & MLSDebugSticky, MLSVerboseSticky
  use MLSL2Options, only: L2Options, OriginalOptions, &
    & DumpOptions, DumpMacros, &
    & ProcessOptions, RestartWarnings, RestoreDefaults, RuntimeValues, &
    & SectionTimingUnits, SkipDirectwrites, SkipDirectwritesOriginal, &
    & StopAfterSection
  use MLSMessageModule, only: MLSMessageConfig, MLSMessage, MLSMessageReset, &
    & MLSMSG_Error
  use MLSStrings, only: Lowercase
  use MLSStringLists, only: BooleanValue, Catlists, GetStringElement, &
    & NumStringElements, StringElementNum, SwitchDetail
  use MoreTree, only: Get_Boolean
  use Output_M, only: StampOptions, Blanks, IsOutputSuspended, NewLine, &
    & Output, RestoreSettings, ResumeOutput, SuspendOutput
  use String_Table, only: Get_String
  use Time_M, only: Time_Now
  use Toggles, only: Switches
  use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree

  implicit none

  public :: Section_times, total_times, &
    &       Add_to_directwrite_timing, &
    &       Add_to_retrieval_timing, Add_to_section_timing, &
    &       Addphasetophasenames, &
    &       Dump_section_timings, Run_start_time
  public :: Finishtimings, Filltimings, Restarttimings
  public :: Showtimingnames
  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: MLSL2Timings.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -
!
!     (Data)
! run_start_time         The starting point in calculating timings;
!                          can be reset by call to restartTimings
! section_times          Show times in each section
! total_times            Show total times from start
!
!     (subroutines and functions)
! add_to_directwrite_timing  
!                        Contribute latest directwrite times to totals
! add_to_retrieval_timing 
!                        Contribute latest retrieval times to totals
! add_to_section_timing 
!                        Contribute latest section times to totals
! addPhaseToPhaseNames   Process the phase specification statement of the l2cf
! dump_section_timings   dump accumulated elapsed timings with detailed breakdown
! finishTimings          Finish accumulating timings
! fillTimings            Return accumulated timings in array
! restartTimings         Zero out accumulating timings; reinitialize flags,
!                          run_start_time
! showTimingNames        Return list of phase names, section names, or both
! === (end of toc) ===

! === (start of api) ===
! add_to_directwrite_timing ( char* section_name, real t1 )
! add_to_retrieval_timing ( char* section_name, real t1 )
! add_to_section_timing ( char* section_name, real t1, [log now_stop] )
! addPhaseToPhaseNames ( int name, int root )
! dump_section_timings
! finishTimings ( char* which, [int returnStatus] )
! fillTimings ( num timings(:), char* which, char* names, [log othersToo] )
! restartTimings ( char* which )
! char* showTimingNames ( char* which, [log othersToo] )
! === (end of api) ===

  interface filltimings
    module procedure filltimings_single
    module procedure filltimings_double
  end interface
  
  ! This module simply contains initial settings and accumulated values.

  ! The following public settings are stored here; they may be set by MLSL2
  logical          :: SECTION_TIMES = .false.  ! Show times in each section
  logical          :: TOTAL_TIMES = .false.    ! Show total times from start
  logical, save    :: FINISHEDPHASETIMES = .false.  ! times in each phase done
  logical, save    :: FINISHEDSECTIONTIMES = .false.  ! times in each section done

  logical, private   :: COUNTEMPTY = .false.     ! Any sections named ' '?
  ! dimension of the following is big enough to allow adding unknown
  ! section names and unknown retrieval names
  integer, parameter :: MAXNUMSECTIONTIMES = 60
  integer, parameter :: SECTIONNAMELEN = 32
  integer, parameter :: MAXNUMPHASES = 40
  integer, parameter :: PHASENAMESLEN = MAXNUMPHASES*SECTIONNAMELEN
  ! The next two are no longer parameters, instead calculated whenever needed
  ! (someday Fortran may allow me to call procedures during initializing)
  integer :: num_section_times ! = NumStringElements(section_names, countEmpty)
  integer :: num_retrieval_times ! = NumStringElements(retrieval_names, countEmpty)

  character(len=*), parameter        :: section_names = &
    & 'main,open_init,global_settings,signals,spectroscopy,' // &
    & 'read_apriori,merge_grids,chunk_divide,construct,fill,retrieve,join,' // &
    & 'directwrite,algebra,output,master'

  character(len=*), parameter        :: retrieval_names = &
    & 'newton_solver,cholesky_factor,cholesky_solver,cholesky_invert,' // &
    & 'baseline,hybrid,polar_linear,switching_mirror,' // &
    & 'full_fwm,fullcloud_fwm,scan_fwm,twod_scan_fwm,linear_fwm,' // &
    & 'low_cloud,high_cloud,sids,form_normeq,tikh_reg'

  character(len=*), parameter        :: directwrite_names = &
    & 'writing,waiting'
  ! This should be the number of elements in the above ----------------
  integer, parameter                 :: num_directwrite_times = 2  ! <--|
  real, dimension(MAXNUMSECTIONTIMES), &
    & save                           :: section_timings = 0.
  character(len=PHASENAMESLEN), save :: phaseNames = ' '
  integer, save :: num_phases = 0
  real, dimension(MAXNUMPHASES), save :: phase_memory = 0.
  real, dimension(MAXNUMPHASES), save :: phase_timings = 0.
  real, public, save :: ChunkMemoryMax = 0.
  real, save :: run_start_time = 0.
  integer, parameter :: MAXNAMESLENGTH = PHASENAMESLEN+LEN(section_names)

contains ! =====     Public Procedures     =============================

  ! -----------------------------------------  add_to_directwrite_timing  -----
  subroutine add_to_directwrite_timing( section_name, t1 )
  ! Add current elapsed directwrite section time to total so far for section_name

  ! Formal arguments
    character(len=*), intent(in):: section_name   ! One of the dw. sect_names
    real, optional, intent(inout)  :: t1          ! Prior time_now, then current

  ! Private
    integer                     :: elem
    integer                     :: elem_offset
    real                        :: t2
    real, save                  :: myLastTime = 0.

  ! Executable
      if ( trim(lowercase(section_name)) == 'restart' ) then
        call time_now ( myLastTime )
        return
      endif
      if ( present(t1) ) myLastTime = t1
      num_section_times = NumStringElements(section_names, countEmpty)
      num_retrieval_times = NumStringElements(retrieval_names, countEmpty)
      elem_offset = num_section_times + num_retrieval_times

      elem = StringElementNum(directwrite_names, LowerCase(section_name), countEmpty)
      if ( elem < 1 .or. elem > num_directwrite_times ) then
          call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Unable to find directwrite section name ' // section_name // &
        & ' among list ' // retrieval_names )
      else
        call time_now ( t2 )
        section_timings(elem_offset+elem) = &
          & section_timings(elem_offset+elem) + t2 - myLastTime
      endif
      myLastTime = t2
      if ( present(t1) ) call time_now ( t1 )
  end subroutine add_to_directwrite_timing

  ! -----------------------------------------  add_to_phase_timing  -----
  subroutine add_to_phase_timing( phase_name, t1 )
  ! Add current elapsed phase time to total so far for last phase

  ! Method:
  ! (1) If phase is not one we've seen before (among stored phaseNames)
  !     let it augment phaseNames
  ! (2) Compute elapsed time (using either arg t1 or stored lastTime)
  ! (3) Add elapsed time to amount for last phase name (unless 1st phase ever)
  ! Formal arguments
    character(len=*), intent(in):: phase_name   ! One of the phases, e.g. 'core'
    real, optional, intent(inout)  :: t1        ! Prior time_now, then current

  ! Private
    integer                     :: elem
    integer, save               :: myLastElem = 0
    real                        :: t2
    real, save                  :: myLastTime = 0.

    ! Executable
      if ( trim(lowercase(phase_name)) == 'restart' ) then
        call time_now ( myLastTime )
        myLastElem=0
        return
      endif
      if ( present(t1) ) myLastTime = t1
      elem = StringElementNum(LowerCase(trim(phaseNames)), &
        & LowerCase(phase_name), countEmpty)
      if ( elem < 1 .and. phase_name /= ' ' ) then
        num_phases = num_phases + 1
        if ( num_phases > MAXNUMPHASES ) &
          & call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Too many phases--unable add to phase name ' // phase_name // &
          & ' to list ' // trim(phaseNames) )
        phaseNames = catLists(trim(phaseNames), trim(phase_name))
        elem = num_phases
      endif
      call time_now ( t2 )
      if ( myLastElem > 0 ) then
        phase_timings(myLastElem) = &
          & phase_timings(myLastElem) + t2 - myLastTime
        phase_memory(myLastElem) = max( phase_memory(myLastElem), sys_memory_max )
      endif
      ChunkMemoryMax = max( ChunkMemoryMax, sys_memory_max )
      myLastTime = t2
      myLastElem = elem
      if ( present(t1) ) call time_now ( t1 )
      if ( len_trim(phase_name) < 1 ) return
      select case ( switchDetail(switches, 'phase') )
      case ( 0 )
        call announce_phase(trim(phase_name))
      case ( 1: )
        call banner( 'Beginning phase ' // trim(phase_name) ) 
      end select
  end subroutine add_to_phase_timing

  ! -----------------------------------------  add_to_retrieval_timing  -----
  subroutine add_to_retrieval_timing( section_name, t1 )
  ! Add current elapsed retrieval section time to total so far for section_name

  ! Formal arguments
    character(len=*), intent(in):: section_name   ! One of the retr. sect_names
    real, optional, intent(inout)  :: t1          ! Prior time_now, then current

  ! Private
    integer                     :: elem
    real                        :: t2
    real, save                  :: myLastTime = 0.

  ! Executable
      if ( trim(lowercase(section_name)) == 'restart' ) then
        call time_now ( myLastTime )
        return
      endif
      if ( present(t1) ) myLastTime = t1

      num_section_times = NumStringElements(section_names, countEmpty)
      num_retrieval_times = NumStringElements(retrieval_names, countEmpty)
      elem = StringElementNum(retrieval_names, LowerCase(section_name), countEmpty)
      if ( elem < 1 .or. elem > num_retrieval_times ) then
          call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Unable to find retrieval section name ' // section_name // &
        & ' among list ' // retrieval_names )
      else
        call time_now ( t2 )
        section_timings(num_section_times+elem) = &
          & section_timings(num_section_times+elem) + t2 - myLastTime
      endif
      myLastTime = t2
      if ( present(t1) ) call time_now ( t1 )
  end subroutine add_to_retrieval_timing

  ! -----------------------------------------------  add_to_section_timing  -----
  subroutine add_to_section_timing( section_name, t1, now_stop )
  ! Add current elapsed section time to total so far for section_name
  ! (or possibly, one of the retrieval sections)

  ! Formal arguments
    character(len=*), intent(in):: section_name   ! One of the section_names
    real, optional, intent(inout)  :: t1          ! Prior time_now, then current
    logical, intent(out), optional :: now_stop

  ! Private
    integer                     :: elem
    real                        :: t2
    real, save                  :: myLastTime = 0.

  ! Executable
      if ( trim(lowercase(section_name)) == 'restart' ) then
        call time_now ( myLastTime )
        return
      endif
    if ( present(t1) ) myLastTime = t1
    num_section_times = NumStringElements(section_names, countEmpty)
    num_retrieval_times = NumStringElements(retrieval_names, countEmpty)
    elem = StringElementNum(section_names, LowerCase(section_name), countEmpty)
    if ( elem < 1 .or. elem > num_section_times ) then
      print *, 'elem ', elem
      print *, 'num_section_times ', num_section_times
      call MLSMessage ( MLSMSG_Error, moduleName, &
      & 'Unable to find section name ' // section_name // &
      & ' among list ' // section_names // ',' // retrieval_names )
    else
      call time_now ( t2 )
      section_timings(elem) = section_timings(elem) + t2 - myLastTime
    endif
    myLastTime = t2
    if ( present(t1) ) call time_now ( t1 )
    if ( present(now_stop) ) then
      now_stop = ( lowerCase(section_name) == lowercase(stopAfterSection) )
      if ( len_trim(stopAfterSection) > 0 .and. MLSverbose ) then
        print *, trim(stopAfterSection), ' is section to stop after'
        print *, trim(section_name), ' is section we just finished'
        print *, ' Stop now? ', now_stop
      endif
      if ( now_stop ) call Banner ( '** Stopping after ' // &
      & trim(section_name) // ' as requested **' )
    endif
  end subroutine add_to_section_timing

  ! -----------------------------------  addPhaseToPhaseNames  -----
  ! Process the phase specification statement of the l2cf
  ! In particular, set up an entry in the phase names database
  ! to hold timing info
  ! set options controllable by runtime flags, like whether
  ! to skip retrievals, skip directwrites, verboseness, etc.
  
  ! This may be called in response to either
  ! name: phase, ..
  ! or
  ! changeSettings, ..
  subroutine addPhaseToPhaseNames ( name, root )
    ! Dummy arguments
    integer, intent(in) :: NAME               ! String index of name
    integer, intent(in) :: ROOT               ! Root of phase subtree
    ! Local variables
    logical :: additional
    logical :: debug
    integer :: detail
    integer :: field
    integer :: field_index
    integer :: fieldValue
    logical, dimension(field_first:field_last) :: GOT
    ! integer :: interval
    integer :: keyNo
    logical, save :: LASTPHASEOVERWROTEOPTS = .false.
    character(len=1) :: null
    character(len=128) :: OPTIONS
    character(len=80) :: PHASESTRING    ! E.g., 'Core'
    character(len=80) :: BOOLEANSTRING  ! E.g., 'BAND13_OK'
    character(len=8)  :: CHUNKSTRING  ! E.g., '257'
    logical :: reset
    logical :: silent
    integer :: son
    logical :: stamp
    logical :: verbose
    ! Executable
    L2Options = OriginalOptions ! Restore Original Options
    additional = .false.
    detail = switchDetail( switches, 'phase' )
    null = achar(0)
    reset = .false.
    silent = .false.
    stamp = detail > 1 ! E.g., -Sphase2; was .false.
    skipDirectwrites = skipDirectWritesoriginal
    ! skipRetrieval = skipRetrievalOriginal
    options = ' '
    Phasestring = ' '
    Chunkstring = ' '
    got= .false.
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
      field_index = decoration(field)
      got(field_Index) = .true.
      select case ( field_index )
      case ( f_additional )
        additional = get_boolean ( fieldValue )
      case ( f_debug )
        debug = get_boolean ( fieldValue )
        if ( stamp ) call output( 'Processing debug field', advance='yes' )
      case ( f_options )
        call get_string ( sub_rosa(subtree(2,son)), options, strip=.true. )
      case ( f_reset )
        reset = get_boolean ( fieldValue )
      case ( f_silent )
        silent = get_boolean ( fieldValue )
      case ( f_skipDirectwrites )
        skipDirectwrites = skipDirectWritesOriginal .or. &
          & get_boolean ( fieldValue )
      case ( f_skipDirectwritesif )
        call get_string( sub_rosa(subtree(2,son)), booleanString )
        if ( stamp ) call output( 'told to skipDirectwrites: ', advance='no' )
        if ( stamp ) call output( BooleanValue ( lowercase(booleanString), &
          & runTimeValues%lkeys, runTimeValues%lvalues, runTimeValues%sep ), &
          advance='yes' )
        skipDirectwrites = skipDirectWritesOriginal .or. &
          & BooleanValue ( lowercase(booleanString), &
          & runTimeValues%lkeys, runTimeValues%lvalues, runTimeValues%sep )
        call output( 'skipDirectwrites: ', advance='no' )
        call output( skipDirectwrites, advance='yes' )
      case ( f_skipRetrieval )
        ! Don't turn retrievals back on if cmdline options said to skip them
        if ( L2Options%SkipRetrievalOriginal ) cycle
        L2Options%SkipRetrieval = get_boolean ( fieldValue )
      case ( f_skipRetrievalif )
        ! Don't turn retrievals back on if cmdline options said to skip them
        if ( L2Options%SkipRetrievalOriginal ) cycle
        call get_string( sub_rosa(subtree(2,son)), booleanString )
        if ( stamp ) call output( 'told to skipRetrieval: ', advance='no' )
        if ( stamp ) call output( BooleanValue ( lowercase(booleanString), &
          & runTimeValues%lkeys, runTimeValues%lvalues, runTimeValues%sep ), &
          & advance='yes' )
        L2Options%SkipRetrieval =  BooleanValue ( lowercase(booleanString), &
          & runTimeValues%lkeys, runTimeValues%lvalues, runTimeValues%sep )
        if ( stamp ) call output( 'skipRetrieval: ', advance='no' )
        if ( stamp ) call output( L2Options%SkipRetrieval, advance='yes' )
        if ( stamp ) call output( trim(booleanString), advance='yes' )
      case ( f_stamp )
        stamp = stamp .or. get_boolean ( fieldValue )
      case ( f_verbose )
        verbose = get_boolean ( fieldValue )
        if ( stamp ) call output( 'Processing verbose field', advance='yes' )
      case default ! Can't get here if tree_checker works correctly
      end select
    end do
    if ( name > 0 ) then
      call get_string(name, phaseString)
      L2Options%CurrentPhaseName = phaseString
    endif
    ! Restore settings if last one overwrote them (unless additional)
    if ( LASTPHASEOVERWROTEOPTS .and. .not. additional ) then
      call restoredefaults
      booleanstring = processOptions( trim( L2Options%Originalcmds ), null )
      MLSDebugSticky = .false.
      MLSVerboseSticky = .false.
      call output( 'Restoring default command-line args', advance='yes' )
      call outputNamedValue( 'command_line', trim(L2Options%Command_line) )
      call outputNamedValue( 'Switches', trim(Switches) )
    endif
    ! Does this phase overwrite settings?
    LASTPHASEOVERWROTEOPTS = .false. ! If not, we won't need to restore them next time
    if ( options /= ' ' ) then
      booleanstring = processOptions( trim(options ) )
      LASTPHASEOVERWROTEOPTS = .true.
      call output( 'Overwriting default command-line args', advance='yes' )
      call outputNamedValue( 'command_line', trim(L2Options%Command_line) )
      call outputNamedValue( 'Switches', trim(Switches) )
    endif
    if( got(f_debug) ) then
      MLSDebug = debug
      MLSDebugSticky = .true.
      LASTPHASEOVERWROTEOPTS = .true.
    endif
    if( got(f_additional) ) then
      LASTPHASEOVERWROTEOPTS = .false.
    endif
    if( got(f_verbose) ) then
      MLSVerbose = verbose
      MLSVerboseSticky = .true.
      LASTPHASEOVERWROTEOPTS = .true.
    endif
    
    if ( RESTARTWARNINGS .and. name > 0 ) call MLSMessageReset( Warnings=.true. )
    ! This will cause Warnings and Errors to print the phase name
    ! where they occurred
    ! and, if we're a slave, the Chunk number
    if ( parallel%slave .and. .not. parallel%fwmParallel ) then
      write(chunkString, '(i3)') parallel%ChunkNo
      MLSMessageConfig%Info = trim(phaseString) // ' (' // &
        & trim(adjustl(chunkString)) // ') '
    elseif ( name > 0 ) then
      MLSMessageConfig%Info = phaseString
    endif
    if ( name > 0 ) MLSMessageConfig%Warning = MLSMessageConfig%Info
    if ( silent ) then
      call suspendOutput
    else
      call resumeOutput
    endif

    if ( .not. got(f_stamp) ) then
      ! No stamp, no separate headline
    elseif ( detail < 2 ) then
      StampOptions%interval = 25 ! print a separate headline once every 25 lines
    elseif ( detail < 3 ) then
      ! -Sphase2
      StampOptions%interval = 10 ! print a separate headline once every 10 lines
    else
      ! -Sphase3 or more
      StampOptions%interval = 1 ! stamp every line with time, phase name
    endif

    If ( reset ) OriginalOptions = L2Options ! Make these Original Options
    if ( BeVerbose('opt', -1) .and. .not. IsOutputSuspended() ) &
      & call DumpOptions
    
    if ( name < 1 ) return
    if ( got(f_stamp) ) then
      stampOptions%neverStamp = .false.
      stampOptions%textCode = ': : ' // trim(phaseString) // ' : :'
    else
      call restoreSettings( 'stamp' )
    endif
    call add_to_phase_timing( trim(phaseString) )
    call FinalMemoryReport
    ChunkMemoryMax = max( ChunkMemoryMax, sys_memory_max )
    call outputNamedValue( 'Resetting to 0 sys_memory which was', sys_memory_max )
    sys_memory_max     = 0.0
    if ( switchDetail ( switches, 'bool' ) > 0 ) &
      & call dumpMacros
  end subroutine addPhaseToPhaseNames

  ! -----------------------------------------------  dump_section_timings  -----
  subroutine dump_section_timings
  ! (1)dump accumulated elapsed timings for section_names
  ! (2) breakdown timings by subsection in retrieve, directwrite
  ! (3) breakdown timings by phase
  ! (4) print sys memory usage by phase and overall
  ! Private
    character(len=*), parameter     :: TIMEFORMSMALL = '(F10.2)'
    character(len=*), parameter     :: TIMEFORMBIG = '(1PE10.2)'
    character(len=*), parameter     :: PCTFORM='(F10.0)'
    logical, parameter              :: PRINTCHUNKNUMWITHPHASES=.true.
    integer                         :: elem
    integer                         :: retrElem
    character(LEN=16)               :: section_name   ! One of the section_names
    real                            :: final
    real                            :: total
    real                            :: retrFinal
    real                            :: retrTotal
    real                            :: dwFinal
    real                            :: dwTotal
    real                            :: maximumMemory
    real                            :: phaseTotal
    real                            :: percent
    real                            :: elem_memory
    real                            :: elem_time
    character(len=len(timeformbig)) :: memoryForm
    character(len=len(timeformbig)) :: timeForm
    integer                         :: timeDivisor

  ! Executable
    num_section_times = NumStringElements(section_names, countEmpty)
    num_retrieval_times = NumStringElements(retrieval_names, countEmpty)
    select case ( sectionTimingUnits )
    case ( l_seconds )
      timeDivisor = 1
    case ( l_minutes )
      timeDivisor = 60
    case ( l_hours )
      timeDivisor = 3600
    case default
      call output ( 'Unrecognized section timing unit : ', advance='no' )
      call output ( sectionTimingUnits, advance='yes' )
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Should be among list l_(seconds, minutes, hours)' )
    end select
    call output ( '==========================================', advance='yes' )
    call blanks ( 8, advance='no' )
    call output ( 'Level 2 section timings : ', advance='yes' )
    call blanks ( 8, advance='no' )
    call printTaskType
    call output ( '==========================================', advance='yes' )
    call output ( 'section name ', advance='no' )
    call blanks ( 8, advance='no' )
    call output ( 'time ', advance='no' )
    call blanks ( 8, advance='no' )
    call output ( 'percent ', advance='yes' )
    call finishTimings('sections')
    total = sum(section_timings(1:num_section_times)) ! + &

    call time_now ( final )
    final = max(final-run_start_time, total)
    if ( final/timeDivisor <= 0.0 ) final = 1.0       ! Just so we don't divide by 0
    if ( final/timeDivisor < 0.5 .or. final/timeDivisor > 99999.99 ) then
      TIMEFORM = TIMEFORMBIG
    else
      TIMEFORM = TIMEFORMSMALL
    endif
    if ( sys_memory_convert*maxval(phase_memory) > 99999.99 ) then
      memoryForm = timeFormBig
    else
      memoryForm = timeFormSmall
    endif
    do elem = 1, num_section_times
      elem_time = section_timings(elem)
      call GetStringElement(section_names, section_name, elem, countEmpty)
      if ( section_name == 'master' .and. .not. parallel%master ) cycle
      percent = 100 * elem_time / final
      call output ( section_name, advance='no' )
      call blanks ( 2, advance='no' )
      call output ( elem_time/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
      call blanks ( 2, advance='no' )
      call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
    enddo
    call output ( '==========================================', advance='yes' )
    percent = 100 * total / final
    call blanks ( 2, advance='no' )
    call output ( '(subtotal)', advance='no' )
    call blanks ( 5, advance='no' )
    call output ( total/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
    call blanks ( 2, advance='no' )
    call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
    percent = 100 * (final-total) / final
    call blanks ( 3, advance='no' )
    call output ( '(others)', advance='no' )
    call blanks ( 6, advance='no' )
    call output ( (final-total)/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
    call blanks ( 2, advance='no' )
    call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
    call output ( '==========================================', advance='yes' )
    percent = 100
    call blanks ( 4, advance='no' )
    call output ( '(final)', advance='no' )
    call blanks ( 6, advance='no' )
    call output ( final/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
    call blanks ( 2, advance='no' )
    call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='no' )
    call blanks ( 4, advance='no' )
    call printTaskType
    ! Subdivision of Retrieval section
    if ( STOPAFTERSECTION /= ' ' ) then
      call output ( '(Some sections skipped) ', advance='yes' )
      return
    endif
    retrElem = StringElementNum(section_names, 'retrieve', countEmpty)
    if ( retrElem == 0 ) then
      call output ( '(Illegal section name--spelling?) ', advance='yes' )
      return
    endif
    retrFinal = section_timings(retrElem) 
    if ( L2Options%SkipRetrieval ) then
      call output ( '(Retrieval section skipped) ', advance='yes' )
    elseif ( retrFinal == 0.0 ) then
      call output ( '(Retrieval section number ', advance='no' )
      call blanks ( 2, advance='no' )
      call output ( elem, advance='no' )
      call blanks ( 2, advance='no' )
      call output ( 'time ', advance='no' )
      call blanks ( 2, advance='no' )
      call output ( retrFinal, advance='yes' )
      call output ( '(No Retrieval section timings breakdown) ', advance='yes' )
    else
      call output ( '==========================================', advance='yes' )
      call blanks ( 8, advance='no' )
      call output ( 'Retrieval section timings : ', advance='yes' )
      call output ( '==========================================', advance='yes' )
      call output ( 'subsection name ', advance='no' )
      call blanks ( 8, advance='no' )
      call output ( 'time ', advance='no' )
      call blanks ( 2, advance='no' )
      call output ( 'percent of total retrieval time', advance='yes' )
      retrTotal = sum(section_timings(1+num_section_times:num_section_times+num_retrieval_times)) ! - &
      do elem = 1, num_retrieval_times  ! num_elems
          elem_time = section_timings(num_section_times+elem)
          call GetStringElement(retrieval_names, section_name, elem, countEmpty)
        percent = 100 * elem_time / retrFinal
        call output ( section_name, advance='no' )
        call blanks ( 2, advance='no' )
        call output ( elem_time/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
        call blanks ( 2, advance='no' )
        call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
      enddo
      call blanks ( 3, advance='no' )
      call output ( '(others)', advance='no' )
      call blanks ( 6, advance='no' )
      call output ( (retrFinal-retrTotal)/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
      call blanks ( 2, advance='no' )
      call output ( 100*(retrFinal-retrTotal)/retrFinal, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
    endif

    ! Subdivision of DirectWrite section
    elem = StringElementNum(section_names, 'directwrite', countEmpty)
    if ( elem == 0 ) then
      call output ( '(Illegal section name--spelling?) ', advance='yes' )
      return
    endif
    dwFinal = section_timings(elem) 
    if ( SKIPDIRECTWRITES ) then
      call output ( '(DirectWrite section skipped) ', advance='yes' )
    elseif ( dwFinal == 0.0 ) then
      call output ( '(DirectWrite section number ', advance='no' )
      call blanks ( 2, advance='no' )
      call output ( elem, advance='no' )
      call blanks ( 2, advance='no' )
      call output ( 'time ', advance='no' )
      call blanks ( 2, advance='no' )
      call output ( dwFinal, advance='yes' )
      call output ( '(No DirectWrite section timings breakdown) ', &
        & advance='yes' )
    else
      call output ( '==========================================', advance='yes' )
      call blanks ( 8, advance='no' )
      call output ( 'DirectWrite section timings : ', advance='yes' )
      call output ( '==========================================', advance='yes' )
      call output ( 'subsection name ', advance='no' )
      call blanks ( 8, advance='no' )
      call output ( 'time ', advance='no' )
      call blanks ( 2, advance='no' )
      call output ( 'percent of total DirectWrite time', advance='yes' )
      dwTotal = sum(section_timings(1+num_section_times+num_retrieval_times:)) 
      do elem = 1, num_directwrite_times
        elem_time = section_timings(num_section_times+num_retrieval_times+elem)
        call GetStringElement(directwrite_names, section_name, elem, countEmpty)
        percent = 100 * elem_time / dwFinal
        call output ( section_name, advance='no' )
        call blanks ( 2, advance='no' )
        call output ( elem_time/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, &
          & advance='no' )
        call blanks ( 2, advance='no' )
        call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
      enddo
      call blanks ( 3, advance='no' )
      call output ( '(others)', advance='no' )
      call blanks ( 6, advance='no' )
      call output ( (dwFinal-dwTotal)/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, &
        & advance='no' )
      call blanks ( 2, advance='no' )
      call output ( 100*(dwFinal-dwTotal)/dwFinal, FORMAT=PCTFORM, &
        & LOGFORMAT=PCTFORM, advance='yes' )
    endif

    ! Subdivision of Phases
    if ( num_phases == 0 ) then
      call output ( '(No phase timings breakdown) ', advance='yes' )
      return
    endif
    call finishTimings('phases')
    ! call dump( phase_timings, 'phase_timings' )
    ! call dump ( sys_memory_convert*phase_memory, sys_memory_ch )
    call output ( '==========================================', advance='yes' )
    call blanks ( 8, advance='no' )
    call output ( 'Phase timings : ', advance='yes' )
    call output ( '==========================================', advance='yes' )
    call output ( 'phase name ', advance='no' )
    call blanks ( 11, advance='no' )
    call output ( 'time ', advance='no' )
    call blanks ( 5, advance='no' )
    call output ( 'pct of total', advance='no' )
    if ( any(phase_memory > 0. ) ) call output ( '  sys_mem max', advance='no' )
    call newLine
    maximumMemory = sys_memory_convert*ChunkMemoryMax ! 0.
    phaseTotal = 0.
    do elem = 1, num_phases
      elem_time   = phase_timings(elem)
      elem_memory = sys_memory_convert*phase_memory(elem)
      call GetStringElement(trim(phaseNames), section_name, elem, countEmpty)
      percent = 100 * elem_time / final
      call output ( section_name, advance='no' )
      call blanks ( 2, advance='no' )
      call output ( elem_time/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
      call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='no' )
      if ( elem_memory > 0. ) then
        call blanks ( 4, advance='no' )
        call output ( elem_memory, FORMAT=MEMORYFORM, LOGFORMAT=MEMORYFORM, advance='no' )
        call blanks ( 1 )
        call output ( sys_memory_ch, advance='no' )
      endif
      if ( PRINTCHUNKNUMWITHPHASES ) then
        call blanks ( 2, advance='no' )
        call printTaskType
      else
        call output ( ' ', advance='yes' )
      endif
      phaseTotal = phaseTotal + elem_time
      maximumMemory = max ( maximumMemory, elem_memory )
    enddo
    call blanks ( 3, advance='no' )
    call output ( '(others)', advance='no' )
    call blanks ( 6, advance='no' )
    call output ( (final-phaseTotal)/timeDivisor, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
    call blanks ( 2, advance='no' )
    call output ( 100*(final-phaseTotal)/final, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
    if ( maximumMemory > 0. ) then
      call output ( 'Maximum memory used ', advance='no' )
      call output ( maximumMemory, advance='no' )
      call blanks ( 1 )
      call output ( sys_memory_ch, advance='no' )
      if ( PRINTCHUNKNUMWITHPHASES ) then
        call blanks ( 2, advance='no' )
        call printTaskType
      else
        call output ( ' ', advance='yes' )
      endif
    endif

    contains
    ! Internal subprograms
    subroutine printTaskType
      if ( parallel%master ) then
        call output ( '(Master Task) ', advance='yes' )
      elseif ( parallel%slave .and. .not. parallel%fwmParallel ) then
        call output ( '(Slave: chunk ', advance='no' )
        call output ( parallel%ChunkNo, advance='no' )
        call output ( ' ) ', advance='yes' )
      else
        call output ( '(Serial Task) ', advance='yes' )
      endif
    end subroutine printTaskType
  end subroutine dump_section_timings

  ! -----------------------------------------  finishTimings  -----
  subroutine finishTimings( which, returnStatus )
  ! Finish accumulating timings
  ! Args
  character(len=*), intent(in) :: which ! phases, sections, or all
  integer, intent(out), optional :: returnStatus ! 0 unless already finished
  ! Internal variables
  logical :: sections, phases
  integer :: dwElem
  integer :: Elem
  integer :: joinElem
  integer :: status
  character(len=32) :: section_name
  ! Executable
  status = 0
  num_section_times = NumStringElements(section_names, countEmpty)
  num_retrieval_times = NumStringElements(retrieval_names, countEmpty)
  ! Do sections, phases, both?
  sections = (StringElementNum('all,both,sections', trim(LowerCase(which)), &
    & countEmpty) > 0)
  phases = (StringElementNum('all,both,phases', trim(LowerCase(which)), &
    & countEmpty) > 0)
  joinElem = StringElementNum(section_names, 'join', countEmpty)
  dwElem = StringElementNum(section_names, 'directwrite', countEmpty)
  if ( sections .and. .not. FINISHEDSECTIONTIMES ) then
    ! A trick:
    ! The DirectWrite section doesn't automatically include the waiting time
    ! (due to lazy coding in Join) so add it in now
    elem = StringElementNum(directwrite_names, 'waiting', countEmpty)
    section_timings(dwElem) = section_timings(dwElem) + &
      & section_timings(num_section_times+num_retrieval_times+elem)
    FINISHEDSECTIONTIMES = .true.
    sections = .false.
    ! Another trick:
    ! Adjust Join section timing to exclude directwrite timings
    ! (otherwise they would be counted twice)
    if ( joinElem > 0 .and. dwElem > 0 ) then
      section_timings(joinElem) = &
      &         section_timings(joinElem) - section_timings(dwElem)
    endif
  endif
  if ( sections ) status = max(status, 1)

  if ( phases .and. .not. FINISHEDPHASETIMES ) then
    ! A trick! Add final elapsed time to last phase
    call add_to_phase_timing(' ')
    FINISHEDPHASETIMES = .true.
    ! print *, 'num_phases: ', num_phases
    do elem = 1, num_phases
      call GetStringElement(trim(phaseNames), section_name, elem, countEmpty)
      ! print *, trim(section_name), phase_timings(elem)
    enddo
    phases = .false.
  endif
  if ( phases ) status = max(status, 1)
  if ( present(returnStatus) ) returnStatus = status
  end  subroutine finishTimings

  ! -----------------------------------------  filltimings_double  -----
  subroutine filltimings_double( timings, which, names, othersToo )
  ! Return accumulated timings in array
  ! Args
  double precision, dimension(:), intent(out) :: timings
  character(len=*), intent(in) :: which      ! 'phase' or 'section'
  character(len=*), intent(in) :: names      ! phase or section names, or 'all'
  logical, intent(in), optional :: othersToo
  ! Internal variables
  real, dimension(:), pointer :: singleTimings
  integer :: timingSize
  ! Executable
  timingSize = size(timings)
  if ( timingSize < 1 ) return
  nullify(singleTimings)
  call Allocate_test ( singleTimings, timingSize, 'singleTimings', ModuleName )
  call filltimings_single( singleTimings, which, names, othersToo )
  timings = singleTimings
  call Deallocate_test ( singleTimings, 'singleTimings', ModuleName )
  end subroutine filltimings_double

  ! -----------------------------------------  filltimings_single  -----
  subroutine filltimings_single( timings, which, names, othersToo )
  ! Return accumulated timings in array
  ! Args
  real, dimension(:), intent(out) :: timings
  character(len=*), intent(in) :: which      ! 'phase' or 'section'
  character(len=*), intent(in) :: names      ! phase or section names, or 'all'
  logical, intent(in), optional :: othersToo
  ! Internal variables
  real :: final, total
  logical :: sections, phases
  integer :: k
  integer :: elem
  integer :: iName
  integer :: numNames
  character(len=MAXNAMESLENGTH) :: myNames
  character(len=SECTIONNAMELEN) :: name      ! will be lower case
  logical :: myOthersToo
  ! Executable
  myOthersToo = .false.
  if ( present( othersToo) ) myOthersToo = othersToo
  num_section_times = NumStringElements(section_names, countEmpty)
  num_retrieval_times = NumStringElements(retrieval_names, countEmpty)
  call time_now ( final )
  final = final - run_start_time
  ! Do sections, phases, both?
  sections = (StringElementNum('all,both,sections', LowerCase(which), &
    & countEmpty) > 0)
  phases = (StringElementNum('all,both,phases', LowerCase(which), &
    & countEmpty) > 0)
  timings = 0.
  k = 0
  if ( sections ) then
    total = 0.
    if ( trim(lowercase(names)) == 'all' ) then
      myNames=section_names
    else
      myNames=names
    endif
    numNames = NumStringElements(trim(myNames), countEmpty)
    do iName=1, numNames
      call GetStringElement(trim(LowerCase(myNames)), name, iName, countEmpty)
      elem = StringElementNum(LowerCase(section_names), trim(name), countEmpty)
      if ( elem > 0 ) then
        k = min(k+1, size(timings))
        timings(k) = section_timings(elem)
        total = total + timings(k)
      endif     
    enddo
    if ( myOthersToo ) then
      k = min(k+1, size(timings))
      timings(k) = max(final, total) - total
    endif
  endif
  if ( phases ) then
    total = 0.
    if ( trim(lowercase(names)) == 'all' ) then
      myNames=trim(phaseNames)
    else
      myNames=names
    endif
    numNames = NumStringElements(trim(myNames), countEmpty)
    do iName=1, numNames
      call GetStringElement(trim(LowerCase(myNames)), name, iName, countEmpty)
      elem = StringElementNum(trim(LowerCase(phaseNames)), &
        & trim(name), countEmpty)
      if ( elem > 0 ) then
        k = min(k+1, size(timings))
        timings(k) = phase_timings(elem)
      endif     
    enddo
    if ( myOthersToo ) then
      k = min(k+1, size(timings))
      timings(k) = max(final, total) - total
    endif
  endif
    
  end subroutine filltimings_single

  ! -----------------------------------------  restartTimings  -----
  subroutine restartTimings( which )
  ! Zero out accumulating timings unless 'flags'-only
  ! re-initialize some specific flags and parameters
  ! Args
  character(len=*), intent(in) :: which ! phases, sections, or all
  ! Internal variables
  logical :: sections, phases
  ! Executable
  num_section_times = NumStringElements(section_names, countEmpty)
  num_retrieval_times = NumStringElements(retrieval_names, countEmpty)
  if ( lowercase(which) == 'flags' ) then
    FINISHEDSECTIONTIMES = .false.
    FINISHEDPHASETIMES = .false.
    return
  endif
  ! Do sections, phases, both?
  sections = (StringElementNum('all,both,sections', LowerCase(which), &
    & countEmpty) > 0)
  phases = (StringElementNum('all,both,phases', LowerCase(which), &
    & countEmpty) > 0)

  if ( sections ) then
    section_timings = 0.
    call add_to_section_timing('restart')
    call add_to_retrieval_timing('restart')
    call add_to_directwrite_timing('restart')
    call time_now(run_start_time)
    FINISHEDSECTIONTIMES = .false.
  endif
  if ( phases ) then
    phase_timings = 0.
    call add_to_phase_timing('restart')
    FINISHEDPHASETIMES = .false.
  endif
  end subroutine restartTimings
  
  function showTimingNames(which, othersToo)  result (names)
  ! Args
  character(len=*), intent(in) :: which ! phases, sections, or all
  character(len=MAXNAMESLENGTH) :: names
  logical, intent(in), optional :: othersToo
  ! Internal variables
  logical :: sections, phases, myOthersToo
  ! Executable
  myOthersToo = .false.
  if ( present(othersToo) ) myOthersToo = othersToo
  ! Do sections, phases, both?
  sections = (StringElementNum('all,both,sections', LowerCase(which), &
    & countEmpty) > 0)
  phases = (StringElementNum('all,both,phases', LowerCase(which), &
    & countEmpty) > 0)
  names = ' '
  if ( sections ) then
    names = trim(section_names)
  else
    names = ' '
  endif
  if ( phases ) then
    names = catLists(trim(names), trim(phaseNames))
  endif
  if ( myOthersToo ) names = catLists(trim(names), '(others)')
  end function showTimingNames

!=============================================================================
  subroutine announce_phase(phase_name)
    character(len=*), intent(in) :: phase_name
    character(len=*), parameter :: BLAZON=' '
    if ( phase_name == ' ' ) return
    if ( BLAZON /= ' ' ) call output ( BLAZON // '  ' , advance='no' )
    call output ( 'Beginning phase ', advance='no' )
    call output ( phase_name , advance='no' )
    if ( BLAZON /= ' ' ) then
      call output ( '  '  // BLAZON  , advance='no' )
    else
      call output ( ' ', advance='yes', DONT_STAMP=.true. )
    endif
  end subroutine announce_phase

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: MLSL2Timings.f90,v 2.77 2020/04/30 23:31:09 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

END MODULE MLSL2Timings
!=============================================================================

!
! $Log: MLSL2Timings.f90,v $
! Revision 2.77  2020/04/30 23:31:09  pwagner
! Add call To FinalMemoryReport at end of each phase
!
! Revision 2.76  2019/09/19 16:10:28  pwagner
! restartTimings will optionally reset only flags, not timings
!
! Revision 2.75  2019/09/05 17:52:54  pwagner
! cmdline --skipretrievals no longer reversible
!
! Revision 2.74  2019/07/17 20:21:11  pwagner
! Dont DumpOptions while output is suspended
!
! Revision 2.73  2018/10/27 01:20:08  vsnyder
! Give initial value to Reset, so undefined-checking runs don't bomb
!
! Revision 2.72  2018/09/13 20:27:46  pwagner
! Moved changeable options to new L2Options; added DumpOptions; added /reset flag to phase commands to make current l2Options permanent
!
! Revision 2.71  2018/03/14 22:16:43  pwagner
! Initialize Phasestring, Chunkstring to prevent printing nulls
!
! Revision 2.70  2017/11/30 20:52:08  pwagner
! Added optional /stamp field to phase spec
!
! Revision 2.69  2017/11/15 00:18:11  pwagner
! Stamp with phase name if /stamp; dont reset interval unless /stamp
!
! Revision 2.68  2017/10/18 00:01:08  pwagner
! interval had been a temporary local variable, instead of StampOptions component; fixed
!
! Revision 2.67  2016/07/28 01:44:41  vsnyder
! Remove unused USE
!
! Revision 2.66  2016/05/27 00:06:14  pwagner
! Should now correctly process options containing an embedded space
!
! Revision 2.65  2016/05/19 23:22:58  pwagner
! Corrected some mistakes and misspellings in comments
!
! Revision 2.64  2015/10/13 23:50:05  pwagner
! Delete unneeded debug printing
!
! Revision 2.63  2015/09/17 23:18:28  pwagner
! Repaired bug using currentPhaseName before being defined; addPhaseToPhaseNames can now be called with name=0
!
! Revision 2.62  2015/09/10 17:50:35  pwagner
! Fixed bug counting DirectWrite timing twice
!
! Revision 2.61  2015/07/16 22:11:24  pwagner
! Will print calculation of now_stop if verbose
!
! Revision 2.60  2015/05/06 20:48:14  pwagner
! Slaves prefix Warnings or worse with phase and chunk num
!
! Revision 2.59  2014/09/29 20:50:03  pwagner
! Summarizes sys memory usagee by phase
!
! Revision 2.58  2014/08/12 23:29:40  pwagner
! /additional flag added to phase commands applies to options field
!
! Revision 2.57  2014/08/06 23:33:18  vsnyder
! Remove USE for CurrentChunkNumber, which is not referenced
!
! Revision 2.56  2014/06/25 20:43:25  pwagner
! Fixed error in evaluating runTimeFlags
!
! Revision 2.55  2014/04/10 00:44:21  pwagner
! Moved currentChunkNumber, currentPhaseName from MLSL2Timings to MLSL2Options
!
! Revision 2.54  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.53  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.52  2013/11/20 00:58:08  pwagner
! Reduce printing during non-verbose processing
!
! Revision 2.51  2013/11/18 22:26:07  pwagner
! phase spec takes optional /debug /verbose fields
!
! Revision 2.50  2013/06/14 18:49:46  vsnyder
! Decruftification
!
! Revision 2.49  2013/06/13 00:43:08  pwagner
! Make actual used of interval variable set between printing header
!
! Revision 2.48  2013/06/12 02:37:49  vsnyder
! Cruft removal
!
! Revision 2.47  2013/05/17 00:53:57  pwagner
! Use dumpMacros to dump r/t macros
!
! Revision 2.46  2013/04/05 23:26:04  pwagner
! Made 'master' a 'section' for timings summary
!
! Revision 2.45  2013/02/04 22:02:28  pwagner
! Less verbose; trimmed commented-out stuff
!
! Revision 2.44  2012/07/02 20:33:41  pwagner
! -Sphasen: n > 0 to bannerize phasename; n > 1 to stamp stdout with time,phase
!
! Revision 2.43  2012/06/27 18:00:34  pwagner
! May overwrite command line options with options field to phase spec
!
! Revision 2.42  2012/04/26 23:14:30  pwagner
! Now tracks currentPhaseName and currentChunkNumber (is there a better place?)
!
! Revision 2.41  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.40  2007/09/06 23:32:47  pwagner
! Fixed repeated phase name bug in Info component of MLSMessageConfig
!
! Revision 2.39  2007/08/31 00:04:06  pwagner
! Make chunk number part of Warning string
!
! Revision 2.38  2007/08/13 17:40:55  pwagner
! Warnings and Errors automatically print phase where they occur
!
! Revision 2.37  2007/06/21 00:54:08  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.36  2007/06/04 23:24:46  pwagner
! Global TRUE skipDirectWrite, skipRetrievals not overriden by phase settings
!
! Revision 2.35  2006/07/21 20:11:54  pwagner
! Can select what section to stop after
!
! Revision 2.34  2006/06/24 23:10:17  pwagner
! Remove unneeded thing from output_m
!
! Revision 2.33  2006/06/12 18:44:25  pwagner
! Must always obey if originally told to skip
!
! Revision 2.32  2006/03/04 00:16:38  pwagner
! May skip retrieval, directWrites depending on runtime Booleans
!
! Revision 2.31  2006/02/16 00:12:02  pwagner
! Added stamp boolean field to phase asks for printing phase names, times
!
! Revision 2.30  2006/02/10 21:11:29  pwagner
! May specify skipRetrivel for particular Phases
!
! Revision 2.29  2006/01/06 01:15:32  pwagner
! Added addPhaseToPhaseNames
!
! Revision 2.28  2005/09/22 23:39:38  pwagner
! time_config and retry_config now hold config settings
!
! Revision 2.27  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.26  2004/12/14 21:40:20  pwagner
! Notes skipped sections
!
! Revision 2.25  2004/08/16 17:13:06  pwagner
! Commented out debug printing
!
! Revision 2.24  2004/08/04 23:19:58  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.23  2004/06/29 00:08:41  pwagner
! Now can fill timings
!
! Revision 2.22  2004/05/06 20:42:24  pwagner
! Announces beginning of each phase if phase switch set
!
! Revision 2.21  2004/02/10 19:26:23  pwagner
! Fixed bug in phase names
!
! Revision 2.20  2004/01/14 18:49:58  vsnyder
! Stuff to support the Algebra section
!
! Revision 2.19  2003/12/05 00:50:44  pwagner
! Numerous small bugixes related to wall clock time use
!
! Revision 2.18  2003/10/23 22:20:16  pwagner
! A few bugfixes in dump_section_timings
!
! Revision 2.17  2003/10/22 21:19:14  pwagner
! Added timings breakdown by phases
!
! Revision 2.16  2003/10/20 18:21:45  pwagner
! Timings breakdown added for directWrite
!
! Revision 2.15  2003/08/11 23:24:48  pwagner
! Chunk no. printed if slave task
!
! Revision 2.14  2003/06/09 22:51:36  pwagner
! Renamed scan_divide to chunk_divide in timings table
!
! Revision 2.13  2003/02/27 21:56:07  pwagner
! Passes LOGFORMAT along with FORMAT
!
! Revision 2.12  2002/10/08 17:36:22  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.11  2002/09/24 18:15:12  pwagner
! Prepared to allow unknown names; add_to_section_timing now like retrieval
!
! Revision 2.10  2002/09/19 19:07:05  vsnyder
! Only update t1 if it's present!
!
! Revision 2.9  2002/09/18 23:56:01  vsnyder
! Call time_now at end of add_to_retrieval_timing
!
! Revision 2.8  2002/07/23 00:06:05  pwagner
! No upper-case allowed in section names
!
! Revision 2.7  2002/07/22 22:53:10  pwagner
! Added names of 2d scan model, form norm eq, and tikh reg to retrieval
!
! Revision 2.6  2001/11/27 23:34:49  pwagner
! Split forward model timings into four types
!
! Revision 2.5  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.4  2001/10/01 23:30:50  pwagner
! Fixed bug in spelling cholesky_solver
!
! Revision 2.3  2001/10/01 22:54:22  pwagner
! Added subsection timings for Retrieval section
!
! Revision 2.2  2001/09/28 23:59:20  pwagner
! Fixed various timing problems
!
! Revision 2.1  2001/09/28 17:50:30  pwagner
! MLSL2Timings module keeps timing info
!
@


2.77
log
@Add call To FinalMemoryReport at end of each phase
@
text
@d47 7
a53 7
  public :: section_times, total_times, &
    &       add_to_directwrite_timing, &
    &       add_to_retrieval_timing, add_to_section_timing, &
    &       addphasetophasenames, &
    &       dump_section_timings, run_start_time
  public :: finishtimings, filltimings, restarttimings
  public :: showtimingnames
d146 1
d233 1
d521 1
d533 1
d548 1
a548 1
    real                            :: memoryTotal
d757 1
a757 1
    memoryTotal = 0.
d781 1
a781 1
      memoryTotal = max ( memoryTotal, elem_memory )
d789 3
a791 3
    if ( memoryTotal > 0. ) then
      call output ( 'Total memory used ', advance='no' )
      call output ( memoryTotal, advance='no' )
d793 7
a799 1
      call output ( sys_memory_ch, advance='yes' )
d1057 1
a1057 1
       "$Id: MLSL2Timings.f90,v 2.76 2019/09/19 16:10:28 pwagner Exp $"
d1069 3
@


2.76
log
@restartTimings will optionally reset only flags, not timings
@
text
@d16 1
a16 1
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d518 1
d1047 1
a1047 1
       "$Id: MLSL2Timings.f90,v 2.75 2019/09/05 17:52:54 pwagner Exp $"
d1059 3
@


2.75
log
@cmdline --skipretrievals no longer reversible
@
text
@d966 1
a966 1
  ! Zero out accumulating timings
d973 7
a979 2
    num_section_times = NumStringElements(section_names, countEmpty)
    num_retrieval_times = NumStringElements(retrieval_names, countEmpty)
d1046 1
a1046 1
       "$Id: MLSL2Timings.f90,v 2.74 2019/07/17 20:21:11 pwagner Exp $"
d1058 3
@


2.74
log
@Dont DumpOptions while output is suspended
@
text
@d415 2
d419 2
d1041 1
a1041 1
       "$Id: MLSL2Timings.f90,v 2.73 2018/10/27 01:20:08 vsnyder Exp $"
d1053 3
@


2.73
log
@Give initial value to Reset, so undefined-checking runs don't bomb
@
text
@d38 2
a39 2
  use Output_M, only: StampOptions, Blanks, NewLine, Output, &
    & RestoreSettings, ResumeOutput, SuspendOutput
d67 2
d83 2
a84 1
! restartTimings         Zero out accumulating timings, reinitialize flags
d503 2
a504 1
    if ( BeVerbose('opt', -1) ) call DumpOptions
d1037 1
a1037 1
       "$Id: MLSL2Timings.f90,v 2.72 2018/09/13 20:27:46 pwagner Exp $"
d1049 3
@


2.72
log
@Moved changeable options to new L2Options; added DumpOptions; added /reset flag to phase commands to make current l2Options permanent
@
text
@d366 1
d1033 1
a1033 1
       "$Id: MLSL2Timings.f90,v 2.71 2018/03/14 22:16:43 pwagner Exp $"
d1045 3
@


2.71
log
@Initialize Phasestring, Chunkstring to prevent printing nulls
@
text
@d18 3
a20 3
  use HighOutput, only: Banner, OutputNamedValue
  use Init_Tables_Module, only: F_Additional, F_Debug, F_Options, F_Silent, &
    & F_Skipdirectwrites, F_Skipdirectwritesif, &
d27 2
a28 2
  use MLSL2Options, only: Command_Line, CurrentPhaseName, &
    & DumpMacros, OriginalCmds, &
a30 1
    & SkipRetrieval, SkipRetrievalOriginal, &
d356 1
d362 1
d369 1
a369 1
    skipRetrieval = skipRetrievalOriginal
d392 2
d411 1
a411 2
        skipRetrieval = skipRetrievalOriginal .or. &
          & get_boolean ( fieldValue )
d418 1
a418 2
        skipRetrieval = skipRetrievalOriginal .or. &
          & BooleanValue ( lowercase(booleanString), &
d421 1
a421 1
        if ( stamp ) call output( skipRetrieval, advance='yes' )
d433 1
a433 1
      currentPhaseName = phaseString
d438 1
a438 1
      booleanstring = processOptions( trim( ORIGINALCMDS ), null )
d442 1
a442 1
      call outputNamedValue( 'command_line', trim(command_line) )
d451 1
a451 1
      call outputNamedValue( 'command_line', trim(command_line) )
d497 3
d633 1
a633 1
    if ( SKIPRETRIEVAL ) then
d1032 1
a1032 1
       "$Id: MLSL2Timings.f90,v 2.70 2017/11/30 20:52:08 pwagner Exp $"
d1044 3
@


2.70
log
@Added optional /stamp field to phase spec
@
text
@d370 2
d1028 1
a1028 1
       "$Id: MLSL2Timings.f90,v 2.69 2017/11/15 00:18:11 pwagner Exp $"
d1040 3
@


2.69
log
@Stamp with phase name if /stamp; dont reset interval unless /stamp
@
text
@d40 1
a40 1
    & ResumeOutput, SuspendOutput
d496 6
a502 2
    if ( got(f_stamp) ) &
      & stampOptions%textCode = ': : ' // trim(phaseString) // ' : :'
d1026 1
a1026 1
       "$Id: MLSL2Timings.f90,v 2.68 2017/10/18 00:01:08 pwagner Exp $"
d1038 3
@


2.68
log
@interval had been a temporary local variable, instead of StampOptions component; fixed
@
text
@d483 4
a486 2
    if ( detail < 2 ) then
      StampOptions%interval = 25 ! print header once every 25 lines
d489 1
a489 1
      StampOptions%interval = 10 ! print header once every 10 lines
d497 2
d1022 1
a1022 1
       "$Id: MLSL2Timings.f90,v 2.67 2016/07/28 01:44:41 vsnyder Exp $"
d1034 3
@


2.67
log
@Remove unused USE
@
text
@d13 1
a13 1
MODULE MLSL2Timings              !  Timings for the MLSL2 program sections
d16 9
a24 10
  use allocate_deallocate, only: allocate_test, deallocate_test
  use Call_Stack_m, only: sys_memory_ch, sys_memory_convert, sys_memory_max
!  use Dump_0, only: Dump
  use HighOutput, only: banner, outputNamedValue
  use Init_tables_module, only: f_additional, f_debug, f_options, f_silent, &
    & f_skipdirectwrites, f_skipdirectwritesif, &
    & f_skipretrieval, f_skipretrievalif, f_stamp, f_verbose, &
    & field_first, field_last
  use intrinsic, only: l_hours, l_minutes, l_seconds
  use L2Parinfo, only: parallel
d27 6
a32 6
  use MLSL2Options, only: command_line, currentPhaseName, &
    & dumpMacros, originalCmds, &
    & processOptions, restartWarnings, restoreDefaults, runtimeValues, &
    & sectionTimingUnits, skipDirectwrites, skipDirectwritesOriginal, &
    & skipRetrieval, skipRetrievalOriginal, &
    & stopAfterSection
d35 10
a44 10
  use MLSStrings, only: lowercase 
  use MLSStringLists, only: booleanValue, catlists, getStringElement, &
    & numStringElements, stringElementNum, switchDetail
  use moreTree, only: get_boolean
  use output_m, only: blanks, newLine, output, &
    & resumeOutput, suspendOutput
  use string_table, only: get_string
  use time_m, only: time_now
  use toggles, only: switches
  use tree, only: decoration, nsons, sub_rosa, subtree
d321 2
d349 1
a349 1
    integer :: interval
d484 1
a484 1
      interval = 25 ! print header once every 25 lines
d487 1
a487 1
      interval = 10 ! print header once every 10 lines
d490 1
a490 1
      interval = 1 ! stamp every line with time, phase name
d1018 1
a1018 1
       "$Id: MLSL2Timings.f90,v 2.66 2016/05/27 00:06:14 pwagner Exp $"
d1030 3
@


2.66
log
@Should now correctly process options containing an embedded space
@
text
@d18 3
a20 3
  use Dump_0, only: dump
  use highOutput, only: banner, outputNamedValue, setStamp
  use init_tables_module, only: f_additional, f_debug, f_options, f_silent, &
d1017 1
a1017 1
       "$Id: MLSL2Timings.f90,v 2.65 2016/05/19 23:22:58 pwagner Exp $"
d1029 3
@


2.65
log
@Corrected some mistakes and misspellings in comments
@
text
@d351 1
d363 1
d434 1
a434 1
      booleanstring = processOptions( trim( ORIGINALCMDS ) )
d1017 1
a1017 1
       "$Id: MLSL2Timings.f90,v 2.64 2015/10/13 23:50:05 pwagner Exp $"
d1029 3
@


2.64
log
@Delete unneeded debug printing
@
text
@d26 10
a35 10
  use MLSCommon, only: MLSdebug, MLSverbose, &
    & MLSDebugsticky, MLSverbosesticky
  use MLSL2Options, only: command_line, currentphasename, &
    & dumpmacros, originalcmds, &
    & processoptions, restartwarnings, restoredefaults, runtimevalues, &
    & sectiontimingunits, skipdirectwrites, skipdirectwritesoriginal, &
    & skipretrieval, skipretrievaloriginal, &
    & stopaftersection
  use MLSMessagemodule, only: MLSmessageconfig, MLSmessage, MLSmessagereset, &
    & MLSMsg_error
d37 3
a39 3
  use MLSStringlists, only: booleanvalue, catlists, getstringelement, &
    & numstringelements, stringelementnum, switchdetail
  use moretree, only: get_boolean
d155 1
a155 1
    character(LEN=*), intent(in):: section_name   ! One of the dw. sect_names
d198 1
a198 1
    character(LEN=*), intent(in):: phase_name   ! One of the phases, e.g. 'core'
d248 1
a248 1
    character(LEN=*), intent(in):: section_name   ! One of the retr. sect_names
d285 1
a285 1
    character(LEN=*), intent(in):: section_name   ! One of the section_names
d329 1
a329 1
  ! set options controllable by runtime flags, like whther
d335 1
a335 1
  ! setPhase, ..
d504 3
a506 3
    character(LEN=*), parameter     :: TIMEFORMSMALL = '(F10.2)'
    character(LEN=*), parameter     :: TIMEFORMBIG = '(1PE10.2)'
    character(LEN=*), parameter     :: PCTFORM='(F10.0)'
d1015 1
a1015 1
       "$Id: MLSL2Timings.f90,v 2.63 2015/09/17 23:18:28 pwagner Exp $"
d1027 3
@


2.63
log
@Repaired bug using currentPhaseName before being defined; addPhaseToPhaseNames can now be called with name=0
@
text
@a816 2
      call outputnamedValue( 'section_timings(joinElem)', section_timings(joinElem) )
      call outputnamedValue( 'section_timings(dwElem)', section_timings(dwElem) )
d1015 1
a1015 1
       "$Id: MLSL2Timings.f90,v 2.62 2015/09/10 17:50:35 pwagner Exp $"
d1027 3
@


2.62
log
@Fixed bug counting DirectWrite timing twice
@
text
@d331 5
d425 4
a428 2
    call get_string(name, phaseString)
    currentPhaseName = phaseString
d462 1
a462 1
    if ( RESTARTWARNINGS ) call MLSMessageReset( Warnings=.true. )
d470 1
a470 1
    else
d473 1
a473 1
    MLSMessageConfig%Warning = MLSMessageConfig%Info
d490 1
a490 7
    if ( stamp .and. .false. ) then ! Not planning to use this idea any longer
      call setStamp( textcode=phaseString(1:24), showTime=.true., &
        & interval=interval )
    else
      ! Possibly undo stamp added by prior phase
      call setStamp( textcode=' ', showTime=.false. )
    endif
d802 2
a815 2
    joinElem = StringElementNum(section_names, 'join', countEmpty)
    dwElem = StringElementNum(section_names, 'directwrite', countEmpty)
d1017 1
a1017 1
       "$Id: MLSL2Timings.f90,v 2.61 2015/07/16 22:11:24 pwagner Exp $"
d1029 3
@


2.61
log
@Will print calculation of now_stop if verbose
@
text
@a802 8
    ! Adjust Join section timing to exclude directwrite timings
    ! (otherwise they would be counted twice)
    joinElem = StringElementNum(section_names, 'join', countEmpty)
    dwElem = StringElementNum(section_names, 'directwrite', countEmpty)
    if ( joinElem > 0 .and. dwElem > 0 ) section_timings(joinElem) = &
      &         section_timings(joinElem) - section_timings(dwElem)

    ! Another trick:
d810 11
d1016 1
a1016 1
       "$Id: MLSL2Timings.f90,v 2.60 2015/05/06 20:48:14 pwagner Exp $"
d1028 3
@


2.60
log
@Slaves prefix Warnings or worse with phase and chunk num
@
text
@d317 5
d1013 1
a1013 1
       "$Id: MLSL2Timings.f90,v 2.59 2014/09/29 20:50:03 pwagner Exp $"
d1025 3
@


2.59
log
@Summarizes sys memory usagee by phase
@
text
@d461 1
d1008 1
a1008 1
       "$Id: MLSL2Timings.f90,v 2.58 2014/08/12 23:29:40 pwagner Exp $"
d1020 3
@


2.58
log
@/additional flag added to phase commands applies to options field
@
text
@d17 2
d26 3
a28 3
  use MLScommon, only: MLSdebug, MLSverbose, &
    & MLSdebugsticky, MLSverbosesticky
  use MLSl2options, only: command_line, currentphasename, &
d40 1
a40 1
  use output_m, only: blanks, output, &
d143 1
d229 1
d417 2
a418 2
    ! Restore settings if last one overwrote them
    if ( LASTPHASEOVERWROTEOPTS ) then
d477 1
a477 1
    if ( stamp ) then
d485 2
d510 1
d513 1
d515 2
a516 1
    character(LEN=LEN(TIMEFORMBIG)) :: TIMEFORM
d557 5
d706 2
d716 4
a719 1
    call output ( 'percent of total time', advance='yes' )
d722 2
a723 1
      elem_time = phase_timings(elem)
a728 1
      call blanks ( 2, advance='no' )
d730 6
d737 1
d743 1
d751 6
d1007 1
a1007 1
       "$Id: MLSL2Timings.f90,v 2.57 2014/08/06 23:33:18 vsnyder Exp $"
d1019 3
@


2.57
log
@Remove USE for CurrentChunkNumber, which is not referenced
@
text
@d18 1
a18 1
  use init_tables_module, only: f_debug, f_options, f_silent, &
d327 1
d346 1
d365 2
d437 3
d974 1
a974 1
       "$Id: MLSL2Timings.f90,v 2.56 2014/06/25 20:43:25 pwagner Exp $"
d986 3
@


2.56
log
@Fixed error in evaluating runTimeFlags
@
text
@d26 1
a26 1
  use MLSl2options, only: command_line, currentphasename, currentchunknumber, &
d967 1
a967 1
       "$Id: MLSL2Timings.f90,v 2.55 2014/04/10 00:44:21 pwagner Exp $"
d979 3
@


2.55
log
@Moved currentChunkNumber, currentPhaseName from MLSL2Timings to MLSL2Options
@
text
@d16 28
a43 28
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use HIGHOUTPUT, only: BANNER, OUTPUTNAMEDVALUE, SETSTAMP
  use INIT_TABLES_MODULE, only: F_DEBUG, F_OPTIONS, F_SILENT, &
    & F_SKIPDIRECTWRITES, F_SKIPDIRECTWRITESIF, &
    & F_SKIPRETRIEVAL, F_SKIPRETRIEVALIF, F_STAMP, F_VERBOSE, &
    & FIELD_FIRST, FIELD_LAST
  use INTRINSIC, only: L_HOURS, L_MINUTES, L_SECONDS
  use L2PARINFO, only: PARALLEL
  use MLSCommon, only: MLSDebug, MLSVerbose, &
    & MLSDebugSticky, MLSVerboseSticky
  use MLSL2OPTIONS, only: COMMAND_LINE, currentPhaseName, currentChunkNumber, &
    & DUMPMACROS, ORIGINALCMDS, &
    & PROCESSOPTIONS, RESTARTWARNINGS, RESTOREDEFAULTS, RUNTIMEVALUES, &
    & SECTIONTIMINGUNITS, SKIPDIRECTWRITES, SKIPDIRECTWRITESORIGINAL, &
    & SKIPRETRIEVAL, SKIPRETRIEVALORIGINAL, &
    & STOPAFTERSECTION
  use MLSMESSAGEMODULE, only: MLSMESSAGECONFIG, MLSMESSAGE, MLSMESSAGERESET, &
    & MLSMSG_ERROR
  use MLSSTRINGS, only: LOWERCASE 
  use MLSSTRINGLISTS, only: BOOLEANVALUE, CATLISTS, GETSTRINGELEMENT, &
    & NUMSTRINGELEMENTS, STRINGELEMENTNUM, SWITCHDETAIL
  use MORETREE, only: GET_BOOLEAN
  use OUTPUT_M, only: BLANKS, OUTPUT, &
    & RESUMEOUTPUT, SUSPENDOUTPUT
  use STRING_TABLE, only: GET_STRING
  use TIME_M, only: TIME_NOW
  use TOGGLES, only: SWITCHES
  use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
d47 7
a53 7
  public :: SECTION_TIMES, TOTAL_TIMES, &
    &       ADD_TO_DIRECTWRITE_TIMING, &
    &       ADD_TO_RETRIEVAL_TIMING, ADD_TO_SECTION_TIMING, &
    &       ADDPHASETOPHASENAMES, &
    &       DUMP_SECTION_TIMINGS, RUN_START_TIME
  public :: FINISHTIMINGS, FILLTIMINGS, RESTARTTIMINGS
  public :: SHOWTIMINGNAMES
d62 35
d317 5
d377 2
a378 1
          & runTimeValues%lkeys, runTimeValues%lvalues), advance='yes' )
d381 3
a383 3
          & runTimeValues%lkeys, runTimeValues%lvalues)
        ! call output( 'skipDirectwrites: ', advance='no' )
        ! call output( skipDirectwrites, advance='yes' )
d386 1
a386 1
          & get_boolean ( fieldValue ) .or. skipRetrievalOriginal
d389 1
a389 1
        if ( stamp )call output( 'told to skipRetrieval: ', advance='no' )
d391 2
a392 1
          & runTimeValues%lkeys, runTimeValues%lvalues), advance='yes' )
d395 4
a398 3
          & runTimeValues%lkeys, runTimeValues%lvalues) .or. skipRetrievalOriginal
        ! call output( 'skipRetrieval: ', advance='no' )
        ! call output( skipRetrieval, advance='yes' )
d890 1
a890 1
  ! -----------------------------------------  restart  -----
d967 1
a967 1
       "$Id: MLSL2Timings.f90,v 2.54 2014/01/11 01:44:18 vsnyder Exp $"
d979 3
@


2.54
log
@Decruftification
@
text
@d26 2
a27 1
  use MLSL2OPTIONS, only: COMMAND_LINE, DUMPMACROS, ORIGINALCMDS, &
d53 1
a53 1
  public :: SHOWTIMINGNAMES, CURRENTCHUNKNUMBER, CURRENTPHASENAME
a103 2
  character(len=SECTIONNAMELEN), save :: currentPhaseName = ' '
  integer, save                       :: currentChunkNumber = 0
d924 1
a924 1
       "$Id: MLSL2Timings.f90,v 2.53 2014/01/09 00:30:24 pwagner Exp $"
d936 3
@


2.53
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d31 2
a32 2
  use MLSMESSAGEMODULE, only: MLSMESSAGECONFIG, &
    & MLSMESSAGE, MLSMESSAGECALLS, MLSMESSAGERESET, MLSMSG_ERROR
d925 1
a925 1
       "$Id: MLSL2Timings.f90,v 2.52 2013/11/20 00:58:08 pwagner Exp $"
d937 3
@


2.52
log
@Reduce printing during non-verbose processing
@
text
@d17 1
d37 2
a38 2
  use OUTPUT_M, only: BANNER, BLANKS, OUTPUT, OUTPUTNAMEDVALUE, &
    & RESUMEOUTPUT, SETSTAMP, SUSPENDOUTPUT
d925 1
a925 1
       "$Id: MLSL2Timings.f90,v 2.51 2013/11/18 22:26:07 pwagner Exp $"
d937 3
@


2.51
log
@phase spec takes optional /debug /verbose fields
@
text
@d325 1
a325 1
        call output( 'Processing debug field', advance='yes' )
d335 3
a337 3
        ! call output( 'told to skipDirectwrites: ', advance='no' )
        ! call output( BooleanValue ( lowercase(booleanString), &
        !   & runTimeValues%lkeys, runTimeValues%lvalues), advance='yes' )
d348 3
a350 3
        ! call output( 'told to skipRetrieval: ', advance='no' )
        ! call output( BooleanValue ( lowercase(booleanString), &
        !   & runTimeValues%lkeys, runTimeValues%lvalues), advance='yes' )
d360 1
a360 1
        call output( 'Processing verbos field', advance='yes' )
d924 1
a924 1
       "$Id: MLSL2Timings.f90,v 2.50 2013/06/14 18:49:46 vsnyder Exp $"
d936 3
@


2.50
log
@Decruftification
@
text
@d17 1
a17 1
  use INIT_TABLES_MODULE, only: F_OPTIONS, F_SILENT, &
d19 2
a20 1
    & F_SKIPRETRIEVAL, F_SKIPRETRIEVALIF, F_STAMP
d23 2
d31 1
a31 1
    & MLSMESSAGE, MLSMESSAGERESET, MLSMSG_ERROR
d287 1
d292 1
d303 1
d311 1
d321 1
d323 3
d358 3
d366 1
d370 2
d376 2
d384 10
a393 2
    else
      LASTPHASEOVERWROTEOPTS = .false.
d924 1
a924 1
       "$Id: MLSL2Timings.f90,v 2.49 2013/06/13 00:43:08 pwagner Exp $"
d936 3
@


2.49
log
@Make actual used of interval variable set between printing header
@
text
@a430 1
    logical                         :: Unknown_nonzero
a448 1
    Unknown_nonzero = .false.  ! (section_timings(unknown_section) > 0.)
a539 1
      Unknown_nonzero = .false.  ! (section_timings(unknown_retrieval) > 0.)
d897 1
a897 1
       "$Id: MLSL2Timings.f90,v 2.48 2013/06/12 02:37:49 vsnyder Exp $"
d909 3
@


2.48
log
@Cruft removal
@
text
@d398 1
a398 1
        & interval=25 )
d900 1
a900 1
       "$Id: MLSL2Timings.f90,v 2.47 2013/05/17 00:53:57 pwagner Exp $"
d912 3
@


2.47
log
@Use dumpMacros to dump r/t macros
@
text
@a16 1
  use DUMP_0, only: DUMP
d900 1
a900 1
       "$Id: MLSL2Timings.f90,v 2.46 2013/04/05 23:26:04 pwagner Exp $"
d912 3
@


2.46
log
@Made 'master' a 'section' for timings summary
@
text
@d23 2
a24 2
  use MLSL2OPTIONS, only: ORIGINALCMDS, COMMAND_LINE, PROCESSOPTIONS, &
    & RESTARTWARNINGS, RESTOREDEFAULTS, RUNTIMEVALUES, &
d406 1
a406 2
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
d901 1
a901 1
       "$Id: MLSL2Timings.f90,v 2.45 2013/02/04 22:02:28 pwagner Exp $"
d913 3
@


2.45
log
@Less verbose; trimmed commented-out stuff
@
text
@d86 1
a86 1
    & 'directwrite,algebra,output'
d476 3
a478 2
        elem_time = section_timings(elem)
        call GetStringElement(section_names, section_name, elem, countEmpty)
d902 1
a902 1
       "$Id: MLSL2Timings.f90,v 2.44 2012/07/02 20:33:41 pwagner Exp $"
d914 3
@


2.44
log
@-Sphasen: n > 0 to bannerize phasename; n > 1 to stamp stdout with time,phase
@
text
@a298 1
    ! logical :: toldToSkip
a305 1
    ! toldToSkip = .false.
a322 1
        ! toldToSkip = .true.
a332 1
        ! toldToSkip = .true.
a335 1
        ! toldToSkip = .true.
a345 1
        ! toldToSkip = .true.
d405 1
a405 1
    if ( switchDetail(switches, 'bool') > -1 ) &
a407 3
    ! if ( toldToSkip ) &
    !   &  call MLSMessage ( MLSMSG_Error, moduleName, &
    !   & 'Told to skip something' )
d901 1
a901 1
       "$Id: MLSL2Timings.f90,v 2.43 2012/06/27 18:00:34 pwagner Exp $"
d913 3
@


2.43
log
@May overwrite command line options with options field to phase spec
@
text
@d34 1
a34 1
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE, &
d193 7
a199 2
      if ( switchDetail(switches, 'phase') > -1 ) &
        & call announce_phase(trim(phase_name))
d303 1
a303 1
    stamp = detail > 0 ! E.g., -Sphase1; was .false.
a357 1
    call add_to_phase_timing( trim(phaseString) )
d410 1
d910 1
a910 1
       "$Id: MLSL2Timings.f90,v 2.42 2012/04/26 23:14:30 pwagner Exp $"
d922 3
@


2.42
log
@Now tracks currentPhaseName and currentChunkNumber (is there a better place?)
@
text
@d18 1
a18 1
  use INIT_TABLES_MODULE, only: F_SILENT, &
d23 2
a24 1
  use MLSL2OPTIONS, only: RESTARTWARNINGS, RUNTIMEVALUES, &
d34 1
a34 1
  use OUTPUT_M, only: BLANKS, OUTPUT, &
d286 2
d301 1
d313 2
d355 17
d905 1
a905 1
       "$Id: MLSL2Timings.f90,v 2.41 2009/06/23 18:46:18 pwagner Exp $"
d917 3
@


2.41
log
@Prevent Intel from optimizing ident string away
@
text
@d16 2
a17 2
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Dump_0, only: Dump
d23 1
a23 1
  USE MLSL2Options, only: RESTARTWARNINGS, RUNTIMEVALUES, &
d27 6
a32 6
  USE MLSMessageModule, only: MLSMessageConfig, &
    & MLSMessage, MLSMessageReset, MLSMSG_Error
  USE MLSStrings, only: LowerCase 
  USE MLSStringLists, only: BooleanValue, catLists, GetStringElement, &
    & NumStringElements, StringElementNum, SwitchDetail
  use MoreTree, only: Get_Boolean
d35 2
a36 2
  use String_Table, only: get_string
  use Time_M, only: Time_Now
d40 1
a40 1
  IMPLICIT NONE
d43 6
a48 6
    & add_to_directwrite_timing, &
    & add_to_retrieval_timing, add_to_section_timing, &
    & addPhaseToPhaseNames, &
    & dump_section_timings, run_start_time
  public :: finishTimings, fillTimings, restartTimings
  public :: showTimingNames
d53 1
a53 1
       "$RCSfile: $"
d99 2
d277 1
a277 1
    integer, intent(in) :: ROOT               ! Root of hGrid subtree
d348 1
d882 1
a882 1
       "$Id: read_apriori.f90 is it here $"
d894 3
@


2.40
log
@Fixed repeated phase name bug in Info component of MLSMessageConfig
@
text
@d53 1
a53 1
       "$RCSfile: MLSL2Timings.f90,v $"
d255 2
d876 1
a877 1
!---------------------------- RCS Ident Info -------------------------------
d879 2
a880 3
       "$Id: MLSL2Timings.f90,v 2.39 2007/08/31 00:04:06 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d882 1
d884 1
d891 3
@


2.39
log
@Make chunk number part of Warning string
@
text
@d351 1
a351 1
        & trim(adjustl(chunkString)) // ') ' // phaseString
d877 1
a877 1
       "$Id: MLSL2Timings.f90,v 2.38 2007/08/13 17:40:55 pwagner Exp $"
d888 3
@


2.38
log
@Warnings and Errors automatically print phase where they occur
@
text
@d283 1
d347 8
a354 1
    MLSMessageConfig%Info = phaseString
d877 1
a877 1
       "$Id: MLSL2Timings.f90,v 2.37 2007/06/21 00:54:08 vsnyder Exp $"
d888 3
@


2.37
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d27 2
a28 1
  USE MLSMessageModule, only: MLSMessage, MLSMessageReset, MLSMSG_Error
d343 4
a346 1
    if ( RESTARTWARNINGS ) call MLSMessageReset(Warnings=.true.)
d869 1
a869 1
       "$Id: MLSL2Timings.f90,v 2.36 2007/06/04 23:24:46 pwagner Exp $"
d880 3
@


2.36
log
@Global TRUE skipDirectWrite, skipRetrievals not overriden by phase settings
@
text
@d81 1
a81 1
  character*(*), parameter           :: section_names = &
d86 1
a86 1
  character*(*), parameter           :: retrieval_names = &
d92 1
a92 1
  character*(*), parameter           :: directwrite_names = &
d865 1
a865 1
       "$Id: MLSL2Timings.f90,v 2.35 2006/07/21 20:11:54 pwagner Exp $"
d876 3
@


2.35
log
@Can select what section to stop after
@
text
@d306 2
a307 1
        skipDirectwrites = get_boolean ( fieldValue )
d311 6
a317 3
        ! call output( trim(booleanString), advance='yes' )
        skipDirectwrites = BooleanValue ( lowercase(booleanString), &
          & runTimeValues%lkeys, runTimeValues%lvalues)
d321 2
a322 1
        skipRetrieval = get_boolean ( fieldValue ) .or. skipRetrievalOriginal
d326 6
a332 3
        ! call output( trim(booleanString), advance='yes' )
        skipRetrieval = BooleanValue ( lowercase(booleanString), &
          & runTimeValues%lkeys, runTimeValues%lvalues) .or. skipRetrievalOriginal
d336 1
a336 1
        stamp = get_boolean ( fieldValue )
d865 1
a865 1
       "$Id: MLSL2Timings.f90,v 2.34 2006/06/24 23:10:17 pwagner Exp $"
d876 3
@


2.34
log
@Remove unneeded thing from output_m
@
text
@d26 1
a26 1
    & STOPAFTERCHUNKDIVIDE, STOPAFTERGLOBAL
a69 1
  logical, private   :: ALLOWUNKNOWNNAMES = .false.  ! Any unknown section names
d83 1
a83 1
    & 'read_apriori,chunk_divide,construct,fill,retrieve,join,' // &
a84 2
  ! This should be the number of elements in the above ---------------
  ! integer, parameter                 :: num_section_times = 14    ! <--|
a90 2
  ! This should be the number of elements in the above -----------------
  ! integer, parameter                 :: num_retrieval_times = 18  ! <--|
d230 1
a230 1
  subroutine add_to_section_timing( section_name, t1 )
d237 1
d263 3
a376 2
    integer                         :: joinElem
    integer                         :: dwElem
a389 1
    integer                         :: num_elems
d467 1
a467 1
    if ( STOPAFTERCHUNKDIVIDE .or. STOPAFTERGLOBAL ) then
a787 3
  integer :: dwElem
  integer :: Elem
  integer :: joinElem
d857 1
a857 1
       "$Id: MLSL2Timings.f90,v 2.33 2006/06/12 18:44:25 pwagner Exp $"
d868 3
@


2.33
log
@Must always obey if originally told to skip
@
text
@d32 1
a32 1
  use OUTPUT_M, only: BLANKS, OUTPUT, PRUNIT, &
d864 1
a864 1
       "$Id: MLSL2Timings.f90,v 2.32 2006/03/04 00:16:38 pwagner Exp $"
d875 3
@


2.32
log
@May skip retrieval, directWrites depending on runtime Booleans
@
text
@d286 1
a286 1
    logical :: toldToSkip
d293 1
a293 1
    toldToSkip = .false.
d308 1
a308 1
        toldToSkip = .true.
d316 1
a316 1
        toldToSkip = .true.
d318 2
a319 2
        skipRetrieval = get_boolean ( fieldValue )
        toldToSkip = .true.
d325 1
a325 1
          & runTimeValues%lkeys, runTimeValues%lvalues)
d327 1
a327 1
        toldToSkip = .true.
d864 1
a864 1
       "$Id: MLSL2Timings.f90,v 2.31 2006/02/16 00:12:02 pwagner Exp $"
d875 3
@


2.31
log
@Added stamp boolean field to phase asks for printing phase names, times
@
text
@d17 4
a20 1
  use INIT_TABLES_MODULE, only: F_SILENT, f_SKIPRETRIEVAL, F_STAMP
d23 3
a25 3
  USE MLSL2Options, only: RESTARTWARNINGS, &
    & SECTIONTIMINGUNITS, &
    & SKIPDIRECTWRITES, SKIPRETRIEVAL, SKIPRETRIEVALORIGINAL, &
d29 1
a29 1
  USE MLSStringLists, only: catLists, GetStringElement, &
d37 1
a37 1
  use TREE, only: DECORATION, NSONS, SUBTREE
d282 1
d286 1
d291 1
d293 1
d306 11
d319 9
d359 6
d864 1
a864 1
       "$Id: MLSL2Timings.f90,v 2.30 2006/02/10 21:11:29 pwagner Exp $"
d875 3
@


2.30
log
@May specify skipRetrivel for particular Phases
@
text
@d17 1
a17 1
  use INIT_TABLES_MODULE, only: F_SILENT, f_SKIPRETRIEVAL
d27 1
a27 1
    & NumStringElements, StringElementNum 
d29 2
a30 1
  use OUTPUT_M, only: BLANKS, OUTPUT, PRUNIT, resumeOutput, suspendOutput
d191 2
a192 1
      if ( index(switches, 'phase') /= 0 ) call announce_phase(trim(phase_name))
d272 1
a272 1
    integer :: keyNo
d276 3
d281 1
a281 1
    character(len=80) :: PHASESTRING    ! E.g., 'Core'
d283 1
d285 1
d301 2
d307 1
a307 1
    call add_to_phase_timing(trim(phaseString))
d314 18
d824 1
a824 1
      call output ( ' ', advance='yes' )
d831 1
a831 1
       "$Id: MLSL2Timings.f90,v 2.29 2006/01/06 01:15:32 pwagner Exp $"
d842 3
@


2.29
log
@Added addPhaseToPhaseNames
@
text
@d17 1
a17 1
  use INIT_TABLES_MODULE, only: F_SILENT
d21 2
a22 1
    & SECTIONTIMINGUNITS, SKIPDIRECTWRITES, SKIPRETRIEVAL, &
d279 1
d292 2
d804 1
a804 1
       "$Id: MLSL2Timings.f90,v 2.28 2005/09/22 23:39:38 pwagner Exp $"
d815 3
@


2.28
log
@time_config and retry_config now hold config settings
@
text
@d17 1
d20 2
a21 1
  USE MLSL2Options, only: SECTIONTIMINGUNITS, SKIPDIRECTWRITES, SKIPRETRIEVAL, &
d23 1
a23 1
  USE MLSMessageModule, only: MLSMessage, MLSMSG_Error
d27 3
a29 1
  use OUTPUT_M, only: BLANKS, OUTPUT, PRUNIT
d32 1
d37 1
a37 1
    & add_to_directwrite_timing, add_to_phase_timing, &
d39 1
d263 40
d800 1
a800 1
       "$Id: MLSL2Timings.f90,v 2.27 2005/06/22 18:57:02 pwagner Exp $"
d811 3
@


2.27
log
@Reworded Copyright statement, moved rcs id
@
text
@d26 1
a26 1
  use Time_M, only: Time_Now, Use_Wall_Clock
d41 1
a41 1
       "$RCSfile: $"
d754 1
a754 1
       "$Id: $"
d765 3
@


2.26
log
@Notes skipped sections
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d39 3
a41 4
  !---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id: MLSL2Timings.f90,v 2.25 2004/08/16 17:13:06 pwagner Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: MLSL2Timings.f90,v $"
d43 1
a43 1
  !---------------------------------------------------------------------------
d752 5
d765 3
@


2.25
log
@Commented out debug printing
@
text
@d11 2
a12 1
  USE MLSL2Options, only: SECTIONTIMINGUNITS
d33 1
a33 1
       "$Id: MLSL2Timings.f90,v 2.24 2004/08/04 23:19:58 pwagner Exp $"
a306 1

d354 4
d364 3
a366 1
    if ( retrFinal == 0.0 ) then
d412 3
a414 1
    if ( dwFinal == 0.0 ) then
d753 3
@


2.24
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d32 1
a32 1
       "$Id: MLSL2Timings.f90,v 2.23 2004/06/29 00:08:41 pwagner Exp $"
d548 1
a548 1
    print *, 'num_phases: ', num_phases
d551 1
a551 1
      print *, trim(section_name), phase_timings(elem)
d745 3
@


2.23
log
@Now can fill timings
@
text
@d13 2
a14 1
  USE MLSStrings, only: catLists, GetStringElement, LowerCase, &
d32 1
a32 1
       "$Id: MLSL2Timings.f90,v 2.22 2004/05/06 20:42:24 pwagner Exp $"
d745 3
@


2.22
log
@Announces beginning of each phase if phase switch set
@
text
@d8 1
d13 2
a14 1
  USE MLSStrings, only: GetStringElement, LowerCase, StringElementNum
d25 2
d31 1
a31 1
       "$Id: MLSL2Timings.f90,v 2.21 2004/02/10 19:26:23 pwagner Exp $"
d36 5
d46 2
d51 4
a54 1
  integer, parameter :: PHASENAMESLEN = 400
d56 5
d67 1
a67 1
  integer, parameter                 :: num_section_times = 14    ! <--|
d75 1
a75 1
  integer, parameter                 :: num_retrieval_times = 18  ! <--|
d81 1
a81 3
  ! dimension of the following is +2 to allow possible unknown
  ! section names and unknown retrieval names
  real, dimension(num_section_times+num_retrieval_times+num_directwrite_times+2), &
a82 3
  ! integer, parameter                 :: unknown_section = &
  !   &                               num_section_times+num_retrieval_times + 1
  ! integer, parameter                 :: unknown_retrieval = unknown_section + 1
d87 1
d106 4
d111 2
d133 5
d149 5
d163 1
a163 1
        phaseNames = trim(phaseNames) // ',' // trim(phase_name)
d191 4
d197 2
d228 4
d233 2
d278 2
d306 1
a306 8
    ! A trick:
    ! Adjust Join section timing to exclude directwrite timings
    ! (otherwise they would be counted twice)
    joinElem = StringElementNum(section_names, 'join', countEmpty)
    dwElem = StringElementNum(section_names, 'directwrite', countEmpty)
    if ( joinElem > 0 .and. dwElem > 0 ) section_timings(joinElem) = &
      &         section_timings(joinElem) - section_timings(dwElem)

a307 1
     ! & section_timings(unknown_section)
a308 6
    ! Another trick:
    ! The DirectWrite section doesn't automatically include the waiting time
    ! (due to lazy coding in Join) so add it in now
    elem = StringElementNum(directwrite_names, 'waiting', countEmpty)
    section_timings(dwElem) = section_timings(dwElem) + &
      & section_timings(num_section_times+num_retrieval_times+elem)
a316 5
    ! if ( Unknown_nonzero ) then
    !  num_elems = num_section_times + 1
    ! else
    !  num_elems = num_section_times
    ! endif
a317 4
      ! if ( elem > num_section_times ) then
      !  elem_time = section_timings(unknown_section)
      !  section_name = 'unknown name'
      ! else
a319 1
      ! endif
a378 1
        ! & section_timings(unknown_section)
a379 5
      ! if ( Unknown_nonzero ) then
      !  num_elems = num_retrieval_times + 1
      !  else
      ! num_elems = num_retrieval_times
      ! endif
a380 4
        ! if ( elem > num_retrieval_times ) then
        !  elem_time = section_timings(unknown_retrieval)
        !  section_name = 'unknown name'
        !else
a382 1
        !endif
d452 1
a452 2
    ! A trick! Add final elapsed time to last phase
    call add_to_phase_timing(' ')
d501 219
d744 3
@


2.21
log
@Fixed bug in phase names
@
text
@d15 1
d27 1
a27 1
       "$Id: MLSL2Timings.f90,v 2.20 2004/01/14 18:49:58 vsnyder Exp $"
d143 1
d493 14
d516 3
@


2.20
log
@Stuff to support the Algebra section
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d26 1
a26 1
       "$Id: MLSL2Timings.f90,v 2.19 2003/12/05 00:50:44 pwagner Exp $"
d123 2
a124 1
      elem = StringElementNum(trim(phaseNames), LowerCase(phase_name), countEmpty)
d500 3
@


2.19
log
@Numerous small bugixes related to wall clock time use
@
text
@d26 1
a26 1
       "$Id: MLSL2Timings.f90,v 2.18 2003/10/23 22:20:16 pwagner Exp $"
d44 2
a45 1
    & 'read_apriori,chunk_divide,construct,fill,retrieve,join,directwrite,output'
d47 1
a47 1
  integer, parameter                 :: num_section_times = 13  ! <--|
d499 3
@


2.18
log
@A few bugfixes in dump_section_timings
@
text
@d8 1
d10 1
d14 1
a14 1
  use Time_M, only: Time_Now
d21 1
a21 1
    & dump_section_timings
d26 1
a26 1
       "$Id: MLSL2Timings.f90,v 2.17 2003/10/22 21:19:14 pwagner Exp $"
d70 1
d228 1
d231 13
d267 7
d275 3
a277 3
    final = max(final, total)
    if ( final <= 0.0 ) final = 1.0       ! Just so we don't divide by 0
    if ( final < 0.5 .or. final > 99999.99 ) then
d298 1
a298 1
      call output ( elem_time, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d307 1
a307 1
    call output ( total, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d314 1
a314 1
    call output ( final-total, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d322 1
a322 1
    call output ( final, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d372 1
a372 1
        call output ( elem_time, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d379 1
a379 1
      call output ( retrFinal-retrTotal, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d418 1
a418 1
        call output ( elem_time, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, &
d426 1
a426 1
      call output ( dwFinal-dwTotal, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, &
d456 1
a456 1
      call output ( elem_time, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d469 1
a469 1
    call output ( final-phaseTotal, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d498 3
@


2.17
log
@Added timings breakdown by phases
@
text
@d24 1
a24 1
       "$Id: MLSL2Timings.f90,v 2.16 2003/10/20 18:21:45 pwagner Exp $"
d200 3
a202 2
  ! dump accumulated elapsed timings forsection_names

d207 1
d215 1
d217 1
d280 1
a280 1
    call blanks ( 4, advance='no' )
d282 1
a282 1
    call blanks ( 3, advance='no' )
d301 1
a301 1
    call blanks ( 8, advance='no' )
d309 2
a310 2
    final = section_timings(retrElem) 
    if ( final == 0.0 ) then
d317 1
a317 1
      call output ( final, advance='yes' )
d345 1
a345 1
        percent = 100 * elem_time / final
d355 1
a355 1
      call output ( final-retrTotal, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d357 1
a357 1
      call output ( 100*(final-retrTotal)/final, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
d366 2
a367 2
    final = section_timings(elem) 
    if ( final == 0.0 ) then
d374 1
a374 1
      call output ( final, advance='yes' )
d391 1
a391 1
        percent = 100 * elem_time / final
d402 1
a402 1
      call output ( final-dwTotal, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, &
d405 1
a405 1
      call output ( 100*(final-dwTotal)/final, FORMAT=PCTFORM, &
d421 1
a421 1
    call blanks ( 8, advance='no' )
d423 1
a423 1
    call blanks ( 8, advance='no' )
d434 6
a439 1
      call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
d474 3
@


2.16
log
@Timings breakdown added for directWrite
@
text
@d17 2
a18 1
    & add_to_directwrite_timing, add_to_retrieval_timing, add_to_section_timing, &
d24 1
a24 1
       "$Id: MLSL2Timings.f90,v 2.15 2003/08/11 23:24:48 pwagner Exp $"
d37 2
d65 3
d83 1
a83 1
    real, save                  :: myLastTime
d103 36
d150 1
a150 1
    real, save                  :: myLastTime
d181 1
a181 1
    real, save                  :: myLastTime
d215 1
d227 2
a228 9
    if ( parallel%master ) then
      call blanks ( 8, advance='no' )
      call output ( '(Master Task) ', advance='yes' )
    elseif ( parallel%slave .and. .not. parallel%fwmParallel ) then
      call blanks ( 8, advance='no' )
      call output ( '(Slave: chunk ', advance='no' )
      call output ( parallel%ChunkNo, advance='no' )
      call output ( ' ) ', advance='yes' )
    endif
d277 2
a278 2
    call output ( '(total)', advance='no' )
    call blanks ( 7, advance='no' )
d285 1
a285 1
    call blanks ( 7, advance='no' )
d293 1
a293 1
    call blanks ( 7, advance='no' )
d296 3
a298 2
    call output ( percent, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )

d323 1
a323 1
      call blanks ( 8, advance='no' )
d350 1
a350 1
      call blanks ( 7, advance='no' )
d371 37
a407 1
      call output ( '(No DirectWrite section timings breakdown) ', advance='yes' )
d410 2
d414 1
a414 1
    call output ( 'DirectWrite section timings : ', advance='yes' )
d416 1
a416 1
    call output ( 'subsection name ', advance='no' )
d420 5
a424 6
    call output ( 'percent of total DirectWrite time', advance='yes' )
    dwTotal = sum(section_timings(1+num_section_times+num_retrieval_times:)) ! - &
      ! & section_timings(unknown_section)
    do elem = 1, num_directwrite_times
      elem_time = section_timings(num_section_times+num_retrieval_times+elem)
      call GetStringElement(directwrite_names, section_name, elem, countEmpty)
d431 1
d435 2
a436 2
    call blanks ( 7, advance='no' )
    call output ( final-dwTotal, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d438 15
a452 1
    call output ( 100*(final-dwTotal)/final, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
d465 3
@


2.15
log
@Chunk no. printed if slave task
@
text
@d16 5
a20 1
  PRIVATE :: Id, ModuleName
d23 1
a23 1
       "$Id: MLSL2Timings.f90,v 2.14 2003/06/09 22:51:36 pwagner Exp $"
d39 4
a42 2
    & 'read_apriori,chunk_divide,construct,fill,retrieve,join,output'
  integer, parameter                 :: num_section_times = 12
d45 1
d48 7
a54 1
  integer, parameter                 :: num_retrieval_times = 14
d57 1
a57 1
  real, dimension(num_section_times+num_retrieval_times+2), &
d59 3
a61 3
  integer, parameter                 :: unknown_section = &
    &                               num_section_times+num_retrieval_times + 1
  integer, parameter                 :: unknown_retrieval = unknown_section + 1
d65 32
a114 5
        if ( ALLOWUNKNOWNNAMES ) then
          call time_now ( t2 )
          section_timings(unknown_retrieval) = &
            & section_timings(unknown_retrieval) + t2 - myLastTime
        else
a117 1
        endif
d145 3
a147 16
      elem = StringElementNum(retrieval_names, LowerCase(section_name), countEmpty)
      if ( elem < 1 .or. elem > num_retrieval_times ) then
        if ( ALLOWUNKNOWNNAMES ) then
          call time_now ( t2 )
          section_timings(unknown_section) = &
            & section_timings(unknown_section) + t2 - myLastTime
        else
          call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Unable to find section name ' // section_name // &
          & ' among list ' // section_names // ',' // retrieval_names )
        endif
      else
        call time_now ( t2 )
        section_timings(num_section_times+elem) = &
          & section_timings(num_section_times+elem) + t2 - myLastTime
      endif
d152 1
d165 3
d171 2
d180 1
a180 1
    Unknown_nonzero = (section_timings(unknown_section) > 0.)
d199 11
a209 2
    total = sum(section_timings(1:num_section_times)) + &
     & section_timings(unknown_section)
d218 5
a222 5
    if ( Unknown_nonzero ) then
      num_elems = num_section_times + 1
    else
      num_elems = num_section_times
    endif
d224 4
a227 4
      if ( elem > num_section_times ) then
        elem_time = section_timings(unknown_section)
        section_name = 'unknown name'
      else
d230 1
a230 1
      endif
d263 6
a268 1
    elem = StringElementNum(section_names, 'retrieve', countEmpty)
d270 52
d327 1
a327 1
      call output ( '(Retrieval section number ', advance='no' )
d334 1
a334 1
      call output ( '(No Retrieval section timings breakdown) ', advance='yes' )
d339 1
a339 1
    call output ( 'Retrieval section timings : ', advance='yes' )
d345 6
a350 17
    call output ( 'percent of total retrieval time', advance='yes' )
    total = sum(section_timings(1+num_section_times:)) - &
      & section_timings(unknown_section)
    Unknown_nonzero = (section_timings(unknown_retrieval) > 0.)
    if ( Unknown_nonzero ) then
      num_elems = num_retrieval_times + 1
    else
      num_elems = num_retrieval_times
    endif
    do elem = 1, num_elems
      if ( elem > num_retrieval_times ) then
        elem_time = section_timings(unknown_retrieval)
        section_name = 'unknown name'
      else
        elem_time = section_timings(num_section_times+elem)
        call GetStringElement(retrieval_names, section_name, elem, countEmpty)
      endif
d361 1
a361 1
    call output ( final-total, FORMAT=TIMEFORM, LOGFORMAT=TIMEFORM, advance='no' )
d363 1
a363 1
    call output ( 100*(final-total)/final, FORMAT=PCTFORM, LOGFORMAT=PCTFORM, advance='yes' )
d376 3
@


2.14
log
@Renamed scan_divide to chunk_divide in timings table
@
text
@d8 1
d19 1
a19 1
       "$Id: MLSL2Timings.f90,v 2.13 2003/02/27 21:56:07 pwagner Exp $"
d152 9
d289 3
@


2.13
log
@Passes LOGFORMAT along with FORMAT
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.12 2002/10/08 17:36:22 pwagner Exp $"
d34 1
a34 1
    & 'read_apriori,scan_divide,construct,fill,retrieve,join,output'
d279 3
@


2.12
log
@Added idents to survive zealous Lahey optimizer
@
text
@d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.11 2002/09/24 18:15:12 pwagner Exp $"
d183 1
a183 1
      call output ( elem_time, FORMAT=TIMEFORM, advance='no' )
d185 1
a185 1
      call output ( percent, FORMAT=PCTFORM, advance='yes' )
d192 1
a192 1
    call output ( total, FORMAT=TIMEFORM, advance='no' )
d194 1
a194 1
    call output ( percent, FORMAT=PCTFORM, advance='yes' )
d199 1
a199 1
    call output ( final-total, FORMAT=TIMEFORM, advance='no' )
d201 1
a201 1
    call output ( percent, FORMAT=PCTFORM, advance='yes' )
d207 1
a207 1
    call output ( final, FORMAT=TIMEFORM, advance='no' )
d209 1
a209 1
    call output ( percent, FORMAT=PCTFORM, advance='yes' )
d257 1
a257 1
      call output ( elem_time, FORMAT=TIMEFORM, advance='no' )
d259 1
a259 1
      call output ( percent, FORMAT=PCTFORM, advance='yes' )
d264 1
a264 1
    call output ( final-total, FORMAT=TIMEFORM, advance='no' )
d266 1
a266 1
    call output ( 100*(final-total)/final, FORMAT=PCTFORM, advance='yes' )
d279 3
@


2.11
log
@Prepared to allow unknown names; add_to_section_timing now like retrieval
@
text
@d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.10 2002/09/19 19:07:05 vsnyder Exp $"
d20 1
d270 4
d279 3
@


2.10
log
@Only update t1 if it's present!
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.9 2002/09/18 23:56:01 vsnyder Exp $"
d24 4
a27 2
  logical            :: SECTION_TIMES = .false.  ! Show times in each section
  logical            :: TOTAL_TIMES = .false.    ! Show total times from start
d29 1
d40 3
a42 1
  real, dimension(num_section_times+num_retrieval_times), &
d44 3
d50 1
a50 1
  ! -----------------------------------------------  add_to_retrieval_timing  -----
d55 1
a55 1
    character(LEN=*), intent(in):: section_name   ! One of the retrieval section_names
d68 6
a73 1
        call MLSMessage ( MLSMSG_Error, moduleName, &
d76 1
d93 1
a93 1
    real, intent(in)            :: t1             ! Prior time_now 
d98 1
d101 1
d106 9
a114 3
        call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Unable to find section name ' // section_name // &
        & ' among list ' // section_names // ',' // retrieval_names )
d118 1
a118 1
          & section_timings(num_section_times+elem) + t2 - t1
d122 1
a122 1
      section_timings(elem) = section_timings(elem) + t2 - t1
d124 1
d140 1
d142 2
d146 1
d156 2
a157 1
    total = sum(section_timings(1:num_section_times))
d166 5
d172 8
a179 2
      call GetStringElement(section_names, section_name, elem, countEmpty)
      percent = 100 * section_timings(elem) / final
d182 1
a182 1
      call output ( section_timings(elem), FORMAT=TIMEFORM, advance='no' )
d237 17
a253 4
    total = sum(section_timings(1+num_section_times:))
    do elem = 1, num_retrieval_times
      call GetStringElement(retrieval_names, section_name, elem, countEmpty)
      percent = 100 * section_timings(num_section_times+elem) / final
d256 1
a256 1
      call output ( section_timings(num_section_times+elem), FORMAT=TIMEFORM, advance='no' )
d274 3
@


2.9
log
@Call time_now at end of add_to_retrieval_timing
@
text
@d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.8 2002/07/23 00:06:05 pwagner Exp $"
d69 1
a69 1
      call time_now ( t1 )
d222 3
@


2.8
log
@No upper-case allowed in section names
@
text
@d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.7 2002/07/22 22:53:10 pwagner Exp $"
d48 1
a48 1
    real, optional, intent(in)  :: t1             ! Prior time_now 
d69 1
d222 3
@


2.7
log
@Added names of 2d scan model, form norm eq, and tikh reg to retrieval
@
text
@d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.6 2001/11/27 23:34:49 pwagner Exp $"
d34 1
a34 1
    & 'full_fwm,fullcloud_fwm,scan_fwm,twoDscan_fwm,linear_fwm,' // &
d221 3
@


2.6
log
@Split forward model timings into four types
@
text
@d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.5 2001/11/09 23:17:22 vsnyder Exp $"
d34 3
a36 3
    & 'full_fwm,fullcloud_fwm,scan_fwm,linear_fwm,' // &
    & 'low_cloud,high_cloud,sids'
  integer, parameter                 :: num_retrieval_times = 11
d221 3
@


2.5
log
@Use Time_Now instead of CPU_TIME
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.4 2001/10/01 23:30:50 pwagner Exp $"
d34 3
a36 2
    & 'forward_model,low_cloud,sids'
  integer, parameter                 :: num_retrieval_times = 7
d48 1
a48 1
    real, intent(in)            :: t1             ! Prior time_now 
d53 1
d56 2
d66 1
a66 1
          & section_timings(num_section_times+elem) + t2 - t1
d68 1
d221 3
@


2.4
log
@Fixed bug in spelling cholesky_solver
@
text
@d11 1
d18 1
a18 1
       "$Id: MLSL2Timings.f90,v 2.3 2001/10/01 22:54:22 pwagner Exp $"
d47 1
a47 1
    real, intent(in)            :: t1             ! Prior cpu_time 
d60 1
a60 1
        call cpu_time ( t2 )
d73 1
a73 1
    real, intent(in)            :: t1             ! Prior cpu_time 
d88 1
a88 1
        call cpu_time ( t2 )
d93 1
a93 1
      call cpu_time ( t2 )
d124 1
a124 1
    call cpu_time ( final )
d216 3
@


2.3
log
@Added subsection timings for Retrieval section
@
text
@d17 1
a17 1
       "$Id: MLSL2Timings.f90,v 2.2 2001/09/28 23:59:20 pwagner Exp $"
d57 1
a57 1
        & 'among list ' // retrieval_names )
d85 1
a85 1
        & 'among list ' // section_names // ',' // retrieval_names )
d215 3
@


2.2
log
@Fixed various timing problems
@
text
@d17 1
a17 1
       "$Id: MLSL2Timings.f90,v 2.1 2001/09/28 17:50:30 pwagner Exp $"
d31 5
a35 1
  real, dimension(num_section_times), &
d40 25
d68 1
d81 3
a83 1
      call MLSMessage ( MLSMSG_Error, moduleName, &
d85 6
a90 1
        & 'among list ' // section_names)
d102 9
a110 7
    character(LEN=*), parameter  :: TIMEFORM = '(F10.2)'
    character(LEN=*), parameter  :: PCTFORM='(F10.0)'
    integer                       :: elem
    character(LEN=16)             :: section_name   ! One of the section_names
    real                          :: final
    real                          :: total
    real                          :: percent
d122 1
a122 1
    total = sum(section_timings)
d126 5
d163 44
d215 3
@


2.1
log
@MLSL2Timings module keeps timing info
@
text
@d17 1
a17 1
       "$Id: MLSL2Timings.f90,v 2.10 2001/07/16 23:43:15 pwagner Exp $"
d23 3
a25 3
  logical            :: SECTION_TIMES=.false.  ! Show times in each section
  logical            :: TOTAL_TIMES=.false.    ! Show total times from start
  logical, private   :: COUNTEMPTY=.false.     ! Any sections named ' '?
d28 5
a32 4
    & 'open_init, global_settings, signals, spectroscopy, read_apriori, ' // &
    & 'scan_divide, construct, fill, retrieve, join, output'
  integer, parameter                 :: num_section_times = 11
  real, dimension(num_section_times) :: section_timings = 0.
d65 7
a71 5
    integer                     :: elem
    character(LEN=16)           :: section_name   ! One of the section_names
    real                        :: final
    real                        :: total
    real                        :: percent
d91 4
a94 4
      call blanks ( 8, advance='no' )
      call output ( section_timings(elem), advance='no' )
      call blanks ( 8, advance='no' )
      call output ( percent, advance='yes' )
d96 8
d105 1
d107 12
a118 4
    call blanks ( 8, advance='no' )
    call output ( final-total, advance='no' )
    call blanks ( 8, advance='no' )
    call output ( percent, advance='yes' )
d127 3
@

