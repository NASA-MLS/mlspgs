head	2.150;
access;
symbols
	v5-02-NRT-19:2.150
	v6-00:2.150
	v5-02-NRT-18:2.150
	v5-02:2.147
	v5-01-NRT-17:2.150
	v5-01-NRT-16:2.150
	v5-01-NRT-15:2.150
	v5-01-NRT-14:2.150
	neuralnetworks-1-0:2.150.0.4
	cfm-single-freq-0-1:2.150.0.2
	v5-01:2.147
	v5-00:2.147
	v4-23-TA133:2.147.0.2
	mus-emls-1-70:2.138.0.2
	rel-1-0-englocks-work:2.136.0.2
	VUMLS1-00:2.131
	VPL1-00:2.130
	V4-22-NRT-08:2.129
	VAM1-00:2.123
	V4-21:2.120.0.2
	V4-13:2.118
	V4-12:2.116
	V4-11:2.116
	V4-10:2.114
	V3-43:2.49.2.1
	M4-00:2.82
	V3-41:2.49.2.1
	V3-40-PlusGM57:2.49.0.2
	V2-24-NRT-04:2.38
	V3-33:2.55
	V2-24:2.38
	V3-31:2.55
	V3-30-NRT-05:2.53
	cfm-01-00:2.51
	V3-30:2.49
	V3-20:2.49
	V3-10:2.45
	V2-23-NRT-02:2.38
	V2-23:2.38
	V2-22-NRT-01:2.38
	V2-22:2.38
	V2-21:2.33
	V2-20:2.33
	V2-11:2.32
	V2-10:2.32
	V2-00:2.30
	V1-51:2.17
	V1-50:2.17
	V1-45:2.10
	V1-44:2.10
	V1-43:2.2;
locks; strict;
comment	@# @;


2.150
date	2020.07.22.22.53.04;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2020.04.30.23.33.42;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2020.01.27.21.34.18;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2019.03.18.22.09.34;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2018.12.11.01.26.13;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2018.11.01.23.19.13;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2018.10.19.00.03.46;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2018.10.17.23.05.04;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2018.09.13.20.22.32;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2018.09.07.00.00.15;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2018.08.04.02.10.27;	author vsnyder;	state Exp;
branches;
next	2.139;

2.139
date	2018.07.27.23.18.48;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2018.05.17.17.05.53;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2018.04.19.23.44.09;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2018.03.22.18.17.00;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2018.03.05.19.49.38;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2017.09.26.16.24.34;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2017.07.27.16.55.02;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2017.07.10.23.09.51;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2017.02.22.18.01.56;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2016.07.28.01.45.07;	author vsnyder;	state Exp;
branches;
next	2.129;

2.129
date	2016.05.18.01.37.30;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2016.04.07.23.40.28;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2016.04.01.00.27.41;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2016.02.26.02.08.18;	author vsnyder;	state Exp;
branches;
next	2.125;

2.125
date	2016.01.29.01.10.07;	author vsnyder;	state Exp;
branches;
next	2.124;

2.124
date	2015.10.06.00.23.48;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2015.09.24.22.10.17;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2015.07.14.23.32.47;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2015.04.09.21.00.32;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2015.02.27.23.13.52;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2015.02.13.00.21.17;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2014.09.05.00.48.13;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2014.08.28.19.07.16;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2014.06.11.20.06.33;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2014.05.31.00.24.55;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2014.04.25.18.53.45;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2014.04.10.02.02.22;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2014.04.10.00.45.41;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2014.03.20.01.32.11;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2014.02.28.01.10.44;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2014.02.28.00.17.05;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2013.12.12.02.09.29;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2013.11.18.22.33.28;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2013.11.07.00.26.44;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2013.10.24.21.12.19;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2013.10.17.18.27.29;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2013.10.09.23.44.13;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2013.10.08.23.52.48;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2013.09.27.00.38.12;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2013.09.25.18.46.50;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2013.09.25.16.33.27;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.96;

2.96
date	2013.09.24.00.56.02;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2013.09.21.00.38.11;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2013.09.04.16.32.51;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2013.08.31.02.29.12;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2013.08.30.23.19.28;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2013.08.29.19.37.41;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2013.08.01.20.46.30;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2013.07.12.23.24.11;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2013.05.22.20.20.49;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2013.05.17.00.55.47;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2013.05.07.22.01.30;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2013.04.24.00.36.02;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2013.04.22.17.49.20;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2013.03.30.00.19.48;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2013.02.21.21.38.10;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2013.02.12.18.17.44;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2012.12.04.00.19.14;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2012.08.16.18.03.44;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2012.06.27.17.53.04;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2012.06.06.20.20.46;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2012.05.14.22.26.31;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2012.05.11.00.16.42;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2012.05.08.17.48.37;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2012.05.01.23.18.13;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2012.04.26.23.28.33;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2012.04.20.01.29.56;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2012.04.20.01.03.30;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2012.03.28.23.14.14;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2012.03.15.22.50.39;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2012.02.28.00.16.42;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2012.02.02.00.56.00;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2011.11.04.00.29.28;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2011.08.29.22.12.13;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2011.06.02.19.25.01;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2011.05.09.18.08.57;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2011.04.20.16.47.54;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2011.04.13.00.26.17;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2011.04.04.23.07.21;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2011.03.15.23.02.45;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2011.03.08.18.28.06;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2010.11.19.23.59.23;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2010.11.05.22.37.06;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2010.08.13.22.08.57;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2010.08.06.23.08.48;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2010.04.17.01.44.26;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2010.04.16.01.39.34;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2010.02.04.23.12.44;	author vsnyder;	state Exp;
branches
	2.49.2.1;
next	2.48;

2.48
date	2009.11.02.21.22.25;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2009.10.27.22.18.18;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2009.09.15.20.03.48;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2008.12.18.21.12.00;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2008.09.30.22.00.22;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2008.06.05.02.07.43;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2007.12.07.01.12.43;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2007.11.15.22.54.51;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2007.11.05.18.36.44;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2007.10.09.00.32.05;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2007.10.03.23.53.05;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2007.08.17.00.32.16;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2007.04.03.17.37.17;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2007.01.11.20.44.55;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2006.09.21.18.48.33;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2006.07.27.03.52.41;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2006.07.19.22.26.40;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2006.06.12.16.28.25;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2006.05.31.22.38.17;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2006.05.03.20.14.05;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2006.03.22.02.19.48;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2006.03.07.16.23.52;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2006.03.07.00.49.42;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2006.01.04.01.21.30;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2005.06.03.02.06.55;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2005.05.02.23.11.37;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2005.04.01.20.48.28;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2005.03.26.01.34.00;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2005.03.15.01.36.08;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2005.01.12.03.18.51;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2004.12.28.00.22.03;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2004.12.13.20.13.04;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2004.11.04.06.37.34;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2004.11.01.20.16.20;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2004.10.30.00.26.46;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2004.10.06.20.19.39;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2004.09.24.22.24.20;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2004.07.17.02.28.19;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2004.06.12.00.41.30;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2004.06.09.19.59.38;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2004.06.08.20.20.18;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2004.05.29.02.50.49;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2004.05.22.02.31.23;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2004.05.20.19.47.36;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2004.05.18.01.18.51;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2004.05.11.02.53.29;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2004.05.01.04.04.16;	author vsnyder;	state Exp;
branches;
next	;

2.49.2.1
date	2011.11.16.23.33.51;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.150
log
@Added BooleanFromChunkStartsAfter, ..BeginsBefore functions
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module DumpCommand_M

! Process a "dump" command. Or a flow control command.
! Or functions to set a run-time "Boolean" flag.
! (Should these latter functions be moved into a special run-time module?)
! Our wiki pages have a writeup on the l2cf control structures in
! https://mls.jpl.nasa.gov/team/wiki/index.php/L2cf_Control_Structures

  use Chunks_M, only: MLSChunk_T, Dump
  use HighOutput, only: Banner, BeVerbose, HeadLine, &
    & NumToChars, OutputNamedValue
  use MLSL2Options, only: MLSL2Message
  use Output_m, only: Beep, Blanks, NewLine, Output, RevertOutput, SwitchOutput

  implicit none
  private

  public :: BooleanFromAnyGoodRadiances
  public :: BooleanFromAnyGoodValues
  public :: BooleanFromCatchWarning
  public :: BooleanFromChunkStartsAfter
  public :: BooleanFromChunkEndsBefore
  public :: BooleanFromComparingQtys
  public :: BooleanFromEmptyGrid, BooleanFromEmptySwath
  public :: BooleanFromFormula
  public :: DumpCommand, ExecuteCommand
  public :: InitializeRepeat, NextRepeat
  public :: MLSCase, MLSEndSelect, MLSSelect, Skip

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: DumpCommand_m.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -
!
!     (Data)
! MLSSelecting  true if in a Select .. Case .. EndSelect control structure
!               and the present Case doesn't match
!     (subroutines and functions)
! The following functions do much the same thing: they add to the
! runtime Boolean database a pair (key => named_Boolean, value => its_value)
! where the value is determined by whether condition is true or false
!    function                 condition
! BooleanFromAnyGoodRadiances
!               Any of the radiances have non-negative precisions
! BooleanFromAnyGoodValues
!               The quantity has any useable values (based on precision, status)
! BooleanFromCatchWarning
!               The last command resulted in a (optionally specific) warning
! BooleanFromChunkEndsBefore
!               The chunk ends before the gridded quantity's last date
! BooleanFromChunkStartsAfter
!               The chunk starts after the gridded quantity's first date
! BooleanFromComparingQuantities
!               The first quantity stands in specified relation to the second
!               E.g., formula="all a > b"
! BooleanFromEmptyGrid
!               The specified GriddedData is empty
! BooleanFromEmptySwath
!               (a) That named swath in that named file has no useable data
!               (b) The specified file can't be found
! BooleanFromFormula
!               (a) Evaluate the formula; it may be one of the forms
!               (1) Contains only "or", "and", "not" => logical result
!               (2) Contains "lhs rel rhs" where
!                   rel is one of {==, /=, <, or >}  => logical result
!               (3) A manipulation formula, signaled by the "/literal' field
!                   (see FillByManipulation)  => string-valued result
!               (b) Just store the text of the label field
!
! The following subroutines depart from the sbove pattern
! DumpCommand    Process the Dump command, dumping any of the allowed datatypes
! ExecuteCommand Execute the shell command specified in text
! InitializeRepeat
!                Set the Repeat counter "count" to 0
! NextRepeat     Add 1 to Repeat counter "count",
!                  store values[count] in "counts(n)"
! MLSCase        Process the Case control statement
! MLSSelect      Process the Select control statement
! MLSEndSelect   Process the EndSelect control statement
! Skip           Process either the Skip or the Repeat control statement
! === (end of toc) ===

! === (start of api) ===
! int BooleanFromAnyGoodRadiances ( int root, type (chunk) chunk, &
!    type(MLSFile) filedatabase(:) )
! int BooleanFromAnyGoodValues ( int root, type (vector_t) vectors(:) )
! int BooleanFromCatchWarning ( int root )
! int BooleanFromComparingQtys ( int root, type (vector_t) vectors(:) )
! int BooleanFromChunkEndsBefore ( int root, type (mlschunk_t) chunk, &
!    type (griddeddata_t) grids(:) )
! int BooleanFromChunkStartsAfter ( int root, type (mlschunk_t) chunk, &
!    type (griddeddata_t) grids(:) )
! int BooleanFromEmptyGrid ( int root, type (griddeddata_t) grids(:) )
! int BooleanFromEmptySwath ( int root )
! int BooleanFromFormula ( int name, int root, type (vector_t) vectors(:) )
! DumpCommand ( int root, type (QuantityTemplate_T) quantityTemplatesDB(:), &
!    type (vectorTemplate_T) vectorTemplates(:), &
!    type (vector_t) vectors(:), type (forwardModelConfig_t) forwardModelConfigs(:), &
!    type (HGrids_T) HGrids(:), &
!    type (GriddedData_T) GriddedDataBase(:), type (MLSFile_T) FileDataBase(:), &
!    type (Matrix_Database_T) MatrixDataBase(:), type (Hessian_T) HessianDataBase(:) )
! ExecuteCommand ( int root )
! InitializeRepeat
! NextRepeat
! MLSCase ( int root )
! MLSSelect ( int root )
! MLSEndSelect ( int root )
! Skip ( int root, char* name )
! === (end of api) ===

  interface Evaluator
    module procedure Evaluator_Sca, Evaluator_Array
  end interface

  interface outputLater
    module procedure outputLater_chars, outputLater_int, outputLater_real
  end interface

  logical :: asBanner
  logical :: asHeadLine
  logical, parameter :: countEmpty = .true. ! Except where overriden locally
  character(len=8) :: headLineChars
  integer :: lineLength
  integer, parameter :: MAXRESULTLEN = 64
  logical, public, save             :: MLSSELECTING = .false.
  logical, save               :: MLSSelectedAlready = .false.
  character(len=MAXRESULTLEN), save :: selectLabel  = ' '

  character(len=80)  :: InputFileName ! e.g., '/tmp/pause.txt'
  character(len=255) :: Text
  logical :: toStderr
  integer, save :: TotalMemory1 = 0   ! For memory usage, in kB
  integer, save :: TotalMemory2 = 0   ! For memory usage, in kB
  real, save :: T1 = 0.               ! For timing
  real, save :: T2 = 0.               ! For timing

  ! Error codes
  integer, parameter :: NoFile = + 1
  integer, parameter :: NoFileDatabase = noFile + 1
  integer, parameter :: NoFWM = noFileDatabase + 1
  integer, parameter :: noGriddedData = NoFWM + 1
  integer, parameter :: NoHGrid = noGriddedData + 1
  integer, parameter :: NoLines = noHGrid + 1
  integer, parameter :: NoQT = noLines + 1
  integer, parameter :: Noradiometers = noQT + 1
  integer, parameter :: NoSignals = noradiometers + 1
  integer, parameter :: NoTG = noSignals + 1
  integer, parameter :: NoVectors = noTG + 1
  integer, parameter :: NoVT = noVectors + 1
  integer, parameter :: Stop = noVT + 1
  integer, parameter :: Unknown = stop + 1 ! Unknown template

contains

  ! --------------------------------  BooleanFromAnyGoodRadiances  -----
  function BooleanFromAnyGoodRadiances ( root, chunk, filedatabase ) &
    & result( hashsize )
    use Allocate_Deallocate, only: Deallocate_Test
    use ConstructQuantityTemplates, only: AnyGoodSignalData
    use Init_Tables_Module, only: F_Signal, F_Boolean
    use MLSCommon, only: MLSFile_T
    use MLSL2Options, only: RuntimeValues
    use MLSSignals_M, only: GetSignalName, &
      & Signals
    use MLSStringLists, only: NumStringElements, PutHashElement
    use MLSStrings, only: Lowercase
    use Parse_Signal_M, only: Parse_Signal
    use String_Table, only: Get_String
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    ! Dummy args
    ! integer, intent(in) :: name
    integer, intent(in) :: root
    type (MLSChunk_T), intent(in) :: chunk
    type (MLSFile_T), dimension(:), pointer ::     Filedatabase
    integer             :: hashsize
    ! Internal variables
    integer :: field
    integer :: field_index
    integer :: keyNo
    character(len=32) :: nameString
    logical :: reverse
    integer :: s
    integer :: signalIndex
    integer, pointer :: Signal_Indices(:)         ! Indices in the signals
    character(len=32) :: signalString
    integer :: son
    character(len=32) :: subSignalString
    logical :: tvalue
    logical :: verbose, verboser
    ! Executable
    reverse = .false.
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    nullify(Signal_Indices)
    ! call get_string(name, nameString)
    ! nameString = lowerCase(nameString)
    signalString = ' '
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      field_index = decoration(field)

      select case ( field_index )
      case ( f_Boolean )
        call get_string( sub_rosa(subtree(2,son)), nameString )
      case ( f_signal )
        call get_string( sub_rosa(subtree(2,son)), signalString, strip=.true. )
      case default ! Can't get here if tree_checker works correctly
      end select
    end do

    if ( signalString /= ' ' ) then
      if ( verbose ) &
        & call output( 'signal: ' // trim(signalString), advance='yes' )
      call Parse_signal(signalString, signal_indices)
      tvalue = .false.
      ! Loop over signals, or-ing them until we get TRUE
      do s=1, size(signal_indices)
        signalIndex = signal_indices(s)
        if ( verbose ) then
          call GetSignalName ( signalIndex, subSignalString, &
            & sideband=signals(signalIndex)%sideband, noChannels=.TRUE. )
          call output( 'sub-signal: ' // trim(subSignalString), advance='yes' )
        end if
        tvalue = tvalue .or. &
          & AnyGoodSignalData ( signalIndex, signals(signalIndex)%sideband, &
          & filedatabase, chunk )
        if ( tvalue ) then
          if ( verbose ) then
            call output( 'good signal data found: ' &
              & // trim(subSignalString), advance='yes' )
          end if
          exit
        end if
      enddo
      call deallocate_test(Signal_Indices, 'Signal_Indices', ModuleName)
    else
      print *, 'Sorry-unable to parse ', trim(signalString)
      tvalue = .false.
    end if
    ! The following could be expressed via: tvalue =
    !    ( reverse .and. tvalue ) .or. (.not. reverse .and. .not. tvalue )
    ! but is it clearer that way? I think .not.
    if ( reverse ) tvalue = .not. tvalue
    if ( verbose ) then
      call output( trim(nameString) // ' = ', advance='no' )
      call output( tvalue, advance='yes' )
    end if
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    hashsize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verboser ) &
      & call dumpBooleans
  end function BooleanFromAnyGoodRadiances

  ! -----------------------------------  BooleanFromAnyGoodValues  -----
  function BooleanFromAnyGoodValues ( root, vectors ) result( thesize )
    use Init_Tables_Module, only: F_Precision, F_Quality, &
      & F_Quantity, F_Boolean, F_Status, F_Reverse
    use ManipulateVectorQuantities, only: AnyGoodDatainQty
    use MLSKinds, only: Rv
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: NumStringElements, PutHashElement
    use MLSStrings, only: Lowercase
    use MoreTree, only: Get_Boolean
    use String_Table, only: Get_String
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    use VectorsModule, only: Vector_T, VectorValue_T, &
      & GetVectorQtyByTemplateIndex
    ! Dummy args
    integer, intent(in) :: root
    type (vector_T), dimension(:) :: Vectors
    integer             :: thesize
    ! Internal variables
    integer :: field
    integer :: field_index
    integer :: keyNo
    character(len=32) :: nameString
    type (VectorValue_T), pointer :: Precisionquantity
    integer  :: Quantityindex
    real(rv) :: Quality_min
    type (VectorValue_T), pointer :: Qualityquantity
    type (VectorValue_T), pointer :: Quantity
    logical :: reverse
    integer :: son
    integer :: source
    type (VectorValue_T), pointer :: Statusquantity
    logical :: tvalue
    integer :: Vectorindex
    logical :: verbose, verboser
    ! Executable
    reverse = .false.
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    nullify( precisionquantity, qualityquantity, Quantity, statusquantity )
    ! call get_string(name, nameString)
    ! nameString = lowerCase(nameString)
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      field_index = decoration(field)
      source = subtree(2,son) ! required to be an n_dot vertex

      select case ( field_index )
      case ( f_Boolean )
        call get_string( sub_rosa(subtree(2,son)), nameString )
      case ( f_precision )
        VectorIndex = decoration(decoration(subtree(1,source)))
        QuantityIndex = decoration(decoration(decoration(subtree(2,source))))
        precisionQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
      case ( f_quality )
        VectorIndex = decoration(decoration(subtree(1,source)))
        QuantityIndex = decoration(decoration(decoration(subtree(2,source))))
        qualityQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
      case ( f_quantity )
        VectorIndex = decoration(decoration(subtree(1,source)))
        QuantityIndex = decoration(decoration(decoration(subtree(2,source))))
        Quantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
      case ( f_status )
        VectorIndex = decoration(decoration(subtree(1,source)))
        QuantityIndex = decoration(decoration(decoration(subtree(2,source))))
        statusQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
      case ( f_reverse )
        reverse = Get_Boolean ( son )
      case default ! Can't get here if tree_checker works correctly
      end select
    end do
    tvalue = AnyGoodDataInQty ( a=Quantity, &
      & precision=precisionQuantity, quality=qualityQuantity, &
      & status=statusQuantity, quality_min=quality_min )
    ! The following could be expressed via: tvalue =
    !    ( reverse .and. tvalue ) .or. (.not. reverse .and. .not. tvalue )
    ! but is it clearer that way? I think .not.
    if ( reverse ) tvalue = .not. tvalue
    if ( verbose ) then
      call output( trim(nameString) // ' = ', advance='no' )
      call output( tvalue, advance='yes' )
    end if
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verboser ) &
      & call dumpBooleans
  end function BooleanFromAnyGoodValues

  ! ------------------------------------  BooleanFromCatchWarning  -----
  function BooleanFromCatchWarning ( root ) result( size )
    ! Called to check if the last command resulted in a warning
    ! (either printed or suppressed)
    ! and optionally if the warning matches a supplied message string
    ! syntax:
    ! CatchWarning, [message='string'], Boolean="name"
    use Init_Tables_Module, only: F_Boolean, F_Message
    use MLSL2Options, only: RuntimeValues
    use MLSMessageModule, only: MLSMessageInquire
    use MLSStringLists, only: NumStringElements, PutHashElement
    use MLSStrings, only: Lowercase
    use String_Table, only: Get_String
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    ! Dummy args
    integer, intent(in) :: root
    integer             :: size
    ! Internal variables
    integer :: field
    integer :: field_index
    character(len=255) :: LastWarningMsg
    character(len=255) :: message
    integer :: keyNo
    character(len=32) :: nameString
    integer :: son
    logical :: tvalue
    logical :: verbose, verboser
    ! Executable
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    tvalue= .false.
    message = ' '
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      field_index = decoration(field)

      select case ( field_index )
      case ( f_Boolean )
        call get_string ( sub_rosa(subtree(2,son)), nameString, strip=.true. )
        nameString = lowerCase(nameString)
      case ( f_message )
        call get_string ( sub_rosa(subtree(2,son)), message, strip=.true. )
      case default ! Can't get here if tree_checker works correctly
      end select
    end do
    call MLSMessageInquire( LastWarningMsg=LastWarningMsg )
    if ( verbose ) then
      call outputNamedValue( 'message to match', message )
      call outputNamedValue( 'LastWarningMsg', LastWarningMsg )
    end if
    if ( len_trim(LastWarningMsg) < 1 ) then
      tvalue = .false.
    else if ( len_trim(message) < 1 ) then
      tvalue = .true.
    else
      ! tvalue = streq( message, LastWarningMsg, '-wcf' )
      ! This allows partial matches, case-insensitive
      tvalue = &
        & index( lowerCase(LastWarningMsg), lowerCase(trim(adjustl(message))) ) > 0
    end if
    if ( verbose ) then
      call output( trim(nameString) // ' = ', advance='no' )
      call output( tvalue, advance='yes' )
    end if
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    size = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verboser ) &
      & call dumpBooleans
  end function BooleanFromCatchWarning

  ! -----------------------------------  BooleanFromComparingQtys  -----
  function BooleanFromComparingQtys ( root, vectors ) result( thesize )
    use Expr_M, only: Expr
    use Init_Tables_Module, only: F_A, F_B, F_C, F_Boolean, F_Formula
    use MLSKinds, only: R8, Rv
    use MLSL2Options, only: RuntimeValues
    use MLSMessageModule, only: MLSMSG_Error
    use MLSStats1, only: MLSMax, MLSMin, MLSMean, MLSMedian
    use MLSStringLists, only: GetStringElement, NumStringElements, &
      & PutHashElement, ReplaceSubstring
    use MLSStrings, only: Lowercase
    use String_Table, only: Get_String
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    use VectorsModule, only: Vector_T, VectorValue_T, M_Fill, &
      & GetVectorQtyByTemplateIndex
    ! Dummy args
    ! Called to endow Boolean with result from comparing
    ! (1) Two quantities (a and b), or
    ! (2) A quantity and a constant (a and c)
    ! The comparison op may be one of "<", ">", or "='
    ! and the "flattening" to be taken may be one of
    ! "any", "all", "min", "max", "mean", or "median"
    ! E.g., to compare a=a.qty and b=b.qty, returning true if
    ! all(a.qty%values > b.qty%values)
    ! formula = "all a > b"

    ! in general we will parse formula as being made up by
    ! "flattening a op [b][c]"

    ! Compare, a=a.qty, [b=b.qty], [c=c], formula="formula", Boolean="name"
    integer, intent(in) :: root
    type (vector_T), dimension(:) :: Vectors
    integer             :: thesize
    ! Internal variables
    type (VectorValue_T), pointer :: AQuantity
    type (VectorValue_T), pointer :: BQuantity
    real(rv) :: A, B, C                       ! constant "c" in formula
    integer :: field
    integer :: field_index
    character(len=8) :: flattening, arg(2), op
    character(len=255) :: formula
    character(len=255) :: formulaTemp
    integer :: keyNo
    integer :: Me = -1                   ! String index for trace cacheing
    character(len=32) :: nameString
    integer :: QUANTITYINDEX
    integer :: son
    integer :: source
    logical :: tvalue
    integer, dimension(2) :: UNITASARRAY ! From expr
    real(r8), dimension(2) :: VALUEASARRAY ! From expr
    integer :: VECTORINDEX
    logical :: verbose, verboser

    ! Executable
    call trace_begin ( me, "BooleanFromComparingQtys", cond=.false. )
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    nullify( aQuantity, bQuantity )
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      field_index = decoration(field)
      source = subtree(2,son) ! required to be an n_dot vertex

      select case ( field_index )
      case ( f_Boolean )
        call get_string( sub_rosa(subtree(2,son)), nameString )
      case ( f_a )
        VectorIndex = decoration(decoration(subtree(1,source)))
        QuantityIndex = decoration(decoration(decoration(subtree(2,source))))
        aQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
      case ( f_b )
        VectorIndex = decoration(decoration(subtree(1,source)))
        QuantityIndex = decoration(decoration(decoration(subtree(2,source))))
        bQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
      case(f_c)
        call expr ( source, unitAsArray, valueAsArray )
        c = valueAsArray(1)
      case ( f_formula )
        call get_string ( sub_rosa(subtree(2,son)), formula, strip=.true. )
      case default ! Can't get here if tree_checker works correctly
      end select
    end do
    ! What kind of flattening, relationship, and is the last arg b or c?
    ! 1st--let's separate args and ops neatly
    call ReplaceSubString( formula, formulaTemp, '(', ' & ', &
      & which='all', no_trim=.true. )
    call ReplaceSubString( formulaTemp, formula, '&', '(', &
      & which='all', no_trim=.false. )
    call ReplaceSubString( formula, formulaTemp, ')', ' & ', &
      & which='all', no_trim=.true. )
    call ReplaceSubString( formulaTemp, formula, '&', ')', &
      & which='all', no_trim=.false. )
    call ReplaceSubString( formula, formulaTemp, '==', ' = ', &
      & which='first', no_trim=.true. )
    call ReplaceSubString( formulaTemp, formula, '=', ' = ', &
      & which='first', no_trim=.true. )
    call ReplaceSubString( formula, formulaTemp, '>', ' > ', &
      & which='first', no_trim=.true. )
    call ReplaceSubString( formulaTemp, formula, '<', ' < ', &
      & which='first', no_trim=.true. )
    ! 2nd--go through the elements
    call GetStringElement ( trim(formula), flattening, 1, &
            & countEmpty=.false., inseparator=' ' )
    call GetStringElement ( trim(formula), arg(1), 2, &
            & countEmpty=.false., inseparator=' ' )
    call GetStringElement ( trim(formula), op, 3, &
            & countEmpty=.false., inseparator=' ' )
    call GetStringElement ( trim(formula), arg(2), 4, &
            & countEmpty=.false., inseparator=' ' )
    flattening = lowerCase(flattening)
    arg(1) = lowerCase(arg(1))
    arg(2) = lowerCase(arg(2))
    if ( arg(1) /= 'a' ) then
      call MLSL2Message (MLSMSG_Error, moduleName, &
        & 'Formula in compare must be "flattening a op [b][c]".' )
    else if( index('<>=', trim(op)) < 1 ) then
      call MLSL2Message (MLSMSG_Error, moduleName, &
        & 'Formula in compare found unrecognized relation: ' // trim(op) )
    end if
    ! What kind of flattening?
    select case (flattening)
    case ('all')
      if ( .not. associated ( aQuantity%mask ) ) then
        tvalue = all ( isRelation( trim(op), aQuantity%values, c ) )
        if ( arg(2) == 'b' ) &
          & tvalue = all ( isRelation( trim(op), aQuantity%values, bQuantity%values ) )
      else
        tvalue = all ( isRelation( trim(op), aQuantity%values, c ) .or. &
          & iand ( ichar(aQuantity%mask(:,:)), m_fill ) /= 0 )
        if ( arg(2) == 'b' ) &
        tvalue = all ( isRelation( trim(op), aQuantity%values, bQuantity%values ) .or. &
          & iand ( ichar(aQuantity%mask(:,:)), m_fill ) /= 0 )
      end if
    case ('any')
      if ( .not. associated ( aQuantity%mask ) ) then
        tvalue = any ( isRelation( trim(op), aQuantity%values, c ) )
        if ( arg(2) == 'b' ) &
          & tvalue = any ( isRelation( trim(op), aQuantity%values, bQuantity%values ) )
      else
        tvalue = any ( isRelation( trim(op), aQuantity%values, c ) .and. &
          & iand ( ichar(aQuantity%mask(:,:)), m_fill ) == 0 )
        if ( arg(2) == 'b' ) &
        tvalue = any ( isRelation( trim(op), aQuantity%values, bQuantity%values ) .and. &
          & iand ( ichar(aQuantity%mask(:,:)), m_fill ) == 0 )
      end if
    case ('max', 'min', 'mean', 'median')
      a = statFun( trim(flattening), aQuantity%values, aQuantity%mask )
      b = c
      if ( arg(2) == 'b' ) &
        & b = statFun( trim(flattening), bQuantity%values, aQuantity%mask )
      tvalue = isRelation( trim(op), a, b )
    case default
      call MLSL2Message (MLSMSG_Error, moduleName, &
        & 'Formula in compare found unrecognized op: ' // trim(op) )
    end select
    if ( verbose ) then
      call output( trim(nameString) // ' = ', advance='no' )
      call output( tvalue, advance='yes' )
    end if
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verboser ) &
      & call dumpBooleans
    call trace_end ( "BooleanFromComparingQtys", cond=.false. )

  contains

    elemental logical function isRelation( relation, a, b )
      ! Do inputs a and b stand in relation ('>', '<', '=') ?
      ! Args
      character(len=*), intent(in) :: relation ! ('>', '<', '=')
      real(rv), intent(in) :: a, b
      ! Executable
      select case (trim(relation))
      case ('<')
        isRelation = (a < b )
      case ('>')
        isRelation = (a > b )
      case ('=')
        isRelation = (a == b )
      case default
        ! We should never have reached here
        isRelation = .false.
      end select
    end function isRelation

    function STATFUN ( name, values, mask )
      ! Evaluate statistical function name of values
      ! masking if appropriate
      ! Args
      use MLSCommon, only: defaultUndefinedValue
      character(len=*), intent(in)         :: name ! 'min', etc.
      real(rv), dimension(:,:), intent(in) :: values
      character, dimension(:,:), pointer :: MASK
      real(rv) :: statFun
      ! Internal variables
      real(rv), dimension(size(values,1),size(values,2)) :: array
      real(rv) :: FillValue
      ! Executable
      FillValue = DEFAULTUNDEFINEDVALUE
      if ( associated(mask) ) then
        array = DEFAULTUNDEFINEDVALUE
        where ( iand ( ichar(mask(:,:)), m_Fill ) == 0 )
          array(:,:) = values(:,:)
        end where
      else
        array = values
      end if
      select case (trim(name))
      case ('max')
        statFun = mlsmax( array, FillValue=FillValue )
      case ('min')
        statFun = mlsmin( array, FillValue=FillValue )
      case ('mean')
        statFun = mlsmean( array, FillValue=FillValue )
      case ('median')
        statFun = mlsmedian( array, FillValue=FillValue )
      case default
        ! Should not have got here
        statFun = mlsmedian( array, FillValue=FillValue )
      end select
    end function statFun
  end function BooleanFromComparingQtys

  ! ------------------------------------- BooleanFromChunkEndsBefore --
  function BooleanFromChunkEndsBefore ( root, chunk, grids ) result( thesize )
    use Dump_0, only: Dump
    use Init_Tables_Module, only: F_Boolean, F_Grid, F_Reverse
    use GriddedData, only: GriddedData_T, Dump
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: NumStringElements, PutHashElement
    use MLSStrings, only: Lowercase
    use MoreTree, only: Get_Boolean
    use String_Table, only: Get_String
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    ! Dummy args
    integer, intent(in) :: root
    type (Griddeddata_T), dimension(:), pointer :: Grids
    type (MLSChunk_T)                           :: Chunk
    integer                                     :: thesize
    ! Internal variables
    integer :: field
    integer :: field_index
    integer :: fieldValue
    type (Griddeddata_T), pointer :: grid
    integer :: keyNo
    character(len=32) :: nameString
    logical :: reverse
    integer :: son
    logical :: tvalue
    integer :: value
    logical :: verbose, verboser
    ! Executable
    reverse = .false.
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
        value = subtree(2,son)
      else
        fieldValue = son
        value = 0
      end if
      field_index = decoration(field)

      select case ( field_index )
      case ( f_Boolean )
        call get_string( sub_rosa(subtree(2,son)), nameString )
      case ( f_grid )
        grid => grids ( decoration ( decoration ( value ) ) )
      case ( f_reverse )
        reverse = Get_Boolean ( son )
      end select
    end do
    tvalue = .true.
    if ( associated(grid) ) tvalue = (chunk%EndTime < grid%DateStarts(1))
    ! The following could be expressed via: tvalue =
    !    ( reverse .and. tvalue ) .or. (.not. reverse .and. .not. tvalue )
    ! but is it clearer that way? I think .not.
    if ( reverse ) tvalue = .not. tvalue
    if ( verbose ) then
      call headLine( 'Checking for chunk ending before grid' )
      call output( trim(nameString) // ' = ', advance='no' )
      call output( tvalue, advance='yes' )
      call outputNamedValue( 'Chunk Ends at', chunk%EndTime )
      call outputNamedValue( 'Grid Starts at', grid%DateStarts(1) )
      call dump (chunk)
      if ( verboser ) call dump( grid, details=-2 )
    end if
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verboser ) &
      & call dumpBooleans
  end function BooleanFromChunkEndsBefore

  ! ------------------------------------- BooleanFromChunkStartsAfter --
  function BooleanFromChunkStartsAfter ( root, chunk, grids ) result( thesize )
    use Dump_0, only: Dump
    use Init_Tables_Module, only: F_Boolean, F_Grid, F_Reverse
    use GriddedData, only: GriddedData_T, Dump
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: NumStringElements, PutHashElement
    use MLSStrings, only: Lowercase
    use MoreTree, only: Get_Boolean
    use String_Table, only: Get_String
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    ! Dummy args
    integer, intent(in) :: root
    type (Griddeddata_T), dimension(:), pointer :: Grids
    type (MLSChunk_T)                           :: Chunk
    integer                                     :: thesize
    ! Internal variables
    integer :: field
    integer :: field_index
    integer :: fieldValue
    type (Griddeddata_T), pointer :: grid
    integer :: keyNo
    character(len=32) :: nameString
    logical :: reverse
    integer :: son
    logical :: tvalue
    integer :: value
    logical :: verbose, verboser
    ! Executable
    reverse = .false.
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
        value = subtree(2,son)
      else
        fieldValue = son
        value = 0
      end if
      field_index = decoration(field)

      select case ( field_index )
      case ( f_Boolean )
        call get_string( sub_rosa(subtree(2,son)), nameString )
      case ( f_grid )
        grid => grids ( decoration ( decoration ( value ) ) )
      case ( f_reverse )
        reverse = Get_Boolean ( son )
      end select
    end do
    tvalue = .true.
    if ( associated(grid) ) tvalue = (chunk%StartTime > grid%DateEnds(1))
    ! The following could be expressed via: tvalue =
    !    ( reverse .and. tvalue ) .or. (.not. reverse .and. .not. tvalue )
    ! but is it clearer that way? I think .not.
    if ( reverse ) tvalue = .not. tvalue
    if ( verbose ) then
      call headLine( 'Checking for chunk starting after grid' )
      call output( trim(nameString) // ' = ', advance='no' )
      call output( tvalue, advance='yes' )
      call outputNamedValue( 'Chunk Starts at', chunk%StartTime )
      call outputNamedValue( 'Grid Ends at', grid%DateEnds(1) )
      call dump (chunk)
      if ( verboser ) call dump( grid, details=-2 )
    end if
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verboser ) &
      & call dumpBooleans
  end function BooleanFromChunkStartsAfter

  ! ------------------------------------- BooleanFromEmptyGrid --
  function BooleanFromEmptyGrid ( root, grids ) result( thesize )
    use Dump_0, only: Dump
    use Init_Tables_Module, only: F_Boolean, F_Grid, F_Reverse
    use GriddedData, only: GriddedData_T, Dump
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: NumStringElements, PutHashElement
    use MLSStrings, only: Lowercase
    use MoreTree, only: Get_Boolean
    use String_Table, only: Get_String
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    ! Dummy args
    integer, intent(in) :: root
    type (Griddeddata_T), dimension(:), pointer :: Grids
    integer             :: thesize
    ! Internal variables
    integer :: field
    integer :: field_index
    integer :: fieldValue
    type (Griddeddata_T), pointer :: grid
    integer :: keyNo
    character(len=32) :: nameString
    logical :: reverse
    integer :: son
    logical :: tvalue
    integer :: value
    logical :: verbose, verboser
    ! Executable
    reverse = .false.
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
        value = subtree(2,son)
      else
        fieldValue = son
        value = 0
      end if
      field_index = decoration(field)

      select case ( field_index )
      case ( f_Boolean )
        call get_string( sub_rosa(subtree(2,son)), nameString )
      case ( f_grid )
        grid => grids ( decoration ( decoration ( value ) ) )
      case ( f_reverse )
        reverse = Get_Boolean ( son )
      end select
    end do
    tvalue = .true.
    if ( associated(grid) ) tvalue = grid%empty
    ! The following could be expressed via: tvalue =
    !    ( reverse .and. tvalue ) .or. (.not. reverse .and. .not. tvalue )
    ! but is it clearer that way? I think .not.
    if ( reverse ) tvalue = .not. tvalue
    if ( verbose ) then
      if ( verboser ) call headLine( 'Checking for empty grid' )
      call output( trim(nameString) // ' = ', advance='no' )
      call output( tvalue, advance='yes' )
      if ( verboser ) call dump( grid, details=-2 )
    end if
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verboser ) &
      & call dumpBooleans
  end function BooleanFromEmptyGrid

  ! ------------------------------------- BooleanFromEmptySwath --
  ! Returns TRUE if, according to use case (a) or (b)
  ! (a) there are no useable data points in the swath
  ! (or if the swath is not in the file at all)
  ! The useablility criterion is
  ! (1) Precision non-negative; and
  ! (2) Status even
  ! If even one point is useable (a very low bar, admittedly) then
  ! return FALSE
  ! or
  ! (b) the file named in the file= field does not exist at all
  function BooleanFromEmptySwath ( root ) result( thesize )
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Dump_0, only: Dump
    use Init_Tables_Module, only: F_Boolean, F_File, F_NoPCFid, &
      & F_Reverse, F_Swath, F_Type, &
      & Field_First, Field_Last, &
      & L_DAO, L_GEOS5, L_GEOS5_7, L_Merra, L_Merra_2, L_L2dgg, L_L2gp, L_None
    use L2GPData, only: L2GPData_T, Rgp, L2GPNameLen, &
      & ReadL2GPData, DestroyL2GPContents
    use MLSCommon, only: Filenamelen
    use MLSFiles, only: HDFversion_5, MLS_Exists
    use MLSHDFeos, only: MLS_Swath_In_File
    use MLSMessageModule, only: MLSMSG_Warning
    use MLSL2Options, only: RuntimeValues
    use MLSPCF2, only: MLSPCF_L2GP_End, MLSPCF_L2GP_Start, &
      & MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End, &
      & MLSPCF_L2DAO_Start, MLSPCF_L2DAO_End, &
      & MLSPCF_L2GEOS5_Start, MLSPCF_L2GEOS5_End
    use MLSStringLists, only: NumStringElements, PutHashElement
    use MLSStrings, only: Lowercase
    use MoreTree, only: Get_Boolean
    use String_Table, only: Get_String
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    ! Dummy args
    integer, intent(in) :: root
    integer             :: thesize
    ! Internal variables
    integer :: field
    integer :: field_index
    integer :: fieldValue
    integer :: fileType
    character (len=FileNameLen) :: File_base    ! From the FILE= field
    character(len=FileNameLen) :: filename          ! filename
    logical, dimension(field_first:field_last) :: got
    character(len=L2GPNAMELEN) :: swathname         ! swathname
    integer :: i
    integer :: keyNo
    character(len=32) :: nameString
    logical :: noPCFid
    logical :: reverse
    integer :: son
    logical :: tvalue
    integer :: value
    type (L2GPData_T) :: l2gp
    integer :: numGood
    logical, dimension(:), pointer  :: negativePrec => null() ! true if all prec < 0
    logical, dimension(:), pointer  :: oddStatus => null() ! true if all status odd
    logical :: verbose, verboser
    ! Executable
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    noPCFid = .false.
    reverse = .false.
    got     = .false.
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
        value = subtree(2,son)
      else
        fieldValue = son
        value = 0
      end if
      field_index = decoration(field)
      got(field_Index) = .true.
      select case ( field_index )
      case ( f_Boolean )
        call get_string( sub_rosa(subtree(2,son)), nameString )
      case ( f_file )
        call get_string ( sub_rosa(subtree(2,son)), file_base, strip=.true. )
      case ( f_noPCFid )
        noPCFid = get_Boolean(son)
      case ( f_reverse )
        reverse = Get_Boolean ( son )
      case ( f_swath )
        call get_string ( sub_rosa(subtree(2,son)), swathname, strip=.true. )
      case ( f_type )
        filetype = decoration(subtree(2, son))
      end select
    end do
    if ( .not. got(f_type) .or. noPCFid ) fileType = l_none
    select case (fileType)
    case ( l_l2dgg )
      call returnFullFileName( file_base, Filename, &
        & MLSPCF_l2dgg_start, MLSPCF_l2dgg_end )
    case ( l_l2gp )
      call returnFullFileName( file_base, Filename, &
        & MLSPCF_l2gp_start, MLSPCF_l2gp_end )
    case ( l_dao )
      call returnFullFileName( file_base, Filename, &
        & mlspcf_l2dao_start, mlspcf_l2dao_end )
    case ( l_geos5, l_geos5_7, l_merra, l_merra_2 ) ! --- GMAO Data (GEOS5*)
      call returnFullFileName( file_base, Filename, &
        & mlspcf_l2geos5_start, mlspcf_l2geos5_end )
    case ( l_none )
      Filename = file_base
    case default
      call MLSL2Message( MLSMSG_Warning, ModuleName, &
      & "type should have been either l2gp or dgg; assume you meant dgg" )
    end select
    tvalue = .true.
    if ( fileType == l_none ) then
      tvalue = ( mls_exists ( Filename ) /= 0 )
    elseif ( mls_swath_in_file( filename, swathname, HDFVERSION_5 ) ) then
      call output( 'Reading swath ' // trim(swathname), advance='yes' )
      call ReadL2GPData ( trim(filename), trim(swathname), l2gp, &
        & hdfVersion=HDFVERSION_5 )
      call allocate_test( negativePrec, l2gp%nTimes, 'negativePrec', ModuleName )
      call allocate_test( oddStatus, l2gp%nTimes, 'oddStatus', ModuleName )
      do i=1, l2gp%nTimes
        negativePrec(i) = all( l2gp%l2GPPrecision(:,:,i) < 0._rgp )
      enddo
      do i=1, l2gp%nTimes
        oddStatus(i) = mod(l2gp%status(i), 2) > 0
      enddo
      numGood = count( .not. ( negativePrec .or. &
        & (mod(l2gp%status, 2) > 0) ) )
      tvalue = ( numGood < 1 )
      if ( verbose ) then
        call dump( negativePrec, 'num surfs with prec < 0' )
        call dump( oddStatus, 'num surfs with odd status' )
        call outputNamedValue ( 'empty swath?', tvalue )
      end if
      call deallocate_test( negativePrec, 'negativePrec', ModuleName )
      call deallocate_test( oddStatus, 'oddStatus', ModuleName )
      call DestroyL2GPContents ( l2gp )
    end if
    if ( reverse ) tvalue = .not. tvalue
    if ( verbose ) then
      call output( trim(nameString) // ' = ', advance='no' )
      call output( tvalue, advance='yes' )
    end if
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verboser ) &
      & call dumpBooleans
  end function BooleanFromEmptySwath

  ! ------------------------------------------- BooleanFromFormula -----
  function BooleanFromFormula ( name, root, vectors ) result( size )
    ! Called either when a Boolean is first declared
    ! syntax:
    ! name: Boolean, formula="formula"
    !
    ! or when it is reevaluated
    ! syntax:
    ! Reevaluate, formula="formula", Boolean="name",
    ! [a=a.qty], [b=b.qty], [c=value], [values=..], [/literal]
    use Dump_0, only: Dump
    use Expr_M, only: Expr
    use Init_Tables_Module, only: F_A, F_B, F_Boolean, F_C, &
      & F_Evaluate, F_Expr, &
      & F_Formula, F_InputBoolean, F_Truncate, &
      & F_Label, F_Literal, F_Manipulation, F_Values, &
      & Field_First, Field_Last
    use Manipulationutils, only: Manipulate
    use MLSKinds, only: R8, Rv
    use MLSL2Options, only: RuntimeValues
    use MLSMessageModule, only: MLSMSG_Error
    use MLSStringLists, only: EvaluateFormula, GetHashElement, &
      & InsertHashElement, NumStringElements, PutHashElement
    use MLSStrings, only: Lowercase, ReadNumsFromChars, WriteIntsToChars
    use Moretree, only: Get_Boolean
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate
    use String_Table, only: Get_String
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    use VectorsModule, only: Vector_T, VectorValue_T, &
      & CloneVectorQuantity, CreateVectorValue, &
      & DestroyVectorQuantityValue, Dump, &
      & GetVectorQtyByTemplateIndex
    ! Dummy args
    integer, intent(in) :: Name
    integer, intent(in) :: Root
    type (vector_T), dimension(:), optional, target :: VECTORS
    integer             :: SIZE
    ! Internal variables
    character(len=80) :: Booleanstring  ! E.g., 'BAND8'
    real(rv) :: C                       ! constant "c" in formula
    type (VectorValue_T), pointer :: AQuantity
    type (VectorValue_T), target  :: ATarget
    type (VectorValue_T), pointer :: BQuantity
    character(len=32) :: cnameString
    character(len=32) :: cvalue
    logical :: evaluate
    integer :: field
    integer :: field_index
    integer :: fieldValue
    character(len=255) :: formula
    logical, dimension(field_first:field_last) :: GOT
    logical :: truncate
    integer :: J
    integer :: keyNo
    character(len=80) :: Keystring
    logical :: literal
    character(len=32) :: nameString
    integer :: Nvalues
    integer :: Quantityindex
    integer :: son
    integer :: source
    type (VectorValue_T) :: TQuantity ! Temporary
    type(QuantityTemplate_T) :: TTemplate
    logical :: tvalue
    integer :: value_field
    integer, dimension(2)  :: Unitasarray ! From expr
    real(r8), dimension(2) :: Valueasarray ! From expr
    integer :: Vectorindex
    logical :: verbose, verboser
    ! Executable
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    nullify( aQuantity, bQuantity )
    c = 0._rv
    evaluate = .false.
    truncate = .false.
    literal = .false.
    tvalue = .false.
    got = .false.
    if ( name > 0 ) then
      call get_string(name, nameString)
      nameString = lowerCase(nameString)
    end if
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(decoration(subtree(2,son))) ! The field's value
        source = subtree(2,son) ! required to be an n_dot vertex
      else
        fieldValue = son
        source = son
      end if
      field_index = decoration(field)
      got(field_Index) = .true.

      select case ( field_index )
      case ( f_a )
        VectorIndex = decoration(decoration(subtree(1,source)))
        QuantityIndex = decoration(decoration(decoration(subtree(2,source))))
        aQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
        call dump( aQuantity )
      case ( f_b )
        VectorIndex = decoration(decoration(subtree(1,source)))
        QuantityIndex = decoration(decoration(decoration(subtree(2,source))))
        bQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
        call dump( bQuantity )
      case ( f_c )
        call expr ( source, unitAsArray, valueAsArray )
        ! c is a numeric value
        c = valueAsArray(1)
        if ( verbose ) call outputNamedValue( 'c', c )
      case ( f_inputBoolean )
        call get_string ( sub_rosa(subtree(2,son)), cnameString, strip=.true. )
        cnameString = lowerCase(cnameString)
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & cnameString, cvalue, countEmpty=countEmpty, &
          & inseparator=runTimeValues%sep )
        call readNumsFromChars ( cvalue, c )
        if ( verbose ) call outputNamedValue( 'c', c )
      case ( f_Boolean )
        call get_string ( sub_rosa(subtree(2,son)), nameString, strip=.true. )
        nameString = lowerCase(nameString)
      case ( f_evaluate )
        ! call output( 'processing evaluate', advance='yes' )
        evaluate = get_Boolean ( fieldValue )
        if ( verbose ) call outputNamedValue( 'evaluate', evaluate )
      case ( f_expr )
        call MLSL2Message ( MLSMSG_Error, moduleName, &
          & 'No code yet to handle "expr" field.' )
      case ( f_formula, f_manipulation )
        call get_string ( sub_rosa(subtree(2,son)), formula, strip=.true. )
        tvalue = myBooleanValue (formula)
        if ( verbose ) call outputNamedValue ( 'tvalue', trim(formula) )
      case ( f_truncate )
        ! call output( 'processing truncate', advance='yes' )
        truncate = get_Boolean ( fieldValue )
        if ( verbose ) call outputNamedValue( 'truncate', truncate )
      case ( f_label )
        call get_string ( sub_rosa(subtree(2,son)), formula, strip=.true. )
        literal = .true.
      case ( f_literal )
        ! call output( 'processing literal', advance='yes' )
        literal = get_Boolean ( fieldValue )
        if ( verbose ) call outputNamedValue( 'literal', literal )
      case ( f_values )
        value_field = son
      case default ! Can't get here if tree_checker works correctly
      end select
    end do
    ! Should have exactly one of
    ! [f_values, f_formula, f_manipulation, f_label]
    if ( count(got( (/f_values, f_formula, f_manipulation, f_label/) ) ) > 1 ) &
      & call announceError ( son, 0, &
      & ' Must supply exactly one of (values, formula, manipulation, label)' )
    if ( verbose .and. len_trim(formula) > 0 ) &
      & call outputNamedValue ( 'formula', trim(formula) )
    if ( evaluate .and. got(f_formula) ) then
      formula = EvaluateTermwise( formula )
      if ( verbose ) call outputNamedValue ( 'formula', trim(formula) )
    end if
    if ( got(f_formula) ) then
      ! Are we in the middle of a Repeat loop? If so, replace each "${n}" with
      ! "${count}"
       call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
         & 'count', cvalue, countEmpty=countEmpty, &
         & inseparator=runTimeValues%sep )
       call readNumsFromChars ( cvalue, c )
       if ( verboser ) call outputnamedValue ( 'c', c )
       if ( c > 0._rv ) &
         & formula = EvaluateFormula ( formula, (/cvalue/), (/"n"/) )
      ! The next will explicitly evaluate run-time Booleans evoked by name via
      ! "${name}"
      if ( verboser ) call outputNamedValue ( 'formula (2nd)', trim(formula) )
      formula =  EvaluateExplicitly( formula )
      if ( verboser ) call outputNamedValue ( 'formula (3rd)', trim(formula) )
    end if
    nvalues = 0
    if ( got(f_values) ) then
      nvalues = nsons(value_field)-1
    end if
    if ( nvalues == 1 ) then
      ! We just treat this as a normal definition or reevaluation of
      ! the named Boolean treated as a scalar
      call get_string( sub_rosa(subtree(2, value_field)), BooleanString, &
        & strip=.true. )
      call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
        & lowercase(trim(nameString)), BooleanString, &
        & countEmpty=countEmpty, &
        & inseparator=runTimeValues%sep )
    elseif ( nvalues > 1 ) then
      ! Given an array of values we store them according to the scheme:
      !        key             value
      !      "name(1)"      "values(1)"
      !      "name(2)"      "values(2)"
      !           .   .   .   .   .
      !  "name(nvalues)"   "values(nvalues)"
      ! where "name" is the named Boolean
      call writeIntsToChars( nvalues, BooleanString )
      keyString = trim(nameString) // 'n'
      call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
        & keyString, BooleanString, &
        & countEmpty=countEmpty, &
        & inseparator=runTimeValues%sep )
      if ( verboser ) then
        call outputnamedValue( 'keyString', trim(keyString) )
        call outputnamedValue( 'BooleanString', trim(BooleanString) )
      end if
      ! see also how the Repeat command treats the values field
      do j=2, nvalues+1
        call writeIntsToChars( j-1, keyString )
        keyString = trim(nameString) // '(' // trim(adjustl(keystring)) // ')'
        call get_string( sub_rosa(subtree(j, value_field)), BooleanString, strip=.true. )
        if ( verboser ) then
          call outputnamedValue( 'keyString', trim(keyString) )
          call outputnamedValue( 'BooleanString', trim(BooleanString) )
        end if
        call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
          & keyString, BooleanString, &
          & countEmpty=countEmpty, &
          & inseparator=runTimeValues%sep )
      enddo
    elseif ( got(f_manipulation) ) then
      ! print *, 'Oops-you dummy! code this missing piece'
      if ( .not. present(vectors) ) &
        & call MLSL2Message ( MLSMSG_Error, moduleName, &
        & 'Cant set manipulation from this section--only Fill or Retrieval' )
      if ( .not. got ( f_a ) ) then
        call setupNewquantitytemplate( tTemplate )
        aQuantity => aTarget
        aQuantity%template = tTemplate
        call CreateVectorValue ( aQuantity, 'a' )
      end if
      call CloneVectorQuantity ( TQuantity, aQuantity )
      if ( verboser ) then
        call output( trim(nameString) // ' = ', advance='no' )
        call output( trim(formula), advance='yes' )
      end if
      call Manipulate( TQuantity, AQuantity, BQuantity, C, formula, &
        & .false., '' )
      formula = numToChars ( TQuantity%values(1,1) )
      if ( truncate ) formula = numToChars ( int(TQuantity%values(1,1)) )
      call insertHashElement ( nameString, formula, &
        & runTimeValues%lkeys, runTimeValues%lvalues, &
        & inseparator=runTimeValues%sep )
      call destroyVectorQuantityValue ( TQuantity, &
        & destroyMask=.true., destroyTemplate=.false. )
    elseif ( literal ) then
      ! print *, 'Oops-you dummy! code this missing piece'
      if ( verboser ) then
        call output( trim(nameString) // ' = ', advance='no' )
        call output( trim(formula), advance='yes' )
      end if
      call insertHashElement ( nameString, formula, &
        & runTimeValues%lkeys, runTimeValues%lvalues, &
        & inseparator=runTimeValues%sep )
    else
      if ( verbose ) call output( 'Using default value for bare Boolean declaration', &
        & advance='yes' )
      if ( verboser ) then
        call output( trim(nameString) // ' = ', advance='no' )
        call output( tvalue, advance='yes' )
      end if
      call insertHashElement ( nameString, BooleanToString(tvalue), &
        & runTimeValues%lkeys, runTimeValues%lvalues, &
        & inseparator=runTimeValues%sep )
    end if
    size = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    if ( verbose ) &
      & call dumpBooleans
  end function BooleanFromFormula

  ! ------------------------------------------------  DumpCommand  -----
  subroutine DumpCommand ( root, quantityTemplatesDB, &
    & vectorTemplates, vectors, forwardModelConfigs, hGrids, griddedDatabase, &
    & fileDatabase, matrixDatabase, hessianDatabase )

  ! Process a "dump" command

    use AntennaPatterns_M, only: Dump_Antenna_Patterns_Database
    use BitStuff, only: DumpBitCounts, DumpBitNames
    use Calendar, only: Duration_Formatted, Time_T, Tk
    use Call_Stack_M, only: Dump_Stack
    use ChunkDivideConfig_M, only: ChunkDivideConfig, Dump
    use Declaration_Table, only: Dump_A_Decl, Decls, Get_Decl, Variable
    use Diff_1, only: Diff
    use Dump_Options, only: PrintNameAsHeadline, PrintNameInBanner, RMSFormat
    use Dump_0, only: Dump
    use Expr_M, only: Expr
    use FilterShapes_M, only: Dump_Filter_Shapes_Database, &
      & Dump_Dacs_Filter_Database
    use Forwardmodelconfig, only: Dump, Forwardmodelconfig_T
    use GriddedData, only: Diff, Dump, GriddedData_T
    use HessianModule_1, only: Hessian_T, Diff, Dump
    use HGridsDatabase, only: Dump, HGrids_T
    use Igrf_Int, only: Dump_Gh
    use Init_Tables_Module, only: F_AllBooleans, F_AllFiles, &
      & F_Allforwardmodels, F_AllgriddedData, F_Allhessians, F_Allhgrids, &
      & F_Alll2pcs, F_Alllines, F_Allmatrices, F_Allpfa, &
      & F_AllquantityTemplates, F_Allradiometers, F_Allsignals, F_Allspectra, &
      & F_AllVectors, F_AllVectorTemplates, F_Allvgrids, F_Antennapatterns, &
      & F_Block, F_Boolean, &
      & F_Callstack, F_Chunkdivide, F_ChunkNumber, F_Clean, &
      & F_Commandline, F_Count, F_Crashburn, &
      & F_Details, F_Dacsfiltershapes, F_DumpFile, &
      & F_File, F_Filtershapes, F_Forwardmodel, F_GlobalAttributes, F_Grid, &
      & F_Hessian, F_Hgrid, F_Igrf, F_InputFile, &
      & F_L2pc, F_Lines, F_Mark, F_Mask, F_Matrix, F_Memory, &
      & F_Mietables, F_Options, &
      & F_Pause, F_PfaData, F_PfaFiles, F_Pfanum, F_Pfastru, &
      & F_Phasename, F_Pointinggrids, F_Polygon, F_Quantity, F_Rank, F_Reset, &
      & F_Signals, F_Spectroscopy, F_Stack, F_Start, F_Stop, F_Stride, &
      & F_Stopwitherror, F_Surface, &
      & F_Template, F_Text, F_Tgrid, F_Time, F_Truncate, &
      & F_TotalMatrixSizes, F_TotalVectorSizes, F_Variable, &
      & F_Vector, F_VectorMask, F_Vgrid, F_ZOT, &
      & S_Diff, S_Dump, S_Quantity, S_VectorTemplate, &
      & Field_First, Field_Last
    use Io_Stuff, only: Truncate_TextFile
    use L2Parinfo, only: Parallel, Closeparallel
    use L2PC_M, only: L2pcDatabase, Dumpl2pc => Dump
    use Lexer_Core, only: Get_Where, Where_T
    use Machine, only: Nevercrash
    use MatrixModule_1, only: Matrix_T, Matrix_Database_T, &
      & Diff, Dump, GetFromMatrixDatabase, MatricesMemoryInUse
    use MLSCommon, only: MLSFile_T
    use MLSFiles, only: DumpMLSFile => Dump, GetMLSFilebyname, MLS_Exists
    use MLSFinds, only: Findfirst, FindUnique
    use MLSKinds, only: R8, Rv
    use MLSL2Options, only: L2Options, &
      & L2cfnode, Normal_Exit_Status, RuntimeValues  !,  MLSMessage
    use MLSL2Timings, only: Dump_Section_Timings
    use MLSMessagemodule, only: MLSMSG_Crash, MLSMSG_Error, MLSMessageCalls, &
      & MLSMessageExit
    use MLSSignals_M, only: Radiometers, Signals, &
      & Dump, Dump_All, Getradiometerindex
    use MLSStrings, only: Indexes, LowerCase, &
      & ReadIntsFromChars, Stretch, WriteIntsToChars
    use MLSStringLists, only: GetHashElement, OptionDetail, RemoveOption, &
      & SwitchDetail
    use Moretree, only: Get_Boolean, Get_Field_Id, Get_Spec_Id
    use PCFHdr, only: DumpGlobalAttributes
    use PfaDatabase_M, only: Dump, Dump_PfaDatabase, Dump_PfaFileDatabase, &
      & Dump_Pfastructure, PfaData
    use PointingGrid_M, only: Dump_Pointing_Grid_Database
    use Polygon_M, only: Dump_Polygon_Database
    use QuantityTemplates, only: Dump, QuantityTemplate_T
    use Read_Mie_M, only: Dump_Mie
    use SpectroscopyCatalog_M, only: Catalog, Dump, Dump_Lines_Database, Lines
    use String_Table, only: Display_String, Get_String
    use Time_M, only: Time_Config
    use Toggles, only: Gen, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decoration, Node_Id, Nsons, Sub_Rosa, Subtree, Where
    use Tree_Types, only: N_Spec_Args
    use VectorsModule, only: Vector_T, VectorTemplate_T, VectorValue_T, &
      & Diff, Dump, DestroyVectorQuantityValue, DumpQuantityMask, DumpVectorMask, &
      & GatherVectorQuantity, GetVectorQuantity, GetVectorQtyByTemplateIndex, &
      & GetVectorQuantityIndexByName, VectorsMemoryInUse
    use VGridsDatabase, only: Dump, VGrids
    use Wait_M, only: Wait_For_Event, Pause

    integer, intent(in) :: Root ! Root of the parse tree for the dump command
    ! Databases:
    type (QuantityTemplate_T), dimension(:), pointer, optional   :: QuantityTemplatesDB
    type (forwardModelConfig_t), dimension(:), pointer, optional :: ForwardModelConfigs
    type (vectorTemplate_T), dimension(:), pointer, optional     :: VectorTemplates
    type (vector_T), dimension(:), target, optional              :: Vectors
    type (HGrids_T), dimension(:), pointer, optional             :: HGrids
    type (griddedData_T), dimension(:), pointer, optional        :: griddedDataBase
    type (MLSFile_T), dimension(:), pointer, optional            :: FileDataBase
    type (matrix_Database_T), dimension(:), pointer, optional    :: MatrixDataBase
    type (Hessian_T), dimension(:), pointer, optional            :: HessianDataBase

    character(len=80) :: Booleanstring  ! E.g., 'BAND8'
    logical :: Clean
    real(tk) :: CPUTime, CPUTimeBase = 0.0_tk
    character(8) :: Date
    type(decls) :: Decl ! of an l2cf Variable
    integer :: DetailReduction
    integer :: Details
    integer :: DiffOrDump
    logical :: doStretch
    logical :: doStretchier
    character(len=255) :: Farewell
    integer :: FieldIndex
    integer :: FileIndex
    character(8) :: fieldName
    logical, dimension(field_first:field_last) :: GOT
    logical :: GotFirst ! of something -- needed if diffing 2 of them
    logical :: GotOne ! of something -- used to test loop completion
    integer :: GSON, I, J, K, L, Look
    logical :: HaveForwardModelConfigs, HaveGriddedData, &
             & HaveHessians, HaveHGrids, &
             & HaveMatrices, HaveQuantityTemplatesDB, &
             & HaveVectors, HaveVectorTemplates
    real(rv) :: height  ! We will use this to dump just one surface
    integer :: hessianIndex
    integer :: hessianIndex2
    integer :: HSLABRANK ! Rank of hyperslab; i.e. size(count)
    integer :: ii
    integer :: JJ
    character(len=80) :: Keystring  ! E.g., 'BAND13_OK'
    character(len=80) :: Label  ! E.g., 'BAND8'
    character(len=8) :: lineLenChars
    type (Matrix_T), pointer :: matrix
    type (Matrix_T), pointer :: matrix2
    integer :: MatrixIndex
    integer :: MatrixIndex2
    integer :: Me = -1               ! String index for trace cacheing
    integer :: MUL
    integer :: N
    character(len=80) :: mesg
    character(len=80) :: Namestring  ! E.g., 'L2PC-band15-SZASCALARHIRES'
    integer :: nUnique
    logical :: oldPrintNameAsHeadline
    logical :: oldPrintNameInBanner
    type (MLSFile_T), pointer :: OneMLSFile
    character(len=80) :: optionsString  ! E.g., '-rbs' (see dump_0.f90)
    type (VectorValue_T), pointer :: Quantity
    integer :: QuantityIndex
    integer :: QuantityIndex2
    type (VectorValue_T), pointer :: Qty1, Qty2
    type (VectorValue_T) :: VectorValue
    logical :: reset
    integer :: rank
    integer :: Son
    integer, dimension(3) :: start, count, stride, block
    integer :: Startnode
    character(len=80) :: TempOptionsString  ! E.g., '-rbs' (see dump_0.f90)
    character(20) :: TempText
    type(time_t) :: Time
    character(10) :: TimeOfDay
    logical :: truncate
    integer, dimension(1000) :: uniqueVals
    type (vector_T), pointer  :: Vector
    integer :: VectorIndex
    integer :: VectorIndex2
    logical :: verbose
    integer :: Units(2) ! of the Details expr -- known to be phyq_dimensionless
    double precision :: Values(2) ! of the Details expr
    integer, dimension(3) :: UNITASARRAY ! From expr
    real(r8), dimension(3) :: VALUEASARRAY ! From expr
    integer :: What
    type(where_t) :: Where_At
    logical :: ZOT
    character(len=16), dimension(10), parameter :: StatusBitNames = (/ &
      & 'do not use      ', 'beware          ', 'inform          ', &
      & 'post-processed  ', 'high clouds     ', 'low clouds      ', &
      & 'no meteorology  ', 'abandoned chunk ', 'too few radiance', &
      & 'mlsl2 crashed   ' /)
  !      123456789012345678901234567890123456789012345678901234567890

    ! Executable
    call trace_begin ( me, 'DumpCommand', root, cond=toggle(gen) )
    verbose = BeVerbose ( 'bool', -1 )
    nullify ( vector, quantity )
    ! Were we called to do a diff or a dump?
    ! The following must be one of (/ s_dump, s_diff /)
    DiffOrDump = get_spec_id(root)
    if ( .not. any( DiffOrDump == (/ s_dump, s_diff /) ) ) &
    &  call MLSL2Message( MLSMSG_Error, moduleName, &
        & "Expected either Diff or Dump command to get here")
    haveForwardModelConfigs = present(forwardModelConfigs)
    if ( haveForwardModelConfigs ) &
      & haveForwardModelConfigs = associated(forwardModelConfigs)
    haveGriddedData = present(griddedDataBase)
    if ( haveGriddedData ) haveGriddedData = associated(griddedDataBase)
    HaveHessians = present(HessianDatabase)
    if ( HaveHessians ) then
      if ( associated(HessianDatabase) ) HaveHessians = size(HessianDatabase) > 0
    end if
    haveHGrids = present(hGrids)
    if ( haveHGrids ) haveHGrids = associated(hGrids)
    haveMatrices = present(MatrixDatabase)
    if ( haveMatrices ) haveMatrices = associated(MatrixDatabase)
    if ( haveMatrices ) haveMatrices = size(MatrixDatabase) > 0
    haveQuantityTemplatesDB = present(quantityTemplatesDB)
    if ( haveQuantityTemplatesDB ) &
      & haveQuantityTemplatesDB = associated(quantityTemplatesDB)
    haveVectorTemplates = present(vectorTemplates)
    if ( haveVectorTemplates ) &
      & haveVectorTemplates = associated(vectorTemplates)
    haveVectors = present(vectors)
    if ( haveVectors ) haveVectors = size(Vectors) > 0

    DetailReduction = switchDetail(switches, 'red')
    if ( DetailReduction < 0 ) then ! The 'red' switch is absent
      DetailReduction = 0
    else if ( DetailReduction == 0 ) then ! By default, reduce details level by 2
      DetailReduction = 2
    end if

    Time_Config%wait_time = 5 ! Wait just 5s before trying to read inputFile
    clean = .false.
    truncate = .false.
    reset = .false.
    rank = 0
    start = 0
    count = 0
    stride = 0
    block = 0
    startNode = 0
    GotFirst = .false.
    details = 0 - DetailReduction
    OptionsString = '-'
    got = .false.
    oldPrintNameAsHeadline = PrintNameAsHeadline
    oldPrintNameInBanner   = PrintNameInBanner
    toStderr = .false.
    asBanner = .false.
    asHeadLine = .false.
    doStretch = .false.
    doStretchier = .false.
    lineLength = 40
    text = ' '
    mesg = ' '
    Namestring = ' '
    ZOT = .false.

    do j = 2, nsons(root)
      son = subtree(j,root) ! The argument
      fieldIndex = get_field_id(son)
      gson = son
      L2CFNODE = son
      if (nsons(son) > 1) gson = subtree(2,son) ! Now value of said argument
      where_at = where(gson) ! column + 256*line in l2cf & file name
      got(fieldIndex) = .true.
      select case ( fieldIndex )
      ! This first heaped set of fields need no "right-hand side"
      case ( f_allBooleans, f_allFiles, f_allForwardModels, f_allGriddedData, &
        & f_allHessians, f_allHGrids, f_allL2PCs, f_allLines, f_allMatrices, &
        & f_allPFA, f_allQuantityTemplates, &
        & f_allRadiometers, f_allSignals, f_allSpectra, &
        & f_allVectors, f_allVectorTemplates, f_allVGrids, f_antennaPatterns, &
        & f_callStack, f_chunkDivide, f_chunkNumber, f_commandLine, f_crashBurn, &
        & f_DACSfilterShapes, f_filterShapes, f_globalAttributes, f_igrf,&
        &  f_memory, f_MieTables, &
        & f_pause, f_pfaFiles, f_pfaStru, f_phaseName, f_pointingGrids, &
        & f_polygon, f_stop, f_stopWithError, f_time, f_totalMatrixSizes, &
        & f_totalVectorSizes, f_ZOT )
        if ( get_Boolean(son) ) then
          select case ( fieldIndex )
          case ( f_allBooleans )
            call dumpBooleans
          case ( f_allFiles )
            if ( present(fileDataBase) ) then
              call dumpMLSFile ( fileDataBase )
            else
              call announceError ( son, noFileDatabase )
            end if
          case ( f_allForwardModels )
            if ( haveForwardModelConfigs ) then
              call dump ( forwardModelConfigs, where=son, &
                & quantityTemplatesDB=quantityTemplatesDB )
            else
              call announceError ( son, noFWM )
            end if
          case ( f_allGriddedData )
            if ( details < -3 ) cycle
            if ( haveGriddedData ) then
              call dump ( griddedDataBase, details , options=optionsString )
            else
              call announceError ( son, noGriddedData )
            end if
          case ( f_allHessians )
            if ( details < -2 ) cycle
            if ( haveHessians ) then
              call dump ( HessianDataBase, details, options=optionsString )
            else
              call announceError ( son, 0, 'Unable to dump HessianDB here; empty or absent' )
            end if
          case ( f_allHGrids )
            if ( haveHGrids ) then
              call dump ( hGrids, details, ZOT )
            else
              call announceError ( son, noHGrid )
            end if
          case ( f_allL2PCs )
            call dumpL2PC( L2PCDataBase, details, options=optionsString )
          case ( f_allLines )
            if ( allocated(lines) ) then
              call dump_lines_database
            else
              call announceError ( son, noLines )
            end if
          case ( f_allMatrices )
            if ( details < -2 ) cycle
            if ( haveMatrices ) then
              call dump ( matrixDataBase, details )
            else
              call announceError ( son, 0, 'Unable to dump MatrixDB here; empty or absent' )
            end if
          case ( f_allPFA )
            if ( details < -2 ) cycle
            call Dump_PFADataBase ( details )
          case ( f_allQuantityTemplates )
            if ( haveQuantityTemplatesDB ) then
              call dump ( quantityTemplatesDB )
            else
              call announceError ( son, noQT )
            end if
          case ( f_allRadiometers )
            if ( details < -2 ) cycle
            if ( associated(Radiometers) ) then
              call dump ( Radiometers )
              if ( details > 1 ) then
                call output('Checking getRadiometerIndex for R1A:118', advance='yes' )
                call getRadiometerIndex('R1A:118', i )
                if ( i > 0 ) call dump( radiometers(i) )
                call output('Checking getRadiometerIndex for R1B:118', advance='yes' )
                call getRadiometerIndex('R1B:118', i )
                if ( i > 0 ) call dump( radiometers(i) )
                call output('Checking getRadiometerIndex for R2:190', advance='yes' )
                call getRadiometerIndex('R2:190', i )
                if ( i > 0 ) call dump( radiometers(i) )
                call output('Checking getRadiometerIndex for R3:240', advance='yes' )
                call getRadiometerIndex('R3:240', i )
                if ( i > 0 ) call dump( radiometers(i) )
                call output('Checking getRadiometerIndex for R3', advance='yes' )
                call getRadiometerIndex('R3', i )
                if ( i > 0 ) call dump( radiometers(i) )
              end if
            else
              call announceError ( son, noRadiometers )
            end if
          case ( f_allSignals )
            if ( details < -2 ) cycle
            if ( details > 1 ) then
              call dump_all
            elseif ( associated(signals) ) then
              call dump ( signals, details=details )
            else
              call announceError ( son, noSignals )
            end if
          case ( f_allSpectra )
            if ( details < -2 ) cycle
            call dump ( catalog, details=details )
          case ( f_allVectors )
            if ( details < -2 ) cycle
            if ( haveVectors ) then
              call dump ( vectors, details=details )
            else
              call announceError ( son, noVectors )
            end if
          case ( f_allVectorTemplates )
            if ( details < -2 ) cycle
            if ( haveVectorTemplates ) then
              call dump ( vectorTemplates, details=details )
            else
              call announceError ( son, noVT )
            end if
          case ( f_allVGrids )
            call dump ( vGrids )
          case ( f_antennaPatterns )
            call dump_antenna_patterns_database ( son )
          case ( f_callStack )
            call MLSMessageCalls ( 'dump' )
            if ( details > 0) &
              & call MLSMessageCalls ( 'dumpdb' )
          case ( f_chunkDivide )
            call dump ( chunkDivideConfig )
          case ( f_chunkNumber )
            call outputNamedValue ( 'chunk number', L2Options%currentChunkNumber )
          case ( f_commandLine )
            call outputNamedValue ( 'command line', L2Options%command_line )
          case ( f_crashBurn )
            call FinishMLSL2 ( 'ending mlsl2' )
            NEVERCRASH = .false.
            call MLSL2Message( MLSMSG_CRASH, moduleName, &
              & "Program stopped by /crashBurn field on DUMP statement.")
          case ( f_DACSfilterShapes )
            call dump_dacs_filter_database ( son )
          case ( f_filterShapes )
            call dump_filter_shapes_database ( son )
          case ( f_globalAttributes )
            call dumpGlobalAttributes
          case ( f_igrf )
            call dump_gh ( details, optionsString )
          case ( f_memory )
            call SayMemory
            if ( reset ) TotalMemory1 = TotalMemory2
          case ( f_MieTables )
            call dump_Mie ( details )
          case ( f_pause )
            ! Do we wait for a command read from inputFile or one from stdin?
            ! If from an inputFile we will wait patiently for you to create it
            ! If from stdin we will wait for you to enetr "by hand"
            ! (which may not always be possible--thus the inputFile option)
            if ( got( f_inputFile ) ) then
              ! call output ( 'Program paused by /pause field on Dump statement' &
              !   & // ' .. to read command from ' // trim(nameString), &
              !   & advance='yes' )
              ! call Wait_then_read_mesg( nameString, mesg )
              call Pause ( mesg, nameString )
              call output ( 'Resuming after reading ' // trim(mesg), &
                & advance='yes' )
            else
              ! call output ( 'Program paused by /pause field on Dump statement.', &
              !   & advance='yes pause' )
              call Pause ( mesg )
            endif
          case ( f_pfaFiles )
            call dump_PFAFileDatabase ( details )
          case ( f_pfaStru )
            call dump_PFAStructure ( details )
          case ( f_phaseName )
            call outputNamedValue ( 'phase name', L2Options%currentphaseName )
          case ( f_pointingGrids )
            call dump_pointing_grid_database ( son )
          case ( f_polygon )
            call dump_polygon_database
          case ( f_stop )
            call FinishMLSL2 ( 'ending mlsl2' )
            if ( switchDetail(switches, 'time') >= 0 ) then
              call output('(Now for the timings summary)', advance='yes')
              call dump_section_timings
            end if
            if ( NORMAL_EXIT_STATUS /= 0 .and. .not. parallel%slave ) then
              call get_where ( where_at, farewell, &
                & before="Program stopped with normal status by /stop field on DUMP statement at ", &
                & after="." )
              call MLSMessageExit( NORMAL_EXIT_STATUS, farewell=farewell )
            else if( parallel%slave ) then
              call closeParallel(0)
              call get_where ( where_at, farewell, &
                & before="Slave stopped by /stop field on DUMP statement at ", &
                & after="." )
              call MLSMessageExit( farewell=farewell )
            else
              call get_where ( where_at, farewell, &
                & before="Program stopped by /stop field on DUMP statement at ", &
                & after="." )
              call MLSMessageExit( farewell=farewell )
            end if
          case ( f_stopWithError )
            if ( switchDetail(switches, 'time') >= 0 ) then
              call output('(Now for the timings summary)', advance='yes')
              call dump_section_timings
            end if
            call get_where ( where_at, farewell, &
              & before="Program stopped by /stopWithError field on DUMP statement at ", &
                & after="." )
            call MLSMessageExit( 1, farewell=farewell )
          case ( f_time )
            call SayTime
            if ( reset ) T1 = T2
          case ( f_totalMatrixSizes )
            if ( details < -2 ) cycle
            if ( haveMatrices ) then
              call output ( matricesMemoryInUse ( matrixDataBase ), &
                & before='Total number of elements in all matrices: ', &
                & advance='yes' )
            else
              call announceError ( son, 0, 'Unable to dump MatrixDB size here; empty or absent' )
            end if
          case ( f_totalVectorSizes )
            if ( details < -2 ) cycle
            if ( haveMatrices ) then
              call output ( vectorsMemoryInUse ( vectors ), &
                & before='Total number of elements in all vectors: ', &
                & advance='yes' )
            else
              call announceError ( son, 0, 'Unable to dump Vector DB size here; empty or absent' )
            end if
          case ( f_ZOT )
            ZOT = .true.
          end select
        end if
      case ( f_dumpFile )
        call get_string ( sub_rosa(gson), BooleanString, strip=.true. )
        if ( truncate ) call truncate_textFile( BooleanString )
        call switchOutput ( BooleanString )
      case ( f_truncate )
        truncate = get_Boolean(son)
      case ( f_Boolean )
        call get_string ( sub_rosa(gson), BooleanString, strip=.true. )
        BooleanString = lowerCase(BooleanString)
        ! 1st--check whether we're dumping an array-valued run-time Boolean
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & trim(BooleanString) // 'n', label, countEmpty, &
          & inseparator=runTimeValues%sep )
        if ( label == runTimeValues%sep ) then
          ! Do we s[kip] the key?
          call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
            & BooleanString, label, countEmpty, &
            & inseparator=runTimeValues%sep )
          text = label
          if ( index( 's', optionsString ) < 1 ) &
            text = trim(BooleanString) // ' = ' // label
          call outputNow
        else
          ! OK, we're asked to dump an array-valued one
          call readIntsFromChars ( label, n )
          call output( 'array-valued run-time Boolean ' // trim(BooleanString), &
            & advance='yes' )
          call output ( '  i          value', advance='yes' )
          do i=1, n
            call writeIntsToChars ( i, label )
            call output ( i, advance='no' )
            call blanks ( 4, advance='no' )
            keyString = trim(BooleanString) // '(' // trim(adjustl(label)) // ')'
            call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
              & keyString, label, countEmpty, &
              & inseparator=runTimeValues%sep )
            call output ( trim(label), advance='yes' )
            ! if ( verbose ) call outputnamedValue( 'keyString', trim(keyString) )
            ! -- Don't retain the following--it's just for testing --
            if ( got(f_vector) ) then
              QuantityIndex = GetVectorQuantityIndexByName ( vector, label, noErr=.true. )
              ! call outputNamedValue ( 'QuantityIndex', QuantityIndex )
              if ( QuantityIndex > 0 ) then
                Quantity => GetVectorQuantity( vector, QuantityIndex )
                call dump( Quantity )
              end if
            end if
          enddo
        end if
      case ( f_clean )
        clean = get_Boolean(son)
        if ( clean ) optionsString = trim(optionsString) // 'c'
      case ( f_details )
        call expr ( gson, units, values )
        details = nint(values(1)) - DetailReduction
        ! call outputnamedValue( 'DetailReduction', DetailReduction )
        ! call outputnamedValue( 'Details', details )
      case ( f_rank )
        call expr ( gson, units, values )
        rank = nint(values(1))
      case ( f_reset )
        reset = get_Boolean(son)
      case ( f_start, f_count, f_stride, f_block ) ! For selecting hyperslab
        startNode = subtree(j, root)
        ! Either start = [a, b] or start = b are possible
        hSlabRank = min(nsons(startNode)-1, 3)
        do jj=1, hSlabRank
          call expr(subtree(jj+1,startNode), unitAsArray, valueAsArray)
          mul = valueAsArray(1)
          ! call outputNamedValue( 'mul', mul )
          select case ( fieldIndex )
          case ( f_start )
            start(jj) = mul
            fieldName = 'start'
          case ( f_count )
            count(jj) = mul
            fieldName = 'count'
          case ( f_stride )
            stride(jj) = mul
            fieldName = 'stride'
          case ( f_block )
            block(jj) = mul
            fieldName = 'block'
          end select
        end do
        if ( verbose ) then
          call output('index ', advance='no')
          call output(trim(fieldName), advance='yes')
        end if
      case ( f_file, f_inputfile )
        if ( present(fileDataBase) ) then
          do i = 2, nsons(son)
            gson = subtree(i,son)
            call get_string ( sub_rosa(gson), nameString, strip=.true. )
            oneMLSFile => getMLSFileByName ( fileDataBase, nameString )
            if ( fieldIndex == f_inputfile ) then
              ! This is just a file to input further commands
            elseif ( associated(oneMLSFile) ) then
              call dumpMLSFile ( oneMLSFile )
            else
              call announceError ( gson, noFile, trim(nameString) )
            end if
          end do
        else
          call announceError ( son, noFileDatabase )
        end if
      case ( f_forwardModel ) ! Dump forward model configs
        if ( details < -2 ) cycle
        if ( haveForwardModelConfigs ) then
          do i = 2, nsons(son)
            call dump ( & ! has no details switch
              & forwardModelConfigs(decoration(decoration(subtree(i,son)))), &
              & quantityTemplatesDB=quantityTemplatesDB )
          end do
        else
          call announceError ( gson, noFWM )
        end if
      case ( f_Grid )    ! Diff or Dump Griddeddata
        if ( details < -2 ) cycle
        if ( haveGriddedData ) then
          do i = 2, nsons(son)
            gson = subtree(i,son)
            if ( gotFirst .and. DiffOrDump == s_diff ) then
              vectorIndex2 = decoration(decoration(gson))
            else
              vectorIndex = decoration(decoration(gson))
            end if
            if ( DiffOrDump == s_diff ) then
              rmsFormat = '(1pe8.1)'
              if ( gotFirst ) &
                & call diff ( &
                & griddedDataBase(vectorIndex), &
                & griddedDataBase(vectorIndex2), &
                & options=optionsString )
              rmsFormat = '*'
            else
              call outputNamedValue ( ' Decoration ', vectorIndex )
              call output ( ' GriddedData: ' )
              call dump ( &
                & griddedDataBase(vectorIndex), details , options=optionsString )
            end if
          end do
        else
          call announceError ( gson, noGriddedData )
        end if
        gotFirst = DiffOrDump == s_diff
      case ( f_surface )
        do i = 2, nsons(son)
          call expr ( subtree(i,son), units, values )
          height = values(1)
        end do
      case ( f_hessian ) ! Diff or Dump hessians
        if ( details < -2 ) cycle
        if ( haveHessians ) then
          do i = 2, nsons(son)
            gson = subtree(i,son)
            ! The decoration is the negative of the index; see Fill, where
            ! the Hessian spec is processed.
            ! Well, that's a nasty trick.
            if ( gotFirst .and. DiffOrDump == s_diff ) then
              hessianIndex2 = -decoration(decoration(gson))
            else
              hessianIndex = -decoration(decoration(gson))
            end if
            if ( DiffOrDump == s_diff ) then
              call diff ( HessianDatabase(hessianIndex), &
                &         HessianDatabase(hessianIndex2), details=details, &
                & options=optionsString )
            else
              call dump ( HessianDatabase(hessianIndex), details=details, &
                & options=optionsString )
            end if
          end do
          gotFirst = DiffOrDump == s_diff
        else
          call announceError ( gson, 0, 'Unable to dump Hessian here; db empty or absent' )
        end if
      case ( f_hGrid )    ! Dump HGrids
        if ( details < -2 ) cycle
        if ( haveHGrids ) then
          do i = 2, nsons(son)
            call output ( ' HGrid ' )
            call dump ( &
              & hGrids(decoration(decoration(subtree(i,son))))%the_hGrid, &
              & details, ZOT )
          end do
        else
          call announceError ( gson, noHGrid )
        end if
      case ( f_L2PC )    ! Dump L2PC
        if ( details < -2 .or. .not. present(FileDataBase) ) cycle
        call get_string( sub_rosa(subtree(2,son)), nameString, strip=.true. )
        fileIndex = FindFirst( FileDataBase%ShortName, trim(nameString) )
        ! call outputNamedValue ( 'name string', trim(nameString) )
        ! call outputNamedValue ( 'file index', fileIndex )
        ! call dumpMLSFile( fileDataBase, details=1 )
        if ( fileIndex < 1 ) cycle
        call output ( ' L2PC short file name: ' // trim(nameString), advance='yes' )
        call dumpL2PC ( fileDataBase(fileIndex), details, options=optionsString )
      case ( f_lines )
        do i = 2, nsons(son)
          what = decoration(decoration(subtree(i,son)))
          call output ( what, after=': ' )
          call dump ( lines(what) )
        end do
      case ( f_mark )
        if ( get_Boolean(son) ) call cpu_time ( cpuTimeBase )
      case ( f_mask, f_quantity ) ! Diff or Dump vector quantities
        if ( details < -2 ) cycle
        do i = 2, nsons(son)
          gson = subtree(i,son)
          if ( gotFirst .and. DiffOrDump == s_diff ) then
            vectorIndex2 = decoration(decoration(subtree(1,gson)))
            quantityIndex2 = decoration(decoration(decoration(subtree(2,gson))))
            qty2 => GetVectorQtyByTemplateIndex( &
                  & vectors(vectorIndex2), quantityIndex2 )
          else
            vectorIndex = decoration(decoration(subtree(1,gson)))
            quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
            qty1 => GetVectorQtyByTemplateIndex( &
                  & vectors(vectorIndex), quantityIndex )
          end if
          if ( DiffOrDump == s_diff ) then
            rmsFormat = '(1pe8.1)'
            if ( gotFirst ) then
              if ( index(optionsString, '1') > 0 ) then
                call diff ( qty1%values, 'qty1 values', &
                  & qty2%values, 'qty2 values', &
                  & options=optionsString )
              else if ( index(optionsString, '2') > 0 ) then
                call diff ( ichar(qty1%mask), 'qty1 mask', &
                  & ichar(qty2%mask), 'qty2 mask', &
                  & options=optionsString )
              else
                call diff ( &
                  & qty1, &
                  & qty2, &
                  & options=optionsString )
              end if
            end if
            rmsFormat = '*'
          else if ( fieldIndex == f_mask ) then
            if ( got(f_details) ) &
              & call outputNamedValue( 'Dump mask with details', details )
            if ( got(f_options) ) &
              & call outputNamedValue( 'Dump mask with options', optionsString )
            call dumpQuantityMask ( GetVectorQtyByTemplateIndex( &
              & vectors(vectorIndex), quantityIndex), &
              & details=details, options=optionsString )
          else

            if ( clean ) optionsString = trim(optionsString) // 'c'
            ! Special hyperslab handling
            ! We create a new vector quantity qty2 based on qty1
            ! dump that qty2
            ! and then destroy it
            if ( any(got( (/f_start, f_count, f_stride, f_block/) ) ) ) then
              if ( verbose ) then
                call outputNamedValue( 'start(1:rank)', start(1:hSlabRank) )
                call outputNamedValue( 'count(1:rank)', count(1:hSlabRank) )
                call outputNamedValue( 'stride(1:rank)', stride(1:hSlabRank) )
                call outputNamedValue( 'block(1:rank)', block(1:hSlabRank) )
              end if
              VectorValue = GatherVectorQuantity( qty1, &
                & start(1:hSlabRank), count(1:hSlabRank), &
                & stride(1:hSlabRank), block(1:hSlabRank) )
              if ( index(optionsString, '1') < 1 ) &
                & call dump ( VectorValue, details=0, &
                & vector=vectors(vectorIndex) )
              select case ( hSlabRank )
              case (1)
                call dump( VectorValue%value1, 'values as 1-d array' )
              case (2)
                call dump( VectorValue%values, 'values as 2-d array' )
              case (3)
                call dump( VectorValue%value3, 'values as 3-d array' )
              case default
                call MLSL2Message (MLSMSG_Error, moduleName, &
                  & 'rand of hyperslab must be one of 1,2, or 3' )
              end select
              call DestroyVectorQuantityValue( VectorValue, destroyMask=.true., &
                & destroyTemplate=.true. )
            ! Special options handling
            ! 'b' means show bit names
            ! 'c' means clean
            ! '0' means dump template
            ! '1' means dump values
            ! '2' means dump mask
            elseif ( .not. any(indexes(optionsString, (/'0','1','2','b'/)) > 0 ) ) then
              call dump ( qty1, details=details, &
                & vector=vectors(vectorIndex), options=optionsString )
            else if ( index(optionsString, 'b') > 0 ) then
              call FindUnique( int(qty1%value1), uniqueVals, nUnique )
              call outputNamedValue(' Number unique values', nUnique )
              do ii=1, nUnique
                call DumpBitNames( uniqueVals(ii), StatusBitNames )
              enddo
              call DumpBitCounts( int(qty1%value1), showPct=.true. )
            else if ( index(optionsString, '1') > 0 ) then
              if ( verbose ) then
                call outputnamedValue ( 'rank field', rank )
                call outputnamedValue ( 'shape(value3)', shape(qty1%value3) )
              end if
              select case ( rank )
              case ( 1 )
                call dump ( qty1%value1, 'quantity values', &
                  & options=optionsString )
              case ( 3 )
                call dump ( qty1%value3, 'quantity values', &
                  & options=optionsString )
              case ( 4 )
                call dump ( qty1%value4, 'quantity values', &
                  & options=optionsString )
              case default
                call dump ( qty1%values, 'quantity values', &
                  & options=optionsString )
              end select
            else if ( index(optionsString, '0') > 0 ) then
              call dump ( qty1%template, details=details )
            else
              call dumpQuantityMask( qty1, details=0, options=optionsString )
            end if
          end if
        end do
        GotFirst = DiffOrDump == s_diff
      case ( f_matrix ) ! Diff or Dump matrices
        if ( details < -2 ) cycle
        if ( haveMatrices ) then
          do i = 2, nsons(son)
            gson = subtree(i,son)
            if ( gotFirst .and. DiffOrDump == s_diff ) then
              matrixIndex2 = decoration(decoration(gson))
            else
              matrixIndex = decoration(decoration(gson))
            end if
            if ( DiffOrDump /= s_diff ) then
              call getFromMatrixDatabase ( &
                & matrixDatabase(matrixIndex), matrix )
              call dump ( Matrix, details=details )
            else if ( GotFirst ) then
              call getFromMatrixDatabase ( &
                & matrixDatabase(matrixIndex), matrix )
              call getFromMatrixDatabase ( &
                & matrixDatabase(matrixIndex2), matrix2 )
              call diff ( Matrix, Matrix2, details=details )
            end if
          end do
        else
          call announceError ( gson, 0, 'Unable to dump matrix here; db empty or absent' )
        end if
        GotFirst = DiffOrDump == s_diff
      case ( f_options )
        call get_string ( sub_rosa(gson), optionsString, strip=.true. )
        if ( verbose ) call outputNamedValue( 'options', trim(optionsString) )
        toStderr = optionDetail( optionsString, 'e', 'Err' ) == 'yes'
        asBanner = optionDetail( optionsString, 'B', 'Banner' ) == 'yes'
        headLineChars = optionDetail( optionsString, 'H', 'Headline' )
        asHeadline =  headLineChars /= 'no'
        lineLenChars = optionDetail( optionsString, 'L', 'Linelength' )
        if ( lineLenChars /= 'no' ) &
          & call readIntsFromChars ( lineLenChars, lineLength )
        if ( asHeadline ) then
          PrintNameAsHeadline = .true.
          call removeOption( optionsString, tempOptionsString, '-H' )
          call removeOption( tempOptionsString, optionsString, '--Headline' )
        endif
        if ( asBanner ) then
          PrintNameInBanner = .true.
          call removeOption( optionsString, tempOptionsString, '-B' )
          call removeOption( tempOptionsString, optionsString, '--Banner' )
        endif
      case ( f_pfaData )
        do i = 2, nsons(son)
          look = decoration(decoration(subtree(i,son)))
          call dump ( pfaData(look), details, look )
        end do
      case ( f_pfaNum )
        do i = 2, nsons(son)
          call expr ( subtree(i,son), units, values )
          call dump ( pfaData(nint(values(1))), details, nint(values(1)) )
        end do
      case ( f_signals )
        do i = 2, nsons(son)
          what = decoration(decoration(subtree(i,son)))
          call output ( what, after=': ' )
          call dump ( signals(what), details )
        end do
      case ( f_spectroscopy )
        do i = 2, nsons(son)
          what = decoration(subtree(i,son))
          call output ( what, after=': ' )
          call dump ( catalog(what), details=details )
        end do
      case ( f_stack )
        call dump_stack( where=.true., CPU=.true., doDepth=details>0 )
      case ( f_template ) ! Dump vector templates or quantity templates
        if ( details < -2 ) cycle
        do i = 2, nsons(son)
          gson = subtree(i,son)
          look = decoration(gson)
          if ( node_id(look) /= n_spec_args ) call announceError ( gson, unknown )
          what = decoration(look)
          select case ( get_spec_id(look) )
          case ( s_quantity )
            if ( haveQuantityTemplatesDB ) then
              call output ( ' Quantity template' )
              call dump ( quantityTemplatesDB(what), details=details )
            else
              call announceError ( gson, noQT )
            end if
          case ( s_vectorTemplate )
            if ( haveVectorTemplates ) then
              call output ( ' Vector template' )
              call dump ( vectorTemplates(what), details=details, quantities=quantityTemplatesDB )
            else
              call announceError ( gson, noVT )
            end if
          end select
        end do
      case ( f_text )
        ! Special use of options string
        !   option         meaning
        ! ---------        -------
        !     B            print as a banner
        !     H            print as a headine
        !     H[c]         print as a headine with character "c" instead of *
        !     e            print to stderr
        !     s            s-t-r-e-t-c-h
        !     S            s t r e t c h
        !   L[nn]          use nn for line length
        if ( len_trim(optionsString) > 0 ) then
          doStretch = optionDetail( optionsString, 's', 'stretch' ) == 'yes'
          doStretchier = optionDetail( optionsString, 'S', 'stretch' ) == 'yes'
        end if
        do k = 2, nsons(son)
          call get_string ( sub_rosa(subtree(k,son)), text, strip=.true. )
          ! Special text causing intentional error (this is a dubious hack)
          ! if ( index(lowercase(text), 'error condition alpha') > 0 ) &
          !   & call MLSMessage ( MLSMSG_Error, moduleName, trim(text) )
          ! Replace format marks: %[Cc] => CPU time in YyDdHH:MM:SS.SSS format
          !                       %[Dd] => date and time of day
          !                       %[Ss] => CPU time in seconds
          !                       %[Tt] => time of day
          gotOne = .false.
          do
            call cpu_time ( cpuTime ) ! In case %[CcSs] appears
            i = max(index(text,'%c'), index(text,'%C'))
            if ( i /= 0 ) then
              tempText = ''
              l = 1 ! Position in TempText
              time = duration_formatted ( cpuTime - cpuTimeBase )
              if ( time%year /= 0 ) then
                gotOne = .true.
                write ( tempText, * ) time%year
                tempText = adjustl(tempText)
                l = len_trim(tempText) + 2
                tempText(l-1:l-1) = 'y'
              end if
              if ( time%day /= 0 .or. gotOne ) then
                gotOne = .true.
                write ( tempText(l:), * ) time%day
                tempText(l:) = adjustl(tempText(l:))
                l = len_trim(tempText) + 2
                tempText(l-1:l-1) = 'd'
              end if
              if ( time%hours /= 0 .or. gotOne ) then
                gotOne = .true.
                write ( tempText(l:), '(i2.2)' ) time%hours
                tempText(l:) = adjustl(tempText(l:))
                l = len_trim(tempText) + 2
                tempText(l-1:l-1) = ':'
              end if
              if ( time%minutes /= 0 .or. gotOne ) then
                gotOne = .true.
                write ( tempText(l:), '(i2.2)' ) time%minutes
                tempText(l:) = adjustl(tempText(l:))
                l = len_trim(tempText) + 2
                tempText(l-1:l-1) = ':'
              end if
              write ( tempText(l:), '(f6.3)' ) time%seconds
              tempText(l:) = adjustl(tempText(l:))
              l = len_trim(tempText)
              text = text(:i-1) // tempText(:l) // text(i+2:)
              cycle
            end if
            i = max(index(text,'%d'), index(text,'%D'))
            if ( i /= 0 ) then
              call date_and_time ( date=date, time=timeOfDay )
              text = text(:i-1) // date(1:4) // '-' // date(5:6) // '-' // date(7:8) // &
                & ' ' // timeOfDay(1:2) // ':' // timeOfDay(3:4) // ':' // timeOfDay(5:10) // &
                & text(i+2:)
              cycle
            end if
            i = max(index(text,'%l'), index(text,'%L'))
            if ( i /= 0 ) then
              call get_where ( where(subtree(k,son)), tempText )
              text = text(:i-1) // trim(tempText) // text(i+2:)
              cycle
            end if
            i = max(index(text,'%s'), index(text,'%S'))
            if ( i /= 0 ) then
              write ( tempText, '(1p,g15.6)' ) cpuTime - cpuTimeBase
              text = text(:i-1) // trim(adjustl(tempText)) // text(i+2:)
              cycle
            end if
            i = max(index(text,'%t'), index(text,'%T'))
            if ( i /= 0 ) then
              call date_and_time ( time=timeOfDay )
              text = text(:i-1) // timeOfDay(1:2) // ':' // timeOfDay(3:4) // &
                & ':' // timeOfDay(5:10) // text(i+2:)
              cycle
            end if
            exit ! Didn't find a format trigger
          end do
          if ( doStretchier ) text = stretch( text, options='-a' )
          if ( doStretch ) text = stretch( text )
          call outputNow ! the text
        end do ! k
      case ( f_tGrid )
        if ( details < -2 ) cycle
        do i = 2, nsons(son)
          call output ( ' TGrid ' )
          call dump ( vGRids(decoration(decoration(subtree(i,son)))), details=details )
        end do
      case ( f_variable )
        do i = 2, nsons(son)
          decl = get_decl ( sub_rosa(subtree(i,son)), type=variable )
          if ( decl%type /= variable ) then
            call display_string ( sub_rosa(subtree(i,son)), before='The symbol "' )
            call output ( '" has not been given a value.', advance='yes' )
          else
            call display_string ( sub_rosa(subtree(i,son)) )
            call dump_a_decl ( decl, before=' is', details=details )
          end if
        end do
      case ( f_vectormask, f_vector ) ! Dump entire vectors
        if ( details < -2 ) cycle
        if ( haveVectors ) then
          do i = 2, nsons(son)
            vector => vectors(decoration(decoration(subtree(i,son))))
            call output ( ' Vector ' )
            if ( fieldIndex == f_vectormask ) then
              call dumpVectorMask ( vector, details=details )
            else
              call dump ( vector, details=details, clean=clean, options=optionsString )
            end if
          end do
        else
          call announceError ( gson, noVectors )
        end if
      case ( f_vGrid )
        if ( details < -2 ) cycle
        do i = 2, nsons(son)
          call output ( ' VGrid ' )
          call dump ( vGRids(decoration(decoration(subtree(i,son)))), details=details )
        end do
      end select
    end do
    if ( got(f_dumpFile) ) call revertOutput
    PrintNameAsHeadline = oldPrintNameAsHeadline
    PrintNameInBanner = oldPrintNameInBanner

    call trace_end ( 'DumpCommand', cond=toggle(gen) )
contains
    subroutine Wait_then_read_mesg ( filename, mesg )
      character(len=*), intent(in)  :: filename
      character(len=*), intent(out) :: mesg
      integer                       :: unitnum, status
      ! Executable
      InputFileName = filename
      call wait_for_event( File_There_Now, 1 )
      open ( newunit=unitnum, form='formatted', &
        & file=trim(FileName), status='old', iostat=status )
      read ( unitnum, '(a80)' ) mesg
    end subroutine Wait_then_read_mesg

    function File_There_Now( id ) result ( now )
      ! Returns
      ! 0 if filename exists
      ! 1 otherwise
      integer, intent(in)          :: id ! Ignored
      integer                      :: now
      now = mls_exists ( trim(InputFileName) )
    end function File_There_Now
  end subroutine DumpCommand

  ! ---------------------------------------------  ExecuteCommand  -----
  subroutine ExecuteCommand ( root )
    use Dump_1, only: DumpTextFile
    use Expr_M, only: Expr
    use Init_Tables_Module, only: F_Crashburn, &
      & F_Delay, F_Details, F_Filename, F_Lines, F_Options, &
      & F_Stop, F_Stopwitherror, F_Command, F_Time, &
      & F_Wait, &
      & Field_First, Field_Last
    use IO_Stuff, only: Write_TextFile
    use L2parinfo, only: Parallel, CloseParallel
    use Lexer_Core, only: Get_Where, Where_T
    use Machine, only: Create_Script, Execute, NeverCrash, Usleep
    use MLSL2Options, only: L2CFNode, Normal_Exit_Status  !, MLSMessage
    use MLSL2Timings, only: Dump_Section_Timings
    use MLSMessageModule, only: MLSMSG_Crash, MLSMSG_Warning, &
      & MLSMessageExit
    use MLSStringLists, only: SwitchDetail
    use MoreTree, only: Get_Boolean, Get_Field_ID
    use String_Table, only: Get_String
    use Toggles, only: Gen, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: NSons, Sub_Rosa, SubTree, Where

  ! Process an Execute command
    integer, intent(in) :: Root ! Root of the parse tree for the Execute command
    ! Local variables
    character(len=256)         :: command
    integer                    :: fieldIndex
    logical, dimension(field_first:field_last) :: GOT
    integer                    :: Delay
    integer                    :: DetailReduction
    integer                    :: Details
    character(len=255)         :: Farewell
    character(len=80)          :: filename  ! E.g., '/tmp/Execute_me.sh'
    integer                    :: gson
    integer                    :: j
    integer                    :: k
    character(len=128), dimension(64) :: lines
    integer                    :: Me = -1  ! String index for trace cacheing
    integer                    :: nLines
    character(len=80)          :: OPTIONSSTRING  ! E.g., '-rbs' (see dump_0.f90)
    logical :: reset
    integer                    :: son
    integer                    :: status
    logical                    :: verbose
    integer                    :: Units(2) ! of the Details expr -- known to be phyq_dimensionless
    double precision           :: Values(2) ! of the Details expr
    logical                    :: wait
    type(where_t)              :: Where_At
    ! Executable
    call trace_begin ( me, 'ExecuteCommand', root, cond=toggle(gen) )
    verbose = BeVerbose ( 'bool', -1 )
    DetailReduction = switchDetail(switches, 'red')
    if ( DetailReduction < 0 ) then ! The 'red' switch is absent
      DetailReduction = 0
    else if ( DetailReduction == 0 ) then ! By default, reduce details level by 2
      DetailReduction = 2
    end if
    delay = 0
    details = 0 - DetailReduction
    lines = ' '
    command = ' '
    nLines = 0
    OPTIONSSTRING = '-'
    reset = .false.
    got= .false.

    do j = 2, nsons(root)
      son = subtree(j,root) ! The argument
      fieldIndex = get_field_id(son)
      gson = son
      L2CFNODE = son
      if (nsons(son) > 1) gson = subtree(2,son) ! Now value of said argument
      where_at = where(gson) ! column + 256*line in l2cf & file name
      got(fieldIndex) = .true.
      select case ( fieldIndex )
        case ( f_wait )
          wait = get_Boolean(son)
        case ( f_crashBurn )
        case ( f_delay )
          call expr ( gson, units, values )
          delay = nint(values(1))
        case ( f_details )
          call expr ( gson, units, values )
          details = nint(values(1)) - DetailReduction
        case ( f_stop )
        case ( f_stopWithError )
        case ( f_time )
          call SayTime
          if ( reset ) T1 = T2
        case ( f_options )
          call get_string ( sub_rosa(gson), optionsString, strip=.true. )
        case ( f_FileName )
          call get_string ( sub_rosa(gson), fileName, strip=.true. )
        case ( f_command )
          do k = 2, nsons(son)
            call get_string ( sub_rosa(subtree(k,son)), command, strip=.true. )
          enddo
        case ( f_lines )
          do k = 2, nsons(son)
            nLines = nLines + 1
            call get_string ( sub_rosa(subtree(k,son)), lines(nLines), strip=.true. )
          enddo
        end select
      end do
      if ( .not. (got(f_command) .or. got(f_fileName)) ) then
        call MLSL2Message( MLSMSG_Warning, moduleName, &
          & "Execute must have either command or fileName present.")
        return
      endif
      ! Do we have a single-line command or an entire script? Must we wait for it?
      if ( wait ) then
        if ( got(f_lines) ) then
          call Execute_then_wait( inscriptName=fileName, inLines=lines(:nLines) )
        elseif ( got(f_command) ) then
          call Execute_then_wait( command=command )
        endif
      elseif ( got(f_lines) ) then
        call create_script( fileName, lines(:nLines), thenRun=.true., &
          & status=status, delay=delay )
        if ( verbose ) then
          call outputNamedValue( 'script name', trim(fileName) )
          call dumpTextfile( FileName, OptionsString )
        endif
        call execute( 'rm -f ' // trim(fileName), status, delay=delay )
      elseif ( got(f_command) ) then
        call outputNamedValue( 'Command to Execute', trim(command) )
        call execute( command, status, delay=delay )
      else
        call MLSL2Message( MLSMSG_Warning, moduleName, &
          & "Execute command must have either command or lines field.")
      endif
      ! Have we been commanded to stop? wait? crash?
      if ( got(f_stop) ) then
        call FinishMLSL2 ( 'ending mlsl2' )
        call MLSL2Message( MLSMSG_Warning, moduleName, &
          & "Program stopped by /stop field on DUMP statement.")
          if ( switchDetail(switches, 'time') >= 0 ) then
            call output('(Now for the timings summary)', advance='yes')
            call dump_section_timings
          end if
        if ( NORMAL_EXIT_STATUS /= 0 .and. .not. parallel%slave ) then
          call get_where ( where_at, farewell, &
            & before="Program stopped with normal status by /stop field on DUMP statement at ", &
            & after="." )
          call MLSMessageExit( NORMAL_EXIT_STATUS, farewell=farewell )
        else if( parallel%slave ) then
          call closeParallel(0)
          call get_where ( where_at, farewell, &
            & before="Slave stopped by /stop field on DUMP statement at ", &
            & after="." )
          call MLSMessageExit( farewell=farewell )
        else
          call get_where ( where_at, farewell, &
            & before="Program stopped by /stop field on DUMP statement at ", &
            & after="." )
          call MLSMessageExit( farewell=farewell )
        end if
      elseif ( got(f_stopWithError) ) then
        if ( switchDetail(switches, 'time') >= 0 ) then
          call output('(Now for the timings summary)', advance='yes')
          call dump_section_timings
        end if
        call get_where ( where_at, farewell, &
          & before="Program stopped by /stopWithError field on DUMP statement at ", &
            & after="." )
        call MLSMessageExit( 1, farewell=farewell )
      elseif ( got(f_crashBurn) ) then
        call FinishMLSL2 ( 'ending mlsl2' )
        NEVERCRASH = .false.
        call MLSL2Message( MLSMSG_Crash, moduleName, &
          & "Program stopped by /crashBurn field on DUMP statement.")
      endif
    call trace_end ( 'ExecuteCommand', cond=toggle(gen) )
  contains
    subroutine Execute_then_wait ( command, inscriptName, inlines )
      ! Execute a command or a script
      ! Then wait for it to complete
      ! Method: we create a script, based either on command or on input lines
      ! At the end of the script we rm a sentinel file we cleverly created 
      ! on entering this subroutine
      ! We loop over checking for the sentinel file
      ! When it's gone, so are we
      ! Args
      character(len=*), optional, intent(in)                  :: command
      character(len=*), optional, intent(in)                  :: inscriptName
      character(len=*), dimension(:), optional, intent(in)    :: inlines
      ! Internal variables
      logical                                                 :: exist
      character(len=80), dimension(60)                        :: lines
      character(len=80)                                       :: scriptName
      character(len=80)                                       :: sentinelName
      integer                                                 :: myDelay
      integer                                                 :: nLines
      ! Executable
      scriptName = '/tmp/mlsl2scriptname.sh'
      if ( present(inscriptName) ) scriptName = inscriptName
      sentinelName = trim(scriptName) // '.txt'
      call write_textfile( sentinelName, 'waiting' )
      if ( present(command) ) then
        lines(1) = '#!/bin/sh'
        lines(2) = command
        lines(3) = 'rm -f ' // sentinelName
        nLines = 3
      elseif ( present(inLines) ) then
        nLines = size(inLines) + 1
        lines(1:nLines-1) = inLines
        lines(nLines) = 'rm -f ' // sentinelName
      else
        call MLSL2Message( MLSMSG_Warning, moduleName, &
          & "Execute_then_wait must have either command or inlines present.")
        return
      endif
      call create_script( scriptName, lines(:nLines), thenRun=.true., &
        & status=status, delay=delay )
      if ( verbose ) then
        call outputNamedValue( 'script name', trim(scriptName) )
        call dumpTextfile( scriptName, OptionsString )
      endif
      ! Now we loop over waiting for the sentinel file to disappear
      myDelay = max( delay, 50 )
      do
        call Usleep( myDelay )
        ! Still there?
        inquire( file=sentinelName, exist=exist )
        if ( .not. exist ) exit
      enddo
      call execute( 'rm -f ' // trim(scriptName), status, delay=delay )
    end subroutine Execute_then_wait
  end subroutine ExecuteCommand

  ! ------------------------------------------------  InitializeRepeat  -----
  subroutine  InitializeRepeat
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: PutHashElement
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'count', '0', countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'countsn', '0', countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
  end subroutine  InitializeRepeat

  subroutine  NextRepeat
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: GetHashElement, PutHashElement
    use MLSStrings, only: Readintsfromchars, Writeintstochars
    ! Internal variables
    character(len=64) :: cvalue
    integer :: c
    character(len=16) :: keyString
    character(len=64) :: nvalue
    ! Executable
    call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'count', cvalue, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    call readIntsFromChars ( cvalue, c )
    call writeIntsToChars ( c+1, cvalue )
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'count', cvalue, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    keyString = 'counts(' // trim(adjustl(cvalue)) // ')'
    call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'countsn', nvalue, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    ! Are we Repeating for a sequence of values?
    call readIntsFromChars ( nvalue, c )
    ! call outputNamedValue( 'nvalue', nvalue )
    if ( c < 1 ) return
    ! If so, store the current value at the key 'counts(n)'
    ! call outputNamedValue( 'keyString', keyString )
    call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
      & keyString, cvalue, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'counts(n)', cvalue, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )

  end subroutine  NextRepeat

  subroutine  MLSCase ( ROOT )
  ! Returns TRUE if the label or Boolean field of the last Select command
  ! matches the label or Boolean field of the current Case command
  ! or if the current Case command is given the special label 'default',
  ! a wildcard matching anything
    use Init_Tables_Module, only: F_Boolean, F_Label, F_Options
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: GetHashElement
    use MLSStrings, only: Lowercase, Streq
    use Moretree, only: Get_Field_Id
    use String_Table, only: Get_String
    use Toggles, only: Gen, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Nsons, Sub_Rosa, Subtree
    ! Args
    integer, intent(in) :: root
    ! Internal variables
    character(len=80) :: Booleanstring  ! E.g., 'BAND8'
    integer :: FieldIndex
    integer :: GSON, J
    character(len=80) :: Label  ! E.g., 'BAND8'
    integer :: Me = -1          ! String index for trace cacheing
    character(len=16) :: optionsString
    integer :: Son
    logical :: verbose ! , verboser

    ! Executable
    call trace_begin ( me, 'MLSCase', root, cond=toggle(gen) )
    verbose = BeVerbose ( 'bool', -1 )
!    verboser = BeVerbose ( 'bool', 0 )
    MLSSelecting = .true. ! Defaults to skipping rest of case
    if ( MLSSelectedAlready ) then
      call trace_end ( 'MLSCase', cond=toggle(gen) )
      return
    end if
    optionsString = ' '
    do j = 2, nsons(root)
      son = subtree(j,root) ! The argument
      fieldIndex = get_field_id(son)
      gson = son
      if (nsons(son) > 1) gson = subtree(2,son) ! Now value of said argument
      select case ( fieldIndex )
      case (f_Boolean)
        call get_string ( sub_rosa(gson), BooleanString, strip=.true. )
        BooleanString = lowerCase(BooleanString)
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & BooleanString, label, countEmpty, &
          & inseparator=runTimeValues%sep )
      case (f_label)
        call get_string ( sub_rosa(gson), label, strip=.true. )
      case (f_options)
        call get_string ( sub_rosa(gson), optionsString, strip=.true. )
      case default
        ! Should not have got here if parser worked correctly
      end select
    enddo
    label = lowerCase(label)
    if ( label == 'default' ) then
      MLSSelecting = .false. ! Matches any pattern
    elseif ( len_trim(optionsString) < 1 ) then
      MLSSelecting = ( label /= selectLabel )
    else
      ! The streq function is a generalized string '=='
      MLSSelecting = .not. streq( label, selectLabel, optionsString )
    end if
    if ( verbose ) then
      call output( 'MLSCase label = ', advance='no' )
      call output( trim(label), advance='yes' )
    end if
    ! We must store whether we have ever had a match
    MLSSelectedAlready = MLSSelectedAlready .or. .not. MLSSelecting
    call trace_end ( 'MLSCase', cond=toggle(gen) )
  end subroutine  MLSCase

  subroutine  MLSSelect ( root )
  ! Fills the global variable selectLabel with
  ! the Label field or value of the Boolean field
    use Init_Tables_Module, only: F_Boolean, F_Label
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: GetHashElement
    use MLSStrings, only: Lowercase
    use Moretree, only: Get_Field_Id
    use String_Table, only: Get_String
    use Toggles, only: Gen, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Nsons, Sub_Rosa, Subtree
    ! Args
    integer, intent(in) :: root
    ! Internal variables
    character(len=80) :: Booleanstring  ! E.g., 'BAND8'
    integer :: FieldIndex
    integer :: GSON, J
    character(len=80) :: Label          ! E.g., 'BAND8'
    integer :: Me = -1                  ! String index for trace cacheing
    integer :: Son
    logical :: verbose! , verboser

    ! Executable
    call trace_begin ( me, 'MLSSelect', root, cond=toggle(gen) )
    verbose = BeVerbose ( 'bool', -1 )
!    verboser = BeVerbose ( 'bool', 0 )
    label = ' '
    do j = 2, nsons(root)
      son = subtree(j,root) ! The argument
      fieldIndex = get_field_id(son)
      gson = son
      if (nsons(son) > 1) gson = subtree(2,son) ! Now value of said argument
      select case ( fieldIndex )
      case (f_Boolean)
        call get_string ( sub_rosa(gson), BooleanString, strip=.true. )
        BooleanString = lowerCase(BooleanString)
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & BooleanString, label, countEmpty, &
          & inseparator=runTimeValues%sep )
      case (f_label)
        call get_string ( sub_rosa(gson), label, strip=.true. )
      case default
        ! Should not have got here if parser worked correctly
      end select
    enddo
    if ( verbose ) then
      call output( 'Selecting label = ', advance='no' )
      call output( trim(label), advance='yes' )
    end if
    selectLabel = lowerCase(label)
    MLSSelecting = .true.
    call trace_end ( 'MLSSelect', cond=toggle(gen) )
  end subroutine MLSSelect

  subroutine  MLSEndSelect ( ROOT )
  ! Resets the global variable MLSSelecting
  ! Optionally puts note about end of selecting in log file
    use Init_Tables_Module, only: F_Label
    use MLSStrings, only: Lowercase
    use Moretree, only: Get_Field_Id
    use String_Table, only: Get_String
    use Toggles, only: Gen, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Nsons, Sub_Rosa, Subtree
    ! args
    integer, intent(in) :: root
    ! Internal variables
    character(len=80) :: Label  ! E.g., 'BAND8'
    integer :: FieldIndex
    integer :: GSON, J
    integer :: Me = -1          ! String index for trace cacheing
    integer :: Son
    logical :: verbose! , verboser
    ! Executable
    verbose = BeVerbose ( 'bool', -1 )
    MLSSelectedAlready = .false.
    call trace_begin ( me, 'MLSEndSelect', root, cond=toggle(gen) )
    label = ' '
    do j = 2, nsons(root)
      son = subtree(j,root) ! The argument
      fieldIndex = get_field_id(son)
      gson = son
      if (nsons(son) > 1) gson = subtree(2,son) ! Now value of said argument
      select case ( fieldIndex )
      case (f_label)
        call get_string ( sub_rosa(gson), label, strip=.true. )
        label = lowerCase(label)
      case default
        ! Should not have got here if parser worked correctly
      end select
    enddo
    MLSSelecting = .false.
    if ( verbose ) then
      call output( 'End Selecting ', advance='no' )
      if ( len_trim(label) > 0 ) &
        & call output( 'label = ' // trim(label), advance='no' )
      call NewLine
    end if
    call trace_end ( 'MLSEndSelect', cond=toggle(gen) )
  end subroutine MLSEndSelect

  ! ----------- callable as either Skip or Repeat command ---------
  ! Returns value of Boolean field (if present);
  ! If TRUE should skip rest of section in which SKIP command appears
  ! If Boolean field absent, returns TRUE
  ! (otherwise it would do nothing--
  ! this way it forces us to skip unconditionally)
  ! If called as Repeat, returns same result as Skip
  ! Exception: values field, if present, will be
  ! stored as additional runtimes Booleans; e.g.
  ! .., values=["str1", "str2", .., "strn"] adds to r/t Booleans the following
  !    key        value
  ! counts(1)      str1
  ! counts(2)      str2
  !   .    .    .
  ! counts(n)      strn
  ! countsn        n
  logical function Skip ( root, name )
    use Init_Tables_Module, only: F_Boolean, F_Formula, F_NextChunk, F_Values
    use MLSL2Options, only: ExitToNextChunk, RuntimeValues
    use MLSStringLists, only: BooleanValue, GetHashElement, PutHashElement
    use MLSStrings, only: Lowercase, ReadintsFromChars, WriteIntsToChars
    use Moretree, only: Get_Boolean, Get_Field_Id
    use String_Table, only: Get_String
    use Toggles, only: Gen, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Nsons, Sub_Rosa, Subtree
    ! args
    integer, intent(in)                    :: ROOT ! Root of the parse tree
    character(len=*), intent(in), optional :: NAME
    ! Internal variables
    character(len=80) :: Booleanstring  ! E.g., 'BAND8'
    character(len=64) :: cvalue
    integer :: c
    integer :: FieldIndex
    integer :: GSON, J
    character(len=80) :: KEYSTRING
    integer :: Me = -1                  ! String index for trace cacheing
    character(len=16) :: MYNAME
    integer :: NVALUES
    integer :: Son
    integer :: VALUE_FIELD
    logical :: verbose, verboser

    ! Executable
    verbose = BeVerbose ( 'bool', -1 )
    verboser = BeVerbose ( 'bool', 0 )
    myName = 'Skip'
    if ( present(name) ) myName = name
    call trace_begin ( me, myName, root, cond=toggle(gen) )
    BooleanString = ' '
    exitToNextChunk = .false. ! Defaults to not skipping rest current chunk
    skip = .true. ! Defaults to skipping rest of section
    value_field = 0
    do j = 2, nsons(root)
      son = subtree(j,root) ! The argument
      fieldIndex = get_field_id(son)
      gson = son
      if (nsons(son) > 1) gson = subtree(2,son) ! Now value of said argument
      select case ( fieldIndex )
      case (f_Boolean)
        call get_string ( sub_rosa(gson), BooleanString, strip=.true. )
        BooleanString = lowerCase(BooleanString)
        if ( verboser ) then
          call output( 'Calling BooleanValue', advance='yes' )
          call output( runTimeValues%lkeys, advance='yes' )
          call output( runTimeValues%lvalues, advance='yes' )
        end if
        skip = BooleanValue ( trim(BooleanString), &
          & runTimeValues%lkeys, runTimeValues%lvalues, runTimeValues%sep )
      case ( f_formula )
        call get_string ( sub_rosa(gson), BooleanString, strip=.true. )
        if ( verboser ) call outputNamedValue( 'formula', trim(BooleanString) )
        skip = myBooleanValue ( BooleanString )
      case ( f_nextChunk )
        exitToNextChunk = Get_Boolean ( gson )
      case ( f_values )
        value_field = son
      case default
        ! Should not have got here if parser worked correctly
      end select
      if ( verboser .and. len_trim(BooleanString) > 0 ) then
        call output( trim(BooleanString) // ' = ', advance='no' )
        call output( skip, advance='yes' )
      end if
      if ( skip ) &
        & call output( '(Skipping rest of this section)', advance='yes' )
    end do
    ! The following should only occur if we were called as Repeat
    ! with a values=[...] field
    if ( value_field > 0 ) then
      nvalues = nsons(value_field)-1
      ! Now, have we run out of values to Repeat over?
      call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
        & 'count', cvalue, countEmpty=countEmpty, &
        & inseparator=runTimeValues%sep )
      call readIntsFromChars ( cvalue, c )
      if ( verboser ) then
        call outputnamedValue( 'nvalues', nvalues)
        call outputnamedValue( 'cvalue', trim(cvalue) )
      end if
      if ( c+1 > nvalues ) then
        Skip = .false.
      else if ( c < 1 ) then
        ! The first time through, so try to grok values field
        ! and then store the number of values as 'countsn' and the individual
        ! values as 'counts(1)' 'counts(2)' ..
        call writeIntsToChars( nvalues, BooleanString )
        call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
          & 'countsn', BooleanString, &
          & countEmpty=countEmpty, &
          & inseparator=runTimeValues%sep )
        do j=2, nvalues+1
          call writeIntsToChars( j-1, keyString )
          keyString = 'counts(' // trim(adjustl(keystring)) // ')'
          call get_string( sub_rosa(subtree(j, value_field)), BooleanString, strip=.true. )
          if ( verboser ) then
            call outputnamedValue( 'keyString', trim(keyString) )
            call outputnamedValue( 'BooleanString', trim(BooleanString) )
          end if
          call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
            & keyString, BooleanString, &
            & countEmpty=countEmpty, &
            & inseparator=runTimeValues%sep )
        enddo
      end if
    end if
    call trace_end ( myName, cond=toggle(gen) )
  end function Skip

! =====     Private Procedures     =====================================

  ! ----------------------------------------------  AnnounceError  -----
  subroutine AnnounceError ( where, what, string )
    use MoreTree, only: StartErrorMessage

    integer, intent(in) :: What, Where
    character(len=*), intent(in), optional :: String

    call StartErrorMessage ( where )

    select case ( what )
    case ( noFile )
      call output ( "File " // string // " not in database." )
    case ( noFileDatabase )
      call output ( "File database not provided." )
    case ( noFWM )
      call output ( "Can't dump Forward Model Configs here." )
    case ( noGriddedData )
      call output ( "Can't dump GriddedData here, or GriddedDatabase empty. " )
    case ( noHGrid )
      call output ( "Can't dump HGrids here." )
    case ( noLines )
      call output ( "Can't dump Lines here." )
    case ( noQT )
      call output ( "Can't dump Quantity Templates here." )
    case ( noradiometers )
      call output ( "Can't dump Radiometers here." )
    case ( noSignals )
      call output ( "Can't dump Signals here." )
    case ( noTG )
      call output ( "Can't dump TGrids here." )
    case ( noVectors )
      call output ( "Can't dump Vectors here." )
    case ( noVT )
      call output ( "Can't dump Vector Templates here." )
    case ( stop )
      call output ( "Program stopped by /stop field on DUMP statement." )
    case ( unknown )
      call output ( "Can't figure out what kind of template it is." )
    case default
      if ( present(string) ) call output ( string )
      call output ( "No reserved error flag for this" )
    end select
    call newLine
  end subroutine AnnounceError

  ! --------------------------------------------  BooleanToString  -----
  function BooleanToString ( BOOL ) result ( STR )
    ! Convert a Boolean argument to a character-valued string
    ! I.e., .true. -> 'true'
    !       .false. -> 'false'
    ! Args
    logical, intent(in) :: Bool
    character(len=6)    :: str
    str = merge( 'true ', 'false', Bool )
  end function BooleanToString

  ! ---------------------------------------------  myBooleanValue  -----
  function myBooleanValue ( FORMULA ) result ( BVALUE )
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: BooleanValue, GetStringElement
    use MLSStrings, only: Lowercase, ReadNumsFromChars
    ! Calculate the Boolean value according to
    ! (1) The logical value of its formula, if the formula
    !     does not contain the special operators "==" or "/="
    ! (2) if the formula is "variable == value" and variable is
    !     is recognized and takes the value "value", return "true", else "false"
    ! (3) if the formula is "variable /= value" return not (2)
    ! (4) if the formula is "variable < value" "true" if variable < value
    character(len=*), intent(in) :: formula
    logical :: bvalue
    ! Internal variables
    character(len=16) :: lhs, rhs
    logical, parameter :: countEmpty = .false.
    logical :: reverse  ! Do we mean NOT equal?
    logical :: verbose
    real :: x
    real :: y
    ! Executable
    verbose = BeVerbose ( 'bool', -1 )
    bvalue = .false.
    reverse = .false.
    if ( index(formula, "==") > 1 ) then
      if ( verbose ) call output( 'Have "=="', advance='yes' )
      call GetStringElement ( formula, lhs, &
        & 1, countEmpty, inseparator='=' )
      call GetStringElement ( formula, rhs, &
        & 2, countEmpty, inseparator='=' )
    elseif ( index(formula, "/=") > 1 ) then
      if ( verbose ) call output( 'Have "/="', advance='yes' )
      call GetStringElement ( formula, lhs, &
        & 1, countEmpty, inseparator='/' )
      call GetStringElement ( formula, rhs, &
        & 2, countEmpty, inseparator='=' )
      reverse = .true.
    elseif ( index(formula, "<") > 1 ) then
      if ( verbose ) call output( 'Have "<"', advance='yes' )
      call GetStringElement ( formula, lhs, &
        & 1, countEmpty, inseparator='<' )
      call GetStringElement ( formula, rhs, &
        & 2, countEmpty, inseparator='<' )
      if ( verbose ) then
        call outputnamedvalue('lhs', trim(lhs) )
        call outputnamedvalue('rhs', trim(rhs) )
      end if
      lhs = Evaluator(lowercase(adjustl(lhs)))
      rhs = Evaluator(lowercase(adjustl(rhs)))
      if ( verbose ) then
        call outputnamedvalue('lhs', trim(lhs) )
        call outputnamedvalue('rhs', trim(rhs) )
      end if
      call readNumsFromChars ( lhs, x )
      call readNumsFromChars ( rhs, y )
      bvalue = ( x < y )
      if ( verbose ) then
        call outputNamedValue( 'x', x )
        call outputNamedValue( 'y', y )
      end if
      return
    elseif ( index(formula, ">") > 1 ) then
      if ( verbose ) call output( 'Have ">"', advance='yes' )
      call GetStringElement ( formula, lhs, &
        & 1, countEmpty, inseparator='>' )
      call GetStringElement ( formula, rhs, &
        & 2, countEmpty, inseparator='>' )
      lhs = Evaluator(lowercase(adjustl(lhs)))
      rhs = Evaluator(lowercase(adjustl(rhs)))
      call readNumsFromChars ( lhs, x )
      call readNumsFromChars ( rhs, y )
      if ( verbose ) then
        call outputNamedValue( 'x', x )
        call outputNamedValue( 'y', y )
      end if
      bvalue = ( x > y )
      return
    else
      if ( verbose ) then
        call output( 'Calling BooleanValue', advance='yes' )
        call output( runTimeValues%lkeys, advance='yes' )
        call output( runTimeValues%lvalues, advance='yes' )
      end if
      bvalue = BooleanValue ( trim(formula), &
        & runTimeValues%lkeys, runTimeValues%lvalues, runTimeValues%sep )
      if ( verbose ) &
        & call outputnamedvalue( trim(formula) // 'evaluates', bvalue )
      return
    end if
    rhs = lowercase(adjustl(rhs))
    ! OK, so now let's try to make sense of the lhs
    ! Note the necessary type conversions for some variables
    ! that aren't chracter-valued
    ! (Should we have done this for rhs, too?)
    lhs = Evaluator(lowercase(adjustl(lhs)))
    bvalue = (lhs == rhs)
    if ( verbose ) then
      call outputnamedvalue('lhs', trim(lhs) )
      call outputnamedvalue('rhs', trim(rhs) )
    end if
    if ( reverse ) bvalue = .not. bvalue  ! If we meant not equal
  end function myBooleanValue

  ! -----------------------------------------  DumpBooleans  -----
  ! Dump runtime values as table of paired keys and values
  subroutine DumpBooleans
    use MLSL2Options, only: DumpMacros
    call output ( 'Run-time "Booleans"', advance='yes' )
    call dumpMacros( details=1 )
  end subroutine DumpBooleans

  ! -----------------------------------------  EvaluateExplicitly  -----
  function EvaluateExplicitly ( FORMULA ) result( ITSVALUE )
    ! Evaluate all the terms in a formula
    use MLSL2Options, only: RuntimeValues
    use MLSStringLists, only: List2Array, EvaluateFormula, NumStringElements
    ! Args
    character(len=*), intent(in) :: formula
    character(len=MAXRESULTLEN)  :: itsValue
    ! Internal variables
    character(len=64), dimension(1024) :: keys, values
    integer :: n
    ! Executable
    n = NumStringElements( runtimevalues%lkeys, countEmpty, &
      & inseparator=runTimeValues%sep )
    ! call outputNamedValue ( 'n', n )
    call List2Array( runtimevalues%lkeys, keys, countEmpty, &
      & inseparator=runTimeValues%sep, &
      & ignoreLeadingSpaces=.true. )
    call List2Array( runtimevalues%lvalues, values, countEmpty, &
      & inseparator=runTimeValues%sep, &
      & ignoreLeadingSpaces=.true. )
    itsValue = evaluateFormula( formula, values, keys )
  end function EvaluateExplicitly

  ! -------------------------------------------  EvaluateTermwise  -----
  function EvaluateTermwise ( FORMULA ) result( ITSVALUE )
    ! Evaluate all the terms in a formula
    use MLSStringLists, only: Array2List, List2Array, NumStringElements
    ! Args
    character(len=*), intent(in) :: formula
    character(len=MAXRESULTLEN)  :: itsValue
    ! Internal variables
    character(len=MAXRESULTLEN), dimension(24) :: array, array2
    integer :: n
    ! Executable
    n = NumStringElements( formula, countEmpty, inseparator=' ' )
    ! call outputNamedValue ( 'n', n )
    call List2Array( formula, array, countEmpty, inseparator=' ', &
      & ignoreLeadingSpaces=.true. )
    array2 = Evaluator( array )
    call Array2List( array2(1:n), itsValue, inseparator=' ' )
  end function EvaluateTermwise

  ! --------------------------------------------  Evaluator_array  -----
  ! This family of functions evaluates a character-valued arg,
  ! being alert for special values
  ! that name global variables, e.g. 'phasename'
  function Evaluator_array ( ARRAY ) result( VALUES )
    ! Args
    character(len=*), dimension(:), intent(in)           :: array
    character(len=MAXRESULTLEN), dimension(size(array))  :: values
    ! Internal variables
    integer :: i
    ! Executable
    do i=1, size(array)
      values(i) = Evaluator_sca( array(i) )
    enddo
  end function Evaluator_array

  ! ----------------------------------------------  Evaluator_sca  -----
  function Evaluator_sca ( ARG ) result( ITSVALUE )
    use MLSL2Options, only: Checkpaths, Need_L1bFiles, &
      & RuntimeValues, L2Options
    use MLSL2Options, only: L2Options
    use MLSStringLists, only: GetHashElement
    use MLSStrings, only: Lowercase, WriteIntsToChars
    ! Args
    character(len=*), intent(in) :: arg
    character(len=MAXRESULTLEN)  :: itsValue
    ! Executable
    select case (arg)
    case ('checkpaths')
      itsValue = merge( 'true ', 'false', checkpaths )
    case ('chunknumber')
      call writeIntsToChars ( L2Options%currentChunkNumber, itsValue )
    case ('count')
      call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
        & arg, itsValue, countEmpty=countEmpty, &
        & inseparator=runTimeValues%sep )
    case ('phasename')
      itsValue = lowercase(L2Options%currentphaseName)
    case ('need_l1bfiles')
      itsValue = merge( 'true ', 'false', need_l1bfiles )
    case ('skipretrieval')
      itsValue = merge( 'true ', 'false', L2Options%skipretrieval )
    case default
      ! What did you mean?
      ! Maybe just whether two character strings are the same
      ! that were assembled using m4 trickery
      ! But first, let's check that you're not naming a runtime Boolean
      call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
        & arg, itsValue, countEmpty=countEmpty, &
        & inseparator=runTimeValues%sep )
      if ( itsvalue == runTimeValues%sep ) itsValue = arg
    end select
  end function Evaluator_sca

  ! ------------------------------------------------  FinishMLSL2  -----
  subroutine FinishMLSL2 ( Show )
    use Output_M, only: OutputOptions
    use PrintIt_M, only: BothLogUnit, MLSMessageConfig
    use Time_M, only: Finish
    character(len=*), intent(in) :: Show
    ! Print to stdout and, if using Toolkit, log it, too
    if ( MLSMessageConfig%UseToolkit )  then
      OutputOptions%PrUnit = BothLogUnit
      MLSMessageConfig%LogFileUnit = BothLogUnit
    endif
    call Finish ( Show )
  end subroutine FinishMLSL2

  ! ------------------------------------------------  insertSpace  -----
  subroutine insertSpace
    ! We actually insert a space followed by a null; later the null will
    ! be removed before printing
    Text = trim(Text) // ' ' // achar(0)
  end subroutine insertSpace

  ! ------------------------------------------  outputLater_chars  -----
  subroutine outputLater_chars ( chars, advance )
    character(len=*), intent(in) :: chars
    character(len=*), optional, intent(in) :: advance
    text = trim(text) // chars
  end subroutine outputLater_chars

  ! --------------------------------------------  outputLater_int  -----
  subroutine outputLater_int ( arg, advance )
    integer, intent(in)             :: arg
    character(len=*), optional, intent(in) :: advance
    text = trim(text) // numToChars ( arg )
  end subroutine outputLater_int

  ! -------------------------------------------  outputLater_real  -----
  subroutine outputLater_real ( arg, advance )
    real, intent(in)             :: arg
    character(len=*), optional, intent(in) :: advance
    text = trim(text) // numToChars ( arg )
  end subroutine outputLater_real

  ! --------------------------------------------------  outputNow  -----
  subroutine outputNow
    ! Snip away the null chars before printing
    use MLSStrings, only: Asciify
    text = asciify( text, how='snip' )
    if ( asHeadLine ) then
      if ( headLineChars == 'yes' ) then
        call headLine( trim(text), Before='*', After='*', fillChar='-' )
      else
        call headLine( trim(text), &
          & Before=headLineChars(1:1), After=headLineChars(1:1), &
          & fillChar='-' )
      end if
    elseif ( asBanner ) then
      if ( lineLength > 0 ) then
        call banner( trim(asciify( text, how='snip' )), linelength=lineLength )
      else
        call banner( trim(asciify( text, how='snip' )) )
      end if
    elseif ( toStderr ) then
      call Beep ( trim(text) )
    else
      call output ( trim(text), advance='yes' )
    end if
  end subroutine outputNow

  ! -----------------------------------------  returnFullFileName  -----
  subroutine returnfullfilename ( shortname, fullname, &
    & pcf_start, pcf_end )
    use MLSFiles, only: GetPCFromRef
    use MLSL2Options, only: Toolkit
    ! Given a possibly-abbreviated shortName, return the full name
    ! as found in the PCF
    ! (w/o toolkit panoply, simply return shortName)
    ! Args
    character(len=*), intent(in)  :: shortName
    character(len=*), intent(out) :: FullName
    integer, intent(in)           :: pcf_start
    integer, intent(in)           :: pcf_end
    ! Internal variables
    logical, parameter :: DEBUG = .false.
    integer :: FileHandle
    integer :: returnStatus
    integer :: Version
    ! Executable
    if ( TOOLKIT .and. pcf_end >= pcf_start ) then
      Version = 1
      FileHandle = GetPCFromRef(shortName, pcf_start, &
        & pcf_end, &
        & TOOLKIT, returnStatus, Version, DEBUG, &
        & exactName=FullName)
      if ( returnStatus /= 0 ) FullName = shortName ! In cases omitted from PCF
    else
      FullName = shortName
    end if
  end subroutine returnFullFileName

  ! --------------------------------------------------  SayMemory  -----
  subroutine SayMemory
    use Memory_M, only: Memory_Used
    text = ' '
    call memory_used ( total=TotalMemory2 )
    call outputLater ( "Memory used since start = " )
    call insertSpace
    call outputLater ( TotalMemory2, advance = 'no' )
    call insertSpace
    if ( TotalMemory1 > 0. ) then
      call outputLater ( "(recent = ", advance='no' )
      call insertSpace
      call outputLater ( TotalMemory2 - TotalMemory1, advance = 'no' )
      call insertSpace
      call outputLater ( ")", advance='no' )
    end if
    call outputNow
  end subroutine SayMemory

  ! ----------------------------------------------------  SayTime  -----
  subroutine SayTime
    use Time_M, only: Time_Now
    text = ' '
    call time_now ( t2 )
    call outputLater ( "Time since start = " )
    call insertSpace
    call outputLater ( t2, advance = 'no' )
    call insertSpace
    if ( T1 > 0. ) then
      call outputLater ( "(lap = ", advance='no' )
      call insertSpace
      call outputLater ( t2 - t1, advance = 'no' )
      call insertSpace
      call outputLater ( ")", advance='no' )
    end if
    call outputNow
  end subroutine SayTime

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: DumpCommand_m.f90,v 2.149 2020/04/30 23:33:42 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module DumpCommand_M

! $Log: DumpCommand_m.f90,v $
! Revision 2.149  2020/04/30 23:33:42  pwagner
! Skip Dumping AllGriddedData only if Details lt -3
!
! Revision 2.148  2020/01/27 21:34:18  pwagner
! Consistent with new api for Dump_Signals
!
! Revision 2.147  2019/03/18 22:09:34  pwagner
! Ensure finishing messages are both printed and logged
!
! Revision 2.146  2018/12/11 01:26:13  pwagner
! Uses Wait_M
!
! Revision 2.145  2018/11/01 23:19:13  pwagner
! Use Pause from Time_M
!
! Revision 2.144  2018/10/19 00:03:46  pwagner
! inputFile= with /pause pauses to read from inputFile instead of stdin
!
! Revision 2.143  2018/10/17 23:05:04  pwagner
! Dump command can take /pause field to wait for user input for, e.g. debugging
!
! Revision 2.142  2018/09/13 20:22:32  pwagner
! Moved changeable options to new L2Options; added DumpOptions
!
! Revision 2.141  2018/09/07 00:00:15  pwagner
! More commands that set a runtime flag can now take /reverse
!
! Revision 2.140  2018/08/04 02:10:27  vsnyder
! Make Lines database allocatable instead of a pointer
!
! Revision 2.139  2018/07/27 23:18:48  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.138  2018/05/17 17:05:53  pwagner
! May Dump quantity values bitwise
!
! Revision 2.137  2018/04/19 23:44:09  pwagner
! Skip may take /nextChunk flag
!
! Revision 2.136  2018/03/22 18:17:00  pwagner
! Added command IsFileAbsent; may occur in ReadApriori, MergeGrids, and Output sections
!
! Revision 2.135  2018/03/05 19:49:38  pwagner
! Consistent with details arg to Dump_Signals now being an int
!
! Revision 2.134  2017/09/26 16:24:34  pwagner
! May use options field to set text as Headline or Banner
!
! Revision 2.133  2017/07/27 16:55:02  pwagner
! Reevaluate may take /truncate to keep integer part only
!
! Revision 2.132  2017/07/10 23:09:51  pwagner
! Print less if not verbose
!
! Revision 2.131  2017/02/22 18:01:56  pwagner
! Declaring a runtime Boolean without an initial value no longer generates a Warning
!
! Revision 2.130  2016/07/28 01:45:07  vsnyder
! Refactor dump and diff
!
! Revision 2.129  2016/05/18 01:37:30  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.128  2016/04/07 23:40:28  pwagner
! Should exit, not crash, if stopped by /stop flag to Execute
!
! Revision 2.127  2016/04/01 00:27:41  pwagner
! May now Execute a single command or a script of lines from l2cf
!
! Revision 2.126  2016/02/26 02:08:18  vsnyder
! Add ZOT switch
!
! Revision 2.125  2016/01/29 01:10:07  vsnyder
! Add polygon to Dump
!
! Revision 2.124  2015/10/06 00:23:48  pwagner
! When Dumping runtime Boolean, options='s' skips printing key
!
! Revision 2.123  2015/09/24 22:10:17  pwagner
! Dump command may optionally direct text to stderr
!
! Revision 2.122  2015/07/14 23:32:47  pwagner
! may divert Dump commands to named dumpFile; /truncate field
!
! Revision 2.121  2015/04/09 21:00:32  pwagner
! rank may be specified for Dump command; restored printing Dumped text field
!
! Revision 2.120  2015/02/27 23:13:52  pwagner
! May Dump global attributes
!
! Revision 2.119  2015/02/13 00:21:17  pwagner
! Nay dump Booleans more nicely as a Table
!
! Revision 2.118  2014/09/05 00:48:13  vsnyder
! Get field value correctly.  Remove USE for unreferenced names.  Add dumps
! for MatricesMemoryInUse, TotalMatrixSizes, TotalVectorSizes,
! VectorsMemoryInUse.  Some cannonball polishing.  New interface to
! Memory_Used.  Move some USE statements from module scope to procedure
! scope.  Add outputLaterInt.
!
! Revision 2.117  2014/08/28 19:07:16  pwagner
! May command Dump of /memory or /time; optionally to /reset
!
! Revision 2.116  2014/06/11 20:06:33  pwagner
! details level to skip all Dumps lowered to -3
!
! Revision 2.115  2014/05/31 00:24:55  pwagner
! Small corrections; details should now be -3 to skipAllDumps
!
! Revision 2.114  2014/04/25 18:53:45  pwagner
! options string to Dump text as headLine or Banner
!
! Revision 2.113  2014/04/10 02:02:22  vsnyder
! Improve message for nonexistent variable
!
! Revision 2.112  2014/04/10 00:45:41  pwagner
! Moved currentChunkNumber, currentPhaseName from MLSL2Timings to MLSL2Options
!
! Revision 2.111  2014/03/20 01:32:11  vsnyder
! Remove unreferenced USE name
!
! Revision 2.110  2014/02/28 01:10:44  vsnyder
! Remove unused names
!
! Revision 2.109  2014/02/28 00:17:05  vsnyder
! Don't re-check types already checked by type checker.  Move units checking
! to type checker.  Don't handle Height field, since there isn't one allowed
! in init_tables_module.
!
! Revision 2.108  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.107  2013/12/12 02:09:29  vsnyder
! Add 'details' to dump_a_decl
!
! Revision 2.106  2013/11/18 22:33:28  pwagner
! /callStack dumps verbose and debug dbs
!
! Revision 2.105  2013/11/07 00:26:44  pwagner
! May dump all dbs related to signals if details >1; use beVerbose
!
! Revision 2.104  2013/10/24 21:12:19  pwagner
! Corrected some bugs in dumping hyperslabs
!
! Revision 2.103  2013/10/17 18:27:29  pwagner
! Must call trace_end in MLSSelect no matter what
!
! Revision 2.102  2013/10/09 23:44:13  vsnyder
! Add Variable field
!
! Revision 2.101  2013/10/08 23:52:48  pwagner
! Fixed call to BooleanVALUE--must use trim
!
! Revision 2.100  2013/09/27 00:38:12  pwagner
! May select hyperslab when dumping quantity
!
! Revision 2.99  2013/09/25 18:46:50  pwagner
! Fixed bug introduced with last commit
!
! Revision 2.98  2013/09/25 16:33:27  pwagner
! Uses hyperslab fields when dumping vector.quantities
!
! Revision 2.97  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.96  2013/09/24 00:56:02  pwagner
! May specify hyperslab when dumping
!
! Revision 2.95  2013/09/21 00:38:11  vsnyder
! Add ChunkDivide
!
! Revision 2.94  2013/09/04 16:32:51  pwagner
! Replaced '--cat' cmdline option; 'Catenate' now an Output section command
!
! Revision 2.93  2013/08/31 02:29:12  vsnyder
! Replace MLSMessageCalls with trace_begin and trace_end
!
! Revision 2.92  2013/08/30 23:19:28  pwagner
! Fixed problem of empty spaces while tracing 'Skip'
!
! Revision 2.91  2013/08/29 19:37:41  pwagner
! May Dump plain stack, too
!
! Revision 2.90  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.89  2013/08/01 20:46:30  vsnyder
! Fix to dump two quantities with two quantity fields, two grids with two
! grid fields, two hessians with two hessian fields, two masks with two
! mask fields, or two matrices with two matrix fields.  Had been assuming
! that two fields meant doing a diff.
!
! Revision 2.88  2013/07/12 23:24:11  vsnyder
! Announce error for 'expr' field -- no code yet
!
! Revision 2.87  2013/05/22 20:20:49  pwagner
! Moved insertHashElement to MLSStringLists
!
! Revision 2.86  2013/05/17 00:55:47  pwagner
! May now do elementwise operations on r/t macros with repeat command; fixed many bugs
!
! Revision 2.85  2013/05/07 22:01:30  pwagner
! run-time Booleans can store arrays of values, formulas can evaluate named terms
!
! Revision 2.84  2013/04/24 00:36:02  pwagner
! Added inputBoolean and made Reevaluate formulas more powerful
!
! Revision 2.83  2013/04/22 17:49:20  pwagner
! Reevaluate may store a literal instead of a Boolean value
!
! Revision 2.82  2013/03/30 00:19:48  vsnyder
! Add quantity database to forward model config dump
!
! Revision 2.81  2013/02/21 21:38:10  pwagner
! Pass options string when dumping quantity mask
!
! Revision 2.80  2013/02/12 18:17:44  pwagner
! Removed SIPS_VERSION; raised -Sbool switch needed for most printing
!
! Revision 2.79  2012/12/04 00:19:14  pwagner
! May dump timings summary after Dump, /stop
!
! Revision 2.78  2012/08/16 18:03:44  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.77  2012/06/27 17:53:04  pwagner
! May now Dump command line
!
! Revision 2.76  2012/06/06 20:20:46  vsnyder
! Add line number to farewell for /stop
!
! Revision 2.75  2012/05/14 22:26:31  pwagner
! Guard against missing swath--counts as empty
!
! Revision 2.74  2012/05/11 00:16:42  pwagner
! Added BooleanFromEmptySwath
!
! Revision 2.73  2012/05/08 17:48:37  pwagner
! Added Select .. Case .. EndSelect control structure
!
! Revision 2.72  2012/05/01 23:18:13  pwagner
! More capable Boolean formula; adds relations
!
! Revision 2.71  2012/04/26 23:28:33  pwagner
! May Dump chunk number, phase name; BooleanFromFormula can compare strings, variables
!
! Revision 2.70  2012/04/20 01:29:56  vsnyder
! Add call to Finish before stopping
!
! Revision 2.69  2012/04/20 01:03:30  pwagner
! May dump callStack from within l2cf
!
! Revision 2.68  2012/03/28 23:14:14  vsnyder
! Pass options to Dump_GH, add 'c' to options if /clean appears
!
! Revision 2.67  2012/03/15 22:50:39  vsnyder
! Add IGRF dump
!
! Revision 2.66  2012/02/28 00:16:42  vsnyder
! Repair %S, which was referencing cpu_time without it being assigned a value
!
! Revision 2.65  2012/02/02 00:56:00  pwagner
! Fix bug in Diffing matrices
!
! Revision 2.64  2011/11/04 00:29:28  pwagner
! :Fixed something only NAg complained about when Matrices not associated yet
!
! Revision 2.63  2011/08/29 22:12:13  pwagner
! Should not attempt to take size of disassociated pointer HessianDataBase
!
! Revision 2.62  2011/06/02 19:25:01  pwagner
! May dump allRadiometers
!
! Revision 2.61  2011/05/09 18:08:57  pwagner
! Print notice of changed runtime Booleans only when "bool" switch is set
!
! Revision 2.60  2011/04/20 16:47:54  pwagner
! Added BooleanFromEmptyGrid
!
! Revision 2.59  2011/04/13 00:26:17  pwagner
! options='' works how comments and wiki says it does for vect.qty
!
! Revision 2.58  2011/04/04 23:07:21  pwagner
! May diff just quantity mask
!
! Revision 2.57  2011/03/15 23:02:45  pwagner
! Dump qty with options 0, 1, or 2 to choose template, values, or mask
!
! Revision 2.56  2011/03/08 18:28:06  pwagner
! May optionally diff, dump just values of vectorqtys
!
! Revision 2.55  2010/11/19 23:59:23  pwagner
! Passes options string to Hessians diff
!
! Revision 2.54  2010/11/05 22:37:06  pwagner
! Pass optionsString to dumps of L2PC, Hessians
!
! Revision 2.53  2010/08/13 22:08:57  pwagner
! May diff hessians, matrices
!
! Revision 2.52  2010/08/06 23:08:48  pwagner
! Pass Hessians, matrices to DumpCommand
!
! Revision 2.51  2010/04/17 01:44:26  vsnyder
! Add details to DumpL2PC calls, spiff up an error message
!
! Revision 2.50  2010/04/16 01:39:34  vsnyder
! Added /allFiles and file fields to dump file database
!
! Revision 2.49  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
! Revision 2.48  2009/11/02 21:22:25  pwagner
! May diff grided data
!
! Revision 2.47  2009/10/27 22:18:18  pwagner
! Implemented new Diff command; so far only of vector quantities
!
! Revision 2.46  2009/09/15 20:03:48  pwagner
! Dump commands take Boolean fields /stop, /stopWithError, /crashBurn
!
! Revision 2.45  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.44  2008/12/18 21:12:00  pwagner
! May now dump an l2pc or allL2PCs (use with caution)
!
! Revision 2.43  2008/09/30 22:00:22  vsnyder
! Add PRINT statement to Not_Used_Here to reduce compilation cascades
!
! Revision 2.42  2008/06/05 02:07:43  vsnyder
! Dump Mie tables
!
! Revision 2.41  2007/12/07 01:12:43  pwagner
! Lets us catch warnings and assign to runtime Booleans
!
! Revision 2.40  2007/11/15 22:54:51  pwagner
! Functions to set runtimeBooleans moved here
!
! Revision 2.39  2007/11/05 18:36:44  pwagner
! May Skip remaining lines in Fill, Join, Retrieve sections depending on Boolean
!
! Revision 2.38  2007/10/09 00:32:05  pwagner
! Added ability to dump masks of quantities, vectors
!
! Revision 2.37  2007/10/03 23:53:05  vsnyder
! Stop with error if /stop and switch 'erh' is set
!
! Revision 2.36  2007/08/17 00:32:16  pwagner
! Unneeded changes
!
! Revision 2.35  2007/04/03 17:37:17  vsnyder
! Check Vectors for zero size instead of associated
!
! Revision 2.34  2007/01/11 20:44:55  vsnyder
! Add Tracing
!
! Revision 2.33  2006/09/21 18:48:33  pwagner
! Reduce level of dumps in SIDS version
!
! Revision 2.32  2006/07/27 03:52:41  vsnyder
! Pass details to dumps for vectors and vector templates
!
! Revision 2.31  2006/07/19 22:26:40  vsnyder
! Comment out unused USE
!
! Revision 2.30  2006/06/12 16:28:25  pwagner
! Added ability to dump Gridded Data
!
! Revision 2.29  2006/05/31 22:38:17  vsnyder
! Revert to details= semantics that Van prefers
!
! Revision 2.28  2006/05/03 20:14:05  pwagner
! details and /stop properly implemented
!
! Revision 2.27  2006/03/22 02:19:48  vsnyder
! Add Vector argument to quantity dump to get its name
!
! Revision 2.26  2006/03/07 16:23:52  pwagner
! Fixed bug only NAG caught
!
! Revision 2.25  2006/03/07 00:49:42  pwagner
! May dump Booleans
!
! Revision 2.24  2006/01/04 01:21:30  vsnyder
! Make optional arguments pointers, in case actuals aren't associated
!
! Revision 2.23  2005/06/03 02:06:55  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! get VGrids from VGridsDatabase instead of an argument, add dumps for
! PFA structure, PFA datum by number.
!
! Revision 2.22  2005/05/02 23:11:37  vsnyder
! Add dump of PFAFiles database
!
! Revision 2.21  2005/04/01 20:48:28  vsnyder
! Add mark and text fields to dump command
!
! Revision 2.20  2005/03/26 01:34:00  vsnyder
! Add stop message
!
! Revision 2.19  2005/03/15 01:36:08  vsnyder
! Add newline after error messages
!
! Revision 2.18  2005/01/12 03:18:51  vsnyder
! Add item number to PFA dump
!
! Revision 2.17  2004/12/28 00:22:03  vsnyder
! Add not_used_here
!
! Revision 2.16  2004/12/13 20:13:04  vsnyder
! Add dumps for AllLines, AllSignals, AllSpectra, Lines, Signals, Spectroscopy,
! and a Stop command.
!
! Revision 2.15  2004/11/04 06:37:34  vsnyder
! Index spetroscopy catalog by molecule instead of searching
!
! Revision 2.14  2004/11/01 20:16:20  vsnyder
! Check for spectroscopy catalog before trying to dump it
!
! Revision 2.13  2004/10/30 00:26:46  vsnyder
! Add 'spectroscopy' field to DumpCommand
!
! Revision 2.12  2004/10/06 20:19:39  vsnyder
! Cannonball polishing
!
! Revision 2.11  2004/09/24 22:24:20  vsnyder
! Make PFA dump aware of 'details' switch
!
! Revision 2.10  2004/07/17 02:28:19  vsnyder
! Add dump for entire PFA database
!
! Revision 2.9  2004/06/12 00:41:30  vsnyder
! Allow all fields except details to be arrays
!
! Revision 2.8  2004/06/09 19:59:38  pwagner
! Gets PFAData type and dump method from PFADataBase_m
!
! Revision 2.7  2004/06/08 20:20:18  vsnyder
! Add tGrid
!
! Revision 2.6  2004/05/29 02:50:49  vsnyder
! Added more dumps
!
! Revision 2.5  2004/05/22 02:31:23  vsnyder
! Dump PFAData, VGrids
!
! Revision 2.4  2004/05/20 19:47:36  vsnyder
! Move Dump*Hgrid from Dumper to HgridsDatabse
!
! Revision 2.3  2004/05/18 01:18:51  vsnyder
! Add dump for HGrid
!
! Revision 2.2  2004/05/11 02:53:29  vsnyder
! Remove USEs for unreferenced symbols
!
! Revision 2.1  2004/05/01 04:04:16  vsnyder
! Initial commit
!
@


2.149
log
@Skip Dumping AllGriddedData only if Details lt -3
@
text
@d20 1
d32 2
d65 4
d105 4
a175 1
    use Chunks_M, only: MLSChunk_T
d680 156
d3415 1
a3415 1
       "$Id: DumpCommand_m.f90,v 2.148 2020/01/27 21:34:18 pwagner Exp $"
d3425 3
@


2.148
log
@Consistent with new api for Dump_Signals
@
text
@d1460 1
a1460 1
            if ( details < -2 ) cycle
d3249 1
a3249 1
       "$Id: DumpCommand_m.f90,v 2.147 2019/03/18 22:09:34 pwagner Exp $"
d3259 3
@


2.147
log
@Ensure finishing messages are both printed and logged
@
text
@d2055 1
a2055 1
          call dump ( signals(what), details=details>0 )
d3249 1
a3249 1
       "$Id: DumpCommand_m.f90,v 2.146 2018/12/11 01:26:13 pwagner Exp $"
d3259 3
@


2.146
log
@Uses Wait_M
@
text
@d1251 1
a1251 1
    use Time_M, only: Finish, Time_Config
d1568 1
a1568 1
            call finish ( 'ending mlsl2' )
d1614 1
a1614 1
            call finish ( 'ending mlsl2' )
a2275 1
    use Time_M, only: Finish
d2391 1
a2391 1
        call finish ( 'ending mlsl2' )
d2425 1
a2425 1
        call finish ( 'ending mlsl2' )
d2889 11
d3109 13
a3121 10
  ! --------------------------------------------  BooleanToString  -----
  function BooleanToString ( BOOL ) result ( STR )
    ! Convert a Boolean argument to a character-valued string
    ! I.e., .true. -> 'true'
    !       .false. -> 'false'
    ! Args
    logical, intent(in) :: Bool
    character(len=6)    :: str
    str = merge( 'true ', 'false', Bool )
  end function BooleanToString
d3249 1
a3249 1
       "$Id: DumpCommand_m.f90,v 2.145 2018/11/01 23:19:13 pwagner Exp $"
d3259 3
@


2.145
log
@Use Pause from Time_M
@
text
@d1251 1
a1251 1
    use Time_M, only: Finish, Time_Config, Wait_For_Event, Pause
d1261 1
d3236 1
a3236 1
       "$Id: DumpCommand_m.f90,v 2.144 2018/10/19 00:03:46 pwagner Exp $"
d3246 3
@


2.144
log
@inputFile= with /pause pauses to read from inputFile instead of stdin
@
text
@d166 1
a166 1
    use Init_Tables_Module, only: F_Signal, F_Boolean, F_Reverse
a172 1
    use MoreTree, only: Get_Boolean
a184 1
    integer :: fieldValue
a206 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
a285 1
    integer :: fieldValue
a309 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
a381 1
    integer :: fieldValue
a396 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
a476 1
    integer :: fieldValue
a499 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
d1251 1
a1251 1
    use Time_M, only: Finish, Time_Config, Wait_For_Event
d1590 5
a1594 4
              call output ( 'Program paused by /pause field on Dump statement' &
                & // ' .. to read command from ' // trim(nameString), &
                & advance='yes' )
              call Wait_then_read_mesg( nameString, mesg )
d1598 3
a1600 2
              call output ( 'Program paused by /pause field on Dump statement.', &
                & advance='yes pause' )
d2488 2
a2489 2
  ! ------------------------------------------------  INITIALIZEREPEAT  -----
  subroutine  INITIALIZEREPEAT
d2500 1
a2500 1
  subroutine  NEXTREPEAT
d3235 1
a3235 1
       "$Id: DumpCommand_m.f90,v 2.143 2018/10/17 23:05:04 pwagner Exp $"
d3245 3
@


2.143
log
@Dump command can take /pause field to wait for user input for, e.g. debugging
@
text
@d134 1
d1232 1
a1232 1
      & F_Hessian, F_Hgrid, F_Igrf, &
d1252 1
a1252 1
    use MLSFiles, only: DumpMLSFile => Dump, GetMLSFilebyname
d1276 1
a1276 1
    use Time_M, only: Finish
d1337 1
d1418 1
d1441 2
d1610 15
a1624 2
            call output ( 'Program paused by /pause field on DUMP statement.', &
              & advance='yes pause' )
d1781 1
a1781 1
      case ( f_file )
d1787 3
a1789 1
            if ( associated(oneMLSFile) ) then
d2255 21
a2275 1

d2689 1
a2689 1
  subroutine  MLSENDSELECT ( ROOT )
a2692 1
    use MLSMessageModule, only: MLSMSG_Info
d3258 1
a3258 1
       "$Id: DumpCommand_m.f90,v 2.142 2018/09/13 20:22:32 pwagner Exp $"
d3268 3
@


2.142
log
@Moved changeable options to new L2Options; added DumpOptions
@
text
@d1233 2
a1234 1
      & F_Mietables, F_Options, F_PfaData, F_PfaFiles, F_Pfanum, F_Pfastru, &
d1456 3
a1458 2
        & f_DACSfilterShapes, f_filterShapes, f_globalAttributes, f_igrf, f_memory, &
        & f_MieTables, f_pfaFiles, f_pfaStru, f_phaseName, f_pointingGrids, &
d1604 3
d3219 1
a3219 1
       "$Id: DumpCommand_m.f90,v 2.141 2018/09/07 00:00:15 pwagner Exp $"
d3229 3
@


2.141
log
@More commands that set a runtime flag can now take /reverse
@
text
@d1253 1
a1253 1
    use MLSL2Options, only: Command_Line, CurrentChunkNumber, CurrentPhaseName, &
d1581 1
a1581 1
            call outputNamedValue ( 'chunk number', currentChunkNumber )
d1583 1
a1583 1
            call outputNamedValue ( 'command line', command_line )
d1607 1
a1607 1
            call outputNamedValue ( 'phase name', currentphaseName )
d3042 2
a3043 2
      & RuntimeValues, Skipretrieval
    use MLSL2Options, only: CurrentChunkNumber, CurrentPhaseName
d3054 1
a3054 1
      call writeIntsToChars ( currentChunkNumber, itsValue )
d3060 1
a3060 1
      itsValue = lowercase(currentPhaseName)
d3064 1
a3064 1
      itsValue = merge( 'true ', 'false', skipretrieval )
d3214 1
a3214 1
       "$Id: DumpCommand_m.f90,v 2.140 2018/08/04 02:10:27 vsnyder Exp $"
d3224 3
@


2.140
log
@Make Lines database allocatable instead of a pointer
@
text
@d32 1
a32 1
  public :: BooleanFromEmptygrid, BooleanFromEmptySwath
d68 2
a69 1
!               The specified swath in the specified file has no useable data
d101 1
a101 1
! DumpCommand ( int root, type (quantityTemplate_t) quantityTemplatesDB(:), &
d160 1
a160 1
  function booleanFromAnyGoodRadiances ( root, chunk, filedatabase ) &
d165 1
a165 1
    use Init_Tables_Module, only: F_Signal, F_Boolean
d172 1
d180 1
a180 1
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
d188 1
d198 1
d253 4
d274 1
a274 1
      & F_Quantity, F_Boolean, F_Status
d280 1
d295 6
a300 5
    type (vectorValue_T), pointer :: PRECISIONQUANTITY
    integer :: QUANTITYINDEX
    real(rv) :: QUALITY_MIN
    type (vectorValue_T), pointer :: QUALITYQUANTITY
    type (vectorValue_T), pointer :: Quantity
d303 1
a303 1
    type (vectorValue_T), pointer :: STATUSQUANTITY
d305 1
a305 1
    integer :: VECTORINDEX
d308 1
d348 2
d356 4
d490 2
a491 2
    type (vectorValue_T), pointer :: AQUANTITY
    type (vectorValue_T), pointer :: BQUANTITY
d697 1
a697 1
    use Init_Tables_Module, only: F_Boolean, F_Grid
d702 1
d707 1
a707 1
    type (GRIDDEDDATA_T), dimension(:), pointer :: Grids
d713 1
a713 1
    type (GRIDDEDDATA_T), pointer :: grid
d716 1
d722 1
a727 1
      value = subtree(2,son)
d730 1
d733 1
d742 2
d748 4
d783 1
a783 1
      & F_Swath, F_Type, &
d810 1
a810 1
    character (len=FileNameLen) :: FILE_BASE    ! From the FILE= field
d812 1
a812 1
    logical, dimension(field_first:field_last) :: GOT
d818 1
d831 2
a835 1
      value = subtree(2,son)
d838 1
d841 1
d851 3
a853 1
        noPCFid = get_boolean(son)
d907 1
d936 1
a936 1
      & F_Formula, F_Inputboolean, F_Truncate, &
d955 2
a956 2
    integer, intent(in) :: NAME
    integer, intent(in) :: ROOT
d960 1
a960 1
    character(len=80) :: BOOLEANSTRING  ! E.g., 'BAND13_OK'
d962 3
a964 3
    type (vectorValue_T), pointer :: AQUANTITY
    type (vectorValue_T), target  :: ATARGET
    type (vectorValue_T), pointer :: BQUANTITY
d976 1
a976 1
    character(len=80) :: KEYSTRING
d979 2
a980 2
    integer :: NVALUES
    integer :: QUANTITYINDEX
d983 2
a984 2
    type (vectorValue_T) :: TQUANTITY ! Temporary
    type(QUANTITYTEMPLATE_T) :: TTEMPLATE
d987 3
a989 3
    integer, dimension(2) :: UNITASARRAY ! From expr
    real(r8), dimension(2) :: VALUEASARRAY ! From expr
    integer :: VECTORINDEX
d1049 1
a1049 1
        evaluate = get_boolean ( fieldValue )
d1060 1
a1060 1
        truncate = get_boolean ( fieldValue )
d1067 1
a1067 1
        literal = get_boolean ( fieldValue )
d1108 1
a1108 1
      call get_string( sub_rosa(subtree(2, value_field)), booleanString, &
d1111 1
a1111 1
        & lowercase(trim(nameString)), booleanString, &
d1125 1
a1125 1
        & keyString, booleanString, &
d1136 1
a1136 1
        call get_string( sub_rosa(subtree(j, value_field)), booleanString, strip=.true. )
d1142 1
a1142 1
          & keyString, booleanString, &
d1157 1
a1157 1
      call CloneVectorQuantity ( tQuantity, aQuantity )
d1162 1
a1162 1
      call Manipulate( tQuantity, AQuantity, BQuantity, C, formula, &
d1164 2
a1165 2
      formula = numToChars ( tQuantity%values(1,1) )
      if ( truncate ) formula = numToChars ( int(tQuantity%values(1,1)) )
d1169 1
a1169 1
      call destroyVectorQuantityValue ( tQuantity, &
d1221 1
a1221 1
    use Init_Tables_Module, only: F_Allbooleans, F_AllFiles, &
d1287 1
a1287 1
    type (quantityTemplate_t), dimension(:), pointer, optional   :: QuantityTemplatesDB
d1297 1
a1297 1
    character(len=80) :: BOOLEANSTRING  ! E.g., 'BAND13_OK'
d1325 1
a1325 1
    character(len=80) :: KEYSTRING  ! E.g., 'BAND13_OK'
d1335 1
a1335 1
    character(len=80) :: NAMESTRING  ! E.g., 'L2PC-band15-SZASCALARHIRES'
d1341 1
a1341 1
    type (vectorValue_T), pointer :: QUANTITY
d1344 1
a1344 1
    type (VectorValue_T), pointer :: QTY1, QTY2
d1349 2
a1350 2
    integer, dimension(3) :: START, COUNT, STRIDE, BLOCK
    integer :: STARTNODE
d1459 1
a1459 1
        if ( get_boolean(son) ) then
d1670 3
a1672 3
        call get_string ( sub_rosa(gson), booleanString, strip=.true. )
        if ( truncate ) call truncate_textFile( booleanString )
        call switchOutput ( booleanString )
d1674 1
a1674 1
        truncate = get_boolean(son)
d1676 2
a1677 2
        call get_string ( sub_rosa(gson), booleanString, strip=.true. )
        booleanString = lowerCase(booleanString)
d1680 1
a1680 1
          & trim(booleanString) // 'n', label, countEmpty, &
d1685 1
a1685 1
            & booleanString, label, countEmpty, &
d1689 1
a1689 1
            text = trim(booleanString) // ' = ' // label
d1694 1
a1694 1
          call output( 'array-valued run-time Boolean ' // trim(booleanString), &
d1701 1
a1701 1
            keyString = trim(booleanString) // '(' // trim(adjustl(label)) // ')'
d1719 1
a1719 1
        clean = get_boolean(son)
d1730 1
a1730 1
        reset = get_boolean(son)
d1873 1
a1873 1
        if ( get_boolean(son) ) call cpu_time ( cpuTimeBase )
d2312 1
a2312 1
          wait = get_boolean(son)
d2515 1
a2515 1
  subroutine  MLSCASE ( ROOT )
d2532 1
a2532 1
    character(len=80) :: BOOLEANSTRING  ! E.g., 'BAND8'
d2558 2
a2559 2
        call get_string ( sub_rosa(gson), booleanString, strip=.true. )
        booleanString = lowerCase(booleanString)
d2561 1
a2561 1
          & booleanString, label, countEmpty, &
d2589 1
a2589 1
  subroutine  MLSSELECT ( ROOT )
d2604 1
a2604 1
    character(len=80) :: BOOLEANSTRING  ! E.g., 'BAND8'
d2624 2
a2625 2
        call get_string ( sub_rosa(gson), booleanString, strip=.true. )
        booleanString = lowerCase(booleanString)
d2627 1
a2627 1
          & booleanString, label, countEmpty, &
d2708 1
a2708 1
  logical function skip ( root, name )
d2722 1
a2722 1
    character(len=80) :: BOOLEANSTRING  ! E.g., 'BAND13_OK'
d2741 1
a2741 1
    booleanString = ' '
d2752 2
a2753 2
        call get_string ( sub_rosa(gson), booleanString, strip=.true. )
        booleanString = lowerCase(booleanString)
d2759 1
a2759 1
        skip = BooleanValue ( trim(booleanString), &
d2762 3
a2764 3
        call get_string ( sub_rosa(gson), booleanString, strip=.true. )
        if ( verboser ) call outputNamedValue( 'formula', trim(booleanString) )
        skip = myBooleanValue ( booleanString )
d2772 2
a2773 2
      if ( verboser .and. len_trim(booleanString) > 0 ) then
        call output( trim(booleanString) // ' = ', advance='no' )
d2798 1
a2798 1
        call writeIntsToChars( nvalues, booleanString )
d2800 1
a2800 1
          & 'countsn', booleanString, &
d2806 1
a2806 1
          call get_string( sub_rosa(subtree(j, value_field)), booleanString, strip=.true. )
d2812 1
a2812 1
            & keyString, booleanString, &
d2873 1
a2873 1
    ! Calculate the boolean value according to
d3214 1
a3214 1
       "$Id: DumpCommand_m.f90,v 2.139 2018/07/27 23:18:48 pwagner Exp $"
d3224 3
d3349 1
a3349 1
! Fixed call to BOOLEANVALUE--must use trim
d3472 1
a3472 1
! Print notice of changed runtime booleans only when "bool" switch is set
d3517 1
a3517 1
! Dump commands take boolean fields /stop, /stopWithError, /crashBurn
@


2.139
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d1465 1
a1465 1
            if ( associated(lines) ) then
d3180 1
a3180 1
       "$Id: DumpCommand_m.f90,v 2.138 2018/05/17 17:05:53 pwagner Exp $"
d3190 3
@


2.138
log
@May Dump quantity values bitwise
@
text
@d22 1
d444 1
a444 1
    use MLSMessagemodule, only: MLSMessage, MLSMSG_Error
d562 1
a562 1
      call MLSMessage (MLSMSG_Error, moduleName, &
d565 1
a565 1
      call MLSMessage (MLSMSG_Error, moduleName, &
d601 1
a601 1
      call MLSMessage (MLSMSG_Error, moduleName, &
d764 1
a764 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
d844 1
a844 1
      call MLSMessage( MLSMSG_Warning, ModuleName, &
d908 1
a908 1
    use MLSMessageModule, only: MLSMSG_Error, MLSMessage
d1018 1
a1018 1
        call MLSMessage ( MLSMSG_Error, moduleName, &
d1115 1
a1115 1
        & call MLSMessage ( MLSMSG_Error, moduleName, &
d1220 1
a1220 2
      & L2cfnode, Normal_Exit_Status, RuntimeValues, &
      & MLSMessage
d1349 1
a1349 1
    &  call MLSMessage( MLSMSG_Error, moduleName, &
d1553 1
a1553 1
            call MLSMessage( MLSMSG_CRASH, moduleName, &
d1910 1
a1910 1
                call MLSMessage (MLSMSG_Error, moduleName, &
d2212 1
a2212 2
    use MLSL2Options, only: L2CFNode, Normal_Exit_Status, &
      & MLSMessage
d2307 1
a2307 1
        call MLSMessage( MLSMSG_Warning, moduleName, &
d2330 1
a2330 1
        call MLSMessage( MLSMSG_Warning, moduleName, &
d2336 1
a2336 1
        call MLSMessage( MLSMSG_Warning, moduleName, &
d2371 1
a2371 1
        call MLSMessage( MLSMSG_Crash, moduleName, &
d2410 1
a2410 1
        call MLSMessage( MLSMSG_Warning, moduleName, &
d2614 1
a2614 1
    use MLSMessagemodule, only: MLSMEssage, MLSMSG_Info
d3180 1
a3180 1
       "$Id: DumpCommand_m.f90,v 2.137 2018/04/19 23:44:09 pwagner Exp $"
d3190 3
@


2.137
log
@Skip may take /nextChunk flag
@
text
@d1170 1
d1216 1
a1216 1
    use MLSFinds, only: Findfirst
d1289 1
d1302 1
d1322 1
d1334 6
d1916 1
d1921 1
a1921 1
            elseif ( .not. any(indexes(optionsString, (/'0','1','2'/)) > 0 ) ) then
d1924 7
d3181 1
a3181 1
       "$Id: DumpCommand_m.f90,v 2.136 2018/03/22 18:17:00 pwagner Exp $"
d3191 3
@


2.136
log
@Added command IsFileAbsent; may occur in ReadApriori, MergeGrids, and Output sections
@
text
@d2658 2
a2659 2
    use Init_Tables_Module, only: F_Boolean, F_Formula, F_Values
    use MLSL2Options, only: RuntimeValues
d2662 1
a2662 1
    use Moretree, only: Get_Field_Id
d2691 1
d2714 2
d3163 1
a3163 1
       "$Id: DumpCommand_m.f90,v 2.135 2018/03/05 19:49:38 pwagner Exp $"
d3173 3
@


2.135
log
@Consistent with details arg to Dump_Signals now being an int
@
text
@d17 2
d51 2
a52 2
! The following functions do much the same thing: They add to the
! runtime Boolean datase a pair (key => named_Boolean, value => its_value)
d741 2
a742 1
  ! Returns TRUE if there are no useable data points in the swath
d749 2
d754 4
a757 2
    use Init_Tables_Module, only: F_Boolean, F_File, F_Swath, F_Type, &
      & L_L2dgg, L_L2gp
d761 1
a761 1
    use MLSFiles, only: HDFversion_5
d766 3
a768 1
      & MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End
d771 1
d784 1
d789 1
d801 1
d812 1
a812 1

d818 2
d826 1
d834 8
d847 4
a850 1
    if ( mls_swath_in_file( filename, swathname, HDFVERSION_5 ) ) then
a1639 2
          if ( index( 's', optionsString ) < 1 ) &
            & call output( trim(booleanString) // ' = ', advance='no' )
d1644 2
d2612 1
d2614 1
d2632 6
a2637 2
    if ( len_trim(label) > 0 ) call MLSMessage (MLSMSG_Info, moduleName, &
        & 'End selecting for ' // trim(label) // '::' // trim(SelectLabel) )
d3160 1
a3160 1
       "$Id: DumpCommand_m.f90,v 2.134 2017/09/26 16:24:34 pwagner Exp $"
d3170 3
@


2.134
log
@May use options field to set text as Headline or Banner
@
text
@d1478 1
a1478 1
              call dump ( signals, details=details>0 )
d3127 1
a3127 1
       "$Id: DumpCommand_m.f90,v 2.133 2017/07/27 16:55:02 pwagner Exp $"
d3137 3
@


2.133
log
@Reevaluate may take /truncate to keep integer part only
@
text
@d14 1
a14 1
! Process a "dump" command. Or say whether to "skip" remainder of section.
d53 1
a53 1
! booleanFromAnyGoodRadiances
d55 1
a55 1
! booleanFromAnyGoodValues
d57 1
a57 1
! booleanFromCatchWarning
d59 1
a59 1
! booleanFromComparingQuantities
d62 1
a62 1
! booleanFromEmptyGrid
d64 1
a64 1
! booleanFromEmptySwath
d66 1
a66 1
! booleanFromFormula
d77 1
a77 1
! Execute        Execute the dhell command specified in text
d103 1
a103 1
! Execute ( int root )
d112 2
a113 2
  interface EVALUATOR
    module procedure EVALUATOR_SCA, EVALUATOR_ARRAY
d1148 1
a1148 1
    use Dump_Options, only: RMSFormat
d1200 2
a1201 1
    use MLSStringLists, only: GetHashElement, OptionDetail, SwitchDetail
d1273 2
d1276 1
a1276 1
    character(len=80) :: OPTIONSSTRING  ! E.g., '-rbs' (see dump_0.f90)
d1287 1
d1355 4
a1358 2
    OPTIONSSTRING = '-'
    got= .false.
d1941 1
a1941 2
        ! optionsString = lowerCase(optionsString)
        ! call outputNamedValue( 'options', trim(optionsString) )
d1949 10
d2147 2
d3127 1
a3127 1
       "$Id: DumpCommand_m.f90,v 2.132 2017/07/10 23:09:51 pwagner Exp $"
d3137 3
@


2.132
log
@Print less if not verbose
@
text
@d29 1
a29 1
  public :: BooleanFromEmptygrid, booleanFromEmptySwath
d364 1
a364 1
    use MLSStringlists, only: NumStringElements, PutHashElement
d872 4
a875 2
    use Init_Tables_Module, only: F_A, F_B, F_Boolean, F_C, F_Evaluate, F_Expr, &
      & F_Formula, F_Inputboolean, F_Label, F_Literal, F_Manipulation, F_Values, &
d911 1
d934 4
a937 3
    evaluate= .false.
    literal= .false.
    tvalue= .false.
d996 4
d1103 1
d1133 1
a1133 1
  end function BOOLEANFROMFORMULA
d2385 1
a2385 1
    use MLSStringlists, only: GetHashElement, PutHashElement
d2427 1
a2427 1
    use MLSStringlists, only: GetHashElement
d2499 1
a2499 1
    use MLSStringlists, only: GetHashElement
d2610 1
a2610 1
    use MLSStringlists, only: BooleanValue, GetHashElement, PutHashElement
d2767 1
a2767 1
    use MLSStringlists, only: BooleanValue, GetStringElement
d2940 1
a2940 1
    use MLSStringlists, only: GetHashElement
d3110 1
a3110 1
       "$Id: DumpCommand_m.f90,v 2.131 2017/02/22 18:01:56 pwagner Exp $"
d3120 3
@


2.131
log
@Declaring a runtime Boolean without an initial value no longer generates a Warning
@
text
@d1110 1
a1110 1
      call output( 'Using default value for bare Boolean declaration', &
d3101 1
a3101 1
       "$Id: DumpCommand_m.f90,v 2.130 2016/07/28 01:45:07 vsnyder Exp $"
d3111 3
@


2.130
log
@Refactor dump and diff
@
text
@d158 13
a170 13
    use allocate_deallocate, only: deallocate_test
    use constructQuantityTemplates, only: anyGoodSignalData
    use chunks_m, only: MLSChunk_t
    use init_tables_module, only: f_signal, f_boolean
    use MLSCommon, only: mlsfile_t
    use MLSL2Options, only: runtimeValues
    use MLSSignals_m, only: getSignalName, &
      & signals
    use MLSStringLists, only: numStringElements, putHashElement
    use MLSStrings, only: lowercase
    use parse_signal_m, only: parse_signal
    use string_table, only: get_string
    use tree, only: decoration, nsons, sub_rosa, subtree
d262 11
a272 11
    use init_tables_module, only: f_precision, f_quality, &
      & f_quantity, f_boolean, f_status
    use manipulateVectorQuantities, only: anyGoodDatainQty
    use MLSKinds, only: rv
    use MLSL2Options, only: runtimeValues
    use MLSStringLists, only: numStringElements, putHashElement
    use MLSStrings, only: lowercase
    use string_table, only: get_string
    use tree, only: decoration, nsons, sub_rosa, subtree
    use vectorsModule, only: vector_t, vectorValue_t, &
      & getVectorQtyByTemplateIndex
d361 2
a362 2
    use init_tables_module, only: f_boolean, f_message
    use MLSL2Options, only: runtimeValues
d364 4
a367 4
    use MLSStringlists, only: numStringElements, putHashElement
    use MLSStrings, only: lowercase
    use string_table, only: get_string
    use tree, only: decoration, nsons, sub_rosa, subtree
d437 4
a440 4
    use expr_m, only: expr
    use init_tables_module, only: f_a, f_b, f_c, f_boolean, f_formula
    use MLSKinds, only: r8, rv
    use MLSL2Options, only: runtimeValues
d442 9
a450 9
    use MLSStats1, only: mlsmax, mlsmin, mlsmean, mlsmedian
    use MLSStringLists, only: getStringElement, numStringElements, &
      & putHashElement, replaceSubstring
    use MLSStrings, only: lowercase
    use string_table, only: get_string
    use trace_m, only: trace_begin, trace_end
    use tree, only: decoration, nsons, sub_rosa, subtree
    use vectorsModule, only: vector_t, vectorvalue_t, m_fill, &
      & getVectorQtyByTemplateIndex
d676 8
a683 8
    use dump_0, only: dump
    use init_tables_module, only: f_boolean, f_grid
    use griddedData, only: griddedData_t, dump
    use MLSL2Options, only: runtimeValues
    use MLSStringLists, only: numStringElements, putHashElement
    use MLSStrings, only: lowercase
    use string_table, only: get_string
    use tree, only: decoration, nsons, sub_rosa, subtree
d747 9
a755 9
    use allocate_deallocate, only: allocate_test, deallocate_test
    use dump_0, only: dump
    use init_tables_module, only: f_boolean, f_file, f_swath, f_type, &
      & l_l2dgg, l_l2gp
    use L2GPData, only: L2GPData_t, rgp, L2GPNameLen, &
      & readL2GPData, destroyL2GPContents
    use MLSCommon, only: filenamelen
    use MLSFiles, only: hdfversion_5
    use MLSHdfeos, only: mls_swath_in_file
d757 1
a757 1
    use MLSL2Options, only: runtimeValues
d760 4
a763 4
    use MLSStringLists, only: numStringElements, putHashElement
    use MLSStrings, only: lowercase
    use string_table, only: get_string
    use tree, only: decoration, nsons, sub_rosa, subtree
d870 8
a877 8
    use dump_0, only: dump
    use expr_m, only: expr
    use init_tables_module, only: f_a, f_b, f_boolean, f_c, f_evaluate, f_expr, &
      & f_formula, f_inputboolean, f_label, f_literal, f_manipulation, f_values, &
      & field_first, field_last
    use manipulationutils, only: manipulate
    use MLSKinds, only: r8, rv
    use MLSL2Options, only: runtimeValues
d879 11
a889 11
    use MLSStringLists, only: evaluateFormula, getHashElement, &
      & insertHashElement, numStringElements, putHashElement
    use MLSStrings, only: lowercase, readNumsFromChars, writeIntsToChars
    use moretree, only: get_boolean
    use quantitytemplates, only: quantityTemplate_t, setupNewQuantityTemplate
    use string_table, only: get_string
    use tree, only: decoration, nsons, sub_rosa, subtree
    use vectorsModule, only: vector_t, vectorValue_t, &
      & cloneVectorQuantity, createVectorValue, &
      & destroyVectorQuantityValue, dump, &
      & getVectorQtyByTemplateIndex
d1006 1
a1006 1
    if ( count(got( (/f_values, f_formula, f_manipulation, f_label/) ) ) /= 1 ) &
d1110 2
d1133 5
a1137 5
    use AntennaPatterns_m, only: dump_antenna_patterns_database
    use Calendar, only: duration_formatted, time_t, tk
    use Call_stack_m, only: dump_stack
    use ChunkDivideConfig_m, only: chunkDivideConfig, dump
    use Declaration_table, only: dump_a_decl, decls, get_decl, variable
d1141 42
a1182 42
    use Expr_m, only: Expr
    use FilterShapes_m, only: dump_filter_shapes_database, &
      & Dump_dacs_filter_database
    use Forwardmodelconfig, only: dump, forwardmodelconfig_t
    use Griddeddata, only: diff, dump, griddeddata_t
    use HessianModule_1, only: hessian_t, diff, dump
    use HGridsDatabase, only: dump, HGrids_t
    use Igrf_int, only: dump_gh
    use Init_tables_module, only: f_allbooleans, f_allfiles, &
      & f_allforwardmodels, f_allgriddeddata, f_allhessians, f_allhgrids, &
      & f_alll2pcs, f_alllines, f_allmatrices, f_allpfa, &
      & f_allquantitytemplates, f_allradiometers, f_allsignals, f_allspectra, &
      & f_allvectors, f_allvectortemplates, f_allvgrids, f_antennapatterns, &
      & f_block, f_boolean, &
      & f_callstack, f_chunkdivide, f_chunknumber, f_clean, &
      & f_commandline, f_count, f_crashburn, &
      & f_details, f_dacsfiltershapes, f_dumpFile, &
      & f_file, f_filtershapes, f_forwardmodel, f_globalAttributes, f_grid, &
      & f_hessian, f_hgrid, f_igrf, &
      & f_l2pc, f_lines, f_mark, f_mask, f_matrix, f_memory, &
      & f_mietables, f_options, f_pfadata, f_pfafiles, f_pfanum, f_pfastru, &
      & f_phasename, f_pointinggrids, F_Polygon, f_quantity, f_rank, f_reset, &
      & f_signals,  f_spectroscopy, f_stack, f_start, f_stop, f_stride, &
      & f_stopwitherror, f_surface, &
      & f_template, f_text, f_tgrid, f_time, f_truncate, &
      & F_TotalMatrixSizes, F_TotalVectorSizes, f_variable, &
      & f_vector, f_vectormask, f_vgrid, f_ZOT, &
      & s_diff, s_dump, s_quantity, s_vectortemplate, &
      & field_first, field_last
    use io_stuff, only: truncate_textFile
    use L2Parinfo, only: parallel, closeparallel
    use L2PC_M, only: l2pcdatabase, dumpl2pc => dump
    use lexer_core, only: get_where, where_t
    use machine, only: nevercrash
    use matrixModule_1, only: matrix_t, matrix_database_t, &
      & diff, dump, getFromMatrixDatabase, MatricesMemoryInUse
    use MLSCommon, only: mlsfile_t
    use MLSFiles, only: dumpMLSFile => dump, getMLSFilebyname
    use MLSFinds, only: findfirst
    use MLSKinds, only: r8, rv
    use MLSL2Options, only: command_line, currentChunkNumber, currentPhaseName, &
      & l2cfnode, normal_exit_status, runtimeValues, &
d1184 2
a1185 2
    use MLSL2Timings, only: dump_section_timings
    use MLSMessagemodule, only: MLSMSG_Crash, MLSMSG_Error, MLSmessageCalls, &
d1187 25
a1211 25
    use MLSSignals_m, only: radiometers, signals, &
      & dump, dump_all, getradiometerindex
    use MLSStrings, only: indexes, lowerCase, &
      & readIntsFromChars, stretch, writeIntsToChars
    use MLSStringLists, only: getHashElement, optionDetail, switchDetail
    use moretree, only: get_boolean, get_field_id, get_spec_id
    use PCFHdr, only: dumpGlobalAttributes
    use pfadatabase_m, only: dump, dump_pfadatabase, dump_pfafiledatabase, &
      & dump_pfastructure, pfadata
    use pointingGrid_m, only: dump_pointing_grid_database
    use Polygon_m, only: Dump_Polygon_Database
    use quantityTemplates, only: dump, quantityTemplate_t
    use read_mie_m, only: dump_mie
    use spectroscopyCatalog_m, only: catalog, dump, dump_lines_database, lines
    use string_table, only: display_string, get_string
    use time_m, only: finish
    use toggles, only: gen, switches, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: decoration, node_id, nsons, sub_rosa, subtree, where
    use tree_types, only: n_spec_args
    use vectorsModule, only: vector_t, vectorTemplate_t, vectorValue_t, &
      & diff, dump, destroyVectorQuantityValue, dumpQuantityMask, dumpVectorMask, &
      & gatherVectorQuantity, getVectorQuantity, getVectorQtyByTemplateIndex, &
      & getVectorQuantityIndexByName, VectorsMemoryInUse
    use vGridsDatabase, only: dump, vGrids
d2130 8
a2137 8
    use Dump_1, only: DumpTextfile
    use Expr_m, only: Expr
    use Init_Tables_Module, only:  f_crashburn, &
      & f_delay, f_details, f_filename, f_lines, f_options, &
      & f_stop, f_stopwitherror, f_command, f_time, &
      & f_wait, &
      & field_first, field_last
    use IO_Stuff, only: Write_Textfile
d2139 1
a2139 1
    use Lexer_Core, only: get_where, where_t
d2149 1
a2149 1
    use Time_m, only: Finish
d2151 1
a2151 1
    use Trace_m, only: Trace_Begin, Trace_End
d2364 2
a2365 2
    use MLSL2Options, only: runtimeValues
    use MLSStringlists, only: putHashElement
d2375 3
a2377 3
    use MLSL2Options, only: runtimeValues
    use MLSStringlists, only: getHashElement, putHashElement
    use MLSStrings, only: readintsfromchars, writeintstochars
d2416 9
a2424 9
    use init_tables_module, only: f_boolean, f_label, f_options
    use MLSL2Options, only: runtimeValues
    use MLSStringlists, only: getHashElement
    use MLSStrings, only: lowercase, streq
    use moretree, only: get_field_id
    use string_table, only: get_string
    use toggles, only: gen, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: nsons, sub_rosa, subtree
d2488 9
a2496 9
    use init_tables_module, only: f_boolean, f_label
    use MLSL2Options, only: runtimeValues
    use MLSStringlists, only: getHashElement
    use MLSStrings, only: lowercase
    use moretree, only: get_field_id
    use string_table, only: get_string
    use toggles, only: gen, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: nsons, sub_rosa, subtree
d2543 8
a2550 8
    use init_tables_module, only: f_label
    use MLSMessagemodule, only: MLSMEssage, MLSMSG_info
    use MLSStrings, only: lowercase
    use moretree, only: get_field_id
    use string_table, only: get_string
    use toggles, only: gen, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: nsons, sub_rosa, subtree
d2599 9
a2607 9
    use init_tables_module, only: f_boolean, f_formula, f_values
    use MLSL2Options, only: runtimevalues
    use MLSStringlists, only: booleanvalue, getHashElement, putHashElement
    use MLSStrings, only: lowercase, readintsFromChars, writeIntsToChars
    use moretree, only: get_field_id
    use string_table, only: get_string
    use toggles, only: gen, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: nsons, sub_rosa, subtree
d2712 1
a2712 1
    use moretree, only: startErrorMessage
d2757 3
a2759 3
    use MLSL2Options, only: runtimevalues
    use MLSStringlists, only: booleanValue, getStringElement
    use MLSStrings, only: lowercase, readNumsFromChars
d2862 1
a2862 1
    use MLSL2Options, only: dumpMacros
d2870 2
a2871 2
    use MLSL2Options, only: runtimeValues
    use MLSStringlists, only: list2Array, evaluateFormula, numStringElements
d2894 1
a2894 1
    use MLSStringLists, only: array2List, list2Array, numStringElements
d2928 5
a2932 5
    use MLSL2Options, only: checkpaths, need_l1bfiles, &
      & runtimevalues, skipretrieval
    use MLSL2Options, only: currentChunkNumber, currentPhaseName
    use MLSStringlists, only: getHashElement
    use MLSStrings, only: lowercase, writeIntsToChars
d3006 1
a3006 1
    use MLSStrings, only: asciify
d3032 2
a3033 2
    use MLSFiles, only: getPCFromRef
    use MLSL2Options, only: toolkit
d3062 1
a3062 1
    use Memory_m, only: memory_used
d3081 1
a3081 1
    use time_m, only: time_now
d3101 1
a3101 1
       "$Id: DumpCommand_m.f90,v 2.129 2016/05/18 01:37:30 vsnyder Exp $"
d3111 3
@


2.129
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@d18 4
a21 3
  use highOutput, only: banner, beVerbose, headLine, &
    & numToChars, outputNamedValue
  use output_m, only: Beep, blanks, newLine, output, revertOutput, switchOutput
d25 9
a33 9
  public :: booleanFromAnyGoodRadiances
  public :: booleanFromAnyGoodValues
  public :: booleanFromCatchWarning
  public :: booleanFromComparingQtys
  public :: booleanFromEmptygrid, booleanFromEmptySwath
  public :: booleanFromFormula
  public :: dumpCommand, ExecuteCommand
  public :: initializeRepeat, nextRepeat
  public :: MLSCase, MLSEndSelect, MLSSelect, skip
d1136 4
a1139 2
    use Dump_0, only: diff, dump, rmsformat
    use Expr_m, only: expr
d2126 1
a2126 1
  ! ------------------------------------------------  ExecuteCCommand  -----
d2128 3
a2130 3
    use Dump_0, only: dumpTextfile
    use expr_m, only: expr
    use init_tables_module, only:  f_crashburn, &
d2135 5
a2139 5
    use io_stuff, only: write_textfile
    use l2parinfo, only: parallel, closeparallel
    use lexer_core, only: get_where, where_t
    use machine, only: create_script, Execute, nevercrash, Usleep
    use MLSL2Options, only: l2cfnode, normal_exit_status, &
d2141 1
a2141 1
    use MLSL2Timings, only: dump_section_timings
d2144 7
a2150 7
    use MLSStringLists, only: switchDetail
    use moretree, only: get_boolean, get_field_id
    use string_table, only: get_string
    use time_m, only: finish
    use toggles, only: gen, switches, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: nsons, sub_rosa, subtree, where
d3099 1
a3099 1
       "$Id: DumpCommand_m.f90,v 2.128 2016/04/07 23:40:28 pwagner Exp $"
d3109 4
@


2.128
log
@Should exit, not crash, if stopped by /stop flag to Execute
@
text
@d99 1
a99 1
!    type (HGrid_T) HGrids(:), &
d1125 1
a1125 1
    & vectorTemplates, vectors, forwardModelConfigs, hgrids, griddedDatabase, &
d1130 15
a1144 15
    use antennaPatterns_m, only: dump_antenna_patterns_database
    use calendar, only: duration_formatted, time_t, tk
    use call_stack_m, only: dump_stack
    use chunkDivideConfig_m, only: chunkDivideConfig, dump
    use declaration_table, only: dump_a_decl, decls, get_decl, variable
    use dump_0, only: diff, dump, rmsformat
    use expr_m, only: expr
    use filterShapes_m, only: dump_filter_shapes_database, &
      & dump_dacs_filter_database
    use forwardmodelconfig, only: dump, forwardmodelconfig_t
    use griddeddata, only: diff, dump, griddeddata_t
    use hessianModule_1, only: hessian_t, diff, dump
    use hGridsDatabase, only: dump, hgrid_t
    use igrf_int, only: dump_gh
    use init_tables_module, only: f_allbooleans, f_allfiles, &
d1214 1
a1214 1
    type (HGrid_T), dimension(:), pointer, optional              :: HGrids
d1401 1
a1401 1
              call dump ( hGrids )
d1759 2
a1760 1
              & hGrids(decoration(decoration(subtree(i,son)))), details, ZOT )
d3096 1
a3096 1
       "$Id: DumpCommand_m.f90,v 2.127 2016/04/01 00:27:41 pwagner Exp $"
d3106 3
@


2.127
log
@May now Execute a single command or a script of lines from l2cf
@
text
@d159 1
a159 1
    use chunks_m, only: mlschunk_t
d442 2
a443 2
    use MLSStringLists, only: getStringElement, numStringElements, puthashelement, &
      & replacesubstring
d750 2
a751 2
    use l2gpdata, only: l2gpdata_t, rgp, l2gpnamelen, &
      & readl2gpdata, destroyl2gpcontents
d757 2
a758 2
    use MLSPcf2, only: mlspcf_l2gp_end, &
      & MLSPcf_l2gp_start, mlspcf_l2dgg_start, mlspcf_l2dgg_end
d813 1
a813 1
        & mlspcf_l2dgg_start, mlspcf_l2dgg_end )
d816 1
a816 1
        & mlspcf_l2gp_start, mlspcf_l2gp_end )
d2260 1
a2260 1
        call MLSMessage( MLSMSG_Crash, moduleName, &
d3095 1
a3095 1
       "$Id: DumpCommand_m.f90,v 2.126 2016/02/26 02:08:18 vsnyder Exp $"
d3105 3
@


2.126
log
@Add ZOT switch
@
text
@d30 1
d32 1
a32 1
  public :: MLSCase, dumpCommand, MLSEndSelect, MLSSelect, skip
d76 1
d102 1
d1166 2
a1167 2
    use l2parinfo, only: parallel, closeparallel
    use l2pc_m, only: l2pcdatabase, dumpl2pc => dump
d1170 3
a1172 3
    use matrixmodule_1, only: matrix_t, matrix_database_t, &
      & diff, dump, getfrommatrixdatabase, MatricesMemoryInUse
    use mlscommon, only: mlsfile_t
d1174 1
a1181 1
    use MLSFinds, only: findfirst
d2122 235
d3095 1
a3095 1
       "$Id: DumpCommand_m.f90,v 2.125 2016/01/29 01:10:07 vsnyder Exp $"
d3105 3
@


2.125
log
@Add polygon to Dump
@
text
@d1159 1
a1159 1
      & f_vector, f_vectormask, f_vgrid, &
d1281 1
d1343 1
d1364 1
a1364 1
        & f_totalVectorSizes )
d1571 2
d1755 2
a1756 2
            call dump ( & ! has no details switch
              & hGrids(decoration(decoration(subtree(i,son)))) )
d2857 1
a2857 1
       "$Id: DumpCommand_m.f90,v 2.124 2015/10/06 00:23:48 pwagner Exp $"
d2867 3
@


2.124
log
@When Dumping runtime Boolean, options='s' skips printing key
@
text
@d245 1
a245 1
    endif
d339 1
a339 1
    endif
d406 1
a406 1
    endif
d420 1
a420 1
    endif
d600 1
a600 1
    endif
d723 1
a723 1
    endif
d837 1
a837 1
      endif
d841 1
a841 1
    endif
d845 1
a845 1
    endif
d856 1
a856 1
  ! ------------------------------------- BooleanFromFormula --
d1010 1
a1010 1
    endif
d1026 1
a1026 1
    endif
d1030 1
a1030 1
    endif
d1057 1
a1057 1
      endif
d1066 1
a1066 1
        endif
d1082 1
a1082 1
      endif
d1087 1
a1087 1
      endif
d1101 1
a1101 1
      endif
d1109 1
a1109 1
      endif
d1113 1
a1113 1
    endif
d1154 1
a1154 1
      & f_phasename, f_pointinggrids, f_quantity, f_rank, f_reset, &
d1189 1
d1300 1
a1300 1
    endif
d1361 1
a1361 1
        & f_stop, f_stopWithError, f_time, f_totalMatrixSizes, &
d1444 1
a1444 1
              endif
d1514 2
d1521 1
a1521 1
            endif
d1538 1
a1538 1
            endif
d1543 1
a1543 1
            endif
d1616 2
a1617 2
              endif
            endif
d1619 1
a1619 1
        endif
d1695 1
a1695 1
            endif
d1709 1
a1709 1
            endif
d1732 1
a1732 1
            endif
d1740 1
a1740 1
            endif
d1806 2
a1807 2
              endif
            endif
d1830 1
a1830 1
              endif
d1862 1
a1862 1
              endif
d2197 1
a2197 1
    endif
d2227 1
a2227 1
    endif
d2231 1
a2231 1
    endif
d2286 1
a2286 1
    endif
d2399 1
a2399 1
        endif
d2414 1
a2414 1
      endif
d2455 1
a2455 1
      endif
d2554 1
a2554 1
      endif
d2560 1
a2560 1
      endif
d2567 1
a2567 1
      endif
d2582 1
a2582 1
      endif
d2590 1
a2590 1
      endif
d2596 1
a2596 1
    endif
d2607 1
a2607 1
    endif
d2767 1
a2767 1
      endif
d2773 1
a2773 1
      endif
d2778 1
a2778 1
    endif
d2827 1
a2827 1
    endif
d2846 1
a2846 1
    endif
d2853 1
a2853 1
       "$Id: DumpCommand_m.f90,v 2.123 2015/09/24 22:10:17 pwagner Exp $"
d2863 3
@


2.123
log
@Dump command may optionally direct text to stderr
@
text
@d1582 3
a1584 1
          call output( trim(booleanString) // ' = ', advance='no' )
d1588 2
a1589 1
          call output( label, advance='yes' )
d1974 1
a1974 1
        !     e            print ot stderr
d2850 1
a2850 1
       "$Id: DumpCommand_m.f90,v 2.122 2015/07/14 23:32:47 pwagner Exp $"
d2860 3
@


2.122
log
@may divert Dump commands to named dumpFile; /truncate field
@
text
@d20 1
a20 1
  use output_m, only: blanks, newLine, output, revertOutput, switchOutput
d127 1
d1334 1
d1909 1
d1971 1
d2768 2
d2847 1
a2847 1
       "$Id: DumpCommand_m.f90,v 2.121 2015/04/09 21:00:32 pwagner Exp $"
d2857 3
@


2.121
log
@rank may be specified for Dump command; restored printing Dumped text field
@
text
@d20 1
a20 1
  use output_m, only: blanks, newLine, output
d1148 1
a1148 1
      & f_details, f_dacsfiltershapes, &
d1155 2
a1156 1
      & f_stopwitherror, f_surface, f_template, f_text, f_tgrid, f_time, &
d1161 1
d1268 1
d1321 1
d1566 6
d1851 4
a1854 2
              call outputnamedValue ( 'rank field', rank )
              call outputnamedValue ( 'shape(value3)', shape(qty1%value3) )
d2099 1
d2841 1
a2841 1
       "$Id: DumpCommand_m.f90,v 2.120 2015/02/27 23:13:52 pwagner Exp $"
d2851 3
@


2.120
log
@May Dump global attributes
@
text
@d1153 1
a1153 1
      & f_phasename, f_pointinggrids, f_quantity, f_reset, &
d1259 1
d1319 1
d1610 3
d1841 16
a1856 2
              call dump ( qty1%values, 'quantity values', &
                & options=optionsString )
d2045 1
d2828 1
a2828 1
       "$Id: DumpCommand_m.f90,v 2.119 2015/02/13 00:21:17 pwagner Exp $"
d2838 3
@


2.119
log
@Nay dump Booleans more nicely as a Table
@
text
@d1149 3
a1151 2
      & f_file, f_filtershapes, f_forwardmodel, f_grid, f_hessian, &
      & f_hgrid, f_igrf, f_l2pc, f_lines, f_mark, f_mask, f_matrix, f_memory, &
d1182 1
d1350 1
a1350 1
        & f_DACSfilterShapes, f_filterShapes, f_igrf, f_memory, &
d1488 2
d2808 1
a2808 1
       "$Id: DumpCommand_m.f90,v 2.118 2014/09/05 00:48:13 vsnyder Exp $"
d2818 3
@


2.118
log
@Get field value correctly.  Remove USE for unreferenced names.  Add dumps
for MatricesMemoryInUse, TotalMatrixSizes, TotalVectorSizes,
VectorsMemoryInUse.  Some cannonball polishing.  New interface to
Memory_Used.  Move some USE statements from module scope to procedure
scope.  Add outputLaterInt.
@
text
@d24 8
a31 8
  public :: BOOLEANFROMANYGOODRADIANCES
  public :: BOOLEANFROMANYGOODVALUES
  public :: BOOLEANFROMCATCHWARNING
  public :: BOOLEANFROMCOMPARINGQTYS
  public :: BOOLEANFROMEMPTYGRID, BOOLEANFROMEMPTYSWATH
  public :: BOOLEANFROMFORMULA
  public :: INITIALIZEREPEAT, NEXTREPEAT
  public :: MLSCASE, DUMPCOMMAND, MLSENDSELECT, MLSSELECT, SKIP
d151 15
a165 15
  function BOOLEANFROMANYGOODRADIANCES ( ROOT, CHUNK, FILEDATABASE ) &
    & result( HASHSIZE )
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST
    use CONSTRUCTQUANTITYTEMPLATES, only: ANYGOODSIGNALDATA
    use CHUNKS_M, only: MLSCHUNK_T
    use INIT_TABLES_MODULE, only: F_SIGNAL, F_BOOLEAN
    use MLSCOMMON, only: MLSFILE_T
    use MLSL2OPTIONS, only: DUMPMACROS, RUNTIMEVALUES
    use MLSSIGNALS_M, only: GETSIGNALNAME, &
      & SIGNALS
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE
    use PARSE_SIGNAL_M, only: PARSE_SIGNAL
    use STRING_TABLE, only: GET_STRING
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
d252 1
a252 1
      & call dumpMacros
d256 12
a267 12
  function BOOLEANFROMANYGOODVALUES ( ROOT, VECTORS ) result( THESIZE )
    use INIT_TABLES_MODULE, only: F_PRECISION, F_QUALITY, &
      & F_QUANTITY, F_BOOLEAN, F_STATUS
    use MANIPULATEVECTORQUANTITIES, only: ANYGOODDATAINQTY
    use MLSKINDS, only: RV
    use MLSL2OPTIONS, only: DUMPMACROS, RUNTIMEVALUES
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE
    use STRING_TABLE, only: GET_STRING
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
    use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T, &
      & GETVECTORQTYBYTEMPLATEINDEX
d346 1
a346 1
      & call dumpMacros
d350 1
a350 1
  function BOOLEANFROMCATCHWARNING ( ROOT ) result( SIZE )
d356 7
a362 7
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_MESSAGE
    use MLSL2OPTIONS, only: DUMPMACROS, RUNTIMEVALUES
    use MLSMESSAGEMODULE, only: MLSMESSAGEINQUIRE
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE
    use STRING_TABLE, only: GET_STRING
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
d427 1
a427 1
      & call dumpMacros
d431 15
a445 15
  function BOOLEANFROMCOMPARINGQTYS ( ROOT, VECTORS ) result( THESIZE )
    use EXPR_M, only: EXPR
    use INIT_TABLES_MODULE, only: F_A, F_B, F_C, F_BOOLEAN, F_FORMULA
    use MLSKINDS, only: R8, RV
    use MLSL2OPTIONS, only: DUMPMACROS, RUNTIMEVALUES
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSSTATS1, only: MLSMAX, MLSMIN, MLSMEAN, MLSMEDIAN
    use MLSSTRINGLISTS, only: GETSTRINGELEMENT, NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & REPLACESUBSTRING
    use MLSSTRINGS, only: LOWERCASE
    use STRING_TABLE, only: GET_STRING
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
    use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T, M_FILL, &
      & GETVECTORQTYBYTEMPLATEINDEX
d607 1
a607 1
      & call dumpMacros
d612 1
a612 1
    elemental logical function ISRELATION( relation, a, b )
d635 1
a635 1
      use MLSCOMMON, only: DEFAULTUNDEFINEDVALUE
d670 9
a678 9
  function BOOLEANFROMEMPTYGRID ( ROOT, GRIDS ) result( THESIZE )
    use DUMP_0, only: DUMP
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_GRID
    use GRIDDEDDATA, only: GRIDDEDDATA_T, DUMP
    use MLSL2OPTIONS, only: DUMPMACROS, RUNTIMEVALUES
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE
    use STRING_TABLE, only: GET_STRING
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
d730 1
a730 1
      & call dumpMacros
d741 18
a758 18
  function BOOLEANFROMEMPTYSWATH ( ROOT ) result( THESIZE )
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use DUMP_0, only: DUMP
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_FILE, F_SWATH, F_TYPE, &
      & L_L2DGG, L_L2GP
    use L2GPDATA, only: L2GPDATA_T, RGP, L2GPNAMELEN, &
      & READL2GPDATA, DESTROYL2GPCONTENTS
    use MLSCOMMON, only: FILENAMELEN
    use MLSFILES, only: HDFVERSION_5
    use MLSHDFEOS, only: MLS_SWATH_IN_FILE
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_WARNING
    use MLSL2OPTIONS, only: DUMPMACROS, RUNTIMEVALUES
    use MLSPCF2, only: MLSPCF_L2GP_END, &
      & MLSPCF_L2GP_START, MLSPCF_L2DGG_START, MLSPCF_L2DGG_END
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE
    use STRING_TABLE, only: GET_STRING
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
d852 1
a852 1
      & call dumpMacros
d856 1
a856 1
  function BOOLEANFROMFORMULA ( NAME, ROOT, VECTORS ) result( SIZE )
d865 20
a884 20
    use DUMP_0, only: DUMP
    use EXPR_M, only: EXPR
    use INIT_TABLES_MODULE, only: F_A, F_B, F_BOOLEAN, F_C, F_EVALUATE, F_EXPR, &
      & F_FORMULA, F_INPUTBOOLEAN, F_LABEL, F_LITERAL, F_MANIPULATION, F_VALUES, &
      & FIELD_FIRST, FIELD_LAST
    use MANIPULATIONUTILS, only: MANIPULATE
    use MLSKINDS, only: R8, RV
    use MLSL2OPTIONS, only: DUMPMACROS, RUNTIMEVALUES
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMESSAGE
    use MLSSTRINGLISTS, only: EVALUATEFORMULA, GETHASHELEMENT, &
      & INSERTHASHELEMENT, NUMSTRINGELEMENTS, PUTHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE, READNUMSFROMCHARS, WRITEINTSTOCHARS
    use MORETREE, only: GET_BOOLEAN
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, SETUPNEWQUANTITYTEMPLATE
    use STRING_TABLE, only: GET_STRING
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
    use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T, &
      & CLONEVECTORQUANTITY, CREATEVECTORVALUE, &
      & DESTROYVECTORQUANTITYVALUE, DUMP, &
      & GETVECTORQTYBYTEMPLATEINDEX
d1116 1
a1116 1
      & call dumpMacros
d1120 3
a1122 3
  subroutine DUMPCOMMAND ( ROOT, QUANTITYTEMPLATESDB, &
    & VECTORTEMPLATES, VECTORS, FORWARDMODELCONFIGS, HGRIDS, GRIDDEDDATABASE, &
    & FILEDATABASE, MATRIXDATABASE, HESSIANDATABASE )
d1126 1
a1126 1
    use antennapatterns_m, only: dump_antenna_patterns_database
d1129 1
a1129 1
    use chunkdivideconfig_m, only: chunkdivideconfig, dump
d1133 1
a1133 1
    use filtershapes_m, only: dump_filter_shapes_database, &
d1137 2
a1138 2
    use hessianmodule_1, only: hessian_t, diff, dump
    use hgridsdatabase, only: dump, hgrid_t
d1168 3
a1170 3
    use MLSL2Options, only: command_line, currentchunknumber, currentphasename, &
      & l2cfnode, normal_exit_status, runtimevalues, &
      & dumpmacros, MLSmessage
d1172 4
a1175 4
    use MLSmessagemodule, only: MLSmsg_crash, MLSmsg_error, MLSmessagecalls, &
      & MLSmessageexit
    use MLSfinds, only: findfirst
    use MLSsignals_m, only: radiometers, signals, &
d1183 2
a1184 2
    use pointinggrid_m, only: dump_pointing_grid_database
    use quantitytemplates, only: dump, quantitytemplate_t
d1193 5
a1197 5
    use vectorsModule, only: vector_t, vectortemplate_t, vectorvalue_t, &
      & diff, dump, destroyvectorquantityvalue, dumpquantitymask, dumpvectormask, &
      & gathervectorquantity, getvectorquantity, getvectorqtybytemplateindex, &
      & getvectorquantityindexbyname, VectorsMemoryInUse
    use vgridsdatabase, only: dump, vgrids
d1355 1
a1355 1
            call dumpMacros
d2069 2
a2070 2
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: PUTHASHELEMENT
d2080 3
a2082 3
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: GETHASHELEMENT, PUTHASHELEMENT
    use MLSSTRINGS, only: READINTSFROMCHARS, WRITEINTSTOCHARS
d2121 9
a2129 9
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_LABEL, F_OPTIONS
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: GETHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE, STREQ
    use MORETREE, only: GET_FIELD_ID
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: NSONS, SUB_ROSA, SUBTREE
d2193 9
a2201 9
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_LABEL
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: GETHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE
    use MORETREE, only: GET_FIELD_ID
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: NSONS, SUB_ROSA, SUBTREE
d2248 9
a2256 9
    use INIT_TABLES_MODULE, only: F_LABEL
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_Info
    use MLSSTRINGS, only: LOWERCASE
    use MORETREE, only: GET_FIELD_ID
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: NSONS, SUB_ROSA, SUBTREE
    ! Args
d2303 11
a2313 11
  logical function SKIP ( ROOT, NAME )
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_FORMULA, F_VALUES
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: BOOLEANVALUE, GETHASHELEMENT, PUTHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE, READINTSFROMCHARS, WRITEINTSTOCHARS
    use MORETREE, only: GET_FIELD_ID
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: NSONS, SUB_ROSA, SUBTREE
    ! Args
d2348 1
a2348 1
        if ( verbose ) then
d2417 1
a2417 1
    use MORETREE, only: STARTERRORMESSAGE
d2462 3
a2464 3
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: BOOLEANVALUE, GETSTRINGELEMENT
    use MLSSTRINGS, only: LOWERCASE, READNUMSFROMCHARS
d2564 8
d2575 2
a2576 2
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: LIST2ARRAY, EVALUATEFORMULA, NUMSTRINGELEMENTS
d2599 1
a2599 1
    use MLSSTRINGLISTS, only: ARRAY2LIST, LIST2ARRAY, NUMSTRINGELEMENTS
d2633 5
a2637 5
    use MLSL2OPTIONS, only: CHECKPATHS, NEED_L1BFILES, &
      & RUNTIMEVALUES, SKIPRETRIEVAL
    use MLSL2Options, only: CURRENTCHUNKNUMBER, CURRENTPHASENAME
    use MLSSTRINGLISTS, only: GETHASHELEMENT
    use MLSSTRINGS, only: LOWERCASE, WRITEINTSTOCHARS
d2733 4
a2736 4
  subroutine RETURNFULLFILENAME ( SHORTNAME, FULLNAME, &
    & PCF_START, PCF_END )
    use MLSFILES, only: GETPCFROMREF
    use MLSL2OPTIONS, only: TOOLKIT
d2804 1
a2804 1
       "$Id: DumpCommand_m.f90,v 2.116 2014/06/11 20:06:33 pwagner Exp $"
d2814 7
@


2.117
log
@May command Dump of /memory or /time; optionally to /reset
@
text
@a19 2
  use MLSCommon, only: MLSFile_t, defaultUndefinedValue, fileNameLen, processID
  use MLSStrings, only: asciify
a20 1
  use time_m, only: finish, time_now
d36 1
a36 1
  private :: not_used_here 
d50 2
a51 2
!    function                 condition   
! booleanFromAnyGoodRadiances  
d53 1
a53 1
! booleanFromAnyGoodValues  
d55 1
a55 1
! booleanFromCatchWarning 
d57 1
a57 1
! booleanFromComparingQuantities 
d75 1
a75 1
! InitializeRepeat 
d77 1
a77 1
! NextRepeat     Add 1 to Repeat counter "count", 
d97 3
a99 3
!    type (HGrid_T) HGrids(:), & 
!    type (GriddedData_T) GriddedDataBase(:), type (MLSFile_T) FileDataBase(:), & 
!    type (Matrix_Database_T) MatrixDataBase(:), type (Hessian_T) HessianDataBase(:) ) 
d111 1
a111 1
  
d113 1
a113 1
    module procedure outputLater_chars, outputLater_real
d125 4
a130 3
  character(len=255) :: Text
  real, save :: TotalMemory1 = 0.     ! For memory usage
  real, save :: TotalMemory2 = 0.     ! For memory usage
d157 1
d175 1
d196 5
d221 1
a221 1
          call GetSignalName ( signalIndex, subSignalString, &                   
d275 1
d298 5
d354 1
a354 1
    ! syntax: 
d369 1
d385 5
d453 1
a453 1
    ! E.g., to compare a=a.qty and b=b.qty, returning true if 
d459 1
a459 1
    
d470 1
d494 5
d630 1
a630 1
    
d635 1
d686 1
d701 5
d711 1
a711 1
      case ( f_grid ) 
d748 1
d765 1
d775 1
d787 6
d858 1
a858 1
    ! syntax: 
d862 2
a863 2
    ! syntax: 
    ! Reevaluate, formula="formula", Boolean="name", 
d1155 2
a1156 1
      & f_variable, f_vector, f_vectormask, f_vgrid, &
d1164 2
a1165 1
      & diff, dump, getfrommatrixdatabase
d1188 1
d1196 1
a1196 1
      & getvectorquantityindexbyname
d1206 1
a1206 1
    type (GriddedData_T), dimension(:), pointer, optional        :: griddedDataBase
d1208 1
a1208 1
    type (Matrix_Database_T), dimension(:), pointer, optional    :: MatrixDataBase
d1229 4
a1232 3
    logical :: HaveQuantityTemplatesDB, HaveVectorTemplates, HaveVectors, &
             & HaveForwardModelConfigs, HaveGriddedData, HaveHGrids, &
             & HaveMatrices, HaveHessians
d1260 1
a1260 1
    character :: TempText*20
a1283 8
    haveQuantityTemplatesDB = present(quantityTemplatesDB)
    if ( haveQuantityTemplatesDB ) &
      & haveQuantityTemplatesDB = associated(quantityTemplatesDB)
    haveVectorTemplates = present(vectorTemplates)
    if ( haveVectorTemplates ) &
      & haveVectorTemplates = associated(vectorTemplates)
    haveVectors = present(vectors)
    if ( haveVectors ) haveVectors = size(Vectors) > 0
a1286 2
    haveHGrids = present(hGrids)
    if ( haveHGrids ) haveHGrids = associated(hGrids)
a1288 3
    haveMatrices = present(MatrixDatabase)
    if ( haveMatrices ) haveMatrices = associated(MatrixDatabase)
    if ( haveMatrices ) haveMatrices = size(MatrixDatabase) > 0
d1293 14
a1306 1
    
d1350 2
a1351 1
        & f_time, f_stop, f_stopWithError )
d1400 1
a1400 1
              call dump ( MatrixDataBase, details )
d1488 3
a1532 3
          case ( f_memory )
            call SayMemory
            if ( reset ) TotalMemory1 = TotalMemory2
d1536 18
a1598 2
      case ( f_reset )
        reset = get_boolean(son)
d1604 2
d1806 1
a1806 1
                & stride(1:hSlabRank), block(1:hSlabRank) ) 
d1939 1
a1939 1
        endif
a2021 1
          call outputNow ! the text
d2067 1
a2067 1
  
d2140 1
a2140 1
    logical :: verbose !, verboser
d2145 1
a2145 1
    ! verboser = BeVerbose ( 'bool', 0 )
d2189 1
a2189 1
  
d2216 1
a2216 1
    ! verboser = BeVerbose ( 'bool', 0 )
d2244 1
a2244 1
  
d2286 1
a2286 1
  
d2290 1
a2290 1
  ! If Boolean field absent, returns TRUE 
d2381 1
a2381 1
        call outputnamedValue( 'nvalues', nvalues) 
d2415 1
d2460 1
d2564 1
d2588 1
d2607 2
a2608 1
  ! This family of functions evaluates a character-valued arg, 
d2623 1
d2660 2
a2661 1
  
d2672 53
a2724 1
  ! ---------------------------------------------  returnFullFileName  -----
d2755 1
d2759 1
a2759 1
    call memory_used ( processID, total=TotalMemory2 )
d2774 1
d2776 1
a2792 40
  subroutine outputLater_chars ( chars, advance )
    character(len=*), intent(in) :: chars
    character(len=*), optional, intent(in) :: advance
    text = trim(text) // chars
  end subroutine outputLater_chars

  subroutine outputLater_real ( arg, advance )
    real, intent(in)             :: arg
    character(len=*), optional, intent(in) :: advance
    text = trim(text) // numToChars ( arg )
  end subroutine outputLater_real

  subroutine outputNow
    ! Snip away the null chars before printing
    text = asciify( text, how='snip' )
    if ( asHeadLine ) then
      if ( headLineChars == 'yes' ) then
        call headLine( trim(text), Before='*', After='*', fillChar='-' )
      else
        call headLine( trim(text), &
          & Before=headLineChars(1:1), After=headLineChars(1:1), &
          & fillChar='-' )
      endif
    elseif ( asBanner ) then
      if ( lineLength > 0 ) then
        call banner( trim(asciify( text, how='snip' )), linelength=lineLength ) 
      else
        call banner( trim(asciify( text, how='snip' )) ) 
      endif
    else
      call output ( trim(text), advance='yes' )
    endif
  end subroutine outputNow

  subroutine insertSpace
    ! We actually insert a space followed by a null; later the null will be removed
    ! before printing
    Text = trim(Text) // ' ' // achar(0)
  end subroutine insertSpace

d2806 3
@


2.116
log
@details level to skip all Dumps lowered to -3
@
text
@d20 2
d23 1
d114 4
d119 2
d122 2
d128 5
a158 1
    use MLSCOMMON, only: MLSFILE_T
a175 1
    integer :: fieldValue
a195 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
a269 1
    integer :: fieldValue
a291 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
a357 1
    integer :: fieldValue
a372 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
a416 1
    use MLSCOMMON, only: DEFAULTUNDEFINEDVALUE
a452 1
    integer :: fieldValue
a475 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
a661 1
    integer :: fieldValue
a675 5
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
a717 1
    use MLSCOMMON, only: FILENAMELEN
a733 1
    integer :: fieldValue
a742 1
    integer :: value
a753 6
      value = subtree(2,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
d1087 49
a1135 50
    use ANTENNAPATTERNS_M, only: DUMP_ANTENNA_PATTERNS_DATABASE
    use CALENDAR, only: DURATION_FORMATTED, TIME_T, TK
    use CALL_STACK_M, only: DUMP_STACK
    use CHUNKDIVIDECONFIG_M, only: CHUNKDIVIDECONFIG, DUMP
    use DECLARATION_TABLE, only: Dump_A_Decl, Decls, Get_Decl, Variable
    use DUMP_0, only: DIFF, DUMP, RMSFORMAT
    use EXPR_M, only: EXPR
    use FILTERSHAPES_M, only: DUMP_FILTER_SHAPES_DATABASE, &
      & DUMP_DACS_FILTER_DATABASE
    use FORWARDMODELCONFIG, only: DUMP, FORWARDMODELCONFIG_T
    use GRIDDEDDATA, only: DIFF, DUMP, GRIDDEDDATA_T
    use HESSIANMODULE_1, only: HESSIAN_T, DIFF, DUMP
    use HGRIDSDATABASE, only: DUMP, HGRID_T
    use IGRF_INT, only: DUMP_GH
    use INIT_TABLES_MODULE, only: F_ALLBOOLEANS, F_ALLFILES, &
      & F_ALLFORWARDMODELS, F_ALLGRIDDEDDATA, F_ALLHESSIANS, F_ALLHGRIDS, &
      & F_ALLL2PCS, F_ALLLINES, F_ALLMATRICES, F_ALLPFA, &
      & F_ALLQUANTITYTEMPLATES, F_ALLRADIOMETERS, F_ALLSIGNALS, F_ALLSPECTRA, &
      & F_ALLVECTORS, F_ALLVECTORTEMPLATES, F_ALLVGRIDS, F_ANTENNAPATTERNS, &
      & F_BLOCK, F_BOOLEAN, &
      & F_CALLSTACK, F_CHUNKDIVIDE, F_CHUNKNUMBER, F_CLEAN, &
      & F_COMMANDLINE, F_COUNT, F_CRASHBURN, &
      & F_DETAILS, F_DACSFILTERSHAPES, &
      & F_FILE, F_FILTERSHAPES, F_FORWARDMODEL, F_GRID, F_HESSIAN, &
      & F_HGRID, F_IGRF, F_L2PC, F_LINES, F_MARK, F_MASK, F_MATRIX, &
      & F_MIETABLES, F_OPTIONS, F_PFADATA, F_PFAFILES, F_PFANUM, F_PFASTRU, &
      & F_PHASENAME, F_POINTINGGRIDS, F_QUANTITY, &
      & F_SIGNALS,  F_SPECTROSCOPY, F_STACK, F_START, F_STOP, F_STRIDE, &
      & F_STOPWITHERROR, F_SURFACE, F_TEMPLATE, F_TEXT, F_TGRID, F_VARIABLE, &
      & F_VECTOR, F_VECTORMASK, F_VGRID, &
      & S_DIFF, S_DUMP, S_QUANTITY, S_VECTORTEMPLATE, &
      & FIELD_FIRST, FIELD_LAST
    use L2PARINFO, only: PARALLEL, CLOSEPARALLEL
    use L2PC_M, only: L2PCDATABASE, DUMPL2PC => DUMP
    use LEXER_CORE, only: GET_WHERE, WHERE_T
    use MACHINE, only: NEVERCRASH
    use MATRIXMODULE_1, only: MATRIX_T, MATRIX_DATABASE_T, &
      & DIFF, DUMP, GETFROMMATRIXDATABASE
    use MLSCOMMON, only: MLSFILE_T
    use MLSFILES, only: DUMPMLSFILE => DUMP, GETMLSFILEBYNAME
    use MLSKINDS, only: R8, RV
    use MLSL2OPTIONS, only: COMMAND_LINE, CURRENTCHUNKNUMBER, CURRENTPHASENAME, &
      & L2CFNODE, NORMAL_EXIT_STATUS, RUNTIMEVALUES, &
      & DUMPMACROS, MLSMESSAGE
    use MLSL2TIMINGS, only: DUMP_SECTION_TIMINGS
    use MLSMESSAGEMODULE, only: MLSMSG_CRASH, MLSMSG_ERROR, MLSMessageCalls, &
      & MLSMESSAGEEXIT
    use MLSFINDS, only: FINDFIRST
    use MLSSIGNALS_M, only: RADIOMETERS, SIGNALS, &
      & DUMP, DUMP_ALL, GETRADIOMETERINDEX
d1139 17
a1155 18
    use MORETREE, only: GET_BOOLEAN, GET_FIELD_ID, GET_SPEC_ID
    use PFADATABASE_M, only: DUMP, DUMP_PFADATABASE, DUMP_PFAFILEDATABASE, &
      & DUMP_PFASTRUCTURE, PFADATA
    use POINTINGGRID_M, only: DUMP_POINTING_GRID_DATABASE
    use QUANTITYTEMPLATES, only: DUMP, QUANTITYTEMPLATE_T
    use READ_MIE_M, only: DUMP_MIE
    use SPECTROSCOPYCATALOG_M, only: CATALOG, DUMP, DUMP_LINES_DATABASE, LINES
    use STRING_TABLE, only: Display_String, GET_STRING
    use TIME_M, only: FINISH
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NODE_ID, NSONS, SUB_ROSA, SUBTREE, WHERE
    use TREE_TYPES, only: N_SPEC_ARGS
    use VECTORSMODULE, only: VECTOR_T, VECTORTEMPLATE_T, VECTORVALUE_T, &
      & DIFF, DUMP, DESTROYVECTORQUANTITYVALUE, DUMPQUANTITYMASK, DUMPVECTORMASK, &
      & GATHERVECTORQUANTITY, GETVECTORQUANTITY, GETVECTORQTYBYTEMPLATEINDEX, &
      & GETVECTORQUANTITYINDEXBYNAME
    use VGRIDSDATABASE, only: DUMP, VGRIDS
a1168 2
    logical :: asBanner
    logical :: asHeadLine
a1197 1
    integer :: lineLength
d1213 1
d1217 1
a1217 1
    character :: TempText*20, Text*255
d1272 1
d1287 1
d1305 1
a1305 1
        & f_DACSfilterShapes, f_filterShapes, f_igrf, &
d1307 1
a1307 1
        & f_stop, f_stopWithError )
d1486 6
d1537 2
d1810 6
d1870 1
a1874 2
          asBanner = optionDetail( optionsString, 'B', 'Banner' ) == 'yes'
          asHeadline = optionDetail( optionsString, 'H', 'Headline' ) == 'yes'
a1876 1
          lineLenChars = optionDetail( optionsString, 'L', 'Linelength' )
a1877 2
        if ( lineLenChars /= 'no' ) &
          & call readIntsFromChars ( lineLenChars, lineLength )
d1960 1
a1960 11
          if ( asHeadLine ) then
            call headLine( trim(text), Before='*', After='*', fillChar='-' )
          elseif ( asBanner ) then
            if ( lineLength > 0 ) then
              call banner( trim(text), linelength=lineLength ) 
            else
              call banner( trim(text) ) 
            endif
          else
            call output ( trim(text), advance='yes' )
          endif
d2079 1
a2079 1
    logical :: verbose, verboser
d2084 1
a2084 1
    verboser = BeVerbose ( 'bool', 0 )
d2150 1
a2150 1
    logical :: verbose, verboser
d2155 1
a2155 1
    verboser = BeVerbose ( 'bool', 0 )
d2635 75
d2713 1
a2713 1
       "$Id: DumpCommand_m.f90,v 2.115 2014/05/31 00:24:55 pwagner Exp $"
d2723 3
@


2.115
log
@Small corrections; details should now be -3 to skipAllDumps
@
text
@d15 2
a16 2
! Or functions to set a run-time Boolean flag.
! (Should these latter functions be moved into a special Boolean module?)
d1360 1
a1360 1
            if ( details < -1 ) cycle
d1381 1
a1381 1
            if ( details < -1 ) cycle
d1388 1
a1388 1
            if ( details < -1 ) cycle
d1397 1
a1397 1
            if ( details < -1 ) cycle
d1421 1
a1421 1
            if ( details < -1 ) cycle
d1430 1
a1430 1
            if ( details < -1 ) cycle
d1433 1
a1433 1
            if ( details < -1 ) cycle
d1440 1
a1440 1
            if ( details < -1 ) cycle
d1606 1
a1606 1
        if ( details < -1 ) cycle
d1617 1
a1617 1
        if ( details < -1 ) cycle
d1651 1
a1651 1
        if ( details < -1 ) cycle
d1677 1
a1677 1
        if ( details < -1 ) cycle
d1688 1
a1688 1
        if ( details < -1 .or. .not. present(FileDataBase) ) cycle
d1706 1
a1706 1
        if ( details < -1 ) cycle
d1800 1
a1800 1
        if ( details < -1 ) cycle
d1854 1
a1854 1
        if ( details < -1 ) cycle
d1990 1
a1990 1
        if ( details < -1 ) cycle
d2007 1
a2007 1
        if ( details < -1 ) cycle
d2022 1
a2022 1
        if ( details < -1 ) cycle
d2665 1
a2665 1
       "$Id: DumpCommand_m.f90,v 2.114 2014/04/25 18:53:45 pwagner Exp $"
d2675 3
@


2.114
log
@options string to Dump text as headLine or Banner
@
text
@d1353 1
a1353 1
            if ( details < -1 ) cycle
d2397 1
a2397 1
      call output ( "Can't dump GriddedData here." )
d2665 1
a2665 1
       "$Id: DumpCommand_m.f90,v 2.113 2014/04/10 02:02:22 vsnyder Exp $"
d2675 3
@


2.113
log
@Improve message for nonexistent variable
@
text
@d18 3
a20 2
  use HIGHOUTPUT, only: BEVERBOSE, HEADLINE, NUMTOCHARS, OUTPUTNAMEDVALUE
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT
d1162 3
a1164 2
    use MLSSTRINGS, only: INDEXES, LOWERCASE, READINTSFROMCHARS, WRITEINTSTOCHARS
    use MLSSTRINGLISTS, only: GETHASHELEMENT, SWITCHDETAIL
d1196 2
d1206 2
d1226 2
d1310 5
d1878 17
d1975 13
a1987 1
          call output ( trim(text), advance='yes' )
d2665 1
a2665 1
       "$Id: DumpCommand_m.f90,v 2.112 2014/04/10 00:45:41 pwagner Exp $"
d2675 3
@


2.112
log
@Moved currentChunkNumber, currentPhaseName from MLSL2Timings to MLSL2Options
@
text
@a1954 1
          call display_string ( sub_rosa(subtree(i,son)) )
d1957 2
a1958 2
            call display_string ( sub_rosa(subtree(i,son)), before='The symbol ' )
            call output ( ' is not a variable.', advance='yes' )
d1960 1
d2623 1
a2623 1
       "$Id: DumpCommand_m.f90,v 2.111 2014/03/20 01:32:11 vsnyder Exp $"
d2633 3
@


2.111
log
@Remove unreferenced USE name
@
text
@d1152 2
a1153 2
    use MLSL2OPTIONS, only: COMMAND_LINE, L2CFNODE, &
      & NORMAL_EXIT_STATUS, RUNTIMEVALUES, &
d1155 1
a1155 2
    use MLSL2TIMINGS, only: CURRENTCHUNKNUMBER, CURRENTPHASENAME, &
      & DUMP_SECTION_TIMINGS
d2545 1
a2545 1
    use MLSL2TIMINGS, only: CURRENTCHUNKNUMBER, CURRENTPHASENAME
d2623 1
a2623 1
       "$Id: DumpCommand_m.f90,v 2.110 2014/02/28 01:10:44 vsnyder Exp $"
d2633 3
@


2.110
log
@Remove unused names
@
text
@d1115 1
a1115 1
    use DECLARATION_TABLE, only: Dump_A_Decl, Decls, Get_Decl, NUM_VALUE, Variable
d2624 1
a2624 1
       "$Id: DumpCommand_m.f90,v 2.109 2014/02/28 00:17:05 vsnyder Exp $"
d2634 3
@


2.109
log
@Don't re-check types already checked by type checker.  Move units checking
to type checker.  Don't handle Height field, since there isn't one allowed
in init_tables_module.
@
text
@a1145 1
    use INTRINSIC, only: PHYQ_DIMENSIONLESS
d1246 1
a1246 1
    integer :: Units(2) ! of the Details expr -- has to be phyq_dimensionless
d2624 1
a2624 1
       "$Id: DumpCommand_m.f90,v 2.108 2014/01/09 00:30:24 pwagner Exp $"
d2634 5
@


2.108
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d118 1
a118 2
  integer, parameter :: Dimless = 1
  integer, parameter :: NoFile = dimless + 1
d130 1
a130 2
  integer, parameter :: Numeric = noVT + 1
  integer, parameter :: Stop = numeric + 1
a883 1
    integer :: exprType
d945 2
a946 2
      case(f_c)
        call expr ( source, unitAsArray, valueAsArray, exprType )
d1134 1
a1134 1
      & F_FILE, F_FILTERSHAPES, F_FORWARDMODEL, F_GRID, F_HEIGHT, F_HESSIAN, &
a1242 1
    integer :: Type     ! of the Details expr -- has to be num_value
d1548 1
a1548 3
        call expr ( gson, units, values, type )
        if ( units(1) /= phyq_dimensionless ) call AnnounceError ( gson, dimless )
        if ( type /= num_value ) call announceError ( gson, numeric )
d1634 1
a1634 1
      case ( f_height, f_surface )
d1636 1
a1636 3
          call expr ( subtree(i,son), units, values, type )
          if ( units(1) /= phyq_dimensionless ) call AnnounceError ( subtree(i,son), dimless )
          if ( type /= num_value ) call announceError ( subtree(i,son), numeric )
d1825 1
a1825 3
          call expr ( subtree(i,son), units, values, type )
          if ( units(1) /= phyq_dimensionless ) call AnnounceError ( subtree(i,son), dimless )
          if ( type /= num_value ) call announceError ( subtree(i,son), numeric )
a2349 2
    case ( dimless )
      call output ( "The field is not unitless." )
a2373 2
    case ( numeric )
      call output ( "The field is not numeric." )
d2625 1
a2625 1
       "$Id: DumpCommand_m.f90,v 2.107 2013/12/12 02:09:29 vsnyder Exp $"
d2635 3
@


2.107
log
@Add 'details' to dump_a_decl
@
text
@d18 2
a149 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT
a250 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT
a347 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT, OUTPUTNAMEDVALUE
a428 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT
a663 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT, HEADLINE
a743 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT, OUTPUTNAMEDVALUE
a864 1
    use OUTPUT_M, only: BEVERBOSE, NUMTOCHARS, OUTPUT, OUTPUTNAMEDVALUE
a1168 1
    use OUTPUT_M, only: BEVERBOSE, BLANKS, OUTPUT, OUTPUTNAMEDVALUE
a2018 1
    ! use OUTPUT_M, only: OUTPUTNAMEDVALUE
a2061 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT
a2133 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT
a2244 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT, OUTPUTNAMEDVALUE
a2352 1
    use OUTPUT_M, only: NEWLINE, OUTPUT
a2402 1
    use OUTPUT_M, only: BEVERBOSE, OUTPUT, OUTPUTNAMEDVALUE
a2505 1
    ! use OUTPUT_M, only: OUTPUTNAMEDVALUE
a2527 1
    ! use OUTPUT_M, only: OUTPUTNAMEDVALUE
d2639 1
a2639 1
       "$Id: DumpCommand_m.f90,v 2.106 2013/11/18 22:33:28 pwagner Exp $"
d2649 3
@


2.106
log
@/callStack dumps verbose and debug dbs
@
text
@d1979 1
a1979 1
            call dump_a_decl ( decl, before=' is' )
d2653 1
a2653 1
       "$Id: DumpCommand_m.f90,v 2.105 2013/11/07 00:26:44 pwagner Exp $"
d2663 3
@


2.105
log
@May dump all dbs related to signals if details >1; use beVerbose
@
text
@d1451 2
d2653 1
a2653 1
       "$Id: DumpCommand_m.f90,v 2.104 2013/10/24 21:12:19 pwagner Exp $"
d2663 3
@


2.104
log
@Corrected some bugs in dumping hyperslabs
@
text
@d146 1
a146 2
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & SWITCHDETAIL
d148 1
a148 1
    use OUTPUT_M, only: OUTPUT
a150 1
    use TOGGLES, only: SWITCHES
d173 2
a174 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
a242 1
    use DUMP_0, only: DUMP
d248 1
a248 2
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & SWITCHDETAIL
d250 1
a250 1
    use OUTPUT_M, only: OUTPUT
a251 1
    use TOGGLES, only: SWITCHES
a255 1
    ! integer, intent(in) :: name
d277 2
a278 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
a342 1
    use DUMP_0, only: DUMP
d346 1
a346 2
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & SWITCHDETAIL
d348 1
a348 1
    use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
a349 1
    use TOGGLES, only: SWITCHES
d366 2
a367 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
d428 1
a428 1
      & REPLACESUBSTRING, SWITCHDETAIL
d430 1
a430 1
    use OUTPUT_M, only: OUTPUT
d432 1
a432 2
    use TOGGLES, only: SWITCHES
    use Trace_m, only: Trace_Begin, Trace_End
d478 2
a479 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
d664 1
a664 2
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & SWITCHDETAIL
d666 1
a666 1
    use OUTPUT_M, only: OUTPUT, HEADLINE
a667 1
    use TOGGLES, only: SWITCHES
d685 2
a686 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
d745 1
a745 2
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & SWITCHDETAIL
d747 1
a747 1
    use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
a748 1
    use TOGGLES, only: SWITCHES
d773 2
a774 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
d866 1
a866 1
      & INSERTHASHELEMENT, NUMSTRINGELEMENTS, PUTHASHELEMENT, SWITCHDETAIL
d869 1
a869 1
    use OUTPUT_M, only: NUMTOCHARS, OUTPUT, OUTPUTNAMEDVALUE
a871 1
    use TOGGLES, only: SWITCHES
d875 1
a875 1
      & DESTROYVECTORQUANTITYVALUE, DUMP, GATHERVECTORQUANTITY, &
d915 2
a916 2
    verbose = ( switchDetail(switches, 'bool') > 0 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
d1169 2
a1170 1
    use MLSSIGNALS_M, only: DUMP, GETRADIOMETERINDEX, RADIOMETERS, SIGNALS
d1174 1
a1174 1
    use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE
d1266 1
a1266 1
    verbose = ( switchDetail(switches, 'bool') > -1 )
d1421 3
a1423 1
            if ( associated(signals) ) then
a1755 3
              VectorValue = GatherVectorQuantity( qty1, &
                & start(1:hSlabRank), count(1:hSlabRank), &
                & stride(1:hSlabRank), block(1:hSlabRank) ) 
d1762 3
d2064 1
a2064 1
    use MLSSTRINGLISTS, only: GETHASHELEMENT, SWITCHDETAIL
d2067 1
a2067 1
    use OUTPUT_M, only: OUTPUT
d2069 1
a2069 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
d2086 2
a2087 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
d2137 1
a2137 1
    use MLSSTRINGLISTS, only: GETHASHELEMENT, SWITCHDETAIL
d2140 1
a2140 1
    use OUTPUT_M, only: OUTPUT
d2142 1
a2142 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
d2158 2
a2159 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
d2249 1
a2249 2
    use MLSSTRINGLISTS, only: BOOLEANVALUE, GETHASHELEMENT, PUTHASHELEMENT, &
      & SWITCHDETAIL
d2252 1
a2252 1
    use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d2254 1
a2254 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
d2275 2
a2276 2
    verbose = ( switchDetail(switches, 'bool') > -1 )
    verboser = ( switchDetail(switches, 'bool') > 0 )
d2410 1
a2410 1
    use MLSSTRINGLISTS, only: BOOLEANVALUE, GETSTRINGELEMENT, SWITCHDETAIL
d2412 1
a2412 2
    use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
    use TOGGLES, only: SWITCHES
d2430 1
a2430 1
    verbose = ( switchDetail(switches, 'bool') > 0 )
d2516 1
a2516 1
    use OUTPUT_M, only: OUTPUTNAMEDVALUE
d2539 1
a2539 1
    use OUTPUT_M, only: OUTPUTNAMEDVALUE
d2651 1
a2651 1
       "$Id: DumpCommand_m.f90,v 2.103 2013/10/17 18:27:29 pwagner Exp $"
d2661 3
@


2.103
log
@Must call trace_end in MLSSelect no matter what
@
text
@d1241 1
d1577 2
a1578 1
        do jj=1, min(nsons(startNode)-1, 2)
d1581 1
d1599 1
a1599 3
          call output(trim(fieldName), advance='no')
          call output(':', advance='no')
          call output(valueAsArray, advance='yes')
d1765 1
a1765 1
            ! dump that
d1768 23
a1790 3
              VectorValue = GatherVectorQuantity( qty1, start, count, stride, block ) 
              call dump ( VectorValue, details=2, &
                & vector=vectors(vectorIndex), options='-1' )
d2665 1
a2665 1
       "$Id: DumpCommand_m.f90,v 2.102 2013/10/09 23:44:13 vsnyder Exp $"
d2675 3
@


2.102
log
@Add Variable field
@
text
@d2080 4
a2083 1
    if ( MLSSelectedAlready ) return
d2644 1
a2644 1
       "$Id: DumpCommand_m.f90,v 2.101 2013/10/08 23:52:48 pwagner Exp $"
d2654 3
@


2.101
log
@Fixed call to BOOLEANVALUE--must use trim
@
text
@d1127 1
a1127 1
  ! ------------------------- DumpCommand ------------------------
d1138 1
a1138 1
    use DECLARATION_TABLE, only: NUM_VALUE
d1162 1
a1162 1
      & F_STOPWITHERROR, F_SURFACE, F_TEMPLATE, F_TEXT, F_TGRID, &
d1195 1
a1195 1
    use STRING_TABLE, only: GET_STRING
d1223 1
d1960 11
d2641 1
a2641 1
       "$Id: DumpCommand_m.f90,v 2.100 2013/09/27 00:38:12 pwagner Exp $"
d2651 3
@


2.100
log
@May select hyperslab when dumping quantity
@
text
@d2269 7
a2275 2
        skip = BooleanValue ( booleanString, &
          & runTimeValues%lkeys, runTimeValues%lvalues)
d2629 1
a2629 1
       "$Id: DumpCommand_m.f90,v 2.99 2013/09/25 18:46:50 pwagner Exp $"
d2639 3
@


2.99
log
@Fixed bug introduced with last commit
@
text
@d1229 1
d1257 1
d1581 1
d1584 1
d1587 1
d1590 1
d1594 3
a1596 1
          call output('index start: ', advance='no')
d1766 4
a1769 4
              qty2 = GatherVectorQuantity( qty1, start, count, stride, block ) 
              call dump ( qty2, details=details, &
                & vector=vectors(vectorIndex), options=optionsString )
              call DestroyVectorQuantityValue( qty2, destroyMask=.true., &
d2624 1
a2624 1
       "$Id: DumpCommand_m.f90,v 2.98 2013/09/25 16:33:27 pwagner Exp $"
d2634 3
@


2.98
log
@Uses hyperslab fields when dumping vector.quantities
@
text
@d1198 2
a1199 2
    use TRACE_M, only: TRACE_BEGIN, TRACE_END, WHERE
    use TREE, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, SUB_ROSA, SUBTREE
a1331 1
      source = source_ref(gson) ! column + 256*line in l2cf
d2616 1
a2616 1
       "$Id: DumpCommand_m.f90,v 2.96 2013/09/24 00:56:02 pwagner Exp $"
d2626 3
@


2.97
log
@Use Where instead of Source_Ref for messages
@
text
@d890 2
a891 1
      & DESTROYVECTORQUANTITYVALUE, DUMP, GETVECTORQTYBYTEMPLATEINDEX
d1168 1
a1168 1
    use Lexer_Core, only: Get_Where, Where_t
d1198 2
a1199 2
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NODE_ID, NSONS, SUB_ROSA, SUBTREE, Where
d1202 2
a1203 2
      & DIFF, DUMP, DUMPQUANTITYMASK, DUMPVECTORMASK, & ! FOR VECTORS, VECTOR QUANTITIES AND TEMPLATES
      & GETVECTORQUANTITY, GETVECTORQTYBYTEMPLATEINDEX, &
d1332 1
d1509 1
a1509 1
            end if
d1514 1
a1514 1
            end if
d1752 12
d1769 1
a1769 3

            if ( clean ) optionsString = trim(optionsString) // 'c'
            if ( .not. any(indexes(optionsString, (/'0','1','2'/)) > 0 ) ) then
d2627 3
@


2.96
log
@May specify hyperslab when dumping
@
text
@d1167 1
d1198 1
a1198 1
    use TREE, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, SUB_ROSA, SUBTREE
d1225 1
a1225 1
    character(len=128) :: Farewell
a1255 1
    integer :: Source ! column*256 + line
d1271 1
d1330 1
a1330 1
      source = source_ref(gson) ! column + 256*line in l2cf
d1492 3
a1494 3
              write ( farewell, '(a,2(i0,a))' ) &
                & "Program stopped with normal status by /stop field on DUMP statement at line ", &
                & source/256, ", column ", mod(source,256), "."
d1498 3
a1500 3
              write ( farewell, '(a,2(i0,a))' ) &
                & "Slave stopped by /stop field on DUMP statement at line ", &
                & source/256, ", column ", mod(source,256), "."
d1503 3
a1505 3
              write ( farewell, '(a,2(i0,a))' ) &
                & "Program stopped by /stop field on DUMP statement at line ", &
                & source/256, ", column ", mod(source,256), "."
d1507 1
a1507 1
            endif
d1512 4
a1515 4
            endif
            write ( farewell, '(a,2(i0,a))' ) &
                & "Program stopped by /stopWithError field on DUMP statement at line ", &
                & source/256, ", column ", mod(source,256), "."
d1913 2
a1914 5
              source = source_ref(subtree(k,son))
              write ( tempText(1:10), * ) source/256
              write ( tempText(11:20), * ) mod(source,256)
              text = text(:i-1) // "line " // trim(adjustl(tempText(1:10))) // &
                & ", column " // trim(adjustl(tempText(11:20))) // text(i+2:)
d2312 1
a2312 1
  subroutine ANNOUNCEERROR ( where, what, string )
d2605 1
a2605 1
       "$Id: DumpCommand_m.f90,v 2.94 2013/09/04 16:32:51 pwagner Exp $"
d2615 3
@


2.95
log
@Add ChunkDivide
@
text
@d672 1
a672 1
    use GRIDDEDDATA, only: GRIDDEDDATA_T
d677 1
a677 1
    use OUTPUT_M, only: OUTPUT
d720 1
d723 1
d993 1
d1029 1
d1031 1
d1136 1
a1136 1
    use ChunkDivideConfig_m, only: ChunkDivideConfig, Dump
d1152 3
a1154 3
      & F_BOOLEAN, &
      & F_CALLSTACK, F_CHUNKDIVIDE, F_CHUNKNUMBER, F_CLEAN, F_COMMANDLINE, &
      & F_CRASHBURN, &
d1160 1
a1160 1
      & F_SIGNALS,  F_SPECTROSCOPY, F_STACK, F_STOP, &
d1173 1
a1173 1
    use MLSKINDS, only: RV
d1237 1
d1245 1
d1256 2
d1268 2
d1313 5
d1568 21
d2367 1
a2367 1
    use OUTPUT_M, only: OUTPUTNAMEDVALUE
d2390 1
d2396 1
d2403 1
d2427 1
d2443 6
a2448 1
      bvalue = BooleanValue ( formula, &
d2450 2
d2617 3
@


2.94
log
@Replaced '--cat' cmdline option; 'Catenate' now an Output section command
@
text
@d1131 1
d1148 2
a1149 1
      & F_CALLSTACK, F_CHUNKNUMBER, F_CLEAN, F_COMMANDLINE, F_CRASHBURN, &
d1322 1
a1322 1
        & f_callStack, f_chunkNumber, f_commandLine, f_crashBurn, &
d1441 2
d2559 1
a2559 1
       "$Id: DumpCommand_m.f90,v 2.93 2013/08/31 02:29:12 vsnyder Exp $"
d2569 3
@


2.93
log
@Replace MLSMessageCalls with trace_begin and trace_end
@
text
@d2475 1
a2475 1
    use MLSL2OPTIONS, only: CATENATESPLITS, CHECKPATHS, NEED_L1BFILES, & ! , SIPS_VERSION
a2484 2
    case ('catenatesplits')
      itsValue = merge( 'true ', 'false', catenatesplits )
a2494 2
    case ('sips_version')
      itsValue = 'true' ! merge( 'true ', 'false', sips_version )
d2555 1
a2555 1
       "$Id: DumpCommand_m.f90,v 2.92 2013/08/30 23:19:28 pwagner Exp $"
d2565 3
@


2.92
log
@Fixed problem of empty spaces while tracing 'Skip'
@
text
@d132 1
d135 1
a135 1
  ! ------------------------------------- BooleanFromAnyGoodRadiances --
d243 1
a243 1
  ! ------------------------------------- BooleanFromAnyGoodValues --
d342 1
a342 1
  ! ------------------------------------- BooleanFromCatchWarning --
d427 1
a427 1
  ! ------------------------------------- BooleanFromComparingQtys --
d434 1
a434 1
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECALLS, MLSMSG_ERROR
d442 1
d475 1
d485 1
d487 1
a489 1
    call MLSMessageCalls( 'push', constantName=ModuleName//'%BooleanFromComparingQtys' )
d608 2
a609 1
    call MLSMessageCalls( 'pop' )
d611 1
d1172 2
a1173 2
    use MLSMESSAGEMODULE, only: MLSMESSAGECALLS, &
      & MLSMSG_CRASH, MLSMSG_ERROR, MLSMESSAGEEXIT
d1236 1
d1260 1
a1260 5
    if ( toggle(gen) ) then
      call trace_begin ( 'DumpCommand', root )
    else
      call MLSMessageCalls( 'push', constantName=ModuleName )
    end if
d1784 1
a1784 1
        call dump_stack( where=.true., CPU=.true. )
d1925 1
a1925 5
    if ( toggle(gen) ) then
      call trace_end ( 'DumpCommand' )
    else
      call MLSMessageCalls( 'pop' )
    end if
a1984 1
    use MLSMESSAGEMODULE, only: MLSMESSAGECALLS
d1997 1
a1998 1
    integer :: FieldIndex
d2000 1
d2004 1
d2006 1
a2011 5
    if ( toggle(gen) ) then
      call trace_begin ( 'MLSCase', root )
    else
      call MLSMessageCalls( 'push', constantName='MLSCase' )
    end if
d2047 1
a2047 5
    if ( toggle(gen) ) then
      call trace_end ( 'MLSCase' )
    else
      call MLSMessageCalls( 'pop' )
    end if
a2054 1
    use MLSMESSAGEMODULE, only: MLSMESSAGECALLS
d2067 1
a2068 1
    integer :: FieldIndex
d2070 1
d2073 1
d2075 1
a2077 5
    if ( toggle(gen) ) then
      call trace_begin ( 'MLSSelect', root )
    else
      call MLSMessageCalls( 'push', constantName='MLSSelect' )
    end if
d2103 1
a2103 5
    if ( toggle(gen) ) then
      call trace_end ( 'MLSSelect' )
    else
      call MLSMessageCalls( 'pop' )
    end if
d2110 1
a2110 1
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECALLS, MLSMSG_Info
d2121 1
d2123 1
a2123 1
    integer :: FieldIndex
d2127 1
a2127 5
    if ( toggle(gen) ) then
      call trace_begin ( 'MLSEndSelect', root )
    else
      call MLSMessageCalls( 'push', constantName='MLSEndSelect' )
    end if
d2145 1
a2145 5
    if ( toggle(gen) ) then
      call trace_end ( 'MLSEndSelect' )
    else
      call MLSMessageCalls( 'pop' )
    end if
a2166 1
    use MLSMESSAGEMODULE, only: MLSMESSAGECALLS
d2183 1
a2184 1
    integer :: FieldIndex
d2186 1
d2192 1
d2198 1
a2198 5
    if ( toggle(gen) ) then
      call trace_begin ( trim(myName), root )
    else
      call MLSMessageCalls( 'push', constantName=trim(myName) )
    end if
d2228 1
a2228 1
    enddo
d2241 1
a2241 1
      endif
d2244 1
a2244 1
      elseif ( c < 1 ) then
d2260 1
a2260 1
          endif
a2266 5
    endif
    if ( toggle(gen) ) then
      call trace_end ( trim(myName) )
    else
      call MLSMessageCalls( 'pop' )
d2268 1
d2559 1
a2559 1
       "$Id: DumpCommand_m.f90,v 2.91 2013/08/29 19:37:41 pwagner Exp $"
d2569 3
@


2.91
log
@May Dump plain stack, too
@
text
@d2220 1
a2220 1
      call trace_begin ( myName, root )
d2222 1
a2222 1
      call MLSMessageCalls( 'push', constantName=myName )
d2294 1
a2294 1
      call trace_end ( myName )
d2588 1
a2588 1
       "$Id: DumpCommand_m.f90,v 2.90 2013/08/12 23:49:41 pwagner Exp $"
d2598 3
@


2.90
log
@FindSomethings moved to MLSFinds module
@
text
@a139 1
    use DUMP_0, only: DUMP
a427 1
    use DUMP_0, only: DUMP
d1124 1
d1147 1
a1147 1
      & F_SIGNALS,  F_SPECTROSCOPY, F_STOP, &
d1166 2
a1167 2
    use MLSMESSAGEMODULE, only: MLSMESSAGECALLS, MLSMESSAGEEXIT, &
      & MLSMSG_CRASH, MLSMSG_ERROR
d1780 2
d2588 1
a2588 1
       "$Id: DumpCommand_m.f90,v 2.89 2013/08/01 20:46:30 vsnyder Exp $"
d2598 3
@


2.89
log
@Fix to dump two quantities with two quantity fields, two grids with two
grid fields, two hessians with two hessian fields, two masks with two
mask fields, or two matrices with two matrix fields.  Had been assuming
that two fields meant doing a diff.
@
text
@d1169 1
a1169 1
    use MLSSETS, only: FINDFIRST
d2587 1
a2587 1
       "$Id: DumpCommand_m.f90,v 2.88 2013/07/12 23:24:11 vsnyder Exp $"
d2597 6
@


2.88
log
@Announce error for 'expr' field -- no code yet
@
text
@d1577 1
a1577 1
            if ( gotFirst ) then
d1600 1
a1600 1
        GotFirst = .true.
d1616 1
a1616 1
            if ( gotFirst ) then
d1630 1
d1667 1
a1667 1
          if ( gotFirst ) then
d1726 1
a1726 1
        GotFirst = .true.
d1732 1
a1732 1
            if ( gotFirst ) then
d1752 1
a1752 1
        GotFirst = .true.
d2587 1
a2587 1
       "$Id: DumpCommand_m.f90,v 2.87 2013/05/22 20:20:49 pwagner Exp $"
d2597 3
@


2.87
log
@Moved insertHashElement to MLSStringLists
@
text
@d866 1
a866 1
    use INIT_TABLES_MODULE, only: F_A, F_B, F_BOOLEAN, F_C, F_EVALUATE, &
d872 1
a872 2
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, &
      & MLSMESSAGE
d977 7
a989 4
      case ( f_evaluate )
        ! call output( 'processing evaluate', advance='yes' )
        evaluate = get_boolean ( fieldValue )
        if ( verbose ) call outputNamedValue( 'evaluate', evaluate )
d2586 1
a2586 1
       "$Id: DumpCommand_m.f90,v 2.86 2013/05/17 00:55:47 pwagner Exp $"
d2596 3
@


2.86
log
@May now do elementwise operations on r/t macros with repeat command; fixed many bugs
@
text
@d875 1
a875 1
      & NUMSTRINGELEMENTS, PUTHASHELEMENT, SWITCHDETAIL
a1085 2
      ! call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      !   & lowercase(trim(nameString)), lowercase(trim(formula)), countEmpty=countEmpty )
a1096 2
      ! call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      !   & lowercase(trim(nameString)), lowercase(trim(formula)), countEmpty=countEmpty )
a1104 3
      ! call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      ! & lowercase(trim(nameString)), BooleanToString(tvalue), &
      ! & countEmpty=countEmpty )
a1112 50
  contains
    subroutine INSERTHASHELEMENT ( NAME, VALUE, KEYS, VALUES, INSEPARATOR )
      ! Dummy args
      character(len=*), intent(in)           :: NAME
      character(len=*), intent(in)           :: VALUE
      character(len=*), intent(inout)        :: KEYS
      character(len=*), intent(inout)        :: VALUES
      character(len=1), intent(in), optional :: INSEPARATOR
      ! Local variables
      character(len=64) :: cvalue
      integer :: c
      character (len=16)                            :: keyString
      integer                                       :: n
      character (len=8)                             :: nCh
      character (len=1)                             :: separator
      ! Executable
      separator = ','
      if ( present(inseparator) ) separator = inseparator
      ! 1st--is name an array-valued hash key?
      keyString = trim(name) // 'n'
      call GetHashElement( keys, values, keyString, nCh, &
        & countEmpty, inseparator=separator )
      if ( nCh == separator ) then
        ! No, it's just a scalar
        call PutHashElement ( keys, values, &
        & trim(name), value, countEmpty=countEmpty, inseparator=separator )
      else
        ! Yes, it's an array, so we must put it in two places:
        ! "name(cvalue)" and "name(n)" where
        ! cvalue is the actual value of "count"
        ! and "name(n)" is literally that (i.e., don't evaluate "n")
        call GetHashElement( keys, values, &
          & 'count', cvalue, countEmpty=countEmpty, inseparator=separator )
        keyString = trim(name) // '(n)'
        if ( verboser ) then
          call outputnamedValue( 'keyString', trim(keyString) )
          call outputnamedValue( 'value', trim(value) )
        endif
        call PutHashElement ( keys, values, &
          & trim(keyString), value, countEmpty=countEmpty, inseparator=separator )
        keyString = trim(name) // '(' // trim(adjustl(cvalue)) // ')'
        if ( verboser ) then
          call outputnamedValue( 'keyString', trim(keyString) )
          call outputnamedValue( 'value', trim(value) )
        endif
        call PutHashElement ( keys, values, &
          & trim(keyString), value, countEmpty=countEmpty, inseparator=separator )
      endif
    
    end subroutine INSERTHASHELEMENT
d1525 1
a1525 1
              QuantityIndex = GetVectorQuantityIndexByName ( vector, label )
d1527 4
a1530 2
              Quantity => GetVectorQuantity( vector, QuantityIndex )
              call dump( Quantity )
d1903 1
a1903 1
              call dump ( vector, details=details, clean=clean )
d2584 1
a2584 1
       "$Id: DumpCommand_m.f90,v 2.85 2013/05/07 22:01:30 pwagner Exp $"
d2594 3
@


2.85
log
@run-time Booleans can store arrays of values, formulas can evaluate named terms
@
text
@d143 1
a143 1
    use MLSL2OPTIONS, only: RUNTIMEVALUES
d235 4
a238 2
      & countEmpty=countEmpty )
    hashsize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty )
d240 1
a240 2
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
d250 1
a250 1
    use MLSL2OPTIONS, only: RUNTIMEVALUES
d334 4
a337 2
      & countEmpty=countEmpty )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty )
d339 1
a339 2
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
d351 1
a351 1
    use MLSL2OPTIONS, only: RUNTIMEVALUES
d419 4
a422 2
      & countEmpty=countEmpty )
    size = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty )
d424 1
a424 2
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
d434 1
a434 1
    use MLSL2OPTIONS, only: RUNTIMEVALUES
d600 4
a603 2
      & countEmpty=countEmpty )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty )
d605 1
a605 2
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
d669 1
a669 1
    use MLSL2OPTIONS, only: RUNTIMEVALUES
d721 4
a724 2
      & countEmpty=countEmpty )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty )
d726 1
a726 2
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
d748 1
a748 1
    use MLSL2OPTIONS, only: RUNTIMEVALUES
d846 4
a849 2
      & countEmpty=countEmpty )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty )
d851 1
a851 2
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
d871 1
a871 1
    use MLSL2OPTIONS, only: RUNTIMEVALUES
d874 2
a875 2
    use MLSSTRINGLISTS, only: GETHASHELEMENT, NUMSTRINGELEMENTS, &
      & PUTHASHELEMENT, SWITCHDETAIL
d971 2
a972 1
          & cnameString, cvalue, countEmpty=countEmpty )
d997 5
d1004 2
a1005 2
    if ( evaluate ) then
      formula = EvaluateFormula( formula )
d1008 14
a1021 5
    ! Should not have more than one of
    ! [f_values, f_formula, f_manipulation, f_label]
    if ( count(got( (/f_values, f_formula, f_manipulation, f_label/) ) ) /= 1 ) &
      & call announceError ( son, 0, &
      & ' Must supply exactly one of (values, formula, manipulation, label)' )
d1033 2
a1034 1
        & countEmpty=countEmpty )
d1047 6
a1052 1
        & countEmpty=countEmpty )
d1064 2
a1065 1
          & countEmpty=countEmpty )
d1086 5
a1090 2
      call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
        & lowercase(trim(nameString)), lowercase(trim(formula)), countEmpty=countEmpty )
d1099 5
a1103 2
      call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
        & lowercase(trim(nameString)), lowercase(trim(formula)), countEmpty=countEmpty )
d1109 6
a1114 3
      call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), BooleanToString(tvalue), &
      & countEmpty=countEmpty )
d1116 2
a1117 1
    size = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty )
d1119 52
a1170 3
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
  end function BooleanFromFormula
d1219 1
a1219 1
      & MLSMESSAGE
d1244 2
a1245 1
      & GETVECTORQTYBYTEMPLATEINDEX
d1253 1
a1253 1
    type (vector_T), dimension(:), optional                      :: Vectors
d1290 1
d1300 1
d1315 1
d1380 1
a1380 2
            call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
            & 'Run-time Boolean flags' )
d1556 3
a1558 2
          & trim(booleanString) // 'n', label, countEmpty )
        if ( label == ',' ) then
d1561 2
a1562 1
            & booleanString, label, countEmpty )
d1576 2
a1577 1
              & keyString, label, countEmpty )
d1580 7
d1953 1
d1956 1
a1956 2
              call dumpVectorMask ( vectors(decoration(decoration(subtree(i,son)))), &
                & details=details )
d1958 1
a1958 2
              call dump ( vectors(decoration(decoration(subtree(i,son)))), &
                & details=details, clean=clean )
d1985 2
a1986 1
      & 'count', '0', countEmpty=countEmpty )
d1988 2
a1989 1
      & 'countsn', '0', countEmpty=countEmpty )
d2004 2
a2005 1
      & 'count', cvalue, countEmpty=countEmpty )
d2009 2
a2010 1
      & 'count', cvalue, countEmpty=countEmpty )
d2013 2
a2014 1
      & 'countsn', nvalue, countEmpty=countEmpty )
d2022 2
a2023 1
      & keyString, cvalue, countEmpty=countEmpty )
d2025 2
a2026 1
      & 'counts(n)', cvalue, countEmpty=countEmpty )
d2077 2
a2078 1
          & booleanString, label, countEmpty )
d2151 2
a2152 1
          & booleanString, label, countEmpty )
d2311 2
a2312 1
        & 'count', cvalue, countEmpty=countEmpty )
d2314 5
a2318 1
      if ( c > nvalues ) then
d2327 2
a2328 1
          & countEmpty=countEmpty )
d2339 2
a2340 1
            & countEmpty=countEmpty )
d2479 1
a2479 1
        & runTimeValues%lkeys, runTimeValues%lvalues )
d2496 25
a2520 1
  function EvaluateFormula ( FORMULA ) result( ITSVALUE )
d2537 1
a2537 1
  end function EvaluateFormula
d2573 2
a2574 1
        & arg, itsValue, countEmpty=countEmpty )
d2589 3
a2591 2
        & arg, itsValue, countEmpty=countEmpty )
      if ( itsvalue == ',' ) itsValue = arg
d2639 1
a2639 1
       "$Id: DumpCommand_m.f90,v 2.84 2013/04/24 00:36:02 pwagner Exp $"
d2649 3
@


2.84
log
@Added inputBoolean and made Reevaluate formulas more powerful
@
text
@d62 1
a62 1
!               (a) Evaluate the formula; it may be one of two forms
d64 4
a67 1
!               (2) Contains "lhs == rhs" or "lhs /= rhs" => Does it?
d73 3
a75 2
!                Set the Repeat counter to 0
! NextRepeat     Add 1 to current value of Repeat counter
d79 1
a79 1
! Skip           Process the Skip control statement
d82 26
d113 19
a131 1
  character(LEN=MAXRESULTLEN), save :: selectLabel  = ' '
d135 1
a135 1
  function BooleanFromAnyGoodRadiances ( ROOT, CHUNK, FILEDATABASE ) &
d243 1
a243 1
  function BooleanFromAnyGoodValues ( ROOT, VECTORS ) result( THESIZE )
d341 1
a341 1
  function BooleanFromCatchWarning ( ROOT ) result( SIZE )
d425 1
a425 1
  function BooleanFromComparingQtys ( ROOT, VECTORS ) result( THESIZE )
d604 1
a604 1
    elemental logical function isRelation( relation, a, b )
d623 1
a623 1
    function statFun ( name, values, mask )
d661 1
a661 1
  function BooleanFromEmptyGrid ( ROOT, GRIDS ) result( THESIZE )
d732 1
a732 1
  function BooleanFromEmptySwath ( ROOT ) result( THESIZE )
d849 1
a849 1
  function BooleanFromFormula ( NAME, ROOT, VECTORS ) result( SIZE )
d857 1
a857 1
    ! [a=a.qty], [b=b.qty], [c=value], [/literal]
d860 2
a861 2
    use INIT_TABLES_MODULE, only: F_A, F_B, F_BOOLEAN, F_C, &
      & F_FORMULA, F_INPUTBOOLEAN, F_LABEL, F_LITERAL, F_VALUES, &
d870 1
a870 1
    use MLSSTRINGS, only: LOWERCASE, READNUMSFROMCHARS
d886 1
d893 1
d900 1
d902 1
d905 1
d912 1
d918 1
a918 1
    verbose = ( switchDetail(switches, 'bool') > -1 )
d922 1
d963 1
a963 1
        cnameString = lowerCase(nameString)
d971 1
a971 1
      case ( f_formula )
d977 4
d986 1
a986 3
        call expr ( son , unitAsArray, valueAsArray )
        tvalue = ( valueAsArray(1) /= 0 )
        ! badRange = valueAsArray
d990 50
a1039 1
    if ( literal .and. .not. got(f_label) ) then
d1043 1
a1043 4
        & 'Cant set /literal from this section--only Fill or Retrieval' )
      if ( .not. got ( f_formula) ) &
        & call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Must supply formula if literal field is present' )
d1051 1
a1051 1
      if ( verbose ) then
d1064 1
a1064 1
      if ( verbose ) then
d1071 1
a1071 1
      if ( verbose ) then
d1080 1
a1080 1
    if ( verboser ) &
d1086 1
a1086 1
  subroutine DumpCommand ( ROOT, QUANTITYTEMPLATESDB, &
d1139 1
a1139 1
    use MLSSTRINGS, only: INDEXES, LOWERCASE
d1142 1
a1142 1
    use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d1192 1
d1198 1
d1213 1
a1217 17
    ! Error codes
    integer, parameter :: Dimless = 1
    integer, parameter :: NoFile = dimless + 1
    integer, parameter :: NoFileDatabase = noFile + 1
    integer, parameter :: NoFWM = noFileDatabase + 1
    integer, parameter :: noGriddedData = NoFWM + 1
    integer, parameter :: NoHGrid = noGriddedData + 1
    integer, parameter :: NoLines = noHGrid + 1
    integer, parameter :: NoQT = noLines + 1
    integer, parameter :: Noradiometers = noQT + 1
    integer, parameter :: NoSignals = noradiometers + 1
    integer, parameter :: NoTG = noSignals + 1
    integer, parameter :: NoVectors = noTG + 1
    integer, parameter :: NoVT = noVectors + 1
    integer, parameter :: Numeric = noVT + 1
    integer, parameter :: Stop = numeric + 1
    integer, parameter :: Unknown = stop + 1 ! Unknown template
d1224 1
d1464 1
a1464 1
        call output( trim(booleanString) // ' = ', advance='no' )
d1466 23
a1488 2
          & booleanString, label, countEmpty )
        call output( label, advance='yes' )
a1879 51
  contains

    subroutine AnnounceError ( where, what, string )
      use MORETREE, only: STARTERRORMESSAGE
      use OUTPUT_M, only: NEWLINE

      integer, intent(in) :: What, Where
      character(len=*), intent(in), optional :: String

      call StartErrorMessage ( where )

      select case ( what )
      case ( dimless )
        call output ( "The field is not unitless." )
      case ( noFile )
        call output ( "File " // string // " not in database." )
      case ( noFileDatabase )
        call output ( "File database not provided." )
      case ( noFWM )
        call output ( "Can't dump Forward Model Configs here." )
      case ( noGriddedData )
        call output ( "Can't dump GriddedData here." )
      case ( noHGrid )
        call output ( "Can't dump HGrids here." )
      case ( noLines )
        call output ( "Can't dump Lines here." )
      case ( noQT )
        call output ( "Can't dump Quantity Templates here." )
      case ( noradiometers )
        call output ( "Can't dump Radiometers here." )
      case ( noSignals )
        call output ( "Can't dump Signals here." )
      case ( noTG )
        call output ( "Can't dump TGrids here." )
      case ( noVectors )
        call output ( "Can't dump Vectors here." )
      case ( noVT )
        call output ( "Can't dump Vector Templates here." )
      case ( numeric )
        call output ( "The field is not numeric." )
      case ( stop )
        call output ( "Program stopped by /stop field on DUMP statement." )
      case ( unknown )
        call output ( "Can't figure out what kind of template it is." )
      case default
        if ( present(string) ) call output ( string )
        call output ( "No reserved error flag for this" )
      end select
      call newLine
    end subroutine AnnounceError

d1887 2
d1894 2
a1895 1
    use MLSSTRINGS, only: READNUMSFROMCHARS, WRITEINTSTOCHARS
d1898 4
a1901 1
    real :: c
d1904 2
a1905 2
    call readNumsFromChars ( cvalue, c )
    call writeIntsToChars ( int(c+1.), cvalue )
d1908 13
d1924 1
a1924 1
  subroutine  MLSCase ( ROOT )
d1947 1
a1947 1
    character(len=8)  :: optionsString
d2002 1
a2002 1
  subroutine  MLSSelect ( ROOT )
d2064 1
a2064 1
  subroutine  MLSEndSelect ( ROOT )
d2113 18
a2130 7
  logical function Skip ( ROOT )
    ! Returns value of Boolean field (if present);
    ! If TRUE should skip rest of section in which SKIP command appears
    ! If Boolean field absent, returns TRUE 
    ! (otherwise it would do nothing--
    ! this way it forces us to skip unconditionally)
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_FORMULA
d2133 3
a2135 2
    use MLSSTRINGLISTS, only: BOOLEANVALUE, SWITCHDETAIL
    use MLSSTRINGS, only: LOWERCASE
d2143 2
a2144 1
    integer, intent(in) :: Root ! Root of the parse tree for the dump command
d2147 2
d2151 3
d2155 1
d2160 2
d2163 1
a2163 1
      call trace_begin ( 'Skip', root )
d2165 1
a2165 1
      call MLSMessageCalls( 'push', constantName='Skip' )
d2167 1
d2169 1
d2183 1
a2183 1
        if ( verbose ) call outputNamedValue( 'formula', trim(booleanString) )
d2185 2
d2190 1
a2190 1
      if ( verbose ) then
d2197 32
d2230 1
a2230 1
      call trace_end ( 'Skip' )
d2238 49
d2310 1
a2310 1
    verbose = ( switchDetail(switches, 'bool') > -1 )
d2381 21
a2401 1
  ! This evaluates a character-valued arg, being alert for special values
d2403 13
a2415 1
  function Evaluator ( ARG ) result( ITSVALUE )
d2452 1
a2452 1
  end function Evaluator
d2465 1
a2465 1
  subroutine returnFullFileName ( SHORTNAME, FULLNAME, &
d2498 1
a2498 1
       "$Id: DumpCommand_m.f90,v 2.83 2013/04/22 17:49:20 pwagner Exp $"
d2508 3
@


2.83
log
@Reevaluate may store a literal instead of a Boolean value
@
text
@d27 1
d69 3
d813 1
a813 1
      & F_FORMULA, F_LABEL, F_LITERAL, F_VALUES, &
d820 3
a822 2
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT, SWITCHDETAIL
    use MLSSTRINGS, only: LOWERCASE
d825 1
d829 3
a831 2
    use VECTORSMODULE, only: CLONEVECTORQUANTITY, DESTROYVECTORQUANTITYVALUE, &
      & DUMP, GETVECTORQTYBYTEMPLATEINDEX, VECTOR_T, VECTORVALUE_T
d840 1
d842 3
d857 1
d902 2
a903 1
        call expr ( source, unitAsArray, valueAsArray )
d905 8
a912 1
        call outputNamedValue( 'c', c )
d923 1
a923 1
        call output( 'processing literal', advance='yes' )
d925 1
a925 1
        call outputNamedValue( 'literal', literal )
d938 1
a938 1
      if ( .not. all( got ( (/f_formula, f_a/) ) ) ) &
d940 7
a946 1
        & 'Must supply formula and a fields if literal field is present' )
d1822 23
d2046 1
a2046 1
    use OUTPUT_M, only: OUTPUT
d2081 1
d2104 2
a2105 2
    use MLSSTRINGLISTS, only: BOOLEANVALUE, GETSTRINGELEMENT
    use MLSSTRINGS, only: LOWERCASE
d2107 1
d2114 1
d2121 3
d2125 1
d2139 38
d2189 4
a2192 2
    call outputnamedvalue('lhs', trim(lhs) )
    call outputnamedvalue('rhs', trim(rhs) )
d2200 1
a2200 1
      & SKIPRETRIEVAL
d2202 1
d2215 3
d2230 4
a2233 1
      itsValue = arg
d2281 1
a2281 1
       "$Id: DumpCommand_m.f90,v 2.81 2013/02/21 21:38:10 pwagner Exp $"
d2291 3
@


2.82
log
@Add quantity database to forward model config dump
@
text
@d64 1
a64 1
!               (b) Just sture the text of the label field
d196 1
a196 1
    use MLSCOMMON, only: RV
d377 2
a378 1
    use MLSCOMMON, only: R8, RV, DEFAULTUNDEFINEDVALUE
d797 1
a797 1
  function BooleanFromFormula ( NAME, ROOT ) result( SIZE )
d804 2
a805 1
    ! Reevaluate, formula="formula", Boolean="name"
d808 5
a812 2
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_FORMULA, F_LABEL, F_VALUES
    use MLSKINDS, only: R8
d814 2
d818 2
a819 1
    use OUTPUT_M, only: OUTPUT
d823 2
d826 4
a829 3
    integer, intent(in) :: name
    integer, intent(in) :: root
    integer             :: size
d831 3
d838 1
d842 1
d844 2
d849 1
d854 2
d858 1
d867 2
a868 1
        fieldValue = decoration(subtree(2,son)) ! The field's value
d871 1
d874 1
d877 16
d902 4
d913 21
a933 1
    if ( literal ) then
d2188 3
@


2.81
log
@Pass options string when dumping quantity mask
@
text
@d1118 2
a1119 1
              call dump ( forwardModelConfigs, where=son )
d1317 2
a1318 1
              & forwardModelConfigs(decoration(decoration(subtree(i,son)))) )
d2113 1
a2113 1
       "$Id: DumpCommand_m.f90,v 2.80 2013/02/12 18:17:44 pwagner Exp $"
d2123 3
@


2.80
log
@Removed SIPS_VERSION; raised -Sbool switch needed for most printing
@
text
@d925 2
a926 1
      & S_DIFF, S_DUMP, S_QUANTITY, S_VECTORTEMPLATE
d988 1
d1084 1
d1093 1
d1294 1
d1446 4
d1451 2
a1452 1
              & vectors(vectorIndex), quantityIndex), details=details )
d1470 1
a1470 1
              call dumpQuantityMask( qty1, details=0 )
d2111 1
a2111 1
       "$Id: DumpCommand_m.f90,v 2.79 2012/12/04 00:19:14 pwagner Exp $"
d2121 3
@


2.79
log
@May dump timings summary after Dump, /stop
@
text
@d121 1
a121 1
    logical :: verbose
d124 1
d177 4
d185 1
a185 1
    if ( switchDetail(switches, 'bool') > 0 ) &
d201 1
d228 1
a228 1
    logical :: verbose
d231 1
d275 4
d283 1
a283 1
    if ( verbose ) &
d302 1
a302 1
    use OUTPUT_M, only: OUTPUTNAMEDVALUE
d319 1
d321 2
d345 4
a348 2
    call outputNamedValue( 'message to match', message )
    call outputNamedValue( 'LastWarningMsg', LastWarningMsg )
d359 4
d367 1
a367 1
    if ( switchDetail(switches, 'bool') > -1 ) &
d384 1
d427 1
a427 1
    logical :: verbose
d430 1
d538 4
d546 1
a546 1
    if ( verbose ) &
d616 1
d634 1
a634 1
    logical :: verbose
d637 1
d658 4
d666 1
a666 1
    if ( verbose ) &
d696 1
a696 1
    use OUTPUT_M, only: OUTPUTNAMEDVALUE
d721 1
a721 1
    logical :: verbose
d724 1
d782 4
d790 1
a790 1
    if ( verbose ) &
d811 1
d831 1
a831 1
    logical :: verbose
d834 1
d870 4
d877 4
d886 1
a886 1
    if ( verbose ) &
d1036 1
a1036 1

d1493 1
a1493 1
        optionsString = lowerCase(optionsString)
d1727 1
a1727 1
    use MLSSTRINGLISTS, only: GETHASHELEMENT
d1730 1
d1732 1
a1732 1
    use TOGGLES, only: GEN, TOGGLE
d1744 1
d1746 2
d1784 4
d1803 1
a1803 1
    use MLSSTRINGLISTS, only: GETHASHELEMENT
d1806 1
d1808 1
a1808 1
    use TOGGLES, only: GEN, TOGGLE
d1819 1
d1821 2
d1846 4
d1932 1
a1932 1
    logical :: verbose
d1935 1
d2026 2
a2027 2
    use MLSL2OPTIONS, only: CHECKPATHS, NEED_L1BFILES, &
      & SIPS_VERSION
d2035 2
d2044 1
a2044 1
      itsValue = merge( 'true ', 'false', sips_version )
d2047 2
d2050 1
a2050 1
      ! What the devil did you mean?
d2101 1
a2101 1
       "$Id: DumpCommand_m.f90,v 2.78 2012/08/16 18:03:44 pwagner Exp $"
d2111 3
@


2.78
log
@Exploit level 2-savvy MLSMessage
@
text
@d83 2
a84 2
  function BooleanFromAnyGoodRadiances ( root, chunk, filedatabase ) &
    & result(hashsize)
d186 1
a186 1
  function BooleanFromAnyGoodValues ( root, vectors ) result(thesize)
d278 1
a278 1
  function BooleanFromCatchWarning ( root ) result(size)
d353 1
a353 1
  function BooleanFromComparingQtys ( root, vectors ) result(thesize)
d582 1
a582 1
  function BooleanFromEmptyGrid ( root, grids ) result(thesize)
d647 1
a647 1
  function BooleanFromEmptySwath ( root ) result(theSize)
d759 1
a759 1
  function BooleanFromFormula ( name, root ) result(size)
d845 3
a847 3
  subroutine DumpCommand ( Root, QuantityTemplatesDB, &
    & VectorTemplates, Vectors, ForwardModelConfigs, HGrids, griddedDataBase, &
    & FileDataBase, MatrixDatabase, HessianDatabase )
d891 2
a892 1
    use MLSL2TIMINGS, only: CURRENTCHUNKNUMBER, CURRENTPHASENAME
d908 1
a908 1
    use Time_m, only: FINISH
d1196 4
d1218 4
d1447 1
a1447 1
        call outputNamedValue( 'options', trim(optionsString) )
d1622 2
a1623 2
      use MoreTree, only: STARTERRORMESSAGE
      use Output_m, only: NEWLINE
d1672 1
a1672 1
  subroutine  MLSCase ( Root )
d1742 1
a1742 1
  subroutine  MLSSelect ( Root )
d1796 1
a1796 1
  subroutine  MLSEndSelect ( Root )
d1845 1
a1845 1
  logical function Skip ( Root )
d1911 1
a1911 1
  function myBooleanValue ( formula ) result ( bvalue )
d1961 1
a1961 1
  function Evaluator ( arg ) result( itsValue )
d1989 1
a1989 1
  function BooleanToString ( Bool ) result ( str )
d2000 2
a2001 2
  subroutine returnFullFileName ( shortName, FullName, &
    & pcf_start, pcf_end )
d2033 1
a2033 1
       "$Id: DumpCommand_m.f90,v 2.77 2012/06/27 17:53:04 pwagner Exp $"
d2043 3
@


2.77
log
@May now Dump command line
@
text
@d862 1
a862 1
    use IGRF_INT, only: Dump_GH
d888 3
a890 1
    use MLSL2OPTIONS, only: COMMAND_LINE, NORMAL_EXIT_STATUS, RUNTIMEVALUES
d892 1
a892 1
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECALLS, MLSMESSAGEEXIT, &
d907 1
a907 1
    use Time_m, only: Finish
d1039 1
d1234 1
d2024 1
a2024 1
       "$Id: DumpCommand_m.f90,v 2.76 2012/06/06 20:20:46 vsnyder Exp $"
d2034 3
@


2.76
log
@Add line number to farewell for /stop
@
text
@d868 2
a869 1
      & F_BOOLEAN, F_CALLSTACK, F_CHUNKNUMBER, F_CLEAN, F_CRASHBURN, &
d888 1
a888 1
    use MLSL2OPTIONS, only: NORMAL_EXIT_STATUS, RUNTIMEVALUES
d1046 1
a1046 1
        & f_callStack, f_chunkNumber, f_crashBurn, &
d1167 2
d2020 1
a2020 1
       "$Id: DumpCommand_m.f90,v 2.75 2012/05/14 22:26:31 pwagner Exp $"
d2030 3
@


2.75
log
@Guard against missing swath--counts as empty
@
text
@d933 1
d1037 1
d1190 4
a1193 2
              call MLSMessageExit( NORMAL_EXIT_STATUS, &
                & farewell="Program stopped with normal status by /stop field on DUMP statement.")
d1196 9
a1204 5
              call MLSMessageExit( &
                & farewell="slave stopped by /stop field on DUMP statement.")
            else
              call MLSMessageExit( &
                & farewell="Program stopped by /stop field on DUMP statement.")
d1207 4
a1210 2
              call MLSMessageExit( 1, &
                & farewell="Program stopped by /stopWithError field on DUMP statement.")
d2017 1
a2017 1
       "$Id: DumpCommand_m.f90,v 2.74 2012/05/11 00:16:42 pwagner Exp $"
d2027 3
@


2.74
log
@Added BooleanFromEmptySwath
@
text
@d35 40
d641 1
d656 1
a724 2
    call ReadL2GPData ( trim(filename), trim(swathname), l2gp, &
      & hdfVersion=HDFVERSION_5 )
d726 22
a747 15
    call allocate_test( negativePrec, l2gp%nTimes, 'negativePrec', ModuleName )
    call allocate_test( oddStatus, l2gp%nTimes, 'oddStatus', ModuleName )
    do i=1, l2gp%nTimes
      negativePrec(i) = all( l2gp%l2GPPrecision(:,:,i) < 0._rgp )
    enddo
    do i=1, l2gp%nTimes
      oddStatus(i) = mod(l2gp%status(i), 2) > 0
    enddo
    numGood = count( .not. ( negativePrec .or. &
      & (mod(l2gp%status, 2) > 0) ) )
    tvalue = ( numGood < 1 )
    if ( verbose ) then
      call dump( negativePrec, 'num surfs with prec < 0' )
      call dump( oddStatus, 'num surfs with odd status' )
      call outputNamedValue ( 'empty swath?', tvalue )
a748 3
    call deallocate_test( negativePrec, 'negativePrec', ModuleName )
    call deallocate_test( oddStatus, 'oddStatus', ModuleName )
    call DestroyL2GPContents ( l2gp )
d2007 1
a2007 1
       "$Id: DumpCommand_m.f90,v 2.73 2012/05/08 17:48:37 pwagner Exp $"
d2017 3
@


2.73
log
@Added Select .. Case .. EndSelect control structure
@
text
@d21 7
a27 7
  public :: BooleanFromAnyGoodRadiances
  public :: BooleanFromAnyGoodValues
  public :: BooleanFromCatchWarning
  public :: BooleanFromComparingQtys
  public :: BooleanFromEmptyGrid
  public :: BooleanFromFormula
  public :: MLSCase, DumpCommand, MLSEndSelect, MLSSelect, Skip
d37 1
a37 1
  logical, public, save             :: MLSSelecting = .false.
a553 1
    ! integer, intent(in) :: name
d599 115
d850 1
a850 1
    use MLSSTRINGLISTS, only: BOOLEANVALUE, GETHASHELEMENT, SWITCHDETAIL
a916 1
    logical :: tvalue
a1164 2
        ! tvalue = BooleanValue ( booleanString, &
        !  & runTimeValues%lkeys, runTimeValues%lvalues )
d1607 1
a1607 1
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_LABEL
d1611 1
a1611 1
    use MLSSTRINGS, only: LOWERCASE
d1614 1
a1614 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
d1624 1
a1625 1
    logical :: verbose
d1629 1
d1648 2
d1655 8
a1662 1
    MLSSelecting = ( label /= selectLabel ) .and. ( label /= 'default' )
d1682 1
a1682 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
a1692 1
    logical :: verbose
d1734 1
a1734 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
a1743 1
    logical :: verbose
d1929 31
d1963 1
a1963 1
       "$Id: DumpCommand_m.f90,v 2.72 2012/05/01 23:18:13 pwagner Exp $"
d1973 3
@


2.72
log
@More capable Boolean formula; adds relations
@
text
@d27 1
a27 1
  public :: DumpCommand, Skip
d35 5
a68 1
    logical, parameter :: countEmpty = .true.
d137 2
a138 1
      & lowercase(trim(nameString)), tvalue, countEmpty=countEmpty )
a166 1
    logical, parameter :: countEmpty = .true.
d229 2
a230 1
      & lowercase(trim(nameString)), tvalue, countEmpty=countEmpty )
a258 1
    logical, parameter :: countEmpty = .true.
d304 2
a305 1
      & lowercase(trim(nameString)), tvalue, countEmpty=countEmpty )
a350 1
    logical, parameter :: countEmpty = .true.
d434 1
a434 1
      call mlsmessage (MLSMSG_Error, moduleName, &
d437 1
a437 1
      call mlsmessage (MLSMSG_Error, moduleName, &
d473 1
a473 1
      call mlsmessage (MLSMSG_Error, moduleName, &
d477 2
a478 1
      & lowercase(trim(nameString)), tvalue, countEmpty=countEmpty )
a558 1
    logical, parameter :: countEmpty = .true.
d592 2
a593 1
      & lowercase(trim(nameString)), tvalue, countEmpty=countEmpty )
d611 1
a611 1
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_FORMULA, F_VALUES
a623 1
    logical, parameter :: countEmpty = .true.
d629 1
d638 1
d661 3
d671 9
a679 2
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), tvalue, countEmpty=countEmpty )
d736 1
a736 1
    use MLSSTRINGLISTS, only: BOOLEANVALUE, SWITCHDETAIL
a769 1
    logical, parameter :: countEmpty = .true.
d786 1
d1050 5
a1054 3
        tvalue = BooleanValue ( booleanString, &
          & runTimeValues%lkeys, runTimeValues%lvalues)
        call output( tvalue, advance='yes' )
d1491 165
d1684 1
a1684 1
      call trace_begin ( 'DumpCommand', root )
d1686 1
a1686 1
      call MLSMessageCalls( 'push', constantName=ModuleName )
a1711 5
      if ( toggle(gen) ) then
        call trace_end ( 'DumpCommand' )
      else
        call MLSMessageCalls( 'pop' )
      end if
d1713 5
d1723 1
a1723 3
    use MLSL2OPTIONS, only: CHECKPATHS, NEED_L1BFILES, RUNTIMEVALUES, &
      & SIPS_VERSION
    use MLSL2TIMINGS, only: CURRENTCHUNKNUMBER, CURRENTPHASENAME
d1725 1
a1725 1
    use MLSSTRINGS, only: LOWERCASE, WRITEINTSTOCHARS
a1758 1
    lhs = lowercase(adjustl(lhs))
d1762 20
a1781 1
    select case (lhs)
d1783 1
a1783 1
      lhs = merge( 'true ', 'false', checkpaths )
d1785 1
a1785 1
      call writeIntsToChars ( currentChunkNumber, lhs )
d1787 1
a1787 1
      lhs = lowercase(currentPhaseName)
d1789 1
a1789 1
      lhs = merge( 'true ', 'false', sips_version )
d1791 1
a1791 1
      lhs = merge( 'true ', 'false', need_l1bfiles )
d1796 1
d1798 11
a1808 5
    bvalue = (lhs == rhs)
    call outputnamedvalue('lhs', trim(lhs) )
    call outputnamedvalue('rhs', trim(rhs) )
    if ( reverse ) bvalue = .not. bvalue  ! If we meant not equal
  end function myBooleanValue
d1813 1
a1813 1
       "$Id: DumpCommand_m.f90,v 2.71 2012/04/26 23:28:33 pwagner Exp $"
d1823 3
@


2.71
log
@May Dump chunk number, phase name; BooleanFromFormula can compare strings, variables
@
text
@d607 4
a610 7
    use MLSCOMMON, only: R8
    use MLSL2OPTIONS, only: CHECKPATHS, NEED_L1BFILES, RUNTIMEVALUES, &
      & SIPS_VERSION
    use MLSL2TIMINGS, only: CURRENTCHUNKNUMBER, CURRENTPHASENAME
    use MLSSTRINGLISTS, only: BOOLEANVALUE, GETSTRINGELEMENT, &
      & NUMSTRINGELEMENTS, PUTHASHELEMENT, SWITCHDETAIL
    use MLSSTRINGS, only: LOWERCASE, WRITEINTSTOCHARS
a667 57
  contains
    function myBooleanValue ( formula ) result ( bvalue )
      ! Calculate the boolean value according to
      ! (1) The logical value of its formula, if the formula
      !     does not contain the special operators "==" or "/="
      ! (2) if the formula is "variable == value" and variable is
      !     is recognized and takes the value "value", return "true", else "false"
      ! (3) if the formula is "variable /= value" return not (2)
      character(len=*), intent(in) :: formula
      logical :: bvalue
      ! Internal variables
      character(len=16) :: lhs, rhs
      logical, parameter :: countEmpty = .false.
      logical :: reverse  ! Do we mean NOT equal?
      ! Executable
      bvalue = .false.
      reverse = .false.
      if ( index(formula, "==") > 1 ) then
        call GetStringElement ( formula, lhs, &
          & 1, countEmpty, inseparator='=' )
        call GetStringElement ( formula, rhs, &
          & 2, countEmpty, inseparator='=' )
      elseif ( index(formula, "/=") > 1 ) then
        call GetStringElement ( formula, lhs, &
          & 1, countEmpty, inseparator='/' )
        call GetStringElement ( formula, rhs, &
          & 2, countEmpty, inseparator='=' )
        reverse = .true.
      else
        bvalue = BooleanValue ( formula, &
          & runTimeValues%lkeys, runTimeValues%lvalues )
        return
      endif
      rhs = lowercase(adjustl(rhs))
      lhs = lowercase(adjustl(lhs))
      ! OK, so now let's try to make sense of the lhs
      ! Note the necessary type conversions for some variables
      ! that aren't chracter-valued
      select case (lhs)
      case ('checkpaths')
        lhs = merge( 'true ', 'false', checkpaths )
      case ('chunknumber')
        call writeIntsToChars ( currentChunkNumber, lhs )
      case ('phasename')
        lhs = currentPhaseName
      case ('sips_version')
        lhs = merge( 'true ', 'false', sips_version )
      case ('need_l1bfiles')
        lhs = merge( 'true ', 'false', need_l1bfiles )
      case default
        ! What the devil did you mean?
        ! Maybe just whether two character strings are the same
        ! that were assembled using m4 trickery
      end select
      bvalue = (lhs == rhs)
      if ( reverse ) bvalue = .not. bvalue  ! If we meant not equal
    end function myBooleanValue
d1479 1
a1479 1
    use INIT_TABLES_MODULE, only: F_BOOLEAN
d1517 3
a1519 4
        if ( verbose ) then
          call output( trim(booleanString) // ' = ', advance='no' )
          call output( skip, advance='yes' )
        endif
d1523 4
d1539 65
d1607 1
a1607 1
       "$Id: DumpCommand_m.f90,v 2.70 2012/04/20 01:29:56 vsnyder Exp $"
d1617 3
@


2.70
log
@Add call to Finish before stopping
@
text
@d608 6
a613 4
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: BOOLEANVALUE, NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & SWITCHDETAIL
    use MLSSTRINGS, only: LOWERCASE
d657 1
a657 1
        tvalue = BooleanValue (formula, runTimeValues%lkeys, runTimeValues%lvalues)
d671 57
d749 2
a750 2
    use INIT_TABLES_MODULE, only: F_ALLBOOLEANS, F_ALLFILES, F_ALLFORWARDMODELS, &
      & F_ALLGRIDDEDDATA, F_ALLHESSIANS, F_ALLHGRIDS, &
d754 1
a754 1
      & F_BOOLEAN, F_CALLSTACK, F_CLEAN, F_CRASHBURN, &
d759 2
a760 1
      & F_POINTINGGRIDS, F_QUANTITY, F_SIGNALS,  F_SPECTROSCOPY, F_STOP, &
d774 1
d924 1
d930 3
a932 2
        & f_callStack, f_crashBurn, f_DACSfilterShapes, f_filterShapes, f_igrf, &
        & f_MieTables, f_pfaFiles, f_pfaStru, f_pointingGrids, &
d1049 2
d1068 2
d1599 1
a1599 1
       "$Id: DumpCommand_m.f90,v 2.69 2012/04/20 01:03:30 pwagner Exp $"
d1609 3
@


2.69
log
@May dump callStack from within l2cf
@
text
@d729 1
d987 4
a990 3
              NEVERCRASH = .false.
              call MLSMessage( MLSMSG_CRASH, moduleName, &
                & "Program stopped by /crashBurn field on DUMP statement.")
d1006 1
d1532 1
a1532 1
       "$Id: DumpCommand_m.f90,v 2.68 2012/03/28 23:14:14 vsnyder Exp $"
d1542 3
@


2.68
log
@Pass options to Dump_GH, add 'c' to options if /clean appears
@
text
@d695 2
a696 1
      & F_BOOLEAN, F_CLEAN, F_CRASHBURN, F_DETAILS, F_DACSFILTERSHAPES, &
d867 3
a869 2
        & f_crashBurn, f_DACSfilterShapes, f_filterShapes, f_igrf, f_MieTables, &
        & f_pfaFiles, f_pfaStru, f_pointingGrids, f_stop, f_stopWithError )
d983 2
d1529 1
a1529 1
       "$Id: DumpCommand_m.f90,v 2.67 2012/03/15 22:50:39 vsnyder Exp $"
d1539 3
@


2.67
log
@Add IGRF dump
@
text
@d990 1
a990 1
            call dump_gh ( details )
d1025 1
d1525 1
a1525 1
       "$Id: DumpCommand_m.f90,v 2.66 2012/02/28 00:16:42 vsnyder Exp $"
d1535 3
@


2.66
log
@Repair %S, which was referencing cpu_time without it being assigned a value
@
text
@d689 1
d697 4
a700 4
      & F_HGRID, F_L2PC, F_LINES, F_MARK, F_MASK, F_MATRIX, F_MIETABLES, &
      & F_OPTIONS, F_PFADATA, F_PFAFILES, F_PFANUM, F_PFASTRU, F_POINTINGGRIDS, &
      & F_QUANTITY, F_SIGNALS,  F_SPECTROSCOPY, F_STOP, F_STOPWITHERROR, &
      & F_SURFACE, F_TEMPLATE, F_TEXT, F_TGRID, &
d866 1
a866 1
        & f_crashBurn, f_DACSfilterShapes, f_filterShapes, f_MieTables, &
d989 2
d1524 1
a1524 1
       "$Id: DumpCommand_m.f90,v 2.65 2012/02/02 00:56:00 pwagner Exp $"
d1534 3
@


2.65
log
@Fix bug in Diffing matrices
@
text
@d291 1
a291 1
    elseif ( len_trim(message) < 1 ) then
d432 1
a432 1
    elseif( index('<>=', trim(op)) < 1 ) then
d1000 1
a1000 1
            elseif( parallel%slave ) then
d1156 1
a1156 1
          endif
d1164 1
a1164 1
              elseif ( index(optionsString, '2') > 0 ) then
d1176 1
a1176 1
          elseif ( fieldIndex == f_mask ) then
d1185 1
a1185 1
            
d1190 1
a1190 1
            elseif ( index(optionsString, '1') > 0 ) then
d1193 1
a1193 1
            elseif ( index(optionsString, '0') > 0 ) then
d1210 1
a1210 1
            endif
d1215 1
a1215 1
            elseif ( GotFirst ) then
d1221 1
a1221 1
            endif
d1291 1
a1295 1
              call cpu_time ( cpuTime )
d1350 1
a1350 1
              write ( tempText, * ) cpuTime - cpuTimeBase
d1521 1
a1521 1
       "$Id: DumpCommand_m.f90,v 2.64 2011/11/04 00:29:28 pwagner Exp $"
d1531 3
@


2.64
log
@:Fixed something only NAg complained about when Matrices not associated yet
@
text
@d1211 5
a1215 1
            if ( DiffOrDump == s_diff ) then
a1220 4
            else
              call getFromMatrixDatabase ( &
                & matrixDatabase(matrixIndex), matrix )
              call dump ( Matrix, details=details )
d1226 1
d1521 1
a1521 1
       "$Id: DumpCommand_m.f90,v 2.63 2011/08/29 22:12:13 pwagner Exp $"
d1531 3
@


2.63
log
@Should not attempt to take size of disassociated pointer HessianDataBase
@
text
@d835 1
d1520 1
a1520 1
       "$Id: DumpCommand_m.f90,v 2.62 2011/06/02 19:25:01 pwagner Exp $"
d1530 3
@


2.62
log
@May dump allRadiometers
@
text
@d837 3
a839 1
    if ( HaveHessians ) HaveHessians = size(HessianDatabase) > 0
d1403 2
a1404 2
      use MoreTree, only: StartErrorMessage
      use Output_m, only: NewLine
d1519 1
a1519 1
       "$Id: DumpCommand_m.f90,v 2.61 2011/05/09 18:08:57 pwagner Exp $"
d1529 3
@


2.61
log
@Print notice of changed runtime booleans only when "bool" switch is set
@
text
@d691 2
a692 2
      & F_ALLL2PCS, F_ALLLINES, F_ALLMATRICES, &
      & F_ALLPFA, F_ALLQUANTITYTEMPLATES, F_ALLSIGNALS, F_ALLSPECTRA, &
d715 1
a715 1
    use MLSSIGNALS_M, only: DUMP, SIGNALS
d799 2
a800 1
    integer, parameter :: NoSignals = noQT + 1
d859 2
a860 1
        & f_allPFA, f_allQuantityTemplates, f_allSignals, f_allSpectra, &
d925 24
d1426 2
d1517 1
a1517 1
       "$Id: DumpCommand_m.f90,v 2.60 2011/04/20 16:47:54 pwagner Exp $"
d1527 3
@


2.60
log
@Added BooleanFromEmptyGrid
@
text
@d40 8
a47 8
    use Allocate_Deallocate, only: DEALLOCATE_TEST
    use ConstructQuantityTemplates, only: AnyGoodSignalData
    use Chunks_m, only: MLSCHUNK_T
    use Dump_0, only: Dump
    use INIT_TABLES_MODULE, only: F_SIGNAL, F_Boolean
    use MLSCommon, only: MLSFile_T
    use MLSL2Options, only: runTimeValues
    use MLSSignals_m, only: GetSignalName, &
d49 6
a54 6
    use MLSStringLists, only: NumStringElements, PutHashElement, &
      & SwitchDetail
    use MLSStrings, only: lowerCase
    use output_m, only: output
    use Parse_signal_m, only: Parse_signal
    use String_Table, only: get_string
d77 1
d79 1
d104 1
a104 1
      if ( switchDetail(switches, 'bool') > 0 ) &
d111 1
a111 1
        if ( switchDetail(switches, 'bool') > 0 ) then
d120 1
a120 1
          if ( switchDetail(switches, 'bool') > 0 ) then
d142 1
a142 1
    use Dump_0, only: Dump
d144 8
a151 8
      & F_QUANTITY, F_Boolean, F_STATUS
    use ManipulateVectorQuantities, only: AnyGoodDataInQty
    use MLSCommon, only: rv
    use MLSL2Options, only: runTimeValues
    use MLSStringLists, only: NumStringElements, PutHashElement, &
      & SwitchDetail
    use MLSStrings, only: lowerCase
    use String_Table, only: get_string
d154 2
a155 2
    use VectorsModule, only: Vector_T, VectorValue_T, &
      & GetVectorQtyByTemplateIndex
d178 1
d180 1
d227 1
a227 1
    if ( switchDetail(switches, 'bool') > 0 ) &
d239 1
a239 1
    use Dump_0, only: Dump
d241 7
a247 7
    use MLSL2Options, only: runTimeValues
    use MLSMessageModule, only: MLSMessageInquire
    use MLSStringLists, only: NumStringElements, PutHashElement, &
      & SwitchDetail
    use MLSStrings, only: lowerCase
    use OUTPUT_M, only: outputNamedValue
    use String_Table, only: get_string
d309 11
a319 11
    use Dump_0, only: Dump
    use Expr_M, only: EXPR
    use INIT_TABLES_MODULE, only: F_A, F_B, F_C, F_Boolean, F_FORMULA
    use MLSCommon, only: r8, rv, DEFAULTUNDEFINEDVALUE
    use MLSL2Options, only: runTimeValues
    use MLSMessageModule, only: MLSMessage, MLSMessageCalls, MLSMSG_error
    use MLSStats1, only: mlsmax, mlsmin, mlsmean, mlsmedian
    use MLSStringLists, only: GetStringElement, NumStringElements, PutHashElement, &
      & ReplaceSubString, SwitchDetail
    use MLSStrings, only: lowerCase
    use String_Table, only: get_string
d322 2
a323 2
    use VectorsModule, only: Vector_T, VectorValue_T, M_Fill, &
      & GetVectorQtyByTemplateIndex
d362 1
d364 1
d475 1
a475 1
    if ( switchDetail(switches, 'bool') > 0 ) &
d538 1
a538 1
    use Dump_0, only: Dump
d540 6
a545 6
    use GriddedData, only: GRIDDEDDATA_T
    use MLSL2Options, only: runTimeValues
    use MLSStringLists, only: NumStringElements, PutHashElement, &
      & SwitchDetail
    use MLSStrings, only: lowerCase
    use String_Table, only: get_string
d564 1
d566 1
d590 1
a590 1
    if ( switchDetail(switches, 'bool') > 0 ) &
d604 2
a605 2
    use Dump_0, only: Dump
    use Expr_M, only: EXPR
d607 6
a612 6
    use MLSCommon, only: r8
    use MLSL2Options, only: runTimeValues
    use MLSStringLists, only: BooleanValue, NumStringElements, PutHashElement, &
      & SwitchDetail
    use MLSStrings, only: lowerCase
    use String_Table, only: get_string
d631 1
d633 1
d666 1
a666 1
    if ( switchDetail(switches, 'bool') > 0 ) &
d678 23
a700 23
    use AntennaPatterns_m, only: Dump_Antenna_Patterns_Database
    use Calendar, only: Duration_Formatted, Time_T, TK
    use Declaration_table, only: Num_Value
    use Dump_0, only: Diff, Dump, rmsFormat
    use Expr_m, only: Expr
    use FilterShapes_m, only: Dump_Filter_Shapes_Database, &
      & Dump_DACS_Filter_Database
    use ForwardModelConfig, only: Dump, ForwardModelConfig_T
    use GriddedData, only: Diff, Dump, GriddedData_T
    use HessianModule_1, only: Hessian_T, Diff, Dump
    use HGridsDatabase, only: Dump, HGRID_T
    use Init_Tables_Module, only: F_AllBooleans, F_AllFiles, F_AllForwardModels, &
      & F_AllGriddedData, F_AllHessians, F_AllHGrids, &
      & F_AllL2PCs, F_AllLines, F_AllMatrices, &
      & F_AllPFA, F_AllQuantityTemplates, F_AllSignals, F_AllSpectra, &
      & F_AllVectors, F_AllVectorTemplates, F_AllVGrids, F_AntennaPatterns, &
      & F_Boolean, F_Clean, F_CrashBurn, F_Details, F_DACSFilterShapes, &
      & F_File, F_FilterShapes, F_ForwardModel, F_GRID, F_HEIGHT, F_HESSIAN, &
      & F_HGrid, F_L2PC, F_Lines, F_Mark, F_Mask, F_MATRIX, F_MieTables, &
      & F_OPTIONS, F_PfaData, F_PfaFiles, F_PFANum, F_PFAStru, F_PointingGrids, &
      & F_Quantity, F_Signals,  F_Spectroscopy, F_Stop, F_StopWithError, &
      & F_SURFACE, F_Template, F_Text, F_TGrid, &
      & F_Vector, F_VectorMask, F_VGrid, &
d702 3
a704 3
    use L2ParInfo, only: PARALLEL, CLOSEPARALLEL
    use L2PC_m, only: L2PCDatabase, dumpL2PC => Dump
    use Intrinsic, only: PHYQ_Dimensionless
d706 4
a709 4
    use MatrixModule_1, only: Matrix_T, Matrix_Database_T, &
      & Diff, Dump, GetFromMatrixDatabase
    use MLSCommon, only: MLSFile_T
    use MLSFiles, only: DumpMLSFile => Dump, GetMLSFileByName
d711 24
a734 24
    use MLSL2Options, only: NORMAL_EXIT_STATUS, RUNTIMEVALUES
    use MLSMessageModule, only: MLSMessage, MLSMessageCalls, MLSMessageExit, &
      & MLSMSG_CRASH, MLSMSG_ERROR, MLSMSG_WARNING
    use MLSSets, only: FindFirst
    use MLSSignals_m, only: Dump, Signals
    use MLSStrings, only: INDEXES, LOWERCASE
    use MLSStringLists, only: BooleanValue, SWITCHDETAIL
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
    use output_m, only: output, outputNamedValue
    use PFADataBase_m, only: Dump, Dump_PFADataBase, Dump_PFAFileDataBase, &
      & Dump_PFAStructure, PFAData
    use PointingGrid_m, only: Dump_Pointing_Grid_Database
    use QuantityTemplates, only: Dump, QuantityTemplate_T
    use Read_Mie_m, only: Dump_Mie
    use SpectroscopyCatalog_m, only: Catalog, Dump, Dump_Lines_Database, Lines
    use String_Table, only: Get_String
    use Toggles, only: Gen, Switches, Toggle
    use Trace_m, only: Trace_begin, Trace_end
    use Tree, only: Decoration, Node_Id, Nsons, Source_Ref, Sub_rosa, Subtree
    use Tree_Types, only: N_Spec_Args
    use VectorsModule, only: Vector_T, VectorTemplate_T, VectorValue_T, &
      & Diff, Dump, DumpQuantityMask, DumpVectorMask, & ! for vectors, vector quantities and templates
      & GetVectorQtyByTemplateIndex
    use VGridsDatabase, only: Dump, VGrids
a778 1
    integer :: surface  ! We will use this to dump just one surface
d1424 1
a1424 1
    ! Returns value of Boolean field;
d1426 15
a1440 11
    use Init_Tables_Module, only: F_Boolean
    use MLSL2Options, only: runTimeValues
    use MLSMessageModule, only: MLSMessageCalls
    use MLSStringLists, only: BooleanValue
    use MLSStrings, only: lowerCase
    use MoreTree, only: Get_Field_ID
    use Output_M, only: Output
    use String_Table, only: Get_String
    use Toggles, only: Gen, Toggle
    use Trace_m, only: Trace_begin, Trace_end
    use Tree, only: Nsons, Sub_rosa, Subtree
d1447 1
d1449 1
d1455 1
a1464 1
        call output( trim(booleanString) // ' = ', advance='no' )
d1467 4
a1470 3
        call output( skip, advance='yes' )
        if ( skip ) &
          & call output( '(Skipping rest of this section)', advance='yes' )
d1474 2
d1489 1
a1489 1
       "$Id: DumpCommand_m.f90,v 2.59 2011/04/13 00:26:17 pwagner Exp $"
d1499 3
@


2.59
log
@options='' works how comments and wiki says it does for vect.qty
@
text
@d16 1
a16 1
! (Should these latter functions be moved into a special module?)
d25 1
d530 57
d685 1
a685 1
      & F_File, F_FilterShapes, F_ForwardModel, F_GRID, F_HESSIAN, &
d689 1
a689 1
      & F_Template, F_Text, F_TGrid, &
d700 1
d754 1
d769 1
d873 1
a873 1
              call dump ( griddedDataBase, details )
d1033 1
d1036 1
a1036 1
                & griddedDataBase(vectorIndex), details )
d1043 7
a1074 25
      case ( f_matrix ) ! Diff or Dump matrices
        if ( details < -1 ) cycle
        if ( haveMatrices ) then
          do i = 2, nsons(son)
            gson = subtree(i,son)
            if ( gotFirst ) then
              matrixIndex2 = decoration(decoration(gson))
            else
              matrixIndex = decoration(decoration(gson))
            endif
            if ( DiffOrDump == s_diff ) then
              call getFromMatrixDatabase ( &
                & matrixDatabase(matrixIndex), matrix )
              call getFromMatrixDatabase ( &
                & matrixDatabase(matrixIndex2), matrix2 )
              call diff ( Matrix, Matrix2, details=details )
            else
              call getFromMatrixDatabase ( &
                & matrixDatabase(matrixIndex), matrix )
              call dump ( Matrix, details=details )
            endif
          end do
        else
          call announceError ( gson, 0, 'Unable to dump matrix here; db empty or absent' )
        end if
d1163 25
d1471 1
a1471 1
       "$Id: DumpCommand_m.f90,v 2.58 2011/04/04 23:07:21 pwagner Exp $"
d1481 3
@


2.58
log
@May diff just quantity mask
@
text
@d1111 1
a1111 1
            elseif ( index(optionsString, '2') > 0 ) then
d1402 1
a1402 1
       "$Id: DumpCommand_m.f90,v 2.57 2011/03/15 23:02:45 pwagner Exp $"
d1412 3
@


2.57
log
@Dump qty with options 0, 1, or 2 to choose template, values, or mask
@
text
@d1082 4
d1100 1
a1100 1
            ! '0' menas dump template
d1402 1
a1402 1
       "$Id: DumpCommand_m.f90,v 2.56 2011/03/08 18:28:06 pwagner Exp $"
d1412 3
@


2.56
log
@May optionally diff, dump just values of vectorqtys
@
text
@d644 1
a644 1
      & MLSMSG_CRASH, MLSMSG_ERROR
d647 1
a647 1
    use MLSStrings, only: lowerCase
d1094 6
d1101 4
a1104 1
            if ( index(optionsString, '1') > 0 ) then
d1107 2
d1110 1
a1110 2
              call dump ( qty1, details=details, &
                & vector=vectors(vectorIndex), options=optionsString )
d1398 1
a1398 1
       "$Id: DumpCommand_m.f90,v 2.55 2010/11/19 23:59:23 pwagner Exp $"
d1408 3
@


2.55
log
@Passes options string to Hessians diff
@
text
@d613 1
a613 1
    use Dump_0, only: Dump, rmsFormat
d662 1
a662 1
    use VectorsModule, only: Vector_T, VectorTemplate_T, &
d706 1
d1067 2
d1072 2
d1077 12
a1088 7
            if ( gotFirst ) &
              & call diff ( &
              & GetVectorQtyByTemplateIndex( &
              & vectors(vectorIndex), quantityIndex), &
              & GetVectorQtyByTemplateIndex( &
              & vectors(vectorIndex2), quantityIndex2), &
              & options=optionsString )
d1095 7
a1101 3
            call dump ( GetVectorQtyByTemplateIndex( &
              & vectors(vectorIndex), quantityIndex), details=details, &
              & vector=vectors(vectorIndex), options=optionsString )
d1388 1
a1388 1
       "$Id: DumpCommand_m.f90,v 2.54 2010/11/05 22:37:06 pwagner Exp $"
d1398 3
@


2.54
log
@Pass optionsString to dumps of L2PC, Hessians
@
text
@d995 2
a996 1
                &         HessianDatabase(hessianIndex2), details=details )
d1374 1
a1374 1
       "$Id: DumpCommand_m.f90,v 2.53 2010/08/13 22:08:57 pwagner Exp $"
d1384 3
@


2.53
log
@May diff hessians, matrices
@
text
@d818 1
a818 1
              call dump ( HessianDataBase, details )
d829 1
a829 1
            call dumpL2PC( L2PCDataBase, details )
d997 2
a998 1
              call dump ( HessianDatabase(hessianIndex), details=details )
d1049 1
a1049 1
        call dumpL2PC ( fileDataBase(fileIndex), details )
d1373 1
a1373 1
       "$Id: DumpCommand_m.f90,v 2.52 2010/08/06 23:08:48 pwagner Exp $"
d1383 3
@


2.52
log
@Pass Hessians, matrices to DumpCommand
@
text
@d619 1
a619 1
    use HessianModule_1, only: Hessian_T, Dump
d639 1
a639 1
      & Dump, GetFromMatrixDatabase
d695 2
d698 3
d711 1
a714 1
    integer :: Type     ! of the Details expr -- has to be num_value
d980 1
a980 1
      case ( f_hessian ) ! Dump hessian
d984 15
a998 4
            call dump ( & ! The decoration is the negative of the index; see Fill, where
                          ! the Hessian spec is processed.
                          ! Well, that's a nasty trick.
              & HessianDatabase(-decoration(decoration(subtree(i,son)))), details=details )
d1003 1
a1003 1
      case ( f_matrix ) ! Dump hessian
d1007 17
a1023 3
            call getFromMatrixDatabase ( &
              & matrixDatabase(decoration(decoration(subtree(i,son)))), matrix )
            call dump ( Matrix, details=details )
d1372 1
a1372 1
       "$Id: DumpCommand_m.f90,v 2.51 2010/04/17 01:44:26 vsnyder Exp $"
d1382 3
@


2.51
log
@Add details to DumpL2PC calls, spiff up an error message
@
text
@d606 1
a606 1
    & FileDataBase )
d619 1
d622 2
a623 1
      & F_AllGriddedData, F_AllHGrids, F_AllL2PCs, F_AllLines, &
d627 2
a628 2
      & F_File, F_FilterShapes, F_ForwardModel, F_GRID, &
      & F_HGrid, F_L2PC, F_Lines, F_Mark, F_Mask, F_MieTables, &
d638 2
d676 2
d693 3
a695 1
      &        HaveForwardModelConfigs, HaveGriddedData, HaveHGrids
d757 4
d781 1
a781 1
        & f_allHGrids, f_allL2PCs, f_allLines, &
d810 7
d831 7
d975 23
d1276 3
d1342 1
a1342 1
       "$Id: DumpCommand_m.f90,v 2.50 2010/04/16 01:39:34 vsnyder Exp $"
d1352 3
@


2.50
log
@Added /allFiles and file fields to dump file database
@
text
@d805 1
a805 1
            call dumpL2PC( L2PCDataBase )
d905 1
a905 1
              call announceError ( gson, noFile )
d969 1
a969 2
        call dumpL2PC ( &
          & fileDataBase(fileIndex), details )
d1187 1
a1187 1
    subroutine AnnounceError ( where, what )
d1192 1
d1200 1
a1200 1
        call output ( "File not in database." )
d1290 1
a1290 1
       "$Id: DumpCommand_m.f90,v 2.49 2010/02/04 23:12:44 vsnyder Exp $"
d1300 3
@


2.49
log
@Remove USE or declaration for unreferenced names
@
text
@d620 2
a621 2
    use Init_Tables_Module, only: F_AllBooleans, F_AllForwardModels, &
      & f_AllGriddedData, F_AllHGrids, F_AllL2PCs, F_AllLines, &
d625 1
a625 1
      & F_FilterShapes, F_ForwardModel, F_GRID, &
d636 2
a638 2
    use MLSCommon, only: MLSFile_T
    ! use MLSFiles, only: DumpMLSFile => Dump
d689 1
d708 3
a710 1
    integer, parameter :: NoFWM = dimless + 1
d768 2
a769 2
      case ( f_allBooleans, f_allForwardModels, f_allGriddedData, &
        & f_allHGrids, f_allLines, &
d779 6
d896 15
d1199 4
d1290 1
a1290 1
       "$Id: DumpCommand_m.f90,v 2.48 2009/11/02 21:22:25 pwagner Exp $"
d1300 3
@


2.49.2.1
log
@Can Read GEOS5.7.2 meteorology; based on v3.33
@
text
@a24 1
  public :: BooleanFromEmptyGrid
a528 59
  ! ------------------------------------- BooleanFromEmptyGrid --
  function BooleanFromEmptyGrid ( root, grids ) result(thesize)
    use DUMP_0, only: DUMP
    use INIT_TABLES_MODULE, only: F_BOOLEAN, F_GRID
    use GRIDDEDDATA, only: GRIDDEDDATA_T
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & SWITCHDETAIL
    use MLSSTRINGS, only: LOWERCASE
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: SWITCHES
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
    ! Dummy args
    ! integer, intent(in) :: name
    integer, intent(in) :: root
    type (GRIDDEDDATA_T), dimension(:), pointer :: Grids
    integer             :: thesize
    ! Internal variables
    logical, parameter :: countEmpty = .true.
    integer :: field
    integer :: field_index
    integer :: fieldValue
    type (GRIDDEDDATA_T), pointer :: grid
    integer :: keyNo
    character(len=32) :: nameString
    integer :: son
    logical :: tvalue
    integer :: value
    logical :: verbose
    ! Executable
    verbose = ( switchDetail(switches, 'bool') > -1 )
    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      value = subtree(2,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
      field_index = decoration(field)

      select case ( field_index )
      case ( f_Boolean )
        call get_string( sub_rosa(subtree(2,son)), nameString )
      case ( f_grid ) 
        grid => grids ( decoration ( decoration ( value ) ) )
      end select
    end do
    tvalue = .true.
    if ( associated(grid) ) tvalue = grid%empty
    call PutHashElement ( runTimeValues%lkeys, runTimeValues%lvalues, &
      & lowercase(trim(nameString)), tvalue, countEmpty=countEmpty )
    thesize = NumStringElements( runTimeValues%lkeys, countEmpty=countEmpty )
    if ( verbose ) &
      & call dump( countEmpty, runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'Run-time Boolean flags' )
  end function BooleanFromEmptyGrid

d1262 1
a1262 1
       "$Id: DumpCommand_m.f90,v 2.49 2010/02/04 23:12:44 vsnyder Exp $"
a1271 3
! Revision 2.49  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
@


2.48
log
@May diff grided data
@
text
@d636 1
a636 1
    use MLSL2Options, only: NORMAL_EXIT_STATUS, RUNTIMEVALUES, STOPWITHERROR
d640 1
a640 1
      & MLSMSG_CRASH, MLSMSG_ERROR, MLSMSG_INFO
d1262 1
a1262 1
       "$Id: DumpCommand_m.f90,v 2.47 2009/10/27 22:18:18 pwagner Exp $"
d1272 3
@


2.47
log
@Implemented new Diff command; so far only of vector quantities
@
text
@d613 1
a613 1
    use Dump_0, only: Dump
d618 1
a618 1
    use GriddedData, only: Dump, GriddedData_T
d897 1
a897 1
      case ( f_Grid )    ! Dump Griddeddata
d901 19
a919 3
            call output ( ' GriddedData: ' )
            call dump ( &
              & griddedDataBase(decoration(decoration(subtree(i,son)))), details )
d924 1
d955 1
a955 1
      case ( f_mask, f_quantity ) ! Dump vector quantities
d967 1
d975 1
d1262 1
a1262 1
       "$Id: DumpCommand_m.f90,v 2.46 2009/09/15 20:03:48 pwagner Exp $"
d1272 3
@


2.46
log
@Dump commands take boolean fields /stop, /stopWithError, /crashBurn
@
text
@d627 1
a627 1
      & F_PfaData, F_PfaFiles, F_PFANum, F_PFAStru, F_PointingGrids, &
d630 2
a631 1
      & F_Vector, F_VectorMask, F_VGrid, S_Quantity, S_VectorTemplate
d646 1
a646 1
    use output_m, only: output !, outputNamedValue
d658 3
a660 2
    use VectorsModule, only: Dump, DumpQuantityMask, DumpVectorMask, & ! for vectors, vector quantities and templates
      & GetVectorQtyByTemplateIndex, Vector_T, VectorTemplate_T
d680 1
d683 1
d689 1
d691 1
d699 1
d725 6
d755 1
d757 1
d942 16
a957 3
          vectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          if ( fieldIndex == f_mask ) then
d961 1
d964 1
a964 1
              & vector=vectors(vectorIndex), clean=clean )
d967 5
d1243 1
a1243 1
       "$Id: DumpCommand_m.f90,v 2.45 2009/06/23 18:46:18 pwagner Exp $"
d1253 3
@


2.45
log
@Prevent Intel from optimizing ident string away
@
text
@d624 1
a624 1
      & F_Boolean, F_Clean, F_Details, F_DACSFilterShapes, &
d628 1
a628 1
      & F_Quantity, F_Signals,  F_Spectroscopy, F_Stop, &
d631 1
d634 2
a635 1
    use MLSL2Options, only: runTimeValues
d638 2
a639 1
    use MLSMessageModule, only: MLSMessage, MLSMessageCalls, MLSMSG_error
d754 2
a755 2
        & f_DACSfilterShapes, f_filterShapes, f_MieTables, &
        & f_pfaFiles, f_pfaStru, f_pointingGrids, f_stop )
d825 4
d842 14
a855 5
            call announceError ( son, stop )
            if ( index(switches,'erh') > 0 ) &
              & call mlsmessage (MLSMSG_Error, moduleName, &
                & "Program stopped by /stop field on DUMP statement." )
            stop
d1209 1
a1209 1
       "$Id: read_apriori.f90 is it here $"
d1219 3
@


2.44
log
@May now dump an l2pc or allL2PCs (use with caution)
@
text
@d1190 1
a1191 1
!---------------------------- RCS Ident Info -------------------------------
d1193 2
a1194 3
       "$Id: DumpCommand_m.f90,v 2.43 2008/09/30 22:00:22 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1196 1
a1196 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1198 1
d1203 3
@


2.43
log
@Add PRINT statement to Not_Used_Here to reduce compilation cascades
@
text
@d18 1
a18 1
  implicit NONE
d605 2
a606 1
    & VectorTemplates, Vectors, ForwardModelConfigs, HGrids, griddedDataBase )
d621 2
a622 2
      & f_AllGriddedData, F_AllHGrids, &
      & F_AllLines, F_AllPFA, F_AllQuantityTemplates, F_AllSignals, F_AllSpectra, &
d626 1
a626 1
      & F_HGrid, F_Lines, F_Mark, F_Mask, F_MieTables, &
d631 1
d634 2
d637 1
d642 1
a642 1
    use Output_M, only: Output
d666 1
d676 1
d681 1
a740 20
    ! We have to parse the line twice: once merely to pick up the details.
    ! This results in using the last details field.  Van prefers to process
    ! left-to-right to allow different details levels for different dumps.
!     do j = 2, nsons(root)
!       son = subtree(j,root) ! The argument
!       fieldIndex = get_field_id(son)
!       gson = son
!       if (nsons(son) > 1) gson = subtree(2,son) ! Now value of said argument
!       select case ( fieldIndex )
!       case ( f_details )
!         call expr ( gson, units, values, type )
!         if ( units(1) /= phyq_dimensionless ) call AnnounceError ( gson, dimless )
!         if ( type /= num_value ) call announceError ( gson, numeric )
!         details = nint(values(1))
!       case default
!         ! We'll do these on the next traveral
!       end select
!     end do

    ! then the second time to do the actual dumps
d777 2
d888 11
d1193 1
a1193 1
       "$Id: DumpCommand_m.f90,v 2.42 2008/06/05 02:07:43 vsnyder Exp $"
d1203 3
@


2.42
log
@Dump Mie tables
@
text
@d112 1
a112 1
        endif
d120 1
a120 1
          endif
d122 1
a122 1
        endif
d128 1
a128 1
    endif
d293 1
a293 1
    endif
d428 1
a428 1
    endif
d442 1
a442 1
      endif
d454 1
a454 1
      endif
d512 1
a512 1
      endif
d570 1
a570 1
    endif
d706 1
a706 1
    endif
d726 1
a726 1
    elseif ( DetailReduction == 0 ) then ! By default, reduce details level by 2
d728 1
a728 1
    endif
d919 1
a919 1
          endif
d1072 1
a1072 1
            endif
d1090 1
a1090 1
    endif
d1160 1
a1160 1
    endif
d1183 1
a1183 1
      endif
d1192 1
a1192 1
       "$Id: DumpCommand_m.f90,v 2.41 2007/12/07 01:12:43 pwagner Exp $"
d1196 1
d1202 3
@


2.41
log
@Lets us catch warnings and assign to runtime Booleans
@
text
@d625 1
a625 1
      & F_HGrid, F_Lines, F_Mark, F_Mask, &
d642 1
d763 2
a764 2
        & f_DACSfilterShapes, f_filterShapes, f_pfaFiles, f_pfaStru, &
        & f_pointingGrids, f_stop )
d836 2
a905 12
      case ( f_pfaData )
        do i = 2, nsons(son)
          look = decoration(decoration(subtree(i,son)))
          call dump ( pfaData(look), details, look )
        end do
      case ( f_pfaNum )
        do i = 2, nsons(son)
          call expr ( subtree(i,son), units, values, type )
          if ( units(1) /= phyq_dimensionless ) call AnnounceError ( subtree(i,son), dimless )
          if ( type /= num_value ) call announceError ( subtree(i,son), numeric )
          call dump ( pfaData(nint(values(1))), details, nint(values(1)) )
        end do
d921 12
d1192 1
a1192 1
       "$Id: DumpCommand_m.f90,v 2.40 2007/11/15 22:54:51 pwagner Exp $"
d1201 3
@


2.40
log
@Functions to set runtimeBooleans moved here
@
text
@d23 1
d227 75
d1189 1
a1189 1
       "$Id: DumpCommand_m.f90,v 2.39 2007/11/05 18:36:44 pwagner Exp $"
d1198 3
@


2.39
log
@May Skip remaining lines in Fill, Join, Retrieve sections depending on Boolean
@
text
@d14 3
a16 1
! Process a "dump" command. Or say whether to "skip" remainder of section
d21 4
d35 493
d1061 2
a1062 2
    use MLSMessageModule, only: MLSMessage, MLSMessageCalls, MLSMSG_error
    use MLSStringLists, only: BooleanValue, SWITCHDETAIL
d1064 1
a1064 1
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
d1067 1
a1067 1
    use Toggles, only: Gen, Switches, Toggle
d1069 1
a1069 1
    use Tree, only: Decoration, Node_Id, Nsons, Source_Ref, Sub_rosa, Subtree
d1113 1
a1113 1
       "$Id: DumpCommand_m.f90,v 2.38 2007/10/09 00:32:05 pwagner Exp $"
d1122 3
@


2.38
log
@Added ability to dump masks of quantities, vectors
@
text
@d14 1
a14 1
! Process a "dump" command.
d19 1
a19 1
  public :: DumpCommand
d278 1
a278 1
        tvalue = BooleanValue ( lowercase(booleanString), &
d556 52
d614 1
a614 1
       "$Id: DumpCommand_m.f90,v 2.37 2007/10/03 23:53:05 vsnyder Exp $"
d623 3
@


2.37
log
@Stop with error if /stop and switch 'erh' is set
@
text
@d50 5
a54 4
      & F_HGrid, F_Lines, F_Mark, F_PfaData, F_PfaFiles, F_PFANum, F_PFAStru, &
      & F_PointingGrids, F_Quantity, F_Signals,  F_Spectroscopy, F_Stop, &
      & F_Template, F_Text, F_TGrid, F_Vector, F_VGrid, S_Quantity, &
      & S_VectorTemplate
d73 1
a73 1
    use VectorsModule, only: Dump, & ! for vectors, vector quantities and templates
d340 1
a340 1
      case ( f_quantity ) ! Dump vector quantities
d346 8
a353 3
          call dump ( GetVectorQtyByTemplateIndex( &
            & vectors(vectorIndex), quantityIndex), details=details, &
            & vector=vectors(vectorIndex), clean=clean )
d483 1
a483 1
      case ( f_vector ) ! Dump entire vectors
d488 7
a494 2
            call dump ( vectors(decoration(decoration(subtree(i,son)))), &
              & details=details, clean=clean )
d562 1
a562 1
       "$Id: DumpCommand_m.f90,v 2.36 2007/08/17 00:32:16 pwagner Exp $"
d571 3
@


2.36
log
@Unneeded changes
@
text
@d56 1
a56 1
    use MLSMessageModule, only: MLSMessageCalls
d267 3
d551 1
a551 1
       "$Id: DumpCommand_m.f90,v 2.35 2007/04/03 17:37:17 vsnyder Exp $"
d560 3
@


2.35
log
@Check Vectors for zero size instead of associated
@
text
@d56 1
a56 1
!   use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d125 5
a129 2
    if ( toggle(gen) ) call trace_begin ( 'DumpCommand', root )

d494 5
a498 1
    if ( toggle(gen) ) call trace_end ( 'DumpCommand' )
d548 1
a548 1
       "$Id: DumpCommand_m.f90,v 2.34 2007/01/11 20:44:55 vsnyder Exp $"
d557 3
@


2.34
log
@Add Tracing
@
text
@d81 1
a81 1
    type (vector_T), dimension(:), pointer, optional             :: Vectors
d134 1
a134 1
    if ( haveVectors ) haveVectors = associated(Vectors)
d541 1
a541 1
       "$Id: DumpCommand_m.f90,v 2.33 2006/09/21 18:48:33 pwagner Exp $"
d550 3
@


2.33
log
@Reduce level of dumps in SIDS version
@
text
@d68 2
a69 1
    use Toggles, only: Switches
d125 2
d295 2
a296 2
            call output ( ' GriddedData ' )
            call dump ( & ! has no details switch
d491 2
d541 1
a541 1
       "$Id: DumpCommand_m.f90,v 2.32 2006/07/27 03:52:41 vsnyder Exp $"
d550 3
@


2.32
log
@Pass details to dumps for vectors and vector templates
@
text
@d59 1
a59 1
    use MLSStringLists, only: BooleanValue
d68 1
d89 1
d139 7
d148 1
a148 1
    details = 0
d194 1
d213 1
d222 1
d229 1
d232 1
d239 1
d277 1
a277 1
        details = nint(values(1))
d279 1
d289 1
d300 1
d331 1
d353 1
d463 1
d469 1
d480 1
d536 1
a536 1
       "$Id: DumpCommand_m.f90,v 2.31 2006/07/19 22:26:40 vsnyder Exp $"
d545 3
@


2.31
log
@Comment out unused USE
@
text
@d220 1
a220 1
              call dump ( vectors )
d226 1
a226 1
              call dump ( vectorTemplates )
d513 1
a513 1
       "$Id: DumpCommand_m.f90,v 2.30 2006/06/12 16:28:25 pwagner Exp $"
d522 3
@


2.30
log
@Added ability to dump Gridded Data
@
text
@d56 1
a56 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d513 1
a513 1
       "$Id: DumpCommand_m.f90,v 2.29 2006/05/31 22:38:17 vsnyder Exp $"
d522 3
@


2.29
log
@Revert to details= semantics that Van prefers
@
text
@d30 1
a30 1
    & VectorTemplates, Vectors, ForwardModelConfigs, HGrids )
d42 1
d44 2
a45 1
    use Init_Tables_Module, only: F_AllBooleans, F_AllForwardModels, F_AllHGrids, &
d49 1
a49 1
      & F_FilterShapes, F_ForwardModel, &
d76 1
a76 3
    type (quantityTemplate_t), dimension(:), pointer, optional :: QuantityTemplatesDB
    type (vectorTemplate_T), dimension(:), pointer, optional :: VectorTemplates
    type (vector_T), dimension(:), pointer, optional :: Vectors
d78 4
a81 1
    type (HGrid_T), dimension(:), pointer, optional :: HGrids
d93 1
a93 1
      &        HaveForwardModelConfigs, HaveHGrids
d110 2
a111 1
    integer, parameter :: NoHGrid = NoFWM + 1
d135 2
d167 2
a168 1
      case ( f_allBooleans, f_allForwardModels, f_allHGrids, f_allLines, &
d184 6
d272 10
d480 2
d513 1
a513 1
       "$Id: DumpCommand_m.f90,v 2.28 2006/05/03 20:14:05 pwagner Exp $"
d522 3
@


2.28
log
@details and /stop properly implemented
@
text
@d46 2
a47 1
      & F_Boolean, F_Details, F_DACSFilterShapes, F_FilterShapes, F_ForwardModel, &
d81 1
a90 1
    logical :: mustStop
d132 1
a133 1
    mustStop = .false.
d135 18
a152 18
    ! We have to parse the line twice: once merely to pick up the details
    do j = 2, nsons(root)
      son = subtree(j,root) ! The argument
      fieldIndex = get_field_id(son)
      gson = son
      if (nsons(son) > 1) gson = subtree(2,son) ! Now value of said argument
      select case ( fieldIndex )
      case ( f_details )
        call expr ( gson, units, values, type )
        if ( units(1) /= phyq_dimensionless ) call AnnounceError ( gson, dimless )
        if ( type /= num_value ) call announceError ( gson, numeric )
        details = nint(values(1))
      case ( f_stop )
        mustStop = get_boolean(son)
      case default
        ! We'll do these on the next traveral
      end select
    enddo
d243 2
d296 1
a296 1
            & vector=vectors(vectorIndex) )
d428 2
a429 1
            call dump ( vectors(decoration(decoration(subtree(i,son)))), details=details )
a439 2
      if ( mustStop ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Stopping after Dump command with /stop argument' )
d488 1
a488 1
       "$Id: DumpCommand_m.f90,v 2.27 2006/03/22 02:19:48 vsnyder Exp $"
d497 3
@


2.27
log
@Add Vector argument to quantity dump to get its name
@
text
@d53 1
a53 1
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
d57 1
d89 1
d132 22
d157 1
d333 3
d436 2
d486 1
a486 1
       "$Id: DumpCommand_m.f90,v 2.26 2006/03/07 16:23:52 pwagner Exp $"
d495 3
@


2.26
log
@Fixed bug only NAG caught
@
text
@d267 2
a268 1
            & vectors(vectorIndex), quantityIndex), details=details )
d456 1
a456 1
       "$Id: DumpCommand_m.f90,v 2.25 2006/03/07 00:49:42 pwagner Exp $"
d465 3
@


2.25
log
@May dump Booleans
@
text
@d37 1
d455 1
a455 1
       "$Id: DumpCommand_m.f90,v 2.24 2006/01/04 01:21:30 vsnyder Exp $"
d464 3
@


2.24
log
@Make optional arguments pointers, in case actuals aren't associated
@
text
@d42 2
a43 2
    use Init_Tables_Module, only: F_AllForwardModels, F_AllHGrids, F_AllLines, &
      & F_AllPFA, F_AllQuantityTemplates, F_AllSignals, F_AllSpectra, &
d45 2
a46 2
      & F_Details, F_DACSFilterShapes, F_FilterShapes, F_ForwardModel, F_HGrid, &
      & F_Lines, F_Mark, F_PfaData, F_PfaFiles, F_PFANum, F_PFAStru, &
d51 1
d54 2
d77 2
d93 1
d134 3
a136 3
      case ( f_allForwardModels, f_allHGrids, f_allLines, f_allPFA, &
        & f_allQuantityTemplates, f_allSignals, f_allSpectra, f_allVectors, &
        & f_allVectorTemplates, f_allVGrids, f_antennaPatterns, &
d141 3
d209 7
d454 1
a454 1
       "$Id: DumpCommand_m.f90,v 2.23 2005/06/03 02:06:55 vsnyder Exp $"
d463 3
@


2.23
log
@New copyright notice, move Id to not_used_here to avoid cascades,
get VGrids from VGridsDatabase instead of an argument, add dumps for
PFA structure, PFA datum by number.
@
text
@d68 3
a70 3
    type (quantityTemplate_t), dimension(:), intent(in), optional :: QuantityTemplatesDB
    type (vectorTemplate_T), dimension(:), intent(in), optional :: VectorTemplates
    type (vector_T), dimension(:), intent(in), optional :: Vectors
d72 1
a72 1
    type (HGrid_T), dimension(:), intent(in), optional :: HGrids
d80 2
d108 14
d136 1
a136 1
            if ( present(forwardModelConfigs) ) then
d142 1
a142 1
            if ( present(hGrids) ) then
d156 1
a156 1
            if ( present(quantityTemplatesDB) ) then
d170 1
a170 1
            if ( present(vectors) ) then
d176 1
a176 1
            if ( present(vectorTemplates) ) then
d206 1
a206 1
        if ( present(forwardModelConfigs) ) then
d215 1
a215 1
        if ( present(hGrids) ) then
d272 1
a272 1
            if ( present(quantityTemplatesDB) ) then
d279 1
a279 1
            if ( present(vectorTemplates) ) then
d376 1
a376 1
        if ( present(vectors) ) then
d438 1
a438 1
       "$Id: DumpCommand_m.f90,v 2.22 2005/05/02 23:11:37 vsnyder Exp $"
d447 5
@


2.22
log
@Add dump of PFAFiles database
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a21 3
  character (len=*), private, parameter :: IdParm = &
       "$Id: DumpCommand_m.f90,v 2.21 2005/04/01 20:48:28 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
d30 1
a30 1
    & VectorTemplates, Vectors, ForwardModelConfigs, HGrids, VGrids )
d46 4
a49 3
      & F_Lines, F_Mark, F_PfaData, F_PfaFiles, F_PointingGrids, F_Quantity, &
      & F_Signals,  F_Spectroscopy, F_Stop, F_Template, F_Text, F_TGrid, &
      & F_Vector, F_VGrid, S_Quantity, S_VectorTemplate
d54 2
a55 1
    use PFADataBase_m, only: Dump, Dump_PFADataBase, Dump_PFAFileDataBase, PFAData
d64 1
a64 1
    use VGridsDatabase, only: Dump, VGrid_T
a72 1
    type (VGrid_T), dimension(:), pointer, optional :: VGrids
d101 1
a101 2
    integer, parameter :: NoVG = noVectors + 1
    integer, parameter :: NoVT = noVG + 1
d115 2
a116 2
        & f_DACSfilterShapes, f_filterShapes, f_pfaFiles, f_pointingGrids, &
        & f_stop )
d166 1
a166 5
            if ( present(vGrids) ) then
              call dump ( vGrids )
            else
              call announceError ( son, noVG )
            end if
d175 2
d221 7
d355 4
a358 8
        if ( present(vGrids) ) then
          do i = 2, nsons(son)
            call output ( ' TGrid ' )
            call dump ( vGRids(decoration(decoration(subtree(i,son)))), details=details )
          end do
        else
          call announceError ( gson, noTG )
        end if
d369 4
a372 8
        if ( present(vGrids) ) then
          do i = 2, nsons(son)
            call output ( ' VGrid ' )
            call dump ( vGRids(decoration(decoration(subtree(i,son)))), details=details )
          end do
        else
          call announceError ( gson, noVG )
        end if
d388 1
a388 1
        call output ( "The details field is not unitless." )
a402 2
      case ( noVG )
        call output ( "Can't dump VGrids here." )
d406 1
a406 1
        call output ( "The details field is not numeric." )
d420 5
d431 3
@


2.21
log
@Add mark and text fields to dump command
@
text
@d15 1
a15 1
       "$Id: DumpCommand_m.f90,v 2.20 2005/03/26 01:34:00 vsnyder Exp $"
d41 3
a43 3
      & F_Lines, F_Mark, F_PfaData, F_PointingGrids, F_Quantity, F_Signals, &
      & F_Spectroscopy, F_Stop, F_Template, F_Text, F_TGrid, F_Vector, F_VGrid, &
      & S_Quantity, S_VectorTemplate
d48 1
a48 1
    use PFADataBase_m, only: Dump, Dump_PFADataBase, PFAData
d110 2
a111 1
        & f_DACSfilterShapes, f_filterShapes, f_pointingGrids, f_stop )
d172 2
d426 3
@


2.20
log
@Add stop message
@
text
@d15 1
a15 1
       "$Id: DumpCommand_m.f90,v 2.19 2005/03/15 01:36:08 vsnyder Exp $"
d30 1
d41 3
a43 3
      & F_Lines, F_PfaData, F_PointingGrids, F_Quantity, F_Signals, F_Spectroscopy, &
      & F_Stop, F_Template, F_TGrid, F_Vector, F_VGrid, S_Quantity, &
      & S_VectorTemplate
d52 2
a53 1
    use Tree, only: Decoration, Node_Id, Nsons, Subtree
d68 2
d72 2
a73 1
    integer :: GSON, I, J, Look
d76 4
d208 2
d258 83
d423 3
@


2.19
log
@Add newline after error messages
@
text
@d15 1
a15 1
       "$Id: DumpCommand_m.f90,v 2.18 2005/01/12 03:18:51 vsnyder Exp $"
d89 2
a90 1
    integer, parameter :: Unknown = numeric + 1 ! Unknown template
d165 1
d310 2
d329 3
@


2.18
log
@Add item number to PFA dump
@
text
@d15 1
a15 1
       "$Id: DumpCommand_m.f90,v 2.17 2004/12/28 00:22:03 vsnyder Exp $"
d279 1
d311 1
d325 3
@


2.17
log
@Add not_used_here
@
text
@d15 1
a15 1
       "$Id: DumpCommand_m.f90,v 2.16 2004/12/13 20:13:04 vsnyder Exp $"
d199 2
a200 1
          call dump ( pfaData(decoration(decoration(subtree(i,son)))), details )
d323 3
@


2.16
log
@Add dumps for AllLines, ALlSignals, AllSpectra, Lines, Signals, Spectroscopy,
and a Stop command.
@
text
@a12 1

d15 1
a15 1
       "$Id: DumpCommand_m.f90,v 2.15 2004/11/04 06:37:34 vsnyder Exp $"
d19 1
a28 5
  ! The fields can be Quantity to dump a vector quantity, Vector to dump an
  ! entire vector, Template to dump a quantity template or vector template,
  ! ForwardModel to dump a forward model config, or Details to specify
  ! the level of detail for subsequent dumps.

d313 6
d322 4
@


2.15
log
@Index spetroscopy catalog by molecule instead of searching
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.14 2004/11/01 20:16:20 vsnyder Exp $"
d41 7
a47 6
    use Init_Tables_Module, only: F_AllForwardModels, F_AllHGrids, F_AllPFA, &
      & F_AllQuantityTemplates, F_AllVectors, F_AllVectorTemplates, &
      & F_AllVGrids, F_AntennaPatterns, F_Details, F_DACSFilterShapes, &
      & F_FilterShapes, F_ForwardModel, F_HGrid, F_PfaData, &
      & F_PointingGrids, F_Quantity, F_Spectroscopy, F_Template, F_TGrid, &
      & F_Vector, F_VGrid, S_Quantity, S_VectorTemplate
d50 1
d55 1
a55 1
    use SpectroscopyCatalog_m, only: Catalog, Dump
d86 4
a89 2
    integer, parameter :: NoQT = noHGrid + 1
    integer, parameter :: NoTG = noQT + 1
d102 4
a105 3
      case ( f_allForwardModels, f_allHGrids, f_allPFA, f_allQuantityTemplates, &
        & f_allVectors, f_allVectorTemplates, f_allVGrids, f_antennaPatterns, &
        & f_DACSfilterShapes, f_filterShapes, f_pointingGrids, f_spectroscopy )
d120 6
d134 8
d168 2
a169 2
          case ( f_spectroscopy )
            call dump ( catalog, details=details )
d196 6
d214 12
d295 2
d299 2
d321 3
@


2.14
log
@Check for spectroscopy catalog before trying to dump it
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.13 2004/10/30 00:26:46 vsnyder Exp $"
d85 1
a85 2
    integer, parameter :: NoSpec = noQT + 1
    integer, parameter :: NoTG = NoSpec + 1
d150 1
a150 5
            if ( associated(catalog) ) then
              call dump ( catalog, details=details )
            else
              call announceError ( son, noSpec )
            end if
a259 2
      case ( noSpec )
        call output ( "Can't dump spectroscopy database here." )
d280 3
@


2.13
log
@Add 'spectroscopy' field to DumpCommand
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.12 2004/10/06 20:19:39 vsnyder Exp $"
d85 2
a86 1
    integer, parameter :: NoTG = noQT + 1
d151 5
a155 1
            call dump ( catalog, details=details )
d265 2
d287 3
@


2.12
log
@Cannonball polishing
@
text
@d16 2
a17 2
       "$Id: DumpCommand_m.f90,v 2.11 2004/09/24 22:24:20 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d45 2
a46 2
      & F_PointingGrids, F_Quantity, F_Template, F_TGrid, F_Vector, &
      & F_VGrid, S_Quantity, S_VectorTemplate
d53 1
d100 1
a100 1
        & f_DACSfilterShapes, f_filterShapes, f_pointingGrids )
d149 2
d280 3
@


2.11
log
@Make PFA dump aware of 'details' switch
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.10 2004/07/17 02:28:19 vsnyder Exp $"
a175 1
          call output ( ' PFA Data' )
d277 3
@


2.10
log
@Add dump for entire PFA database
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.9 2004/06/12 00:41:30 vsnyder Exp $"
d177 1
a177 1
          call dump ( pfaData(decoration(decoration(subtree(i,son)))) )
d278 3
@


2.9
log
@Allow all fields except details to be arrays
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.8 2004/06/09 19:59:38 pwagner Exp $"
d41 1
a41 1
    use Init_Tables_Module, only: F_AllForwardModels, F_AllHGrids, &
d50 1
a50 1
    use PFADataBase_m, only: Dump, PFAData
d97 1
a97 1
      case ( f_allForwardModels, f_allHGrids, f_allQuantityTemplates, &
d114 2
d278 3
@


2.8
log
@Gets PFAData type and dump method from PFADataBase_m
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.7 2004/06/08 20:20:18 vsnyder Exp $"
d70 1
a70 1
    integer :: GSON, J, Look
d153 1
a153 1
      case ( f_forwardModel ) ! Dump a forward model config
d155 4
a158 2
          what = decoration(decoration(gson))
          call dump ( forwardModelConfigs(what) ) ! has no details switch
d162 1
a162 1
      case ( f_hGrid )    ! Dump an HGrid
d164 5
a168 3
          what = decoration(decoration(gson))
          call output ( ' HGrid ' )
          call dump ( hGrids(what) ) ! has no details switch
d173 35
a207 27
        call output ( ' PFA Data' )
        call dump ( pfaData(decoration(decoration(gson))) )
      case ( f_quantity ) ! Dump a vector quantity
        vectorIndex = decoration(decoration(subtree(1,gson)))
        quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        call dump ( GetVectorQtyByTemplateIndex( &
          & vectors(vectorIndex), quantityIndex), details=details )
      case ( f_template ) ! Dump a vector template or a quantity template
        look = decoration(gson)
        if ( node_id(look) /= n_spec_args ) call announceError ( gson, unknown )
        what = decoration(look)
        select case ( get_spec_id(look) )
        case ( s_quantity )
          if ( present(quantityTemplatesDB) ) then
            call output ( ' Quantity template' )
            call dump ( quantityTemplatesDB(what), details=details )
          else
            call announceError ( gson, noQT )
          end if
        case ( s_vectorTemplate )
          if ( present(vectorTemplates) ) then
            call output ( ' Vector template' )
            call dump ( vectorTemplates(what), details=details, quantities=quantityTemplatesDB )
          else
            call announceError ( gson, noVT )
          end if
        end select
d210 4
a213 2
          call output ( ' TGrid ' )
          call dump ( vGRids(decoration(decoration(gson))), details=details )
d217 1
a217 1
      case ( f_vector ) ! Dump an entire vector
d219 4
a222 2
          call output ( ' Vector ' )
          call dump ( vectors(decoration(decoration(gson))), details=details )
d228 4
a231 2
          call output ( ' VGrid ' )
          call dump ( vGRids(decoration(decoration(gson))), details=details )
d276 3
@


2.7
log
@Add tGrid
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.6 2004/05/29 02:50:49 vsnyder Exp $"
d50 1
a50 1
    use PFAData_m, only: Dump, PFAData
d258 3
@


2.6
log
@Added more dumps
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.5 2004/05/22 02:31:23 vsnyder Exp $"
d45 2
a46 2
      & F_PointingGrids, F_Quantity, F_Template, F_Vector, F_VGrid, &
      & S_Quantity, S_VectorTemplate
d84 2
a85 1
    integer, parameter :: NoVectors = noQT + 1
d196 7
d238 2
d258 3
@


2.5
log
@Dump PFAData, VGrids
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.4 2004/05/20 19:47:36 vsnyder Exp $"
d34 1
d37 2
d41 5
a45 2
    use Init_Tables_Module, only: F_Details, F_ForwardModel, F_HGrid, &
      & F_PfaData, F_Quantity, F_Template, F_Vector, F_VGrid, &
d48 1
a48 1
    use MoreTree, only: Get_Field_ID, Get_Spec_ID
d51 1
d64 1
a64 1
    type (forwardModelConfig_t), dimension(:), intent(in), optional :: ForwardModelConfigs
d66 1
a66 1
    type (VGrid_T), dimension(:), intent(in), optional :: VGrids
d72 1
d92 3
a94 3
      gson = subtree(j,root) ! The argument
      fieldIndex = get_field_id(gson)
      if (nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
d96 51
d150 1
a150 1
        if ( type /= num_value ) call AnnounceError ( gson, numeric )
d168 1
a168 1
        call output ( ' PFA Data', advance='yes' )
d248 3
@


2.4
log
@Move Dump*Hgrid from Dumper to HgridsDatabse
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.3 2004/05/18 01:18:51 vsnyder Exp $"
d25 1
a25 1
    & VectorTemplates, Vectors, ForwardModelConfigs, HGrids )
d39 1
a39 1
      & F_Quantity, F_Template, F_Vector, &
d44 1
d50 1
d54 2
a55 2
    type (quantityTemplate_t), dimension(:), intent(in) :: QuantityTemplatesDB
    type (vectorTemplate_T), dimension(:), intent(in) :: VectorTemplates
d59 1
d75 5
a79 2
    integer, parameter :: NoVectors = noHGrid + 1
    integer, parameter :: Numeric = noVectors + 1
d108 3
d122 6
a127 2
          call output ( ' Quantity template' )
          call dump ( quantityTemplatesDB(what), details=details )
d129 6
a134 2
          call output ( ' Vector template' )
          call dump ( vectorTemplates(what), details=details, quantities=quantityTemplatesDB )
a137 1
          vectorIndex = decoration(decoration(gson))
d139 1
a139 1
          call dump ( vectors(vectorIndex), details=details )
d143 7
d156 2
a157 2
      use LEXER_CORE, only: PRINT_SOURCE
      use Tree, only: Source_Ref
d160 1
a160 6
      call output ( '***** At ' )
      if ( where > 0 ) then
        call print_source ( source_ref(where) )
      else
        call output ( '(no lcf tree available)' )
      end if
d169 2
d172 5
a176 1
        call output ( "Can't dump vectors here." )
d189 3
@


2.3
log
@Add dump for HGrid
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.2 2004/05/11 02:53:29 vsnyder Exp $"
a34 1
    use Dumper, only: Dump ! HGrid, Quantity templates
d37 1
a37 1
    use HGridsDatabase, only: HGRID_T
d165 3
@


2.2
log
@Remove USEs for unreferenced symbols
@
text
@d16 1
a16 1
       "$Id: DumpCommand_m.f90,v 2.1 2004/05/01 04:04:16 vsnyder Exp $"
d25 1
a25 1
    & VectorTemplates, Vectors, ForwardModelConfigs )
d38 3
a40 2
    use Init_Tables_Module, only: F_Details, F_ForwardModel, F_Quantity, &
      & F_Template, F_Vector, &
d57 1
d72 2
a73 1
    integer, parameter :: NoVectors = noFWM + 1
d88 1
a88 1
      case ( f_forwardModel )
d95 8
d132 1
d150 2
d160 1
d166 3
@


2.1
log
@Initial commit
@
text
@d16 1
a16 1
       "$Id: init_tables_module.f90,v 2.364 2004/04/16 00:48:40 livesey Exp $"
d19 1
a19 1
       "$RCSfile: init_tables_module.f90,v $"
a41 1
    use MLSMessageModule, only: MLSMSG_Error, MLSMessage
d48 1
a48 1
      & GetVectorQtyByTemplateIndex, Vector_T, VectorTemplate_T, VectorValue_T
d150 4
a153 1
! $Log: $
@

