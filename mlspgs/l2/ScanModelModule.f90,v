head	2.95;
access;
symbols
	v5-02-NRT-19:2.95
	v6-00:2.95
	v5-02-NRT-18:2.95
	v5-02:2.89.4.1
	v5-01-NRT-17:2.95
	v5-01-NRT-16:2.95
	v5-01-NRT-15:2.95
	v5-01-NRT-14:2.95
	neuralnetworks-1-0:2.95.0.4
	cfm-single-freq-0-1:2.95.0.2
	v5-01:2.89.4.1
	v5-00:2.89.4.1
	v4-23-TA133:2.94.0.2
	mus-emls-1-70:2.89.0.4
	rel-1-0-englocks-work:2.89.0.2
	VUMLS1-00:2.88
	VPL1-00:2.88
	V4-22-NRT-08:2.86
	VAM1-00:2.85
	V4-21:2.81.0.2
	V4-13:2.81
	V4-12:2.81
	V4-11:2.80
	V4-10:2.80
	V3-43:2.72
	M4-00:2.76
	V3-41:2.72
	V3-40-PlusGM57:2.72.0.2
	V2-24-NRT-04:2.70
	V3-33:2.72
	V2-24:2.70
	V3-31:2.72
	V3-30-NRT-05:2.72
	cfm-01-00:2.72
	V3-30:2.72
	V3-20:2.72
	V3-10:2.72
	V2-23-NRT-02:2.70
	V2-23:2.70
	V2-22-NRT-01:2.70
	V2-22:2.70
	V2-21:2.66
	V2-20:2.66
	V2-11:2.63
	V2-10:2.63
	V2-00:2.63
	V1-51:2.61
	V1-50:2.61
	V1-45:2.61
	V1-44:2.61
	V1-43:2.61
	V1-32:2.60
	V1-31:2.60
	V1-30:2.60
	V1-13:2.59
	V1-12:2.59
	V1-11:2.58
	V1-10:2.55
	newfwm-feb03:2.57.0.2
	V1-04:2.28
	V1-03:2.28
	V1-02:2.28
	JointForwardModel:2.39.0.2
	V1-00:2.28
	newfwm-sep01:2.24.0.2
	V0-7:2.24
	V0-5-Level2:2.16
	V0-5-SIPS:2.10;
locks; strict;
comment	@# @;


2.95
date	2020.05.15.21.33.41;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2018.12.13.01.45.28;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2018.12.04.23.22.33;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2018.11.30.00.13.28;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2018.11.01.00.43.21;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2018.10.30.20.59.14;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2017.08.10.22.44.12;	author pwagner;	state Exp;
branches
	2.89.4.1;
next	2.88;

2.88
date	2016.08.12.00.31.25;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2016.08.09.18.46.16;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2016.01.23.02.59.18;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2015.09.24.22.06.36;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2015.08.25.17.35.56;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2015.06.19.21.15.50;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2015.06.04.03.14.14;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2014.07.18.23.17.59;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2013.08.31.02.29.12;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2013.08.30.02.45.47;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2013.06.12.02.38.33;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2013.03.01.01.11.10;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2012.06.06.20.13.37;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2012.04.20.01.54.20;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2011.05.09.18.25.12;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2009.05.13.20.41.55;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2007.08.20.22.06.08;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2007.07.25.20.08.46;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2007.06.29.19.32.07;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2006.12.13.01.33.08;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2006.08.05.02.36.06;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2006.08.05.02.12.27;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2006.08.02.20.10.56;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2006.04.03.20.23.46;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2004.03.20.04.05.23;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2003.08.15.23.58.20;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2003.03.19.19.24.10;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2003.02.18.23.59.28;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2003.02.13.01.15.39;	author bill;	state Exp;
branches;
next	2.56;

2.56
date	2003.02.12.22.46.49;	author bill;	state Exp;
branches;
next	2.55;

2.55
date	2003.01.31.22.30.56;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2003.01.26.04.43.15;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2003.01.16.23.13.35;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2002.11.22.12.22.41;	author mjf;	state Exp;
branches;
next	2.51;

2.51
date	2002.10.25.22.24.54;	author livesey;	state Exp;
branches;
next	2.50;

2.50
date	2002.10.16.20.13.55;	author mjf;	state Exp;
branches;
next	2.49;

2.49
date	2002.10.08.17.36.22;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2002.09.27.01.47.45;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2002.09.27.00.01.16;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2002.09.26.23.48.21;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2002.09.26.20.38.19;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2002.06.27.00.20.43;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2002.06.27.00.19.26;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2002.06.26.23.37.27;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2002.06.26.23.29.52;	author bill;	state Exp;
branches;
next	2.40;

2.40
date	2002.06.26.20.59.25;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2002.06.26.19.18.53;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2002.06.26.18.44.12;	author bill;	state Exp;
branches;
next	2.37;

2.37
date	2002.06.26.01.26.10;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2002.06.25.22.17.09;	author bill;	state Exp;
branches;
next	2.35;

2.35
date	2002.06.25.21.55.49;	author bill;	state Exp;
branches;
next	2.34;

2.34
date	2002.06.25.17.03.30;	author bill;	state Exp;
branches;
next	2.33;

2.33
date	2002.06.25.14.55.15;	author bill;	state Exp;
branches;
next	2.32;

2.32
date	2002.06.25.00.01.32;	author bill;	state Exp;
branches;
next	2.31;

2.31
date	2002.06.24.18.27.02;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2002.06.24.17.55.41;	author bill;	state Exp;
branches;
next	2.29;

2.29
date	2002.06.05.00.00.29;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2002.02.13.00.08.58;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2001.12.06.23.44.57;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2001.11.03.01.33.47;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2001.10.02.16.49.56;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.06.29.23.03.28;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.06.19.22.43.23;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2001.06.04.22.42.36;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.05.10.00.46.49;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.05.09.17.43.44;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.05.08.19.43.57;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.05.08.03.05.05;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.05.05.00.03.30;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.05.04.05.41.26;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.05.04.05.05.46;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.05.03.23.42.57;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.05.03.23.09.52;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.05.03.20.34.08;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.21.00.52.24;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.10.22.27.47;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.03.19.03.07;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.20.21.43.41;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.15.23.31.15;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.07.22.42.38;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.06.00.34.54;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.05.01.20.26;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.28.17.35.36;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.28.17.34.51;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.22.00.37.50;	author livesey;	state Exp;
branches;
next	;

2.89.4.1
date	2019.02.01.18.52.51;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.95
log
@Fixed long-standing in sending basis boundaries
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module ScanModelModule          ! Scan model and associated calculations

  ! This module defines the `scan model' for the MLS Level 2 software.  It also
  ! contains functionality such as a pressure guesser etc, which may be useful
  ! for other programs.

  ! Note that currently the scan model is 1D, later versions will be two
  ! dimensional.  I will try to place comments in the code to indicate where 2D
  ! aware stuff needs to be placed.

  ! Also note that there is currently no height offset term in the state
  ! vector.  This was never used in UMLS V5, and so it is not clear that it
  ! will ever be required.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Constants, only: Deg2rad, Ln10, Pi
  use ForwardModelConfig, only: Forwardmodelconfig_T
  use ForwardModelIntermediate, only: Forwardmodelstatus_T
  use ForwardModelVectortools, only: Getquantityforforwardmodel
  use Geometry, only: EarthRadA, EarthRadB, EarthSurfaceGPH, GeodToGeocLat, &
    & G0, Gm, J2, J4, Omega => W
  use Init_Tables_Module, only: L_Refgph, L_Zeta
  use Intrinsic, only: L_Heightoffset, L_None, L_Ptan, L_Scanresidual, &
    & L_Temperature, L_Tngtgeocalt, L_Vmr, L_Phitan, L_Orbitinclination, &
    & Phyq_Length
  use ManipulateVectorQuantities, only: FindClosestInstances, &
    & Findinstancewindow
  use MatrixModule_0, only: DestroyBlock, MatrixElement_T, M_Absent, &
    & M_Full, UpdateDiagonal
  use MatrixModule_1, only: CreateBlock, FindBlock, Matrix_T, &
    & CreateEmptyMatrix, DestroyMatrix, ClearMatrix, RM
  use MLSKinds, only: R8, RP, RV
  use MLSMessagemodule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use MLSNumerics, Only : Hunt, InterpolateValues
  use MLSStringLists, only: SwitchDetail
  use Molecules, only: L_H2o
  use Output_M, only: Output
  use QuantityTemplates, only: Dump
  use Refraction_M, only: MaxRefraction, Refractive_Index, &
    & Refractive_Index_Deriv, Refractive_Index_F
  use Toggles, only: Emit, Toggle, Switches
  use Trace_M, only: Trace_Begin, Trace_End
  use VectorsModule, only: ValidateVectorquantity, &
    & Vector_T, VectorTemplate_T, VectorValue_T, CreateVector, &
    & ConstructVectorTemplate, DestroyVectorinfo

  implicit none

  private

  public :: DestroyForwardModelIntermediate, DumpInstanceWindows, &
    & GetBasisGPH, GetGPHPrecision, &
    & GetHydrostaticTangentPressure, Get2DHydrostaticTangentPressure,      &
    & ScanForwardModel, TwoDScanForwardModel

  type, private :: ForwardModelIntermediate_T

    ! These ones are for the scan model
    real (r8), dimension(:,:),             pointer :: BasisGph=>NULL()
    real (r8), dimension(:),               pointer :: R=>NULL()
    real (r8), dimension(:,:),             pointer :: RT=>NULL()
    integer :: BelowRef                 ! T. basis at or below refGPH

  end type ForwardModelIntermediate_T

  ! Workspace type stuff for the scan model
  type (ForwardModelIntermediate_T), private, save :: IFM

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: ScanModelModule.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! Define various constants etc.
  ! Some terms to do with refraction
  
  real (r8), parameter :: MaxPressure = 1400.0 ! /mb Don't allow very large pressures
  real (r8), parameter :: MinZeta = log10(maxPressure)

contains ! =============== Subroutines and functions ==========================

  ! -----------------------------  DestroyForwardModelIntemediate  -----
  subroutine DestroyForwardModelIntermediate

    ! Exectuable code

    call Deallocate_test ( ifm%basisGPH, 'basisGPH', ModuleName )
    call Deallocate_test ( ifm%RT, 'RT', ModuleName )
    call Deallocate_test ( ifm%R, 'R', ModuleName )

  end subroutine DestroyForwardModelIntermediate

  ! ----------------------------------------  DumpInstanceWindows  -----
    ! Dump the instance windows (e.g., in temperature) 
    ! that a 2d forward model must consider
    ! for the range of mafs [maf1, maf2]
  subroutine DumpInstanceWindows ( STATE, EXTRA, MAF1, MAF2, FMCONF, DETAILS )
    use Dump_0, only: Dump
    use ForwardModelConfig, only: Dump
    use MLSStrings, only: WriteIntsToChars
    use HighOutput, only: HeadLine, OutputNamedValue
    ! Args
    type (Vector_T), intent(in) :: STATE ! The state vector
    type (Vector_T), intent(in) :: EXTRA ! Other stuff in the state vector
    integer, intent(in)         :: MAF1
    integer, intent(in)         :: MAF2
    type (ForwardModelConfig_T), intent(in) :: FMCONF
    integer, intent(in)         :: DETAILS ! dump FMConf if > 0
    ! Internal variables
    character(len=4) :: CHARS
    character(len=16) :: HEADING
    integer :: INSTLOW
    integer :: INSTHIGH
    type (VectorValue_T), pointer :: PHITAN ! Phitan component of state
    type (VectorValue_T), pointer :: TEMP   ! Temperature component of state
    integer :: WINDOWSTART_T         ! first instance for temperature
    integer :: WINDOWFINISH_T        ! last instance for temperature
    ! Executable
    if ( fmConf%instrumentModule > 0 ) then
      phitan => getQuantityForForwardModel ( state, extra, &
        & quantityType=l_phitan, instrumentModule=fmConf%instrumentModule, &
        & config=fmConf )
    else
      phitan => getQuantityForForwardModel ( state, extra, &
        & quantityType=l_phitan, config=fmConf )
    end if
    temp => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_temperature, config=fmConf )
    call FindInstanceWindow( temp, phitan, maf1, FMConf%phiWindow, &
      & FMConf%windowUnits, windowstart_t, windowfinish_t )
    instLow = min( windowstart_t, windowfinish_t )
    instHigh = max( windowstart_t, windowfinish_t )
    call FindInstanceWindow( temp, phitan, maf2, FMConf%phiWindow, &
      & FMConf%windowUnits, windowstart_t, windowfinish_t )
    instLow = min( windowstart_t, instLow )
    instHigh = max( instHigh, windowfinish_t )
    call writeintstochars( maf1, chars )
    heading = adjustl(chars)
    call writeintstochars( maf2, chars )
    heading = trim(heading) // ',' // adjustl(chars)
    call headline( 'Instance Window for mafs in range: '// trim(heading), &
      & fillChar='-', before='*', after='*' )
    call dump( FMConf, details=details-1 )
    call outputNamedValue ( 'Instance Window', [ instLow, instHigh ] )
  end subroutine DumpInstanceWindows

  ! ------------------------------------------------  GetBasisGPH  -----
  subroutine GetBasisGPH ( temp, refGPH, gph, R, RT, belowRef )
    ! This function calculates gph based on
    ! temperature temp
    ! reference gph refgph
    !
    ! It also marks with FillValues any levels affected
    ! by FillValues among the Temperatures
    use Dump_0, only: Dump
    use HighOutput, only: OutputNamedValue
    use MLSCommon, only: UndefinedValue
    use MLSFillValues, only: IsFillValue
    use MLSFinds, only: FindFirst
    use Physics, only: Boltz
    use Trace_M, only: Trace_Begin, Trace_End

    ! Dummy arguments
    type (VectorValue_T), intent(IN) :: TEMP ! The temperature field
    type (VectorValue_T), intent(IN) :: REFGPH ! The reference gph field
    real (r8), dimension(:,:), intent(OUT) :: GPH ! Result (temp%noSurfs,temp%noInstances)
    real (r8), dimension(:), pointer, optional :: R ! Gas constant, noSurfs
    real (r8), dimension(:,:), pointer, optional :: RT ! R*T (noSurfs,noInstances)
    integer, intent(out), optional :: BELOWREF ! Level in temperature basis
  
    ! Some terms to do with the gas 'constant'

!    real (r8), parameter :: GASM0 = 25.34314957d-3 ! Constant
!    real (r8), parameter :: GASM1 = 2.89644d-3 ! Linear term
!    real (r8), parameter :: GASM2 = -0.579d-3 ! Quadratic term
!    real (r8), parameter :: GASR0 = 8.31441 ! `Standard' gas constant
    REAL(r8), parameter :: c_mass = 0.02_rp ! mass reduction coefficient
    REAL(r8), parameter :: basiscutoff = 2.5_rp ! zeta where mass reduction begins

    ! Local variables, many automatic arrays

    real (r8), dimension(:), pointer :: MYR      ! Gas constant, noSurfs
    real (r8), dimension(:,:), pointer :: MYRT   ! R*T (noSurfs,noInstances)

    real (r8), dimension(temp%template%noSurfs) :: LOGP ! -log10 pressure
    real (r8), dimension(temp%template%noSurfs) :: MODIFIEDBASIS ! noSurfs
    real (r8), dimension(temp%template%noInstances) :: CURRENTREFGPH ! From 1st calc
    real (r8), dimension(temp%template%noInstances) :: CORRECTION ! To apply to gph
    real (r8), dimension(temp%template%noInstances) :: DELTAGEOPOT ! noInstances

    integer :: Me = -1                  ! String index for trace cacheing

    integer :: MYBELOWREF               ! Result of a hunt
    real (r8) :: ABOVEREFWEIGHT         ! Interpolation weight
    
    integer :: INSTANCE                 ! Loop counter
    integer :: SURF                     ! Loop counter
    
!    real (r8) :: BASISCUTOFF            ! Threshold level for gas constant
    real (r8) :: REFLOGP                ! Log p of pressure reference surface
    real (r8) :: BASISGAP               ! Space between adjacent surfaces
    logical, parameter :: DEEBUG = .false.

    call trace_begin ( me, 'GetBasisGPH', cond=.false. )
    nullify ( myR, myRT )
    ! Check that we get the right kinds of quantities
    if ( ( .not. ValidateVectorQuantity( temp,&
      &            coherent=.true., &
      &            stacked=.true., &
      &            regular=.true., &
      &            verticalCoordinate=[ l_Zeta ]) ) .or. &
      &  ( .not. ValidateVectorQuantity( refGPH,&
      &            coherent=.true., &
      &            stacked=.true., &
      &            regular=.true., &
      &            verticalCoordinate=[ l_Zeta ]) ) ) &
      & call MLSMessage(MLSMSG_Error,ModuleName,&
        & 'Inappropriate temp/refGPH quantity' )

    ! Now allocate intermediate quantities
    call allocate_test ( myR, temp%template%noSurfs, 'myR', ModuleName )
    call allocate_test ( myRT, temp%template%noSurfs, &
      & temp%template%noInstances, 'myR', ModuleName )

    ! Now the main calculation. This is two parts.  First we compute a
    ! geopotential height grid with an arbitrary offset of H=0 at the lowest
    ! basis point.

    ! To do this we get a gas constant for all the temperature basis points
    logP= temp%template%surfs(:,1)

!    basisCutoff= -gasM1 / (2*gasM2) ! Set a threshold value
    modifiedBasis = max ( logP, basisCutoff ) ! Either logP or this threshold
!    myR = gasR0 / ( gasM0 + gasM1*modifiedBasis + gasM2*modifiedBasis**2 )
    myR = boltz * (1.0_r8 + c_mass*(modifiedBasis - basiscutoff)**2)   

    ! Compute R*T for each point, avoid spread intrinsic to save memory
    ! and cpu time.
    do instance = 1, temp%template%noInstances
      myRT(:,instance) = myR * temp%values(:,instance)
    end do

    gph(1,:) = 0.0
    do surf = 2, temp%template%noSurfs
!     deltaGeopot = (ln10/ (2*g0) ) * &
!         & ( myRT(surf,:) + myRT(surf-1,:) ) * &
!         & ( logP(surf) - logP(surf-1) )
      deltaGeopot = ( myRT(surf,:) + myRT(surf-1,:) ) * &
         & ( logP(surf) - logP(surf-1) ) / (2 * g0)
      gph(surf,:) = gph(surf-1,:) + deltaGeopot
    end do

    ! Now we need to correct for the reference geopotential, find the layer the
    ! reference surface is within.

    refLogP = refGPH%template%surfs(1,1)
    call Hunt ( logP, refLogP, myBelowRef )

    ! Get weights
    basisGap = logP(myBelowRef+1) - logP(myBelowRef)
    aboveRefWeight = ( refLogP - logP(myBelowRef) )/basisGap

    ! Forbid extrapolation
    aboveRefWeight = max ( min ( aboveRefWeight, 1.0D0 ), 0.0D0 )

    ! Get geopotential at the reference surface from our intermediate result
!    currentRefGPH = gph(myBelowRef,:) + ((basisGap*ln10)/(2*g0))* &
!      & ( myRT(myBelowRef,:) * aboveRefWeight * (2-aboveRefWeight) + &
!      &   myRT(myBelowRef+1,:) * (aboveRefWeight**2))
    currentRefGPH = gph(myBelowRef,:) + ((basisGap)/(2 * g0))* &
      & ( myRT(myBelowRef,:) * aboveRefWeight * (2-aboveRefWeight) + &
      &   myRT(myBelowRef+1,:) * (aboveRefWeight**2))

    ! Now make the correction, again avoid spread to save time/memory,
    ! Also convert to geopotential height.
    correction = refGPH%values(1,:) - currentRefGPH
    do surf = 1, temp%template%noSurfs         
       gph(surf,:) = gph(surf,:) + correction
    end do
    ! Put back intermediate data if wanted.
    if ( present(R) ) then
      R=>myR
    else
      call deallocate_test ( myR, 'myR', moduleName )
    end if

    if ( present(rt) ) then
      rt=>myRT
    else
      call deallocate_test ( myRT, 'myRT', moduleName )
    end if

    if ( present(belowRef) ) belowRef = myBelowRef
    if ( any(IsFillValue(temp%values) ) ) then
      if ( DEEBUG ) call outputNamedValue ( 'myBelowRef', myBelowRef )
      ! We will reset gph to FillValue for any ..
      do instance=1, temp%template%noInstances
        if ( DEEBUG ) call outputNamedValue ( 'instance', instance )
        if ( DEEBUG ) call dump( temp%values(:, instance), 'Temperatures' )
        ! heights above the 1st neg T starting at the refGPH and going up
        surf = FindFirst ( isFillValue(temp%values(myBelowRef:, instance) ) )
        if ( DEEBUG ) call outputNamedValue ( 'upper -999.99 surf', surf )
        if ( surf > 0 ) gph(myBelowRef+surf-1:,instance) = UndefinedValue
        ! heights below the 1st neg T starting at the refGPH and going down
        surf = FindFirst ( isFillValue(temp%values(myBelowRef:1:-1, instance) ) )
        if ( DEEBUG ) call outputNamedValue ( 'lower -999.99 surf', surf )
        if ( surf > 0 ) gph(myBelowRef-surf+1:1:-1,instance) = UndefinedValue
      enddo
    endif
         
    call trace_end ( 'GetBasisGPH', cond=.false. )
    ! That's it  
  end subroutine GetBasisGPH

  ! --------------------------------------------  GetGPHPrecision  -----
  subroutine GetGPHPrecision ( tempPrec, refGPHPrec, &
    & gphPrec )
    ! This function takes a state vector, containing one and only one
    ! temperature and reference geopotential height precisions, and
    ! returns the GPH precision.
    use HighOutput, only: OutputNamedValue
    use Physics, only: Boltz
    use Trace_M, only: Trace_Begin, Trace_End

    ! Dummy arguments
    type (VectorValue_T), intent(IN) :: TEMPPREC ! The temperature precision
                                                 ! field
    type (VectorValue_T), intent(IN) :: REFGPHPREC ! The reference gph
                                                   ! precision field
    real (r8), dimension(:,:), intent(OUT) :: GPHPREC ! Result (temp%noSurfs,temp%noInstances)
  
    ! Some terms to do with the gas 'constant'

!    real (r8), parameter :: GASM0 = 25.34314957d-3 ! Constant
!    real (r8), parameter :: GASM1 = 2.89644d-3 ! Linear term
!    real (r8), parameter :: GASM2 = -0.579d-3 ! Quadratic term
!    real (r8), parameter :: GASR0 = 8.31441 ! `Standard' gas constant
    real(r8), parameter :: c_mass = 0.02_rp ! mass reduction coefficient
    real(r8), parameter :: basiscutoff = 2.5_rp ! zeta where mass reduction begins

    ! Local variables, many automatic arrays

    real (r8), dimension(tempPrec%template%noSurfs) :: MYR ! Gas constant

    real (r8), dimension(tempPrec%template%noSurfs) :: LOGP ! -log10 pressure
    real (r8), dimension(tempPrec%template%noSurfs) :: MODIFIEDBASIS ! noSurfs
!   real (r8), dimension(tempPrec%template%noInstances) :: CURRENTREFGPH ! From 1st calc
!   real (r8), dimension(tempPrec%template%noInstances) :: CORRECTION ! To apply to gph

    ! The derivatives are effectively 1D at each instance
    real (r8), dimension(tempPrec%template%noSurfs, &
      & tempPrec%template%noSurfs, &
      & tempPrec%template%noInstances) :: DMyRT_dT   ! d(R*T)/dT
    real (r8), dimension(tempPrec%template%noSurfs, &
      & tempPrec%template%noInstances) :: DCurrentRefGPH_dT ! From 1st calc
    real (r8), dimension(tempPrec%template%noSurfs, &
      & tempPrec%template%noInstances) :: Dcorrection_dT ! To apply to dgph_dT
    real (r8), dimension(tempPrec%template%noSurfs, &
      & tempPrec%template%noInstances) :: DDeltaGeoPot_dT ! 
    real (r8), dimension(tempPrec%template%noSurfs, &
      & tempPrec%template%noSurfs, &
      & tempPrec%template%noInstances) :: DGPH_dT ! 
    real (r8), dimension(tempPrec%template%noSurfs, &
      & tempPrec%template%noInstances) :: DGPH_dRefGPH ! 

    real (r8), dimension(tempPrec%template%noSurfs, &
      & tempPrec%template%noInstances) :: GPHPrec2 ! squared PGH precision
    real (r8), dimension(tempPrec%template%noSurfs, &
      & tempPrec%template%noInstances) :: GPHPrec2a ! squared PGH precision (alt)
    ! We usee this next to avoid segment faulting due to bug in NAG compiler
    real (r8), dimension(tempPrec%template%noSurfs) :: TPrecVals ! T Precision

    integer :: Me = -1                  ! String index for trace cacheing

    integer :: MyBelowRef               ! Result of a hunt
    real (r8) :: AboveRefWeight         ! Interpolation weight
    
    integer :: Instance                 ! Loop counter
    integer :: Surf                     ! Loop counter
    
!    real (r8) :: BASISCUTOFF            ! Threshold level for gas constant
    real (r8) :: RefLogP                ! Log p of pressure reference surface
    real (r8) :: BasisGap               ! Space between adjacent surfaces
    integer, dimension( max(1,size(GPHPrec, 1)), max(1,size(GPHPrec, 2)) ) &
      &       :: ItsSign                ! < 0 if tempprec or refgphprec are
    integer, save :: TimesHere = 0
    logical :: DeeBug

    TimesHere = TimesHere + 1
    DeeBug = .false. ! ( TimesHere > 1 )
    if ( DeeBug ) call output( 'Now in GetGPHPrecision', advance='yes' )
    call trace_begin ( me, 'GetGPHPrecision', cond=.false. )
    ! Check that we get the right kinds of quantities
    if ( ( .not. ValidateVectorQuantity( tempPrec,&
      &            coherent=.true., &
      &            stacked=.true., &
      &            regular=.true., &
      &            verticalCoordinate=[ l_Zeta ]) ) .or. &
      &  ( .not. ValidateVectorQuantity( refGPHPrec,&
      &            coherent=.true., &
      &            stacked=.true., &
      &            regular=.true., &
      &            verticalCoordinate=[ l_Zeta ]) ) ) &
      & call MLSMessage(MLSMSG_Error,ModuleName,&
        & 'Inappropriate tempPrec/refGPHPrec quantity' )

    ! Now the main calculation. This is two parts.  First we compute a
    ! geopotential height grid with an arbitrary offset of H=0 at the lowest
    ! basis point.

    ! To do this we get a gas constant for all the temperature basis points
    if ( DeeBug )  then
      call Dump( tempPrec%template )
      call Dump( refGPHPrec%template )
      call output( 'Now the main calculation', advance='yes' )
    end if
    logP= tempPrec%template%surfs(:,1)

!    basisCutoff= -gasM1 / (2*gasM2) ! Set a threshold value
    modifiedBasis = max ( logP, basisCutoff ) ! Either logP or this threshold
!    myR = gasR0 / ( gasM0 + gasM1*modifiedBasis + gasM2*modifiedBasis**2 )
    myR = boltz * (1.0_r8 + c_mass*(modifiedBasis - basiscutoff)**2)   

    ! Compute T derivative of R*T for each point.
    dmyRT_dT = 0.0
    do surf = 1, tempPrec%template%noSurfs
      dmyRT_dT(surf,surf,:) = myR(surf)
    end do

    dgph_dT = 0.0
    do surf = 2, tempPrec%template%noSurfs
!       ddeltaGeopot_dT = (ln10/ (2*g0) ) * &
!         & ( dmyRT_dT(surf,:,:) + dmyRT_dT(surf-1,:,:) ) * &
!         & ( logP(surf) - logP(surf-1) )
       ddeltaGeopot_dT = ( dmyRT_dT(surf,:,:) + dmyRT_dT(surf-1,:,:) ) * &
         & ( logP(surf) - logP(surf-1) ) / (2 * g0)
       dgph_dT(surf,:,:) = dgph_dT(surf-1,:,:) + ddeltaGeopot_dT
    end do

    ! Now we need to correct for the reference geopotential, find the layer the
    ! reference surface is within.

    refLogP = refGPHPrec%template%surfs(1,1)
    call Hunt ( logP, refLogP, myBelowRef )

    ! Get weights
    basisGap = logP(myBelowRef+1) - logP(myBelowRef)
    aboveRefWeight = ( refLogP - logP(myBelowRef) )/basisGap

    ! Forbid extrapolation
    aboveRefWeight = max ( min ( aboveRefWeight, 1.0D0 ), 0.0D0 )

    ! Get derivative of the geopotential at the reference surface
    ! from our intermediate result
!    dcurrentRefGPH_dT = dgph_dT(myBelowRef,:,:) + ((basisGap*ln10)/(2*g0))* &
!      & ( dmyRT_dT(myBelowRef,:,:) * aboveRefWeight * (2-aboveRefWeight) + &
!      &   dmyRT_dT(myBelowRef+1,:,:) * (aboveRefWeight**2))
    dcurrentRefGPH_dT = dgph_dT(myBelowRef,:,:) + ((basisGap)/(2*g0))* &
      & ( dmyRT_dT(myBelowRef,:,:) * aboveRefWeight * (2-aboveRefWeight) + &
      &   dmyRT_dT(myBelowRef+1,:,:) * (aboveRefWeight**2))

    ! Now make the correction, again avoid spread to save time/memory,
    ! Also convert to geopotential height.
    dcorrection_dT = - dcurrentRefGPH_dT
    do surf = 1, tempPrec%template%noSurfs         
       dgph_dT(surf,:,:) = dgph_dT(surf,:,:) + dcorrection_dT
    end do

    ! The refGPH derivative is easy!
    dgph_drefGPH = 1.0
    if ( DeeBug ) then
      call output( 'Transform the Temp, refGPH precision to GPH precision', advance='yes' )
      call outputNamedValue ( 'shape(tempPrec)', shape(tempPrec%values) )
      call outputNamedValue ( 'shape(refGPHPrec)', shape(refGPHPrec%values) )
      call outputNamedValue ( 'shape(GPHPrec)', shape(GPHPrec) )
      call outputNamedValue ( 'shape(ITSSIGN)', shape(ITSSIGN) )
      call outputNamedValue ( 'shape(GPHPrec2)', shape(GPHPrec2) )
      call outputNamedValue ( 'shape(dgph_dT)', shape(dgph_dT) )
      call outputNamedValue ( 'shape(dgph_drefGPH)', shape(dgph_drefGPH) )
      call outputNamedValue ( 'noInstances', tempPrec%template%noInstances )
      call outputNamedValue ( 'noSurfs', tempPrec%template%noSurfs )
      call outputNamedValue ( 'myBelowRef', myBelowRef )
      call Dump( tempPrec%values, 'temperature precision' )
    end if
    !  Transform the temperature, refGPH precision to GPH precision
    GPHPrec2 = 0.0
    ItsSign  = 1
    do instance = 1, tempPrec%template%noInstances
      TPrecVals = tempPrec%values(:,instance)
      do surf = 1, tempPrec%template%noSurfs
        GPHPrec2(:,instance) = GPHPrec2(:,instance) + &
          & ( dgph_dT(:,surf,instance) * TPrecVals(surf) )**2
      end do
      GPHPrec2(:,instance) = GPHPrec2(:,instance) + &
        & ( dgph_drefGPH(:,instance) * refGPHPrec%values(1,instance) )**2
      if ( DeeBug ) then
        call outputnamedValue ( 'instance', instance )
        call outputnamedValue ( 'refGPHPrec%values(1,instance)', refGPHPrec%values(1,instance) )
        call outputnamedValue ( ' all( TPrecVals >= 0._rv',  all( TPrecVals >= 0._rv) )
      end if
      if ( refGPHPrec%values(1,instance) < 0._rv ) then
        ItsSign(:, instance) = -1
      else if ( all( TPrecVals >= 0._rv ) ) then
        ! ITSS already 1
      else if ( refGPHPrec%values(1,instance) >= 0._rv ) then
        if ( DeeBug ) then
          call outputnamedValue ( 'myBelowRef', myBelowRef )
          call outputnamedValue ( 'tempPrec%template%noSurfs', tempPrec%template%noSurfs )
          call outputnamedValue ( 'any( TPrecVals < 0._rv )', any( TPrecVals < 0._rv ) )
          call outputnamedValue ( 'shape( TPrecVals(myBelowRef:myBelowRef))', &
            & shape( TPrecVals(myBelowRef:myBelowRef)) )
        end if
        if ( any( TPrecVals < 0._rv ) ) then
          if ( DeeBug ) then
            call outputnamedValue( 'shape', shape(TPrecVals(1:myBelowRef)))
            call outputnamedValue( 'value', TPrecVals(1:myBelowRef))
          end if
          do surf = 1, myBelowRef
            ! if ( any( tempPrec%values(surf:myBelowRef, instance) < 0._rv ) ) &
            !    & ITSSIGN(surf, instance) = -1
            ITSSIGN(surf, instance) = sign ( 1.d0, minval(TPrecVals(surf:myBelowRef)) )
          end do
          do surf = myBelowRef+1, tempPrec%template%noSurfs
            if ( any( TPrecVals(myBelowRef:surf) < 0._rv ) ) &
              ITSSIGN(surf, instance) = -1
          end do
        end if
      else
        if ( DeeBug ) then
          call output( 'in else clause', advance='yes' )
          call outputnamedValue ( 'myBelowRef', myBelowRef )
          call outputnamedValue ( 'tempPrec%template%noSurfs', tempPrec%template%noSurfs )
        end if
        do surf = 1, tempPrec%template%noSurfs
          ! On which side of the reference surface are we?
          if ( surf < myBelowRef ) then
            if ( any( TPrecVals(surf:myBelowRef) < 0._rv ) ) &
              & ITSSIGN(surf, instance) = -1
          else if ( surf == myBelowRef ) then
            if ( TPrecVals(surf) < 0._rv ) &
              & ITSSIGN(surf, instance) = -1
          else if ( &
            & any( TPrecVals(myBelowRef:surf) < 0._rv ) ) then
            ITSSIGN(surf, instance) = -1
          end if
        end do
      end if
    end do

    ! if ( TimesHere > 1 ) then
    !  call output( '2nd time, so quitting', advance='yes' )
    !  stop
    ! end if
    if ( DeeBug ) call output( 'Finish the calculation', advance='yes' )
    do surf = 1, tempPrec%template%noSurfs
      GPHPrec2a(surf,:) = sum ( &
        & dgph_dT(surf,:,:) * tempPrec%values(:,:) * &
        & tempPrec%values(:,:) * dgph_dT(surf,:,:), &
        & dim=1 )
      GPHPrec2a(surf,:) = GPHPrec2a(surf,:) + &
        & dgph_drefGPH(surf,:) * refGPHPrec%values(1,:) * &
        & refGPHPrec%values(1,:) * dgph_drefGPH(surf,:)
    end do
    GPHPrec = ITSSIGN * sqrt ( GPHPrec2 )
     
    call trace_end ( 'GetGPHPrecision', cond=.false. )
    ! That's it  
  end subroutine GetGPHPrecision

  ! ----------------------------  Get2DHydroStaticTangentPressure  -----
  subroutine Get2DHydrostaticTangentPressure ( ptan, temp, refGPH, h2o, &
    & orbIncl, phiTan, geocAlt, maxIterations, phiWindow, phiWindowUnits, &
    & chunkNo )
    ! This is a new pressure guesser routine which works by simply running the
    ! new 2D scan model 'backwards'
    ! Dummy arguments

    use Dump_0, only: Dump
    use Output_M, only: Output
    use QuantityTemplates, only: QuantityTemplate_T

    type (VectorValue_T), intent(inout) :: PTAN ! Tangent pressure sv. component
    type (VectorValue_T), intent(in) :: Temp ! Temperature
    type (VectorValue_T), intent(in) :: RefGPH ! Reference GPH
    type (VectorValue_T), intent(in) :: H2O ! H2O
    type (VectorValue_T), intent(in) :: Orbincl ! Inclination
    type (VectorValue_T), intent(in) :: PhiTan ! Tangent phi
    type (VectorValue_T), intent(in) :: GeocAlt ! L1B Tp Geoc alt.
    integer, intent(IN) :: MaxIterations ! Number of iterations to use
    real(r8), intent(in) :: PhiWindow(2)   ! For 2D or not
    integer, intent(in) :: PhiWindowUnits
    integer, intent(in), optional :: ChunkNo

    ! Local parameters
    integer, parameter :: NoQtys = 8

    ! Local variables
    type (QuantityTemplate_T) :: ScanResidual ! Scan residual
    type (QuantityTemplate_T) :: MyQTs(NoQtys) ! All our quantities
    type (Vector_T) :: State            ! Gets ptan
    type (Vector_T) :: Extra            ! Gets temp,refGPH,h2o and geocAlt
    type (Vector_T) :: Residual         ! Gets the scan residual
    type (VectorTemplate_T) :: StateTemplate ! Gets ptan
    type (VectorTemplate_T) :: ExtraTemplate ! Gets temp,refGPH,h2o and geocAlt
    type (VectorTemplate_T) :: ResidualTemplate ! Gets the scan residual
    type (Matrix_T) :: Jacobian         ! dScanresidual/dPtan

    type (ForwardModelConfig_T) :: FMConf
    type (ForwardModelStatus_T) :: FMStat

    integer :: I                        ! Iteration counter
    integer :: MAF                      ! MAF counter
    integer :: Me = -1                  ! String index for trace
    real (r8), dimension(ptan%template%noSurfs, ptan%template%noInstances) :: &
      EARTHRADIUS ! Earth radius (minor frame)

    ! Executable code
    ! Get a really simple first guess, assuming a uniform log scale height of
    ! 16km

    call trace_begin (me, 'Get2DHydrostaticTangentPressure', cond=toggle(emit) )

    earthRadius = earthRadA*earthRadB/sqrt( &
      & (earthRadA**2-earthRadB**2)*sin(GeodToGeocLat(ptan%template%geodLat))**2 + earthRadB**2)
    ptan%values = -3.0+(geocAlt%values - earthRadius)/16.0e3
    if ( any(ptan%values < -4.0 .or. ptan%values > 10.0) ) then
      call MLSMessage ( MLSMSG_Warning, moduleName, &
        & 'Why is PTan weird?  Module turned off?  PTan guess set to -3.0' )
      ptan%values = -3.0
    end if
    if ( .not. associated(orbIncl%values) ) then
      call MLSMessage ( MLSMSG_Warning, moduleName, &
        & 'orbIncl not associated; non-satellite data?' )
      call trace_end ( 'Get2DHydrostaticTangentPressure', cond=toggle(emit) )
      return
    else if ( size(orbIncl%values) < 1 ) then
      call MLSMessage ( MLSMSG_Warning, moduleName, &
        & 'orbIncl array size 0; non-satellite data?' )
      call trace_end ( 'Get2DHydrostaticTangentPressure', cond=toggle(emit) )
      return
    end if
    
    if ( switchDetail ( switches, 'pguess' ) > -1 ) then
      call dump ( ptan%values, 'Initial ptan guess' )
      if ( switchDetail ( switches, 'pguess' ) > 1 ) then
        call dump ( geocAlt%values, name='GeocAlt' )
        call dump ( earthRadius, name='EarthRadius' )
      end if
    end if

    fmConf%phiWindow = phiWindow
    fmConf%windowUnits = phiWindowUnits
    fmConf%instrumentModule = ptan%template%instrumentModule
    fmConf%differentialScan = .false.

    call Allocate_test ( fmStat%rows, ptan%template%noInstances, &
      & 'fmStat%rows', ModuleName )
    fmStat%rows = .false.

    ! Construct a scan residual quantity by hand
    scanResidual = ptan%template
    scanResidual%quantityType = l_scanResidual
    scanResidual%unit = PHYQ_Length
    ! Now create an array of all our quantity templates
    myQTs = [ ptan%template, temp%template, refGPH%template, &
      & h2o%template, orbIncl%template, phiTan%template, &
      & geocAlt%template, scanResidual ]
    ! Now create the vector templates
    ! state: ptan
    call ConstructVectorTemplate ( 0, myQTs, [1], stateTemplate, forWhom=moduleName )
    ! extra: temp, refGPH, h2o, geocAlt
    call ConstructVectorTemplate ( 0, myQTs, [2,3,4,5,6,7],  extraTemplate, forWhom=moduleName )
    ! residual
    call ConstructVectorTemplate ( 0, myQTs, [8], residualTemplate, forWhom=moduleName )

    ! Now create the vectors
    state = CreateVector ( 0, stateTemplate, myQTs )
    extra = CreateVector ( 0, extraTemplate, myQTs )
    residual = CreateVector ( 0, residualTemplate, myQTs )

    ! Fill the values
    state%quantities(1)%values = ptan%values

    extra%quantities(1)%values = temp%values
    extra%quantities(2)%values = refGPH%values
    extra%quantities(3)%values = h2o%values
    extra%quantities(4)%values = orbIncl%values
    extra%quantities(5)%values = phiTan%values
    extra%quantities(6)%values = geocAlt%values

    ! Create the matrix
    call CreateEmptyMatrix ( jacobian, 0, residual, state )

    ! Now do the iterations
    do i = 1, maxIterations
      ! Get residual for all mafs
      do maf = 1, ptan%template%noInstances
        fmStat%maf = maf
        call TwoDScanForwardModel ( fmConf, state, extra, residual, &
          & fmStat, jacobian, chunkNo )
        state%quantities(1)%values(:,maf) = state%quantities(1)%values(:,maf) - &
          & residual%quantities(1)%values(:,maf) / &
          &   jacobian%block(maf,maf)%values(:,1)
        call ClearMatrix ( jacobian )
      end do
      if ( switchDetail ( switches, 'pguess' ) > -1 ) then
        call output ( 'Pressure guesser iteration ' )
        call output ( i )
        call output ( ' mean, min abs, max abs residual:  ', advance='yes' )
        call output ( sum(residual%quantities(1)%values) / &
          & (ptan%template%noInstances*ptan%template%noSurfs) )
        call output ( minval(abs(residual%quantities(1)%values)), before=', ' )
        call output ( maxval(abs(residual%quantities(1)%values)), before=', ', &
          & advance='yes' )
      end if
    end do

    ! Put the result back in state
    ptan%values = state%quantities(1)%values

    if ( switchDetail (switches, 'pguess' ) > -1 ) &
      & call dump ( ptan%values, 'Final ptan guess' )

    ! Destroy our vectors
    call DestroyMatrix ( jacobian )
    call DestroyVectorInfo ( state )
    call DestroyVectorInfo ( extra )
    call DestroyVectorInfo ( residual )
    
    call Deallocate_test ( fmStat%rows, 'fmStat%rows', ModuleName )

    call trace_end ( 'Get2DHydrostaticTangentPressure', cond=toggle(emit) )

  end subroutine Get2DHydrostaticTangentPressure

  ! ------------------------------  GetHydroStaticTangentPressure  -----
  subroutine GetHydrostaticTangentPressure ( ptan, temp, refGPH, h2o, geocAlt, &
    maxIterations )
    ! This routine is a pressure `guesser'.  It works by comparing the
    ! geopotential heights estimated from the level 1 heights with those based on
    ! a hydrostatic calculation.  The tangent point pressure is adjusted over
    ! several iterations until a good match is achieved.

    ! Dummy arguments
    ! Temp and H2O have the target attribute so we can take a pointer to
    ! their %template%surfs components.
    type (VectorValue_T), intent(inout) :: PTAN ! Tangent pressure sv. component
    type (VectorValue_T), intent(in), target :: Temp ! Temperature
    type (VectorValue_T), intent(in) :: RefGPH       ! Reference GPH
    type (VectorValue_T), intent(in), target :: H2O  ! H2O
    type (VectorValue_T), intent(in) :: GeocAlt      ! L1B Tp Geoc alt.
    integer, intent(IN) :: MaxIterations             ! Number of iterations to use

    ! Local variables

    real (r8), dimension(:,:), pointer :: RT           ! rt=R*T
    real (r8), target :: BasisGPH(temp%template%noSurfs, temp%template%noInstances)

    real (r8) :: ACoeff(ptan%template%noSurfs)           ! Quadratic term
    real (r8) :: BasisLower(ptan%template%noSurfs)       ! For temperature
    real (r8) :: BasisSpacing(ptan%template%noSurfs)     ! For temperature
    real (r8) :: BasisUpper(ptan%template%noSurfs)       ! For temperature
    real (r8) :: BCoeff(ptan%template%noSurfs)           ! Quadratic term
    real (r8) :: CCoeff(ptan%template%noSurfs)           ! Quadratic term
    real (r8) :: DeltaRT(ptan%template%noSurfs) 
    real (r8) :: EarthRadius(ptan%template%noSurfs)
    real (r8) :: GeocLat(ptan%template%noSurfs)
    real (r8) :: GeometricGPH(ptan%template%noSurfs)
    real (r8) :: N(ptan%template%noSurfs)                ! Refractive index
    real (r8) :: P2(ptan%template%noSurfs)
    real (r8) :: P4(ptan%template%noSurfs)
    real (r8) :: PointingH2O(ptan%template%noSurfs)      ! t.p. h2o
    real (r8) :: PointingPres(ptan%template%noSurfs)     ! t.p. press
    real (r8) :: PointingTemp(ptan%template%noSurfs)     ! t.p. temp.
    real (r8) :: Ratio2(ptan%template%noSurfs)           ! minor frame
    real (r8) :: Ratio4(ptan%template%noSurfs)           ! minor frame
    real (r8) :: RefractedGeocAlt(ptan%template%noSurfs) ! minor frame
    real (r8) :: RTLower(ptan%template%noSurfs)
    real (r8) :: RTUpper(ptan%template%noSurfs)
    real (r8) :: S2(ptan%template%noSurfs)

    real (r8), dimension(:), pointer :: H2OBasis         ! H2O basis
    real (r8), dimension(:), pointer :: H2OVals          ! Part of h2o
    real (r8), dimension(:), pointer :: PTANVals         ! Part of ptan
    real (r8), dimension(:), pointer :: TempBasis        ! Temp basis
    real (r8), dimension(:), pointer :: TempVals         ! Part of temp
    real (r8), dimension(:), pointer :: ThisBasisGPH     ! Part of basisGPH

    integer :: ClosestTempProfiles(ptan%template%noInstances)
    integer :: ClosestH2OProfiles(ptan%template%noInstances)
    integer :: Lower(ptan%template%noSurfs) ! index into temperature profile
    integer :: Upper(ptan%template%noSurfs) ! index into temperature profile

    integer :: Iteration                ! Loop stuff
    integer :: MAF                      ! Loop counter
    integer :: Me = -1                  ! String index for trace

    ! Executable code

    call trace_begin ( me, 'GetHydrostaticTangentPressure', cond=toggle(emit) )

    ! Check that we get the right kinds of quantities
    if ( ( .not. ValidateVectorQuantity( temp,&
      &            coherent=.true., &
      &            stacked=.true., &
      &            regular=.true., &
      &            verticalCoordinate=[ l_Zeta ]) ) .or. &
      &  ( .not. ValidateVectorQuantity( refGPH,&
      &            coherent=.true., &
      &            stacked=.true., &
      &            regular=.true., &
      &            verticalCoordinate=[ l_Zeta ]) ) .or. &
      &  ( .not. ValidateVectorQuantity( h2o,&
      &            coherent=.true., &
      &            stacked=.true., &
      &            regular=.true., &
      &            verticalCoordinate=[ l_Zeta ]) ) ) &
      & call MLSMessage(MLSMSG_Error,ModuleName, &
      &   'Inappropriate temp/refGPH/h2o quantity' )

    ! Now precompute the basis geopotential height
    nullify ( rt ) ! Allocated in GetBasisGPH
    call GetBasisGPH ( temp, refGPH, basisGPH, rt=rt )

    ! Find the closest temperature and h2o profiles to each MAF.  Note that
    ! this makes this calculation 1D
    call FindClosestInstances ( temp, ptan, closestTempProfiles )
    call FindClosestInstances ( h2o, ptan, closestH2OProfiles )

    ! Rather than try to be too clever and do this all with 2D arrays, we'll
    ! loop over major frame.

    tempBasis => temp%template%surfs(:,1)
    h2oBasis => h2o%template%surfs(:,1)

    do maf = 1, ptan%template%noInstances
      ! Setup pointers for this maf
      ptanVals => ptan%values(:,maf)
      tempVals => temp%values(:,closestTempProfiles(maf))
      h2oVals => h2o%values(:,closestH2OProfiles(maf))
      thisBasisGPH => basisGPH(:,closestTempProfiles(maf))

      ! Get a really simple first guess, assuming a uniform log scale height of
      ! 16km
      geocLat=GeodToGeocLat(ptan%template%geodLat(:,maf))
      s2=sin(geocLat)**2
      earthRadius = earthRadA*earthRadB/sqrt(&
        & (earthRadA**2-earthRadB**2)*s2 + earthRadB**2)

      ptanVals = -3.0+(geocAlt%values(:,maf) - &
        & earthRadius)/16e3 ! Do a better job later !???
      ! Precompute some spherical geometry terms, these are
      ! particularly worthy of note. We're doing the geometricGPH
      ! in a 2D manner (apart from refraction effects).  The hydrostatic GPH is
      ! being done 2D.
      p2=0.5*(3*s2-1)
      p4=0.125*(35*(s2**2)-30*s2+3)

      ! Now we have an iteration loop where we try to fit the tangent pressure
      do iteration = 1, maxIterations
        ! The first stage is to refract the tangent point altitudes, for this we
        ! need the refractive index, which is dependent on temperature, pressure
        ! and water vapor concentration for the given altitude.

        ! Note here an assumption that temp and h2o are coherent.
        call InterpolateValues ( tempBasis, tempVals, ptanVals, &
          pointingTemp, "Linear", extrapolate='Clamp' )
        call InterpolateValues ( h2oBasis, h2oVals, ptanVals, &
          pointingH2O, "Linear", extrapolate='Clamp' )

        pointingH2O = max(pointingH2O, 0.0_r8)
        where ( geocAlt%values(:,maf) /= geocAlt%template%badValue )

          pointingPres = min(10**(-ptanVals), maxPressure)

          n = refractive_index_f ( pointingPres, pointingTemp, pointingH2O )

          n = min(n,maxRefraction) ! Forbid stupidly large values of n

          ! Now we're going to compute refracted geocentric altitudes
          refractedGeocAlt=geocAlt%values(:,maf)/(1.0+n)

          ! Now convert these to geopotential heights
          ratio2=(earthRadA/refractedGeocAlt)**2
          ratio4=ratio2**2

          geometricGPH = -((GM/g0)/refractedGeocAlt)*&
            &              (1-j2*p2*ratio2- j4*p4*ratio4) - &
            ((omega**2/(2*g0))*(refractedGeocAlt*cos(geocLat))**2)+earthSurfaceGPH
        elsewhere
          n = 0.0
        end where

        ! Now, we're effectively going to compare this with a hydrostatic
        ! calculation.

        call Hunt ( thisBasisGPH, geometricGPH, lower )
        upper=lower+1
        basisLower= tempBasis(lower)
        basisUpper= tempBasis(upper)
        basisSpacing= basisUpper - basisLower
        rtLower = rt(lower, closestTempProfiles(maf))
        rtUpper = rt(upper, closestTempProfiles(maf))
        deltaRT = rtUpper - rtLower

        where ( geocAlt%values(:,maf) == geocAlt%template%badValue )
          ptanVals = ptan%template%badValue

          ! Below the bottom
        elsewhere ( geometricGPH < thisBasisGPH(1) )
          ptanVals = tempBasis(1) - (thisBasisGPH(1) - geometricGPH) * &
            & ((g0 / ln10) / rtLower)

          ! Above the top
        elsewhere ( geometricGPH >= thisBasisGPH(temp%template%noSurfs) )
          ptanVals = tempBasis(temp%template%noSurfs) + &
            & (geometricGPH-thisBasisGPH(upper)) * &
            & ((g0 / ln10) / rtUpper)

          ! Everywhere else
        elsewhere
          aCoeff = deltaRT
          bCoeff = 2*rtLower
          cCoeff = -2*(g0/ln10)*(geometricGPH-thisBasisGPH(lower)) / &
            & (basisSpacing)
          ! Let ptan contain upperWeight (ptan-basisLower)/basisSpacing first
          ptanVals = 2*cCoeff/( -bCoeff - &
            & sqrt(max(bCoeff**2-4*aCoeff*cCoeff,0.0_r8)))
          ! The max is here just in case of slips.
          ! Now let it contain ptan
          ptanVals = basisLower + ( ptanVals * basisSpacing )
        end where
      end do                            ! End iteration loop
    end do                              ! Major frame loop

    call Deallocate_Test ( rt, "rt", ModuleName ) ! Was allocated in GetBasisGPH

    call trace_end ( 'GetHydrostaticTangentPressure', cond=toggle(emit) )

  end subroutine GetHydrostaticTangentPressure

  ! -------------------------------------------  ScanForwardModel  -----
  subroutine ScanForwardModel ( fmConf, state, extra, &
    & fwmOut, fmStat, jacobian )
    ! This is the main `scan model' for the module. It compares altitude reported
    ! geometrically, as converted into geopotential height, with a hydrostatic
    ! equivalent.

    ! Note that while this model takes multi-MAF quantities as input, it only
    ! considers one MAF at a time (fmStat%maf).

    ! Dummy arguments
    type (ForwardModelConfig_T), intent(in) :: FMConf ! Configuration options
    type (Vector_T), intent(in) :: State ! The state vector
    type (Vector_T), intent(in) :: Extra ! Other stuff in the state vector
    type (Vector_T), intent(inout) :: FWMOut ! Output vector, residual filled
    type (ForwardModelStatus_T), intent(inout) :: FMStat ! Which maf etc.
    type (Matrix_T), intent(inout), optional :: Jacobian ! The derivative matrix

    ! Local parameters

    character(len=*), parameter :: InvalidQuantity = "Invalid vector quantity for "

    ! Local variables

    integer :: Me = -1                  ! String index for trace
    integer :: NoMAFS                   ! Dimension
    integer :: NoMIFS                   ! Dimension
    integer :: NoTemps                  ! Dimension

    logical :: H2OInState               ! Set if H2O in state, not extra
    logical :: HeightOffsetInState      ! Set if heightOffset in state, not extra
    logical :: PTANInState              ! Set if ptan in state, not extra
    logical :: REFGPHInState            ! Set if refGPH in state not extra
    logical :: TempInState              ! Set if temp in state not extra

    type (VectorValue_T), pointer :: H2O      ! H2O component of state
    type (VectorValue_T), pointer :: HeightOffset ! Height offset component of state
    type (VectorValue_T), pointer :: L1Alt    ! Tangent point altitude
    type (VectorValue_T), pointer :: PTAN     ! Ptan component of state
    type (VectorValue_T), pointer :: RefGPH   ! Ref gph component of state
    type (VectorValue_T), pointer :: Residual ! Resulting component of fwmOut
    type (VectorValue_T), pointer :: Temp     ! Temperature component of state

    ! Executable code -----------------------
    call MLSMessage( MLSMSG_Error, ModuleName,&
      & 'The 1d Scan model is broken; how could you get here?' )
    call trace_begin ( me, 'ScanForwardModel', cond=toggle(emit) )

    ! Identify the vector quantities from state/extra
    temp => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_temperature, config=fmConf, foundInFirst=tempInState )
    ptan => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_ptan, instrumentModule=fmConf%instrumentModule,&
      & config=fmConf, foundInFirst=ptanInState )
    h2o => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_vmr, molecule=l_h2o, &
      & config=fmConf, foundInFirst=h2oInState, noError=.true.)
    refgph => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_refGPH, config=fmConf, foundInFirst=refGPHInState )
    l1Alt => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_tngtGeocAlt, instrumentModule=fmConf%instrumentModule, &
      & config=fmConf )
    heightOffset => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_heightOffset, instrumentModule=fmConf%instrumentModule, &
      & config=fmConf, noError=.true., foundInFirst=heightOffsetInState )

    ! Identify the vector quantities from fwmOut
    residual => getQuantityForForwardModel ( fwmOut, &
      & quantityType=l_scanResidual, instrumentModule=fmConf%instrumentModule, &
      & config=fmConf )

    ! Now check that they make sense
    if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
      & frequencyCoordinate=[ l_none ]) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'temperature' )
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true., &
      & frequencyCoordinate=[ l_none ]) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'ptan' )
    if ( .not. ValidateVectorQuantity(h2o, stacked=.true., coherent=.true., &
      & frequencyCoordinate=[ l_none ]) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'h2o' )
    if ( .not. ValidateVectorQuantity(refGPH, stacked=.true., coherent=.true., &
      & frequencyCoordinate=[ l_none ]) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'refGPH' )
    if ( .not. ValidateVectorQuantity(l1Alt, minorFrame=.true., &
      & frequencyCoordinate=[ l_none ]) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'l1Alt' )
    if ( associated(heightOffset) ) then
      if ( .not. ValidateVectorQuantity(heightOffset, minorFrame=.false., &
        & frequencyCoordinate=[ l_none ],&
        & noInstances=[1] ) ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, InvalidQuantity//'heightOffset' )
    end if

    ! Now setup some standard dimensions etc.
    noMIFs = ptan%template%noSurfs
    noMAFs = ptan%template%noInstances
    noTemps = temp%template%noSurfs
    call scanForwardModelAuto
    call trace_end ( 'ScanForwardModel', cond=toggle(emit) )

  contains

    subroutine ScanForwardModelAuto

      ! Local variables

      integer :: Col                      ! Block col in jacobian
      integer :: I                        ! Loop index
      integer :: J                        ! Loop index
      integer :: Lower                    ! Index into T profile
      integer :: MAF                      ! Major frame to consider
      integer :: Row                      ! Block row in jacobian
      real (r8), target :: Zero=0.0_r8    ! Need this if no heightOffset
      real (r8), pointer :: HTOff         ! HeightOffset%values or zero
      real (r8) :: UsePTAN                ! A tangent pressure
      real (r8) :: Basis                  ! Index
      real (r8) :: BasisMinus             ! Index
      real (r8) :: BasisPlus              ! Index

      integer, dimension(noMifs) :: PointTempLayer ! Pointing layer
      integer, dimension(noMifs) :: PointH2OLayer  ! Pointing layer
      integer, dimension(noMafs) :: ClosestTempProfiles
      integer, dimension(noMafs) :: ClosestH2OProfiles

      real (r8), dimension(noMifs) :: DH2OByDPtan ! Derivative
      real (r8), dimension(noMifs) :: DHydrosGPHByDPtan ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHByDHeightOffset ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHByDL1RefrGeocAlt ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHByDPtan ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHByDtempLower ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHByDtempUpper ! Derivative
      real (r8), dimension(noMifs) :: DL1RefrGeocAltByDHeightOffset ! Derivative
      real (r8), dimension(noMifs) :: DL1refrGeocAltByDn ! Derivative
      real (r8), dimension(noMifs) :: DL1RefrGeocAltByDptan ! Derivative
      real (r8), dimension(noMifs) :: DL1RefrGeocAltByDtempLower ! Derivative
      real (r8), dimension(noMifs) :: DL1RefrGeocAltByDtempUpper ! Derivative
      real (r8), dimension(noMifs) :: dnByDH2O  ! Derivative
      real (r8), dimension(noMifs) :: DnByDPtan ! Derivative
      real (r8), dimension(noMifs) :: DnByDTemp ! Derivative
      real (r8), dimension(noMifs) :: DnByDTempLower ! Derivative
      real (r8), dimension(noMifs) :: DnByDTempUpper ! Derivative
      real (r8), dimension(noMifs) :: DTempByDPtan ! Derivative
      real (r8), dimension(noMifs) :: GeocLat ! TP GeocLat
      real (r8), dimension(noMifs) :: H2OBasisGap ! Basis spacing
      real (r8), dimension(noMifs) :: H2OLowerWeight ! Weight
      real (r8), dimension(noMifs) :: H2OUpperWeight ! Weight    
      real (r8), dimension(noMifs) :: HydrosGPH ! GPH from hydrostatic calc.
      real (r8), dimension(noMifs) :: L1GPH ! Geometric geopotential
      real (r8), dimension(noMifs) :: L1RefrGeocAlt ! Refracted geocentric alt
      real (r8), dimension(noMifs) :: N ! Refractive index - 1
      real (r8), dimension(noMifs) :: P2 ! Polynomial term
      real (r8), dimension(noMifs) :: P4 ! Polynomial term
      real (r8), dimension(noMifs) :: PointingH2O ! tangent h2o.
      real (r8), dimension(noMifs) :: PointingPres ! tangent pressure.
      real (r8), dimension(noMifs) :: PointingTemp ! tangent temp.
      real (r8), dimension(noMifs) :: Ratio2 ! For geopotential calculation
      real (r8), dimension(noMifs) :: Ratio4 ! For geopotential calculation
      real (r8), dimension(noMifs) :: S2 ! sin^2 geocLat
      real (r8), dimension(noMifs) :: TempBasisGap ! Basis spacing
      real (r8), dimension(noMifs) :: TempLowerWeight ! Weight
      real (r8), dimension(noMifs) :: TempUpperWeight ! Weight

      ! These are all dimensioned noMIFs
      real (r8), dimension(:), pointer :: BasisGPH ! From ifm
      real (r8), dimension(:), pointer :: H2OBasis ! => h2o%template%surfs
      real (r8), dimension(:), pointer :: H2OVals ! => h2o%values
      real (r8), dimension(:), pointer :: PtanVals ! => ptan%values
      real (r8), dimension(:), pointer :: RT ! Gas constant*T
      real (r8), dimension(:), pointer :: TempBasis ! => temp%template%surfs
      real (r8), dimension(:), pointer :: TempVals ! => temp%values

      real (r8), dimension(noMifs+1, noTemps) :: A ! Derivative array,
                                          ! extra row for refGPH
      real (r8), dimension(noMifs, noTemps) :: DHydrosGPHBydTemp ! Derivative array

      type (MatrixElement_T), pointer :: Block ! A matrix block

      maf = fmStat%maf

      ! This could maybe be store in ifm, but for the moment, we'll do it each
      ! time
      call FindClosestInstances ( temp, ptan, closestTempProfiles )
      call FindClosestInstances ( h2o, ptan, closestH2OProfiles )

      ! Make some pointers to save time
      tempVals => temp%values (:,closestTempProfiles(maf) )
      h2oVals => h2o%values(:,closestH2OProfiles(maf) )

      tempBasis => temp%template%surfs(:,1)
      h2oBasis => h2o%template%surfs(:,1)
      ptanVals => ptan%values(:,maf)
      if ( associated( heightOffset ) ) then
        htOff => heightOffset%values(1,1)
      else
        htOff => zero
      end if

      ! Do some preamble calcaulations
      geocLat = GeodToGeocLat( ptan%template%geodLat(:,maf) )
      ! Get terms for geopotential expression
      s2 = (sin(geocLat))**2
      p2 = 0.5 * (3*s2-1) ! Polynomial terms
      p4 = 0.125 * (35*(s2**2) - 30*s2 + 3)

      ! The first part of the calculation is the geometric calculation. This is in
      ! three stages.

      ! First we convert the level 1 geodetic heights to geocentric ones.
      ! Then we refract these heights given our knowledge of temperature and pressure
      ! Lastly we convert these heights to geopotentials.
      ! For each of these stages we need to calculate derivatives


      ! We have to refract the L1altitudes. In order to do that we need the
      ! refractive index, for which we need pressure and the temperature corresponding
      ! to that pressure.

      ! First find the layer each pointing is in, both for T and H2O, and
      ! thence calculate the refractive indicies


      ! Find temp and h2o layers
      call Hunt ( tempBasis, ptanVals, pointTempLayer )
      call Hunt ( h2oBasis,  ptanVals, pointH2OLayer )

      ! Calculate lower and upper weights
      tempBasisGap = tempBasis(pointTempLayer+1) - tempBasis(pointTempLayer)
      h2oBasisGap = h2oBasis(pointH2OLayer+1) - h2oBasis(pointH2OLayer)

      ! Compute weights
      tempUpperWeight = (ptanVals-tempBasis(pointTempLayer))/tempBasisGap
      tempLowerWeight = 1.0 - tempUpperWeight
      h2oUpperWeight = (ptanVals-h2oBasis(pointH2oLayer))/h2oBasisGap
      h2oLowerWeight = 1.0 - h2oUpperWeight

      ! Constrain to constant so we get no extrapolation
      tempUpperWeight = max ( 0.0_r8, min( 1.0_r8, tempUpperWeight ) )
      tempLowerWeight = max ( 0.0_r8, min( 1.0_r8, tempLowerWeight ) )
      h2oUpperWeight = max ( 0.0_r8, min( 1.0_r8, h2oUpperWeight ) )
      h2oLowerWeight = max ( 0.0_r8, min( 1.0_r8, h2oLowerWeight ) )

      ! Now compute derivatives wrt ptan for later chain rule use.
      where (ptanVals>=tempBasis(1) .and. ptanVals<tempBasis(noTemps))
        dTempByDPTan = ( tempVals(pointTempLayer+1) - tempVals(pointTempLayer) ) / &
          & tempBasisGap
      elsewhere
        dTempByDPTan = 0.0_r8
      end where

      where (ptanVals>=h2oBasis(1) .and. ptanVals<h2oBasis(h2o%template%noSurfs))
        dH2OByDPTan = ( h2oVals(pointH2oLayer+1) - h2oVals(pointH2oLayer) ) / &
          & h2oBasisGap
      elsewhere
        dH2OByDPTan = 0.0_r8
      end where

      ! Now get interpolated temperature and H2O
      pointingTemp = tempVals(pointTempLayer) * tempLowerWeight + &
        &            tempVals(pointTempLayer+1) * tempUpperWeight 
      pointingH2O = h2oVals(pointH2OLayer) * h2oLowerWeight + &
        &           h2oVals(pointH2OLayer+1) * h2oUpperWeight

      ! Get pointing pressure in mb
      pointingPres = min(10.0_r8**(-ptanVals), maxPressure)

      ! Now get the refractive index and its derivatives w.r.t. temperature
      ! and H2O.
      call refractive_index_deriv ( pointingPres, pointingTemp, pointingH2O, &
        & n, dnByDTemp, dnByDH2O )

      where ( n > maxRefraction )
        ! where n is too big limit it and set derivatives to zero
        n = maxRefraction
        dNByDPtan = 0.0
        dNByDTempLower = 0.0
        dNByDTempUpper = 0.0
      elsewhere ! ( n <= maxRefraction )
        !{ Compute derivative of the refractive index w.r.t.\ PTan ($\zeta$).\\
        !  $\frac{\text{d} n}{\text{d} \zeta} =
        !   \frac{\text{d} n}{\text{d} P}
        !   \frac{\text{d} P}{\text{d} \zeta} =
        !   \left( \frac{n}P +
        !   \frac{\text{d} n}{\text{d} T} \frac{\text{d} T}{\text{d} P} +
        !   \frac{\text{d} n}{\text{d} \mathbf{f}_{\text{H}_2\text{O}}}
        !   \frac{\text{d} \mathbf{f}_{\text{H}_2\text{O}}}{\text{d} P} \right)
        !   \frac{\text{d} P}{\text{d} \zeta} =
        !   \frac{n}P \frac{\text{d} P}{\text{d} \zeta} +
        !   \frac{\text{d} n}{\text{d} T} \frac{\text{d} T}{\text{d} \zeta} +
        !   \frac{\text{d} n}{\text{d} \mathbf{f}_{\text{H}_2\text{O}}}
        !   \frac{\text{d} \mathbf{f}_{\text{H}_2\text{O}}}{\text{d} \zeta}$. \\
        !  Since $\frac{\text{d} P}{\text{d} \zeta} = - P \ln 10$, we have
        !  $\frac{\text{d} n}{\text{d} \zeta} = -n \ln 10 +
        !   \frac{\text{d} n}{\text{d} T} \frac{\text{d} T}{\text{d} \zeta} +
        !   \frac{\text{d} n}{\text{d} \mathbf{f}_{\text{H}_2\text{O}}}
        !   \frac{\text{d} \mathbf{f}_{\text{H}_2\text{O}}}{\text{d} \zeta}$ 
        
        dnBydPTan = -n * ln10 + dnByDTemp * dTempByDPTan + dnByDH2O * dH2OByDPTan
        ! Compute derivatives w.r.t. temperature at lower and upper layers.
        dNByDTempLower = tempLowerWeight * dnByDTemp
        dNByDTempLower = tempUpperWeight * dnByDTemp
      end where

      ! Set derivatives w.r.t. pressure to zero for high pressure cases
    ! where ( 10**(-ptanVals) > maxPressure ) dNByDPtan=0.0
      where ( ptanVals < minZeta ) dNByDPtan=0.0

      ! Now from this calculate the refracted geocentric altitudes
      l1RefrGeocAlt= ( l1Alt%values(:,maf) + htOff ) / (1.0+n)

      ! And calculate their derivatives, again ignore H2O
      dl1RefrGeocAltByDHeightOffset = 1.0 / (1.0+n)
      dl1RefrGeocAltByDn = -l1RefrGeocAlt / (1.0+n)

      dl1RefrGeocAltByDPtan = dL1RefrGeocAltByDn * dNByDPtan

      dl1RefrGeocAltByDTempLower = dl1RefrGeocAltByDn * dNByDTempLower
      dl1RefrGeocAltByDTempUpper = dl1RefrGeocAltByDn * dNByDTempUpper

      ! Now we want to convert these to geopotentials
      ratio2=(earthRadA/l1RefrGeocAlt)**2
      ratio4=ratio2**2

      l1GPH = -((GM/g0)/l1RefrGeocAlt) * &
        & (1-J2*P2*ratio2-J4*P4*ratio4) - &
        & ((omega**2)/(2*g0)*(l1RefrGeocAlt*cos(geocLat))**2) + earthSurfaceGPH

      dL1GPHByDL1RefrGeocAlt= ( (GM/(l1RefrGeocAlt**2)) * &
        & (1-3*J2*P2*ratio2-5*J4*P4*ratio4) - &
        & omega**2*l1RefrGeocAlt*(cos(geocLat))**2 ) / g0

      ! Now get the combined derivatives for the l1Geopt's
      dL1GPHByDHeightOffset = dL1GPHByDL1RefrGeocAlt * &
        & dL1RefrGeocAltByDHeightOffset
      dL1GPHByDPtan = dL1GPHByDL1RefrGeocAlt * &
        & dL1RefrGeocAltByDPtan
      dL1GPHByDTempLower = dL1GPHByDL1RefrGeocAlt * &
        & dL1RefrGeocAltByDTempLower
      dL1GPHByDTempUpper = dL1GPHByDL1RefrGeocAlt * &
        & dL1RefrGeocAltByDTempUpper

      ! --------------------------------------------------------
      ! That's the end of the geometric geopotential calculation
      ! Now we're onto the hydrostatic calculation
      ! --------------------------------------------------------

      ! If this is the very first call, setup the hydrostatic temperature
      ! grid.
      if ( fmStat%newScanHydros ) then
        call allocate_test ( ifm%basisGPH, noTemps, &
          & temp%template%noInstances, 'ifm%gph', ModuleName )
        call allocate_test ( ifm%RT,  noTemps, &
          & temp%template%noInstances, 'ifm%gph', ModuleName )
        call allocate_test ( ifm%R, noTemps, &
          & 'ifm%gph', ModuleName )
        call GetBasisGPH ( temp, refGPH, ifm%basisGPH, &
          & ifm%R, ifm%RT, belowRef=ifm%belowRef )
        fmStat%newScanHydros = .false.
      end if

      rt => ifm%rt(:, closestTempProfiles(maf) )
      basisGPH => ifm%basisGPH (:, closestTempProfiles(maf) )

      ! Compute the basisGPH for each minor frame
      where (ptanVals>=tempBasis(1) .and. ptanVals<tempBasis(noTemps))
        hydrosGPH = basisGPH ( pointTempLayer ) + &
          & (rt(pointTempLayer)*tempUpperWeight*(2-tempUpperWeight) + &
          &  rt(pointTempLayer+1)*(tempUpperWeight**2))*(ln10*tempBasisGap/(2*g0))
      end where

      where ( ptanVals < tempBasis(1) )
        hydrosGPH = basisGPH ( pointTempLayer ) + &
          & rt(pointTempLayer) * (ln10/g0) * &
          & (ptanVals-tempBasis(pointTempLayer))
      end where

      where ( ptanVals > tempBasis(noTemps) )
        hydrosGPH = basisGPH (pointTempLayer+1) + &
          & rt(pointTempLayer+1) * (ln10/g0) * &
          & (ptanVals-tempBasis(pointTempLayer+1))
      end where

      ! Now we need dHydrosGPHByDT. To do this we calculate a matrix A containing
      ! the integrated basis functions.  There is an extra dimension in this
      ! to account for the reference surface which is then globally subtracted at
      ! the end.

      ! Unlike the code above, I think I'll do this in a loop to make life easier

      do i = 1, noMIFs + 1
        if ( i == noMIFs+1 ) then
          usePtan = refGPH%template%surfs(1,1)
          lower = ifm%belowRef
        else
          usePtan = ptanVals(i)
          lower = pointTempLayer(i)
        end if

        ! Now do the main bulk of the temperature bases
        do j = 1, noTemps

          ! Loop over temperature basis surfaces
          A(i,j) = 0.0_r8          ! Set to zero to start

          ! Now do nothing for bad ptans
          if ( usePtan /= ptan%template%badValue ) then
            basis = tempBasis(j)
            basisPlus =  tempBasis( min(j+1,noTemps))
            basisMinus = tempBasis( max(j-1,1) )

            ! Consider the extremes (j==1, j==noTemps) cases first

            ! Below bottom of basis
            if ( (j==1) .and. (usePtan < tempBasis(j)) ) then
              A(i,j) = 2*(usePtan-tempBasis(j))

              ! Above top
            else if ( (j==noTemps) .and. (usePtan > tempBasis(j)) ) then
              A(i,j) = 2*(usePtan-tempBasis(j))

              ! Basis triangles completely below ptan
            else if ( j < lower ) then
              A(i,j) = basisPlus - basisMinus

              ! Basis triangles with ptan in the top half (not when ptan above top)
            else if ( j == lower .and. usePtan < tempBasis(noTemps) ) then
              A(i,j) = ( basis - basisMinus ) + &
                & ( usePtan - basis ) * &
                & ( 2 * basisPlus - basis - usePtan ) / &
                & (basisPlus - basis)

              ! Basis triangles with ptan in the bottom half (not when ptan below bottom)
            else if ( j == lower+1 .and. usePtan >= tempBasis(1) ) then
              A(i,j) = ( ( usePtan - basisMinus )**2 ) / &
                & (basis - basisMinus)

            end if                         ! Basis triangles completely above ptan, no impact
          end if                           ! Good ptan
        end do                             ! Loop over temp basis
      end do                               ! Loop over ptans

      ! Now use this to get temperature derivatives
      do i = 1, noMIFs
        if ( ptanVals(i) /= ptan%template%badValue ) then
          do j = 1, noTemps
            dHydrosGPHByDTemp(i,j) = ( A(i,j) - A(noMIFs+1,j) ) * &
              & (ifm%R(j)*ln10) / (2*g0)
          end do
        end if
      end do

      ! Now get dHydrosGPHByDPtan
      do i= 1, noMIFs
        if ( ptanVals(i) /= ptan%template%badValue ) then
          dHydrosGPHByDPtan(i)= (ln10/g0) * ( &
            & rt(pointTempLayer(i)) * tempLowerWeight(i)+ &
            & rt(pointTempLayer(i)+1) * tempUpperWeight(i) )
        else
          dHydrosGPHByDPtan(i)=0.0
        end if
      end do

      ! -----------------------------------------------------------------------
      ! Now we calculate the residual, which is defined as the difference of the
      ! l1GPH and hydrosGPH. We also need it's derivatives wrt temp and ptan.
      ! First calculate residual. Also calculate the derivatives.
      ! -----------------------------------------------------------------------

      ! Compute residual (or differential residual)
      if ( fmConf%differentialScan ) then
        residual%values ( 1 : noMIFs-1, maf ) = &
          & ( l1GPH(2:noMIFs) - l1GPH(1:noMIFs-1) ) -&
          & ( hydrosGPH(2:noMIFs) - hydrosGPH(1:noMIFs-1) )
        residual%values( noMIFs, maf ) = 0.0
      else
        residual%values(:,maf) = l1GPH - hydrosGPH
      end if

      ! Find row in jacobian
      if ( present ( jacobian ) ) then
        row = FindBlock ( jacobian%row, residual%index, maf )
        fmStat%rows(row) = .true.

        ! Store the ptan derivatives
        if ( ptanInState ) then
          col = FindBlock ( jacobian%col, ptan%index, maf )
          block => jacobian%block(row,col)
          if ( block%kind /= M_Absent ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Found a prexisting d(residual)/d(ptan), removing' )
            call DestroyBlock ( block )
          end if
          if ( fmConf%differentialScan ) then
            call updateDiagonal ( block, [ &
              & ( dL1GPHByDPtan(2:noMIFs) - dL1GPHByDPtan(1:noMIFs-1) ) - &
              & ( dHydrosGPHByDPtan(2:noMIFs) - dHydrosGPHByDPtan(1:noMIFs-1) ) - &
              & 0.0 ] )
          else
            call updateDiagonal ( block, dL1GPHByDPtan-dHydrosGPHByDPtan )
          end if
        end if

        ! Store refGPH derivatives
        if ( refGPHInState ) then
          col = FindBlock ( jacobian%col, refGPH%index, maf )
          block => jacobian%block(row,col)
          if ( fmConf%differentialScan ) then
            call DestroyBlock ( block )
          else
            if ( block%kind /= M_Absent ) then
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & 'Found a prexisting d(residual)/d(refGPH), removing' )
              call DestroyBlock ( block )
            end if
            call CreateBlock ( jacobian, row, col, M_Full )
            block%values = -1.0
          end if
        end if

        ! Store heightOffset derivatives if any
        if ( associated (heightOffset) .and. heightOffsetInState ) then
          col = FindBlock ( jacobian%col, heightOffset%index, maf )
          block => jacobian%block(row,col)
          if ( block%kind /= M_Absent ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Found a prexisting d(residual)/d(heightOffset), removing' )
            call DestroyBlock ( block )
          end if
          call CreateBlock ( jacobian, row, col, M_Full )
          if  ( fmConf%differentialScan ) then
            block%values(:,1) = [ &
              & dL1GPHByDHeightOffset(2:noMIFs) - dL1GPHByDHeightOffset(1:noMIFs-1), &
              & 0.0_r8 ]
          else
            block%values(:,1) = dL1GPHByDHeightOffset
          end if
        end if

        ! Now the temperature derivatives
        if ( tempInState ) then
          col = FindBlock ( jacobian%col, temp%index, maf )
          block => jacobian%block(row,col)
          if ( block%kind /= M_Absent ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Found a prexisting d(residual)/d(temp), removing' )
            call DestroyBlock ( block )
          end if
          call CreateBlock ( jacobian, row, col, M_Full )
          if ( fmConf%differentialScan ) then
            ! ------------- Diffential model
            block%values(noMIFs,:) = 0.0
            block%values(1:noMIFs-1,:) = - ( dHydrosGPHByDTemp(2:noMIFs,:) - &
              & dHydrosGPHByDTemp(1:noMIFs-1,:) )
            do i = 2, noMIFs
              block%values(i-1,pointTempLayer(i)) = &
                & block%values(i-1,pointTempLayer(i)) + dL1GPHByDTempLower(i)
              block%values(i-1,pointTempLayer(i)+1) = &
                & block%values(i-1,pointTempLayer(i)+1) + dL1GPHByDTempUpper(i)
            end do
            do i = 1, noMIFs-1
              block%values(i,pointTempLayer(i)) = &
                & block%values(i,pointTempLayer(i)) - dL1GPHByDTempLower(i)
              block%values(i,pointTempLayer(i)+1) = &
                & block%values(i,pointTempLayer(i)+1) - dL1GPHByDTempUpper(i)
            end do
          else
            ! ------------- Non differential model
            block%values = - dHydrosGPHByDTemp
            do i = 1, noMIFs
              block%values(i,pointTempLayer(i)) = &
                & block%values(i,pointTempLayer(i)) + dL1GPHByDTempLower(i)
              block%values(i,pointTempLayer(i)+1) = &
                & block%values(i,pointTempLayer(i)+1) + dL1GPHByDTempUpper(i)
            end do
          end if
        end if

      end if

    end subroutine ScanForwardModelAuto

  end subroutine ScanForwardModel
  ! ---------------------------------------  TwodScanForwardModel  -----
  subroutine TwoDScanForwardModel ( FmConf, State, Extra, FwmOut, &
                                  & FmStat, Jacobian, ChunkNo )

use dump_0, only: dump
    use Array_Stuff, only: Subscripts
    use Check_QTM_m, only: Check_QTM
    use Get_Species_Data_M, only:  Get_Species_Data
    use HGridsDatabase, only: HGrid_T
    use MatrixModule_0, only: MatrixElement_t
    use Output_M, only: Blanks, Output
    use Physics, only: Boltz
    use Piq_Int_M, only: Piq_Int
    use Sparse_Eta_m, only: Sparse_Eta_t
    use Tangent_Qty_m, only: Tangent_Qty
    use Time_M, only: Time_Now

  ! This is a two D version of ScanForwardModel
  ! inputs
    type (ForwardModelConfig_T), intent(inout) :: FmConf ! Configuration options
    type (Vector_T), intent(in) :: State ! The state vector
    type (Vector_T), intent(in) :: Extra ! Other stuff in the state vector
  ! outputs
    type (Vector_T), intent(inout) :: FwmOut ! Output vector, residual filled
    type (ForwardModelStatus_T), intent(inout) :: FmStat ! Which maf etc.
    type (Matrix_T), intent(inout), optional :: Jacobian ! The derivative matrix
    integer, intent(in), optional :: ChunkNo

    ! To make an array of pointers to MatrixElement_t blocks
    type :: Blocks_t
      type(matrixElement_t), pointer :: B
    end type Blocks_t

  ! local variables
    type (HGrid_t), pointer :: QTM_HGrid        ! QTM with finest resolution
    type (VectorValue_T), pointer :: OrbIncline ! Orbital inclination
    type (VectorValue_T), pointer :: Temp       ! Temperature component of state
    type (VectorValue_T), pointer :: PTAN       ! Ptan component of state
    type (VectorValue_T), pointer :: PhiTAN     ! Phitan component of state
    type (VectorValue_T), pointer :: H2O        ! H2O component of state
    type (VectorValue_T), pointer :: RefGPH     ! Ref gph component of state
    type (VectorValue_T), pointer :: L1Alt      ! Tangent point altitude
    type (VectorValue_T), pointer :: Residual   ! Resulting component of fwmOut
    type (MatrixElement_T), pointer :: Block    ! A matrix block

    logical :: TempInState           ! Set if Temp in state not extra
    logical :: RefGPHInState         ! Set if RefGPH in state not extra
    logical :: H2OInState            ! Set if H2O in state, not extra
    logical :: PTANInState           ! Set if PTan in state, not extra
    logical :: UsingQTM              ! Set if Temp and all species are QTM

    integer :: E                     ! Index of Sparse_t E component
    integer :: Me = -1               ! String index for trace
    integer :: R                     ! Row index from Sparse_t E(e) component
    integer :: Row                   ! Block row in jacobian
    integer :: Col                   ! Block col in jacobian
    integer :: Sv_Z                  ! height basis index
    integer :: Sv_P                  ! horizontal basis index
    integer :: Windowstart_t         ! first instance for temperature
    integer :: Windowfinish_t        ! last instance for temperature
    integer :: Windowstart_h2o       ! first instance for water vapor
    integer :: Windowfinish_h2o      ! last instance for water vapor

    real(rp) :: z_surf
    real(rp) :: surf_temp
    real(rp) :: surf_refr_indx(1)

    type(sparse_eta_t) :: Eta_P_H2O     ! H2O horizontal
    type(sparse_eta_t) :: Eta_P_T       ! Temperature horizontal
    type(sparse_eta_t) :: Eta_ZXP_T     ! Temperature zeta X horizontal
    type(sparse_eta_t) :: Eta_ZXP_H2O   ! Water zeta X horizontal

    real :: T0, T1, T2                     ! For timing
    logical, parameter :: always_timing = .false.  ! if worried about NAG taking so long
    logical :: Timing  ! if worried about NAG taking so long
    logical, parameter :: Total_Times = .true.

integer :: Times = 0
times = times + 1
    call trace_begin ( me, 'TwoDScanForwardModel, MAF=', index=fmstat%maf, &
      & cond=toggle(emit) ) ! set by -f command-line switch
  ! Time this
    call time_now ( t0 )
    call time_now ( t1 )
    Timing = always_timing
  !  if ( present(chunkNo) ) &
  !    & Timing = always_timing .or. &
  !    & chunkNo == 4 .or. chunkNo == 12 .or. chunkNo == 25 .or.  &
  !    & chunkNo == 50 .or. chunkNo == 167
    if ( timing ) &
      & call output('beginning timing for 2d scan forward model', advance='yes')
  ! Identify the vector quantities from state/extra
    orbIncline => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_orbitInclination, config=fmConf )
    temp => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_temperature, config=fmConf, foundInFirst=tempInState )
    ptan => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_ptan, instrumentModule=fmConf%instrumentModule, &
      & config=fmConf, foundInFirst=ptanInState )
    phitan => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_phitan, instrumentModule=fmConf%instrumentModule, &
      & config=fmConf)
    h2o => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_vmr, molecule=l_h2o, &
      & config=fmConf, foundInFirst=h2oInState, noError=.true.)
    refgph => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_refGPH, config=fmConf, foundInFirst=refGPHInState )
    l1Alt => getQuantityForForwardModel ( state, extra, &
      & quantityType=l_tngtGeocAlt, instrumentModule=fmConf%instrumentModule, &
      & config=fmConf)
  ! Identify the vector quantities from fwmOut
    residual => getQuantityForForwardModel ( fwmOut, &
      & quantityType=l_scanResidual, instrumentModule=fmConf%instrumentModule, &
      & config=fmConf)
    if ( timing ) call sayTime ( 'Getting vector quantities' )
    call time_now ( t1 )

    ! Get pointers to the temperature and other quantities from the state
    ! vector into the configuration. This has to be done AFTER
    ! DeriveFromForwardModelConfig, which is invoked from ForwardModelWrappers.

    call get_species_data ( fmConf, state, extra )

    ! Check whether temperature and all the mixing ratios either all have QTM
    ! HGrid, or none do.  If so, find the QTM HGrid with the finest resolution.
    ! (We currently require that if they're QTM they all have the same grid.)

    call check_QTM ( fmConf, QTM_HGrid, usingQTM )

    ! Get windows
    if ( usingQTM ) then
      windowstart_t = 1
      windowfinish_t = size(temp%template%the_hGrid%QTM_tree%geo_in)
      windowstart_h2o = 1
      windowfinish_h2o = size(h2o%template%the_hGrid%QTM_tree%geo_in)
    else
      call FindInstanceWindow ( temp, phitan, fmStat%maf, FMConf%phiWindow, &
        & FMConf%windowUnits, windowstart_t, windowfinish_t )
      call FindInstanceWindow( h2o, phitan, fmStat%maf, FMConf%phiWindow, &
        & FMConf%windowUnits, windowstart_h2o, windowfinish_h2o )
    end if

    if ( timing ) call sayTime ( 'Finding instance windows' )
    call time_now ( t1 )

    block ! So that local arrays are automatic instead of allocatable
      type(blocks_t) :: Blocks(windowstart_t:windowfinish_t)
      real(rp) :: Coslat2(ptan%template%nosurfs)
      real(rp) :: dGPHdR(ptan%template%nosurfs)
      real(rp) :: Earth_radius(ptan%template%nosurfs)
      real(rp) :: Eff_earth_radius(ptan%template%nosurfs)
      real(rp) :: Eta_piqxp( ptan%template%nosurfs, temp%template%nosurfs, &
                           & windowfinish_t - windowstart_t + 1 )
      real(rp) :: G_ref(ptan%template%nosurfs)
      real(rp) :: L1AltRefr(ptan%template%nosurfs)
      real(rp) :: L1RefAlt(ptan%template%nosurfs)
      real(rp) :: Mass_corr(ptan%template%nosurfs)
      real(rp) :: P2(ptan%template%nosurfs)
      real(rp) :: P4(ptan%template%nosurfs)
      real(rp) :: piq(ptan%template%nosurfs,temp%template%nosurfs)
      real(rp) :: Ratio2_gph(ptan%template%nosurfs)
      real(rp) :: Ratio2(ptan%template%nosurfs)
      real(rp) :: Ratio4_gph(ptan%template%nosurfs)
      real(rp) :: Ratio4(ptan%template%nosurfs)
      real(rp) :: RefGeomAlt_denom(ptan%template%nosurfs)
      real(rp) :: Refgph_Surfs(ptan%template%nosurfs)
      real(rp) :: Tan_H2O(ptan%template%nosurfs)
      real(rp) :: Tan_Refr_Indx(ptan%template%nosurfs)
      real(rp) :: Tan_temp(ptan%template%nosurfs)
      real(rp) :: Work(ptan%template%nosurfs)

      ! Geometry calculations
      block ! So that some even-more local arrays are automatic
        real(rp) :: earthradc(ptan%template%nosurfs)  ! square of minor axis of
    !                       earth ellipsoid in orbit plane projected system
        real(rp) :: red_phi_t(ptan%template%nosurfs)
        real(rp) :: sinbeta(ptan%template%nosurfs)
        real(rp) :: sinphi2(ptan%template%nosurfs)
        real(rp) :: cosphi2(ptan%template%nosurfs)
        real(rp) :: geoclats(ptan%template%nosurfs)
        real(rp) :: sinlat2(ptan%template%nosurfs)

        ! Sometimes, orbincline may not have the same number of surfaces as
        ! ptan, e.g. for non-satellite data
        if ( size(orbincline%values, 1) < ptan%template%noSurfs ) then
          sinbeta = sin(deg2rad*orbincline%values(1,fmStat%maf))
        else
          sinbeta = sin(deg2rad*orbincline%values(1:ptan%template%noSurfs,fmStat%maf))
        end if
        earthradc = (earthrada*earthradb)**2 / &
          & ( (earthRada**2 - earthRadb**2) * sinbeta**2 + earthRadb**2) ! in meters
      ! rephase the phi
        red_phi_t = modulo(deg2rad*phitan%values(:,fmStat%maf),2.0_rp*Pi)
        where ( 0.5_rp*Pi < red_phi_t .AND. red_phi_t <= 1.5_rp*Pi )
          red_phi_t = Pi - red_phi_t
        elsewhere ( red_phi_t > 1.5_rp*Pi )
          red_phi_t = red_phi_t - 2.0_rp*Pi
        end where
        if ( timing ) call sayTime ( 'rephasing phi' )
        call time_now ( t1 )
      ! compute sin^2(phi) and cos^2(phi)
        sinphi2 = sin(red_phi_t)**2
        cosphi2 = 1.0_rp - sinphi2
      ! convert phitan into geocentric latitude
        geoclats = asin(earthradc * sin(red_phi_t) * sinbeta / &
          & sqrt(earthrada**4*cosphi2 + earthradc**2*sinphi2))
        sinlat2 = sin(geoclats)**2
        coslat2 = 1.0_rp - sinlat2
        p2=0.5_rp * (3.0_rp*sinlat2 - 1.0_rp)
        p4=0.125_rp * (35.0_rp*sinlat2**2 - 30.0_rp*sinlat2 + 3.0_rp)
      ! compute the local gravitational acceleration at the surface
        earth_radius = sqrt((earthrada**4*cosphi2 + earthradc**2*sinphi2) &
                     &    / (earthrada**2*cosphi2 + earthradc*sinphi2))
        ratio2=(earthRadA/earth_radius)**2
        ratio4=ratio2**2
        g_ref =  GM * (1.0_rp - 3.0_rp*j2*p2*ratio2 - 5.0_rp*j4*p4*ratio4) &
          & / earth_radius**2 - omega**2*earth_radius*coslat2
      ! get the effective earth radius
        eff_earth_radius = 2.0_rp * g_ref / (2.0_rp * gm * (1.0_rp-6.0_rp*j2*p2 &
          & * ratio2 - 15.0_rp*j4*p4*ratio4) / earth_radius**3 &
          & + omega**2*coslat2)
      end block

      ! Get Eta functions, and H2O and temperature tangent profiles.
      call tangent_qty ( fmConf, usingQTM, fmStat%MAF, ptan, phiTan, &
                       & h2o, windowStart_h2o, windowFinish_h2o, tan_h2o, &
                       & eta_zxp_h2o, eta_p_h2o, logLin=.true. )
      call tangent_qty ( fmConf, usingQTM, fmStat%MAF, ptan, phiTan, &
                       & temp, windowStart_t, windowFinish_t, tan_temp, &
                       & eta_zxp_t, eta_p_t )
    ! compute refractive index at the MIF tangent points
      call refractive_index ( 10.0_rp**(-max(-10.0_rp,ptan%values(:,fmStat%maf))), &
                            & tan_temp, tan_refr_indx, h2o_path = tan_h2o )
      if ( timing ) call sayTime ( 'getting etas etc.' )
      call time_now ( t1 )

    ! construct piq integral
      call piq_int ( ptan%values(:,fmStat%maf), temp%template%surfs(:,1), &
        & refGPH%template%surfs(1,1), piq, Z_MASS = 2.5_rp, C_MASS = 0.02_rp)
      if ( timing ) call sayTime ( 'constructing piq integral' )
      call time_now ( t1 )

    ! Convert level 1 reference geopotential height into geometric altitude.
    ! This assumes that the reference ellipsoid is equivalent to a reference
    ! geopotential height of 0 meters.
    ! Assume RefGPH and Temperature have the same horizontal basis.
      call eta_p_t%sparse_dot_vec ( &
        & refgph%values(1,windowstart_t:windowfinish_t), refgph_surfs )
      refgeomalt_denom = g_ref*eff_earth_radius - g0*refgph_surfs
      l1refalt = g_ref*eff_earth_radius**2 / refgeomalt_denom - eff_earth_radius &
        & + earth_radius
      eta_piqxp = 0
      do e = 1, eta_p_t%ne
        r = eta_p_t%e(e)%r
        eta_piqxp(r,:,eta_p_t%e(e)%c) = piq(r,:) * eta_p_t%e(e)%v
      end do
      if ( timing ) call sayTime ( 'constructing geometric altitude' )
      call time_now ( t1 )

      ! Compute surface pressure. Compute temperature at surface phi.
      ! Compute H2O at surface phi and surface pressure.
      block
        type(sparse_eta_t) :: Eta_At_One_Zeta
        type(sparse_eta_t) :: Eta_At_Z_Surf
        real(rp) :: Temp_At_Surf_Phi(temp%template%nosurfs)
        real(rp) :: Surf_H2O(h2o%template%nosurfs)

        call eta_p_t%row_dot_matrix ( 1, &
          & temp%values(:,windowstart_t:windowfinish_t), temp_at_surf_phi )
        z_surf = z_surface( temp%template%surfs(:,1),temp_at_surf_phi, g_ref(1), &
                          & refgph_surfs(1), refGPH%template%surfs(1,1), boltz )
      ! compute temperature at Z_Surf
        call eta_at_z_surf%eta_1d ( temp%template%surfs(:,1), [z_surf] )
        surf_temp = eta_at_z_surf%row_dot_vec ( 1, temp_at_surf_phi )
        ! Compute H2O at Z_Surf
        ! Logarithmic interpolation:
        ! First surf_h2o = eta_p_h2o .dot. log(max(h2o%values,1.0e-9_rp)),
        ! then h2o_path = exp(eta_at_z_surf .dot. surf_h2o)
        ! surf_h2o = 0 ! not necessary because most elements won't be used
        if ( eta_p_h2o%rows(1) /= 0 ) then
          call eta_at_z_surf%eta_1d ( h2o%template%surfs(:,1), [z_surf], &
            & empty=.true. )
          ! Surf_H2O is log(H2O at Z_Surf).  It will be an operand in a dot
          ! product with Eta_At_Z_Surf, so we only need it where Eta_At_Z_Surf
          ! has a nonzero column -- and there are only two of those.
          ! If TangentQuantity is changed to send the basis boundaries to
          ! Eta_p%Eta_1D, DO NOT put windowStart_h2o:windowFinish_h2o as a
          ! section subscript on the second dimension of H2O%Values!
          call eta_p_h2o%row_dot_matrix ( 1, &
            & h2o%values(:,windowStart_h2o:windowFinish_h2o), surf_h2o, &
            & logOnly = .true., rows=eta_at_z_surf )
          ! Compute refractive index at Z_Surf
          call refractive_index(10.0_rp**([ -z_surf ]), [ surf_temp ], &
            & surf_refr_indx, &
            & h2o_path = [ exp(eta_at_z_surf%row_dot_vec(1,surf_h2o)) ] )
        else
          ! Compute refractive index at Z_Surf
          call refractive_index(10.0_rp**([ -z_surf ]), [ surf_temp ], &
            & surf_refr_indx )
        end if
      end block
    ! set all refr indicies below the surface to the surface value
      where(ptan%values(:,fmStat%maf) < z_surf) 
        tan_refr_indx = surf_refr_indx(1)
        tan_temp = surf_temp
      end where
    ! compute l1 geopotential
      l1altrefr = l1alt%values(:,fmStat%maf) / (1.0_rp + tan_refr_indx)
      ratio2 = (earthRadA/l1altrefr)**2
      ratio4 = ratio2**2
      ratio2_gph = (earthRadA/l1refalt)**2
!????? Bill says ratio4_gph ought to be ratio2_gph**2 ?????
      ratio4_gph = ratio2**2
    ! do a simple mass correction
      mass_corr = 1.0_rp
    !  where(ptan%values(:,fmStat%maf) > 2.5) mass_corr = 1.0_rp &
    !    & / (0.875_rp + 0.1_rp*ptan%values(:,fmStat%maf) &
    !    & - 0.02_rp*ptan%values(:,fmStat%maf)**2)
    ! This is a reasonable approximation to the above.
      where(ptan%values(:,fmStat%maf) > 2.5) mass_corr = 1.0_rp &
         & + 0.02_rp*(ptan%values(:,fmStat%maf) - 2.5)**2
      if ( timing ) call sayTime ( 'refractive index, l1 geopotential' )
      call time_now ( t1 )
    ! forward model calculation
      do row = 1, ptan%template%nosurfs
        work(row) = sum ( temp%values(:,windowstart_t:windowfinish_t) * &
                        & eta_piqxp(row,:,:) ) * (boltz/g0)
      end do
      residual%values(:,fmStat%maf) = &
      & ( GM/g0) * ((1.0_rp - j2*p2*ratio2 - j4*p4*ratio4)  / l1altrefr &
      &             - (1.0_rp - j2*p2*ratio2_gph - j4*p4*ratio4_gph) / &
      &               l1refalt) &
      & + (omega**2/(2*g0)) * coslat2 * (l1altrefr - l1refalt) * &
      &   (l1altrefr + l1refalt) &
      & + work
      if ( timing ) call sayTime ( 'forward model calculation' )
      call time_now ( t1 )
      if ( fmConf%differentialScan ) residual%values(:,fmStat%maf) = &
        & EOSHIFT(residual%values(:,fmStat%maf), 1, &
        & residual%values(ptan%template%nosurfs,fmStat%maf)) &
        & - residual%values(:,fmStat%maf)
    ! derivatives--for simplicity we are ignoring h2o contributions
      if ( present ( jacobian ) ) then
        ! Find row in jacobian
        row = FindBlock ( jacobian%row, residual%index, fmStat%maf )
        fmStat%rows(row) = .true.
    ! compute dudr
        dgphdr =  -( (GM/g0) / l1altrefr**2) * (1.0_rp - 3.0_rp*j2*p2*ratio2 &
        & - 5.0_rp*j4*p4*ratio4) + (omega**2/g0)*l1altrefr*coslat2
    ! Store the ptan derivatives
        if ( ptanInState ) then
          col = FindBlock ( jacobian%col, ptan%index, fmStat%maf )
          block => jacobian%block(row,col)
          if ( block%kind /= M_Absent ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Found a prexisting d(residual)/d(ptan), removing' )
            call DestroyBlock ( block )
          end if
          block
            real(rp) :: dScandz(ptan%template%nosurfs)
            !{ $\frac{\text{d Scan}}{\text{d} z} = 
            !  \frac{k}{g_0} \, \eta_{\zeta \times p}^T \cdot T \,\times\, $
            !  mass\_corr
            call eta_zxp_t%sparse_dot_vec ( &
              & temp%values(:,windowstart_t:windowfinish_t), dScandz )
            dscandz = ( boltz / g0 ) * mass_corr * dscandz
            where ( ptan%values(:,fmStat%maf) > z_surf ) dscandz = dscandz + &
              & dgphdr*l1altrefr*tan_refr_indx*ln10 / (1.0_rp + tan_refr_indx)
              ! UpdateDiagonal creates a banded block
            if ( fmConf%differentialScan ) then
              call updateDiagonal ( block, EOSHIFT(dscandz, 1, &
              & dscandz(ptan%template%nosurfs)) - dscandz)
            else
              call updateDiagonal ( block, dscandz )
            end if
! call dump ( dscandz, 'PTan derivatives' )
          end block
        end if
    ! Store refGPH derivatives
        if ( refGPHInState ) then
          ! Find/create necessary Jacobian blocks
          do sv_p = windowstart_t, windowfinish_t
            col = FindBlock ( jacobian%col, refGPH%index, sv_p )
            blocks(sv_p)%b => jacobian%block(row,col)
            if ( blocks(sv_p)%b%kind /= M_Absent ) then
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Found a prexisting d(residual)/d(refGPH), removing' )
              call DestroyBlock ( blocks(sv_p)%b )
            end if
            if ( any(eta_p_t%e%r == sv_p ) ) &
              call CreateBlock ( jacobian, row, col, M_Full, init=0.0_rm )
          end do
          work = (GM * (1.0_rp - 3.0_rp*j2*p2*ratio2_gph &
               & - 5.0_rp*j4*p4*ratio4_gph) / l1refalt**2 &
               & + omega**2*l1refalt*coslat2) * &
               & (l1refalt+eff_earth_radius - earth_radius) / &
               & refgeomalt_denom
          !{ The dot product $\eta_p^T \cdot $ work is done ``the hard way''
          !  because the column index in eta_p_t\%e(e)\%c needs to be offset
          !  by WindowStart_t, and it gives the block index, not a subscript.
          do e = 1, eta_p_t%ne
            r = eta_p_t%e(e)%r
            sv_p = eta_p_t%e(e)%c + windowStart_t - 1
            blocks(sv_p)%b%values(r,1) =  blocks(sv_p)%b%values(r,1) + &
              & work(r) * eta_p_t%e(e)%v
          end do
          if ( fmConf%differentialScan ) then
    ! ------------- Differential model
            do sv_p = windowStart_t, windowFinish_t
              blocks(sv_p)%b%values = EOSHIFT(blocks(sv_p)%b%values, &
                & SPREAD(1, 1, ptan%template%nosurfs), &
                & RESHAPE(blocks(sv_p)%b%values(ptan%template%nosurfs,:), &
                & [ temp%template%nosurfs ]), dim=2) - blocks(sv_p)%b%values
            end do
          end if
! do sv_p = windowstart_t, windowfinish_t
! print '(a,i0)', 'SV_P ', sv_p
! call dump ( blocks(sv_p)%b%values, 'refGPH derivatives' )
! end do
          if ( timing ) call sayTime ( 'differential model' )
          call time_now ( t1 )
        end if
    ! Now the temperature derivatives
        if ( tempInState ) then
          block
            integer :: C     ! Column of Eta_ZXP_T element
            integer :: C2(2) ! Temperature's Zeta, Phi subscripts,
                             ! Sub-column subscripts of PIQXP, second and third
                             ! subscripts of PIQXP3
            ! Find/create necessary Jacobian blocks
            do sv_p = windowstart_t, windowfinish_t
              col = FindBlock ( jacobian%col, temp%index, sv_p )
              blocks(sv_p)%b => jacobian%block(row,col)
              if ( blocks(sv_p)%b%kind /= M_Absent ) then
                call MLSMessage ( MLSMSG_Warning, ModuleName, &
                  & 'Found a prexisting d(residual)/d(temp), removing' )
                call DestroyBlock ( blocks(sv_p)%b )
              end if
              if ( any(eta_zxp_t%e%r == sv_p) ) &
                call CreateBlock ( jacobian, row, col, M_Full, init=0.0_rm )
              blocks(sv_p)%b%values = (boltz/g0) * eta_piqxp(:,:,sv_p-windowstart_t+1)
            end do
            work = dgphdr * l1altrefr * tan_refr_indx / &
                 & ((1.0_rp + tan_refr_indx) * tan_temp)
            !{ The dot product $\eta_{\zeta \times p}^T \cdot$ work is done
            !  ``the hard way'' because the column index in eta_p_t\%e(e)\%c is
            !  actually the array-order index of a two-dimensional array, one of
            !  which needs to be offset by WindowStart_t, and gives the block
            !  index, not a subscript.
            do e = 1, eta_zxp_t%ne
              r = eta_zxp_t%e(e)%r
              c = eta_zxp_t%e(e)%c
              c2 = subscripts( c, [ temp%template%nosurfs, windowfinish_t ], &
                             &    [ 1, windowstart_t ] )
              blocks(c2(2))%b%values(r,c2(1)) = blocks(c2(2))%b%values(r,c2(1)) + &
                & work(r) * eta_zxp_t%e(e)%v
            end do
            if ( fmConf%differentialScan ) then
    ! ------------- Differential model
              do sv_p = windowStart_t, windowFinish_t
                blocks(sv_p)%b%values = EOSHIFT(blocks(sv_p)%b%values, &
                & SPREAD(1, 1, ptan%template%nosurfs), &
                & RESHAPE(blocks(sv_p)%b%values(ptan%template%nosurfs,:), &
                & [ temp%template%nosurfs ]), dim=2) - blocks(sv_p)%b%values
              end do
            end if
          end block
          if ( timing ) call sayTime ( 'temperature derivatives' )
          call time_now ( t1 )
        end if
      end if
    end block

    if ( timing ) call sayTime ( 'deallocating the rest' )
    if ( timing ) then
      t1 = t0
      call sayTime ( 'all of 2d scan forward model' )
    end if

    call trace_end ( 'TwoDScanForwardModel MAF=', fmStat%maf, &
      & cond=toggle(emit) )

  contains
    ! ..................................................  SayTime  .....
    subroutine SayTime ( What )
      character(len=*), intent(in) :: What
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for " // what // " = " )
      call output ( dble(t2 - t1), advance = 'yes' )
    end subroutine SayTime

    ! ................................................  Z_surface  .....
    real(rp) function Z_surface ( z_basis, t_values, g_ref, h_ref, z_ref, boltz, &
      & threshold, maxiterations )
! finds the surface pressure
      use Sparse_Eta_m, only: Sparse_Eta_t
! inputs:
      real(rp), intent(in) :: Z_basis(:) ! zeta basis for temperature
      real(rp), intent(in) :: T_values(:) ! temperature coefficients
      real(rp), intent(in) :: G_ref      ! reference acceloration at the surface
      real(rp), intent(in) :: H_ref      ! reference geopotential
      real(rp), intent(in) :: Z_ref      ! reference zeta for h_ref
      real(rp), intent(in) :: Boltz      ! k*ln10/m in your favorite units
! note that the units of h_ref, g_ref, and boltz must be consistent
      real(rp), optional, intent(in) :: Threshold ! zeta convergence criteria
      integer, optional, intent(in) :: MaxIterations ! maximum number of
!                                  iterations
! This is a one dimensional calculation where g_ref is assumed to apply
! throughout the entire vertical range of t_basis.
! internals
      integer :: Iter
      integer :: MaxIter

      type(sparse_eta_t) :: Eta
      real(rp) :: GHB                    ! g_ref * h_ref / boltz
      real(rp) :: PIQ(1,size(z_basis))
      real(rp) :: Thresh
      real(rp) :: Z_old(1)

! begin code
      maxiter = 10
      thresh = 0.0001_rp
      if ( present(maxiterations) ) maxiter = maxiterations
      if ( present(threshold) ) thresh = threshold

! intitial guess
      ghb = g_ref * h_ref / boltz
      z_old = z_ref - ghb / t_values(1)

      iter = 0
      do
        call piq_int ( z_old, z_basis, z_ref, piq )
        call eta%eta ( z_basis, z_old, empty=.true. )
! correct
        z_surface = z_old(1) - (ghb + dot_product(piq(1,:),t_values)) / &
                             & eta%row_dot_vec(1,t_values)

        iter = iter + 1
        if ( abs(z_surface - z_old(1)) < thresh .or. iter >= maxiter ) exit
        z_old = z_surface
      end do
      if (Timing) call output( 'Num iterations in z_surface: ', advance='no')
      if (Timing) call output( iter, advance='yes')
    end function Z_surface

  end subroutine TwoDScanForwardModel

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ScanModelModule.f90,v 2.94 2018/12/13 01:45:28 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ScanModelModule

! $Log: ScanModelModule.f90,v $
! Revision 2.94  2018/12/13 01:45:28  vsnyder
! More QTM work -- hopefully the last of it
!
! Revision 2.93  2018/12/04 23:22:33  vsnyder
! Add QTM horizontal interpolation.  Spell outputNamedValue correctly.
!
! Revision 2.92  2018/11/30 00:13:28  pwagner
! Resets gph to Fill Values where Temperatures do, too
!
! Revision 2.91  2018/11/01 00:43:21  vsnyder
! Make sure there are no uninitialized elements of Jacobian blocks
!
! Revision 2.90  2018/10/30 20:59:14  vsnyder
! Completely revised.  Use sparse interpolators.  Convert allocatable
! variables to automatic variables.
!
! Revision 2.89  2017/08/10 22:44:12  pwagner
! Exit witth eror message if buggy 1s Scan Model called

! Revision 2.88  2016/08/12 00:31:25  pwagner
! Seems to restore tthe gold brick

! Revision 2.87  2016/08/09 18:46:16  pwagner
! Survives encounter with non-satellite data

! Revision 2.86  2016/01/23 02:59:18  vsnyder
! Get MexRefraction from refraction_m, not geometry.  Get refractive index
! derivatives from refraction_m instead of computing them here.  Add LaTeX.

! Revision 2.85  2015/09/24 22:06:36  pwagner
! Code around segment fault due to NAG bug

! Revision 2.84  2015/08/25 17:35:56  vsnyder
! PhiWindow is a tuple, with the first element specifying the angles or
! number of profiles/MAFs before the tangent point, and the second
! specifying the angles or number after.

! Revision 2.83  2015/06/19 21:15:50  pwagner
! Maneuvers around calculation of ITSS; buggy NAG sometimes segment faults here

! Revision 2.82  2015/06/04 03:14:14  vsnyder
! Make Surfs component of quantity template allocatable

! Revision 2.81  2014/07/18 23:17:59  pwagner
! Aimed for consistency in names passed to allocate_test

! Revision 2.80  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput

! Revision 2.79  2013/08/31 02:29:12  vsnyder
! Replace MLSMessageCalls with trace_begin and trace_end

! Revision 2.78  2013/08/30 02:45:47  vsnyder
! Revise calls to trace_begin and trace_end

! Revision 2.77  2013/06/12 02:38:33  vsnyder
! Cruft removal

! Revision 2.76  2013/03/01 01:11:10  pwagner
! Added DumpInstanceWindows

! Revision 2.75  2012/06/06 20:13:37  vsnyder
! Avoid overflow if ptan is bogus because module is turned off

! Revision 2.74  2012/04/20 01:54:20  vsnyder
! Remove GeocLat from Get2DHydrostaticTangentPressure, make EarthRadius
! automatic.  Add some dumps.  Print a warning if the initial pressure
! guess is <-4 or >10.  Probably still gets overflows if the module is turned
! off.  More tracing.

! Revision 2.73  2011/05/09 18:25:12  pwagner
! Converted to using switchDetail

! Revision 2.72  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away

! Revision 2.71  2009/05/13 20:41:55  vsnyder
! Get constants from Constants, kinds from MLSKinds

! Revision 2.70  2007/08/20 22:06:08  pwagner
! Two procedures now push their names onto MLSCallStack

! Revision 2.69  2007/07/25 20:08:46  vsnyder
! Delete declaration for unused variable

! Revision 2.68  2007/06/29 19:32:07  vsnyder
! Make ForwardModelIntermediate_t private to ScanModelModule

! Revision 2.67  2006/12/13 01:33:08  vsnyder
! Use slightly faster get_eta_sparse

! Revision 2.66  2006/08/05 02:36:06  vsnyder
! Delete unused symbols

! Revision 2.65  2006/08/05 02:12:27  vsnyder
! Add ForWhom argument to ConstructVectorTemplate

! Revision 2.64  2006/08/02 20:10:56  vsnyder
! Use deallocate_test for myR and myRT, for leak tracking

! Revision 2.63  2006/04/03 20:23:46  pwagner
! Preserve correct sign for GPH Precision

! Revision 2.62  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id

! Revision 2.61  2004/03/20 04:05:23  vsnyder
! Moved Boltz from units to physics

! Revision 2.60  2003/08/15 23:58:20  vsnyder
! Get PHYQ_... directly from Intrinsic instead of indirectly via Units

! Revision 2.59  2003/03/19 19:24:10  pwagner
! Prints timing info when necessary; speedup of TwoDScanForwardModel despite terrible NAG memory management

! Revision 2.58  2003/02/18 23:59:28  livesey
! Added phiWindow stuff for hydrostatic fill

! Revision 2.57  2003/02/13 01:15:39  bill
! made reference geopotential height calculation constants the same as those used in the hydrostatic calcs

! Revision 2.56  2003/02/12 22:46:49  bill
! fixed mass correction integrations

! Revision 2.55  2003/01/31 22:30:56  livesey
! Got rid of a print statement

! Revision 2.54  2003/01/26 04:43:15  livesey
! Changed to handle units for phiWindow

! Revision 2.53  2003/01/16 23:13:35  livesey
! Now gets MaxRefraction (smaller value) from Geometry

! Revision 2.52  2002/11/22 12:22:41  mjf
! Use getQuantityForForwardModel instead of GetVectorQuantityByType.

! Revision 2.51  2002/10/25 22:24:54  livesey
! Two bug fixes with the h2o stuff

! Revision 2.50  2002/10/16 20:13:55  mjf
! Added GetGPHPrecision, based on GetBasisGPH.

! Revision 2.49  2002/10/08 17:36:22  pwagner
! Added idents to survive zealous Lahey optimizer

! Revision 2.48  2002/09/27 01:47:45  vsnyder
! Move some USEs from module scope to procedure scope.  Move parameters from
! module scope to procedure scope.  Simplify iteration in z_surface.
! Convert some variables from pointers to automatic arrays.  Cosmetic changes.

! Revision 2.47  2002/09/27 00:01:16  vsnyder
! Remove unused variables and dead calculations

! Revision 2.46  2002/09/26 23:48:21  vsnyder
! Avoid computing sine and cosine of the same angle

! Revision 2.45  2002/09/26 20:38:19  vsnyder
! Get some constants from Geometry and Units instead of declaring them, cosmetics

! Revision 2.44  2002/06/27 00:20:43  livesey
! Typo!

! Revision 2.43  2002/06/27 00:19:26  livesey
! Fixed another log h2o

! Revision 2.42  2002/06/26 23:37:27  livesey
! Tidied up dumps.

! Revision 2.41  2002/06/26 23:29:52  bill
! fixed residual calculation bug--wgr

! Revision 2.40  2002/06/26 20:59:25  livesey
! Fixed bug in 2d pressure guesser, was ignoring very first guess

! Revision 2.39  2002/06/26 19:18:53  livesey
! Merge of Bills fixes and my diagnostics

! Revision 2.38  2002/06/26 18:44:12  bill
! added a feature to limit the index of refraction to its surface value--wgr

! Revision 2.37  2002/06/26 01:26:10  livesey
! Added 2D pressure guesser

! Revision 2.36  2002/06/25 22:17:09  bill
! doesn't store blocks of zeros--wgr

! Revision 2.35  2002/06/25 21:55:49  bill
! first debugged? version of 2d scan module--wgr

! Revision 2.34  2002/06/25 17:03:30  bill
! fixed p4 calc in pressure guesser--wgr

! Revision 2.33  2002/06/25 14:55:15  bill
! work in progress--wgr

! Revision 2.32  2002/06/25 00:01:32  bill
! work in progress--wgr

! Revision 2.31  2002/06/24 18:27:02  livesey
! Debugging

! Revision 2.30  2002/06/24 17:55:41  bill
! added a two d scan model subroutine--wgr

! Revision 2.29  2002/06/05 00:00:29  livesey
! Typo fixed

! Revision 2.28  2002/02/13 00:08:58  livesey
! Added differential scan model

! Revision 2.27  2001/12/06 23:44:57  livesey
! Moved Omega into units so L1BOASim can use it.

! Revision 2.26  2001/11/03 01:33:47  livesey
! Changed the togle from gen to emit

! Revision 2.25  2001/10/02 16:49:56  livesey
! Removed fmStat%finished and change loop ordering in forward models

! Revision 2.24  2001/06/29 23:03:28  livesey
! Whoops, bad parameter set.

! Revision 2.23  2001/06/19 22:43:23  pwagner
! Eliminated l_temperature from things got from init_tables_module

! Revision 2.22  2001/06/04 22:42:36  livesey
! Gets belowRef from intermediate

! Revision 2.21  2001/05/10 00:46:49  livesey
! Changed else where to elsewhere (NAG problem?)

! Revision 2.20  2001/05/09 17:43:44  vsnyder
! Use UpdateDiagonal to store PTAN derivatives; cosmetic changes

! Revision 2.19  2001/05/08 19:43:57  livesey
! Pretty stable version.  Pressure now converges better.  Caught a few
! more gremlins in d(residual)/dT.

! Revision 2.18  2001/05/08 03:05:05  livesey
! Working version, pressure guesser a little unstable in extreme cases

! Revision 2.17  2001/05/05 00:03:30  livesey
! Close to working.  One last part of the temperature derivatives that disagrees with
! numerical calculation.

! Revision 2.16  2001/05/04 05:41:26  livesey
! Added some more conditions for derivative calculation

! Revision 2.15  2001/05/04 05:05:46  livesey
! The scan calculation works in ScanModel, haven't tested the
! derivatives yet though.

! Revision 2.14  2001/05/03 23:42:57  livesey
! Closer to working

! Revision 2.13  2001/05/03 23:09:52  livesey
! First version of scan model.  Compiles, but probably doesn't run.

! Revision 2.12  2001/05/03 20:34:08  vsnyder
! Cosmetic changes

! Revision 2.11  2001/04/21 00:52:24  livesey
! Fixed memory leak.

! Revision 2.10  2001/04/10 22:27:47  vsnyder
! Nullify explicitly instead of with <initialization> so as not to give
! pointers the SAVE attribute.  <initialization> is NOT executed on each
! entry to a procedure.

! Revision 2.9  2001/04/03 19:03:07  vsnyder
! Get L_H2O from Molecules -- can't get it from Intrinsic after the order of
! Molecules and Intrinsic was reversed.

! Revision 2.8  2001/03/20 21:43:41  livesey
! Moved geodtogeoc lat to geometry in lib

! Revision 2.7  2001/03/15 23:31:15  livesey
! Made it default private.

! Revision 2.6  2001/03/07 22:42:38  livesey
! Got pressure guesser working

! Revision 2.5  2001/03/06 00:34:54  livesey
! Pretty good version

! Revision 2.4  2001/03/05 01:20:26  livesey
! Interim version

! Revision 2.3  2001/02/28 17:35:36  livesey
! Added RCS log stuff

@


2.94
log
@More QTM work -- hopefully the last of it
@
text
@d1540 1
d1613 2
a1765 1

a1768 1

d1798 1
a1804 1

d1821 6
a1826 2
          call eta_p_h2o%row_dot_matrix ( 1, h2o%values, surf_h2o, &
                                        & logOnly = .true., rows=eta_at_z_surf )
d1847 1
d1911 1
d1951 4
d2091 1
a2091 1
       "$Id: ScanModelModule.f90,v 2.93 2018/12/04 23:22:33 vsnyder Exp $"
d2101 3
@


2.93
log
@Add QTM horizontal interpolation.  Spell outputNamedValue correctly.
@
text
@d1549 1
d1602 4
a1605 7
    type(sparse_eta_t) :: Eta_Z
    type(sparse_eta_t) :: Eta_P_T
    type(sparse_eta_t) :: Eta_P_H2O
    type(sparse_eta_t) :: Eta_ZXP_T
    type(sparse_eta_t) :: Eta_ZXP_H2O
    type(sparse_eta_t) :: Eta_At_One_Phi
    type(sparse_eta_t) :: Eta_At_One_Zeta
d1704 1
d1739 1
a1739 1
        sinlat2 = SIN(geoclats)**2
d1744 1
a1744 1
        earth_radius = SQRT((earthrada**4*cosphi2 + earthradc**2*sinphi2) &
a1753 1
      ! deallocate things we don't need
d1756 11
a1766 20
      ! Get horizontal Eta functions.
      if ( usingQTM) then
        ! Use phitan%template%geodLat(:,fmConf%MAF) and
        ! phitan%template%lon(:,fmConf%MAF) to find QTM
        ! facets and compute interpolation coefficients.
        call eta_p_t%eta_QTM ( temp%template%the_Hgrid%QTM_Tree, &
                             & phitan%template%lon(:,fmStat%maf), &
                             & phitan%template%geodLat(:,fmStat%maf), &
                             & what=l_temperature )
        call eta_p_h2o%eta_QTM ( h2o%template%the_Hgrid%QTM_Tree, &
                               & phitan%template%lon(:,fmStat%maf), &
                               & phitan%template%geodLat(:,fmStat%maf), &
                               & what=l_h2o )
      else
        ! Eta_p_*%Eta_1D allocates components -- no need to call eta_p_*%create
        call eta_p_t%eta_1d ( temp%template%phi(1,windowstart_t:windowfinish_t), &
                            & phitan%values(:,fmStat%maf), sorted=.false. )
        call eta_p_h2o%eta_1d ( h2o%template%phi(1,windowstart_h2o:windowfinish_h2o), &
                              & phitan%values(:,fmStat%maf), sorted=.false. )
      end if
d1768 1
a1768 5
      ! compute temperature function
      ! Get remaining eta functions.
      call eta_z%eta_1d ( temp%template%surfs(:,1), &
                        & ptan%values(:,fmStat%maf), sorted=.false. )
      if ( timing ) call sayTime ( 'getting etas functions' )
d1770 1
d1776 1
d1780 1
a1785 4
      tan_temp = 0.0_rp
      call eta_zxp_t%eta_nd ( eta_z, eta_p_t )
      call eta_zxp_t%sparse_dot_vec ( &
        & temp%values(:,windowstart_t:windowfinish_t), tan_temp )
d1793 3
a1795 16
    ! compute water vapor function
      call eta_z%empty ! Remove temperature's vertical interpolation coefficients
      call eta_z%eta_1d ( h2o%template%surfs(:,1), &
                        & ptan%values(:,fmStat%maf), empty=.true., sorted=.false. )
      call eta_zxp_h2o%eta_nd ( eta_z, eta_p_h2o )
      ! we use logarithmic interpolation here:
      ! tan_h2o = exp( eta_zxp_h2o .dot. log(max(h2o%values,1.0e-9_rp)) )
      call eta_zxp_h2o%sparse_dot_vec ( &
        & h2o%values(:,windowstart_h2o:windowfinish_h2o), &
        & tan_h2o, expLog = .true. )
      if ( timing ) call sayTime ( 'computing water vapor functions' )
      call time_now ( t1 )
    ! compute refractive index
      call refractive_index ( 10.0_rp**(-max(-10.0_rp,ptan%values(:,fmStat%maf))), &
        & tan_temp, tan_refr_indx, h2o_path = tan_h2o )
    ! compute surface pressure
d1797 3
a1799 8
        real(rp) :: temp_at_surf_phi(temp%template%nosurfs)
        call eta_at_one_phi%eta_1d ( &
          & temp%template%phi(1,windowstart_t:windowfinish_t), &
          & phitan%values(1:1,fmStat%maf) )
        do sv_z = 1, temp%template%nosurfs
        temp_at_surf_phi(sv_z) = eta_at_one_phi%row_dot_vec ( 1, &
          & temp%values(sv_z,windowstart_t:windowfinish_t) )
        end do
d1801 4
a1804 1
        z_surf = z_surface( temp%template%surfs(:,1),temp_at_surf_phi,g_ref(1), &
d1806 4
a1809 10
      ! compute refractive index at the surface
        call eta_at_one_zeta%eta_1d ( temp%template%surfs(:,1), [z_surf] )
        surf_temp = eta_at_one_zeta%row_dot_vec ( 1, temp_at_surf_phi )
      end block
      call eta_at_one_phi%eta_1d ( &
        & h2o%template%phi(1,windowstart_h2o:windowfinish_h2o), &
        & phitan%values(1:1,fmStat%maf), empty=.true. )
      call eta_at_one_zeta%eta_1d ( h2o%template%surfs(:,1), [z_surf], empty=.true. )
      block
        real(rp) :: Surf_H2O(h2o%template%nosurfs)
d1811 2
a1812 5
        ! First surf_h2o = eta_at_one_phi .dot. log(max(h2o%values,1.0e-9_rp)),
        ! then h2o_path = exp(eta_at_one_zeta .dot. surf_h2o)
        call eta_at_one_phi%sparse_dot_vec ( &
          & h2o%values(:,windowstart_h2o:windowfinish_h2o), &
          & surf_h2o, logOnly = .true. )
d1814 17
a1830 19
        do sv_z = 1, h2o%template%nosurfs
          if ( eta_at_one_zeta%cols(sv_z) /= 0 ) then
            ! Surf_H2O will be an operand in a dot product with Eta_At_One_Zeta,
            ! so we only need it where Eta_At_One_Zeta has a nonzero column
            surf_h2o(sv_z) = 0
            do e = 1, eta_at_one_phi%ne
              sv_p = eta_at_one_phi%e(e)%c + windowStart_h2o - 1
              ! Each element of Surf_H2O is the dot product of eta_at_one_phi with the
              ! corresponding row of the logarithm of H2O%Values.  We do this "the
              ! hard way" to avoid computing the logarithm of all of H2O%Values and
              ! then use only the ones corresponding to nonzeroes of eta_at_one_phi.
              surf_h2o(sv_z) = surf_h2o(sv_z) + &
                & eta_at_one_phi%e(e)%v * LOG(max(h2o%values(sv_z,sv_p),1e-9_rp))
            end do
          end if
        end do
        call refractive_index(10.0_rp**([ -z_surf ]), [ surf_temp ], &
          & surf_refr_indx, &
          & h2o_path = [ EXP(eta_at_one_zeta%row_dot_vec(1,surf_h2o)) ] )
d2080 1
a2080 1
       "$Id: ScanModelModule.f90,v 2.92 2018/11/30 00:13:28 pwagner Exp $"
d2090 3
@


2.92
log
@Resets gph to Fill Values where Temperatures do, too
@
text
@d310 1
a310 1
        if ( DEEBUG ) call ouputNamedValue ( 'instance', instance )
d314 1
a314 1
        if ( DEEBUG ) call ouputNamedValue ( 'upper -999.99 surf', surf )
d318 1
a318 1
        if ( DEEBUG ) call ouputNamedValue ( 'lower -999.99 surf', surf )
d1541 3
d1553 1
a1553 1
    type (ForwardModelConfig_T), intent(in) :: FmConf ! Configuration options
d1568 1
d1579 2
a1580 2
    logical :: TempInState           ! Set if temp in state not extra
    logical :: RefGPHInState         ! Set if refGPH in state not extra
d1582 2
a1583 1
    logical :: PTANInState           ! Set if ptan in state, not extra
d1603 1
a1603 1
    type(sparse_eta_t) :: Eta_P_h2o
d1612 1
a1612 2
    logical, parameter :: total_times = .true.
    integer :: isurf
d1651 26
a1676 7
  ! get window
    call FindInstanceWindow ( temp, phitan, fmStat%maf, FMConf%phiWindow, &
      & FMConf%windowUnits, windowstart_t, windowfinish_t )
    call FindInstanceWindow( h2o, phitan, fmStat%maf, FMConf%phiWindow, &
      & FMConf%windowUnits, windowstart_h2o, windowfinish_h2o )
     ! if( timing ) print *, 'T window  : ', windowstart_t, windowfinish_t
     ! if( timing ) print *, 'H2O window: ', windowstart_h2o, windowfinish_h2o
d1706 1
a1706 1
      block ! So that some more local arrays are automatic
d1757 24
a1780 4
    ! compute temperature function
      ! get eta functions
      call eta_p_t%eta_1d ( temp%template%phi(1,windowstart_t:windowfinish_t), &
                          & phitan%values(:,fmStat%maf), sorted=.false. )
d1790 1
a1790 1
    ! convert level 1 reference geopotential height into geometric altitude
d1810 1
a1810 2
      call eta_p_h2o%eta_1d ( h2o%template%phi(1,windowstart_h2o:windowfinish_h2o), &
                            & phitan%values(:,fmStat%maf), sorted=.false. )
d2122 1
a2122 1
       "$Id: ScanModelModule.f90,v 2.91 2018/11/01 00:43:21 vsnyder Exp $"
d2132 3
@


2.91
log
@Make sure there are no uninitialized elements of Jacobian blocks
@
text
@d161 11
a171 2
    ! This function takes a state vector, containing one and only one
    ! temperature and reference geopotential height quantity, and returns
d214 1
d306 16
d2080 1
a2080 1
       "$Id: ScanModelModule.f90,v 2.90 2018/10/30 20:59:14 vsnyder Exp $"
d2090 3
@


2.90
log
@Completely revised.  Use sparse interpolators.  Convert allocatable
variables to automatic variables.
@
text
@d42 1
a42 1
    & CreateEmptyMatrix, DestroyMatrix, ClearMatrix
d1511 2
a1512 2
  subroutine TwoDScanForwardModel ( fmConf, state, extra, fwmOut, &
                                  & fmStat, Jacobian, chunkNo )
d1524 1
a1524 1
    type (ForwardModelConfig_T), intent(in) :: FMConf ! Configuration options
d1528 2
a1529 2
    type (Vector_T), intent(inout) :: FWMOut ! Output vector, residual filled
    type (ForwardModelStatus_T), intent(inout) :: FMStat ! Which maf etc.
d1531 1
a1531 1
    integer, intent(in), optional :: chunkNo
d1865 2
a1866 1
            !  \frac{k}{g_0} \, \eta_{z \times p}^T \cdot T \,\times\, $mass\_corr
d1872 1
d1893 1
a1893 1
              call CreateBlock ( jacobian, row, col, M_Full )
d1900 3
d1905 3
a1907 2
            sv_p = eta_p_t%e(e)%c + windowstart_t - 1
            blocks(sv_p)%b%values(r,1) =  work(r) * eta_p_t%e(e)%v
d1911 1
a1911 1
            do sv_p = windowstart_t, windowfinish_t
d1938 1
a1938 1
                call CreateBlock ( jacobian, row, col, M_Full )
d1943 5
d1958 1
a1958 1
              do sv_p = windowstart_t, windowfinish_t
d2054 1
a2054 1
       "$Id: ScanModelModule.f90,v 2.89 2017/08/10 22:44:12 pwagner Exp $"
d2064 4
@


2.89
log
@Exit witth eror message if buggy 1s Scan Model called
@
text
@d31 1
a31 1
  use Geometry, only: Earthrada, Earthradb, Earthsurfacegph, Geodtogeoclat, &
a96 2
    use Allocate_Deallocate, only: Deallocate_Test

d138 1
a138 1
    endif
d156 1
a156 1
    call outputNamedValue ( 'Instance Window', (/ instLow, instHigh /) )
d213 1
a213 1
      &            verticalCoordinate=(/l_Zeta/)) ) .or. &
d218 1
a218 1
      &            verticalCoordinate=(/l_Zeta/)) ) ) &
d242 1
a242 1
       myRT(:,instance) = myR * temp%values(:,instance)
d247 1
a247 1
!       deltaGeopot = (ln10/ (2*g0) ) * &
d250 3
a252 3
       deltaGeopot = ( myRT(surf,:) + myRT(surf-1,:) ) * &
         & ( logP(surf) - logP(surf-1) ) / (2.0_r8 * g0)
       gph(surf,:) = gph(surf-1,:) + deltaGeopot
d272 1
a272 1
    currentRefGPH = gph(myBelowRef,:) + ((basisGap)/(2.0_r8 * g0))* &
d284 1
a284 1
       R=>myR
d286 1
a286 1
       call deallocate_test ( myR, 'myR', moduleName )
d290 1
a290 1
       rt=>myRT
d292 1
a292 1
        call deallocate_test ( myRT, 'myRT', moduleName )
d324 2
a325 2
    REAL(r8), parameter :: c_mass = 0.02_rp ! mass reduction coefficient
    REAL(r8), parameter :: basiscutoff = 2.5_rp ! zeta where mass reduction begins
d339 1
a339 1
      & tempPrec%template%noInstances) :: DMYRT_DT   ! d(R*T)/dT
d341 1
a341 1
      & tempPrec%template%noInstances) :: DCURRENTREFGPH_DT ! From 1st calc
d343 1
a343 1
      & tempPrec%template%noInstances) :: DCORRECTION_DT ! To apply to dgph_dT
d345 1
a345 1
      & tempPrec%template%noInstances) :: DDELTAGEOPOT_DT ! 
d348 1
a348 1
      & tempPrec%template%noInstances) :: DGPH_DT ! 
d350 1
a350 1
      & tempPrec%template%noInstances) :: DGPH_DREFGPH ! 
d353 1
a353 1
      & tempPrec%template%noInstances) :: GPHPREC2 ! squared PGH precision
d355 1
a355 1
      & tempPrec%template%noInstances) :: GPHPREC2A ! squared PGH precision (alt)
d361 2
a362 2
    integer :: MYBELOWREF               ! Result of a hunt
    real (r8) :: ABOVEREFWEIGHT         ! Interpolation weight
d364 2
a365 2
    integer :: INSTANCE                 ! Loop counter
    integer :: SURF                     ! Loop counter
d368 4
a371 4
    real (r8) :: REFLOGP                ! Log p of pressure reference surface
    real (r8) :: BASISGAP               ! Space between adjacent surfaces
    integer, dimension( max(1,size(GPHPREC, 1)), max(1,size(GPHPREC, 2)) ) &
      &       :: ITSSIGN                ! < 0 if tempprec or refgphprec are
d373 1
a373 1
    logical :: DEEBUG
d376 1
a376 1
    DEEBUG = .false. ! ( TimesHere > 1 )
d384 1
a384 1
      &            verticalCoordinate=(/l_Zeta/)) ) .or. &
d389 1
a389 1
      &            verticalCoordinate=(/l_Zeta/)) ) ) &
d402 1
a402 1
    endif
d422 1
a422 1
         & ( logP(surf) - logP(surf-1) ) / (2.0_r8 * g0)
d444 1
a444 1
    dcurrentRefGPH_dT = dgph_dT(myBelowRef,:,:) + ((basisGap)/(2.0_r8*g0))* &
d470 1
a470 1
    endif
d473 1
a473 1
    ITSSIGN  = 1
d486 1
a486 1
      endif
d488 2
a489 2
        ITSSIGN(:, instance) = -1
      elseif ( all( TPrecVals >= 0._rv ) ) then
d491 1
a491 1
      elseif ( refGPHPrec%values(1,instance) >= 0._rv ) then
d498 1
a498 1
        endif
d503 1
a503 1
          endif
d508 1
a508 1
          enddo
d512 2
a513 2
          enddo
        endif
d519 1
a519 1
        endif
d525 1
a525 1
          elseif ( surf == myBelowRef ) then
d528 1
a528 1
          elseif ( &
d531 1
a531 1
          endif
d533 1
a533 1
      endif
d539 1
a539 1
    ! endif
d569 2
a570 2
    type (VectorValue_T), intent(in) :: TEMP ! Temperature
    type (VectorValue_T), intent(in) :: REFGPH ! Reference GPH
d572 3
a574 3
    type (VectorValue_T), intent(in) :: ORBINCL ! Inclination
    type (VectorValue_T), intent(in) :: PHITAN ! Tangent phi
    type (VectorValue_T), intent(in) :: GEOCALT ! L1B Tp Geoc alt.
d594 2
a595 2
    type (ForwardModelConfig_T) :: FMCONF
    type (ForwardModelStatus_T) :: FMSTAT
d622 1
a622 1
    elseif ( size(orbIncl%values) < 1 ) then
d627 1
a627 1
    endif
d651 1
a651 1
    myQTs = (/ ptan%template, temp%template, refGPH%template, &
d653 1
a653 1
      & geocAlt%template, scanResidual /) 
d656 1
a656 1
    call ConstructVectorTemplate ( 0, myQTs, (/1/), stateTemplate, forWhom=moduleName )
d658 1
a658 1
    call ConstructVectorTemplate ( 0, myQTs, (/2,3,4,5,6,7/),  extraTemplate, forWhom=moduleName )
d660 1
a660 1
    call ConstructVectorTemplate ( 0, myQTs, (/8/), residualTemplate, forWhom=moduleName )
d734 5
a738 5
    type (VectorValue_T), intent(in), target :: TEMP    ! Temperature
    type (VectorValue_T), intent(in) :: REFGPH  ! Reference GPH
    type (VectorValue_T), intent(in), target :: H2O     ! H2O
    type (VectorValue_T), intent(in) :: GEOCALT ! L1B Tp Geoc alt.
    integer, intent(IN) :: MAXITERATIONS        ! Number of iterations to use
d743 1
a743 1
    real (r8), dimension(:,:), pointer :: BASISGPH     ! temp(noSurfs,noInstances)
d745 34
a778 33
    real (r8), dimension(:), pointer :: ACOEFF         ! Quadratic term
    real (r8), dimension(:), pointer :: BASISLOWER     ! For temperature
    real (r8), dimension(:), pointer :: BASISSPACING   ! For temperature
    real (r8), dimension(:), pointer :: BASISUPPER     ! For temperature
    real (r8), dimension(:), pointer :: BCOEFF         ! Quadratic term
    real (r8), dimension(:), pointer :: CCOEFF         ! Quadratic term
    real (r8), dimension(:), pointer :: DELTART 
    real (r8), dimension(:), pointer :: EARTHRADIUS
    real (r8), dimension(:), pointer :: GEOCLAT
    real (r8), dimension(:), pointer :: GEOMETRICGPH
    real (r8), dimension(:), pointer :: H2OBASIS ! Points to h2o basis
    real (r8), dimension(:), pointer :: H2OVALS ! Points to part of h2o
    real (r8), dimension(:), pointer :: N              ! Refractive index
    real (r8), dimension(:), pointer :: P2
    real (r8), dimension(:), pointer :: P4
    real (r8), dimension(:), pointer :: POINTINGH2O    ! t.p. h2o
    real (r8), dimension(:), pointer :: POINTINGPRES ! t.p. press
    real (r8), dimension(:), pointer :: POINTINGTEMP   ! t.p. temp.
    real (r8), dimension(:), pointer :: PTANVALS       ! Points to part of ptan
    real (r8), dimension(:), pointer :: RATIO2         ! minor frame
    real (r8), dimension(:), pointer :: RATIO4         ! minor frame
    real (r8), dimension(:), pointer :: REFRACTEDGEOCALT ! minor frame
    real (r8), dimension(:), pointer :: RTLOWER
    real (r8), dimension(:), pointer :: RTUPPER
    real (r8), dimension(:), pointer :: S2
    real (r8), dimension(:), pointer :: TEMPBASIS ! Points to temp basis
    real (r8), dimension(:), pointer :: TEMPVALS ! Points to part of temp
    real (r8), dimension(:), pointer :: THISBASISGPH ! Points to part of basisGPH

    integer, dimension(:), pointer :: CLOSESTTEMPPROFILES
    integer, dimension(:), pointer :: CLOSESTH2OPROFILES
    integer, dimension(:), pointer :: LOWER ! index into temperature profile
    integer, dimension(:), pointer :: UPPER ! index into temperature profile
d780 2
a781 2
    integer :: iteration                ! Loop stuff
    integer :: maf                      ! Loop counter
a787 6
    nullify ( aCoeff, basisGPH, basisLower, basisSpacing, basisUpper, &
      & bCoeff, cCoeff, closestH2OProfiles, closestTempProfiles, deltaRT, &
      & earthRadius, geocLat, geometricGPH, lower, n, &
      & pointingH2O, pointingPres, pointingTemp, ratio2, ratio4, &
      & refractedGeocAlt, rt, rtLower, rtUpper, upper, s2, p2, p4 )

d793 1
a793 1
      &            verticalCoordinate=(/l_Zeta/)) ) .or. &
d798 1
a798 1
      &            verticalCoordinate=(/l_Zeta/)) ) .or. &
d803 1
a803 1
      &            verticalCoordinate=(/l_Zeta/)) ) ) &
a806 36
    ! Allocate temporary arrays
    call Allocate_Test ( basisGPH, temp%template%noSurfs, temp%template%noInstances, &
      & "basisGPH", ModuleName )
    call Allocate_Test ( earthRadius, ptan%template%noSurfs, &
      "earthRadius", ModuleName )
    call Allocate_Test ( geocLat, ptan%template%noSurfs, &
      "geocLat", ModuleName )
    call Allocate_Test ( s2, ptan%template%noSurfs, "s2", ModuleName )
    call Allocate_Test ( p2, ptan%template%noSurfs, "p2", ModuleName )
    call Allocate_Test ( p4, ptan%template%noSurfs, "p4", ModuleName )
    call Allocate_Test ( aCoeff, ptan%template%noSurfs, "aCoeff", ModuleName )
    call Allocate_Test ( rtLower, ptan%template%noSurfs, "rtLower", ModuleName )
    call Allocate_Test ( rtUpper, ptan%template%noSurfs, "rtUpper", ModuleName )
    call Allocate_Test ( basisLower, ptan%template%noSurfs, "basisLower", ModuleName )
    call Allocate_Test ( basisUpper, ptan%template%noSurfs, "basisUpper", ModuleName )
    call Allocate_Test ( basisSpacing, ptan%template%noSurfs, "basisSpacing", ModuleName )
    call Allocate_Test ( bCoeff, ptan%template%noSurfs, "bCoeff", ModuleName )
    call Allocate_Test ( cCoeff, ptan%template%noSurfs, "cCoeff", ModuleName )
    call Allocate_Test ( deltaRT, ptan%template%noSurfs, "deltaRT", ModuleName )
    call Allocate_Test ( geometricGPH, ptan%template%noSurfs, &
      "geometricGPH", ModuleName )
    call Allocate_Test ( n, ptan%template%noSurfs, "n", ModuleName )
    call Allocate_Test ( pointingH2O, ptan%template%noSurfs, "pointingH2O", ModuleName )
    call Allocate_Test ( pointingPres, ptan%template%noSurfs, "pointingpres", ModuleName )
    call Allocate_Test ( pointingTemp, ptan%template%noSurfs, "pointingTemp", ModuleName )
    call Allocate_Test ( ratio2, ptan%template%noSurfs, "ratio2", ModuleName )
    call Allocate_Test ( ratio4, ptan%template%noSurfs, "ratio4", ModuleName )
    call Allocate_Test ( refractedGeocAlt, ptan%template%noSurfs, &
      & "refractedGeocAlt", ModuleName )
    call Allocate_Test ( closestTempProfiles, ptan%template%noInstances, &
      "closestTempProfiles", ModuleName )
    call Allocate_Test ( closestH2OProfiles, ptan%template%noInstances, &
      "closestH2OProfiles", ModuleName )
    call Allocate_Test ( lower, ptan%template%noSurfs, "lower", ModuleName )
    call Allocate_Test ( upper, ptan%template%noSurfs, "upper", ModuleName )

d808 1
d873 1
a873 1
          geometricGPH = -(GM/(refractedGeocAlt*g0))*&
d875 1
a875 1
            ((omega*refractedGeocAlt*cos(geocLat))**2)/(2*g0)+earthSurfaceGPH
d898 1
a898 1
            & (g0 / (ln10*rtLower))
d904 1
a904 1
            & (g0 / (ln10*rtUpper))
d910 2
a911 2
          cCoeff = -2*g0*(geometricGPH-thisBasisGPH(lower)) / &
            & (basisSpacing*ln10)
a921 30
    ! Deallocate all the various things
    call Deallocate_Test ( basisGPH, "basisGPH", ModuleName )
    call Deallocate_Test ( aCoeff, "aCoeff", ModuleName )
    call Deallocate_Test ( rtLower, "rtLower", ModuleName )
    call Deallocate_Test ( rtUpper, "rtUpper", ModuleName )
    call Deallocate_Test ( basisLower, "basisLower", ModuleName )
    call Deallocate_Test ( basisUpper, "basisUpper", ModuleName )
    call Deallocate_Test ( basisSpacing, "basisSpacing", ModuleName )
    call Deallocate_Test ( bCoeff, "bCoeff", ModuleName )
    call Deallocate_Test ( cCoeff, "cCoeff", ModuleName )
    call Deallocate_Test ( deltaRT, "deltaRT", ModuleName )
    call Deallocate_Test ( earthRadius, "earthRadisu", ModuleName )
    call Deallocate_Test ( geocLat, "geocLat", ModuleName )
    call Deallocate_Test ( p2, "p2", ModuleName )
    call Deallocate_Test ( p4, "p4", ModuleName )
    call Deallocate_Test ( s2, "s2", ModuleName )
    call Deallocate_Test ( geometricGPH, "geometricGPH", ModuleName )
    call Deallocate_Test ( n, "n", ModuleName )
    call Deallocate_Test ( pointingH2O, "pointingH2O", ModuleName )
    call Deallocate_Test ( pointingpres, "pointingpres", ModuleName )
    call Deallocate_Test ( pointingTemp, "pointingTemp", ModuleName )
    call Deallocate_Test ( ratio2, "ratio2", ModuleName )
    call Deallocate_Test ( ratio4, "ratio4", ModuleName )
    call Deallocate_Test ( refractedGeocAlt, "refractedGeocAlt", ModuleName )

    call Deallocate_Test ( closestTempProfiles, "closestTempProfiles", ModuleName )
    call Deallocate_Test ( closestH2OProfiles, "closestH2OProfiles", ModuleName )
    call Deallocate_Test ( lower, "lower", ModuleName )
    call Deallocate_Test ( upper, "upper", ModuleName )

d939 6
a944 6
    type (ForwardModelConfig_T), intent(in) :: FMCONF ! Configuration options
    type (Vector_T), intent(in) :: STATE ! The state vector
    type (Vector_T), intent(in) :: EXTRA ! Other stuff in the state vector
    type (Vector_T), intent(inout) :: FWMOUT ! Output vector, residual filled
    type (ForwardModelStatus_T), intent(inout) :: FMSTAT ! Which maf etc.
    type (Matrix_T), intent(inout), optional :: JACOBIAN ! The derivative matrix
d948 1
a948 1
    character(len=*), parameter :: INVALIDQUANTITY = "Invalid vector quantity for "
d953 17
a969 17
    integer :: NOMAFS                   ! Dimension
    integer :: NOMIFS                   ! Dimension
    integer :: NOTEMPS                  ! Dimension

    logical :: H2OINSTATE               ! Set if H2O in state, not extra
    logical :: HEIGHTOFFSETINSTATE      ! Set if heightOffset in state, not extra
    logical :: PTANINSTATE              ! Set if ptan in state, not extra
    logical :: REFGPHINSTATE            ! Set if refGPH in state not extra
    logical :: TEMPINSTATE              ! Set if temp in state not extra

    type (VectorValue_T), pointer :: H2O ! H2O component of state
    type (VectorValue_T), pointer :: HEIGHTOFFSET ! Height offset component of state
    type (VectorValue_T), pointer :: L1ALT ! Tangent point altitude
    type (VectorValue_T), pointer :: PTAN ! Ptan component of state
    type (VectorValue_T), pointer :: REFGPH ! Ref gph component of state
    type (VectorValue_T), pointer :: RESIDUAL ! Resulting component of fwmOut
    type (VectorValue_T), pointer :: TEMP ! Temperature component of state
d1001 1
a1001 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d1004 1
a1004 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d1007 1
a1007 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d1010 1
a1010 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d1013 1
a1013 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d1017 2
a1018 2
        & frequencyCoordinate=(/l_none/),&
        & noInstances=(/1/) ) ) call MLSMessage ( MLSMSG_Error, &
d1035 1
a1035 1
      integer :: COL                      ! Block col in jacobian
d1038 1
a1038 1
      integer :: LOWER                    ! Index into T profile
d1040 7
a1046 7
      integer :: ROW                      ! Block row in jacobian
      real (r8), target :: ZERO=0.0_r8    ! Need this if no heightOffset
      real (r8), pointer :: HTOFF         ! HeightOffset%values or zero
      real (r8) :: USEPTAN                ! A tangent pressure
      real (r8) :: BASIS                  ! Index
      real (r8) :: BASISMINUS             ! Index
      real (r8) :: BASISPLUS              ! Index
d1092 4
a1095 4
      real (r8), dimension(:), pointer :: BASISGPH ! From ifm
      real (r8), dimension(:), pointer :: H2OBASIS ! => h2o%template%surfs
      real (r8), dimension(:), pointer :: H2OVALS ! => h2o%values
      real (r8), dimension(:), pointer :: PTANVALS ! => ptan%values
d1097 2
a1098 2
      real (r8), dimension(:), pointer :: TEMPBASIS ! => temp%template%surfs
      real (r8), dimension(:), pointer :: TEMPVALS ! => temp%values
d1102 1
a1102 1
      real (r8), dimension(noMifs, noTemps) :: DHYDROSGPHBYDTEMP ! Derivative array
d1104 1
a1104 1
      type (MatrixElement_T), pointer :: BLOCK ! A matrix block
d1176 1
a1176 1
      endwhere
d1183 1
a1183 1
      endwhere
d1200 1
a1200 1
        ! Where n is too big limit it and set derivatives to zero
d1251 1
a1251 1
      l1GPH = -(GM/(l1RefrGeocAlt*g0)) * &
d1253 1
a1253 1
        & ((omega*l1RefrGeocAlt*cos(geocLat))**2)/(2*g0) + earthSurfaceGPH
d1300 2
a1301 2
          & rt(pointTempLayer) * ln10 * &
          & (ptanVals-tempBasis(pointTempLayer))/g0
d1306 2
a1307 2
          & rt(pointTempLayer+1) * ln10 * &
          & (ptanVals-tempBasis(pointTempLayer+1))/g0
d1421 1
a1421 1
            call updateDiagonal ( block, (/ &
d1424 1
a1424 1
              & 0.0 /) )
d1458 1
a1458 1
            block%values(:,1) = (/ &
d1460 1
a1460 1
              & 0.0_r8 /)
d1512 1
a1512 1
  & fmStat, jacobian, chunkNo )
d1514 2
a1515 1
    use Get_Eta_Matrix_M, only: Get_Eta_Sparse
d1519 1
d1524 3
a1526 3
    type (ForwardModelConfig_T), intent(in) :: FMCONF ! Configuration options
    type (Vector_T), intent(in) :: STATE ! The state vector
    type (Vector_T), intent(in) :: EXTRA ! Other stuff in the state vector
d1528 3
a1530 3
    type (Vector_T), intent(inout) :: FWMOUT ! Output vector, residual filled
    type (ForwardModelStatus_T), intent(inout) :: FMSTAT ! Which maf etc.
    type (Matrix_T), intent(inout), optional :: JACOBIAN ! The derivative matrix
d1532 6
d1539 16
a1554 16
    type (VectorValue_T), pointer :: ORBINCLINE ! Orbital inclination
    type (VectorValue_T), pointer :: TEMP ! Temperature component of state
    type (VectorValue_T), pointer :: PTAN ! Ptan component of state
    type (VectorValue_T), pointer :: PHITAN ! Phitan component of state
    type (VectorValue_T), pointer :: H2O ! H2O component of state
    type (VectorValue_T), pointer :: REFGPH ! Ref gph component of state
    type (VectorValue_T), pointer :: L1ALT ! Tangent point altitude
    type (VectorValue_T), pointer :: RESIDUAL ! Resulting component of fwmOut
    type (MatrixElement_T), pointer :: BLOCK ! A matrix block
  !
    logical :: TEMPINSTATE           ! Set if temp in state not extra
    logical :: REFGPHINSTATE         ! Set if refGPH in state not extra
    logical :: H2OINSTATE            ! Set if H2O in state, not extra
    logical :: PTANINSTATE           ! Set if ptan in state, not extra
  !
    integer :: First, Last           ! Nonzeros in Eta_at_one*
d1556 10
a1565 9
    integer :: windowstart_t         ! first instance for temperature
    integer :: windowfinish_t        ! last instance for temperature
    integer :: windowstart_h2o       ! first instance for water vapor
    integer :: windowfinish_h2o      ! last instance for water vapor
    integer :: sv_z                  ! height basis index
    integer :: sv_p                  ! horizontal basis index
    integer :: row                   ! Block row in jacobian
    integer :: col                   ! Block col in jacobian
  !
d1569 9
a1577 44
  !
    real(rp), pointer :: earthradc(:)  ! square of minor axis of earth ellipsoid
  !                              in orbit plane projected system
    real(rp), pointer :: red_phi_t(:)
    real(rp), pointer :: sinbeta(:)
    real(rp), pointer :: sinphi2(:)
    real(rp), pointer :: cosphi2(:)
    real(rp), pointer :: geoclats(:)
    real(rp), pointer :: sinlat2(:)
    real(rp), pointer :: coslat2(:)
    real(rp), pointer :: g_ref(:)
    real(rp), pointer :: earth_radius(:)
    real(rp), pointer :: eff_earth_radius(:)
    real(rp), pointer :: p2(:)
    real(rp), pointer :: p4(:)
    real(rp), pointer :: ratio2(:)
    real(rp), pointer :: ratio4(:)
    real(rp), pointer :: ratio2_gph(:)
    real(rp), pointer :: ratio4_gph(:)
    real(rp), pointer :: tan_temp(:)
    real(rp), pointer :: tan_h2o(:)
    real(rp), pointer :: tan_refr_indx(:)
    real(rp), pointer :: l1altrefr(:)
    real(rp), pointer :: refgeomalt_denom(:)
    real(rp), pointer :: l1refalt(:)
    real(rp), pointer :: mass_corr(:)
    real(rp), pointer :: dgphdr(:)
    real(rp), pointer :: dscandz(:)
    real(rp), pointer :: temp_at_surf_phi(:)
    real(rp), pointer :: eta_z(:,:)
    real(rp), pointer :: eta_p_t(:,:)
    real(rp), pointer :: eta_p_h2o(:,:)
    real(rp), pointer :: piq(:,:)
    real(rp), pointer :: eta_piqxp(:,:)
    real(rp), pointer :: eta_zxp_t(:,:)
    real(rp), pointer :: eta_zxp_h2o(:,:)
    real(rp), pointer :: eta_at_one_phi(:)
    real(rp), pointer :: eta_at_one_zeta(:)
  !
    logical, pointer :: not_zero_z(:,:)
    logical, pointer :: not_zero_p_t(:,:)
    logical, pointer :: not_zero_p_h2o(:,:)
    logical, pointer :: not_zero_t(:,:)
    logical, pointer :: not_zero_h2o(:,:)
a1595 8
  ! nullify all pointers
    nullify ( coslat2, cosphi2, dgphdr, dscandz, earthradc, earth_radius,      &
      & eff_earth_radius, eta_at_one_phi, eta_at_one_zeta, eta_p_h2o,          &
      & eta_piqxp, eta_p_t, eta_z, eta_zxp_h2o, eta_zxp_t, geoclats,           &
      & g_ref, l1altrefr, l1refalt, mass_corr, not_zero_h2o, not_zero_p_h2o,   &
      & not_zero_p_t, not_zero_t, not_zero_z, p2, p4, piq, ratio2, ratio2_gph, &
      & ratio4, ratio4_gph, red_phi_t, refgeomalt_denom, sinbeta, sinlat2,     &
      & sinphi2, tan_h2o, tan_refr_indx, tan_temp, temp_at_surf_phi ) 
d1622 4
a1625 4
    CALL FindInstanceWindow(temp,phitan,fmStat%maf,FMConf%phiWindow, &
      & FMConf%windowUnits, windowstart_t, windowfinish_t)
    CALL FindInstanceWindow(h2o,phitan,fmStat%maf,FMConf%phiWindow, &
      & FMConf%windowUnits, windowstart_h2o, windowfinish_h2o)
d1630 41
a1670 303
  ! convert phitan into geocentric latitude
    CALL ALLOCATE_TEST(earth_radius,ptan%template%nosurfs,'earth_radius', &
    & modulename)
    CALL ALLOCATE_TEST(eff_earth_radius,ptan%template%nosurfs, &
    & 'eff_earth_radius', modulename)
    CALL ALLOCATE_TEST(g_ref,ptan%template%nosurfs,'g_ref',modulename)
    CALL ALLOCATE_TEST(coslat2,ptan%template%nosurfs,'coslat2',modulename)
    CALL ALLOCATE_TEST(p2,ptan%template%nosurfs,'p2',modulename)
    CALL ALLOCATE_TEST(p4,ptan%template%nosurfs,'p4',modulename)
    CALL ALLOCATE_TEST(ratio2,ptan%template%nosurfs,'ratio2',modulename)
    CALL ALLOCATE_TEST(ratio4,ptan%template%nosurfs,'ratio4',modulename)
    CALL ALLOCATE_TEST(l1refalt,ptan%template%nosurfs,'l1refalt',modulename)
    CALL ALLOCATE_TEST(refgeomalt_denom,ptan%template%nosurfs, &
      & 'refgeomalt_denom',modulename)
    CALL ALLOCATE_TEST(sinbeta,ptan%template%nosurfs,'sinbeta',modulename)
    CALL ALLOCATE_TEST(geoclats,ptan%template%nosurfs,'geoclats',modulename)
    CALL ALLOCATE_TEST(sinlat2,ptan%template%nosurfs,'sinlat2',modulename)
    CALL ALLOCATE_TEST(cosphi2,ptan%template%nosurfs,'cosphi2',modulename)
    CALL ALLOCATE_TEST(sinphi2,ptan%template%nosurfs,'sinphi2',modulename)
    CALL ALLOCATE_TEST(red_phi_t,ptan%template%nosurfs,'red_phi_t',modulename)
    CALL ALLOCATE_TEST(earthradc,ptan%template%nosurfs,'earthradc',modulename)
    ! Sometimes, orbincline may not have the same number of surfaces as
    ! ptan, e.g. for non-satellite data
    if ( size(orbincline%values, 1) < ptan%template%noSurfs ) then
      sinbeta = sin(deg2rad*orbincline%values(1,fmStat%maf))
    else
      sinbeta = sin(deg2rad*orbincline%values(1:ptan%template%noSurfs,fmStat%maf))
    endif
    earthradc = (earthrada*earthradb)**2 / &
      & ( (earthRada**2 - earthRadb**2) * sinbeta**2 + earthRadb**2) ! in meters
  ! rephase the phi
    red_phi_t = MODULO(deg2rad*phitan%values(:,fmStat%maf),2.0_rp*Pi)
    WHERE(0.5_rp*Pi < red_phi_t .AND. red_phi_t <= 1.5_rp*Pi)
      red_phi_t = Pi - red_phi_t
    ELSEWHERE(red_phi_t > 1.5_rp*Pi)
      red_phi_t = red_phi_t - 2.0_rp*Pi
    ENDWHERE
    if ( timing ) call sayTime ( 'rephasing phi' )
    call time_now ( t1 )
  ! compute sin^2(phi) and cos^2(phi)
    sinphi2 = sin(red_phi_t)**2
    cosphi2 = 1.0_rp - sinphi2
    geoclats = asin(earthradc * sin(red_phi_t) * sinbeta / &
      & sqrt(earthrada**4*cosphi2 + earthradc**2*sinphi2))
    sinlat2 = SIN(geoclats)**2
    coslat2 = 1.0_rp - sinlat2
    p2=0.5_rp * (3.0_rp*sinlat2 - 1.0_rp)
    p4=0.125_rp * (35.0_rp*sinlat2**2 - 30.0_rp*sinlat2 + 3.0_rp)
  ! compute the local gravitational acceleration at the surface
    earth_radius = SQRT((earthrada**4*cosphi2 + earthradc**2*sinphi2) &
                 &    / (earthrada**2*cosphi2 + earthradc*sinphi2))
    ratio2=(earthRadA/earth_radius)**2
    ratio4=ratio2**2
    g_ref =  GM * (1.0_rp - 3.0_rp*j2*p2*ratio2 - 5.0_rp*j4*p4*ratio4) &
      & / earth_radius**2 - omega**2*earth_radius*coslat2
  ! get the effective earth radius
    eff_earth_radius = 2.0_rp * g_ref / (2.0_rp * gm * (1.0_rp-6.0_rp*j2*p2 &
      & * ratio2 - 15.0_rp*j4*p4*ratio4) / earth_radius**3 &
      & + omega**2*coslat2)
  ! deallocate things we don't need
    CALL DEALLOCATE_TEST(earthradc,'earthradc',modulename)
    CALL DEALLOCATE_TEST(red_phi_t,'red_phi_t',modulename)
    CALL DEALLOCATE_TEST(sinphi2,'sinphi2',modulename)
    CALL DEALLOCATE_TEST(cosphi2,'cosphi2',modulename)
    CALL DEALLOCATE_TEST(sinlat2,'sinlat2',modulename)
    CALL DEALLOCATE_TEST(geoclats,'geoclats',modulename)
    CALL DEALLOCATE_TEST(sinbeta,'sinbeta',modulename)
  ! compute temperature function
    CALL allocate_test(eta_z,ptan%template%nosurfs,temp%template%nosurfs, &
                    & 'eta_z',ModuleName)
    CALL allocate_test(not_zero_z,ptan%template%nosurfs,temp%template%nosurfs,&
                    & 'not_zero_z',ModuleName)
    CALL allocate_test(eta_p_t,phitan%template%nosurfs, &
                    & windowfinish_t - windowstart_t + 1, 'eta_p_t',ModuleName)
    CALL allocate_test(not_zero_p_t,phitan%template%nosurfs, &
               & windowfinish_t - windowstart_t + 1, 'not_zero_p_t',ModuleName)
    CALL allocate_test(eta_zxp_t,ptan%template%nosurfs,temp%template%nosurfs &
        & * (windowfinish_t - windowstart_t + 1), 'eta_zxp_t',ModuleName)
    CALL allocate_test(not_zero_t,ptan%template%nosurfs,temp%template%nosurfs &
        & * (windowfinish_t - windowstart_t + 1), 'not_zero_t',ModuleName)
    CALL allocate_test(eta_piqxp,ptan%template%nosurfs,temp%template%nosurfs &
        & * (windowfinish_t - windowstart_t + 1), 'eta_piqxp',ModuleName)
    CALL allocate_test(tan_temp,ptan%template%nosurfs , 'tan_temp', &
      & ModuleName)
  ! get eta functions
    CALL get_eta_sparse(temp%template%phi(1,windowstart_t:windowfinish_t), &
      & phitan%values(:,fmStat%maf), eta_p_t, not_zero_p_t)
    CALL get_eta_sparse(temp%template%surfs(:,1),ptan%values(:,fmStat%maf), &
      & eta_z, not_zero_z)
    if ( timing ) call sayTime ( 'getting etas functions' )
    call time_now ( t1 )
  ! construct piq integral
    CALL ALLOCATE_TEST(piq,ptan%template%nosurfs,temp%template%nosurfs, &
      & 'piq', modulename)
    CALL piq_int(ptan%values(:,fmStat%maf),temp%template%surfs(:,1), &
      & refGPH%template%surfs(1,1), piq, Z_MASS = 2.5_rp, C_MASS = 0.02_rp)
    if ( timing ) call sayTime ( 'constructing piq integral' )
    call time_now ( t1 )
  ! convert level 1 reference geopotential height into geometric altitude
  ! This assumes that the reference ellipsoid is equivalent to a reference
  ! geopotential height of 0 meters.
    refgeomalt_denom = g_ref*eff_earth_radius &
      & - g0*SUM(SPREAD(RESHAPE(refgph%values(1,windowstart_t:windowfinish_t), &
      & (/windowfinish_t-windowstart_t+1/)),1,ptan%template%nosurfs) &
      & * eta_p_t,dim=2)
    l1refalt = g_ref*eff_earth_radius**2 / refgeomalt_denom - eff_earth_radius &
      & + earth_radius
    tan_temp = 0.0_rp
    eta_zxp_t = 0.0_rp
    eta_piqxp = 0.0_rp
    not_zero_t = .false.
    DO sv_z = 1, temp%template%nosurfs
      DO sv_p = 1, windowfinish_t - windowstart_t + 1
  !      WHERE(not_zero_p_t(:,sv_p) .AND. not_zero_z(:,sv_z))
  !        eta_zxp_t(:,sv_z + temp%template%nosurfs*(sv_p-1)) = &
  !        & eta_z(:,sv_z) * eta_p_t(:,sv_p)
  !        not_zero_t(:,sv_z + temp%template%nosurfs*(sv_p-1)) = .TRUE.
  !        tan_temp = tan_temp + eta_zxp_t(:,sv_z+temp%template%nosurfs*(sv_p-1)) &
  !        & * temp%values(sv_z,windowstart_t+sv_p-1)
  !      END WHERE
  !      WHERE(not_zero_p_t(:,sv_p)) &
  !        & eta_piqxp(:,sv_z + temp%template%nosurfs*(sv_p-1)) &
  !        & = piq(:,sv_z) * eta_p_t(:,sv_p)
        do isurf=1, ptan%template%nosurfs
          if ( not_zero_p_t(isurf,sv_p) .AND. not_zero_z(isurf,sv_z) ) then
            eta_zxp_t(isurf,sv_z + temp%template%nosurfs*(sv_p-1)) = &
              & eta_z(isurf,sv_z) * eta_p_t(isurf,sv_p)
            not_zero_t(isurf,sv_z + temp%template%nosurfs*(sv_p-1)) = .TRUE.
            tan_temp(isurf) = tan_temp(isurf) + &
              & eta_zxp_t(isurf,sv_z+temp%template%nosurfs*(sv_p-1)) &
              & * temp%values(sv_z,windowstart_t+sv_p-1)
          endif
          if ( not_zero_p_t(isurf,sv_p) ) then
            eta_piqxp(isurf,sv_z + temp%template%nosurfs*(sv_p-1)) &
              & = piq(isurf,sv_z) * eta_p_t(isurf,sv_p)
          endif
        enddo
      ENDDO
    ENDDO
    if ( timing ) call sayTime ( 'constructing geometric altitude' )
    call time_now ( t1 )
    CALL deallocate_test(piq, 'piq',ModuleName)
    CALL deallocate_test(eta_z, 'eta_z',ModuleName)
    CALL deallocate_test(not_zero_z,'not_zero_z',ModuleName)
  ! compute water vapor function
    CALL allocate_test(eta_p_h2o,phitan%template%nosurfs, &
              & windowfinish_h2o - windowstart_h2o + 1, 'eta_p_h2o',ModuleName)
    CALL allocate_test(not_zero_p_h2o,phitan%template%nosurfs, &
         & windowfinish_h2o - windowstart_h2o + 1, 'not_zero_p_h2o',ModuleName)
    CALL allocate_test(eta_z,ptan%template%nosurfs,h2o%template%nosurfs, &
                    & 'eta_z',ModuleName)
    CALL allocate_test(not_zero_z, ptan%template%nosurfs, &
    & h2o%template%nosurfs, 'not_zero_z',ModuleName)
    CALL allocate_test(eta_zxp_h2o,ptan%template%nosurfs,h2o%template%nosurfs &
        & * (windowfinish_h2o - windowstart_h2o + 1), 'eta_zxp_h2o',ModuleName)
    CALL allocate_test(not_zero_h2o,ptan%template%nosurfs,h2o%template%nosurfs &
        & * (windowfinish_h2o - windowstart_h2o + 1), 'not_zero_h2o',ModuleName)
    CALL allocate_test(tan_h2o,ptan%template%nosurfs , 'tan_h2o', &
      & ModuleName)
    CALL get_eta_sparse(h2o%template%phi(1,windowstart_h2o:windowfinish_h2o), &
      & phitan%values(:,fmStat%maf), eta_p_h2o, not_zero_p_h2o)
    CALL get_eta_sparse(h2o%template%surfs(:,1),ptan%values(:,fmStat%maf), &
      & eta_z, not_zero_z)
  ! we will assume the logarithmic interpolation here
    tan_h2o = 0.0_rp
    eta_zxp_h2o = 0.0_rp
    not_zero_h2o = .false.
    DO sv_p = 1, windowfinish_h2o - windowstart_h2o + 1
      DO sv_z = 1, h2o%template%nosurfs
  !      WHERE(not_zero_p_h2o(:,sv_p) .AND. not_zero_z(:,sv_z))
  !        eta_zxp_h2o(:,sv_z + h2o%template%nosurfs*(sv_p-1)) = &
  !        & eta_z(:,sv_z) * eta_p_h2o(:,sv_p)
  !        not_zero_h2o(:,sv_z + h2o%template%nosurfs*(sv_p-1)) = .TRUE.
  !        tan_h2o = tan_h2o + eta_zxp_h2o(:,sv_z+h2o%template%nosurfs*(sv_p-1)) &
  !        & * LOG(max(h2o%values(sv_z,windowstart_h2o+sv_p-1),1e-9_rp))
  !      END WHERE
        do isurf=1, ptan%template%nosurfs
          if ( not_zero_p_h2o(isurf,sv_p) .AND. not_zero_z(isurf,sv_z) ) then
            eta_zxp_h2o(isurf,sv_z + h2o%template%nosurfs*(sv_p-1)) = &
              & eta_z(isurf,sv_z) * eta_p_h2o(isurf,sv_p)
            not_zero_h2o(isurf,sv_z + h2o%template%nosurfs*(sv_p-1)) = .TRUE.
            tan_h2o(isurf) = tan_h2o(isurf) + &
              & eta_zxp_h2o(isurf,sv_z+h2o%template%nosurfs*(sv_p-1)) &
              & * LOG(max(h2o%values(sv_z,windowstart_h2o+sv_p-1),1e-9_rp))
          endif
        enddo
      ENDDO
    ENDDO
    tan_h2o = EXP(tan_h2o)
    CALL deallocate_test(eta_p_h2o, 'eta_p_h2o',ModuleName)
    CALL deallocate_test(eta_z, 'eta_z',ModuleName)
    CALL deallocate_test(not_zero_p_h2o,'not_zero_p_h2o',ModuleName)
    CALL deallocate_test(not_zero_z,'not_zero_z',ModuleName)
    if ( timing ) call sayTime ( 'computing water vapor functions' )
    call time_now ( t1 )
  ! compute refractive index
    CALL ALLOCATE_TEST(tan_refr_indx,ptan%template%nosurfs,'tan_refr_indx', &
    & modulename)
    CALL refractive_index ( 10.0_rp**(-max(-10.0_rp,ptan%values(:,fmStat%maf))), &
      & tan_temp, tan_refr_indx,h2o_path = tan_h2o )
  ! compute surface pressure
    CALL ALLOCATE_TEST(eta_at_one_phi,windowfinish_t-windowstart_t+1, &
    & 'eta_at_one_phi',modulename)
    CALL ALLOCATE_TEST(temp_at_surf_phi,temp%template%nosurfs, &
    & 'temp_at_surf_phi',modulename)
    CALL get_eta_sparse(temp%template%phi(1,windowstart_t:windowfinish_t), &
    & phitan%values(1,fmStat%maf),eta_at_one_phi,first,last)
    temp_at_surf_phi = SUM(temp%values(:,windowstart_t:windowfinish_t)* &
    & SPREAD(eta_at_one_phi,1,temp%template%nosurfs),dim=2)
    z_surf = z_surface(temp%template%surfs(:,1),temp_at_surf_phi,g_ref(1), &
    & SUM(refgph%values(1,windowstart_t:windowfinish_t) * eta_p_t(1,:)), &
    & refGPH%template%surfs(1,1),boltz)
    CALL DEALLOCATE_TEST(eta_at_one_phi,'eta_at_one_phi',modulename)
  ! compute refractive index at the surface
    CALL ALLOCATE_TEST(eta_at_one_zeta,temp%template%nosurfs, &
    & 'eta_at_one_zeta',modulename)
    CALL get_eta_sparse(temp%template%surfs(:,1),z_surf,eta_at_one_zeta,first,last)
    surf_temp = dot_product(eta_at_one_zeta(first:last), temp_at_surf_phi(first:last))
    CALL DEALLOCATE_TEST(eta_at_one_zeta,'eta_at_one_zeta',modulename)
    CALL DEALLOCATE_TEST(temp_at_surf_phi,'temp_at_surf_phi',modulename)
    CALL ALLOCATE_TEST(eta_at_one_phi,windowfinish_h2o-windowstart_h2o+1, &
    & 'eta_at_one_phi',modulename)
    CALL ALLOCATE_TEST(eta_at_one_zeta,h2o%template%nosurfs, &
    & 'eta_at_one_zeta',modulename)
    CALL get_eta_sparse(h2o%template%phi(1,windowstart_h2o:windowfinish_h2o), &
    & phitan%values(1,fmStat%maf),eta_at_one_phi)
    CALL get_eta_sparse(h2o%template%surfs(:,1),z_surf,eta_at_one_zeta,first,last)
    CALL refractive_index(10.0_rp**(-(/z_surf/)),(/surf_temp/),surf_refr_indx, &
    & h2o_path = (/EXP(dot_product(eta_at_one_zeta(first:last), &
    &   SUM(LOG(max(h2o%values(first:last,windowstart_h2o:windowfinish_h2o),1e-9_rp)) &
    & * SPREAD(eta_at_one_phi,1,last-first+1),dim=2)))/))
    CALL DEALLOCATE_TEST(eta_at_one_zeta,'eta_at_one_zeta',modulename)
    CALL DEALLOCATE_TEST(eta_at_one_phi,'eta_at_one_phi',modulename)
  ! set all refr indicies below the surface to the surface value
    WHERE(ptan%values(:,fmStat%maf) < z_surf) 
      tan_refr_indx = surf_refr_indx(1)
      tan_temp = surf_temp
    END WHERE
  ! compute l1 geopotential
    CALL ALLOCATE_TEST(l1altrefr,ptan%template%nosurfs,'l1altrefr', &
    & modulename)
    l1altrefr = l1alt%values(:,fmStat%maf) / (1.0_rp + tan_refr_indx)
    CALL ALLOCATE_TEST(ratio2_gph,ptan%template%nosurfs,'ratio2',modulename)
    CALL ALLOCATE_TEST(ratio4_gph,ptan%template%nosurfs,'ratio4',modulename)
    ratio2=(earthRadA/l1altrefr)**2
    ratio4=ratio2**2
    ratio2_gph=(earthRadA/l1refalt)**2
    ratio4_gph=ratio2**2
  ! do a simple mass correction
    CALL ALLOCATE_TEST(mass_corr,ptan%template%nosurfs,'mass_corr',modulename)
    mass_corr = 1.0_rp
  !  WHERE(ptan%values(:,fmStat%maf) > 2.5) mass_corr = 1.0_rp &
  !    & / (0.875_rp + 0.1_rp*ptan%values(:,fmStat%maf) &
  !    & - 0.02_rp*ptan%values(:,fmStat%maf)**2)
  ! This is a reasonable approximation to the above.
    WHERE(ptan%values(:,fmStat%maf) > 2.5) mass_corr = 1.0_rp &
       & + 0.02_rp*(ptan%values(:,fmStat%maf) - 2.5)**2
    if ( timing ) call sayTime ( 'refractive index, l1 geopotential' )
    call time_now ( t1 )
  ! forward model calculation
    residual%values(:,fmStat%maf) = (GM*((1.0_rp - j2*p2*ratio2 - j4*p4*ratio4) &
    & / l1altrefr - (1.0_rp - j2*p2*ratio2_gph - j4*p4*ratio4_gph) / l1refalt) &
    & + 0.5_rp*omega**2*coslat2*(l1altrefr - l1refalt)*(l1altrefr + l1refalt) &
    & + boltz*SUM(RESHAPE(SPREAD(temp%values(:,windowstart_t: &
    & windowfinish_t),1,ptan%template%nosurfs), (/ptan%template%nosurfs, &
    & temp%template%nosurfs*(windowfinish_t-windowstart_t+1)/)) &
    & * eta_piqxp,dim=2)) / g0
    if ( timing ) call sayTime ( 'forward model calculation' )
    call time_now ( t1 )
    IF ( fmConf%differentialScan ) residual%values(:,fmStat%maf) = &
      & EOSHIFT(residual%values(:,fmStat%maf),1, &
      & residual%values(ptan%template%nosurfs,fmStat%maf)) &
      & - residual%values(:,fmStat%maf)
  ! derivatives--for simplicity we are ignoring h2o contributions
      ! Find row in jacobian
    if ( present ( jacobian ) ) then
      row = FindBlock ( jacobian%row, residual%index,fmStat%maf )
      fmStat%rows(row) = .true.
  ! compute dudr
      CALL ALLOCATE_TEST(dgphdr,ptan%template%nosurfs,'dgphdr',modulename)
      dgphdr =  -(GM / (l1altrefr**2*g0)) * (1.0_rp - 3.0_rp*j2*p2*ratio2 &
      & - 5.0_rp*j4*p4*ratio4) + (omega**2*l1altrefr*coslat2) / g0
  ! Store the ptan derivatives
      if ( ptanInState ) then
        col = FindBlock ( jacobian%col, ptan%index, fmStat%maf )
        block => jacobian%block(row,col)
        if ( block%kind /= M_Absent ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Found a prexisting d(residual)/d(ptan), removing' )
          call DestroyBlock ( block )
        end if
        CALL ALLOCATE_TEST(dscandz,ptan%template%nosurfs, &
        & 'dscandz', modulename)
        dscandz = boltz*mass_corr*SUM(RESHAPE( &
          & SPREAD(temp%values(:,windowstart_t:windowfinish_t),1, &
          & ptan%template%nosurfs), (/ptan%template%nosurfs, &
          & temp%template%nosurfs*(windowfinish_t-windowstart_t+1)/)) &
          & * eta_zxp_t,dim=2) / g0
        WHERE(ptan%values(:,fmStat%maf) > z_surf) dscandz = dscandz &
          & + dgphdr*l1altrefr*tan_refr_indx*ln10 / (1.0_rp + tan_refr_indx)
        if ( fmConf%differentialScan ) then
          CALL updateDiagonal ( BLOCK, EOSHIFT(dscandz,1, &
          & dscandz(ptan%template%nosurfs)) - dscandz)
d1672 1
a1672 1
          CALL updateDiagonal ( BLOCK,dscandz)
d1674 182
a1855 6
        CALL DEALLOCATE_TEST(dscandz,'dscandz', modulename)
      end if
  ! Store refGPH derivatives
      if ( refGPHInState ) then
        DO sv_p = windowstart_t, windowfinish_t
          col = FindBlock ( jacobian%col, refGPH%index, sv_p )
d1859 1
a1859 1
            & 'Found a prexisting d(residual)/d(refGPH), removing' )
d1862 9
a1870 7
          IF(ANY(not_zero_p_t(:,sv_p-windowstart_t+1))) THEN
            call CreateBlock ( jacobian, row, col, M_Full )
            block%values(:,1) = (GM * (1.0_rp - 3.0_rp*j2*p2*ratio2_gph &
            & - 5.0_rp*j4*p4*ratio4_gph) / l1refalt**2 &
            & + omega**2*l1refalt*coslat2) * (l1refalt+eff_earth_radius &
            & - earth_radius) * eta_p_t(:,sv_p - windowstart_t + 1) &
            & / refgeomalt_denom
d1872 4
a1875 5
  ! ------------- Differential model
              block%values = EOSHIFT(block%values, &
              & SPREAD(1,1,ptan%template%nosurfs), &
              & RESHAPE(block%values(ptan%template%nosurfs,:), &
              & (/temp%template%nosurfs/)),dim=2) - block%values
d1877 34
a1910 14
          ENDIF
        ENDDO
        if ( timing ) call sayTime ( 'differential model' )
        call time_now ( t1 )
      end if
  ! Now the temperature derivatives
      if ( tempInState ) then
        DO sv_p = windowstart_t, windowfinish_t
          col = FindBlock ( jacobian%col, temp%index, sv_p )
          block => jacobian%block(row,col)
          if ( block%kind /= M_Absent ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Found a prexisting d(residual)/d(temp), removing' )
            call DestroyBlock ( block )
d1912 33
a1944 8
          IF(ANY(not_zero_p_t(:,sv_p-windowstart_t+1))) THEN
            call CreateBlock ( jacobian, row, col, M_Full )
            block%values = SPREAD(dgphdr*l1altrefr*tan_refr_indx &
            & / ((1.0_rp + tan_refr_indx)*tan_temp),2,temp%template%nosurfs) &
            & * eta_zxp_t(:,1+(sv_p-windowstart_t)*temp%template%nosurfs: &
            & (sv_p-windowstart_t+1)*temp%template%nosurfs) &
            & + boltz*eta_piqxp(:,1+(sv_p-windowstart_t)*temp%template%nosurfs: &
            & (sv_p-windowstart_t+1)*temp%template%nosurfs) / g0
d1946 7
a1952 5
  ! ------------- Differential model
              block%values = EOSHIFT(block%values, &
              & SPREAD(1,1,ptan%template%nosurfs), &
              & RESHAPE(block%values(ptan%template%nosurfs,:), &
              & (/temp%template%nosurfs/)),dim=2) - block%values
d1954 4
a1957 4
          ENDIF
        ENDDO
        if ( timing ) call sayTime ( 'temperature derivatives' )
        call time_now ( t1 )
d1959 2
a1960 27
      CALL DEALLOCATE_TEST(dgphdr,'dgphdr',modulename)
    ENDIF
  ! deallocate all remaining pointers
    CALL DEALLOCATE_TEST(coslat2,'coslat2',modulename)
    CALL DEALLOCATE_TEST(p2,'p2',modulename)
    CALL DEALLOCATE_TEST(p4,'p4',modulename)
    CALL DEALLOCATE_TEST(earth_radius,'earth_radius', modulename)
    CALL DEALLOCATE_TEST(eff_earth_radius,'eff_earth_radius', modulename)
    CALL DEALLOCATE_TEST(g_ref,'g_ref',modulename)
    CALL DEALLOCATE_TEST(l1refalt,'l1refalt',modulename)
    CALL DEALLOCATE_TEST(refgeomalt_denom,'refgeomalt_denom',modulename)
    CALL DEALLOCATE_TEST(ratio2,'ratio2',modulename)
    CALL DEALLOCATE_TEST(ratio4,'ratio4',modulename)
    CALL DEALLOCATE_TEST(ratio2_gph,'ratio2_gph',modulename)
    CALL DEALLOCATE_TEST(ratio4_gph,'ratio4_gph',modulename)
    CALL DEALLOCATE_TEST(l1altrefr,'l1altrefr', modulename)
    CALL deallocate_test(eta_p_t,'eta_p_t',ModuleName)
    CALL deallocate_test(not_zero_p_t, 'not_zero_p_t',ModuleName)
    CALL DEALLOCATE_TEST(mass_corr,'mass_corr',modulename)
    CALL deallocate_test(eta_zxp_t,'eta_zxp_t',ModuleName)
    CALL deallocate_test(not_zero_t,'not_zero_t',ModuleName)
    CALL deallocate_test(eta_piqxp,'eta_piqxp',ModuleName)
    CALL deallocate_test(tan_temp,'tan_temp',ModuleName)
    CALL deallocate_test(eta_zxp_h2o,'eta_zxp_h2o',ModuleName)
    CALL deallocate_test(not_zero_h2o,'not_zero_h2o',ModuleName)
    CALL deallocate_test(tan_h2o,'tan_h2o',ModuleName)
    CALL DEALLOCATE_TEST(tan_refr_indx,'tan_refr_indx', modulename)
d1965 1
a1965 1
    endif
d1979 1
a1979 1
      endif
d1988 1
d1990 6
a1995 6
      real(rp), intent(in) :: z_basis(:) ! zeta basis for temperature
      real(rp), intent(in) :: t_values(:) ! temperature coefficients
      real(rp), intent(in) :: g_ref      ! reference acceloration at the surface
      real(rp), intent(in) :: h_ref      ! reference geopotential
      real(rp), intent(in) :: z_ref      ! reference zeta for h_ref
      real(rp), intent(in) :: boltz      ! k*ln10/m in your favorite units
d1997 1
a1997 1
      real(rp), optional, intent(in) :: threshold ! zeta convergence criteria
d2003 9
a2011 10
      integer :: First, Last             ! Nonzeros of Eta
      integer :: iter
      integer :: maxiter
!
      real(rp) :: eta(size(z_basis))
      real(rp) :: ghb                    ! g_ref * h_ref / boltz
      real(rp) :: piq(1,size(z_basis))
      real(rp) :: thresh
      real(rp) :: z_old
! 
d2024 2
a2025 2
        call piq_int ( (/z_old/), z_basis, z_ref, piq )
        call get_eta_sparse ( z_basis, z_old, eta, first, last )
d2027 3
a2029 2
        z_surface = z_old - (ghb + dot_product(piq(1,:),t_values)) &
                         & / dot_product(eta(first:last),t_values(first:last))
d2031 1
a2031 1
        if ( abs(z_surface - z_old) < thresh .or. iter >= maxiter ) exit
d2043 1
a2043 1
       "$Id: ScanModelModule.f90,v 2.88 2016/08/12 00:31:25 pwagner Exp $"
d2053 3
d2058 1
a2058 1
!
d2061 1
a2061 1
!
d2065 1
a2065 1
!
d2068 1
a2068 1
!
d2073 1
a2073 1
!
d2076 1
a2076 1
!
d2079 1
a2079 1
!
d2082 1
a2082 1
!
d2085 1
a2085 1
!
d2088 1
a2088 1
!
d2091 1
a2091 1
!
d2094 1
a2094 1
!
d2097 1
a2097 1
!
d2100 1
a2100 1
!
d2106 1
a2106 1
!
d2109 1
a2109 1
!
d2112 1
a2112 1
!
d2115 1
a2115 1
!
d2118 1
a2118 1
!
d2121 1
a2121 1
!
d2124 1
a2124 1
!
d2127 1
a2127 1
!
d2130 1
a2130 1
!
d2133 1
a2133 1
!
d2136 1
a2136 1
!
d2139 1
a2139 1
!
d2142 1
a2142 1
!
d2145 1
a2145 1
!
d2148 1
a2148 1
!
d2151 1
a2151 1
!
d2154 1
a2154 1
!
d2157 1
a2157 1
!
d2160 1
a2160 1
!
d2163 1
a2163 1
!
d2166 1
a2166 1
!
d2169 1
a2169 1
!
d2172 1
a2172 1
!
d2175 1
a2175 1
!
d2178 1
a2178 1
!
d2181 1
a2181 1
!
d2186 1
a2186 1
!
d2189 1
a2189 1
!
d2192 1
a2192 1
!
d2195 1
a2195 1
!
d2198 1
a2198 1
!
d2201 1
a2201 1
!
d2204 1
a2204 1
!
d2207 1
a2207 1
!
d2210 1
a2210 1
!
d2213 1
a2213 1
!
d2216 1
a2216 1
!
d2219 1
a2219 1
!
d2222 1
a2222 1
!
d2225 1
a2225 1
!
d2228 1
a2228 1
!
d2231 1
a2231 1
!
d2234 1
a2234 1
!
d2237 1
a2237 1
!
d2240 1
a2240 1
!
d2243 1
a2243 1
!
d2246 1
a2246 1
!
d2249 1
a2249 1
!
d2252 1
a2252 1
!
d2255 1
a2255 1
!
d2258 1
a2258 1
!
d2261 1
a2261 1
!
d2264 1
a2264 1
!
d2267 1
a2267 1
!
d2270 1
a2270 1
!
d2274 1
a2274 1
!
d2277 1
a2277 1
!
d2281 1
a2281 1
!
d2284 1
a2284 1
!
d2288 1
a2288 1
!
d2291 1
a2291 1
!
d2294 1
a2294 1
!
d2297 1
a2297 1
!
d2300 1
a2300 1
!
d2305 1
a2305 1
!
d2309 1
a2309 1
!
d2312 1
a2312 1
!
d2315 1
a2315 1
!
d2318 1
a2318 1
!
d2321 1
a2321 1
!
d2324 1
a2324 1
!
d2327 1
a2327 1
!
@


2.89.4.1
log
@Sets GPH Precisions negative where Temps are not valid
@
text
@a164 5
    use Dump_0, only: Dump
    use HighOutput, only: OutputNamedValue
    use MLSCommon, only: UndefinedValue
    use MLSFillValues, only: IsFillValue
    use MLSFinds, only: FindFirst
d167 1
a207 1
    logical, parameter :: DEEBUG = .false.
a297 16
    if ( any(IsFillValue(temp%values) ) ) then
      if ( DEEBUG ) call outputNamedValue ( 'myBelowRef', myBelowRef )
      ! We will reset gph to FillValue for any ..
      do instance=1, temp%template%noInstances
        if ( DEEBUG ) call outputNamedValue ( 'instance', instance )
        if ( DEEBUG ) call dump( temp%values(:, instance), 'Temperatures' )
        ! heights above the 1st neg T starting at the refGPH and going up
        surf = FindFirst ( isFillValue(temp%values(myBelowRef:, instance) ) )
        if ( DEEBUG ) call outputNamedValue ( 'upper -999.99 surf', surf )
        if ( surf > 0 ) gph(myBelowRef+surf-1:,instance) = UndefinedValue
        ! heights below the 1st neg T starting at the refGPH and going down
        surf = FindFirst ( isFillValue(temp%values(myBelowRef:1:-1, instance) ) )
        if ( DEEBUG ) call outputNamedValue ( 'lower -999.99 surf', surf )
        if ( surf > 0 ) gph(myBelowRef-surf+1:1:-1,instance) = UndefinedValue
      enddo
    endif
d2211 1
a2211 1
       "$Id: ScanModelModule.f90,v 2.89 2017/08/10 22:44:12 pwagner Exp $"
a2220 3
! Revision 2.89  2017/08/10 22:44:12  pwagner
! Exit witth eror message if buggy 1s Scan Model called
!
@


2.88
log
@Seems to restore tthe gold brick
@
text
@d26 12
a37 12
  use Allocate_deallocate, only: allocate_test, deallocate_test
  use Constants, only: deg2rad, ln10, pi
  use ForwardModelConfig, only: forwardmodelconfig_t
  use ForwardModelIntermediate, only:  forwardmodelstatus_t
  use ForwardModelVectortools, only: getquantityforforwardmodel
  use Geometry, only: earthrada, earthradb, earthsurfacegph, geodtogeoclat, &
    & G0, gm, j2, j4, omega => w
  use Init_tables_module, only: l_refgph, l_zeta
  use Intrinsic, only: l_heightoffset, l_none, l_ptan, l_scanresidual, &
    & L_temperature, l_tngtgeocalt, l_vmr, l_phitan, l_orbitinclination, &
    & Phyq_length
  use ManipulateVectorQuantities, only: findClosestInstances, &
d39 4
a42 4
  use MatrixModule_0, only: destroyBlock, matrixElement_t, m_absent, &
    & M_full, updateDiagonal
  use MatrixModule_1, only: createBlock, findBlock, matrix_t, &
    & CreateEmptyMatrix, destroyMatrix, clearMatrix
d45 12
a56 12
  use MLSNumerics, only : hunt, interpolateValues
  use MLSStringLists, only: switchDetail
  use Molecules, only: l_h2o
  use Output_m, only: output
  use QuantityTemplates, only: dump
  use Refraction_m, only: MaxRefraction, Refractive_Index, &
    & Refractive_Index_Deriv, Refractive_Index_f
  use Toggles, only: emit, toggle, switches
  use Trace_m, only: trace_begin, trace_end
  use VectorsModule, only : validatevectorquantity, &
    & Vector_t, vectortemplate_t, vectorvalue_t, createvector, &
    & Constructvectortemplate, destroyvectorinfo
d97 1
a97 1
    use Allocate_Deallocate, only: Deallocate_test
d112 4
a115 4
    use Dump_0, only: dump
    use ForwardModelConfig, only: dump
    use MLSStrings, only: writeIntsToChars
    use HighOutput, only: headLine, outputNamedValue
d165 2
a166 2
    use Physics, only: boltz
    use Trace_m, only: trace_begin, trace_end
d309 3
a311 3
    use HighOutput, only: outputNamedValue
    use Physics, only: boltz
    use Trace_m, only: trace_begin, trace_end
d566 3
a568 3
    use Dump_0, only: dump
    use Output_m, only: output
    use Quantitytemplates, only: quantityTemplate_t
d1043 3
a1047 2
    ! Executable code -----------------------

d1586 5
a1590 5
    use Get_eta_matrix_m, only: get_eta_sparse
    use Output_m, only: blanks, output
    use Physics, only: boltz
    use Piq_int_m, only: piq_int
    use Time_m, only: time_now
d2211 1
a2211 1
       "$Id: ScanModelModule.f90,v 2.87 2016/08/09 18:46:16 pwagner Exp $"
d2221 3
@


2.87
log
@Survives encounter with non-satellite data
@
text
@d1758 1
a1758 1
    if ( size(orbincline%values, 1) /= ptan%template%noSurfs ) then
d2210 1
a2210 1
       "$Id: ScanModelModule.f90,v 2.86 2016/01/23 02:59:18 vsnyder Exp $"
d2220 3
@


2.86
log
@Get MexRefraction from refraction_m, not geometry.  Get refractive index
derivatives from refraction_m instead of computing them here.  Add LaTeX.
@
text
@a86 2
  logical, parameter :: deeBug = .false.
  
d619 12
d1756 7
a1762 1
    sinbeta = sin(deg2rad*orbincline%values(1:ptan%template%noSurfs,fmStat%maf))
d2210 1
a2210 1
       "$Id: ScanModelModule.f90,v 2.85 2015/09/24 22:06:36 pwagner Exp $"
d2220 4
@


2.85
log
@Code around segment fault due to NAG bug
@
text
@d32 1
a32 1
    & G0, gm, j2, j4, omega => w, maxrefraction
d43 1
a43 1
  use MLSKinds, only: r8, rp, rv
d50 2
a51 1
  use Refraction_m, only: refractive_index, refraterm, refrbterm
d62 4
a65 4
  public :: DESTROYFORWARDMODELINTERMEDIATE, DUMPINSTANCEWINDOWS, &
    & GETBASISGPH, GETGPHPRECISION, &
    & GETHYDROSTATICTANGENTPRESSURE, GET2DHYDROSTATICTANGENTPRESSURE,      &
    & SCANFORWARDMODEL, TWODSCANFORWARDMODEL
d91 2
a92 1
  real (r8), parameter :: MAXPRESSURE = 1400.0 ! /mb Don't allow very large pressures
d827 1
a827 1
    call Allocate_Test ( pointingpres, ptan%template%noSurfs, "pointingpres", ModuleName )
d892 1
a892 1
          pointingpres = min(10**(-ptanVals), maxPressure)
d894 1
a894 2
          n=( (refrATerm*pointingpres) / pointingTemp ) * &
            & (1.0 + refrBTerm*pointingH2O/pointingTemp)
d896 1
a896 1
          n=min(n,maxRefraction) ! Forbid stupidly large values of n           
d1109 28
a1136 26
      integer, dimension(noMifs) :: POINTTEMPLAYER ! Pointing layer
      integer, dimension(noMifs) :: POINTH2OLAYER ! Pointing layer
      integer, dimension(noMafs) :: CLOSESTTEMPPROFILES
      integer, dimension(noMafs) :: CLOSESTH2OPROFILES

      real (r8), dimension(noMifs) :: DH2OBYDPTAN ! Derivative
      real (r8), dimension(noMifs) :: DHYDROSGPHBYDPTAN ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHBYDHEIGHTOFFSET ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHBYDL1REFRGEOCALT ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHBYDPTAN ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHBYDTEMPLOWER ! Derivative
      real (r8), dimension(noMifs) :: DL1GPHBYDTEMPUPPER ! Derivative
      real (r8), dimension(noMifs) :: DL1REFRGEOCALTBYDHEIGHTOFFSET ! Derivative
      real (r8), dimension(noMifs) :: DL1REFRGEOCALTBYDN ! Derivative
      real (r8), dimension(noMifs) :: DL1REFRGEOCALTBYDPTAN ! Derivative
      real (r8), dimension(noMifs) :: DL1REFRGEOCALTBYDTEMPLOWER ! Derivative
      real (r8), dimension(noMifs) :: DL1REFRGEOCALTBYDTEMPUPPER ! Derivative
      real (r8), dimension(noMifs) :: DNBYDPTAN ! Derivative
      real (r8), dimension(noMifs) :: DNBYDTEMPLOWER ! Derivative
      real (r8), dimension(noMifs) :: DNBYDTEMPUPPER ! Derivative
      real (r8), dimension(noMifs) :: DTEMPBYDPTAN ! Derivative
      real (r8), dimension(noMifs) :: GEOCLAT ! TP GeocLat
      real (r8), dimension(noMifs) :: H2OBASISGAP ! Basis spacing
      real (r8), dimension(noMifs) :: H2OLOWERWEIGHT ! Weight
      real (r8), dimension(noMifs) :: H2OUPPERWEIGHT ! Weight    
      real (r8), dimension(noMifs) :: HYDROSGPH ! GPH from hydrostatic calc.
d1138 1
a1138 1
      real (r8), dimension(noMifs) :: L1REFRGEOCALT ! Refracted geocentric alt
d1142 5
a1146 6
      real (r8), dimension(noMifs) :: POINTINGH2O ! tangent h2o.
      real (r8), dimension(noMifs) :: POINTINGPRES ! tangent pressure.
      real (r8), dimension(noMifs) :: POINTINGTEMP ! tangent temp.
      real (r8), dimension(noMifs) :: POVERTSQUARED ! As name implies
      real (r8), dimension(noMifs) :: RATIO2 ! For geopotential calculation
      real (r8), dimension(noMifs) :: RATIO4 ! For geopotential calculation
d1148 3
a1150 3
      real (r8), dimension(noMifs) :: TEMPBASISGAP ! Basis spacing
      real (r8), dimension(noMifs) :: TEMPLOWERWEIGHT ! Weight
      real (r8), dimension(noMifs) :: TEMPUPPERWEIGHT ! Weight
d1240 1
a1240 1
        dH2oByDPTan = ( h2oVals(pointH2oLayer+1) - h2oVals(pointH2oLayer) ) / &
d1243 1
a1243 1
        dH2oByDPTan = 0.0_r8
d1255 4
a1258 15
      ! Now get the refractive index n
      n=refrATerm/(pointingTemp/pointingPres) * &
        & (1.0+refrBterm*pointingH2O/pointingTemp)

      ! Get its derivatives wrt temp, and ptan (ignore h2o)
      pOverTSquared=pointingPres/(pointingTemp**2)

      dNByDPtan=n*(-LN10-dTempByDPtan/pointingTemp)+ &
        & (refrBTerm*refrATerm*pOverTSquared) * &
        & (dH2OByDPtan-(pointingH2O/pointingTemp)*dTempByDPtan)

      dNByDTempLower=-(tempLowerWeight*refrATerm) * &
        & pOverTSquared*(1+2*refrBTerm*pointingH2O/pointingTemp)
      dNByDTempUpper=-(tempUpperWeight*refrATerm) * &
        & pOverTSquared*(1+2*refrBTerm*pointingH2O/pointingTemp)
a1259 1
      ! Now if n is too big limit it and set derivatives to zero
d1261 3
a1263 1
        n=maxRefraction
d1266 24
a1289 1
        dNByDPtan = 0.0
d1292 3
a1294 4
      ! Do similar things for high pressure cases
      where ( 10.0_r8**(-ptanVals) > maxPressure )
        dNByDPtan=0.0
      end where
d2194 1
a2194 1
       "$Id: ScanModelModule.f90,v 2.84 2015/08/25 17:35:56 vsnyder Exp $"
d2204 3
@


2.84
log
@PhiWindow is a tuple, with the first element specifying the angles or
number of profiles/MAFs before the tangent point, and the second
specifying the angles or number after.
@
text
@d46 1
a46 1
  use MLSStringLists, only: switcHdetail
d114 2
a115 2
    use Mlsstrings, only: writeintstochars
    use Highoutput, only: headline, outputnamedvalue
d309 1
a309 1
    use HighOutput, only: headLine, outputNamedValue
d358 2
d372 1
a372 1
    integer, dimension( size(GPHPREC, 1), size(GPHPREC, 2) ) &
d374 2
d377 2
d467 1
d477 1
d480 1
a480 1
          & ( dgph_dT(:,surf,instance) * tempPrec%values(surf,instance) )**2
d484 5
d491 1
a491 1
      elseif ( all( tempPrec%values(:,instance) >= 0._rv ) ) then
d494 22
a515 8
        do surf = 1, myBelowRef
          if ( any( tempPrec%values(surf:myBelowRef, instance) < 0._rv ) ) &
              & ITSSIGN(surf, instance) = -1
        enddo
        do surf = myBelowRef+1, tempPrec%template%noSurfs
          if ( any( tempPrec%values(myBelowRef:surf, instance) < 0._rv ) ) &
            ITSSIGN(surf, instance) = -1
        enddo
d517 5
d525 1
a525 1
            if ( any( tempPrec%values(surf:myBelowRef, instance) < 0._rv ) ) &
d528 1
a528 1
            if ( tempPrec%values(surf, instance) < 0._rv ) &
d531 1
a531 1
            & any( tempPrec%values(myBelowRef:surf, instance) < 0._rv ) ) then
d538 4
d2180 1
a2180 1
       "$Id: ScanModelModule.f90,v 2.83 2015/06/19 21:15:50 pwagner Exp $"
d2190 5
@


2.83
log
@Maneuvers around calculation of ITSS; buggy NAG sometimes segment faults here
@
text
@d541 4
a544 4
    integer, intent(IN) :: MAXITERATIONS ! Number of iterations to use
    real(r8), intent(in) :: PHIWINDOW   ! For 2D or not
    integer, intent(in) :: PHIWINDOWUNITS
    integer, intent(in), optional :: chunkNo
a1675 1
    CALL ALLOCATE_TEST(earthradc,ptan%template%nosurfs,'earthradc',modulename)
a1680 4
    CALL ALLOCATE_TEST(red_phi_t,ptan%template%nosurfs,'red_phi_t',modulename)
    CALL ALLOCATE_TEST(sinphi2,ptan%template%nosurfs,'sinphi2',modulename)
    CALL ALLOCATE_TEST(cosphi2,ptan%template%nosurfs,'cosphi2',modulename)
    CALL ALLOCATE_TEST(sinlat2,ptan%template%nosurfs,'sinlat2',modulename)
a1681 2
    CALL ALLOCATE_TEST(sinbeta,ptan%template%nosurfs,'sinbeta',modulename)
    CALL ALLOCATE_TEST(geoclats,ptan%template%nosurfs,'geoclats',modulename)
d1689 7
d2144 1
a2144 1
       "$Id: ScanModelModule.f90,v 2.82 2015/06/04 03:14:14 vsnyder Exp $"
d2154 3
@


2.82
log
@Make Surfs component of quantity template allocatable
@
text
@d26 30
a55 28
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use CONSTANTS, only: DEG2RAD, LN10, PI
  use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
  use FORWARDMODELINTERMEDIATE, only:  FORWARDMODELSTATUS_T
  use FORWARDMODELVECTORTOOLS, only: GETQUANTITYFORFORWARDMODEL
  use GEOMETRY, only: EARTHRADA, EARTHRADB, EARTHSURFACEGPH, GEODTOGEOCLAT, &
    & G0, GM, J2, J4, OMEGA => W, MAXREFRACTION
  use INIT_TABLES_MODULE, only: L_REFGPH, L_ZETA
  use INTRINSIC, only: L_HEIGHTOFFSET, L_NONE, L_PTAN, L_SCANRESIDUAL, &
    & L_TEMPERATURE, L_TNGTGEOCALT, L_VMR, L_PHITAN, L_ORBITINCLINATION, &
    & PHYQ_LENGTH
  use MANIPULATEVECTORQUANTITIES, only: FINDCLOSESTINSTANCES, &
    & FINDINSTANCEWINDOW
  use MATRIXMODULE_0, only: DESTROYBLOCK, MATRIXELEMENT_T, M_ABSENT, &
    & M_FULL, UPDATEDIAGONAL
  use MATRIXMODULE_1, only: CREATEBLOCK, FINDBLOCK, MATRIX_T, &
    & CREATEEMPTYMATRIX, DESTROYMATRIX, CLEARMATRIX
  use MLSKINDS, only: R8, RP, RV
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
  use MLSNUMERICS, only : HUNT, INTERPOLATEVALUES
  use MLSSTRINGLISTS, only: SWITCHDETAIL
  use MOLECULES, only: L_H2O
  use REFRACTION_M, only: REFRACTIVE_INDEX, REFRATERM, REFRBTERM
  use TOGGLES, only: EMIT, TOGGLE, SWITCHES
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use VECTORSMODULE, only : VALIDATEVECTORQUANTITY, &
    & VECTOR_T, VECTORTEMPLATE_T, VECTORVALUE_T, CREATEVECTOR, &
    & CONSTRUCTVECTORTEMPLATE, DESTROYVECTORINFO
d57 1
a57 1
  implicit NONE
d86 1
d97 1
a97 1
    use Allocate_Deallocate, only: DEALLOCATE_TEST
d112 4
a115 4
    use DUMP_0, only: DUMP
    use FORWARDMODELCONFIG, only: DUMP
    use MLSSTRINGS, only: WRITEINTSTOCHARS
    use HIGHOUTPUT, only: HEADLINE, OUTPUTNAMEDVALUE
d165 2
a166 2
    use PHYSICS, only: BOLTZ
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d309 3
a311 2
    use PHYSICS, only: BOLTZ
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d373 1
d394 5
d453 13
a465 1

d478 11
d495 3
d504 1
d506 1
a506 5
    ! This displayed excessive zeal--it turned all precisions negative
    ! if ( refGPHPrec%values(1,instance) < 0._rv .or. &
    !   & any( tempPrec%values(1:tempPrec%template%noSurfs,instance) < 0._rv ) ) &
    !   & ITSSIGN(:, instance) = -1
    end do
d530 3
a532 3
    use DUMP_0, only: DUMP
    use OUTPUT_M, only: OUTPUT
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T
d1525 5
a1529 5
    use GET_ETA_MATRIX_M, only: GET_ETA_SPARSE
    use OUTPUT_M, only: BLANKS, OUTPUT
    use PHYSICS, only: BOLTZ
    use PIQ_INT_M, only: PIQ_INT
    use TIME_M, only: TIME_NOW
d2144 1
a2144 1
       "$Id: ScanModelModule.f90,v 2.81 2014/07/18 23:17:59 pwagner Exp $"
d2154 3
@


2.81
log
@Aimed for consistency in names passed to allocate_test
@
text
@d652 2
d655 1
a655 1
    type (VectorValue_T), intent(in) :: TEMP    ! Temperature
d657 1
a657 1
    type (VectorValue_T), intent(in) :: H2O     ! H2O
d2111 1
a2111 1
       "$Id: ScanModelModule.f90,v 2.80 2014/01/09 00:30:24 pwagner Exp $"
d2121 3
@


2.80
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d1727 1
a1727 1
      & 'tan_refr_indx', modulename)
d2109 1
a2109 1
       "$Id: ScanModelModule.f90,v 2.79 2013/08/31 02:29:12 vsnyder Exp $"
d2119 3
@


2.79
log
@Replace MLSMessageCalls with trace_begin and trace_end
@
text
@d112 1
a112 1
    use OUTPUT_M, only: HEADLINE, OUTPUTNAMEDVALUE
d2109 1
a2109 1
       "$Id: ScanModelModule.f90,v 2.78 2013/08/30 02:45:47 vsnyder Exp $"
d2119 3
@


2.78
log
@Revise calls to trace_begin and trace_end
@
text
@d44 1
a44 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING, &
    & MLSMESSAGECALLS
d163 1
d193 2
d205 1
a205 1
    call MLSMessageCalls( 'push', constantName='GetBasisGPH' )
d296 1
a296 1
    call MLSMessageCalls( 'pop' )
d307 1
d355 2
d369 1
a369 1
    call MLSMessageCalls( 'push', constantName='GepGPHPrecision' )
d485 1
a485 1
    call MLSMessageCalls( 'pop' )
d2109 1
a2109 1
       "$Id: ScanModelModule.f90,v 2.77 2013/06/12 02:38:33 vsnyder Exp $"
d2119 3
@


2.77
log
@Cruft removal
@
text
@d105 1
a105 1
  ! ---------------------------------------- DumpInstanceWindows -----------
d159 1
a159 1
  ! ----------------------------------------------- GetBasisGPH ---------------
d298 1
a298 1
  ! ----------------------------------------------- GetGPHPrecision ---------------
d484 1
a484 1
  ! ---------------------------------- Get2DHydroStaticTangentPressure ----------
d527 1
d535 1
a535 1
    if ( toggle(emit) ) call trace_begin ('Get2DHydrostaticTangentPressure' )
d634 1
a634 1
    if ( toggle(emit) ) call trace_end ('Get2DHydrostaticTangentPressure' )
d638 1
a638 1
  ! ---------------------------------- GetHydroStaticTangentPressure ----------
d695 1
d699 1
a699 1
    if ( toggle(emit) ) call trace_begin ('GetHydrostaticTangentPressure' )
d909 1
a909 1
    if ( toggle(emit) ) call trace_end ('GetHydrostaticTangentPressure' )
d913 1
a913 1
  ! ---------------------------------------- ScanForwardModel --------------
d937 1
d956 1
a956 1
    if ( toggle ( emit ) ) call trace_begin ( 'ScanForwardModel' )
d1011 1
a1011 1
    if ( toggle ( emit ) ) call trace_end ( 'ScanForwardModel' )
d1481 1
a1481 1
  ! ---------------------------------------- twodScanForwardModel -----------
d1518 9
a1526 8
    INTEGER :: windowstart_t         ! first instance for temperature
    INTEGER :: windowfinish_t        ! last instance for temperature
    INTEGER :: windowstart_h2o       ! first instance for water vapor
    INTEGER :: windowfinish_h2o      ! last instance for water vapor
    INTEGER :: sv_z                  ! height basis index
    INTEGER :: sv_p                  ! horizontal basis index
    INTEGER :: row                   ! Block row in jacobian
    INTEGER :: col                   ! Block col in jacobian
d1528 3
a1530 3
    REAL(rp) :: z_surf
    REAL(rp) :: surf_temp
    REAL(rp) :: surf_refr_indx(1)
d1532 1
a1532 1
    REAL(rp), POINTER :: earthradc(:)  ! square of minor axis of earth ellipsoid
d1534 35
a1568 35
    REAL(rp), POINTER :: red_phi_t(:)
    REAL(rp), POINTER :: sinbeta(:)
    REAL(rp), POINTER :: sinphi2(:)
    REAL(rp), POINTER :: cosphi2(:)
    REAL(rp), POINTER :: geoclats(:)
    REAL(rp), POINTER :: sinlat2(:)
    REAL(rp), POINTER :: coslat2(:)
    REAL(rp), POINTER :: g_ref(:)
    REAL(rp), POINTER :: earth_radius(:)
    REAL(rp), POINTER :: eff_earth_radius(:)
    REAL(rp), POINTER :: p2(:)
    REAL(rp), POINTER :: p4(:)
    REAL(rp), POINTER :: ratio2(:)
    REAL(rp), POINTER :: ratio4(:)
    REAL(rp), POINTER :: ratio2_gph(:)
    REAL(rp), POINTER :: ratio4_gph(:)
    REAL(rp), POINTER :: tan_temp(:)
    REAL(rp), POINTER :: tan_h2o(:)
    REAL(rp), POINTER :: tan_refr_indx(:)
    REAL(rp), POINTER :: l1altrefr(:)
    REAL(rp), POINTER :: refgeomalt_denom(:)
    REAL(rp), POINTER :: l1refalt(:)
    REAL(rp), POINTER :: mass_corr(:)
    REAL(rp), POINTER :: dgphdr(:)
    REAL(rp), POINTER :: dscandz(:)
    REAL(rp), POINTER :: temp_at_surf_phi(:)
    REAL(rp), POINTER :: eta_z(:,:)
    REAL(rp), POINTER :: eta_p_t(:,:)
    REAL(rp), POINTER :: eta_p_h2o(:,:)
    REAL(rp), POINTER :: piq(:,:)
    REAL(rp), POINTER :: eta_piqxp(:,:)
    REAL(rp), POINTER :: eta_zxp_t(:,:)
    REAL(rp), POINTER :: eta_zxp_h2o(:,:)
    REAL(rp), POINTER :: eta_at_one_phi(:)
    REAL(rp), POINTER :: eta_at_one_zeta(:)
d1570 5
a1574 5
    LOGICAL, POINTER :: not_zero_z(:,:)
    LOGICAL, POINTER :: not_zero_p_t(:,:)
    LOGICAL, POINTER :: not_zero_p_h2o(:,:)
    LOGICAL, POINTER :: not_zero_t(:,:)
    LOGICAL, POINTER :: not_zero_h2o(:,:)
d1581 2
a1582 2
    if ( toggle(emit) ) & ! set by -f command-line switch
      & call trace_begin ( 'TwoDScanForwardModel, MAF=', index=fmstat%maf )
d1594 1
a1594 1
    NULLIFY ( coslat2, cosphi2, dgphdr, dscandz, earthradc, earth_radius,      &
d2029 2
a2030 1
    if ( toggle(emit) ) call trace_end ( 'TwoDScanForwardModel MAF=', fmStat%maf )
d2104 1
a2104 1
       "$Id: ScanModelModule.f90,v 2.76 2013/03/01 01:11:10 pwagner Exp $"
d2114 3
@


2.76
log
@Added DumpInstanceWindows
@
text
@d113 1
a113 1
    use OUTPUT_M, only: HEADLINE, OUTPUT, OUTPUTNAMEDVALUE
d2099 1
a2099 1
       "$Id: ScanModelModule.f90,v 2.75 2012/06/06 20:13:37 vsnyder Exp $"
d2109 3
@


2.75
log
@Avoid overflow if ptan is bogus because module is turned off
@
text
@d60 4
a63 3
  public :: DestroyForwardModelIntermediate, GetBasisGPH, GetGPHPrecision, &
    & GetHydrostaticTangentPressure, Get2DHydrostaticTangentPressure,      &
    & ScanForwardModel, TwoDScanForwardModel
d105 54
d163 1
a163 1
    use Physics, only: Boltz
d304 1
a304 1
    use Physics, only: Boltz
d492 3
a494 3
    use Dump_0, only: DUMP
    use Output_M, only: OUTPUT
    use QuantityTemplates, only: QuantityTemplate_T
a1481 1
use dump_0, only: dump
d2099 1
a2099 1
       "$Id: ScanModelModule.f90,v 2.74 2012/04/20 01:54:20 vsnyder Exp $"
d2109 3
@


2.74
log
@Remove GeocLat from Get2DHydrostaticTangentPressure, make EarthRadius
automatic.  Add some dumps.  Print a warning if the initial pressure
guess is <-4 or >10.  Probably still gets overflows if the module is turned
off.  More tracing.
@
text
@d1769 2
a1770 2
    CALL refractive_index(10.0_rp**(-ptan%values(:,fmStat%maf)), tan_temp, &
    & tan_refr_indx,h2o_path = tan_h2o)
d2045 1
a2045 1
       "$Id: ScanModelModule.f90,v 2.73 2011/05/09 18:25:12 pwagner Exp $"
d2055 6
@


2.73
log
@Converted to using switchDetail
@
text
@d457 9
a465 9
    type (QuantityTemplate_T) :: scanResidual ! Scan residual
    type (QuantityTemplate_T) :: myQTs(NoQtys) ! All our quantities
    type (Vector_T) :: state            ! Gets ptan
    type (Vector_T) :: extra            ! Gets temp,refGPH,h2o and geocAlt
    type (Vector_T) :: residual         ! Gets the scan residual
    type (VectorTemplate_T) :: stateTemplate ! Gets ptan
    type (VectorTemplate_T) :: extraTemplate ! Gets temp,refGPH,h2o and geocAlt
    type (VectorTemplate_T) :: residualTemplate ! Gets the scan residual
    type (Matrix_T) :: jacobian         ! dScanresidual/dPtan
d470 1
a470 1
    integer :: i                        ! Iteration counter
d472 2
a473 2
    real (r8), dimension(:,:), pointer :: GEOCLAT ! Geocentric latitude (minor frame)
    real (r8), dimension(:,:), pointer :: EARTHRADIUS ! Earth radius (minor frame)
d478 3
a480 8
    nullify ( geocLat, earthRadius )
    call Allocate_test ( geocLat, &
      & ptan%template%noSurfs, ptan%template%noInstances, &
      & 'geocLat', ModuleName )
    call Allocate_test ( earthRadius, &
      & ptan%template%noSurfs, ptan%template%noInstances, &
      & 'geocLat', ModuleName )
    geocLat = GeodToGeocLat(ptan%template%geodLat)
d482 14
a495 6
      & (earthRadA**2-earthRadB**2)*sin(geocLat)**2 + earthRadB**2)
    ptan%values = -3.0+(geocAlt%values - earthRadius)/16e3
    if ( switchDetail ( switches, 'pguess' ) > -1 ) &
      & call dump ( ptan%values, 'Initial ptan guess' )
    call Deallocate_test ( earthRadius, 'geocLat', ModuleName )
    call Deallocate_test ( geocLat, 'geocLat', ModuleName )
d545 5
a549 5
       call TwoDScanForwardModel ( fmConf, state, extra, residual, &
         & fmStat, jacobian, chunkNo )
       state%quantities(1)%values(:,maf) = state%quantities(1)%values(:,maf) - &
         & residual%quantities(1)%values(:,maf) / &
         &   jacobian%block(maf,maf)%values(:,1)
d555 1
a555 2
        call output ( ' mean, min abs, max abs residual:', advance='yes' )
        call output ( '  ' )
d558 2
a559 4
        call output ( ', ' )
        call output ( minval(abs(residual%quantities(1)%values)) )
        call output ( ', ' )
        call output ( maxval(abs(residual%quantities(1)%values)), &
d577 3
a879 5
    integer :: COL                      ! Block col in jacobian
    integer :: I                        ! Loop index
    integer :: J                        ! Loop index
    integer :: LOWER                    ! Index into T profile
    integer :: MAF                      ! Major frame to consider
a882 1
    integer :: ROW                      ! Block row in jacobian
a883 62
    integer, dimension(:), pointer :: POINTTEMPLAYER ! Pointing layer
    integer, dimension(:), pointer :: POINTH2OLAYER ! Pointing layer
    integer, dimension(:), pointer :: CLOSESTTEMPPROFILES
    integer, dimension(:), pointer :: CLOSESTH2OPROFILES

    real (r8), target :: ZERO=0.0_r8    ! Need this if no heightOffset
    real (r8), pointer :: HTOFF         ! HeightOffset%values or zero
    real (r8) :: USEPTAN                ! A tangent pressure
    real (r8) :: BASIS                    ! Index
    real (r8) :: BASISMINUS               ! Index
    real (r8) :: BASISPLUS                ! Index

    ! All these will be dimensioned noMIFs.
    real (r8), dimension(:), pointer :: BASISGPH ! From ifm
    real (r8), dimension(:), pointer :: DH2OBYDPTAN ! Derivative
    real (r8), dimension(:), pointer :: DHYDROSGPHBYDPTAN ! Derivative
    real (r8), dimension(:), pointer :: DL1GPHBYDHEIGHTOFFSET ! Derivative
    real (r8), dimension(:), pointer :: DL1GPHBYDL1REFRGEOCALT ! Derivative
    real (r8), dimension(:), pointer :: DL1GPHBYDPTAN ! Derivative
    real (r8), dimension(:), pointer :: DL1GPHBYDTEMPLOWER ! Derivative
    real (r8), dimension(:), pointer :: DL1GPHBYDTEMPUPPER ! Derivative
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDHEIGHTOFFSET ! Derivative
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDN ! Derivative
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDPTAN ! Derivative
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDTEMPLOWER ! Derivative
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDTEMPUPPER ! Derivative
    real (r8), dimension(:), pointer :: DNBYDPTAN ! Derivative
    real (r8), dimension(:), pointer :: DNBYDTEMPLOWER ! Derivative
    real (r8), dimension(:), pointer :: DNBYDTEMPUPPER ! Derivative
    real (r8), dimension(:), pointer :: DTEMPBYDPTAN ! Derivative
    real (r8), dimension(:), pointer :: GEOCLAT ! TP GeocLat
    real (r8), dimension(:), pointer :: H2OBASIS ! => h2o%template%surfs
    real (r8), dimension(:), pointer :: H2OBASISGAP ! Basis spacing
    real (r8), dimension(:), pointer :: H2OLOWERWEIGHT ! Weight
    real (r8), dimension(:), pointer :: H2OUPPERWEIGHT ! Weight    
    real (r8), dimension(:), pointer :: H2OVALS ! => h2o%values
    real (r8), dimension(:), pointer :: HYDROSGPH ! GPH from hydrostatic calc.
    real (r8), dimension(:), pointer :: L1GPH ! Geometric geopotential
    real (r8), dimension(:), pointer :: L1REFRGEOCALT ! Refracted geocentric alt
    real (r8), dimension(:), pointer :: N ! Refractive index - 1
    real (r8), dimension(:), pointer :: P2 ! Polynomial term
    real (r8), dimension(:), pointer :: P4 ! Polynomial term
    real (r8), dimension(:), pointer :: POINTINGH2O ! tangent h2o.
    real (r8), dimension(:), pointer :: POINTINGPRES ! tangent pressure.
    real (r8), dimension(:), pointer :: POINTINGTEMP ! tangent temp.
    real (r8), dimension(:), pointer :: POVERTSQUARED ! As name implies
    real (r8), dimension(:), pointer :: PTANVALS ! => ptan%values
    real (r8), dimension(:), pointer :: RATIO2 ! For geopotential calculation
    real (r8), dimension(:), pointer :: RATIO4 ! For geopotential calculation
    real (r8), dimension(:), pointer :: RT ! Gas constant*T
    real (r8), dimension(:), pointer :: S2 ! sin^2 geocLat
    real (r8), dimension(:), pointer :: TEMPBASIS ! => temp%template%surfs
    real (r8), dimension(:), pointer :: TEMPBASISGAP ! Basis spacing
    real (r8), dimension(:), pointer :: TEMPLOWERWEIGHT ! Weight
    real (r8), dimension(:), pointer :: TEMPUPPERWEIGHT ! Weight
    real (r8), dimension(:), pointer :: TEMPVALS ! => temp%values

    real (r8), dimension(:,:), pointer :: A ! Derivative array
    real (r8), dimension(:,:), pointer :: DHYDROSGPHBYDTEMP ! Derivative array

    logical :: TEMPINSTATE              ! Set if temp in state not extra
    logical :: REFGPHINSTATE            ! Set if refGPH in state not extra
d885 1
d887 2
a888 1
    logical :: HEIGHTOFFSETINSTATE      ! Set if heightOffset in state, not extra
d890 3
a892 1
    type (VectorValue_T), pointer :: TEMP ! Temperature component of state
a893 1
    type (VectorValue_T), pointer :: H2O ! H2O component of state
a894 1
    type (VectorValue_T), pointer :: L1ALT ! Tangent point altitude
d896 1
a896 1
    type (VectorValue_T), pointer :: HEIGHTOFFSET ! Height offset component of state
d898 1
a898 1
    type (MatrixElement_T), pointer :: BLOCK ! A matrix block
a901 2
    if ( toggle ( emit ) ) call trace_begin ( 'ScanForwardModel' )

a948 1
    maf = fmStat%maf
d952 2
d955 1
a955 2
    nullify ( pointTempLayer, pointH2OLayer )
    nullify ( closestTempProfiles, closestH2OProfiles )
d957 1
a957 102
    nullify ( dh2obydptan, dhydrosgphbydptan, dl1gphbydheightoffset )
    nullify ( dl1gphbydl1refrgeocalt, dl1gphbydptan, dl1gphbydtemplower )
    nullify ( dl1gphbydtempupper,  dl1refrgeocaltbydheightoffset )
    nullify ( dl1refrgeocaltbydn, dl1refrgeocaltbydptan )
    nullify ( dl1refrgeocaltbydtemplower, dl1refrgeocaltbydtempupper )
    nullify ( dnbydptan, dnbydtemplower, dnbydtempupper, dtempbydptan )
    nullify ( geoclat, h2obasisgap, h2olowerweight )
    nullify ( h2oupperweight, hydrosgph, l1gph, l1refrgeocalt )
    nullify ( n, p2, p4, pointingh2o, pointingpres, pointingtemp )
    nullify ( povertsquared, ratio2, ratio4 )
    nullify ( rt, s2, tempbasisgap )
    nullify ( templowerweight, tempupperweight )

    nullify ( A, dHydrosGPHByDTemp )

    ! Now set up pointer arrays (there are a lot of these)
    call allocate_test ( pointTempLayer, noMIFs,&
      & 'pointTempLayer', ModuleName )
    call allocate_test ( pointH2OLayer, noMIFs, &
      & 'pointH2OLayer', ModuleName )
    call allocate_test ( closestTempProfiles, noMAFs,&
      & 'closestTempProfiles', ModuleName )
    call allocate_test ( closestH2OProfiles, noMAFs,&
      & 'closestH2OProfiles', ModuleName )

    call allocate_test ( dH2OByDPtan, noMIFs, &
      & 'dH2OByDPtan', ModuleName )
    call allocate_test ( dHydrosGPHByDPtan, noMIFs, &
      & 'dHydrosGPHByDPtan', ModuleName )
    call allocate_test ( dL1GPHByDHeightOffset, noMIFs, &
      & 'dL1GPHByDHeightOffset', ModuleName )
    call allocate_test ( dL1GPHByDL1RefrGeocAlt, noMIFs, &
      & 'dL1GPHByDL1RefrGeocAlt', ModuleName )
    call allocate_test ( dL1GPHByDPtan, noMIFs, &
      & 'dL1GPHByDPtan', ModuleName )
    call allocate_test ( dL1GPHByDTempLower, noMIFs, &
      & 'dL1GPHByDTempLower', ModuleName )
    call allocate_test ( dL1GPHByDTempUpper, noMIFs, &
      & 'dL1GPHByDTempLower', ModuleName )
    call allocate_test ( dL1RefrGeocAltByDHeightOffset, noMIFs, &
      & 'dL1RefrGeocAltByDHeightOffset', ModuleName )
    call allocate_test ( dL1RefrGeocAltByDN, noMIFs, &
      & 'dL1RefrGeocAltByDN', ModuleName )
    call allocate_test ( dL1RefrGeocAltByDPtan, noMIFs, &
      & 'dL1RefrGeocAltByDPtan', ModuleName )
    call allocate_test ( dL1RefrGeocAltByDTempLower, noMIFs, &
      & 'dL1RefrGeocAltByDTempLower', ModuleName )
    call allocate_test ( dL1RefrGeocAltByDTempUpper, noMIFs, &
      & 'dL1RefrGeocAltByDTempUpper', ModuleName )
    call allocate_test ( dNByDPtan, noMIFs, &
      & 'dNByDPtan', ModuleName )
    call allocate_test ( dNByDTempLower, noMIFs, &
      & 'dNByDTempLower', ModuleName )
    call allocate_test ( dNByDTempUpper, noMIFs, &
      & 'dNByDTempUpper', ModuleName )
    call allocate_test ( dTempByDPtan, noMIFs, &
      & 'dTempByDPtan', ModuleName )
    call allocate_test ( geocLat, noMIFs, &
      & 'geocLat', ModuleName )
    call allocate_test ( h2oBasisGap, noMIFs, &
      & 'h2oBasisGap', ModuleName )
    call allocate_test ( h2oLowerWeight, noMIFs, &
      & 'h2oLowerWeight', ModuleName )
    call allocate_test ( h2oUpperWeight, noMIFs, &
      & 'h2oUpperWeight', ModuleName )
    call allocate_test ( hydrosGPH, noMIFs, &
      & 'hydrosGPH', ModuleName )
    call allocate_test ( l1GPH, noMIFs, &
      & 'l1GPH', ModuleName )
    call allocate_test ( l1RefrGeocAlt, noMIFs, &
      & 'l1RefrGeocAlt', ModuleName )
    call allocate_test ( n, noMIFs, &
      & 'n', ModuleName )
    call allocate_test ( p2, noMIFs, &
      & 'p2', ModuleName )
    call allocate_test ( p4, noMIFs, &
      & 'p4', ModuleName )
    call allocate_test ( pointingH2O, noMIFs, &
      & 'pointingH2O', ModuleName )
    call allocate_test ( pointingPres, noMIFs, &
      & 'pointingPres', ModuleName )
    call allocate_test ( pointingTemp, noMIFs, &
      & 'pointingTemp', ModuleName )
    call allocate_test ( pOverTSquared, noMIFs, &
      & 'pOverTSquared', ModuleName )
    call allocate_test ( ratio2, noMIFs, &
      & 'ratio2', ModuleName )
    call allocate_test ( ratio4, noMIFs, &
      & 'ratio4', ModuleName )
    call allocate_test ( s2, noMIFs, &
      & 's2', ModuleName )
    call allocate_test ( tempBasisGap, noMIFs, &
      & 'tempBasisGap', ModuleName )
    call allocate_test ( tempLowerWeight, noMIFs, &
      & 'tempLowerWeight', ModuleName )
    call allocate_test ( tempUpperWeight, noMIFs, &
      & 'tempUpperWeight', ModuleName )

    call allocate_test ( A, noMIFs+1, noTemps, & ! Extra for refGPH
      & 'A', ModuleName )
    call allocate_test ( dHydrosGPHByDTemp, noMIFs, noTemps, &
      & 'dHydrosGPHByDTemp', ModuleName )
d959 1
a959 4
    ! This could maybe be store in ifm, but for the moment, we'll do it each
    ! time
    call FindClosestInstances ( temp, ptan, closestTempProfiles )
    call FindClosestInstances ( h2o, ptan, closestH2OProfiles )
d961 80
a1040 3
    ! Make some pointers to save time
    tempVals => temp%values (:,closestTempProfiles(maf) )
    h2oVals => h2o%values(:,closestH2OProfiles(maf) )
d1042 8
a1049 8
    tempBasis => temp%template%surfs(:,1)
    h2oBasis => h2o%template%surfs(:,1)
    ptanVals => ptan%values(:,maf)
    if ( associated( heightOffset ) ) then
      htOff => heightOffset%values(1,1)
    else
      htOff => zero
    end if
d1051 149
a1199 6
    ! Do some preamble calcaulations
    geocLat = GeodToGeocLat( ptan%template%geodLat(:,maf) )
    ! Get terms for geopotential expression
    s2 = (sin(geocLat))**2
    p2 = 0.5 * (3*s2-1) ! Polynomial terms
    p4 = 0.125 * (35*(s2**2) - 30*s2 + 3)
d1201 2
a1202 8
    ! The first part of the calculation is the geometric calculation. This is in
    ! three stages.
    
    ! First we convert the level 1 geodetic heights to geocentric ones.
    ! Then we refract these heights given our knowledge of temperature and pressure
    ! Lastly we convert these heights to geopotentials.
    ! For each of these stages we need to calculate derivatives
    
d1204 34
a1237 3
    ! We have to refract the L1altitudes. In order to do that we need the
    ! refractive index, for which we need pressure and the temperature corresponding
    ! to that pressure.
d1239 2
a1240 2
    ! First find the layer each pointing is in, both for T and H2O, and
    ! thence calculate the refractive indicies
d1242 2
d1245 46
a1290 84
    ! Find temp and h2o layers
    call Hunt ( tempBasis, ptanVals, pointTempLayer )
    call Hunt ( h2oBasis,  ptanVals, pointH2OLayer )
    
    ! Calculate lower and upper weights
    tempBasisGap = tempBasis(pointTempLayer+1) - tempBasis(pointTempLayer)
    h2oBasisGap = h2oBasis(pointH2OLayer+1) - h2oBasis(pointH2OLayer)

    ! Compute weights
    tempUpperWeight = (ptanVals-tempBasis(pointTempLayer))/tempBasisGap
    tempLowerWeight = 1.0 - tempUpperWeight
    h2oUpperWeight = (ptanVals-h2oBasis(pointH2oLayer))/h2oBasisGap
    h2oLowerWeight = 1.0 - h2oUpperWeight

    ! Constrain to constant so we get no extrapolation
    tempUpperWeight = max ( 0.0_r8, min( 1.0_r8, tempUpperWeight ) )
    tempLowerWeight = max ( 0.0_r8, min( 1.0_r8, tempLowerWeight ) )
    h2oUpperWeight = max ( 0.0_r8, min( 1.0_r8, h2oUpperWeight ) )
    h2oLowerWeight = max ( 0.0_r8, min( 1.0_r8, h2oLowerWeight ) )

    ! Now compute derivatives wrt ptan for later chain rule use.
    where (ptanVals>=tempBasis(1) .and. ptanVals<tempBasis(noTemps))
      dTempByDPTan = ( tempVals(pointTempLayer+1) - tempVals(pointTempLayer) ) / &
        & tempBasisGap
    elsewhere
      dTempByDPTan = 0.0_r8
    endwhere

    where (ptanVals>=h2oBasis(1) .and. ptanVals<h2oBasis(h2o%template%noSurfs))
      dH2oByDPTan = ( h2oVals(pointH2oLayer+1) - h2oVals(pointH2oLayer) ) / &
        & h2oBasisGap
    elsewhere
      dH2oByDPTan = 0.0_r8
    endwhere
  
    ! Now get interpolated temperature and H2O
    pointingTemp = tempVals(pointTempLayer) * tempLowerWeight + &
      &            tempVals(pointTempLayer+1) * tempUpperWeight 
    pointingH2O = h2oVals(pointH2OLayer) * h2oLowerWeight + &
      &           h2oVals(pointH2OLayer+1) * h2oUpperWeight

    ! Get pointing pressure in mb
    pointingPres = min(10.0_r8**(-ptanVals), maxPressure)

    ! Now get the refractive index n
    n=refrATerm/(pointingTemp/pointingPres) * &
      & (1.0+refrBterm*pointingH2O/pointingTemp)

    ! Get its derivatives wrt temp, and ptan (ignore h2o)
    pOverTSquared=pointingPres/(pointingTemp**2)

    dNByDPtan=n*(-LN10-dTempByDPtan/pointingTemp)+ &
      & (refrBTerm*refrATerm*pOverTSquared) * &
      & (dH2OByDPtan-(pointingH2O/pointingTemp)*dTempByDPtan)

    dNByDTempLower=-(tempLowerWeight*refrATerm) * &
      & pOverTSquared*(1+2*refrBTerm*pointingH2O/pointingTemp)
    dNByDTempUpper=-(tempUpperWeight*refrATerm) * &
      & pOverTSquared*(1+2*refrBTerm*pointingH2O/pointingTemp)

    ! Now if n is too big limit it and set derivatives to zero
    where ( n > maxRefraction )
      n=maxRefraction
      dNByDTempLower = 0.0
      dNByDTempUpper = 0.0
      dNByDPtan = 0.0
    end where

    ! Do similar things for high pressure cases
    where ( 10.0_r8**(-ptanVals) > maxPressure )
      dNByDPtan=0.0
    end where

    ! Now from this calculate the refracted geocentric altitudes
    l1RefrGeocAlt= ( l1Alt%values(:,maf) + htOff ) / (1.0+n)

    ! And calculate their derivatives, again ignore H2O
    dl1RefrGeocAltByDHeightOffset = 1.0 / (1.0+n)
    dl1RefrGeocAltByDn = -l1RefrGeocAlt / (1.0+n)
    
    dl1RefrGeocAltByDPtan = dL1RefrGeocAltByDn * dNByDPtan
    
    dl1RefrGeocAltByDTempLower = dl1RefrGeocAltByDn * dNByDTempLower
    dl1RefrGeocAltByDTempUpper = dl1RefrGeocAltByDn * dNByDTempUpper
d1292 10
a1301 3
    ! Now we want to convert these to geopotentials
    ratio2=(earthRadA/l1RefrGeocAlt)**2
    ratio4=ratio2**2
d1303 5
a1307 36
    l1GPH = -(GM/(l1RefrGeocAlt*g0)) * &
      & (1-J2*P2*ratio2-J4*P4*ratio4) - &
      & ((omega*l1RefrGeocAlt*cos(geocLat))**2)/(2*g0) + earthSurfaceGPH

    dL1GPHByDL1RefrGeocAlt= ( (GM/(l1RefrGeocAlt**2)) * &
      & (1-3*J2*P2*ratio2-5*J4*P4*ratio4) - &
      & omega**2*l1RefrGeocAlt*(cos(geocLat))**2 ) / g0

    ! Now get the combined derivatives for the l1Geopt's
    dL1GPHByDHeightOffset = dL1GPHByDL1RefrGeocAlt * &
      & dL1RefrGeocAltByDHeightOffset
    dL1GPHByDPtan = dL1GPHByDL1RefrGeocAlt * &
      & dL1RefrGeocAltByDPtan
    dL1GPHByDTempLower = dL1GPHByDL1RefrGeocAlt * &
      & dL1RefrGeocAltByDTempLower
    dL1GPHByDTempUpper = dL1GPHByDL1RefrGeocAlt * &
      & dL1RefrGeocAltByDTempUpper

    ! --------------------------------------------------------
    ! That's the end of the geometric geopotential calculation
    ! Now we're onto the hydrostatic calculation
    ! --------------------------------------------------------

    ! If this is the very first call, setup the hydrostatic temperature
    ! grid.
    if ( fmStat%newScanHydros ) then
      call allocate_test ( ifm%basisGPH, noTemps, &
        & temp%template%noInstances, 'ifm%gph', ModuleName )
      call allocate_test ( ifm%RT,  noTemps, &
        & temp%template%noInstances, 'ifm%gph', ModuleName )
      call allocate_test ( ifm%R, noTemps, &
        & 'ifm%gph', ModuleName )
      call GetBasisGPH ( temp, refGPH, ifm%basisGPH, &
        & ifm%R, ifm%RT, belowRef=ifm%belowRef )
      fmStat%newScanHydros = .false.
    end if
d1309 6
a1314 33
    rt => ifm%rt(:, closestTempProfiles(maf) )
    basisGPH => ifm%basisGPH (:, closestTempProfiles(maf) )

    ! Compute the basisGPH for each minor frame
    where (ptanVals>=tempBasis(1) .and. ptanVals<tempBasis(noTemps))
      hydrosGPH = basisGPH ( pointTempLayer ) + &
        & (rt(pointTempLayer)*tempUpperWeight*(2-tempUpperWeight) + &
        &  rt(pointTempLayer+1)*(tempUpperWeight**2))*(ln10*tempBasisGap/(2*g0))
    end where

    where ( ptanVals < tempBasis(1) )
      hydrosGPH = basisGPH ( pointTempLayer ) + &
        & rt(pointTempLayer) * ln10 * &
        & (ptanVals-tempBasis(pointTempLayer))/g0
    end where

    where ( ptanVals > tempBasis(noTemps) )
      hydrosGPH = basisGPH (pointTempLayer+1) + &
        & rt(pointTempLayer+1) * ln10 * &
        & (ptanVals-tempBasis(pointTempLayer+1))/g0
    end where

    ! Now we need dHydrosGPHByDT. To do this we calculate a matrix A containing
    ! the integrated basis functions.  There is an extra dimension in this
    ! to account for the reference surface which is then globally subtracted at
    ! the end.

    ! Unlike the code above, I think I'll do this in a loop to make life easier

    do i = 1, noMIFs + 1
      if ( i == noMIFs+1 ) then
        usePtan = refGPH%template%surfs(1,1)
        lower = ifm%belowRef
d1316 1
a1316 2
        usePtan = ptanVals(i)
        lower = pointTempLayer(i)
d1319 23
a1341 2
      ! Now do the main bulk of the temperature bases
      do j = 1, noTemps
d1343 16
a1358 2
        ! Loop over temperature basis surfaces
        A(i,j) = 0.0_r8          ! Set to zero to start
d1360 17
a1376 87
        ! Now do nothing for bad ptans
        if ( usePtan /= ptan%template%badValue ) then
          basis = tempBasis(j)
          basisPlus =  tempBasis( min(j+1,noTemps))
          basisMinus = tempBasis( max(j-1,1) )
          
          ! Consider the extremes (j==1, j==noTemps) cases first
          
          ! Below bottom of basis
          if ( (j==1) .and. (usePtan < tempBasis(j)) ) then
            A(i,j) = 2*(usePtan-tempBasis(j))

            ! Above top
          else if ( (j==noTemps) .and. (usePtan > tempBasis(j)) ) then
            A(i,j) = 2*(usePtan-tempBasis(j))

            ! Basis triangles completely below ptan
          else if ( j < lower ) then
            A(i,j) = basisPlus - basisMinus

            ! Basis triangles with ptan in the top half (not when ptan above top)
          else if ( j == lower .and. usePtan < tempBasis(noTemps) ) then
            A(i,j) = ( basis - basisMinus ) + &
              & ( usePtan - basis ) * &
              & ( 2 * basisPlus - basis - usePtan ) / &
              & (basisPlus - basis)

            ! Basis triangles with ptan in the bottom half (not when ptan below bottom)
          else if ( j == lower+1 .and. usePtan >= tempBasis(1) ) then
            A(i,j) = ( ( usePtan - basisMinus )**2 ) / &
              & (basis - basisMinus)

          end if                         ! Basis triangles completely above ptan, no impact
        end if                           ! Good ptan
      end do                             ! Loop over temp basis
    end do                               ! Loop over ptans
    
    ! Now use this to get temperature derivatives
    do i = 1, noMIFs
      if ( ptanVals(i) /= ptan%template%badValue ) then
        do j = 1, noTemps
          dHydrosGPHByDTemp(i,j) = ( A(i,j) - A(noMIFs+1,j) ) * &
            & (ifm%R(j)*ln10) / (2*g0)
        end do
      end if
    end do
    
    ! Now get dHydrosGPHByDPtan
    do i= 1, noMIFs
      if ( ptanVals(i) /= ptan%template%badValue ) then
        dHydrosGPHByDPtan(i)= (ln10/g0) * ( &
          & rt(pointTempLayer(i)) * tempLowerWeight(i)+ &
          & rt(pointTempLayer(i)+1) * tempUpperWeight(i) )
      else
        dHydrosGPHByDPtan(i)=0.0
      end if
    end do

    ! -----------------------------------------------------------------------
    ! Now we calculate the residual, which is defined as the difference of the
    ! l1GPH and hydrosGPH. We also need it's derivatives wrt temp and ptan.
    ! First calculate residual. Also calculate the derivatives.
    ! -----------------------------------------------------------------------

    ! Compute residual (or differential residual)
    if ( fmConf%differentialScan ) then
      residual%values ( 1 : noMIFs-1, maf ) = &
        & ( l1GPH(2:noMIFs) - l1GPH(1:noMIFs-1) ) -&
        & ( hydrosGPH(2:noMIFs) - hydrosGPH(1:noMIFs-1) )
      residual%values( noMIFs, maf ) = 0.0
    else
      residual%values(:,maf) = l1GPH - hydrosGPH
    end if

    ! Find row in jacobian
    if ( present ( jacobian ) ) then
      row = FindBlock ( jacobian%row, residual%index, maf )
      fmStat%rows(row) = .true.
      
      ! Store the ptan derivatives
      if ( ptanInState ) then
        col = FindBlock ( jacobian%col, ptan%index, maf )
        block => jacobian%block(row,col)
        if ( block%kind /= M_Absent ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Found a prexisting d(residual)/d(ptan), removing' )
          call DestroyBlock ( block )
a1377 9
        if ( fmConf%differentialScan ) then
          call updateDiagonal ( block, (/ &
            & ( dL1GPHByDPtan(2:noMIFs) - dL1GPHByDPtan(1:noMIFs-1) ) - &
            & ( dHydrosGPHByDPtan(2:noMIFs) - dHydrosGPHByDPtan(1:noMIFs-1) ) - &
            & 0.0 /) )
        else
          call updateDiagonal ( block, dL1GPHByDPtan-dHydrosGPHByDPtan )
        end if
      end if
d1379 4
a1382 7
      ! Store refGPH derivatives
      if ( refGPHInState ) then
        col = FindBlock ( jacobian%col, refGPH%index, maf )
        block => jacobian%block(row,col)
        if ( fmConf%differentialScan ) then
          call DestroyBlock ( block )
        else
d1385 1
a1385 1
              & 'Found a prexisting d(residual)/d(refGPH), removing' )
d1389 27
a1415 20
          block%values = -1.0
        end if
      end if
        
      ! Store heightOffset derivatives if any
      if ( associated (heightOffset) .and. heightOffsetInState ) then
        col = FindBlock ( jacobian%col, heightOffset%index, maf )
        block => jacobian%block(row,col)
        if ( block%kind /= M_Absent ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Found a prexisting d(residual)/d(heightOffset), removing' )
          call DestroyBlock ( block )
        end if
        call CreateBlock ( jacobian, row, col, M_Full )
        if  ( fmConf%differentialScan ) then
          block%values(:,1) = (/ &
            & dL1GPHByDHeightOffset(2:noMIFs) - dL1GPHByDHeightOffset(1:noMIFs-1), &
            & 0.0_r8 /)
        else
          block%values(:,1) = dL1GPHByDHeightOffset
a1416 1
      end if
a1417 37
      ! Now the temperature derivatives
      if ( tempInState ) then
        col = FindBlock ( jacobian%col, temp%index, maf )
        block => jacobian%block(row,col)
        if ( block%kind /= M_Absent ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Found a prexisting d(residual)/d(temp), removing' )
          call DestroyBlock ( block )
        end if
        call CreateBlock ( jacobian, row, col, M_Full )
        if ( fmConf%differentialScan ) then
          ! ------------- Diffential model
          block%values(noMIFs,:) = 0.0
          block%values(1:noMIFs-1,:) = - ( dHydrosGPHByDTemp(2:noMIFs,:) - &
            & dHydrosGPHByDTemp(1:noMIFs-1,:) )
          do i = 2, noMIFs
            block%values(i-1,pointTempLayer(i)) = &
              & block%values(i-1,pointTempLayer(i)) + dL1GPHByDTempLower(i)
            block%values(i-1,pointTempLayer(i)+1) = &
              & block%values(i-1,pointTempLayer(i)+1) + dL1GPHByDTempUpper(i)
          end do
          do i = 1, noMIFs-1
            block%values(i,pointTempLayer(i)) = &
              & block%values(i,pointTempLayer(i)) - dL1GPHByDTempLower(i)
            block%values(i,pointTempLayer(i)+1) = &
              & block%values(i,pointTempLayer(i)+1) - dL1GPHByDTempUpper(i)
          end do
        else
          ! ------------- Non differential model
          block%values = - dHydrosGPHByDTemp
          do i = 1, noMIFs
            block%values(i,pointTempLayer(i)) = &
              & block%values(i,pointTempLayer(i)) + dL1GPHByDTempLower(i)
            block%values(i,pointTempLayer(i)+1) = &
              & block%values(i,pointTempLayer(i)+1) + dL1GPHByDTempUpper(i)
          end do
        end if
a1418 50
      
    end if

    ! Now deallocate pointers
    call deallocate_test ( pointTempLayer, 'pointTempLayer', ModuleName )
    call deallocate_test ( pointH2OLayer, 'pointH2OLayer', ModuleName )
    call deallocate_test ( closestTempProfiles, 'closestTempProfiles', ModuleName )
    call deallocate_test ( closestH2OProfiles, 'closestH2OProfiles', ModuleName )

    call deallocate_test ( dH2OByDPtan, 'dH2OByDPtan', ModuleName )
    call deallocate_test ( dHydrosGPHByDPtan, 'dHydrosGPHByDPtan', ModuleName )
    call deallocate_test ( dL1GPHByDHeightOffset, 'dL1GPHByDHeightOffset', ModuleName )
    call deallocate_test ( dL1GPHByDL1RefrGeocAlt, 'dL1GPHByDL1RefrGeocAlt', ModuleName )
    call deallocate_test ( dL1GPHByDPtan, 'dL1GPHByDPtan', ModuleName )
    call deallocate_test ( dL1GPHByDTempLower, 'dL1GPHByDTempLower', ModuleName )
    call deallocate_test ( dL1GPHByDTempUpper, 'dL1GPHByDTempLower', ModuleName )
    call deallocate_test ( dL1RefrGeocAltByDHeightOffset,&
      & 'dL1RefrGeocAltByDHeightOffset', ModuleName )
    call deallocate_test ( dL1RefrGeocAltByDN,&
      & 'dL1RefrGeocAltByDN', ModuleName )
    call deallocate_test ( dL1RefrGeocAltByDPtan,&
      & 'dL1RefrGeocAltByDPtan', ModuleName )
    call deallocate_test ( dL1RefrGeocAltByDTempLower,&
      & 'dL1RefrGeocAltByDTempLower', ModuleName )
    call deallocate_test ( dL1RefrGeocAltByDTempUpper, &
      & 'dL1RefrGeocAltByDTempUpper', ModuleName )
    call deallocate_test ( dNByDPtan, 'dNByDPtan', ModuleName )
    call deallocate_test ( dNByDTempLower, 'dNByDTempLower', ModuleName )
    call deallocate_test ( dNByDTempUpper, 'dNByDTempUpper', ModuleName )
    call deallocate_test ( dTempByDPtan, 'dTempByDPtan', ModuleName )
    call deallocate_test ( geocLat, 'geocLat', ModuleName )
    call deallocate_test ( h2oBasisGap, 'h2oBasisGap', ModuleName )
    call deallocate_test ( h2oLowerWeight, 'h2oLowerWeight', ModuleName )
    call deallocate_test ( h2oUpperWeight, 'h2oUpperWeight', ModuleName )
    call deallocate_test ( hydrosGPH, 'hydrosGPH', ModuleName )
    call deallocate_test ( l1GPH, 'l1GPH', ModuleName )
    call deallocate_test ( l1RefrGeocAlt, 'l1RefrGeocAlt', ModuleName )
    call deallocate_test ( n, 'n', ModuleName )
    call deallocate_test ( p2, 'p2', ModuleName )
    call deallocate_test ( p4, 'p4', ModuleName )
    call deallocate_test ( pointingH2O, 'pointingH2O', ModuleName )
    call deallocate_test ( pointingPres, 'pointingPres', ModuleName )
    call deallocate_test ( pointingTemp, 'pointingTemp', ModuleName )
    call deallocate_test ( pOverTSquared, 'pOverTSquared', ModuleName )
    call deallocate_test ( ratio2, 'ratio2', ModuleName )
    call deallocate_test ( ratio4, 'ratio4', ModuleName )
    call deallocate_test ( s2, 's2', ModuleName )
    call deallocate_test ( tempBasisGap, 'tempBasisGap', ModuleName )
    call deallocate_test ( tempLowerWeight, 'tempLowerWeight', ModuleName )
    call deallocate_test ( tempUpperWeight, 'tempUpperWeight', ModuleName )
d1420 1
a1420 4
    call deallocate_test ( A, 'A', ModuleName )
    call deallocate_test ( dHydrosGPHByDTemp, 'dHydrosGPHByDTemp', ModuleName )

    if ( toggle ( emit ) ) call trace_end ( 'ScanForwardModel' )
d1427 1
d1430 1
a1432 1
    use PHYSICS, only: BOLTZ
d1434 130
a1563 127
! This is a two D version of ScanForwardModel
! inputs
  type (ForwardModelConfig_T), intent(in) :: FMCONF ! Configuration options
  type (Vector_T), intent(in) :: STATE ! The state vector
  type (Vector_T), intent(in) :: EXTRA ! Other stuff in the state vector
! outputs
  type (Vector_T), intent(inout) :: FWMOUT ! Output vector, residual filled
  type (ForwardModelStatus_T), intent(inout) :: FMSTAT ! Which maf etc.
  type (Matrix_T), intent(inout), optional :: JACOBIAN ! The derivative matrix
  integer, intent(in), optional :: chunkNo
! local variables
  type (VectorValue_T), pointer :: ORBINCLINE ! Orbital inclination
  type (VectorValue_T), pointer :: TEMP ! Temperature component of state
  type (VectorValue_T), pointer :: PTAN ! Ptan component of state
  type (VectorValue_T), pointer :: PHITAN ! Phitan component of state
  type (VectorValue_T), pointer :: H2O ! H2O component of state
  type (VectorValue_T), pointer :: REFGPH ! Ref gph component of state
  type (VectorValue_T), pointer :: L1ALT ! Tangent point altitude
  type (VectorValue_T), pointer :: RESIDUAL ! Resulting component of fwmOut
  type (MatrixElement_T), pointer :: BLOCK ! A matrix block
!
  logical :: TEMPINSTATE           ! Set if temp in state not extra
  logical :: REFGPHINSTATE         ! Set if refGPH in state not extra
  logical :: H2OINSTATE            ! Set if H2O in state, not extra
  logical :: PTANINSTATE           ! Set if ptan in state, not extra
!
  integer :: First, Last           ! Nonzeros in Eta_at_one*
  INTEGER :: windowstart_t         ! first instance for temperature
  INTEGER :: windowfinish_t        ! last instance for temperature
  INTEGER :: windowstart_h2o       ! first instance for water vapor
  INTEGER :: windowfinish_h2o      ! last instance for water vapor
  INTEGER :: sv_z                  ! height basis index
  INTEGER :: sv_p                  ! horizontal basis index
  INTEGER :: row                   ! Block row in jacobian
  INTEGER :: col                   ! Block col in jacobian
!
  REAL(rp) :: z_surf
  REAL(rp) :: surf_temp
  REAL(rp) :: surf_refr_indx(1)
!
  REAL(rp), POINTER :: earthradc(:)  ! square of minor axis of earth ellipsoid
!                              in orbit plane projected system
  REAL(rp), POINTER :: red_phi_t(:)
  REAL(rp), POINTER :: sinbeta(:)
  REAL(rp), POINTER :: sinphi2(:)
  REAL(rp), POINTER :: cosphi2(:)
  REAL(rp), POINTER :: geoclats(:)
  REAL(rp), POINTER :: sinlat2(:)
  REAL(rp), POINTER :: coslat2(:)
  REAL(rp), POINTER :: g_ref(:)
  REAL(rp), POINTER :: earth_radius(:)
  REAL(rp), POINTER :: eff_earth_radius(:)
  REAL(rp), POINTER :: p2(:)
  REAL(rp), POINTER :: p4(:)
  REAL(rp), POINTER :: ratio2(:)
  REAL(rp), POINTER :: ratio4(:)
  REAL(rp), POINTER :: ratio2_gph(:)
  REAL(rp), POINTER :: ratio4_gph(:)
  REAL(rp), POINTER :: tan_temp(:)
  REAL(rp), POINTER :: tan_h2o(:)
  REAL(rp), POINTER :: tan_refr_indx(:)
  REAL(rp), POINTER :: l1altrefr(:)
  REAL(rp), POINTER :: refgeomalt_denom(:)
  REAL(rp), POINTER :: l1refalt(:)
  REAL(rp), POINTER :: mass_corr(:)
  REAL(rp), POINTER :: dgphdr(:)
  REAL(rp), POINTER :: dscandz(:)
  REAL(rp), POINTER :: temp_at_surf_phi(:)
  REAL(rp), POINTER :: eta_z(:,:)
  REAL(rp), POINTER :: eta_p_t(:,:)
  REAL(rp), POINTER :: eta_p_h2o(:,:)
  REAL(rp), POINTER :: piq(:,:)
  REAL(rp), POINTER :: eta_piqxp(:,:)
  REAL(rp), POINTER :: eta_zxp_t(:,:)
  REAL(rp), POINTER :: eta_zxp_h2o(:,:)
  REAL(rp), POINTER :: eta_at_one_phi(:)
  REAL(rp), POINTER :: eta_at_one_zeta(:)
!
  LOGICAL, POINTER :: not_zero_z(:,:)
  LOGICAL, POINTER :: not_zero_p_t(:,:)
  LOGICAL, POINTER :: not_zero_p_h2o(:,:)
  LOGICAL, POINTER :: not_zero_t(:,:)
  LOGICAL, POINTER :: not_zero_h2o(:,:)
  real :: T0, T1, T2                     ! For timing
  logical, parameter :: always_timing = .false.  ! if worried about NAG taking so long
  logical :: Timing  ! if worried about NAG taking so long
  logical, parameter :: total_times = .true.
  integer :: isurf
! Time this
  call time_now ( t0 )
  call time_now ( t1 )
  Timing = always_timing
!  if ( present(chunkNo) ) &
!    & Timing = always_timing .or. &
!    & chunkNo == 4 .or. chunkNo == 12 .or. chunkNo == 25 .or.  &
!    & chunkNo == 50 .or. chunkNo == 167
  if ( timing ) &
    & call output('beginning timing for 2d scan forward model', advance='yes')
! nullify all pointers
  NULLIFY ( coslat2, cosphi2, dgphdr, dscandz, earthradc, earth_radius,      &
    & eff_earth_radius, eta_at_one_phi, eta_at_one_zeta, eta_p_h2o,          &
    & eta_piqxp, eta_p_t, eta_z, eta_zxp_h2o, eta_zxp_t, geoclats,           &
    & g_ref, l1altrefr, l1refalt, mass_corr, not_zero_h2o, not_zero_p_h2o,   &
    & not_zero_p_t, not_zero_t, not_zero_z, p2, p4, piq, ratio2, ratio2_gph, &
    & ratio4, ratio4_gph, red_phi_t, refgeomalt_denom, sinbeta, sinlat2,     &
    & sinphi2, tan_h2o, tan_refr_indx, tan_temp, temp_at_surf_phi ) 
! Identify the vector quantities from state/extra
  orbIncline => getQuantityForForwardModel ( state, extra, &
    & quantityType=l_orbitInclination, config=fmConf )
  temp => getQuantityForForwardModel ( state, extra, &
    & quantityType=l_temperature, config=fmConf, foundInFirst=tempInState )
  ptan => getQuantityForForwardModel ( state, extra, &
    & quantityType=l_ptan, instrumentModule=fmConf%instrumentModule, &
    & config=fmConf, foundInFirst=ptanInState )
  phitan => getQuantityForForwardModel ( state, extra, &
    & quantityType=l_phitan, instrumentModule=fmConf%instrumentModule, &
    & config=fmConf)
  h2o => getQuantityForForwardModel ( state, extra, &
    & quantityType=l_vmr, molecule=l_h2o, &
    & config=fmConf, foundInFirst=h2oInState, noError=.true.)
  refgph => getQuantityForForwardModel ( state, extra, &
    & quantityType=l_refGPH, config=fmConf, foundInFirst=refGPHInState )
  l1Alt => getQuantityForForwardModel ( state, extra, &
    & quantityType=l_tngtGeocAlt, instrumentModule=fmConf%instrumentModule, &
    & config=fmConf)
! Identify the vector quantities from fwmOut
  residual => getQuantityForForwardModel ( fwmOut, &
d1565 144
a1708 143
    & config=fmConf)
  if ( timing ) call sayTime ( 'Getting vector quantities' )
  call time_now ( t1 )
! get window
  CALL FindInstanceWindow(temp,phitan,fmStat%maf,FMConf%phiWindow, &
    & FMConf%windowUnits, windowstart_t, windowfinish_t)
  CALL FindInstanceWindow(h2o,phitan,fmStat%maf,FMConf%phiWindow, &
    & FMConf%windowUnits, windowstart_h2o, windowfinish_h2o)
   ! if( timing ) print *, 'T window  : ', windowstart_t, windowfinish_t
   ! if( timing ) print *, 'H2O window: ', windowstart_h2o, windowfinish_h2o
  if ( timing ) call sayTime ( 'Finding instance windows' )
  call time_now ( t1 )
! convert phitan into geocentric latitude
  CALL ALLOCATE_TEST(earthradc,ptan%template%nosurfs,'earthradc',modulename)
  CALL ALLOCATE_TEST(earth_radius,ptan%template%nosurfs,'earth_radius', &
  & modulename)
  CALL ALLOCATE_TEST(eff_earth_radius,ptan%template%nosurfs, &
  & 'eff_earth_radius', modulename)
  CALL ALLOCATE_TEST(g_ref,ptan%template%nosurfs,'g_ref',modulename)
  CALL ALLOCATE_TEST(red_phi_t,ptan%template%nosurfs,'red_phi_t',modulename)
  CALL ALLOCATE_TEST(sinphi2,ptan%template%nosurfs,'sinphi2',modulename)
  CALL ALLOCATE_TEST(cosphi2,ptan%template%nosurfs,'cosphi2',modulename)
  CALL ALLOCATE_TEST(sinlat2,ptan%template%nosurfs,'sinlat2',modulename)
  CALL ALLOCATE_TEST(coslat2,ptan%template%nosurfs,'coslat2',modulename)
  CALL ALLOCATE_TEST(sinbeta,ptan%template%nosurfs,'sinbeta',modulename)
  CALL ALLOCATE_TEST(geoclats,ptan%template%nosurfs,'geoclats',modulename)
  CALL ALLOCATE_TEST(p2,ptan%template%nosurfs,'p2',modulename)
  CALL ALLOCATE_TEST(p4,ptan%template%nosurfs,'p4',modulename)
  CALL ALLOCATE_TEST(ratio2,ptan%template%nosurfs,'ratio2',modulename)
  CALL ALLOCATE_TEST(ratio4,ptan%template%nosurfs,'ratio4',modulename)
  CALL ALLOCATE_TEST(l1refalt,ptan%template%nosurfs,'l1refalt',modulename)
  CALL ALLOCATE_TEST(refgeomalt_denom,ptan%template%nosurfs, &
  & 'refgeomalt_denom',modulename)
  sinbeta = sin(deg2rad*orbincline%values(1:ptan%template%noSurfs,fmStat%maf))
  earthradc = (earthrada*earthradb)**2 / &
  & ( (earthRada**2 - earthRadb**2) * sinbeta**2 + earthRadb**2) ! in meters
! rephase the phi
  red_phi_t = MODULO(deg2rad*phitan%values(:,fmStat%maf),2.0_rp*Pi)
  WHERE(0.5_rp*Pi < red_phi_t .AND. red_phi_t <= 1.5_rp*Pi)
    red_phi_t = Pi - red_phi_t
  ELSEWHERE(red_phi_t > 1.5_rp*Pi)
    red_phi_t = red_phi_t - 2.0_rp*Pi
  ENDWHERE
  if ( timing ) call sayTime ( 'rephasing phi' )
  call time_now ( t1 )
! compute sin^2(phi) and cos^2(phi)
  sinphi2 = sin(red_phi_t)**2
  cosphi2 = 1.0_rp - sinphi2
  geoclats = asin(earthradc * sin(red_phi_t) * sinbeta / &
  & sqrt(earthrada**4*cosphi2 + earthradc**2*sinphi2))
  sinlat2 = SIN(geoclats)**2
  coslat2 = 1.0_rp - sinlat2
  p2=0.5_rp * (3.0_rp*sinlat2 - 1.0_rp)
  p4=0.125_rp * (35.0_rp*sinlat2**2 - 30.0_rp*sinlat2 + 3.0_rp)
! compute the local gravitational acceleration at the surface
  earth_radius = SQRT((earthrada**4*cosphi2 + earthradc**2*sinphi2) &
               / (earthrada**2*cosphi2 + earthradc*sinphi2))
  ratio2=(earthRadA/earth_radius)**2
  ratio4=ratio2**2
  g_ref =  GM * (1.0_rp - 3.0_rp*j2*p2*ratio2 - 5.0_rp*j4*p4*ratio4) &
  & / earth_radius**2 - omega**2*earth_radius*coslat2
! get the effective earth radius
  eff_earth_radius = 2.0_rp * g_ref / (2.0_rp * gm * (1.0_rp-6.0_rp*j2*p2 &
  & * ratio2 - 15.0_rp*j4*p4*ratio4) / earth_radius**3 &
  & + omega**2*coslat2)
! deallocate things we don't need
  CALL DEALLOCATE_TEST(earthradc,'earthradc',modulename)
  CALL DEALLOCATE_TEST(red_phi_t,'red_phi_t',modulename)
  CALL DEALLOCATE_TEST(sinphi2,'sinphi2',modulename)
  CALL DEALLOCATE_TEST(cosphi2,'cosphi2',modulename)
  CALL DEALLOCATE_TEST(sinlat2,'sinlat2',modulename)
  CALL DEALLOCATE_TEST(geoclats,'geoclats',modulename)
  CALL DEALLOCATE_TEST(sinbeta,'sinbeta',modulename)
! compute temperature function
  CALL allocate_test(eta_z,ptan%template%nosurfs,temp%template%nosurfs, &
                  & 'eta_z',ModuleName)
  CALL allocate_test(not_zero_z,ptan%template%nosurfs,temp%template%nosurfs,&
                  & 'not_zero_z',ModuleName)
  CALL allocate_test(eta_p_t,phitan%template%nosurfs, &
                  & windowfinish_t - windowstart_t + 1, 'eta_p_t',ModuleName)
  CALL allocate_test(not_zero_p_t,phitan%template%nosurfs, &
             & windowfinish_t - windowstart_t + 1, 'not_zero_p_t',ModuleName)
  CALL allocate_test(eta_zxp_t,ptan%template%nosurfs,temp%template%nosurfs &
      & * (windowfinish_t - windowstart_t + 1), 'eta_zxp_t',ModuleName)
  CALL allocate_test(not_zero_t,ptan%template%nosurfs,temp%template%nosurfs &
      & * (windowfinish_t - windowstart_t + 1), 'not_zero_t',ModuleName)
  CALL allocate_test(eta_piqxp,ptan%template%nosurfs,temp%template%nosurfs &
      & * (windowfinish_t - windowstart_t + 1), 'eta_piqxp',ModuleName)
  CALL allocate_test(tan_temp,ptan%template%nosurfs , 'tan_temp', &
    & ModuleName)
! get eta functions
  CALL get_eta_sparse(temp%template%phi(1,windowstart_t:windowfinish_t), &
    & phitan%values(:,fmStat%maf), eta_p_t, not_zero_p_t)
  CALL get_eta_sparse(temp%template%surfs(:,1),ptan%values(:,fmStat%maf), &
    & eta_z, not_zero_z)
  if ( timing ) call sayTime ( 'getting etas functions' )
  call time_now ( t1 )
! construct piq integral
  CALL ALLOCATE_TEST(piq,ptan%template%nosurfs,temp%template%nosurfs, &
  & 'tan_refr_indx', modulename)
  CALL piq_int(ptan%values(:,fmStat%maf),temp%template%surfs(:,1), &
  & refGPH%template%surfs(1,1), piq, Z_MASS = 2.5_rp, C_MASS = 0.02_rp)
  if ( timing ) call sayTime ( 'constructing piq integral' )
  call time_now ( t1 )
! convert level 1 reference geopotential height into geometric altitude
! This assumes that the reference ellipsoid is equivalent to a reference
! geopotential height of 0 meters.
  refgeomalt_denom = g_ref*eff_earth_radius &
  & - g0*SUM(SPREAD(RESHAPE(refgph%values(1,windowstart_t:windowfinish_t), &
  & (/windowfinish_t-windowstart_t+1/)),1,ptan%template%nosurfs) &
  & * eta_p_t,dim=2)
  l1refalt = g_ref*eff_earth_radius**2 / refgeomalt_denom - eff_earth_radius &
  & + earth_radius
  tan_temp = 0.0_rp
  eta_zxp_t = 0.0_rp
  eta_piqxp = 0.0_rp
  not_zero_t = .false.
  DO sv_z = 1, temp%template%nosurfs
    DO sv_p = 1, windowfinish_t - windowstart_t + 1
!      WHERE(not_zero_p_t(:,sv_p) .AND. not_zero_z(:,sv_z))
!        eta_zxp_t(:,sv_z + temp%template%nosurfs*(sv_p-1)) = &
!        & eta_z(:,sv_z) * eta_p_t(:,sv_p)
!        not_zero_t(:,sv_z + temp%template%nosurfs*(sv_p-1)) = .TRUE.
!        tan_temp = tan_temp + eta_zxp_t(:,sv_z+temp%template%nosurfs*(sv_p-1)) &
!        & * temp%values(sv_z,windowstart_t+sv_p-1)
!      END WHERE
!      WHERE(not_zero_p_t(:,sv_p)) &
!        & eta_piqxp(:,sv_z + temp%template%nosurfs*(sv_p-1)) &
!        & = piq(:,sv_z) * eta_p_t(:,sv_p)
      do isurf=1, ptan%template%nosurfs
        if ( not_zero_p_t(isurf,sv_p) .AND. not_zero_z(isurf,sv_z) ) then
          eta_zxp_t(isurf,sv_z + temp%template%nosurfs*(sv_p-1)) = &
            & eta_z(isurf,sv_z) * eta_p_t(isurf,sv_p)
          not_zero_t(isurf,sv_z + temp%template%nosurfs*(sv_p-1)) = .TRUE.
          tan_temp(isurf) = tan_temp(isurf) + &
            & eta_zxp_t(isurf,sv_z+temp%template%nosurfs*(sv_p-1)) &
            & * temp%values(sv_z,windowstart_t+sv_p-1)
        endif
        if ( not_zero_p_t(isurf,sv_p) ) then
          eta_piqxp(isurf,sv_z + temp%template%nosurfs*(sv_p-1)) &
            & = piq(isurf,sv_z) * eta_p_t(isurf,sv_p)
        endif
      enddo
d1710 48
a1757 48
  ENDDO
  if ( timing ) call sayTime ( 'constructing geometric altitude' )
  call time_now ( t1 )
  CALL deallocate_test(piq, 'piq',ModuleName)
  CALL deallocate_test(eta_z, 'eta_z',ModuleName)
  CALL deallocate_test(not_zero_z,'not_zero_z',ModuleName)
! compute water vapor function
  CALL allocate_test(eta_p_h2o,phitan%template%nosurfs, &
            & windowfinish_h2o - windowstart_h2o + 1, 'eta_p_h2o',ModuleName)
  CALL allocate_test(not_zero_p_h2o,phitan%template%nosurfs, &
       & windowfinish_h2o - windowstart_h2o + 1, 'not_zero_p_h2o',ModuleName)
  CALL allocate_test(eta_z,ptan%template%nosurfs,h2o%template%nosurfs, &
                  & 'eta_z',ModuleName)
  CALL allocate_test(not_zero_z, ptan%template%nosurfs, &
  & h2o%template%nosurfs, 'not_zero_z',ModuleName)
  CALL allocate_test(eta_zxp_h2o,ptan%template%nosurfs,h2o%template%nosurfs &
      & * (windowfinish_h2o - windowstart_h2o + 1), 'eta_zxp_h2o',ModuleName)
  CALL allocate_test(not_zero_h2o,ptan%template%nosurfs,h2o%template%nosurfs &
      & * (windowfinish_h2o - windowstart_h2o + 1), 'not_zero_h2o',ModuleName)
  CALL allocate_test(tan_h2o,ptan%template%nosurfs , 'tan_h2o', &
    & ModuleName)
  CALL get_eta_sparse(h2o%template%phi(1,windowstart_h2o:windowfinish_h2o), &
    & phitan%values(:,fmStat%maf), eta_p_h2o, not_zero_p_h2o)
  CALL get_eta_sparse(h2o%template%surfs(:,1),ptan%values(:,fmStat%maf), &
    & eta_z, not_zero_z)
! we will assume the logarithmic interpolation here
  tan_h2o = 0.0_rp
  eta_zxp_h2o = 0.0_rp
  not_zero_h2o = .false.
  DO sv_p = 1, windowfinish_h2o - windowstart_h2o + 1
    DO sv_z = 1, h2o%template%nosurfs
!      WHERE(not_zero_p_h2o(:,sv_p) .AND. not_zero_z(:,sv_z))
!        eta_zxp_h2o(:,sv_z + h2o%template%nosurfs*(sv_p-1)) = &
!        & eta_z(:,sv_z) * eta_p_h2o(:,sv_p)
!        not_zero_h2o(:,sv_z + h2o%template%nosurfs*(sv_p-1)) = .TRUE.
!        tan_h2o = tan_h2o + eta_zxp_h2o(:,sv_z+h2o%template%nosurfs*(sv_p-1)) &
!        & * LOG(max(h2o%values(sv_z,windowstart_h2o+sv_p-1),1e-9_rp))
!      END WHERE
      do isurf=1, ptan%template%nosurfs
        if ( not_zero_p_h2o(isurf,sv_p) .AND. not_zero_z(isurf,sv_z) ) then
          eta_zxp_h2o(isurf,sv_z + h2o%template%nosurfs*(sv_p-1)) = &
            & eta_z(isurf,sv_z) * eta_p_h2o(isurf,sv_p)
          not_zero_h2o(isurf,sv_z + h2o%template%nosurfs*(sv_p-1)) = .TRUE.
          tan_h2o(isurf) = tan_h2o(isurf) + &
            & eta_zxp_h2o(isurf,sv_z+h2o%template%nosurfs*(sv_p-1)) &
            & * LOG(max(h2o%values(sv_z,windowstart_h2o+sv_p-1),1e-9_rp))
        endif
      enddo
d1759 97
a1855 125
  ENDDO
  tan_h2o = EXP(tan_h2o)
  CALL deallocate_test(eta_p_h2o, 'eta_p_h2o',ModuleName)
  CALL deallocate_test(eta_z, 'eta_z',ModuleName)
  CALL deallocate_test(not_zero_p_h2o,'not_zero_p_h2o',ModuleName)
  CALL deallocate_test(not_zero_z,'not_zero_z',ModuleName)
  if ( timing ) call sayTime ( 'computing water vapor functions' )
  call time_now ( t1 )
! compute refractive index
  CALL ALLOCATE_TEST(tan_refr_indx,ptan%template%nosurfs,'tan_refr_indx', &
  & modulename)
  CALL refractive_index(10.0_rp**(-ptan%values(:,fmStat%maf)), tan_temp, &
  & tan_refr_indx,h2o_path = tan_h2o)
! compute surface pressure
  CALL ALLOCATE_TEST(eta_at_one_phi,windowfinish_t-windowstart_t+1, &
  & 'eta_at_one_phi',modulename)
  CALL ALLOCATE_TEST(temp_at_surf_phi,temp%template%nosurfs, &
  & 'temp_at_surf_phi',modulename)
  CALL get_eta_sparse(temp%template%phi(1,windowstart_t:windowfinish_t), &
  & phitan%values(1,fmStat%maf),eta_at_one_phi,first,last)
  temp_at_surf_phi = SUM(temp%values(:,windowstart_t:windowfinish_t)* &
  & SPREAD(eta_at_one_phi,1,temp%template%nosurfs),dim=2)
  z_surf = z_surface(temp%template%surfs(:,1),temp_at_surf_phi,g_ref(1), &
  & SUM(refgph%values(1,windowstart_t:windowfinish_t) * eta_p_t(1,:)), &
  & refGPH%template%surfs(1,1),boltz)
  CALL DEALLOCATE_TEST(eta_at_one_phi,'eta_at_one_phi',modulename)
! compute refractive index at the surface
  CALL ALLOCATE_TEST(eta_at_one_zeta,temp%template%nosurfs, &
  & 'eta_at_one_zeta',modulename)
  CALL get_eta_sparse(temp%template%surfs(:,1),z_surf,eta_at_one_zeta,first,last)
  surf_temp = dot_product(eta_at_one_zeta(first:last), temp_at_surf_phi(first:last))
  CALL DEALLOCATE_TEST(eta_at_one_zeta,'eta_at_one_zeta',modulename)
  CALL DEALLOCATE_TEST(temp_at_surf_phi,'temp_at_surf_phi',modulename)
  CALL ALLOCATE_TEST(eta_at_one_phi,windowfinish_h2o-windowstart_h2o+1, &
  & 'eta_at_one_phi',modulename)
  CALL ALLOCATE_TEST(eta_at_one_zeta,h2o%template%nosurfs, &
  & 'eta_at_one_zeta',modulename)
  CALL get_eta_sparse(h2o%template%phi(1,windowstart_h2o:windowfinish_h2o), &
  & phitan%values(1,fmStat%maf),eta_at_one_phi)
  CALL get_eta_sparse(h2o%template%surfs(:,1),z_surf,eta_at_one_zeta,first,last)
  CALL refractive_index(10.0_rp**(-(/z_surf/)),(/surf_temp/),surf_refr_indx, &
  & h2o_path = (/EXP(dot_product(eta_at_one_zeta(first:last), &
  &   SUM(LOG(max(h2o%values(first:last,windowstart_h2o:windowfinish_h2o),1e-9_rp)) &
  & * SPREAD(eta_at_one_phi,1,last-first+1),dim=2)))/))
  CALL DEALLOCATE_TEST(eta_at_one_zeta,'eta_at_one_zeta',modulename)
  CALL DEALLOCATE_TEST(eta_at_one_phi,'eta_at_one_phi',modulename)
! set all refr indicies below the surface to the surface value
  WHERE(ptan%values(:,fmStat%maf) < z_surf) 
    tan_refr_indx = surf_refr_indx(1)
    tan_temp = surf_temp
  END WHERE
! compute l1 geopotential
  CALL ALLOCATE_TEST(l1altrefr,ptan%template%nosurfs,'l1altrefr', &
  & modulename)
  l1altrefr = l1alt%values(:,fmStat%maf) / (1.0_rp + tan_refr_indx)
  CALL ALLOCATE_TEST(ratio2_gph,ptan%template%nosurfs,'ratio2',modulename)
  CALL ALLOCATE_TEST(ratio4_gph,ptan%template%nosurfs,'ratio4',modulename)
  ratio2=(earthRadA/l1altrefr)**2
  ratio4=ratio2**2
  ratio2_gph=(earthRadA/l1refalt)**2
  ratio4_gph=ratio2**2
! do a simple mass correction
  CALL ALLOCATE_TEST(mass_corr,ptan%template%nosurfs,'mass_corr',modulename)
  mass_corr = 1.0_rp
!  WHERE(ptan%values(:,fmStat%maf) > 2.5) mass_corr = 1.0_rp &
!    & / (0.875_rp + 0.1_rp*ptan%values(:,fmStat%maf) &
!    & - 0.02_rp*ptan%values(:,fmStat%maf)**2)
! This is a reasonable approximation to the above.
  WHERE(ptan%values(:,fmStat%maf) > 2.5) mass_corr = 1.0_rp &
     & + 0.02_rp*(ptan%values(:,fmStat%maf) - 2.5)**2
  if ( timing ) call sayTime ( 'refractive index, l1 geopotential' )
  call time_now ( t1 )
! forward model calculation
  residual%values(:,fmStat%maf) = (GM*((1.0_rp - j2*p2*ratio2 - j4*p4*ratio4) &
  & / l1altrefr - (1.0_rp - j2*p2*ratio2_gph - j4*p4*ratio4_gph) / l1refalt) &
  & + 0.5_rp*omega**2*coslat2*(l1altrefr - l1refalt)*(l1altrefr + l1refalt) &
  & + boltz*SUM(RESHAPE(SPREAD(temp%values(:,windowstart_t: &
  & windowfinish_t),1,ptan%template%nosurfs), (/ptan%template%nosurfs, &
  & temp%template%nosurfs*(windowfinish_t-windowstart_t+1)/)) &
  & * eta_piqxp,dim=2)) / g0
  if ( timing ) call sayTime ( 'forward model calculation' )
  call time_now ( t1 )
  IF ( fmConf%differentialScan ) residual%values(:,fmStat%maf) = &
    & EOSHIFT(residual%values(:,fmStat%maf),1, &
    & residual%values(ptan%template%nosurfs,fmStat%maf)) &
    & - residual%values(:,fmStat%maf)
! derivatives--for simplicity we are ignoring h2o contributions
    ! Find row in jacobian
  if ( present ( jacobian ) ) then
    row = FindBlock ( jacobian%row, residual%index,fmStat%maf )
    fmStat%rows(row) = .true.
! compute dudr
    CALL ALLOCATE_TEST(dgphdr,ptan%template%nosurfs,'dgphdr',modulename)
    dgphdr =  -(GM / (l1altrefr**2*g0)) * (1.0_rp - 3.0_rp*j2*p2*ratio2 &
    & - 5.0_rp*j4*p4*ratio4) + (omega**2*l1altrefr*coslat2) / g0
! Store the ptan derivatives
    if ( ptanInState ) then
      col = FindBlock ( jacobian%col, ptan%index, fmStat%maf )
      block => jacobian%block(row,col)
      if ( block%kind /= M_Absent ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Found a prexisting d(residual)/d(ptan), removing' )
        call DestroyBlock ( block )
      end if
      CALL ALLOCATE_TEST(dscandz,ptan%template%nosurfs, &
      & 'dscandz', modulename)
      dscandz = boltz*mass_corr*SUM(RESHAPE( &
        & SPREAD(temp%values(:,windowstart_t:windowfinish_t),1, &
        & ptan%template%nosurfs), (/ptan%template%nosurfs, &
        & temp%template%nosurfs*(windowfinish_t-windowstart_t+1)/)) &
        & * eta_zxp_t,dim=2) / g0
      WHERE(ptan%values(:,fmStat%maf) > z_surf) dscandz = dscandz &
        & + dgphdr*l1altrefr*tan_refr_indx*ln10 / (1.0_rp + tan_refr_indx)
      if ( fmConf%differentialScan ) then
        CALL updateDiagonal ( BLOCK, EOSHIFT(dscandz,1, &
        & dscandz(ptan%template%nosurfs)) - dscandz)
      else
        CALL updateDiagonal ( BLOCK,dscandz)
      end if
      CALL DEALLOCATE_TEST(dscandz,'dscandz', modulename)
    end if
! Store refGPH derivatives
    if ( refGPHInState ) then
      DO sv_p = windowstart_t, windowfinish_t
        col = FindBlock ( jacobian%col, refGPH%index, sv_p )
d1859 1
a1859 1
          & 'Found a prexisting d(residual)/d(refGPH), removing' )
d1862 26
a1887 13
        IF(ANY(not_zero_p_t(:,sv_p-windowstart_t+1))) THEN
          call CreateBlock ( jacobian, row, col, M_Full )
          block%values(:,1) = (GM * (1.0_rp - 3.0_rp*j2*p2*ratio2_gph &
          & - 5.0_rp*j4*p4*ratio4_gph) / l1refalt**2 &
          & + omega**2*l1refalt*coslat2) * (l1refalt+eff_earth_radius &
          & - earth_radius) * eta_p_t(:,sv_p - windowstart_t + 1) &
          & / refgeomalt_denom
          if ( fmConf%differentialScan ) then
! ------------- Differential model
            block%values = EOSHIFT(block%values, &
            & SPREAD(1,1,ptan%template%nosurfs), &
            & RESHAPE(block%values(ptan%template%nosurfs,:), &
            & (/temp%template%nosurfs/)),dim=2) - block%values
d1889 28
a1916 29
        ENDIF
      ENDDO
      if ( timing ) call sayTime ( 'differential model' )
      call time_now ( t1 )
    end if
! Now the temperature derivatives
    if ( tempInState ) then
      DO sv_p = windowstart_t, windowfinish_t
        col = FindBlock ( jacobian%col, temp%index, sv_p )
        block => jacobian%block(row,col)
        if ( block%kind /= M_Absent ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Found a prexisting d(residual)/d(temp), removing' )
          call DestroyBlock ( block )
        end if
        IF(ANY(not_zero_p_t(:,sv_p-windowstart_t+1))) THEN
          call CreateBlock ( jacobian, row, col, M_Full )
          block%values = SPREAD(dgphdr*l1altrefr*tan_refr_indx &
          & / ((1.0_rp + tan_refr_indx)*tan_temp),2,temp%template%nosurfs) &
          & * eta_zxp_t(:,1+(sv_p-windowstart_t)*temp%template%nosurfs: &
          & (sv_p-windowstart_t+1)*temp%template%nosurfs) &
          & + boltz*eta_piqxp(:,1+(sv_p-windowstart_t)*temp%template%nosurfs: &
          & (sv_p-windowstart_t+1)*temp%template%nosurfs) / g0
          if ( fmConf%differentialScan ) then
! ------------- Differential model
            block%values = EOSHIFT(block%values, &
            & SPREAD(1,1,ptan%template%nosurfs), &
            & RESHAPE(block%values(ptan%template%nosurfs,:), &
            & (/temp%template%nosurfs/)),dim=2) - block%values
d1918 54
a1971 37
        ENDIF
      ENDDO
      if ( timing ) call sayTime ( 'temperature derivatives' )
      call time_now ( t1 )
    end if
    CALL DEALLOCATE_TEST(dgphdr,'dgphdr',modulename)
  ENDIF
! deallocate all remaining pointers
  CALL DEALLOCATE_TEST(coslat2,'coslat2',modulename)
  CALL DEALLOCATE_TEST(p2,'p2',modulename)
  CALL DEALLOCATE_TEST(p4,'p4',modulename)
  CALL DEALLOCATE_TEST(earth_radius,'earth_radius', modulename)
  CALL DEALLOCATE_TEST(eff_earth_radius,'eff_earth_radius', modulename)
  CALL DEALLOCATE_TEST(g_ref,'g_ref',modulename)
  CALL DEALLOCATE_TEST(l1refalt,'l1refalt',modulename)
  CALL DEALLOCATE_TEST(refgeomalt_denom,'refgeomalt_denom',modulename)
  CALL DEALLOCATE_TEST(ratio2,'ratio2',modulename)
  CALL DEALLOCATE_TEST(ratio4,'ratio4',modulename)
  CALL DEALLOCATE_TEST(ratio2_gph,'ratio2_gph',modulename)
  CALL DEALLOCATE_TEST(ratio4_gph,'ratio4_gph',modulename)
  CALL DEALLOCATE_TEST(l1altrefr,'l1altrefr', modulename)
  CALL deallocate_test(eta_p_t,'eta_p_t',ModuleName)
  CALL deallocate_test(not_zero_p_t, 'not_zero_p_t',ModuleName)
  CALL DEALLOCATE_TEST(mass_corr,'mass_corr',modulename)
  CALL deallocate_test(eta_zxp_t,'eta_zxp_t',ModuleName)
  CALL deallocate_test(not_zero_t,'not_zero_t',ModuleName)
  CALL deallocate_test(eta_piqxp,'eta_piqxp',ModuleName)
  CALL deallocate_test(tan_temp,'tan_temp',ModuleName)
  CALL deallocate_test(eta_zxp_h2o,'eta_zxp_h2o',ModuleName)
  CALL deallocate_test(not_zero_h2o,'not_zero_h2o',ModuleName)
  CALL deallocate_test(tan_h2o,'tan_h2o',ModuleName)
  CALL DEALLOCATE_TEST(tan_refr_indx,'tan_refr_indx', modulename)
  if ( timing ) call sayTime ( 'deallocating the rest' )
  if ( timing ) then
    t1 = t0
    call sayTime ( 'all of 2d scan forward model' )
  endif
d1989 1
a1989 1
    & threshold, maxiterations )
d2039 1
d2041 1
d2045 1
a2045 1
       "$Id: ScanModelModule.f90,v 2.72 2009/06/23 18:46:18 pwagner Exp $"
d2055 3
@


2.72
log
@Prevent Intel from optimizing ident string away
@
text
@d26 6
a31 6
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use Constants, ONLY: Deg2Rad, LN10, PI
  use ForwardModelConfig, only: ForwardModelConfig_T
  use ForwardModelIntermediate, only:  ForwardModelStatus_T
  use ForwardModelVectorTools, only: GETQUANTITYFORFORWARDMODEL
  use Geometry, only: EARTHRADA, EARTHRADB, EARTHSURFACEGPH, GEODTOGEOCLAT, &
d33 2
a34 2
  use Init_Tables_Module, only: L_REFGPH, L_ZETA
  use intrinsic, only: L_HEIGHTOFFSET, L_NONE, L_PTAN, L_SCANRESIDUAL, &
d36 6
a41 6
    & PHYQ_Length
  use ManipulateVectorQuantities, ONLY: FINDCLOSESTINSTANCES, &
    & FindInstanceWindow
  use MatrixModule_0, only: DESTROYBLOCK, MATRIXELEMENT_T, M_ABSENT, &
    & M_FULL, UpdateDiagonal
  use MatrixModule_1, only: CREATEBLOCK, FINDBLOCK, MATRIX_T, &
d43 10
a52 9
  use MLSKinds, ONLY: R8, RP, RV
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING, &
    & MLSMessageCalls
  use MLSNumerics, only : HUNT, INTERPOLATEVALUES
  use Molecules, only: L_H2O
  use Refraction_m, only: Refractive_index, RefrAterm, RefrBterm
  use Toggles, only: EMIT, TOGGLE, SWITCHES
  use Trace_M, only: TRACE_BEGIN, TRACE_END
  use VectorsModule, ONLY : VALIDATEVECTORQUANTITY, &
d79 1
a79 1
       "$RCSfile: $"
d489 1
a489 1
    if ( index ( switches, 'pguess' ) /= 0 ) &
d549 1
a549 1
      if ( index ( switches, 'pguess' ) /= 0 ) then
d567 1
a567 1
    if ( index (switches, 'pguess' ) /= 0 ) &
d1570 1
a1570 1
    use Get_eta_matrix_m, only: Get_eta_sparse
d1572 3
a1574 3
    use Piq_int_m, only: Piq_int
    use Time_M, only: Time_Now
    use Physics, only: Boltz
d2180 1
a2180 1
       "$Id: read_apriori.f90 is it here $"
d2190 3
@


2.71
log
@Get constants from Constants, kinds from MLSKinds
@
text
@d78 1
a78 1
       "$RCSfile: ScanModelModule.f90,v $"
d2176 1
a2177 1
!---------------------------- RCS Ident Info -------------------------------
d2179 2
a2180 3
       "$Id: ScanModelModule.f90,v 2.70 2007/08/20 22:06:08 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2182 1
a2182 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2184 1
d2189 3
@


2.70
log
@Two procedures now push their names onto MLSCallStack
@
text
@d27 1
d43 1
a43 1
  use MLSCommon, ONLY: R8, rp, rv
a53 1
  USE Units, ONLY: Deg2Rad, LN10, PI
d2179 1
a2179 1
       "$Id: ScanModelModule.f90,v 2.69 2007/07/25 20:08:46 vsnyder Exp $"
d2183 1
d2189 3
@


2.69
log
@Delete declaration for unused variable
@
text
@d43 2
a44 1
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
d147 1
d238 1
d308 1
d424 1
d2179 1
a2179 1
       "$Id: ScanModelModule.f90,v 2.68 2007/06/29 19:32:07 vsnyder Exp $"
d2188 3
@


2.68
log
@Make ForwardModelIntermediate_t private to ScanModelModule
@
text
@a270 1
    real (r8), dimension(tempPrec%template%noInstances) :: DELTAGEOPOT ! noInstances
d2174 1
a2174 1
       "$Id: ScanModelModule.f90,v 2.67 2006/12/13 01:33:08 vsnyder Exp $"
d2183 3
@


2.67
log
@Use slightly faster get_eta_sparse
@
text
@d28 1
a28 2
  use ForwardModelIntermediate, only: ForwardModelIntermediate_T, &
    & ForwardModelStatus_T
d58 16
a73 2
  public :: GetBasisGPH, GetHydrostaticTangentPressure, ScanForwardModel, &
    & TwoDScanForwardModel, Get2DHydrostaticTangentPressure, GetGPHPrecision
d89 13
a462 1
    type (ForwardModelIntermediate_T) :: IFM
d537 1
a537 1
       call TwoDScanForwardModel ( fmConf, state, extra, residual, ifm, &
d850 1
a850 1
    & fwmOut, ifm, fmStat, jacobian )
a862 1
    type (ForwardModelIntermediate_T), intent(inout) :: IFM ! Workspace type stuff
d1562 1
a1562 1
  subroutine TwoDScanForwardModel ( fmConf, state, extra, fwmOut, ifm, &
a1577 1
  type (ForwardModelIntermediate_T), intent(inout) :: IFM ! Workspace type stuff
d2175 1
a2175 1
       "$Id: ScanModelModule.f90,v 2.66 2006/08/05 02:36:06 vsnyder Exp $"
d2184 3
@


2.66
log
@Delete unused symbols
@
text
@d1574 1
d1623 2
a1624 2
  REAL(rp), POINTER :: eta_at_one_phi(:,:)
  REAL(rp), POINTER :: eta_at_one_zeta(:,:)
d1883 1
a1883 1
  CALL ALLOCATE_TEST(eta_at_one_phi,1,windowfinish_t-windowstart_t+1, &
d1888 3
a1890 5
  & (/phitan%values(1,fmStat%maf)/),eta_at_one_phi)
  temp_at_surf_phi = SUM(temp%values(:, &
  & windowstart_t:windowfinish_t)*SPREAD( &
  & RESHAPE(eta_at_one_phi,(/windowfinish_t-windowstart_t+1/)),1, &
  & temp%template%nosurfs),dim=2)
d1896 1
a1896 1
  CALL ALLOCATE_TEST(eta_at_one_zeta,1,temp%template%nosurfs, &
d1898 2
a1899 3
  CALL get_eta_sparse(temp%template%surfs(:,1), (/z_surf/),eta_at_one_zeta)
  surf_temp = SUM(RESHAPE(eta_at_one_zeta,(/temp%template%nosurfs/)) &
  & * temp_at_surf_phi)
d1901 2
a1902 1
  CALL ALLOCATE_TEST(eta_at_one_phi,1,windowfinish_h2o-windowstart_h2o+1, &
d1904 1
a1904 1
  CALL ALLOCATE_TEST(eta_at_one_zeta,1,h2o%template%nosurfs, &
d1907 2
a1908 2
  & (/phitan%values(1,fmStat%maf)/),eta_at_one_phi)
  CALL get_eta_sparse(h2o%template%surfs(:,1),(/z_surf/),eta_at_one_zeta)
d1910 3
a1912 4
  & h2o_path = (/EXP(SUM(RESHAPE(eta_at_one_zeta,(/h2o%template%nosurfs/)) &
  & * SUM(LOG(max(h2o%values(:,windowstart_h2o:windowfinish_h2o),1e-9_rp)) &
  & * SPREAD(RESHAPE(eta_at_one_phi,(/windowfinish_h2o-windowstart_h2o+1/)), &
  & 1,h2o%template%nosurfs),dim=2)))/))
a1914 1
  CALL DEALLOCATE_TEST(temp_at_surf_phi,'temp_at_surf_phi',modulename)
d2083 1
d2096 1
d2114 1
d2118 1
a2118 1
      real(rp) :: eta(1,size(z_basis))
d2137 1
a2137 1
        call get_eta_sparse ( z_basis, (/z_old/), eta )
d2140 1
a2140 1
                         & / dot_product(eta(1,:),t_values)
d2152 1
a2152 1
       "$Id: ScanModelModule.f90,v 2.65 2006/08/05 02:12:27 vsnyder Exp $"
d2161 3
@


2.65
log
@Add ForWhom argument to ConstructVectorTemplate
@
text
@d36 1
a36 1
    & PHYQ_Length, PHYQ_Profiles
d39 1
a39 1
  use MatrixModule_0, only: DESTROYBLOCK, MATRIXELEMENT_T, M_ABSENT, M_BANDED, &
d44 1
a44 2
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
       MLSMSG_ERROR, MLSMSG_WARNING
d50 1
a50 1
  use VectorsModule, ONLY : GETVECTORQUANTITYBYTYPE, VALIDATEVECTORQUANTITY, &
d243 2
a244 2
    real (r8), dimension(tempPrec%template%noInstances) :: CURRENTREFGPH ! From 1st calc
    real (r8), dimension(tempPrec%template%noInstances) :: CORRECTION ! To apply to gph
d2152 1
a2152 1
       "$Id: ScanModelModule.f90,v 2.64 2006/08/02 20:10:56 vsnyder Exp $"
d2161 3
@


2.64
log
@Use deallocate_test for myR and myRT, for leak tracking
@
text
@d484 1
a484 1
    call ConstructVectorTemplate ( 0, myQTs, (/1/), stateTemplate )
d486 1
a486 1
    call ConstructVectorTemplate ( 0, myQTs, (/2,3,4,5,6,7/),  extraTemplate )
d488 1
a488 1
    call ConstructVectorTemplate ( 0, myQTs, (/8/), residualTemplate )
d2153 1
a2153 1
       "$Id: ScanModelModule.f90,v 2.63 2006/04/03 20:23:46 pwagner Exp $"
d2162 3
@


2.63
log
@Preserve correct sign for GPH Precision
@
text
@d200 1
a200 1
       deallocate ( myR )
d206 1
a206 1
       deallocate ( myRT )
d2153 1
a2153 1
       "$Id: ScanModelModule.f90,v 2.62 2005/06/22 18:57:02 pwagner Exp $"
d2162 3
@


2.62
log
@Reworded Copyright statement, moved rcs id
@
text
@d43 1
a43 1
  use MLSCommon, ONLY: R8, rp
d65 1
a65 1
       "$RCSfile: $"
d278 2
d357 1
d365 19
d394 1
a394 1
    GPHPrec = sqrt ( GPHPrec2 )
d2153 1
a2153 1
       "$Id: $"
d2162 3
@


2.61
log
@Moved Boltz from units to physics
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d63 3
a65 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: ScanModelModule.f90,v 2.60 2003/08/15 23:58:20 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName = &
    & "$RCSfile: ScanModelModule.f90,v $"
d67 1
a67 1
  !---------------------------------------------------------------------------
d2129 5
d2140 3
@


2.60
log
@Get PHYQ_... directly from Intrinsic instead of indirectly via Units
@
text
@d57 1
a57 1
    & "$Id: ScanModelModule.f90,v 2.59 2003/03/19 19:24:10 pwagner Exp $"
d76 1
a76 1
    use Units, only: Boltz
d215 1
a215 1
    use Units, only: Boltz
d1519 1
a1519 1
    use Units, only: Boltz
d2130 3
@


2.59
log
@Prints timing info when necessary; speedup of TwoDScanForwardModel despite terrible NAG memory management
@
text
@d27 2
a28 1
    & L_TEMPERATURE, L_TNGTGEOCALT, L_VMR, L_PHITAN, L_ORBITINCLINATION
d46 1
a46 1
  USE Units, ONLY: Deg2Rad, LN10, PHYQ_Length, PI, PHYQ_Profiles
d57 1
a57 1
    & "$Id: ScanModelModule.f90,v 2.58 2003/02/18 23:59:28 livesey Exp $"
d2130 3
@


2.58
log
@Added phiWindow stuff for hydrostatic fill
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.57 2003/02/13 01:15:39 bill Exp $"
d373 2
a374 1
    & orbIncl, phiTan, geocAlt, maxIterations, phiWindow, phiWindowUnits )
d393 1
d485 5
a489 5
        call TwoDScanForwardModel ( fmConf, state, extra, residual, ifm, &
          & fmStat, jacobian )
        state%quantities(1)%values(:,maf) = state%quantities(1)%values(:,maf) - &
          & residual%quantities(1)%values(:,maf) / &
          &   jacobian%block(maf,maf)%values(:,1)
d1512 1
a1512 1
  & fmStat, jacobian )
d1515 1
d1517 1
d1530 1
d1603 15
d1649 2
d1656 4
d1691 2
d1743 2
d1750 2
d1767 24
a1790 10
      WHERE(not_zero_p_t(:,sv_p) .AND. not_zero_z(:,sv_z))
        eta_zxp_t(:,sv_z + temp%template%nosurfs*(sv_p-1)) = &
        & eta_z(:,sv_z) * eta_p_t(:,sv_p)
        not_zero_t(:,sv_z + temp%template%nosurfs*(sv_p-1)) = .TRUE.
        tan_temp = tan_temp + eta_zxp_t(:,sv_z+temp%template%nosurfs*(sv_p-1)) &
        & * temp%values(sv_z,windowstart_t+sv_p-1)
      END WHERE
      WHERE(not_zero_p_t(:,sv_p)) &
        & eta_piqxp(:,sv_z + temp%template%nosurfs*(sv_p-1)) &
        & = piq(:,sv_z) * eta_p_t(:,sv_p)
d1793 2
d1823 17
a1839 7
      WHERE(not_zero_p_h2o(:,sv_p) .AND. not_zero_z(:,sv_z))
        eta_zxp_h2o(:,sv_z + h2o%template%nosurfs*(sv_p-1)) = &
        & eta_z(:,sv_z) * eta_p_h2o(:,sv_p)
        not_zero_h2o(:,sv_z + h2o%template%nosurfs*(sv_p-1)) = .TRUE.
        tan_h2o = tan_h2o + eta_zxp_h2o(:,sv_z+h2o%template%nosurfs*(sv_p-1)) &
        & * LOG(max(h2o%values(sv_z,windowstart_h2o+sv_p-1),1e-9_rp))
      END WHERE
d1847 2
d1915 2
d1925 2
d1992 2
d2022 2
d2052 5
d2059 12
d2118 2
d2129 3
@


2.57
log
@made reference geopotential height calculation constants the same as those used in the hydrostatic calcs
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.56 2003/02/12 22:46:49 bill Exp $"
d373 1
a373 1
    & orbIncl, phiTan, geocAlt, maxIterations )
d390 2
d435 2
a436 2
    fmConf%phiWindow = 4
    fmConf%windowUnits = phyq_profiles
d2042 3
@


2.56
log
@fixed mass correction integrations
@
text
@d45 1
a45 1
  use Units, only: Deg2Rad, LN10, PHYQ_Length, PI, PHYQ_Profiles
d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.55 2003/01/31 22:30:56 livesey Exp $"
d75 1
d87 6
a92 4
    real (r8), parameter :: GASM0 = 25.34314957d-3 ! Constant
    real (r8), parameter :: GASM1 = 2.89644d-3 ! Linear term
    real (r8), parameter :: GASM2 = -0.579d-3 ! Quadratic term
    real (r8), parameter :: GASR0 = 8.31441 ! `Standard' gas constant
d111 1
a111 1
    real (r8) :: BASISCUTOFF            ! Threshold level for gas constant
d142 1
a142 1
    basisCutoff= -gasM1 / (2*gasM2) ! Set a threshold value
d144 2
a145 1
    myR = gasR0 / ( gasM0 + gasM1*modifiedBasis + gasM2*modifiedBasis**2 )
d155 5
a159 3
       deltaGeopot = (ln10/ (2*g0) ) * &
         & ( myRT(surf,:) + myRT(surf-1,:) ) * &
         & ( logP(surf) - logP(surf-1) )
d177 4
a180 1
    currentRefGPH = gph(myBelowRef,:) + ((basisGap*ln10)/(2*g0))* &
d214 1
d225 6
a230 4
    real (r8), parameter :: GASM0 = 25.34314957d-3 ! Constant
    real (r8), parameter :: GASM1 = 2.89644d-3 ! Linear term
    real (r8), parameter :: GASM2 = -0.579d-3 ! Quadratic term
    real (r8), parameter :: GASR0 = 8.31441 ! `Standard' gas constant
d269 1
a269 1
    real (r8) :: BASISCUTOFF            ! Threshold level for gas constant
d294 1
a294 1
    basisCutoff= -gasM1 / (2*gasM2) ! Set a threshold value
d296 2
a297 1
    myR = gasR0 / ( gasM0 + gasM1*modifiedBasis + gasM2*modifiedBasis**2 )
d307 5
a311 3
       ddeltaGeopot_dT = (ln10/ (2*g0) ) * &
         & ( dmyRT_dT(surf,:,:) + dmyRT_dT(surf-1,:,:) ) * &
         & ( logP(surf) - logP(surf-1) )
d330 4
a333 1
    dcurrentRefGPH_dT = dgph_dT(myBelowRef,:,:) + ((basisGap*ln10)/(2*g0))* &
d2040 3
@


2.55
log
@Got rid of a print statement
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.54 2003/01/26 04:43:15 livesey Exp $"
d1699 1
a1699 1
  & refGPH%template%surfs(1,1), piq)
d1829 4
d1834 1
a1834 2
    & / (0.875_rp + 0.1_rp*ptan%values(:,fmStat%maf) &
    & - 0.02_rp*ptan%values(:,fmStat%maf)**2)
d1839 1
a1839 1
  & + mass_corr*boltz*SUM(RESHAPE(SPREAD(temp%values(:,windowstart_t: &
d1925 1
a1925 2
          & + boltz*SPREAD(mass_corr,2,temp%template%nosurfs) &
          & * eta_piqxp(:,1+(sv_p-windowstart_t)*temp%template%nosurfs: &
d2022 3
@


2.54
log
@Changed to handle units for phiWindow
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.53 2003/01/16 23:13:35 livesey Exp $"
a347 1
    print*, sum(GPHPrec2-GPHPrec2a), maxval(GPHPrec2), maxval(GPHPrec2a)
d2020 3
@


2.53
log
@Now gets MaxRefraction (smaller value) from Geometry
@
text
@d45 1
a45 1
  use Units, only: Deg2Rad, LN10, PHYQ_Length, PI
d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.52 2002/11/22 12:22:41 mjf Exp $"
d416 2
a417 1
    fmConf%phiWindow = 4.0
d1612 1
a1612 1
                            & windowstart_t, windowfinish_t)
d1614 1
a1614 1
                            & windowstart_h2o, windowfinish_h2o)
d2021 3
@


2.52
log
@Use getQuantityForForwardModel instead of GetVectorQuantityByType.
@
text
@d24 1
a24 1
    & G0, GM, J2, J4, OMEGA => W
d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.51 2002/10/25 22:24:54 livesey Exp $"
a66 1
  real (r8), parameter :: MAXREFRACTION = 0.1_rp ! Don't allow stupidly large n.
d2020 3
@


2.51
log
@Two bug fixes with the h2o stuff
@
text
@d22 1
d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.50 2002/10/16 20:13:55 mjf Exp $"
d891 3
a893 3
    temp => GetVectorQuantityByType ( state, extra, &
      & quantityType=l_temperature, foundInFirst=tempInState )
    ptan => GetVectorQuantityByType ( state, extra, &
d895 2
a896 2
      & foundInFirst=ptanInState )
    h2o => GetVectorQuantityByType ( state, extra, &
d898 7
a904 6
      & foundInFirst=h2oInState, noError=.true.)
    refgph => GetVectorQuantityByType ( state, extra, &
      & quantityType=l_refGPH, foundInFirst=refGPHInState )
    l1Alt => GetVectorQuantityByType ( state, extra, &
      & quantityType=l_tngtGeocAlt, instrumentModule=fmConf%instrumentModule )
    heightOffset => GetVectorQuantityByType ( state, extra, &
d906 1
a906 1
      & noError=.true., foundInFirst=heightOffsetInState )
d909 3
a911 2
    residual => GetVectorQuantityByType ( fwmOut, &
      & quantityType=l_scanResidual, instrumentModule=fmConf%instrumentModule )
d1588 11
a1598 10
  orbIncline => GetVectorQuantityByType ( state, extra, &
    & quantityType=l_orbitInclination )
  temp => GetVectorQuantityByType ( state, extra, &
    & quantityType=l_temperature, foundInFirst=tempInState )
  ptan => GetVectorQuantityByType ( state, extra, &
    & quantityType=l_ptan, instrumentModule=fmConf%instrumentModule,&
    & foundInFirst=ptanInState )
  phitan => GetVectorQuantityByType ( state, extra, &
    & quantityType=l_phitan, instrumentModule=fmConf%instrumentModule)
  h2o => GetVectorQuantityByType ( state, extra, &
d1600 6
a1605 5
    & foundInFirst=h2oInState, noError=.true.)
  refgph => GetVectorQuantityByType ( state, extra, &
    & quantityType=l_refGPH, foundInFirst=refGPHInState )
  l1Alt => GetVectorQuantityByType ( state, extra, &
    & quantityType=l_tngtGeocAlt, instrumentModule=fmConf%instrumentModule )
d1607 3
a1609 2
  residual => GetVectorQuantityByType ( fwmOut, &
      & quantityType=l_scanResidual, instrumentModule=fmConf%instrumentModule )
d2021 3
@


2.50
log
@Added GetGPHPrecision, based on GetBasisGPH.
@
text
@d55 1
a55 1
    & "$Id: ScanModelModule.f90,v 2.49 2002/10/08 17:36:22 pwagner Exp $"
d1753 1
a1753 1
        not_zero_h2o(:,sv_z + temp%template%nosurfs*(sv_p-1)) = .TRUE.
d1802 1
a1802 1
  & 1,temp%template%nosurfs),dim=2)))/))
d2015 3
@


2.49
log
@Added idents to survive zealous Lahey optimizer
@
text
@d51 1
a51 1
    & TwoDScanForwardModel, Get2DHydrostaticTangentPressure
d55 1
a55 1
    & "$Id: ScanModelModule.f90,v 2.48 2002/09/27 01:47:45 vsnyder Exp $"
d199 155
d2015 3
@


2.48
log
@Move some USEs from module scope to procedure scope.  Move parameters from
module scope to procedure scope.  Simplify iteration in z_surface.
Convert some variables from pointers to automatic arrays.  Cosmetic changes.
@
text
@d55 1
a55 1
    & "$Id: ScanModelModule.f90,v 2.47 2002/09/27 00:01:16 vsnyder Exp $"
d59 1
d1853 4
d1860 5
@


2.47
log
@Remove unused variables and dead calculations
@
text
@a18 1
  use Dump_0, only: DUMP
d24 1
a24 2
  USE Get_eta_matrix_m, only: get_eta_sparse
  use Init_Tables_Module, only: L_HEIGHT, L_REFGPH, L_ZETA
d27 1
a27 1
  USE ManipulateVectorQuantities, ONLY: FINDCLOSESTINSTANCES, &
d33 1
a33 1
  USE MLSCommon, ONLY: R8, rp
d38 1
a38 3
  use Output_M, only: OUTPUT
  USE Piq_int_m, only: piq_int
  USE Refraction_m, only: Refractive_index, RefrAterm, RefrBterm
d41 1
a41 1
  USE VectorsModule, ONLY : GETVECTORQUANTITYBYTYPE, VALIDATEVECTORQUANTITY, &
a44 1
  use QuantityTemplates, only: QuantityTemplate_T
d55 1
a55 1
    & "$Id: ScanModelModule.f90,v 2.46 2002/09/26 23:48:21 vsnyder Exp $"
a66 7
  
  ! Now some terms to do with the gas 'constant'
  
  real (r8), parameter :: GASM0 = 25.34314957d-3 ! Constant
  real (r8), parameter :: GASM1 = 2.89644d-3 ! Linear term
  real (r8), parameter :: GASM2 = -0.579d-3 ! Quadratic term
  real (r8), parameter :: GASR0 = 8.31441 ! `Standard' gas constant
d71 3
a73 3
  subroutine GetBasisGPH(temp,refGPH,gph,R,RT,belowRef)
    ! This function takes a state vector, containing one and only one temperature
    ! and reference geopotential height quantity, and returns
d82 7
d101 1
a101 1
    integer :: MYBELOWREF                 ! Result of a hunt
d160 1
a160 1
    call Hunt( logP, refLogP, myBelowRef )
d204 5
d345 1
a345 1
  subroutine GetHydrostaticTangentPressure ( ptan, temp, refGPH, h2o, geocAlt,&
d1333 5
a1372 1
  REAL(rp), PARAMETER :: boltz = 660.988_rp ! = kln10/m  m^2/(K sec^2)
d1801 4
a1804 4
  end subroutine TwoDScanForwardModel
!
  REAL(rp) FUNCTION z_surface(z_basis,t_values,g_ref,h_ref,z_ref,boltz, &
  & threshold,maxiterations)
d1807 6
a1812 6
  REAL(rp), INTENT(in) :: z_basis(:) ! zeta basis for temperature
  REAL(rp), INTENT(in) :: t_values(:) ! temperature coefficients
  REAL(rp), INTENT(in) :: g_ref      ! reference acceloration at the surface
  REAL(rp), INTENT(in) :: h_ref      ! reference geopotential
  REAL(rp), INTENT(in) :: z_ref      ! reference zeta for h_ref
  REAL(rp), INTENT(in) :: boltz      ! k*ln10/m in your favorite units
d1814 2
a1815 2
  REAL(rp), OPTIONAL, INTENT(in) :: threshold ! zeta convergence criteria
  INTEGER, OPTIONAL, INTENT(in) :: maxiterations ! maximum number of
d1820 2
a1821 6
  INTEGER :: iter
  INTEGER :: maxiter
  INTEGER :: n_coeffs
!
  REAL(rp) :: z_new
  REAL(rp) :: thresh
d1823 5
a1827 2
  REAL(rp), POINTER :: eta(:,:)
  REAL(rp), POINTER :: piq(:,:)
d1830 5
a1834 6
  NULLIFY(eta,piq)
  maxiter = 10
  thresh = 0.0001_rp
  IF (PRESENT(maxiterations)) maxiter = maxiterations
  IF (PRESENT(threshold)) thresh = threshold
  n_coeffs = SIZE(z_basis)
d1836 7
a1842 5
  z_surface = z_ref - g_ref*h_ref/(t_values(1)*boltz)
  CALL ALLOCATE_TEST(piq,1,n_coeffs,'piq',modulename)
  CALL ALLOCATE_TEST(eta,1,n_coeffs,'eta',modulename)
  CALL piq_int((/z_surface/),z_basis,z_ref,piq)
  CALL get_eta_sparse(z_basis,(/z_surface/),eta)
d1844 8
a1851 19
  z_new = z_surface - (h_ref*g_ref &
  & + boltz*SUM(RESHAPE(piq,(/n_coeffs/))*t_values)) &
  & / (boltz*SUM(RESHAPE(eta,(/n_coeffs/))*t_values))
  iter = 0
  DO
    iter = iter + 1
    IF(ABS(z_new - z_surface) < thresh .OR. iter == maxiter) EXIT
    z_surface = z_new
    CALL piq_int((/z_surface/),z_basis,z_ref,piq)
    CALL get_eta_sparse(z_basis,(/z_surface/),eta)
! correct
    z_new = z_surface - (h_ref*g_ref &
    & + boltz*SUM(RESHAPE(piq,(/n_coeffs/))*t_values)) &
    & / (boltz*SUM(RESHAPE(eta,(/n_coeffs/))*t_values))
  ENDDO
  z_surface = z_new
  CALL DEALLOCATE_TEST(eta,'eta',modulename)
  CALL DEALLOCATE_TEST(piq,'piq',modulename)
  END FUNCTION z_surface
d1855 3
@


2.46
log
@Avoid computing sine and cosine of the same angle
@
text
@d60 1
a60 1
    & "$Id: ScanModelModule.f90,v 2.45 2002/09/26 20:38:19 vsnyder Exp $"
a110 1
    integer :: STATUS                   ! Flag
a643 1
    integer :: H2OINST                  ! H2O Instance for this MAF
a651 2
    integer :: TEMPINST                 ! Temperature instance for this MAF
    integer :: UPPER                    ! Index into T profile
a660 1
    real (r8) :: UPPERWEIGHT            ! A weight
a894 2
    tempInst = closestTempProfiles ( maf )
    h2oInst = closestH2OProfiles ( maf )
a1089 1
        upper = ifm%belowRef + 1
a1092 1
        upper = lower+1
a1105 5
          if ( j /= noTemps ) then
            upperWeight = (usePtan - basis) / (basisPlus - basis)
          else
            upperWeight = 1.0
          end if
a1357 1
  logical :: HEIGHTOFFSETINSTATE   ! Set if heightOffset in state, not extra
d1862 3
@


2.45
log
@Get some constants from Geometry and Units instead of declaring them, cosmetics
@
text
@d48 1
a48 1
  use Units, only: LN10, PHYQ_Length, PI
d60 1
a60 1
    & "$Id: ScanModelModule.f90,v 2.44 2002/06/27 00:20:43 livesey Exp $"
d252 3
a254 4
    geocLat=GeodToGeocLat(ptan%template%geodLat)
    earthRadius= earthRadA*earthRadB/sqrt(&
      & (earthRadA*sin(geocLat))**2+ &
      & (earthRadB*cos(geocLat))**2)
d258 1
a259 1
    call Deallocate_test ( earthRadius, 'geocLat', ModuleName )
d482 1
a482 1
    do maf=1,ptan%template%noInstances
d492 3
a494 3
      earthRadius= earthRadA*earthRadB/sqrt(&
        & (earthRadA*sin(geocLat))**2+ &
        & (earthRadB*cos(geocLat))**2)
a501 1
      s2=sin(geocLat)**2
d506 1
a506 1
      do iteration=1,maxIterations
d534 1
a534 1
          geometricGPH= -(GM/(refractedGeocAlt*g0))*&
d538 1
a538 1
          n=0.0
a1382 1
  REAL(rp), PARAMETER :: deg2rad = pi / 180.0_rp ! degree to radians
d1388 2
a1389 2
  REAL(rp), POINTER :: earthradc(:)  ! minor axis of earth ellipsoid in orbit
!                              plane projected system
d1391 1
d1432 7
a1438 7
  NULLIFY(earthradc, red_phi_t, sinphi2, cosphi2, geoclats, sinlat2, coslat2)
  NULLIFY(p2, p4, ratio2, ratio4, tan_temp, tan_h2o, tan_refr_indx, l1altrefr)
  NULLIFY(earth_radius, eff_earth_radius, g_ref, refgeomalt_denom, l1refalt)
  NULLIFY(mass_corr, dgphdr, dscandz, eta_z, eta_p_t, eta_p_h2o, piq)
  NULLIFY(eta_zxp_t, eta_zxp_h2o, not_zero_z, not_zero_p_t, not_zero_p_h2o)
  NULLIFY(eta_piqxp, not_zero_t, not_zero_h2o, ratio2_gph, ratio4_gph) 
  NULLIFY(eta_at_one_phi, eta_at_one_zeta, temp_at_surf_phi) 
d1476 1
d1485 3
a1487 4
  earthradc = earthrada*earthradb / SQRT(earthrada**2 &
  & * SIN(deg2rad*orbincline%values(1:ptan%template%noSurfs,fmStat%maf))**2 &
  & + earthradb**2* COS(deg2rad*orbincline%values( &
  &  1:ptan%template%noSurfs,fmStat%maf))**2) ! in meters
d1490 5
a1494 3
  WHERE(0.5_rp*Pi < red_phi_t .AND. red_phi_t <= 1.5_rp*Pi) &
              &  red_phi_t = Pi - red_phi_t
  WHERE(red_phi_t > 1.5_rp*Pi) red_phi_t = red_phi_t - 2.0_rp*Pi
d1496 1
a1496 1
  sinphi2 = SIN(red_phi_t)**2
d1498 2
a1499 3
  geoclats = ASIN(earthradc**2 * SIN(red_phi_t) &
  & * SIN(deg2rad*orbincline%values(1:ptan%template%noSurfs,fmStat%maf)) &
  & / SQRT(earthrada**4*cosphi2 + earthradc**4*sinphi2))
d1505 2
a1506 2
  earth_radius = SQRT((earthrada**4*cosphi2 + earthradc**4*sinphi2) &
               / (earthrada**2*cosphi2 + earthradc**2*sinphi2))
d1522 1
d1877 3
@


2.44
log
@Typo!
@
text
@d23 3
a25 2
  USE get_eta_matrix_m, only: get_eta_sparse
  use Geometry, only: EARTHRADA, EARTHRADB, GEODTOGEOCLAT, LN10, PI
d41 2
a42 2
  USE piq_int_m, only: piq_int
  USE refraction_m, only: refractive_index
d48 1
a48 1
  use Units, only: OMEGA, PHYQ_Length
d51 1
a51 1
  implicit none
d59 4
a62 3
  character (LEN=130), private :: Id = &
    & "$Id: ScanModelModule.f90,v 2.43 2002/06/27 00:19:26 livesey Exp $"
  character (LEN=*), parameter, private :: ModuleName= &
a66 6

  ! First some constants to do with the earths dimensions and rotation

  real (r8), parameter :: EARTHSURFACEGPH = 6387182.265D0 ! GPH at earth's surface m

  ! Now some other constants to do with geopotentials and GPHs
d68 1
a68 4
  real (r8), parameter :: J2=0.0010826256_r8 ! 2nd coefficient
  real (r8), parameter :: J4=-0.0000023709122_r8 ! 4th coeficient.
  real (r8), parameter :: GM=3.98600436D14 ! Big G times earth mass (m2s-2)
  real (r8), parameter :: G0=9.80665    ! Nominal little g ms-2
a69 4
  ! Now some terms to do with refraction
  
  real (r8), parameter :: REFRATERM = 0.0000776D0 ! First term
  real (r8), parameter :: REFRBTERM = 4810.0D0 ! Second term
d1877 3
@


2.43
log
@Fixed another log h2o
@
text
@d59 1
a59 1
    & "$Id: ScanModelModule.f90,v 2.42 2002/06/26 23:37:27 livesey Exp $"
d1666 1
a1666 1
  & * SUM(LOG(max(h2o%values(:,windowstart_h2o:windowfinish_h2o),1e-9_rp))) &
d1888 3
@


2.42
log
@Tidied up dumps.
@
text
@d59 1
a59 1
    & "$Id: ScanModelModule.f90,v 2.41 2002/06/26 23:29:52 bill Exp $"
d1666 1
a1666 1
  & * SUM(LOG(h2o%values(:,windowstart_h2o:windowfinish_h2o)) &
d1888 3
@


2.41
log
@fixed residual calculation bug--wgr
@
text
@d59 1
a59 1
    & "$Id: ScanModelModule.f90,v 2.40 2002/06/26 20:59:25 livesey Exp $"
d333 1
a333 2
          & (ptan%template%noInstances*ptan%template%noSurfs), &
          & format='(f10.2)' )
d335 1
a335 2
        call output ( minval(abs(residual%quantities(1)%values)), &
          & format='(f10.2)' )
d338 1
a338 1
          & format='(f10.2)', advance='yes' )
d1621 1
a1621 1
        & * LOG(h2o%values(sv_z,windowstart_h2o+sv_p-1))
d1888 3
@


2.40
log
@Fixed bug in 2d pressure guesser, was ignoring very first guess
@
text
@d59 1
a59 1
    & "$Id: ScanModelModule.f90,v 2.39 2002/06/26 19:18:53 livesey Exp $"
d1401 1
d1430 1
d1439 1
d1453 1
a1453 1
  NULLIFY(eta_at_one_phi) 
a1513 2
! some testing code
!  WRITE(*,'(8f8.4)') geoclats - GeodToGeocLat(ptan%template%geodLat(:,fmStat%maf))
d1640 2
d1644 1
a1644 1
  z_surf = z_surface(temp%template%surfs(:,1),SUM(temp%values(:, &
d1647 2
a1648 1
  & temp%template%nosurfs),dim=2),g_ref(1), &
d1653 21
a1673 4
! we assume that the lowermost temperature and water vapor values are
! appropriate for this estimate.
  CALL refractive_index(10.0_rp**(-(/z_surf/)),tan_temp(1:1),surf_refr_indx, &
  & h2o_path = tan_h2o(1:1))
d1675 4
a1678 1
  WHERE(ptan%values(:,fmStat%maf) < z_surf) tan_refr_indx = surf_refr_indx(1)
d1696 3
a1698 5
  residual%values(:,fmStat%maf) = (GM / (l1altrefr*g0)) &
  & * (1.0_rp - j2*p2*ratio2 - j4*p4*ratio4) &
  & + ((omega*l1altrefr)**2*coslat2)/(2.0_rp*g0) - (GM / (l1refalt*g0)) &
  & * (1.0_rp - j2*p2*ratio2_gph - j4*p4*ratio4_gph) &
  & + ((omega*l1refalt)**2*coslat2)/(2.0_rp*g0) &
d1702 1
a1702 1
  & * eta_piqxp,dim=2) / g0
d1727 1
a1727 2
      dscandz = dgphdr*l1altrefr*tan_refr_indx*ln10 &
        & / (1.0_rp + tan_refr_indx) + boltz*mass_corr*SUM(RESHAPE( &
d1732 2
a1854 6
!  WRITE(*,'(a)') 'inputted g_ref,h_ref,z_ref,boltz'
!  WRITE(*,*) g_ref, h_ref,z_ref,boltz
!  WRITE(*,'(a)') 'inputted z_basis'
!  WRITE(*,'(8f9.4)') z_basis
!  WRITE(*,'(a)') 'inputted t_values'
!  WRITE(*,'(8f8.2)') t_values
a1881 2
!  WRITE(*,'(a,i3)') 'iterating',iter
!  WRITE(*,'(f9.4)') z_surface
a1882 2
!  WRITE(*,'(a)') 'done iterating'
!  WRITE(*,'(f9.4)') z_surface
d1890 3
@


2.39
log
@Merge of Bills fixes and my diagnostics
@
text
@d59 1
a59 1
    & "$Id: ScanModelModule.f90,v 2.38 2002/06/26 18:44:12 bill Exp $"
d254 19
a314 19
    ! Get a really simple first guess, assuming a uniform log scale height of
    ! 16km
    nullify ( geocLat, earthRadius )
    call Allocate_test ( geocLat, &
      & ptan%template%noSurfs, ptan%template%noInstances, &
      & 'geocLat', ModuleName )
    call Allocate_test ( earthRadius, &
      & ptan%template%noSurfs, ptan%template%noInstances, &
      & 'geocLat', ModuleName )
    geocLat=GeodToGeocLat(ptan%template%geodLat)
    earthRadius= earthRadA*earthRadB/sqrt(&
      & (earthRadA*sin(geocLat))**2+ &
      & (earthRadB*cos(geocLat))**2)
    ptan%values = -3.0+(geocAlt%values - earthRadius)/16e3
    if ( index ( switches, 'pguess' ) /= 0 ) &
      & call dump ( ptan%values, 'Initial ptan guess' )
    call Deallocate_test ( geocLat, 'geocLat', ModuleName )
    call Deallocate_test ( earthRadius, 'geocLat', ModuleName )

d347 3
d1877 3
@


2.38
log
@added a feature to limit the index of refraction to its surface value--wgr
@
text
@d42 1
a42 1
  use Toggles, only: EMIT, TOGGLE
d59 1
a59 1
    & "$Id: ScanModelModule.f90,v 2.37 2002/06/26 01:26:10 livesey Exp $"
d81 1
a81 1
  real (r8), parameter :: MAXREFRACTION = 10.0!1e-2 ! Don't allow stupidly large n.
d310 2
d327 15
d1874 3
@


2.37
log
@Added 2D pressure guesser
@
text
@d59 1
a59 1
    & "$Id: ScanModelModule.f90,v 2.36 2002/06/25 22:17:09 bill Exp $"
d1380 2
d1416 1
d1430 1
d1491 2
a1568 1
  CALL DEALLOCATE_TEST(g_ref,'g_ref',modulename)
d1616 19
d1763 1
d1783 71
d1857 3
@


2.36
log
@doesn't store blocks of zeros--wgr
@
text
@d32 2
a33 1
  use MatrixModule_1, only: CREATEBLOCK, FINDBLOCK, MATRIX_T
d45 4
a48 2
    & VECTOR_T, VECTORVALUE_T
  use Units, only: OMEGA
d55 1
a55 1
    & TwoDScanForwardModel
d59 1
a59 1
    & "$Id: ScanModelModule.f90,v 2.35 2002/06/25 21:55:49 bill Exp $"
d215 124
d1761 3
@


2.35
log
@first debugged? version of 2d scan module--wgr
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.34 2002/06/25 17:03:30 bill Exp $"
d1553 3
a1555 1
        if ( fmConf%differentialScan ) then
d1557 2
a1558 6
        else
          if ( block%kind /= M_Absent ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Found a prexisting d(residual)/d(refGPH), removing' )
            call DestroyBlock ( block )
          end if
d1565 1
a1565 2
        end if
        if ( fmConf%differentialScan ) then
d1567 6
a1572 5
          block%values = EOSHIFT(block%values, &
          & SPREAD(1,1,ptan%template%nosurfs), &
          & RESHAPE(block%values(ptan%template%nosurfs,:), &
          & (/temp%template%nosurfs/)),dim=2) - block%values
        end if
d1585 10
a1594 9
        call CreateBlock ( jacobian, row, col, M_Full )
        block%values = SPREAD(dgphdr*l1altrefr*tan_refr_indx &
        & / ((1.0_rp + tan_refr_indx)*tan_temp),2,temp%template%nosurfs) &
        & * eta_zxp_t(:,1+(sv_p-windowstart_t)*temp%template%nosurfs: &
        & (sv_p-windowstart_t+1)*temp%template%nosurfs) &
        & + boltz*SPREAD(mass_corr,2,temp%template%nosurfs) &
        & * eta_piqxp(:,1+(sv_p-windowstart_t)*temp%template%nosurfs: &
        & (sv_p-windowstart_t+1)*temp%template%nosurfs) / g0
        if ( fmConf%differentialScan ) then
d1596 6
a1601 5
          block%values = EOSHIFT(block%values, &
          & SPREAD(1,1,ptan%template%nosurfs), &
          & RESHAPE(block%values(ptan%template%nosurfs,:), &
          & (/temp%template%nosurfs/)),dim=2) - block%values
        end if
d1634 3
@


2.34
log
@fixed p4 calc in pressure guesser--wgr
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.33 2002/06/25 14:55:15 bill Exp $"
a1300 1
!  print*,'Hello I am Bills new scan model', present(jacobian)
a1356 2
!  WRITE(*,'(a)') 'red_phi_t'
!  WRITE(*,'(8f8.4)') red_phi_t / deg2rad
a1359 4
!  WRITE(*,'(a)') 'geoclats'
!  WRITE(*,'(8f8.4)') geoclats / deg2rad
!  WRITE(*,'(a)') 'c-radius'
!  WRITE(*,'(8f8.2)') earthradc/1000.0_rp
a1366 2
!  WRITE(*,'(a)') 'earth-radius'
!  WRITE(*,'(8f8.2)') earth_radius/1000.0_rp
a1370 2
!  WRITE(*,'(a)') 'g_ref'
!  WRITE(*,'(8f8.4)') g_ref
a1374 2
!  WRITE(*,'(a)') 'eff-radius'
!  WRITE(*,'(8f8.2)') eff_earth_radius/1000.0_rp
a1417 2
!  WRITE(*,'(a)') 'l1refalt'
!  WRITE(*,'(8f8.2)') l1refalt/1000.0_rp
a1483 4
!  WRITE(*,'(a)') 'refractive index'
!  WRITE(*,'(8f8.2)') tan_temp
!  WRITE(*,'(4e12.2)') tan_h2o
!  WRITE(*,'(8f9.6)') tan_refr_indx
a1509 2
!  WRITE(*,'(a)') 'residuals'
!  WRITE(*,'(8f8.4)') residual%values(:,fmStat%maf) / 1000.0
a1523 1
!    WRITE(*,*) 'ptaninstate',ptanInState
a1539 2
!  WRITE(*,'(a)') 'dscandz'
!  WRITE(*,'(8f8.4)') dscandz/1000.0
a1548 1
!    print*,'Hello, refGPHInState=',refGPHInState
a1551 1
!        print*,'Loop:',sv_p, row, col
d1562 1
a1562 1
          block%values(:,1) = -(GM * (1.0_rp - 3.0_rp*j2*p2*ratio2_gph &
a1566 2
!  WRITE(*,'(a,i3)') 'dscandgph phi = ', sv_p
!  WRITE(*,'(8f8.4)') block%values(:,1)
a1567 1
!        call dump ( block%values, 'Block%values' )
a1594 2
!  WRITE(*,'(a,i3)') 'dscandt phi = ', sv_p
!  WRITE(*,'(8f8.4)') block%values/1000.0
d1634 3
@


2.33
log
@work in progress--wgr
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.32 2002/06/25 00:01:32 bill Exp $"
d787 1
a787 1
    p4 = 0.125 * (35*(s2**2) - 30*s2 + 30)
d1665 3
@


2.32
log
@work in progress--wgr
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.31 2002/06/24 18:27:02 livesey Exp $"
d1526 1
a1526 1
  & windowfinish_t),3,ptan%template%nosurfs), (/ptan%template%nosurfs, &
d1596 1
a1596 1
        call dump ( block%values, 'Block%values' )
d1665 3
@


2.31
log
@Debugging
@
text
@d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.30 2002/06/24 17:55:41 bill Exp $"
d1299 1
a1299 1
  NULLIFY(eta_piqxp, not_zero_t, not_zero_h2o) 
d1301 1
a1301 1
  print*,'Hello I am Bills new scan model', present(jacobian)
d1310 1
a1310 2
    & quantityType=l_phitan, instrumentModule=fmConf%instrumentModule,&
    & foundInFirst=ptanInState )
d1318 3
d1358 2
d1361 6
a1366 2
  & / SQRT(earthrada**2*cosphi2 + earthradc**2*sinphi2)) &
         & * SIN(deg2rad*orbincline%values(1:ptan%template%noSurfs,fmStat%maf))
d1374 2
d1379 3
a1381 1
  & / (earth_radius**2*g0) - omega**2*earth_radius*coslat2
d1386 2
a1394 1
  CALL DEALLOCATE_TEST(g_ref,'g_ref',modulename)
d1431 2
d1451 1
d1475 1
a1475 1
  tan_h2o = -23.0_rp ! approx 0.1 ppbv
d1498 5
a1502 1
  & tan_refr_indx,tan_h2o)
d1529 2
d1545 1
d1558 1
a1558 1
        & SPREAD(temp%values(:,windowstart_t:windowfinish_t),3, &
d1562 2
d1573 1
a1573 1
    print*,'Hello, refGPHInState=',refGPHInState
d1577 1
a1577 1
        print*,'Loop:',sv_p, row, col
d1588 1
a1588 1
          block%values(:,1) = (GM * (1.0_rp - 3.0_rp*j2*p2*ratio2_gph &
d1593 2
d1623 3
a1625 1
        & (sv_p-windowstart_t+1)*temp%template%nosurfs)
d1665 3
@


2.30
log
@added a two d scan model subroutine--wgr
@
text
@d51 2
a52 1
  public :: GetBasisGPH, GetHydrostaticTangentPressure, ScanForwardModel
d56 1
a56 1
    & "$Id: ScanModelModule.f90,v 2.29 2002/06/05 00:00:29 livesey Exp $"
d1301 1
d1345 3
a1347 2
  & * SIN(deg2rad*orbincline%values(:,fmStat%maf))**2 &
  & + earthradb**2*COS(deg2rad*orbincline%values(:,fmStat%maf))**2) ! in meters
d1358 1
a1358 1
         & * SIN(deg2rad*orbincline%values(:,fmStat%maf))
d1548 1
d1552 1
d1569 1
d1636 3
@


2.29
log
@Typo fixed
@
text
@d23 1
d27 3
a29 2
    & L_TEMPERATURE, L_TNGTGEOCALT, L_VMR
  use ManipulateVectorQuantities, only: FINDCLOSESTINSTANCES
d33 1
a33 1
  use MLSCommon, only: R8
d39 2
d43 1
a43 1
  use VectorsModule, only : GETVECTORQUANTITYBYTYPE, VALIDATEVECTORQUANTITY, &
d55 1
a55 1
    & "$Id: ScanModelModule.f90,v 2.28 2002/02/13 00:08:58 livesey Exp $"
d68 2
a69 2
  real (r8), parameter :: J2=0.0010826256D0 ! 2nd coefficient
  real (r8), parameter :: J4=-0.0000016165D0 ! 4th coeficient.
d370 1
a370 1
      p4=0.125*(35*(s2**2)-30*s2+30)
d1211 416
a1626 1

d1630 3
@


2.28
log
@Added differential scan model
@
text
@d51 1
a51 1
    & "$Id: ScanModelModule.f90,v 2.27 2001/12/06 23:44:57 livesey Exp $"
d537 13
a549 13
    real (r8), dimension(:), pointer :: DL1GPHBYDHEIGHTOFFSET ! Derivaite
    real (r8), dimension(:), pointer :: DL1GPHBYDL1REFRGEOCALT ! Derivaite
    real (r8), dimension(:), pointer :: DL1GPHBYDPTAN ! Derivaite
    real (r8), dimension(:), pointer :: DL1GPHBYDTEMPLOWER ! Derivaite
    real (r8), dimension(:), pointer :: DL1GPHBYDTEMPUPPER ! Derivaite
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDHEIGHTOFFSET ! Derivaite
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDN ! Derivaite
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDPTAN ! Derivaite
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDTEMPLOWER ! Derivaite
    real (r8), dimension(:), pointer :: DL1REFRGEOCALTBYDTEMPUPPER ! Derivaite
    real (r8), dimension(:), pointer :: DNBYDPTAN ! Derivaite
    real (r8), dimension(:), pointer :: DNBYDTEMPLOWER ! Derivaite
    real (r8), dimension(:), pointer :: DNBYDTEMPUPPER ! Derivaite
d1211 3
@


2.27
log
@Moved Omega into units so L1BOASim can use it.
@
text
@d51 1
a51 1
    & "$Id: ScanModelModule.f90,v 2.26 2001/11/03 01:33:47 livesey Exp $"
d1042 9
a1050 2
    ! Compute residual
    residual%values(:,maf) = l1GPH - hydrosGPH
d1066 8
a1073 1
        call updateDiagonal ( block, dL1GPHByDPtan-dHydrosGPHByDPtan )
d1080 1
a1080 3
        if ( block%kind /= M_Absent ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Found a prexisting d(residual)/d(refGPH), removing' )
d1082 8
a1090 2
        call CreateBlock ( jacobian, row, col, M_Full )
        block%values = -1.0
d1103 7
a1109 1
        block%values(:,1) = dL1GPHByDHeightOffset
d1122 27
a1148 7
        block%values = - dHydrosGPHByDTemp
        do i = 1, noMIFs
          block%values(i,pointTempLayer(i)) = &
            & block%values(i,pointTempLayer(i)) + dL1GPHByDTempLower(i)
          block%values(i,pointTempLayer(i)+1) = &
            & block%values(i,pointTempLayer(i)+1) + dL1GPHByDTempUpper(i)
        end do
d1211 3
@


2.26
log
@Changed the togle from gen to emit
@
text
@d41 1
d47 1
a47 1
  public :: GetBasisGPH, GetHydrostaticTangentPressure, Omega, ScanForwardModel
d51 1
a51 1
    & "$Id: ScanModelModule.f90,v 2.25 2001/10/02 16:49:56 livesey Exp $"
a59 1
  real (r8), parameter :: OMEGA = 7.292115D-5 ! Earth's angular velocity (s-1)
d1167 3
@


2.25
log
@Removed fmStat%finished and change loop ordering in forward models
@
text
@d37 1
a37 1
  use Toggles, only: GEN, TOGGLE
d50 1
a50 1
    & "$Id: ScanModelModule.f90,v 2.24 2001/06/29 23:03:28 livesey Exp $"
d267 1
a267 1
    if ( toggle(gen) ) call trace_begin ('GetHydrostaticTangentPressure' )
d478 1
a478 1
    if ( toggle(gen) ) call trace_end ('GetHydrostaticTangentPressure' )
d599 1
a599 1
    if ( toggle ( gen ) ) call trace_begin ( 'ScanForwardModel' )
d1160 1
a1160 1
    if ( toggle ( gen ) ) call trace_end ( 'ScanForwardModel' )
d1167 3
@


2.24
log
@Whoops, bad parameter set.
@
text
@d50 1
a50 1
    & "$Id: ScanModelModule.f90,v 2.23 2001/06/19 22:43:23 pwagner Exp $"
a1159 2
    if ( maf == noMAFs ) fmStat%finished = .true.

d1167 3
@


2.23
log
@Eliminated l_temperature from things got from init_tables_module
@
text
@d50 1
a50 1
    & "$Id: ScanModelModule.f90,v 2.22 2001/06/04 22:42:36 livesey Exp $"
d503 1
a503 1
    character, parameter :: INVALIDQUANTITY = "Invalid vector quantity for "
d1169 3
@


2.22
log
@Gets belowRef from intermediate
@
text
@d24 1
a24 1
  use Init_Tables_Module, only: L_HEIGHT, L_REFGPH, L_TEMPERATURE, L_ZETA
d50 1
a50 1
    & "$Id: ScanModelModule.f90,v 2.21 2001/05/10 00:46:49 livesey Exp $"
d1169 3
@


2.21
log
@Changed else where to elsewhere (NAG problem?)
@
text
@d50 1
a50 1
    & "$Id: ScanModelModule.f90,v 2.20 2001/05/09 17:43:44 vsnyder Exp $"
a506 1
    integer :: BELOWREF                 ! Returned from getBasisGPH
d923 1
a923 1
        & ifm%R, ifm%RT, belowRef=belowRef )
d959 2
a960 2
        lower = belowRef
        upper = belowRef + 1
d1169 3
@


2.20
log
@Use UpdateDiagonal to store PTAN derivatives; cosmetic changes
@
text
@d50 1
a50 1
    & "$Id: ScanModelModule.f90,v 2.19 2001/05/08 19:43:57 livesey Exp $"
d420 1
a420 1
        else where ( geometricGPH < thisBasisGPH(1) )
d425 1
a425 1
        else where ( geometricGPH >= thisBasisGPH(temp%template%noSurfs) )
d1170 3
@


2.19
log
@Pretty stable version.  Pressure now converges better.  Caught a few
more gremlins in d(residual)/dT.
@
text
@d20 7
a26 4
  use Geometry, only: EARTHRADA, EARTHRADB, PI, LN10, GEODTOGEOCLAT
  use Init_Tables_Module, only: L_ZETA, L_TEMPERATURE, L_REFGPH, L_HEIGHT
  use intrinsic, only: L_TEMPERATURE, L_VMR, L_PTAN, L_TNGTGEOCALT, &
    & L_HEIGHTOFFSET, L_NONE, L_SCANRESIDUAL
d28 4
d37 1
a37 7
  use VectorsModule, only : VECTOR_T, VECTORVALUE_T, GETVECTORQUANTITYBYTYPE, &
    &  VALIDATEVECTORQUANTITY
  use MatrixModule_1, only: MATRIX_T, FINDBLOCK, CREATEBLOCK
  use MatrixModule_0, only: MATRIXELEMENT_T, M_ABSENT, M_BANDED, M_FULL, DESTROYBLOCK
  use ForwardModelConfig, only: ForwardModelConfig_T
  use ForwardModelIntermediate, only: ForwardModelIntermediate_T, ForwardModelStatus_T
  use Toggles, only: TOGGLE, GEN
d39 2
a40 1
  use MLSCommon, only: r8
d50 1
a50 1
    & "$Id: ScanModelModule.f90,v 2.18 2001/05/08 03:05:05 livesey Exp $"
d169 1
a169 1
    call Hunt( logP, refLogP, myBelowRef)
d190 1
a190 1
    if (present(R)) then
d193 2
a194 2
       deallocate(myR)
    endif
d196 1
a196 1
    if (present(rt)) then
d199 2
a200 2
       deallocate(myRT)
    endif
d202 1
a202 1
    if (present(belowRef)) belowRef = myBelowRef
d295 34
a328 34
    call Allocate_Test(basisGPH,temp%template%noSurfs,temp%template%noInstances,&
      & "basisGPH", ModuleName)
    call Allocate_Test(earthRadius,ptan%template%noSurfs, &
      "earthRadius",ModuleName)
    call Allocate_Test(geocLat,ptan%template%noSurfs, &
      "geocLat",ModuleName)
    call Allocate_Test(s2,ptan%template%noSurfs, "s2",ModuleName)
    call Allocate_Test(p2,ptan%template%noSurfs, "p2",ModuleName)
    call Allocate_Test(p4,ptan%template%noSurfs, "p4",ModuleName)
    call Allocate_Test(aCoeff,ptan%template%noSurfs,"aCoeff",ModuleName)
    call Allocate_Test(rtLower,ptan%template%noSurfs,"rtLower",ModuleName)
    call Allocate_Test(rtUpper,ptan%template%noSurfs,"rtUpper",ModuleName)
    call Allocate_Test(basisLower,ptan%template%noSurfs,"basisLower",ModuleName)
    call Allocate_Test(basisUpper,ptan%template%noSurfs,"basisUpper",ModuleName)
    call Allocate_Test(basisSpacing,ptan%template%noSurfs,"basisSpacing",ModuleName)
    call Allocate_Test(bCoeff,ptan%template%noSurfs,"bCoeff",ModuleName)
    call Allocate_Test(cCoeff,ptan%template%noSurfs,"cCoeff",ModuleName)
    call Allocate_Test(deltaRT,ptan%template%noSurfs,"deltaRT",ModuleName)
    call Allocate_Test(geometricGPH,ptan%template%noSurfs, &
      "geometricGPH",ModuleName)
    call Allocate_Test(n,ptan%template%noSurfs,"n",ModuleName)
    call Allocate_Test(pointingH2O,ptan%template%noSurfs,"pointingH2O",ModuleName)
    call Allocate_Test(pointingpres,ptan%template%noSurfs,"pointingpres",ModuleName)
    call Allocate_Test(pointingTemp,ptan%template%noSurfs,"pointingTemp",ModuleName)
    call Allocate_Test(ratio2,ptan%template%noSurfs,"ratio2",ModuleName)
    call Allocate_Test(ratio4,ptan%template%noSurfs,"ratio4",ModuleName)
    call Allocate_Test(refractedGeocAlt,ptan%template%noSurfs,"refractedGeocAlt",ModuleName)

    call Allocate_Test(closestTempProfiles,ptan%template%noInstances,&
      "closestTempProfiles", ModuleName)
    call Allocate_Test(closestH2OProfiles,ptan%template%noInstances,&
      "closestH2OProfiles", ModuleName)
    call Allocate_Test(lower,ptan%template%noSurfs,"lower",ModuleName)
    call Allocate_Test(upper,ptan%template%noSurfs,"upper",ModuleName)
d331 1
a331 1
    call GetBasisGPH(temp,refGPH,basisGPH,rt=rt)
d335 2
a336 2
    call FindClosestInstances(temp,ptan,closestTempProfiles)
    call FindClosestInstances(h2o,ptan,closestH2OProfiles)
d375 4
a378 4
        call InterpolateValues( tempBasis, tempVals, ptanVals, &
          pointingTemp, "Linear", extrapolate='Clamp')
        call InterpolateValues( h2oBasis, h2oVals, ptanVals, &
          pointingH2O, "Linear", extrapolate='Clamp')
d381 1
a381 1
        where(geocAlt%values(:,maf) /= geocAlt%template%badValue)
d407 1
a407 1
        call Hunt(thisBasisGPH, geometricGPH, lower)
d416 1
a416 1
        where (geocAlt%values(:,maf) == geocAlt%template%badValue)
d420 1
a420 1
        elsewhere ( geometricGPH < thisBasisGPH(1) )
d425 1
a425 1
        elsewhere ( geometricGPH >= thisBasisGPH(temp%template%noSurfs) )
d447 28
a474 28
    call Deallocate_Test(basisGPH,"basisGPH", ModuleName)
    call Deallocate_Test(aCoeff,"aCoeff",ModuleName)
    call Deallocate_Test(rtLower,"rtLower",ModuleName)
    call Deallocate_Test(rtUpper,"rtUpper",ModuleName)
    call Deallocate_Test(basisLower,"basisLower",ModuleName)
    call Deallocate_Test(basisUpper,"basisUpper",ModuleName)
    call Deallocate_Test(basisSpacing,"basisSpacing",ModuleName)
    call Deallocate_Test(bCoeff,"bCoeff",ModuleName)
    call Deallocate_Test(cCoeff,"cCoeff",ModuleName)
    call Deallocate_Test(deltaRT,"deltaRT",ModuleName)
    call Deallocate_Test(earthRadius,"earthRadisu",ModuleName)
    call Deallocate_Test(geocLat,"geocLat",ModuleName)
    call Deallocate_Test(p2,"p2",ModuleName)
    call Deallocate_Test(p4,"p4",ModuleName)
    call Deallocate_Test(s2,"s2",ModuleName)
    call Deallocate_Test(geometricGPH,"geometricGPH",ModuleName)
    call Deallocate_Test(n,"n",ModuleName)
    call Deallocate_Test(pointingH2O,"pointingH2O",ModuleName)
    call Deallocate_Test(pointingpres,"pointingpres",ModuleName)
    call Deallocate_Test(pointingTemp,"pointingTemp",ModuleName)
    call Deallocate_Test(ratio2,"ratio2",ModuleName)
    call Deallocate_Test(ratio4,"ratio4",ModuleName)
    call Deallocate_Test(refractedGeocAlt,"refractedGeocAlt",ModuleName)

    call Deallocate_Test(closestTempProfiles,"closestTempProfiles", ModuleName)
    call Deallocate_Test(closestH2OProfiles,"closestH2OProfiles", ModuleName)
    call Deallocate_Test(lower,"lower",ModuleName)
    call Deallocate_Test(upper,"upper",ModuleName)
d476 1
a476 1
    call Deallocate_Test(rt,"rt",ModuleName) ! Was allocated in GetBasisGPH
d644 1
a644 1
    endif
d760 2
a761 2
    call FindClosestInstances(temp,ptan,closestTempProfiles)
    call FindClosestInstances(h2o,ptan,closestH2OProfiles)
d776 1
a776 1
    endif
d926 1
a926 1
    endif
d958 1
a958 1
      if ( i == noMIFs+1) then
d966 1
a966 1
      endif
d1007 1
a1007 1
          else if ( j == lower+1 .and. usePtan >= tempBasis(1)) then
d1011 4
a1014 4
          endif                         ! Basis triangles completely above ptan, no impact
        endif                           ! Good ptan
      enddo                             ! Loop over temp basis
    enddo                               ! Loop over ptans
d1022 3
a1024 3
        enddo
      endif
    enddo
d1034 2
a1035 2
      endif
    enddo
d1059 2
a1060 7
        endif
        call CreateBlock ( jacobian, row, col, M_Banded, noMIFs )
        do i = 1, noMIFs
          block%r1(i) = i
          block%r2(i) = i
        end do
        block%values(:,1) = dL1GPHByDPtan-dHydrosGPHByDPtan
d1071 1
a1071 1
        endif
d1074 1
a1074 1
      endif
d1077 1
a1077 1
      if ( associated (heightOffset) .and. heightOffsetInState) then
d1084 1
a1084 1
        endif
d1097 1
a1097 1
        endif
d1170 4
@


2.18
log
@Working version, pressure guesser a little unstable in extreme cases
@
text
@d48 1
a48 1
    & "$Id: ScanModelModule.f90,v 2.17 2001/05/05 00:03:30 livesey Exp $"
d71 2
a72 1
  real (r8), parameter :: MAXREFRACTION = 1e-2 ! Don't allow stupidly large n.
d242 1
d270 2
a271 2
      & pointingH2O, pointingTemp, ratio2, ratio4, refractedGeocAlt, rt, &
      & rtLower, rtUpper, upper, s2, p2, p4 )
d315 1
a367 1
        print*,'Iteration:',iteration,maxval(ptanVals),minval(ptanVals)
d381 3
a383 1
          n=( (refrATerm*(10**(-ptanVals))) / pointingTemp ) * &
d463 1
d842 1
a842 1
    pointingPres=10.0_r8**(-ptanVals)
d868 5
a959 1
        print*,'refGPH term:',usePtan,belowRef
a981 1

d984 3
a986 1
          if ( (j==1) .and. (usePtan < tempBasis(j)) ) then ! Below bottom of basis
d989 2
a990 1
          else if ( (j==noTemps) .and. (usePtan > tempBasis(j)) ) then ! Above top
d992 3
a994 2
            
          else if ( j < lower ) then         ! Basis triangles completely below ptan
d997 2
a998 1
          else if ( j == lower  ) then  ! Basis triangles with ptan in the top half
d1004 2
a1005 1
          else if ( j == lower+1 ) then ! Basis triangles with ptan in the bottom half
d1173 3
@


2.17
log
@Close to working.  One last part of the temperature derivatives that disagrees with
numerical calculation.
@
text
@d48 1
a48 1
    & "$Id: ScanModelModule.f90,v 2.16 2001/05/04 05:41:26 livesey Exp $"
d71 1
a71 1
  real (r8), parameter :: MAXREFRACTION = 1.0 ! Don't allow stupidly large n.
d206 1
a206 1
       maxIterations )
d211 1
a211 1
    
d235 2
d242 1
d249 3
d294 1
a294 1
         "earthRadius",ModuleName)
d296 1
a296 1
         "geocLat",ModuleName)
d310 1
a310 1
         "geometricGPH",ModuleName)
d317 1
a317 1
    
d319 1
a319 1
         "closestTempProfiles", ModuleName)
d321 1
a321 1
         "closestH2OProfiles", ModuleName)
d336 3
d340 6
d352 2
a353 2
      
      ptan%values(:,maf) = -3.0+(geocAlt%values(:,maf) - &
d356 3
a358 3
      ! particularly worthy of note.  There is a 1D approximation
      ! the same one we made in early versions of UMLSV5 and had to fix.
      ! Make sure we update this one when we go 2D!
d363 76
a438 65
       ! Now we have an iteration loop where we try to fit the tangent pressure
       do iteration=1,maxIterations
          ! The first stage is to refract the tangent point altitudes, for this we
          ! need the refractive index, which is dependent on temperature, pressure
          ! and water vapor concentration for the given altitude.
          
          ! Note here an assumption that temp and h2o are coherent.
          call InterpolateValues( temp%template%surfs(:,1), &
               temp%values(:,closestTempProfiles(maf)), ptan%values(:,maf), &
               pointingTemp, "Linear", extrapolate='C')
          call InterpolateValues( h2o%template%surfs(:,1), &
               h2o%values(:,closestH2OProfiles(maf)), ptan%values(:,maf), &
               pointingH2O, "Linear", extrapolate='C')

          pointingH2O = max(pointingH2O, 0.0_r8)

          where(geocAlt%values(:,maf) /= geocAlt%template%badValue)
            
            n=( (refrATerm*(10**(-ptan%values(:,maf)))) / pointingTemp ) * &
              & (1.0 + refrBTerm*pointingH2O/pointingTemp)
            
            n=min(n,maxRefraction) ! Forbid stupidly large values of n             
            ! Now we're going to compute refracted geocentric altitudes
            refractedGeocAlt=geocAlt%values(:,maf)/(1.0+n)
            
            ! Now convert these to geopotential heights
            ratio2=(earthRadA/refractedGeocAlt)**2
            ratio4=ratio2**2
            
            geometricGPH= -(GM/(refractedGeocAlt*g0))*&
              &              (1-j2*p2*ratio2- j4*p4*ratio4) - &
              ((omega*refractedGeocAlt*cos(geocLat))**2)/(2*g0)+earthSurfaceGPH
          elsewhere
            n=0.0
          end where
          
          ! Now, we're effectively going to compare this with a hydrostatic
          ! calculation.

          call Hunt(temp%template%surfs(:,1), ptan%values(:,maf),lower)
          upper=lower+1
          basisLower= temp%template%surfs(lower,1)
          basisUpper= temp%template%surfs(upper,1)
          basisSpacing= basisUpper - basisLower
          rtLower = rt(lower, closestTempProfiles(maf))
          rtUpper = rt(upper, closestTempProfiles(maf))
          deltaRT = rtUpper - rtLower

          where (geocAlt%values(:,maf) /= geocAlt%template%badValue)
            aCoeff = deltaRT
            bCoeff = 2*rtLower
            cCoeff = -2*g0*(geometricGPH-basisGPH(lower,closestTempProfiles(maf))) /  &
              & (basisSpacing*ln10)
            ! Let ptan contain upperWeight (ptan-basisLower)/basisSpacing first
            ptan%values(:,maf)=2*cCoeff/( -bCoeff - &
              & sqrt(max(bCoeff**2-4*aCoeff*cCoeff,0.0_r8)))
            ! The max is here just in case of slips.
            ! Now let it contain ptan
            ptan%values(:,maf) = basisLower+(ptan%values(:,maf) * basisSpacing)
          elsewhere
            ptan%values(:,maf)=ptan%template%badValue
          end where
       end do                   ! End iteration loop
    end do                      ! Major frame loop

d463 1
a463 1
    
d833 1
a833 1
    pointingH2O = h2oVals(pointH2Olayer) * h2oLowerWeight + &
a854 1

d956 1
a956 1
      
d960 1
a960 1
      ! Loop over temperature basis surfaces
d974 4
a977 1
          ! I'm listing these cases in the order given in the geopotential ATBD.
d979 4
a982 1
          if ( j < lower ) then         ! Basis triangles completely below ptan
d1033 1
d1089 6
a1094 6
!         do i = 1, noMIFs
!           block%values(i,pointTempLayer(i)) = &
!             & block%values(i,pointTempLayer(i)) + dL1GPHByDTempLower(i)
!           block%values(i,pointTempLayer(i)+1) = &
!             & block%values(i,pointTempLayer(i)+1) + dL1GPHByDTempUpper(i)
!         end do
d1096 1
a1096 1

d1159 4
@


2.16
log
@Added some more conditions for derivative calculation
@
text
@d48 1
a48 1
    & "$Id: ScanModelModule.f90,v 2.15 2001/05/04 05:05:46 livesey Exp $"
a473 3
    integer :: BASIS                    ! Index
    integer :: BASISMINUS               ! Index
    integer :: BASISPLUS                ! Index
d496 4
d584 1
a584 1
      & noError=.true. )
d925 1
d931 3
a933 1
      do j = 1,noTemps
d941 27
a967 23
          basisPlus =  tempBasis( min(j+1,noTemps) )
          basisMinus = tempBasis( max(J-1,1) )
          
          ! Points where ptan is within bottom half of basis
          if ( (basisMinus < usePtan) .and. (usePtan <= basis) ) then
            A(i,j) = ((usePtan-basisMinus)**2) / &
              & (2*(basis-basisMinus))
          endif
          
          ! Points where ptan is within top half of basis
          if ( (basis < usePtan) .and. (usePtan <= basisPlus) ) then 
            A(i,j)=(basis-basisMinus)/2.0+&
              & ((usePtan-basis)/2)*(1+(basisPlus-usePtan) / &
              & (basisPlus-basis))
          endif
          
          !Points where ptan is above the top of the basis function
          if ( usePtan > basisPlus ) then 
            A(i,j) = (basisPlus-basisMinus)/2
          endif
        endif                       ! Good ptan
      enddo                         ! Loop over temp basis
    enddo                           ! Loop over ptans
d973 2
a974 2
          dHydrosGPHByDTemp(i,j) = (A(i,j) - A(noMIFs+1,j))*&
            & ifm%R(j)*LN10
d982 3
a984 3
        dHydrosGPHByDPtan(i)= &
          & rt(pointTempLayer(i)) * tempUpperWeight(i)+ &
          & rt(pointTempLayer(i)+1) * tempLowerWeight(i)
d1057 6
a1062 6
        do i = 1, noMIFs
          block%values(i,pointTempLayer(i)) = &
            & block%values(i,pointTempLayer(i)) + dL1GPHByDTempLower(i)
          block%values(i,pointTempLayer(i)+1) = &
            & block%values(i,pointTempLayer(i)+1) + dL1GPHByDTempUpper(i)
        end do
d1127 3
@


2.15
log
@The scan calculation works in ScanModel, haven't tested the
derivatives yet though.
@
text
@d48 1
a48 1
    & "$Id: ScanModelModule.f90,v 2.14 2001/05/03 23:42:57 livesey Exp $"
d996 15
a1010 13
      col = FindBlock ( jacobian%col, ptan%index, maf )
      block => jacobian%block(row,col)
      if ( block%kind /= M_Absent ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Found a prexisting d(residual)/d(ptan), removing' )
        call DestroyBlock ( block )
      endif
      call CreateBlock ( jacobian, row, col, M_Banded, noMIFs )
      do i = 1, noMIFs
        block%r1(i) = i
        block%r2(i) = i
      end do
      block%values(:,1) = dL1GPHByDPtan-dHydrosGPHByDPtan
d1013 10
a1022 6
      col = FindBlock ( jacobian%col, refGPH%index, maf )
      block => jacobian%block(row,col)
      if ( block%kind /= M_Absent ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Found a prexisting d(residual)/d(refGPH), removing' )
        call DestroyBlock ( block )
d1024 1
a1024 3
      call CreateBlock ( jacobian, row, col, M_Full )
      block%values = -1.0

d1026 1
a1026 1
      if ( associated (heightOffset) ) then
d1039 17
a1055 15
      col = FindBlock ( jacobian%col, temp%index, maf )
      block => jacobian%block(row,col)
      if ( block%kind /= M_Absent ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Found a prexisting d(residual)/d(temp), removing' )
        call DestroyBlock ( block )
      endif
      call CreateBlock ( jacobian, row, col, M_Full )
      block%values = - dHydrosGPHByDTemp
      do i = 1, noMIFs
        block%values(i,pointTempLayer(i)) = &
          & block%values(i,pointTempLayer(i)) + dL1GPHByDTempLower(i)
        block%values(i,pointTempLayer(i)+1) = &
          & block%values(i,pointTempLayer(i)+1) + dL1GPHByDTempUpper(i)
      end do
d1057 1
a1057 1
    endif
d1119 4
@


2.14
log
@Closer to working
@
text
@d48 1
a48 1
    & "$Id: ScanModelModule.f90,v 2.13 2001/05/03 23:09:52 livesey Exp $"
d83 1
a83 1
  subroutine GetBasisGPH(temp,refGPH,gph,R,RT)
d93 1
d106 1
a106 1
    integer :: BELOWREF                 ! Result of a hunt
d166 1
a166 1
    call Hunt( logP, refLogP, belowRef)
d169 2
a170 2
    basisGap = logP(belowRef+1) - logP(belowRef)
    aboveRefWeight = ( refLogP - logP(belowRef) )/basisGap
d176 3
a178 3
    currentRefGPH = gph(belowRef,:) + ((basisGap*ln10)/(2*g0))* &
      & ( myRT(belowRef,:) * aboveRefWeight * (2-aboveRefWeight) + &
      &   myRT(belowRef+1,:) * (aboveRefWeight**2))
d198 2
a223 2
    real (r8), dimension(:,:), pointer :: EARTHRADIUS
    real (r8), dimension(:,:), pointer :: GEOCLAT
a225 2
    real (r8), dimension(:), pointer :: RTLOWER
    real (r8), dimension(:), pointer :: RTUPPER
d227 1
a228 1
    real (r8), dimension(:), pointer :: BASISSPACING   ! For temperature
d232 2
d236 2
d243 3
a251 3
    real (r8) :: s2, s4, p2, p4 ! Polynomial terms

    real (r8) :: geocLat1               ! Geocentric latitude
d263 1
a263 1
      & rtLower, rtUpper, upper )
d287 1
a287 1
    call Allocate_Test(earthRadius,ptan%template%noSurfs,ptan%template%noInstances, &
d289 1
a289 1
    call Allocate_Test(geocLat,ptan%template%noSurfs,ptan%template%noInstances, &
d291 3
a321 9
    ! Get a really simple first guess, assuming a uniform log scale height of
    ! 16km
    geocLat=GeodToGeocLat(ptan%template%geodLat)
    earthRadius= earthRadA*earthRadB/sqrt(&
      & (earthRadA*sin(geocLat))**2+ &
      & (earthRadB*cos(geocLat))**2)

    ptan%values= -3.0+(geocAlt%values-earthRadius)/16e3 ! Do a better job later !???

d331 16
a346 9
       ! Precompute some spherical geometry terms, these are
       ! particularly worthy of note.  There is a 1D approximation
       ! the same one we made in early versions of UMLSV5 and had to fix.
       ! Make sure we update this one when we go 2D!
       geocLat1=GeodToGeocLat(temp%template%geodLat(1, &
            closestTempProfiles(maf)))
       s2=sin(geocLat1)**2
       p2=0.5*(3*s2-1)
       p4=0.125*(35*(s2**2)-30*s2+30)
d378 2
a379 2
              &              (1-j2*p2*ratio2- j4*p4*ratio4)- &
              ((omega*refractedGeocAlt*cos(geocLat1))**2)/(2*g0)+earthSurfaceGPH
d383 1
a383 1

d413 1
d427 3
a473 1
    integer :: ABOVEREF                 ! Returned from getBasisGPH
d810 1
a810 1
    pointingPres=10.0_r8**(ptanVals)
d853 1
a853 1
    l1GPH = ( -(GM/l1RefrGeocAlt) * &
d855 2
a856 1
      & ((omega*l1RefrGeocAlt*cos(geocLat))**2)/2.0 ) / g0
d885 2
a886 1
      call GetBasisGPH ( temp, refGPH, ifm%basisGPH, ifm%R, ifm%RT )
d923 1
a923 1
        upper = aboveRef
d1104 2
d1113 3
@


2.13
log
@First version of scan model.  Compiles, but probably doesn't run.
@
text
@d36 2
a37 1

d44 1
a44 1
  public :: GetBasisGPH, GetHydrostaticTangentPressure, Omega
d48 1
a48 1
    & "$Id: ScanModelModule.f90,v 2.12 2001/05/03 20:34:08 vsnyder Exp $"
d254 2
d437 2
d491 1
a491 1
    real (r8), pointer :: USEPTAN       ! A tangent pressure
d559 1
d614 1
a614 1
    nullify ( basisGPH, dh2obydptan, dhydrosgphbydptan, dl1gphbydheightoffset )
d620 2
a621 2
    nullify ( geoclat, h2obasis, h2obasisgap, h2olowerweight )
    nullify ( h2oupperweight, h2ovals, hydrosgph, l1gph, l1refrgeocalt )
d623 5
a627 3
    nullify ( povertsquared, ptanvals, ratio2, ratio4 )
    nullify ( rt, s2, tempbasis, tempbasisgap )
    nullify ( templowerweight, tempupperweight, tempvals )
d683 2
d712 1
a712 1
    call allocate_test ( A, noMIFs, noTemps, &
d740 3
a742 3
    s2 = (sin(geocLat(I)))**2
    p2 = 0.5 * (3*s2(I)-1) ! Polynomial terms
    p4 = 0.125 * (35*(s2(I)**2) - 30*s2(I) + 30)
d1034 7
a1040 1
      !block%values = dL1GPHByDTemp - dHydrosGPHByDTemp
d1077 1
d1095 2
d1102 3
@


2.12
log
@Cosmetic changes
@
text
@a3 1
!=============================================================================
a4 1
!=============================================================================
d18 1
a18 1
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d20 8
a27 7
  use Geometry, only: earthRadA,earthRadB, PI, LN10, GeodToGeocLat
  use Init_Tables_Module, only: L_Zeta, L_Temperature, L_RefGPH
  use intrinsic, only: L_TEMPERATURE, L_VMR, L_PTAN, L_TNGTGEOCALT
  use ManipulateVectorQuantities, only: FindClosestInstances
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate, &
       MLSMSG_Error
  use MLSNumerics, only : Hunt, InterpolateValues
d30 6
a35 2
  use VectorsModule, only : Vector_T, VectorValue_T, GetVectorQuantityByType, &
    &  ValidateVectorQuantity
d47 1
a47 1
    & "$Id: ScanModelModule.f90,v 2.11 2001/04/21 00:52:24 livesey Exp $"
d56 2
a57 2
  real (r8), parameter :: omega=7.292115D-5 ! Earth's angular velocity (s-1)
  real (r8), parameter :: earthSurfaceGPH=6387182.265D0 ! GPH at earth's surface m
d61 2
a62 1
  real (r8), parameter :: j2=0.0010826256D0, j4=-0.0000016165D0 ! 2nd and 4th coefs.
d64 1
a64 1
  real (r8), parameter :: g0=9.80665    ! Nominal little g ms-2
d68 3
a70 2
  real (r8), parameter :: refrATerm=0.0000776D0, refrBterm=4810.0D0
  real (r8), parameter :: maxRefraction=1.0 ! Don't allow stupidly large n.
d74 11
a84 10
  real (r8), parameter :: gasM0=25.34314957d-3, gasM1=2.89644d-3, gasM2=-0.579d-3
  real (r8), parameter :: gasR0=8.31441

contains ! --------------- Subroutines and functions --------------------------


  ! This function takes a state vector, containing one and only one temperature
  ! and reference geopotential height quantity, and returns

  subroutine GetBasisGPH ( Temp, RefGPH, Gph, R, RT )
d87 3
a89 3
    type (VectorValue_T), intent(in) :: Temp
    type (VectorValue_T), intent(in) :: RefGPH
    real (r8), dimension(:,:), intent(out) :: Gph ! Result (temp%noSurfs,temp%noInstances)
d93 4
a96 1
    ! Local variables
d98 16
a113 18
    real (r8), dimension(:), allocatable :: LogP ! -log10 pressure, noSurfs
    real (r8), dimension(:), allocatable :: ModifiedBasis ! noSurfs
    real (r8), dimension(:), pointer :: MyR      ! Gas constant, noSurfs
    real (r8), dimension(:,:), pointer :: MyRT   ! R*T (noSurfs,noInstances)
    real (r8), dimension(:), allocatable :: CurrentRefGPH ! (noInstances)
    real (r8), dimension(:), allocatable :: Correction ! (noInstances)

    real (r8), dimension(:), allocatable :: DeltaGeopot ! noInstances

    integer :: belowRef
    real (r8) :: aboveRefWeight ! a weight for an interpolation
    
    integer :: instance,surf ! Loop counters
    integer :: status ! Flag
    
    real (r8) :: basisCutoff    ! Threshold level for gas constant
    real (r8) :: refLogP        ! Log p of pressure reference surface
    real (r8) :: basisGap       ! Space between adjacent surfaces
d131 3
a133 27
    allocate(logP(temp%template%noSurfs),STAT=status)
    if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         "logP in GetBasisGPH")

    allocate(modifiedBasis(temp%template%noSurfs),STAT=status)
    if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         "modifiedBasis in GetBasisGPH")

    allocate(myR(temp%template%noSurfs),STAT=status)
    if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         "myR in GetBasisGPH")

    allocate(myRT(temp%template%noSurfs,temp%template%noInstances),STAT=status)
    if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         "myRT in GetBasisGPH")

    allocate(deltaGeopot(temp%template%noInstances),STAT=status)
    if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         "deltaGeopot in GetBasisGPH")

    allocate(currentRefGPH(temp%template%noInstances),STAT=status)
    if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         "currentRefGPH in GetBasisGPH")

    allocate(correction(temp%template%noInstances),STAT=status)
    if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
         "correction in GetBasisGPH")
d142 3
a144 3
    basisCutoff=-gasM1/(2*gasM2) ! Set a threshold value
    modifiedBasis=max(logP,basisCutoff) ! Either logP or this threshold
    myR=gasR0/(gasM0+gasM1*modifiedBasis+gasM2*modifiedBasis**2)
d148 2
a149 2
    do instance=1,temp%template%noInstances
       myRT(:,instance)=myR*temp%values(:,instance)
d152 6
a157 6
    gph(1,:)=0.0
    do surf=2,temp%template%noSurfs
       deltaGeopot=(ln10/(2*g0)) * &
         & (myRT(surf,:)+myRT(surf-1,:)) * &
         & (logP(surf)-logP(surf-1))
       gph(surf,:)=gph(surf-1,:)+deltaGeopot
d163 2
a164 2
    refLogP=refGPH%template%surfs(1,1)
    call Hunt(logP,refLogP,belowRef)
d167 2
a168 2
    basisGap=logP(belowRef+1)-logP(belowRef)
    aboveRefWeight=(refLogP-logP(belowRef))/basisGap
d171 1
a171 1
    aboveRefWeight=max(min(aboveRefWeight,1.0D0),0.0D0)
d174 3
a176 3
    currentRefGPH=gph(belowRef,:)+((basisGap*ln10)/(2*g0))* &
      & (myRT(belowRef,:)*aboveRefWeight*(2-aboveRefWeight)+ &
      &  myRT(belowRef+1,:)*(aboveRefWeight**2))
d180 3
a182 3
    correction=refGPH%values(1,:)-currentRefGPH
    do surf=1,temp%template%noSurfs         
       gph(surf,:)=gph(surf,:)+correction
d200 8
a207 10
  ! ----------------------------------------------------------------------------

  ! This routine is a pressure `guesser'.  It works by comparing the
  ! geopotential heights estimated from the level 1 heights with those based on
  ! a hydrostatic calculation.  The tangent point pressure is adjusted over
  ! several iterations until a good match is achieved.

  subroutine GetHydrostaticTangentPressure ( Ptan, Temp, RefGPH, H2o, GeocAlt, &
    & MaxIterations )

d209 6
a214 6
    type (VectorValue_T), intent(inout) :: PTAN
    type (VectorValue_T), intent(in) :: TEMP
    type (VectorValue_T), intent(in) :: REFGPH
    type (VectorValue_T), intent(in) :: H2O
    type (VectorValue_T), intent(in) :: GEOCALT
    integer, intent(in) :: maxIterations ! Number of iterations to use
d218 15
a232 13
    real (r8), dimension(:,:), pointer :: BasisGPH     ! temp(noSurfs,noInstances)
    real (r8), dimension(:,:), pointer :: EarthRadius
    real (r8), dimension(:,:), pointer :: GeocLat
    real (r8), dimension(:,:), pointer :: Rt           ! rt=R*T

    real (r8), dimension(:), pointer :: ACoeff         ! Quadratic term
    real (r8), dimension(:), pointer :: BCoeff         ! Quadratic term
    real (r8), dimension(:), pointer :: BasisLower     ! For temperature
    real (r8), dimension(:), pointer :: BasisSpacing   ! For temperature
    real (r8), dimension(:), pointer :: BasisUpper     ! For temperature
    real (r8), dimension(:), pointer :: CCoeff         ! Quadratic term
    real (r8), dimension(:), pointer :: DeltaRT
    real (r8), dimension(:), pointer :: GeometricGPH
d234 16
a249 18
    real (r8), dimension(:), pointer :: PointingH2O    ! t.p. h2o
    real (r8), dimension(:), pointer :: PointingTemp   ! t.p. temp.
    real (r8), dimension(:), pointer :: Ratio2         ! minor frame
    real (r8), dimension(:), pointer :: Ratio4         ! minor frame
    real (r8), dimension(:), pointer :: RefractedGeocAlt ! minor frame
    real (r8), dimension(:), pointer :: RtLower
    real (r8), dimension(:), pointer :: RtUpper

    integer, dimension(:), pointer :: ClosestH2OProfiles
    integer, dimension(:), pointer :: ClosestTempProfiles
    integer, dimension(:), pointer :: Lower ! index into temperature profile
    integer, dimension(:), pointer :: Upper ! index into temperature profile

    real (r8) :: S2, S4, P2, P4 ! Polynomial terms

    real (r8) :: GeocLat1               ! Geocentric latitude
    integer :: Iteration                ! Loop stuff
    integer :: Maf                      ! Loop counter
d258 1
d436 644
d1083 3
@


2.11
log
@Fixed memory leak.
@
text
@d44 1
a44 1
    & "$Id: ScanModelModule.f90,v 2.10 2001/04/10 22:27:47 vsnyder Exp $"
d78 1
a78 1
  subroutine GetBasisGPH(temp,refGPH,gph,R,RT)
d81 3
a83 3
    type (VectorValue_T), intent(IN) :: temp
    type (VectorValue_T), intent(IN) :: refGPH
    real (r8), dimension(:,:), intent(OUT) :: gph ! Result (temp%noSurfs,temp%noInstances)
d89 6
a94 6
    real (r8), dimension(:), allocatable :: logP ! -log10 pressure, noSurfs
    real (r8), dimension(:), allocatable :: modifiedBasis ! noSurfs
    real (r8), dimension(:), pointer :: myR      ! Gas constant, noSurfs
    real (r8), dimension(:,:), pointer :: myRT   ! R*T (noSurfs,noInstances)
    real (r8), dimension(:), allocatable :: currentRefGPH ! (noInstances)
    real (r8), dimension(:), allocatable :: correction ! (noInstances)
d96 1
a96 1
    real (r8), dimension(:), allocatable :: deltaGeopot ! noInstances
d224 2
a225 2
  subroutine GetHydrostaticTangentPressure ( ptan, temp, refGPH, h2o, geocAlt,&
       maxIterations )
d228 6
a233 6
    type (VectorValue_T), intent(INOUT) :: PTAN
    type (VectorValue_T), intent(IN) :: TEMP
    type (VectorValue_T), intent(IN) :: REFGPH
    type (VectorValue_T), intent(IN) :: H2O
    type (VectorValue_T), intent(IN) :: GEOCALT
    integer, intent(IN) :: maxIterations ! Number of iterations to use
d237 32
a268 32
    real (r8), dimension(:,:), pointer :: rt           ! rt=R*T
    real (r8), dimension(:,:), pointer :: basisGPH     ! temp(noSurfs,noInstances)
    real (r8), dimension(:,:), pointer :: earthRadius
    real (r8), dimension(:,:), pointer :: geocLat

    real (r8), dimension(:), pointer :: aCoeff         ! Quadratic term
    real (r8), dimension(:), pointer :: rtLower
    real (r8), dimension(:), pointer :: rtUpper
    real (r8), dimension(:), pointer :: basisLower     ! For temperature
    real (r8), dimension(:), pointer :: basisUpper     ! For temperature
    real (r8), dimension(:), pointer :: basisSpacing   ! For temperature
    real (r8), dimension(:), pointer :: bCoeff         ! Quadratic term
    real (r8), dimension(:), pointer :: cCoeff         ! Quadratic term
    real (r8), dimension(:), pointer :: deltaRT 
    real (r8), dimension(:), pointer :: geometricGPH
    real (r8), dimension(:), pointer :: n              ! Refractive index
    real (r8), dimension(:), pointer :: pointingH2O    ! t.p. h2o
    real (r8), dimension(:), pointer :: pointingTemp   ! t.p. temp.
    real (r8), dimension(:), pointer :: ratio2         ! minor frame
    real (r8), dimension(:), pointer :: ratio4         ! minor frame
    real (r8), dimension(:), pointer :: refractedGeocAlt ! minor frame

    integer, dimension(:), pointer :: closestTempProfiles
    integer, dimension(:), pointer :: closestH2OProfiles
    integer, dimension(:), pointer :: lower ! index into temperature profile
    integer, dimension(:), pointer :: upper ! index into temperature profile

    real (r8) :: s2, s4, p2, p4 ! Polynomial terms

    real (r8) :: geocLat1               ! Geocentric latitude
    integer :: iteration                ! Loop stuff
    integer :: maf                      ! Loop counter
d272 5
a276 5
    nullify ( rt, basisGPH, earthRadius, geocLat, aCoeff, rtLower, rtUpper, &
      & basisLower, basisUpper, basisSpacing, bCoeff, cCoeff, deltaRT, &
      & geometricGPH, n, pointingH2O, pointingTemp, ratio2, ratio4, &
      & refractedGeocAlt, closestTempProfiles, closestH2OProfiles, lower, &
      & upper )
d457 3
@


2.10
log
@Nullify explicitly instead of with <initialization> so as not to give
pointers the SAVE attribute.  <initialization> is NOT executed on each
entry to a procedure.
@
text
@d44 1
a44 1
    & "$Id: ScanModelModule.f90,v 2.9 2001/04/03 19:03:07 vsnyder Exp $"
d450 2
d457 5
@


2.9
log
@Get L_H2O from Molecules -- can't get it from Intrinsic after the order of
Molecules and Intrinsic was reversed.
@
text
@d44 1
a44 1
    & "$Id: ScanModelModule.f90,v 2.8 2001/03/20 21:43:41 livesey Exp $"
d91 2
a92 2
    real (r8), dimension(:), pointer :: myR=>NULL() ! Gas constant, noSurfs
    real (r8), dimension(:,:), pointer :: myRT=>NULL() ! R*T (noSurfs,noInstances)
d108 1
d237 26
a262 26
    real (r8), dimension(:,:), pointer :: rt=> NULL() ! rt=R*T
    real (r8), dimension(:,:), pointer :: basisGPH=> NULL() ! temp(noSurfs,noInstances)
    real (r8), dimension(:,:), pointer :: earthRadius=> NULL()
    real (r8), dimension(:,:), pointer :: geocLat=> NULL()

    real (r8), dimension(:), pointer :: aCoeff=> NULL() ! Quadratic term
    real (r8), dimension(:), pointer :: rtLower=> NULL()
    real (r8), dimension(:), pointer :: rtUpper=> NULL()
    real (r8), dimension(:), pointer :: basisLower=> NULL() ! For temperature
    real (r8), dimension(:), pointer :: basisUpper=> NULL() ! For temperature
    real (r8), dimension(:), pointer :: basisSpacing=> NULL() ! For temperature
    real (r8), dimension(:), pointer :: bCoeff=> NULL() ! Quadratic term
    real (r8), dimension(:), pointer :: cCoeff=> NULL() ! Quadratic term
    real (r8), dimension(:), pointer :: deltaRT=> NULL() 
    real (r8), dimension(:), pointer :: geometricGPH=> NULL()
    real (r8), dimension(:), pointer :: n=> NULL() ! Refractive index
    real (r8), dimension(:), pointer :: pointingH2O=> NULL() ! t.p. h2o
    real (r8), dimension(:), pointer :: pointingTemp=> NULL() ! t.p. temp.
    real (r8), dimension(:), pointer :: ratio2=> NULL() ! minor frame
    real (r8), dimension(:), pointer :: ratio4=> NULL() ! minor frame
    real (r8), dimension(:), pointer :: refractedGeocAlt=> NULL() ! minor frame

    integer, dimension(:), pointer :: closestTempProfiles=> NULL()
    integer, dimension(:), pointer :: closestH2OProfiles=> NULL()
    integer, dimension(:), pointer :: lower=>NULL() ! index into temperature profile
    integer, dimension(:), pointer :: upper=>NULL() ! index into temperature profile
d272 5
d455 4
@


2.8
log
@Moved geodtogeoc lat to geometry in lib
@
text
@d20 1
d23 3
d28 3
a32 6
  use Init_Tables_Module, only: L_Zeta, L_Temperature, L_RefGPH
  use ManipulateVectorQuantities, only: FindClosestInstances
  use MLSNumerics, only : Hunt, InterpolateValues
  use intrinsic, only: L_H2O, L_TEMPERATURE, L_VMR, L_PTAN, L_TNGTGEOCALT
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Output_M, only: OUTPUT
d44 1
a44 1
    & "$Id: ScanModelModule.f90,v 2.7 2001/03/15 23:31:15 livesey Exp $"
d449 3
@


2.7
log
@Made it default private.
@
text
@d21 1
d43 1
a43 1
    & "$Id: ScanModelModule.f90,v 2.6 2001/03/07 22:42:38 livesey Exp $"
a51 2
  real (r8), parameter :: earthRadA=6378137.0D0 ! Major axis radius in m
  real (r8), parameter :: earthRadB=6356752.3141D0 ! Minor axis radius in m
d70 1
a70 6
    
  ! Just in case this constant isn't defined everywhere else.
  
  real (r8), parameter :: PI=3.1415926535897931159979635D0
  real (r8), parameter :: LN10=2.302585124969482421875D0
  
a72 23
  ! This function converts a geodetic latitude (IN DEGREES!) into a geocentric
  ! one (IN RADIANS!)

  real(r8) ELEMENTAL function GeodToGeocLat(geodLat)

    ! Arguments
    real (r8), intent(IN) :: geodLat

    ! Executable code, use special method for high latitudes.
    if (abs(geodLat).gt.89.0) then
       if (geodLat.gt.0.0) then
          geodtoGeocLat=PI/2.0+((earthRadA/earthRadB)**2)*&
               (geodLat-90.0)*PI/180.0
       else
          geodToGeocLat=-PI/2.0+((earthRadA/earthRadB)**2)*&
               (geodLat+90.0)*PI/180.0
       endif
    else
       geodToGeocLat=atan(((earthRadB/earthRadA)**2)*tan(geodLat*PI/180.0))
    endif
  end function GeodToGeocLat
  
  ! --------------------------------------------------------------------------
d448 3
@


2.6
log
@Got pressure guesser working
@
text
@d36 4
d42 1
a42 1
    & "$Id: ScanModelModule.f90,v 2.5 2001/03/06 00:34:54 livesey Exp $"
d477 3
@


2.5
log
@Pretty good version
@
text
@d38 1
a38 1
    & "$Id: ScanModelModule.f90,v 2.4 2001/03/05 01:20:26 livesey Exp $"
d102 1
a102 1
  subroutine GetBasisGPH(temp,refGPH,gph,R,art)
d109 1
a109 1
    real (r8), dimension(:,:), pointer, optional :: art ! ln10*R*T (noSurfs,noInstances)
d116 2
a117 2
    real (r8), dimension(:,:), pointer :: myArt=>NULL() ! ln10*R*T (noSurfs,noInstances)
    real (r8), dimension(:), allocatable :: currentRefGeopot ! (noInstances)
d159 1
a159 1
    allocate(myArt(temp%template%noSurfs,temp%template%noInstances),STAT=status)
d161 1
a161 1
         "myArt in GetBasisGPH")
d167 1
a167 1
    allocate(currentRefGeopot(temp%template%noInstances),STAT=status)
d169 1
a169 1
         "currentRefGeopot in GetBasisGPH")
d186 1
a186 1
    ! Compute ln10*R*T for each point, avoid spread intrinsic to save memory
d189 1
a189 1
       myArt(:,instance)=LN10*myR*temp%values(:,instance)
d194 3
a196 1
       deltaGeopot=(myArt(surf,:)+myArt(surf-1,:))*(logP(surf)-logP(surf-1))/2.0
d214 3
a216 3
    currentRefGeopot=gph(belowRef,:)+( &
         myArt(belowRef,:)*aboveRefWeight*(2-aboveRefWeight)+&
         myArt(belowRef+1,:)*(aboveRefWeight**2))*basisGap/2.0
d220 1
a220 1
    correction=refGPH%values(1,:)-currentRefGeopot/g0
d222 1
a222 1
       gph(surf,:)=gph(surf,:)/g0+correction
d231 2
a232 2
    if (present(art)) then
       art=>myArt
d234 1
a234 1
       deallocate(myArt)
d260 1
a260 1
    real (r8), dimension(:,:), pointer :: art=> NULL() ! art=ln10*R*T
d266 2
a267 1
    real (r8), dimension(:), pointer :: artLower=> NULL()
d269 1
d273 1
a273 1
    real (r8), dimension(:), pointer :: deltaArt=> NULL() 
d285 1
d322 2
a323 1
    call Allocate_Test(artLower,ptan%template%noSurfs,"artLower",ModuleName)
d325 1
d329 1
a329 1
    call Allocate_Test(deltaArt,ptan%template%noSurfs,"deltaArt",ModuleName)
d344 1
d347 1
a347 1
    call GetBasisGPH(temp,refGPH,basisGPH,art=art)
a366 1

a378 1

d407 1
a407 1
              &              (1-j2*p2*ratio2- j4*p4*ratio4)+ &
d416 2
a417 7
          call Hunt(temp%template%surfs(:,1), &
               ptan%values(:,maf),lower)
          basisSpacing= temp%template%surfs(lower+1,1)- &
               temp%template%surfs(lower,1)
          deltaArt=art(lower+1,closestTempProfiles(maf))-&
               art(lower,closestTempProfiles(maf))
          artLower=art(lower,closestTempProfiles(maf))
d419 5
d426 6
a431 6
            aCoeff= deltaArt/basisSpacing
            bCoeff= 2*artLower - 2*basisLower*aCoeff
            cCoeff= (basisLower**2)*aCoeff - &
              & 2*artLower*basisLower - &
              & 2*g0*(geometricGPH - basisGPH(lower,closestTempProfiles(maf)))/ln10
            ptan%values(:,maf)=2*cCoeff/( -bCoeff -&
d434 2
d445 2
a446 1
    call Deallocate_Test(artLower,"artLower",ModuleName)
d448 1
d452 1
a452 1
    call Deallocate_Test(deltaArt,"deltaArt",ModuleName)
d466 1
d473 3
@


2.4
log
@Interim version
@
text
@d5 1
a5 1
MODULE ScanModelModule          ! Scan model and associated calculations
d20 2
a21 2
  USE Dump_0, only: DUMP
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate, &
d23 1
a23 1
  USE VectorsModule, ONLY : Vector_T, VectorValue_T, GetVectorQuantityByType, &
d25 6
a30 6
  USE Init_Tables_Module, ONLY: L_Zeta, L_Temperature, L_RefGPH
  USE ManipulateVectorQuantities, ONLY: FindClosestInstances
  USE MLSNumerics, ONLY : Hunt, InterpolateValues
  USE Intrinsic, ONLY: L_H2O, L_TEMPERATURE, L_VMR, L_PTAN, L_TNGTGEOCALT
  USE Allocate_Deallocate, ONLY: Allocate_Test, Deallocate_Test
  USE Output_M, only: OUTPUT
d32 1
a32 1
  USE MLSCommon, ONLY: r8
d34 1
a34 1
  IMPLICIT NONE
d37 3
a39 3
  CHARACTER (LEN=130), PRIVATE :: Id = &
    & "$Id: ScanModelModule.f90,v 2.3 2001/02/28 17:35:36 livesey Exp $"
  CHARACTER (LEN=*), PARAMETER, PRIVATE :: ModuleName= &
d47 4
a50 3
  REAL (r8), PARAMETER :: earthRadA=6378.137D0 ! Major axis radius in km
  REAL (r8), PARAMETER :: earthRadB=6356.7523141D0 ! Minor axis radius in km
  REAL (r8), PARAMETER :: omega=7.292115D-5 ! Earth's angular velocity (s-1)
d54 3
a56 3
  REAL (r8), PARAMETER :: j2=0.0010826256D0, j4=-0.0000016165D0 ! 2nd and 4th coefs.
  REAL (r8), PARAMETER :: GM=3.98600436D5 ! Big G times earth mass (km2s-2)
  REAL (r8), PARAMETER :: g0=9.80665    ! Nominal little g
d60 2
a61 2
  REAL (r8), PARAMETER :: refrATerm=0.0000776D0, refrBterm=4810.0D0
  REAL (r8), PARAMETER :: maxRefraction=1.0 ! Don't allow stupidly large n.
d65 2
a66 2
  REAL (r8), PARAMETER :: gasM0=25.34314957d-3, gasM1=2.89644d-3, gasM2=-0.579d-3
  REAL (r8), PARAMETER :: gasR0=8.31441
d70 2
a71 2
  REAL (r8), PARAMETER :: PI=3.1415926535897931159979635D0
  REAL (r8), PARAMETER :: LN10=2.302585124969482421875D0
d73 1
a73 1
CONTAINS ! --------------- Subroutines and functions --------------------------
d78 1
a78 1
  REAL(r8) ELEMENTAL FUNCTION GeodToGeocLat(geodLat)
d81 1
a81 1
    REAL (r8), INTENT(IN) :: geodLat
d84 2
a85 2
    IF (ABS(geodLat).GT.89.0) THEN
       IF (geodLat.GT.0.0) THEN
d88 1
a88 1
       ELSE
d91 5
a95 5
       ENDIF
    ELSE
       geodToGeocLat=ATAN(((earthRadB/earthRadA)**2)*TAN(geodLat*PI/180.0))
    ENDIF
  END FUNCTION GeodToGeocLat
d102 1
a102 1
  SUBROUTINE GetBasisGPH(temp,refGPH,gph,R,art)
d105 5
a109 5
    TYPE (VectorValue_T), INTENT(IN) :: temp
    TYPE (VectorValue_T), INTENT(IN) :: refGPH
    REAL (r8), DIMENSION(:,:), INTENT(OUT) :: gph ! Result (temp%noSurfs,temp%noInstances)
    REAL (r8), DIMENSION(:), POINTER, OPTIONAL :: R ! Gas constant, noSurfs
    REAL (r8), DIMENSION(:,:), POINTER, OPTIONAL :: art ! ln10*R*T (noSurfs,noInstances)
d113 6
a118 6
    REAL (r8), DIMENSION(:), ALLOCATABLE :: logP ! -log10 pressure, noSurfs
    REAL (r8), DIMENSION(:), ALLOCATABLE :: modifiedBasis ! noSurfs
    REAL (r8), DIMENSION(:), POINTER :: myR=>NULL() ! Gas constant, noSurfs
    REAL (r8), DIMENSION(:,:), POINTER :: myArt=>NULL() ! ln10*R*T (noSurfs,noInstances)
    REAL (r8), DIMENSION(:), ALLOCATABLE :: currentRefGeopot ! (noInstances)
    REAL (r8), DIMENSION(:), ALLOCATABLE :: correction ! (noInstances)
d120 1
a120 1
    REAL (r8), DIMENSION(:), ALLOCATABLE :: deltaGeopot ! noInstances
d122 2
a123 2
    INTEGER :: belowRef
    REAL (r8) :: aboveRefWeight ! a weight for an interpolation
d125 2
a126 2
    INTEGER :: instance,surf ! Loop counters
    INTEGER :: status ! Flag
d128 3
a130 3
    REAL (r8) :: basisCutoff    ! Threshold level for gas constant
    REAL (r8) :: refLogP        ! Log p of pressure reference surface
    REAL (r8) :: basisGap       ! Space between adjacent surfaces
d147 2
a148 2
    ALLOCATE(logP(temp%template%noSurfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
d151 2
a152 2
    ALLOCATE(modifiedBasis(temp%template%noSurfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
d155 2
a156 2
    ALLOCATE(myR(temp%template%noSurfs),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
d159 2
a160 2
    ALLOCATE(myArt(temp%template%noSurfs,temp%template%noInstances),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
d163 2
a164 2
    ALLOCATE(deltaGeopot(temp%template%noInstances),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
d167 2
a168 2
    ALLOCATE(currentRefGeopot(temp%template%noInstances),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
d171 2
a172 2
    ALLOCATE(correction(temp%template%noInstances),STAT=status)
    IF (status/=0) CALL MLSMessage(MLSMSG_Error,ModuleName,MLSMSG_Allocate//&
d183 1
a183 1
    modifiedBasis=MAX(logP,basisCutoff) ! Either logP or this threshold
d188 1
a188 1
    DO instance=1,temp%template%noInstances
d190 1
a190 1
    END DO
d193 1
a193 1
    DO surf=2,temp%template%noSurfs
d196 1
a196 1
    END DO
d202 1
a202 1
    CALL Hunt(logP,refLogP,belowRef)
d209 1
a209 1
    aboveRefWeight=MAX(MIN(aboveRefWeight,1.0D0),0.0D0)
d219 1
a219 1
    DO surf=1,temp%template%noSurfs         
d221 1
a221 1
    END DO
d223 1
a223 1
    IF (PRESENT(R)) THEN
d225 3
a227 3
    ELSE
       DEALLOCATE(myR)
    ENDIF
d229 1
a229 1
    IF (PRESENT(art)) THEN
d231 3
a233 3
    ELSE
       DEALLOCATE(myArt)
    ENDIF
d236 1
a236 1
  END SUBROUTINE GetBasisGPH
d245 1
a245 1
  SUBROUTINE GetHydrostaticTangentPressure ( ptan, temp, refGPH, h2o, geocAlt,&
d249 6
a254 6
    TYPE (VectorValue_T), INTENT(INOUT) :: PTAN
    TYPE (VectorValue_T), INTENT(IN) :: TEMP
    TYPE (VectorValue_T), INTENT(IN) :: REFGPH
    TYPE (VectorValue_T), INTENT(IN) :: H2O
    TYPE (VectorValue_T), INTENT(IN) :: GEOCALT
    INTEGER, INTENT(IN), OPTIONAL :: maxIterations ! Number of iterations to use
d258 29
a286 24
    REAL (r8), DIMENSION(:,:), POINTER :: basisGPH=> NULL() ! temp(noSurfs,noInstances)
    REAL (r8), DIMENSION(:,:), POINTER :: art=> NULL() ! art=ln10*R*T

    REAL (r8), DIMENSION(:), POINTER :: artLower=> NULL()
    REAL (r8), DIMENSION(:), POINTER :: basisSpacing=> NULL() ! For temperature
    REAL (r8), DIMENSION(:), POINTER :: cCoeff=> NULL() ! Quadratic term
    REAL (r8), DIMENSION(:), POINTER :: deltaArt=> NULL() 
    REAL (r8), DIMENSION(:), POINTER :: geometricGeopotential=> NULL()
    REAL (r8), DIMENSION(:), POINTER :: n=> NULL() ! Refractive index
    REAL (r8), DIMENSION(:), POINTER :: pointingH2O=> NULL() ! t.p. h2o
    REAL (r8), DIMENSION(:), POINTER :: pointingTemp=> NULL() ! t.p. temp.
    REAL (r8), DIMENSION(:), POINTER :: ratio2=> NULL() ! minor frame
    REAL (r8), DIMENSION(:), POINTER :: ratio4=> NULL() ! minor frame
    REAL (r8), DIMENSION(:), POINTER :: refractedGeocAlt=> NULL() ! minor frame

    INTEGER, DIMENSION(:), POINTER :: closestTempProfiles=> NULL()
    INTEGER, DIMENSION(:), POINTER :: closestH2OProfiles=> NULL()
    INTEGER, DIMENSION(:), POINTER :: lower=>NULL() ! index into temperature profile

    REAL (r8) :: geocLat        ! Geocentric latitude
    REAL (r8) :: s2, s4, p2, p4 ! Polynomial terms

    INTEGER :: myMaxIterations,iteration ! Loop stuff
    INTEGER :: maf              ! Loop counter
a289 7
    ! Set default values

    print*,0

    myMaxIterations=4
    IF (PRESENT(maxIterations)) myMaxIterations=maxIterations

a308 2
    print*,1

d310 1
a310 1
    CALL Allocate_Test(basisGPH,temp%template%noSurfs,temp%template%noInstances,&
d312 19
a330 14

    print*,2
    CALL Allocate_Test(artLower,ptan%template%noSurfs,"artLower",ModuleName)
    CALL Allocate_Test(basisSpacing,ptan%template%noSurfs,"basisSpacing",ModuleName)
    CALL Allocate_Test(cCoeff,ptan%template%noSurfs,"cCoeff",ModuleName)
    CALL Allocate_Test(deltaArt,ptan%template%noSurfs,"deltaArt",ModuleName)
    CALL Allocate_Test(geometricGeopotential,ptan%template%noSurfs, &
         "geometricGeopotential",ModuleName)
    CALL Allocate_Test(n,ptan%template%noSurfs,"n",ModuleName)
    CALL Allocate_Test(pointingH2O,ptan%template%noSurfs,"pointingH2O",ModuleName)
    CALL Allocate_Test(pointingTemp,ptan%template%noSurfs,"pointingTemp",ModuleName)
    CALL Allocate_Test(ratio2,ptan%template%noSurfs,"ratio2",ModuleName)
    CALL Allocate_Test(ratio4,ptan%template%noSurfs,"ratio4",ModuleName)
    CALL Allocate_Test(refractedGeocAlt,ptan%template%noSurfs,"refractedGeocAlt",ModuleName)
d332 1
a332 2
    print*,3
    CALL Allocate_Test(closestTempProfiles,ptan%template%noInstances,&
d334 1
a334 1
    CALL Allocate_Test(closestH2OProfiles,ptan%template%noInstances,&
d336 1
a336 1
    CALL Allocate_Test(lower,ptan%template%noSurfs,"lower",ModuleName)
a337 1
    print*,4
d339 1
a339 1
    CALL GetBasisGPH(temp,refGPH,basisGPH,art=art)
a340 1
    print*,5
d343 6
a348 1
    ptan%values=3.0-(geocAlt%values/16e3-6.37e6) ! Do a better job later !???
d352 2
a353 2
    CALL FindClosestInstances(temp,ptan,closestTempProfiles)
    CALL FindClosestInstances(h2o,ptan,closestH2OProfiles)
a354 1
    print*,6
d358 1
a358 1
    DO maf=1,ptan%template%noInstances
d364 1
a364 1
       geocLat=GeodToGeocLat(temp%template%geodLat(1, &
d366 1
a366 1
       s2=SIN(geocLat)**2
a368 1
       print*,7,maf
d371 1
a371 1
       DO iteration=1,myMaxIterations
a372 1
         print*,8,iteration
d378 28
a405 33
          CALL InterpolateValues( &
               temp%template%surfs(:,1), &
               temp%values(:,closestTempProfiles(maf)), &
               ptan%values(:,maf), &
               pointingTemp,&
               "Linear")
          print*,8.5
          CALL InterpolateValues( &
               h2o%template%surfs(:,1), &
               h2o%values(:,closestH2OProfiles(maf)), &
               ptan%values(:,maf), &
               pointingH2O,&
               "Linear")

          print*,9
          WHERE(geocAlt%values(:,maf) /= geocAlt%template%badValue)

             n=(refrATerm/pointingTemp*(10**ptan%values(:,maf)))*&
                  (1+refrBTerm*pointingH2O/pointingTemp)

             n=MIN(n,maxRefraction) ! Forbid stupidly large values of n             
             ! Now we're going to compute refracted geocentric altitudes
             refractedGeocAlt=geocAlt%values(:,maf)/(1.0+n)

             ! Now convert these to geopotential heights
             ratio2=(earthRadA/refractedGeocAlt)**2
             ratio4=ratio2**2

             geometricGeopotential= -(GM/refractedGeocAlt)*(1-j2*p2*ratio2- &
                  j4*p4*ratio4)- &
                  0.5*((omega*refractedGeocAlt*COS(geocLat))**2)
          ENDWHERE
          print*,10
d410 1
a410 1
          CALL Hunt(temp%template%surfs(:,1), &
d414 19
a432 15
          deltaArt=art(closestTempProfiles(maf),lower+1)-&
               art(closestTempProfiles(maf),lower)
          artLower=art(closestTempProfiles(maf),lower)
          print*,11

          WHERE (geocAlt%values(:,maf) /= geocAlt%template%badValue)
             cCoeff=2*(geometricGeopotential-&
                  basisGPH(closestTempProfiles(maf),lower)) &
                  /basisSpacing
             ptan%values(:,maf)=temp%template%surfs(lower,1)+ &
                  basisSpacing*cCoeff/ &
                  (artLower*SQRT(ABS(artLower**2+deltaArt*cCoeff)))
          ELSEWHERE
             ptan%values(:,maf)=ptan%template%badValue
          END WHERE
a433 4
       END DO                   ! End iteration loop
    END DO                      ! Major frame loop

    print*,12
d435 21
a455 7
    CALL Deallocate_Test(closestTempProfiles,"closestTempProfiles", ModuleName)
    CALL Deallocate_Test(closestH2OProfiles,"closestH2OProfiles", ModuleName)
    CALL Deallocate_Test(pointingTemp,"pointingTemp",ModuleName)
    CALL Deallocate_Test(pointingH2O,"pointingH2O",ModuleName)
    CALL Deallocate_Test(n,"n",ModuleName)
    CALL Deallocate_Test(lower,"lower",ModuleName)
    print*,13
d457 1
a457 1
  END SUBROUTINE GetHydrostaticTangentPressure
d459 1
a459 1
END MODULE ScanModelModule
d462 3
@


2.3
log
@Added RCS log stuff
@
text
@d20 1
d28 1
a28 1
  USE Intrinsic, ONLY: L_H2O, L_TEMPERATURE, L_VMR, L_PTAN, L_TNGTGEODALT, L_TNGTGEOCALT
d30 1
d38 1
a38 1
    & "$Id: ScanModelModule.f90,v 2.2 2001/02/28 17:34:51 livesey Exp $"
d55 1
a55 1
  REAL (r8), PARAMETER :: g0=9.80665D-3 ! Nominal little g
d64 2
a65 2
  REAL (r8), PARAMETER :: gasM0=25.34314957d-3, gasM1=2.896d-3, gasM2=-0.579d-3
  REAL (r8), PARAMETER :: gasR0=8.31432d-6
d101 1
a101 1
  SUBROUTINE GetBasisGPH(state,gph,R,art)
d104 3
a106 2
    TYPE (Vector_T), INTENT(IN) :: state
    REAL (r8), DIMENSION(:,:), POINTER :: gph ! Result (temp%noSurfs,temp%noInstances)
a110 2
    TYPE (VectorValue_T), POINTER :: temp
    TYPE (VectorValue_T), POINTER :: refGPH
d114 2
a115 2
    REAL (r8), DIMENSION(:), POINTER :: myR ! Gas constant, noSurfs
    REAL (r8), DIMENSION(:,:), POINTER :: myArt ! ln10*R*T (noSurfs,noInstances)
a130 5
    ! First we identify the temperature and refGPH quantities in the vector
    ! Note that no return if no such quantity found.
    temp=>GetVectorQuantityByType(state, l_temperature)
    refGPH=>GetVectorQuantityByType(state, l_refGPH)

a144 5
    ! Now allocate a result array
    IF (ASSOCIATED(gph)) CALL Deallocate_test(gph,"GPH in GetBasisGPH",ModuleName)
    CALL Allocate_Test(gph,temp%template%noSurfs,temp%template%noInstances,&
         "GPH in GetBasisGPH",ModuleName)

d184 1
a184 1
    
a220 1

d244 2
a245 2
  SUBROUTINE GetHydrostaticTangentPressure(state,measurements,radiometer,&
       noIterations)
d248 6
a253 4
    TYPE (Vector_T), INTENT(INOUT) :: state ! Contains temp, refGPH and ptan
    TYPE (Vector_T), INTENT(IN) :: measurements ! Contains l1 altitudes
    INTEGER, INTENT(IN) :: radiometer ! L_THz or L_GHZ
    INTEGER, INTENT(IN), OPTIONAL :: noIterations ! Number of iterations to use
d256 19
a274 25
    TYPE (VectorValue_T), POINTER :: geodAlt
    TYPE (VectorValue_T), POINTER :: geocAlt
    TYPE (VectorValue_T), POINTER :: temp
    TYPE (VectorValue_T), POINTER :: refGPH
    TYPE (VectorValue_T), POINTER :: h2o
    TYPE (VectorValue_T), POINTER :: ptan

    REAL (r8), DIMENSION(:,:), POINTER :: basisGPH ! temp(noSurfs,noInstances)
    REAL (r8), DIMENSION(:,:), POINTER :: art ! art=ln10*R*T

    REAL (r8), DIMENSION(:), POINTER :: artLower
    REAL (r8), DIMENSION(:), POINTER :: basisSpacing ! For temperature
    REAL (r8), DIMENSION(:), POINTER :: cCoeff ! Quadratic term
    REAL (r8), DIMENSION(:), POINTER :: deltaArt 
    REAL (r8), DIMENSION(:), POINTER :: geometricGeopotential
    REAL (r8), DIMENSION(:), POINTER :: n ! Refractive index
    REAL (r8), DIMENSION(:), POINTER :: pointingH2O ! t.p. h2o
    REAL (r8), DIMENSION(:), POINTER :: pointingTemp ! t.p. temp.
    REAL (r8), DIMENSION(:), POINTER :: ratio2 ! minor frame
    REAL (r8), DIMENSION(:), POINTER :: ratio4 ! minor frame
    REAL (r8), DIMENSION(:), POINTER :: refractedGeocAlt ! minor frame

    INTEGER, DIMENSION(:), POINTER :: closestTempProfiles
    INTEGER, DIMENSION(:), POINTER :: closestH2OProfiles
    INTEGER, DIMENSION(:), POINTER :: lower ! index into temperature profile
d279 1
a279 1
    INTEGER :: myNoIterations,iteration ! Loop stuff
d286 1
a286 2
    myNoIterations=4
    IF (PRESENT(noIterations)) myNoIterations=noIterations
d288 2
a289 10
    ! The first stage is to identify the vector quantities involved.
    geodAlt=> GetVectorQuantityByType(state, l_tngtGeodAlt, &
         radiometer=radiometer)
    geocAlt=> GetVectorQuantityByType(state, l_tngtGeocAlt, &
         radiometer=radiometer)
    temp=> GetVectorQuantityByType(state, l_temperature)
    refGPH=> GetVectorQuantityByType(state, l_refGPH)
    h2o=> GetVectorQuantityByType(state, l_vmr, molecule=l_h2o)
    ptan=> GetVectorQuantityByType(state, l_ptan, radiometer= &
         radiometer)
d310 1
a310 5
    if ( ( .not. ValidateVectorQuantity( geodAlt, minorFrame=.true.) ) .or. &
      &  ( .not. ValidateVectorQuantity( geocAlt, minorFrame=.true.) ) .or. &
      &  ( .not. ValidateVectorQuantity( ptan,    minorFrame=.true.) ) ) &
      & call MLSMessage(MLSMSG_Error,ModuleName, &
      &   'Inapporpriate geodAlt/geocAlt/ptan quantity' )
d313 4
d330 1
d337 1
d339 1
a339 1
    CALL GetBasisGPH(state,basisGPH,art=art)
d341 1
d344 1
a344 1
    ptan%values=3.0-geodAlt%values/16e3
d351 1
d366 1
d369 1
a369 1
       DO iteration=1,myNoIterations
d371 1
d383 1
d391 1
d409 1
d421 1
d437 1
d445 1
d451 4
a454 1
! $Log$
@


2.2
log
@Modified to use zeta rather than pressure as vertical coordinate.
@
text
@d36 1
a36 1
    & "$Id: ScanModelModule.f90,v 2.1 2001/02/22 00:37:50 livesey Exp $"
d462 1
a462 8








@


2.1
log
@First version
@
text
@d22 3
a24 2
  USE VectorsModule, ONLY : Vector_T, VectorValue_T, GetVectorQuantityByType
  USE Init_Tables_Module, ONLY: L_Temperature, L_RefGPH
d36 1
a36 1
    & "$Id: VectorsModule.f90,v 2.8 2001/01/19 23:49:59 vsnyder Exp $"
d38 1
a38 1
    & "$RCSfile: VectorsModule.f90,v $"
d135 14
d188 1
a188 1
    logP= -LOG10(temp%template%surfs(:,1))
d314 24
a337 2
    ! Note, we're making an assumption that ptan and geod/geocAlt conform
    ! completely.
d395 1
a395 1
               -LOG10(temp%template%surfs(:,1)), &
d401 1
a401 1
               -LOG10(h2o%template%surfs(:,1)), &
d428 1
a428 1
          CALL Hunt(-LOG10(temp%template%surfs(:,1)), &
d430 2
a431 2
          basisSpacing= -LOG10(temp%template%surfs(lower,1)/ &
               temp%template%surfs(lower+1,1))
d440 1
a440 1
             ptan%values(:,maf)=-LOG10(temp%template%surfs(lower,1))+ &
@

