head	2.128;
access;
symbols
	v5-02-NRT-19:2.128
	v6-00:2.128
	v5-02-NRT-18:2.128
	v5-02:2.128
	v5-01-NRT-17:2.128
	v5-01-NRT-16:2.128
	v5-01-NRT-15:2.128
	v5-01-NRT-14:2.128
	neuralnetworks-1-0:2.128.0.6
	cfm-single-freq-0-1:2.128.0.4
	v5-01:2.128
	v5-00:2.128
	v4-23-TA133:2.128.0.2
	mus-emls-1-70:2.125.0.4
	rel-1-0-englocks-work:2.125.0.2
	VUMLS1-00:2.119
	VPL1-00:2.115
	V4-22-NRT-08:2.114
	VAM1-00:2.112
	V4-21:2.109.0.2
	V4-13:2.109
	V4-12:2.106
	V4-11:2.106
	V4-10:2.105
	V3-43:2.91
	M4-00:2.96
	V3-41:2.91
	V3-40-PlusGM57:2.91.0.2
	V2-24-NRT-04:2.73
	V3-33:2.83
	V2-24:2.73
	V3-31:2.83
	V3-30-NRT-05:2.82
	cfm-01-00:2.82
	V3-30:2.82
	V3-20:2.82
	V3-10:2.77
	V2-23-NRT-02:2.73
	V2-23:2.73
	V2-22-NRT-01:2.73
	V2-22:2.73
	V2-21:2.68
	V2-20:2.68
	V2-11:2.68
	V2-10:2.68
	V2-00:2.68
	V1-51:2.57
	V1-50:2.57
	V1-45:2.56
	V1-44:2.56
	V1-43:2.56
	V1-32:2.54
	V1-31:2.53
	V1-30:2.52
	V1-13:2.43
	V1-12:2.43
	V1-11:2.43
	V1-10:2.39
	newfwm-feb03:2.39.0.2
	V1-04:2.35
	V1-03:2.35
	V1-02:2.35
	JointForwardModel:2.35.0.2
	V1-00:2.34
	newfwm-sep01:2.20.0.2
	V0-7:2.20
	V0-5-Level2:2.18
	V0-5-SIPS:2.17;
locks; strict;
comment	@# @;


2.128
date	2019.01.31.19.49.58;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2018.11.01.23.18.13;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2018.07.27.23.19.53;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2018.03.22.18.14.28;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2018.03.14.22.42.40;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2017.11.15.00.11.24;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2017.08.08.20.46.28;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2017.07.10.23.04.52;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2017.03.17.00.13.43;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2017.03.07.21.21.01;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2017.01.13.01.31.40;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2016.09.30.20.33.46;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2016.09.21.00.41.04;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2016.07.28.01.45.07;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2016.04.01.00.27.15;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2015.11.17.21.28.07;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2015.08.03.21.43.50;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2015.05.07.20.16.50;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2015.05.05.18.15.47;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2014.10.07.00.08.45;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2014.10.02.17.24.00;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2014.09.05.01.27.33;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2014.06.04.18.34.37;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2014.04.02.23.05.11;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2014.01.11.01.52.15;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2013.10.09.23.43.41;	author vsnyder;	state Exp;
branches;
next	2.99;

2.99
date	2013.09.24.23.47.23;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2013.08.30.02.45.51;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2013.02.12.18.13.01;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2012.08.16.17.50.42;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2012.05.08.17.50.31;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2012.03.12.17.31.59;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2012.02.24.21.16.06;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2011.08.03.21.59.39;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2011.07.13.14.24.46;	author honghanh;	state Exp;
branches;
next	2.89;

2.89
date	2011.07.12.22.35.03;	author honghanh;	state Exp;
branches;
next	2.88;

2.88
date	2011.06.16.23.16.27;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2011.05.26.20.45.15;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2011.05.05.17.02.34;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2011.04.27.17.39.56;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2011.04.20.16.54.28;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2010.11.09.02.37.28;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2010.02.04.23.12.44;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2009.10.26.17.11.07;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2009.09.10.23.03.41;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2009.08.26.16.48.17;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2009.08.24.20.25.28;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2008.12.02.23.12.47;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2008.09.17.23.20.13;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2007.10.24.00.16.59;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2007.08.17.00.35.30;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2007.06.21.00.54.08;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2007.03.02.18.14.02;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2007.01.30.21.59.10;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2007.01.11.20.48.30;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2006.06.13.20.56.43;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2006.06.13.18.19.08;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2006.06.06.21.56.52;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2006.04.10.23.45.18;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2006.02.10.21.15.55;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2006.01.26.00.35.35;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2005.09.28.17.02.04;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2005.08.05.20.39.07;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2005.07.12.17.34.57;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2005.06.14.20.40.27;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2004.09.23.23.03.14;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2004.06.28.20.25.54;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2004.06.23.17.13.34;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2004.01.23.01.10.58;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2003.10.06.13.16.09;	author cvuu;	state Exp;
branches;
next	2.52;

2.52
date	2003.06.09.22.49.34;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2003.05.29.17.54.28;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2003.05.09.23.26.45;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2003.05.06.00.16.32;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2003.05.05.23.00.34;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2003.04.17.23.08.29;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2003.04.04.18.35.11;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2003.04.02.23.54.53;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2003.04.01.21.44.38;	author dwu;	state Exp;
branches;
next	2.43;

2.43
date	2003.03.01.00.24.27;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2003.02.27.18.41.40;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2003.02.20.21.26.21;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2003.02.19.19.16.21;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2003.01.18.02.37.34;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2002.12.10.00.40.27;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2002.12.06.01.06.56;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2002.10.08.17.36.22;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2002.04.06.00.11.18;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2002.01.29.23.49.38;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2002.01.26.00.10.45;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2002.01.23.23.09.46;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2002.01.23.22.35.47;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2002.01.18.19.01.34;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2002.01.18.18.50.08;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2002.01.18.00.55.30;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2002.01.09.00.00.04;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2001.10.30.00.35.27;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2001.10.26.23.20.10;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2001.10.08.21.35.43;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2001.09.28.23.59.20;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2001.09.10.23.37.44;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.05.12.00.20.00;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.05.07.18.03.56;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2001.05.03.20.34.08;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.16.23.50.01;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.12.22.19.33;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.10.20.04.26;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.03.30.00.27.38;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2001.03.29.19.13.41;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.03.21.00.46.08;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.03.15.21.38.00;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.03.15.21.25.16;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.15.21.18.57;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.15.00.34.34;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.14.19.06.08;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.14.18.54.38;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.08.01.08.08;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.07.22.41.44;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.03.07.01.04.33;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.03.06.00.23.58;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2001.03.03.00.14.40;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.128
log
@Improved verbose Dumps
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module ReadAPriori

  use Expr_M, only: Expr
  use HDF, only: Dfacc_Rdonly
  use HighOutput, only: Dump, OutputNamedValue
  use Init_Tables_Module, only: F_AuraInstrument, &
    & F_Date, F_Dimlist, F_Downsample, &
    & F_Field, F_File, F_Grid, F_HDFVersion, F_MissingValue, F_NoPCFid, &
    & F_Origin, F_Quantitytype, F_Sdname, F_DeferReading, F_Sum, F_Swath, &
    & Field_First, Field_Last, &
    & L_Climatology, L_Dao, L_Geos5, L_Geos5_7, L_Gloria, &
    & L_Merra, L_Merra_2, L_Ncep, L_None, L_Strat, L_Surfaceheight, &
    & S_ChangeSettings, S_Diff, S_Dump, S_Execute, S_Gridded, &
    & S_IsFileAbsent, S_L2aux, S_L2gp, S_ReadGriddedData
  use Intrinsic, only: L_Ascii, L_Binary, L_HDFeos, L_HDF, L_Swath, &
    & Phyq_Dimensionless
  use L2GPData, only: MaxSwathNamesBufSize
  use Lexer_Core, only: Print_Source
  use MLSCommon, only: Filenamelen, MLSFile_T
  use MLSFiles, only: Filenotfound, &
    & HDFVersion_4, HDFVersion_5, WildCardHDFVersion, &
    & AddFileToDatabase, MLS_CloseFile, Dump, GetPCFromRef, InitializeMLSFile, &
    & MLS_HDF_Version, MLS_Inqswath, MLS_OpenFile, Split_Path_Name
  use MLSL2Options, only: CheckPaths, Default_HDFVersion_Read, L2CFNode, &
    & RuntimeValues, SpecialDumpFile, Toolkit, &
    & DumpMacros, MLSL2Message
  use MLSL2Timings, only: AddPhaseToPhaseNames
  use MLSMessageModule, only: MLSMsg_Error, MLSMsg_Warning
  use MLSPCF2, only: &
    & MLSPCF_L2apriori_Start, MLSPCF_L2apriori_End, &
    & MLSPCF_L2clim_Start, MLSPCF_L2clim_End, &
    & MLSPCF_L2dao_Start, MLSPCF_L2dao_End, &
    & MLSPCF_L2geos5_Start, MLSPCF_L2geos5_End, &
    & MLSPCF_L2ncep_Start, MLSPCF_L2ncep_End, &
    & MLSPCF_Surfaceheight_Start, MLSPCF_Surfaceheight_End
  use MLSStringLists, only: CatLists, GetHashElement, SwitchDetail
  use MLSStrings, only: Lowercase
  use MoreTree, only: Get_Boolean
  use Output_M, only: Output, RevertOutput, SwitchOutput
  use PCFHdr, only: GlobalAttributes
  use SDPToolkit, only: Pgs_S_Success
  use String_Table, only: Get_String
  use Toggles, only: Gen, Switches, Toggle
  use Tree, only: Decorate, Decoration, Nsons, &
    & Sub_Rosa, Subtree, Dump_Tree_Node, Where

  implicit none
  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: read_apriori.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (data types)
! APrioriFiles_T              data type storing names of apriori files used
! APrioriFiles                actual names of apriori files used

!     (subroutines and functions)
! DumpAPrioriAttributes       dump types and names of apriori files used
! ProcessOneAprioriFile       read one apriori file into a gridded data type
! ProcessOneL2AUXFile         read one l2aux file into a gridded data type
! ProcessOneL2GPFile          read one l2gp file into a gridded data type
! Read_apriori                entry point for apriori section; process l2cf
! ReadAPrioriAttributes       read attributes from a file to which they were written
! WriteAPrioriAttributes      write as attributes info about apriori files used
! === (end of toc) ===



  public ::  aprioriFiles, AprioriFiles_t, &
    & DumpAPrioriAttributes, ProcessOneAPrioriFile, &
    & ProcessOneL2AUXFile, ProcessOneL2GPFile, &
    & Read_apriori, ReadAPrioriAttributes, &
    & WriteAPrioriAttributes
  private ::  announce_error
  logical, parameter :: countEmpty = .true. ! Except where overriden locally
  integer, private :: ERROR
  integer, private, parameter :: MAXNUMFILES = 20

   ! What a priori files did we read? 
   ! (This is very wasteful of memory--can we change it
   ! so that just one field is needed/)
  type APrioriFiles_T
    character (len=MAXNUMFILES*FileNameLen) :: l2gp =  ''
    character (len=MAXNUMFILES*FileNameLen) :: l2aux = ''
    character (len=MAXNUMFILES*FileNameLen) :: ncep =  ''
    character (len=MAXNUMFILES*FileNameLen) :: dao =   ''
    character (len=MAXNUMFILES*FileNameLen) :: geos5 = ''
    character (len=MAXNUMFILES*16) :: geos5description =  ''
  end type APrioriFiles_T

  type (APrioriFiles_T), save :: APrioriFiles

  interface readAPrioriAttributes
    module procedure readAPrioriAttributes_id
    module procedure readAPrioriAttributes_mf
  end interface
  
  interface writeAPrioriAttributes
    module procedure writeAPrioriAttributes_id
    module procedure writeAPrioriAttributes_mf
  end interface
  
  ! -----     Private declarations     ---------------------------------

contains ! =====     Public Procedures     =============================

  ! ------------------------------------------  dumpAPrioriAttributes  -----
  subroutine dumpAPrioriAttributes
    ! dump info about what apriori files were used
    ! Storing them as hdfeos5 attributes
    use Dump_1, only: Dump
    ! Executable
    call output( 'Actual apriori files and file types used', advance='yes' )
    if ( len_trim(APrioriFiles%l2gp) > 0 )&
      & call dump( APrioriFiles%l2gp, 'l2gp' )
    if ( len_trim(APrioriFiles%l2aux) > 0 )&
      & call dump( APrioriFiles%l2aux, 'l2aux' )
    if ( len_trim(APrioriFiles%ncep) > 0 )&
      & call dump( APrioriFiles%ncep, 'ncep' )
    if ( len_trim(APrioriFiles%dao) > 0 )&
      & call dump( APrioriFiles%dao, 'dao' )
    if ( len_trim(APrioriFiles%geos5) > 0 )&
      & call dump( APrioriFiles%geos5, 'geos5' )
  end subroutine dumpAPrioriAttributes

  ! --------------------------------------------------  read_apriori  -----
  ! Read a priori data from data files, be they l2gp, l2aux, climatology,
  ! NCEP, DAO etc.

  subroutine Read_apriori ( Root, L2GPDatabase, L2auxDatabase, GriddedDatabase, &
    & fileDataBase )
    use DumpCommand_M, only: BooleanFromEmptySwath, BooleanFromFormula, &
      & ExecuteCommand, MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, Skip
    use GriddedData, only: GriddedData_T, Dump
    use Init_Tables_Module, only: S_Boolean, S_Case, S_Endselect, &
      & S_Select, S_Skip
    use L2AUXData, only: L2AUXData_T, Dump
    use L2GPData, only: L2GPData_T, Dump
    use MLSL2Timings, only: Section_Times
    use MoreTree, only: Get_Label_And_Spec, Get_Spec_Id
    use Next_Tree_Node_M, only: Next_Tree_Node, Next_Tree_Node_State
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decorate
    ! Dummy arguments
    integer, intent(in) :: ROOT    ! Of the Read a priori section in the AST
    type (l2gpdata_t), dimension(:), pointer :: L2GPDatabase
    type (L2AUXData_T), dimension(:), pointer :: L2auxDatabase
    type (GriddedData_T), dimension(:), pointer :: GriddedDatabase 
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    ! Local variables
    logical :: carryover
    character(len=32) :: cvalue
    integer :: Details             ! How much info about the files to dump
    integer :: KEY
    integer, save :: LastAprioriPCF      ! l2gp or l2aux  apriori
    integer, save :: LastClimPCF         ! l3ascii or gloria format
    integer, save :: LastDAOPCF
    integer, save :: LastGEOS5PCF
    integer, save :: LastHeightPCF
    integer, save :: LastNCEPPCF
    integer :: Me = -1             ! String index for trace
    integer :: NAME                ! Index into string table
    integer :: SON                 ! Of root, an n_spec_args or a n_named
    type(next_tree_node_state) :: State ! of tree traverser
    logical :: verbose
    logical :: verboser

    call trace_begin ( me, "read_apriori", root, cond=toggle(gen) )

    error = 0

    ! Will we be dumping info? To what level of detail?
    Details = switchDetail(switches, 'apr') - 2
    verbose = ( Details > -3 )
    verboser = ( Details > -2 )
    if ( verbose ) &     
    & call output ( '============ Read APriori ============', advance='yes' )  
    ! Are we picking up again where we left off in the last
    ! readAPriori section?
    ! We'll have to pre-process any Booleans in this section to see
    do 
      son = next_tree_node ( root, state )
      if ( son == 0 ) exit
      call get_label_and_spec ( son, name, key )
      L2CFNODE= key
      select case( get_spec_id(key) )
      case ( s_Boolean )
        call decorate ( key,  BooleanFromFormula ( name, key ) )
      end select
    enddo
    call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'carryover', cvalue, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    carryover = ( index(lowercase(cvalue), 't') > 0 )
    if ( verbose ) call dumpMacros
    if ( verboser ) call outputNamedValue( 'carryover', carryover )
    if ( .not. carryover ) then
      LastAprioriPCF = mlspcf_l2apriori_start - 1
      lastClimPCF = mlspcf_l2clim_start - 1
      lastDAOPCF = mlspcf_l2dao_start - 1
      lastNCEPPCF = mlspcf_l2ncep_start - 1
      lastGEOS5PCF = mlspcf_l2geos5_start - 1
      LastHeightPCF = mlspcf_surfaceHeight_start - 1
    end if
    if ( verboser ) call outputNamedValue ( 'mlspcf_l2geos5_start', mlspcf_l2geos5_start )
    if ( verboser ) call outputNamedValue ( 'lastGEOS5PCF', lastGEOS5PCF )
    if ( verboser ) call outputNamedValue ( 'LastClimPCF', LastClimPCF )
    if ( verboser ) call outputNamedValue ( 'carryOver', carryOver )

    do 
      son = next_tree_node ( root, state )
      if ( son == 0 ) exit
      call get_label_and_spec ( son, name, key )
      L2CFNODE= key
      if ( MLSSelecting .and. &
        & .not. any( get_spec_id(key) == (/ s_endselect, s_select, s_case /) ) ) cycle
      select case( get_spec_id(key) )
      case ( s_Boolean )
        call decorate ( key,  BooleanFromFormula ( name, key ) )
      case ( s_changeSettings ) ! ===============================  changeSettings ==
        ! Change settings for this phase
        call addPhaseToPhaseNames ( 0, key )
      case ( s_isFileAbsent )
        call decorate ( key, BooleanFromEmptySwath ( key ) )
      case ( s_select ) ! ============ Start of select .. case ==========
        ! We'll start seeking a matching case
        call MLSSelect (key)
      case ( s_case ) ! ============ seeking matching case ==========
        ! We'll continue seeking a match unless the case is TRUE
        call MLSCase (key)
      case ( s_endSelect ) ! ============ End of select .. case ==========
        ! We'done with seeking a match
        call MLSEndSelect (key)
      case ( s_execute ) ! ======================== ExecuteCommand ==========
        call ExecuteCommand ( key )
      case ( s_skip ) ! ============================== Skip ==========
        ! We'll skip the rest of the section if the Boolean cond'n is TRUE
        if ( Skip(key) ) exit
      case default
        call processOneAprioriFile ( son, L2GPDatabase, L2auxDatabase, &
          & GriddedDatabase, fileDataBase, &
          & LastAprioriPCF , &
          & LastClimPCF    , &
          & LastDAOPCF     , &
          & LastGEOS5PCF   , &
          & LastHeightPCF  , &
          & LastNCEPPCF     &
            )
      end select
    end do                              ! Lines in l2cf loop
    if( verboser ) then
      call output( '------------------- apriori datatypes --------------', advance='yes' )
      call output ( 'l2gp', advance='yes' )
      call dump( trim(APrioriFiles%l2gp), 'l2gp files' )
      call output ( 'l2aux', advance='yes' )
      call dump( trim(APrioriFiles%l2aux), 'l2aux files' )
      call output ( 'ncep', advance='yes' )
      call dump( trim(APrioriFiles%ncep), 'ncep files' )
      call output ( 'dao', advance='yes' )
      call dump( trim(APrioriFiles%dao), 'dao files' )
      call output ( 'geos5', advance='yes' )
      call dump( trim(APrioriFiles%geos5), 'geos5 files' )
    end if
    if ( ERROR/=0 ) then
      call MLSL2Message ( MLSMSG_Error,ModuleName, &
        & 'Problem with read_apriori section' )
    end if

    call trace_end( "read_apriori", cond=section_times .or. toggle(gen) )

  end subroutine read_apriori
  
  subroutine processOneAprioriFile ( Root, L2GPDatabase, L2auxDatabase, &
    & GriddedDatabase, fileDataBase, &
    & LastAprioriPCF , &
    & LastClimPCF    , &
    & LastDAOPCF     , &
    & LastGEOS5PCF   , &
    & LastHeightPCF  , &
    & LastNCEPPCF     &
      )
    use ChunkDivide_M, only: ChunkDivideConfig
    use Dumpcommand_M, only: Dumpcommand
    use GriddedData, only: Rgr, GriddedData_T, V_Is_Eta, V_Is_Pressure, &
      & AddGriddedDataToDatabase, CopyGrid, &
      & DestroyGriddedData, DownSampleGriddedData, Dump, &
      & SetupnewgriddedData
    use L2AUXData, only: L2AUXData_T, AddL2AUXtoDatabase, &
      & Dump
    use L2GPData, only: L2GPData_T, &
      & Addl2GPtoDatabase, Dump
    use Moretree, only: Get_Label_And_Spec, Get_Spec_Id
    use Ncep_Dao, only: ReadgriddedData
    use ReadgriddedUtils, only: Read_Climatology, ReadgloriaFile
    use Surfaceheight_M, only: Open_Surface_Height_File, &
      & Read_Surface_Height_File, Close_Surface_Height_File
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End

    ! Dummy arguments
    integer, intent(in) :: ROOT    ! Of the Read a priori section in the AST
    type (l2gpdata_t), dimension(:), pointer :: L2GPDatabase
    type (L2AUXData_T), dimension(:), pointer :: L2auxDatabase
    type (GriddedData_T), dimension(:), pointer :: GriddedDatabase 
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    integer :: LastAprioriPCF      ! l2gp or l2aux  apriori
    integer :: LastClimPCF         ! l3ascii or gloria format
    integer :: LastDAOPCF
    integer :: LastGEOS5PCF
    integer :: LastHeightPCF
    integer :: LastNCEPPCF
    ! Local Variables
    integer :: AURAINST             ! index of 'MLS' in AuraInstrument='MLS'
    integer :: DATE             ! in case using GMAO backgr
    character(len=FileNameLen) :: DATESTRING ! 'X,Y,..'
    logical :: DEBUG
    logical :: deferReading      ! skip reading the data; just note file name?
    character(len=8) :: description
    integer :: Details             ! How much info about the files to dump
    integer :: DIMLIST             ! index of 'X,Y,..' in dimList='X,Y,..'
    character(len=FileNameLen) :: DIMLISTSTRING ! 'X,Y,..'
    logical :: DOWNSAMPLE          ! Downsample gridded data to coarser mesh
    integer :: EXPR_UNITS(2)            ! Output from Expr subroutine
    double precision :: EXPR_VALUE(2)   ! Output from Expr subroutine
    integer :: FIELD               ! Son of KEY, must be n_assign
    integer :: FIELDINDEX          ! Literal
    integer :: FieldName           ! sub-rosa index of name in field='name'
    character(len=FileNameLen) :: FIELDNAMESTRING ! actual literal clim. field
    integer :: FileIndex
    integer :: FileName            ! Sub-rosa index of name in file='name'
    character(len=FileNameLen) :: FileNameString   ! actual literal file name
    integer :: FileType            ! s_gridded, s_l2gp, s_l2aux, ..
    logical :: GotAlready               ! Do we need to reread this file?
    type (GriddedData_T), pointer :: Grid     => null()
    type (GriddedData_T), target  :: tempGrid
    type (MLSFile_T) :: GriddedFile
    integer :: GriddedOrigin            ! From tree
    integer :: GridIndex           ! In the griddeddata database
    logical, dimension(field_first:field_last) :: GOT
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    character :: HMOT              ! 'H', 'M', 'O', or 'T'
    integer :: L2apriori_version
    integer :: J                   ! Loop indices for section, spec
    integer :: KEY                 ! Index of n_spec_args in the AST
    type (L2AUXData_T) :: L2AUX
    type (MLSFile_T) :: L2AUXFile
    type (L2GPData_T) :: L2GP
    type (MLSFile_T) :: L2GPFile
    integer :: L2Index             ! In the l2gp or l2aux database
    integer :: L2Name              ! Sub-rosa index of L2[aux/gp] label
!     integer :: lastAPrioriVersion
    character(len=16) :: litDescription
    integer :: Me = -1             ! String index for trace
    real(rgr) ::    missingValue = 0.
    logical :: noPCFid
    character(len=FileNameLen) :: path   ! path of actual literal file name
    integer :: QUANTITYTYPE             ! Lit index of quantity type
    integer :: ReturnStatus
    integer :: SdName        ! sub-rosa index of name in sdName='name'
    character(len=FileNameLen) :: SDNAMESTRING ! actual literal sdName
    character(len=FileNameLen) :: ShortFileName
    integer :: SON              ! Of root, an n_spec_args or a n_named
    character(len=FileNameLen) :: subString   ! file name w/o path
    logical :: sumDelp          ! sum up the DELP field values to get PL?
    integer :: SwathName        ! sub-rosa index of name in swath='name'
    character(len=FileNameLen) :: SWATHNAMESTRING ! actual literal swath name
    integer :: Type                     ! Type of value returned by EXPR
    integer :: Units(2)                 ! Units of value returned by EXPR
    double precision :: Value(2)        ! Value returned by EXPR
    integer :: v_type                   ! E.g., v_is_eta
    logical :: verbose

    ! Executable
    call trace_begin ( me, "processOneAprioriFile", root, &
      & cond=toggle(gen) .and. levels(gen) > 0 )

    nullify(grid)
    hdfVersion = DEFAULT_HDFVERSION_READ
    HMOT = ' '
    L2apriori_version = 1
    got = .false.
    son = root ! Because first argument of get_label_and_spec is inout
               ! (and it's needed later anyway)
    call get_label_and_spec ( son, l2Name, key )

    ! Node_id(key) is now n_spec_args.

    FileType = get_spec_id(key)

    if ( any( fileType == (/s_diff, s_dump/) ) ) then
      if ( .not. CHECKPATHS ) &
        & call dumpCommand ( key, griddedDataBase=griddedDataBase, &
        & FileDatabase=FileDatabase )
      go to 9
    end if

    ! Now parse file and field names
    Details = switchDetail(switches, 'apr') - 2
    Debug   = ( Details > -2 )
    verbose = ( Details > -3 )
    downsample = .false.
    deferReading = .false.
    noPCFid = .false.
    sumDelp = .false.
    fileName = 0
    gridIndex = 0
    griddedOrigin = l_none
    swathName = 0
    do j = 2, nsons(key)
      field = subtree(j,key)
      L2CFNODE = field
      fieldIndex = decoration(subtree(1,field))
      got(fieldIndex) = .true.
      select case ( fieldIndex )
      case ( f_AuraInstrument )
        AuraInst = sub_rosa(subtree(2,field))
      case ( f_date )
        date = sub_rosa(subtree(2,field))
      case ( f_deferReading )
        deferReading = get_boolean(field)
      case ( f_dimList )
        dimList = sub_rosa(subtree(2,field))
      case ( f_downsample )
        downsample = get_boolean(field)
      case ( f_field )
        fieldName = sub_rosa(subtree(2,field))
      case ( f_file )
        fileName = sub_rosa(subtree(2,field))
      case ( f_grid )
        gridIndex = decoration ( decoration ( subtree(2, field) ) )
      case ( f_missingValue )
        call expr ( subtree(2,field), expr_units, expr_value )
        missingValue = expr_value(1)
      case ( f_hdfVersion ) ! hdfVersion is never used
        call expr ( subtree(2,field), units, value, type )             
        if ( units(1) /= phyq_dimensionless ) &                        
          & call Announce_error ( field, &                               
            & 'No units allowed for hdfVersion: just integer 4 or 5')  
        hdfVersion = value(1)
        call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'HdfVersion is never used by the ReadAPriori command' )
      case ( f_noPCFid )
        noPCFid = get_boolean(field)
      case ( f_origin )
        griddedOrigin = decoration(subtree(2,field))
      case ( f_quantityType )
        quantityType = decoration(subtree(2,field))
      case ( f_sum )
        sumDelp = get_boolean(field)
      case ( f_swath )
        swathName = sub_rosa(subtree(2,field))
      case ( f_sdname )
        sdname = sub_rosa(subtree(2,field))
      end select
    end do

    if ( got(f_dimList) ) then
      call get_string ( dimList, dimListString, strip=.true. )
    else
      dimListString = ''
    end if

    if ( got(f_date) ) then
      call get_string ( date, dateString, strip=.true. )
    else
      dateString = ''
    end if

    if ( got(f_AuraInstrument) ) then
      call get_string ( AuraInst, HMOT, strip=.true. )
    end if

    if ( got(f_file) ) then
      call get_string ( FileName, fileNameString, strip=.true. )
    else
      fileNameString = ''
    end if
    shortFileName = fileNameString
    
    ! So, grid is associated only if the command held a grid field, e.g.
    ! readGriddedData, grid=gmaoTemperatureInput5, origin=...
    ! and not a mere declaration like
    ! gmaoTemperatureInput5: gridded, origin=none
    if ( got(f_grid) ) grid => griddedDataBase(gridIndex)

    if ( FileType == s_readGriddedData ) then
      if ( grid%fileType > 0 ) then
        FileType = grid%fileType
      else
        FileType = s_gridded
      end if
    end if

    select case ( FileType )
    case ( s_l2gp )
      if ( .not. got(f_file) ) &
        & call announce_error ( son, &
          & 'Filename name must be specified in read a priori' )
      swathNameString=''
      if ( got(f_swath) ) &
        & call get_string ( swathName, swathNameString, strip=.true. )
      call processOneL2GPFile ( FileNameString, swathNameString, &
        & noPCFid, mlspcf_l2apriori_start, mlspcf_l2apriori_end, &
        & LastAprioriPCF, HMOT, Debug, &
        & L2GP, L2GPFile )
      FileIndex = AddFileToDataBase( filedatabase, L2GPFile )

      if( Debug ) then
        if ( specialDumpFile /= ' ' ) &
          & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
        call dump( l2gp, details=details )
        if ( specialDumpFile /= ' ' ) &
          & call revertOutput
      end if

      if( switchDetail(switches, 'pro') > -1 ) then                            
         call announce_success( FilenameString, 'l2gp', &                    
         & swathNameString, MLSFile=L2GPFile )    
      end if
      apriorifiles%l2gp = catlists(apriorifiles%l2gp, trim(FilenameString))

      ! Add this l2gp to the database, decorate this key with index
      call decorate ( key, AddL2GPToDatabase( L2GPDatabase, l2gp ) )
      ! Don't call destroy contents as the AddL2GPToDatabase has done a shallow
      ! copy.
      ! l2gp files in our database means               
      ! change default behavior so that we won't allow 
      ! overlaps outside the processing range)         
      call output( '(Resetting defaults to exclude overlaps outside '&
        & // 'processingRange', advance='yes' )
      ChunkDivideConfig%allowPriorOverlaps = .false.
      ChunkDivideConfig%allowPostOverlaps = .false.

    case ( s_l2aux )

      if ( .not. all(got((/f_sdName, f_file, f_quantityType /)))) &
        & call announce_error ( son, &
          & 'file/sd name must both be specified in read a priori' )
      call get_string ( sdName, sdNameString )
      sdNameString = sdNameString(2:LEN_TRIM(sdNameString)-1)


      l2aux%name = l2Name

      l2Index = AddL2AUXToDatabase( L2AUXDatabase, l2aux )
      call processOneL2AUXFile ( FileNameString, sdNameString, &
        & noPCFid, quantityType, &
        & LastAprioriPCF, Debug, &
        & L2AUXDatabase(l2Index), L2AUXFile, fileDatabase )

      call decorate ( key, l2Index )
      ! if( switchDetail(switches, 'apr') > -1 ) then
      if( Debug ) then
        if ( specialDumpFile /= ' ' ) &
          & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
        call dump( L2AUXDatabase(l2Index), details )
        if ( specialDumpFile /= ' ' ) &
          & call revertOutput
      end if

      if( switchDetail(switches, 'pro') > -1 ) then                            
         call announce_success(FilenameString, 'l2aux', &                    
         & sdNameString, MLSFile=L2AUXFile)    
      end if
      apriorifiles%l2aux = catlists(apriorifiles%l2aux, trim(FilenameString))

    case ( s_gridded )

      ! So we can declare a gridded data name to be used later
      if ( griddedOrigin == l_none ) then
        fieldNameString = 'none'
      else if ( .not. all(got((/f_origin, f_field/))) ) then
        call announce_error ( son, 'Incomplete gridded data information' )
      else
        call get_string ( fieldName, fieldNameString, strip=.true. )
      end if

      select case ( griddedOrigin )
      case ( l_none ) ! ----------- Just a declaration to use later
        ! Should not have come here with readGriddedData command
        if ( associated(grid) ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'origin should be sensible for readGriddeddata, "none" is not' )
        description = 'none'
        ! The gridded data needs to part of the database, even if the file
        ! won't be found and the gridded data empty,
        ! so it can be operated on w/o segment faulting
        gridIndex = AddGriddedDataToDatabase( GriddedDatabase, tempGrid )
        call decorate ( key, gridIndex )
        call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
        GriddedDatabase(gridIndex)%fileType = s_gridded
      case ( l_ncep, l_strat ) ! --------------------------- NCEP Data
        if (griddedOrigin == l_ncep) then
           description = 'ncep'
        else
           description = 'strat'
        end if
        call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
          & mlspcf_l2ncep_start, mlspcf_l2ncep_end, description, got(f_file), &
          & LastNCEPPCF, returnStatus, noPCFid, verbose, debug )
        FileIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
          & name=FilenameString, shortName=shortFileName, &
          & type=l_hdfeos, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
          & PCBottom=mlspcf_l2ncep_start, PCTop=mlspcf_l2ncep_end)
        GriddedFile%PCFId = LastNCEPPCF
        FileIndex = AddFileToDataBase(filedatabase, GriddedFile)
        if ( .not. associated(grid) ) then
          ! The gridded data needs to be part of the database, even if the file
          ! won't be found and the gridded data empty,
          ! so it can be merged w/o segment faulting
          gridIndex = AddGriddedDataToDatabase( GriddedDatabase, tempGrid )
          call decorate ( key, gridIndex )
          if ( returnStatus == PGS_S_SUCCESS) then
            call readGriddedData ( GriddedFile, son, description, &
              & v_is_pressure, GriddedDatabase(gridIndex), returnStatus, &
              & dimListString, TRIM(fieldNameString), missingValue, &
              & verbose=verbose, deferReading=deferReading )
          else
            call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
          end if
          GriddedDatabase(gridIndex)%fileType = s_gridded
        else if ( returnStatus == PGS_S_SUCCESS) then
          call readGriddedData ( GriddedFile, son, description, &
            & v_is_pressure, tempGrid, returnStatus, &
            & dimListString, TRIM(fieldNameString), missingValue, &
            & verbose=verbose, deferReading=deferReading )
          ! If we succeeded in reading values, insert them into the db
          ! but only if we succeeded; otherwise protect the current values
          if ( .not. tempGrid%empty .or. deferReading ) then
            call DestroyGriddedData( grid )
            call copyGrid( grid, tempGrid )
          end if
        end if
        if ( returnStatus == 0 ) then
          if( switchDetail(switches, 'pro') > -1 ) &                            
            & call announce_success(FilenameString, 'ncep', &                    
             & fieldNameString, MLSFile=GriddedFile)
          apriorifiles%ncep = catlists(apriorifiles%ncep, trim(FilenameString))
        else
          call announce_success(FilenameString, 'ncep not found--carry on', &                    
             & fieldNameString, MLSFile=GriddedFile)
        end if
      case ( l_dao ) ! ---------------------------- GMAO Data (GEOS4)
        call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
          & mlspcf_l2dao_start, mlspcf_l2dao_end, 'dao', got(f_file), &
          & LastDAOPCF, returnStatus, noPCFid, verbose, debug )
        FileIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
          & name=FilenameString, shortName=shortFileName, &
          & type=l_hdfeos, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
          & PCBottom=mlspcf_l2dao_start, PCTop=mlspcf_l2dao_end)
        GriddedFile%PCFId = LastDAOPCF
        FileIndex = AddFileToDataBase(filedatabase, GriddedFile)

        ! We will decide whether it's geos4 or geos5 based on the field name
        select case ( lowercase(fieldNameString) )
        case ( 'tmpu' )
          description = 'dao'
          v_type = v_is_pressure
        case ( 'pl', 't' )
          description = 'geos5'
          v_type = V_is_eta
        case default
          description = 'geos5'
          v_type = V_is_eta
        end select

        if ( .not. associated(grid) ) then
          ! The gridded data needs to part of the database, even if the file
          ! won't be found and the gridded data empty,
          ! so it can be merged w/o segment faulting
          gridIndex = AddGriddedDataToDatabase( GriddedDatabase, tempGrid )
          call decorate ( key, gridIndex )

          if ( returnStatus == PGS_S_SUCCESS) then
            call ReadGriddedData ( GriddedFile, son, description, v_type, &
              & GriddedDatabase(gridIndex), returnStatus, &
              & dimListString, TRIM(fieldNameString), &
              & missingValue, litDescription=litDescription, &
              & verbose=verbose, deferReading=deferReading )
          else
            call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
          end if
          GriddedDatabase(gridIndex)%fileType = s_gridded
        else if ( returnStatus == PGS_S_SUCCESS) then
          call ReadGriddedData ( GriddedFile, son, description, v_type, &
            & tempGrid, returnStatus, &
            & dimListString, TRIM(fieldNameString), &
            & missingValue, litDescription=litDescription, &
            & verbose=verbose, deferReading=deferReading )
          ! If we succeeded in reading values, insert them into the db
          ! but only if we succeeded; otherwise protect the current values
          if ( .not. tempGrid%empty .or. deferReading ) then
            tempGrid%description = litDescription
            call DestroyGriddedData( grid )
            call copyGrid( grid, tempGrid )
          end if
        end if
        if ( litDescription == 'none' ) then
          call announce_success( FilenameString, 'dao not found--carry on', &
             & fieldNameString )
        elseif ( Griddeddatabase(gridIndex)%empty ) then
          call output( 'File was probably not ' // &
            & trim(litDescription), advance='yes' )
        else if ( description == 'dao' ) then
          apriorifiles%dao = catlists(apriorifiles%dao, trim(FilenameString))
        else
          apriorifiles%geos5 = &
            & catlists(apriorifiles%geos5, trim(FilenameString))
          apriorifiles%geos5Description = &
            & catlists(apriorifiles%geos5Description, trim(litDescription))
        end if
        if ( returnStatus == 0 ) then
          if( switchDetail(switches, 'pro') > -1 ) &                            
            & call announce_success(FilenameString, 'dao', & 
             & fieldNameString, MLSFile=GriddedFile)    
        elseif ( litDescription /= 'none' ) then
          call announce_success(FilenameString, 'dao not found--carry on', &
             & fieldNameString, MLSFile=GriddedFile)
        end if
      case ( l_geos5, l_geos5_7, l_merra, l_merra_2 ) ! --- GMAO Data (GEOS5*)
        if ( verbose ) call outputNamedvalue( 'LastGEOS5PCF', LastGEOS5PCF )
        call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
          & mlspcf_l2geos5_start, mlspcf_l2geos5_end, 'geos5', got(f_file), &
          & LastGEOS5PCF, returnStatus, noPCFid, verbose, debug )
        if ( &
          & any( griddedOrigin == (/ l_geos5_7, l_merra_2 /) ) &
          & ) then ! since geos5_7 and merra_2 are HDF5
            FileIndex = InitializeMLSFile(GriddedFile, content='gridded', &
            name=FilenameString, shortName=shortFileName, &
            type=l_hdf, access=DFACC_RDONLY, hdfVersion=HDFVERSION_5, &
            PCBottom=mlspcf_l2geos5_start, PCTop=mlspcf_l2geos5_end)
        else ! and the rest are HDF-EOS
            FileIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
              & name=FilenameString, shortName=shortFileName, &
              & type=l_hdfeos, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
              & PCBottom=mlspcf_l2geos5_start, PCTop=mlspcf_l2geos5_end)
        end if
        GriddedFile%PCFId = LastGEOS5PCF
        FileIndex = AddFileToDataBase( filedatabase, GriddedFile )

        ! We will decide whether it's geos4 or geos5 based on the field name
        select case ( lowercase(fieldNameString) )
        case ( 'tmpu' )
          description = 'dao'
          v_type = v_is_pressure
        case ( 'pl', 't', 'delp' )
          description = 'geos5'
          v_type = V_is_eta
        case default
          ! We may use this case if we allow for either merra or geos5
          ! in the same l2cf declarartion; e.g.
          ! geos5SumInput: gridded, origin=geos5, field='PL,DELP',  ..
          ! which means:
          ! 1st, try to read the field 'PL'
          ! if that fails, try to read the field 'DELP'
          ! (optionally summing over it to create a 'PL' field)
          description = 'geos5'
          v_type = V_is_eta
        end select
        ! We may override these based on the origin field
        select case ( griddedOrigin )
        case ( l_merra ) 
          description = 'merra'
        case ( l_merra_2 ) 
          description = 'merra_2'
        case ( l_geos5_7 ) 
          description = 'geos5_7'
        end select
        if ( DEBUG ) then
          call outputNamedValue( 'fileName', fileNameString )
          call outputNamedValue( 'fieldName', fieldNameString )
          call outputNamedValue( 'description', description )
          call outputNamedValue( 'associated(grid)', associated(grid) )
        end if

        if ( .not. associated(grid) ) then
          ! The gridded data needs to be part of the database, even if the file
          ! won't be found and the gridded data empty,
          ! so it can be merged w/o segment faulting
          gridIndex = AddGriddedDataToDatabase( GriddedDatabase, tempGrid )
          call decorate ( key, gridIndex )
          if ( returnStatus == PGS_S_SUCCESS) then
            call ReadGriddedData ( GriddedFile, son, description, v_type, &
              & GriddedDatabase(gridIndex), returnStatus, &
              & dimListString, TRIM(fieldNameString), &
              & missingValue, dateString, sumDelp, &
              & litDescription=litDescription, &
              & verbose=verbose, deferReading=deferReading )
          else
            call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
          end if
          GriddedDatabase(gridIndex)%fileType = s_gridded
        else if ( returnStatus == PGS_S_SUCCESS) then
          call ReadGriddedData ( GriddedFile, son, description, v_type, &
            & tempGrid, returnStatus, &
            & dimListString, TRIM(fieldNameString), &
            & missingValue, dateString, sumDelp, litDescription=litDescription, &
            & verbose=verbose, deferReading=deferReading )
          ! If we succeeded in reading values, insert them into the db
          ! but only if we succeeded; otherwise protect the current values
          if ( .not. tempGrid%empty .or. deferReading ) then
            tempGrid%description = litDescription
            call DestroyGriddedData( grid )
            call copyGrid( grid, tempGrid )
          end if
        end if
        if ( litDescription == 'none' ) then
          call announce_success( FilenameString, 'geos5 not found--carry on', &                    
             & fieldNameString )
        elseif ( Griddeddatabase(gridIndex)%empty ) then
          call output( 'File was probably not ' // &
            & trim(litDescription), advance='yes' )
        else
          apriorifiles%geos5 = &
            & catlists(apriorifiles%geos5, trim(FilenameString))
          apriorifiles%geos5Description = &
            & catlists(apriorifiles%geos5Description, trim(litDescription))
        end if
        if ( returnStatus == 0 ) then
          if( switchDetail(switches, 'pro') > -1 ) &                            
            & call announce_success(FilenameString, description, &                    
             & fieldNameString, MLSFile=GriddedFile)    
        elseif ( litDescription /= 'none' ) then
          call announce_success( FilenameString, 'geos5 not found--carry on', &                    
             & fieldNameString, MLSFile=GriddedFile )
        end if
        ! If we were asked to downsample gridded data to a coarser mesh, do so
        if ( downsample .and. .not. Griddeddatabase(gridIndex)%empty ) then
          call output( 'Downsampling Gridded data', advance='yes' )
          call DestroyGriddedData( tempgrid )
          grid => Griddeddatabase(gridIndex)
          call DownSampleGriddedData ( grid, tempgrid, &
            & heightsStep=1, latsStep=2, lonsStep=2, &
            & lstsStep=1, szasStep=1, datesStep=1, &
            & firstheights=1, firstlats=1, firstlons=1, &
            & firstlsts=1, firstszas=1, firstdates=1 )
          if( Debug ) then
            call output( 'Original Gridded data', advance='yes' )
            call dump( grid, details )
            call output( 'Downsampled Gridded data', advance='yes' )
            call dump( tempgrid, details )
          end if
          call DestroyGriddedData( grid )
          call copyGrid( grid, tempGrid )
        end if
      case ( l_gloria ) ! ------------------------- Data in Gloria's UARS format
        call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
          & mlspcf_l2clim_start, mlspcf_l2clim_end, 'gloria', got(f_file), &
          & LastClimPCF, returnStatus, noPCFid, verbose, debug )
        if ( TOOLKIT .and. returnStatus /= PGS_S_SUCCESS ) then
          call announce_error ( son, &
            & 'PCF number not found to supply' // &
            & ' missing Climatology file name' )
        end if
        FileIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
          & name=FilenameString, shortName=shortFileName, &
          & type=l_ascii, access=DFACC_RDONLY, &
          & PCBottom=mlspcf_l2clim_start, PCTop=mlspcf_l2clim_end)
        GriddedFile%PCFId = LastCLIMPCF
        FileIndex = AddFileToDataBase(filedatabase, GriddedFile)
        call decorate ( key, &
          & AddGriddedDataToDatabase ( griddedDatabase, &
          & ReadGloriaFile ( GriddedFile ) ) )
        if( switchDetail(switches, 'pro') > -1 ) then                            
          call announce_success(FilenameString, 'Gloria', &                    
           & '', MLSFile=GriddedFile)    
        end if
      case ( l_climatology ) ! -------------------- Climatology data
        ! Identify file (maybe from PCF if no name given)
        call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
          & mlspcf_l2clim_start, mlspcf_l2clim_end, 'climatology', got(f_file), &
          & LastClimPCF, returnStatus, noPCFid, verbose, debug )
        if ( Debug ) then
          call outputnamedValue ( 'got(f_file)', got(f_file) )
          call outputnamedValue ( 'fileNameString', trim(fileNameString) )
          call outputnamedValue ( 'path', trim(path) )
          call outputnamedValue ( 'subString', trim(subString) )
          call outputnamedValue ( 'noPCFid', noPCFid )
          call outputnamedValue ( 'returnStatus', returnStatus )
          call outputnamedValue ( 'LastClimPCF', LastClimPCF )
        endif
        if ( TOOLKIT .and. returnStatus /= PGS_S_SUCCESS ) then
          call announce_error ( son, &
            & 'PCF number not found to supply' // &
            & ' missing Climatology file name' )
        end if

        ! Have we read this already?
        gotAlready = associated(GriddedDatabase)
        if ( gotAlready ) then
          gotAlready = any(GriddedDatabase%sourceFilename==filenameString)
        end if
        if ( .not. gotAlready ) then
          FileIndex = InitializeMLSFile(GriddedFile, content = 'clim', &
            & name=FilenameString, shortName=shortFileName, &
            & type=l_ascii, access=DFACC_RDONLY, &
            & PCBottom=mlspcf_l2clim_start, PCTop=mlspcf_l2clim_end)
          GriddedFile%PCFId = LastCLIMPCF
          FileIndex = AddFileToDataBase(filedatabase, GriddedFile)
          ! No, well read it then, add its entire contents to the database
          call read_climatology ( GriddedFile, son, &
            & GriddedDatabase, returnStatus, &
            & mlspcf_l2apriori_start, mlspcf_l2apriori_end, &
            & missingValue )
          if ( returnStatus /= 0 ) then
            call Announce_error ( field, &                               
            & 'read_climatology unsuccessful--check file name and path' )
            ! Now crash gracefully instead of getting a reference to a
            ! disassociated GriddedDatabase pointer.
            call MLSL2Message ( MLSMSG_Error, ModuleName, &
            & 'read_climatology unsuccessful--check file name and path' )
          end if
          if ( Debug ) call outputNamedValue( 'climatology desc.', &
            & GriddedDatabase(size(GriddedDatabase))%description )
        end if
        if ( .not. associated(GriddedDatabase) ) go to 9  ! Last chance

        ! Locate requested grid by name, store index in gridIndex
        ! Check that field name is among those added by the source field
        do gridIndex = 1, size(griddedDatabase)
          if ( trim(fieldNameString) == &
            & trim(GriddedDatabase(gridIndex)%quantityName) ) exit
        end do

        if ( gridIndex <= size(griddedDatabase) ) then
          call decorate ( key, gridIndex )
          if( switchDetail(switches, 'pro') > -1 ) then
            if ( .not. gotAlready ) then
              call announce_success(FilenameString, 'climatology', &                  
               & fieldNameString, MLSFile=GriddedFile)
            else
              call announce_success(FilenameString, 'climatology', &                  
               & fieldNameString)
            end if
          end if
        else
          call announce_error ( son, 'Field ' // trim(fieldNameString) // &
            & ' not found in clim. file ' // trim(fileNameString) )
        end if
      case ( l_surfaceHeight ) ! See Read_surface_height_file
        call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
          & mlspcf_surfaceHeight_start, mlspcf_surfaceHeight_end, &
          & 'surfaceHeight', got(f_file), &
          & lastHeightPCF, returnStatus, noPCFid, verbose, debug )
        if ( TOOLKIT .and. returnStatus /= PGS_S_SUCCESS ) then
          call announce_error ( son, &
            & 'PCF number not found to supply' // &
            & ' missing Surface Height file name' )
        end if
        FileIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
          & name=FilenameString, shortName=shortFileName, &
          & type=l_binary, access=DFACC_RDONLY, &
          & PCBottom=mlspcf_surfaceHeight_start, PCTop=mlspcf_surfaceHeight_end)
        GriddedFile%PCFId = LastCLIMPCF
        FileIndex = AddFileToDataBase(filedatabase, GriddedFile)
        call open_surface_height_file ( griddedFile )
        call decorate ( key, &
          & AddGriddedDataToDatabase ( griddedDatabase, &
          & read_surface_height_file ( GriddedFile ) ) )
        call close_surface_height_file ( GriddedFile )
        if( switchDetail(switches, 'pro') > -1 ) then                            
          call announce_success(FilenameString, 'SurfaceHeight', &                    
           & '', MLSFile=GriddedFile)    
        end if
      case default ! Can't get here if tree_checker worked correctly
      end select   ! origins of gridded data

      if( Debug .and. gridIndex <= size(griddedDatabase) ) then
        if ( specialDumpFile /= ' ' ) &
          & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
        if ( griddedOrigin /= l_none ) &
          & call dump( GriddedDatabase(gridIndex), details )
        if ( specialDumpFile /= ' ' ) &
          & call revertOutput
      end if

    case default
    end select     ! types of apriori data

9   continue
    call trace_end ( "processOneAprioriFile", &
      & cond=toggle(gen) .and. levels(gen) > 0 )

  end subroutine processOneAprioriFile

  subroutine processOneL2AUXFile ( FileNameString, sdNameString, &
    & noPCFid, quantityType, &
    & LastAprioriPCF, Debug, &
    & L2AUX, L2AUXFile, fileDatabase )
   use L2AUXData, only: L2AUXData_T, ReadL2AUXData
   ! Process an a priori l2gp
    ! Args:
    character(len=FileNameLen)              :: FileNameString   ! actual literal file name
    character(len=FileNameLen)              :: sdNameString ! actual literal swath name
    logical, intent(in)                     :: noPCFid
    integer, intent(in)                     :: QUANTITYTYPE  ! Lit index of quantity type
    integer, intent(inout)                  :: LastAprioriPCF
    logical, intent(in)                     :: Debug
    type (L2AUXData_T), intent(inout)       :: L2AUX
    type (MLSFile_T)                        :: L2AUXFile
    type (MLSFile_T), dimension(:), pointer :: FILEDATABASE
    ! Internal variables
    integer :: FileIndex
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: L2apriori_version               ! 4 or 5 (corresp. to hdf4 or hdf5)

    character(len=FileNameLen) :: path   ! path of actual literal file name
    type (MLSFile_T), pointer :: pL2AUXFile
    integer :: ReturnStatus
    character(len=FileNameLen) :: ShortFileName
    character(len=FileNameLen) :: subString   ! file name w/o path

    if ( TOOLKIT .and. .not. noPCFid ) then
      call split_path_name( FileNameString, path, SubString )
      LastAprioriPCF = GetPCFromRef( SubString, mlspcf_l2apriori_start, &
      & mlspcf_l2apriori_end, &                                     
      & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
      & exactName=FileNameString )                             
    end if
    hdfVersion = mls_hdf_version(FilenameString)
    FileIndex = InitializeMLSFile( L2AUXFile, content = 'l2aux', &
      & name=FilenameString, shortName=shortFileName, &
      & type=l_hdf, access=DFACC_RDONLY, hdfVersion=hdfVersion, &
      & PCBottom=mlspcf_l2apriori_start, PCTop=mlspcf_l2apriori_end )
    ! call mls_openFile(L2AUXFile, returnStatus)
    L2AUXFile%PCFId = LastAprioriPCF
    FileIndex = AddFileToDataBase( filedatabase, L2AUXFile )
    pL2AUXFile => filedatabase(FileIndex)
    call ReadL2AUXData ( pL2AUXFile, sdNameString, &
      & L2AUX, &
      & quantityType, &
      & checkDimNames=.false. )

  end subroutine processOneL2AUXFile

  subroutine processOneL2GPFile ( FileNameString, swathNameString, &
    & noPCFid, PCBottom, PCTop, &
    & LastAprioriPCF, HMOT, Debug, &
    & L2GP, L2GPFile )
    ! Process an a priori l2gp
    use L2GPData, only: L2GPData_T, &
      & Readl2GPData
    ! Args:
    character(len=FileNameLen)     :: FileNameString   ! actual literal file name
    character(len=FileNameLen)     :: SWATHNAMESTRING ! actual literal swath name
    logical, intent(in)            :: noPCFid
    integer, intent(in)            :: PCBottom
    integer, intent(in)            :: PCTop
    integer, intent(inout)         :: LastAprioriPCF
!    integer, intent(inout)         :: LastAprioriVersion
    character, intent(in)          :: HMOT           ! 'H', 'M', 'O', or 'T'
    logical, intent(in)            :: Debug
    type (L2GPData_T), intent(out) :: L2GP
    type (MLSFile_T) :: L2GPFile
    ! Internal variables
    character(len=MAXSWATHNAMESBUFSIZE) :: ALLSWATHNAMES ! Buffer to get info back.
    integer :: COMMAPOS                 ! For parsing string
    integer :: FileIndex
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: L2apriori_version               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: LISTSIZE                 ! Size of string from SWInqSwath
    integer :: NOSWATHS                 ! In an input file
    character(len=FileNameLen) :: path   ! path of actual literal file name
    integer :: ReturnStatus
    character(len=FileNameLen) :: ShortFileName
    character(len=FileNameLen) :: subString   ! file name w/o path

    ! If we were given only a strand of the filename, expand it
    L2apriori_version = 1
    if ( TOOLKIT .and. .not. noPCFid ) then
      call split_path_name( FileNameString, path, SubString )
      LastAprioriPCF = GetPCFromRef( SubString, mlspcf_l2apriori_start, &
      & mlspcf_l2apriori_end, &                                     
      & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
      & exactName=FileNameString )                             
    end if
    hdfVersion = mls_hdf_version(FilenameString)

    FileIndex = InitializeMLSFile( L2GPFile, content = 'l2gp', &
      & name=FilenameString, shortName=shortFileName, &
      & type=l_swath, access=DFACC_RDONLY, hdfVersion=hdfVersion, &
      & PCBottom=PCBottom, PCTop=PCTop )
    L2GPFile%PCFId = LastAprioriPCF
    ! If we didn't get a name get the first swath name in the file
    if ( len_trim(swathNameString) == 0 ) then
      allSwathNames = ''
      noSwaths = mls_InqSwath ( fileNameString, allSwathNames, listSize, &
       & hdfVersion=hdfVersion )
      if ( listSize == FILENOTFOUND ) then
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'File not found; make sure the name and path are correct' &
          & // trim(fileNameString), MLSFile=L2GPFile )
      else if ( listSize < 1 ) then
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'Failed to determine swath names, perhaps none in file ' &
          & // trim(fileNameString), MLSFile=L2GPFile )
      else if ( listSize < len(allSwathNames) ) then
        commaPos = index ( allSwathNames, ',' )
        if ( commaPos == 0 ) then
          commaPos = len_trim(allSwathNames)
        else if ( commaPos == 1 ) then
          call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'Failed to determine swath name, allswathnames begin with , ' &
          & // trim(fileNameString), MLSFile=L2GPFile )
        else
          commaPos = commaPos - 1
        end if
        swathNameString = allSwathNames ( 1:commaPos )
      else
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'Failed to determine swath names, string too long.' &
          & // trim(fileNameString), MLSFile=L2GPFile )
      end if
    end if
    if ( swathNameString == ' ' ) then
      call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Failed to determine swath name, obscure error on ' &
        & // trim(fileNameString), MLSFile=L2GPFile )
    end if

    ! Read the swath
    if ( HMOT /= ' ' ) then
      call ReadL2GPData ( L2GPFile, swathNameString, l2gp, HMOT=HMOT )
    else
      call ReadL2GPData ( L2GPFile, swathNameString, l2gp )
    end if
  end subroutine processOneL2GPFile

  ! =========== Private ============

    subroutine Get_PCF_Id ( FileNameString, Path, SubString, L2Apriori_Version, &
      & FirstPCF, LastPCF, Description, GotFile, PCF_Id, ReturnStatus, noPCFid, &
      & verbose, debug )
      use MLSFiles, only: Getpcfromref, Split_Path_Name
      use MLSL2Options, only: Toolkit
      use SDPToolkit, only: Pgs_Pc_Getreference, Pgs_S_Success
      use Toggles, only: Gen, Levels, Toggle
      use Trace_M, only: Trace_Begin, Trace_End

      ! Args
      character(len=*), intent(inout) :: FileNameString
      character(len=*), intent(out) :: Path, SubString
      integer, intent(inout) :: L2Apriori_Version
      integer, intent(in) :: FirstPCF, LastPCF
      character(len=*), intent(in) :: Description
      logical, intent(in) :: GotFile
      integer, intent(inout) :: PCF_Id
      integer, intent(out) :: ReturnStatus
      logical, intent(in) :: noPCFid
      logical, intent(in) :: verbose
      logical, intent(in) :: debug
      ! Local variables
      integer :: Me = -1       ! String index for trace
      integer :: PCFBottom
      ! Executable
      call trace_begin ( me, "Get_PCF_Id", &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( gotFile ) then
        PCFBottom = FirstPCF
      else
        PCFBottom = PCF_Id + 1 ! This must be the last PCF id we found
      end if

      ! Now parse file and field names
      if ( debug ) then
        call outputNamedValue ( 'fileNameString', trim(fileNameString) )
        call outputNamedValue ( 'got file?', gotFile )
        call output('PCFBottom, lastPCF: ')
        call output( (/ PCFBottom, lastPCF /), advance='yes' )
      endif
      call split_path_name ( fileNameString, path, subString )
      if ( TOOLKIT .and. gotFile .and. .not. noPCFid ) then
        if ( debug ) call output( 'Calling getPCFromRef with ' // trim(subString), advance='yes' )
        pcf_id = getPCFromRef ( subString, PCFBottom, lastPCF, TOOLKIT, &
          &                     returnStatus, l2Apriori_Version, DEBUG, &
          &                     exactName = fileNameString )
      else if ( TOOLKIT .and. .not. noPCFid ) then
        do pcf_id = PCFBottom, lastPCF
          returnStatus = Pgs_pc_getReference(pcf_id, L2apriori_version, &
                & fileNameString)
          if ( returnStatus == PGS_S_SUCCESS) exit
        end do
        if ( returnStatus /= PGS_S_SUCCESS ) &
          & call announce_success ( description, 'no entry in PCF',  ' ' )
      else
        returnStatus = 0
        PCF_Id = 0
      end if
      call trace_end ( "Get_PCF_Id", &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine Get_PCF_Id

  ! ------------------------------------------  readAPrioriAttributes_MF  -----
  subroutine readAPrioriAttributes_MF ( MLSFile )
    type(MLSFile_T) :: MLSFile
    logical             :: verbose
    ! Executable
    verbose = ( switchDetail(switches, 'apr') > 0 )
    if ( verbose ) call dump( MLSFile, details=1 )
    if ( MLSFile%hdfVersion /= HDFVERSION_5 ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'Wrong hdfVersion--can read apriori attributes for hdf5 only', &
        & MLSFile=MLSFile )
      return ! Can only do this for hdf5 files
    else if ( MLSFile%StillOpen ) then
      if ( verbose ) call output( 'About to read file attributes for a priori', advance='yes' )
      call readAPrioriAttributes_ID(MLSFile%fileID%f_id, HDFVERSION_5)
    else
      call MLS_OpenFile( MLSFile )
      if ( verbose ) then
        call dump( MLSFile, details=1 )
        call output( 'About to read file attributes for a priori', advance='yes' )
      end if
      call readAPrioriAttributes_ID(MLSFile%fileID%f_id, HDFVERSION_5)
      call MLS_CloseFile( MLSFile )
    end if
  end subroutine readAPrioriAttributes_MF

  ! ------------------------------------------  readAPrioriAttributes_ID  -----
  subroutine readAPrioriAttributes_ID ( fileID, hdfVersion )
    ! read info about what apriori files were used
    ! Storing them as hdfeos5 attributes
    use MLSHDFEOS, only: HE5_EHRDGlatt, MLS_IsGlatt
    use PCFHdr, only: GlobalAttributes
    ! Args
    integer, intent(in) :: fileID
    integer, intent(in) :: hdfVersion  ! Must be 5 to work properly
    ! Internal variables
    integer             :: status
    logical             :: verbose
    character(len=*), parameter  :: whereami = 'readAPrioriAttributes_ID'
    ! Executable
    verbose = ( switchDetail(switches, 'apr') > 0 )
    if ( verbose ) call output( 'Reading apriori attributes', advance='yes' )
    if ( hdfVersion /= HDFVERSION_5 ) then
      call MLSL2Message ( MLSMSG_Warning, whereami, &
        & 'Wrong hdfVersion--can read apriori attributes for hdf5 only' )
      return ! Can only do this for hdf5 files
    end if
    if ( verbose ) then
      call outputNamedValue( 'FileID', FileID )
      call outputNamedValue( 'l2gp there?', mls_isglatt ( fileID, 'A Priori l2gp' ) )
      call outputNamedValue( 'geos5desc there?', mls_isglatt ( fileID, 'geos5 type' ) )
    end if
    status = HE5_EHRDGLATT(fileID, &
     & 'A Priori l2gp', APrioriFiles%l2gp)
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem reading APrioriFiles%l2gp' // trim(APrioriFiles%l2gp) )
    status = HE5_EHRDGLATT(fileID, &
     & 'A Priori l2aux', APrioriFiles%l2aux)
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem reading APrioriFiles%l2aux' // trim(APrioriFiles%l2aux) )
    status = HE5_EHRDGLATT(fileID, &
     & 'A Priori ncep', APrioriFiles%ncep)
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem reading APrioriFiles%ncep' // trim(APrioriFiles%ncep) )
    status = HE5_EHRDGLATT(fileID, &
     & 'A Priori gmao', APrioriFiles%dao)
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem reading APrioriFiles%dao' // trim(APrioriFiles%dao) )
    status = HE5_EHRDGLATT(fileID, &
     & 'A Priori geos5', APrioriFiles%geos5)
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem reading APrioriFiles%geos5' // trim(APrioriFiles%geos5) )
    status = HE5_EHRDGLATT(fileID, &
     &  'geos5 type', APrioriFiles%geos5description)
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem reading APrioriFiles%geos5description' // &
      &  trim(APrioriFiles%geos5description) )
    status = HE5_EHRDGLATT(fileID, &
     &  'MiscNotes', GlobalAttributes%MiscNotes)
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem reading GlobalAttributes%MiscNotes' // &
      &  trim(GlobalAttributes%MiscNotes) )
  end subroutine readAPrioriAttributes_ID

  ! ------------------------------------------  writeAPrioriAttributes_MF  -----
  subroutine writeAPrioriAttributes_MF ( MLSFile, DontReplace )
    type(MLSFile_T) :: MLSFile
    logical, optional, intent(in) :: DontReplace ! Don't overwrite attributes
    logical             :: verbose
    ! Executable
    verbose = ( switchDetail(switches, 'apr') > 0 )
    if ( verbose ) then
      call dump( MLSFile, details=1 )
      call output( 'About to write file attributes for a priori', advance='yes' )
    end if
    if ( MLSFile%hdfVersion /= HDFVERSION_5 ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'Wrong hdfVersion--can write apriori attributes for hdf5 only', &
        & MLSFile=MLSFile )
      return ! Can only do this for hdf5 files
    else if ( MLSFile%StillOpen ) then
      call writeAPrioriAttributes_ID( MLSFile%fileID%f_id, HDFVERSION_5, &
       & DontReplace )
    else
      call MLS_OpenFile( MLSFile )
      call writeAPrioriAttributes_ID( MLSFile%fileID%f_id, HDFVERSION_5, &
        & DontReplace )
      call MLS_CloseFile( MLSFile )
    end if
  end subroutine writeAPrioriAttributes_MF

  ! ------------------------------------------  writeAPrioriAttributes_ID  -----
  subroutine writeAPrioriAttributes_ID ( fileID, hdfVersion, DontReplace )
    ! Write info about what apriori files were used
    ! Storing them as hdfeos5 attributes
    use HDFEOS5, only: MLS_Chartype
    use MLSHDFEOS, only: MLS_EHWRGlatt, MLS_IsGlatt
    ! Args
    integer, intent(in) :: fileID
    integer, intent(in) :: hdfVersion  ! Must be 5 to work properly
    logical, optional, intent(in) :: DontReplace ! Don't overwrite attributes
    character(len=*), parameter  :: whereami = 'readAPrioriAttributes_ID'
    ! Internal variables
    integer             :: status
    logical             :: verbose
    ! Executable
    verbose = ( switchDetail(switches, 'apr') > 0 )
    if ( verbose ) call output( 'Writing apriori attributes', advance='yes' )
    if ( hdfVersion /= HDFVERSION_5 ) then
      call MLSL2Message ( MLSMSG_Warning, whereami, &
        & 'Wrong hdfVersion--can write apriori attributes for hdf5 only' )
      return ! Can only do this for hdf5 files
    end if
    if ( verbose ) call outputNamedValue( 'attributes already written', &
      & mls_isglatt ( fileID, 'A Priori l2gp' ) )
    ! Have the attributes been written before? Must we avoid replacing them?
    if ( present( dontReplace ) ) then
      if ( verbose ) call outputNamedValue( 'dontReplace?', dontReplace )
      if ( dontReplace ) then
        if ( mls_isglatt ( fileID, 'A Priori l2gp' ) ) return
      end if
    end if
    status = mls_EHwrglatt(fileID, &
     & 'A Priori l2gp', MLS_CHARTYPE, 1, &
     &  trim(APrioriFiles%l2gp))
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem writing APrioriFiles%l2gp' // trim(APrioriFiles%l2gp) )
    status = mls_EHwrglatt(fileID, &
     & 'A Priori l2aux', MLS_CHARTYPE, 1, &
     &  trim(APrioriFiles%l2aux))
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem writing APrioriFiles%l2aux' // trim(APrioriFiles%l2aux) )
    status = mls_EHwrglatt(fileID, &
     & 'A Priori ncep', MLS_CHARTYPE, 1, &
     &  trim(APrioriFiles%ncep))
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem writing APrioriFiles%ncep' // trim(APrioriFiles%ncep) )
    status = mls_EHwrglatt(fileID, &
     & 'A Priori gmao', MLS_CHARTYPE, 1, &
     &  trim(APrioriFiles%dao))
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem writing APrioriFiles%dao' // trim(APrioriFiles%dao) )
    status = mls_EHwrglatt(fileID, &
     & 'A Priori geos5', MLS_CHARTYPE, 1, &
     &  trim(APrioriFiles%geos5))
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem writing APrioriFiles%geos5' // trim(APrioriFiles%geos5) )
    status = mls_EHwrglatt(fileID, &
     & 'geos5 type', MLS_CHARTYPE, 1, &
     &  trim(APrioriFiles%geos5description))
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem writing APrioriFiles%geos5description' // &
      & trim(APrioriFiles%geos5description) )
    status = mls_EHwrglatt(fileID, &
      & 'MiscNotes', MLS_CHARTYPE, 1, &
      &  GlobalAttributes%MiscNotes)
    if ( status /= 0 ) &
      &  call MLSL2Message ( MLSMSG_Warning, whereami, &
      & 'Problem writing MiscNotes' // &
      & trim(GlobalAttributes%MiscNotes) )
  end subroutine writeAPrioriAttributes_ID

! =====     Private Procedures     =====================================

  ! ---------------------------------------------  announce_success  -----
  subroutine announce_success ( FullName, l2_type, quantityName, &
    & hdfVersion, MLSFile )
    use HighOutput, only: AddRow, &
      & OutputTable, StartTable, StyledOutput
    ! Args
    character(len=*), intent(in)   :: FullName
    character(len=*), intent(in)   :: l2_type
    integer, optional,  intent(in) :: hdfVersion
    character(len=*), intent(in) :: quantityName
    type(MLSFile_T), optional :: MLSFile

    ! Local variables
    integer                        :: myhdfVersion
    character(len=len(FullName))   :: name, path
    integer, save                  :: trip = 0
    ! Executable
    trip = trip + 1
    if ( trip < 2 ) &
      & call StyledOutput ( 'Level 2 apriori products', options='--Banner' )
    call split_path_name ( FullName, path, name )
    call StartTable
    call addRow ( 'type', trim(l2_type) )
    if ( present(hdfVersion) ) then
      if ( hdfVersion == WILDCARDHDFVERSION ) then
        myhdfVersion = mls_hdf_version(trim(Name))
      else
        myhdfVersion = hdfVersion
      end if
      call addRow ( 'hdf ver', myhdfVersion )
    end if
    call addRow ( 'path', trim(path) )
    call addRow ( 'name', trim(name) )
    call addRow ( 'quantity', trim(quantityName) )
    Call OutputTable ( sep='|', border='-' )
    if ( present(MLSFile) .and. switchdetail(switches, 'apr' ) > -1 ) &
      & call dump(MLSFile)
  end subroutine announce_success

  ! ------------------------------------------------  announce_error  -----
  subroutine Announce_error ( lcf_where, full_message, use_toolkit, &
    & error_number, APrioriFile )
  
   ! Arguments
  
    integer, intent(in)    :: Lcf_where
    character(LEN=*), intent(in)    :: Full_message
    logical, intent(in), optional :: Use_toolkit
    integer, intent(in), optional    :: Error_number
    type(MLSFile_T), intent(in), optional    :: APrioriFile
    ! Local
    logical :: Just_print_it
    logical, parameter :: Default_output_by_toolkit = .true.
    logical :: verbose
    ! Executable
    if ( present(use_toolkit) ) then
      just_print_it = .not. use_toolkit
    else if ( default_output_by_toolkit ) then
      just_print_it = .false.
    else
      just_print_it = .true.
    end if
    verbose = ( SwitchDetail(switches, 'apr') > -1 )
 
    if ( .not. just_print_it ) then
      error = max(error,1)
      call output ( '***** At ' )

      if ( lcf_where > 0 ) then
          call print_source ( where(lcf_where) )
      else
        call output ( '(no lcf node available)' )
      end if
      if ( verbose ) then
        call output ( ': ' )
        call output ( "The " );
        if ( lcf_where > 0 ) then
          call dump_tree_node ( lcf_where, 0 )
        else
          call output ( '(no lcf tree available)' )
        end if
      end if

      call output ( " Caused the following error: ", advance='yes', &
        & from_where=ModuleName )
      call output ( trim(full_message), advance='yes', &
        & from_where=ModuleName )
      if ( present(error_number) ) then
        call output ( 'error number ', advance='no' )
        call output ( error_number, places=9, advance='yes' )
      end if
    else
      call output ( '***Error in module ' )
      call output ( ModuleName, advance='yes' )
      call output ( trim(full_message), advance='yes' )
      if ( present(error_number) ) then
        call output ( 'Error number ' )
        call output ( error_number, advance='yes' )
      end if
    end if
    if ( present(APrioriFile) ) call dump(APrioriFile)
!===========================
  end subroutine Announce_error
!===========================

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: read_apriori.f90,v 2.127 2018/11/01 23:18:13 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ReadAPriori

!=============================================================================

!
! $Log: read_apriori.f90,v $
! Revision 2.127  2018/11/01 23:18:13  pwagner
! Removed unused stuff
!
! Revision 2.126  2018/07/27 23:19:53  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.125  2018/03/22 18:14:28  pwagner
! Added command IsFileAbsent; may occur in ReadApriori, MergeGrids, and Output sections
!
! Revision 2.124  2018/03/14 22:42:40  pwagner
! May changeSettings in readApriori and MergeGrids sections
!
! Revision 2.123  2017/11/15 00:11:24  pwagner
! Use OutputTable to Dump list of level 1 files
!
! Revision 2.122  2017/08/08 20:46:28  vsnyder
! Stop with error instead of seg fault if climatology not successfully read
!
! Revision 2.121  2017/07/10 23:04:52  pwagner
! Print less if not verbose
!
! Revision 2.120  2017/03/17 00:13:43  pwagner
! runtime Boolean CarryOver given better chance to work properly
!
! Revision 2.119  2017/03/07 21:21:01  pwagner
! Support new meteorology origin: merra_2
!
! Revision 2.118  2017/01/13 01:31:40  pwagner
! Avoid excess output when feeling around for right meteorology file type
!
! Revision 2.117  2016/09/30 20:33:46  pwagner
! verboser was used w/o being defined; fixed
!
! Revision 2.116  2016/09/21 00:41:04  pwagner
! Default to printing less
!
! Revision 2.115  2016/07/28 01:45:07  vsnyder
! Refactor dump and diff
!
! Revision 2.114  2016/04/01 00:27:15  pwagner
! May now Execute a single command or a script of lines from l2cf
!
! Revision 2.113  2015/11/17 21:28:07  pwagner
! Made public processOneL2AUXFile and processOneL2GPFile
!
! Revision 2.112  2015/08/03 21:43:50  pwagner
! Made quantityType optional in call to ReadL2AUXData
!
! Revision 2.111  2015/05/07 20:16:50  pwagner
! Fixed error affecting noPCFid
!
! Revision 2.110  2015/05/05 18:15:47  pwagner
! /noPCFid field allows us to read from files not named in PCF
!
! Revision 2.109  2014/10/07 00:08:45  pwagner
! Higher details level of debug now required for most printing
!
! Revision 2.108  2014/10/02 17:24:00  pwagner
! Added MiscNotes to file attributes we read and write
!
! Revision 2.107  2014/09/05 01:27:33  vsnyder
! Add some tracing
!
! Revision 2.106  2014/06/04 18:34:37  pwagner
! runtime carryover flag starts PCFids at value from last readApriori section; may deferReading
!
! Revision 2.105  2014/04/02 23:05:11  pwagner
! Removed redundant open_ and close_MLSFile
!
! Revision 2.104  2014/01/11 01:52:15  vsnyder
! Get OutputNamedValue from HighOutput, not Output_m.  Getting it from
! Output_m crept back in during CVS conflict resolution.
!
! Revision 2.103  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.102  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.101  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.100  2013/10/09 23:43:41  vsnyder
! Add Evaluate_Variable
!
! Revision 2.99  2013/09/24 23:47:23  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.98  2013/08/30 02:45:51  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.97  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.96  2013/02/12 18:13:01  pwagner
! Raise -Sapr switch setting needed to become verbose
!
! Revision 2.95  2012/08/16 17:50:42  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.94  2012/05/08 17:50:31  pwagner
! Added Select .. Case .. EndSelect control structure
!
! Revision 2.93  2012/03/12 17:31:59  pwagner
! New api for writeAPrioriAttributes; can avoid replacing if already written
!
! Revision 2.92  2012/02/24 21:16:06  pwagner
! Read/Write geos5description attributes, too
!
! Revision 2.91  2011/08/03 21:59:39  pwagner
! Reduced default verbosity by making debug switchable
!
! Revision 2.90  2011/07/13 14:24:46  honghanh
! Initialize GEOS5.7 file type with l_hdf instead of l_hdfeos
!
! Revision 2.89  2011/07/12 22:35:03  honghanh
! Change l_grid to l_hdfeos
!
! Revision 2.88  2011/06/16 23:16:27  pwagner
! Added /downsample to reduce resolution of gridded data when read
!
! Revision 2.87  2011/05/26 20:45:15  pwagner
! Should not bomb with 'pro' set in switches
!
! Revision 2.86  2011/05/05 17:02:34  pwagner
! Added readGriddedData command to readApriori section
!
! Revision 2.85  2011/04/27 17:39:56  pwagner
! Consistent with new ncep_dao api
!
! Revision 2.84  2011/04/20 16:54:28  pwagner
! Added new flexibility to l2cf control flow by run-time booleans affecting gridded data
!
! Revision 2.83  2010/11/09 02:37:28  vsnyder
! Spiff up a dump
!
! Revision 2.82  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
! Revision 2.81  2009/10/26 17:11:07  pwagner
! Added Diff command to be used like Dump in l2cf
!
! Revision 2.80  2009/09/10 23:03:41  pwagner
! Prevents 'Dump, /stop' line in l2cf from causing checkPaths failure
!
! Revision 2.79  2009/08/26 16:48:17  pwagner
! Added readAPrioriAttributes; writes APrioriFiles%geos5 as file attribute
!
! Revision 2.78  2009/08/24 20:25:28  pwagner
! Added merra file type, 'DELP' field name, /sum filed
!
! Revision 2.77  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.76  2008/12/02 23:12:47  pwagner
! mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
!
! Revision 2.75  2008/09/17 23:20:13  pwagner
! Allow date string in gridded data to offset gmao background files
!
! Revision 2.74  2007/10/24 00:16:59  pwagner
! Removed unused declarations
!
! Revision 2.73  2007/08/17 00:35:30  pwagner
! Unneeded changes
!
! Revision 2.72  2007/06/21 00:54:08  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.71  2007/03/02 18:14:02  pwagner
! Fixed bugs introduced 2 versions ago
!
! Revision 2.70  2007/01/30 21:59:10  pwagner
! fixed bug where Get_PCF_Id retruned undefined values
!
! Revision 2.69  2007/01/11 20:48:30  vsnyder
! Add SurfaceHeight to gridded data, vector quantities, allow dump in ReadApriori
!
! Revision 2.68  2006/06/13 20:56:43  pwagner
! Fixed bug in pcfid names for geos5 files
!
! Revision 2.67  2006/06/13 18:19:08  pwagner
! Added pcfids for geos5; moved ncep pcfids backwards to make room
!
! Revision 2.66  2006/06/06 21:56:52  pwagner
! May specify geos5 apriori files instead of dao (geos4)
!
! Revision 2.65  2006/04/10 23:45:18  pwagner
! Reset defaults in read_apriori, not ChunkDivide
!
! Revision 2.64  2006/02/10 21:15:55  pwagner
! dumps may go to special dumpfile
!
! Revision 2.63  2006/01/26 00:35:35  pwagner
! demoted more use statements from module level to speed Lahey compiles
!
! Revision 2.62  2005/09/28 17:02:04  pwagner
! Should not segment fault when reading apriori l2aux
!
! Revision 2.61  2005/08/05 20:39:07  pwagner
! L2AUXFile arg to ReadL2AUXFile now a pointer
!
! Revision 2.60  2005/07/12 17:34:57  pwagner
! Added MLSFile interface for writing apriori attributes
!
! Revision 2.59  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.58  2005/06/14 20:40:27  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.57  2004/09/23 23:03:14  pwagner
! Added writeAPrioriAttributes
!
! Revision 2.56  2004/06/28 20:25:54  pwagner
! Handle dao, ncep missing from PCF with grace
!
! Revision 2.55  2004/06/23 17:13:34  pwagner
! Should quit gracefully if climatolgy file not found
!
! Revision 2.54  2004/01/23 01:10:58  pwagner
! Gets max swathlist length from L2GPData
!
! Revision 2.53  2003/10/06 13:16:09  cvuu
! add new description=strat to handle reading the ncep data file
!
! Revision 2.52  2003/06/09 22:49:34  pwagner
! Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
!
! Revision 2.51  2003/05/29 17:54:28  pwagner
! Able to read dao, ncep files w/o knowing name fragment
!
! Revision 2.50  2003/05/09 23:26:45  pwagner
! Should not bomb when l2aux hdfversion absent or wildcard
!
! Revision 2.49  2003/05/06 00:16:32  pwagner
! Fixed passing wild card hdf version to mls_sfend for l2aux
!
! Revision 2.48  2003/05/05 23:00:34  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.47  2003/04/17 23:08:29  pwagner
! Added optional AuraInstrument field to l2gp apriori reads
!
! Revision 2.46  2003/04/04 18:35:11  pwagner
! Warns if dao, ncep FILENOTFOUND
!
! Revision 2.45  2003/04/02 23:54:53  pwagner
! Checks for FILENOTFOUND
!
! Revision 2.44  2003/04/01 21:44:38  dwu
! Fixed bad error with multiple swaths in file (pwagner)
!
! Revision 2.43  2003/03/01 00:24:27  pwagner
! Added missingValue as filed to reading Gridded data
!
! Revision 2.42  2003/02/27 18:41:40  pwagner
! Handles WILDCARDHDFVERSION properly
!
! Revision 2.41  2003/02/20 21:26:21  pwagner
! Lets you read field dimList=x,y,.. w/ griddeddata
!
! Revision 2.40  2003/02/19 19:16:21  pwagner
! More sensible output when proclaiming successful file inputs
!
! Revision 2.39  2003/01/18 02:37:34  livesey
! Added the quantityType stuff to L2Aux issues
!
! Revision 2.38  2002/12/10 00:40:27  pwagner
! Overrides defaults; forcing check of l2auxdimNames
!
! Revision 2.37  2002/12/06 01:06:56  pwagner
! Passes hdfVersion to readl2auxdata
!
! Revision 2.36  2002/10/08 17:36:22  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.35  2002/04/06 00:11:18  pwagner
! Combined pcf numbers for dao, ncep, clim, l2gp into apriori
!
! Revision 2.34  2002/01/29 23:49:38  pwagner
! Separate DEFAULT_HDFVERSION_(READ)(WRITE)
!
! Revision 2.33  2002/01/26 00:10:45  pwagner
! Correctly sets hdfVersion; changed proclaim to announce_success
!
! Revision 2.32  2002/01/23 23:09:46  pwagner
! Handles optional hdfVersion field; proclaims files input
!
! Revision 2.31  2002/01/23 22:35:47  livesey
! Added ReadGloriaFile stuff
!
! Revision 2.30  2002/01/18 19:01:34  pwagner
! Changed debugOption to .false.
!
! Revision 2.29  2002/01/18 18:50:08  pwagner
! Better check when swopen fails
!
! Revision 2.28  2002/01/18 00:55:30  pwagner
! Uses MLSFiles for swapi wrappers
!
! Revision 2.27  2002/01/09 00:00:04  pwagner
! Replaced write or print statements with calls to output
!
! Revision 2.26  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.25  2001/10/30 00:35:27  pwagner
! Tidied up small things
!
! Revision 2.24  2001/10/26 23:20:10  pwagner
! Optionally dumps apriori quantities as it reads them
!
! Revision 2.23  2001/10/08 21:35:43  pwagner
! Initialize allswathnames
!
! Revision 2.22  2001/09/28 23:59:20  pwagner
! Fixed various timing problems
!
! Revision 2.21  2001/09/10 23:37:44  livesey
! New GriddedData stuff
!
! Revision 2.20  2001/05/12 00:20:00  livesey
! Allowed user to not supply swath name when reading l2gp
!
! Revision 2.19  2001/05/07 18:03:56  pwagner
! Checks for PCF before looping over pcf_indx
!
! Revision 2.18  2001/05/03 20:34:08  vsnyder
! Cosmetic changes
!
! Revision 2.17  2001/04/16 23:50:01  pwagner
! Tiny change to announce_error
!
! Revision 2.16  2001/04/12 22:19:33  vsnyder
! Improved an error message
!
! Revision 2.15  2001/04/10 20:04:26  livesey
! Bug fixes etc.
!
! Revision 2.14  2001/03/30 00:27:38  pwagner
! Fleshed out njl outline for reading clim. files
!
! Revision 2.13  2001/03/29 19:13:41  livesey
! Added some comment guidelines for read climatology
!
! Revision 2.12  2001/03/21 00:46:08  pwagner
! Passes son to READ_CLIMATOLOGY
!
! Revision 2.11  2001/03/15 21:38:00  pwagner
! Gets v_is_pressure from GriddedData
!
! Revision 2.10  2001/03/15 21:25:16  pwagner
! Split between GriddedData and ncep_dao modules
!
! Revision 2.9  2001/03/15 21:18:57  vsnyder
! Use Get_Spec_ID instead of decoration(subtree...
!
! Revision 2.8  2001/03/15 00:34:34  pwagner
! Gives more info to ReadGriddedData
!
! Revision 2.7  2001/03/14 19:06:08  livesey
! Some changes
!
! Revision 2.6  2001/03/14 18:54:38  pwagner
! Uses FieldNameString and son in call to ReadGriddedData
!
! Revision 2.5  2001/03/08 01:08:08  pwagner
! Interfaces with ReadGriddedData
!
! Revision 2.4  2001/03/07 22:41:44  livesey
! Reworked the l2cf aspects
!
! Revision 2.3  2001/03/07 01:04:33  pwagner
! No longer uses obtainclim, obtaindao, obtainncep
!
! Revision 2.2  2001/03/06 00:23:58  pwagner
! A little bit more
!
! Revision 2.1  2001/03/03 00:14:40  pwagner
! First commit
!
!
@


2.127
log
@Removed unused stuff
@
text
@d1217 1
a1217 1
    if ( verbose ) call dump( MLSFile )
d1229 1
a1229 1
        call dump( MLSFile )
d1306 1
d1308 5
d1320 1
a1320 1
        & DontReplace )
a1322 1
      ! call writeAPrioriAttributes_name(MLSFile%name, HDFVERSION_5)
d1516 1
a1516 1
       "$Id: read_apriori.f90,v 2.126 2018/07/27 23:19:53 pwagner Exp $"
d1529 3
@


2.126
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d40 1
a40 1
  use MLSMessageModule, only: MLSMsg_Error, MLSMsg_Warning, DumpConfig
d51 1
a51 1
  use Output_M, only: OutputOptions, StampOptions, Output, RevertOutput, SwitchOutput
d77 7
a83 7
! dumpAPrioriAttributes       dump types and names of apriori files used
! processOneAprioriFile       read one apriori file into a gridded data type
! processOneL2AUXFile         read one l2aux file into a gridded data type
! processOneL2GPFile          read one l2gp file into a gridded data type
! read_apriori                entry point for apriori section; process l2cf
! readAPrioriAttributes       read attributes from a file to which they were written
! writeAPrioriAttributes      write as attributes info about apriori files used
d88 5
a92 5
  public ::  aprioriFiles, aprioriFiles_t, &
    & dumpAPrioriAttributes, processOneAPrioriFile, &
    & processOneL2AUXFile, processOneL2GPFile, &
    & read_apriori, readAPrioriAttributes, &
    & writeAPrioriAttributes
a241 3
        ! call Dump( OutputOptions )
        ! call Dump( StampOptions )
        ! call DumpConfig
d410 3
a412 1
      if ( .not. CHECKPATHS ) call dumpCommand ( key, griddedDataBase=griddedDataBase )
d453 1
a453 1
      case ( f_hdfVersion )           
d458 3
a460 1
        hdfVersion = value(1)                                          
d566 1
a566 1
        & noPCFid, mlspcf_l2apriori_start, mlspcf_l2apriori_end, quantityType, &
d1005 1
a1005 1
    & noPCFid, PCBottom, PCTop, quantityType, &
a1013 2
    integer, intent(in)                     :: PCBottom
    integer, intent(in)                     :: PCTop
d1305 1
a1305 1
    logical, optional, intent(in) :: DontReplace
d1313 2
a1314 1
      call writeAPrioriAttributes_ID(MLSFile%fileID%f_id, HDFVERSION_5)
d1318 2
a1319 1
      call writeAPrioriAttributes_ID(MLSFile%fileID%f_id, HDFVERSION_5)
d1325 1
a1325 1
  subroutine writeAPrioriAttributes_ID ( fileID, hdfVersion , DontReplace )
d1333 1
a1333 1
    logical, optional, intent(in) :: DontReplace
d1511 1
a1511 1
       "$Id: read_apriori.f90,v 2.125 2018/03/22 18:14:28 pwagner Exp $"
d1524 3
@


2.125
log
@Added command IsFileAbsent; may occur in ReadApriori, MergeGrids, and Output sections
@
text
@d38 1
a38 1
    & DumpMacros, MLSMessage
d287 2
a288 2
      call MLSMessage(MLSMSG_Error,ModuleName, &
        & 'Problem with read_apriori section')
d599 1
a599 1
        if ( associated(grid) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d927 1
a927 1
            call MLSMessage ( MLSMSG_Error, ModuleName, &
d1109 1
a1109 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d1113 1
a1113 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d1121 1
a1121 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d1129 1
a1129 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d1135 1
a1135 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d1220 1
a1220 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1255 1
a1255 1
      call MLSMessage ( MLSMSG_Warning, whereami, &
d1267 1
a1267 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1272 1
a1272 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1277 1
a1277 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1282 1
a1282 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1287 1
a1287 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1292 1
a1292 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1298 1
a1298 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1309 1
a1309 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1341 1
a1341 1
      call MLSMessage ( MLSMSG_Warning, whereami, &
d1358 1
a1358 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1364 1
a1364 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1370 1
a1370 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1376 1
a1376 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1382 1
a1382 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1388 1
a1388 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1395 1
a1395 1
      &  call MLSMessage ( MLSMSG_Warning, whereami, &
d1510 1
a1510 1
       "$Id: read_apriori.f90,v 2.124 2018/03/14 22:42:40 pwagner Exp $"
d1523 3
@


2.124
log
@May changeSettings in readApriori and MergeGrids sections
@
text
@d26 1
a26 1
    & S_L2aux, S_L2gp, S_ReadGriddedData
d151 2
a152 2
    use DumpCommand_M, only: BooleanFromFormula, ExecuteCommand, &
      & MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, Skip
d245 2
d1510 1
a1510 1
       "$Id: read_apriori.f90,v 2.123 2017/11/15 00:11:24 pwagner Exp $"
d1523 3
@


2.123
log
@Use OutputTable to Dump list of level 1 files
@
text
@d17 1
a17 1
  use HighOutput, only: OutputNamedValue
d25 2
a26 1
    & S_Diff, S_Dump, S_Execute, S_Gridded, S_L2aux, S_L2gp, S_ReadGriddedData
d39 2
a40 1
  use MLSMessagemodule, only: MLSMsg_Error, MLSMsg_Warning
d51 1
a51 1
  use Output_M, only: Output, RevertOutput, SwitchOutput
d239 6
d928 1
a928 1
          call outputNamedValue( 'climatology desc.', &
d1190 1
a1190 1
        call output( 'Calling getPCFromRef with ' // trim(subString), advance='yes' )
d1453 2
a1454 1
 
d1462 1
d1473 8
a1480 7

      call output ( ': ' )
      call output ( "The " );
      if ( lcf_where > 0 ) then
        call dump_tree_node ( lcf_where, 0 )
      else
        call output ( '(no lcf tree available)' )
d1508 1
a1508 1
       "$Id: read_apriori.f90,v 2.122 2017/08/08 20:46:28 vsnyder Exp $"
d1521 3
@


2.122
log
@Stop with error instead of seg fault if climatology not successfully read
@
text
@d49 1
a49 1
  use Output_M, only: Blanks, Output, RevertOutput, SwitchOutput
a324 1
    character(len=MAXSWATHNAMESBUFSIZE) :: ALLSWATHNAMES ! Buffer to get info back.
a325 1
    integer :: COMMAPOS                 ! For parsing string
a363 1
    integer :: LISTSIZE                 ! Size of string from SWInqSwath
a367 1
    integer :: NOSWATHS                 ! In an input file
a368 1
    type (MLSFile_T), pointer :: pL2AUXFile
a389 1
    allswathnames = ' '
d828 1
a828 1
            & call announce_success(FilenameString, 'geos5', &                    
d997 1
a997 2
   use L2AUXData, only: L2AUXData_t, AddL2AUXToDatabase, &
    &                  ReadL2AUXData
a1014 1
    integer :: L2Index             ! In the l2gp or l2aux database
d1051 1
a1051 1
      & Readl2GPData, Dump
d1393 1
a1393 1
  subroutine announce_success ( Name, l2_type, quantityName, &
d1395 5
a1399 2
    character(LEN=*), intent(in)   :: Name
    character(LEN=*), intent(in)   :: l2_type
d1401 1
a1401 1
    character(LEN=*), intent(in) :: quantityName
d1406 9
a1414 2
    call output ( 'Level 2 apriori product type : ' )
    call output ( trim(l2_type), advance='no' )
a1415 2
      call blanks(4)
      call output ( 'hdf ' )
d1421 1
a1421 1
      call output ( myhdfVersion, advance='no' )
d1423 4
a1426 7
    call output ( '', advance='yes' )
    call blanks(15)
    call output ( 'name:     ', advance='no' )
    call output ( trim(Name), advance='yes' )
    call blanks(15)
    call output ( 'quantity: ', advance='no' )           
    call output ( trim(quantityName), advance='yes' )      
d1497 1
a1497 1
       "$Id: read_apriori.f90,v 2.121 2017/07/10 23:04:52 pwagner Exp $"
d1510 3
@


2.121
log
@Print less if not verbose
@
text
@d918 8
a925 3
          if ( returnStatus /= 0 ) &
            & call Announce_error ( field, &                               
            & 'read_climatology unsuccessful--check file name and path') 
d1500 1
a1500 1
       "$Id: read_apriori.f90,v 2.120 2017/03/17 00:13:43 pwagner Exp $"
d1513 3
@


2.120
log
@runtime Boolean CarryOver given better chance to work properly
@
text
@d224 1
d734 1
a734 1
        call outputNamedvalue( 'LastGEOS5PCF', LastGEOS5PCF )
d886 9
a894 3
        call outputnamedValue ( 'fileNameString', trim(fileNameString) )
        call outputnamedValue ( 'noPCFid', noPCFid )
        call outputnamedValue ( 'returnStatus', returnStatus )
d920 3
a922 1
            & 'read_climatology unsuccessful--check file name and path')  
d1177 7
a1183 4
      ! call outputNamedValue ( 'fileNameString', trim(fileNameString) )
      ! call outputNamedValue ( 'got file?', gotFile )
      ! call output('PCFBottom, lastPCF: ')
      ! call output( (/ PCFBottom, lastPCF /), advance='yes' )
d1185 1
a1185 1
        call split_path_name ( fileNameString, path, subString )
d1495 1
a1495 1
       "$Id: read_apriori.f90,v 2.119 2017/03/07 21:21:01 pwagner Exp $"
d1508 3
@


2.119
log
@Support new meteorology origin: merra_2
@
text
@d197 11
d224 1
d733 1
d1483 1
a1483 1
       "$Id: read_apriori.f90,v 2.118 2017/01/13 01:31:40 pwagner Exp $"
d1496 3
@


2.118
log
@Avoid excess output when feeling around for right meteorology file type
@
text
@d15 22
a36 22
  use Expr_m, only: expr
  use HDF, only: dfacc_rdonly
  use HighOutput, only: outputNamedValue
  use Init_tables_module, only: f_auraInstrument, &
    & f_date, f_dimlist, f_downsample, &
    & f_field, f_file, f_grid, f_HDFVersion, f_missingvalue, f_noPCFid, &
    & f_origin, f_quantitytype, f_sdname, f_deferReading, f_sum, f_swath, &
    & field_first, field_last, &
    & l_climatology, l_dao, l_geos5, l_geos5_7, l_gloria, &
    & l_merra, l_ncep, l_none, l_strat, l_surfaceheight, &
    & s_diff, s_dump, s_execute, s_gridded, s_l2aux, s_l2gp, s_readGriddedData
  use Intrinsic, only: l_ascii, l_binary, l_hdfeos, l_hdf, l_swath, &
    & phyq_dimensionless
  use L2GPData, only: maxSwathNamesBufSize
  use Lexer_core, only: print_source
  use MLSCommon, only: filenamelen, MLSfile_t
  use MLSFiles, only: filenotfound, &
    & HDFVersion_4, HDFVersion_5, wildCardHDFVersion, &
    & AddFileToDatabase, MLS_CloseFile, dump, getPCFromRef, initializeMLSFile, &
    & MLS_HDF_Version, MLS_inqswath, MLS_openfile, split_path_name
  use MLSl2Options, only: checkPaths, default_HDFVersion_read, L2CFNode, &
    & RuntimeValues, specialDumpFile, toolkit, &
d38 1
a38 1
  use MLSMessagemodule, only: MLSMsg_error, MLSMsg_warning
d40 10
a49 10
    & MLSPCF_l2apriori_start, MLSPCF_l2apriori_end, &
    & MLSPCF_l2clim_start, MLSPCF_l2clim_end, &
    & MLSPCF_l2dao_start, MLSPCF_l2dao_end, &
    & MLSPCF_l2geos5_start, MLSPCF_l2geos5_end, &
    & MLSPCF_l2ncep_start, MLSPCF_l2ncep_end, &
    & MLSPCF_surfaceheight_start, MLSPCF_surfaceheight_end
  use MLSStringLists, only: catLists, GetHashElement, switchDetail
  use MLSStrings, only: lowercase
  use MoreTree, only: get_boolean
  use Output_m, only: blanks, output, revertOutput, switchOutput
d51 5
a55 5
  use SDPToolkit, only: pgs_s_success
  use String_table, only: get_string
  use Toggles, only: gen, switches, toggle
  use Tree, only: decorate, decoration, nsons, &
    &             sub_rosa, subtree, dump_tree_node, where
d149 12
a160 12
    use dumpCommand_m, only: booleanFromFormula, ExecuteCommand, &
      & MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, skip
    use griddedData, only: griddedData_t, dump
    use init_tables_module, only: s_boolean, s_case, s_endselect, &
      & s_select, s_skip
    use L2AUXData, only: L2AUXData_t, dump
    use L2GPData, only: L2GPData_t, dump
    use MLSL2Timings, only: section_times
    use moreTree, only: get_label_and_spec, get_spec_id
    use next_tree_node_m, only: next_tree_node, next_tree_node_state
    use trace_m, only: trace_begin, trace_end
    use tree, only: decorate
d281 15
a295 14
    use ChunkDivide_m, only: chunkDivideConfig
    use Dumpcommand_m, only: dumpcommand
    use GriddedData, only: rgr, griddedData_t, v_is_eta, v_is_pressure, &
      & AddGriddedDataToDatabase, copyGrid, &
      & DestroyGriddedData, downSampleGriddedData, dump, &
      & Setupnewgriddeddata
    use L2AUXData, only: L2AUXdata_t, addL2AUXtodatabase, &
      &                  dump
    use L2GPdata, only: l2GPdata_t, &
      & Addl2GPtodatabase, dump
    use Moretree, only: get_label_and_spec, get_spec_id
    use Ncep_dao, only: read_climatology, readgriddeddata, readgloriafile
    use Surfaceheight_m, only: open_surface_height_file, &
      & Read_surface_height_file, close_surface_height_file
d297 1
a297 1
    use Trace_m, only: trace_begin, trace_end
d720 1
a720 1
      case ( l_geos5, l_geos5_7, l_merra ) ! ------------ GMAO Data (GEOS5*)
d724 3
a726 1
        if (griddedOrigin == l_geos5_7) then ! since geos5_7 is HDF5
d731 1
a731 1
        else ! and the rest is HDF-EOS
d738 1
a738 1
        FileIndex = AddFileToDataBase(filedatabase, GriddedFile)
d759 9
a767 2
        if ( griddedOrigin == l_merra ) description = 'merra'
        if ( griddedOrigin == l_geos5_7 ) description = 'geos5_7'
d776 1
a776 1
          ! The gridded data needs to part of the database, even if the file
d976 2
a977 2
   use L2AUXData, only: L2AUXdata_t, addL2AUXtodatabase, &
    &                  readL2AUXdata
d1031 2
a1032 2
    use L2GPdata, only: l2GPdata_t, &
      & readl2GPdata, dump
d1124 3
a1126 3
      use MLSFiles, only: getpcfromref, split_path_name
      use MLSL2Options, only: toolkit
      use SDPToolkit, only: pgs_pc_getreference, pgs_s_success
d1128 1
a1128 1
      use Trace_m, only: trace_begin, trace_end
d1470 1
a1470 1
       "$Id: read_apriori.f90,v 2.117 2016/09/30 20:33:46 pwagner Exp $"
d1483 3
@


2.117
log
@verboser was used w/o being defined; fixed
@
text
@d697 4
a700 1
        if ( Griddeddatabase(gridIndex)%empty ) then
d715 1
a715 1
        else
d796 4
a799 1
        if ( Griddeddatabase(gridIndex)%empty ) then
d812 3
a814 3
        else
          call announce_success(FilenameString, 'geos5 not found--carry on', &                    
             & fieldNameString, MLSFile=GriddedFile)
d1460 1
a1460 1
       "$Id: read_apriori.f90,v 2.116 2016/09/21 00:41:04 pwagner Exp $"
d1473 3
@


2.116
log
@Default to printing less
@
text
@d192 1
a192 1
    verbose = ( Details > -2 )
d1454 1
a1454 1
       "$Id: read_apriori.f90,v 2.115 2016/07/28 01:45:07 vsnyder Exp $"
d1467 3
@


2.115
log
@Refactor dump and diff
@
text
@d183 1
d192 1
d202 1
a202 1
    if ( verbose ) call outputNamedValue( 'carryover', carryover )
d211 2
a212 2
    if ( verbose ) call outputNamedValue ( 'mlspcf_l2geos5_start', mlspcf_l2geos5_start )
    if ( verbose ) call outputNamedValue ( 'lastGEOS5PCF', lastGEOS5PCF )
d250 1
a250 1
    if( Details > -2 ) then
d1454 1
a1454 1
       "$Id: read_apriori.f90,v 2.114 2016/04/01 00:27:15 pwagner Exp $"
d1467 3
@


2.114
log
@May now Execute a single command or a script of lines from l2cf
@
text
@d128 1
a128 1
    use dump_0, only: dump
d286 1
a286 1
      &                  readL2AUXdata, dump
d288 1
a288 1
      & Addl2GPtodatabase, readl2GPdata, dump
d959 1
a959 1
    &                  readL2AUXdata, dump
d1452 1
a1452 1
       "$Id: read_apriori.f90,v 2.113 2015/11/17 21:28:07 pwagner Exp $"
d1465 3
@


2.113
log
@Made public processOneL2AUXFile and processOneL2GPFile
@
text
@d25 1
a25 1
    & s_diff, s_dump, s_gridded, s_l2aux, s_l2gp, s_readGriddedData
d149 2
a150 2
    use dumpCommand_m, only: booleanFromFormula, MLSCase, MLSEndSelect, &
      & MLSSelect, MLSSelecting, skip
d231 2
d1452 1
a1452 1
       "$Id: read_apriori.f90,v 2.112 2015/08/03 21:43:50 pwagner Exp $"
d1465 3
@


2.112
log
@Made quantityType optional in call to ReadL2AUXData
@
text
@d77 2
d86 5
a90 4
  public ::  APRIORIFILES, APRIORIFILES_T, &
    & DUMPAPRIORIATTRIBUTES, PROCESSONEAPRIORIFILE, &
    & READ_APRIORI, READAPRIORIATTRIBUTES, &
    & WRITEAPRIORIATTRIBUTES
d97 2
a98 2
   ! (This is very wasteful of memory--let's change it
   ! so that it one field is needed)
d347 1
d498 5
a502 60

      ! If we were given only a strand of the filename, expand it
      if ( TOOLKIT .and. .not. noPCFid ) then
        call split_path_name(FileNameString, path, SubString)
        LastAprioriPCF = GetPCFromRef(SubString, mlspcf_l2apriori_start, &
        & mlspcf_l2apriori_end, &                                     
        & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
        & exactName=FileNameString)                             
      end if
      hdfVersion = mls_hdf_version(FilenameString)

      FileIndex = InitializeMLSFile(L2GPFile, content = 'l2gp', &
        & name=FilenameString, shortName=shortFileName, &
        & type=l_swath, access=DFACC_RDONLY, hdfVersion=hdfVersion, &
        & PCBottom=mlspcf_l2apriori_start, PCTop=mlspcf_l2apriori_end)
      L2GPFile%PCFId = LastAprioriPCF
      FileIndex = AddFileToDataBase(filedatabase, L2GPFile)
      ! If we didn't get a name get the first swath name in the file
      if ( len_trim(swathNameString) == 0 ) then
        allSwathNames = ''
        noSwaths = mls_InqSwath ( fileNameString, allSwathNames, listSize, &
         & hdfVersion=hdfVersion)
        if ( listSize == FILENOTFOUND ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'File not found; make sure the name and path are correct' &
            & // trim(fileNameString), MLSFile=L2GPFile )
        else if ( listSize < 1 ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to determine swath names, perhaps none in file ' &
            & // trim(fileNameString), MLSFile=L2GPFile )
        else if ( listSize < len(allSwathNames) ) then
          commaPos = index ( allSwathNames, ',' )
          if ( commaPos == 0 ) then
            commaPos = len_trim(allSwathNames)
          else if ( commaPos == 1 ) then
            call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to determine swath name, allswathnames begin with , ' &
            & // trim(fileNameString), MLSFile=L2GPFile )
          else
            commaPos = commaPos - 1
          end if
          swathNameString = allSwathNames ( 1:commaPos )
        else
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to determine swath names, string too long.' &
            & // trim(fileNameString), MLSFile=L2GPFile )
        end if
      end if
      if ( swathNameString == ' ' ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Failed to determine swath name, obscure error on ' &
          & // trim(fileNameString), MLSFile=L2GPFile )
      end if

      ! Read the swath
      if ( HMOT /= ' ' ) then
        call ReadL2GPData ( L2GPFile, swathNameString, l2gp, HMOT=HMOT )
      else
        call ReadL2GPData ( L2GPFile, swathNameString, l2gp )
      end if
d513 2
a514 2
         call announce_success(FilenameString, 'l2gp', &                    
         & swathNameString, MLSFile=L2GPFile)    
a531 7
      if ( TOOLKIT .and. .not. noPCFid ) then
        call split_path_name(FileNameString, path, SubString)
        LastAprioriPCF = GetPCFromRef(SubString, mlspcf_l2apriori_start, &
        & mlspcf_l2apriori_end, &                                     
        & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
        & exactName=FileNameString)                             
      end if
a534 1

a537 7
      hdfVersion = mls_hdf_version(FilenameString)
      FileIndex = InitializeMLSFile(L2AUXFile, content = 'l2aux', &
        & name=FilenameString, shortName=shortFileName, &
        & type=l_hdf, access=DFACC_RDONLY, hdfVersion=hdfVersion, &
        & PCBottom=mlspcf_l2apriori_start, PCTop=mlspcf_l2apriori_end)
      ! call mls_openFile(L2AUXFile, returnStatus)
      L2AUXFile%PCFId = LastAprioriPCF
a538 1
      FileIndex = AddFileToDataBase(filedatabase, L2AUXFile)
d542 5
a547 6
      pL2AUXFile => filedatabase(FileIndex)
      call ReadL2AUXData ( pL2AUXFile, sdNameString, &
        & L2AUXDatabase(l2Index), &
        & quantityType, &
        & checkDimNames=.false. )

d595 1
a595 1
          & LastNCEPPCF, returnStatus, noPCFid )
d641 1
a641 1
          & LastDAOPCF, returnStatus, noPCFid )
d715 1
a715 1
          & LastGEOS5PCF, returnStatus, noPCFid )
d828 1
a828 1
          & LastClimPCF, returnStatus, noPCFid )
d851 1
a851 1
          & LastClimPCF, returnStatus, noPCFid )
d910 1
a910 1
          & lastHeightPCF, returnStatus, noPCFid )
d950 151
a1100 1
  contains
d1102 2
a1103 1
      & FirstPCF, LastPCF, Description, GotFile, PCF_Id, ReturnStatus, noPCFid )
d1107 2
d1120 2
d1134 1
a1159 4
  end subroutine processOneAprioriFile

  ! =========== Private ============

d1450 1
a1450 1
       "$Id: read_apriori.f90,v 2.111 2015/05/07 20:16:50 pwagner Exp $"
d1463 3
@


2.111
log
@Fixed error affecting noPCFid
@
text
@d611 1
a611 1
      call ReadL2AUXData ( pL2AUXFile, sdNameString, quantityType, &
d613 1
d1366 1
a1366 1
       "$Id: read_apriori.f90,v 2.110 2015/05/05 18:15:47 pwagner Exp $"
d1379 3
@


2.110
log
@/noPCFid field allows us to read from files not named in PCF
@
text
@d15 4
a18 4
  use expr_m, only: expr
  use hdf, only: dfacc_rdonly
  use highOutput, only: outputNamedValue
  use init_tables_module, only: f_auraInstrument, &
d26 1
a26 1
  use intrinsic, only: l_ascii, l_binary, l_hdfeos, l_hdf, l_swath, &
d29 1
a29 1
  use lexer_core, only: print_source
d32 6
a37 6
    & hdfversion_4, hdfversion_5, wildCardHDFVersion, &
    & addfiletodatabase, MLS_closefile, dump, getpcfromref, initializeMLSFile, &
    & MLS_hdf_version, MLS_inqswath, MLS_openfile, split_path_name
  use MLSl2Options, only: checkPaths, default_hdfversion_read, l2cfnode, &
    & runtimeValues, specialDumpFile, toolkit, &
    & dumpMacros, MLSMessage
d39 8
a46 8
  use MLSPcf2, only: &
    & MLSPcf_l2apriori_start, MLSPcf_l2apriori_end, &
    & MLSPcf_l2clim_start, MLSPcf_l2clim_end, &
    & MLSPcf_l2dao_start, MLSPcf_l2dao_end, &
    & MLSPcf_l2geos5_start, MLSPcf_l2geos5_end, &
    & MLSPcf_l2ncep_start, MLSPcf_l2ncep_end, &
    & MLSPcf_surfaceheight_start, MLSPcf_surfaceheight_end
  use MLSStringlists, only: catLists, GetHashElement, switchDetail
d48 2
a49 2
  use moreTree, only: get_boolean
  use output_m, only: blanks, output, revertOutput, switchOutput
d52 3
a54 3
  use string_table, only: get_string
  use toggles, only: gen, switches, toggle
  use tree, only: decorate, decoration, nsons, &
d919 3
d1050 1
a1050 1
      if ( TOOLKIT .and. gotFile ) then
d1365 1
a1365 1
       "$Id: read_apriori.f90,v 2.109 2014/10/07 00:08:45 pwagner Exp $"
d1378 3
@


2.109
log
@Higher details level of debug now required for most printing
@
text
@d20 1
a20 1
    & f_field, f_file, f_grid, f_HDFVersion, f_missingvalue, &
d146 3
a148 3
    use dumpcommand_m, only: booleanfromformula, MLScase, MLSendselect, &
      & MLSselect, MLSselecting, skip
    use griddeddata, only: griddeddata_t, dump
d151 4
a154 4
    use l2auxdata, only: l2auxdata_t, dump
    use l2gpdata, only: l2gpdata_t, dump
    use MLSl2timings, only: section_times
    use moretree, only: get_label_and_spec, get_spec_id
d274 14
a287 14
    use chunkdivide_m, only: chunkdivideconfig
    use dumpcommand_m, only: dumpcommand
    use griddeddata, only: rgr, griddeddata_t, v_is_eta, v_is_pressure, &
      & addgriddeddatatodatabase, copygrid, &
      & destroygriddeddata, downsamplegriddeddata, dump, &
      & setupnewgriddeddata
    use l2auxdata, only: l2auxdata_t, addl2auxtodatabase, &
      &                  readl2auxdata, dump
    use l2gpdata, only: l2gpdata_t, &
      & addl2gptodatabase, readl2gpdata, dump
    use moretree, only: get_label_and_spec, get_spec_id
    use ncep_dao, only: read_climatology, readgriddeddata, readgloriafile
    use surfaceheight_m, only: open_surface_height_file, &
      & read_surface_height_file, close_surface_height_file
d289 1
a289 1
    use Trace_m, only: TRACE_BEGIN, TRACE_END
d348 1
d397 1
d434 2
d496 1
a496 1
      if ( TOOLKIT ) then
d583 1
a583 1
      if ( TOOLKIT ) then
d662 1
a662 1
          & LastNCEPPCF, returnStatus )
d708 1
a708 1
          & LastDAOPCF, returnStatus )
d782 1
a782 1
          & LastGEOS5PCF, returnStatus )
d895 1
a895 1
          & LastClimPCF, returnStatus )
d918 1
a918 1
          & LastClimPCF, returnStatus )
d974 1
a974 1
          & lastHeightPCF, returnStatus )
d1016 4
a1019 4
      & FirstPCF, LastPCF, Description, GotFile, PCF_Id, ReturnStatus )
      use mlsfiles, only: getpcfromref, split_path_name
      use mlsl2options, only: toolkit
      use sdptoolkit, only: pgs_pc_getreference, pgs_s_success
d1030 1
d1052 1
a1052 1
      else if ( TOOLKIT ) then
d1188 1
a1188 1
    use MLSHDFEOS, only: MLS_EHWRGlatt, MLS_ISGlatt
d1362 1
a1362 1
       "$Id: read_apriori.f90,v 2.108 2014/10/02 17:24:00 pwagner Exp $"
d1375 3
@


2.108
log
@Added MiscNotes to file attributes we read and write
@
text
@d17 2
a18 2
  use highoutput, only: outputnamedvalue
  use init_tables_module, only: f_aurainstrument, &
d20 1
a20 1
    & f_field, f_file, f_grid, f_hdfversion, f_missingvalue, &
d25 1
a25 1
    & s_diff, s_dump, s_gridded, s_l2aux, s_l2gp, s_readgriddeddata
d28 1
a28 1
  use l2gpdata, only: maxswathnamesbufsize
d32 2
a33 2
    & hdfversion_4, hdfversion_5, wildcardhdfversion, &
    & addfiletodatabase, MLS_closefile, dump, getpcfromref, initializeMLSfile, &
d38 8
a45 8
  use MLSmessagemodule, only: MLSmsg_error, MLSmsg_warning
  use MLSpcf2, only: &
    & MLSpcf_l2apriori_start, MLSpcf_l2apriori_end, &
    & MLSpcf_l2clim_start, MLSpcf_l2clim_end, &
    & MLSpcf_l2dao_start, MLSpcf_l2dao_end, &
    & MLSpcf_l2geos5_start, MLSpcf_l2geos5_end, &
    & MLSpcf_l2ncep_start, MLSpcf_l2ncep_end, &
    & MLSpcf_surfaceheight_start, MLSpcf_surfaceheight_end
d179 1
d187 2
a188 1
    if( Details > -3 ) &     
d196 2
a197 2
    call dumpMacros
    call outputNamedValue( 'carryover', carryover )
d206 2
a207 2
    call outputNamedValue ( 'mlspcf_l2geos5_start', mlspcf_l2geos5_start )
    call outputNamedValue ( 'lastGEOS5PCF', lastGEOS5PCF )
d243 1
a243 1
    if( Details > -3 ) then
a306 2
    !logical, parameter :: DEBUG = .FALSE.
    logical :: DEBUG
d309 2
a357 1
    logical :: deferReading      ! skip reading the data; just note file name?
d365 1
d392 2
a393 1
    Debug = ( Details > -3 )
d551 1
a551 1
      if( Details > -3 ) then
d612 1
a612 1
      if( Details > -3 ) then
d675 1
a675 1
              & verbose=( Details > -3 ), deferReading=deferReading )
d684 1
a684 1
            & verbose=( Details > -3 ), deferReading=deferReading )
d737 1
a737 1
              & verbose=( Details > -3 ), deferReading=deferReading )
d747 1
a747 1
            & verbose=( Details > -3 ), deferReading=deferReading )
d833 1
a833 1
              & verbose=( Details > -3 ), deferReading=deferReading )
d843 1
a843 1
            & verbose=( Details > -3 ), deferReading=deferReading )
d879 1
a879 1
          if( details > -3 ) then                            
d994 1
a994 1
      if( Details > -3 .and. gridIndex <= size(griddedDatabase) ) then
d1357 1
a1357 1
       "$Id: read_apriori.f90,v 2.107 2014/09/05 01:27:33 vsnyder Exp $"
d1370 3
@


2.107
log
@Add some tracing
@
text
@d30 2
a31 2
  use MLScommon, only: filenamelen, MLSfile_t
  use MLSfiles, only: filenotfound, &
d50 1
d125 1
a125 1
    use DUMP_0, only: DUMP
d146 12
a157 12
    use DUMPCOMMAND_M, only: BOOLEANFROMFORMULA, MLSCASE, MLSENDSELECT, &
      & MLSSELECT, MLSSELECTING, SKIP
    use GRIDDEDDATA, only: GRIDDEDDATA_T, DUMP
    use INIT_TABLES_MODULE, only: S_BOOLEAN, S_CASE, S_ENDSELECT, &
      & S_SELECT, S_SKIP
    use L2AUXDATA, only: L2AUXDATA_T, DUMP
    use L2GPDATA, only: L2GPDATA_T, DUMP
    use MLSL2TIMINGS, only: SECTION_TIMES
    use MORETREE, only: Get_Label_And_Spec, GET_SPEC_ID
    use Next_Tree_Node_m, only: Next_Tree_Node, Next_Tree_Node_State
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATE
d272 14
a285 14
    use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG
    use DUMPCOMMAND_M, only: DUMPCOMMAND
    use GRIDDEDDATA, only: RGR, GRIDDEDDATA_T, V_IS_ETA, V_IS_PRESSURE, &
      & ADDGRIDDEDDATATODATABASE, COPYGRID, &
      & DESTROYGRIDDEDDATA, DOWNSAMPLEGRIDDEDDATA, DUMP, &
      & SETUPNEWGRIDDEDDATA
    use L2AUXDATA, only: L2AUXDATA_T, ADDL2AUXTODATABASE, &
      &                  READL2AUXDATA, DUMP
    use L2GPDATA, only: L2GPDATA_T, &
      & ADDL2GPTODATABASE, READL2GPDATA, DUMP
    use MORETREE, only: Get_Label_And_Spec, GET_SPEC_ID
    use NCEP_DAO, only: READ_CLIMATOLOGY, READGRIDDEDDATA, READGLORIAFILE
    use SURFACEHEIGHT_M, only: OPEN_SURFACE_HEIGHT_FILE, &
      & READ_SURFACE_HEIGHT_FILE, CLOSE_SURFACE_HEIGHT_FILE
d1010 3
a1012 3
      use MLSFILES, only: GETPCFROMREF, SPLIT_PATH_NAME
      use MLSL2OPTIONS, only: TOOLKIT
      use SDPTOOLKIT, only: PGS_PC_GETREFERENCE, PGS_S_SUCCESS
d1094 2
a1095 1
    use MLSHDFEOS, only: HE5_EHRDGLATT, MLS_ISGLATT
d1147 6
d1179 2
a1180 2
    use HDFEOS5, only: MLS_CHARTYPE
    use MLSHDFEOS, only: MLS_EHWRGLATT, MLS_ISGLATT
d1243 7
d1354 1
a1354 1
       "$Id: read_apriori.f90,v 2.106 2014/06/04 18:34:37 pwagner Exp $"
d1367 3
@


2.106
log
@runtime carryover flag starts PCFids at value from last readApriori section; may deferReading
@
text
@d202 1
a202 1
    endif
d252 1
a252 1
    endif
d285 2
d317 1
a317 1
    integer :: FieldName        ! sub-rosa index of name in field='name'
d333 1
a333 1
    integer :: J                ! Loop indices for section, spec
d343 1
d365 3
d384 1
a384 1
      return
d455 1
a455 1
    endif
d475 2
a476 2
      endif
    endif
d494 1
a494 1
      endif
d512 1
a512 1
        elseif ( listSize < 1 ) then
d516 1
a516 1
        elseif ( listSize < len(allSwathNames) ) then
d520 1
a520 1
          elseif ( commaPos == 1 ) then
d526 1
a526 1
          endif
d533 1
a533 1
      endif
d538 1
a538 1
      endif
d545 1
a545 1
      endif
d553 1
a553 1
      endif
d581 1
a581 1
      endif
d614 1
a614 1
      endif
d627 1
a627 1
      elseif ( .not. all(got((/f_origin, f_field/))) ) then
d631 1
a631 1
      endif
d674 1
a674 1
          endif
d676 1
a676 1
        elseif ( returnStatus == PGS_S_SUCCESS) then
d686 2
a687 2
          endif
        endif
d696 1
a696 1
        endif
d736 1
a736 1
          endif
d738 1
a738 1
        elseif ( returnStatus == PGS_S_SUCCESS) then
d750 2
a751 2
          endif
        endif
d755 1
a755 1
        elseif ( description == 'dao' ) then
d762 1
a762 1
        endif
d770 1
a770 1
        endif
d785 1
a785 1
        endif
d815 1
a815 1
        endif
d832 1
a832 1
          endif
d834 1
a834 1
        elseif ( returnStatus == PGS_S_SUCCESS) then
d846 2
a847 2
          endif
        endif
d856 1
a856 1
        endif
d864 1
a864 1
        endif
d880 1
a880 1
          endif
d883 1
a883 1
        endif
d905 1
a905 1
        endif
d938 1
a938 1
        if ( .not. associated(GriddedDatabase) ) return  ! Last chance
d997 1
a997 1
      endif
d1001 5
d1023 1
d1026 2
d1032 1
a1032 1
      endif
d1055 2
d1075 1
a1075 1
    elseif ( MLSFile%StillOpen ) then
d1083 1
a1083 1
      endif
d1086 1
a1086 1
    endif
d1108 1
a1108 1
    endif
d1113 1
a1113 1
    endif
d1157 1
a1157 1
    elseif ( MLSFile%StillOpen ) then
d1164 1
a1164 1
    endif
d1188 1
a1188 1
    endif
d1196 2
a1197 2
      endif
    endif
d1259 1
a1259 1
      endif
d1339 1
a1339 1
       "$Id: read_apriori.f90,v 2.105 2014/04/02 23:05:11 pwagner Exp $"
d1352 3
@


2.105
log
@Removed redundant open_ and close_MLSFile
@
text
@d15 40
a54 40
  use EXPR_M, only: EXPR
  use HDF, only: DFACC_RDONLY
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INIT_TABLES_MODULE, only: F_AURAINSTRUMENT, &
    & F_DATE, F_DIMLIST, F_DOWNSAMPLE, &
    & F_FIELD, F_FILE, F_GRID, F_HDFVERSION, F_MISSINGVALUE, &
    & F_ORIGIN, F_QUANTITYTYPE, F_SDNAME, F_SUM, F_SWATH, &
    & FIELD_FIRST, FIELD_LAST, &
    & L_CLIMATOLOGY, L_DAO, L_GEOS5, L_GEOS5_7, L_GLORIA, &
    & L_MERRA, L_NCEP, L_NONE, L_STRAT, L_SURFACEHEIGHT, &
    & S_DIFF, S_DUMP, S_GRIDDED, S_L2AUX, S_L2GP, S_READGRIDDEDDATA
  use Intrinsic, only: L_ASCII, L_BINARY, L_HDFEOS, L_HDF, L_SWATH, &
    & PHYQ_DIMENSIONLESS
  use L2GPDATA, only: MAXSWATHNAMESBUFSIZE
  use LEXER_CORE, only: PRINT_SOURCE
  use MLSCOMMON, only: FILENAMELEN, MLSFILE_T
  use MLSFILES, only: FILENOTFOUND, &
    & HDFVERSION_4, HDFVERSION_5, WILDCARDHDFVERSION, &
    & ADDFILETODATABASE, MLS_CloseFile, DUMP, GETPCFROMREF, INITIALIZEMLSFILE, &
    & MLS_HDF_VERSION, MLS_INQSWATH, MLS_OpenFile, SPLIT_PATH_NAME
  use MLSL2OPTIONS, only: CHECKPATHS, DEFAULT_HDFVERSION_READ, L2CFNODE, &
    & SPECIALDUMPFILE, TOOLKIT, &
    & MLSMESSAGE
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING
  use MLSPCF2, only: &
    & MLSPCF_L2APRIORI_START, MLSPCF_L2APRIORI_END, &
    & MLSPCF_L2CLIM_START, MLSPCF_L2CLIM_END, &
    & MLSPCF_L2DAO_START, MLSPCF_L2DAO_END, &
    & MLSPCF_L2GEOS5_START, MLSPCF_L2GEOS5_END, &
    & MLSPCF_L2NCEP_START, MLSPCF_L2NCEP_END, &
    & MLSPCF_SURFACEHEIGHT_START, MLSPCF_SURFACEHEIGHT_END
  use MLSSTRINGLISTS, only: CATLISTS, SWITCHDETAIL
  use MLSSTRINGS, only: LOWERCASE
  use MORETREE, only: GET_BOOLEAN
  use OUTPUT_M, only: BLANKS, OUTPUT, REVERTOUTPUT, SWITCHOUTPUT
  use SDPTOOLKIT, only: PGS_S_SUCCESS
  use STRING_TABLE, only: GET_STRING
  use TOGGLES, only: GEN, SWITCHES, TOGGLE
  use TREE, only: DECORATE, DECORATION, NSONS, &
    &             SUB_ROSA, SUBTREE, DUMP_TREE_NODE, Where
d88 1
d164 2
d168 6
a173 6
    integer :: LastAprioriPCF      ! l2gp or l2aux  apriori
    integer :: LastClimPCF         ! l3ascii or gloria format
    integer :: LastDAOPCF
    integer :: LastGEOS5PCF
    integer :: LastHeightPCF
    integer :: LastNCEPPCF
d186 19
a204 9
    & call output ( '============ Read APriori ============', advance='yes' )    
    LastAprioriPCF = mlspcf_l2apriori_start - 1
    lastClimPCF = mlspcf_l2clim_start - 1
    lastDAOPCF = mlspcf_l2dao_start - 1
    lastNCEPPCF = mlspcf_l2ncep_start - 1
    lastGEOS5PCF = mlspcf_l2geos5_start - 1
    LastHeightPCF = mlspcf_surfaceHeight_start - 1
    ! call outputNamedValue ( 'mlspcf_l2geos5_start', mlspcf_l2geos5_start )
    ! call outputNamedValue ( 'lastGEOS5PCF', lastGEOS5PCF )
d352 1
d385 1
d401 2
d458 4
d656 1
a656 1
          ! The gridded data needs to part of the database, even if the file
d665 1
a665 1
              & verbose=( Details > -3 ) )
d674 1
a674 1
            & verbose=( Details > -3 ) )
d677 1
a677 1
          if ( .not. tempGrid%empty ) then
d727 1
a727 1
              & verbose=( Details > -3 ) )
d737 1
a737 1
            & verbose=( Details > -3 ) )
d740 1
a740 1
          if ( .not. tempGrid%empty ) then
d822 2
a823 1
              & litDescription=litDescription, verbose=( Details > -3 ) )
d833 1
a833 1
            & verbose=( Details > -3 ) )
d836 1
a836 1
          if ( .not. tempGrid%empty ) then
d1323 1
a1323 1
       "$Id: read_apriori.f90,v 2.104 2014/01/11 01:52:15 vsnyder Exp $"
d1336 3
@


2.104
log
@Get OutputNamedValue from HighOutput, not Output_m.  Getting it from
Output_m crept back in during CVS conflict resolution.
@
text
@d33 2
a34 2
    & ADDFILETODATABASE, CLOSE_MLSFILE, DUMP, GETPCFROMREF, INITIALIZEMLSFILE, &
    & MLS_HDF_VERSION, MLS_INQSWATH, OPEN_MLSFILE, SPLIT_PATH_NAME
d1041 1
a1041 1
      call open_MLSFile( MLSFile )
d1047 1
a1047 1
      call close_MLSFile( MLSFile )
d1122 1
a1122 1
      call open_MLSFile( MLSFile )
d1125 1
a1125 1
      call close_MLSFile( MLSFile )
d1301 1
a1301 1
       "$Id: read_apriori.f90,v 2.103 2014/01/11 01:44:18 vsnyder Exp $"
d1314 4
@


2.103
log
@Decruftification
@
text
@d49 1
a49 2
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE, &
    & REVERTOUTPUT, SWITCHOUTPUT
d1301 1
a1301 1
       "$Id: read_apriori.f90,v 2.102 2014/01/09 00:30:24 pwagner Exp $"
d1314 3
@


2.102
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d48 2
a49 2
  use MORETREE, only: GET_BOOLEAN, GET_SPEC_ID
  use OUTPUT_M, only: BLANKS, OUTPUT, &
a52 1
  use TIME_M, only: TIME_NOW
d54 1
a54 1
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, &
d156 1
a156 1
    use TREE, only: DECORATE, NSONS, SUBTREE
a164 1
    integer :: I
a342 1
    logical :: TIMING
d1302 1
a1302 1
       "$Id: read_apriori.f90,v 2.101 2013/12/12 02:11:26 vsnyder Exp $"
d1315 3
@


2.101
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d17 1
d49 1
a49 1
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE, &
d1305 1
a1305 1
       "$Id: read_apriori.f90,v 2.100 2013/10/09 23:43:41 vsnyder Exp $"
d1318 3
@


2.100
log
@Add Evaluate_Variable
@
text
@a55 1
  use TREE_TYPES, only: N_NAMED
a146 1
    use Evaluate_Variable_m, only: Evaluate_Variable
d153 2
a156 1
    use TREE_TYPES, only: N_NAMED, N_Variable
d176 1
d195 4
a198 12
    do i = 2, nsons(root)-1 ! Skip the section name at begin and end
      son = subtree(i,root)
      if ( node_id(son) == n_variable ) then
        call evaluate_variable ( son )
    cycle
      end if
      if ( node_id(son) == n_named ) then ! Is spec labed?
        key = subtree ( 2, son )
        name = sub_rosa ( subtree(1,son) )
      else
        key = son
      end if
d270 1
d357 3
a359 7
    if ( node_id(root) == n_named ) then ! Is spec labeled?
      key = subtree(2,root)
      l2Name = sub_rosa(subtree(1,root))
    else
      key = root
      l2Name = 0
    end if
a377 1
    son = root
d1304 1
a1304 1
       "$Id: read_apriori.f90,v 2.99 2013/09/24 23:47:23 vsnyder Exp $"
d1317 3
@


2.99
log
@Use Where instead of Source_Ref for messages
@
text
@d148 1
d157 1
a157 1
    use TREE_TYPES, only: N_NAMED
d197 4
d1316 1
a1316 1
       "$Id: read_apriori.f90,v 2.98 2013/08/30 02:45:51 vsnyder Exp $"
d1329 3
@


2.98
log
@Revise calls to trace_begin and trace_end
@
text
@d55 1
a55 1
    &             SUB_ROSA, SUBTREE, DUMP_TREE_NODE, SOURCE_REF
d1273 1
a1273 1
          call print_source ( source_ref(lcf_where) )
d1311 1
a1311 1
       "$Id: read_apriori.f90,v 2.97 2013/08/12 23:49:41 pwagner Exp $"
d1324 3
@


2.97
log
@FindSomethings moved to MLSFinds module
@
text
@d37 1
a37 3
  use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES
  use MLSMESSAGEMODULE, only: MLSMESSAGECALLS, &
    & MLSMSG_ERROR, MLSMSG_WARNING
a53 1
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
d153 2
d173 3
a175 4
    integer :: NAME                     ! Index into string table
    integer :: SON              ! Of root, an n_spec_args or a n_named
    real :: T1, T2                      ! for timing
    logical :: TIMING
d177 1
a178 8
    if ( toggle(gen) ) then
      call trace_begin ( "read_apriori", root )
    else
      call MLSMessageCalls( 'push', constantName=ModuleName )
    endif

    timing = section_times
    if ( timing ) call time_now ( t1 )
a248 11
    
    if ( toggle(gen) ) then
      call trace_end("read_apriori")
    else
      call MLSMessageCalls( 'pop' )
    endif
  
    if ( timing ) call sayTime
    return

  contains
d250 1
a250 11
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for read_apriori = " )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime
a378 1
    timing = section_times
d1311 1
a1311 1
       "$Id: read_apriori.f90,v 2.96 2013/02/12 18:13:01 pwagner Exp $"
d1324 3
@


2.96
log
@Raise -Sapr switch setting needed to become verbose
@
text
@d128 1
a128 1
    use dump_0, only: dump
d1017 3
a1019 3
      use MLSFiles, only: GETPCFROMREF, SPLIT_PATH_NAME
      use MLSL2Options, only: TOOLKIT
      use SDPToolkit, only: PGS_PC_GETREFERENCE, PGS_S_SUCCESS
d1342 1
a1342 1
       "$Id: read_apriori.f90,v 2.95 2012/08/16 17:50:42 pwagner Exp $"
d1355 3
@


2.95
log
@Exploit level 2-savvy MLSMessage
@
text
@d16 1
a16 1
  use HDF, only: DFACC_RDonly
d88 4
a91 4
  public ::  APrioriFiles, APrioriFiles_T, &
    & dumpAPrioriAttributes, processOneAprioriFile, &
    & read_apriori, readAPrioriAttributes, &
    & writeAPrioriAttributes
d152 2
a153 1
    use INIT_TABLES_MODULE, only: S_BOOLEAN, S_CASE, S_ENDSELECT, S_SELECT, S_SKIP
d1071 1
a1071 1
    verbose = ( switchDetail(switches, 'apr') > -1 )
d1105 1
a1105 1
    verbose = ( switchDetail(switches, 'apr') > -1 )
d1185 1
a1185 1
    verbose = ( switchDetail(switches, 'apr') > -1 )
d1342 1
a1342 1
       "$Id: read_apriori.f90,v 2.94 2012/05/08 17:50:31 pwagner Exp $"
d1355 3
@


2.94
log
@Added Select .. Case .. EndSelect control structure
@
text
@d34 3
a36 2
  use MLSL2OPTIONS, only: CHECKPATHS, DEFAULT_HDFVERSION_READ, SPECIALDUMPFILE, &
    & TOOLKIT
d38 1
a38 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMESSAGECALLS, &
d210 1
d418 1
d1016 1
a1016 1
      use MLSFiles, only: GetPCFromRef, SPLIT_PATH_NAME
d1018 1
a1018 1
      use SDPToolkit, only: Pgs_pc_getReference, PGS_S_SUCCESS
d1341 1
a1341 1
       "$Id: read_apriori.f90,v 2.93 2012/03/12 17:31:59 pwagner Exp $"
d1354 3
@


2.93
log
@New api for writeAPrioriAttributes; can avoid replacing if already written
@
text
@d148 2
d151 1
d154 2
a155 1
    use TREE, only: NSONS, SUBTREE
d165 1
d172 1
d203 34
a236 10
      call processOneAprioriFile ( son, L2GPDatabase, L2auxDatabase, &
        & GriddedDatabase, fileDataBase, &
        & LastAprioriPCF , &
        & LastClimPCF    , &
        & LastDAOPCF     , &
        & LastGEOS5PCF   , &
        & LastHeightPCF  , &
        & LastNCEPPCF     &
          )

d238 13
a250 12
    
    call output( '------------------- apriori datatypes --------------', advance='yes' )
    call output ( 'l2gp', advance='yes' )
    call dump( trim(APrioriFiles%l2gp), 'l2gp files' )
    call output ( 'l2aux', advance='yes' )
    call dump( trim(APrioriFiles%l2aux), 'l2aux files' )
    call output ( 'ncep', advance='yes' )
    call dump( trim(APrioriFiles%ncep), 'ncep files' )
    call output ( 'dao', advance='yes' )
    call dump( trim(APrioriFiles%dao), 'dao files' )
    call output ( 'geos5', advance='yes' )
    call dump( trim(APrioriFiles%geos5), 'geos5 files' )
d411 1
d1002 2
a1003 1
        call dump( GriddedDatabase(gridIndex), details )
d1338 1
a1338 1
       "$Id: read_apriori.f90,v 2.92 2012/02/24 21:16:06 pwagner Exp $"
d1351 3
@


2.92
log
@Read/Write geos5description attributes, too
@
text
@d1032 1
d1034 2
d1042 1
d1046 4
d1059 1
a1059 1
    use MLSHDFEOS, only: HE5_EHRDGLATT
d1065 2
d1068 2
d1071 1
a1071 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1075 5
d1083 1
a1083 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1088 1
a1088 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1093 1
a1093 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1098 1
a1098 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1103 1
a1103 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1108 1
a1108 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1114 1
a1114 1
  subroutine writeAPrioriAttributes_MF ( MLSFile )
d1116 1
d1134 1
a1134 1
  subroutine writeAPrioriAttributes_ID ( fileID, hdfVersion )
d1137 2
a1138 2
    use HDFEOS5, only: MLS_charType
    use MLSHDFEOS, only: mls_EHwrglatt
d1142 2
d1146 1
d1148 2
d1151 1
a1151 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1155 9
d1168 1
a1168 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1174 1
a1174 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1180 1
a1180 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1186 1
a1186 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1192 1
a1192 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1198 1
a1198 1
      &  call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1305 1
a1305 1
       "$Id: read_apriori.f90,v 2.91 2011/08/03 21:59:39 pwagner Exp $"
d1318 3
@


2.91
log
@Reduced default verbosity by making debug switchable
@
text
@d1067 1
a1067 1
      & 'Problem writing APrioriFiles%l2gp' // trim(APrioriFiles%l2gp) )
d1072 1
a1072 1
      & 'Problem writing APrioriFiles%l2aux' // trim(APrioriFiles%l2aux) )
d1077 1
a1077 1
      & 'Problem writing APrioriFiles%ncep' // trim(APrioriFiles%ncep) )
d1082 1
a1082 1
      & 'Problem writing APrioriFiles%dao' // trim(APrioriFiles%dao) )
d1087 7
a1093 1
      & 'Problem writing APrioriFiles%geos5' // trim(APrioriFiles%geos5) )
d1162 7
d1273 1
a1273 1
       "$Id: read_apriori.f90,v 2.90 2011/07/13 14:24:46 honghanh Exp $"
d1286 3
@


2.90
log
@Initialize GEOS5.7 file type with l_hdf instead of l_hdfeos
@
text
@d289 2
a290 1
    logical, parameter :: DEBUG = .TRUE.
d374 1
d1260 1
a1260 1
       "$Id: read_apriori.f90,v 2.89 2011/07/12 22:35:03 honghanh Exp $"
d1273 3
@


2.89
log
@Change l_grid to l_hdfeos
@
text
@d751 11
a761 4
        FileIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
          & name=FilenameString, shortName=shortFileName, &
          & type=l_hdfeos, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
          & PCBottom=mlspcf_l2geos5_start, PCTop=mlspcf_l2geos5_end)
d1258 1
a1258 1
       "$Id: read_apriori.f90,v 2.88 2011/06/16 23:16:27 pwagner Exp $"
d1271 3
@


2.88
log
@Added /downsample to reduce resolution of gridded data when read
@
text
@d25 1
a25 1
  use INTRINSIC, only: L_ASCII, L_BINARY, L_GRID, L_HDF, L_SWATH, &
d633 1
a633 1
          & type=l_grid, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
d679 1
a679 1
          & type=l_grid, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
d753 1
a753 1
          & type=l_grid, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
d1251 1
a1251 1
       "$Id: read_apriori.f90,v 2.87 2011/05/26 20:45:15 pwagner Exp $"
d1264 3
@


2.87
log
@Should not bomb with 'pro' set in switches
@
text
@d15 4
a18 3
  use Expr_M, only: EXPR
  use Hdf, only: DFACC_RDONLY
  use INIT_TABLES_MODULE, only: F_AURAINSTRUMENT, F_DATE, F_DIMLIST, &
d25 1
a25 1
  use Intrinsic, only: L_ASCII, L_BINARY, L_GRID, L_HDF, L_SWATH, &
d27 1
a27 1
  use L2GPData, only: MAXSWATHNAMESBUFSIZE
d29 2
a30 2
  use MLSCommon, only: FILENAMELEN, MLSFILE_T
  use MLSFiles, only: FILENOTFOUND, &
d34 1
a34 1
  use MLSL2Options, only: CHECKPATHS, DEFAULT_HDFVERSION_READ, SPECIALDUMPFILE, &
d36 2
a37 2
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
  use MLSMessageModule, only: MLSMESSAGE, MLSMESSAGECALLS, &
d46 3
a48 3
  use MLSStringLists, only: CATLISTS, SWITCHDETAIL
  use MLSStrings, only: LOWERCASE
  use MoreTree, only: GET_BOOLEAN, GET_SPEC_ID
d51 3
a53 3
  use SDPToolkit, only: PGS_S_SUCCESS
  use String_Table, only: GET_STRING
  use Time_M, only: TIME_NOW
d148 3
a150 3
    use GriddedData, only: GRIDDEDDATA_T, DUMP
    use L2AUXData, only: L2AUXDATA_T, DUMP
    use L2GPData, only: L2GPDATA_T, DUMP
d259 5
a263 4
    use ChunkDivide_m, only: CHUNKDIVIDECONFIG
    use DumpCommand_m, only: DUMPCOMMAND
    use GriddedData, only: RGR, GRIDDEDDATA_T, V_IS_ETA, V_IS_PRESSURE, &
      & ADDGRIDDEDDATATODATABASE, COPYGRID, DESTROYGRIDDEDDATA, DUMP, &
d265 1
a265 1
    use L2AUXData, only: L2AUXDATA_T, ADDL2AUXTODATABASE, &
d267 1
a267 1
    use L2GPData, only: L2GPDATA_T, &
d269 2
a270 2
    use ncep_dao, only: READ_CLIMATOLOGY, READGRIDDEDDATA, READGLORIAFILE
    use SurfaceHeight_m, only: OPEN_SURFACE_HEIGHT_FILE, &
d296 1
d374 1
d391 2
d833 19
d1251 1
a1251 1
       "$Id: read_apriori.f90,v 2.86 2011/05/05 17:02:34 pwagner Exp $"
d1264 3
@


2.86
log
@Added readGriddedData command to readApriori section
@
text
@d577 1
a577 1
      ! if( index(switches, 'apr') /= 0 ) then
d892 8
a899 3
          if( switchDetail(switches, 'pro') > -1 ) then                            
            call announce_success(FilenameString, 'climatology', &                  
             & fieldNameString, MLSFile=GriddedFile)
d933 1
a933 1
      if( Details > -3 ) then
d1226 1
a1226 1
       "$Id: read_apriori.f90,v 2.85 2011/04/27 17:39:56 pwagner Exp $"
d1239 3
@


2.85
log
@Consistent with new ncep_dao api
@
text
@d15 1
a15 1
  use Expr_M, only: Expr
d18 1
a18 1
    & F_FIELD, F_FILE, F_HDFVERSION, F_MISSINGVALUE, &
d23 1
a23 1
    & S_DIFF, S_DUMP, S_GRIDDED, S_L2AUX, S_L2GP
d28 1
a28 1
  use MLSCommon, only: FileNameLen, MLSFile_T
d31 2
a32 2
    & AddFileToDataBase, close_MLSFile, Dump, GetPCFromRef, InitializeMLSFile, &
    & MLS_HDF_VERSION, MLS_INQSWATH, open_MLSFile, SPLIT_PATH_NAME
d36 2
a37 2
  use MLSMessageModule, only: MLSMessage, MLSMessageCalls, &
    & MLSMSG_Error, MLSMSG_Warning
d39 9
a47 9
    & mlspcf_l2apriori_start, mlspcf_l2apriori_end, &
    & mlspcf_l2clim_start, mlspcf_l2clim_end, &
    & mlspcf_l2dao_start, mlspcf_l2dao_end, &
    & mlspcf_l2geos5_start, mlspcf_l2geos5_end, &
    & mlspcf_l2ncep_start, mlspcf_l2ncep_end, &
    & mlspcf_surfaceHeight_start, mlspcf_surfaceHeight_end
  use MLSStringLists, only: catLists, SWITCHDETAIL
  use MLSStrings, only: lowercase
  use MoreTree, only: Get_BOOLEAN, Get_Spec_ID
d49 1
a49 1
    & revertoutput, switchOutput
d51 2
a52 2
  use String_Table, only: DISPLAY_STRING, GET_STRING
  use Time_M, only: Time_Now
d147 3
a149 3
    use GriddedData, only: GriddedData_T, Dump
    use L2AUXData, only: L2AUXData_T, Dump
    use L2GPData, only: L2GPData_T, Dump
d258 12
a269 11
    use ChunkDivide_m, only: ChunkDivideConfig
    use DumpCommand_m, only: DumpCommand
    use GriddedData, only: rgr, GriddedData_T, V_is_eta, v_is_pressure, &
      & AddGriddedDataToDatabase, Dump, SetupNewGriddedData
    use L2AUXData, only: L2AUXData_T, AddL2AUXToDatabase, &
      &                  ReadL2AUXData, Dump
    use L2GPData, only: L2GPData_T, &
      & AddL2GPToDatabase, ReadL2GPData, Dump
    use ncep_dao, only: READ_CLIMATOLOGY, ReadGriddedData, ReadGloriaFile
    use SurfaceHeight_m, only: Open_Surface_Height_File, &
      & Read_Surface_Height_File, Close_Surface_Height_File
d287 1
a287 1
    logical, parameter :: DEBUG = .FALSE.
d290 1
d300 1
d304 3
a306 1
    type (griddedData_T) :: GriddedData1
a309 1
    logical :: GotAlready               ! Do we need to reread this file?
a317 1
    type (MLSFile_T), pointer :: pL2AUXFile
d327 1
d330 2
a333 2
    integer :: SdName        ! sub-rosa index of name in sdName='name'
    character(len=FileNameLen) :: SDNAMESTRING ! actual literal sdName
a343 1
    character(len=8) :: description
d345 1
d373 1
d391 2
d403 1
a403 1
        griddedOrigin = decoration(subtree(2,subtree(j,key)))
d405 1
a405 1
        quantityType = decoration(subtree(2,subtree(j,key)))
d437 10
d467 1
a467 1
      gridIndex = InitializeMLSFile(L2GPFile, content = 'l2gp', &
d472 1
a472 1
      gridIndex = AddFileToDataBase(filedatabase, L2GPFile)
d560 1
a560 1
      gridIndex = InitializeMLSFile(L2AUXFile, content = 'l2aux', &
d567 1
a567 1
      gridIndex = AddFileToDataBase(filedatabase, L2AUXFile)
d572 1
a572 1
      pL2AUXFile => filedatabase(gridIndex)
d605 3
d612 1
a612 1
        gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData1 )
d615 1
d625 1
a625 1
        gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
d630 17
a646 7
        gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
        ! The gridded data needs to part of the database, even if the file
        ! won't be found and the gridded data empty,
        ! so it can be merged w/o segment faulting
        gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData1 )
        call decorate ( key, gridIndex )
        if ( returnStatus == PGS_S_SUCCESS) then
d648 9
a656 4
            & v_is_pressure, GriddedDatabase(gridIndex), returnStatus, &
            & dimListString, TRIM(fieldNameString), missingValue )
        else
          call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
d671 1
a671 1
        gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
d676 1
a676 6
        gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
        ! The gridded data needs to part of the database, even if the file
        ! won't be found and the gridded data empty,
        ! so it can be merged w/o segment faulting
        gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData1 )
        call decorate ( key, gridIndex )
d690 19
a708 1
        if ( returnStatus == PGS_S_SUCCESS) then
d710 1
a710 1
            & GriddedDatabase(gridIndex), returnStatus, &
d712 8
a719 11
            & missingValue, litDescription=litDescription )
          if ( Griddeddatabase(gridIndex)%empty ) then
            call output( 'File was probably not ' // &
              & trim(litDescription), advance='yes' )
          elseif ( description == 'dao' ) then
            apriorifiles%dao = catlists(apriorifiles%dao, trim(FilenameString))
          else
            apriorifiles%geos5 = &
              & catlists(apriorifiles%geos5, trim(FilenameString))
            apriorifiles%geos5Description = &
              & catlists(apriorifiles%geos5Description, trim(litDescription))
d721 6
d728 4
a731 1
          call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
a741 2
        ! call outputNamedValue ( 'fileNameString', trim(fileNameString) )
        ! call outputNamedValue ( 'LastGEOS5PCF', LastGEOS5PCF )
d745 1
a745 1
        gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
d750 1
a750 6
        gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
        ! The gridded data needs to part of the database, even if the file
        ! won't be found and the gridded data empty,
        ! so it can be merged w/o segment faulting
        gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData1 )
        call decorate ( key, gridIndex )
d777 1
d779 18
a796 1
        if ( returnStatus == PGS_S_SUCCESS) then
d798 1
a798 1
            & GriddedDatabase(gridIndex), returnStatus, &
d800 8
a807 9
            & missingValue, dateString, sumDelp, litDescription=litDescription )
          if ( Griddeddatabase(gridIndex)%empty ) then
            call output( 'File was probably not ' // &
              & trim(litDescription), advance='yes' )
          else
            apriorifiles%geos5 = &
              & catlists(apriorifiles%geos5, trim(FilenameString))
            apriorifiles%geos5Description = &
              & catlists(apriorifiles%geos5Description, trim(litDescription))
d809 4
d814 4
a817 1
          call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
d836 1
a836 1
        gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
d841 1
a841 1
        gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
d866 1
a866 1
          gridIndex = InitializeMLSFile(GriddedFile, content = 'clim', &
d871 1
a871 1
          gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
d910 1
a910 1
        gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
d915 1
a915 1
        gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
d1221 1
a1221 1
       "$Id: read_apriori.f90,v 2.84 2011/04/20 16:54:28 pwagner Exp $"
d1234 3
@


2.84
log
@Added new flexibility to l2cf control flow by run-time booleans affecting gridded data
@
text
@d61 25
d87 2
a88 1
    & processOneAprioriFile, read_apriori, readAPrioriAttributes, &
d98 1
a98 1
    character (len=MAXNUMFILES*FileNameLen) :: l2gp = ''
d100 2
a101 2
    character (len=MAXNUMFILES*FileNameLen) :: ncep = ''
    character (len=MAXNUMFILES*FileNameLen) :: dao = ''
d103 1
d120 1
a120 5
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: read_apriori.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
d122 18
a139 1
contains ! =====     Public Procedures     =============================
d320 1
d663 12
a674 1
            & missingValue )
a685 6
        if ( description == 'dao' ) then
          apriorifiles%dao = catlists(apriorifiles%dao, trim(FilenameString))
        else
          apriorifiles%geos5 = &
            & catlists(apriorifiles%geos5, trim(FilenameString))
        endif
d734 10
a743 1
            & missingValue, dateString, sumDelp )
a754 2
        apriorifiles%geos5 = catlists(apriorifiles%geos5, trim(FilenameString))
        ! error = 1
d1044 1
a1044 1
      & 'Problem writing APrioriFiles%geos5' // trim(APrioriFiles%dao) )
d1149 1
a1149 1
       "$Id: read_apriori.f90,v 2.83 2010/11/09 02:37:28 vsnyder Exp $"
d1162 3
@


2.83
log
@Spiff up a dump
@
text
@d18 1
a18 1
    & F_FIELD, F_FILE, F_HDFVERSION, F_missingValue, &
d20 3
a22 2
    & FIELD_FIRST, FIELD_LAST, L_CLIMATOLOGY, L_DAO, L_GEOS5, L_GLORIA, &
    & L_MERRA, L_NCEP, L_STRAT, L_SURFACEHEIGHT, &
d24 3
a26 1
  use Intrinsic, only: l_ascii, L_Binary, l_grid, l_hdf, l_swath, PHYQ_Dimensionless
d51 1
a51 1
  use String_Table, only: GET_STRING
d62 2
a63 1
    & read_apriori, readAPrioriAttributes, writeAPrioriAttributes
d66 1
a66 1
  integer, private, parameter :: MAXNUMFILES = 10
d106 59
a164 1
    & fileDataBase)
d166 52
d224 1
a224 1
    use L2GPData, only: L2GPData_T, MAXSWATHNAMESBUFSIZE, &
d236 6
a241 1

d243 1
d260 1
a260 2
    integer :: FileType            ! either s_l2gp or s_l2aux
    logical, dimension(field_first:field_last) :: GOT
d266 1
d269 2
a270 1
    integer :: I, J                ! Loop indices for section, spec
a271 1
    integer :: L2apriori_version
a278 6
    integer :: LastAprioriPCF      ! l2gp or l2aux  apriori
    integer :: LastClimPCF         ! l3ascii or gloria format
    integer :: LastDAOPCF
    integer :: LastGEOS5PCF
    integer :: LastHeightPCF
    integer :: LastNCEPPCF
a292 1
    real :: T1, T2                      ! for timing
a298 1
    character(len=MAXSWATHNAMESBUFSIZE) :: ALLSWATHNAMES ! Buffer to get info back.
d300 17
d318 57
a374 2
    if ( toggle(gen) ) then
      call trace_begin ( "read_apriori", root )
d376 5
a380 1
      call MLSMessageCalls( 'push', constantName=ModuleName )
d383 25
a407 3
    timing = section_times
    if ( timing ) call time_now ( t1 )
    error = 0
d409 42
a450 13
    ! Will we be dumping info? To what level of detail?
    Details = switchDetail(switches, 'apr') - 2
    if( Details > -3 ) &     
    & call output ( '============ Read APriori ============', advance='yes' )    
    allswathnames = ' '
    LastAprioriPCF = mlspcf_l2apriori_start - 1
    lastClimPCF = mlspcf_l2clim_start - 1
    lastDAOPCF = mlspcf_l2dao_start - 1
    lastNCEPPCF = mlspcf_l2ncep_start - 1
    lastGEOS5PCF = mlspcf_l2geos5_start - 1
    LastHeightPCF = mlspcf_surfaceHeight_start - 1
    ! call outputNamedValue ( 'mlspcf_l2geos5_start', mlspcf_l2geos5_start )
    ! call outputNamedValue ( 'lastGEOS5PCF', lastGEOS5PCF )
d452 3
a454 9
    do i = 2, nsons(root)-1 ! Skip the section name at begin and end
      hdfVersion = DEFAULT_HDFVERSION_READ
      HMOT = ' '
      L2apriori_version = 1
      got = .false.
      son = subtree(i,root)
      if ( node_id(son) == n_named ) then ! Is spec labeled?
        key = subtree(2,son)
        l2Name = sub_rosa(subtree(1,son))
d456 14
a469 2
        key = son
        l2Name = 0
d471 1
d473 54
a526 1
      ! Node_id(key) is now n_spec_args.
d528 3
a530 5
      FileType = get_spec_id(key)

      if ( any( fileType == (/s_diff, s_dump/) ) ) then
        if ( .not. CHECKPATHS ) call dumpCommand ( key, griddedDataBase=griddedDataBase )
        cycle
d532 1
d534 1
a534 40
      ! Now parse file and field names
      sumDelp = .false.
      fileName = 0
      swathName = 0
      do j = 2, nsons(key)
        field = subtree(j,key)
        fieldIndex = decoration(subtree(1,field))
        got(fieldIndex) = .true.
        select case ( fieldIndex )
        case ( f_AuraInstrument )
          AuraInst = sub_rosa(subtree(2,field))
        case ( f_date )
          date = sub_rosa(subtree(2,field))
        case ( f_dimList )
          dimList = sub_rosa(subtree(2,field))
        case ( f_field )
          fieldName = sub_rosa(subtree(2,field))
        case ( f_file )
          fileName = sub_rosa(subtree(2,field))
        case ( f_missingValue )
          call expr ( subtree(2,field), expr_units, expr_value )
          missingValue = expr_value(1)
        case ( f_hdfVersion )           
          call expr ( subtree(2,field), units, value, type )             
          if ( units(1) /= phyq_dimensionless ) &                        
            & call Announce_error ( field, &                               
              & 'No units allowed for hdfVersion: just integer 4 or 5')  
          hdfVersion = value(1)                                          
        case ( f_origin )
          griddedOrigin = decoration(subtree(2,subtree(j,key)))
        case ( f_quantityType )
          quantityType = decoration(subtree(2,subtree(j,key)))
        case ( f_sum )
          sumDelp = get_boolean(field)
        case ( f_swath )
          swathName = sub_rosa(subtree(2,field))
        case ( f_sdname )
          sdname = sub_rosa(subtree(2,field))
        end select
      end do
d536 5
a540 2
      if ( got(f_dimList) ) then
        call get_string ( dimList, dimListString, strip=.true. )
d542 1
a542 11
        dimListString = ''
      end if
        
      if ( got(f_date) ) then
        call get_string ( date, dateString, strip=.true. )
      else
        dateString = ''
      end if
        
      if ( got(f_AuraInstrument) ) then
        call get_string ( AuraInst, HMOT, strip=.true. )
d545 44
a588 23
      if ( got(f_file) ) then
        call get_string ( FileName, fileNameString, strip=.true. )
      else
        fileNameString = ''
      end if
      shortFileName = fileNameString
        
      select case ( FileType )
      case ( s_l2gp )
        if ( .not. got(f_file) ) &
          & call announce_error ( son, &
            & 'Filename name must be specified in read a priori' )
        swathNameString=''
        if ( got(f_swath) ) &
          & call get_string ( swathName, swathNameString, strip=.true. )

        ! If we were given only a strand of the filename, expand it
        if ( TOOLKIT ) then
          call split_path_name(FileNameString, path, SubString)
          LastAprioriPCF = GetPCFromRef(SubString, mlspcf_l2apriori_start, &
          & mlspcf_l2apriori_end, &                                     
          & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
          & exactName=FileNameString)                             
d590 5
a594 3
        hdfVersion = mls_hdf_version(FilenameString)

        gridIndex = InitializeMLSFile(L2GPFile, content = 'l2gp', &
d596 43
a638 34
          & type=l_swath, access=DFACC_RDONLY, hdfVersion=hdfVersion, &
          & PCBottom=mlspcf_l2apriori_start, PCTop=mlspcf_l2apriori_end)
        L2GPFile%PCFId = LastAprioriPCF
        gridIndex = AddFileToDataBase(filedatabase, L2GPFile)
        ! If we didn't get a name get the first swath name in the file
        if ( len_trim(swathNameString) == 0 ) then
          allSwathNames = ''
          noSwaths = mls_InqSwath ( fileNameString, allSwathNames, listSize, &
           & hdfVersion=hdfVersion)
          if ( listSize == FILENOTFOUND ) then
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'File not found; make sure the name and path are correct' &
              & // trim(fileNameString), MLSFile=L2GPFile )
          elseif ( listSize < 1 ) then
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Failed to determine swath names, perhaps none in file ' &
              & // trim(fileNameString), MLSFile=L2GPFile )
          elseif ( listSize < len(allSwathNames) ) then
            commaPos = index ( allSwathNames, ',' )
            if ( commaPos == 0 ) then
              commaPos = len_trim(allSwathNames)
            elseif ( commaPos == 1 ) then
              call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Failed to determine swath name, allswathnames begin with , ' &
              & // trim(fileNameString), MLSFile=L2GPFile )
            else
              commaPos = commaPos - 1
            endif
            swathNameString = allSwathNames ( 1:commaPos )
          else
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Failed to determine swath names, string too long.' &
              & // trim(fileNameString), MLSFile=L2GPFile )
          end if
d640 43
a682 4
        if ( swathNameString == ' ' ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Failed to determine swath name, obscure error on ' &
            & // trim(fileNameString), MLSFile=L2GPFile )
d684 5
a688 4

        ! Read the swath
        if ( HMOT /= ' ' ) then
          call ReadL2GPData ( L2GPFile, swathNameString, l2gp, HMOT=HMOT )
d690 1
a690 1
          call ReadL2GPData ( L2GPFile, swathNameString, l2gp )
d692 7
a698 7

        if( Details > -3 ) then
          if ( specialDumpFile /= ' ' ) &
            & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
          call dump( l2gp, details=details )
          if ( specialDumpFile /= ' ' ) &
            & call revertOutput
d700 10
a709 4

        if( switchDetail(switches, 'pro') > -1 ) then                            
           call announce_success(FilenameString, 'l2gp', &                    
           & swathNameString, MLSFile=L2GPFile)    
d711 1
a711 32
        apriorifiles%l2gp = catlists(apriorifiles%l2gp, trim(FilenameString))

        ! Add this l2gp to the database, decorate this key with index
        call decorate ( key, AddL2GPToDatabase( L2GPDatabase, l2gp ) )
        ! Don't call destroy contents as the AddL2GPToDatabase has done a shallow
        ! copy.
        ! l2gp files in our database means               
        ! change default behavior so that we won't allow 
        ! overlaps outside the processing range)         
        call output( '(Resetting defaults to exclude overlaps outside '&
          & // 'processingRange', advance='yes' )
        ChunkDivideConfig%allowPriorOverlaps = .false.
        ChunkDivideConfig%allowPostOverlaps = .false.

      case ( s_l2aux )

        if ( TOOLKIT ) then
          call split_path_name(FileNameString, path, SubString)
          LastAprioriPCF = GetPCFromRef(SubString, mlspcf_l2apriori_start, &
          & mlspcf_l2apriori_end, &                                     
          & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
          & exactName=FileNameString)                             
        endif
        if ( .not. all(got((/f_sdName, f_file, f_quantityType /)))) &
          & call announce_error ( son, &
            & 'file/sd name must both be specified in read a priori' )
        
        call get_string ( sdName, sdNameString )
        sdNameString = sdNameString(2:LEN_TRIM(sdNameString)-1)

        hdfVersion = mls_hdf_version(FilenameString)
        gridIndex = InitializeMLSFile(L2AUXFile, content = 'l2aux', &
d713 10
a722 22
          & type=l_hdf, access=DFACC_RDONLY, hdfVersion=hdfVersion, &
          & PCBottom=mlspcf_l2apriori_start, PCTop=mlspcf_l2apriori_end)
        ! call mls_openFile(L2AUXFile, returnStatus)
        L2AUXFile%PCFId = LastAprioriPCF

        gridIndex = AddFileToDataBase(filedatabase, L2AUXFile)
        l2aux%name = l2Name

        l2Index = AddL2AUXToDatabase( L2AUXDatabase, l2aux )
        call decorate ( key, l2Index )
        pL2AUXFile => filedatabase(gridIndex)
        call ReadL2AUXData ( pL2AUXFile, sdNameString, quantityType, &
          & L2AUXDatabase(l2Index), &
          & checkDimNames=.false. )

        ! if( index(switches, 'apr') /= 0 ) then
        if( Details > -3 ) then
          if ( specialDumpFile /= ' ' ) &
            & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
          call dump( L2AUXDatabase(l2Index), details )
          if ( specialDumpFile /= ' ' ) &
            & call revertOutput
d724 10
d735 4
a738 3
        if( switchDetail(switches, 'pro') > -1 ) then                            
           call announce_success(FilenameString, 'l2aux', &                    
           & sdNameString, MLSFile=L2AUXFile)    
d740 2
a741 166
        apriorifiles%l2aux = catlists(apriorifiles%l2aux, trim(FilenameString))

      case ( s_gridded )

        if ( .not. all(got((/f_origin, f_field/))) ) &
          & call announce_error ( son, 'Incomplete gridded data information' )

        call get_string ( fieldName, fieldNameString, strip=.true. )
        
        select case ( griddedOrigin )
        case ( l_ncep, l_strat ) ! --------------------------- NCEP Data
          if (griddedOrigin == l_ncep) then
             description = 'ncep'
          else
             description = 'strat'
          end if
          call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
            & mlspcf_l2ncep_start, mlspcf_l2ncep_end, description, got(f_file), &
            & LastNCEPPCF, returnStatus )
          gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
            & name=FilenameString, shortName=shortFileName, &
            & type=l_grid, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
            & PCBottom=mlspcf_l2ncep_start, PCTop=mlspcf_l2ncep_end)
          GriddedFile%PCFId = LastNCEPPCF
          gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
          ! The gridded data needs to part of the database, even if the file
          ! won't be found and the gridded data empty,
          ! so it can be merged w/o segment faulting
          gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData1 )
          call decorate ( key, gridIndex )
          if ( returnStatus == PGS_S_SUCCESS) then
            call readGriddedData ( GriddedFile, son, description, &
              & v_is_pressure, GriddedDatabase(gridIndex), returnStatus, &
              & dimListString, TRIM(fieldNameString), missingValue )
          else
            call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
          endif
          if ( returnStatus == 0 ) then
            if( switchDetail(switches, 'pro') > -1 ) &                            
              & call announce_success(FilenameString, 'ncep', &                    
               & fieldNameString, MLSFile=GriddedFile)
            apriorifiles%ncep = catlists(apriorifiles%ncep, trim(FilenameString))
          else
            call announce_success(FilenameString, 'ncep not found--carry on', &                    
               & fieldNameString, MLSFile=GriddedFile)
          endif
        case ( l_dao ) ! ---------------------------- GMAO Data (GEOS4)
          call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
            & mlspcf_l2dao_start, mlspcf_l2dao_end, 'dao', got(f_file), &
            & LastDAOPCF, returnStatus )
          gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
            & name=FilenameString, shortName=shortFileName, &
            & type=l_grid, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
            & PCBottom=mlspcf_l2dao_start, PCTop=mlspcf_l2dao_end)
          GriddedFile%PCFId = LastDAOPCF
          gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
          ! The gridded data needs to part of the database, even if the file
          ! won't be found and the gridded data empty,
          ! so it can be merged w/o segment faulting
          gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData1 )
          call decorate ( key, gridIndex )

          ! We will decide whether it's geos4 or geos5 based on the field name
          select case ( lowercase(fieldNameString) )
          case ( 'tmpu' )
            description = 'dao'
            v_type = v_is_pressure
          case ( 'pl', 't' )
            description = 'geos5'
            v_type = V_is_eta
          case default
            description = 'geos5'
            v_type = V_is_eta
          end select
          if ( returnStatus == PGS_S_SUCCESS) then
            call ReadGriddedData ( GriddedFile, son, description, v_type, &
              & GriddedDatabase(gridIndex), returnStatus, &
              & dimListString, TRIM(fieldNameString), &
              & missingValue )
          else
            call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
          endif
          if ( returnStatus == 0 ) then
            if( switchDetail(switches, 'pro') > -1 ) &                            
              & call announce_success(FilenameString, 'dao', &                    
               & fieldNameString, MLSFile=GriddedFile)    
          else
            call announce_success(FilenameString, 'dao not found--carry on', &                    
               & fieldNameString, MLSFile=GriddedFile)
          endif
          if ( description == 'dao' ) then
            apriorifiles%dao = catlists(apriorifiles%dao, trim(FilenameString))
          else
            apriorifiles%geos5 = catlists(apriorifiles%geos5, trim(FilenameString))
          endif
        case ( l_geos5, l_merra ) ! ---------------------------- GMAO Data (GEOS5)
          ! call outputNamedValue ( 'fileNameString', trim(fileNameString) )
          ! call outputNamedValue ( 'LastGEOS5PCF', LastGEOS5PCF )
          call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
            & mlspcf_l2geos5_start, mlspcf_l2geos5_end, 'geos5', got(f_file), &
            & LastGEOS5PCF, returnStatus )
          gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
            & name=FilenameString, shortName=shortFileName, &
            & type=l_grid, access=DFACC_RDONLY, hdfVersion=HDFVERSION_4, &
            & PCBottom=mlspcf_l2geos5_start, PCTop=mlspcf_l2geos5_end)
          GriddedFile%PCFId = LastGEOS5PCF
          gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
          ! The gridded data needs to part of the database, even if the file
          ! won't be found and the gridded data empty,
          ! so it can be merged w/o segment faulting
          gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData1 )
          call decorate ( key, gridIndex )

          ! We will decide whether it's geos4 or geos5 based on the field name
          select case ( lowercase(fieldNameString) )
          case ( 'tmpu' )
            description = 'dao'
            v_type = v_is_pressure
          case ( 'pl', 't', 'delp' )
            description = 'geos5'
            v_type = V_is_eta
          case default
            ! We may use this case if we allow for either merra or geos5
            ! in the same l2cf declarartion; e.g.
            ! geos5SumInput: gridded, origin=geos5, field='PL,DELP',  ..
            ! which means:
            ! 1st, try to read the field 'PL'
            ! if that fails, try to read the field 'DELP'
            ! (optionally summing over it to create a 'PL' field)
            description = 'geos5'
            v_type = V_is_eta
          end select
          if ( griddedOrigin == l_merra ) description = 'merra'
          if ( DEBUG ) then
            call outputNamedValue( 'fileName', fileNameString )
            call outputNamedValue( 'fieldName', fieldNameString )
            call outputNamedValue( 'description', description )
          endif
          if ( returnStatus == PGS_S_SUCCESS) then
            call ReadGriddedData ( GriddedFile, son, description, v_type, &
              & GriddedDatabase(gridIndex), returnStatus, &
              & dimListString, TRIM(fieldNameString), &
              & missingValue, dateString, sumDelp )
          else
            call SetupNewGriddedData ( GriddedDatabase(gridIndex), empty=.true. )
          endif
          if ( returnStatus == 0 ) then
            if( switchDetail(switches, 'pro') > -1 ) &                            
              & call announce_success(FilenameString, 'geos5', &                    
               & fieldNameString, MLSFile=GriddedFile)    
          else
            call announce_success(FilenameString, 'geos5 not found--carry on', &                    
               & fieldNameString, MLSFile=GriddedFile)
          endif
          apriorifiles%geos5 = catlists(apriorifiles%geos5, trim(FilenameString))
          ! error = 1
        case ( l_gloria ) ! ------------------------- Data in Gloria's UARS format
          call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
            & mlspcf_l2clim_start, mlspcf_l2clim_end, 'gloria', got(f_file), &
            & LastClimPCF, returnStatus )
          if ( TOOLKIT .and. returnStatus /= PGS_S_SUCCESS ) then
            call announce_error ( son, &
              & 'PCF number not found to supply' // &
              & ' missing Climatology file name' )
          end if
          gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
d747 20
a766 3
          call decorate ( key, &
            & AddGriddedDataToDatabase ( griddedDatabase, &
            & ReadGloriaFile ( GriddedFile ) ) )
d768 2
a769 12
            call announce_success(FilenameString, 'Gloria', &                    
             & '', MLSFile=GriddedFile)    
          endif
        case ( l_climatology ) ! -------------------- Climatology data
          ! Identify file (maybe from PCF if no name given)
          call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
            & mlspcf_l2clim_start, mlspcf_l2clim_end, 'climatology', got(f_file), &
            & LastClimPCF, returnStatus )
          if ( TOOLKIT .and. returnStatus /= PGS_S_SUCCESS ) then
            call announce_error ( son, &
              & 'PCF number not found to supply' // &
              & ' missing Climatology file name' )
d771 31
a801 68
          
          ! Have we read this already?
          gotAlready = associated(GriddedDatabase)
          if ( gotAlready ) then
            gotAlready = any(GriddedDatabase%sourceFilename==filenameString)
          end if
          if ( .not. gotAlready ) then
            gridIndex = InitializeMLSFile(GriddedFile, content = 'clim', &
              & name=FilenameString, shortName=shortFileName, &
              & type=l_ascii, access=DFACC_RDONLY, &
              & PCBottom=mlspcf_l2clim_start, PCTop=mlspcf_l2clim_end)
            GriddedFile%PCFId = LastCLIMPCF
            gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
            ! No, well read it then, add its entire contents to the database
            call read_climatology ( GriddedFile, son, &
              & GriddedDatabase, returnStatus, &
              & mlspcf_l2apriori_start, mlspcf_l2apriori_end, &
              & missingValue )
            if ( returnStatus /= 0 ) &
              & call Announce_error ( field, &                               
              & 'read_climatology unsuccessful--check file name and path')  
          end if
          if ( .not. associated(GriddedDatabase) ) cycle  ! Last chance
       
          ! Locate requested grid by name, store index in gridIndex
          ! Check that field name is among those added by the source field
          do gridIndex = 1, size(griddedDatabase)
            if ( trim(fieldNameString) == &
              & trim(GriddedDatabase(gridIndex)%quantityName) ) exit
          end do

          if ( gridIndex <= size(griddedDatabase) ) then
            call decorate ( key, gridIndex )
            if( switchDetail(switches, 'pro') > -1 ) then                            
              call announce_success(FilenameString, 'climatology', &                  
               & fieldNameString, MLSFile=GriddedFile)
            end if
          else
            call announce_error ( son, 'Field ' // trim(fieldNameString) // &
              & ' not found in clim. file ' // trim(fileNameString) )
          end if
        case ( l_surfaceHeight ) ! See Read_surface_height_file
          call get_pcf_id ( fileNameString, path, subString, l2apriori_version, &
            & mlspcf_surfaceHeight_start, mlspcf_surfaceHeight_end, &
            & 'surfaceHeight', got(f_file), &
            & lastHeightPCF, returnStatus )
          if ( TOOLKIT .and. returnStatus /= PGS_S_SUCCESS ) then
            call announce_error ( son, &
              & 'PCF number not found to supply' // &
              & ' missing Surface Height file name' )
          end if
          gridIndex = InitializeMLSFile(GriddedFile, content = 'gridded', &
            & name=FilenameString, shortName=shortFileName, &
            & type=l_binary, access=DFACC_RDONLY, &
            & PCBottom=mlspcf_surfaceHeight_start, PCTop=mlspcf_surfaceHeight_end)
          GriddedFile%PCFId = LastCLIMPCF
          gridIndex = AddFileToDataBase(filedatabase, GriddedFile)
          call open_surface_height_file ( griddedFile )
          call decorate ( key, &
            & AddGriddedDataToDatabase ( griddedDatabase, &
            & read_surface_height_file ( GriddedFile ) ) )
          call close_surface_height_file ( GriddedFile )
          if( switchDetail(switches, 'pro') > -1 ) then                            
            call announce_success(FilenameString, 'SurfaceHeight', &                    
             & '', MLSFile=GriddedFile)    
          end if
        case default ! Can't get here if tree_checker worked correctly
        end select   ! origins of gridded data
d803 7
a809 36
        if( Details > -3 ) then
          if ( specialDumpFile /= ' ' ) &
            & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
          call dump( GriddedDatabase(gridIndex), details )
          if ( specialDumpFile /= ' ' ) &
            & call revertOutput
        endif

      case default
      end select     ! types of apriori data
    end do                              ! Lines in l2cf loop
    
    call output( '------------------- apriori datatypes --------------', advance='yes' )
    call output ( 'l2gp', advance='yes' )
    call dump( trim(APrioriFiles%l2gp), 'l2gp files' )
    call output ( 'l2aux', advance='yes' )
    call dump( trim(APrioriFiles%l2aux), 'l2aux files' )
    call output ( 'ncep', advance='yes' )
    call dump( trim(APrioriFiles%ncep), 'ncep files' )
    call output ( 'dao', advance='yes' )
    call dump( trim(APrioriFiles%dao), 'dao files' )
    call output ( 'geos5', advance='yes' )
    call dump( trim(APrioriFiles%geos5), 'geos5 files' )
    if ( ERROR/=0 ) then
      call MLSMessage(MLSMSG_Error,ModuleName, &
        & 'Problem with read_apriori section')
    end if
    
    if ( toggle(gen) ) then
      call trace_end("read_apriori")
    else
      call MLSMessageCalls( 'pop' )
    endif
  
    if ( timing ) call sayTime
    return
d811 2
a813 1

d861 1
a861 11
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for read_apriori = " )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime
d863 1
a863 1
  end subroutine read_apriori
d1096 1
a1096 1
       "$Id: read_apriori.f90,v 2.82 2010/02/04 23:12:44 vsnyder Exp $"
d1109 3
@


2.82
log
@Remove USE or declaration for unreferenced names
@
text
@d942 1
a942 1
    call output ( trim(l2_type), advance='no')
d951 6
a956 4
      call output ( myhdfVersion, advance='yes')
    else
      call output ( ' ', advance='yes')
    endif
d958 2
a959 7
    call output ( 'name : ' )
    call blanks(8)
    call output ( trim(Name), advance='yes')

    call output ( 'quantity', advance='yes')           
    call blanks(5)                                        
    call output ( trim(quantityName), advance='yes')      
d1030 1
a1030 1
       "$Id: read_apriori.f90,v 2.81 2009/10/26 17:11:07 pwagner Exp $"
d1043 3
@


2.81
log
@Added Diff command to be used like Dump in l2cf
@
text
@d16 1
a16 1
  use Hdf, only: DFACC_RDWR, DFACC_RDONLY
a820 1
    use HDFEOS5, only: MLS_charType
d1033 1
a1033 1
       "$Id: read_apriori.f90,v 2.80 2009/09/10 23:03:41 pwagner Exp $"
d1046 3
@


2.80
log
@Prevents 'Dump, /stop' line in l2cf from causing checkPaths failure
@
text
@d22 1
a22 1
    & S_Dump, S_GRIDDED, S_L2AUX, S_L2GP
d231 1
a231 1
      if ( fileType == s_dump ) then
d1034 1
a1034 1
       "$Id: read_apriori.f90,v 2.79 2009/08/26 16:48:17 pwagner Exp $"
d1047 3
@


2.79
log
@Added readAPrioriAttributes; writes APrioriFiles%geos5 as file attribute
@
text
@d30 2
a31 1
  use MLSL2Options, only: DEFAULT_HDFVERSION_READ, SPECIALDUMPFILE, TOOLKIT
d232 1
a232 1
        call dumpCommand ( key, griddedDataBase=griddedDataBase )
d1034 1
a1034 1
       "$Id: read_apriori.f90,v 2.78 2009/08/24 20:25:28 pwagner Exp $"
d1047 3
@


2.78
log
@Added merra file type, 'DELP' field name, /sum filed
@
text
@d57 2
a58 1
  public ::  APrioriFiles, APrioriFiles_T, read_apriori, writeAPrioriAttributes
d64 2
d75 6
a526 5
            if ( description == 'dao' ) then
              apriorifiles%dao = catlists(apriorifiles%dao, trim(FilenameString))
            else
              apriorifiles%geos5 = catlists(apriorifiles%geos5, trim(FilenameString))
            endif
d531 5
a590 5
            if ( description == 'dao' ) then
              apriorifiles%dao = catlists(apriorifiles%dao, trim(FilenameString))
            else
              apriorifiles%geos5 = catlists(apriorifiles%geos5, trim(FilenameString))
            endif
d595 1
d710 11
d798 62
d920 6
d1033 1
a1033 1
       "$Id: read_apriori.f90,v 2.77 2009/06/23 18:46:18 pwagner Exp $"
d1046 3
@


2.77
log
@Prevent Intel from optimizing ident string away
@
text
@d19 3
a21 3
    & F_ORIGIN, F_QUANTITYTYPE, F_SDNAME, F_SWATH, &
    & FIELD_FIRST, FIELD_LAST, L_CLIMATOLOGY, L_DAO, L_NCEP, &
    & L_GEOS5, L_GLORIA, L_STRAT, L_SURFACEHEIGHT, &
d43 2
a44 2
  use MoreTree, only: Get_Spec_ID
  use OUTPUT_M, only: BLANKS, OUTPUT, &
d81 1
a81 1
       "$RCSfile: $"
d166 1
d227 1
d258 2
a427 5
        ! call mls_closeFile(L2AUXFile, returnStatus)
!         if ( returnStatus /= 0 ) then
!           call announce_error ( son, &
!             & 'Failed to close l2aux file ' // trim(FileNameString) )
!         elseif(index(switches, 'pro') /= 0) then                            
d527 1
a527 1
        case ( l_geos5 ) ! ---------------------------- GMAO Data (GEOS5)
d550 1
a550 1
          case ( 'pl', 't' )
d554 7
d564 6
d574 1
a574 1
              & missingValue, dateString )
d949 1
a949 1
       "$Id: read_apriori.f90 is it here $"
d962 3
@


2.76
log
@mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
@
text
@d81 1
a81 1
       "$RCSfile: read_apriori.f90,v $"
d934 1
a935 1
!---------------------------- RCS Ident Info -------------------------------
d937 2
a938 3
       "$Id: read_apriori.f90,v 2.75 2008/09/17 23:20:13 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d940 1
a940 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d942 1
d950 3
@


2.75
log
@Allow date string in gridded data to offset gmao background files
@
text
@d28 2
a29 4
    & AddFileToDataBase, Dump, GetPCFromRef, InitializeMLSFile, &
    & MLS_HDF_VERSION, &
    & MLS_INQSWATH, mls_io_gen_closeF, mls_io_gen_openF, &
    & SPLIT_PATH_NAME
d74 1
a74 2
    module procedure writeAPrioriAttributes_MF
    module procedure writeAPrioriAttributes_name
d782 4
a785 1
      call writeAPrioriAttributes_name(MLSFile%name, HDFVERSION_5)
a788 17
  ! ------------------------------------------  writeAPrioriAttributes_name  -----
  subroutine writeAPrioriAttributes_name ( fileName, hdfVersion )
    character(len=*), intent(in) :: fileName
    integer, intent(in)          :: hdfVersion  ! Must be 5 to work properly
    ! Internal variables
    integer             :: fileID
    integer             :: record_length
    integer             :: status
    ! Executable
    fileID = mls_io_gen_openF(l_swath, .TRUE., status, &
      & record_length, DFACC_RDWR, FileName=Filename, &
      & hdfVersion=hdfVersion, debugOption=.false. )  
    call writeAPrioriAttributes_ID ( fileID, hdfVersion )
    status = mls_io_gen_closeF(l_swath, fileID, &
      & hdfVersion=hdfVersion)
  end subroutine writeAPrioriAttributes_name

d937 1
a937 1
       "$Id: read_apriori.f90,v 2.74 2007/10/24 00:16:59 pwagner Exp $"
d950 3
@


2.74
log
@Removed unused declarations
@
text
@d17 3
a19 2
  use INIT_TABLES_MODULE, only: F_AURAINSTRUMENT, F_DIMLIST, F_FIELD, F_FILE, &
    & F_HDFVERSION, F_missingValue, F_ORIGIN, F_QUANTITYTYPE, F_SDNAME, F_SWATH, &
d120 2
d238 2
d272 6
d565 1
a565 1
              & missingValue )
d954 1
a954 1
       "$Id: read_apriori.f90,v 2.73 2007/08/17 00:35:30 pwagner Exp $"
d958 1
d967 3
@


2.73
log
@Unneeded changes
@
text
@d28 1
a28 1
    & mls_closeFile, MLS_HDF_VERSION, &
d30 1
a30 1
    & mls_openFile, SPLIT_PATH_NAME
d45 1
a45 1
  use OUTPUT_M, only: BLANKS, OUTPUT, outputNamedValue, &
d47 1
a47 1
  use SDPToolkit, only: Pgs_pc_getReference, PGS_S_SUCCESS
a158 1
    integer :: pcf_indx            ! loop index of climatology pcf numbers
d943 1
a943 1
       "$Id: read_apriori.f90,v 2.72 2007/06/21 00:54:08 vsnyder Exp $"
d955 3
@


2.72
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d33 2
a34 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d42 1
a42 1
  use MLSStringLists, only: catLists
d179 5
a183 1
    if ( toggle (gen) ) call trace_begin ( "read_apriori", root )
d190 2
a191 10
    if ( index(switches, 'apr3') /= 0 ) then
      Details = 1
    elseif ( index(switches, 'apr2') /= 0 ) then
      Details = 0
    elseif ( index(switches, 'apr1') /= 0 ) then
      Details = -1
    else
      Details = -2
    endif
    if( index(switches, 'apr') /= 0 ) &     
d348 1
a348 1
        if( index(switches, 'apr') /= 0 ) then
d356 1
a356 1
        if(index(switches, 'pro') /= 0) then                            
d408 2
a409 1
        if( index(switches, 'apr') /= 0 ) then
d422 1
a422 1
        if(index(switches, 'pro') /= 0) then                            
d464 1
a464 1
            if(index(switches, 'pro') /= 0) &
d509 1
a509 1
            if(index(switches, 'pro') /= 0) &
d560 1
a560 1
            if(index(switches, 'pro') /= 0) &
d591 1
a591 1
          if(index(switches, 'pro') /= 0) then                            
d638 1
a638 1
            if(index(switches, 'pro') /= 0) then                          
d667 1
a667 1
          if(index(switches, 'pro') /= 0) then                            
d674 1
a674 1
        if( index(switches, 'apr') /= 0 ) then
d691 5
a695 1
    if ( toggle(gen) ) call trace_end("read_apriori")
d874 1
a874 1
    if ( present(MLSFile) .and. index(switches, 'apr') /= 0 ) &
d944 1
a944 1
       "$Id: read_apriori.f90,v 2.71 2007/03/02 18:14:02 pwagner Exp $"
d956 3
@


2.71
log
@Fixed bugs introduced 2 versions ago
@
text
@d460 1
a460 1
	           & v_is_pressure, GriddedDatabase(gridIndex), returnStatus, &
d942 1
a942 1
       "$Id: read_apriori.f90,v 2.70 2007/01/30 21:59:10 pwagner Exp $"
d954 3
@


2.70
log
@fixed bug where Get_PCF_Id retruned undefined values
@
text
@d44 2
a45 1
  use OUTPUT_M, only: BLANKS, OUTPUT, revertoutput, switchOutput
d202 3
d524 2
d574 1
d651 2
a652 1
            & 'surfaceHeight', got(f_file), lastHeightPCF, returnStatus )
d706 1
d713 10
a722 1
      integer, intent(out) :: PCF_Id, ReturnStatus
d724 4
d730 1
a730 1
        pcf_id = getPCFromRef ( subString, firstPCF, lastPCF, TOOLKIT, &
d734 2
a735 2
        do pcf_id = firstPCF, lastPCF
          returnStatus = Pgs_pc_getReference(pcf_indx, L2apriori_version, &
d942 1
a942 1
       "$Id: read_apriori.f90,v 2.69 2007/01/11 20:48:30 vsnyder Exp $"
d954 3
@


2.69
log
@Add SurfaceHeight to gridded data, vector quantities, allow dump in ReadApriori
@
text
@d719 3
d920 1
a920 1
       "$Id: read_apriori.f90,v 2.68 2006/06/13 20:56:43 pwagner Exp $"
d932 3
@


2.68
log
@Fixed bug in pcfid names for geos5 files
@
text
@d18 5
a22 4
    & F_HDFVERSION, F_missingValue, F_ORIGIN, F_SDNAME, F_SWATH, &
    & FIELD_FIRST, FIELD_LAST, L_CLIMATOLOGY, L_DAO, L_NCEP, S_GRIDDED, &
    & L_GLORIA, L_STRAT, L_GEOS5, S_L2AUX, S_L2GP, F_QUANTITYTYPE
  use Intrinsic, only: l_ascii, l_grid, l_hdf, l_swath, PHYQ_Dimensionless
d34 5
a38 1
  use MLSPCF2, only: mlspcf_l2apriori_start, mlspcf_l2apriori_end, &
d40 1
a40 3
    & mlspcf_l2dao_start, mlspcf_l2dao_end, &
    & mlspcf_l2clim_start, mlspcf_l2clim_end, &
    & mlspcf_l2geos5_start, mlspcf_l2geos5_end
d94 12
a105 8
  use ChunkDivide_m, only: ChunkDivideConfig
  use GriddedData, only: rgr, GriddedData_T, V_is_eta, v_is_pressure, &
    & AddGriddedDataToDatabase, Dump, SetupNewGriddedData
  use L2AUXData, only: L2AUXData_T, AddL2AUXToDatabase, &
    &                  ReadL2AUXData, Dump
  use L2GPData, only: L2GPData_T, MAXSWATHNAMESBUFSIZE, &
    & AddL2GPToDatabase, ReadL2GPData, Dump
  use ncep_dao, only: READ_CLIMATOLOGY, ReadGriddedData, ReadGloriaFile
d151 1
d220 5
a434 18
          if ( TOOLKIT .and. got(f_file) ) then
            call split_path_name(FileNameString, path, SubString)
            LastNCEPPCF = GetPCFromRef(SubString, mlspcf_l2ncep_start, &
            & mlspcf_l2ncep_end, &                                     
            & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
            & exactName=FileNameString)                             
          elseif ( TOOLKIT ) then
            do pcf_indx = LastNCEPPCF+1, mlspcf_l2ncep_end
              returnStatus = Pgs_pc_getReference(pcf_indx, L2apriori_version, &
                & fileNameString)
              if ( returnStatus == PGS_S_SUCCESS) exit
            end do
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call announce_success('ncep', 'no entry in PCF',  ' ')
            else
              LastNCEPPCF = pcf_indx
            end if
          endif
d440 3
d471 3
a473 21
          if ( TOOLKIT .and. got(f_file) ) then
            call split_path_name(FileNameString, path, SubString)
            LastDAOPCF = GetPCFromRef(SubString, mlspcf_l2dao_start, &
            & mlspcf_l2dao_end, &                                     
            & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
            & exactName=FileNameString)                             
          elseif ( TOOLKIT ) then
            do pcf_indx = LastDAOPCF+1, mlspcf_l2dao_end
              returnStatus = Pgs_pc_getReference(pcf_indx, L2apriori_version, &
                & fileNameString)
              if ( returnStatus == PGS_S_SUCCESS) exit
            end do
            if ( returnStatus /= PGS_S_SUCCESS ) then
              ! call announce_error ( son, &
              !  & 'PCF number not found to supply' // &
              !  & ' missing dao file name' )
              call announce_success('dao', 'no entry in PCF',  ' ')
            else
              LastDAOPCF = pcf_indx
            end if
          endif
d520 3
a522 18
          if ( TOOLKIT .and. got(f_file) ) then
            call split_path_name(FileNameString, path, SubString)
            LastGEOS5PCF = GetPCFromRef(SubString, mlspcf_l2geos5_start, &
            & mlspcf_l2geos5_end, &                                     
            & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
            & exactName=FileNameString)                             
          elseif ( TOOLKIT ) then
            do pcf_indx = LastGEOS5PCF+1, mlspcf_l2geos5_end
              returnStatus = Pgs_pc_getReference(pcf_indx, L2apriori_version, &
                & fileNameString)
              if ( returnStatus == PGS_S_SUCCESS) exit
            end do
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call announce_success('geos5', 'no entry in PCF',  ' ')
            else
              LastGEOS5PCF = pcf_indx
            end if
          endif
d569 8
a576 19
          if ( TOOLKIT .and. got(f_file) ) then
            call split_path_name(FileNameString, path, SubString)
            LastClimPCF = GetPCFromRef(SubString, mlspcf_l2clim_start, &
            & mlspcf_l2clim_end, &                                     
            & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
            & exactName=FileNameString)                             
          elseif ( TOOLKIT ) then
            do pcf_indx = lastClimPCF+1, mlspcf_l2clim_end
              returnStatus = Pgs_pc_getReference(pcf_indx, L2apriori_version, &
                & fileNameString)
              if ( returnStatus == PGS_S_SUCCESS) exit
            end do
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call announce_error ( son, &
                & 'PCF number not found to supply' // &
                & ' missing Climatology file name' )
            end if
            LastCLIMPCF = pcf_indx
          endif
d588 1
a588 1
             & swathNameString, MLSFile=GriddedFile)    
d592 8
a599 19
          if ( TOOLKIT .and. got(f_file) ) then
            call split_path_name(FileNameString, path, SubString)
            LastClimPCF = GetPCFromRef(SubString, mlspcf_l2clim_start, &
            & mlspcf_l2clim_end, &                                     
            & TOOLKIT, returnStatus, l2apriori_Version, DEBUG, &  
            & exactName=FileNameString)                             
          elseif ( TOOLKIT ) then
            do pcf_indx = lastClimPCF+1, mlspcf_l2clim_end
              returnStatus = Pgs_pc_getReference(pcf_indx, L2apriori_version, &
                & fileNameString)
              if ( returnStatus == PGS_S_SUCCESS) exit
            end do
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call announce_error ( son, &
                & 'PCF number not found to supply' // &
                & ' missing Climatology file name' )
            end if
            LastCLIMPCF = pcf_indx
          endif
d636 1
a636 1
            endif
d641 24
d691 31
d728 1
a728 1
      endif
d733 1
d917 1
a917 1
       "$Id: read_apriori.f90,v 2.67 2006/06/13 18:19:08 pwagner Exp $"
d929 3
@


2.67
log
@Added pcfids for geos5; moved ncep pcfids backwards to make room
@
text
@d37 1
a37 1
    & mlspcf_geos5_start, mlspcf_geos5_end
d192 1
a192 1
    lastGEOS5PCF = mlspcf_geos5_start - 1
d542 2
a543 2
            LastGEOS5PCF = GetPCFromRef(SubString, mlspcf_geos5_start, &
            & mlspcf_geos5_end, &                                     
d547 1
a547 1
            do pcf_indx = LastGEOS5PCF+1, mlspcf_geos5_end
d561 1
a561 1
            & PCBottom=mlspcf_geos5_start, PCTop=mlspcf_geos5_end)
d918 1
a918 1
       "$Id: read_apriori.f90,v 2.66 2006/06/06 21:56:52 pwagner Exp $"
d930 3
@


2.66
log
@May specify geos5 apriori files instead of dao (geos4)
@
text
@d36 2
a37 1
    & mlspcf_l2clim_start, mlspcf_l2clim_end
a53 1
  ! integer, public, parameter :: CLIMATOLOGYFALLBACKSTATUS = 1024
a56 2
  integer, private, parameter :: mlspcf_geos5_start = mlspcf_l2ncep_start
  integer, private, parameter :: mlspcf_geos5_end   = mlspcf_l2ncep_end
d918 1
a918 1
       "$Id: read_apriori.f90,v 2.65 2006/04/10 23:45:18 pwagner Exp $"
d930 3
@


2.65
log
@Reset defaults in read_apriori, not ChunkDivide
@
text
@d20 1
a20 1
    & L_GLORIA, L_STRAT, S_L2AUX, S_L2GP, F_QUANTITYTYPE
d38 1
d57 2
d66 1
d94 1
a94 1
  use GriddedData, only: rgr, GriddedData_T, v_is_pressure, &
d145 1
d166 1
d194 1
d474 1
a474 1
        case ( l_dao ) ! ---------------------------- DAO Data
d507 13
d521 1
a521 1
            call ReadGriddedData ( GriddedFile, son, 'dao', v_is_pressure, &
d532 5
a536 1
            apriorifiles%dao = catlists(apriorifiles%dao, trim(FilenameString))
d541 64
d920 1
a920 1
       "$Id: read_apriori.f90,v 2.64 2006/02/10 21:15:55 pwagner Exp $"
d932 3
@


2.64
log
@dumps may go to special dumpfile
@
text
@d89 1
d347 8
d832 1
a832 1
       "$Id: read_apriori.f90,v 2.63 2006/01/26 00:35:35 pwagner Exp $"
d844 3
@


2.63
log
@demoted more use statements from module level to speed Lahey compiles
@
text
@d30 1
a30 1
  use MLSL2Options, only: DEFAULT_HDFVERSION_READ, TOOLKIT
d39 1
a39 1
  use OUTPUT_M, only: BLANKS, OUTPUT
d328 7
a334 2
        if( index(switches, 'apr') /= 0 ) &
        & call dump( l2gp, details=details )
d380 7
a386 2
        if( index(switches, 'apr') /= 0 ) &
        & call dump( L2AUXDatabase(l2Index), details )
d606 7
a612 2
        if( index(switches, 'apr') /= 0 ) &
        & call dump( GriddedDatabase(gridIndex), details )
d823 1
a823 1
       "$Id: read_apriori.f90,v 2.62 2005/09/28 17:02:04 pwagner Exp $"
d835 3
@


2.62
log
@Should not segment fault when reading apriori l2aux
@
text
@a14 2
  use GriddedData, only: rgr, GriddedData_T, v_is_pressure, &
    & AddGriddedDataToDatabase, Dump, SetupNewGriddedData
a21 4
  use L2AUXData, only: L2AUXData_T, AddL2AUXToDatabase, &
    &                  ReadL2AUXData, Dump
  use L2GPData, only: L2GPData_T, MAXSWATHNAMESBUFSIZE, &
    & AddL2GPToDatabase, ReadL2GPData, Dump
a38 1
  use ncep_dao, only: READ_CLIMATOLOGY, ReadGriddedData, ReadGloriaFile
a39 1
  use PCFHdr, only: GlobalAttributes
d89 7
d120 1
a120 1
    type (griddedData_T) :: GriddedData
d430 1
a430 1
          gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData )
d479 1
a479 1
          gridIndex = AddGriddedDataToDatabase( GriddedDatabase, GriddedData )
d808 1
a808 1
       "$Id: read_apriori.f90,v 2.61 2005/08/05 20:39:07 pwagner Exp $"
d820 3
@


2.61
log
@L2AUXFile arg to ReadL2AUXFile now a pointer
@
text
@d132 2
a133 1
    type (MLSFile_T), pointer :: L2AUXFile
d363 1
a363 1
        call mls_openFile(L2AUXFile, returnStatus)
d371 2
a372 1
        call ReadL2AUXData ( L2AUXFile, sdNameString, quantityType, &
d379 6
a384 5
        call mls_closeFile(L2AUXFile, returnStatus)
        if ( returnStatus /= 0 ) then
          call announce_error ( son, &
            & 'Failed to close l2aux file ' // trim(FileNameString) )
        elseif(index(switches, 'pro') /= 0) then                            
d809 1
a809 1
       "$Id: read_apriori.f90,v 2.60 2005/07/12 17:34:57 pwagner Exp $"
d821 3
@


2.60
log
@Added MLSFile interface for writing apriori attributes
@
text
@d132 1
a132 1
    type (MLSFile_T) :: L2AUXFile
d806 1
a806 1
       "$Id: read_apriori.f90,v 2.59 2005/06/22 18:57:02 pwagner Exp $"
d818 3
@


2.59
log
@Reworded Copyright statement, moved rcs id
@
text
@d47 1
d59 2
a60 1
  public ::  read_apriori, writeAPrioriAttributes
d73 1
a73 1
  type (APrioriFiles_T), private, save :: APrioriFiles
d75 3
a77 1
    module procedure writeAPrioriAttributes_id, writeAPrioriAttributes_name
d84 1
a84 1
       "$RCSfile: $"
d605 1
a605 1

d625 16
d806 1
a806 1
       "$Id: $"
d818 3
@


2.58
log
@Interfaces changed to accept MLSFile_T args
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d78 1
a78 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: read_apriori.f90,v 2.57 2004/09/23 23:03:14 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d80 1
a80 1
       "$RCSfile: read_apriori.f90,v $"
d784 5
d798 3
@


2.57
log
@Added writeAPrioriAttributes
@
text
@d10 1
a10 1
  use Hdf, only: DFACC_RDWR, DFACC_READ
d15 1
a15 1
  use Intrinsic, only: PHYQ_Dimensionless
d21 7
a27 4
  use MLSCommon, only: FileNameLen
  use MLSFiles, only: FILENOTFOUND, HDFVERSION_5, WILDCARDHDFVERSION, &
    & GetPCFromRef, MLS_HDF_VERSION, mls_io_gen_closeF, mls_io_gen_openF, &
    & MLS_INQSWATH, MLS_SFEND, MLS_SFSTART, SPLIT_PATH_NAME
d72 1
a72 1
       "$Id: read_apriori.f90,v 2.56 2004/06/28 20:25:54 pwagner Exp $"
d85 2
a86 1
  subroutine Read_apriori ( Root, L2GPDatabase, L2auxDatabase, GriddedDatabase)
d93 1
a107 1
    integer :: FileHandle          ! fileHandle of a priori data file
d113 1
a121 4
    integer :: LastClimPCF
    integer :: LastDAOPCF
    integer :: LastNCEPPCF
    integer :: LISTSIZE                 ! Size of string from SWInqSwath
d123 1
d125 1
d128 5
a137 1
    integer :: record_length
d139 1
a142 1
    integer :: Sd_id
d174 1
d248 1
d262 1
a262 1
          LastClimPCF = GetPCFromRef(SubString, mlspcf_l2apriori_start, &
d267 1
d269 6
d283 1
a283 1
              & // trim(fileNameString) )
d287 1
a287 1
              & // trim(fileNameString) )
d295 1
a295 1
              & // trim(fileNameString) )
d303 1
a303 1
              & // trim(fileNameString) )
d309 1
a309 1
            & // trim(fileNameString) )
d314 1
a314 2
          call ReadL2GPData ( trim(FileNameString), swathNameString, l2gp, &
           & hdfVersion=hdfVersion, HMOT=HMOT )
d316 1
a316 2
          call ReadL2GPData ( trim(FileNameString), swathNameString, l2gp, &
           & hdfVersion=hdfVersion )
d324 1
a324 1
           & swathNameString, hdfVersion=hdfVersion)    
d336 1
a336 1
          LastClimPCF = GetPCFromRef(SubString, mlspcf_l2apriori_start, &
d348 7
a354 8
        ! create SD interface identifier for l2aux
         if ( hdfVersion == WILDCARDHDFVERSION ) &
           & hdfVersion = mls_hdf_version(trim(FilenameString))
         sd_id = mls_sfstart(FilenameString, DFACC_READ, hdfVersion=hdfVersion)
        if (sd_id == -1 ) then
          call announce_error ( son, 'Failed to open l2aux ' // &
          &  trim(FilenameString) )
        end if
d356 1
d361 3
a363 2
        call ReadL2AUXData ( sd_id, sdNameString, quantityType, L2AUXDatabase(l2Index), &
          & hdfVersion=hdfVersion, checkDimNames=.false. )
d368 2
a369 4
        if ( hdfVersion == WILDCARDHDFVERSION ) &
          & hdfVersion = mls_hdf_version(trim(FilenameString))
        fileHandle = mls_sfend(sd_id, hdfVersion=hdfVersion)
        if ( fileHandle == -1 ) then
d374 1
a374 1
           & sdNameString, hdfVersion=hdfVersion)    
a399 3
              ! call announce_error ( son, &
              !  & 'PCF number not found to supply' // &
              !  & ' missing ncep file name' )
d410 6
d422 1
a422 1
            call readGriddedData ( FileNameString, son, description, &
d431 1
a431 1
               & fieldNameString, hdfVersion=hdfVersion)
d435 1
a435 1
               & fieldNameString, hdfVersion=hdfVersion)
d459 6
d471 1
a471 1
            call ReadGriddedData ( FileNameString, son, 'dao', v_is_pressure, &
d481 1
a481 1
               & fieldNameString, hdfVersion=hdfVersion)    
d485 1
a485 1
               & fieldNameString, hdfVersion=hdfVersion)
d507 6
d515 1
a515 1
            & ReadGloriaFile ( FilenameString ) ) )
d518 1
a518 1
             & swathNameString)    
d548 6
d555 1
a555 1
            call read_climatology ( FileNameString, son, &
d576 1
a576 1
               & fieldNameString)    
d625 1
a625 1
    fileID = mls_io_gen_openF('swopen', .TRUE., status, &
d629 1
a629 1
    status = mls_io_gen_closeF('swclose', fileID, &
d637 2
a638 3
    use HDFEOS5, only: HE5T_NATIVE_INT, &
      & HE5T_NATIVE_DOUBLE, MLS_charType
    use MLSHDFEOS, only: he5_EHwrglatt, mls_EHwrglatt
d679 2
a680 1
  subroutine announce_success ( Name, l2_type, quantityName, hdfVersion )
d685 1
d711 2
d717 1
a717 1
    & error_number )
d725 1
d773 1
a773 1

d788 3
@


2.56
log
@Handle dao, ncep missing from PCF with grace
@
text
@d10 1
a10 1
  use Hdf, only: DFACC_READ
d22 2
a23 2
  use MLSFiles, only: FILENOTFOUND, WILDCARDHDFVERSION, &
    & GetPCFromRef, MLS_HDF_VERSION, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
d27 1
a27 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d32 1
d47 1
a47 1
  public ::  read_apriori
d50 1
d52 13
d69 1
a69 1
       "$Id: read_apriori.f90,v 2.55 2004/06/23 17:13:34 pwagner Exp $"
d312 1
d363 1
d416 1
d460 1
d582 61
d750 3
@


2.55
log
@Should quit gracefully if climatolgy file not found
@
text
@d8 1
a8 1
    & AddGriddedDataToDatabase, Dump
d54 1
a54 1
       "$Id: read_apriori.f90,v 2.54 2004/01/23 01:10:58 pwagner Exp $"
d370 6
a375 3
              call announce_error ( son, &
                & 'PCF number not found to supply' // &
                & ' missing ncep file name' )
a376 1
            LastNCEPPCF = pcf_indx
d383 3
d388 7
a394 3
          call readGriddedData ( FileNameString, son, description, &
	    & v_is_pressure, GriddedDatabase(gridIndex), returnStatus, &
            & dimListString, TRIM(fieldNameString), missingValue )
d417 6
a422 3
              call announce_error ( son, &
                & 'PCF number not found to supply' // &
                & ' missing dao file name' )
a423 1
            LastDAOPCF = pcf_indx
d425 3
d430 8
a437 4
          call ReadGriddedData ( FileNameString, son, 'dao', v_is_pressure, &
            & GriddedDatabase(gridIndex), returnStatus, &
            & dimListString, TRIM(fieldNameString), &
            & missingValue )
d670 3
@


2.54
log
@Gets max swathlist length from L2GPData
@
text
@d54 1
a54 1
       "$Id: read_apriori.f90,v 2.53 2003/10/06 13:16:09 cvuu Exp $"
d485 2
a486 1
              & GriddedDatabase, mlspcf_l2apriori_start, mlspcf_l2apriori_end, &
d488 3
d492 1
d652 3
@


2.53
log
@add new description=strat to handle reading the ncep data file
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 2
a19 1
  use L2GPData, only: L2GPData_T, AddL2GPToDatabase, ReadL2GPData, Dump
d54 1
a54 1
       "$Id: read_apriori.f90,v 2.52 2003/06/09 22:49:34 pwagner Exp $"
d130 1
a130 1
    character(len=2048) :: ALLSWATHNAMES ! Buffer to get info back.
d647 3
@


2.52
log
@Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
@
text
@d14 1
a14 1
    & L_GLORIA, S_L2AUX, S_L2GP, F_QUANTITYTYPE
d53 1
a53 1
       "$Id: read_apriori.f90,v 2.51 2003/05/29 17:54:28 pwagner Exp $"
d130 1
d355 1
a355 1
        case ( l_ncep ) ! --------------------------- NCEP Data
d375 5
d382 2
a383 2
          call readGriddedData ( FileNameString, son, 'ncep', v_is_pressure, &
            & GriddedDatabase(gridIndex), returnStatus, &
d646 3
@


2.51
log
@Able to read dao, ncep files w/o knowing name fragment
@
text
@d24 1
a24 1
  use MLSL2Options, only: DEFAULT_HDFVERSION_READ, PCF, PCFL2CFSAMECASE
d53 1
a53 1
       "$Id: read_apriori.f90,v 2.50 2003/05/09 23:26:45 pwagner Exp $"
d234 1
a234 1
        if ( PCF ) then
d238 1
a238 1
          & PCFL2CFSAMECASE, returnStatus, l2apriori_Version, DEBUG, &  
d302 1
a302 1
        if ( PCF ) then
d306 1
a306 1
          & PCFL2CFSAMECASE, returnStatus, l2apriori_Version, DEBUG, &  
d355 1
a355 1
          if ( PCF .and. got(f_file) ) then
d359 1
a359 1
            & PCFL2CFSAMECASE, returnStatus, l2apriori_Version, DEBUG, &  
d361 1
a361 1
          elseif ( PCF ) then
d388 1
a388 1
          if ( PCF .and. got(f_file) ) then
d392 1
a392 1
            & PCFL2CFSAMECASE, returnStatus, l2apriori_Version, DEBUG, &  
d394 1
a394 1
          elseif ( PCF ) then
d422 1
a422 1
          if ( PCF .and. got(f_file) ) then
d426 1
a426 1
            & PCFL2CFSAMECASE, returnStatus, l2apriori_Version, DEBUG, &  
d428 1
a428 1
          elseif ( PCF ) then
d450 1
a450 1
          if ( PCF .and. got(f_file) ) then
d454 1
a454 1
            & PCFL2CFSAMECASE, returnStatus, l2apriori_Version, DEBUG, &  
d456 1
a456 1
          elseif ( PCF ) then
d640 3
@


2.50
log
@Should not bomb when l2aux hdfversion absent or wildcard
@
text
@d27 4
a30 1
  use MLSPCF2, only: mlspcf_l2apriori_start, mlspcf_l2apriori_end
d53 1
a53 1
       "$Id: read_apriori.f90,v 2.49 2003/05/06 00:16:32 pwagner Exp $"
d102 2
a124 1
    integer :: Version
a148 1
    version = 1
d150 3
a152 1
    lastClimPCF = mlspcf_l2apriori_start - 1
a277 9
        ! Open the l2gp file
        ! fileHandle = swopen(FileNameString, DFACC_READ)
        ! fileHandle = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
        !     & record_length, DFACC_READ, FileName=FileNameString, &
        !     & hdfVersion=hdfVersion, debugOption=.false. )
        ! if ( fileHandle < 0 ) then
        !  call announce_error ( son, &
        !    & 'Failed to open swath file ' // trim(FileNameString) )
        ! end if
a279 2
        ! call ReadL2GPData ( fileHandle, swathNameString, l2gp, &
        ! & hdfVersion=hdfVersion )
a290 8
        ! Close the file
        ! fileHandle = swclose(fileHandle)
        ! fileHandle = mls_io_gen_closeF('swclose', fileHandle, &
        ! & hdfVersion=hdfVersion)
        ! if ( fileHandle == -1 ) then
        !  call announce_error ( son, &
        !    & 'Failed to close swath file ' // trim(FileNameString) )
        ! elseif(index(switches, 'pro') /= 0) then                            
a315 2
  ! ((( This will have to change if we wish to convert l2aux to hdf5
  !          Maybe put another wrapper in MSLFiles
a319 1
!        sd_id = sfstart(FilenameString, DFACC_READ)
a324 5
        ! Create the l2aux, and add it to the database.
        ! This doesn't match the interface in module L2AUXData
        !       CALL SetupNewL2AUXRecord ( l2aux )
        ! It has been relocated to READL2AUXData

a334 4
   ! For some reason, sfend was never called for l2aux data files here
   ! Did we think we were going to read from elsewhere?
   ! Anyway, I added the mls_sfend version when I converted
   ! this module to use MLSFiles instead of Hdf
a347 8
        if ( PCF .and. got(f_file) ) then
          call split_path_name(FileNameString, path, SubString)
          LastClimPCF = GetPCFromRef(SubString, mlspcf_l2apriori_start, &
          & mlspcf_l2apriori_end, &                                     
          & PCFL2CFSAMECASE, returnStatus, l2apriori_Version, DEBUG, &  
          & exactName=FileNameString)                             
        endif

d355 19
d388 19
d422 19
d450 10
a459 3
          if ( .NOT. got(f_file) .and. PCF) then
            do pcf_indx = lastClimPCF+1, mlspcf_l2apriori_end
              returnStatus = Pgs_pc_getReference(i, version, fileNameString)
d467 2
a468 1
          end if
d640 3
@


2.49
log
@Fixed passing wild card hdf version to mls_sfend for l2aux
@
text
@d50 1
a50 1
       "$Id: read_apriori.f90,v 2.48 2003/05/05 23:00:34 livesey Exp $"
d333 2
d609 3
@


2.48
log
@Merged in feb03 newfwm branch
@
text
@d50 1
a50 1
       "$Id: read_apriori.f90,v 2.47 2003/04/17 23:08:29 pwagner Exp $"
d359 2
d607 3
@


2.47
log
@Added optional AuraInstrument field to l2gp apriori reads
@
text
@d50 1
a50 1
       "$Id: read_apriori.f90,v 2.46 2003/04/04 18:35:11 pwagner Exp $"
d350 1
a350 1
          & hdfVersion=hdfVersion, checkDimNames=.true. )
d605 3
@


2.46
log
@Warns if dao, ncep FILENOTFOUND
@
text
@d10 2
a11 2
  use Hdf, only: DFACC_READ  !, SFSTART
  use INIT_TABLES_MODULE, only: F_DIMLIST, F_FIELD, F_FILE, &
d50 1
a50 1
       "$Id: read_apriori.f90,v 2.45 2003/04/02 23:54:53 pwagner Exp $"
d72 1
d94 1
d151 1
d175 2
d209 4
d286 7
a292 2
        call ReadL2GPData ( trim(FileNameString), swathNameString, l2gp, &
         & hdfVersion=hdfVersion )
d605 3
@


2.45
log
@Checks for FILENOTFOUND
@
text
@d50 1
a50 1
       "$Id: read_apriori.f90,v 2.44 2003/04/01 21:44:38 dwu Exp $"
d374 1
a374 1
            & GriddedDatabase(gridIndex), &
d376 7
a382 6
          if(index(switches, 'pro') /= 0) then                            
            call announce_success(FilenameString, 'ncep', &                    
             & fieldNameString, hdfVersion=hdfVersion)
             ! print *, trim(GriddedDatabase(gridIndex)%quantityName)
             ! print *, trim(GriddedDatabase(gridIndex)%description)
             ! print *, trim(GriddedDatabase(gridIndex)%units)
d388 2
a389 1
            & GriddedDatabase(gridIndex), dimListString, TRIM(fieldNameString), &
d391 7
a397 6
          if(index(switches, 'pro') /= 0) then                            
            call announce_success(FilenameString, 'dao', &                    
             & fieldNameString, hdfVersion=hdfVersion)    
             ! print *, trim(GriddedDatabase(gridIndex)%quantityName)
             ! print *, trim(GriddedDatabase(gridIndex)%description)
             ! print *, trim(GriddedDatabase(gridIndex)%units)
d591 3
@


2.44
log
@Fixed bad error with multiple swaths in file (pwagner)
@
text
@d21 1
a21 1
  use MLSFiles, only: WILDCARDHDFVERSION, &
d50 1
a50 1
       "$Id: read_apriori.f90,v 2.43 2003/03/01 00:24:27 pwagner Exp $"
a229 1
!          noSwaths = SWInqSwath ( fileNameString, allSwathNames, listSize )
d233 5
a237 1
          if ( listSize < 1 ) then
d588 3
@


2.43
log
@Added missingValue as filed to reading Gridded data
@
text
@d50 1
a50 1
       "$Id: read_apriori.f90,v 2.42 2003/02/27 18:41:40 pwagner Exp $"
d240 9
a248 1
            if ( commaPos == 0 ) commaPos = len_trim(allSwathNames)
d585 3
@


2.42
log
@Handles WILDCARDHDFVERSION properly
@
text
@d7 1
a7 1
  use GriddedData, only: GriddedData_T, v_is_pressure, &
d11 2
a12 2
  use INIT_TABLES_MODULE, only: F_DIMLIST, F_FIELD, F_FILE, F_HDFVERSION, &
    & F_ORIGIN, F_SDNAME, F_SWATH, &
d50 1
a50 1
       "$Id: read_apriori.f90,v 2.41 2003/02/20 21:26:21 pwagner Exp $"
d77 2
d102 1
d178 3
d364 1
a364 1
            & dimListString, TRIM(fieldNameString) )
d368 3
a370 3
             print *, trim(GriddedDatabase(gridIndex)%quantityName)
             print *, trim(GriddedDatabase(gridIndex)%description)
             print *, trim(GriddedDatabase(gridIndex)%units)
d376 2
a377 1
            & GriddedDatabase(gridIndex), dimListString, TRIM(fieldNameString) )
d381 3
a383 3
             print *, trim(GriddedDatabase(gridIndex)%quantityName)
             print *, trim(GriddedDatabase(gridIndex)%description)
             print *, trim(GriddedDatabase(gridIndex)%units)
d415 2
a416 1
              & GriddedDatabase, mlspcf_l2apriori_start, mlspcf_l2apriori_end )
d577 3
@


2.41
log
@Lets you read field dimList=x,y,.. w/ griddeddata
@
text
@d21 3
a23 2
  use MLSFiles, only: GetPCFromRef, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
    & MLS_INQSWATH, MLS_SFSTART, MLS_SFEND, SPLIT_PATH_NAME
d50 1
a50 1
       "$Id: read_apriori.f90,v 2.40 2003/02/19 19:16:21 pwagner Exp $"
d213 9
d228 5
a232 1
          if ( listSize < len(allSwathNames) ) then
d238 2
a239 1
              & 'Failed to determine swath names, string too long.' )
d242 4
a245 7
        
        if ( PCF ) then
          call split_path_name(FileNameString, path, SubString)
          LastClimPCF = GetPCFromRef(SubString, mlspcf_l2apriori_start, &
          & mlspcf_l2apriori_end, &                                     
          & PCFL2CFSAMECASE, returnStatus, l2apriori_Version, DEBUG, &  
          & exactName=FileNameString)                             
d248 8
a255 8
!        fileHandle = swopen(FileNameString, DFACC_READ)
        fileHandle = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
             & record_length, DFACC_READ, FileName=FileNameString, &
             & hdfVersion=hdfVersion, debugOption=.false. )
        if ( fileHandle < 0 ) then
          call announce_error ( son, &
            & 'Failed to open swath file ' // trim(FileNameString) )
        end if
d258 3
a260 1
        call ReadL2GPData ( fileHandle, swathNameString, l2gp, &
d267 8
a274 7
!        fileHandle = swclose(fileHandle)
        fileHandle = mls_io_gen_closeF('swclose', fileHandle, &
         & hdfVersion=hdfVersion)
        if ( fileHandle == -1 ) then
          call announce_error ( son, &
            & 'Failed to close swath file ' // trim(FileNameString) )
        elseif(index(switches, 'pro') /= 0) then                            
d361 4
a364 1
             & fieldNameString, hdfVersion=hdfVersion)    
d374 3
d471 2
d478 6
a483 1
      call output ( hdfVersion, advance='yes')
d569 3
@


2.40
log
@More sensible output when proclaiming successful file inputs
@
text
@d11 1
a11 1
  use INIT_TABLES_MODULE, only: F_FIELD, F_FILE, F_HDFVERSION, &
d49 1
a49 1
       "$Id: read_apriori.f90,v 2.39 2003/01/18 02:37:34 livesey Exp $"
d74 2
d168 4
a173 10
        case ( f_swath )
          swathName = sub_rosa(subtree(2,field))
        case ( f_sdname )
          sdname = sub_rosa(subtree(2,field))
        case ( f_field )
          fieldName = sub_rosa(subtree(2,field))
        case ( f_origin )
          griddedOrigin = decoration(subtree(2,subtree(j,key)))
        case ( f_quantityType )
          quantityType = decoration(subtree(2,subtree(j,key)))
d180 8
d191 6
d343 1
a343 1
            & 'XDim,YDim,Height,TIME', TRIM(fieldNameString) )
d352 1
a352 1
            & GriddedDatabase(gridIndex), fieldName = TRIM(fieldNameString) )
d541 3
@


2.39
log
@Added the quantityType stuff to L2Aux issues
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d49 1
a49 1
       "$Id: read_apriori.f90,v 2.38 2002/12/10 00:40:27 pwagner Exp $"
d334 4
a337 1
          
d343 4
a346 1

d351 4
a354 1
          
d389 4
d531 3
@


2.38
log
@Overrides defaults; forcing check of l2auxdimNames
@
text
@d14 1
a14 1
    & L_GLORIA, S_L2AUX, S_L2GP
d49 1
a49 1
       "$Id: read_apriori.f90,v 2.37 2002/12/06 01:06:56 pwagner Exp $"
d100 1
d176 2
d267 1
a267 1
        if ( .not. all(got((/f_sdName, f_file/)))) &
d293 1
a293 1
        call ReadL2AUXData ( sd_id, sdNameString, L2AUXDatabase(l2Index), &
d518 3
@


2.37
log
@Passes hdfVersion to readl2auxdata
@
text
@d49 1
a49 1
       "$Id: read_apriori.f90,v 2.36 2002/10/08 17:36:22 pwagner Exp $"
d291 1
a291 1
          & hdfVersion=hdfVersion )
d515 3
@


2.36
log
@Added idents to survive zealous Lahey optimizer
@
text
@d49 1
a49 1
       "$Id: read_apriori.f90,v 2.35 2002/04/06 00:11:18 pwagner Exp $"
d290 2
a291 1
        call ReadL2AUXData ( sd_id, sdNameString, L2AUXDatabase(l2Index) )
d515 3
@


2.35
log
@Combined pcf numbers for dao, ncep, clim, l2gp into apriori
@
text
@d49 1
a49 1
       "$Id: read_apriori.f90,v 2.34 2002/01/29 23:49:38 pwagner Exp $"
d53 1
d504 4
d514 3
@


2.34
log
@Separate DEFAULT_HDFVERSION_(READ)(WRITE)
@
text
@d21 3
a23 3
  use MLSFiles, only: MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
    & MLS_INQSWATH, MLS_SFSTART, MLS_SFEND
  use MLSL2Options, only: DEFAULT_HDFVERSION_READ, PCF
d26 1
a26 1
  use MLSPCF2, only: mlspcf_l2clim_start, mlspcf_l2clim_end
d49 1
a49 1
       "$Id: read_apriori.f90,v 2.33 2002/01/26 00:10:45 pwagner Exp $"
d71 1
d89 1
d97 1
d105 1
d137 1
a137 1
    lastClimPCF = mlspcf_l2clim_start - 1
d141 1
d214 7
d256 7
d309 8
d344 1
a344 1
            do pcf_indx = lastClimPCF+1, mlspcf_l2clim_end
d363 1
a363 1
              & GriddedDatabase, mlspcf_l2clim_start, mlspcf_l2clim_end )
d509 3
@


2.33
log
@Correctly sets hdfVersion; changed proclaim to announce_success
@
text
@d10 1
a10 1
  use Hdf, only: DFACC_READ, SFSTART
d21 3
a23 3
  use MLSFiles, only: GetPCFromRef, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
    & split_path_name, mls_InqSwath
  use MLSL2Options, only: DEFAULT_HDFVERSION, PCF
d49 1
a49 1
       "$Id: read_apriori.f90,v 2.32 2002/01/23 23:09:46 pwagner Exp $"
d136 1
a136 1
      hdfVersion = DEFAULT_HDFVERSION
d254 2
a255 2
!        sd_id = mls_sfstart(FilenameString, DFACC_READ)
        sd_id = sfstart(FilenameString, DFACC_READ)
d275 13
d482 3
@


2.32
log
@Handles optional hdfVersion field; proclaims files input
@
text
@d9 1
d15 1
d49 1
a49 1
       "$Id: read_apriori.f90,v 2.31 2002/01/23 22:35:47 livesey Exp $"
d107 3
d170 5
a174 1
          hdfVersion = subtree(2,field)  
d234 1
a234 1
           call proclaim(FilenameString, 'l2gp', &                    
d375 2
a376 2
  ! ---------------------------------------------  proclaim  -----
  subroutine proclaim ( Name, l2_type, quantityName, hdfVersion )
d399 1
a399 1
  end subroutine proclaim
d469 3
@


2.31
log
@Added ReadGloriaFile stuff
@
text
@d10 2
a11 1
  use INIT_TABLES_MODULE, only: F_FIELD, F_FILE, F_ORIGIN, F_SDNAME, F_SWATH, &
d21 1
a21 1
  use MLSL2Options, only: PCF
d47 1
a47 1
       "$Id: read_apriori.f90,v 2.30 2002/01/18 19:01:34 pwagner Exp $"
d83 1
d131 1
d164 2
d188 2
a189 1
          noSwaths = mls_InqSwath ( fileNameString, allSwathNames, listSize )
d204 1
a204 1
             & debugOption=.false. )
d211 2
a212 1
        call ReadL2GPData ( fileHandle, swathNameString, l2gp )
d219 2
a220 1
        fileHandle = mls_io_gen_closeF('swclose', fileHandle)
d224 3
d364 28
d460 3
@


2.30
log
@Changed debugOption to .false.
@
text
@d12 1
a12 1
    & S_L2AUX, S_L2GP
d25 1
a25 1
  use ncep_dao, only: READ_CLIMATOLOGY, ReadGriddedData
d46 1
a46 1
       "$Id: read_apriori.f90,v 2.29 2002/01/18 18:50:08 pwagner Exp $"
d263 1
a263 2
        case ( l_ncep )
          
d270 1
a270 2
        case ( l_dao )
          
d275 5
d281 1
a281 2
        case ( l_climatology )
          
a282 1

a283 1
            
a287 1
            
a306 1
          
a326 1
      
d421 3
@


2.29
log
@Better check when swopen fails
@
text
@a9 1
  use Hdfeos, only: SWOPEN, SWCLOSE
d46 1
a46 1
       "$Id: read_apriori.f90,v 2.28 2002/01/18 00:55:30 pwagner Exp $"
a180 3
!
! (((((( This will have to be changed before transition to hdfeos5 ))))))
!        Maybe put wrapper in MLSFiles?
d198 1
a198 1
             & debugOption=.true. )
d230 3
d234 1
d424 3
@


2.28
log
@Uses MLSFiles for swapi wrappers
@
text
@d47 1
a47 1
       "$Id: read_apriori.f90,v 2.27 2002/01/09 00:00:04 pwagner Exp $"
d203 1
a203 1
        if ( fileHandle == -1 ) then
d424 3
@


2.27
log
@Replaced write or print statements with calls to output
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d10 1
a10 1
  use Hdfeos, only: SWOPEN, SWCLOSE, SWINQSWATH
d19 2
d47 1
a47 1
       "$Id: read_apriori.f90,v 2.26 2001/11/09 23:17:22 vsnyder Exp $"
d93 1
d182 6
a187 1
          noSwaths = SWInqSwath ( fileNameString, allSwathNames, listSize )
d199 4
a202 1
        fileHandle = swopen(FileNameString, DFACC_READ)
d215 2
a216 1
        fileHandle = swclose(fileHandle)
d424 3
@


2.26
log
@Use Time_Now instead of CPU_TIME
@
text
@d45 1
a45 1
       "$Id: read_apriori.f90,v 2.25 2001/10/30 00:35:27 pwagner Exp $"
d393 3
a395 2
      print*, '***Error in module ', ModuleName
      print*, trim(full_message)
d397 2
a398 1
        print*, 'error number ', error_number
d412 3
@


2.25
log
@Tidied up small things
@
text
@d28 1
d45 1
a45 1
       "$Id: read_apriori.f90,v 2.24 2001/10/26 23:20:10 pwagner Exp $"
d107 1
a107 1
    if ( timing ) call cpu_time ( t1 )
d332 1
a332 1
      call cpu_time ( t2 )
d410 3
@


2.24
log
@Optionally dumps apriori quantities as it reads them
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d12 2
a13 2
    & FIELD_FIRST, FIELD_LAST, L_CLIMATOLOGY, L_DAO, L_NCEP, S_GRIDDED, S_L2AUX, &
    & S_L2GP
a18 1
  use MLSFiles, only: SPLIT_PATH_NAME
d24 1
a24 1
  use ncep_dao, only: READ_CLIMATOLOGY, ReadGriddedData, source_file_already_read
d44 1
a44 1
       "$Id: read_apriori.f90,v 2.23 2001/10/08 21:35:43 pwagner Exp $"
d109 1
d119 2
a160 3
!      if ( fileName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
!        & 'File name not specified in read a priori')
      
d171 1
a171 1
            & 'Filename name not specified in read a priori' )
d193 1
a193 1
            & 'Failed to open swath file ' // FileNameString )
d206 1
a206 1
            & 'Failed to close swath file ' // FileNameString )
d217 1
a217 1
            & 'file/sd name not specified in read a priori' )
d224 2
a225 1
          call announce_error ( son, 'Failed to open l2aux ' // sdNameString )
a226 2
        ! ??? subtree(1,key) is l2aux or l2gp.  It doesn't have a subtree ???
        !       vectorIndex = decoration(decoration(subtree(2,subtree(1,key))))
a234 6
        !        call decorate ( key, AddL2AUXToDatabase( L2AUXDatabase, l2aux ) )

        ! That's the end of the create operation

        ! ??? Should "vectorIndex" be "decoration(key)" ???
        ! ??? If so, do something like
a236 2
        !   call ReadL2AUXData ( ... L2AUXDataBase(l2Index) ... )
        ! Need to add this routine to L2AUXData.f90 before uncommenting this line
d278 2
a279 1
                & 'PCF number not found to supply missing Climatology file name' )
a353 2
!    character (len=80) :: msg, mnemonic
!    integer :: status
d409 3
@


2.23
log
@Initialize allswathnames
@
text
@d7 2
a8 1
  use GriddedData, only: GriddedData_T, v_is_pressure, AddGriddedDataToDatabase
d15 2
a16 2
    &                  ReadL2AUXData
  use L2GPData, only: L2GPData_T, AddL2GPToDatabase, ReadL2GPData
d22 1
a22 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    &                         MLSMSG_Error, MLSMSG_FileOpen
d29 1
a29 1
  use TOGGLES, only: GEN, TOGGLE
d45 1
a45 1
       "$Id: read_apriori.f90,v 2.22 2001/09/28 23:59:20 pwagner Exp $"
d67 1
d109 10
d186 1
a186 1
              & 'Failed to determinne swath names, string too long.' )
d200 3
d249 3
d318 5
a322 1
        end select
d324 1
a324 1
      end select
d420 3
@


2.22
log
@Fixed various timing problems
@
text
@d45 1
a45 1
       "$Id: read_apriori.f90,v 2.21 2001/09/10 23:37:44 livesey Exp $"
d109 1
d399 3
@


2.21
log
@New GriddedData stuff
@
text
@d20 1
d26 1
a26 1
  use OUTPUT_M, only: OUTPUT
d45 1
a45 1
       "$Id: read_apriori.f90,v 2.20 2001/05/12 00:20:00 livesey Exp $"
d97 2
d105 2
d313 15
d398 3
@


2.20
log
@Allowed user to not supply swath name when reading l2gp
@
text
@d7 1
a7 1
  use GriddedData, only: GriddedData_T, v_is_pressure
d24 1
a24 2
  use ncep_dao, only: AddGridTemplateToDatabase, &
  & READ_CLIMATOLOGY, ReadGriddedData, source_file_already_read
d44 1
a44 1
       "$Id: read_apriori.f90,v 2.19 2001/05/07 18:03:56 pwagner Exp $"
d239 1
a239 1
          gridIndex = AddGridTemplateToDatabase( GriddedDatabase, GriddedData )
d247 1
a247 1
          gridIndex = AddGridTemplateToDatabase( GriddedDatabase, GriddedData )
d378 3
@


2.19
log
@Checks for PCF before looping over pcf_indx
@
text
@d9 1
a9 1
  use Hdfeos, only: swopen, swclose
d45 1
a45 1
       "$Id: read_apriori.f90,v 2.18 2001/05/03 20:34:08 vsnyder Exp $"
d65 2
a66 1
    !Local Variables
d83 1
d88 1
d99 2
d154 1
a154 1
        if ( .not. all(got((/f_swath, f_file/)))) &
d156 18
a173 3
            & 'Swath/filename name not specified in read a priori' )
        call get_string ( swathName, swathNameString )
        swathNameString = swathNameString(2:LEN_TRIM(swathNameString)-1)
d379 3
@


2.18
log
@Cosmetic changes
@
text
@d19 1
d45 1
a45 1
       "$Id: $"
d48 1
a48 1
       "$RCSfile: $"
d86 1
a86 1
    integer :: Pcf                 ! loop index of climatology pcf numbers
d237 1
a237 1
          if ( .NOT. got(f_file) ) then
d239 1
a239 1
            do pcf = lastClimPCF+1, mlspcf_l2clim_end
d359 3
@


2.17
log
@Tiny change to announce_error
@
text
@d42 7
a48 6
  private :: Id, ModuleName
  !------------------------------- RCS Ident Info ------------------------------
  character(len=130) :: id = &
    "$id: open_init.f90,v 1.11 2000/06/19 22:40:51 lungu Exp $"
  character(len=*), parameter :: ModuleName="$RCSfile: read_apriori.f90,v $"
  !-----------------------------------------------------------------------------
d56 1
a56 1
  subroutine read_apriori ( root, L2GPDatabase, l2auxDatabase, GriddedDatabase)
d61 1
a61 1
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase
d67 4
a70 2
    integer :: fileHandle          ! fileHandle of a priori data file
    integer :: fileName            ! Sub-rosa index of name in file='name'
d73 5
a77 2
    integer :: gridIndex           ! In the griddeddata database
    logical :: gotAlready               ! Do we need to reread this file?
d80 1
a80 1
    integer :: lastClimPCF
d83 1
a83 2
    TYPE (GriddedData_T) :: GriddedData
    integer :: l2Index             ! In the l2gp or l2aux database
d85 2
a86 3
    integer :: pcf                 ! loop index of climatology pcf numbers

    integer :: sd_id
d88 4
a91 5
    integer :: swathName        ! sub-rosa index of name in swath='name'
    integer :: sdName        ! sub-rosa index of name in sdName='name'
    integer :: fieldName        ! sub-rosa index of name in field='name'
    integer :: griddedOrigin            ! From tree
    character(len=FileNameLen) :: FIELDNAMESTRING ! actual literal clim. field
d93 1
a93 3
    character(len=FileNameLen) :: SDNAMESTRING ! actual literal sdName
    integer :: version
	integer :: returnStatus
d95 1
a95 3
    logical, dimension(field_first:field_last) :: got

    if ( toggle (gen) ) call trace_begin( "read_apriori", root )
d98 2
a99 2
	 version = 1
	lastClimPCF = mlspcf_l2clim_start - 1
d102 1
a102 1
      got=.false.
d121 2
a122 2
        fieldIndex=decoration(subtree(1,field))
        got(fieldIndex)=.true.
d143 1
a143 1
        fileNameString=''
d146 1
a146 1
      select case( FileType )
a150 1
        
d207 1
a207 1
        call ReadL2AUXData(sd_id, sdNameString, L2AUXDatabase(l2Index))
d211 2
a212 3
        if ( .not. all(got((/f_origin, f_field/)))) &
          & call announce_error(son, &
          & 'Incomplete gridded data information')
d221 1
a221 1
          CALL ReadGriddedData ( FileNameString, son, 'ncep', v_is_pressure, &
d238 2
a239 3
            do pcf=lastClimPCF+1, mlspcf_l2clim_end
              returnStatus = Pgs_pc_getReference(i, version, &
                & fileNameString)
d263 1
a263 2
          gridIndex=1
          do gridIndex=1,size(griddedDatabase)
d265 1
a265 1
              & trim(GriddedDatabase(gridIndex)%quantityName)) exit
d281 4
a284 4
    if (ERROR/=0 ) then
	 	call MLSMessage(MLSMSG_Error,ModuleName, &
      & 'Problem with read_apriori section')
	end if
d291 2
a292 2
  subroutine announce_error ( lcf_where, full_message, use_toolkit, &
  & error_number )
d296 4
a299 4
    integer, intent(in)    :: lcf_where
    character(LEN=*), intent(in)    :: full_message
    logical, intent(in), optional :: use_toolkit
    integer, intent(in), optional    :: error_number
d303 2
a304 2
    logical :: just_print_it
    logical, parameter :: default_output_by_toolkit = .true.
d349 1
a349 1
  end subroutine announce_error
d358 3
@


2.16
log
@Improved an error message
@
text
@d12 1
a12 1
    & S_L2GP, LIT_INDICES
d14 1
a14 1
    &                  ReadL2AUXData!, SetupNewL2AUXRecord
d17 1
a17 1
  use MLSCommon, only: FileNameLen, L1BInfo_T, TAI93_Range_T
d19 2
a20 5
!  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
!    &                         MLSMSG_Error, MLSMSG_FileOpen!, MLSMSG_Info
!  use OBTAINCLIMATOLOGY, only: READ_CLIMATOLOGY
!  use OBTAINDAO, only: READ_DAO
!  use OBTAINNCEP, only: READ_NCEP
d27 1
a27 1
  use String_Table, only: GET_STRING, DISPLAY_STRING
d32 1
a32 1
  use TREE_TYPES, only: N_NAMED!, N_DOT
a79 1
    character (LEN=480) :: msr     ! Error message if can't find file
a90 2
    character(len=FileNameLen) :: bareFilename
    character(len=FileNameLen) :: path
a148 3
!        if ( .not. all(got((/f_swath, f_file/)))) &
!          & call MLSMessage(MLSMSG_Error, ModuleName, &
!          & 'Swath/filename name not specified in read a priori')
a157 2
!          msr = MLSMSG_Fileopen // FileNameString
!          call MLSMessage ( MLSMSG_Error, ModuleName, trim(msr) )
a167 2
!          msr = 'Failed to close file ' // FileNameString
!          call MLSMessage(MLSMSG_Error, ModuleName, trim(msr))
a177 3
!        if ( .not. all(got((/f_sdName, f_file/)))) &
!          & call MLSMessage(MLSMSG_Error, ModuleName, &
!          & 'file/sd name not specified in read a priori')
a186 2
!          msr = MLSMSG_Fileopen // FileNameString
!          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a212 3
!        if ( .not. all(got((/f_origin, f_field, f_file/)))) &
!          & call MLSMessage(MLSMSG_Error, ModuleName, &
!          & 'Incomplete gridded data information')
d286 5
d312 1
a312 1
      just_print_it = use_toolkit
d363 3
@


2.15
log
@Bug fixes etc.
@
text
@d147 1
a147 1
      if (got(f_file)) then
d151 1
a151 1
      endif
d159 2
a160 2
          & call announce_error(son, &
          & 'Swath/filename name not specified in read a priori')
d163 1
a163 1
        swathNameString=swathNameString(2:LEN_TRIM(swathNameString)-1)
d166 1
a166 1
        if (fileHandle == -1) then
d169 2
a170 1
          call announce_error ( son, 'Failed to open swath file ' // FileNameString)
d178 1
a178 1
        if (fileHandle == -1) THEN
d181 2
a182 1
          call announce_error(son, 'Failed to close swath file ' // FileNameString)
d195 2
a196 2
          & call announce_error(son, &
          & 'file/sd name not specified in read a priori')
d199 1
a199 1
        sdNameString=sdNameString(2:LEN_TRIM(sdNameString)-1)
d202 1
a202 1
        IF (sd_id == -1) THEN
d205 2
a206 2
          CALL announce_error(son, 'Failed to open l2aux ' // sdNameString)
        ENDIF
d227 1
a227 1
        CALL ReadL2AUXData(sd_id, sdNameString, L2AUXDatabase(l2Index))
d245 1
a245 1
          CALL ReadGriddedData(FileNameString, son, 'ncep', v_is_pressure, &
d247 1
a247 1
            & 'XDim,YDim,Height,TIME', TRIM(fieldNameString))
d253 2
a254 2
          CALL ReadGriddedData(FileNameString, son, 'dao', v_is_pressure, &
            & GriddedDatabase(gridIndex), fieldName = TRIM(fieldNameString))
d260 1
a260 1
          if(.NOT. got(f_file)) then
d265 2
a266 2
              if(returnStatus == PGS_S_SUCCESS) exit
            enddo
d268 5
a272 5
            if(returnStatus /= PGS_S_SUCCESS) then
              call announce_error(son, &
                & 'PCF number not found to supply missing Climatology file name')
            endif
          endif
d276 1
a276 1
          if (gotAlready) then
d278 2
a279 2
          endif
          if (.not. gotAlready) then
d281 3
a283 3
            call read_climatology(FileNameString, son, &
              & GriddedDatabase, mlspcf_l2clim_start, mlspcf_l2clim_end)
          endif
d290 1
a290 1
            if (trim(fieldNameString) == &
d292 1
a292 1
          enddo
d294 1
a294 1
          if (gridIndex <= size(griddedDatabase) ) then
d297 3
a299 3
            call announce_error(son, 'Field ' // trim(fieldNameString) // &
              & ' not found in clim. file ' // trim(fileNameString))
          endif
d307 1
a307 1
    if (toggle(gen) ) call trace_end("read_apriori")
d316 52
a367 52
	
	integer, intent(in)    :: lcf_where
	character(LEN=*), intent(in)    :: full_message
	logical, intent(in), optional :: use_toolkit
	integer, intent(in), optional    :: error_number
	! Local
!  character (len=80) :: msg, mnemonic
!  integer :: status
  logical :: just_print_it
  logical, parameter :: default_output_by_toolkit = .true.
	
	if(present(use_toolkit)) then
		just_print_it = use_toolkit
	elseif(default_output_by_toolkit) then
		just_print_it = .false.
	else
		just_print_it = .true.
	endif
	
	if(.not. just_print_it) then
    error = max(error,1)
    call output ( '***** At ' )

	if(lcf_where > 0) then
	    call print_source ( source_ref(lcf_where) )
		else
    call output ( '(no lcf node available)' )
		endif

    call output ( ': ' )
    call output ( "The " );
	if(lcf_where > 0) then
    call dump_tree_node ( lcf_where, 0 )
		else
    call output ( '(no lcf tree available)' )
		endif

		CALL output("Caused the following error:", advance='yes', &
		& from_where=ModuleName)
		CALL output(trim(full_message), advance='yes', &
		& from_where=ModuleName)
		if(present(error_number)) then
			CALL output('error number ', advance='no')
			CALL output(error_number, places=9, advance='yes')
		endif
	else
		print*, '***Error in module ', ModuleName
		print*, trim(full_message)
		if(present(error_number)) then
			print*, 'error number ', error_number
		endif
	endif
d379 3
@


2.14
log
@Fleshed out njl outline for reading clim. files
@
text
@d18 1
d74 1
d95 2
a145 5
      if ( fileName == 0 ) call announce_error(son, &
        & 'File name not specified in read a priori')
      
      call get_string ( FileName, fileNameString )
      fileNameString=fileNameString(2:LEN_TRIM(fileNameString)-1)
d147 6
d232 1
a232 1
        if ( .not. all(got((/f_origin, f_field, f_file/)))) &
d236 1
a236 2
        call get_string ( fieldName, fieldNameString )
        fieldNameString=fieldNameString(2:LEN_TRIM(fieldNameString)-1)
d245 1
a245 1
				& 'XDim,YDim,Height,TIME', TRIM(fieldNameString))
d255 1
a255 1
         
d258 14
a271 15
				if(.NOT. got(f_file)) then
					
					do pcf=lastClimPCF+1, mlspcf_l2clim_end
           		 returnStatus = Pgs_pc_getReference(i, version, &
              & fileNameString)
				  	if(returnStatus == PGS_S_SUCCESS) exit
				  
				  enddo
				  
				  if(returnStatus /= PGS_S_SUCCESS) then
						call announce_error(son, &
						& 'PCF number not found to supply missing Climatology file name')
              endif
				endif

d273 10
a282 10
				if(source_file_already_read(GriddedDatabase, trim(fileNameString), &
				& trim(fieldNameString))) then
				
			! Excellent, no need to read it again--if it's already in the database
				else
          ! No, well read it then, add its entire contents to the database
          CALL READ_CLIMATOLOGY(FileNameString, son, &
            & GriddedDatabase, mlspcf_l2clim_start, mlspcf_l2clim_end)
          
				endif
a283 10

			! Check that field name is among those added by the source field
				if(source_file_already_read(GriddedDatabase, trim(fileNameString), &
				& trim(fieldNameString))) then
		          call decorate ( key, gridIndex )
				else
	          CALL announce_error(son, 'Field ' // trim(fieldNameString) // &
				 & ' not found in clim. file ' // trim(fileNameString))
				endif

d285 13
d377 3
@


2.13
log
@Added some comment guidelines for read climatology
@
text
@d16 1
d18 2
a19 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    &                         MLSMSG_Error, MLSMSG_FileOpen!, MLSMSG_Info
d26 3
a28 1
  & READ_CLIMATOLOGY, ReadGriddedData
d33 1
a33 1
    &             SUB_ROSA, SUBTREE
a34 1
  use OUTPUT_M, only: OUTPUT
d39 2
d57 1
a57 1
  subroutine read_apriori ( root, L2GPDatabase, l2auxDatabase, aprioriData)
d63 1
a63 1
    type (GriddedData_T), dimension(:), pointer :: aprioriData 
d72 1
d75 1
d82 1
d90 1
d93 2
a94 1
    character(len=FileNameLen) :: FIELDNAMESTRING ! actual literal fieldName
d100 4
d140 3
a142 1
      if ( fileName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
d150 3
d154 1
a154 1
          & call MLSMessage(MLSMSG_Error, ModuleName, &
d162 3
a164 2
          msr = MLSMSG_Fileopen // FileNameString
          call MLSMessage ( MLSMSG_Error, ModuleName, trim(msr) )
d173 3
a175 2
          msr = 'Failed to close file ' // FileNameString
          call MLSMessage(MLSMSG_Error, ModuleName, trim(msr))
d184 3
d188 1
a188 1
          & call MLSMessage(MLSMSG_Error, ModuleName, &
d196 3
a198 2
          msr = MLSMSG_Fileopen // FileNameString
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d224 3
d228 1
a228 1
          & call MLSMessage(MLSMSG_Error, ModuleName, &
d237 2
a238 2
          l2Index = AddGridTemplateToDatabase( aprioriData, GriddedData )
          call decorate ( key, l2Index )
d240 1
a240 1
            & aprioriData(l2Index), &
d245 2
a246 2
          l2Index = AddGridTemplateToDatabase( aprioriData, GriddedData )
          call decorate ( key, l2Index )
d248 1
a248 1
            & aprioriData(l2Index), fieldName = TRIM(fieldNameString))
d254 15
d270 5
a274 1

d276 2
d279 1
a280 1
          ! call decorate ( key, gridIndex )
d282 9
a290 2
          CALL READ_CLIMATOLOGY(FileNameString, son, &
            & aprioriData, mlspcf_l2clim_start, mlspcf_l2clim_end)
d303 62
d371 3
@


2.12
log
@Passes son to READ_CLIMATOLOGY
@
text
@d224 6
d231 3
d254 3
@


2.11
log
@Gets v_is_pressure from GriddedData
@
text
@d225 1
a225 1
          CALL READ_CLIMATOLOGY(FileNameString, &
d245 3
@


2.10
log
@Split between GriddedData and ncep_dao modules
@
text
@d7 1
a7 1
  use GriddedData, only: GriddedData_T
d25 1
a25 1
  & READ_CLIMATOLOGY, ReadGriddedData, v_is_pressure
d245 3
@


2.9
log
@Use Get_Spec_ID instead of decoration(subtree...
@
text
@d7 1
a7 2
  use GriddedData, only: GriddedData_T, AddGridTemplateToDatabase, &
  & READ_CLIMATOLOGY, ReadGriddedData, v_is_pressure
d24 2
d245 3
@


2.8
log
@Gives more info to ReadGriddedData
@
text
@d24 1
d103 1
a103 1
      FileType = decoration(subtree(1,decoration(subtree(1,key))))
d244 3
@


2.7
log
@Some changes
@
text
@d8 1
a8 1
  & READ_CLIMATOLOGY, ReadGriddedData
d210 1
a210 1
          CALL ReadGriddedData(FileNameString, son, &
d218 1
a218 1
          CALL ReadGriddedData(FileNameString, son, &
d243 3
@


2.6
log
@Uses FieldNameString and son in call to ReadGriddedData
@
text
@d12 2
a13 1
    & L_CLIMATOLOGY, L_DAO, L_NCEP, S_GRIDDED, S_L2AUX, S_L2GP, LIT_INDICES
d61 1
d85 2
d90 1
d109 3
a111 1
        select case ( decoration(subtree(1,field)) )
d133 3
a135 3

        if ( swathName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
          & 'Swath name not specified in read a priori')
d162 3
a164 2
        if ( sdName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
          & 'sd name not specified in read a priori')
d198 3
a200 4
!        call output('Hello paul, in read gridded data section.',advance='yes')
        call display_string(lit_indices(griddedOrigin),advance='yes')
        if ( fieldName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
          & 'Field name not specified in read a priori')
d243 3
@


2.5
log
@Interfaces with ReadGriddedData
@
text
@d190 1
a190 1
        call output('Hello paul, in read gridded data section.',advance='yes')
d203 3
a205 2
          CALL ReadGriddedData(FileNameString, &
            & aprioriData(l2Index), 'XDim,YDim,Height,TIME', 'Some_field_name')
d211 2
a212 2
          CALL ReadGriddedData(FileNameString, &
            & aprioriData(l2Index), fieldName = 'Some_field_name')
d236 3
@


2.4
log
@Reworked the l2cf aspects
@
text
@d204 1
a204 1
            & aprioriData(l2Index), 'Some_field_name')
d211 1
a211 1
            & aprioriData(l2Index), 'Some_field_name')
d235 3
@


2.3
log
@No longer uses obtainclim, obtaindao, obtainncep
@
text
@d11 2
a12 2
  use INIT_TABLES_MODULE, only: F_FILE, F_SWATH, S_L2AUX, S_L2GP !, s_ncep, &
	!  & s_dao, s_clim 
d23 1
a23 1
  use String_Table, only: GET_STRING
d29 1
a29 3

! 	

a51 1

a71 1
!?  type (Vector_T) :: newVector
d76 6
a81 8
    character(len=FileNameLen) :: SwathNameString ! actual literal swath name
!?  integer :: vectorIndex         ! In the vector database


! These should be replaced by appropriate entries in init_tables_module
	INTEGER, PARAMETER :: s_ncep=s_l2aux+1
	INTEGER, PARAMETER :: s_dao=s_ncep+1
	INTEGER, PARAMETER :: s_climatology=s_dao+1
d109 6
d117 1
d120 1
a120 3
      if ( swathName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Swath name not specified in read a priori')

a121 1
      call get_string ( swathName, swathNameString )
d123 1
a123 2
      swathNameString=swathNameString(2:LEN_TRIM(swathNameString)-1)

d127 5
d155 5
d186 1
a186 1
        CALL ReadL2AUXData(sd_id, swathNameString, L2AUXDatabase(l2Index))
d188 1
a188 3
	! The remaining cases are gridded data types
!	ReadGriddedData(FileName, the_g_data, fieldName)
      case ( s_ncep )
d190 31
a220 18
        l2Index = AddGridTemplateToDatabase( aprioriData, GriddedData )
        call decorate ( key, l2Index )
			CALL ReadGriddedData(FileNameString, &
			& aprioriData(l2Index), 'Some_field_name')

      case ( s_dao )

        l2Index = AddGridTemplateToDatabase( aprioriData, GriddedData )
        call decorate ( key, l2Index )
			CALL ReadGriddedData(FileNameString, &
			& aprioriData(l2Index), 'Some_field_name')

      case ( s_climatology )

			CALL READ_CLIMATOLOGY(FileNameString, &
			& aprioriData, mlspcf_l2clim_start, mlspcf_l2clim_end)

      case default ! Can't get here if tree_checker worked correctly
d222 3
a224 4


    end do

d226 1
a226 1

d235 3
@


2.2
log
@A little bit more
@
text
@d7 2
a8 1
  use GriddedData, only: GriddedData_T, AddGridTemplateToDatabase
d19 4
a22 3
  use OBTAINCLIMATOLOGY, only: READ_CLIMATOLOGY
  use OBTAINDAO, only: READ_DAO
  use OBTAINNCEP, only: READ_NCEP
d30 3
d182 1
d187 2
a188 2
			CALL READ_NCEP(FileNameString, &
			& aprioriData(l2Index)%field(1, 1, 1, :, :, :))
d194 2
a195 2
			CALL READ_DAO(FileNameString, 'Some_vector_name', &
			& aprioriData(l2Index)%field(1, 1, 1, :, :, :))
a198 2
        l2Index = AddGridTemplateToDatabase( aprioriData, GriddedData )
        call decorate ( key, l2Index )
d200 1
a200 1
			& aprioriData(l2Index)%field(1, 1, 1, :, :, :))
d218 3
@


2.1
log
@First commit
@
text
@d38 1
a38 1
  character(len=*), parameter :: ModuleName="$RCSfile: open_init.f90,v $"
d66 1
d179 2
d186 2
d193 2
d213 4
a216 1
! $Log: open_init.f90,v $
@

