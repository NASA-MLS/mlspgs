head	2.368;
access;
symbols
	v5-02-NRT-19:2.368
	v6-00:2.368
	v5-02-NRT-18:2.368
	v5-02:2.364
	v5-01-NRT-17:2.368
	v5-01-NRT-16:2.368
	v5-01-NRT-15:2.367
	v5-01-NRT-14:2.367
	neuralnetworks-1-0:2.365.0.4
	cfm-single-freq-0-1:2.365.0.2
	v5-01:2.364
	v5-00:2.364
	v4-23-TA133:2.363.0.2
	mus-emls-1-70:2.357.0.4
	rel-1-0-englocks-work:2.357.0.2
	VUMLS1-00:2.356
	VPL1-00:2.356
	V4-22-NRT-08:2.356
	VAM1-00:2.356
	V4-22:2.356
	V4-21:2.355.0.2
	V4-13:2.355
	V4-12:2.351
	V4-11:2.351
	V4-10:2.351
	V3-43:2.307
	M4-00:2.334
	V3-41:2.307
	V3-40-PlusGM57:2.307.0.2
	V2-24-NRT-04:2.297
	V3-33:2.312
	V2-24:2.297
	V3-31:2.312
	V3-30-NRT-05:2.312
	cfm-01-00:2.309
	V3-30:2.307
	V3-20:2.307
	V3-10:2.305
	V2-23-NRT-02:2.297
	V2-23:2.297
	V2-22-NRT-01:2.297
	V2-22:2.297
	V2-21:2.286
	V2-20:2.286
	V2-11:2.280
	V2-10:2.280
	V2-00:2.277
	V1-51:2.260
	V1-50:2.260
	V1-45:2.260
	V1-44:2.260
	V1-43:2.256
	V1-32:2.252
	V1-31:2.252
	V1-30:2.250
	V1-13:2.238
	V1-12:2.238
	V1-11:2.238
	V1-10:2.229
	newfwm-feb03:2.231.0.2
	V1-04:2.140
	V1-03:2.140
	V1-02:2.140
	JointForwardModel:2.146.0.2
	V1-00:2.138
	newfwm-sep01:2.58.0.2
	V0-7:2.58
	V0-5-Level2:2.26
	V0-5-SIPS:2.15;
locks; strict;
comment	@# @;


2.368
date	2022.05.19.17.19.04;	author pwagner;	state Exp;
branches;
next	2.367;

2.367
date	2021.02.05.05.18.50;	author pwagner;	state Exp;
branches;
next	2.366;

2.366
date	2021.01.22.00.21.10;	author pwagner;	state Exp;
branches;
next	2.365;

2.365
date	2020.07.17.19.38.52;	author vsnyder;	state Exp;
branches;
next	2.364;

2.364
date	2019.06.24.23.29.26;	author pwagner;	state Exp;
branches;
next	2.363;

2.363
date	2018.11.20.01.09.43;	author vsnyder;	state Exp;
branches;
next	2.362;

2.362
date	2018.09.13.20.23.49;	author pwagner;	state Exp;
branches;
next	2.361;

2.361
date	2018.08.28.20.50.10;	author vsnyder;	state Exp;
branches;
next	2.360;

2.360
date	2018.07.27.23.19.53;	author pwagner;	state Exp;
branches;
next	2.359;

2.359
date	2018.07.23.23.29.56;	author vsnyder;	state Exp;
branches;
next	2.358;

2.358
date	2018.07.23.22.20.21;	author vsnyder;	state Exp;
branches;
next	2.357;

2.357
date	2017.12.07.01.01.23;	author vsnyder;	state Exp;
branches;
next	2.356;

2.356
date	2015.05.05.00.12.47;	author vsnyder;	state Exp;
branches;
next	2.355;

2.355
date	2014.09.30.02.15.19;	author vsnyder;	state Exp;
branches;
next	2.354;

2.354
date	2014.09.29.20.17.52;	author vsnyder;	state Exp;
branches;
next	2.353;

2.353
date	2014.09.05.01.20.03;	author vsnyder;	state Exp;
branches;
next	2.352;

2.352
date	2014.09.05.00.49.07;	author vsnyder;	state Exp;
branches;
next	2.351;

2.351
date	2014.04.10.00.45.24;	author pwagner;	state Exp;
branches;
next	2.350;

2.350
date	2014.03.01.03.10.56;	author vsnyder;	state Exp;
branches;
next	2.349;

2.349
date	2014.02.28.01.14.04;	author vsnyder;	state Exp;
branches;
next	2.348;

2.348
date	2014.01.23.23.16.37;	author vsnyder;	state Exp;
branches;
next	2.347;

2.347
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.346;

2.346
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.345;

2.345
date	2013.10.09.23.42.29;	author vsnyder;	state Exp;
branches;
next	2.344;

2.344
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.343;

2.343
date	2013.09.04.02.50.05;	author vsnyder;	state Exp;
branches;
next	2.342;

2.342
date	2013.08.30.02.45.46;	author vsnyder;	state Exp;
branches;
next	2.341;

2.341
date	2013.08.03.00.40.42;	author vsnyder;	state Exp;
branches;
next	2.340;

2.340
date	2013.07.26.22.41.44;	author vsnyder;	state Exp;
branches;
next	2.339;

2.339
date	2013.07.12.23.25.28;	author vsnyder;	state Exp;
branches;
next	2.338;

2.338
date	2013.06.12.02.38.50;	author vsnyder;	state Exp;
branches;
next	2.337;

2.337
date	2013.04.24.00.37.42;	author pwagner;	state Exp;
branches;
next	2.336;

2.336
date	2013.04.22.17.51.57;	author pwagner;	state Exp;
branches;
next	2.335;

2.335
date	2013.04.17.00.05.25;	author pwagner;	state Exp;
branches;
next	2.334;

2.334
date	2013.03.01.01.12.15;	author pwagner;	state Exp;
branches;
next	2.333;

2.333
date	2012.10.11.22.03.46;	author pwagner;	state Exp;
branches;
next	2.332;

2.332
date	2012.09.13.18.08.34;	author vsnyder;	state Exp;
branches;
next	2.331;

2.331
date	2012.09.12.22.51.40;	author vsnyder;	state Exp;
branches;
next	2.330;

2.330
date	2012.08.30.23.01.18;	author vsnyder;	state Exp;
branches;
next	2.329;

2.329
date	2012.08.16.18.07.23;	author pwagner;	state Exp;
branches;
next	2.328;

2.328
date	2012.07.26.02.07.11;	author vsnyder;	state Exp;
branches;
next	2.327;

2.327
date	2012.07.04.02.13.03;	author vsnyder;	state Exp;
branches;
next	2.326;

2.326
date	2012.06.06.20.37.56;	author vsnyder;	state Exp;
branches;
next	2.325;

2.325
date	2012.05.08.17.50.52;	author pwagner;	state Exp;
branches;
next	2.324;

2.324
date	2012.04.20.01.37.47;	author vsnyder;	state Exp;
branches;
next	2.323;

2.323
date	2012.03.13.01.48.25;	author vsnyder;	state Exp;
branches;
next	2.322;

2.322
date	2012.03.07.01.58.40;	author vsnyder;	state Exp;
branches;
next	2.321;

2.321
date	2012.02.10.23.46.24;	author vsnyder;	state Exp;
branches;
next	2.320;

2.320
date	2012.02.01.00.18.38;	author vsnyder;	state Exp;
branches;
next	2.319;

2.319
date	2012.02.01.00.17.07;	author vsnyder;	state Exp;
branches;
next	2.318;

2.318
date	2012.01.27.01.06.26;	author pwagner;	state Exp;
branches;
next	2.317;

2.317
date	2012.01.04.02.14.55;	author vsnyder;	state Exp;
branches;
next	2.316;

2.316
date	2012.01.04.01.51.26;	author vsnyder;	state Exp;
branches;
next	2.315;

2.315
date	2011.12.21.01.42.22;	author vsnyder;	state Exp;
branches;
next	2.314;

2.314
date	2011.08.29.22.13.42;	author pwagner;	state Exp;
branches;
next	2.313;

2.313
date	2011.05.09.18.24.31;	author pwagner;	state Exp;
branches;
next	2.312;

2.312
date	2010.08.27.23.59.36;	author vsnyder;	state Exp;
branches;
next	2.311;

2.311
date	2010.08.27.06.31.45;	author yanovsky;	state Exp;
branches;
next	2.310;

2.310
date	2010.08.06.23.08.48;	author pwagner;	state Exp;
branches;
next	2.309;

2.309
date	2010.03.24.20.56.46;	author vsnyder;	state Exp;
branches;
next	2.308;

2.308
date	2010.02.25.18.19.27;	author pwagner;	state Exp;
branches;
next	2.307;

2.307
date	2009.11.23.21.10.18;	author vsnyder;	state Exp;
branches;
next	2.306;

2.306
date	2009.10.26.17.12.39;	author pwagner;	state Exp;
branches;
next	2.305;

2.305
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.304;

2.304
date	2009.06.16.17.40.02;	author pwagner;	state Exp;
branches;
next	2.303;

2.303
date	2009.03.14.02.43.19;	author honghanh;	state Exp;
branches;
next	2.302;

2.302
date	2008.12.18.21.13.05;	author pwagner;	state Exp;
branches;
next	2.301;

2.301
date	2007.12.07.01.14.03;	author pwagner;	state Exp;
branches;
next	2.300;

2.300
date	2007.11.15.22.53.16;	author pwagner;	state Exp;
branches;
next	2.299;

2.299
date	2007.11.08.03.24.39;	author vsnyder;	state Exp;
branches;
next	2.298;

2.298
date	2007.11.05.18.37.19;	author pwagner;	state Exp;
branches;
next	2.297;

2.297
date	2007.10.04.20.43.12;	author vsnyder;	state Exp;
branches;
next	2.296;

2.296
date	2007.10.04.01.49.42;	author vsnyder;	state Exp;
branches;
next	2.295;

2.295
date	2007.10.02.22.51.27;	author vsnyder;	state Exp;
branches;
next	2.294;

2.294
date	2007.09.12.00.17.05;	author vsnyder;	state Exp;
branches;
next	2.293;

2.293
date	2007.09.08.00.31.49;	author vsnyder;	state Exp;
branches;
next	2.292;

2.292
date	2007.09.06.00.36.51;	author vsnyder;	state Exp;
branches;
next	2.291;

2.291
date	2007.08.20.22.05.30;	author pwagner;	state Exp;
branches;
next	2.290;

2.290
date	2007.06.29.19.32.07;	author vsnyder;	state Exp;
branches;
next	2.289;

2.289
date	2007.04.03.17.47.14;	author vsnyder;	state Exp;
branches;
next	2.288;

2.288
date	2007.02.28.23.27.51;	author vsnyder;	state Exp;
branches;
next	2.287;

2.287
date	2006.12.09.00.45.35;	author vsnyder;	state Exp;
branches;
next	2.286;

2.286
date	2006.10.04.22.52.48;	author vsnyder;	state Exp;
branches;
next	2.285;

2.285
date	2006.10.04.19.39.38;	author vsnyder;	state Exp;
branches;
next	2.284;

2.284
date	2006.09.21.18.51.14;	author pwagner;	state Exp;
branches;
next	2.283;

2.283
date	2006.09.20.00.43.38;	author vsnyder;	state Exp;
branches;
next	2.282;

2.282
date	2006.08.11.20.58.38;	author vsnyder;	state Exp;
branches;
next	2.281;

2.281
date	2006.08.04.18.11.33;	author vsnyder;	state Exp;
branches;
next	2.280;

2.280
date	2006.08.01.02.48.33;	author vsnyder;	state Exp;
branches;
next	2.279;

2.279
date	2006.07.21.20.13.29;	author pwagner;	state Exp;
branches;
next	2.278;

2.278
date	2006.07.19.22.28.59;	author vsnyder;	state Exp;
branches;
next	2.277;

2.277
date	2006.06.08.23.59.46;	author vsnyder;	state Exp;
branches;
next	2.276;

2.276
date	2006.06.06.18.54.21;	author vsnyder;	state Exp;
branches;
next	2.275;

2.275
date	2006.06.06.00.51.23;	author vsnyder;	state Exp;
branches;
next	2.274;

2.274
date	2006.06.06.00.31.20;	author vsnyder;	state Exp;
branches;
next	2.273;

2.273
date	2006.06.03.01.04.59;	author vsnyder;	state Exp;
branches;
next	2.272;

2.272
date	2006.06.03.00.15.20;	author vsnyder;	state Exp;
branches;
next	2.271;

2.271
date	2006.05.31.18.22.26;	author pwagner;	state Exp;
branches;
next	2.270;

2.270
date	2006.05.30.22.51.21;	author vsnyder;	state Exp;
branches;
next	2.269;

2.269
date	2006.03.30.19.00.50;	author vsnyder;	state Exp;
branches;
next	2.268;

2.268
date	2006.03.30.18.57.01;	author vsnyder;	state Exp;
branches;
next	2.267;

2.267
date	2006.03.22.23.47.14;	author vsnyder;	state Exp;
branches;
next	2.266;

2.266
date	2006.02.10.21.17.09;	author pwagner;	state Exp;
branches;
next	2.265;

2.265
date	2006.01.21.00.04.14;	author livesey;	state Exp;
branches;
next	2.264;

2.264
date	2005.12.21.21.48.03;	author livesey;	state Exp;
branches;
next	2.263;

2.263
date	2005.06.03.02.09.46;	author vsnyder;	state Exp;
branches;
next	2.262;

2.262
date	2005.05.27.23.57.03;	author vsnyder;	state Exp;
branches;
next	2.261;

2.261
date	2005.03.15.01.27.58;	author vsnyder;	state Exp;
branches;
next	2.260;

2.260
date	2004.06.16.23.41.39;	author vsnyder;	state Exp;
branches;
next	2.259;

2.259
date	2004.06.16.01.21.57;	author vsnyder;	state Exp;
branches;
next	2.258;

2.258
date	2004.06.16.00.01.36;	author livesey;	state Exp;
branches;
next	2.257;

2.257
date	2004.05.19.19.16.12;	author vsnyder;	state Exp;
branches;
next	2.256;

2.256
date	2004.04.19.23.25.55;	author livesey;	state Exp;
branches;
next	2.255;

2.255
date	2004.04.19.19.23.44;	author livesey;	state Exp;
branches;
next	2.254;

2.254
date	2004.01.29.01.45.32;	author livesey;	state Exp;
branches;
next	2.253;

2.253
date	2004.01.24.03.22.49;	author livesey;	state Exp;
branches;
next	2.252;

2.252
date	2003.10.07.01.17.52;	author vsnyder;	state Exp;
branches;
next	2.251;

2.251
date	2003.09.11.23.16.11;	author livesey;	state Exp;
branches;
next	2.250;

2.250
date	2003.09.05.23.24.09;	author pwagner;	state Exp;
branches;
next	2.249;

2.249
date	2003.07.09.23.49.13;	author vsnyder;	state Exp;
branches;
next	2.248;

2.248
date	2003.06.20.19.38.26;	author pwagner;	state Exp;
branches;
next	2.247;

2.247
date	2003.06.03.19.24.19;	author livesey;	state Exp;
branches;
next	2.246;

2.246
date	2003.05.14.23.40.51;	author dwu;	state Exp;
branches;
next	2.245;

2.245
date	2003.05.14.23.38.15;	author dwu;	state Exp;
branches;
next	2.244;

2.244
date	2003.05.14.03.55.10;	author dwu;	state Exp;
branches;
next	2.243;

2.243
date	2003.05.13.22.25.39;	author dwu;	state Exp;
branches;
next	2.242;

2.242
date	2003.05.13.20.43.05;	author dwu;	state Exp;
branches;
next	2.241;

2.241
date	2003.05.13.19.32.28;	author dwu;	state Exp;
branches;
next	2.240;

2.240
date	2003.04.04.22.02.06;	author livesey;	state Exp;
branches;
next	2.239;

2.239
date	2003.03.27.20.45.22;	author livesey;	state Exp;
branches;
next	2.238;

2.238
date	2003.03.07.03.17.03;	author livesey;	state Exp;
branches;
next	2.237;

2.237
date	2003.03.06.00.46.41;	author livesey;	state Exp;
branches;
next	2.236;

2.236
date	2003.02.25.21.12.48;	author dwu;	state Exp;
branches;
next	2.235;

2.235
date	2003.02.25.19.04.43;	author dwu;	state Exp;
branches;
next	2.234;

2.234
date	2003.02.25.18.58.35;	author dwu;	state Exp;
branches;
next	2.233;

2.233
date	2003.02.24.19.20.40;	author dwu;	state Exp;
branches;
next	2.232;

2.232
date	2003.02.14.01.56.36;	author livesey;	state Exp;
branches;
next	2.231;

2.231
date	2003.02.12.02.11.13;	author livesey;	state Exp;
branches
	2.231.2.1;
next	2.230;

2.230
date	2003.02.08.00.20.25;	author livesey;	state Exp;
branches;
next	2.229;

2.229
date	2003.02.05.20.59.16;	author dwu;	state Exp;
branches;
next	2.228;

2.228
date	2003.02.05.04.07.05;	author dwu;	state Exp;
branches;
next	2.227;

2.227
date	2003.02.03.23.08.50;	author vsnyder;	state Exp;
branches;
next	2.226;

2.226
date	2003.01.29.22.43.46;	author livesey;	state Exp;
branches;
next	2.225;

2.225
date	2003.01.18.02.15.43;	author vsnyder;	state Exp;
branches;
next	2.224;

2.224
date	2003.01.18.01.40.10;	author vsnyder;	state Exp;
branches;
next	2.223;

2.223
date	2003.01.17.22.59.47;	author livesey;	state Exp;
branches;
next	2.222;

2.222
date	2003.01.17.22.13.46;	author dwu;	state Exp;
branches;
next	2.221;

2.221
date	2003.01.17.16.55.19;	author dwu;	state Exp;
branches;
next	2.220;

2.220
date	2003.01.16.21.48.22;	author vsnyder;	state Exp;
branches;
next	2.219;

2.219
date	2003.01.16.04.06.58;	author vsnyder;	state Exp;
branches;
next	2.218;

2.218
date	2003.01.15.01.49.29;	author vsnyder;	state Exp;
branches;
next	2.217;

2.217
date	2003.01.14.22.14.43;	author dwu;	state Exp;
branches;
next	2.216;

2.216
date	2003.01.13.17.17.29;	author jonathan;	state Exp;
branches;
next	2.215;

2.215
date	2003.01.12.07.33.42;	author dwu;	state Exp;
branches;
next	2.214;

2.214
date	2003.01.11.15.51.34;	author dwu;	state Exp;
branches;
next	2.213;

2.213
date	2003.01.11.08.08.01;	author dwu;	state Exp;
branches;
next	2.212;

2.212
date	2003.01.11.02.14.55;	author livesey;	state Exp;
branches;
next	2.211;

2.211
date	2003.01.11.01.02.50;	author livesey;	state Exp;
branches;
next	2.210;

2.210
date	2003.01.08.23.52.38;	author livesey;	state Exp;
branches;
next	2.209;

2.209
date	2003.01.07.23.44.17;	author livesey;	state Exp;
branches;
next	2.208;

2.208
date	2002.12.11.01.58.54;	author livesey;	state Exp;
branches;
next	2.207;

2.207
date	2002.12.06.18.41.24;	author livesey;	state Exp;
branches;
next	2.206;

2.206
date	2002.11.23.00.07.13;	author vsnyder;	state Exp;
branches;
next	2.205;

2.205
date	2002.11.22.00.11.16;	author livesey;	state Exp;
branches;
next	2.204;

2.204
date	2002.11.20.21.05.55;	author livesey;	state Exp;
branches;
next	2.203;

2.203
date	2002.11.20.01.10.03;	author livesey;	state Exp;
branches;
next	2.202;

2.202
date	2002.10.29.20.51.27;	author livesey;	state Exp;
branches;
next	2.201;

2.201
date	2002.10.25.23.56.04;	author livesey;	state Exp;
branches;
next	2.200;

2.200
date	2002.10.25.22.24.42;	author livesey;	state Exp;
branches;
next	2.199;

2.199
date	2002.10.25.01.13.46;	author livesey;	state Exp;
branches;
next	2.198;

2.198
date	2002.10.23.23.27.40;	author livesey;	state Exp;
branches;
next	2.197;

2.197
date	2002.10.23.01.32.31;	author vsnyder;	state Exp;
branches;
next	2.196;

2.196
date	2002.10.23.01.14.41;	author livesey;	state Exp;
branches;
next	2.195;

2.195
date	2002.10.19.23.41.04;	author livesey;	state Exp;
branches;
next	2.194;

2.194
date	2002.10.19.18.49.17;	author livesey;	state Exp;
branches;
next	2.193;

2.193
date	2002.10.19.01.52.21;	author livesey;	state Exp;
branches;
next	2.192;

2.192
date	2002.10.18.22.05.42;	author vsnyder;	state Exp;
branches;
next	2.191;

2.191
date	2002.10.17.23.12.51;	author vsnyder;	state Exp;
branches;
next	2.190;

2.190
date	2002.10.17.00.16.40;	author vsnyder;	state Exp;
branches;
next	2.189;

2.189
date	2002.10.08.17.41.38;	author livesey;	state Exp;
branches;
next	2.188;

2.188
date	2002.10.08.17.36.22;	author pwagner;	state Exp;
branches;
next	2.187;

2.187
date	2002.10.06.02.04.57;	author livesey;	state Exp;
branches;
next	2.186;

2.186
date	2002.09.25.20.08.43;	author livesey;	state Exp;
branches;
next	2.185;

2.185
date	2002.09.23.23.15.08;	author vsnyder;	state Exp;
branches;
next	2.184;

2.184
date	2002.09.23.20.21.21;	author livesey;	state Exp;
branches;
next	2.183;

2.183
date	2002.09.21.00.33.34;	author vsnyder;	state Exp;
branches;
next	2.182;

2.182
date	2002.09.21.00.04.14;	author vsnyder;	state Exp;
branches;
next	2.181;

2.181
date	2002.09.19.01.26.46;	author vsnyder;	state Exp;
branches;
next	2.180;

2.180
date	2002.09.18.23.56.01;	author vsnyder;	state Exp;
branches;
next	2.179;

2.179
date	2002.09.14.02.46.30;	author vsnyder;	state Exp;
branches;
next	2.178;

2.178
date	2002.09.14.00.37.37;	author vsnyder;	state Exp;
branches;
next	2.177;

2.177
date	2002.09.13.23.55.01;	author livesey;	state Exp;
branches;
next	2.176;

2.176
date	2002.09.13.20.05.06;	author vsnyder;	state Exp;
branches;
next	2.175;

2.175
date	2002.09.13.18.10.10;	author pwagner;	state Exp;
branches;
next	2.174;

2.174
date	2002.09.11.20.21.49;	author livesey;	state Exp;
branches;
next	2.173;

2.173
date	2002.09.11.17.40.59;	author livesey;	state Exp;
branches;
next	2.172;

2.172
date	2002.09.11.14.06.42;	author livesey;	state Exp;
branches;
next	2.171;

2.171
date	2002.09.11.01.14.47;	author livesey;	state Exp;
branches;
next	2.170;

2.170
date	2002.09.06.00.46.18;	author livesey;	state Exp;
branches;
next	2.169;

2.169
date	2002.09.05.23.08.22;	author livesey;	state Exp;
branches;
next	2.168;

2.168
date	2002.08.29.04.45.37;	author livesey;	state Exp;
branches;
next	2.167;

2.167
date	2002.08.28.00.51.04;	author vsnyder;	state Exp;
branches;
next	2.166;

2.166
date	2002.08.26.20.01.59;	author livesey;	state Exp;
branches;
next	2.165;

2.165
date	2002.08.24.01.38.28;	author vsnyder;	state Exp;
branches;
next	2.164;

2.164
date	2002.08.22.00.06.50;	author vsnyder;	state Exp;
branches;
next	2.163;

2.163
date	2002.08.21.19.55.31;	author vsnyder;	state Exp;
branches;
next	2.162;

2.162
date	2002.08.20.19.55.02;	author vsnyder;	state Exp;
branches;
next	2.161;

2.161
date	2002.08.08.22.02.52;	author vsnyder;	state Exp;
branches;
next	2.160;

2.160
date	2002.08.06.02.16.09;	author livesey;	state Exp;
branches;
next	2.159;

2.159
date	2002.08.05.19.40.11;	author vsnyder;	state Exp;
branches;
next	2.158;

2.158
date	2002.08.03.20.40.58;	author livesey;	state Exp;
branches;
next	2.157;

2.157
date	2002.08.03.01.16.17;	author vsnyder;	state Exp;
branches;
next	2.156;

2.156
date	2002.07.31.22.43.30;	author vsnyder;	state Exp;
branches;
next	2.155;

2.155
date	2002.07.26.22.47.56;	author vsnyder;	state Exp;
branches;
next	2.154;

2.154
date	2002.07.26.01.20.22;	author vsnyder;	state Exp;
branches;
next	2.153;

2.153
date	2002.07.24.01.08.40;	author vsnyder;	state Exp;
branches;
next	2.152;

2.152
date	2002.07.22.23.14.28;	author pwagner;	state Exp;
branches;
next	2.151;

2.151
date	2002.07.22.22.53.42;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2002.07.08.21.05.09;	author vsnyder;	state Exp;
branches;
next	2.149;

2.149
date	2002.07.04.00.34.55;	author vsnyder;	state Exp;
branches;
next	2.148;

2.148
date	2002.07.02.01.38.06;	author vsnyder;	state Exp;
branches;
next	2.147;

2.147
date	2002.07.01.23.43.17;	author vsnyder;	state Exp;
branches;
next	2.146;

2.146
date	2002.06.25.20.45.31;	author vsnyder;	state Exp;
branches;
next	2.145;

2.145
date	2002.06.18.01.19.52;	author vsnyder;	state Exp;
branches;
next	2.144;

2.144
date	2002.06.07.01.34.26;	author vsnyder;	state Exp;
branches;
next	2.143;

2.143
date	2002.05.22.19.16.51;	author vsnyder;	state Exp;
branches;
next	2.142;

2.142
date	2002.05.22.19.00.38;	author vsnyder;	state Exp;
branches;
next	2.141;

2.141
date	2002.05.07.01.02.24;	author vsnyder;	state Exp;
branches
	2.141.2.1;
next	2.140;

2.140
date	2002.04.22.23.00.58;	author vsnyder;	state Exp;
branches;
next	2.139;

2.139
date	2002.04.22.20.55.00;	author vsnyder;	state Exp;
branches;
next	2.138;

2.138
date	2002.03.13.22.01.50;	author livesey;	state Exp;
branches;
next	2.137;

2.137
date	2002.03.08.08.07.16;	author livesey;	state Exp;
branches;
next	2.136;

2.136
date	2002.03.06.01.44.30;	author livesey;	state Exp;
branches;
next	2.135;

2.135
date	2002.02.14.21.55.31;	author vsnyder;	state Exp;
branches;
next	2.134;

2.134
date	2002.02.13.00.11.13;	author vsnyder;	state Exp;
branches;
next	2.133;

2.133
date	2002.02.12.22.53.21;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2002.02.09.19.11.34;	author livesey;	state Exp;
branches;
next	2.131;

2.131
date	2002.02.08.22.51.59;	author livesey;	state Exp;
branches;
next	2.130;

2.130
date	2002.02.07.02.55.02;	author vsnyder;	state Exp;
branches;
next	2.129;

2.129
date	2002.02.05.02.40.52;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2002.01.18.00.31.23;	author livesey;	state Exp;
branches;
next	2.127;

2.127
date	2001.12.03.18.50.43;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2001.12.01.01.01.56;	author livesey;	state Exp;
branches;
next	2.125;

2.125
date	2001.11.28.23.16.39;	author livesey;	state Exp;
branches;
next	2.124;

2.124
date	2001.11.28.20.39.35;	author livesey;	state Exp;
branches;
next	2.123;

2.123
date	2001.11.28.18.28.50;	author livesey;	state Exp;
branches;
next	2.122;

2.122
date	2001.11.28.00.01.27;	author jonathan;	state Exp;
branches;
next	2.121;

2.121
date	2001.11.27.23.49.48;	author jonathan;	state Exp;
branches;
next	2.120;

2.120
date	2001.11.27.23.34.49;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2001.11.27.01.28.17;	author vsnyder;	state Exp;
branches;
next	2.118;

2.118
date	2001.11.17.02.30.44;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2001.11.13.23.35.12;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2001.11.12.18.25.02;	author dwu;	state Exp;
branches;
next	2.115;

2.115
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2001.11.08.01.21.45;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2001.11.07.23.55.43;	author dwu;	state Exp;
branches;
next	2.112;

2.112
date	2001.11.06.18.04.11;	author dwu;	state Exp;
branches;
next	2.111;

2.111
date	2001.11.02.01.11.45;	author dwu;	state Exp;
branches;
next	2.110;

2.110
date	2001.11.01.19.29.01;	author dwu;	state Exp;
branches;
next	2.109;

2.109
date	2001.10.31.21.59.56;	author livesey;	state Exp;
branches;
next	2.108;

2.108
date	2001.10.30.16.57.43;	author dwu;	state Exp;
branches;
next	2.107;

2.107
date	2001.10.26.20.28.42;	author dwu;	state Exp;
branches;
next	2.106;

2.106
date	2001.10.24.00.29.00;	author livesey;	state Exp;
branches;
next	2.105;

2.105
date	2001.10.23.20.08.59;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2001.10.22.22.40.21;	author livesey;	state Exp;
branches;
next	2.103;

2.103
date	2001.10.22.22.34.47;	author dwu;	state Exp;
branches;
next	2.102;

2.102
date	2001.10.22.22.25.17;	author dwu;	state Exp;
branches;
next	2.101;

2.101
date	2001.10.22.20.52.00;	author dwu;	state Exp;
branches;
next	2.100;

2.100
date	2001.10.20.17.50.48;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2001.10.19.17.42.36;	author dwu;	state Exp;
branches;
next	2.98;

2.98
date	2001.10.18.23.25.13;	author dwu;	state Exp;
branches;
next	2.97;

2.97
date	2001.10.17.23.37.29;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2001.10.17.20.50.30;	author dwu;	state Exp;
branches;
next	2.95;

2.95
date	2001.10.17.19.52.43;	author dwu;	state Exp;
branches;
next	2.94;

2.94
date	2001.10.16.23.35.39;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2001.10.15.23.21.47;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2001.10.15.22.41.11;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2001.10.11.16.28.25;	author dwu;	state Exp;
branches;
next	2.90;

2.90
date	2001.10.09.20.39.36;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2001.10.09.20.38.23;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2001.10.05.20.50.16;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2001.10.05.20.20.16;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2001.10.05.05.02.27;	author dwu;	state Exp;
branches;
next	2.85;

2.85
date	2001.10.05.01.46.25;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2001.10.04.01.48.59;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2001.10.04.00.30.34;	author dwu;	state Exp;
branches;
next	2.82;

2.82
date	2001.10.03.23.56.30;	author dwu;	state Exp;
branches;
next	2.81;

2.81
date	2001.10.03.22.05.12;	author dwu;	state Exp;
branches;
next	2.80;

2.80
date	2001.10.03.21.49.54;	author dwu;	state Exp;
branches;
next	2.79;

2.79
date	2001.10.03.21.30.16;	author dwu;	state Exp;
branches;
next	2.78;

2.78
date	2001.10.03.17.57.21;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2001.10.02.23.41.11;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2001.10.02.16.49.56;	author livesey;	state Exp;
branches;
next	2.75;

2.75
date	2001.10.01.23.30.50;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2001.10.01.23.04.17;	author livesey;	state Exp;
branches;
next	2.73;

2.73
date	2001.10.01.22.54.22;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2001.10.01.20.30.48;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2001.09.29.00.07.11;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2001.09.28.18.25.37;	author dwu;	state Exp;
branches;
next	2.69;

2.69
date	2001.09.28.17.50.30;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2001.09.27.20.14.50;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2001.09.27.18.40.26;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2001.09.26.02.15.40;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2001.09.25.23.04.30;	author livesey;	state Exp;
branches;
next	2.64;

2.64
date	2001.09.25.20.42.55;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2001.09.25.17.49.59;	author livesey;	state Exp;
branches;
next	2.62;

2.62
date	2001.09.25.05.57.36;	author livesey;	state Exp;
branches;
next	2.61;

2.61
date	2001.09.25.00.49.59;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2001.09.25.00.18.36;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2001.09.20.00.31.06;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2001.07.19.22.00.41;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2001.07.12.22.18.05;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2001.07.12.22.11.46;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2001.07.11.22.06.31;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2001.07.02.17.21.48;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2001.06.30.03.10.35;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2001.06.30.03.07.43;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2001.06.30.02.35.43;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2001.06.27.04.31.29;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2001.06.27.04.05.32;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2001.06.26.20.11.32;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2001.06.26.19.01.00;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2001.06.26.18.18.14;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2001.06.26.17.57.46;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2001.06.26.16.26.32;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2001.06.22.01.26.54;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2001.06.20.22.21.22;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2001.06.20.21.44.33;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2001.06.01.22.26.03;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2001.06.01.21.58.17;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2001.06.01.21.40.18;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2001.06.01.21.27.48;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2001.06.01.20.36.34;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2001.06.01.01.02.32;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2001.05.24.23.28.45;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2001.05.22.19.10.59;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2001.05.19.01.17.39;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2001.05.19.00.22.31;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2001.05.18.23.18.42;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2001.05.18.19.46.23;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2001.05.18.01.04.08;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2001.05.10.22.50.45;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.05.03.02.00.15;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2001.05.02.05.28.04;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.05.01.23.52.04;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2001.04.28.01.47.17;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.26.23.43.23;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.26.19.48.20;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.26.02.53.37;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.04.26.01.04.21;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2001.04.26.01.00.01;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.21.01.44.43;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.19.23.56.23;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.13.21.40.58;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.12.01.50.21;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.10.02.46.17;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.07.01.50.48;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.03.17.00.45.15;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.03.15.21.18.57;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.09.03.05.05;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.08.03.23.09;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.07.23.59.52;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.02.22.18.54.05;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.02.22.01.57.02;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.09.19.30.16;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.08.00.56.55;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.01.26.19.01.47;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2001.01.10.21.04.13;	author vsnyder;	state Exp;
branches;
next	;

2.231.2.1
date	2003.02.24.19.22.04;	author dwu;	state Exp;
branches;
next	2.231.2.2;

2.231.2.2
date	2003.02.25.18.59.33;	author dwu;	state Exp;
branches;
next	2.231.2.3;

2.231.2.3
date	2003.02.25.19.05.23;	author dwu;	state Exp;
branches;
next	;

2.141.2.1
date	2002.05.22.23.14.59;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.368
log
@Perform NeuralNet even when skipping retrievals
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module RetrievalModule
!=============================================================================

!{This module inverts the radiative transfer equation, to solve for
! atmospheric parameters, given radiance measurements.
!
! This module and ones it calls consume most of the cycles.

  implicit none
  private
  public :: RETRIEVE

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: RetrievalModule.f90,v $"
!---------------------------------------------------------------------------

  ! Aitken acceleration code was originally defective, in that DX was not
  ! being multiplied by the Aitken parameter AJ%CAIT.  If Do_Aitken is set
  ! true, Aitken acceleration is actually done.
  logical, parameter :: Do_Aitken = .false.

contains

  ! ---------------------------------------------------  Retrieve  -----
  subroutine RETRIEVE ( ROOT, VECTORDATABASE, MATRIXDATABASE, HESSIANDATABASE, &
    & CONFIGDATABASE, CHUNK, FILEDATABASE )

  !{Process the ``Retrieve'' section of the L2 Configuration File.
  ! The ``Retrieve'' section can have ForwardModel, Matrix, Sids, Subset or
  ! Retrieve specifications.

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, TrackAllocates
    use Bitstuff, only: CountBits
    use Chunks_m, only: MLSChunk_t
    use CloudRetrievalModule, only: CloudRetrieval
    use DumpCommand_m, only: &
      & BooleanFromAnyGoodvalues, &
      & BooleanFromCatchWarning, BooleanFromComparingQtys, BooleanFromFormula, &
      & DumpCommand, InitializeRepeat, NextRepeat, &
      & MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, Repeat=>Skip, Skip
    use HessianModule_1, only: Hessian_t, CreateEmptyHessian, DestroyHessian
    use IEEE_Arithmetic, only: iEEE_Is_NaN
    use Expr_m, only: Expr
    use ForwardModelConfig, only: ForwardModelConfig_t
    use Init_TableS_Module, only: F_Apriori, F_AprioriFraction, F_AprioriScale, &
      & F_Average, F_ColumnScale, F_Comment, F_Covariance, F_CovSansReg, &
      & F_Diagnostics, F_Diagonal, F_DumpQuantities, F_ExtendedAverage, &
      & F_ForwardModel, F_Fuzz, F_FwdModelExtra, F_FwdModelOut, &
      & F_Hessian, F_HighBound, F_HregOrders, F_HregQuants, F_HregWeights, &
      & F_HregWeightVec, F_Jacobian, F_Lambda, F_LambdaMin, F_Level, &
      & F_LowBound, &
      & F_MaxJ, F_Measurements, F_MeasurementSD, F_Method, F_MuMin, &
      & F_NegateSD, &
      & F_OutputCovariance, F_OutputSD, &
      & F_PhaseName, F_PrecisionFactor, &
      & F_RegAfter, F_RegApriori, F_Serial, F_SparseQuantities, &
      & F_State, F_StateMax, F_StateMin, F_Switches, F_Toggles, &
      & F_ToleranceA, F_ToleranceF, F_ToleranceR, &
      & F_VregOrders, F_VregQuants, F_VregWeights, F_VregWeightVec, &
      & Field_First, Field_Last, &
      & L_Apriori, L_Covariance, &
      & L_DNWT_Abandoned,  L_DNWT_Ajn,  L_DNWT_Axmax, &
      & L_DNWT_Cait, L_DNWT_ChisqMinNorm, L_DNWT_ChisqNorm, L_DNWT_count, &
      & L_DNWT_Diag,  L_DNWT_dxdx, L_DNWT_dxdxl, L_DNWT_dxn,  L_DNWT_dxnl, &
      & L_DNWT_Flag, L_DNWT_Fnmin, L_DNWT_Fnorm,  L_DNWT_gdx,  L_DNWT_gfac, &
      & L_DNWT_gradn,  L_DNWT_sq, L_DNWT_sq,  L_DNWT_sqt, &
      & L_HighCloud, L_Jacobian_Cols, L_Jacobian_Rows, L_LowCloud, &
      & L_Newtonian, L_None, L_Norm, L_NumGrad, L_NumJ, L_NumNewt, L_Simple, &
      & S_AnyGoodValues, S_CatchWarning, S_Case, S_Compare, &
      & S_Diff, S_Dump, S_DumpBlocks, S_EndSelect, S_FlagCloud, S_FlushPFA, &
      & S_LeakCheck, S_NeuralNet, &
      & S_Reevaluate, S_Repeat, S_RestrictRange, S_Retrieve, &
      & S_Select, S_SIDS, S_Skip, S_Snoop, S_Subset, S_Time, S_UpdateMask
    use L2parinfo, only: Parallel
    use MatrixModule_1, only: AddToMatrixDatabase, CopyMatrix, CreateEmptyMatrix, &
      & DestroyMatrix, GetFromMatrixDatabase, NullifyMatrix, Matrix_t, &
      & Matrix_Database_t, Matrix_SPD_t, MultiplyMatrixVectorNoT, &
      & ReflectMatrix, Sparsify, MultiplyMatrix_XTY
    use MatrixTools, only: DumpBlocks
    use MLSKinds, only: R8, RV
    use MLSCommon, only: MLSFile_t
    use MLSL2Options, only: L2CFNode, L2Options, SpecialDumpFile, &
      & StateFilledBySkippedRetrievals
    use MLSL2timings, only: Section_Times, Total_Times, Add_To_Retrieval_Timing
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, MLSMessageReset, &
      & MLSMessage
    use MoreTree, only: Get_Boolean, Get_Label_And_Spec, Get_Field_Id, &
      & Get_Spec_Id
    use MLSStringlists, only: SwitchDetail
    use MLSStrings, only: WriteIntsToChars
    use NeuralNet_M, only: NeuralNet
    use Next_Tree_Node_m, only: Init_Next_Tree_Node, Next_Tree_Node, &
      & Next_Tree_Node_State
    use Output_m, only: Blanks, Output, RevertOutput, SwitchOutput
    use PFAData_m, only: Flush_PFAData
    use Set_Toggles_m, only: Set_Toggles
    use SIDSModule, only: SIDS
    use SnoopMLSL2, only: Snoop
    use String_Table, only: Display_String, Get_String
    use SubsetModule, only: SetupSubset, SetupFlagCloud, RestrictRange, UpdateMask
    use Time_m, only: Time_Now
    use Toggles, only: GEN, Switches, Toggle, Levels
    use Trace_m, only: Trace_Begin, Trace_End
    use Track_m, only: ReportLeaks
    use Tree, only: Decorate, Decoration, Node_Id, NSons, Sub_Rosa, Subtree, &
      & Where
    use Tree_Types, only: N_Array
    use Vectorsmodule, only: ClearMask, ClearUnderMask, &
      & ClearVector, CloneVector, CopyVector, CopyVectorMask, CreateMask, &
      & DestroyVectorInfo, DumpVectorNorms, GetVectorQuantityByType, M_Linalg, &
      & Vector_t, VectorValue_t

    ! Dummy arguments:
    integer, intent(in)                               :: Root ! Of the relevant subtree of the AST;
                                                              ! It indexes an n_cf vertex
    type(vector_T), dimension(:), target              :: VectorDatabase
    type(matrix_Database_T), dimension(:), pointer    :: MatrixDatabase
    type(Hessian_T), dimension(:), pointer            :: HessianDatabase
    type(forwardModelConfig_T), dimension(:), pointer :: ConfigDatabase
    type(MLSChunk_T), intent(inout)                   :: Chunk
    type (MLSFile_T), dimension(:), pointer           :: FileDatabase

    ! Default values:
    real(r8), parameter :: DefaultInitLambda = 0.0_r8
    real(r8), parameter :: DefaultLambdaMin = 0.0_r8
    integer, parameter :: DefaultMaxJ = 5
    integer, parameter :: DefaultMethod = l_newtonian
    real(r8), parameter :: DefaultMuMin = 0.1_rv
    double precision, parameter :: DefaultToleranceA = 1.0d-6 ! for NWT
    double precision, parameter :: DefaultToleranceF = 1.0d-6 ! for NWT
    double precision, parameter :: DefaultToleranceR = 1.0d-6 ! for NWT

    ! Local variables:
    type(vector_T), pointer :: Apriori  ! A priori estimate of state
    type(vector_T), pointer :: AprioriFraction ! How much of result is apriori, in [0..1]
    real(r8) :: AprioriScale            ! Weight for apriori, default 1.0
    real(r8) :: ChiSqMinNorm            ! AJ%FNMIN / no degrees of freedom
    real(r8) :: ChiSqNorm               ! AJ%FNORM / no degrees of freedom
    integer :: ColumnScaling            ! one of l_apriori, l_covariance,
                                        ! l_none or l_norm
    integer, pointer, dimension(:) :: ConfigIndices    ! In ConfigDatabase
    type(matrix_SPD_T), pointer :: Covariance     ! covariance**(-1) of Apriori
    logical :: CovSansReg               ! Compute covariance without regularization
    type(vector_T), pointer :: Diagnostics   ! Diagnostic stuff about the
                                        ! retrieval.
    logical :: Diagonal                 ! "Iterate with the diagonal of the
                                        ! a priori covariance matrix until
                                        ! convergence, then put in the whole
                                        ! thing and iterate until it converges
                                        ! again (hopefully only once).
    integer :: DumpQuantitiesNode       ! in the l2cf tree
    integer :: Error
    logical :: ExtendedAverage          ! Averaging kernels based on full
                                        ! Jacobian (last term) not masked
    integer :: Field                    ! Field index -- f_something
    real(r8) :: Fuzz                    ! For testing only.  Amount of "fuzz"
                                        ! to add to state vector before
                                        ! starting a retrieval.
    type(vector_T), pointer :: FwdModelExtra
    type(vector_T), pointer :: FwdModelOut
    logical :: Got(field_first:field_last) ! "Got this field already"
    integer :: GSon                     ! a son of Son.
    type(vector_T), pointer :: HighBound ! For state during retrieval
    integer :: HRegOrders               ! Regularization orders
    integer :: HRegQuants               ! Regularization quantities
    integer :: HRegWeights              ! Weight of regularization conditions
    type(vector_T), pointer :: HRegWeightVec  ! Weight vector for regularization
    integer :: I_Key, J                 ! Subscripts and loop inductors
    real(r8) :: InitLambda              ! Initial Levenberg-Marquardt parameter
    integer :: IxAverage                ! Index in tree of averagingKernel
    integer :: IxCovariance             ! Index in tree of outputCovariance
    integer :: IxJacobian               ! Index in tree of Jacobian matrix
    type(matrix_T), pointer :: Jacobian ! The Jacobian matrix
    type(hessian_T), pointer :: Hessian ! The Hessian
    integer :: Jacobian_Cols            ! Number of columns of the Jacobian.
    integer :: Jacobian_Rows            ! (Number of rows of Jacobian) -
                                        ! (masked-off rows of Jacobian)
    integer :: K                        ! Subscript, loop inductor, local temp
    integer :: Key                      ! Index of an n_spec_args.  Either
                                        ! a son or grandson of root.
    integer :: Label                    ! Of a spec (not actually used)
    real(r8) :: LambdaMin               ! Minimum Levenberg-Marquardt parameter
    type(vector_T), pointer :: LowBound ! For state during retrieval
    integer :: MaxJacobians             ! Maximum number of Jacobian
                                        ! evaluations of Newton method
    type(vector_T), pointer :: Measurements    ! The measurements vector
    type(vector_T), pointer :: MeasurementSD   ! The measurements vector's Std. Dev.
    character(len=32) :: mesg
    character(len=32) :: mesgChunkNo
    integer :: Method                   ! Method to use for inversion, currently
                                        ! only l_Newtonian.
    type(matrix_T), target :: MyAverage ! for OutputAverage to point to
    type(matrix_SPD_T), target :: MyCovariance ! for OutputCovariance to point at
    type(hessian_T), target :: MyHessian       ! for Hessian to point at
    type(matrix_T), target :: MyJacobian       ! for Jacobian to point at
    real(rv) :: MuMin                   ! Smallest shrinking of dx before change direction
    logical :: NegateSD                 ! Flip output error negative for poor information
    type(matrix_T), pointer :: OutputAverage   ! Averaging Kernel
    type(matrix_SPD_T), pointer :: OutputCovariance    ! Covariance of the sol'n
    type(vector_T), pointer :: OutputSD ! Vector containing SD of result
    logical :: ParallelMode             ! Run forward models in parallel
    character(len=127) :: PhaseName     ! To pass to snoopers
    logical :: PotemkinHessian 
    real(rv) :: PrecisionFactor         ! Default 0.5, precisions 'worse than this' set negative
    logical :: REPEATLOOP               ! Do we repeat this section?
    integer :: SaveLevels(size(levels))
    logical :: SaveToggle(size(toggle))
    integer :: Son                      ! Of Root or Key
    character(len=127) :: SnoopComment  ! From comment= field of S_Snoop spec.
    integer :: SnoopKey                 ! Tree point of S_Snoop spec.
    integer :: SnoopLevel               ! From level field of S_Snoop spec.
    integer, dimension(:), pointer :: SparseQuantities ! Which jacobian blocks to sparsify
    integer :: Spec                     ! s_subset or s_retrieve ...
    type(vector_T), pointer :: State    ! The state vector
    type(vector_T), pointer :: StateMax ! Maximum state vector over all iterations
    type(vector_T), pointer :: StateMin ! Minimum state vector over all iterations
    integer :: Status
    integer :: SwitchLen                ! LEN_TRIM(Switches) on entry
    integer :: SwitchLenCur             ! LEN_TRIM(Switches) after command processing
    real :: T0, T1, T2, T3              ! for timing
    type(matrix_T) :: Tikhonov          ! Matrix for Tikhonov regularization
    logical :: TikhonovApriori          ! Regularization is to apriori, not
                                        ! zero -- default false
    logical :: TikhonovBefore           ! "Do Tikhonov before column scaling"
    logical :: TikhonovNeeded           ! got(f_hRegOrders) .or. got(f_vRegOrders)
    logical :: Timing
    double precision :: ToleranceA      ! convergence tolerance for NWT,
                                        ! norm of move
    double precision :: ToleranceF      ! convergence tolerance for NWT,
                                        ! norm of F
    double precision :: ToleranceR      ! convergence tolerance for NWT,
                                        ! (norm of move) / (norm of X)
    integer :: Units(2)                 ! Units of value returned by EXPR
    logical :: Update                   ! "We are updating normal equations"
    double precision :: Value(2)        ! Value returned by EXPR
    integer :: VRegOrders               ! Regularization orders
    integer :: VRegQuants               ! Regularization quantities
    integer :: VRegWeights              ! Weight of regularization conditions
    type(vector_T), pointer :: VRegWeightVec  ! Weight vector for regularization
    type(next_tree_node_state) :: Walk ! of tree traverser
    character(len=63) :: WhereLeakCheck ! From LeakCheck command, else default

    ! Indexes in the private vectors database
    integer, parameter :: FirstVec = 1
    integer, parameter :: AprioriMinusX = firstVec ! Apriori - X
    integer, parameter :: ATb = aprioriMinusX + 1  ! A^T b -- the RHS of the normal eqns    integer, parameter ::
    integer, parameter :: BestGradient = aTb + 1   ! for NWT
    integer, parameter :: BestX = bestGradient + 1 ! for NWT
    integer, parameter :: CandidateDX = bestX + 1  ! for NWT
    integer, parameter :: ColumnScaleVector = candidateDX + 1 ! For column scaling by column norms
                          ! ColumnScaleVector is really a diagonal matrix
    integer, parameter :: CovarianceDiag = columnScaleVector + 1
    integer, parameter :: CovarianceXApriori = covarianceDiag + 1
    integer, parameter :: DiagFlagA = CovarianceXApriori + 1  ! for NWT
    integer, parameter :: DiagFlagB = DiagFlagA + 1  ! for NWT
    integer, parameter :: DX = DiagFlagB + 1       ! for negateSD case
    integer, parameter :: DXUnScaled = dX + 1      ! for NWT
    integer, parameter :: F = dXUnscaled + 1       ! Residual -- Model - Measurements
    integer, parameter :: F_rowScaled = f + 1      ! Either a copy of f, or f row-scaled
    integer, parameter :: Gradient = f_rowScaled + 1   ! for NWT
    integer, parameter :: Reg_X_x = gradient + 1   ! Regularization * X_n
    integer, parameter :: Reg_RHS = reg_X_x + 1    ! RHS for Tikhonov if regApriori
    integer, parameter :: Weight = reg_RHS + 1     ! Scaling vector for rows, 1/measurementSD
    integer, parameter :: X = weight + 1           ! for NWT
    integer, parameter :: LastVec = X

    type(vector_T), dimension(firstVec:lastVec) :: V   ! Database for snoop

    ! Indices for trace strings, need to have negative initial values;
    ! See Push_Stack_b in Call_Stack
    integer :: Me = -1                  ! "Retrieve"
    integer :: Me_FlagCloud = -1        ! "Retrieve.flagCloud"
    integer :: Me_NeuralNet = -1        ! "Retrieve.NeuralNet
    integer :: Me_RestrictRange = -1    ! "Retrieve.RestrictRange
    integer :: Me_Retrieve = -1         ! "Retrieve.retrieve"
    integer :: Me_Subset = -1           ! "Retrieve.subset"
    integer :: Me_UpdateMask = -1       ! "Retrieve.UpdateMask"

    ! Error message codes
    integer, parameter :: ArrayOfArrays = 1
    integer, parameter :: BothOrNeither = ArrayOfArrays + 1
    integer, parameter :: DiagNoCov = BothOrNeither + 1
    integer, parameter :: IfAThenB = DiagNoCov + 1
    integer, parameter :: Inconsistent = IfAThenB + 1   ! Inconsistent fields
    integer, parameter :: NoExtraVec = Inconsistent + 1 ! no FwdModelExtra
    integer, parameter :: NotGeneral = NoExtraVec + 1   ! Not a general matrix
    integer, parameter :: NotSPD = notGeneral + 1       ! Not symmetric pos. definite

    dumpQuantitiesNode = 0
    error = 0
    nullify ( apriori, aprioriFraction, configIndices, covariance, fwdModelOut )
    nullify ( measurements, measurementSD, outputSD, sparseQuantities )
    nullify ( state, stateMax, stateMin )
    phaseName = ' '              ! Default in case there's no field
    snoopComment = ' '           ! Ditto
    snoopKey = 0
    snoopLevel = 1               ! Ditto
    switchLen = len_trim(switches)
    switchLenCur = switchLen + 1
    switches(switchLenCur:switchLenCur) = ','
    timing = section_times
    repeatLoop = .false. ! By default, we will not repeat
    call initializeRepeat
    do j = firstVec, lastVec ! Make the vectors in the database initially empty
      nullify ( v(j)%quantities, v(j)%template%quantities )
      v(j)%name = 0 ! so Snoop won't use it
    end do
    call time_now ( t1 )

    call trace_begin ( me, "Retrieve", root, cond=toggle(gen) )
    if ( specialDumpFile /= ' ' ) &
      & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
repeat_loop: do ! RepeatLoop
      ! Loop over the lines in the configuration file

      call init_next_tree_node ( walk )
      do 
        son = next_tree_node ( root, walk )
        if ( son == 0 ) exit
        call get_label_and_spec ( son, label, key )
        L2CFNODE = key

        ! "Key" now indexes an n_spec_args vertex.  See "Configuration file
        ! parser users' guide" for pictures of the trees being analyzed.

        if ( MLSSelecting .and. &
          & .not. any( get_spec_id(key) == (/ s_endselect, s_select, s_case /) ) ) cycle
        if ( get_spec_id(key) /= s_catchWarning ) &
          & call MLSMessageReset( clearLastWarning=.true. )

        got = .false.
        spec = get_spec_id(key)
        PotemkinHessian = .false.
        select case ( spec )
        case ( s_anygoodvalues )
          call decorate ( key, &
            & BooleanFromAnyGoodValues ( key, vectorDatabase ) )
        case ( s_catchWarning )
          call decorate ( key,  BooleanFromCatchWarning ( key ) )
        case ( s_compare )
          call decorate ( key,  BooleanFromComparingQtys ( key, vectorDatabase ) )
        case ( s_diff, s_dump )
          if ( .not. L2Options%SkipRetrieval ) &
            & call dumpCommand ( key, forwardModelConfigs=configDatabase, &
            & vectors=vectorDatabase, FileDataBase=FileDataBase, &
            & MatrixDatabase=MatrixDatabase, Hessiandatabase=HessianDatabase )
        case ( s_dumpblocks )
          if ( .not. L2Options%SkipRetrieval ) &
            & call DumpBlocks ( key, matrixDatabase, hessianDatabase )
        case ( s_flagCloud )
          call trace_begin ( me_flagCloud, "Retrieve.flagCloud", root, &
            & cond=toggle(gen) .and. levels(gen) > 0 )
          call SetupflagCloud ( key, vectorDatabase )
          call trace_end ( cond=toggle(gen) .and. levels(gen) > 0 )
        case ( s_flushPFA )
          call flush_PFAData ( key, status )
          error = max(error,status)
        case ( s_leakCheck )
          if ( trackAllocates > 0 ) then
            whereLeakCheck = "In retrieval module..."
            if ( nsons(key) > 1 ) then
              call get_string ( sub_rosa(subtree(2,subtree(2,key))), whereLeakCheck, &
                & strip=.true. )
            end if
            call reportLeaks ( whereLeakCheck )
          end if
        case ( s_NeuralNet )
          ! if ( L2Options%SkipRetrieval .and. STATEFILLEDBYSKIPPEDRETRIEVALS == 0. ) cycle
          call trace_begin ( Me_NeuralNet, "Retrieve.NeuralNet", root, &
            & cond=toggle(gen) .and. levels(gen) > 0 )
          call NeuralNet ( key, vectorDatabase, chunk, FileDatabase )
          call trace_end ( cond=toggle(gen) .and. levels(gen) > 0 )
        case ( s_restrictRange )
          call trace_begin ( me_restrictRange, "Retrieve.RestrictRange", root, &
            & cond=toggle(gen) .and. levels(gen) > 0 )
          call RestrictRange ( key, vectorDatabase )
          call trace_end ( cond=toggle(gen) .and. levels(gen) > 0 )
        case ( s_Reevaluate )
          call decorate ( key,  BooleanFromFormula ( 0, key, vectorDatabase ) )
        case ( s_retrieve )
          if ( L2Options%SkipRetrieval .and. STATEFILLEDBYSKIPPEDRETRIEVALS == 0. ) cycle
          call trace_begin ( me_retrieve, "Retrieve.retrieve", root, &
            & cond=toggle(gen) )
          saveLevels = levels
          saveToggle = toggle
          aprioriScale = 1.0
          columnScaling = l_none
          covSansReg = .false.
          diagonal = .false.
          extendedAverage = .false.
          hRegQuants = 0
          hRegWeights = 0
          nullify ( lowBound, highBound, hRegWeightVec )
          initLambda = defaultInitLambda
          lambdaMin = defaultLambdaMin
          maxJacobians = defaultMaxJ
          method = defaultMethod
          muMin = defaultMuMin
          negateSD = .false.
          precisionFactor = 0.5_rv
          toleranceA = defaultToleranceA
          toleranceF = defaultToleranceF
          toleranceR = defaultToleranceR
          vRegQuants = 0
          vRegWeights = 0
          parallelMode = parallel%fwmParallel .and. parallel%master
          tikhonovApriori = .false.
          tikhonovBefore = .true.
          tikhonovNeeded = .false.
          nullify ( vRegWeightVec )
          do i_key = 2, nsons(key) ! fields of the "retrieve" specification
            son = subtree(i_key, key)
            L2CFNODE = son
            field = get_field_id(son)  ! tree_checker prevents duplicates
            got(field) = .true.
            select case ( field )
            case ( f_apriori )
              apriori => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_aprioriFraction )
              aprioriFraction => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_average )
              ixAverage = decoration(subtree(2,son)) ! averagingKernel matrix vertex
            case ( f_columnScale )
              columnScaling = decoration(subtree(2,son))
            case ( f_covariance )      ! of apriori
              call getFromMatrixDatabase ( &
                & matrixDatabase(decoration(decoration(subtree(2,son)))), &
                & covariance)
              if ( .not. associated(covariance) ) &
                & call announceError ( notSPD, field )
            case ( f_covSansReg )
              covSansReg = get_Boolean(son)
            case ( f_diagnostics )
              diagnostics => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_diagonal )
              diagonal = get_Boolean(son)
            case ( f_dumpQuantities )
              dumpQuantitiesNode = son
            case ( f_extendedAverage )
              extendedAverage = get_boolean(son)
            case ( f_forwardModel )
              call allocate_test ( configIndices, nsons(son)-1, "ConfigIndices", &
                & moduleName )
              do k = 2, nsons(son)
                gson = subtree(k,son)
                if ( node_id(gson) == n_array ) then
                  call announceError ( arrayOfArrays, field )
                  configIndices(k-1) = -999
                else
                  configIndices(k-1) = decoration(decoration(gson))
                end if
              end do
            case ( f_fwdModelExtra )
              fwdModelExtra => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_fwdModelOut )
              fwdModelOut => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_highBound )
              highBound => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_hRegOrders )
              hRegOrders = son
              tikhonovNeeded = .true.
            case ( f_hRegQuants )
              hRegQuants = son
            case ( f_hRegWeights )
              hRegWeights = son
            case ( f_hRegWeightVec )
              hRegWeightVec => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_jacobian )
              ixJacobian = decoration(subtree(2,son)) ! jacobian: matrix vertex
            case ( f_lowBound )
              lowBound => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_measurements )
              measurements => vectorDatabase(decoration(decoration(subtree(2,son))))
              call cloneVector ( v(f), measurements, vectorNameText='_f' )
            case ( f_measurementSD )
              measurementSD => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_method )
              method = decoration(subtree(2,son))
            case ( f_negateSD )
              negateSD = get_boolean ( son )
            case ( f_regAfter )
              tikhonovBefore = .not. get_Boolean(son)
            case ( f_regApriori )
              tikhonovApriori = get_Boolean(son)
            case ( f_serial )
              parallelMode = parallelMode .and. .not. get_boolean ( son )
            case ( f_outputCovariance )
              ixCovariance = decoration(subtree(2,son)) ! outCov: matrix vertex
            case ( f_outputSD )
              outputSD => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_sparseQuantities )
              call Allocate_Test ( sparseQuantities, nsons(son)-1, &
                & 'sparseQuantities', ModuleName )
              do k = 2, nsons(son)
                gson = subtree(k,son)
                if ( node_id(gson) == n_array ) then
                  call announceError ( arrayOfArrays, field )
                  sparseQuantities(k-1) = -999
                else
                  sparseQuantities(k-1) = decoration(decoration(gson))
                end if
              end do
            case ( f_state )
              state => vectorDatabase(decoration(decoration(subtree(2,son))))
            case ( f_stateMax )
              stateMax => vectorDatabase(decoration(decoration(subtree(2,son))))
              do k = 1, size(stateMax%quantities)
                stateMax%quantities(k)%values = -huge(0.0_rv)
              end do
            case ( f_stateMin )
              stateMin => vectorDatabase(decoration(decoration(subtree(2,son))))
              do k = 1, size(stateMin%quantities)
                stateMin%quantities(k)%values = huge(0.0_rv)
              end do
            case ( f_switches )
              call get_string ( sub_rosa(subtree(2,son)), switches(switchLenCur+1:), strip=.true. )
              switchLenCur = len_trim(switches) + 1
              switches(switchLenCur:switchLenCur) = ','
            case ( f_toggles )
              call get_string ( sub_rosa(subtree(2,son)), switches(switchLenCur+1:), strip=.true. )
              call set_toggles ( switches(switchLenCur+1:) )
              switches(switchLenCur+1:) = ''
            case ( f_aprioriScale, f_fuzz, f_lambda, f_lambdamin, f_maxJ, &
              &    f_muMin, f_precisionFactor, f_toleranceA, f_toleranceF, &
              &    f_toleranceR )
              call expr ( subtree(2,son), units, value )
              select case ( field )
              case ( f_aprioriScale )
                aprioriScale = value(1)
              case ( f_fuzz )
                fuzz = value(1)
              case ( f_lambda )
                initLambda = value(1)
              case ( f_lambdamin )
                lambdaMin = value(1)
              case ( f_maxJ )
                maxJacobians = nint(value(1))
              case ( f_muMin )
                muMin = value(1)
              case ( f_precisionFactor )
                precisionFactor = value(1)
              case ( f_toleranceA )
                toleranceA = value(1)
              case ( f_toleranceF )
                toleranceF = value(1)
              case ( f_toleranceR )
                toleranceR = value(1)
              end select
            case ( f_vRegOrders )
              vRegOrders = son
              tikhonovNeeded = .true.
            case ( f_vRegQuants )
              vRegQuants = son
            case ( f_vRegWeights )
              vRegWeights = son
            case ( f_vRegWeightVec )
              vRegWeightVec => vectorDatabase(decoration(decoration(subtree(2,son))))
            case default
              ! Shouldn't get here if the type checker worked
            end select
          end do ! ! fields of the "retrieve" specification

          if ( L2Options%SkipRetrieval ) then
            if ( got(f_state) ) then
              call ClearVector( state, real(statefilledbyskippedretrievals, rv) )
              call output ( 'Clearing retrieval state vector name: ' )
              call display_string ( state%name )
              call output ( ', template name: ' )
              call display_string ( state%template%name, advance='yes' )
            end if
            if ( got(f_outputSD) ) then
              call ClearVector( outputSD, real(statefilledbyskippedretrievals, rv) )
              call output ( 'Clearing retrieval precision vector name: ' )
              call display_string ( state%name )
              call output ( ', template name: ' )
              call display_string ( state%template%name, advance='yes' )
            end if
            call output ( ' (skipping retrieval) ', advance='yes' )
            levels = saveLevels
            toggle = saveToggle
            call trace_end ( "Retrieve.retrieve", cond=toggle(gen) )
            cycle
          end if

          if ( got(f_apriori) .neqv. got(f_covariance) ) &
            & call announceError ( bothOrNeither, f_apriori, f_covariance )
          if ( diagonal .and. .not. got(f_covariance) ) &
            & call announceError ( diagNoCov )
          if ( got(f_regApriori) .and. .not. got(f_apriori) ) &
            & call announceError ( ifAThenB, f_regApriori, f_apriori )
          if ( got(f_hRegOrders) .neqv. &
            & (got(f_hRegWeights) .or. got(f_hRegWeightVec)) ) then
            call announceError ( bothOrNeither, f_hRegOrders, f_hRegWeights )
            call announceError ( bothOrNeither, f_hRegOrders, f_hRegWeightVec )
          end if
          if ( got(f_hRegQuants) .and. .not. got(f_hRegOrders) ) &
            & call announceError ( ifAThenB, f_hRegQuants, f_hRegOrders )
          if ( got(f_vRegOrders) .neqv. &
            & (got(f_vRegWeights) .or. got(f_vRegWeightVec)) ) then
            call announceError ( bothOrNeither, f_vRegOrders, f_vRegWeights )
            call announceError ( bothOrNeither, f_vRegOrders, f_vRegWeightVec )
          end if
          if ( got(f_vRegQuants) .and. .not. got(f_vRegOrders) ) &
            & call announceError ( ifAThenB, f_vRegQuants, f_vRegOrders )
          if ( negateSD .and. .not. tikhonovBefore ) &
            & call announceError ( inconsistent, f_negateSD, f_regAfter )
          if ( negateSD .and. .not. got(f_outputSD) ) &
            & call AnnounceError ( ifAThenB, f_negateSD, f_outputSD )
          if ( ( method == l_newtonian .or. method == l_simple ) .and. &
             & parallelMode .and. .not. got(f_fwdModelExtra) ) &
            & call announceError ( noExtraVec )

          if ( error == 0 ) then

            ! Verify the consistency of various matrices and vectors
            if ( got(f_apriori) ) then
              if ( apriori%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_apriori, f_state )
            end if
            if ( got(f_aprioriFraction) ) then
              if ( aprioriFraction%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_aprioriFraction, f_state )
            end if
            if ( associated(covariance) ) then
              if ( covariance%m%row%vec%template%name /= state%template%name .or. &
                &  covariance%m%col%vec%template%name /= state%template%name ) &
                &  call announceError ( inconsistent, f_covariance, f_state )
            end if
            if ( got(f_highBound) ) then
              if ( highBound%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_highBound, f_state )
            end if
            if ( got(f_lowBound) ) then
              if ( lowBound%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_lowBound, f_state )
            end if
            if ( got(f_measurementSD) ) then
              if ( measurementSD%template%name /= measurements%template%name ) &
                & call announceError ( inconsistent, f_measurementSD, f_measurements )
            end if
            if ( got(f_stateMax) ) then
              if ( stateMax%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_stateMax, f_state )
            end if
            if ( got(f_stateMin) ) then
              if ( stateMin%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_stateMin, f_state )
            end if
          end if

          if ( error == 0 ) then

            if ( switchDetail ( switches, 'rtv' ) > -1 ) call DumpRetrievalConfig

            ! Create the Hessian object
            if ( got(f_hessian) ) then
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Not ready to handle a Hessian field in Retrieve command yet' )
            else
              hessian => myHessian
              hessian = createEmptyHessian ( 0, measurements, state, Potemkin=.true. )
              PotemkinHessian = .true.
            end if

            ! Create the Jacobian matrix
            if ( got(f_jacobian) ) then
              k = decoration(ixJacobian)
              if ( k == 0 ) then
                call createEmptyMatrix ( myJacobian, &
                  & sub_rosa(subtree(1,ixJacobian)), measurements, state )
                k = addToMatrixDatabase( matrixDatabase, myJacobian )
                call decorate ( ixJacobian, k )
!     The following is probably necessary to make final subroutines for
!     RC_Info and Matrix_T work, else the finalizers deallocate targets
!     out from under pointers in the matrix database... but it causes a
!     crash.  I don't know why.
!                 call nullifyMatrix ( myJacobian ) ! so as not to clobber out
                  ! from under matrixDatabase(k) when myJacobian is finalized
              end if
              call getFromMatrixDatabase ( matrixDatabase(k), jacobian )
              if ( jacobian%row%vec%template%name /= measurements%template%name ) &
                & call announceError ( inconsistent, f_jacobian, f_measurements )
              if ( jacobian%col%vec%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_jacobian, f_state )
            else
              jacobian => myJacobian
              call createEmptyMatrix ( jacobian, 0, measurements, state )
            end if

            ! Create the output covariance matrix
            if ( got(f_outputCovariance) ) then
              k = decoration(ixCovariance)
              if ( k == 0 ) then
                call createEmptyMatrix ( myCovariance%m, &
                  & sub_rosa(subtree(1,ixCovariance)), state, state )
                k = addToMatrixDatabase( matrixDatabase, myCovariance )
                call decorate ( ixCovariance, k )
!     The following is probably necessary to make final subroutines for
!     RC_Info and Matrix_T work, else the finalizers deallocate targets
!     out from under pointers in the matrix database... but it causes a
!     crash.  I don't know why.
!                 call nullifyMatrix ( myCovariance%m ) ! so as not to clobber out
                  ! from under matrixDatabase(k) when myCovariance%m is finalized
              end if
              call getFromMatrixDatabase ( matrixDatabase(k), outputCovariance )
              if ( .not. associated(outputCovariance) ) then
                call announceError ( notSPD, f_outputCovariance )
              else
                if ( outputCovariance%m%row%vec%template%name /= state%template%name &
                  & .or. &
                  &  outputCovariance%m%col%vec%template%name /= state%template%name ) &
                  & call announceError ( inconsistent, f_outputCovariance, f_state )
              end if
            else
              outputCovariance => myCovariance
              call createEmptyMatrix ( myCovariance%m, 0, state, state )
            end if

            ! Create the averaging kernel matrix
            if ( got(f_average) ) then
              k = decoration(ixAverage)
              if ( k == 0 ) then
                call createEmptyMatrix ( myAverage, &
                  & sub_rosa(subtree(1,ixAverage)), state, state )
                k = addToMatrixDatabase( matrixDatabase, myAverage )
                call decorate ( ixAverage, k )
!     The following is probably necessary to make final subroutines for
!     RC_Info and Matrix_T work, else the finalizers deallocate targets
!     out from under pointers in the matrix database... but it causes a
!     crash.  I don't know why.
!                 call nullifyMatrix ( myAverage ) ! so as not to clobber out
                  ! from under matrixDatabase(k) when myAverage is finalized
              end if
              call getFromMatrixDatabase ( matrixDatabase(k), outputAverage )
              call display_string ( outputAverage%name, advance='yes' )
              if ( .not. associated(outputAverage) ) then
                call announceError ( notGeneral, f_average )
              else
                if ( outputAverage%row%vec%template%name /= state%template%name &
                  & .or. &
                  &  outputAverage%col%vec%template%name /= state%template%name ) &
                  & call announceError ( inconsistent, f_average, f_state )
              end if
            end if

            ! Create the matrix for adding the Tikhonov regularization to the
            ! normal equations
            if ( tikhonovNeeded ) then
              call createEmptyMatrix ( tikhonov, 0, state, state, text='_Tikhonov' )
            end if

            ! Do the retrieval
            jacobian_Cols = 0
            jacobian_Rows = 0
            if ( got(f_lowBound) ) call getInBounds ( state, lowBound, 'low' )
            if ( got(f_highBound) ) call getInBounds ( state, highBound, 'high' )

            select case (method)
            case( l_lowcloud, l_highcloud)
              ! use this for testing
              if(.not. got(f_maxJ)) maxJacobians = 5
              if(.not. got(f_lambda)) initlambda = 10.
              call CloudRetrieval(Method, ConfigDatabase,configIndices,fwdModelExtra,&
                 & measurements,MeasurementSD, state, OutputSD, Covariance, &
                 & jacobian, chunk,maxJacobians,initlambda)
              call add_to_retrieval_timing( 'low_cloud', t1 )
            case ( l_newtonian, l_simple )
              call newtonSolver
            case default
              call MLSMessage ( MLSMSG_Error, moduleName, &
              & "this retrieval method has not yet been implemented" )
            end select
          else
            call MLSMessage ( MLSMSG_Error, moduleName, &
              & "No retrieval done -- error in configuration" )
          end if

          !??? Make sure the jacobian and outputCovariance get destroyed
          !??? after ?what? happens?  Can we destroy the entire matrix
          !??? database at the end of each chunk?
          if ( .not. got(f_jacobian) ) call destroyMatrix ( jacobian )
          if ( .not. got(f_outputCovariance) ) &
            & call destroyMatrix ( outputCovariance%m )
          if ( got(f_fwdModelOut) ) then
            call copyVector ( fwdModelOut, v(f) )
            call copyVectorMask ( fwdModelOut, measurements )
          end if
          call deallocate_test ( configIndices, "ConfigIndices", moduleName )
          levels = saveLevels
          toggle = saveToggle
          call trace_end ( "Retrieve.retrieve", cond=toggle(gen) )
        case ( s_sids )
          if ( L2Options%SkipRetrieval .and. switchDetail( switches, 'fiw' ) < 0 ) cycle
          call time_now ( t1 )
          call sids ( key, VectorDatabase, MatrixDatabase, HessianDatabase, configDatabase, chunk)
        case ( s_select ) ! ============ Start of select .. case ==========
          ! We'll start seeking a matching case
          call MLSSelect (key)
        case ( s_case ) ! ================ seeking matching case ==========
          ! We'll continue seeking a match unless the case is TRUE
          call MLSCase (key)
        case ( s_endSelect ) ! =========== End of select .. case ==========
          ! We'done with seeking a match
          call MLSEndSelect (key)
        case ( s_Repeat ) ! ============================= Repeat ==========
          ! We'll Repeat the section as long as the Boolean cond'n is TRUE
          RepeatLoop = Repeat(key)
          if ( .not. RepeatLoop ) exit repeat_loop
          call nextRepeat
        case ( s_skip ) ! ================================= Skip ==========
          ! We'll skip the rest of the section if the Boolean cond'n is TRUE
          if ( Skip(key) ) exit repeat_loop
        case ( s_snoop )
          snoopKey = key
          do i_key = 2, nsons(key)
            son = subtree(i_key, key)
            field = get_field_id(son)  ! tree_checker prevents duplicates
            select case ( field )
            case ( f_comment )
              call get_string ( sub_rosa(subtree(2,son)), snoopComment, strip=.true. )
            case ( f_phaseName )
              call get_string ( sub_rosa(subtree(2,son)), phaseName, strip=.true. )
            case ( f_level )
              call expr ( subtree(2,son), units, value )
              snoopLevel = nint(value(1))
            end select
          end do
        case ( s_subset )
          call trace_begin ( me_subset, "Retrieve.subset", root, &
            & cond=toggle(gen) .and. levels(gen) > 0 )
          call SetupSubset ( key, vectorDatabase )
          call trace_end ( cond=toggle(gen) .and. levels(gen) > 0 )
        case ( s_time )
          if ( timing ) then
            call sayTime
          else
            call time_now ( t1 )
            timing = .true.
          end if
        case ( s_updateMask )
          call trace_begin ( me_updateMask, "Retrieve.UpdateMask", root, &
            & cond=toggle(gen) .and. levels(gen) > 0 )
          call UpdateMask ( key, vectorDatabase )
          call trace_end ( cond=toggle(gen) .and. levels(gen) > 0 )
        end select

        do j = firstVec, lastVec
          call destroyVectorInfo ( v(j) )
        end do

      end do ! sons
      if ( .not. repeatLoop ) exit ! Otherwise, we will repeat the section
    end do repeat_loop ! RepeatLoop
    
    ! Housekeeping
    ! if ( .not. got(f_jacobian) ) call DestroyMatrix( Jacobian )
    if ( PotemkinHessian ) call DestroyHessian( Hessian )

    if ( specialDumpFile /= ' ' ) call revertOutput

    switches(switchLen+1:) = '' ! Clobber switches from retrieve command
    call trace_end ( "Retrieve", cond=toggle(gen) )
    if ( timing ) call sayTime

  contains

    ! --------------------------------------------  AnnounceError  -----
    subroutine AnnounceError ( Code, FieldIndex, AnotherFieldIndex, String )

      use Intrinsic, only: Field_Indices
      use Lexer_Core, only: Print_Source
      use String_Table, only: Display_String

      integer, intent(in) :: Code       ! Index of error message
      integer, intent(in), optional :: FieldIndex, AnotherFieldIndex ! f_...
      character(len=*), optional :: String

      error = max(error,1)
      call output ( '***** At ' )
      call print_source ( where(son) )
      call output ( ', RetrievalModule complained: ' )
      select case ( code )
      case ( arrayOfArrays )
        call output ( 'Field ' )
        call display_string ( field_indices(fieldIndex) )
        call output ( ' cannot be an array of arrays', advance='yes' )
      case ( bothOrNeither )
        call output ( 'One of ' )
        call display_string ( field_indices(fieldIndex) )
        call output ( ' or ' )
        call display_string ( field_indices(anotherFieldIndex) )
        call output ( ' appears, but the other does not.', advance='yes' )
      case ( diagNoCov )
        call output ( 'If the diagonal field is true, covariance shall appear', &
          & advance='yes' )
      case ( ifAThenB )
        call output ( 'If the ' )
        call display_string ( field_indices(fieldIndex) )
        call output ( ' field appears then the ' )
        call display_string ( field_indices(anotherFieldIndex) )
        call output ( ' field shall also appear.', advance='yes' )
      case ( noExtraVec )
        call output ( 'FwdModelExtra is required for parallel forward models.', &
                    & advance='yes' )
      case ( inconsistent, notGeneral, notSPD )
        if ( present(string) ) call output ( string )
        call output ( 'the field ' )
        call display_string ( field_indices(fieldIndex) )
        select case ( code )
        case ( inconsistent )
          call output ( ' is not consistent with the ' )
          call display_string ( field_indices(anotherFieldIndex ) )
          call output ( ' field.', advance='yes' )
        case ( notGeneral )
          call output ( ' is not a general matrix.', advance='yes' )
        case ( notSPD )
          call output ( ' is not a symmetric positive-definite matrix.', &
            & advance='yes' )
        end select
      end select
    end subroutine AnnounceError

    ! --------------------------------------------  ApplyTikhonov  -----
    subroutine ApplyTikhonov ( After, NormalEquations, AJ, TikhonovRows, &
                             & D_Reg, D_Fnorm )
      !{ Apply Tikhonov regularization.
      !  Tikhonov regularization is of the form ${\bf R x}_{n+1} \simeq
      !  {\bf 0}$ or ${\bf R x}_{n+1} \simeq {\bf a}$, where {\bf a} is
      !  the apriori. So that all of the parts of the problem are solving
      !  for ${\bf\delta x}$, we subtract ${\bf R x}_n$ from both sides
      !  to get ${\bf R \delta x} \simeq -{\bf R x}_n$ or ${\bf R \delta
      !  x} \simeq {\bf R} ( {\bf a - x}_n)$.
      !
      !  If {\tt After} is true, apply column scaling.
      !
      !  If requesting a posteriori covariance, a posteriori standard
      !  deviation, or an averaging kernel, without Tikhonov regularization,
      !  becomes common, this routine should be used to back out its effect
      !  by subtracting from the normal equations.  This would require adding
      !  a flag to the FormNormalEquations routine to subtract instead of add.

      use DNWT_Module, only: NWT_T
      use MatrixModule_1, only: ClearMatrix, ColumnScale, Dump, Dump_Struct, &
        & FormNormalEquations => NormalEquations, GetDiagonal
      use Regularization, only: Regularize
      use VectorsModule, only: OPERATOR(.DOT.), ScaleVector

      logical, intent(in) :: After     ! Allow column scaling
      type(matrix_SPD_T), intent(inout) :: NormalEquations  ! Jacobian**T * Jacobian
      type(Nwt_T), intent(inout) :: AJ ! Stuff for communicating with DNWT
      integer, intent(inout) :: TikhonovRows ! Number of rows added
      logical, intent(in) :: D_Reg     ! Dump regularization
      integer, intent(in) :: D_Fnorm   ! Dump the revised norm of F

      integer :: J                     ! Loop index
      integer :: T
      character(*), parameter :: Which(2) = (/ 'Vertical  ', 'Horizontal' /)

      ! call add_to_retrieval_timing( 'newton_solver', t1 )
      call time_now ( t1 )

      !{ Tikhonov regularization is of the form ${\bf R x}_{n+1} \simeq
      !  {\bf 0}$ or ${\bf R x}_{n+1} \simeq {\bf a}$, where {\bf a} is
      !  the apriori. So that all of the parts of the problem are solving
      !  for ${\bf\delta x}$, we subtract ${\bf R x}_n$ from both sides
      !  to get ${\bf R \delta x} \simeq -{\bf R x}_n$ or ${\bf R \delta
      !  x} \simeq {\bf R} ( {\bf a - x}_n)$.

      do t = 1, 2 ! Vertical, then Horizontal regularization
        if ( t == 1 ) then
          if ( .not. got(f_vRegOrders) ) cycle
          call regularize ( tikhonov, vRegOrders, vRegQuants, vRegWeights, &
            & vRegWeightVec, tikhonovRows, horiz=.false. )
        else
          if ( .not. got(f_hRegOrders) ) cycle
          call regularize ( tikhonov, hRegOrders, hRegQuants, hRegWeights, &
            & hRegWeightVec, tikhonovRows, horiz=.true. )
        end if

        !{ If Tiknonov regularization is ``the second derivative of the
        !  state ought to be like the second derivative of the apriori,''
        !  the RHS is ${\bf W R} ( {\bf x}_a - {\bf x}_n )$, where ${\bf
        !  W}$ is the Tikhonov weight, ${\bf R}$ is the regularization
        !  operator, ${\bf x}_a$ is apriori, and ${\bf x}_n$ is the
        !  current state.  If Tiknonov regularization is ``the second
        !  derivative of the state ought to be zero, the RHS is $-{\bf W
        !  R x}_n$.
        if ( tikhonovApriori ) then
          call multiplyMatrixVectorNoT ( tikhonov, v(reg_RHS), v(reg_X_x) )
        else
          call multiplyMatrixVectorNoT ( tikhonov, v(x), v(reg_X_x) )
          call scaleVector ( v(reg_X_x), -1.0_r8 )   ! -R x_n
        end if

        if ( after .and. columnScaling /= l_none ) then ! Compute $\Sigma$
          ! Get the column scale vector.
          select case ( columnScaling )
          case ( l_apriori ) ! v(columnScaleVector) := apriori
            call copyVector ( v(columnScaleVector), apriori )
          case ( l_covariance )
            !??? Can't get here until allowed by init_tables
          case ( l_norm ) ! v(columnScaleVector) := diagonal of normal
                          !                         equations = column norms^2
            call getDiagonal ( normalEquations%m, v(columnScaleVector) )
          end select
          do j = 1, v(columnScaleVector)%template%noQuantities
            where ( v(columnScaleVector)%quantities(j)%values <= 0.0 )
              v(columnScaleVector)%quantities(j)%values = 0.0
            elsewhere
              v(columnScaleVector)%quantities(j)%values = &
                & sqrt( v(columnScaleVector)%quantities(j)%values )
            end where
          end do
          call columnScale ( tikhonov, v(columnScaleVector) )
        end if

          if ( d_reg ) then
            if ( t == 1 ) then
              call output ( 'Dumping Tikhonov for vertical regularization', &
                & advance='yes' )
            else
              call output ( 'Dumping Tikhonov for horizontal regularization', &
                & advance='yes' )
            end if
            call dump_struct ( tikhonov, 'Tikhonov' )
            call dump ( tikhonov, name='Tikhonov', details=2 )
          end if

          call add_to_retrieval_timing( 'tikh_reg', t1 )
        call formNormalEquations ( tikhonov, normalEquations, &
          & v(reg_X_x), v(aTb), update=update, useMask=.false. )
        update = .true.
        call clearMatrix ( tikhonov )           ! free the space
        ! aj%fnorm is still the square of the norm of f
        aj%fnorm = aj%fnorm + ( v(reg_X_x) .dot. v(reg_X_x) )
        if ( d_fnorm > -1 ) then
          call output ( trim(which(t)) // &
            & ' Regularization contribution to | F |^2 = ' )
          call output ( v(reg_X_x) .dot. v(reg_X_x), advance='yes' )
        end if
        ! call destroyVectorValue ( v(reg_X_x) )  ! free the space
        ! Don't destroy reg_X_x unless we move the 'clone' for it
        ! inside the loop.  Also, if we destroy it, we can't snoop it.
      end do ! t

    end subroutine ApplyTikhonov

    ! ------------------------------------------------  BoundMove  -----
    subroutine BoundMove ( Mu, Bound, X, Dx, Which, muMin )
      ! Compute a scalar multiple Mu such that X + Mu*DX does not go
      ! beyond Bound.  "Which" specifies either "low" or "high"

      !{ Let $D$ be $|\delta \mathbf{x}|$, where $\delta \mathbf{x}$ is
      ! given by Dx, let $b_i$ and $x_i$ be components of Bound and X. Let
      ! $d_i$ be such that $x_i + \frac{|d_i|}D \delta x_i$ is not beyond
      ! a bound.  That is, $d_i$ is such that $|d_i| \cos \theta_i = x_i -
      ! b_i$, where $\theta_i$ is the angle between $\delta \mathbf{x}$
      ! and the normal to the $i^{th}$ constraint surface.  Since the
      ! constraints are bounds, we have $\cos \theta_i = \frac{\delta
      ! x_i}D$.  $\mu$ is the smallest value of $\frac{|d_i|}D =
      ! \left|\frac{x_i-b_i} {\delta x_i}\right|$.  If we check the
      ! components one at a time, each one using the most recently
      ! computed $\mu$, we don't need a divide for each check, and we
      ! don't need a {\tt min} operation. However, if we are already at
      ! the bounds, and the next step wants to keep going beyond the
      ! bounds, then $\mu$ will be really small.  In this case $\mu <
      ! \mu_{\text{min}}$ we revert to a straight element-by-element
      ! modification of $\delta x_i$.

      real(rv), intent(inout) :: Mu
      type(vector_T), intent(inout) :: Bound, X, Dx
      character(len=*), intent(in) :: Which
      real(rv), intent(in) :: MuMin

      integer :: IQ, IVX, IVY           ! Subscripts used during MU computation
      real(rv) :: MuOrig                ! The original value of MU


!     This is a set of debugging output it is helpful to sprinkle in when
!     tracking down problems.
!       call Output ( 'In Bound move (' // which // ')', advance='yes' )
!       call output ( ' x = ' )
!       call output ( x%quantities(iq)%values(ivx,ivy) )
!       call output ( ' dx = ' )
!       call output ( dx%quantities(iq)%values(ivx,ivy) )
!       call output ( ' bound = ' )
!       call output ( bound%quantities(iq)%values(ivx,ivy) )
!       call output ( ' mu = ' )
!       call output ( mu, advance='yes' )

      muOrig = mu
      if ( which == 'low' ) then
        do iq = 1, size(x%quantities)
          if ( associated(x%quantities(iq)%mask) ) then
            do ivy = 1, size(x%quantities(iq)%values,2)
              do ivx = 1, size(x%quantities(iq)%values,1)
                if ( iand(ichar(x%quantities(iq)%mask(ivx,ivy)),m_linalg) == 0 ) then
                  if ( x%quantities(iq)%values(ivx,ivy) + &
                    &  mu * dx%quantities(iq)%values(ivx,ivy) < &
                    &  bound%quantities(iq)%values(ivx,ivy) ) &
                      & mu = abs( ( bound%quantities(iq)%values(ivx,ivy) - &
                      &             x%quantities(iq)%values(ivx,ivy) ) &
                      &           / dx%quantities(iq)%values(ivx,ivy) )
                end if
              end do
            end do
          else
            do ivy = 1, size(x%quantities(iq)%values,2)
              do ivx = 1, size(x%quantities(iq)%values,1)
                if ( x%quantities(iq)%values(ivx,ivy) + &
                  &  mu * dx%quantities(iq)%values(ivx,ivy) < &
                  &  bound%quantities(iq)%values(ivx,ivy) ) &
                    & mu = abs( ( bound%quantities(iq)%values(ivx,ivy) - &
                    &             x%quantities(iq)%values(ivx,ivy) ) &
                    &           / dx%quantities(iq)%values(ivx,ivy) )
              end do
            end do
          end if
        end do
      else if ( which == 'high' ) then
        do iq = 1, size(x%quantities)
          if ( associated(x%quantities(iq)%mask) ) then
            do ivy = 1, size(x%quantities(iq)%values,2)
              do ivx = 1, size(x%quantities(iq)%values,1)
                if ( iand(ichar(x%quantities(iq)%mask(ivx,ivy)),m_linalg) == 0 ) then
                  if ( x%quantities(iq)%values(ivx,ivy) + &
                    &  mu * dx%quantities(iq)%values(ivx,ivy) > &
                    &  bound%quantities(iq)%values(ivx,ivy) ) &
                      & mu = abs( ( bound%quantities(iq)%values(ivx,ivy) - &
                      &             x%quantities(iq)%values(ivx,ivy) ) &
                      &           / dx%quantities(iq)%values(ivx,ivy) )
                end if
              end do
            end do
          else
            do ivy = 1, size(x%quantities(iq)%values,2)
              do ivx = 1, size(x%quantities(iq)%values,1)
                if ( x%quantities(iq)%values(ivx,ivy) + &
                  &  mu * dx%quantities(iq)%values(ivx,ivy) > &
                  &  bound%quantities(iq)%values(ivx,ivy) ) &
                    & mu = abs( ( bound%quantities(iq)%values(ivx,ivy) - &
                    &             x%quantities(iq)%values(ivx,ivy) ) &
                    &           / dx%quantities(iq)%values(ivx,ivy) )
              end do
            end do
          end if
        end do
      else
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Come on! In BoundMove, it has to be a low bound or a high bound!' )
      end if

      ! Now if mu has gotten really small, we'll change it back to one,
      ! and do an element-by-element modification of dx
      if ( abs(mu) < muMin ) then
        mu = muOrig
        if ( which == 'low' ) then
          do iq = 1, size(x%quantities)
            if ( associated(x%quantities(iq)%mask) ) then
              do ivy = 1, size(x%quantities(iq)%values,2)
                do ivx = 1, size(x%quantities(iq)%values,1)
                  if ( iand(ichar(x%quantities(iq)%mask(ivx,ivy)),m_linalg) == 0 ) then
                    if ( x%quantities(iq)%values(ivx,ivy) + &
                      &  mu * dx%quantities(iq)%values(ivx,ivy) < &
                      &  bound%quantities(iq)%values(ivx,ivy) ) &
                        &  dx%quantities(iq)%values(ivx,ivy) = &
                        &    ( bound%quantities(iq)%values(ivx,ivy) - &
                        &    x%quantities(iq)%values(ivx,ivy) ) / mu
                  end if
                end do
              end do
            else
              do ivy = 1, size(x%quantities(iq)%values,2)
                do ivx = 1, size(x%quantities(iq)%values,1)
                  if ( x%quantities(iq)%values(ivx,ivy) + &
                    &  mu * dx%quantities(iq)%values(ivx,ivy) < &
                    &  bound%quantities(iq)%values(ivx,ivy) ) &
                      &  dx%quantities(iq)%values(ivx,ivy) = &
                      &    ( bound%quantities(iq)%values(ivx,ivy) - &
                      &    x%quantities(iq)%values(ivx,ivy) ) / mu
                end do
              end do
            end if
          end do
        else if ( which == 'high' ) then
          do iq = 1, size(x%quantities)
            if ( associated(x%quantities(iq)%mask) ) then
              do ivy = 1, size(x%quantities(iq)%values,2)
                do ivx = 1, size(x%quantities(iq)%values,1)
                  if ( iand(ichar(x%quantities(iq)%mask(ivx,ivy)),m_linalg) == 0 ) then
                    if ( x%quantities(iq)%values(ivx,ivy) + &
                      &  mu * dx%quantities(iq)%values(ivx,ivy) > &
                      &  bound%quantities(iq)%values(ivx,ivy) ) &
                        &  dx%quantities(iq)%values(ivx,ivy) = &
                        &    ( bound%quantities(iq)%values(ivx,ivy) - &
                        &      x%quantities(iq)%values(ivx,ivy) ) / mu
                  end if
                end do
              end do
            else
              do ivy = 1, size(x%quantities(iq)%values,2)
                do ivx = 1, size(x%quantities(iq)%values,1)
                  if ( x%quantities(iq)%values(ivx,ivy) + &
                    &  mu * dx%quantities(iq)%values(ivx,ivy) > &
                    &  bound%quantities(iq)%values(ivx,ivy) ) &
                      &  dx%quantities(iq)%values(ivx,ivy) = &
                      &    ( bound%quantities(iq)%values(ivx,ivy) - &
                      &      x%quantities(iq)%values(ivx,ivy) ) / mu
                end do
              end do
            end if
          end do
        end if
      else if ( mu > 1.0 ) then ! in case dx(...) is very small
        mu = 1.0
      end if

      ! Let's keep this check in, just in case muMin has not been set.
      if ( mu < 0.0_rv ) then
        ! If it's negative but tiny then just nudge it.
        if ( mu > - sqrt ( epsilon ( 1.0_rv ) ) ) then
          mu = abs ( mu )
        else
          call output ( 'mu=' )
          call output ( mu, advance='yes' )
          call MLSMessage ( MLSMSG_Error, moduleName, &
            &  'How did mu get to be negative, might the initial guess be out of bounds?' )
        end if
      end if
    end subroutine BoundMove

    ! --------------------------------------  DumpStateQuantities  -----
    subroutine DumpStateQuantities ( DumpQuantitiesNode, Title )
      use Tree, only: Decoration, NSons, Subtree
      use VectorsModule, only: Dump, GetVectorQtyByTemplateIndex, &
        & VectorValue_t

      integer, intent(in) :: DumpQuantitiesNode ! in L2CF tree
      character(len=*), intent(in) :: Title

      integer :: Gson, I
      type(vectorValue_t), pointer :: Qty

      ! Sons of dumpQuantitiesNode are <dot vector quantity> trees.
      do i = 2, nsons(dumpQuantitiesNode)
        gson = subtree(i,dumpQuantitiesNode)
        qty => getVectorQtyByTemplateIndex ( &
          & vectorDatabase(decoration(decoration(subtree(1,gson)))), &
          & decoration(decoration(decoration(subtree(2,gson)))) )
        call dump ( qty, name=title )
      end do

    end subroutine DumpStateQuantities

    ! --------------------------------------  DumpRetrievalConfig  -----
    subroutine DumpRetrievalConfig
      use lexer_core, only: PRINT_SOURCE
      use VectorsModule, only: DumpNiceMaskSummary, M_Tikhonov, M_FullDerivatives
      ! Local variables
      integer :: Q                ! Loop counter
      ! Executable code
      call output ( '---------------------------- Begin retrieval configuration dump', advance='yes' )
      call output ( 'Dumping retrieval configuration for retrieve statement at ' )
      call print_source ( where ( son ) )
      call output ( '', advance='yes' )
      call output ( 'Retrieval state vector name: ' )
      call display_string ( state%name )
      call output ( ', template name: ' )
      call display_string ( state%template%name, advance='yes' )
      ! Now display the list of quantities retrieved
      do q = 1, state%template%noQuantities
        call output ( 'Retrieved quantity ' )
        call output ( q )
        call output ( ' ( ' )
        call display_string ( state%quantities(q)%template%name )
        call output ( ' ) ' )
        call output ( state%quantities(q)%template%noInstances )
        if ( state%quantities(q)%template%noInstances == 1 ) then
          call output ( ' instance, ' )
        else
          call output ( ' instances, ' )
        end if
        call output ( state%quantities(q)%template%noSurfs )
        if ( state%quantities(q)%template%noSurfs == 1 ) then
          call output ( ' surface, ' )
        else
          call output ( ' surfaces, ' )
        end if
        call output ( state%quantities(q)%template%noChans )
        if ( state%quantities(q)%template%noChans == 1 ) then
          call output ( ' channel.', advance='yes' )
        else
          call output ( ' channel.', advance='yes' )
        end if
        ! Call a routine to dump a nice summary of the retrieval range etc.
        call DumpNiceMaskSummary ( state%quantities(q), '  ', &
          & (/ m_linAlg, m_tikhonov, m_fullDerivatives /) )
      end do

      ! Now display the list of measurements used
      call output ( 'Measurements vector name: ' )
      call display_string ( measurements%name )
      call output ( ', template name: ' )
      call display_string ( measurements%template%name, advance='yes' )
      ! Now display the list of quantities retrieved
      do q = 1, measurements%template%noQuantities
        call output ( 'Measurement quantity ' )
        call output ( q )
        call output ( ' ( ' )
        call display_string ( measurements%quantities(q)%template%name )
        call output ( ' ) ' )
        call output ( measurements%quantities(q)%template%noInstances )
        if ( measurements%quantities(q)%template%noInstances == 1 ) then
          call output ( ' instance, ' )
        else
          call output ( ' instances, ' )
        end if
        call output ( measurements%quantities(q)%template%noSurfs )
        if ( measurements%quantities(q)%template%noSurfs == 1 ) then
          call output ( ' surface, ' )
        else
          call output ( ' surfaces, ' )
        end if
        call output ( measurements%quantities(q)%template%noChans )
        if ( measurements%quantities(q)%template%noChans == 1 ) then
          call output ( ' channel.', advance='yes' )
        else
          call output ( ' channel.', advance='yes' )
        end if
        ! Call a routine to dump a nice summary of the retrieval range etc.
        call DumpNiceMaskSummary ( measurements%quantities(q), '  ', (/ m_linalg /) )
      end do


      call output ( '---------------------------- End retrieval configuration dump', advance='yes' )
      stop
    end subroutine DumpRetrievalConfig

    ! ----------------------------------------------  FillDiagQty  -----
    subroutine FillDiagQty ( Diagnostics, QuantityIndex, Value )
      ! Put Value into the first element of the values field of the
      ! quantity of the Diagnostics vector given by QuantityIndex.
      ! We assume the Diagnostics vector is associated, so you better
      ! check before you call!
      type (Vector_T), intent(inout) :: DIAGNOSTICS
      integer, intent(in) :: QuantityIndex
      real(r8), intent(in) :: Value

      integer :: Latest
      integer :: Me = -1                ! String index for trace
      type(vectorValue_T), pointer :: Diag_Qty    ! A quantity in the
                                        ! Diagnostics vector
      call trace_begin ( me, 'Retrieve.FillDiagQty', cond=.false. )
      diag_qty => GetVectorQuantityByType ( diagnostics, &
        & quantityType=QuantityIndex, noError=.true. )
      if ( associated(diag_qty) ) then
        if ( diag_qty%template%noSurfs == 1 ) then
          ! Just one 'surface', or no mask information
          ! write this value out
          diag_qty%values(1,1) = value
        else
          if ( .not. associated ( diag_qty%mask ) ) then
            call CreateMask ( diag_qty )
            diag_qty%mask = char ( m_linalg )
          end if
          ! Multiple surfaces here, find the 'latest'
          latest = count ( iand(ichar(diag_qty%mask(:,1)),m_linalg) == 0 )
          if ( latest == diag_qty%template%noSurfs ) then
            diag_qty%values ( :, 1 ) = &
              & (/ diag_qty%values ( 2:latest, 1 ), value /)
          else
            diag_qty%values ( latest+1, 1 ) = value
            call ClearMask ( diag_qty%mask(:,1), (/ latest+1 /), m_linalg )
          end if
        end if
      end if
      call trace_end ( 'Retrieve.FillDiagQty', cond=.false. )
    end subroutine FillDiagQty

    ! ----------------------------------------------  FillDiagVec  -----
    subroutine FillDiagVec ( Diagnostics, AJ, NumGrad, NumJ, NumNewt, NWT_Flag, &
      & Jacobian_Rows, Jacobian_Cols )
      use DNWT_Module, only: NWT_T
      type(Vector_T), intent(inout) :: Diagnostics
      type(Nwt_T), intent(in) :: AJ
      integer, intent(in), optional :: NumGrad
      integer, intent(in), optional :: NumJ
      integer, intent(in), optional :: NumNewt
      integer, intent(in), optional :: NWT_Flag
      integer, intent(in), optional :: Jacobian_Rows
      integer, intent(in), optional :: Jacobian_Cols

      integer :: Me = -1               ! String index for trace

      call trace_begin ( me, 'Retrieve.FillDiagVec', cond=.false. )
      call fillDiagQty ( diagnostics,  l_dnwt_ajn, aj%ajn )
      call fillDiagQty ( diagnostics,  l_dnwt_axmax, aj%axmax )
      call fillDiagQty ( diagnostics,  l_dnwt_cait, aj%cait )
      call fillDiagQty ( diagnostics,  l_dnwt_chiSqMinNorm, chiSqMinNorm )
      call fillDiagQty ( diagnostics,  l_dnwt_chiSqNorm, chiSqNorm )
      call fillDiagQty ( diagnostics,  l_dnwt_diag, aj%diag )
      call fillDiagQty ( diagnostics,  l_dnwt_dxdx, aj%dxdx )
      call fillDiagQty ( diagnostics,  l_dnwt_dxdxl, aj%dxdxl )
      call fillDiagQty ( diagnostics,  l_dnwt_dxn, aj%dxn )
      call fillDiagQty ( diagnostics,  l_dnwt_dxnl, aj%dxnl )
      call fillDiagQty ( diagnostics,  l_dnwt_fnmin, aj%fnmin )
      call fillDiagQty ( diagnostics,  l_dnwt_fnorm, aj%fnorm )
      call fillDiagQty ( diagnostics,  l_dnwt_gdx, aj%gdx )
      call fillDiagQty ( diagnostics,  l_dnwt_gfac, aj%gfac )
      call fillDiagQty ( diagnostics,  l_dnwt_gradn, aj%gradn )
      call fillDiagQty ( diagnostics,  l_dnwt_sq, aj%sq )
      call fillDiagQty ( diagnostics,  l_dnwt_sqt, aj%sqt )
      if ( present ( numGrad ) ) &
        & call fillDiagQty ( diagnostics,  l_numGrad, real(numGrad, rv) )
      if ( present ( numJ ) ) &
        & call fillDiagQty ( diagnostics,  l_numJ, real(numJ, rv) )
      if ( present ( numNewt ) ) &
        & call fillDiagQty ( diagnostics,  l_numNewt, real(numNewt, rv) )
      if ( present ( nwt_flag ) ) &
        & call fillDiagQty ( diagnostics,  l_dnwt_flag, real(nwt_flag,rv) )
      if ( present ( jacobian_rows ) ) &
        & call fillDiagQty ( diagnostics,  l_jacobian_rows, real(jacobian_rows,rv) )
      if ( present ( jacobian_cols ) ) &
        & call fillDiagQty ( diagnostics,  l_jacobian_cols, real(jacobian_cols,rv) )
      call trace_end ( 'Retrieve.FillDiagVec', cond=.false. )
    end subroutine FillDiagVec

    ! ----------------------------------------------  GetInBounds  -----
    subroutine GetInBounds ( X, Bound, Which )
      ! Put X above/below Bound.  Which specifies low or high bound.
      type(vector_t), intent(inout) :: X
      type(vector_t), intent(in) :: Bound
      character(len=*), intent(in) :: Which

      integer :: IQ, IVX, IVY           ! Subscripts used during bounding

      if ( which == 'low' ) then
        do iq = 1, size(x%quantities)
          if ( associated(x%quantities(iq)%mask) ) then
            do ivy = 1, size(x%quantities(iq)%values,2)
              do ivx = 1, size(x%quantities(iq)%values,1)
                if ( iand(ichar(x%quantities(iq)%mask(ivx,ivy)),m_linalg) /= 0 ) &
                  & x%quantities(iq)%values(ivx,ivy) = &
                    & max(x%quantities(iq)%values(ivx,ivy), &
                    &     bound%quantities(iq)%values(ivx,ivy) )
              end do
            end do
          else
            do ivy = 1, size(x%quantities(iq)%values,2)
              do ivx = 1, size(x%quantities(iq)%values,1)
                x%quantities(iq)%values(ivx,ivy) = &
                  & max(x%quantities(iq)%values(ivx,ivy), &
                  &     bound%quantities(iq)%values(ivx,ivy) )
              end do
            end do
          end if
        end do
      else if ( which == 'high' ) then
        do iq = 1, size(x%quantities)
          if ( associated(x%quantities(iq)%mask) ) then
            do ivy = 1, size(x%quantities(iq)%values,2)
              do ivx = 1, size(x%quantities(iq)%values,1)
                if ( iand(ichar(x%quantities(iq)%mask(ivx,ivy)),m_linalg) /= 0 ) &
                & x%quantities(iq)%values(ivx,ivy) = &
                    & min(x%quantities(iq)%values(ivx,ivy), &
                    &     bound%quantities(iq)%values(ivx,ivy) )
              end do
            end do
          else
            do ivy = 1, size(x%quantities(iq)%values,2)
              do ivx = 1, size(x%quantities(iq)%values,1)
                x%quantities(iq)%values(ivx,ivy) = &
                  & min(x%quantities(iq)%values(ivx,ivy), &
                  &     bound%quantities(iq)%values(ivx,ivy) )
              end do
            end do
          end if
       end do
      else
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Come on! In GetInBounds, it has to be a low bound or a high bound!' )
      end if
    end subroutine GetInBounds

    ! -------------------------------------------------  My_NWTDB  -----
    subroutine My_NWTDB ( AJ, Width, Why )
      use DNWT_Module, only: NWT_T, NWTDB
      use DNWT_Clone, only: ALT_NWTDB
      type (NWT_T), intent(in) :: AJ
      integer, intent(in), optional :: Width
      character(len=*), intent(in), optional :: Why
      if ( method == l_newtonian ) then
        call nwtdb ( aj, width, why )
      else
        call alt_nwtdb ( aj, width, why )
      end if
    end subroutine My_NWTDB

    ! ---------------------------------------------  NewtonSolver  -----
    subroutine NewtonSolver

      use DNWT_MODULE, only: FlagName, NF_Aitken, NF_Best, NF_Biggest_Flag, &
      & NF_DX, NF_DX_Aitken, NF_EvalF, NF_EvalJ, NF_FandJ, NF_Gmove, NF_Lev, &
      & NF_NewX, NF_Smallest_Flag, NF_Solve, NF_Start, NF_TolX, NF_TolF, &
      & NF_TolX_Best, NF_Too_Small, NWT_t, NWT_Options, RK
      use DNWT_Module, only: NWT, NWTA
      use DNWT_Clone, only: ALT_NWT, ALT_NWTA ! SIMPLE
      use Dump_0, only: dump
      use ForwardModelWrappers, only: ForwardModel
      use Forwardmodelintermediate, only: forwardmodelstatus_t
      use L2FWMParallel, only: SetupFWMSlaves, TriggerSlaveRun, &
        & RequestSlavesOutput, ReceiveSlavesOutput
      use MatrixModule_0, only: Dump ! The one from MatrixModule_1 ought to work ???
      use MatrixModule_1, only: AddToMatrix, CholeskyFactor, ClearMatrix, &
        & ColumnScale, CopyMatrixValue, CreateEmptyMatrix, &
        & DestroyMatrix, Dump, Dump_Linf, Dump_Struct, &
        & FormNormalEquations => NormalEquations, &
        & GetDiagonal, InvertCholesky, Matrix_t, &
        & Matrix_Cholesky_t, Matrix_SPD_t, MaxL1, MinDiag, Multiply, &
        & MultiplyMatrix_XY,  MultiplyMatrix_XY_T,  &
        & RowScale, ScaleMatrix, SolveCholesky, UpdateDiagonal
      use ScanModelModule, only: DestroyForwardModelIntermediate
      use Symbol_Table, only: Enter_Terminal
      use Symbol_Types, only: T_Identifier
      use VectorsModule, only: AddToVector, DestroyVectorInfo, &
        & Dump, Multiply, OPERATOR(.dot.), OPERATOR(.mdot.), OPERATOR(-), &
        & ScaleVector, SubtractFromVector

      ! Local Variables
      ! logical :: Abandoned              ! Flag to indicate numerical problems
      real(r8) :: abandoned_value
      type(nwt_T) :: AJ                 ! "About the Jacobian", see NWT.
      type(matrix_SPD_T), target :: APlusRegCOV ! Covariance from a priori and Tikhnov alone
      type(matrix_SPD_T), target :: APlusRegNEQ ! Normal equations from a priori in Tikhnov alone.
                                        ! Only used when computing solution covariance/sd
                                        ! and needing to set values negative, or when
                                        ! computing the apriori fraction.
      logical :: AtBest                 ! Current state is the best one so far.
      type(nwt_T) :: BestAJ             ! AJ at Best Fnorm so far.
      real(r8) :: Cosine                ! Of an angle between two vectors
      ! Dump switches
      logical :: D_ATB    ! 'atb' A^T b -- RHS of system
      logical :: D_Col    ! 'col' Column scale vector
      logical :: D_Cov    ! 'cov' Solution covariance
      logical :: D_Diag   ! 'diag' Diagonal of normal equations factor
      logical :: D_Drmc   ! 'drmc' Dump Retriever Matrices Clean
      logical :: D_Dvec   ! 'dvec' DX vector
      integer :: D_DXn    ! 'dxn' DX vector norm if 0, quantity norms if > 0
      logical :: D_Fac_F  ! 'FAC' Full normal equations factor (if you dare)
      logical :: D_Fac_N  ! 'fac' L_Infty norms of blocks of normal equations factor
      integer :: D_Fnmin  ! 'fnmin' terms
      integer :: D_Fnorm  ! 'fnorm' Contributions to | F |
      logical :: D_Gvec   ! 'gvec' Gradient vector
      integer :: D_Jac_F  ! 'JAC' Full Jacobian (if you dare)
      logical :: D_Jac_N  ! 'jac' L_Infty norms of Jacobian blocks
      integer :: D_KTK    ! 'kTk' kTk, which might be normalEquations
      logical :: D_Mas    ! 'mas' Announce master triggering slaves
      logical :: D_Mst    ! 'mst' Block causing factoring abnormal status
      integer :: D_Ndb    ! 'ndb[n]' Newton method debugging output level
      integer :: D_Neq    ! 'neq' > 0 Full normal equations (if you dare)
                          !       = 0 L_Infty norms of Normal equation blocks
      logical :: D_Nin    ! 'nin' Newton method's internal output
      logical :: D_Nwt    ! 'nwt' Commands from Newton method
      logical :: D_Reg    ! 'reg' Tikhonov regularization
      integer :: D_Resid  ! 'dres' Dump residuals with details = d_resid
      logical :: D_Sca    ! 'sca' Newton method's scalars
      logical :: D_Spa    ! 'spa' Sparsity structure of matrices
      logical :: D_Strb   ! 'strb' State vector iff we get into trouble
      logical :: D_Svec   ! 'svec' Final state vector
      logical :: D_Vir    ! 'vir' Virgin matrix, before KTK
      logical :: D_Xvec   ! 'xvec' Current state vector

      real(rk) :: DOF                   ! Degrees of freedom, rows - columns
      type(matrix_Cholesky_T) :: Factored ! Cholesky-factored normal equations
      type (ForwardModelStatus_T) :: FmStat ! Status for forward model
      logical :: FoundBetterState       ! Set if we ever got an nf_best
      type(vector_T) :: FuzzState       ! Random numbers to fuzz the state
      integer :: J, K                   ! Loop inductors and subscripts
      type(matrix_SPD_T), pointer :: KTK ! The Jacobian-derived part of the
                                        ! normal equations.  NormalEquations
                                        ! if no averaging kernel is requested,
                                        ! else kTkSep.
      type(matrix_SPD_T), target :: KTKSep ! The Jacobian-derived part of the
                                        ! normal equations if an averaging kernel
                                        ! is requested.
      type(matrix_T), target :: KTKStar ! The kTkStar contrbution to the averaging
      real(rk) :: Lambda                ! Levenberg-Marquardt stabilization
                                        ! last applied to normal equations
      integer :: LATESTMAFSTARTED       ! For FWMParallel stuff
      real(r8) :: LoopCounter            ! Abandon after 50 * maxJ loop iterations
      integer, dimension(2) :: MATRIXSTATUS ! Flag from matrix calculations
      integer :: Me = -1                ! String index for trace
      real(rv) :: MU                    ! Move Length = scale for DX
      integer, parameter :: NF_GetJ = NF_Smallest_Flag - 1 ! Take an extra loop
                                        ! to get J.
      integer, parameter :: NF_Too_Many = NF_Biggest_Flag + 1 ! Max iterations
      type(matrix_SPD_T), target :: NormalEquations  ! Jacobian**T * Jacobian
      integer :: NumGrad                ! Number of gradient moves
      integer :: NumJ                   ! Number of Jacobian evaluations
      integer :: NumNewt                ! Number of Newton moves
      integer :: NWT_Flag               ! Signal from NWT, q.v., indicating
                                        ! the action to take.
      type(nwt_options) :: NWT_Opt      ! Options for NWT, q.v.
      integer :: PreserveMatrixName     ! Temporary name store
      integer :: Prev_NWT_Flag          ! Previous value of NWT_Flag
      type(vector_T) :: Q               ! Used to calculate Marquardt parameter
      integer :: QTY                    ! Loop counter
      integer :: RowBlock               ! Which block of rows is the forward
                                        ! model filling?
      integer, parameter :: SnoopLevels(NF_DX_AITKEN:NF_FANDJ) = (/ &
      ! dx_aitken dx aitken best gmove newx lev solve evalj evalf
        &      3, 2,     3,   2,    2,   1,  2,   2,    2,    2,  &
      ! start tolx tolx_best tolf too_small fandj
        &  9,   2,        2,   2,        3,    9  /)
      integer :: T                      ! Which Tikhonov: 1 -> V, 2 -> H
      ! real :: T1
      type(matrix_T) :: Temp            ! Because we can't do X := X * Y
      type(matrix_T) :: TempU           ! U**(-1)
      type(matrix_cholesky_T) :: TempC  ! For negateSD caseXoXo
      character(len=10) :: TheFlagName  ! Name of NWTA's flag argument
      integer :: TikhonovRows           ! How many rows of Tiknonov regularization?

      call trace_begin ( me, 'Retrieve.NewtonSolver', cond=.false. )
      ! Set flags from switches
      d_atb = switchDetail ( switches, 'atb' ) > -1
      d_col = switchDetail(switches,'col') > -1
      d_cov = switchDetail(switches,'cov') > -1
      d_diag = switchDetail(switches,'diag') > -1
      d_drmc = switchDetail(switches,'drmc') > -1
      d_dvec = switchDetail(switches,'dvec') > -1
      d_dxn = switchDetail(switches,'dxn')
      d_fac_f = switchDetail(switches,'FAC') > -1
      d_fac_n = switchDetail(switches,'fac') > -1
      d_fnmin = switchDetail ( switches, 'fnmin' )
      d_fnorm = switchDetail ( switches, 'fnorm' )
      d_gvec = switchDetail(switches,'gvec') > -1
      d_jac_f = switchDetail(switches,'JAC')
      d_jac_n = switchDetail(switches,'jac') > -1
      d_kTk = switchDetail ( switches, 'kTk' )
      d_mas = switchDetail ( switches, 'mas' ) > -1
      d_mst = switchDetail(switches,'mst') > -1
      d_ndb = switchDetail(switches,'ndb')
      d_neq = switchDetail(switches,'neq')
      d_nin = switchDetail(switches,'nin') > -1
      d_nwt = switchDetail(switches,'nwt') > -1
      d_reg = switchDetail(switches,'reg') > -1
      d_resid = switchDetail(switches,'dres')
      d_sca = switchDetail(switches,'sca') > -1
      d_spa = switchDetail(switches,'spa') > -1
      d_strb = switchDetail(switches,'strb') > -1
      d_svec = switchDetail(switches,'svec') > -1
      d_vir = switchDetail(switches,'vir') > -1
      d_xvec = switchDetail(switches,'xvec') > -1

      call time_now ( t1 )
      call allocate_test ( fmStat%rows, jacobian%row%nb, 'fmStat%rows', &
        & ModuleName )
      ! Launch fwmParallel slaves
      if ( parallelMode ) then
        if ( .not. got(f_fwdModelExtra) ) call announceError ( noExtraVec )
        call SetupFWMSlaves ( configDatabase(configIndices), &
        & state, fwdModelExtra, FwdModelOut, jacobian )
      end if
      foundBetterState = ( maxJacobians == 0 )
      chunk%abandoned = .false.
      ! Set options for NWT
      nwt_opt = nwt_options ( relsf=toleranceF, tolxa=toleranceA, &
                            & tolxr=toleranceR, spstrt=initLambda, &
                            & spmini=lambdaMin )
      if ( method == l_newtonian ) then
        call nwt ( nwt_flag, aj, nwt_opt )
      else
        call alt_nwt ( nwt_flag, aj, nwt_opt )
      end if
      ! Create the matrix for the Cholesky factor of the normal equations
      call createEmptyMatrix ( factored%m, &
        & enter_terminal('_factored', t_identifier), &
        & state, state )
      ! Create the normal equations matrix
      call createEmptyMatrix ( normalEquations%m, &
        & enter_terminal ('_normalEquations', t_identifier), state, state )
      ! Create a separate matrix for J^T J in case averaging kernel requested
      call createEmptyMatrix ( kTkSep%m, &
        & enter_terminal ('_kTkSep', t_identifier), state, state )
      ! Create another separate one for J^T(J unmasked) in case 'extended'
      ! averaging kernel required
      call createEmptyMatrix ( kTkStar, &
        & enter_terminal ('_kTkStar', t_identifier), state, state )
      ! Create the vectors we need.
      call copyVector ( v(x), state, vectorNameText='_x', clone=.true. ) ! x = state
      call cloneVector ( v(aTb), v(x), vectorNameText='_ATb' )
      call cloneVector ( v(bestGradient), v(x), vectorNameText='_bestGradient' )
      call cloneVector ( v(bestX), v(x), vectorNameText='_bestX' )
      call cloneVector ( v(candidateDX), v(x), vectorNameText='_candidateDX' )
      call cloneVector ( v(covarianceDiag), v(x), vectorNameText='_covarianceDiag' )
      call cloneVector ( v(dx), v(x), vectorNameText='_DX' )
      call cloneVector ( v(dxUnScaled), v(x), vectorNameText='_DxUnscaled' )
      call cloneVector ( v(f_rowScaled), measurements, vectorNameText='_f_rowScaled' )
      call copyVectorMask ( v(f_rowScaled), measurements )
      call cloneVector ( v(gradient), v(x), vectorNameText='_gradient' )
      call cloneVector ( q, v(x), vectorNameText='Q' )
      call cloneVector ( v(reg_X_x), state, vectorNameText='_reg_X_x' )
      if ( got(f_measurementSD) ) then
        call cloneVector ( v(weight), measurementSD, vectorNameText='_weight' )
        do j = 1, measurementSD%template%noQuantities
          where ( measurementSD%quantities(j)%values <= 0.0 )
            v(weight)%quantities(j)%values = 1.0
          elsewhere
            v(weight)%quantities(j)%values = 1.0 / &
              & measurementSD%quantities(j)%values
          end where
        end do
      end if
      if ( columnScaling /= l_none ) &
        call cloneVector ( v(columnScaleVector), v(x), vectorNameText='_ColumnScale' )
      if ( got(f_fuzz) ) then
        ! Add some fuzz to the state vector (for testing purposes):
        call cloneVector ( fuzzState, v(x) )
        do j = 1, v(x)%template%noQuantities
          call random_number(fuzzState%quantities(j)%values)
          v(x)%quantities(j)%values = v(x)%quantities(j)%values * &
            & ( 1.0_r8 + fuzz * ( fuzzState%quantities(j)%values - 0.5 ) )
        end do
      end if
        if ( d_xvec ) call dump ( v(x), name='Original X' )
        if ( got(f_dumpQuantities) ) &
          & call DumpStateQuantities ( dumpQuantitiesNode, 'Original X' )
      numGrad = 0
      numJ = 0
      numNewt = 0
      aj%axmax = 0.0
        call time_now ( t0 ) ! time base for Newton iteration
      do k = 1, size(v(x)%quantities)
        aj%axmax = max(aj%axmax, maxval(abs(v(x)%quantities(k)%values)))
      end do

        if ( d_sca ) then
          if ( got(f_apriori) ) then
            call output ( ' apriori scale = ' )
            call output ( aprioriScale )
          end if
          if ( got(f_fuzz) ) then
            call output ( ' fuzz = ' )
            call output ( fuzz )
          end if
          call output ( ' initLambda = ' )
          call output ( initLambda, advance='yes' )
        end if
        call add_to_retrieval_timing( 'newton_solver', t1 )

      call copyVector ( v(bestX), v(x) ) ! bestX = x to start things off
      prev_nwt_flag = huge(0)
      loopCounter = 0
      atBest = .false.
NEWT: do ! Newton iteration
        loopCounter = loopCounter + 1
        if ( loopCounter > max(50, 50 * maxJacobians) ) then
          chunk%abandoned = .true.
          call writeIntsToChars( L2Options%CurrentChunkNumber, mesgChunkNo )
          mesg = '(' // trim(L2Options%CurrentPhaseName) // ')' // &
            & ' (' // trim(mesgChunkNo) // ') ' // &
            & 'Retrieval abandoned because DNWT appears to be looping.'
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            &  trim(mesg) )
          exit NEWT
        end if
        if ( nwt_flag == nf_getJ ) then
          if ( got(f_diagnostics) ) call FillDiagVec ( diagnostics, aj, &
            & numGrad=numGrad, numJ=numJ, numNewt=numNewt, nwt_flag=nwt_flag, &
            & jacobian_rows=jacobian_rows, jacobian_cols=jacobian_cols )
        else ! not taking a special iteration to get J
            if ( d_nin )aj%o%k1it = 1 ! Turn on NWTA's internal output
          if ( method == l_newtonian ) then
            call nwta ( nwt_flag, aj )
          else
            call alt_nwta ( nwt_flag, aj )
          end if
        end if
          if ( d_nwt ) then
            call FlagName ( nwt_flag, theFlagName )
            if ( nwt_flag == nf_getJ ) theFlagName = 'GETJ'
            call output ( 'Newton method flag = ' )
            call output ( trim(theFlagName) )
            call output ( numJ, before=', numJ = ' )
            call time_now ( t3 )
            call output ( t3-t0, advance='yes', before=' at ', after=' seconds' )
          end if
          if ( nwt_flag == nf_evalj .and. prev_nwt_flag == nf_evalf ) then
            prev_nwt_flag = nf_evalj
            cycle
          end if
        select case ( nwt_flag )
        ! The EVALF case is now subsumed into the EVALJ case, so that FNORM
        ! is consistent between the two.  Otherwise, we would need to do all
        ! of the Tikhonov computations here, too.  WVS 2002/09/13.
        case ( nf_evalf, nf_evalj, nf_getJ ) ! EVALF, EVALJ, GETJ  .....
        !{IF ( too many Jacobian values ) EXIT \\
        ! Compute the Jacobian matrix $\bf K$ if you didn't do it when NFLAG
        ! was NF\_EVALF:\\
        ! ${\bf K}_{k,l} = \frac{\partial {\bf f}_k}{\partial {\bf x}_l},
        ! \, k = 1 .. \text{NF},\, l = 1 .. \text{NX}$
        !
        ! Actually, the matrix for the least-squares problem has four parts:
        !  \begin{xalignat*}{2}
        !  {\bf K \delta x} & \simeq {\bf -m}  && \text{The Jacobian} \\
        !  {\bf F x_{n+1}}  & \simeq {\bf F a} && \text{The apriori} \\
        !  {\bf R x_{n+1}}  & \simeq {\bf 0}   &&
        !                   \text{Tikhonov regularization} \\
        !  \lambda {\bf I \delta x} & \simeq {\bf 0} &&
        !                   \text{Levenberg-Marquardt stabilization}
        !  \end{xalignat*}
        !%
        ! {\bf OR}, written so that all equations are solving for ${\bf
        ! \delta x}$:
        !%
        ! \begin{equation*}
        ! {\bf J \delta x} =
        ! \begin{array}{ll}
        !  \left [
        !  \begin{array}{l}
        !  {\bf K} \\
        !  {\bf F} \\
        !  {\bf R} \\
        !  \lambda {\bf I}
        !  \end{array} \right ] {\bf \delta x}
        !  \simeq {\bf -f} =
        !  \left [
        !  \begin{array}{l}
        !   {\bf -m} \\
        !   {\bf F} ( {\bf a} - {\bf x}_n) \\
        !   -{\bf R x}_n \\
        !   {\bf 0}
        !  \end{array}
        !  \right ]
        ! &
        !  \begin{array}{l}
        !   \text{The Jacobian} \\
        !   \text{The apriori} \\
        !   \text{Tikhonov regularization} \\
        !   \text{Levenberg-Marquardt stabilization}
        !  \end{array}
        ! \end{array}
        ! \end{equation*}
        !%
        ! Triangularize ${\bf J}$, and compute the (negative of the) gradient =
        ! $-{\bf J^T f}$.  This is the RHS of the normal equations ${\bf J^T J
        ! \delta \hat x} = -{\bf J^T f}$ where ${\bf \delta \hat x}$ is a
        ! ``Candidate DX'' that might not actually get used.
        ! Set \begin{description}
        !   \item[AJ\%DIAG] = element on diagonal with smallest absolute
        !           value, after triangularization,
        !   \item[AJ\%AJN] = maximum L1 norm of column in upper triangle
        !           after triangularization,
        !   \item[AJ\%FNMIN] = L2 norm of residual =
        !           $||{\bf f + J \delta \hat x}||_2$,
        !   \item[AJ\%GRADN] = L2 norm of Gradient = $|| {\bf J^T f}||_2$.
        !   \end{description}
          numJ = numJ + 1
            if ( d_xvec ) call dump ( v(x), details=2, name='State' )
            if ( got(f_dumpQuantities) ) &
              & call DumpStateQuantities ( dumpQuantitiesNode, 'State' )
          if ( numJ > maxJacobians .and. nwt_flag /= nf_getJ ) then
              if ( d_nwt ) then
                call output ( numJ, before= &
                  & 'Newton iteration terminated because Jacobian evaluations (' )
                call output ( maxJacobians, before=') > maxJacobians (', &
                  & after=')', advance='yes' )
                call time_now ( t3 )
                call output ( t3-t0, before=' at ', after=' seconds', advance='yes' )
              end if
            ! Decide whether we need a special iteration just to get a new
            ! Jacobian.
            if ( foundBetterState .and. .not. atBest ) then
              ! Restore BestX, run the forward model one more time to get a new
              ! Jacobian, and form normal equations -- the last two so that the
              ! a posteriori covariance is consistent with BestX.
              aj = bestAJ
              call copyVector ( v(x), v(bestX) ) ! x = bestX
              nwt_flag = nf_getJ
              cycle NEWT
            end if
            if ( ( got(f_outputCovariance) .or. got(f_outputSD) .or. &
              &    got(f_average) ) .and. tikhonovNeeded .and. covSansReg ) then
              ! Get a fresh Jacobian, uncontaminated by Tikhonov regularization,
              ! to compute a posteriori covariance, standard deviation, or an
              ! averaging kernel.  This is hopefully an unusual request.  If it
              ! becomes usual, this should be done by calculating the
              ! Tikhonov regularization matrix, multiplying it (on the left) by
              ! its transpose, and subtracting the result from the normal
              ! equations, rather than by getting a new Jacobian, adding the
              ! a priori covariance, and forming normal equations.  Care will
              ! be needed to handle the cases of column scaling before and after
              ! applying Tikhonov regularization correctly.
              nwt_flag = nf_getJ
              cycle NEWT
            end if
            exit Newt
          end if

          lambda = 0.0
          update = got(f_apriori)
          if ( update ) then ! start normal equations with apriori
            ! Destroy (i.e. clean up) the previous contents of
            ! AprioriMinusX (if any), so as not to have a memory
            ! leak.  Then make it look like apriori.
!           v(aprioriMinusX) = apriori - v(x) ! leaks memory, so do:
            call copyVector ( v(aprioriMinusX), apriori, clone=.true., &
              & vectorNameText='_aprioriMinusX' ) ! a-x := a
            call subtractFromVector ( v(aprioriMinusX), v(x) ) ! a-x := a - x
            if ( tikhonovApriori ) &
              & call copyVector ( v(reg_RHS), v(aprioriMinusX), clone=.true., &
              & vectorNameText='_regRHS' )
            if ( got(f_aprioriScale) ) &
              & call scaleVector ( v(aprioriMinusX), aprioriScale )
            !{Let the covariance of the apriori be $\mathbf{S_a}$, let
            ! $\mathbf{C = S_a^{-1}}$, and let $\mathbf{F^T F = C}$. In
            ! the least-squares problem we have extra rows of the form
            ! $\mathbf{F \delta x = F ( a - x_n )}$ where $\mathbf{a}$
            ! is the apriori state, and $\mathbf{x_n}$ is the state as
            ! of the previous iteration.  The initial bit of the
            ! right-hand side of the normal equations is $\mathbf{F^T F
            ! ( a - x_n ) = C ( a - x_n )}$.
            call cloneVector ( v(covarianceXApriori), apriori, &
              & vectorNameText='_covarianceXApriori' )
            if ( diagonal ) then
              call cloneVector ( v(covarianceDiag), state, &
               &  vectorNameText='_covarianceDiag' )
              call getDiagonal ( covariance%m, v(covarianceDiag) )
              ! covarianceXApriori := covarianceDiag # apriori:
              call multiply ( v(covarianceDiag), v(aprioriMinusX), &
                & v(covarianceXApriori) )
            else ! covarianceXApriori := covariance X apriori:
              call multiply ( covariance, v(aprioriMinusX), &
                & v(covarianceXApriori) )
            end if
            !{The contribution to the norm of the residual of the
            ! right-hand side of the part of the least-squares problem
            ! that is due to apriori is $\mathbf{
            ! ( a - x_n )^T F^T F ( a - x_n ) = ( a - x_n )^T \left [
            ! C ( a - x_n ) \right ] }$
            aj%fnorm = v(aprioriMinusX) .mdot. v(covarianceXapriori)
              if ( d_fnorm > -1 ) then             
                call output ( aj%fnorm, &
                  & before='A priori contribution to | F |^2 = ', advance='yes' )
                if ( d_fnorm > 1 ) then
                  call dump ( v(aprioriMinusX), details=d_fnorm )
                  call dump ( v(covarianceXapriori), details=d_fnorm )
                end if
              end if
            !{ Using Apriori requires adding equations of the form ${\bf F
            !  x}_{n+1} \simeq {\bf F a}$ where ${\bf F}$ is the Cholesky
            !  factor of $\bf C$, the inverse of the apriori covariance ${\bf
            !  S}_a$.  So that all of the parts of the problem are solving
            !  for ${\bf\delta x}$, we subtract ${\bf F x}_n$ from both
            !  sides, to get ${\bf F \delta x} \simeq {\bf F (a - x}_n)$.
            !
            ! Actually, we start by putting this into the normal equations,
            ! so we form ${\bf C \delta x} = {\bf C (a - x}_n)$
            if ( diagonal ) then
            ! Iterate with the diagonal of the apriori covariance, then
            ! use the full apriori covariance (one hopes only for one
            ! more iteration). This improves sparsity during iteration.
              call clearMatrix ( normalEquations%m )
              call updateDiagonal ( normalEquations, v(covarianceDiag) )
            else
              call copyMatrixValue ( normalEquations%m, covariance%m )
            end if
            call copyVector ( v(aTb), v(covarianceXApriori) ) ! A^T b := C (a-x_n)
            if ( got(f_aprioriScale) ) then
              call scaleMatrix ( normalEquations%m, aprioriScale )
              ! Don't need to scale aTb -- covarianceXApriori is scaled already
            end if
          else
            aj%fnorm = 0.0_r8
              if ( d_fnorm > -1 ) call output ( &
                & 'No a priori so setting | F | to zero.', advance='yes' )
            call clearMatrix ( normalEquations%m ) ! start with zero
            call clearVector ( v(aTb) ) ! Clear the RHS vector
          end if

          ! Add Tikhonov regularization if requested.
          if ( tikhonovNeeded .and. tikhonovBefore .and. &
            & ( ( nwt_flag /= nf_getj ) .or. .not. covSansReg ) ) then
              call add_to_retrieval_timing( 'newton_solver', t1 )

              call applyTikhonov ( .false., normalEquations, AJ, &
                & tikhonovRows, d_reg, d_fnorm )

          else
            tikhonovRows = 0
          end if

          ! Copy the normal equations formed thus far into a temporary matrix
          ! for the negateSD case
          if ( negateSD .or. associated(aprioriFraction) ) &
            & call copyMatrix ( aPlusRegNEQ%m, normalEquations%m )

          fmStat%maf = 0
          fmStat%newScanHydros = .true.

          if ( d_vir ) call dump ( normalEquations%m, details=2 )

          ! Include the part of the normal equations due to the Jacobian matrix
          ! and the measurements
          call clearVector ( v(f_rowScaled) )
          if ( got(f_average) .and. .not. extendedAverage ) then
            ! Need a separate matrix for K^T K
            kTk => kTkSep
            call clearMatrix ( kTkSep%m )
          else
            kTk => normalEquations
          end if

          ! If in fwm parallel mode, get all slaves computing the forward models
          if ( parallelMode ) then
              if ( d_mas ) &
                & call output ( "Triggering slave forward model runs", advance='yes' )
            latestMAFStarted = min ( parallel%noFwmSlaves, &
              & chunk%lastMAFIndex-chunk%firstMAFIndex+1 )
            do t = 1, latestMAFStarted
              call TriggerSlaveRun ( v(x), t )
            end do
            ! Get the first one setup to send results as soon as possible
            call RequestSlavesOutput ( 1 )
          end if

          ! Loop over MAFs
          do while (fmStat%maf < chunk%lastMAFIndex-chunk%firstMAFIndex+1)
              call add_to_retrieval_timing( 'newton_solver', t1 )
            !??? What if one config set finished but others still had more
            !??? to do? Ermmm, think of this next time.
            fmStat%maf = fmStat%maf + 1
            fmstat%rows = .false.
            if ( parallelMode ) then
              call ReceiveSlavesOutput ( v(f_rowScaled), fmStat, jacobian )
              ! If there is still another MAF to launch off, let's do that
              if ( latestMAFStarted < chunk%lastMAFIndex-chunk%firstMAFIndex+1 ) then
                latestMAFStarted = latestMAFStarted + 1
                call TriggerSlaveRun ( v(x), latestMAFStarted )
              end if
              ! Set the next slave about packing up its output while we do
              ! our normal equations stuff
              if ( fmStat%maf < chunk%lastMAFIndex-chunk%firstMAFIndex+1 ) &
                & call RequestSlavesOutput ( fmStat%maf + 1 )
            else
              ! Otherwise, we call the forward model as usual
              do k = 1, size(configIndices)
                call forwardModel ( configDatabase(configIndices(k)), &
                  & v(x), fwdModelExtra, v(f_rowScaled), fmStat, Jacobian, &
                  & Hessian, vectorDatabase )
              end do ! k
              call time_now ( t1 )
              ! Forward model calls add_to_retrieval_timing
            end if
            call time_now ( t1 )
              if ( d_jac_f > -1 ) &
                & call dump ( jacobian, name='Jacobian', details=d_jac_f, clean=d_drmc )
            do rowBlock = 1, size(fmStat%rows)
              if ( fmStat%rows(rowBlock) ) then
                 ! Store what we've just got in v(f) ie fwdModelOut
                call copyVector ( v(f), v(f_rowScaled), & ! v(f) := v(f_rowScaled)
                  & quant=jacobian%row%quant(rowBlock), &
                  & inst=jacobian%row%inst(rowBlock) )
                call subtractFromVector ( v(f_rowScaled), measurements, &
                  & quant=jacobian%row%quant(rowBlock), &
                  & inst=jacobian%row%inst(rowBlock) ) ! f - y
                  if ( d_resid > -1 ) call dump ( v(f_rowScaled), &
                    & name='Residuals', details=d_resid )
                !{Let $\bf W$ be the Cholesky factor of the inverse of the
                ! measurement covariance ${\bf S}_m$ (which in our case is
                ! diagonal), i.e. ${\bf W}^T {\bf W} = {\bf S}_m^{-1}$. Row
                ! scale the part of the least-squares problem that arises
                ! from the measurements, i.e. the least-squares problem
                ! becomes $\mathbf{W J \delta \hat x \simeq - W f}$ (actually,
                ! we only row scale ${\bf f}$ here, and scale ${\bf J}$
                ! below).
                if ( got(f_measurementSD) ) then
                  call multiply ( v(f_rowScaled), v(weight), &
                    & quant=jacobian%row%quant(rowBlock), &
                    & inst=jacobian%row%inst(rowBlock) )
                end if
              end if
            end do
            call scaleVector ( v(f_rowScaled), -1.0_r8 ) ! y - f

            if ( got(f_sparseQuantities) ) call Sparsify ( jacobian, &
              & rowQuantities=sparseQuantities )
            if ( got(f_measurementSD) ) call rowScale ( v(weight), jacobian )

            !{Form normal equations:
            ! ${\bf J}^T {\bf W}^T {\bf W J \delta \hat x} =
            ! {\bf J}^T {\bf S}_m^{-1} {\bf J \delta \hat x} =
            ! -{\bf J}^T {\bf W}^T {\bf W f} =
            ! -{\bf J}^T {\bf S}_m^{-1} {\bf f}$.
              call add_to_retrieval_timing( 'newton_solver', t1 )
            call formNormalEquations ( jacobian, kTk, rhs_in=v(f_rowScaled), &
              & rhs_out=v(aTb), update=update, useMask=.true. )
              if ( d_kTk>-1 ) call dump ( kTk%m, name='kTk', details=d_kTk )
              if ( d_atb ) call dump ( v(aTb) )
              call add_to_retrieval_timing( 'form_normeq', t1 )
            if ( got(f_average) .and. extendedAverage ) then
              call MultiplyMatrix_XTY ( jacobian, jacobian, kTkStar, update=update, &
                & maskX=.true., maskY=.false. )
            end if
            update = .true.
              if ( d_jac_n ) &
                call dump_Linf ( jacobian, 'L_infty norms of Jacobian blocks:' )
              if ( d_spa ) call dump_struct ( jacobian, &
                  & 'Sparseness structure of Jacobian blocks:' )
            call clearMatrix ( jacobian )  ! free the space
          end do ! mafs
          call DestroyForwardModelIntermediate ! in case scan model got used
          fmStat%newScanHydros = .true.

          ! In the case where we're forming a regular averaging kernel
          ! (not extended), we need to add this MAFs worth of kTk into the
          ! normal equations.  Otherwise normalEquations and kTk are in
          ! fact pointers to the same matrix
          if ( got(f_average) .and. .not. extendedAverage ) then
            call addToMatrix ( normalEquations%m, kTk%m )
          end if

          ! aj%fnorm is still the square of the function norm
          aj%fnorm = aj%fnorm + ( v(f_rowScaled) .mdot. v(f_rowScaled) )
            if ( d_fnorm > -1 ) &
              & call output ( v(f_rowScaled) .mdot. v(f_rowScaled), &
                & before='Measurement contribution to | F |^2 = ', advance='yes' )

          ! Add Tikhonov regularization if requested.  We do it here instead
          ! of before adding the Jacobian so that we can scale it up by the
          ! column scaling before scaling the normal equations back down
          ! by the column scaling.  The effect is that regularization takes
          ! place (roughly) on the column-scaled problem, and if scaling by
          ! the column norm is requested, it's still makes the column norms
          ! all 1.0.
          if ( tikhonovNeeded .and. .not. tikhonovBefore .and. &
            & ( ( nwt_flag /= nf_getj ) .or. .not. covSansReg ) ) then
              call add_to_retrieval_timing( 'newton_solver', t1 )

              call applyTikhonov ( .true., normalEquations, AJ, &
                & tikhonovRows, d_reg, d_fnorm )

          else
            tikhonovRows = 0
          end if

          !{Column Scale $\bf J$ (row and column scale ${\bf J}^T {\bf J}$)
          ! using the matrix $\bf\Sigma$. We cater for several choices of
          ! $\bf\Sigma$.  After row scaling with $\bf W$ and column scaling
          ! with $\bf\Sigma$, the least-squares problem is ${\bf W J \Sigma
          ! \Sigma}^{-1} {\bf \delta \hat x} \simeq -{\bf W f}$.  We will
          ! solve for ${\bf \Sigma}^{-1} {\bf \delta \hat x}$, and then for
          ! $\bf \delta \hat x$.
          select case ( columnScaling )
          case ( l_apriori ) ! v(columnScaleVector) := apriori
            call copyVector ( v(columnScaleVector), apriori )
          case ( l_covariance )
            !??? Can't get here until allowed by init_tables
          case ( l_norm ) ! v(columnScaleVector) := diagonal of normal
                          !                         equations = column norms^2
            call getDiagonal ( normalEquations%m, v(columnScaleVector) )
          end select
          if ( columnScaling /= l_none ) then ! Compute $\Sigma$
            do j = 1, v(columnScaleVector)%template%noQuantities
              where ( v(columnScaleVector)%quantities(j)%values <= 0.0 )
                v(columnScaleVector)%quantities(j)%values = 1.0
              elsewhere
                v(columnScaleVector)%quantities(j)%values = 1.0 / &
                  & sqrt( v(columnScaleVector)%quantities(j)%values )
              end where
            end do
              if ( d_col ) &
                & call dump ( v(columnScaleVector), name='Column scale vector' )
            !{Scale in normal equations form: ${\bf \Sigma}^T {\bf  J}^T {\bf
            ! W}^T {\bf W J \Sigma \Sigma}^{-1} {\bf \delta \hat x} = {\bf
            ! \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf J \Sigma \Sigma}^{-1}
            ! {\bf \delta \hat x} =  -{\bf \Sigma}^T {\bf J}^T {\bf W}^T {\bf
            ! W f} = -{\bf \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf f}$.
            call columnScale ( normalEquations%m, v(columnScaleVector) )
            call rowScale ( v(columnScaleVector), normalEquations%m )
            call multiply ( v(aTb), v(columnScaleVector) )
          end if

          !{The (negative of the) gradient $= -{\bf \Sigma}^T {\bf J}^T
          ! {\bf S}_m^{-1} {\bf f}$
          ! is the right-hand side of the normal equations.  Save it.
          call copyVector ( v(gradient), v(aTb) ) ! gradient := atb
          ! Make sure the gradient is zerod out in various places.
          ! aTb may have non zero values in masked places where x/=a.
          call copyVectorMask ( v(gradient), v(x) )
          call clearUnderMask ( v(gradient) )
            if ( d_gvec ) call dump ( v(gradient), name='gradient' )

          !{Compute the Cholesky factor of the LHS of the normal equations:
          ! ${\bf U}^T {\bf U} {\bf \Sigma}^{-1} {\bf \delta \hat x} =
          ! ({\bf\Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf J \Sigma})
          ! {\bf \Sigma}^{-1} {\bf \delta \hat x} = -{\bf \Sigma}^T {\bf J}^T
          ! {\bf S}_m^{-1} {\bf f}$.

          ! factored%m%block => normalEquations%m%block ! to save space
          ! Can't do the above because we need to keep the normal
          ! equations around, in order to subtract Levenberg-Marquardt and
          ! apriori covariance, in order to compute a posteriori covariance
            if ( d_neq == 0 ) &
              call dump_Linf ( normalEquations%m, &
                & 'L_infty norms of Normal Equations blocks after scaling:', &
                & upper=.true. )
            if ( d_spa ) call dump_struct ( normalEquations%m, &
                & 'Sparseness structure of Normal equations blocks:', &
                & upper=.true. )
            call add_to_retrieval_timing ( 'newton_solver', t1 )
          call choleskyFactor ( factored, normalEquations, status=matrixStatus )
            call add_to_retrieval_timing ( 'cholesky_factor', t1 )
          if ( any ( matrixStatus /= 0 ) ) then
            call dump ( matrixStatus, 'matrixStatus [block, row in trouble] = ' )
            if ( d_mst ) then
              ! Dump the structure if we haven't done so already
              if ( .not. d_spa ) call dump_struct ( normalEquations%m, &
                  & 'Sparseness structure of Normal equations blocks:' )
!               call dump ( normalEquations%m%block(matrixStatus(1),matrixStatus(1)), &
!               & name='Offending block', details=9 )
              call dump ( normalEquations%m, name='Normal equations', details=9 )
              call dump ( v(columnScaleVector), name='Column scale', details=9 )
              call dump ( v(x), name='Current state', details=9 )
              if ( got(f_lowBound) ) call dump ( lowBound, name='Low Bound', details=9 )
              if ( got(f_highBound) ) call dump ( highBound, name='High Bound', details=9 )
            else
              call dump ( normalEquations%m%block(matrixStatus(1),matrixStatus(1)), &
                & name='Offending block', details=0 )
            end if
            call output ( &
              & 'Consider applying or increasing the weight of Tikhonov regularization for the block', &
              & advance='yes' )
            call output ( 'Re-run with -Smst to see more details', advance='yes' )
            call newtonSolverFailed ( 'problem factoring normalEquations in evalJ', &
              & nwt_flag, prev_nwt_flag, d_ndb, aj )
!             exit NEWT
            cycle NEWT
          end if
            if ( d_neq > 0 ) &
              & call dump ( normalEquations%m, 'Normal Equations', 2, clean=d_drmc )
            if ( d_diag ) then
              call getDiagonal ( factored%m, v(dxUnscaled) )
              call dump ( v(dxUnscaled), &
                & name='Diagonal of factored normal equations:' )
            end if
            if ( d_fac_n ) call dump_Linf ( factored%m, &
              & 'L_infty norms of blocks of factor:', upper=.true. )
            if ( d_spa ) call dump_struct ( factored%m, &
              & 'Sparseness structure of blocks of factor:', upper=.true. )
            if ( d_fac_f ) call dump ( factored%m, 'Factor', 2, clean=d_drmc )

          ! Compute numbers of rows and columns of Jacobian actually used. 
          ! Don't count rows due to Levenberg-Marquardt stabilization.  Do
          ! count rows due to a priori or regularization.  Don't count
          ! masked-off measurement or state rows or columns.
          jacobian_cols = sum(jacobian%col%nelts)
          do j = 1, state%template%noQuantities
            if ( associated(state%quantities(j)%mask) ) &
              ! Subtract masked-off columns
              & jacobian_cols = jacobian_cols - &
              &   countBits(state%quantities(j)%mask, what=m_linAlg )
          end do
          jacobian_rows = sum(jacobian%row%nelts)
          do j = 1, measurements%template%noQuantities
            if ( associated(measurements%quantities(j)%mask) ) &
              ! subtract masked-off rows
              & jacobian_rows = jacobian_rows - &
              &   countBits(measurements%quantities(j)%mask, what=m_linAlg )
          end do

          ! Correct the number of rows for apriori information.  Note that
          ! there is an approximation here: We don't take any account of
          ! whether the a priori is used on an element by element basis.
          if ( got(f_apriori) ) jacobian_rows = jacobian_rows + jacobian_cols

          if ( tikhonovNeeded ) then
            ! Correct the number of rows for Tikhonov information, unless
            ! we're taking a special iteration to get a Jacobian without
            ! Tikhonov regularization.
            if ( nwt_flag /= nf_getJ .or. .not. covSansReg ) &
              & jacobian_rows = jacobian_rows + tikhonovRows
          end if

          ! Exit if we are taking a special iteration to get J.
          if ( nwt_flag == nf_getJ ) exit NEWT

          aj%diag = minDiag ( factored ) ! element on diagonal with
            !       smallest absolute value, after triangularization
          aj%ajn = maxL1 ( factored%m ) ! maximum L1 norm of
          !       column in upper triangle after triangularization
            call add_to_retrieval_timing ( 'newton_solver', t1 )

          !{Solve ${\bf U}^T {\bf U} {\bf \Sigma}^{-1} {\bf \delta \hat x} =
          ! -{\bf \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf f}$ for
          ! ${\bf U} {\bf \Sigma}^{-1} {\bf \delta \hat x} = {\bf v}$.

          call solveCholesky ( factored, v(candidateDX), v(aTb), &
            & transpose=.true., status=matrixStatus )
          call copyVectorMask ( v(candidateDX), v(x) )
            call add_to_retrieval_timing ( 'cholesky_solver', t1 )
          if ( any ( matrixStatus /= 0 ) ) then
            call dump ( matrixStatus, 'matrixStatus [block, row in trouble] = ' )
            if ( d_mst ) then
              call dump ( normalEquations%m%block(matrixStatus(1),matrixStatus(1)), &
              & name='Offending block', details=9 )
              call dump ( v(columnScaleVector), name='Column scale', details=9 )
              call dump ( v(x), name='Current state', details=9 )
              if ( got(f_lowBound) ) call dump ( lowBound, name='Low Bound', details=9 )
              if ( got(f_highBound) ) call dump ( highBound, name='High Bound', details=9 )
            end if
            call newtonSolverFailed ( 'problem solving normalEquations in evalJ', &
              & nwt_flag, prev_nwt_flag, d_ndb, aj )
!             exit NEWT
            cycle NEWT
          end if
            if ( d_dvec ) call dump ( v(candidateDX), name='CandidateDX 1' )
            if ( d_dxn > -1 ) &
              & call dumpVectorNorms ( v(candidateDX), d_dxn, &
                & name='|CandidateDX| 1', useMask=.true. )

          !{AJ\%FNMIN = $L_2$ norm of residual, $||{\bf\Sigma}^T {\bf J}^T
          ! {\bf S}_m^{-1} {\bf J \Sigma \Sigma}^{-1} {\bf \delta \hat x} +
          ! {\bf \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf f}||$ where
          ! $\bf\delta \hat x$ is the ``Candidate DX'' that might not get
          ! used. This can be gotten without saving $\bf J$ as $\sqrt{{\bf f}^T
          ! {\bf f} - {\bf v}^T {\bf v}}$ where ${\bf v} = {\bf U}^{-T}
          ! {\bf \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf f}$. The variable
          ! {\tt v(candidateDX)} is a temp here = $\bf v$ in {\tt wvs-011}
          ! or $\bf y$ in {\tt wvs-014}.
          aj%fnmin = aj%fnorm - (v(candidateDX) .mdot. v(candidateDX))
          if ( aj%fnmin < 0.0 ) then
            if ( abs(aj%fnmin) > &
               & (aj%fnorm + (v(candidateDX) .mdot. v(candidateDX))) * &
                   & sqrt(sqrt(epsilon(1.0e0)))**3 ) then
              ! Relative to aj%fnorm and v(candidateDX)**2, it's more than
              ! single-precision round_off**(0.75).
              call output ( aj%fnmin, before='How can aj%fnmin be negative?  aj%fnmin = ', &
                & advance='yes' )
              call output ( aj%fnorm, before='aj%fnorm**2 = ', advance='yes' )
              call output ( v(candidateDX) .mdot. v(candidateDX), &
                & before='norm(candidateDX)**2 = ', advance='yes' )
              if ( d_fnmin > 1 ) &
                & call dump ( v(candidateDX), name='v(candidateDX)', details=d_fnmin )
              if ( aj%fnmin < -10.0 * aj%fnorm * sqrt(epsilon(aj%fnorm)) ) &
                & call MLSMessage ( MLSMSG_Warning, ModuleName, &
                  & "Norm of residual not in Jacobian's column space is imaginary!" )
            end if
            aj%fnmin = tiny ( aj%fnmin )
          end if
          ! Compute the normalised chiSquared statistics etc.
          dof = max ( jacobian_rows - jacobian_cols, 1 )
          chiSqMinNorm = aj%fnmin / dof
          chiSqNorm = aj%fnorm / dof
          aj%fnmin = sqrt(aj%fnmin)
          aj%fnorm = sqrt(aj%fnorm)
          call copyVectorMask ( v(gradient), v(x) )
          aj%gradn = sqrt(v(gradient) .mdot. v(gradient)) ! L2Norm(gradient)
            if ( d_sca ) then
              call dump ( (/ aj%fnorm, aj%fnmin, aj%diag, aj%ajn, aj%gradn /), &
                & '     | F |      aj%fnmin       aj%diag      L1| FAC |        | G |', &
                & options='c' )
              call dump ( (/ chiSqNorm, chiSqMinNorm, dof /), &
                & ' chi^2/DOF  chimin^2/DOF           DOF ', options='c' )
            end if
        case ( nf_lev ) ! ..................................  LEV  .....
        !{Solve ${\bf U}^T {\bf q} = {\bf \delta \hat x}$, then compute
        ! $||{\bf q}||^2$, which is used to compute the Levenberg-Marquardt
        ! stabilization parameter.
          call solveCholesky ( factored, q, v(candidateDX), &
            & transpose=.true., status=matrixStatus ) ! q := factored^{-T} v(candidateDX)
          if ( any ( matrixStatus /= 0 ) ) then
            call dump ( matrixStatus, 'matrixStatus [block, row in trouble] = ' )
            call newtonSolverFailed ( 'problem solving for q in levenberg', &
              & nwt_flag, prev_nwt_flag, d_ndb, aj )
!             exit NEWT
            cycle NEWT
          end if
          call copyVectorMask ( q, v(x) )
          aj%qnsq = q .mdot. q
        case ( nf_solve ) ! ..............................  SOLVE  .....
        !{Apply Levenberg-Marquardt stabilization with parameter
        ! $\lambda =$ {\bf AJ\%SQ}.  I.e., form $({\bf \Sigma}^T {\bf J}^T
        ! {\bf W}^T {\bf W J \Sigma + \lambda^2 I}) {\bf \Sigma}^{-1}
        ! {\bf \delta \hat x = \Sigma}^T {\bf J}^T {\bf W}^T {\bf f}$ for
        ! ${\bf \Sigma}^{-1} {\bf \delta \hat x}$.  The update is
        ! aj\%sq$^2 - \lambda^2$ to remove the previous Levenberg-Marquardt
        ! parameter.  Then set
        ! \begin{description}
        !   \item[AJ\%FNMIN] as for NWT\_FLAG = NF\_EVALJ, but taking
        !     account of Levenberg-Marquardt stabilization;
        !   \item[AJ\%DXN] = L2 norm of ``candidate DX'';
        !   \item[AJ\%GDX] = (Gradient) .dot. (``candidate DX'')
        ! \end{description}
          call updateDiagonal ( normalEquations, &
                              & max(aj%sq, lambdaMin)**2 - lambda**2 )
          lambda = max(aj%sq, lambdaMin)
          ! factored%m%block => normalEquations%m%block ! to save space
          ! Can't do the above because we need to keep the normal equations
          ! around, in order to subtract Levenberg-Marquardt and apriori
          ! covariance, in order to compute a posteriori covariance
            if ( d_neq > 0 ) then
              call dump ( normalEquations%m, 'Normal Equations', 2, clean=d_drmc )
            else if ( d_neq == 0 ) then
              call dump_Linf ( normalEquations%m, &
                & 'L1 norms of Normal Equations blocks after Marquardt:', &
                & upper=.true. )
            end if
            if ( d_spa ) call dump_struct ( normalEquations%m, &
                & 'Sparseness structure of Normal equations blocks:', &
                & upper=.true. )
            call add_to_retrieval_timing( 'newton_solver', t1 )
          call choleskyFactor ( factored, normalEquations, status=matrixStatus )
            call add_to_retrieval_timing( 'cholesky_factor', t1 )
          if ( any ( matrixStatus /= 0 ) ) then
            call dump ( matrixStatus, 'matrixStatus [block, row in trouble] = ' )
            if ( d_mst ) then
              call dump ( normalEquations%m%block(matrixStatus(1),matrixStatus(1)), &
              & name='Offending block', details=9 )
              call dump ( v(columnScaleVector), name='Column scale', details=9 )
              call dump ( v(x), name='Current state', details=9 )
              if ( got(f_lowBound) ) call dump ( lowBound, name='Low Bound', details=9 )
              if ( got(f_highBound) ) call dump ( highBound, name='High Bound', details=9 )
            end if
            call newtonSolverFailed ( 'problem factoring normal equations in solve', &
              & nwt_flag, prev_nwt_flag, d_ndb, aj )
!             exit NEWT
            cycle NEWT
          end if
            if ( d_fac_n ) call dump_Linf ( factored%m, &
                & 'L1 norms of blocks of factor after Marquardt:', &
                & upper=.true. )
            if ( d_spa ) call dump_struct ( factored%m, &
                & 'Sparseness structure of blocks of factor:', upper=.true. )
            if ( d_fac_f ) call dump ( factored%m, &
                & name='Factored, after Marquardt', details=2, clean=d_drmc )

          !{Solve ${\bf U}^T {\bf U} {\bf \Sigma}^{-1} {\bf \delta \hat x} =
          ! ({\bf\Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf J \Sigma}) {\bf
          ! \Sigma}^{-1} {\bf \delta \hat x} = -{\bf \Sigma}^T {\bf J}^T {\bf
          ! S}_m^{-1} {\bf f}$ for ``candidate DX'' = ${\bf \Sigma}^{-1} {\bf
          ! \delta \hat x}$ using two back solves.  First solve ${\bf U}^T {\bf v}
          ! = -{\bf \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf f}$ for ${\bf v}$,
          ! then solve ${\bf U \Sigma}^{-1} {\bf \delta \hat x}$ = ${\bf v}$ for
          ! ${\bf \Sigma}^{-1} {\bf \delta \hat x}$. Meanwhile, set AJ\%FNMIN =
          ! $\sqrt{{\bf f}^T {\bf f} - {\bf v}^T {\bf v}}$ as when NWT\_FLAG is
          ! NF\_EVALJ, but taking account of Levenberg-Marquardt stabilization.
            call add_to_retrieval_timing( 'newton_solver', t1 )
          call solveCholesky ( factored, v(candidateDX), v(aTb), &
            & transpose=.true., status=matrixStatus ) ! v(candidateDX) := factored^{-T} v(aTb)
          call copyVectorMask ( v(candidateDX), v(x) )
            call add_to_retrieval_timing( 'cholesky_solver', t1 )
          if ( any ( matrixStatus /= 0 ) ) then
            call dump ( matrixStatus, 'matrixStatus [block, row in trouble] = ' )
            call newtonSolverFailed ( 'problem solving for aTb in solve', &
              & nwt_flag, prev_nwt_flag, d_ndb, aj )
!             exit NEWT
            cycle NEWT
          end if
            if ( d_dvec ) call dump ( v(candidateDX), name='CandidateDX 2' )
            if ( d_dxn > -1 ) &
              & call dumpVectorNorms ( v(candidateDX), d_dxn, &
                & name='|CandidateDX| 2', useMask=.true. )

          if ( ieee_is_nan ( aj%fnorm ) ) then
            if ( d_strb ) call dump ( v(x), name='Current state', details=9 )
            call newtonSolverFailed ( 'numerical problems (with radiances?)', &
              & nwt_flag, prev_nwt_flag, d_ndb, aj )
!             exit NEWT
            cycle NEWT
          end if

          ! aj%fnorm is now the norm of f, not its square.
          ! The following calculation of fnmin was commented out, but on
          ! 11 September 2002 FTK told me it's the right thing to do
          ! after all.
          aj%fnmin = aj%fnorm**2 - (v(candidateDX) .mdot. v(candidateDX))

          if ( ieee_is_nan ( aj%fnmin ) ) then
            if ( d_strb ) call dump ( v(x), name='Current state', details=9 )
            call newtonSolverFailed ( 'numerical problems (with derivatives?)', &
              & nwt_flag, prev_nwt_flag, d_ndb, aj )
!             exit NEWT
            cycle NEWT
          end if

          if ( aj%fnmin < 0.0 ) then
            if ( abs(aj%fnmin) > &
               & (aj%fnorm + (v(candidateDX) .mdot. v(candidateDX))) * &
                   & sqrt(sqrt(epsilon(1.0e0)))**3 ) then
              ! Relative to aj%fnorm and v(candidateDX)**2, it's more than
              ! single-precision round_off**(0.75).
              call output ( aj%fnmin, before='How can aj%fnmin be negative?  aj%fnmin = ', &
                & advance='yes' )
              call output ( aj%fnorm**2, before='aj%fnorm**2 = ', advance='yes' )
              call output ( v(candidateDX) .mdot. v(candidateDX), &
                & before='norm(candidateDX)**2 = ', advance='yes' )
              if ( d_fnmin > 1 ) &
                & call dump ( v(candidateDX), name='v(candidateDX)', details=d_fnmin )
              if ( aj%fnmin < -10.0 * aj%fnorm * sqrt(epsilon(aj%fnorm)) ) &
                & call MLSMessage ( MLSMSG_Warning, ModuleName, &
                  & "Norm of residual not in Jacobian's column space is imaginary!" )
            end if
            aj%fnmin = tiny ( aj%fnmin )
          end if
          aj%fnmin = sqrt(aj%fnmin)
          ! v(candidateDX) := factored^{-1} v(candidateDX)
          call solveCholesky ( factored, v(candidateDX), status=matrixStatus )
          call copyVectorMask ( v(candidateDX), v(x) )
          if ( any ( matrixStatus /= 0 ) ) then
            call dump ( matrixStatus, 'matrixStatus [block, row in trouble] = ' )
            call newtonSolverFailed ( 'problem solving normal equations in solve', &
              & nwt_flag, prev_nwt_flag, d_ndb, aj )
!             exit NEWT
            cycle NEWT
          end if
            if ( d_dvec ) call dump ( v(candidateDX), name='CandidateDX 3' )
            if ( d_dxn > -1 ) &
              & call dumpVectorNorms ( v(candidateDX), d_dxn, &
                & name='|CandidateDX| 3', useMask=.true. )

          !{Shorten $\delta {\bf \hat x} =$ {\tt dxUnScaled} to stay within
          ! the bounds. We aren't ready to take the move, but NWTA needs an
          ! accurate value for the norm of {\tt candidateDX}.  We don't simply
          ! put out-of-bounds variables onto their bounds, as this could
          ! change the direction away from the Newton direction.
          call copyVector ( v(dxUnScaled), v(candidateDX) ) ! dxUnscaled = dx
          if ( columnScaling /= l_none ) then ! Scale into problem's space
            ! dxUnScaled = dxUnScaled # columnScaleVector:
            call multiply ( v(dxUnScaled), v(columnScaleVector) )
          end if
          mu = 1.0_rv
          if ( got(f_lowBound) ) &
            & call boundMove ( mu, lowBound, v(x), v(dxUnScaled), 'low', muMin )
          if ( got(f_highBound) ) &
            & call boundMove ( mu, highBound, v(x), v(dxUnScaled), 'high', muMin )
          ! dxUnScaled = mu * dxUnScaled -- may shorten vector in problem space
          call scaleVector ( v(dxUnScaled), mu )
          call scaleVector ( v(candidateDX), mu )
          aj%dxn = sqrt(v(candidateDX) .mdot. v(candidateDX)) ! L2Norm(dx)
          call copyVectorMask ( v(gradient), v(x) )
          aj%gdx = v(gradient) .mdot. v(candidateDX)
          if ( .not. aj%starting ) then
            call copyVectorMask ( v(dx), v(x) )
            aj%dxdxl = v(dx) .mdot. v(candidateDX)
          end if
            if ( d_dvec ) call dump ( v(candidateDX), name='CandidateDX 4' )
            if ( d_dxn > -1 ) &
              & call dumpVectorNorms ( v(candidateDX), d_dxn, &
                & name='|CandidateDX| 4', useMask=.true. )
            if ( d_sca ) then
              cosine = -2.0_r8
              if ( aj%dxn > 0.0_r8 .and. aj%gradn > 0.0_r8 ) &
                cosine = aj%gdx/(aj%dxn*aj%gradn)
              call dump ( (/ aj%dxn, aj%fnmin, cosine, aj%sq, mu /), &
                & '    | DX |      aj%fnmin    ' // &
                & 'cos(G, DX)        lambda            mu', options='c' )
              if ( .not. aj%starting ) then
                call output ( ' cos(DX, DXL) = ' )
                cosine = -2.0_r8
                if ( aj%dxn > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
                  cosine = aj%dxdxl / (aj%dxn*aj%dxnl)
                call output ( cosine, format='(1pe14.7)', advance='yes' )
              ! call output ( ',  DX . DXL = ' )
              ! call output ( aj%dxdxl, format='(1pe14.7)', advance='yes' )
              end if
            end if
            if ( d_ndb >= 0 ) call my_nwtdb ( aj, width=9, why='After Solve' )
        case ( nf_newx ) ! ................................  NEWX  .....
          ! Set X = X + DX
          !     AJ%AXMAX = MAXVAL(ABS(X)),
          !     AJ%BIG = ANY ( DX > 10.0 * epsilon(X) * X )

          !{Set $\delta {\bf x} := \delta {\bf \hat x}$ and then ${\bf x} :=
          ! {\bf x} + \delta {\bf x}$.  We already accounted for column scaling
          ! when a candidate Newton move or gradient move was put into {\tt
          ! v(dxUnscaled)}, i.e., we're now dealing with $\delta {\bf \hat x}$,
          ! not ${\bf \Sigma}^{-1} \delta {\bf \hat x}$. Shorten {\tt
          ! dxUnscaled} if necessary to stay within the bounds.  We did this
          ! when we solved for $\delta {\bf \hat x}$ as a Newton move because
          ! DNWT needed the norm of the actual candidate move, but if this move
          ! is a gradient or Aitken-accelerated move, we still need to stay in
          ! bounds.
          mu = 1.0
          if ( got(f_lowBound) ) &
            & call boundMove ( mu, lowBound, v(x), v(dxUnscaled), 'low', muMin )
          if ( got(f_highBound) ) &
            & call boundMove ( mu, highBound, v(x), v(dxUnscaled), 'high', muMin )
          if ( mu < 1.0_rv ) call scaleVector ( v(dxUnscaled), mu )
          call addToVector ( v(x), v(dxUnScaled) ) ! x = x + dxUnScaled
          atBest = .false.
            if ( d_dvec ) call dump ( v(dxUnScaled), name='dX Unscaled' )
            if ( d_dxn > -1 ) &
              & call dumpVectorNorms ( v(dxUnScaled), d_dxn, &
                & name='|dxUnScaled|', useMask=.true. )
          if ( got(f_stateMax) ) then
            do j = 1, size(v(x)%quantities)
              stateMax%quantities(j)%values = max(stateMax%quantities(j)%values, &
                &                                 v(x)%quantities(j)%values)
            end do
          end if
          if ( got(f_stateMin) ) then
            do j = 1, size(v(x)%quantities)
              stateMin%quantities(j)%values = min(stateMin%quantities(j)%values, &
                &                                 v(x)%quantities(j)%values)
            end do
          end if
          aj%axmax = 0.0
          aj%big = .false.
          do j = 1, size(v(x)%quantities)
            aj%axmax = max(aj%axmax, maxval(abs(v(x)%quantities(j)%values)))
            if ( any( abs(v(dx)%quantities(j)%values) > &
              & 10.0 * epsilon(aj%axmax) * abs(v(x)%quantities(j)%values) ) ) &
              & aj%big = .true.
          end do
            if ( d_sca ) then
              call output ( ' aj%axmax = ' )
              call output ( aj%axmax, format='(1pe14.7)' )
              if ( .not. aj%starting ) then
                call output ( ' cos(DX, DXL) = ' )
                cosine = -2.0_r8
                if ( aj%dxn > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
                  cosine = aj%dxdxl / (aj%dxn*aj%dxnl)
                call output ( cosine, format='(1pe14.7)' )
              ! call output ( ', DX . DXL = ' )
              ! call output ( aj%dxdxl, format='(1pe14.7)', advance='yes' )
              end if
              call output ( ', aj%big = ' )
              call output ( aj%big, advance='yes' )
            end if
        case ( nf_gmove ) ! ..............................  GMOVE  .....
        ! Set X = "Best X"
        !     DX = AJ%GFAC * "Best Gradient"
          numGrad = numGrad + 1
          if ( got(f_diagnostics) ) call FillDiagVec ( diagnostics, aj, &
            & numGrad=numGrad, numJ=numJ, numNewt=numNewt, nwt_flag=nwt_flag, &
            & jacobian_rows=jacobian_rows, jacobian_cols=jacobian_cols )
          call copyVectorMask ( v(bestX), v(x) ) ! Don't lose x's mask
          call copyVector ( v(x), v(bestX) ) ! x = bestX
          if ( .not. aj%starting ) then
            call copyVectorMask ( v(dx), v(x) )
            call copyVectorMask ( v(bestGradient), v(x) )
            aj%dxdxl = aj%gfac * ( v(dx) .mdot. v(bestGradient) )
          end if
          call copyVector ( v(dxUnscaled), v(bestGradient) ) ! dxUnscaled := bestGradient
          if ( columnScaling /= l_none ) & ! dxUnscaled = bestGradient / scale
            ! The saved gradient is in scaled coordinates.
            ! Put it back into the problem coordinates.
            & call multiply ( v(dxUnscaled), v(columnScaleVector) )
          ! dx = aj%gfac * "Best Gradient":
          call scaleVector ( v(dxUnscaled), aj%gfac )
            if ( d_sca ) then
              call output ( ' aj%gfac = ' )
              call output ( aj%gfac, format='(1pe14.7)' )
              call output ( ' |DX| = ' )
              call output ( aj%gradnb * aj%gfac, advance='yes' )
            end if
            if ( d_gvec ) call dump ( v(dxUnscaled), name='Gradient move from best X' )
        case ( nf_best ) ! ................................  Best  .....
        ! Set "Best X" = X, "Best Gradient" = Gradient
          atBest = .true.
          foundBetterState = .true.
          bestAJ = aj
          call copyVector ( v(bestX), v(x) ) ! bestX = x
          call copyVector ( v(bestGradient), v(gradient) ) ! bestGradient = gradient
        case ( nf_aitken ) ! ............................  Aitken  .....
        ! Set DX = DX - "Candidate DX",
        !     AJ%DXDX = dot_product( DX, DX )
        ! IF ( AJ%DXDX /= 0.0 ) &
        !   Set AJ%DXDXL = dot_product( DX, "Candidate DX" )
          call subtractFromVector ( v(dx), v(candidateDX) ) ! dx = dx - candidateDX
          call copyVectorMask ( v(dx), v(x) )
          aj%dxdx = v(dx) .mdot. v(dx)
          if ( aj%dxdx > 0.0 ) then
            call copyVectorMask ( v(candidateDX), v(x) )
            aj%dxdxl = v(dx) .mdot. v(candidateDX)
          end if
            if ( d_dvec ) call dump ( v(dx), name='dx after Aitken' )
            if ( d_sca ) then
              call output ( ' aj%dxdx = ' )
              call output ( aj%dxdx, format='(1pe14.7)' )
              call output ( ', cos(DX, DXL) = ' )
              cosine = -2.0_r8
              if ( aj%dxn > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
                cosine = aj%dxdxl / (aj%dxn*aj%dxnl)
              call output ( cosine, format='(1pe14.7)', advance='yes' )
            end if
        case ( nf_dx ) ! ....................................  DX  .....
          numNewt = numNewt + 1
          if ( got(f_diagnostics) ) call FillDiagVec ( diagnostics, aj, &
            & numGrad=numGrad, numJ=numJ, numNewt=numNewt, nwt_flag=nwt_flag, &
            & jacobian_rows=jacobian_rows, jacobian_cols=jacobian_cols )
          if ( .not. aj%starting ) then
            call copyVectorMask ( v(dx), v(x) )
            call copyVectorMask ( v(candidateDX), v(x) )
            aj%dxdxl = v(dx) .mdot. v(candidateDX)
          end if
          call copyVector ( v(dx), v(candidateDX) ) ! dx = candidateDX
          ! v(dxUnscaled) was computed during nf_solve
        case ( nf_dx_aitken ) ! ......................  DX_Aitken  .....
          numNewt = numNewt + 1
          if ( got(f_diagnostics) ) call FillDiagVec ( diagnostics, aj, &
            & numGrad=numGrad, numJ=numJ, numNewt=numNewt, nwt_flag=nwt_flag, &
            & jacobian_rows=jacobian_rows, jacobian_cols=jacobian_cols )
!!! This is needed for correct Aitken acceleration, but Bill Read doesn't
!!! like the results:
          ! dxUnscaled = aj%cait * dxUnscaled:
          if ( do_Aitken ) call scaleVector ( v(dxUnscaled), aj%cait )
          ! dx = aj%cait * candidateDX:
          call scaleVector ( v(candidateDX), aj%cait, v(dx) )
          if ( .not. aj%starting ) then
            call copyVectorMask ( v(dx), v(x) )
            call copyVectorMask ( v(candidateDX), v(x) )
            aj%dxdxl = v(dx) .mdot. v(candidateDX)
          end if
            if ( d_sca ) then
              call output ( ' aj%cait = ' )
              call output ( aj%cait, format='(1pe14.7)', advance='yes' )
            end if
            if ( d_dvec ) call dump ( v(dx), name='dx after dx Aitken' )
        case ( nf_tolx, nf_tolx_best, nf_tolf, nf_too_small ) ! ........
          ! IF ( NWT_FLAG == NF_TOO_SMALL ) THEN
          !   Take special action if requested accuracy is critical
          ! END IF
          ! Convergence to desired solution.  Do whatever you want to
          ! with the solution.
          if ( got(f_diagnostics) ) call FillDiagVec ( diagnostics, aj, &
            & numGrad=numGrad, numJ=numJ, numNewt=numNewt, nwt_flag=nwt_flag, &
            & jacobian_rows=jacobian_rows, jacobian_cols=jacobian_cols )
          if ( nwt_flag == nf_tolx_best ) then
            call copyVector ( v(x), v(bestX) )
            aj = bestAJ
            atBest = .false.
          end if
          if ( .not. diagonal ) then
              if ( d_nwt ) then
                call time_now ( t3 )
                call output ( t3-t0, after=' seconds', advance='yes', &
                  & before='Newton iteration terminated because of convergence at ' )
              end if
            nwt_flag = nf_getJ
            ! Do we need to get a fresh Jacobian, uncontaminated by Tikhonov
            ! regularization and Levenberg-Marquardt stabilization, in order
            ! to compute a posteriori covariance or standard deviation, or
            ! an averaging kernel?
            if ( ( got(f_outputCovariance) .or. got(f_outputSD) .or.  &
              &    got(f_average) ) .and.                             &
              &  ( nwt_flag == nf_tolx_best .or.                      &
              &    nwt_flag == nf_tolx .and. aj%sq /= 0.0 .or.        &
              &    tikhonovNeeded .and. covSansReg ) ) cycle NEWT ! yes
            exit NEWT ! no
          end if
          diagonal = .false.
          nwt_flag = nf_start
        case ( nf_fandj ) ! ...............................  FANDJ .....
          ! There is probably an error in the way F or J is computed.
          ! A warning has been printed by the error processor.
          ! IF ( you have confidence in F and J ) CYCLE
          ! STOP
        end select
      ! IF ( you want to return to a previous best X ) NWT_FLAG = 0
        if ( snoopKey /= 0 .and. snoopLevel >= snoopLevels(nwt_flag) ) then
          call FlagName ( nwt_flag, theFlagName )
          call snoop ( key=snoopKey, vectorDatabase=vectorDatabase, &
            & anotherVectorDatabase=v, &
            & anotherComment=trim(snoopComment) // ': ' // trim(theFlagName), &
            & anotherPhaseName=trim(phaseName), &
            & matrixDatabase=(/ factored%m, normalEquations%m /) )

        end if
          if ( d_ndb >= 2 ) call my_nwtdb ( aj, width=9, why='Bottom' )
        prev_nwt_flag = nwt_flag
      end do NEWT ! Newton iteration

      dof = max ( jacobian_rows - jacobian_cols, 1 )
      chiSqNorm = aj%fnorm / dof
      aj%fnorm = sqrt(aj%fnorm)
        if ( d_sca ) &
          & call dump ( (/ aj%fnorm, chiSqNorm, dof /) , &
          & '     | F |    chi^2/DOF           DOF ', options='c' )

        if ( d_ndb >= 1 ) &
          & call my_nwtdb ( aj, width=9, why = "After Newton iteration" )

      if ( got(f_diagnostics) .and. numJ > maxJacobians ) &
        & call FillDiagVec ( diagnostics, aj, &
        & numGrad=numGrad, numJ=numJ, numNewt=numNewt, nwt_flag=nf_too_many, &
        & jacobian_rows=jacobian_rows, jacobian_cols=jacobian_cols )
      abandoned_value = 0.d0
      if ( chunk%abandoned ) abandoned_value = 1.d0
      if ( got(f_diagnostics) ) then
          call fillDiagQty ( diagnostics,  l_dnwt_abandoned, abandoned_value )
          call fillDiagQty ( diagnostics, l_dnwt_count, loopCounter )
      end if

      ! chunk%abandoned = abandoned
      if ( chunk%abandoned ) then
          if ( d_cov ) call output ( "Abandoned; no covariance calculation", advance="yes" )
        foundBetterState = .false.
        ! We'll output our last good state, but set the error bar to
        ! the a priori error.
        if ( associated(outputSD) .and. associated(covariance) ) &
          & call GetDiagonal ( covariance%m, outputSD, squareRoot=.true., &
          & invert=.true., zeroOK=.true. )
        if ( got(f_outputCovariance) .and. associated(covariance) ) &
          & call CopyMatrix ( outputCovariance%m, covariance%m )
        ! Also flag our measurements as never having been used
        ! Was going to flag the forward model output, but its mask
        ! Gets overwritten with the measurements one.
        do j = 1, measurements%template%noQuantities
          if ( .not. associated ( measurements%quantities(j)%mask ) ) &
            & call CreateMask ( measurements%quantities(j) )
          measurements%quantities(j)%mask = char ( ior ( ichar ( &
            & measurements%quantities(j)%mask ), m_linAlg ) )
        end do
      end if

      !{Compute the covariance of the solution = ${\bf S}_s = ({\bf J}^T {\bf
      ! S}_m^{-1} {\bf J})^{-1}$, where ${\bf J}$ does not include
      ! Levenberg-Marquardt stabilization, and might or might not include
      ! Tikhonov regularization.  Start by computing the inverse transpose of
      ! the Cholesky factor of the normal equations, ${\bf U}^{-T}$, then
      ! $({\bf U}^T {\bf U})^{-1} = {\bf U}^{-1} {\bf U}^{-T} = ({\bf
      ! \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf J \Sigma}^T)^{-1}$. Then
      ! unscale it to ${\bf \Sigma}^T ({\bf \Sigma}^T {\bf J}^T {\bf
      ! S}_m^{-1} {\bf J \Sigma}^T)^{-1} {\bf \Sigma}^T$.
      if ( foundBetterState .and. ( got(f_outputCovariance) .or. got(f_outputSD) &
        & .or. got(f_average) .or. got(f_aprioriFraction) ) ) then
        if ( nwt_flag /= nf_getJ ) then
          print *, 'BUG in Retrieval module -- should need to getJ to quit'
          stop
        end if
          if ( d_cov ) then
            call time_now ( t3 )
            call output ( t3-t0, before='Begin covariance calculation at ', &
              & after=' seconds', advance='yes' )
            call output ( jacobian_rows, before='Counted ' )
            call output ( jacobian_cols, before=' rows and ', after=' columns' )
            call time_now ( t3 )
            call output ( t3-t0, before=' in the Jacobian matrix at ', &
              & after=' seconds', advance='yes' )
          end if
          call time_now ( t1 )
        if ( lambda /= 0 ) then
          ! Need to remove the Levenberg-Marquardt parameter from the diagonal
          ! of the normal equations.  Lambda is the last-used value.
          call updateDiagonal ( normalEquations, -lambda**2 )
          call choleskyFactor ( factored, normalEquations, status=matrixStatus )
            call add_to_retrieval_timing( 'cholesky_factor', t1 )
        end if
        ! We now have factored normal equations without the Levenberg-Marquardt
        ! parameter, and without Tiknonov regularization if CovSansReg was set.
        ! Invert the Cholesky factor to compute the a posteriori covariance
        ! matrix.
        call createEmptyMatrix ( tempU, 0, state, state )
        call invertCholesky ( factored, tempU ) ! U^{-1}
          if ( d_cov ) then
            call output ( &
              & 'Inverted the Cholesky factor of the normal equations at ' )
            call time_now ( t3 )
            call output ( t3-t0, advance='yes' )
          end if
        ! Scale the covariance
        if ( columnScaling /= l_none ) then
          call rowScale ( v(columnScaleVector), tempU )
            if ( d_cov ) then
              call time_now ( t3 )
              call output ( t3-t0, before='Scaled the Covariance matrix at ', &
                & after=' seconds', advance='yes' )
            end if
        end if
        preserveMatrixName = outputCovariance%m%name
        ! TempU is the inverse of the Cholesky factor of the normal equations,
        ! which is now the Cholesky factor of the covariance matrix.  Compute
        ! the covariance matrix from its Cholesky factor.
        call multiplyMatrix_XY_T ( tempU, tempU, outputCovariance%m, &
          & diagonalOnly = .not. any ( got ( (/ f_outputCovariance, f_average/) ) ) ) ! U^{-1} U^{-T}
          if ( d_cov ) then
            call output ( 'Computed ' )
            if ( .not. any ( got ( (/ f_outputCovariance, f_average /) ) ) ) &
              & call output ( 'diagonal blocks of ' )
            call time_now ( t3 )
            call output ( t3-t0, before='U^{-1} U^{-T} at ', after=' seconds', &
              & advance='yes' )
          end if
        call add_to_retrieval_timing( 'cholesky_invert', t1 )
        outputCovariance%m%name = preserveMatrixName
        if ( associated(outputSD) ) &
          & call GetDiagonal ( outputCovariance%m, outputSD, squareRoot=.true. )

        ! Deal with possibly setting the error bar negative
        if ( negateSD .or. associated(aprioriFraction) ) then
          ! We need to compute what just the a priori and regularization would
          ! give for the output covariance.
          ! Firstly, we need to do some gymnastics to avoid singular matrices.  This
          ! will happen with ptan terms that have neither a priori nor smoothing.
          ! Set these such that our answer is the same as the outputSD
          call cloneVector ( v(diagFlagA), state )
          call GetDiagonal ( aPlusRegNEQ%m, v(diagFlagA) )
          do qty = 1, v(diagFlagA)%template%noQuantities
            where ( v(diagFlagA)%quantities(qty)%values <= 0.0_rv )
              ! Choose a value to let it invert properly
              v(diagFlagA)%quantities(qty)%values = outputSD%quantities(qty)%values ** (-2)
            elsewhere
              v(diagFlagA)%quantities(qty)%values = 0.0_rv
            end where
          end do
          call UpdateDiagonal ( aPlusRegNEQ, v(diagFlagA) )

          ! Now decompose it
          call createEmptyMatrix ( tempC%m, &
            & enter_terminal('_tempC', t_identifier), &
            & state, state, .not. aPlusRegNEQ%m%row%instFirst, .not. aPlusRegNEQ%m%col%instFirst )
          call CholeskyFactor ( tempC, aPlusRegNEQ, status=matrixStatus )
          if ( any ( matrixStatus /= 0 ) ) then
            call MLSMessage ( MLSMSG_Error, 'aPlusRegNEQ', &
              & 'Non SPD matrix to be factored: aPlusRegNEQ' )
          end if

          call MultiplyMatrix_XY ( tempC%m, tempU, temp ) ! Can't do C := C * U

          call MultiplyMatrix_XY_T ( temp, temp, aPlusRegCov%m, diagonalOnly=.true. )

          ! Destroy works in progress
          call DestroyMatrix ( tempC%m )
          call DestroyMatrix ( temp )

          call cloneVector ( v(diagFlagB), state )
          call GetDiagonal ( aPlusRegcov%m, v(diagFlagB), squareRoot=.true. )
          ! Remove ones where we substituted aposteriori precision.
          do qty = 1, v(diagFlagA)%template%noQuantities
            where ( v(diagFlagA)%quantities(qty)%values /= 0.0_rv ) &
              & v(diagFlagB)%quantities(qty)%values = 0.0_rv
          end do
          if ( associated(aprioriFraction) ) &
            call copyVector ( aprioriFraction, v(diagFlagB) )

          if ( negateSD ) then
            ! Go through and set error bar negative if appropriate
            do qty = 1, v(diagFlagA)%template%noQuantities
              where ( v(diagFlagB)%quantities(qty)%values > precisionFactor ) &
                & outputSD%quantities(qty)%values = - outputSD%quantities(qty)%values
            end do
          end if
        end if ! ( negateSD .or. associated(aprioriFraction) )
        call DestroyMatrix ( tempU )
      end if

      !{Compute the averaging kernel = ${\bf S}_s {\bf K}^T {\bf K}$.
      if ( foundBetterState .and. got(f_average) ) then
        if ( extendedAverage ) then
          call ClearMatrix ( outputAverage )
          call MultiplyMatrix_XTY ( outputCovariance%m, kTkStar, outputAverage, update=.true. )
        else
          ! Make sure kTk is symmetrical
          !  (outputCovariance is by virtue of its creation method as U^T U)
          Call ReflectMatrix ( kTk%m )
          call ClearMatrix ( outputAverage )
          call MultiplyMatrix_XTY ( outputCovariance%m, ktk%m, outputAverage, update=.true. )
        end if
        if ( d_cov ) call output ( &
          & 'Computed the Averaging Kernel from the Covariance', advance='yes' )
      end if

      call copyVector ( state, v(x) )
      if ( d_svec ) call dump ( state, name='Final state' )
      ! Clean up the temporaries, so we don't have a memory leak.
      if ( got(f_fuzz) ) call destroyVectorInfo ( fuzzState )
      call destroyMatrix ( normalEquations%m )
      call destroyMatrix ( kTkSep%m )
      call destroyMatrix ( kTkStar )
      call destroyMatrix ( factored%m )
      call destroyVectorInfo ( q )
      call deallocate_test ( fmStat%rows, 'FmStat%rows', moduleName )
      call add_to_retrieval_timing( 'newton_solver', t1 )
      call trace_end ( 'Retrieve.NewtonSolver', cond=.false. )
    end subroutine NewtonSolver

    ! ---------------------------------------  NewtonSolverFailed  -----
    subroutine NewtonSolverFailed ( WHY, NWT_Flag, Prev_NWT_Flag, &
      & D_NDB, AJ )
      use DNWT_Module, only: NF_START, NWT_T
      character(len=*), intent(in) :: WHY      ! What failed
      integer, intent(inout) :: NWT_Flag       ! Solver's state flag
      integer, intent(inout) :: Prev_NWT_Flag  ! Solver's previous state
      integer, intent(in) :: D_NDB             ! dump AJ if d_ndb >= 2
      type (NWT_T), intent(in) :: AJ           ! Solver's database

!       block ! for abandoned chunk version, followed by EXIT NEWT
!         chunk%abandoned = .true.
!         call MLSMessage ( MLSMSG_Warning, ModuleName, &
!           & 'Retrieval abandoned due to ' // trim(why) )
!       end block
!     block ! for forced gradient move version, followed by CYCLE NEWT
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Gradient move forced due to ' // trim(why) )
        if ( d_ndb >= 2 ) call my_nwtdb ( aj, width=9, why='Failed' )
        prev_nwt_flag = nwt_flag
        nwt_flag = nf_start ! Force gradient move
!     end block
    end subroutine NewtonSolverFailed

    ! --------------------------------------------------  SayTime  -----
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for Retrieve = " )
      call output ( DBLE(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime

  end subroutine Retrieve

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: RetrievalModule.f90,v 2.367 2021/02/05 05:18:50 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module RetrievalModule

! $Log: RetrievalModule.f90,v $
! Revision 2.367  2021/02/05 05:18:50  pwagner
! Avoid calling NeuralNet when skipping Retrievals, too
!
! Revision 2.366  2021/01/22 00:21:10  pwagner
! Added NeuralNet command
!
! Revision 2.365  2020/07/17 19:38:52  vsnyder
! Check that FwdModelExtra exists if -Sfwmparallel is set
!
! Revision 2.364  2019/06/24 23:29:26  pwagner
! Updated to reflect TA-01-143
!
! Revision 2.363  2018/11/20 01:09:43  vsnyder
! Always pass AJ to My_NWTDB.  It's no longer optional to DNWTDB
!
! Revision 2.362  2018/09/13 20:23:49  pwagner
! Moved changeable options to new L2Options; added DumpOptions
!
! Revision 2.361  2018/08/28 20:50:10  vsnyder
! Don't print message about fnmin being negative if |fnmin| is small
!
! Revision 2.360  2018/07/27 23:19:53  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.359  2018/07/23 23:29:56  vsnyder
! Remove ChiSqMinNorm and ChiSqNorm from DNWT AJ structure because DNWT
! doesn't compute them or use them.
!
! Revision 2.358  2018/07/23 22:20:21  vsnyder
! Add AJ to all argument lists for nwt* so the options can be (eventually)
! stored there instead of as saved module variables.
!
! Revision 2.357  2017/12/07 01:01:23  vsnyder
! Don't use host-associated variable as a DO index
!
! Revision 2.356  2015/05/05 00:12:47  vsnyder
! Make sure 0 < mu <= 1 in BoundMove
!
! Revision 2.355  2014/09/30 02:15:19  vsnyder
! Don't put the Tikhonov matrix in the matrix database.  Add some commented-
! out stuff that might be useful if we turn on matrix finalizers.
!
! Revision 2.354  2014/09/29 20:17:52  vsnyder
! Fuse two IF constructs with identical conditions, some cannonball polishing
!
! Revision 2.353  2014/09/05 01:20:03  vsnyder
! Remove unused State argument from DumpStateQuantities.  Remove USE for
! unreferenced USE name.
!
! Revision 2.352  2014/09/05 00:49:07  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.351  2014/04/10 00:45:24  pwagner
! Moved currentChunkNumber, currentPhaseName from MLSL2Timings to MLSL2Options
!
! Revision 2.350  2014/03/01 03:10:56  vsnyder
! Move units checking to init_tables_module
!
! Revision 2.349  2014/02/28 01:14:04  vsnyder
! Remove TYPE argument from calls to EXPR because the value wasn't used.
! Move units checking to type checker.
!
! Revision 2.348  2014/01/23 23:16:37  vsnyder
! Back out Levenberg-Marquardt without getting a new Jacobiab
!
! Revision 2.347  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.346  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.345  2013/10/09 23:42:29  vsnyder
! Add Evaluate_Variable
!
! Revision 2.344  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.343  2013/09/04 02:50:05  vsnyder
! Add 'cond' argument in three calls to Trace_End
!
! Revision 2.342  2013/08/30 02:45:46  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.341  2013/08/03 00:40:42  vsnyder
! Require vector.quantity in dumpQuantities field in retrieve spec
!
! Revision 2.340  2013/07/26 22:41:44  vsnyder
! Fiddling with some dump switches
!
! Revision 2.339  2013/07/12 23:25:28  vsnyder
! Remove unreferenced error messages
!
! Revision 2.338  2013/06/12 02:38:50  vsnyder
! Cruft removal
!
! Revision 2.337  2013/04/24 00:37:42  pwagner
! Added InitRepeat and NextRepeat calls to set/increment r/t Boolean count
!
! Revision 2.336  2013/04/22 17:51:57  pwagner
! Reevaluate may store a literal instead of a Boolean value
!
! Revision 2.335  2013/04/17 00:05:25  pwagner
! Added new Repeat control structure to Fill, Retrieve sections
!
! Revision 2.334  2013/03/01 01:12:15  pwagner
! 'fiw' switch dumps sids instance window even if retrieval skipped
!
! Revision 2.333  2012/10/11 22:03:46  pwagner
! Fix timing error; print chunkNumber, phaseName instead of module when warning of abandoning
!
! Revision 2.332  2012/09/13 18:08:34  vsnyder
! Don't include tikhonov row count if covSansReg is set
!
! Revision 2.331  2012/09/12 22:51:40  vsnyder
! Tell DNWT what lambdaMin is
!
! Revision 2.330  2012/08/30 23:01:18  vsnyder
! Procedurize Tikhonov, add lambdaMin
!
! Revision 2.329  2012/08/16 18:07:23  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.328  2012/07/26 02:07:11  vsnyder
! Remove unused cruft
!
! Revision 2.327  2012/07/04 02:13:03  vsnyder
! Add dump of residuals.  Add dumpQuantities node to select quantities of
! the state vector to dump during the Newton iteration.  Remove masked rows
! and columns from the counts, to compute DOF correctly.
!
! Revision 2.326  2012/06/06 20:37:56  vsnyder
! Add toggles field to retrieve spec
!
! Revision 2.325  2012/05/08 17:50:52  pwagner
! Added Select .. Case .. EndSelect control structure
!
! Revision 2.324  2012/04/20 01:37:47  vsnyder
! Dump vector norms using dxn, copy mask from x to candidateDx, print DOF
! dump QNSQ if sca, some cannonball polishing
!
! Revision 2.323  2012/03/13 01:48:25  vsnyder
! Add drmc flag to control clean matrix printing
!
! Revision 2.322  2012/03/07 01:58:40  vsnyder
! Respect mask in some dot products where it should have done all along
!
! Revision 2.321  2012/02/10 23:46:24  vsnyder
! Add dump for kTk
!
! Revision 2.320  2012/02/01 00:18:38  vsnyder
! Remove Matrix from the Retrieve section; nobody used it, because it was broken.
!
! Revision 2.319  2012/02/01 00:17:07  vsnyder
! init_tables_module.f90
!
! Revision 2.318  2012/01/27 01:06:26  pwagner
! Tried to fix memory leak created by Hessian
!
! Revision 2.317  2012/01/04 02:14:55  vsnyder
! Ensure forward model does not see MIFExtinction
!
! Revision 2.316  2012/01/04 01:51:26  vsnyder
! Create fwmJacobian if needed and one isn't supplied
!
! Revision 2.315  2011/12/21 01:42:22  vsnyder
! Add MIFExtinction transformation
!
! Revision 2.314  2011/08/29 22:13:42  pwagner
! Predefine Hessian object in parallel with Jacobian matrix
!
! Revision 2.313  2011/05/09 18:24:31  pwagner
! Converted to using switchDetail
!
! Revision 2.312  2010/08/27 23:59:36  vsnyder
! Removed some overly long comments that duplicate the CVS log anyway
!
! Revision 2.311  2010/08/27 06:31:45  yanovsky
! Added   type(hessian_T), pointer :: Hessian  in Retrieve subroutine.
! Hessian is an actual argument in a call to forwardModel.
!
! Revision 2.309  2010/03/24 20:56:46  vsnyder
! Add Hessian database to DumpBlocks call
!
! Revision 2.308  2010/02/25 18:19:27  pwagner
! Adds support for new Hessian database
!
! Revision 2.307  2009/11/23 21:10:18  vsnyder
! Gradiant move instead of abandonment when trouble occurs
!
! Revision 2.306  2009/10/26 17:12:39  pwagner
! Added Diff command to be used like Dump in l2cf
!
! Revision 2.305  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.304  2009/06/16 17:40:02  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.303  2009/03/14 02:43:19  honghanh
! Add dnwt_abandoned and dnwt_count
!
! Revision 2.302  2008/12/18 21:13:05  pwagner
! May now dump an l2pc or allL2PCs (use with caution)
!
! Revision 2.301  2007/12/07 01:14:03  pwagner
! Lets us catch warnings and assign to runtime Booleans
!
! Revision 2.300  2007/11/15 22:53:16  pwagner
! May set runtimeBooleans by anyGood.., Compare, Reevaluate commands
!
! Revision 2.299  2007/11/08 03:24:39  vsnyder
! Add stateMax and stateMin
!
! Revision 2.298  2007/11/05 18:37:19  pwagner
! May Skip remaining lines in Fill, Join, Retrieve sections depending on Boolean
!
! Revision 2.297  2007/10/04 20:43:12  vsnyder
! Remove unused symbols
!
! Revision 2.296  2007/10/04 01:49:42  vsnyder
! Correct a string's misspelling
!
! Revision 2.295  2007/10/02 22:51:27  vsnyder
! Put switches field value into global switches variable so the models can
! see them, then clear them at the end so they don't stick around.
!
! Revision 2.294  2007/09/12 00:17:05  vsnyder
! Simplify printing when Cholesky fails
!
! Revision 2.293  2007/09/08 00:31:49  vsnyder
! Be more careful before printing name of failed Cholesky block
!
! Revision 2.292  2007/09/06 00:36:51  vsnyder
! More information about failed Cholesky
!
! Revision 2.291  2007/08/20 22:05:30  pwagner
! Many procedures now push their names onto MLSCallStack
!
! Revision 2.290  2007/06/29 19:32:07  vsnyder
! Make ForwardModelIntermediate_t private to ScanModelModule
!
! Revision 2.289  2007/04/03 17:47:14  vsnyder
! Replace pointer attribute on VectorDatabase with target attribute
!
! Revision 2.288  2007/02/28 23:27:51  vsnyder
! Replace FORALL by DO, since FORALL sometimes causes compilers to have trouble
!
! Revision 2.287  2006/12/09 00:45:35  vsnyder
! Move calculation of size of Jacobian, so that ChiSqMin calculation works
! correctly if zero Newton iterations are allowed.
!
! Revision 2.286  2006/10/04 22:52:48  vsnyder
! Another change from Herb:  Make Apriori fraction zero where we had to
! substitute aposteriori precision to calculate the apriori fraction.
!
! Revision 2.285  2006/10/04 19:39:38  vsnyder
! Correct negateSD as recommended by Herb
!
! Revision 2.284  2006/09/21 18:51:14  pwagner
! Reduce level of dumps in SIDS version
!
! Revision 2.283  2006/09/20 00:43:38  vsnyder
! Implemented Herb's apriori fraction calculation
!
! Revision 2.282  2006/08/11 20:58:38  vsnyder
! Add 'simple' method to use alternate Newton solver
!
! Revision 2.281  2006/08/04 18:11:33  vsnyder
! Add LeakCheck command
!
! Revision 2.280  2006/08/01 02:48:33  vsnyder
! Remove unused USE for .TX.
!
! Revision 2.279  2006/07/21 20:13:29  pwagner
! Can fill state even if skipping retrievals
!
! Revision 2.278  2006/07/19 22:28:59  vsnyder
! Cannonball polishing
!
! Revision 2.277  2006/06/08 23:59:46  vsnyder
! Simplify column scaling, add switches field, TeXnicalities
!
! Revision 2.276  2006/06/06 18:54:21  vsnyder
! Sharpen criteria for fresh Jacobian at the end
!
! Revision 2.275  2006/06/06 00:51:23  vsnyder
! Move diagnostic output from NEWX to DX, DX_Aitken, and GMOVE
!
! Revision 2.274  2006/06/06 00:31:20  vsnyder
! Add more diagnostic output
!
! Revision 2.273  2006/06/03 01:04:59  vsnyder
! Cannonball polishing
!
! Revision 2.272  2006/06/03 00:15:20  vsnyder
! Correct updating of Levenberg-Marquardt parameter during More' and
! Sorensen iteration.  Polish up some dumps.
!
! Revision 2.271  2006/05/31 18:22:26  pwagner
! Fixed bug only NAG complained about: needed Dump from MatrixModule_0
!
! Revision 2.270  2006/05/30 22:51:21  vsnyder
! Precompute dump flags.  Add NumGrad and NumNewt counters.  Compute
! cosine of angles between moves correctly for printing (it's already
! done correctly inside dnwt_module).
!
! Revision 2.269  2006/03/30 19:00:50  vsnyder
! Correct CVS log comment
!
! Revision 2.268  2006/03/30 18:57:01  vsnyder
! Correct some TeXnicalities
!
! Revision 2.267  2006/03/22 23:47:14  vsnyder
! Decruftification
!
! Revision 2.266  2006/02/10 21:17:09  pwagner
! dumps may go to special dumpfile
!
! Revision 2.265  2006/01/21 00:04:14  livesey
! Added the start of a dump retrieval config option (-Srtv)
!
! Revision 2.264  2005/12/21 21:48:03  livesey
! Added handling of the negateSD option.
!
! Revision 2.263  2005/06/03 02:09:46  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades
!
! Revision 2.262  2005/05/27 23:57:03  vsnyder
! Add Flush PFAData
!
! Revision 2.261  2005/03/15 01:27:58  vsnyder
! Allow Dump command in Retrieve section
!
! Revision 2.260  2004/06/16 23:41:39  vsnyder
! Put a limit on the total number of DNWT iterations, regardless of Jacobians
!
! Revision 2.259  2004/06/16 01:21:57  vsnyder
! Repair bug in constrained move
!
! Revision 2.258  2004/06/16 00:01:36  livesey
! Bug fixes to BoundMove
!
! Revision 2.257  2004/05/19 19:16:12  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.256  2004/04/19 23:25:55  livesey
! Added an only to the use of ieee_arithemtic
!
! Revision 2.255  2004/04/19 19:23:44  livesey
! Better handling of NaNs in radiances or derivatives
!
! Revision 2.254  2004/01/29 01:45:32  livesey
! Removed print statement
!
! Revision 2.253  2004/01/24 03:22:49  livesey
! Changed logistics of computing averaging kernel to preserve vectors that
! describe edges.
!
! Revision 2.252  2003/10/07 01:17:52  vsnyder
! Change spelling of dumpBlock to dumpBlocks
!
! Revision 2.251  2003/09/11 23:16:11  livesey
! Now hands vector database onto forward model to support xStar/yStar in
! linearized forward model.
!
! Revision 2.250  2003/09/05 23:24:09  pwagner
! Skips calls to Retrieve, SIDS if SKIPRETRIEVAL
!
! Revision 2.249  2003/07/09 23:49:13  vsnyder
! Remove numerous unreferenced USE names
!
! Revision 2.248  2003/06/20 19:38:26  pwagner
! Allows direct writing of output products
!
! Revision 2.247  2003/06/03 19:24:19  livesey
! Added the abandoned stuff to make the chunk processing more robust.
!
! Revision 2.246  2003/05/14 23:40:51  dwu
! a change in cloud retr
!
! Revision 2.245  2003/05/14 23:38:15  dwu
! change in cloud retrieval
!
! Revision 2.244  2003/05/14 03:55:10  dwu
! tidy up
!
! Revision 2.243  2003/05/13 22:25:39  dwu
! changes in lowcloudretrieval
!
! Revision 2.242  2003/05/13 20:43:05  dwu
! a quick fix after spinout
!
! Revision 2.241  2003/05/13 19:32:28  dwu
! spin out cloud retrievals
!
! Revision 2.240  2003/04/04 22:02:06  livesey
! Added call to UpdateMask
!
! Revision 2.239  2003/03/27 20:45:22  livesey
! Reinstated the fnorm dumping which seemed to fall by the wayside
! for some reason.
!
! Revision 2.238  2003/03/07 03:17:03  livesey
! Added Restrict Range
!
! Revision 2.237  2003/03/06 00:46:41  livesey
! Now gets subset etc. from subsetmodule
!
! Revision 2.236  2003/02/25 21:12:48  dwu
!  clean up FlagCloud
!
! Revision 2.235  2003/02/25 19:04:43  dwu
! fix another bug in FlagCloud
!
! Revision 2.234  2003/02/25 18:58:35  dwu
! fix another bug in FlagCloud
!
! Revision 2.233  2003/02/24 19:20:40  dwu
! fix a bug in FlagCloud
!
! Revision 2.232  2003/02/14 01:56:36  livesey
! Added the 'additional' capability in subset
!
! Revision 2.231  2003/02/12 02:11:13  livesey
! New code for extended averaging kernels
!
! Revision 2.230  2003/02/08 00:20:25  livesey
! Added error message to check that the right ptan (GHz/THz) is used in
! subset statements.
!
! Revision 2.229  2003/02/05 20:59:16  dwu
! an improvement in flagcloud
!
! Revision 2.228  2003/02/05 04:07:05  dwu
! add cloudheight option for flagcloud
!
! Revision 2.227  2003/02/03 23:08:50  vsnyder
! Delete test for small residual -- there's a test relative to FNMIN in
! dnwt.  Add stuff for dnwt to use Mor\'e and Sorensen algorithm to
! compute the Levenberg parameter.
!
! Revision 2.225  2003/01/18 02:15:43  vsnyder
! Change names of global loop inductors "I" and "J" to something more clever,
! i.e., I_Sons and I_Key.  It's too easy to use "I" and "J" in internal
! procedures, thereby clobbering the important values of these loop
! inductors.
!
! Revision 2.224  2003/01/18 01:40:10  vsnyder
! Prepare for More and Sorensen
!
! Revision 2.223  2003/01/17 22:59:47  livesey
! Minor bug fix in units checking for max/minValue in subset.
!
! Revision 2.222  2003/01/17 22:13:46  dwu
! fix a bug in flagCloud
!
! Revision 2.221  2003/01/17 16:55:19  dwu
! a minor change in FlagCloud
!
! Revision 2.220  2003/01/16 21:48:22  vsnyder
! More stuff on getting NWTA internal output
!
! Revision 2.219  2003/01/16 04:06:58  vsnyder
! Change some output in DNWT
!
! Revision 2.218  2003/01/15 01:49:29  vsnyder
! Revise dumping stuff for Newton method
!
! Revision 2.217  2003/01/14 22:14:43  dwu
! make FlagCloud depend on both channels and cloudChannels
!
! Revision 2.216  2003/01/13 17:17:29  jonathan
!  change cloud_width to i_saturation
!
! Revision 2.215  2003/01/12 07:33:42  dwu
! with some fix in flagcloud
!
! Revision 2.214  2003/01/11 15:51:34  dwu
! follow-up fix for FlagCloud
!
! Revision 2.213  2003/01/11 08:08:01  dwu
! add flagCloud
!
! Revision 2.212  2003/01/11 02:14:55  livesey
! Bug fix in max/min value subset
!
! Revision 2.211  2003/01/11 01:02:50  livesey
! Added max and min value to subset
!
! Revision 2.210  2003/01/08 23:52:38  livesey
! Added the sparsify stuff according to sparseQuantities
!
! Revision 2.209  2003/01/07 23:44:17  livesey
! Added reset option to subset
!
! Revision 2.208  2002/12/11 01:58:54  livesey
! Changed detail of forward model parallel stuff
!
! Revision 2.207  2002/12/06 18:41:24  livesey
! Slightly new approach to FWMParallel mode
!
! Revision 2.206  2002/11/23 00:07:13  vsnyder
! Delete some unused symbols
!
! Revision 2.205  2002/11/22 00:11:16  livesey
! Better handling of foundBetterState
!
! Revision 2.204  2002/11/20 21:05:55  livesey
! More informative dump for Tikhonov
!
! Revision 2.203  2002/11/20 01:10:03  livesey
! Added the foundBetterState stuff
!
! Revision 2.202  2002/10/29 20:51:27  livesey
! Moved call to FillDiagVec
!
! Revision 2.201  2002/10/25 23:56:04  livesey
! Bug fix in the diagnostics
!
! Revision 2.200  2002/10/25 22:24:42  livesey
! Changed the diagnostic vector handling.
!
! Revision 2.199  2002/10/25 01:13:46  livesey
! Jacobian rows/cols etc. now actually describe the jacobian.
!
! Revision 2.198  2002/10/23 23:27:40  livesey
! Bug fix in jacobian_rows calculation
!
! Revision 2.197  2002/10/23 01:32:31  vsnyder
! Add CovSansReg switch to retrieve spec
!
! Revision 2.196  2002/10/23 01:14:41  livesey
! Added the chiSquared stuff, needs more work though.
!
! Revision 2.195  2002/10/19 23:41:04  livesey
! Added muMin functionality
!
! Revision 2.194  2002/10/19 18:49:17  livesey
! Various bug fixes in bounds stuff
!
! Revision 2.193  2002/10/19 01:52:21  livesey
! Added serial option and associated flags.
!
! Revision 2.192  2002/10/18 22:05:42  vsnyder
! Get in bounds before starting.  Account for scaling when bounding a move.
!
! Revision 2.191  2002/10/17 23:12:51  vsnyder
! Apply bounds to gradient and Aitken moves
!
! Revision 2.190  2002/10/17 00:16:40  vsnyder
! Add lowBound and highBound fields for the Retrieve spec
!
! Revision 2.189  2002/10/08 17:41:38  livesey
! Bug fixes in FWMParallel stuff
!
! Revision 2.188  2002/10/08 17:36:22  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.187  2002/10/06 02:04:57  livesey
! Put in fwmParallel functionality
!
! Revision 2.186  2002/09/25 20:08:43  livesey
! Made subset -g less verbose
!
! Revision 2.185  2002/09/23 23:15:08  vsnyder
! Delete maxF
!
! Revision 2.184  2002/09/23 20:21:21  livesey
! Now copies mask from f_rowScaled to f.  Only important for snooping.
!
! Revision 2.183  2002/09/21 00:33:34  vsnyder
! Don't take a getJ iteration if TOLF convergence occurs
!
! Revision 2.182  2002/09/21 00:04:14  vsnyder
! Put back an erroneously-removed timing call
!
! Revision 2.181  2002/09/19 01:26:46  vsnyder
! Mostly fixing up comments and LaTeX stuff
!
! Revision 2.180  2002/09/18 23:56:01  vsnyder
! Call time_now at end of add_to_retrieval_timing
!
! Revision 2.179  2002/09/14 02:46:30  vsnyder
! Add NDB switch to get DNWT output every return
!
! Revision 2.178  2002/09/14 00:37:37  vsnyder
! More stuff on subsuming EVALF into EVALJ properly
!
! Revision 2.177  2002/09/13 23:55:01  livesey
! Changed print statements
!
! Revision 2.176  2002/09/13 20:05:06  vsnyder
! Subsume EVALF into EVALJ
!
! Revision 2.175  2002/09/13 18:10:10  pwagner
! May change matrix precision rm from r8
!
! Revision 2.174  2002/09/11 20:21:49  livesey
! Made second | F | print on GETJ not EVALJ
!
! Revision 2.173  2002/09/11 17:40:59  livesey
! Changed meaning of v(f)
!
! Revision 2.172  2002/09/11 14:06:42  livesey
! Bug fix, misunderstood meaning of v(f)
!
! Revision 2.171  2002/09/11 01:14:47  livesey
! Added extra dump of | F |
!
! Revision 2.170  2002/09/06 00:46:18  livesey
! Added dump of aTb
!
! Revision 2.169  2002/09/05 23:08:22  livesey
! Gradient move handles mask 'correctly', though we might have been right
! from a philosophical point of view earlier.
!
! Revision 2.168  2002/08/29 04:45:37  livesey
! Sped up covariance calculations
!
! Revision 2.167  2002/08/28 00:51:04  vsnyder
! Correct more blunders in Tikhonov regularization
!
! Revision 2.166  2002/08/26 20:01:59  livesey
! Made subset us the GetIndexFlagsFromList routine to get channel flags
!
! Revision 2.165  2002/08/24 01:38:28  vsnyder
! Implement horizontal regularization
!
! Revision 2.164  2002/08/22 00:06:50  vsnyder
! Implement regularize-to-apriori
!
! Revision 2.163  2002/08/21 19:55:31  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.162  2002/08/20 19:55:02  vsnyder
! Use matrix with same row and column templates for Tikhonov
!
! Revision 2.161  2002/08/08 22:02:52  vsnyder
! Add hRegWeightVec and Tikhonov mask
!
! Revision 2.160  2002/08/06 02:16:09  livesey
! Fixed averaging kernels by reflecting the kTk matrix
!
! Revision 2.159  2002/08/05 19:40:11  vsnyder
! Undo scaling of kTk -- it's prepared unscaled
!
! Revision 2.158  2002/08/03 20:40:58  livesey
! Added matrix name preseveration.  Changed averaging kernel calculation.  Still
! not right though!
!
! Revision 2.157  2002/08/03 01:16:17  vsnyder
! RegAfter switch controls Tikhonov before/after column scaling -- default before
!
! Revision 2.156  2002/07/31 22:43:30  vsnyder
! Add some timers in the Newtonian iteration
!
! Revision 2.155  2002/07/26 22:47:56  vsnyder
! Only do DNWT internal output after NF_SOLVE and at the end.
! Finish commenting-out FNMIN calculation when NWT_FLAG = NF_SOLVE
!
! Revision 2.154  2002/07/26 01:20:22  vsnyder
! Exploit added output from DNWTDB, get rid of bogus Levenberg at start
!
! Revision 2.153  2002/07/24 01:08:40  vsnyder
! Don't compute FNMIN at NF_SOLVE time -- it should be the same as at NF_EVALJ
!
! Revision 2.152  2002/07/22 23:14:28  pwagner
! Fixed some bugs in timings (there may be more)
!
! Revision 2.151  2002/07/22 22:53:42  pwagner
! Added form norm eq and tikh reg timings
!
! Revision 2.150  2002/07/08 21:05:09  vsnyder
! Make sure "Best X" has a value even if no Newtonian iterations are done.
! Mark Filipiak noticed this problem.
!
! Revision 2.149  2002/07/04 00:34:55  vsnyder
! Make aprioriMinusX apriori - x instead of -x
!
! Revision 2.148  2002/07/02 01:38:06  vsnyder
! Quit if a a retrieve can't be done due to L2CF errors
!
! Revision 2.147  2002/07/01 23:43:17  vsnyder
! Plug some memory leaks
!
! Revision 2.146  2002/06/25 20:45:31  vsnyder
! DestroyVectorValue should have been ClearVector in the case that there is
! no apriori covariance.
!
! Revision 2.145  2002/06/18 01:19:52  vsnyder
! Cosmetic changes
!
! Revision 2.144  2002/06/07 01:34:26  vsnyder
! Create temp matrix used in covariance calculation
!
! Revision 2.143  2002/05/22 19:16:51  vsnyder
! Put the correct number of rows used for Tikhonov regularization into the
! diagnostics vector.
!
! Revision 2.142  2002/05/22 19:00:38  vsnyder
! Correct covariance calculation -- it ought to be U^{-1} U^{-T}, not U^{-1}.
! Mark Filipiak noticed this bug.
!
! Revision 2.141  2002/05/07 01:02:24  vsnyder
! Change regWeight to hRegWeights -- which is now a tree node instead of
! a real scalar.  Add dump for regularization matrix.
!
! Revision 2.140  2002/04/22 23:00:58  vsnyder
! Add SquareRoot=.true. to getDiagonal for standard deviation
!
! Revision 2.139  2002/04/22 20:55:00  vsnyder
! Compute and output the averaging kernel
!
! Revision 2.138  2002/03/13 22:01:50  livesey
! Changed explicitFill to fill
!
! Revision 2.137  2002/03/08 08:07:16  livesey
! Added explicit fill mask
!
! Revision 2.136  2002/03/06 01:44:30  livesey
! Changed manner in which optical depth cutoff applied so that
! once a channel is too optically thick it always is (as a function of
! height).  Note it's resistant to changes in scan direction.
!
! Revision 2.135  2002/02/14 21:55:31  vsnyder
! Account for mask.  Get a final Jacobian using Best X.  Cosmetic changes.
!
! Revision 2.134  2002/02/13 00:11:13  vsnyder
! Test fnmin both places it's formed
!
! Revision 2.133  2002/02/12 22:53:21  vsnyder
! Update a bunch of comments
!
! Revision 2.132  2002/02/09 19:11:34  livesey
! Modified subset to add optical depth cutoffs
!
! Revision 2.131  2002/02/08 22:51:59  livesey
! Added call to CopyVectorMask to transfer mask from measurements to forward
! model.
!
! Revision 2.130  2002/02/07 02:55:02  vsnyder
! Add a 'mask' field to the 'setup' spec
!
! Revision 2.129  2002/02/05 02:40:52  vsnyder
! Use 'dumpMask' instead of 'dump' to dump the mask, cosmetic changes
!
! Revision 2.128  2002/01/18 00:31:23  livesey
! Changed error message about fnmin being imaginary to warning and put
! in a work around.  I want to see what it's doing.
!
! Revision 2.127  2001/12/03 18:50:43  pwagner
! NAG compiler mad at '/ =' instead of '/='
!
! Revision 2.126  2001/12/01 01:01:56  livesey
! Added vir switch
!
! Revision 2.125  2001/11/28 23:16:39  livesey
! Added use of MLSMSG_Warning, whoops!
!
! Revision 2.124  2001/11/28 20:39:35  livesey
! Fixed bug with subset, changed some of Dong's prints to MLSMessage's
!
! Revision 2.123  2001/11/28 18:28:50  livesey
! Updated subset to include open ranges in height specification.
! There is possibly a bug in Van's version I'll point out to him
! (if not my version has the opposite bug).
!
! Revision 2.122  2001/11/28 00:01:27  jonathan
! remove type (VectorValue_T), pointer :: Re
!
! Revision 2.121  2001/11/27 23:49:48  jonathan
! remove Re in HighCloudRetrieval
!
! Revision 2.120  2001/11/27 23:34:49  pwagner
! Split forward model timings into four types
!
! Revision 2.119  2001/11/27 01:28:17  vsnyder
! Implement (partially) open range for channels in subset
!
! Revision 2.118  2001/11/17 02:30:44  vsnyder
! Add L_numF and L_numJ to 'diagnostics' vector
!
! Revision 2.117  2001/11/13 23:35:12  vsnyder
! Keep f and f_rowScaled separate in EVALF case
!
! Revision 2.116  2001/11/12 18:25:02  dwu
! speed up some cloud calculations
!
! Revision 2.115  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.114  2001/11/08 01:21:45  vsnyder
! Make sure phaseName has a value
!
! Revision 2.113  2001/11/07 23:55:43  dwu
! added option to constain cloud top height
!
! Revision 2.112  2001/11/06 18:04:11  dwu
! first working version of HighCloudRetrieval
!
! Revision 2.111  2001/11/02 01:11:45  dwu
! a test for highcloudretrieval
!
! Revision 2.110  2001/11/01 19:29:01  dwu
! corrections in cloud retrievals
!
! Revision 2.109  2001/10/31 21:59:56  livesey
! Added phaseName to snooper
!
! Revision 2.108  2001/10/30 16:57:43  dwu
! fixed a bug in LowCloudREtrieval
!
! Revision 2.107  2001/10/26 20:28:42  dwu
! Added cloud extinction SD and high cloud retrieval
!
! Revision 2.106  2001/10/24 00:29:00  livesey
! Added Matrix snooping
!
! Revision 2.105  2001/10/23 20:08:59  vsnyder
! Scale the RHS of apriori equations by aprioriScale too!
! Cosmetic changes -- LaTeX comments about how Tikhonov and apriori work.
!
! Revision 2.104  2001/10/22 22:40:21  livesey
! Tried to add a matrixDatabase to snoop call
!
! Revision 2.103  2001/10/22 22:34:47  dwu
! oops
!
! Revision 2.102  2001/10/22 22:25:17  dwu
! prepare for high cloud retrieval
!
! Revision 2.101  2001/10/22 20:52:00  dwu
! renaming some cloud functions
!
! Revision 2.100  2001/10/20 17:50:48  livesey
! A little more information on aj%fnmin < 0.0
!
! Revision 2.99  2001/10/19 17:42:36  dwu
! add protection for cloud sensitivity from going to zero
!
! Revision 2.98  2001/10/18 23:25:13  dwu
! rename FillQuantityFromLos to BinFromLOS2Grid
!
! Revision 2.97  2001/10/17 23:37:29  pwagner
! Improved dump of mask
!
! Revision 2.96  2001/10/17 20:50:30  dwu
! a fix of cloud retrieval
!
! Revision 2.95  2001/10/17 19:52:43  dwu
! Add standard deviation calculation to LowCloudRetrieval
!
! Revision 2.94  2001/10/16 23:35:39  pwagner
! More dumped on msk switch
!
! Revision 2.93  2001/10/15 23:21:47  vsnyder
! Forgot to clone AprioriMinusX after changing multiply not to clone
!
! Revision 2.92  2001/10/15 22:41:11  vsnyder
! Put the local (non-l2cf) vectors into a private database of fixed size,
! for snooping.  We can't copy them in, because it's a shallow copy, and
! we change some pointers later.
!
! Revision 2.91  2001/10/11 16:28:25  dwu
! Add cloudretrieval method for low tangent height radiances
!
! Revision 2.90  2001/10/09 20:39:36  vsnyder
! Left out a blank on the CVS command line, botched the last comment
!
! Revision 2.89  2001/10/09 20:38:23  vsnyder
! Corrections for regularization; output f, not f-measurements
!
! Revision 2.88  2001/10/05 20:50:16  vsnyder
! Concatenate Snoop comment and DNWT flag; clear F before EVAL[FJ]
!
! Revision 2.87  2001/10/05 20:20:16  vsnyder
! Put Nwt_Flag into Snoop's comment; add Dnwt_Flag to diagnostics vector
!
! Revision 2.86  2001/10/05 05:02:27  dwu
! temporarily set p_lowcut in LowCloud Retrieval
!
! Revision 2.85  2001/10/05 01:46:25  vsnyder
! Put in stuff to snoop in the Newtonian iteration loop
!
! Revision 2.84  2001/10/04 01:48:59  vsnyder
! Move temporary vectors into 'myVectors' database, for snooping
!
! Revision 2.83  2001/10/04 00:30:34  dwu
! fix coljBlock finding in Low Cloud
!
! Revision 2.82  2001/10/03 23:56:30  dwu
! some minor fixes for Low Cloud
!
! Revision 2.81  2001/10/03 22:05:12  dwu
! some quick remedies for LowcloudRetrieval
!
! Revision 2.80  2001/10/03 21:49:54  dwu
! some quick remedies for LowcloudRetrieval
!
! Revision 2.79  2001/10/03 21:30:16  dwu
! add LowCloudRetrieval
!
! Revision 2.78  2001/10/03 17:57:21  vsnyder
! Delete l_DegreesOfFreedom, add l-DNWT_...
!
! Revision 2.77  2001/10/02 23:41:11  vsnyder
! Added computation of degrees of freedom, diagnostics vector
!
! Revision 2.76  2001/10/02 16:49:56  livesey
! Removed fmStat%finished and change loop ordering in forward models
!
! Revision 2.75  2001/10/01 23:30:50  pwagner
! Fixed bug in spelling cholesky_solver
!
! Revision 2.74  2001/10/01 23:04:17  livesey
! Bug fix with channel range, and some tidying up
!
! Revision 2.73  2001/10/01 22:54:22  pwagner
! Added subsection timings for Retrieval section
!
! Revision 2.72  2001/10/01 20:30:48  vsnyder
! Insert a reminder for necessary future work
!
! Revision 2.71  2001/09/29 00:07:11  pwagner
! Fixed various timing problems
!
! Revision 2.70  2001/09/28 18:25:37  dwu
! prepare for adding lowcloud retrieval method
!
! Revision 2.69  2001/09/28 17:50:30  pwagner
! MLSL2Timings module keeps timing info
!
! Revision 2.68  2001/09/27 20:14:50  vsnyder
! Add 'msk' switch to control printing the mask after a Subset
!
! Revision 2.67  2001/09/27 18:40:26  vsnyder
! Explicitly control mask use for FormNormalEquations
!
! Revision 2.66  2001/09/26 02:15:40  vsnyder
! More work on checking the Subset command
!
! Revision 2.65  2001/09/25 23:04:30  livesey
! Fixed uninitialised heightUnit
!
! Revision 2.64  2001/09/25 20:42:55  vsnyder
! Spiffify error processing for Subset
!
! Revision 2.63  2001/09/25 17:49:59  livesey
! More updates, and fixes to subset
!
! Revision 2.62  2001/09/25 05:57:36  livesey
! Removed call to destroyVectorMask, and the erroneous .not. doThis
!
! Revision 2.61  2001/09/25 00:49:59  vsnyder
! Copy mask from measurements to f_rowScaled
!
! Revision 2.60  2001/09/25 00:18:36  livesey
! Bug fix in Subset
!
! Revision 2.59  2001/09/20 00:31:06  vsnyder
! Move deallocation of 'channels' out of loop
!
! Revision 2.58  2001/07/19 22:00:41  vsnyder
! orrect problems with row scaling.
!
! Revision 2.57  2001/07/12 22:18:05  livesey
! Got rid of an old diagnostic
!
! Revision 2.56  2001/07/12 22:11:46  vsnyder
! Maybe the column scaling is right now....
!
! Revision 2.55  2001/07/11 22:06:31  vsnyder
! Interim commit -- still appears to be broken
!
! Revision 2.54  2001/07/02 17:21:48  livesey
! Fixed memory leak with channels.
!
! Revision 2.53  2001/06/30 03:10:35  vsnyder
! Don't access sub_rosa(0) when creating a covariance matrix
!
! Revision 2.52  2001/06/30 03:07:43  vsnyder
! Remove some unused variables.  Move some more internal-subroutine-peculiar
! USEs into them.  Don't access sub_rosa(0) when creating a Jacobian.
!
! Revision 2.51  2001/06/30 02:35:43  vsnyder
! Don't use the "extra" column to solve for the residual.  Move the Newtonian
! solver, and its variables and USEs, into an internal subroutine.  Move USEs
! peculiar to SetupSubset into that routine.
!
! Revision 2.50  2001/06/27 04:31:29  livesey
! Subset is getting closer bit by bit.
!
! Revision 2.49  2001/06/27 04:05:32  livesey
! Interim version with known problems in subset
!
! Revision 2.48  2001/06/26 20:11:32  livesey
! Bug fixes to subset (more to come I imagine)
!
! Revision 2.47  2001/06/26 19:01:00  vsnyder
! Specify regularization orders according to quantities
!
! Revision 2.46  2001/06/26 18:18:14  livesey
! Another (working?) version.
!
! Revision 2.45  2001/06/26 17:57:46  livesey
! Whoops, added another use clause
!
! Revision 2.44  2001/06/26 16:26:32  livesey
! It at least compiles, but subset certainly doesn't work yet.
!
! Revision 2.43  2001/06/22 01:26:54  vsnyder
! Process fields for regularization, but regularization isn't done yet
!
! Revision 2.42  2001/06/20 22:21:22  vsnyder
! Added initialization for fmStat%newScanHydros
!
! Revision 2.41  2001/06/20 21:44:33  vsnyder
! Don't compute cosines between zero-length vectors
!
! Revision 2.40  2001/06/01 22:26:03  vsnyder
! Got the row scaling backwards in the NF_EVALF
!
! Revision 2.39  2001/06/01 21:58:17  livesey
! Added scale for outputSD.
!
! Revision 2.38  2001/06/01 21:40:18  vsnyder
! Row scale during NF_EVALF; destroy some vectors so as not to have a
! memory leak; initially clone x to get columnScaleVector.
!
! Revision 2.37  2001/06/01 21:27:48  livesey
! Added outSD field
!
! Revision 2.36  2001/06/01 20:36:34  vsnyder
! Seems to work.  Added LaTeX comments.
!
! Revision 2.35  2001/06/01 01:02:32  vsnyder
! Periodic commit.  Not working right yet.
!
! Revision 2.34  2001/05/24 23:28:45  vsnyder
! Scale things back to user coordinates at the correct times; numerous output changes
!
! Revision 2.33  2001/05/22 19:10:59  vsnyder
! Periodic commit; still isn't accepting a Newton step
!
! Revision 2.32  2001/05/19 01:17:39  vsnyder
! Correct sign of (apriori-x)
!
! Revision 2.31  2001/05/19 00:22:31  vsnyder
! Dump_L1 -> Dump_Linf, uncouple 'spa' and Linf dumps
!
! Revision 2.30  2001/05/18 23:18:42  vsnyder
! Replace 'weight' field of 'retrieve' by 'measurementSD'
!
! Revision 2.29  2001/05/18 19:46:23  vsnyder
! Add secret 'fuzz' field to 'retrieve' command -- for testing
!
! Revision 2.28  2001/05/18 01:04:08  vsnyder
! Periodic commit -- tons of stuff changed
!
! Revision 2.27  2001/05/10 22:50:45  vsnyder
! Added switches to print stuff during Newton iteration
!
! Revision 2.26  2001/05/03 02:00:15  vsnyder
! Put names on cloned vectors
!
! Revision 2.25  2001/05/02 05:28:04  livesey
! Added DumpBlocks
!
! Revision 2.24  2001/05/01 23:52:04  vsnyder
! Allocate and deallocate fmStat%rows here
!
! Revision 2.23  2001/04/28 01:47:17  vsnyder
! Don't try to create initial value for state
!
! Revision 2.22  2001/04/26 23:43:23  vsnyder
! Remove forwardModelIn from retrieve spec
!
! Revision 2.21  2001/04/26 19:48:20  livesey
! Now uses ForwardModelWrappers
!
! Revision 2.20  2001/04/26 02:53:37  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.19  2001/04/26 01:04:21  vsnyder
! Copy model's final radiance to fwdModelOut
!
! Revision 2.18  2001/04/26 01:00:01  vsnyder
! Get the Jacobian's row block from fmStat%rows, cosmetic changes
!
! Revision 2.17  2001/04/21 01:44:43  vsnyder
! Make the timing message prettier
!
! Revision 2.16  2001/04/19 23:56:23  livesey
! New fmStat
!
! Revision 2.15  2001/04/13 21:40:58  vsnyder
! Periodic commit -- stuff about looping over configs
!
! Revision 2.14  2001/04/12 01:50:21  vsnyder
! Work on getting a posteriori covariance
!
! Revision 2.13  2001/04/10 02:46:17  livesey
! Working version, no more FMI/TFMI
!
! Revision 2.12  2001/04/07 01:50:48  vsnyder
! Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
! some related stuff to fwdmdl/ForwardModelConfig.
!
! Revision 2.11  2001/03/17 00:45:15  livesey
! Moved to new ForwardModelConfig_T
!
! Revision 2.10  2001/03/15 21:18:57  vsnyder
! Use Get_Spec_ID instead of decoration(subtree...
!
! Revision 2.9  2001/03/09 03:05:05  vsnyder
! Correct identification for timing
!
! Revision 2.8  2001/03/08 03:23:09  vsnyder
! More stuff to work with L2_Load
!
! Revision 2.7  2001/03/07 23:59:52  vsnyder
! Add stuff for SIDS.
!
! Revision 2.6  2001/02/22 18:54:05  vsnyder
! Periodic commit.  Still working on the output covariance.
!
! Revision 2.5  2001/02/22 01:57:02  vsnyder
! Periodic commit -- working on getting output covariance matrix.
!
! Revision 2.4  2001/02/09 19:30:16  vsnyder
! Move checking for required and duplicate fields to init_tables_module
!
! Revision 2.3  2001/02/08 00:56:55  vsnyder
! Periodic commit.  Still needs work.
!
! Revision 2.2  2001/01/26 19:01:47  vsnyder
! More nearly complete, except for forward model interface and minor things
! having to do with creating subset masks.  Look for ??? in comments.
!
! Revision 2.1  2001/01/10 21:04:13  vsnyder
! Initial (incomplete) submission
!
@


2.367
log
@Avoid calling NeuralNet when skipping Retrievals, too
@
text
@d381 1
a381 1
          if ( L2Options%SkipRetrieval .and. STATEFILLEDBYSKIPPEDRETRIEVALS == 0. ) cycle
d3034 1
a3034 1
       "$Id: RetrievalModule.f90,v 2.366 2021/01/22 00:21:10 pwagner Exp $"
d3044 3
@


2.366
log
@Added NeuralNet command
@
text
@d381 1
d3034 1
a3034 1
       "$Id: RetrievalModule.f90,v 2.365 2020/07/17 19:38:52 vsnyder Exp $"
d3044 3
@


2.365
log
@Check that FwdModelExtra exists if -Sfwmparallel is set
@
text
@d83 3
a85 2
      & S_Diff, S_Dump, S_DumpBlocks, S_FlagCloud, S_FlushPFA, S_LeakCheck, &
      & S_EndSelect, S_Reevaluate, S_Repeat, S_RestrictRange, S_Retrieve, &
d104 1
d286 1
d380 5
d3033 1
a3033 1
       "$Id: RetrievalModule.f90,v 2.364 2019/06/24 23:29:26 pwagner Exp $"
d3043 3
@


2.364
log
@Updated to reflect TA-01-143
@
text
@d116 3
a118 1
    use Tree, only: Decorate, Decoration, NSons, Where, Sub_Rosa, Subtree
d173 1
d290 2
a291 1
    integer, parameter :: BothOrNeither = 1
d295 2
a296 1
    integer, parameter :: NotGeneral = Inconsistent + 1 ! Not a general matrix
d449 7
a455 1
                configIndices(k-1) = decoration(decoration(subtree(k,son)))
d499 7
a505 1
                sparseQuantities(k-1) = decoration(decoration(subtree(k,son)))
d613 3
d887 4
d906 3
d1663 3
a1665 2
      if ( parallelMode ) &
        & call SetupFWMSlaves ( configDatabase(configIndices), &
d1667 1
d3025 1
a3025 1
       "$Id: RetrievalModule.f90,v 2.363 2018/11/20 01:09:43 vsnyder Exp $"
d3035 3
@


2.363
log
@Always pass AJ to My_NWTDB.  It's no longer optional to DNWTDB
@
text
@d30 5
d1463 1
a1463 1
    subroutine My_NWTDB ( AJ, Width, Level, Why )
a1467 1
      integer, intent(in), optional :: Level
d1470 1
a1470 1
        call nwtdb ( aj, width, level, why )
d1472 1
a1472 1
        call alt_nwtdb ( aj, width, level, why )
d1479 6
a1484 6
      use DNWT_MODULE, only: FlagName, NF_AITKEN, NF_BEST, NF_BIGGEST_FLAG, &
      & NF_DX, NF_DX_AITKEN, NF_EVALF, NF_EVALJ, NF_FANDJ, NF_GMOVE, NF_LEV, &
      & NF_NEWX, NF_SMALLEST_FLAG, NF_SOLVE, NF_START, NF_TOLX, NF_TOLF, &
      & NF_TOLX_BEST, NF_TOO_SMALL, NWT_T, RK
      use DNWT_Module, only: NWT, NWTA, NWTOP
      use DNWT_Clone, only: ALT_NWT, ALT_NWTA, ALT_NWTOP ! SIMPLE
d1580 1
a1580 2
      integer :: NWT_Opt(20)            ! Options for NWT, q.v.
      real(rk) :: NWT_Xopt(20)          ! Real parameters for NWT options, q.v.
d1642 3
a1644 2
      nwt_opt(1:9) = (/  15, 1,      17, 2,      18, 3,      11, 4, 0 /)
      nwt_xopt(1:4) = (/ toleranceF, toleranceA, toleranceR, initLambda /)
d1646 1
a1646 1
        call nwt ( nwt_flag, aj, nwt_xopt, nwt_opt )
d1648 1
a1648 1
        call alt_nwt ( nwt_flag, aj, nwt_xopt, nwt_opt )
a1728 1
      aj%sqmin = lambdaMin
d1747 1
a1747 7
            if ( d_nin ) then ! Turn on NWTA's internal output
              if ( method == l_newtonian ) then
                call nwtop ( aj, (/ 1, 1, 0 /), nwt_xopt )
              else
                call alt_nwtop ( aj, (/ 1, 1, 0 /), nwt_xopt )
              end if
            end if
d2370 3
a2372 3
          aj%sq = max(aj%sq, lambdaMin)
          call updateDiagonal ( normalEquations, aj%sq**2 - lambda**2 )
          lambda = aj%sq
d2543 1
a2543 7
            if ( d_ndb >= 0 ) then
              if ( d_sca .or.  d_ndb >= 1 ) then
                call my_nwtdb ( aj, width=9, why='After Solve' )
              else
                call my_nwtdb ( aj, width=9, level=0, why='After Solve' )
              end if
            end if
d2634 1
a2634 1
        case ( nf_best ) ! ................................  BEST  .....
d2641 1
a2641 1
        case ( nf_aitken ) ! ............................  AITKEN  .....
d2675 1
a2675 1
        case ( nf_dx_aitken ) ! ......................  DX_AITKEN  .....
d2680 5
a2684 2
          ! dx = aj%cait * dxUnscaled:
          call scaleVector ( v(dxUnscaled), aj%cait, v(dx) )
d2686 5
a2690 3
          ! We don't need to compute aj%dxdxl because we only take Aitken
          ! accelerated moves when there is no Levenberg-Marquardt
          ! stabilization, in which case NWTA doesn't use aj%dxdxl.
d2746 1
a2746 1
          if ( d_ndb >= 2 ) call my_nwtdb ( aj, width=9 )
d2757 2
a2758 7
        if ( d_ndb >= 1 ) then
          if ( d_sca .or. d_ndb >= 2 ) then
            call my_nwtdb ( aj, width=9, why = "After Newton iteration" )
          else
            call my_nwtdb ( aj, width=9, why = "After Newton iteration" )
          end if
        end if
d2972 1
a2972 1
        if ( d_ndb >= 2 ) call my_nwtdb ( aj, width=9 )
d2996 1
a2996 1
       "$Id: RetrievalModule.f90,v 2.362 2018/09/13 20:23:49 pwagner Exp $"
d3006 3
@


2.362
log
@Moved changeable options to new L2Options; added DumpOptions
@
text
@d1461 1
a1461 1
      type (NWT_T), intent(in), optional :: AJ
d2550 1
a2550 1
                call my_nwtdb ( width=9, level=0, why='After Solve' )
d2765 1
a2765 1
            call my_nwtdb ( width=9, why = "After Newton iteration" )
d3005 1
a3005 1
       "$Id: RetrievalModule.f90,v 2.361 2018/08/28 20:50:10 vsnyder Exp $"
d3015 3
@


2.361
log
@Don't print message about fnmin being negative if |fnmin| is small
@
text
@d89 2
a90 3
    use MLSL2Options, only: L2CFNode, SkipRetrieval, SpecialDumpFile, &
      & StateFilledBySkippedRetrievals, &
      & CurrentChunkNumber, CurrentPhaseName
d343 1
a343 1
          if ( .not. SKIPRETRIEVAL ) &
d348 1
a348 1
          if ( .not. SKIPRETRIEVAL ) &
d375 1
a375 1
          if ( SKIPRETRIEVAL .and. STATEFILLEDBYSKIPPEDRETRIEVALS == 0. ) cycle
d545 1
a545 1
          if ( skipRetrieval ) then
d772 1
a772 1
          if ( skipRetrieval .and. switchDetail( switches, 'fiw' ) < 0 ) cycle
d1731 2
a1732 2
          call writeIntsToChars( currentChunkNumber, mesgChunkNo )
          mesg = '(' // trim(CurrentPhaseName) // ')' // &
d3005 1
a3005 1
       "$Id: RetrievalModule.f90,v 2.360 2018/07/27 23:19:53 pwagner Exp $"
d3015 3
@


2.360
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d2312 16
a2327 10
            call output ( aj%fnmin, before='How can aj%fnmin be negative?  aj%fnmin = ', &
              & advance='yes' )
            call output ( aj%fnorm, before='aj%fnorm**2 = ', advance='yes' )
            call output ( v(candidateDX) .mdot. v(candidateDX), &
              & before='norm(candidateDX)**2 = ', advance='yes' )
            if ( d_fnmin > 1 ) &
              & call dump ( v(candidateDX), name='v(candidateDX)', details=d_fnmin )
            if ( aj%fnmin < -10.0 * aj%fnorm * sqrt(epsilon(aj%fnorm)) ) &
              & call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & "Norm of residual not in Jacobian's column space is imaginary!" )
d2467 16
a2482 10
            call output ( aj%fnmin, before='How can aj%fnmin be negative?  aj%fnmin = ', &
              & advance='yes' )
            call output ( aj%fnorm**2, before='aj%fnorm**2 = ', advance='yes' )
            call output ( v(candidateDX) .mdot. v(candidateDX), &
              & before='norm(candidateDX)**2 = ', advance='yes' )
            if ( d_fnmin > 1 ) &
              & call dump ( v(candidateDX), name='v(candidateDX)', details=d_fnmin )
            if ( aj%fnmin < -10.0 * aj%fnorm * sqrt(epsilon(aj%fnorm)) ) &
              & call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & "Norm of residual not in Jacobian's column space is imaginary!" )
d3006 1
a3006 1
       "$Id: RetrievalModule.f90,v 2.359 2018/07/23 23:29:56 vsnyder Exp $"
d3016 3
@


2.359
log
@Remove ChiSqMinNorm and ChiSqNorm from DNWT AJ structure because DNWT
doesn't compute them or use them.
@
text
@d89 1
a89 1
    use MLSL2options, only: L2CFNode, SkipRetrieval, SpecialDumpFile, &
a90 1
      & MLSMessage, &
d93 2
a94 1
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, MLSMessageReset
d2994 1
a2994 1
       "$Id: RetrievalModule.f90,v 2.358 2018/07/23 22:20:21 vsnyder Exp $"
d3004 4
@


2.358
log
@Add AJ to all argument lists for nwt* so the options can be (eventually)
stored there instead of as saved module variables.
@
text
@d142 2
d1372 2
a1373 2
      call fillDiagQty ( diagnostics,  l_dnwt_chiSqMinNorm, aj%chiSqMinNorm )
      call fillDiagQty ( diagnostics,  l_dnwt_chiSqNorm, aj%chiSqNorm )
d2326 2
a2327 2
          aj%chiSqMinNorm = aj%fnmin / dof
          aj%chiSqNorm = aj%fnorm / dof
d2336 1
a2336 1
              call dump ( (/ aj%chiSqNorm, aj%chiSqMinNorm, dof /), &
d2744 1
a2744 1
      aj%chiSqNorm = aj%fnorm / dof
d2747 1
a2747 1
          & call dump ( (/ aj%fnorm, aj%chiSqNorm, dof /) , &
d2994 1
a2994 1
       "$Id: RetrievalModule.f90,v 2.357 2017/12/07 01:01:23 vsnyder Exp $"
d3004 4
@


2.357
log
@Don't use host-associated variable as a DO index
@
text
@d1641 1
a1641 1
        call nwt ( nwt_flag, nwt_xopt, nwt_opt )
d1643 1
a1643 1
        call alt_nwt ( nwt_flag, nwt_xopt, nwt_opt )
d1745 1
a1745 1
                call nwtop ( (/ 1, 1, 0 /), nwt_xopt )
d1747 1
a1747 1
                call alt_nwtop ( (/ 1, 1, 0 /), nwt_xopt )
d2992 1
a2992 1
       "$Id: RetrievalModule.f90,v 2.356 2015/05/05 00:12:47 vsnyder Exp $"
d3002 3
@


2.356
log
@Make sure 0 < mu <= 1 in BoundMove
@
text
@d926 1
d2992 1
a2992 1
       "$Id: RetrievalModule.f90,v 2.355 2014/09/30 02:15:19 vsnyder Exp $"
d3002 3
@


2.355
log
@Don't put the Tikhonov matrix in the matrix database.  Add some commented-
out stuff that might be useful if we turn on matrix finalizers.
@
text
@d386 1
a386 1
          nullify ( hRegWeightVec )
d1024 3
a1026 3
      ! given by Dx, let $b_i$ and $x_i$ be components of Bound and X.
      ! Let $d_i$ be such that $x_i + \frac{d_i}D \delta x_i$ is not beyond
      ! a bound.  That is, $d_i$ is such that $d_i \cos \theta_i = x_i -
d1030 9
a1038 8
      ! x_i}D$.  $\mu$ is the smallest value of $\frac{d_i}D = \frac{x_i-b_i}
      ! {\delta x_i}$.  If we check the components one at a time, each one
      ! using the most recently computed $\mu$, we don't need a divide for
      ! each check, and we don't need a {\tt min} operation.
      ! However, if we are already at the bounds, and the next step
      ! wants to keep going beyond the bounds, then $\mu$ will be
      ! really small.  In this case $\mu < \mu_{\text{min}}$ we revert
      ! to a straight element-by-element modification of $\delta x_i$.
d1071 3
a1073 3
                      & mu = ( bound%quantities(iq)%values(ivx,ivy) - &
                      &        x%quantities(iq)%values(ivx,ivy) ) &
                      &      / dx%quantities(iq)%values(ivx,ivy)
d1083 3
a1085 3
                    & mu = ( bound%quantities(iq)%values(ivx,ivy) - &
                    &        x%quantities(iq)%values(ivx,ivy) ) &
                    &      / dx%quantities(iq)%values(ivx,ivy)
d1099 3
a1101 3
                      & mu = ( bound%quantities(iq)%values(ivx,ivy) - &
                      &        x%quantities(iq)%values(ivx,ivy) ) &
                      &      / dx%quantities(iq)%values(ivx,ivy)
d1111 3
a1113 3
                    & mu = ( bound%quantities(iq)%values(ivx,ivy) - &
                    &        x%quantities(iq)%values(ivx,ivy) ) &
                    &      / dx%quantities(iq)%values(ivx,ivy)
d1184 2
d2991 1
a2991 1
       "$Id: RetrievalModule.f90,v 2.354 2014/09/29 20:17:52 vsnyder Exp $"
d3001 4
@


2.354
log
@Fuse two IF constructs with identical conditions, some cannonball polishing
@
text
@d83 3
a85 3
      & DestroyMatrix, GetFromMatrixDatabase, Matrix_t, Matrix_Database_t, &
      & Matrix_SPD_t, MultiplyMatrixVectorNoT, ReflectMatrix, &
      & Sparsify, MultiplyMatrix_XTY
d651 6
d676 6
d705 6
a727 1
              k = addToMatrixDatabase( matrixDatabase, tikhonov )
d2988 1
a2988 1
       "$Id: RetrievalModule.f90,v 2.353 2014/09/05 01:20:03 vsnyder Exp $"
d2998 3
@


2.353
log
@Remove unused State argument from DumpStateQuantities.  Remove USE for
unreferenced USE name.
@
text
@d40 59
a98 59
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST, TRACKALLOCATES
    use BITSTUFF, only: COUNTBITS
    use CHUNKS_M, only: MLSCHUNK_T
    use CLOUDRETRIEVALMODULE, only: CLOUDRETRIEVAL
    use DUMPCOMMAND_M, only: &
      & BOOLEANFROMANYGOODVALUES, &
      & BOOLEANFROMCATCHWARNING, BOOLEANFROMCOMPARINGQTYS, BOOLEANFROMFORMULA, &
      & DUMPCOMMAND, INITIALIZEREPEAT, NEXTREPEAT, &
      & MLSCASE, MLSENDSELECT, MLSSELECT, MLSSELECTING, REPEAT=>SKIP, SKIP
    use HESSIANMODULE_1, only: HESSIAN_T, CREATEEMPTYHESSIAN, DESTROYHESSIAN
    use IEEE_ARITHMETIC, only: IEEE_IS_NAN
    use EXPR_M, only: EXPR
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use INIT_TABLES_MODULE, only: F_APRIORI, F_APRIORIFRACTION, F_APRIORISCALE, &
      & F_AVERAGE, F_COLUMNSCALE, F_COMMENT, F_COVARIANCE, F_COVSANSREG, &
      & F_DIAGNOSTICS, F_DIAGONAL, F_DUMPQUANTITIES, F_EXTENDEDAVERAGE, &
      & F_FORWARDMODEL, F_FUZZ, F_FWDMODELEXTRA, F_FWDMODELOUT, &
      & F_HESSIAN, F_HIGHBOUND, F_HREGORDERS, F_HREGQUANTS, F_HREGWEIGHTS, &
      & F_HREGWEIGHTVEC, F_JACOBIAN, F_LAMBDA, F_LAMBDAMIN, F_LEVEL, &
      & F_LOWBOUND, &
      & F_MAXJ, F_MEASUREMENTS, F_MEASUREMENTSD, F_METHOD, F_MUMIN, &
      & F_NEGATESD, &
      & F_OUTPUTCOVARIANCE, F_OUTPUTSD, &
      & F_PHASENAME, F_PRECISIONFACTOR, &
      & F_REGAFTER, F_REGAPRIORI, F_SERIAL, F_SPARSEQUANTITIES, &
      & F_STATE, F_STATEMAX, F_STATEMIN, F_SWITCHES, F_TOGGLES, &
      & F_TOLERANCEA, F_TOLERANCEF, F_TOLERANCER, &
      & F_VREGORDERS, F_VREGQUANTS, &
      & F_VREGWEIGHTS, F_VREGWEIGHTVEC, FIELD_FIRST, FIELD_LAST, &
      & L_APRIORI, L_COVARIANCE, &
      & L_DNWT_ABANDONED,  L_DNWT_AJN,  L_DNWT_AXMAX, &
      & L_DNWT_CAIT, L_DNWT_CHISQMINNORM, L_DNWT_CHISQNORM, L_DNWT_COUNT, &
      & L_DNWT_DIAG,  L_DNWT_DXDX, L_DNWT_DXDXL, L_DNWT_DXN,  L_DNWT_DXNL, &
      & L_DNWT_FLAG, L_DNWT_FNMIN, L_DNWT_FNORM,  L_DNWT_GDX,  L_DNWT_GFAC, &
      & L_DNWT_GRADN,  L_DNWT_SQ, L_DNWT_SQ,  L_DNWT_SQT, &
      & L_HIGHCLOUD, L_JACOBIAN_COLS, L_JACOBIAN_ROWS, L_LOWCLOUD, &
      & L_NEWTONIAN, L_NONE, L_NORM, L_NUMGRAD, L_NUMJ, L_NUMNEWT, L_SIMPLE, &
      & S_ANYGOODVALUES, S_CATCHWARNING, S_CASE, S_COMPARE, &
      & S_DIFF, S_DUMP, S_DUMPBLOCKS, S_FLAGCLOUD, S_FLUSHPFA, S_LEAKCHECK, &
      & S_ENDSELECT, S_REEVALUATE, S_REPEAT, S_RESTRICTRANGE, S_RETRIEVE, &
      & S_SELECT, S_SIDS, S_SKIP, S_SNOOP, S_SUBSET, S_TIME, S_UPDATEMASK
    use L2PARINFO, only: PARALLEL
    use MATRIXMODULE_1, only: ADDTOMATRIXDATABASE, COPYMATRIX, CREATEEMPTYMATRIX, &
      & DESTROYMATRIX, GETFROMMATRIXDATABASE, MATRIX_T, MATRIX_DATABASE_T, &
      & MATRIX_SPD_T, MULTIPLYMATRIXVECTORNOT, REFLECTMATRIX, &
      & SPARSIFY, MULTIPLYMATRIX_XTY
    use MATRIXTOOLS, only: DUMPBLOCKS
    use MLSKINDS, only: R8, RV
    use MLSCOMMON, only: MLSFILE_T
    use MLSL2OPTIONS, only: L2CFNODE, SKIPRETRIEVAL, SPECIALDUMPFILE, &
      & STATEFILLEDBYSKIPPEDRETRIEVALS, &
      & MLSMESSAGE, &
      & currentChunkNumber, CurrentPhaseName
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES, ADD_TO_RETRIEVAL_TIMING
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, MLSMESSAGERESET
    use MORETREE, only: GET_BOOLEAN, Get_Label_And_Spec, GET_FIELD_ID, &
      & GET_SPEC_ID
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MLSSTRINGS, only: WRITEINTSTOCHARS
d101 16
a116 16
    use OUTPUT_M, only: BLANKS, OUTPUT, REVERTOUTPUT, SWITCHOUTPUT
    use PFADATA_M, only: FLUSH_PFADATA
    use SET_TOGGLES_M, only: SET_TOGGLES
    use SIDSMODULE, only: SIDS
    use SNOOPMLSL2, only: SNOOP
    use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
    use SUBSETMODULE, only: SETUPSUBSET, SETUPFLAGCLOUD, RESTRICTRANGE, UPDATEMASK
    use TIME_M, only: TIME_NOW
    use TOGGLES, only: GEN, SWITCHES, TOGGLE, LEVELS
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TRACK_M, only: REPORTLEAKS
    use TREE, only: DECORATE, DECORATION, NSONS, Where, SUB_ROSA, SUBTREE
    use VECTORSMODULE, only: CLEARMASK, CLEARUNDERMASK, &
      & CLEARVECTOR, CLONEVECTOR, COPYVECTOR, COPYVECTORMASK, CREATEMASK, &
      & DESTROYVECTORINFO, DUMPVECTORNORMS, GETVECTORQUANTITYBYTYPE, M_LINALG, &
      & VECTOR_T, VECTORVALUE_T
d119 1
a119 1
    integer, intent(in)                               :: ROOT ! Of the relevant subtree of the AST;
d121 6
a126 6
    type(vector_T), dimension(:), target              :: VECTORDATABASE
    type(matrix_Database_T), dimension(:), pointer    :: MATRIXDATABASE
    type(Hessian_T), dimension(:), pointer            :: HESSIANDATABASE
    type(forwardModelConfig_T), dimension(:), pointer :: CONFIGDATABASE
    type(MLSChunk_T), intent(inout)                   :: CHUNK
    type (MLSFile_T), dimension(:), pointer           :: FILEDATABASE
d564 1
a564 1
          endif
d712 1
a712 2
          end if
          if ( error == 0 ) then
a733 7

            !??? Make sure the jacobian and outputCovariance get destroyed
            !??? after ?what? happens?  Can we destroy the entire matrix
            !??? database at the end of each chunk?
            if ( .not. got(f_jacobian) ) call destroyMatrix ( jacobian )
            if ( .not. got(f_outputCovariance) ) &
              & call destroyMatrix ( outputCovariance%m )
d738 7
d754 1
a754 1
          if ( SKIPRETRIEVAL .and. switchDetail( switches, 'fiw' ) < 0 ) cycle
d831 3
a833 3
      use INTRINSIC, only: FIELD_INDICES
      use LEXER_CORE, only: PRINT_SOURCE
      use STRING_TABLE, only: DISPLAY_STRING
d897 4
a900 4
      use MatrixModule_1, only: CLEARMATRIX, COLUMNSCALE, DUMP, DUMP_STRUCT, &
        & FORMNORMALEQUATIONS => NORMALEQUATIONS, GETDIAGONAL
      use Regularization, only: REGULARIZE
      use VectorsModule, only: OPERATOR(.DOT.), SCALEVECTOR
d1184 3
a1186 3
      use Tree, only: DECORATION, NSONS, SUBTREE
      use VectorsModule, only: DUMP, GETVECTORQTYBYTEMPLATEINDEX, &
        & VECTORVALUE_T
d1208 1
a1208 1
      use VectorsModule, only: DUMPNICEMASKSUMMARY, M_TIKHONOV, M_FULLDERIVATIVES
d1331 2
a1332 2
    subroutine FillDiagVec ( diagnostics, aj, numGrad, numJ, numNewt, nwt_flag, &
      & jacobian_rows, jacobian_cols )
d1334 1
a1334 1
      type(Vector_T), intent(inout) :: DIAGNOSTICS
d1336 6
a1341 6
      integer, intent(in), optional :: NUMGrad
      integer, intent(in), optional :: NUMJ
      integer, intent(in), optional :: NUMNewt
      integer, intent(in), optional :: NWT_FLAG
      integer, intent(in), optional :: JACOBIAN_ROWS
      integer, intent(in), optional :: JACOBIAN_COLS
d1436 1
a1436 1
    subroutine My_NWTDB ( AJ, WIDTH, LEVEL, WHY )
d1440 3
a1442 3
      integer, intent(in), optional :: WIDTH
      integer, intent(in), optional :: LEVEL
      character(len=*), intent(in), optional :: WHY
d1453 1
a1453 1
      use DNWT_MODULE, only: FLAGNAME, NF_AITKEN, NF_BEST, NF_BIGGEST_FLAG, &
d1457 22
a1478 22
      use DNWT_MODULE, only: NWT, NWTA, NWTOP
      use DNWT_CLONE, only: ALT_NWT, ALT_NWTA, ALT_NWTOP ! SIMPLE
      use DUMP_0, only: DUMP
      use FORWARDMODELWRAPPERS, only: FORWARDMODEL
      use FORWARDMODELINTERMEDIATE, only: FORWARDMODELSTATUS_T
      use L2FWMPARALLEL, only: SETUPFWMSLAVES, TRIGGERSLAVERUN, &
        & REQUESTSLAVESOUTPUT, RECEIVESLAVESOUTPUT
      use MATRIXMODULE_0, only: DUMP ! THE ONE FROM MATRIXMODULE_1 OUGHT TO WORK ???
      use MATRIXMODULE_1, only: ADDTOMATRIX, CHOLESKYFACTOR, CLEARMATRIX, &
        & COLUMNSCALE, COPYMATRIXVALUE, CREATEEMPTYMATRIX, &
        & DESTROYMATRIX, DUMP, DUMP_LINF, DUMP_STRUCT, &
        & FORMNORMALEQUATIONS => NORMALEQUATIONS, &
        & GETDIAGONAL, INVERTCHOLESKY, MATRIX_T, &
        & MATRIX_CHOLESKY_T, MATRIX_SPD_T, MAXL1, MINDIAG, MULTIPLY, &
        & MULTIPLYMATRIX_XY,  MULTIPLYMATRIX_XY_T,  &
        & ROWSCALE, SCALEMATRIX, SOLVECHOLESKY, UPDATEDIAGONAL
      use SCANMODELMODULE, only: DESTROYFORWARDMODELINTERMEDIATE
      use SYMBOL_TABLE, only: ENTER_TERMINAL
      use SYMBOL_TYPES, only: T_IDENTIFIER
      use VECTORSMODULE, only: ADDTOVECTOR, DESTROYVECTORINFO, &
        & DUMP, MULTIPLY, OPERATOR(.DOT.), OPERATOR(.MDOT.), OPERATOR(-), &
        & SCALEVECTOR, SUBTRACTFROMVECTOR
d2930 1
a2930 1
    subroutine NewtonSolverFailed ( WHY, NWT_FLAG, PREV_NWT_FLAG, &
d2934 2
a2935 2
      integer, intent(inout) :: NWT_FLAG       ! Solver's state flag
      integer, intent(inout) :: PREV_NWT_FLAG  ! Solver's previous state
d2960 1
a2960 1
      endif
d2971 1
a2971 1
       "$Id: RetrievalModule.f90,v 2.352 2014/09/05 00:49:07 vsnyder Exp $"
d2981 4
@


2.352
log
@EmpiricalGeometry.f90
@
text
@d2972 1
a2972 1
       "$Id: RetrievalModule.f90,v 2.351 2014/04/10 00:45:24 pwagner Exp $"
d2982 3
@


2.351
log
@Moved currentChunkNumber, currentPhaseName from MLSL2Timings to MLSL2Options
@
text
@d1184 1
a1184 1
    subroutine DumpStateQuantities ( State, DumpQuantitiesNode, Title )
d1187 1
a1187 1
        & VECTOR_T, VECTORVALUE_T
a1188 1
      type(vector_t), intent(in) :: State
d1677 1
a1677 1
          & call DumpStateQuantities ( v(x), dumpQuantitiesNode, 'Original X' )
d1818 1
a1818 1
              & call DumpStateQuantities ( v(x), dumpQuantitiesNode, 'State' )
d2972 1
a2972 1
       "$Id: RetrievalModule.f90,v 2.350 2014/03/01 03:10:56 vsnyder Exp $"
d2982 3
@


2.350
log
@Move units checking to init_tables_module
@
text
@d91 3
a93 3
      & MLSMESSAGE
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES, ADD_TO_RETRIEVAL_TIMING, &
      & CURRENTCHUNKNUMBER, CURRENTPHASENAME
d2973 1
a2973 1
       "$Id: RetrievalModule.f90,v 2.349 2014/02/28 01:14:04 vsnyder Exp $"
d2983 3
@


2.349
log
@Remove TYPE argument from calls to EXPR because the value wasn't used.
Move units checking to type checker.
@
text
@a477 2
            case ( f_precisionFactor )
              precisionFactor = value(1)
d505 2
a506 1
              &    f_muMin, f_toleranceA, f_toleranceF, f_toleranceR )
d521 2
d2973 1
a2973 1
       "$Id: RetrievalModule.f90,v 2.348 2014/01/23 23:16:37 vsnyder Exp $"
d2983 4
@


2.348
log
@Back out Levenberg-Marquardt without getting a new Jacobiab
@
text
@a80 1
    use INTRINSIC, only: PHYQ_DIMENSIONLESS
a234 1
    integer :: Type                     ! Type of value returned by EXPR
a286 1
    integer, parameter :: WrongUnits = NotSPD + 1
d508 1
a508 3
              call expr ( subtree(2,son), units, value, type )
              if ( units(1) /= phyq_dimensionless ) &
                & call announceError ( wrongUnits, field, string='no' )
d785 1
a785 3
              call expr ( subtree(2,son), units, value, type )
              if ( units(1) /= phyq_dimensionless ) &
                & call announceError ( wrongUnits, field, string='no' )
a873 6
      case ( wrongUnits )
        call output ( 'The value(s) of the "' )
        call display_string ( field_indices(fieldIndex) )
        call output ( '" field shall have ' )
        call output ( trim(string) )
        call output ( ' units.', advance='yes' )
d2972 1
a2972 1
       "$Id: RetrievalModule.f90,v 2.347 2014/01/11 01:44:18 vsnyder Exp $"
d2982 3
@


2.347
log
@Decruftification
@
text
@d902 6
d1503 1
d1718 1
d1841 11
a1851 11
            if ( .not. foundBetterState ) exit NEWT
            ! Restore BestX, run the forward model one more time to get a new
            ! Jacobian, and form normal equations -- the last two so that the
            ! a posteriori covariance is consistent with BestX.
            aj = bestAJ
            call copyVector ( v(x), v(bestX) ) ! x = bestX
            ! Do we need to get a fresh Jacobian, uncontaminated by Tikhonov
            ! regularization and Levenberg-Marquardt stabilization, in order
            ! to compute a posteriori covariance or standard deviation, or
            ! an averaging kernel?
            nwt_flag = nf_getJ
d1853 15
a1867 3
              &    got(f_average) ) .and. &
              &  tikhonovNeeded .and. covSansReg ) cycle NEWT ! yes
            exit NEWT ! no
d2242 11
a2252 14
          ! Correct for apriori information.  Note that there is an
          ! approximation here: We don't take any account of whether the a
          ! priori is used on an element by element basis.
          if ( got(f_apriori) ) &
            & jacobian_rows = jacobian_rows + jacobian_cols
          ! Correct for Tikhonov information.
          if ( nwt_flag == nf_getJ ) then ! taking a special iteration to get J
            dof = max ( jacobian_rows - jacobian_cols, 1 )
            aj%chiSqNorm = aj%fnorm / dof
            aj%fnorm = sqrt(aj%fnorm)
              if ( d_sca ) &
                & call dump ( (/ aj%fnorm, aj%chiSqNorm, dof /) , &
                & '     | F |    chi^2/DOF           DOF ', options='c' )
            exit NEWT
d2254 4
a2257 1
          if ( tikhonovNeeded ) jacobian_rows = jacobian_rows + tikhonovRows
d2350 3
a2352 1
        ! ${\bf \Sigma}^{-1} {\bf \delta \hat x}$.  Set
d2534 4
a2537 3
        ! Set X = X + DX
        !     AJ%AXMAX = MAXVAL(ABS(X)),
        !     AJ%BIG = ANY ( DX > 10.0 * epsilon(X) * X )
d2555 1
d2625 1
d2692 1
d2734 7
d2791 2
a2792 2
      if ( foundBetterState .and. ( got(f_outputCovariance) .or. got(f_outputSD) .or. &
        &  got(f_average) .or. got(f_aprioriFraction) ) ) then
d2808 11
d2837 3
d2985 1
a2985 1
       "$Id: RetrievalModule.f90,v 2.346 2013/12/12 02:11:26 vsnyder Exp $"
d2995 3
@


2.346
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d113 1
a113 2
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, Where, SUB_ROSA, &
      & SUBTREE
a1190 1
      use MoreTree, only: StartErrorMessage
d2938 1
a2938 1
       "$Id: RetrievalModule.f90,v 2.345 2013/10/09 23:42:29 vsnyder Exp $"
d2948 3
@


2.345
log
@Add Evaluate_Variable
@
text
@a48 1
    use Evaluate_Variable_m, only: Evaluate_Variable
d96 2
a97 1
    use MORETREE, only: GET_BOOLEAN, GET_FIELD_ID, GET_SPEC_ID
d100 2
a114 1
    use TREE_TYPES, only: N_NAMED, N_Variable
d172 1
a172 1
    integer :: I_Key, I_Sons, J         ! Subscripts and loop inductors
d185 1
d245 1
d319 5
a323 11
      do i_sons = 2, nsons(root) - 1      ! skip names at begin/end of section
        son = subtree(i_sons, root)
        if ( node_id(son) == n_variable ) then
          call evaluate_variable ( son )
      cycle
        end if
        if ( node_id(son) == n_named ) then
          key = subtree(2, son)
        else
          key = son
        end if
d820 1
a820 1
      end do ! i_sons = 2, nsons(root) - 1
d2940 1
a2940 1
       "$Id: RetrievalModule.f90,v 2.344 2013/09/24 23:47:22 vsnyder Exp $"
d2950 3
@


2.344
log
@Use Where instead of Source_Ref for messages
@
text
@d49 1
d113 1
a113 1
    use TREE_TYPES, only: N_NAMED
d318 4
d2943 1
a2943 1
       "$Id: RetrievalModule.f90,v 2.343 2013/09/04 02:50:05 vsnyder Exp $"
d2953 3
@


2.343
log
@Add 'cond' argument in three calls to Trace_End
@
text
@d110 1
a110 1
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, SOURCE_REF, SUB_ROSA, &
d847 1
a847 1
      call print_source ( source_ref(son) )
d1222 1
a1222 1
      call print_source ( source_ref ( son ) )
d2938 1
a2938 1
       "$Id: RetrievalModule.f90,v 2.342 2013/08/30 02:45:46 vsnyder Exp $"
d2948 3
@


2.342
log
@Revise calls to trace_begin and trace_end
@
text
@d1335 1
a1335 1
      call trace_end
d1383 1
a1383 1
      call trace_end
d2893 1
a2893 1
      call trace_end
d2938 1
a2938 1
       "$Id: RetrievalModule.f90,v 2.341 2013/08/03 00:40:42 vsnyder Exp $"
d2948 3
@


2.341
log
@Require vector.quantity in dumpQuantities field in retrieve spec
@
text
@d95 1
a95 2
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, &
      & MLSMESSAGECALLS, MLSMESSAGERESET
d270 9
d309 1
a309 1
    if ( toggle(gen) ) call trace_begin ( "Retrieve", root )
d312 2
a313 2
    repeat_loop: do ! RepeatLoop
    ! Loop over the lines in the configuration file
d315 8
a322 8
    do i_sons = 2, nsons(root) - 1      ! skip names at begin/end of section
      son = subtree(i_sons, root)
      if ( node_id(son) == n_named ) then
        key = subtree(2, son)
      else
        key = son
      end if
      L2CFNODE = key
d324 2
a325 2
      ! "Key" now indexes an n_spec_args vertex.  See "Configuration file
      ! parser users' guide" for pictures of the trees being analyzed.
d327 84
a410 187
      if ( MLSSelecting .and. &
        & .not. any( get_spec_id(key) == (/ s_endselect, s_select, s_case /) ) ) cycle
      if ( get_spec_id(key) /= s_catchWarning ) &
        & call MLSMessageReset( clearLastWarning=.true. )

      got = .false.
      spec = get_spec_id(key)
      PotemkinHessian = .false.
      select case ( spec )
      case ( s_anygoodvalues )
        call decorate ( key, &
          & BooleanFromAnyGoodValues ( key, vectorDatabase ) )
      case ( s_catchWarning )
        call decorate ( key,  BooleanFromCatchWarning ( key ) )
      case ( s_compare )
        call decorate ( key,  BooleanFromComparingQtys ( key, vectorDatabase ) )
      case ( s_diff, s_dump )
        if ( .not. SKIPRETRIEVAL ) &
          & call dumpCommand ( key, forwardModelConfigs=configDatabase, &
          & vectors=vectorDatabase, FileDataBase=FileDataBase, &
          & MatrixDatabase=MatrixDatabase, Hessiandatabase=HessianDatabase )
      case ( s_dumpblocks )
        if ( .not. SKIPRETRIEVAL ) &
          & call DumpBlocks ( key, matrixDatabase, hessianDatabase )
      case ( s_flagCloud )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_begin ( "Retrieve.flagCloud", root )
        call SetupflagCloud ( key, vectorDatabase )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "Retrieve.flagCloud" )
      case ( s_flushPFA )
        call flush_PFAData ( key, status )
        error = max(error,status)
      case ( s_leakCheck )
        if ( trackAllocates > 0 ) then
          whereLeakCheck = "In retrieval module..."
          if ( nsons(key) > 1 ) then
            call get_string ( sub_rosa(subtree(2,subtree(2,key))), whereLeakCheck, &
              & strip=.true. )
          end if
          call reportLeaks ( whereLeakCheck )
        end if
      case ( s_restrictRange )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_begin ( "Retrieve.RestrictRange", root )
        call RestrictRange ( key, vectorDatabase )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "Retrieve.RestrictRange" )
      case ( s_Reevaluate )
        call decorate ( key,  BooleanFromFormula ( 0, key, vectorDatabase ) )
      case ( s_retrieve )
        if ( SKIPRETRIEVAL .and. STATEFILLEDBYSKIPPEDRETRIEVALS == 0. ) cycle
        if ( toggle(gen) ) call trace_begin ( "Retrieve.retrieve", root )
        saveLevels = levels
        saveToggle = toggle
        aprioriScale = 1.0
        columnScaling = l_none
        covSansReg = .false.
        diagonal = .false.
        extendedAverage = .false.
        hRegQuants = 0
        hRegWeights = 0
        nullify ( hRegWeightVec )
        initLambda = defaultInitLambda
        lambdaMin = defaultLambdaMin
        maxJacobians = defaultMaxJ
        method = defaultMethod
        muMin = defaultMuMin
        negateSD = .false.
        precisionFactor = 0.5_rv
        toleranceA = defaultToleranceA
        toleranceF = defaultToleranceF
        toleranceR = defaultToleranceR
        vRegQuants = 0
        vRegWeights = 0
        parallelMode = parallel%fwmParallel .and. parallel%master
        tikhonovApriori = .false.
        tikhonovBefore = .true.
        tikhonovNeeded = .false.
        nullify ( vRegWeightVec )
        do i_key = 2, nsons(key) ! fields of the "retrieve" specification
          son = subtree(i_key, key)
          L2CFNODE = son
          field = get_field_id(son)  ! tree_checker prevents duplicates
          got(field) = .true.
          select case ( field )
          case ( f_apriori )
            apriori => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_aprioriFraction )
            aprioriFraction => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_average )
            ixAverage = decoration(subtree(2,son)) ! averagingKernel matrix vertex
          case ( f_columnScale )
            columnScaling = decoration(subtree(2,son))
          case ( f_covariance )      ! of apriori
            call getFromMatrixDatabase ( &
              & matrixDatabase(decoration(decoration(subtree(2,son)))), &
              & covariance)
            if ( .not. associated(covariance) ) &
              & call announceError ( notSPD, field )
          case ( f_covSansReg )
            covSansReg = get_Boolean(son)
          case ( f_diagnostics )
            diagnostics => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_diagonal )
            diagonal = get_Boolean(son)
          case ( f_dumpQuantities )
            dumpQuantitiesNode = son
          case ( f_extendedAverage )
            extendedAverage = get_boolean(son)
          case ( f_forwardModel )
            call allocate_test ( configIndices, nsons(son)-1, "ConfigIndices", &
              & moduleName )
            do k = 2, nsons(son)
              configIndices(k-1) = decoration(decoration(subtree(k,son)))
            end do
          case ( f_fwdModelExtra )
            fwdModelExtra => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_fwdModelOut )
            fwdModelOut => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_highBound )
            highBound => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_hRegOrders )
            hRegOrders = son
            tikhonovNeeded = .true.
          case ( f_hRegQuants )
            hRegQuants = son
          case ( f_hRegWeights )
            hRegWeights = son
          case ( f_hRegWeightVec )
            hRegWeightVec => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_jacobian )
            ixJacobian = decoration(subtree(2,son)) ! jacobian: matrix vertex
          case ( f_lowBound )
            lowBound => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_measurements )
            measurements => vectorDatabase(decoration(decoration(subtree(2,son))))
            call cloneVector ( v(f), measurements, vectorNameText='_f' )
          case ( f_measurementSD )
            measurementSD => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_method )
            method = decoration(subtree(2,son))
          case ( f_negateSD )
            negateSD = get_boolean ( son )
          case ( f_regAfter )
            tikhonovBefore = .not. get_Boolean(son)
          case ( f_regApriori )
            tikhonovApriori = get_Boolean(son)
          case ( f_serial )
            parallelMode = parallelMode .and. .not. get_boolean ( son )
          case ( f_outputCovariance )
            ixCovariance = decoration(subtree(2,son)) ! outCov: matrix vertex
          case ( f_outputSD )
            outputSD => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_precisionFactor )
            precisionFactor = value(1)
          case ( f_sparseQuantities )
            call Allocate_Test ( sparseQuantities, nsons(son)-1, &
              & 'sparseQuantities', ModuleName )
            do k = 2, nsons(son)
              sparseQuantities(k-1) = decoration(decoration(subtree(k,son)))
            end do
          case ( f_state )
            state => vectorDatabase(decoration(decoration(subtree(2,son))))
          case ( f_stateMax )
            stateMax => vectorDatabase(decoration(decoration(subtree(2,son))))
            do k = 1, size(stateMax%quantities)
              stateMax%quantities(k)%values = -huge(0.0_rv)
            end do
          case ( f_stateMin )
            stateMin => vectorDatabase(decoration(decoration(subtree(2,son))))
            do k = 1, size(stateMin%quantities)
              stateMin%quantities(k)%values = huge(0.0_rv)
            end do
          case ( f_switches )
            call get_string ( sub_rosa(subtree(2,son)), switches(switchLenCur+1:), strip=.true. )
            switchLenCur = len_trim(switches) + 1
            switches(switchLenCur:switchLenCur) = ','
          case ( f_toggles )
            call get_string ( sub_rosa(subtree(2,son)), switches(switchLenCur+1:), strip=.true. )
            call set_toggles ( switches(switchLenCur+1:) )
            switches(switchLenCur+1:) = ''
          case ( f_aprioriScale, f_fuzz, f_lambda, f_lambdamin, f_maxJ, &
            &    f_muMin, f_toleranceA, f_toleranceF, f_toleranceR )
            call expr ( subtree(2,son), units, value, type )
            if ( units(1) /= phyq_dimensionless ) &
              & call announceError ( wrongUnits, field, string='no' )
d412 132
a543 18
            case ( f_aprioriScale )
              aprioriScale = value(1)
            case ( f_fuzz )
              fuzz = value(1)
            case ( f_lambda )
              initLambda = value(1)
            case ( f_lambdamin )
              lambdaMin = value(1)
            case ( f_maxJ )
              maxJacobians = nint(value(1))
            case ( f_muMin )
              muMin = value(1)
            case ( f_toleranceA )
              toleranceA = value(1)
            case ( f_toleranceF )
              toleranceF = value(1)
            case ( f_toleranceR )
              toleranceR = value(1)
d545 23
a567 13
          case ( f_vRegOrders )
            vRegOrders = son
            tikhonovNeeded = .true.
          case ( f_vRegQuants )
            vRegQuants = son
          case ( f_vRegWeights )
            vRegWeights = son
          case ( f_vRegWeightVec )
            vRegWeightVec => vectorDatabase(decoration(decoration(subtree(2,son))))
          case default
            ! Shouldn't get here if the type checker worked
          end select
        end do ! ! fields of the "retrieve" specification
d569 76
a644 46
        if ( skipRetrieval ) then
          if ( got(f_state) ) then
            call ClearVector( state, real(statefilledbyskippedretrievals, rv) )
            call output ( 'Clearing retrieval state vector name: ' )
            call display_string ( state%name )
            call output ( ', template name: ' )
            call display_string ( state%template%name, advance='yes' )
          end if
          if ( got(f_outputSD) ) then
            call ClearVector( outputSD, real(statefilledbyskippedretrievals, rv) )
            call output ( 'Clearing retrieval precision vector name: ' )
            call display_string ( state%name )
            call output ( ', template name: ' )
            call display_string ( state%template%name, advance='yes' )
          end if
          call output ( ' (skipping retrieval) ', advance='yes' )
          levels = saveLevels
          toggle = saveToggle
          if ( toggle(gen) )  call trace_end ( "Retrieve.retrieve" )
          cycle
        endif

        if ( got(f_apriori) .neqv. got(f_covariance) ) &
          & call announceError ( bothOrNeither, f_apriori, f_covariance )
        if ( diagonal .and. .not. got(f_covariance) ) &
          & call announceError ( diagNoCov )
        if ( got(f_regApriori) .and. .not. got(f_apriori) ) &
          & call announceError ( ifAThenB, f_regApriori, f_apriori )
        if ( got(f_hRegOrders) .neqv. &
          & (got(f_hRegWeights) .or. got(f_hRegWeightVec)) ) then
          call announceError ( bothOrNeither, f_hRegOrders, f_hRegWeights )
          call announceError ( bothOrNeither, f_hRegOrders, f_hRegWeightVec )
        end if
        if ( got(f_hRegQuants) .and. .not. got(f_hRegOrders) ) &
          & call announceError ( ifAThenB, f_hRegQuants, f_hRegOrders )
        if ( got(f_vRegOrders) .neqv. &
          & (got(f_vRegWeights) .or. got(f_vRegWeightVec)) ) then
          call announceError ( bothOrNeither, f_vRegOrders, f_vRegWeights )
          call announceError ( bothOrNeither, f_vRegOrders, f_vRegWeightVec )
        end if
        if ( got(f_vRegQuants) .and. .not. got(f_vRegOrders) ) &
          & call announceError ( ifAThenB, f_vRegQuants, f_vRegOrders )
        if ( negateSD .and. .not. tikhonovBefore ) &
          & call announceError ( inconsistent, f_negateSD, f_regAfter )
        if ( negateSD .and. .not. got(f_outputSD) ) &
          & call AnnounceError ( ifAThenB, f_negateSD, f_outputSD )
d646 18
a663 1
        if ( error == 0 ) then
d665 22
a686 35
          ! Verify the consistency of various matrices and vectors
          if ( got(f_apriori) ) then
            if ( apriori%template%name /= state%template%name ) &
              & call announceError ( inconsistent, f_apriori, f_state )
          end if
          if ( got(f_aprioriFraction) ) then
            if ( aprioriFraction%template%name /= state%template%name ) &
              & call announceError ( inconsistent, f_aprioriFraction, f_state )
          end if
          if ( associated(covariance) ) then
            if ( covariance%m%row%vec%template%name /= state%template%name .or. &
              &  covariance%m%col%vec%template%name /= state%template%name ) &
              &  call announceError ( inconsistent, f_covariance, f_state )
          end if
          if ( got(f_highBound) ) then
            if ( highBound%template%name /= state%template%name ) &
              & call announceError ( inconsistent, f_highBound, f_state )
          end if
          if ( got(f_lowBound) ) then
            if ( lowBound%template%name /= state%template%name ) &
              & call announceError ( inconsistent, f_lowBound, f_state )
          end if
          if ( got(f_measurementSD) ) then
            if ( measurementSD%template%name /= measurements%template%name ) &
              & call announceError ( inconsistent, f_measurementSD, f_measurements )
          end if
          if ( got(f_stateMax) ) then
            if ( stateMax%template%name /= state%template%name ) &
              & call announceError ( inconsistent, f_stateMax, f_state )
          end if
          if ( got(f_stateMin) ) then
            if ( stateMin%template%name /= state%template%name ) &
              & call announceError ( inconsistent, f_stateMin, f_state )
          end if
        end if
d688 20
a707 1
        if ( error == 0 ) then
d709 29
a737 1
          if ( switchDetail ( switches, 'rtv' ) > -1 ) call DumpRetrievalConfig
d739 6
a744 4
          ! Create the Hessian object
          if ( got(f_hessian) ) then
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Not ready to handle a Hessian field in Retrieve command yet' )
d746 6
a751 22
            hessian => myHessian
            hessian = createEmptyHessian ( 0, measurements, state, Potemkin=.true. )
            PotemkinHessian = .true.
          end if

          ! Create the Jacobian matrix
          if ( got(f_jacobian) ) then
            k = decoration(ixJacobian)
            if ( k == 0 ) then
              call createEmptyMatrix ( myJacobian, &
                & sub_rosa(subtree(1,ixJacobian)), measurements, state )
              k = addToMatrixDatabase( matrixDatabase, myJacobian )
              call decorate ( ixJacobian, k )
            end if
            call getFromMatrixDatabase ( matrixDatabase(k), jacobian )
            if ( jacobian%row%vec%template%name /= measurements%template%name ) &
              & call announceError ( inconsistent, f_jacobian, f_measurements )
            if ( jacobian%col%vec%template%name /= state%template%name ) &
              & call announceError ( inconsistent, f_jacobian, f_state )
          else
            jacobian => myJacobian
            call createEmptyMatrix ( jacobian, 0, measurements, state )
d753 50
a802 20


          ! Create the output covariance matrix
          if ( got(f_outputCovariance) ) then
            k = decoration(ixCovariance)
            if ( k == 0 ) then
              call createEmptyMatrix ( myCovariance%m, &
                & sub_rosa(subtree(1,ixCovariance)), state, state )
              k = addToMatrixDatabase( matrixDatabase, myCovariance )
              call decorate ( ixCovariance, k )
            end if
            call getFromMatrixDatabase ( matrixDatabase(k), outputCovariance )
            if ( .not. associated(outputCovariance) ) then
              call announceError ( notSPD, f_outputCovariance )
            else
              if ( outputCovariance%m%row%vec%template%name /= state%template%name &
                & .or. &
                &  outputCovariance%m%col%vec%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_outputCovariance, f_state )
            end if
d804 2
a805 2
            outputCovariance => myCovariance
            call createEmptyMatrix ( myCovariance%m, 0, state, state )
d807 6
d814 2
a815 106
          ! Create the averaging kernel matrix
          if ( got(f_average) ) then
            k = decoration(ixAverage)
            if ( k == 0 ) then
              call createEmptyMatrix ( myAverage, &
                & sub_rosa(subtree(1,ixAverage)), state, state )
              k = addToMatrixDatabase( matrixDatabase, myAverage )
              call decorate ( ixAverage, k )
            end if
            call getFromMatrixDatabase ( matrixDatabase(k), outputAverage )
            call display_string ( outputAverage%name, advance='yes' )
            if ( .not. associated(outputAverage) ) then
              call announceError ( notGeneral, f_average )
            else
              if ( outputAverage%row%vec%template%name /= state%template%name &
                & .or. &
                &  outputAverage%col%vec%template%name /= state%template%name ) &
                & call announceError ( inconsistent, f_average, f_state )
            end if
          end if

          ! Create the matrix for adding the Tikhonov regularization to the
          ! normal equations
          if ( tikhonovNeeded ) then
            call createEmptyMatrix ( tikhonov, 0, state, state, text='_Tikhonov' )
            k = addToMatrixDatabase( matrixDatabase, tikhonov )
          end if
        end if
        if ( error == 0 ) then
          ! Do the retrieval
          jacobian_Cols = 0
          jacobian_Rows = 0
          if ( got(f_lowBound) ) call getInBounds ( state, lowBound, 'low' )
          if ( got(f_highBound) ) call getInBounds ( state, highBound, 'high' )

          select case (method)
          case( l_lowcloud, l_highcloud)
            ! use this for testing
            if(.not. got(f_maxJ)) maxJacobians = 5
            if(.not. got(f_lambda)) initlambda = 10.
            call CloudRetrieval(Method, ConfigDatabase,configIndices,fwdModelExtra,&
               & measurements,MeasurementSD, state, OutputSD, Covariance, &
               & jacobian, chunk,maxJacobians,initlambda)
            call add_to_retrieval_timing( 'low_cloud', t1 )
          case ( l_newtonian, l_simple )
            call newtonSolver
          case default
            call MLSMessage ( MLSMSG_Error, moduleName, &
            & "this retrieval method has not yet been implemented" )
          end select

          !??? Make sure the jacobian and outputCovariance get destroyed
          !??? after ?what? happens?  Can we destroy the entire matrix
          !??? database at the end of each chunk?
          if ( .not. got(f_jacobian) ) call destroyMatrix ( jacobian )
          if ( .not. got(f_outputCovariance) ) &
            & call destroyMatrix ( outputCovariance%m )
        else
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & "No retrieval done -- error in configuration" )
        end if
        if ( got(f_fwdModelOut) ) then
          call copyVector ( fwdModelOut, v(f) )
          call copyVectorMask ( fwdModelOut, measurements )
        end if
        call deallocate_test ( configIndices, "ConfigIndices", moduleName )
        levels = saveLevels
        toggle = saveToggle
        if ( toggle(gen) ) call trace_end ( "Retrieve.retrieve" )
      case ( s_sids )
        if ( SKIPRETRIEVAL .and. switchDetail( switches, 'fiw' ) < 0 ) cycle
        call time_now ( t1 )
        call sids ( key, VectorDatabase, MatrixDatabase, HessianDatabase, configDatabase, chunk)
      case ( s_select ) ! ============ Start of select .. case ==========
        ! We'll start seeking a matching case
        call MLSSelect (key)
      case ( s_case ) ! ============ seeking matching case ==========
        ! We'll continue seeking a match unless the case is TRUE
        call MLSCase (key)
      case ( s_endSelect ) ! ============ End of select .. case ==========
        ! We'done with seeking a match
        call MLSEndSelect (key)
      case ( s_Repeat ) ! ============================== Repeat ==========
        ! We'll Repeat the section as long as the Boolean cond'n is TRUE
        RepeatLoop = Repeat(key)
        if ( .not. RepeatLoop ) exit repeat_loop
        call nextRepeat
      case ( s_skip ) ! ============================== Skip ==========
        ! We'll skip the rest of the section if the Boolean cond'n is TRUE
        if ( Skip(key) ) exit repeat_loop
      case ( s_snoop )
        snoopKey = key
        do i_key = 2, nsons(key)
          son = subtree(i_key, key)
          field = get_field_id(son)  ! tree_checker prevents duplicates
          select case ( field )
          case ( f_comment )
            call get_string ( sub_rosa(subtree(2,son)), snoopComment, strip=.true. )
          case ( f_phaseName )
            call get_string ( sub_rosa(subtree(2,son)), phaseName, strip=.true. )
          case ( f_level )
            call expr ( subtree(2,son), units, value, type )
            if ( units(1) /= phyq_dimensionless ) &
              & call announceError ( wrongUnits, field, string='no' )
            snoopLevel = nint(value(1))
          end select
a816 20
      case ( s_subset )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_begin ( "Retrieve.subset", root )
        call SetupSubset ( key, vectorDatabase )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "Retrieve.subset" )
      case ( s_time )
        if ( timing ) then
          call sayTime
        else
          call time_now ( t1 )
          timing = .true.
        end if
      case ( s_updateMask )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_begin ( "Retrieve.UpdateMask", root )
        call UpdateMask ( key, vectorDatabase )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "Retrieve.UpdateMask" )
      end select
d818 3
a820 7
      do j = firstVec, lastVec
        call destroyVectorInfo ( v(j) )
      end do

    end do ! i_sons = 2, nsons(root) - 1
    if ( .not. repeatLoop ) exit ! Otherwise, we will repeat the section
    enddo repeat_loop ! RepeatLoop
d829 1
a829 1
    if ( toggle(gen) ) call trace_end ( "Retrieve" )
d1306 1
d1308 1
d1311 1
a1311 1
      call MLSMessageCalls( 'push', constantName='FillDiagQty' )
d1335 1
a1335 1
      call MLSMessageCalls( 'pop' )
d1351 3
a1353 1
      call MLSMessageCalls( 'push', constantName='FillDiagVec' )
d1383 1
a1383 1
      call MLSMessageCalls( 'pop' )
d1550 1
d1582 1
a1582 1
      call MLSMessageCalls( 'push', constantName='NewtonSolver' )
d2893 1
a2893 1
      call MLSMessageCalls( 'pop' )
d2896 1
a2896 1
    ! ------------------------------------  NewtonSolverFailed  -----
d2938 1
a2938 1
       "$Id: RetrievalModule.f90,v 2.340 2013/07/26 22:41:44 vsnyder Exp $"
d2948 3
@


2.340
log
@Fiddling with some dump switches
@
text
@d1186 2
a1189 1
      use Tree, only: DECORATION, NSONS, SUBTREE
d1195 1
a1195 1
      integer :: I
d1198 1
d1200 4
a1203 2
        qty => getVectorQtyByTemplateIndex ( state, &
          & decoration(decoration(subtree(i,dumpQuantitiesNode))) )
d2929 1
a2929 1
       "$Id: RetrievalModule.f90,v 2.339 2013/07/12 23:25:28 vsnyder Exp $"
d2939 3
@


2.339
log
@Remove unreferenced error messages
@
text
@d1505 3
a1507 5
      logical :: D_Ndb_0  ! 'ndb' Minimum Newton method debugging output
      logical :: D_Ndb_1  ! 'Ndb' Medium Newton method debugging output
      logical :: D_Ndb_2  ! 'NDB' Maximum Newton method debugging output
      logical :: D_Neq_F  ! 'NEQ' Full normal equations (if you dare)
      logical :: D_Neq_N  ! 'neq' L_Infty norms of Normal equation blocks
d1588 2
a1589 5
      d_ndb_0 = switchDetail(switches,'ndb') > -1
      d_ndb_1 = switchDetail(switches,'Ndb') > -1
      d_ndb_2 = switchDetail(switches,'NDB') > -1
      d_neq_f = switchDetail(switches,'NEQ') > -1
      d_neq_n = switchDetail(switches,'neq') > -1
d2141 1
a2141 1
            if ( d_neq_n ) &
d2173 1
a2173 1
              & nwt_flag, prev_nwt_flag, d_ndb_2, aj )
d2177 1
a2177 1
            if ( d_neq_f ) &
d2250 1
a2250 1
              & nwt_flag, prev_nwt_flag, d_ndb_2, aj )
d2306 1
a2306 1
              & nwt_flag, prev_nwt_flag, d_ndb_2, aj )
d2331 4
a2334 3
            if ( d_neq_f ) &
              & call dump ( normalEquations%m, 'Normal Equations', 2, clean=d_drmc )
            if ( d_neq_n ) call dump_Linf ( normalEquations%m, &
d2337 1
d2355 1
a2355 1
              & nwt_flag, prev_nwt_flag, d_ndb_2, aj )
d2385 1
a2385 1
              & nwt_flag, prev_nwt_flag, d_ndb_2, aj )
d2397 1
a2397 1
              & nwt_flag, prev_nwt_flag, d_ndb_2, aj )
d2411 1
a2411 1
              & nwt_flag, prev_nwt_flag, d_ndb_2, aj )
d2436 1
a2436 1
              & nwt_flag, prev_nwt_flag, d_ndb_2, aj )
d2491 3
a2493 5
            if ( d_ndb_0 ) &
              & call my_nwtdb ( width=9, level=0, why='After Solve' )
            if ( d_ndb_1 ) then
              if ( d_sca ) then
                call my_nwtdb ( width=9, why='After Solve' )
d2495 1
a2495 1
                call my_nwtdb ( aj, width=9, why='After Solve' )
d2691 1
a2691 1
          if ( d_ndb_2 ) call my_nwtdb ( aj, width=9 )
d2695 3
a2697 5
        if ( d_ndb_2 ) then
          call my_nwtdb ( aj, width=9 )
        else if ( d_ndb_1 ) then
          if ( d_sca ) then
            call my_nwtdb ( width=9 )
d2699 1
a2699 1
            call my_nwtdb ( aj, width=9 )
d2885 1
a2885 1
      & D_NDB_2, AJ )
d2890 1
a2890 1
      logical, intent(in) :: D_NDB_2           ! "dump AJ"
d2901 1
a2901 1
          if ( d_ndb_2 ) call my_nwtdb ( aj, width=9 )
d2925 1
a2925 1
       "$Id: RetrievalModule.f90,v 2.338 2013/06/12 02:38:50 vsnyder Exp $"
d2935 3
@


2.338
log
@Cruft removal
@
text
@d272 1
a272 4
    integer, parameter :: BadOpticalDepthSignal = 1
    integer, parameter :: BadOpticalDepthQuantities = BadOpticalDepthSignal + 1
    ! Only one of two required fields supplied
    integer, parameter :: BothOrNeither = BadOpticalDepthQuantities + 1
d275 4
a278 13
    integer, parameter :: IfUnitsAThenB = IfAThenB + 1
    integer, parameter :: Inconsistent = IfUnitsAThenB + 1  ! Inconsistent fields
    integer, parameter :: InconsistentQuantities = Inconsistent + 1
    integer, parameter :: InconsistentUnits = InconsistentQuantities + 1
    integer, parameter :: NeedBothDepthAndCutoff = InconsistentUnits + 1
    integer, parameter :: NotGeneral = NeedBothDepthAndCutoff + 1 ! Not a general matrix
    integer, parameter :: NotSPD = notGeneral + 1    ! Not symmetric pos. definite
    integer, parameter :: RangeNotAppropriate = NotSPD + 1
    integer, parameter :: WrongUnits = RangeNotAppropriate + 1
    integer, parameter :: MustHaveOne = WrongUnits + 1
    integer, parameter :: CannotFlagCloud = MustHaveOne + 1
    integer, parameter :: BadQuantities = CannotFlagCloud + 1
    integer, parameter :: BadChannel = BadQuantities + 1
d829 1
d831 1
a831 1
    subroutine AnnounceError ( Code, FieldIndex, AnotherFieldIndex, String, Lit )
d833 1
a833 1
      use INTRINSIC, only: FIELD_INDICES, SPEC_INDICES
a839 1
      integer, optional, intent(in) :: LIT
a845 11
      case ( badChannel)
        call output ( 'Number of cloud channels must be 1')
      case ( cannotFlagCloud )
        call output ( 'Cannot flag clouds, missing input quantities' )
      case ( badQuantities )
        call output ( 'Bad quantity type for radiance or cloud radiance' )
      case ( badOpticalDepthSignal )
        call output ( 'Mismatch in signal/sideband for radiance and optical depth', &
          & advance='yes' )
      case ( badOpticalDepthQuantities )
        call output ( 'Bad quantity type for radiance or optical depth' )
a860 8
      case ( ifUnitsAThenB )
        call output ( 'If the units of the ' )
        call display_string ( field_indices(fieldIndex) )
        call output ( ' field are ' )
        call output ( trim(string) )
        call output ( ' the ' )
        call display_string ( field_indices(anotherFieldIndex) )
        call output ( ' field shall also appear.', advance='yes' )
a875 17
      case ( inconsistentQuantities )
        call output ( 'the quantities of the "' )
        call display_string ( field_indices(fieldIndex) )
        call output ( '" field are inconsistent with the quantities of the "' )
        call display_string ( field_indices(anotherFieldIndex ) )
        call output ( '" field.', advance='yes' )
      case ( inconsistentUnits )
        call output ( 'the elements of the "' )
        call display_string ( field_indices(fieldIndex) )
        call output ( '" field have inconsistent units.', advance='yes' )
      case ( needBothDepthAndCutoff )
        call output ( 'OpticalDepth specified but no cutoff, or visa versa', &
          & advance='yes' )
      case ( rangeNotAppropriate )
        call output ( 'Ranges are not appropriate for a ' )
        call display_string ( spec_indices(fieldIndex) )
        call output ( ' specification.', advance='yes' )
a881 3
      case ( mustHaveOne )
        call output ( 'Must supply one and only one of height, ignore or reset', &
          & advance='yes' )
d2932 1
a2932 1
       "$Id: RetrievalModule.f90,v 2.337 2013/04/24 00:37:42 pwagner Exp $"
d2942 3
@


2.337
log
@Added InitRepeat and NextRepeat calls to set/increment r/t Boolean count
@
text
@a1519 1
      use REGULARIZATION, only: REGULARIZE
d2983 1
a2983 1
       "$Id: RetrievalModule.f90,v 2.336 2013/04/22 17:51:57 pwagner Exp $"
d2993 3
@


2.336
log
@Reevaluate may store a literal instead of a Boolean value
@
text
@d33 2
a34 2
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, HessianDatabase, &
    & ConfigDatabase, chunk, FileDataBase )
d47 1
a47 1
      & DUMPCOMMAND, &
d120 8
a127 9
    integer, intent(in) :: Root         ! Of the relevant subtree of the AST;
                                        ! It indexes an n_cf vertex
    type(vector_T), dimension(:), target :: VectorDatabase
    type(matrix_Database_T), dimension(:), pointer :: MatrixDatabase
    type(Hessian_T), dimension(:), pointer :: HessianDatabase
    type(forwardModelConfig_T), dimension(:), pointer :: ConfigDatabase

    type(MLSChunk_T), intent(inout) :: CHUNK
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
d306 1
d780 1
d2984 1
a2984 1
       "$Id: RetrievalModule.f90,v 2.335 2013/04/17 00:05:25 pwagner Exp $"
d2994 3
@


2.335
log
@Added new Repeat control structure to Fill, Retrieve sections
@
text
@d380 1
a380 1
        call decorate ( key,  BooleanFromFormula ( 0, key ) )
d2983 1
a2983 1
       "$Id: RetrievalModule.f90,v 2.334 2013/03/01 01:12:15 pwagner Exp $"
d2993 3
@


2.334
log
@'fiw' switch dumps sids instance window even if retrieval skipped
@
text
@d48 1
a48 1
      & MLSCASE, MLSENDSELECT, MLSSELECT, MLSSELECTING, SKIP
d79 1
a79 1
      & S_ENDSELECT, S_REEVALUATE, S_RESTRICTRANGE, S_RETRIEVE, &
d208 1
d306 1
d316 3
d776 4
d782 1
a782 1
        if ( Skip(key) ) exit
d826 2
d2983 1
a2983 1
       "$Id: RetrievalModule.f90,v 2.333 2012/10/11 22:03:46 pwagner Exp $"
d2993 3
@


2.333
log
@Fix timing error; print chunkNumber, phaseName instead of module when warning of abandoning
@
text
@d759 1
a759 1
        if ( SKIPRETRIEVAL ) cycle
d2972 1
a2972 1
       "$Id: RetrievalModule.f90,v 2.332 2012/09/13 18:08:34 vsnyder Exp $"
d2982 3
@


2.332
log
@Don't include tikhonov row count if covSansReg is set
@
text
@d93 2
a94 1
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES, ADD_TO_RETRIEVAL_TIMING
d99 1
d102 1
a102 1
    use Set_Toggles_m, only: Set_Toggles
d191 2
d309 1
a309 1
    if ( timing ) call time_now ( t1 )
d938 3
a940 3
      use MatrixModule_1, only: ClearMatrix, ColumnScale, Dump, Dump_Struct, &
        & FormNormalEquations => NormalEquations, GetDiagonal
      use Regularization, only: Regularize
d953 2
a954 1
        call add_to_retrieval_timing( 'newton_solver', t1 )
d1023 1
a1037 1
          call add_to_retrieval_timing( 'tikh_reg', t1 )
d1604 1
a1604 1
      real :: T1
d1747 4
d1752 1
a1752 1
            & 'Retrieval abandoned because DNWT appears to be looping.' )
d2034 1
d2931 2
a2932 2
    subroutine NewtonSolverFailed ( Why, Nwt_Flag, Prev_Nwt_Flag, &
      & D_ndb_2, AJ )
d2934 4
a2937 4
      character(len=*), intent(in) :: Why      ! What failed
      integer, intent(inout) :: Nwt_Flag       ! Solver's state flag
      integer, intent(inout) :: Prev_Nwt_Flag  ! Solver's previous state
      logical, intent(in) :: D_ndb_2           ! "dump AJ"
d2972 1
a2972 1
       "$Id: RetrievalModule.f90,v 2.331 2012/09/12 22:51:40 vsnyder Exp $"
d2982 3
@


2.331
log
@Tell DNWT what lambdaMin is
@
text
@d1218 1
a1218 1
    ! ---------------------------------------------   DumpStateQuantities --
d1239 1
a1239 1
    ! ---------------------------------------------   DumpRetrievalConfig --
d1362 1
a1362 1
    ! ----------------------------------------------  FillDiagVec ------
d1480 1
a1480 1
    ! ------------------------------------------  NewtonSolver  -----
a1865 2
            if ( .not. (got(f_outputCovariance) .or. got(f_outputSD) .or. &
              &         got(f_average)) ) exit NEWT ! no
d1867 4
a2249 1
          if ( tikhonovNeeded ) jacobian_rows = jacobian_rows + tikhonovRows
d2259 1
d2962 1
a2962 1
       "$Id: RetrievalModule.f90,v 2.330 2012/08/30 23:01:18 vsnyder Exp $"
d2972 3
@


2.330
log
@Procedurize Tikhonov, add lambdaMin
@
text
@d1737 1
d2960 1
a2960 1
       "$Id: RetrievalModule.f90,v 2.329 2012/08/16 18:07:23 pwagner Exp $"
d2970 3
@


2.329
log
@Exploit level 2-savvy MLSMessage
@
text
@d58 2
a59 1
      & F_HREGWEIGHTVEC, F_JACOBIAN, F_LAMBDA, F_LEVEL, F_LOWBOUND, &
d130 1
d183 1
d386 1
d504 2
a505 2
          case ( f_aprioriScale, f_fuzz, f_lambda, f_maxJ, f_muMin, &
            &    f_toleranceA, f_toleranceF, f_toleranceR )
d516 2
d920 117
d1956 2
a1957 48
            !{ Tikhonov regularization is of the form ${\bf R x}_{n+1} \simeq
            !  {\bf 0}$ or ${\bf R x}_{n+1} \simeq {\bf a}$, where {\bf a} is
            !  the apriori. So that all of the parts of the problem are solving
            !  for ${\bf\delta x}$, we subtract ${\bf R x}_n$ from both sides
            !  to get ${\bf R \delta x} \simeq -{\bf R x}_n$ or ${\bf R \delta
            !  x} \simeq {\bf R} ( {\bf a - x}_n)$.

            do t = 1, 2 ! Vertical, then Horizontal regularization
              if ( t == 1 ) then
                if ( .not. got(f_vRegOrders) ) cycle
                call regularize ( tikhonov, vRegOrders, vRegQuants, vRegWeights, &
                  & vRegWeightVec, tikhonovRows, horiz=.false. )
              else
                if ( .not. got(f_hRegOrders) ) cycle
                call regularize ( tikhonov, hRegOrders, hRegQuants, hRegWeights, &
                  & hRegWeightVec, tikhonovRows, horiz=.true. )
              end if
              if ( tikhonovApriori ) then ! reg_*_x := R * (apriori - x)
                call multiplyMatrixVectorNoT ( tikhonov, v(reg_RHS), v(reg_X_x) )
              else                          ! reg_*_x := -R * x
                call multiplyMatrixVectorNoT ( tikhonov, v(x), v(reg_X_x) )
                call scaleVector ( v(reg_X_x), -1.0_r8 )   ! -R x_n
              end if
                if ( d_reg ) then
                  if ( t == 1 ) then
                    call output ( 'Dumping Tikhonov for vertical regularization', &
                      & advance='yes' )
                  else
                    call output ( 'Dumping Tikhonov for horizontal regularization', &
                      & advance='yes' )
                  end if
                  call dump_struct ( tikhonov, 'Tikhonov' )
                  call dump ( tikhonov, name='Tikhonov', details=2 )
                end if
              call formNormalEquations ( tikhonov, normalEquations, &
                & v(reg_X_x), v(aTb), update=update, useMask=.false. )
              update = .true.
              call clearMatrix ( tikhonov )           ! free the space
              ! aj%fnorm is still the square of the norm of f
              aj%fnorm = aj%fnorm + ( v(reg_X_x) .dot. v(reg_X_x) )
              if ( d_fnorm > -1 ) then
                if ( t == 1 ) then
                  call output ( 'Vertical Regularization contribution to | F |^2 = ' )
                else
                  call output ( 'Horizontal Regularization contribution to | F |^2 = ' )
                end if
                call output ( v(reg_X_x) .dot. v(reg_X_x), advance='yes' )
              end if
a1958 5
              ! call destroyVectorValue ( v(reg_X_x) )  ! free the space
              ! Don't destroy reg_X_x unless we move the 'clone' for it
              ! inside the loop.  Also, if we destroy it, we can't snoop it.
                call add_to_retrieval_timing( 'tikh_reg', t1 )
            end do ! t
d2109 2
a2110 15
            !{ Tikhonov regularization is of the form ${\bf R x}_{n+1} \simeq
            !  {\bf 0}$. So that all of the parts of the problem are solving
            !  for ${\bf\delta x}$, we subtract ${\bf R x}_n$ from both sides
            !  to get ${\bf R \delta x} \simeq -{\bf R x}_n$.

            do t = 1, 2 ! Vertical, then Horizontal regularization
              if ( t == 1 ) then
                if ( .not. got(f_vRegOrders) ) cycle
                call regularize ( tikhonov, vRegOrders, vRegQuants, vRegWeights, &
                  & vRegWeightVec, tikhonovRows, horiz=.false. )
              else
                if ( .not. got(f_hRegOrders) ) cycle
                call regularize ( tikhonov, hRegOrders, hRegQuants, hRegWeights, &
                  & hRegWeightVec, tikhonovRows, horiz=.true. )
              end if
a2111 54
              ! Get the column scale vector.
              select case ( columnScaling )
              case ( l_apriori ) ! v(columnScaleVector) := apriori
                call copyVector ( v(columnScaleVector), apriori )
              case ( l_covariance )
                !??? Can't get here until allowed by init_tables
              case ( l_norm ) ! v(columnScaleVector) := diagonal of normal
                              !                         equations = column norms^2
                call getDiagonal ( normalEquations%m, v(columnScaleVector) )
              end select

              if ( tikhonovApriori ) then
                call multiplyMatrixVectorNoT ( tikhonov, v(reg_RHS), v(reg_X_x) )
              else
                call multiplyMatrixVectorNoT ( tikhonov, v(x), v(reg_X_x) )
                call scaleVector ( v(reg_X_x), -1.0_r8 )   ! -R x_n
              end if
              call scaleVector ( v(reg_X_x), -1.0_r8 )   ! -R x_n

              if ( columnScaling /= l_none ) then ! Compute $\Sigma$
                do j = 1, v(columnScaleVector)%template%noQuantities
                  where ( v(columnScaleVector)%quantities(j)%values <= 0.0 )
                    v(columnScaleVector)%quantities(j)%values = 0.0
                  elsewhere
                    v(columnScaleVector)%quantities(j)%values = &
                      & sqrt( v(columnScaleVector)%quantities(j)%values )
                  end where
                end do
                call columnScale ( tikhonov, v(columnScaleVector) )
              end if

                if ( d_reg ) then
                  call dump_struct ( tikhonov, 'Tikhonov' )
                  call dump ( tikhonov, name='Tikhonov', details=2 )
                end if
              call formNormalEquations ( tikhonov, normalEquations, &
                & v(reg_X_x), v(aTb), update=update, useMask=.false. )
              update = .true.
              call clearMatrix ( tikhonov )           ! free the space
              ! aj%fnorm is still the square of the norm of f
              aj%fnorm = aj%fnorm + ( v(reg_X_x) .dot. v(reg_X_x) )
              if ( d_fnorm > -1 ) then
                if ( t == 1 ) then
                  call output ( 'Vertical Regularization contribution to | F |^2 = ' )
                else
                  call output ( 'Horizontal Regularization contribution to | F |^2 = ' )
                end if
                call output ( v(reg_X_x) .dot. v(reg_X_x), advance='yes' )
              end if
              ! call destroyVectorValue ( v(reg_X_x) )  ! free the space
              ! Don't destroy reg_X_x unless we move the 'clone' for it
              ! inside the loop.  Also, if we destroy it, we can't snoop it.
                call add_to_retrieval_timing( 'tikh_reg', t1 )
            end do ! t
d2356 1
d2959 1
a2959 1
       "$Id: RetrievalModule.f90,v 2.328 2012/07/26 02:07:11 vsnyder Exp $"
d2969 3
@


2.328
log
@Remove unused cruft
@
text
@d21 1
a21 1
  implicit NONE
d55 1
a55 1
      & F_DIAGNOSTICS, F_DIAGONAL, F_DumpQuantities, F_EXTENDEDAVERAGE, &
d89 3
a91 2
    use MLSL2OPTIONS, only: SKIPRETRIEVAL, SPECIALDUMPFILE, &
      & STATEFILLEDBYSKIPPEDRETRIEVALS
d94 1
a94 1
      & MLSMESSAGE, MLSMESSAGECALLS, MLSMESSAGERESET
d113 1
a113 1
      & DESTROYVECTORINFO, DumpVectorNorms, GETVECTORQUANTITYBYTYPE, M_LINALG, &
d314 1
d400 1
d1097 3
a1099 3
      use VectorsModule, only: Dump, GetVectorQtyByTemplateIndex, &
        & Vector_t, VectorValue_t
      use Tree, only: Decoration, NSons, Subtree
d1119 1
a1119 1
      use VectorsModule, only: DUMPNICEMASKSUMMARY, m_tikhonov, m_fullderivatives
d2953 1
a2953 1
       "$Id: RetrievalModule.f90,v 2.327 2012/07/04 02:13:03 vsnyder Exp $"
d2963 3
@


2.327
log
@Add dump of residuals.  Add dumpQuantities node to select quantities of
the state vector to dump during the Newton iteration.  Remove masked rows
and columns from the counts, to compute DOF correctly.
@
text
@d80 1
a80 1
    use INTRINSIC, only: L_VMR, PHYQ_DIMENSIONLESS
a93 1
    use Molecules, only: L_EXTINCTION, L_EXTINCTIONV2
d104 1
a104 1
    use TOGGLES, only: EMIT, GEN, SWITCHES, TOGGLE, LEVELS
a199 1
    type(vectorValue_T), pointer :: Qty ! A temporary value used for checking
a1103 1
      integer :: QuantityIndex
a1105 1
call output ( decoration(decoration(subtree(i,dumpQuantitiesNode))), before='Quantity index = ', advance='yes' )
d2950 1
a2950 1
       "$Id: RetrievalModule.f90,v 2.326 2012/06/06 20:37:56 vsnyder Exp $"
d2960 5
@


2.326
log
@Add toggles field to retrieve spec
@
text
@d55 1
a55 1
      & F_DIAGNOSTICS, F_DIAGONAL, F_EXTENDEDAVERAGE, &
d152 1
d286 1
d423 2
d1094 23
d1413 1
a1413 1
      logical :: D_Jac_F  ! 'JAC' Full Jacobian (if you dare)
d1426 1
d1498 1
a1498 1
      d_jac_f = switchDetail(switches,'JAC') > -1
d1511 1
d1587 2
d1722 2
d1954 2
a1955 2
              if ( d_jac_f ) &
                & call dump ( jacobian, name='Jacobian', details=9, clean=d_drmc )
d1965 2
d2218 4
a2221 3
          ! Compute number of rows of Jacobian actually used.  Don't count
          ! rows due to Levenberg-Marquardt stabilization.  Do count rows
          ! due to a priori or regularization.
d2223 6
d2232 1
d2236 1
d2954 1
a2954 1
       "$Id: RetrievalModule.f90,v 2.325 2012/05/08 17:50:52 pwagner Exp $"
d2964 3
@


2.325
log
@Added Select .. Case .. EndSelect control structure
@
text
@d64 1
a64 1
      & F_STATE, F_STATEMAX, F_STATEMIN, F_SWITCHES, &
d99 1
d105 1
a105 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE, LEVELS
d201 2
d370 2
d491 4
d548 2
d740 2
d2910 1
a2910 1
       "$Id: RetrievalModule.f90,v 2.324 2012/04/20 01:37:47 vsnyder Exp $"
d2920 3
@


2.324
log
@Dump vector norms using dxn, copy mask from x to candidateDx, print DOF
dump QNSQ if sca, some cannonball polishing
@
text
@d47 2
a48 1
      & DUMPCOMMAND, SKIP
d76 1
a76 1
      & S_ANYGOODVALUES, S_CATCHWARNING, S_COMPARE, &
d78 2
a79 2
      & S_REEVALUATE, S_RESTRICTRANGE, S_RETRIEVE, &
      & S_SIDS, S_SKIP, S_SNOOP, S_SUBSET, S_TIME, S_UPDATEMASK
d314 2
d734 9
d2897 1
a2897 1
       "$Id: RetrievalModule.f90,v 2.323 2012/03/13 01:48:25 vsnyder Exp $"
d2907 4
@


2.323
log
@Add drmc flag to control clean matrix printing
@
text
@d33 2
a34 2
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, HessianDatabase, ConfigDatabase, &
    & chunk, FileDataBase )
d111 1
a111 1
      & DESTROYVECTORINFO, GETVECTORQUANTITYBYTYPE, M_LINALG, &
d1355 1
d1381 1
d1439 1
d2176 2
a2177 1
            aj%chiSqNorm = aj%fnorm / max ( jacobian_rows - jacobian_cols, 1 )
d2180 2
a2181 2
                & call dump ( (/ aj%fnorm, aj%chiSqNorm /) , &
                & '     | F |    chi^2/DOF ', options='c' )
d2196 1
a2197 1
            if ( d_dvec ) call dump ( v(candidateDX), name='CandidateDX' )
d2213 4
a2226 1
          call copyVectorMask ( v(candidateDX), v(x) )
d2242 3
a2244 2
          aj%chiSqMinNorm = aj%fnmin / max ( jacobian_rows - jacobian_cols, 1 )
          aj%chiSqNorm = aj%fnorm / max ( jacobian_rows - jacobian_cols, 1 )
d2253 2
a2254 2
              call dump ( (/ aj%chiSqNorm, aj%chiSqMinNorm /), &
                & ' chi^2/DOF  chimin^2/DOF ', options='c' )
a2270 2
            if ( d_sca ) &
              & call output ( aj%qnsq, before='QN^2 = ' , advance='yes')
d2336 1
d2345 4
a2361 1
          call copyVectorMask ( v(candidateDX), v(x) )
d2388 1
d2396 4
a2418 1
          call copyVectorMask ( v(candidateDX), v(x) )
d2426 4
a2429 1
            if ( d_dvec ) call dump ( v(candidateDX), name='CandidateDX' )
d2478 3
d2885 1
a2885 1
       "$Id: RetrievalModule.f90,v 2.322 2012/03/07 01:58:40 vsnyder Exp $"
d2895 3
@


2.322
log
@Respect mask in some dot products where it should have done all along
@
text
@d1353 1
d1435 1
d1731 1
a1731 1
                  & before='A priori contribution to | F | = ', advance='yes' )
d1815 1
a1815 1
                  call output ( 'Vertical Regularization contribution to | F | = ' )
d1817 1
a1817 1
                  call output ( 'Horizontal Regularization contribution to | F | = ' )
d1894 1
a1894 1
                & call dump ( jacobian, name='Jacobian', details=9, clean=.true. )
d1962 1
a1962 1
                & before='Measurement contribution to | F | = ', advance='yes' )
d2034 1
a2034 1
                  call output ( 'Vertical Regularization contribution to | F | = ' )
d2036 1
a2036 1
                  call output ( 'Horizontal Regularization contribution to | F | = ' )
d2143 1
a2143 1
              & call dump ( normalEquations%m, 'Normal Equations', 2, clean=.true. )
d2153 1
a2153 1
            if ( d_fac_f ) call dump ( factored%m, 'Factor', 2, clean=.true. )
d2284 1
a2284 1
              & call dump ( normalEquations%m, 'Normal Equations', 2, clean=.true. )
d2315 1
a2315 1
                & name='Factored, after Marquardt', details=2, clean=.true. )
d2865 1
a2865 1
       "$Id: RetrievalModule.f90,v 2.321 2012/02/10 23:46:24 vsnyder Exp $"
d2875 3
@


2.321
log
@Add dump for kTk
@
text
@a55 1
      & F_FWMJACOBIAN, F_FWMSTATE, &
d73 1
a73 2
      & L_HIGHCLOUD, L_JACOBIAN_COLS, L_JACOBIAN_ROWS, &
      & L_LOWCLOUD, l_MIFExtinction, l_MIFExtinctionV2, &
a158 2
    type(matrix_T), pointer :: FwmJacobian ! forward model's Jacobian matrix
    type(vector_T), pointer :: FwmState    ! forward model's State vector
a168 1
    integer :: IxFwmJacobian            ! tree index of forward model's Jacobian
a186 1
    type(matrix_T), target :: MyFwmJacobian    ! for FwmJacobian to point at
d272 1
a272 3
    integer, parameter :: NeedFwmState = NeedBothDepthAndCutoff + 1
    integer, parameter :: NoMIFExtinction = NeedFwmState + 1 ! Not in fwmState
    integer, parameter :: NotGeneral = noMIFExtinction + 1 ! Not a general matrix
a282 1
    nullify ( fwmJacobian, fwmState )
a424 4
          case ( f_fwmJacobian )
            ixFwmJacobian = decoration(subtree(2,son)) ! jacobian: matrix vertex
          case ( f_fwmState )
            fwmState => vectorDatabase(decoration(decoration(subtree(2,son))))
a563 2
        if ( got(f_fwmJacobian) .and. .not. got(f_fwmState) ) &
            & call AnnounceError ( NeedFwmState )
a635 61
          if ( got(f_fwmState) ) then
            if ( got(f_fwmJacobian) ) then
              ! Get or create the forward model Jacobian
              k = decoration(ixFwmJacobian)
              if ( k == 0 ) then
                call createEmptyMatrix ( myFwmJacobian, &
                  & sub_rosa(subtree(1,ixFwmJacobian)), measurements, fwmState )
                k = addToMatrixDatabase( matrixDatabase, myFwmJacobian )
                call decorate ( ixFwmJacobian, k )
              end if
              ! Check compatability of retriever Jacobian and forward model Jacobian
              call getFromMatrixDatabase ( matrixDatabase(k), fwmJacobian )
              if ( fwmJacobian%row%vec%template%name /= measurements%template%name ) &
                & call announceError ( inconsistent, f_fwmJacobian, f_measurements )
              if ( fwmJacobian%col%vec%template%name /= fwmState%template%name ) &
                & call announceError ( inconsistent, f_fwmJacobian, f_fwmState )
            else
              fwmJacobian => myFwmJacobian
              call createEmptyMatrix ( fwmJacobian, 0, measurements, fwmState )
            end if
            ! Make sure it's possible to use the same row index for blocks
            ! of Jacobian and fwmJacobian
            if ( Jacobian%row%instFirst .neqv. fwmJacobian%row%instFirst ) &
              & call announceError ( inconsistent, f_Jacobian, f_fwmJacobian )
            ! Verify that for every quantity in State there is a corresponding
            ! one in FwmState.  Verify that vmr quantities are equivalent.
            do k = 1, size(state%quantities)
              select case ( state%quantities(k)%template%quantityType )
              case ( l_vmr )
                qty => getVectorQuantityByType ( fwmState, quantityType=l_vmr, &
                    &    molecule=state%quantities(k)%template%molecule )
                if ( state%quantities(k)%template%name /= qty%template%name ) &
                  & call announceError ( inconsistentQuantities, f_state, f_fwmState )
              case ( l_MIFExtinction ) ! All we care is that a quantity exists
                qty => getVectorQuantityByType ( fwmState, &
                    &  quantityType=l_vmr, molecule=l_extinction )
              case ( l_MIFExtinctionV2 ) ! All we care is that a quantity exists
                qty => getVectorQuantityByType ( fwmState, &
                    &  quantityType=l_vmr, molecule=l_extinctionV2 )
              case default
                qty => getVectorQuantityByType ( fwmState, &
                    &  quantityType=state%quantities(k)%template%quantityType )
                if ( state%quantities(k)%template%name /= qty%template%name ) &
                  & call announceError ( inconsistentQuantities, f_state, f_fwmState )
              end select
            end do
            ! FWM sees FwmState, so ensure no MIFExtinction in it
            do k = 1, size(fwmState%quantities)
              select case ( fwmState%quantities(k)%template%quantityType )
              case ( l_MIFExtinction, l_MIFExtinctionV2 )
                call announceError ( noMIFExtinction, fwmState%name )
              end select
            end do
          else ! FWM sees State, so ensure no MIFExtinction in it
            do k = 1, size(state%quantities)
              select case ( state%quantities(k)%template%quantityType )
              case ( l_MIFExtinction, l_MIFExtinctionV2 )
                call announceError ( noMIFExtinction, state%name )
              end select
            end do
          end if
a714 2
          if ( associated(fwmJacobian) .and. .not. got(f_fwmJacobian) ) &
            call destroyMatrix ( fwmJacobian )
a867 6
      case ( NeedFwmState )
        call output ( 'FwmJacobian specified, but fwmState not specified', &
          & advance='yes' )
      case ( noMIFExtinction )
        call display_string ( fieldIndex, & ! fieldIndex is a string index here
          & before='MIFExtinction quantity type not allowed in ', advance='yes' )
d1356 2
a1357 1
      logical :: D_Fnorm  ! 'fnorm' Contributions to | F |
d1437 2
a1438 1
      d_fnorm = switchDetail ( switches, 'fnorm' ) > -1
d1727 2
a1728 1
              if ( d_fnorm ) call output ( aj%fnorm, &
d1730 5
d1760 2
a1761 2
            if ( d_fnorm ) &
              & call output ( 'No a priori so setting | F | to zero.', advance='yes' )
d1811 1
a1811 1
              if ( d_fnorm ) then
d1884 3
a1886 9
                if ( associated(fwmState) ) then
                  call forwardModel ( configDatabase(configIndices(k)), &
                    & v(x), fwdModelExtra, v(f_rowScaled), fmStat, Jacobian, &
                    & Hessian, vectorDatabase, fwmState, fwmJacobian )
                else
                  call forwardModel ( configDatabase(configIndices(k)), &
                    & v(x), fwdModelExtra, v(f_rowScaled), fmStat, Jacobian, &
                    & Hessian, vectorDatabase )
                end if
d1958 1
a1958 1
            if ( d_fnorm ) &
d2030 1
a2030 1
              if ( d_fnorm ) then
d2215 4
a2218 3
          ! {\tt v(candidateDX)} is a temp here = $\bf v$.  See {\bf wvs-011}
          ! for derivation.
          aj%fnmin = aj%fnorm - (v(candidateDX) .dot. v(candidateDX))
d2223 1
a2223 1
            call output ( v(candidateDX) .dot. v(candidateDX), &
d2225 2
d2237 2
a2238 1
          aj%gradn = sqrt(v(gradient) .dot. v(gradient)) ! L2Norm(gradient)
d2259 2
a2260 1
          aj%qnsq = q .dot. q
d2349 2
a2350 1
          aj%fnmin = aj%fnorm**2 - (v(candidateDX) .dot. v(candidateDX))
d2364 1
a2364 1
            call output ( v(candidateDX) .dot. v(candidateDX), &
d2366 2
d2402 8
a2409 3
          aj%dxn = sqrt(v(candidateDX) .dot. v(candidateDX)) ! L2Norm(dx)
          aj%gdx = v(gradient) .dot. v(candidateDX)
          if ( .not. aj%starting ) aj%dxdxl = v(dx) .dot. v(candidateDX)
d2501 1
d2503 5
a2507 2
          if ( .not. aj%starting ) aj%dxdxl = &
            & aj%gfac * ( v(dx) .dot. v(bestGradient) )
d2534 6
a2539 2
          aj%dxdx = v(dx) .dot. v(dx)
          if ( aj%dxdx > 0.0 ) aj%dxdxl = v(dx) .dot. v(candidateDX)
d2555 5
a2559 1
          if ( .not. aj%starting ) aj%dxdxl = v(dx) .dot. v(candidateDX)
d2863 1
a2863 1
       "$Id: RetrievalModule.f90,v 2.320 2012/02/01 00:18:38 vsnyder Exp $"
d2873 3
@


2.320
log
@Remove Matrix from the Retrieve section; nobody used it, because it was broken.
@
text
@d1444 1
d1524 1
d2013 1
d2920 1
a2920 1
       "$Id: RetrievalModule.f90,v 2.319 2012/02/01 00:17:07 vsnyder Exp $"
d2930 3
@


2.319
log
@init_tables_module.f90
@
text
@d163 1
a163 1
    logical :: Got(field_first:field_last)   ! "Got this field already"
d2917 1
a2917 1
       "$Id: RetrievalModule.f90,v 2.318 2012/01/27 01:06:26 pwagner Exp $"
d2927 3
@


2.318
log
@Tried to fix memory leak created by Hessian
@
text
@d79 1
a79 1
      & S_MATRIX, S_REEVALUATE, S_RESTRICTRANGE, S_RETRIEVE, &
d165 3
a167 3
    integer :: HRegOrders               ! Regularization orders               
    integer :: HRegQuants               ! Regularization quantities           
    integer :: HRegWeights              ! Weight of regularization conditions 
d186 2
a187 2
    type(vector_T), pointer :: Measurements  ! The measurements vector
    type(vector_T), pointer :: MeasurementSD ! The measurements vector's Std. Dev.
d191 4
a194 4
    type(matrix_SPD_T), target :: MyCovariance    ! for OutputCovariance to point at
    type(matrix_T), target :: MyFwmJacobian       ! for FwmJacobian to point at
    type(hessian_T), target :: MyHessian          ! for Hessian to point at
    type(matrix_T), target :: MyJacobian          ! for Jacobian to point at
d197 1
a197 1
    type(matrix_T), pointer :: OutputAverage      ! Averaging Kernel
d210 1
a210 1
    integer :: Spec                     ! s_matrix, s_subset or s_retrieve ... 
d243 1
a243 1
    integer, parameter :: ATb = aprioriMinusX + 1  ! A^T b -- the RHS of the normal eqns    integer, parameter :: 
d279 1
a279 2
    integer, parameter :: NoFields = NeedFwmState + 1  ! No fields are allowed
    integer, parameter :: NoMIFExtinction = noFields + 1 ! Not in fwmState
a361 6
      case ( s_matrix )
        if ( toggle(gen) ) call trace_begin ( "Retrieve.matrix/vector", root )
        if ( nsons(key) /= 1 ) call announceError ( noFields, spec )
        call destroyMatrix( matrixDatabase(decoration(key)) ) ! avoids a memory leak
        call decorate ( key, 0 )
        if ( toggle(gen) ) call trace_end ( "Retrieve.matrix/vector" )
d579 1
a579 1
        
d770 1
a770 1
          
d772 1
a772 1
          case( l_lowcloud, l_highcloud) 
d780 1
a780 1
          case ( l_newtonian, l_simple ) 
a948 4
      case ( noFields )
        call output ( 'No fields are allowed for a ' )
        call display_string ( spec_indices(fieldIndex) )
        call output ( ' specification.', advance='yes' )
d974 1
a974 1
      ! given by Dx, let $b_i$ and $x_i$ be components of Bound and X. 
d984 1
a984 1
      ! However, if we are already at the bounds, and the next step 
d987 1
a987 1
      ! to a straight element-by-element modification of $\delta x_i$.      
d1317 1
a1317 1
    
d1804 1
a1804 1
            ! ( a - x_n )^T F^T F ( a - x_n ) = ( a - x_n )^T \left [ 
d1916 1
a1916 1
          if ( got(f_average) .and. .not. extendedAverage ) then 
d2172 1
a2172 1
          
d2805 1
a2805 1
            
d2851 1
a2851 1
          ! Make sure kTk is symmetrical 
d2917 1
a2917 1
       "$Id: RetrievalModule.f90,v 2.317 2012/01/04 02:14:55 vsnyder Exp $"
d2927 3
@


2.317
log
@Ensure forward model does not see MIFExtinction
@
text
@d48 1
a48 1
    use HESSIANMODULE_1, only: HESSIAN_T, CREATEEMPTYHESSIAN
a82 1
    use ManipulateVectorQuantities, only: DoHGridsMatch
d95 1
a95 2
    use Molecules, only: First_Molecule, Last_Molecule, &
      & L_Extinction, L_ExtinctionV2
d202 1
d328 1
a328 1

d635 2
a636 1
            hessian = createEmptyHessian ( 0, measurements, state )
d862 4
d877 1
a877 1
      use INTRINSIC, only: FIELD_INDICES, LIT_INDICES, SPEC_INDICES
d884 1
a884 1
      integer, intent(in), optional :: Lit ! A literal index
d1967 1
a1967 1
              ! Otherwise, we call the forward model as ususal
d2928 1
a2928 1
       "$Id: RetrievalModule.f90,v 2.316 2012/01/04 01:51:26 vsnyder Exp $"
d2938 3
@


2.316
log
@Create fwmJacobian if needed and one isn't supplied
@
text
@d281 2
a282 1
    integer, parameter :: NotGeneral = noFields + 1  ! Not a general matrix
d704 14
d956 3
d2924 1
a2924 1
       "$Id: RetrievalModule.f90,v 2.315 2011/12/21 01:42:22 vsnyder Exp $"
d2934 3
@


2.315
log
@Add MIFExtinction transformation
@
text
@d279 2
a280 2
    integer, parameter :: NeedFwmJacobian = NeedBothDepthAndCutoff + 1
    integer, parameter :: NoFields = NeedFwmJacobian + 1  ! No fields are allowed
d584 2
a585 2
        if ( got(f_fwmJacobian) .neqv. got(f_fwmState) ) &
            & call AnnounceError ( needFwmJacobian )
d657 20
a676 15
          if ( got(f_fwmJacobian) ) then
            ! Get or create the forward model Jacobian
            k = decoration(ixFwmJacobian)
            if ( k == 0 ) then
              call createEmptyMatrix ( myFwmJacobian, &
                & sub_rosa(subtree(1,ixFwmJacobian)), measurements, fwmState )
              k = addToMatrixDatabase( matrixDatabase, myFwmJacobian )
              call decorate ( ixFwmJacobian, k )
            end if
            ! Check compatability of retriever Jacobian and forward model Jacobian
            call getFromMatrixDatabase ( matrixDatabase(k), fwmJacobian )
            if ( fwmJacobian%row%vec%template%name /= measurements%template%name ) &
              & call announceError ( inconsistent, f_fwmJacobian, f_measurements )
            if ( fwmJacobian%col%vec%template%name /= fwmState%template%name ) &
              & call announceError ( inconsistent, f_fwmJacobian, f_fwmState )
d783 2
d934 2
a935 2
      case ( needFwmJacobian )
        call output ( 'FwmJacobian or fwmState specified, but not both', &
d1947 9
a1955 8
                ! This depends upon the Fortran 2008 feature that a null
                ! pointer actual argument corresponding to a nonpointer
                ! optional dummy argument is not present.  This feature,
                ! although not standard until 2008, was provided (probably
                ! by accident) by many pre-2008 compilers.
                call forwardModel ( configDatabase(configIndices(k)), &
                  & v(x), fwdModelExtra, v(f_rowScaled), fmStat, Jacobian, &
                  & Hessian, vectorDatabase, fwmState, fwmJacobian )
d2906 1
a2906 1
       "$Id: RetrievalModule.f90,v 2.314 2011/08/29 22:13:42 pwagner Exp $"
d2916 3
@


2.314
log
@Predefine Hessian object in parallel with Jacobian matrix
@
text
@d56 1
d65 2
a66 1
      & F_TOLERANCEA, F_TOLERANCEF, F_TOLERANCER, F_VREGORDERS, F_VREGQUANTS, &
d75 2
a76 2
      & L_LOWCLOUD, L_NEWTONIAN, L_NONE, L_NORM, &
      & L_NUMGRAD, L_NUMJ, L_NUMNEWT, L_SIMPLE, &
d81 1
a81 1
    use INTRINSIC, only: PHYQ_DIMENSIONLESS
d83 1
d96 2
d163 2
d175 1
d194 2
a195 1
    type(hessian_T), target :: MyHessian          ! for Jacobian to point at
d205 1
d276 2
a277 1
    integer, parameter :: InconsistentUnits = Inconsistent + 1
d279 2
a280 1
    integer, parameter :: NoFields = NeedBothDepthAndCutoff + 1  ! No fields are allowed
d292 1
d441 4
d547 1
a547 1
          endif
d554 1
a554 1
          endif
d584 2
d624 1
d657 43
d849 1
a849 1
    subroutine AnnounceError ( Code, FieldIndex, AnotherFieldIndex, String )
d851 1
a851 1
      use INTRINSIC, only: FIELD_INDICES, SPEC_INDICES
d858 1
d900 1
d914 6
d927 3
d1940 5
d1946 2
a1947 1
                  & v(x), fwdModelExtra, v(f_rowScaled), fmStat, jacobian, hessian, vectorDatabase )
d2898 1
a2898 1
       "$Id: RetrievalModule.f90,v 2.313 2011/05/09 18:24:31 pwagner Exp $"
d2908 3
@


2.313
log
@Converted to using switchDetail
@
text
@d48 1
a48 1
    use HESSIANMODULE_1, only: HESSIAN_T
d56 1
a56 1
      & F_HIGHBOUND, F_HREGORDERS, F_HREGQUANTS, F_HREGWEIGHTS, &
d186 1
d609 9
d2818 1
a2818 1
       "$Id: RetrievalModule.f90,v 2.312 2010/08/27 23:59:36 vsnyder Exp $"
d2828 3
@


2.312
log
@Removed some overly long comments that duplicate the CVS log anyway
@
text
@d40 49
a88 48
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, TrackAllocates
    use BitStuff, only: CountBits
    use Chunks_m, only: MLSChunk_T
    use CloudRetrievalModule, only: CloudRetrieval
    use DumpCommand_m, only: &
      & BooleanFromAnyGoodValues, &
      & BooleanFromCatchWarning, BooleanFromComparingQtys, BooleanFromFormula, &
      & DumpCommand, Skip
    use HessianModule_1, only: Hessian_T
    use IEEE_Arithmetic, only: IEEE_IS_NAN
    use Expr_M, only: Expr
    use ForwardModelConfig, only: ForwardModelConfig_T
    use Init_Tables_Module, only: F_apriori, F_aprioriFraction, F_aprioriScale, &
      & F_Average, F_columnScale, F_Comment, F_covariance, F_covSansReg, &
      & F_diagnostics, F_diagonal, F_extendedAverage, &
      & F_forwardModel, F_fuzz, F_fwdModelExtra, F_fwdModelOut, &
      & F_highBound, F_hRegOrders, F_hRegQuants, F_hRegWeights, &
      & F_hRegWeightVec, F_jacobian, F_lambda, F_Level, F_lowBound, &
      & F_maxJ, F_measurements, F_measurementSD, F_method, F_muMin, &
      & F_NegateSD, &
      & F_outputCovariance, F_outputSD, &
      & F_phaseName, F_precisionFactor, &
      & F_regAfter, F_regApriori, F_serial, F_SparseQuantities, &
      & F_state, F_stateMax, F_stateMin, F_switches, &
      & F_toleranceA, F_toleranceF, F_toleranceR, f_vRegOrders, f_vRegQuants, &
      & f_vRegWeights, f_vRegWeightVec, Field_first, Field_last, &
      & L_apriori, L_covariance, &
      & L_dnwt_abandoned,  L_dnwt_ajn,  L_dnwt_axmax, &
      & L_dnwt_cait, L_dnwt_chiSqMinNorm, L_dnwt_chiSqNorm, L_dnwt_count, &
      & L_dnwt_diag,  L_dnwt_dxdx, L_dnwt_dxdxl, L_dnwt_dxn,  L_dnwt_dxnl, &
      & L_dnwt_flag, L_dnwt_fnmin, L_dnwt_fnorm,  L_dnwt_gdx,  L_dnwt_gfac, &
      & L_dnwt_gradn,  L_dnwt_sq, L_dnwt_sq,  L_dnwt_sqt, &
      & L_highcloud, L_Jacobian_Cols, L_Jacobian_Rows, &
      & L_lowcloud, L_newtonian, L_none, L_norm, &
      & L_NumGrad, L_numJ, L_NumNewt, l_Simple, &
      & S_ANYGOODVALUES, S_CATCHWARNING, S_Compare, &
      & S_diff, S_dump, S_dumpBlocks, S_flagCloud, S_flushPFA, S_LeakCheck, &
      & S_matrix, S_REEVALUATE, S_restrictRange, S_retrieve, &
      & S_sids, S_SKIP, S_snoop, S_subset, S_time, S_updateMask
    use Intrinsic, only: PHYQ_Dimensionless
    use L2ParInfo, only: PARALLEL
    use MatrixModule_1, only: AddToMatrixDatabase, CopyMatrix, CreateEmptyMatrix, &
      & DestroyMatrix, GetFromMatrixDatabase, Matrix_T, Matrix_Database_T, &
      & Matrix_SPD_T, MultiplyMatrixVectorNoT, ReflectMatrix, &
      & Sparsify, MultiplyMatrix_XTY
    use MatrixTools, only: DumpBlocks
    use MLSCommon, only: R8, RV, MLSFile_T
    use MLSL2Options, only: SKIPRETRIEVAL, SPECIALDUMPFILE, &
d90 22
a111 21
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES, Add_To_Retrieval_Timing
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, &
      & MLSMessage, MLSMessageCalls, MLSMessageReset
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
    use Output_m, only: BLANKS, OUTPUT, revertoutput, switchOutput
    use PFAData_m, only: Flush_PFAData
    use SidsModule, only: SIDS
    use SnoopMLSL2, only: SNOOP
    use String_Table, only: Display_String, Get_String
    use SubsetModule, only: SETUPSUBSET, SETUPFLAGCLOUD, RESTRICTRANGE, UPDATEMASK
    use Time_M, only: Time_Now
    use Toggles, only: Gen, Switches, Toggle, Levels
    use Trace_M, only: Trace_begin, Trace_end
    use Track_m, only: ReportLeaks
    use Tree, only: Decorate, Decoration, Node_ID, Nsons, Source_Ref, Sub_Rosa, &
      & Subtree
    use Tree_Types, only: N_named
    use VectorsModule, only: ClearMask, ClearUnderMask, &
      & ClearVector, CloneVector, CopyVector, CopyVectorMask, CreateMask, &
      & DestroyVectorInfo, GetVectorQuantityByType, M_LinAlg, &
      & Vector_T, VectorValue_T
d606 1
a606 1
          if ( index ( switches, 'rtv' ) /= 0 ) call DumpRetrievalConfig
d778 3
a780 3
      use Intrinsic, only: Field_indices, Spec_indices
      use Lexer_Core, only: Print_Source
      use String_Table, only: Display_String
d1291 1
a1291 1
      use DNWT_Module, only: FlagName, NF_AITKEN, NF_BEST, NF_BIGGEST_FLAG, &
d1295 6
a1300 6
      use DNWT_Module, only: NWT, NWTA, NWTOP
      use DNWT_clone, only: ALT_NWT, ALT_NWTA, ALT_NWTOP ! Simple
      use Dump_0, only: Dump
      use ForwardModelWrappers, only: ForwardModel
      use ForwardModelIntermediate, only: ForwardModelStatus_T
      use L2FWMParallel, only: SETUPFWMSLAVES, TRIGGERSLAVERUN, &
d1302 16
a1317 16
      use MatrixModule_0, only: Dump ! The one from MatrixModule_1 ought to work ???
      use MatrixModule_1, only: AddToMatrix, CholeskyFactor, ClearMatrix, &
        & ColumnScale, CopyMatrixValue, CreateEmptyMatrix, &
        & DestroyMatrix, Dump, Dump_Linf, Dump_struct, &
        & FormNormalEquations => NormalEquations, &
        & GetDiagonal, InvertCholesky, Matrix_T, &
        & Matrix_Cholesky_T, Matrix_SPD_T, MaxL1, MinDiag, Multiply, &
        & MultiplyMatrix_XY,  MultiplyMatrix_XY_T,  &
        & RowScale, ScaleMatrix, SolveCholesky, UpdateDiagonal
      use Regularization, only: Regularize
      use ScanModelModule, only: DestroyForwardModelIntermediate
      use Symbol_Table, only: ENTER_TERMINAL
      use Symbol_Types, only: T_IDENTIFIER
      use VectorsModule, only: AddToVector, DestroyVectorInfo, &
        & Dump, Multiply, operator(.DOT.), operator(.MDOT.), operator(-), &
        & ScaleVector, SubtractFromVector
d1410 27
a1436 27
      d_atb = index ( switches, 'atb' ) /= 0
      d_col = index(switches,'col') /= 0
      d_cov = index(switches,'cov') /= 0
      d_diag = index(switches,'diag') /= 0
      d_dvec = index(switches,'dvec') /= 0
      d_fac_f = index(switches,'FAC') /= 0
      d_fac_n = index(switches,'fac') /= 0
      d_fnorm = index ( switches, 'fnorm' ) /= 0
      d_gvec = index(switches,'gvec') /= 0
      d_jac_f = index(switches,'JAC') /= 0
      d_jac_n = index(switches,'jac') /= 0
      d_mas = index ( switches, 'mas' ) /= 0
      d_mst = index(switches,'mst') /= 0
      d_ndb_0 = index(switches,'ndb') /= 0
      d_ndb_1 = index(switches,'Ndb') /= 0
      d_ndb_2 = index(switches,'NDB') /= 0
      d_neq_f = index(switches,'NEQ') /= 0
      d_neq_n = index(switches,'neq') /= 0
      d_nin = index(switches,'nin') /= 0
      d_nwt = index(switches,'nwt') /= 0
      d_reg = index(switches,'reg') /= 0
      d_sca = index(switches,'sca') /= 0
      d_spa = index(switches,'spa') /= 0
      d_strb = index(switches,'strb') /= 0
      d_svec = index(switches,'svec') /= 0
      d_vir = index(switches,'vir') /=0
      d_xvec = index(switches,'xvec') /= 0
d2808 1
a2808 1
       "$Id: RetrievalModule.f90,v 2.311 2010/08/27 06:31:45 yanovsky Exp $"
d2818 3
@


2.311
log
@Added   type(hessian_T), pointer :: Hessian  in Retrieve subroutine.
Hessian is an actual argument in a call to forwardModel.
@
text
@d168 1
a168 1
    type(hessian_T), pointer :: Hessian ! The Hessian                              ! Added by IGOR  -   Need to define Hessian related quantities (similar to Jacobian)
d1855 1
a1855 1
                  & v(x), fwdModelExtra, v(f_rowScaled), fmStat, jacobian, hessian, vectorDatabase )      ! Changed by IGOR - added 'hessian'
d2806 1
a2806 1
       "$Id: RetrievalModule.f90,v 2.309 2010/03/24 20:56:46 vsnyder Exp $"
d2816 4
@


2.310
log
@Pass Hessians, matrices to DumpCommand
@
text
@d168 1
d1855 1
a1855 1
                  & v(x), fwdModelExtra, v(f_rowScaled), fmStat, jacobian, vectorDatabase )
@


2.309
log
@Add Hessian database to DumpBlocks call
@
text
@d323 2
a324 1
          & vectors=vectorDatabase, FileDataBase=FileDataBase )
d2805 1
a2805 1
       "$Id: RetrievalModule.f90,v 2.308 2010/02/25 18:19:27 pwagner Exp $"
d2815 3
@


2.308
log
@Adds support for new Hessian database
@
text
@d325 2
a326 1
        if ( .not. SKIPRETRIEVAL ) call DumpBlocks ( key, matrixDatabase )
d2804 1
a2804 1
       "$Id: RetrievalModule.f90,v 2.307 2009/11/23 21:10:18 vsnyder Exp $"
d2814 3
@


2.307
log
@Gradiant move instead of abandonment when trouble occurs
@
text
@d33 1
a33 1
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, ConfigDatabase, &
d48 1
d116 1
d715 1
a715 1
        call sids ( key, VectorDatabase, MatrixDatabase, configDatabase, chunk)
d2803 1
a2803 1
       "$Id: RetrievalModule.f90,v 2.306 2009/10/26 17:12:39 pwagner Exp $"
d2813 3
@


2.306
log
@Added Diff command to be used like Dump in l2cf
@
text
@d174 1
a174 1
                                        ! evaluations of Newtonian method
d688 1
a688 1
            call newtonianSolver
d1280 3
a1282 2
    ! ------------------------------------------  NewtonianSolver  -----
    subroutine NewtonianSolver
d1401 1
a1401 1
      call MLSMessageCalls( 'push', constantName='NewtonianSolver' )
d1503 1
a1503 1
        call time_now ( t0 ) ! time base for Newtonian iteration
d1525 2
a1526 2
NEWT: do ! Newtonian iteration
        loopCounter = loopCOunter + 1
d1531 1
a1531 1
          exit
d1641 1
a1641 1
            if ( .not. foundBetterState ) exit
d1652 1
a1652 1
              &         got(f_average)) ) exit ! no
a2077 1
            chunk%abandoned = .true.
d2098 4
a2101 3
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Retrieval abandoned due to problem factoring normalEquations in evalJ' )
            exit NEWT
d2139 1
a2139 1
            exit
a2155 1
            chunk%abandoned = .true.
d2165 4
a2168 3
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Retrieval abandoned due to problem solving normalEquations in evalJ' )
            exit
a2211 1
            chunk%abandoned = .true.
d2213 4
a2216 3
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Retrieval abandoned due to problem solving for q in levenberg' )
            exit
a2250 1
            chunk%abandoned = .true.
d2260 4
a2263 3
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Retrieval abandoned due to problem factoring normal equations in solve' )
            exit
a2287 1
            chunk%abandoned = .true.
d2289 4
a2292 3
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Retrieval abandoned due to problem solving for aTb in solve' )
            exit
a2295 1
            chunk%abandoned = .true.
d2297 4
a2300 3
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Retrieval abandoned due to numerical problems (with radiances?)' )
            exit
a2309 1
            chunk%abandoned = .true.
d2311 4
a2314 3
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Retrieval abandoned due to numerical problems (with derivatives?)' )
            exit
a2331 1
            chunk%abandoned = .true.
d2333 4
a2336 3
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Retrieval abandoned due to problem solving normal equations in solve' )
            exit
d2544 2
a2545 2
              &    tikhonovNeeded .and. covSansReg ) ) cycle ! yes
            exit ! no
d2757 25
a2781 1
    end subroutine NewtonianSolver
d2801 1
a2801 1
       "$Id: RetrievalModule.f90,v 2.305 2009/06/23 18:46:18 pwagner Exp $"
d2811 3
@


2.305
log
@Prevent Intel from optimizing ident string away
@
text
@d75 2
a76 2
      & S_dump, S_dumpBlocks, S_flagCloud, S_flushPFA, S_LeakCheck, S_matrix, &
      & S_REEVALUATE, S_restrictRange, S_retrieve, &
d318 1
a318 1
      case ( s_dump )
d2776 1
a2776 1
       "$Id: read_apriori.f90 is it here $"
d2786 3
@


2.304
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d2773 2
a2774 2
  logical function NOT_USED_HERE()
!---------------------------- RCS Ident Info -------------------------------
d2776 1
a2776 1
       "$Id: RetrievalModule.f90,v 2.303 2009/03/14 02:43:19 honghanh Exp $"
d2778 3
a2781 3
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, not_used_here ! .mod files sometimes change if PRINT is added
  end function NOT_USED_HERE
d2786 3
@


2.303
log
@Add dnwt_abandoned and dnwt_count
@
text
@d2137 1
a2137 1
                & '     | F |    chi^2/DOF ', clean=.true. )
d2200 1
a2200 1
                & clean=.true. )
d2202 1
a2202 1
                & ' chi^2/DOF  chimin^2/DOF ', clean=.true. )
d2366 1
a2366 1
                & 'cos(G, DX)        lambda            mu', clean=.true. )
d2776 1
a2776 1
       "$Id: RetrievalModule.f90,v 2.302 2008/12/18 21:13:05 pwagner Exp $"
d2786 3
@


2.302
log
@May now dump an l2pc or allL2PCs (use with caution)
@
text
@d66 5
a70 5
      & L_dnwt_ajn,  L_dnwt_axmax,  L_dnwt_cait, L_dnwt_chiSqMinNorm, L_dnwt_chiSqNorm, &
      & L_dnwt_diag,  L_dnwt_dxdx, &
      & L_dnwt_dxdxl, L_dnwt_dxn,  L_dnwt_dxnl,  L_dnwt_flag, L_dnwt_fnmin, &
      & L_dnwt_fnorm,  L_dnwt_gdx,  L_dnwt_gfac, L_dnwt_gradn,  L_dnwt_sq, &
      & L_dnwt_sq,  L_dnwt_sqt, &
d117 1
a117 1
    type(MLSChunk_T), intent(in) :: CHUNK
d1312 2
a1313 1
      logical :: Abandoned              ! Flag to indicate numerical problems
d1367 1
a1367 1
      integer :: LoopCounter            ! Abandon after 50 * maxJ loop iterations
d1438 1
a1438 1
      abandoned = .false.
d1527 1
a1527 1
          abandoned = .true.
d2077 1
a2077 1
            abandoned = .true.
d2155 1
a2155 1
            abandoned = .true.
d2211 1
a2211 1
            abandoned = .true.
d2250 1
a2250 1
            abandoned = .true.
d2287 1
a2287 1
            abandoned = .true.
d2295 1
a2295 1
            abandoned = .true.
d2309 1
a2309 1
            abandoned = .true.
d2331 1
a2331 1
            abandoned = .true.
d2582 6
d2589 2
a2590 1
      if ( abandoned ) then
d2776 1
a2776 1
       "$Id: RetrievalModule.f90,v 2.301 2007/12/07 01:14:03 pwagner Exp $"
d2786 3
@


2.301
log
@Lets us catch warnings and assign to runtime Booleans
@
text
@d34 1
a34 1
    & chunk )
d85 1
a85 1
    use MLSCommon, only: R8, RV
d118 1
d321 1
a321 1
          & vectors=vectorDatabase )
d2768 1
a2768 1
       "$Id: RetrievalModule.f90,v 2.300 2007/11/15 22:53:16 pwagner Exp $"
d2772 1
d2778 3
@


2.300
log
@May set runtimeBooleans by anyGood.., Compare, Reevaluate commands
@
text
@d45 2
a46 1
      & BooleanFromAnyGoodValues, BooleanFromComparingQtys, BooleanFromFormula, &
d74 1
a74 1
      & S_ANYGOODVALUES, S_Compare, &
d89 2
a90 2
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning, &
      & MLSMessageCalls
d303 3
d313 2
d2767 1
a2767 1
       "$Id: RetrievalModule.f90,v 2.299 2007/11/08 03:24:39 vsnyder Exp $"
d2776 3
@


2.299
log
@Add stateMax and stateMin
@
text
@d44 3
a46 1
    use DumpCommand_m, only: DumpCommand, Skip
d73 1
d75 2
a76 2
      & S_restrictRange, S_retrieve, S_sids, S_SKIP, S_snoop, S_subset, &
      & S_time, S_updateMask
d306 5
d347 2
d2761 1
a2761 1
       "$Id: RetrievalModule.f90,v 2.298 2007/11/05 18:37:19 pwagner Exp $"
d2770 3
@


2.298
log
@May Skip remaining lines in Fill, Join, Retrieve sections depending on Boolean
@
text
@d59 2
a60 2
      & F_state, F_switches, F_toleranceA, F_toleranceF, &
      & F_toleranceR, f_vRegOrders, f_vRegQuants, &
d192 2
d269 2
a270 1
    nullify ( measurements, measurementSD, state, outputSD, sparseQuantities )
d447 10
d550 9
a566 5
          if ( associated(covariance) ) then
            if ( covariance%m%row%vec%template%name /= state%template%name .or. &
              &  covariance%m%col%vec%template%name /= state%template%name ) &
              &  call announceError ( inconsistent, f_covariance, f_state )
          end if
d571 7
a577 3
          if ( got(f_aprioriFraction) ) then
            if ( aprioriFraction%template%name /= state%template%name ) &
              & call announceError ( inconsistent, f_aprioriFraction, f_state )
d2390 12
d2751 1
a2751 1
       "$Id: RetrievalModule.f90,v 2.297 2007/10/04 20:43:12 vsnyder Exp $"
d2760 3
@


2.297
log
@Remove unused symbols
@
text
@d44 1
a44 1
    use DumpCommand_m, only: DumpCommand
d72 2
a73 2
      & S_restrictRange, S_retrieve, S_sids, S_snoop, S_subset, S_time, &
      & S_updateMask
d676 3
d2718 1
a2718 1
       "$Id: RetrievalModule.f90,v 2.296 2007/10/04 01:49:42 vsnyder Exp $"
d2727 3
@


2.296
log
@Correct a string's misspelling
@
text
@d88 1
a88 1
    use Output_m, only: BLANKS, NewLine, OUTPUT, revertoutput, switchOutput
d2715 1
a2715 1
       "$Id: RetrievalModule.f90,v 2.295 2007/10/02 22:51:27 vsnyder Exp $"
d2724 3
@


2.295
log
@Put switches field value into global switches variable so the models can
see them, then clear them at the end so they don't stick around.
@
text
@d1358 1
a1358 1
      call MLSMessageCalls( 'push', constantName='NewtonoanSolver' )
d2715 1
a2715 1
       "$Id: RetrievalModule.f90,v 2.294 2007/09/12 00:17:05 vsnyder Exp $"
d2724 4
@


2.294
log
@Simplify printing when Cholesky fails
@
text
@a177 1
    character(len=2*len(switches)) :: MySwitches
d193 2
d272 3
a350 1
        mySwitches = ''
d445 3
a447 1
            call get_string ( sub_rosa(subtree(2,son)), mySwitches, strip=.true. )
a504 1
        mySwitches = trim(mySwitches) // ',' // switches
d561 1
a561 1
          if ( index ( mySwitches, 'rtv' ) /= 0 ) call DumpRetrievalConfig
d719 4
a722 2
    if ( specialDumpFile /= ' ' ) &
      & call revertOutput
d1304 1
d1359 28
a1386 27
      ! Set flags from mySwitches
      d_atb = index ( mySwitches, 'atb' ) /= 0
      d_col = index(mySwitches,'col') /= 0
      d_cov = index(mySwitches,'cov') /= 0
      d_diag = index(mySwitches,'diag') /= 0
      d_dvec = index(mySwitches,'dvec') /= 0
      d_fac_f = index(mySwitches,'FAC') /= 0
      d_fac_n = index(mySwitches,'fac') /= 0
      d_fnorm = index ( mySwitches, 'fnorm' ) /= 0
      d_gvec = index(mySwitches,'gvec') /= 0
      d_jac_f = index(mySwitches,'JAC') /= 0
      d_jac_n = index(mySwitches,'jac') /= 0
      d_mas = index ( mySwitches, 'mas' ) /= 0
      d_mst = index(mySwitches,'mst') /= 0
      d_ndb_0 = index(mySwitches,'ndb') /= 0
      d_ndb_1 = index(mySwitches,'Ndb') /= 0
      d_ndb_2 = index(mySwitches,'NDB') /= 0
      d_neq_f = index(mySwitches,'NEQ') /= 0
      d_neq_n = index(mySwitches,'neq') /= 0
      d_nin = index(mySwitches,'nin') /= 0
      d_nwt = index(mySwitches,'nwt') /= 0
      d_reg = index(mySwitches,'reg') /= 0
      d_sca = index(mySwitches,'sca') /= 0
      d_spa = index(mySwitches,'spa') /= 0
      d_svec = index(mySwitches,'svec') /= 0
      d_vir = index(mySwitches,'vir') /=0
      d_xvec = index(mySwitches,'xvec') /= 0
d2038 6
a2043 2
              call dump ( normalEquations%m%block(matrixStatus(1),matrixStatus(1)), &
              & name='Offending block', details=9 )
d2055 1
d2254 1
d2268 1
d2715 1
a2715 1
       "$Id: RetrievalModule.f90,v 2.293 2007/09/08 00:31:49 vsnyder Exp $"
d2724 3
@


2.293
log
@Be more careful before printing name of failed Cholesky block
@
text
@d88 1
a88 1
    use Output_m, only: BLANKS, OUTPUT, revertoutput, switchOutput
d2040 3
a2042 8
            call output ( 'Consider applying or increasing the weight of Tikhonov regularization for the' )
            if ( associated(normalEquations%m%col%vec%quantities) ) then
              if ( normalEquations%m%col%vec%quantities(matrixStatus(1))%template%name > 0 ) &
                & call display_string ( &
                  & normalEquations%m%col%vec%quantities(matrixStatus(1))%template%name, &
                  & advance='yes', before=' ' )
            end if
            call output ( ' block', advance='yes' )
d2700 1
a2700 1
       "$Id: RetrievalModule.f90,v 2.292 2007/09/06 00:36:51 vsnyder Exp $"
d2709 3
@


2.292
log
@More information about failed Cholesky
@
text
@d2041 6
a2046 4
            if ( normalEquations%m%col%vec%quantities(matrixStatus(1))%template%name /= 0 ) &
              & call display_string ( &
                & normalEquations%m%col%vec%quantities(matrixStatus(1))%template%name, &
                & advance='yes', before=' ' )
d2705 1
a2705 1
       "$Id: RetrievalModule.f90,v 2.291 2007/08/20 22:05:30 pwagner Exp $"
d2714 3
@


2.291
log
@Many procedures now push their names onto MLSCallStack
@
text
@d2036 3
d2040 6
d2703 1
a2703 1
       "$Id: RetrievalModule.f90,v 2.290 2007/06/29 19:32:07 vsnyder Exp $"
d2712 3
@


2.290
log
@Make ForwardModelIntermediate_t private to ScanModelModule
@
text
@d85 2
a86 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d1089 1
d1113 1
d1129 1
d1159 1
d1351 1
d2672 2
a2673 1
        call add_to_retrieval_timing( 'newton_solver', t1 )
d2694 1
a2694 1
       "$Id: RetrievalModule.f90,v 2.289 2007/04/03 17:47:14 vsnyder Exp $"
d2703 3
@


2.289
log
@Replace pointer attribute on VectorDatabase with target attribute
@
text
@d1239 3
a1241 2
      use ForwardModelIntermediate, only: ForwardModelIntermediate_T, &
        & ForwardModelStatus_T
d1252 1
a1257 2
      use L2FWMParallel, only: SETUPFWMSLAVES, TRIGGERSLAVERUN, &
        & REQUESTSLAVESOUTPUT, RECEIVESLAVESOUTPUT
a1298 1
      type (ForwardModelIntermediate_T) :: Fmw ! Work space for forward model
d1793 1
a1793 1
                  & v(x), fwdModelExtra, v(f_rowScaled), fmw, fmStat, jacobian, vectorDatabase )
d1851 2
d2687 1
a2687 1
       "$Id: RetrievalModule.f90,v 2.288 2007/02/28 23:27:51 vsnyder Exp $"
d2696 3
@


2.288
log
@Replace FORALL by DO, since FORALL sometimes causes compilers to have trouble
@
text
@d108 1
a108 1
    type(vector_T), dimension(:), pointer :: VectorDatabase
d2686 1
a2686 1
       "$Id: RetrievalModule.f90,v 2.287 2006/12/09 00:45:35 vsnyder Exp $"
d2695 3
@


2.287
log
@Move calculation of size of Jacobian, so that ChiSqMin calculation works
correctly if zero Newton iterations are allowed.
@
text
@d1914 1
a1914 1
                forall (j = 1: v(columnScaleVector)%template%noQuantities)
d1921 1
a1921 1
                end forall
d1969 1
a1969 1
            forall (j = 1: v(columnScaleVector)%template%noQuantities)
d1976 1
a1976 1
            end forall
d2686 1
a2686 1
       "$Id: RetrievalModule.f90,v 2.286 2006/10/04 22:52:48 vsnyder Exp $"
d2695 4
@


2.286
log
@Another change from Herb:  Make Apriori fraction zero where we had to
substitute aposteriori precision to calculate the apriori fraction.
@
text
@d2046 18
a2122 18
          ! Compute number of rows of Jacobian actually used.  Don't count
          ! rows due to Levenberg-Marquardt stabilization.  Do count rows
          ! due to a priori or regularization.  Put numbers of rows and
          ! columns into diagnostic vector.
          jacobian_cols = sum(jacobian%col%nelts)
          jacobian_rows = sum(jacobian%row%nelts)
          do j = 1, measurements%template%noQuantities
            if ( associated(measurements%quantities(j)%mask) ) &
              & jacobian_rows = jacobian_rows - &
              &   countBits(measurements%quantities(j)%mask, what=m_linAlg )
          end do
          ! Correct for apriori information.  Note that there is an
          ! approximation here: We don't take any account of whether the a
          ! priori is used on an element by element basis.
          if ( got(f_apriori) ) &
            & jacobian_rows = jacobian_rows + jacobian_cols
          ! Correct for Tikhonov information.
          if ( tikhonovNeeded ) jacobian_rows = jacobian_rows + tikhonovRows
d2686 1
a2686 1
       "$Id: RetrievalModule.f90,v 2.285 2006/10/04 19:39:38 vsnyder Exp $"
d2695 4
@


2.285
log
@Correct negateSD as recommended by Herb
@
text
@d2620 5
d2631 2
a2632 4
              where ( v(diagFlagB)%quantities(qty)%values > precisionFactor &
                &     .and. v(diagFlagA)%quantities(qty)%values == 0.0_rv )
                outputSD%quantities(qty)%values = - outputSD%quantities(qty)%values
              end where
d2686 1
a2686 1
       "$Id: RetrievalModule.f90,v 2.284 2006/09/21 18:51:14 pwagner Exp $"
d2695 3
@


2.284
log
@Reduce level of dumps in SIDS version
@
text
@d2626 2
a2627 3
              where ( outputSD%quantities(qty)%values > &
                &     precisionFactor * v(diagFlagB)%quantities(qty)%values .and. &
                & v(diagFlagA)%quantities(qty)%values == 0.0_rv )
d2683 1
a2683 1
       "$Id: RetrievalModule.f90,v 2.283 2006/09/20 00:43:38 vsnyder Exp $"
d2692 3
@


2.283
log
@Implemented Herb's apriori fraction calculation
@
text
@d296 2
a297 1
        call dumpCommand ( key, forwardModelConfigs=configDatabase, &
d300 1
a300 1
        call DumpBlocks ( key, matrixDatabase )
d494 2
d2684 1
a2684 1
       "$Id: RetrievalModule.f90,v 2.282 2006/08/11 20:58:38 vsnyder Exp $"
d2693 3
@


2.282
log
@Add 'simple' method to use alternate Newton solver
@
text
@d48 2
a49 2
    use Init_Tables_Module, only: F_apriori, F_aprioriScale, F_Average, &
      & F_columnScale, F_Comment, F_covariance, F_covSansReg, &
d125 1
d210 3
a212 3
    integer :: VRegOrders                ! Regularization orders
    integer :: VRegQuants                ! Regularization quantities
    integer :: VRegWeights               ! Weight of regularization conditions
d214 1
a214 1
    character(len=63) :: WhereLeakCheck   ! From LeakCheck command, else default
d229 1
a229 1
    integer, parameter :: DX = DiagFlagB + 1  ! for negateSD case
d264 1
a264 1
    nullify ( apriori, configIndices, covariance, fwdModelOut )
d365 2
d546 4
d1245 2
a1246 2
        & MultiplyMatrix_XY_T,  RowScale, ScaleMatrix, SolveCholesky, &
        & UpdateDiagonal
d1261 3
a1263 2
                                        ! Only used when computing solution covariance/sd and needing to
                                        ! set values negative.
d1339 1
d1737 2
a1738 1
          if ( negateSD ) call copyMatrix ( aPlusRegNEQ%m, normalEquations%m )
d2499 1
d2519 2
a2520 2
      !{Compute the covariance of the solution = ${\bf S}_s = ({\bf J}^T
      ! {\bf S}_m^{-1} {\bf J})^{-1}$, where ${\bf J}$ does not include
d2522 6
a2527 5
      ! Tikhonov regularization.  Start by computing ${\bf U}^{-T}$, then
      ! $({\bf U}^T {\bf U})^{-1} = {\bf U}^{-1} {\bf U}^{-T} =
      ! ({\bf \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf J \Sigma}^T)^{-1}$.
      ! Then unscale it to ${\bf \Sigma}^T ({\bf \Sigma}^T {\bf J}^T
      ! {\bf S}_m^{-1} {\bf J \Sigma}^T)^{-1} {\bf \Sigma}^T$.
d2529 1
a2529 1
        &  got(f_average) ) ) then
d2539 1
a2539 1
            call output ( jacobian_cols, before=' rows and ' )
d2545 2
a2546 2
        call createEmptyMatrix ( temp, 0, state, state )
        call invertCholesky ( factored, temp ) ! U^{-1}
d2553 9
d2563 1
a2563 1
        call multiplyMatrix_XY_T ( temp, temp, outputCovariance%m, &
a2572 1
        call destroyMatrix ( temp )
a2573 10
        ! Scale the covariance
        if ( columnScaling /= l_none ) then
          call columnScale ( outputCovariance%m, v(columnScaleVector) )
          call rowScale ( v(columnScaleVector), outputCovariance%m )
            if ( d_cov ) then
              call time_now ( t3 )
              call output ( t3-t0, before='Scaled the Covariance matrix at ', &
                & after=' seconds', advance='yes' )
            end if
        end if
d2579 3
a2581 3
        if ( negateSD ) then
          ! We need to compute what just the a priori and regularization would give for
          ! the output covariance.
d2607 2
a2608 5
          ! Now invert it
          call createEmptyMatrix ( temp, &
            & enter_terminal('_temp', t_identifier), &
            & state, state, .not. aPlusRegNEQ%m%row%instFirst, .not. aPlusRegNEQ%m%col%instFirst )
          call InvertCholesky ( tempC, temp )
a2614 1
          ! Go through and set error bar negative if appropriate
d2617 15
a2631 8
          do qty = 1, v(diagFlagA)%template%noQuantities
            where ( outputSD%quantities(qty)%values > &
              &     precisionFactor * v(diagFlagB)%quantities(qty)%values .and. &
              & v(diagFlagA)%quantities(qty)%values == 0.0_rv )
              outputSD%quantities(qty)%values = - outputSD%quantities(qty)%values
            end where
          end do
        end if
d2681 1
a2681 1
       "$Id: RetrievalModule.f90,v 2.281 2006/08/04 18:11:33 vsnyder Exp $"
d2690 3
@


2.281
log
@Add LeakCheck command
@
text
@d70 1
a70 1
      & L_NumGrad, L_numJ, L_NumNewt, &
d634 1
a634 1
          case ( l_newtonian ) 
d1204 14
d1225 2
a1226 2
      use DNWT_Module, only: NWT, NWTA, NWTDB, NWTOP
!     use DNWT_clone, only: NWT, NWTA, NWTDB, NWTOP
d1375 5
a1379 1
      call nwt ( nwt_flag, nwt_xopt, nwt_opt )
d1470 12
a1481 3
            if ( d_nin ) & ! Turn on NWTA's internal output
              & call nwtop ( (/ 1, 1, 0 /), nwt_xopt )
          call nwta ( nwt_flag, aj )
d2294 2
a2295 1
            if ( d_ndb_0 ) call nwtdb ( width=9, level=0, why='After Solve' )
d2298 1
a2298 1
                call nwtdb ( width=9, why='After Solve' )
d2300 1
a2300 1
                call nwtdb ( aj, width=9, why='After Solve' )
d2469 1
a2469 1
          if ( d_ndb_2 ) call nwtdb ( aj, width=9 )
d2474 1
a2474 1
          call nwtdb ( aj, width=9 )
d2477 1
a2477 1
            call nwtdb ( width=9 )
d2479 1
a2479 1
            call nwtdb ( aj, width=9 )
d2668 1
a2668 1
       "$Id: RetrievalModule.f90,v 2.280 2006/08/01 02:48:33 vsnyder Exp $"
d2677 3
@


2.280
log
@Remove unused USE for .TX.
@
text
@d40 1
a40 1
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d43 1
d45 1
d71 1
a71 1
      & S_dump, S_dumpBlocks, S_flagCloud, S_flushPFA, S_matrix, &
d96 1
a103 2
    use CloudRetrievalModule, only: CloudRetrieval
    use IEEE_Arithmetic, only: IEEE_IS_NAN
d213 1
d308 9
d2640 1
a2640 1
       "$Id: RetrievalModule.f90,v 2.279 2006/07/21 20:13:29 pwagner Exp $"
d2649 3
@


2.279
log
@Can fill state even if skipping retrievals
@
text
@d76 1
a76 1
      & Matrix_SPD_T, MultiplyMatrixVectorNoT, operator(.TX.), ReflectMatrix, &
d2629 1
a2629 1
       "$Id: RetrievalModule.f90,v 2.278 2006/07/19 22:28:59 vsnyder Exp $"
d2638 3
@


2.278
log
@Cannonball polishing
@
text
@d80 2
a81 1
    use MLSL2Options, only: SKIPRETRIEVAL, SPECIALDUMPFILE
d319 1
a319 1
        if ( SKIPRETRIEVAL ) cycle
d462 19
a480 1
        end do ! i_key = 2, nsons(key)
d2629 1
a2629 1
       "$Id: RetrievalModule.f90,v 2.277 2006/06/08 23:59:46 vsnyder Exp $"
d2638 3
@


2.277
log
@Simplify column scaling, add switches field, TeXnicalities
@
text
@d1199 1
a1199 1
      use VectorsModule, only: AddToVector, DestroyVectorInfo, DivideVectors, &
d1217 2
a1218 2
      logical :: D_Cov    ! 'cov' Covariance
      logical :: D_Diag   ! 'diag' Diagonal of factored normal equations
d1220 2
a1221 2
      logical :: D_Fac_F  ! 'FAC' Full factored normal equations (if you dare)
      logical :: D_Fac_N  ! 'fac' L_Infty norms of factored normal equations blocks
d1230 1
a1230 1
      logical :: D_Ndb_2  ! 'Ndb' Maximium Newton method debugging output
d2610 1
a2610 1
       "$Id: RetrievalModule.f90,v 2.276 2006/06/06 18:54:21 vsnyder Exp $"
d2619 3
@


2.276
log
@Sharpen criteria for fresh Jacobian at the end
@
text
@d57 1
a57 1
      & F_state, F_toleranceA, F_toleranceF, &
d174 1
d243 2
a244 1
    integer, parameter :: IfAThenB = BothOrNeither + 1
d332 1
d424 2
d463 1
d466 2
d516 1
a516 1
          if ( index ( switches, 'rtv' ) /= 0 ) call DumpRetrievalConfig
d713 3
d1291 27
a1317 27
      ! Set flags from switches
      d_atb = index ( switches, 'atb' ) /= 0
      d_col = index(switches,'col') /= 0
      d_cov = index(switches,'cov') /= 0
      d_diag = index(switches,'diag') /= 0
      d_dvec = index(switches,'dvec') /= 0
      d_fac_f = index(switches,'FAC') /= 0
      d_fac_n = index(switches,'fac') /= 0
      d_fnorm = index ( switches, 'fnorm' ) /= 0
      d_gvec = index(switches,'gvec') /= 0
      d_jac_f = index(switches,'JAC') /= 0
      d_jac_n = index(switches,'jac') /= 0
      d_mas = index ( switches, 'mas' ) /= 0
      d_mst = index(switches,'mst') /= 0
      d_ndb_0 = index(switches,'ndb') /= 0
      d_ndb_1 = index(switches,'Ndb') /= 0
      d_ndb_2 = index(switches,'NDB') /= 0
      d_neq_f = index(switches,'NEQ') /= 0
      d_neq_n = index(switches,'neq') /= 0
      d_nin = index(switches,'nin') /= 0
      d_nwt = index(switches,'nwt') /= 0
      d_reg = index(switches,'reg') /= 0
      d_sca = index(switches,'sca') /= 0
      d_spa = index(switches,'spa') /= 0
      d_svec = index(switches,'svec') /= 0
      d_vir = index(switches,'vir') /=0
      d_xvec = index(switches,'xvec') /= 0
d1347 1
a1347 1
      call copyVector ( v(x), state, vectorNameText='_x', clone=.true. ) ! x := state
d1406 1
a1406 1
      call copyVector ( v(bestX), v(x) ) ! bestX := x to start things off
d1521 1
a1521 1
            call copyVector ( v(x), v(bestX) ) ! x := bestX
d1600 2
a1601 3
            if ( d_fnorm ) then
              call output ( 'No a priori so setting | F | to zero.', advance='yes' )
            end if
d1765 1
a1765 1
            ! -{\bf J}^T {\bf S}_m^{-1} {\bf f}$:
a1916 1
  
d1918 1
d1930 4
a1933 3
          ! ${\bf U}^T {\bf U} {\bf \delta \hat x} = {\bf\Sigma}^T {\bf J}^T
          ! {\bf S}_m^{-1} {\bf J \Sigma \Sigma}^{-1} {\bf \delta \hat x} =
          ! -{\bf \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf f}$.
d1989 5
d2017 3
a2019 3
          ! $\bf\delta \hat x$ is the ``Candidate DX'' that may not get
          ! used. This can be gotten without saving $\bf J$ as ${\bf f}^T
          ! {\bf f} - {\bf v}^T {\bf v}$ where ${\bf v} = {\bf U}^{-T}
d2021 1
a2021 1
          ! {\tt candidateDX} is a temp here = $\bf v$.  See {\bf wvs-011}
d2060 2
a2061 2
              call dump ( (/ aj%fnorm, aj%ajn, aj%diag, aj%fnmin, aj%gradn /), &
                & '     | F |      L1| FAC |      aj%diag      aj%fnmin         | G |', &
d2067 3
a2069 2
        ! Solve U^T q = dx, then compute ||q||**2, which is used to
        ! compute the Levenberg-Marquardt stabilization parameter.
d2133 11
a2143 9
          !{Solve for ``candidate DX'' = ${\bf \delta \hat x} = -({\bf J}^T {\bf
          ! J})^{-1} {\bf J}^T {\bf F} = -({\bf U}^T {\bf U})^{-1} {\bf J}^T 
          ! {\bf F}$ using two back solves.  First solve ${\bf U}^T {\bf y} =
          ! -{\bf J}^T {\bf F}$, then $\mathbf{U \delta \hat x}$ =
          ! $\mathbf{y}$. Meanwhile, set AJ\%FNMIN as for NWT\_FLAG =
          ! NF\_EVALJ, but taking account of Levenberg-Marquardt stabilization
          ! (actually, ``taking account of Levenberg-Marquardt stabilization''
          ! means ``not including Levenberg-Marquardt stabilization,'' which
          ! is how we did it at NF\_EVALF, so we don't need to do it now).
d2198 5
a2202 3
          ! Shorten candidateDX if necessary to stay within the bounds.
          ! We aren't ready to take the move, but NWTA needs an accurate
          ! value for the norm of candidateDX.
d2204 1
a2204 1
          if ( columnScaling /= l_none ) then
d2215 1
a2215 7
          if ( columnScaling /= l_none ) then
            ! candidateDX = dxUnScaled / columnScaleVector -- Scale into solver's space
            call divideVectors ( v(dxUnScaled), v(columnScaleVector), &
              & v(candidateDX) )
          else
            call copyVector ( v(candidateDX), v(dxUnScaled) ) ! dx = dxUnscaled
          end if
d2249 10
a2258 9
          !{Account for column scaling.  We solved for $\mathbf{\Sigma^{-1}
          ! \delta x}$ above, so multiply by $\Sigma$ (which is our
          ! variable {\tt columnScaleVector}):
          call copyVector ( v(dxUnScaled), v(dx) ) ! dxUnscaled = dx
          if ( columnScaling /= l_none ) then
            ! dxUnScaled = dxUnScaled # columnScaleVector:
            call multiply ( v(dxUnScaled), v(columnScaleVector) )
          end if
          ! Shorten dxUnscaled if necessary to stay within the bounds
d2300 5
d2306 1
a2306 1
          call scaleVector ( v(bestGradient), aj%gfac, v(dx) )
d2313 1
a2313 1
            if ( d_gvec ) call dump ( v(dx), name='Gradient move from best X' )
d2345 1
a2346 1
          ! dx = aj%cait * candidateDX:
d2351 2
d2354 3
d2375 1
a2375 1
          if ( .not. (got(f_apriori) .and. diagonal) ) then
d2450 8
a2457 1
      ! Compute the covariance of the solution
d2515 1
a2515 1
          ! will happen with the ptan terms which have neither a priori or smoothing.
d2563 1
a2563 1
      ! Compute the averaging kernel
d2567 1
a2567 1
          call MultiplyMatrix_XTY ( outputCovariance%m, ktkStar, outputAverage, update=.true. )
d2610 1
a2610 1
       "$Id: RetrievalModule.f90,v 2.275 2006/06/06 00:51:23 vsnyder Exp $"
d2619 3
@


2.275
log
@Move diagnostic output from NEWX to DX, DX_Aitken, and GMOVE
@
text
@d191 1
a191 1
    logical :: TikhonovApriori          ! Regularization is to aproiri, not
d194 1
d340 1
d381 1
d446 1
d575 1
a575 1
          if ( got(f_hRegOrders) .or. got(f_vRegOrders) ) then
d1276 1
a1276 1
      type(matrix_cholesky_T) :: TempC   ! For negateSD caseXoXo
d1511 4
d1516 1
a1516 1
              & got(f_average)) ) exit
d1597 1
a1597 2
          if ( (got(f_hRegOrders) .or. got(f_vRegOrders)) .and. &
            & tikhonovBefore .and. &
d1794 1
a1794 2
          if ( (got(f_hRegOrders) .or. got(f_vRegOrders)) .and. &
            & .not. tikhonovBefore .and. &
d2036 1
a2036 2
          if ( any ( got( (/f_hRegOrders, f_vRegOrders /) ) ) ) &
            & jacobian_rows = jacobian_rows + tikhonovRows
d2349 1
a2349 1
          if ( .not. got(f_apriori) .or. .not. diagonal ) then
d2356 10
a2365 3
            if ( ( got(f_outputCovariance) .or. got(f_outputSD) .or. &
              &  got(f_average) ) .and. nwt_flag == nf_tolx_best ) cycle
            exit
d2577 1
a2577 1
       "$Id: RetrievalModule.f90,v 2.274 2006/06/06 00:31:20 vsnyder Exp $"
d2586 3
@


2.274
log
@Add more diagnostic output
@
text
@a2231 3
          if ( got(f_diagnostics) ) call FillDiagVec ( diagnostics, aj, &
            & numGrad=numGrad, numJ=numJ, numNewt=numNewt, nwt_flag=nwt_flag, &
            & jacobian_rows=jacobian_rows, jacobian_cols=jacobian_cols )
d2273 3
d2314 3
d2321 4
d2565 1
a2565 1
       "$Id: RetrievalModule.f90,v 2.273 2006/06/03 01:04:59 vsnyder Exp $"
d2574 3
@


2.273
log
@Cannonball polishing
@
text
@d1162 2
a1163 2
      use DNWT_Module, only: FlagName, NF_AITKEN, NF_BEST, NF_DX, &
      & NF_DX_AITKEN, NF_EVALF, NF_EVALJ, NF_FANDJ, NF_GMOVE, NF_LEV, &
d1249 1
d1402 5
a1406 1
        if ( nwt_flag /= nf_getJ ) then ! not taking a special iteration to get J
d1500 1
a1501 1
              end if
d2330 3
d2380 3
a2382 2
      if ( got(f_diagnostics) ) call FillDiagVec ( diagnostics, aj, &
        & numGrad=numGrad, numJ=numJ, numNewt=numNewt, nwt_flag=nwt_flag, &
d2558 1
a2558 1
       "$Id: RetrievalModule.f90,v 2.272 2006/06/03 00:15:20 vsnyder Exp $"
d2567 3
@


2.272
log
@Correct updating of Levenberg-Marquardt parameter during More' and
Sorensen iteration.  Polish up some dumps.
@
text
@d1959 1
a1959 1
                & '     | F |       chi^2/n ', clean=.true. )
d2549 1
a2549 1
       "$Id: RetrievalModule.f90,v 2.271 2006/05/31 18:22:26 pwagner Exp $"
d2558 4
@


2.271
log
@Fixed bug only NAG complained about: needed Dump from MatrixModule_0
@
text
@d1172 1
a1172 1
      use MatrixModule_0, only: Dump
d1241 2
a1242 1
                                        
d1411 1
a1411 3
            call output ( ', numJ = ' )
            call output ( numJ )
            call output ( ' at ' )
d1413 1
a1413 1
            call output ( t3-t0, advance='yes' )
d1489 1
a1489 1
                call output ( &
d1491 4
a1494 4
                call output ( numJ )
                call output ( ') > maxJacobians (' )
                call output ( maxJacobians )
                call output ( ')', advance='yes' )
d1507 1
d1929 3
a1931 3
            call dump ( matrixStatus, 'matrixStatus' )
            if ( d_mst ) &
              & call dump ( normalEquations%m%block(matrixStatus(1),matrixStatus(1)), &
d1933 5
d1973 9
a1981 1
            call dump ( matrixStatus, 'matrixStatus' )
d1991 5
a1995 5
          ! used. This can be gotten without saving $\bf J$ as ${\bf \hat f}^T
          ! {\bf \hat f} - {\bf y}^T {\bf y}$ where ${\bf\hat f} = {\bf
          ! \Sigma}^T {\bf J}^T {\bf S}_m^{-1} {\bf f}$ and ${\bf y} = {\bf
          ! U}^{-T} {\bf \hat f}$. The variable {\tt candidateDX} is a
          ! temp here = $\bf y$.
d1998 8
a2005 8
            call output ( 'How can aj%fnmin be negative?  aj%fnmin = ' )
            call output ( aj%fnmin, advance='yes' )
            call output ( 'aj%fnorm = ' )
            call output ( aj%fnorm, advance='yes' )
            call output ( 'norm(candidateDX) = ' )
            call output ( v(candidateDX) .dot. v(candidateDX), advance='yes' )
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Norm of residual is imaginary!' )
d2035 1
a2035 1
                & '     | F |       L1| FAC |     aj%diag        aj%fnmin       | G |', &
d2038 1
a2038 1
                & '  chi^2/n      chimin^2/n ', clean=.true. )
d2047 1
a2047 1
            call dump ( matrixStatus, 'matrixStatus' )
d2063 1
a2063 2
        !     account of Levenberg-Marquardt stabilization.  Actually,
        !     we don't have to compute this, because we did it at NF\_EVALF;
d2067 2
a2068 1
          call updateDiagonal ( normalEquations, aj%sq**2 )
d2086 9
a2094 1
            call dump ( matrixStatus, 'matrixStatus' )
d2121 1
a2121 1
            call dump ( matrixStatus, 'matrixStatus' )
d2123 1
a2123 1
              & 'Retrieval abandoned due to problem solving aTb in solve' )
d2148 8
a2155 8
            call output ( 'How can aj%fnmin be negative?  aj%fnmin = ' )
            call output ( aj%fnmin, advance='yes' )
            call output ( 'aj%fnorm**2 = ' )
            call output ( aj%fnorm**2, advance='yes' )
            call output ( 'norm(candidateDX) = ' )
            call output ( v(candidateDX) .dot. v(candidateDX), advance='yes' )
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & "Norm of residual not in Jacobian's column space is imaginary!" )
d2163 1
a2163 1
            call dump ( matrixStatus, 'matrixStatus' )
d2199 1
a2199 1
              call dump ( (/ aj%dxn, aj%fnmin, cosine, aj%sq /), &
d2201 1
a2201 1
                & 'cos(G, DX)        lambda', clean=.true. )
a2330 2
                call output ( &
                  & 'Newton iteration terminated because of convergence at ' )
d2332 2
a2333 1
                call output ( t3-t0, advance='yes' )
a2403 1
            call output ( 'Begin covariance calculation at ' )
d2405 4
a2408 6
            call output ( t3-t0, advance='yes' )
            call output ( 'Counted ' )
            call output ( jacobian_rows )
            call output ( ' rows and ' )
            call output ( jacobian_cols )
            call output ( ' in the Jacobian matrix at ' )
d2410 2
a2411 1
            call output ( t3-t0, advance='yes' )
a2428 1
            call output ( 'U^{-1} U^{-T} at ' )
d2430 2
a2431 1
            call output ( t3-t0, advance='yes' )
a2439 1
              call output ( 'Scaled the Covariance matrix at ' )
d2441 2
a2442 1
              call output ( t3-t0, advance='yes' )
d2549 1
a2549 1
       "$Id: RetrievalModule.f90,v 2.270 2006/05/30 22:51:21 vsnyder Exp $"
d2558 3
@


2.270
log
@Precompute dump flags.  Add NumGrad and NumNewt counters.  Compute
cosine of angles between moves correctly for printing (it's already
done correctly inside dnwt_module).
@
text
@d1172 1
d2531 1
a2531 1
       "$Id: RetrievalModule.f90,v 2.269 2006/03/30 19:00:50 vsnyder Exp $"
d2540 5
@


2.269
log
@Correct CVS log comment
@
text
@d68 1
a68 1
      & L_numJ, &
d289 1
a289 1
        call dumpCOmmand ( key, forwardModelConfigs=configDatabase, &
d1059 1
a1059 1
    subroutine FillDiagVec ( diagnostics, aj, numJ, nwt_flag, &
d1064 1
d1066 1
d1088 2
d1091 3
a1093 1
        & call fillDiagQty ( diagnostics,  l_numJ, real(numJ, r8) )
d1095 1
a1095 1
        & call fillDiagQty ( diagnostics,  l_dnwt_flag, real(nwt_flag,r8) )
d1097 1
a1097 1
        & call fillDiagQty ( diagnostics,  l_jacobian_rows, real(jacobian_rows,r8) )
d1099 1
a1099 1
        & call fillDiagQty ( diagnostics,  l_jacobian_cols, real(jacobian_cols,r8) )
d1165 3
a1167 1
      & NF_TOLX_BEST, NF_TOO_SMALL, NWT, NWTA, NWTDB, NWTOP, NWT_T, RK
d1198 27
d1248 1
d1250 1
d1273 28
d1364 2
a1365 1
        if ( index(switches,'xvec') /= 0 ) call dump ( v(x), name='Original X' )
d1367 1
d1374 1
a1374 1
        if ( index(switches,'sca') /= 0 ) then
d1391 1
a1391 1
      do ! Newtonian iteration
d1400 1
a1400 1
            if ( index(switches,'nin') /= 0 ) & ! Turn on NWTA's internal output
a1402 4
          if ( nwt_flag == nf_evalj .and. prev_nwt_flag == nf_evalf ) then
            prev_nwt_flag = nf_evalj
            cycle
          end if
d1404 1
a1404 1
          if ( index(switches,'nwt') /= 0 ) then
d1415 4
d1486 1
a1486 1
          if ( index(switches,'dst') /= 0 ) call dump ( v(x), details=2, name='State' )
d1488 1
a1488 1
              if ( index(switches,'nwt') /= 0 ) then
d1548 2
a1549 4
            if ( index ( switches, 'fnorm' ) /= 0 ) then
              call output ( 'A priori contribution to | F | = ' )
              call output ( aj%fnorm, advance='yes' )
            end if
d1575 1
a1575 1
            if ( index ( switches, 'fnorm' ) /= 0 ) then
d1611 1
a1611 1
                if ( index(switches,'reg') /= 0 ) then
d1628 1
a1628 1
              if ( index ( switches, 'fnorm' ) /= 0 ) then
d1646 2
a1647 2
          ! Copy the normal equations formed thus far into a temporary matrix for the
          ! negateSD case
d1653 1
a1653 1
          if ( index(switches,'vir') /=0 ) call dump ( normalEquations%m, details=2 )
d1668 2
a1669 2
            if ( index ( switches, 'mas' ) /= 0 ) &
              & call output ( "Triggering slave forward model runs", advance='yes' )
d1706 2
d1746 1
a1746 1
              if ( index ( switches, 'atb' ) /= 0 ) call dump ( v(aTb) )
d1753 1
a1753 1
              if ( index(switches,'jac') /= 0 ) &
d1755 1
a1755 2
              if ( index(switches,'spa') /= 0 ) &
                & call dump_struct ( jacobian, &
d1770 3
a1772 4
          if ( index ( switches, 'fnorm' ) /= 0 ) then
            call output ( 'Measurement contribution to | F | = ' )
            call output ( v(f_rowScaled) .mdot. v(f_rowScaled), advance='yes' )
          end if
d1833 1
a1833 1
                if ( index(switches,'reg') /= 0 ) then
d1843 1
a1843 1
              if ( index ( switches, 'fnorm' ) /= 0 ) then
d1885 1
a1885 1
              if ( index(switches,'col') /= 0 ) &
d1905 1
a1905 2
            if ( index(switches,'gvec') /= 0 ) &
              & call dump ( v(gradient), name='gradient' )
d1916 1
a1916 1
            if ( index(switches,'neq') /= 0 ) &
d1920 1
a1920 2
            if ( index(switches,'spa') /= 0 ) &
              & call dump_struct ( normalEquations%m, &
d1924 1
a1924 1
            call choleskyFactor ( factored, normalEquations, status=matrixStatus )
d1926 13
a1938 8
            if ( any ( matrixStatus /= 0 ) ) then
              abandoned = .true.
              call dump ( matrixStatus, 'matrixStatus' )
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & 'Retrieval abandoned due to problem factoring normalEquations in evalJ' )
              exit
            end if
            if ( index(switches,'diag') /= 0 ) then
d1943 3
a1945 5
            if ( index(switches,'fac') /= 0 ) &
              call dump_Linf ( factored%m, 'L_infty norms of blocks of factor:', &
                & upper=.true. )
            if ( index(switches,'spa') /= 0 ) &
              & call dump_struct ( factored%m, &
d1947 8
a1954 7
            if ( nwt_flag == nf_getJ ) then ! taking a special iteration to get J
              aj%chiSqNorm = aj%fnorm / max ( jacobian_rows - jacobian_cols, 1 )
              aj%fnorm = sqrt(aj%fnorm)
                if ( index(switches,'sca') /= 0 ) &
                  & call dump ( (/ aj%fnorm, aj%chiSqNorm /) , &
                  & ' | F |       chi^2/n ', clean=.true. )
              exit
d1964 1
d2019 1
a2019 1
            if ( index(switches,'sca') /= 0 ) then
d2039 2
a2040 4
            if ( index(switches,'sca') /= 0 ) then
              call output ( 'QN^2 = ' )
              call output ( aj%qnsq, advance='yes' )
            end if
d2059 3
a2061 2
            if ( index(switches,'neq') /= 0 ) &
              call dump_Linf ( normalEquations%m, &
d2064 1
a2064 2
            if ( index(switches,'spa') /= 0 ) &
              & call dump_struct ( normalEquations%m, &
d2070 8
a2077 9
            if ( any ( matrixStatus /= 0 ) ) then
              abandoned = .true.
              call dump ( matrixStatus, 'matrixStatus' )
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & 'Retrieval abandoned due to problem factoring normal equations in solve' )
              exit
            end if
            if ( index(switches,'fac') /= 0 ) &
              call dump_Linf ( factored%m, &
d2080 1
a2080 2
            if ( index(switches,'spa') /= 0 ) &
              & call dump_struct ( factored%m, &
d2082 2
d2162 7
a2168 3
          ! candidateDX = dxUnScaled / columnScaleVector -- Scale into solver's space
          call divideVectors ( v(dxUnScaled), v(columnScaleVector), &
            & v(candidateDX) ) 
d2172 2
a2173 3
            if ( index(switches,'dvec') /= 0 ) &
              & call dump ( v(candidateDX), name='CandidateDX' )
            if ( index(switches,'sca') /= 0 ) then
d2183 1
a2183 1
                if ( aj%dxdxl > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
d2190 3
a2192 4
            if ( index(switches,'ndb') /= 0 ) &
              & call nwtdb ( width=9, level=0, why='After Solve' )
            if ( index(switches,'Ndb') /= 0 ) then
              if ( index(switches,'sca') /= 0 ) then
d2206 2
a2207 2
            & numJ=numJ, nwt_flag=nwt_flag, jacobian_rows=jacobian_rows, &
            & jacobian_cols=jacobian_cols )
d2221 1
a2221 4
            if ( index(switches,'dvec') /= 0 ) &
              & call dump ( v(dxUnScaled), name='dX Unscaled' )
            if ( index(switches,'xvec') /= 0 ) &
              & call dump ( v(x), name='New X' )
d2230 1
a2230 1
            if ( index(switches,'sca') /= 0 ) then
d2236 1
a2236 1
                if ( aj%dxdxl > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
d2248 1
d2254 1
a2254 3
            if ( index(switches,'dvec') /= 0 ) &
              & call dump ( v(dx), name='Gradient move from best X' )
            if ( index(switches,'sca') /= 0 ) then
d2260 1
d2275 2
a2276 3
            if ( index(switches,'dvec') /= 0 ) &
              & call dump ( v(dx), name='dx after Aitken' )
            if ( index(switches,'sca') /= 0 ) then
d2281 1
a2281 1
              if ( aj%dxdxl > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
d2286 1
d2292 1
a2292 3
            if ( index(switches,'dvec') /= 0 ) &
              & call dump ( v(dx), name='dx after dx Aitken' )
            if ( index(switches,'sca') /= 0 ) then
d2296 1
d2308 1
a2308 1
              if ( index(switches,'nwt') /= 0 ) then
d2337 1
a2337 1
          if ( index(switches,'NDB') /= 0 ) call nwtdb ( aj, width=9 )
d2339 3
a2341 3
      end do ! Newton iteration
      
        if ( index(switches,'NDB') /= 0 ) then
d2343 2
a2344 2
        else if ( index(switches,'Ndb') /= 0 ) then
          if ( index(switches,'sca') /= 0 ) then
d2352 2
a2353 2
        & numJ=numJ, nwt_flag=nwt_flag, jacobian_rows=jacobian_rows, &
        & jacobian_cols=jacobian_cols )
d2382 1
a2382 1
          if ( index(switches,'cov') /= 0 ) then
d2395 3
a2397 3
          call createEmptyMatrix ( temp, 0, state, state )
          call invertCholesky ( factored, temp ) ! U^{-1}
          if ( index(switches,'cov') /= 0 ) then
d2403 4
a2406 4
          preserveMatrixName = outputCovariance%m%name
          call multiplyMatrix_XY_T ( temp, temp, outputCovariance%m, &
            & diagonalOnly = .not. any ( got ( (/ f_outputCovariance, f_average/) ) ) ) ! U^{-1} U^{-T}
          if ( index(switches,'cov') /= 0 ) then
d2414 7
a2420 7
          call destroyMatrix ( temp )
          call add_to_retrieval_timing( 'cholesky_invert', t1 )
          ! Scale the covariance
          if ( columnScaling /= l_none ) then
            call columnScale ( outputCovariance%m, v(columnScaleVector) )
            call rowScale ( v(columnScaleVector), outputCovariance%m )
            if ( index(switches,'cov') /= 0 ) then
d2425 32
a2457 21
          outputCovariance%m%name = preserveMatrixName
          if ( associated(outputSD) ) &
            & call GetDiagonal ( outputCovariance%m, outputSD, squareRoot=.true. )

          ! Deal with possibly setting the error bar negative
          if ( negateSD ) then
            ! We need to compute what just the a priori and regularization would give for
            ! the output covariance.

            ! Firstly, we need to do some gymnastics to avoid singular matrices.  This
            ! will happen with the ptan terms which have neither a priori or smoothing.
            ! Set these such that our answer is the same as the outputSD
            call cloneVector ( v(diagFlagA), state )
            call GetDiagonal ( aPlusRegNEQ%m, v(diagFlagA) )
            do qty = 1, v(diagFlagA)%template%noQuantities
              where ( v(diagFlagA)%quantities(qty)%values <= 0.0_rv )
                ! Choose a value to let it invert properly
                v(diagFlagA)%quantities(qty)%values = outputSD%quantities(qty)%values ** (-2)
              elsewhere
                v(diagFlagA)%quantities(qty)%values = 0.0_rv
              end where
d2459 21
a2479 35
            end do
            call UpdateDiagonal ( aPlusRegNEQ, v(diagFlagA) )
            
            ! Now decompose it
            call createEmptyMatrix ( tempC%m, &
              & enter_terminal('_tempC', t_identifier), &
              & state, state, .not. aPlusRegNEQ%m%row%instFirst, .not. aPlusRegNEQ%m%col%instFirst )
            call CholeskyFactor ( tempC, aPlusRegNEQ, status=matrixStatus )
            if ( any ( matrixStatus /= 0 ) ) then
              call MLSMessage ( MLSMSG_Error, 'aPlusRegNEQ', &
                & 'Non SPD matrix to be factored: aPlusRegNEQ' )
            end if

            ! Now invert it
            call createEmptyMatrix ( temp, &
              & enter_terminal('_temp', t_identifier), &
              & state, state, .not. aPlusRegNEQ%m%row%instFirst, .not. aPlusRegNEQ%m%col%instFirst )
            call InvertCholesky ( tempC, temp )
            call MultiplyMatrix_XY_T ( temp, temp, aPlusRegCov%m, diagonalOnly=.true. )

            ! Destroy works in progress
            call DestroyMatrix ( tempC%m )
            call DestroyMatrix ( temp )

            ! Go through and set error bar negative if appropriate
            call cloneVector ( v(diagFlagB), state )
            call GetDiagonal ( aPlusRegcov%m, v(diagFlagB), squareRoot=.true. )
            do qty = 1, v(diagFlagA)%template%noQuantities
              where ( outputSD%quantities(qty)%values > &
                &     precisionFactor * v(diagFlagB)%quantities(qty)%values .and. &
                & v(diagFlagA)%quantities(qty)%values == 0.0_rv )
                outputSD%quantities(qty)%values = - outputSD%quantities(qty)%values
              end where
            end do
          end if
d2481 1
d2495 1
a2495 1
        if ( index(switches,'cov') /= 0 ) call output ( &
d2500 1
a2500 2
      if ( index(switches,'svec') /= 0 ) &
        & call dump ( state, name='Final state' )
d2530 1
a2530 1
       "$Id: RetrievalModule.f90,v 2.268 2006/03/30 18:57:01 vsnyder Exp $"
d2539 3
@


2.268
log
@Allow duplicates in [LU]SBpfaMolecules and [LU]SBlblMolecules lists
@
text
@d2469 1
a2469 1
       "$Id: RetrievalModule.f90,v 2.267 2006/03/22 23:47:14 vsnyder Exp $"
d2478 3
@


2.267
log
@Decruftification
@
text
@d1655 1
a1655 1
                ! becomes $\mathbf{W J \delta \hat x -\simeq W f}$ (actually,
d2469 1
a2469 1
       "$Id: RetrievalModule.f90,v 2.266 2006/02/10 21:17:09 pwagner Exp $"
d2478 3
@


2.266
log
@dumps may go to special dumpfile
@
text
@d942 1
a942 1
      integer :: Q, I, J                ! Loop counters
d2469 1
a2469 1
       "$Id: RetrievalModule.f90,v 2.265 2006/01/21 00:04:14 livesey Exp $"
d2478 3
@


2.265
log
@Added the start of a dump retrieval config option (-Srtv)
@
text
@d80 1
a80 1
    use MLSL2Options, only: SKIPRETRIEVAL
d84 1
a84 1
    use Output_m, only: BLANKS, OUTPUT
d271 2
d662 2
d2469 1
a2469 1
       "$Id: RetrievalModule.f90,v 2.264 2005/12/21 21:48:03 livesey Exp $"
d2478 3
@


2.264
log
@Added handling of the negateSD option.
@
text
@d502 2
d856 1
a856 1
      ! Now if mu has goten really small, we'll change it back to one,
d928 1
a928 1
            &  'How did mu get to be negative?' )
d933 84
d2465 1
a2465 1
       "$Id: RetrievalModule.f90,v 2.263 2005/06/03 02:09:46 vsnyder Exp $"
d2474 3
@


2.263
log
@New copyright notice, move Id to not_used_here to avoid cascades
@
text
@d53 1
d55 1
a55 1
      & F_phaseName, &
d174 1
d180 1
d221 3
a223 1
    integer, parameter :: DX = covarianceXApriori + 1  ! for NWT
d327 2
d394 2
d406 2
d470 5
d1094 4
d1100 1
d1131 1
d1142 1
d1491 4
d2275 54
d2379 1
a2379 1
       "$Id: RetrievalModule.f90,v 2.262 2005/05/27 23:57:03 vsnyder Exp $"
d2388 3
@


2.262
log
@Add Flush PFAData
@
text
@d1 10
a10 2
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a25 3
  character (len=*), private, parameter :: IdParm = &
       "$Id: RetrievalModule.f90,v 2.261 2005/03/15 01:27:58 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d2296 5
d2307 3
@


2.261
log
@Allow Dump command in Retrieve section
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.260 2004/06/16 23:41:39 vsnyder Exp $"
d63 3
a65 2
      & S_dump, S_dumpBlocks, S_flagCloud, S_matrix, S_retrieve, S_sids, &
      & S_snoop, S_subset, S_time, S_RESTRICTRANGE, S_UPDATEMASK
d79 1
d180 1
d281 9
a295 23
      case ( s_snoop )
        snoopKey = key
        do i_key = 2, nsons(key)
          son = subtree(i_key, key)
          field = get_field_id(son)  ! tree_checker prevents duplicates
          select case ( field )
          case ( f_comment )
            call get_string ( sub_rosa(subtree(2,son)), snoopComment, strip=.true. )
          case ( f_phaseName )
            call get_string ( sub_rosa(subtree(2,son)), phaseName, strip=.true. )
          case ( f_level )
            call expr ( subtree(2,son), units, value, type )
            if ( units(1) /= phyq_dimensionless ) &
              & call announceError ( wrongUnits, field, string='no' )
            snoopLevel = nint(value(1))
          end select
        end do
      case ( s_subset )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_begin ( "Retrieve.subset", root )
        call SetupSubset ( key, vectorDatabase )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "Retrieve.subset" )
a301 12
      case ( s_flagCloud )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_begin ( "Retrieve.flagCloud", root )
        call SetupflagCloud ( key, vectorDatabase )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "Retrieve.flagCloud" )
      case ( s_updateMask )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_begin ( "Retrieve.UpdateMask", root )
        call UpdateMask ( key, vectorDatabase )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "Retrieve.UpdateMask" )
d594 23
d624 6
d2297 3
@


2.260
log
@Put a limit on the total number of DNWT iterations, regardless of Jacobians
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.259 2004/06/16 01:21:57 vsnyder Exp $"
d38 1
d63 2
a64 2
      & S_dumpBlocks, S_flagCloud, S_matrix, S_retrieve, S_sids, S_snoop, &
      & S_subset, S_time, S_RESTRICTRANGE, S_UPDATEMASK
d273 3
a275 1
      
d2291 3
@


2.259
log
@Repair bug in constrained move
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.258 2004/06/16 00:01:36 livesey Exp $"
d433 1
a433 1
              maxJacobians = value(1)
d1082 1
d1196 1
d1198 7
d2288 3
@


2.258
log
@Bug fixes to BoundMove
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.257 2004/05/19 19:16:12 vsnyder Exp $"
d206 1
d825 1
a825 1
      ! and do an element by element modification of dx
d1055 3
a1057 3
      use VectorsModule, only: AddToVector, DestroyVectorInfo, &
        & Dump, Multiply, operator(.DOT.), &
        & operator(.MDOT.), operator(-), ScaleVector, SubtractFromVector
d1954 5
a1958 1
          if ( mu < 1.0_rv ) call scaleVector ( v(candidateDX), mu )
d2279 3
@


2.257
log
@Move MLSChunk_t to Chunks_m
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.256 2004/04/19 23:25:55 livesey Exp $"
d746 1
d748 14
d799 2
a800 2
                      & mu = ( x%quantities(iq)%values(ivx,ivy) - &
                      &        bound%quantities(iq)%values(ivx,ivy) ) &
d811 2
a812 2
                    & mu = ( x%quantities(iq)%values(ivx,ivy) - &
                    &        bound%quantities(iq)%values(ivx,ivy) ) &
d825 2
a826 2
      if ( mu < muMin ) then
        mu = 1.0_rv
d834 1
a834 1
                      &  dx%quantities(iq)%values(ivx,ivy) < &
d837 2
a838 2
                        &    bound%quantities(iq)%values(ivx,ivy) - &
                        &    x%quantities(iq)%values(ivx,ivy)
d846 1
a846 1
                    &  dx%quantities(iq)%values(ivx,ivy) < &
d849 2
a850 2
                      &    bound%quantities(iq)%values(ivx,ivy) - &
                      &    x%quantities(iq)%values(ivx,ivy)
d862 1
a862 1
                      &  dx%quantities(iq)%values(ivx,ivy) > &
d865 2
a866 2
                        &    bound%quantities(iq)%values(ivx,ivy) - &
                        &    x%quantities(iq)%values(ivx,ivy)
d874 1
a874 1
                    &  dx%quantities(iq)%values(ivx,ivy) > &
d877 2
a878 2
                      &    bound%quantities(iq)%values(ivx,ivy) - &
                      &    x%quantities(iq)%values(ivx,ivy)
a2264 1

d2274 3
@


2.256
log
@Added an only to the use of ieee_arithemtic
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.255 2004/04/19 19:23:44 livesey Exp $"
d37 1
d71 1
a71 1
    use MLSCommon, only: MLSCHUNK_T, R8, RV
d2260 3
@


2.255
log
@Better handling of NaNs in radiances or derivatives
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.254 2004/01/29 01:45:32 livesey Exp $"
d91 1
a91 1
    use IEEE_Arithmetic
d2259 3
@


2.254
log
@Removed print statement
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.253 2004/01/24 03:22:49 livesey Exp $"
d91 1
d1882 6
d1894 8
d2259 3
@


2.253
log
@Changed logistics of computing averaging kernel to preserve vectors that
describe edges.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.252 2003/10/07 01:17:52 vsnyder Exp $"
a542 1
            print*,'AVERAGE:', k
d2244 4
@


2.252
log
@Change spelling of dumpBlock to dumpBlocks
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.251 2003/09/11 23:16:11 livesey Exp $"
d543 1
a2193 1
        preserveMatrixName = outputAverage%name
d2195 2
a2196 1
          outputAverage = outputCovariance%m .tx. kTkStar
d2201 2
a2202 1
          outputAverage = outputCovariance%m .tx. kTk%m
d2204 2
a2205 3
        outputAverage%name = preserveMatrixName
          if ( index(switches,'cov') /= 0 ) call output ( &
            & 'Computed the Averaging Kernel from the Covariance', advance='yes' )
d2245 3
@


2.251
log
@Now hands vector database onto forward model to support xStar/yStar in
linearized forward model.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.250 2003/09/05 23:24:09 pwagner Exp $"
d69 1
a69 1
    use MatrixTools, only: DumpBlock
d271 1
a271 1
        call DumpBlock ( key, matrixDatabase )
d2244 4
@


2.250
log
@Skips calls to Retrieve, SIDS if SKIPRETRIEVAL
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.249 2003/07/09 23:49:13 vsnyder Exp $"
d1478 1
a1478 1
                  & v(x), fwdModelExtra, v(f_rowScaled), fmw, fmStat, jacobian )
d2244 3
@


2.249
log
@Remove numerous unreferenced USE names
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.248 2003/06/20 19:38:26 pwagner Exp $"
d71 1
d320 1
d608 1
d2244 3
@


2.248
log
@Allows direct writing of output products
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.247 2003/06/03 19:24:19 livesey Exp $"
d39 1
a39 3
    use Init_Tables_Module, only: F_additional, F_apriori, F_aprioriScale, F_Average, &
      & F_channels, F_cloudChannels, F_cloudHeight, F_cloudRadiance, &
      & F_cloudRadianceCutOff, &
d43 6
a48 7
      & F_height, f_highBound, f_hRegOrders, f_hRegQuants, f_hRegWeights, &
      & f_hRegWeightVec, F_ignore, F_jacobian, F_lambda, F_Level, f_lowBound, &
      & F_mask, F_maxJ, F_maxValue, F_measurements, &
      & F_measurementSD, F_method, F_minValue, F_muMin, &
      & F_opticalDepth, F_opticalDepthCutoff, F_outputCovariance, F_outputSD, &
      & F_phaseName, F_ptanQuantity, F_quantity, &
      & F_regAfter, F_regApriori, F_reset, F_serial, F_SparseQuantities, &
d57 1
a57 1
      & L_dnwt_sq,  L_dnwt_sqt, L_Fill, L_full_derivatives, &
d59 2
a60 2
      & L_linalg, L_lowcloud, L_newtonian, L_none, L_norm, &
      & L_numJ, L_opticalDepth, L_pressure, L_radiance, L_Tikhonov, L_zeta, &
d63 1
a63 1
    use Intrinsic, only: PHYQ_Dimensionless, PHYQ_Invalid
d70 1
a70 1
    use MLSCommon, only: MLSCHUNK_T, R8, RM, RV
d84 1
a84 2
    use Tree_Types, only: N_colon_less, N_less_colon, &
      & N_less_colon_less, N_named
d87 2
a88 3
      & DestroyVectorInfo, DumpMask, GetVectorQuantityByType, &
      & IsVectorQtyMasked, M_Fill, M_FullDerivatives, M_LinAlg, &
      & M_Tikhonov, Vector_T, VectorValue_T
d2241 3
@


2.247
log
@Added the abandoned stuff to make the chunk processing more robust.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.246 2003/05/14 23:40:51 dwu Exp $"
d478 1
a478 1
            if ( apriori%template%id /= state%template%id ) &
d482 1
a482 1
            if ( highBound%template%id /= state%template%id ) &
d486 1
a486 1
            if ( lowBound%template%id /= state%template%id ) &
d490 2
a491 2
            if ( covariance%m%row%vec%template%id /= state%template%id .or. &
              &  covariance%m%col%vec%template%id /= state%template%id ) &
d495 1
a495 1
            if ( measurementSD%template%id /= measurements%template%id ) &
d511 1
a511 1
            if ( jacobian%row%vec%template%id /= measurements%template%id ) &
d513 1
a513 1
            if ( jacobian%col%vec%template%id /= state%template%id ) &
d533 1
a533 1
              if ( outputCovariance%m%row%vec%template%id /= state%template%id &
d535 1
a535 1
                &  outputCovariance%m%col%vec%template%id /= state%template%id ) &
d557 1
a557 1
              if ( outputAverage%row%vec%template%id /= state%template%id &
d559 1
a559 1
                &  outputAverage%col%vec%template%id /= state%template%id ) &
d2246 3
@


2.246
log
@a change in cloud retr
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.245 2003/05/14 23:38:15 dwu Exp $"
d68 1
a68 1
    use MatrixModule_1, only: AddToMatrixDatabase, CreateEmptyMatrix, &
d1046 1
d1066 1
d1100 1
d1705 1
a1705 1
            call choleskyFactor ( factored, normalEquations )
d1707 7
d1739 1
a1739 1
            & transpose=.true. )
d1741 7
d1806 8
a1813 1
            & transpose=.true. ) ! q := factored^{-T} v(candidateDX)
d1846 1
a1846 1
          call choleskyFactor ( factored, normalEquations )
d1848 7
d1873 1
a1873 1
            & transpose=.true. ) ! v(candidateDX) := factored^{-T} v(aTb)
d1875 9
d1902 9
a1910 1
          call solveCholesky ( factored, v(candidateDX) )
d2102 1
a2102 1

d2117 20
d2210 2
a2211 2
        if ( index(switches,'svec') /= 0 ) &
          & call dump ( state, name='Final state' )
d2246 3
@


2.245
log
@change in cloud retrieval
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.244 2003/05/14 03:55:10 dwu Exp $"
d586 1
a586 1
            call add_to_retrieval_timing( 'low_retrieval', t1 )
d2178 3
@


2.244
log
@tidy up
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.243 2003/05/13 22:25:39 dwu Exp $"
d578 1
a578 1
	  select case (method)
d586 1
a586 1
            call add_to_retrieval_timing( 'cloud_retrieval', t1 )
d2178 3
@


2.243
log
@changes in lowcloudretrieval
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.242 2003/05/13 20:43:05 dwu Exp $"
d94 1
a94 1
    use CloudRetrievalModule, only: HighCloudRetrieval, LowCloudRetrieval
d577 7
a583 8
          select case ( method )
          case ( l_newtonian )
            call newtonianSolver
          case ( l_lowcloud )
                ! use this for testing
               if(.not. got(f_maxJ)) maxJacobians = 5
               if(.not. got(f_lambda)) initlambda = 10.
            call LowCloudRetrieval(ConfigDatabase,configIndices,fwdModelExtra,&
d586 8
a593 9
              call add_to_retrieval_timing( 'low_cloud', t1 )
          case ( l_highcloud )
               if(.not. got(f_maxJ)) maxJacobians = 5
               if(.not. got(f_lambda)) initlambda = 10.
            call HighCloudRetrieval(ConfigDatabase,configIndices,fwdModelExtra,&
               & measurements,MeasurementSD, state, OutputSD, Covariance, &
               & jacobian, chunk,maxJacobians,initlambda)
              call add_to_retrieval_timing( 'high_cloud', t1 )
          end select ! method
d2178 3
@


2.242
log
@a quick fix after spinout
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.241 2003/05/13 19:32:28 dwu Exp $"
d586 1
a586 1
               & chunk,maxJacobians,initlambda)
d593 1
a593 1
               & chunk,maxJacobians,initlambda)
d2180 3
@


2.241
log
@spin out cloud retrievals
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.240 2003/04/04 22:02:06 livesey Exp $"
d584 3
a586 4
               ! find how many MAFs        
                 nMAFs = chunk%lastMAFIndex-chunk%firstMAFIndex + 1

            call LowCloudRetrieval
d589 5
a593 1
            call HighCloudRetrieval
d2180 3
@


2.240
log
@Added call to UpdateMask
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.239 2003/03/27 20:45:22 livesey Exp $"
d94 1
d581 6
a2152 314
    ! ------------------------------------------  HighCloudRetrieval  -----
    subroutine HighCloudRetrieval

      use Intrinsic, only: L_PTAN, L_RADIANCE,                           &
                     & L_CLOUDINDUCEDRADIANCE,                           &
                     & L_CLOUDEXTINCTION,                                &
                     & L_CLOUDRADSENSITIVITY
      use MatrixModule_0, only: MatrixInversion, MATRIXELEMENT_T
      use MatrixModule_1, only: ClearMatrix, FINDBLOCK, GetDiagonal
      use MLSSignals_m, only: SIGNAL_T
      use ForwardModelWrappers, only: ForwardModel
      use ForwardModelIntermediate, only: ForwardModelIntermediate_T, &
        & ForwardModelStatus_T

      ! Local Variables
      type (ForwardModelStatus_T) :: FmStat        ! Status for forward model
      type (ForwardModelIntermediate_T) :: Fmw     ! Work space for forward model
      type (vector_T) :: FwdModelOut1               ! Forward outputs
      type (Signal_T) :: signal                    ! signal info in each model
      type (VectorValue_T), pointer :: xExtPtr        ! pointer of l_cloudExtinction quantity
      type (VectorValue_T), pointer :: xExtVar        ! variance of apriori
      type (VectorValue_T), pointer :: outExtSD        ! SD of output
      type (VectorValue_T), pointer :: ModelTcir        ! for model cloud top indicator
      type (VectorValue_T), pointer :: Tcir        ! cloud-induced radiance
      type (VectorValue_T), pointer :: Terr        ! cloud-induced radiance SD
      type (VectorValue_T), pointer :: PTAN        ! Tgt pressure
!      type (VectorValue_T), pointer :: Re        ! Earth Radius
      type (VectorValue_T), pointer :: Tb0         ! model clear sky radiance (100%RH)
      type (VectorValue_T), pointer :: Slope       ! sensitivity slope to convert cloud
                                                   ! radiance to optical depth
                                          
      integer :: i,j,i1,j1,ich,maf,mif          ! Loop subscripts
      integer :: coljBlock     ! Column index for jacobian
      integer :: rowjBlock     ! Row index for jacobian
      integer :: nFreqs      ! number of frequencies in each block
      integer :: nMafs      ! number of MAFs
      integer :: nz        ! number of retrieval levels
      integer :: nInst     ! number of retrieval instances in the chunk
      integer :: cloudysky   ! cloudysky index from Model Configuration
      real(r8) :: pcut    ! ptan threshold for high tangent heights
      real(r8) :: badValue
                                        
      type(MatrixElement_T), pointer :: JBLOCK       ! A block from the jacobian
      type(vector_T) :: CovarianceDiag  ! Diagonal of apriori Covariance  
      
      ! retrieval work arrays
      real(r8) :: sensitivity                         ! sensitivity with slope and correction
      real(r8) :: teff                                ! effective optical depth
      real(r8) :: trans                                ! transmission function
      real(r8) :: y      ! measurement array
      real(r8) :: sy     ! variance of y
      integer :: n1
      logical :: doMaf      ! array for MAF flag
      real(r8), dimension(:), allocatable :: tmp1, tmp2      ! working array
      real(rm), dimension(:,:), allocatable :: A      ! working array
      real(r8), dimension(:), allocatable :: dx       ! working array for x
      real(r8), dimension(:), allocatable :: x        ! s grid array
      real(r8), dimension(:), allocatable :: x0       ! A priori of x
      real(r8), dimension(:), allocatable :: sx0       ! variance of A priori
      real(r8), dimension(:), allocatable :: xext       ! extinction along los
      real(r8), dimension(:,:), allocatable :: sx       ! variance of x
      real(r8), dimension(:,:), allocatable :: C    ! for problem y=Kx, c=K^t#Sy^-1#K
                                                      ! last dimension is for mif
                                                      ! first two are (chan, s)

      ! use this for testing
      pcut = -2.5
      
      if (size(configIndices) > 1 .or. &
        & size(configDatabase(configIndices(1))%signals) > 1) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Only one signal is allowed in high cloud retrieval' )

      ! get signal information for this model. Note: allow only 1 signal 
        signal = configDatabase(configIndices(1))%signals(1)
      
        call allocate_test ( fmStat%rows, jacobian%row%nb, 'fmStat%rows',ModuleName )
      ! create FwdModelOut1 vector by cloning measurements
        call cloneVector ( FwdModelOut1, measurements, vectorNameText='_covarianceDiag' )          

      ! find which channel is used
        ich = 0
        nFreqs = size (signal%frequencies)
        do k=1,nFreqs
              if(signal%channels(k)) ich=k
        end do

      ! find how many MAFs        
        nMAFs = chunk%lastMAFIndex-chunk%firstMAFIndex + 1

      !memorize the initial model configuration
!        cloudysky = configDatabase(configIndices(1))%cloud_width
        cloudysky = configDatabase(configIndices(1))%i_saturation

      ! create covarianceDiag array
        call cloneVector ( covarianceDiag, state, vectorNameText='_covarianceDiag' )
      ! get the inverted diagnonal elements of covariance of apriori
        call getDiagonal ( covariance%m, covarianceDiag )
        
      ! find about the dimension of the state vector        
         xExtPtr => GetVectorQuantityByType ( state, quantityType=l_cloudextinction)
         nInst = xExtPtr%template%noInstances
         nz = xExtPtr%template%noSurfs
        
      ! allocate C, y, x matrices
          allocate(A(nz*nInst,nz*nInst),C(nz*nInst,nz*nInst))
          allocate(x(nz*nInst),x0(nz*nInst),sx0(nz*nInst),dx(nz*nInst))
          allocate(tmp1(nz),tmp2(nz))
          A = 0._rm
          C = 0._r8
          y = 0._r8
          sy = 0._r8
          dx = 0._r8
            
          ! get cloud radiance measurements for this signal
          Tcir => GetVectorQuantityByType ( Measurements,       &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )
            
          ! get cloud radiances error for this signal
          Terr => GetVectorQuantityByType ( MeasurementSD,       &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )

          ! get pointers of x covariance for the retrieval
          xExtVar => GetVectorQuantityByType (covarianceDiag, &
               & quantityType=l_cloudextinction)
      
          ! get pointers of output SD for the retrieval
          outExtSD => GetVectorQuantityByType (outputSD, &
               & quantityType=l_cloudextinction)
      
          ! get cloud radiance measurements for this signal
          ModelTcir => GetVectorQuantityByType ( fwdModelExtra,     &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )
          
          ModelTcir%values = Tcir%values
          
      ! Loop over MAFs
      do maf=1, nMAFs
      fmStat%maf = maf
                        
          ! to save time, skip cloud sensitivity calculation if there is no cloud
          ! overwrite model configuration
          doMaf = .false.
          if(sum(ModelTcir%values(:,maf)) .ne. 0._r8) doMaf = .true.
          
!          configDatabase(configIndices(1))%cloud_width=0
!          if(doMaf) configDatabase(configIndices(1))%cloud_width=cloudysky
          configDatabase(configIndices(1))%i_saturation=0
          if(doMaf) configDatabase(configIndices(1))%i_saturation=cloudysky

      print*,'begin cloud retrieval maf= ',maf,' chunk size=',nMAFs,'type=',doMaf
          fmStat%rows = .false.
          call forwardModel ( configDatabase(configIndices(1)), &
            & state, fwdModelExtra, FwdModelOut1, fmw, fmStat, jacobian )
            
          ! get clear sky radiances from forward model for this signal
          Tb0 => GetVectorQuantityByType ( fwdModelOut1,                 &
               & quantityType=l_radiance,                                      &
               & signal=signal%index, sideband=signal%sideband )

          ! get ptan.  Warning: all signals must be in the same module
          ptan => GetVectorQuantityByType ( fwdModelExtra,      &
               & quantityType=l_ptan, instrumentModule = &
               & Tb0%template%instrumentModule)

          ! get earthradius from forward model
!          Re => GetVectorQuantityByType ( fwdModelExtra,      &
!               & quantityType=l_earthradius)
          
          ! get sensitivity from forward model for this signal
          Slope => GetVectorQuantityByType ( fwdModelOut1,      &
               & quantityType=l_cloudRADSensitivity,                           &
               & signal=signal%index, sideband=signal%sideband )
          
          ! get rowBlock and colBlock for this model
          rowJBlock = FindBlock (jacobian%row, Tb0%index, maf)
          colJBlock = FindBlock ( Jacobian%col, xExtPtr%index, maf )
          jBlock => jacobian%block(rowJblock,colJblock)
               
          do mif=1,ptan%template%noSurfs
          if(ptan%values(mif,maf) > pcut) then
             
             sensitivity = 0._r8
             if(doMaf) then
                ! find more accurate sensitivity
                do j=1,nz
                  tmp1(j) = 1._r8/nz*(j-1._r8)
                  tmp2(j) = slope%values(ich+nFreqs*(mif-1),maf)* &
                     & (1._r8 - 0.2_r8* tmp1(j)**5) ! correction term (see ATBD)
!		            if(j > 1) then
!			            if(tmp2(j) > tmp2(j-1)) n1=j
!		            end if
                end do
!		          if(n1 < nz/2) print*,'sensitivity too low for mif=',mif
                     
                y = Tcir%values(ich+nFreqs*(mif-1),maf)

                ! interpolate to get initial guess of teff
                teff = 0._r8
                if(y < tmp2(1)) teff=0._r8
                if(y > tmp2(nz)) teff=1._r8
                do j=1,nz-1
                  if(y > tmp2(j) .and. y < tmp2(j+1)) then
                    teff=(tmp1(j)*(y-tmp2(j))+tmp1(j+1)*(tmp2(j+1)-y)) &
                      & /(tmp2(j+1)-tmp2(j))
                  end if
                end do

                ! solve the relation one more time to refine teff and sensitivity
                sensitivity = slope%values(ich+nFreqs*(mif-1),maf)* &
                   & (1._r8 - 0.2_r8* teff**5) ! correction term (see ATBD)
            end if  ! when sensitivity is calculated

                ! in case we have small sensitivity or no cloud
                if(sensitivity < 0._r8) cycle
                if(abs(sensitivity) < 1._r8) sensitivity = 130._r8
                     
                teff = y/sensitivity
                if(teff > 1._r8) teff = 1._r8
                           
                ! convert cloud radiance to effective optical depth
                y = teff
                sy = Terr%values(ich+nFreqs*(mif-1),maf)**2/sensitivity**2
                     
                do i=1,nz
                  do j=1,nInst
                    dx(i+(j-1)*nz) = dx(i+(j-1)*nz) + jBlock%values(mif,i+(j-1)*nz)*y/sy
                  end do
                end do
                do i=1,nz
                 do j=1,nInst
                  do i1=1,nz
                   do j1=1,nInst
                   C(i+(j-1)*nz,i1+(j1-1)*nz) = C(i+(j-1)*nz,i1+(j1-1)*nz) + &
                    & jBlock%values(mif,i+(j-1)*nz)*jBlock%values(mif,i1+(j1-1)*nz)/sy
                   end do
                  end do
                 end do
                end do
          end if
          end do   ! mif

      call clearMatrix ( jacobian )           ! free the space
      end do ! end of mafs
      
    ! give back the model config value
!      configDatabase(configIndices(1))%cloud_width=cloudysky
      configDatabase(configIndices(1))%i_saturation=cloudysky

      ! start inversion
      x0 = 0._r8        ! A priori
      x = 0._r8
      A = C
      do i=1,nz
         do j=1,nInst
         sx0(i+(j-1)*nz) = xExtVar%values(i,j)   ! sx has already been inverted
         A(i+(j-1)*nz,i+(j-1)*nz)=A(i+(j-1)*nz,i+(j-1)*nz) + xExtVar%values(i,j) 
         end do
      end do
         
      Call MatrixInversion(A)
               
      ! output estimated SD 
      do i=1,nz
         do j=1,nInst
            outExtSD%values(i,j) = A(i+(j-1)*nz,i+(j-1)*nz)
         end do
      end do

      ! compute the least-squared solution
      do i=1,nz
         do j=1,nInst
         x(i+(j-1)*nz) = sum(reshape(A(i+(j-1)*nz,:),(/nz*nInst/))*(x0*sx0 + dx))
         end do
      end do
      
      ! output retrieval results
      xExtPtr%values = reshape(x,(/nz,nInst/))
      
      ! deallocate arrays and free memory
      deallocate(A,C,tmp1,tmp2,dx,x,x0,sx0)

    ! ExtSD is defined as MLS contribution only
           badValue = outExtSD%template%badValue
!      outExtSD%values = 1._r8/outExtSD%values - xExtVar%values !xExtVar is an inverted variance
!       where(outExtSD%values > 0._r8) outExtSD%values = 1._r8/sqrt(outExtSD%values)
!       where(outExtSD%values .le. 0._r8) outExtSD%values = badValue

   ! clean up
      call destroyVectorInfo ( FwdModelOut1 )
      call destroyVectorInfo ( CovarianceDiag )
      call deallocate_test ( fmStat%rows, 'FmStat%rows', moduleName )
      
    end subroutine HighCloudRetrieval

    ! ------------------------------------------  LowCloudRetrieval  -----
    subroutine LowCloudRetrieval

      use Intrinsic, only: L_PTAN, L_RADIANCE, &
                     & L_CLOUDINDUCEDRADIANCE,                               &
                     & L_CLOUDEXTINCTION,                                &
                     & L_CLOUDRADSENSITIVITY,                                &
                     & L_EARTHRADIUS,                                &
                     & L_LOSTRANSFUNC
      use MatrixModule_0, only: MatrixInversion, MATRIXELEMENT_T
      use MatrixModule_1, only: ClearMatrix, FINDBLOCK, GetDiagonal, &
            & UpdateDiagonal, clearMatrix
      use MLSSignals_m, only: SIGNAL_T
      use ForwardModelWrappers, only: ForwardModel
      use ForwardModelIntermediate, only: ForwardModelIntermediate_T, &
        & ForwardModelStatus_T
a2153 555
      ! Local Variables
      type (ForwardModelStatus_T) :: FmStat        ! Status for forward model
      type (ForwardModelIntermediate_T) :: Fmw     ! Work space for forward model
      type (vector_T) :: FwdModelOut1               ! Forward outputs
      type (Signal_T) :: signal                    ! signal info in each model
      type (VectorValue_T), pointer :: xLosPtr        ! pointer of l_lostransfunc quantity
      type (VectorValue_T), pointer :: xExtPtr        ! pointer of l_cloudExtinction quantity
      type (VectorValue_T), pointer :: xLosVar        ! variance of apriori
      type (VectorValue_T), pointer :: xExtVar        ! variance of apriori
      type (VectorValue_T), pointer :: outLosSD        ! SD of output
      type (VectorValue_T), pointer :: outExtSD        ! SD of output
      type (VectorValue_T), pointer :: ModelTcir        ! for model cloud top indicator
      type (VectorValue_T), pointer :: Tcir        ! cloud-induced radiance
      type (VectorValue_T), pointer :: Terr        ! cloud-induced radiance SD
      type (VectorValue_T), pointer :: PTAN        ! Tgt pressure
      type (VectorValue_T), pointer :: Re        ! Earth Radius
      type (VectorValue_T), pointer :: Tb0         ! model clear sky radiance (100%RH)
      type (VectorValue_T), pointer :: Slope       ! sensitivity slope to convert cloud
                                                   ! radiance to optical depth
                                          
      integer :: i,j,k,imodel,mif,maf,isignal          ! Loop subscripts
      integer :: ich, ich0          ! channel used
      integer :: cloudysky(size(configIndices))   ! cloudysky index from Model Configuration
      integer :: coljBlock     ! Column index for jacobian
      integer :: rowjBlock     ! Row index for jacobian
      integer :: nFreqs      ! number of frequencies in each block
      integer :: nFreqs0      ! number of frequencies in the signal for cloud top estimation
      integer :: nSignal      ! number of signals in a band  
      integer :: nSgrid      ! number of S grids  
      integer :: nChans      ! total number of channels used in retrieval
      integer :: nMifs       ! number of total mifs
      integer :: nMafs      ! number of MAFs
      integer :: ndoMifs       ! number of used mifs
      real(r8) :: p_lowcut    ! ptan threshold for low tangent heights
      real(r8) :: scale
      real(r8) :: badValue
                                        
      type(MatrixElement_T), pointer :: JBLOCK       ! A block from the jacobian
      type(vector_T) :: CovarianceDiag  ! Diagonal of apriori Covariance  
      
      ! retrieval work arrays
      real(r8) :: sensitivity                         ! sensitivity with slope and correction
      real(r8) :: teff                                ! effective optical depth
      real(r8) :: trans                                ! transmission function
      integer :: itop                                ! cloud top tangt pressure index
      real(r8) :: zt
      logical, dimension(:), allocatable :: doMaf      ! array for MAF flag
      real(rm), dimension(:,:), allocatable :: A      ! working array
      real(r8), dimension(:,:), allocatable :: dx       ! working array for x
      real(r8), dimension(:,:), allocatable :: y      ! measurement array
      real(r8), dimension(:,:), allocatable :: sy     ! variance of y
      real(r8), dimension(:), allocatable :: Slevel        ! s grid
      real(r8), dimension(:), allocatable :: x        ! s grid array
      real(r8), dimension(:), allocatable :: x0       ! A priori of x
      real(r8), dimension(:), allocatable :: sx0       ! variance of A priori
      real(r8), dimension(:), allocatable :: xext       ! extinction along los
      real(r8), dimension(:,:), allocatable :: sx       ! variance of x
      real(r8), dimension(:,:,:), allocatable :: C    ! for problem y=Kx, c=K^t#Sy^-1#K
                                                      ! last dimension is for mif
                                                      ! first two are (chan, s)

      ! use this for testing
      if(.not. got(f_maxJ)) maxJacobians = 5
      if(.not. got(f_lambda)) initlambda = 10.
      
      p_lowcut = -2.5
      
      ! find how many MAFs        
        nMAFs = chunk%lastMAFIndex-chunk%firstMAFIndex + 1
        allocate(doMaf(nMAFs))
               
      call allocate_test ( fmStat%rows, jacobian%row%nb, 'fmStat%rows', &
        & ModuleName )
      ! create FwdModelOut1 vector by cloning measurements
        call cloneVector ( FwdModelOut1, measurements, vectorNameText='_covarianceDiag' )
               
      ! Measurements are cloud radiances and will be converted to
      ! the effective cloud optical depth after the forward model
      ! provides the sensitivities.
        
      ! Get  l_lostransfunc quantity from state vector
      ! State vector should contains only one quantity of l_lostransfunc type 
      ! (a los quantity),which is the increment of cloud transmission function,
      ! and it is going to be retrieved here.
      
        xLosPtr => GetVectorQuantityByType ( state, quantityType=l_lostransfunc)
        xExtPtr => GetVectorQuantityByType ( state, quantityType=l_cloudextinction)
      
      ! Get S grid dimensions
        nSgrid=xLosPtr%template%noChans    ! number of S grids
        allocate(Slevel(nSgrid))
        sLevel = xLosPtr%template%frequencies      ! sLevel has unit of km here                 
        
      ! find how many channels total in all models
        doMaf = .false.
        nChans = 0
        do imodel = 1, size(configIndices)
          !memorize the initial model configuration
!           cloudysky(imodel) = configDatabase(configIndices(imodel))%cloud_width
           cloudysky(imodel) = configDatabase(configIndices(imodel))%i_saturation
        do isignal = 1, size(configDatabase(configIndices(imodel))%signals)
          nChans = nChans + &
          & count(configDatabase(configIndices(imodel))%signals(isignal)%channels)
              ! get signal information for this model. Note: allow only 1 signal 
              signal = configDatabase(configIndices(imodel))%signals(isignal)
              ! get cloud radiance measurements for this signal
              Tcir => GetVectorQuantityByType ( Measurements,       &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband)
              ! determine MAF flag (i.e., whether to call Forward Model for the MAF)
              do maf=1,nMAFs
              if(sum(Tcir%values(:,maf)) .ne. 0._r8) doMaf(maf) = .true.
              end do
        end do ! band signals
        end do ! configIndices or models

      ! find how many mifs from the first quantity        
        nMifs = measurements%quantities(1)%template%noSurfs
               
      ! create covarianceDiag array
        call cloneVector ( covarianceDiag, state, vectorNameText='_covarianceDiag' )
      ! get the inverted diagnonal elements of covariance of apriori
        call getDiagonal ( covariance%m, covarianceDiag )
        
      ! get pointers of x covariance for the apriori
        xLosVar => GetVectorQuantityByType(covarianceDiag,quantityType=l_lostransfunc)
        xExtVar => GetVectorQuantityByType(covarianceDiag,quantityType=l_cloudextinction)
      
      ! get pointers of output SD for the retrieval
        outLosSD => GetVectorQuantityByType(outputSD,quantityType=l_lostransfunc)
        outExtSD => GetVectorQuantityByType(outputSD,quantityType=l_cloudextinction)
        outLosSD%values = 0._r8
        outExtSD%values = 0._r8
      
      ! allocate C, y, x matrices
          allocate(A(nSgrid,nSgrid),C(nSgrid,nSgrid,nMifs))
          allocate(y(nChans,nMifs),sy(nChans,nMifs))
          allocate(x(nSgrid),x0(nSgrid),sx0(nSgrid),xext(nSgrid))
          allocate(dx(nSgrid,nMifs),sx(nSgrid,nMifs))

      ! Loop over MAFs
        do maf =1,nMAFs
        fmStat%maf = maf
        print*,'begin cloud retrieval maf= ',maf,' chunk size=',nMAFs, 'type= ',&
          & configDatabase(configIndices(1))%i_saturation
!         & configDatabase(configIndices(1))%cloud_width
                        
          A = 0._rm
          C = 0._r8
          y = 0._r8
          sy = 0._r8
          dx = 0._r8
            
          ich = 0
          do imodel = 1, size(configIndices)
            fmStat%rows = .false.
            nSignal = size(configDatabase(configIndices(imodel))%signals)
            ! to save time, skip cloud sensitivity calculation if there is no cloud
            ! overwrite model configuration
!            configDatabase(configIndices(imodel))%cloud_width=0
!            if(doMaf(maf)) configDatabase(configIndices(imodel))%cloud_width=cloudysky(imodel)
            configDatabase(configIndices(imodel))%i_saturation=0
            if(doMaf(maf)) configDatabase(configIndices(imodel))%i_saturation=cloudysky(imodel)
                       
            ! use the cloud radiance in last signal for cloud top indicator 
            signal = configDatabase(configIndices(imodel))%signals(nSignal)

              Tcir => GetVectorQuantityByType ( Measurements,       &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )
            
              ModelTcir => GetVectorQuantityByType ( fwdModelExtra,     &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )
          
              ModelTcir%values = Tcir%values
 
              nFreqs0 = size(signal%frequencies)
               do k=1,nFreqs0
                  if(signal%channels(k)) ich0 = k
               end do
               
            ! estimate cloud top from the Tcir in previous scans
            ! (in simulation, now use the current scan)
              itop = 0
              do mif = 1, nMifs
               if(ModelTcir%values(ich0+(mif-1)*nFreqs0,maf) .ne. 0._r8) &
                & itop = mif
              end do
              
            ! call full cloud model for Jacobian and Sensitivity  
             call forwardModel ( configDatabase(configIndices(imodel)), &
                & state, fwdModelExtra, FwdModelOut1, fmw, fmStat, jacobian )
            
            do isignal = 1, nSignal
              ! get signal information for this model. Note: allow only 1 signal 
              signal = configDatabase(configIndices(imodel))%signals(isignal)

              ! get clear sky radiances from forward model for this signal
              Tb0 => GetVectorQuantityByType ( fwdModelOut1,                 &
               & quantityType=l_radiance,                                      &
               & signal=signal%index, sideband=signal%sideband )

              ! get ptan.  Warning: all signals must be in the same module
              ptan => GetVectorQuantityByType ( fwdModelExtra,      &
               & quantityType=l_ptan, instrumentModule = &
               & Tb0%template%instrumentModule)

              ! get earthradius from forward model
              Re => GetVectorQuantityByType ( fwdModelExtra,      &
               & quantityType=l_earthradius)
          
              ! get sensitivity from forward model for this signal
              Slope => GetVectorQuantityByType ( fwdModelOut1,      &
               & quantityType=l_cloudRADSensitivity,                           &
               & signal=signal%index, sideband=signal%sideband )
          
              ! get cloud radiance measurements for this signal
              Tcir => GetVectorQuantityByType ( Measurements,       &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )
            
              ! get cloud radiances error for this signal
              Terr => GetVectorQuantityByType ( MeasurementSD,       &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )

              ! get rowBlock and colBlock for this model
              rowJBlock = FindBlock (jacobian%row, Tb0%index, maf)
              colJBlock = FindBlock ( Jacobian%col, xLosPtr%index, maf )
                
              jBlock => jacobian%block(rowJblock,colJblock)
               
              nFreqs = size (signal%frequencies)
               do k=1,nFreqs
               if(signal%channels(k)) then
               ich = ich + 1
                  do mif=1,nMifs
                  if(ptan%values(mif,maf) < p_lowcut) then
                    
                    sensitivity = 0._r8
                    if(doMaf(maf)) then
                     ! find more accurate sensitivity. we first borrow 
                     ! x, x0 arrays to establish the Tcir-teff relation:
                     ! x-> Tcir; x0->teff;
                     do j=1,nSgrid
                     x0(j) = 1._r8/nSgrid*(j-1._r8)
                     x(j) = slope%values(k+nFreqs*(mif-1),maf)* &
                        & (1._r8 + 0.46_r8* x0(j)**6) ! correction term (see ATBD)
                     end do
                     
                     y(ich,mif) = Tcir%values(k+nFreqs*(mif-1),maf)

                     ! interpolate to get initial guess of teff
                     teff = 0._r8
                     if(y(ich,mif) < x(1)) teff=0._r8
                     if(y(ich,mif) > x(nSgrid)) teff=1._r8
                     do j=1,nSgrid-1
                        if(y(ich,mif) > x(j) .and. y(ich,mif) < x(j+1)) then
                        teff=(x0(j)*(y(ich,mif)-x(j))+x0(j+1)*(x(j+1)-y(ich,mif))) &
                          & /(x(j+1)-x(j))
                        end if
                     end do

                     ! solve the relation one more time to refine teff and sensitivity
                     sensitivity = slope%values(k+nFreqs*(mif-1),maf)* &
                           & (1._r8 + 0.46_r8* teff**6) ! correction term (see ATBD)
                    end if ! when sensitivity is calculated

                     ! in case we have small sensitivity or no cloud
                     if(abs(sensitivity) < 1._r8) sensitivity = -105._r8
                     
                     teff = y(ich,mif)/sensitivity
                     if(teff > 1._r8) teff = 1._r8
                           
                     ! convert cloud radiance to effective optical depth
                     
                     y(ich,mif) = teff
                     sy(ich,mif) = (Terr%values(k+nFreqs*(mif-1),maf)/sensitivity)**2
                     
                     do i=1,nSgrid
                        dx(i,mif) = dx(i,mif) + jBlock%values(k,i+(mif-1)*nSgrid)* &
                           & y(ich,mif)/sy(ich,mif)
                     do j=1,nSgrid
                        C(i,j,mif) = C(i,j,mif) + jBlock%values(k,i+(mif-1)*nSgrid)* &
                           & jBlock%values(k,j+(mif-1)*nSgrid)/sy(ich,mif)
                           
                     end do
                     end do
                  end if
                  end do   ! mif

               end if
               end do      ! end of frequency k

            end do         ! end of band signals
         end do         ! end of imodel

         ! check if Jacobian rows are consistent with Signal rows
         if(ich /= nChans) call MLSMessage ( MLSMSG_Warning, ModuleName, &
           & 'inconsistent channels between Jacobian and Signal' )

           sx = 1.e8_r8         ! sx is the inversd variance of a priori
           x = 0._r8
           x0 = xLosVar%template%frequencies
           do mif=1,nMifs
             do i=1,nSgrid
                !xLosVar is the inverted variance
                sx(i,mif) = xLosVar%values(i+nSgrid*(mif-1),maf)  ! xLosVar has been inverted
             end do
             if(itop .ne. 0) then
             !constrained by the estimated cloud top
                x = x0**2/2._r8/(re%values(1,maf)*0.001_r8 + &
                  & (ptan%values(mif,maf)+3._r8)*16._r8)
                x = x/16._r8 + ptan%values(mif,maf)
                do i = 1,nSgrid
                 if(x(i) > ptan%values(itop,maf)) sx(i,mif) = sx(i,mif)*1.e4
                end do
             end if
           end do
                              
         ! start inversion
           do mif=1,nMifs
            if (ptan%values(mif,maf) < p_lowcut) then
               ! for cloud retrieval: x_star=0, y_star=0, x0=apriori=0

               x0 = 0._r8        ! A priori
               x = 0._r8
               sx0=sx(:,mif)
               
               do j=1,maxJacobians     ! maxJacobians is number of iterations (default 5)
               
                  x0 = x        ! use  the last retrieval as A priori
                                 ! and doubt constraints to the A priori
                  where(x0 .le. 0._r8) x0 = 0._r8

                  A = reshape(C(:,:,mif),(/nSgrid,nSgrid/))
                  do i=1,nSgrid
                   A(i,i)=A(i,i) + sx0(i)       ! sx has been inverted
                  end do
                  Call MatrixInversion(A)
               
                  ! output estimated SD after the first iteration
                  if(associated(xLosPtr) .and. j == 1) then
                   do i=1,nSgrid
                    outLosSD%values(i+(mif-1)*nSgrid,maf) = sqrt(A(i,i))
                   end do
                  end if
                  
                  ! compute the LOS retrieval in the least-squard solution
                  do i=1,nSgrid
                     x(i) = sum( reshape(A(i,:),(/nSgrid/))* &
                     & (x0*sx0 + reshape(dx(:,mif),(/nSgrid/)) ))
                  end do
                  ! reduce covariance on x0 for next iteration, using factor lambda (default 10)
                  sx0 = sx0*initLambda          ! sx0 is the inversed variance

               end do  ! end of iteration
               
               ! Now, x is the los Transmission increment
               ! compute cloud extinction from los Transmission increments
               xext = 0._r8      ! temporary storage for LOS extinction
               trans = 0._r8
               do i=nSgrid,2,-1
                 trans = trans + x(i)
                 ! protect from blowing up
                 if(1._r8-trans > 0.004) then
                  scale = (1._r8-trans)*(slevel(i)-slevel(i-1))      ! see ATBD
                                 xext(i)=x(i)/scale
                  ! and standard deviation
                  outLosSD%values(i+(mif-1)*nSgrid,maf) = &     !neglect higher orders
                     & outLosSD%values(i+(mif-1)*nSgrid,maf)/scale
                  xLosVar%values(i+(mif-1)*nSgrid,maf) = &     !xLosVar is the inversed var
                     & xLosVar%values(i+(mif-1)*nSgrid,maf)*scale*scale
                 end if
               end do
               
               ! output los extinction to state vector
               if(associated(xLosPtr)) then
                do i=1,nSgrid
                 xLosPtr%values(i+(mif-1)*nSgrid,maf) = xext(i)
                end do
               end if               
               
            end if
           end do  ! mif
      call clearMatrix ( jacobian )           ! free the space
      
      end do ! end of mafs
      
    ! give back the model config value
      do imodel = 1,size(configIndices)
!        configDatabase(configIndices(imodel))%cloud_width=cloudysky(imodel)
        configDatabase(configIndices(imodel))%i_saturation=cloudysky(imodel)
      end do
      
    ! deallocate arrays and free memory
      deallocate(A,C,y,sy,dx,x,x0,sx0,xext,sx)

      xExtPtr%values = 0._r8
      outLosSD%values = outLosSD%values**2
      xLosVar%values = 1._r8/xLosVar%values  ! xLosVar is the inverted variance
      
   	call LOS2Grid(xExtPtr,outExtSD,xExtvar,xLosPtr,outLosSD,xLosVar,Ptan,Re,p_lowcut)

    ! output SD
      outLosSD%values = sqrt(outLosSD%values)
    ! ExtSD is defined as MLS contribution only
      badValue = outExtSD%template%badValue
      outExtSD%values = 1._r8/outExtSD%values - 1._r8/xExtVar%values
       where(outExtSD%values > 0._r8) outExtSD%values = 1._r8/sqrt(outExtSD%values)
       where(outExtSD%values .le. 0._r8) outExtSD%values = badValue
    ! Output SD
      xExtVar%values = sqrt(abs(xExtVar%values))
      
    ! overwrite input covariance
      call clearMatrix(covariance%m)     ! this will initialize it to M_Absent
      call updateDiagonal ( covariance, CovarianceDiag)

    ! clean up
      call destroyVectorInfo ( FwdModelOut1 )
      call destroyVectorInfo ( CovarianceDiag )
      call deallocate_test ( fmStat%rows, 'FmStat%rows', moduleName )
      deallocate(Slevel, doMaf)
      
    end subroutine LowCloudRetrieval

  !=============================== LOS2Grid ===================================
  subroutine LOS2Grid( Qty, vQty, vQtyApr, Los, vLos, vLosApr, Ptan, Re, Pcut)

    ! This is to fill a l2gp type of quantity with a los grid type of quantity.
    ! The los quantity is a vector quantity that has dimension of (s, mif, maf),
    ! where s is the path along los.
    !
    ! Linear interpolation is used to fill l2gp grids and unfilled grids are
    ! marked with the baddata flag (-999.)

    use UNITS
    use MLSNumerics, only: InterpolateValues
    ! Dummy arguments
    type (VectorValue_T), intent(in) :: LOS ! LOS quantity
    type (VectorValue_T), intent(in) :: vLOS ! variance of LOS
    type (VectorValue_T), intent(in) :: vLosApr ! variance of LOS Apriori
    type (VectorValue_T), intent(in) :: Ptan ! tangent pressure
    type (VectorValue_T), intent(in) :: Re ! Earth's radius
    type (VectorValue_T), INTENT(INOUT) :: Qty ! Quantity to fill
    type (VectorValue_T), INTENT(INOUT) :: vQty ! variance of Quantity
    type (VectorValue_T), INTENT(INOUT) :: vQtyApr ! variance of Quantity Aprori

    ! Local variables
    integer :: i, j, maf, mif                ! Loop counter
    integer :: maxZ, minZ                    ! pressure range indices of sGrid
    integer :: noMAFs,noMIFs,noDepths
    real (r8) :: pcut
    real (r8), dimension(qty%template%noSurfs,qty%template%noInstances) :: cnta
    real (r8), dimension(qty%template%noSurfs,qty%template%noInstances) :: cnt
    real (r8), dimension(qty%template%noSurfs,qty%template%noInstances) :: out
    real (r8), dimension(qty%template%noSurfs) :: outZeta, phi_out, beta_out, weight, weighta
    real (r8), dimension(los%template%noChans) :: x_in, y_in, sLevel
    real (r8), dimension(los%template%noSurfs) :: zt

    if ( qty%template%verticalCoordinate == l_pressure ) then
        outZeta = -log10 ( qty%template%surfs(:,1) )
    else
        outZeta = qty%template%surfs(:,1)
    end if

    noMAFs=los%template%noInstances
    noMIFs=los%template%noSurfs
! Now, we use frequency coordinate as sGrid along the path
    noDepths=los%template%noChans
    sLevel = los%template%frequencies
   
! initialize quantity
   Qty%values=Qty%template%badValue
   vQty%values = vQty%template%badValue
   vQtyApr%values = vQtyApr%template%badValue
   cnta=0._r8
   cnt=0._r8
   out=0._r8
   
    do maf=1,noMAFs  
      zt = ptan%values(:,maf)   ! noChans=1 for ptan
      zt = (zt+3.)*16.                      ! converted to height in km
      do mif=1,noMIFs
      if (ptan%values(mif,maf) .gt. pcut) cycle
      ! find altitude of each s grid
      x_in = sLevel**2/2./(re%values(1,maf)*0.001_r8 + zt(mif))
      ! converted to zeta
      x_in = x_in/16. + ptan%values(mif,maf)
      ! find minimum and maximum pressures indices in sGrid
        do i = 2,qty%template%noSurfs-1
        if (ptan%values(mif,maf) < (outZeta(i)+outZeta(i+1))/2. .and. &
          & ptan%values(mif,maf) > (outZeta(i)+outZeta(i-1))/2.) &
          & minZ = i
        end do
        if (ptan%values(mif,maf) < (outZeta(1)+outZeta(2))/2.) minZ=1
        if (ptan%values(mif,maf) > outZeta(qty%template%noSurfs)) cycle ! goto next mif
        
        do i = 2,qty%template%noSurfs-1
        if (x_in(noDepths) < (outZeta(i)+outZeta(i+1))/2. .and. &
          & x_in(noDepths) > (outZeta(i)+outZeta(i-1))/2.) &
          & maxZ = i
        end do
        if (x_in(noDepths) < (outZeta(1)+outZeta(2))/2.) cycle    ! goto next mif
        if (x_in(noDepths) > outZeta(qty%template%noSurfs)) maxZ=qty%template%noSurfs

      ! get phi along path for each mif (phi is in degree)
      y_in = los%template%phi(mif,maf) &
        & - atan(sLevel/(re%values(1,maf)*0.001_r8 + zt(mif)))*180._r8/Pi
       ! interpolate phi onto standard vertical grids     
        call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),phi_out(minZ:maxZ), &
           & method='Linear')
       ! interpolate quantity to standard vertical grids      
        y_in = Los%values((1+(mif-1)*noDepths):mif*noDepths,maf)
        beta_out = 0._r8
        call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),beta_out(minZ:maxZ), &
           & method='Linear')
        y_in = vLos%values((1+(mif-1)*noDepths):mif*noDepths,maf)
        weight = 0._r8
        call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),weight(minZ:maxZ), &
           & method='Linear')
        weight = weight*(maxZ-minZ+1._r8)/size(y_in)  !inflated after interpolation
        y_in = vLosApr%values((1+(mif-1)*noDepths):mif*noDepths,maf)
        weighta = 0._r8
        call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),weighta(minZ:maxZ), &
           & method='Linear')
        weighta = weighta*(maxZ-minZ+1._r8)/size(y_in)  !inflated after interpolation
        
       ! interpolate quantity to standard phi grids
        do i=minZ,maxZ  
          do j = 2, qty%template%noInstances-1
          if(phi_out(i) .lt. &     
            & (qty%template%phi(1,j)+qty%template%phi(1,j+1))/2._r8 &
            & .and. phi_out(i) .ge. &  
            & (qty%template%phi(1,j-1)+qty%template%phi(1,j))/2._r8 ) then
            out(i,j)=out(i,j) + beta_out(i)/weight(i)    ! weighted by variance
            cnt(i,j)=cnt(i,j)+1._r8/weight(i)       !  counter
            cnta(i,j)=cnta(i,j)+1._r8/weighta(i)       !  counter
          end if
          end do
        end do
      end do                            ! End surface loop
    end do                              ! End instance loop
    ! average all non-zero bins
    where (cnt > 0._r8) Qty%values = out/cnt
    where (cnt > 0._r8) cnt = 1._r8/cnt
    where (cnta > 0._r8) cnta = 1._r8/cnta
    
    where (cnta > 0._r8) vQtyApr%values = cnta
    where (cnt > 0._r8) vQty%values = cnt
!    where (cnt > 0._r8 .and. cnt > 0.5_r8*cnta) vQty%values = -cnt  ! assign negative

  end subroutine LOS2Grid    
    
d2177 3
@


2.239
log
@Reinstated the fnorm dumping which seemed to fall by the wayside
for some reason.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.238 2003/03/07 03:17:03 livesey Exp $"
d65 1
a65 1
      & S_subset, S_time, S_RESTRICTRANGE
d81 1
a81 1
    use SubsetModule, only: SETUPSUBSET, SETUPFLAGCLOUD, RESTRICTRANGE
d176 1
a176 1
    integer :: Spec                     ! s_matrix, s_subset or s_retrieve
d316 6
d3039 4
@


2.238
log
@Added Restrict Range
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.237 2003/03/06 00:46:41 livesey Exp $"
d1312 4
a1315 1

d1341 3
d1394 9
d1531 4
d1605 8
d3033 3
@


2.237
log
@Now gets subset etc. from subsetmodule
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.236 2003/02/25 21:12:48 dwu Exp $"
d65 1
a65 1
      & S_subset, S_time
d81 1
a81 1
    use SubsetModule, only: SETUPSUBSET, SETUPFLAGCLOUD
d304 6
d3006 3
@


2.236
log
@ clean up FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.235 2003/02/25 19:04:43 dwu Exp $"
d76 1
a76 1
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID, GetIndexFlagsFromList
d81 1
a2989 745
    ! -------------------------------------------------- SetupSubset ---
    subroutine SetupSubset ( key, vectors )

      use Declaration_table, only: NUM_VALUE
      use Intrinsic, only: PHYQ_LENGTH, PHYQ_PRESSURE
      use VectorsModule, only: ClearMask, CreateMask, &
        & GetVectorQtyByTemplateIndex, SetMask, VectorValue_T
      integer, intent(in) :: KEY        ! Tree node
      type (Vector_T), dimension(:) :: VECTORS

      ! Local variables
      integer :: CHANNEL                ! Loop index
      integer :: CHANNELSNODE           ! Tree node for channels values
      integer :: COORDINATE             ! Vertical coordinate type
      integer :: FIELD                  ! Field type from tree
      integer :: GSON                   ! Tree node
      integer :: HEIGHT                 ! Loop counter
      integer :: HEIGHTNODE             ! Tree node for height values
      integer :: HEIGHTUNIT             ! Unit for heights command
      integer :: I, J                   ! Subscripts, loop inductors
      integer :: IND                    ! An array index
      integer :: INSTANCE               ! Loop counter
      integer :: INSTANCEOR1            ! For coherent quantities
      integer :: MASK                   ! Which thing are we talking about?
      integer :: MaskBit                ! Bits corresponding to Mask
      integer :: MAINVECTORINDEX        ! Vector index of quantity to subset
      integer :: NROWS                  ! Loop limit dumping mask
      integer :: ODCUTOFFHEIGHT         ! `First' index optically thick
      integer :: QUANTITYINDEX          ! Index
      integer :: RANGEID                ! nodeID of a range
      integer :: RANGE_LOW, RANGE_HI    ! Bounds of a range
      integer :: ROW                    ! Row index dumping mask
      integer :: S1(1), S2(1)           ! Results of minloc intrinsic
      integer :: SCANDIRECTION          ! +/-1 for up or down
      integer :: SON                    ! Tree node
      integer :: STATUS                 ! Flag
      integer :: TESTUNIT               ! Either vector%globalUnit or qty tmplt unit
      integer :: TYPE                   ! Type of value returned by expr
      integer :: UNITS(2)               ! Units returned by expr
      integer :: VECTORINDEX            ! Index
      integer :: MINUNIT                ! Units for minValue
      integer :: MAXUNIT                ! Units for maxValue

      real(r8) :: HeightMin, HeightMax
      real(r8), dimension(:), pointer :: THESEHEIGHTS ! Subset of heights
      real(r8) :: VALUE(2)              ! Value returned by expr
      real(r8) :: OPTICALDEPTHCUTOFF    ! Maximum value of optical depth to allow
      real(r8) :: MAXVALUE, MINVALUE    ! Cutoff ranges
      type (VectorValue_T), pointer :: QTY ! The quantity to mask
      type (VectorValue_T), pointer :: PTAN ! The ptan quantity if needed
      type (VectorValue_T), pointer :: OPTICALDEPTH ! The opticalDepth quantity if needed
      logical :: Got(field_first:field_last)   ! "Got this field already"
      logical, dimension(:), pointer :: CHANNELS ! Are we dealing with these channels
      logical :: IGNORE                 ! Flag
      logical :: RESET                  ! Flag
      logical :: ADDITIONAL             ! Flag
      logical :: DOTHISCHANNEL          ! Flag
      logical :: DOTHISHEIGHT           ! Flag
      integer, parameter ::                      MAXCOLUMNS = 127
      character(len=1), dimension(MAXCOLUMNS) :: maskedMan
      character(len=5) ::                        decades
      character(len=1), dimension(:), pointer :: ORIGINALMASK

      ! Executable code
      nullify ( channels, qty, ptan, opticalDepth )
      got = .false.
      ignore = .false.
      reset = .false.
      additional = .false.
      maskBit = m_linalg
      minUnit = 0
      maxUnit = 0
      do j = 2, nsons(key) ! fields of the "subset" specification
        son = subtree(j, key)
        field = get_field_id(son)   ! tree_checker prevents duplicates
        if (nsons(son) > 1 ) gson = subtree(2,son) ! Gson is value
        select case ( field )
        case ( f_quantity )
          mainVectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          qty => GetVectorQtyByTemplateIndex(vectors(mainVectorIndex), quantityIndex)
        case ( f_ptanquantity )
          vectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          ptan => GetVectorQtyByTemplateIndex(vectors(vectorIndeX), quantityIndex)
        case ( f_channels )
          channelsNode = son
        case ( f_height )
          heightNode = son
        case ( f_mask )
          if ( .not. got(f_mask) ) maskBit = 0 ! clear default first time
          do i = 2, nsons(son)
            mask = decoration(subtree(i,son))
            select case ( mask )
            case ( l_fill )
              maskBit = ior(maskBit, m_fill)
            case ( l_full_derivatives )
              maskBit = ior(maskBit, m_fullDerivatives)
            case ( l_linAlg )
              maskBit = ior(maskBit, m_linAlg)
            case ( l_Tikhonov )
              maskBit = ior(maskBit, m_Tikhonov)
            end select
          end do
        case ( f_opticalDepth )
          vectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          opticalDepth => GetVectorQtyByTemplateIndex(vectors(vectorIndeX), quantityIndex)
        case ( f_opticalDepthCutoff )
          call expr ( subtree (2, son), units, value, type )
          if ( type /= num_value ) call announceError ( &
            & rangeNotAppropriate, f_opticalDepthCutoff )
          if ( units(1) /= phyq_dimensionless ) &
            & call announceError ( wrongUnits, f_opticalDepthCutoff, string='no' )
          opticalDepthCutoff = value(1)
        case ( f_maxValue )
          call expr ( subtree (2, son), units, value, type )
          if ( type /= num_value ) call announceError ( &
            & rangeNotAppropriate, f_opticalDepthCutoff )
          maxUnit = units(1)
          maxValue = value(1)
        case ( f_minValue )
          call expr ( subtree (2, son), units, value, type )
          if ( type /= num_value ) call announceError ( &
            & rangeNotAppropriate, f_opticalDepthCutoff )
          minUnit = units(1)
          minValue = value(1)
        case ( f_ignore )
          ignore = Get_Boolean ( son )
        case ( f_reset )
          reset = Get_Boolean ( son )
        case ( f_additional )
          additional = Get_Boolean ( son )
        case default
          ! Shouldn't get here if the type checker worked
        end select
        got(field) = .true.
      end do ! j = 2, nsons(key)

      ! Do some error checking for the optical depth issues
      if ( any(got((/ f_opticalDepth, f_opticalDepthCutoff /))) ) then
        if ( .not. all(got((/ f_opticalDepth, f_opticalDepthCutoff /))) ) &
          & call AnnounceError ( needBothDepthAndCutoff, key )
        if ( qty%template%quantityType /= l_radiance .or. &
          &  opticalDepth%template%quantityType /= l_opticalDepth ) &
          & call AnnounceError ( badOpticalDepthQuantities, key )
        if ( qty%template%signal /= opticalDepth%template%signal .or. &
          &  qty%template%sideband /= opticalDepth%template%sideband ) &
          & call AnnounceError ( badOpticalDepthSignal, key )
      endif
      
      if ( vectors(mainVectorIndex)%globalUnit /= phyq_invalid ) then
        testUnit = vectors(mainVectorIndex)%globalUnit
      else
        testUnit = qty%template%unit
      end if
      if ( got ( f_minValue ) .and. ( minUnit /= testUnit ) ) &
        & call AnnounceError ( WrongUnits, f_minValue, string="different" )
      if ( got ( f_maxValue ) .and. ( maxUnit /= testUnit ) ) &
        & call AnnounceError ( WrongUnits, f_maxValue, string="different" )

      ! Process the channels field.
      if ( qty%template%frequencyCoordinate /= l_none ) then
        call Allocate_test ( channels, qty%template%noChans, &
          & 'channels', ModuleName )
        if ( got(f_channels) ) then     ! This subset is only for some channels
          call GetIndexFlagsFromList ( channelsNode, channels, status, &
            & lower=lbound(channels,1) )
          if ( status /= 0 ) call announceError ( wrongUnits, f_channels, string='no' )
        else
          channels = .true.             ! Apply this to all channels
        end if
      end if

      ! Check that got one of ignore, height, reset
      if ( count ( got ( (/ f_ignore, f_height, f_reset /) ) ) /= 1 ) &
        & call announceError ( MustHaveOne )

      ! Preprocess the height stuff.  
      heightUnit = phyq_dimensionless
      if ( got(f_height) ) then
        do j = 2, nsons(heightNode)
          call expr ( subtree(j,heightNode), units, value, type )
          ! Make sure the range has non-dimensionless units -- the type
          ! checker only verifies that they're consistent.  We need to
          ! check each range separately, because the units determine the
          ! scaling of the values.
          if ( all(units == phyq_dimensionless) ) call announceError ( &
            & wrongUnits, f_height, string = 'length or pressure.' )
          ! Check consistency of units -- all the same, or dimensionless. The
          ! type checker verifies the consistency of units of ranges, but not
          ! of array elements.
          do i = 1, 2
            if ( heightUnit == phyq_dimensionless ) then
              heightUnit = units(i)
            else if ( units(i) /= phyq_dimensionless .and. &
              &       units(i) /= heightUnit ) then
              call announceError ( inconsistentUnits, f_height )
            end if
          end do
        end do
        ! Check for correct units
        if ( heightUnit == phyq_pressure ) then
          if ( qty%template%minorFrame .and. .not. got(f_ptanQuantity) ) &
            & call announceError ( ifUnitsAThenB, f_height, f_ptanQuantity, &
            & 'pressure' )
        else if ( heightUnit /= phyq_length ) then
          call announceError ( wrongUnits, f_height, &
            & string = 'length or pressure.' )
        end if
      end if

      ! Create the mask if it doesn't exist
      if ( .not. associated( qty%mask ) ) call CreateMask ( qty )

      ! Make a space to save the original values if doing an additional mask
      if ( additional ) then
        nullify ( originalMask )
        call Allocate_test ( originalMask, qty%template%instanceLen, &
          & 'originalMask', ModuleName )
      end if

      ! Now we loop over the instances
      do instance = 1, qty%template%noInstances

        ! Possibly save original mask
        if ( additional ) originalMask = qty%mask ( :, instance )

        instanceOr1 = instance
        if ( qty%template%coherent ) then
          theseHeights => qty%template%surfs(:,1)
          coordinate = qty%template%verticalCoordinate
          instanceOr1 = 1
        else if ( qty%template%minorFrame .and. heightUnit == phyq_pressure ) then
          if ( ptan%template%instrumentModule /= qty%template%instrumentModule ) &
            & call AnnounceError ( inconsistent, f_ptanQuantity, &
            & f_quantity )
          theseHeights => ptan%values(:,instance)
          coordinate = l_zeta
        else
          theseHeights => qty%template%surfs(:,instance)
          coordinate = qty%template%verticalCoordinate
        end if

        ! Now, make sure for the channels we're considering that the
        ! default is to ignore all, unless we've not got a heights or ignore
        ! in which case we default to use all
        if ( got(f_height) .or. ignore ) then
          do channel = 1, qty%template%noChans
            doThisChannel = .true.
            if ( associated(channels) ) doThisChannel = channels(channel)
            if ( doThisChannel ) then
              do height = 1, qty%template%noSurfs
                !??? Make sure mask bit numbers begin at 1, even when
                !??? channel numbers don't.
                call SetMask ( qty%mask(:,instance), &
                  & (/ channel+qty%template%noChans*(height-1) /), &
                  & what=maskBit )
              end do                    ! Height loop
            end if                      ! Do this channel
          end do                        ! Channel loop
        else
          ! If not got heights and/or ignore, default must be 
          if ( reset ) then
            do channel = 1, qty%template%noChans
              doThisChannel = .true.
              if ( associated(channels) ) doThisChannel = channels(channel)
              if ( doThisChannel ) then
                do height = 1, qty%template%noSurfs
                  !??? Make sure mask bit numbers begin at 1, even when
                  !??? channel numbers don't.
                  call ClearMask ( qty%mask(:,instance), &
                    & (/ channel+qty%template%noChans*(height-1) /), &
                    & what=maskBit )
                end do                  ! Height loop
              end if                    ! Do this channel
            end do                      ! Channel loop
          end if                        ! Reset specified
        end if                          ! Got heights or ignore

        ! Now go and `unmask' the ones we want to consider.  For coherent
        ! quantities we can simply loop over the indices of each height range.
        ! For incoherent ones we have to go through and mark each point
        ! appropriately.
        if ( got(f_height) ) then
          do j = 2, nsons(heightNode)
            ! Get values for this ragne
            son = subtree ( j, heightNode )
            rangeId = node_id ( son )
            call expr ( son, units, value, type )
            ! Now maybe do something nasty to value to get in right units.
            if ( coordinate == l_zeta .and. heightUnit == phyq_pressure ) then
              value = -log10(value)
            else
              if ( coordinate /= qty%template%verticalCoordinate ) &
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Inappropriate units for height in subset' )
            end if

            ! Do special things for coherent quantities
            if ( qty%template%coherent ) then
              if ( qty%template%verticalCoordinate == l_pressure ) then
                s1 = minloc ( abs ( -log10(theseHeights) + log10(value(1)) ) )
                s2 = minloc ( abs ( -log10(theseHeights) + log10(value(2)) ) )
              else
                s1 = minloc ( abs ( theseHeights - value(1) ) )
                s2 = minloc ( abs ( theseHeights - value(2) ) )
              end if

              ! Now consider the open range issue
              select case ( rangeId )
              case ( n_colon_less )
                s1 = min ( s1 + 1, qty%template%noSurfs )
              case ( n_less_colon )
                s2 = max ( s2 - 1, 1 )
              case ( n_less_colon_less )
                s1 = min ( s1 + 1, qty%template%noSurfs )
                s2 = max ( s2 - 1, 1 )
              end select
            end if
 
            scanDirection = 0
            do channel = 1, qty%template%noChans
              doThisChannel = .true.
              if ( associated(channels) ) doThisChannel = channels(channel)
              if ( doThisChannel ) then

                ! Think about optical depth.  We want the cutoff to apply once
                ! and definitively, not have channels come in and out of use as
                ! a function of tangent height.  To do this we need to work out
                ! where we 'first' go optically thick. To do this we need to
                ! work out whether we're scanning up or down.
                if ( associated ( opticalDepth ) ) then
                  ! Don't bother deducing direction if we alredy know
                  if ( scanDirection == 0 ) then
                    ind = qty%template%noChans + channel
                    do height = 2, qty%template%noSurfs
                      scanDirection = scanDirection + merge ( 1, -1, &
                        & opticalDepth%template%surfs(height,instanceOr1) > &
                        & opticalDepth%template%surfs(height-1,instanceOr1) )
                    end do
                    ! Now convert it to +/-1.
                    if ( scanDirection == 0 ) scanDirection = 1 ! Default upscan
                    scanDirection = scanDirection / abs(scanDirection) 
                  end if
                  ! Now find `first' optically thick radiance look down from top
                  if ( scanDirection == 1 ) then ! Scanning up
                    ind = qty%template%noChans*(qty%template%noSurfs-1) + channel
                    do odCutoffHeight = qty%template%noSurfs, 1, - 1 
                      if ( opticalDepth%values ( ind, instance ) > &
                        & opticalDepthCutoff ) exit
                      ind = ind - qty%template%noChans
                    end do
                  else ! else scanning down
                    ind = qty%template%noChans + channel
                    do odCutoffHeight = 1, qty%template%noSurfs
                      if ( opticalDepth%values ( ind, instance ) > &
                        & opticalDepthCutoff ) exit
                      ind = ind + qty%template%noChans
                    end do
                  end if
                end if

                if ( qty%template%coherent ) then
                  ! For coherent quantities simply do a loop over a range.
                  do height = s1(1), s2(1)
                    !??? Make sure mask bit numbers begin at 1, even when
                    !??? channel numbers don't.
                    ind = channel + qty%template%noChans*(height-1)
                    doThisHeight = .true.
                    if ( got ( f_minValue ) ) doThisHeight = doThisHeight .and. &
                        & qty%values( ind, instance ) > minValue
                    if ( got ( f_maxValue ) ) doThisHeight = doThisHeight .and. &
                        & qty%values( ind, instance ) < maxValue
                    if ( doThisHeight ) then
                      if ( associated( opticalDepth ) ) then
                        if ( scanDirection * ( height - odCutoffHeight ) > 0 ) &
                          & call ClearMask ( qty%mask(:,instance), (/ind/), what=maskBit )
                      else
                        call ClearMask ( qty%mask(:,instance), (/ind/), what=maskBit )
                      end if
                    end if
                  end do                ! Height loop
                else
                  ! For Incoherent quantities check each height individually
                  ! We might as well consider open and non open ranges, but
                  ! it's really rather unnecessary, as the chance of a ptan
                  ! being exactly equal to the range given is remote, and the
                  ! difference probably doesn't matter anyway.
                  do height = 1, qty%template%noSurfs
                    ind = channel + qty%template%noChans*(height-1)
                    doThisHeight = .true.
                    if (any(rangeID==(/ n_less_colon,n_less_colon_less /))) then
                      doThisHeight = doThisHeight .and. theseHeights(height) > value(1)
                    else
                      doThisHeight = doThisHeight .and. theseHeights(height) >= value(1)
                    end if
                    if (any(rangeID==(/ n_colon_less,n_less_colon_less /))) then
                      doThisHeight = doThisHeight .and. theseHeights(height) < value(2)
                    else
                      doThisHeight = doThisHeight .and. theseHeights(height) <= value(2)
                    end if
                    if ( associated ( opticalDepth ) ) then
                      doThisHeight = doThisHeight .and. &
                        & scanDirection * ( height - odCutoffHeight ) > 0
                    end if
                    if ( got ( f_minValue ) ) doThisHeight = doThisHeight .and. &
                        & qty%values( ind, instance ) > minValue
                    if ( got ( f_maxValue ) ) doThisHeight = doThisHeight .and. &
                        & qty%values( ind, instance ) < maxValue
                    if ( doThisHeight ) call ClearMask ( qty%mask(:,instance), &
                        & (/ ind /), what=maskBit )
                  end do                ! Height loop
                end if                  ! Coherent
              end if                    ! Do this channel
            end do                      ! Channel loop
          end do                        ! Height entries in l2cf
        end if                          ! Got a height entry

        ! If this is supposed to be an 'additional' mask, merge in the
        ! original value
        if ( additional ) &
          & qty%mask(:,instance) = char ( ior ( &
          & ichar ( qty%mask(:,instance) ), ichar ( originalMask ) ) )
      end do                            ! Instance loop
      
      ! Tidy up
      call Deallocate_test ( channels, 'channels', ModuleName )
      if ( additional ) call Deallocate_test ( originalMask, &
        & 'originalMask', ModuleName )
      
      if ( index(switches,'msk') /= 0 ) then
        if ( qty%template%name /= 0 ) then
          call output ( ' Qty_Template_Name = ' )
          call display_string ( qty%template%name )
        end if
        call output ( ' ', advance='yes' )
        call output ( 'Elements per mask = ' )
        call output ( size(qty%values,1), advance='yes' )
        call output ( 'noChans = ' )
        call output ( qty%template%noChans, advance='no' )
        call output ( ' noSurfs = ' )
        call output ( qty%template%noSurfs, advance='no' )
        call output ( ' noInstances = ' )
        call output ( qty%template%noInstances, advance='no' )
        call output ( ' instanceLen = ' )
        call output ( qty%template%instanceLen, advance='yes' )
        call dumpMask ( qty )
        ! P. Wagner's inspection of masking array
        if ( got(f_height) ) then
          nrows = qty%template%noSurfs
          call output ( '(Suppressing channel info, rows are surfaces) ', &
          & advance='no' )
        else
          nrows = qty%template%noChans
          call output ( '(Suppressing mif info, rows are channels) ', &
          & advance='no' )
        end if
        nrows = min(nrows, MAXCOLUMNS)
        call output ( 'column, row look at mask', advance='yes' )
        maskedMan=' '
        call output ( 'column ', advance='no' )
        call blanks(14, advance='no')
        call output ( 'mask', advance='yes' )
        call output ( 'rows ->', advance='no' )
        do j=10, nrows, 10
          call blanks(10-len(decades), advance='no')
          write(decades, '(i5.2)') mod(j, 100)
          call output(decades, advance='no')
        end do
        call output(' ', advance='yes')
        heightMin=+1.d4
        heightMax=-1.d4
        do i=1, size(qty%values(1,:))
          maskedMan='0'
          do j=1, nrows
            if ( got(f_height) ) then
              row = 1 + qty%template%noChans*(j-1)
            else
              row = j
            end if
            if ( IsVectorQtyMasked(qty, row, i) ) then
              maskedMan(j)='1'
              if ( got(f_height) .and. j <= size(theseheights)) then
                heightMin = min(heightMin, theseheights(j))
                heightMax = max(heightMax, theseheights(j))
              endif
            endif
          end do
          call output ( i, format='(i3)', advance='no' )
          call blanks(4, advance='no')
          call output ( MaskedMan(1:nrows), advance='yes' )
        end do
        if ( got(f_height) ) then
          call output ( 'min, max heights masked out: ', advance='no' )
          call output ( exp(-log(10.)*heightMax), advance='no' )
          call blanks(4, advance='no')
          call output ( exp(-log(10.)*heightMin), advance='yes' )
        end if
      end if
      if ( error /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'An error occured during the subset setup' )
    end subroutine SetupSubset

    ! -------------------------------------------------- FlagCloud ---
    subroutine SetupFlagCloud ( key, vectors )

      use Declaration_table, only: NUM_VALUE
      use Intrinsic, only: PHYQ_PRESSURE, PHYQ_TEMPERATURE, L_CLOUDINDUCEDRADIANCE
      use VectorsModule, only: ClearMask, CreateMask, &
        & GetVectorQtyByTemplateIndex, SetMask, VectorValue_T

      integer, intent(in) :: KEY        ! Tree node
      type (Vector_T), dimension(:) :: VECTORS

      ! Local variables
      integer :: CHANNEL                ! Loop index
      integer :: CHANNELSNODE           ! Tree node for channels values
      integer :: CLOUDCHANNELSNODE      ! Tree node for CLOUDchannels values
      integer :: COORDINATE             ! Vertical coordinate type
      integer :: FIELD                  ! Field type from tree
      integer :: GSON                   ! Tree node
      integer :: HEIGHT                 ! Loop counter
      integer :: HEIGHT1                 ! Loop counter
      integer :: CLOUDHEIGHTNODE             ! Tree node for cloudheight values
      integer :: HEIGHTNODE             ! Tree node for height values
      integer :: CLOUDHEIGHTUNIT             ! Unit for cloudheights command
      integer :: HEIGHTUNIT             ! Unit for heights command
      integer :: IND,IND1,J, I          ! Aarray indices
      integer :: INSTANCE               ! Loop counter
      integer :: MaskBit                ! Bits corresponding to Mask
      integer :: QUANTITYINDEX          ! Index
      integer :: RANGEID                ! nodeID of a range
      integer :: SON                    ! Tree node
      integer :: STATUS                 ! Flag
      integer :: TYPE                   ! Type of value returned by expr
      integer :: UNITS(2)               ! Units returned by expr
      integer :: VECTORINDEX            ! Index
      integer :: USETHISCHANNEL         ! cloud radiance channel

      real(r8), dimension(:), pointer :: THESEHEIGHTS ! Subset of heights
      real(r8) :: VALUE(2)              ! Value returned by expr
      real(r8) :: HeightVALUE(2)              ! Value returned by height expr
      real(r8) :: CHeightVALUE(2)              ! Value returned by cloudHeight expr
      real(r8) :: cloudRadianceCutOff              ! threshold for flagging cloud
      type (VectorValue_T), pointer :: QTY ! The quantity to mask
      type (VectorValue_T), pointer :: PTAN ! The ptan quantity if needed
      type (VectorValue_T), pointer :: cloudRadiance ! cloud radiances

      logical :: Got(field_first:field_last)   ! "Got this field already"
      logical, dimension(:), pointer :: CHANNELS ! Are we dealing with these channels
      logical, dimension(:), pointer :: CLOUDCHANNELS ! Are we dealing with these cloud channels
      logical :: DOTHISCLOUDHEIGHT           ! Flag
      logical :: DOTHISHEIGHT           ! Flag
      logical :: DOTHISCHANNEL          ! Flag
      logical :: ISCLOUD                ! Flag

      integer, parameter ::                      MAXCOLUMNS = 127

      ! Executable code
      nullify ( channels, cloudChannels, qty, ptan, cloudRadiance )
      got = .false.
      maskBit = m_linalg   ! default mask bit

      do j = 2, nsons(key) ! fields of the "Flagcloud" specification
        son = subtree(j, key)
        field = get_field_id(son)   ! tree_checker prevents duplicates
        if (nsons(son) > 1 ) gson = subtree(2,son) ! Gson is value
        select case ( field )
        case ( f_quantity )
          vectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          qty => GetVectorQtyByTemplateIndex(vectors(vectorIndeX), quantityIndex)
        case ( f_ptanquantity )
          vectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          ptan => GetVectorQtyByTemplateIndex(vectors(vectorIndeX), quantityIndex)
        case ( f_height )
          heightNode = son
        case ( f_cloudHeight )
          cloudHeightNode = son
        case ( f_channels )
          channelsNode = son
        case ( f_cloudChannels )
          cloudchannelsNode = son
        case ( f_cloudRadiance )
          vectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          cloudRadiance => GetVectorQtyByTemplateIndex(vectors(vectorIndeX), quantityIndex)
        case ( f_cloudRadianceCutoff )
          call expr ( subtree (2, son), units, Value, type )
          if ( type /= num_value ) call announceError ( &
            & rangeNotAppropriate, f_cloudRadianceCutoff )
          if ( units(1) /= phyq_TEMPERATURE ) &
            & call announceError ( wrongUnits, f_cloudRadianceCutoff, string='no' )
          cloudRadianceCutoff = value(1)
        case default
          ! Shouldn't get here if the type checker worked
        end select
        got(field) = .true.
      end do ! j = 2, nsons(key)

      ! Check if got the cloud radiance and threshold
      if ( .not. all(got((/ f_cloudRadiance, f_cloudRadianceCutoff, &
         & f_height, f_ptanQuantity, f_cloudChannels /))) ) &
         & call AnnounceError ( cannotFlagCloud, key )
      ! Quantity must be radiance
      if ( qty%template%quantityType /= l_radiance &
         & .or. (cloudRadiance%template%quantityType /= l_cloudInducedRadiance &
         & .and. cloudRadiance%template%quantityType /= l_radiance)) &
         & call AnnounceError ( badQuantities, key )

      ! Process the channels field used in cloudRadiance, must have 1 channel
      call Allocate_test ( cloudChannels, cloudRadiance%template%noChans, &
          & 'cloudChannels', ModuleName )
      call GetIndexFlagsFromList ( cloudChannelsNode, cloudChannels, status, &
          & lower=lbound(cloudChannels,1) )
      if(count(cloudChannels) .ne. 1) &
         & call AnnounceError ( badChannel, key )
      do channel = 1, cloudRadiance%template%noChans
         if ( cloudChannels(channel) ) useThisChannel = channel
      end do

      if( got(f_channels)) then
      call Allocate_test ( Channels, qty%template%noChans, &
          & 'channels', ModuleName )
      call GetIndexFlagsFromList ( channelsNode, channels, status, &
          & lower=lbound(channels,1) )
      end if

      ! Preprocess the height stuff.
      heightUnit = phyq_dimensionless
      if ( got(f_height) ) then
        if (nsons(cloudheightNode) .gt. 2) then 
            print*,'the input height range is not allowed in FlagCloud'
            stop
        endif 

          call expr ( subtree(2,heightNode), units, value, type )
          ! Make sure the range has non-dimensionless units -- the type
          ! checker only verifies that they're consistent.  We need to
          ! check each range separately, because the units determine the
          ! scaling of the values.
          if ( all(units == phyq_dimensionless) ) call announceError ( &
            & wrongUnits, f_height, string = 'length or pressure.' )
          ! Check consistency of units -- all the same, or dimensionless. The
          ! type checker verifies the consistency of units of ranges, but not
          ! of array elements.
          do i = 1, 2
            if ( heightUnit == phyq_dimensionless ) then
              heightUnit = units(i)
            else if ( units(i) /= phyq_dimensionless .and. &
              &       units(i) /= heightUnit ) then
              call announceError ( inconsistentUnits, f_height )
            end if
          end do

          ! convert pressure unit
          Heightvalue = value
          if ( heightUnit == phyq_pressure ) Heightvalue = -log10(value)
          
      end if
      ! Preprocess the height stuff.
      cloudheightUnit = phyq_dimensionless
      if ( got(f_cloudheight) ) then
        if (nsons(cloudheightNode) .gt. 2) then 
            print*,'the input height range is not allowed in FlagCloud'
            stop
        endif 
            
          call expr ( subtree(2,cloudheightNode), units, value, type )
          if ( all(units == phyq_dimensionless) ) call announceError ( &
            & wrongUnits, f_cloudheight, string = 'length or pressure.' )
          do i = 1, 2
            if ( cloudheightUnit == phyq_dimensionless ) then
              cloudheightUnit = units(i)
            else if ( units(i) /= phyq_dimensionless .and. &
              &       units(i) /= cloudheightUnit ) then
              call announceError ( inconsistentUnits, f_cloudheight )
            end if
          end do

          ! convert pressure unit
          CHeightvalue = value
          if ( cloudheightUnit == phyq_pressure ) CHeightvalue = -log10(value)          
      end if

      ! ----- finish checking ------

      ! Create the mask if it doesn't exist
      if ( .not. associated( qty%mask ) ) call CreateMask ( qty )

      ! Now loop over the instances
      do instance = 1, qty%template%noInstances
          theseHeights => ptan%values(:,instance)
          coordinate = l_zeta

            isCloud = .false.
            
            ! use the given height range to find cloud flag
            if( got(f_cloudheight) ) then 
              do height1 = 1,cloudRadiance%template%noSurfs
                     doThisCloudHeight = .true.
                     doThisCloudHeight = doThisCloudHeight .and. theseHeights(height1) > Cheightvalue(1)
                     doThisCloudHeight = doThisCloudHeight .and. theseHeights(height1) < Cheightvalue(2)
                  ind1 = useThisChannel + cloudRadiance%template%noChans*(height1-1)
                  if ( doThisCloudHeight .and. &
                     & cloudRadiance%values ( ind1, instance ) > cloudRadianceCutoff) &
                     & isCloud = .true.
              enddo
            endif
            do height = 1, qty%template%noSurfs
                 doThisHeight = .true.
                 doThisHeight = doThisHeight .and. theseHeights(height) > heightvalue(1)
                 doThisHeight = doThisHeight .and. theseHeights(height) < heightvalue(2)

               ! determine cloud flag
               ! if cloud flag is not from a height range then do comparison at each minor frame
               if( .not. got(f_cloudheight) ) then 
                  ! use the same mif radiance to find cloud flag
                  isCloud = .false.
                  ind1 = useThisChannel + cloudRadiance%template%noChans*(height-1)
                  if ( cloudRadiance%values ( ind1, instance ) > cloudRadianceCutoff) &
                     & isCloud = .true.
               endif
               
               ! assign cloud flag
               do channel = 1, qty%template%noChans
                  doThisChannel = .true.
                  if ( associated(channels) ) doThisChannel = channels(channel)
                  if ( doThisChannel ) then
                  ind = channel + qty%template%noChans*(height-1)
                  if ( doThisHeight .and. isCloud )  &
                  &     call SetMask ( qty%mask(:,instance), (/ ind /), &
                  &     what=maskBit )
                  end if                   ! do this channel
               end do                   ! Channel loop
             end do                   ! height loop
      end do                            ! Instance loop

      ! Tidy up
      if(associated(channels)) call Deallocate_test ( channels, 'channels', ModuleName )
      call Deallocate_test ( cloudChannels, 'cloudChannels', ModuleName )

    end subroutine SetupFlagCloud
d3000 3
@


2.235
log
@fix another bug in FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.234 2003/02/25 18:58:35 dwu Exp $"
a3725 1
               print*,height,doThisHeight, isCloud
d3744 3
@


2.234
log
@fix another bug in FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.233 2003/02/24 19:20:40 dwu Exp $"
d3673 1
a3673 1
          if ( heightUnit == phyq_pressure ) CHeightvalue = -log10(value)          
d3745 3
@


2.233
log
@fix a bug in FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.232 2003/02/14 01:56:36 livesey Exp $"
d3709 1
d3726 1
a3727 1

d3745 3
@


2.232
log
@Added the 'additional' capability in subset
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.231 2003/02/12 02:11:13 livesey Exp $"
d3531 2
d3579 1
a3579 1
          call expr ( subtree (2, son), units, value, type )
d3622 6
a3627 2
        do j = 2, nsons(heightNode)
          call expr ( subtree(j,heightNode), units, value, type )
d3645 5
a3649 1
        end do
d3654 6
a3659 6
        do j = 2, nsons(cloudheightNode)
          call expr ( subtree(j,cloudheightNode), units, value, type )
          ! Make sure the range has non-dimensionless units -- the type
          ! checker only verifies that they're consistent.  We need to
          ! check each range separately, because the units determine the
          ! scaling of the values.
a3661 3
          ! Check consistency of units -- all the same, or dimensionless. The
          ! type checker verifies the consistency of units of ranges, but not
          ! of array elements.
d3670 4
a3673 1
        end do
a3685 13
          do j = 2, nsons(heightNode)
            ! Get values for this ragne
            son = subtree ( j, heightNode )
            rangeId = node_id ( son )
            call expr ( son, units, value, type )
            ! Now maybe do something nasty to value to get in right units.
            if ( heightUnit == phyq_pressure ) then
              value = -log10(value)
            else
                call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Inappropriate units for height in flag cloud' )
            end if

d3690 1
a3690 1
                  do height1 = 1,cloudRadiance%template%noSurfs
d3692 2
a3693 10
                     if (any(rangeID==(/ n_less_colon,n_less_colon_less /))) then
                     doThisCloudHeight = doThisCloudHeight .and. theseHeights(height1) > value(1)
                     else
                     doThisCloudHeight = doThisCloudHeight .and. theseHeights(height1) >= value(1)
                     end if
                     if (any(rangeID==(/ n_colon_less,n_less_colon_less /))) then
                     doThisCloudHeight = doThisCloudHeight .and. theseHeights(height1) < value(2)
                     else
                     doThisCloudHeight = doThisCloudHeight .and. theseHeights(height1) <= value(2)
                     end if
d3698 1
a3698 1
                  enddo
a3699 1
               
d3701 3
a3703 11
               doThisHeight = .true.
               if (any(rangeID==(/ n_less_colon,n_less_colon_less /))) then
                 doThisHeight = doThisHeight .and. theseHeights(height) > value(1)
               else
                 doThisHeight = doThisHeight .and. theseHeights(height) >= value(1)
               end if
               if (any(rangeID==(/ n_colon_less,n_less_colon_less /))) then
                 doThisHeight = doThisHeight .and. theseHeights(height) < value(2)
               else
                 doThisHeight = doThisHeight .and. theseHeights(height) <= value(2)
               end if
d3723 1
a3723 1
               end if                   ! do this channel
d3725 2
a3726 2
             end do                     ! Height loop
          end do                        ! Height node entries in l2cf
d3744 3
@


2.231
log
@New code for extended averaging kernels
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.230 2003/02/08 00:20:25 livesey Exp $"
d39 1
a39 1
    use Init_Tables_Module, only: F_apriori, F_aprioriScale, F_Average, &
a2995 1

d3044 1
d3050 1
d3057 1
d3120 2
d3204 7
d3213 4
d3407 6
d3414 1
a3414 1

d3417 2
d3764 3
@


2.231.2.1
log
@fix a bug in FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.233 2003/02/24 19:20:40 dwu Exp $"
d39 1
a39 1
    use Init_Tables_Module, only: F_additional, F_apriori, F_aprioriScale, F_Average, &
d2996 1
a3044 1
      logical :: ADDITIONAL             ! Flag
a3049 1
      character(len=1), dimension(:), pointer :: ORIGINALMASK
a3055 1
      additional = .false.
a3117 2
        case ( f_additional )
          additional = Get_Boolean ( son )
a3199 7
      ! Make a space to save the original values if doing an additional mask
      if ( additional ) then
        nullify ( originalMask )
        call Allocate_test ( originalMask, qty%template%instanceLen, &
          & 'originalMask', ModuleName )
      end if

a3201 4

        ! Possibly save original mask
        if ( additional ) originalMask = qty%mask ( :, instance )

d3392 1
a3393 7
        ! If this is supposed to be an 'additional' mask, merge in the
        ! original value
        if ( additional ) &
          & qty%mask(:,instance) = char ( ior ( &
          & ichar ( qty%mask(:,instance) ), ichar ( originalMask ) ) )
      end do                            ! Instance loop
      
a3395 2
      if ( additional ) call Deallocate_test ( originalMask, &
        & 'originalMask', ModuleName )
a3507 2
      real(r8) :: HeightVALUE(2)              ! Value returned by height expr
      real(r8) :: CHeightVALUE(2)              ! Value returned by cloudHeight expr
d3554 1
a3554 1
          call expr ( subtree (2, son), units, Value, type )
d3597 2
a3598 6
        if (nsons(cloudheightNode) .gt. 2) then 
            print*,'the input height range is not allowed in FlagCloud'
            stop
        endif 

          call expr ( subtree(2,heightNode), units, value, type )
d3616 1
a3616 5

          ! convert pressure unit
          Heightvalue = value
          if ( heightUnit == phyq_pressure ) Heightvalue = -log10(value)
          
d3621 6
a3626 6
        if (nsons(cloudheightNode) .gt. 2) then 
            print*,'the input height range is not allowed in FlagCloud'
            stop
        endif 
            
          call expr ( subtree(2,cloudheightNode), units, value, type )
d3629 3
d3640 1
a3640 4

          ! convert pressure unit
          CHeightvalue = value
          if ( heightUnit == phyq_pressure ) CHeightvalue = -log10(value)          
d3653 13
d3670 1
a3670 1
              do height1 = 1,cloudRadiance%template%noSurfs
d3672 10
a3681 2
                     doThisCloudHeight = doThisCloudHeight .and. theseHeights(height1) > Cheightvalue(1)
                     doThisCloudHeight = doThisCloudHeight .and. theseHeights(height1) < Cheightvalue(2)
d3686 1
a3686 1
              enddo
d3688 1
d3690 11
a3700 3
                 doThisHeight = .true.
                 doThisHeight = doThisHeight .and. theseHeights(height) > heightvalue(1)
                 doThisHeight = doThisHeight .and. theseHeights(height) < heightvalue(2)
d3720 1
a3720 1
                  end if                   ! do this channel
d3722 2
a3723 2
             end do                   ! height loop

a3740 9
! Revision 2.233  2003/02/24 19:20:40  dwu
! fix a bug in FlagCloud
!
! Revision 2.232  2003/02/14 01:56:36  livesey
! Added the 'additional' capability in subset
!
! Revision 2.231  2003/02/12 02:11:13  livesey
! New code for extended averaging kernels
!
@


2.231.2.2
log
@fix another bug in FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.234 2003/02/25 18:58:35 dwu Exp $"
a3708 1
                  isCloud = .false.
a3724 1
               print*,height,doThisHeight, isCloud
d3726 1
a3743 3
! Revision 2.234  2003/02/25 18:58:35  dwu
! fix another bug in FlagCloud
!
@


2.231.2.3
log
@fix another bug in FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.235 2003/02/25 19:04:43 dwu Exp $"
d3673 1
a3673 1
          if ( cloudheightUnit == phyq_pressure ) CHeightvalue = -log10(value)          
a3744 3
! Revision 2.235  2003/02/25 19:04:43  dwu
! fix another bug in FlagCloud
!
@


2.230
log
@Added error message to check that the right ptan (GHz/THz) is used in
subset statements.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.229 2003/02/05 20:59:16 dwu Exp $"
d43 1
a43 1
      & F_diagnostics, F_diagonal, &
d71 1
a71 1
      & Sparsify
d128 2
d315 1
d355 2
d1041 2
d1091 4
d1398 2
a1399 1
          if ( got(f_average) ) then ! Need a separate matrix for K^T K
d1486 4
d1499 7
a1505 3
          ! If an averaging kernel has been requested, K^T K was accumulated
          ! separately from normalEquations.  So we need to add it in.
          if ( got(f_average) ) call addToMatrix ( normalEquations%m, kTk%m )
d2080 8
a2087 3
        ! Make sure kTk is symmetrical (outputCovariance is by virtue of its creation method 
        Call ReflectMatrix ( kTk%m )
        outputAverage = outputCovariance%m .tx. kTk%m
d2100 1
d3741 4
@


2.229
log
@an improvement in flagcloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.228 2003/02/05 04:07:05 dwu Exp $"
d3182 3
d3440 2
d3715 3
@


2.228
log
@add cloudheight option for flagcloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.227 2003/02/03 23:08:50 vsnyder Exp $"
d3635 4
a3638 17
            do height = 1, qty%template%noSurfs
               doThisHeight = .true.
               if (any(rangeID==(/ n_less_colon,n_less_colon_less /))) then
                 doThisHeight = doThisHeight .and. theseHeights(height) > value(1)
               else
                 doThisHeight = doThisHeight .and. theseHeights(height) >= value(1)
               end if
               if (any(rangeID==(/ n_colon_less,n_less_colon_less /))) then
                 doThisHeight = doThisHeight .and. theseHeights(height) < value(2)
               else
                 doThisHeight = doThisHeight .and. theseHeights(height) <= value(2)
               end if

               ! determine cloud flag
               isCloud = .false.
               if( got(f_cloudheight) ) then 
                  ! use the given height range to find cloud flag
d3656 6
d3663 11
d3710 3
@


2.227
log
@Delete test for small residual -- there's a test relative to FNMIN in
dnwt.  Add stuff for dnwt to use Mor\'e and Sorensen algorithm to
compute the Levenberg parameter.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.225 2003/01/18 02:15:43 vsnyder Exp $"
d40 2
a41 1
      & F_channels, F_cloudChannels, F_cloudRadiance, F_cloudRadianceCutOff, &
d3458 2
d3461 1
d3485 1
d3512 2
d3587 24
d3648 1
d3650 27
a3676 4
               ind1 = useThisChannel + cloudRadiance%template%noChans*(height-1)
               if ( cloudRadiance%values ( ind1, instance ) > cloudRadianceCutoff) &
                  & isCloud = .true.
                  
d3706 5
@


2.226
log
@Added the fnorm switch to dump contributions to fnorm
@
text
@d1020 1
d1047 1
d1068 1
a1069 1
      foundBetterState = ( maxJacobians == 0 )
d1095 1
d1231 1
d1240 1
d1245 1
a1248 1
            if ( .not. foundBetterState ) exit
a1292 4
            if ( index ( switches, 'fnorm' ) /= 0 ) then
              call output ( 'A priori contribution to | F | = ' )
              call output ( aj%fnorm, advance='yes' )
            end if
a1318 3
            if ( index ( switches, 'fnorm' ) /= 0 ) then
              call output ( 'No a priori so setting | F | to zero.', advance='yes' )
            end if
a1368 8
              if ( index ( switches, 'fnorm' ) /= 0 ) then
                if ( t == 1 ) then
                  call output ( 'Vertical Regularization contribution to | F | = ' )
                else
                  call output ( 'Horizontal Regularization contribution to | F | = ' )
                end if
                call output ( v(reg_X_x) .dot. v(reg_X_x), advance='yes' )
              end if
a1487 4
          if ( index ( switches, 'fnorm' ) /= 0 ) then
            call output ( 'Measurement contribution to | F | = ' )
            call output ( v(f_rowScaled) .mdot. v(f_rowScaled), advance='yes' )
          end if
a1557 8
              if ( index ( switches, 'fnorm' ) /= 0 ) then
                if ( t == 1 ) then
                  call output ( 'Vertical Regularization contribution to | F | = ' )
                else
                  call output ( 'Horizontal Regularization contribution to | F | = ' )
                end if
                call output ( v(reg_X_x) .dot. v(reg_X_x), advance='yes' )
              end if
a1566 20
          ! Quit if the tolerance is reached.  aj%fnorm is norm**2 here.
          if ( nwt_flag /= nf_getj .and. aj%fnorm < toleranceF**2 ) then
              if ( index(switches,'nwt') /= 0 ) then
                call output ( &
                  & 'Newton iteration terminated because aj%fnorm (' )
                call output ( aj%fnorm )
                call output ( ') < ToleranceF (' )
                call output ( toleranceF )
                call output ( ')', advance='yes' )
              end if
            ! Finish getting the Jacobian, and form normal equations, to get
            ! the a posteriori covariance.
            if ( .not. got(f_outputCovariance) .and. .not. got(f_outputSD) &
              & .and. .not. got(f_average) ) then
                aj%fnorm = sqrt(aj%fnorm)
                exit
            end if
            nwt_flag = nf_getJ ! so we exit the loop at the end
          end if

d1695 3
a1697 3
          ! Correct for apriori information, note that there is an approximation here
          ! we don't take any account of whether the a priori is used on an element
          ! by element basis.
d1717 9
a1725 2
        ! Calculate quantities necessary to determine the
        ! Levenberg-Marquardt stabilization parameter
d1903 1
a1903 1
              call output ( aj%gradn * aj%gfac, advance='yes' )
d1908 1
a1945 1
          if ( nwt_flag == nf_tolx_best ) call copyVector ( v(x), v(bestX) )
d1948 4
d2075 1
@


2.225
log
@Change names of global loop inductors "I" and "J" to something more clever,
i.e., I_Sons and I_Key.  It's too easy to use "I" and "J" in internal
procedures, thereby clobbering the important values of these loop
inductors.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.224 2003/01/18 01:40:10 vsnyder Exp $"
d1288 4
d1318 3
d1371 8
d1498 4
d1572 8
d3681 6
@


2.224
log
@Prepare for More and Sorensen
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.223 2003/01/17 22:59:47 livesey Exp $"
d139 1
a139 1
    integer :: I, J, K                  ! Subscripts and loop inductors
d148 1
d253 2
a254 2
    do i = 2, nsons(root) - 1           ! skip names at begin/end of section
      son = subtree(i, root)
d279 2
a280 2
        do j = 2, nsons(key)
          son = subtree(j, key)
d328 2
a329 2
        do j = 2, nsons(key) ! fields of the "retrieve" specification
          son = subtree(j, key)
d434 1
a434 1
        end do ! j = 2, nsons(key)
d599 1
a599 1
    end do ! i = 2, nsons(root) - 1
d3654 3
@


2.223
log
@Minor bug fix in units checking for max/minValue in subset.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.222 2003/01/17 22:13:46 dwu Exp $"
d992 4
a995 4
      use DNWT_Module, only: FlagName, NF_EVALF, NF_EVALJ, NF_SOLVE, &
        & NF_NEWX, NF_GMOVE, NF_BEST, NF_AITKEN, NF_DX, NF_DX_AITKEN, &
        & NF_SMALLEST_FLAG, NF_START, NF_TOLX, NF_TOLX_BEST, NF_TOLF, &
        & NF_TOO_SMALL, NF_FANDJ, NWT, NWT_T, NWTA, NWTDB, NWTOP, RK
d1048 2
a1049 2
      ! dx_aitken dx aitken best gmove newx solve evalj evalf
        &      3, 2,     3,   2,    2,   1,    2,    2,    2,  &
d1730 3
d1900 2
a1902 1
          if ( .not. aj%starting ) aj%dxdxl = v(dx) .dot. v(bestGradient)
d3653 3
@


2.222
log
@fix a bug in flagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.221 2003/01/17 16:55:19 dwu Exp $"
d65 1
a65 1
    use Intrinsic, only: PHYQ_Dimensionless
d3107 1
a3107 1
      if ( vectors(mainVectorIndex)%globalUnit /= phyq_dimensionless ) then
d3649 3
@


2.221
log
@a minor change in FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.220 2003/01/16 21:48:22 vsnyder Exp $"
d265 1
d267 1
d302 1
a302 1
        call flagCloud ( key, vectorDatabase )
d3437 1
a3437 1
    subroutine FlagCloud ( key, vectors )
d3457 1
a3457 1
      integer :: IND,IND1,J             ! Aarray indices
d3486 1
a3486 1
      nullify ( channels, qty, ptan, cloudRadiance )
d3532 2
a3533 2
         & .or. cloudRadiance%template%quantityType /= l_cloudInducedRadiance &
         & .or. cloudRadiance%template%quantityType /= l_radiance) &
d3599 1
a3599 1
                & 'Inappropriate units for height in subset' )
d3626 1
a3626 2
                  &     call SetMask ( qty%mask(:,instance), &
                  &     (/ channel+qty%template%noChans*(height-1) /), &
d3635 1
a3635 1
      call Deallocate_test ( channels, 'channels', ModuleName )
d3638 1
a3638 1
    end subroutine FlagCloud
d3649 3
@


2.220
log
@More stuff on getting NWTA internal output
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.219 2003/01/16 04:06:58 vsnyder Exp $"
d3438 1
a3438 1
      use Intrinsic, only: PHYQ_PRESSURE, PHYQ_TEMPERATURE
d3530 1
d3648 3
@


2.219
log
@Change some output in DNWT
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.218 2003/01/15 01:49:29 vsnyder Exp $"
d1139 2
a1140 2
            if ( index(switches,'nin') /= 0 ) &
              & call nwtop ( (/ 1, 1, 0 /) ) ! Turn on NWTA's internal output
d3647 3
@


2.218
log
@Revise dumping stuff for Newton method
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.217 2003/01/14 22:14:43 dwu Exp $"
d993 1
a993 1
        & NF_TOO_SMALL, NF_FANDJ, NWT, NWT_T, NWTA, NWTDB, RK
d1139 2
d1832 2
a1833 2
            if ( index(switches,'ndb') /= 0 ) call nwtdb ( width=9, level=0 )
            call nwtdb ( width=9, level=0 )
d1836 1
a1836 1
                call nwtdb ( width=9 )
d1838 1
a1838 1
                call nwtdb ( aj, width=9 )
d1902 3
a1904 1
              call output ( aj%gfac, format='(1pe14.7)', advance='yes' )
d3647 3
@


2.217
log
@make FlagCloud depend on both channels and cloudChannels
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.216 2003/01/13 17:17:29 jonathan Exp $"
d1830 3
a1832 1
            if ( index(switches,'ndb') /= 0 ) then
d1981 1
a1981 1
        else if ( index(switches,'ndb') /= 0 ) then
d3643 3
@


2.216
log
@ change cloud_width to i_saturation
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.215 2003/01/12 07:33:42 dwu Exp $"
d40 1
a40 1
      & F_channels, F_cloudRadiance, F_cloudRadianceCutOff, &
d3442 1
d3470 1
d3472 1
d3499 2
d3520 1
a3520 1
         & f_height, f_ptanQuantity, f_channels /))) ) &
d3528 12
a3539 1
      call Allocate_test ( channels, cloudRadiance%template%noChans, &
d3543 1
a3543 5
      if(count(channels) .ne. 1) &
         & call AnnounceError ( badChannel, key )
      do channel = 1, cloudRadiance%template%noChans
         if ( channels(channel) ) useThisChannel = channel
      end do
d3612 3
d3620 1
d3628 1
d3641 3
@


2.215
log
@with some fix in flagcloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.214 2003/01/11 15:51:34 dwu Exp $"
d2160 2
a2161 1
        cloudysky = configDatabase(configIndices(1))%cloud_width
d2217 4
a2220 2
          configDatabase(configIndices(1))%cloud_width=0
          if(doMaf) configDatabase(configIndices(1))%cloud_width=cloudysky
d2318 2
a2319 1
      configDatabase(configIndices(1))%cloud_width=cloudysky
d2482 2
a2483 1
           cloudysky(imodel) = configDatabase(configIndices(imodel))%cloud_width
d2528 2
a2529 1
         & configDatabase(configIndices(1))%cloud_width
d2543 5
a2547 3
            configDatabase(configIndices(imodel))%cloud_width=0
            if(doMaf(maf)) configDatabase(configIndices(imodel))%cloud_width=cloudysky(imodel)
            
d2776 2
a2777 1
        configDatabase(configIndices(imodel))%cloud_width=cloudysky(imodel)
d3624 3
@


2.214
log
@follow-up fix for FlagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.213 2003/01/11 08:08:01 dwu Exp $"
d235 1
a235 1
    integer, parameter :: BadRadianceSignal = BadQuantities + 1
d617 2
a622 3
      case ( badRadianceSignal )
        call output ( 'Mismatch in signal/sideband for radiance and cloud radiance', &
          & advance='yes' )
d3439 1
a3439 1
      integer :: IND                    ! An array index
d3449 1
a3459 1
      logical :: DOTHISCHANNEL          ! Flag
d3470 1
a3470 1
      do j = 2, nsons(key) ! fields of the "subset" specification
d3506 1
a3506 1
         & f_height, f_ptanQuantity /))) ) &
a3511 4
      ! Output radiance and cloud radiance must be the same signal
      if ( qty%template%signal /= cloudRadiance%template%signal .or. &
          &  qty%template%sideband /= cloudRadiance%template%sideband ) &
          & call AnnounceError ( badRadianceSignal, key )
d3513 2
a3514 3
      ! Process the channels field.
      if ( qty%template%frequencyCoordinate /= l_none ) then
        call Allocate_test ( channels, qty%template%noChans, &
d3516 7
a3522 8
        if ( got(f_channels) ) then     ! This subset is only for some channels
          call GetIndexFlagsFromList ( channelsNode, channels, status, &
            & lower=lbound(channels,1) )
          if ( status /= 0 ) call announceError ( wrongUnits, f_channels, string='no' )
        else
          channels = .true.             ! Apply this to all channels
        end if
      end if
d3541 2
a3542 1
            else if ( units(i) /= phyq_dimensionless ) then
d3572 12
a3583 18
            do channel = 1, qty%template%noChans
              doThisChannel = .true.
              if ( associated(channels) ) doThisChannel = channels(channel)
              if ( doThisChannel ) then
                  ind = qty%template%noChans + channel
                  do height = 1, qty%template%noSurfs
                    ind = channel + qty%template%noChans*(height-1)
                    doThisHeight = .true.
                    if (any(rangeID==(/ n_less_colon,n_less_colon_less /))) then
                      doThisHeight = doThisHeight .and. theseHeights(height) > value(1)
                    else
                      doThisHeight = doThisHeight .and. theseHeights(height) >= value(1)
                    end if
                    if (any(rangeID==(/ n_colon_less,n_less_colon_less /))) then
                      doThisHeight = doThisHeight .and. theseHeights(height) < value(2)
                    else
                      doThisHeight = doThisHeight .and. theseHeights(height) <= value(2)
                    end if
d3585 8
a3592 4
                    isCloud = .false.
                    if ( cloudRadiance%values ( ind, instance ) > cloudRadianceCutoff) &
                  &     isCloud = .true.
                    if ( doThisHeight .and. isCloud )  &
d3596 3
a3598 4
                  end do                ! Height loop
              end if                    ! Do this channel
            end do                      ! Channel loop
          end do                        ! Height entries in l2cf
d3615 3
@


2.213
log
@add flagCloud
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.212 2003/01/11 02:14:55 livesey Exp $"
d3531 24
d3556 1
d3571 1
a3571 1
            if ( coordinate == l_zeta .and. heightUnit == phyq_pressure ) then
d3574 1
a3574 2
              if ( coordinate /= qty%template%verticalCoordinate ) &
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
d3624 3
@


2.212
log
@Bug fix in max/min value subset
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.211 2003/01/11 01:02:50 livesey Exp $"
d40 2
a41 1
      & F_channels, F_columnScale, F_Comment, F_covariance, F_covSansReg, &
d63 1
a63 1
      & S_dumpBlocks, S_matrix, S_retrieve, S_sids, S_snoop, &
d233 3
d297 6
d617 7
d3419 172
d3600 3
@


2.211
log
@Added max and min value to subset
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.210 2003/01/08 23:52:38 livesey Exp $"
d2953 1
d2995 2
d3003 1
a3003 1
          vectorIndex = decoration(decoration(subtree(1,gson)))
d3005 1
a3005 1
          qty => GetVectorQtyByTemplateIndex(vectors(vectorIndeX), quantityIndex)
d3050 1
a3050 1
          minUnit = value(1)
d3074 2
a3075 2
      if ( vectors(vectorIndex)%globalUnit /= phyq_dimensionless ) then
        testUnit = vectors(vectorIndex)%globalUnit
d3080 1
a3080 1
        & call AnnounceError ( WrongUnits, key )
d3082 1
a3082 1
        & call AnnounceError ( WrongUnits, key )
d3411 3
@


2.210
log
@Added the sparsify stuff according to sparseQuantities
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.209 2003/01/07 23:44:17 livesey Exp $"
d45 2
a46 1
      & F_mask, F_maxJ, F_measurements, F_measurementSD, F_method, F_muMin, &
d2963 1
d2967 2
d2974 1
d3037 12
d3070 10
d3275 12
a3286 6
                    
                    if ( associated( opticalDepth ) ) then
                      if ( scanDirection * ( height - odCutoffHeight ) > 0 ) &
                        & call ClearMask ( qty%mask(:,instance), (/ind/), what=maskBit )
                    else
                      call ClearMask ( qty%mask(:,instance), (/ind/), what=maskBit )
d3312 4
d3408 3
@


2.209
log
@Added reset option to subset
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.208 2002/12/11 01:58:54 livesey Exp $"
d48 2
a49 1
      & F_regAfter, F_regApriori, F_reset, F_serial, F_state, F_toleranceA, F_toleranceF, &
d67 2
a68 1
      & Matrix_SPD_T, MultiplyMatrixVectorNoT, operator(.TX.), ReflectMatrix
d168 1
d234 1
a234 1
    nullify ( measurements, measurementSD, state, outputSD )
d378 6
d1071 1
d1432 2
d3371 3
@


2.208
log
@Changed detail of forward model parallel stuff
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.207 2002/12/06 18:41:24 livesey Exp $"
d48 1
a48 1
      & F_regAfter, F_regApriori, F_serial, F_state, F_toleranceA, F_toleranceF, &
d227 1
d657 3
d2964 1
d2975 1
d3022 2
d3055 4
a3061 1
        if ( ignore ) call announceError ( inconsistent, f_height, f_ignore )
d3112 2
a3113 1
        ! default is to ignore all
d3128 17
d3359 3
@


2.207
log
@Slightly new approach to FWMParallel mode
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.206 2002/11/23 00:07:13 vsnyder Exp $"
d983 1
a983 1
        & REQUESTSLAVESOUTPUT, RECEIVESLAVESOUTPUT, GETNOSLAVES
d1356 1
a1356 1
            latestMAFStarted = min ( GetNoSlaves(), &
d3330 3
@


2.206
log
@Delete some unused symbols
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.205 2002/11/22 00:11:16 livesey Exp $"
d983 1
a983 1
        & REQUESTSLAVESOUTPUT, RECEIVESLAVESOUTPUT
d1001 1
d1356 3
a1358 1
            do t = 1, chunk%lastMAFIndex-chunk%firstMAFIndex+1
d1374 5
d3330 3
@


2.205
log
@Better handling of foundBetterState
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.204 2002/11/20 21:05:55 livesey Exp $"
a36 1
    use Dump_0, only: Dump
d60 1
a60 1
      & S_dumpBlocks, S_forwardModel, S_matrix, S_retrieve, S_sids, S_snoop, &
d66 1
a66 1
      & Matrix_SPD_T, MultiplyMatrixVectorNoT, operator(.TX.), ReflectMatrix, Dump
d81 1
a81 1
    use Tree_Types, only: N_colon, N_colon_less, N_less_colon, &
d83 1
a83 1
    use VectorsModule, only: AddToVector, AddVectorToDatabase, ClearMask, ClearUnderMask, &
d85 1
a85 1
      & DestroyVectorInfo, DestroyVectorDatabase, DumpMask, GetVectorQuantityByType, &
a155 1
    type(vector_T), dimension(:), pointer :: MyVectors ! database
d230 1
a230 1
    nullify ( measurements, measurementSD, myVectors, state, outputSD )
d969 2
a970 2
        & ColumnScale, CopyMatrix, CopyMatrixValue, CreateEmptyMatrix, &
        & DestroyMatrix, dump_Linf, dump_struct, &
d972 1
a972 1
        & GetDiagonal, InvertCholesky, Matrix_T, Matrix_Database_T, &
d974 1
a974 1
        & MultiplyMatrix_XY_T,  Negate, RowScale, ScaleMatrix, SolveCholesky, &
d980 1
a980 1
        & DestroyVectorValue, Dump, Multiply, operator(.DOT.), &
a2020 2
      ! Most of the vectors are in the myVectors database, which is
      ! destroyed upon exit from Retrieve.
d2034 1
a2034 2
                     & L_CLOUDRADSENSITIVITY,                            &
                     & L_EARTHRADIUS
a2772 1
    use MLSStrings, only: Capitalize
d2905 1
a2905 1
      use Declaration_table, only: NUM_VALUE, RANGE
d3322 3
@


2.204
log
@More informative dump for Tikhonov
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.203 2002/11/20 01:10:03 livesey Exp $"
d1035 1
a1035 1
      foundBetterState = .false.
d3328 3
@


2.203
log
@Added the foundBetterState stuff
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.202 2002/10/29 20:51:27 livesey Exp $"
d1313 7
d3328 3
@


2.202
log
@Moved call to FillDiagVec
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.201 2002/10/25 23:56:04 livesey Exp $"
d993 1
d1035 1
d1208 1
d1856 1
d1946 2
a1947 2
      if ( got(f_outputCovariance) .or. got(f_outputSD) .or. &
        &  got(f_average) ) then
d2002 1
a2002 1
      if ( got(f_average) ) then
d3321 3
@


2.201
log
@Bug fix in the diagnostics
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.200 2002/10/25 22:24:42 livesey Exp $"
a1913 3
        if ( got(f_diagnostics) ) call FillDiagVec ( diagnostics, aj, &
          & numJ=numJ, nwt_flag=nwt_flag, jacobian_rows=jacobian_rows, &
          & jacobian_cols=jacobian_cols )
d1937 4
d3317 3
@


2.200
log
@Changed the diagnostic vector handling.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.199 2002/10/25 01:13:46 livesey Exp $"
d849 1
a849 1
            diag_qty%mask = char (m_linalg )
d858 1
a858 1
            call ClearMask ( diag_qty%mask(:,1), (/ latest /), m_linalg )
d3316 3
@


2.199
log
@Jacobian rows/cols etc. now actually describe the jacobian.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.198 2002/10/23 23:27:40 livesey Exp $"
d84 3
a86 3
    use VectorsModule, only: AddToVector, AddVectorToDatabase, ClearUnderMask, &
      & ClearVector, CloneVector, CopyVector, CopyVectorMask, DestroyVectorInfo, &
      & DestroyVectorDatabase, DumpMask, GetVectorQuantityByType, &
d827 2
a828 2
    ! ----------------------------------------------  FillDiagVec  -----
    subroutine FillDiagVec ( QuantityIndex, Value )
d833 1
d836 1
d841 59
a899 1
      if ( associated(diag_qty) ) diag_qty%values(1,1) = value
d901 1
a901 1

d1608 1
a1608 1
              aj%chiSqNorm = aj%fnorm / max ( jacobian_rows, 1 )
d1651 2
a1652 2
          do j = 1, normalEquations%m%col%vec%template%noQuantities
            if ( associated(normalEquations%m%col%vec%quantities(j)%mask) ) &
d1654 1
a1654 2
              & countBits(normalEquations%m%col%vec%quantities(j)%mask, &
                & what=m_linAlg)
d1656 3
d1661 2
a1662 1
          if ( got(f_hRegOrders) ) &
d1665 2
a1666 2
          aj%chiSqMinNorm = aj%fnmin / max ( jacobian_rows, 1 )
          aj%chiSqNorm = aj%fnorm / max ( jacobian_rows, 1 )
d1795 3
d1914 3
a1916 21
        if ( got(f_diagnostics) ) then
          call fillDiagVec ( l_dnwt_ajn, aj%ajn )
          call fillDiagVec ( l_dnwt_axmax, aj%axmax )
          call fillDiagVec ( l_dnwt_cait, aj%cait )
          call fillDiagVec ( l_dnwt_chiSqMinNorm, aj%chiSqMinNorm )
          call fillDiagVec ( l_dnwt_chiSqNorm, aj%chiSqNorm )
          call fillDiagVec ( l_dnwt_diag, aj%diag )
          call fillDiagVec ( l_dnwt_dxdx, aj%dxdx )
          call fillDiagVec ( l_dnwt_dxdxl, aj%dxdxl )
          call fillDiagVec ( l_dnwt_dxn, aj%dxn )
          call fillDiagVec ( l_dnwt_dxnl, aj%dxnl )
          call fillDiagVec ( l_dnwt_flag, real(nwt_flag,r8) )
          call fillDiagVec ( l_dnwt_fnmin, aj%fnmin )
          call fillDiagVec ( l_dnwt_fnorm, aj%fnorm )
          call fillDiagVec ( l_dnwt_gdx, aj%gdx )
          call fillDiagVec ( l_dnwt_gfac, aj%gfac )
          call fillDiagVec ( l_dnwt_gradn, aj%gradn )
          call fillDiagVec ( l_dnwt_sq, aj%sq )
          call fillDiagVec ( l_dnwt_sqt, aj%sqt )
          call fillDiagVec ( l_numJ, real(numJ, r8))
        end if
d1951 7
a1958 13
        if ( got(f_diagnostics) ) then
          call fillDiagVec ( l_jacobian_cols, real(jacobian_cols,r8) )
          call fillDiagVec ( l_jacobian_rows, real(jacobian_rows,r8) )
            if ( index(switches,'cov') /= 0 ) then
              call output ( 'Counted ' )
              call output ( jacobian_rows )
              call output ( ' rows and ' )
              call output ( jacobian_cols )
              call output ( ' in the Jacobian matrix at ' )
              call time_now ( t3 )
              call output ( t3-t0, advance='yes' )
            end if
        end if
d1960 2
a1961 2
        call createEmptyMatrix ( temp, 0, state, state )
        call invertCholesky ( factored, temp ) ! U^{-1}
d1968 3
a1970 3
        preserveMatrixName = outputCovariance%m%name
        call multiplyMatrix_XY_T ( temp, temp, outputCovariance%m, &
          & diagonalOnly = .not. any ( got ( (/ f_outputCovariance, f_average/) ) ) ) ! U^{-1} U^{-T}
d1979 1
a1979 1
        call destroyMatrix ( temp )
d1981 4
a1984 4
        ! Scale the covariance
        if ( columnScaling /= l_none ) then
          call columnScale ( outputCovariance%m, v(columnScaleVector) )
          call rowScale ( v(columnScaleVector), outputCovariance%m )
d1990 4
a1994 4
        outputCovariance%m%name = preserveMatrixName
        if ( associated(outputSD) ) &
          & call GetDiagonal ( outputCovariance%m, outputSD, squareRoot=.true. )
      end if
d3316 3
@


2.198
log
@Bug fix in jacobian_rows calculation
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.197 2002/10/23 01:32:31 vsnyder Exp $"
d1589 2
a1590 2
          jacobian_cols = sum(normalEquations%m%col%nelts)
          jacobian_rows = sum(normalEquations%m%row%nelts)
d3274 3
@


2.197
log
@Add CovSansReg switch to retrieve spec
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.196 2002/10/23 01:14:41 livesey Exp $"
d1548 1
a1548 1
              aj%chiSqNorm = aj%fnorm / max ( jacobian_rows - jacobian_cols, 1 )
d1585 19
a1603 2
          aj%chiSqMinNorm = aj%fnmin / max ( jacobian_rows - jacobian_cols, 1 )
          aj%chiSqNorm = aj%fnorm / max ( jacobian_rows - jacobian_cols, 1 )
a1904 16
          ! Compute number of rows of Jacobian actually used.  Don't count
          ! rows due to Levenberg-Marquardt stabilization.  Do count rows
          ! due to a priori or regularization.  Put numbers of rows and
          ! columns into diagnostic vector.
          jacobian_cols = sum(normalEquations%m%col%nelts)
          jacobian_rows = sum(normalEquations%m%row%nelts)
          do j = 1, normalEquations%m%col%nb
            if ( associated(normalEquations%m%col%vec%quantities(j)%mask) ) &
              & jacobian_rows = jacobian_rows - &
              & countBits(normalEquations%m%col%vec%quantities(j)%mask, &
                & what=m_linAlg)
          end do
          if ( got(f_apriori) ) &
            & jacobian_rows = jacobian_rows + jacobian_cols
          if ( got(f_hRegOrders) ) &
            & jacobian_rows = jacobian_rows + tikhonovRows
d3274 3
@


2.196
log
@Added the chiSquared stuff, needs more work though.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.195 2002/10/19 23:41:04 livesey Exp $"
d41 3
a43 2
      & F_channels, F_columnScale, F_Comment, F_covariance, F_diagnostics, &
      & F_diagonal, F_forwardModel, F_fuzz, F_fwdModelExtra, F_fwdModelOut, &
d115 1
d294 1
d329 2
d680 1
a680 1
      ! to a straight element by element modification of $d_i$.      
d750 1
a750 1
      ! Now if mu has got really small, we'll change it back to one,
d1221 3
a1223 1
          if ( (got(f_hRegOrders) .or. got(f_vRegOrders)) .and. tikhonovBefore ) then
d1377 3
a1379 1
          if ( (got(f_hRegOrders) .or. got(f_vRegOrders)) .and. .not. tikhonovBefore ) then
d3273 3
@


2.195
log
@Added muMin functionality
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.194 2002/10/19 18:49:17 livesey Exp $"
d52 2
a53 1
      & L_dnwt_ajn,  L_dnwt_axmax,  L_dnwt_cait, L_dnwt_diag,  L_dnwt_dxdx, &
d1506 1
a1506 1

d1525 1
a1525 1
          call choleskyFactor ( factored, normalEquations )
d1537 8
a1544 8
                & 'Sparseness structure of blocks of factor:', upper=.true. )
          if ( nwt_flag == nf_getJ ) then ! taking a special iteration to get J
            aj%fnorm = sqrt(aj%fnorm)
              if ( index(switches,'sca') /= 0 ) then
                call output ( ' | F | = ' )
                call output ( aj%fnorm, format='(1pe14.7)', advance='yes' )
              end if
            exit
d1547 1
a1547 1
          !       smallest absolute value, after triangularization
d1576 2
d1585 2
d1826 2
d3264 3
@


2.194
log
@Various bug fixes in bounds stuff
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.193 2002/10/19 01:52:21 livesey Exp $"
d45 1
a45 1
      & F_mask, F_maxJ, F_measurements, F_measurementSD, F_method, &
d101 1
d155 1
d298 1
d372 1
a372 1
          case ( f_aprioriScale, f_fuzz, f_lambda, f_maxJ, &
d386 2
d656 1
a656 1
    subroutine BoundMove ( Mu, Bound, X, Dx, Which )
d671 4
d677 1
a677 1
      type(vector_T), intent(in) :: Bound, X, Dx
d679 1
a726 1
            print*,'Doing unmasked high bound'
d743 65
d809 9
a817 4
        call output ( 'mu=' )
        call output ( mu, advance='yes' )
        call MLSMessage ( MLSMSG_Error, moduleName, &
          &  'How did mu get to be negative?' )
d1661 1
a1661 1
            & call boundMove ( mu, lowBound, v(x), v(dxUnScaled), 'low' )
d1663 1
a1663 1
            & call boundMove ( mu, highBound, v(x), v(dxUnScaled), 'high' )
d1709 1
a1709 1
            & call boundMove ( mu, lowBound, v(x), v(dxUnscaled), 'low' )
d1711 1
a1711 1
            & call boundMove ( mu, highBound, v(x), v(dxUnscaled), 'high' )
d3257 3
@


2.193
log
@Added serial option and associated flags.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.192 2002/10/18 22:05:42 vsnyder Exp $"
d522 2
a523 2
          if ( got(f_lowBound) ) call getInBounds ( v(x), lowBound, 'low' )
          if ( got(f_highBound) ) call getInBounds ( v(x), highBound, 'high' )
d676 2
a677 2
            do ivy = 1, size(x%quantities(iq)%values,1)
              do ivx = 1, size(x%quantities(iq)%values,2)
d689 2
a690 2
            do ivy = 1, size(x%quantities(iq)%values,1)
              do ivx = 1, size(x%quantities(iq)%values,2)
d704 2
a705 2
            do ivy = 1, size(x%quantities(iq)%values,1)
              do ivx = 1, size(x%quantities(iq)%values,2)
d717 3
a719 2
            do ivy = 1, size(x%quantities(iq)%values,1)
              do ivx = 1, size(x%quantities(iq)%values,2)
d734 6
a739 2
      if ( mu < 0.0_rv ) call MLSMessage ( MLSMSG_Error, moduleName, &
        &  'How did mu get to be negative?' )
d769 2
a770 2
            do ivy = 1, size(x%quantities(iq)%values,1)
              do ivx = 1, size(x%quantities(iq)%values,2)
d778 2
a779 2
            do ivy = 1, size(x%quantities(iq)%values,1)
              do ivx = 1, size(x%quantities(iq)%values,2)
d790 2
a791 2
            do ivy = 1, size(x%quantities(iq)%values,1)
              do ivx = 1, size(x%quantities(iq)%values,2)
d799 2
a800 2
            do ivy = 1, size(x%quantities(iq)%values,1)
              do ivx = 1, size(x%quantities(iq)%values,2)
d3178 3
@


2.192
log
@Get in bounds before starting.  Account for scaling when bounding a move.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.191 2002/10/17 23:12:51 vsnyder Exp $"
d48 1
a48 1
      & F_regAfter, F_regApriori, F_state, F_toleranceA, F_toleranceF, &
d62 1
d157 1
a231 2
    tikhonovApriori = .false.
    tikhonovBefore = .true.
d301 3
d361 2
a833 1
      use L2ParInfo, only: PARALLEL
d880 1
a880 1
      if ( parallel%master .and. parallel%fwmParallel ) &
d1192 1
a1192 1
          if ( parallel%master .and. parallel%fwmParallel ) then
d1209 1
a1209 1
            if ( parallel%master .and. parallel%fwmParallel ) then
d3173 3
@


2.191
log
@Apply bounds to gradient and Aitken moves
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.190 2002/10/17 00:16:40 vsnyder Exp $"
a22 1
  private :: not_used_here 
d517 2
d670 23
a692 8
          do ivx = 1, size(x%quantities(iq)%values,1)
            do ivy = 1, size(x%quantities(iq)%values,2)
              if ( x%quantities(iq)%values(ivx,ivy) + &
                &  mu * dx%quantities(iq)%values(ivx,ivy) < &
                &  bound%quantities(iq)%values(ivx,ivy) ) &
                  & mu = ( bound%quantities(iq)%values(ivx,ivy) - &
                  &        x%quantities(iq)%values(ivx,ivy) ) &
                  &      / dx%quantities(iq)%values(ivx,ivy)
d694 1
a694 1
          end do
d698 23
a720 8
          do ivx = 1, size(x%quantities(iq)%values,1)
            do ivy = 1, size(x%quantities(iq)%values,2)
              if ( x%quantities(iq)%values(ivx,ivy) + &
                &  mu * dx%quantities(iq)%values(ivx,ivy) > &
                &  bound%quantities(iq)%values(ivx,ivy) ) &
                  & mu = ( x%quantities(iq)%values(ivx,ivy) - &
                  &        bound%quantities(iq)%values(ivx,ivy) ) &
                  &      / dx%quantities(iq)%values(ivx,ivy)
d722 1
a722 1
          end do
d726 1
a726 1
          & 'Come on! It has to be a low bound or a high bound!' )
d746 58
a803 1
    !
d1557 1
a1557 1
              & 'Norm of residual is imaginary!' )
d1566 5
d1573 1
a1573 1
            & call boundMove ( mu, lowBound, v(x), v(candidateDx), 'low' )
d1575 1
a1575 1
            & call boundMove ( mu, highBound, v(x), v(candidateDx), 'high' )
d3162 1
a3162 1
  logical function not_used_here()
d3164 1
a3164 1
  end function not_used_here
d3169 3
@


2.190
log
@Add lowBound and highBound fields for the Retrieve spec
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.189 2002/10/08 17:41:38 livesey Exp $"
d644 57
a751 1
      integer :: IQ, IVX, IVY           ! Subscripts used during MU computation
d1475 3
a1477 1
          ! Shorten candidateDX if necessary to stay within the bounds
d1479 5
a1483 34
          if ( got(f_lowBound) ) then
            do iq = 1, size(v(x)%quantities)
              do ivx = 1, size(v(x)%quantities(iq)%values,1)
                do ivy = 1, size(v(x)%quantities(iq)%values,2)
                  if ( v(x)%quantities(iq)%values(ivx,ivy) + &
                    &  mu * v(candidateDX)%quantities(iq)%values(ivx,ivy) < &
                    &  lowBound%quantities(iq)%values(ivx,ivy) ) &
                      & mu = ( lowBound%quantities(iq)%values(ivx,ivy) - &
                      &        v(x)%quantities(iq)%values(ivx,ivy) ) &
                      &      / v(candidateDX)%quantities(iq)%values(ivx,ivy)
                end do
              end do
            end do
          end if
          if ( got(f_highBound) ) then
            do iq = 1, size(v(x)%quantities)
              do ivx = 1, size(v(x)%quantities(iq)%values,1)
                do ivy = 1, size(v(x)%quantities(iq)%values,2)
                  if ( v(x)%quantities(iq)%values(ivx,ivy) + &
                    &  mu * v(candidateDX)%quantities(iq)%values(ivx,ivy) > &
                    &  highBound%quantities(iq)%values(ivx,ivy) ) &
                      & mu = ( v(x)%quantities(iq)%values(ivx,ivy) - &
                      &        highBound%quantities(iq)%values(ivx,ivy) ) &
                      &      / v(candidateDX)%quantities(iq)%values(ivx,ivy)
                end do
              end do
            end do
          end if
          if ( mu <= 1.0_rv ) then
            do iq = 1, size(v(candidateDX)%quantities)
              v(candidateDX)%quantities(iq)%values = &
                & mu * v(candidateDX)%quantities(iq)%values
            end do
          end if
a1516 1
          if ( .not. aj%starting ) aj%dxdxl = v(dx) .dot. v(candidateDX)
d1520 1
a1520 1
          call copyVector ( v(dxUnScaled), v(dx) )
d1525 7
d1565 1
d1597 1
d1708 1
a1708 1
          call fillDiagVec ( l_jacobian_cols, real(jacobian_rows,r8) )
d3076 3
@


2.189
log
@Bug fixes in FWMParallel stuff
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.188 2002/10/08 17:36:22 pwagner Exp $"
d44 4
a47 4
      & F_height, f_hRegOrders, f_hRegQuants, f_hRegWeights, f_hRegWeightVec, &
      & F_ignore, F_jacobian, F_lambda, F_Level, F_mask, &
      & F_maxJ, F_measurements, F_measurementSD, F_method, F_opticalDepth, &
      & F_opticalDepthCutoff, F_outputCovariance, F_outputSD, &
d67 1
a67 1
    use MLSCommon, only: R8, MLSCHUNK_T, RM
d127 4
a130 3
    integer :: HRegOrders                ! Regularization orders
    integer :: HRegQuants                ! Regularization quantities
    integer :: HRegWeights               ! Weight of regularization conditions
d143 1
d334 2
d346 2
d424 8
d695 2
d704 1
a706 1
      integer :: J, K                   ! Loop inductors and subscripts
d1419 36
d3039 3
@


2.188
log
@Added idents to survive zealous Lahey optimizer
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.187 2002/10/06 02:04:57 livesey Exp $"
d718 1
a718 1
        & state, fwdModelExtra, FwdModelOut )
d1029 2
d1049 1
a1049 1
              if ( fmStat%maf < chunk%lastMAFIndex-chunk%firstMAFIndex ) &
d2987 3
@


2.187
log
@Put in fwmParallel functionality
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.186 2002/09/25 20:08:43 livesey Exp $"
d23 1
d2978 4
d2985 3
@


2.186
log
@Made subset -g less verbose
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.185 2002/09/23 23:15:08 vsnyder Exp $"
d669 3
d714 4
d1026 9
d1042 12
a1053 4
            do k = 1, size(configIndices)
              call forwardModel ( configDatabase(configIndices(k)), &
                & v(x), fwdModelExtra, v(f_rowScaled), fmw, fmStat, jacobian )
            end do ! k
d1055 2
a1056 1
              call time_now ( t1 )
d2980 3
@


2.185
log
@Delete maxF
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.184 2002/09/23 20:21:21 livesey Exp $"
d75 1
a75 1
    use Toggles, only: Gen, Switches, Toggle
d278 2
a279 1
        if ( toggle(gen) ) call trace_begin ( "Retrieve.subset", root )
d281 2
a282 1
        if ( toggle(gen) ) call trace_end ( "Retrieve.subset" )
d2955 3
@


2.184
log
@Now copies mask from f_rowScaled to f.  Only important for snooping.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.183 2002/09/21 00:33:34 vsnyder Exp $"
d44 1
a44 1
      & F_ignore, F_jacobian, F_lambda, F_Level, F_mask, F_maxF, &
d57 1
a57 1
      & L_linalg, L_lowcloud, L_newtonian, L_none, L_norm, L_numF, &
d98 1
a98 1
    integer, parameter :: DefaultMaxF = 30, DefaultMaxJ = 5
a140 2
    integer :: MaxFunctions             ! Maximum number of function
                                        ! evaluations of Newtonian method
a289 1
        maxFunctions = defaultMaxF
d356 1
a356 1
          case ( f_aprioriScale, f_fuzz, f_lambda, f_maxF, f_maxJ, &
a367 2
            case ( f_maxF )
              maxFunctions = value(1)
d562 1
a562 1
      call output ( ' RetrievalModule complained: ' )
d686 1
a686 1
      integer :: NumF, NumJ             ! Number of Function, Jacobian evaluations
a757 1
      numF = 0
a793 2
            call output ( ', numF = ' )
            call output ( numF )
d894 1
a894 1
            if ( got(f_regApriori) ) &
d977 1
a977 1
              if ( got(f_regApriori) ) then ! reg_*_x := R * (apriori - x)
d1121 1
a1121 1
              if ( got(f_regApriori) ) then
a1533 1
          call fillDiagVec ( l_numF, real(numF, r8))
d2953 3
@


2.183
log
@Don't take a getJ iteration if TOLF convergence occurs
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.182 2002/09/21 00:04:14 vsnyder Exp $"
d1043 1
a1043 1
                  & inst=jacobian%row%inst(rowBlock), noMask=.true. )
d2962 3
@


2.182
log
@Put back an erroneously-removed timing call
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.181 2002/09/19 01:26:46 vsnyder Exp $"
d1511 3
a1513 5
            if ( got(f_outputCovariance) .or. got(f_outputSD) .or. &
              &  got(f_average) ) then
              nwt_flag = nf_getJ
              cycle
            end if
d2962 3
@


2.181
log
@Mostly fixing up comments and LaTeX stuff
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.180 2002/09/18 23:56:01 vsnyder Exp $"
d1036 2
a1037 1
              call add_to_retrieval_timing( 'forward_model', t1 )
d2964 3
@


2.180
log
@Call time_now at end of add_to_retrieval_timing
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.179 2002/09/14 02:46:30 vsnyder Exp $"
d898 1
a900 1
!           v(aprioriMinusX) = apriori - v(x)
d936 5
a940 5
            !  x}_n \simeq {\bf F a}$ where ${\bf F}$ is the Cholesky factor
            !  of $\bf C$, the inverse of the apriori covariance ${\bf S}_a$. 
            !  So that all of the parts of the problem are solving for
            !  ${\bf\delta x}$, we subtract ${\bf F x}_{n-1}$ from both sides,
            !  to get ${\bf F \delta x} \simeq {\bf F (a - x}_{n-1})$.
d943 1
a943 1
            ! so we form ${\bf C \delta x} = {\bf C (a - x}_{n-1})$
d968 6
a973 6
            !{ Tikhonov regularization is of the form ${\bf R x}_n \simeq {\bf
            !  0}$ or ${\bf R x}_n \simeq {\bf a}$, where {\bf a} is the
            !  apriori. So that all of the parts of the problem are solving for
            !  ${\bf\delta x}$, we subtract ${\bf R x}_{n-1}$ from both sides
            !  to get ${\bf R \delta x} \simeq -{\bf R x}_{n-1}$ or ${\bf
            !  R \delta x} \simeq {\bf R} ( {\bf a - x}_{n-1})$.
d975 1
a975 1
            do t = 1, 2 ! Vertical, Horizontal regularization
d1018 1
a1018 1
          if ( got(f_average) ) then ! Need a separate matrix for J^T J
d1051 1
a1051 1
                ! becomes $\mathbf{W J \delta \hat x \simeq W f}$ (actually,
d1068 2
a1069 2
            ! {\bf J}^T {\bf W}^T {\bf W f} =
            ! {\bf J}^T {\bf S}_m^{-1} {\bf f}$:
d1101 4
a1104 4
            !{ Tikhonov regularization is of the form ${\bf R x}_n \simeq {\bf
            !  0}$. So that all of the parts of the problem are solving for
            !  ${\bf\delta x}$, we subtract ${\bf R x}_{n-1}$ from both sides to
            !  get ${\bf R \delta x} \simeq -{\bf R x}_{n-1}$.
d1106 1
a1106 1
            do t = 1, 2
d1314 1
a1314 1
        ! $\lambda =$ {\bf AJ\%SQ}.  I.e. form $({\bf \Sigma}^T {\bf J}^T
d1359 1
a1359 1
            & transpose=.true. )
d1378 1
d1431 3
a1433 2
            aj%big = aj%big .or. any( abs(v(dx)%quantities(j)%values) > &
              & 10.0 * epsilon(aj%axmax) * abs(v(x)%quantities(j)%values) )
d1559 3
a1561 1
        if ( index(switches,'ndb') /= 0 ) then
d2963 3
@


2.179
log
@Add NDB switch to get DNWT output every return
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.178 2002/09/14 00:37:37 vsnyder Exp $"
a511 1
              call time_now ( t1 )
a514 1
              call time_now ( t1 )
d766 1
a766 1
      call time_now ( t0 ) ! time base for Newtonian iteration
d782 2
a783 1
        end if;
a784 2
        call add_to_retrieval_timing( 'newton_solver', t1 )
        call time_now ( t1 )
d790 4
a873 4
          if ( nwt_flag == nf_evalj .and. prev_nwt_flag == nf_evalf ) then
            prev_nwt_flag = nf_evalj
            cycle
          end if
d899 3
a901 3
              & vectorNameText='_aprioriMinusX' )
            v(aprioriMinusX) = apriori - v(x)
            call subtractFromVector ( v(aprioriMinusX), v(x) )
a966 1
              call time_now ( t1 )
d975 1
a975 1
            do t = 1, 2
d985 1
a985 1
              if ( got(f_regApriori) ) then
d987 1
a987 1
              else
a1004 1
                call time_now ( t1 )
a1027 1
              call time_now ( t1 )
d1036 1
a1036 3
            ! ForwardModel itself calls add_to_retrieval_timing
            ! call add_to_retrieval_timing( 'forward_model', t1 )
            call time_now ( t1 )
d1040 1
a1040 1
                call copyVector ( v(f), v(f_rowScaled), &
a1070 1
              call time_now ( t1 )
a1074 1
              call time_now ( t1 )
a1099 1
              call time_now ( t1 )
a1161 1
                call time_now ( t1 )
a1252 1
            call time_now ( t1 )
a1254 1
            call time_now ( t1 )
a1278 1
            call time_now ( t1 )
a1281 1
            call time_now ( t1 )
a1338 1
            call time_now ( t1 )
a1340 1
            call time_now ( t1 )
a1357 1
            call time_now ( t1 )
a1360 1
            call time_now ( t1 )
d1606 1
a1606 1
        call time_now ( t1 )
a1627 1
          call time_now ( t1 )
a1665 1
        call time_now ( t1 )
d2959 3
@


2.178
log
@More stuff on subsuming EVALF into EVALJ properly
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.177 2002/09/13 23:55:01 livesey Exp $"
d1573 1
d2981 3
@


2.177
log
@Changed print statements
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.176 2002/09/13 20:05:06 vsnyder Exp $"
d67 1
a67 1
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES, add_to_retrieval_timing
d511 2
a512 2
            call add_to_retrieval_timing( 'low_cloud', t1 )
            call time_now ( t1 )
d515 2
a516 2
            call add_to_retrieval_timing( 'high_cloud', t1 )
            call time_now ( t1 )
d786 2
a787 2
      call add_to_retrieval_timing( 'newton_solver', t1 )
      call time_now ( t1 )
d969 2
a970 2
            call add_to_retrieval_timing( 'newton_solver', t1 )
            call time_now ( t1 )
d1008 2
a1009 2
              call add_to_retrieval_timing( 'tikh_reg', t1 )
              call time_now ( t1 )
d1032 2
a1033 2
            call add_to_retrieval_timing( 'newton_solver', t1 )
            call time_now ( t1 )
d1078 2
a1079 2
            call add_to_retrieval_timing( 'newton_solver', t1 )
            call time_now ( t1 )
d1083 2
a1084 2
            call add_to_retrieval_timing( 'form_normeq', t1 )
            call time_now ( t1 )
d1172 2
a1173 2
              call add_to_retrieval_timing( 'tikh_reg', t1 )
              call time_now ( t1 )
d1179 20
d1264 2
a1265 2
          call add_to_retrieval_timing ( 'newton_solver', t1 )
          call time_now ( t1 )
d1267 2
a1268 2
          call add_to_retrieval_timing ( 'cholesky_factor', t1 )
          call time_now ( t1 )
d1280 8
a1287 1
          if ( nwt_flag == nf_getJ ) exit ! taking a special iteration to get J
d1292 2
a1293 2
          call add_to_retrieval_timing ( 'newton_solver', t1 )
          call time_now ( t1 )
d1296 2
a1297 2
          call add_to_retrieval_timing ( 'cholesky_solver', t1 )
          call time_now ( t1 )
d1354 2
a1355 2
          call add_to_retrieval_timing( 'newton_solver', t1 )
          call time_now ( t1 )
d1357 2
a1358 2
          call add_to_retrieval_timing( 'cholesky_factor', t1 )
          call time_now ( t1 )
d1375 2
a1376 2
          call add_to_retrieval_timing( 'newton_solver', t1 )
          call time_now ( t1 )
d1379 2
a1380 2
          call add_to_retrieval_timing( 'cholesky_solver', t1 )
          call time_now ( t1 )
d1646 2
a1647 2
        call add_to_retrieval_timing( 'cholesky_invert', t1 )
        call time_now ( t1 )
d1685 2
a1686 2
      call add_to_retrieval_timing( 'newton_solver', t1 )
      call time_now ( t1 )
d2980 3
@


2.176
log
@Subsume EVALF into EVALJ
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.175 2002/09/13 18:10:10 pwagner Exp $"
a1259 4
            if ( nwt_flag == nf_getJ .and. index(switches,'sca') /= 0 ) then
              call output ( ' | F | = ' )
              call output ( sqrt ( aj%fnorm ), format='(1pe14.7)', advance='yes' )
            end if
d1297 2
a1298 2
              call dump ( (/ aj%ajn, aj%diag, aj%fnmin, aj%gradn /), &
                & ' L1| FAC |       aj%diag      aj%fnmin         | G |', &
d2953 3
@


2.175
log
@May change matrix precision rm from r8
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.174 2002/09/11 20:21:49 livesey Exp $"
a676 1
      real(r8) :: AprioriNorm           ! apriori .dot. apriori
d699 1
d789 1
d808 4
a811 123
        case ( nf_evalf ) ! ..............................  EVALF  .....
        !{IF ( too many function values ) EXIT\\
        ! Compute $\mathbf{f(x)}$\\
        ! Compute the Jacobian matrix $J$ if you feel like it\\
        ! Set  {\bf AJ\%FNORM} = L2 norm of $\mathbf{f(x)}$\\
        ! IF ( AJ%FNORM is small enough ) EXIT
          numF = numF + 1
          if ( numF > maxFunctions ) then
              if ( index(switches,'nwt') /= 0 ) then
                call output ( &
                  & 'Newton iteration terminated because function evaluations (' )
                call output ( numF )
                call output ( ') > maxFunctions (' )
                call output ( maxFunctions )
                call output ( ')', advance='yes' )
              end if
            ! Restore BestX, run the forward model again to get a new
            ! Jacobian, and form normal equations -- the last two so that the
            ! a posteriori covariance is consistent with BestX.
            call copyVector ( v(x), v(bestX) ) ! x := bestX
            if ( got(f_outputCovariance) .or. got(f_outputSD) .or. &
              &  got(f_average) ) then
              nwt_flag = nf_getJ
              cycle
            end if
            exit
          end if

          if ( got(f_apriori) ) then
            ! Destroy (i.e. clean up) the previous contents of
            ! AprioriMinusX (if any), so as not to have a memory
            ! leak.  Then make it look like apriori.
            call copyVector ( v(aprioriMinusX), apriori, clone=.true., &
              & vectorNameText='_aprioriMinusX' )
!           v(aprioriMinusX) = apriori - v(x)
            call subtractFromVector ( v(aprioriMinusX), v(x) )
            if ( got(f_regApriori) ) &
              & call copyVector ( v(reg_RHS), v(aprioriMinusX), clone=.true., &
              & vectorNameText='_regRHS' )
            if ( got(f_aprioriScale) ) &
              & call scaleVector ( v(aprioriMinusX), aprioriScale )
            !{Let the covariance of the apriori be $\mathbf{S_a}$, let
            ! $\mathbf{C = S_a^{-1}}$, and let $\mathbf{F^T F = C}$. In
            ! the least-squares problem we have extra rows of the form
            ! $\mathbf{F \delta x = F ( a - x_n )}$ where $\mathbf{a}$
            ! is the apriori state, and $\mathbf{x_n}$ is the state as
            ! of the previous iteration.  The initial bit of the
            ! right-hand side of the normal equations is $\mathbf{F^T F
            ! ( a - x_n ) = C ( a - x_n )}$.
            call cloneVector ( v(covarianceXApriori), apriori, &
              & vectorNameText='_covarianceXApriori' )
            if ( diagonal ) then
              call cloneVector ( v(covarianceDiag), state, &
               &  vectorNameText='_covarianceDiag' )
              call getDiagonal ( covariance%m, v(covarianceDiag) )
              ! covarianceXApriori := covarianceDiag # apriori:
              call multiply ( v(covarianceDiag), v(aprioriMinusX), &
                & v(covarianceXApriori) )
            else ! covarianceXApriori := covariance X apriori:
              call multiply ( covariance, v(aprioriMinusX), &
                & v(covarianceXApriori) )
            end if
            !{The contribution to the norm of the residual of the
            ! right-hand side of the part of the least-squares problem
            ! that is due to apriori is $\mathbf{
            ! ( a - x_n )^T F^T F ( a - x_n ) = ( a - x_n )^T \left [ 
            ! C ( a - x_n ) \right ] }$
            aprioriNorm = v(aprioriMinusX) .mdot. v(covarianceXapriori)
          else
            aprioriNorm = 0.0_r8
          end if

          ! Compute f(x)
 
          fmStat%newScanHydros = .true.
          fmStat%maf = 0

          call add_to_retrieval_timing( 'newton_solver', t1 )
          call time_now ( t1 )
          call clearVector ( v(f) )
          call copyVectorMask ( v(f), measurements )
          ! Loop over MAFs
          do while (fmStat%maf < chunk%lastMAFIndex-chunk%firstMAFIndex+1)
            fmStat%maf = fmStat%maf + 1
            do k = 1, size(configIndices)
              call forwardModel ( configDatabase(configIndices(k)), &
                & v(x), fwdModelExtra, v(f), fmw, fmStat )
            end do ! k
          end do ! MAFs
          ! ForwardModel itself calls add_to_retrieval_timing
          ! call add_to_retrieval_timing( 'forward_model', t1 )
          call time_now ( t1 )
          call copyVector ( v(f_rowScaled), v(f) ) ! f_rowScaled := f
          call subtractFromVector ( v(f_rowScaled), measurements )
          if ( got(f_measurementSD) ) call multiply ( v(f_rowScaled), v(weight) )
          aj%fnorm = sqrt ( aprioriNorm + ( v(f_rowScaled) .mdot. v(f_rowScaled) ) )
            if ( index(switches,'fvec') /= 0 ) &
              & call dump ( v(f_rowScaled), name='RowScaledResidual' )
            if ( index(switches,'sca') /= 0 ) then
                call output ( ' | F | = ' )
                call output ( aj%fnorm, format='(1pe14.7)', advance='yes' )
            end if
          if ( aj%fnorm < toleranceF ) then
              if ( index(switches,'nwt') /= 0 ) then
                call output ( &
                  & 'Newton iteration terminated because aj%fnorm (' )
                call output ( aj%fnorm )
                call output ( ') < ToleranceF (' )
                call output ( toleranceF )
                call output ( ')', advance='yes' )
              end if
            ! Restore BestX, run the forward model again to get a new
            ! Jacobian, and form normal equations -- the last two so that the
            ! a posteriori covariance is consistent with BestX.
            call copyVector ( v(x), v(bestX) ) ! x := bestX
            if ( got(f_outputCovariance) .or. got(f_outputSD) .or. &
              &  got(f_average) ) then
              nwt_flag = nf_getJ
              cycle
            end if
            exit
          end if
        case ( nf_evalj, nf_getJ ) ! ...............  EVALJ, GETJ  .....
d873 4
d895 1
d898 40
d962 1
a965 3
          ! aprioriNorm was computed when nwt_flag was NF_EVALF.  It is the
          ! _square_ of the norm of (apriori - measurements).
          aj%fnorm = aprioriNorm
d1359 16
a1374 13
!         aj%fnmin = aj%fnorm**2 - (v(candidateDX) .dot. v(candidateDX))
!         if ( aj%fnmin < 0.0 ) then
!           call output ( 'How can aj%fnmin be negative?  aj%fnmin = ' )
!           call output ( aj%fnmin, advance='yes' )
!           call output ( 'aj%fnorm**2 = ' )
!           call output ( aj%fnorm**2, advance='yes' )
!           call output ( 'norm(candidateDX) = ' )
!           call output ( v(candidateDX) .dot. v(candidateDX), advance='yes' )
!           call MLSMessage ( MLSMSG_Warning, ModuleName, &
!             & 'Norm of residual is imaginary!' )
!           aj%fnmin = tiny ( aj%fnmin )
!         end if
!         aj%fnmin = sqrt(aj%fnmin)
d1550 1
d2957 3
@


2.174
log
@Made second | F | print on GETJ not EVALJ
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.173 2002/09/11 17:40:59 livesey Exp $"
d66 1
a66 1
    use MLSCommon, only: R8, MLSCHUNK_T
d1791 1
a1791 1
      real(r8), dimension(:,:), allocatable :: A      ! working array
d1844 1
a1844 1
          A = 0._r8
d2095 1
a2095 1
      real(r8), dimension(:,:), allocatable :: A      ! working array
d2193 1
a2193 1
          A = 0._r8
d3028 3
@


2.173
log
@Changed meaning of v(f)
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.172 2002/09/11 14:06:42 livesey Exp $"
d1335 1
a1335 1
            if ( index(switches,'sca') /= 0 ) then
d3028 3
@


2.172
log
@Bug fix, misunderstood meaning of v(f)
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.171 2002/09/11 01:14:47 livesey Exp $"
a529 1
          call addToVector ( fwdModelOut, measurements )
a898 1
          call subtractFromVector ( v(f), measurements )
d900 1
d1123 3
a1128 3
                call copyVector ( v(f), v(f_rowScaled), &
                  & quant=jacobian%row%quant(rowBlock), &
                  & inst=jacobian%row%inst(rowBlock), noMask=.true. )
d3028 3
@


2.171
log
@Added extra dump of | F |
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.170 2002/09/06 00:46:18 livesey Exp $"
d1123 1
d1127 3
d3029 3
@


2.170
log
@Added dump of aTb
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.169 2002/09/05 23:08:22 livesey Exp $"
d1332 4
d3025 3
@


2.169
log
@Gradient move handles mask 'correctly', though we might have been right
from a philosophical point of view earlier.
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.168 2002/08/29 04:45:37 livesey Exp $"
d1154 1
d3021 4
@


2.168
log
@Sped up covariance calculations
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.167 2002/08/28 00:51:04 vsnyder Exp $"
d81 2
a82 2
    use VectorsModule, only: AddToVector, AddVectorToDatabase, ClearVector, &
      & CloneVector, CopyVector, CopyVectorMask, DestroyVectorInfo, &
d1291 4
d3020 3
@


2.167
log
@Correct more blunders in Tikhonov regularization
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.166 2002/08/26 20:01:59 livesey Exp $"
d1671 2
a1672 1
        call multiplyMatrix_XY_T ( temp, temp, outputCovariance%m ) ! U^{-1} U^{-T}
d1674 4
a1677 1
            call output ( 'Computed U^{-1} U^{-T} at ' )
d3016 3
@


2.166
log
@Made subset us the GetIndexFlagsFromList routine to get channel flags
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.165 2002/08/24 01:38:28 vsnyder Exp $"
d1059 1
a1059 1
                  & vRegWeightVec, tikhonovRows )
d1063 1
a1063 1
                  & hRegWeightVec, tikhonovRows )
d1192 1
a1192 1
                  & vRegWeightVec, tikhonovRows )
d1196 1
a1196 1
                  & hRegWeightVec, tikhonovRows )
d3012 3
@


2.165
log
@Implement horizontal regularization
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.164 2002/08/22 00:06:50 vsnyder Exp $"
d69 1
a69 1
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
d2631 1
d2725 3
a2727 21
          channels = .false.
          do j = 2, nsons(channelsNode)
            son = subtree ( j, channelsNode )
            call expr ( son, units, value, type )
            do i = 1, merge(1,2,type==num_value)
              if ( units(i) /= phyq_dimensionless ) &
                & call announceError ( wrongUnits, f_channels, string='no' )
            end do
            range_low = nint(value(1))
            range_hi = nint(value(merge(1,2,type==num_value)))
            select case ( node_id(son) )
            case ( n_colon_less )
              range_hi = range_hi - 1
            case ( n_less_colon )
              range_low = range_low + 1
            case ( n_less_colon_less )
              range_low = range_low + 1
              range_hi = range_hi - 1
            end select
            channels ( range_low : range_hi ) = .true.
          end do
d3012 3
@


2.164
log
@Implement regularize-to-apriori
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.163 2002/08/21 19:55:31 vsnyder Exp $"
d43 2
a44 1
      & F_height, F_ignore, F_jacobian, F_lambda, F_Level, F_mask, F_maxF, &
d46 5
a50 5
      & F_opticalDepthCutoff, &
      & F_outputCovariance, F_outputSD, F_phaseName, F_ptanQuantity, &
      & F_quantity, F_regAfter, F_regApriori, F_regOrders, F_regQuants, &
      & F_regWeights, F_regWeightVec, F_state, F_toleranceA, F_toleranceF, &
      & F_toleranceR, Field_first, Field_last, &
d126 4
a156 4
    integer :: RegOrders                ! Regularization orders
    integer :: RegQuants                ! Regularization quantities
    integer :: RegWeights               ! Weight of regularization conditions
    type(vector_T), pointer :: RegWeightVec  ! Weight vector for regularization
d179 4
d288 3
a294 3
        regQuants = 0
        regWeights = 0
        nullify ( regWeightVec )
d298 3
d332 8
a352 8
          case ( f_regOrders )
            regOrders = son
          case ( f_regQuants )
            regQuants = son
          case ( f_regWeights )
            regWeights = son
          case ( f_regWeightVec )
            RegWeightVec => vectorDatabase(decoration(decoration(subtree(2,son))))
d382 8
d399 4
a402 4
        if ( got(f_regOrders) .neqv. &
          & (got(f_regWeights) .or. got(f_regWeightVec)) ) then
          call announceError ( bothOrNeither, f_regOrders, f_regWeights )
          call announceError ( bothOrNeither, f_regOrders, f_regWeightVec )
d404 9
a412 2
        if ( got(f_regQuants) .and. .not. got(f_regOrders) ) &
          & call announceError ( ifAThenB, f_regQuants, f_regOrders )
d497 1
a497 1
          if ( got(f_regOrders) ) then
d708 1
d1044 1
a1044 1
          if ( got(f_regOrders) .and. tikhonovBefore ) then
d1055 15
a1069 11
            call regularize ( tikhonov, regOrders, regQuants, regWeights, &
              & RegWeightVec, tikhonovRows )
            if ( got(f_regApriori) ) then
              call multiplyMatrixVectorNoT ( tikhonov, v(reg_RHS), v(reg_X_x) )
            else
              call multiplyMatrixVectorNoT ( tikhonov, v(x), v(reg_X_x) )
              call scaleVector ( v(reg_X_x), -1.0_r8 )   ! -R x_n
            end if
              if ( index(switches,'reg') /= 0 ) then
                call dump_struct ( tikhonov, 'Tikhonov' )
                call dump ( tikhonov, name='Tikhonov', details=2 )
d1071 16
a1086 11
            call formNormalEquations ( tikhonov, normalEquations, &
              & v(reg_X_x), v(aTb), update=update, useMask=.false. )
            update = .true.
            call clearMatrix ( tikhonov )           ! free the space
            ! aj%fnorm is still the square of the norm of f
            aj%fnorm = aj%fnorm + ( v(reg_X_x) .dot. v(reg_X_x) )
            ! call destroyVectorValue ( v(reg_X_x) )  ! free the space
            ! Don't destroy reg_X_x unless we move the 'clone' for it
            ! inside the loop.  Also, if we destroy it, we can't snoop it.
            call add_to_retrieval_timing( 'tikh_reg', t1 )
            call time_now ( t1 )
d1179 3
a1181 3
          if ( got(f_regOrders) .and. .not. tikhonovBefore ) then
            call add_to_retrieval_timing( 'newton_solver', t1 )
            call time_now ( t1 )
a1182 10
            ! Get the column scale vector.
            select case ( columnScaling )
            case ( l_apriori ) ! v(columnScaleVector) := apriori
              call copyVector ( v(columnScaleVector), apriori )
            case ( l_covariance )
              !??? Can't get here until allowed by init_tables
            case ( l_norm ) ! v(columnScaleVector) := diagonal of normal
                            !                         equations = column norms^2
              call getDiagonal ( normalEquations%m, v(columnScaleVector) )
            end select
d1188 28
a1215 6
            call regularize ( tikhonov, regOrders, regQuants, regWeights, &
              & regWeightVec, tikhonovRows )
            if ( got(f_regApriori) ) then
              call multiplyMatrixVectorNoT ( tikhonov, v(reg_RHS), v(reg_X_x) )
            else
              call multiplyMatrixVectorNoT ( tikhonov, v(x), v(reg_X_x) )
a1216 2
            end if
            call scaleVector ( v(reg_X_x), -1.0_r8 )   ! -R x_n
d1218 10
a1227 15
            if ( columnScaling /= l_none ) then ! Compute $\Sigma$
              forall (j = 1: v(columnScaleVector)%template%noQuantities)
                where ( v(columnScaleVector)%quantities(j)%values <= 0.0 )
                  v(columnScaleVector)%quantities(j)%values = 0.0
                elsewhere
                  v(columnScaleVector)%quantities(j)%values = &
                    & sqrt( v(columnScaleVector)%quantities(j)%values )
                end where
              end forall
              call columnScale ( tikhonov, v(columnScaleVector) )
            end if

              if ( index(switches,'reg') /= 0 ) then
                call dump_struct ( tikhonov, 'Tikhonov' )
                call dump ( tikhonov, name='Tikhonov', details=2 )
d1229 17
a1245 11
            call formNormalEquations ( tikhonov, normalEquations, &
              & v(reg_X_x), v(aTb), update=update, useMask=.false. )
            update = .true.
            call clearMatrix ( tikhonov )           ! free the space
            ! aj%fnorm is still the square of the norm of f
            aj%fnorm = aj%fnorm + ( v(reg_X_x) .dot. v(reg_X_x) )
            ! call destroyVectorValue ( v(reg_X_x) )  ! free the space
            ! Don't destroy reg_X_x unless we move the 'clone' for it
            ! inside the loop.  Also, if we destroy it, we can't snoop it.
            call add_to_retrieval_timing( 'tikh_reg', t1 )
            call time_now ( t1 )
d1647 1
a1647 1
          if ( got(f_regOrders) ) &
d3029 3
d3039 1
a3039 1
! Add regWeightVec and Tikhonov mask
d3105 1
a3105 1
! Change regWeight to regWeights -- which is now a tree node instead of
@


2.163
log
@Move USE statements from module scope to procedure scope
@
text
@d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.162 2002/08/20 19:55:02 vsnyder Exp $"
d47 3
a49 3
      & F_quantity, F_regAfter, F_regOrders, F_regQuants, F_regWeights, &
      & F_regWeightVec, F_state, F_toleranceA, F_toleranceF, F_toleranceR, &
      & Field_first, Field_last, &
d72 1
a72 1
    use String_Table, only: DISPLAY_STRING, Get_String
d164 2
d195 2
a196 1
    integer, parameter :: Weight = reg_X_x + 1     ! Scaling vector for rows, 1/measurementSD
d225 1
d335 2
d381 2
d475 1
a475 1
            call createEmptyMatrix ( tikhonov, 0, state, state )
d677 1
a677 1
      integer :: PreserveMatrixName    ! Temporary name store
d820 3
d1025 5
a1029 3
            !  0}$. So that all of the parts of the problem are solving for
            !  ${\bf\delta x}$, we subtract ${\bf R x}_{n-1}$ from both sides to
            !  get ${\bf R \delta x} \simeq -{\bf R x}_{n-1}$.
d1033 6
a1038 2
            call multiplyMatrixVectorNoT ( tikhonov, v(x), v(reg_X_x) ) ! regularization * x_n
            call scaleVector ( v(reg_X_x), -1.0_r8 )   ! -R x_n
d1167 6
a1172 1
            call multiplyMatrixVectorNoT ( tikhonov, v(x), v(reg_X_x) ) ! regularization * x_n
d2985 3
@


2.162
log
@Use matrix with same row and column templates for Tikhonov
@
text
@a12 48
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Dump_0, only: Dump
  use Expr_M, only: Expr
  use Init_Tables_Module, only: F_apriori, F_aprioriScale, F_Average, &
    & F_channels, F_columnScale, F_Comment, F_covariance, F_diagnostics, &
    & F_diagonal, F_forwardModel, F_fuzz, F_fwdModelExtra, F_fwdModelOut, &
    & F_height, F_ignore, F_jacobian, F_lambda, F_Level, F_mask, F_maxF, &
    & F_maxJ, F_measurements, F_measurementSD, F_method, F_opticalDepth, &
    & F_opticalDepthCutoff, &
    & F_outputCovariance, F_outputSD, F_phaseName, F_ptanQuantity, &
    & F_quantity, F_regAfter, F_regOrders, F_regQuants, F_regWeights, &
    & F_regWeightVec, F_state, F_toleranceA, F_toleranceF, F_toleranceR, &
    & Field_first, Field_last, &
    & L_apriori, L_covariance, &
    & L_dnwt_ajn,  L_dnwt_axmax,  L_dnwt_cait, L_dnwt_diag,  L_dnwt_dxdx, &
    & L_dnwt_dxdxl, L_dnwt_dxn,  L_dnwt_dxnl,  L_dnwt_flag, L_dnwt_fnmin, &
    & L_dnwt_fnorm,  L_dnwt_gdx,  L_dnwt_gfac, L_dnwt_gradn,  L_dnwt_sq, &
    & L_dnwt_sq,  L_dnwt_sqt, L_Fill, L_full_derivatives, &
    & L_highcloud, L_Jacobian_Cols, L_Jacobian_Rows, &
    & L_linalg, L_lowcloud, L_newtonian, L_none, L_norm, L_numF, &
    & L_numJ, L_opticalDepth, L_pressure, L_radiance, L_Tikhonov, L_zeta, &
    & S_dumpBlocks, S_forwardModel, S_matrix, S_retrieve, S_sids, S_snoop, &
    & S_subset, S_time
  use Intrinsic, only: PHYQ_Dimensionless
  use MatrixModule_1, only: AddToMatrixDatabase, CreateEmptyMatrix, &
    & DestroyMatrix, GetFromMatrixDatabase, Matrix_T, Matrix_Database_T, &
    & Matrix_SPD_T, MultiplyMatrixVectorNoT, operator(.TX.), ReflectMatrix, Dump
  use MatrixTools, only: DumpBlock
  use MLSCommon, only: R8, MLSCHUNK_T
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES, add_to_retrieval_timing
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
  use OUTPUT_M, only: BLANKS, OUTPUT
  use SnoopMLSL2, only: SNOOP
  use String_Table, only: DISPLAY_STRING, Get_String
  use Time_M, only: Time_Now
  use Toggles, only: Gen, Switches, Toggle
  use Trace_M, only: Trace_begin, Trace_end
  use Tree, only: Decorate, Decoration, Node_ID, Nsons, Source_Ref, Sub_Rosa, &
    & Subtree
  use Tree_Types, only: N_colon, N_colon_less, N_less_colon, &
    & N_less_colon_less, N_named
  use VectorsModule, only: AddToVector, AddVectorToDatabase, ClearVector, &
    & CloneVector, CopyVector, CopyVectorMask, DestroyVectorInfo, &
    & DestroyVectorDatabase, DumpMask, GetVectorQuantityByType, &
    & IsVectorQtyMasked, M_Fill, M_FullDerivatives, M_LinAlg, &
    & M_Tikhonov, Vector_T, VectorValue_T

a16 7
  real(r8), parameter, private :: DefaultInitLambda = 0.0_r8
  integer, parameter, private :: DefaultMaxF = 30, DefaultMaxJ = 5
  integer, parameter, private :: DefaultMethod = l_newtonian
  double precision, parameter, private :: DefaultToleranceA = 1.0d-6 ! for NWT
  double precision, parameter, private :: DefaultToleranceF = 1.0d-6 ! for NWT
  double precision, parameter, private :: DefaultToleranceR = 1.0d-6 ! for NWT

d19 1
a19 1
       "$Id: RetrievalModule.f90,v 2.161 2002/08/08 22:02:52 vsnyder Exp $"
d35 1
d37 2
d40 30
d71 14
d87 2
a88 2
    integer, intent(in) :: Root         ! Of the relevant subtree of the AST
                                        ! Indexes an n_cf vertex
d95 8
d129 1
a129 1
    integer :: IxJacobian               ! Index in tree of jacobian matrix
d2963 3
@


2.161
log
@Add regWeightVec and Tikhonov mask
@
text
@d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.160 2002/08/06 02:16:09 livesey Exp $"
d163 1
d463 7
d710 1
a710 1
      call cloneVector ( v(reg_X_x), measurements, vectorNameText='_reg_X_x' )
d1018 1
a1018 3
            ! We need a matrix with the same column space as the "jacobian".
            ! The "jacobian" matrix is handily unused, so we used it here.
            call regularize ( jacobian, regOrders, regQuants, regWeights, &
d1020 1
a1020 1
            call multiplyMatrixVectorNoT ( jacobian, v(x), v(reg_X_x) ) ! regularization * x_n
d1022 5
a1026 3
              if ( index(switches,'reg') /= 0 ) &
                & call dump ( jacobian, name='Tikhonov', details=2 )
            call formNormalEquations ( jacobian, normalEquations, &
d1029 1
a1029 1
            call clearMatrix ( jacobian )           ! free the space
d1148 1
a1148 3
            ! We need a matrix with the same column space as the "jacobian".
            ! The "jacobian" matrix is handily unused, so we used it here.
            call regularize ( jacobian, regOrders, regQuants, regWeights, &
d1150 1
a1150 1
            call multiplyMatrixVectorNoT ( jacobian, v(x), v(reg_X_x) ) ! regularization * x_n
d1162 1
a1162 1
              call columnScale ( jacobian, v(columnScaleVector) )
d1165 5
a1169 3
              if ( index(switches,'reg') /= 0 ) &
                & call dump ( jacobian, name='Tikhonov', details=2 )
            call formNormalEquations ( jacobian, normalEquations, &
d1172 1
a1172 1
            call clearMatrix ( jacobian )           ! free the space
d2963 3
@


2.160
log
@Fixed averaging kernels by reflecting the kTk matrix
@
text
@a13 1
  use BitStuff, only: CountBits
a15 1
  use ForwardModelConfig, only: ForwardModelConfig_T
d24 2
a25 2
    & F_state, F_toleranceA, F_toleranceF, F_toleranceR, Field_first, &
    & Field_last, &
d33 1
a33 1
    & L_numJ, L_opticalDepth, L_pressure, L_radiance, L_zeta, &
a45 1
  use SidsModule, only: SIDS
d59 1
a59 1
    & Vector_T, VectorValue_T
d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.159 2002/08/05 19:40:11 vsnyder Exp $"
d90 4
d155 1
d283 2
d336 2
d374 5
a378 2
        if ( got(f_regOrders) .neqv. got(f_regWeights) ) &
          & call announceError ( bothOrNeither, f_regOrders, f_regWeights )
d1013 1
a1013 1
              & tikhonovRows )
d1143 1
a1143 1
              & tikhonovRows )
a1629 1
        call destroyMatrix ( kTk%m )
d2610 2
d2955 3
@


2.159
log
@Undo scaling of kTk -- it's prepared unscaled
@
text
@d41 1
a41 1
    & Matrix_SPD_T, MultiplyMatrixVectorNoT, operator(.TX.), Dump
d77 1
a77 1
       "$Id: RetrievalModule.f90,v 2.158 2002/08/03 20:40:58 livesey Exp $"
d1615 2
d2945 3
@


2.158
log
@Added matrix name preseveration.  Changed averaging kernel calculation.  Still
not right though!
@
text
@d77 1
a77 1
       "$Id: RetrievalModule.f90,v 2.157 2002/08/03 01:16:17 vsnyder Exp $"
a1614 4
        if ( columnScaling /= l_none ) then
          call columnScale ( kTk%m, v(columnScaleVector) )
          call rowScale ( v(columnScaleVector), kTk%m )
        end if
d2943 4
@


2.157
log
@RegAfter switch controls Tikhonov before/after column scaling -- default before
@
text
@d77 1
a77 1
       "$Id: RetrievalModule.f90,v 2.156 2002/07/31 22:43:30 vsnyder Exp $"
d443 1
d652 1
d1587 1
d1607 1
d1614 5
d1620 1
d2947 3
@


2.156
log
@Add some timers in the Newtonian iteration
@
text
@d25 3
a27 2
    & F_quantity, F_regOrders, F_regQuants, F_regWeights, F_state, &
    & F_toleranceA, F_toleranceF, F_toleranceR, Field_first, Field_last, &
d77 1
a77 1
       "$Id: RetrievalModule.f90,v 2.155 2002/07/26 22:47:56 vsnyder Exp $"
d161 1
d219 1
d324 2
d979 1
a979 1
              call scaleVector ( v(aTb), aprioriScale )
d989 2
a990 2
          ! Add Tikhonov regularization if requested
          if ( got(f_regOrders) ) then
d993 1
d1103 62
d1178 1
a1178 1
                          !                         equations = column norms
d2937 3
@


2.155
log
@Only do DNWT internal output after NF_SOLVE and at the end.
Finish commenting-out FNMIN calculation when NWT_FLAG = NF_SOLVE
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.154 2002/07/26 01:20:22 vsnyder Exp $"
d159 1
a159 1
    real :: T1, T2                      ! for timing
d713 1
d746 4
a749 1
            call output ( numJ, advance='yes' )
d1406 6
a1411 4
              if ( index(switches,'nwt') /= 0 )&
                & call output ( &
                  & 'Newton iteration terminated because of convergence', &
                  & advance='yes' )
d1474 5
d1498 9
d1511 6
d1518 5
d1530 5
d1543 2
d2869 4
@


2.154
log
@Exploit added output from DNWTDB, get rid of bogus Levenberg at start
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.153 2002/07/24 01:08:40 vsnyder Exp $"
a735 7
          if ( nwt_flag /= nf_start .and. index(switches,'ndb') /= 0 ) then
            if ( index(switches,'nwt') /= 0 ) then
              call nwtdb
            else
              call nwtdb ( aj )
            end if
          end if
d1266 12
a1277 12
          if ( aj%fnmin < 0.0 ) then
            call output ( 'How can aj%fnmin be negative?  aj%fnmin = ' )
            call output ( aj%fnmin, advance='yes' )
            call output ( 'aj%fnorm**2 = ' )
            call output ( aj%fnorm**2, advance='yes' )
            call output ( 'norm(candidateDX) = ' )
            call output ( v(candidateDX) .dot. v(candidateDX), advance='yes' )
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Norm of residual is imaginary!' )
            aj%fnmin = tiny ( aj%fnmin )
          end if
          aj%fnmin = sqrt(aj%fnmin)
d1301 7
d1453 8
d2831 3
@


2.153
log
@Don't compute FNMIN at NF_SOLVE time -- it should be the same as at NF_EVALJ
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.152 2002/07/22 23:14:28 pwagner Exp $"
a734 2
          if ( nwt_flag /= nf_start .and. index(switches,'ndb') /= 0 ) &
            & call nwtdb
d736 7
a1018 8
          !{ Add some early stabilization.  This consists of adding equations
          ! of the form $\lambda {\bf I} \simeq {\bf 0}$.
          if ( nwt_flag /= nf_getJ .and. got(f_lambda) ) then
            call updateDiagonal ( normalEquations, initLambda )
            update = .true.
            ! The right-hand-side is zero -- no need to update ATb or aj%fnorm
          end if

d2823 3
@


2.152
log
@Fixed some bugs in timings (there may be more)
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.151 2002/07/22 22:53:42 pwagner Exp $"
d88 2
a89 2
  !{Process the "Retrieve" section of the L2 Configuration File.
  ! The "Retrieve" section can have ForwardModel, Matrix, Sids, Subset or
d595 1
a595 1
    ! 
d921 1
a921 1
        ! "Candidate DX" that might not actually get used.
d1195 1
a1195 1
          ! $\bf\delta \hat x$ is the "Candidate DX" that may not get
d1199 1
a1199 1
          ! U}^{-T} {\bf \delta \hat x}$. The variable {\tt candidateDX} is a
d1229 4
a1232 3
        !     account of Levenberg-Marquardt stabilization.
        !   \item[AJ\%DXN] = L2 norm of "candidate DX",
        !   \item[AJ\%GDX] = (Gradient) .dot. ("candidate DX")
d1259 1
a1259 1
          !{Solve for "candidate DX" = ${\bf \delta \hat x} = -({\bf J}^T {\bf
d1265 3
d1275 1
a1275 1
          aj%fnmin = aj%fnorm**2 - (v(candidateDX) .dot. v(candidateDX))
d2826 3
@


2.151
log
@Added form norm eq and tikh reg timings
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.150 2002/07/08 21:05:09 vsnyder Exp $"
d985 1
d1009 1
d1082 1
d1086 1
d2822 3
@


2.150
log
@Make sure "Best X" has a value even if no Newtonian iterations are done.
Mark Filipiak noticed this problem.
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.149 2002/07/04 00:34:55 vsnyder Exp $"
d984 1
d1007 1
d1079 1
d1082 1
d2818 4
@


2.149
log
@Make aprioriMinusX apriori - x instead of -x
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.148 2002/07/02 01:38:06 vsnyder Exp $"
d732 1
d2814 3
@


2.148
log
@Quit if a a retrieve can't be done due to L2CF errors
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.147 2002/07/01 23:43:17 vsnyder Exp $"
d781 1
a781 1
            call cloneVector ( v(aprioriMinusX), apriori, &
d2813 3
@


2.147
log
@Plug some memory leaks
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.146 2002/06/25 20:45:31 vsnyder Exp $"
d470 3
d2813 3
@


2.146
log
@DestroyVectorValue should have been ClearVector in the case that there is
no apriori covariance.
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.145 2002/06/18 01:19:52 vsnyder Exp $"
d669 3
d780 2
a781 1
            v(aprioriMinusX) = apriori - v(x)
d1484 4
a1487 1
      if ( got(f_average) ) outputAverage = outputCovariance%m .tx. kTk%m
d1493 2
a1494 2
      ! Most of them are in the myVectors database, which is destroyed
      ! upon exit from Retrieve.
d1497 1
d2810 4
@


2.145
log
@Cosmetic changes
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.144 2002/06/07 01:34:26 vsnyder Exp $"
d968 1
a968 1
            call destroyVectorValue ( v(aTb) ) ! Clear the RHS vector
d2802 3
@


2.144
log
@Create temp matrix used in covariance calculation
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.143 2002/05/22 19:16:51 vsnyder Exp $"
d1778 1
a1778 1
	   badValue = outExtSD%template%badValue
d2171 1
a2171 1
			         xext(i)=x(i)/scale
d2210 1
a2210 1
	   badValue = outExtSD%template%badValue
d2802 3
@


2.143
log
@Put the correct number of rows used for Tikhonov regularization into the
diagnostics vector.
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.142 2002/05/22 19:00:38 vsnyder Exp $"
d1464 1
d2802 4
@


2.142
log
@Correct covariance calculation -- it ought to be U^{-1} U^{-T}, not U^{-1}.
Mark Filipiak noticed this bug.
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.141 2002/05/07 01:02:24 vsnyder Exp $"
d653 1
d983 2
a984 1
            call regularize ( jacobian, regOrders, regQuants, regWeights )
d998 2
d1459 1
a1459 1
            & jacobian_rows = jacobian_rows + jacobian_cols
d2801 4
d2806 1
a2806 1
! Change regWeight to regWeights -- which is now a tree note instead of
@


2.141
log
@Change regWeight to regWeights -- which is now a tree note instead of
a real scalar.  Add dump for regularization matrix.
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.140 2002/04/22 23:00:58 vsnyder Exp $"
d610 2
a611 1
        & Negate, RowScale, ScaleMatrix, SolveCholesky, UpdateDiagonal
d651 1
d1440 4
a1443 4
          ! Compute rows of Jacobian actually used.  Don't count rows due
          ! to Levenberg-Marquardt stabilization.  Do count rows due to
          ! a priori or regularization.  Put numbers of rows and columns
          ! into diagnostic vector.
d1460 3
a1462 1
        call invertCholesky ( factored, outputCovariance%m )
d2797 4
@


2.141.2.1
log
@*** empty log message ***
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.143 2002/05/22 19:16:51 vsnyder Exp $"
d610 1
a610 2
        & MultiplyMatrix_XY_T,  Negate, RowScale, ScaleMatrix, SolveCholesky, &
        & UpdateDiagonal
a649 1
      type(matrix_T) :: Temp            ! Because we can't do X := X * Y
a650 1
      integer :: TikhonovRows           ! How many rows of Tiknonov regularization?
d980 1
a980 2
            call regularize ( jacobian, regOrders, regQuants, regWeights, &
              & tikhonovRows )
a993 2
          else
            tikhonovRows = 0
d1438 4
a1441 4
          ! Compute number of rows of Jacobian actually used.  Don't count
          ! rows due to Levenberg-Marquardt stabilization.  Do count rows
          ! due to a priori or regularization.  Put numbers of rows and
          ! columns into diagnostic vector.
d1453 1
a1453 1
            & jacobian_rows = jacobian_rows + tikhonovRows
d1458 1
a1458 3
        call invertCholesky ( factored, temp ) ! U^{-1}
        call multiplyMatrix_XY_T ( temp, temp, outputCovariance%m ) ! U^{-1} U^{-T}
        call destroyMatrix ( temp )
a2792 12
! Revision 2.143  2002/05/22 19:16:51  vsnyder
! Put the correct number of rows used for Tikhonov regularization into the
! diagnostics vector.
!
! Revision 2.142  2002/05/22 19:00:38  vsnyder
! Correct covariance calculation -- it ought to be U^{-1} U^{-T}, not U^{-1}.
! Mark Filipiak noticed this bug.
!
! Revision 2.141  2002/05/07 01:02:24  vsnyder
! Change regWeight to regWeights -- which is now a tree node instead of
! a real scalar.  Add dump for regularization matrix.
!
@


2.140
log
@Add SquareRoot=.true. to getDiagonal for standard deviation
@
text
@d25 1
a25 1
    & F_quantity, F_regOrders, F_regQuants, F_regWeight, F_state, &
d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.139 2002/04/22 20:55:00 vsnyder Exp $"
d152 1
a152 1
    real(r8) :: RegWeight               ! Weight of regularization conditions
d325 2
d334 1
a334 1
            &    f_regWeight, f_toleranceA, f_toleranceF, f_toleranceR )
a348 2
            case ( f_regWeight )
              regWeight = value(1)
d363 2
a364 2
        if ( got(f_regOrders) .neqv. got(f_regWeight) ) &
          & call announceError ( bothOrNeither, f_regOrders, f_regWeight )
a708 4
          if ( got(f_regWeight) ) then
            call output ( ' regWeight = ' )
            call output ( regWeight )
          end if
d978 3
a980 2
            ! The "jacobian" matrix is used for scratch here.
            call regularize ( jacobian, regOrders, regQuants, regWeight )
d982 3
a984 1
            call scaleVector ( v(reg_X_x), -regWeight )   ! -R x_n
d2793 3
@


2.139
log
@Compute and output the averaging kernel
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.138 2002/03/13 22:01:50 livesey Exp $"
a103 1
    type(matrix_T), pointer :: AveragingKernel ! NormalEquationsMatrix^{-1} (J^T J)
d1467 2
a1468 3
        if ( associated(outputSD) ) then
          call GetDiagonal ( outputCovariance%m, outputSD )
        end if
d2794 3
@


2.138
log
@Changed explicitFill to fill
@
text
@d18 5
a22 5
  use Init_Tables_Module, only: F_apriori, F_aprioriScale, F_channels, &
    & F_columnScale, F_Comment, F_covariance, F_diagnostics, F_diagonal, &
    & F_forwardModel, F_fuzz, F_fwdModelExtra, F_fwdModelOut, F_height, &
    & F_ignore, F_jacobian, F_lambda, F_Level, F_mask, F_maxF, F_maxJ, &
    & F_measurements, F_measurementSD, F_method, F_opticalDepth, &
d40 1
a40 1
    & Matrix_SPD_T, MultiplyMatrixVectorNoT, Dump
d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.137 2002/03/08 08:07:16 livesey Exp $"
d104 1
d126 1
d143 1
d147 1
d206 2
a207 1
    integer, parameter :: NotSPD = noFields + 1   ! Not symmetric pos. definite
d289 2
d405 1
d428 20
d541 1
a541 1
      case ( inconsistent, notSPD )
d549 2
d627 7
d637 1
a637 1
      type(matrix_SPD_T) :: NormalEquations  ! Jacobian**T * Jacobian
d765 2
a766 1
            if ( got(f_outputCovariance) .or. got(f_outputSD) ) then
d856 2
a857 1
            if ( got(f_outputCovariance) .or. got(f_outputSD) ) then
d939 2
a940 1
            if ( .not. (got(f_outputCovariance) .or. got(f_outputSD)) ) exit
d1011 10
a1021 1
          call clearVector ( v(f_rowScaled) )
d1065 2
a1066 3
            call formNormalEquations ( jacobian, normalEquations, &
              & rhs_in=v(f_rowScaled), rhs_out=v(aTb), update=update, &
              & useMask=.true. )
d1076 4
d1385 2
a1386 1
            if ( got(f_outputCovariance) .or. got(f_outputSD) ) then
d1431 4
a1434 1
      if ( got(f_outputCovariance) .or. got(f_outputSD) ) then
d1441 2
a1442 2
          ! to Levenberg-Marquardt stabilization.  Do count rows due to a
          ! priori or regularization.  Put numbers of rows and columns
d1463 6
a1468 2
        !??? Don't forget to scale the covariance
        if ( associated(outputSD) ) then !???
a1469 3
          if ( columnScaling /= l_none ) then
            call multiply ( outputSD, v(columnScaleVector) )
          end if
d1472 4
d1492 2
a1493 2
      use Intrinsic, only: L_PTAN, L_RADIANCE, &
                     & L_CLOUDINDUCEDRADIANCE,                               &
d1495 1
a1495 1
                     & L_CLOUDRADSENSITIVITY,                                &
d1560 2
a1561 2
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Only one signal is allowed in high cloud retrieval' )
d2796 3
@


2.137
log
@Added explicit fill mask
@
text
@d31 1
a31 1
    & L_dnwt_sq,  L_dnwt_sqt, L_ExplicitFill, L_full_derivatives, &
d60 1
a60 1
    &IsVectorQtyMasked, M_ExplicitFill, M_FullDerivatives, M_LinAlg, &
d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.136 2002/03/06 01:44:30 livesey Exp $"
d2386 2
a2387 2
            case ( l_explicitFill )
              maskBit = ior(maskBit, m_explicitFill)
d2735 3
@


2.136
log
@Changed manner in which optical depth cutoff applied so that
once a channel is too optically thick it always is (as a function of
height).  Note it's resistant to changes in scan direction.
@
text
@d31 1
a31 1
    & L_dnwt_sq,  L_dnwt_sqt, L_full_derivatives, &
d60 1
a60 1
    &IsVectorQtyMasked, M_FullDerivatives, M_LinAlg, &
d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.135 2002/02/14 21:55:31 vsnyder Exp $"
d2386 2
d2735 5
@


2.135
log
@Account for mask.  Get a final Jacobian using Best X.  Cosmetic changes.
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.134 2002/02/13 00:11:13 vsnyder Exp $"
d2327 1
d2331 1
d2333 1
a2334 1
      integer :: RANGEID                ! nodeID of a range
d2337 1
d2494 1
d2498 1
d2565 2
a2566 1

d2571 37
d2616 1
a2616 1
                      if ( opticalDepth%values ( ind, instance ) < opticalDepthCutoff ) &
d2643 1
a2643 1
                        & opticalDepth%values ( ind, instance ) < opticalDepthCutoff
d2733 3
@


2.134
log
@Test fnmin both places it's formed
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.133 2002/02/12 22:53:21 vsnyder Exp $"
d569 2
a570 2
        & NF_START, NF_TOLX, NF_TOLX_BEST, NF_TOLF, NF_TOO_SMALL, &
        & NF_FANDJ, NWT, NWT_T, NWTA, NWTDB, RK
d586 2
a587 2
        & DestroyVectorValue, Dump, Multiply, operator(.DOT.), operator(-), &
        & ScaleVector, SubtractFromVector
d597 2
d639 1
a639 2
      call copyVector ( v(f_rowScaled), measurements, clone=.true., & ! mask only
        & noValues=.true., vectorNameText='_f_rowScaled' )
d692 2
a693 1
        if ( nwt_flag /= nf_start .and. index(switches,'ndb') /= 0 ) &
d695 2
a696 1
        call nwta ( nwt_flag, aj )
d699 1
d724 8
a731 3
!??? At this point we should restore BestX, run the forward model again
!??? to get a new Jacobian, and form normal equations -- the last two so
!??? that the a posteriori covariance is consistent with BestX.
d770 1
a770 1
            aprioriNorm = v(aprioriMinusX) .dot. v(covarianceXapriori)
d783 1
d798 1
a798 1
          aj%fnorm = sqrt ( aprioriNorm + ( v(f_rowScaled) .dot. v(f_rowScaled) ) )
d800 1
a800 1
              & call dump ( v(f), name='Residual' )
d814 8
a821 3
!??? At this point we should restore BestX, run the forward model again
!??? to get a new Jacobian, and form normal equations -- the last two so
!??? that the a posteriori covariance is consistent with BestX.
d824 1
a824 1
        case ( nf_evalj ) ! ..............................  EVALJ  .....
d887 1
a887 1
          if ( numJ > maxJacobians ) then
d896 6
a901 4
!??? At this point we should restore BestX, run the forward model again
!??? to get a new Jacobian, and form normal equations -- the last two so
!??? that the a posteriori covariance is consistent with BestX.
            exit
d942 2
d960 1
a960 1
          if ( got(f_lambda) ) then
d963 1
a963 2
            ! The right-hand-side is zero -- no need to update ATb
            ! or aj%fnorm
d1029 1
a1029 1
          aj%fnorm = aj%fnorm + ( v(f_rowScaled) .dot. v(f_rowScaled) )
d1108 1
d1203 2
a1204 2
            call output ( 'aj%fnorm = ' )
            call output ( aj%fnorm, advance='yes' )
d1333 4
d1339 1
a1339 1
          diagonal = .not. diagonal
d1379 4
d1393 2
a1394 1
              & countBits(normalEquations%m%col%vec%quantities(j)%mask)
a1402 17
        ! Subtract sum of Levenberg-Marquardt updates from normal
        ! equations
        call updateDiagonal ( normalEquations, -aj%sqt**2 )
        ! Subtract a priori covariance matrix from normal equations
        ! call negate ( covariance%m )
        ! call addToMatrix ( normalEquations%m, covariance%m )
        ! call negate ( covariance%m )
        !??? Commented out, pending deep thought.!???
        !??? If we remove a priori covariance from normal equations
        !??? we should presumably also remove regularization.  Maybe we
        !??? should remove regularization anyway.  On the other hand, if
        !??? remove them, maybe the normal equations are singular?
        ! Re-factor normal equations
        call add_to_retrieval_timing( 'newton_solver', t1 )
        call time_now ( t1 )
        call choleskyFactor ( factored, normalEquations )
        call add_to_retrieval_timing( 'cholesky_factor', t1 )
d2690 3
@


2.133
log
@Update a bunch of comments
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.132 2002/02/09 19:11:34 livesey Exp $"
d1120 1
a1120 1
            aj%fnmin = sqrt ( tiny ( aj%fnmin ) )
d1180 13
a1192 1
          aj%fnmin = sqrt(aj%fnorm**2 - (v(candidateDX) .dot. v(candidateDX)) )
d2679 3
@


2.132
log
@Modified subset to add optical depth cutoffs
@
text
@d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.131 2002/02/08 22:51:59 livesey Exp $"
d759 2
a760 1
            ! ( a - x_n )^T F^T F ( a - x_n ) = ( a - x_n )^T C ( a - x_n )}$
d782 2
a783 2
!          ForwardModel itself calls add_to_retrieval_timing
!          call add_to_retrieval_timing( 'forward_model', t1 )
d804 3
d811 1
a811 1
        ! Compute the Jacobian matrix J if you didn't do it when NFLAG
d813 1
a813 1
        ! ${\bf J}_{k,l} = \frac{\partial {\bf f}_k}{\partial {\bf x}_l},
d816 1
a816 1
        ! Actually, the matrix has four parts:
d818 1
a818 1
        !  {\bf J \delta x} & \simeq {\bf -f}  && \text{The Jacobian} \\
d830 1
d834 1
a834 1
        !  {\bf J} \\
d839 1
a839 1
        !  \simeq
d842 1
a842 1
        !   {\bf -f} \\
d858 4
a861 4
        ! Triangularize ${\bf J}$, and compute the (negative of the) gradient
        ! = $-{\bf J^T f}$.  This is the RHS of the normal equations
        ! ${\bf J^T J \delta \hat x} = -{\bf J^T f}$ where ${\bf \delta
        !  \hat x}$ is a "Candidate DX" that might not actually get used.
d881 3
d888 9
a896 5
            !{ Using Apriori requires adding equations of the form
            !  $C x_n \simeq C a$ where $C$ is the Cholesky factor of the
            !  apriori covariance.  So that all of the parts of the problem
            !  are solving for $\delta x$, we subtract $C x_{n-1}$ from both
            !  sides, to get $C \delta x \simeq C (a - x_{n-1})$.
d915 2
a916 1
          ! aprioriNorm was computed when nwt_flag was NF_EVALF
d921 4
a924 4
            !{ Tikhonov regularization is of the form $R x_n \simeq 0$.
            !  So that all of the parts of the problem are solving for
            !  $\delta x$, we subtract $R x_{n-1}$ from both sides to get
            !  $R \delta x \simeq -R x_{n-1}$.
d932 1
d934 1
a934 1
!           call destroyVectorValue ( v(reg_X_x) )  ! free the space
d940 1
a940 1
          ! of the form $\lambda I \simeq 0$.
d958 2
a959 2
            ! What if one config set finished but others still had more
            ! to do? Ermmm, think of this next time.
d966 2
a967 2
!          ForwardModel itself calls add_to_retrieval_timing
!            call add_to_retrieval_timing( 'forward_model', t1 )
d974 8
a981 8
                !{Let ${\bf J}$ be the Jacobian matrix and ${\bf f}$ be the
                ! residual of the least-squares problem.  Let $\bf W$ be the
                ! inverse of the measurement covariance (which in our case
                ! is diagonal). Row scale the part of the least-squares
                ! problem that arises from the measurements, i.e. the
                ! least-squares problem becomes $\mathbf{W J = W f}$
                ! (actually, we only row scale ${\bf f}$ here, and scale
                ! ${\bf J}$ below).
d994 4
a997 1
            ! $\mathbf{J^T W^T W J \delta \hat x = J^T W^T W f}$:
d1010 1
d1013 7
a1019 5
          !{Column Scale $\mathbf{J}$ (row and column scale $\mathbf{J^T
          ! J}$).  Let $\mathbf{\Sigma}$ be a column-scaling matrix for the
          ! Jacobian. We cater for several choices.  After row and column
          ! scaling, the problem is $\mathbf{J^T W^T W J \Sigma \Sigma^{-1}
          ! \delta \hat x = -J^T W^T f}$.
d1021 1
a1021 1
          case ( l_apriori )
d1025 2
a1026 1
          case ( l_norm )
d1040 5
a1044 1
            !{Scale: $\mathbf{\Sigma^T J^T J \Sigma = -\Sigma^T J^T f}$
d1050 3
a1052 5
          !{Compute the (negative of the) gradient $= -\mathbf{J^T f}$.
          ! This is the right-hand side of the normal equations
          ! $\mathbf{J^T J \delta \hat x = -J^T f}$ where $\mathbf{\delta
          ! \hat x}$ is the "Candidate $\mathbf{\delta x}$" that may or
          ! may not get used.
d1057 9
a1065 5
          ! Factor J^T J:
!         factored%m%block => normalEquations%m%block ! to save space
!         Can't do the above because we need to keep the normal
!         equations around, in order to subtract Levenberg-Marquardt and
!         apriori covariance, in order to compute a posteriori covariance
d1074 1
a1074 1
          call add_to_retrieval_timing( 'newton_solver', t1 )
a1075 1
          ! Factor the normal equations
d1077 1
a1077 1
          call add_to_retrieval_timing( 'cholesky_factor', t1 )
d1094 1
a1094 1
          call add_to_retrieval_timing( 'newton_solver', t1 )
d1098 1
a1098 1
          call add_to_retrieval_timing( 'cholesky_solver', t1 )
d1101 9
a1109 6
          !{AJ\%FNMIN = L2 norm of residual, $||\mathbf{J \delta x + f}||$
          ! where $\mathbf{\delta x}$ is the "Candidate DX" that may not
          ! get used. This can be gotten without saving $\bf J$ as
          ! $\mathbf{f^T f - y^T y}$ where $\mathbf{y = U^{-T} \delta x}$
          ! ($\mathbf{U}$ is the Cholesky factor of $\mathbf{J^T J}$).
          ! The variable {\tt candidateDX} is a temp here = $\bf y$.
d1132 4
a1135 3
        ! $\lambda =$ {\bf AJ\%SQ}.  I.e. solve $\mathbf{(J^T W^T W J
        ! \Sigma + \lambda^2 I) \Sigma^{-1} \delta \hat x = J^T W^T
        ! f}$ for $\mathbf{\Sigma^{-1} \delta \hat x}$.  Set
d1143 4
a1146 4
!         factored%m%block => normalEquations%m%block ! to save space
!         Can't do the above because we need to keep the normal equations
!         around, in order to subtract Levenberg-Marquardt and apriori
!         covariance, in order to compute a posteriori covariance
d1167 6
a1172 6
          !{Solve for "candidate DX" = $-\mathbf{(J^T J)^{-1} J^T  F =
          ! -(U^T U)^{-1} J^T  F}$ using two back solves.  First solve
          ! $\mathbf{U^T y = -J^T F}$, then $\mathbf{U}$ "candidate DX"
          ! = $\mathbf{y}$. Meanwhile, set AJ\%FNMIN as for NWT\_FLAG =
          ! NF\_EVALJ, but taking account of Levenberg-Marquardt
          ! stabilization
d1179 1
d2667 3
@


2.131
log
@Added call to CopyVectorMask to transfer mask from measurements to forward
model.
@
text
@d23 1
d34 1
a34 1
    & L_numJ, L_pressure, L_zeta, &
d76 1
a76 1
       "$Id: RetrievalModule.f90,v 2.130 2002/02/07 02:55:02 vsnyder Exp $"
d192 4
a195 2
    integer, parameter :: BothOrNeither = 1       ! Only one of two required
                                                  !    fields supplied
d200 2
a201 1
    integer, parameter :: NoFields = InconsistentUnits + 1  ! No fields are allowed
d203 2
a204 1
    integer, parameter :: WrongUnits = notSPD + 1
d488 5
d529 3
d536 4
a2264 1
      integer :: DEPTHNODE              ! Tree node for optical depth
d2271 1
d2289 1
d2292 1
d2303 1
a2303 1
      nullify ( channels, qty, ptan )
d2336 10
a2345 1
          depthNode = son
d2354 12
d2516 8
a2523 3
                    call ClearMask ( qty%mask(:,instance), &
                      & (/ channel+qty%template%noChans*(height-1) /), &
                      & what=maskBit )
d2532 1
d2544 4
d2549 1
a2549 2
                        & (/ channel+qty%template%noChans*(height-1) /), &
                        & what=maskBit )
d2636 4
@


2.130
log
@Add a 'mask' field to the 'setup' spec
@
text
@d57 3
a59 3
    & CloneVector, CopyVector, DestroyVectorInfo, DestroyVectorDatabase, &
    & DumpMask, GetVectorQuantityByType, IsVectorQtyMasked, &
    & M_FullDerivatives, M_LinAlg, &
d75 1
a75 1
       "$Id: RetrievalModule.f90,v 2.129 2002/02/05 02:40:52 vsnyder Exp $"
d442 1
d2587 3
@


2.129
log
@Use 'dumpMask' instead of 'dump' to dump the mask, cosmetic changes
@
text
@d21 5
a25 5
    & F_ignore, F_jacobian, F_lambda, F_Level, F_maxF, F_maxJ, F_measurements, &
    & F_measurementSD, F_method, F_opticalDepth, F_outputCovariance, &
    & F_outputSD, F_phaseName, F_ptanQuantity, F_quantity, F_regOrders, F_regQuants, &
    & F_regWeight, F_state, F_toleranceA, F_toleranceF, F_toleranceR, &
    & Field_first, Field_last, &
d27 7
a33 7
    & L_dnwt_ajn,  L_dnwt_axmax,  L_dnwt_cait, &
    & L_dnwt_diag,  L_dnwt_dxdx,  L_dnwt_dxdxl, &
    & L_dnwt_dxn,  L_dnwt_dxnl,  L_dnwt_flag, L_dnwt_fnmin, &
    & L_dnwt_fnorm,  L_dnwt_gdx,  L_dnwt_gfac, &
    & L_dnwt_gradn,  L_dnwt_sq,  L_dnwt_sq,  L_dnwt_sqt,&
    & L_highcloud, L_Jacobian_Cols, L_Jacobian_Rows, L_lowcloud, &
    & L_newtonian, L_none, L_norm, L_numF, L_numJ, L_pressure, L_zeta, &
d59 1
d75 1
a75 1
       "$Id: RetrievalModule.f90,v 2.128 2002/01/18 00:31:23 livesey Exp $"
d2255 2
d2262 1
d2268 2
a2269 2
      integer :: S1(1), S2(1)           ! Results of minloc intrinsic

a2270 1
      real(r8), dimension(:), pointer :: THESEHEIGHTS ! Subset of heights
a2280 1
      real(r8)         ::                        heightMin, heightMax
d2286 1
a2289 1
        got(field) = .true.
d2304 11
d2322 1
d2418 2
a2419 1
                  & (/ channel+qty%template%noChans*(height-1) /) )
d2476 2
a2477 1
                      & (/ channel+qty%template%noChans*(height-1) /) )
d2498 2
a2499 1
                        & (/ channel+qty%template%noChans*(height-1) /) )
d2586 3
@


2.128
log
@Changed error message about fnmin being imaginary to warning and put
in a work around.  I want to see what it's doing.
@
text
@d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.127 2001/12/03 18:50:43 pwagner Exp $"
d2510 1
a2510 1
        call dump ( qty%mask, format='(1x,z8.8)' )
d2520 1
a2520 1
        endif
d2532 1
a2532 1
        enddo
d2543 1
a2543 1
            endif
d2551 1
a2551 1
          enddo
d2555 1
a2555 1
        enddo
d2561 1
a2561 1
        endif
d2569 4
@


2.127
log
@NAG compiler mad at '/ =' instead of '/='
@
text
@d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.126 2001/12/01 01:01:56 livesey Exp $"
d1070 1
a1070 1
            call MLSMessage ( MLSMSG_Error, ModuleName, &
d1072 1
d2569 3
@


2.126
log
@Added vir switch
@
text
@d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.125 2001/11/28 23:16:39 livesey Exp $"
d918 1
a918 1
          if ( index(switches,'vir') / =0 ) call dump ( normalEquations%m, details=2 )
d2568 3
@


2.125
log
@Added use of MLSMSG_Warning, whoops!
@
text
@d39 1
a39 1
    & Matrix_SPD_T, MultiplyMatrixVectorNoT
d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.124 2001/11/28 20:39:35 livesey Exp $"
d918 2
d2568 3
@


2.124
log
@Fixed bug with subset, changed some of Dong's prints to MLSMessage's
@
text
@d43 1
a43 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.123 2001/11/28 18:28:50 livesey Exp $"
d2566 3
@


2.123
log
@Updated subset to include open ranges in height specification.
There is possibly a bug in Van's version I'll point out to him
(if not my version has the opposite bug).
@
text
@d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.122 2001/11/28 00:01:27 jonathan Exp $"
d1421 5
a1425 5
      if(size(configIndices) > 1 .or. &
        & size(configDatabase(configIndices(1))%signals) > 1) then
        print*,'Only one signal is allowed in high cloud retrieval'
        stop
      end if
d1959 2
a1960 1
         if(ich /= nChans) print*,'inconsistent channels between Jacobian and Signal'
d2315 2
a2316 1
            call expr ( subtree(j,channelsNode), units, value, type )
d2323 1
a2323 1
            select case ( node_id(channelsNode) )
d2468 2
a2469 4
                    if ( rangeID == n_less_colon .or. rangeID == &
                      & n_less_colon_less ) then
                      doThisHeight = doThisHeight .and. &
                        & qty%template%surfs(height,instance) > value(1)
d2471 1
a2471 2
                      doThisHeight = doThisHeight .and. &
                        & qty%template%surfs(height,instance) >= value(1)
d2473 2
a2474 4
                    if ( rangeID == n_colon_less .or. rangeID == &
                      & n_less_colon_less ) then
                      doThisHeight = doThisHeight .and. &
                        & qty%template%surfs(height,instance) < value(2)
d2476 1
a2476 2
                      doThisHeight = doThisHeight .and. &
                        & qty%template%surfs(height,instance) <= value(1)
d2566 5
@


2.122
log
@remove type (VectorValue_T), pointer :: Re
@
text
@d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.121 2001/11/27 23:49:48 jonathan Exp $"
d2253 1
d2269 2
a2270 1
      logical :: DOTHIS                 ! Flag
d2392 3
a2394 3
            doThis = .true.
            if ( associated(channels) ) doThis = channels(channel)
            if ( doThis ) then
d2405 4
a2408 1
        ! Now go and `unmask' the ones we want to consider
d2411 4
a2414 1
            ! Don't need to call expr again.
d2416 1
a2416 2
            if ( coordinate == l_zeta &
              & .and. heightUnit == phyq_pressure ) then
d2418 4
a2421 3
!             else if ( coordinate /= qty%template%verticalCoordinate ) then
!               call MLSMessage ( MLSMSG_Error, ModuleName, &
!                 & 'Inappropriate units for height in subset' )
d2423 21
a2443 6
            if ( qty%template%verticalCoordinate == l_pressure ) then
              s1 = minloc ( abs ( -log10(theseHeights) + log10(value(1)) ) )
              s2 = minloc ( abs ( -log10(theseHeights) + log10(value(2)) ) )
            else
              s1 = minloc ( abs ( theseHeights - value(1) ) )
              s2 = minloc ( abs ( theseHeights - value(2) ) )
d2445 1
d2447 39
a2485 9
              doThis = .true.
              if ( associated(channels) ) doThis = channels(channel)
              if ( doThis ) then
                do height = s1(1), s2(1)
                  !??? Make sure mask bit numbers begin at 1, even when
                  !??? channel numbers don't.
                  call ClearMask ( qty%mask(:,instance), &
                    & (/ channel+qty%template%noChans*(height-1) /) )
                end do                  ! Height loop
d2570 3
@


2.121
log
@remove Re in HighCloudRetrieval
@
text
@d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.120 2001/11/27 23:34:49 pwagner Exp $"
d1379 1
a1379 1
      type (VectorValue_T), pointer :: Re        ! Earth Radius
d2516 3
@


2.120
log
@Split forward model timings into four types
@
text
@d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.119 2001/11/27 01:28:17 vsnyder Exp $"
d1519 2
a1520 2
          Re => GetVectorQuantityByType ( fwdModelExtra,      &
               & quantityType=l_earthradius)
d2516 3
@


2.119
log
@Implement (partially) open range for channels in subset
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.118 2001/11/17 02:30:44 vsnyder Exp $"
a420 1
        ! call add_to_retrieval_timing( 'newton_solver', t1 )
a422 2
        !    call add_to_retrieval_timing( 'low_cloud', t1 )
        !    call time_now ( t1 )
d424 2
d428 2
a444 1
        ! call add_to_retrieval_timing( 'sids', t1 )
d762 2
a763 1
          call add_to_retrieval_timing( 'forward_model', t1 )
d931 2
a932 1
            call add_to_retrieval_timing( 'forward_model', t1 )
d2516 3
@


2.118
log
@Add L_numF and L_numJ to 'diagnostics' vector
@
text
@d54 2
a55 1
  use Tree_Types, only: N_named
d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.117 2001/11/13 23:35:12 vsnyder Exp $"
d2248 1
d2250 1
a2250 1
      integer :: NROWS                  ! Loop limit dumping mask
d2315 12
a2326 2
            channels ( nint(value(1)) : &
              & nint(value(merge(1,2,type==num_value))) ) = .true.
d2404 2
a2405 2
            call expr ( subtree(j,heightNode), units, value, type )
            ! Now maybe do something nasty to value to get in right units
d2514 3
@


2.117
log
@Keep f and f_rowScaled separate in EVALF case
@
text
@d33 1
a33 1
    & L_newtonian, L_none, L_norm, L_pressure, L_zeta, &
d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.116 2001/11/12 18:25:02 dwu Exp $"
d700 3
d1274 2
d2502 3
@


2.116
log
@speed up some cloud calculations
@
text
@d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.115 2001/11/09 23:17:22 vsnyder Exp $"
d183 1
a183 1
    integer, parameter :: X = weight + 1  ! for NWT
d185 1
a185 1
 
d197 1
a197 2
    integer, parameter :: OrderAndWeight = notSPD + 1  ! Need both or neither
    integer, parameter :: WrongUnits = OrderAndWeight + 1
d761 3
a763 2
          if ( got(f_measurementSD) ) call multiply ( v(f), v(weight) )
          aj%fnorm = sqrt ( aprioriNorm + ( v(f) .dot. v(f) ) )
d914 1
a914 1
          call clearVector ( v(f) )
d2497 3
@


2.115
log
@Use Time_Now instead of CPU_TIME
@
text
@d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.114 2001/11/08 01:21:45 vsnyder Exp $"
d1676 2
a1677 1
      integer :: i,j,k,ich,imodel,mif,maf,isignal          ! Loop subscripts
d1682 1
d1700 2
d1828 13
d1842 1
d1954 2
d1959 1
a1959 1
                sx(i,mif) = xLosVar%values(i+nSgrid*(mif-1),maf)  
d1961 9
d1973 1
a1973 1
            do mif=1,nMifs
d1980 2
a1981 1
               do j=1,maxJacobians     ! we use maxJacobians as number of iterations (default 5)
d1989 1
a1989 1
                   A(i,i)=A(i,i) + sx0(i)       ! sx has already been inverted
d2036 1
a2036 1
            end do  ! mif
d2077 1
a2077 1
  !=============================== LOS2Grid ====
d2497 3
@


2.114
log
@Make sure phaseName has a value
@
text
@d49 1
d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.113 2001/11/07 23:55:43 dwu Exp $"
d212 1
a212 1
    if ( timing ) call cpu_time ( t1 )
d425 1
a425 1
        !    call cpu_time ( t1 )
d445 1
a445 1
        call cpu_time ( t1 )
d451 1
a451 1
          call cpu_time ( t1 )
d595 1
a595 1
      call cpu_time ( t1 )
d670 1
a670 1
      call cpu_time ( t1 )
d749 1
a749 1
          call cpu_time ( t1 )
d760 1
a760 1
          call cpu_time ( t1 )
d917 1
a917 1
            call cpu_time ( t1 )
d927 1
a927 1
            call cpu_time ( t1 )
d1021 1
a1021 1
          call cpu_time ( t1 )
d1025 1
a1025 1
          call cpu_time ( t1 )
d1042 1
a1042 1
          call cpu_time ( t1 )
d1046 1
a1046 1
          call cpu_time ( t1 )
d1098 1
a1098 1
          call cpu_time ( t1 )
d1101 1
a1101 1
          call cpu_time ( t1 )
d1116 1
a1116 1
          call cpu_time ( t1 )
d1120 1
a1120 1
          call cpu_time ( t1 )
d1316 1
a1316 1
        call cpu_time ( t1 )
d1319 1
a1319 1
        call cpu_time ( t1 )
d1322 1
a1322 1
        call cpu_time ( t1 )
d1342 1
a1342 1
      call cpu_time ( t1 )
d2178 1
a2178 1
      call cpu_time ( t2 )
d2467 3
@


2.113
log
@added option to constain cloud top height
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.112 2001/11/06 18:04:11 dwu Exp $"
d202 2
a203 1
    snoopComment = ' '
d205 1
a205 1
    snoopLevel = 1
d2466 3
@


2.112
log
@first working version of HighCloudRetrieval
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.111 2001/11/02 01:11:45 dwu Exp $"
d1365 1
a1365 1
      type (VectorValue_T), pointer :: ModelTcir        ! for model cloud radiance
d1381 1
d1383 1
d1394 2
d1409 1
a1409 1
      pcut = -2.4
d1413 1
a1413 1
        print*,'Only one forward model and one signal is allowed in high cloud retrieval'
d1432 4
a1435 1
               
a1455 5
          ! Loop over MAFs
      do maf=1, nMAFs
      fmStat%maf = maf
      print*,'begin cloud retrieval maf= ',maf,' chunk size=',nMAFs
                        
d1468 1
a1468 1
               & quantityType=l_cloudextinction,noerror=.true.)
d1472 1
a1472 1
               & quantityType=l_cloudextinction,noerror=.true.)
d1481 13
d1524 3
a1526 1
                     
d1531 4
a1534 1
                     & (1._r8 - 0.2_r8* teff**5) ! correction term (see ATBD)
d1536 1
d1541 1
d1554 1
d1556 2
a1557 1
                ! in case we go into ambiguity altitudes with small sensitivity
d1588 2
d1607 1
a1607 1
            outExtSD%values(i,j) = sqrt(A(i+(j-1)*nz,i+(j-1)*nz))
d1624 6
a1629 3
      ! if the input variance is NOT reduced by half, it is given negative
      where(outExtSD%values**2 > 0.5/xExtVar%values) &   ! xExtVar is inversed
            & outExtSD%values = -outExtSD%values
d1665 1
d1679 1
d1804 1
d1810 14
a1823 1
            call forwardModel ( configDatabase(configIndices(imodel)), &
d1826 1
a1826 1
            do isignal = 1, size(configDatabase(configIndices(imodel))%signals)
d1871 3
a1873 1
                     
d1880 1
a1880 1
                        & (1._r8 + 0.46_r8* teff**6) ! correction term (see ATBD)
d1886 1
d1899 1
d1901 1
a1901 1
                     ! in case we go into ambiguity altitudes with small sensitivity
d2023 1
a2023 1
    ! output SD but keep the sign
d2030 2
d2465 3
@


2.111
log
@a test for highcloudretrieval
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.110 2001/11/01 19:29:01 dwu Exp $"
d1365 1
d1405 1
a1405 4
      if(.not. got(f_maxJ)) maxJacobians = 5
      if(.not. got(f_lambda)) initlambda = 10.
      
      pcut = -2.5
d1454 25
a1501 18
          ! get cloud radiance measurements for this signal
          Tcir => GetVectorQuantityByType ( Measurements,       &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )
            
          ! get cloud radiances error for this signal
          Terr => GetVectorQuantityByType ( MeasurementSD,       &
               & quantityType=l_cloudInducedRadiance,             &
               & signal=signal%index, sideband=signal%sideband )

          ! get pointers of x covariance for the retrieval
          xExtVar => GetVectorQuantityByType (covarianceDiag, &
               & quantityType=l_cloudextinction,noerror=.true.)
      
          ! get pointers of output SD for the retrieval
          outExtSD => GetVectorQuantityByType (outputSD, &
               & quantityType=l_cloudextinction,noerror=.true.)
      
d1553 1
a1553 1
                    & jBlock%values(ich,i+(j-1)*nz)*jBlock%values(mif,i1+(j1-1)*nz)/sy
d1571 2
a1572 2
         sx0(i+(j-1)*nz) = xExtVar%values(i,j)
         A(i,i)=A(i,i) + xExtVar%values(i,j)  ! sx has already been inverted
d1581 1
a1581 1
            outExtSD%values(i,j) = sqrt(A(i,i))
d1592 3
a1597 3
      ! output retrieval results
      xExtPtr%values = reshape(x,(/nz,nInst/))
      
d2414 3
@


2.110
log
@corrections in cloud retrievals
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.109 2001/10/31 21:59:56 livesey Exp $"
d426 1
a426 1
!            call HighCloudRetrieval
d1414 2
d1417 1
a1417 2
        call allocate_test ( fmStat%rows, jacobian%row%nb, 'fmStat%rows', &
        & ModuleName )
d1419 2
a1420 2
        call cloneVector ( FwdModelOut1, measurements, vectorNameText='_covarianceDiag' )
               
a1427 1

a1459 3
          ! get signal information for this model. Note: allow only 1 signal 
          signal = configDatabase(configIndices(1))%signals(1)

d1529 1
a1529 1
                if(abs(sensitivity) < 1._r8) sensitivity = 1._r8
d1540 1
a1540 1
                    dx(i+(j-1)*nz) = dx(i+(j-1)*nz) + jBlock%values(ich,i+(j-1)*nz)*y/sy
d1548 1
a1548 1
                    & jBlock%values(ich,i+(j-1)*nz)*jBlock%values(ich,i1+(j1-1)*nz)/sy
d1848 1
a1848 1
                     if(abs(sensitivity) < 1._r8) sensitivity = 105._r8
d2409 3
@


2.109
log
@Added phaseName to snooper
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.108 2001/10/30 16:57:43 dwu Exp $"
d1422 2
a1423 1
        do k=1,size (signal%frequencies)
d1643 1
a1643 1
      integer :: cloudysky     ! cloudysky index from Model Configuration
d1714 2
a1756 1
        cloudysky = 1
d1771 2
a1772 2
            ! memorize cloud configuration type
            ! to save time, only skip cloud sensitivity calculation if there is no cloud
d1774 1
a1774 1
            if(doMaf(maf)) configDatabase(configIndices(imodel))%cloud_width=cloudysky
d1851 1
a1851 1
                     if(abs(sensitivity) < 1._r8) sensitivity = 1._r8
d1958 5
d2120 1
a2120 1
  
d2412 3
@


2.108
log
@fixed a bug in LowCloudREtrieval
@
text
@d23 1
a23 1
    & F_outputSD, F_ptanQuantity, F_quantity, F_regOrders, F_regQuants, &
d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.107 2001/10/26 20:28:42 dwu Exp $"
d142 1
d243 2
d1275 1
d2405 3
@


2.107
log
@Added cloud extinction SD and high cloud retrieval
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.106 2001/10/24 00:29:00 livesey Exp $"
d1750 1
d1753 2
a1754 1
        print*,'begin cloud retrieval maf= ',maf,' chunk size=',nMAFs
a1765 1
            if(maf==1) cloudysky = configDatabase(configIndices(imodel))%cloud_width
d2401 3
@


2.106
log
@Added Matrix snooping
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.105 2001/10/23 20:08:59 vsnyder Exp $"
d1338 263
d1611 2
a1612 1
      use MatrixModule_1, only: ClearMatrix, FINDBLOCK, GetDiagonal
d1637 2
a1638 1
      integer :: i,j,k,ich,imodel,mif,isignal          ! Loop subscripts
d1645 1
d1649 1
d1658 1
d1679 4
d1706 1
d1712 10
d1733 10
d1749 4
a1752 5
        fmStat%maf = 0
          ! Loop over MAFs
        do while (fmStat%maf < chunk%lastMAFIndex-chunk%firstMAFIndex+1)
          fmStat%maf = fmStat%maf + 1
print*,'begin cloud retrieval maf= ',fmstat%maf,' chunk size=',chunk%lastMAFIndex-chunk%firstMAFIndex
d1763 6
a1804 14
              ! get pointers of x covariance for the retrieval
               xLosVar => GetVectorQuantityByType (covarianceDiag, &
               & quantityType=l_lostransfunc,noerror=.true.)
               xExtVar => GetVectorQuantityByType (covarianceDiag, &
               & quantityType=l_cloudextinction,noerror=.true.)
      
              ! get pointers of output SD for the retrieval
               outLosSD => GetVectorQuantityByType (outputSD, &
               & quantityType=l_lostransfunc,noerror=.true.)
               outExtSD => GetVectorQuantityByType (outputSD, &
               & quantityType=l_cloudextinction,noerror=.true.)
               ! initialized to SD of xLosVar
               outLosSD%values = 1._r8/sqrt(xLosVar%values)
      
d1806 2
a1807 2
              rowJBlock = FindBlock (jacobian%row, Tb0%index, fmStat%maf)
              colJBlock = FindBlock ( Jacobian%col, xLosPtr%index, fmStat%maf )
d1816 1
a1816 1
                  if(ptan%values(mif,fmStat%maf) < p_lowcut) then
d1823 1
a1823 1
                     x(j) = slope%values(k+nFreqs*(mif-1),fmStat%maf)* &
d1827 1
a1827 1
                     y(ich,mif) = Tcir%values(k+nFreqs*(mif-1),fmStat%maf)
d1840 1
a1840 1
                     sensitivity = slope%values(k+nFreqs*(mif-1),fmStat%maf)* &
d1852 1
a1852 2
                     sy(ich,mif) = Terr%values(k+nFreqs*(mif-1),fmStat%maf)**2 &
                       & /sensitivity**2
a1876 2
!            x0 = sqrt(re%values(1,fmStat%maf)**2+(sLevel*1.e3_r8)**2) - &
!               re%values(1,fmStat%maf)
d1878 2
a1879 2
!               if(x0(i) < 20.e3_r8) &
                  sx(i,mif) = xLosVar%values(i+nSgrid*(mif-1),fmStat%maf)
d1885 1
a1885 1
            if (ptan%values(mif,fmStat%maf) < p_lowcut) then
d1906 1
a1906 1
                    outLosSD%values(i+(mif-1)*nSgrid,fmStat%maf) = sqrt(A(i,i))
d1931 4
a1934 2
                  outLosSD%values(i+(mif-1)*nSgrid,fmStat%maf) = &     !neglect higher orders
                     & outLosSD%values(i+(mif-1)*nSgrid,fmStat%maf)/scale
d1941 1
a1941 1
                 xLosPtr%values(i+(mif-1)*nSgrid,fmStat%maf) = xext(i)
d1948 1
d1951 2
a1952 2
      ! deallocate arrays and free memory
            deallocate(A,C,y,sy,dx,x,x0,sx0,xext,sx)
d1955 2
a1956 1
   	call LOS2Grid(xExtPtr,xLosPtr,Ptan,Re,p_lowcut,method='Average')
d1958 15
a1972 16
      if(associated(xLosVar) .and. associated(xExtVar) &
         & .and. associated(outLosSD) .and. associated(outExtSD)) then
      ! get variances after re-sampling
   	   call LOS2Grid(xExtVar,xLosVar,Ptan,Re,p_lowcut,method='Variance')
      ! get output variances after re-sampling, outLosSD is SD at present
         outLosSD%values = 1._r8/outLosSD%values**2 ! converted to 1/variance
         outExtSD%values = xExtVar%values      ! initialized to inversed a priori variance
         call LOS2Grid(outExtSD,outLosSD,Ptan,Re,p_lowcut,method='Variance')
      ! output SD of the retrieved extinction
         outLosSD%values = sqrt(1._r8/outLosSD%values) ! converted back to SD
         outExtSD%values = sqrt(1._r8/outExtSD%values) ! converted back to SD
      ! if the input variance is NOT reduced by half, it is given negative
         where(outExtSD%values**2 > 0.5/xExtVar%values) &   ! xExtVar is inversed
            & outExtSD%values = -outExtSD%values
      end if
   ! clean up
d1976 1
a1976 1
      deallocate(Slevel)
d1981 1
a1981 1
  subroutine LOS2Grid( Qty, LOS,Ptan, Re, Pcut, method)
d1994 3
a1996 2
    character (len=*), intent(in) :: method ! whether for averaging or variance
    type (VectorValue_T), intent(in) :: LOS ! Vector quantity to fill from
d1999 3
a2001 1
    type (VectorValue_T), INTENT(INOUT) :: QTY ! Quantity to fill
d2008 2
a2009 1
    integer, dimension(qty%template%noSurfs,qty%template%noInstances) :: cnt
d2011 1
a2011 1
    real (r8), dimension(qty%template%noSurfs) :: outZeta, phi_out, beta_out
a2013 1
    real (r8), dimension(los%template%noChans,los%template%noSurfs,los%template%noInstances) :: beta
a2026 8
   do maf=1,noMafs
   do mif=1,noMifs
      do i=1,noDepths
         beta(i,mif,maf)=los%values(i+(mif-1)*noDepths,maf)
      end do
   end do
   end do
      
d2028 6
a2033 7
   do j = 1, qty%template%noInstances
   do i = 1, qty%template%noSurfs
!   qty%values(i,j)=qty%template%badValue
   cnt(i,j)=0
   out(i,j)=0._r8
   end do 
   end do
d2064 1
a2064 1
        ! interpolate phi onto standard vertical grids     
d2067 3
a2069 2
        ! interpolate quantity to standard vertical grids      
        y_in = beta(:,mif,maf)
d2072 12
a2083 1
        ! interpolate quantity to standard phi grids
d2087 1
a2087 1
            & (qty%template%phi(1,j)+qty%template%phi(1,j+1))/2. &
d2089 4
a2092 3
            & (qty%template%phi(1,j-1)+qty%template%phi(1,j))/2. ) then
            out(i,j)=out(i,j) + beta_out(i)
            cnt(i,j)=cnt(i,j)+1       !  counter
d2099 7
a2105 2
    if(Capitalize(method(1:1))=="A") where (cnt > 0) qty%values = out/cnt
    if(Capitalize(method(1:1))=="V") where (cnt > 0) qty%values = out
d2107 2
a2108 1
  end subroutine LOS2Grid
d2400 3
@


2.105
log
@Scale the RHS of apriori equations by aprioriScale too!
Cosmetic changes -- LaTeX comments about how Tikhonov and apriori work.
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.104 2001/10/22 22:40:21 livesey Exp $"
d559 2
d598 3
a600 1
      call createEmptyMatrix ( factored%m, 0, state, state )
d602 2
a603 1
      call createEmptyMatrix ( normalEquations%m, 0, state, state )
d1269 1
a1269 1
          call snoop ( key=snoopKey, vectorDatabase=vectorDatabase,&
d1271 2
a1272 3
            & anotherComment=trim(snoopComment) // ': ' // trim(theFlagName) )
          ! Was going to to matrixDatabase, but had a problem with names
          !   matrixDatabase=(/ factored%m, normalEquations%m /)
d2103 4
@


2.104
log
@Tried to add a matrixDatabase to snoop call
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.103 2001/10/22 22:34:47 dwu Exp $"
d601 1
a601 1
      call cloneVector ( v(atb), v(x), vectorNameText='_ATb' )
d846 5
d860 5
a864 3
            call copyVector ( v(atb), v(covarianceXApriori) ) ! A^T b := C (a-x_n)
            if ( got(f_aprioriScale) ) &
              & call scaleMatrix ( normalEquations%m, aprioriScale )
d867 1
a867 1
            call destroyVectorValue ( v(atb) ) ! Clear the RHS vector
d874 4
d882 1
a882 1
              & v(reg_X_x), v(atb), update=update, useMask=.false. )
d891 2
a892 1
          ! Add some early stabilization
d945 1
a945 1
              & rhs_in=v(f_rowScaled), rhs_out=v(atb), update=update, &
d985 1
a985 1
            call multiply ( v(atb), v(columnScaleVector) )
d993 1
a993 1
          call copyVector ( v(gradient), v(atb) ) ! gradient := atb
d1033 1
a1033 1
          call solveCholesky ( factored, v(candidateDX), v(atb), &
d1107 1
a1107 1
          call solveCholesky ( factored, v(candidateDX), v(atb), &
d2099 3
@


2.103
log
@oops
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.102 2001/10/22 22:25:17 dwu Exp $"
d1252 6
a1257 2
          call snoop ( snoopKey, vectorDatabase, v, &
            & trim(snoopComment) // ': ' // trim(theFlagName) )
d2087 3
@


2.102
log
@prepare for high cloud retrieval
@
text
@d32 1
a32 1
    & L_Jacobian_Cols, L_Jacobian_Rows, L_lowcloud, &
d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.101 2001/10/22 20:52:00 dwu Exp $"
d2083 3
@


2.101
log
@renaming some cloud functions
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.100 2001/10/20 17:50:48 livesey Exp $"
d422 2
d2083 3
@


2.100
log
@A little more information on aj%fnmin < 0.0
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.99 2001/10/19 17:42:36 dwu Exp $"
d1649 1
a1649 1
   	call BinFromLOS2Grid(xExtPtr,xLosPtr,Ptan,Re,p_lowcut,method='Average')
d1654 1
a1654 1
   	   call BinFromLOS2Grid(xExtVar,xLosVar,Ptan,Re,p_lowcut,method='Variance')
d1658 1
a1658 1
         call BinFromLOS2Grid(outExtSD,outLosSD,Ptan,Re,p_lowcut,method='Variance')
d1674 2
a1675 2
  !=============================== BinFromLOS2L2GP ====
  subroutine BinFromLOS2Grid( Qty, LOS,Ptan, Re, Pcut, method)
d1789 1
a1789 1
  end subroutine BinFromLOS2Grid
d2081 3
@


2.99
log
@add protection for cloud sensitivity from going to zero
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.98 2001/10/18 23:25:13 dwu Exp $"
d1034 4
d2081 3
@


2.98
log
@rename FillQuantityFromLos to BinFromLOS2Grid
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.97 2001/10/17 23:37:29 pwagner Exp $"
d1533 3
a1535 2
                     if(mif==1) print*,mif,ich,k,sensitivity
                     if(abs(sensitivity) < 10._r8) print*,mif,ich,k,slope%values(1:nFreqs,fmStat%maf)
d2077 3
@


2.97
log
@Improved dump of mask
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.96 2001/10/17 20:50:30 dwu Exp $"
d1434 1
a1434 1
print*,'begin cloud retrieval maf= ',fmstat%maf
d1510 3
a1512 3
                     ! x-> Tcir; x0->teff; 
                     do j=1,nSgrid 
                     x0(j) = 1._r8/nSgrid*(j-1)
d1533 2
a1559 1
         call clearMatrix ( jacobian )  ! free the space
d1637 1
a1637 1

d1644 1
a1644 1
   	call FillQuantityFromLosGrid (xExtPtr,xLosPtr,Ptan,Re,p_lowcut,method='Average')
d1649 1
a1649 1
   	   call FillQuantityFromLosGrid (xExtVar,xLosVar,Ptan,Re,p_lowcut,method='Variance')
d1653 1
a1653 1
         call FillQuantityFromLosGrid (outExtSD,outLosSD,Ptan,Re,p_lowcut,method='Variance')
d1669 2
a1670 2
  !=============================== FillQuantityFromLosGrid ====
  subroutine FillQuantityFromLosGrid ( Qty, LOS,Ptan, Re, Pcut, method)
d1784 1
a1784 2
  end subroutine FillQuantityFromLosGrid

d2076 3
@


2.96
log
@a fix of cloud retrieval
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.95 2001/10/17 19:52:43 dwu Exp $"
d1822 2
d1841 2
d2006 1
d2009 8
d2018 11
d2030 13
d2045 13
a2057 2
          do j=1, min(size(qty%values(:,1)), MAXCOLUMNS)
            if ( IsVectorQtyMasked(qty, j, i) ) maskedMan(j)='1'
d2059 1
a2059 3
          j=min(size(qty%values(:,1)), MAXCOLUMNS)
          call output ( 'column ', advance='no' )
          call output ( i, advance='no' )
d2061 1
a2061 1
          call output ( MaskedMan(1:j), advance='yes' )
d2063 6
d2076 3
@


2.95
log
@Add standard deviation calculation to LowCloudRetrieval
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.94 2001/10/16 23:35:39 pwagner Exp $"
d421 1
a421 1
            call CloudRetrieval
d2024 3
@


2.94
log
@More dumped on msk switch
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.93 2001/10/15 23:21:47 vsnyder Exp $"
d1312 2
a1313 2
    ! ------------------------------------------  CloudRetrieval  -----
    subroutine CloudRetrieval
d1337 2
a1354 1
      integer :: nIterations       ! number of iterations in retrieval
d1356 1
d1372 1
d1378 1
d1380 3
a1383 1
      nIterations = 4
d1388 1
a1388 1
        call cloneVector ( FwdModelOut1, measurements, vectorNameText='_FwdModelOut1' )
d1399 2
a1400 4
        xLosPtr => GetVectorQuantityByType ( state, quantityType=l_lostransfunc, & 
         & noerror=.true. )
        xExtPtr => GetVectorQuantityByType ( state, quantityType=l_cloudextinction, &
         & noerror=.true. )
d1405 1
a1405 1
        sLevel = xLosPtr%template%frequencies                       
d1424 6
a1435 6
          ! allocate C, y, x matrices
          allocate(A(nSgrid,nSgrid),C(nSgrid,nSgrid,nMifs))
          allocate(y(nChans,nMifs),sy(nChans,nMifs))
          allocate(dx(nSgrid,nMifs),x(nSgrid),x0(nSgrid),xext(nSgrid))
          allocate(sx(nSgrid,nMifs))

d1481 1
a1481 1
              ! get x covariance for this signal
d1487 8
d1553 1
a1553 1
                  
a1556 7
               
               do i=1,nSgrid
                 do mif=1,nMifs
                  sx(i,mif) = xLosVar%values(i+nSgrid*(mif-1),fmStat%maf)
                 end do
               end do
                              
d1564 10
d1581 2
a1582 2
               
               do j=1,nIterations
d1590 1
a1590 1
                   A(i,i)=A(i,i) + sx(i,mif)       ! sx has already been inverted
d1593 9
a1601 1
               ! 
d1604 1
a1604 2
                     & (x0*reshape(sx(:,mif),(/nSgrid/)) &
                     & + reshape(dx(:,mif),(/nSgrid/)) ))
d1606 3
d1611 1
a1611 7
               ! output los results to state vector
               if(associated(xLosPtr)) then
               do i=1,nSgrid
                 xLosPtr%values(i+(mif-1)*nSgrid,fmStat%maf) = x(i)
               end do
               end if
               
d1613 1
a1613 1
               xext = 0._r8
d1617 8
a1624 2
                 if(1._r8-trans > 0.004) &
			         & xext(i)=x(i)/(1._r8-trans)/(slevel(i)-slevel(i-1))
d1626 8
d1637 4
a1640 2
            ! deallocate arrays and free memory
            deallocate(A,C,y,sy,dx,x,x0,xext,sx)
d1642 18
a1659 3
          end do ! end of mafs

   	call FillQuantityFromLosGrid (xExtPtr,xLosPtr,Ptan,Re,p_lowcut)
d1666 1
a1666 1
    end subroutine CloudRetrieval
d1669 1
a1669 1
  subroutine FillQuantityFromLosGrid ( Qty, LOS,Ptan, Re, Pcut)
d1680 1
d1682 1
d1723 1
a1723 1
   qty%values(i,j)=qty%template%badValue
d1780 2
a1781 1
     where (cnt > 0) qty%values = out/cnt
d2024 3
@


2.93
log
@Forgot to clone AprioriMinusX after changing multiply not to clone
@
text
@d48 1
a48 1
  use String_Table, only: Get_String
d56 2
a57 1
    & DumpMask, GetVectorQuantityByType, Vector_T, VectorValue_T
d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.92 2001/10/15 22:41:11 vsnyder Exp $"
d1784 2
d1945 4
d1952 12
d1971 3
@


2.92
log
@Put the local (non-l2cf) vectors into a private database of fixed size,
for snooping.  We can't copy them in, because it's a shallow copy, and
we change some pointers later.
@
text
@d71 1
a71 1
       "$Id: RetrievalModule.f90,v 2.91 2001/10/11 16:28:25 dwu Exp $"
d708 2
d872 3
a874 1
            call destroyVectorValue ( v(reg_X_x) )  ! free the space
d1952 5
@


2.91
log
@Add cloudretrieval method for low tangent height radiances
@
text
@d71 1
a71 1
       "$Id: RetrievalModule.f90,v 2.90 2001/10/09 20:39:36 vsnyder Exp $"
a110 1
    type(vector_T) :: F                 ! Residual -- Model - Measurements
d163 22
d204 4
d298 1
a298 2
            call cloneVector ( f, measurements, vectorNameText='_f', &
              & database=myVectors )
d430 1
a430 1
          call copyVector ( fwdModelOut, f )
d448 3
a450 1
    call destroyVectorDatabase ( myVectors )
d533 1
a533 1
        & quantityType=l_dnwt_ajn, noError=.true. )
a561 1
      type(vector_T) :: AprioriMinusX   ! Apriori - X
a562 5
      type(vector_T) :: ATb             ! A^T b -- the RHS of the normal eqns.
      type(vector_T) :: BestGradient    ! for NWT
      type(vector_T) :: BestX           ! for NWT
      type(vector_T) :: CandidateDX     ! for NWT
      type(vector_T) :: ColumnScaleVector ! For column scaling by column norms
a563 4
      type(vector_T) :: CovarianceDiag  ! Diagonal of apriori Covariance
      type(vector_T) :: CovarianceXApriori ! Covariance \times Apriori
      type(vector_T) :: DX              ! for NWT
      type(vector_T) :: DXUnScaled      ! for NWT
a566 1
      type(vector_T) :: F_rowScaled     ! Either a copy of f, or f row-scaled
a567 1
      type(vector_T) :: Gradient        ! for NWT
a574 1
      type(vector_T) :: Reg_X_X         ! Regularization * X_n
a583 2
      type(vector_T) :: Weight          ! Scaling vector for rows, 1/measurementSD
      type(vector_T) :: X               ! for NWT
d597 12
a608 13
      call copyVector ( x, state, vectorNameText='_x', clone=.true., &
        database=myVectors ) ! x := state
      call cloneVector ( atb, x, vectorNameText='_ATb', database=myVectors )
      call cloneVector ( bestGradient, x, vectorNameText='_bestGradient', database=myVectors )
      call cloneVector ( bestX, x, vectorNameText='_bestX', database=myVectors )
      call cloneVector ( candidateDX, x, vectorNameText='_candidateDX', database=myVectors )
      call cloneVector ( covarianceDiag, x, vectorNameText='_covarianceDiag', database=myVectors )
      call cloneVector ( dx, x, vectorNameText='_DX', database=myVectors )
      call cloneVector ( dxUnScaled, x, vectorNameText='_DX Unscaled', database=myVectors )
      call copyVector ( f_rowScaled, measurements, clone=.true., & ! mask only
        & noValues=.true., vectorNameText='_f_rowScaled', database=myVectors )
      call cloneVector ( gradient, x, vectorNameText='_gradient', database=myVectors )
      call cloneVector ( reg_X_x, measurements, vectorNameText='_reg_X_x', database=myVectors )
d610 1
a610 2
        call cloneVector ( weight, measurementSD, vectorNameText='_weight', &
          & database=myVectors )
d613 1
a613 1
            weight%quantities(j)%values = 1.0
d615 1
a615 1
            weight%quantities(j)%values = 1.0 / &
d621 1
a621 2
        call cloneVector ( columnScaleVector, x, vectorNameText='_ColumnScale', &
          & database=myVectors )
d624 2
a625 2
        call cloneVector ( fuzzState, x )
        do j = 1, x%template%noQuantities
d627 1
a627 1
          x%quantities(j)%values = x%quantities(j)%values * &
d631 1
a631 1
        if ( index(switches,'xvec') /= 0 ) call dump ( x, name='Original X' )
d635 2
a636 2
      do k = 1, size(x%quantities)
        aj%axmax = max(aj%axmax, maxval(abs(x%quantities(k)%values)))
d695 1
a695 1
            call cloneVector ( aprioriMinusX, apriori, &
d697 1
a697 1
            aprioriMinusX = apriori - x
d699 1
a699 1
              & call scaleVector ( aprioriMinusX, aprioriScale )
d709 1
a709 1
              call cloneVector ( covarianceDiag, state, &
d711 1
a711 1
              call getDiagonal ( covariance%m, covarianceDiag )
d713 2
a714 2
              call multiply ( covarianceDiag, aprioriMinusX, &
                & covarianceXApriori )
d716 2
a717 2
              call multiply ( covariance, aprioriMinusX, &
                & covarianceXApriori )
d723 1
a723 1
            aprioriNorm = aprioriMinusX .dot. covarianceXapriori
d735 1
a735 1
          call clearVector ( f )
d741 1
a741 1
                & x, fwdModelExtra, f, fmw, fmStat )
d746 3
a748 3
          call subtractFromVector ( f, measurements )
          if ( got(f_measurementSD) ) call multiply ( f, weight )
          aj%fnorm = sqrt ( aprioriNorm + ( f .dot. f ) )
d750 1
a750 1
              & call dump ( f, name='Residual' )
d846 1
a846 1
              call updateDiagonal ( normalEquations, covarianceDiag )
d850 1
a850 1
            call copyVector ( atb, covarianceXApriori ) ! A^T b := C (a-x_n)
d855 1
a855 1
            call destroyVectorValue ( atb ) ! Clear the RHS vector
d863 2
a864 2
            call multiplyMatrixVectorNoT ( jacobian, x, reg_X_x ) ! regularization * x_n
            call scaleVector ( reg_X_x, -regWeight )   ! -R x_n
d866 1
a866 1
              & reg_X_x, atb, update=update, useMask=.false. )
d868 3
a870 3
            call clearMatrix ( jacobian )        ! free the space
            aj%fnorm = aj%fnorm + ( reg_X_x .dot. reg_X_x )
            call destroyVectorValue ( reg_X_x )  ! free the space
d885 1
a885 1
          call clearVector ( f )
d895 1
a895 1
                & x, fwdModelExtra, f_rowScaled, fmw, fmStat, jacobian )
d901 1
a901 1
                call subtractFromVector ( f_rowScaled, measurements, &
d913 1
a913 1
                  call multiply ( f_rowScaled, weight, &
d919 1
a919 1
            call scaleVector ( f_rowScaled, -1.0_r8 ) ! y - f
d921 1
a921 1
            if ( got(f_measurementSD) ) call rowScale ( weight, jacobian )
d926 2
a927 1
              & rhs_in=f_rowScaled, rhs_out=atb, update=update, useMask=.true. )
d937 1
a937 1
          aj%fnorm = aj%fnorm + ( f_rowScaled .dot. f_rowScaled )
d946 1
a946 1
            call copyVector ( columnScaleVector, apriori )
d950 1
a950 1
            call getDiagonal ( normalEquations%m, columnScaleVector )
d953 3
a955 3
            forall (j = 1: columnScaleVector%template%noQuantities)
              where ( columnScaleVector%quantities(j)%values <= 0.0 )
                columnScaleVector%quantities(j)%values = 1.0
d957 2
a958 2
                columnScaleVector%quantities(j)%values = 1.0 / &
                  & sqrt( columnScaleVector%quantities(j)%values )
d962 1
a962 1
                & call dump ( columnScaleVector, name='Column scale vector' )
d964 3
a966 3
            call columnScale ( normalEquations%m, columnScaleVector )
            call rowScale ( columnScaleVector, normalEquations%m )
            call multiply ( atb, columnScaleVector )
d974 1
a974 1
          call copyVector ( gradient, atb ) ! gradient := atb
d976 1
a976 1
              & call dump ( gradient, name='gradient' )
d998 2
a999 2
              call getDiagonal ( factored%m, dxUnscaled )
              call dump ( dxUnscaled, &
d1014 1
a1014 1
          call solveCholesky ( factored, candidateDX, atb, &
d1025 1
a1025 1
          aj%fnmin = aj%fnorm - (candidateDX .dot. candidateDX)
d1034 1
a1034 1
          aj%gradn = sqrt(gradient .dot. gradient) ! L2Norm(gradient)
d1084 1
a1084 1
          call solveCholesky ( factored, candidateDX, atb, &
d1088 5
a1092 5
          aj%fnmin = sqrt(aj%fnorm**2 - (candidateDX .dot. candidateDX) )
          call solveCholesky ( factored, candidateDX )
          aj%dxn = sqrt(candidateDX .dot. candidateDX) ! L2Norm(dx)
          aj%gdx = gradient .dot. candidateDX
          if ( .not. aj%starting ) aj%dxdxl = dx .dot. candidateDX
d1094 1
a1094 1
              & call dump ( candidateDX, name='CandidateDX' )
d1116 1
a1116 1
          if ( .not. aj%starting ) aj%dxdxl = dx .dot. candidateDX
d1120 1
a1120 1
          call copyVector ( dxUnScaled, dx )
d1123 1
a1123 1
            call multiply ( dxUnScaled, columnScaleVector )
d1125 1
a1125 1
          call addToVector ( x, dxUnScaled ) ! x = x + dxUnScaled
d1127 1
a1127 1
              & call dump ( dxUnScaled, name='dX Unscaled' )
d1129 1
a1129 1
              & call dump ( x, name='New X' )
d1132 4
a1135 4
          do j = 1, size(x%quantities)
            aj%axmax = max(aj%axmax, maxval(abs(x%quantities(j)%values)))
            aj%big = aj%big .or. any( abs(dx%quantities(j)%values) > &
              & 10.0 * epsilon(aj%axmax) * abs(x%quantities(j)%values) )
d1155 1
a1155 1
          call copyVector ( x, bestX ) ! x = bestX
d1157 1
a1157 1
          call scaleVector ( bestGradient, aj%gfac, dx )
d1159 1
a1159 1
              & call dump ( dx, name='Gradient move from best X' )
d1166 2
a1167 2
          call copyVector ( bestX, x ) ! bestX = x
          call copyVector ( bestGradient, gradient ) ! bestGradient = gradient
d1173 3
a1175 3
          call subtractFromVector ( dx, candidateDX ) ! dx = dx - candidateDX
          aj%dxdx = dx .dot. dx
          if ( aj%dxdx > 0.0 ) aj%dxdxl = dx .dot. candidateDX
d1177 1
a1177 1
              & call dump ( dx, name='dx after Aitken' )
d1188 1
a1188 1
          call copyVector ( dx, candidateDX ) ! dx = candidateDX
d1191 1
a1191 1
          call scaleVector ( candidateDX, aj%cait, dx )
d1193 1
a1193 1
              & call dump ( dx, name='dx after dx Aitken' )
d1202 1
a1202 1
          if ( nwt_flag == nf_tolx_best ) call copyVector ( x, bestX )
d1241 1
a1241 1
          call snoop ( snoopKey, vectorDatabase, myVectors, &
d1290 1
a1290 1
            call multiply ( outputSD, columnScaleVector )
d1294 1
a1294 1
      call copyVector ( state, x )
a1299 2
      call destroyVectorInfo ( aprioriMinusX )
      if ( got(f_apriori) ) call destroyVectorInfo ( covarianceXApriori )
a1369 1

d1377 1
a1377 1
        call cloneVector ( FwdModelOut1, measurements, vectorNameText='_covarianceDiag' )
d1948 3
@


2.90
log
@Left out a blank on the CVS command line, botched the last comment
@
text
@d71 1
a71 1
       "$Id: RetrievalModule.f90,v 2.89 2001/10/09 20:38:23 vsnyder Exp $"
d396 1
a396 1
            call LowCloudRetrieval
d1300 2
a1301 2
    ! ------------------------------------------  LowCloudRetrieval  -----
    subroutine LowCloudRetrieval
d1305 1
d1307 1
d1319 1
a1319 1
      type (vector_T) :: fwdModelOut1              ! Forward outputs
d1321 4
a1324 2
      type (VectorValue_T), pointer :: xPtr        ! pointer of l_lostransfunc quantity
      type (VectorValue_T), pointer :: xVar        ! variance of apriori
d1328 1
d1333 1
a1333 1
      integer :: i,j,k,ich,imodel,mif          ! Loop subscripts
d1341 1
d1345 1
a1345 1
      type(vector_T) :: CovarianceDiag  ! Diagonal of apriori Covariance
d1347 1
a1347 1
      ! linear retrieval work arrays
d1350 1
a1353 1
      real(r8), dimension(:,:), allocatable :: y_star ! model calculation from x_star
d1355 1
d1357 2
a1358 2
      real(r8), dimension(:), allocatable :: x_star   ! model linearization point for x
      real(r8), dimension(:), allocatable :: x0       ! apriori of x
d1363 5
a1367 3
      ! for temporary test
	p_lowcut = -2.5
print*,'begin cloud retrieval'
a1369 2
      ! create covarianceDiag vector by cloning x
        call cloneVector ( covarianceDiag, state, vectorNameText='_covarianceDiag' )
a1372 3
      ! get the inverted diagnonal elements of covariance of apriori
        call getDiagonal ( covariance%m, covarianceDiag )
        
d1382 4
a1385 1
        xPtr => GetVectorQuantityByType ( state, quantityType=l_lostransfunc )
d1388 3
a1390 1
        nSgrid=xPtr%template%noChans    ! number of S grids                        
d1395 1
a1395 5
          ! Check the model configuration 
          if ( size (configDatabase(configIndices(imodel))%signals ) /= 1 )    &
          & call MLSMessage ( MLSMSG_Error, ModuleName,      &
          & 'Cannot call the full cloud forward model with multiple signals' )
               
d1397 3
a1399 2
          & count(configDatabase(configIndices(imodel))%signals(1)%channels)
        end do ! configIndices
d1402 1
a1402 1
         nMifs = measurements%quantities(1)%template%noSurfs
d1404 5
d1411 3
a1413 2
          do while (fmStat%maf < chunk%lastMAFIndex-chunk%firstMAFIndex+1)
            fmStat%maf = fmStat%maf + 1
d1415 11
a1425 11
            ! allocate C, y, x matrices
            allocate(A(nSgrid,nSgrid),C(nSgrid,nSgrid,nMifs))
            allocate(y(nChans,nMifs),y_star(nChans,nMifs),sy(nChans,nMifs))
            allocate(dx(nSgrid,nMifs),x(nSgrid),x0(nSgrid),x_star(nSgrid))
            allocate(sx(nSgrid,nMifs))

            A = 0._r8
            C = 0._r8
            y = 0._r8
            sy = 0._r8
            dx = 0._r8
d1427 4
a1430 3
            ich = 0
            do imodel = 1, size(configIndices)
              call forwardModel ( configDatabase(configIndices(imodel)), &
d1433 1
a1433 3
              ! nullify pointers (don't need here)
              ! nullify(Tb0, ptan, slope, Tcir, Terr, xVar)
              
d1435 1
a1435 1
              signal = configDatabase(configIndices(imodel))%signals(1)
d1447 4
d1467 4
a1470 3
               xVar => GetVectorQuantityByType (covarianceDiag, &
               & quantityType=l_lostransfunc,                &
               & signal=signal%index, sideband=signal%sideband )
d1474 1
a1474 1
              colJBlock = FindBlock ( Jacobian%col, ptan%index, fmStat%maf )
d1509 1
d1513 2
a1514 1
                     ! convert cloud radiance to effective optical depth                     
a1515 1
                     y_star(ich,mif) = 0._r8
d1518 1
a1518 1
                       
d1521 1
a1521 1
                           & (y(ich,mif)-y_star(ich,mif))/sy(ich,mif)
d1525 1
d1533 1
d1537 1
a1537 1
                  sx(i,mif) = xVar%values(i+nFreqs*(mif-1),fmStat%maf)
d1541 3
a1543 1
            end do         ! end of imodel
a1544 1
            call clearMatrix ( jacobian )  ! free the space
d1546 1
a1546 1
            if(ich /= nChans) print*,'inconsistent channels between Jacobian and Signal'
a1547 1
print*,'start inversion'
d1552 2
a1553 1
               x0 = 0._r8
d1555 8
a1562 2
               x_star = 0._r8
               A = reshape(C(:,:,mif),(/nSgrid,nSgrid/))
d1564 1
a1564 1
                  A(i,i)=A(i,i)+1._r8*sx(i,mif)       ! sx has already been inverted
d1566 1
a1566 1
               Call MatrixInversion(A)
d1568 9
d1578 1
a1578 3
               x(i) = sum( reshape(A(i,:),(/nSgrid/))* &
                  & ((x0-x_star)*reshape(sx(:,mif),(/nSgrid/)) &
                  & + reshape(dx(:,mif),(/nSgrid/)) ))
d1580 1
d1582 7
a1588 3
               ! give the results to state vector
               do i=1,nSgrid
               xPtr%values(i+(mif-1)*nSgrid,fmStat%maf) = x(i)
d1594 1
a1594 1
            deallocate(A,C,y,y_star,sy,dx,x,x0,x_star,sx)
d1598 1
d1601 1
a1601 1
      call destroyVectorInfo ( CovarianceDiag)
d1603 1
d1605 113
a1717 1
    end subroutine LowCloudRetrieval
d1719 1
d1942 3
@


2.89
log
@Corrections for regularization; output f, not f-measurementsRetrievalModule.f90
@
text
@d71 1
a71 1
       "$Id: RetrievalModule.f90,v 2.88 2001/10/05 20:50:16 vsnyder Exp $"
d1789 3
@


2.88
log
@Concatenate Snoop comment and DNWT flag; clear F before EVAL[FJ]
@
text
@d39 1
a39 1
    & Matrix_SPD_T
d54 3
a56 3
  use VectorsModule, only: AddVectorToDatabase, ClearVector, CloneVector, &
    & CopyVector, DestroyVectorInfo, DestroyVectorDatabase, DumpMask, &
    & GetVectorQuantityByType, Vector_T, VectorValue_T
d71 1
a71 1
       "$Id: RetrievalModule.f90,v 2.87 2001/10/05 20:20:16 vsnyder Exp $"
d405 4
a408 1
        if ( got(f_fwdModelOut) ) call copyVector ( fwdModelOut, f )
d452 1
a452 1
        call output ( ' appears, but the other is not.', advance='yes' )
d598 1
a598 1
      call cloneVector ( reg_X_x, x, vectorNameText='_reg_X_x', database=myVectors )
d855 1
a855 1
            call multiply ( jacobian, x, reg_X_x ) ! regularization * x_n
d1317 1
a1317 1
      type (vector_T) :: FwdModelOut1               ! Forward outputs
d1356 1
a1356 1
	! for temporary test
d1789 3
@


2.87
log
@Put Nwt_Flag into Snoop's comment; add Dnwt_Flag to diagnostics vector
@
text
@d48 1
d54 2
a55 2
  use VectorsModule, only: AddVectorToDatabase, CloneVector, CopyVector, &
    & DestroyVectorInfo, DestroyVectorDatabase, DumpMask, &
d71 1
a71 1
       "$Id: RetrievalModule.f90,v 2.86 2001/10/05 05:02:27 dwu Exp $"
d146 1
d179 1
d215 1
a215 1
            ! Processed by snoop
d724 1
d874 1
d1229 2
a1230 1
          call snoop ( snoopKey, vectorDatabase, myVectors, theFlagName )
d1786 3
@


2.86
log
@temporarily set p_lowcut in LowCloud Retrieval
@
text
@d29 1
a29 1
    & L_dnwt_dxn,  L_dnwt_dxnl,  L_dnwt_fnmin, &
d70 1
a70 1
       "$Id: RetrievalModule.f90,v 2.85 2001/10/05 01:46:25 vsnyder Exp $"
d208 1
d1213 1
d1222 4
a1225 2
        if ( snoopKey /= 0 .and. snoopLevel >= snoopLevels(nwt_flag) ) &
          & call snoop ( key, vectorDatabase, myVectors )
d1780 3
@


2.85
log
@Put in stuff to snoop in the Newtonian iteration loop
@
text
@d70 1
a70 1
       "$Id: RetrievalModule.f90,v 2.84 2001/10/04 01:48:59 vsnyder Exp $"
d1343 2
a1344 1

d1776 3
@


2.84
log
@Move temporary vectors into 'myVectors' database, for snooping
@
text
@d19 6
a24 6
    & F_columnScale, F_covariance, F_diagnostics, F_diagonal, F_forwardModel, &
    & F_fuzz, F_fwdModelExtra, F_fwdModelOut, F_height, F_ignore, F_jacobian, &
    & F_lambda, F_maxF, F_maxJ, F_measurements, F_measurementSD, F_method, &
    & F_opticalDepth, F_outputCovariance, F_outputSD, F_ptanQuantity, &
    & F_quantity, F_regOrders, F_regQuants, F_regWeight, F_state, &
    & F_toleranceA, F_toleranceF, F_toleranceR, &
d26 11
a36 5
    & L_apriori, L_covariance, L_newtonian, L_lowcloud, &
    & L_none, L_norm, L_pressure, L_zeta, &
    & S_dumpBlocks, S_forwardModel, S_sids, S_matrix, S_subset, S_retrieve, &
    & S_time
  use Intrinsic, only: L_Jacobian_Cols, L_Jacobian_Rows, PHYQ_Dimensionless
d47 1
d70 1
a70 1
       "$Id: RetrievalModule.f90,v 2.83 2001/10/04 00:30:34 dwu Exp $"
d79 2
a80 1
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, ConfigDatabase, chunk )
d89 1
a89 1
    type(vector_T), dimension(:), intent(inout), target :: VectorDatabase
a108 2
    type(vectorValue_T), pointer :: DOF_Qty  ! Degrees of freedom quantity in
                                        ! Diagnostics vector
a123 1
    type(vectorValue_T), pointer :: Jac_Col_Qty   ! To output Jacobian_Cols
a125 1
    type(vectorValue_T), pointer :: Jac_Row_Qty   ! To output Jacobian_Rows
d145 2
d177 2
d205 14
d489 15
d557 5
d639 1
a639 1
        end if
d1203 19
a1228 4
          jac_col_qty => GetVectorQuantityByType ( diagnostics, &
            & quantityType=l_jacobian_cols, noError=.true. )
          jac_row_qty => GetVectorQuantityByType ( diagnostics, &
            & quantityType=l_jacobian_rows, noError=.true. )
d1240 2
a1241 2
          if ( associated(jac_col_qty) ) jac_col_qty%values(1,1) = jacobian_cols
          if ( associated(jac_row_qty) ) jac_row_qty%values(1,1) = jacobian_rows
d1775 3
@


2.83
log
@fix coljBlock finding in Low Cloud
@
text
@d46 3
a48 2
  use VectorsModule, only: CloneVector, CopyVector, DestroyVectorInfo, &
    & DumpMask, GetVectorQuantityByType, Vector_T, VectorValue_T
d63 1
a63 1
       "$Id: RetrievalModule.f90,v 2.82 2001/10/03 23:56:30 dwu Exp $"
d134 2
a135 1
    type(matrix_SPD_T), pointer :: OutputCovariance   ! Covariance of the sol'n
d170 1
a170 1
    nullify ( measurements, measurementSD, state, outputSD )
d247 2
a379 1
        call destroyVectorInfo ( f )
d395 2
d537 13
a549 13
      call cloneVector ( x, state, vectorNameText='_x' )
      call copyVector ( x, state ) ! x := state
      call cloneVector ( atb, state, vectorNameText='_ATb' )
      call cloneVector ( reg_X_x, state, vectorNameText='_reg_X_x' )
      call cloneVector ( f, measurements, vectorNameText='_f' )
      call cloneVector ( f_rowScaled, measurements, vectorNameText='_f_rowScaled' )
      call copyVector ( f_rowScaled, measurements, noValues=.true. ) ! mask only
      call cloneVector ( bestGradient, x, vectorNameText='_bestGradient' )
      call cloneVector ( bestX, x, vectorNameText='_bestX' )
      call cloneVector ( candidateDX, x, vectorNameText='_candidateDX' )
      call cloneVector ( dx, x, vectorNameText='_DX' )
      call cloneVector ( dxUnScaled, x, vectorNameText='_DX Unscaled' )
      call cloneVector ( gradient, x, vectorNameText='_gradient' )
d551 2
a552 1
        call cloneVector ( weight, measurementSD )
d563 2
a564 1
        call cloneVector ( columnScaleVector, x, vectorNameText='_ColumnScale' )
d1218 4
a1221 8
      ! Clean up the temporaries, so we don't have a memory leak
      call destroyVectorInfo ( atb )
      call destroyVectorInfo ( bestGradient )
      call destroyVectorInfo ( bestX )
      call destroyVectorInfo ( candidateDX )
      if ( columnScaling /= l_none ) &
        & call destroyVectorInfo ( columnScaleVector )
      if ( diagonal ) call destroyVectorInfo ( covarianceDiag )
a1222 3
      call destroyVectorInfo ( dx )
      call destroyVectorInfo ( dxUnscaled )
      call destroyVectorInfo ( f_rowScaled )
a1223 4
      call destroyVectorInfo ( gradient )
      if ( got(f_measurementSD) ) call destroyVectorInfo ( weight )
      call destroyVectorInfo ( x )
      call destroyVectorInfo ( aprioriMinusX )
d1718 3
@


2.82
log
@some minor fixes for Low Cloud
@
text
@d62 1
a62 1
       "$Id: RetrievalModule.f90,v 2.81 2001/10/03 22:05:12 dwu Exp $"
d1251 1
a1251 1
      type (vector_T) :: FwdModelOut               ! Forward outputs
d1292 2
d1296 2
a1334 1
            fmstat%rows = .false.
d1351 1
a1351 1
                & state, fwdModelExtra, FwdModelOut, fmw, fmStat, jacobian )
d1360 1
a1360 1
              Tb0 => GetVectorQuantityByType ( fwdModelOut,                 &
d1370 1
a1370 1
              Slope => GetVectorQuantityByType ( fwdModelOut,      &
d1391 1
a1391 6

              colJBlock = 0
              do while (colJBlock <= jacobian%col%nb .and. &
                  jacobian%col%inst(colJBlock) /= fmStat%maf)
                  colJBlock = colJBlock +1 
              end do
d1494 1
a1494 1
      call destroyVectorInfo ( FwdModelOut )
d1496 1
d1722 3
@


2.81
log
@some quick remedies for LowcloudRetrieval
@
text
@d62 1
a62 1
       "$Id: RetrievalModule.f90,v 2.80 2001/10/03 21:49:54 dwu Exp $"
d364 2
a365 2
            call add_to_retrieval_timing( 'low_cloud', t1 )
            call cpu_time ( t1 )
d645 2
d1291 4
a1294 1
          
d1463 1
d1497 1
d1723 3
@


2.80
log
@some quick remedies for LowcloudRetrieval
@
text
@d62 1
a62 1
       "$Id: RetrievalModule.f90,v 2.79 2001/10/03 21:30:16 dwu Exp $"
d1290 1
a1290 1
      ! get diagnonal elements of covariance of apriori
d1467 1
a1467 1
                  A(i,i)=A(i,i)+1._r8/sx(i,mif)
d1473 1
a1473 1
                  & ((x0-x_star)/reshape(sx(:,mif),(/nSgrid/)) &
d1716 3
@


2.79
log
@add LowCloudRetrieval
@
text
@d62 1
a62 1
       "$Id: RetrievalModule.f90,v 2.78 2001/10/03 17:57:21 vsnyder Exp $"
d366 1
a366 2
          ! call LowCloudRetrieval
            print*,'to be added'
d1716 3
@


2.78
log
@Delete l_DegreesOfFreedom, add l-DNWT_...
@
text
@d62 1
a62 1
       "$Id: RetrievalModule.f90,v 2.77 2001/10/02 23:41:11 vsnyder Exp $"
d1233 262
d1717 3
@


2.77
log
@Added computation of degrees of freedom, diagnostics vector
@
text
@d30 1
a30 1
  use Intrinsic, only: L_DegreesOfFreedom, PHYQ_Dimensionless
d62 1
a62 1
       "$Id: RetrievalModule.f90,v 2.76 2001/10/02 16:49:56 livesey Exp $"
a92 6
    integer :: DegreesOfFreedom         ! (Rows - Columns) of Jacobian
                                        ! This includes all of the columns, but
                                        ! excludes masked-out rows, because we
                                        ! don't mask out columns of the apriori
                                        ! or the regularization.  If we did, the
                                        ! normal equations would be singular.
d94 1
a94 1
                                        ! retrieval -- e.g. degrees of freedom.
d116 5
d357 2
a358 1
          degreesOfFreedom = 0
a1154 4
        ! Compute degrees of freedom = (Rows of Jacobian actually used) -
        ! (Columns of Jacobian).  Don't count rows due to Levenberg-
        ! Marquardt stabilization.  Do count rows due to a priori or
        ! regularization.
d1156 10
a1165 3
          dof_qty => GetVectorQuantityByType ( diagnostics, &
            & quantityType=l_degreesOfFreedom )
          degreesOfFreedom = sum(normalEquations%m%row%nelts)
d1168 1
a1168 1
              & degreesOfFreedom = degreesOfFreedom - &
d1172 5
a1176 4
            & degreesOfFreedom = degreesOfFreedom + sum(normalEquations%m%col%nelts)
          if ( .not. got(f_regOrders) ) &
            & degreesOfFreedom = degreesOfFreedom - sum(normalEquations%m%col%nelts)
          dof_qty%values(1,1) = degreesOfFreedom
d1455 3
@


2.76
log
@Removed fmStat%finished and change loop ordering in forward models
@
text
@a12 1
use Dump_0, only: Dump
d14 2
d19 1
a19 1
    & F_columnScale, F_covariance, F_diagonal, F_forwardModel, &
d30 1
a30 1
  use Intrinsic, only: PHYQ_Dimensionless
d47 1
a47 1
    & Vector_T, DumpMask
d62 1
a62 1
       "$Id: RetrievalModule.f90,v 2.75 2001/10/01 23:30:50 pwagner Exp $"
d93 8
d106 2
d228 2
d358 1
d1155 19
d1181 5
a1185 1
        ! Commented out, pending deep thought.!???
d1197 1
a1197 1
          call GetDiagonal ( outputCovariance%m, outputSD, SquareRoot = .true. )
d1451 3
@


2.75
log
@Fixed bug in spelling cholesky_solver
@
text
@d34 1
a34 1
  use MLSCommon, only: R8
d61 1
a61 1
       "$Id: RetrievalModule.f90,v 2.74 2001/10/01 23:04:17 livesey Exp $"
d70 1
a70 1
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, ConfigDatabase )
d83 2
d369 1
a369 1
        call sids ( key, VectorDatabase, MatrixDatabase, configDatabase)
a650 1
          fmStat%newHydros = .true.
a652 1
          fmStat%finished = .false.
d657 1
a657 3
          do while (.not. fmStat%finished )
            !??? What if one config set finished but others still had
            !??? more to do? Ermmm, think of this next time.
a801 2
          fmStat%finished = .false.
          fmStat%newHydros = .true.
d805 1
a805 1
          do while ( .not. fmStat%finished )
d1414 3
@


2.74
log
@Bug fix with channel range, and some tidying up
@
text
@d61 1
a61 1
       "$Id: RetrievalModule.f90,v 2.73 2001/10/01 22:54:22 pwagner Exp $"
d938 1
a938 1
          call add_to_retrieval_timing( 'cholesky_solve', t1 )
d1008 1
a1008 1
          call add_to_retrieval_timing( 'cholesky_solve', t1 )
d1418 3
@


2.73
log
@Added subsection timings for Retrieval section
@
text
@d61 1
a61 1
       "$Id: RetrievalModule.f90,v 2.71 2001/09/29 00:07:11 pwagner Exp $"
a1291 1
              channels ( nint(value(1)) ) = .true.
d1293 2
d1364 4
a1367 4
              end do
            end if
          end do
        end if
d1397 10
a1406 10
                end do
              end if
            end do
          end do
        end if
     end do

    ! Tidy up
    call Deallocate_test ( channels, 'channels', ModuleName )

d1418 3
@


2.72
log
@Insert a reminder for necessary future work
@
text
@d35 1
a35 1
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
d345 1
d348 2
d365 2
d500 1
d505 1
d577 2
d654 2
d666 2
d810 2
d820 2
d913 2
d917 2
d934 2
d938 2
d986 2
d989 2
d1004 2
d1008 2
d1154 2
d1157 2
d1160 2
d1193 2
d1417 3
@


2.71
log
@Fixed various timing problems
@
text
@d61 1
a61 1
       "$Id: RetrievalModule.f90,v 2.70 2001/09/28 18:25:37 dwu Exp $"
d1318 2
d1351 2
d1376 3
@


2.70
log
@prepare for adding lowcloud retrieval method
@
text
@d61 1
a61 1
       "$Id: RetrievalModule.f90,v 2.69 2001/09/28 17:50:30 pwagner Exp $"
d158 1
d1372 3
@


2.69
log
@MLSL2Timings module keeps timing info
@
text
@d25 2
a26 1
    & L_apriori, L_covariance, L_newtonian, L_none, L_norm, L_pressure, L_zeta, &
d61 1
a61 1
       "$Id: RetrievalModule.f90,v 2.68 2001/09/27 20:14:50 vsnyder Exp $"
d345 3
d1371 3
@


2.68
log
@Add 'msk' switch to control printing the mask after a Subset
@
text
@d34 1
d37 1
a37 1
  use Output_M, only: Output
d60 1
a60 1
       "$Id: RetrievalModule.f90,v 2.67 2001/09/27 18:40:26 vsnyder Exp $"
d156 1
a156 1
    timing = .false.
d1154 5
d1367 3
@


2.67
log
@Explicitly control mask use for FormNormalEquations
@
text
@d59 1
a59 1
       "$Id: RetrievalModule.f90,v 2.66 2001/09/26 02:15:40 vsnyder Exp $"
d1350 5
a1354 1
call dump ( qty%mask, format='(1x,z8.8)' )
d1361 3
@


2.66
log
@More work on checking the Subset command
@
text
@d59 1
a59 1
       "$Id: RetrievalModule.f90,v 2.65 2001/09/25 23:04:30 livesey Exp $"
d769 2
a770 1
              & reg_X_x, atb, update=update )
d826 1
a826 1
              & rhs_in=f_rowScaled, rhs_out=atb, update=update )
d1357 3
@


2.65
log
@Fixed uninitialised heightUnit
@
text
@d13 1
d59 1
a59 1
       "$Id: RetrievalModule.f90,v 2.64 2001/09/25 20:42:55 vsnyder Exp $"
d146 2
a147 1
    integer, parameter :: NoFields = Inconsistent + 1  ! No fields are allowed
d150 1
a150 2
    integer, parameter :: Unitless = OrderAndWeight + 1
    integer, parameter :: WrongUnits = Unitless + 1
d246 1
a246 1
              & call announceError ( unitless, field )
d419 4
a426 4
      case ( unitless )
        call output ( 'The value of the ' )
        call display_string ( field_indices(fieldIndex) )
        call output ( ' field shall be unitless', advance='yes' )
d428 1
a428 1
        call output ( 'The units of the ' )
d430 3
a432 2
        call output ( ' field shall be ' )
        call output ( trim(string), advance='yes' )
d915 8
a922 1
          aj%fnmin = sqrt(aj%fnorm - (candidateDX .dot. candidateDX) )
d1228 1
a1228 1
      ! Now deal with the channels and heights fields
d1236 3
a1238 4
            select case ( type )
            case ( num_value )
              if ( units(1) /= phyq_dimensionless ) &
                & call announceError ( unitless, f_channels )
d1240 1
a1240 9
            case ( range )
              if ( any ( units /= phyq_dimensionless ) ) &
                & call announceError ( unitless, f_channels )
              channels ( nint(value(1)):nint(value(2)) ) = .true.
            case default
              ! Shouldn't get here if the type checker worked.
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unrecognised type for channels' )
            end select
d1247 1
a1247 2
      ! Now preprocess the height stuff.  The type checker verifies the
      ! consistency of units of ranges.
d1253 9
d1263 6
a1268 1
            if ( heightUnit == phyq_dimensionless ) heightUnit = units(i)
d1271 7
a1277 2
        if ( .not. any ( heightUnit == (/ phyq_pressure, phyq_length /) ) ) &
          & call announceError ( wrongUnits, f_height, &
d1279 1
a1279 5

        ! Now one final check over all the things we've been asked to do.
        if ( heightUnit == phyq_pressure .and. qty%template%minorFrame .and. &
          & .not. got(f_ptanQuantity) ) call announceError ( ifUnitsAThenB, &
            & f_height, f_ptanQuantity, 'pressure' )
d1341 1
a1341 1
            enddo
d1349 1
d1356 3
@


2.64
log
@Spiffify error processing for Subset
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.63 2001/09/25 17:49:59 livesey Exp $"
d1249 1
a1251 1
        heightUnit = phyq_dimensionless
d1341 3
@


2.63
log
@More updates, and fixes to subset
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.62 2001/09/25 05:57:36 livesey Exp $"
d143 2
a144 1
    integer, parameter :: Inconsistent = IfAThenB + 1  ! Inconsistent fields
d149 1
d371 1
a371 1
    subroutine AnnounceError ( Code, FieldIndex, AnotherFieldIndex )
d379 1
d395 1
a395 1
        call output ( ' field appears then the field ' )
d397 9
a405 5
        call output ( ' shall also appear.', advance='yes' )
      case ( noFields )
        call output ( 'No fields are allowed for a ' )
        call display_string ( spec_indices(fieldIndex) )
        call output ( ' specification.', advance='yes' )
d418 4
d425 6
a430 1
        call output ( ' field shall be unitless' )
d1169 1
d1230 1
a1230 2
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Invalid unit for channel' )
d1234 1
a1234 2
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Invalid unit for channel range' )
d1237 1
d1247 2
a1248 1
      ! Now deal with the height stuff, at least preprocess it.
d1250 1
d1254 3
a1256 12
          if ( type /= range ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Only allow range for height' )
          if ( units(1) /= units(2) .and. .not. any(units == phyq_dimensionless) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Conflicting units for height' )
          if ( heightUnit == phyq_dimensionless ) then
            heightUnit = units(1)
          else 
            if ( heightUnit /= units(1) ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Conflicting units for height' )
          end if
d1259 2
a1260 2
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Height must be either length or pressure.' )
d1264 2
a1265 2
          & .not. got(f_ptanQuantity) ) call MLSMessage ( MLSMSG_Error, &
          & ModuleName, 'must supply ptan for this subset if using pressure' )
a1267 4
      if ( got(f_height) .and. ignore ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Can't set both height and ignore fields" )

d1341 3
@


2.62
log
@Removed call to destroyVectorMask, and the erroneous .not. doThis
@
text
@d43 1
a43 1
    & Vector_T
d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.61 2001/09/25 00:49:59 vsnyder Exp $"
a417 21
    ! -------------------------------------------------  DumpMask  -----
    subroutine DumpMask ( mask, n )
      integer, intent(in), dimension(:) :: MASK
      integer, intent(in) :: N
   
      ! Local variables
      integer :: I
      integer :: B

      ! Executable code
      b = bit_size (mask)
      do i = 1, n
        if ( btest(mask(i/b+1), mod (i,b) ) ) then
          call output ( '1' )
        else
          call output ( '0' )
        end if
      end do
      call output ( '', advance='yes' )
    end subroutine DumpMask

d1336 3
@


2.61
log
@Copy mask from measurements to f_rowScaled
@
text
@d43 1
a43 1
    & DestroyVectorMask, Vector_T
d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.60 2001/09/25 00:18:36 livesey Exp $"
a350 4
        ! Clear the masks of every vector
        do j = 1, size(vectorDatabase)
          call destroyVectorMask ( vectorDatabase(i) )
        end do
d568 1
a568 1
          if ( nwt_flag /= nf_start .and. index(switches,'ndb') /= 0 ) &
d1306 1
a1306 1
            if ( .not. doThis ) then
d1357 3
@


2.60
log
@Bug fix in Subset
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.59 2001/09/20 00:31:06 vsnyder Exp $"
d516 2
a517 1
      call cloneVector ( f_rowScaled, f, vectorNameText='_f_rowScaled' )
d1361 3
@


2.59
log
@Move deallocation of 'channels' out of loop
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.58 2001/07/19 22:00:41 vsnyder Exp $"
d1309 1
a1309 1
            if ( doThis ) then
d1360 3
@


2.58
log
@orrect problems with row scaling.
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.57 2001/07/12 22:18:05 livesey Exp $"
d1279 2
a1280 2
          & .not. got(f_ptanQuantity) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'must supply ptan for this subset if using pressure' )
d1315 1
a1315 1
          enddo
d1349 1
d1351 2
a1352 4
        ! Tidy up
        if ( associated ( channels ) ) &
          & call Deallocate_test ( channels, 'channels', ModuleName )
      end do
d1360 3
@


2.57
log
@Got rid of an old diagnostic
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.56 2001/07/12 22:11:46 vsnyder Exp $"
d468 1
d483 1
d486 1
a498 1
      type(vector_T) :: XminusApriori   ! X - Apriori
d516 1
d605 1
a605 1
            ! xMinusApriori (if any), so as not to have a memory
d607 5
a611 3
            call cloneVector ( xMinusApriori, apriori, &
              & vectorNameText='_xMinusApriori' )
            xMinusApriori = x - apriori
d623 1
a623 1
              call multiply ( xMinusApriori, covarianceDiag, &
d626 1
a626 1
              call multiply ( covariance, xMinusApriori, &
d631 3
a633 3
            ! that is due to apriori is $( a - x_n )^T F^T F ( a - x_n )
            ! = ( a - x_n )^T C ( a - x_n )$
            aprioriNorm = xMinusApriori .dot. covarianceXapriori
d723 2
a724 2
        ! Triangularize ${\bf J}$, and compute (negative of the) gradient =
        ! $-{\bf J^T f}$.  This is the RHS of the normal equations
a754 1
              call getDiagonal ( covariance%m, covarianceDiag )
d759 3
a761 5
            call copyVector ( atb, covarianceXApriori )
            if ( got(f_aprioriScale) ) then
              call scaleMatrix ( normalEquations%m, aprioriScale )
              call scaleVector ( atb, aprioriScale )
            end if
a764 1
            aprioriNorm = 0.0_r8
d766 1
d772 2
a773 2
            call multiply ( jacobian, x, reg_X_x ) ! regularization * x
            call scaleVector ( reg_X_x, -regWeight )
d802 1
a802 1
                & x, fwdModelExtra, f, fmw, fmStat, jacobian )
d806 16
a821 3
                call subtractFromVector ( f, measurements, &
                  & jacobian%row%quant(rowBlock), &
                  & jacobian%row%inst(rowBlock) )
d824 6
a829 14
            call scaleVector ( f, -1.0_r8 )
            !{Let ${\bf J}$ be the Jacobian matrix and ${\bf f}$ be the
            ! residual of the least-squares problem.  Let $W$ be the
            ! inverse of the measurement covariance (which in our case
            ! is diagonal). Row scale the part of the least-squares
            ! problem that arises from the measurements, i.e. the
            ! least-squares problem becomes $\mathbf{W J = W f}$.
            if ( got(f_measurementSD) ) then
              call rowScale ( weight, jacobian )
              call multiply ( f, weight )
            end if
            aj%fnorm = aj%fnorm + ( f .dot. f )
            !{Form normal equations: $\mathbf{J^T W^T W J \delta \hat x =
            ! J^T W^T f}$:
d831 1
a831 1
              & f, atb, update=update )
a838 1
!           call destroyVectorValue ( f )  ! free the space
d841 2
d846 2
a847 2
          ! scaling, the problem is $\mathbf{J^T W^T W J \Sigma^{-1} \Sigma
          ! \delta \hat x = J^T W^T f}$.
d856 2
a857 2
          if ( columnScaling /= l_none ) then
            do j = 1, columnScaleVector%template%noQuantities
d864 1
a864 1
            end do
d867 1
d871 1
d914 7
a920 5
          ! AJ%FNMIN = L2 norm of residual, ||F + J * "Candidate DX"||
          ! This can be gotten without saving J as F^T F - (U^{-T} F)^T
          ! U^{-T} F.  The variable candidateDX is a temp here.
          if ( columnScaling /= l_none ) &
            & call multiply ( candidateDX, columnScaleVector )
d932 2
a933 2
        ! \Sigma^{-1} + \lambda^2 I) \Sigma \delta \hat x = J^T W^T
        ! f}$ for $\mathbf{\Sigma \delta \hat x}$.  Set
a992 2
          if ( columnScaling /= l_none ) &
            & call multiply ( candidateDX, columnScaleVector )
d998 3
a1000 3
          !{Account for column scaling.  We solved for $\Sigma \delta x$
          ! above, so multiply by $\Sigma^{-1}$ (which is our variable
          ! {\tt columnScaleVector}):
d1137 1
d1142 1
a1142 1
      call destroyVectorInfo ( xMinusApriori )
d1361 3
@


2.56
log
@Maybe the column scaling is right now....
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.55 2001/07/11 22:06:31 vsnyder Exp $"
a1337 2
        print*,'Mask:'
        call DumpMask ( qty%mask(:,instance), qty%template%instanceLen )
d1350 3
@


2.55
log
@Interim commit -- still appears to be broken
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.54 2001/07/02 17:21:48 livesey Exp $"
d861 1
d907 2
d981 2
d1352 3
@


2.54
log
@Fixed memory leak with channels.
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.53 2001/06/30 03:10:35 vsnyder Exp $"
a91 2
    logical :: DiagonalOut              ! "We only want the diagonal of the
                                        ! a posteriori covariance matrix"
a137 1
    type(vector_T) :: Weight            ! Scaling vector for rows, 1/measurementSD
a289 9
            call cloneVector ( weight, measurementSD )
            do j = 1, measurementSD%template%noQuantities
              where ( measurementSD%quantities(j)%values <= 0.0 )
                weight%quantities(j)%values = 1.0
              elsewhere
                weight%quantities(j)%values = 1.0 / &
                  & measurementSD%quantities(j)%values
              end where
            end do
d494 1
d520 11
d809 1
a809 1
            aj%fnorm = aj%fnorm + ( f .dot. f )
d816 5
a820 1
            if ( got(f_measurementSD) ) call rowScale ( weight, jacobian )
d901 1
a901 1
          call solveCholesky ( factored, atb, candidateDX, &
d952 1
a952 1
          call solveCholesky ( factored, atb, candidateDX, &
d1112 1
d1118 2
d1124 1
d1126 1
d1347 3
@


2.53
log
@Don't access sub_rosa(0) when creating a covariance matrix
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.52 2001/06/30 03:07:43 vsnyder Exp $"
d1326 4
d1338 3
@


2.52
log
@Remove some unused variables.  Move some more internal-subroutine-peculiar
USEs into them.  Don't access sub_rosa(0) when creating a Jacobian.
@
text
@d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.51 2001/06/30 02:35:43 vsnyder Exp $"
d328 2
a329 2
              call createEmptyMatrix ( myCovariance%m, sub_rosa(k), &
                &                      state, state )
d1334 4
@


2.51
log
@Don't use the "extra" column to solve for the residual.  Move the Newtonian
solver, and its variables and USEs, into an internal subroutine.  Move USEs
peculiar to SetupSubset into that routine.
@
text
@a13 1
  use Dump_0, only: Dump
d17 1
a17 1
    & F_criteria, F_columnScale, F_covariance, F_diagonal, F_forwardModel, &
d21 1
a21 1
    & F_quantity, F_regOrders, F_regQuants, F_regWeight, F_state, F_test, &
d27 1
a27 3
  use Intrinsic, only: Field_indices, PHYQ_Dimensionless, &
    & PHYQ_LENGTH, PHYQ_PRESSURE, PHYQ_ZETA, Spec_indices
  use Lexer_Core, only: Print_Source
a35 1
  use String_Table, only: Display_String
d43 1
a43 1
    & DestroyVectorMask, Dump, Vector_T
d58 1
a58 1
       "$Id: RetrievalModule.f90,v 2.50 2001/06/27 04:31:29 livesey Exp $"
a82 2
    integer :: Channels                 ! Index in tree of "channels" field
                                        ! of subset specification, or zero
a86 2
    integer :: Criteria                 ! Index in tree of "criteria" field
                                        ! of subset specification, or zero
a121 2
    integer :: Quantity                 ! Index in tree of "quantity" field
                                        ! of subset specification, or zero
a128 2
    integer :: Test                     ! Index in tree of "test" field
                                        ! of subset specification, or zero
d310 2
a311 2
              call createEmptyMatrix ( myJacobian, sub_rosa(k), measurements, &
                & state )
d386 5
d462 1
d475 1
a475 1
        & DestroyVectorValue, Multiply, operator(.DOT.), operator(-), &
d1135 1
d1334 5
@


2.50
log
@Subset is getting closer bit by bit.
@
text
@a13 4
  use Declaration_table, only: NUM_VALUE, RANGE
  use DNWT_Module, only: FlagName, NF_EVALF, NF_EVALJ, NF_SOLVE, NF_NEWX, &
    & NF_GMOVE, NF_BEST, NF_AITKEN, NF_DX, NF_DX_AITKEN, NF_START, NF_TOLX, &
    & NF_TOLX_BEST, NF_TOLF, NF_TOO_SMALL, NF_FANDJ, NWT, NWT_T, NWTA, NWTDB, RK
a16 3
  use ForwardModelWrappers, only: ForwardModel
  use ForwardModelIntermediate, only: ForwardModelIntermediate_T, &
    & ForwardModelStatus_T
d18 2
a19 3
    & F_criteria, F_columnScale, F_covariance, F_diagonal, &
    & F_forwardModel, F_fuzz, F_fwdModelExtra, F_fwdModelOut, F_height, F_ignore, &
    & F_jacobian, &
d22 2
a23 2
    & F_quantity, F_regOrders, f_regQuants, &
    & F_regWeight, F_state, F_test, F_toleranceA, F_toleranceF, F_toleranceR, &
d31 3
a33 8
  use MatrixModule_1, only: AddToMatrix, AddToMatrixDatabase, CholeskyFactor, &
    & ClearMatrix, ColumnScale, CopyMatrix, CopyMatrixValue, CreateEmptyMatrix, &
    & DestroyMatrix, dump_Linf, dump_struct, &
    & FillExtraCol, FillExtraRow, FormNormalEquations => NormalEquations, &
    & GetDiagonal, GetFromMatrixDatabase, GetVectorFromColumn, InvertCholesky, &
    & Matrix_T, Matrix_Database_T, Matrix_Cholesky_T, Matrix_SPD_T, MaxL1, &
    & MinDiag, Multiply, Negate, RowScale, ScaleMatrix, SolveCholesky, &
    & UpdateDiagonal
a38 1
  use Regularization, only: Regularize
d46 2
a47 5
  use VectorsModule, only: AddToVector, ClearMask, CloneVector, CopyVector, &
    & CreateMask, DestroyVectorInfo, DestroyVectorMask, DestroyVectorValue, Dump, &
    & GetVectorQtyByTemplateIndex, GetVectorQuantityIndexByName, &
    & Multiply, operator(.DOT.), &
    & operator(-), ScaleVector, SetMask, SubtractFromVector, Vector_T, VectorValue_T
d62 1
a62 1
       "$Id: RetrievalModule.f90,v 2.49 2001/06/27 04:05:32 livesey Exp $"
a84 1
    type(nwt_T) :: AJ                   ! "About the Jacobian", see NWT.
a85 2
    real(r8) :: AprioriNorm             ! apriori .dot. apriori, for n+1, n+1
                                        ! element of augmented normal equations
a86 3
    type(vector_T) :: BestGradient      ! for NWT
    type(vector_T) :: BestX             ! for NWT
    type(vector_T) :: CandidateDX       ! for NWT
a88 1
    type(vector_T) :: ColumnScaleVector ! For column scaling by column norms
a91 1
    real(r8) :: Cosine                  ! Of an angle between two vectors
a92 2
    type(vector_T) :: CovarianceDiag    ! Diagonal of apriori Covariance
    type(vector_T) :: CovarianceXApriori ! Covariance \times Apriori
a94 2
    type(vector_T) :: DX                ! for NWT
    type(vector_T) :: DXUnScaled        ! for NWT
d103 1
a103 2
    type(vector_T) :: F                 ! for NWT -- Model - Measurements
    type(matrix_Cholesky_T) :: Factored ! Cholesky-factored normal equations
a104 2
    type (ForwardModelStatus_T) :: FmStat ! Status for forward model
    type (ForwardModelIntermediate_T) :: Fmw ! Work space for forward model
a107 1
    type(vector_T) :: FuzzState         ! Random numbers to fuzz the state
a110 1
    type(vector_T) :: Gradient          ! for NWT
a127 9
    integer :: N                        ! 1 + Number of columns in the Jacobian
    integer :: Name                     ! Either 0 or, if node_id(son) ==
                                        ! n_named, subtree(1,son)
    type(matrix_SPD_T) :: NormalEquations         ! Jacobian**T * Jacobian
    integer :: NumF, NumJ               ! Number of Function, Jacobian evaluations
    integer :: NWT_Flag                 ! Signal from NWT, q.v., indicating
                                        ! the action to take.
    integer :: NWT_Opt(20)              ! Options for NWT, q.v.
    real(rk) :: NWT_Xopt(20)            ! Real parameters for NWT options, q.v.
a131 1
    integer :: QuantityIndex            ! Index within vector of a quantity
a133 1
    type(vector_T) :: Reg_X_X           ! Regularization * X_n
a134 2
    integer :: RowBlock                 ! Which block of rows is the forward
                                        ! model filling?
a140 3
    type(matrix_SPD_T) :: TestCholesky  ! Used if "cho" is in switches; only
    !                                     for test/debug purposes.
    character(len=10) :: TheFlagName    ! Name of NWTA's flag argument
a151 1
    integer :: vectorIndex              ! Index in VectorDatabase
a152 2
    type(vector_T) :: X                 ! for NWT
    type(vector_T) :: XminusApriori     ! X - Apriori
d160 1
a160 2
    integer, parameter :: NotExtra = noFields + 1 ! No "extra" row and/or column
    integer, parameter :: NotSPD = notExtra + 1   ! Not symmetric pos. definite
a172 1
        name = subtree(1, son)
a174 1
        name = 0
d222 2
a223 7
            if ( .not. associated(covariance) ) then
              call announceError ( notSPD, field )
            else
              if ( .not. covariance%m%row%extra .or. &
                &  .not. covariance%m%col%extra ) &
                & call announceError ( notExtra, field )
            end if
a317 3
          ! Create the matrix for the Cholesky factor of the normal equations
          call createEmptyMatrix ( factored%m, 0, state, state, &
            &                      extra_col=.true., extra_row=.true. )
d323 1
a323 1
                &                      state, extra_col=.true. )
a331 2
            if ( .not. jacobian%col%extra ) &
              & call announceError ( notExtra, f_jacobian )
d334 1
a334 2
            call createEmptyMatrix ( jacobian, 0, measurements, state, &
              &                      extra_col=.true. )
a335 4
          n = sum(jacobian%col%nelts)   ! 1 + Number of columns in the Jacobian
          ! Create the normal equations matrix
          call createEmptyMatrix ( normalEquations%m, 0, state, state, &
            &                      extra_col=.true., extra_row=.true. )
d341 1
a341 2
                &                      state, state, &
                &                      extra_col=.true., extra_row=.true. )
a348 3
              if ( .not. outputCovariance%m%row%extra .or. &
                &  .not. outputCovariance%m%col%extra ) &
                & call announceError ( notExtra, f_outputCovariance )
d356 1
a356 2
            call createEmptyMatrix ( myCovariance%m, 0, state, state, &
              &                      extra_col = .true., extra_row = .true. )
d363 1
a363 580
            call allocate_test ( fmStat%rows, jacobian%row%nb, 'fmStat%rows', &
              & ModuleName )
            ! Set options for NWT
            nwt_opt(1:9) = (/  15, 1,      17, 2,      18, 3,      11, 4, 0 /)
            nwt_xopt(1:4) = (/ toleranceF, toleranceA, toleranceR, initLambda /)
            call nwt ( nwt_flag, nwt_xopt, nwt_opt )
            ! Create extra vectors.  Altogether, we need F, X, "Best X", DX,
            ! "Candidate DX" Gradient and "Best Gradient".
            call cloneVector ( x, state, vectorNameText='_x' )
            call copyVector ( x, state )
            call cloneVector ( f, measurements, vectorNameText='_f' )
            call cloneVector ( bestGradient, x, vectorNameText='_bestGradient' )
            call cloneVector ( bestX, x, vectorNameText='_bestX' )
            call cloneVector ( candidateDX, x, vectorNameText='_candidateDX' )
            call cloneVector ( dx, x, vectorNameText='_DX' )
            call cloneVector ( dxUnScaled, x, vectorNameText='_DX Unscaled' )
            call cloneVector ( gradient, x, vectorNameText='_gradient' )
            if ( columnScaling /= l_none ) &
              call cloneVector ( columnScaleVector, x, vectorNameText='_ColumnScale' )
            if ( got(f_fuzz) ) then
              ! Add some fuzz to the state vector (for testing purposes):
              call cloneVector ( fuzzState, x )
              do j = 1, x%template%noQuantities
                call random_number(fuzzState%quantities(j)%values)
                x%quantities(j)%values = x%quantities(j)%values * &
                  & ( 1.0_r8 + fuzz * ( fuzzState%quantities(j)%values - 0.5 ) )
              end do
            end if
              if ( index(switches,'xvec') /= 0 ) call dump ( x, name='Original X' )
            numF = 0
            numJ = 0
            aj%axmax = 0.0
            do k = 1, size(x%quantities)
              aj%axmax = max(aj%axmax, maxval(abs(x%quantities(k)%values)))
            end do

              if ( index(switches,'sca') /= 0 ) then
                if ( got(f_regWeight) ) then
                  call output ( ' regWeight = ' )
                  call output ( regWeight )
                end if
                if ( got(f_apriori) ) then
                  call output ( ' apriori scale = ' )
                  call output ( aprioriScale )
                end if
                if ( got(f_fuzz) ) then
                  call output ( ' fuzz = ' )
                  call output ( fuzz )
                end if
                call output ( ' initLambda = ' )
                call output ( initLambda, advance='yes' )
              end if

            do ! Newtonian iteration
                if ( nwt_flag /= nf_start .and. index(switches,'ndb') /= 0 ) &
                  & call nwtdb
              call nwta ( nwt_flag, aj )
                if ( index(switches,'nwt') /= 0 ) then
                  call FlagName ( nwt_flag, theFlagName )
                  call output ( 'Newton method flag = ' )
                  call output ( trim(theFlagName) )
                  call output ( ', numF = ' )
                  call output ( numF )
                  call output ( ', numJ = ' )
                  call output ( numJ, advance='yes' )
                end if
              select case ( nwt_flag )
              case ( nf_evalf ) ! ........................  EVALF  .....
              ! IF ( too many function values ) EXIT
              ! Compute f(x)
              ! Compute the Jacobian matrix J if you feel like it
              ! Set AJ%FNORM = L2 norm of f(x)
              ! IF ( AJ%FNORM is small enough ) EXIT
                numF = numF + 1
                if ( numF > maxFunctions ) then
                    if ( index(switches,'nwt') /= 0 ) then
                      call output ( &
                        & 'Newton iteration terminated because function evaluations (' )
                      call output ( numF )
                      call output ( ') > maxFunctions (' )
                      call output ( maxFunctions )
                      call output ( ')', advance='yes' )
                    end if
                  exit
                end if

                if ( got(f_apriori) ) then
                  ! Destroy (i.e. clean up) the previous contents of
                  ! xMinusApriori (if any), so as not to have a memory
                  ! leak.  Then make it look like apriori.
                  call cloneVector ( xMinusApriori, apriori, &
                    & vectorNameText='_xMinusApriori' )
                  xMinusApriori = x - apriori
                  !{Let the covariance of the apriori be $S_a$, let $C =
                  ! S_a^{-1}$, and let $F^T F = C$.  In the least-squares
                  ! problem we have extra rows of the form $F \delta x = F
                  ! ( a - x_n )$ where $a$ is the apriori state, and $x_n$
                  ! is the state as of the previous iteration.  The
                  ! initial bit of the right-hand side of the normal
                  ! equations is $F^T F ( a - x_n ) = C ( a - x_n )$.
                  if ( diagonal ) then
                    call getDiagonal ( covariance%m, covarianceDiag )
                    ! covarianceXApriori := covarianceDiag # apriori:
                    call multiply ( xMinusApriori, covarianceDiag, &
                      & covarianceXApriori )
                  else ! covarianceXApriori := covariance X apriori:
                    call multiply ( covariance, xMinusApriori, &
                      & covarianceXApriori )
                  end if
                  !{The contribution to the norm of the residual of the
                  ! right-hand side of the part of the least-squares problem
                  ! that is due to apriori is $( a - x_n )^T F^T F ( a - x_n )
                  ! = ( a - x_n )^T C ( a - x_n )$
                  aprioriNorm = xMinusApriori .dot. covarianceXapriori
                else
                  aprioriNorm = 0.0_r8
                end if

                ! Compute f(x)
                
                fmStat%newHydros = .true.
                fmStat%newScanHydros = .true.
                fmStat%maf = 0
                fmStat%finished = .false.

                ! Loop over MAFs
                do while (.not. fmStat%finished )
                  !??? What if one config set finished but others still had more
                  !??? to do? Ermmm, think of this next time.
                  fmStat%maf = fmStat%maf + 1
                  do k = 1, size(configIndices)
                    call forwardModel ( configDatabase(configIndices(k)), &
                      & x, fwdModelExtra, f, fmw, fmStat )
                  end do ! k
                end do ! MAFs
                call subtractFromVector ( f, measurements )
                if ( got(f_measurementSD) ) call multiply ( f, weight )
                aj%fnorm = sqrt ( aprioriNorm + ( f .dot. f ) )
                  if ( index(switches,'fvec') /= 0 ) &
                    & call dump ( f, name='Residual' )
                  if ( index(switches,'sca') /= 0 ) then
                      call output ( ' | F | = ' )
                      call output ( aj%fnorm, format='(1pe14.7)', advance='yes' )
                  end if
                if ( aj%fnorm < toleranceF ) then
                    if ( index(switches,'nwt') /= 0 ) then
                      call output ( &
                        & 'Newton iteration terminated because aj%fnorm (' )
                      call output ( aj%fnorm )
                      call output ( ') < ToleranceF (' )
                      call output ( toleranceF )
                      call output ( ')', advance='yes' )
                    end if
                  exit
                end if
              case ( nf_evalj ) ! ........................  EVALJ  .....
              ! IF ( too many Jacobian values ) EXIT
              ! Compute the Jacobian matrix J if you didn't do it when NFLAG
              ! was NF_EVALF:
              !   J(K,L) = Partial of F(K) / W.R.T. X(L), K = 1, NF, L = 1, NX
              ! Triangularize J, and compute (negative of the) gradient =
              ! -(Jacobian)**T * F.  This is the RHS of the normal equations
              ! J**T * J * "Candidate DX" = -J**T * F.
              ! Set
              !   AJ%DIAG = element on diagonal with smallest absolute value,
              !           after triangularization,
              !   AJ%AJN = maximum L1 norm of column in upper triangle
              !           after triangularization,
              !   AJ%FNMIN = L2 norm of residual, ||F + J * "Candidate DX"||
              !           (which can be gotten without solving for
              !           "Candidate DX": if -F is put as the last column of
              !           J before triangularization, either by Householder
              !           or by Cholesky factoring the normal equations,
              !           this is J(N+1,N+1)),
              !   AJ%GRADN = L2 norm of Gradient.
                numJ = numJ + 1
                if ( numJ > maxJacobians ) then
                    if ( index(switches,'nwt') /= 0 ) then
                      call output ( &
                        & 'Newton iteration terminated because Jacobian evaluations (' )
                      call output ( numJ )
                      call output ( ') > maxJacobians (' )
                      call output ( maxJacobians )
                      call output ( ')', advance='yes' )
                    end if
                  exit
                end if
                update = got(f_apriori)
                if ( update ) then ! start normal equations with apriori
                  if ( diagonal ) then
                  ! Iterate with the diagonal of the apriori covariance, then
                  ! use the full apriori covariance (one hopes only for one
                  ! more iteration). This improves sparsity during iteration.
                    call clearMatrix ( normalEquations%m )
                    call getDiagonal ( covariance%m, covarianceDiag )
                    call updateDiagonal ( normalEquations, covarianceDiag )
                  else
                    call copyMatrixValue ( normalEquations%m, covariance%m )
                  end if
                  call scaleVector ( covarianceXApriori, -1.0_r8 )
                  call fillExtraCol ( normalEquations%m, covarianceXApriori )
                  k = normalEquations%m%row%nb
                  normalEquations%m%block(k,k)%values(1,1) = aprioriNorm
                  if ( got(f_aprioriScale) ) &
                    & call scaleMatrix ( normalEquations%m, aprioriScale )
                else
                  call clearMatrix ( normalEquations%m ) ! start with zero
                  aprioriNorm = 0.0_r8
                end if

                ! Add Tikhonov regularization if requested
                if ( got(f_regOrders) ) then
                  call regularize ( jacobian, regOrders, regQuants, regWeight )
                  call cloneVector ( reg_X_x, x )
                  call multiply ( jacobian, x, reg_X_x )
!                 call scaleVector ( reg_X_x, -1.0_r8 )
                  call formNormalEquations ( jacobian, normalEquations, &
                    & update=update )
                  call clearMatrix ( jacobian )        ! free the space
                  call destroyVectorValue ( reg_X_x )  ! free the space
                end if

                ! Add some early stabilization
                if ( got(f_lambda) ) then
                  call updateDiagonal ( normalEquations, initLambda )
                  update = .true.
                end if

                fmStat%maf = 0
                fmStat%finished = .false.
                fmStat%newHydros = .true.
                fmStat%newScanHydros = .true.

                ! Loop over MAFs
                do while ( .not. fmStat%finished )
                  ! What if one config set finished but others still had more
                  ! to do? Ermmm, think of this next time.
                  fmStat%maf = fmStat%maf + 1
                  fmstat%rows = .false.
                  do k = 1, size(configIndices)
                    call forwardModel ( configDatabase(configIndices(k)), &
                      & x, fwdModelExtra, f, fmw, fmStat, jacobian )
                  end do ! k
                  do rowBlock = 1, size(fmStat%rows)
                    if ( fmStat%rows(rowBlock) ) then
                      call subtractFromVector ( f, measurements, &
                        & jacobian%row%quant(rowBlock), &
                        & jacobian%row%inst(rowBlock) )
                      call scaleVector ( f, -1.0_r8 )
                      call fillExtraCol ( jacobian, f, rowBlock )
                    end if
                  end do
                  !{Let $J$ be the Jacobian matrix and $f$ be the residual
                  ! of the least-squares problem.  Let $W$ be the inverse
                  ! of the measurement covariance (which in our case is
                  ! diagonal). Row scale the part of the least-squares
                  ! problem that arises from the measurements, i.e. the
                  ! least-squares problem becomes $W J = W f$.
                  if ( got(f_measurementSD) ) call rowScale ( weight, jacobian )
                  !{Form normal equations: $J^T W^T W J \delta \hat x =
                  ! J^T W^T f$:
                  call formNormalEquations ( jacobian, normalEquations, &
                    & update=update )
                  update = .true.
                    if ( index(switches,'jac') /= 0 ) &
                      call dump_Linf ( jacobian, 'L_infty norms of Jacobian blocks:' )
                    if ( index(switches,'spa') /= 0 ) &
                      & call dump_struct ( jacobian, &
                        & 'Sparseness structure of Jacobian blocks:' )
                  call clearMatrix ( jacobian )  ! free the space
!                 call destroyVectorValue ( f )  ! free the space
                end do ! mafs

                !{Column Scale $J$ (row and column scale $J^T J$).  Let
                ! $\Sigma$ be a column-scaling matrix for the Jacobian. We
                ! cater for several choices.  After row and column
                ! scaling, the problem is $J^T W^T W J \Sigma^{-1} \Sigma
                ! \delta \hat x = J^T W^T f$.
                select case ( columnScaling )
                case ( l_apriori )
                  call copyVector ( columnScaleVector, apriori )
                case ( l_covariance )
                  !??? Can't get here until allowed by init_tables
                case ( l_norm )
                  call getDiagonal ( normalEquations%m, columnScaleVector )
                end select
                if ( columnScaling /= l_none ) then
                  do j = 1, columnScaleVector%template%noQuantities
                    where ( columnScaleVector%quantities(j)%values <= 0.0 )
                      columnScaleVector%quantities(j)%values = 1.0
                    elsewhere
                      columnScaleVector%quantities(j)%values = 1.0 / &
                        & sqrt( columnScaleVector%quantities(j)%values )
                    end where
                  end do
                    if ( index(switches,'col') /= 0 ) &
                      & call dump ( columnScaleVector, name='Column scale vector' )
                  call columnScale ( normalEquations%m, columnScaleVector )
                  call rowScale ( columnScaleVector, normalEquations%m )
                end if
                k = normalEquations%m%row%nb
                aj%fnorm = sqrt(normalEquations%m%block(k,k)%values(1,1))
                !{Compute the (negative of the) gradient $= -J^T f$.
                ! This is the right-hand side of the normal equations
                ! $J^T J \delta \hat x = -J^T f$ where $\delta \hat x$ is
                ! the "Candidate $\delta x$" that may or may not get used.
                call getVectorFromColumn ( normalEquations%m, n, gradient )
                  if ( index(switches,'gvec') /= 0 ) &
                    & call dump ( gradient, name='gradient' )

                ! Factor J^T J:
!               factored%m%block => normalEquations%m%block ! to save space
!               Can't do the above because we need to keep the normal
!               equations around, in order to subtract Levenberg-Marquardt and
!               apriori covariance, in order to compute a posteriori covariance
                  if ( index(switches,'neq') /= 0 ) &
                    call dump_Linf ( normalEquations%m, &
                      & 'L_infty norms of Normal Equations blocks after scaling:', &
                      & upper=.true. )
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( normalEquations%m, &
                      & 'Sparseness structure of Normal equations blocks:', &
                      & upper=.true. )
                ! Factor the normal equations
                call choleskyFactor ( factored, normalEquations )
                  if ( index(switches,'diag') /= 0 ) then
                    call getDiagonal ( factored%m, dxUnscaled )
                    call dump ( dxUnscaled, &
                      & name='Diagonal of factored normal equations:' )
                  end if
                  if ( index(switches,'fac') /= 0 ) &
                    call dump_Linf ( factored%m, 'L_infty norms of blocks of factor:', &
                      & upper=.true. )
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( factored%m, &
                      & 'Sparseness structure of blocks of factor:', upper=.true. )
                  if ( index(switches,'cho') /= 0 ) then
                    call copyMatrix ( testCholesky%m, normalEquations%m )
                    call negate ( testCholesky%m )
                    call formNormalEquations ( factored%m, testCholesky, &
                      & update=.true. )
                    call dump_Linf ( testCholesky%m, 'How good was Cholesky?', &
                      & upper=.true. )
                    call destroyMatrix ( testCholesky%m )
                  end if
                aj%diag = minDiag ( factored ) ! element on diagonal with
                !       smallest absolute value, after triangularization
                aj%ajn = maxL1 ( factored%m ) ! maximum L1 norm of
                !       column in upper triangle after triangularization
                ! AJ%FNMIN = L2 norm of residual, ||F + J * "Candidate DX"||
                !       (which can be gotten without solving for
                !       "Candidate DX": if -F is put as the last column of
                !       J before triangularization, either by Householder
                !       or by Cholesky factoring the normal equations,
                !       this is J(N+1,N+1)).  The (extra row, extra column)
                !       block is 1x1:
                k = factored%m%col%nb
                aj%fnmin = factored%m%block(k,k)%values(1,1)
                aj%gradn = sqrt(gradient .dot. gradient) ! L2Norm(gradient)
                  if ( index(switches,'sca') /= 0 ) then
                    call dump ( (/ aj%ajn, aj%diag, aj%fnmin, aj%gradn /), &
                      & ' L1| FAC |       aj%diag      aj%fnmin         | G |', &
                      & clean=.true. )
                  end if
              case ( nf_solve ) ! ........................  SOLVE  .....
              !{Apply Levenberg-Marquardt stabilization with parameter
              ! $\lambda =$ AJ\%SQ.  I.e. solve $(J^T W^T W J \Sigma^{-1}
              ! + \lambda^2 I) \Sigma \delta \hat x = J^T W^T f$ for
              ! $\Sigma \delta \hat x$.

              ! Set AJ%FNMIN as for NWT_FLAG = NF_EVALJ, but taking account
              ! of Levenberg-Marquardt stabilization. Set
              !   AJ%DXN = L2 norm of "candidate DX",
              !   AJ%GDX = (Gradient) .dot. ("candidate DX")
                call updateDiagonal ( normalEquations, aj%sq**2 )
!               factored%m%block => normalEquations%m%block ! to save space
!               Can't do the above because we need to keep the normal equations
!               around, in order to subtract Levenberg-Marquardt and apriori
!               covariance, in order to compute a posteriori covariance
                  if ( index(switches,'neq') /= 0 ) &
                    call dump_Linf ( normalEquations%m, &
                      & 'L1 norms of Normal Equations blocks after Marquardt:', &
                      & upper=.true. )
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( normalEquations%m, &
                      & 'Sparseness structure of Normal equations blocks:', &
                      & upper=.true. )
                call choleskyFactor ( factored, normalEquations )
                  if ( index(switches,'fac') /= 0 ) &
                    call dump_Linf ( factored%m, &
                      & 'L1 norms of blocks of factor after Marquardt:', &
                      & upper=.true. )
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( factored%m, &
                      & 'Sparseness structure of blocks of factor:', upper=.true. )
                  if ( index(switches,'cho') /= 0 ) then
                    call copyMatrix ( testCholesky%m, normalEquations%m )
                    call negate ( testCholesky%m )
                    call formNormalEquations ( factored%m, testCholesky, &
                      & update=.true. )
                    call dump_Linf ( testCholesky%m, 'How good was Cholesky?', &
                      & upper=.true. )
                    call destroyMatrix ( testCholesky%m )
                  end if
                ! Solve for "candidate DX" = -(J**T J)**(-1) J**T * F
                call getVectorFromColumn ( factored%m, n, candidateDX )
                call solveCholesky ( factored, candidateDX )
                ! Set AJ%FNMIN as for NWT_FLAG = NF_EVALJ, but taking account
                ! of Levenberg-Marquardt stabilization:
                k = factored%m%col%nb
                aj%fnmin = factored%m%block(k,k)%values(1,1)
                aj%dxn = sqrt(candidateDX .dot. candidateDX) ! L2Norm(dx)
                aj%gdx = gradient .dot. candidateDX
                if ( .not. aj%starting ) aj%dxdxl = dx .dot. candidateDX
                  if ( index(switches,'dvec') /= 0 ) &
                    & call dump ( candidateDX, name='CandidateDX' )
                  if ( index(switches,'sca') /= 0 ) then
                    cosine = -2.0_r8
                    if ( aj%dxn > 0.0_r8 .and. aj%gradn > 0.0_r8 ) &
                      cosine = aj%gdx/(aj%dxn*aj%gradn)
                    call dump ( (/ aj%dxn, aj%fnmin, cosine, aj%sq /), &
                      & '    | DX |      aj%fnmin    ' // &
                      & 'cos(G, DX)        lambda', clean=.true. )
                    if ( .not. aj%starting ) then
                      call output ( ' cos(DX, DXL) = ' )
                      cosine = -2.0_r8
                      if ( aj%dxdxl > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
                        cosine = aj%dxdxl / (aj%dxn*aj%dxnl)
                      call output ( cosine, format='(1pe14.7)', advance='yes' )
                    ! call output ( ',  DX . DXL = ' )
                    ! call output ( aj%dxdxl, format='(1pe14.7)', advance='yes' )
                    end if
                  end if
              case ( nf_newx ) ! ..........................  NEWX  .....
              ! Set X = X + DX
              !     AJ%AXMAX = MAXVAL(ABS(X)),
              !     AJ%BIG = ANY ( DX > 10.0 * epsilon(X) * X )
                if ( .not. aj%starting ) aj%dxdxl = dx .dot. candidateDX
                !{Account for column scaling.  We solved for $\Sigma \delta x$
                ! above, so multiply by $\Sigma^{-1}$ (which is our variable
                ! {\tt columnScaleVector}):
                call copyVector ( dxUnScaled, dx )
                if ( columnScaling /= l_none ) then
                  ! dxUnScaled = dxUnScaled # columnScaleVector:
                  call multiply ( dxUnScaled, columnScaleVector )
                end if
                call addToVector ( x, dxUnScaled ) ! x = x + dxUnScaled
                  if ( index(switches,'dvec') /= 0 ) &
                    & call dump ( dxUnScaled, name='dX Unscaled' )
                  if ( index(switches,'xvec') /= 0 ) &
                    & call dump ( x, name='New X' )
                aj%axmax = 0.0
                aj%big = .false.
                do j = 1, size(x%quantities)
                  aj%axmax = max(aj%axmax, maxval(abs(x%quantities(j)%values)))
                  aj%big = aj%big .or. any( abs(dx%quantities(j)%values) > &
                    & 10.0 * epsilon(aj%axmax) * abs(x%quantities(j)%values) )
                end do
                  if ( index(switches,'sca') /= 0 ) then
                    call output ( ' aj%axmax = ' )
                    call output ( aj%axmax, format='(1pe14.7)' )
                    if ( .not. aj%starting ) then
                      call output ( ' cos(DX, DXL) = ' )
                      cosine = -2.0_r8
                      if ( aj%dxdxl > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
                        cosine = aj%dxdxl / (aj%dxn*aj%dxnl)
                      call output ( cosine, format='(1pe14.7)' )
                    ! call output ( ', DX . DXL = ' )
                    ! call output ( aj%dxdxl, format='(1pe14.7)', advance='yes' )
                    end if
                    call output ( ', aj%big = ' )
                    call output ( aj%big, advance='yes' )
                  end if
              case ( nf_gmove ) ! ........................  GMOVE  .....
              ! Set X = "Best X"
              !     DX = AJ%GFAC * "Best Gradient"
                call copyVector ( x, bestX ) ! x = bestX
                ! dx = aj%gfac * "Best Gradient":
                call scaleVector ( bestGradient, aj%gfac, dx )
                  if ( index(switches,'dvec') /= 0 ) &
                    & call dump ( dx, name='Gradient move from best X' )
                  if ( index(switches,'sca') /= 0 ) then
                    call output ( ' aj%gfac = ' )
                    call output ( aj%gfac, format='(1pe14.7)', advance='yes' )
                  end if
              case ( nf_best ) ! ..........................  BEST  .....
              ! Set "Best X" = X, "Best Gradient" = Gradient
                call copyVector ( bestX, x ) ! bestX = x
                call copyVector ( bestGradient, gradient ) ! bestGradient = gradient
              case ( nf_aitken ) ! ......................  AITKEN  .....
              ! Set DX = DX - "Candidate DX",
              !     AJ%DXDX = dot_product( DX, DX )
              ! IF ( AJ%DXDX /= 0.0 ) &
              !   Set AJ%DXDXL = dot_product( DX, "Candidate DX" )
                call subtractFromVector ( dx, candidateDX ) ! dx = dx - candidateDX
                aj%dxdx = dx .dot. dx
                if ( aj%dxdx > 0.0 ) aj%dxdxl = dx .dot. candidateDX
                  if ( index(switches,'dvec') /= 0 ) &
                    & call dump ( dx, name='dx after Aitken' )
                  if ( index(switches,'sca') /= 0 ) then
                    call output ( ' aj%dxdx = ' )
                    call output ( aj%dxdx, format='(1pe14.7)' )
                    call output ( ', cos(DX, DXL) = ' )
                    cosine = -2.0_r8
                    if ( aj%dxdxl > 0.0_r8 .and. aj%dxnl > 0.0_r8 ) &
                      cosine = aj%dxdxl / (aj%dxn*aj%dxnl)
                    call output ( cosine, format='(1pe14.7)', advance='yes' )
                  end if
              case ( nf_dx ) ! ..............................  DX  .....
                call copyVector ( dx, candidateDX ) ! dx = candidateDX
              case ( nf_dx_aitken ) ! ................  DX_AITKEN  .....
                ! dx = aj%cait * candidateDX:
                call scaleVector ( candidateDX, aj%cait, dx )
                  if ( index(switches,'dvec') /= 0 ) &
                    & call dump ( dx, name='dx after dx Aitken' )
                  if ( index(switches,'sca') /= 0 ) then
                    call output ( ' aj%cait = ' )
                    call output ( aj%cait, format='(1pe14.7)', advance='yes' )
                  end if
              case ( nf_tolx, nf_tolx_best, nf_tolf, nf_too_small ) ! ..
                ! IF ( NWT_FLAG == NF_TOO_SMALL ) THEN
                !   Take special action if requested accuracy is critical
                ! END IF
                if ( nwt_flag == nf_tolx_best ) call copyVector ( x, bestX )
                ! Convergence to desired solution.  Do whatever you want to
                ! with the solution.
                if ( .not. got(f_apriori) .or. .not. diagonal ) then
                    if ( index(switches,'nwt') /= 0 )&
                      & call output ( &
                        & 'Newton iteration terminated because of convergence', &
                        & advance='yes' )
                  exit
                end if
                diagonal = .not. diagonal
                nwt_flag = nf_start
              case ( nf_fandj ) ! .........................  FANDJ .....
                ! There is probably an error in the way F or J is computed.
                ! A warning has been printed by the error processor.
                ! IF ( you have confidence in F and J ) CYCLE
                ! STOP
              end select
            ! IF ( you want to return to a previous best X ) NWT_FLAG = 0
            end do ! Newton iteration
            if ( got(f_outputCovariance) .or. got(f_outputSD) ) then
              ! Subtract sum of Levenberg-Marquardt updates from normal
              ! equations
              call updateDiagonal ( normalEquations, -aj%sqt**2 )
              ! Subtract a priori covariance matrix from normal equations
              ! call negate ( covariance%m )
              ! call addToMatrix ( normalEquations%m, covariance%m )
              ! call negate ( covariance%m )
              ! Commented out, pending deep thought.!???
              ! Re-factor normal equations
              call choleskyFactor ( factored, normalEquations )
              call invertCholesky ( factored, outputCovariance%m )
              !??? Don't forget to scale the covariance
              if ( associated(outputSD) ) then !???
                call GetDiagonal ( outputCovariance%m, outputSD, SquareRoot = .true. )
                if ( columnScaling /= l_none ) then
                  call multiply ( outputSD, columnScaleVector )
                end if
              end if
            end if
            call copyVector ( state, x )
              if ( index(switches,'svec') /= 0 ) &
                & call dump ( state, name='Final state' )
            ! Clean up the temporaries, so we don't have a memory leak
            call destroyVectorInfo ( bestGradient )
            call destroyVectorInfo ( bestX )
            call destroyVectorInfo ( candidateDX )
            if ( columnScaling /= l_none ) &
              & call destroyVectorInfo ( columnScaleVector )
            call destroyVectorInfo ( dx )
            call destroyVectorInfo ( dxUnscaled )
            if ( got(f_fuzz) ) call destroyVectorInfo ( fuzzState )
            call destroyVectorInfo ( gradient )
            call destroyVectorInfo ( x )
            call destroyMatrix ( normalEquations%m )
            call destroyMatrix ( factored%m )
            call deallocate_test ( fmStat%rows, 'FmStat%rows', moduleName )
d422 1
a422 1
      case ( inconsistent, notExtra, notSPD )
a429 3
        case ( notExtra )
          call output ( ' does not have an extra column for the RHS.', &
            & advance='yes' )
d441 688
d1139 5
d1233 1
a1233 1
      endif
d1251 1
a1251 1
          endif
d1281 1
a1281 1
        endif
d1294 1
a1294 1
            endif
d1325 1
a1325 1
              endif
a1333 20

    subroutine DumpMask ( mask, n )
      integer, intent(in), dimension(:) :: MASK
      integer, intent(in) :: N
   
      ! Local variables
      integer :: I
      integer :: B

      ! Executable code
      b = bit_size (mask)
      do i = 1, n
        if ( btest(mask(i/b+1), mod (i,b) ) ) then
          call output ( '1' )
        else
          call output ( '0' )
        endif
      end do
      call output ( '', advance='yes' )
    end subroutine DumpMask
d1339 3
@


2.49
log
@Interim version with known problems in subset
@
text
@d33 1
a33 1
    & L_apriori, L_covariance, L_newtonian, L_none, L_norm, L_pressure, &
d79 1
a79 1
       "$Id: RetrievalModule.f90,v 2.48 2001/06/26 20:11:32 livesey Exp $"
d1142 1
d1218 8
a1226 8
      if ( .not. any ( heightUnit == (/ phyq_pressure, phyq_length /) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Height must be either length or pressure.' )

      ! Now one final check over all the things we've been asked to do.
      if ( heightUnit == phyq_pressure .and. qty%template%minorFrame .and. &
        & .not. got(f_ptanQuantity) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'must supply ptan for this subset if using pressure' )
d1242 1
a1242 1
          coordinate = phyq_zeta
d1268 2
a1269 2
            if ( qty%template%verticalCoordinate == phyq_zeta &
              & .and. coordinate == phyq_pressure ) then
d1271 3
a1273 3
            else if ( coordinate /= qty%template%verticalCoordinate ) then
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Inappropriate units for height in subset' )
d1324 3
@


2.48
log
@Bug fixes to subset (more to come I imagine)
@
text
@d79 1
a79 1
       "$Id: RetrievalModule.f90,v 2.47 2001/06/26 19:01:00 vsnyder Exp $"
d1293 2
a1294 1

d1299 19
d1323 3
@


2.47
log
@Specify regularization orders according to quantities
@
text
@d79 1
a79 1
       "$Id: RetrievalModule.f90,v 2.46 2001/06/26 18:18:14 livesey Exp $"
d1142 1
d1158 1
a1158 1
          channelsNode = gson
d1160 1
a1160 1
          heightNode = gson
d1162 1
a1162 1
          depthNode = gson
d1176 1
a1176 1
          do j = 1, nsons(channelsNode)
d1202 1
a1202 1
        do j = 1, nsons(heightNode)
d1206 1
a1206 1
          if ( units(1) /= units(2) ) &
d1231 3
d1264 1
a1264 1
          do j = 1, nsons(heightNode)
d1267 2
a1268 1
            if ( coordinate == phyq_zeta .and. units(1) == phyq_pressure ) then
d1270 1
a1270 1
            else if ( coordinate /= units(1) ) then
d1303 3
@


2.46
log
@Another (working?) version.
@
text
@d29 3
a31 3
    & F_opticalDepth, &
    & F_outputCovariance, F_ptanQuantity, F_outputSD, F_quantity, F_regOrders, F_regWeight, &
    & F_state, F_test, F_toleranceA, F_toleranceF, F_toleranceR, &
d52 1
a52 1
  use Regularization, only: MaxRegOrd, Regularize
d79 1
a79 1
       "$Id: RetrievalModule.f90,v 2.45 2001/06/26 17:57:46 livesey Exp $"
a139 1
    type(vector_T) :: FuzzMeasurements  ! Random numbers to fuzz the measurements
a166 1
    integer :: NumRegOrds               ! Number of regularization orders
d176 3
a178 1
    integer, dimension(:), pointer :: RegOrds    ! Regularization orders
d210 2
a211 1
    integer, parameter :: Inconsistent = BothOrNeither + 1 ! Inconsistent fields
d216 1
d219 1
a219 1
    nullify ( apriori, configIndices, covariance, fwdModelOut, regOrds )
d261 1
a261 1
        numRegOrds = 0
d306 3
a308 10
            call allocate_test ( regOrds, nsons(son)-1, &
              & "Regularization orders", moduleName )
            numRegOrds = nsons(son) - 1
            do k = 2, nsons(son)
              call expr(subtree(k,son), units, value, type )
              if ( units(1) /= phyq_dimensionless ) call MLSMessage ( &
                & MLSMSG_Error, moduleName, &
                & "Regularization orders must be dimensionless" )
              regOrds(k-1) = value(1)
            end do
d318 2
d349 2
d476 1
a476 8
                if ( got(f_regOrders) ) then
                  if ( numRegOrds == 1 ) then
                    call output ( ' regOrder = ' )
                    call output ( regOrds(1) )
                  else
                    call dump ( regOrds, &
                    & "Regularization orders:", clean=.true., format='(i3)' )
                  end if
d649 12
a1030 1
        call deallocate_test ( regOrds, "Regularization orders", moduleName )
d1066 7
a1072 1
        call output ( ' is supplied, but the other is not.', advance='yes' )
d1092 4
d1298 3
@


2.45
log
@Whoops, added another use clause
@
text
@d79 1
a79 1
       "$Id: RetrievalModule.f90,v 2.44 2001/06/26 16:26:32 livesey Exp $"
d1100 5
d1106 1
a1106 7
      integer :: SON                    ! Tree node
      integer :: FIELD                  ! Field type from tree
      integer :: VECTORINDEX            ! Index
      integer :: QUANTITYINDEX          ! Index
      integer :: UNITS(2)               ! Units returned by expr
      integer :: TYPE                   ! Type of value returned by expr
      integer :: CHANNELSNODE           ! Tree node for channels values
a1108 2
      integer :: COORDINATE             ! Vertical coordinate type
      integer :: DEPTHNODE              ! Tree node for optical depth
d1110 5
a1117 2
      integer, pointer, dimension(:) :: TOCHANGE ! Indices

d1125 1
d1128 1
a1128 1
      nullify ( channels, qty, ptan, tochange )
d1213 3
a1215 5
      ! Setup a temporary array
      call allocate_test ( tochange, qty%template%instanceLen, 'tochange', ModuleName )
      do j = 1, qty%template%instanceLen 
        toChange(j)=j
      end do
d1230 16
d1263 10
a1272 1
            call ClearMask ( qty%mask(:,instance), tochange(s1(1):s2(1)) )
d1285 3
@


2.44
log
@It at least compiles, but subset certainly doesn't work yet.
@
text
@d60 2
a61 2
  use VectorsModule, only: AddToVector, CloneVector, CopyVector, CreateMask, &
    & DestroyVectorInfo, DestroyVectorMask, DestroyVectorValue, Dump, &
d79 1
a79 1
       "$Id: RetrievalModule.f90,v 2.43 2001/06/22 01:26:54 vsnyder Exp $"
d1261 3
@


2.43
log
@Process fields for regularization, but regularization isn't done yet
@
text
@d14 1
d26 2
a27 1
    & F_forwardModel, F_fuzz, F_fwdModelExtra, F_fwdModelOut, F_jacobian, &
d29 2
a30 1
    & F_outputCovariance, F_outputSD, F_quantity, F_regOrders, F_regWeight, &
d33 1
a33 1
    & L_apriori, L_covariance, L_newtonian, L_none, L_norm, &
d36 2
a37 1
  use Intrinsic, only: Field_indices, PHYQ_Dimensionless, Spec_indices
d62 3
a64 2
    & GetVectorQuantityIndexByName, Multiply, operator(.DOT.), &
    & operator(-), ScaleVector, SetMask, SubtractFromVector, Vector_T
d79 1
a79 1
       "$Id: RetrievalModule.f90,v 2.42 2001/06/20 22:21:22 vsnyder Exp $"
d248 1
a248 34
        do j = 2, nsons(key) ! fields of the "subset" specification
          son = subtree(j, key)
          field = get_field_id(son)   ! tree_checker prevents duplicates
          got(field) = .true.
          select case ( field )
          case ( f_channels )
            channels = subtree(2,son)
          case ( f_criteria )
            criteria = subtree(2,son)
          case ( f_quantity )
            quantity = subtree(2,son) ! vector.quantity
          case ( f_test )
            test = subtree(2,son)
          case default
            ! Shouldn't get here if the type checker worked
          end select
        end do ! j = 2, nsons(key)
        if ( error == 0 ) then
          ! Compute the mask for the vector
          vectorIndex = decoration(decoration(subtree(1,quantity)))
          quantityIndex = getVectorQuantityIndexByName &
            & ( vectorDatabase(vectorIndex), sub_rosa(subtree(2,quantity)) )
          if ( .not. associated(vectorDatabase(vectorIndex)% &
            & quantities(quantityIndex)%mask) ) then ! create and fill with 1's
            call createMask ( vectorDatabase(vectorIndex)% &
              & quantities(quantityIndex) )
            do j = 1, size(vectorDatabase(vectorIndex)% &
              & quantities(quantityIndex)%mask, 2)
              call setMask ( vectorDatabase(vectorIndex)% &
                & quantities(quantityIndex)%mask(:,j) )
            end do
          end if ! mask exists
          !??? Fill the mask according to the specified criteria ???
        end if ! error == 0
d1093 163
d1261 3
@


2.42
log
@Added initialization for fmStat%newScanHydros
@
text
@d27 3
a29 2
    & F_outputCovariance, F_outputSD, F_quantity, F_state, F_test, F_toleranceA, &
    & F_toleranceF, F_toleranceR, Field_first, Field_last, &
d33 1
a33 1
  use Intrinsic, only: Field_indices, Spec_indices
d48 1
d74 1
a74 1
       "$Id: RetrievalModule.f90,v 2.41 2001/06/20 21:44:33 vsnyder Exp $"
d163 1
d173 2
d203 3
a205 3
    integer, parameter :: AprioriAndCovar = 1     ! Only one of apriori and
                                                  ! covariance supplied
    integer, parameter :: Inconsistent = AprioriAndCovar + 1 ! Inconsistent fields
d209 1
d212 1
a212 1
    nullify ( apriori, configIndices, covariance, fwdModelOut )
d287 1
d331 11
d349 1
a349 1
            &    f_toleranceA, f_toleranceF, f_toleranceR )
d362 2
d377 3
a379 1
          & call announceError ( aprioriAndCovar )
d505 11
d1055 1
d1086 1
a1086 1
      case ( aprioriAndCovar )
d1088 1
a1088 1
        call display_string ( field_indices(f_apriori) )
d1090 1
a1090 1
        call display_string ( field_indices(f_covariance) )
d1126 3
@


2.41
log
@Don't compute cosines between zero-length vectors
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.40 2001/06/01 22:26:03 vsnyder Exp $"
d563 1
d1092 3
@


2.40
log
@Got the row scaling backwards in the NF_EVALF
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.39 2001/06/01 21:58:17 livesey Exp $"
d109 1
d846 4
a849 2
                    call dump ( (/ aj%dxn, aj%fnmin, &
                      & aj%gdx/(aj%dxn*aj%gradn), aj%sq /), &
d854 4
a857 2
                      call output ( aj%dxdxl / (aj%dxn*aj%dxnl), format='(1pe14.7)', &
                        & advance='yes' )
d892 4
a895 1
                      call output ( aj%dxdxl / (aj%dxn*aj%dxnl), format='(1pe14.7)' )
d932 4
a935 2
                    call output ( aj%dxdxl / (aj%dxn*aj%dxnl), &
                      & format='(1pe14.7)', advance='yes' )
d1091 3
@


2.39
log
@Added scale for outputSD.
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.38 2001/06/01 21:40:18 vsnyder Exp $"
d576 1
a576 1
                if ( got(f_measurementSD) ) call multiply ( weight, f )
d1081 3
@


2.38
log
@Row scale during NF_EVALF; destroy some vectors so as not to have a
memory leak; initially clone x to get columnScaleVector.
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.37 2001/06/01 21:27:48 livesey Exp $"
d165 1
a165 1
    type(vector_T), pointer :: OutSD    ! Vector containing SD of result
d206 1
a206 1
    nullify ( measurements, measurementSD, state, outSD )
d326 1
a326 1
            outSD => vectorDatabase(decoration(decoration(subtree(2,son))))
d962 1
a962 1
            if ( got(f_outputCovariance) ) then
d975 5
a979 3
              if ( associated(outSD) ) then !???
                call GetDiagonal ( outputCovariance%m, outSD, SquareRoot = .true. )
              else
d1081 4
@


2.37
log
@Added outSD field
@
text
@d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.36 2001/06/01 20:36:34 vsnyder Exp $"
d462 2
d576 1
d987 2
d990 2
d1079 3
@


2.36
log
@Seems to work.  Added LaTeX comments.
@
text
@d24 1
a24 1
    & F_criteria, F_columnScale, F_covariance, F_diagonal, F_diagonalOut, &
d27 1
a27 1
    & F_outputCovariance, F_quantity, F_state, F_test, F_toleranceA, &
d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.34 2001/05/24 23:28:45 vsnyder Exp $"
d165 1
d206 1
a206 1
    nullify ( measurements, measurementSD, state )
a304 2
          case ( f_diagonalOut )
            diagonalOut = get_Boolean(son)
d325 2
d964 4
a967 3
              call negate ( covariance%m )
              call addToMatrix ( normalEquations%m, covariance%m )
              call negate ( covariance%m )
d972 2
a973 1
              if ( diagonalOut ) then
d1072 3
@


2.35
log
@Periodic commit.  Not working right yet.
@
text
@d8 1
a8 1
! This module inverts the radiative transfer equation, to solve for
d10 1
a10 1

d83 1
a83 1
  ! Process the "Retrieve" section of the L2 Configuration File.
d462 1
a462 10
              ! Add some fuzz to the measurement vector
!             call cloneVector ( fuzzMeasurements, measurements )
!             do j = 1, measurements%template%noQuantities
!               call random_number(fuzzMeasurements%quantities(j)%values)
!               measurements%quantities(j)%values = &
!                 & measurements%quantities(j)%values * &
!                   & ( 1.0_r8 + fuzz * &
!                     & ( fuzzMeasurements%quantities(j)%values - 0.5 ) )
!             end do
              ! Add some fuzz to the state vector
d531 7
a537 19
                  ! First, we need the square of the norm of the Cholesky
                  ! factor of the inverse of the covariance times
                  ! xMinusApriori.
                  if ( diagonal ) then
                    call getDiagonal ( covariance%m, covarianceDiag, &
                      & squareRoot=.true. )
                    ! covarianceXApriori := covarianceDiag # apriori:
                    call multiply ( xMinusApriori, covarianceDiag, &
                      & covarianceXApriori )
                  else ! covarianceXApriori := factor(covariance) X apriori:
                    call choleskyFactor ( factored, covariance, noExtra=.true. )
                    call multiply ( factored%m, xMinusApriori, &
                      & covarianceXApriori )
                    call clearMatrix ( factored%m )  ! free the space
                  end if
                  aprioriNorm = covarianceXapriori .dot. covarianceXapriori ! norm**2
                  ! Now we need the inverse of the covariance times
                  ! xMinusApriori, as the initial bit of the right-hand
                  ! side of the normal equations.
d547 5
d626 3
a628 3
                  ! Iterate with the diagonal of the covariance, then use the
                  ! full covariance (one hopes only for one more iteration).
                  ! This improves sparsity during iteration.
d635 1
a635 1
!                 call scaleVector ( covarianceXApriori, -1.0_r8 )
d676 6
d683 2
d696 6
a701 4
                ! Compute (negative of the) gradient = -(Jacobian)**T * F.
                ! This is the RHS of the normal equations 
                ! J**T * J * "Candidate DX" = -J**T * F:
                ! Column Scale J (row and column scale J^T J):
d726 4
d733 1
d735 4
a738 4
!???            factored%m%block => normalEquations%m%block ! to save space
!???            Can't do this because we need to keep the normal equations
!???            around, in order to subtract Levenberg-Marquardt and
!???            apriori covariance, in order to compute a posteriori covariance
d747 1
d789 5
a793 2
              ! Apply Levenberg-Marquardt stabilization with parameter = AJ%SQ,
              ! and solve (Jacobian) * "candidate DX" ~ -F for "candidate DX".
d795 1
a795 2
              ! of Levenberg-Marquardt stabilization.
              ! Set
d799 4
a802 4
!???            factored%m%block => normalEquations%m%block ! to save space
!???            Can't do this because we need to keep the normal equations
!???            around, in order to subtract Levenberg-Marquardt and
!???            apriori covariance, in order to compute a posteriori covariance
d858 3
a860 1
                ! Account for column scaling
a981 1
            call destroyVectorInfo ( f )
d995 2
a996 1
        if ( got(f_fwdModelOut) ) call copyVector ( f, fwdModelOut )
d1069 3
@


2.34
log
@Scale things back to user coordinates at the correct times; numerous output changes
@
text
@d28 1
a28 1
    & F_toleranceF, F_toleranceR, field_first, field_last, &
d39 2
a40 3
    & Matrix_T, &
    & Matrix_Database_T, Matrix_Cholesky_T, Matrix_SPD_T, MaxL1, MinDiag, &
    & MultiplyMatrixVector, Negate, RowScale, ScaleMatrix, SolveCholesky, &
d56 1
a56 1
    & GetVectorQuantityIndexByName, MultiplyVectors, operator(.DOT.), &
d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.33 2001/05/22 19:10:59 vsnyder Exp $"
d115 1
a115 1
    type(vector_T) :: DXScaled          ! for NWT
d153 2
a154 2
    type(matrix_SPD_T), target :: myCovariance    ! for OutputCovariance to point at
    type(matrix_T), target :: myJacobian          ! for Jacobian to point at
d459 1
a459 1
            call cloneVector ( dxScaled, x, vectorNameText='_DX Scaled' )
d462 10
a471 2
              ! Add some fuzz to the measurement and state vectors
              call cloneVector ( fuzzMeasurements, measurements )
a472 7
              do j = 1, measurements%template%noQuantities
                call random_number(fuzzMeasurements%quantities(j)%values)
                measurements%quantities(j)%values = &
                  & measurements%quantities(j)%values * &
                    & ( 1.0_r8 + fuzz * &
                      & ( fuzzMeasurements%quantities(j)%values - 0.5 ) )
              end do
d479 1
a479 1
            if ( index(switches,'xvec') /= 0 ) call dump ( x, name='Original X' )
d487 13
d501 2
a502 2
              if ( nwt_flag /= nf_start .and. index(switches,'ndb') /= 0 ) &
                & call nwtdb
d504 9
a512 5
              if ( index(switches,'nwt') /= 0 ) then
                call FlagName ( nwt_flag, theFlagName )
                call output ( 'Newton method flag = ' )
                call output ( trim(theFlagName), advance='yes' )
              end if
d522 8
a529 8
                  if ( index(switches,'nwt') /= 0 ) then
                    call output ( &
                      & 'Newton iteration terminated because function evaluations (' )
                    call output ( numF )
                    call output ( ') > maxFunctions (' )
                    call output ( maxFunctions )
                    call output ( ')', advance='yes' )
                  end if
d535 1
a535 1
                  ! covarianceXApriori (if any), so as not to have a memory
a538 3
                  ! It would be nice to write
                  ! covarianceXApriori = covariance .tx. ( x - apriori )
                  ! but that would cause a memory leak.
d540 15
a554 2
                  call multiplyMatrixVector ( covariance, xMinusApriori, &
                    & covarianceXApriori ) ! covarianceXApriori := covariance X apriori
d556 12
d590 5
a594 5
                if ( index(switches,'fvec') /= 0 ) &
                  & call dump ( f, name='Residual' )
                if ( index(switches,'sca') /= 0 ) then
                    call output ( ' | F | = ' )
                    call output ( aj%fnorm, format='(1pe14.7)', advance='yes' )
d597 8
a604 8
                  if ( index(switches,'nwt') /= 0 ) then
                    call output ( &
                      & 'Newton iteration terminated because aj%fnorm (' )
                    call output ( aj%fnorm )
                    call output ( ') < ToleranceF (' )
                    call output ( toleranceF )
                    call output ( ')', advance='yes' )
                  end if
d629 8
a636 8
                  if ( index(switches,'nwt') /= 0 ) then
                    call output ( &
                      & 'Newton iteration terminated because Jacobian evaluations (' )
                    call output ( numJ )
                    call output ( ') > maxJacobians (' )
                    call output ( maxJacobians )
                    call output ( ')', advance='yes' )
                  end if
d646 1
a646 1
                    call getDiagonal ( covariance, covarianceDiag )
d663 4
a666 2
                if ( got(f_lambda) ) &
                  & call updateDiagonal ( normalEquations, initLambda )
d688 1
a688 1
!                     call scaleVector ( f, -1.0_r8 )
d696 5
a700 5
                  if ( index(switches,'jac') /= 0 ) &
                    call dump_Linf ( jacobian, 'L_infty norms of Jacobian blocks:' )
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( jacobian, &
                      & 'Sparseness structure of Jacobian blocks:' )
d714 1
a714 1
                  call getDiagonal ( normalEquations, columnScaleVector )
d725 2
a726 2
                  if ( index(switches,'col') /= 0 ) &
                    & call dump ( columnScaleVector, name='Column scale vector' )
d730 2
d733 2
a734 2
                if ( index(switches,'gvec') /= 0 ) &
                  & call dump ( gradient, name='gradient' )
d740 8
a747 8
                if ( index(switches,'neq') /= 0 ) &
                  call dump_Linf ( normalEquations%m, &
                    & 'L_infty norms of Normal Equations blocks after scaling:', &
                    & upper=.true. )
                if ( index(switches,'spa') /= 0 ) &
                  & call dump_struct ( normalEquations%m, &
                    & 'Sparseness structure of Normal equations blocks:', &
                    & upper=.true. )
d749 20
a768 15
                if ( index(switches,'fac') /= 0 ) &
                  call dump_Linf ( factored%m, 'L_infty norms of blocks of factor:', &
                    & upper=.true. )
                if ( index(switches,'spa') /= 0 ) &
                  & call dump_struct ( factored%m, &
                    & 'Sparseness structure of blocks of factor:', upper=.true. )
                if ( index(switches,'cho') /= 0 ) then
                  call copyMatrix ( testCholesky%m, normalEquations%m )
                  call negate ( testCholesky%m )
                  call formNormalEquations ( factored%m, testCholesky, &
                    & update=.true. )
                  call dump_Linf ( testCholesky%m, 'How good was Cholesky?', &
                    & upper=.true. )
                  call destroyMatrix ( testCholesky%m )
                end if
d783 5
a787 5
                if ( index(switches,'sca') /= 0 ) then
                  call dump ( (/ aj%ajn, aj%diag, aj%fnmin, aj%gradn /), &
                    & ' L1| FAC |       aj%diag      aj%fnmin         | G |', &
                    & clean=.true. )
                end if
d801 8
a808 8
                if ( index(switches,'neq') /= 0 ) &
                  call dump_Linf ( normalEquations%m, &
                    & 'L1 norms of Normal Equations blocks after Marquardt:', &
                    & upper=.true. )
                if ( index(switches,'spa') /= 0 ) &
                  & call dump_struct ( normalEquations%m, &
                    & 'Sparseness structure of Normal equations blocks:', &
                    & upper=.true. )
d810 17
a826 17
                if ( index(switches,'fac') /= 0 ) &
                  call dump_Linf ( factored%m, &
                    & 'L1 norms of blocks of factor after Marquardt:', &
                    & upper=.true. )
                if ( index(switches,'spa') /= 0 ) &
                  & call dump_struct ( factored%m, &
                    & 'Sparseness structure of blocks of factor:', upper=.true. )
                if ( index(switches,'cho') /= 0 ) then
                  call copyMatrix ( testCholesky%m, normalEquations%m )
                  call negate ( testCholesky%m )
                  call formNormalEquations ( factored%m, testCholesky, &
                    & update=.true. )
                  call dump_Linf ( testCholesky%m, 'How good was Cholesky?', &
                    & upper=.true. )
                  call destroyMatrix ( testCholesky%m )
                end if
                ! Solve for "candidate DX" = -(Jacobian)**(-1) * F
d836 14
a849 13
                if ( index(switches,'dvec') /= 0 ) &
                  & call dump ( candidateDX, name='CandidateDX' )
                if ( index(switches,'sca') /= 0 ) then
                  call dump ( (/ aj%dxn, aj%fnmin, &
                    & aj%gdx/(aj%dxn*aj%gradn), aj%sq /), &
                    & '    | DX |      aj%fnmin    ' // &
                    & 'cos(G, DX)        lambda', clean=.true. )
                  if ( .not. aj%starting ) then
                    call output ( ' cos(DX, DXL) = ' )
                    call output ( aj%dxdxl / (aj%dxn*aj%dxnl), format='(1pe14.7)', &
                      & advance='yes' )
                  ! call output ( ',  DX . DXL = ' )
                  ! call output ( aj%dxdxl, format='(1pe14.7)', advance='yes' )
a850 1
                end if
d857 1
d859 8
a866 9
                  call copyVector ( dxScaled, dx )
                  ! dxScaled = dxScaled # columnScaleVector:
                  call multiplyVectors ( dxScaled, columnScaleVector )
                end if
                call addToVector ( x, dxScaled ) ! x = x + dxScaled
                if ( index(switches,'dvec') /= 0 ) &
                  & call dump ( dxScaled, name='dX Scaled' )
                if ( index(switches,'xvec') /= 0 ) &
                  & call dump ( x, name='New X' )
d874 11
a884 8
                if ( index(switches,'sca') /= 0 ) then
                  call output ( ' aj%axmax = ' )
                  call output ( aj%axmax, format='(1pe14.7)' )
                  if ( .not. aj%starting ) then
                    call output ( ' cos(DX, DXL) = ' )
                    call output ( aj%dxdxl / (aj%dxn*aj%dxnl), format='(1pe14.7)' )
                  ! call output ( ', DX . DXL = ' )
                  ! call output ( aj%dxdxl, format='(1pe14.7)', advance='yes' )
a885 3
                  call output ( ', aj%big = ' )
                  call output ( aj%big, advance='yes' )
                end if
d892 6
a897 6
                if ( index(switches,'dvec') /= 0 ) &
                  & call dump ( dx, name='Back to bestX' )
                if ( index(switches,'sca') /= 0 ) then
                  call output ( ' aj%gfac = ' )
                  call output ( aj%gfac, format='(1pe14.7)', advance='yes' )
                end if
d910 9
a918 9
                if ( index(switches,'dvec') /= 0 ) &
                  & call dump ( dx, name='dx after Aitken' )
                if ( index(switches,'sca') /= 0 ) then
                  call output ( ' aj%dxdx = ' )
                  call output ( aj%dxdx, format='(1pe14.7)' )
                  call output ( ', cos(DX, DXL) = ' )
                  call output ( aj%dxdxl / (aj%dxn*aj%dxnl), &
                    & format='(1pe14.7)', advance='yes' )
                end if
d924 6
a929 6
                if ( index(switches,'dvec') /= 0 ) &
                  & call dump ( dx, name='dx after dx Aitken' )
                if ( index(switches,'sca') /= 0 ) then
                  call output ( ' aj%cait = ' )
                  call output ( aj%cait, format='(1pe14.7)', advance='yes' )
                end if
d938 4
a941 4
                  if ( index(switches,'nwt') /= 0 )&
                    & call output ( &
                      & 'Newton iteration terminated because of convergence', &
                      & advance='yes' )
d971 2
a972 2
            if ( index(switches,'svec') /= 0 ) &
              & call dump ( state, name='Final state' )
d1065 3
@


2.33
log
@Periodic commit; still isn't accepting a Newton step
@
text
@d15 2
a16 2
    & NF_GMOVE, NF_BEST, NF_AITKEN, NF_DX, NF_DX_AITKEN, NF_TOLX, &
    & NF_TOLX_BEST, NF_TOLF, NF_TOO_SMALL, NF_FANDJ, NWT, NWT_T, NWTA, RK
d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.32 2001/05/19 01:17:39 vsnyder Exp $"
d116 1
d459 2
a460 1
            call cloneVector ( DX, x, vectorNameText='_DX' )
d479 1
d486 4
a489 1
            do
d551 1
a551 1
                if ( index(switches,'vec') /= 0 ) &
d623 4
a675 2
                  if ( index(switches,'col') /= 0 ) &
                    & call dump ( columnScaleVector, name='Column scale vector' )
d684 2
d690 1
a690 1
                if ( index(switches,'vec') /= 0 ) &
a724 1
                k = factored%m%col%nb
d732 1
d737 1
a737 1
                    & '   | FAC |       aj%diag      aj%fnmin         | G |', &
d787 2
a788 1
                if ( index(switches,'vec') /= 0 ) &
d791 1
a791 1
                  call dump ( (/ aj%dxn, aj%fnmin, aj%gdx, &
d793 1
a793 1
                    & '    | DX |      aj%fnmin        G . DX    ' // &
d795 7
d807 1
d809 10
a818 7
                if ( columnScaling /= l_none ) & ! dx = dx # columnScaleVector:
                  call multiplyVectors ( dx, columnScaleVector )
                call addToVector ( x, dx ) ! x = x + dx
                if ( index(switches,'vec') /= 0 ) then
                  call dump ( dx, name='dX' )
                  call dump ( x, name='New X' )
                end if
a825 1
                if ( .not. aj%starting ) aj%dxdxl = dx .dot. candidateDX
d830 4
a833 2
                    call output ( ', aj%dxdxl = ' )
                    call output ( aj%dxdxl, format='(1pe14.7)' )
d844 1
a844 1
                if ( index(switches,'vec') /= 0 ) &
d862 1
a862 1
                if ( index(switches,'vec') /= 0 ) &
d866 4
a869 1
                  call output ( aj%dxdx, format='(1pe14.7)', advance='yes' )
d876 1
a876 1
                if ( index(switches,'vec') /= 0 ) &
d897 1
d923 1
a923 1
            if ( index(switches,'vec') /= 0 ) &
d1017 3
@


2.32
log
@Correct sign of (apriori-x)
@
text
@d40 1
a40 1
    & Matrix_Database_T, Matrix_Cholesky_T, Matrix_SPD_T, MaxAbsVal, MinDiag, &
d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.31 2001/05/19 00:22:31 vsnyder Exp $"
d491 6
a496 1
              case ( nf_evalf )
d523 2
d533 1
a533 1
                ! Loop over mafs
d535 2
a536 2
                  ! What if one config set finished but others still had more
                  ! to do? Ermmm, think of this next time.
d542 1
a542 1
                end do ! mafs
d562 20
a581 4
              case ( nf_evalj )
                ! Compute the Jacobian matrix J if you didn't do it when
                ! NWT_FLAG was NF_EVALF:
                !   J(K,L) = Partial of F(K) / W.R.T. X(L), K = 1, NF, L = 1, NX
a659 10
                  do j = 1, columnScaleVector%template%noQuantities
                    where ( columnScaleVector%quantities(j)%values <= 0.0 )
                      columnScaleVector%quantities(j)%values = 1.0
                    elsewhere
                      columnScaleVector%quantities(j)%values = 1.0 / &
                        & sqrt( columnScaleVector%quantities(j)%values )
                    end where
                  end do
                  call columnScale ( normalEquations%m, columnScaleVector )
                  call rowScale ( columnScaleVector, normalEquations%m )
d664 2
d678 1
a678 1
                end select
d713 1
a713 1
                aj%ajn = maxAbsVal ( factored%m ) ! maximum L1 norm of
d730 8
a737 2
              case ( nf_solve )
                ! Apply Marquardt stabilization with parameter = AJ%SQ:
a770 9
                ! Account for column scaling
                select case ( columnScaling )
                case ( l_apriori )
                  call multiplyVectors ( dx, apriori ) ! dx = dx # apriori
                case ( l_covariance )
                  !??? Can't get here until allowed by init_tables
                case ( l_norm )
                  call multiplyVectors ( dx, columnScaleVector ) ! dx = dx # ...
                end select
d777 2
a778 1
                if ( index(switches,'vec') /= 0 ) call dump ( dx, name='DX' )
d785 7
a791 2
              case ( nf_newx )
                if ( index(switches,'vec') /= 0 ) call dump ( dx, name='dX' )
d793 4
a796 1
                if ( index(switches,'vec') /= 0 ) call dump ( x, name='New X' )
d808 4
a813 4
                  if ( .not. aj%starting ) then
                    call output ( ' aj%dxdxl = ' )
                    call output ( aj%dxdxl, format='(1pe14.7)', advance='yes' )
                  end if
d815 3
a817 1
              case ( nf_gmove )
d827 2
a828 1
              case ( nf_best )
d831 5
a835 1
              case ( nf_aitken )
d845 1
a845 1
              case ( nf_dx )
d847 1
a847 1
              case ( nf_dx_aitken )
d856 1
a856 1
              case ( nf_tolx, nf_tolx_best, nf_tolf, nf_too_small )
d863 1
a863 1
                if ( .not. diagonal ) then
d871 1
a871 1
              case ( nf_fandj )
d896 2
d990 3
@


2.31
log
@Dump_L1 -> Dump_Linf, uncouple 'spa' and Linf dumps
@
text
@d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.30 2001/05/18 23:18:42 vsnyder Exp $"
d583 1
a583 1
                  call scaleVector ( covarianceXApriori, -1.0_r8 )
d960 3
@


2.30
log
@Replace 'weight' field of 'retrieve' by 'measurementSD'
@
text
@d36 1
a36 1
    & DestroyMatrix, dump_l1, dump_struct, &
d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.29 2001/05/18 19:46:23 vsnyder Exp $"
d468 1
a468 1
                    & ( 1.0_r8 + fuzz * epsilon(fuzz) * &
d474 1
a474 2
                  & ( 1.0_r8 + fuzz * epsilon(fuzz) * &
                    & ( fuzzState%quantities(j)%values - 0.5 ) )
d622 5
a626 6
                  if ( index(switches,'jac') /= 0 ) then
                    call dump_l1 ( jacobian, 'L1 norms of Jacobian blocks:' )
                    if ( index(switches,'spa') /= 0 ) &
                      & call dump_struct ( jacobian, &
                        & 'Sparseness structure of Jacobian blocks:' )
                  end if
d672 7
a678 3
                if ( index(switches,'neq') /= 0 ) then
                  call dump_l1 ( normalEquations%m, &
                    & 'L1 norms of Normal Equations blocks after scaling:', &
a679 5
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( normalEquations%m, &
                      & 'Sparseness structure of Normal equations blocks:', &
                      & upper=.true. )
                end if
d681 2
a682 2
                if ( index(switches,'fac') /= 0 ) then
                  call dump_l1 ( factored%m, 'L1 norms of blocks of factor:', &
d684 3
a686 4
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( factored%m, &
                      & 'Sparseness structure of blocks of factor:', upper=.true. )
                end if
d692 1
a692 1
                  call dump_L1 ( testCholesky%m, 'How good was Cholesky?', &
d722 2
a723 2
                if ( index(switches,'neq') /= 0 ) then
                  call dump_l1 ( normalEquations%m, &
d726 4
a729 5
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( normalEquations%m, &
                      & 'Sparseness structure of Normal equations blocks:', &
                      & upper=.true. )
                end if
d731 2
a732 2
                if ( index(switches,'fac') /= 0 ) then
                  call dump_l1 ( factored%m, &
d735 3
a737 4
                  if ( index(switches,'spa') /= 0 ) &
                    & call dump_struct ( factored%m, &
                      & 'Sparseness structure of blocks of factor:', upper=.true. )
                end if
d743 1
a743 1
                  call dump_L1 ( testCholesky%m, 'How good was Cholesky?', &
d960 3
@


2.29
log
@Add secret 'fuzz' field to 'retrieve' command -- for testing
@
text
@d26 3
a28 3
    & F_lambda, F_maxF, F_maxJ, F_measurements, F_method, F_outputCovariance, &
    & F_quantity, F_state, F_test, F_toleranceA, F_toleranceF, &
    & F_toleranceR, F_weight, field_first, field_last, &
d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.28 2001/05/18 01:04:08 vsnyder Exp $"
d150 1
d191 1
a191 1
    type(vector_T), pointer :: Weight   ! Scaling vector for rows
d205 1
a205 1
    nullify ( measurements, state, weight )
d320 2
a348 2
          case ( f_weight )
            weight => vectorDatabase(decoration(decoration(subtree(2,son))))
d368 12
a379 3
          if ( got(f_weight) ) then
            if ( weight%template%id /= measurements%template%id ) &
              & call announceError ( inconsistent, f_weight, f_measurements )
d619 1
a619 1
                  if ( got(f_weight) ) call rowScale ( weight, jacobian )
d638 11
a648 2
                  call columnScale ( normalEquations%m, apriori )
                  call rowScale ( apriori, normalEquations%m )
a651 9
                  if ( index(switches,'neq') /= 0 ) then
                    call dump_l1 ( normalEquations%m, &
                      & 'L1 norms of blocks of Normal Equations before scaling:', &
                      & upper=.true. )
                    if ( index(switches,'spa') /= 0 ) &
                      & call dump_struct ( normalEquations%m, &
                        & 'Sparseness structure of Normal equations blocks:', &
                        & upper=.true. )
                  end if
d656 6
a661 7
                    where ( columnScaleVector%quantities(j)%values <= 0.0 ) &
                      & columnScaleVector%quantities(j)%values = 1.0
!                   if ( any(columnScaleVector%quantities(j)%values <= 0.0) ) &
!                     & call MLSMessage ( MLSMSG_Error, ModuleName, &
!                       & "Normal equations are singular" )
                    columnScaleVector%quantities(j)%values = 1.0 / &
                      & sqrt( columnScaleVector%quantities(j)%values )
d676 2
a677 1
                    & 'L1 norms of Normal Equations blocks:', upper=.true. )
d966 3
@


2.28
log
@Periodic commit -- tons of stuff changed
@
text
@d25 2
a26 2
    & F_forwardModel, F_fwdModelExtra, F_fwdModelOut, F_jacobian, &
    & F_Lambda, F_maxF, F_maxJ, F_measurements, F_method, F_outputCovariance, &
d30 2
a31 1
    & S_dumpblocks, S_forwardModel, S_sids, S_matrix, S_subset, S_retrieve, S_time
d73 1
a73 1
       "$Id: RetrievalModule.f90,v 2.27 2001/05/10 22:50:45 vsnyder Exp $"
d129 5
d191 2
a192 2
    type(vector_T), pointer :: X        ! for NWT
    type(vector_T) :: XminusApriori ! X - Apriori
d204 1
a204 1
    nullify ( measurements, state, weight, x )
d325 2
a326 2
          case ( f_aprioriScale, f_lambda, f_maxF, f_maxJ, f_toleranceA, &
            &    f_toleranceF, f_toleranceR )
d331 2
d442 2
a443 1
            x => state
d450 18
d471 2
a472 2
            do k = 1, size(state%quantities)
              aj%axmax = max(aj%axmax, maxval(abs(state%quantities(k)%values)))
d763 1
a763 1
                  call dump ( (/ aj%fnmin, aj%dxn, aj%gdx, &
d765 1
a765 1
                    & '  aj%fnmin        | DX |        G . DX    ' // &
d863 1
d871 1
d955 4
a958 1
! $Log: RetrievalModule.f90, $
@


2.27
log
@Added switches to print stuff during Newton iteration
@
text
@d14 1
a14 1
  use DNWT_Module, only: NF_EVALF, NF_EVALJ, NF_SOLVE, NF_NEWX, &
d17 1
d26 1
a26 1
    & F_maxIterations, F_measurements, F_method, F_outputCovariance, &
d34 1
a34 1
    & ClearMatrix, ColumnScale, CopyMatrixValue, CreateEmptyMatrix, &
a35 1
dump, &
d44 1
d55 1
a55 2
    & DestroyVectorInfo, DestroyVectorMask, DestroyVectorValue, &
dump, &
d57 1
a57 1
    & ScaleVector, SetMask, SubtractFromVector, Vector_T
d63 2
a64 1
  integer, parameter, private :: DefaultMaxIterations = 5
d72 1
a72 1
       "$Id: RetrievalModule.f90,v 2.26 2001/05/03 02:00:15 vsnyder Exp $"
d133 1
a133 1
    integer :: Iter                     ! Iteration number
d139 4
a142 2
    integer :: MaxIterations            ! Maximum number of iterations of
                                        ! Newtonian method
d152 1
d155 2
a156 2
    integer :: NWT_Opt(10)              ! Options for NWT, q.v.
    real(rk) :: NWT_Xopt(10)            ! Real parameters for NWT options, q.v.
d169 3
d186 1
d268 3
a270 1
        maxIterations = defaultMaxIterations
d319 2
a320 2
          case ( f_aprioriScale, f_maxIterations, f_toleranceA, f_toleranceF, &
            &    f_toleranceR )
d325 6
a330 2
            case ( f_maxIterations )
              maxIterations = value(1)
a422 1

d429 2
a430 2
            nwt_opt(1:7) = (/  15, 1,      17, 2,      18, 3,      0 /)
            nwt_xopt(1:3) = (/ toleranceF, toleranceA, toleranceR /)
d441 2
a442 8
            if ( got(f_apriori) ) then
              call cloneVector ( covarianceXApriori, apriori, &
                & vectorNameText='_covarianceXApriori' )
              call multiplyMatrixVector ( covariance, apriori, &
                & covarianceXApriori ) ! covarianceXApriori := covariance X apriori
              aprioriNorm = covarianceXapriori .dot. covarianceXapriori ! norm**2
            end if
            iter = 0
d449 5
d456 28
a483 1
                if ( iter > maxIterations ) exit
a484 1
                aj%fnorm = 0.0
a498 5
                  call subtractFromVector ( f, measurements )
                  aj%fnorm = aj%fnorm + ( f .dot. f )
                  if ( index(switches,'vec') /= 0 ) &
                    & call dump ( f, name='Residual' )
!                 call destroyVectorValue ( f )  ! free the space
d500 4
a503 1
                aj%fnorm = sqrt(aj%fnorm)
d505 11
a515 2
                    call output ( 'Residual norm = ' )
                    call output ( aj%fnorm, advance='yes' )
d517 2
a518 1
                if ( aj%fnorm < toleranceF ) exit
d523 12
d547 1
d555 1
d578 1
a597 3
                call getVectorFromColumn ( normalEquations%m, n, gradient )
                if ( index(switches,'vec') /= 0 ) &
                  & call dump ( gradient, name='gradient' )
d606 9
d616 2
d619 6
a624 1
                    columnScaleVector%quantities(j)%values = &
d630 3
d654 9
d678 3
a680 4
                  call output ( 'aj%diag = ' ); call output ( aj%diag, advance='yes' )
                  call output ( 'aj%ajn = ' ); call output ( aj%ajn, advance='yes' )
                  call output ( 'aj%fnmin = ' ); call output ( aj%fnmin, advance='yes' )
                  call output ( 'aj%gradn = ' ); call output ( aj%gradn, advance='yes' )
a682 3
                if ( index(switches,'sca') /= 0 ) then
                  call output ( 'aj%sq = ' ); call output ( aj%sq, advance='yes' )
                end if
d707 9
d734 7
d742 1
d744 1
a744 1
                if ( index(switches,'vec') /= 0 ) call dump ( x, name='X' )
d754 8
a761 3
                  call output ( 'aj%axmax' ); call output ( aj%axmax, advance='yes' )
                  call output ( 'aj%big' ); call output ( aj%big, advance='yes' )
                  call output ( 'aj%dxdxl' ); call output ( aj%dxdxl, advance='yes' )
d770 2
a771 1
                  call output ( 'aj%gfac' ); call output ( aj%gfac, advance='yes' )
d783 2
a784 1
                  call output ( 'aj%dxdx' ); call output ( aj%dxdx, advance='yes' )
d794 2
a795 1
                  call output ( 'aj%cait' ); call output ( aj%cait, advance='yes' )
d804 7
a810 1
                if ( .not. diagonal ) exit
a818 1
              iter = iter + 1
d926 4
a929 1
! $Log: RetrievalModule.f90,v $
@


2.26
log
@Put names on cloned vectors
@
text
@d34 2
a35 1
    & DestroyMatrix, &
d48 1
a48 1
  use Toggles, only: Gen, Toggle
d55 1
d71 1
a71 1
       "$Id: RetrievalModule.f90,v 2.25 2001/05/02 05:28:04 livesey Exp $"
d96 1
a96 1
    real(r8) :: aprioriNorm             ! apriori .dot. apriori, for n+1, n+1
d98 1
a98 1
    real(r8) :: aprioriScale            ! Weight for apriori, default 1.0
d259 1
d429 2
a430 1
              aprioriNorm = apriori .dot. apriori ! norm**2
d433 1
d463 2
d468 4
a489 1
                  call fillExtraRow ( normalEquations%m, covarianceXApriori )
a497 1
                fmStat%newHydros = .true.
d500 2
d503 1
a503 1
                ! Loop over mafs
d508 1
d525 7
a531 1
!                 call clearMatrix ( jacobian )  ! free the space
d538 2
d557 20
a576 2
                factored%m%block => normalEquations%m%block ! to save space
                call choleskyFactor ( normalEquations, factored )
d591 6
d598 3
d607 18
a624 1
                call choleskyFactor ( normalEquations, factored )
d645 1
d654 5
d663 5
d675 5
d685 5
d717 1
a717 1
              call choleskyFactor ( normalEquations, factored )
d815 3
@


2.25
log
@Added DumpBlocks
@
text
@d69 1
a69 1
       "$Id: RetrievalModule.f90,v 2.24 2001/05/01 23:52:04 vsnyder Exp $"
d419 6
a424 6
            call cloneVector ( f, measurements )
            call cloneVector ( bestGradient, x )
            call cloneVector ( bestX, x )
            call cloneVector ( candidateDX, x )
            call cloneVector ( DX, x )
            call cloneVector ( gradient, x )
d730 3
@


2.24
log
@Allocate and deallocate fmStat%rows here
@
text
@d29 1
a29 1
    & S_forwardModel, S_sids, S_matrix, S_subset, S_retrieve, S_time
d41 1
d69 1
a69 1
       "$Id: RetrievalModule.f90,v 2.23 2001/04/28 01:47:17 vsnyder Exp $"
d208 2
d730 3
@


2.23
log
@Don't try to create initial value for state
@
text
@a12 1
use VectorsModule, only: Dump
d68 1
a68 1
       "$Id: RetrievalModule.f90,v 2.22 2001/04/26 23:43:23 vsnyder Exp $"
d407 2
d428 4
a442 1
                nullify ( fmStat%rows )
a487 1
                nullify ( fmStat%rows )
a493 1
call dump ( (/ x, fwdModelExtra, f /), details=0 )
a512 1
                call deallocate_test ( fmStat%rows, 'FmStat%rows', moduleName )
d645 1
d727 3
@


2.22
log
@Remove forwardModelIn from retrieve spec
@
text
@d13 1
d69 1
a69 1
       "$Id: RetrievalModule.f90,v 2.21 2001/04/26 19:48:20 livesey Exp $"
a420 9
            ! Create initial guess for X.  Use Apriori if we have it, else
            ! zero is probably as good a guess as anything.
            if ( got(f_apriori) ) then
              call copyVector ( x, apriori ) ! x := apriori
            else
              do j = 1, size(x%quantities)
                x%quantities(j)%values = 0.0_rk
              end do ! j
            end if
d446 2
a447 2
                  call forwardModel ( configDatabase(configIndices(k)), &
                    & x, fwdModelExtra, f, fmw, fmStat )
d451 1
a451 1
                  call destroyVectorValue ( f )  ! free the space
d491 1
d493 2
a494 2
                  call forwardModel ( configDatabase(configIndices(k)), &
                    & x, fwdModelExtra, f, fmw, fmStat, jacobian )
d508 2
a509 2
                  call clearMatrix ( jacobian )  ! free the space
                  call destroyVectorValue ( f )  ! free the space
d725 3
@


2.21
log
@Now uses ForwardModelWrappers
@
text
@d22 8
a29 8
  use Init_Tables_Module, only: f_apriori, f_aprioriScale, f_channels, &
    & f_criteria, f_columnScale, f_covariance, f_diagonal, f_diagonalOut, &
    & f_forwardModel, f_fwdModelIn, f_fwdModelExtra, f_fwdModelOut, f_jacobian, &
    & f_maxIterations, f_measurements, f_method, f_outputCovariance, &
    & f_quantity, f_state, f_test, f_toleranceA, f_toleranceF, &
    & f_toleranceR, f_weight, field_first, field_last, &
    & l_apriori, l_covariance, l_newtonian, l_none, l_norm, &
    & s_forwardModel, s_sids, s_matrix, s_subset, s_retrieve, s_time
d68 1
a68 1
       "$Id: RetrievalModule.f90,v 2.20 2001/04/26 02:53:37 vsnyder Exp $"
a124 1
    type(vector_T), pointer :: FwdModelIn
d186 1
a186 1
    nullify ( apriori, configIndices, covariance, fwdModelIn, fwdModelOut )
a288 2
          case ( f_fwdModelIn )
            fwdModelIn => vectorDatabase(decoration(decoration(subtree(2,son))))
d455 1
a455 1
                    & fwdModelIn, fwdModelExtra, f, fmw, fmStat )
d501 1
a501 2
                    & fwdModelIn, fwdModelExtra, f, fmw, fmStat, &
                    & jacobian )
d732 3
@


2.20
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d19 1
a19 1
  use ForwardModelInterface, only: ForwardModel
d68 1
a68 1
       "$Id: $"
d71 1
a71 1
       "$RCSfile: $"
d736 3
@


2.19
log
@Copy model's final radiance to fwdModelOut
@
text
@d27 1
a27 1
    & f_toleranceR, f_weight, field_first, field_indices,field_last, &
d29 2
a30 2
    & s_forwardModel, s_sids, s_matrix, s_subset, s_retrieve, s_time, &
    & spec_indices
d66 7
a72 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=130), private :: Id = &
    & "$Id: RetrievalModule.f90,v 2.18 2001/04/26 01:00:01 vsnyder Exp $"
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: RetrievalModule.f90,v $"
  !---------------------------------------------------------------------------
d736 3
@


2.18
log
@Get the Jacobian's row block from fmStat%rows, cosmetic changes
@
text
@d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.17 2001/04/21 01:44:43 vsnyder Exp $"
a455 2
!??? Should we copy the relevant bits of F into FwdModelOut if
!??? FwdModelOut exists?  Or is this only useful in the SIDS case?
a501 2
!??? Should we copy the relevant bits of F into FwdModelOut if
!??? FwdModelOut exists?  Or is this only useful in the SIDS case?
d662 1
d735 3
@


2.17
log
@Make the timing message prettier
@
text
@d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.16 2001/04/19 23:56:23 livesey Exp $"
d456 2
d459 1
a459 1
                    & fwdModelIn, fwdModelExtra, fwdModelOut, fmw, fmStat )
a460 2
!??? How do we know what part of F and Measurements to use for this MAF ???
!??? And isn't it actually FwdModelOut, not F, that ought to be used?
d499 1
a499 1
                do while (.not. fmStat%finished )
d504 2
d507 1
a507 1
                    & fwdModelIn, fwdModelExtra, fwdModelOut, fmw, fmStat, &
d510 8
a517 7
!??? Need to get rowBlock from MAF somehow
!??? How do we know what part of F and Measurements to use for this MAF ???
!??? And isn't it actually FwdModelOut, not F, that ought to be used?
                  call subtractFromVector ( f, measurements, &
                    & jacobian%row%quant(rowBlock), &
                    & jacobian%row%inst(rowBlock) )
                  call fillExtraCol ( jacobian, f, rowBlock )
d525 1
d527 2
a528 2
                ! This is the RHS of the normal equations J**T * J *
                ! "Candidate DX" = -J**T * F:
d738 3
@


2.16
log
@New fmStat
@
text
@d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.15 2001/04/13 21:40:58 vsnyder Exp $"
d725 1
a725 1
      call output ( "Timing for Retrieve =" )
d734 3
@


2.15
log
@Periodic commit -- stuff about looping over configs
@
text
@d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.14 2001/04/12 01:50:21 vsnyder Exp $"
d444 6
a449 2
                !                             newHydros maf finished
                fmStat = ForwardModelStatus_T(.true.,   0,  .false.)
d492 6
a497 2
                !                             newHydros maf finished
                fmStat = ForwardModelStatus_T(.true.,   0,  .false.)
d734 3
@


2.14
log
@Work on getting a posteriori covariance
@
text
@d13 1
d20 2
d42 1
a42 1
  use MoreTree, only: Get_Boolean, Get_Spec_ID
d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.13 2001/04/10 02:46:17 livesey Exp $"
d76 2
a77 2
! subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, FwdModelConfig )
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, configDatabase )
d87 1
a87 1
    type(forwardModelConfig_T), dimension(:), pointer :: configDatabase
d103 1
d121 2
a122 1
    integer :: FwdModelConfigs          ! Tree node index
d186 1
a186 1
    nullify ( apriori, covariance, fwdModelIn, fwdModelOut )
d217 1
a217 1
          field = decoration(subtree(1,son)) ! tree_checker prevents duplicates
d261 1
a261 1
          field = decoration(subtree(1,son)) ! tree_checker prevents duplicates
d268 1
a268 1
          case ( f_covariance ) ! of a priori
d284 5
a288 1
            fwdModelConfigs = son
d439 1
a439 1
              select case ( nwt_flag ) ! >0 means "Done", <0 means "Continue"
d443 19
a461 6
                ! VAN HAS TO WORRY ABOUT THIS LATER AS MULTIPLE FWDMODELCONFIGs !???
                !call forwardModel ( fwdModelConfig, fwdModelExtra, fwdModelIn, &
                !  fwdModelOut=fwdModelOut )
                call subtractFromVector ( f, measurements )
                aj%fnorm = sqrt(f .dot. f)
                call destroyVectorValue ( f )  ! free the space
d488 15
a502 4
                do rowBlock = 1, jacobian%row%nb
                  ! VAN HAS TO WORRY ABOUT THIS LATER AS MULTIPLE FWDMODELCONFIGs !???
                  ! call forwardModel ( fwdModelConfig, fwdModelExtra, &
                  !   & fwdModelIn, jacobian, rowBlock, fwdModelOut )
d513 1
a513 1
                end do
d654 1
d726 3
@


2.13
log
@Working version, no more FMI/TFMI
@
text
@d29 3
a31 2
  use MatrixModule_1, only: AddToMatrixDatabase, CholeskyFactor, ClearMatrix, &
    & ColumnScale, CopyMatrixValue, CreateEmptyMatrix, DestroyMatrix, &
d36 1
a36 1
    & MultiplyMatrixVector, RowScale, ScaleMatrix, SolveCholesky, &
d65 1
a65 1
    & "$Id: RetrievalModule.f90,v 2.12 2001/04/07 01:50:48 vsnyder Exp $"
d521 4
a524 1
                factored%m%block => normalEquations%m%block ! to save space
d589 9
a597 3
              ! ??? Subtract sum of Levenberg-Marquardt updates and   ???
              ! ??? a priori covariance matrix from normal equations, ???
              ! ??? and re-factor them.
d599 1
d692 3
@


2.12
log
@Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
some related stuff to fwdmdl/ForwardModelConfig.
@
text
@a51 4
  !??? The next USE statement is Temporary for l2load:
  use L2_TEST_STRUCTURES_M, only: FWD_MDL_CONFIG, FWD_MDL_INFO, &
    & TEMPORARY_FWD_MDL_INFO

d64 1
a64 1
    & "$Id: RetrievalModule.f90,v 2.11 2001/03/17 00:45:15 livesey Exp $"
d73 1
a73 2
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, configDatabase, &
    & fmc, fmi, tfmi ) !??? Last line temporary
a84 6
    !??? Begin temporary stuff to start up the forward model
    type(fwd_mdl_config) :: FMC
    type(fwd_mdl_info), dimension(:), pointer :: FMI
    type(temporary_fwd_mdl_info), dimension(:), pointer :: TFMI
    !??? End of temporary stuff to start up the forward model

d616 1
a616 2
        call sids ( key, VectorDatabase, MatrixDatabase, configDatabase, &
          & fmc, fmi, tfmi ) !??? Last line is temporary
d681 4
@


2.11
log
@Moved to new ForwardModelConfig_T
@
text
@d17 2
a18 1
  use ForwardModelInterface, only: ForwardModel, ForwardModelConfig_T
d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.10 2001/03/15 21:18:57 vsnyder Exp $"
d693 3
@


2.10
log
@Use Get_Spec_ID instead of decoration(subtree...
@
text
@d17 1
a17 2
  use ForwardModelInterface, only: ForwardModel, ForwardModelInfo_T, &
    & ForwardModelSetup
d20 1
a20 1
    & f_fwdModelIn, f_fwdModelExtra, f_fwdModelOut, f_jacobian, &
d67 1
a67 1
    & "$Id: RetrievalModule.f90,v 2.9 2001/03/09 03:05:05 vsnyder Exp $"
d75 2
a76 2
! subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, FwdModelInfo )
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, FwdModelInfo, &
d87 1
a87 1
    type(forwardModelInfo_T), intent(inout) :: FwdModelInfo ! From ForwardModelSetup
d89 5
a93 5
!??? Begin temporary stuff to start up the forward model
  type(fwd_mdl_config) :: FMC
  type(fwd_mdl_info), dimension(:), pointer :: FMI
  type(temporary_fwd_mdl_info), dimension(:), pointer :: TFMI
!??? End of temporary stuff to start up the forward model
d126 1
a210 5
      case ( s_forwardModel )
        ! ??? This a ForwardModelSetup for one chunk ???
        ! ??? Do we need a ForwardModelGlobalSetup?  ???
        call forwardModelSetup ( key, vectorDatabase, matrixDatabase, &
          & fwdModelInfo )
d287 2
d443 3
a445 2
                call forwardModel ( fwdModelInfo, fwdModelExtra, fwdModelIn, &
                  fwdModelOut=fwdModelOut )
d476 3
a478 2
                  call forwardModel ( fwdModelInfo, fwdModelExtra, &
                    & fwdModelIn, jacobian, rowBlock, fwdModelOut )
d626 1
a626 1
        call sids ( key, VectorDatabase, MatrixDatabase, fwdModelInfo, &
d692 3
@


2.9
log
@Correct identification for timing
@
text
@d38 1
a38 1
  use MoreTree, only: Get_Boolean
d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.8 2001/03/08 03:23:09 vsnyder Exp $"
d209 1
a209 1
      spec = decoration(subtree(1,decoration(subtree(1,key))))
d693 3
@


2.8
log
@More stuff to work with L2_Load
@
text
@d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.7 2001/03/07 23:59:52 vsnyder Exp $"
d684 1
a684 1
      call output ( "Timing for MLSL2Join =" )
d693 3
@


2.7
log
@Add stuff for SIDS.
@
text
@d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.6 2001/02/22 18:54:05 vsnyder Exp $"
d76 3
a78 2
! subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase )
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase, fmc, fmi, tfmi )
d88 1
a128 1
    type(forwardModelInfo_T) :: FwdModelInfo
d627 2
a628 1
        call sids ( key, VectorDatabase, MatrixDatabase, fmc, fmi, tfmi )
d693 3
@


2.6
log
@Periodic commit.  Still working on the output covariance.
@
text
@a16 1
  use Declaration_Table, only: Num_Value
d21 6
a26 5
    & f_fwdModelIn, f_fwdModelOut, f_jacobian, f_maxIterations, &
    & f_measurements, f_method, f_outputCovariance, f_quantity, f_state, &
    & f_test, f_toleranceA, f_toleranceF, f_toleranceR, f_weight, field_first, &
    & field_indices,field_last, l_apriori, l_covariance, l_newtonian, l_none, &
    & l_norm, s_forwardModel, s_matrix, s_subset, s_retrieve, &
d41 1
d46 1
a46 1
  use Tree_Types, only: N_named, N_set_one
d52 4
d68 1
a68 1
    & "$Id: RetrievalModule.f90,v 2.5 2001/02/22 01:57:02 vsnyder Exp $"
d76 2
a77 1
  subroutine Retrieve ( Root, VectorDatabase, MatrixDatabase )
d79 3
a81 2
  ! The "Retrieve" section can have ForwardModel, Matrix, Subset or Retrieve
  ! specifications.
d88 6
d125 1
d162 1
d165 1
d191 1
d293 2
d445 2
a446 1
                call forwardModel ( fwdModelInfo, fwdModelIn, f=f )
d477 2
a478 2
                  call forwardModel ( fwdModelInfo, fwdModelIn, jacobian, f, &
                    & rowBlock, fwdModelOut )
d625 9
d638 1
d678 8
d691 3
@


2.5
log
@Periodic commit -- working on getting output covariance matrix.
@
text
@d26 1
a26 1
    & l_norm,l_true, s_forwardModel, s_matrix, s_subset, s_retrieve, &
d32 2
a33 1
    & GetDiagonal, GetFromMatrixDatabase, GetVectorFromColumn, Matrix_T, &
d63 1
a63 1
    & "$Id: RetrievalModule.f90,v 2.4 2001/02/09 19:30:16 vsnyder Exp $"
d578 1
a578 1
              call invertCholesky ( factored, outputCovariance )
d653 3
@


2.4
log
@Move checking for required and duplicate fields to init_tables_module
@
text
@d21 6
a26 6
    & f_criteria, f_columnScale, f_covariance, f_diagonal, f_fwdModelIn, &
    & f_fwdModelOut, f_jacobian, f_maxIterations, f_measurements, f_method, &
    & f_outputCovariance, f_quantity, f_state, f_test, f_toleranceA, &
    & f_toleranceF, f_toleranceR, f_weight, field_first, field_indices, &
    & field_last, l_apriori, l_covariance, l_newtonian, l_none, l_norm, &
    & l_true, s_forwardModel, s_matrix, s_subset, s_retrieve, &
d37 1
d62 1
a62 1
    & "$Id: RetrievalModule.f90,v 2.3 2001/02/08 00:56:55 vsnyder Exp $"
d72 2
a73 1
  ! The "Retrieve" section can have Matrix, Subset or Retrieve specifications.
d95 1
d100 6
a105 1
    logical :: Diagonal                 ! "We only want the diagonal of the
d167 1
a167 2
    integer, parameter :: NoField = Inconsistent + 1   ! Required field missing
    integer, parameter :: NoFields = NoField + 1  ! No fields are allowed
d169 1
a169 2
    integer, parameter :: NotRange = notExtra + 1 ! A field is a range
    integer, parameter :: NotSPD = notRange + 1   ! Not symmetric pos. definite
d193 2
d270 3
a272 6
            son = subtree(2,son)
            if ( node_id(son) == n_set_one ) then
              diagonal = .true.
            else
              diagonal = decoration(subtree(2,son)) == l_true
            end if
a278 4
          case ( f_maxIterations )
            call expr ( subtree(2,son), units, value, type )
            if ( type /= num_value ) call announceError ( notRange, field )
            maxIterations = value(1)
d287 2
a288 1
          case ( f_aprioriScale, f_toleranceA, f_toleranceF, f_toleranceR )
a289 1
            if ( type /= num_value ) call announceError ( notRange, field )
d293 2
d416 1
a416 1
                & covarianceXApriori )
d436 10
a445 1
                  call copyMatrixValue ( normalEquations%m, covariance%m )
d562 2
a563 1
                exit ! unless you have a really good reason to continue
d574 6
a579 2
              ! ??? Compute the covariance matrix
              if ( diagonal ) then
d630 1
a630 1
      case ( inconsistent, noField, notExtra, notRange, notSPD )
a637 2
        case ( noField )
          call output ( ' is not specified.', advance='yes' )
a640 2
        case ( notRange )
          call output ( ' shall not be a range.', advance='yes' )
d652 3
@


2.3
log
@Periodic commit.  Still needs work.
@
text
@d28 1
d61 1
a61 1
    & "$Id: RetrievalModule.f90,v 2.2 2001/01/26 19:01:47 vsnyder Exp $"
a163 1
    integer, parameter :: Twice = notSPD + 1      ! A field appears twice
d199 1
a199 2
          field = decoration(subtree(1,son))
          if ( got(field) ) call announceError ( twice, field )
a215 6
          son = key ! in case it's needed for error messages -- see announceError
          if ( .not. got(f_criteria) ) call announceError ( noField, f_criteria )
          if ( .not. got(f_quantity) ) call announceError ( noField, f_quantity )
          if ( .not. got(f_test) ) call announceError ( noField, f_test )
        end if
        if ( error == 0 ) then
d243 1
a243 2
          field = decoration(subtree(1,son))
          if ( got(field) ) call announceError ( twice, field )
a305 5
        ! Check that we have all of the necessary fields
        son = key ! in case it's needed for error messages -- see announceError
        if ( .not. got(f_fwdModelIn) ) call announceError ( noField, f_fwdModelIn )
        if ( .not. got(f_measurements) ) call announceError ( noField, f_measurements )
        if ( .not. got(f_state) ) call announceError ( noField, f_state )
a596 1
      integer :: Source
d599 3
a601 5
      source = source_ref ( son )
      call output ( 'At line '  )
      call output ( mod(source,256) )
      call output ( ', column ' )
      call output ( source/256 )
d610 1
a610 1
        call output ( ': No fields are allowed for a ' )
d613 2
a614 2
      case ( inconsistent, noField, notExtra, notRange, notSPD, twice )
        call output ( ': the field ' )
a630 2
        case ( twice )
          call output ( ' shall not appear twice.', advance='yes' )
d639 3
@


2.2
log
@More nearly complete, except for forward model interface and minor things
having to do with creating subset masks.  Look for ??? in comments.
@
text
@d18 2
d26 2
a27 1
    & l_true, s_matrix, s_subset, s_retrieve
d38 2
d60 1
a60 1
    & "$Id: RetrievalModule.f90,v 2.1 2001/01/10 21:04:13 vsnyder Exp $"
d102 3
a104 1
    type(vector_T), pointer :: FwdModelIn, FwdModelOut
d169 1
d186 3
d190 2
a191 1
        if ( nsons(key) /= 1 ) call announceError ( noFields )
d194 1
d196 1
d199 1
a199 1
          field = decoration(subtree(1,decoration(subtree(1,son))))
d204 1
a204 1
            channels = son
d206 1
a206 1
            criteria = son
d208 1
a208 1
            quantity = son
d210 1
a210 1
            test = son
d238 1
d240 1
d250 1
a250 1
          field = decoration(subtree(1,decoration(subtree(1,son))))
d435 1
a435 1
                call forwardModelRadiances ( fwdModelIn, f )
d457 2
a458 2
                  call forwardModel ( fwdModelIn, jacobian, f, rowBlock, &
                    & fwdModelOut )
d573 5
d586 1
d599 1
d603 1
d610 1
a610 1
      integer :: MyField, Source
a612 2
      myField = field
      if ( present(fieldIndex) ) myField = fieldIndex
d626 3
a628 1
        call output ( ': No fields are allowed.' )
d631 1
a631 1
        call display_string ( field_indices(myField) )
d657 4
@


2.1
log
@Initial (incomplete) submission
@
text
@d17 16
a32 8
  use Declaration_Table, only: Num_Value, Range, Str_Range, Str_Value
  use Init_Tables_Module, only: f_apriori, f_channels, f_criteria, &
    & f_covariance, f_fwdModelIn, f_fwdModelOut, f_jacobian, f_maxIterations, &
    & f_measurements, f_method, f_outputCovariance, f_quantity, f_state, &
    & f_test, f_toleranceA, f_toleranceF, f_toleranceR, f_weight, &
    & field_first, field_indices, field_last, l_newtonian, s_subset, &
    & s_retrieve, s_vector
  use MatrixModule_1, only: Matrix_Database_T
d35 8
a42 5
  use Tree, only: Decoration, Node_ID, Nsons, Source_Ref, Sub_Rosa, Subtree
  use Tree_Types, only: N_named, N_spec_args
  use VectorsModule, only: CopyVector, CreateMask, DestroyVectorMask, &
    & GetVectorQuantityIndexByName, operator(.DOT.), ScaleVector, SetMask, &
    & Vector_T
d55 1
a55 1
    & "$Id: $"
d57 1
a57 1
    & "$RCSfile: $"
d64 3
d70 1
a70 1
    type(matrix_Database_T), dimension(:), intent(in) :: MatrixDatabase
d72 1
a72 1
    ! Local variables
d74 4
a77 1
    integer :: Apriori                  ! Index in VectorDatabase
d83 5
a87 2
    integer :: Covariance               ! Index in MatrixDatabase of the
                                        ! covariance of Apriori
a89 1
    logical :: Diagonal                 ! "outputCovariance is a vector"
d91 2
d95 1
d97 1
a97 1
    integer :: FwdModelIn, FwdModelOut  ! Indices in VectorDatabase
d102 3
a104 1
    integer :: Jacobian                 ! Index in MatrixDatabase
d109 1
a109 1
    integer :: Measurements             ! Index in VectorDatabase
d112 3
d117 1
d122 1
a122 2
    integer :: OutputCovariance         ! Index in VectorDatabase if Diagonal,
                                        ! else index in MatrixDatabase
d126 2
d129 2
a130 2
    integer :: Spec                     ! s_subset or s_retrieve
    integer :: State                    ! Index in VectorDatabase
d141 1
d144 1
a144 1
    integer :: Weight                   ! Index in VectorDatabase
d148 9
a156 3
    integer, parameter :: NoField = 1             ! A required field is missing
    integer, parameter :: NotRange = noField + 1  ! A field is a range
    integer, parameter :: Twice = notRange + 1    ! A field appears twice
d159 2
d172 1
a172 1
      ! Key now indexes an n_spec_args vertex.  See "Configuration file
d178 4
d186 1
a186 1
          if ( got(field) ) call announceError ( twice )
d207 2
d225 2
d235 1
a235 1
          if ( got(field) ) call announceError ( twice )
d239 3
a241 1
            apriori = decoration(decoration(subtree(2,son)))
d243 17
a259 1
            covariance = decoration(decoration(subtree(2,son)))
d261 1
a261 1
            fwdModelIn = decoration(decoration(subtree(2,son)))
d263 1
a263 1
            fwdModelOut = decoration(decoration(subtree(2,son)))
d265 1
a265 1
            jacobian = decoration(decoration(subtree(2,son)))
d268 1
a268 1
            if ( type /= num_value ) call announceError ( notRange )
d271 1
a271 1
            measurements = decoration(decoration(subtree(2,son)))
d275 1
a275 3
            outputCovariance = decoration(decoration(subtree(2,son)))
            diagonal = decoration(subtree(1,decoration( &
                       & subtree(1,decoration(subtree(2,son)))))) == s_vector
d277 2
a278 2
            state = decoration(decoration(subtree(2,son)))
          case ( f_toleranceA, f_toleranceF, f_toleranceR )
d280 1
a280 1
            if ( type /= num_value ) call announceError ( notRange )
d282 2
d292 1
a292 1
            weight = decoration(decoration(subtree(2,son)))
d297 25
d323 59
a381 6
          ! Check that we have all of the necessary fields
          son = key ! in case it's needed for error messages -- see announceError
          if ( .not. got(f_fwdModelIn) ) call announceError ( noField, f_fwdModelIn )
          if ( .not. got(f_jacobian) ) call announceError ( noField, f_jacobian )
          if ( .not. got(f_measurements) ) call announceError ( noField, f_measurements )
          if ( .not. got(f_state) ) call announceError ( noField, f_state )
d391 2
a392 2
            x => vectorDatabase(state)
            call cloneVector ( f, vectorDatabase(measurements) )
d401 1
a401 1
              call copyVector ( x, vectorDatabase(apriori) )
d407 5
a416 1
              ! IF ( too many function values ) EXIT
d418 5
a422 3
              ! Compute f(x)
                call subtractFromVector ( f, vectorDatabase(measurements) )
                aj%fnorm = sqrt(f .dot. f) ! L2Norm(f)
a423 1
              ! Compute the Jacobian matrix J if you feel like it
d425 65
a489 12
              ! Compute the Jacobian matrix J if you didn't do it when NWT_FLAG
              ! was NF_EVALF:
              !   J(K,L) = Partial of F(K) / W.R.T. X(L), K = 1, NF, L = 1, NX
              ! Triangularize J, and compute (negative of the) gradient =
              ! -(Jacobian)**T * F
              ! Set
              !   AJ%DIAG = element on diagonal with smallest absolute value,
              !           after factoring,
              !   AJ%AJN = maximum L1 norm of column in upper triangle
              !           after factoring,
              !   AJ%FNMIN = L2 norm of residual not in the column space of
              !           the Jacobian,
d492 20
a511 4
              ! Apply Marquardt stabilization with parameter = AJ%SQ, and
              ! solve for "candidate DX" = -(Jacobian)**(-1) * F
              ! Set AJ%FNMIN as for NWT_FLAG = NF_EVALJ, but taking account
              ! of Levenberg-Marquardt stabilization.
d526 1
a526 1
              !     dx = aj%gfac * "Best Gradient":
d538 1
a538 1
              ! dx = aj%cait * candidateDX
d541 3
a543 3
              ! IF ( NWT_FLAG == NF_TOO_SMALL ) THEN
              !   Take special action if requested accuracy is critical
              ! END IF
d545 2
a546 2
              ! Convergence to desired solution.  Do whatever you want to
              ! with the solution.
d549 4
a552 4
              ! There is probably an error in the way F or J is computed.
              ! A warning has been printed by the error processor.
              ! IF ( you have confidence in F and J ) CYCLE
              ! STOP
d554 1
a554 1
!             IF ( you want to return to a previous best X ) NWT_FLAG = 0
d557 1
a557 1
            ! Clean up the temporary vectors, so we don't have a memory leak
d564 1
d566 6
d582 2
a583 1
    subroutine AnnounceError ( Code, FieldIndex )
d585 1
a585 1
      integer, intent(in), optional :: FieldIndex ! f_...
d591 5
d597 9
a605 6
      case ( noField, notRange, twice )
        source = source_ref ( son )
        call output ( 'At line '  )
        call output ( mod(source,256) )
        call output ( ', column ' )
        call output ( source/256 )
d609 4
d614 4
a617 1
          call output ( ' is not specified', advance='yes' )
d619 4
a622 1
          call output ( ' shall not be a range', advance='yes' )
d624 1
a624 1
          call output ( ' shall not appear twice', advance='yes' )
d632 4
a635 1
! $Log: $
@

