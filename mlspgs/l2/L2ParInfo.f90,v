head	2.70;
access;
symbols
	v5-02-NRT-19:2.70
	v6-00:2.70
	v5-02-NRT-18:2.70
	v5-02:2.70
	v5-01-NRT-17:2.70
	v5-01-NRT-16:2.70
	v5-01-NRT-15:2.70
	v5-01-NRT-14:2.70
	neuralnetworks-1-0:2.70.0.8
	cfm-single-freq-0-1:2.70.0.6
	v5-01:2.70
	v5-00:2.70
	v4-23-TA133:2.70.0.4
	mus-emls-1-70:2.70.0.2
	rel-1-0-englocks-work:2.69.0.2
	VUMLS1-00:2.67
	VPL1-00:2.67
	V4-22-NRT-08:2.67
	VAM1-00:2.65
	V4-21:2.64.0.2
	V4-13:2.64
	V4-12:2.62
	V4-11:2.62
	V4-10:2.62
	V3-43:2.53
	M4-00:2.60
	V3-41:2.53
	V3-40-PlusGM57:2.53.0.2
	V2-24-NRT-04:2.49
	V3-33:2.54
	V2-24:2.49
	V3-31:2.54
	V3-30-NRT-05:2.54
	cfm-01-00:2.53
	V3-30:2.53
	V3-20:2.53
	V3-10:2.53
	V2-23-NRT-02:2.49
	V2-23:2.49
	V2-22-NRT-01:2.49
	V2-22:2.49
	V2-21:2.48
	V2-20:2.47
	V2-11:2.47
	V2-10:2.47
	V2-00:2.46
	V1-51:2.42
	V1-50:2.42
	V1-45:2.37
	V1-44:2.37
	V1-43:2.36
	V1-32:2.36
	V1-31:2.35
	V1-30:2.32
	V1-13:2.27
	V1-12:2.27
	V1-11:2.27
	V1-10:2.27
	newfwm-feb03:2.27.0.2
	V1-04:2.11
	V1-03:2.11
	V1-02:2.11
	JointForwardModel:2.12.0.2
	V1-00:2.10
	newfwm-sep01:2.7.0.2
	V0-7:2.7;
locks; strict;
comment	@# @;


2.70
date	2018.04.19.01.14.16;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2018.02.09.01.07.07;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2017.12.22.00.31.05;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2016.03.23.20.12.42;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2016.02.29.19.50.26;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2015.03.28.02.48.02;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2014.09.05.01.05.03;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2014.09.05.00.49.06;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2013.02.14.19.03.32;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2012.07.10.15.19.45;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2012.07.02.20.39.59;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2012.06.27.18.10.41;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2012.03.28.20.05.10;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2011.05.09.18.20.55;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2010.08.06.23.08.48;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2009.07.21.20.35.38;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2009.06.16.17.41.37;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2007.10.24.00.16.38;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2007.04.03.20.55.22;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2007.01.12.00.38.57;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2006.06.24.23.10.00;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2005.03.24.21.20.33;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2005.03.15.23.53.03;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2005.02.03.19.07.35;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2005.01.13.00.01.31;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2005.01.07.17.27.21;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2004.12.14.21.53.30;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2004.09.16.23.57.32;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2004.09.16.00.18.03;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2004.08.05.22.47.47;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2004.01.22.00.56.35;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2004.01.02.23.36.00;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2003.12.11.23.00.58;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2003.11.14.23.37.13;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2003.08.11.23.23.31;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2003.08.01.20.26.53;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2003.07.07.17.32.10;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2003.06.20.19.38.25;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2003.05.12.19.04.50;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2003.01.27.17.18.58;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2003.01.17.21.54.21;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2002.12.11.01.58.33;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2002.11.23.00.13.18;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2002.10.17.18.19.13;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2002.10.08.20.33.51;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2002.10.08.17.40.56;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2002.10.08.17.36.21;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2002.10.06.22.22.47;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2002.10.06.01.10.17;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2002.10.05.00.43.20;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2002.07.19.06.07.32;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2002.07.17.20.02.17;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2002.07.17.20.01.42;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2002.07.17.19.54.52;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2002.05.22.00.48.28;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2002.04.24.16.53.50;	author livesey;	state Exp;
branches
	2.11.2.1;
next	2.10;

2.10
date	2002.03.21.01.23.36;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.10.30.01.45.21;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.09.08.00.21.44;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.05.30.23.53.54;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.05.29.20.42.18;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.05.29.20.39.57;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2001.05.26.00.20.45;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.05.25.05.00.07;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.05.25.01.03.47;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.05.23.21.59.54;	author livesey;	state Exp;
branches;
next	;

2.11.2.1
date	2002.05.22.23.14.33;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.70
log
@Remove USE statements for unused names
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module L2ParInfo
  ! This module provides definitions needed by L2Parallel and other modules to
  ! manage the parallel aspects of the L2 code.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Dump_0, only: Dump
  use HighOutput, only: OutputNamedValue
  use Io_Stuff, only: Get_Lun
  use Machine, only: Usleep
  use MLSFinds, only: Findfirst
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, PVMErrorMessage
  use MLSStats1, only: Allstats
  use MLSStrings, only: Lowercase
  use MLSStringLists, only: Getuniqueints, Getuniquestrings, NumstringElements, &
    & Removenumfromlist, StringElement, Switchdetail
  use MorePVM, only: PVMpackstringindex, PVMunpackstringindex
  use Output_M, only: Beep, Output
  use PVM, only: Infotag, &
    & PVMfmytid, PVMfinitsend, PVMf90pack, PVMfsend, &
    & PVMDatadefault, PVMf90unpack, NextPVMarg, PVMtaskexit, Sig_Abouttodie
  use PVMidl, only: PVMidlpack
  use QuantityPVM, only: PVMsendquantity
  use Toggles, only: Switches
  use Vectorsmodule, only: VectorValue_T

  implicit none
  private

  public :: L2parallelinfo_T, Parallel, Machine_T
  public :: AddmachinenametoDatabase, AddmachinetoDatabase
  public :: Initparallel, Closeparallel
  public :: Slavejoin
  public :: Getnicetidstring, Slavearguments
  public :: Accumulateslavearguments, Logdirectwriterequest
  public :: Sniplastslaveargument, Transmitslavearguments
  public :: Finisheddirectwrite, Machinenamelen, Getmachinenames, Getmachines
  public :: Fwmslavegroup, Directwriterequest_T
  public :: Inflatedirectwriterequestdb, Waitfordirectwritepermission
  public :: Compactdirectwriterequestdb, Dump
  public :: SigToName, TagToName
  
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L2ParInfo.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! Parameters

  ! So requests don't pile up delaying notification of the finishings
  integer, parameter :: DELAYFOREACHSLAVEDWREQUEST   = 0 ! unneeded 200000
  ! To leave time for slaves to flush stdout before master closes pvm
  integer, parameter :: DELAYFOREACHSLAVESTDOUTBUFFER   = 500
  integer, parameter :: FIXDELAYFORSLAVESTDOUTBUFFER   = 500000
  integer, public, parameter :: CHUNKTAG   = InfoTag + 1  ! Master => slave: chunkinfo
  integer, public, parameter :: NOTIFYTAG  = ChunkTag + 1  ! pvm => master: Slave exited
  integer, public, parameter :: PETITIONTAG  = NotifyTag + 1 ! master => l2q
  integer, public, parameter :: GRANTEDTAG  = PetitionTag + 1 ! l2q => master
  integer, public, parameter :: MASTERDUMPTAG  = GrantedTag + 1 ! l2q => master
  integer, public, parameter :: MACHINEFIXEDTAG = 800
  integer, public, parameter :: GIVEUPTAG  = 999

  integer, public, parameter :: SIG_TOJOIN = SIG_AboutToDie + 1
  integer, public, parameter :: SIG_FINISHED = SIG_toJoin + 1
  integer, public, parameter :: SIG_ACKFINISH = SIG_finished + 1
  integer, public, parameter :: SIG_REGISTER = SIG_AckFinish + 1
  integer, public, parameter :: SIG_REQUESTDIRECTWRITE = SIG_Register + 1
  integer, public, parameter :: SIG_DIRECTWRITEGRANTED = SIG_RequestDirectWrite + 1
  integer, public, parameter :: SIG_DIRECTWRITEFINISHED = SIG_DirectWriteGranted + 1
  integer, public, parameter :: SIG_NEWSETUP = SIG_DirectWriteFinished + 1
  integer, public, parameter :: SIG_RUNMAF = SIG_NewSetup + 1
  integer, public, parameter :: SIG_SENDRESULTS = SIG_RunMAF + 1
  integer, public, parameter :: SIG_REQUESTHOST = SIG_SendResults + 1
  integer, public, parameter :: SIG_RELEASEHOST = SIG_RequestHost + 1
  integer, public, parameter :: SIG_HOSTDIED = SIG_ReleaseHost + 1
  integer, public, parameter :: SIG_THANKSHOST = SIG_HostDied + 1
  integer, public, parameter :: SIG_SWEARALLEGIANCE = SIG_ThanksHost + 1
  integer, public, parameter :: SIG_SWITCHALLEGIANCE = SIG_SwearAllegiance + 1

  integer, parameter :: MACHINENAMELEN = 64 ! Max length of name of machine

  ! Name of fwm slave group
  character (len=*), parameter :: FWMSLAVEGROUP = "MLSL2FWMSlaves"

  ! This datatype defines configuration for the parallel code
  type L2ParallelInfo_T
    logical :: fwmParallel = .false.    ! Set if we are in forward model parallel mode
    logical :: master = .false.         ! Set if this is a master task
    logical :: slave = .false.          ! Set if this is a slave task
    integer :: verbosity = 0            ! Set > 0 for extra output 
    integer :: myTid                    ! My task ID in pvm       | than a file
    integer :: masterTid                ! task ID in pvm
    integer :: noFWMSlaves              ! No. slaves in pvm system for fwm cases
    integer :: chunkNo                  ! Chunk No. if this is a slave
    integer :: Delay = 200000           ! For Usleep, no. microsecs
    character(len=132) :: pgeName="mlsl2"   ! command name, if not 'mlsl2'
    character(len=132) :: slaveFilename ! Filename with list of slaves
    character(len=132) :: executable    ! Executable filename
    character(len=132) :: submit=""     ! Submit comand for batch queue system
    ! run range in comma-separated list with possible ranges
    ! e.g. '1,2-6+2,9-11,15' expands to '1,2,4,6,9,10,11,15'
    character(len=4096) :: chunkRange='' ! if blank, runs all chunks
    ! chunks are ','-separated ints; e.g. '2,5,129'
    character(len=4096) :: failedChunks='' ! if blank, no chunks failed
    ! Machs are string list; e.g. 'c0-1,c0-66,c0-66'
    character(len=4096) :: failedMachs='' ! blank if usingSubmit
    ! Msgs are string list; e.g. 'msg 1\msg 2\..\msg n'
    character(len=8192) :: failedMsgs='' ! in same order (hopefully)
    integer :: maxFailuresPerMachine = 1 ! More than this then don't use it | staging
    integer :: maxFailuresPerChunk = 10 ! More than this then give up on getting it
    integer :: numFailedChunks = 0
    integer :: numCompletedChunks = 0
  end type L2ParallelInfo_T

  ! This enumerated type describes the state that directWrites can be in
  integer, public, parameter :: DW_INVALID = 0
  integer, public, parameter :: DW_PENDING = DW_INVALID + 1
  integer, public, parameter :: DW_INPROGRESS = DW_PENDING + 1
  integer, public, parameter :: DW_COMPLETED = DW_INPROGRESS + 1

  ! This datatype logs a directWrite request
  type DirectWriteRequest_T
    integer :: CHUNK=0                  ! Which chunk made the request
    integer :: MACHINE=0                ! What machine is that on
    integer :: NODE=0                   ! What tree node was it
    integer :: FILEINDEX=0              ! Which file was it
    integer :: TICKET=0                 ! What ticket number is it
    integer :: VALUE=0                  ! Workspace for master
    integer :: STATUS=DW_INVALID        ! One of the DW_... above
    real    :: WHENMADE
    real    :: WHENGRANTED
    real    :: WHENFINISHED = -999.99
  end type DirectWriteRequest_T

  ! This datatype describes the machines that will host parallel tasks
  type machine_T
    character(len=MACHINENAMELEN) :: name = ' '
    character(len=MACHINENAMELEN) :: master_name = ' '
    character(len=16            ) :: master_date = ' '
    integer                       :: master_tid = 0
    integer                       :: tid = 0
    integer                       :: chunk = 0
    integer                       :: jobsKilled = 0
    logical                       :: OK = .true.
    logical                       :: free = .true.
  end type machine_T

  ! Shared variables
  type (L2ParallelInfo_T), save :: parallel
  character ( len=2048 ), save :: slaveArguments = ""

  interface dump
    module procedure DumpDirectWriteRequest, DumpAllDirectWriteRequests
    module procedure Dump_Machine, Dump_Machine_DataBase
  end interface

  interface LogDirectWriteRequest
    module procedure LogDirectWriteRequest_int, LogDirectWriteRequest_str
  end interface
  
  logical, parameter :: countEmpty = .false.
  logical, parameter :: DEEBUG = .false.

contains ! ==================================================================

  ! --------------------------------------------- AccumulateSlaveArguments ------
  subroutine AccumulateSlaveArguments ( arg )
    ! This routine accumulates the command line arguments for the slaves
    character (len=*), intent(in) :: arg
    ! Executable code
    ! call NextPVMArg ( trim(arg) )
    if ( len_trim(slaveArguments) + len_trim(arg) +1 > len(slaveArguments) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Argument list for slave too long.' )
    slaveArguments = trim(slaveArguments)//' '//trim(arg)
  end subroutine AccumulateSlaveArguments
    
  ! ---------------------------------- AddMachineNameToDataBase ------------
  integer function AddMachineNameToDataBase ( DATABASE, ITEM )
    ! Add a machine name to a databsse of machine names
    ! an array of machine names

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    character(len=MachineNameLen), dimension(:), pointer :: DATABASE
    character(len=MachineNameLen), intent(in) :: ITEM
    ! Local variables
    character(len=MachineNameLen), dimension(:), pointer :: tempDatabase
    !This include causes real trouble if you are compiling in a different 
    !directory.
    include "addItemToDatabase.f9h" 

    AddMachineNameToDatabase = newSize
  end function AddMachineNameToDataBase

  ! ---------------------------------- AddMachineToDataBase ------------
  integer function AddMachineToDataBase ( DATABASE, ITEM )
    ! Add a machine to a database of machines

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    type(machine_t), dimension(:), pointer :: DATABASE
    type(machine_t), intent(in) :: ITEM
    ! Local variables
    type(machine_t), dimension(:), pointer :: tempDatabase
    !This include causes real trouble if you are compiling in a different 
    !directory.
    include "addItemToDatabase.f9h" 

    AddMachineToDatabase = newSize
  end function AddMachineToDataBase

  ! ---------------------------------------------- InitParallel -------------
  subroutine InitParallel ( chunkNo, MAFNo )
    ! This routine initialises the parallel code
    integer, intent(in) :: chunkNo      ! Chunk number asked to do.
    integer, intent(in) :: MAFNo        ! MAF number asked to do in fwmParallel mode.
    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    ! Executable code
    if ( parallel%master .or. parallel%slave ) then
      call output ( 'About to get my tid', advance='yes' )
      call PVMFMyTid ( parallel%myTid )
      call output ( 'Task ID: ' )
      call output ( trim(GetNiceTidString ( parallel%myTid ) ), advance='yes' )
    end if
    if ( parallel%slave ) then
      ! Register ourselves with the master
      ! Identify ourselves
      call PVMFInitSend ( PvmDataDefault, bufferID )
      call PVMF90Pack ( SIG_Register, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing registration' )
      call PVMF90Pack ( chunkNo, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing chunkNumber' )
      call PVMF90Pack ( MAFNo, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing MAFNumber' )
      call PVMFSend ( parallel%masterTid, InfoTag, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'sending finish packet' )
      if ( parallel%fwmParallel ) then
        call PVMFNotify ( PVMTaskExit, NotifyTag, 1, (/ parallel%masterTid /), info )
        if ( info /= 0 ) call PVMErrorMessage ( info, 'setting up notify' )
        call PVMFJoinGroup ( FWMSlaveGroup, info )
        if ( info < 0 ) &
          & call PVMErrorMessage ( info, 'Joining '//FWMSlaveGroup//' group' )
      end if
    end if
  end subroutine InitParallel

  ! --------------------------------------------- CloseParallel -------------
  subroutine CloseParallel ( noSlaves, dontWait )
    ! This routine closes down any parallel stuff

    use Toggles, only: Gen, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

    integer, intent(in) :: noSlaves     ! How many slaves
    logical, intent(in), optional :: dontWait
    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    integer :: Me = -1                  ! String index for trace

    integer :: SIGNAL                   ! From acknowledgement packet
    integer :: slave
    logical :: myDontWait

    ! Executable code

    call trace_begin ( me, "CloseParallel", cond=toggle(gen) )
    myDontWait = .false.
    if ( present(dontWait) ) myDontWait = dontWait
    if ( parallel%slave ) then
      myDontWait = .true.
      ! call MLSMessage ( MLSMSG_Info, ModuleName, &
      !  & 'About to call PVMFInitSend' )
      ! Send a request to finish
      call PVMFInitSend ( PvmDataDefault, bufferID )
      ! call MLSMessage ( MLSMSG_Info, ModuleName, &
      !  & 'About to call PVMF90Pack' )
      call PVMF90Pack ( SIG_Finished, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing finished signal' )
      ! call MLSMessage ( MLSMSG_Info, ModuleName, &
      !  & 'About to call PVMFSend' )
      call PVMFSend ( parallel%masterTid, InfoTag, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'sending finish packet' )
      ! call MLSMessage ( MLSMSG_Error, ModuleName, &
      !  & 'Hey--we did it' )
      if ( myDontWait ) go to 9
      ! Wait for an acknowledgement from the master
      call PVMFrecv ( parallel%masterTid, InfoTag, bufferID )
      if ( bufferID <= 0 ) &
        & call PVMErrorMessage ( bufferID, &
        & 'receiving finish acknowledgement' )
      call PVMF90Unpack ( signal, info )
      if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'unpacking finish acknowledgement')
      if ( signal /= SIG_AckFinish ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Got unrecognised signal from master' )
      if ( DEEBUG ) call output ( 'Master acknowledged our completion', advance='yes' )
      if ( DEEBUG ) call Beep ( 'Master acknowledged our completion' )
    else if ( parallel%master ) then
      call usleep(FIXDELAYFORSLAVESTDOUTBUFFER)
      if ( noSlaves < 1 ) go to 9
      do slave=1, noSlaves+40
        call usleep(DELAYFOREACHSLAVESTDOUTBUFFER)
      end do
    end if
9   continue
    call trace_end ( "CloseParallel", cond=toggle(gen) )
  end subroutine CloseParallel

  ! ----------------------------------- CompactDirectWriteRequestDB --------
  subroutine CompactDirectWriteRequestDB ( database, noRequests )
    type ( DirectWriteRequest_T), dimension(:), pointer :: DATABASE
    integer, intent(out) :: NOREQUESTS
    ! Move all the non completed requests up the list
    noRequests = count ( database%status /= DW_Completed .and. &
      & database%status /= DW_Invalid )
    database ( 1 : noRequests ) = pack ( database, &
      & database%status /= DW_Completed .and. database%status /= DW_Invalid )
    database(noRequests+1:)%status = DW_Invalid
  end subroutine CompactDirectWriteRequestDB

  ! --------------------------------------- dump_machine_database ---------
  subroutine dump_machine_database(machines, Details)
    ! dump data type
    type(Machine_T), dimension(:), pointer :: machines
    integer, intent(in), optional :: DETAILS  ! 1: dump each machine, too
    ! Internal variables
    integer :: i
    integer :: myDetails
    integer, dimension(:), pointer :: master_tids
    character(len=MACHINENAMELEN), dimension(:), pointer :: master_names
    ! Executable
    if ( .not. associated(machines) ) then
      call output('machine database not associated', advance='yes')
      return
    endif
    myDetails = 1
    if ( present(details) ) myDetails = details
    call output ('Size of machine database: ', advance='no')
    call output (size(machines), advance='yes')
    call output ('Number of machines alive: ', advance='no')
    call output (count(machines%OK), advance='yes')
    call output ('Number of machines free: ', advance='no')
    call output (count(machines%free .and. machines%OK), advance='yes')
    if ( size(machines) < 1 ) return
    nullify ( master_tids, master_names )
    call Allocate_test ( master_tids, size(machines), 'machine_tids', moduleName )
    call Allocate_test ( master_names, size(machines), 'machine_names', moduleName )
    master_tids = 0
    call GetUniqueInts(machines%master_tid, master_tids, i, minValue=1)
    call output ('Number of unique master_ids: ', advance='no')
    call output (i, advance='yes')
    call GetUniqueStrings(machines%master_name, master_names, i, fillValue=' ')
    call output ('Number of unique master_names: ', advance='no')
    call output (i, advance='yes')
    call GetUniqueStrings(machines%master_date, master_names, i, fillValue=' ')
    call output ('Number of unique master_dates: ', advance='no')
    call output (i, advance='yes')
    call DeAllocate_test ( master_tids,  'machine_tids', moduleName )
    call DeAllocate_test ( master_names, 'machine_names', moduleName )
    if ( myDetails < 1 ) return
    do i = 1, size(machines)
      call dump_machine(machines(i))
    enddo
  end subroutine dump_machine_database

  ! --------------------------------------- dump_machine ---------
  subroutine dump_machine(machine)
    ! dump data type
    type(Machine_T), intent(in) :: machine
    call output('machine name: ', advance = 'no')
    call output(trim(machine%name), advance = 'yes')
    call output('master tid: ', advance = 'no')
    call output(machine%master_tid, advance = 'yes')
    call output('master name: ', advance = 'no')
    call output(trim(machine%master_name), advance = 'yes')
    call output('master date: ', advance = 'no')
    call output(trim(machine%master_date), advance = 'yes')
    call output('tid: ', advance = 'no')
    call output(machine%tid, advance = 'yes')
    call output('chunk: ', advance = 'no')
    call output(machine%chunk, advance = 'yes')
    call output('alive?: ', advance = 'no')
    call output(machine%OK, advance = 'yes')
    call output('free?: ', advance = 'no')
    call output(machine%free, advance = 'yes')
  end subroutine dump_machine
   
  ! --------------------------------------- DumpDirectWriteRequest ---------
  subroutine DumpDirectWriteRequest ( request )
    type(DirectWriteRequest_T), intent(in) :: REQUEST
    ! Executable code
    call output ( 'Chunk=' )
    call output ( request%chunk )
    call output ( ', machine=' )
    call output ( request%machine )
    call output ( ', tree node=' )
    call output ( request%node, advance='yes' )
    call output ( 'File index=' )
    call output ( request%fileIndex )
    call output ( ', ticket=' )
    call output ( request%ticket )
    call output ( ', value=' )
    call output ( request%value )
    call output ( ' Status: ' )
    select case ( request%status )
    case ( dw_invalid )
      call output ( 'invalid', advance='yes' )
    case ( dw_pending )
      call output ( 'pending', advance='yes' )
    case ( dw_inProgress )
      call output ( 'in Progress', advance='yes' )
    case ( dw_completed )
      call output ( 'completed', advance='yes' )
    case default
      call output ( request%status, advance='no' )
      call output ( ' (unrecognized)', advance='yes' )
    end select
    if ( request%whenFinished < 0. ) return
    call output ( 'grant delay: ' )
    call output ( request%whenGranted - request%whenMade, advance='yes' )
    call output ( 'writing time: ' )
    call output ( request%whenFinished - request%whenGranted, advance='yes' )
  end subroutine DumpDirectWriteRequest

  ! --------------------------------------- DumpAllDirectWriteRequests -----
  subroutine DumpAllDirectWriteRequests ( requests, statsOnly )
    type(DirectWriteRequest_T), intent(in), dimension(:) :: REQUESTS
    logical, optional, intent(in) :: statsOnly
    ! Internal variables
    logical :: mystatsOnly
    integer :: I, numRequests
    real :: min, max, mean, stddev, rms
    ! Executable code
    mystatsOnly = .false.
    if ( present(statsOnly) ) mystatsOnly = statsOnly
    numRequests = FindFirst(requests%status, DW_INVALID) - 1
    if ( numRequests < 1 ) then
      call output ( 'No valid directWrite requests among ' )
      call output ( size(requests) )
      call output ( ' direct write requests', advance='yes' )
      return
    endif
    call output ( 'Dumping ' )
    call output ( numRequests )
    call output ( ' direct write requests', advance='yes' )
    call allstats(requests(1:numRequests)%whenGranted &
      & - requests(1:numRequests)%whenMade, &
      & min=min, max=max, mean=mean, stddev=stddev, rms=rms)
    call output ( 'grant delay statistics: ', advance='yes' )
    call output ( 'min: ', advance='no' )
    call output ( min, advance='no' )
    call output ( '   max: ', advance='no' )
    call output ( max, advance='no' )
    call output ( '   mean: ', advance='no' )
    call output ( mean, advance='yes' )
    call allstats(requests(1:numRequests)%whenFinished &
      & - requests(1:numRequests)%whenGranted, &
      & min=min, max=max, mean=mean, stddev=stddev, rms=rms)
    call output ( 'writing time statistics: ', advance='yes' )
    call output ( 'min: ', advance='no' )
    call output ( min, advance='no' )
    call output ( '   max: ', advance='no' )
    call output ( max, advance='no' )
    call output ( '   mean: ', advance='no' )
    call output ( mean, advance='yes' )
    if ( mystatsOnly ) return
    ! Now dump each dw request (this could be   h u g e  ) !    
    do i = 1, numRequests ! size(requests)
      call output ( 'Request #' )
      call output ( i, advance='yes' )
      call dump ( requests(i) )
    end do
  end subroutine DumpAllDirectWriteRequests

  ! --------------------------------------- FinishedDirectWrite ------------
  subroutine FinishedDirectWrite ( ticket )
    integer, intent(in) :: TICKET       ! Ticket number
    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    ! Executable code
    if ( parallel%verbosity > 0 ) then
      call output ( "Sending finished on ticket " )
      call output ( ticket, advance='yes' )
    endif
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_DirectWriteFinished, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write finished flag" )
    call PVMF90Pack ( ticket, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write finished ticket" )

    call PVMFSend ( parallel%masterTid, InfoTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "sending direct write finished packet" )
    
  end subroutine FinishedDirectWrite

  ! ---------------------------------------- GetMachineNames ------------
  subroutine GetMachineNames ( machineNames )
    ! This reads the parallel slave name file and returns
    ! an array of machine names
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES

    ! Local variables
    character(len=MachineNameLen) :: ARCH ! A line from the file
    integer :: DTID                     ! From PVMFConfig
    integer :: FIRST                    ! First machine in file to use
    integer :: FIRSTCOLONPOS            ! Position in string
    logical :: GOTFIRSTLAST             ! Got a range
    integer :: I                        ! Loop inductor
    integer :: INFO                     ! From PVMFConfig
    integer :: LAST                     ! Last machine in file to use
    character(len=MachineNameLen) :: LINE ! A line from the file
    integer :: LUN                      ! Logical unit number
    integer :: MACHINE                  ! Counter
    integer :: NARCH                    ! From PVMFConfig
    integer :: NOLINES                  ! Number of lines in file
    integer :: NOMACHINES               ! Array size
    character(len=MachineNameLen) :: ORIGINAL ! A line from the file
    integer :: SECONDCOLONPOS           ! Position in string
    integer :: SPEED                    ! From PVMFConfig
    integer :: STAT                     ! Status flag from read

    ! Executable code
    ! The slave filename may contain starting and ending line numbers

    original = parallel%slaveFilename

    if ( trim(original) == 'pvm' ) then
      ! If the user specifies 'pvm' then just get the names of the machines
      ! in the pvm system
      machine = 1
      hostLoop: do
        call PVMFConfig ( noMachines, narch, dtid, line, arch, speed, info )
        if ( info < 0 ) call PVMErrorMessage ( info, &
          & 'Calling PVMFConfig' )
        if ( machine == 1 ) then
          call Allocate_test ( machineNames, noMachines, 'machineNames', moduleName )
        end if
        machineNames(machine) = trim(line)
        machine = machine + 1
        if ( machine == noMachines + 1 ) exit hostLoop
      end do hostLoop
    else
      gotFirstLast = .false.
      firstColonPos = index ( parallel%slaveFilename, ':' )
      if ( firstColonPos /= 0 ) then
        gotFirstLast = .true.
        parallel%slaveFilename(firstColonPos:firstColonPos) = ' '
        secondColonPos = index ( parallel%slaveFilename,':' )
        if ( secondColonPos < firstColonPos ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Incorrect syntax for slave info:'//trim(original) )
        parallel%slaveFilename(secondColonPos:secondColonPos) = ' '
        read (parallel%slaveFilename(firstColonPos+1:),*,iostat=stat) first, last
        if ( stat /= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Incorrect syntax for slave info:'//trim(original) )
      else
        firstColonPos = len_trim(parallel%slaveFilename)+1
      end if

      ! Find a free logical unit number
      ! lun = get_lun ()
      call get_lun( lun, msg=.false. )
      if ( lun < 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & "No logical unit numbers available" )
      open ( unit=lun, file=parallel%slaveFilename(1:firstColonPos-1),&
        & status='old', form='formatted', &
        & access='sequential', iostat=stat )
      if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to open slave file " // parallel%slaveFilename(1:firstColonPos-1) )

      ! Now read the file and count the lines
      noMachines = 0
      noLines = 0
      firstTimeRound: do
        read ( unit=lun, fmt=*, iostat=stat ) line
        if ( stat < 0 ) exit firstTimeRound
        noLines = noLines + 1
        line = adjustl ( line )
        if ( line(1:1) /= '#' ) noMachines = noMachines + 1
      end do firstTimeRound

      ! Now setup the result array
      if ( .not. gotFirstLast ) then
        first = 1
        last = noMachines
      else
        first = min( max ( first, 1 ), noMachines )
        last = max( 1, min ( last, noMachines ) )
      end if
      noMachines = last - first + 1

      call Allocate_test ( machineNames, noMachines, 'machineNames', moduleName )
      ! Now rewind the file and read the names
      rewind ( lun )
      machine = 1
      do i = 1, noLines
        read ( unit=lun, fmt=* ) line
        line = adjustl ( line )
        if ( line(1:1) /= '#' ) then
          if ( (machine >= first) .and. (machine <= last) ) &
            & machineNames(machine-first+1) = line
          machine = machine + 1
        end if
      end do

      close ( unit=lun )
    end if
    if ( switchDetail(switches,'mach') /=0 ) &
      & call dump ( machineNames, options=what_options(trim=.true.) )
  end subroutine GetMachineNames

  ! ---------------------------------------- GetMachines ------------
  subroutine GetMachines ( machines )
    ! This reads the parallel slave name file and returns
    ! an array of machine types
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type(machine_t), dimension(:), pointer :: MACHINES

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: noMachines, stat
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
    ! Executable
    nullify(machineNames, machines)
    call GetMachineNames(machineNames)
    noMachines = size(machineNames)
    if ( noMachines < 1 ) return
    allocate ( machines(noMachines), stat=stat )
    addr = 0
    if ( stat == 0 ) addr = transfer(c_loc(machines(1)), addr)
    call test_allocate ( stat, ModuleName, 'machines', ubounds=noMachines, &
      & elementSize = storage_size(machines) / 8, address=addr )
    machines%name = machineNames
  end subroutine GetMachines

  ! ------------------------------------ InflateDirectWriteRequestDB --
  integer function InflateDirectWriteRequestDB ( database, extra )
    ! Make the directWrite database bigger by extra
    ! return index of first new element

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type(DirectWriteRequest_T), dimension(:), pointer :: DATABASE
    integer, intent(in) :: EXTRA

    ! Local variables
    type(DirectWriteRequest_T), dimension(:), pointer :: TEMPDATABASE

    include "inflateDatabase.f9h"
    InflateDirectWriteRequestDB = firstNewItem
  end function InflateDirectWriteRequestDB

  ! ---------------------------------------- LogDirectWriteRequest_int --
  subroutine LogDirectWriteRequest_int ( filename, node )
    integer, intent(in) :: FILENAME     ! String index of filename
    integer, intent(in) :: NODE         ! Node for directWrite line

    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM

    ! Executable code

    ! Pack and dispatch
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_RequestDirectWrite, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write request flag" )
    call PVMPackStringIndex ( filename, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write request filename" )
    call PVMF90Pack ( node, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write request node" )

    if ( DELAYFOREACHSLAVEDWREQUEST > 0 ) &
      & call usleep ( DELAYFOREACHSLAVEDWREQUEST )
    call PVMFSend ( parallel%masterTid, InfoTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "sending direct write request packet" )

  end subroutine LogDirectWriteRequest_int

  ! ---------------------------------------- LogDirectWriteRequest_str --
  subroutine LogDirectWriteRequest_str ( filename, node )
    character(len=*), intent(in) :: FILENAME     ! String filename
    integer, intent(in) :: NODE         ! Node for directWrite line

    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM

    ! Executable code

    ! Pack and dispatch
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_RequestDirectWrite, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write request flag" )
    ! call PVMPackStringIndex ( filename, info )
    call PVMIDLPack ( trim(filename), info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write request filename" )
    call PVMF90Pack ( node, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write request node" )

    if ( DELAYFOREACHSLAVEDWREQUEST > 0 ) &
      & call usleep ( DELAYFOREACHSLAVEDWREQUEST )
    call PVMFSend ( parallel%masterTid, InfoTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "sending direct write request packet" )

  end subroutine LogDirectWriteRequest_str

  ! -------------------------------------------- WaitForDirectWritePermission --
  subroutine WaitForDirectWritePermission ( node, ticket, theFile, createFile )
    integer, intent(out) :: NODE        ! Which line was granted
    integer, intent(out) :: TICKET      ! What is the ticket number
    ! integer, intent(out) :: THEFILE   ! What is the file name
    character(len=*), intent(out), optional :: THEFILE  ! file name
    logical, intent(out) :: CREATEFILE  ! Do we have to create the file?
    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    integer :: SIGNAL                   ! The signal from the master
    integer :: I4(4)                    ! Information from master
    ! Executable code
    call PVMFRecv ( parallel%masterTid, InfoTag, bufferID )
    if ( bufferID <= 0 ) call PVMErrorMessage ( bufferID, &
      & 'receiving direct write permission/wait' )

    ! Once we have the reply unpack it
    call PVMF90Unpack ( signal, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'unpacking direct write permission signal')

    if ( signal == SIG_DirectWriteGranted ) then
      call PVMF90Unpack ( I4, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking direct write permission information')
      call PVMUnpackStringIndex ( I4(4), info, outWord=theFile )
      if ( info /= 0 )  call PVMErrorMessage ( info, &
        & "unpacking direct write request filename" )
      node = I4(1)
      ticket = I4(2)
      createFile = I4(3) /= 0
      ! theFile = I4(4)

    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Got unrecognised signal from master' )
    end if

  end subroutine WaitForDirectWritePermission

  ! ------------------------------------------- SlaveJoin ---------------
  subroutine SlaveJoin ( quantity, precisionQuantity, hdfName, key )
    ! This simply sends one or more vector quantities down a pvm spigot.
    type (VectorValue_T), pointer :: QUANTITY    ! Quantity to join
    type (VectorValue_T), pointer :: PRECISIONQUANTITY ! Its precision
    character(len=*), intent(in) :: HDFNAME ! Swath / sd name
    integer, intent(in) :: KEY          ! Tree node

    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: GOTPRECISION             ! really boolean
    integer :: INFO                     ! Flag from PVM

    ! Executable code
    gotPrecision = 0
    if ( associated ( precisionQuantity) ) gotPrecision = 1

    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_ToJoin, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing kind" )
    call PVMF90Pack ( (/key, gotPrecision /), info )
    if ( info /= 0 ) &
       & call PVMErrorMessage ( info, "packing key, gotPrecision" )
    call PVMIDLPack ( hdfName, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing hdfName" )

    call PVMSendQuantity ( quantity, justPack=.true., noMask=.true. )
    if ( associated ( precisionQuantity ) ) &
      call PVMSendQuantity ( precisionQuantity, justPack=.true., noMask=.true. )
    
    call PVMFSend ( parallel%masterTid, InfoTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage( info, 'sending join packet' )

  end subroutine SlaveJoin

  ! --------------------------------------------- SnipLastSlaveArgument ------
  subroutine SnipLastSlaveArgument
    ! This routine snips the last command line arguments for the slaves
    integer :: n
    character ( len=len(slaveArguments) ), save :: tempArguments = ""
    character(len=1), parameter :: SPACE = ' '
    ! Executable code
    if ( DEEBUG ) call output( 'Planning to SnipLastSlaveArgument from ' // trim(slaveArguments), &
      & advance='yes' )
    ! How many elements?
    n = NumStringElements( slaveArguments, countEmpty, inseparator=space )
    if ( DEEBUG ) call outputNamedValue ( 'n', n )
    if ( n < 1 ) return
    tempArguments = slaveArguments
    if ( DEEBUG ) call output( 'Before snip: ' // trim(slaveArguments), advance='yes' )
    call RemoveNumFromList( tempArguments, slaveArguments, n, &
      & inseparator=space )
    if ( DEEBUG ) call output( 'After snip: ' // trim(slaveArguments), advance='yes' )
  end subroutine SnipLastSlaveArgument
    
  ! --------------------------------------------- SigToName ------
  function SigToName( Sig ) result ( name )
    integer, intent(in)           :: Sig
    character(len=32)             :: name
    ! Executable
    select case ( Sig )
    case ( SIG_AboutToDie )
      name = 'AboutToDie'
    case ( SIG_ToJoin )
      name = 'ToJoin'
    case ( SIG_Finished )
      name = 'Finished'
    case ( SIG_AckFinish )
      name = 'AckFinish'
    case ( SIG_Register )
      name = 'Register'
    case ( SIG_RequestDirectWrite )
      name = 'RequestDirectWrite'
    case ( SIG_DirectWriteGranted )
      name = 'DirectWriteGranted'
    case ( SIG_DirectWriteFinished )
      name = 'DirectWriteFinished'
    case ( SIG_NewSetUp )
      name = 'NewSetUp'
    case ( SIG_RunMAF )
      name = 'RunMAF'
    case ( SIG_SendResults )
      name = 'SendResults'
    case ( SIG_RequestHost )
      name = 'RequestHost'
    case ( SIG_ReleaseHost )
      name = 'ReleaseHost'
    case ( SIG_HostDied )
      name = 'HostDied'
    case ( SIG_ThanksHost )
      name = 'ThanksHost'
    case ( SIG_SwearAllegiance )
      name = 'SwearAllegiance'
    case ( SIG_SwitchAllegiance )
      name = 'SwitchAllegiance'
    case default
      name = 'Unknown'
    end select
  end function SigToName
    
  ! --------------------------------------------- TagToName ------
  function TagToName( tag ) result ( name )
    integer, intent(in)           :: tag
    character(len=24)             :: name
    ! Executable
    select case ( tag )
    case ( Infotag )
      name = 'Info'
    case ( Chunktag )
      name = 'Chunk'
    case ( Notifytag )
      name = 'Notify'
    case ( Petitiontag )
      name = 'Petition'
    case ( Grantedtag )
      name = 'Granted'
    case ( MasterDumptag )
      name = 'MasterDump'
    case ( MachineFixedtag )
      name = 'MachineFixed'
    case ( GiveUptag )
      name = 'GiveUp'
    case default
      name = 'Unknown'
    end select
  end function TagToName
    
  ! --------------------------------------------- TransmitSlaveArguments ------
  subroutine TransmitSlaveArguments
    ! This routine transmits command line arguments to the slaves via pvm
    integer :: i, n
    character(len=1), parameter :: SPACE = ' '
    ! Executable code
    if ( parallel%verbosity > 0 ) call output( 'slave arguments: ' // &
      & trim(slaveArguments), advance='yes' )
    ! How many elements?
    n = NumStringElements( slaveArguments, countEmpty, inseparator=space )
    do i=1, n
      call NextPVMArg ( trim(StringElement ( slaveArguments, &
        & i, countEmpty, inseparator=space ) ) )
    enddo
  end subroutine TransmitSlaveArguments
    
  ! ----------------------------------------- GetNiceTidString -----
  character(len=16) function GetNiceTidString ( tid )
    integer, intent(in) :: tid

    ! Executable code
    write ( GetNiceTidString, '(z0)' ) tid
    GetNiceTidString = '[t'//trim(LowerCase ( GetNiceTidString ))//']'
  end function GetNiceTidString

  function what_options( clean, transpose, trim ) result( options )
    use MLSStrings, only: Trim_Safe
    logical, optional, intent(in) :: clean
    logical, optional, intent(in) :: transpose
    logical, optional, intent(in) :: trim
    character(len=8) :: options
    options = ' '
    if ( present(clean) ) then
      if ( clean ) options = trim_safe(options) // 'c'
    endif
    if ( present(transpose) ) then
      if ( transpose ) options = trim_safe(options) // 'p'
    endif
    if ( present(trim) ) then
      if ( trim ) options = trim_safe(options) // 't'
    endif
  end function what_options

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: L2ParInfo.f90,v 2.69 2018/02/09 01:07:07 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module L2ParInfo

! $Log: L2ParInfo.f90,v $
! Revision 2.69  2018/02/09 01:07:07  pwagner
! Added functions to convert tags and sigs to corresponding names
!
! Revision 2.68  2017/12/22 00:31:05  pwagner
! Made Use statements CamelCase
!
! Revision 2.67  2016/03/23 20:12:42  pwagner
! Usleep not an external any more
!
! Revision 2.66  2016/02/29 19:50:26  pwagner
! Usleep got from machine module instead of being an external
!
! Revision 2.65  2015/03/28 02:48:02  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.64  2014/09/05 01:05:03  vsnyder
! Add some tracing.  Move some USEs from module to procedure scope.
!
! Revision 2.63  2014/09/05 00:49:06  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.62  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.61  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.60  2013/02/14 19:03:32  pwagner
! Added way for l2q to tell master to dump status
!
! Revision 2.59  2012/07/10 15:19:45  pwagner
! Adapted to new api for RemoveNumFromList
!
! Revision 2.58  2012/07/02 20:39:59  pwagner
! Once-routine output now requires verbosity > 0
!
! Revision 2.57  2012/06/27 18:10:41  pwagner
! Added TransmitSlaveArguments, SnipLastSlaveArgument
!
! Revision 2.56  2012/03/28 20:05:10  pwagner
! Removed staging file--slave tasks lost ability to join quantities
!
! Revision 2.55  2011/05/09 18:20:55  pwagner
! Converted to using switchDetail
!
! Revision 2.54  2010/08/06 23:08:48  pwagner
! Pass Hessians, matrices to DumpCommand
!
! Revision 2.53  2009/07/21 20:35:38  pwagner
! Nullify pointers before call ing allocate_test with them
!
! Revision 2.52  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.51  2009/06/16 17:41:37  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.50  2007/10/24 00:16:38  pwagner
! Removed unused declarations
!
! Revision 2.49  2007/04/03 20:55:22  pwagner
! Uses get_lun from lib/io_stuff instead of internal function
!
! Revision 2.48  2007/01/12 00:38:57  pwagner
! Switches allegiance to a replacement l2q
!
! Revision 2.47  2006/06/24 23:10:00  pwagner
! Remove unneeded thing from output_m
!
! Revision 2.46  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.45  2005/03/24 21:20:33  pwagner
! New fileds in directWriteRequests figure grant delay, writing time
!
! Revision 2.44  2005/03/15 23:53:03  pwagner
! PVMERRORMESSAGE now part of MLSMessageModule; INFOTag, SIG_ABOUTTODIE from lib/PVM
!
! Revision 2.43  2005/02/03 19:07:35  pwagner
! master_name and master_date fields added to machine type
!
! Revision 2.42  2005/01/13 00:01:31  pwagner
! Dumping machineDB shows only free machines that are still alive
!
! Revision 2.41  2005/01/07 17:27:21  pwagner
! Details an optional arg to dump_machine_database to bypass dumping each machine
!
! Revision 2.40  2004/12/14 21:53:30  pwagner
! Added machine_T, tags and signals related to l2q
!
! Revision 2.39  2004/09/16 23:57:32  pwagner
! Now tracks machine names of failed chunks
!
! Revision 2.38  2004/09/16 00:18:03  pwagner
! Keeps record of completed, failed chunks
!
! Revision 2.37  2004/08/05 22:47:47  pwagner
! New --chunkRange option to run selected chunks in parallel mode
!
! Revision 2.36  2004/01/22 00:56:35  pwagner
! Fixed many bugs in auto-distribution of DirectWrites
!
! Revision 2.35  2004/01/02 23:36:00  pwagner
! DirectWrites may choose files automatically from db
!
! Revision 2.34  2003/12/11 23:00:58  pwagner
! Make master task wait for slaves stdout buffers to flush
!
! Revision 2.33  2003/11/14 23:37:13  pwagner
! Lets user change masterLoop delay via commandline option
!
! Revision 2.32  2003/08/11 23:23:31  pwagner
! ChunkNo component added to L2ParallelInfo_T
!
! Revision 2.31  2003/08/01 20:26:53  pwagner
! slave command name saved as component pgeName
!
! Revision 2.30  2003/07/07 17:32:10  livesey
! New approach to DirectWrite
!
! Revision 2.29  2003/06/20 19:38:25  pwagner
! Allows direct writing of output products
!
! Revision 2.28  2003/05/12 19:04:50  livesey
! Added the staging file to L2ParallelInfo_T
!
! Revision 2.27  2003/01/27 17:18:58  livesey
! Made master task output it's tid as well as slaves.
!
! Revision 2.26  2003/01/17 21:54:21  livesey
! Added the machineFixed stuff
!
! Revision 2.25  2002/12/11 01:58:33  livesey
! Added noFWMSlaves
!
! Revision 2.24  2002/11/23 00:13:18  livesey
! Increased maxFailuresPerChunk to reflect nature of Raytheon cluster (at
! least for the moment).
!
! Revision 2.23  2002/10/17 18:19:13  livesey
! Added GiveupTag
!
! Revision 2.22  2002/10/08 20:33:51  livesey
! Added notify stuff for FWMParallel
!
! Revision 2.21  2002/10/08 17:40:56  livesey
! Minor bug fix in FWMParallel stuff
!
! Revision 2.20  2002/10/08 17:36:21  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.19  2002/10/06 22:22:47  livesey
! Removed MAFTAG and MAF communication stuff
!
! Revision 2.18  2002/10/06 01:10:17  livesey
! More progress on the fwmParallel stuff
!
! Revision 2.17  2002/10/05 00:43:20  livesey
! Started work on the fwmParallel stuff
!
! Revision 2.16  2002/07/19 06:07:32  livesey
! Cut down MaxFailuresPerChunk
!
! Revision 2.15  2002/07/17 20:02:17  livesey
! Bug fix
!
! Revision 2.14  2002/07/17 20:01:42  livesey
! Put an advance=yes in there
!
! Revision 2.13  2002/07/17 19:54:52  livesey
! Made slaves at least identify themselves
!
! Revision 2.12  2002/05/22 00:48:28  livesey
! Added direct write stuff
!
! Revision 2.11  2002/04/24 16:53:50  livesey
! Changes to implement submit.
!
! Revision 2.10  2002/03/21 01:23:36  livesey
! Changed thresholds
!
! Revision 2.9  2001/10/30 01:45:21  livesey
! Some modifications/fixes to parallel join
!
! Revision 2.8  2001/09/08 00:21:44  pwagner
! Revised to work for new column Abundance in lone swaths
!
! Revision 2.7  2001/05/30 23:53:54  livesey
! Vectors now sent within info packets
!
! Revision 2.6  2001/05/29 20:42:18  pwagner
! Added Log at bottom of source
!
@


2.69
log
@Added functions to convert tags and sigs to corresponding names
@
text
@a193 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a209 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a665 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d956 1
a956 1
       "$Id: L2ParInfo.f90,v 2.68 2017/12/22 00:31:05 pwagner Exp $"
d966 3
@


2.68
log
@Made Use statements CamelCase
@
text
@d40 12
a51 11
  public :: L2PARALLELINFO_T, PARALLEL, MACHINE_T
  public :: ADDMACHINENAMETODATABASE, ADDMACHINETODATABASE
  public :: INITPARALLEL, CLOSEPARALLEL
  public :: SLAVEJOIN
  public :: GETNICETIDSTRING, SLAVEARGUMENTS
  public :: ACCUMULATESLAVEARGUMENTS, LOGDIRECTWRITEREQUEST
  public :: SNIPLASTSLAVEARGUMENT, TRANSMITSLAVEARGUMENTS
  public :: FINISHEDDIRECTWRITE, MACHINENAMELEN, GETMACHINENAMES, GETMACHINES
  public :: FWMSLAVEGROUP, DIRECTWRITEREQUEST_T
  public :: INFLATEDIRECTWRITEREQUESTDB, WAITFORDIRECTWRITEPERMISSION
  public :: COMPACTDIRECTWRITEREQUESTDB, DUMP
d288 1
d303 1
a303 1
      ! call MLSMessage ( MLSMSG_Info, ModuleName, &
d841 72
d959 1
a959 1
       "$Id: L2ParInfo.f90,v 2.67 2016/03/23 20:12:42 pwagner Exp $"
d969 3
@


2.67
log
@Usleep not an external any more
@
text
@d16 6
a21 6
  use allocate_deallocate, only: allocate_test, deallocate_test
  use dump_0, only: dump
  use highOutput, only: outputNamedValue
  use io_stuff, only: get_lun
  use machine, only: usleep
  use MLSFinds, only: findfirst
d23 7
a29 7
  use MLSStats1, only: allstats
  use MLSStrings, only: lowercase
  use MLSStringLists, only: getuniqueints, getuniquestrings, numstringelements, &
    & removenumfromlist, stringelement, switchdetail
  use morePVM, only: PVMpackstringindex, PVMunpackstringindex
  use output_m, only: output
  use PVM, only: infotag, &
d31 1
a31 1
    & PVMdatadefault, PVMf90unpack, nextPVMarg, PVMtaskexit, sig_abouttodie
d33 3
a35 3
  use quantityPVM, only: PVMsendquantity
  use toggles, only: switches
  use vectorsmodule, only: vectorvalue_t
d314 2
d865 1
a865 1
    use MLSSTRINGS, only: TRIM_SAFE
d885 1
a885 1
       "$Id: L2ParInfo.f90,v 2.66 2016/02/29 19:50:26 pwagner Exp $"
d895 3
@


2.66
log
@Usleep got from machine module instead of being an external
@
text
@a716 2
    ! External (C) function
    external :: Usleep
d883 1
a883 1
       "$Id: L2ParInfo.f90,v 2.65 2015/03/28 02:48:02 vsnyder Exp $"
d893 3
@


2.65
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d16 20
a35 19
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DUMP
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use IO_STUFF, only: GET_LUN
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, PVMERRORMESSAGE
  use MLSFINDS, only: FINDFIRST
  use MLSSTATS1, only: ALLSTATS
  use MLSSTRINGS, only: LOWERCASE
  use MLSSTRINGLISTS, only: GETUNIQUEINTS, GETUNIQUESTRINGS, NUMSTRINGELEMENTS, &
    & REMOVENUMFROMLIST, STRINGELEMENT, SWITCHDETAIL
  use MOREPVM, only: PVMPACKSTRINGINDEX, PVMUNPACKSTRINGINDEX
  use OUTPUT_M, only: OUTPUT
  use PVM, only: INFOTAG, &
    & PVMFMYTID, PVMFINITSEND, PVMF90PACK, PVMFSEND, &
    & PVMDATADEFAULT, PVMF90UNPACK, NEXTPVMARG, PVMTASKEXIT, SIG_ABOUTTODIE
  use PVMIDL, only: PVMIDLPACK
  use QUANTITYPVM, only: PVMSENDQUANTITY
  use TOGGLES, only: SWITCHES
  use VECTORSMODULE, only: VECTORVALUE_T
a685 2
    ! External (C) function
    external :: Usleep
d885 1
a885 1
       "$Id: L2ParInfo.f90,v 2.64 2014/09/05 01:05:03 vsnyder Exp $"
d895 3
@


2.64
log
@Add some tracing.  Move some USEs from module to procedure scope.
@
text
@d192 1
d209 1
a518 1
    use Allocate_Deallocate, only: Test_Allocate
d612 1
a612 4
      allocate ( machineNames(noMachines), stat=stat )
      call test_allocate ( stat, ModuleName, 'machineNames', ubounds=noMachines, &
        & elementSize = storage_size(machineNames) / 8 )

d623 1
a623 1
        endif
d637 1
d641 1
d650 2
d653 1
a653 1
      & elementSize = storage_size(machines) / 8 )
d663 1
d886 1
a886 1
       "$Id: L2ParInfo.f90,v 2.63 2014/09/05 00:49:06 vsnyder Exp $"
d896 3
@


2.63
log
@EmpiricalGeometry.f90
@
text
@d883 1
a883 1
       "$Id: L2ParInfo.f90,v 2.62 2014/01/09 00:30:24 pwagner Exp $"
d893 3
@


2.62
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d20 1
a20 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_ALLOCATE, &
    & MLSMSG_DEALLOCATE, PVMERRORMESSAGE
d190 2
d206 2
d261 1
a261 1
  subroutine CloseParallel(noSlaves, dontWait)
d263 4
d272 1
d279 2
d300 1
a300 1
      if ( myDontWait ) return
d311 1
a311 1
    elseif ( parallel%master ) then
d313 1
a313 1
      if ( noSlaves < 1 ) return
d316 1
a316 1
      enddo
d318 2
d517 1
d612 2
a613 2
      if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//' machineNames')
d638 1
d650 2
a651 2
    if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//' machines')
d660 2
d883 1
a883 1
       "$Id: L2ParInfo.f90,v 2.61 2013/08/12 23:49:41 pwagner Exp $"
d893 3
@


2.61
log
@FindSomethings moved to MLSFinds module
@
text
@d18 1
d28 1
a28 1
  use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d867 1
a867 1
       "$Id: L2ParInfo.f90,v 2.60 2013/02/14 19:03:32 pwagner Exp $"
d877 3
@


2.60
log
@Added way for l2q to tell master to dump status
@
text
@d21 1
a21 1
  use MLSSETS, only: FINDFIRST
d866 1
a866 1
       "$Id: L2ParInfo.f90,v 2.59 2012/07/10 15:19:45 pwagner Exp $"
d876 3
@


2.59
log
@Adapted to new api for RemoveNumFromList
@
text
@d39 11
a49 11
  public :: L2ParallelInfo_T, parallel, Machine_T
  public :: AddMachineNameToDataBase, AddMachineToDataBase
  public :: InitParallel, CloseParallel
  public :: SlaveJoin
  public :: GetNiceTidString, SlaveArguments
  public :: AccumulateSlaveArguments, LogDirectWriteRequest
  public :: SnipLastSlaveArgument, TransmitSlaveArguments
  public :: FinishedDirectWrite, MachineNameLen, GetMachineNames, GetMachines
  public :: FWMSlaveGroup, DirectWriteRequest_T
  public :: InflateDirectWriteRequestDB, WaitForDirectWritePermission
  public :: CompactDirectWriteRequestDB, Dump
d68 1
a98 1
    ! logical :: stageInMemory = .false.  ! Set if master stages to memory rather
d866 1
a866 1
       "$Id: L2ParInfo.f90,v 2.58 2012/07/02 20:39:59 pwagner Exp $"
d876 3
@


2.58
log
@Once-routine output now requires verbosity > 0
@
text
@d816 1
a816 1
      & inseparator=space, countEmpty=countEmpty )
d866 1
a866 1
       "$Id: L2ParInfo.f90,v 2.57 2012/06/27 18:10:41 pwagner Exp $"
d876 3
@


2.57
log
@Added TransmitSlaveArguments, SnipLastSlaveArgument
@
text
@d98 2
a99 1
    logical :: stageInMemory = .false.  ! Set if master stages to memory rather
d478 1
d481 5
a485 3
    ! Local variables
    call output ( "Sending finished on ticket " )
    call output ( ticket, advance='yes' )
a497 1
    ! Executable code
d826 2
d866 1
a866 1
       "$Id: L2ParInfo.f90,v 2.56 2012/03/28 20:05:10 pwagner Exp $"
d876 3
@


2.56
log
@Removed staging file--slave tasks lost ability to join quantities
@
text
@d24 2
a25 1
  use MLSSTRINGLISTS, only: GETUNIQUEINTS, GETUNIQUESTRINGS, SWITCHDETAIL
d27 1
a27 1
  use OUTPUT_M, only: OUTPUT
d45 1
d168 3
d179 1
a179 1
    call NextPVMArg ( trim(arg) )
d797 34
d841 1
a841 1
    use MLSStrings, only: trim_safe
d861 1
a861 1
       "$Id: L2ParInfo.f90,v 2.55 2011/05/09 18:20:55 pwagner Exp $"
d871 3
@


2.55
log
@Converted to using switchDetail
@
text
@a89 2
  character (len=*), parameter :: DEFAULTSTAGINGFILE = &
    & "MLS-Aura_L2Staging-Full_v0-0-0_0000d000.h5"
a105 1
    character(len=132) :: stagingFile=DefaultStagingFile ! Filename for possible
d822 1
a822 1
       "$Id: L2ParInfo.f90,v 2.54 2010/08/06 23:08:48 pwagner Exp $"
d832 3
@


2.54
log
@Pass Hessians, matrices to DumpCommand
@
text
@d16 12
a27 12
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use dump_0, only: DUMP
  use IO_Stuff, only: Get_Lun
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_Allocate, &
    & MLSMSG_Deallocate, PVMERRORMESSAGE
  use MLSSets, only: FINDFIRST
  use MLSStats1, only: ALLSTATS
  use MLSStrings, only: LowerCase
  use MLSStringLists, only: GetUniqueInts, GetUniqueStrings
  use MorePVM, only: PVMPACKSTRINGINDEX, PVMUNPACKSTRINGINDEX
  use Output_M, only: Output
  use PVM, only: INFOTag, &
d31 3
a33 3
  use QuantityPVM, only: PVMSENDQUANTITY
  use Toggles, only: SWITCHES
  use VectorsModule, only: VECTORVALUE_T
d611 1
a611 1
    if ( index(switches,'mach') /=0 ) &
d825 1
a825 1
       "$Id: L2ParInfo.f90,v 2.53 2009/07/21 20:35:38 pwagner Exp $"
d835 3
@


2.53
log
@Nullify pointers before call ing allocate_test with them
@
text
@d222 1
d825 1
a825 1
       "$Id: L2ParInfo.f90,v 2.52 2009/06/23 18:46:18 pwagner Exp $"
d835 3
@


2.52
log
@Prevent Intel from optimizing ident string away
@
text
@d51 1
a51 1
       "$RCSfile: $"
d341 1
d824 1
a824 1
       "$Id: read_apriori.f90 is it here $"
d834 3
@


2.51
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d51 1
a51 1
       "$RCSfile: L2ParInfo.f90,v $"
d820 1
a821 1
!---------------------------- RCS Ident Info -------------------------------
d823 2
a824 3
       "$Id: L2ParInfo.f90,v 2.50 2007/10/24 00:16:38 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d826 1
d828 1
d833 3
@


2.50
log
@Removed unused declarations
@
text
@d609 2
a610 1
    if ( index(switches,'mach') /=0 ) call dump ( machineNames, trim=.true. )
d802 18
d823 1
a823 1
       "$Id: L2ParInfo.f90,v 2.49 2007/04/03 20:55:22 pwagner Exp $"
d832 3
@


2.49
log
@Uses get_lun from lib/io_stuff instead of internal function
@
text
@d20 1
a20 1
    & MLSMSG_Deallocate, MLSMSG_INFO, PVMERRORMESSAGE
a499 2
    character(len=MachineNameLen) :: LINE ! A line from the file
    character(len=MachineNameLen) :: ORIGINAL ! A line from the file
a500 4
    logical :: EXIST                    ! Flag from inquire
    logical :: GOTFIRSTLAST             ! Got a range
    logical :: OPENED                   ! Flag from inquire

d504 1
d508 1
d514 1
a620 1
    type(machine_t) :: MACHINE
a655 1
    integer :: SIGNAL                   ! From Master
a688 1
    integer :: SIGNAL                   ! From Master
a725 1
    integer :: CREATE                   ! Integer version of createFile
d804 1
a804 1
       "$Id: L2ParInfo.f90,v 2.48 2007/01/12 00:38:57 pwagner Exp $"
d813 3
@


2.48
log
@Switches allegiance to a replacement l2q
@
text
@d18 1
d562 4
a565 1
      lun = get_lun ()
a807 16
  ! --------------------------------------- get_lun -----
  integer function get_lun ()
    ! Local variables
    integer :: LUN
    logical :: EXIST
    logical :: OPENED
    ! Executable code
    do lun = 20, 99
      inquire ( unit=lun, exist=exist, opened=opened )
      if ( exist .and. .not. opened ) exit
    end do
    if ( opened .or. .not. exist ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "No logical unit numbers available" )
    get_lun = lun
  end function get_lun

d811 1
a811 1
       "$Id: L2ParInfo.f90,v 2.47 2006/06/24 23:10:00 pwagner Exp $"
d820 3
@


2.47
log
@Remove unneeded thing from output_m
@
text
@d40 2
a41 8
  public :: SIG_ToJoin, SIG_Finished, SIG_Register
  public :: ChunkTag, GRANTEDTAG, SlaveJoin
  public :: SIG_AckFinish, SIG_RequestDirectWrite, SIG_DirectWriteGranted
  public :: SIG_DirectWriteFinished
  public :: SIG_NewSetup, SIG_RunMAF, SIG_SendResults
  public :: PETITIONTAG
  public :: SIG_REQUESTHOST, SIG_RELEASEHOST, SIG_HOSTDIED, SIG_THANKSHOST
  public :: NotifyTag, GetNiceTidString, GiveUpTag, SlaveArguments
d44 1
a44 2
  public :: FWMSlaveGroup, MachineFixedTag, DirectWriteRequest_T
  public :: DW_Invalid, DW_Pending, DW_InProgress, DW_Completed
d61 23
a83 21
  integer, parameter :: CHUNKTAG   = InfoTag + 1  ! Master => slave: chunkinfo
  integer, parameter :: NOTIFYTAG  = ChunkTag + 1  ! pvm => master: Slave exited
  integer, parameter :: PETITIONTAG  = NotifyTag + 1 ! master => l2q
  integer, parameter :: GRANTEDTAG  = PetitionTag + 1 ! l2q => master
  integer, parameter :: MACHINEFIXEDTAG = 800
  integer, parameter :: GIVEUPTAG  = 999

  integer, parameter :: SIG_TOJOIN = SIG_AboutToDie + 1
  integer, parameter :: SIG_FINISHED = SIG_toJoin + 1
  integer, parameter :: SIG_ACKFINISH = SIG_finished + 1
  integer, parameter :: SIG_REGISTER = SIG_AckFinish + 1
  integer, parameter :: SIG_REQUESTDIRECTWRITE = SIG_Register + 1
  integer, parameter :: SIG_DIRECTWRITEGRANTED = SIG_RequestDirectWrite + 1
  integer, parameter :: SIG_DIRECTWRITEFINISHED = SIG_DirectWriteGranted + 1
  integer, parameter :: SIG_NEWSETUP = SIG_DirectWriteFinished + 1
  integer, parameter :: SIG_RUNMAF = SIG_NewSetup + 1
  integer, parameter :: SIG_SENDRESULTS = SIG_RunMAF + 1
  integer, parameter :: SIG_REQUESTHOST = SIG_SendResults + 1
  integer, parameter :: SIG_RELEASEHOST = SIG_RequestHost + 1
  integer, parameter :: SIG_HOSTDIED = SIG_ReleaseHost + 1
  integer, parameter :: SIG_THANKSHOST = SIG_HostDied + 1
d124 4
a127 4
  integer, parameter :: DW_INVALID = 0
  integer, parameter :: DW_PENDING = DW_INVALID + 1
  integer, parameter :: DW_INPROGRESS = DW_PENDING + 1
  integer, parameter :: DW_COMPLETED = DW_INPROGRESS + 1
d823 1
a823 1
       "$Id: L2ParInfo.f90,v 2.46 2005/06/22 18:57:02 pwagner Exp $"
d832 3
@


2.46
log
@Reworded Copyright statement, moved rcs id
@
text
@d57 1
a57 1
       "$RCSfile: $"
a217 1
    use Output_m, only: PRUNIT
d828 1
a828 1
       "$Id: $"
d837 3
@


2.45
log
@New fileds in directWriteRequests figure grant delay, writing time
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d55 1
a55 4
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
    "$Id: L2ParInfo.f90,v 2.44 2005/03/15 23:53:03 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d57 1
a57 1
    "$RCSfile: L2ParInfo.f90,v $"
d59 1
a59 1
  !---------------------------------------------------------------------------
d827 5
d838 3
@


2.44
log
@PVMERRORMESSAGE now part of MLSMessageModule; INFOTag, SIG_ABOUTTODIE from lib/PVM
@
text
@d12 6
a21 2
  use MorePVM, only: PVMPACKSTRINGINDEX, PVMUNPACKSTRINGINDEX
  use VectorsModule, only: VECTORVALUE_T
a22 3
  use MLSStrings, only: LowerCase
  use MLSStringLists, only: GetUniqueInts, GetUniqueStrings
  use Output_M, only: Output
d24 1
d49 1
a49 1
    "$Id: L2ParInfo.f90,v 2.43 2005/02/03 19:07:35 pwagner Exp $"
d58 3
d138 3
a140 1
    real    :: WHENFIRSTPERMITTED
d409 3
d413 5
d421 1
a421 1
  subroutine DumpAllDirectWriteRequests ( requests )
d423 15
a437 2
    integer :: I
    ! Executable code
d439 1
a439 1
    call output ( size(requests) )
d441 23
a463 1
    do i = 1, size(requests)
d659 2
d675 2
d693 2
d710 2
d828 3
@


2.43
log
@master_name and master_date fields added to machine type
@
text
@d11 4
a14 3
    & MLSMSG_Deallocate, MLSMSG_INFO
  use PVM, only: PVMFMYTID, PVMFINITSEND, PVMF90PACK, PVMFSEND, &
    & PVMDATADEFAULT, PVMERRORMESSAGE, PVMF90UNPACK, NEXTPVMARG, PVMTASKEXIT
d31 1
a31 1
  public :: ChunkTag, GRANTEDTAG, InfoTag, SlaveJoin
d47 1
a47 1
    "$Id: L2ParInfo.f90,v 2.42 2005/01/13 00:01:31 pwagner Exp $"
d58 2
a59 3
  integer, parameter :: CHUNKTAG   = 10  ! Master => slave: chunkinfo
  integer, parameter :: INFOTAG    = ChunkTag + 1 ! Slave <=> master
  integer, parameter :: NOTIFYTAG  = InfoTag + 1  ! pvm => master: Slave exited
d65 1
a65 1
  integer, parameter :: SIG_TOJOIN = 1
d110 2
d770 3
@


2.42
log
@Dumping machineDB shows only free machines that are still alive
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d8 1
a8 1
  use Allocate_Deallocate, only: ALLOCATE_TEST
d19 1
d46 1
a46 1
    "$Id: L2ParInfo.f90,v 2.41 2005/01/07 17:27:21 pwagner Exp $"
d137 2
d316 2
d331 15
d360 4
d768 3
@


2.41
log
@Details an optional arg to dump_machine_database to bypass dumping each machine
@
text
@d45 1
a45 1
    "$Id: L2ParInfo.f90,v 2.40 2004/12/14 21:53:30 pwagner Exp $"
d325 1
a325 1
    call output (count(machines%free), advance='yes')
d744 3
@


2.40
log
@Added machine_T, tags and signals related to l2q
@
text
@d45 1
a45 1
    "$Id: L2ParInfo.f90,v 2.39 2004/09/16 23:57:32 pwagner Exp $"
d306 1
a306 1
  subroutine dump_machine_database(machines)
d309 1
d312 1
d318 2
d322 5
d744 3
@


2.39
log
@Now tracks machine names of failed chunks
@
text
@d9 1
d11 1
a11 1
    & MLSMSG_Deallocate
d25 5
a29 2
  public :: L2ParallelInfo_T, parallel, InitParallel, CloseParallel
  public :: SIG_ToJoin, SIG_Finished, SIG_Register, ChunkTag, InfoTag, SlaveJoin
d33 2
d37 1
a37 1
  public :: FinishedDirectWrite, MachineNameLen, GetMachineNames
d45 1
a45 1
    "$Id: L2ParInfo.f90,v 2.38 2004/09/16 00:18:03 pwagner Exp $"
d56 5
a60 3
  integer, parameter :: CHUNKTAG   = 10
  integer, parameter :: INFOTAG    = ChunkTag + 1
  integer, parameter :: NOTIFYTAG  = InfoTag + 1
d74 4
d133 11
d150 1
d164 1
a164 1
    call NextPVMArg ( arg )
d170 29
d241 1
a241 1
  subroutine CloseParallel(noSlaves)
d244 1
d251 1
d254 2
d257 2
d261 2
d266 2
d271 3
a273 1

d287 1
a287 1
      do slave=1, noSlaves
d305 36
d524 1
d527 21
d735 3
@


2.38
log
@Keeps record of completed, failed chunks
@
text
@d39 1
a39 1
    "$Id: L2ParInfo.f90,v 2.37 2004/08/05 22:47:47 pwagner Exp $"
d93 1
d95 2
d612 3
@


2.37
log
@New --chunkRange option to run selected chunks in parallel mode
@
text
@d39 1
a39 1
    "$Id: L2ParInfo.f90,v 2.36 2004/01/22 00:56:35 pwagner Exp $"
d93 1
d96 2
d609 3
@


2.36
log
@Fixed many bugs in auto-distribution of DirectWrites
@
text
@d39 1
a39 1
    "$Id: L2ParInfo.f90,v 2.35 2004/01/02 23:36:00 pwagner Exp $"
d90 3
d606 3
@


2.35
log
@DirectWrites may choose files automatically from db
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d39 1
a39 1
    "$Id: L2ParInfo.f90,v 2.34 2003/12/11 23:00:58 pwagner Exp $"
d120 4
d432 2
a433 2
  ! ---------------------------------------- LogDirectWriteRequest --
  subroutine LogDirectWriteRequest ( filename, node )
d460 32
a491 1
  end subroutine LogDirectWriteRequest
d497 2
a498 1
    integer, intent(out) :: THEFILE     ! What is the file name
d520 3
d526 1
a526 1
      theFile = I4(4)
d603 3
@


2.34
log
@Make master task wait for slaves stdout buffers to flush
@
text
@d39 1
a39 1
    "$Id: L2ParInfo.f90,v 2.33 2003/11/14 23:37:13 pwagner Exp $"
d459 1
a459 1
  subroutine WaitForDirectWritePermission ( node, ticket, createFile )
d462 1
d469 1
a469 1
    integer :: I3(3)                    ! Information from master
d481 1
a481 1
      call PVMF90Unpack ( i3, info )
d484 4
a487 3
      node = i3(1)
      ticket = i3(2)
      createFile = i3(3) /= 0
d564 3
@


2.33
log
@Lets user change masterLoop delay via commandline option
@
text
@d39 1
a39 1
    "$Id: L2ParInfo.f90,v 2.32 2003/08/11 23:23:31 pwagner Exp $"
d48 2
d175 1
a175 2
  subroutine CloseParallel
    use Output_m, only: PRUNIT
d177 1
d183 1
d185 1
a185 1
    ! Exeuctable code
d206 6
d562 3
@


2.32
log
@ChunkNo component added to L2ParallelInfo_T
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d9 2
a10 1
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_Allocate, MLSMSG_Deallocate
d39 1
a39 1
    "$Id: L2ParInfo.f90,v 2.31 2003/08/01 20:26:53 pwagner Exp $"
d82 1
d553 3
@


2.31
log
@slave command name saved as component pgeName
@
text
@d38 1
a38 1
    "$Id: L2ParInfo.f90,v 2.30 2003/07/07 17:32:10 livesey Exp $"
d75 3
a77 3
    logical :: slave = .false.          ! Set if this is a slace task
    logical :: stageInMemory = .false.  ! Set if master stages to memory rather than a file
    integer :: myTid                    ! My task ID in pvm
d80 1
d85 2
a86 2
    character(len=132) :: stagingFile=DefaultStagingFile ! Filename for possible staging
    integer :: maxFailuresPerMachine = 1 ! More than this then don't use it
d105 1
d551 3
@


2.30
log
@New approach to DirectWrite
@
text
@d38 1
a38 1
    "$Id: L2ParInfo.f90,v 2.29 2003/06/20 19:38:25 pwagner Exp $"
d80 1
d549 3
@


2.29
log
@Allows direct writing of output products
@
text
@d9 1
a9 1
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_Allocate
d13 1
a13 1
  use MorePVM, only: PVMPACKSTRINGINDEX
d18 1
d26 1
a26 1
  public :: SIG_DirectWriteFinished, SIG_DirectWriteWait, SIG_DirectWriteAbandoned
d29 1
a29 1
  public :: AccumulateSlaveArguments, RequestDirectWritePermission
d31 4
a34 1
  public :: FWMSlaveGroup, MachineFixedTag
d38 1
a38 1
    "$Id: L2ParInfo.f90,v 2.28 2003/05/12 19:04:50 livesey Exp $"
d58 1
a58 2
  integer, parameter :: SIG_DIRECTWRITEABANDONED = SIG_RequestDirectWrite + 1
  integer, parameter :: SIG_DIRECTWRITEGRANTED = SIG_DirectWriteAbandoned + 1
d60 1
a60 2
  integer, parameter :: SIG_DIRECTWRITEWAIT = SIG_DirectWriteFinished + 1
  integer, parameter :: SIG_NEWSETUP = SIG_DirectWriteWait + 1
d88 17
a105 1

d109 4
d128 1
d169 1
d201 56
d258 2
a259 1
  subroutine FinishedDirectWrite
d263 2
d269 3
d349 1
a349 6
      do lun = 20, 99
        inquire ( unit=lun, exist=exist, opened=opened )
        if ( exist .and. .not. opened ) exit
      end do
      if ( opened .or. .not. exist ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & "No logical unit numbers available" )
d398 20
a417 6
  ! ---------------------------------------- RequestDirectWritePermission --
  subroutine RequestDirectWritePermission ( filename, createFile, waitItOut, granted )
    integer, intent(in) :: FILENAME
    logical, intent(out) :: CREATEFILE
    logical, intent(in) :: WAITITOUT    ! Just wait if not granted
    logical, intent(out) :: GRANTED     ! Set if permission granted (and not waiting)
a422 1
    integer :: CREATEFLAG               ! Returned by PVM
d433 4
a436 1
      & call PVMErrorMessage ( info, "packing direct write information" )
d442 25
a466 9
    ! Now wait for a reply.  This may mean waiting for other chunks to
    ! finish writing their part of the file.
    waitForPermission: do
      call PVMFRecv ( parallel%masterTid, InfoTag, bufferID )
      if ( bufferID <= 0 ) call PVMErrorMessage ( bufferID, &
        & 'receiving direct write permission/wait' )
      
      ! Once we have the reply unpack it
      call PVMF90Unpack ( signal, info )
d468 5
a472 27
        & call PVMErrorMessage ( info, 'unpacking direct write permission')
      select case ( signal )
      case ( SIG_DirectWriteGranted )
        granted = .true.
        exit waitForPermission
      case ( SIG_DirectWriteWait )
        ! If we're told to wait, we can either wait it out, in
        ! which case we go round this loop again and wait for a second
        ! message, or we can abandon our request.
        if ( .not. waitItOut ) then
          granted = .false.
          exit waitForPermission
        end if
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Got unrecognised signal from master' )
      end select
      ! If we get here, it means permission was denied and we're happy
      ! to wait so simply wait for the next message.
    end do waitForPermission

    if ( granted ) then
      ! Second piece of info in this packet is the createFile flag
      call PVMF90Unpack ( createFlag, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking create file flag')
      createFile = createFlag == 1
d474 2
a475 9
      ! If permission was not granted, and (by being here), we're
      ! not prepared to wait it out, abandon our request.
      call PVMFInitSend ( PvmDataDefault, bufferID )
      call PVMF90Pack ( SIG_DirectWriteAbandoned, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, "packing direct write abandoned flag" )
      call PVMFSend ( parallel%masterTid, InfoTag, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, "sending direct write abandoned packet" )
d478 1
a478 1
  end subroutine RequestDirectWritePermission
d525 16
d548 3
@


2.28
log
@Added the staging file to L2ParallelInfo_T
@
text
@d13 1
d25 2
a26 1
  public :: SIG_DirectWriteFinished, SIG_NewSetup, SIG_RunMAF, SIG_SendResults
d34 1
a34 1
    "$Id: L2ParInfo.f90,v 2.27 2003/01/27 17:18:58 livesey Exp $"
d54 2
a55 1
  integer, parameter :: SIG_DIRECTWRITEGRANTED = SIG_RequestDirectWrite + 1
d57 2
a58 1
  integer, parameter :: SIG_NEWSETUP = SIG_DirectWriteFinished + 1
d318 1
a318 1
  subroutine RequestDirectWritePermission (filename, createFile )
d321 2
d337 1
a337 1
    call PVMF90Pack ( filename, info )
d347 46
a392 3
    call PVMFRecv ( parallel%masterTid, InfoTag, bufferID )
    if ( bufferID <= 0 ) call PVMErrorMessage ( bufferID, &
      & 'receiving direct write permission' )
a393 10
    ! Once we have the reply unpack it
    call PVMF90Unpack ( signal, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'unpacking direct write permission')
    if ( signal /= SIG_DirectWriteGranted ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Got unrecognised signal from master' )
    call PVMF90Unpack ( createFlag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'unpacking create file flag')
    createFile = createFlag == 1
d448 3
@


2.27
log
@Made master task output it's tid as well as slaves.
@
text
@d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.26 2003/01/17 21:54:21 livesey Exp $"
d62 2
d70 1
d77 1
d409 3
@


2.26
log
@Added the machineFixed stuff
@
text
@d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.25 2002/12/11 01:58:33 livesey Exp $"
d107 2
a112 2
      call output ( 'Task ID: ' )
      call output ( trim(GetNiceTidString ( parallel%myTid ) ), advance='yes' )
d405 3
@


2.25
log
@Added noFWMSlaves
@
text
@d28 1
a28 1
  public :: FWMSlaveGroup
d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.24 2002/11/23 00:13:18 livesey Exp $"
d44 1
d405 3
@


2.24
log
@Increased maxFailuresPerChunk to reflect nature of Raytheon cluster (at
least for the moment).
@
text
@d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.23 2002/10/17 18:19:13 livesey Exp $"
d69 1
d404 4
@


2.23
log
@Added GiveupTag
@
text
@d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.22 2002/10/08 20:33:51 livesey Exp $"
d73 1
a73 1
    integer :: maxFailuresPerChunk = 2 ! More than this then give up on getting it
d403 3
@


2.22
log
@Added notify stuff for FWMParallel
@
text
@d25 1
a25 1
  public :: NotifyTag, GetNiceTidString, SlaveArguments
d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.21 2002/10/08 17:40:56 livesey Exp $"
d44 1
d403 3
@


2.21
log
@Minor bug fix in FWMParallel stuff
@
text
@d11 1
a11 1
    & PVMDATADEFAULT, PVMERRORMESSAGE, PVMF90UNPACK, NEXTPVMARG
d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.20 2002/10/08 17:36:21 pwagner Exp $"
d124 2
d402 3
@


2.20
log
@Added idents to survive zealous Lahey optimizer
@
text
@d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.19 2002/10/06 22:22:47 livesey Exp $"
d125 1
a125 1
        if ( info <= 0 ) &
d400 3
@


2.19
log
@Removed MAFTAG and MAF communication stuff
@
text
@d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.18 2002/10/06 01:10:17 livesey Exp $"
d36 1
d393 4
d400 3
@


2.18
log
@More progress on the fwmParallel stuff
@
text
@d27 2
a28 1
  public :: FinishedDirectWrite, MachineNameLen, MAFTAG, GetMachineNames
d32 1
a32 1
    "$Id: L2ParInfo.f90,v 2.17 2002/10/05 00:43:20 livesey Exp $"
a42 1
  integer, parameter :: MAFTAG     = NotifyTag + 1
d57 2
d122 5
d395 3
@


2.17
log
@Started work on the fwmParallel stuff
@
text
@d24 1
a24 1
  public :: SIG_DirectWriteFinished
d31 1
a31 1
    "$Id: L2ParInfo.f90,v 2.16 2002/07/19 06:07:32 livesey Exp $"
d51 3
d388 3
@


2.16
log
@Cut down MaxFailuresPerChunk
@
text
@d8 2
a9 1
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
d27 1
a27 1
  public :: FinishedDirectWrite
d31 1
a31 1
    "$Id: L2ParInfo.f90,v 2.15 2002/07/17 20:02:17 livesey Exp $"
d42 1
d52 3
d57 1
d88 1
a88 1
  subroutine InitParallel ( chunkNo )
d91 1
d111 3
d169 123
a291 1
    
d385 3
@


2.15
log
@Bug fix
@
text
@d30 1
a30 1
    "$Id: L2ParInfo.f90,v 2.14 2002/07/17 20:01:42 livesey Exp $"
d60 1
a60 1
    integer :: maxFailuresPerChunk = 4 ! More than this then give up on getting it
d253 3
@


2.14
log
@Put an advance=yes in there
@
text
@d15 1
d30 1
a30 1
    "$Id: L2ParInfo.f90,v 2.13 2002/07/17 19:54:52 livesey Exp $"
d253 3
@


2.13
log
@Made slaves at least identify themselves
@
text
@d29 1
a29 1
    "$Id: L2ParInfo.f90,v 2.12 2002/05/22 00:48:28 livesey Exp $"
d95 1
a95 1
      call output ( trim(GetNiceTidString ( parallel%myTid ) ) )
d252 3
@


2.12
log
@Added direct write stuff
@
text
@d29 1
a29 1
    "$Id: L2ParInfo.f90,v 2.11 2002/04/24 16:53:50 livesey Exp $"
d93 3
d252 3
@


2.11
log
@Changes to implement submit.
@
text
@d21 5
a25 2
  public :: SIG_AckFinish, NotifyTag, GetNiceTidString, SlaveArguments
  public :: AccumulateSlaveArguments
d29 1
a29 1
    "$Id: L2ParInfo.f90,v 2.10 2002/03/21 01:23:36 livesey Exp $"
d45 3
d139 62
d249 3
@


2.11.2.1
log
@*** empty log message ***
@
text
@d21 2
a22 5
  public :: SIG_AckFinish, SIG_RequestDirectWrite, SIG_DirectWriteGranted
  public :: SIG_DirectWriteFinished
  public :: NotifyTag, GetNiceTidString, SlaveArguments
  public :: AccumulateSlaveArguments, RequestDirectWritePermission
  public :: FinishedDirectWrite
d26 1
a26 1
    "$Id: L2ParInfo.f90,v 2.12 2002/05/22 00:48:28 livesey Exp $"
a41 3
  integer, parameter :: SIG_REQUESTDIRECTWRITE = SIG_Register + 1
  integer, parameter :: SIG_DIRECTWRITEGRANTED = SIG_RequestDirectWrite + 1
  integer, parameter :: SIG_DIRECTWRITEFINISHED = SIG_DirectWriteGranted + 1
a132 62
  ! --------------------------------------- FinishedDirectWrite ------------
  subroutine FinishedDirectWrite
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    ! Local variables
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_DirectWriteFinished, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write finished flag" )

    call PVMFSend ( parallel%masterTid, InfoTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "sending direct write finished packet" )
    
    ! Executable code
  end subroutine FinishedDirectWrite
    

  ! ---------------------------------------- RequestDirectWritePermission --
  subroutine RequestDirectWritePermission (filename, createFile )
    integer, intent(in) :: FILENAME
    logical, intent(out) :: CREATEFILE

    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    integer :: SIGNAL                   ! From Master
    integer :: CREATEFLAG               ! Returned by PVM

    ! Executable code

    ! Pack and dispatch
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_RequestDirectWrite, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write request flag" )
    call PVMF90Pack ( filename, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "packing direct write information" )

    call PVMFSend ( parallel%masterTid, InfoTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, "sending direct write request packet" )

    ! Now wait for a reply.  This may mean waiting for other chunks to
    ! finish writing their part of the file.
    call PVMFRecv ( parallel%masterTid, InfoTag, bufferID )
    if ( bufferID <= 0 ) call PVMErrorMessage ( bufferID, &
      & 'receiving direct write permission' )

    ! Once we have the reply unpack it
    call PVMF90Unpack ( signal, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'unpacking direct write permission')
    if ( signal /= SIG_DirectWriteGranted ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Got unrecognised signal from master' )
    call PVMF90Unpack ( createFlag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'unpacking create file flag')
    createFile = createFlag == 1
  end subroutine RequestDirectWritePermission

a180 6
! Revision 2.12  2002/05/22 00:48:28  livesey
! Added direct write stuff
!
! Revision 2.11  2002/04/24 16:53:50  livesey
! Changes to implement submit.
!
@


2.10
log
@Changed thresholds
@
text
@d10 1
a10 1
    & PVMDATADEFAULT, PVMERRORMESSAGE, PVMF90UNPACK
d20 3
a22 2
  public :: SIG_ToJoin, SIG_Finished, ChunkTag, InfoTag, SlaveJoin
  public :: SIG_AckFinish, NotifyTag, GetNiceTidString
d26 1
a26 1
    "$Id: L2ParInfo.f90,v 2.9 2001/10/30 01:45:21 livesey Exp $"
d41 1
d50 2
d59 1
d63 11
d75 1
a75 1
  subroutine InitParallel
d77 4
d85 13
d181 3
@


2.9
log
@Some modifications/fixes to parallel join
@
text
@d25 1
a25 1
    "$Id: L2ParInfo.f90,v 2.8 2001/09/08 00:21:44 pwagner Exp $"
d48 2
a49 2
    integer :: maxFailuresPerMachine = 8 ! More than this then don't use it
    integer :: maxFailuresPerChunk = 3 ! More than this then give up on getting it
d148 3
@


2.8
log
@Revised to work for new column Abundance in lone swaths
@
text
@d25 1
a25 1
    "$Id: L2ParInfo.f90,v 2.7 2001/05/30 23:53:54 livesey Exp $"
d101 1
a101 1
  subroutine SlaveJoin ( quantity, precisionQuantity, BPQuantity, hdfName, key )
a104 1
    type (VectorValue_T), pointer :: BPQUANTITY ! Tropopause if colm. abund.
a110 1
    integer :: GOTBP                    ! really boolean
a116 6
    if ( associated ( BPQuantity) ) then
      gotBP = 1
    else
      gotBP = 0
    endif

d120 1
a120 1
    call PVMF90Pack ( (/key, gotPrecision, gotBP /), info )
d122 1
a122 1
       & call PVMErrorMessage ( info, "packing key, gotPrecision, gotBP" )
d126 1
a126 1
    call PVMSendQuantity ( quantity, justPack=.true. )
d128 1
a128 4
      call PVMSendQuantity ( precisionQuantity, justPack=.true. )
    
    if ( associated ( BPQuantity ) ) &
      call PVMSendQuantity ( BPQuantity, justPack=.true. )
d148 3
@


2.7
log
@Vectors now sent within info packets
@
text
@d25 1
a25 1
    "$Id: L2ParInfo.f90,v 2.6 2001/05/29 20:42:18 pwagner Exp $"
d101 2
a102 2
  subroutine SlaveJoin ( quantity, precisionQuantity, hdfName, key )
    ! This simply sends a vector quantity (or two) down a pvm spigot.
d105 1
d112 1
d119 6
d128 3
a130 2
    call PVMF90Pack ( (/key, gotPrecision /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing key, gotPrecision" )
d138 3
d159 3
@


2.6
log
@Added Log at bottom of source
@
text
@d25 1
a25 1
    "$Id: L2ParInfo.f90,v 2.5 2001/05/29 20:39:57 pwagner Exp $"
d48 2
a49 2
    integer :: maxFailuresPerMachine = 3 ! More than this then don't use it
    integer :: maxFailuresPerChunk = 6 ! More than this then give up on getting it
d124 5
a132 4
    call PVMSendQuantity ( quantity, parallel%masterTid )
    if ( associated ( precisionQuantity ) ) &
      call PVMSendQuantity ( precisionQuantity, parallel%masterTid )
    
d147 3
@


2.5
log
@Replaced ref to downcase with LowerCase
@
text
@d25 1
a25 1
    "$Id: L2ParInfo.f90,v 2.4 2001/05/26 00:20:45 livesey Exp $"
d145 1
@


2.4
log
@Added GetNiceTidString
@
text
@d14 1
a14 1
  use MLSStrings, only: DOWNCASE
d25 1
a25 1
    "$Id: L2ParInfo.f90,v 2.3 2001/05/25 05:00:07 livesey Exp $"
d140 1
a140 1
    GetNiceTidString = '[t'//trim(downcase ( GetNiceTidString ))//']'
@


2.3
log
@Increased default limits
@
text
@d14 1
d21 1
a21 1
  public :: SIG_AckFinish, NotifyTag
d25 1
a25 1
    "$Id: L2ParInfo.f90,v 2.2 2001/05/25 01:03:47 livesey Exp $"
d134 9
d144 1
@


2.2
log
@Working parallel version
@
text
@d24 1
a24 1
    "$Id: L2ParInfo.f90,v 2.1 2001/05/23 21:59:54 livesey Exp $"
d48 1
a48 1
    integer :: maxFailuresPerChunk = 2 ! More than this then give up on getting it
@


2.1
log
@First version
@
text
@d10 1
a10 1
    & PVMDATADEFAULT, PVMERRORMESSAGE
d20 1
d24 1
a24 1
    "$Id: L2Parallel.f90,v 2.4 2001/05/23 03:46:41 livesey Exp $"
d27 1
a27 1
    "$RCSfile: L2Parallel.f90,v $"
d34 1
d38 1
d47 2
d73 2
d77 1
d81 1
a81 2
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to pack finished signal' )
d84 12
a95 2
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to send finish packet' )
d125 1
a125 2
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to send join packet' )
@

