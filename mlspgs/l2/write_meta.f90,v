head	2.84;
access;
symbols
	v5-02-NRT-19:2.84
	v6-00:2.84
	v5-02-NRT-18:2.84
	v5-02:2.84
	v5-01-NRT-17:2.84
	v5-01-NRT-16:2.84
	v5-01-NRT-15:2.84
	v5-01-NRT-14:2.84
	neuralnetworks-1-0:2.84.0.8
	cfm-single-freq-0-1:2.84.0.6
	v5-01:2.84
	v5-00:2.84
	v4-23-TA133:2.84.0.4
	mus-emls-1-70:2.84.0.2
	rel-1-0-englocks-work:2.82.0.2
	VUMLS1-00:2.82
	VPL1-00:2.82
	V4-22-NRT-08:2.82
	VAM1-00:2.82
	V4-21:2.81.0.2
	V4-13:2.81
	V4-12:2.80
	V4-11:2.80
	V4-10:2.80
	V3-43:2.67
	M4-00:2.72
	V3-41:2.67
	V3-40-PlusGM57:2.67.0.2
	V2-24-NRT-04:2.62
	V3-33:2.67
	V2-24:2.62
	V3-31:2.67
	V3-30-NRT-05:2.67
	cfm-01-00:2.67
	V3-30:2.67
	V3-20:2.67
	V3-10:2.67
	V2-23-NRT-02:2.62
	V2-23:2.62
	V2-22-NRT-01:2.62
	V2-22:2.62
	V2-21:2.61
	V2-20:2.61
	V2-11:2.61
	V2-10:2.61
	V2-00:2.61
	V1-51:2.57
	V1-50:2.56
	V1-45:2.53
	V1-44:2.53
	V1-43:2.52
	V1-32:2.52
	V1-31:2.51
	V1-30:2.51
	V1-13:2.41
	V1-12:2.41
	V1-11:2.41
	V1-10:2.36
	newfwm-feb03:2.37.0.2
	V1-04:2.27
	V1-03:2.27
	V1-02:2.27
	JointForwardModel:2.27.0.2
	V1-00:2.27
	newfwm-sep01:2.18.0.2
	V0-7:2.18
	V0-5-Level2:2.14
	V0-5-SIPS:2.11
	V0_1:1.4;
locks; strict;
comment	@# @;


2.84
date	2018.05.31.22.48.40;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2018.04.19.01.14.16;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2015.03.28.02.56.12;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2014.09.05.01.28.53;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2014.04.07.18.10.09;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2014.03.26.17.47.44;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2014.03.07.19.30.30;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2013.12.05.01.42.03;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2013.09.24.23.47.23;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2013.07.26.00.07.35;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2013.07.18.22.39.37;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2013.04.19.20.07.28;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2013.04.12.00.06.35;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2011.07.12.22.35.03;	author honghanh;	state Exp;
branches;
next	2.69;

2.69
date	2011.06.29.21.52.53;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2011.05.09.18.28.30;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2009.06.23.18.46.19;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2009.06.02.17.53.15;	author cvuu;	state Exp;
branches;
next	2.65;

2.65
date	2008.05.02.00.33.53;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2008.02.22.21.37.05;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2007.12.07.01.50.32;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2007.06.21.00.54.08;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2006.03.15.23.52.24;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2006.02.21.19.12.00;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2005.07.21.23.45.03;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2005.01.27.00.35.06;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2005.01.14.21.37.30;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2004.12.15.23.34.32;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2004.12.14.21.41.53;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2004.08.04.23.19.58;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2004.01.30.00.31.10;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2003.09.12.16.32.00;	author cvuu;	state Exp;
branches;
next	2.50;

2.50
date	2003.09.04.22.41.09;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2003.09.03.23.56.24;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2003.08.11.17.29.36;	author cvuu;	state Exp;
branches;
next	2.47;

2.47
date	2003.08.01.20.25.08;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2003.07.23.18.27.44;	author cvuu;	state Exp;
branches;
next	2.45;

2.45
date	2003.07.07.23.48.18;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2003.06.09.22.49.35;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2003.05.30.23.50.32;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2003.04.03.22.58.40;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2003.03.15.00.15.52;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2003.03.11.00.21.36;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2003.03.07.00.55.38;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2003.02.27.21.54.28;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2003.02.10.22.02.41;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2003.02.01.00.29.40;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2003.01.30.01.01.05;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2003.01.14.00.42.24;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2002.12.11.22.21.05;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2002.12.06.23.37.22;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2002.11.22.12.31.16;	author mjf;	state Exp;
branches;
next	2.30;

2.30
date	2002.10.08.17.36.23;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2002.08.29.16.55.35;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2002.08.28.22.27.26;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2002.03.13.18.31.01;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2002.02.22.19.20.12;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2002.02.22.01.18.06;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2002.01.31.00.37.45;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2002.01.26.00.08.20;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2002.01.23.21.50.04;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2002.01.22.17.45.26;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2002.01.18.23.11.09;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2002.01.09.23.54.24;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2001.05.17.22.33.27;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2001.05.08.23.28.46;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2001.05.07.23.30.05;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2001.05.07.18.04.51;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2001.05.03.20.34.20;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.20.23.52.15;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.19.23.51.40;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.16.23.49.11;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.16.17.43.35;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.13.23.47.26;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2001.04.13.00.28.03;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.04.12.00.22.17;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2001.04.11.20.20.37;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2001.04.10.23.03.57;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2001.04.09.23.45.47;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2001.04.03.23.51.28;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2001.04.02.23.42.18;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.13.22.59.36;	author pwagner;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.07;	author ahanzel;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.30.00.16.41;	author lungu;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.28.01.40.15;	author lungu;	state Exp;
branches;
next	;


desc
@@


2.84
log
@Changed name of attribute to identifier_product_doi to please DAAC
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! -------------------------------------------------------
module WriteMetadata ! Populate metadata and write it out
! -------------------------------------------------------

  use Dump_0, only: Dump
  use HDF, only: Dfacc_Rdwr
  use HighOutput, only: Beverbose, OutputnamedValue
  use Init_Tables_Module, only: L_L2dgg, L_L2gp, L_HDF, L_Swath
  use Io_Stuff, only: Read_TextFile
  use Lexer_Core, only: Print_Source
  use MLSCommon, only: Filenamelen, Namelen, L2metaData_T, MLSFile_T
  use MLSKinds, only: R8
  use MLSFiles, only: Dump, Getpcfromref, MLS_CloseFile, MLS_OpenFile, &
    & MLS_Sfstart, MLS_Sfend, Split_Path_Name
  use MLSL2options, only: Toolkit, Sharedpcf
  use MLSMessagemodule, only: MLSMessage, MLSMSG_Warning
  use MLSPcf2, only: MLSPcf_Mcf_L2gp_End, MLSPcf_Mcf_L2gp_Start, &
    & MLSPcf_Mcf_L2log_Start
  use MLSStrings, only: Iscomment, Lowercase, Streq
  use MLSStringlists, only: Extractsubstring, &
    & GethashElement, GetstringElement
  use Output_M, only: Output, Blanks
  use Pcfhdr, only: Writeinputpointer, Writepcf2hdr, Globalattributes
  use Sdptoolkit, only: Pgsd_Met_Group_Name_L, &
    & Pgsd_Met_Num_Of_Groups, Pgsd_Pc_File_Path_Max, Pgs_Pc_Getreference, &
    & Pgspc_W_No_Reference_Found, Pgs_S_Success, Pgsmet_W_MetaData_Not_Set
  use Tree, only: Where

  implicit none

  private

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: write_meta.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (parameters and datatypes)
! MCGROUP_T          metadata control group
! MCPARAM_T          metadata control object; e.g. PGEVersion
! PCFData_T          metadata-relevant data taken from PCF

!     (subroutines and functions)
! addMCGroupToDatabase  Adds a new MCGroup to existing database of them
! addMCParamToDatabase  Adds a new MC Parameter to existing database of them
! addToMetadata         Adds a new metadata field onto an existing file
! destroyMCGroup        Deallocates any arrays in a MCGroup
! destroyMCGroupDB      Destroys each MCGroup in a database of them, 
!                        then deallocates it, too
! dumpMCGroup           Dumps all the parameters in a MCGroup
! dumpMCGroupDB         dumps each MCGroup in a database of them
! get_l2gp_mcf          Finds the mcf relevant for a given species based on
!                        its file name 
! mctree                parse list of mc odl-like character args
! NullifyPCFData        Nullify all pointers associated with a PCFData_T
! Populate_metadata_std Write metadata to a standard l2 product file, e.g. H2O
! Populate_metadata_oth Write metadata to other l2 product files, e.g. DGG, DGM
! readMCF               Read a metadata control file (mcf) into a database of
!                         metadata control groups
! writemetalog          Write metadata for the log file
! writeMCF              Write a database of metadata control groups to
!                         a metadata control file (mcf)
! === (end of toc) ===

! === (start of api) ===
! addMCGroupToDatabase (type MCGroup_T dataBase(:), type MCGroup_T item)
! addMCParamToDatabase (type MCParam_T dataBase(:), type MCParam_T item)
! addToMetadata (char* mcf_grp, char* mcf_grp, value)
!      where value can be a single, double, integer, or string
! DestroyMCGroup (type MCGroup_T MCGroup)
! DestroyMCGroupDB (type MCGroup_T MCGroupDB(:))
! dumpMCGroup (type MCGroup_T MCGroup)
! dumpMCGroupDB (type MCGroup_T MCGroupDB(:))
! Get_l2gp_mcf (char* file_base, char* meta_name, int mcf, int version)
! mctree ( char* list(:), type MCGroup mcdb*(:) )
! NullifyPCFData (type PCFData_T P)
! Populate_metadata_std ( int hdf_file, int mcf_file, &
!   & char* Field_name, type(L2Metadata_T) l2metaData, &
!   & [int hdfVersion], [int Metadata_error], &
!   & [int filetype] )
! Populate_metadata_oth ( int hdf_file, int mcf_file, &
!   & int NumQuantitiesPerFile, char* QuantityNames, &
!   & type(L2Metadata_T) l2metaData, &
!   & [int hdfVersion], [int Metadata_error], &
!   & [int filetype] )
! readMCF (type MLSFile_T MLSFile, type MCGroup_T MCGroups(:))
! writeMCF (type MLSFile_T MLSFile, type MCGroup_T MCGroups(:))
! WriteMetaLog ([int metadata_error])
! === (end of api) ===

  public :: AddmcgrouptoDatabase, AddmcparamtoDatabase, AddtometaData, &
    & Destroy, Destroymcgroup, Destroymcgroupdb, &
    & Dump, Dumpmcgroup, Dumpmcgroupdb, &
    & Get_L2gp_Mcf, Mctree, NullifypcfData, &
    & Populate_MetaData_Std, Populate_MetaData_Oth, &
    & Readmcf, Writemcf, Writemetalog


! This data type is used to store User-defined Runtime Parameters and other
! information taken from the PCF.
! Why are these len=80 instead of, say, len=NameLen?
! If they need to be 80, then shouldn't NameLen be 80, too?
  type, public :: MCGROUP_T
    character (len=80) :: name = ' '
    character (len=80) :: class         = ' '
    character (len=80) :: type = ' '
    type(MCGROUP_T), dimension(:), pointer :: groups => null()
    type(MCPARAM_T), dimension(:), pointer :: params => null()
  end type MCGROUP_T

  type, public :: MCPARAM_T
    character (len=80) :: name          = ' '
    character (len=80) :: mandatory     = ' '
    character (len=80) :: data_location = ' '
    character (len=80) :: class         = ' '
    character (len=80) :: num_val       = ' '
    character (len=80) :: type          = ' '
    character (len=256) :: value        = ' '
    type(MCGROUP_T), dimension(:), pointer :: groups => null()
    type(MCPARAM_T), dimension(:), pointer :: params => null()
  end type MCPARAM_T

  type, public :: PCFData_T

    ! cycle # of processing run
    character (len=4) :: cycle         ! add to output files

    ! id string processing run
    character (len=16) :: RunID = ' '

    ! version string in PCF output file names
    character (len=15) :: PGEVersion   ! add to output files

    character(len=27) :: StartUTC
    character(len=27) :: EndUTC

    ! The annotation text to be written to the header of every scientific
    ! data file for which we need metadata
    ! In practice, this annotation will be the contents of the PCF file itself

    character (len=1), pointer :: AnText(:) => null()

    !     How to choose the mcf file to be used in writing metadata
    !                          (3)
    ! The SPECIES of the corresponding
    ! MCF file names are chosen from an associative array structure
    ! or hash table, where the keys are the possible species and
    ! the hash
    ! how to associate l2gp species names with mcf files

    ! if an associative array, then l2gp file names contain the "keys"
    ! the following is a comma-delimited list of possible species
    ! names that may be such keys

    ! Note that the text matching in options (2) and (3)
    ! will not be case sensitive unless you set MCFCASESENSITIVE

    !                          (*)
    ! Finally, you can avoid any of this trickery by using the metaName=
    ! field for each file. For example, if you set metaName='o3', the
    ! mcf matching o3 will be selected, no matter what you named the l2gp file.
    character (len=fileNameLen) :: spec_keys

    ! the following is a comma-delimited list of possible
    ! mcf file name parts that may be the corresponding hash values
    character (len=fileNameLen) :: spec_mcfnames      

    ! DOIs
    character (len=20*NameLen) :: spec_doinames   

    ! name of the log file (without the path)
    character (len=fileNameLen) :: logGranID

    ! identifier_product_doi
    character (len=32) :: DOI     ! unique for each type

  end type PCFData_T

  interface addToMetadata
    module procedure addToMetadata_dbl
    module procedure addToMetadata_int
    module procedure addToMetadata_sngl
    module procedure addToMetadata_str
  end interface
  interface DESTROY
    module procedure DESTROYMCGROUP
    module procedure DESTROYMCGROUPDB
  end interface
  interface DUMP
    module procedure DUMPMCPARAM
    module procedure DUMPMCGROUP
    module procedure DUMPMCGROUPDB
  end interface
  integer, public, parameter :: INVENTORYMETADATA = 2
  logical, public, parameter :: MCFCASESENSITIVE = .FALSE.
  logical, public, parameter :: ANNOTATEWITHPCF = .TRUE.
  logical, public, parameter :: SETINPUTPOINTER = .not. ANNOTATEWITHPCF
  logical, public, parameter :: SFINBETWEENSTARTEND = .FALSE.
  integer, public, parameter :: MCFFORL2GPOPTION = 3     ! 1, public, 2 or 3
  integer, private :: Module_error
  integer, private :: nest_degree
  type(PCFData_T), public, save :: L2PCF
  character(len=*), parameter :: spaces = '                                  ' &
    & // '                                                                    '
  logical, private, parameter :: countEmpty = .true.

contains

  !-----------------------------------------  AddMCGroupToDatabase  -----
  integer function AddMCGroupToDatabase ( DATABASE, ITEM )

  ! This routine adds a vector to a database of such vectors, 
  ! creating the database if necessary.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (MCGroup_T), dimension(:), pointer :: DATABASE
    type (MCGroup_T), intent(in) ::            ITEM

    ! Local variables
    type (MCGroup_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddMCGroupToDatabase = newSize
  end function AddMCGroupToDatabase

  !-----------------------------------------  AddMCParamToDatabase  -----
  integer function AddMCParamToDatabase ( DATABASE, ITEM )

  ! This routine adds a vector to a database of such vectors, 
  ! creating the database if necessary.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (MCParam_T), dimension(:), pointer :: DATABASE
    type (MCParam_T), intent(in) ::            ITEM

    ! Local variables
    type (MCParam_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddMCParamToDatabase = newSize
  end function AddMCParamToDatabase

  ! ------------ addToMetadata
  ! This family of routines adds on to existing metadata in a file
  subroutine addToMetadata_dbl( MCF_GRP, ATTRNAME, VALUE )
    ! Args
    character (len = PGSd_MET_GROUP_NAME_L), intent(in) :: MCF_GRP
    character(len=*), intent(in)     :: ATTRNAME
    double precision, intent(in)     :: VALUE
    integer, external :: PGS_MET_SETATTR_D
    ! Local variables
    integer :: status
    ! Executable
    status = pgs_met_setAttr_d ( mcf_grp, trim(attrName), value )
    if ( status /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing " // trim(attrName) )
    end if
  end subroutine addToMetadata_dbl

  subroutine addToMetadata_int( MCF_GRP, ATTRNAME, VALUE )
    ! Args
    character (len = PGSd_MET_GROUP_NAME_L), intent(in) :: MCF_GRP
    character(len=*), intent(in)     :: ATTRNAME
    integer, intent(in)     :: VALUE
    integer, external :: PGS_MET_SETATTR_I
    ! Local variables
    integer :: status
    ! Executable
    status = pgs_met_setAttr_i ( mcf_grp, trim(attrName), value )
    if ( status /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing " // trim(attrName) )
    end if
  end subroutine addToMetadata_int

  subroutine addToMetadata_sngl( MCF_GRP, ATTRNAME, VALUE )
    ! Args
    character (len = PGSd_MET_GROUP_NAME_L), intent(in) :: MCF_GRP
    character(len=*), intent(in)     :: ATTRNAME
    real, intent(in)                 :: VALUE
    integer, external :: PGS_MET_SETATTR_D
    ! Local variables
    integer :: status
    ! Executable
    status = pgs_met_setAttr_d ( mcf_grp, trim(attrName), value*1.0d0 )
    if ( status /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing " // trim(attrName) )
    end if
  end subroutine addToMetadata_sngl

  subroutine addToMetadata_str( MCF_GRP, ATTRNAME, VALUE )
    ! Args
    character (len = PGSd_MET_GROUP_NAME_L), intent(in) :: MCF_GRP
    character(len=*), intent(in)     :: ATTRNAME
    character(len=*), intent(in)     :: VALUE
    integer, external :: PGS_MET_SETATTR_S
    ! Local variables
    integer :: status
    ! Executable
    status = pgs_met_setAttr_s ( mcf_grp, trim(attrName), value )
    if ( status /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing " // trim(attrName) )
    end if
  end subroutine addToMetadata_str

  ! ----------------------------------------DestroyMCGroup -----
  recursive subroutine DestroyMCGroup ( MCGROUP )
    ! Destroy a group of inventory metadata control parameters 
    ! If the group contains other groups, destroy them, too
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type ( MCGROUP_T ), intent(inout)               :: MCGROUP
    ! Internal variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: error, i, s

    ! Executable code
    if ( associated(MCGroup%groups) ) then
      do i=1, size(MCGroup%groups)
        call DestroyMCGroup( MCGroup%groups(i) )
      end do
      s = size(MCGroup%groups) * storage_size(MCGroup%groups) / 8
      addr = 0
      if ( s > 0 ) addr=transfer(c_loc(MCGroup%groups(1)), addr)
      deallocate ( MCGroup%groups, stat=error )
      call test_deallocate ( error, moduleName, 'MCGroup%groups', s, address=addr )
    end if
    if ( associated(MCGroup%params) ) then
      do i=1, size(MCGroup%params)
        call DestroyMCParam( MCGroup%params(i) )
      end do
      s = size(MCGroup%params) * storage_size(MCGroup%params) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MCGroup%params(1)), addr)
      deallocate ( MCGroup%params, stat=error )
      call test_deallocate ( error, moduleName, 'MCGroup%params', s, address=addr )
    end if
  end subroutine DestroyMCGroup

  ! ----------------------------------------DestroyMCParam -----
  recursive subroutine DestroyMCParam ( MCParam )
    ! Destroy a metadata control parameter
    ! If it contains other params and groups, destroy them, too
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type ( MCParam_T ), intent(inout)               :: MCParam
    ! Internal variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: error, i, s

    ! Executable code
    if ( associated(MCParam%groups) ) then
      do i=1, size(MCParam%groups)
        call DestroyMCGroup( MCParam%groups(i) )
      end do
      s = size(MCParam%groups) * storage_size(MCParam%groups) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MCParam%groups(1)), addr)
      deallocate ( MCParam%groups, stat=error )
      call test_deallocate ( error, moduleName, 'MCParam%groups', s, address=addr )
    end if
    if ( associated(MCParam%params) ) then
      do i=1, size(MCParam%params)
        call DestroyMCParam( MCParam%params(i) )
      end do
      s = size(MCParam%params) * storage_size(MCParam%params) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(MCParam%params(1)), addr)
      deallocate ( MCParam%params, stat=error )
      call test_deallocate ( error, moduleName, 'MCParam%params', s, address=addr )
    end if
  end subroutine DestroyMCParam

  ! ----------------------------------------DestroyMCGroupDB -----
  subroutine DestroyMCGroupDB ( MCGROUPDB )
    ! Destroy a database of metadata control groups
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type ( MCGROUP_T ), dimension(:), pointer         :: MCGROUPDB
    ! Internal variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: error, i, s

    ! Executable code
    if ( .not. associated(MCGROUPDB) ) return
    do i=1, size(MCGroupDB)
      call DestroyMCGroup( MCGroupDB(i) )
    end do
    s = size(MCGroupDB) * storage_size(MCGroupDB) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(MCGroupDB(1)), addr)
    deallocate ( MCGroupDB, stat=error )
    call test_deallocate ( error, moduleName, 'MCGroupDB', s, address=addr )
  end subroutine DestroyMCGroupDB

  ! ----------------------------------------dumpMCGroup -----
  recursive subroutine dumpMCGroup ( MCGROUP )
    ! dump a group of inventory metadata control parameters 
    ! If the group contains other groups, dump them, too
    type ( MCGROUP_T ), intent(in)               :: MCGROUP
    ! Internal variables
    integer :: i
    integer :: indent

    ! Executable code
    indent = nest_degree*3
    if ( len_trim(MCGroup%name) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'group name', &
      & MCGroup%name )
    if ( len_trim(MCGroup%class) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'class', &
      & MCGroup%class )
    if ( len_trim(MCGroup%type) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'type', &
      & MCGroup%type )
    nest_degree = nest_degree + 1
    indent = nest_degree*3
    if ( .not. associated(MCGroup%groups) ) then
      call blanks( indent )
      call output( '(No subgroups of this group) ', advance='yes' )
    else
      do i=1, size(MCGroup%groups)
        call blanks( indent )
        call output( 'Sub-group ', advance='no' )
        call output( i, advance='yes' )
        call dumpMCGroup( MCGroup%groups(i) )
      enddo
    endif
    if ( .not. associated(MCGroup%params) ) then
      call blanks( indent )
      call output( '(No parameters in this group) ', advance='yes' )
    else
      do i=1, size(MCGroup%params)
        call dumpMCParam( MCGroup%params(i) )
      enddo
    endif
    nest_degree = nest_degree - 1
  end subroutine dumpMCGroup

  ! ----------------------------------------dumpMCGroupDB -----
  subroutine dumpMCGroupDB ( MCGROUPDB )
    ! dump a database of metadata control groups
    type ( MCGROUP_T ), dimension(:), pointer         :: MCGROUPDB
    ! Internal variables
    integer :: i

    ! Executable code
    if ( .not. associated(MCGROUPDB) ) then
      call output( ' (MCGroup database not associated) ', advance='yes' )
      return
    endif
    call output( 'Dumping MCGroup database with ', advance='no' )
    call output( size(MCGroupDB), advance='no' )
    call output( ' groups ', advance='yes' )
    do i=1, size(MCGroupDB)
      nest_degree = 1
      call dumpMCGroup( MCGroupDB(i) )
    enddo
  end subroutine dumpMCGroupDB

  ! ----------------------------------------dumpMCParam -----
  recursive subroutine dumpMCParam ( MCParam )
    ! dump a group of inventory metadata control parameters 
    ! If the group contains other groups, dump them, too
    type ( MCParam_T ), intent(in)               :: MCParam
    ! Internal variables
    integer :: i
    integer :: indent

    ! Executable code
    indent = nest_degree*3
    if ( len_trim(MCParam%name) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'parameter name', &
      & MCParam%name )
    nest_degree = nest_degree + 1
    indent = nest_degree*3
    if ( .not. associated(MCParam%groups) ) then
      call blanks( indent )
      call output( '(No subgroups of this parameter) ', advance='yes' )
    else
      do i=1, size(MCParam%groups)
        call blanks( indent )
        call output( 'Sub-group ', advance='no' )
        call output( i, advance='yes' )
        call dumpMCGroup( MCParam%groups(i) )
      enddo
    endif
    if ( .not. associated(MCParam%params) ) then
      call blanks( indent )
      call output( '(No parameters in this parameter) ', advance='yes' )
    else
      do i=1, size(MCParam%params)
        call dumpMCParam( MCParam%params(i) )
      enddo
    endif
    indent = nest_degree*3
    indent = indent + 4
    if ( len_trim(MCParam%name) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'name', &
      & MCParam%name )
    if ( len_trim(MCParam%mandatory) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'mandatory', &
      & MCParam%mandatory )
    if ( len_trim(MCParam%data_location) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'data_location', &
      & MCParam%data_location )
    if ( len_trim(MCParam%class) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'class', &
      & MCParam%class )
    if ( len_trim(MCParam%num_val) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'num_val', &
      & MCParam%num_val )
    if ( len_trim(MCParam%type) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'type', &
      & MCParam%type )
    if ( len_trim(MCParam%value) > 0 ) &
      & call outputnamedValue( spaces(:indent)//'value', &
      & MCParam%value )
    nest_degree = nest_degree - 1
  end subroutine dumpMCParam

  ! -----------------------------------------------  Get_l2gp_mcf  -----

  subroutine Get_l2gp_mcf ( File_base, meta_name, Mcf, doiIdentifier )

  ! metadata configuration file (mcf) PCF number corresponding to l2gp number
  ! sdid
  ! Arguments
    character(len=*), intent(in) ::  File_base
    character(len=*), intent(in) ::  meta_name
    integer, intent(inout) ::        Mcf
    ! integer, intent(in), optional :: Version
    character(len=*), intent(out) ::  doiIdentifier

    ! Local
    character (len=PGSd_PC_FILE_PATH_MAX) :: Sd_full
    !character (len=NameLen) :: Sd_path
    character (len=NameLen) :: Sd_name

    character (len=PGSd_PC_FILE_PATH_MAX) :: Mcf_full
    character (len=NameLen) :: Mcf_path
    character (len=NameLen) :: Mcf_name
    integer :: ReturnStatus, MyVersion, I

    character (len=1), parameter :: COMMA = ','

    ! Find species name
    ! assume sd_name is "*l2gp-species_"
    ! hence enclosed between "_" chars after an l2gp

    logical, parameter :: DEBUG = .false.

    ! Begin

    if(.NOT. TOOLKIT) then
      mcf=0
      return
   endif

    ! if ( MCFFORL2GPOPTION == 1 ) then
    !  mcf = mcf+1
    !  return
    ! end if

    if ( DEBUG ) then
      call output('file_base: ', advance='no')
      call output(trim(file_base), advance='yes')
      call output('meta_name: ', advance='no')
      call output(trim(meta_name), advance='yes')
    end if

    if ( len(TRIM(file_base)) <= 0 ) then
      mcf=0
      return
    end if

    if ( meta_name == ' ' ) then
      ! * The following complication is attempting to infer
      ! * the species name based on the file name
      ! * It is necessary only if you disdained to specify the metaName
      ! * field in the output command
      ! Get full file name for typical MCF file
      do i=mlspcf_mcf_l2gp_start, mlspcf_mcf_l2gp_end

        myVersion = 1

        returnStatus = PGS_PC_GetReference(i, myVersion, mcf_full)

        if ( returnStatus == PGS_S_SUCCESS ) then 
          exit
        end if

      end do

      if ( DEBUG ) then
        call output('returnStatus: ', advance='no')
        call output(returnStatus, advance='yes')
      end if

      if ( returnStatus /= PGS_S_SUCCESS ) then 
        mcf = 0
        return
      end if

      ! Split full_file_names into path+name

      call split_path_name ( mcf_full, mcf_path, mcf_name )

      ! If   text matching not case sensitive, shift to lower case
      if ( .NOT. MCFCASESENSITIVE ) then
        sd_full = LowerCase(file_base)
        mcf_name = LowerCase(mcf_name)
      else
        sd_full = file_base
      end if

      if ( DEBUG ) then
        call output('mcf_full: ', advance='no')
        call output(trim(mcf_full), advance='yes')
        call output('mcf_path: ', advance='no')
        call output(trim(mcf_path), advance='yes')
        call output('mcf_name: ', advance='no')
        call output(trim(mcf_name), advance='yes')
      end if

      ! Either we were given a short form of the sd_full
      ! e.g., 'h2o', or else a much longer one like 'mls-aura_...'
      if ( index(sd_full, 'mls-aura_') > 0 ) then
        ! Get species name assuming e.g. 'mls-aura_l2gp-h2O_'
        call ExtractSubString(sd_full, sd_name, 'mls-aura_l2gp-', '_')
      else
        sd_name = sd_full
      endif

      if ( DEBUG ) then
        call output('sd_full: ', advance='no')
        call output(trim(sd_full), advance='yes')
        call output('sd_name: ', advance='no')
        call output(trim(sd_name), advance='yes')
      end if

      if ( len(trim(sd_name)) <= 0 ) then
        mcf=0
        return
      end if

      ! if ( MCFFORL2GPOPTION == 3 ) then

        ! get mcfspecies name from associative array
        ! if the species name not found in spec_keys, it will return ','
        call GetHashElement ( l2pcf%spec_keys, l2pcf%spec_mcfnames      , &
          & trim(sd_name), sd_full, .TRUE. )
        call GetHashElement ( l2pcf%spec_keys, l2pcf%spec_doinames      , &
          & trim(sd_name), doiIdentifier, .TRUE. )

        if ( DEBUG ) then
          call output('keys: ', advance='no')
          call output(trim(l2pcf%spec_keys), advance='yes')
          call output('hash: ', advance='no')
          call output(trim(l2pcf%spec_mcfnames      ), advance='yes')
          call output('hash for species name: ', advance='no')
          call output(trim(sd_full), advance='yes')
        end if

        if ( trim(sd_full) == COMMA ) then
          mcf = 0
          return
        end if

        sd_name = trim(sd_full)

      ! end if
   elseif ( .NOT. MCFCASESENSITIVE ) then
     sd_name = Lowercase(meta_name)
   else
     sd_name = meta_name
   endif
   ! Now try to find mcf file corresponding to species name   
   ! assuming, e.g. '*h2o.*'                                  
   if ( DEBUG ) then                                       
     call output('Trying for a pcf name matching: ', advance='no')                   
     call output(trim(sd_name), advance='yes')     
   end if                                                  
   mcf = GetPCFromRef(trim(sd_name), &
    & mlspcf_mcf_l2gp_start, mlspcf_mcf_l2gp_end, &
    & MCFCASESENSITIVE, returnStatus)

   if ( returnStatus /= 0 ) then
     mcf = 0
   endif

  end subroutine Get_l2gp_mcf

   
  ! -------------------------------------- mctree ----------------------
  ! parse list of mc odl-like commands entered as character strings
  ! each of one of the following form s
  ! (a) key = value
  ! (b) end_group [= value]
  ! (c) end_parameter [= value]
  ! To start a new group, choose the special key
  !   group_name
  ! To start a new parameter, choose the special key
  !   parameter_name
  subroutine mctree ( list, mcdb )
     character(len=*), dimension(:), intent(in)   :: list
     type (MCGroup_T), dimension(:), pointer      :: mcdb
     ! Internal variables
     integer :: i
     character(len=64)  :: key
     type (MCGROUP_T)   :: group
     integer            :: newsize
     type (MCPARAM_T)   :: param
     character(len=128) :: value
     ! Executable
     if( size(list) < 1 ) return
     i = 0
     do
       i = i+1
       if ( i > size(list) ) exit
       
       ! Which form is our list_line?
       if ( index( trim(list(i)), 'end_group' ) > 0 ) then
         newsize = addmcgrouptodatabase( mcdb, group )
       elseif ( any( streq( list(i), &
         & (/ 'end_parameter', 'end_object   ' /) , options='-cfh' ) ) )  then
         newsize = addmcparamtodatabase( group%params, param )
       elseif( isComment(list(i)) ) then
         ! Just a comment
       elseif( len_trim(list(i)) < 1 ) then
         ! Just a blank line
       elseif ( index( trim(list(i)), '=' ) > 0 ) then
         ! separate into key, value
         call GetStringElement ( list(i), key, &
           & 1, countEmpty, '=' )
         call GetStringElement ( list(i), value, &
           & 2, countEmpty, '=' )
         ! Are we beginning a new group or parameter
         if ( any( streq( key, &
           & (/ 'group_name', 'group     ' /) , options='-cfh' ) ) )  then
           call insertGroup ( list, mcdb, i, value )
         elseif ( any( streq( key, &
           & (/ 'parameter_name', 'object        ' /) , options='-cfh' ) ) )  then
           call insertParameter ( list, group%params, i, value )
         else
           call setParam ( param, key, value )
         endif
       else
         ! unrecognized line
         call output( trim(list(i)) // ' is unrecognized', advance='yes' )
       endif
     enddo
   end subroutine mctree

  ! ----------------------------------------NullifyPCFData -----
  subroutine NullifyPCFData ( P )
    ! Given a PCFData, nullify all the pointers associated with it
    type ( PCFData_T ), intent(out) :: P

    ! Executable code
    nullify ( p%AnText )
  end subroutine NullifyPCFData

  ! --------------------------------------  Populate_metadata_std  -----

  subroutine Populate_metadata_std ( HDF_FILE, MCF_FILE, &
    & Field_name, l2metaData, hdfVersion, Metadata_error, &
    & filetype )

    ! This is the standard way to write meta data
    ! It should work unchanged for the standard l2gp files (e.g. BrO)
    ! and, with minor changes, for the l2gp file marked "other"
    !
    ! the l2aux files, also called dgm
    ! and the dgg files will probably require special treatment
    ! the log file should be able to use the one stolen from level 3
    !

    !    USE InitPCFs, ONLY: L2PCF

    !Arguments

    integer                        :: HDF_FILE, MCF_FILE
    character (len=*)              :: Field_name
    type (L2Metadata_T) :: l2metaData
    integer, optional, intent(in)  :: hdfVersion
    integer, optional, intent(out) :: Metadata_error
    integer, optional, intent(in)  :: filetype  ! 'sw' or 'hdf'

    !Local Variables

    integer :: hdfReturn
    integer :: returnStatus
    integer :: sdid, hdf_sdid

    character (len=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: mcf_filename
    integer :: version

    ! the group have to be defined as 49 characters long. The C interface is 50.
    ! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
    ! therefore making the actual length of a 
    ! string pass of 50.

    character (len = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)

    ! Externals

    integer, external :: PGS_MET_remove

    !Executable code

    module_error = 0
    if ( present(metadata_error)) metadata_error=1
    if(.NOT. TOOLKIT) return

    version = 1
    if ( mcf_file > 0 ) then
      returnStatus = PGS_PC_GetReference (MCF_FILE, version , mcf_filename)
    else
      returnStatus = PGSPC_W_NO_REFERENCE_FOUND
    end if

    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error: failed to find PCF ref for MCF_FILE in populate_metadata_std.") 
      return
    end if

    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)

    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error: failed to find PCF ref for HDF_FILE in populate_metadata_std.") 
      return
    end if

    call first_grouping(HDF_FILE, MCF_FILE, groups)
    call measured_parameter (HDF_FILE, field_name, groups, 1)
    call third_grouping (HDF_FILE, hdf_sdid, groups, &
      & hdfVersion, filetype, l2metaData)

    if ( SFINBETWEENSTARTEND ) then
      sdid = mls_sfstart (physical_fileName, DFACC_RDWR, &
        & hdfVersion=hdfVersion, addingMetaData=.true.)
    else
      sdid = hdf_sdid
    endif 

    if ( sdid == -1 ) then
      call announce_error ( 0, &
      & "Error: failed to open the hdf file in populate_metadata_std: "&
      & //TRIM(physical_fileName)) 
      return
    end if

    hdfReturn = mls_sfend( sdid, hdfVersion=hdfVersion, addingMetadata=.true. )
    if ( hdfReturn /= 0 ) then
        call announce_error ( 0, &
        & "Error: metadata mls_sfend in populate_metadata_std.", &
        & error_number=hdfReturn) 
    end if

    ! Annotate the file with the PCF

    if ( ANNOTATEWITHPCF ) then
      call PCF2Hdr( physical_filename, hdfVersion, filetype=filetype )
    end if

    returnStatus = pgs_met_remove() 

    if ( present(metadata_error)) metadata_error=module_error

   if(BeVerbose( 'pro', -1 )) then
       call announce_success(physical_filename, mcf_filename, 'standard')
   end if

  end subroutine Populate_metadata_std

  ! --------------------------------------  Populate_metadata_oth  -----

  subroutine Populate_metadata_oth ( HDF_FILE, MCF_FILE, &
    & NumQuantitiesPerFile, QuantityNames, l2metaData, hdfVersion, Metadata_error, &
    & filetype )

    ! This is specially to write meta data for heterogeneous files
    ! It should work unchanged for the 'OTH' l2gp files (e.g. ML2OTH.001.MCF)
    ! and, with minor changes, for the l2aux files 

    !Arguments

    integer :: HDF_FILE, MCF_FILE, NumQuantitiesPerFile
    character (len=*), dimension(:) :: QuantityNames
    type (L2Metadata_T) :: l2metaData
    integer, optional, intent(out) :: Metadata_error
    integer, optional, intent(in) :: hdfVersion
    integer, optional, intent(in)  :: filetype  ! 'sw' or 'hdf'

    !Local Variables

    integer :: HdfReturn
    integer :: ReturnStatus
    integer :: Sdid, hdf_sdid

    character (len=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: mcf_filename
    integer :: Version, Indx

    ! the group have to be defined as 49 characters long. The C interface is 50.
    ! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
    ! therefore making the actual length of a 
    ! string pass of 50.

    character (len = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)

    ! Externals

    integer, external :: PGS_MET_remove

    !Executable code

    module_error = 0
    if ( present(metadata_error)) metadata_error=1
    if(.NOT. TOOLKIT) return

    version = 1
    if ( MCF_FILE > 0 ) then
      returnStatus = PGS_PC_GetReference (MCF_FILE, version , mcf_filename)
    else
      returnStatus = PGSPC_W_NO_REFERENCE_FOUND
    end if

    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error: failed to find PCF ref for MCF_FILE in populate_metadata_oth.") 
      return
    end if

    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)

    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error: failed to find PCF ref for HDF_FILE in populate_metadata_oth.") 
      return
    end if

    call first_grouping(HDF_FILE, MCF_FILE, groups)

    do indx=1, numquantitiesperfile

      call measured_parameter (HDF_FILE, &
        & QuantityNames(indx), groups, indx)

    end do

    call third_grouping (HDF_FILE, hdf_sdid, groups, &
      & hdfVersion, filetype, l2metaData)

    if ( SFINBETWEENSTARTEND ) then
      sdid = mls_sfstart (physical_fileName, DFACC_RDWR, &
        & hdfVersion=hdfVersion, addingMetaData=.true.)
    else
      sdid = hdf_sdid
    endif 

    if ( sdid == -1 ) then
      call announce_error ( 0, &
      & "Error: failed to open the hdf file: "//TRIM(physical_fileName))
      return
    end if

    hdfReturn = mls_sfend( sdid, hdfVersion=hdfVersion, addingMetadata=.true. )
    if ( hdfReturn /= 0 ) then
        call announce_error ( 0, &
        & "Error: metadata mls_sfend in populate_metadata_oth.", &
        & error_number=hdfReturn) 
    end if

! Annotate the file with the PCF

    if ( ANNOTATEWITHPCF ) then
      call PCF2Hdr( physical_filename, hdfVersion, filetype=filetype )
      ! & hdfVersion, isHDFEOS)
    end if

    returnStatus = pgs_met_remove() 

    if ( present(metadata_error)) metadata_error=module_error

   if(BeVerbose( 'pro', -1 )) then
       call announce_success(physical_filename, mcf_filename, 'others')
   end if

  end subroutine Populate_metadata_oth

  ! ----------------------------------------readMCF -----
  subroutine readMCF ( MLSFILE, MCGROUPS )
    ! Given a metadata control file, read a group of inventory metadata control 
    ! parameters from it
    ! Note that the file must be an MLSFile_T
    type ( MLSFile_T ), intent(inout)            :: MLSFILE
    type ( MCGROUP_T ), pointer, dimension(:) :: MCGROUPS
    ! Internal variables
    integer :: list_len
    integer, parameter :: MAXLINELENGTH  = 256
    integer, parameter :: MAXARRAYLENGTH = 512
    character(len=MAXLINELENGTH), dimension(MAXARRAYLENGTH) :: list
    logical :: verbose

    ! Executable code
    verbose = BeVerbose( 'mcf', -1 )
    list = ' '
    call read_textfile( MLSFILE%Name, list, nLines=list_len )
    if ( verbose ) then
      call outputnamedValue( 'list_len', list_len )
      call dump( list(:list_len), 'list', width=1 )
    endif
    call mctree( list(:list_len), MCGroups )
  end subroutine readMCF

  ! ----------------------------------------writeMCF -----
  subroutine writeMCF ( MLSFILE, MCGROUPS )
    ! Given an MLSFile_T, write a group of inventory metadata control 
    ! parameters to it
    ! Note that the group may contain other groups, i.e. be nested
    type ( MLSFile_T ), intent(inout)            :: MLSFILE
    type ( MCGROUP_T ), intent(in), dimension(:) :: MCGROUPS
    ! Internal variables
    integer :: error
    integer :: i
    logical :: needMasterGroup

    ! Executable code
    if ( .not. MLSfile%stillOpen ) call mls_OpenFile ( MLSFile, error )
    call dump( MLSFile, details=1 )
    if ( error /= 0 ) call announce_error ( 0, &
      & 'error opening MLSFile in writeMCF' )
    needMasterGroup = .not. streq(MCGroups(1)%type, 'mastergroup', options='-cf' )
    call outputnamedvalue ( 'MCGroups(1)%type', trim(MCGroups(1)%type) )
    if ( needMasterGroup ) then
      write( MLSFile%fileID%f_id, * ) 'GROUP = INVENTORYMETADATA'
      write( MLSFile%fileID%f_id, * ) 'GROUPTYPE = MASTERGROUP'
      nest_degree = 1
    else
      nest_degree = 0
    endif
    do i=1, size(MCGroups)
      call writeMCGroup( MLSFile, MCGroups(i) )
    enddo
    if ( needMasterGroup ) write( MLSFile%fileID%f_id, * ) 'END_GROUP = INVENTORYMETADATA'
    write( MLSFile%fileID%f_id, * ) 'END'
    call mls_CloseFile ( MLSFile )
  end subroutine writeMCF

! Lori's routines

  ! -----------------------------------------------  WriteMetaLog  -----
  subroutine WriteMetaLog ( Metadata_error )

    ! Brief description of subroutine
    ! This subroutine writes metadata for the log file to a separate ASCII file.

    ! Arguments

    ! type( PCFData_T ), intent(in) :: Pcf
    integer, optional, intent(out) :: Metadata_error

    ! Parameters
    ! These are PCF numbers that *must* be in the PCF file

    integer, parameter :: ASCII_FILE = 101
    integer, parameter :: THE_LOG_FILE = 100

    ! Functions

    integer, external :: PGS_MET_init, PGS_MET_remove
    integer, external :: PGS_MET_setattr_s, PGS_MET_write
    integer, external :: PGS_PC_getconfigdata

    ! Internal

    character (len=1) :: NullStr
    character (len=45) :: Sval
    character (len=32) :: Mnemonic
    character (len=FileNameLen) :: Physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: mcf_filename
    character (len=480) :: Msg, Msr
    character (len=PGSd_MET_GROUP_NAME_L) :: Groups(PGSd_MET_NUM_OF_GROUPS)

    integer :: Result, Indx, Version
    logical, parameter :: DEBUG=.FALSE.

    ! Begin
    module_error = 0
    if ( present(metadata_error)) metadata_error=1
    if(.NOT. TOOLKIT) return

    nullStr = ''

    version = 1
    result = PGS_PC_GetReference (mlspcf_mcf_l2log_start, version, &
      & mcf_filename)

    if ( result /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error: failed to find PCF ref for Log mcf in WriteMetaLog.") 
      return
    end if

    ! Check that the PCF file contains the entries for the ASCII file
    ! and for the log file itself
    result = pgs_pc_getconfigdata (ASCII_FILE, physical_filename)

    if ( result /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error: failed to find PCF ref for the ASCII in WriteMetaLog.") 
      return
    end if

    version = 1
    result = PGS_PC_GetReference (THE_LOG_FILE, version , physical_filename)

    if ( result /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error: failed to find PCF ref for the Log in WriteMetaLog.") 
      return
    end if

! Initialize the MCF file

    if ( DEBUG ) then
      call output('Initialize the MCF file', advance='yes')
    end if

    result = pgs_met_init(mlspcf_mcf_l2log_start, groups)
    if ( result /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "metadata initialization error in WriteMetaLog.") 
      return
    end if

! Set PGE values

    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalGranuleID", &
                               l2pcf%logGranID)

    sval = 'c' // l2pcf%cycle
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalVersionID", &
                               sval)

    indx = INDEX (l2pcf%startUTC, "T")

    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                               "RangeBeginningDate", l2pcf%startUTC(1:indx-1))
!    sval= '00:00:00.000000'
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                               "RangeBeginningTime", l2pcf%startUTC(indx+1:))
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                               "RangeEndingDate", l2pcf%endUTC(1:indx-1))
!    sval= '23:59:59.999999'
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                               "RangeEndingTime", l2pcf%endUTC(indx+1:))

    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "PGEVersion", &
                               l2pcf%PGEVersion)

    if ( result /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in setting PGEVersion attribute in WriteMetaLog.", &
      &  error_number=result)
        return
    end if

    ! Write the metadata and their values to an ASCII file

    if ( DEBUG ) then
      call output('Write the metadata and their values to an ASCII file', &
      &  advance='yes')
    end if

    result = pgs_met_write(groups(1), nullStr, ASCII_FILE)

    if ( result /= PGS_S_SUCCESS ) then
       call Pgs_smf_getMsg(result, mnemonic, msg)
       msr = "Error: failed to write metadata in WriteMetaLog." &
       & // trim(mnemonic) // ':  ' // trim(msg)
       CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
    end if

    result = pgs_met_remove()

    if ( present(metadata_error)) metadata_error=module_error

   if(BeVerbose( 'pro', -1 )) then
       call announce_success(physical_filename, mcf_filename, 'Log')
   end if

   end subroutine WriteMetaLog

  ! ---------------------- Private procedures ------------

  ! ---------------------------------------------  announce_success  -----
  subroutine announce_success ( Name, mcf, l2_type )
    character(LEN=*), intent(in) :: Name
    character(LEN=*), intent(in) :: mcf
    character(LEN=*), intent(in) :: l2_type

    call output ( 'Level 2 output product metadata type : ' )
    call output ( trim(l2_type), advance='yes')
    call blanks(15)
    call output ( 'name : ' )
    call blanks(8)
    call output ( trim(Name), advance='yes')
    call blanks(15)
    call output ( 'mcf name : ' )
    call blanks(8)
    call output ( trim(mcf), advance='yes')

  end subroutine announce_success

  ! ------------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( lcf_where, full_message, use_toolkit, &
    & error_number )

    ! Arguments

    integer, intent(in) :: Lcf_where
    character(LEN=*), intent(in) :: Full_message
    logical, intent(in), optional :: Use_toolkit
    integer, intent(in), optional :: Error_number

    ! Local
    logical :: Just_print_it
    logical, parameter :: Default_output_by_toolkit = .true.
    character (LEN=132) :: attrname, errmsg
    integer :: Toolbox_error_num

    just_print_it = .not. default_output_by_toolkit
    if ( present(use_toolkit) ) just_print_it = .not. use_toolkit

    if ( .not. just_print_it ) then
      if ( TOOLKIT ) module_error = 1
      call output ( '***** At ' )

      if ( lcf_where > 0 ) then
        call print_source ( where(lcf_where) )
      else
        call output ( '(no lcf node available)' )
      end if

      call output ( " Caused the following error:", advance='yes', &
       & from_where=ModuleName)
      call output ( trim(full_message), advance='yes', &
        & from_where=ModuleName)
      if ( present(error_number) ) then
        call output ( 'Error number ', advance='no' )
        call output ( error_number, places=9, advance='yes' )
        Toolbox_error_num = error_number
        call Pgs_smf_getMsg (Toolbox_error_num, attrname, errmsg)
        call MLSMessage (MLSMSG_WARNING, ModuleName, &
            &  TRIM(attrname) //' ' // TRIM(errmsg) )
      end if
    else
      call output ( '***Error in module ' )
      call output ( ModuleName, advance='yes' )
      call output ( trim(full_message), advance='yes' )
      if ( present(error_number) ) then
        call output ( 'Error number ' )
        call output ( error_number, advance='yes' )
      end if
    end if

!===========================
  end subroutine Announce_Error
!===========================

  ! ---------------------------------------------  First_grouping  -----

  subroutine First_grouping ( HDF_FILE, MCF_FILE, Groups )

    ! This writes the metadata for the following attributes:
    ! (attributes marked automatic are not explicitly written, however)

    ! SizeMBECSDataGranule (automatic)
    ! ReProcessingPlanned
    ! LocalGranuleID
    ! DayNightFlag
    ! ProductionDateTime (automatic)
    ! LocalVersionID
    !

    !    USE InitPCFs, ONLY: L2PCF

    !Arguments

    integer :: HDF_FILE, MCF_FILE
    ! type(PCFData_T) :: l2pcf

    ! the group have to be defined as 49 characters long. The C interface is 50.
    ! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
    ! therefore making the actual length of a 
    ! string pass of 50.

    character (len = PGSd_MET_GROUP_NAME_L) :: Groups(PGSd_MET_NUM_OF_GROUPS)

    !Local Variables

    integer, parameter :: INVENTORY=2 !, ARCHIVE=1
    character (len=132) :: Attrname
    integer :: Indx, Version
    character (len=PGSd_PC_FILE_PATH_MAX) :: Physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: Sval
    integer :: ReturnStatus

    ! Externals

    integer, external :: PGS_MET_init, &
      &  PGS_MET_setAttr_s
    ! Executable code

    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)

    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in getting ref for PCF number in 1st grouping." ) 
    end if

    returnStatus = pgs_met_init (MCF_FILE, groups)

    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Metadata initialization error" )
    end if

    ! Set PGE values 

    ! ECSDataGranule

    attrName = 'ReprocessingPlanned'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'further update anticipated using enhanced PGE')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing ReprocessingPlanned attribute." )
    end if

    attrName = 'LocalGranuleID'
    sval = physical_filename
    indx = INDEX (sval, "/", .TRUE.) + 1  ! Begin after last "/"
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval(indx:))
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
       & "Error in writing LocalGranuleID attribute." ) 
    end if

    attrName = 'DayNightFlag'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, 'Both')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing DayNightFlag attribute." )
    end if

    attrName = 'LocalVersionID'
    sval = 'c' // l2pcf%cycle
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing LocalVersionID attribute." ) 
    end if

  end subroutine First_grouping

  recursive subroutine insertGroup ( list, groups, i, name )
    ! Loop over list until end_group
    character(len=*), dimension(:), intent(in)   :: list
    type (MCGroup_T), dimension(:), pointer      :: groups
    integer, intent(inout)                       :: i
    character(len=*), intent(in)                 :: name
    ! Internal variables
    type (MCGroup_T)   :: group
    character(len=64)  :: key
    integer            :: newsize
    type (MCPARAM_T)   :: param
    character(len=128) :: value
    logical :: verbose
    ! Executable
    verbose = BeVerbose( 'mcf', -1 )
    group%name = name
    if ( verbose ) call output( 'Inserting group named '// trim(name), advance='yes' )
    do
      i = i+1
      if ( i > size(list) ) exit
      ! Which form is our list_line?
      if ( streq( list(i), 'end_group', options='-cfh' ) ) then
        newsize = addmcgrouptodatabase( groups, group )
        exit
      elseif ( any( streq( list(i), &
        & (/ 'end_parameter', 'end_object   ' /) , options='-cfh' ) ) )  then
        newsize = addmcparamtodatabase( group%params, param )
      elseif( isComment(list(i)) ) then
        ! Just a comment
      elseif( len_trim(list(i)) < 1 ) then
        ! Just a blank line
      elseif ( index( trim(list(i)), '=' ) > 0 ) then
        ! separate into key, value
        call GetStringElement ( list(i), key, &
          & 1, countEmpty, '=' )
        call GetStringElement ( list(i), value, &
          & 2, countEmpty, '=' )
        ! Are we beginning a new group or parameter? Maybe just grouptype?
        if ( streq( key, &
          & 'grouptype' , options='-cf' ) )  then
          group%type = value
          ! print *, "setting named group " // trim(name) // ' type to ' // trim(value)
        elseif ( streq( key, &
          & 'class' , options='-cf' ) )  then
          group%class = value
        elseif ( any( streq( key, &
          & (/ 'group_name', 'group     ' /) , options='-cfh' ) ) )  then
          call insertGroup ( list, group%groups, i, value )
        elseif ( any( streq( key, &
          & (/ 'parameter_name', 'object        ' /) , options='-cfh' ) ) )  then
          call insertParameter ( list, group%params, i, value )
        else
          call setParam ( param, key, value )
        endif
      else
        ! unrecognized line
        call output( trim(list(i)) // ' is unrecognized', advance='yes' )
      endif
    enddo
  end subroutine insertGroup

  recursive subroutine insertParameter ( list, parameters, i, name )
    ! Loop over list until end_parameter
    character(len=*), dimension(:), intent(in)   :: list
    type (MCParam_T), dimension(:), pointer      :: parameters
    integer, intent(inout)                       :: i
    character(len=*), intent(in)                 :: name
    ! Internal variables
    integer :: newsize
    character(len=64)  :: key
    type (MCParam_T)   :: param
    character(len=128) :: value
    logical :: verbose
    ! Executable
    verbose = BeVerbose( 'mcf', -1 )
    if ( verbose ) call output( 'Inserting parameter named '// trim(name), advance='yes' )
    param%name = name
    do
      i = i+1
      if ( i > size(list) ) exit
      ! Which form is our list_line?
      ! print *, trim(list(i)), streq( list(i), 'end_object', options='-cfh' )
      if ( any( streq( list(i), &
        & (/ 'end_parameter', 'end_object   ' /) , options='-cfh' ) ) )  then
        newsize = addmcparamtodatabase( parameters, param )
        exit
      elseif( isComment(list(i)) ) then
        ! Just a comment
      elseif( len_trim(list(i)) < 1 ) then
        ! Just a blank line
      elseif ( index( trim(list(i)), '=' ) > 0 ) then
        ! separate into key, value
        call GetStringElement ( list(i), key, &
          & 1, countEmpty, '=' )
        call GetStringElement ( list(i), value, &
          & 2, countEmpty, '=' )
        if ( any( streq( key, &
          & (/ 'group_name', 'group     ' /) , options='-cfh' ) ) )  then
          call insertGroup ( list, param%groups, i, value )
        elseif ( any( streq( key, &
          & (/ 'parameter_name', 'object        ' /) , options='-cfh' ) ) )  then
          call insertParameter ( list, param%params, i, value )
        else
          call setParam ( param, key, value )
        endif
      else
        ! unrecognized line
        call output( trim(list(i)) // ' is unrecognized', advance='yes' )
      endif
    enddo
  end subroutine insertParameter

  subroutine setParam ( param, key, value )
    ! set key component of param to value
    type (MCParam_T), intent(inout):: param
    character(len=*), intent(in)   :: key, value
    ! Internal variables
    ! Executable
    ! print *, 'Setting parameter key named ', trim(key), ' to ', trim(value)
    select case (adjustl(lowercase(key)))
    case ('name')
      param%name          = value
    case ('mandatory')
      param%mandatory     = value
    case ('data_location')
      param%data_location = value
    case ('class')
      param%class         = value
    case ('num_val')
      param%num_val       = value
    case ('type')
      param%type          = value
    case ('value')
      param%value         = value
    ! case default
    end select
  end subroutine setParam

  ! -----------------------------------------  Measured_parameter  -----

  subroutine Measured_parameter ( HDF_FILE, Field_name, Groups, Class_num)

    ! This writes the attributes corresponding to the measured parameter container:
    !
    ! ParameterName
    ! AutomaticQualityFlag
    ! AutomaticQualityFlagExplanation
    ! OperationalQualityFlag
    ! OperationalQualityFlagExplanation
    ! ScienceQualityFlag
    ! ScienceQualityFlagExplanation
    ! QAPercentInterpolatedData
    ! QAPercentMissingData
    ! QAPercentOutOfBoundsData
    !

    !    USE InitPCFs, ONLY: L2PCF

    !Arguments

    integer                       :: HDF_FILE
    character(len=*)              :: Field_name
    integer, intent(in)           :: Class_num

    ! the group have to be defined as 49 characters long. The C interface is 50.
    ! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
    ! therefore making the actual length of a 
    ! string pass of 50.

    character (len = PGSd_MET_GROUP_NAME_L) :: Groups(PGSd_MET_NUM_OF_GROUPS)

    ! Local Variables

    integer, parameter :: INVENTORY=2 !, ARCHIVE=1
    character (len=132) :: Attrname
    character (len=2) :: Class
    character (len=PGSd_PC_FILE_PATH_MAX) :: Physical_filename
    integer :: ReturnStatus
    character (len=PGSd_PC_FILE_PATH_MAX) :: Sval
    integer :: Version

    ! Externals

    integer, external :: &
      &  PGS_MET_setAttr_s, PGS_MET_SETATTR_I

    !Executable code
    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)


    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
        & "Error in getting ref for PCF id in measured_parameter." )
    end if

    ! A moment of misplaced priorities: we have decided to create
    ! links between valid data field names and the name L2gpValue
    ! Instead of doing this in a routine created for that purpose,
    ! we have violated good design principles and stuck it here for now
    !                (moved to WriteL2GPData)
    ! MeasuredParameterContainer
    if ( class_num <= 0 ) then
      class(:2) = '0 '
    else if ( class_num < 10 ) then
      write ( class(:1), '(I1)' ) class_num
      class(2:2) = ' '
    else
      write ( class(:2), '(I2)' ) class_num
    end if

    if ( field_name /= ' ' ) then
      sval = adjustl(field_name)
    else
      sval = 'Miscellaneous'
    end if
    attrName = 'ParameterName' // '.' // class
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing ParameterName attribute." )
    end if

    ! QAFlags Group
    ! These have been moved to the MCF files
    ! QAStats Group

    attrName = 'QAPercentInterpolatedData' // '.' // class
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 0)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing QAPercentInterpolatedData attribute." )
    end if

    attrName = 'QAPercentMissingData' // '.' // class
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 0)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing QAPercentMissingData attribute." )
    end if

    attrName = 'QAPercentOutofBoundsData' // '.' // class
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 0)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing QAPercentOutofBoundsData attribute." )
    end if

  end subroutine Measured_parameter

  ! ---------------------------------------- PCF2Hdr -----
  ! Make sure file type will be recognized
  ! before calling writePCF2Hdr
  ! (which only knows l_hdf, l_hdfeos, l_swath)
  subroutine PCF2Hdr( filename, hdfVersion, filetype )
    ! Args
    character(len=*), intent(in)  :: filename
    integer, optional, intent(in) :: hdfVersion
    integer, optional, intent(in) :: fileType
    ! Internal variables
    integer :: myType
    ! Executable
    if ( .not. associated(l2pcf%anText) ) return
    myType = l_hdf
    if ( present(filetype) ) then
      myType = filetype
      select case(filetype)
      case (l_l2dgg,l_l2gp)
        myType = l_swath
      ! case default
        ! myType = filetype
      end select
    endif
    call writePCF2Hdr( filename, l2pcf%anText, hdfVersion, myType )

  end subroutine PCF2Hdr

  ! ---------------------------------------------  Third_grouping  -----

  subroutine Third_grouping ( HDF_FILE, hdf_sdid, Groups, &
    & hdfVersion, filetype, l2metaData )

    ! This writes the following metadata attributes:

    ! OrbitNumber
    ! StartOrbitNumber
    ! StopOrbitNumber
    ! EquatorCrossingLongitude
    ! EquatorCrossingTime
    ! EquatorCrossingDate
    ! ShortName
    ! VersionID
    ! InputPointer
    ! LocalityValue
    ! VerticalSpatialDomainType
    ! VerticalSpatialDomainValue
    ! ZOneIdentifier
    ! WestBoundingCoordinate
    ! NortBoundingCoordinate
    ! EastBoundingCoordinate
    ! SouthBoundingCoordinate
    ! RangeBeginningDate
    ! RangeBeginningTime
    ! RangeEndingDate
    ! RangeEndingTime
    ! PGEVersion
    !


    ! Arguments

    integer :: HDF_FILE
    integer :: hdf_sdid

    ! the group have to be defined as 49 characters long. The C interface is 50.
    ! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
    ! therefore making the actual length of a 
    ! string pass of 50.

    character (len = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
    integer, optional, intent(in) :: hdfVersion
    integer, optional, intent(in)  :: filetype  ! 'sw' or 'hdf'
    type (L2Metadata_T) :: l2metaData

    !Local Variables

    integer :: HdfReturn
    integer :: ReturnStatus

    real(r8) :: Dval
    integer, parameter :: INVENTORY=2 !, ARCHIVE=1
    character (len=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: sval
    character (len=132) :: attrname
    integer :: version, indx
    integer :: inptptr_filetype
    integer :: startOrbit, stopOrbit


    ! Externals

    integer, external :: PGS_MET_setattr_d, &
         PGS_MET_setAttr_s, PGS_MET_SETATTR_I, &
         PGS_MET_write, PGS_MET_remove
    !Executable code

    inptptr_filetype = l_swath
    if ( present(filetype) ) inptptr_filetype = filetype
    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)

    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in getting ref for PCF id in third_grouping.") 
    end if

    ! Orbit Calculated Spatial Domain Container
    ! Per James Johnson's email 6/12/03, use either OrbitNumber OR 
    ! (StartOrbitNumber and StopOrbitNumber)

    !attrName = 'OrbitNumber' // '.1'
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, -1)
    ! This change to confirm James Johnson suggestion on 6/12/03
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 999)
    !if ( returnStatus /= PGS_S_SUCCESS ) then
    !  call announce_error ( 0, &
    !  & "Error in writing OrbitNumber attribute.") 
    !end if

    ! Start, Stop orbit numbers: level one has actual calculated numbers
    ! but, for now at least, we'll not trouble
    ! For now, use 99999 for invalid value
    ! Write start, stop orbit numbers from l1 to l2

    attrName = 'StartOrbitNumber' // '.1'
    if (GlobalAttributes%OrbNum(1) == -1) then
        startOrbit = 99999
    else
        startOrbit = GlobalAttributes%OrbNum(1)
    end if
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, &
        & startOrbit)
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 99999)
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, -1)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing StartOrbitNumber attribute.")
    end if

    attrName = 'StopOrbitNumber' // '.1'
    if (maxval(GlobalAttributes%OrbNum) == -1) then
        stopOrbit = 99999
    else
        stopOrbit = maxval(GlobalAttributes%OrbNum)
    end if
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, &
        & stopOrbit)
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 99999)
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, -1)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing StopOrbitNumber attribute.")
    end if

    attrName = 'EquatorCrossingLongitude' // '.1'
    dval = 0.0
    returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing EquatorCrossingLongitude attribute.") 
    end if

    attrName = 'EquatorCrossingTime' // '.1'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         '00:00:00')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing EquatorCrossingTime attribute.") 
    end if

    indx = INDEX (L2PCF%startUTC, "T")
    attrName = 'EquatorCrossingDate' // '.1'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         L2PCF%startUTC(1:indx-1))
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing EquatorCrossingDate attribute.") 
    end if

    ! InputPointer

    attrName = 'InputPointer'
    if ( SETINPUTPOINTER ) then
      call announce_error ( 0, &
      & "Invalid method of writing InputPointer attribute.") 
    else
      returnStatus = WriteInputPointer(groups(INVENTORY), attrName, &
        & filetype=inptptr_filetype)
    endif
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing InputPointer attribute.") 
    end if

    ! Locality Value

    attrName = 'LocalityValue'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'Limb')
    if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing LocalityValue attribute.")
     end if

     ! VerticalSpatialDomain Product-Specific Attribute

     attrName = 'VerticalSpatialDomainType' // '.1'
     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
          'Atmosphere Layer')
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing VerticalSpatialDomainType attribute.")
     end if

     attrName = 'VerticalSpatialDomainValue' // '.1'
     !returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
     !     'Brightness Temperature')
     ! The following change bring level 2 into agreement level 3
     ! Further change to confirm James Johnson suggestion 6/12/03
     ! will await in the next delivery which it also unify all 3 levels
     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
          'Atmosphere Profile')
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing VerticalSpatialDomainValue attribute.")
     end if

     ! HorizontalSpatialDomainContainer

     attrName = 'ZoneIdentifier'
     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
          'Other Grid System')
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing ZoneIdentifier attribute.")
     end if

     if ( .not. sharedPCF ) then
        l2metaData%minLon = -180.0
        l2metaData%maxLon = 180.0
        l2metaData%minLat = -90.0
        l2metaData%maxLat = 90.0
     end if

     attrName = 'WestBoundingCoordinate'
     dval = l2metaData%minLon 
     returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing WestBoundingCoordinate attribute.")
     end if

     attrName = 'NorthBoundingCoordinate'
     dval = l2metaData%maxLat 
     returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing NorthBoundingCoordinate attribute.")
     end if

     attrName = 'EastBoundingCoordinate'
     dval = l2metaData%maxLon 
     returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing EastBoundingCoordinate attribute.")
     end if

     attrName = 'SouthBoundingCoordinate'
     dval = l2metaData%minLat 
     returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
     if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing SouthBoundingCoordinate attribute.")
    end if

    indx = INDEX (L2PCF%startUTC, "T")

    ! RangeDateTime Group

    attrName = 'RangeBeginningDate'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), &
         attrName, L2PCF%startUTC(1:indx-1))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in setting RangeBeginningDate attribute.") 
    end if

    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), &
         "RangeBeginningTime", L2PCF%startUTC(indx+1:))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in setting RangeBeginningTime attribute.") 
    end if

    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), "RangeEndingDate", &
         L2PCF%endUTC(1:indx-1))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in setting RangeEndingDate attribute.") 
    end if

    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), "RangeEndingTime", &
         L2PCF%endUTC(indx+1:))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in setting RangeEndingTime attribute.") 
    end if

    ! PGEVersion

    attrName = 'PGEVersion'
    sval = L2PCF%PGEVersion
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in setting PGEVersion attribute.") 
    end if

    ! Production Location

    attrName = 'ProductionLocation'
    sval = GlobalAttributes%productionLoc
    returnStatus = pgs_met_setAttr_s ( groups(INVENTORY), attrName, sval )
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in setting ProductionLocation attribute.") 
    end if

    attrName = 'DataProducer'
    sval = 'MLS_SIPS'
    returnStatus = pgs_met_setAttr_s ( groups(INVENTORY), attrName, sval )
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in setting DataProducer attribute.") 
    end if

    ! DOI
    ! This should be in the MCF
    attrName = 'identifier_product_doi'
    sval = l2metaData%doiIdentifier
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in setting DOI attribute.") 
    end if

    ! All done
    hdf_sdid = mls_sfstart (physical_fileName, DFACC_RDWR, &
      & hdfVersion=hdfVersion, addingMetaData=.true.) 

    if ( hdf_sdid == -1 ) then
      call announce_error ( 0, &
      & "Error: failed to open hdf file: "//physical_fileName) 
    end if

    returnStatus = pgs_met_write (groups(INVENTORY), "coremetadata.0", hdf_sdid)

    if ( returnStatus /= PGS_S_SUCCESS .AND. &
      &  returnStatus /= PGSMET_W_METADATA_NOT_SET ) then 
      if ( returnStatus == PGSMET_W_METADATA_NOT_SET ) then 
        call announce_error ( 0, &
        & "Error: some of the mandatory parameters not set.") 
      else
        call output('hdf_sdid: ', advance='no')
        call output(hdf_sdid, advance='yes')
        call output('hdfVersion: ', advance='no')
        call output(hdfVersion, advance='yes')
        call announce_error ( 0, &
        & "Error: metadata write failed in third_grouping." // trim(physical_fileName), &
        & error_number=returnStatus) 
      end if
    end if

    if ( SFINBETWEENSTARTEND ) then
      hdfReturn = mls_sfend( hdf_sdid, hdfVersion=hdfVersion, addingMetadata=.true. )
      if ( hdfReturn /= 0 ) then
          call announce_error ( 0, &
          & "Error: metadata mls_sfend in third_grouping.", &
          & error_number=hdfReturn) 
      end if

      returnStatus = pgs_met_remove() 
    endif

  end subroutine Third_grouping

  ! ----------------------------------------writeMCGroup -----
  recursive subroutine writeMCGroup ( MLSFILE, MCGROUP )
    ! Given an MLSFile_T, write a set of inventory metadata control parameters 
    ! to it
    ! If the group contains other groups, do what seems proper
    type ( MLSFile_T ), intent(inout)            :: MLSFILE
    type ( MCGROUP_T ), intent(in)               :: MCGROUP
    ! Internal variables
    integer :: i
    integer :: indent

    ! Executable code
    call output( 'Writing group ' // trim(MCGroup%name), advance='yes' )
    if ( len_trim(MCGroup%name) < 1 ) return
    nest_degree = nest_degree + 1
    indent = nest_degree*3
    ! write( MLSFile%fileID%f_id, * ) spaces(:indent), '#GROUP_namelen = ', len_trim(MCGroup%name)
    write( MLSFile%fileID%f_id, * ) spaces(:indent), 'GROUP = ' // trim(adjustl(MCGroup%name))
    indent = indent + 3
    if ( len_trim(MCGroup%class) > 0 ) &
      & write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'CLASS = ' // trim(adjustl(MCGroup%class))
    if ( len_trim(MCGroup%type) > 0 ) &
      & write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'GROUPTYPE = ' // trim(adjustl(MCGroup%type))
    if ( associated(MCGroup%groups) ) then
      do i=1, size(MCGroup%groups)
        call writeMCGroup( MLSFile, MCGroup%groups(i) )
      enddo
    endif
    if ( associated(MCGroup%params) ) then
      do i=1, size(MCGroup%params)
        call writeMCParam( MLSFile, MCGroup%params(i) )
      enddo
    endif
    indent = nest_degree*3
    write( MLSFile%fileID%f_id, * )  spaces(:indent), 'END_GROUP = ' // trim(adjustl(MCGroup%name))
    nest_degree = nest_degree - 1
  end subroutine writeMCGroup

  recursive subroutine writeMCParam ( MLSFILE, MCPARAM )
    type ( MLSFile_T ), intent(inout)            :: MLSFILE
    type ( MCParam_T ), intent(in)               :: MCPARAM
    ! Internal variables
    integer :: i
    integer :: indent
    ! Executable
    call output( 'Writing parameter ' // trim(MCParam%name), advance='yes' )
    if ( len_trim(MCParam%name) < 1 ) return
    nest_degree = nest_degree + 1
    indent = nest_degree*3
    write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'OBJECT = ' // trim(adjustl(MCParam%name))
    indent = indent + 3
    write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'Mandatory = ' // trim(adjustl(MCParam%mandatory))
    write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'Data_Location = ' // trim(adjustl(MCParam%data_location))
    if ( len_trim(MCParam%class) > 0 ) &
      & write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'CLASS = ' // trim(adjustl(MCParam%class))
    if ( len_trim(MCParam%num_val) > 0 ) &
      & write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'NUM_VAL = ' // trim(adjustl(MCParam%num_val))
    if ( len_trim(MCParam%type) > 0 ) &
      & write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'TYPE = ' // trim(adjustl(MCParam%type))
    if ( len_trim(MCParam%value) > 0 ) &
      & write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'Value = ' // trim(adjustl(MCParam%value))

    if ( associated(MCParam%groups) ) then
      do i=1, size(MCParam%groups)
        call writeMCGroup( MLSFile, MCParam%groups(i) )
      enddo
    endif
    if ( associated(MCParam%params) ) then
      do i=1, size(MCParam%params)
        call writeMCParam( MLSFile, MCParam%params(i) )
      enddo
    endif
    indent = nest_degree*3
    write( MLSFile%fileID%f_id, * ) spaces(:indent), &
      & 'END_OBJECT = ' // trim(adjustl(MCParam%name))
    nest_degree = nest_degree - 1
  end subroutine writeMCParam

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: write_meta.f90,v 2.83 2018/04/19 01:14:16 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module WriteMetadata 
! $Log: write_meta.f90,v $
! Revision 2.83  2018/04/19 01:14:16  vsnyder
! Remove USE statements for unused names
!
! Revision 2.82  2015/03/28 02:56:12  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.81  2014/09/05 01:28:53  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.80  2014/04/07 18:10:09  pwagner
! Added new metadata attribute: DataProducer
!
! Revision 2.79  2014/03/26 17:47:44  pwagner
! Added ProductionLocation, identifier_product_doi metadata
!
! Revision 2.78  2014/03/07 19:30:30  pwagner
! Housekeeping; insert comments suggesting use of NameLen instead of hard-coded charlens
!
! Revision 2.77  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.76  2013/12/05 01:42:03  pwagner
! Added RunID component to pcf; started using BeVerbose
!
! Revision 2.75  2013/09/24 23:47:23  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.74  2013/07/26 00:07:35  pwagner
! Added routines to read, write, and parse MCFs
!
! Revision 2.73  2013/07/18 22:39:37  pwagner
! Added datatypes, functions for metadata control
!
! Revision 2.72  2013/04/19 20:07:28  pwagner
! Fixed long-standing bug in closing file after adding metadata
!
! Revision 2.71  2013/04/12 00:06:35  pwagner
! Added addToMetadata
!
! Revision 2.70  2011/07/12 22:35:03  honghanh
! Change l_grid to l_hdfeos
!
! Revision 2.69  2011/06/29 21:52:53  pwagner
! no metadata is always an error now
!
! Revision 2.68  2011/05/09 18:28:30  pwagner
! Converted to using switchDetail
!
! Revision 2.67  2009/06/23 18:46:19  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.66  2009/06/02 17:53:15  cvuu
! Add NRT Lat and Lon bounding to metadata
!
! Revision 2.65  2008/05/02 00:33:53  vsnyder
! Delete unused symbol
!
! Revision 2.64  2008/02/22 21:37:05  pwagner
! DGG file was hybrid by default; now it will be pure HDFEOS
!
! Revision 2.63  2007/12/07 01:50:32  pwagner
! Removed unused dummy variables, etc.
!
! Revision 2.62  2007/06/21 00:54:08  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.61  2006/03/15 23:52:24  pwagner
! Removed InputVersion component from PCF, l2cf
!
! Revision 2.60  2006/02/21 19:12:00  pwagner
! GetHashElement is now a generic
!
! Revision 2.59  2005/07/21 23:45:03  pwagner
! Removed unused l1b fileinfo fields from l2pcf
!
! Revision 2.58  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.57  2005/01/27 00:35:06  pwagner
! ReprocessingActual field dropped from product metadata
!
! Revision 2.56  2005/01/14 21:37:30  pwagner
! ch3cn now has mcf, so special treatment lifted
!
! Revision 2.55  2004/12/15 23:34:32  pwagner
! Change REPROCESSINGACTUAL to unknown; light housecleaning
!
! Revision 2.54  2004/12/14 21:41:53  pwagner
! Repaired double-0 cycle; automaticQ.. and OperationalQ.. shifted to mcf
!
! Revision 2.53  2004/08/04 23:19:58  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.52  2004/01/30 00:31:10  pwagner
! Stops useless warnings about pgs_met_remove return value
!
! Revision 2.51  2003/09/12 16:32:00  cvuu
! Output the right orbit numbers for StartOrbitNumber and StopOrbitNumber
!
! Revision 2.50  2003/09/04 22:41:09  pwagner
! Added some extra printing if metadata write fails in third_grouping
!
! Revision 2.49  2003/09/03 23:56:24  pwagner
! Can get species name from trivial file name fragment
!
! Revision 2.48  2003/08/11 17:29:36  cvuu
! Change to output attributes StartOrbitNumber and StopOrbitNumber instead of OrbitNumber
!
! Revision 2.47  2003/08/01 20:25:08  pwagner
! Removed ref to undefined sd_path
!
! Revision 2.46  2003/07/23 18:27:44  cvuu
! brought closer to James Johnson want to; quick and dirty fixed for CH3CN
!
! Revision 2.45  2003/07/07 23:48:18  pwagner
! Changed in interfaces to make filetype a lit_name; l2pcf a saved variable
!
! Revision 2.44  2003/06/09 22:49:35  pwagner
! Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
!
! Revision 2.43  2003/05/30 23:50:32  pwagner
! Relies on lib/PCFHdr to know what mesg goes in InputPointer
!
! Revision 2.42  2003/04/03 22:58:40  pwagner
! Alias now set in lib/L2GPData instead of l2/write_meta
!
! Revision 2.41  2003/03/15 00:15:52  pwagner
! Wont quit if pgs_met_remove returns non-zero value
!
! Revision 2.40  2003/03/11 00:21:36  pwagner
! Interfaces fit new WritePCF2Hdr flixibility
!
! Revision 2.39  2003/03/07 00:55:38  pwagner
! Set INPUTPOINTERMESG when annotating with PCF as a private param /HDFEOS/ADDITIONAL/FILE_ATTRIBUTES/PCF
!
! Revision 2.38  2003/02/27 21:54:28  pwagner
! Now annotates with PCF; does not set inputPointer
!
! Revision 2.37  2003/02/10 22:02:41  pwagner
! Passes isHDFEOS to PCFHdr
!
! Revision 2.36  2003/02/01 00:29:40  pwagner
! Passes hdfVersion to writePCF2Hdr
!
! Revision 2.35  2003/01/30 01:01:05  pwagner
! Lets PCFHdr prepare and write input pointer
!
! Revision 2.34  2003/01/14 00:42:24  pwagner
! Creates soft link to type2precisionname, too
!
! Revision 2.33  2002/12/11 22:21:05  pwagner
! Makes soft link to data field name from L2gpValue field in hdf5 l2gp
!
! Revision 2.32  2002/12/06 23:37:22  pwagner
! addingMetaData now optional arg to mls_sfstart
!
! Revision 2.31  2002/11/22 12:31:16  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.30  2002/10/08 17:36:23  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.29  2002/08/29 16:55:35  pwagner
! Moved writeInputPointer to PCFHdr in lib
!
! Revision 2.28  2002/08/28 22:27:26  pwagner
! Now writes input pointer metadata like L3MMData
!
! Revision 2.27  2002/03/13 18:31:01  pwagner
! Opens, writes metadata, closes each file only once
!
! Revision 2.26  2002/02/22 19:20:12  pwagner
! Added mcf file name to announce_success
!
! Revision 2.25  2002/02/22 01:18:06  pwagner
! get_l2gp_mcf accepts meta_name arg; now uses getPCFFromRef
!
! Revision 2.24  2002/01/31 00:37:45  pwagner
! Checks return value of mls_sfend
!
! Revision 2.23  2002/01/26 00:08:20  pwagner
! Housekeeping; changed proclaim to announce_success
!
! Revision 2.22  2002/01/23 21:50:04  pwagner
! Uses hdfVersion optional parameter
!
! Revision 2.21  2002/01/22 17:45:26  pwagner
! Removed bogus declaration of pgs_met_startf
!
! Revision 2.20  2002/01/18 23:11:09  pwagner
! Uses mls_sfstart; writePCF2Hdr controlled by ANNOTATEWITHPCF; dumps core (hooray)
!
! Revision 2.19  2002/01/09 23:54:24  pwagner
! Now gets FileNameLen from MLSCommon, not SDPToolkit
!
! Revision 2.18  2001/05/17 22:33:27  pwagner
! Prints info if pro switch set
!
! Revision 2.17  2001/05/08 23:28:46  pwagner
! Sorry-bad metadata functions in SDPToolkit
!
! Revision 2.16  2001/05/07 23:30:05  pwagner
! Gets all pgs_ from SDPToolkit
!
! Revision 2.15  2001/05/07 18:04:51  pwagner
! Always check for CREATEMETADATA first
!
! Revision 2.14  2001/05/03 20:34:20  vsnyder
! Cosmetic changes
!
! Revision 2.13  2001/04/20 23:52:15  vsnyder
! Consider the penalty from MLSL2Options in Announce_Error.  Numerous
! cosmetic changes.  Remove dump of tree node from Announce_Error.
!
! Revision 2.12  2001/04/19 23:51:40  pwagner
! Moved anText to become component of PCFData_T
!
! Revision 2.11  2001/04/16 23:49:11  pwagner
! Tiny change to announce_error
!
! Revision 2.10  2001/04/16 17:43:35  pwagner
! mcf text matching case sensitive if MCFCASESENSITIVE
!
! Revision 2.9  2001/04/13 23:47:26  pwagner
! Writes multiple measuredcontainers properly
!
! Revision 2.8  2001/04/13 00:28:03  pwagner
! Turned get_l2gp_mcf into a subroutine
!
! Revision 2.7  2001/04/12 00:22:17  pwagner
! Added announce_error
!
! Revision 2.6  2001/04/11 20:20:37  pwagner
! Checks correctly on PCF file before attempting LOG.met
!
! Revision 2.5  2001/04/10 23:03:57  pwagner
! Finally seems to work
!
! Revision 2.4  2001/04/09 23:45:47  pwagner
! Deleted unused old populate_metadata; some fixes
!
! Revision 2.3  2001/04/03 23:51:28  pwagner
! Many changes; some may be right
!
! Revision 2.2  2001/04/02 23:42:18  pwagner
! Added populate_metadata_oth
!
! Revision 2.1  2001/02/13 22:59:36  pwagner
! l2 modules can only use MLSPCF2
!
! Revision 2.0  2000/09/05 18:57:07  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.4  2000/06/30 00:16:41  lungu
! Made dval REAL(r8).
!
@


2.83
log
@Remove USE statements for unused names
@
text
@d16 23
a38 23
  use DUMP_0, only: DUMP
  use HDF, only: DFACC_RDWR
  use HIGHOUTPUT, only: BEVERBOSE, OUTPUTNAMEDVALUE
  use INIT_TABLES_MODULE, only: L_L2DGG, L_L2GP, L_HDF, L_SWATH
  use IO_STUFF, only: READ_TEXTFILE
  use LEXER_CORE, only: PRINT_SOURCE
  use MLSCOMMON, only: FILENAMELEN, NAMELEN, L2METADATA_T, MLSFILE_T
  use MLSKINDS, only: R8
  use MLSFILES, only: DUMP, GETPCFROMREF, MLS_CLOSEFILE, MLS_OPENFILE, &
    &  MLS_SFSTART, MLS_SFEND, SPLIT_PATH_NAME
  use MLSL2OPTIONS, only: TOOLKIT, SHAREDPCF
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_WARNING
  use MLSPCF2, only: MLSPCF_MCF_L2GP_END, MLSPCF_MCF_L2GP_START, &
    & MLSPCF_MCF_L2LOG_START
  use MLSSTRINGS, only: ISCOMMENT, LOWERCASE, STREQ
  use MLSSTRINGLISTS, only: EXTRACTSUBSTRING, &
    & GETHASHELEMENT, GETSTRINGELEMENT
  use OUTPUT_M, only: OUTPUT, BLANKS
  use PCFHDR, only: WRITEINPUTPOINTER, WRITEPCF2HDR, GLOBALATTRIBUTES
  use SDPTOOLKIT, only: PGSD_MET_GROUP_NAME_L, &
    & PGSD_MET_NUM_OF_GROUPS, PGSD_PC_FILE_PATH_MAX, PGS_PC_GETREFERENCE, &
    & PGSPC_W_NO_REFERENCE_FOUND, PGS_S_SUCCESS, PGSMET_W_METADATA_NOT_SET
  use TREE, only: WHERE
d107 7
a113 6
  public :: ADDMCGROUPTODATABASE, ADDMCPARAMTODATABASE, ADDTOMETADATA, &
    & DESTROY, DESTROYMCGROUP, DESTROYMCGROUPDB, &
    & DUMP, DUMPMCGROUP, DUMPMCGROUPDB, &
    & GET_L2GP_MCF, MCTREE, NULLIFYPCFDATA, &
    & POPULATE_METADATA_STD, POPULATE_METADATA_OTH, &
    & READMCF, WRITEMCF, WRITEMETALOG
d190 1
a190 1
    ! identifier_product_DOI
d1990 1
a1990 1
    attrName = 'identifier_product_DOI'
d2128 1
a2128 1
       "$Id: write_meta.f90,v 2.82 2015/03/28 02:56:12 vsnyder Exp $"
d2137 3
d2150 1
a2150 1
! Added ProductionLocation, identifier_product_DOI metadata
@


2.82
log
@Added stuff to trace allocate/deallocate addresses
@
text
@a230 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a250 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d2127 1
a2127 1
       "$Id: write_meta.f90,v 2.81 2014/09/05 01:28:53 vsnyder Exp $"
d2136 3
@


2.81
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d231 1
d252 1
d337 1
d340 1
d349 2
d352 1
a352 1
      call test_deallocate ( error, moduleName, 'MCGroup%groups', s )
d359 2
d362 1
a362 1
      call test_deallocate ( error, moduleName, 'MCGroup%params', s )
d371 1
d374 1
d383 2
d386 1
a386 1
      call test_deallocate ( error, moduleName, 'MCParam%groups', s )
d393 2
d396 2
a397 2
      call test_deallocate ( error, moduleName, 'MCParam%params', s )
    endif
d404 1
d407 1
d416 2
d419 1
a419 1
    call test_deallocate ( error, moduleName, 'MCGroupDB', s )
d2129 1
a2129 1
       "$Id: write_meta.f90,v 2.80 2014/04/07 18:10:09 pwagner Exp $"
d2138 3
@


2.80
log
@Added new metadata attribute: DataProducer
@
text
@d27 1
a27 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, &
    & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMSG_ERROR, MLSMSG_WARNING
d230 2
d250 2
d334 1
d337 1
a337 1
    integer :: i, error
d343 5
a347 5
      enddo
      deallocate( MCGroup%groups, stat=error )
      if ( error /= 0 ) call announce_error( 0, &
        & 'Failed to deallocate MCGroup%groups' )
    endif
d351 5
a355 5
      enddo
      deallocate( MCGroup%params, stat=error )
      if ( error /= 0 ) call announce_error( 0, &
        & 'Failed to deallocate MCGroup%params' )
    endif
d362 1
d365 1
a365 1
    integer :: i, error
d371 5
a375 5
      enddo
      deallocate( MCParam%groups, stat=error )
      if ( error /= 0 ) call announce_error( 0, &
        & 'Failed to deallocate MCParam%groups' )
    endif
d379 4
a382 4
      enddo
      deallocate( MCParam%params, stat=error )
      if ( error /= 0 ) call announce_error( 0, &
        & 'Failed to deallocate MCParam%params' )
d389 1
d392 1
a392 1
    integer :: i, error
d398 4
a401 4
    enddo
    deallocate( MCGroupDB, stat=error )
    if ( error /= 0 ) call announce_error( 0, &
      & 'Failed to deallocate MCGroupDB' )
d2111 1
a2111 1
       "$Id: write_meta.f90,v 2.79 2014/03/26 17:47:44 pwagner Exp $"
d2120 3
@


2.79
log
@Added ProductionLocation, identifier_product_DOI metadata
@
text
@d1957 8
d2105 1
a2105 1
       "$Id: write_meta.f90,v 2.78 2014/03/07 19:30:30 pwagner Exp $"
d2114 3
@


2.78
log
@Housekeeping; insert comments suggesting use of NameLen instead of hard-coded charlens
@
text
@d159 1
a159 24
    ! The correspondence between MCF and l2gp files is determined by
    ! the value of        MCFFORL2GPOPTION
    ! One of three possible options:
    !                          (1)
    ! The PCF numbers for the mcf corresponding to each
    ! of the l2gp files begin with mlspcf_mcf_l2gp_start
    ! and increase 1 by 1 with each succeeding species.
    ! Then, after the last single-species l2gp, the very next pcf number
    ! is for the one called 'other' ML2OTH.001.MCF
    ! This inconvenient inflexibility is relieved in option (2) or (3)

    !                          (2)
    ! Each l2gp file name, stripped of their paths, fits the pattern like
    !  *_l2gp_species_*
    ! and the corresponding MCF files fit the pattern
    !  *SPECIES.*
    ! where species and SPECIES are case-insensitive "species" name
    ! i.e., BrO, ClO, etc.
    ! Warning:
    ! You therefore must use exactly the same abbreviation for the l2gp and the
    ! corresponding MCF: if the MCF is ML2T.001.MCF, don't use "temp"
    ! in the l2gp name
    ! This inflexibility replaces the different kind in option (1)

d161 1
a161 1
    ! Similar to (2), but now the SPECIES of the corresponding
a177 1

d181 2
a182 1
    ! mcf file name parts that may be the corresponding hash
d184 2
a185 1
    character (len=fileNameLen) :: spec_hash
a187 1

d190 2
a191 3
    ! Parts of the input pointer
    ! INTEGER :: L1BOAPCFId=0  ! The PCF ID for the L1BOA file
    ! INTEGER, DIMENSION(:), POINTER :: L1BRADPCFIds => NULL()
d526 1
a526 1
  subroutine Get_l2gp_mcf ( File_base, meta_name, Mcf, Version )
a532 1
    integer, intent(in), optional :: Version
d534 2
a535 1
    ! type(PCFData_T) :: l2pcf
d550 1
a550 1
    ! assume sd_name is "*l2gp_species_"
d562 4
a565 4
    if ( MCFFORL2GPOPTION == 1 ) then
      mcf = mcf+1
      return
    end if
d587 1
a587 5
        if ( present(version) ) then
          myVersion=version
        else
          myVersion = 1
        end if
d589 1
a589 1
        returnStatus = PGS_PC_GetReference(i, myVersion , mcf_full)
d628 1
a628 1
      ! Either we were given a short version of the sd_full
d649 1
a649 1
      if ( MCFFORL2GPOPTION == 3 ) then
d653 1
a653 1
        call GetHashElement ( l2pcf%spec_keys, l2pcf%spec_hash, &
d655 2
d662 1
a662 1
          call output(trim(l2pcf%spec_hash), advance='yes')
d674 1
a674 1
      end if
d1947 21
d2097 1
a2097 1
       "$Id: write_meta.f90,v 2.77 2014/01/09 00:30:24 pwagner Exp $"
d2106 3
@


2.77
log
@Some procedures formerly in output_m now got from highOutput
@
text
@a38 1
  use TOGGLES, only: SWITCHES
d117 2
a118 1

a1037 1
    ! integer :: swLevel ! How much extra debugging info to print (-1 means none)
a1040 1
    ! swlevel = switchDetail(switches, 'mcf' )
a1415 1
    ! integer :: swLevel ! How much extra debugging info to print (-1 means none)
a1417 1
    ! swlevel = switchDetail(switches, 'mcf' )
a1475 1
    ! integer :: swLevel ! How much extra debugging info to print (-1 means none)
a1477 1
    ! swlevel = switchDetail(switches, 'mcf' )
d2028 1
a2028 1
    ! write( MLSFile%fileID%f_id, * ) spaces(:indent), '#GROUP_NAME_LEN = ', len_trim(MCGroup%name)
d2102 1
a2102 1
       "$Id: write_meta.f90,v 2.76 2013/12/05 01:42:03 pwagner Exp $"
d2111 3
@


2.76
log
@Added RunID component to pcf; started using BeVerbose
@
text
@d18 1
d34 1
a34 1
  use OUTPUT_M, only: OUTPUT, BEVERBOSE, BLANKS, OUTPUTNAMEDVALUE
d2108 1
a2108 1
       "$Id: write_meta.f90,v 2.75 2013/09/24 23:47:23 vsnyder Exp $"
d2117 3
@


2.75
log
@Use Where instead of Source_Ref for messages
@
text
@d32 2
a33 2
    & GETHASHELEMENT, GETSTRINGELEMENT, SWITCHDETAIL
  use OUTPUT_M, only: OUTPUT, BLANKS, OUTPUTNAMEDVALUE
d39 1
a39 1
  use TREE, only: Where
d141 1
d143 2
a144 1
    character (len=4) :: cycle
a146 1

d902 1
a902 1
   if(switchDetail(switches, 'pro') > -1) then
d1019 1
a1019 1
   if(switchDetail(switches, 'pro') > -1) then
d1037 1
a1037 1
    integer :: swLevel ! How much extra debugging info to print (-1 means none)
d1041 2
a1042 2
    swlevel = switchDetail(switches, 'mcf' )
    verbose = ( swlevel >= 0 )
d1225 1
a1225 1
   if(switchDetail(switches, 'pro') > -1) then
d1417 1
a1417 1
    integer :: swLevel ! How much extra debugging info to print (-1 means none)
d1420 2
a1421 2
    swlevel = switchDetail(switches, 'mcf' )
    verbose = ( swlevel >= 0 )
d1479 1
a1479 1
    integer :: swLevel ! How much extra debugging info to print (-1 means none)
d1482 2
a1483 2
    swlevel = switchDetail(switches, 'mcf' )
    verbose = ( swlevel >= 0 )
d2107 1
a2107 1
       "$Id: write_meta.f90,v 2.74 2013/07/26 00:07:35 pwagner Exp $"
d2116 3
@


2.74
log
@Added routines to read, write, and parse MCFs
@
text
@d39 1
a39 1
  use TREE, only: SOURCE_REF
d1276 1
a1276 1
        call print_source ( source_ref(lcf_where) )
d2106 1
a2106 1
       "$Id: write_meta.f90,v 2.73 2013/07/18 22:39:37 pwagner Exp $"
d2115 3
@


2.73
log
@Added datatypes, functions for metadata control
@
text
@d16 1
d19 1
d30 3
a32 2
  use MLSSTRINGS, only: LOWERCASE
  use MLSSTRINGLISTS, only: GETHASHELEMENT, EXTRACTSUBSTRING, SWITCHDETAIL
d62 1
d71 1
d75 2
d84 1
d92 1
d103 1
d108 1
a108 1
  public :: ADDMCGROUPTODATABASE, ADDTOMETADATA, &
d111 3
a113 2
    & GET_L2GP_MCF, NULLIFYPCFDATA, &
    & POPULATE_METADATA_STD, POPULATE_METADATA_OTH, WRITEMCF, WRITEMETALOG
d120 2
d132 4
a135 2
    character (len=80) :: type         = ' '
    character (len=80) :: value         = ' '
d228 1
d243 1
d265 18
d353 1
a353 1
    type ( MCGROUP_T ), intent(out)               :: MCGROUP
d358 16
a373 9
    do i=1, size(MCGroup%groups)
      call DestroyMCGroup( MCGroup%groups(i) )
    enddo
    deallocate( MCGroup%groups, stat=error )
    if ( error /= 0 ) call announce_error( 0, &
      & 'Failed to deallocate MCGroup%groups' )
    deallocate( MCGroup%params, stat=error )
    if ( error /= 0 ) call announce_error( 0, &
      & 'Failed to deallocate MCGroup%params' )
d376 27
d411 1
d434 6
a441 1
    call blanks( indent )
d443 2
a444 1
      call output( ' (No subgroups of this group) ', advance='yes' )
d447 2
a448 1
        call output( ' Sub-group ', advance='no' )
d455 1
a455 1
      call output( ' (No parameters in this group) ', advance='yes' )
d458 1
a458 26
        indent = nest_degree*3
        call blanks( indent )
        call output( ' Parameter ', advance='no' )
        call output( i, advance='yes' )
        indent = indent + 4
        if ( len_trim(MCGroup%params(i)%name) > 0 ) &
          & call outputnamedValue( spaces(:indent)//'name', &
          & MCGroup%params(i)%name )
        if ( len_trim(MCGroup%params(i)%mandatory) > 0 ) &
          & call outputnamedValue( spaces(:indent)//'mandatory', &
          & MCGroup%params(i)%mandatory )
        if ( len_trim(MCGroup%params(i)%data_location) > 0 ) &
          & call outputnamedValue( spaces(:indent)//'data_location', &
          & MCGroup%params(i)%data_location )
        if ( len_trim(MCGroup%params(i)%class) > 0 ) &
          & call outputnamedValue( spaces(:indent)//'class', &
          & MCGroup%params(i)%class )
        if ( len_trim(MCGroup%params(i)%num_val) > 0 ) &
          & call outputnamedValue( spaces(:indent)//'num_val', &
          & MCGroup%params(i)%num_val )
        if ( len_trim(MCGroup%params(i)%type) > 0 ) &
          & call outputnamedValue( spaces(:indent)//'type', &
          & MCGroup%params(i)%type )
        if ( len_trim(MCGroup%params(i)%value) > 0 ) &
          & call outputnamedValue( spaces(:indent)//'value', &
          & MCGroup%params(i)%value )
d485 61
d720 61
d1024 27
d1061 1
d1065 1
a1065 1
    call dump( MLSFile )
d1068 9
a1076 2
    write( MLSFile%fileID%f_id, * ) 'GROUP = INVENTORYMETADATA'
    write( MLSFile%fileID%f_id, * ) 'GROUPTYPE = MASTERGROUP'
d1080 2
a1081 1
    write( MLSFile%fileID%f_id, * ) 'END_GROUP = INVENTORYMETADATA'
d1404 142
d2025 1
a2025 1
    integer, save :: indent
d2028 1
d2030 4
d2035 19
a2053 38
    write( MLSFile%fileID%f_id, * ) spaces(:indent), 'GROUP = ' // trim(MCGroup%name)
    do i=1, size(MCGroup%groups)
      call writeMCGroup( MLSFile, MCGroup%groups(i) )
    enddo
    do i=1, size(MCGroup%params)
      call writeMCParam( MCGroup%params(i) )
    enddo
    write( MLSFile%fileID%f_id, * )  spaces(:indent), 'END_GROUP = ' // trim(MCGroup%name)
    indent = indent - 3
    contains
    subroutine writeMCParam ( MCPARAM )
      type ( MCParam_T ), intent(in)               :: MCPARAM
      ! Internal variables
      ! Executable
      indent = indent + 3
      write( MLSFile%fileID%f_id, * ) spaces(:indent), &
        & 'OBJECT = ' // trim(MCParam%name)
      indent = indent + 3
      write( MLSFile%fileID%f_id, * ) spaces(:indent), &
        & 'Mandatory = ' // trim(MCParam%mandatory)
      write( MLSFile%fileID%f_id, * ) spaces(:indent), &
        & 'Data_Location = ' // trim(MCParam%data_location)
      if ( len_trim(MCParam%class) > 0 ) &
        & write( MLSFile%fileID%f_id, * ) spaces(:indent), &
        & 'Data_Location = ' // trim(MCParam%data_location)
      write( MLSFile%fileID%f_id, * ) spaces(:indent), &
        & 'NUM_VAL = ' // trim(MCParam%num_val)
      write( MLSFile%fileID%f_id, * ) spaces(:indent), &
        & 'TYPE = ' // trim(MCParam%type)
      if ( len_trim(MCParam%value) > 0 ) &
        & write( MLSFile%fileID%f_id, * ) spaces(:indent), &
        & 'Data_Location = ' // trim(MCParam%value)
      
      indent = indent - 3
      write( MLSFile%fileID%f_id, * ) spaces(:indent), &
        & 'END_OBJECT = ' // trim(MCParam%name)
      indent = indent - 3
    end subroutine writeMCParam
d2056 47
d2106 1
a2106 1
       "$Id: write_meta.f90,v 2.72 2013/04/19 20:07:28 pwagner Exp $"
d2115 3
@


2.72
log
@Fixed long-standing bug in closing file after adding metadata
@
text
@d19 1
a19 1
  use MLSCOMMON, only: FILENAMELEN, NAMELEN, L2METADATA_T
d21 2
a22 1
  use MLSFILES, only: GETPCFROMREF, MLS_SFSTART, MLS_SFEND, SPLIT_PATH_NAME
d24 2
a25 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_WARNING
d30 1
a30 1
  use OUTPUT_M, only: OUTPUT, BLANKS
d48 55
a102 2
  public :: ADDTOMETADATA, POPULATE_METADATA_STD, POPULATE_METADATA_OTH, &
    & GET_L2GP_MCF, WRITEMETALOG, NULLIFYPCFDATA
d107 16
d208 8
d223 1
d225 2
d230 18
d314 44
a357 1
  ! ---------------------------------------------  First_grouping  -----
d359 52
a410 1
  subroutine First_grouping ( HDF_FILE, MCF_FILE, Groups )
d412 6
a417 2
    ! This writes the metadata for the following attributes:
    ! (attributes marked automatic are not explicitly written, however)
d419 13
a431 7
    ! SizeMBECSDataGranule (automatic)
    ! ReProcessingPlanned
    ! LocalGranuleID
    ! DayNightFlag
    ! ProductionDateTime (automatic)
    ! LocalVersionID
    !
d433 1
a433 1
    !    USE InitPCFs, ONLY: L2PCF
d435 1
a435 1
    !Arguments
d437 7
a443 1
    integer :: HDF_FILE, MCF_FILE
d446 4
a449 4
    ! the group have to be defined as 49 characters long. The C interface is 50.
    ! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
    ! therefore making the actual length of a 
    ! string pass of 50.
d451 4
a454 1
    character (len = PGSd_MET_GROUP_NAME_L) :: Groups(PGSd_MET_NUM_OF_GROUPS)
d456 1
a456 1
    !Local Variables
d458 3
a460 8
    integer, parameter :: ARCHIVE=1, INVENTORY=2
    character (len=132) :: Attrname
    integer :: Indx, Version
    character (len=PGSd_PC_FILE_PATH_MAX) :: Physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: Sval
    character (len=*), parameter :: METAWR_ERR = &
         'Error writing metadata attribute '
    integer :: ReturnStatus
d462 1
a462 1
    ! Externals
d464 1
a464 3
    integer, external :: PGS_MET_init, &
      &  PGS_MET_setAttr_s
    ! Executable code
d466 4
a469 2
    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)
d471 3
a473 3
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in getting ref for PCF number in 1st grouping." ) 
d476 5
a480 5
    returnStatus = pgs_met_init (MCF_FILE, groups)

    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Metadata initialization error" )
d483 3
a485 10
    ! Set PGE values 

    ! ECSDataGranule

    attrName = 'ReprocessingPlanned'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'further update anticipated using enhanced PGE')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing ReprocessingPlanned attribute." )
d488 7
a494 8
    attrName = 'LocalGranuleID'
    sval = physical_filename
    indx = INDEX (sval, "/", .TRUE.) + 1  ! Begin after last "/"
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval(indx:))
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
       & "Error in writing LocalGranuleID attribute." ) 
    end if
d496 5
a500 6
    attrName = 'DayNightFlag'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, 'Both')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing DayNightFlag attribute." )
    end if
d502 1
a502 7
    attrName = 'LocalVersionID'
    sval = 'c' // l2pcf%cycle
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing LocalVersionID attribute." ) 
    end if
d504 3
a506 1
  end subroutine First_grouping
d508 1
a508 1
  ! -----------------------------------------  Measured_parameter  -----
d510 4
a513 1
  subroutine Measured_parameter ( HDF_FILE, Field_name, Groups, Class_num)
d515 4
a518 13
    ! This writes the attributes corresponding to the measured parameter container:
    !
    ! ParameterName
    ! AutomaticQualityFlag
    ! AutomaticQualityFlagExplanation
    ! OperationalQualityFlag
    ! OperationalQualityFlagExplanation
    ! ScienceQualityFlag
    ! ScienceQualityFlagExplanation
    ! QAPercentInterpolatedData
    ! QAPercentMissingData
    ! QAPercentOutOfBoundsData
    !
d520 1
a520 1
    !    USE InitPCFs, ONLY: L2PCF
d522 1
a522 1
    !Arguments
d524 7
a530 3
    integer                       :: HDF_FILE
    character(len=*)              :: Field_name
    integer, intent(in)           :: Class_num
d532 8
a539 4
    ! the group have to be defined as 49 characters long. The C interface is 50.
    ! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
    ! therefore making the actual length of a 
    ! string pass of 50.
d541 8
a548 1
    character (len = PGSd_MET_GROUP_NAME_L) :: Groups(PGSd_MET_NUM_OF_GROUPS)
d550 6
a555 1
    ! Local Variables
d557 4
a560 10
    integer, parameter :: ARCHIVE=1, INVENTORY=2
    character (len=132) :: Attrname
    character (len=2) :: Class
    character (len=*), parameter :: METAWR_ERR = &
      &  'Error writing metadata attribute '
    character (len=PGSd_PC_FILE_PATH_MAX) :: Physical_filename
    integer :: ReturnStatus
    character (len=PGSd_PC_FILE_PATH_MAX) :: Sval
    integer :: Version
    integer, parameter :: FILEACCESSTYPE = DFACC_RDWR
d562 1
a562 1
    ! Externals
d564 4
a567 2
    integer, external :: &
      &  PGS_MET_setAttr_s, PGS_MET_SETATTR_I
d569 8
a576 3
    !Executable code
    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)
d578 4
d583 1
a583 4
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
        & "Error in getting ref for PCF id in measured_parameter." )
    end if
d585 87
a671 11
    ! A moment of misplaced priorities: we have decided to create
    ! links between valid data field names and the name L2gpValue
    ! Instead of doing this in a routine created for that purpose,
    ! we have violated good design principles and stuck it here for now
    !                (moved to WriteL2GPData)
    ! MeasuredParameterContainer
    if ( class_num <= 0 ) then
      class(:2) = '0 '
    else if ( class_num < 10 ) then
      write ( class(:1), '(I1)' ) class_num
      class(2:2) = ' '
d673 1
a673 1
      write ( class(:2), '(I2)' ) class_num
a675 7
    if ( field_name /= ' ' ) then
      sval = adjustl(field_name)
    else
      sval = 'Miscellaneous'
    end if
    attrName = 'ParameterName' // '.' // class
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval)
d678 2
a679 1
        & "Error in writing ParameterName attribute." )
d682 2
a683 3
    ! QAFlags Group
    ! These have been moved to the MCF files
    ! QAStats Group
a684 2
    attrName = 'QAPercentInterpolatedData' // '.' // class
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 0)
d687 2
a688 1
        & "Error in writing QAPercentInterpolatedData attribute." )
d691 13
a703 3
    attrName = 'QAPercentMissingData' // '.' // class
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 0)
    if ( returnStatus /= PGS_S_SUCCESS ) then
d705 3
a707 1
        & "Error in writing QAPercentMissingData attribute." )
d710 5
a714 5
    attrName = 'QAPercentOutofBoundsData' // '.' // class
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 0)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing QAPercentOutofBoundsData attribute." )
d717 5
a721 1
  end subroutine Measured_parameter
d723 1
a723 1
  ! ---------------------------------------------  Third_grouping  -----
d725 1
a725 2
  subroutine Third_grouping ( HDF_FILE, hdf_sdid, Groups, &
    & hdfVersion, filetype, l2metaData )
d727 3
a729 1
    ! This writes the following metadata attributes:
d731 1
a731 23
    ! OrbitNumber
    ! StartOrbitNumber
    ! StopOrbitNumber
    ! EquatorCrossingLongitude
    ! EquatorCrossingTime
    ! EquatorCrossingDate
    ! ShortName
    ! VersionID
    ! InputPointer
    ! LocalityValue
    ! VerticalSpatialDomainType
    ! VerticalSpatialDomainValue
    ! ZOneIdentifier
    ! WestBoundingCoordinate
    ! NortBoundingCoordinate
    ! EastBoundingCoordinate
    ! SouthBoundingCoordinate
    ! RangeBeginningDate
    ! RangeBeginningTime
    ! RangeEndingDate
    ! RangeEndingTime
    ! PGEVersion
    !
d733 1
d735 3
a737 1
    ! Arguments
d739 3
a741 2
    integer :: HDF_FILE
    integer :: hdf_sdid
d743 1
a743 4
    ! the group have to be defined as 49 characters long. The C interface is 50.
    ! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
    ! therefore making the actual length of a 
    ! string pass of 50.
d745 4
a748 1
    character (len = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
a750 1
    type (L2Metadata_T) :: l2metaData
d756 1
a757 2
    real(r8) :: Dval
    integer, parameter :: INVENTORY=2, ARCHIVE=1
d759 7
a765 7
    character (len=PGSd_PC_FILE_PATH_MAX) :: sval
    character (len=132) :: attrname
    integer :: version, indx
    integer :: inptptr_filetype
    character (len=*), parameter :: METAWR_ERR = &
      & 'Error writing metadata attribute '
    integer :: startOrbit, stopOrbit
d767 1
d771 2
a772 3
    integer, external :: PGS_MET_setattr_d, &
         PGS_MET_setAttr_s, PGS_MET_SETATTR_I, &
         PGS_MET_write, PGS_MET_remove
d775 17
a791 2
    inptptr_filetype = l_swath
    if ( present(filetype) ) inptptr_filetype = filetype
d795 1
a795 1
    if ( returnStatus /= PGS_S_SUCCESS ) then 
d797 2
a798 1
      & "Error in getting ref for PCF id in third_grouping.") 
d801 6
a806 3
    ! Orbit Calculated Spatial Domain Container
    ! Per James Johnson's email 6/12/03, use either OrbitNumber OR 
    ! (StartOrbitNumber and StopOrbitNumber)
d808 1
a808 8
    !attrName = 'OrbitNumber' // '.1'
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, -1)
    ! This change to confirm James Johnson suggestion on 6/12/03
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 999)
    !if ( returnStatus /= PGS_S_SUCCESS ) then
    !  call announce_error ( 0, &
    !  & "Error in writing OrbitNumber attribute.") 
    !end if
d810 2
a811 4
    ! Start, Stop orbit numbers: level one has actual calculated numbers
    ! but, for now at least, we'll not trouble
    ! For now, use 99999 for invalid value
    ! Write start, stop orbit numbers from l1 to l2
d813 3
a815 3
    attrName = 'StartOrbitNumber' // '.1'
    if (GlobalAttributes%OrbNum(1) == -1) then
        startOrbit = 99999
d817 4
a820 7
        startOrbit = GlobalAttributes%OrbNum(1)
    end if
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, &
        & startOrbit)
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 99999)
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, -1)
    if ( returnStatus /= PGS_S_SUCCESS ) then
d822 2
a823 1
      & "Error in writing StartOrbitNumber attribute.")
d826 5
a830 5
    attrName = 'StopOrbitNumber' // '.1'
    if (maxval(GlobalAttributes%OrbNum) == -1) then
        stopOrbit = 99999
    else
        stopOrbit = maxval(GlobalAttributes%OrbNum)
d832 6
a837 7
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, &
        & stopOrbit)
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 99999)
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, -1)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing StopOrbitNumber attribute.")
d840 3
a842 7
    attrName = 'EquatorCrossingLongitude' // '.1'
    dval = 0.0
    returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing EquatorCrossingLongitude attribute.") 
    end if
d844 3
a846 7
    attrName = 'EquatorCrossingTime' // '.1'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         '00:00:00')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing EquatorCrossingTime attribute.") 
    end if
d848 1
a848 8
    indx = INDEX (L2PCF%startUTC, "T")
    attrName = 'EquatorCrossingDate' // '.1'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         L2PCF%startUTC(1:indx-1))
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing EquatorCrossingDate attribute.") 
    end if
d850 10
a859 1
    ! InputPointer
d861 13
a873 12
    attrName = 'InputPointer'
    if ( SETINPUTPOINTER ) then
      call announce_error ( 0, &
      & "Invalid method of writing InputPointer attribute.") 
    else
      returnStatus = WriteInputPointer(groups(INVENTORY), attrName, &
        & filetype=inptptr_filetype)
    endif
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing InputPointer attribute.") 
    end if
d875 1
a875 1
    ! Locality Value
d877 2
a878 7
    attrName = 'LocalityValue'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'Limb')
    if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing LocalityValue attribute.")
     end if
d880 2
a881 1
     ! VerticalSpatialDomain Product-Specific Attribute
d883 1
a883 7
     attrName = 'VerticalSpatialDomainType' // '.1'
     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
          'Atmosphere Layer')
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing VerticalSpatialDomainType attribute.")
     end if
d885 2
a886 12
     attrName = 'VerticalSpatialDomainValue' // '.1'
     !returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
     !     'Brightness Temperature')
     ! The following change bring level 2 into agreement level 3
     ! Further change to confirm James Johnson suggestion 6/12/03
     ! will await in the next delivery which it also unify all 3 levels
     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
          'Atmosphere Profile')
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing VerticalSpatialDomainValue attribute.")
     end if
d888 2
a889 1
     ! HorizontalSpatialDomainContainer
d891 2
a892 7
     attrName = 'ZoneIdentifier'
     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
          'Other Grid System')
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing ZoneIdentifier attribute.")
     end if
d894 1
a894 6
     if ( .not. sharedPCF ) then
        l2metaData%minLon = -180.0
        l2metaData%maxLon = 180.0
        l2metaData%minLat = -90.0
        l2metaData%maxLat = 90.0
     end if
d896 3
a898 7
     attrName = 'WestBoundingCoordinate'
     dval = l2metaData%minLon 
     returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing WestBoundingCoordinate attribute.")
     end if
d900 1
a900 7
     attrName = 'NorthBoundingCoordinate'
     dval = l2metaData%maxLat 
     returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing NorthBoundingCoordinate attribute.")
     end if
d902 7
a908 7
     attrName = 'EastBoundingCoordinate'
     dval = l2metaData%maxLon 
     returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
     if ( returnStatus /= PGS_S_SUCCESS ) then
       call announce_error ( 0, &
       & "Error in writing EastBoundingCoordinate attribute.")
     end if
d910 2
a911 7
     attrName = 'SouthBoundingCoordinate'
     dval = l2metaData%minLat 
     returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
     if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing SouthBoundingCoordinate attribute.")
    end if
d913 4
a916 1
    indx = INDEX (L2PCF%startUTC, "T")
d918 1
a918 1
    ! RangeDateTime Group
d920 3
a922 7
    attrName = 'RangeBeginningDate'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), &
         attrName, L2PCF%startUTC(1:indx-1))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in setting RangeBeginningDate attribute.") 
    end if
d924 1
a924 3
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), &
         "RangeBeginningTime", L2PCF%startUTC(indx+1:))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
d926 2
a927 1
      & "Error in setting RangeBeginningTime attribute.") 
d930 3
a932 6
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), "RangeEndingDate", &
         L2PCF%endUTC(1:indx-1))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      call announce_error ( 0, &
      & "Error in setting RangeEndingDate attribute.") 
    end if
d934 1
a934 3
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), "RangeEndingTime", &
         L2PCF%endUTC(indx+1:))
    if ( returnStatus /= PGS_S_SUCCESS ) then 
d936 2
a937 1
      & "Error in setting RangeEndingTime attribute.") 
d940 2
a941 1
    ! PGEVersion
d943 1
a943 4
    attrName = 'PGEVersion'
    sval = L2PCF%PGEVersion
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, sval)
    if ( returnStatus /= PGS_S_SUCCESS ) then
d945 2
a946 1
      & "Error in setting PGEVersion attribute.") 
d949 37
a985 2
    hdf_sdid = mls_sfstart (physical_fileName, DFACC_RDWR, &
      & hdfVersion=hdfVersion, addingMetaData=.true.) 
d987 1
a987 1
    if ( hdf_sdid == -1 ) then
d989 19
a1007 1
      & "Error: failed to open hdf file: "//physical_fileName) 
d1010 54
a1063 1
    returnStatus = pgs_met_write (groups(INVENTORY), "coremetadata.0", hdf_sdid)
d1065 2
a1066 5
    if ( returnStatus /= PGS_S_SUCCESS .AND. &
      &  returnStatus /= PGSMET_W_METADATA_NOT_SET ) then 
      if ( returnStatus == PGSMET_W_METADATA_NOT_SET ) then 
        call announce_error ( 0, &
        & "Error: some of the mandatory parameters not set.") 
d1068 1
a1068 7
        call output('hdf_sdid: ', advance='no')
        call output(hdf_sdid, advance='yes')
        call output('hdfVersion: ', advance='no')
        call output(hdfVersion, advance='yes')
        call announce_error ( 0, &
        & "Error: metadata write failed in third_grouping." // trim(physical_fileName), &
        & error_number=returnStatus) 
a1069 1
    end if
d1071 19
a1089 6
    if ( SFINBETWEENSTARTEND ) then
      hdfReturn = mls_sfend( hdf_sdid, hdfVersion=hdfVersion, addingMetadata=.true. )
      if ( hdfReturn /= 0 ) then
          call announce_error ( 0, &
          & "Error: metadata mls_sfend in third_grouping.", &
          & error_number=hdfReturn) 
d1091 1
d1093 3
a1095 2
      returnStatus = pgs_met_remove() 
    endif
d1097 1
a1097 1
  end subroutine Third_grouping
d1099 1
a1099 1
  ! --------------------------------------  Populate_metadata_std  -----
d1101 2
a1102 3
  subroutine Populate_metadata_std ( HDF_FILE, MCF_FILE, &
    & Field_name, l2metaData, hdfVersion, Metadata_error, &
    & filetype )
d1104 6
a1109 7
    ! This is the standard way to write meta data
    ! It should work unchanged for the standard l2gp files (e.g. BrO)
    ! and, with minor changes, for the l2gp file marked "other"
    !
    ! the l2aux files, also called dgm
    ! and the dgg files will probably require special treatment
    ! the log file should be able to use the one stolen from level 3
d1116 2
a1117 19
    integer                        :: HDF_FILE, MCF_FILE
    character (len=*)              :: Field_name
    type (L2Metadata_T) :: l2metaData
    integer, optional, intent(in)  :: hdfVersion
    integer, optional, intent(out) :: Metadata_error
    integer, optional, intent(in)  :: filetype  ! 'sw' or 'hdf'

    !Local Variables

    integer :: hdfReturn
    integer :: returnStatus
    integer :: sdid, hdf_sdid

    integer, parameter :: INVENTORY=2, ARCHIVE=1
    character (len=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: mcf_filename
    integer :: version
    character (len=*), parameter :: METAWR_ERR = &
      &  'Error writing metadata attribute '
d1124 1
a1124 1
    character (len = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d1126 1
a1126 1
    ! Externals
d1128 6
a1133 1
    integer, external :: PGS_MET_remove
d1135 1
a1135 1
    !Executable code
d1137 3
a1139 3
    module_error = 0
    if ( present(metadata_error)) metadata_error=1
    if(.NOT. TOOLKIT) return
d1142 1
a1142 5
    if ( mcf_file > 0 ) then
      returnStatus = PGS_PC_GetReference (MCF_FILE, version , mcf_filename)
    else
      returnStatus = PGSPC_W_NO_REFERENCE_FOUND
    end if
d1144 1
a1144 1
    if ( returnStatus /= PGS_S_SUCCESS ) then
d1146 1
a1146 2
      & "Error: failed to find PCF ref for MCF_FILE in populate_metadata_std.") 
      return
d1149 1
a1149 2
    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)
d1151 1
a1151 1
    if ( returnStatus /= PGS_S_SUCCESS ) then
d1153 1
a1153 2
      & "Error: failed to find PCF ref for HDF_FILE in populate_metadata_std.") 
      return
d1156 1
a1156 4
    call first_grouping(HDF_FILE, MCF_FILE, groups)
    call measured_parameter (HDF_FILE, field_name, groups, 1)
    call third_grouping (HDF_FILE, hdf_sdid, groups, &
      & hdfVersion, filetype, l2metaData)
d1158 1
a1158 6
    if ( SFINBETWEENSTARTEND ) then
      sdid = mls_sfstart (physical_fileName, DFACC_RDWR, &
        & hdfVersion=hdfVersion, addingMetaData=.true.)
    else
      sdid = hdf_sdid
    endif 
d1160 4
a1163 1
    if ( sdid == -1 ) then
d1165 1
a1165 3
      & "Error: failed to open the hdf file in populate_metadata_std: "&
      & //TRIM(physical_fileName)) 
      return
d1168 7
a1174 5
    hdfReturn = mls_sfend( sdid, hdfVersion=hdfVersion, addingMetadata=.true. )
    if ( hdfReturn /= 0 ) then
        call announce_error ( 0, &
        & "Error: metadata mls_sfend in populate_metadata_std.", &
        & error_number=hdfReturn) 
d1177 6
a1182 1
    ! Annotate the file with the PCF
d1184 6
a1189 2
    if ( ANNOTATEWITHPCF ) then
      call PCF2Hdr( physical_filename, hdfVersion, filetype=filetype )
d1192 1
a1192 1
    returnStatus = pgs_met_remove() 
d1194 1
a1194 1
    if ( present(metadata_error)) metadata_error=module_error
d1196 1
a1196 3
   if(switchDetail(switches, 'pro') > -1) then
       call announce_success(physical_filename, mcf_filename, 'standard')
   end if
d1198 13
a1210 11
  end subroutine Populate_metadata_std

  ! --------------------------------------  Populate_metadata_oth  -----

  subroutine Populate_metadata_oth ( HDF_FILE, MCF_FILE, &
    & NumQuantitiesPerFile, QuantityNames, l2metaData, hdfVersion, Metadata_error, &
    & filetype )

    ! This is specially to write meta data for heterogeneous files
    ! It should work unchanged for the 'OTH' l2gp files (e.g. ML2OTH.001.MCF)
    ! and, with minor changes, for the l2aux files 
d1216 3
a1218 21
    integer :: HDF_FILE, MCF_FILE, NumQuantitiesPerFile
    ! type(PCFData_T) :: L2pcf
    character (len=*), dimension(:) :: QuantityNames
    type (L2Metadata_T) :: l2metaData
    integer, optional, intent(out) :: Metadata_error
    integer, optional, intent(in) :: hdfVersion
    ! character(len=*), optional, intent(in)  :: filetype  ! 'sw' or 'hdf'
    integer, optional, intent(in)  :: filetype  ! 'sw' or 'hdf'

    !Local Variables

    integer :: HdfReturn
    integer :: ReturnStatus
    integer :: Sdid, hdf_sdid

    integer, parameter :: INVENTORY=2, ARCHIVE=1
    character (len=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: mcf_filename
    integer :: Version, Indx
    character (len=*), parameter :: METAWR_ERR = &
      & 'Error writing metadata attribute '
d1225 11
a1235 1
    character (len = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d1239 2
a1240 1
    integer, external :: PGS_MET_remove
d1243 2
a1245 3
    module_error = 0
    if ( present(metadata_error)) metadata_error=1
    if(.NOT. TOOLKIT) return
d1247 16
a1262 3
    version = 1
    if ( MCF_FILE > 0 ) then
      returnStatus = PGS_PC_GetReference (MCF_FILE, version , mcf_filename)
d1264 1
a1264 1
      returnStatus = PGSPC_W_NO_REFERENCE_FOUND
d1267 7
d1276 1
a1276 2
      & "Error: failed to find PCF ref for MCF_FILE in populate_metadata_oth.") 
      return
d1279 3
a1281 2
    version = 1
    returnStatus = PGS_PC_GetReference (HDF_FILE, version , physical_filename)
d1283 2
d1287 1
a1287 2
      & "Error: failed to find PCF ref for HDF_FILE in populate_metadata_oth.") 
      return
d1290 6
a1295 1
    call first_grouping(HDF_FILE, MCF_FILE, groups)
d1297 6
a1302 1
    do indx=1, numquantitiesperfile
d1304 1
a1304 2
      call measured_parameter (HDF_FILE, &
        & QuantityNames(indx), groups, indx)
d1306 24
a1329 1
    end do
d1331 1
a1331 2
    call third_grouping (HDF_FILE, hdf_sdid, groups, &
      & hdfVersion, filetype, l2metaData)
d1333 1
a1333 6
    if ( SFINBETWEENSTARTEND ) then
      sdid = mls_sfstart (physical_fileName, DFACC_RDWR, &
        & hdfVersion=hdfVersion, addingMetaData=.true.)
    else
      sdid = hdf_sdid
    endif 
d1335 2
a1336 5
    if ( sdid == -1 ) then
      call announce_error ( 0, &
      & "Error: failed to open the hdf file: "//TRIM(physical_fileName))
      return
    end if
d1338 1
a1338 6
    hdfReturn = mls_sfend( sdid, hdfVersion=hdfVersion, addingMetadata=.true. )
    if ( hdfReturn /= 0 ) then
        call announce_error ( 0, &
        & "Error: metadata mls_sfend in populate_metadata_oth.", &
        & error_number=hdfReturn) 
    end if
d1340 23
a1362 1
! Annotate the file with the PCF
a1363 4
    if ( ANNOTATEWITHPCF ) then
      call PCF2Hdr( physical_filename, hdfVersion, filetype=filetype )
      ! & hdfVersion, isHDFEOS)
    end if
d1365 1
a1365 1
    returnStatus = pgs_met_remove() 
d1367 2
a1368 1
    if ( present(metadata_error)) metadata_error=module_error
d1370 4
a1373 3
   if(switchDetail(switches, 'pro') > -1) then
       call announce_success(physical_filename, mcf_filename, 'others')
   end if
d1375 4
a1378 1
  end subroutine Populate_metadata_oth
d1380 1
a1380 1
  ! -----------------------------------------------  Get_l2gp_mcf  -----
d1382 11
a1392 1
  subroutine Get_l2gp_mcf ( File_base, meta_name, Mcf, Version )
a1393 8
  ! metadata configuration file (mcf) PCF number corresponding to l2gp number
  ! sdid
  ! Arguments
    character(len=*), intent(in) ::  File_base
    character(len=*), intent(in) ::  meta_name
    integer, intent(in), optional :: Version
    integer, intent(inout) ::        Mcf
    ! type(PCFData_T) :: l2pcf
d1395 1
a1395 4
    ! Local
    character (len=PGSd_PC_FILE_PATH_MAX) :: Sd_full
    !character (len=NameLen) :: Sd_path
    character (len=NameLen) :: Sd_name
d1397 4
a1400 4
    character (len=PGSd_PC_FILE_PATH_MAX) :: Mcf_full
    character (len=NameLen) :: Mcf_path
    character (len=NameLen) :: Mcf_name
    integer :: ReturnStatus, MyVersion, I
d1402 4
a1405 1
    character (len=1), parameter :: COMMA = ','
d1407 4
a1410 3
    ! Find species name
    ! assume sd_name is "*l2gp_species_"
    ! hence enclosed between "_" chars after an l2gp
d1412 3
a1414 3
    character (len=1), parameter :: Species_delimiter = '_'
    character (len=4), parameter :: L2gp = 'l2gp'
    logical, parameter :: DEBUG = .false.
d1416 8
a1423 1
    ! Begin
d1425 4
a1428 4
    if(.NOT. TOOLKIT) then
      mcf=0
      return
   endif
d1430 13
a1442 3
    if ( MCFFORL2GPOPTION == 1 ) then
      mcf = mcf+1
      return
d1445 13
a1457 5
    if ( DEBUG ) then
      call output('file_base: ', advance='no')
      call output(trim(file_base), advance='yes')
      call output('meta_name: ', advance='no')
      call output(trim(meta_name), advance='yes')
d1460 6
a1465 3
    if ( len(TRIM(file_base)) <= 0 ) then
      mcf=0
      return
d1468 7
a1474 7
    if ( meta_name == ' ' ) then
      ! * The following complication is attempting to infer
      ! * the species name based on the file name
      ! * It is necessary only if you disdained to specify the metaName
      ! * field in the output command
      ! Get full file name for typical MCF file
      do i=mlspcf_mcf_l2gp_start, mlspcf_mcf_l2gp_end
d1476 8
a1483 5
        if ( present(version) ) then
          myVersion=version
        else
          myVersion = 1
        end if
d1485 1
a1485 1
        returnStatus = PGS_PC_GetReference(i, myVersion , mcf_full)
d1487 12
a1498 3
        if ( returnStatus == PGS_S_SUCCESS ) then 
          exit
        end if
d1500 1
a1500 1
      end do
d1502 7
a1508 4
      if ( DEBUG ) then
        call output('returnStatus: ', advance='no')
        call output(returnStatus, advance='yes')
      end if
d1510 1
a1510 4
      if ( returnStatus /= PGS_S_SUCCESS ) then 
        mcf = 0
        return
      end if
d1512 7
a1518 1
      ! Split full_file_names into path+name
d1520 12
a1531 1
      call split_path_name ( mcf_full, mcf_path, mcf_name )
d1533 1
a1533 7
      ! If   text matching not case sensitive, shift to lower case
      if ( .NOT. MCFCASESENSITIVE ) then
        sd_full = LowerCase(file_base)
        mcf_name = LowerCase(mcf_name)
      else
        sd_full = file_base
      end if
d1535 7
a1541 8
      if ( DEBUG ) then
        call output('mcf_full: ', advance='no')
        call output(trim(mcf_full), advance='yes')
        call output('mcf_path: ', advance='no')
        call output(trim(mcf_path), advance='yes')
        call output('mcf_name: ', advance='no')
        call output(trim(mcf_name), advance='yes')
      end if
d1543 6
a1548 8
      ! Either we were given a short version of the sd_full
      ! e.g., 'h2o', or else a much longer one like 'mls-aura_...'
      if ( index(sd_full, 'mls-aura_') > 0 ) then
        ! Get species name assuming e.g. 'mls-aura_l2gp-h2O_'
        call ExtractSubString(sd_full, sd_name, 'mls-aura_l2gp-', '_')
      else
        sd_name = sd_full
      endif
d1550 7
a1556 6
      if ( DEBUG ) then
        call output('sd_full: ', advance='no')
        call output(trim(sd_full), advance='yes')
        call output('sd_name: ', advance='no')
        call output(trim(sd_name), advance='yes')
      end if
d1558 7
a1564 92
      if ( len(trim(sd_name)) <= 0 ) then
        mcf=0
        return
      end if

      if ( MCFFORL2GPOPTION == 3 ) then

        ! get mcfspecies name from associative array
        ! if the species name not found in spec_keys, it will return ','
        call GetHashElement ( l2pcf%spec_keys, l2pcf%spec_hash, &
          & trim(sd_name), sd_full, .TRUE. )

        if ( DEBUG ) then
          call output('keys: ', advance='no')
          call output(trim(l2pcf%spec_keys), advance='yes')
          call output('hash: ', advance='no')
          call output(trim(l2pcf%spec_hash), advance='yes')
          call output('hash for species name: ', advance='no')
          call output(trim(sd_full), advance='yes')
        end if

        if ( trim(sd_full) == COMMA ) then
          mcf = 0
          return
        end if

        sd_name = trim(sd_full)

      end if
   elseif ( .NOT. MCFCASESENSITIVE ) then
     sd_name = Lowercase(meta_name)
   else
     sd_name = meta_name
   endif
   ! Now try to find mcf file corresponding to species name   
   ! assuming, e.g. '*h2o.*'                                  
   if ( DEBUG ) then                                       
     call output('Trying for a pcf name matching: ', advance='no')                   
     call output(trim(sd_name), advance='yes')     
   end if                                                  
   mcf = GetPCFromRef(trim(sd_name), &
    & mlspcf_mcf_l2gp_start, mlspcf_mcf_l2gp_end, &
    & MCFCASESENSITIVE, returnStatus)

   if ( returnStatus /= 0 ) then
     mcf = 0
   endif

  end subroutine Get_l2gp_mcf

! Lori's routines

  ! -----------------------------------------------  WriteMetaLog  -----
  subroutine WriteMetaLog ( Metadata_error )

    ! Brief description of subroutine
    ! This subroutine writes metadata for the log file to a separate ASCII file.

    ! Arguments

    ! type( PCFData_T ), intent(in) :: Pcf
    integer, optional, intent(out) :: Metadata_error

    ! Parameters
    ! These are PCF numbers that *must* be in the PCF file

    integer, parameter :: ASCII_FILE = 101
    integer, parameter :: THE_LOG_FILE = 100

    ! Functions

    integer, external :: PGS_MET_init, PGS_MET_remove
    integer, external :: PGS_MET_setattr_s, PGS_MET_write
    integer, external :: PGS_PC_getconfigdata

    ! Internal

    character (len=1) :: NullStr
    character (len=45) :: Sval
    character (len=32) :: Mnemonic
    character (len=FileNameLen) :: Physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: mcf_filename
    character (len=480) :: Msg, Msr
    character (len=PGSd_MET_GROUP_NAME_L) :: Groups(PGSd_MET_NUM_OF_GROUPS)

    integer :: Result, Indx, Version
    logical, parameter :: DEBUG=.FALSE.

    ! Begin
    module_error = 0
    if ( present(metadata_error)) metadata_error=1
    if(.NOT. TOOLKIT) return
d1566 7
a1572 1
    nullStr = ''
d1574 4
a1577 5
    version = 1
    result = PGS_PC_GetReference (mlspcf_mcf_l2log_start, version, &
      & mcf_filename)

    if ( result /= PGS_S_SUCCESS ) then
d1579 1
a1579 2
        & "Error: failed to find PCF ref for Log mcf in WriteMetaLog.") 
      return
d1582 3
a1584 3
    ! Check that the PCF file contains the entries for the ASCII file
    ! and for the log file itself
    result = pgs_pc_getconfigdata (ASCII_FILE, physical_filename)
d1586 4
a1589 1
    if ( result /= PGS_S_SUCCESS ) then
d1591 1
a1591 2
        & "Error: failed to find PCF ref for the ASCII in WriteMetaLog.") 
      return
d1594 3
a1596 4
    version = 1
    result = PGS_PC_GetReference (THE_LOG_FILE, version , physical_filename)

    if ( result /= PGS_S_SUCCESS ) then
d1598 1
a1598 2
        & "Error: failed to find PCF ref for the Log in WriteMetaLog.") 
      return
d1601 5
a1605 4
! Initialize the MCF file

    if ( DEBUG ) then
      call output('Initialize the MCF file', advance='yes')
d1608 3
a1610 2
    result = pgs_met_init(mlspcf_mcf_l2log_start, groups)
    if ( result /= PGS_S_SUCCESS ) then
d1612 1
a1612 2
      & "metadata initialization error in WriteMetaLog.") 
      return
d1615 1
a1615 1
! Set PGE values
d1617 4
a1620 24
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalGranuleID", &
                               l2pcf%logGranID)

    sval = 'c' // l2pcf%cycle
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalVersionID", &
                               sval)

    indx = INDEX (l2pcf%startUTC, "T")

    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                               "RangeBeginningDate", l2pcf%startUTC(1:indx-1))
!    sval= '00:00:00.000000'
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                               "RangeBeginningTime", l2pcf%startUTC(indx+1:))
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                               "RangeEndingDate", l2pcf%endUTC(1:indx-1))
!    sval= '23:59:59.999999'
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                               "RangeEndingTime", l2pcf%endUTC(indx+1:))

    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "PGEVersion", &
                               l2pcf%PGEVersion)

    if ( result /= PGS_S_SUCCESS ) then
d1622 1
a1622 3
      & "Error in setting PGEVersion attribute in WriteMetaLog.", &
      &  error_number=result)
        return
d1625 2
a1626 1
    ! Write the metadata and their values to an ASCII file
d1628 3
a1630 3
    if ( DEBUG ) then
      call output('Write the metadata and their values to an ASCII file', &
      &  advance='yes')
d1633 1
a1633 1
    result = pgs_met_write(groups(1), nullStr, ASCII_FILE)
d1635 14
a1648 5
    if ( result /= PGS_S_SUCCESS ) then
       call Pgs_smf_getMsg(result, mnemonic, msg)
       msr = "Error: failed to write metadata in WriteMetaLog." &
       & // trim(mnemonic) // ':  ' // trim(msg)
       CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
d1651 7
a1657 1
    result = pgs_met_remove()
d1659 2
a1660 1
    if ( present(metadata_error)) metadata_error=module_error
d1662 1
a1662 3
   if(switchDetail(switches, 'pro') > -1) then
       call announce_success(physical_filename, mcf_filename, 'Log')
   end if
d1664 10
a1673 6
   end subroutine WriteMetaLog

  ! ----------------------------------------NullifyPCFData -----
  subroutine NullifyPCFData ( P )
    ! Given a PCFData, nullify all the pointers associated with it
    type ( PCFData_T ), intent(out) :: P
d1676 41
a1716 107
    nullify ( p%AnText )
    ! nullify ( p%L1BRADPCFIds )
  end subroutine NullifyPCFData

  ! ---------------------------------------- PCF2Hdr -----
  ! Make sure file type will be recognized
  ! before calling writePCF2Hdr
  ! (which only knows l_hdf, l_hdfeos, l_swath)
  subroutine PCF2Hdr( filename, hdfVersion, filetype )
    ! Args
    character(len=*), intent(in)  :: filename
    integer, optional, intent(in) :: hdfVersion
    integer, optional, intent(in) :: fileType
    ! Internal variables
    integer :: myType
    ! Executable
    if ( .not. associated(l2pcf%anText) ) return
    myType = l_hdf
    if ( present(filetype) ) then
      myType = filetype
      select case(filetype)
      case (l_l2dgg,l_l2gp)
        myType = l_swath
      ! case default
        ! myType = filetype
      end select
    endif
    call writePCF2Hdr( filename, l2pcf%anText, hdfVersion, myType )

  end subroutine PCF2Hdr

  ! ---------------------- Private procedures ------------

  ! ---------------------------------------------  announce_success  -----
  subroutine announce_success ( Name, mcf, l2_type )
    character(LEN=*), intent(in) :: Name
    character(LEN=*), intent(in) :: mcf
    character(LEN=*), intent(in) :: l2_type

    call output ( 'Level 2 output product metadata type : ' )
    call output ( trim(l2_type), advance='yes')
    call blanks(15)
    call output ( 'name : ' )
    call blanks(8)
    call output ( trim(Name), advance='yes')
    call blanks(15)
    call output ( 'mcf name : ' )
    call blanks(8)
    call output ( trim(mcf), advance='yes')

  end subroutine announce_success

  ! ------------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( lcf_where, full_message, use_toolkit, &
    & error_number )

    ! Arguments

    integer, intent(in) :: Lcf_where
    character(LEN=*), intent(in) :: Full_message
    logical, intent(in), optional :: Use_toolkit
    integer, intent(in), optional :: Error_number

    ! Local
    logical :: Just_print_it
    logical, parameter :: Default_output_by_toolkit = .true.
    character (LEN=132) :: attrname, errmsg
    integer :: Toolbox_error_num

    just_print_it = .not. default_output_by_toolkit
    if ( present(use_toolkit) ) just_print_it = .not. use_toolkit

    if ( .not. just_print_it ) then
      if ( TOOLKIT ) module_error = 1
      call output ( '***** At ' )

      if ( lcf_where > 0 ) then
        call print_source ( source_ref(lcf_where) )
      else
        call output ( '(no lcf node available)' )
      end if

      call output ( " Caused the following error:", advance='yes', &
       & from_where=ModuleName)
      call output ( trim(full_message), advance='yes', &
        & from_where=ModuleName)
      if ( present(error_number) ) then
        call output ( 'Error number ', advance='no' )
        call output ( error_number, places=9, advance='yes' )
        Toolbox_error_num = error_number
        call Pgs_smf_getMsg (Toolbox_error_num, attrname, errmsg)
        call MLSMessage (MLSMSG_WARNING, ModuleName, &
            &  TRIM(attrname) //' ' // TRIM(errmsg) )
      end if
    else
      call output ( '***Error in module ' )
      call output ( ModuleName, advance='yes' )
      call output ( trim(full_message), advance='yes' )
      if ( present(error_number) ) then
        call output ( 'Error number ' )
        call output ( error_number, advance='yes' )
      end if
    end if

!===========================
  end subroutine Announce_Error
!===========================
d1721 1
a1721 1
       "$Id: write_meta.f90,v 2.71 2013/04/12 00:06:35 pwagner Exp $"
d1730 3
@


2.71
log
@Added addToMetadata
@
text
@d749 1
a749 1
      hdfReturn = mls_sfend(hdf_sdid, hdfVersion=hdfVersion)
d858 1
a858 1
    hdfReturn = mls_sfend(sdid, hdfVersion=hdfVersion)
d981 1
a981 1
    hdfReturn = mls_sfend(sdid, hdfVersion=hdfVersion)
d1443 1
a1443 1
       "$Id: write_meta.f90,v 2.70 2011/07/12 22:35:03 honghanh Exp $"
d1452 3
@


2.70
log
@Change l_grid to l_hdfeos
@
text
@d46 2
a47 2
  public :: Populate_metadata_std, Populate_metadata_oth, &
    & Get_l2gp_mcf, WriteMetaLog, NullifyPCFData
d131 6
d148 66
d1363 2
d1443 1
a1443 1
       "$Id: write_meta.f90,v 2.69 2011/06/29 21:52:53 pwagner Exp $"
d1452 3
@


2.69
log
@no metadata is always an error now
@
text
@d1267 1
a1267 1
  ! (which only knows l_hdf, l_grid, l_swath)
d1369 1
a1369 1
       "$Id: write_meta.f90,v 2.68 2011/05/09 18:28:30 pwagner Exp $"
d1378 3
@


2.68
log
@Converted to using switchDetail
@
text
@d22 1
a22 1
  use MLSL2OPTIONS, only: PENALTY_FOR_NO_METADATA, TOOLKIT, SHAREDPCF
d1331 1
a1331 1
      module_error = max(module_error,PENALTY_FOR_NO_METADATA)
d1369 1
a1369 1
       "$Id: write_meta.f90,v 2.67 2009/06/23 18:46:19 pwagner Exp $"
d1378 3
@


2.67
log
@Prevent Intel from optimizing ident string away
@
text
@d16 2
a17 2
  use Hdf, only: DFACC_RDWR
  use INIT_TABLES_MODULE, only: l_l2dgg, l_l2gp, l_hdf, L_SWATH
d19 13
a31 12
  use MLSCommon, only: FileNameLen, NameLen, R8, L2Metadata_T
  use MLSFiles, only: GetPCFromRef, mls_sfstart, mls_sfend, Split_path_name
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA, TOOLKIT, SHAREDPCF
  use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
  use MLSPCF2, only: Mlspcf_mcf_l2gp_end, Mlspcf_mcf_l2gp_start, &
    & Mlspcf_mcf_l2log_start
  use MLSStrings, only: LowerCase
  use MLSStringLists, only: GetHashElement, ExtractSubString
  use Output_m, only: Output, blanks
  use PCFHdr, only: WriteInputPointer, WritePCF2Hdr, GlobalAttributes
  use SDPToolkit, only: PGSd_MET_GROUP_NAME_L, &
    & PGSd_MET_NUM_OF_GROUPS, PGSd_PC_FILE_PATH_MAX, PGS_PC_GetReference, &
d33 1
a33 1
  use TOGGLES, only: switches
d42 1
a42 1
       "$RCSfile: $"
d803 1
a803 1
   if(index(switches, 'pro') /= 0) then
d927 1
a927 1
   if(index(switches, 'pro') /= 0) then
d1248 1
a1248 1
   if(index(switches, 'pro') /= 0) then
d1369 1
a1369 1
       "$Id: read_apriori.f90 is it here $"
d1378 3
@


2.66
log
@Add NRT Lat and Lon bounding to metadata
@
text
@d41 1
a41 1
       "$RCSfile: write_meta.f90,v $"
d1365 1
a1366 1
!---------------------------- RCS Ident Info -------------------------------
d1368 2
a1369 3
       "$Id: write_meta.f90,v 2.65 2008/05/02 00:33:53 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1371 1
d1373 1
d1377 3
@


2.65
log
@Delete unused symbol
@
text
@d19 1
a19 1
  use MLSCommon, only: FileNameLen, NameLen, R8
d21 1
a21 1
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA, TOOLKIT
d358 1
a358 1
    & hdfVersion, filetype )
d400 1
d567 7
d575 1
a575 1
     dval = -180.0
d583 1
a583 1
     dval = 90.0
d591 1
a591 1
     dval = 180.0
d599 1
a599 1
     dval = -90.0
d691 1
a691 1
    & Field_name, hdfVersion, Metadata_error, &
d709 1
d769 1
a769 1
      & hdfVersion, filetype)
d811 1
a811 1
    & NumQuantitiesPerFile, QuantityNames, hdfVersion, Metadata_error, &
d825 1
d893 1
a893 1
      & hdfVersion, filetype)
d1368 1
a1368 1
       "$Id: write_meta.f90,v 2.64 2008/02/22 21:37:05 pwagner Exp $"
d1376 3
@


2.64
log
@DGG file was hybrid by default; now it will be pure HDFEOS
@
text
@d17 1
a17 1
  use INIT_TABLES_MODULE, only: l_l2aux, l_l2dgg, l_l2gp, l_hdf, L_SWATH
d1358 1
a1358 1
       "$Id: write_meta.f90,v 2.63 2007/12/07 01:50:32 pwagner Exp $"
d1366 3
@


2.63
log
@Removed unused dummy variables, etc.
@
text
@d17 1
a17 1
  use INTRINSIC, only: L_SWATH
d786 1
a786 2
      call writePCF2Hdr(physical_filename, l2pcf%anText, &
     & hdfVersion, filetype=filetype)
d908 1
a908 2
      call writePCF2Hdr(physical_filename, l2pcf%anText, &
      & hdfVersion, filetype=filetype)
d1253 27
d1358 1
a1358 1
       "$Id: write_meta.f90,v 2.62 2007/06/21 00:54:08 vsnyder Exp $"
d1366 3
@


2.62
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d17 1
a17 3
  use HDFEOS5, only: HE5_SWATTACH, HE5_SWDETACH, &
    & HE5_SWCLOSE
  use INTRINSIC, only: L_GRID, L_HDF, L_HDFEOS, L_SWATH
d20 1
a20 2
  use MLSFiles, only: GetPCFromRef, mls_sfstart, mls_sfend, Split_path_name, &
   &  mls_hdf_version, HDFVERSION_5, mls_io_gen_openF
d22 1
a22 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d28 1
a28 3
  use PCFHdr, only: INPUTPTR_STRING_LENGTH, &
    & InputInputPointer, WriteInputPointer, WritePCF2Hdr, &
    & GlobalAttributes
d183 1
a183 1
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
a282 1
    integer :: record_length, file_id, sw_id
d288 1
a288 1
    integer, external :: PGS_MET_setattr_d, &
a385 1
    !    USE InitPCFs, ONLY: L2PCF
a390 1
    ! type(PCFData_T) :: l2pcf
a398 1
    ! character(len=*), optional, intent(in)  :: filetype  ! 'sw' or 'hdf'
d411 1
a411 3
    integer :: version, indx, i
    CHARACTER (LEN=INPUTPTR_STRING_LENGTH) :: inpt(31)
    ! CHARACTER (LEN=6) :: inptptr_filetype
a511 3
!       call InputInputPointer(inpt, &
!         & (/ L2pcf%L1BOAPCFId, L2pcf%L1BRADPCFIds(:) /) )
!       returnStatus = WriteInputPointer(groups(INVENTORY), attrName, inpt)
a514 2
      ! returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
      !     INPUTPOINTERMESG)
a684 1
    ! & isHDFEOS )
a699 1
    ! type(PCFData_T)                :: L2pcf
a702 1
    ! character(len=*), optional, intent(in)  :: filetype  ! 'sw' or 'hdf'
a703 1
    ! logical, optional, intent(in)  :: isHDFEOS
a709 2
    character (len=132) :: attrname, errmsg
    CHARACTER (LEN=98) :: inpt(31)
d727 1
a727 3
    integer, external :: PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, &
      &  PGS_MET_write, PGS_MET_remove
a826 1
    character (len=132) :: Attrname, Errmsg
d844 1
a844 3
    integer, external :: PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, &
      &  PGS_MET_write, PGS_MET_remove
d1121 1
a1121 1
    integer, external :: PGS_MET_init, PGS_MET_remove, PGS_MET_setattr_d
d1333 1
a1333 1
       "$Id: write_meta.f90,v 2.61 2006/03/15 23:52:24 pwagner Exp $"
d1341 3
@


2.61
log
@Removed InputVersion component from PCF, l2cf
@
text
@d120 1
a120 1
    ! the following is a comma-delimited list of possible 	
d771 1
a771 1
		
d780 1
a780 1
		
d810 1
a810 1
	call writePCF2Hdr(physical_filename, l2pcf%anText, &
d885 1
a885 1
	
d936 1
a936 1
	call writePCF2Hdr(physical_filename, l2pcf%anText, &
d983 1
a983 1
	
d1017 1
a1017 1
	        myVersion=version
d1019 1
a1019 1
	        myVersion = 1
d1025 1
a1025 1
	        exit
d1043 1
a1043 1
	
d1081 1
a1081 1
	
d1360 1
a1360 1
       "$Id: write_meta.f90,v 2.60 2006/02/21 19:12:00 pwagner Exp $"
d1368 3
@


2.60
log
@GetHashElement is now a generic
@
text
@a61 4
    ! version string in PCF input file names

    character (len=15) :: InputVersion ! input files (but which?)

d1360 1
a1360 1
       "$Id: write_meta.f90,v 2.59 2005/07/21 23:45:03 pwagner Exp $"
d1368 3
@


2.59
log
@Removed unused l1b fileinfo fields from l2pcf
@
text
@d29 1
a29 1
  use MLSStringLists, only: GetStringHashElement, ExtractSubString
d1090 1
a1090 1
        call GetStringHashElement ( l2pcf%spec_keys, l2pcf%spec_hash, &
d1364 1
a1364 1
       "$Id: write_meta.f90,v 2.58 2005/06/22 18:57:02 pwagner Exp $"
d1372 3
@


2.58
log
@Reworded Copyright statement, moved rcs id
@
text
@d24 1
a24 2
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA, TOOLKIT, &
    & ILLEGALL1BRADID
d46 1
a46 1
       "$RCSfile: $"
d134 2
a135 2
    INTEGER :: L1BOAPCFId=0  ! The PCF ID for the L1BOA file
    INTEGER, DIMENSION(:), POINTER :: L1BRADPCFIds => NULL()
d527 5
a531 3
      call InputInputPointer(inpt, &
        & (/ L2pcf%L1BOAPCFId, L2pcf%L1BRADPCFIds(:) /) )
      returnStatus = WriteInputPointer(groups(INVENTORY), attrName, inpt)
d1283 1
a1283 1
    nullify ( p%L1BRADPCFIds )
d1364 1
a1364 1
       "$Id: $"
d1372 3
@


2.57
log
@ReprocessingActual field dropped from product metadata
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d45 3
a47 5
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: IdParm = & 
     "$Id: write_meta.f90,v 2.56 2005/01/14 21:37:30 pwagner Exp $"
  character(len=len(idParm)) :: Id = idParm
  character(len=*), parameter :: ModuleName="$RCSfile: write_meta.f90,v $"
d49 1
a49 1
  !-----------------------------------------------------------------------------
d1361 5
d1371 3
@


2.56
log
@ch3cn now has mcf, so special treatment lifted
@
text
@d39 1
a39 1
     "$Id: write_meta.f90,v 2.55 2004/12/15 23:34:32 pwagner Exp $"
a153 1
    ! ReProcessingActual
a217 9
    attrName = 'ReprocessingActual'
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'unknown')
         ! 'processed once')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing ReprocessingActual attribute." )
    end if

d1360 3
@


2.55
log
@Change REPROCESSINGACTUAL to unknown; light housecleaning
@
text
@d39 1
a39 1
     "$Id: write_meta.f90,v 2.54 2004/12/14 21:41:53 pwagner Exp $"
a1083 9
      ! quick and dirty fixed for certain l2gp species without mcf
      ! Correct solution will require changes to l2/directWrite
      ! lib/l2gpData and unknown fragment l2/l2cf/lib

      if ( trim(sd_name) == 'ch3cn' ) then
	     mcf = -999
	     return
      end if

d1370 3
@


2.54
log
@Repaired double-0 cycle; automaticQ.. and OperationalQ.. shifted to mcf
@
text
@d8 1
a8 1
  use Hdf, only: DFACC_RDWR   ! , Sfend, Sfstart
d29 1
a29 6
    & PGSPC_W_NO_REFERENCE_FOUND, PGS_S_SUCCESS, PGSMET_W_METADATA_NOT_SET, &
    & WARNIFCANTPGSMETREMOVE !, &
!    & PGS_PC_getconfigdata, &
!    & PGS_MET_init, PGS_MET_setattr_d, &
!      &  PGS_MET_setAttr_s, PGS_MET_setattr_i, &
!      &  PGS_MET_write, PGS_MET_remove
d39 1
a39 1
     "$Id: write_meta.f90,v 2.53 2004/08/04 23:19:58 pwagner Exp $"
d221 2
a222 1
         'processed once')
a244 1
    ! call expandFileTemplate ( '$cycle', sval, cycle=l2pcf%cycle )
a344 34
    ! You should delete them in the next version

!     attrName = 'AutomaticQualityFlag' // '.' // class
!     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
!          'Passed')
!     if ( returnStatus /= PGS_S_SUCCESS ) then
!       call announce_error ( 0, &
!         & "Error in writing AutomaticQualityFlag attribute." )
!     end if
! 
!     attrName = 'AutomaticQualityFlagExplanation' // '.' // class
!     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
!          'pending algorithm update')
!     if ( returnStatus /= PGS_S_SUCCESS ) then
!       call announce_error ( 0, &
!         & "Error in writing AutomaticQualityFlagExplanation attribute." )
!     end if
! 
!     attrName = 'OperationalQualityFlag' // '.' // class
!     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
!          'Not Investigated')
!     if ( returnStatus /= PGS_S_SUCCESS ) then
!       call announce_error ( 0, &
!       & "Error in writing OperationalQualityFlag attribute." )
!     end if
! 
!     attrName = 'OperationalQualityFlagExplanation' // '.' // class
!     returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
!          'Not Investigated')
!     if ( returnStatus /= PGS_S_SUCCESS ) then
!       call announce_error ( 0, &
!         & "Error in writing OperationalQualityFlagExplanation attribute.") 
!     end if
! 
a663 1
!    hdf_sdid = sfstart (physical_fileName, DFACC_RDWR) 
a689 1
!    hdfReturn = sfend(hdf_sdid)
a698 5
      ! if (returnStatus /= PGS_S_SUCCESS .and. WARNIFCANTPGSMETREMOVE) THEN 
      !  write(sval, *) returnStatus
      !  CALL MLSMessage (MLSMSG_Warning, ModuleName, &
      !        "Calling pgs_met_remove() failed with value " // trim(sval) )
      ! endif          
a792 1
!    sdid = sfstart (physical_fileName, DFACC_RDWR) 
a821 5
    ! if ( returnStatus /= 0 .and. WARNIFCANTPGSMETREMOVE ) then
    !    write(errmsg, *) returnStatus
    !    CALL MLSMessage (MLSMSG_Warning, ModuleName, &
    !          "Calling pgs_met_remove() failed with value " // trim(errmsg) )
    ! end if
a919 1
!    sdid = sfstart (physical_fileName, DFACC_RDWR) 
a932 16
!    returnStatus = pgs_met_write (groups(INVENTORY), "coremetadata.0", sdid)

!    if ( returnStatus /= PGS_S_SUCCESS .AND. &
!         returnStatus /= PGSMET_W_METADATA_NOT_SET ) then 
!      if ( returnStatus == PGSMET_W_METADATA_NOT_SET ) then 
!        call announce_error ( 0, &
!        & "Error: Some of the mandatory parameters were not set in populate_metadata_oth.")
!      else
!        call Pgs_smf_getMsg (returnStatus, attrname, errmsg)
!        call MLSMessage (MLSMSG_WARNING, ModuleName, &
!             "Metadata write failed in populate_metadata_oth " &
!             & //trim(attrname)//trim(errmsg))
!      end if
!    end if

!    hdfReturn = sfend(sdid)
a948 8
    ! if ( returnStatus /= 0 .and. WARNIFCANTPGSMETREMOVE ) then
        ! call announce_error ( 0, &
        ! & "Error: metadata removal in populate_metadata_oth.", &
        ! & error_number=hdfReturn) 
    !    write(errmsg, *) returnStatus
    !    CALL MLSMessage (MLSMSG_Warning, ModuleName, &
    !          "Calling pgs_met_remove() failed with value " // trim(errmsg) )
    ! end if
a1071 1
        !call split_path_name(sd_full, sd_path, sd_name, species_delimiter)
a1079 2
        ! call output('sd_path: ', advance='no')
        ! call output(trim(sd_path), advance='yes')
a1234 1
    ! call expandFileTemplate('$cycle', sval, cycle=l2pcf%cycle)
a1278 10
    ! if ( result /= 0 .and. WARNIFCANTPGSMETREMOVE ) then
        ! call announce_error ( 0, &
        ! & "Error: metadata removal in WriteMetaLog.", &
        ! & error_number=result) 
    !  if (result /= PGS_S_SUCCESS) THEN 
    !    write(sval, *) result
    !    CALL MLSMessage (MLSMSG_Warning, ModuleName, &
    !          "Calling pgs_met_remove() failed with value " // trim(sval) )
    !  endif          
    ! end if
a1297 111
  ! -----------------------------------------  ExpandFileTemplate  -----
   subroutine ExpandFileTemplate ( Template, Filename, Level, Version, Cycle, &
     &                            Day )

     ! Brief description of subroutine
     ! This subroutine expands the version, cycle, and day fields in a file
     ! name template.  Note: CYCLE is a STRING here, which is how it's read
     ! from the PCF.

     ! Arguments

     character (len=*), intent(in) :: Template

     character (len=*), intent(in), optional :: Cycle, Day, Level, Version

     character (len=*), intent(out) :: Filename

    ! Parameters

    ! Functions

    ! Variables

    character (len=4) :: Field, zCy

    integer :: I, iCy, Indx, NumFields

    ! Initializations

    numFields = 4

    fileName = template

    ! Loop through the expandable fields in the template

    do i = 1, numFields

      ! Search for $

      indx = INDEX(fileName,'$')

      ! Exit, if there are no expandable fields 

      if ( indx == 0) exit

      ! Match the field name to the input argument

      field = fileName(indx:indx+3)

      if ( field == '$lev' ) then

        if ( present(level) ) then
          fileName = fileName(:(indx-1)) // TRIM(level) // &
            &        fileName((indx+6):)
        else
          call MLSMessage(MLSMSG_Error, ModuleName, 'Input level &
            &required to expand the template.')
        end if

      else if ( field == '$ver' ) then

        if ( present(version) ) then
          fileName = fileName(:(indx-1)) // TRIM(version) // &
            &        fileName((indx+8):)
        else
          call MLSMessage(MLSMSG_Error, ModuleName, 'Input version &
            &required to expand the template.')
        end if

      else if ( field == '$cyc' ) then

        if ( present(cycle) ) then

        ! Convert from CHARACTER to INTEGER

          read ( cycle, '(I2)' ) iCy

          ! Add a leading zero, if less than 10

          if ( iCy < 10 ) then
            zCy = '0' // trim(cycle)
          else
            zCy = cycle
          end if

          fileName = fileName(:(indx-1)) // 'c' // TRIM(zCy) // &
                            fileName((indx+6):)

        else

          call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'Input cycle required to expand the template.')

        end if

      else if ( field == '$day' ) then

        if ( present(day) ) then
          fileName = fileName(:(indx-1)) // TRIM(day) // &
            &        fileName((indx+4):)
        else
          call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'Input day required to expand the template.')
        end if

      end if

    end do

   end subroutine ExpandFileTemplate

d1379 3
@


2.53
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d44 1
a44 1
     "$Id: write_meta.f90,v 2.52 2004/01/30 00:31:10 pwagner Exp $"
d249 2
a250 1
    call expandFileTemplate ( '$cycle', sval, cycle=l2pcf%cycle )
d349 2
d352 32
a383 32
    attrName = 'AutomaticQualityFlag' // '.' // class
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'Passed')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing AutomaticQualityFlag attribute." )
    end if

    attrName = 'AutomaticQualityFlagExplanation' // '.' // class
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'pending algorithm update')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing AutomaticQualityFlagExplanation attribute." )
    end if

    attrName = 'OperationalQualityFlag' // '.' // class
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'Not Investigated')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing OperationalQualityFlag attribute." )
    end if

    attrName = 'OperationalQualityFlagExplanation' // '.' // class
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'Not Investigated')
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
        & "Error in writing OperationalQualityFlagExplanation attribute.") 
    end if

d1315 2
a1316 1
    call expandFileTemplate('$cycle', sval, cycle=l2pcf%cycle)
d1581 3
@


2.52
log
@Stops useless warnings about pgs_met_remove return value
@
text
@d21 2
a22 1
  use MLSStrings, only: LowerCase, GetStringHashElement, ExtractSubString
d44 1
a44 1
     "$Id: write_meta.f90,v 2.51 2003/09/12 16:32:00 cvuu Exp $"
d1577 3
@


2.51
log
@Output the right orbit numbers for StartOrbitNumber and StopOrbitNumber
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d43 1
a43 1
     "$Id: write_meta.f90,v 2.50 2003/09/04 22:41:09 pwagner Exp $"
d736 5
a740 5
      if (returnStatus /= PGS_S_SUCCESS .and. WARNIFCANTPGSMETREMOVE) THEN 
        write(sval, *) returnStatus
        CALL MLSMessage (MLSMSG_Warning, ModuleName, &
              "Calling pgs_met_remove() failed with value " // trim(sval) )
      endif          
d865 5
a869 5
    if ( returnStatus /= 0 .and. WARNIFCANTPGSMETREMOVE ) then
        write(errmsg, *) returnStatus
        CALL MLSMessage (MLSMSG_Warning, ModuleName, &
              "Calling pgs_met_remove() failed with value " // trim(errmsg) )
    end if
d1014 1
a1014 1
    if ( returnStatus /= 0 .and. WARNIFCANTPGSMETREMOVE ) then
d1018 4
a1021 4
        write(errmsg, *) returnStatus
        CALL MLSMessage (MLSMSG_Warning, ModuleName, &
              "Calling pgs_met_remove() failed with value " // trim(errmsg) )
    end if
d1355 1
a1355 1
    if ( result /= 0 .and. WARNIFCANTPGSMETREMOVE ) then
d1359 6
a1364 6
      if (result /= PGS_S_SUCCESS) THEN 
        write(sval, *) result
        CALL MLSMessage (MLSMSG_Warning, ModuleName, &
              "Calling pgs_met_remove() failed with value " // trim(sval) )
      endif          
    end if
d1576 3
@


2.50
log
@Added some extra printing if metadata write fails in third_grouping
@
text
@d24 2
a25 1
    & InputInputPointer, WriteInputPointer, WritePCF2Hdr
d43 1
a43 1
     "$Id: write_meta.f90,v 2.49 2003/09/03 23:56:24 pwagner Exp $"
d470 1
d506 1
d509 8
a516 1
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 99999)
d520 1
a520 1
      & "Error in writing StartOrbitNumber attribute.") 
d524 8
a531 1
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 99999)
d535 1
a535 1
      & "Error in writing StopOrbitNumber attribute.") 
d1576 3
@


2.49
log
@Can get species name from trivial file name fragment
@
text
@d42 1
a42 1
     "$Id: write_meta.f90,v 2.48 2003/08/11 17:29:36 cvuu Exp $"
d699 4
d704 1
a704 1
        & "Error: metadata write failed in third_grouping.", &
d1559 3
@


2.48
log
@Change to output attributes StartOrbitNumber and StopOrbitNumber instead of OrbitNumber
@
text
@d42 1
a42 1
     "$Id: write_meta.f90,v 2.47 2003/08/01 20:25:08 pwagner Exp $"
d1120 9
a1128 3
      ! Get species name assuming e.g. 'mls-aura_l2gp-h2O_'
      !call split_path_name(sd_full, sd_path, sd_name, species_delimiter)
      call ExtractSubString(sd_full, sd_name, 'mls-aura_l2gp-', '_')
d1144 2
a1145 2
	mcf = -999
	return
d1555 3
@


2.47
log
@Removed ref to undefined sd_path
@
text
@d42 1
a42 1
     "$Id: write_meta.f90,v 2.46 2003/07/23 18:27:44 cvuu Exp $"
d489 2
d492 1
a492 1
    attrName = 'OrbitNumber' // '.1'
d495 13
a507 1
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, 999)
d510 1
a510 1
      & "Error in writing OrbitNumber attribute.") 
d513 7
a519 17
    ! Start, Stop orbit numbers: level one has actual calculated numbers
    ! but, for now at least, we'll not trouble
    !attrName = 'StartOrbitNumber' // '.1'
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, &
    !     -1)
    !if ( returnStatus /= PGS_S_SUCCESS ) then
    !  call announce_error ( 0, &
    !  & "Error in writing StartOrbitNumber attribute.") 
    !end if

    !attrName = 'StopOrbitNumber' // '.1'
    !returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, &
    !     -1)
    !if ( returnStatus /= PGS_S_SUCCESS ) then
    !  call announce_error ( 0, &
    !  & "Error in writing StopOrbitNumber attribute.") 
    !end if
d838 2
a839 1
    if ( ANNOTATEWITHPCF ) call writePCF2Hdr(physical_filename, l2pcf%anText, &
d841 1
d986 2
a987 1
    if ( ANNOTATEWITHPCF ) call writePCF2Hdr(physical_filename, l2pcf%anText, &
d990 1
d1549 3
@


2.46
log
@brought closer to James Johnson want to; quick and dirty fixed for CH3CN
@
text
@d42 1
a42 1
     "$Id: write_meta.f90,v 2.45 2003/07/07 23:48:18 pwagner Exp $"
d1015 1
a1015 1
! Local
d1017 1
a1017 1
    character (len=NameLen) :: Sd_path
d1119 2
a1120 2
        call output('sd_path: ', advance='no')
        call output(trim(sd_path), advance='yes')
d1541 3
@


2.45
log
@Changed in interfaces to make filetype a lit_name; l2pcf a saved variable
@
text
@d21 1
a21 1
  use MLSStrings, only: LowerCase, GetStringHashElement
d42 1
a42 1
     "$Id: write_meta.f90,v 2.44 2003/06/09 22:49:35 pwagner Exp $"
d491 3
a493 1
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, -1)
d501 15
a515 15
    attrName = 'StartOrbitNumber' // '.1'
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, &
         -1)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing StartOrbitNumber attribute.") 
    end if

    attrName = 'StopOrbitNumber' // '.1'
    returnStatus = pgs_met_setAttr_i (groups(INVENTORY), attrName, &
         -1)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, &
      & "Error in writing StopOrbitNumber attribute.") 
    end if
d581 5
d587 1
a587 1
          'Brightness Temperature')
d1112 3
a1114 2
      ! Get species name assuming e.g. '*l2gp_h2o'
      call split_path_name(sd_full, sd_path, sd_name, species_delimiter)
d1125 9
d1434 1
a1434 1
          fileName = fileName(:(indx-1)) // 'C' // TRIM(zCy) // &
d1541 3
@


2.44
log
@Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
@
text
@d11 1
d42 1
a42 1
     "$Id: write_meta.f90,v 2.43 2003/05/30 23:50:32 pwagner Exp $"
d144 1
d150 1
a150 1
  subroutine First_grouping ( HDF_FILE, MCF_FILE, L2pcf, Groups )
d169 1
a169 1
    type(PCFData_T) :: l2pcf
d406 1
a406 1
  subroutine Third_grouping ( HDF_FILE, hdf_sdid, L2pcf, Groups, &
d441 1
a441 1
    type(PCFData_T) :: l2pcf
d450 2
a451 1
    character(len=*), optional, intent(in)  :: filetype  ! 'sw' or 'hdf'
d465 2
a466 1
    CHARACTER (LEN=6) :: inptptr_filetype
d478 1
a478 1
    inptptr_filetype = 'sw'
d716 1
a716 1
    & L2pcf, Field_name, hdfVersion, Metadata_error, &
d734 1
a734 1
    type(PCFData_T)                :: L2pcf
d738 2
a739 1
    character(len=*), optional, intent(in)  :: filetype
d798 1
a798 1
    call first_grouping(HDF_FILE, MCF_FILE, l2pcf, groups)
d800 1
a800 1
    call third_grouping (HDF_FILE, hdf_sdid, l2pcf, groups, &
d847 1
a847 1
  subroutine Populate_metadata_oth ( HDF_FILE, MCF_FILE, L2pcf, &
d860 1
a860 1
    type(PCFData_T) :: L2pcf
d864 2
a865 1
    character(len=*), optional, intent(in)  :: filetype  ! 'sw' or 'hdf'
d922 1
a922 1
    call first_grouping(HDF_FILE, MCF_FILE, l2pcf, groups)
d931 1
a931 1
    call third_grouping (HDF_FILE, hdf_sdid, l2pcf, groups, &
d997 1
a997 1
  subroutine Get_l2gp_mcf ( File_base, meta_name, Mcf, L2pcf, Version )
d1006 1
a1006 1
    type(PCFData_T) :: l2pcf
d1170 1
a1170 1
  subroutine WriteMetaLog ( Pcf, Metadata_error )
d1177 1
a1177 1
    type( PCFData_T ), intent(in) :: Pcf
d1257 1
a1257 1
                               pcf%logGranID)
d1259 1
a1259 1
    call expandFileTemplate('$cycle', sval, cycle=pcf%cycle)
d1263 1
a1263 1
    indx = INDEX (PCF%startUTC, "T")
d1266 1
a1266 1
                               "RangeBeginningDate", PCF%startUTC(1:indx-1))
d1269 1
a1269 1
                               "RangeBeginningTime", PCF%startUTC(indx+1:))
d1271 1
a1271 1
                               "RangeEndingDate", PCF%endUTC(1:indx-1))
d1274 1
a1274 1
                               "RangeEndingTime", PCF%endUTC(indx+1:))
d1277 1
a1277 1
                               pcf%PGEVersion)
d1524 3
@


2.43
log
@Relies on lib/PCFHdr to know what mesg goes in InputPointer
@
text
@d15 1
a15 1
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA, CREATEMETADATA, &
d41 1
a41 1
     "$Id: write_meta.f90,v 2.42 2003/04/03 22:58:40 pwagner Exp $"
d769 1
a769 1
    if(.NOT. CREATEMETADATA) return
d892 1
a892 1
    if(.NOT. CREATEMETADATA) return
d1024 1
a1024 1
    if(.NOT. CREATEMETADATA) then
d1202 1
a1202 1
    if(.NOT. CREATEMETADATA) return
d1518 3
@


2.42
log
@Alias now set in lib/L2GPData instead of l2/write_meta
@
text
@d41 1
a41 1
     "$Id: write_meta.f90,v 2.41 2003/03/15 00:15:52 pwagner Exp $"
a49 3
  private :: First_grouping, Measured_parameter, Third_grouping, &
    & ExpandFileTemplate

a141 4
  ! What gets written if ANNOTATEWITHPCF instead of InputPointer
  character(len=*), private, parameter :: INPUTPOINTERMESG = &
    & '/HDFEOS/ADDITIONAL/FILE_ATTRIBUTES/PCF'  ! path to PCF attribute
  !  & 'See the PCF annotation to this file.'
d404 2
a405 1
  subroutine Third_grouping ( HDF_FILE, hdf_sdid, L2pcf, Groups, hdfVersion )
d448 1
d462 1
a462 1
!   CHARACTER (LEN=98) :: inpt(31)
a471 1
!   INTEGER, EXTERNAL :: pgs_pc_getUniversalRef
d474 2
d544 4
a547 2
      returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
           INPUTPOINTERMESG)
d795 2
a796 1
    call third_grouping (HDF_FILE, hdf_sdid, l2pcf, groups, hdfVersion)
a812 17
!    returnStatus = pgs_met_write (groups(INVENTORY), "coremetadata.0", sdid)

!    if ( returnStatus /= PGS_S_SUCCESS .AND. &
!         returnStatus /= PGSMET_W_METADATA_NOT_SET ) then 
!      if ( returnStatus == PGSMET_W_METADATA_NOT_SET ) then 
!        call announce_error ( 0, &
!        & "Error--some of the mandatory parameters were not set") 
!					return
!      else
!        call Pgs_smf_getMsg (returnStatus, attrname, errmsg)
!        call MLSMessage (MLSMSG_WARNING, ModuleName, &
!             "Metadata write failed in populate_metadata_std " &
!             & //trim(attrname)//trim(errmsg))
!      end if
!    end if

!    hdfReturn = sfend(sdid)
a823 1
     ! & hdfVersion, isHDFEOS=isHDFEOS)
a826 3
        ! call announce_error ( 0, &
        ! & "Error: metadata removal in populate_metadata_std.", &
        ! & error_number=hdfReturn) 
d925 2
a926 1
    call third_grouping (HDF_FILE, hdf_sdid, l2pcf, groups, hdfVersion)
d1518 3
@


2.41
log
@Wont quit if pgs_met_remove returns non-zero value
@
text
@d9 1
a9 1
  use HDFEOS5, only: HE5_SWATTACH, HE5_SWSETALIAS, HE5_SWDETACH, &
d41 1
a41 1
     "$Id: write_meta.f90,v 2.40 2003/03/11 00:21:36 pwagner Exp $"
d263 1
a263 2
  subroutine Measured_parameter ( HDF_FILE, Field_name, Groups, Class_num, &
    & setAlias )
a285 1
    logical, optional, intent(in) :: setAlias
a305 1
    logical :: mySetAlias
a306 3
    ! The following are for establishing soft links between field names & type2
    character(len=*), parameter :: TYPE2FIELDNAME = 'L2gpValue'
    character(len=*), parameter :: TYPE2PRECISIONNAME = 'L2gpPrecision'
a313 2
    mySetAlias = .false.
    if ( present(setAlias) ) mySetAlias = setAlias
d327 1
a327 41
    if ( mySetAlias ) then
      if ( mls_hdf_version(physical_filename) == HDFVERSION_5 ) then
        file_id = mls_io_gen_openF('sw', .true., returnStatus, &
          & record_length, FileAccessType, &
          & physical_filename, &
          & hdfVersion=HDFVERSION_5)
        if ( returnStatus /= PGS_S_SUCCESS ) then 
          call announce_error ( 0, &
            & "Error in opening file for setting alias." )
        end if
        sw_id = he5_swattach(file_id, trim(field_name))
        if ( sw_id < 1 ) then 
          call announce_error ( 0, &
            & "Error in attaching swath for setting alias." )
        end if
        returnStatus = he5_SWsetalias(sw_id, TYPE2FIELDNAME, trim(field_name))
        if ( returnStatus /= PGS_S_SUCCESS ) then 
          call announce_error ( 0, &
            & "Error in setting alias from " // TYPE2FIELDNAME // &
              & ' to ' // trim(field_name) )
        end if
        returnStatus = he5_SWsetalias(sw_id, TYPE2PRECISIONNAME, &
         & trim(field_name) // ' Precision')
        if ( returnStatus /= PGS_S_SUCCESS ) then 
          call announce_error ( 0, &
            & "Error in setting alias from " // TYPE2PRECISIONNAME // &
              & ' to ' // trim(field_name) // ' Precision' )
        end if
        returnStatus = he5_SWdetach(sw_id)
        if ( returnStatus /= PGS_S_SUCCESS ) then 
          call announce_error ( 0, &
            & "Error in detaching swath for setting alias." )
        end if
        returnStatus = he5_SWclose(file_id)
        if ( returnStatus /= PGS_S_SUCCESS ) then 
          call announce_error ( 0, &
            & "Error in closing file for setting alias." )
        end if
      endif
    endif

a328 2


d714 1
a714 1
    & L2pcf, Field_name, hdfVersion, Metadata_error, setAlias, &
a735 1
    logical, optional, intent(in)  :: setAlias
d796 1
a796 1
    call measured_parameter (HDF_FILE, field_name, groups, 1, setAlias)
d866 1
a866 2
    & setAlias, filetype )
    ! & setAlias, isHDFEOS )
a880 2
    logical, optional, intent(in)  :: setAlias
    ! logical, optional, intent(in)  :: isHDFEOS
d943 1
a943 1
        & QuantityNames(indx), groups, indx, setAlias)
d1539 3
@


2.40
log
@Interfaces fit new WritePCF2Hdr flixibility
@
text
@d26 2
a27 1
    & PGSPC_W_NO_REFERENCE_FOUND, PGS_S_SUCCESS, PGSMET_W_METADATA_NOT_SET !, &
d41 1
a41 1
     "$Id: write_meta.f90,v 2.39 2003/03/07 00:55:38 pwagner Exp $"
d752 5
d896 7
a902 4
    if ( returnStatus /= 0 ) then
        call announce_error ( 0, &
        & "Error: metadata removal in populate_metadata_std.", &
        & error_number=hdfReturn) 
d1047 7
a1053 4
    if ( returnStatus /= 0 ) then
        call announce_error ( 0, &
        & "Error: metadata removal in populate_metadata_oth.", &
        & error_number=hdfReturn) 
d1372 9
a1380 4
    if ( result /= 0 ) then
        call announce_error ( 0, &
        & "Error: metadata removal in WriteMetaLog.", &
        & error_number=result) 
d1593 3
@


2.39
log
@Set INPUTPOINTERMESG when annotating with PCF as a private param /HDFEOS/ADDITIONAL/FILE_ATTRIBUTES/PCF
@
text
@d40 1
a40 1
     "$Id: write_meta.f90,v 2.38 2003/02/27 21:54:28 pwagner Exp $"
d759 2
a760 1
    & isHDFEOS )
d781 2
a782 1
    logical, optional, intent(in)  :: isHDFEOS
d886 2
a887 1
     & hdfVersion, isHDFEOS=isHDFEOS)
d908 2
a909 1
    & setAlias, isHDFEOS )
d925 2
a926 1
    logical, optional, intent(in)  :: isHDFEOS
d1034 2
a1035 1
      & hdfVersion, isHDFEOS)
d1576 3
@


2.38
log
@Now annotates with PCF; does not set inputPointer
@
text
@d40 1
a40 1
     "$Id: write_meta.f90,v 2.37 2003/02/10 22:02:41 pwagner Exp $"
d144 4
a592 17
! >       inpt = ' '
! >       DO i = 0, size(L2pcf%L1BRADPCFIds)
! >         version = 1
! >         if ( i == 0 ) then
! >          returnStatus = pgs_pc_getUniversalRef(L2pcf%L1BOAPCFId, version, sval)
! >         elseif ( L2pcf%L1BRADPCFIds(i) /= ILLEGALL1BRADID ) then
! >          returnStatus = pgs_pc_getUniversalRef(L2pcf%L1BRADPCFIds(i), &
! >            & version, sval)
! >         else
! >          returnStatus = PGS_S_SUCCESS + 1
! >         endif
! >         IF (returnStatus == PGS_S_SUCCESS) THEN 
! >            inpt(i+1) = sval                     
! >         ENDIF                                   
! >       ENDDO
      ! print *, 'Forming input pointer with ids: ', &
      !  & L2pcf%L1BOAPCFId, L2pcf%L1BRADPCFIds(:)
a594 5
      ! returnStatus = pgs_met_setAttr_s(groups(INVENTORY), attrName, inpt)
      ! print *, 'Writing input pointer with : '
      ! do i=1, size(inpt)
      !   if ( inpt(i) /= ' ' ) print *, trim(inpt(i))
      ! enddo
d598 1
a598 1
           'See the PCF annotation to this file.')
d1570 3
@


2.37
log
@Passes isHDFEOS to PCFHdr
@
text
@d40 1
a40 1
     "$Id: write_meta.f90,v 2.36 2003/02/01 00:29:40 pwagner Exp $"
d140 2
a141 2
  logical, public, parameter :: ANNOTATEWITHPCF = .FALSE.
  logical, public, parameter :: SETINPUTPOINTER = .TRUE.
d604 2
d609 4
d1588 3
@


2.36
log
@Passes hdfVersion to writePCF2Hdr
@
text
@d40 1
a40 1
     "$Id: write_meta.f90,v 2.35 2003/01/30 01:01:05 pwagner Exp $"
d770 2
a771 1
    & L2pcf, Field_name, hdfVersion, Metadata_error, setAlias )
d792 1
d896 1
a896 1
     & hdfVersion)
d917 1
a917 1
    & setAlias )
d933 1
d1041 1
a1041 1
      & hdfVersion)
d1582 3
@


2.35
log
@Lets PCFHdr prepare and write input pointer
@
text
@d23 1
a23 1
    & InputInputPointer,WriteInputPointer, WritePCF2Hdr
d40 1
a40 1
     "$Id: write_meta.f90,v 2.34 2003/01/14 00:42:24 pwagner Exp $"
d134 1
a134 1
    INTEGER, DIMENSION(:), POINTER :: L1BRADPCFIds=>NULL()
d138 6
a143 6
  integer, public, parameter :: INVENTORYMETADATA=2
  logical, public, parameter :: MCFCASESENSITIVE=.FALSE.
  logical, public, parameter :: ANNOTATEWITHPCF=.FALSE.
  logical, public, parameter :: SETINPUTPOINTER=.TRUE.
  logical, public, parameter :: SFINBETWEENSTARTEND=.FALSE.
  integer, public, parameter :: MCFFORL2GPOPTION=3     ! 1, public, 2 or 3
d893 2
a894 1
    if ( ANNOTATEWITHPCF ) call writePCF2Hdr(physical_filename, l2pcf%anText)
d1037 2
a1038 1
    if ( ANNOTATEWITHPCF ) call writePCF2Hdr(physical_filename, l2pcf%anText)
d1579 3
@


2.34
log
@Creates soft link to type2precisionname, too
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d22 2
a23 1
  use PCFHdr, only: WriteInputPointer, WritePCF2Hdr
d40 1
a40 1
     "$Id: write_meta.f90,v 2.33 2002/12/11 22:21:05 pwagner Exp $"
d511 2
a512 1
    CHARACTER (LEN=98) :: inpt(31)
d522 1
a522 2
    INTEGER, EXTERNAL :: pgs_pc_getUniversalRef

d589 17
a605 15
      inpt = ' '
      DO i = 0, size(L2pcf%L1BRADPCFIds)
        version = 1
        if ( i == 0 ) then
         returnStatus = pgs_pc_getUniversalRef(L2pcf%L1BOAPCFId, version, sval)
        elseif ( L2pcf%L1BRADPCFIds(i) /= ILLEGALL1BRADID ) then
         returnStatus = pgs_pc_getUniversalRef(L2pcf%L1BRADPCFIds(i), &
           & version, sval)
        else
         returnStatus = PGS_S_SUCCESS + 1
        endif
        IF (returnStatus == PGS_S_SUCCESS) THEN 
           inpt(i+1) = sval                     
        ENDIF                                   
      ENDDO
d1577 3
@


2.33
log
@Makes soft link to data field name from L2gpValue field in hdf5 l2gp
@
text
@d39 1
a39 1
     "$Id: write_meta.f90,v 2.32 2002/12/06 23:37:22 pwagner Exp $"
d304 1
d306 1
d350 7
d1574 3
@


2.32
log
@addingMetaData now optional arg to mls_sfstart
@
text
@d9 2
d13 2
a14 1
  use MLSFiles, only: GetPCFromRef, mls_sfstart, mls_sfend, Split_path_name
d39 1
a39 1
     "$Id: write_meta.f90,v 2.31 2002/11/22 12:31:16 mjf Exp $"
d257 2
a258 1
  subroutine Measured_parameter ( HDF_FILE, Field_name, Groups, Class_num )
d278 4
a281 3
    integer :: HDF_FILE
    character(len=*) :: Field_name
    integer, intent(in) :: Class_num
d300 1
d302 3
d310 1
d312 2
a313 1

d323 38
d758 1
a758 1
    & L2pcf, Field_name, hdfVersion, Metadata_error )
d773 4
a776 4
    integer :: HDF_FILE, MCF_FILE
    type(PCFData_T) :: L2pcf
    character (len=*) :: Field_name
    integer, optional, intent(in) :: hdfVersion
d778 1
d837 1
a837 1
    call measured_parameter (HDF_FILE, field_name, groups, 1)
d901 2
a902 1
    & NumQuantitiesPerFile, QuantityNames, hdfVersion, Metadata_error )
d917 1
d979 1
a979 1
        & QuantityNames(indx), groups, indx)
d1565 3
@


2.31
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d36 1
a36 1
     "$Id: write_meta.f90,v 2.30 2002/10/08 17:36:23 pwagner Exp $"
d670 2
a671 1
    hdf_sdid = mls_sfstart (physical_fileName, DFACC_RDWR, hdfVersion=hdfVersion) 
d792 2
a793 1
      sdid = mls_sfstart (physical_fileName, DFACC_RDWR, hdfVersion=hdfVersion)
d935 2
a936 1
      sdid = mls_sfstart (physical_fileName, DFACC_RDWR, hdfVersion=hdfVersion)
d1513 4
@


2.30
log
@Added idents to survive zealous Lahey optimizer
@
text
@d36 1
a36 1
     "$Id: write_meta.f90,v 2.29 2002/08/29 16:55:35 pwagner Exp $"
d43 1
a43 1
    & Get_l2gp_mcf, WriteMetaLog
d1308 10
d1510 3
@


2.29
log
@Moved writeInputPointer to PCFHdr in lib
@
text
@d36 1
a36 1
     "$Id: write_meta.f90,v 2.28 2002/08/28 22:27:26 pwagner Exp $"
d39 1
d1494 4
d1500 3
@


2.28
log
@Now writes input pointer metadata like L3MMData
@
text
@d19 1
a19 1
  use PCFHdr, only: WritePCF2Hdr
d36 1
a36 1
     "$Id: write_meta.f90,v 2.27 2002/03/13 18:31:01 pwagner Exp $"
d544 2
a545 1
      returnStatus = pgs_met_setAttr_s(groups(INVENTORY), attrName, inpt)
d1495 3
@


2.27
log
@Opens, writes metadata, closes each file only once
@
text
@d12 2
a13 1
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA, CREATEMETADATA
d36 1
a36 1
     "$Id: write_meta.f90,v 2.26 2002/02/22 19:20:12 pwagner Exp $"
d127 4
d136 1
d445 1
a445 1
    real(r8) Dval
d450 2
a451 1
    integer :: version, indx
d461 1
d528 21
a548 2
    returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
         'See the PCF annotation to this file.')
d733 1
d1494 3
@


2.26
log
@Added mcf file name to announce_success
@
text
@d35 1
a35 1
     "$Id: write_meta.f90,v 2.25 2002/02/22 01:18:06 pwagner Exp $"
d131 1
d181 1
a181 3
      &  PGS_MET_setAttr_s, &
      &  PGS_MET_write

d293 1
a293 3
      &  PGS_MET_setAttr_s, PGS_MET_SETATTR_I, &
      &  PGS_MET_write

d390 1
a390 1
  subroutine Third_grouping ( HDF_FILE, L2pcf, Groups, hdfVersion )
d423 1
a437 1
    integer :: Sdid
d640 2
a641 2
!    sdid = sfstart (physical_fileName, DFACC_RDWR) 
    sdid = mls_sfstart (physical_fileName, DFACC_RDWR, hdfVersion=hdfVersion) 
d643 1
a643 1
    if ( sdid == -1 ) then
d648 1
a648 1
    returnStatus = pgs_met_write (groups(INVENTORY), "coremetadata.0", sdid)
d662 8
a669 7
!    hdfReturn = sfend(sdid)
    hdfReturn = mls_sfend(sdid, hdfVersion=hdfVersion)
    if ( hdfReturn /= 0 ) then
        call announce_error ( 0, &
        & "Error: metadata mls_sfend in third_grouping.", &
        & error_number=hdfReturn) 
    end if
d671 2
a672 1
    returnStatus = pgs_met_remove() 
d704 1
a704 1
    integer :: sdid
d757 1
a757 1
    call third_grouping (HDF_FILE, l2pcf, groups, hdfVersion)
d760 5
a764 1
    sdid = mls_sfstart (physical_fileName, DFACC_RDWR, hdfVersion=hdfVersion) 
d773 1
a773 1
    returnStatus = pgs_met_write (groups(INVENTORY), "coremetadata.0", sdid)
d775 5
a779 5
    if ( returnStatus /= PGS_S_SUCCESS .AND. &
         returnStatus /= PGSMET_W_METADATA_NOT_SET ) then 
      if ( returnStatus == PGSMET_W_METADATA_NOT_SET ) then 
        call announce_error ( 0, &
        & "Error--some of the mandatory parameters were not set") 
d781 7
a787 7
      else
        call Pgs_smf_getMsg (returnStatus, attrname, errmsg)
        call MLSMessage (MLSMSG_WARNING, ModuleName, &
             "Metadata write failed in populate_metadata_std " &
             & //trim(attrname)//trim(errmsg))
      end if
    end if
d802 5
d839 1
a839 1
    integer :: Sdid
d899 1
a899 1
    call third_grouping (HDF_FILE, l2pcf, groups, hdfVersion)
d902 5
a906 1
    sdid = mls_sfstart (physical_fileName, DFACC_RDWR, hdfVersion=hdfVersion)
d914 1
a914 1
    returnStatus = pgs_met_write (groups(INVENTORY), "coremetadata.0", sdid)
d916 12
a927 12
    if ( returnStatus /= PGS_S_SUCCESS .AND. &
         returnStatus /= PGSMET_W_METADATA_NOT_SET ) then 
      if ( returnStatus == PGSMET_W_METADATA_NOT_SET ) then 
        call announce_error ( 0, &
        & "Error: Some of the mandatory parameters were not set in populate_metadata_oth.")
      else
        call Pgs_smf_getMsg (returnStatus, attrname, errmsg)
        call MLSMessage (MLSMSG_WARNING, ModuleName, &
             "Metadata write failed in populate_metadata_oth " &
             & //trim(attrname)//trim(errmsg))
      end if
    end if
d942 5
d1264 5
d1466 3
@


2.25
log
@get_l2gp_mcf accepts meta_name arg; now uses getPCFFromRef
@
text
@d35 1
a35 1
     "$Id: write_meta.f90,v 2.24 2002/01/31 00:37:45 pwagner Exp $"
d710 1
a710 1
!    character (len=132) :: attrname, errmsg
d736 1
a736 1
      returnStatus = PGS_PC_GetReference (MCF_FILE, version , physical_filename)
d803 1
a803 1
       call announce_success(physical_filename, 'standard')
d836 1
a836 1
!    character (len=132) :: attrname, errmsg
d862 1
a862 1
      returnStatus = PGS_PC_GetReference (MCF_FILE, version , physical_filename)
d934 1
a934 1
       call announce_success(physical_filename, 'others')
d987 2
d1097 4
d1142 1
d1158 1
a1158 1
      & physical_filename)
d1251 1
a1251 1
       call announce_success(physical_filename, 'Log')
d1368 1
a1368 1
  subroutine announce_success ( Name, l2_type )
d1370 1
d1379 4
d1444 3
@


2.24
log
@Checks return value of mls_sfend
@
text
@d11 1
a11 1
  use MLSFiles, only: Split_path_name, mls_sfstart, mls_sfend
d16 1
a16 1
  use MLSStrings, only: Reverse, LowerCase, GetStringHashElement
d35 1
a35 1
     "$Id: write_meta.f90,v 2.23 2002/01/26 00:08:20 pwagner Exp $"
d110 5
d941 1
a941 1
  subroutine Get_l2gp_mcf ( File_base, Mcf, L2pcf, Version )
d947 1
a959 1
    character (len=NameLen) :: Mcf_pattern
d994 7
a1000 2
    ! Get full file name for typical MCF file
    do i=mlspcf_mcf_l2gp_start, mlspcf_mcf_l2gp_end
d1002 5
a1006 5
      if ( present(version) ) then
	      myVersion=version
      else
	      myVersion = 1
      end if
d1008 1
a1008 1
      returnStatus = PGS_PC_GetReference(i, myVersion , mcf_full)
d1010 3
a1012 3
      if ( returnStatus == PGS_S_SUCCESS ) then 
	      exit
      end if
d1014 1
a1014 1
    end do
d1016 4
a1019 4
    if ( DEBUG ) then
      call output('returnStatus: ', advance='no')
      call output(returnStatus, advance='yes')
    end if
d1021 4
a1024 4
    if ( returnStatus /= PGS_S_SUCCESS ) then 
      mcf = 0
      return
    end if
d1026 1
a1026 1
    ! Split full_file_names into path+name
d1028 1
a1028 1
    call split_path_name ( mcf_full, mcf_path, mcf_name )
d1030 7
a1036 7
! If text matching not case sensitive, shift to lower case
    if ( .NOT. MCFCASESENSITIVE ) then
      sd_full = LowerCase(file_base)
      mcf_name = LowerCase(mcf_name)
    else
      sd_full = file_base
    end if
d1038 8
a1045 8
    if ( DEBUG ) then
      call output('mcf_full: ', advance='no')
      call output(trim(mcf_full), advance='yes')
      call output('mcf_path: ', advance='no')
      call output(trim(mcf_path), advance='yes')
      call output('mcf_name: ', advance='no')
      call output(trim(mcf_name), advance='yes')
    end if
d1047 2
a1048 23
    ! Get species name assuming e.g. '*l2gp_h2o'
    call split_path_name(sd_full, sd_path, sd_name, species_delimiter)

    if ( DEBUG ) then
      call output('sd_full: ', advance='no')
      call output(trim(sd_full), advance='yes')
      call output('sd_path: ', advance='no')
      call output(trim(sd_path), advance='yes')
      call output('sd_name: ', advance='no')
      call output(trim(sd_name), advance='yes')
    end if

    if ( len(trim(sd_name)) <= 0 ) then
      mcf=0
      return
    end if
	
    if ( MCFFORL2GPOPTION == 3 ) then

      ! get mcfspecies name from associative array
      ! if the species name not found in spec_keys, it will return ','
      call GetStringHashElement ( l2pcf%spec_keys, l2pcf%spec_hash, &
        & trim(sd_name), sd_full, .TRUE. )
d1051 1
a1051 5
        call output('keys: ', advance='no')
        call output(trim(l2pcf%spec_keys), advance='yes')
        call output('hash: ', advance='no')
        call output(trim(l2pcf%spec_hash), advance='yes')
        call output('hash for species name: ', advance='no')
d1053 4
d1059 2
a1060 2
      if ( trim(sd_full) == COMMA ) then
        mcf = 0
d1063 2
d1066 4
a1069 1
      sd_name = trim(sd_full)
d1071 8
a1078 1
    end if
d1080 3
a1082 24
    ! Now try to find mcf file corresponding to species name
    ! assuming, e.g. '*h2o.*'

    if ( DEBUG ) then
      call output('loop over mcf files', advance='yes')
    end if

    do i=mlspcf_mcf_l2gp_start, mlspcf_mcf_l2gp_end

      if ( present(version) ) then
        myVersion=version
      else
        myVersion = 1
      end if

      returnStatus = PGS_PC_GetReference(i, myVersion, mcf_full)

      if ( returnStatus == PGS_S_SUCCESS ) then 
        call split_path_name(mcf_full, mcf_path, mcf_name)

        ! This gives 'o2h*'
        call split_path_name(Reverse(mcf_name), mcf_path, mcf_pattern, '.')
        if ( .NOT. MCFCASESENSITIVE ) then
          mcf_pattern = LowerCase(mcf_pattern)
d1085 1
a1085 2
        ! So reverse it to make h2o
        mcf_pattern = adjustl(Reverse(mcf_pattern))
a1086 12
        if ( DEBUG ) then
          call output('mcf_pattern: ', advance='no')
          call output(trim(mcf_pattern), advance='yes')
        end if
        ! Check that pattern matches species name
        ! Warning--this could give a false matching
        ! if the species name matches more than one mcf_pattern
        ! May wish to check for multiple matches later
        if ( index(trim(mcf_pattern), trim(sd_name)) > 0 ) then
          mcf = i
          return
	end if
d1088 10
d1099 3
a1101 3
    end do

    mcf = 0
d1432 3
@


2.23
log
@Housekeeping; changed proclaim to announce_success
@
text
@d35 1
a35 1
     "$Id: write_meta.f90,v 2.22 2002/01/23 21:50:04 pwagner Exp $"
d662 5
d783 5
d914 5
d1455 3
@


2.22
log
@Uses hdfVersion optional parameter
@
text
@d8 1
a8 1
  use Hdf, only: DFACC_RDWR, Sfend, Sfstart
d21 2
a22 2
    & PGSPC_W_NO_REFERENCE_FOUND, PGS_S_SUCCESS, PGSMET_W_METADATA_NOT_SET, &
   & PGS_PC_getconfigdata!, &
d27 1
a27 1
  use TREE, only: DUMP_TREE_NODE, SOURCE_REF
d35 1
a35 1
     "$Id: write_meta.f90,v 2.21 2002/01/22 17:45:26 pwagner Exp $"
d164 1
a164 1
    character (len=132) :: Attrname, Errmsg
d175 2
a176 2
      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_setattr_i, &
      &  PGS_MET_write, PGS_MET_remove
d277 1
a277 1
    character (len=132) :: Attrname, Errmsg
d288 3
a290 3
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
      &  PGS_MET_write, PGS_MET_remove
d441 1
a441 1
    character (len=132) :: attrname, errmsg
d449 2
a450 2
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
         PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
d714 2
a715 2
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
a772 4
!       call announce_error ( 0, &
!       & "Error: metadata write failed in populate_metadata_std.", &
!       & error_number=returnStatus)
!       return
d788 1
a788 1
       call proclaim(physical_filename, 'standard')
d835 2
a836 2
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
a891 2
!       CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!         & "Some of the mandatory parameters were not set" )
a893 1
!       return
a898 4
!       call announce_error ( 0, &
!       & "Error: metdata write failed in populate_metadata_oth.", &
!       & error_number=returnStatus)
!       return
d914 1
a914 1
       call proclaim(physical_filename, 'others')
a1161 2
!       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!         & "Failed to find the PCF reference for the Log mcf in WriteMetaLog" ) 
a1168 2
!    version = 1
!    result = PGS_PC_GetReference (ASCII_FILE, version , physical_filename)
a1171 2
!     CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!       & "Failed to find the PCF reference for the ASCII in WriteMetaLog" ) 
a1180 2
!     CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!       & "Failed to find the PCF reference for the LOG in WriteMetaLog" ) 
a1193 2
!     CALL MLSMessage(MLSMSG_Error, ModuleName, &
!       & 'Initialization error.  See LogStatus for details.')
a1224 3
!         call Pgs_smf_getMsg(result, mnemonic, msg)
!         msr = mnemonic // ':  ' // msg
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
a1244 4
!    call announce_error ( 0, &
!    & "Error: failed to write metadata in WriteMetaLog.", &
!    & error_number=result)
!                     return
d1252 1
a1252 1
       call proclaim(physical_filename, 'Log')
d1368 2
a1369 2
  ! ---------------------------------------------  proclaim  -----
  subroutine proclaim ( Name, l2_type )
d1380 1
a1380 1
  end subroutine proclaim
d1440 3
@


2.21
log
@Removed bogus declaration of pgs_met_startf
@
text
@d35 1
a35 1
     "$Id: write_meta.f90,v 2.20 2002/01/18 23:11:09 pwagner Exp $"
d388 1
a388 1
  subroutine Third_grouping ( HDF_FILE, L2pcf, Groups )
d429 1
d639 1
a639 1
    sdid = mls_sfstart (physical_fileName, DFACC_RDWR) 
d661 1
a661 1
    hdfReturn = mls_sfend(sdid)
d670 1
a670 1
    & L2pcf, Field_name, Metadata_error )
d688 1
d748 1
a748 1
    call third_grouping (HDF_FILE, l2pcf, groups)
d751 1
a751 1
    sdid = mls_sfstart (physical_fileName, DFACC_RDWR) 
d781 1
a781 1
    hdfReturn = mls_sfend(sdid)
d800 1
a800 1
    & NumQuantitiesPerFile, QuantityNames, Metadata_error )
d814 1
d880 1
a880 1
    call third_grouping (HDF_FILE, l2pcf, groups)
d883 1
a883 1
    sdid = mls_sfstart (physical_fileName, DFACC_RDWR) 
d914 1
a914 1
    hdfReturn = mls_sfend(sdid)
d1468 3
@


2.20
log
@Uses mls_sfstart; writePCF2Hdr controlled by ANNOTATEWITHPCF; dumps core (hooray)
@
text
@d35 1
a35 1
     "$Id: write_meta.f90,v 2.19 2002/01/09 23:54:24 pwagner Exp $"
d176 1
a176 1
      &  PGS_MET_write, PGS_MET_remove, PGS_MET_SDstartF
d290 1
a290 1
      &  PGS_MET_write, PGS_MET_remove, PGS_MET_SDstartF
d450 1
a450 1
         PGS_MET_write, PGS_MET_remove, PGS_MET_SDstartF
d714 1
a714 1
      &  PGS_MET_write, PGS_MET_remove, PGS_MET_SDstartF
d838 1
a838 1
      &  PGS_MET_write, PGS_MET_remove, PGS_MET_SDstartF
d1465 3
@


2.19
log
@Now gets FileNameLen from MLSCommon, not SDPToolkit
@
text
@d11 1
a11 1
  use MLSFiles, only: Split_path_name
d35 1
a35 1
     "$Id: write_meta.f90,v 2.18 2001/05/17 22:33:27 pwagner Exp $"
a123 1
  
d125 1
a125 1

a126 1

d176 1
a176 1
      &  PGS_MET_write, PGS_MET_remove
d290 1
a290 1
      &  PGS_MET_write, PGS_MET_remove
d450 1
a450 1
         PGS_MET_write, PGS_MET_remove
d637 2
a638 1
    sdid = sfstart (physical_fileName, DFACC_RDWR) 
d659 2
a660 1
    hdfReturn = sfend(sdid)
d714 1
a714 1
      &  PGS_MET_write, PGS_MET_remove
d748 2
a749 1
    sdid = sfstart (physical_fileName, DFACC_RDWR) 
d778 2
a779 1
    hdfReturn = sfend(sdid)
d783 1
a783 1
    call writePCF2Hdr(physical_filename, l2pcf%anText)
d838 1
a838 1
      &  PGS_MET_write, PGS_MET_remove
d879 2
a880 1
    sdid = sfstart (physical_fileName, DFACC_RDWR) 
d910 2
a911 1
    hdfReturn = sfend(sdid)
d915 1
a915 1
    call writePCF2Hdr(physical_filename, l2pcf%anText)
d1465 3
@


2.18
log
@Prints info if pro switch set
@
text
@d1 1
a1 1
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d10 1
a10 1
  use MLSCommon, only: NameLen, R8
d19 1
a19 1
  use SDPToolkit, only: FileNameLen, PGSd_MET_GROUP_NAME_L, &
d35 1
a35 1
     "$Id: write_meta.f90,v 2.17 2001/05/08 23:28:46 pwagner Exp $"
d1461 3
@


2.17
log
@Sorry-bad metadata functions in SDPToolkit
@
text
@d17 1
a17 1
  use Output_m, only: Output
d26 1
d35 1
a35 1
     "$Id: write_meta.f90,v 2.16 2001/05/07 23:30:05 pwagner Exp $"
d787 4
d917 4
d1272 4
d1389 14
d1461 3
@


2.16
log
@Gets all pgs_ from SDPToolkit
@
text
@d22 4
a25 3
    & PGS_MET_init, PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, PGS_MET_setattr_i, &
      &  PGS_MET_write, PGS_MET_remove, PGS_PC_getconfigdata
d34 1
a34 1
     "$Id: write_meta.f90,v 2.15 2001/05/07 18:04:51 pwagner Exp $"
d175 3
a177 3
!    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
!      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_setattr_i, &
!      &  PGS_MET_write, PGS_MET_remove
d289 3
a291 3
!    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
!      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
!      &  PGS_MET_write, PGS_MET_remove
d449 3
a451 3
!    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
!         PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
!         PGS_MET_write, PGS_MET_remove
d711 3
a713 3
!    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
!      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
!      &  PGS_MET_write, PGS_MET_remove
d829 3
a831 3
!    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
!      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
!      &  PGS_MET_write, PGS_MET_remove
d1129 3
a1131 3
!    integer, external :: PGS_MET_init, PGS_MET_remove, PGS_MET_setattr_d
!    integer, external :: PGS_MET_setattr_s, PGS_MET_write
!    integer, external :: PGS_PC_getconfigdata
d1434 3
@


2.15
log
@Always check for CREATEMETADATA first
@
text
@d21 4
a24 1
    & PGSPC_W_NO_REFERENCE_FOUND, PGS_S_SUCCESS, PGSMET_W_METADATA_NOT_SET
d33 1
a33 1
     "$Id: write_meta.f90,v 2.14 2001/05/03 20:34:20 vsnyder Exp $"
d174 3
a176 3
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_setattr_i, &
      &  PGS_MET_write, PGS_MET_remove
d288 3
a290 3
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
      &  PGS_MET_write, PGS_MET_remove
d448 3
a450 3
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
         PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
         PGS_MET_write, PGS_MET_remove
d710 3
a712 3
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
      &  PGS_MET_write, PGS_MET_remove
d828 3
a830 3
    integer, external :: PGS_MET_init, PGS_MET_setattr_d, &
      &  PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
      &  PGS_MET_write, PGS_MET_remove
d1128 3
a1130 3
    integer, external :: PGS_MET_init, PGS_MET_remove, PGS_MET_setattr_d
    integer, external :: PGS_MET_setattr_s, PGS_MET_write
    integer, external :: PGS_PC_getconfigdata
d1433 3
@


2.14
log
@Cosmetic changes
@
text
@a8 1
! use HDFEOS ! Appears not to be used
a9 1
! use MLSCF  ! Appears not to be used
d12 1
a12 1
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA
d30 1
a30 1
     "$Id: write_meta.f90,v 2.13 2001/04/20 23:52:15 vsnyder Exp $"
a180 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Error in getting ref for PCF number in 1st grouping.") 
a187 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Initialization error.  See LogStatus for details.") 
a199 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a207 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a216 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a223 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a231 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a295 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Error in getting ref for PCF number in measured_parameter.") 
a301 9
!    if ( hdf_file == mlspcf_l1b_radf_start ) then
!       sval = "Filter bank radiances"
!    else if ( hdf_file == mlspcf_l1b_radd_start ) then
!       sval = "DACS radiances"
!    else if ( hdf_file == mlspcf_l1b_oa_start ) then
!       sval = "Orbit/attitude and tangent point"
!    else if ( hdf_file == mlspcf_l1b_eng_start ) then
!       sval = "MLS Instrument Engineering"
!    end if
a319 1
    !   errmsg = METAWR_ERR // attrName
a321 1
!       CALL MLSMessage(MLSMSG_Error, ModuleName, errmsg)
a329 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a337 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a345 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage(MLSMSG_Error, ModuleName, errmsg)
a353 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage(MLSMSG_Error, ModuleName, errmsg)
a362 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a369 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a376 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a454 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Error in getting ref for PCF number in third_grouping.") 
a463 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a473 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a481 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a489 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a497 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a506 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a516 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a526 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a536 2
     !   errmsg = METAWR_ERR // attrName
!        CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a544 2
     !   errmsg = METAWR_ERR // attrName
!        CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a554 2
     !   errmsg = METAWR_ERR // attrName
!        CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a562 2
     !   errmsg = METAWR_ERR // attrName
!        CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a570 2
     !   errmsg = METAWR_ERR // attrName
!        CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a578 2
     !   errmsg = METAWR_ERR // attrName
!        CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a586 2
     !   errmsg = METAWR_ERR // attrName
!        CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a598 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Error setting RangeBeginningDate")
a605 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Error setting RangeBeginningTime")
a612 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Error setting RangeEndingDate")
a619 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Error setting RangeEndingTime")
a629 2
    !   errmsg = METAWR_ERR // attrName
!       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
a636 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Failed to open the hdf file "//physical_fileName ) 
a645 2
!       CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!        & "Some of the mandatory parameters were not set" )
a648 3
!       CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
!       CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!         &  "Metadata write failed "//attrname//errmsg)
d715 1
a724 2
!     CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!       & "Failed to find the PCF reference for MCF_FILE in populate_metadata_std" ) 
a733 2
!     CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!       & "Failed to find the PCF reference for HDF_FILE in populate_metadata_std" ) 
a745 2
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Failed to open the hdf file "//physical_fileName ) 
a756 2
!       CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!         & "Some of the mandatory parameters were not set" )
d833 1
a842 2
!     CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!       & "Failed to find the PCF reference for MCF_FILE in populate_metadata_oth" ) 
a851 2
!     CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!       & "Failed to find the PCF reference for HDF_FILE in populate_metadata_oth" ) 
a870 2
!     CALL MLSMessage (MLSMSG_Error, ModuleName, &
!       & "Failed to open the hdf file "//physical_fileName ) 
d945 5
d1144 1
d1430 3
@


2.13
log
@Consider the penalty from MLSL2Options in Announce_Error.  Numerous
cosmetic changes.  Remove dump of tree node from Announce_Error.
@
text
@d32 1
a32 1
     "$Id: write_meta.f90,v 2.12 2001/04/19 23:51:40 pwagner Exp $"
d67 1
a67 1
    character (len=1), pointer :: anText(:) => null()
d120 2
a121 2
  integer, public, parameter :: MCFFORL2GPOPTION=3     ! 1, public, 2 or 3

d124 1
a124 1
  integer, public, parameter :: INVENTORYMETADATA=2
a152 12
    !Local Variables

    integer :: ReturnStatus

    integer, parameter :: INVENTORY=2, ARCHIVE=1
    character (len=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: sval
    character (len=132) :: attrname, errmsg
    integer :: version, indx
    character (len=*), parameter :: METAWR_ERR = &
         'Error writing metadata attribute '

d160 11
d174 2
a175 2
         PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_setattr_i, &
         PGS_MET_write, PGS_MET_remove
d177 1
a177 1
    !Executable code
d185 2
a186 2
      call announce_error(0, &
      & "Error in getting ref for PCF number in 1st grouping.") 
d194 2
a195 2
      call announce_error(0, &
      & "Metadata initialization error") 
d208 2
a209 2
      call announce_error(0, &
      & "Error in writing ReprocessingPlanned attribute.") 
d218 2
a219 2
      call announce_error(0, &
      & "Error in writing ReprocessingActual attribute.") 
d229 2
a230 2
      call announce_error(0, &
      & "Error in writing LocalGranuleID attribute.") 
d238 2
a239 2
      call announce_error(0, &
      & "Error in writing DayNightFlag attribute.") 
d243 1
a243 1
         CALL ExpandFileTemplate('$cycle', sval, cycle=l2pcf%cycle)
d248 2
a249 2
      call announce_error(0, &
      & "Error in writing LocalVersionID attribute.") 
d252 1
a252 1
  end subroutine first_grouping
d287 1
a287 4
    !Local Variables

    integer :: returnStatus
    character (len=2) :: class
d289 1
a289 3
    integer, parameter :: INVENTORY=2, ARCHIVE=1
    character (len=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    character (len=PGSd_PC_FILE_PATH_MAX) :: sval
d291 1
a291 1
    integer :: Version
d294 4
d302 2
a303 2
         PGS_MET_setAttr_s, PGS_MET_getsetattr_d, PGS_MET_SETATTR_I, &
         PGS_MET_write, PGS_MET_remove
d314 2
a315 2
      call announce_error(0, &
      & "Error in getting ref for PCF id in measured_parameter.") 
d331 1
a331 1
      class(:2)='0 '
d333 2
a334 2
      write(class(:1), '(I1)') class_num
      class(2:2)=' '
d336 1
a336 1
      write(class(:2), '(I2)') class_num
d348 2
a349 2
      call announce_error(0, &
      & "Error in writing ParameterName attribute.") 
d361 2
a362 2
      call announce_error(0, &
      & "Error in writing AutomaticQualityFlag attribute.") 
d371 2
a372 2
      call announce_error(0, &
      & "Error in writing AutomaticQualityFlagExplanation attribute.") 
d381 2
a382 2
      call announce_error(0, &
      & "Error in writing OperationalQualityFlag attribute.") 
d391 2
a392 2
      call announce_error(0, &
      & "Error in writing OperationalQualityFlagExplanation attribute.") 
d402 2
a403 2
      call announce_error(0, &
      & "Error in writing QAPercentInterpolatedData attribute.") 
d411 2
a412 2
      call announce_error(0, &
      & "Error in writing QAPercentMissingData attribute.") 
d420 2
a421 2
      call announce_error(0, &
      & "Error in writing QAPercentOutofBoundsData attribute.") 
d500 1
a500 1
      call announce_error(0, &
d511 1
a511 1
      call announce_error(0, &
d523 1
a523 1
      call announce_error(0, &
d533 1
a533 1
      call announce_error(0, &
d543 1
a543 1
      call announce_error(0, &
d553 1
a553 1
      call announce_error(0, &
d564 1
a564 1
      call announce_error(0, &
d576 1
a576 1
      call announce_error(0, &
d588 1
a588 1
       call announce_error(0, &
d600 1
a600 1
       call announce_error(0, &
d610 1
a610 1
       call announce_error(0, &
d622 1
a622 1
       call announce_error(0, &
d632 1
a632 1
       call announce_error(0, &
d642 1
a642 1
       call announce_error(0, &
d652 1
a652 1
       call announce_error(0, &
d662 1
a662 1
      call announce_error(0, &
d676 1
a676 1
      call announce_error(0, &
d685 1
a685 1
      call announce_error(0, &
d694 1
a694 1
      call announce_error(0, &
d703 1
a703 1
      call announce_error(0, &
d715 1
a715 1
      call announce_error(0, &
d724 1
a724 1
      call announce_error(0, &
d735 1
a735 1
        call announce_error(0, &
d741 1
a741 1
        call announce_error(0, &
d818 1
a818 1
      call announce_error(0, &
d829 1
a829 1
      call announce_error(0, &
d843 1
a843 1
      call announce_error(0, &
d856 1
a856 1
        call announce_error(0, &
d864 1
a864 1
!       call announce_error(0, &
d943 1
a943 1
      call announce_error(0, &
d954 1
a954 1
      call announce_error(0, &
d975 1
a975 1
      call announce_error(0, &
d987 1
a987 1
        call announce_error(0, &
d995 1
a995 1
!       call announce_error(0, &
d1253 1
a1253 1
      call announce_error(0, &
d1267 1
a1267 1
      call announce_error(0, &
d1278 1
a1278 1
      call announce_error(0, &
d1293 1
a1293 1
      call announce_error(0, &
d1327 1
a1327 1
      call announce_error(0, &
d1347 1
a1347 1
!    call announce_error(0, &
d1528 4
@


2.12
log
@Moved anText to become component of PCFData_T
@
text
@d1 2
d5 1
a5 1
MODULE WriteMetadata ! Populate metadata and write it out
a6 24
USE Hdf 
USE HDFEOS 
use LEXER_CORE, only: PRINT_SOURCE
USE MLSCF 
USE MLSCommon, only: NameLen
USE MLSFiles, only: split_path_name
USE MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
USE MLSPCF2
USE MLSStrings, only: Reverse, LowerCase, GetStringHashElement
USE output_m, only: output
USE PCFHdr, only: WritePCF2Hdr
USE SDPToolkit
use TREE, only: DUMP_TREE_NODE, SOURCE_REF

IMPLICIT NONE

PUBLIC

PRIVATE :: Id, ModuleName
!------------------------------- RCS Ident Info ------------------------------
CHARACTER(LEN=130) :: id = & 
   "$Id: write_meta.f90,v 2.11 2001/04/16 23:49:11 pwagner Exp $"
CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: write_meta.f90,v $"
!-----------------------------------------------------------------------------
d8 31
a38 5
	public :: populate_metadata_std, populate_metadata_oth, &
	& get_l2gp_mcf, WriteMetaLog
	
	private :: first_grouping, measured_parameter, third_grouping, &
	& ExpandFileTemplate
d40 2
a41 1
  integer, private :: module_error
d46 9
a54 1
   TYPE PCFData_T
d56 1
a56 1
     ! cycle # of processing run
d58 1
a58 1
     CHARACTER (LEN=4) :: cycle
d60 2
a61 1
     ! version string in PCF input file names
d63 3
a65 1
     CHARACTER (LEN=15) :: inputVersion	! input files (but which?)
d67 1
a67 1
     ! version string in PCF output file names
d69 10
a78 1
     CHARACTER (LEN=15) :: PGEVersion	! add to output files
d80 12
a91 2
      CHARACTER(LEN=27) :: StartUTC
      CHARACTER(LEN=27) :: EndUTC
d93 6
a98 5
   ! The annotation text to be written to the header of every scientific
   ! data file for which we need metadata
   ! In practice, this annotation will be the contents of the PCF file itself
   
    CHARACTER (LEN=1), POINTER :: anText(:) => null()
d100 3
a102 23
	! The correspondence between MCF and l2gp files is determined by
	! the value of        MCFFORL2GPOPTION
	! One of three possible options:
	!                          (1)
	! The PCF numbers for the mcf corresponding to each
	! of the l2gp files begin with mlspcf_mcf_l2gp_start
	! and increase 1 by 1 with each succeeding species.
	! Then, after the last single-species l2gp, the very next pcf number
	! is for the one called 'other' ML2OTH.001.MCF
	! This inconvenient inflexibility is relieved in option (2) or (3)
	
	!                          (2)
	! Each l2gp file name, stripped of their paths, fits the pattern like
	!  *_l2gp_species_*
	! and the corresponding MCF files fit the pattern
	!  *SPECIES.*
	! where species and SPECIES are case-insensitive "species" name
	! i.e., BrO, ClO, etc.
	! Warning:
	! You therefore must use exactly the same abbreviation for the l2gp and the
	! corresponding MCF: if the MCF is ML2T.001.MCF, don't use "temp"
	! in the l2gp name
	! This inflexibility replaces the different kind in option (1)
d104 2
a105 6
	!                          (3)
	! Similar to (2), but now the SPECIES of the corresponding
	! MCF file names are chosen from an associative array structure
	! or hash table, where the keys are the possible species and
	! the hash
     ! how to associate l2gp species names with mcf files
d107 1
a107 3
	  ! if an associative array, then l2gp file names contain the "keys"
	  ! the following is a comma-delimited list of possible species
	  ! names that may be such keys
d109 2
a110 2
   ! Note that the text matching in options (2) and (3)
   ! will not be case sensitive unless you set MCFCASESENSITIVE
d112 1
a112 1
     CHARACTER (LEN=FileNameLen) :: spec_keys
d114 1
a114 2
	  ! the following is a comma-delimited list of possible 	
	  ! mcf file name parts that may be the corresponding hash
d116 1
a116 1
     CHARACTER (LEN=FileNameLen) :: spec_hash
d118 1
a118 1
     ! name of the log file (without the path)
d120 1
a120 1
     CHARACTER (LEN=FileNameLen) :: logGranID
d122 1
a122 1
   END TYPE PCFData_T
d124 1
a124 3
    integer, parameter :: MCFFORL2GPOPTION=3		! 1, 2 or 3
    
    logical, parameter :: MCFCASESENSITIVE=.FALSE.
d126 1
a126 2
   !
	INTEGER, PARAMETER :: INVENTORYMETADATA=2
d128 1
a128 1
CONTAINS
d130 1
a130 1
!--------------------------- first_grouping -------------------
d132 1
a132 1
  SUBROUTINE first_grouping (HDF_FILE, MCF_FILE, l2pcf, groups)
d134 2
a135 2
! This writes the metadata for the following attributes:
! (attributes marked automatic are not explicitly written, however)
d137 8
a144 8
! SizeMBECSDataGranule (automatic)
! ReProcessingPlanned
! ReProcessingActual
! LocalGranuleID
! DayNightFlag
! ProductionDateTime (automatic)
! LocalVersionID
!
d146 1
a146 1
!    USE InitPCFs, ONLY: L2PCF
d150 2
a151 2
    INTEGER :: HDF_FILE, MCF_FILE
	 type(PCFData_T) :: l2pcf
a153 2
 
    INTEGER :: returnStatus
d155 8
a162 6
    INTEGER, PARAMETER :: INVENTORY=2, ARCHIVE=1
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: sval
    CHARACTER (LEN=132) :: attrname, errmsg
    INTEGER :: version, indx
    CHARACTER (LEN=*), PARAMETER :: METAWR_ERR = &
d170 1
a170 1
    CHARACTER (LEN = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d174 3
a176 3
    INTEGER, EXTERNAL :: pgs_met_init, pgs_met_setattr_d, &
         pgs_met_setAttr_s, pgs_met_getsetattr_d, PGS_MET_SETATTR_I, &
         pgs_met_write, pgs_met_remove
d183 1
a183 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN 
d188 1
a188 1
    ENDIF
d192 1
a192 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN 
d197 1
a197 1
    ENDIF
d206 1
a206 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d211 1
a211 1
    ENDIF
d216 1
a216 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d221 1
a221 1
    ENDIF
d227 1
a227 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d232 1
a232 1
    ENDIF
d236 1
a236 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d241 1
a241 1
    ENDIF
d246 1
a246 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d251 1
a251 1
    ENDIF
d253 1
a253 1
END SUBROUTINE first_grouping
d255 1
a255 1
!--------------------------- measured_parameter -------------------
d257 1
a257 1
  SUBROUTINE measured_parameter (HDF_FILE, field_name, groups, class_num)
d259 13
a271 13
! This writes the attributes corresponding to the measured parameter container:
!
! ParameterName
! AutomaticQualityFlag
! AutomaticQualityFlagExplanation
! OperationalQualityFlag
! OperationalQualityFlagExplanation
! ScienceQualityFlag
! ScienceQualityFlagExplanation
! QAPercentInterpolatedData
! QAPercentMissingData
! QAPercentOutOfBoundsData
!
d273 1
a273 1
!    USE InitPCFs, ONLY: L2PCF
d277 3
a279 16
    INTEGER :: HDF_FILE
	 character (LEN=*) :: field_name
    integer, intent (in) :: class_num

    !Local Variables
 
    INTEGER :: returnStatus
    character (LEN=2) :: class

    INTEGER, PARAMETER :: INVENTORY=2, ARCHIVE=1
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: sval
    CHARACTER (LEN=132) :: attrname, errmsg
    INTEGER :: version
    CHARACTER (LEN=*), PARAMETER :: METAWR_ERR = &
         'Error writing metadata attribute '
d286 14
a299 1
    CHARACTER (LEN = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d303 3
a305 3
    INTEGER, EXTERNAL :: pgs_met_init, pgs_met_setattr_d, &
         pgs_met_setAttr_s, pgs_met_getsetattr_d, PGS_MET_SETATTR_I, &
         pgs_met_write, pgs_met_remove
d313 1
a313 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN 
d318 1
a318 1
    ENDIF
d322 1
a322 1
!    IF (hdf_file == mlspcf_l1b_radf_start) THEN
d324 1
a324 1
!    ELSE IF (hdf_file == mlspcf_l1b_radd_start) THEN
d326 1
a326 1
!    ELSE IF (hdf_file == mlspcf_l1b_oa_start) THEN
d328 1
a328 1
!    ELSE IF (hdf_file == mlspcf_l1b_eng_start) THEN
d330 1
a330 1
!    ENDIF
d332 1
a332 1
   if(class_num <= 0) then
d334 1
a334 1
   elseif(class_num < 10) then
d337 1
a337 1
   else
d339 1
a339 1
   endif
d341 5
a345 5
	if(field_name /= ' ') then
		sval = adjustl(field_name)
	else
		sval = 'Miscellaneous'
	endif
d348 1
a348 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d353 1
a353 1
    ENDIF
d360 1
a360 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d365 1
a365 1
    ENDIF
d370 1
a370 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d375 1
a375 1
    ENDIF
d380 1
a380 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d385 1
a385 1
    ENDIF
d390 1
a390 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d395 1
a395 1
    ENDIF
d398 1
a398 1
    
d401 1
a401 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d406 1
a406 1
    ENDIF
d410 1
a410 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d415 1
a415 1
    ENDIF
d419 1
a419 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d424 1
a424 1
    ENDIF
d426 1
a426 1
END SUBROUTINE measured_parameter
d428 1
a428 1
!--------------------------- third_grouping -------------------
d430 1
a430 1
  SUBROUTINE third_grouping (HDF_FILE, l2pcf, groups)
d432 1
a432 25
! This writes the following metadata attributes:

! OrbitNumber
! StartOrbitNumber
! StopOrbitNumber
! EquatorCrossingLongitude
! EquatorCrossingTime
! EquatorCrossingDate
! ShortName
! VersionID
! InputPointer
! LocalityValue
! VerticalSpatialDomainType
! VerticalSpatialDomainValue
! ZOneIdentifier
! WestBoundingCoordinate
! NortBoundingCoordinate
! EastBoundingCoordinate
! SouthBoundingCoordinate
! RangeBeginningDate
! RangeBeginningTime
! RangeEndingDate
! RangeEndingTime
! PGEVersion
!
d434 23
a456 1
!    USE InitPCFs, ONLY: L2PCF
d458 1
a458 1
    !Arguments
d460 1
a460 2
    INTEGER :: HDF_FILE
	 type(PCFData_T) :: l2pcf
d462 2
a463 14
    !Local Variables
 
    INTEGER :: hdfReturn
    INTEGER :: returnStatus
    INTEGER :: sdid

    REAL(r8) dval
    INTEGER, PARAMETER :: INVENTORY=2, ARCHIVE=1
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: physical_filename
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: sval
    CHARACTER (LEN=132) :: attrname, errmsg
    INTEGER :: version, indx
    CHARACTER (LEN=*), PARAMETER :: METAWR_ERR = &
         'Error writing metadata attribute '
d470 17
a486 1
    CHARACTER (LEN = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d490 3
a492 3
    INTEGER, EXTERNAL :: pgs_met_init, pgs_met_setattr_d, &
         pgs_met_setAttr_s, pgs_met_getsetattr_d, PGS_MET_SETATTR_I, &
         pgs_met_write, pgs_met_remove
d499 1
a499 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN 
d504 1
a504 1
    ENDIF
d510 1
a510 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d515 1
a515 1
    ENDIF
d517 2
a518 2
! Start, Stop orbit numbers: level one has actual calculated numbers
! but, for now at least, we'll not trouble
d522 1
a522 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d527 1
a527 1
    ENDIF
d532 1
a532 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d537 1
a537 1
    ENDIF
d542 1
a542 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d547 1
a547 1
    ENDIF
d552 1
a552 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d557 1
a557 1
    ENDIF
d563 1
a563 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d568 1
a568 1
    ENDIF
d571 1
a571 1
    
d575 1
a575 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d580 1
a580 1
    ENDIF
d582 1
a582 1
       ! Locality Value
d584 80
a663 80
       attrName = 'LocalityValue'
       returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
            'Limb')
       IF (returnStatus /= PGS_S_SUCCESS) THEN
       !   errmsg = METAWR_ERR // attrName
!          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
      call announce_error(0, &
      & "Error in writing LocalityValue attribute.") 
       ENDIF

       ! VerticalSpatialDomain Product-Specific Attribute
       
       attrName = 'VerticalSpatialDomainType' // '.1'
       returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
            'Atmosphere Layer')
       IF (returnStatus /= PGS_S_SUCCESS) THEN
       !   errmsg = METAWR_ERR // attrName
!          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
      call announce_error(0, &
      & "Error in writing VerticalSpatialDomainType attribute.") 
       ENDIF

       attrName = 'VerticalSpatialDomainValue' // '.1'
       returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
            'Brightness Temperature')
       IF (returnStatus /= PGS_S_SUCCESS) THEN
       !   errmsg = METAWR_ERR // attrName
!          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
      call announce_error(0, &
      & "Error in writing VerticalSpatialDomainValue attribute.") 
       ENDIF

       ! HorizontalSpatialDomainContainer

       attrName = 'ZoneIdentifier'
       returnStatus = pgs_met_setAttr_s (groups(INVENTORY), attrName, &
            'Other Grid System')
       IF (returnStatus /= PGS_S_SUCCESS) THEN
       !   errmsg = METAWR_ERR // attrName
!          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
      call announce_error(0, &
      & "Error in writing ZoneIdentifier attribute.") 
       ENDIF

       attrName = 'WestBoundingCoordinate'
       dval = -180.0
       returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
       IF (returnStatus /= PGS_S_SUCCESS) THEN
       !   errmsg = METAWR_ERR // attrName
!          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
      call announce_error(0, &
      & "Error in writing WestBoundingCoordinate attribute.") 
       ENDIF

       attrName = 'NorthBoundingCoordinate'
       dval = 90.0
       returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
       IF (returnStatus /= PGS_S_SUCCESS) THEN
       !   errmsg = METAWR_ERR // attrName
!          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
      call announce_error(0, &
      & "Error in writing NorthBoundingCoordinate attribute.") 
       ENDIF

       attrName = 'EastBoundingCoordinate'
       dval = 180.0
       returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
       IF (returnStatus /= PGS_S_SUCCESS) THEN
       !   errmsg = METAWR_ERR // attrName
!          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
      call announce_error(0, &
      & "Error in writing EastBoundingCoordinate attribute.") 
       ENDIF

       attrName = 'SouthBoundingCoordinate'
       dval = -90.0
       returnStatus = pgs_met_setAttr_d (groups(INVENTORY), attrName, dval)
       IF (returnStatus /= PGS_S_SUCCESS) THEN
       !   errmsg = METAWR_ERR // attrName
!          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d665 2
a666 2
      & "Error in writing SouthBoundingCoordinate attribute.") 
       ENDIF
d675 1
a675 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN 
d680 1
a680 1
    ENDIF
d684 1
a684 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN 
d689 1
a689 1
    ENDIF
d693 1
a693 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN 
d698 1
a698 1
    ENDIF
d702 1
a702 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN 
d707 1
a707 1
    ENDIF
d710 1
a710 1
    
d714 1
a714 1
    IF (returnStatus /= PGS_S_SUCCESS) THEN
d719 1
a719 1
    ENDIF
d723 1
a723 1
    IF (sdid == -1) THEN
d728 1
a728 1
    ENDIF
d732 16
a747 16
    IF (returnStatus /= PGS_S_SUCCESS .AND. &
         returnStatus /= PGSMET_W_METADATA_NOT_SET) THEN 
       IF (returnStatus == PGSMET_W_METADATA_NOT_SET) THEN 
!          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!               "Some of the mandatory parameters were not set" )
      call announce_error(0, &
      & "Error: some of the mandatory parameters not set.") 
       ELSE 
!          CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
!          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!               "Metadata write failed "//attrname//errmsg) 
      call announce_error(0, &
      & "Error: metadata write failed in third_grouping.", &
      & error_number=returnStatus) 
       ENDIF
    ENDIF
d753 1
a753 1
  END SUBROUTINE third_grouping
d755 1
a755 1
!--------------------------- populate_metadata_std -------------------
d757 2
a758 2
  SUBROUTINE populate_metadata_std (HDF_FILE, MCF_FILE, &
  & l2pcf, field_name, metadata_error)
d760 8
a767 8
! This is the standard way to write meta data
! It should work unchanged for the standard l2gp files (e.g. BrO)
! and, with minor changes, for the l2gp file marked "other"
!
! the l2aux files, also called dgm
! and the dgg files will probably require special treatment
! the log file should be able to use the one stolen from level 3
!
d769 1
a769 1
!    USE InitPCFs, ONLY: L2PCF
d773 4
a776 4
    INTEGER :: HDF_FILE, MCF_FILE
	 type(PCFData_T) :: l2pcf
	 character (LEN=*) :: field_name
		integer, optional, intent(out) :: metadata_error
d779 12
a790 12
 
    INTEGER :: hdfReturn
    INTEGER :: returnStatus
    INTEGER :: sdid
    CHARACTER (LEN=132) :: attrname, errmsg

    INTEGER, PARAMETER :: INVENTORY=2, ARCHIVE=1
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: physical_filename
!    CHARACTER (LEN=132) :: attrname, errmsg
    INTEGER :: version
    CHARACTER (LEN=*), PARAMETER :: METAWR_ERR = &
         'Error writing metadata attribute '
d797 1
a797 1
    CHARACTER (LEN = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d801 3
a803 3
    INTEGER, EXTERNAL :: pgs_met_init, pgs_met_setattr_d, &
         pgs_met_setAttr_s, pgs_met_getsetattr_d, PGS_MET_SETATTR_I, &
         pgs_met_write, pgs_met_remove
d807 2
a808 2
   module_error = 0
	if(present(metadata_error)) metadata_error=1
d811 5
a815 5
	 IF(MCF_FILE > 0) then
	    returnStatus = PGS_PC_GetReference (MCF_FILE, version , physical_filename)
	else
		returnStatus = PGSPC_W_NO_REFERENCE_FOUND
	endif
d817 3
a819 3
	if(returnStatus /= PGS_S_SUCCESS) then
!       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!            "Failed to find the PCF reference for MCF_FILE in populate_metadata_std" ) 
d822 2
a823 2
			return
    ENDIF
d828 3
a830 3
	if(returnStatus /= PGS_S_SUCCESS) then
!       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!            "Failed to find the PCF reference for HDF_FILE in populate_metadata_std" ) 
d833 2
a834 2
			return
    ENDIF
d836 3
a838 3
	call first_grouping(HDF_FILE, MCF_FILE, l2pcf, groups)
	call measured_parameter (HDF_FILE, field_name, groups, 1)
	call third_grouping (HDF_FILE, l2pcf, groups)
d842 1
a842 1
    IF (sdid == -1) THEN
d848 2
a849 2
				return
    ENDIF
d853 7
a859 7
    IF (returnStatus /= PGS_S_SUCCESS .AND. &
         returnStatus /= PGSMET_W_METADATA_NOT_SET) THEN 
       IF (returnStatus == PGSMET_W_METADATA_NOT_SET) THEN 
!          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!               "Some of the mandatory parameters were not set" )
      call announce_error(0, &
      & "Error--some of the mandatory parameters were not set") 
d861 11
a871 11
       ELSE 
          CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
               "Metadata write failed in populate_metadata_std " &
               & //trim(attrname)//trim(errmsg))
!      call announce_error(0, &
!      & "Error: metadata write failed in populate_metadata_std.", &
!      & error_number=returnStatus) 
!					return
       ENDIF
    ENDIF
d875 1
a875 1
! Annotate the file with the PCF
d877 1
a877 1
         CALL WritePCF2Hdr(physical_filename, l2pcf%anText)
d881 1
a881 1
	if(present(metadata_error)) metadata_error=module_error
d883 1
a883 1
  END SUBROUTINE populate_metadata_std
d885 1
a885 1
!--------------------------- populate_metadata_oth -------------------
d887 2
a888 2
  SUBROUTINE populate_metadata_oth (HDF_FILE, MCF_FILE, l2pcf, &
  & numquantitiesperfile, QuantityNames, metadata_error)
d890 3
a892 3
! This is specially to write meta data for heterogeneous files
! It should work unchanged for the 'OTH' l2gp files (e.g. ML2OTH.001.MCF)
! and, with minor changes, for the l2aux files 
d894 1
a894 1
!    USE InitPCFs, ONLY: L2PCF
d898 4
a901 4
    INTEGER :: HDF_FILE, MCF_FILE, numquantitiesperfile
	 type(PCFData_T) :: l2pcf
	 character (LEN=*), dimension(:) :: QuantityNames
		integer, optional, intent(out) :: metadata_error
d904 12
a915 12
 
    INTEGER :: hdfReturn
    INTEGER :: returnStatus
    INTEGER :: sdid
    CHARACTER (LEN=132) :: attrname, errmsg

    INTEGER, PARAMETER :: INVENTORY=2, ARCHIVE=1
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: physical_filename
!    CHARACTER (LEN=132) :: attrname, errmsg
    INTEGER :: version, indx
    CHARACTER (LEN=*), PARAMETER :: METAWR_ERR = &
         'Error writing metadata attribute '
d922 1
a922 1
    CHARACTER (LEN = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d926 3
a928 3
    INTEGER, EXTERNAL :: pgs_met_init, pgs_met_setattr_d, &
         pgs_met_setAttr_s, pgs_met_getsetattr_d, PGS_MET_SETATTR_I, &
         pgs_met_write, pgs_met_remove
d932 2
a933 2
   module_error = 0
	if(present(metadata_error)) metadata_error=1
d936 5
a940 5
	 IF(MCF_FILE > 0) then
	    returnStatus = PGS_PC_GetReference (MCF_FILE, version , physical_filename)
	else
		returnStatus = PGSPC_W_NO_REFERENCE_FOUND
	endif
d942 3
a944 3
	if(returnStatus /= PGS_S_SUCCESS) then
!       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!            "Failed to find the PCF reference for MCF_FILE in populate_metadata_oth" ) 
d947 2
a948 2
			return
    ENDIF
d953 3
a955 3
	if(returnStatus /= PGS_S_SUCCESS) then
!       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!            "Failed to find the PCF reference for HDF_FILE in populate_metadata_oth" ) 
d958 2
a959 2
			return
    ENDIF
d961 1
a961 1
	call first_grouping(HDF_FILE, MCF_FILE, l2pcf, groups)
d963 1
a963 1
	do indx=1, numquantitiesperfile
d965 2
a966 2
		call measured_parameter (HDF_FILE, &
		& QuantityNames(indx), groups, indx)
d968 1
a968 1
	enddo
d970 1
a970 1
	call third_grouping (HDF_FILE, l2pcf, groups)
d974 3
a976 3
    IF (sdid == -1) THEN
!       CALL MLSMessage (MLSMSG_Error, ModuleName, &
!            "Failed to open the hdf file "//physical_fileName ) 
d979 2
a980 2
				return
    ENDIF
d984 19
a1002 19
    IF (returnStatus /= PGS_S_SUCCESS .AND. &
         returnStatus /= PGSMET_W_METADATA_NOT_SET) THEN 
       IF (returnStatus == PGSMET_W_METADATA_NOT_SET) THEN 
!          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!               "Some of the mandatory parameters were not set" )
      call announce_error(0, &
      & "Error: Some of the mandatory parameters were not set in populate_metadata_oth.") 
!					return
       ELSE 
          CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
               "Metadata write failed in populate_metadata_oth " &
               & //trim(attrname)//trim(errmsg))
!      call announce_error(0, &
!      & "Error: metdata write failed in populate_metadata_oth.", &
!      & error_number=returnStatus) 
!					return
       ENDIF
    ENDIF
d1008 1
a1008 1
         CALL WritePCF2Hdr(physical_filename, l2pcf%anText)
d1012 1
a1012 1
	if(present(metadata_error)) metadata_error=module_error
d1014 1
a1014 1
  END SUBROUTINE populate_metadata_oth
d1016 1
a1016 1
!--------------------------- get_l2gp_mcf -------------------
d1018 1
a1018 1
  SUBROUTINE get_l2gp_mcf (file_base, mcf, l2pcf, version)
d1020 7
a1026 7
! metadata configuration file (mcf) PCF number corresponding to l2gp number sdid
!
! Arguments
	character(len=*), intent(in) ::  file_base
	integer, intent(in), optional :: version
	integer, intent(inout) ::        mcf
	 type(PCFData_T) :: l2pcf
d1029 19
a1047 19
	character (len=PGSd_PC_FILE_PATH_MAX) :: sd_full
	character (len=NameLen) :: sd_path
	character (len=NameLen) :: sd_name

	character (len=PGSd_PC_FILE_PATH_MAX) :: mcf_full
	character (len=NameLen) :: mcf_path
	character (len=NameLen) :: mcf_name
	character (len=NameLen) :: mcf_pattern
	integer :: returnStatus, myVersion, i

	character (len=1), parameter :: COMMA = ','

	! Find species name
	! assume sd_name is "*l2gp_species_"
	! hence enclosed between "_" chars after an l2gp

	character (len=1), parameter :: species_delimiter = '_'
	character (len=4), parameter :: l2gp = 'l2gp'
   logical, parameter :: DEBUG = .false.
d1049 1
a1049 1
! Begin
d1051 1
a1051 1
   if(MCFFORL2GPOPTION == 1) then
d1054 1
a1054 1
   endif
d1056 1
a1056 1
   if(DEBUG) then
d1059 15
a1073 1
   endif
d1075 1
a1075 4
	if(len(TRIM(file_base)) <= 0) then
		mcf=0
		return
	endif
d1077 3
a1079 8
	! Get full file name for typical MCF file
	do i=mlspcf_mcf_l2gp_start, mlspcf_mcf_l2gp_end
	
		if(present(version)) then
			myVersion=version
		else
			myVersion = 1
		endif
d1081 1
a1081 7
		returnStatus = PGS_PC_GetReference(i, myVersion , mcf_full)
	
		if (returnStatus == PGS_S_SUCCESS) then 
			exit
		endif
		
	enddo
d1083 1
a1083 1
   if(DEBUG) then
d1086 6
a1091 1
   endif
d1093 1
a1093 4
	if (returnStatus /= PGS_S_SUCCESS) then 
		mcf = 0
		return
	endif
d1095 1
a1095 3
	! Split full_file_names into path+name
	
	call split_path_name(mcf_full, mcf_path, mcf_name)
d1098 8
a1105 8
   if(.NOT. MCFCASESENSITIVE) then
   	sd_full = LowerCase(file_base)
	   mcf_name = LowerCase(mcf_name)
   else
   	sd_full = file_base
   endif
   
   if(DEBUG) then
d1112 1
a1112 1
   endif
d1114 4
a1117 4
	! Get species name assuming e.g. '*l2gp_h2o'
	call split_path_name(sd_full, sd_path, sd_name, species_delimiter)
	
   if(DEBUG) then
d1124 1
a1124 1
   endif
d1126 4
a1129 4
	if(len(trim(sd_name)) <= 0) then
		mcf=0
		return
	endif
d1131 1
a1131 1
   if(MCFFORL2GPOPTION == 3) then
d1133 18
a1150 18
   ! get mcfspecies name from associative array
   ! if the species name not found in spec_keys, it will return ','
      call GetStringHashElement(l2pcf%spec_keys, l2pcf%spec_hash, &
      & trim(sd_name), sd_full, .TRUE.)

     if(DEBUG) then
       call output('keys: ', advance='no')
       call output(trim(l2pcf%spec_keys), advance='yes')
       call output('hash: ', advance='no')
       call output(trim(l2pcf%spec_hash), advance='yes')
       call output('hash for species name: ', advance='no')
       call output(trim(sd_full), advance='yes')
    endif

      if(trim(sd_full) == COMMA) then
         mcf=0
         return
      endif
d1154 8
a1161 1
   endif
d1163 1
a1163 2
	! Now try to find mcf file corresponding to species name
	! assuming, e.g. '*h2o.*'
d1165 35
a1199 11
     if(DEBUG) then
       call output('loop over mcf files', advance='yes')
   endif
   
	do i=mlspcf_mcf_l2gp_start, mlspcf_mcf_l2gp_end
	
		if(present(version)) then
			myVersion=version
		else
			myVersion = 1
		endif
d1201 1
a1201 31
		returnStatus = PGS_PC_GetReference(i, myVersion, mcf_full)
	
		if (returnStatus == PGS_S_SUCCESS) then 
			call split_path_name(mcf_full, mcf_path, mcf_name)
			
			! This gives 'o2h*'
			call split_path_name(Reverse(mcf_name), mcf_path, mcf_pattern, '.')
         if(.NOT. MCFCASESENSITIVE) then
		   	mcf_pattern = LowerCase(mcf_pattern)
         endif

			! So reverse it to make h2o
			mcf_pattern = adjustl(Reverse(mcf_pattern))
			
     if(DEBUG) then
       call output('mcf_pattern: ', advance='no')
       call output(trim(mcf_pattern), advance='yes')
      endif
			! Check that pattern matches species name
         ! Warning--this could give a false matching
         ! if the species name matches more than one mcf_pattern
         ! May wish to check for multiple matches later
			if(index(trim(mcf_pattern), trim(sd_name)) > 0) then
				mcf = i
				return
			endif
		endif
		
	enddo
	
	mcf = 0
d1203 1
a1203 1
  END SUBROUTINE get_l2gp_mcf
d1207 2
a1208 3
!-------------------------------
   SUBROUTINE WriteMetaLog (pcf, metadata_error)
!-------------------------------
d1210 2
a1211 2
! Brief description of subroutine
! This subroutine writes metadata for the log file to a separate ASCII file.
d1213 1
a1213 1
! Arguments
d1215 2
a1216 2
      TYPE( PCFData_T ), INTENT(IN) :: pcf
		integer, optional, intent(out) :: metadata_error
d1218 2
a1219 2
! Parameters
!     These are PCF numbers that *must* be in the PCF file
d1221 2
a1222 2
      INTEGER, PARAMETER :: ASCII_FILE = 101
      INTEGER, PARAMETER :: THE_LOG_FILE = 100
d1224 1
a1224 1
! Functions
d1226 3
a1228 3
      INTEGER, EXTERNAL :: pgs_met_init, pgs_met_remove, pgs_met_setAttr_d
      INTEGER, EXTERNAL :: pgs_met_setAttr_s, pgs_met_write
    integer, external :: pgs_pc_getconfigdata
d1230 1
a1230 1
! Internal
d1232 6
a1237 6
      CHARACTER (LEN=1) :: nullStr
      CHARACTER (LEN=45) :: sval
      CHARACTER (LEN=32) :: mnemonic
      CHARACTER (LEN=FileNameLen) :: physical_filename
      CHARACTER (LEN=480) :: msg, msr
      CHARACTER (LEN=PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
d1239 2
a1240 2
      INTEGER :: result, indx, version
		logical, parameter :: DEBUG=.FALSE.
d1242 3
a1244 3
   ! Begin
   module_error = 0
	if(present(metadata_error)) metadata_error=1
d1246 1
a1246 1
      nullStr = ''
d1249 2
a1250 1
    result = PGS_PC_GetReference (mlspcf_mcf_l2log_start, version , physical_filename)
d1252 1
a1252 1
	if(result /= PGS_S_SUCCESS) then
d1254 1
a1254 1
!            "Failed to find the PCF reference for the Log mcf in WriteMetaLog" ) 
d1256 3
a1258 3
      & "Error: failed to find PCF ref for Log mcf in WriteMetaLog.") 
			return
    ENDIF
d1260 2
a1261 2
! Check that the PCF file contains the entries for the ASCII file
! and for the log file itself
d1266 3
a1268 3
	if(result /= PGS_S_SUCCESS) then
!       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!            "Failed to find the PCF reference for the ASCII in WriteMetaLog" ) 
d1270 3
a1272 3
      & "Error: failed to find PCF ref for the ASCII in WriteMetaLog.") 
			return
    ENDIF
d1277 3
a1279 3
	if(result /= PGS_S_SUCCESS) then
!       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
!            "Failed to find the PCF reference for the LOG in WriteMetaLog" ) 
d1281 3
a1283 3
      & "Error: failed to find PCF ref for the Log in WriteMetaLog.") 
			return
    ENDIF
d1287 8
a1294 9
	if(DEBUG) then
		call output('Initialize the MCF file', &
		&  advance='yes')
	endif

      result = pgs_met_init(mlspcf_mcf_l2log_start, groups)
      IF (result /= PGS_S_SUCCESS) then
!			CALL MLSMessage(MLSMSG_Error, ModuleName, &
!                          'Initialization error.  See LogStatus for details.')
d1297 2
a1298 2
			return
		endif
d1302 2
a1303 2
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalGranuleID", &
                                 pcf%logGranID)
d1305 3
a1307 3
      CALL ExpandFileTemplate('$cycle', sval, cycle=pcf%cycle)
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalVersionID", &
                                 sval)
d1311 10
a1320 10
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeBeginningDate", PCF%startUTC(1:indx-1))
!      sval= '00:00:00.000000'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeBeginningTime", PCF%startUTC(indx+1:))
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeEndingDate", PCF%endUTC(1:indx-1))
!      sval= '23:59:59.999999'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeEndingTime", PCF%endUTC(indx+1:))
d1322 2
a1323 2
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "PGEVersion", &
                                 pcf%PGEVersion)
d1325 1
a1325 1
      IF (result /= PGS_S_SUCCESS) THEN
d1331 3
a1333 3
      &  error_number=result) 
			return
      ENDIF
d1335 1
a1335 1
! Write the metadata and their values to an ASCII file
d1337 6
a1342 4
	if(DEBUG) then
		call output('Write the metadata and their values to an ASCII file', &
		&  advance='yes')
	endif
d1344 10
a1353 1
      result = pgs_met_write(groups(1), nullStr, ASCII_FILE)
d1355 1
a1355 10
      IF (result /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(result, mnemonic, msg)
         msr = "Error: failed to write metadata in WriteMetaLog." &
         & // trim(mnemonic) // ':  ' // trim(msg)
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
!      call announce_error(0, &
!      & "Error: failed to write metadata in WriteMetaLog.", &
!      & error_number=result) 
!			return
      ENDIF
d1357 1
a1357 1
      result = pgs_met_remove()
d1359 1
a1359 1
	if(present(metadata_error)) metadata_error=module_error
d1361 3
a1363 3
!-----------------------------
   END SUBROUTINE WriteMetaLog
!-----------------------------
d1365 4
a1368 4
!-----------------------------------------------------------------------------
   SUBROUTINE ExpandFileTemplate (template, filename, level, version, cycle, &
                                  day)
!-----------------------------------------------------------------------------
d1370 1
a1370 3
! Brief description of subroutine
! This subroutine expands the version, cycle, and day fields in a file name
! template.  Note: CYCLE is a STRING here, which is how it's read from the PCF.
d1372 1
a1372 1
! Arguments
d1374 1
a1374 1
      CHARACTER (LEN=*), INTENT(IN) :: template
d1376 1
a1376 1
      CHARACTER (LEN=*), INTENT(IN), OPTIONAL :: cycle, day, level, version
d1378 1
a1378 1
      CHARACTER (LEN=*), INTENT(OUT) :: fileName
d1380 1
a1380 1
! Parameters
d1382 1
a1382 1
! Functions
d1384 1
a1384 1
! Variables
d1386 1
a1386 1
      CHARACTER (LEN=4) :: field, zCy
d1388 1
a1388 1
      INTEGER :: i, iCy, indx, numFields
d1390 1
a1390 1
! Initializations
d1392 1
a1392 1
      numFields = 4
d1394 1
a1394 1
      fileName = template
d1396 1
a1396 1
! Loop through the expandable fields in the template
d1398 1
a1398 1
      DO i = 1, numFields
d1400 1
a1400 1
! Search for $
d1402 1
a1402 1
         indx = INDEX(fileName,'$')
d1404 1
a1404 1
! Exit, if there are no expandable fields 
d1406 1
a1406 1
         IF (indx == 0) EXIT
d1408 1
a1408 1
! Match the field name to the input argument
d1410 1
a1410 3
         field = fileName(indx:indx+3)
    
         IF (field == '$lev') THEN
d1412 7
a1418 7
            IF ( PRESENT(level) ) THEN
               fileName = fileName(:(indx-1)) // TRIM(level) // &
                          fileName((indx+6):)
            ELSE
               CALL MLSMessage(MLSMSG_Error, ModuleName, 'Input level &
                                            &required to expand the template.')
            ENDIF
d1420 1
a1420 1
         ELSE IF (field == '$ver') THEN
d1422 7
a1428 7
            IF ( PRESENT(version) ) THEN
               fileName = fileName(:(indx-1)) // TRIM(version) // &
                          fileName((indx+8):)
            ELSE
               CALL MLSMessage(MLSMSG_Error, ModuleName, 'Input version &
                                            &required to expand the template.')
            ENDIF
d1430 1
a1430 1
         ELSE IF (field == '$cyc') THEN
d1432 1
a1432 1
            IF ( PRESENT(cycle) ) THEN
d1434 1
a1434 1
! Convert from CHARACTER to INTEGER
d1436 1
a1436 1
               READ(cycle, '(I2)') iCy
d1438 1
a1438 1
! Add a leading zero, if less than 10
d1440 5
a1444 5
               IF (iCy < 10) THEN
                  zCy = '0' // TRIM(cycle)
               ELSE 
                  zCy = cycle
               ENDIF
d1446 2
a1447 2
               fileName = fileName(:(indx-1)) // 'C' // TRIM(zCy) // &
                          fileName((indx+6):)
d1449 1
a1449 1
            ELSE
d1451 2
a1452 2
               CALL MLSMessage(MLSMSG_Error, ModuleName, 'Input cycle &
                                            &required to expand the template.')
d1454 1
a1454 1
            ENDIF
d1456 1
a1456 1
         ELSE IF (field == '$day') THEN
d1458 7
a1464 7
            IF ( PRESENT(day) ) THEN
               fileName = fileName(:(indx-1)) // TRIM(day) // &
                          fileName((indx+4):)
            ELSE
               CALL MLSMessage(MLSMSG_Error, ModuleName, 'Input day required &
                                                    &to expand the template.')
            ENDIF
d1466 1
a1466 1
         ENDIF
d1468 1
a1468 1
      ENDDO
d1470 1
a1470 3
!-----------------------------------
   END SUBROUTINE ExpandFileTemplate
!-----------------------------------
d1475 1
a1475 1
  
d1486 1
a1486 1
    CHARACTER (LEN=132) :: attrname, errmsg
d1493 1
a1493 1
      module_error = max(module_error,1)
a1501 7
      call output ( ": The " );
      if ( lcf_where > 0 ) then
        call dump_tree_node ( lcf_where, 0 )
      else
        call output ( '(no lcf tree available)' )
      end if

d1510 2
a1511 2
        CALL Pgs_smf_getMsg (Toolbox_error_num, attrname, errmsg)
        CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
d1523 1
a1523 1
    
d1528 1
a1528 1
END MODULE WriteMetadata 
d1530 3
@


2.11
log
@Tiny change to announce_error
@
text
@d26 1
a26 1
   "$Id: write_meta.f90,v 2.10 2001/04/16 17:43:35 pwagner Exp $"
d58 6
a114 2
	INTEGER, PARAMETER :: INVENTORYMETADATA=2

d119 3
d201 1
a201 1
       errmsg = METAWR_ERR // attrName
d211 1
a211 1
       errmsg = METAWR_ERR // attrName
d222 1
a222 1
       errmsg = METAWR_ERR // attrName
d231 1
a231 1
       errmsg = METAWR_ERR // attrName
d241 1
a241 1
       errmsg = METAWR_ERR // attrName
d343 1
a343 1
       errmsg = METAWR_ERR // attrName
d355 1
a355 1
       errmsg = METAWR_ERR // attrName
d365 1
a365 1
       errmsg = METAWR_ERR // attrName
d375 1
a375 1
       errmsg = METAWR_ERR // attrName
d385 1
a385 1
       errmsg = METAWR_ERR // attrName
d396 1
a396 1
       errmsg = METAWR_ERR // attrName
d405 1
a405 1
       errmsg = METAWR_ERR // attrName
d414 1
a414 1
       errmsg = METAWR_ERR // attrName
d504 1
a504 1
       errmsg = METAWR_ERR // attrName
d516 1
a516 1
       errmsg = METAWR_ERR // attrName
d526 1
a526 1
       errmsg = METAWR_ERR // attrName
d536 1
a536 1
       errmsg = METAWR_ERR // attrName
d546 1
a546 1
       errmsg = METAWR_ERR // attrName
d557 1
a557 1
       errmsg = METAWR_ERR // attrName
d569 1
a569 1
       errmsg = METAWR_ERR // attrName
d581 1
a581 1
          errmsg = METAWR_ERR // attrName
d593 1
a593 1
          errmsg = METAWR_ERR // attrName
d603 1
a603 1
          errmsg = METAWR_ERR // attrName
d615 1
a615 1
          errmsg = METAWR_ERR // attrName
d625 1
a625 1
          errmsg = METAWR_ERR // attrName
d635 1
a635 1
          errmsg = METAWR_ERR // attrName
d645 1
a645 1
          errmsg = METAWR_ERR // attrName
d655 1
a655 1
          errmsg = METAWR_ERR // attrName
d708 1
a708 1
       errmsg = METAWR_ERR // attrName
d737 1
a737 1
      & "Error: metadata write failed in populate_metadata_std.", &
d751 1
a751 1
  & l2pcf, field_name, anText, metadata_error)
a768 1
      CHARACTER (LEN=1), POINTER :: anText(:)
d857 2
a858 1
               "Metadata write failed "//attrname//errmsg) 
d870 1
a870 1
         CALL WritePCF2Hdr(physical_filename, anText)
d881 1
a881 1
  & numquantitiesperfile, QuantityNames, anText, metadata_error)
a893 1
      CHARACTER (LEN=1), POINTER :: anText(:)
d988 2
a989 1
               "Metadata write failed "//attrname//errmsg) 
d1001 1
a1001 1
         CALL WritePCF2Hdr(physical_filename, anText)
a1048 2
!	if(sdid <= 0) then

a1058 15
	! Get full file name for l2gp file

!		if(present(version)) then
!			myVersion=version
!		else
!			myVersion = 1
!		endif

!	returnStatus = PGS_PC_GetReference(sdid, myVersion , sd_full)
	
!	if (returnStatus /= PGS_S_SUCCESS) then 
!		mcf = 0
!		return
!	endif

a1087 1
!	call split_path_name(sd_full, sd_path, sd_name)
d1094 2
a1106 7
!	i=index(mcf_name, l2gp)

!	if(i <= 0) then
!		mcf=0
!		return
!	endif
	
d1340 2
a1341 1
         msr = mnemonic // ':  ' // msg
d1535 3
@


2.10
log
@mcf text matching case sensitive if MCFCASESENSITIVE
@
text
@d26 1
a26 1
   "$Id: write_meta.f90,v 2.9 2001/04/13 23:47:26 pwagner Exp $"
d1503 1
a1503 1
    if ( present(use_toolkit) ) just_print_it = use_toolkit
d1550 3
@


2.9
log
@Writes multiple measuredcontainers properly
@
text
@d13 1
a13 1
USE MLSStrings 
d26 1
a26 1
   "$Id: write_meta.f90,v 2.8 2001/04/13 00:28:03 pwagner Exp $"
d60 1
a60 1
	! Either
d67 1
a67 1
	! This hateful inflexibility leads to possibility
d93 3
d112 2
d1101 6
a1106 3
	sd_full = LowerCase(file_base)
	mcf_name = LowerCase(mcf_name)
	
d1187 4
a1190 2
			mcf_pattern = LowerCase(mcf_pattern)
			
d1550 3
@


2.8
log
@Turned get_l2gp_mcf into a subroutine
@
text
@d26 1
a26 1
   "$Id: write_meta.f90,v 2.7 2001/04/12 00:22:17 pwagner Exp $"
d108 1
a108 1
    integer, parameter :: MCFFORL2GPOPTION=1		! Either 1 or 2
d239 1
a239 1
  SUBROUTINE measured_parameter (HDF_FILE, field_name, groups)
d261 1
d266 1
d314 9
d328 1
a328 1
    attrName = 'ParameterName' // '.1'
d339 1
a339 1
    attrName = 'AutomaticQualityFlag' // '.1'
d349 1
a349 1
    attrName = 'AutomaticQualityFlagExplanation' // '.1'
d359 1
a359 1
    attrName = 'OperationalQualityFlag' // '.1'
d369 1
a369 1
    attrName = 'OperationalQualityFlagExplanation' // '.1'
d381 1
a381 1
    attrName = 'QAPercentInterpolatedData' // '.1'
d390 1
a390 1
    attrName = 'QAPercentMissingData' // '.1'
d399 1
a399 1
    attrName = 'QAPercentOutofBoundsData' // '.1'
d819 1
a819 1
	call measured_parameter (HDF_FILE, field_name, groups)
d948 1
a948 1
		& QuantityNames(indx), groups)
d1028 1
d1038 6
d1081 5
d1099 9
d1118 9
d1139 9
d1160 4
d1184 4
d1192 1
a1192 1
			if(index(mcf_pattern, sd_name) > 0) then
d1540 3
@


2.7
log
@Added announce_error
@
text
@d26 1
a26 1
   "$Id: write_meta.f90,v 2.6 2001/04/11 20:20:37 pwagner Exp $"
d754 1
d833 6
a838 6
!          CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
!          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!               "Metadata write failed "//attrname//errmsg) 
      call announce_error(0, &
      & "Error: metadata write failed in populate_metadata_std.", &
      & error_number=returnStatus) 
d879 1
d964 6
a969 6
!          CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
!          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
!               "Metadata write failed "//attrname//errmsg) 
      call announce_error(0, &
      & "Error: metdata write failed in populate_metadata_oth.", &
      & error_number=returnStatus) 
d988 1
a988 1
  FUNCTION get_l2gp_mcf (sdid, version) RESULT(mcf)
d993 1
a993 1
	integer, intent(in) :: sdid
d995 3
a997 1
	integer :: mcf
a998 1

d1009 2
d1020 7
a1026 1
	if(sdid <= 0) then
d1033 5
a1037 5
		if(present(version)) then
			myVersion=version
		else
			myVersion = 1
		endif
d1039 1
a1039 1
	returnStatus = PGS_PC_GetReference(sdid, myVersion , sd_full)
d1041 4
a1044 4
	if (returnStatus /= PGS_S_SUCCESS) then 
		mcf = 0
		return
	endif
d1070 1
a1070 1
	call split_path_name(sd_full, sd_path, sd_name)
d1073 1
a1073 1
	sd_name = LowerCase(sd_name)
d1076 1
a1076 1
	i=index(mcf_name, l2gp)
d1078 4
a1081 4
	if(i <= 0) then
		mcf=0
		return
	endif
d1083 2
a1084 15
	! Get species name assuming e.g. '*l2gp_h2o_*'
	sd_full = adjustl(sd_name(i+len(l2gp):))
	
	i=index(sd_full, species_delimiter)

	if(i /= 1) then
		mcf=0
		return
	endif

	! This gives 'o2h'
	call split_path_name(Reverse(sd_full(2:)), sd_path, sd_name, species_delimiter)
	
	! so reverse it -> 'h2o'
	sd_name = adjustl(Reverse(sd_name))
d1091 16
d1127 1
a1127 1
			! So reverse it
d1131 3
d1144 1
a1144 1
  END FUNCTION get_l2gp_mcf
d1176 1
a1176 1
!      CHARACTER (LEN=32) :: mnemonic
d1178 1
a1178 1
!      CHARACTER (LEN=480) :: msg, msr
d1182 1
a1182 1
		logical, parameter :: DEBUG=.TRUE.
d1287 6
a1292 6
!         call Pgs_smf_getMsg(result, mnemonic, msg)
!         msr = mnemonic // ':  ' // msg
!         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      call announce_error(0, &
      & "Error: failed to write metadata in WriteMetaLog.", &
      & error_number=result) 
d1482 3
@


2.6
log
@Checks correctly on PCF file before attempting LOG.met
@
text
@d5 4
d11 2
d14 1
a14 3
USE MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
USE L2GPData
USE L2AUXData
d17 1
a17 4
USE MLSPCF2
USE MLSCF 
USE Hdf 
USE HDFEOS 
d26 1
a26 1
   "$Id: write_meta.f90,v 2.5 2001/04/10 23:03:57 pwagner Exp $"
d36 2
d53 1
a53 1
     CHARACTER (LEN=15) :: outputVersion	! output files
d166 4
a169 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Error in getting ref for PCF number in 1st grouping.") 
d175 4
a178 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Initialization error.  See LogStatus for details.") 
d190 3
a192 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d200 3
a202 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d211 3
a213 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d220 3
a222 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d230 3
a232 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d294 4
a297 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Error in getting ref for PCF number in measured_parameter.") 
d321 3
a323 1
       CALL MLSMessage(MLSMSG_Error, ModuleName, errmsg)
d333 3
a335 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d343 3
a345 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d353 3
a355 1
       CALL MLSMessage(MLSMSG_Error, ModuleName, errmsg)
d363 3
a365 1
       CALL MLSMessage(MLSMSG_Error, ModuleName, errmsg)
d374 3
a376 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d383 3
a385 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d392 3
a394 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d470 4
a473 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Error in getting ref for PCF number in third_grouping.") 
d482 3
a484 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d494 3
a496 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d504 3
a506 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d514 3
a516 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d524 3
a526 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d535 3
a537 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d547 3
a549 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d559 3
a561 1
          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d571 3
a573 1
          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d581 3
a583 1
          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d593 3
a595 1
          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d603 3
a605 1
          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d613 3
a615 1
          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d623 3
a625 1
          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d633 3
a635 1
          CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d646 4
a649 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Error setting RangeBeginningDate")
d655 4
a658 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Error setting RangeBeginningTime")
d664 4
a667 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Error setting RangeEndingDate")
d673 4
a676 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Error setting RangeEndingTime")
d682 1
a682 1
    sval = L2PCF%OutputVersion
d686 3
a688 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, errmsg)
d694 4
a697 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Failed to open the hdf file "//physical_fileName ) 
d705 4
a708 2
          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
               "Some of the mandatory parameters were not set" )
d710 6
a715 3
          CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
               "Metadata write failed "//attrname//errmsg) 
d757 1
a757 1
    CHARACTER (LEN=132) :: attrname, errmsg
d777 1
d788 4
a791 2
       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
            "Failed to find the PCF reference for MCF_FILE in populate_metadata_std" ) 
d799 4
a802 2
       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
            "Failed to find the PCF reference for HDF_FILE in populate_metadata_std" ) 
d813 5
a817 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Failed to open the hdf file "//physical_fileName ) 
d826 5
a830 3
          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
               "Some of the mandatory parameters were not set" )
					return
d832 7
a838 4
          CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
               "Metadata write failed "//attrname//errmsg) 
					return
d850 1
a850 1
	if(present(metadata_error)) metadata_error=0
d881 1
a881 1
    CHARACTER (LEN=132) :: attrname, errmsg
d901 1
d912 4
a915 2
       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
            "Failed to find the PCF reference for MCF_FILE in populate_metadata_oth" ) 
d923 4
a926 2
       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
            "Failed to find the PCF reference for HDF_FILE in populate_metadata_oth" ) 
d944 4
a947 2
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
            "Failed to open the hdf file "//physical_fileName ) 
d956 5
a960 3
          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
               "Some of the mandatory parameters were not set" )
					return
d962 7
a968 4
          CALL Pgs_smf_getMsg (returnStatus, attrname, errmsg)
          CALL MLSMessage (MLSMSG_WARNING, ModuleName, &
               "Metadata write failed "//attrname//errmsg) 
					return
d980 1
a980 1
	if(present(metadata_error)) metadata_error=0
d1159 1
a1159 1
      CHARACTER (LEN=32) :: mnemonic
d1161 1
a1161 1
      CHARACTER (LEN=480) :: msg, msr
d1168 1
d1177 4
a1180 2
       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
            "Failed to find the PCF reference for the Log mcf in WriteMetaLog" ) 
d1191 4
a1194 2
       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
            "Failed to find the PCF reference for the ASCII in WriteMetaLog" ) 
d1202 4
a1205 2
       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
            "Failed to find the PCF reference for the LOG in WriteMetaLog" ) 
d1218 4
a1221 2
			CALL MLSMessage(MLSMSG_Error, ModuleName, &
                          'Initialization error.  See LogStatus for details.')
d1248 1
a1248 1
                                 pcf%outputVersion)
d1251 6
a1256 3
         call Pgs_smf_getMsg(result, mnemonic, msg)
         msr = mnemonic // ':  ' // msg
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1270 7
a1276 4
         call Pgs_smf_getMsg(result, mnemonic, msg)
         msr = mnemonic // ':  ' // msg
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
			return
d1281 1
a1281 1
	if(present(metadata_error)) metadata_error=0
d1400 63
d1465 3
@


2.5
log
@Finally seems to work
@
text
@d25 1
a25 1
   "$Id: write_meta.f90,v 2.4 2001/04/09 23:45:47 pwagner Exp $"
d1035 1
d1038 1
d1044 1
d1072 12
d1085 1
a1085 1
    result = PGS_PC_GetReference (ASCII_FILE, version , physical_filename)
d1089 1
a1089 1
            "Failed to find the PCF reference for the Log in WriteMetaLog" ) 
d1278 3
@


2.4
log
@Deleted unused old populate_metadata; some fixes
@
text
@d8 1
a8 1
USE MLSMessageModule
d25 1
a25 1
   "$Id: write_meta.f90,v 2.3 2001/04/03 23:51:28 pwagner Exp $"
d29 6
d44 4
d55 42
d105 2
a248 1
    REAL(r8) dval
d644 1
a644 1
  & l2pcf, field_name, anText)
d663 1
a663 1

d693 15
d712 1
a712 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
d726 1
d736 1
d741 1
d753 2
d760 1
a760 1
  & numquantitiesperfile, QuantityNames, anText)
d774 1
a774 1

d804 15
d823 1
a823 1
       CALL MLSMessage (MLSMSG_Error, ModuleName, &
d844 1
d854 1
d859 1
d871 2
d1023 1
a1023 1
   SUBROUTINE WriteMetaLog (pcf)
d1032 1
d1043 1
a1043 1
! Variables
d1048 1
d1052 5
a1056 1
      INTEGER :: result, indx
d1060 18
d1080 5
d1121 1
d1126 5
d1137 1
d1142 2
d1263 3
@


2.3
log
@Many changes; some may be right
@
text
@d25 1
a25 1
   "$Id: write_meta.f90,v 2.2 2001/04/02 23:42:18 pwagner Exp $"
a54 186
SUBROUTINE populate_metadata(HDF_FILE, MCF_FILE)

! This was the version 0.1 way to write the metadata file(s)

!It was superseded in v.0.5 by populate_metadata_std and others

!Arguments

INTEGER :: HDF_FILE, MCF_FILE

!Local Variables 
INTEGER :: pgs_met_init
INTEGER :: pgs_met_setattr_d
INTEGER :: pgs_met_setAttr_s
INTEGER :: pgs_met_getsetattr_d
INTEGER :: pgs_met_getsetattr_s
INTEGER :: pgs_met_write
INTEGER :: pgs_met_getpcattr_d
INTEGER :: pgs_met_getconfigdata_d
INTEGER :: pgs_met_getconfigdata_s
INTEGER :: pgs_met_remove
INTEGER :: hdfReturn
INTEGER :: returnStatus
INTEGER :: sdid
INTEGER :: access
INTEGER :: sfstart
INTEGER :: sfend

REAL(r8) dval
INTEGER, PARAMETER :: INVENTORY=2,ARCHIVE=1
CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: physical_filename, hdfeos_filename 
CHARACTER (LEN=27) :: datetime, sval
CHARACTER (LEN=32) :: mnemonic, msg
INTEGER :: version
! the group have to be defined as 49 characters long. The C interface is 50.

! The cfortran.h mallocs an extra 1 byte for the null character '\0/1, 
! therefore making the actual length of a 
! string pass of 50.

CHARACTER (LEN = PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
!Executable code

version = 1
returnStatus = PGS_PC_GetReference(HDF_FILE, version , physical_filename)

returnStatus = pgs_met_init(MCF_FILE, groups)

IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Initialization error.") 
ENDIF


sval = 'Horizontal & Vertical'
returnStatus = pgs_met_setAttr_s(groups(INVENTORY), &
                         "GranuleSpatialDomainType", sval)
IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Error setting GranuleSpatialDomainType")
ENDIF

sval = '2000-01-01'
returnStatus = pgs_met_setAttr_s(groups(INVENTORY), &
                         "RangeBeginningDate", sval)

IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Error setting RangeBeginningDate")
ENDIF

sval= '00:00:00.000000'
returnStatus = pgs_met_setAttr_s(groups(INVENTORY), &
                         "RangeBeginningTime", sval)
IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Error setting RangeBeginningTime")
ENDIF

sval = '2000-01-01'
returnStatus = pgs_met_setAttr_s(groups(INVENTORY), "RangeEndingDate", &
                          sval)
IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Error setting RangeEndingDate")
ENDIF

sval= '23:59:59.999999'
returnStatus = pgs_met_setAttr_s(groups(INVENTORY), "RangeEndingTime", &
                          sval)
IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Error setting RangeEndingTime")
ENDIF


sval = 'Other Grid System'
returnStatus = pgs_met_setAttr_s(groups(INVENTORY), "ZoneIdentifier", &
                          sval)
IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Error setting ZoneIdentifier")
ENDIF



dval = -180.0

returnStatus = pgs_met_setattr_d(groups(INVENTORY),& 
                                "WestBoundingCoordinate",dval)

IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Error setting WestBoundingCoordinate")
ENDIF
 
dval = -180.0
returnStatus = PGS_MET_GetSetAttr_d(groups(INVENTORY),&
                                  "WestBoundingCoordinate",dval)
IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "WestBoundingCoordinate") 
ENDIF 

dval = 90.0

returnStatus = pgs_met_setattr_d(groups(INVENTORY),&
                                "NorthBoundingCoordinate",dval)
IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "NorthBoundingCoordinate.") 
ENDIF

dval = 90.0

returnStatus = PGS_MET_GetSetAttr_d(groups(INVENTORY),&
                                   "NorthBoundingCoordinate",dval)

IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "NorthBoundingCoordinate") 
ENDIF

dval = 180.0
returnStatus = pgs_met_setattr_d(groups(INVENTORY),&
                                "EastBoundingCoordinate",dval)

IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "EastBoundingCoordinate") 
ENDIF
dval = 180.0
returnStatus = PGS_MET_GetSetAttr_d(groups(INVENTORY),&
                                   "EastBoundingCoordinate",dval)
IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "EastBoundingCoordinate") 
ENDIF

dval =-90.0 
returnStatus = pgs_met_setattr_d(groups(INVENTORY),&
&                               "SouthBoundingCoordinate",dval)

IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "SouthBoundingCoordinate") 
ENDIF

dval = -90.0
returnStatus = PGS_MET_GetSetAttr_d(groups(INVENTORY),&
                                   "SouthBoundingCoordinate",dval)

IF (returnStatus /= PGS_S_SUCCESS) THEN 
     CALL MLSMessage (MLSMSG_Error, ModuleName, "SouthBoundingCoordinate") 
ENDIF

sdid = sfstart(physical_fileName, DFACC_RDWR) 

IF (sdid == -1) THEN
     CALL MLSMessage (MLSMSG_Error, ModuleName, "Failed to open the hdf file" ) 
ENDIF

returnStatus = pgs_met_write(groups(INVENTORY),&
                            "coremetadata.0", sdid)

IF (returnStatus /= PGS_S_SUCCESS .AND. &
    returnStatus /= PGSMET_W_METADATA_NOT_SET) THEN 
   IF (returnStatus == PGSMET_W_METADATA_NOT_SET) THEN 
     CALL MLSMessage (MLSMSG_WARNING, ModuleName, "Some of the mandatory parameters were not set" )
   ELSE 
     CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
     CALL MLSMessage (MLSMSG_WARNING, ModuleName,"Metadata write failed "//mnemonic// msg) 
   ENDIF
ENDIF

hdfReturn = sfend(sdid)

returnStatus=pgs_met_remove() 
END SUBROUTINE populate_metadata

a79 1
    INTEGER :: hdfReturn
a80 1
    INTEGER :: sdid
a81 1
    REAL(r8) dval
d86 1
a86 1
    INTEGER :: version, ival, indx
d108 5
a156 2
!    READ (L2PCF%Cycle, '(I3)') ival
!    WRITE (sval, '("C", i2.2)') ival
d168 1
a168 1
  SUBROUTINE measured_parameter (HDF_FILE, MCF_FILE, l2pcf, field_name, groups)
d188 1
a188 2
    INTEGER :: HDF_FILE, MCF_FILE
	 type(PCFData_T) :: l2pcf
a192 1
    INTEGER :: hdfReturn
a193 1
    INTEGER :: sdid
d200 1
a200 1
    INTEGER :: version, ival, indx
d222 6
d313 1
a313 1
  SUBROUTINE third_grouping (HDF_FILE, MCF_FILE, l2pcf, groups)
d345 1
a345 1
    INTEGER :: HDF_FILE, MCF_FILE
d359 1
a359 1
    INTEGER :: version, ival, indx
d381 5
a617 1
    REAL(r8) dval
a619 1
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: sval
d621 1
a621 1
    INTEGER :: version, ival, indx
d643 6
d650 2
a651 2
	call measured_parameter (HDF_FILE, MCF_FILE, l2pcf, field_name, groups)
	call third_grouping (HDF_FILE, MCF_FILE, l2pcf, groups)
a708 1
    REAL(r8) dval
a710 1
    CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: sval
d712 1
a712 1
    INTEGER :: version, ival, indx
d734 6
d744 2
a745 2
		call measured_parameter (HDF_FILE, MCF_FILE, &
		& l2pcf, QuantityNames(indx), groups)
d749 1
a749 1
	call third_grouping (HDF_FILE, MCF_FILE, l2pcf, groups)
d818 7
a824 5
	if(present(version)) then
		myVersion=version
	else
		myVersion = 1
	endif
a825 1
	! Get full file name for l2gp file
d836 6
d896 6
d964 2
a965 1
      IF (result /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, ModuleName, &
d967 2
d1132 3
@


2.2
log
@Added populate_metadata_oth
@
text
@d5 2
a6 1
USE MLSCommon
d11 1
d25 1
a25 1
   "$Id: write_meta.f90,v 2.1 2001/02/13 22:59:36 pwagner Exp $"
d241 3
a243 1
!--------------------------- populate_metadata_std -------------------
d245 2
a246 1
  SUBROUTINE populate_metadata_std (HDF_FILE, MCF_FILE, l2pcf, field_name)
d248 7
a254 7
! This is the standard way to write meta data
! It should work unchanged for the standard l2gp files (e.g. BrO)
! and, with minor changes, for the l2gp file marked "other"
!
! the l2aux files, also called dgm
! and the dgg files will probably require special treatment
! the log file should be able to use the one stolen from level 3
a262 1
	 character (LEN=*) :: field_name
d350 61
d492 72
d764 92
d861 1
a861 1
  & numquantitiesperfile, QuantityNames)
d874 1
d877 72
a948 2
	! Not fleshed out yet, unfortunately--just want to compile successfully
	! before going home
a949 2
	call populate_metadata_std(HDF_FILE, MCF_FILE, l2pcf, &
  & QuantityNames(1))
d952 132
d1286 3
@


2.1
log
@l2 modules can only use MLSPCF2
@
text
@d23 1
a23 1
   "$Id: write_meta.f90,v 2.0 2000/09/05 18:57:07 ahanzel Exp $"
d27 23
d55 4
d239 615
d856 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@d11 1
a11 1
USE MLSPCF
d23 1
a23 1
   "$Id: write_meta.f90,v 1.4 2000/06/30 00:16:41 lungu Exp $"
d214 3
@


1.4
log
@Made dval REAL(r8).
@
text
@d23 1
a23 1
   "$Id: write_meta.f90,v 1.4 2000/06/30 00:16:41 lungu Exp $"
d214 3
a218 9
!
! Revision 1.3  2000/06/19 22:49:48  lungu
! Major rewrite so that it agrees with MCF.
!
! Revision 1.2  2000/01/28 19:36:36  lungu
! Removed the weird hard <CR>s.
!
! Revision 1.1  2000/01/28 01:40:15  lungu
! Initial release.
@


1.1
log
@Initial release.
@
text
@d1 212
a212 419

! -------------------------------------------------------
MODULE WriteMetadata ! Populate metadata and write it out
! -------------------------------------------------------
USE MLSCommon
USE MLSStrings 
USE MLSMessageModule
USE L2GPData
USE L2AUXData
USE SDPToolkit
USE MLSPCF
USE MLSCF 
USE Hdf 
USE HDFEOS 

IMPLICIT NONE

PUBLIC

PRIVATE :: Id, ModuleName
!------------------------------- RCS Ident Info ------------------------------
CHARACTER(LEN=130) :: id = & 
   "$Id: write_meta.f90,v 1.1 2000/01/28 01:40:15 lungu Exp $"
CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: write_meta.f90,v $"
!-----------------------------------------------------------------------------

!Parameters

IMPLICIT NONE
! - - - local declarations - - -
  INTEGER, PARAMETER :: INVENTORY=1,ARCHIVE=2
  CHARACTER (LEN=PGSd_PC_FILE_PATH_MAX) :: physical_filename, hdfeos_filename 
  CHARACTER (LEN=25) :: name
  CHARACTER (LEN=3) :: NAval
  CHARACTER (LEN=4) :: spacecraft
  CHARACTER (LEN=21) :: start_time, end_time
  CHARACTER (LEN=PGS_SMF_MAX_MSGBUF_SIZE) :: message
  CHARACTER (LEN=49) mdHandles
! - - - begin - - -
CONTAINS

  SUBROUTINE populate_metadata(HDF_FILE, MCF_FILE)

  version = 1
  returnStatus = PGS_PC_GetReference(HDF_FILE, version ,physical_filename)

  retVal = pgs_met_Init(MCF_FILE, mdHandles)

  IF (retVal == PGS_S_SUCCESS) THEN
    retVal = pgs_met_setattr(mdHandles(INVENTORY),  &
        "RANGEBEGINNINGDATETIME",  &
        start_time)
    CALL PGS_SMF_GetMsgByCode(retVal, message)
    CALL PGS_SMF_SetStaticMsg(retVal, "RANGEBEGINNINGDATETIME")
    retVal = pgs_met_setattr(mdHandles(INVENTORY+1),  &
        "RANGEENDINGDATETIME",  &
        end_time)
    CALL PGS_SMF_GetMsgByCode(retVal, message)
    CALL PGS_SMF_SetStaticMsg(retVal, "RANGEENDINGDATETIME")
    version = 3.0
    attrValI = version
    retVal = pgs_met_setattr(mdHandles(AUX+1),  &
        "VERSIONID",  &
        attrValI)
    CALL PGS_SMF_GetMsgByCode(retVal, message)
    CALL PGS_SMF_SetStaticMsg(retVal, "VERSION_ID")
    attrValI = 0
    retVal = pgs_met_setattr(mdHandles(ARCHIVE+1),  &
        "BROWSESIZE",  &
        attrValI)
    CALL PGS_SMF_GetMsgByCode(retVal, message)
    CALL PGS_SMF_SetStaticMsg(retVal, "BROWSESIZE")
  ELSE
    STOP '(1)'
  END IF
  sdId = SDstart( physical_filename, DFACC_RDWR)
  retVal = pgs_met_Write(mdHandles(INVENTORY+1),  &
      "coremetadata.0", sdId)
  IF (retVal /= PGS_S_SUCCESS) CALL PGS_SMF_GetMsgByCode(retVal, message)
  CALL PGS_SMF_SetStaticMsg(retVal, "Inventory WRITE")
  retVal = pgs_met_Write(mdHandles(ARCHIVE+1),  &
      "coremetadata.1",sdId)
  IF (retVal /= PGS_S_SUCCESS) CALL PGS_SMF_GetMsgByCode(retVal, message)
  CALL PGS_SMF_SetStaticMsg(retVal, "Archive WRITE")
  retVal = pgs_met_Write(mdHandles(AUX+1),  &
      "productspecific.0", sdId)
  IF (retVal /= PGS_S_SUCCESS) CALL PGS_SMF_GetMsgByCode(retVal, message)
  CALL PGS_SMF_SetStaticMsg(retVal, "Product Specific WRITE")
  CALL SDend(sdId)
  CALL pgs_met_Remove()

END SUBROUTINE populate_metadat

 
! --------------------------------------------------
FUNCTION metawrite(logout, hdf_filename, dumpfilename) 
  ! --------------------------------------------------
  ! - - - arg types - - -                                      
  INTEGER :: logout
  CHARACTER,TARGET :: hdf_filename(*)
  CHARACTER (LEN=*) :: dumpfilename
  ! - - - local declarations - - -
  INTEGER :: in
  CHARACTER (LEN=80),TARGET :: spacecraft
  CHARACTER (LEN=25),TARGET :: start_time,end_time
  CHARACTER (LEN=80) :: dumpline
  CHARACTER (LEN=PGS_SMF_MAX_MSGBUF_SIZE) :: message
  CHARACTER (LEN=PGS_SMF_MAX_MNEMONIC_SIZE) :: mnemonic
  CHARACTER (LEN=2000) :: file_des
  CHARACTER,POINTER :: inputp,fieldlist(:),parname
  CHARACTER :: ten
  CHARACTER :: one

  ! - - - begin - - -


  !  in = FOPEN(dumpfilename,"r")
  !  IF (in == NULL) THEN
  !     CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
  ! 
  !    RETURN
  !  END IF

  retVal = pgs_met_Init(InDPpPCFLogIDMCF, mdHandles)
  IF ( retVal /= PGS_S_SUCCESS ) THEN
     CALL PGS_SMF_GetMsg(code, mnemonic, message)
     CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite"//mnemonic//message)
  END IF
  IF (retVal == PGS_S_SUCCESS) THEN
     attrValD = 360.
     retVal = pgs_met_setattr(mdHandles(INVENTORY+1),  &
          "EASTBOUNDINGCOORDINATE",  &
          attrValD)
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     attrValD = 0.
     retVal = pgs_met_setattr(mdHandles(INVENTORY+1),  &
          "WESTBOUNDINGCOORDINATE",  &
          attrValD)
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     attrValD = -90.
     IF (spacecraft(0+1:0+1) /= "N") attrValD = -57.
     retVal = pgs_met_setattr(mdHandles(INVENTORY+1),  &
          "SOUTHBOUNDINGCOORDINATE",  &
          attrValD)
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     attrValD = 90.
     IF (spacecraft(0+1:0+1) /= "N") attrValD = 57.
     retVal = pgs_met_setattr(mdHandles(INVENTORY+1),  &
          "NORTHBOUNDINGCOORDINATE",  &
          attrValD)
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     inputp => start_time(0+1:+1:0+1:+1)
     retVal = pgs_met_setattr(mdHandles(INVENTORY+1),  &
          "RANGEBEGINNINGDATETIME",  &
          inputp)
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     inputp => end_time(0+1:+1:0+1:+1)
     retVal = pgs_met_setattr(mdHandles(INVENTORY+1),  &
          "RANGEENDINGDATETIME",  &
          inputp)
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     inputp => spacecraft(0+1:+1:0+1:+1)
     retVal = pgs_met_setattr(mdHandles(ARCHIVE+1),  &
          "SPACECRAFT",  &
          inputp)
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     inputp => hdf_filename(0+1)
     retVal = pgs_met_setattr(mdHandles(INVENTORY+1),  &
          "GRANULEPOINTER",  &
          inputp )
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     swfid = SWopen(hdf_filename, DFACC_READ)
     IF (swfid /= -1) THEN
        SWid = SWattach(swfid,"E" )
        IF (SWid /= -1 ) THEN
           nflds = SWnentries(SWid, HDFE_NENTGFLD, strbufsize)
           geoflds = nflds
           ALLOCATE( fieldlist(strbufsize) )
           nflds = SWinqgeofields(SWid, fieldlist, rank, ntype)
           l = 0
           k = 0
           i = 0
           CALL parse_param(ip, kp, lp, flagp, logout, fieldlist(1)(:SIZE(fieldlist)), geoflds, one, ten)
           DEALLOCATE (fieldlist(1)(:SIZE(fieldlist)))
           DEALLOCATE (rank)
           DEALLOCATE (ntype)
           nflds = SWnentries(SWid, HDFE_NENTDFLD, strbufsize)
           datflds = nflds
           ALLOCATE( fieldlist(strbufsize) )
           nflds = SWinqdatafields(SWid, fieldlist, rank, ntype)
           k = 0
           i = 0
           CALL parse_param(ip, kp, lp, flagp, logout, fieldlist(1)(:SIZE(fieldlist)), datflds, one, ten)
           DEALLOCATE (fieldlist(1)(:SIZE(fieldlist)))
           DEALLOCATE (rank)
           DEALLOCATE (ntype)
        ELSE
           CALL MLSMessage (MLSMSG_Error, ModuleName,  "Unable to open SWATH")

           RETURN
        END IF
     END IF
     hdf_status = SWdetach(SWid)
     hdf_status = SWclose(swfid)
  ELSE
     output_4 = (1)
     RETURN
  END IF
  sdId = SDstart( hdf_filename, DFACC_RDWR)
  IF (sdId < 0) THEN
     CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
  END IF
  retVal = pgs_met_Write(mdHandles(INVENTORY+1),  &
       "coremetadata.0", sdId)
  IF (retVal /= PGS_S_SUCCESS) THEN
     CALL PGS_SMF_GetMsg(code, mnemonic, message)
     CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     CALL SDend(sdId)
     CALL pgs_met_Remove
     output_4 = (1)
     RETURN
  END IF
  retVal = pgs_met_Write(mdHandles(ARCHIVE+1),  &
       "archivedata.0",sdId)
  IF (retVal /= PGS_S_SUCCESS) THEN
     CALL PGS_SMF_GetMsg(code, mnemonic, message)
     CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     CALL SDend(sdId)
     CALL pgs_met_Remove
     output_4 = (1)
     RETURN
  END IF
  CALL SDend(sdId)
  CALL pgs_met_Remove
  CALL MLSMessage (MLSMSG_Error, ModuleName,  "Informational, metawrite")
  CLOSE (logout)
  in = FOPEN(dumpfilename,"r")
  IF (in == NULL) THEN
     CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     output_4 = (1)
     RETURN
  END IF
  file_des = "0"
  DO
     READ (in,END=???) dumpline
     file_des = file_des(1:LEN_TRIM(file_des)) // dumpline
  END DO
  file_des = file_des(1:LEN_TRIM(file_des))
  sdId = Hopen(hdf_filename, DFACC_RDWR, 0)
  CALL DFANaddfds(sdId, file_des, 2000)
  CALL Hclose(sdId)
  CLOSE (in)
  RETURN

END FUNCTION metawrite
 
! --------------------------------------------------
FUNCTION julian(mon,day,year)  
  ! --------------------------------------------------

  ! - - - arg types - - -

  INTEGER :: mon,day,year
  ! - - - local declarations - - -
  INTEGER :: jul,i
  INTEGER :: monref(12)

  ! - - - begin - - -
  monref = (/0,31,28,31,30,31,30,31,31,30,31,30/)
  jul = 0
  IF (MOD(year,4) == 0) monref(2+1) = 29
  IF (MOD(year,100) == 0) THEN
     IF (MOD(year,400) /= 0) monref(2+1) = 28
     DO i = 0,mon-1
        jul = jul + monref(i+1)
     END DO
     jul = jul + day
     julian = jul
  END IF
     
RETURN

   
END FUNCTION julian
 
! --------------------------------------------------
SUBROUTINE start_end(dumpline,start_time,end_time)
  ! --------------------------------------------------

  ! - - - arg types - - -
  CHARACTER (LEN=*) :: dumpline,start_time,end_time
  INTEGER,EXTERNAL :: julian
  ! - - - local declarations - - -
  INTEGER :: jul,j1,j2,j3
  CHARACTER (LEN=25) :: time
  CHARACTER (LEN=4) :: julday
  CHARACTER (LEN=3) :: mon,day
  CHARACTER (LEN=5) :: year
  CHARACTER (LEN=15) :: times,timee

  ! - - - begin - - -
  times = "T00:00:00.000"
  timee = "T23:59:00.000"
  j1,j2,j3,jul,moni,dayi,yeari
  time = dumpline
  CALL strncat(start_time, time, 2)
  start_time = start_time(1:LEN_TRIM(start_time)) // "-"
  year(0+1:0+1) = "1"
  year(1+1:1+1) = "9"
  year(2+1:2+1) = time(0+1:0+1)
  year(3+1:3+1) = time(1+1:1+1)
  year(4+1:4+1) = CHAR(000)
  mon(0+1:0+1) = time(3+1:3+1)
  mon(1+1:1+1) = time(4+1:4+1)
  mon(2+1:2+1) = CHAR(000)
  day(0+1:0+1) = time(6+1:6+1)
  day(1+1:1+1) = time(7+1:7+1)
  day(2+1:2+1) = CHAR(000)
  moni = atoi(mon)
  dayi = atoi(day)
  yeari = atoi(year)
  jul = julian(moni,dayi,yeari)
  j1 = jul/100
  jul = jul-j1*100
  j2 = jul/10
  jul = jul-j2*10
  j3 = jul
  julday(0+1:0+1) = "0"+j1
  julday(1+1:1+1) = "0"+j2
  julday(2+1:2+1) = "0"+j3
  julday(3+1:3+1) = CHAR(000)
  start_time = start_time(1:LEN_TRIM(start_time)) // julday
  end_time = start_time
  start_time = start_time(1:LEN_TRIM(start_time)) // times
  end_time = end_time(1:LEN_TRIM(end_time)) // timee

END SUBROUTINE start_end
 
! --------------------------------------------------
SUBROUTINE parse_param(intn)
  ! --------------------------------------------------
  ! - - - arg types - - -
  ! - - - local declarations - - -
  CHARACTER (LEN=25),TARGET :: name
  CHARACTER (LEN=80),TARGET :: parametername
  CHARACTER (LEN=PGS_SMF_MAX_MSGBUF_SIZE) :: message
  CHARACTER (LEN=PGS_SMF_MAX_MNEMONIC_SIZE) :: mnemonic
  CHARACTER,POINTER :: inputp,parname
  CHARACTER :: paramt

  ! - - - begin - - -
  paramt = "PARAMETERNAME"
  i,j,k,l,flag

  i = ip
  k = kp
  l = lp
  flag = flagp
  DO
     DO WHILE (fieldlist(k+1) /= "," )
        name(i+1:i+1) = fieldlist(k+1)
        i = i+1
        k = k+1
        IF (fieldlist(k+1) == NULL) EXIT
     END DO
     name(i+1:i+1) => NULL()
     inputp => name(0+1:+1:0+1:+1)
     parametername = paramt
     parametername = parametername(1:LEN_TRIM(parametername)) // "."
     l = l+1
     IF (l > 9) THEN
        l = 0
        flag = 1
     END IF
     IF (flag == 1) parametername = parametername(1:LEN_TRIM(parametername)) // ten
     parametername = parametername(1:LEN_TRIM(parametername)) // one
     parname => parametername(0+1:+1:0+1:+1)
     retVal = pgs_met_setattr(mdHandles(ARCHIVE+1),  &
          parname, inputp)
     IF ( retVal /= PGS_S_SUCCESS ) THEN
        CALL PGS_SMF_GetMsg(code, mnemonic, message)
        CALL MLSMessage (MLSMSG_Error, ModuleName,  "Error, metawrite")
     END IF
     k = k+1
     IF (fieldlist(k+1) == NULL) EXIT
     i = 0
  END DO
  ip = i
  kp = k
  lp = l
  flagp = flag

END SUBROUTINE parse_param

END MODULE WriteMetadata 
d214 9
d225 1
a225 1
!
@


