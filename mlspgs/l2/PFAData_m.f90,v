head	2.33;
access;
symbols
	v5-02-NRT-19:2.33
	v6-00:2.33
	v5-02-NRT-18:2.33
	v5-02:2.33
	v5-01-NRT-17:2.33
	v5-01-NRT-16:2.33
	v5-01-NRT-15:2.33
	v5-01-NRT-14:2.33
	neuralnetworks-1-0:2.33.0.10
	cfm-single-freq-0-1:2.33.0.8
	v5-01:2.33
	v5-00:2.33
	v4-23-TA133:2.33.0.6
	mus-emls-1-70:2.33.0.4
	rel-1-0-englocks-work:2.33.0.2
	VUMLS1-00:2.33
	VPL1-00:2.33
	V4-22-NRT-08:2.33
	VAM1-00:2.33
	V4-21:2.32.0.2
	V4-13:2.32
	V4-12:2.29
	V4-11:2.29
	V4-10:2.29
	V3-43:2.27
	M4-00:2.27
	V3-41:2.27
	V3-40-PlusGM57:2.27.0.2
	V2-24-NRT-04:2.25
	V3-33:2.27
	V2-24:2.25
	V3-31:2.27
	V3-30-NRT-05:2.27
	cfm-01-00:2.27
	V3-30:2.27
	V3-20:2.27
	V3-10:2.27
	V2-23-NRT-02:2.25
	V2-23:2.25
	V2-22-NRT-01:2.25
	V2-22:2.25
	V2-21:2.25
	V2-20:2.25
	V2-11:2.25
	V2-10:2.25
	V2-00:2.24
	V1-51:2.11
	V1-50:2.11
	V1-45:2.6
	V1-44:2.6;
locks; strict;
comment	@# @;


2.33
date	2015.03.28.02.50.56;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2014.09.05.01.17.40;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2014.09.05.00.49.07;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2014.08.01.01.45.30;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2014.03.01.03.10.56;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2008.09.04.20.00.28;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2006.06.15.20.39.59;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2006.04.26.00.39.09;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2006.04.21.22.28.01;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2005.06.03.02.09.19;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2005.05.28.03.25.58;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2005.05.27.23.57.03;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2005.05.03.15.53.39;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2005.03.25.21.02.48;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2005.03.16.23.59.42;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2005.03.03.21.12.48;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2005.01.27.21.21.28;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2005.01.13.00.00.13;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2005.01.12.03.18.22;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2004.12.31.02.41.56;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2004.12.13.23.58.48;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2004.09.25.00.29.44;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2004.09.24.23.44.05;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2004.09.05.21.14.10;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2004.09.02.00.49.38;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2004.07.08.19.33.23;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2004.06.09.19.58.55;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2004.06.09.17.47.10;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2004.06.08.19.29.27;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2004.05.29.02.51.40;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2004.05.22.02.29.48;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.33
log
@Added stuff to trace allocate/deallocate addresses
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module PFAData_m

  ! Read the PFA data file(s).  Build a database.  Provide for access to it.
  ! Setup to make the PFA Data tables, as specified by a MakePFA statement.
  ! Write PFA data file(s).  Add PFA tables weighted by isotope ratios.
  ! Flush the PFA database.

  implicit NONE
  private
  public :: Flush_PFAData, Get_PFAdata_from_l2cf, Make_PFAData
  public :: Read_PFAData, Write_PFAData

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: PFAData_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains ! =====     Public Procedures     =============================

  ! ----------------------------------------------  Flush_PFAData  -----
  subroutine Flush_PFAData ( Root, Error )
  ! Flush data (absorption and derivatives) from the PFA database.
  ! Keep enough information to read it from HDF files if it's needed again.
  ! For now, flush the entire database.  Someday, we may want to add the
  ! capability to flush selectively by signals, molecules, or the Cartesian
  ! product.

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use init_tables_module, only: F_Molecules
    use PFADataBase_m, only: Flush_PFADatabase
    use MoreTree, only: Get_Field_ID
    use Tree, only: Decoration, NSons, Subtree

    integer, intent(in) :: Root            ! of the pfaData subtree in the l2cf
    integer, intent(out) :: Error          ! 0 => OK, else trouble

    integer :: I, J, Son
    integer, pointer :: Molecules(:)

    ! Gather the molecules, if any
    nullify ( molecules )
    do i = 2, nsons(root)
      son = subtree(i,root)
      select case ( get_field_id(son) )
      case ( f_molecules )
        call allocate_test ( molecules, nsons(son)-1, 'Molecules', moduleName )
        do j = 2, nsons(son)
          molecules(j-1) = decoration(subtree(j,son))
        end do
      end select
    end do

    ! For now, just flush all signals
    call Flush_PFADatabase ( null(), molecules, error )

    call deallocate_test ( molecules, 'Molecules', moduleName )

  end subroutine Flush_PFAData

  ! --------------------------------------  Get_PDAdata_from_l2cf  -----
  subroutine Get_PFAdata_from_l2cf ( Root, Name, Error )
  ! Process a PFAdata specification from the l2cf.

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Expr_m, only: Expr
    use Init_Tables_Module, only: F_Absorption, F_dAbsDnc, F_dAbsDnu, &
      & F_dAbsDwc, F_Molecules, F_Signal, F_Temperatures, F_VelLin, &
      & F_VGrid, Field_First, Field_Last, L_Zeta
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only: MaxSigLen, Signals
    use MoreTree, only: Get_Field_ID
    use Parse_Signal_m, only: Parse_Signal
    use PFADataBase_m, only: AddPFADatumToDatabase, PFAData, PFAData_T, RK
    use Physics, only: SpeedOfLight
    use String_Table, only: Get_String
    use Tree, only: Decorate, Decoration, NSons, Sub_Rosa, Subtree
    use VGridsDatabase, only: VGrids

    integer, intent(in) :: Root            ! of the pfaData subtree in the l2cf
    integer, intent(in) :: Name            ! of the pfaData spec, else zero
    integer, intent(out) :: Error          ! 0 => OK, else trouble

    ! Error codes
    integer, parameter :: DSBSignal = 1
    integer, parameter :: NotMolecule = DSBSignal + 1
    integer, parameter :: NotZeta = notMolecule + 1
    integer, parameter :: ShowSize = notZeta + 1
    integer, parameter :: SignalParse = showSize + 1
    integer, parameter :: TooManyChannels = signalParse + 1
    integer, parameter :: TooManySignals = tooManyChannels + 1
    integer, parameter :: WrongFields = tooManySignals + 1
    integer, parameter :: WrongSignal = wrongFields + 1
    integer, parameter :: WrongSize = wrongSignal + 1

    integer :: AbsTree
    integer, parameter :: CK = kind(speedOfLight)
    real(ck) :: C = speedOfLight / 1000.0_ck ! km/s
    logical, pointer :: Channels(:)
    integer :: dAbsDncTree, dAbsDnuTree, dAbsDwcTree
    integer :: Field
    logical :: Got(field_first:field_last)
    integer :: I
    integer :: NArrays, NPress, NTemps
    integer :: Sideband
    integer, pointer :: SignalIndices(:)
    character(len=maxSigLen) :: SignalText
    integer :: SignalTree       ! Where in tree is signal=...
    integer :: Son, Units(2)
    type(pfaData_t) :: PFADatum
    double precision :: Value(2)
    real(rk) :: VelLin

    error = 0
    got = .false.
    nullify ( channels, signalIndices )
    pfaDatum%name = name
    do i = 2, nsons(root)
      son = subtree(i,root)
      field = get_field_id(son)
      got(field) = .true.
      select case ( field )
      case ( f_absorption )
        absTree = son
      case ( f_dAbsDnc )
        dAbsDncTree = son
      case ( f_dAbsDnu )
        dAbsDnuTree = son
      case ( f_dAbsDwc )
        dAbsDwcTree = son
      case ( f_molecules )
        pfaDatum%molecule = decoration(subtree(2,son))
      case ( f_signal )
        signalTree = subtree(2,son)
        pfaDatum%signal = sub_rosa(signalTree)
        call get_string ( pfaDatum%signal, SignalText, strip=.true. )
        call parse_signal ( signalText, signalIndices, &
          & tree_index=son, sideband=sideband, channels=channels )
        if ( .not. associated(signalIndices) ) & ! A parse error occurred
          & call announce_error ( subtree(2,son), signalParse, signalText )
        if ( size(signalIndices) > 1 ) &
          & call announce_error ( subtree(2,son), tooManySignals, signalText )
        if ( size(channels) > 1 ) &
          & call announce_error ( subtree(2,son), tooManyChannels, signalText )
        pfaDatum%signalIndex = signalIndices(1)
        pfaDatum%theSignal = signals(pfaDatum%signalIndex)
        pfaDatum%theSignal%channels => channels
        pfaDatum%theSignal%sideband = sideband
        call deallocate_test ( signalIndices, 'SignalIndices', moduleName )
      case ( f_temperatures )
        pfaDatum%tGrid = vGrids(decoration(decoration(subtree(2,son))))
      case ( f_velLin )
        call expr ( subtree(2,son), units, value )
        velLin = value(1) / 1000.0 ! fundamental unit is m/s, fwdmdl wants km/s
      case ( f_vGrid )
        pfaDatum%vGrid = vGrids(decoration(decoration(subtree(2,son))))
        if ( pfaDatum%vGrid%verticalCoordinate /= l_zeta ) &
          & call announce_error ( subtree(1,son), notZeta )
      end select
    end do

    nPress = pfaDatum%vGrid%noSurfs
    nTemps = pfaDatum%tGrid%noSurfs
    nArrays = nPress * nTemps + 1

    ! Nullify shouldn't be needed, but just to be safe....
    nullify ( pfaDatum%absorption, pfaDatum%dAbsDnc, pfaDatum%dAbsDnu, pfaDatum%dAbsDwc )
    call allocate_test ( pfaDatum%absorption, nTemps, nPress, 'pfaDatum%absorption', moduleName )
    call allocate_test ( pfaDatum%dAbsDnc,    nTemps, nPress, 'pfaDatum%dAbsDnc',    moduleName )
    call allocate_test ( pfaDatum%dAbsDnu,    nTemps, nPress, 'pfaDatum%dAbsDnu',    moduleName )
    call allocate_test ( pfaDatum%dAbsDwc,    nTemps, nPress, 'pfaDatum%dAbsDwc',    moduleName )

    if ( .not. all( (/ & ! Check that we have all required fields
         & got(f_absorption), got(f_dAbsDnc), got(f_dAbsDnu), got(f_dAbsDwc), &
         & got(f_molecules), got(f_velLin) /) ) ) &
      & call announce_error ( root, wrongFields, stop=.true. )
    if ( nSons(absTree) /= nArrays ) &
      call announce_error ( subtree(1,absTree), wrongSize, 'Absorption', &
        & nArrays )
    if ( nSons(dAbsDncTree) /= nArrays ) &
      call announce_error ( subtree(1,dAbsDncTree), wrongSize, 'd Abs / d nc', &
        & nArrays )
    if ( nSons(dAbsDnuTree) /= nArrays ) &
      call announce_error ( subtree(1,dAbsDnuTree), wrongSize, 'd Abs / d nu', &
        & nArrays )
    if ( nSons(dAbsDwcTree) /= nArrays ) &
      call announce_error ( subtree(1,dAbsDwcTree), wrongSize, 'd Abs / d wc', &
        & nArrays )
    ! Get data from the tree into the data structure
    call store_2d ( absTree, pfaDatum%absorption )
    call store_2d ( dAbsDncTree, pfaDatum%dAbsDnc )
    call store_2d ( dAbsDnuTree, pfaDatum%dAbsDnu )
    call store_2d ( dAbsDwcTree, pfaDatum%dAbsDwc )
    PFADatum%vel_rel = velLin / c ! Doppler correction factor

    if ( PFADatum%theSignal%sideband == 0 ) &
      & call announce_error ( signalTree, DSBSignal )

    if ( error == 0 ) then
      call decorate ( root, addPFADatumToDatabase ( pfaData, pfaDatum ) )
    else
      call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Execution terminated.' )
    end if

  contains

    ! ...........................................  Announce_Error  .....
    subroutine Announce_Error ( Where, What, String, More, Stop )
      use MoreTree, only: StartErrorMessage
      use Output_m, only: Output
      use PFADataBase_m, only: Dump
      integer, intent(in) :: Where             ! Tree node index
      integer, intent(in) :: What              ! Error index
      character(len=*), intent(in), optional :: String  ! For more info
      integer, intent(in), optional :: More    ! For more info
      logical,  intent(in),optional :: Stop    ! Stop via MLSMessage if true
      error = 1
      call startErrorMessage ( where )
      select case ( what )
      case ( DSBSignal )
        call output ( 'DSB signals not allowed for PFA', advance='yes' )
        call dump ( pfaDatum )
      case ( notMolecule )
        call output ( 'Symbol ' )
        call output ( trim(string) )
        call output ( ' read from file is not a molecule.', advance='yes' )
      case ( notZeta )
        call output ( 'Vertical coordinate for pressure grid must be Zeta.', &
          & advance='yes' )
      case ( showSize )
        call output ( 'Size of ' )
        call output ( trim(string) )
        call output ( more, before=' = ', after='.', advance='yes' )
      case ( signalParse )
        call output ( 'Unable to parse signal ' )
        call output ( trim(string), advance='yes' )
      case ( tooManyChannels )
        call output ( string )
        call output ( ' Describes more than one channel.', advance='yes' )
      case ( tooManySignals )
        call output ( string )
        call output ( ' Describes more than one signal.', advance='yes' )
      case ( wrongFields )
        call output ( 'If file appears, either none of absorption, dAbsDnc, dAbsDnu, dAbsDwc,', &
          advance='yes' )
        call output ( 'molecules or velLin shall appear, or all shall appear.', &
          advance='yes' )
      case ( wrongSignal )
        call output ( 'The signal in file ' )
        call output ( trim(string) )
        call output ( ' is not consistent with the SIGNAL in the PFADATA.', advance='yes' )
      case ( wrongSize )
        call output ( 'Incorrect size for ' )
        call output ( trim(string) )
        call output ( more, before=' -- should be ', after='.', advance='yes' )
      end select
      if ( present(stop) ) then
        if ( stop ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Execution terminated.' )
      end if
    end subroutine Announce_Error

    ! .................................................  Store_2d  .....
    subroutine Store_2d ( Where, What )
    ! Store data from Where in the L2CF into an nTemps X nPress
    ! array What

      use MLSKinds, only: R4
      integer, intent(in) :: Where
      real(r4), pointer :: What(:,:)
      integer :: I, J, K

      j = 0
      k = 1
      do i = 2, nsons(where)
        call expr ( subtree(i,where), units, value )
        j = j + 1
        if ( j > nTemps ) then
          j = 1
          k = k + 1
        end if
        what(j,k) = value(1)
      end do
    end subroutine Store_2d

  end subroutine Get_PFAdata_from_l2cf

  ! -----------------------------------------------  Make_PFAData  -----
  subroutine Make_PFAData ( Root, Error )

    use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test, &
      & Test_Allocate, Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use Create_PFAData_m, only: Create_PFAData
    use Expr_m, only: Expr
    use FilterShapes_m, only: DACSFilterShapes, FilterShapes
    use Init_Tables_Module, only: F_AllLinesForRadiometer, F_AllLinesInCatalog, &
      & F_LOSVEL, F_Molecules, F_Oversample, F_Signals, F_Temperatures, &
      & F_VGrid, L_Zeta
    use MLSKinds, only: RP
    use MLSSignals_m, only: Signal_T, Signals
    use MoreTree, only: Get_Boolean, Get_Field_ID
    use Parse_Signal_m, only: Parse_Signal
    use String_Table, only: Get_String
    use Tree, only: Decorate, Decoration, Node_Id, NSons, Sub_Rosa, Subtree
    use Tree_types, only: N_Array
    use VGridsDatabase, only: VGrids ! Both temperature and pressure

    integer, intent(in) :: Root ! of the MakePFA subtree
    integer, intent(out) :: Error

    integer(c_intptr_t) :: Addr         ! For tracing
    logical, pointer :: Channels(:)
    integer :: Field, I, J, K, Son
    integer :: Lines ! 0 => Lines for channel, 1 => Lines for radiometer,
                     ! 2 => All lines in catalog
    real(rp) :: LosVel
    integer, pointer :: Molecules(:)
    type(signal_t), pointer :: MySignals(:), SignalsTemp(:)
    integer :: Oversample
    integer :: Sideband
    character(127) :: Signal
    integer, pointer :: SignalIndices(:)
    integer :: Stat
    integer :: TGrid, VGrid ! Indices in vGrids database
    integer :: Units(2) ! of losVel
    double precision :: Values(2) ! of losVel

    ! Error codes
    integer, parameter :: DuplicateMolecule = 1
    integer, parameter :: NoFilterShapes = DuplicateMolecule + 1
    integer, parameter :: NoFolded = noFilterShapes + 1
    integer, parameter :: NoGroup = noFolded + 1
    integer, parameter :: NotZeta = noGroup + 1
    integer, parameter :: SignalParse = notZeta + 1

    ! Gather the data from the command
    error = 0
    lines = 0
    oversample = 1
    nullify ( signalIndices )
    allocate ( mySignals(0), stat=stat )
    call test_allocate ( stat, moduleName,  'MySignals', uBounds = 0, &
      & elementSize = storage_size(mySignals) / 8 )
    do i = 2, nsons(root)
      son = subtree(i,root)
      field = get_field_id(son)
      select case ( field )
      case ( f_allLinesForRadiometer )
        if ( get_boolean(son) ) lines = 1
      case ( f_allLinesInCatalog )
        if ( get_boolean(son) ) lines = 2
      case ( f_losvel )
        call expr ( subtree(2,son), units, values ) ! can't be a range
        losVel = values(1)
      case ( f_molecules )
        nullify ( molecules )
        call allocate_test ( molecules, nsons(son)-1, 'molecules', moduleName )
        do j = 2, nsons(son)
          k = subtree(j,son)
          if ( node_id(k) == n_array ) call announce_error ( son, noGroup )
          molecules(j-1) = decoration(k)
          if ( any(molecules(:j-2) == molecules(j-1)) ) &
            & call announce_error ( k, duplicateMolecule, stringIndex=sub_rosa(k) )
        end do
      case ( f_oversample )
        call expr ( subtree(2,son), units, values ) ! can't be a range
        oversample = max(nint(values(1)),1)
      case ( f_signals )
        nullify ( channels )
        do j = 2, nsons(son)
          call get_string ( sub_rosa(subtree(j,son)), signal, strip=.true. )
          call parse_signal ( signal, signalIndices, tree_index=son, &
            & sideband=sideband, channels=channels )
          if ( .not. associated(signalIndices) ) & ! A parse error occurred
            & call announce_error ( subtree(j,son), signalParse, signal )
          if ( sideband == 0 ) &
            & call announce_error ( subtree(j,son), noFolded, signal )
          signalsTemp => mySignals
          allocate ( mySignals(size(signalsTemp)+size(signalIndices)), stat=stat )
          addr = 0
          if ( stat == 0 ) then
            if ( size(mySignals) > 0 ) addr = transfer(c_loc(mySignals(1)), addr)
          end if
          call test_allocate ( stat, moduleName,  'MySignals', &
            & uBounds = size(signalsTemp)+size(signalIndices), &
            & elementSize = storage_size(mySignals) / 8, address=addr )
          mySignals(:size(signalsTemp)) = signalsTemp
          mySignals(size(signalsTemp)+1:) = signals(signalIndices)
          mySignals(size(signalsTemp)+1:)%sideband = sideband
          ! Unlike the full forward model, use all of the matching signals.
          do k = size(signalsTemp)+1, size(mySignals)
            mySignals(k)%sideband = sideband
            ! Don't hose channels in database
            nullify ( mySignals(k)%channels )
            call allocate_test ( mySignals(k)%channels, &
              & size(mySignals(k)%frequencies), 'mySignals%channels', &
              & ModuleName ) ! , lowBound=lbound(mySignals(k)%frequencies,1) )
            if ( associated(channels) ) then
              mySignals(k)%channels(1:lbound(channels,1)-1) = .false.
              mySignals(k)%channels(lbound(channels,1):ubound(channels,1)) = &
                & channels
              mySignals(k)%channels(ubound(channels,1)+1:) = .false.
            else
              mySignals(k)%channels = .true.
            end if
          end do ! k
          call deallocate_test ( channels, 'Channels', moduleName )
          call deallocate_test ( signalIndices, 'signalIndices', moduleName )
          k = size(signalsTemp) * storage_size(signalsTemp) / 8
          addr = 0
          if ( k > 0 ) addr = transfer(c_loc(signalsTemp(1)), addr)
          deallocate ( signalsTemp, stat=stat )
          call test_deallocate ( stat, moduleName, 'SignalsTemp', k, address=addr )
        end do ! j
      case ( f_temperatures )
        tGrid = decoration(decoration(subtree(2,son)))
      case ( f_vGrid )
        vGrid = decoration(decoration(subtree(2,son)))
        if ( vGrids(vGrid)%verticalCoordinate /= l_zeta ) &
          & call announce_error ( subtree(1,son), notZeta )
      end select
    end do ! i
    if ( .not. associated(filterShapes) .and. &
         .not. associated(DACSfilterShapes) ) call announce_error ( root, noFilterShapes )
    if ( error /= 0 ) return

    call decorate ( root, &
      & create_PFAData ( molecules, mySignals, vGrids(tGrid), vGrids(vGrid), &
      & losVel, lines, oversample, root ) )

  contains

    ! ...........................................  Announce_Error  .....
    subroutine Announce_Error ( Where, What, String, StringIndex )
      use MoreTree, only: StartErrorMessage
      use Output_m, only: Output
      use String_Table, only: Display_String
      integer, intent(in) :: Where             ! Tree node index
      integer, intent(in) :: What              ! Error index
      character(len=*), intent(in), optional :: String
      integer, intent(in), optional :: StringIndex
      error = 1
      call startErrorMessage ( where )
      select case ( what )
      case ( DuplicateMolecule )
        call output ( 'Duplicate molecule ' )
        call display_string ( stringIndex, advance='yes' )
      case ( noFilterShapes )
        call output ( 'Filter shapes are required to compute PFA', advance='yes' )
      case ( noFolded )
        call output ( 'Folded sidaband PFA not allowed: ' )
        call output ( trim(string), advance='yes' )
      case ( noGroup )
        call output ( 'Molecule groups not allowed.', advance='yes' )
      case ( notZeta )
        call output ( 'Vertical coordinate for pressure grid must be Zeta.', &
          & advance='yes' )
      case ( signalParse )
        call output ( 'Unable to parse signal ' )
        call output ( trim(string), advance='yes' )
      end select
    end subroutine Announce_Error

  end subroutine Make_PFAData

  ! -----------------------------------------------  Read_PFAData  -----
  subroutine Read_PFAData ( Root, Name, Error )

    ! Read PFA data.  If the file= field is a range, the second element
    ! specifies the format.  Default is "UNFORMATTED".

    use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
    use Init_Tables_Module, only: F_File, F_Molecules, F_Signals
    use PFADataBase_m, only: PFAData, Read_PFADatabase
    use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
    use MLSStrings, only: Capitalize
    use MoreTree, only: FillDecorArray, FillSubrosaArray, Get_Field_ID
    use String_Table, only: Get_String
    use Tree, only: Decorate, Node_Id, NSons, Sub_Rosa, Subtree
    use Tree_Types, only: N_String

    integer, intent(in) :: Root ! of the MakePFA subtree, below name if any
    integer, intent(in) :: Name ! ends up labeling the last PFADatum
    integer, intent(out) :: Error ! 0 => OK

    integer :: FileName, FileType ! HDF5 is all we can do
    character(len=12) :: FileTypeText
    integer :: I, J
    integer, pointer :: Molecules(:)
    integer, pointer :: Signals(:)
    integer :: Son

    integer, parameter :: BadFileType = 1 ! Neither HDF5 nor Unformatted

    error = 0
    fileType = 0
    nullify ( molecules, signals )
    do i = 2, nsons(root)
      son = subtree(i,root)
      select case ( get_field_id(son) )
      case ( f_file )
        j = subtree(2,son)
        if ( node_id(j) /= n_string ) then ! must be n_*colon
          fileType = sub_rosa(subtree(2,j))
          call get_string ( fileType, fileTypeText )
          fileTypeText = capitalize(fileTypeText)
          if ( fileTypeText /= 'HDF5' ) call announce_error ( subtree(2,j), badFileType )
          j = subtree(1,j)
        end if
        fileName = sub_rosa(j)
      case ( f_molecules )
        error = max(error,fillDecorArray ( son, molecules, 'Molecules' ))
      case ( f_signals )
        error = max(error,fillSubrosaArray ( son, signals, 'Signals' ))
      end select
    end do
    if ( .not. associated(molecules) ) &
      & call allocate_test ( molecules, 0, 'Molecules', moduleName )
    if ( .not. associated(signals) ) &
      & call allocate_test ( signals, 0, 'Signals', moduleName )
    if ( error > 0 ) then
      call MLSMessage ( MLSMSG_Warning, moduleName, &
        & 'Error trying to read PFAData' )
    else
      call read_PFADatabase ( fileName, fileType, molecules, signals, &
        & root )
      if ( name /= 0 ) then
        j = size(PFAData)
        call decorate ( root, j )
      end if
    end if
    call deallocate_test ( molecules, 'Molecules', moduleName )
    call deallocate_test ( signals, 'Signals', moduleName )

  contains
    ! ...........................................  Announce_Error  .....
    subroutine Announce_Error ( Where, What )
      use MoreTree, only: StartErrorMessage
      use Output_m, only: Output
      integer, intent(in) :: Where, What
      error = 1
      call startErrorMessage ( where )
      select case ( what )
      case ( badFileType )
        call output ( 'Unsupported file type.', advance='yes' )
      end select
    end subroutine Announce_Error

  end subroutine Read_PFAData

  ! ----------------------------------------------  Write_PFAData  -----
  subroutine Write_PFAData ( Root, Error )

    ! Write PFA data on a file generated from the file= field, the molecule,
    ! and the signal.  If the file= field is a range, the second element
    ! specifies the format.  Default is "UNFORMATTED".

    use Init_Tables_Module, only: F_AllPFA, F_File, F_PFAData
    use MoreTree, only: Get_Boolean, Get_Field_ID
    use PFADataBase_m, only: PFAData, Write_PFADatabase, Write_PFADatum
    use String_Table, only: Get_String
    use Tree, only: Decoration, Node_Id, NSons, Sub_Rosa, Subtree
    use Tree_Types, only: N_String

    integer, intent(in) :: Root ! of the MakePFA subtree, below name if any
    integer, intent(out) :: Error ! 0 => OK

    logical :: AllPFA
    integer :: Field, FileIndex ! Where in the tree is the filename?
    character(255) :: FileName, FileType ! Unformatted(default), ???
    integer :: I
    integer :: PFATree          ! Tree index of PFAData=...
    integer :: Son

    integer, parameter :: AtLeastOne = 1            ! Either allPFA or pfaDATA
    integer, parameter :: BadFileType = atLeastOne + 1 ! Not HDF5
    integer, parameter :: NotBoth = badFileType + 1 ! not both allPFA and pfaDATA

    allPFA = .false.
    error = 0
    pfaTree = 0
    do i = 2, nsons(root)
      son = subtree(i,root)
      field = get_field_id(son)
      select case ( field )
      case ( f_allPFA )
        allPFA = get_boolean(son)
      case ( f_file )
        fileIndex = subtree(2,son)
        fileType = 'HDF5'
        if ( node_id(fileIndex) /= n_string ) then ! must be n_*colon
          call get_string( sub_rosa(subtree(2,fileIndex)), fileType, strip=.true. )
          fileIndex = subtree(1,fileIndex)
          if ( fileType /= 'HDF5' ) call announce_error ( fileIndex, badFileType )
        end if
        call get_string ( sub_rosa(fileIndex), fileName, strip=.true. )
      case ( f_pfaData )
        pfaTree = son
      end select
    end do

    if ( .not. allPFA .and. pfaTree == 0 ) call announce_error ( root, atLeastOne )
    if ( allPFA .and. pfaTree /= 0 )  call announce_error ( root, notBoth )

    if ( error /= 0 ) return

    if ( allPFA ) then
      call write_PFADataBase ( fileName, fileType )
    else
      do i = 2, nsons(pfaTree)
        call write_PFADatum ( pfaData(decoration(decoration(subtree(i,pfaTree)))), &
          & fileName, fileType )
      end do
    end if

  contains

    ! ...........................................  Announce_Error  .....
    subroutine Announce_Error ( Where, What )
      use MoreTree, only: StartErrorMessage
      use Output_m, only: Output
      integer, intent(in) :: Where             ! Tree node index
      integer, intent(in) :: What              ! Error index
      error = 1
      call startErrorMessage ( where )
      select case ( what )
      case ( atLeastOne )
        call output ( 'Either AllPFA or PFAData is required', advance='yes' )
      case ( badFileType )
        call output ( 'Unsupported file type.', advance='yes' )
      case ( notBoth )
        call output ( 'Cannot specify both AllPFA and PFAData', advance='yes' )
      end select
    end subroutine Announce_Error

  end subroutine Write_PFAData

! =====     Private Procedures     =====================================

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: PFAData_m.f90,v 2.32 2014/09/05 01:17:40 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module PFAData_m

! $Log: PFAData_m.f90,v $
! Revision 2.32  2014/09/05 01:17:40  vsnyder
! More complete and accurate allocate/deallocate size tracking.  Get kinds
! from MLSKinds instead of from MLSCommon.
!
! Revision 2.31  2014/09/05 00:49:07  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.30  2014/08/01 01:45:30  vsnyder
! Remove unreferenced USE names
!
! Revision 2.29  2014/03/01 03:10:56  vsnyder
! Move units checking to init_tables_module
!
! Revision 2.28  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.27  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.26  2008/09/04 20:00:28  vsnyder
! Add PRINT statement in not_used_here
!
! Revision 2.25  2006/06/15 20:39:59  vsnyder
! Add PFA oversampling
!
! Revision 2.24  2006/04/26 00:39:09  vsnyder
! Need either ordinary or DACS filters
!
! Revision 2.23  2006/04/21 22:28:01  vsnyder
! Flush specified molecules
!
! Revision 2.22  2005/06/03 02:09:19  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! get VGrids from VGridsDatabase instead of a dummy argument.
!
! Revision 2.21  2005/05/28 03:25:58  vsnyder
! Cannonball polishing
!
! Revision 2.20  2005/05/27 23:57:03  vsnyder
! Add Flush PFAData
!
! Revision 2.19  2005/05/03 15:53:39  pwagner
! Consistent with changes to MLSSignals
!
! Revision 2.18  2005/03/25 21:02:48  vsnyder
! Add duplicate molecule detector to MakePFA
!
! Revision 2.17  2005/03/16 23:59:42  vsnyder
! Add allLinesForRadiometer and allLinesInCatalog to makePFA
!
! Revision 2.16  2005/03/03 21:12:48  vsnyder
! Remove UseMolecule from WritePFAData, remove unreferenced symbols
!
! Revision 2.15  2005/01/27 21:21:28  vsnyder
! Remove 'file' field from PFAData, unformatted, nonscalar molecule
!
! Revision 2.14  2005/01/13 00:00:13  vsnyder
! Delete an unreferenced use name
!
! Revision 2.13  2005/01/12 03:18:22  vsnyder
! Read and write PFAData in HDF5
!
! Revision 2.12  2004/12/31 02:41:56  vsnyder
! Working on read/write PFA database
!
! Revision 2.11  2004/12/13 23:58:48  vsnyder
! Add Make_PFAData; add HDF5 to Write_PFAData
!
! Revision 2.10  2004/09/25 00:29:44  vsnyder
! Don't know how the defective one got committed....
!
! Revision 2.9  2004/09/24 23:44:05  vsnyder
! Don't allow DSB signal
!
! Revision 2.8  2004/09/05 21:14:10  pwagner
! component of PFAData type renamed vel_rel
!
! Revision 2.7  2004/09/02 00:49:38  vsnyder
! Replace velLin with vel_cor
!
! Revision 2.6  2004/07/08 19:33:23  vsnyder
! Set up to read unformatted files
!
! Revision 2.5  2004/06/09 19:58:55  pwagner
! Corrected module name to PFADataBase_m
!
! Revision 2.4  2004/06/09 17:47:10  vsnyder
! Split off PFADataBase to fwdmdl
!
! Revision 2.3  2004/06/08 19:29:27  vsnyder
! Add file field
!
! Revision 2.2  2004/05/29 02:51:40  vsnyder
! Allow signal string to denote only one signal
!
! Revision 2.1  2004/05/22 02:29:48  vsnyder
! Initial commit
!
@


2.32
log
@More complete and accurate allocate/deallocate size tracking.  Get kinds
from MLSKinds instead of from MLSCommon.
@
text
@d305 1
d324 1
d393 4
d399 1
a399 1
            & elementSize = storage_size(mySignals) / 8 )
d423 2
d426 1
a426 1
          call test_deallocate ( stat, moduleName, 'SignalsTemp', k )
d656 1
a656 1
       "$Id: PFAData_m.f90,v 2.31 2014/09/05 00:49:07 vsnyder Exp $"
d666 4
@


2.31
log
@EmpiricalGeometry.f90
@
text
@d648 1
a648 1
       "$Id: PFAData_m.f90,v 2.30 2014/08/01 01:45:30 vsnyder Exp $"
d658 3
@


2.30
log
@Remove unreferenced USE names
@
text
@d280 1
a280 1
      use MLSCommon, only: R4
d303 2
a304 1
    use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
d311 1
a311 3
    use MLSCommon, only: RP
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
      & MLSMSG_Error
d353 2
a354 2
    if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // 'Signals' )
d391 3
a393 2
          if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & MLSMSG_Allocate // 'Signals' )
d416 1
d418 1
a418 2
          if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & MLSMSG_DeAllocate // 'SignalsTemp' )
d648 1
a648 1
       "$Id: PFAData_m.f90,v 2.29 2014/03/01 03:10:56 vsnyder Exp $"
d658 3
@


2.29
log
@Move units checking to init_tables_module
@
text
@a80 1
    use Intrinsic, only: PHYQ_Dimensionless, PHYQ_Velocity
a309 1
    use Intrinsic, only: PHYQ_Dimensionless, PHYQ_Velocity
d648 1
a648 1
       "$Id: PFAData_m.f90,v 2.28 2013/09/24 23:47:22 vsnyder Exp $"
d658 3
@


2.28
log
@Use Where instead of Source_Ref for messages
@
text
@a106 1
    integer, parameter :: WrongUnits = wrongSize + 1
a165 2
        if ( units(1) /= phyq_velocity ) &
          & call announce_error ( subtree(1,son), wrongUnits, 'Velocity' )
a268 4
      case ( wrongUnits )
        call output ( 'Incorrect units -- should be ' )
        call output ( trim(string) )
        call output ( '.', advance='yes' )
a289 3
        if ( units(1) /= phyq_dimensionless ) &
          & call announce_error ( subtree(i,where), wrongUnits, &
            & 'Dimensionless' )
a348 1
    integer, parameter :: WrongDimensions = signalParse + 1
a367 2
        if ( units(1) /= phyq_velocity ) &
          & call announce_error ( son, wrongDimensions, 'velocity' )
a380 2
        if ( units(1) /= phyq_dimensionless ) &
          & call announce_error ( son, wrongDimensions, 'dimensionless' )
a467 2
      case ( wrongDimensions )
        call output ( 'Units are not '//trim(string)//'.', advance='yes' )
d650 1
a650 1
       "$Id: PFAData_m.f90,v 2.27 2009/06/23 18:46:18 pwagner Exp $"
d660 3
@


2.27
log
@Prevent Intel from optimizing ident string away
@
text
@d503 1
a503 1
    use Tree, only: Decorate, Node_Id, NSons, Source_Ref, Sub_Rosa, Subtree
d550 1
a550 1
        & source_ref(root) )
d667 1
a667 1
       "$Id: read_apriori.f90 is it here $"
d677 3
@


2.26
log
@Add PRINT statement in not_used_here
@
text
@d664 1
a665 1
!---------------------------- RCS Ident Info -------------------------------
d667 1
a667 1
       "$Id: PFAData_m.f90,v 2.25 2006/06/15 20:39:59 vsnyder Exp $"
a668 1
!---------------------------------------------------------------------------
d670 1
a670 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d672 1
d677 3
@


2.25
log
@Add PFA oversampling
@
text
@d667 1
a667 1
       "$Id: PFAData_m.f90,v 2.24 2006/04/26 00:39:09 vsnyder Exp $"
d671 1
d677 3
@


2.24
log
@Need either ordinary or DACS filters
@
text
@d319 3
a321 2
      & F_LOSVEL, F_Molecules, F_Signals, F_Temperatures, F_VGrid, L_Zeta
    use Intrinsic, only: PHYQ_Velocity
d343 1
d357 1
a357 2
    integer, parameter :: NotVelocity = noGroup + 1
    integer, parameter :: NotZeta = notVelocity + 1
d359 1
d364 1
d379 2
a380 1
        if ( units(1) /= phyq_velocity ) call announce_error ( son, notVelocity )
d392 5
d451 1
a451 1
      & losVel, lines, root ) )
a476 2
      case ( notVelocity )
        call output ( 'Units are not velocity.', advance='yes' )
d483 2
d667 1
a667 1
       "$Id: PFAData_m.f90,v 2.23 2006/04/21 22:28:01 vsnyder Exp $"
d676 3
@


2.23
log
@Flush specified molecules
@
text
@d317 1
a317 1
    use FilterShapes_m, only: FilterShapes
d436 2
a437 1
    if ( .not. associated(filterShapes) ) call announce_error ( root, noFilterShapes )
d658 1
a658 1
       "$Id: PFAData_m.f90,v 2.22 2005/06/03 02:09:19 vsnyder Exp $"
d667 3
@


2.22
log
@New copyright notice, move Id to not_used_here to avoid cascades,
get VGrids from VGridsDatabase instead of a dummy argument.
@
text
@d40 2
d43 2
d49 20
a68 2
    ! For now, just flush everything
    call Flush_PFADatabase ( null(), null(), error )
d657 1
a657 1
       "$Id: PFAData_m.f90,v 2.21 2005/05/28 03:25:58 vsnyder Exp $"
d666 4
@


2.21
log
@Cannonball polishing
@
text
@a24 3
  character (len=*), private, parameter :: IdParm = &
       "$Id: PFAData_m.f90,v 2.20 2005/05/27 23:57:03 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d51 1
a51 1
  subroutine Get_PFAdata_from_l2cf ( Root, Name, VGrids, Error )
d68 1
a68 1
    use VGridsDatabase, only: VGrid_t
a71 1
    type(vGrid_t), intent(in), target :: VGrids(:) ! database of vgrids
d290 1
a290 1
  subroutine Make_PFAData ( Root, VGrids, Error )
d308 1
a308 1
    use VGridsDatabase, only: VGrid_t
a310 1
    type(vGrid_T), intent(in), target :: VGrids(:) ! Both temperature and pressure
d459 1
a459 1
  subroutine Read_PFAData ( Root, Name, VGrids, Error )
a472 1
    use VGridsDatabase, only: VGrid_t
a475 1
    type(vGrid_t), pointer :: VGrids(:) ! database of vgrids
d517 1
a517 1
      call read_PFADatabase ( fileName, fileType, molecules, signals, vGrids, &
d633 5
d644 3
@


2.20
log
@Add Flush PFAData
@
text
@d1 1
a1 1
! Copyright (c) 2005, by the California Institute of Technology. ALL
d26 1
a26 1
       "$Id: PFAData_m.f90,v 2.19 2005/05/03 15:53:39 pwagner Exp $"
d646 3
@


2.19
log
@Consistent with changes to MLSSignals
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d17 1
d21 1
a21 1
  public :: Get_PFAdata_from_l2cf, Make_PFAData
d26 1
a26 1
       "$Id: PFAData_m.f90,v 2.18 2005/03/25 21:02:48 vsnyder Exp $"
d35 18
d474 1
a474 1
    use MoreTree, only: FillSubrosaArray, Get_Field_ID
d511 1
a511 1
        error = max(error,fillSubrosaArray ( son, molecules, 'Molecules' ))
d646 3
@


2.18
log
@Add duplicate molecule detector to MakePFA
@
text
@d17 1
a17 1
       "$Id: PFAData_m.f90,v 2.17 2005/03/16 23:59:42 vsnyder Exp $"
d37 1
a37 1
    use MLSSignals_m, only: Signals
d75 1
d103 3
a105 2
        call get_string ( sub_rosa(signalTree), pfaDatum%signal, strip=.true. )
        call parse_signal ( pfaDatum%signal, signalIndices, &
d108 1
a108 1
          & call announce_error ( subtree(2,son), signalParse, pfaDatum%signal )
d110 1
a110 1
          & call announce_error ( subtree(2,son), tooManySignals, pfaDatum%signal )
d112 1
a112 1
          & call announce_error ( subtree(2,son), tooManyChannels, pfaDatum%signal )
d444 1
a444 1
    use PFADataBase_m, only: MolNameLen, PFAData, Read_PFADatabase
a445 1
    use MLSSignals_m, only: MaxSigLen
d447 1
a447 1
    use MoreTree, only: FillArray, Get_Field_ID
d449 1
a449 1
    use Tree, only: Decorate, Node_Id, NSons, Sub_Rosa, Subtree
d458 2
a459 1
    character(255) :: FileName, FileType ! HDF5(default), Unformatted
d461 2
a462 2
    character(molNameLen), pointer :: Molecules(:)
    character(maxSigLen), pointer :: Signals(:)
d468 1
a474 1
        fileType = 'HDF5'
d476 4
a479 3
          call get_string ( sub_rosa(subtree(2,j)), fileType, strip=.true. )
          fileType = capitalize(fileType)
          if ( fileType /= 'HDF5' ) call announce_error ( subtree(2,j), badFileType )
d482 1
a482 1
        call get_string ( sub_rosa(j), fileName, strip=.true. )
d484 1
a484 1
        error = max(error,fillArray ( son, molecules, 'Molecules' ))
d486 1
a486 1
        error = max(error,fillArray ( son, signals, 'Signals' ))
d497 2
a498 1
      call read_PFADatabase ( fileName, fileType, molecules, signals, vGrids )
d619 3
@


2.17
log
@Add allLinesForRadiometer and allLinesInCatalog to makePFA
@
text
@d17 1
a17 1
       "$Id: PFAData_m.f90,v 2.16 2005/03/03 21:12:48 vsnyder Exp $"
d305 2
a306 1
    integer, parameter :: NoFilterShapes = 1
d339 2
d400 1
a400 1
    subroutine Announce_Error ( Where, What, String )
d403 1
d407 1
d411 3
d615 3
@


2.16
log
@Remove UseMolecule from WritePFAData, remove unreferenced symbols
@
text
@d17 1
a17 1
       "$Id: PFAData_m.f90,v 2.15 2005/01/27 21:21:28 vsnyder Exp $"
d271 2
a272 2
    use Init_Tables_Module, only: F_LOSVEL, F_Molecules, F_Signals, &
      & F_Temperatures, F_VGrid, L_Zeta
d278 1
a278 1
    use MoreTree, only: Get_Field_ID
d291 2
d314 1
d323 4
d392 1
a392 1
      & losVel, root ) )
d607 3
@


2.15
log
@Remove 'file' field from PFAData, unformatted, nonscalar molecule
@
text
@d17 1
a17 1
       "$Id: PFAData_m.f90,v 2.14 2005/01/13 00:00:13 vsnyder Exp $"
d33 1
a33 1
      & F_dAbsDwc, F_File, F_Molecules, F_Signal, F_Temperatures, F_VelLin, &
d38 1
a38 3
    use MLSStrings, only: Capitalize
    use Molecules, only: T_Molecule
    use MoreTree, only: Get_Field_ID, GetLitIndexFromString
d40 1
a40 2
    use PFADataBase_m, only: AddPFADatumToDatabase, PFAData, PFAData_T, RK, &
      & Write_PFADatum
d42 2
a43 4
    use String_Table, only: Create_String, Get_String
    use Tree, only: Decorate, Decoration, Node_Id, NSons, Sub_Rosa, Subtree
    use Tree_Checker, only: Check_Type
    use Tree_Types, only: N_String
a177 1
      use Machine, only: IO_Error
d431 1
a431 1
    use MoreTree, only: FillArray, Get_Boolean, Get_Field_ID
d565 1
a565 1
          & fileName, fileType, useMolecule=.true. )
d600 3
@


2.14
log
@Delete an unreferenced use name
@
text
@d8 1
d12 2
a13 1
  public :: Get_PFAdata_from_l2cf, Make_PFAData, Read_PFAData, Write_PFAData
d17 1
a17 1
       "$Id: PFAData_m.f90,v 2.13 2005/01/12 03:18:22 vsnyder Exp $"
a35 1
    use IO_Stuff, only: Get_Lun
d57 1
a57 3
    integer, parameter :: CannotOpen = 1
    integer, parameter :: CannotRead = cannotOpen + 1
    integer, parameter :: DSBSignal = cannotRead + 1
d64 1
a64 2
    integer, parameter :: UnsupportedFormat = tooManySignals + 1
    integer, parameter :: WrongFields = unsupportedFormat + 1
d74 1
a74 3
    integer :: Field, FileIndex ! Where in the tree is the filename?
    character(255) :: FileName, FileType ! Formatted(default), Unformatted
    character(255) :: FilterFile ! From PFAData file, not from L2cf
d76 2
a77 4
    integer :: I, IOStat, J
    character(127) :: Line      ! of formatted PFA data file
    integer :: Lun
    integer :: NArrays, NMolT, NPress, NPressT, NTemps, NTempsT
d80 1
a80 1
    character(127) :: SignalT
a102 8
      case ( f_file ) ! "filename" [: "<format>"]
        fileIndex = subtree(2,son)
        fileType = 'UNFORMATTED'
        if ( node_id(fileIndex) /= n_string ) then ! must be n_*colon
          call get_string( sub_rosa(subtree(2,fileIndex)), fileType, strip=.true. )
          fileIndex = subtree(1,fileIndex)
        end if
        call get_string ( sub_rosa(fileIndex), fileName, strip=.true. )
d104 1
a104 6
        nullify ( pfaDatum%molecules )
        call allocate_test ( pfaDatum%molecules, nsons(son)-1, &
          & 'pfaDatum%molecules', moduleName )
        do j = 2, nsons(son)
          pfaDatum%molecules(j-1) = decoration(subtree(j,son))
        end do
d106 2
a107 1
        call get_string ( sub_rosa(subtree(2,son)), pfaDatum%signal, strip=.true. )
d146 21
a166 91
    ! Got(file) and not any of the others means read PFAdata from file
    if ( got(f_file) .and. .not. any( (/  &
       & got(f_absorption), got(f_dAbsDnc), got(f_dAbsDnu), got(f_dAbsDwc), &
       & got(f_molecules), got(f_velLin) /) ) ) then
      call get_lun ( lun )
      j = scan(fileName,'$%')
      if ( j == 0 ) then
        fileName = trim(fileName) // pfaDatum%signal
      else
        fileName = fileName(:j-1) // trim(pfaDatum%signal) // fileName(j+1:)
      end if
      open ( unit=lun, file=fileName, form=fileType, status='old', iostat=iostat )
      if ( iostat /= 0 ) then
        call announce_error ( fileIndex, cannotOpen, fileName, iostat )
      else
        if ( capitalize(fileType) == 'UNFORMATTED' ) then ! Unformatted
          signalT = ''
          read ( lun, iostat=iostat ) nTempsT, nPressT, nMolT, velLin, &
            & i, signalT(:i)
          if ( iostat /= 0 ) &
            & call announce_error ( fileIndex, cannotRead, fileName, iostat )
          ! Check the signal
          if ( signalT /= pfaDatum%signal ) call announce_error ( &
            fileIndex, wrongSignal, fileName )
          ! Check numbers of temperatures and pressures
          if ( nTemps /= nTempsT ) then
            call announce_error ( fileIndex, showSize, &
              & 'Temperature in L2CF', nTemps )
            call announce_error ( fileIndex, showSize, &
              & 'Temperature in File', nTempsT )
          end if
          if ( nPress /= nPressT ) then
            call announce_error ( fileIndex, showSize, &
              & 'Pressure in L2CF', nPress )
            call announce_error ( fileIndex, showSize, &
              & 'Pressure in File', nPressT )
          end if
          if ( error == 0 ) then
            ! Read the absorption and derivative arrays
            read ( lun, iostat=iostat ) pfaDatum%absorption, &
              & pfaDatum%dAbsDwc, pfaDatum%dAbsDnc, pfaDatum%dAbsDnu
            if ( iostat /= 0 ) &
              & call announce_error ( fileIndex, cannotRead, fileName, iostat )
            ! Read and check the molecules
            call allocate_test ( pfaDatum%molecules, nMolT, 'pfaDatum%molecules', moduleName )
            do i = 1, nMolT
              read ( lun, iostat=iostat ) j, line(:j)
              if ( iostat /= 0 ) &
                & call announce_error ( fileIndex, cannotRead, fileName, iostat )
              pfaDatum%molecules(i) = getLitIndexFromString ( line(:j) )
              if ( .not. check_type ( t_molecule, pfaDatum%molecules(i) ) ) &
                & call announce_error ( fileIndex, notMolecule, line(:j) )
              pfaDatum%filterFile = 0
              read ( lun, iostat=iostat ) j, filterFile(:j)
              if ( iostat > 0 ) &
                & call announce_error ( fileIndex, cannotRead, fileName, iostat )
              if ( iostat == 0 ) pfaDatum%filterFile = &
                & create_string ( filterFile(:j), caseless=.false. )
            end do
          end if
        else if ( capitalize(fileType) == 'HDF' ) then ! HDF
          call announce_error ( fileIndex, unsupportedFormat, fileType )
        else
          call announce_error ( fileIndex, unsupportedFormat, fileType )
        end if
      end if
    else ! Got(file) and not the others means write PFAData to file.
      if ( .not. all( (/ & ! Check that we have all required fields
           & got(f_absorption), got(f_dAbsDnc), got(f_dAbsDnu), got(f_dAbsDwc), &
           & got(f_molecules), got(f_velLin) /) ) ) &
        & call announce_error ( root, wrongFields, stop=.true. )
      if ( nSons(absTree) /= nArrays ) &
        call announce_error ( subtree(1,absTree), wrongSize, 'Absorption', &
          & nArrays )
      if ( nSons(dAbsDncTree) /= nArrays ) &
        call announce_error ( subtree(1,dAbsDncTree), wrongSize, 'd Abs / d nc', &
          & nArrays )
      if ( nSons(dAbsDnuTree) /= nArrays ) &
        call announce_error ( subtree(1,dAbsDnuTree), wrongSize, 'd Abs / d nu', &
          & nArrays )
      if ( nSons(dAbsDwcTree) /= nArrays ) &
        call announce_error ( subtree(1,dAbsDwcTree), wrongSize, 'd Abs / d wc', &
          & nArrays )
      ! Get data from the tree into the data structure
      call store_2d ( absTree, pfaDatum%absorption )
      call store_2d ( dAbsDncTree, pfaDatum%dAbsDnc )
      call store_2d ( dAbsDnuTree, pfaDatum%dAbsDnu )
      call store_2d ( dAbsDwcTree, pfaDatum%dAbsDwc )
      ! Write it?
      if ( got(f_file) ) call write_PFADatum ( pfaDatum, fileName, fileType )
    end if
d168 1
d170 1
a170 1
      & call announce_error ( fileIndex, DSBSignal )
a194 10
      case ( cannotOpen )
        call output ( 'Cannot open file ' )
        call output ( trim(string) )
        call output ( more, before='.  IOSTAT = ', after='.', advance='yes' )
        call io_error ( 'Cannot open file ', more, trim(string) )
      case ( cannotRead )
        call output ( 'Cannot read file ' )
        call output ( trim(string) )
        call output ( more, before='.  IOSTAT = ', after='.', advance='yes' )
        call io_error ( 'Cannot read file ', more, trim(string) )
a217 3
      case ( unsupportedFormat )
        call output ( trim(string) )
        call output ( ' is not a supported file format.', advance='yes' )
a241 9
    ! .................................................  ReadLine  .....
    subroutine ReadLine
    ! Read from LUN into LINE with '(a)' format.
    !  Announce an error if it fails.
      read ( lun, '(a)', iostat=iostat ) line
      if ( iostat /= 0 ) &
        & call announce_error ( fileIndex, cannotRead, fileName, iostat, .true. )
    end subroutine ReadLine

d426 1
a426 1
  subroutine Read_PFAData ( Root, VGrids )
d433 2
a434 2
    use PFADataBase_m, only: Read_PFADatabase
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d437 1
a437 1
    use MoreTree, only: Get_Field_ID
d439 1
a439 1
    use Tree, only: Node_Id, NSons, Sub_Rosa, Subtree
d444 1
d446 1
a447 1
    logical :: Error
d450 1
a450 1
    character(31), pointer :: Molecules(:)
a454 1
    integer, parameter :: NoRange = badFileType + 1 ! Range not allowed
d456 1
a456 1
    error = .false.
d467 1
a467 2
          if ( fileType /= 'HDF5' .and. fileType /= 'UNFORMATTED' ) &
            & call announce_error ( subtree(2,j), badFileType )
d472 1
a472 1
        call fillArray ( son, molecules, 'Molecules' )
d474 1
a474 1
        call fillArray ( son, signals, 'Signals' )
d481 10
a490 3
    if ( error ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & 'Error trying to read PFAData' )
    call read_PFADatabase ( fileName, fileType, molecules, signals, vGrids )
d500 1
a500 1
      error = .true.
a504 2
      case ( noRange )
        call output ( 'Range not allowed.', advance='yes' )
a507 20
    ! ................................................  FillArray  .....
    subroutine FillArray ( Where, Array, ArrayName )
      use MLSStrings, only: Capitalize
      use Tree, only: Node_Kind, Pseudo
      integer, intent(in) :: Where ! in the tree
      character(len=*), pointer :: Array(:)
      character(len=*), intent(in) :: ArrayName
      integer :: Gson, J
      call allocate_test ( array, nsons(son)-1, arrayName, moduleName )
      do j = 2, nsons(where)
        gson = subtree(j,where)
        if ( node_kind(gson) == pseudo ) then
          call get_string ( sub_rosa(gson), array(j-1), strip=.true. )
          array(j-1) = capitalize(array(j-1))
        else
          call announce_error ( where, noRange )
        end if
      end do
    end subroutine FillArray

d534 3
a536 2
    integer, parameter :: AtLeastOne = 1           ! Either allPFA and pfaDATA
    integer, parameter :: NotBoth = atLeastOne + 1 ! not both allPFA and pfaDATA
d549 1
a549 1
        fileType = 'UNFORMATTED'
d553 1
d588 2
d606 3
@


2.13
log
@Read and write PFAData in HDF5
@
text
@d15 1
a15 1
       "$Id: PFAData_m.f90,v 2.12 2004/12/31 02:41:56 vsnyder Exp $"
d546 1
a546 1
    use MoreTree, only: Get_Boolean, Get_Field_ID
d727 3
@


2.12
log
@Working on read/write PFA database
@
text
@d15 1
a15 1
       "$Id: PFAData_m.f90,v 2.11 2004/12/13 23:58:48 vsnyder Exp $"
a90 1
    logical :: Write
d140 1
a140 1
        pfaDatum%tGrid => vgrids(decoration(decoration(subtree(2,son))))
d147 1
a147 1
        pfaDatum%vGrid => vgrids(decoration(decoration(subtree(2,son))))
a152 4
    write = got(f_file) .and. all( (/ &
           & got(f_absorption), got(f_dAbsDnc), got(f_dAbsDnu), got(f_dAbsDwc), &
           & got(f_molecules), got(f_velLin) /) )

d164 1
d230 1
a230 1
    else
d413 1
a413 1
    type(vGrid_T), pointer :: TGrid, VGrid
d488 1
a488 1
        tGrid => vgrids(decoration(decoration(subtree(2,son))))
d490 2
a491 2
        vGrid => vgrids(decoration(decoration(subtree(2,son))))
        if ( vGrid%verticalCoordinate /= l_zeta ) &
d499 2
a500 1
      & create_PFAData ( molecules, mySignals, tGrid, vGrid, losVel, root ) )
d535 1
a535 1
  subroutine Read_PFAData ( Root )
d541 1
a541 1
    use Init_Tables_Module, only: F_AllPFA, F_File, F_Molecules, F_Signals
d550 1
d553 1
a554 1
    logical :: AllPFA
d557 1
a557 1
    integer :: Gson, I, J
a563 1
    integer, parameter :: NoSignals = noRange + 1   ! Need Signals or AllPFA
a569 2
      case ( f_allPFA )
        allPFA = get_boolean(son)
d589 2
a590 7
    if ( .not. associated(signals) ) then
      if ( .not. allPFA ) then
        call announce_error ( root, noSignals )
      else
        call allocate_test ( signals, 0, 'Signals', moduleName )
      end if
    end if
d593 1
a593 1
    call read_PFADatabase ( fileName, fileType, molecules, signals, allPFA )
d607 1
a607 1
        call output ( 'Unsupported file type', advance='yes' )
d609 1
a609 3
        call output ( 'Range not allowed', advance='yes' )
      case ( noSignals )
        call output ( 'Need either Signals or AllPFA=true', advance='yes' )
d727 3
@


2.11
log
@Add Make_PFAData; add HDF5 to Write_PFAData
@
text
@d11 1
a11 1
  public :: Get_PFAdata_from_l2cf, Make_PFAData, Write_PFAData
d15 1
a15 1
       "$Id: PFAData_m.f90,v 2.10 2004/09/25 00:29:44 vsnyder Exp $"
d76 1
a76 1
    integer :: Field, FileIndex, FilterFileIndex ! Where in the tree is the filename?
d389 1
d422 2
a423 1
    integer, parameter :: NoFolded = 1
d499 1
d517 2
d537 110
d739 3
@


2.10
log
@Don't know how the defective one got committed....
@
text
@d7 1
d11 1
a11 1
  public :: Get_PFAdata_from_l2cf
d15 1
a15 1
       "$Id: PFAData_m.f90,v 2.9 2004/09/24 23:44:05 vsnyder Exp $"
d44 1
a44 1
    use String_Table, only: Get_String
d76 1
a76 1
    integer :: Field, FileIndex ! Where in the tree is the filename?
d78 1
d110 1
a110 1
      case ( f_file )
d112 2
a113 2
        fileType = 'unformatted'
        if ( node_id(fileIndex) /= n_string ) then
d119 1
d162 2
d220 6
d383 232
d624 3
@


2.9
log
@Don't allow DSB signal
@
text
@d14 1
a14 1
       "$Id: PFAData_m.f90,v 2.8 2004/09/05 21:14:10 pwagner Exp $"
d249 2
a250 1
    if ( PFADatum%sideband == 0 ) call announce_error ( fileIndex, DSBSignal )
d286 1
a286 1
        call output ( 'DSB signals not allowed for PFA', advance='yes' ) )
d381 3
@


2.8
log
@component of PFAData type renamed vel_rel
@
text
@d14 1
a14 1
       "$Id: PFAData_m.f90,v 2.7 2004/09/02 00:49:38 vsnyder Exp $"
d57 2
a58 1
    integer, parameter :: NotMolecule = cannotRead + 1
d249 1
d264 2
a265 1
      use OUTPUT_M, only: OUTPUT
d284 3
d380 3
@


2.7
log
@Replace velLin with vel_cor
@
text
@d14 1
a14 1
       "$Id: PFAData_m.f90,v 2.6 2004/07/08 19:33:23 vsnyder Exp $"
d247 1
a247 1
    PFADatum%vel_cor = 1.0_ck - velLin / c ! Doppler correction factor
d374 3
@


2.6
log
@Set up to read unformatted files
@
text
@d14 1
a14 1
       "$Id: PFAData_m.f90,v 2.5 2004/06/09 19:58:55 pwagner Exp $"
d40 1
a40 1
    use PFADataBase_m, only: AddPFADatumToDatabase, PFAData, PFAData_T, &
d42 1
d70 2
d87 1
d142 1
a142 1
        pfaDatum%velLin = value(1) / 1000.0 ! fundamental unit is m/s, fwdmdl wants km/s
d179 1
a179 1
          read ( lun, iostat=iostat ) nTempsT, nPressT, nMolT, pfaDatum%velLin, &
d247 1
d374 3
@


2.5
log
@Corrected module name to PFADataBase_m
@
text
@d14 1
a14 1
       "$Id: PFAData_m.f90,v 2.4 2004/06/09 17:47:10 vsnyder Exp $"
d32 1
a32 1
    use Intrinsic, only: PHYQ_Dimensionless, PHYQ_Temperature, PHYQ_Velocity
d34 1
d37 2
a38 1
    use MoreTree, only: Get_Field_ID
d40 2
a41 1
    use PFADataBase_m, only: AddPFADatumToDatabase, PFAData, PFAData_T
d44 1
d56 4
a59 2
    integer, parameter :: NotZeta = cannotRead + 1
    integer, parameter :: SignalParse = notZeta + 1
d62 4
a65 2
    integer, parameter :: WrongFields = tooManySignals + 1
    integer, parameter :: WrongSize = wrongFields + 1
d70 1
a70 1
    integer :: dAbsDncTree, dAbsDnuTree, dAbsDwcTree, Dim
d74 5
a78 1
    integer :: I, IOStat, J, Lun, NArrays, NPress, NTemps, Sideband
d80 1
d84 1
d105 1
a105 1
        fileType = 'formatted'
a116 6
      case ( f_temperatures )
        pfaDatum%tGrid => vgrids(decoration(decoration(subtree(2,son))))
      case ( f_vGrid )
        pfaDatum%vGrid => vgrids(decoration(decoration(subtree(2,son))))
        if ( pfaDatum%vGrid%verticalCoordinate /= l_zeta ) &
          & call announce_error ( subtree(1,son), notZeta )
d132 2
d139 4
d146 3
a148 8
    ! Check that we have file and not absorption etc, or vice-versa
    if ( got(f_file) .and. &
         any( (/ &
           & got(f_absorption), got(f_dAbsDnc), got(f_dAbsDnu), got(f_dAbsDwc) /) ) &
    & .or. .not. got(f_file) .and. .not. &
         all( (/ &
           & got(f_absorption), got(f_dAbsDnc), got(f_dAbsDnu), got(f_dAbsDwc) /)) ) &
      call announce_error ( root, wrongFields )
d159 3
a161 1
    if ( got(f_file) ) then
d163 6
a168 1
      fileName = trim(fileName) // pfaDatum%signal
d173 41
a213 3
        if ( capitalize(fileType) /= 'UNFORMATTED' ) then
          read ( lun, *, iostat=iostat ) pfaDatum%absorption, pfaDatum%dAbsDnc, &
            & pfaDatum%dAbsDnu, pfaDatum%dAbsDwc
d215 1
a215 2
          read ( lun, iostat=iostat ) pfaDatum%absorption, pfaDatum%dAbsDnc, &
            & pfaDatum%dAbsDnu, pfaDatum%dAbsDwc
a216 2
        if ( iostat /= 0 ) &
          & call announce_error ( fileIndex, cannotRead, fileName, iostat )
d219 4
a222 1
      ! Check sizes
d240 2
d244 6
a249 2
    if ( error == 0 ) &
      & call decorate ( root, addPFADatumToDatabase ( pfaData, pfaDatum ) )
d254 1
a254 1
    subroutine Announce_Error ( Where, What, String, More )
d262 1
d276 4
d283 4
d296 3
d300 1
a300 1
        call output ( 'Need either file and not absorption, dAbsDnc, dAbsDnu or dAbsDwc,', &
d302 1
a302 1
        call output ( 'or not file and all of absorption, dAbsDnc, dAbsDnu and dAbsDwc,', &
d304 4
d311 1
a311 1
        call output ( more, before=' -- should be ', advance='yes' )
d314 2
a315 1
        call output ( trim(string), advance='yes' )
d317 4
d323 9
d369 3
@


2.4
log
@Split off PFADataBase to fwdmdl
@
text
@d14 1
a14 1
       "$Id: PFAData_m.f90,v 2.3 2004/06/08 19:29:27 vsnyder Exp $"
d38 1
a38 1
    use PFADataBase, only: AddPFADatumToDatabase, PFAData, PFAData_T
d279 3
@


2.3
log
@Add file field
@
text
@a7 4
  use MLSCommon, only: R4
  use MLSSignals_m, only: Signal_T
  use VGridsDatabase, only: VGrid_t

a9 1
  public :: PFAData_t, PFAData
a10 24
  public :: Destroy_PFADataBase, Dump_PFADataBase, Dump
  public :: Write_PFADataBase, Read_PFADataBase

  interface Dump
    module procedure Dump_PFADatum
  end interface Dump

  type PFAData_t
    integer :: Name                                ! of the pfaData spec
    integer, pointer :: Molecules(:) => NULL()     ! Molecule indices
    character(len=127) :: Signal                   ! The signal string
    integer :: SignalIndex                         ! in Signals database
    type(signal_t) :: TheSignal                    ! The signal, with channels
                                                   ! and sidebands added
    type(vGrid_t), pointer :: TGrid => NULL()      ! Log temperatures
    type(vGrid_t), pointer :: VGrid => NULL()      ! vertical grid
    real(r4) :: VelLin                             ! Velocity linearization, km/s
    real(r4), pointer :: Absorption(:,:) => NULL() ! Ln Absorption data
    real(r4), pointer :: dAbsDwc(:,:) => NULL()    ! d Ln Absorption / d wc data
    real(r4), pointer :: dAbsDnc(:,:) => NULL()    ! d Ln Absorption / d nc data
    real(r4), pointer :: dAbsDnu(:,:) => NULL()    ! d Ln Absorption / d nu data
  end type PFAData_t

  type(PFAData_t), pointer,save :: PFAData(:) => NULL()
d14 1
a14 1
       "$Id: PFAData_m.f90,v 2.2 2004/05/29 02:51:40 vsnyder Exp $"
d38 1
d42 1
d246 2
a269 99
  ! ----------------------------------------  Destroy_PFADataBase  -----
  subroutine Destroy_PFADataBase
    use Allocate_Deallocate, only: Deallocate_Test
    integer :: I
    if ( .not. associated(pfaData) ) return
    do i = 1, size(pfaData)
      call deallocate_test ( pfaData(i)%molecules, 'pfaData%molecules', moduleName )
      call deallocate_test ( pfaData(i)%theSignal%channels, 'pfaData...Channels', &
          & moduleName )
      call deallocate_test ( pfaData(i)%absorption, 'pfaData%absorption', moduleName )
      call deallocate_test ( pfaData(i)%dAbsDwc, 'pfaData%dAbsDwc', moduleName )
      call deallocate_test ( pfaData(i)%dAbsDnc, 'pfaData%dAbsDnc', moduleName )
      call deallocate_test ( pfaData(i)%dAbsDnu, 'pfaData%dAbsDnu', moduleName )
    end do
  end subroutine Destroy_PFADataBase

  ! -------------------------------------------  Dump_PFADataBase  -----
  subroutine Dump_PFADataBase
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    integer :: I
    if ( .not. associated(pfaData) ) &
      & call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Cannot dump unallocated PFA data base" )
    do i = 1, size(pfaData)
      call dump_PFADatum ( pfaData(i) )
    end do
  end subroutine Dump_PFADataBase

  ! ----------------------------------------------  Dump_PFADatum  -----
  subroutine Dump_PFADatum ( PFADatum )

    use Dump_0, only: Dump
    use Intrinsic, only: Lit_Indices
    use MLSSignals_m, only: DisplaySignalName
    use String_Table, only: Display_String, String_Length
    use Output_m, only: Blanks, NewLine, Output

    type(PFAData_t), intent(in) :: PFADatum

    integer :: I, L, W
    character(len=*), parameter :: Molecules = ' Molecules:'

    if ( pfaDatum%name /= 0 ) then
      call output ( ' ' )
      call display_string ( pfaDatum%name )
    end if
    call newLine
    call output ( Molecules )
    w = len(Molecules)
    do i = 1, size(pfaDatum%molecules)
      l = string_length(lit_indices(pfaDatum%molecules(i)))
      if ( w + l > 72 ) then
        call newLine
        w = len(molecules)
        call blanks ( w )
      end if
      call blanks ( 1 )
      call display_string ( lit_indices(pfaDatum%molecules(i)) )
      w = w + l + 1
    end do
    call newline

    call output ( ' Specified signal: ' )
    call output ( trim(pfaDatum%signal), advance='yes' )
    call output ( ' Actual signal: ' )
    call output ( pfaDatum%signalIndex, after=': ' )
    if ( pfaDatum%theSignal%name /= 0 ) then
      call display_string ( pfaDatum%theSignal%name )
      call output ( ': ' )
    end if
    call displaySignalName ( pfaDatum%theSignal, advance='yes' )


    call output ( ' TGrid: ' )
    call display_string ( pfaDatum%tGrid%name )

    call output ( ', VGrid: ' )
    call display_string ( pfaDatum%vGrid%name, advance='yes' )

    call output ( pfaDatum%velLin, before=' Velocity Linearization: ', &
      & advance='yes' )

    call dump ( pfaDatum%absorption, name=' ln Absorption' )
    call dump ( pfaDatum%dAbsDwc, name=' d ln Absorption / d wc' )
    call dump ( pfaDatum%dAbsDnc, name=' d ln Absorption / d nc' )
    call dump ( pfaDatum%dAbsDnu, name=' d ln Absorption / d nu' )

  end subroutine Dump_PFADatum

  ! ------------------------------------------  Write_PFADatabase  -----
  subroutine Write_PFADatabase ( FileName )
    character(len=*), intent(in) :: FileName
  end subroutine Write_PFADatabase

  ! -------------------------------------------  Read_PFADatabase  -----
  subroutine Read_PFADatabase ( FileName )
    character(len=*), intent(in) :: FileName
  end subroutine Read_PFADatabase

a271 20
  ! --------------------------------------  AddPFADatumToDatabase  -----
  integer function AddPFADatumToDatabase ( DATABASE, ITEM )

  ! This routine adds a PFA Datum to a database of PFA Data, creating the
  ! database if necessary.

    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate, &
      & MLSMSG_Error
    ! Dummy arguments
    type (PFAData_T), dimension(:), pointer :: DATABASE
    type (PFAData_T), intent(in) :: ITEM

    ! Local variables
    type (PFAData_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddPFADatumToDatabase = newSize
  end function AddPFADatumToDatabase

d279 3
@


2.2
log
@Allow signal string to denote only one signal
@
text
@d17 1
d30 1
a30 1
    real(r4), pointer :: LnT(:) => NULL()          ! Log temperatures
d43 1
a43 1
       "$Id: PFAData_m.f90,v 2.1 2004/05/22 02:29:48 vsnyder Exp $"
d53 1
a53 1
  subroutine Get_PFAdata_from_l2cf ( Root, Name, VGrids )
d59 2
a60 1
      & F_dAbsDwc, F_Molecules, F_Signal, F_Temperatures, F_VelLin, F_VGrid
d62 1
a62 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d64 1
d68 2
a69 1
    use Tree, only: Decorate, Decoration, NSons, Sub_Rosa, Subtree
d74 1
d77 4
a80 1
    integer, parameter :: SignalParse = 1
d83 2
a84 1
    integer, parameter :: WrongSize = tooManySignals + 1
d90 4
a93 2
    logical :: Error
    integer :: I, J, NArrays, NPress, NTemps, Sideband
d95 1
a95 1
    integer :: Son, TemperatureTree, Units(2)
d99 2
a100 1
    error = .false.
d105 3
a107 1
      select case ( get_field_id(son) )
d116 8
d130 2
d134 2
a150 2
      case ( f_temperatures )
        temperatureTree = son
d153 1
a153 1
        if ( units(1) /= phyq_velocity .and. units(1) /= phyq_dimensionless ) &
d155 1
a155 1
        pfaDatum%velLin = value(1)
d159 9
a167 1
    ! Check sizes
d169 1
a169 1
    nTemps = nsons(temperatureTree) - 1
d171 16
a186 23
    if ( nSons(absTree) /= nArrays ) &
      call announce_error ( subtree(1,absTree), wrongSize, 'Absorption', &
        & nArrays )
    if ( nSons(dAbsDncTree) /= nArrays ) &
      call announce_error ( subtree(1,dAbsDncTree), wrongSize, 'd Abs / d nc', &
        & nArrays )
    if ( nSons(dAbsDnuTree) /= nArrays ) &
      call announce_error ( subtree(1,dAbsDnuTree), wrongSize, 'd Abs / d nu', &
        & nArrays )
    if ( nSons(dAbsDwcTree) /= nArrays ) &
      call announce_error ( subtree(1,dAbsDwcTree), wrongSize, 'd Abs / d wc', &
        & nArrays )

    ! Store temperatures
    call allocate_test ( pfaDatum%lnT, nTemps, 'pfaDatum%lnT', moduleName )
    dim = phyq_dimensionless
    do j = 2, nTemps + 1
      call expr ( subtree(j,temperatureTree), units, value )
      pfaDatum%lnT(j-1) = value(1)
      if ( units(1) /= phyq_dimensionless ) then
        if ( units(1) /= phyq_temperature ) then
          call announce_error ( subtree(j,temperatureTree), wrongUnits, &
            & 'Temperature' )
d188 2
a189 1
          dim = phyq_temperature
d191 2
d194 20
a213 12
    end do
    if ( dim /= phyq_temperature ) &
      & call announce_error ( subtree(1,temperatureTree), wrongUnits, &
        & 'Temperature' )

    call store_2d ( absTree, pfaDatum%absorption, 'pfaDatum%absorption' )
    call store_2d ( dAbsDncTree, pfaDatum%dAbsDnc, 'pfaDatum%dAbsDnc' )
    call store_2d ( dAbsDnuTree, pfaDatum%dAbsDnu, 'pfaDatum%dAbsDnu' )
    call store_2d ( dAbsDwcTree, pfaDatum%dAbsDwc, 'pfaDatum%dAbsDwc' )

    if ( error ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to complete processing of PFAData' )
d215 2
a216 1
    call decorate ( root, addPFADatumToDatabase ( pfaData, pfaDatum ) )
d222 1
d229 1
a229 1
      error = .true.
d232 13
d254 5
d270 1
a270 1
    subroutine Store_2d ( Where, What, Name )
a274 1
      character(len=*), intent(in) :: Name
a276 1
      call allocate_test ( what, nTemps, nPress, name, moduleName )
a303 1
      call deallocate_test ( pfaData(i)%lnT, 'pfaData%lnT', moduleName )
a366 1
    call dump ( pfaDatum%lnT, name=' Ln Temperatures' )
d368 4
a371 1
    call output ( ' VGrid: ' )
d384 10
d423 3
@


2.1
log
@Initial commit
@
text
@d9 1
d23 1
d26 3
a28 1
    integer, pointer :: SignalIndices(:) => NULL() ! Signal indices
d42 1
a42 1
       "$Id: Fill.f90,v 2.272 2004/05/19 20:38:04 vsnyder Exp $"
d45 1
a45 1
       "$RCSfile: Fill.f90,v $"
d52 1
a52 1
  subroutine Get_PFAdata_from_l2cf ( Root, VGrids )
d55 1
a55 1
    use Allocate_Deallocate, only: Allocate_Test
d61 1
d68 1
d73 3
a75 1
    integer, parameter :: WrongSize = signalParse + 1
d78 3
a80 1
    integer :: AbsTree, dAbsDncTree, dAbsDnuTree, dAbsDwcTree, Dim
d82 3
a84 2
    integer :: I, J, NArrays, NPress, NTemps, Son
    integer :: TemperatureTree, Units(2)
d89 2
d112 13
a124 5
        call parse_signal ( pfaDatum%signal, pfaDatum%signalIndices, &
          & tree_index=son )
        if ( .not. associated(pfaDatum%signalIndices) ) & ! A parse error occurred
          & call announce_error ( subtree(2,son), signalParse, &
            & pfaDatum%signal )
d197 6
d248 2
a249 1
      call deallocate_test ( pfaData(i)%signalIndices, 'pfaData%signalIndices', moduleName )
d275 2
a276 1
    use String_Table, only: Display_String
d281 2
a282 1
    integer :: I
d284 7
a290 1
    call output ( ' Molecules:' )
d292 6
d300 1
d304 1
a304 1
    call output ( ' Signal: ' )
d306 7
d357 4
a360 1
! $Log: $
@

