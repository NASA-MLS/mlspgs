head	2.157;
access;
symbols
	v5-02-NRT-19:2.157
	v6-00:2.156
	v5-02-NRT-18:2.156
	v5-02:2.149
	v5-01-NRT-17:2.152
	v5-01-NRT-16:2.152
	v5-01-NRT-15:2.152
	v5-01-NRT-14:2.152
	neuralnetworks-1-0:2.150.0.4
	cfm-single-freq-0-1:2.150.0.2
	v5-01:2.149
	v5-00:2.149
	v4-23-TA133:2.147.0.2
	mus-emls-1-70:2.143.0.2
	rel-1-0-englocks-work:2.140.0.2
	VUMLS1-00:2.129
	VPL1-00:2.126
	V4-22-NRT-08:2.121
	VAM1-00:2.114
	V4-21:2.102.0.2
	V4-13:2.100
	V4-12:2.100
	V4-11:2.100
	V4-10:2.99
	V3-43:2.32.2.2
	M4-00:2.73
	V3-41:2.32.2.2
	V3-40-PlusGM57:2.32.0.2
	V2-24-NRT-04:2.2
	V3-33:2.40
	V2-24:2.2
	V3-31:2.40
	V3-30-NRT-05:2.40
	cfm-01-00:2.38
	V3-30:2.32
	V3-20:2.32
	V3-10:2.27
	V2-23-NRT-02:2.2
	V2-23:2.2
	V2-22-NRT-01:2.2
	V2-22:2.2;
locks; strict;
comment	@# @;


2.157
date	2024.07.02.22.08.14;	author pwagner;	state Exp;
branches;
next	2.156;

2.156
date	2023.12.14.21.28.00;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2023.12.07.23.08.01;	author pwagner;	state Exp;
branches;
next	2.154;

2.154
date	2023.10.19.20.40.54;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2023.05.25.22.27.35;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2021.06.10.23.46.06;	author pwagner;	state Exp;
branches;
next	2.151;

2.151
date	2021.05.13.23.26.37;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2020.01.27.18.03.13;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2020.01.09.22.25.41;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2019.09.27.16.48.42;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2019.01.24.00.02.27;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2018.12.07.00.21.58;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2018.11.30.17.48.25;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2018.07.27.23.18.48;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2018.06.27.00.01.14;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2018.04.16.22.16.45;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2018.04.13.00.19.18;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2018.03.14.22.54.12;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2018.02.27.16.23.12;	author livesey;	state Exp;
branches;
next	2.138;

2.138
date	2018.02.26.19.04.53;	author livesey;	state Exp;
branches;
next	2.137;

2.137
date	2018.02.23.22.09.52;	author mmadatya;	state Exp;
branches;
next	2.136;

2.136
date	2017.12.15.18.33.19;	author mmadatya;	state Exp;
branches;
next	2.135;

2.135
date	2017.12.07.01.01.23;	author vsnyder;	state Exp;
branches;
next	2.134;

2.134
date	2017.10.31.23.47.33;	author vsnyder;	state Exp;
branches;
next	2.133;

2.133
date	2017.09.20.00.02.58;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2017.07.27.16.59.42;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2017.07.10.18.52.32;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2017.04.06.23.43.34;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2017.02.08.19.22.00;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2016.10.20.19.18.30;	author vsnyder;	state Exp;
branches;
next	2.127;

2.127
date	2016.09.02.00.56.05;	author vsnyder;	state Exp;
branches;
next	2.126;

2.126
date	2016.07.28.01.45.07;	author vsnyder;	state Exp;
branches;
next	2.125;

2.125
date	2016.06.14.22.54.39;	author vsnyder;	state Exp;
branches;
next	2.124;

2.124
date	2016.06.13.21.03.20;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2016.06.03.20.54.38;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2016.06.03.20.52.04;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2016.05.18.01.37.30;	author vsnyder;	state Exp;
branches;
next	2.120;

2.120
date	2016.03.18.17.58.05;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2016.01.23.02.56.37;	author vsnyder;	state Exp;
branches;
next	2.118;

2.118
date	2015.12.01.21.19.57;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2015.11.11.23.25.32;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2015.10.29.00.55.27;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2015.10.03.00.28.06;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2015.09.25.02.15.26;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2015.09.22.23.42.05;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2015.08.25.17.33.42;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2015.08.03.21.43.25;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2015.07.29.00.29.54;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2015.06.04.03.19.36;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2015.06.03.00.35.36;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2015.05.28.18.26.48;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2015.05.05.17.44.01;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2015.04.29.01.17.52;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2015.04.09.01.12.32;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2015.03.28.02.41.45;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2014.12.10.21.30.34;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2014.10.31.17.43.45;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2014.05.13.00.13.22;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2014.04.07.18.06.10;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2014.03.13.18.12.26;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2013.11.22.00.22.49;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2013.11.21.21.23.52;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2013.11.20.01.02.49;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2013.10.24.21.10.23;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2013.10.17.18.36.15;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2013.10.09.00.26.27;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2013.10.02.00.48.55;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2013.09.25.16.39.53;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2013.09.21.00.24.21;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2013.09.17.22.47.49;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2013.09.17.00.52.15;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2013.08.30.02.45.38;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2013.08.20.00.33.40;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2013.08.16.02.50.42;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2013.08.13.02.23.06;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2013.07.18.01.10.57;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2013.06.29.00.18.04;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2013.05.31.00.42.12;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2013.05.22.20.09.50;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2013.05.21.01.47.34;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2013.05.17.00.52.01;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2013.04.05.23.20.47;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2013.02.01.23.42.25;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2013.01.14.21.22.51;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2013.01.02.21.41.31;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2012.12.20.01.05.26;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2012.11.14.00.59.23;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2012.11.08.23.21.51;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2012.11.05.19.04.28;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2012.10.22.18.15.47;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2012.10.09.00.48.31;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2012.08.16.17.58.00;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2012.08.08.19.57.06;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2012.07.31.00.49.02;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2012.06.07.22.46.03;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2012.06.07.00.53.25;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2012.05.08.17.51.58;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2012.04.26.23.30.04;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2012.04.20.01.06.03;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2012.03.12.17.11.46;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2012.02.24.21.22.02;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2012.02.16.22.39.02;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2012.01.25.01.18.05;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2012.01.18.20.38.36;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2011.12.15.01.50.26;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2011.11.30.21.30.00;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2011.11.04.23.46.45;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2011.11.04.00.24.39;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2011.07.20.00.53.40;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2011.06.16.20.51.24;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2011.04.20.16.46.00;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2011.04.13.00.28.15;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2011.04.07.23.35.31;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2011.03.08.18.29.22;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2010.07.06.16.05.37;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2010.07.01.00.49.33;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2010.06.18.16.48.34;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2010.05.24.16.33.52;	author honghanh;	state Exp;
branches;
next	2.36;

2.36
date	2010.05.23.03.31.24;	author honghanh;	state Exp;
branches;
next	2.35;

2.35
date	2010.05.19.23.06.45;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2010.04.28.16.23.52;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2010.04.22.23.36.00;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2010.02.04.23.12.44;	author vsnyder;	state Exp;
branches
	2.32.2.1;
next	2.31;

2.31
date	2009.12.14.18.35.51;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2009.10.27.22.14.24;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2009.09.01.17.14.02;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2009.08.24.20.14.11;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2009.07.21.20.34.56;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2009.07.10.20.56.52;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2009.06.30.15.19.05;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2009.05.13.20.41.55;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2009.05.01.23.44.40;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2009.04.30.22.13.29;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2009.04.30.20.15.01;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2009.04.29.23.11.04;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2009.04.28.20.03.49;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2009.04.16.21.55.23;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2009.04.13.20.45.57;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2009.03.05.18.38.32;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2008.10.15.16.37.28;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2008.09.24.16.46.09;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2008.09.20.00.03.00;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2008.09.16.22.30.19;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2008.08.14.20.58.40;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2008.08.06.17.27.47;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2008.06.06.21.02.49;	author michael;	state Exp;
branches;
next	2.7;

2.7
date	2008.04.26.00.39.56;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2008.04.11.01.17.09;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2008.01.07.21.43.03;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2007.11.05.18.41.20;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2007.11.01.23.33.59;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2007.10.04.20.43.12;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2007.09.27.21.59.00;	author pwagner;	state Exp;
branches;
next	;

2.32.2.1
date	2013.01.07.21.55.26;	author pwagner;	state Exp;
branches;
next	2.32.2.2;

2.32.2.2
date	2013.01.08.18.01.18;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.157
log
@Fixed problem where Infinite convergences were being written out to l2gps anyway.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module FillUtils_1                     ! Procedures used by Fill
  !=============================================================================

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Chunks_M, only: MLSChunk_T
  use Constants, only: Deg2rad, Ln10, Rad2deg
  use Diff_1, only: Diff
  use Dump_0, only: Dump
  use Expr_M, only: Expr, Expr_Check, GetindexFlagsfromlist
  use GriddedData, only: GriddedData_T, Dump, WrapGriddedData
  use HDF5, only: HSize_T, H5DOpen_F, H5DClose_F
  use HighOutput, only: BeVerbose, LetsDebug, OutputNamedValue
  use Init_Tables_Module, only: F_Measurements, F_TotalpowerVector, &
    & F_WeightsVector, &
    & L_Addnoise, L_Baseline, L_Binmax, L_Binmean, L_Binmin, L_Bintotal, &
    & L_Boundarypressure, L_Boxcar, L_Chisqbinned, L_Chisqchan, &
    & L_ChisqmMAF, L_ChisqmMIF, &
    & L_CloudinducedRadiance, L_Cloudminmax, &
    & L_Columnabundance, &
    & L_Dnwt_Flag, L_Dnwt_Chisqminnorm, L_Dnwt_Chisqnorm, L_Dnwt_Chisqratio, &
    & L_Dobsonunits, L_Du, &
    & L_Ecrtofov, &
    & L_Fieldazimuth, L_Fieldelevation, L_Fieldstrength, &
    & L_Geocaltitude, L_Geodaltitude, L_GPH, L_GHzAzim, &
    & L_Height, L_Isotoperatio, &
    & L_L1bMAFbaseline, L_L1bMIF_Tai, &
    & L_Limbsidebandfraction, L_Losvel, &
    & L_Lslocal, L_Lsglobal, L_Lsweighted, &
    & L_Magneticfield, L_Max, L_Mean, L_Min, L_Molcm2, &
    & L_Noisebandwidth, L_None, L_NoradsperMIF, L_Noradsbinned, &
    & L_Orbitinclination, L_Ascdescmode, &
    & L_Pressure, L_Ptan, L_Quality, &
    & L_Radiance, L_RefGPH, &
    & L_Refltemp, &
    & L_Sceci, L_Scecr, L_Instecr, L_Scgeocalt, L_Scveleci, L_Scvelecr, &
    & L_SingleChannelRadiance, &
    & L_Status, L_Surfacetype, L_Systemtemperature, &
    & L_Temperature, L_Time, L_TngtECI, L_TngtECR, L_TngtGeocAlt, &
    & L_TngtGeodAlt, L_TngtGeodLat, L_TotalPowerWeight, L_Vmr, &
    & L_Xyz, L_Zeta
  use Intrinsic, only: Field_Indices, Lit_Indices, &
    & Phyq_Angle, Phyq_Dimensionless, Phyq_Indices, Phyq_Invalid, &
    & Phyq_Length, Phyq_Pressure, Phyq_Temperature, Phyq_Zeta
  use L1BData, only: DeallocateL1BData, Dump, GetL1BFile, L1BData_T, &
    & Precisionsuffix, ReadL1BData, AssembleL1Bqtyname
  use L2GPData, only: L2GPData_T, ReadL2GPData, DestroyL2GPcontents
  use L2AUXData, only: L2AUXData_T, Maxsdnamesbufsize, &
    & ReadL2AUXData, DestroyL2AUXcontents
  use L3ascii, only: L3ascii_Interp_Field
  use ManipulateVectorQuantities, only: DoFGridsMatch, DoHGridsMatch, &
    & DoVGridsMatch, DoQtysDescribeSameThing
  use MatrixModule_0, only: MatrixElement_T, M_Full, &
    & CreateBlock, Sparsify, MatrixInversion
  use MatrixModule_1, only: Dump, FindBlock, Matrix_Spd_T, UpdateDiagonal
  ! Note: If You Ever Want To Include Defined Assignment For Matrices, Please
  ! Carefully Check Out The Code Around The Call To Snoop.
  use MLSCommon, only: MLSFile_T, DefaultUndefinedValue, MLS_HyperStart
  use MLSFiles, only: Hdfversion_5, Dump, GetMLSFileByType, GetPCFromRef
  use MLSFillValues, only: IsFillValue, IsFinite, IsInfinite, &
    & Monotonize, RemoveFillValues
  use MLSKinds, only: R4, R8, Rm, Rp, Rv
  use MLSL2options, only: Aura_L1bFiles, L2CFErrorNode, L2CFNode, Toolkit
  use MLSMessagemodule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
  use MLSNumerics, only: Coefficients, InterpolateArraySetup, &
    & InterpolateArrayTeardown, InterpolateValues, Hunt
  use MLSFinds, only: FindFirst, FindLast
  use MLSPCF2, only: MLSPCF_L2ascii_Start, MLSPCF_L2ascii_End
  use MLSSignals_M, only: GetFirstChannel, GetSignalName, GetModuleName, &
    & GetSignal, IsModuleSpacecraft, Signal_T, Signals
  use MLSStringLists, only: GetHashElement, NumStringElements, &
    & ReadNumsFromList, StringElement, StringElementNum, SwitchDetail
  use MLSStrings, only: Asciify, Indexes, LowerCase, WriteIntsToChars
  use Molecules, only: L_H2O
  use Monotone, only: IsMonotonic
  use Output_M, only: Blanks, Newline, Output
  use QuantityTemplates, only: QuantityTemplate_T
  use RHifromH2O, only: H2OprecfromRHi, RHifromH2O_Factor, RHiprecfromH2O
  use ScanModelModule, only: GetBasisGPH, Get2dHydrostaticTangentPressure, &
    & GetGPHPrecision
  use SpectroscopyCatalog_M, only: Catalog
  use String_Table, only: Display_String, Get_String
  use Toggles, only: Gen, Levels, Switches, Toggle
  use Trace_M, only: Trace_Begin, Trace_End
  use Tree, only: Decoration, Subtree, Nsons, Subtree
  use VectorsModule, only: &
    & ClearUnderMask, CloneVectorQuantity, CopyVector, CreateMask, &
    & DestroyVectorinfo, DestroyVectorQuantityMask, &
    & DestroyVectorQuantityValue, Dump, &
    & GetVectorqtyByTemplateIndex, GetVectorQuantityByType, &
    & IsVectorqtyMasked, MaskVectorqty, &
    & ValidateVectorQuantity, Vector_T, &
    & VectorValue_T, M_Cloud, M_Fill, M_Ignore, M_Linalg
  use VGridsDatabase, only: Vgrid_T, GetUnitForVerticalCoordinate

  implicit none
  private

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: FillUtils_1.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

  logical, parameter :: COUNTEMPTY = .true.
  logical, parameter :: DONTPAD = .false.
  logical, parameter :: WARNWHENPTANNONMONOTONIC = .false.

  ! -----     Declarations for Fill and internal subroutines     -------

  logical, parameter :: ADDSLASH = .false.
  logical, parameter :: DEEBUG = .FALSE.                 ! Usually FALSE
  logical, parameter :: UNIFORMCHISQRATIO = .FALSE.
  logical, parameter :: REPLACEINFS = .TRUE.
  integer, public    :: FILLERROR
  integer, public, parameter            :: M_All = 127 ! 2**7 - 1

  ! -999.99 ! Same as %template%badvalue
  real, parameter ::    UNDEFINED_VALUE = DEFAULTUNDEFINEDVALUE

  ! Error codes for "Announce_Error"
  integer, parameter, public :: No_Error_code = 0
  integer, parameter, public :: CantFromL2AUX = No_Error_code + 1
  integer, parameter, public :: CantFromL1B = cantFromL2AUX + 1

  ! Error codes for "Matrix" specification
  integer, parameter, public :: MissingField = cantFromL1B + 1

  ! More Error codes relating to Vector
  integer, parameter, public :: NegativePhiWindow = missingField + 1
  integer, parameter, public :: NumChansisZero = negativePhiWindow + 1
  integer, parameter, public :: NoSourceGridGiven= numChansisZero + 1
  integer, parameter, public :: NoSourceL2GPGiven= noSourceGridGiven + 1
  integer, parameter, public :: NoSourceL2AUXGiven= noSourceL2GPGiven + 1
  integer, parameter, public :: NoExplicitValuesGiven= noSourceL2AUXGiven + 1
  integer, parameter, public :: InvalidExplicitFill = noExplicitValuesGiven + 1
  integer, parameter, public :: BadIsotopeFill = invalidExplicitFill + 1
  integer, parameter, public :: BadlosGridFill = badIsotopeFill + 1
  integer, parameter, public :: CantInterpolate3d = badlosGridFill + 1
  integer, parameter, public :: WrongUnits = CantInterpolate3d + 1

  ! Error codes resulting from Covariance
  integer, parameter, public :: BothFractionAndLength = WrongUnits + 1
  integer, parameter, public :: Inconsistent = BothFractionAndLength + 1
  integer, parameter, public :: NotImplemented = Inconsistent + 1
  integer, parameter, public :: NotPlain = NotImplemented  + 1
  integer, parameter, public :: NotSPD = NotPlain + 1

  ! Miscellaneous
  integer, parameter, public :: BadGeocAltitudeQuantity = NotSPD + 1
  integer, parameter, public :: BadTemperatureQuantity = badGeocAltitudeQuantity + 1
  integer, parameter, public :: BadREFGPHQuantity = badTemperatureQuantity + 1
  integer, parameter, public :: BadGPHQuantity = badREFGPHQuantity + 1
  integer, parameter, public :: BadScVelECRQuantity = badGPHQuantity + 1
  integer, parameter, public :: Miscellaneous_err = BadScVelECRQuantity + 1
  integer, parameter, public :: ErrorReadingL1B = miscellaneous_err + 1
  integer, parameter, public :: NeedTempREFGPH = errorReadingL1B + 1
  integer, parameter, public :: NeedH2O = needTempRefGPH + 1
  integer, parameter, public :: NeedOrbitInclination = needH2O + 1
  integer, parameter, public :: NeedGeocAltitude = needOrbitInclination + 1
  integer, parameter, public :: NoCodeFor = needGeocAltitude + 1
  integer, parameter, public :: NonConformingHydrostatic = noCodeFor + 1
  integer, parameter, public :: NoSpecialFill = nonConformingHydrostatic + 1
  integer, parameter, public :: NoTotalPower = noSpecialFill + 1
  integer, parameter, public :: BadlosVelFill = noTotalPower + 1
  integer, parameter, public :: NotZetaForGrid = BadLosVelFill + 1
  integer, parameter, public :: BadEstNoiseFill = NotZetaForGrid + 1
  integer, parameter, public :: BadRefractFill = BadEstNoiseFill + 1
  integer, parameter, public :: MissingDataInGrid = BadRefractFill + 1
  integer, parameter, public :: EmptyGridForFill = MissingDataInGrid + 1

  logical :: UNITSERROR               ! From expr

  public :: AddGaussianNoise, ApplyBaseline, AutoFillVector, &
    & ComputeTotalpower, &
    & ExtractsingleChannel, Fillcovariance, Fromanother, Fromgrid, &
    & Froml2GP, FromproFile, Gather, GeoidData, Losvelocity, &
    & Chisqchan, ChisqmMAF, ChisqmMIF, Chisqratio, &
    & Colabundance, Derivativeofsource, FoldedRadiance, Phitanwithrefraction, &
    & HeightFromPressure, Iwcfromextinction, Rhifromortoh2o, NoradsperMIF, &
    & Rhiprecisionfromortoh2o, Withestnoise, &
    & Hydrostatically_GPH, Hydrostatically_PTan, FromSplitSideband, &
    & GPHPrecision, FromIsotope, FromAsciiFile, RotateMagneticField, &
    & Explicit, FromL1B, Froml2aux, Usingmagneticmodel, &
    & Frominterpolatedqty, Fromlosgrid, &
    & Bymanipulation, ManipulateVectors, NearestProFiles, &
    & Withreflectortemperature, Withascordesc, Withreichlerwmotp, &
    & Withwmotropopause, Withbinresults, Withboxcarfunction, &
    & Statusquantity, Qualityfromchisq, Convergencefromchisq, &
    & Usingleastsquares, OffsetRadiancequantity, ResetunusedRadiances, &
    & ResidualCorrection, Scaleoverlaps, Scatter, SpreadChannelfill, &
    & TransferVectors, TransferVectorsbymethod, UncompressRadiance, &
    & Announce_Error, QtyfromFile, VectorfromFile

  interface FromProfile
    module procedure FromProfile_node, FromProfile_values
  end interface

  logical, parameter :: WARNIFVERTCOORDNOTZETA = .false.

contains ! =====     Public Procedures     =============================

    ! ------------------------------------------- AddGaussianNoise -----
    subroutine AddGaussianNoise ( key, quantity, sourceQuantity, &
              & noiseQty, multiplier, spread, ignoreTemplate )
      use MLSRandomNumber, only: DRang
      ! A special fill: quantity = sourceQuantity + g() noiseQty
      ! where g() is a random number generator with mean 0 and std. dev. 1
      ! Generalized into ( a sourceQuantity + b g() noiseQty )
      ! where a and b are multipliers)
      ! Formal arguments
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) ::      quantity
      type (VectorValue_T), intent(in) ::         sourceQuantity
      type (VectorValue_T), intent(in) ::         noiseQty
      real, dimension(:), intent(in)   ::         multiplier
      logical, intent(in)              ::         ignoreTemplate
      logical, intent(in)              ::         spread

      ! Local variables
      integer                          ::    ROW, COLUMN
      real                             ::    a, b
      integer :: Me = -1               ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.addGaussianNoise', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! First check that things are OK.
      if ( .not. ignoreTemplate .and. .not. FillableChiSq ( quantity, &
        & sourceQuantity, noiseQty ) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Incompatibility among vector quantities adding noise'  )
        go to 9
      end if

     ! Either multiplier = [a, b] or multiplier = b are possible
      if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
        a = 1.
        b = 1.
      else if ( multiplier(2) == UNDEFINED_VALUE ) then
        a = 1.
        b = multiplier(1)
      else
        a = multiplier(1)
        b = multiplier(2)
      end if

      if ( spread .and. &
        & size(quantity%values, 1) /= size(sourceQuantity%values, 1) ) then
        do column=1, size(quantity%values(1, :))
          quantity%values(:, column) = &
            & sourceQuantity%values(1, column) * a &
            & + &
            & drang() * noiseQty%values(1, column) * b
        end do
      else if ( spread .and. &
        & size(quantity%values, 2) /= size(sourceQuantity%values, 2) ) then
        do row=1, size(quantity%values(:, 1))
          quantity%values(row, :) = &
            & sourceQuantity%values(row, :) * a &
            & + &
            & drang() * noiseQty%values(row, :) * b
        end do
      else
        do column=1, size(quantity%values(1, :))
          do row=1, size(quantity%values(:, 1))
            quantity%values(row, column) = &
              & sourceQuantity%values(row, column) * a &
              & + &
              & drang() * noiseQty%values(row, column) * b
          end do
        end do
      end if

    9 call trace_end ( 'FillUtils_1.addGaussianNoise', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine AddGaussianNoise

    ! ---------------------------------------------  Announce_Error  -----
    ! How Fill and FillUtils ought to handle errors.
    ! This is a model for coding other modules, too.
    ! Note that by default we merely print a message w/o quitting.
    !
    ! We set FillError and pass control back up the calling tree, leaving
    ! the decision to quit or not to the caller or caller's caller or ..
    subroutine Announce_Error ( WhereWasIt, Code, &
      & Extramessage, Qty, Extrainfo, Quitnow )

      use Moretree, only: Get_Field_Id, Starterrormessage

      integer, intent(in) :: WhereWasIt   ! Tree node WhereWasIt error was noticed
      integer, intent(in) :: CODE    ! Code for error message
      character (len=*), intent(in), optional :: EXTRAMESSAGE
      type (VectorValue_T), optional, intent(in) :: QTY
      integer, intent(in), dimension(:), optional :: EXTRAINFO
      logical, intent(in), optional :: QUITNOW ! If present and TRUE, stop
      ! Internal variables

      integer :: I
      ! Executable

      fillerror = max(fillerror,1)
      if ( present(extraMessage) ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & trim(extraMessage) )
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Calling Announce_Error' )
      end if
      call StartErrorMessage ( WhereWasIt )
      L2CFErrorNode = WhereWasIt
      if ( code  > no_Error_Code ) call output ( 'The' );

      select case ( code )
      case ( badEstNoiseFill )
        call output ( " estimated noise fill is missing information", advance='yes' )
      case ( badGeocAltitudeQuantity )
        call output ( " geocAltitudeQuantity is not geocAltitude", advance='yes' )
      case ( badlosGridfill )
        call output ( " information for los Grid fill is incomplete/incorrect", advance='yes' )
      case ( badlosvelfill )
        call output ( " information for los velocity is incomplete/incorrect", advance='yes' )
      case ( badIsotopeFill )
        call output ( " information for isotope fill is incomplete/incorrect", advance='yes' )
      case ( badGPHQuantity )
        call output ( " GPHQuantity is not GPH", advance='yes' )
      case ( badREFGPHQuantity )
        call output ( " refGPHQuantity is not refGPH", advance='yes' )
      case ( badRefractFill )
        call output ( " phiTan refract fill is missing information", advance='yes' )
      case ( BadScVelECRQuantity )
        call output ( " scVelQuantity quantity is not scVelQuantity", advance='yes' )
      case ( badTemperatureQuantity )
        call output ( " temperatureQuantity is not temperature", advance='yes' )
      case ( bothFractionAndLength )
        call output ( " config specifies both fraction and lengthScale", advance='yes' )
      case ( cantFromL1B )
        call output ( " command could not be filled from L1B.", advance='yes' )
      case ( cantFromL2AUX )
        call output ( " command could not be filled from L2AUX.", advance='yes' )
      case ( cantInterpolate3D )
        call output ( " program cannot interpolate 3d quantities (yet).", advance='yes' )
      case ( emptyGridForFill )
        call output ( " config specifies an empty grid for the fill", advance='yes' )
      case ( errorReadingL1B )
        call output ( " L1B file could not be read.", advance='yes' )
      case ( inconsistent )
        call output ( " matrix and vector are inconsistent.", advance='yes' )
      case ( invalidExplicitFill )
        call output ( " value has inappropriate dimensionality for explicit fill.", advance='yes' )
        call output ( " Should have " )
        call output ( extraInfo )
        call output ( " elements.", advance='yes' )
      case ( missingDataInGrid )
        call output ( " grid for fill has missing/bad data points", advance='yes' )
      case ( missingField )
        call output ( " fields " )
        do i = 1, size(extraInfo)
          call display_string ( field_indices(extraInfo(i)) )
          if ( i == size(extraInfo) ) then
            call output ( " and " )
          else
            call output ( ", " )
          end if
        end do
        call output ( " are required.", advance='yes' )
      case ( noCodeFor )
        call output ( 're is no code for the "' )
        call display_string ( field_indices(extraInfo(1)) )
        call output ( '" field', advance='yes' )
      case ( needGeocAltitude )
        call output ( " fill needs geocAltitudeQuantity.", advance='yes' )
      case ( needH2O )
        call output ( " fill needs H2OQuantity.", advance='yes' )
      case ( needOrbitInclination )
        call output ( " fill needs OrbitalInclination.", advance='yes' )
      case ( needTempREFGPH )
        call output ( " needs temperatureQuantity and refGPHquantity.", advance='yes' )
      case ( negativePhiWindow )
        call output ( " has a negative value for phiWindow.", advance='yes' )
      case ( no_Error_Code ) ! Handled at the bottom
      case ( noExplicitValuesGiven )
        call output ( " explicit fill requires explicit values.", advance='yes' )
      case ( nonConformingHydrostatic )
        call output ( " quantities needed for hydrostatic fill do not conform", advance='yes' )
      case ( noSourceGridGiven )
        call output ( " gridded fill requires a sourceGrid field.", advance='yes' )
      case ( noSourceL2AUXGiven )
        call output ( " L2AUX fill requires a sourceL2AUX field.", advance='yes' )
      case ( noSourceL2GPGiven )
        call output ( " L2GP fill requires a sourceL2GP field.", advance='yes' )
      case ( noSpecialFill )
        call output ( " special fill is invalid", advance='yes' )
      case ( noTotalPower )
        call output ( " total power weights are zero", advance='yes' )
      case ( notImplemented )
        call output ( extraMessage )
        call output ( " method is not implemented yet.", advance='yes' )
      case ( notSPD )
        call output ( " matrix is not a SPD matrix.", advance='yes' )
      case ( notPlain )
        call output ( " matrix is not a plain matrix.", advance='yes' )
      case ( NotZetaForGrid )
        call output ( " Quantity not on zeta surfaces.", advance='yes' )
      case ( wrongUnits )
        call display_string ( field_indices(Get_Field_Id(WhereWasIt)), &
          & before=" values of the " )
        call output ( " field have the wrong units", advance="yes" )
        if ( present(extraInfo) ) then
          i = 1
          if ( size(extraInfo) > 1 ) then
            call display_String ( phyq_indices(extraInfo(1)), &
              & before="Units are " )
            call output ( ", " )
            i = 2
          end if
          call display_String ( phyq_indices(extraInfo(i:)), advance='yes', &
            & before="Units should be" )
        end if
      case default
        call outputNamedValue( ' error code', Code, advance='no' )
        call output ( " command caused an unrecognized programming error", advance='yes' )
      end select
      if ( present(ExtraMessage) )  call output(ExtraMessage, advance='yes')
      if ( code == no_Error_Code .and. present(extraInfo) ) &
        & call dump ( extraInfo, name='Extra info' )
      if ( present(qty) ) call dump( qty )
      if ( present(QUITNOW) ) then
        if ( QUITNOW ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & trim(extraMessage) )
      end if
    end subroutine Announce_Error

    ! ------------------------------------------- ApplyBaseline ----------
    subroutine ApplyBaseline ( key, quantity, baselineQuantity, &
      & quadrature, dontMask, ignoreTemplate )
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Radiance quantity to modify
      type (VectorValue_T), intent(in) :: BASELINEQUANTITY ! L1B MAF baseline to use
      logical, intent(in) :: QUADRATURE ! If set add in quadrature (for noise)
      logical, intent(in) :: DONTMask ! If set ignore baselinequantity Mask
      logical, intent(in) :: IGNORETEMPLATE
      ! Local variables
      integer :: MIF
      integer :: CHAN
      integer :: IND                    ! Combined MIF/CHAN
      integer :: i
      integer :: Me = -1                ! String index for trace
      integer :: numProfs
      logical :: skipMe
      logical :: debug

      ! Executable code
      debug = ignoreTemplate
      call trace_begin ( me, 'FillUtils_1.ApplyBaseline', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( .not. ignoreTemplate ) then
        if ( quantity%template%quantityType /= l_radiance ) &
          & call Announce_Error ( key, no_Error_Code, &
          &   'Quantity to fill must be a radiance' )
        if ( baselineQuantity%template%quantityType /= l_l1bMAFBaseline ) &
          & call Announce_Error ( key, no_Error_Code, &
          &   'Quantity to fill must be a L1BMAFBaseline' )
        if ( baselineQuantity%template%signal /= quantity%template%signal .or. &
          &  baselineQuantity%template%sideband /= quantity%template%sideband ) &
          & call Announce_Error ( key, no_Error_Code, &
          &   'Quantity and baselineQuantity must have matching signal/sideband' )
      end if
      ind = 1
      numProfs = size( quantity%values ( ind, : ) )
      if ( debug ) then
        call outputNamedValue( 'quadrature', quadrature )
        call outputNamedValue( 'dontMask', quadrature )
        call outputNamedValue( 'masked Quantity?', associated(Quantity%Mask) )
      endif
      if ( quadrature ) then
        do mif = 1, quantity%template%noSurfs
          do chan = 1, quantity%template%noChans
            ! if ( .not. dontMask .and. associated(Quantity%Mask) ) then
            if ( .not. dontMask .and. associated(baselineQuantity%Mask) ) then
              do i=1, numProfs
                skipMe = .not. dontMask .and. &
                  &  isVectorQtyMasked(baselineQuantity, chan, i, m_linAlg)
                  ! &  isVectorQtyMasked(Quantity, chan, i, m_linAlg)
                if ( .not. skipMe )  &
                & quantity%values ( ind, i ) = sqrt ( &
                  & quantity%values ( ind, i )**2 + &
                  & baselineQuantity%values ( chan, i )**2 )
              end do
            else
              quantity%values ( ind, : ) = sqrt ( quantity%values ( ind, : )**2 + &
                & baselineQuantity%values ( chan, : )**2 )
            end if
            ind = ind + 1
          end do
        end do
      else
        do mif = 1, quantity%template%noSurfs
          do chan = 1, quantity%template%noChans
            ! if ( .not. dontMask .and. associated(Quantity%Mask) ) then
            if ( .not. dontMask .and. associated(baselineQuantity%Mask) ) then
              do i=1, numProfs
                skipMe = .not. dontMask .and. &
                  &  isVectorQtyMasked(baselineQuantity, chan, i, m_linalg)
                  ! &  isVectorQtyMasked(Quantity, chan, i, m_linalg)
                if ( .not. skipMe )  &
                & quantity%values ( ind, i ) = &
                  & quantity%values ( ind, i ) + &
                  & baselineQuantity%values ( chan, i )
              end do
            else
              quantity%values ( ind, : ) = quantity%values ( ind, : ) + &
                & baselineQuantity%values ( chan, : )
            end if
            ind = ind + 1
          end do
        end do
      end if
      call trace_end ( 'FillUtils_1.ApplyBaseline', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ApplyBaseline

    ! --------------------------------------------- AutoFillVector -----
    subroutine AutoFillVector ( vector )
      ! Automatically Fill items in vector we know how to
      type (Vector_T), intent(inout) :: Vector

      ! Local variables
      type (VectorValue_T), pointer :: SQ ! vector quantity
      integer :: Me = -1                  ! String index for trace
      integer :: MOL                      ! Molecule index
      integer :: SQI                      ! Quantity index
      character(len=32) :: str
      ! DEEBUG = .true.
      ! Executable code

      call trace_begin ( me, 'FillUtils_1.AutoFillVector', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
      ! Loop over its qtys
      do sqi = 1, size ( vector%quantities )
        sq => vector%quantities(sqi)
        select case(sq%template%quantityType)
        case ( l_isotoperatio )
          mol = sq%template%molecule
          if ( mol > 0 ) then
            call Get_String ( lit_indices(mol), str, strip=.true. )
            sq%values = Catalog(mol)%DefaultIsotopeRatio
            if ( DEEBUG ) then
              call outputNamedValue( 'molecule', str )
              call outputNamedValue( 'isotoperatio', Catalog(mol)%DefaultIsotopeRatio )
            end if
          end if
        case default
        end select
      end do
      call trace_end ( cond=toggle(gen) .and. levels(gen) > 2 )
    end subroutine AutoFillVector

    !--------------------------------------------------  NearestProfiles  -----
    subroutine NearestProfiles ( quantity, HGrid, ProfileOffset )
    use HGridsDatabase, only: HGrid_T

      ! This routine is called from MLSL2Fill to fill values of
      ! a maf-based quantity with the nearest profile indexes
      ! Method:
      ! There is a maf array already in HGrid
      ! We just need to invert it
      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! The quantity to fill
      type (HGrid_T)                      :: HGrid
      integer, intent(in)                 :: ProfileOffset
      ! Internal variables
      integer :: i
      integer :: profile
      ! Executable
      quantity%values = -999.
      do i=1, quantity%template%noInstances
        profile = FindFirst ( HGrid%maf, i )
        if ( profile > 0 ) quantity%values(:, i) = profile + ProfileOffset
      end do

    end subroutine NearestProfiles

    !--------------------------------------------------  Explicit  -----
    subroutine Explicit ( quantity, valuesNode, spreadFlag, force, &
      & globalUnit, channel, AzEl, options, FillValue, extraQuantity )

      ! This routine is called from MLSL2Fill to fill values from an explicit
      ! fill command line or as part of a compound Fill,
      ! Fill with height (range) specified

      ! Use (1): extraQuantity not present
      ! values node must be same shape as quantity or else /spread flag
      ! spreads scalar values over all (unMasked) quantity%values

      ! Use (2): extraQuantity present
      ! values node ignored
      ! sends ExtraQuantity%values into all (unMasked) quantity%values

      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! The quantity to fill
      integer, intent(in) :: VALUESNODE   ! Tree node
      logical, intent(in) :: SPREADFLAG   ! One instance given, spread to all
      logical, intent(in) :: FORCE        ! Fill in as many instances as will fit
      integer, intent(in) :: GLOBALUNIT   ! From parent vector
      integer, intent(in) :: CHANNEL
      logical, intent(in), optional :: AzEl ! Values are in [Mag, Az, El]; the
        ! desired quantity is components of Mag in the coordinate system to
        ! which Az and El are referenced.  So the number of values has to be
        ! a multiple of 3.
                                          ! (defaults to replacing all)
      ! The options are peculiar to this procedure, apart from verbose
      ! option           meaning
      ! ------           -------
      !   v              verbose
      !   e              replace only values in quantity == Value
      !   n              replace only values in quantity != Value
      !   a              replace only values at heights above specified height
      !   b              replace only values at heights below specified height
      !                   (defaults to replacing all)
      character (len=*), optional, intent(in) :: options ! E.g., '-v'
      real(r8), intent(in), optional :: FillValue
      type (VectorValue_T), optional :: EXTRAQUANTITY ! Instead of Value

      ! Local variables
      integer :: chan
      integer :: K                        ! Loop counter
      integer :: I,J                      ! Other indices
      integer :: Me = -1                  ! String index for trace
      logical :: MyAzEl
      real(kind(quantity%values)) :: myValue
      character (len=8) :: myOptions
      integer :: NoValues
      integer :: numChans
      integer :: surf
      integer :: TestUnit                 ! Unit to use
      integer, dimension(2) :: unitAsArray ! Unit for value given
      real (r8), pointer, dimension(:) :: VALUES
      real (r8), dimension(2) :: valueAsArray ! Value given
      logical :: Verbose
      character(len=2) :: whichToReplace ! '/=' (.ne. fillValue), '==', or ' ' (always)

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.Explicit', valuesNode, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      myAzEl = .false.
      if ( present(azEl) ) myAzEl = azEl
      myOptions = ' '
      if ( present(options) ) myOptions = options

      testUnit = quantity%template%unit
      if ( globalUnit /= phyq_Invalid ) testUnit = globalUnit
      noValues = -1 ! if we will ignore valuesNode
      if ( .not. present(ExtraQuantity) ) noValues = nsons(valuesNode) - 1
      if ( Force ) noValues = min( noValues, &
        & quantity%template%instanceLen * quantity%template%noInstances )

      myValue = 0.
      if ( present(FillValue) ) myValue = FillValue

      whichToReplace = ' '
      if ( index(myOptions, 'e') > 0 ) then
        whichToReplace = '=='
      else if ( index(myOptions, 'n') > 0 ) then
        whichToReplace = '/='
      end if
      verbose = ( index(myOptions, 'v') > 0 )

      if ( .not. present(extraQuantity) ) then
        ! Check the dimensions work out OK
        if ( myAzEl .and. mod(noValues,3) /= 0 ) &
            & call Announce_Error ( valuesNode, invalidExplicitFill )
        if ( spreadFlag ) then
          if ( noValues /= quantity%template%instanceLen .and. &
            & noValues /= quantity%template%noChans .and. &
            & noValues /= 1 ) &
            & call Announce_Error ( valuesNode, invalidExplicitFill )
        else if ( .not. Force ) then
          if ( noValues /= &
            & quantity%template%instanceLen * quantity%template%noInstances ) &
            & call Announce_Error ( valuesNode, invalidExplicitFill, &
              & extraInfo = (/ &
                & quantity%template%instanceLen * quantity%template%noInstances /) )
        end if

        ! Get the values the user asked for, checking their units
        nullify ( values )
        call Allocate_test ( values, noValues, 'values', ModuleName )
        if ( .not. myAzEl ) then
          do k = 1, noValues
            call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
              & (/testUnit, PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_Error ( valuesNode, wrongUnits, &
              & extraInfo=(/unitAsArray(1), testUnit, PHYQ_Dimensionless/) )
            values ( k ) = valueAsArray(1)
          end do
        else
          ! Convert from Mag, Az, El to 3-D projections
          do k = 1, noValues, 3
            call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
              & (/testUnit, PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_Error ( valuesNode, wrongUnits, &
              & extraInfo=(/unitAsArray(1), testUnit, PHYQ_Dimensionless/) )
            values ( k ) = valueAsArray(1)
            ! Next two quantities have to be angles
            call expr_check ( subtree(k+2,valuesNode) , unitAsArray, valueAsArray, &
              & (/PHYQ_Angle/), unitsError )
            if ( unitsError ) call Announce_Error ( valuesNode, wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
            values (k+1) = deg2rad * valueAsArray(1)
            call expr_check ( subtree(k+3,valuesNode) , unitAsArray, valueAsArray, &
              & (/PHYQ_Angle/), unitsError )
            if ( unitsError ) call Announce_Error ( valuesNode, wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
            values (k+2) = deg2rad * valueAsArray(1)
            values(k:k+2) = values(k) * (/ cos(values(k+1))*cos(values(k+2)), &
                                           sin(values(k+1))*cos(values(k+2)), &
                                           sin(values(k+2)) /)
          end do
        end if

        if ( verbose ) then
          call output('Explicit fill of values for ', advance='no')
          call display_string ( quantity%template%name )
          call newline
          call output(values)
          call newline
        end if
      end if

      if ( quantity%template%noSurfs < 1 ) then
        call Announce_Error ( valuesNode, no_error_code, &
          & 'Bad value for quantity%template%noSurfs' )
        go to 9
      end if
      if ( quantity%template%noCrossTrack < 1 ) then
        call Announce_Error ( valuesNode, no_error_code, &
          & 'Bad value for quantity%template%noCrossTrack' )
        go to 9
      end if

      numChans = quantity%template%instanceLen / &
        & ( quantity%template%noSurfs * quantity%template%noCrossTrack )
      if ( numChans /= quantity%template%noChans ) then
        call outputNamedValue( 'noSurfs', quantity%template%noSurfs )
        call outputNamedValue( 'noChans', quantity%template%noChans )
        call outputNamedValue( 'noCrossTrack', quantity%template%noCrossTrack)
        call outputNamedValue( 'numChans', numChans )
        call outputNamedValue( 'instanceLen', quantity%template%instanceLen )
        call Announce_Error ( valuesNode, no_Error_Code, &
          & 'Inconsistent template instance length' )
      end if
      ! Now loop through the quantity
      k = 0
      do i = 1, quantity%template%noInstances
        j = 0
        do surf = 1, quantity%template%noSurfs
          ! Have we specified which height to fill?
          do chan = 1, numChans
            j = j + 1
            k = k + 1
            if ( associated ( quantity%Mask ) ) then
              if ( iand ( ichar(quantity%Mask(j,i)), m_Fill ) /= 0 ) cycle
            end if
            select case (whichToReplace)
            case ('/=')
              if ( quantity%values(j,i) == myValue ) cycle
            case ('==')
              if ( quantity%values(j,i) /= myValue ) cycle
            end select
            ! Have we specified which channel to fill?
            if ( channel /= 0 ) then
              if ( channel /= chan ) cycle
            end if
            if ( present(extraQuantity) ) then
              quantity%values(j,i) = extraQuantity%values(j,i)
            else
              quantity%values(j,i) = values ( mod ( k-1, noValues ) + 1 )
            end if
          end do
        end do
      end do

      if ( verbose ) then
        call output(quantity%values(1,:))
        call newline
      end if
      ! Housekeeping
      if ( .not. present(extraQuantity) ) &
        & call Deallocate_test ( values, 'values', ModuleName )
      ! No, don't do this, because sourceHeights might be our vgrid
      ! call Deallocate_test ( sourceHeights, 'sourceHeights', ModuleName )
      9 call trace_end ( 'FillUtils_1.Explicit', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine Explicit

    ! ------------------------------------------- ComputeTotalPower
    subroutine ComputeTotalPower ( key, vectors )
      use MoreTree, only: Get_field_id

      ! Arguments
      integer, intent(in) :: KEY        ! Tree node
      type (Vector_T), pointer, dimension(:) :: vectors

      ! Local variables
      integer :: J                      ! Tree index
      integer :: FIELD                  ! Entry in tree
      integer :: SON                    ! Tree node
      integer :: I                      ! Loop counter
      integer :: K                      ! Loop counter
      integer :: SIGNAL                 ! the signal we're looking for

      type (Vector_T), pointer :: MEASUREMENTS ! The measurement vector to compute total power for
      type (Vector_T), pointer :: TOTALPOWERVECTOR ! The total power vector to fill
      type (Vector_T), pointer :: WEIGHTSVECTOR ! The vector of weights to use

      type (VectorValue_T), pointer :: RADIANCES ! The radiances for this band
      type (VectorValue_T), pointer :: THISRESULT ! The total power quantity to fill
      type (VectorValue_T), pointer :: WEIGHTSQUANTITY ! The total power quantity to fill

      integer :: Me = -1                ! String index for trace
      real(rv) :: TOTALWEIGHT

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ComputeTotalPower', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      do i = 2, nsons(key)
        son = subtree(i,key)
        field = get_field_id(son)
        select case ( field )
        case ( f_measurements )
          measurements => vectors(decoration(decoration(subtree(2,son))))
        case ( f_totalPowerVector )
          totalPowerVector => vectors(decoration(decoration(subtree(2,son))))
        case ( f_weightsVector )
          weightsVector => vectors(decoration(decoration(subtree(2,son))))
        end select
      end do ! i = 2, nsons(key)

      ! Loop over the quantities in the total power vector

      do i = 1, totalPowerVector%template%noQuantities
        if ( totalPowerVector%quantities(i)%template%quantityType /= l_baseline .or. &
          & .not. totalPowerVector%quantities(i)%template%minorFrame ) then
          call Announce_Error ( key, no_error_code, 'Total power quantity must be minor frame baseline' )
        end if
        totalWeight = 0.0_rv
        thisResult => totalPowerVector%quantities(i)
        thisResult%values = 0.0_rv
        ! Now go through all the bands in the measurement vector that are in this radiometer
        do j = 1, measurements%template%noQuantities
          if ( measurements%quantities(j)%template%quantityType /= l_radiance ) cycle
          if ( measurements%quantities(j)%template%radiometer /= thisResult%template%radiometer ) cycle
          radiances => measurements%quantities(j)
          signal = measurements%quantities(j)%template%signal
          ! Now look for the weights for this band
          weightsQuantity => GetVectorQuantityByType ( weightsVector, quantityType=l_totalPowerWeight, &
            & signal=signal )
          do k = 1, radiances%template%noChans
            thisResult%values(:,:) = thisResult%values(:,:) + &
              & weightsQuantity%values(k,1) * &
              &   radiances%values(k:radiances%template%instanceLen:radiances%template%noChans,:)
            totalWeight = totalWeight + weightsQuantity%values(k,1)
          end do                        ! End loop over channels
        end do                          ! End loop over bands

!debug
!call dump(thisResult%values, 'beforedivide')


        if ( totalWeight == 0 ) then
          thisResult%values = 0         ! Don't divide by zero
        else
          thisResult%values = thisResult%values / totalWeight
        end if
      end do                            ! End loop over (effectively) radiometers
      call trace_end ( 'FillUtils_1.ComputeTotalPower', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ComputeTotalPower

    ! -------------------------------------  ExtractSingleChannel  -----
    subroutine ExtractSingleChannel ( key, quantity, sourceQuantity, &
      & channel, ignoreTemplate )
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY ! Source quantity for radiances
      integer, intent(in) :: CHANNEL    ! Channel number
      logical, intent(in)              :: ignoreTemplate
      ! Local variables
      integer :: CHANIND                ! Channel index
      integer :: Me = -1                ! String index for trace
      integer :: MIF                    ! Minor frame index
      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ExtractSingleChannel', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( .not. ignoreTemplate ) then
        if ( quantity%template%quantityType /= l_singleChannelRadiance ) &
          & call Announce_Error ( key, no_Error_Code, 'Quantity to fill must be of type singleChannelRadiance' )
        if ( all ( sourceQuantity%template%quantityType /= (/ l_cloudInducedRadiance, l_radiance /) ) ) &
          & call Announce_Error ( key, no_Error_Code, 'source quantity for fill must be of type [cloudInduced]radiance' )
        if ( quantity%template%signal /= sourceQuantity%template%signal .or. &
          & quantity%template%sideband /= sourceQuantity%template%sideband ) &
          & call Announce_Error ( key, no_Error_Code, 'quantity/sourceQuantity must be same signal/sideband' )
        if ( .not. sourceQuantity%template%regular ) &
          & call Announce_Error ( key, no_Error_Code, 'source quantity must be regular' )
      end if
      chanInd = channel - GetFirstChannel ( quantity%template%signal ) + 1
      do mif = 1, quantity%template%noSurfs
        quantity%values ( mif, : ) = &
          & sourceQuantity%values ( chanInd + ( mif - 1 ) * sourceQuantity%template%noChans, : )
      end do
      call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine ExtractSingleChannel

    ! ------------------------------------------------  ChiSqChan  -----
    subroutine ChiSqChan ( key, qty, measQty, modelQty, noiseQty, &
    & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier, &
    & firstInstance, lastInstance )
      ! A special fill of chi squared
      ! broken out according to channels
      ! Formal arguments
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) ::    modelQty
      type (VectorValue_T), intent(in) ::    measQty
      type (VectorValue_T), intent(in) ::    noiseQty
      logical, intent(in)           ::       dontMask    ! Use even Masked values
      logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
      logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
      real, dimension(:), intent(in) ::      multiplier
      logical, intent(in)           ::       IGNORETEMPLATE

      integer, intent(in), optional ::       firstInstance, lastInstance
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in qty

      ! Local variables
      real(r8), dimension(:), pointer  ::    VALUES => NULL()
      integer ::                             UseFirstInstance, UseLastInstance, &
      &                                      NoOutputInstances
      integer ::                             C           ! Channel loop counter
      integer ::                             S           ! Surface loop counter
      integer ::                             I           ! Instances
      integer ::                             QINDEX
      integer :: Me = -1                     ! String index for trace
      integer ::                             NOCHANS
      integer ::                             N           ! Num. of summed values
      logical ::                             skipMe
      real                             ::    a, b

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ChiSqChan', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
      if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
        a = 1.
        b = 1.
      else if ( multiplier(2) == UNDEFINED_VALUE ) then
        a = 0.
        if ( multiplier(1) /= 0.0 ) a = 1.0/multiplier(1)
        b = a
      else
        a = multiplier(1)
        b = multiplier(2)
      end if

      ! First check that things are OK.
      if ( ignoreTemplate ) then
        ! Anything goes
      else if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_chiSqChan/), majorFrame=.true.) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Attempting to fill wrong quantity with chi^2 channelwise'  )
        if ( DEEBUG ) then
          call output('major frame? ', advance = 'no')
          call output(qty%template%majorFrame, advance = 'no')
          call output('   quantity type ', advance = 'no')
          call output(qty%template%quantityType, advance = 'no')
          call output('   compared with ', advance = 'no')
          call output(l_chiSqChan, advance = 'yes')
        end if
        go to 9
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Incompatibility among vector quantities filling chi^2 channelwise'  )
        go to 9
      else if ( any ( noiseQty%values == 0.0) .and. &
        & .not. (ignoreZero .or. .not. dontMask) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'A vanishing error filling chi^2 channelwise'  )
        go to 9
      end if

      ! Work out what to do with the first and last Instance information

      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) go to 9

      call allocate_test(values, measQty%template%noSurfs, &
        & 'chi^2 unsummed', ModuleName)
      noChans = qty%template%noChans
      do i=useFirstInstance, useLastInstance
        do c=1, noChans
          N = 0
          values = 0.0
          do s=1, measQty%template%noSurfs
            qIndex = c + (s-1)*nochans
            skipMe = &
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, qIndex, i, m_linalg) .or. &
            &   isVectorQtyMasked(modelQty, qIndex, i, m_linalg) .or. &
            &   isVectorQtyMasked(noiseQty, qIndex, i, m_linalg) ) &
            & .or. (ignoreNegative .and. noiseQty%values(qIndex, i) < 0.0 ) &
            & .or. (ignoreZero .and. noiseQty%values(qIndex, i) == 0.0 )
            if ( .not. skipMe ) then
              values(s) = ( &
              & (a*measQty%values(qIndex, i) - b*modelQty%values(qIndex, i)) &
              & / &
              & noiseQty%values(qIndex, i) &
              &  ) ** 2
              N = N + 1
            end if
          end do
          if ( N > 0 ) then
            qty%values(c, i) = sum(values) / N
          else
            qty%values(c, i) = 0.
          end if
        end do
      end do
      call deallocate_test(values, &
        & 'chi^2 unsummed', ModuleName)
    9 call trace_end ( 'FillUtils_1.ChiSqChan', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ChiSqChan

    ! ------------------------------------------------  ChiSqMMaf  -----
    subroutine ChiSqMMaf ( key, qty, measQty, modelQty, noiseQty, &
    & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier, &
    & firstInstance, lastInstance )
      ! A special fill of chi squared
      ! broken out according to major frames
      ! Formal arguments
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) ::    modelQty
      type (VectorValue_T), intent(in) ::    measQty
      type (VectorValue_T), intent(in) ::    noiseQty
      logical, intent(in)           ::       dontMask    ! Use even Masked values
      logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
      logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
      real, dimension(:), intent(in) ::      multiplier
      logical, intent(in)           ::       IGNORETEMPLATE

      integer, intent(in), optional ::       firstInstance, lastInstance
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in the qty

      ! Local variables
      real(r8), dimension(:), pointer  ::    VALUES => NULL()
      integer ::                             UseFirstInstance, UseLastInstance, &
      &                                      NoOutputInstances
      integer ::                             I           ! Instances
      integer ::                             INSTANCELEN ! Num of rows
      integer :: Me = -1                     ! String index for trace
      integer ::                             N           ! Num. of summed values
      integer ::                             ROW         ! Running 1st coord
      logical ::                             skipMe

      real                             ::    a, b

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ChiSqMMaf', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
      ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
      if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
        a = 1.
        b = 1.
        a = 1.
        b = 1.
      else if ( multiplier(2) == UNDEFINED_VALUE ) then
        a = 0.
        if ( multiplier(1) /= 0.0 ) a = 1.0/multiplier(1)
        b = a
      else
        a = multiplier(1)
        b = multiplier(2)
      end if

      ! First check that things are OK.
      if ( ignoreTemplate ) then
        ! Anything goes
      else if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_chiSqMMaf/), majorFrame=.true.) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Attempting to fill wrong quantity with chi^2 MMAFwise'  )
        if ( DEEBUG ) then
          call output('major frame? ', advance = 'no')
          call output(qty%template%majorFrame, advance = 'no')
          call output('   quantity type ', advance = 'no')
          call output(qty%template%quantityType, advance = 'no')
          call output('   compared with ', advance = 'no')
          call output(l_chiSqMMaf, advance = 'yes')
        end if
        go to 9
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Incompatibility among vector quantities filling chi^2 MMAFwise'  )
        go to 9
      else if ( any ( noiseQty%values == 0.0) .and. &
        & .not. (ignoreZero .or. .not. dontMask) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'A vanishing noise filling chi^2 MMAFwise'  )
        go to 9
      end if

      ! Work out what to do with the first and last Instance information

      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) go to 9

      instanceLen = measQty%template%noChans * measQty%template%noSurfs
      call allocate_test(values, instanceLen, &
        & 'chi^2 unsummed', ModuleName)
      do i=useFirstInstance, useLastInstance
        if ( .not. (.not. dontMask .or. ignoreNegative .or. ignoreZero ) ) then
            values = ( &
            & (measQty%values(:, i) - modelQty%values(:, i)) &
            & / &
            & noiseQty%values(:, i) &
            &  ) ** 2
            qty%values(1, i) = sum(values) / instanceLen
        else
          N = 0
          values = 0.0
          do row = 1, instanceLen
            skipMe = &
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, row, i, m_linalg) .or. &
            &   isVectorQtyMasked(modelQty, row, i, m_linalg) .or. &
            &   isVectorQtyMasked(noiseQty, row, i, m_linalg) ) &
            & .or. (ignoreNegative .and. noiseQty%values(row, i) < 0.0 ) &
            & .or. (ignoreZero .and. noiseQty%values(row, i) == 0.0 )
            if ( .not. skipMe ) then
              values(row) = ( &
              & (a*measQty%values(row, i) - b*modelQty%values(row, i)) &
              & / &
              & noiseQty%values(row, i) &
              &  ) ** 2
              N = N + 1
            end if
          end do
          if ( N > 0 ) then
            qty%values(1, i) = sum(values) / N
          else
            qty%values(1, i) = 0.
          end if
        end if
      end do
      call deallocate_test ( values, 'chi^2 unsummed', ModuleName)
    9 call trace_end ( 'FillUtils_1.ChiSqMMaf', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ChiSqMMaf

    ! ------------------------------------------------  ChiSqMMif  -----
    subroutine ChiSqMMif ( key, qty, measQty, modelQty, noiseQty, &
    & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier, &
    & firstInstance, lastInstance )
      ! A special fill of chi squared
      ! broken out according to Mifs
      ! Formal arguments
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) ::    modelQty
      type (VectorValue_T), intent(in) ::    measQty
      type (VectorValue_T), intent(in) ::    noiseQty
      logical, intent(in)           ::       dontMask    ! Use even Masked values
      logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
      logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
      real, dimension(:), intent(in) ::      multiplier
      logical, intent(in)           ::       IGNORETEMPLATE

      integer, intent(in), optional ::       firstInstance, lastInstance
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in the qty

      ! Local variables
      real(r8), dimension(:), pointer  ::    VALUES => NULL()
      integer ::                             UseFirstInstance, UseLastInstance, &
      &                                      NoOutputInstances
      integer ::                             C           ! Channel loop counter
      integer ::                             S           ! Surface loop counter
      integer ::                             I           ! Instances
      integer :: Me = -1                     ! String index for trace
      integer ::                             NOMIFS
      integer ::                             N           ! Num. of summed values
      integer ::                             QINDEX
      logical ::                             skipMe

      real                             ::    a, b

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ChiSqMMif', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
      if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
        a = 1.
        b = 1.
      else if ( multiplier(2) == UNDEFINED_VALUE ) then
        a = 0.
        if ( multiplier(1) /= 0.0 ) a = 1.0/multiplier(1)
        b = a
      else
        a = multiplier(1)
        b = multiplier(2)
      end if

      ! First check that things are OK.
      if ( ignoreTemplate ) then
        ! Anything goes
      else if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_chiSqMMif/), minorFrame=.true.) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Attempting to fill wrong quantity with chi^2 MMIFwise'  )
        if ( DEEBUG ) then
          call output('minor frame? ', advance = 'no')
          call output(qty%template%minorFrame, advance = 'no')
          call output('   quantity type ', advance = 'no')
          call output(qty%template%quantityType, advance = 'no')
          call output('   compared with ', advance = 'no')
          call output(l_chiSqMMif, advance = 'yes')
        end if
        go to 9
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Incompatibility among vector quantities filling chi^2 MMIFwise'  )
        go to 9
      else if ( any ( noiseQty%values == 0.0) .and. &
        & .not. (ignoreZero .or. .not. dontMask) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'A vanishing noise filling chi^2 MMIFwise'  )
        go to 9
      end if

      ! Work out what to do with the first and last Instance information

      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) go to 9

      call allocate_test(values, measQty%template%noChans, &
        & 'chi^2 unsummed', ModuleName)
      noMIFs = measQty%template%noSurfs
      do i=useFirstInstance, useLastInstance
        do s=1, noMIFs
          N = 0
          values = 0.0
          do c=1, measQty%template%noChans
            qIndex = c + (s-1)*measQty%template%noChans
            skipMe = &
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, qIndex, i, m_linalg) .or. &
            &   isVectorQtyMasked(modelQty, qIndex, i, m_linalg) .or. &
            &   isVectorQtyMasked(noiseQty, qIndex, i, m_linalg) ) &
            & .or. (ignoreNegative .and. noiseQty%values(qIndex, i) < 0.0 ) &
            & .or. (ignoreZero .and. noiseQty%values(qIndex, i) == 0.0 )
            if ( .not. skipMe ) then
              values(c) = ( &
              & (a*measQty%values(qIndex, i) - b*modelQty%values(qIndex, i)) &
              & / &
              & noiseQty%values(qIndex, i) &
              &  ) ** 2
              N = N + 1
            end if
          end do
          if ( N > 0 ) then
            qty%values(s, i) = sum(values) / N
          else
            qty%values(s, i) = 0.
          end if
        end do
      end do
      call deallocate_test(values, &
        & 'chi^2 unsummed', ModuleName)
    9 call trace_end ( 'FillUtils_1.ChiSqMMif', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ChiSqMMif

    ! -----------------------------------------------  ChiSqRatio  -----
    subroutine ChiSqRatio ( key, qty, normQty, minNormQty, flagQty, &
    & dontMask, ignoreTemplate, firstInstance, lastInstance )
      ! A special fill of the ratio
      !  chi squared Norm
      ! ----------------     [iter_n, *]
      ! chi squared Min Norm
      ! where iter_n is the final iteration number

      ! Note the following tricks:
      ! The number of surfaces is the maximum allowed number of iterations
      ! The actual number of iterations will be less than this

      ! Depending on UNIFORMCHISQRATIO
      ! TRUE    all values will equal the ratio of the last iteration
      ! FALSE   nth value will be ratio for nth iteration, up to last one
      !           and all zero thereafter
      ! After the last iteration, all "surfaces" above this are zero-filled

      ! The number of instances will be the number of chunks
      ! (yes, an unfortunate fact)
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(inout) :: normQty
      type (VectorValue_T), intent(inout) :: minNormQty
      type (VectorValue_T), intent(inout) :: flagQty
      logical, intent(in)           ::       dontMask    ! Use even Masked values
      logical, intent(in)           ::       IGNORETEMPLATE

      integer, intent(in), optional ::       firstInstance, lastInstance
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in qty

      ! Local variables
      integer ::                             UseFirstInstance, UseLastInstance, &
      &                                      NoOutputInstances
      integer ::                             I           ! Instances
      integer ::                             ITER        ! Instances
      integer :: Me = -1                     ! String index for trace
      ! integer ::                             NOCHANS
      integer ::                             QINDEX
      logical ::                             skipMe
      logical ::                             willBeNaN
      logical, parameter ::                  FakeData = .false.

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ChiSqRatio', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! First check that things are OK.
      if ( ignoreTemplate ) then
        ! Anything goes
      else if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_dnwt_chiSqRatio/) ) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Attempting to fill wrong quantity with chi^2 ratio'  )
        go to 9
      else if ( .not. ValidateVectorQuantity ( normqty, &
        & quantityType=(/l_dnwt_chiSqNorm/) ) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Attempting to fill using wrong norm quantity with chi^2 ratio'  )
        go to 9
      else if ( .not. ValidateVectorQuantity ( minnormqty, &
        & quantityType=(/l_dnwt_chiSqMinNorm/) ) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Attempting to fill using wrong min norm quantity with chi^2 ratio'  )
        go to 9
      else if ( .not. ValidateVectorQuantity ( flagqty, &
        & quantityType=(/l_dnwt_flag/) ) ) then
        call Announce_Error ( key, No_Error_code, &
        & 'Attempting to fill using wrong flag quantity with chi^2 ratio'  )
        go to 9
      end if

      ! Work out what to do with the first and last Instance information

      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) go to 9

      ! noChans = qty%template%noChans
      do i=useFirstInstance, useLastInstance
        if ( FakeData ) then
          ! Let's just fake up some data here
          flagQty%values(:,i) = 0._rv
          normQty%values(:,i) = 0._rv
          minNormQty%values(:,i) = 0._rv
          ! Say we converged at iteration number 5
          qIndex = 5
          flagQty%values(:qIndex,i) = -2._rv
          minNormQty%values(:qIndex,i) = -2._rv
          do iter = 1, qIndex
            minNormQty%values(iter, i) = 1.1
            normQty%values(iter, i) = 1.1 + 0.05*(qIndex+1-iter)
          end do
        end if
        willBeNaN = .false.
        ! Now find the iteration number
        qIndex = findLast( flagQty%values(:,i)            /= 0._rv  .and. &
          &                minNormQty%values(:, i) /= 0._rv )
        if ( qIndex == 0 .or. qIndex >= qty%template%noSurfs ) cycle
        willBeNaN = minNormQty%values(qIndex, i) == 0.
        skipMe = &
          & (.not. dontMask .and. ( &
          &   isVectorQtyMasked(normQty, qIndex, i, m_linalg) .or. &
          &   isVectorQtyMasked(minNormQty, qIndex, i, m_linalg) &
          & ) ) .or. &
          &   willBeNaN
        if ( skipMe ) then
          if ( willBeNaN ) qty%values(:,i) = 999._rv
        else if ( UNIFORMCHISQRATIO .or. &
          & size(qty%values) /= size(normQty%values) .or. &
          & size(qty%values) /= size(minNormQty%values) ) then
          qty%values(:,i) = &
            & normQty%values(qIndex, i) / minNormQty%values(qIndex, i)
        else
          qty%values(:,i) = 0._rv
          qty%values(1:qIndex,i) = &
            & normQty%values(1:qIndex, i) / minNormQty%values(1:qIndex, i)
        end if
      end do
    9 call trace_end ( 'FillUtils_1.ChiSqRatio', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ChiSqRatio

    ! ------------------------------------------- ColAbundance ---
    subroutine ColAbundance ( key, qty, bndPressQty, vmrQty, &
      & colmAbUnits, ignoreTemplate, &
      & firstInstance, lastInstance )
      ! A special fill according to W.G.Read's idl code
      ! Similar to his hand-written notes, but with a small correction

      ! Assumptions:
      ! (See above)
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) :: BNDPRESSQTY
      type (VectorValue_T), intent(in) :: VMRQTY
      integer, intent(in) :: colmAbUnits
      logical, intent(in)           :: IGNORETEMPLATE
      integer, intent(in), optional :: FIRSTINSTANCE
      integer, intent(in), optional :: LASTINSTANCE
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in the column data.

      ! Local parameters
      real(r8), parameter :: INVERMGPPMV = 0.789 ! in DU / (ppmv hPa)
      real(r8), parameter :: INVERMGDU = INVERMGPPMV*1.d6 ! in DU / (vmr hPa)
      real(r8), parameter :: INVERMGMOLCM2 = INVERMGDU*2.687d16 ! in mol / cm^2

      ! Local variables
      logical :: printMe
      integer :: SURFACE
      integer :: INSTANCE
      integer :: FIRSTSURFACEABOVE
      integer :: FIRSTSURFACEBELOW
      integer :: USEFIRSTINSTANCE
      integer :: USELASTINSTANCE
      integer :: Me = -1           ! String index for trace
      integer :: N
      integer :: NOOUTPUTINSTANCES
      real (r8) :: THISBNDPRESS
      real (r8) :: zeta            ! -log(THISBNDPRESS)
      real (r8) :: zetaTmp
      real (r8) :: COLUMNSUM
      real (r8) :: TRAPEZOIDSUM
      real (r8) :: DELTAZETA       ! Zetai[s+1] - Zetai[s]
      real (r8) :: INVERMG
      real (r8)                        :: Zetaa
      real (r8), dimension(vmrQty%template%noSurfs) :: Zetab
      real (r8), dimension(vmrQty%template%noSurfs) :: Zetac
      real (r8)                                     :: Zetad
      real (r8), dimension(vmrQty%template%noSurfs) :: Zetai
      real (r8)               :: Pa         ! p[i] in hPa
      real (r8), dimension(vmrQty%template%noSurfs) :: Pb         ! p[i] in hPa
      real (r8), dimension(vmrQty%template%noSurfs) :: Pc         ! p[i] in hPa
      real (r8)               :: Pd         ! p[i] in hPa
      real (r8), dimension(vmrQty%template%noSurfs) :: Pi         ! p[i] in hPa

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ColAbundance', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! First check that things are OK.
      if ( ignoreTemplate ) then
        ! Anything goes
      else if ( (qty%template%quantityType /= l_columnAbundance) .or. &
        &  (bndPressQty%template%quantityType /= l_boundaryPressure) .or. &
        &  (vmrQty%template%quantityType /= l_vmr) ) then
        call Announce_Error ( key, No_Error_code, &
          & 'Wrong quantity type found while filling column abundance'  )
        go to 9
      else if ( qty%template%molecule /= vmrQty%template%molecule ) then
        call Announce_Error ( key, No_Error_code, &
          & 'Attempt to fill column abundance with different molecule'  )
        go to 9
      else if ( .not. ( DoHgridsMatch( qty, vmrQty ) .and. &
        & DoHgridsMatch( qty, bndPressQty ) ) ) then
        call Announce_Error ( key, No_Error_code, &
          & 'Attempt to fill column abundance with different HGrids'  )
        go to 9
      else if ( .not. any(vmrQty%template%verticalCoordinate == &
        & (/l_zeta/)) ) then
        call Announce_Error ( key, No_Error_code, &
          & 'Fill column abundance, but vmr not on zeta surfs.'  )
        go to 9
      else if ( vmrQty%template%noSurfs < 2 ) then
        call Announce_Error ( key, No_Error_code, &
          & 'Fill column abundance, but too few vmr surfaces'  )
        go to 9
      end if
      select case (colmAbUnits)
      case (l_DobsonUnits)
        INVERMG = INVERMGDU
      case (l_DU)
        INVERMG = INVERMGDU
      case (l_molcm2)
        INVERMG = INVERMGMOLCM2
      case default
        call Announce_Error ( key, No_Error_code, &
          & 'Fill column abundance, but wrong units.'  )
      end select
      ! Work out what to do with the first and last Instance information
      useFirstInstance = 1
      useLastInstance = qty%template%noInstances
      if ( present ( firstInstance ) ) useFirstInstance = firstInstance
      if ( present ( lastInstance ) ) useLastInstance = lastInstance
      noOutputInstances = useLastInstance-useFirstInstance+1

      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) go to 9

      Zetai = vmrQty%template%surfs(:,1)
      pi = 10.0 ** ( -Zetai  )
      N = vmrQty%template%noSurfs
      do instance = useFirstInstance, useLastInstance
        printMe = ( instance == useFirstInstance) .and. &
         & (switchDetail(switches, 'column') > -1 )
        if ( printMe ) print *, 'switches: ', trim(switches)
        if ( printMe ) &
          & print *, 'switchDetail(switches, column) ', switchDetail(switches, 'column')
        ! Find 1st surface at or above tropopause
        ! (i.e., at a pressure equal to or less than boundaryPressure)
        ! This next check should be unnecessary--the HGrids were already matched
        if ( instance > size(bndPressQty%values, 2) ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Cant fill column--instance outside b.pres. range' )
          go to 9
        end if
        thisBndPress = bndPressQty%values(1,instance)
        ! In case where WMO algorithm failed, use bottom of basis
        if ( thisBndPress <= 0.0 ) &
          & thisBndPress = 10.0 ** ( - vmrQty%template%surfs(1,1) )
        if ( thisBndPress <= 0._r8 ) then
          call Announce_Error ( key, No_Error_code, &
          & 'Fill column abundance, illegal bound. pr. at this instance' )
        end if
        zeta = -log10 ( thisBndPress )
        Zetaa = max(Zetai(N), zeta)
        do surface=1, N
          Zetab(surface) = Zetai(min(surface+1,N))
        end do
        do surface=1, N
          Zetab(surface) = min(max(zeta, Zetai(surface)), Zetab(surface))
          zetaTmp = zeta
          if ( surface > 1 ) zetaTmp = max(zeta, Zetai(surface-1))
          Zetac(surface) = min(zetaTmp, Zetai(surface))
        end do
        Zetad = min(Zetai(1), zeta)
        Pa = 10. ** (-Zetaa)
        Pb = 10. ** (-Zetab)
        Pc = 10. ** (-Zetac)
        Pd = 10. ** (-Zetad)
        if ( printMe ) then
          call output ( 'zeta: ', advance='no')
          call output ( zeta, advance='yes')
          call output ( 'zetaA: ', advance='no')
          call output ( zetaA, advance='yes')
          call output ( 'zetaD: ', advance='no')
          call output ( zetaD, advance='yes')
          call output ( 'PA: ', advance='no')
          call output ( PA, advance='yes')
          call output ( 'PD: ', advance='no')
          call output ( PD, advance='yes')
          call output ( 'zetaI   zetaB     zetaC      Pi   Pb   Pc', advance='yes')
          do surface=1, N
            call output( (/ zetai(surface), zetab(surface), zetac(surface), &
             & Pi(surface), Pb(surface), Pc(surface)/) , advance='yes')
          end do
        end if
        ! Find 1st surface immediately above tropopause
        firstSurfaceAbove = FindFirst (Pi < thisBndPress)
        if ( firstSurfaceAbove < 1 ) then
          call output ( 'tropopause: ', advance='no')
          call output ( thisBndPress, advance='yes')
          call output ( 'p0 ', advance='no')
          call output ( Pi(1), advance='yes')
          call output ( 'pTop ', advance='no')
          call output ( Pi(N), advance='yes')
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Filling column, but tropopause outside pres. surfaces' )
          firstSurfaceBelow = 1
        else if ( firstSurfaceAbove == 1 ) then
          ! Nothing special
          firstSurfaceBelow = 1
        else if ( firstSurfaceAbove > N ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Cant column, tropopause above top surface' )
          go to 9
        else  ! Nothing special
          firstSurfaceBelow = firstSurfaceAbove - 1
        end if
        if ( printMe ) then
          print *, 'thisBndPress: ', thisBndPress
          print *, 'firstSurfaceAbove: ', firstSurfaceAbove
          print *, 'firstSurfaceBelow: ', firstSurfaceBelow
        end if
        ! Do summation
        columnSum = vmrQty%values(N, instance) * Pa  ! Initialize sum
        if ( printMe ) then
          print *, 'columnSum: ', columnSum
          trapezoidSum = 0.
          do surface=firstSurfaceAbove, N-1
            trapezoidsum = trapezoidsum + 0.5 * ( &
              & vmrQty%values(surface, instance) + vmrQty%values(surface+1, instance) &
              & ) * ( Pi(surface+1)-Pi(surface))
          end do
        end if
        ! Loop over surfaces from 1 to uppermost-1
        do surface = 1, N-1
          deltaZeta = Zetai(surface+1) - Zetai(surface)
          if ( deltaZeta == 0._r8 ) cycle
          columnSum = columnSum + &
            & vmrQty%values(surface, instance) / deltaZeta * &
            & ( &
            & Pb(surface)*(Zetai(surface+1)-Zetab(surface)) &
            & + &
            & (Pi(surface+1) - Pb(surface))/ln10 &
            & )
        if ( printMe ) print *, 'columnSum: ', columnSum, surface
        end do
        ! Loop over surfaces from 2 to uppermost
        do surface = 2, N
          deltaZeta = Zetai(surface) - Zetai(surface-1)
          if ( deltaZeta == 0._r8 ) cycle
          columnSum = columnSum + &
            & vmrQty%values(surface, instance) / deltaZeta * &
            & ( &
            & Pc(surface)*(Zetac(surface)-Zetai(surface)) &
            & + &
            & (Pc(surface) - Pi(surface))*(1./ln10 + deltaZeta) &
            & )
          ! columnSum = columnSum + &
          ! & vmrQty%values(surface, instance) / deltaZeta * &
          ! & ( &
          ! & Pc(surface)*(Zetac(surface)-Zetai(surface)) &
          ! & + &
          ! & (Pc(surface) - Pi(surface))/ln10 &
          ! & )
        if ( printMe ) print *, 'columnSum: ', columnSum, surface
        end do
        columnSum = columnSum + vmrQty%values(1, instance) * (Pd - Pi(1))
        if ( printMe ) print *, 'columnSum: ', columnSum
        if ( printMe ) print *, 'trapezoid: ', -trapezoidSum
        qty%values ( 1, instance ) = InverMg * columnSum
      end do
    9 call trace_end ( 'FillUtils_1.ColAbundance', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ColAbundance

    ! -------------------------------------  ConvergenceFromChisq  -----
    subroutine ConvergenceFromChisq ( key, quantity, sourceQuantity, &
      & scale, ignoreTemplate )
      integer, intent(in) :: KEY        ! Tree node
      type ( VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type ( VectorValue_T), intent(in) :: SOURCEQUANTITY ! dnwt_ChisqRatio quantity on which it's based
      real(r8), intent(in) :: SCALE     ! A scale factor
      logical, intent(in)           ::       IGNORETEMPLATE
      ! Local variables
      integer :: Me = -1                ! String index for trace
      integer ::                             QINDEX
      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ConvergenceFromChisq', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! Do some sanity checking
      ! call Dump( sourceQuantity%values, 'chi^2' )
      if ( .not. ignoreTemplate ) then
        if ( quantity%template%quantityType /= l_quality ) call Announce_Error ( key, no_error_code, &
          & 'Convergence quantity must be quality' )
        if ( sourceQuantity%template%quantityType /= l_dnwt_chisqRatio ) call Announce_Error ( &
          & key, no_error_code, 'sourceQuantity must be of type chisqRatio' )
      end if
      if ( UNIFORMCHISQRATIO ) then
        if ( isFinite( sourceQuantity%values(1,1) ) ) &
          & quantity%values(1,:) = scale * sourceQuantity%values(1,1)
      else
        qIndex = findLast( sourceQuantity%values(:,1) /= 0._rv .and. &
          & isFinite(sourceQuantity%values(:,1)) )
        if ( qIndex > 0 ) &
          & quantity%values(1,:) = scale * sourceQuantity%values(qIndex,1)
      end if
      ! call Output ( any( isTooBig(quantity%values(1,:))), advance='yes' )
      if ( REPLACEINFS .and. any( isTooBig(quantity%values(1,:))) ) &
        & quantity%values(1,:) = UNDEFINED_VALUE
      ! call Dump( Quantity%values, 'convergence' )
      call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )
    contains
      elemental logical function isTooBig ( x )
        real(rv), intent(in) :: x
        real(rv), parameter:: TOOBIG = 100000000000._rv
        isTooBig = isInfinite(x) .or. abs(x) > TOOBIG
      end function
    end subroutine ConvergenceFromChisq

    !--------------------------------------------  FillCovariance  -----
    subroutine FillCovariance ( covariance, vectors, diagonal, &
      & lengthScale, fraction, invert, ignoreTemplate )
      ! This routine fills a covariance matrix from a given set of vectors
      type (Matrix_SPD_T), intent(inout) :: COVARIANCE ! The matrix to fill
      type (Vector_T), dimension(:), intent(in), target :: VECTORS ! The vector database
      integer, intent(in) :: DIAGONAL     ! Index of vector describing diagonal
      integer, intent(in) :: LENGTHSCALE  ! Index of vector describing length scale
      integer, intent(in) :: FRACTION     ! Index of vector describing fraction
      logical, intent(in) :: INVERT       ! We actually want the inverse
      logical, intent(in) :: IGNORETEMPLATE

      ! Local parameters
      real(r8), parameter :: DECADE = 16000.0 ! Number of meters per decade.

      ! Local variables
      type (VectorValue_T), pointer :: d  ! Diagonal
      type (VectorValue_T), pointer :: l  ! Length
      type (VectorValue_T), pointer :: f  ! Fraction
      type (QuantityTemplate_T), pointer :: qt ! One quantity template
      type (Vector_T) :: DMaskED ! Masked diagonal
      type (Vector_T) :: LMaskED ! Masked length scale
      integer :: B                        ! Block index
      integer :: I                        ! Instance index
      integer :: J                        ! Loop index
      integer :: K                        ! Loop index
      integer :: Me = -1                  ! String index for trace
      integer :: N                        ! Size of matrix block
      integer :: Q                        ! Quantity index
      type (MatrixElement_t), pointer :: M ! The matrix being filled
      real (r8), dimension(:), pointer :: SURFS ! The vertical coordinate
      real (r8) :: distance               ! Distance between two points
      real (r8) :: thisLength             ! Geometric mean length scale
      real (r8) :: meanDiag               ! Geometric mean diagonal value
      real (r8) :: thisFraction           ! Geometric mean diagonal value
      logical, dimension(:), pointer :: condition ! Condition
      logical :: ANYOFFDIAG             ! Flag to indicate presence of off diagonal elements

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FillCovariance', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! Apply Mask to diagonal
      nullify ( condition )
      call CopyVector ( DMasked, vectors(diagonal), clone=.true., &
        & vectorNameText='_DMasked' )
      call ClearUnderMask ( DMasked )

      if ( lengthScale == 0 ) then
        call updateDiagonal ( covariance, vectors(diagonal), square=.true.,&
          & invert=invert, forgiveZeros=.true. )
      else
        ! Do a more complex fill, either we're doing non-diagonal, or there might
        ! be zeros to 'invert'

        ! Setup some stuff
        if ( lengthScale /= 0 ) then
          call CopyVector ( LMasked, vectors(lengthScale), clone=.true., &
            & vectorNameText='_LMasked' )
          call ClearUnderMask ( LMasked )
        end if

        ! Check the validity of the supplied vectors
        if ( .not. ignoretemplate ) then
          if ( covariance%m%row%vec%template%name /= &
            & vectors(diagonal)%template%name ) call MLSMessage ( MLSMSG_Error, &
            & ModuleName, "Diagonal and covariance not compatible in fillCovariance" )
          if ( covariance%m%row%vec%template%name /= &
            & dMasked%template%name ) call MLSMessage ( MLSMSG_Error, &
            & ModuleName, "Copied diagonal and covariance not compatible in fillCovariance" )
          if ( lengthScale /= 0 ) then    ! Check length if supplied
            if ( covariance%m%row%vec%template%name /= &
              & lMasked%template%name ) call MLSMessage ( MLSMSG_Error, &
              & ModuleName, "lengthScale and covariance not compatible in fillCovariance" )
            if ( lMasked%globalUnit /= phyq_length ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "length vector does not have dimensions of length" )
          else
            thisLength = 0.0
          end if
          if ( fraction /= 0 ) then       ! Check fraction if supplied
            if ( covariance%m%row%vec%template%name /= &
              & vectors(fraction)%template%name ) call MLSMessage ( MLSMSG_Error, &
              & ModuleName, "fraction and covariance not compatible in fillCovariance" )
            if ( vectors(fraction)%globalUnit /= phyq_dimensionless ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "fraction vector is not dimensionless" )
          else
            thisFraction = 1.0
          end if
        end if

        ! Now loop over the quantities
        do q = 1, covariance%m%col%vec%template%noQuantities

          ! Setup pointers etc.
          d => dMasked%quantities(q)
          qt => d%template
          if ( lengthScale /= 0 ) l => lMasked%quantities(q)
          if ( fraction /=0 ) f => vectors(fraction)%quantities(q)
          n = qt%instanceLen
          if ( qt%coherent ) surfs => qt%surfs(:,1)
          if ( .not. qt%regular ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Unable to handle irregular quantity in Covariance" )

          ! Loop over the instances
          do i = 1, qt%noInstances
            b = FindBlock ( covariance%m%col, q, i )
            m => covariance%m%block(b,b)
            call createBlock ( m, n, n, m_full, forWhom=moduleName )
            anyOffDiag = .false.
            if ( .not. qt%coherent ) surfs => qt%surfs(:,i)

            ! Clear the working matrix and load the diagonal
            m%values = 0.0_rm
            do j = 1, n
              m%values(j,j) = d%values(j,i) ** 2.0
            end do

            ! Now if appropriate add off diagonal terms.
            if ( any( qt%verticalCoordinate == (/ l_height, l_pressure, l_zeta /) ) ) then
              ! Loop over off diagonal terms
              do j = 1, n
                do k = 1, j-1
                  meanDiag = sqrt ( m%values(j,j) * m%values(k,k) )
                  if ( lengthScale /= 0 ) &
                    & thisLength = sqrt ( l%values(j,i) * l%values(k,i) )
                  if ( fraction /= 0 ) thisFraction = f%values(j,i)
                  select case (qt%verticalCoordinate)
                  case ( l_height )
                    distance = abs ( surfs ( (j-1)/qt%noChans + 1 ) - &
                      & surfs ( (k-1)/qt%noChans + 1) )
                  case ( l_zeta )
                    distance = abs ( surfs ( (j-1)/qt%noChans + 1 ) - &
                      & surfs ( (k-1)/qt%noChans + 1 ) ) * decade
                  case ( l_pressure )
                    distance = abs ( -log10 ( surfs( (j-1)/qt%noChans + 1) ) + &
                      &               log10 ( surfs( (k-1)/qt%noChans + 1) ) ) / decade
                  end select
                  if ( thisLength > 0.0 .and. thisFraction > 0.0 ) then
                    m%values(j,k) = meanDiag*thisFraction*exp(-distance/thisLength)
                    anyOffDiag = .true.
                  end if
                end do                    ! Loop over k (in M)
              end do                      ! Loop over j (in M)
            end if                        ! An appropriate vertical coordinate

            ! Now we may need to invert this, if so we need to be clever.
            if ( invert ) then
              call Allocate_test ( condition, n, 'condition', ModuleName )
              condition = d%values(:,i) <= 0.0_rv
              do j = 1, n
                if ( condition(j) ) m%values(j,j) = 1.0_rm
              end do
              if ( anyOffDiag ) then
                call MatrixInversion(M%values, upper=.true.)
              else
                do j = 1, n
                  m%values(j,j) = 1.0 / m%values(j,j)
                end do
              end if
              do j = 1, n
                if ( condition(j) ) m%values(j,j) = 0.0_rm
              end do
              call Deallocate_test ( condition, 'condition', ModuleName )
            end if

            call Sparsify ( M )
          end do                          ! Loop over instances
        end do                            ! Loop over quantities
      end if                              ! A non diagonal fill

      call DestroyVectorInfo ( DMasked )
      call DestroyVectorInfo ( LMasked )
      call trace_end ( 'FillUtils_1.FillCovariance', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine FillCovariance

    !----------------------------------------  DerivativeOfSource  -----
    ! Compute derivative of source quantity w.r.t. dim listed
    subroutine DerivativeOfSource ( DERIVATIVE, SOURCE, XQUANTITY, &
      & DIMLIST, IGNORETEMPLATE )
      use Manipulationutils, only: Manipulate

      type (VectorValue_T), pointer       :: DERIVATIVE
      type (VectorValue_T), pointer       :: SOURCE
      type (VectorValue_T), pointer       :: XQUANTITY
      character(len=*), intent(in)        :: DIMLIST        ! 's', 'c', or 'i' in manipulation's shi
      logical, intent(in)                 :: IGNORETEMPLATE

      ! Local variables
      ! integer                      :: NOKEY
      type(vectorValue_T), pointer :: LOWER         ! For storing (dy/dx)_l
      type(vectorValue_T), target  :: LOWERQUANTITY ! For storing (dy/dx)_l
      type(vectorValue_T), pointer :: UPPER         ! For storing (dy/dx)_u
      type(vectorValue_T), target  :: UPPERQUANTITY ! For storing (dy/dx)_u
      ! Executable
      nullify( upper, lower )
      ! nokey = 0
      ! First: check that derivative and source are compatible
      if ( .not. ignoretemplate ) then
        if ( source%template%name /= &
          & derivative%template%name ) call MLSMessage ( MLSMSG_Error, &
          & ModuleName, "Derivative and source not compatible in fill derivative" )
      end if
      call CloneVectorQuantity ( upperQuantity, source )
      call CloneVectorQuantity ( lowerQuantity, source )
      lower => lowerQuantity
      upper => upperQuantity
      ! Second: compute the "upper derivative"
      ! (dy/dx)_u = ( y[x+dx] - y[x] ) / dx
      call Manipulate ( upper, source, xQuantity, 0._rv, &
        & "(shift(a) - a)/(shift(b) - b)", &
        & .false., dimList )
      ! Third: compute the "lower derivative"
      ! (dy/dx)_l = ( y[x] - y[x-dx] ) / dx
      call Manipulate ( lower, source, xQuantity, 0._rv, &
        & "(a - slip(a))/(b - slip(b))", &
        & .false., dimList )
      ! Last: average the two to arrive at the central difference
      ! (dy/dx) = (1/2) * ( (dy/dx)_u + (dy/dx)_l )
      call Manipulate ( derivative, upper, lower, 0.5_rv, &
        & "c*(a + b)", &
        & .false., dimList )
      ! Housekeeping
      call destroyVectorQuantityValue ( upperQuantity, &
        & destroyMask=.true., destroyTemplate=.false. )
      call destroyVectorQuantityValue ( lowerQuantity, &
        & destroyMask=.true., destroyTemplate=.false. )
    end subroutine DerivativeOfSource

    ! ------------------------------------- FoldedRadiance ---
    subroutine FoldedRadiance ( radiance, lsb, usb, &
      & lsbFraction, usbFraction, key )
      type (VectorValue_T), intent(inout) :: RADIANCE
      type (VectorValue_T), pointer :: USB
      type (VectorValue_T), pointer :: LSB
      type (VectorValue_T), pointer :: USBFRACTION
      type (VectorValue_T), pointer :: LSBFRACTION
      integer, intent(in) :: KEY

      ! Local variables
      integer :: C                        ! Channel loop inductor
      integer :: I                        ! Array index
      integer :: Me = -1                  ! String index for trace
      integer :: MIF                      ! Minor frame loop inductor

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FoldedRadiance', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! First some sanity checks
      if ( .not. ValidateVectorQuantity ( radiance, quantityType=(/l_radiance/), &
        & sideband=(/0/), minorFrame=.true. )) &
        & call Announce_Error ( key, no_error_code, 'Inappropriate radiance quantity to fill' )
      if ( ( associated ( lsb ) .neqv. associated ( lsbFraction ) ) .or. &
        &  ( associated ( usb ) .neqv. associated ( usbFraction ) ) ) then
        call Announce_Error ( key, no_error_code, 'Must supply sidebands and fractions together' )
        go to 9
      end if
      if ( associated ( lsb ) ) then
        if ( .not. ValidateVectorQuantity ( lsb, quantityType=(/l_radiance/), &
          & sideband=(/-1/), signal=(/radiance%template%signal/), minorFrame=.true. )) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate lsb radiance quantity for fill' )
        if ( .not. ValidateVectorQuantity ( lsbFraction, &
          & quantityType=(/l_limbSidebandFraction/), &
          & signal=(/radiance%template%signal/), sideband=(/-1/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate lsbFraction quantity for fill' )
      end if
      if ( associated ( usb ) ) then
        if ( .not. ValidateVectorQuantity ( usb, quantityType=(/l_radiance/), &
          & sideband=(/1/), signal=(/radiance%template%signal/), minorFrame=.true. )) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate usb radiance quantity for fill' )
        if ( .not. ValidateVectorQuantity ( usbFraction, &
          & quantityType=(/l_limbSidebandFraction/), &
          & signal=(/radiance%template%signal/), sideband=(/1/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate usbFraction quantity for fill' )
      end if

      if ( .not. associated ( lsb ) .and. .not. associated ( usb ) ) &
        & call Announce_Error ( key, no_error_code, 'Must supply one or both of lsb/usb' )

      ! Now do the work
      ! Note that this is a very inefficient loop, but I don't really care as it's
      ! Never used in routine processing.
      i = 1                               ! Use i as a composit mif,channel index
      do mif = 1, radiance%template%noSurfs
        do c = 1, radiance%template%noChans
          radiance%values(i,:) = 0.0
          if ( associated ( lsb ) ) radiance%values(i,:) = radiance%values(i,:) + &
            & lsbFraction%values(c,1) * lsb%values(i,:)
          if ( associated ( usb ) ) radiance%values(i,:) = radiance%values(i,:) + &
            & usbFraction%values(c,1) * usb%values(i,:)
          i = i + 1
        end do
      end do
    9 call trace_end ( 'FillUtils_1.FoldedRadiance', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine FoldedRadiance

    ! --------------------------------------------- FromAnother ---
    ! The most basic of Fill methods:
    ! At some point we must try to modify most of the other Fill methods so
    ! that they do their unique stuff and then call this method
    ! That makes maximum reuse, a best practice, and confines future changes to
    ! just this subroutine
    ! Note that this does *NOT* copy the Mask (at least for the moment)
    ! It is assumed that the original one (e.g. inherited from transfer)
    ! is still relevant.
    ! See Subset command

    ! Next:
    ! Check that vGrids match
    ! If they don't, and /interpolate not set, then raise an exception
    ! (no more silent inerpolations)
    subroutine FromAnother ( quantity, sourceQuantity, ptan, &
      & key, ignoreTemplate, spreadflag, interpolate, force, sourceMask )
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), pointer :: SOURCEQUANTITY
      type (VectorValue_T), pointer :: PTAN
      integer, intent(in) :: KEY        ! Tree node
      logical, intent(in) :: IGNORETEMPLATE ! If set throw caution to the wind
      logical, intent(in) :: SPREADFLAG ! If set spread across instances
      logical, intent(in) :: INTERPOLATE ! If set spread across summed dimension
      logical, intent(in) :: FORCE ! Copy as much as will fit
      logical, intent(in) :: sourceMask ! Obey source masking bits
      ! Local parameters
      integer :: inst
      integer :: instanceLen
      integer :: noInstances
      integer :: surf
      logical :: verbose
      ! Executable
      verbose = ( switchDetail(switches, 'fill') > 0 ) ! -Sfill1
      noInstances = Quantity%template%noInstances
      if ( associated ( ptan ) .and. interpolate ) then
        call FromInterpolatedQty ( quantity, sourceQuantity, &
          & key, ignoreTemplate, ptan )
      else if ( (quantity%template%name /= sourceQuantity%template%name) &
        & .and. .not. sourceMask ) then
        if ( .not. interpolate .and. .not. ignoreTemplate ) then
          call Announce_Error ( key, No_Error_Code, &
            & 'Quantity and sourceQuantity do not have the same template' )
        else
          call FromInterpolatedQty ( quantity, sourceQuantity, &
            & key, ignoreTemplate )
        end if
      else if ( spreadFlag ) then
        ! Copy first instance into all (assuming instance lengths are the same)
        noInstances = Quantity%template%noInstances
        do inst = 1, noInstances
          ! If we have a Mask and we're going to obey it then do so
          if ( associated(quantity%Mask) ) then
            where ( iand ( ichar(quantity%Mask(:,inst)), m_Fill ) == 0 )
              quantity%values(:,inst) = sourceQuantity%values(:,1)
            end where
          else ! Otherwise, just blindly copy
            quantity%values(:,inst) = sourceQuantity%values(:,1)
          end if
        end do
      else if ( force .and. &
        & sourceQuantity%template%instanceLen == Quantity%template%instanceLen ) then
        ! Copy as many instances as we can
        noInstances = min( sourceQuantity%template%noInstances, Quantity%template%noInstances )
        do inst = 1, noInstances
          ! If we have a Mask and we're going to obey it then do so
          if ( associated(quantity%Mask) ) then
            where ( iand ( ichar(quantity%Mask(:,inst)), m_Fill ) == 0 )
              quantity%values(:,inst) = sourceQuantity%values(:,inst)
            end where
          else ! Otherwise, just blindly copy
            quantity%values(:,inst) = sourceQuantity%values(:,inst)
          end if
        end do
      else if ( force .and. &
        & sourceQuantity%template%noInstances == Quantity%template%noInstances ) then
        ! Copy as many instances as we can
        instanceLen = min( sourceQuantity%template%instanceLen, Quantity%template%instanceLen )
        do surf = 1, instanceLen
          ! If we have a Mask and we're going to obey it then do so
          if ( associated(quantity%Mask) ) then
            where ( iand ( ichar(quantity%Mask(surf,:)), m_Fill ) == 0 )
              quantity%values(surf,:) = sourceQuantity%values(surf,:)
            end where
          else ! Otherwise, just blindly copy
            quantity%values(surf,:) = sourceQuantity%values(surf,:)
          end if
        end do
      elseif ( sourceMask .and. associated(sourceQuantity%Mask) ) then
        ! Instead of obeying quantity's mask bits, use mask bits from source
        ! Either value fo value copy, or, if the sizes don't match
        ! copy the first unmasked value from source into element 1 of quantity
        ! call output ( 'using mask from source quantity', advance='yes' )
        ! call dumpQuantityMask( sourceQuantity )
        ! call outputNamedValue( 'shape(source)', shape(sourceQuantity%values) )
        ! call outputNamedValue( 'shape(qty)', shape(quantity%values) )
        if ( size(quantity%values) == size(sourceQuantity%values) ) then
          where ( iand ( ichar(sourceQuantity%Mask(:,:)), m_Fill ) == 0 )
            quantity%values(:,:) = sourceQuantity%values(:,:)
          end where
        elseif ( size(quantity%values(1,:)) == size(sourceQuantity%values(1,:)) ) then
          do inst = 1, noInstances
            surf = FindFirst ( iand ( ichar(sourceQuantity%Mask(:,inst)), m_Fill ) == 0 )
            ! call outputNamedValue ( 'surf', surf )
            if ( surf > 0 ) quantity%values(1,inst) = sourceQuantity%values(surf,inst)
            ! if ( surf > 0 ) call outputNamedValue ( 'sQ(surf)', sourceQuantity%values(surf,inst) ) 
          enddo
        else
          surf = FindFirst ( iand ( ichar(sourceQuantity%Mask(:,1)), m_Fill ) == 0 )
          ! call outputNamedValue ( 'surf', surf )
          if ( surf > 0 ) quantity%values(1,1) = sourceQuantity%values(surf,1)
          ! if ( surf > 0 ) call outputNamedValue ( 'sQ(surf)', sourceQuantity%values(surf,1) ) 
        endif
      else
        ! Just a straight copy
        ! If we have a Mask and we're going to obey it then do so
        if ( associated(quantity%Mask) ) then
          where ( iand ( ichar(quantity%Mask(:,:)), m_Fill ) == 0 )
            quantity%values(:,:) = sourceQuantity%values(:,:)
          end where
        else ! Otherwise, just blindly copy
          quantity%values = sourceQuantity%values
        end if
      end if
      if ( associated( sourceQuantity%BinNumber ) ) then
        allocate( quantity%BinNumber(sourceQuantity%template%NoInstances) )
        quantity%BinNumber = sourceQuantity%BinNumber
      elseif ( verbose ) then
        call output( 'source%BinNumber not allocated', advance='yes' )
      endif
      if ( associated( sourceQuantity%MAF ) ) then
        allocate( quantity%MAF(sourceQuantity%template%NoInstances) )
        quantity%MAF = sourceQuantity%MAF
      elseif ( verbose ) then
        call output( 'source%MAF not allocated', advance='yes' )
      endif

    end subroutine FromAnother

    ! ------------------------------------- FromSplitSideband ----
    subroutine FromSplitSideband ( quantity, sourceQuantity, &
      & lsbFraction, usbFraction, spreadFlag, usb, channel, key )

      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY
      type (VectorValue_T), intent(in) :: LSBFRACTION
      type (VectorValue_T), intent(in) :: USBFRACTION
      type (VectorValue_T), pointer :: USB
      logical, intent(in) :: SPREADFLAG   ! One instance given, spread to all
      integer, intent(in) :: CHANNEL
      integer, intent(in) :: KEY
      ! Local variables
      integer :: MYCHANNEL              ! Possibly offset channel
      integer :: i, mif, maf
      integer :: Me = -1                ! String index for trace
      type (Signal_T) :: signalIn, signalOut, signalRef
      real(r8), dimension(:), pointer :: freq1, freqL1, freqU1
      real(r8), dimension(:), pointer :: freq2, freqL2, freqU2
      real(r8), dimension(:), pointer :: freq, freqL, freqU
      real(r8) :: ratio1, ratio2    ! signal sideband fractions
      real(r8) :: scaledRad   ! scaled radiance according to the f^4 law

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FromSplitSideband', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      nullify(freq, freqL, freqU, freq1, freqL1, freqU1, freq2, freqL2, freqU2)

      ! check for qualified quantity
      if ( .not. ValidateVectorQuantity ( quantity, quantityType=(/l_cloudInducedRadiance/), &
        & sideband=(/-1,1/), minorFrame=.true. )) &
        & call Announce_Error ( key, no_error_code, 'Quantity must be cloud-induced-radiances to fill' )
      if ( .not. associated(quantity%Mask)) &
        & call Announce_Error ( key, no_error_code, 'Quantity must be a subset to fill' )

      signalIn = GetSignal ( sourceQuantity%template%signal )     ! sideband info gets lost
      signalOut = GetSignal ( Quantity%template%signal )          ! sideband info gets lost

      myChannel = channel

      call allocate_test ( freq1, size(signalIn%frequencies), 'frequencies', ModuleName )
      call allocate_test ( freqL1, size(signalIn%frequencies), 'LSBfrequencies', ModuleName )
      call allocate_test ( freqU1, size(signalIn%frequencies), 'USBfrequencies', ModuleName )
      call allocate_test ( freq2, size(signalOut%frequencies), 'frequencies', ModuleName )
      call allocate_test ( freqL2, size(signalOut%frequencies), 'LSBfrequencies', ModuleName )
      call allocate_test ( freqU2, size(signalOut%frequencies), 'USBfrequencies', ModuleName )

      ! find input signal frequencies
      freqL1 = signalIn%lo - signalIn%centerFrequency - &
        & signalIn%direction*signalIn%frequencies    ! lower sideband freq
      freqU1 = signalIn%lo + signalIn%centerFrequency + &
        & signalIn%direction*signalIn%frequencies     ! upper sideband freq
      if ( sourceQuantity%template%sideband == -1) freq1 = freqL1
      if ( sourceQuantity%template%sideband == 1) freq1 = freqU1
      ! find output signal frequencies
      freqL2 = signalOut%lo - signalOut%centerFrequency - &
        & signalOut%direction*signalOut%frequencies      ! lower sideband freq
      freqU2 = signalOut%lo + signalOut%centerFrequency + &
        & signalOut%direction*signalOut%frequencies    ! upper sideband freq
      if ( quantity%template%sideband == -1) freq2 = freqL2
      if ( quantity%template%sideband == 1) freq2 = freqU2

      quantity%values=0._r8
      if ( spreadFlag ) then
        ! spread a cloudy radiance to other bands according to the f^4 law
        ! The source cloudy radiance must be from a single sideband signal
        if ( .not. ValidateVectorQuantity ( sourceQuantity, &
          & quantityType=(/l_cloudInducedRadiance/), &
          & sideband=(/-1,1/), minorFrame=.true. )) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate sourceQuantity radiance for fill' )
        do i=1,size(signalOut%frequencies)
          do maf=1, quantity%template%noInstances
            do mif=1, quantity%template%noSurfs
              scaledRad = sourceQuantity%values ( MyChannel + &
                & (mif-1) * size(signalIn%frequencies), maf) * &
                & freq2(i)**4/freq1(MyChannel)**4
              if ( iand ( ichar ( Quantity%Mask(i+(mif-1) * &
                & size(signalOut%frequencies), maf)), m_cloud) /= 0 ) &
                & quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = scaledRad
            end do
          end do
        end do

      else
        ! split two sideband radiances according to the f^4 law
        ! The source cloudy radiance must be from the same signal of double sideband

        if ( .not. ValidateVectorQuantity ( sourceQuantity, &
          & quantityType=(/l_cloudInducedRadiance/), &
          & sideband=(/0/), signal=(/quantity%template%signal/), minorFrame=.true. )) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate sourceQuantity radiance for fill' )
        if ( .not. ValidateVectorQuantity ( lsbFraction, &
          & quantityType=(/l_limbSidebandFraction/), &
          & signal=(/quantity%template%signal/), sideband=(/-1/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate lsbFraction quantity for fill' )
        if ( .not. ValidateVectorQuantity ( usbFraction, &
          & quantityType=(/l_limbSidebandFraction/), &
          & signal=(/quantity%template%signal/), sideband=(/1/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate usbFraction quantity for fill' )

        ! This method is only appliable to the cloud-induced radiances. One may assume
        ! that the scattering radiances are proportional to f^4. And this operation
        ! is only applied to Maskbit = m_cloud.

        if ( .not. associated(usb) ) then
          ! If both sidebands are within 20GHz and have similar penetration depths
          ! in the attenuative atmosphere. We can neglect the attenuation and split cloudy
          ! radiances assuming that they are fully due to scattering and obey the f^4 law.
          do i=1,size(signalOut%frequencies)
            do maf=1, quantity%template%noInstances
              do mif=1, quantity%template%noSurfs
                if ( iand ( ichar ( Quantity%Mask( i + &
                  & (mif-1) * size(signalOut%frequencies), maf)), m_cloud) /= 0 ) then
                  quantity%values(i+(mif-1)*size(signalOut%frequencies), maf ) = &
                    & sourceQuantity%values ( myChannel + &
                    & (mif-1)*size(signalIn%frequencies), maf) *freq2(i)**4/ &
                    & (lsbFraction%values ( myChannel, 1 ) * freqL1(MyChannel)**4 + &
                    & usbFraction%values ( myChannel, 1 ) * freqU1(MyChannel)**4)
                end if
              end do
            end do
          end do
        else
          ! If both sidebands are within 20GHz but have very different penetration depths,
          ! where one is optically thick and one is optically thin. We may use a reference
          ! cloud radiance near the optically-thin sideband to split cloud radiance in the
          ! optically-thick sideband. The reference radiance must be a single sideband
          ! radiance in this case, namely usb (upper sideband in most cases). The usb is
          ! scaled to the sourceQty upperside (thin) via the f^4 law, and the rest cloud
          ! radiance is for the lower sideband.
          !
          ! In this case, channel will for the reference signal and sideband frac remains for
          ! source signal.
          !
          if ( .not. ValidateVectorQuantity ( usb, &
            & quantityType=(/l_cloudInducedRadiance/), sideband=(/-1,1/), &
            & minorFrame=.true. )) call Announce_Error ( key, no_error_code, &
            & 'Inappropriate reference radiance for splitting' )

          signalRef = GetSignal ( usb%template%signal )

          call allocate_test ( freq, size(signalRef%frequencies), 'frequencies', ModuleName )
          call allocate_test ( freqL, size(signalRef%frequencies), &
            & 'LSBfrequencies', ModuleName )
          call allocate_test ( freqU, size(signalRef%frequencies), &
            & 'USBfrequencies', ModuleName )
          freq = signalRef%centerFrequency + signalRef%direction*signalRef%frequencies
          freqL = signalOut%lo - freq    ! lower sideband freq
          freqU = signalOut%lo + freq    ! upper sideband freq
          if ( usb%template%sideband == -1) freq = freqL
          if ( usb%template%sideband == 1) freq = freqU
          do i=1,size(signalOut%frequencies)

            ! need to scale the opposite sideband for the output signal
            if ( quantity%template%sideband == 1 ) then
              ratio1 = lsbFraction%values(i,1)
              ratio2 = usbFraction%values(i,1)
              freq2 = freqL2
            end if
            if ( quantity%template%sideband == -1 ) then
              ratio2 = lsbFraction%values(i,1)
              ratio1 = usbFraction%values(i,1)
              freq2 = freqU2
            end if

            do maf=1, quantity%template%noInstances
              do mif=1, quantity%template%noSurfs
                scaledRad = usb%values(MyChannel+(mif-1)*size(signalIn%frequencies), maf) * &
                  & freq2(i)**4/freq(MyChannel)**4

                if ( iand ( ichar ( Quantity%Mask( i + &
                  & (mif-1)*size(signalOut%frequencies), maf)), m_cloud) /= 0 ) then
                  quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = &
                    &  (sourceQuantity%values(i+(mif-1)*size(signalIn%frequencies), maf) - &
                    &  ratio1*scaledRad)/ratio2
                end if
              end do
            end do
          end do

          call deallocate_test ( freq, 'frequencies', ModuleName )
          call deallocate_test ( freqL,'LSBfrequencies', ModuleName )
          call deallocate_test ( freqU,'USBfrequencies', ModuleName )
        end if
      end if

      call deallocate_test ( freq1, 'frequencies', ModuleName )
      call deallocate_test ( freqL1,'LSBfrequencies', ModuleName )
      call deallocate_test ( freqU1,'USBfrequencies', ModuleName )
      call deallocate_test ( freq2, 'frequencies', ModuleName )
      call deallocate_test ( freqL2,'LSBfrequencies', ModuleName )
      call deallocate_test ( freqU2,'USBfrequencies', ModuleName )
      call trace_end ( 'FillUtils_1.FromSplitSideband', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine FromSplitSideband

    ! --------------------------------------------- Gather ---
    ! The most barbaric of Fill methods:
    ! Go through the source quantity's values, gathering
    ! them into the quantity's values
    ! according to the start, stride, block, and count arrays
    ! No checking is done

    ! (See also Scatter)
    ! See the hdf5 introduction to HDF5 description of the hyperslab
    ! for a discussion of what we mean
    ! Let the following diagram serve as a mnemonic
    !         n2 ->
    ! o x x o x x o x x o x x
    ! o x x o x x o x x o x x
    ! o x x o x x o x x o x x
    ! o o o o o o o o o o o o  n1
    ! o x x o x x o x x o x x  |
    ! o x x o x x o x x o x x  v
    ! o x x o x x o x x o x x
    ! o o o o o o o o o o o o
    ! The above is an array from sourceQuantity sized 8x12 (as n1 x n2)
    ! We plan to gather the elements marked by x into the
    ! contiguous array in quantity sized 6x8
    ! Each block is 3x2 (3,2)
    ! The start is at (1,2)
    ! The stride is (4,3)
    ! The count is (2,4)
    ! Note: if the 2nd index of block is 0, then do all instances
    ! and just hyperslabify the first index
    
    ! We recently (re)-discovered that hdf5 actually interprets the
    ! start array as if it meant "offset" instead of the starting index
    ! as this subroutine does. And as the Scatter subroutine does,
    ! for that matter. We have added the parameter MLS_HyperStart to
    ! MLSCommon. It determines whether Embeds and Extracts as implemented
    ! in the Hyperslabs module treat the start array as starting indexes
    ! or as offsets.
    ! Should we do the same here?
    
    ! We will for the present favor continuity over consistency
    ! by interpreting start to mean the starting index instead of the offset.
    subroutine Gather ( quantity, sourceQuantity, start, count, stride, block )
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), pointer :: SOURCEQUANTITY
      integer, dimension(:), intent(in) :: start
                                   ! Starting coordinates of hyperslab
      integer, dimension(:), intent(in) :: count
                                   ! Num of blocks to select from dataspace
      integer, dimension(:), intent(in) :: stride
                                   ! How many elements to move in each direction
      integer, dimension(:), intent(in) :: block
                                   ! Size of element block
      ! Local parameters
      integer :: II, JJ ! Block counters
      integer :: i, j   ! Counters within a block
      integer :: n1, n2 ! indices in sourceQuantity array
      integer :: m1, m2 ! indices in quantity array
      ! Executable
      if ( block(2) < 1 ) then
        ! do every instance of the 2nd index
        do n2=1, size(quantity%values, 2)
          do II=1, count(1)
            do i=1, block(1)
              n1 = start(1) - 1 + (II-1)*stride(1) + i
              m1 = (II-1)*block(1) + i
              quantity%values(m1, n2) = sourceQuantity%values(n1, n2)
            end do
          end do
        end do
      else
        do JJ=1, count(2)
          do II=1, count(1)
            do j=1, block(2)
              n2 = start(2) - 1 + (JJ-1)*stride(2) + j
              m2 = (JJ-1)*block(2) + j
              do i=1, block(1)
                n1 = start(1) - 1 + (II-1)*stride(1) + i
                m1 = (II-1)*block(1) + i
                quantity%values(m1, m2) = sourceQuantity%values(n1, n2)
              end do
            end do
          end do
        end do
      end if
    end subroutine Gather

    ! ------------------------------------------------  GeoidData  -----
    ! Load the geoid data from the DEM toolkit files
    ! at the default resolution unless another is specified
    ! If source quantity is present use geoid data to make it
    ! relative to geoid instead of ellipsoid
    subroutine GeoidData ( quantity, sourceQuantity, resolution )
      use, Intrinsic :: Iso_C_Binding, only: C_Short
      use Sdptoolkit, only: Pgsd_Dem_30arc, Pgsd_Dem_90arc, Pgsd_Dem_Geoid, &
        & Pgsd_Dem_Degree !, &
        !& Pgs_Dem_GetqualityData, Pgs_Dem_Getsize, Pgs_Dem_Sortmodels
      type(VectorValue_T), intent(inout)        :: QUANTITY
      type(VectorValue_T), intent(in), optional :: SOURCEQUANTITY
      integer, intent(in), optional             :: RESOLUTION
      ! Local variables
      ! integer*2, dimension(4000)        :: BUFFER
      integer(kind=c_short), dimension(4000)      :: BUFFER
      integer :: I                      ! Instance loop counter
      integer :: J                      ! Destination index
      double precision, parameter       :: DLATRANGE = 5.0d-1
      double precision, parameter       :: DLONRANGE = 1.0d0
      double precision, dimension(2)    :: latitude
      double precision, dimension(2)    :: longitude
      integer :: Me = -1                ! String index for trace
      integer :: MYRESOLUTION              ! Possibly offset channel
      integer :: NUMRESOLUTIONS
!       integer :: NUMVERTPIX
!       integer :: NUMHORIZPIX
!       integer :: PIXBYTE
      integer, dimension(2) :: resolutionList
      integer :: STATUS
!       integer, dimension(2) :: COMPLETEDATA
      integer, external :: PGS_DEM_GETQUALITYDATA ! , PGS_DEM_GETSIZE, PGS_DEM_SORTMODELS

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.GeoidData', 0, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( .not. toolkit ) then
        ! Without the sdp toolkit, we're unable to apply the geoid offsets
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Without the sdp toolkit, we are unable to apply the geoid offsets' )
        call trace_end ( 'FillUtils_1.GeoidData', &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        return
      end if
      myResolution = PGSd_DEM_90ARC
      if ( present(resolution) ) myResolution = resolution
      numResolutions = 2
      resolutionList(1) = PGSd_DEM_30ARC
      resolutionList(2) = PGSd_DEM_90ARC
      do I=1, quantity%template%noInstances
        latitude(1) =  quantity%template%geodLat(1, i) + dlatRange
        latitude(2) =  quantity%template%geodLat(1, i) - dlatRange
        longitude(1) =  quantity%template%lon(1, i) - dlonRange
        longitude(2) =  quantity%template%lon(1, i) + dlonRange
        ! Ensure latitudes, longitudes within permissible ranges:
        ! -90 < lat < 90
        ! -180 < lon < 180
        latitude = min(latitude, 90.d0)
        latitude = max(latitude, -90.d0)
        longitude = min(longitude, 179.d0)
        longitude = max(longitude, -179.d0)
        ! status = PGS_DEM_sortModels ( ResolutionList, numResolutions, &
        !  & PGSd_DEM_geoid, PGSd_DEM_degree, latitude, longitude, &
        !  & completeData(1) )
        ! call outputNamedValue( 'status (sortModels)', status )
        ! call outputNamedValue( 'latitude', latitude )
        ! call outputNamedValue( 'longitude', longitude )
        ! call outputNamedValue( 'completeData(1)', completeData(1) )

        ! status = PGS_DEM_getsize ( myResolution, &
         ! & PGSd_DEM_geoid, PGSd_DEM_degree, latitude, longitude, &
         ! & numVertPix, numHorizPix, pixByte )
      !    call outputNamedValue( 'status (GetSize)', status )
      !    call outputNamedValue( 'latitude', latitude )
      !    call outputNamedValue( 'longitude', longitude )
      !    call outputNamedValue( 'numVertPix', status )
      !    call outputNamedValue( 'numHorizPix', status )
      !    call outputNamedValue( 'PixByte', status )

        status = PGS_DEM_getqualitydata (myResolution, &
          & PGSd_DEM_geoid, PGSd_DEM_degree, latitude, longitude, buffer )
        if ( status /= 0 ) then
           call outputNamedValue( 'latitude', latitude )
           call outputNamedValue( 'longitude', longitude )
           call outputNamedValue( 'i', i )
           call outputNamedValue( 'status(getQuality)', status )
           call dump( buffer(1:10), 'buffer' )
           call MLSMessage ( MLSMSG_Error, &
            & ModuleName, "nonzero status in GeoidData; must quit" )
        end if
        if ( present(sourceQuantity)) then
          do j=1, quantity%template%noSurfs
            quantity%values(j, i) = sourceQuantity%values(j, i) - buffer(1)
          end do
        else
          do j=1, quantity%template%noSurfs
            quantity%values(j, i) = buffer(1)
          end do
        end if
      end do
      call trace_end ( 'FillUtils_1.GeoidData', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine GeoidData

    ! ---------------------------------------------  GPHPrecision  -----
    subroutine GPHPrecision ( key, quantity, &
      & tempPrecisionQuantity, refGPHPrecisionQuantity )
      ! Fill the GPH precision from the temperature and refGPH precision,
      ! ignoring the off-diagonal elements (not available outside
      ! RetrievalModule anyway).
      integer, intent(in) :: key          ! For messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: TEMPPRECISIONQUANTITY
      type (VectorValue_T), intent(in) :: REFGPHPRECISIONQUANTITY

      ! Local variables
      integer :: Me = -1                  ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.GPHPrecision', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      select case ( quantity%template%quantityType )
      case ( l_GPH )
        if ( (tempPrecisionQuantity%template%noSurfs /= &
          &   quantity%template%noSurfs) .or. &
          &  (refGPHPrecisionQuantity%template%noInstances /= &
          &   quantity%template%noInstances) .or. &
          &  (tempPrecisionQuantity%template%noInstances /= &
          &   quantity%template%noInstances) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_GPH failed first test" )
        else if ( (any(quantity%template%surfs /= tempPrecisionQuantity%template%surfs)) .or. &
          & (any(quantity%template%phi /= tempPrecisionQuantity%template%phi)) .or. &
          & (any(quantity%template%phi /= refGPHPrecisionQuantity%template%phi)) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            &  "case l_GPH failed second test" )
        else
          call GetGPHPrecision ( tempPrecisionQuantity, refGPHPrecisionQuantity, quantity%values )
        end if
      case default
        call Announce_Error ( 0, no_error_code, 'GPH precision needed for result of GPHPrecision' )
      end select

    9 call trace_end( 'FillUtils_1.GPHPrecision', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine GPHPrecision

      ! --------------------------------------  IWCFromExtinction  -----
    subroutine IWCFromExtinction ( Quantity, SourceQuantity, TemperatureQuantity)
      ! Actually, the meaning of the next two is reversed if invert is TRUE)
      type (VectorValue_T), intent(inout) :: QUANTITY ! (IWC) Quantity to fill
      type (VectorValue_T), intent(in) :: sourceQuantity ! cloud extinction
      type (VectorValue_T), intent(in) :: temperatureQuantity ! T(zeta)

      ! local variables
      real (r8), dimension(Temperaturequantity%template%noSurfs,quantity%template%noInstances) :: temp
      real (r8), dimension(Temperaturequantity%template%noSurfs) :: zt, yt
      real (r8), dimension(sourceQuantity%template%noSurfs) :: ze, ye
      real (r8), dimension(quantity%template%noSurfs) :: z, Tz, Ez, iwc0
      real (r8), dimension(quantity%template%noInstances) :: x2, y2
      real (r8), dimension(Temperaturequantity%template%noInstances) :: x1, y1
      integer :: i
      integer :: Me = -1                     ! String index for trace

      call trace_begin ( me, 'FillUtils_1.IWCFromExtinction', &
        & cond=toggle(gen) .and. levels(gen) > 2  )
      if ( .not. (quantity%template%coherent .and. sourceQuantity%template%coherent &
         .and. Temperaturequantity%template%coherent)) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "one of the quantities is not coherent")
      if ( sourceQuantity%template%noInstances /= Quantity%template%noInstances) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "IWC and Extinction profile numbers are not matched")

      if ( TemperatureQuantity%template%noInstances /= Quantity%template%noInstances ) then
         x1 = TemperatureQuantity%template%phi(1,:)
         x2 = quantity%template%phi(1,:)
         do i=1,Temperaturequantity%template%noSurfs
           y1 = TemperatureQuantity%values(i, :)
           call InterpolateValues( x1, y1, x2, y2, method='Linear' )
           temp(i,:) = y2
         end do
      else
         temp = TemperatureQuantity%values
      end if

      if ( quantity%template%verticalCoordinate == l_pressure ) then
        z = -log10 ( quantity%template%surfs(:,1) )
      else
        z = quantity%template%surfs(:,1)
      end if

      if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then
        ze = -log10 ( sourceQuantity%template%surfs(:,1) )
      else
        ze = sourceQuantity%template%surfs(:,1)
      end if

      if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then
        zt = -log10 ( Temperaturequantity%template%surfs(:,1) )
      else
        zt = Temperaturequantity%template%surfs(:,1)
      end if

      do i=1, quantity%template%noInstances
        yt = Temp(:, i)
        call InterpolateValues( zt, yt, z,  Tz, method='Linear' )
        ye = sourceQuantity%values(:, i)*1000._r8  ! converted to 1/km
        call InterpolateValues( ze, ye, z, Ez, method='Linear' )
        ! see ATBD for the conversion based on the size distribution from
        ! McFarquhar and Heymsfield [1996]
        !
        iwc0 = 10**(-2.77+0.01*(Tz-273.15))
        where(Ez < 0._r8) Ez = 0._r8
        Ez = Ez**(1./1.4)

        quantity%values(:,i) = iwc0*Ez
      end do
      call trace_end ( 'FillUtils_1.IWCFromExtinction', &
        & cond=toggle(gen) .and. levels(gen) > 2 )

    end subroutine IWCFromExtinction

    ! ----------------------------------------------  LOSVelocity  -----
    subroutine LOSVelocity ( key, qty, tngtECI, scECI, scVel )
      ! A special fill from geometry arguments
      use Geometry, only: Omega => W
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) :: TngtECI
      type (VectorValue_T), intent(in) :: SCECI
      type (VectorValue_T), intent(in) :: SCVEL

      ! Local variables
      integer :: MAF, MIF                 ! Loop counters
      integer :: Me = -1                  ! String index for trace
      integer :: noMAFs                   ! Number of major frames
      integer :: noMIFs                   ! Number of minor frames for this module

      real (r8), dimension(3) :: tngtVel  ! Due to rotation of earth
      real (r8), dimension(3) :: los      ! Normalised line of sight vector

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.LOSVelocity', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! First check that things are OK.
      if ( .not. ValidateVectorQuantity ( qty, quantityType=(/l_losVel/), &
        & minorFrame=.true., frequencyCoordinate=(/l_none/) ) ) &
        call Announce_Error ( key, No_Error_Code, &
          & 'Quantity to fill is not a valid LOS Velocity', qty )
      if ( .not. ValidateVectorQuantity ( tngtECI, quantityType=(/l_tngtECI/), &
        & minorFrame=.true., frequencyCoordinate=(/l_xyz/) ) ) &
        call Announce_Error ( key, No_Error_Code, &
          & 'Tangent ECI quantity is not of an appropriate form', tngtECI )
      if ( .not. ValidateVectorQuantity ( scECI, quantityType=(/l_scECI/), &
        & minorFrame=.true., frequencyCoordinate=(/l_xyz/) ) ) &
        call Announce_Error ( key, No_Error_Code, &
          & 'Spacecraft ECI quantity is not of an approriate form', scECI )
      if ( qty%template%instrumentModule /= tngtECI%template%instrumentModule ) &
        & call Announce_Error ( key, No_Error_Code, &
        & 'LOS Velocity and Tangent ECI quantities are not for the same module' )
      if ( .not. IsModuleSpacecraft ( scECI%template%instrumentModule ) ) &
        & call Announce_Error ( key, No_Error_Code, &
        & 'Spacecraft ECI quantity is not for the spacecraft' )

      ! Don't waste any effort if the values are all still zero
      if ( any(tngtECI%values /= 0._rv) ) then
        noMAFs = qty%template%noInstances
        noMIFs = qty%template%noSurfs

        do maf = 1, noMAFs
          do mif = 1, noMIFs

            ! First compute the tangent point velocity in ECI coordinates due
            ! to the rotation of the earth.  This no doubt makes approximations
            ! due to the slight non alignment between the earth's rotation axis
            ! and the ECI z axis, but I'm going to ignore this.

            tngtVel= omega* (/ -tngtECI%value3(2,mif,maf), &
              &                 tngtECI%value3(1,mif,maf), 0.0_r8 /)

            ! Now compute the line of sight direction unit normal
            los = tngtECI%value3(1:3,mif,maf) - scECI%value3(1:3,mif,maf)
            los = los / norm2(los)

            ! Now compute the net velocity in this direction.  For the moment,
            ! assume +ve means the sc and tp are moving apart, and -ve that
            ! they're getting closer.

            qty%values(mif,maf) = dot_product(tngtVel, los) - &
                                & dot_product(scVel%value3(1:3,mif,maf), los)

            ! Even though x,y,z have been used up to now for a GHz/THz minor
            ! frame quantity, they're OK with this sc one too.
          end do
        end do
      end if
      call trace_end ( 'FillUtils_1.LOSVelocity', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine LOSVelocity

    ! ---------------------------------------------  NoRadsPerMIF  -----
    subroutine NoRadsPerMif ( key, quantity, measQty, asPercentage )
      use BitStuff, only: Biteq
      ! Count number of valid (i.e., not Masked) radiances
      ! optionally compute it as a percentage of largest number possible
      ! The largest number possible takes into account
      ! np = the number with negative precisions
      !      Masked with bits m_linalg + m_ignore
      ! ns = the number subsetted "do not use"
      !      Masked only with bit m_linalg
      ! nv = the number valid
      !      not Masked with bit m_linalg (either alone or with others)
      ! ni = total number of instances
      ! Then ni = possible + ns
      ! and pct = 100 * nv/possible
      integer, intent(in) :: KEY
      type(VectorValue_T), intent(inout) :: QUANTITY
      type(VectorValue_T), intent(in) :: MEASQTY
      logical, intent(in), optional   :: asPercentage ! as % of
      ! Local variables
      integer  :: I0, I1                 ! Indices
      integer  :: MAF, MIF               ! Loop counters
      integer  :: Me = -1                ! String index for trace
      logical  :: pct
      integer  :: possible

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.NoRadsPerMif', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      pct = .false.
      if ( present(asPercentage) ) pct = asPercentage
      possible = measQty%template%noChans
      ! Do some fairly limited checking.
      if ( .not. ValidateVectorQuantity ( measQty, quantityType=(/l_radiance/), &
        & signal=(/quantity%template%signal/), sideband=(/quantity%template%sideband/) ) ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Quantity and measurement quantity disagree' )
      if ( associated ( measQty%Mask ) ) then
        do maf = 1, quantity%template%noInstances
          do mif = 1, quantity%template%noSurfs
            i0 = 1 +  ( mif-1 ) * measQty%template%noChans
            i1 = i0 + measQty%template%noChans - 1
            quantity%values ( mif, maf ) = count ( &
              & iand ( ichar ( measQty%Mask ( i0:i1, maf ) ), M_LinAlg ) == 0 )
            possible = measQty%template%noChans - &
              & count( biteq( ichar(measQty%Mask( i0:i1, maf )), M_linAlg) )
            possible = max(possible, 1)
            if ( pct ) &
              & quantity%values( mif, maf ) = 100*quantity%values( mif, maf )/possible
          end do
        end do
      else
        quantity%values = measQty%template%noChans
        if ( pct ) quantity%values = 100*quantity%values/possible
      end if
      call trace_end ( 'FillUtils_1.NoRadsPerMif', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine NoRadsPerMIF

    ! -------------------------------------  PhiTanWithRefraction  -----
    subroutine PhiTanWithRefraction ( key, quantity, &
      & H2O, orbIncline, ptan, refGPH, temperature, ignoreTemplate )

      use Geometry, only: Earthrada, Earthradb, Geodtogeoclat
      use Hydrostatic_M, only: Hydrostatic
      use Phi_Refractive_Correction_M, only: Phi_Refractive_Correction_Up
      use Refraction_M, only: Refractive_Index

      integer, intent(in) :: KEY          ! Tree node, for error messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! PhiTan quantity to update
      type (VectorValue_T), intent(in) :: H2O         ! Water vapor
      type (VectorValue_T), intent(in) :: OrbIncline  ! Orbital inclination
      type (VectorValue_T), intent(in) :: PTan        ! Tangent pressure
      type (VectorValue_T), intent(in) :: RefGPH      ! Reference GPH
      type (VectorValue_T), intent(in) :: TEMPERATURE ! Temperature
      logical, intent(in)              :: IGNORETEMPLATE

      real(rp), dimension(quantity%template%noInstances) :: CP2, CSQ, REQ, SP2
      real(rp) :: PhiCorrs(temperature%template%noInstances,temperature%template%noSurfs)
      real(rp), dimension(temperature%template%noInstances) :: REQS
      real(rv), dimension(temperature%template%noSurfs) :: Heights, N, PhiCorr, PS
      integer :: I, J     ! Subscripts, loop inductors
      integer :: Me = -1  ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.PhiTanWithRefraction', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! More sanity checks
      if ( .not. ignoreTemplate ) then
        if ( quantity%template%instrumentModule /= ptan%template%instrumentModule ) &
          & call Announce_Error ( key, No_Error_Code, &
          & 'PHITan and PTan quantities are not for the same module' )
        if ( any(shape(quantity%values)/=shape(ptan%values)) ) &
          & call Announce_Error ( key, No_Error_Code, &
          & 'PHITan and PTan quantities are not the same size' )
        if ( .not. ValidateVectorQuantity ( temperature, &
          & quantityType=(/l_temperature/), coherent=.true., stacked=.true., &
          & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Problem with temperature quantity for phiTan fill' )
        if ( .not. ValidateVectorQuantity ( H2O, &
          & quantityType=(/l_vmr/), molecule=(/l_H2O/), coherent=.true., stacked=.true., &
          & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Problem with H2O quantity for phiTan fill' )
        if ( .not. ValidateVectorQuantity ( refGPH, &
          & quantityType = (/l_refGPH/), coherent=.true., stacked=.true., &
          & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/), noSurfs=(/1/) ) ) &
          & call Announce_Error ( key, badrefGPHQuantity )
      end if
      i = 0
      if ( .not. DoHGridsMatch ( temperature, refGPH ) ) i = i + 1
      if ( .not. DoHGridsMatch ( temperature, H2O ) ) i = i + 2
      if ( quantity%template%noInstances /= orbincline%template%noInstances ) i = i + 4
      if ( .not. DoVGridsMatch ( temperature, H2O ) ) i = i + 8
      if ( i /= 0 ) call Announce_Error ( key, no_error_code, &
        & ' coordinates for temperature/refGPH/H2O disagree', &
        & extraInfo = (/i/) )

      ! compute equivalent earth radius at uncorrected tangent phi nearest surface
      csq = (earthrada * earthradb)**2 / &
            & ((earthrada**2-earthradb**2)*sin(orbincline%values(1,:)*deg2rad)**2 + &
            &   earthradb**2)
      cp2 = cos(quantity%values(1,:)*deg2rad)**2
      sp2 = 1.0_rp - cp2
      req = 0.001_rp*sqrt((earthrada**4*sp2 + csq**2*cp2) / &
                        & (earthrada**2*cp2 + csq*sp2))

      ! Interpolate REQ to temperature/H2O/refGPH hGrid
      call InterpolateValues ( quantity%values(1,:), req, &
        & temperature%template%phi(1,:), reqs, 'Linear', extrapolate='Constant' )

      ! Get pressures corresponding to Temperature etc
      ps = 10.0**(-temperature%template%surfs(:,1))

      ! OK, do the refraction calculation on Temperature's grids
      do i = 1, temperature%template%noInstances

        ! Get heights.  Temperature and RefGPH are on same hGrids.
        ! RefGPH is in meters, but Hydrostatic wants it in km.
        call Hydrostatic ( GeodToGeocLat ( temperature%template%geodLat(1,i) ), &
          & temperature%template%surfs(:,1), temperature%values(:,i), &
          & temperature%template%surfs(:,1), &
          & refGPH%template%surfs(1,1), 0.001*refGPH%values(1,i), &
          & heights )
        heights = heights + reqs(i)
        ! Get refractive indices.  Temperature and H2O are on same grids.
        call refractive_index ( ps, temperature%values(:,i), n, H2O%values(:,i) )
        do j = 1, temperature%template%noSurfs
          call phi_refractive_correction_up ( n(j:), heights(j:), phiCorr(j:) )
          phiCorrs(i,j) = phiCorr(temperature%template%noSurfs) * rad2deg
        end do
      end do

      ! Now interpolate Phi corrections onto the PhiTan grid and apply them.
      ! Its zeta grid is the value of PTan; its phi grid is its own value.

      do j = 1, size(quantity%values,2)
        call interpolateValues ( H2O%template%phi(1,:), quantity%values(:,j), &
          &                      H2O%template%surfs(:,1), ptan%values(:,j), &
          &                      phiCorrs, quantity%values(:,j), update=.true. )
      end do ! j

      call trace_end ( 'FillUtils_1.PhiTanWithRefraction', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine PhiTanWithRefraction
    
    ! -------------------------------------  HeightFromPressure  -----
    subroutine HeightFromPressure ( key, quantity, &
      & H2O, orbIncline, ptan, refGPH, temperature, ignoreTemplate )

      use Geometry, only: Geodtogeoclat
      use Hydrostatic_M, only: Hydrostatic

      integer, intent(in) :: KEY          ! Tree node, for error messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! PhiTan quantity to update
      type (VectorValue_T), intent(in) :: H2O         ! Water vapor
      type (VectorValue_T), intent(in) :: OrbIncline  ! Orbital inclination
      type (VectorValue_T), intent(in) :: PTan        ! Tangent pressure
      type (VectorValue_T), intent(in) :: RefGPH      ! Reference GPH
      type (VectorValue_T), intent(in) :: TEMPERATURE ! Temperature
      logical, intent(in)              :: IGNORETEMPLATE

      real(rv), dimension(temperature%template%noSurfs) :: Heights
      integer :: I        ! Subscripts, loop inductors
      integer :: Me = -1  ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.HeightFromPressure', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! More sanity checks
      if ( .not. ignoreTemplate ) then
        if ( .not. ValidateVectorQuantity ( temperature, &
          & quantityType=(/l_temperature/), coherent=.true., stacked=.true., &
          & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Problem with temperature quantity for phiTan fill' )
        if ( .not. ValidateVectorQuantity ( H2O, &
          & quantityType=(/l_vmr/), molecule=(/l_H2O/), coherent=.true., stacked=.true., &
          & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Problem with H2O quantity for phiTan fill' )
        if ( .not. ValidateVectorQuantity ( refGPH, &
          & quantityType = (/l_refGPH/), coherent=.true., stacked=.true., &
          & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/), noSurfs=(/1/) ) ) &
          & call Announce_Error ( key, badrefGPHQuantity )
      end if
      i = 0
      if ( .not. DoHGridsMatch ( temperature, refGPH ) ) i = i + 1
      if ( .not. DoHGridsMatch ( temperature, H2O ) ) i = i + 2
      if ( .not. DoVGridsMatch ( temperature, H2O ) ) i = i + 8
      if ( i /= 0 ) call Announce_Error ( key, no_error_code, &
        & ' coordinates for temperature/refGPH/H2O disagree', &
        & extraInfo = (/i/) )  

      ! Interpolate REQ to temperature/H2O/refGPH hGrid
      ! call InterpolateValues ( quantity%values(1,:), req, &
      !   & temperature%template%phi(1,:), reqs, 'Linear', extrapolate='Constant' )

      ! Get pressures corresponding to Temperature etc
      ! ps = 10.0**(-temperature%template%surfs(:,1))
      
      ! The heights will vary depending on local pressure surfaces
       do i = 1, temperature%template%noInstances

         ! Get heights.  Temperature and RefGPH are on same hGrids.
         ! RefGPH is in meters, but Hydrostatic wants it in km.
         call Hydrostatic ( GeodToGeocLat ( temperature%template%geodLat(1,i) ), &
           & temperature%template%surfs(:,1), temperature%values(:,i), &
           & temperature%template%surfs(:,1), &
           & refGPH%template%surfs(1,1), 0.001*refGPH%values(1,i), &
           & heights )

         quantity%values(:,i) = heights
       end do
       

      call trace_end ( 'FillUtils_1.HeightFromPressure', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine HeightFromPressure

      ! ------------------------------------- RHiFromOrToH2O ----
    subroutine RHiFromOrToH2O ( key, quantity, &
     & sourceQuantity, temperatureQuantity, &
     & dontMask, ignoreZero, ignoreNegative, interpolate, &
     & markUndefinedValues, invert )
      ! Convert H2O vmr to %RHi for all instances, channels, surfaces
      ! (See Eq. 9 from "UARS Microwave Limb Sounder upper tropospheric
      !  humidity measurement: Method and validation" Read et. al.
      !  J. Geoph. Res. Dec. 2001 (106) D23)

      !  Method:
      ! (1) straight convert--all quantities must have the same shape
      !     (strictly we assume they have _all_ the same geolocations)
      ! (2) interpolate--all quantities may have different shapes
      !     (the interpolation will be along the vertical coordinate only)
      !     I.e., for xQuantity (where x can be H2O or temperature)
      !     if NoChans(xQuantity) /= NoChans(Quantity)
      !        => use only xQuantity(channel==1)
      !     if NoInstances(xQuantity) /= NoInstances(Quantity)
      !        => use only xQuantity(instance==1)
      !
      ! (3) if invert is TRUE, like (1) but its inverse: %RHi to H2O vmr
      integer, intent(in) :: key          ! For messages
      ! Actually, the meaning of the next two is reversed if invert is TRUE)
      type (VectorValue_T), intent(inout) :: QUANTITY ! (RHi) Quantity to fill
      type (VectorValue_T), intent(in) :: sourceQuantity ! vmr (unless invert)
      type (VectorValue_T), intent(in) :: temperatureQuantity ! T(zeta)
      logical, intent(in)           ::    dontMask    ! Use even Masked values
      logical, intent(in)           ::    ignoreZero  ! Ignore 0 values of H2O
      logical, intent(in)           ::    ignoreNegative  ! Ignore <0 values
      logical, intent(in)           ::    interpolate ! If VGrids or HGrids differ
      logical, intent(in)           ::    markUndefinedValues ! as UNDEFINED_VALUE
      logical, intent(in)           ::    invert      ! %RHi -> vmr if TRUE

      ! Local variables
      integer ::                          Channel     ! Channel loop counter
      integer ::                          Chan_H2O    ! Channel loop counter
      integer ::                          Chan_T      ! Channel loop counter
      logical, parameter ::               DEEBUG_RHi = .false.
      integer                          :: dim
      integer ::                          I           ! Instances
      integer ::                          I_H2O       ! Instance num for values
      integer ::                          I_T         ! Instance num for values
      ! integer ::                          invs        ! 1 if invert, else -1
      logical                          :: matched_H2O_channels
      logical                          :: matched_H2O_instances
      logical                          :: matched_sizes
      logical                          :: matched_surfs
      logical                          :: matched_T_channels
      logical                          :: matched_T_instances
      integer :: Me = -1                  ! String index for trace
      integer ::                          N           ! Num. of summed values
      integer ::                          QINDEX
      integer ::                          S           ! Surface loop counter
      integer ::                          S_H2O       ! Instance num for surfs
      integer ::                          S_RHi       ! Instance num for surfs
      integer ::                          S_T         ! Instance num for surfs
      logical ::                          skipMe
      real (r8) ::                        T
      character(len=*), parameter ::      VMR_UNITS = 'vmr'
      integer ::                          VMR_UNIT_CNV
      logical ::                          wereAnySkipped
      ! These automatic arrays could cause trouble later
      ! You may consider declaring them as pointers and
      ! calling allocate_test and deallocate_test
      real (r8), dimension(quantity%template%noSurfs) :: &
       &                                  zeta, TofZeta, H2OofZeta
      real (r8), dimension(Temperaturequantity%template%noSurfs) :: &
       &                                  zetaTemperature, oldTemperature
      real (r8), dimension(sourceQuantity%template%noSurfs) :: &
       &                                  zetaH2O, oldH2O
      real (r8), dimension(quantity%template%noSurfs, quantity%template%noInstances) :: &
       &                                  values
      ! Executable statements
      call trace_begin ( me, 'FillUtils_1.RHiFromOrToH2O', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      values = 0.
      ! Let any undefined values be so marked (but not necessarily Masked)
      ! An exceptionally dubious step -- should remove this idea
      if ( markUndefinedValues ) Quantity%values = UNDEFINED_VALUE
      ! Will we convert %RHi to vmr?
      !  if ( invert ) then
      !    invs = 1
      !  else
      !    invs = -1
      !  end if
      ! Do we need to internally convert the vmr units?
      if ( VMR_UNITS == 'ppmv' ) then
        vmr_unit_cnv = 6
      else if ( VMR_UNITS == 'ppbv' ) then
        vmr_unit_cnv = 9
      else
        vmr_unit_cnv = 0
      end if
      ! Check that all is well
      if ( invert .and. interpolate ) then
       call Announce_Error ( key, No_Error_code, &
        & ' RHiFromOrToH2O unable to invert and interpolate simultaneously' )
       go to 9
      end if
      matched_sizes = .true.
      do dim=1, 2
        matched_sizes = matched_sizes .and. &
        & .not. any( size(Quantity%values,dim) /= &
        &(/ size(sourceQuantity%values,dim), &
        & size(temperatureQuantity%values,dim) /)&
        & )
      end do
      if ( .not. (matched_sizes .or. interpolate) ) then
       call Announce_Error ( key, No_Error_code, &
        & 'Incompatible quantities in RHiFromOrToH2O--' //&
        & '(unless interpolating, all must have same shape)' )
       go to 9
      end if
      matched_surfs = .true.
      matched_surfs = matched_surfs .and. &
       & .not. any( Quantity%template%noSurfs /= &
       &(/ sourceQuantity%template%noSurfs, &
       & temperatureQuantity%template%noSurfs /)&
       & )
      if ( .not. (matched_surfs .or. interpolate) ) then
       call Announce_Error ( key, No_Error_code, &
        & 'Different vertical coords in RHiFromOrToH2O--' //&
        & '(unless interpolating, all must be on the same VGrid)' )
       go to 9
      end if
      matched_H2O_channels = &
       &   (sourceQuantity%template%noChans == Quantity%template%noChans)
      matched_H2O_instances = &
       &   (sourceQuantity%template%noInstances == Quantity%template%noInstances)
      matched_T_channels = &
       &   (TemperatureQuantity%template%noChans == Quantity%template%noChans)
      matched_T_instances = &
       &   (TemperatureQuantity%template%noInstances == Quantity%template%noInstances)
      wereAnySkipped = .false.
      ! Now let's do the actual conversion
      do i=1, quantity%template%noInstances
        if ( quantity%template%coherent ) then
          s_RHi = 1
        else
          s_RHi = i
        end if
        if ( sourceQuantity%template%coherent ) then
          s_H2O = 1
        else
          s_H2O = i
        end if
        if ( temperaturequantity%template%coherent ) then
          s_t = 1
        else
          s_t = i
        end if
        ! zeta must be in log(hPa) units
        if ( quantity%template%verticalCoordinate == l_pressure ) then
          zeta = -log10 ( quantity%template%surfs(:,s_RHi) )
        else
          zeta = quantity%template%surfs(:,s_RHi)
        end if
        if ( interpolate .and. .not. matched_H2O_instances ) then
          i_H2O = 1
        else
          i_H2O = i
        end if
        if ( interpolate .and. .not. matched_T_instances ) then
          i_T = 1
        else
          i_T = i
        end if
        if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then
          zetaH2O = -log10 ( sourceQuantity%template%surfs(:,s_H2O) )
        else
          zetaH2O = sourceQuantity%template%surfs(:,s_H2O)
        end if
        if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then
          zetaTemperature = -log10 ( Temperaturequantity%template%surfs(:,s_T) )
        else
          zetaTemperature = Temperaturequantity%template%surfs(:,s_T)
        end if
        N = 0
        do Channel=1, quantity%template%noChans
          if ( interpolate .and. .not. matched_H2O_channels ) then
            Chan_H2O = 1
          else
            Chan_H2O = Channel
          end if
          if ( interpolate .and. .not. matched_T_channels ) then
            Chan_T = 1
          else
            Chan_T = Channel
          end if
          if ( interpolate ) then
            do s=1, sourceQuantity%template%noSurfs
              qIndex = Chan_H2O + (s-1)*sourceQuantity%template%noChans
              oldH2O(s) = sourceQuantity%values(qIndex, i_H2O)
            end do
            ! Know the following about the procedure we will call:
            ! First pair of args are old(X,Y), next pair are new(X,Y)
            ! We want newY(newX) via linear interp. w/o extrapolating
            ! and mark undefined values among oldY with UNDEFINED_VALUE
            call InterpolateValues( zetaH2O, oldH2O, &
             & zeta, H2OofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
            do s=1, Temperaturequantity%template%noSurfs
              qIndex = Chan_T + (s-1)*Temperaturequantity%template%noChans
              oldTemperature(s) = TemperatureQuantity%values(qIndex, i_T)
            end do
            call InterpolateValues( zetaTemperature, oldTemperature, &
             & zeta, TofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
          else
            do s=1, quantity%template%noSurfs
              N = N + 1
              qIndex = Channel + (s-1)*quantity%template%noChans
              H2OofZeta(s) = sourceQuantity%values(qIndex, i)
              TofZeta(s) = TemperatureQuantity%values(qIndex, i)
            end do
          end if
          do s=1, quantity%template%noSurfs
            N = N + 1
            qIndex = Channel + (s-1)*quantity%template%noChans
            skipMe = .false.
            skipMe = skipMe .or. &
            & .not. dontMask .and. ( &
            & (ignoreNegative .and. H2OofZeta(s) < 0.0 ) &
            & .or. (ignoreZero .and. H2OofZeta(s) == 0.0 ) &
            & )
            ! But skip no matter what else if temperature illegal
            skipMe = skipMe .or. TofZeta(s) <= 0.0
            if ( .not. skipMe ) then
              T = TofZeta(s)
              ! Quantity%values(qIndex, i) = &
              values(qIndex, i) = &
               & H2OofZeta(s) &
               & * &
               & RHiFromH2O_Factor(T, zeta(qIndex), vmr_unit_cnv, invert)
            end if
            wereAnySkipped = wereAnySkipped .or. skipMe
          end do
        end do
      end do
      if ( .not. associated ( quantity%Mask ) ) then
        quantity%values = values
      else
        where ( iand ( ichar(quantity%Mask(:,:)), m_fill ) == 0 )
          quantity%values = values
        end where
      end if
      if ( DEEBUG_RHi ) then
        call output('RHi Num. instances: ', advance='no')
        if ( invert ) then
          call output(sourceQuantity%template%noInstances, advance='yes')
        else
          call output(quantity%template%noInstances, advance='yes')
        end if
        call output('  size(surfs,2) ', advance='no')
        call output(size(quantity%template%surfs,2), advance='yes')
        call output('Were any RHi left undefined? ', advance='no')
        call output(wereAnySkipped, advance='yes')
        call dump(zeta, 'zeta(-log hPa)')
        do s=1, quantity%template%noSurfs
          if ( invert ) then
            zeta(s) = 1000000*Quantity%values(s,1)
          else
            zeta(s) = 1000000*sourceQuantity%values(s,1)
          end if
        end do
        call dump(zeta, 'H2O(ppmv)')
        call dump(TemperatureQuantity%values(:,1), 'Temperature(K)')
        if ( invert ) then
          call dump(sourceQuantity%values(:,1), 'RHi(%)')
        else
          call dump(Quantity%values(:,1), 'RHi(%)')
        end if
      end if
    9 call trace_end ( 'FillUtils_1.RHiFromOrToH2O', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine RHiFromOrToH2O
!MJF
    ! ----------------------------------  RHiPrecisionFromOrToH2O  -----
    subroutine RHiPrecisionFromOrToH2O ( key, quantity, &
     & sourcePrecisionQuantity, tempPrecisionQuantity, sourceQuantity, &
     & temperatureQuantity, &
     & dontMask, ignoreZero, ignoreNegative, interpolate, &
     & markUndefinedValues, invert )
      ! For precisions:
      ! Convert H2O vmr to %RHi for all instances, channels, surfaces
      ! (See Eq. 9 from "UARS Microwave Limb Sounder upper tropospheric
      !  humidity measurement: Method and validation" Read et. al.
      !  J. Geoph. Res. Dec. 2001 (106) D23)

      !  Method:
      ! (1) straight convert--all quantities must have the same shape
      !     (strictly we assume they have _all_ the same geolocations)
      ! (2) interpolate--all quantities may have different shapes
      !     (the interpolation will be along the vertical coordinate only)
      !     I.e., for xQuantity (where x can be H2O or temperature)
      !     if NoChans(xQuantity) /= NoChans(Quantity)
      !        => use only xQuantity(channel==1)
      !     if NoInstances(xQuantity) /= NoInstances(Quantity)
      !        => use only xQuantity(instance==1)
      !
      ! (3) Don't know how to invert precisions
      !
      ! Note: If either of TempPrecision or H2OPrecision is negative, then
      ! set Precision to negative, too (if NEGATIVETOO is TRUE)
      integer, intent(in) :: key          ! For messages
      ! Actually, the meaning of the next two is reversed if invert is TRUE)
      type (VectorValue_T), intent(inout) :: QUANTITY ! (RHi) Quantity to fill
      type (VectorValue_T), intent(in) :: sourcePrecisionQuantity ! vmr (unless invert)
      type (VectorValue_T), intent(in) :: tempPrecisionQuantity ! T(zeta)
      type (VectorValue_T), intent(in) :: sourceQuantity ! vmr (unless invert)
      type (VectorValue_T), intent(in) :: temperatureQuantity ! T(zeta)
      logical, intent(in)           ::    dontMask    ! Use even Masked values
      logical, intent(in)           ::    ignoreZero  ! Ignore 0 values of H2O
      logical, intent(in)           ::    ignoreNegative  ! Ignore <0 values
      logical, intent(in)           ::    interpolate ! If VGrids or HGrids differ
      logical, intent(in)           ::    markUndefinedValues ! as UNDEFINED_VALUE
      logical, intent(in)           ::    invert      ! %RHi -> vmr if TRUE

      ! Local variables
      integer ::                          Channel     ! Channel loop counter
      integer ::                          Chan_H2OPrecision    ! Channel loop counter
      integer ::                          Chan_TPrecision      ! Channel loop counter
      integer ::                          Chan_H2O    ! Channel loop counter
      integer ::                          Chan_T      ! Channel loop counter
      logical, parameter ::               DEEBUG_RHi = .false.
      integer                          :: dim
      integer ::                          I           ! Instances
      integer ::                          I_H2OPrecision       ! Instance num for values
      integer ::                          I_TPrecision         ! Instance num for values
      integer ::                          I_H2O       ! Instance num for values
      integer ::                          I_T         ! Instance num for values
      logical                          :: matched_H2OPrecision_channels
      logical                          :: matched_H2OPrecision_instances
      logical                          :: matched_H2O_channels
      logical                          :: matched_H2O_instances
      logical                          :: matched_sizes
      logical                          :: matched_surfs
      logical                          :: matched_TPrecision_channels
      logical                          :: matched_TPrecision_instances
      logical                          :: matched_T_channels
      logical                          :: matched_T_instances
      integer :: Me = -1                  ! String index for trace
      integer ::                          N           ! Num. of summed values
      logical, parameter ::               NEGATIVETOO = .true.
      integer ::                          QINDEX
      real (r8) ::                        qty_precision
      integer ::                          S           ! Surface loop counter
      integer ::                          S_H2O       ! Instance num for surfs
      integer ::                          S_RHi       ! Instance num for surfs
      integer ::                          S_T         ! Instance num for surfs
      logical ::                          skipMe
      character(len=*), parameter ::      VMR_UNITS = 'vmr'
      integer ::                          VMR_UNIT_CNV
      logical ::                          wereAnySkipped
      ! These automatic arrays could cause trouble later
      ! You may consider declaring them as pointers and
      ! calling allocate_test and deallocate_test
      real (r8), dimension(quantity%template%noSurfs) :: &
       &                                  zeta, TPrecisionofZeta, sourcePrecisionofZeta, TofZeta, H2OofZeta
      real (r8), dimension(TempPrecisionquantity%template%noSurfs) :: &
       &                                  zetaTempPrecision, oldTempPrecision
      real (r8), dimension(sourcePrecisionQuantity%template%noSurfs) :: &
       &                                  zetaH2OPrecision, oldH2OPrecision
      real (r8), dimension(Temperaturequantity%template%noSurfs) :: &
       &                                  zetaTemperature, oldTemperature
      real (r8), dimension(sourceQuantity%template%noSurfs) :: &
       &                                  zetaH2O, oldH2O
      real (r8), dimension(quantity%template%noSurfs, quantity%template%noInstances) :: &
       &                                  values
      ! Executable statements
      call trace_begin ( me, 'FillUtils_1.RHiPrecisionFromOrToH2O', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      values = 0.
      ! Let any undefined values be so marked (but not necessarily Masked)
      ! An exceptionally dubious step -- should remove this idea
      if ( markUndefinedValues ) Quantity%values = UNDEFINED_VALUE
      ! Will we convert %RHi to vmr?
      ! if ( invert ) then
      ! call Announce_Error ( key, No_Error_code, &
      !  & ' RHiPrecisionFromOrToH2O unable to invert' )
      ! go to 9
      ! end if
      ! Do we need to internally convert the vmr units?
      if ( VMR_UNITS == 'ppmv' ) then
        vmr_unit_cnv = 6
      else if ( VMR_UNITS == 'ppbv' ) then
        vmr_unit_cnv = 9
      else
        vmr_unit_cnv = 0
      end if
      ! Check that all is well
      if ( invert .and. interpolate ) then
       call Announce_Error ( key, No_Error_code, &
        & ' RHiPrecisionFromOrToH2O unable to invert and interpolate simultaneously' )
       go to 9
      end if
      matched_sizes = .true.
      do dim=1, 2
        matched_sizes = matched_sizes .and. &
        & .not. any( size(Quantity%values,dim) /= &
        &(/ size(sourcePrecisionQuantity%values,dim), &
        & size(tempPrecisionQuantity%values,dim), &
        & size(sourceQuantity%values,dim), &
        & size(temperatureQuantity%values,dim) /)&
        & )
      end do
      if ( .not. (matched_sizes .or. interpolate) ) then
       call Announce_Error ( key, No_Error_code, &
        & 'Incompatible quantities in RHiPrecisionFromOrToH2O--' //&
        & '(unless interpolating, all must have same shape)' )
       go to 9
      end if
      matched_surfs = .true.
      matched_surfs = matched_surfs .and. &
       & .not. any( Quantity%template%noSurfs /= &
       &(/ sourcePrecisionQuantity%template%noSurfs, &
       & tempPrecisionQuantity%template%noSurfs, &
       & sourceQuantity%template%noSurfs, &
       & temperatureQuantity%template%noSurfs /)&
       & )
      if ( .not. (matched_surfs .or. interpolate) ) then
       call Announce_Error ( key, No_Error_code, &
        & 'Different vertical coords in RHiPrecisionFromOrToH2O--' //&
        & '(unless interpolating, all must be on the same VGrid)' )
       go to 9
      end if
      matched_H2OPrecision_channels = &
       &   (sourcePrecisionQuantity%template%noChans == Quantity%template%noChans)
      matched_H2OPrecision_instances = &
       &   (sourcePrecisionQuantity%template%noInstances == Quantity%template%noInstances)
      matched_TPrecision_channels = &
       &   (TempPrecisionQuantity%template%noChans == Quantity%template%noChans)
      matched_TPrecision_instances = &
       &   (TempPrecisionQuantity%template%noInstances == Quantity%template%noInstances)
      matched_H2O_channels = &
       &   (sourceQuantity%template%noChans == Quantity%template%noChans)
      matched_H2O_instances = &
       &   (sourceQuantity%template%noInstances == Quantity%template%noInstances)
      matched_T_channels = &
       &   (TemperatureQuantity%template%noChans == Quantity%template%noChans)
      matched_T_instances = &
       &   (TemperatureQuantity%template%noInstances == Quantity%template%noInstances)
      wereAnySkipped = .false.
      ! Now let's do the actual conversion
      do i=1, quantity%template%noInstances
        if ( quantity%template%coherent ) then
          s_RHi = 1
        else
          s_RHi = i
        end if
        if ( sourceQuantity%template%coherent ) then
          s_H2O = 1
        else
          s_H2O = i
        end if
        if ( temperaturequantity%template%coherent ) then
          s_t = 1
        else
          s_t = i
        end if
        ! zeta must be in log(hPa) units
        if ( quantity%template%verticalCoordinate == l_pressure ) then
          zeta = -log10 ( quantity%template%surfs(:,s_RHi) )
        else
          zeta = quantity%template%surfs(:,s_RHi)
        end if
        if ( interpolate .and. .not. matched_H2OPrecision_instances ) then
          i_H2OPrecision = 1
        else
          i_H2OPrecision = i
        end if
        if ( interpolate .and. .not. matched_TPrecision_instances ) then
          i_TPrecision = 1
        else
          i_TPrecision = i
        end if
        if ( interpolate .and. .not. matched_H2O_instances ) then
          i_H2O = 1
        else
          i_H2O = i
        end if
        if ( interpolate .and. .not. matched_T_instances ) then
          i_T = 1
        else
          i_T = i
        end if
        if ( sourcePrecisionQuantity%template%verticalCoordinate == l_pressure ) then
          zetaH2OPrecision = -log10 ( sourcePrecisionQuantity%template%surfs(:,s_H2O) )
        else
          zetaH2OPrecision = sourcePrecisionQuantity%template%surfs(:,s_H2O)
        end if
        if ( TempPrecisionquantity%template%verticalCoordinate == l_pressure ) then
          zetaTempPrecision = -log10 ( TempPrecisionquantity%template%surfs(:,s_T) )
        else
          zetaTempPrecision = TempPrecisionquantity%template%surfs(:,s_T)
        end if
        if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then
          zetaH2O = -log10 ( sourceQuantity%template%surfs(:,s_H2O) )
        else
          zetaH2O = sourceQuantity%template%surfs(:,s_H2O)
        end if
        if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then
          zetaTemperature = -log10 ( Temperaturequantity%template%surfs(:,s_T) )
        else
          zetaTemperature = Temperaturequantity%template%surfs(:,s_T)
        end if
        N = 0
        do Channel=1, quantity%template%noChans
          if ( interpolate .and. .not. matched_H2OPrecision_channels ) then
            Chan_H2OPrecision = 1
          else
            Chan_H2OPrecision = Channel
          end if
          if ( interpolate .and. .not. matched_TPrecision_channels ) then
            Chan_TPrecision = 1
          else
            Chan_TPrecision = Channel
          end if
          if ( interpolate .and. .not. matched_H2O_channels ) then
            Chan_H2O = 1
          else
            Chan_H2O = Channel
          end if
          if ( interpolate .and. .not. matched_T_channels ) then
            Chan_T = 1
          else
            Chan_T = Channel
          end if
          if ( interpolate ) then
            do s=1, sourcePrecisionQuantity%template%noSurfs
              qIndex = Chan_H2OPrecision + (s-1)*sourcePrecisionQuantity%template%noChans
              oldH2OPrecision(s) = sourcePrecisionQuantity%values(qIndex, i_H2OPrecision)
            end do
            ! Know the following about the procedure we will call:
            ! First pair of args are old(X,Y), next pair are new(X,Y)
            ! We want newY(newX) via linear interp. w/o extrapolating
            ! and mark undefined values among oldY with UNDEFINED_VALUE
            call InterpolateValues( zetaH2OPrecision, oldH2OPrecision, &
             & zeta, sourcePrecisionofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
            do s=1, TempPrecisionquantity%template%noSurfs
              qIndex = Chan_TPrecision + (s-1)*TempPrecisionquantity%template%noChans
              oldTempPrecision(s) = TempPrecisionQuantity%values(qIndex, i_TPrecision)
            end do
            call InterpolateValues( zetaTempPrecision, oldTempPrecision, &
             & zeta, TPrecisionofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
            do s=1, sourceQuantity%template%noSurfs
              qIndex = Chan_H2O + (s-1)*sourceQuantity%template%noChans
              oldH2O(s) = sourceQuantity%values(qIndex, i_H2O)
            end do
            ! Know the following about the procedure we will call:
            ! First pair of args are old(X,Y), next pair are new(X,Y)
            ! We want newY(newX) via linear interp. w/o extrapolating
            ! and mark undefined values among oldY with UNDEFINED_VALUE
            call InterpolateValues( zetaH2O, oldH2O, &
             & zeta, H2OofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
            do s=1, Temperaturequantity%template%noSurfs
              qIndex = Chan_T + (s-1)*Temperaturequantity%template%noChans
              oldTemperature(s) = TemperatureQuantity%values(qIndex, i_T)
            end do
            call InterpolateValues( zetaTemperature, oldTemperature, &
             & zeta, TofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
          else
            do s=1, quantity%template%noSurfs
              N = N + 1
              qIndex = Channel + (s-1)*quantity%template%noChans
              sourcePrecisionofZeta(s) = sourcePrecisionQuantity%values(qIndex, i)
              TPrecisionofZeta(s) = TempPrecisionQuantity%values(qIndex, i)
              H2OofZeta(s) = sourceQuantity%values(qIndex, i)
              TofZeta(s) = TemperatureQuantity%values(qIndex, i)
            end do
          end if
          do s=1, quantity%template%noSurfs
            N = N + 1
            qIndex = Channel + (s-1)*quantity%template%noChans
            skipMe = .false.
            skipMe = skipMe .or. &
            & .not. dontMask .and. ( &
            & (ignoreNegative .and. H2OofZeta(s) < 0.0 ) &
            & .or. (ignoreZero .and. H2OofZeta(s) == 0.0 ) &
            & )
            ! But skip no matter what else if temperature illegal
            skipMe = skipMe .or. TofZeta(s) <= 0.0
            if ( .not. skipMe ) then
              if ( invert ) then
                call H2OPrecFromRHi( H2OofZeta(s), &
                 & TofZeta(s), zeta(qIndex), vmr_unit_cnv, &
                 & sourcePrecisionofZeta(s), TPrecisionofZeta(s), &
                 & qty_precision, negativeToo )
              else
                call RHiPrecFromH2O( H2OofZeta(s), &
                 & TofZeta(s), zeta(qIndex), vmr_unit_cnv, &
                 & sourcePrecisionofZeta(s), TPrecisionofZeta(s), &
                 & qty_precision, negativeToo )
              end if
              ! Quantity%values(qIndex, i) = qty_precision
              values(qIndex, i) = qty_precision
            end if
            wereAnySkipped = wereAnySkipped .or. skipMe
          end do
        end do
      end do
      if ( .not. associated ( quantity%Mask ) ) then
        quantity%values = values
      else
        where ( iand ( ichar(quantity%Mask(:,:)), m_fill ) == 0 )
          quantity%values = values
        end where
      end if
      if ( DEEBUG_RHi ) then
        call output('RHi Num. instances: ', advance='no')
        if ( invert ) then
          call output(sourceQuantity%template%noInstances, advance='yes')
        else
          call output(quantity%template%noInstances, advance='yes')
        end if
        call output('  size(surfs,2) ', advance='no')
        call output(size(quantity%template%surfs,2), advance='yes')
        call output('Were any RHi left undefined? ', advance='no')
        call output(wereAnySkipped, advance='yes')
        call dump(zeta, 'zeta(-log hPa)')
        do s=1, quantity%template%noSurfs
          if ( invert ) then
            zeta(s) = 1000000*Quantity%values(s,1)
          else
            zeta(s) = 1000000*sourceQuantity%values(s,1)
          end if
        end do
        call dump(zeta, 'H2O(ppmv)')
        call dump(TemperatureQuantity%values(:,1), 'Temperature(K)')
        if ( invert ) then
          call dump(sourceQuantity%values(:,1), 'RHi(%)')
        else
          call dump(Quantity%values(:,1), 'RHi(%)')
        end if
      end if
    9 call trace_end ( 'FillUtils_1.RHiPrecisionFromOrToH2O', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine RHiPrecisionFromOrToH2O
!MJF
    ! --------------------------------------------  FromASCIIFile  -----
    subroutine FromAsciiFile ( key, quantity, filename, badRange )
      use Io_stuff, only: Get_lun
      use Lexer_Core, only: Get_Where
      use Machine, only: Io_error
      use Tree, only: Where
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      integer, intent(in) :: FILENAME   ! ASCII filename to read from
      real(r8), dimension(2), optional, intent(in) :: BADRANGE ! Range for missing data
      ! Local variables
      integer :: LUN                    ! Unit number
      integer :: Me = -1                ! String index for trace
      integer :: STATUS                 ! Flag from open/close/read etc.
      character(len=1024) :: FILENAMESTR
      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FromAsciiFile', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      call get_lun ( lun, msg=.false. )
      if ( lun < 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "No logical unit numbers available" )
      call Get_String ( filename, filenameStr, strip=.true. )
      open ( unit=lun, file=filenameStr, status='old', form='formatted', &
        & access='sequential', iostat=status )
      if ( status /= 0 ) then
        call io_Error ( "Unable to open ASCII input file ", status, fileNameStr )
        call get_where ( where(key), fileNameStr, before='Error opening ASCII file at ' )
        call MLSMessage( MLSMSG_Error, ModuleName, fileNameStr )
      end if
      read ( unit=lun, fmt=*, iostat=status ) quantity%values
      if ( status /= 0 ) then
        call io_Error ( "Unable to read ASCII input file ", status, filenameStr )
        call get_where ( where(key), fileNameStr, before='Error reading ASCII file at ' )
        call MLSMessage( MLSMSG_Error, ModuleName, fileNameStr )
      end if
      close ( unit=lun, iostat=status )
      if ( status /= 0 ) then
        call io_Error ( "Unable to close ASCII input file ", status, filenameStr )
        call get_where ( where(key), fileNameStr, before='Error closing  ASCII file at ' )
        call MLSMessage( MLSMSG_Error, ModuleName, fileNameStr )
      end if
      if ( present ( badRange ) ) then
        if ( .not. associated ( quantity%Mask ) ) call CreateMask ( quantity )
        where ( quantity%values >= badRange(1) .and. &
          & quantity%values <= badRange(2) )
          quantity%Mask = char(ior(ichar(quantity%Mask),M_LinAlg))
        end where
      end if
      call trace_end ( 'FillUtils_1.FromAsciiFile', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine FromAsciiFile

    ! --------------------------------------  FromInterpolatedQty  -----
    subroutine FromInterpolatedQty ( qty, source, key, &
      & ignoreTemplate, ptan )
      use MLSNumerics, only: Interpolate_Regular_To_Irregular
      use VectorsModule, only: CreateVectorValue
      ! Arguments
      ! Source and Qty have the target attribute so that we can take pointers
      ! to their %template%surfs components
      type (VectorValue_T), intent(inout), target :: QTY
      type (VectorValue_T), intent(in), target :: SOURCE
      integer, intent(in) :: KEY
      logical, intent(in) :: IGNORETEMPLATE
      type (VectorValue_T), optional :: PTAN ! press. values

      ! Local variables
      real (r8), dimension(:), pointer :: oldSurfs, newSurfs
      real (r8), dimension(:,:), pointer :: newValues
      integer :: instance
      integer :: Me = -1              ! String index for trace
      logical :: mySurfs, myNewValues
      integer :: status
      logical :: verbose

      ! Executable code
      verbose = ( switchDetail(switches, 'fill') > 0 ) ! -Sfill1
      ! call Dump( source )
      call trace_begin ( me, 'FillUtils_1.FromInterpolatedQty', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( .not. ignoreTemplate ) then
        if ( .not. DoQtysDescribeSameThing ( qty, source ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'Mismatch in quantities' )
          go to 9
        end if
        if ( .not. doHGridsMatch ( qty, source ) .and. .not. present(ptan) ) then
          call Announce_Error ( key, no_error_code, &
            & 'Mismatch in horizontal grid' )
          go to 9
        end if
        if ( qty%template%noInstances /= source%template%noInstances ) then
          call Announce_Error ( key, no_error_code, &
            & 'Mismatch in num of instances' )
          go to 9
        end if
        if ( .not. doFGridsMatch ( qty, source )  .and. .not. present(ptan) ) then
          call Announce_Error ( key, no_error_code, &
            & 'Mismatch in frequency grid' )
          go to 9
        end if
      end if
      if ( associated( source%BinNumber ) ) then
        allocate( qty%BinNumber(source%template%NoInstances) )
        qty%BinNumber = source%BinNumber
      elseif ( verbose ) then
        call output( 'source%BinNumber not allocated', advance='yes' )
      endif
      if ( associated( source%MAF ) ) then
        allocate( qty%MAF(source%template%NoInstances) )
        qty%MAF = source%MAF
      elseif ( verbose ) then
        call output( 'source%MAF not allocated', advance='yes' )
      endif

      ! Two cases here, one where we have to interpolate vertically (has to be
      ! single channel quantity).  The other where we don't.  Most of the latter
      ! cases can be handled by the code that calls this routine.  The exception
      ! is when we've used the force option to e.g. copy one band into another.
      if ( .not. doVGridsMatch ( qty, source ) ) then
        ! This quantity needs vertical interpolation
        ! These checks are for cases the code can't (yet) handle,
        ! may add this functionality later.
        if ( present(ptan) ) then
          ! Very (too?) forgiving
        else if ( qty%template%noChans /= 1) then
          call Announce_Error ( key, no_error_code, &
            & 'Code cannot (yet?) interpolate multi channel quantities' )
          go to 9
        else if ( .not. all ( (/ qty%template%coherent, source%template%coherent /) ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'Code cannot (yet?) interpolate incoherent quantities' )
          go to 9
        end if

        ! Work out vertical coordinate issues
        if ( present(ptan) ) then
          oldSurfs => source%template%surfs ( :, 1 )
          newSurfs => ptan%values ( :, 1 )
          mySurfs = .false.
        else if ( qty%template%verticalCoordinate == l_pressure ) then
          nullify ( oldSurfs, newSurfs )
          call Allocate_test ( oldSurfs, source%template%noSurfs, 'oldSurfs', ModuleName )
          call Allocate_test ( newSurfs, qty%template%noSurfs, 'newSurfs', ModuleName )
          oldSurfs = -log10 ( source%template%surfs(:,1) )
          newSurfs = -log10 ( qty%template%surfs(:,1) )
          mySurfs = .true.
        else
          oldSurfs => source%template%surfs ( :, 1 )
          newSurfs => qty%template%surfs ( :, 1 )
          mySurfs = .false.
        end if

        ! Work out if we have to obey the Mask
        myNewValues = .false.
        if ( associated ( qty%Mask ) ) &
          & myNewValues = any ( iand ( ichar(qty%Mask(:,:)), m_fill ) /= 0 )
        if ( myNewValues ) then
          nullify ( newValues )
          call Allocate_test ( newValues, qty%template%instanceLen, &
            & qty%template%noInstances, 'myNewValues', ModuleName )
        else
          newValues => qty%values
        end if

        ! OK, do the work
        if ( qty%template%logBasis ) then
          ! Whyd did you ever want to print this?
          if ( any( (/ source%values <= 0. /) ) .and. verbose ) then
            call MLSMessage( MLSMSG_Warning, ModuleName, &
              & 'log basis source values <= 0 in FromInterpolateQty', &
              & status=status )
            if ( status == 0 ) then
              call dump( qty%template )
              call dump( source%template )
            end if
          end if
          call InterpolateValues ( &
            & oldSurfs, log ( max ( source%values, sqrt(tiny(0.0_r8)) ) ), &
            & newSurfs, newValues, &
            & method='Linear', extrapolate='Constant' )
          newValues = exp ( newValues )
        else if( source%template%noInstances /= qty%template%noInstances ) then
          ! You have elected to interpolate when you have different numbers
          ! of horizontal instances.
          ! The only reasonable thing is to assume homogeneity of source.
          if ( present(ptan) ) then
            if ( source%template%coherent .and. qty%template%minorFrame ) then
              if ( source%template%noChans > 1 .or. &
                 & qty%template%noChans > 1 ) then
                call Announce_Error ( key, no_error_code, &
                  & 'Cannot interpolate regular-to-irregular with more than one channel' )
                go to 9
              end if
              if ( .not. associated(qty%values) ) &
                & call createVectorValue ( qty, 'qty', moduleName )
              call interpolate_regular_to_irregular ( &
                & source%template%phi(:,1), oldSurfs, source%values, &
                & qty%template%phi, ptan%values, qty%values )
            else
              ! If newSurfs is ptan, we can interpolate from the first column
              ! of source separately to each profile/MAF of qty.
              do instance=1, qty%template%noInstances
                call InterpolateValues ( &
                  & oldSurfs, source%values(:,1), &
                  & ptan%values(:,instance), newValues(:,instance), &
                  & method='Linear', extrapolate='Constant' )
              end do
            end if
          else
            ! Otherwise, all we can do is interpolate the first column and
            ! spread it.
            call InterpolateValues ( &
              & oldSurfs, source%values(:,1), &
              & newSurfs, newValues(:,1), &
              & method='Linear', extrapolate='Constant' )
            do instance=2, qty%template%noInstances
              newValues(:,instance) = newValues(:,1)
            end do
          end if
        else
          call InterpolateValues ( &
            & oldSurfs, source%values, &
            & newSurfs, newValues, &
            & method='Linear', extrapolate='Constant' )
        end if

        if ( myNewValues ) then
          where ( iand ( ichar(qty%Mask(:,:)),m_fill) == 0 )
            qty%values = newValues
          end where
          call Deallocate_test ( newValues, 'myNewValues', ModuleName )
        end if

        ! Tidy up
        if ( mySurfs ) then
          call Deallocate_test ( oldSurfs, 'oldSurfs', ModuleName )
          call Deallocate_test ( newSurfs, 'newSurfs', ModuleName )
        end if
      else ! ------------------------
        ! No interpolation needed, more like the
        ! case handled in the calling code, except we're more lenient
        ! If we have a Mask and we're going to obey it then do so

        ! There was a bug without consequences as originally coded:
        ! "qty" below was "quantity" while "source" was "sourceQuantity"
        ! As this subroutine was then an internal procedure to MLSL2Fill,
        ! and the formal args in the call were "Quantity" and "sourceQuantity"
        ! the correct items were actually being referred to
        if ( associated(qty%Mask) ) then
          where ( iand ( ichar(qty%Mask(:,:)), m_Fill ) == 0 )
            qty%values(:,:) = source%values(:,:)
          end where
        else ! Otherwise, just blindly copy
          qty%values = source%values
        end if
      end if
    9 call trace_end ( 'FillUtils_1.FromInterpolatedQty', &
        & cond=toggle(gen) .and. levels(gen) > 1  )

    end subroutine FromInterpolatedQty

    !=============================== FromLosGrid ====
    subroutine FromLosGrid ( key, Qty, LOS, &
      & Ptan, Re, noFineGrid, extinction, errorCode )

      ! This is to fill a L2GP type of quantity with a los grid type of quantity.
      ! The los quantity is a vector quantity that has dimension of (s, mif, maf),
      ! where s is the path along los.

      ! Linear interpolation is used to fill L2GP grids and unfilled grids are
      ! marked with the baddata flag (-999.)

      ! Dummy arguments
      integer, intent(in) :: key          ! For messages
      type (VectorValue_T), intent(in) :: LOS ! Vector quantity to fill from
      type (VectorValue_T), intent(in) :: Ptan ! tangent pressure
      type (VectorValue_T), intent(in) :: Re ! Earth's radius
      type (VectorValue_T), intent(inout) :: QTY ! Quantity to fill
      integer, intent(in) :: noFineGrid   ! make finer sGrid with this number
      logical, intent(in) :: extinction  ! Flag for extinction fill and calculation
      integer, intent(out) :: errorCode ! Error code

      ! Local variables
      integer :: i, j, maf, mif                ! Loop counter
      integer :: maxZ, minZ                    ! pressure range indices of sGrid
      integer :: Me = -1                       ! String index for trace
      integer :: noMAFs,noMIFs,noDepths
      integer, dimension(qty%template%noSurfs,qty%template%noInstances) :: cnt
      real (r8), dimension(qty%template%noSurfs,qty%template%noInstances) :: out
      real (r8), dimension(qty%template%noSurfs) :: outZeta, phi_out, beta_out
      real (r8), dimension(los%template%noChans) :: x_in, y_in, sLevel
      real (r8), dimension(los%template%noSurfs) :: zt
      real (r8), dimension(los%template%noChans*noFineGrid) :: betaFine, TransFine, SFine
      real (r8), dimension(los%template%noChans, &
        & los%template%noSurfs,los%template%noInstances) :: beta
      real (r8) :: ds, ColTrans

      call trace_begin ( me, 'FillUtils_1.FromLosGrid', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      errorCode=0

      ! Make sure this quantity is appropriate
      !    if ( .not. ValidateVectorQuantity(qty, coherent=.TRUE., stacked=.TRUE., &
      !      & verticalCoordinate= (/ l_pressure, l_zeta /) ) ) then
      !      call output ( " quantity vertical grid in FromLOSgrid is not valid")
      !    end if

      if ( qty%template%verticalCoordinate == l_pressure ) then
        outZeta = -log10 ( qty%template%surfs(:,1) )
      else
        outZeta = qty%template%surfs(:,1)
      end if

      noMAFs=los%template%noInstances
      noMIFs=los%template%noSurfs
      ! Now, we use frequency coordinate as sGrid along the path
      noDepths=los%template%noChans
      sLevel = los%template%frequencies

      ! the input losQty is the increment of cloud transmission function by default.
      ! it is converted to cloud extinction if extinction flag is on.
      if ( extinction ) then
        ! both sGrid and sFineGrid are expected to be evenly spaced at present
        ds = sLevel(2)-sLevel(1)
        do i=1,noDepths
          do j=1,noFineGrid
            Sfine(j+(i-1)*noFineGrid) = sLevel(i)+(j-1._r8)*ds/noFineGrid
          end do
        end do

        do maf=1,noMafs
          do mif=1,noMifs
            do i=1,noDepths
              ! convert increments to derivatives
              y_in(i) = los%values(i+(mif-1)*noDepths,maf)/ds
            end do
            call InterpolateValues(sLevel,y_in,sFine,TransFine,method='Linear')
            ! calculate column transmission function by integrating
            ! the derivatives on fine grid
            do i=1,noFineGrid*noDepths
              betaFine(i) = 0._r8
              colTrans=0._r8
              do j=1,i
                colTrans=colTrans + transFine(j)*ds/noFineGrid
              end do
              colTrans = 1._r8 - colTrans
              if ( colTrans > 0.02_r8) betaFine(i)= transFine(i)/colTrans
            end do
            ! interpolate betaFine back to the coarser sGrid
            call InterpolateValues(sFine,betaFine,sLevel,beta(:,mif,maf),method='Linear')

          end do
        end do

      else

        do maf=1,noMafs
          do mif=1,noMifs
            do i=1,noDepths
              beta(i,mif,maf)=los%values(i+(mif-1)*noDepths,maf)
            end do
          end do
        end do

      end if

      ! initialize quantity
      do j = 1, qty%template%noInstances
        do i = 1, qty%template%noSurfs
          qty%values(i,j)=qty%template%badValue
          cnt(i,j)=0
          out(i,j)=0._r8
        end do
      end do

      do maf=1,noMAFs
        zt = ptan%values(:,maf)   ! noChans=1 for ptan
        zt = (zt+3.)*16.                      ! converted to height in km
        do mif=1,noMIFs
          if ( ptan%values(mif,maf) .gt. -2.5) cycle ! for testing
          ! find altitude of each s grid
          x_in = sLevel**2/2./(re%values(1,maf)*0.001_r8 + zt(mif))
          ! converted to zeta
          x_in = x_in/16. + ptan%values(mif,maf)
          ! find minimum and maximum pressures indices in sGrid
          do i = 2,qty%template%noSurfs-1
            if ( ptan%values(mif,maf) < (outZeta(i)+outZeta(i+1))/2. .and. &
              & ptan%values(mif,maf) > (outZeta(i)+outZeta(i-1))/2.) &
              & minZ = i
          end do
          if ( ptan%values(mif,maf) < (outZeta(1)+outZeta(2))/2.) minZ=1
          if ( ptan%values(mif,maf) > outZeta(qty%template%noSurfs)) cycle ! goto next mif

          do i = 2,qty%template%noSurfs-1
            if ( x_in(noDepths) < (outZeta(i)+outZeta(i+1))/2. .and. &
              & x_in(noDepths) > (outZeta(i)+outZeta(i-1))/2.) &
              & maxZ = i
          end do
          if ( x_in(noDepths) < (outZeta(1)+outZeta(2))/2.) cycle    ! goto next mif
          if ( x_in(noDepths) > outZeta(qty%template%noSurfs)) maxZ=qty%template%noSurfs

          ! get phi along path for each mif ( phi is in degree)
          y_in = los%template%phi(mif,maf) &
            & - atan2(sLevel, (re%values(1,maf)*0.001_r8 + zt(mif)))*rad2deg
          ! interpolate phi onto standard vertical grids
          call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),phi_out(minZ:maxZ), &
            & method='Linear')
          ! interpolate quantity to standard vertical grids
          y_in = beta(:,mif,maf)
          call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),beta_out(minZ:maxZ), &
            & method='Linear')
          ! interpolate quantity to standard phi grids
          do i=minZ,maxZ
            do j = 2, qty%template%noInstances-1
              if ( phi_out(i) .lt. &
                & (qty%template%phi(1,j)+qty%template%phi(1,j+1))/2. &
                & .and. phi_out(i) .ge. &
                & (qty%template%phi(1,j-1)+qty%template%phi(1,j))/2. ) then
                out(i,j)=out(i,j) + beta_out(i)
                cnt(i,j)=cnt(i,j)+1       !  counter
              end if
            end do
          end do
        end do                            ! End surface loop
      end do                              ! End instance loop
      ! average all non-zero bins
      where (cnt > 0) qty%values = out/cnt
      call trace_end ( 'FillUtils_1.FromLosGrid', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine FromLosGrid

    ! -------------------------------------------  ByManipulation  -----
    ! Use the Manipulation field of the Fill statement to perform
    ! standard algebraic formulas plus
    ! selected functions, statistical operations, geolocations,
    ! and other miscellaneous but useful functions

    ! Most of the hard work has been moved to the manipulationUtils module
    subroutine ByManipulation ( quantity, a, b, &
      & manipulation, key, ignoreTemplate, &
      & spreadflag, dimList, &
      & c )
      use ManipulationUtils, only: MaxManipulationLen, Manipulate
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), pointer :: A
      type (VectorValue_T), pointer :: B
      real(rv), optional            :: C  ! constant "c" in manipulation
      integer, intent(in) :: MANIPULATION
      integer, intent(in) :: KEY        ! Tree node
      logical, intent(in) :: ignoreTemplate ! If set throw caution to the wind
      ! The following args are important only for statistical functions
      logical, intent(in) :: SPREADFLAG ! If set spread across summed dimension
      character(len=*), intent(in)    :: DIMLIST ! E.g., 's' to shift surfaces, not chans
      ! Local parameters

      logical, parameter :: autoRecognizeGeneralExp = .true.
      ! Local variables
      character (len=1) :: ABNAME
      type (VectorValue_T), pointer :: AORB
      real(rv) :: cc
      integer :: I
      logical :: MAPFUNCTION
      integer :: Me = -1   ! String index for trace
      integer :: NUMWAYS   ! 1 or 2
      character (len=MAXMANIPULATIONLEN) :: MSTR
      logical :: OKSOFAR
      logical :: StatisticalFunction
      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ByManipulation', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! Currently we have a rather brain dead approach to this, so
      ! check that what the user has asked for, we can supply.
      call get_string ( manipulation, mstr, strip=.true. )
      mstr = lowercase(mstr)

      StatisticalFunction = any( &
        & indexes( &
        &   mstr, &
        &   (/ 'count ', 'min   ', 'max   ', 'mean  ', 'median', 'rms   ', 'stddev' /) &
        &   ) &
        &  > 1 )
      MapFunction = ( index(mstr, 'map') > 0 )

      numWays = 2
      okSoFar = .true.
      do i = 1, numWays ! 2
        if ( i == 1 ) then
          if ( .not. associated(a) ) cycle
          aorb => a
          abName = 'a'
        else
          if ( .not. associated(b) ) cycle
          aorb => b
          abName = 'b'
        end if

        ! For minor frame quantities, check that we're on the same page
        if ( StatisticalFunction ) then
          ! We don't check for anything
        else if ( MapFunction ) then
          ! We don't check for anything
        else if ( .not. ignoreTemplate ) then
          if ( quantity%template%minorFrame ) then
            okSoFar = okSoFar .and. aorb%template%minorFrame .and. &
              & quantity%template%signal == aorb%template%signal .and. &
              & quantity%template%sideband == aorb%template%sideband .and. &
              & quantity%template%frequencyCoordinate == aorb%template%frequencyCoordinate
          else if ( mstr == 'a+b' .or. mstr == 'a-b' ) then
            ! For a+/-b these quantities must share a template
            okSoFar = okSoFar .and. quantity%template%name == aorb%template%name
          end if
        else
          okSoFar = okSoFar &
            & .and. &
            & ( &
            & spreadflag .or. &
            & quantity%template%noInstances == aorb%template%noInstances &
            & .and. quantity%template%instanceLen == aorb%template%instanceLen &
            & )
        end if

        if ( .not. okSoFar ) then
          call Announce_Error ( key, no_error_code, &
            & abName // ' is not of the same (or close enough) type as quantity' )
          go to 9
        end if
      end do

      select case ( mstr )
      case ( 'a|b' )
        ! At some point we must treat this '|' operator more generally, like '+', ..
        if ( .not. associated ( quantity%Mask ) ) then
          quantity%values = ior ( nint(a%values), nint(b%values) )
        else
          where ( iand ( ichar(quantity%Mask(:,:)), m_fill ) == 0 )
            quantity%values = ior ( nint(a%values), nint(b%values) )
          end where
        end if
      case default
        ! This should be one of the cases which use the constant "c"
        if ( .not. present(c) ) then
          if ( autoRecognizeGeneralExp ) then
            cc = 0._rv
          else
            ! How did we get here?
            call Announce_Error ( key, no_error_code, &
              & 'trim(mstr) manipulation but no c supplied' )
            go to 9
          end if
        else
          cc = c
        end if
        call Manipulate( quantity, a, b, cc, mstr, &
          & spreadflag, dimList )
      end select
    9 call trace_end ( 'FillUtils_1.ByManipulation', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine ByManipulation

    ! --------------------------------------------------  FromL1B  -----
    ! Fills a quantity that is stored as a dataset in either the
    ! l1boa file (lat, lons, etc.)
    ! l1brad file (radiances, radiance precisions, etc.)
    ! Optionally supply PrecisionQuantity when reading a radiance
    ! so that we Mask radiances where the corresponding precisions
    ! are negative or Masked themselves

    ! Naming conventions:
    ! l1boa datasets are named differently depending on hdfversion
    ! if 4, they are some way I have forgotten
    ! If 5, they are divided among 3 groups: GHz, THz, and spacecraft

    ! radiances are named the same independent of hdf version
    
    ! Due to the insistence by mlsl2 in getting the module name from the
    ! string table, which perversely stores 'sc' as 'SC', we must resort
    ! to the inelegancies typified by
    !   if ( NameString == 'SC' ) NameString = 'sc'
    
    subroutine FromL1B ( Root, Quantity, Chunk, FileDatabase, &
      & IsPrecision, Suffix, Geolocation, PrecisionQuantity, BOMask, sdName )
      use BitStuff, only: NegativeIfBitPatternSet
      use Init_Tables_Module, only: L_ECR, L_geocentric, L_geodetic, L_none
      integer, intent(in)                        :: Root
      type (VectorValue_T), intent(inout)        :: Quantity
      type (MLSChunk_T), intent(in)              :: Chunk
      type (MLSFile_T), dimension(:), pointer    :: FileDatabase
      logical, intent(in)                        :: IsPrecision
      integer, intent(in)                        :: Suffix
      integer, intent(in)                        :: Geolocation
      type (VectorValue_T), intent(in), optional :: PrecisionQuantity
      integer, intent(in), optional              :: BOMask ! A pattern of bits--
                                              ! set prec. neg. if matched
                                   
      character(len=256), intent(in), optional :: sdname
      ! Local variables
      integer                   :: BO_error
      type (L1BData_T)          :: BO_stat
      integer                   :: Channel
      integer                   :: Found
      logical                   :: Goofy ! MIF_TAI is goofy in HDF4
      character (len=132)       :: ModuleNameString
      character (len=132)       :: NameString
      integer                   :: Flag, NoMAFS, MaxMIFs
      type (L1BData_T)          :: L1BData
      type (MLSFile_T), pointer :: L1BFile
      type (MLSFile_T), pointer :: L1BOAFile
      integer                   :: Column
      integer                   :: Me = -1 ! String index for trace
      integer                   :: MyBOMask
      integer                   :: NG ! geolocations = noSurfs * noCrossTrack =
                                      ! instanceLen / noChans
      integer                   :: Row

      type :: Finder_t ! to find the quantity name and module name
        integer :: QtyType     ! L_...
        character(15) :: Name  ! Special case (signal) if *SIGNAL*
        character(2) :: Module ! Use GetModuleName if blank; 4 if HDF4 is goofy
        logical :: Tngt        ! IsTngtQty argument for AssembleL1BQtyName
      end type Finder_t

      type(finder_t), parameter :: Finder(19) = [ &
                   ! QtyType              Name       Module  Tngt
        & finder_t ( l_ECRtoFOV,         'ECRtoFOV',  '  ', .true.  ), &
        & finder_t ( l_GHzAzim,          'azimAngle', '  ', .true.  ), &
        & finder_t ( l_L1BMAFBaseline,   '*SIGNAL*',  '  ', .false. ), &
        & finder_t ( l_l1bMIF_TAI,       'MIF_TAI',   '4 ', .false. ), &
        & finder_t ( l_LosVel,           'LosVel',    '  ', .true.  ), &
        & finder_t ( l_orbitInclination, 'OrbIncl',   '  ', .false. ), &
        & finder_t ( l_ptan,             'ptan',      '  ', .false. ), &
        & finder_t ( l_radiance,         '*SIGNAL*',  '  ', .false. ), &
        & finder_t ( l_scECI,            'ECI',       'sc', .false. ), &
        & finder_t ( l_scECR,            'ECR',       'sc', .false. ), &
        & finder_t ( l_instECR,          'ECR',       '  ', .false. ), &
        & finder_t ( l_scGeocAlt,        'GeocAlt',   'sc', .false. ), &
        & finder_t ( l_scVelECI,         'VelECI',    'sc', .false. ), &
        & finder_t ( l_scVelECR,         'VelECR',    'sc', .false. ), &
        & finder_t ( l_tngtECI,          'ECI',       '  ', .true.  ), &
        & finder_t ( l_tngtECR,          'ECR',       '  ', .true.  ), &
        & finder_t ( l_tngtGeocAlt,      'GeocAlt',   '  ', .true.  ), &
        & finder_t ( l_tngtGeodAlt,      'GeodAlt',   '  ', .true.  ), &
        & finder_t ( l_tngtGeodLat,      'GeodLat',   '  ', .true.  )  &
        & ]

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FromL1B', root, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      myBOMask = 0
      if ( present(BOMask) ) myBOMask = BOMask
      ! print *, 'Filling vector quantity from l1b'
      ! L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      L1BOAFile => GetMLSFileByType(filedatabase, content='l1boa')
      ! fileID = L1BFile%FileID%f_id

      goofy = .false.
      do found = 1, size(finder)
        if ( quantity%template%quantityType == finder(found)%qtyType ) then
          moduleNameString = ''
          nameString = finder(found)%name
          if ( finder(found)%name == '*SIGNAL*' ) then
            call GetSignalName ( quantity%template%signal, nameString, &
              & sideband=quantity%template%sideband, noChannels=.TRUE. )
          else if ( finder(found)%module == '4 ' ) then
            goofy = L1BOAFile%HDFVersion /= HDFVERSION_5
            if ( .not. goofy ) &
              & call GetModuleName ( quantity%template%instrumentModule, &
                & moduleNameString )
            ! else Goofy in HDF4 files -- no sc, no tp, no GHz....
          else if ( finder(found)%module /= '  ' ) then
            moduleNameString = finder(found)%module
          else
            call GetModuleName ( quantity%template%instrumentModule, &
                               & moduleNameString )
          end if
          if ( moduleNameString == 'SC' ) moduleNameString = 'sc'
          ! print *, 'namestring: ', trim(nameString)
          ! print *, 'module namestring: ', trim(moduleNameString)
          nameString = AssembleL1BQtyName ( trim(nameString), &
                     & L1BOAFile%HDFVersion, &
                     & finder(found)%tngt, trim(moduleNameString) )
          exit
        end if
      end do
      if ( found > size(finder) ) call Announce_Error ( root, cantFromL1B )

      ! Perhaps will need to read bright object status from l1bOA file
      if ( isPrecision .and. myBOMask /= 0 ) then
        call GetModuleName ( quantity%template%instrumentModule, moduleNameString )
        moduleNameString = AssembleL1BQtyName('BO_stat', L1BOAFile%HDFVersion, .TRUE., &
          & trim(moduleNameString))
          ! print *, 'Precision namestring: ', trim(nameString)
          ! print *, 'module namestring: ', trim(moduleNameString)
        call ReadL1BData ( L1BOAFile, moduleNameString, BO_stat, noMAFs, &
          & flag=BO_error, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail= .true., &
          & dontPad=DONTPAD )
      end if

      ! Possibly modify namestring based on whether a suffix field was supplied
      ! or a /isPrecision switch was set

      if ( suffix /= 0 ) then
        call Get_String ( suffix, &
          & nameString(len_trim(nameString)+1:), strip=.true. )
      else if ( isPrecision ) then
        nameString = trim(nameString) // PRECISIONSUFFIX
      end if

      L1BFile => GetL1bFile(filedatabase, namestring)
      if (associated(L1BFile)) then
        call ReadL1BData ( L1BFile, nameString, L1BData, noMAFs, flag, &
          & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail= .false., &
          & dontPad=DONTPAD )
      else
         flag = 1 ! Just a trick, so we reuse the printing of error message
      end if
      ! If it didn't exist in the not-a-radiance case, then we'll fail here.
      if ( flag /= 0 ) then
        if ( any(quantity%template%quantityType == &
          & (/ l_radiance, l_L1BMAFBaseline /) ) ) then
          ! This is the case where it's a radiance we're after and it's missing
          ! and we will allow this because we permit level 1 to omit certain
          ! bands when they are turned off
          quantity%values = DEFAULTUNDEFINEDVALUE ! -1.0
          do column=1, size(quantity%values(1,:))
            do row=1, size(quantity%values(:,1))
              call MaskVectorQty ( quantity, row, column, M_LinAlg )
            end do
          end do
        else if (.not. Aura_L1BFILES ) then
          ! This is the case where we're reading from level 1 files
          ! that aren't Aura files
          ! We'll allow but issue a warning
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Unable to find ' // trim(nameString) // ' in non-Aura file' )
        else
          call Announce_Error ( root, errorReadingL1B )
        end if
        go to 9
      end if
      if ( quantity%template%noInstances /= size ( L1BData%dpField, 3 ) .or. &
        &  quantity%template%instanceLen /= &
        &   size ( L1BData%dpField, 1 ) * size ( L1BData%dpField, 2 ) ) then
        call output ( 'Quantity shape: ' )
        call output ( quantity%template%instanceLen )
        call output ( quantity%template%noChans, before=' ( ' )
        call output ( quantity%template%noSurfs, before=', ' )
        call output ( quantity%template%noInstances, before=', ' )
        call output ( quantity%template%noCrossTrack, before=', ', &
          & after = ' )', advance='yes' )
        call output ( 'L1B shape: ( ' )
        call output ( size ( L1BData%dpField, 1 ) )
        call output ( size ( L1BData%dpField, 2 ), before=', ' )
        call output ( size ( L1BData%dpField, 3 ), before=', ', &
          & after = ' )', advance='yes' )
        call output ( 'Most likely a FORGE command clobbered the MIF Geolocation', &
          & advance='yes' )
        call Announce_Error ( root, no_error_code, 'L1B data is wrong shape' )
        go to 9
      end if

      if ( isPrecision .and. myBOMask /= 0 .and. BO_error == 0 ) then
        noMAFs = size(L1BData%dpField, 3)
        maxMIFs = L1BData%maxMIFs
        if ( BeVerbose( 'glob', 1 ) ) then ! e.g., 'glob1'
          call output ( 'Quantity shape:' )
          call output ( quantity%template%instanceLen )
          call output ( ' ( ' )
          call output ( quantity%template%noChans )
          call output ( ', ' )
          call output ( quantity%template%noSurfs )
          call output ( ' ), ' )
          call output ( quantity%template%noInstances, advance='yes' )
          call output ( 'L1B shape:' )
          call output ( size ( L1BData%dpField, 1 ) )
          call output ( ', ' )
          call output ( size ( L1BData%dpField, 2 ) )
          call output ( ', ' )
          call output ( size ( L1BData%dpField, 3 ), advance='yes' )
          call outputNamedValue( 'shape' // trim(namestring), shape(L1BData%dpField) )
          call outputNamedValue( 'shape(BO_stat)', shape(BO_stat%intField) )
          call outputNamedValue( 'noMAFs', noMAFs )
          call outputNamedValue( 'maxMIFs', maxMIFs )
          call outputNamedValue( 'noChans', quantity%template%noChans )
        end if
        if ( BeVerbose( 'glob', 2 ) ) then ! e.g., 'glob2'
          call dump( L1BData%dpField(1,:,:), '(Before applying bright object Mask)' )
        end if
        do channel = 1, quantity%template%noChans
        L1BData%dpField(channel,:,:) = &
          & NegativeIfBitPatternSet( L1BData%dpField(channel,:,:), &
          & BO_stat%intField(1, 1:maxMIFs, 1:noMAFs), myBOMask )
        end do
        if ( BeVerbose( 'glob', 2 ) ) &
          & call dump( L1BData%dpField(1,:,:), '(After applying bright object Mask)' )
        call DeallocateL1BData(BO_stat)
      end if

      quantity%values = RESHAPE(L1BData%dpField, &
        & (/ quantity%template%instanceLen, quantity%template%noInstances /) )
      if ( isPrecision ) then
        do column=1, size(quantity%values(1, :))
          do row=1, size(quantity%values(:, 1))
            if ( quantity%values(row, column) < 0.d0 ) &
              & call MaskVectorQty(quantity, row, column, M_LinAlg)
          end do
        end do
      else if ( present(precisionQuantity) ) then
        do column=1, size(quantity%values(1, :))
          do row=1, size(quantity%values(:, 1))
            if ( isVectorQtyMasked(precisionQuantity, row, column, M_LinAlg) ) &
              & call MaskVectorQty(quantity, row, column, M_LinAlg)
          end do
        end do
        do column=1, size(quantity%values(1, :))
          do row=1, size(quantity%values(:, 1))
            if ( precisionQuantity%values(row, column) < 0.d0 ) then
              call MaskVectorQty(quantity, row, column, M_Ignore)
              call MaskVectorQty(quantity, row, column, M_LinAlg)
            end if
          end do
        end do
      end if

      if ( geolocation == l_ECR ) then
        ng = quantity%template%noSurfs * quantity%template%noCrossTrack
        if ( .not. goofy ) & ! not MIF_TAI in HDF4
          & call GetModuleName( quantity%template%instrumentModule,nameString )
        if ( NameString == 'SC' ) NameString = 'sc'
        nameString = AssembleL1BQtyName('ECR', L1BOAFile%HDFVersion, &
          & .false., trim(nameString))
        call ReadL1BData ( L1BOAFile, nameString, L1BData, noMAFs, flag, &
          & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail=.false., dontPad=DONTPAD )
        ! Assume we don't usually have ECR, so create it
        call allocate_test ( quantity%template%ECR, 3, 1, ng, 'ECR', moduleName )
        quantity%template%ECR = RESHAPE(L1BData%dpField, &
        & (/ 3, ng, quantity%template%noInstances /) )
      else if ( geolocation /= l_none ) then
        ng = quantity%template%noSurfs * quantity%template%noCrossTrack
        select case ( geolocation )
        case ( l_geocentric )
          if ( .not. goofy ) & ! not MIF_TAI in HDF4
            & call GetModuleName( quantity%template%instrumentModule,nameString )
          if ( NameString == 'SC' ) NameString = 'sc'
          nameString = AssembleL1BQtyName('GeocLat', L1BOAFile%HDFVersion, &
            & .true., trim(nameString))
          call ReadL1BData ( L1BOAFile, nameString, L1BData, noMAFs, flag, &
            & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
            & NeverFail=.false., dontPad=DONTPAD )
          quantity%template%geodLat = RESHAPE(L1BData%dpField, &
            & (/ ng, quantity%template%noInstances /) )
          quantity%template%latitudeCoordinate = l_geocentric
        case ( l_geodetic )
          if ( .not. goofy ) & ! not MIF_TAI in HDF4
            & call GetModuleName( quantity%template%instrumentModule,nameString )
          if ( NameString == 'SC' ) NameString = 'sc'
          nameString = AssembleL1BQtyName('GeodLat', L1BOAFile%HDFVersion, &
            & .true., trim(nameString))
          ! print *, 'namestring: ', namestring
          ! stop
          call ReadL1BData ( L1BOAFile, nameString, L1BData, noMAFs, flag, &
            & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
            & NeverFail=.false., dontPad=DONTPAD )
          quantity%template%geodLat = RESHAPE(L1BData%dpField, &
            & (/ ng, quantity%template%noInstances /) )
          quantity%template%latitudeCoordinate = l_geodetic
        end select
        if ( .not. goofy ) & ! not MIF_TAI in HDF4
          & call GetModuleName( quantity%template%instrumentModule,nameString )
        if ( NameString == 'SC' ) NameString = 'sc'
        nameString = AssembleL1BQtyName('Lon', L1BOAFile%HDFVersion, &
            & .true., trim(nameString))
        call ReadL1BData ( L1BOAFile, nameString, L1BData, noMAFs, flag, &
          & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail=.false., dontPad=DONTPAD )
        quantity%template%Lon = RESHAPE(L1BData%dpField, &
        & (/ ng, quantity%template%noInstances /) )
      end if

      if ( BeVerbose( 'l1bfill', 0 ) ) call Dump( L1BData )
    9 call DeallocateL1BData(L1BData) ! Done by finalizer, but this can't hurt
      call trace_end ( 'FillUtils_1.FromL1B', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine FromL1B

    ! ------------------------------------------------  FromL2AUX  -----
    subroutine FromL2AUX ( qty, L2AUX, errorCode )
      type ( VectorValue_T), intent(inout) :: QTY
      type ( L2AUXData_T), intent(in) :: L2AUX
      integer, intent(inout) :: ERRORCODE
      ! Local variables
      integer :: FIRSTPROFILE
      integer :: LASTPROFILE
      integer :: Me = -1        ! String index for trace
      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FromL2AUX', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      errorCode = 0
      ! Work out which profile in the L2AUX this belongs to
      firstProfile = qty%template%instanceOffset - qty%template%noInstancesLowerOverlap
      lastProfile = firstProfile + qty%template%noInstances - 1
      ! In the case of minor/major frame quanties, while instanceOffset is
      ! Numbered from zero, as in L1B, our array starts from 1.
      if ( qty%template%minorFrame .or. qty%template%majorFrame ) then
        firstProfile = firstProfile + 1
        lastProfile = lastProfile + 1
      end if
      ! Check that the dimensions are appropriate
      if ( firstProfile < lbound ( L2AUX%values, 3 ) ) then
        errorCode = CantFromL2AUX
        go to 9
      end if
      if ( lastProfile > ubound ( L2AUX%values, 3 ) ) then
        errorCode = CantFromL2AUX
        go to 9
      end if
      if ( size ( L2AUX%values, 1 ) /= qty%template%noChans .or. &
        &  size ( L2AUX%values, 2 ) /= qty%template%noSurfs ) then
        errorCode = CantFromL2AUX
        go to 9
      end if
      ! Do the fill
      qty%values = reshape ( L2AUX%values ( :, :,  &
        & firstProfile : lastProfile ), &
        & (/ qty%template%instanceLen, qty%template%noInstances /) )
    9 call trace_end ( 'FillUtils_1.FromL2AUX', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine FromL2AUX

    ! ---------------------------------------  UsingMagneticModel  -----
    subroutine UsingMagneticModel ( Qty, Key, ScVelQuantity, GeocAltitudeQuantity, &
                                  & GPHQuantity, Regular, ReferenceMIF, &
                                  & ReferenceMIFunits )

      use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
      use Geometry, only: EarthRadA, GeodToECRm, GeocToECRu, XYZ_to_Geod
      use Hunt_m, only: Hunt
      use Intrinsic, only: L_Geodetic
      use Magnetic_Field_Quantity, only: Get_Magnetic_Field_Quantity
      use MLSMessageModule, only: MLSMSG_info
      use Monotone, only: Longest_Monotone_Subsequence
      use MoreMessage, only: MLSMessage
      use QuantityTemplates, only: QuantitiesAreCompatible, RT
      type (VectorValue_T), intent(inout) :: Qty
      integer, intent(in) :: Key
      type (VectorValue_T), intent(in), optional :: ScVelQuantity        ! MIF quantity
      type (VectorValue_T), intent(in), optional :: GeocAltitudeQuantity ! MIF quantity
      type (VectorValue_T), intent(in), optional :: GPHQuantity
      logical, intent(in), optional :: Regular ! coherent and stacked
      real(r8), intent(in), optional :: ReferenceMIF
      integer, intent(in), optional :: ReferenceMIFunits ! Dimless or height

      integer, allocatable :: Dec(:)  ! Decreasing sequence indices
      logical :: Error
      real(rt) :: Geod(3)             ! [lat radians, lon radians, ht meters]
      integer :: I
      integer, allocatable :: Inc(:)  ! Increasing sequence indices
      real(rt) :: MaxV, MinV          ! Max, Min of geocAltitudeQuantity's Surfs
      integer :: Me = -1              ! String index for trace
      integer :: ReferenceMIFnumber
      integer, allocatable :: Seq(:)  ! Increasing or decreasing
                                      ! sequence indices, => Inc or Dec
      real(rt), allocatable  :: Surfs(:) ! Either geocentric or geodetic
      real(rt) :: XYZ(3)              ! ECR for geocAltitudeQuantity%template
      logical :: verbose
      ! Executable code
      call trace_begin ( me, 'FillUtils_1.UsingMagneticModel', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! Check a bunch of stuff.
      error = .false.
      verbose = .true. ! beVerbose( 'what?', 1 )
      if ( present(referenceMIFunits) ) then ! Assume present(ReferenceMIF)
        if ( referenceMIFunits == phyq_length ) then
          if ( present(geocAltitudeQuantity) ) then
            call allocate_test ( surfs, geocAltitudeQuantity%template%noSurfs, 'Surfs', moduleName )
            if ( referenceMIF < 0.5 * EarthRadA .and. &
               & geocAltitudeQuantity%template%verticalCoordinate /= l_geodAltitude ) then
              ! referenceMIF is assumed to be geodetic height.  Convert
              ! geocAltitudeQuantity%template%surfs to geodetic height.
              do i = 1, geocAltitudeQuantity%template%noSurfs
                ! Convert [lat, lon, ht] to ECR in meters
                if ( geocAltitudeQuantity%template%latitudeCoordinate == l_geodetic ) then
                  ! geodetic altitude, geodetic latitude.
                  ! GeodToECRm makes an ECR vector in meters here.
                  xyz = geodToECRm ( [ geocAltitudeQuantity%template%geodLat(i,1), &
                                     & geocAltitudeQuantity%template%lon(i,1), &
                                     & geocAltitudeQuantity%template%surfs(i,1) ] )
                else ! geodetic altitude, geocentric latitude (weird)
                  ! Convert [lat, lon] to unit ECR, then ECR * ht to meters.
                  ! GeocToECRu makes an ECR unit vector.
                  xyz = geocToECRu ( geocAltitudeQuantity%template%geodLat(i,1), &
                                   & geocAltitudeQuantity%template%lon(i,1) ) * &
                                   & geocAltitudeQuantity%template%surfs(i,1)
                end if
                ! Convert ECR to [geod lat, lon, geod ht]
                geod = xyz_to_geod ( xyz )
                surfs(i) = geod(3) ! Geodetic altitude
              end do
            else
              call MLSMessage ( MLSMSG_Info, moduleName, &
                & 'ReferenceMIF = %R is greater than half the Earth radius ' // &
                & '= %R and is therefore assumed to be geocentric height.', &
                & datum = [ referenceMIF, 0.5 * EarthRadA ] )
              surfs(:) = geocAltitudeQuantity%template%surfs(:,1)
            end if
            ! Use only the monotone part of the tangent-point altitudes
            call longest_monotone_subsequence ( surfs, inc )
            call longest_monotone_subsequence ( surfs, dec, -1 )
            if ( size(inc) >= size(dec) ) then
              call move_alloc ( inc, seq )
              deallocate ( dec )
            else
              call move_alloc ( dec, seq )
              deallocate ( inc )
            end if
            ! Find the MIF with the desired altitude
            call hunt ( surfs(seq), referenceMIF, referenceMIFnumber )
            maxv = maxval(surfs(seq))
            minv = minval(surfs(seq))
            if ( switchDetail ( switches, 'plane' ) > 1 ) then
              call output ( seq(referenceMIFnumber), &
                & before='Height at reference MIF number ' )
              call output ( surfs(seq(referenceMIFnumber)), before=' = ' )
              call output ( referenceMIF, before=' chosen using height ' )
              call output ( minv, before=' from range ' )
              call output ( maxv, before=' ... ', advance='yes' )
            else if ( verbose ) then
              call outputNamedValue ( 'Reference MIF number', referenceMIFnumber )
            end if
            referenceMIFnumber = seq(referenceMIFnumber)
            if ( minv - referenceMIF > 2.0 * ( maxv - minv ) .or. &
               & referenceMIF - maxv > 2.0 * ( maxv - minv ) ) &
              call MLSMessage ( MLSMSG_Warning, moduleName, &
                & 'ReferenceMIF = %R is far outside the range %R ... %R of the ' // &
                & 'vertical coordinate of the tangent point geocentric height; ' // &
                & 'did you mean it to be an unitless MIF number?', &
                & datum = [ referenceMIF, minv, maxv ] )
            deallocate ( seq )
            call deallocate_test ( surfs, 'Surfs', moduleName )
          else
            call Announce_Error ( key, no_error_code, &
              & 'Reference MIF for magnetic field is height but geocentric ' // &
              & 'altitude quantity is not provided' )
            error = .true.
          end if
        else if ( referenceMIFunits == phyq_dimensionless ) then
          referenceMIFnumber = nint(referenceMIF)
          if ( verbose ) call outputNamedValue ( 'Reference MIF number', referenceMIFnumber )
        else ! neither dimensionless or height
          call Announce_Error ( key, no_error_code, &
            & 'Reference MIF for magnetic field is not unitless or height' )
            error = .true.
        end if
      else if ( present(geocAltitudeQuantity) ) then
        referenceMIFnumber = geocAltitudeQuantity%template%noSurfs / 2
      else if ( present(scVelQuantity) ) then
        referenceMIFnumber = scVelQuantity%template%noSurfs / 2
      else ! GPHQuantity is not a minor frame quantity; can't get referenceMIFnumber
        referenceMIFnumber = 1
      end if
      if ( .not. ValidateVectorQuantity ( qty, quantityType=(/l_magneticField/), &
        & frequencyCoordinate=(/ l_xyz /) ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Magnetic field quantity does not describe magnetic field' )
        error = .true.
      end if
      if ( qty%template%verticalCoordinate /= l_geocAltitude .and. &
         & qty%template%verticalCoordinate /= l_geodAltitude .and. &
         & qty%template%verticalCoordinate /= l_zeta ) then
        call Announce_Error ( key, no_error_code, &
          & 'Magnetic field vertical coordinate is not geocentric ' // &
          & 'or geodetic altitude, or zeta' )
        error = .true.
      end if
      if ( present(regular) ) then
        if ( regular .and. qty%template%verticalCoordinate == l_geocAltitude ) then
          call Announce_Error ( key, no_error_code, &
            & 'Regular magnetic field cannot have geocentric altitude vertical ' // &
            & 'coordinate because the forward model wants a geodetic coordinate' )
          error = .true.
        end if
      end if
      if ( qty%template%verticalCoordinate == l_zeta ) then
        if ( .not. present(GPHQuantity) ) then
          call Announce_Error ( key, no_error_code, &
            & 'GPH quantity is required if magnetic field vertical ' // &
            & 'coordinate is zeta' )
          error = .true.
        end if
        if ( present(geocAltitudeQuantity) ) then
          call Announce_Error ( key, no_error_code, &
            & 'Cross-track viewing and zeta magnetic field vertical ' // &
            & 'coordinate are incompatible' )
          error = .true.
        end if
      end if
      if ( present(scVelQuantity) ) then
        if ( .not. ValidateVectorQuantity ( scVelQuantity, &
             & quantityType=(/l_scVelECR/), frequencyCoordinate=(/ l_xyz /) ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'scVelQuantity quantity does not describe spacecraft velocity in ECR' )
          error = .true.
        end if
      end if
      if ( present(geocAltitudeQuantity) ) then
        if ( .not. ValidateVectorQuantity ( geocAltitudeQuantity, &
             & quantityType=(/l_tngtgeocAlt/), frequencyCoordinate=(/ l_none /), &
             & verticalCoordinate=(/l_geocAltitude/) ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'GeocAltitude quantity does not describe geocentric altitude' )
          error = .true.
        end if
        if ( geocAltitudeQuantity%template%noInstances /= qty%template%noInstances ) then
          call Announce_Error ( key, no_error_code, &
            & 'GeocAltitude quantity and magnetic field quantity have ' // &
            & 'different numbers of instances' )
          error = .true.
        end if
      end if
      if ( present(GPHQuantity) ) then
        if ( .not. ValidateVectorQuantity ( GPHQuantity, &
             & quantityType=(/l_GPH/) ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'GPH quantity does not describe geopotential height' )
          error = .true.
        end if
      end if
      if ( present(scVelQuantity) .neqv. present(geocAltitudeQuantity) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Only one of spacecraft velocity or geocentric altitude quantity ' // &
          & 'is specified; both are needed.' )
        error = .true.
      end if
      if ( present(scVelQuantity) .and. present(geocAltitudeQuantity) ) then
        if ( .not. quantitiesAreCompatible ( scVelQuantity%template, geocAltitudeQuantity%template, &
                   & differentTypeOK=.true., differentChansOK=.true. ) ) then
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & "Spacecraft velocity and tangent altitude quantities are not " // &
            & "compatible" )
          error = .true.
        end if
      end if
      if ( associated(qty%template%crossAngles) ) then
        if ( any( qty%template%crossAngles /= 0.0 ) ) then
          ! Magnetic field is in a viewing plane that is not the orbit plane
          if ( .not. present(scVelQuantity) .or. &
             & .not. present(geocAltitudeQuantity) ) then
            call Announce_Error ( key, no_error_code, &
              & 'Magnetic field has cross angles but spacecraft velocity ' // &
              & 'or tangent geocentric height quantity is not provided' )
            error = .true.
          end if
          if ( qty%template%stacked .and. &
             & qty%template%verticalCoordinate == l_geocAltitude ) then
            ! Geocentric altitude gets converted to geodetic altitude
            ! which is different for every latitude, and therefore not
            ! stacked.
            call MLSMessage ( MLSMSG_Error, moduleName, &
              & "Cross-track magnetic field quantity with geocentric " // &
              & "altitude vertical coordinate cannot be stacked" )
            error = .true.
          end if
        end if
      end if

      if ( .not. error ) call get_Magnetic_Field_Quantity ( qty, &
        & scVelQuantity, geocAltitudeQuantity, GPHQuantity, regular, &
        & referenceMIFNumber )

      call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine UsingMagneticModel

    ! --------------------------------------  Hydrostatically_GPH  -----
    subroutine Hydrostatically_GPH ( key, quantity, &
      & temperatureQuantity, refGPHQuantity )
      use ManipulateVectorQuantities, only: DoHGridsMatch, DoVGridsMatch
      ! Fill GPH hydrostatically
      integer, intent(in) :: key          ! For messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: TEMPERATUREQUANTITY
      type (VectorValue_T), intent(in) :: REFGPHQUANTITY

      ! Local variables
      integer :: Me = -1                ! String index for trace

      ! Executable code

      call trace_begin ( me, 'FillUtils_1.Hydrostatically_GPH', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      select case ( quantity%template%quantityType )
      case ( l_GPH )
        if ( doHGridsMatch ( quantity, temperatureQuantity ) .and. &
           & doVGridsMatch ( quantity, temperatureQuantity ) ) then
          call GetBasisGPH ( temperatureQuantity, refGPHQuantity, quantity%values )
        else
          call Announce_Error ( key, nonConformingHydrostatic )
        end if
      case default
        call Announce_Error ( 0, no_error_code, &
          & 'Trying to use Hydrostatic_GPH for non-GPH quantity' )
      end select

      call trace_end ( 'FillUtils_1.Hydrostatically_GPH', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine Hydrostatically_GPH

    ! -------------------------------------  Hydrostatically_PTan  -----
    subroutine Hydrostatically_PTan ( key, quantity, &
      & temperatureQuantity, refGPHQuantity, H2OQuantity, &
      & orbitInclinationQuantity, phiTanQuantity, geocAltitudeQuantity, &
      & maxIterations, phiWindow, phiWindowUnits, chunkNo )
      use ManipulateVectorQuantities, only: DoHGridsMatch, &
        & findClosestInstances
      ! Fill PTan quantity hydrostatically
      integer, intent(in) :: key          ! For messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: TEMPERATUREQUANTITY
      type (VectorValue_T), intent(in) :: REFGPHQUANTITY
      type (VectorValue_T), pointer :: H2OQUANTITY
      type (VectorValue_T), pointer :: ORBITINCLINATIONQUANTITY
      type (VectorValue_T), pointer :: PHITANQUANTITY
      type (VectorValue_T), pointer :: GEOCALTITUDEQUANTITY
      integer, intent(in) :: MaxIterations
      real(r8), intent(in) :: PhiWindow(2)
      integer, intent(in) :: PhiWindowUnits
      integer, intent(in), optional :: chunkNo
      ! H2OQuantity and GeocAltitudeQuantity have to be pointers
      ! as they may be absent.

      ! Local variables
      integer, dimension(:), pointer :: CLOSESTTEMPPROFILES
      integer :: Me = -1                ! String index for trace
      logical :: verbose

      ! Executable code
      verbose = ( BeVerbose( 'fill', -1 ) )

      call trace_begin ( me, 'FillUtils_1.Hydrostatically_PTan', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      select case ( quantity%template%quantityType )
      case ( l_ptan )
        if ( .not. ( doHGridsMatch ( refGPHquantity, temperatureQuantity ) &
           &   .and. doHGridsMatch ( H2OQuantity, temperatureQuantity ) ) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_ptan failed first test" )
          go to 9
        end if
        if ( (.not. ValidateVectorQuantity(quantity, minorFrame=.true.) ) .or. &
          &  (.not. ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ) .or. &
          &  (quantity%template%instrumentModule /= &
          &   geocAltitudeQuantity%template%instrumentModule) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_ptan failed third test" )
           call output('ValidateVectorQuantity(quantity, minorFrame=.true.) ')
           call blanks(3)
           call output( &
           & ValidateVectorQuantity(quantity, minorFrame=.true., sayWhyNot=.true.), &
           & advance='yes')

           call output('ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ')
           call blanks(3)
           call output( &
           & ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true., sayWhyNot=.true.), &
           & advance='yes')

           call output('quantity%template%instrumentModule ')
           call blanks(3)
           call output( &
           & quantity%template%instrumentModule, &
           & advance='yes')

           call output('geocAltitudeQuantity%template%instrumentModule ')
           call blanks(3)
           call output( &
           & geocAltitudeQuantity%template%instrumentModule, &
           & advance='yes')
           go to 9
        end if
        call Get2DHydrostaticTangentPressure ( quantity, temperatureQuantity,&
          & refGPHQuantity, H2OQuantity, orbitInclinationQuantity, &
          & phiTanQuantity, geocAltitudeQuantity, maxIterations, &
          & phiWindow, phiWindowUnits, chunkNo )
      case default
        call Announce_Error ( 0, no_error_code, &
          & 'Trying to use Hydrostatic_PTan for non-PTan quantity' )
        go to 9
      end select

      if ( verbose .and. associated(phitanquantity) ) then
        nullify( closestTempProfiles )
        call Allocate_Test ( closestTempProfiles, phitanquantity%template%noInstances, &
          "closestTempProfiles", ModuleName )
        call FindClosestInstances ( temperatureQuantity, phitanquantity, &
          & closestTempProfiles )
        call Deallocate_Test ( closestTempProfiles, "closestTempProfiles", ModuleName )
      end if

    9 call trace_end ( 'FillUtils_1.Hydrostatically_PTan', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine Hydrostatically_PTan

    ! ----------------------------------------------  FromIsotope  -----
    subroutine FromIsotope ( Quantity, SourceQuantity, RatioQuantity )
      ! This routine fills one vector from another, given an appropriate
      ! isotope ratio.

      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY ! Quantity to take vmr from
      type (VectorValue_T), intent(in) :: RATIOQUANTITY ! Isotope ratio information

      ! Local variables
      real (r8) :: FACTOR                 ! Multiplier to apply to sourceQuantity
      integer :: Me = -1                  ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FromIsotope', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/ l_vmr /), frequencyCoordinate=(/ l_none /) ) ) &
        &   call MLSMessage ( MLSMSG_Error, ModuleName, &
        &      "Inappropriate quantity for isotope fill")

      if ( .not. ValidateVectorQuantity ( sourceQuantity, &
        & quantityType=(/ l_vmr /), frequencyCoordinate=(/ l_none /) ) ) &
        &   call MLSMessage ( MLSMSG_Error, ModuleName, &
        &      "Inappropriate source quantity for isotope fill")

      if ( .not. ValidateVectorQuantity ( ratioQuantity, &
        & quantityType=(/ l_isotopeRatio /), frequencyCoordinate=(/ l_none /), &
        & noInstances=(/1/), noSurfs=(/1/) ) ) &
        &   call MLSMessage ( MLSMSG_Error, ModuleName, &
        &     "Inappropriate form/quantity for isotope ratio")


      if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) .or. &
        &  .not. DoVGridsMatch ( quantity, sourceQuantity ) ) &
        &    call MLSMessage ( MLSMSG_Error, ModuleName, &
        &      "Quantity and source quantity don't match for isotope fill" )

      if ( quantity%template%molecule == sourceQuantity%template%molecule ) &
        & call MLSMessage( MLSMSG_Error, ModuleName, &
        &   "Source and quantity both describe same molecule in isotope fill")

      if ( ratioQuantity%template%molecule == quantity%template%molecule ) then
        ! Going from parent to isotope
        factor = ratioQuantity%values(1,1)
      else if ( ratioQuantity%template%molecule == sourceQuantity%template%molecule ) then
        ! Going from isotope to parent
        factor = 1.0/ratioQuantity%values(1,1)
      else
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Unable to understand isotope fill" )
      end if

      quantity%values = sourceQuantity%values * factor
      call trace_end ( 'FillUtils_1.FromIsotope', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine FromIsotope

    ! --------------------------------------------- Scatter ---
    ! The equally-most barbaric of Fill methods:
    ! Go through the source quantity's values, Scattering
    ! them into the quantity's values
    ! according to the start, stride, block, and count arrays
    ! No checking is done

    ! (See also Gather)
    ! See the hdf5 introduction to HDF5 description of the hyperslab
    ! for a discussion of what we mean
    ! Let the following diagram serve as a mnemonic
    !         n2 ->
    ! o x x o x x o x x o x x
    ! o x x o x x o x x o x x
    ! o x x o x x o x x o x x
    ! o o o o o o o o o o o o  n1
    ! o x x o x x o x x o x x  |
    ! o x x o x x o x x o x x  v
    ! o x x o x x o x x o x x
    ! o o o o o o o o o o o o
    ! The above is an array from quantity sized 8x12 (as n1 x n2)
    ! We plan to Scatter into the elements marked by x from the
    ! contiguous array in sourcequantity sized 6x8
    ! Each block is 3x2 (3,2)
    ! The start is at (1,2)
    ! The stride is (4,3)
    ! The count is (2,4)
    ! Note: if the 2nd index of block is 0, then do all instances
    ! and just hyperslabify the first index
    ! (See warning note following gather comments about how hdf5 interprets
    ! start array.)
    subroutine Scatter ( quantity, sourceQuantity, start, count, stride, block )
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), pointer :: SOURCEQUANTITY
      integer, dimension(:), intent(in) :: start
                                   ! Starting coordinates of hyperslab
      integer, dimension(:), intent(in) :: count
                                   ! Num of blocks to select from dataspace
      integer, dimension(:), intent(in) :: stride
                                   ! How many elements to move in each direction
      integer, dimension(:), intent(in) :: block
                                   ! Size of element block
      ! Local parameters
      integer :: II, JJ ! Block counters
      integer :: i, j   ! Counters within a block
      integer :: n1, n2 ! indices in Quantity array
      integer :: m1, m2 ! indices in sourcequantity array
      ! Executable
      if ( block(2) < 1 ) then
        ! do every instance of the 2nd index
        do n2=1, size(quantity%values, 2)
          do II=1, count(1)
            do i=1, block(1)
              n1 = start(1) - 1 + (II-1)*stride(1) + i
              m1 = (II-1)*block(1) + i
              quantity%values(n1, n2) = sourceQuantity%values(m1, n2)
            end do
          end do
        end do
      else
        do JJ=1, count(2)
          do II=1, count(1)
            do j=1, block(2)
              n2 = start(2) - 1 + (JJ-1)*stride(2) + j
              m2 = (JJ-1)*block(2) + j
              do i=1, block(1)
                n1 = start(1) - 1 + (II-1)*stride(1) + i
                m1 = (II-1)*block(1) + i
                quantity%values(n1, n2) = sourceQuantity%values(m1, m2)
              end do
            end do
          end do
        end do
      end if
    end subroutine Scatter

    ! --------------------------------------------  WithAscOrDesc  -----
    ! Fills a quantity with values determined by whether the s/c
    ! is in ascending or descending mode: +1 is ascending, -1 is descending
    ! method:
    ! We read the s/c velocity and look at the sign of its z component
    subroutine WithAscOrDesc ( key, quantity, chunk, fileDatabase, HGrids, &
      & PtanQuantity, manipulation )
    use HGridsDatabase, only: HGrids_T
    use MLSNumerics, only: ClosestElement

      ! Dummy arguments
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout)        :: QUANTITY ! Quantity to fill
      type (MLSChunk_T), INTENT(IN)              :: CHUNK
      type (MLSFile_T), dimension(:), pointer    :: FILEDATABASE
      type (HGrids_T), dimension(:), pointer     :: HGrids
      type (VectorValue_T), pointer              :: PtanQuantity
      ! manipulation can be either
      ! 's' scVelECI
      ! 'g' Geodlat
      ! If it is blank, we'll assume to read scVelECI from the L1BOA
      integer                                    :: manipulation
      ! Local variables
      integer                                    :: heightMAF
      real(r8), dimension(:,:), allocatable :: HEIGHTS ! might be ptan.
      integer                                    :: I
      integer, dimension(1)                      :: indices
      integer                                    :: l1bError
      integer                                    :: J
      type (L1BData_T)                           :: L1BDATA
      type (MLSFile_T), pointer                  :: L1BOAFile
      integer                                    :: MAF
      integer :: Me = -1                ! String index for trace
      integer                                    :: noMAFs
      integer                                    :: noSurfs
      character(len=1)                           :: SourceType ! 'g' or 's'
      character(len=1)                           :: string
      logical :: verbose
      ! Executable
      verbose = BeVerbose( 'fill', 0 )
      if ( verbose ) then
        call output( 'Made it to WithAscOrDesc subroutine', advance='yes' )
        call outputnamedValue ( 'manipulation', manipulation )
      endif
      call trace_begin ( me, 'FillUtils_1.WithAscOrDesc', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_surfaceType, l_AscDescMode/) ) ) &
        & call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & "Invalid quantity for Ascend/Descend fill.")
      SourceType = 's'
      if ( manipulation > 0 ) then
        call get_string ( manipulation, string, strip=.true. )
        SourceType = lowercase(string)
      endif
      L1BOAFile => GetMLSFileByType( filedatabase, content='l1boa' )
      if ( verbose ) then
        call Dump( L1BOAFile )
        call outputnamedValue ( 'SourceType', SourceType )
      endif
      select case (SourceType)
      case ('s')
        call ReadL1BData ( L1BOAFile, 'sc/VelECI', L1BDATA, noMAFs, &
          & flag=l1bError, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail= .true., &
          & dontPad=DONTPAD )
        if ( .not. associated( L1BData%dpField ) ) then
          call trace_end ( 'FillUtils_1.WithAscOrDesc', &
            & cond=toggle(gen) .and. levels(gen) > 1 )
          return
        end if

      case ('g')
        call ReadL1BData ( L1BOAFile, 'GHz/GeodAngle', L1BDATA, noMAFs, &
          & flag=l1bError, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail= .true., &
          & dontPad=DONTPAD )
        if ( .not. associated( L1BData%dpField ) ) then
          call trace_end ( 'FillUtils_1.WithAscOrDesc', &
            & cond=toggle(gen) .and. levels(gen) > 1 )
          return
        end if
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Invalid source quantity for Ascend/Descend fill." // string )
      end select
      noSurfs = quantity%template%noSurfs
      if ( verbose ) call outputnamedValue ( 'noSurfs', noSurfs )
      ! Work out vertical coordinate if needed
      if ( associated ( ptanQuantity ) .and. .not. Quantity%template%minorFrame ) then
        call Allocate_test ( Heights, ptanQuantity%template%nosurfs, &
          & ptanQuantity%template%noinstances, 'Heights', ModuleName )
        Heights = ptanQuantity%values
      else
        call Allocate_test ( Heights, nosurfs, &
          & quantity%template%noInstances, 'Heights', ModuleName )
        Heights = Quantity%template%surfs
      end if
      if ( verbose ) call outputnamedValue ( 'noInstances', quantity%template%noInstances )
      do i=1, quantity%template%noInstances
        maf = Hgrids(quantity%template%hGridIndex)%the_hGrid%maf(i)
        if ( maf < 1 ) maf = i
        heightMAF = maf
        if ( size(heights, 2) < heightMAF ) heightMAF = 1
        do j=1, noSurfs
          call ClosestElement ( Quantity%template%surfs(j,maf)*1._r8, &
            & Heights(:, heightMAF), indices )
          select case (SourceType)
          case ('s')
            quantity%values(j,i) = sign(1._rv, &
              & L1BData%dpField(3, indices(1), maf))
          case ('g')
            if ( indices(1) < 2 ) indices(1) = 2 ! In case it was 1
            quantity%values(j,i) = sign(1._rv, &
              & L1BData%dpField(1, indices(1), maf) - &
              & L1BData%dpField(1, indices(1)-1,maf) &
              & )
          end select
        end do
      end do
      call Deallocate_test ( Heights, 'Heights', ModuleName )
      call deallocateL1BData ( L1BData ) ! Avoid memory leaks
      call trace_end ( 'FillUtils_1.WithAscOrDesc', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine WithAscOrDesc

    ! --------------------------------------------  WithEstdNoise  -----
    subroutine WithEstNoise ( Quantity, Radiance, SysTemp, Nbw, IntegrationTime )

      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: RADIANCE ! Radiances to use in calculation
      type (VectorValue_T), intent(in) :: SYSTEMP ! System temperature
      type (VectorValue_T), pointer :: NBW ! Noise bandwidth
      real(r8), intent(in) :: INTEGRATIONTIME ! Integration time in seconds

      ! Local variables
      integer :: C                        ! Channel loop counter
      integer :: I                        ! Index into first dimension of values
      integer :: Me = -1                  ! String index for trace
      integer :: S                        ! Surface loop counter

      real (r8), dimension(:), pointer :: WIDTH ! Channel widths in MHz

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.WithEstNoise', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/), minorFrame=.true.) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Invalid quantity for estimated noise fill.")

      if ( .not. ValidateVectorQuantity ( radiance, &
        & quantityType=(/l_radiance/), minorFrame=.true.) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Invalid quantity for estimated noise fill.")

      if ( ( radiance%template%signal /= quantity%template%signal ) .or. &
        &  ( radiance%template%sideband /= quantity%template%sideband ) ) &
        & call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & "Quantity and radiances not same signal for estimated noise fill.")

      if ( ( systemp%template%signal /= quantity%template%signal ) .or. &
        &  ( systemp%template%sideband /= quantity%template%sideband ) ) &
        & call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & "Quantity and system temperature not same signal for estimated noise fill." )

      if ( .not. ValidateVectorQuantity ( &
        & sysTemp, &
        & quantityType=(/l_systemTemperature/), &
        & verticalCoordinate=(/l_none/), &
        & noInstances=(/1/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Invalid system temperature quantity for estimated noise fill.")

      if ( associated ( nbw ) ) then
        if ( .not. ValidateVectorQuantity ( &
          & nbw, &
          & quantityType=(/l_noiseBandwidth/), &
          & verticalCoordinate=(/l_none/), &
          & noInstances=(/1/) ) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Invalid noise bandwidth quantity for estimated noise fill.")
        if ( ( nbw%template%signal /= quantity%template%signal ) .or. &
          &    ( nbw%template%sideband /= quantity%template%sideband ) ) &
          & call MLSMEssage ( MLSMSG_Error, ModuleName, &
          & "Quantity and noise bandwidth not same signal for estimated noise fill." )
        width => nbw%values(:,1)
      else
        width => signals(radiance%template%signal)%widths(:)
      end if

      i = 1
      do s = 1, quantity%template%noSurfs
        do c = 1, quantity%template%noChans
          quantity%values(i,:) = ( radiance%values(i,:) + sysTemp%values(c,1) ) / &
            & sqrt ( integrationTime * 1e6 * width(c) )
          i = i + 1
        end do
      end do
      call trace_end ( 'FillUtils_1.WithEstNoise', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine WithEstNoise

    ! ---------------------------------  WithReflectorTemperature  -----
    subroutine WithReflectorTemperature ( key, quantity, phiZero, termsNode )
      integer, intent(in) :: KEY         ! Tree node for messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! The quantity to fill
      real(r8), intent(in) :: PHIZERO   ! Offset term
      integer, intent(in) :: TERMSNODE

      ! Local variables
      integer :: I                      ! Loop counter
      integer :: Me = -1                ! String index for trace
      integer, DIMENSION(2) :: UNITASARRAY ! Unit for value given
      real (r8), DIMENSION(2) :: VALUEASARRAY ! Value give

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.WithReflectorTemperature', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( quantity%template%quantityType /= l_reflTemp ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Inappropriate quantity for reflector temperature fill' )

      ! Loop over fourier terms, coefficients are son i+2
      do i = 0, nsons ( termsNode ) - 2
        call expr_check ( subtree(i+2,termsNode), unitAsArray, valueAsArray, &
          & (/PHYQ_Temperature/), unitsError )
        if ( unitsError ) call Announce_Error ( termsNode, wrongUnits, &
          & extraInfo=(/unitAsArray(1), PHYQ_Temperature/) )
        ! Add in this coefficient
        if ( i == 0 ) then
          quantity%values = valueAsArray(1)
        else if ( mod ( i, 2 ) == 1 ) then
          ! A sine term
          quantity%values(1,:) = quantity%values(1,:) + 2 * valueAsArray(1) * &
            & cos ( Deg2Rad * ((i+1)/2) * ( quantity%template%phi(1,:) - phiZero ) )
        else
          ! A cosine term
          quantity%values(1,:) = quantity%values(1,:) - 2 * valueAsArray(1) * &
            & sin ( Deg2Rad * ((i+1)/2) * ( quantity%template%phi(1,:) - phiZero ) )
        end if
      end do
      call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine WithReflectorTemperature

    ! ----------------------------------------  WithReichlerWMOTP  -----
    subroutine WithReichlerWMOTP ( tpPres, temperature )
      use WMOTropopause, only: ExtraTropics, TWMO
      ! Implements the algorithm published in GRL
      ! Loosely called the "Reichler" algorithm
      ! Ideas the same as in WithWMOTropopause
      ! But implemented differently
      !
      type (VectorValue_T), intent(inout) :: TPPRES ! Result
      type (VectorValue_T), intent(in) :: TEMPERATURE

      ! Local variables

      logical :: AlreadyDumped
      logical :: deebug
      integer :: Instance
      integer :: Invert
      integer :: Me = -1                   ! String index for trace
      real :: MISSINGVALUE
      integer :: Nlev
      integer :: Nvalid
      real, dimension( size(temperature%values, 1) ) :: P ! Pa
      real, parameter :: Pliml = 65.*100 ! in Pa
      real, parameter :: Plimlex = 65.*100 ! in Pa
      real, parameter :: Plimu = 550.*100 ! in Pa
      real, dimension( size(temperature%values, 1) ) :: T
      real :: Trp
      real, dimension(:), pointer :: xyTemp, xyPress
      ! logical, parameter :: DEEBUG = .false.

      ! Executable
      DEEBUG = LetsDebug ( 'wmo', 0 )
      call trace_begin ( me, 'FillUtils_1.WithReichlerWMOTP', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      nullify( xyTemp, xyPress )
      nlev = size(temperature%values, 1)
      MISSINGVALUE = REAL( DEFAULTUNDEFINEDVALUE )
      ! Loop over the instances
      tpPres%values = MISSINGVALUE
      if ( DEEBUG ) then
      call output( 'num levels', advance='no' )
      call output( nlev, advance='yes' )
      call output( 'num instances', advance='no' )
      call output( temperature%template%noInstances, advance='yes' )
      call output( 'shape of tpPress values', advance='no' )
      call output( shape(tpPres%values), advance='yes' )
      end if
      if ( -temperature%template%surfs(1,1) .gt.&
        & -temperature%template%surfs(2,1) ) then
        invert=1
        ! p = refGPH%values(nlev:1:-1,instance)*100.  ! hPa > Pa
        p = 10.0**(-temperature%template%surfs(nlev:1:-1,1))
        p = p * 100.  ! hPa > Pa
      else
        invert=0
        ! p=refGPH%values(:,instance)*100.         ! hPa > Pa
        p = 10.0**(-temperature%template%surfs(:,1))
        p = p * 100.  ! hPa > Pa
      end if
      instanceLoop: do instance = 1, temperature%template%noInstances
      alreadyDumped = .false.
        ! Check the temperatures are in a sensible range
        if ( any ( &
          & temperature%values(:,instance) < 10.0 .or. &
          & temperature%values(:,instance) > 1000.0 ) ) then
          if ( DEEBUG ) call output('invalid temperatures in this instance', advance='yes' )
          cycle instanceLoop
        end if
        ! check vertical orientation of data
        ! (twmo expects ordered from top downward)
        ! but surfs are -1.0 * log10(press)
        if ( invert == 1 ) then
          t = temperature%values(nlev:1:-1,instance)
        else
          t = temperature%values(:,instance)
        end if
        where ( t < 0. .or. t > 100000. )
          t = MissingValue
        end where
        nvalid = count( .not. isFillValue(t) )
        if ( nvalid < 2 ) then
          if ( DEEBUG ) then
          call output('not enough valid temperatures in this instance', advance='yes' )
          call output(count( .not. isFillValue(t) ), advance='yes' )
          call output(count( isFillValue(t) ), advance='yes' )
          call dump(temperature%values(:,instance), 'temperature%values')
          end if
          cycle
        end if
        call Allocate_test (xyTemp, nvalid, 'xyTemp', ModuleName )
        call Allocate_test (xyPress, nvalid, 'xyPress', ModuleName )
        call RemoveFillValues( t, MISSINGVALUE, xyTemp, &
          & p, xyPress )
        call twmo(nvalid, xyTemp, xyPress, plimu, pliml, trp)
        if ( .not. alreadyDumped .and. DEEBUG ) then
           alreadyDumped = .true.
           call dump(p, 'p ')
           call dump(t, 't ')
           call dump(xyTemp, 'xyTemp')
           call dump(xyPress, 'xyPress')
           call output( 'plimu, pliml, trp', advance='no' )
           call output( (/ plimu, pliml, trp /), advance='yes' )
        end if
        ! Don't let tropopause sink too low in "extra tropics"
        if ( trp < plimlex .and. &
          & extraTropics(temperature%template%geodLat(1, instance) ) ) then
          if ( DEEBUG ) then
          call output( 'trp too low in extra tropics', advance='no' )
          call output( (/ plimlex, trp /), advance='yes' )
          end if
          trp = MISSINGVALUE
        end if
        if ( trp > 0. .and. trp < 100000000. ) tpPres%values(1, instance) = trp/100
        call Deallocate_test ( xyTemp, 'xyTemp', ModuleName )
        call Deallocate_test ( xyPress, 'xyPress', ModuleName )
      end do instanceLoop
      if ( DEEBUG ) call dump( tpPres%values, 'tpPres%values' )
      call trace_end ( 'FillUtils_1.WithReichlerWMOTP', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine WithReichlerWMOTP

    ! ------------------------------------------  WithWMOTropopause  -----
    subroutine WithWMOTropopause ( tpPres, temperature, refGPH, grid )
      use Geometry, only: GeodToGeocLat
      use Hydrostatic_M, only: Hydrostatic

      type (VectorValue_T), intent(inout) :: TPPRES ! Result
      type (VectorValue_T), intent(in) :: TEMPERATURE
      type (VectorValue_T), intent(in) :: REFGPH
      type (VGrid_T), intent(in) :: GRID

      ! Local variables
      real(rv), dimension(grid%noSurfs) :: TFINE ! Temperature on fine grid
      real(rv), dimension(grid%noSurfs) :: HFINE ! Temperature on fine grid
      real(rv), dimension(grid%noSurfs) :: DTDH ! d(tFine)/d(hFine)
      real(rv), dimension(grid%noSurfs) :: DUMMYT ! Extra arg. for interpolateValues
      integer :: DS                     ! No. surfs less than 2km above s
      integer :: I                      ! Instance counter
      integer :: LOWCANDIDATE           ! Possbile tb but below 500hPa
      integer :: Me = -1                ! String index for trace
      integer :: S0                     ! Surface to start looking from
      integer :: S500                   ! 500mb surface?
      integer :: S                      ! Surface counter
      logical :: VALIDTP                ! Flag

      ! Now the rules for the WMO tropopause are:

      ! 1. The "first tropopause" is defined as the lowest height at which the
      ! lapse rate decreases to 2K per kilometer or less, provided also that
      ! the average lapse rate between this height and all higher altitudes
      ! within 2 kilometers does not exceed 2K per kilometer.

      ! 2. If, above the first tropopause, the average lapse rate between any
      ! height and all higher altitudes within a 1-kilometer intend exceeds 3K
      ! per kilometer, then another tropopause is defined by the same criteria
      ! as under 1 above. This second tropopause may be within or above the
      ! 1-kilometer layer.

      ! There are also two qualifying remarks attached to the selection
      ! criteria. They are as follows:

      ! 1. A height below the 500-mb level is not designated as a tropopause
      ! unless the sounding reaches the 200-mb level and the height is the only
      ! height satisfying the above definitions.

      ! 2. When the second or higher tropopauses are being determined, the
      ! 1-kilometer interval with an average lapse rate of 3K per kilometer can
      ! occur at any height above the conventional tropopause and not only at a
      ! height more than 2 kilometers above the first tropopause.

      ! Stricly melding the WMO tropopause definition with our own
      ! 'linear interpolation between tie points' mantra is problematic.
      ! If we are strict we'd only ever give the one of our basis points as
      ! the solution.  So we're going to interpolate to a higher resolution
      ! using a spline which pop's out the derivatives too.

      ! Note here we assume that the quantities supplied are all valid
      ! (ie describe the right quantities, and all on the same horizontal
      ! grid).

      call trace_begin ( me, 'FillUtils_1.WithWMOTropopause', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! Loop over the instances
      tpPres%values = 0.0
      instanceLoop: do i = 1, temperature%template%noInstances
        ! Check the temperatures are in a sensible range
        if ( any ( &
          & temperature%values(:,i) < 10.0 .or. &
          & temperature%values(:,i) > 1000.0 ) ) then
          cycle instanceLoop
        end if
        ! Perhaps think later about keeping track of the 'top'.
        ! Currently we're going to assert that we have data extending to
        ! pressures lower than 200mb.

        ! Interpolate temperature onto 'finer' pressure grid
        call InterpolateValues ( &
          & temperature%template%surfs(:,1), temperature%values(:,i), &
          & grid%surfs(:,1), tFine, method='Spline' )
        ! Now get the height for this.  Temperature and RefGPH are on same
        ! hGrids. RefGPH is in meters, but Hydrostatic wants it in km.
        call Hydrostatic ( GeodToGeocLat ( temperature%template%geodLat(1,i) ), &
          & grid%surfs(:,1), tFine, grid%surfs(:,1), &
          & refGPH%template%surfs(1,1), 0.001*refGPH%values(1,i), hFine )
        ! Note while much of the software thinks in meters, the hydrostatic
        ! routine works in km.
        ! Now do another spline 'interpolation' to get dTdH
        call InterpolateValues ( hFine, tFine, hFine, dummyT, &
          & dYbyDx=dtdh, method='Spline' )
        ! Negate dTdH to turn it into lapse rate
        dTdH = - dTdH

        ! Locate the 500mb surface
        call Hunt ( grid%surfs(:,1), -log10(500.0_r8), s500 )

        ! Find the 'first' tropopause.  We're not going to bother
        ! with the 'second'
        lowCandidate = 0
        validTP = .false.
        s0 = 1
        tpHunt: do
          ! Find first place where lapse rate less than 2K/km
          s = FindFirst ( dtdh(s0:) < 2.0 ) + s0 - 1
          ! If not found such a place give up looking
          if ( s == s0 - 1 ) exit tpHunt
          ! Find last surface within 2km of this one
          ds = FindFirst ( hFine(s:) > hFine(s) + 2.0 ) - 1
          ! If not got data 2km above s0 (FindFirst gave 0, so ds=-1), give up
          ! Also, if data on such coarse resolution that the next point above
          ! s0 is more than 2km away (FindFirst gave 1 so ds=0), also give up
          if ( ds <= 0 ) exit tpHunt
          ! Must have mean lapse rate less than 2K/km within 2km of s.
          validTp = sum ( dTdH ( s : s + ds - 1 ) / ds ) < 2.0
          ! If this is below 500mb, keep an eye on it and keep looking
          if ( s < s500 .and. validTP ) then
            validTP = .false.
            lowCandidate = s
          end if
          if ( validTP ) exit tpHunt
          ! Otherwise keep looking higher up
          s0 = s + 1
          if ( s0 > grid%noSurfs ) exit tpHunt
        end do tpHunt

        ! Now pick up the pieces of that complex logic
        if ( .not. validTP .and. lowCandidate > 0 ) then
          s = lowCandidate
          validTP = .true.
        end if

        ! If we never found one, leave 0 in the result and move onto
        ! the next instance
        if ( .not. validTP ) cycle instanceLoop

        ! OK, our tropopause is below surface s
        ! Now we do some interpolation to get
        ! the value we really want.
        if ( s > 1 ) then
          tpPres%values(1,i) = 10.0 ** ( -( &
            & grid%surfs(s-1,1) + &
            & ( grid%surfs(s,1) - grid%surfs(s-1,1) ) * ( dTdH(s-1) - 2.0 ) / &
            & ( dTdH(s-1) - dTdH(s) ) ) )
        else
          tpPres%values(1,i) = 10.0 ** ( - grid%surfs(s,1) )
        end if
      end do instanceLoop
      call trace_end ( 'FillUtils_1.WithWMOTropopause', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine WithWMOTropopause

    ! -----------------------------------------  QualityFromChisq  -----
    ! Compute Quality as a function of chi^2
    ! namely, Q = scale / chi^2
    ! The computation is done at the first vertical surface
    ! unless heightNode is supplied
    subroutine QualityFromChisq ( key, quantity, sourceQuantity, &
      & scale, heightNode, ignoreTemplate )
      integer, intent(in) :: KEY        ! Tree node
      type ( VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type ( VectorValue_T), intent(in)    :: SOURCEQUANTITY ! Chisq like quantity on which it's based
      real(r8), intent(in)                 :: SCALE     ! A scale factor
      integer, intent(in)                  :: HEIGHTNODE ! What height to use
      logical, intent(in)                  :: IGNORETEMPLATE

      ! Local variables
      real(r8) :: HEIGHT                ! The height to consider
      integer :: Me = -1                ! String index for trace
      integer :: SURFACE                ! Surface index
      integer, dimension(2) :: UNITASARRAY ! From expr
      real(r8), dimension(2) :: VALUEASARRAY ! From expr

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.QualityFromChisq', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! Do some sanity checking
      if ( .not. ignoreTemplate ) then
        if ( quantity%template%quantityType /= l_quality ) call Announce_Error ( key, no_error_code, &
          & 'Quality quantity must be quality' )
        if ( sourceQuantity%template%quantityType /= l_chisqBinned ) call Announce_Error ( &
          & key, no_error_code, 'sourceQuantity must be of type chisqBinned' )
        if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) ) call Announce_Error ( &
          & key, no_error_code, 'quantity and sourceQuantity do not have matching hGrids' )
      end if
      ! Work out the height
      if ( heightNode /= 0 ) then
        if ( nsons ( heightNode ) /= 2 ) call Announce_Error ( key, no_error_code, &
          & 'Only one height can be supplied for quality fill' )
        call expr_check ( subtree(2,heightNode) , unitAsArray, valueAsArray, &
          & (/PHYQ_Pressure/), unitsError )
        if ( unitsError ) call Announce_Error ( heightNode, wrongUnits, &
          & extraInfo=(/unitAsArray(1), PHYQ_Pressure/) )
        height = - log10 ( valueAsArray(1) )
        call Hunt ( sourceQuantity%template%surfs(:,1), height, surface, nearest=.true. )
      else
        surface = 1
      end if
      quantity%values(1,:) = 0.0_r8
      where ( sourceQuantity%values(surface,:) /= 0.0_r8 )
        quantity%values(1,:) = scale / sourceQuantity%values(surface,:)
      end where
      call trace_end ( 'FillUtils_1.QualityFromChisq', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine QualityFromChisq

    ! -------------------------------------------  StatusQuantity  -----
    subroutine StatusQuantity ( key, quantity, sourceQuantity, statusValue, &
      & minValue, maxValue, heightNode, &
      & additional, exact, ignoreTemplate )
      integer, intent(in) :: KEY        ! Tree node
      type ( VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type ( VectorValue_T), intent(in) :: SOURCEQUANTITY ! Quantity on which it's based
      integer, intent(in) :: STATUSVALUE
      real(r8), intent(in) :: MINVALUE     ! A scale factor
      real(r8), intent(in) :: MAXVALUE     ! A scale factor
      integer, intent(in) :: HEIGHTNODE ! What height to compare at
      logical, intent(in) :: ADDITIONAL ! Is this an additional flag or a fresh start?
      logical, intent(in) :: EXACT ! Set status to exact statusValue , don't OR values
      logical, intent(in) :: IGNORETEMPLATE

      ! Local variables
      real(r8) :: HEIGHT                ! The height to consider
      integer :: Me = -1                ! String index for trace
      integer :: SURFACE                ! Surface index
      integer, dimension(2) :: UNITASARRAY ! From expr
      real(r8), dimension(2) :: VALUEASARRAY ! From expr

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.StatusQuantity', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! Do some sanity checking
      if ( .not. ignoreTemplate ) then
        if ( quantity%template%quantityType /= l_status ) call Announce_Error ( key, no_error_code, &
          & 'status quantity must be status' )
        if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) ) &
          & call Announce_Error ( &
          & key, no_error_code, 'quantity and sourceQuantity do not have matching hGrids' )
      end if
      ! Work out the height
      if ( heightNode /= 0 ) then
        if ( nsons ( heightNode ) /= 2 ) call Announce_Error ( key, no_error_code, &
          & 'Only one height can be supplied for status fill' )
        if ( sourceQuantity%template%verticalCoordinate /= l_zeta ) &
          & call Announce_Error ( key, no_error_code, 'Bad vertical coordinate for sourceQuantity' )
        call expr_check ( subtree(2,heightNode) , unitAsArray, valueAsArray, &
          & (/PHYQ_Pressure/), unitsError )
        if ( unitsError ) call Announce_Error ( heightNode, wrongUnits, &
          & extraInfo=(/unitAsArray(1), PHYQ_Pressure/) )
        height = - log10 ( valueAsArray(1) )
        call Hunt ( sourceQuantity%template%surfs(:,1), height, surface, nearest=.true. )
      else
        surface = 1
      end if
      if ( .not. additional ) quantity%values = 0.0_r8
      if ( size(sourceQuantity%values, 2) /= size(quantity%values, 2) ) then
        if ( sourceQuantity%values(surface,1) > maxValue .or. &
          & sourceQuantity%values(surface,1) < minValue ) then
          if ( exact ) then
            quantity%values(1,:) = statusValue
          else
            quantity%values(1,:) = ior ( nint ( quantity%values(1,1) ), statusValue )
          end if
        end if
      else
        ! quantity%values = iand ( nint ( quantity%values ), not ( statusValue ) )
        if ( exact ) then
          where ( sourceQuantity%values(surface,:) > maxValue .or. &
            & sourceQuantity%values(surface,:) < minValue )
              quantity%values(1,:) = statusValue
          end where
        else
          where ( sourceQuantity%values(surface,:) > maxValue .or. &
            & sourceQuantity%values(surface,:) < minValue )
              quantity%values(1,:) = ior ( nint ( quantity%values(1,:) ), statusValue )
          end where
        end if
      end if
      call trace_end ( 'FillUtils_1.StatusQuantity', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine StatusQuantity

    ! ----------------------------------------  UsingLeastSquares  -----
    subroutine UsingLeastSquares  ( Key, Quantity, SourceQuantity, PtanQuantity, &
      & Channel, Method, ScaleInstances, ScaleRatio, ScaleSurfs )
      ! This fills a coherent Quantity from a a typically incoherent
      ! SourceQuantity using a least-squares approximation to a first-order
      ! Taylor series.

      use HFTI_M, only: HFTI

      ! Arguments
      ! SourceQuantity has the target attribute so that we can take a
      ! pointer to SourceQuantity%template%surfs
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in), target :: SOURCEQUANTITY
      type (VectorValue_T), pointer :: PTANQUANTITY
      integer, intent(in) :: CHANNEL
      integer, intent(in) :: METHOD
      real(r8), intent(inout) :: ScaleInstances, ScaleRatio, ScaleSurfs

      ! Local variables
      real(r8), dimension(:,:), pointer :: INSTS ! Instance coordinates for source
      real(r8), dimension(:,:), pointer :: LSMatrix ! Least Squares problem matrix
      real(r8), dimension(:), pointer :: RHS
      real(r8), dimension(:,:), pointer :: SOURCEHEIGHTS ! might be ptan.
      real(r8), dimension(:,:), pointer :: SURFS ! Surface coordinates for source
      real(r8) :: W, WMAX               ! Weight if method == l_lsWeighted
      integer :: QS, QI, SS, SI         ! Loop counters
      integer :: KRANK                  ! Rank of least-squares solution
      integer :: Me = -1                ! String index for trace
      integer :: MYCHANNEL              ! Channel or 1
      integer :: NRows
      integer :: NSourceQuant  ! Number of values in SourceQuantity

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.UsingLeastSquares', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! Check the output quantity
      if ( .not. ValidateVectorQuantity ( quantity, &
        & coherent=.true., stacked=.true. ) ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Quantity for least-squares fill must be stacked and coherent' )

      ! Also should have the condition:
      !  quantityType = (/ sourceQuantity%template%quantityType /)
      ! However, the code does not yet really support the ability to do that.

      ! Work out source vertical coordinate
      if ( associated ( ptanQuantity ) .and. sourceQuantity%template%minorFrame ) then
        nullify ( sourceHeights )
        call Allocate_test ( sourceHeights, sourceQuantity%template%nosurfs, &
          & sourceQuantity%template%noinstances, 'sourceHeights', ModuleName )
        sourceHeights = ptanQuantity%values
        if ( quantity%template%verticalCoordinate /= l_zeta .and. WARNIFVERTCOORDNOTZETA ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Vertical coordinate in quantity to fill is not zeta' )
      else
        sourceHeights => sourceQuantity%template%surfs
        if ( sourceQuantity%template%verticalCoordinate /= quantity%template%verticalCoordinate ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Vertical coordinates in least-squares fill do not match' )
      end if

      ! Get the channel number
      if ( sourceQuantity%template%frequencyCoordinate /= l_none .and. &
        & channel == 0 ) then
        call Announce_Error ( key, no_error_code, &
          & 'Must supply channel for this least-squares fill' )
        go to 9
      end if
      myChannel = max(channel,1)

      ! Setup coordinate arrays
      nullify ( surfs, insts )
      call Allocate_test ( surfs, sourceQuantity%template%nosurfs, &
        & sourceQuantity%template%noinstances, 'surfs', ModuleName )
      call Allocate_test ( insts, sourceQuantity%template%nosurfs, &
        & sourceQuantity%template%noinstances, 'insts', ModuleName )

      ! Get the vertical coordinates, a function of instance for
      ! incoherent quantities
      do ss = 1, sourceQuantity%template%noSurfs
        if ( sourceQuantity%template%coherent ) then
          surfs(ss,:) = sourceHeights(ss,1)
        else
          surfs(ss,:) = sourceHeights(ss,:)
        end if
      end do

!      call dump ( surfs, 'surfs' )

      ! Get the horizontal coordinates, a function of height for unstacked quantities.
      do si = 1, sourceQuantity%template%noInstances
        if ( sourceQuantity%template%coherent ) then
          insts(:,si) = sourceQuantity%template%phi(1,si)
        else
          insts(:,si) = sourceQuantity%template%phi(:,si)
        end if
      end do

!      call dump ( insts, 'insts' )

      ! Allocate the arrays
      nullify ( lsMatrix, RHS )
      if ( sourceQuantity%template%regular ) then
        nSourceQuant = sourceQuantity%template%noInstances * &
          &            sourceQuantity%template%noSurfs
      else
        nSourceQuant = sourceQuantity%template%noInstances * &
          &                sourceQuantity%template%instanceLen
      end if
      call allocate_test ( lsMatrix, nSourceQuant, 4, 'LSMatrix', moduleName )
      call allocate_test ( RHS, nSourceQuant, 'RHS', moduleName )

      if ( method == l_lsWeighted ) then
        if ( scaleInstances < 0.0 ) scaleInstances = &
          ( quantity%template%phi(1,quantity%template%noInstances) - &
            quantity%template%phi(1,1) ) / &
          ( quantity%template%noInstances - 1 )
        if ( scaleSurfs < 0.0 ) scaleSurfs = &
          ( quantity%template%surfs(quantity%template%noSurfs,1) - &
            quantity%template%surfs(1,1) ) / &
          ( quantity%template%noSurfs - 1 )
        scaleSurfs = scaleSurfs * scaleRatio
      end if
      ! Now loop over the output quantity points and set up the least-squares
      ! problem.
      do qi = 1, quantity%template%noInstances
        do qs = 1, quantity%template%noSurfs
          nRows = 0
          wMax = -1.0
          do si = 1, sourceQuantity%template%noInstances
            do ss = 1, sourceQuantity%template%noSurfs
              if ( method == l_lslocal ) then
                if ( surfs(ss,si) < quantity%template%surfs(max(qs-1,1),1) ) cycle
                if ( surfs(ss,si) > quantity%template%surfs(min(qs+1,quantity%template%noSurfs),1) ) cycle
                if ( insts(ss,si) < quantity%template%phi(1,max(qi-1,1)) ) cycle
                if ( insts(ss,si) > quantity%template%phi(1,min(qi+1,quantity%template%noInstances)) ) cycle
              end if
              nRows = nRows + 1
              lsMatrix(nRows,:3) = (/ 1.0_r8, &
                & insts(ss,si) - quantity%template%phi(1,qi), &
                & surfs(ss,si) - quantity%template%surfs(qs,1) /)
              lsMatrix(nRows,4) = 0.5 * lsMatrix(nRows,2) * lsMatrix(nRows,3)
              rhs(nRows) = sourceQuantity%values(myChannel+(ss-1)*sourceQuantity%template%noChans,si)
              if ( method == l_lsWeighted ) then
                w = exp( - (lsMatrix(nRows,2)/scaleInstances)**2 &
                       & - (lsMatrix(nRows,3)/scaleSurfs)**2 )
                if ( w > wMax ) then
                  wMax = w
                else if ( w < sqrt(epsilon(w))*wMax ) then
                  nRows = nRows - 1
                  cycle
                end if
                lsMatrix(nRows,:) = lsMatrix(nRows,:) * w
                rhs(nRows) = rhs(nRows) * w
              end if
            end do
          end do
          if ( nRows < 4 ) then
            quantity%values(qs,qi) = quantity%template%badValue
          else
            ! Solve the least squares problem
            call hfti ( lsMatrix(:nRows,:), rhs(:nRows), krank=krank )
            if ( krank < 4 ) then
              quantity%values(qs,qi) = quantity%template%badValue
            else
              quantity%values(qs,qi) = rhs(1)
            end if
          end if
        end do
      end do

      ! Now tidy up
      call deallocate_test ( surfs,    'surfs',    moduleName )
      call deallocate_test ( insts,    'insts',    moduleName )
      call deallocate_test ( lsMatrix, 'LSMatrix', moduleName )
      call deallocate_test ( RHS,      'RHS',      moduleName )
      if ( associated ( ptanQuantity ) .and. sourceQuantity%template%minorFrame ) &
        & call Deallocate_test ( sourceHeights, 'sourceHeights', ModuleName )
    9 call trace_end ( 'FillUtils_1.UsingLeastSquares', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine UsingLeastSquares

    ! -------------------------------------------------  FromGrid  -----
    subroutine FromGrid( quantity, grid, allowMissing, replaceMissingValue, &
      & errorCode )
      use QuantityTemplates, only: Dump
      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (GriddedData_T), intent(inout) :: GRID ! Grid to fill it from
      ! Needs to be inout because we wrap it.
      logical, intent(in) :: ALLOWMISSING ! If set missing data in grid ok
      real(rv), intent(in) :: replaceMissingValue ! Replace missing data in grid with
      integer, intent(out) :: ERRORCODE   ! Error code (one of constants defined above)

      ! Local variables
      logical :: check
      logical :: DEEBUG
      integer :: instance,surf            ! Loop counter
      integer :: instIndex,surfIndex      ! Indices
      integer :: Me = -1                  ! String index for trace
      real(rv) :: newValue
      logical :: noGrid
      logical :: verbose
      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FromGrid', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      errorCode = 0
      DEEBUG = .false.
      ! DEEBUG = ( grid%quantityName == 'TEMPERATURE' .or. &
      !   & grid%description == 'Temperature' )
      check = (BeVerbose( 'cgrid', -1 ))
      verbose = (BeVerbose( 'grid', -1 )) ! .or. .true.
      if ( check ) call outputNamedValue( 'check', check )
      noGrid = .not. associated(grid%field)
      if ( .not. noGrid ) noGrid = grid%empty
      if ( noGrid ) then
        ! Must allow this as missing gmao files are a possibility
        ! to be handled with grace and aplomb
        call MLSMessage ( MLSMSG_Warning, moduleName, &
          & 'No tropopause or whatever values in grid--filling with missing values' )
        quantity%values = REAL( DEFAULTUNDEFINEDVALUE ) ! grid%missingValue
        go to 9
      end if

      if ( quantity%template%verticalCoordinate /= l_zeta .and. &
        & quantity%template%noInstances > 1 .and. grid%noHeights > 1 ) then
        errorCode=NotZetaForGrid
        go to 9
      end if

      instIndex=1
      surfIndex=1

      ! Wrap the grid to be sure that we can interpolate it in longitude
      ! This will skip out if it's already been done.
      call WrapGriddedData ( grid )

      if ( DEEBUG ) then
        call dump( grid )
        call dump( quantity%template%surfs, 'zeta surfs' )
        call outputNamedValue( '(noSurfs,noInstances)', &
          & (/ quantity%template%noSurfs,quantity%template%noInstances /) )
      end if
      if ( verbose ) then
        call Dump( quantity%template, details=1 )
        call Dump( quantity%template%time(:,1), 'template dates' )
      endif
      do instance = 1, quantity%template%noInstances
        if ( .not. quantity%template%stacked) instIndex=instance

        do surf = 1, quantity%template%noSurfs
          if ( .not. quantity%template%coherent) surfIndex=surf
          if ( DEEBUG ) then
            call outputNamedValue( 'interp pressure', 10.0**(-quantity%template%surfs(surf,instIndex)) )
            if ( 10.0**(-quantity%template%surfs(surf,instIndex)) < 1.E-6 ) then
              call outputNamedValue( '(surf,instIndex)', (/ surf,instIndex /) )
            end if
          end if
          call l3ascii_interp_field(grid, newValue, &
            & pressure=10.0**(-quantity%template%surfs(surf,instIndex)), &
            & lat=quantity%template%geodLat(surfIndex,instance), &
            & lon=quantity%template%lon(surfIndex,instance), &
            & lst=quantity%template%solarTime(surfIndex,instance), &
            & sza=quantity%template%solarZenith(surfIndex,instance), &
            & date=quantity%template%time(surfIndex,instance), &
            & debug=.false. )
            ! & debug=(instance==1 .and. surf==1 .and. grid%quantityName == 'CO') )
          if ( newValue >= nearest ( grid%missingValue, -1.0 ) .and. &
            &  newValue <= nearest ( grid%missingValue,  1.0 ) ) then
            if ( .not. allowMissing ) errorCode = MissingDataInGrid
            if ( replaceMissingValue /= 0. ) newValue = replaceMissingValue
          endif
          quantity%values(surf,instance) = newValue
        end do                            ! End surface loop
      end do                              ! End instance loop

      if ( check ) then
          call l3ascii_interp_field(grid, newValue, &
            & pressure=100.0_rv, &
            & lat=0.0_rv, &
            & lon=0.0_rv, &
            & lst=0.0_rv, &
            & sza=0.0_rv, &
            & date=quantity%template%time(1,1), &
            & debug=.false. )
          call outputNamedValue( 'interpolated value', newValue )
      end if
    9 call trace_end ( 'FillUtils_1.FromGrid', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine FromGrid

    ! -------------------------------------------------  FromL2GP  -----
    subroutine FromL2GP ( quantity,L2GP, interpolate, profile, &
      & errorCode, ignoreGeolocation, fromPrecision )

      ! If the times, pressures, and geolocations match, fill the quantity with
      ! the appropriate subset of profiles from the L2GP

      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (L2GPData_T), intent(in), target :: L2GP ! L2GP to fill from
      logical, intent(in) :: interpolate  ! Flag
      integer, intent(in) :: profile    ! Single profile to use or -1 for default
      integer, intent(out) :: errorCode ! Error code
      logical, intent(in) :: ignoreGeolocation  ! Flag
      logical, intent(in) :: fromPrecision ! Flag

      ! Local parameters
      real(r8), parameter :: TOLERANCE=0.05 ! Tolerence for angles
      real(r8), parameter :: TIMETOL=5.0  ! Tolerence for time (not sure why this
      ! needs to be so big !????????? NJL)

      ! Local variables
      integer :: FIRSTPROFILE, LASTPROFILE
      integer, dimension(1) :: FIRSTPROFILEASARRAY
      integer :: INSTANCE               ! Loop counter
      integer :: Me = -1                ! String index for trace
      integer :: THISPROFILE            ! Index
      type (Coefficients(r8)) :: COEFFS  ! For interpolation
      real (r8), dimension(quantity%template%noSurfs) :: outZeta
      real (r4), dimension(:,:,:), pointer :: SOURCE

      call trace_begin ( me, 'FillUtils_1.FromL2GP', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      errorCode=0
      ! Make sure this quantity is appropriate
      if ( .not. ValidateVectorQuantity(quantity, coherent=.TRUE., stacked=.TRUE., &
        & verticalCoordinate= (/ l_pressure, l_zeta /) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity to fill is not on pressure or zeta coordinates' )

      if ( (quantity%template%noChans/=L2GP%nFreqs) .and. &
        &  ((quantity%template%noChans/=1) .or. (L2GP%nFreqs/=0)) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity and L2GP have different number of channels' )

      if ( quantity%template%noSurfs /= L2GP%nLevels .and. (.not. interpolate) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity and L2GP have different number of surfaces (set interpolate?)' )

      if ( .not. interpolate ) then
        if ( quantity%template%verticalCoordinate == l_pressure ) then
          if ( any(ABS(-LOG10(quantity%template%surfs(:,1))+ &
            & LOG10(L2GP%pressures)) > TOLERANCE) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Quantity and L2GP are on different surfaces (set interpolate?)' )
        else                                ! Must be l_zeta
          if ( any(ABS(quantity%template%surfs(:,1)+ &
            & LOG10(L2GP%pressures)) > TOLERANCE) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Quantity and L2GP are on different surfaces (set interpolate?)' )
        end if
      end if

      ! Skip the position checks if we're forcing in a particular profile.
      firstProfile = 1
      lastProfile=firstProfile+quantity%template%noInstances-1
      if ( (profile == -1) .and. (.not. ignoreGeolocation) ) then
        ! Attempt to match up the first location
        if ( quantity%template%horizontalCoordinate == l_time ) then
          firstProfileAsArray = minloc( &
            & abs(quantity%template%time(1,1)-L2GP%time) &
            & )
        else
          firstProfileAsArray = minloc( &
            & abs(quantity%template%phi(1,1)-L2GP%geodAngle) &
            & )
        end if
        firstProfile=firstProfileAsArray(1)

        ! Well, the last profile has to be noInstances later, check this would be OK
        lastProfile=firstProfile+quantity%template%noInstances-1
        if ( lastProfile > L2GP%nTimes ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Quantity has profiles beyond the end of the L2GP' )

        ! Now check that geodAngle's are a sufficient match
        if ( any(abs(L2GP%geodAngle(firstProfile:lastProfile)-&
          &         quantity%template%phi(1,:)) > tolerance) .and. &
          & quantity%template%horizontalCoordinate /= l_time ) then
          if ( BeVerbose( 'l2gp', -1 ) ) then
            call dump ( L2GP%geodAngle(firstProfile:lastProfile), 'L2GP geodetic angle' )
            call dump ( quantity%template%phi(1,:), 'Quantity Geodetic angle' )
          end if
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Quantity has profiles that mismatch L2GP in geodetic angle; interpolate?' )
        end if

        ! Now check that the times match
        if ( any(abs(L2GP%time(firstProfile:lastProfile)- &
          &         quantity%template%time(1,:)) > timeTol) ) then
          if ( BeVerbose( 'l2gp', -1 ) ) then
            call dump ( L2GP%time(firstProfile:lastProfile), 'L2GP geodetic angle' )
            call dump ( quantity%template%time(1,:), 'Quantity Geodetic angle' )
          end if
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Quantity has profiles that mismatch L2GP in time' )
        end if
        ! Currently the code cannot interpolate in 3 dimensions, wouldn't
        ! be hard to code up, but no need as yet.
        if ( interpolate .and. quantity%template%noChans /= 1 ) then
          errorCode=cantInterpolate3D
          go to 9
        end if
      else
        ! Given a specific profile, check it's legal
        if ( profile == 0 .or. profile > L2GP%nTimes ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Illegal profile request in L2GP fill' )
      end if

      ! OK, things seem to be OK, so start getting the data
      if ( fromPrecision ) then
        source => L2GP%L2GPPrecision
      else
        source => L2GP%L2GPValue
      end if

      ! OK, now do the filling, it's easier if we don't have to interpolate
      if ( .not. interpolate ) then
        if ( profile == -1 ) then
          ! Not forcing a particular profile to all instances
          quantity%values=reshape(source(:,:,firstProfile:lastProfile),&
            & (/quantity%template%noChans*quantity%template%noSurfs,&
            &   quantity%template%noInstances/))
        else
          ! Spread one profile onto all instances
          quantity%values = spread ( reshape ( source(:,:,profile), &
            &   (/ quantity%template%noChans*quantity%template%noSurfs/) ), &
            & 2, quantity%template%noInstances )
        end if
      else
        if ( quantity%template%verticalCoordinate == l_pressure ) then
          outZeta = -log10 ( quantity%template%surfs(:,1) )
        else
          outZeta = quantity%template%surfs(:,1)
        end if
        ! Setup the interpolation we'll be doing.
        call InterpolateArraySetup ( -log10(real(L2GP%pressures, r8)), &
          & outZeta, 'Linear', coeffs, extrapolate='Clamp' )
        do instance = 1, quantity%template%noInstances
          if ( profile == -1 ) then
            thisProfile = firstProfile + instance - 1
          else
            thisProfile = profile
          end if
          ! Guess I don't really need the loop here, but it
          ! does make the spread stuff much easier, and the setup/teardown
          ! at least makes it more efficient.
          call InterpolateValues ( coeffs, &
            & -log10(real(L2GP%pressures, r8)), &  ! Old X
            & real(source(1,:,thisProfile), r8), & ! OldY
            & outZeta, & ! New X
            & quantity%values(:,instance), & ! New Y
            & method='Linear', extrapolate='Clamp' )
        end do
        call InterpolateArrayTeardown ( coeffs )
      end if
    9 call trace_end ( 'FillUtils_1.FromL2GP', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine FromL2GP

    ! ----------------------------------------------  FromProfile  -----
    subroutine FromProfile_values ( quantity, inheights, invalues, &
      & instancesNode, globalUnit, ptan, logSpace, dontLatch )
      ! Given two arrays,  (heights, invalues) vs. the quantity's own heights,
      ! does the linear interpolation appropriate to perform the fill.
      ! By default, latch the supplied heights to the quantity's own
      ! optionally dont latch
      !
      ! Another gotcha: interpolate using only the quantity's heights at its first
      ! instance, then spread out to all other instances
      ! Should we let the user override this?
      !
      ! Quantity has the target attribute so that we can take a pointer to
      ! Quantity%template%surfs.
      type (VectorValue_T), intent(inout), target :: QUANTITY ! Quantity to fill
      real(r8), dimension(:), intent(in) :: INHEIGHTS ! Supplied heights
      real(r8), dimension(:), intent(in) :: INVALUES
      integer, intent(in) :: INSTANCESNODE ! Tree node for instances
      integer, intent(in) :: GLOBALUNIT   ! Possible global unit
      type (VectorValue_T), pointer :: PTAN ! press. values
      logical, intent(in), optional :: LOGSPACE ! Interpolate in logspace
      logical, intent(in), optional :: DONTLATCH ! Dont latch supplied heights

      ! Local variables
      integer :: C                      ! Channel loop counter
      logical, dimension(:), pointer :: DUPLICATED ! Flags
      logical :: Fail                   ! Status from Hunt
      real (r8), dimension(:), pointer :: HEIGHTS ! Heights for the points
      integer :: I,J                    ! Loop counters / indices
      integer, dimension(:), pointer :: ININDS ! Indices
      logical, dimension(:), pointer :: INSTANCES ! Flags
      logical :: LOCALOUTHEIGHTS ! Set if out heights is our own variable
      integer :: Me = -1                ! String index for trace
      logical :: MYLATCH                ! Latch supplied heights to quantity's own?
      logical :: MYLOGSPACE             ! Interpolate in log space?
      integer :: NOPOINTS               ! Number of points supplied
      integer :: NOUNIQUE               ! Number of unique heights supplied
      real (r8), dimension(:), pointer :: OUTHEIGHTS ! Heights for output
      real (r8), dimension(:), pointer :: OUTVALUES ! Single profile for output
      integer :: S                      ! Surface loop counter
      integer :: STATUS                 ! Flag
      real (r8), dimension(:), pointer :: VALUES ! Values for the points
      logical :: Verbose

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FromProfile_values', instancesNode, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! Set some stuff up
      verbose = associated(ptan) .and. .false.
      myLogSpace = quantity%template%logBasis
      if ( present ( logSpace ) ) myLogSpace = logSpace
      if ( myLogSpace .and. any ( invalues <= 0.0 ) ) then
        call Announce_Error ( 0, no_error_code, &
          & 'Non-positive input data in log profile fill (reset logSpace=false?)' )
        go to 9
      end if
      myLatch = .true.
      if ( present(dontLatch) ) myLatch = .not. dontLatch
      nullify ( heights, values, duplicated, outHeights, outValues, instances )
      noPoints = size(invalues)
      call Allocate_test ( heights, noPoints, 'values', ModuleName )
      call Allocate_test ( values, noPoints, 'values', ModuleName )
      call Allocate_test ( duplicated, noPoints, 'duplicated', ModuleName )
      call Allocate_test ( outValues, quantity%template%noSurfs, &
        & 'outValues', ModuleName )
      call Allocate_test ( instances, quantity%template%noInstances, &
        & 'instances', ModuleName )
      heights = inHeights
      values = invalues
      if ( myLogSpace ) values = log ( invalues )
      if ( verbose ) call outputnamedValue( 'myLatch', myLatch )

      ! Get the appropriate height coordinate for output, for pressure take log.
      if ( associated(ptan) ) then
        localOutHeights = .false.
        outHeights => ptan%values(:,1)
      else if ( quantity%template%verticalCoordinate == l_pressure ) then
        localOutHeights = .true.
        call Allocate_test ( outHeights, quantity%template%noSurfs, &
          & 'outHeights', ModuleName )
        outHeights = -log10 ( quantity%template%surfs(:,1) )
      else
        localOutHeights = .false.
        outHeights => quantity%template%surfs(:,1)
      end if

      ! Now, let's assume the user wanted the
      ! 'nearest' values, so first latch the supplied heights to
      ! the nearest quantity heights or equivalent
      if ( myLatch ) then
        nullify ( inInds )
        call allocate_test ( inInds, noPoints, 'inInds', ModuleName )
        ! Hunt fails with non-monotonic outHeights
        if ( .not. isMonotonic(outHeights) ) then
          call monotonize( outHeights )
          if ( WARNWHENPTANNONMONOTONIC ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName // '/FromProfile', &
              & 'Ptan non-monotonic' )
            call dump( outHeights, 'outHeights' )
          end if
        end if
        if ( verbose ) then
          call dump( 10.**(-outHeights), 'outHeights (hPa)' )
          call dump( 10.**(-heights), 'heights (hpa)' )
        end if
        call hunt ( outHeights, heights, inInds, &
         & nearest=.true., allowTopValue=.true., fail=fail )
        if ( fail ) then
          call Announce_Error ( 0, no_error_code, &
          & 'Problem in Hunt' )
          go to 9
        end if
        duplicated = .false.
        do i = 1, noPoints - 1
          do j = i + 1, noPoints
            if ( inInds(i) == inInds(j) ) then
              duplicated ( j ) = .true.
            end if
          end do
        end do
        noUnique = count ( .not. duplicated )
        inInds(1:noUnique) = pack ( inInds, .not. duplicated )
        heights(1:noUnique) = outHeights ( inInds(1:noUnique) )
        values(1:noUnique) = pack ( values, .not. duplicated )
        if ( verbose ) then
          call dump( inInds(1:noUnique), 'inInds(1:noUnique)' )
          call dump( heights(1:noUnique), 'heights(1:noUnique)' )
          call dump( values(1:noUnique), 'values(1:noUnique)' )
        end if
        call deallocate_test ( inInds, 'inInds', ModuleName )
      else
        noUnique = noPoints
      end if

      ! Now do the interpolation for the first instance
      ! Here's where, for incoherent quantities, we might
      ! interpolate separately for each instance if the user so wished
      call InterpolateValues ( heights(1:noUnique), values(1:noUnique), outHeights, &
        & outValues, 'Linear', extrapolate='Constant' )

        if ( verbose ) then
          call outputnamedValue( 'noUnique', noUnique )
          call dump( outValues, 'outValues' )
        end if
      if ( myLogSpace ) outValues = exp ( outValues )

      ! Work out what instances we're going to spread this to
      instances = .true.
      if ( instancesNode /= 0 ) then
        call GetIndexFlagsFromList ( instancesNode, instances, &
          & status, noError = .true. )
        if ( status /= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to parse instances (wrong units?)' )
      end if

      ! Spread it into the other instances, worry about the Mask and instances
      do i = 1, quantity%template%noInstances
        if ( instances(i) ) then
          j = 1
          do s = 1, quantity%template%noSurfs
            do c = 1, quantity%template%noChans
              if ( associated(quantity%Mask) ) then
                if ( iand ( ichar(quantity%Mask(j,i)), m_fill ) == 0 ) &
                  & quantity%values(j,i) = outValues(s)
              else
                quantity%values(j,i) = outValues(s)
              end if
              j = j + 1
            end do
          end do
        end if
      end do

      ! Finish off
      if ( localOutHeights ) call Deallocate_test ( outHeights, &
        & 'outHeights', ModuleName )
      call Deallocate_test ( heights, 'heights', ModuleName )
      call Deallocate_test ( values, 'values', ModuleName )
      call Deallocate_test ( outvalues, 'outvalues', ModuleName )
      call Deallocate_test ( duplicated, 'duplicated', ModuleName )
      call Deallocate_test ( instances, 'instances', ModuleName )
    9 call trace_end ( 'FillUtils_1.FromProfile_values', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine FromProfile_values

    ! -----------------------------------------  FromProfile_node  -----
    subroutine FromProfile_node ( quantity, valuesNode, &
      & instancesNode, globalUnit, ptan, logSpace, dontLatch )
      ! This fill is slightly complicated.  Given a values array along
      ! the lines of [ 1000mb : 1.0K, 100mb : 1.0K,  10mb : 2.0K] etc. it
      ! does the linear interpolation appropriate to perform the fill.
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      integer, intent(in) :: VALUESNODE   ! Tree node for values
      integer, intent(in) :: INSTANCESNODE ! Tree node for instances
      integer, intent(in) :: GLOBALUNIT   ! Possible global unit
      type (VectorValue_T), pointer :: PTAN ! press. values
      logical, intent(in), optional :: LOGSPACE ! Interpolate in logspace
      logical, intent(in), optional :: DONTLATCH ! Dont latch supplied heights

      ! Local variables
      integer :: HEIGHTUNIT             ! Unit for height
      integer :: NOPOINTS               ! Number of points supplied
      integer :: I                      ! Loop counters / indices
      integer :: TESTUNIT               ! Unit for value
      real (r8), dimension(:), pointer :: HEIGHTS ! Heights for the points
      real (r8), dimension(:), pointer :: VALUES ! Values for the points
      real (r8), dimension(2) :: EXPRVALUE ! Value of expression
      integer, dimension(2) :: EXPRUNIT ! Unit for expression
      integer :: Me = -1                ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.FromProfile_node', instancesNode, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! Check the quantity is amenable to this type of fill
      if ( .not. ValidateVectorQuantity ( quantity, &
        & coherent=.true. ) .and. .not. associated(ptan) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity is not amenable to a profile fill unless you supply ptan' )

      ! Check the units
      testUnit = quantity%template%unit
      if ( globalUnit /= phyq_Invalid ) testUnit = globalUnit

      ! Set some stuff up
      noPoints = nsons ( valuesNode ) - 1
      nullify ( heights, values )
      call Allocate_test ( heights, noPoints, 'heights', ModuleName )
      call Allocate_test ( values, noPoints, 'values', ModuleName )

      ! Loop over the values
      do i = 1, noPoints
        ! Get value from tree
        call expr ( subtree ( i+1, valuesNode ), exprUnit, exprValue )
        ! Check height unit OK
        heightUnit = GetUnitForVerticalCoordinate ( quantity%template%verticalCoordinate )
        if ( associated(ptan) ) heightUnit = PHYQ_Zeta
        if ( exprUnit(1) /= heightUnit .and. exprUnit(1) /= PHYQ_Dimensionless &
          & .and. .not. ( exprUnit(1) == PHYQ_Pressure .and. heightUnit == PHYQ_Zeta ) ) &
          & call Announce_Error ( valuesNode, no_Error_Code, 'Bad height units for profile fill' )
        ! Store height
        if ( heightUnit == PHYQ_Zeta ) then
          ! Assume zeta coordinates are expressed in mb
          heights(i) = -log10 ( exprValue(1) )
        else
          heights(i) = exprValue(1)
        end if
        ! Check value unit OK
        if ( all ( exprUnit(2) /= (/ testUnit, PHYQ_Dimensionless /) ) ) &
          & call Announce_Error ( valuesNode, no_error_code, 'Bad units for profile fill' )
        ! Store value
        values ( i ) = exprValue(2)
      end do

      call FromProfile( quantity, heights, values, &
        & instancesNode, globalUnit, ptan, logSpace, dontLatch )
      call Deallocate_test ( heights, 'heights', ModuleName )
      call Deallocate_test ( values, 'values', ModuleName )
      call trace_end ( 'FillUtils_1.FromProfile_node', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine FromProfile_node

    ! ----------------------------------------  ManipulateVectors  -----
    subroutine ManipulateVectors ( MANIPULATION, DEST, A, B, C, BOOLEANNAME )
    use MLSL2Options, only: RunTimeValues
    use MLSStrings, only: StrEq
      ! Manipulate common items in a, b, copying result to those in dest
      integer, intent(in) :: MANIPULATION
      type (Vector_T), intent(in)            :: A, B
      type (Vector_T), intent(inout)         :: DEST
      real(rv), optional                     :: C  ! constant "c" in manipulation
      character(len=*), intent(in), optional :: BOOLEANNAME

      ! Local variables
      type (VectorValue_T), pointer     :: DQ     ! Destination quantity
      type (VectorValue_T), pointer     :: AQ, BQ ! Source quantities
      integer                           :: SQI    ! Quantity index in source
      integer :: Me = -1                          ! String index for trace
      integer                           :: N
      character(len=64), dimension(128) :: NAMES
      character(len=64)                 :: QNAME

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ManipulateVectors', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      n = 0
      ! If we're given a BooleanName, try to interpret it as a container for
      ! quantity names
      if ( present(booleanName) ) then
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & lowerCase(trim(booleanName)), names, countEmpty, &
          & inseparator=runTimeValues%sep )
        n = FindLast( names /= runTimeValues%sep )
      end if
      ! First copy those things in source, loop over them
      dest%globalUnit = a%globalUnit
      do sqi = 1, size ( a%quantities )
        ! Try to find this in dest
        aq => a%quantities(sqi)
        bq => b%quantities(sqi)
        dq => GetVectorQtyByTemplateIndex ( dest, a%template%quantities(sqi) )
        if ( associated(aq) ) call get_string ( aq%template%name, qName, &
          & strip=.true. )
        if ( n > 0 ) then
          if ( .not. any( streq(names, qName, options='-cf' ) )  ) cycle
        else if ( all( (/ associated(aq), associated(bq), associated(dq) /) ) ) then
          call ByManipulation ( dq, aq, bq, &
            & manipulation, key=0, &
            & ignoreTemplate=.true., spreadflag=.false., dimList=' ', &
            & c=c )
        else
          call MLSMessage ( MLSMSG_Warning, ModuleName // '%ManipulateVectors', &
          & 'dq not associated' )
        end if
      end do
      call trace_end ( 'FillUtils_1.ManipulateVectors', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ManipulateVectors

    ! -------------------------------------------  WithBinResults  -----
    subroutine WithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
      & channel, method, additional, excludeBelowBottom, centerVertically )
      ! This fills a coherent quantity with the max/min binned value of
      ! a typically incoherent one.  The bins are centered horizontally
      ! on the profiles in quantity, but vertically the bins run between one
      ! surface and the next one up.
      !
      ! SourceQuantity has the target attribute so that we can take a pointer
      ! to SourceQuantity%template%surfs.
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in), target :: SOURCEQUANTITY
      type (VectorValue_T), pointer :: PTANQUANTITY
      integer, intent(in) :: CHANNEL
      integer, intent(in) :: METHOD
      logical, intent(in) :: ADDITIONAL
      logical, intent(in) :: EXCLUDEBELOWBOTTOM
      logical, intent(in) :: CENTERVERTICALLY

      ! Local variables
      real(r8), dimension(:,:), pointer :: SOURCEHEIGHTS ! might be ptan.
      real(r8), dimension(:), pointer :: PHIBOUNDARIES
      real(r8) :: V                     ! A value
      integer, dimension(:,:), pointer :: SURFS ! Surface mapping source->quantity
      integer, dimension(:,:), pointer :: INSTS ! Instance mapping source->quantity
      integer :: QS, QI, SS, SI                   ! Loop counters
      integer :: Me = -1                ! String index for trace
      integer :: MYCHANNEL              ! Channel or 1
      integer :: NumQtyInstances        ! E.g., num MAFs
      integer :: NumSourceInstances     ! E.g., num MAFs
      logical :: ExtraProfile           ! True when profile stands outside chunk

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.WithBinResults', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )

      ! Check the output quantity
      if ( .not. ValidateVectorQuantity ( quantity, &
        & coherent=.true., stacked=.true. ) ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Illegal quantity for bin min/max/total fill' )

      ! Also should have the condition:
      !  quantityType = (/ sourceQuantity%template%quantityType /)
      ! However, the code does not yet really support the ability to do that.
      ! We are alert for the case when HGrid inserted an otherwise
      ! "dropped" profile
      ! This profile will have a phi greater than the chunk-bounding last MAF's phi
      NumSourceInstances = size(sourceQuantity%template%phi, 2)
      NumQtyInstances = size(Quantity%template%phi, 2)
      ExtraProfile = ( quantity%template%noInstances > 1 ) .and. &
        & ( sourceQuantity%template%phi(1,NumSourceInstances) < &
        & quantity%template%phi(1, NumQtyInstances) )

      ! Work out source vertical coordinate
      if ( associated ( ptanQuantity ) .and. sourceQuantity%template%minorFrame ) then
        nullify ( sourceHeights )
        call Allocate_test ( sourceHeights, sourceQuantity%template%nosurfs, &
          & sourceQuantity%template%noinstances, 'sourceHeights', ModuleName )
        sourceHeights = ptanQuantity%values
        if ( quantity%template%verticalCoordinate /= l_zeta .and. WARNIFVERTCOORDNOTZETA ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Vertical coordinate in quantity to fill is not zeta' )
      else
        sourceHeights => sourceQuantity%template%surfs
        if ( sourceQuantity%template%verticalCoordinate /= quantity%template%verticalCoordinate ) then
          call dump ( quantity%template )
          call dump ( sourceQuantity%template )
          call outputNamedValue( 'source is minor frame?', sourceQuantity%template%minorFrame )
          call outputNamedValue( 'associated(ptanQuantity)?', associated(ptanQuantity) )
          call Announce_Error ( key, no_error_code, &
          & 'Vertical coordinates in binned fill do not match' )
        end if
      end if

      ! Setup index arrays
      nullify ( surfs, insts )
      call Allocate_test ( surfs, sourceQuantity%template%nosurfs, &
        & sourceQuantity%template%noinstances, 'surfs', ModuleName )
      call Allocate_test ( insts, sourceQuantity%template%nosurfs, &
        & sourceQuantity%template%noinstances, 'insts', ModuleName )

      ! Work out the vertical mapping, a function of instance for
      ! incoherent quantities
      if ( sourceQuantity%template%coherent ) then
        call Hunt ( quantity%template%surfs(:,1), sourceHeights(:,1), surfs(:,1), &
          & allowTopValue=.true., allowBelowValue=excludeBelowBottom, nearest=centerVertically )
        surfs = spread ( surfs(:,1), 2, sourceQuantity%template%noInstances )
      else
        do si = 1, sourceQuantity%template%noInstances
          call Hunt ( quantity%template%surfs(:,1), sourceHeights(:,si), surfs(:,si), &
            & allowTopValue=.true., allowBelowValue=excludeBelowBottom, nearest=centerVertically )
        end do
      end if

!      call dump ( surfs, 'surfs' )

      if ( quantity%template%noInstances > 1 ) then
        ! Setup and work out the phiBoundaries
        nullify ( phiBoundaries )
        call Allocate_test ( phiBoundaries, quantity%template%noInstances-1, &
          & 'phiBoundaries', ModuleName )
        phiBoundaries = 0.5 * ( &
          & quantity%template%phi(1,1:quantity%template%noInstances-1) + &
          & quantity%template%phi(1,2:quantity%template%noInstances) )
        if ( sourceQuantity%template%stacked ) then
          call Hunt ( phiBoundaries, sourceQuantity%template%phi(1,:), &
            & insts(1,:), allowTopValue=.true., allowBelowValue=.true. )
          insts = spread ( surfs(1,:), 1, sourceQuantity%template%noSurfs ) + 1
        else
          do ss = 1, sourceQuantity%template%noSurfs
            call Hunt ( phiBoundaries, sourceQuantity%template%phi(ss,:), &
              & insts(ss,:), allowTopValue=.true., allowBelowValue=.true. )
          end do
          insts = insts + 1
        end if
        if ( method==l_binTotal .and. .false. ) then
          call outputNamedValue( 'phiBoundaries', phiBoundaries )
          call outputNamedValue( 'phi(source)', sourceQuantity%template%phi(1,:) )
        end if
        call Deallocate_test ( phiBoundaries, 'phiBoundaries', ModuleName )
      else
        insts = 1
      end if

!      call dump ( insts, 'insts' )

      ! Modify the surfs index to account for the channel, so now it's more
      ! of a 'values' index
      if ( sourceQuantity%template%frequencyCoordinate /= l_none .and. &
        & channel == 0 ) then
        call Announce_Error ( key, no_error_code, &
          & 'Must supply channel for this bin max/min fill' )
        go to 9
      end if
      myChannel = channel
      if ( channel == 0 ) myChannel = 1

      ! Now loop over the output quantity points and work out the information
      if ( ExtraProfile ) then
        do qs = 1, quantity%template%noSurfs
          if ( count ( surfs == qs ) > 0 ) then
            select case ( method )
            case  ( l_binMax )
              ! Compute the maximum value in the bin
              v = maxval ( pack ( sourceQuantity%values ( &
                & myChannel : sourceQuantity%template%instanceLen : &
                &   sourceQuantity%template%noChans, 1 ), &
                & surfs(:,1) == qs ) )
              if ( additional ) then
                quantity%values(qs,:) = max ( quantity%values(qs,:), v )
              else
                quantity%values(qs,:) = v
              end if
            case ( l_binMean )
              ! Compute the average in the bin, be careful about dividing by zero
              v = sum ( pack ( sourceQuantity%values ( &
                & myChannel : sourceQuantity%template%instanceLen : &
                &   sourceQuantity%template%noChans, 1 ), &
                & surfs(:,1) == qs ) ) / &
                & max ( count ( surfs(:,1) == qs ), 1 )
              if ( additional ) then
                quantity%values(qs,:) = 0.5 * ( quantity%values(qs,:) + v )
              else
                quantity%values(qs,:) = v
              end if
            case ( l_binMin )
              ! Compute the minimum value in the bin
              v = minval ( pack ( sourceQuantity%values ( &
                & myChannel : sourceQuantity%template%instanceLen : &
                &   sourceQuantity%template%noChans, 1 ), &
                & surfs(:,1) == qs ) )
              if ( additional ) then
                quantity%values(qs,:) = min ( quantity%values(qs,:), v )
              else
                quantity%values(qs,:) = v
              end if
            case ( l_binTotal )
              ! Compute the total in the bin
              v = sum ( pack ( sourceQuantity%values ( &
                & myChannel : sourceQuantity%template%instanceLen : &
                &   sourceQuantity%template%noChans, 1 ), &
                & surfs(:,1) == qs ) )
              if ( additional ) then
                quantity%values(qs,:) = quantity%values(qs,:) + v
              else
                quantity%values(qs,:) = v
              end if
            end select
          else
            quantity%values(qs,:) = 0.0
          end if
        end do
      else
        do qi = 1, quantity%template%noInstances
          do qs = 1, quantity%template%noSurfs
            if ( count ( surfs == qs .and. insts == qi ) > 0 ) then
              select case ( method )
              case  ( l_binMax )
                ! Compute the maximum value in the bin
                v = maxval ( pack ( sourceQuantity%values ( &
                  & myChannel : sourceQuantity%template%instanceLen : &
                  &   sourceQuantity%template%noChans, : ), &
                  & surfs == qs .and. insts == qi ) )
                if ( additional ) then
                  quantity%values(qs,qi) = max ( quantity%values(qs,qi), v )
                else
                  quantity%values(qs,qi) = v
                end if
              case ( l_binMean )
                ! Compute the average in the bin, be careful about dividing by zero
                v = sum ( pack ( sourceQuantity%values ( &
                  & myChannel : sourceQuantity%template%instanceLen : &
                  &   sourceQuantity%template%noChans, : ), &
                  & surfs == qs .and. insts == qi ) ) / &
                  & max ( count ( surfs == qs .and. insts == qi ), 1 )
                if ( additional ) then
                  quantity%values(qs,qi) = 0.5 * ( quantity%values(qs,qi) + v )
                else
                  quantity%values(qs,qi) = v
                end if
              case ( l_binMin )
                ! Compute the minimum value in the bin
                v = minval ( pack ( sourceQuantity%values ( &
                  & myChannel : sourceQuantity%template%instanceLen : &
                  &   sourceQuantity%template%noChans, : ), &
                  & surfs == qs .and. insts == qi ) )
                if ( additional ) then
                  quantity%values(qs,qi) = min ( quantity%values(qs,qi), v )
                else
                  quantity%values(qs,qi) = v
                end if
              case ( l_binTotal )
                ! Compute the total in the bin
                v = sum ( pack ( sourceQuantity%values ( &
                  & myChannel : sourceQuantity%template%instanceLen : &
                  &   sourceQuantity%template%noChans, : ), &
                  & surfs == qs .and. insts == qi ) )
                if ( additional ) then
                  quantity%values(qs,qi) = quantity%values(qs,qi) + v
                else
                  quantity%values(qs,qi) = v
                end if
              end select
            else
              quantity%values(qs,qi) = 0.0
            end if
          end do
        end do
      end if
      ! Now tidy up
      call Deallocate_test ( surfs, 'surfs', ModuleName )
      call Deallocate_test ( insts, 'insts', ModuleName )
      if ( associated ( ptanQuantity ) .and. sourceQuantity%template%minorFrame ) &
        & call Deallocate_test ( sourceHeights, 'sourceHeights', ModuleName )
    9 call trace_end ( 'FillUtils_1.WithBinResults', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine WithBinResults

    ! --------------------------------------  WithBoxcarFunction   -----
    subroutine WithBoxcarFunction ( key, quantity, sourceQuantity, &
    & width, method, ignoreTemplate )
      integer, intent(in) :: KEY        ! Key for tree node
      type (VectorValue_T), intent(inout)      :: QUANTITY
      type (VectorValue_T), intent(in), target :: SOURCEQUANTITY
      integer, intent(in)                      :: WIDTH
      integer, intent(in)                      :: METHOD  ! L_MEAN, L_MAX, L_MIN
      logical, intent(in)              ::         IGNORETEMPLATE

      ! Local variables
      integer :: I, I1, I2              ! Instance indices
      integer :: HALFWIDTH
      integer :: Me = -1                ! String index for trace
      real(r8), dimension(:,:), pointer :: OLDVALUES

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.WithBoxcarFunction', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( .not. ignoreTemplate .and. &
        & quantity%template%name /= sourceQuantity%template%name ) then
        call Announce_Error ( key, no_error_code, 'Quantity and source quantity do not match' )
        go to 9
      end if
      if ( width <= 1 .or. mod ( width, 2 ) == 0 ) then
        call Announce_Error ( key, no_error_code, 'width must be greater than 1 and odd' )
        go to 9
      end if

      if ( associated ( quantity%values, sourceQuantity%values ) ) then
        nullify ( oldValues )
        call Allocate_test ( oldValues, quantity%template%instanceLen, quantity%template%noInstances, &
          & 'oldValues', ModuleName )
        oldValues = sourceQuantity%values
      else
        oldValues => sourceQuantity%values
      end if

      halfWidth = width/2
      select case ( method )
      case ( l_mean )
        do i = 1, quantity%template%noInstances
          i1 = max ( i - halfWidth, 1 )
          i2 = min ( i + halfWidth, quantity%template%noInstances )
          quantity%values(:,i) = sum ( oldValues(:,i1:i2), dim=2 ) / (i2-i1+1)
        end do
      case ( l_min )
        do i = 1, quantity%template%noInstances
          i1 = max ( i - halfWidth, 1 )
          i2 = min ( i + halfWidth, quantity%template%noInstances )
          quantity%values(:,i) = minval ( oldValues(:,i1:i2), dim=2 )
        end do
      case ( l_max )
        do i = 1, quantity%template%noInstances
          i1 = max ( i - halfWidth, 1 )
          i2 = min ( i + halfWidth, quantity%template%noInstances )
          quantity%values(:,i) = maxval ( oldValues(:,i1:i2), dim=2 )
        end do
      end select

      if ( associated ( quantity%values, sourceQuantity%values ) ) then
        call Deallocate_test ( oldValues, 'oldValues', ModuleName )
      end if
    9 call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine WithBoxcarFunction

    ! -----------------------------------  OffsetRadianceQuantity  -----
    subroutine OffsetRadianceQuantity ( quantity, radianceQuantity, amount )
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in) :: RADIANCEQUANTITY
      real (rv), intent(in) :: AMOUNT

      integer :: Me = -1                  ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.OffsetRadianceQuantity', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity for offsetRadiance fill is not radiance' )
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Radiance quantity for offsetRadiance fill is not radiance' )
      if ( quantity%template%signal /= radianceQuantity%template%signal .or. &
        & quantity%template%sideband /= radianceQuantity%template%sideband ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity and rad. qty. in offsetRadiance fill different signal/sideband' )
      if ( associated ( radianceQuantity%Mask ) ) then
        where ( iand ( ichar(radianceQuantity%Mask), M_LinAlg ) /= 0 )
          quantity%values = quantity%values + amount
        end where
      end if
      call trace_end ( cond=toggle(gen) .and. levels(gen) > 2 )
    end subroutine OffsetRadianceQuantity

    ! -----------------------------------  ResidualCorrection  -----
    ! Note that 
    ! (1) this must be called after applying the baseliine
    ! (2) the radiances vector must be a different vector from the one
    !     that contains the quantity (to avoid being stepped on by
    !     successive calls to this routine)
    subroutine ResidualCorrection ( key, quantity, sourceradiances, filename )
      use Io_Stuff, only: Get_Lun, Read_Textfile
      use Lexer_Core, only: Get_Where
      use Machine, only: Io_Error
      use MLSNumerics, only: F_Of_X
      use MLSSignals_m, only: Signal_T, Signals, GetBandName
      use Tree, only: Where
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (Vector_T), intent(in) :: SOURCERADIANCES
      integer, intent(in) :: FILENAME   ! Str indexx of ASCII filename to read from
      ! The Filename should be something like
      ! /users/pwagner/docs/mls/l2based_extended_residual_corrections.txt
      integer :: LUN                    ! Unit number
      integer :: Me = -1                ! String index for trace
      integer :: STATUS                 ! Flag from open/close/read etc.
      character(len=1024) :: FILENAMESTR
      character(len=1024) :: inputPhysicalFilename
      ! ---------- Algorithm -----------
      ! Bw(25) = 96,96,96,64,64,64,48,32,24,16,12,8,6,8,12,16,24,32,48,64,64,64,96,96,96
      ! 
      ! X(2:6) = 1,9,1,1,1
      ! 
      ! Y(2:6) = 23,24,25,25,25
      ! 
      !  
      ! 
      ! Tavg(mif,maf) = sum(b=2,6) sum(c=x(b),y(b)) I(b,c,mif,maf) * BW(c)
      ! 
      !  
      ! 
      ! Tavg(mif,maf) = (Tavg(mif,maf) + 962.670 * I(2,1,mif,maf)
      ! 
      ! + 0.5*(I(4,1,mif,maf) + I(5,25,mif,maf))*909.000
      ! 
      ! + 0.5*(I(5,1,mif,maf) + I(6,1,mif,maf))*534.000
      ! 
      ! + I(6,25,mif,maf)*1140.330) / 8928.04
      !
      ! Note that the only bands 2,3 and 4 are corrected. 
      ! Not bands 5, 6, 23, and 27.

      integer, dimension(25), parameter :: Bw = &
        & (/ 96,96,96,64,64,64,48,32,24,16,12,8,6,8,12,16,24,32,48,64,64,64,96,96,96 /)
      integer, dimension(6), parameter :: X = &
        & (/-999, 1,9,1,1,1 /)
      integer, dimension(6), parameter :: Y = &
        & (/-999, 23,24,25,25,25 /)
      ! ------------------------------------------------------------------
      ! These are what GetBandName currently returns from the signal type
      ! for Bands 2, 3, and 4
      ! If a future revision to the l2cf or to to signal type changes that
      ! then this routine may stop working properly
      ! ------------------------------------------------------------------
      character(len=*), parameter :: BandNames = 'B2F:H2O,B3F:N2O,B4F:HNO3' 
      ! ------------------------------------------------------------------
      ! The next array holds the coefficients of our lookup table for
      ! bands 2, 3, and 4 (the final index of the big array) and
      ! for the 25 channels (the middle index) and 19 possible values
      ! of Tavg.
      ! If the format or size of the ascii file holding coefficients
      ! change, then this routine may stop working properly
      real(r4), dimension(19, 25, 3) :: Coef
      real(r4), dimension(19)        :: Tf    ! These are the reference T vals
      ! This is the content of the Lookup file
      character(len=80), dimension(400) :: string  
      integer :: band
      character(32) :: BandName
      integer :: BandNumber
      integer :: channel
      integer :: line
      integer :: maf
      integer :: mif
      integer :: NLines
      integer :: NoChannels
      integer :: NoMIFs
      integer :: NoMAFs
      integer :: p1, p2
      integer :: ref
      type (VectorValue_T), pointer :: SQ ! Source quantity
      integer :: SQI                      ! Quantity index in source
      character, parameter :: null = char(0)
      real(r4) :: Tavg
      real(r4) :: Tmin
      real(r4) :: Tmax
      real(r4), dimension(6, 25) :: I
      logical :: NegativeSort ! If true, Tf are negatively sorted
      logical :: verbose
      ! Executable code
      verbose = ( BeVerbose( 'residual', -1 ) )
      string = null
      call trace_begin ( me, 'FillUtils_1.ResidualCorrection', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity for offsetRadiance fill is not radiance' )
      call GetBandName( signals(quantity%template%signal)%band, bandname )
      if ( verbose ) then
        call outputNamedValue ( 'Band name', trim(BandName) )
        call Dump( quantity%values(:,1), 'values before correction (maf 1)' )
      endif
      ! BandNumber must be in the range {2,3,4} to be correctable
      ! StringElementNum returns {1,2,3} or else 0
      BandNumber = StringElementNum( BandNames, trim(BandName), countEmpty ) + 1
      if ( BandNumber < 2 .or. BandNumber > 4 ) return
      NoMAFs = quantity%template%noInstances
      NoMIFs = quantity%template%noSurfs ! 125
      NoChannels = quantity%template%noChans ! 125
      call get_lun ( lun, msg=.false. )
      if ( lun < 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "No logical unit numbers available" )
      call Get_String ( filename, filenameStr, strip=.true. )
      call returnFullFileName( filenameStr, inputPhysicalFilename, &
        & MLSPCF_l2ascii_start, MLSPCF_l2ascii_end )
      if ( verbose ) then
        call outputNamedValue ( 'string fragment', trim(filenameStr) )
        call outputNamedValue ( 'full path', trim(inputPhysicalFilename) )
      endif
      open ( unit=lun, file=inputPhysicalFilename, status='old', form='formatted', &
        & access='sequential', iostat=status )
      if ( status /= 0 ) then
        call io_Error ( "Unable to open ASCII input file ", status, inputPhysicalFilename )
        call get_where ( where(key), inputPhysicalFilename, before='Error opening ASCII file at ' )
        call MLSMessage( MLSMSG_Error, ModuleName, inputPhysicalFilename )
      end if
      ! Trying to read the file:
      call Read_Textfile ( inputPhysicalFilename, string, maxLineLen=80, nLines=nLines )
      if ( nLines < 1 ) then
        call io_Error ( "Unable to properly read ASCII input file ", nLines, inputPhysicalFilename )
        call get_where ( where(key), inputPhysicalFilename, before='Error reading ASCII file at ' )
        call MLSMessage( MLSMSG_Error, ModuleName, inputPhysicalFilename )
      endif
      if ( verbose ) call OutputNamedValue ( 'number of lines read', nLines )
      do line=1, NLines
        string(line) = asciify( string(line), how='snip' )
      enddo
      ! Ignoring first three lines, first we obtain the reference T vals
      line = 4
      call ReadNumsFromList ( &
        & trim(string(line)) // ' ' // &
        & trim(string(line+1)) // ' ' // &
        & trim(string(line+2)) // ' ' // &
        & trim(string(line+3)), Tf, separator=' ' )
!       call dump( Tf, name='Reference Temperatures' )
      NegativeSort = ( Tf(2) < Tf(1) )
      if ( verbose ) &
        & call OutputNamedValue ( 'T(ref) sorted from large to small?', NegativeSort )
      line = line + 4
      do band = 2,4 ! Loop over bands
        ! Ignore the string announcing the band number
        line = line + 1
        do ref=1, 19 ! Loop over reference Temperatures
          ! Ignore the string announcing the Temperature
          line = line + 1
          call ReadNumsFromList ( &
            & trim(string(line)) // ' ' // &
            & trim(string(line+1)) // ' ' // &
            & trim(string(line+2)) // ' ' // &
            & trim(string(line+3)) // ' ' // &
            & trim(string(line+4)), Coef(ref,:,band-1), separator=' ' )
          line = line + 5
        enddo
      enddo
      ! How were the Tvalues sorted? 
      ! Smallest to largest, or largest to smallest?
!       call dump( Coef(:,:,1), name='Coeffficients for Band 2' )
!       call dump( Coef(:,:,2), name='Coeffficients for Band 3' )
!       call dump( Coef(:,:,3), name='Coeffficients for Band 4' )
!       call trace_end ( cond=toggle(gen) .and. levels(gen) > 2 )
      ! Now we get down to business
      ! Compute the Tavg
!      Changes to make in the following:
! Tavg should be a scalar
! I should be a 2d array I(b,c)
      Tmin = 9999.
      Tmax = -9999.
      do maf=1, NoMAFs
        do mif=1, NoMIFs
          Tavg = 0.
          do band=2, 6
            sqi = band - 1 ! We'll assume the source quanitites are ordered so
            sq => sourceRadiances%quantities(sqi)
            do channel=x(band), y(band)
              Tavg = Tavg + &
                & sq%values(channel + (mif-1)*NoChannels, maf) * BW(channel)
            enddo ! Loop of channels
          enddo ! Loop of bands
          
          ! p1:p2 represent all the channels for a given mif
          p1 = 1 + (mif-1)*NoChannels
          p2 = mif*NoChannels

          ! Now some  special Band-specific terms
          ! We'll need Bands 2, 4, 5, and 6
          I = 0.

          band = 2
          sqi = band - 1
          sq => sourceRadiances%quantities(sqi)
          I(band, :) = sq%values(p1:p2, maf)

          band = 4
          sqi = band - 1
          sq => sourceRadiances%quantities(sqi)
          I(band, :) = sq%values(p1:p2, maf)

          band = 5
          sqi = band - 1
          sq => sourceRadiances%quantities(sqi)
          I(band, :) = sq%values(p1:p2, maf)

          band = 6
          sqi = band - 1
          sq => sourceRadiances%quantities(sqi)
          I(band, :) = sq%values(p1:p2, maf)

          Tavg = (Tavg + 962.670 * I(2,1) &
          + 0.5*(I(4,1) + I(5,25))*909.000 &
          + 0.5*(I(5,1) + I(6,1))*534.000 &
          + I(6,25)*1140.330) / 8928.04
          Tmin = min( Tmin, Tavg )
          Tmax = max( Tmax, Tavg )
          ! Now use the Look-up table with coefficients Coef
          ! Note that 
          ! (1) we subtract the corrections
          ! (2) we interpolate (options='-pi')
          ! (3) if Tf are sorted largest to smallest multiply them by -1
          do channel=1, NoChannels
            if ( NegativeSort ) then
              quantity%values(channel + (mif-1)*NoChannels, maf) = &
                & quantity%values(channel + (mif-1)*NoChannels, maf) &
                & - &
                & F_Of_X ( -Tavg, -Tf, Coef(:, channel, BandNumber-1), options='-pi')
            else
              quantity%values(channel + (mif-1)*NoChannels, maf) = &
                & quantity%values(channel + (mif-1)*NoChannels, maf) &
                & - &
                & F_Of_X ( Tavg, Tf, Coef(:, channel, BandNumber-1), options='-pi')
            endif
          enddo ! Loop of channels
        enddo ! Loop of mifs
      enddo ! Loop of mafs
      if ( verbose ) then
        call Dump( quantity%values(:,1), 'values after correction (maf 1)' )
        call outputNamedValue ( 'Tmin', Tmin )
        call outputNamedValue ( 'Tmax', Tmax )
      endif
      sqi = bandNumber - 1
      sq => sourceRadiances%quantities(sqi)
      if ( verbose ) call Diff( quantity%values, 'original', &
        & sq%values, 'corrected', options='@@' )
      call trace_end ( cond=toggle(gen) .and. levels(gen) > 2 )

    end subroutine ResidualCorrection

    ! -------------------------------------  ResetUnusedRadiances  -----
    subroutine ResetUnusedRadiances ( quantity, amount )
      type (VectorValue_T), intent(inout) :: QUANTITY
      real (rv), intent(in) :: AMOUNT

      integer :: Me = -1                    ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ResetUnusedRadiances', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity for resetUnusedRadiances fill is not radiance' )
      where ( quantity%values > amount*0.9 )
        quantity%values = quantity%values - amount
      end where
      call trace_end ( cond=toggle(gen) .and. levels(gen) > 2 )
    end subroutine ResetUnusedRadiances

    ! --------------------------------------  RotateMagneticField  -----
    subroutine RotateMagneticField ( key, qty, fieldECR, ecrToFOV )
      integer, intent(in) :: KEY        ! Where are we in the l2cf?
      type (VectorValue_T), intent(inout) :: QTY ! The quantity to fill
      type (VectorValue_T), intent(in) :: FIELDECR ! The input field
      type (VectorValue_T), intent(in) :: ECRTOFOV ! The rotation matrix
      ! Local variables
      integer :: CROSS                  ! Loop counter
      integer :: INSTANCE               ! Loop counter
      integer :: SURFACE                ! Loop counter
      integer :: MAF(1)                 ! Which MAF is the best match to this instance
      integer :: Me = -1                ! String index for trace
      real(r8) :: THISFIELD(3)          ! A magnetic field vector
      real(r8) :: ROTATION(3,3)         ! One rotation matrix
      real(r8) :: STRENGTH              ! The field strength

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.RotateMagneticField', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      ! Do some sanity checks
      if ( .not. any ( qty%template%quantityType == &
        & (/ l_fieldStrength, l_fieldAzimuth, l_fieldElevation /) ) ) then
        call Announce_Error ( key, no_error_code, 'Inappropriate quantity for this fill' )
        go to 9
      end if
      if ( .not. DoHGridsMatch ( qty, fieldECR ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Field and result quantity must have matching hGrids' )
        go to 9
      end if
      if ( .not. DoVGridsMatch ( qty, fieldECR ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Field and result quantity must have matching vGrids' )
        go to 9
      end if

      do instance = 1, qty%template%noInstances
        ! Identify the relevant MAF and pull out the first MIF's rotation matrix
        ! (first MIF is probably close enough to all the others to be useful).
        maf = 1
        ! If the template isn't stacked, Phi is meaningless, and has zero size.
        if ( allocated(qty%template%phi) .and. qty%template%stacked ) &
          & maf = minloc ( abs ( qty%template%phi(1,instance) - &
            & ecrToFOV%template%phi(1,:) ) )
        ! Dimensions of ECRtoFOV%value3 are ( chans, surfs, instances*cross angles ).
        ! Chans is actually 3x3, so we need to reform it.
        rotation = reshape ( ecrToFOV%value3( 1:9, 1, maf), (/ 3, 3 /) )
        ! Now loop over the pressure levels in the input and output field information
        ! qty%value3 isn't the right pointer to use, because its dimensions are
        ! ( channels, surfaces, instances*cross angles ), not
        ! ( channels*surfaces, instances, cross angles ).
        do surface = 1, qty%template%noSurfs
          do cross = 1, qty%template%noCrossTrack
            ! Now rotate the field from ECR into IFOVPP coordinates
            thisField = matmul ( rotation, &
                               & fieldECR%value4 ( 1:3, surface, instance, cross ) )
            ! Now work out the strength / angles as appropriate.
            strength = norm2 ( thisField )
            select case ( qty%template%quantityType )
            case ( l_fieldStrength )
              qty%value4(1,surface,instance,cross) = strength
            case ( l_fieldElevation )
              if ( strength /= 0.0_r8 ) then
                ! Elevation is constrained to 0--90 degrees instead of 0--180 degrees because
                ! radiative transfer Physics is symmetric.  We save half of l2pc bins.
                qty%value4(1,surface,instance,cross) = &
                  & acos ( abs ( thisField(3) / strength ) ) * rad2deg
              else
                qty%value4(1,surface,instance,cross) = 0.0
              end if
            case ( l_fieldAzimuth )
              if ( thisField(1) /= 0.0_r8 ) then
                qty%value4(1,surface,instance,cross) = &
                  & atan2 ( thisField(2), thisField(1) ) * rad2deg
              else
                qty%value4(1,surface,instance,cross) = &
                  & merge ( 90.0_r8, -90.0_r8, thisField(1) > 0.0_r8 )
              end if
            end select
          end do
        end do
      end do
    9 call trace_end ( 'FillUtils_1.RotateMagneticField', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine RotateMagneticField

    ! --------------------------------------------  ScaleOverlaps  -----
    subroutine ScaleOverlaps ( quantity, multiplierNode )
      type (VectorValue_T), intent(inout) :: QUANTITY
      integer, intent(in) :: MULTIPLIERNODE ! Tree node for factors
      ! Local variables
      real (r8) :: exprValue(2)         ! Tree expression
      integer :: exprUnit(2)            ! Tree units
      integer :: i,j                    ! Loop counters / indices
      integer :: Me = -1                ! String index for trace

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.ScaleOverlaps', multiplierNode, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      scaleLowerLoop: do i = 1, quantity%template%noInstancesLowerOverlap
        if ( i+1 > nsons ( multiplierNode ) ) exit scaleLowerLoop
        call expr_check ( subtree( i+1, multiplierNode ), exprUnit, exprValue, &
          & (/PHYQ_Dimensionless/), unitsError )
        if ( unitsError ) then
          call Announce_Error ( multiplierNode, wrongUnits, &
            & extraMessage="for scaleOverlaps fill", &
            & extraInfo=(/exprUnit(1), PHYQ_Dimensionless/) )
          go to 9
        end if
        if ( associated ( quantity%Mask ) ) then
          where ( iand ( ichar(quantity%Mask(:,i)), m_Fill ) == 0 )
            quantity%values ( :, i ) = quantity%values ( :, i ) * exprValue(1)
          end where
        else
          quantity%values ( :, i ) = quantity%values ( :, i ) * exprValue(1)
        end if
      end do scaleLowerLoop

      scaleUpperLoop: do i = quantity%template%noInstances, &
        & quantity%template%noInstances - &
        & quantity%template%noInstancesUpperOverlap + 1, - 1
        j = quantity%template%noInstances - i + 1
        if ( j+1 > nsons ( multiplierNode ) ) exit scaleUpperLoop
        call expr_check ( subtree( j+1, multiplierNode ), exprUnit, exprValue, &
          & (/PHYQ_Dimensionless/), unitsError )
        if ( unitsError ) then
          call Announce_Error ( multiplierNode, wrongUnits, &
            & extraMessage="for scaleOverlaps fill", &
            & extraInfo=(/exprUnit(1), PHYQ_Dimensionless/) )
          go to 9
        end if
        if ( associated ( quantity%Mask ) ) then
          where ( iand ( ichar(quantity%Mask(:,i)), m_Fill ) == 0 )
            quantity%values ( :, i ) = quantity%values ( :, i ) * exprValue(1)
          end where
        else
          quantity%values ( :, i ) = quantity%values ( :, i ) * exprValue(1)
        end if
      end do scaleUpperLoop
    9 call trace_end ( 'FillUtils_1.ScaleOverlaps', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine ScaleOverlaps

    ! ----------------------------------------  SpreadChannelFill  -----
    subroutine SpreadChannelFill ( quantity, channel, key, &
      & sourceQuantity )
      type(VectorValue_T), intent(inout) :: QUANTITY
      integer, intent(in) :: CHANNEL
      integer, intent(in) :: KEY
      type(VectorValue_T), intent(in), optional :: SOURCEQUANTITY
      ! Local variables
      integer :: I                      ! Instance loop counter
      integer :: C                      ! Channel loop counter
      integer :: S                      ! Surface loop counter
      integer :: J                      ! Destination index
      integer :: Me = -1                ! String index for trace
      integer :: MYCHANNEL              ! Possibly offset channel
      type (Signal_T) ::  signal        ! Signal for this quantity

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.SpreadChannelFill', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( present(sourceQuantity) ) then
        do i = 1, quantity%template%noInstances
          do s = 1, quantity%template%noSurfs
            do c = 1, quantity%template%noChans
              j = (s-1)*quantity%template%noChans + c
              if ( associated ( quantity%Mask ) ) then
                if ( iand ( ichar(quantity%Mask(j,i)), m_Fill ) == 1 ) cycle
              end if
              quantity%values ( j, i ) = &
                & sourceQuantity%values ( s, i )
            end do
          end do
        end do
      else
        ! Deal with any channel numbering issues.
        signal = GetSignal ( quantity%template%signal )
        myChannel = channel - lbound ( signal%frequencies, 1 ) + 1
        if ( myChannel < 1 .or. myChannel > quantity%template%noChans ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Invalid channel for spread channel' )
        do i = 1, quantity%template%noInstances
          do s = 1, quantity%template%noSurfs
            do c = 1, quantity%template%noChans
              if ( c == myChannel ) cycle
              j = (s-1)*quantity%template%noChans + c
              if ( associated ( quantity%Mask ) ) then
                if ( iand ( ichar(quantity%Mask(j,i)), m_Fill ) == 1 ) cycle
              end if
              quantity%values ( j, i ) = &
                & quantity%values ( (s-1)*quantity%template%noChans + myChannel, i )
            end do
          end do
        end do
      end if
      call trace_end ( 'FillUtils_1.SpreadChannelFill', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine SpreadChannelFill

    ! ------------------------------------------  TransferVectors  -----
    subroutine TransferVectors ( source, dest, &
      & expandMask, skipMask, skipValues, interpolate, &
      & booleanname )
    use MLSL2Options, only: RunTimeValues
    use MLSStrings, only: StrEq
      ! Copy common items in source to those in dest
      type (Vector_T), intent(in) :: SOURCE
      type (Vector_T), intent(inout) :: DEST
      logical, intent(in) :: ExpandMask
      logical, intent(in) :: SKIPMask
      logical, intent(in) :: SKIPValues
      logical, intent(in) :: INTERPOLATE
      character(len=*), intent(in), optional :: BOOLEANNAME

      ! Local variables
      type (VectorValue_T), pointer :: DQ ! Destination quantity
      type (VectorValue_T), pointer :: SQ ! Source quantity
      integer :: Me = -1                  ! String index for trace
      integer                           :: N
      character(len=64), dimension(128) :: NAMES
      character(len=64)                 :: QNAME
      integer :: SQI                      ! Quantity index in source
      logical :: verbose, verboser

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.TransferVectors', &
        & cond=toggle(gen) .and. levels(gen) > 2  )
      verbose = ( BeVerbose( 'bool', -1 ) )
      verboser = ( switchDetail(switches, 'bool') > 0 )
      ! Can't have /interpolate and /skipValues at the same time
      if ( interpolate .and. skipValues ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "May not have both /interpolate and /skipValues" )
      ! Can't have /skipMask and /expandMask at the same time
      if ( skipMask .and. expandMask ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "May not have both /skipMask and /expandMask" )

      n = 0
      ! If we're given a BooleanName, try to interpret it as a container for
      ! quantity names
      if ( present(booleanName) ) then
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & lowerCase(trim(booleanName)), names, countEmpty, &
          & inseparator=runTimeValues%sep )
        n = FindLast( names /= runTimeValues%sep )
        if ( verboser .and. n > 0 ) then
          call outputNamedValue( 'n', n )
          call dump( names(1:n), 'names', width=1 )
        end if
      end if

      ! First copy those things in source, loop over them
      dest%globalUnit = source%globalUnit
      do sqi = 1, size ( source%quantities )
        ! Try to find this in dest
        sq => source%quantities(sqi)
        dq => GetVectorQtyByTemplateIndex ( dest, source%template%quantities(sqi) )
        if ( .not. associated(dq) ) cycle
        call get_string ( dq%template%name, qName, &
          & strip=.true. )
        if ( n > 0 ) then
          if ( .not. any( streq(names, qName, options='-cf' ) )  ) cycle
        end if
        if ( verboser .and. n > 0 ) call output( 'Transferring quantities named ' // trim(qName), advance='yes' )
        if ( .not. skipValues ) then
          dq%values = sq%values
          if ( associated(sq%BinNumber) ) then
            allocate(dq%BinNumber(dq%template%NoInstances) )
            dq%BinNumber = sq%BinNumber
          endif
          if ( associated(sq%MAF) ) then
            allocate(dq%MAF(dq%template%NoInstances) )
            dq%MAF = sq%MAF
          endif
        endif
        if ( .not. skipMask ) then
          if ( associated(sq%Mask) ) then
            if ( .not. associated(dq%Mask)) call CreateMask ( dq )
            dq%Mask = sq%Mask
            if ( expandmask ) then
              where ( ichar(sq%Mask) /= 0 )
                dq%Mask = char(M_All)
              end where
            endif
          else
            call destroyVectorQuantityMask ( dq )
          end if
        else if ( interpolate ) then
          dq => GetVectorQuantityByType ( dest, &
            & quantityType=sq%template%quantityType, &
            & molecule=sq%template%molecule )
          if ( associated ( dq ) ) then
            call FromInterpolatedQty( dq, sq, key=0, &
              & ignoreTemplate=.false. )
          end if
        end if
      end do
      call trace_end ( 'FillUtils_1.TransferVectors', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
    end subroutine TransferVectors

    ! ----------------------------------  TransferVectorsByMethod  -----
    ! Fill items in dest according to method
    ! Using either those in source or those in measVector

    ! Note:
    ! This may fill multiple quantities in destination using the same
    ! source quantities if more than one match according to
    ! method-dependent criteria (should we check? warn?)

    ! Which methods to permit is a question probably to be revisited
    ! as needed
    subroutine TransferVectorsByMethod ( key, dest, &
      & source, method, dontMask, interpolate, &
      & ignorenegative, ignorezero, measvector, modelvector, &
      & noisevector, ptan, booleanname )
    use MLSL2Options, only: RunTimeValues
    use MLSStrings, only: StrEq
    use Dump_0, only: Dump
      integer, intent(in)            :: KEY
      type (Vector_T), pointer       :: DEST
      type (Vector_T), pointer       :: SOURCE
      integer, intent(in)            :: METHOD
      logical, intent(in)            :: DONTMask
      logical, intent(in)            :: INTERPOLATE
      logical, intent(in)            :: IGNORENEGATIVE
      logical, intent(in)            :: IGNOREZERO
      type (Vector_T), pointer       :: MODELVECTOR
      type (Vector_T), pointer       :: MEASVECTOR
      type (Vector_T), pointer       :: NOISEVECTOR
      type (VectorValue_T), pointer  :: PTAN ! tangent pressure
      character(len=*), intent(in), optional :: BOOLEANNAME

      ! Local variables
      logical, parameter            :: ASPERCENTAGE = .false.
      integer                       :: BININDEXER
      integer, parameter            :: CHANNEL=0
      type (VectorValue_T), pointer :: DQ ! Destination quantity
      integer                       :: DQI
      logical, parameter            :: IGNORETEMPLATE = .false.
      real, dimension(2), parameter :: MULTIPLIER = (/ 1.0, 1.0 /)
      integer                       :: NUMQUANTITIES
      type (VectorValue_T), pointer :: SQ  ! Source or meas quantity
      integer                       :: SQI ! Quantity index in source or meas
      integer :: Me = -1                   ! String index for trace
      type (VectorValue_T), pointer :: MQ  ! Model quantity
      integer                           :: N
      character(len=64), dimension(128) :: NAMES
      character(len=64)                 :: QNAME
      logical :: verbose, verboser
      type (VectorValue_T), pointer :: NQ  ! Noise quantity
      integer                       :: NUMMATCHES
      real(r8)                      :: SCALEINSTANCES, SCALERATIO, SCALESURFS
      integer, dimension(4), parameter :: BINMETHODS = &
        & (/ l_binMax, l_binMean, l_binMin, l_binTotal /)
      integer, dimension(4), parameter :: BINNEDTYPES = &
        & (/ l_chisqBinned, l_chisqBinned, l_cloudMinMax, l_noRadsBinned /)

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.TransferVectorsByMethod', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
      verbose = ( switchDetail(switches, 'bool') > -1 )
      verboser = ( switchDetail(switches, 'bool') > 0 )
      n = 0
      ! If we're given a BooleanName, try to interpret it as a container for
      ! quantity names
      if ( present(booleanName) ) then
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & lowerCase(trim(booleanName)), names, countEmpty, &
          & inseparator=runTimeValues%sep )
        n = FindLast( names /= runTimeValues%sep )
      end if

      scaleInstances=-1.0d0
      scaleRatio=1.0d0
      scaleSurfs=-1.0d0
      ! First copy those things in source, loop over them
      if ( any( method == &
        & (/ l_chisqMMAF, l_chisqMMIF, l_chisqChan, l_noRadsPerMif /) ) ) then
        NumQuantities = size ( measVector%quantities )
      else
        NumQuantities = size ( source%quantities )
      end if
      do sqi = 1, NumQuantities
        if ( any( method == &
          & (/ l_chisqMMAF, l_chisqMMIF, l_chisqChan /) ) ) then
          sq => measVector%quantities(sqi)
          mq => modelVector%quantities(sqi)
          nq => noiseVector%quantities(sqi)
        else if ( any( method == &
          & (/ l_noRadsPerMif /) ) ) then
          sq => measVector%quantities(sqi)
        else
          sq => source%quantities(sqi)
        end if
        nummatches = 0
        do dqi = 1, size ( dest%quantities )
          dq => dest%quantities(dqi)
          if ( .not. associated(dq) ) cycle
          call get_string ( dq%template%name, qName, &
            & strip=.true. )
          if ( n > 0 ) then
            if ( verboser ) then
              call outputnamedValue( 'n', n )
              call outputnamedValue( 'qName', qName )
              call dump( names(:n), 'names', width=1 )
            end if
            if ( .not. any( streq(names, qName, options='-cf' ) )  ) cycle
          end if
          select case ( method )
          case ( l_addNoise ) ! ----- Add random noise to source Quantity -------
            nq => GetVectorQtyByTemplateIndex ( noiseVector, &
              & source%template%quantities(sqi) )
            call addGaussianNoise ( key, dq, sq, &
              & nq, multiplier, spread=.false., &
              & ignoreTemplate=ignoreTemplate )
          case ( l_binMax, l_binMean, l_binMin, l_binTotal )
            if ( dq%template%signal /= sq%template%signal ) cycle
            binIndexer = FindFirst( binMethods, method )
            if ( dq%template%quantityType /= binnedTypes(binIndexer) ) cycle
            if ( .not. any( sq%template%quantityType == &
              & (/ l_chiSQMMIF, l_noRadsPerMif/) ) ) cycle
            call WithBinResults ( key, dq, sq, ptan, &
              & channel, method, additional=.false., &
              & excludeBelowBottom=.false., centerVertically=.false. )
          case ( l_lsLocal, l_lsGlobal, l_lsWeighted )
            call UsingLeastSquares ( key, dq, sq, ptan, &
              & channel, method, &
              & scaleInstances, scaleRatio, scaleSurfs )
          case ( l_boxcar )
            if ( dq%template%quantityType /= l_chisqBinned ) cycle
            call WithBoxcarFunction ( key, dq, sq, width=3, &
              & method=l_min, ignoreTemplate=ignoreTemplate )
          case ( l_chiSQChan )
            if ( dq%template%signal /= sq%template%signal ) cycle
            if ( dq%template%quantityType /= l_chiSQChan ) cycle
            call ChiSqChan ( key, dq, &
              & sq, mq, nq, &
              & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier )
          case ( l_chiSQMMaf )
            if ( dq%template%signal /= sq%template%signal ) cycle
            if ( dq%template%quantityType /= l_chiSQMMaf ) cycle
            call ChiSqMMaf ( key, dq, &
              & sq, mq, nq, &
              & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier )
          case ( l_chiSQMMIF )
            if ( dq%template%signal /= sq%template%signal ) cycle
            if ( dq%template%quantityType /= l_chiSQMMIF ) cycle
            call ChiSqMMiF ( key, dq, &
              & sq, mq, nq, &
              & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier )
          case ( l_noRadsPerMif )
            if ( dq%template%signal /= sq%template%signal ) cycle
            if ( dq%template%quantityType /= l_noRadsPerMif ) cycle
            call NoRadsPerMif ( key, dq, sq, asPercentage )
          case default
           call MLSMessage ( MLSMSG_Error, ModuleName, &
             & "Unable to transfer by this method")
          end select
          nummatches = nummatches + 1
        end do
        if ( nummatches > 1 ) then
          L2CFNode = key
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'More than one matching destination quantity in ' // &
          & 'TransferVectorsByMethod' )
        end if
      end do
      call trace_end ( 'FillUtils_1.TransferVectorsByMethod', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
    end subroutine TransferVectorsByMethod

    ! ---------------------------------------  UncompressRadiance  -----
    subroutine UncompressRadiance ( key, quantity, totalPowerQuantity, &
      & systemTemperatureQuantity, termsNode )
      integer, intent(in) :: KEY        ! Tree node for messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! The quantity to mess with
      type (VectorValue_T), intent(inout) :: TOTALPOWERQUANTITY ! The total power
      type (VectorValue_T), intent(inout) :: SYSTEMTEMPERATUREQUANTITY ! The system temperature
      integer, intent(in) :: TERMSNODE

      ! Local parameters
      integer, parameter :: NOTERMS=3

      ! Local variables
      integer :: I
      integer :: J
      integer :: K
      integer :: Me = -1                      ! String index for trace
      integer :: Nchannels
      integer :: Npointings
      real(rv), dimension(noTerms) :: myTerms
      integer, DIMENSION(2) :: UNITASARRAY    ! Unit for value given
      real (r8), DIMENSION(2) :: VALUEASARRAY ! Value give
      real(rv) :: b
      real(rv) :: bTsys
      real(rv) :: sumCal
      real(rv) :: bprodCal

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.UncompressRadiance', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      if ( quantity%template%quantityType /= l_radiance ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Inappropriate quantity for uncompressRadiance fill' )
      if ( totalPowerQuantity%template%quantityType /= l_baseline  ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Inappropriate quantity for total power quantity in uncompressRadiance' // &
        & ' (should be a baseline)' )
      if ( .not. totalPowerQuantity%template%minorFrame ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Inappropriate quantity for total power quantity in uncompressRadiance' // &
        & ' (should be MIF baseline)' )

     ! if (totalPowerQuantity%template%radiometer /= quantity%template%radiometer ) &
     !   & call Announce_Error ( key, no_error_code, &
     !   & 'Inappropriate quantity for total power quantity in uncompressRadiance' // &
     !   & ' (should be the right radiometer)' )

      if ( nsons ( termsNode ) /= noTerms + 1 ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Wrong number of terms for uncompressRadiance fill' )

      do i = 1, noTerms
        call expr_check ( subtree(i+1,termsNode), unitAsArray, valueAsArray, &
          & (/PHYQ_Dimensionless/), unitsError )
        if ( unitsError ) call Announce_Error ( termsNode, wrongUnits, &
          & extraInfo=(/unitAsArray(1), PHYQ_Temperature/) )
        myTerms(i) = valueAsArray(1)
      end do

      ! Radiances are in quantity%values [ chans * pointings, mafs ], do your messing here
      ! Total power are in totalPowerQuantity%values [ pointings, mafs ]
      ! System temperature is in systemTemperatureQuantity%values(chans,1)
      ! The terms supplied are in myTerms(:)

      ! YOUR CODE HERE
      !
      !terms needed:
      !   myTerms(1) == b == gain compression at the cal target, e.g. 0.01
      !   myTerms(2) == Tcal == cal target Planckified radiance, e.g. 250
      !   myTerms(3) == Tspace == space Planckified radiance,    e.g. 3
      !
      ! TA ~= TAhat + b * TAhat *(TAhatbar - Tcal - Tspace - Tsys) +  b * Tcal * Tspace  +  b * Tsys * TAhatbar
      !
      Nchannels = size(quantity%values, 1)/ size(totalPowerQuantity%values, 1)
      !Nchannels = quantity%
      Npointings = size(totalPowerQuantity%values, 1)
      do i = 1, size(quantity%values, 2)  !MAFS

        do j = 1, Npointings !Pointings
          if ( totalPowerQuantity%values(j,i) == 0 ) then
             call Announce_Error ( key, noTotalPower )
          else
            do k = 1, Nchannels  !channels
              b=myTerms(1)/(myTerms(2) +  systemTemperatureQuantity%values(k,1))
              sumCal = myTerms(2) + myTerms(3) + systemTemperatureQuantity%values(k,1)
              bprodCal = b * myTerms(2) * myTerms(3)
              bTsys= b * systemTemperatureQuantity%values(k,1)

              quantity%values(k + (j - 1)*Nchannels, i) = quantity%values(k + (j - 1)*Nchannels, i) &
                       &  + b *  quantity%values(k + (j - 1)*Nchannels, i) * (totalPowerQuantity%values(j,i)-sumcal) &
                       &  + bprodCal  + bTsys * totalPowerQuantity%values(j,i)
            end do
          end if
        end do
      end do
      call trace_end ( 'FillUtils_1.UncompressRadiance', &
        & cond=toggle(gen) .and. levels(gen) > 1 )

    end subroutine UncompressRadiance

    ! ----------------------------------------------  QtyFromFile  -----
    subroutine QtyFromFile ( key, quantity, MLSFile, &
      & filetype, options, sdname, spread, interpolate )
      use MLSHDF5, only: MatchHDF5Attributes
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Radiance quantity to modify
      type (MLSFile_T), pointer   :: MLSFile
      character(len=*), intent(in) :: FILETYPE
      character(len=*), intent(in) :: OPTIONS
      character(len=*), optional, intent(in) :: sdname
      logical, intent(in)                    :: spread
      logical, intent(in)                    :: interpolate

      ! Local variables
      integer, parameter                      :: MAXLISTLENGTH=256
      character (len=10*MAXLISTLENGTH)        :: attrnames
      character (len=10*MAXLISTLENGTH)        :: attrvalues
      logical homogeneous
      integer :: Me = -1                      ! String index for trace
      character(len=80) :: name
      character (len=80) :: Str

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.QtyFromFile', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      homogeneous = index(lowercase(options), 'h') > 0
      ! How do we access the dataset to read? By name or by attribute?
      if ( index(lowercase(options), 'a') < 1 ) then
        ! By name
        name = ' '
        if ( present(sdName) ) name = sdname
        if ( len_trim(name) < 1 ) &
          & call get_string( lit_indices(quantity%template%name), Name )
        if ( addSlash ) Name = '/' // Name
      else
        ! By attribute
        attrnames  = 'TemplateName,tempQtyType'
        call Get_String ( quantity%template%name, str, strip=.true. )
        attrvalues = str
        call Get_String ( lit_indices(quantity%template%quantityType), &
          & str, strip=.true. )
        attrvalues = trim(attrvalues) // ',' // str
        call MatchHDF5Attributes ( MLSFile, attrNames, attrValues, name )
        ! call Announce_Error ( key, no_Error_Code, &
        ! &   'Unable to read Quantity from File by attribute yet' )
      end if
      call NamedQtyFromFile ( key, quantity, MLSFile, &
        & filetype, name, spread, interpolate, homogeneous )
      call trace_end ( 'FillUtils_1.QtyFromFile', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    end subroutine QtyFromFile

    ! -------------------------------------------  VectorFromFile  -----
    subroutine VectorFromFile ( key, Vector, MLSFile, &
      & filetype, options, spread, interpolate, groupName )
      use Dump_1, only: Dump
      use MLSHDF5, only: GetAllHDF5DSNames, MatchHDF5Attributes
      use MLSMessageModule, only: MLSMSG_info
      integer, intent(in)            :: KEY        ! Tree node
      type (Vector_T), intent(inout) :: Vector
      type (MLSFile_T), pointer      :: MLSFile
      character(len=*), intent(in)   :: FILETYPE
      character(len=*), intent(in)   :: OPTIONS
      character(len=*), intent(in)   :: groupName
      logical, intent(in)            :: spread
      logical, intent(in)            :: interpolate

      ! Local variables
      integer :: DSI                      ! Dataset index in file
      character(len=MAXSDNAMESBUFSIZE) :: DSNames
      logical :: homogeneous
      integer :: Me = -1                  ! String index for trace
      character(len=64) :: name
      integer :: NDSs
      integer :: NSQs
      type (VectorValue_T), pointer :: quantity
      integer, parameter                      :: MAXLISTLENGTH=256
      character (len=10*MAXLISTLENGTH)        :: attrnames
      character (len=10*MAXLISTLENGTH)        :: attrvalues
      integer :: SQI                      ! Quantity index in source
      character (len=80) :: Str
      logical :: verbose

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.VectorFromFile', key, &
        & cond=toggle(gen) .and. levels(gen) > 1 )
      homogeneous = index(lowercase(options), 'h') > 0
      verbose = index(lowercase(options), 'v') > 0 &
        & .or. BeVerbose( 'vect', 0 )
      call GetAllHDF5DSNames( MLSFile, DSNames )
      if ( verbose ) then
        call output( 'Now in VectorFromFile', advance='yes' )
        call dump( DSNames )
      endif
      ! Do we access the dataset by attribute(s)? (Most efficient way)
      if ( index(lowercase(options), 'a') > 0 ) then
        call ByAttribute
        call trace_end ( 'FillUtils_1.VectorFromFile', &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        return
      endif
      call LogMyData ( mesg='NumStringElements( trim(DSNames), countEmpty )', &
        & data=NumStringElements( trim(DSNames), countEmpty ) )
      call LogMyData ( mesg='size ( vector%quantities )', &
        & data=size ( vector%quantities ) )
      NDSs = NumStringElements( trim(DSNames), countEmpty )
      NSQs = size ( vector%quantities )
      ! do dsi=1, NDSs
        ! call LogMyData ( mesg='dsi', data=dsi )
        sqiloop: do sqi = 1, NSQs
          ! if ( dsi > 123 .and. sqi > 120 ) &
            ! & call LogMyData ( mesg='sqi', data=sqi )
          quantity => vector%quantities(sqi)
          ! How do we access the dataset to read? By name or by num?
          if ( index(lowercase(options), 'num') < 1 ) then
          ! By name
            if ( quantity%template%name < 1 ) &
              & call Announce_Error ( key, no_Error_Code, &
              &   'template name is 0?' )
            call get_string( quantity%template%name, Name )
            ! if ( dsi > 123 ) &
              ! & call LogMyData ( mesg='Made it out of get_string', data=sqi )
          else
          ! By num
            call writeIntsToChars ( sqi, Name )
            Name = 'Quantity ' // trim(Name)
          end if
          ! if ( dsi > 123 .and. sqi > 123 ) &
            ! & call LogMyData ( mesg='Deciding about sqi', data=sqi )
          ! if ( lowercase(trim(name)) /= &
          !  & lowercase(StringElement( DSNames, dsi, countEmpty )) ) &
          !  & cycle
          dsi = StringElementNum( lowercase(DSNames), lowercase(name), &
            & countEmpty=.true. )
          if ( dsi < 1 ) cycle
          if ( addSlash ) Name = '/' // Name
          if ( DEEBUG ) then
            call outputNamedValue( 'shape(values)' // trim(name), &
              & shape(quantity%values) )
            call dump( MLSFile )
          end if
          if ( len_trim(name) > 0 ) then
            if ( len_trim(groupName) > 0 ) &
              & name = trim(groupName) // '/' // name
            call LogMyData ( mesg='sqi', data=sqi )
            call NamedQtyFromFile ( key, quantity, MLSFile, &
              & filetype, name, spread, interpolate, homogeneous )
            call LogMyData ( mesg='Returned from reading ' // trim(name) )
            ! exit sqiloop
          endif
        end do sqiloop
      ! end do
      call LogMyData ( mesg='Whew! Barely made it.' )
      call trace_end ( 'FillUtils_1.VectorFromFile', &
        & cond=toggle(gen) .and. levels(gen) > 1 )
    contains
      subroutine LogMyData ( mesg, data )
        character(len=*), intent(in), optional       :: mesg
        integer, intent(in), optional                :: data
        ! Internal
        character(len=1024)                          :: chars
        character(len=16)                            :: dchars
        ! Executable
        if ( .not. verbose ) return
        chars = ' '
        if ( present(mesg) ) chars = trim(chars) // mesg
        if ( present(data) ) then
          write( dchars, * ) data
          if ( len(chars) >= &
            & ( len_trim(chars) + 2 + len_trim(dchars) ) ) &
            & chars = trim(chars) // ': ' // trim(dchars)
        endif
        call MLSMessage ( MLSMSG_Info, ModuleName, trim(chars) )
      end subroutine LogMyData
      subroutine ByAttribute
        ! By attribute
        integer :: SQI ! Loop index
        do sqi = 1, size ( vector%quantities )
          quantity => vector%quantities(sqi)
          attrnames  = 'TemplateName,tempQtyType'
          call Get_String ( quantity%template%name, str, strip=.true. )
          attrvalues = str
          call Get_String ( lit_indices(quantity%template%quantityType), &
            & str, strip=.true. )
          attrvalues = trim(attrvalues) // ',' // str
          call MatchHDF5Attributes ( MLSFile, attrNames, attrValues, name )
          if ( verbose ) then
            call outputnamedValue ( 'sqi', sqi )
            call outputnamedValue ( 'attrNames', trim(attrNames) )
            call outputnamedValue ( 'attrValues', trim(attrValues) )
            call outputnamedValue ( 'name', trim(name) )
          endif
          if ( len_trim(name) > 0 ) &
            & call NamedQtyFromFile ( key, quantity, MLSFile, &
            & filetype, name, spread, interpolate, homogeneous )
        enddo
      end subroutine ByAttribute
    end subroutine VectorFromFile

    ! =====  Private procedures  =======================================

    ! ---------------------------------------------  returnFullFileName  -----
    subroutine returnFullFileName ( shortName, FullName, &
      & pcf_start, pcf_end )
      ! Given a possibly-abbreviated shortName, return the full name
      ! as found in the PCF
      ! (w/o toolkit panoply, simply return shortName)
      ! Args
      character(len=*), intent(in)  :: shortName
      character(len=*), intent(out) :: FullName
      integer, intent(in)           :: pcf_start
      integer, intent(in)           :: pcf_end
      ! Internal variables
      ! logical, parameter :: DEBUG = .false.
      logical :: debug
      integer :: FileHandle
      integer :: returnStatus
      integer :: Version
      ! Executable
      debug = LetsDebug ( 'output', 0 )
      if ( TOOLKIT .and. pcf_end >= pcf_start ) then
        Version = 1
        FileHandle = GetPCFromRef(shortName, pcf_start, &
          & pcf_end, &
          & TOOLKIT, returnStatus, Version, DEBUG, &
          & exactName=FullName)
        if ( returnStatus /= 0 ) FullName = shortName ! In cases omitted from PCF
      else
        FullName = shortName
      end if
    end subroutine returnFullFileName

    ! --------------------------------------------  FillableChiSq  -----
    function FillableChiSq ( qty, measQty, modelQty, noiseQty ) result ( aok )
      ! Purpose (A)
      !   Check whether we may proceed with special fill of chi squared
      !   case where all VectorValue_T args present
      ! Purpose (B)
      !   Check whether we may proceed with special fill of addNoise
      !   case where missing noiseQty arg
      type (VectorValue_T), intent(in) ::              QTY
      type (VectorValue_T), intent(in) ::              modelQty
      type (VectorValue_T), intent(in) ::              measQty
      type (VectorValue_T), optional, intent(in) ::    noiseQty
      logical ::                                       AOK

      ! What we will check is that (for the args we have been given):
      ! (0) all quantities have associated values
      ! (1) all quantities have same molecule
      ! (2) all quantities have same signal
      ! (3) all quantities have same HGrid
      ! (4A) all but qty (chiSq) have same VGrid
      ! (4B) all have same VGrid
      ! Ah, but radiances have no VGrid or HGrid,
      ! and molecule should be part of signal, so
      ! if radiances need only check on signal
      ! if vmr, check on others

      ! Local variables
      integer :: Me = -1            ! String index for trace
      logical :: MinorFrame         ! TRUE if radiances, FALSE if vmr

      call trace_begin ( me, 'FillUtils_1.FillableChiSq', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
      aok = .true.

      ! (0)
      if ( present(noiseQty) ) then
        aok = associated(noiseQty%values)
        if ( DEEBUG .and. .not. associated(noiseQty%values) ) &
          & call Announce_Error( no_Error_Code, No_Error_code, &
          & 'Noise values unassociated in FillableChiSq')
      end if
      aok = aok .and. &
        & associated(qty%values) .and. &
        & associated(measQty%values) .and. &
        & associated(modelQty%values)

      if ( DEEBUG ) then
        if ( .not. associated(qty%values) ) &
          & call Announce_Error( no_Error_Code, No_Error_code, &
          & 'Quantity values unassociated in FillableChiSq')
        if ( .not. associated(measQty%values) ) &
          & call Announce_Error( no_Error_Code, No_Error_code, &
          & 'Measurements values unassociated in FillableChiSq')
        if ( .not. associated(modelQty%values) ) &
          & call Announce_Error( no_Error_Code, No_Error_code, &
          & 'Model values unassociated in FillableChiSq')
      end if

      if ( .not. aok ) go to 9

      minorFrame = qty%template%minorFrame .or. qty%template%majorFrame
      ! (1)
      if ( .not. minorFrame ) then
        aok = aok .and. &
          & (qty%template%molecule == measQty%template%molecule) &
          & .and. &
          & (qty%template%molecule == modelQty%template%molecule)
        if ( present(noiseQty) ) aok = aok &
          & .and. &
          & (qty%template%molecule == noiseQty%template%molecule)
      end if

      ! (2)
      if ( minorFrame ) then
        aok = aok .and. &
          & (qty%template%signal == measQty%template%signal) &
          & .and. &
          & (qty%template%signal == modelQty%template%signal)
        if ( present(noiseQty) ) aok = aok &
          & .and. &
          & (qty%template%signal == noiseQty%template%signal)
      end if

      ! (3)
      if ( .not. minorFrame ) then
        aok = aok .and. &
          & DoHgridsMatch( qty, measQty ) &
          & .and. &
          & DoHgridsMatch( qty, modelQty )
        if ( present(noiseQty) ) aok = aok &
          & .and. &
          & DoHgridsMatch( qty, noiseQty )

        ! (4)
        aok = aok .and. &
          & DoVgridsMatch( measqty, modelQty )
        if ( present(noiseQty) ) then
          aok = aok &
          & .and. &
          & DoVgridsMatch( measqty, noiseQty )
        else
          aok = aok &
          & .and. &
          & DoVgridsMatch( measqty, Qty )
        end if
      end if

    9 call trace_end ( 'FillUtils_1.FillableChiSq', &
        & cond=toggle(gen) .and. levels(gen) > 2 )
    end function FillableChiSq

    ! -----------------------------------------  NamedQtyFromFile  -----
    subroutine NamedQtyFromFile ( key, quantity, MLSFile, &
      & filetype, name, spread, interpolate, homogeneous )
      use MLSHDF5, only: GetHDF5Attribute, GetHDF5DSDims, GetHDF5DSRank, &
        & LoadFromHDF5DS
      use MLSMessageModule, only: MLSMSG_info
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Radiance quantity to modify
      type (MLSFile_T), pointer   :: MLSFile
      character(len=*), intent(in) :: FILETYPE
      character(len=*), intent(in) :: name
      logical, intent(in)                    :: spread
      logical, intent(in)                    :: interpolate
      logical, intent(in)                    :: homogeneous

      ! Local variables
      character(len=8)    :: caseName
      integer, dimension(3) :: dimInts
      integer(kind=hSize_t), dimension(3) :: dims
      integer, parameter :: globalUnit = 0
      integer, parameter :: instancesNode = 0
      integer :: instance
      type( L2AUXData_T ) :: L2AUX ! Result
      type( L2GPData_T ) :: L2GP   ! Result
      integer :: Me = -1           ! String index for trace
      integer :: noSurfs
      type (VectorValue_T), pointer :: PTAN => null()
      integer :: rank
      integer :: status
      real(r8), dimension(:), pointer :: surfs  => null()
      real(rv), dimension(:,:,:), pointer :: values => null()
      logical :: Verbose

      ! Executable code
      call trace_begin ( me, 'FillUtils_1.NamedQtyFromFile', key, &
        & cond=toggle(gen) .and. levels(gen) > 2 )
      verbose = ( switchDetail(switches, 'fill') > -1 )
      if ( verbose ) &
          & call MLSMessage ( MLSMSG_Info, ModuleName, &
          & trim(name) // ' will be read from file' )
      call GetHDF5DSDims ( MLSFile, name, DIMS )
      dimInts = max(dims, int(1,hsize_t))
      caseName = lowercase(fileType)
      if ( any( casename == (/ 'l2aux   ', 'swath   ', 'l2gp    ' /) ) ) then
        ! Keep your old casename
      else
        call GetHDF5DSRank ( MLSFile, name, rank )
        if ( verbose ) call outputNamedvalue ( 'rank', rank )
        if ( verbose ) call outputNamedvalue ( 'dimInts', dimInts )
        if ( rank == 2 .and. .not. interpolate .and. .not. spread ) &
          & casename = 'auto' ! Assume you wrote it as you'll read it
      endif
      if ( verbose ) call outputNamedValue( 'fileType', trim(fileType) )
      select case ( caseName )
      case ('l2aux')
        if ( spread ) call Announce_Error ( key, no_Error_Code, &
          &   'Unable to use spread when filling from L2AUX file' )
        call ReadL2AUXData ( MLSFile, name, L2AUX, quantity%template%quantityType )
        call FromL2AUX( quantity, L2AUX, status )
        call DestroyL2AUXContents ( L2AUX )
      case ('swath', 'l2gp')
        if ( spread ) call Announce_Error ( key, no_Error_Code, &
          &   'Unable to use spread when filling from L2GP file' )
        call ReadL2GPData( MLSFile, name, L2GP )
        call FromL2GP ( quantity, L2GP, .false., -1, status, .true., .false. )
        call DestroyL2GPContents ( L2GP )
      case ('auto')
        ! Simplest
        call LoadfromHDF5DS ( MLSFile, trim(Name), quantity%values )
      case default ! E.g., 'hdf' but not 'auto'
        call Allocate_test ( values, dimInts(1), dimInts(2), dimInts(3), &
          & 'values read from file', ModuleName )
        call LoadMyHDF5DS ( MLSFile, &
          & trim(Name), values, rank, dimInts ) ! quantity%values )
        if ( verbose ) then
          call outputNamedValue( 'name', trim(name) )
          call outputNamedValue( 'spread', spread )
          call outputNamedvalue( 'shape(quantity%values)', shape(quantity%values) )
          call outputNamedvalue( 'shape(values)', shape(values) )
          call outputNamedvalue( 'values(1,1,1)', values(1,1,1) )
        end if
        if ( spread ) then
          if ( verbose ) call output( '/spead option invoked', advance='yes' )
          quantity%values = values(1,1,1)
        else if ( interpolate .and. allocated(quantity%template%surfs) ) then
          ! Must we interpolate according to surface heights?
          call h5dOpen_f ( MLSFile%fileID%f_id, trim(name), &
            & MLSFile%fileID%sd_id, status)
          if ( status /= 0 ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
                  & 'Unable to open sd to read heights attribute in hdf file', &
                  & MLSFile=MLSFile )
          end if
          call GetHDF5Attribute( MLSFile, 'noSurfs', noSurfs )
          call Allocate_test ( surfs, noSurfs, 'surfs read from file', ModuleName )
          call GetHDF5Attribute( MLSFile, 'surfs', surfs )
          if ( all(surfs == quantity%template%surfs(:,1)) ) then
            ! No need, the heights are all the same
            if ( verbose ) call output( 'All heights the same', advance='yes' )
            call fillMyInstances( quantity%values, values )
          else if ( noSurfs == dimInts(1)*dimInts(2) ) then
            if ( verbose ) call output( 'Must interpolate according to surface height', advance='yes' )
            call FromProfile( quantity, surfs, &
              & real( &
              & reshape( values(:,:,1), (/ dimInts(1)*dimInts(2) /) ), &
              & rv), &
              & instancesNode, globalUnit, ptan )
          else
            call Announce_Error ( key, no_Error_Code, &
          &   'Unable to interpolate using this file data set ; noSurfs ' // &
          &   'does not match dims(1)*dims(2)' )
          end if
          call DeAllocate_test ( surfs, 'surfs read from file', ModuleName )
          call h5dClose_f ( MLSFile%fileID%sd_id, status)
          if ( status /= 0 ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
                  & 'Unable to close sd to read heights attribute in hdf file', &
                  & MLSFile=MLSFile )
          end if
          MLSFile%fileID%sd_id = 0
        else if ( size(quantity%values(:,1)) == size(values(:,:,1) ) ) then
          if ( verbose ) call output( 'instance lengths match', advance='yes' )
          do instance = 1, size(quantity%values(1,:))
            quantity%values(:,instance) = &
              & reshape( values(:,:,1), (/ dimInts(1)*dimInts(2) /) )
          end do
        else if ( size(quantity%values) /= size(values ) ) then
          call Announce_Error ( 0, no_Error_Code, &
            'sizes of read and filled datasets dont match' )
        else
          if ( verbose ) call output( 'Needed to reshape', advance='yes' )
          quantity%values = reshape( values, (/ dimInts(1)*dimInts(2), dimInts(3) /) )
        end if
        call DeAllocate_test ( values, 'values read from file', ModuleName )
      end select
999      call trace_end ( 'FillUtils_1.NamedQtyFromFile', &
        & cond=toggle(gen) .and. levels(gen) > 2 )

    contains
      subroutine LoadMyHDF5DS ( MLSFile, &
           & Name, values, rank, dimInts )
        ! Load the values from MLSFile depending on the rank by which it was stored
        type (MLSFile_T), pointer   :: MLSFile
        character(len=*), intent(in) :: name
        real(rv), dimension(:,:,:) :: values
        integer, intent(in) :: rank
        integer, dimension(3), intent(in) :: dimInts
        select case ( rank )
        case ( 3 )
          call LoadfromHDF5DS ( MLSFile, trim(Name), values )
        case ( 2 )
          call LoadfromHDF5DS ( MLSFile, trim(Name), values(:,:,1) )
        case ( 1 )
          call LoadfromHDF5DS ( MLSFile, trim(Name), values(:,1,1) )
        case default
          ! ?
        end select
      end subroutine LoadMyHDF5DS

      subroutine FillMyInstances ( values1, values2 )
        ! Handle the following cases:
        ! (1) values2 has only 1 instance
        ! (2) values2 has the same number of instances as values1
        ! (3) values2 has a different number of instances from values1
        ! Args:
        real(rv), dimension(:,:), pointer :: VALUES1
        real(rv), dimension(:,:,:), pointer :: values2
        ! Local variables
        integer :: instance
        integer :: noInst1  ! Number of instances in values1
        integer :: noInst2  ! Number of instances in values2
        integer, dimension(3) :: shp2
        ! Executable code
        noInst1 = size(values1, 2)
        noInst2 = size(values2, 3)
        shp2 = shape(values2)
        if ( noInst2 == 1 .or. homogeneous ) then
          do instance = 1, noInst1
            values1(:,instance) = &
              & reshape( values2(:,:,1), (/ shp2(1)*shp2(2) /) )
          end do
        else if( noInst1 == noInst2 ) then
          do instance = 1, noInst1
            values1(:,instance) = &
              & reshape( values2(:,:,instance), (/ shp2(1)*shp2(2) /) )
          end do
        else
          do instance = 1, noInst1
            values1(:,instance) = &
              & reshape( values2(:,:,1), (/ shp2(1)*shp2(2) /) )
          end do
        end if
      end subroutine FillMyInstances
    end subroutine NamedQtyFromFile

  ! --------- WhichSurfaceIsHeight ------
  function WhichSurfaceIsHeight ( node, Heights ) result ( surface )
    ! Args
    integer, intent(in)                  :: node  ! Tree node
    real(r8), dimension(:), intent(in)   :: heights ! array of heights
    integer                              :: surface
    ! Internal variables
    real(r8) :: HEIGHT                ! The height to consider
    integer, dimension(2) :: unitAsArray ! Unit for value given
    logical :: unitsError
    real (r8), dimension(2) :: valueAsArray ! Value given
    ! Executable
    if ( node > 0 ) then
      if ( nsons ( node ) /= 2 ) call Announce_Error ( node, no_error_code, &
        & 'Only one height can be supplied for explicit fill' )
      call expr_check ( subtree(2,node) , unitAsArray, valueAsArray, &
        & (/PHYQ_Pressure/), unitsError )
      if ( unitsError ) call Announce_Error ( node, wrongUnits, &
        & extraInfo=(/unitAsArray(1), PHYQ_Pressure/) )
      height = - log10 ( valueAsArray(1) )
      call Hunt ( heights, height, surface, nearest=.true. )
    else
      surface = 0
    end if
  end function WhichSurfaceIsHeight

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: FillUtils_1.f90,v 2.156 2023/12/14 21:28:00 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module FillUtils_1
!=============================================================================

!
! $Log: FillUtils_1.f90,v $
! Revision 2.156  2023/12/14 21:28:00  pwagner
! Turned off printing in residualCorrection unless verbose
!
! Revision 2.155  2023/12/07 23:08:01  pwagner
! Improved ResidualCorrection Fill method
!
! Revision 2.154  2023/10/19 20:40:54  pwagner
! Added stub for residualCorrection Fill method; needs work
!
! Revision 2.153  2023/05/25 22:27:35  pwagner
! Try to avoid Filling convergence with ieee Infinity
!
! Revision 2.152  2021/06/10 23:46:06  pwagner
! When copying vector qties, copy their BinNumber and MAF, too
!
! Revision 2.151  2021/05/13 23:26:37  pwagner
! Minor housekeeping; more comments about the start array
!
! Revision 2.150  2020/01/27 18:03:13  pwagner
! Worked around the error that made instrumentModuleName allcaps
!
! Revision 2.149  2020/01/09 22:25:41  pwagner
! Extra steps to avoid munging sids-related DS names
!
! Revision 2.148  2019/09/27 16:48:42  pwagner
! Removed faulty goto 999 from NamedQtyFromFile
!
! Revision 2.147  2019/01/24 00:02:27  pwagner
! Coded around a strange NAG error
!
! Revision 2.146  2018/12/07 00:21:58  pwagner
! Corrected error in LogMyData; will log only if verbose
!
! Revision 2.145  2018/11/30 17:48:25  pwagner
! These calls to LogMyData caused crashes; need investigation before being restored
!
! Revision 2.144  2018/07/27 23:18:48  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.143  2018/06/27 00:01:14  pwagner
! Dont complain about invalid temperatures in WithReichlerWMOTP
!
! Revision 2.142  2018/04/16 22:16:45  pwagner
! fixed bug in character array constructor for non-auto casenames
!
! Revision 2.141  2018/04/13 00:19:18  pwagner
! Plain hdf DirectWrites and -Reads are now 'auto'
!
! Revision 2.140  2018/03/14 22:54:12  pwagner
! Stop computing unneeded arrays in HeightFromPressure
!
! Revision 2.139  2018/02/27 16:23:12  livesey
! Fixed erroneous error message
!
! Revision 2.138  2018/02/26 19:04:53  livesey
! More error messages.
!
! Revision 2.137  2018/02/23 22:09:52  mmadatya
! Added l_instECR for ASMLS
!
! Revision 2.136  2017/12/15 18:33:19  mmadatya
! Added heightFromPressure as new Fill method
!
! Revision 2.135  2017/12/07 01:01:23  vsnyder
! Don't use host-associated variable as a DO index
!
! Revision 2.134  2017/10/31 23:47:33  vsnyder
! Make Coefficients a parameterized type
!
! Revision 2.133  2017/09/20 00:02:58  vsnyder
! Shorten a log comment so compilers don't complain
!
! Revision 2.132  2017/07/27 16:59:42  pwagner
! VectorFromFile may read qties from a named group
!
! Revision 2.131  2017/07/10 18:52:32  pwagner
! Transfer may /expandMask to all masking bits; may /skipValues to transfer
! only mask; Fill may replaceMissingValue=; correct Transfer by attribute
!
! Revision 2.130  2017/04/06 23:43:34  pwagner
! May choose to base on asc/desc mode on GHz/GeodAngle via manipulation field
!
! Revision 2.129  2017/02/08 19:22:00  pwagner
! /sourceMask causes vector Fills to obey mask from source, not destination
!
! Revision 2.128  2016/10/20 19:18:30  vsnyder
! Use tngtECE%value3 and scVel%value3, which eliminates the need to calculate
! 2D subscripts for XYZ, MIF, MAF, and eliminates a seg fault with NAG build
! 1052.
!
! Revision 2.127  2016/09/02 00:56:05  vsnyder
! Add TngtECR and TngtGeodLat fills from L1B.  Make some arrays in
! ColAbundance automatic, resulting in DeallocateStuff being unused, and
! therefore deleted.  Simplify FromL1B fills.  Correct geolocation fills
! in FromL1B.  Correct reference to Hydrostatic in WithWMOTropopause,
! which was giving RefGPH in meters instead of kilometers.
!
! Revision 2.126  2016/07/28 01:45:07  vsnyder
! Refactor dump and diff
!
! Revision 2.125  2016/06/14 22:54:39  vsnyder
! In UsingMagneticModel, improve a message.  Add some comments about unexpected
! combinations, such as geodetic height and geocentric latitude.
!
! Revision 2.124  2016/06/13 21:03:20  vsnyder
! Improve a warning message
!
! Revision 2.123  2016/06/03 20:54:38  vsnyder
! Correct the log for the previous commit
!
! Revision 2.122  2016/06/03 20:52:04  vsnyder
! Allow scVelQuantity and geocAltitudeQuantity to have different numbers
! of "channels" in the magnetic fill.
!
! Revision 2.121  2016/05/18 01:37:30  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.120  2016/03/18 17:58:05  pwagner
! Make certain the L2CF line cited is actal error, not end of section
!
! Revision 2.119  2016/01/23 02:56:37  vsnyder
! Replace To_Cart with GeodToECRm, To_XYZ with GeodToECRu
!
! Revision 2.118  2015/12/01 21:19:57  pwagner
! May Fill with nearest profile number
!
! Revision 2.117  2015/11/11 23:25:32  vsnyder
! Compute the longest monotone subsequence of altitudes after converting
! from geocentric to geodetic, instead of before, for purposes of determining
! the reference MIF number.
!
! Revision 2.116  2015/10/29 00:55:27  vsnyder
! If the units of the referenceMIF are length, and its value is less than
! half EarthRadA, assume it's a geodetic height.  If so, and the tangent
! point vertical coordinate is geocentric height, create an array of
! geodetic heights from the first MAF in which to choose a reference MIF
! number.
!
! Revision 2.115  2015/10/03 00:28:06  pwagner
! May print Reference MIF number if verbose
!
! Revision 2.114  2015/09/25 02:15:26  vsnyder
! Remove conversion of surfs to geocentric if the vertical coordinate is
! geocentric altitude, because ConstructQuantityTemplates now reads the
! appropriate altitude from the L1BOA file.
!
! Revision 2.113  2015/09/22 23:42:05  vsnyder
! Add GHzAzim and ScECR quantities.  Add ReferenceMIF.  Convert Surfs to
! geocentric altitude if that's the specified vertical coordinate.
!
! Revision 2.112  2015/08/25 17:33:42  vsnyder
! PhiWindow is a tuple, with the first element specifying the angles or
! number of profiles/MAFs before the tangent point, and the second
! specifying the angles or number after.
!
! Revision 2.111  2015/08/03 21:43:25  pwagner
! Made quantityType optional in call to ReadL2AUXData
!
! Revision 2.110  2015/07/29 00:29:54  vsnyder
! Convert Phi from pointer to allocatable
!
! Revision 2.109  2015/06/04 03:19:36  vsnyder
! Make the Surfs component of quantity templates allocatable
!
! Revision 2.108  2015/06/03 00:35:36  pwagner
! Should only use sc/VelECI if it is found in l1boa
!
! Revision 2.107  2015/05/28 18:26:48  vsnyder
! Remove unreferenced USE names and external declarations
!
! Revision 2.106  2015/05/05 17:44:01  pwagner
! Use MAXMANIPULATIONLEN from manipulationUtils; lots of unsetting allcaps
!
! Revision 2.105  2015/04/29 01:17:52  vsnyder
! Add lots of checking in UsingMagneticModel
!
! Revision 2.104  2015/04/09 01:12:32  vsnyder
! Correct message about mismatched vGrid in RotateMagneticField
!
! Revision 2.103  2015/03/28 02:41:45  vsnyder
! Got IsMonotonic from Monotone instead of MLSFillValues.  Added support
! for cross-track grids.  Use Norm2 to normalize LOS.  Specify whether
! latitude is geocentric or geodetic.  Change UsingMagneticModel fill to
! use SC velocity quantity to get SC geolocation (we don't care about its
! velocity) and a geocentric altitude quantity to get the tangent position
! geolocation and geocentric altitude.  Use 3-d Values field for ECRtoFOV
! quantity in RotateMagneticField.  Account for cross-track viewing in
! RotateMagneticField.  Use ATAN2 instead of ATAN in two places.
!
! Revision 2.102  2014/12/10 21:30:34  pwagner
! WithAscOrDesc may use PtanQuantity
!
! Revision 2.101  2014/10/31 17:43:45  vsnyder
! Separate PTan and GPH hydrostatic fills
!
! Revision 2.100  2014/05/13 00:13:22  pwagner
! FromL2GP may inerpolate in time, instead of phi
!
! Revision 2.99  2014/04/07 18:06:10  pwagner
! Added check on quantityTypes when Filling WithAscOrDesc
!
! Revision 2.98  2014/03/13 18:12:26  pwagner
! GeoidData Fills will warn instead of bomb if running toolkitless
!
! Revision 2.97  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.96  2013/11/22 00:22:49  pwagner
! Simpler, hopefully better, too, way to prevent NaNs in ChiSqRatio
!
! Revision 2.95  2013/11/21 21:23:52  pwagner
! Further steps to prevent Fiiling convergence ratios with non-finite values
!
! Revision 2.94  2013/11/20 01:02:49  pwagner
! Reduce some printing; switch to use of BeVerbose function
!
! Revision 2.93  2013/10/24 21:10:23  pwagner
! /dontLatch in profile Fills retains profile heights as input
!
! Revision 2.92  2013/10/17 18:36:15  pwagner
! GeoidData needs to call integer externals in DEM (but why?)
!
! Revision 2.91  2013/10/09 00:26:27  pwagner
! Protect against certain obscure crashes; use c_short instead of 2-byte integer
!
! Revision 2.90  2013/10/02 00:48:55  pwagner
! Added ascenddescend Fill Method
!
! Revision 2.89  2013/09/25 16:39:53  pwagner
! Repaired GeoidData
!
! Revision 2.88  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.87  2013/09/21 00:24:21  pwagner
! Added geoid Fill methods
!
! Revision 2.86  2013/09/17 22:47:49  pwagner
! Added Scatter, Gather methods
!
! Revision 2.85  2013/09/17 00:52:15  vsnyder
! Correct 'no_code_for' error message
!
! Revision 2.84  2013/08/30 02:45:38  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.83  2013/08/20 00:33:40  pwagner
! Avoid more crashes caused by non-Aura l1boa data
!
! Revision 2.82  2013/08/16 02:50:42  vsnyder
! Add MAF and SpacingOnly arguments to UsingMagneticModel
!
! Revision 2.81  2013/08/13 02:23:06  vsnyder
! Move magnetic field stuff to Magnetic_Field_Quantity
!
! Revision 2.80  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.79  2013/07/18 01:10:57  vsnyder
! Remove scVel since it's ambiguous whether it's ECI or ECR, and nobody
! uses it anyway.
!
! Revision 2.78  2013/06/29 00:18:04  pwagner
! Changed switch to dump l1b fills to -Sl1bfill
!
! Revision 2.77  2013/05/31 00:42:12  vsnyder
! Add geolocation field to fill, used only if method=l1b
!
! Revision 2.76  2013/05/22 20:09:50  pwagner
! Print only if verboser
!
! Revision 2.75  2013/05/21 01:47:34  vsnyder
! Don't look at QUITNOW until you're sure it's there
!
! Revision 2.74  2013/05/17 00:52:01  pwagner
! May constrain Transfer command command to quantitynames by r/t Boolean; r/t sep now achar(0)
!
! Revision 2.73  2013/04/05 23:20:47  pwagner
! Requires verbose settings for extra printing
!
! Revision 2.72  2013/02/01 23:42:25  vsnyder
! Use CreateVectorValue instead of Allocate_Test
!
! Revision 2.71  2013/01/14 21:22:51  pwagner
! Changed chiSqRatio when skipped to 999
!
! Revision 2.70  2013/01/02 21:41:31  pwagner
! Added derivative method to Fill command; Transfer can do Fill methods, too
!
! Revision 2.69  2012/12/20 01:05:26  vsnyder
! Provide coherent-to-minor frame interpolation
!
! Revision 2.68  2012/11/14 00:59:23  pwagner
! Use dimList for choosing which of {csi} to average over
!
! Revision 2.67  2012/11/08 23:21:51  pwagner
! dimList field lets us specifiy whether to shift by [c,s,i] during manipulate
!
! Revision 2.66  2012/11/05 19:04:28  pwagner
! Most Fill methods need not handle dontMask themselves
!
! Revision 2.65  2012/10/22 18:15:47  pwagner
! Many Subset operations now available in Fill
!
! Revision 2.64  2012/10/09 00:48:31  pwagner
! New ignoreTemplate, changed force meaning in Fill
!
! Revision 2.63  2012/08/16 17:58:00  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.62  2012/08/08 19:57:06  vsnyder
! Use a matrix block instead of a real array in FillCovariance
!
! Revision 2.61  2012/07/31 00:49:02  vsnyder
! Use DestroyVectoryQuantityMask abstraction
!
! Revision 2.60  2012/06/07 22:46:03  pwagner
! Turn off warnings about non-monotonic Ptan in FromProfile
!
! Revision 2.59  2012/06/07 00:53:25  vsnyder
! More, and more consistent, -g tracing
!
! Revision 2.58  2012/05/08 17:51:58  pwagner
! Disabled another debugging bloc
!
! Revision 2.57  2012/04/26 23:30:04  pwagner
! Monotonize ptan heights when needed; (should we sort instead?)
!
! Revision 2.56  2012/04/20 01:06:03  pwagner
! Changes to bin, ChiSqRatio, and Interpolating to remove bugs, hopefully adding none
!
! Revision 2.55  2012/03/12 17:11:46  pwagner
! 'ln' same as 'log' in manipulate fills; new 'cgrid' switch
!
! Revision 2.54  2012/02/24 21:22:02  pwagner
! DirectRead may /interpolate vertically
!
! Revision 2.53  2012/02/16 22:39:02  pwagner
! Dont automatically in AutoFillVector
!
! Revision 2.52  2012/01/25 01:18:05  pwagner
! Fixed most bugs in QtyFromFile and VectorFromFile; now can select by attributes
!
! Revision 2.51  2012/01/18 20:38:36  vsnyder
! Add 'matrix and vector inconsistent' error message
!
! Revision 2.50  2011/12/15 01:50:26  pwagner
! Added sdName and /spread fields to DirectRead
!
! Revision 2.49  2011/11/30 21:30:00  pwagner
! Fixed bug affecting skipped retrievals
!
! Revision 2.48  2011/11/04 23:46:45  pwagner
! Fixed bug added with last commit
!
! Revision 2.47  2011/11/04 00:24:39  pwagner
! Added procedures to auto special qties in a vector, fill a qty from a file, and fill a vector from a file
!
! Revision 2.46  2011/07/20 00:53:40  pwagner
! Fixed bug added in rev2.43
!
! Revision 2.45  2011/06/16 20:51:24  vsnyder
! Make Announce_Error codes public
!
! Revision 2.44  2011/04/20 16:46:00  pwagner
! Fixed solecism that NAG complained about
!
! Revision 2.43  2011/04/13 00:28:15  pwagner
! manipulation can now accept digits
!
! Revision 2.42  2011/04/07 23:35:31  pwagner
! Fixed bug in handling manipulation='(c - c*a)*b'
!
! Revision 2.41  2011/03/08 18:29:22  pwagner
! Added shift,slip,chaannel,surface,instance functions to manipulate fills
!
! Revision 2.40  2010/07/06 16:05:37  pwagner
! Better error checking in MaanipulateVectors
!
! Revision 2.39  2010/07/01 00:49:33  pwagner
! Transfer between vectors may now also manipulate
!
! Revision 2.38  2010/06/18 16:48:34  pwagner
! Corrected error that prevented filling radiances qty from l1b
!
! Revision 2.37  2010/05/24 16:33:52  honghanh
! Merge changes in version 2.35 and 2.36
!
! Revision 2.35  2010/05/19 23:06:45  pwagner
! Shorten most Fill routine names
!
! Revision 2.34  2010/04/28 16:23:52  pwagner
! May specify instances range in explicit Fill
!
! Revision 2.33  2010/04/22 23:36:00  pwagner
! May fill num rads/MIF as a percentage
!
! Revision 2.32  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
! Revision 2.31  2009/12/14 18:35:51  pwagner
! Dont crash in FromGrid if Grid is empty
!
! Revision 2.30  2009/10/27 22:14:24  pwagner
! Compiles with new api for Dump vector quantity
!
! Revision 2.29  2009/09/01 17:14:02  pwagner
! Reduce severity of profile mismatch in FromL2GP to permit filling 1d sids with truth
!
! Revision 2.28  2009/08/24 20:14:11  pwagner
! May Fill H2O precision from RHi precision
!
! Revision 2.27  2009/07/21 20:34:56  pwagner
! chi^2 ratio nay hold values for iterations prior to final
!
! Revision 2.26  2009/07/10 20:56:52  pwagner
! Fixed bug affecting manipulations like 'a+b+c'
!
! Revision 2.25  2009/06/30 15:19:05  pwagner
! Fixed bug in Explicit
!
! Revision 2.24  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.23  2009/05/13 20:41:55  vsnyder
! Get constants from Constants, kinds from MLSKinds
!
! Revision 2.22  2009/05/01 23:44:40  pwagner
! Restored nearly all except for conversions between RHi and H2O
!
! Revision 2.21  2009/04/30 22:13:29  pwagner
! name of bit in MaskVectorQty and isVectorQtyMasked now mandatory
!
! Revision 2.20  2009/04/30 20:15:01  pwagner
! Another fix to Masking bit miscues in RHi..
!
! Revision 2.19  2009/04/29 23:11:04  pwagner
! Explicit can Fill from an optional extraQuantity
!
! Revision 2.18  2009/04/28 20:03:49  pwagner
! Consider only Mask of quantity being filled, not sources in RHi
!
! Revision 2.17  2009/04/16 21:55:23  pwagner
! /exact keyword in status Fill to fix radiance bug
!
! Revision 2.16  2009/04/13 20:45:57  pwagner
! heightRange in explicit Fill can fill above or below specified height
!
! Revision 2.15  2009/03/05 18:38:32  pwagner
! May specifiy height, channel with explicit Fill
!
! Revision 2.14  2008/10/15 16:37:28  pwagner
! Let precisions explicitly set negative also Mask radiances
!
! Revision 2.13  2008/09/24 16:46:09  livesey
! Changed ptan from optional to pointer in fill from profile
!
! Revision 2.12  2008/09/20 00:03:00  pwagner
! Added print statement to not_used_here
!
! Revision 2.11  2008/09/16 22:30:19  pwagner
! Use optional arg ptan when source is profile, vector
!
! Revision 2.10  2008/08/14 20:58:40  pwagner
! /interpolate now possible field in Transfer command
!
! Revision 2.9  2008/08/06 17:27:47  pwagner
! Fill by manipulation now respects Mask better
!
! Revision 2.8  2008/06/06 21:02:49  michael
! added fill method uncompressRadiance
!
! Revision 2.7  2008/04/26 00:39:56  livesey
! Added total power stuff
!
! Revision 2.6  2008/04/11 01:17:09  livesey
! Added uncompressRadiance fill
!
! Revision 2.5  2008/01/07 21:43:03  pwagner
! Fixed bug regarding unrecognized ops '<' and '>' in catTwoOperands
!
! Revision 2.4  2007/11/05 18:41:20  pwagner
! expr with 'c' unambiguous (I hope); '^' power op added to expr
!
! Revision 2.3  2007/11/01 23:33:59  pwagner
! rewrite to permit functions and algebra in same manipulation; needs more testing
!
! Revision 2.2  2007/10/04 20:43:12  vsnyder
! Remove unused symbols
!
! Revision 2.1  2007/09/27 21:59:00  pwagner
! First commit
!
@


2.156
log
@Turned off printing in residualCorrection unless verbose
@
text
@d1745 1
d1761 2
a1762 1
      if ( REPLACEINFS .and. any( IsInfinite(quantity%values(1,:))) ) &
d1764 1
d1766 6
d8360 1
a8360 1
       "$Id: FillUtils_1.f90,v 2.155 2023/12/07 23:08:01 pwagner Exp $"
d8372 3
@


2.155
log
@Improved ResidualCorrection Fill method
@
text
@d7020 1
d7022 1
d7031 4
a7034 2
      call outputNamedValue ( 'Band name', trim(BandName) )
      call Dump( quantity%values(:,1), 'values before correction (maf 1)' )
d7048 4
a7051 2
      call outputNamedValue ( 'string fragment', trim(filenameStr) )
      call outputNamedValue ( 'full path', trim(inputPhysicalFilename) )
d7066 1
a7066 1
      call OutputNamedValue ( 'number of lines read', nLines )
d7079 2
a7080 1
      call OutputNamedValue ( 'T(ref) sorted from large to small?', NegativeSort )
d7176 5
a7180 3
      call Dump( quantity%values(:,1), 'values after correction (maf 1)' )
      call outputNamedValue ( 'Tmin', Tmin )
      call outputNamedValue ( 'Tmax', Tmax )
d7183 1
a7183 1
      call Diff( quantity%values, 'original', &
d8351 1
a8351 1
       "$Id: FillUtils_1.f90,v 2.154 2023/10/19 20:40:54 pwagner Exp $"
d8363 3
@


2.154
log
@Added stub for residualCorrection Fill method; needs work
@
text
@d19 1
d83 2
a84 2
    & StringElement, StringElementNum, SwitchDetail
  use MLSStrings, only: Indexes, LowerCase, WriteIntsToChars
d6928 7
a6934 2
    subroutine ResidualCorrection ( key, quantity, radianceQuantity, filename )
      use Io_stuff, only: Get_lun
d6936 3
a6938 1
      use Machine, only: Io_error
d6942 4
a6945 3
      type (VectorValue_T), intent(in) :: RADIANCEQUANTITY
      integer, intent(in) :: FILENAME   ! ASCII filename to read from

d6947 1
a6947 1
      integer :: Me = -1                  ! String index for trace
d6951 23
d6975 45
d7021 1
d7028 10
a7037 8
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Radiance quantity for offsetRadiance fill is not radiance' )
      if ( quantity%template%signal /= radianceQuantity%template%signal .or. &
        & quantity%template%sideband /= radianceQuantity%template%sideband ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity and rad. qty. in offsetRadiance fill different signal/sideband' )
d7044 2
d7049 127
a7175 4
        call io_Error ( "Unable to open ASCII input file ", status, fileNameStr )
        call get_where ( where(key), fileNameStr, before='Error opening ASCII file at ' )
        call MLSMessage( MLSMSG_Error, ModuleName, fileNameStr )
      end if
d7177 1
d8342 1
a8342 1
       "$Id: FillUtils_1.f90,v 2.153 2023/05/25 22:27:35 pwagner Exp $"
d8354 3
@


2.153
log
@Try to avoid Filling convergence with ieee Infinity
@
text
@d23 1
a23 1
  use HighOutput, only: BeVerbose, OutputNamedValue
d69 1
a69 1
  use MLSFiles, only: Hdfversion_5, Dump, GetMLSFileByType
d78 1
d201 1
a201 1
    & Scaleoverlaps, Scatter, SpreadChannelfill, &
a5382 1
      use HighOutput, only: LetsDebug
d6926 48
d7770 31
d8136 1
a8136 1
       "$Id: FillUtils_1.f90,v 2.152 2021/06/10 23:46:06 pwagner Exp $"
d8148 3
@


2.152
log
@When copying vector qties, copy their BinNumber and MAF, too
@
text
@d70 1
a70 1
  use MLSFillValues, only: IsFillValue, IsFinite, &
d123 2
a124 1
  integer, public :: FILLERROR
d1758 2
d8057 1
a8057 1
       "$Id: FillUtils_1.f90,v 2.151 2021/05/13 23:26:37 pwagner Exp $"
d8069 3
@


2.151
log
@Minor housekeeping; more comments about the start array
@
text
@d2093 1
d2095 1
d2186 12
d3756 1
d3781 12
d7210 11
a7220 1
        if ( .not. skipValues ) dq%values = sq%values
d8054 1
a8054 1
       "$Id: FillUtils_1.f90,v 2.150 2020/01/27 18:03:13 pwagner Exp $"
d8066 3
@


2.150
log
@Worked around the error that made instrumentModuleName allcaps
@
text
@d68 1
a68 1
  use MLSCommon, only: MLSFile_T, DefaultUndefinedValue
d129 1
a129 1
  ! Error codes for "announce_error"
d239 1
a239 1
        call Announce_error ( key, No_Error_code, &
d289 9
a297 3
    ! ---------------------------------------------  ANNOUNCE_ERROR  -----
    subroutine ANNOUNCE_ERROR ( WhereWasIt, CODE, &
      & EXTRAMESSAGE, QTY, EXTRAINFO, QUITNOW )
d306 2
a307 1
      logical, intent(in), optional :: QUITNOW
d310 1
d318 1
a318 1
        & 'Calling ANNOUNCE_ERROR' )
d443 1
a443 1
    end subroutine ANNOUNCE_ERROR
d704 1
a704 1
            if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
d713 1
a713 1
            if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
d719 1
a719 1
            if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
d724 1
a724 1
            if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
d743 1
a743 1
        call announce_error ( valuesNode, no_error_code, &
d748 1
a748 1
        call announce_error ( valuesNode, no_error_code, &
d761 1
a761 1
        call announce_error ( valuesNode, no_Error_Code, &
d910 1
a910 1
          & call announce_error ( key, no_Error_Code, 'Quantity to fill must be of type singleChannelRadiance' )
d912 1
a912 1
          & call announce_error ( key, no_Error_Code, 'source quantity for fill must be of type [cloudInduced]radiance' )
d915 1
a915 1
          & call announce_error ( key, no_Error_Code, 'quantity/sourceQuantity must be same signal/sideband' )
d988 1
a988 1
        call Announce_error ( key, No_Error_code, &
d1000 1
a1000 1
        call Announce_error ( key, No_Error_code, &
d1005 1
a1005 1
        call Announce_error ( key, No_Error_code, &
d1127 1
a1127 1
        call Announce_error ( key, No_Error_code, &
d1139 1
a1139 1
        call Announce_error ( key, No_Error_code, &
d1144 1
a1144 1
        call Announce_error ( key, No_Error_code, &
d1270 1
a1270 1
        call Announce_error ( key, No_Error_code, &
d1282 1
a1282 1
        call Announce_error ( key, No_Error_code, &
d1287 1
a1287 1
        call Announce_error ( key, No_Error_code, &
d1401 1
a1401 1
        call Announce_error ( key, No_Error_code, &
d1406 1
a1406 1
        call Announce_error ( key, No_Error_code, &
d1411 1
a1411 1
        call Announce_error ( key, No_Error_code, &
d1416 1
a1416 1
        call Announce_error ( key, No_Error_code, &
d1546 1
a1546 1
        call Announce_error ( key, No_Error_code, &
d1550 1
a1550 1
        call Announce_error ( key, No_Error_code, &
d1555 1
a1555 1
        call Announce_error ( key, No_Error_code, &
d1560 1
a1560 1
        call Announce_error ( key, No_Error_code, &
d1564 1
a1564 1
        call Announce_error ( key, No_Error_code, &
d1576 1
a1576 1
        call Announce_error ( key, No_Error_code, &
d1611 1
a1611 1
          call Announce_error ( key, No_Error_code, &
d1743 1
a1743 1
        if ( quantity%template%quantityType /= l_quality ) call Announce_error ( key, no_error_code, &
d1745 1
a1745 1
        if ( sourceQuantity%template%quantityType /= l_dnwt_chisqRatio ) call Announce_error ( &
d2386 1
a2386 1
    ! them into the quanity's values
d2412 12
d2610 1
a2610 1
        call Announce_error ( 0, no_error_code, 'GPH precision needed for result of GPHPrecision' )
d2870 1
a2870 1
          & call Announce_error ( key, no_error_code, 'Problem with temperature quantity for phiTan fill' )
d2874 1
a2874 1
          & call Announce_error ( key, no_error_code, 'Problem with H2O quantity for phiTan fill' )
d2965 1
a2965 1
          & call Announce_error ( key, no_error_code, 'Problem with temperature quantity for phiTan fill' )
d2969 1
a2969 1
          & call Announce_error ( key, no_error_code, 'Problem with H2O quantity for phiTan fill' )
d3746 1
a3746 1
          call Announce_error ( key, no_error_code, &
d3751 1
a3751 1
          call Announce_error ( key, no_error_code, &
d3756 1
a3756 1
          call Announce_error ( key, no_error_code, &
d3761 1
a3761 1
          call Announce_error ( key, no_error_code, &
d3778 1
a3778 1
          call Announce_error ( key, no_error_code, &
d3782 1
a3782 1
          call Announce_error ( key, no_error_code, &
d3842 1
a3842 1
                call announce_error ( key, no_error_code, &
d4859 1
a4859 1
        call Announce_error ( 0, no_error_code, &
d4946 1
a4946 1
        call Announce_error ( 0, no_error_code, &
d5028 1
a5028 1
    ! them into the quanity's values
d5054 2
d5331 1
a5331 1
        if ( unitsError ) call Announce_error ( termsNode, wrongUnits, &
d5647 1
a5647 1
        if ( quantity%template%quantityType /= l_quality ) call Announce_error ( key, no_error_code, &
d5649 1
a5649 1
        if ( sourceQuantity%template%quantityType /= l_chisqBinned ) call Announce_error ( &
d5651 1
a5651 1
        if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) ) call Announce_error ( &
d5660 1
a5660 1
        if ( unitsError ) call Announce_error ( heightNode, wrongUnits, &
d5702 1
a5702 1
        if ( quantity%template%quantityType /= l_status ) call Announce_error ( key, no_error_code, &
d5705 1
a5705 1
          & call Announce_error ( &
d5716 1
a5716 1
        if ( unitsError ) call Announce_error ( heightNode, wrongUnits, &
d6458 1
a6458 1
          & call Announce_error ( valuesNode, no_Error_Code, 'Bad height units for profile fill' )
d6468 1
a6468 1
          & call Announce_error ( valuesNode, no_error_code, 'Bad units for profile fill' )
d7021 1
a7021 1
          call Announce_error ( multiplierNode, wrongUnits, &
d7043 1
a7043 1
          call Announce_error ( multiplierNode, wrongUnits, &
d7435 1
a7435 1
        if ( unitsError ) call Announce_error ( termsNode, wrongUnits, &
d7720 1
a7720 1
          & call announce_error( no_Error_Code, No_Error_code, &
d7730 1
a7730 1
          & call announce_error( no_Error_Code, No_Error_code, &
d7733 1
a7733 1
          & call announce_error( no_Error_Code, No_Error_code, &
d7736 1
a7736 1
          & call announce_error( no_Error_Code, No_Error_code, &
d8005 1
a8005 1
      if ( unitsError ) call Announce_error ( node, wrongUnits, &
d8017 1
a8017 1
       "$Id: FillUtils_1.f90,v 2.149 2020/01/09 22:25:41 pwagner Exp $"
d8029 3
@


2.149
log
@Extra steps to avoid munging sids-related DS names
@
text
@d4209 6
d4310 3
d4326 2
d4465 1
d4481 1
d4493 1
d4507 1
d7995 1
a7995 1
       "$Id: FillUtils_1.f90,v 2.148 2019/09/27 16:48:42 pwagner Exp $"
d8007 3
@


2.148
log
@Removed faulty goto 999 from NamedQtyFromFile
@
text
@d4455 1
a4455 1
          & finder(found)%tngt, trim(nameString))
d4470 1
a4470 1
            & finder(found)%tngt, trim(nameString))
d4481 3
a4483 1
            & finder(found)%tngt, trim(nameString))
d4494 1
a4494 1
            & finder(found)%tngt, trim(nameString))
d7980 1
a7980 1
       "$Id: FillUtils_1.f90,v 2.147 2019/01/24 00:02:27 pwagner Exp $"
d7992 3
@


2.147
log
@Coded around a strange NAG error
@
text
@a7793 1
      goto 999
d7978 1
a7978 1
       "$Id: FillUtils_1.f90,v 2.146 2018/12/07 00:21:58 pwagner Exp $"
d7990 3
@


2.146
log
@Corrected error in LogMyData; will log only if verbose
@
text
@d81 1
a81 1
    & StringElement, SwitchDetail
d7515 2
d7547 5
a7551 3
      do dsi=1, NumStringElements( trim(DSNames), countEmpty )
        call LogMyData ( mesg='dsi', data=dsi )
        do sqi = 1, size ( vector%quantities )
d7571 6
a7576 3
          if ( lowercase(trim(name)) /= &
            & lowercase(StringElement( DSNames, dsi, countEmpty )) ) &
            & cycle
d7589 2
d7592 2
a7593 2
        end do
      end do
d7979 1
a7979 1
       "$Id: FillUtils_1.f90,v 2.145 2018/11/30 17:48:25 pwagner Exp $"
d7991 3
@


2.145
log
@These calls to LogMyData caused crashes; need investigation before being restored
@
text
@d182 20
a201 22
  public :: addGaussianNoise, applyBaseline, autoFillVector, &
      & computeTotalpower, &
      & extractsinglechannel, fillcovariance, fromanother, fromgrid, &
      & froml2gp, fromprofile, gather, geoiddata, losvelocity, &
      & chisqchan, chisqmmaf, chisqmmif, chisqratio, &
      & colabundance, derivativeofsource, foldedradiance, phitanwithrefraction, heightFromPressure, &
      & iwcfromextinction, rhifromortoh2o, noradspermif, &
      & rhiprecisionfromortoh2o, withestnoise, &
      & Hydrostatically_GPH, Hydrostatically_PTan, fromSplitSideband, &
      & GPHPrecision, fromIsotope, fromAsciiFile, rotateMagneticField, &
      & explicit, froml1b, &
      & froml2aux, usingmagneticmodel, &
      & frominterpolatedqty, fromlosgrid, &
      & bymanipulation, manipulatevectors, NearestProfiles, &
      & withreflectortemperature, withascordesc, withreichlerwmotp, &
      & withwmotropopause, withbinresults, withboxcarfunction, &
      & statusquantity, qualityfromchisq, convergencefromchisq, &
      & usingleastsquares, offsetradiancequantity, resetunusedradiances, &
      & scaleoverlaps, scatter, spreadchannelfill, &
      & transfervectors, transfervectorsbymethod, &
      & uncompressradiance, &
      & announce_error, qtyfromfile, vectorfromfile
d7457 2
a7458 2
      character (LEN=10*MAXLISTLENGTH)        :: attrnames
      character (LEN=10*MAXLISTLENGTH)        :: attrvalues
d7517 2
a7518 2
      character (LEN=10*MAXLISTLENGTH)        :: attrnames
      character (LEN=10*MAXLISTLENGTH)        :: attrvalues
d7527 2
a7528 1
      verbose = index(lowercase(options), 'v') > 0
d7541 4
a7544 2
      ! call LogMyData ( mesg='NumStringElements( trim(DSNames), countEmpty )', data=NumStringElements( trim(DSNames), countEmpty ) )
      ! call LogMyData ( mesg='size ( vector%quantities )', data=size ( vector%quantities ) )
d7546 1
a7546 1
        ! call LogMyData ( mesg='dsi', data=dsi )
d7579 1
a7579 1
            ! call LogMyData ( mesg='sqi', data=sqi )
d7585 1
a7585 1
      ! call LogMyData ( mesg='Whew! Barely made it.' )
d7594 1
a7594 1
        character(len=8)                             :: dchars
d7596 1
d7601 3
a7603 1
          chars = trim(chars) // ': ' // dchars
d7970 1
a7970 1
       "$Id: FillUtils_1.f90,v 2.144 2018/07/27 23:18:48 pwagner Exp $"
d7982 3
@


2.144
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d7542 2
a7543 2
      call LogMyData ( mesg='NumStringElements( trim(DSNames), countEmpty )', data=NumStringElements( trim(DSNames), countEmpty ) )
      call LogMyData ( mesg='size ( vector%quantities )', data=size ( vector%quantities ) )
d7545 1
a7545 1
        call LogMyData ( mesg='dsi', data=dsi )
d7547 2
a7548 2
          if ( dsi > 123 .and. sqi > 120 ) &
            & call LogMyData ( mesg='sqi', data=sqi )
d7564 2
a7565 2
          if ( dsi > 123 .and. sqi > 123 ) &
            & call LogMyData ( mesg='Deciding about sqi', data=sqi )
d7578 1
a7578 1
            call LogMyData ( mesg='sqi', data=sqi )
d7584 1
a7584 1
      call LogMyData ( mesg='Whew! Barely made it.' )
d7966 1
a7966 1
       "$Id: FillUtils_1.f90,v 2.143 2018/06/27 00:01:14 pwagner Exp $"
d7978 3
@


2.143
log
@Dont complain about invalid temperatures in WithReichlerWMOTP
@
text
@d7501 1
d7542 2
d7545 1
d7547 2
d7557 2
d7564 2
d7578 1
d7584 1
d7588 15
d7746 1
d7778 4
d7877 1
a7877 1
      call trace_end ( 'FillUtils_1.NamedQtyFromFile', &
d7966 1
a7966 1
       "$Id: FillUtils_1.f90,v 2.142 2018/04/16 22:16:45 pwagner Exp $"
d7978 3
@


2.142
log
@fixed bug in character array constructor for non-auto casenames
@
text
@d98 1
a98 1
    & DestroyVectorQuantityValue, Dump, DumpQuantityMask, &
a441 1
      use HighOutput, only: outputNamedValue
d4213 2
a4214 2
      use BitStuff, only: negativeIfBitPatternSet
      use Init_Tables_Module, only: l_ECR, l_geocentric, l_geodetic, l_none
d5315 2
a5316 2

      use WMOTropopause, only: extraTropics, TWMO
d5328 1
d5345 1
a5345 1

d5379 1
a5379 1
          call output('invalid temperatures in this instance', advance='yes' )
d5437 2
a5438 2
      use Geometry, only: geodToGeocLat
      use Hydrostatic_M, only: hydrostatic
d7934 1
a7934 1
       "$Id: FillUtils_1.f90,v 2.141 2018/04/13 00:19:18 pwagner Exp $"
d7946 3
@


2.141
log
@Plain hdf DirectWrites and -Reads are now 'auto'
@
text
@d7753 1
a7753 1
      if ( any( casename == (/ 'l2aux   ', 'swath  ', 'l2gp    ' /) ) ) then
d7934 1
a7934 1
       "$Id: FillUtils_1.f90,v 2.140 2018/03/14 22:54:12 pwagner Exp $"
d7946 3
@


2.140
log
@Stop computing unneeded arrays in HeightFromPressure
@
text
@d7717 2
a7718 1
      use MLSHDF5, only: GetHDF5Attribute, GetHDF5DSDims, LoadFromHDF5DS
d7729 1
d7740 1
d7749 1
a7749 1
      verbose = ( switchDetail(switches, 'fill') > 0 )
d7752 12
a7763 1
      select case (lowercase(fileType))
d7776 8
a7783 4
      case default ! E.g., 'hdf'
        call Allocate_test ( values, dimInts(1), dimInts(2), dimInts(3), 'values read from file', ModuleName )
        call loadFromHDF5DS ( MLSFile, &
          & trim(Name), values ) ! quantity%values )
d7849 19
d7934 1
a7934 1
       "$Id: FillUtils_1.f90,v 2.139 2018/02/27 16:23:12 livesey Exp $"
d7946 3
@


2.139
log
@Fixed erroneous error message
@
text
@d2924 1
a2924 1
      use Geometry, only: Earthrada, Earthradb, Geodtogeoclat
a2925 2
      use Phi_Refractive_Correction_M, only: Phi_Refractive_Correction_Up
      use Refraction_M, only: Refractive_Index
d2936 2
a2937 5
      real(rp), dimension(quantity%template%noInstances) :: CP2, CSQ, REQ, SP2
      real(rp) :: PhiCorrs(temperature%template%noInstances,temperature%template%noSurfs)
      real(rp), dimension(temperature%template%noInstances) :: REQS
      real(rv), dimension(temperature%template%noSurfs) :: Heights, N, PhiCorr, PS
      integer :: I, J     ! Subscripts, loop inductors
d2967 2
a2968 2
      call InterpolateValues ( quantity%values(1,:), req, &
        & temperature%template%phi(1,:), reqs, 'Linear', extrapolate='Constant' )
d2971 1
a2971 1
      ps = 10.0**(-temperature%template%surfs(:,1))
d7897 1
a7897 1
       "$Id: FillUtils_1.f90,v 2.138 2018/02/26 19:04:53 livesey Exp $"
d7909 3
@


2.138
log
@More error messages.
@
text
@d737 1
a737 1
      if ( quantity%template%noSurfs <= 1 ) then
d742 1
a742 1
      if ( quantity%template%noCrossTrack <= 1 ) then
d7902 1
a7902 1
       "$Id: FillUtils_1.f90,v 2.137 2018/02/23 22:09:52 mmadatya Exp $"
d7914 3
@


2.137
log
@Added l_instECR for ASMLS
@
text
@d737 11
d799 1
a799 1
      call trace_end ( 'FillUtils_1.Explicit', &
d7902 1
a7902 1
       "$Id: FillUtils_1.f90,v 2.136 2017/12/15 18:33:19 mmadatya Exp $"
d7914 3
@


2.136
log
@Added heightFromPressure as new Fill method
@
text
@d46 1
a46 1
    & L_Sceci, L_Scecr, L_Scgeocalt, L_Scveleci, L_Scvelecr, &
d4207 1
a4207 1
      & IsPrecision, Suffix, Geolocation, PrecisionQuantity, BOMask )
d4220 2
d4248 1
a4248 1
      type(finder_t), parameter :: Finder(18) = [ &
d4260 1
d7891 1
a7891 1
       "$Id: FillUtils_1.f90,v 2.135 2017/12/07 01:01:23 vsnyder Exp $"
d7903 3
@


2.135
log
@Don't use host-associated variable as a DO index
@
text
@d187 1
a187 1
      & colabundance, derivativeofsource, foldedradiance, phitanwithrefraction, &
d2908 77
d7888 1
a7888 1
       "$Id: FillUtils_1.f90,v 2.134 2017/10/31 23:47:33 vsnyder Exp $"
d7900 3
@


2.134
log
@Make Coefficients a parameterized type
@
text
@d7492 1
d7811 1
a7811 1
       "$Id: FillUtils_1.f90,v 2.133 2017/09/20 00:02:58 vsnyder Exp $"
d7823 3
@


2.133
log
@Shorten a log comment so compilers don't complain
@
text
@d75 1
a75 1
  use MLSNumerics, only: Coefficients_R8, InterpolateArraySetup, &
d5950 1
a5950 1
      type (Coefficients_R8) :: COEFFS  ! For interpolation
d7810 1
a7810 1
       "$Id: FillUtils_1.f90,v 2.132 2017/07/27 16:59:42 pwagner Exp $"
d7822 3
@


2.132
log
@VectorFromFile may read qties from a named group
@
text
@d7810 1
a7810 1
       "$Id: FillUtils_1.f90,v 2.131 2017/07/10 18:52:32 pwagner Exp $"
d7822 3
d7826 2
a7827 1
! Transfer may /expandMask to all masking bits; may /skipValues to transfer only mask; Fill may replaceMissingValue=; correct Transfer by attribute
@


2.131
log
@Transfer may /expandMask to all masking bits; may /skipValues to transfer only mask; Fill may replaceMissingValue=; correct Transfer by attribute
@
text
@d7412 1
a7412 1
      & filetype, options, spread, interpolate )
d7415 1
a7415 1
      integer, intent(in) :: KEY        ! Tree node
d7417 6
a7422 5
      type (MLSFile_T), pointer   :: MLSFile
      character(len=*), intent(in) :: FILETYPE
      character(len=*), intent(in) :: OPTIONS
      logical, intent(in)                    :: spread
      logical, intent(in)                    :: interpolate
d7479 6
a7484 3
          if ( len_trim(name) > 0 ) &
            & call NamedQtyFromFile ( key, quantity, MLSFile, &
            & filetype, name, spread, interpolate, homogeneous )
d7810 1
a7810 1
       "$Id: FillUtils_1.f90,v 2.130 2017/04/06 23:43:34 pwagner Exp $"
d7822 3
@


2.130
log
@May choose to base on asc/desc mode on GHz/GeodAngle via manipulation field
@
text
@d124 1
d442 1
d457 1
d460 1
a460 1

d477 5
d485 1
d490 1
d506 1
d511 1
d5815 3
a5817 1
    subroutine FromGrid(quantity, grid, allowMissing, errorCode)
d5823 1
d5834 1
d5843 1
d5875 4
d5900 4
a5903 2
            &  newValue <= nearest ( grid%missingValue,  1.0 ) .and. &
            & .not. allowMissing ) errorCode = MissingDataInGrid
d6995 2
a6996 1
    subroutine TransferVectors ( source, dest, skipMask, interpolate, &
d7003 1
d7005 1
d7024 9
d7060 1
a7060 1
        dq%values = sq%values
d7065 5
d7435 1
d7441 1
a7441 1
      call output( 'Now in VectorFromFile', advance='yes' )
d7443 11
a7453 1
      call dump( DSNames )
d7457 7
a7463 21
          ! How do we access the dataset to read? By name or by attribute?
          if ( index(lowercase(options), 'a') < 1 ) then
            ! By name
            if ( index(lowercase(options), 'num') < 1 ) then
              if ( quantity%template%name < 1 ) &
                & call Announce_Error ( key, no_Error_Code, &
                &   'template name is 0?' )
              call get_string( quantity%template%name, Name )
            else
              call writeIntsToChars ( sqi, Name )
              Name = 'Quantity ' // trim(Name)
            end if
            if ( lowercase(trim(name)) /= &
              & lowercase(StringElement( DSNames, dsi, countEmpty )) ) &
              & cycle
            if ( addSlash ) Name = '/' // Name
            if ( DEEBUG ) then
              call outputNamedValue( 'shape(values)' // trim(name), &
                & shape(quantity%values) )
              call dump( MLSFile )
            end if
d7465 12
a7476 10
            ! By attribute
            attrnames  = 'TemplateName,tempQtyType'
            call Get_String ( quantity%template%name, str, strip=.true. )
            attrvalues = str
            call Get_String ( lit_indices(quantity%template%quantityType), &
              & str, strip=.true. )
            attrvalues = trim(attrvalues) // ',' // str
            call MatchHDF5Attributes ( MLSFile, attrNames, attrValues, name )
            ! call Announce_Error ( key, no_Error_Code, &
            ! &   'Unable to read Vector from File by attribute yet' )
d7485 23
d7655 1
a7655 1
      verbose = ( switchDetail(switches, 'fill') > -1 )
d7680 1
d7683 1
d7699 1
d7702 1
d7722 1
d7731 1
d7806 1
a7806 1
       "$Id: FillUtils_1.f90,v 2.129 2017/02/08 19:22:00 pwagner Exp $"
d7818 3
@


2.129
log
@/sourceMask causes vector Fills to obey mask from source, not destination
@
text
@d4972 2
a4973 1
    subroutine WithAscOrDesc ( key, quantity, chunk, fileDatabase, HGrids, PtanQuantity )
d4984 5
d5002 3
d5006 5
d5015 1
a5015 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d5017 36
a5052 11

      L1BOAFile => GetMLSFileByType(filedatabase, content='l1boa')
      call ReadL1BData ( L1BOAFile, 'sc/VelECI', L1BDATA, noMAFs, &
        & flag=l1bError, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & NeverFail= .true., &
        & dontPad=DONTPAD )
      if ( .not. associated( L1BData%dpField ) ) then
        call trace_end ( 'FillUtils_1.WithAscOrDesc', &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        return
      end if
d5054 1
a5055 2
      call Allocate_test ( Heights, ptanQuantity%template%nosurfs, &
        & ptanQuantity%template%noinstances, 'Heights', ModuleName )
d5057 2
d5061 2
d5065 1
d5074 11
a5084 2
          quantity%values(j,i) = sign(1._rv, &
          & L1BData%dpField(3, indices(1), maf))
d5087 1
a5087 2
      if ( associated ( ptanQuantity ) .and. .not. Quantity%template%minorFrame ) &
        & call Deallocate_test ( Heights, 'Heights', ModuleName )
d7738 1
a7738 1
       "$Id: FillUtils_1.f90,v 2.128 2016/10/20 19:18:30 vsnyder Exp $"
d7750 3
@


2.128
log
@Use tngtECE%value3 and scVel%value3, which eliminates the need to calculate
2D subscripts for XYZ, MIF, MAF, and eliminates a seg fault with NAG build
1052.
@
text
@d16 73
a88 73
  use Allocate_deallocate, only: allocate_test, deallocate_test
  use Chunks_m, only: MLSChunk_t
  use Constants, only: deg2rad, ln10, rad2deg
  use Dump_0, only: dump
  use Expr_m, only: expr, expr_check, getindexflagsfromlist
  use GriddedData, only: griddedData_t, dump, wrapGriddedData
  use HDF5, only: HSize_t, H5DOpen_f, H5DClose_f
  use HighOutput, only: beVerbose, outputNamedValue
  use Init_tables_module, only: f_measurements, f_totalpowervector, &
    & f_weightsvector, &
    & l_addnoise, l_baseline, l_binmax, l_binmean, l_binmin, l_bintotal, &
    & l_boundarypressure, l_boxcar, l_chisqbinned, l_chisqchan, &
    & l_chisqmmaf, l_chisqmmif, &
    & l_cloudinducedradiance, l_cloudminmax, &
    & l_columnabundance, &
    & l_dnwt_flag, l_dnwt_chisqminnorm, l_dnwt_chisqnorm, l_dnwt_chisqratio, &
    & l_dobsonunits, l_du, &
    & l_ecrtofov, &
    & l_fieldazimuth, l_fieldelevation, l_fieldstrength, &
    & l_geocaltitude, l_geodaltitude, l_GPH, l_GHzAzim, &
    & l_height, l_isotoperatio, &
    & l_l1bmafbaseline, l_l1bmif_tai, &
    & l_limbsidebandfraction, l_losvel, &
    & l_lslocal, l_lsglobal, l_lsweighted, &
    & l_magneticfield, l_max, l_mean, l_min, l_molcm2, &
    & l_noisebandwidth, l_none, l_noradspermif, l_noradsbinned, &
    & l_orbitinclination, l_ascdescmode, &
    & l_pressure, l_ptan,  l_quality, &
    & l_radiance, l_refGPH, &
    & l_refltemp, &
    & l_sceci, l_scecr, l_scgeocalt, l_scveleci, l_scvelecr, &
    & l_singlechannelradiance, &
    & l_status, l_surfacetype, l_systemtemperature, &
    & l_temperature, l_time, l_tngtECI, l_tngtECR, l_tngtGeocAlt, &
    & l_tngtGeodAlt, l_tngtGeodLat, l_totalPowerWeight, l_vmr, &
    & l_xyz, l_zeta
  use Intrinsic, only: field_indices, lit_indices, &
    & phyq_angle, phyq_dimensionless, phyq_indices, phyq_invalid, &
    & phyq_length, phyq_pressure, phyq_temperature, phyq_zeta
  use L1BData, only: deallocateL1BData, dump, getl1bfile, L1BData_t, &
    & precisionsuffix, readL1BData, assemblel1bqtyname
  use L2GPData, only: L2GPData_t, readL2GPData, destroyL2GPcontents
  use L2AUXData, only: L2AUXData_t, maxsdnamesbufsize, &
    & readL2AUXData, destroyL2AUXcontents
  use L3ascii, only: l3ascii_interp_field
  use ManipulateVectorQuantities, only: doFGridsMatch, doHGridsMatch, &
    & doVGridsMatch, doQtysDescribeSameThing
  use MatrixModule_0, only: matrixElement_t, m_full, &
    & createBlock, sparsify, matrixInversion
  use MatrixModule_1, only: dump, findBlock, matrix_spd_t, updateDiagonal
  ! note: if you ever want to include defined assignment for matrices, please
  ! carefully check out the code around the call to snoop.
  use MLSCommon, only: MLSFile_t, defaultUndefinedValue
  use MLSFiles, only: hdfversion_5, dump, getMLSFileByType
  use MLSFillvalues, only: isFillValue, isFinite, &
    & Monotonize, removeFillValues
  use MLSKinds, only: r4, r8, rm, rp, rv
  use MLSL2options, only: aura_l1bfiles, L2CFErrorNode, L2CFNode, toolkit
  use MLSMessagemodule, only: MLSMessage, MLSMSG_error, MLSMSG_warning
  use MLSNumerics, only: coefficients_r8, interpolateArraySetup, &
    & InterpolateArrayTeardown, interpolateValues, hunt
  use MLSFinds, only: findFirst, findLast
  use MLSSignals_m, only: getFirstChannel, getSignalName, getModuleName, &
    & GetSignal, isModuleSpacecraft, signal_t, signals
  use MLSStringLists, only: getHashElement, numStringElements, &
    & StringElement, switchDetail
  use MLSStrings, only: indexes, lowerCase, writeIntsToChars
  use Molecules, only: l_H2O
  use Monotone, only: isMonotonic
  use Output_m, only: blanks, newline, output
  use QuantityTemplates, only: quantityTemplate_t
  use RHifromH2O, only: H2OprecfromRHi, RHifromH2O_factor, RHiprecfromH2O
  use ScanModelModule, only: getBasisGPH, get2dHydrostaticTangentPressure, &
d90 5
a94 5
  use SpectroscopyCatalog_m, only: catalog
  use String_table, only: display_string, get_string
  use Toggles, only: gen, levels, switches, toggle
  use Trace_m, only: trace_begin, trace_end
  use Tree, only: decoration, subtree, nsons, subtree
d96 8
a103 8
    & clearUnderMask, cloneVectorQuantity, copyVector, createMask, &
    & destroyVectorinfo, destroyVectorQuantityMask, &
    & destroyVectorQuantityValue, dump, &
    & getVectorqtyByTemplateIndex, getVectorQuantityByType, &
    & isVectorqtyMasked, MaskVectorqty, &
    & validateVectorQuantity, Vector_t, &
    & VectorValue_t, m_cloud, m_fill, m_ignore, m_linalg
  use VGridsDatabase, only: vgrid_t, getUnitForVerticalCoordinate
d215 1
a215 1
      use MLSRandomNumber, only: DRANG
d294 1
a294 1
      use MORETREE, only: GET_FIELD_ID, STARTERRORMESSAGE
d783 1
a783 1
      use MoreTree, only: GET_FIELD_ID
d1916 1
a1916 1
      use MANIPULATIONUTILS, only: MANIPULATE
d2050 1
a2050 1
      & key, ignoreTemplate, spreadflag, interpolate, force )
d2059 1
d2066 1
d2070 2
a2071 1
      else if ( quantity%template%name /= sourceQuantity%template%name ) then
d2120 25
d2435 4
a2438 4
      use, intrinsic :: ISO_C_BINDING, only: C_SHORT
      use SDPTOOLKIT, only: PGSd_DEM_30ARC, PGSd_DEM_90ARC, PGSd_DEM_GEOID, &
        & PGSd_DEM_DEGREE !, &
        !& PGS_DEM_GETQUALITYDATA, PGS_DEM_GETSIZE, PGS_DEM_SORTMODELS
d2657 1
a2657 1
      use Geometry, only: OMEGA => W
d2734 1
a2734 1
      use BitStuff, only: BITEQ
d2795 4
a2798 4
      use Geometry, only: EARTHRADA, EARTHRADB, GEODTOGEOCLAT
      use Hydrostatic_M, only: HYDROSTATIC
      use Phi_Refractive_Correction_m, only: PHI_REFRACTIVE_CORRECTION_UP
      use Refraction_m, only: REFRACTIVE_INDEX
d3555 1
a3555 1
      use IO_STUFF, only: GET_LUN
d3557 1
a3557 1
      use MACHINE, only: IO_ERROR
d3985 1
a3985 1
      use manipulationUtils, only: maxManipulationLen, Manipulate
d4703 1
a4703 1
      use manipulateVectorQuantities, only: DoHGridsMatch, DoVGridsMatch
d4741 1
a4741 1
      use manipulateVectorQuantities, only: DoHGridsMatch, &
d5168 1
a5168 1
      use wmoTropopause, only: extraTropics, TWMO
d6286 2
a6287 2
    use MLSL2Options, only: runTimeValues
    use MLSStrings, only: strEq
d6923 2
a6924 2
    use MLSL2Options, only: runTimeValues
    use MLSStrings, only: strEq
d7011 3
a7013 3
    use MLSL2Options, only: runTimeValues
    use MLSStrings, only: strEq
    use dump_0, only: dump
d7270 1
a7270 1
      use MLSHDF5, only: matchHDF5Attributes
d7323 1
a7323 1
      use MLSHDF5, only: getAllHDF5DSNames, matchHDF5Attributes
d7513 1
a7513 1
      use MLSHDF5, only: getHDF5Attribute, getHDF5DSDims, loadFromHDF5DS
d7687 1
a7687 1
       "$Id: FillUtils_1.f90,v 2.127 2016/09/02 00:56:05 vsnyder Exp $"
d7699 5
@


2.127
log
@Add TngtECR and TngtGeodLat fills from L1B.  Make some arrays in
ColAbundance automatic, resulting in DeallocateStuff being unused, and
therefore deleted.  Simplify FromL1B fills.  Correct geolocation fills
in FromL1B.  Correct reference to Hydrostatic in WithWMOTropopause,
which was giving RefGPH in meters instead of kilometers.
@
text
@d2632 1
a2632 1
      type (VectorValue_T), intent(in) :: TNGTECI
a2635 1

a2640 1
      integer :: x,y,z                    ! Indicies into the vectors
d2642 2
a2643 2
      real (r8), dimension(3) :: tngtVel   ! Due to rotation of earth
      real (r8), dimension(3) :: los       ! Normalised line of sight vector
d2649 2
a2650 4
      if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_losVel/), &
        & minorFrame=.true., &
        & frequencyCoordinate=(/l_none/) ) ) &
d2652 3
a2654 5
        & 'Quantity to fill is not a valid LOS Velocity', qty )
      if ( .not. ValidateVectorQuantity ( tngtECI, &
        & quantityType=(/l_tngtECI/), &
        & minorFrame=.true., &
        & frequencyCoordinate=(/l_xyz/) ) ) &
d2656 3
a2658 5
        & 'Tangent ECI quantity is not of an appropriate form', tngtECI )
      if ( .not. ValidateVectorQuantity ( scECI, &
        & quantityType=(/l_scECI/), &
        & minorFrame=.true., &
        & frequencyCoordinate=(/l_xyz/) ) ) &
d2660 1
a2660 1
        & 'Spacecraft ECI quantity is not of an approriate form', scECI )
d2678 2
a2679 7
            ! due to the slight non alignment between the earth's rotation axis and
            ! the ECI z axis, but I'm going to ignore this.

            ! Work out the indices in 3*mif,maf space
            x = 1 + 3*(mif-1)
            y = x+1
            z = x+2
d2681 2
a2682 2
            tngtVel= omega* (/ -tngtECI%values(y,maf), &
              &                 tngtECI%values(x,maf), 0.0_r8 /)
d2684 2
a2685 2
            ! Now compute the line of sight direction normal
            los = tngtECI%values(x:z,maf) - scECI%values(x:z,maf)
d2688 3
a2690 3
            ! Now compute the net velocity in this direction.  For the moment I'll
            ! assume +ve means the sc and tp are moving apart, and -ve that they're
            ! getting closer.
d2693 1
a2693 1
              &                   dot_product(scVel%values(x:z,maf), los)
d2695 2
a2696 2
            ! Note that even though x,y,z have been used up to now for a GHz/THz
            ! minor frame quantity, they're OK with this sc one too.
a4115 1
      integer                   :: I
d7659 1
a7659 1
       "$Id: FillUtils_1.f90,v 2.126 2016/07/28 01:45:07 vsnyder Exp $"
d7671 7
@


2.126
log
@Refactor dump and diff
@
text
@d49 2
a50 2
    & l_temperature, l_time, l_tngteci, l_tngtgeodalt, &
    & l_tngtgeocalt, l_totalpowerweight, l_vmr, &
d107 1
a107 1
  
d182 1
a182 1
      & computeTotalpower, deallocatestuff, &
d525 2
a526 2
      integer :: MOL                      ! Molecule index 
      integer :: SQI                      ! Quantity index 
a552 20
    ! -------------------------------------------- deallocateStuff -----
    subroutine DeallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
      real (r8), pointer, dimension(:) :: Zetab
      real (r8), pointer, dimension(:) :: Zetac
      real (r8), pointer, dimension(:) :: Zetai
      real (r8), pointer, dimension(:) :: Pb         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pc         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pi         ! p[i] in hPa
      ! call Deallocate_test ( pa, 'pa', ModuleName )
      call Deallocate_test ( pb, 'pb', ModuleName )
      call Deallocate_test ( pc, 'pc', ModuleName )
      ! call Deallocate_test ( pd, 'pd', ModuleName )
      call Deallocate_test ( pi, 'pi', ModuleName )
      ! call Deallocate_test ( Zetaa, 'Zetaa', ModuleName )
      call Deallocate_test ( Zetab, 'Zetab', ModuleName )
      call Deallocate_test ( Zetac, 'Zetac', ModuleName )
      ! call Deallocate_test ( Zetad, 'Zetad', ModuleName )
      call Deallocate_test ( Zetai, 'Zetai', ModuleName )
    end subroutine DeallocateStuff

d575 1
a575 1
      
d585 1
a585 1
      
d662 1
a662 1
      
d807 1
a807 1
      
d1327 1
a1327 1
      
d1331 1
a1331 1
      
d1337 1
a1337 1
      
d1459 1
a1459 1
      ! A special fill according to W.R.Read's idl code
d1499 9
a1507 9
      real (r8), pointer, dimension(:) :: Zetab
      real (r8), pointer, dimension(:) :: Zetac
      real (r8)                        :: Zetad
      real (r8), pointer, dimension(:) :: Zetai
      real (r8)                        :: Pa         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pb         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pc         ! p[i] in hPa
      real (r8)                        :: Pd         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pi         ! p[i] in hPa
a1560 7
      nullify ( Zetab, Zetac, Zetai, pb, pc, pi )
      call allocate_test ( Zetab, vmrQty%template%noSurfs, 'Zetab', ModuleName )
      call allocate_test ( Zetac, vmrQty%template%noSurfs, 'Zetac', ModuleName )
      call allocate_test ( Zetai, vmrQty%template%noSurfs, 'Zetai', ModuleName )
      call allocate_test ( pb, vmrQty%template%noSurfs, 'pb', ModuleName )
      call allocate_test ( pc, vmrQty%template%noSurfs, 'pc', ModuleName )
      call allocate_test ( pi, vmrQty%template%noSurfs, 'pi', ModuleName )
a1575 1
          call deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
a1636 1
          call deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
a1694 1
      call deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
d2036 1
a2036 1
    ! At some point we must try to modify most of the other Fill methods so 
d2044 1
a2044 1
    
d2333 1
a2333 1
    
d2346 1
a2346 1
    ! o o o o o o o o o o o o 
d2401 1
a2401 1
    ! ----------------------------------------  GeoidData  -----
d2723 1
a2723 1
      ! np = the number with negative precisions 
d2735 1
a2735 1
      logical, intent(in), optional   :: asPercentage ! as % of 
d3964 1
a3964 1
    
d4002 1
a4002 1
      
d4010 2
a4011 2
      
      numWays = 2 
d4095 1
a4095 1
    
d4100 1
a4100 1
    
d4102 2
a4103 2
    subroutine FromL1B ( ROOT, QUANTITY, CHUNK, FILEDATABASE, &
      & ISPRECISION, SUFFIX, GEOLOCATION, PRECISIONQUANTITY, BOMask )
d4105 9
a4113 9
      use Init_Tables_Module, only: l_geocentric, l_geodetic, l_none
      integer, intent(in)                        :: ROOT
      type (VectorValue_T), INTENT(INOUT)        :: QUANTITY
      type (MLSChunk_T), INTENT(IN)              :: CHUNK
      type (MLSFile_T), dimension(:), pointer    :: FILEDATABASE
      logical, intent(in)                        :: ISPRECISION
      integer, intent(in)                        :: SUFFIX
      integer, intent(in)                        :: GEOLOCATION
      type (VectorValue_T), INTENT(IN), optional :: PRECISIONQUANTITY
d4119 7
a4125 5
      integer                   :: channel
      character (len=132)       :: MODULENAMESTRING
      character (len=132)       :: NAMESTRING
      integer                   :: FLAG, NOMAFS, maxMIFs
      type (L1BData_T)          :: L1BDATA
d4128 2
a4129 1
      integer                   :: COLUMN
d4131 1
a4131 1
      integer                   :: myBOMask
d4134 31
a4164 1
      integer                   :: ROW
d4175 27
a4201 64
      select case ( quantity%template%quantityType )
      case ( l_ECRtoFOV )
        call GetModuleName( quantity%template%instrumentModule, nameString )
        nameString = AssembleL1BQtyName('ECRtoFOV', L1BOAFile%HDFVersion, .TRUE., &
          & trim(nameString))
      case ( l_GHzAzim )
        call GetModuleName ( quantity%template%instrumentModule, nameString )
        nameString = AssembleL1BQtyName ('azimAngle', L1BOAFile%HDFVersion, .TRUE., &
          & trim(nameString) )
      case ( l_L1BMAFBaseline )
        call GetSignalName ( quantity%template%signal, nameString, &
          & sideband=quantity%template%sideband, noChannels=.TRUE. )
        nameString = AssembleL1BQtyName(nameString, L1BOAFile%HDFVersion, .FALSE.)
      case ( l_l1bMIF_TAI )
        if ( L1BOAFile%HDFVersion == HDFVERSION_5 ) then
          call GetModuleName ( quantity%template%instrumentModule, nameString )
          nameString = AssembleL1BQtyName ('MIF_TAI', L1BOAFile%HDFVersion, .FALSE., &
            & trim(nameString) )
        else ! ??? MIF_TAI is goofy in HDF4 files -- no sc, no tp, no GHz....
          nameString = 'MIF_TAI'
        end if
      case ( l_LosVel )
        call GetModuleName ( quantity%template%instrumentModule, nameString )
        nameString = AssembleL1BQtyName ('LosVel', L1BOAFile%HDFVersion, .TRUE., &
          & trim(nameString) )
      case ( l_orbitInclination )
        nameString = AssembleL1BQtyName('OrbIncl', L1BOAFile%HDFVersion, .FALSE., &
          & 'sc')
      case ( l_ptan )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('ptan', L1BOAFile%HDFVersion, .FALSE., &
          & trim(nameString))
      case ( l_radiance )
        call GetSignalName ( quantity%template%signal, nameString, &
          & sideband=quantity%template%sideband, noChannels=.TRUE. )
        nameString = AssembleL1BQtyName(nameString, L1BOAFile%HDFVersion, .FALSE.)
      case ( l_scECI )
        nameString = AssembleL1BQtyName('ECI', L1BOAFile%HDFVersion, .FALSE., 'sc')
      case ( l_scECR )
        nameString = AssembleL1BQtyName('ECR', L1BOAFile%HDFVersion, .FALSE., 'sc')
      case ( l_scGeocAlt )
        nameString = AssembleL1BQtyName('GeocAlt', L1BOAFile%HDFVersion, .FALSE., &
          & 'sc')
      case ( l_scVelECI )
        nameString = AssembleL1BQtyName('VelECI', L1BOAFile%HDFVersion, .FALSE., &
          & 'sc')
      case ( l_scVelECR )
        nameString = AssembleL1BQtyName('VelECR', L1BOAFile%HDFVersion, .FALSE., &
          & 'sc')
      case ( l_tngtECI )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('ECI', L1BOAFile%HDFVersion, .TRUE., &
          & trim(nameString))
      case ( l_tngtGeocAlt )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('GeocAlt', L1BOAFile%HDFVersion, .TRUE., &
          & trim(nameString))
      case ( l_tngtGeodAlt )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('GeodAlt', L1BOAFile%HDFVersion, .TRUE., &
          & trim(nameString))
      case default
        call Announce_Error ( root, cantFromL1B )
      end select
d4216 1
a4216 1
      
d4341 14
a4354 1
      if ( geolocation /= l_none ) then
d4358 4
a4361 3
          call GetModuleName( quantity%template%instrumentModule,nameString )
          nameString = AssembleL1BQtyName('GeocLat', L1BOAFile%HDFVersion, .false., &
            & trim(nameString))
d4369 4
a4372 3
          call GetModuleName( quantity%template%instrumentModule,nameString )
          nameString = AssembleL1BQtyName('GeodLat', L1BOAFile%HDFVersion, .false., &
            & trim(nameString))
d4380 4
a4383 3
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('Lon', L1BOAFile%HDFVersion, .false., &
          & trim(nameString))
d4463 1
a4463 1
 
d4554 1
a4554 1
              & 'Reference MIF for magnetic field is height but geocentric ' // & 
d4719 1
a4719 1
      
d4763 1
a4763 1
        end if  
d4885 1
a4885 1
    
d4898 1
a4898 1
    ! o o o o o o o o o o o o 
d5153 1
a5153 1
      
d5159 1
a5159 1
      ! 
d5207 1
a5207 1
        p = 10.0**(-temperature%template%surfs(:,1)) 
d5350 2
a5351 1
        ! Now get the height for this.
d5354 1
a5354 1
          & refGPH%template%surfs(1,1), refGPH%values(1,i), hFine )
d5819 1
a5819 1
      
d6102 1
a6102 1
          if ( WARNWHENPTANNONMONOTONIC ) then                               
d6104 1
a6104 1
              & 'Ptan non-monotonic' )                                       
d6990 1
a6990 1
    
d7077 1
a7077 1
        do dqi = 1, size ( dest%quantities ) 
d7167 1
a7167 1
      integer :: J 
d7203 1
a7203 1
      
d7217 1
a7217 1
      ! YOUR CODE HERE  
d7220 2
a7221 2
      !   myTerms(1) == b == gain compression at the cal target, e.g. 0.01 
      !   myTerms(2) == Tcal == cal target Planckified radiance, e.g. 250 
d7227 1
a7227 1
      !Nchannels = quantity% 
d7230 1
a7230 1
        
d7238 1
a7238 1
              bprodCal = b * myTerms(2) * myTerms(3) 
d7243 1
a7243 1
                       &  + bprodCal  + bTsys * totalPowerQuantity%values(j,i)  
d7304 1
a7304 1
    
d7324 1
a7324 1
      type (VectorValue_T), pointer :: quantity 
d7643 1
a7643 1
    
d7673 1
a7673 1
       "$Id: FillUtils_1.f90,v 2.125 2016/06/14 22:54:39 vsnyder Exp $"
d7685 3
@


2.125
log
@In UsingMagneticModel, improve a message.  Add some comments about unexpected
combinations, such as geodetic height and geocentric latitude.
@
text
@d267 1
a267 1
      elseif ( spread .and. &
d284 1
a284 1
      endif
d312 1
a312 1
      endif
d471 1
a471 1
      endif
d485 1
a485 1
              enddo
d489 1
a489 1
            endif
d504 1
a504 1
              enddo
d508 1
a508 1
            endif
d594 1
a594 1
      enddo
d678 1
a678 1
      elseif ( index(myOptions, 'n') > 0 ) then
d692 1
a692 1
        elseif ( .not. Force ) then
d777 1
a777 1
            endif
d782 1
a782 1
            endif
d910 1
a910 1
      endif
d978 1
a978 1
      elseif ( .not. ValidateVectorQuantity ( qty, &
d1117 1
a1117 1
      elseif ( .not. ValidateVectorQuantity ( qty, &
d1391 1
a1391 1
      elseif ( .not. ValidateVectorQuantity ( qty, &
d1396 1
a1396 1
      elseif ( .not. ValidateVectorQuantity ( normqty, &
d1401 1
a1401 1
      elseif ( .not. ValidateVectorQuantity ( minnormqty, &
d1406 1
a1406 1
      elseif ( .not. ValidateVectorQuantity ( flagqty, &
d1444 2
a1445 2
          enddo
        endif
d1460 1
a1460 1
        elseif ( UNIFORMCHISQRATIO .or. &
d1469 1
a1469 1
        endif
d1535 1
a1535 1
      elseif ( (qty%template%quantityType /= l_columnAbundance) .or. &
d1968 1
a1968 1
      endif
d2098 1
a2098 1
      elseif ( quantity%template%name /= sourceQuantity%template%name ) then
d2106 1
a2106 1
      elseif ( spreadFlag ) then
d2118 2
a2119 2
        enddo
      elseif ( force .and. &
d2132 2
a2133 2
        enddo
      elseif ( force .and. &
d2146 1
a2146 1
        enddo
d2411 3
a2413 3
            enddo
          enddo
        enddo
d2424 5
a2428 5
              enddo
            enddo
          enddo
        enddo
      endif
d2456 3
a2458 3
      integer :: NUMVERTPIX
      integer :: NUMHORIZPIX
      integer :: PIXBYTE
d2461 1
a2461 1
      integer, dimension(2) :: COMPLETEDATA
d2474 1
a2474 1
      endif
d2520 1
a2520 1
        endif
d2524 1
a2524 1
          enddo
d2528 3
a2530 3
          enddo
        endif
      enddo
d2854 1
a2854 1
      endif
d3522 1
a3522 1
              endif
d3680 1
a3680 1
        elseif ( qty%template%noChans /= 1) then
d3684 1
a3684 1
        elseif ( .not. all ( (/ qty%template%coherent, source%template%coherent /) ) ) then
d3695 1
a3695 1
        elseif ( qty%template%verticalCoordinate == l_pressure ) then
d3730 2
a3731 2
            endif
          endif
d4057 1
a4057 1
        elseif ( MapFunction ) then
d4059 1
a4059 1
        elseif ( .not. ignoreTemplate ) then
d4065 1
a4065 1
          elseif ( mstr == 'a+b' .or. mstr == 'a-b' ) then
d4106 1
a4106 1
          endif
d4109 1
a4109 1
        endif
d4135 1
a4135 3
      use Geometry, only: GeocToGeodLat, GeodToGeocAlt
      use Init_Tables_Module, only: l_geocAltitude, l_geocentric, l_geodetic, &
        & l_none
a4152 1
      integer                   :: I, J, K
a4155 1
      real(kind(quantity%template%geodLat)) :: Lat
d4254 1
a4254 1
      elseif ( isPrecision ) then
d4280 1
a4280 1
        elseif (.not. Aura_L1BFILES ) then
d4288 1
a4288 1
        endif
d4335 1
a4335 1
        endif
d4338 1
a4338 1
        endif
d4343 1
a4343 1
        enddo
d4370 1
a4370 1
            endif
d4557 1
a4557 1
            elseif ( verbose ) then
d4951 3
a4953 3
            enddo
          enddo
        enddo
d4964 5
a4968 5
              enddo
            enddo
          enddo
        enddo
      endif
d5017 1
a5017 1
      endif
d5026 1
a5026 1
      endif
d5037 2
a5038 2
        enddo
      enddo
d5215 1
a5215 1
      endif
d5255 1
a5255 1
          endif
d5257 1
a5257 1
        endif
d5271 1
a5271 1
        endif
d5278 1
a5278 1
          endif
d5280 1
a5280 1
        endif
d5524 1
a5524 1
      endif
d5548 2
a5549 2
          endif
        endif
d5809 1
a5809 1
      endif
d5819 2
a5820 2
            endif
          endif
d5847 1
a5847 1
      endif
d5928 1
a5928 1
        endif
d5944 1
a5944 1
          endif
d5955 1
a5955 1
          endif
d5958 1
a5958 1
        endif
d6100 1
a6100 1
      elseif ( quantity%template%verticalCoordinate == l_pressure ) then
d6123 2
a6124 2
          endif
        endif
d6128 1
a6128 1
        endif
d6152 1
a6152 1
        endif
d6167 1
a6167 1
        endif
d6318 1
a6318 1
      endif
d6330 1
a6330 1
        elseif ( all( (/ associated(aq), associated(bq), associated(dq) /) ) ) then
d6464 1
a6464 1
        endif
d6594 1
a6594 1
      endif
d6975 1
a6975 1
        endif
d6985 1
a6985 1
        elseif ( interpolate ) then
d7069 1
a7069 1
      endif
d7080 1
a7080 1
      endif
d7087 1
a7087 1
        elseif ( any( method == &
d7092 1
a7092 1
        endif
d7104 1
a7104 1
            endif
d7106 1
a7106 1
          endif
d7164 1
a7164 1
        endif
d7315 1
a7315 1
      endif
d7325 1
d7570 1
a7570 1
        endif
d7573 1
a7573 1
        elseif ( interpolate .and. allocated(quantity%template%surfs) ) then
d7588 1
a7588 1
          elseif ( noSurfs == dimInts(1)*dimInts(2) ) then
d7598 1
a7598 1
          endif
d7607 1
a7607 1
        elseif ( size(quantity%values(:,1)) == size(values(:,:,1) ) ) then
d7611 2
a7612 2
          enddo
        elseif ( size(quantity%values) /= size(values ) ) then
d7617 1
a7617 1
        endif
d7646 2
a7647 2
          enddo
        elseif( noInst1 == noInst2 ) then
d7651 1
a7651 1
          enddo
d7656 2
a7657 2
          enddo
        endif
d7684 1
a7684 1
    endif
d7690 1
a7690 1
       "$Id: FillUtils_1.f90,v 2.124 2016/06/13 21:03:20 vsnyder Exp $"
d7702 4
@


2.124
log
@Improve a warning message
@
text
@d4517 2
d4522 3
a4524 2
                else ! geocentric latitude
                  ! GeocToECRu gets an ECR unit vector
d4535 3
a4537 3
                & 'ReferenceMIF = %R is greater than half than Earth radius ' // &
                & 'and is therefore assumed to be geocentric height.', &
                & datum = referenceMIF )
d7693 1
a7693 1
       "$Id: FillUtils_1.f90,v 2.123 2016/06/03 20:54:38 vsnyder Exp $"
d7705 3
@


2.123
log
@Correct the log for the previous commit
@
text
@d4566 2
a4567 1
                & 'vertical coordinate of the tangent point geocentric height ', &
d7690 1
a7690 1
       "$Id: FillUtils_1.f90,v 2.122 2016/06/03 20:52:04 vsnyder Exp $"
d7702 3
@


2.122
log
@FillUtils_1.f90
@
text
@d7689 1
a7689 1
       "$Id: FillUtils_1.f90,v 2.121 2016/05/18 01:37:30 vsnyder Exp $"
d7701 4
@


2.121
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@d4666 1
a4666 1
                                           & differentTypeOK=.true. ) ) then
d7689 1
a7689 1
       "$Id: FillUtils_1.f90,v 2.120 2016/03/18 17:58:05 pwagner Exp $"
d7701 4
@


2.120
log
@Make certain the L2CF line cited is actal error, not end of section
@
text
@d4977 1
a4977 1
    use HGridsDatabase, only: HGrid_T
d4985 1
a4985 1
      type (HGrid_T), dimension(:), pointer      :: HGrids
d5028 1
a5028 1
        maf = Hgrids(quantity%template%hGridIndex)%maf(i)
d7689 1
a7689 1
       "$Id: FillUtils_1.f90,v 2.119 2016/01/23 02:56:37 vsnyder Exp $"
d7701 3
@


2.119
log
@Replace To_Cart with GeodToECRm, To_XYZ with GeodToECRu
@
text
@d68 1
a68 1
  use MLSCommon, only: mlsfile_t, defaultundefinedvalue
d73 1
a73 1
  use MLSL2options, only: aura_l1bfiles, l2cfnode, toolkit
d80 1
a80 1
  use MLSStringLists, only: gethashelement, numstringelements, &
d291 1
a291 1
    subroutine ANNOUNCE_ERROR ( WHERE, CODE, &
d296 1
a296 1
      integer, intent(in) :: WHERE   ! Tree node where error was noticed
d313 2
a314 1
      call StartErrorMessage ( where )
d409 1
a409 1
        call display_string ( field_indices(Get_Field_Id(where)), &
d7689 1
a7689 1
       "$Id: FillUtils_1.f90,v 2.118 2015/12/01 21:19:57 pwagner Exp $"
d7701 3
@


2.118
log
@May Fill with nearest profile number
@
text
@d4468 1
a4468 1
      use Geometry, only: EarthRadA, To_Cart, To_XYZ, XYZ_to_Geod
d4514 1
a4514 1
                ! Convert [lat, lon, ht] to ECR
d4516 3
a4518 4
                  call to_cart ( [ geocAltitudeQuantity%template%geodLat(i,1), &
                                 & geocAltitudeQuantity%template%lon(i,1), &
                                 & geocAltitudeQuantity%template%surfs(i,1) ], &
                                 & xyz, km=.true. )
d4520 4
a4523 3
                  xyz = to_xyz ( geocAltitudeQuantity%template%geodLat(i,1), &
                               & geocAltitudeQuantity%template%lon(i,1) )
                  xyz = xyz * geocAltitudeQuantity%template%surfs(i,1)
d7688 1
a7688 1
       "$Id: FillUtils_1.f90,v 2.117 2015/11/11 23:25:32 vsnyder Exp $"
d7700 3
@


2.117
log
@Compute the longest monotone subsequence of altitudes after converting
from geocentric to geodetic, instead of before, for purposes of determining
the reference MIF number.
@
text
@d181 22
a202 22
  public :: ADDGAUSSIANNOISE, APPLYBASELINE, AUTOFILLVECTOR, &
      & COMPUTETOTALPOWER, DEALLOCATESTUFF, &
      & EXTRACTSINGLECHANNEL, FILLCOVARIANCE, FROMANOTHER, FROMGRID, &
      & FROML2GP, FROMPROFILE, GATHER, GEOIDDATA, LOSVELOCITY, &
      & CHISQCHAN, CHISQMMAF, CHISQMMIF, CHISQRATIO, &
      & COLABUNDANCE, DERIVATIVEOFSOURCE, FOLDEDRADIANCE, PHITANWITHREFRACTION, &
      & IWCFROMEXTINCTION, RHiFROMORTOH2O, NORADSPERMIF, &
      & RHiPRECISIONFROMORTOH2O, WITHESTNOISE, &
      & Hydrostatically_GPH, Hydrostatically_PTan, FROMSPLITSIDEBAND, &
      & GPHPRECISION, FROMISOTOPE, FROMASCIIFILE, ROTATEMAGNETICFIELD, &
      & EXPLICIT, FROML1B, &
      & FROML2AUX, USINGMAGNETICMODEL, &
      & FROMINTERPOLATEDQTY, FROMLOSGRID, &
      & BYMANIPULATION, MANIPULATEVECTORS, WITHREFLECTORTEMPERATURE, &
      & WITHASCORDESC, WITHREICHLERWMOTP, &
      & WITHWMOTROPOPAUSE, WITHBINRESULTS, WITHBOXCARFUNCTION, &
      & STATUSQUANTITY, QUALITYFROMCHISQ, CONVERGENCEFROMCHISQ, &
      & USINGLEASTSQUARES, OFFSETRADIANCEQUANTITY, RESETUNUSEDRADIANCES, &
      & SCALEOVERLAPS, SCATTER, SPREADCHANNELFILL, &
      & TRANSFERVECTORS, TRANSFERVECTORSBYMETHOD, &
      & UNCOMPRESSRADIANCE, &
      & ANNOUNCE_ERROR, QTYFROMFILE, VECTORFROMFILE
d572 25
d7688 1
a7688 1
       "$Id: FillUtils_1.f90,v 2.116 2015/10/29 00:55:27 vsnyder Exp $"
d7700 5
@


2.116
log
@If the units of the referenceMIF are length, and its value is less than
half EarthRadA, assume it's a geodetic height.  If so, and the tangent
point vertical coordinate is geocentric height, create an array of
geodetic heights from the first MAF in which to choose a reference MIF
number.
@
text
@d4483 1
a4483 11
            ! Use only the monotone part of the tangent-point altitudes
            call longest_monotone_subsequence ( geocAltitudeQuantity%template%surfs(:,1), inc )
            call longest_monotone_subsequence ( geocAltitudeQuantity%template%surfs(:,1), dec, -1 )
            if ( size(inc) >= size(dec) ) then
              call move_alloc ( inc, seq )
              deallocate ( dec )
            else
              call move_alloc ( dec, seq )
              deallocate ( inc )
            end if
            call allocate_test ( surfs, size(seq), 'Surfs', moduleName )
d4488 1
a4488 5
              call MLSMessage ( MLSMSG_Info, moduleName, &
                & 'ReferenceMIF = %R is less half than Earth radius ' // &
                & 'and is therefore assumed to be geodetic height.', &
                & datum = referenceMIF )
              do i = 1, size(surfs)
d4491 3
a4493 3
                  call to_cart ( [ geocAltitudeQuantity%template%geodLat(seq(i),1), &
                                 & geocAltitudeQuantity%template%lon(seq(i),1), &
                                 & geocAltitudeQuantity%template%surfs(seq(i),1) ], &
d4496 3
a4498 3
                  xyz = to_xyz ( geocAltitudeQuantity%template%geodLat(seq(i),1), &
                               & geocAltitudeQuantity%template%lon(seq(i),1) )
                  xyz = xyz * geocAltitudeQuantity%template%surfs(seq(i),1)
d4505 15
a4519 1
              surfs(:) = geocAltitudeQuantity%template%surfs(seq,1)
d4522 3
a4524 3
            call hunt ( surfs, referenceMIF, referenceMIFnumber )
            maxv = maxval(surfs)
            minv = minval(surfs)
d4528 1
a4528 1
              call output ( surfs(referenceMIFnumber), before=' = ' )
d7663 1
a7663 1
       "$Id: FillUtils_1.f90,v 2.115 2015/10/03 00:28:06 pwagner Exp $"
d7675 7
@


2.115
log
@May print Reference MIF number if verbose
@
text
@d4442 2
d4445 1
d4447 1
d4462 2
d4470 2
d4493 42
a4534 2
            call hunt ( geocAltitudeQuantity%template%surfs(seq,1), referenceMIF, &
              & referenceMIFnumber )
a4535 2
            maxv = maxval(geocAltitudeQuantity%template%surfs(seq,1))
            minv = minval(geocAltitudeQuantity%template%surfs(seq,1))
a4541 10
            if ( switchDetail ( switches, 'plane' ) > 1 ) then
              call output ( referenceMIFnumber, &
                & before='Reference MIF number ' )
             
              call output ( referenceMIF, before=' chosen using height ' )
              call output ( minv, before=' from range ' )
              call output ( maxv, before=' ... ', advance='yes' )
            elseif ( verbose ) then
              call outputNamedValue ( 'Reference MIF number', referenceMIFnumber )
            end if
d4543 1
d7663 1
a7663 1
       "$Id: FillUtils_1.f90,v 2.114 2015/09/25 02:15:26 vsnyder Exp $"
d7675 3
@


2.114
log
@Remove conversion of surfs to geocentric if the vertical coordinate is
geocentric altitude, because ConstructQuantityTemplates now reads the
appropriate altitude from the L1BOA file.
@
text
@d4464 1
a4464 1

d4471 1
d4503 2
d4515 1
d7626 1
a7626 1
       "$Id: FillUtils_1.f90,v 2.113 2015/09/22 23:42:05 vsnyder Exp $"
d7638 5
@


2.113
log
@Add GHzAzim and ScECR quantities.  Add ReferenceMIF.  Convert Surfs to
geocentric altitude if that's the specified vertical coordinate.
@
text
@d73 2
a74 2
  use MLSL2options, only: aura_l1bfiles, l2cfnode, MLSMessage, toolkit
  use MLSMessagemodule, only: MLSMSG_error, MLSMSG_warning
a4386 14
      if ( quantity%template%verticalCoordinate == l_geocAltitude ) then
        ! L1B quantity's surfs field is geodetic altitude.  Convert it.
        do i = 1, quantity%template%noSurfs
          k = merge(1,i,quantity%template%stacked)
          do j = 1, size(quantity%template%surfs,2)
            lat = quantity%template%geodLat(k,j)
            if ( quantity%template%latitudeCoordinate == l_geocentric ) &
              & lat = geocToGeodLat ( lat ) ! GeodToGeocAlt wants geodetic latitude
            quantity%template%surfs(i,j) = geodToGeocAlt ( &
              & [ lat, quantity%template%lon(k,j), quantity%template%surfs(i,j) ] )
          end do
        end do
      end if

d4388 2
a4389 2
      call DeallocateL1BData(L1BData)
    9 call trace_end ( 'FillUtils_1.FromL1B', &
d4445 2
a4446 1
      use QuantityTemplates, only: QuantitiesAreCompatible
d4456 1
a4456 1
      integer, allocatable :: Dec(:)       ! Decreasing sequence indices
d4458 3
a4460 2
      integer, allocatable :: Inc(:)       ! Increasing sequence indices
      integer :: Me = -1                   ! String index for trace
d4462 2
a4463 2
      integer, allocatable :: Seq(:)       ! Increasing or decreasing
                                           ! sequence indices, => Inc or Dec
d4487 16
d7622 1
a7622 1
       "$Id: FillUtils_1.f90,v 2.112 2015/08/25 17:33:42 vsnyder Exp $"
d7634 4
@


2.112
log
@PhiWindow is a tuple, with the first element specifying the angles or
number of profiles/MAFs before the tangent point, and the second
specifying the angles or number after.
@
text
@d35 1
a35 1
    & l_geocaltitude, l_geodaltitude, l_GPH, &
d46 1
a46 1
    & l_sceci, l_scgeocalt, l_scveleci, l_scvelecr, &
d53 2
a54 2
    & phyq_dimensionless, phyq_indices, phyq_invalid, phyq_temperature, &
    & phyq_length, phyq_pressure, phyq_zeta, phyq_angle
d4109 3
a4111 1
      use Init_Tables_Module, only: l_geocentric, l_geodetic, l_none
d4123 17
a4139 13
      integer                               :: BO_error
      type (L1BData_T)                      :: BO_stat
      integer                               :: channel
      character (len=132)                   :: MODULENAMESTRING
      character (len=132)                   :: NAMESTRING
      integer                               :: FLAG, NOMAFS, maxMIFs
      type (L1BData_T)                      :: L1BDATA
      type (MLSFile_T), pointer             :: L1BFile
      type (MLSFile_T), pointer             :: L1BOAFile
      integer                               :: COLUMN
      integer :: Me = -1                    ! String index for trace
      integer                               :: myBOMask
      integer                               :: ROW
d4155 4
d4188 2
d4354 1
d4364 1
a4364 1
          & (/ quantity%template%instanceLen, quantity%template%noInstances /) )
d4374 1
a4374 1
          & (/ quantity%template%instanceLen, quantity%template%noInstances /) )
d4384 15
a4398 1
        & (/ quantity%template%instanceLen, quantity%template%noInstances /) )
d4453 4
a4456 1
                                  & GPHQuantity )
d4458 1
d4465 5
a4469 1

d4471 1
d4473 3
d4483 37
d4534 8
d4612 5
a4616 1
          if ( qty%template%stacked ) then
d4618 2
a4619 1
              & "Cross-track magnetic field quantity cannot be stacked" )
d4626 2
a4627 1
        & scVelQuantity, geocAltitudeQuantity, GPHQuantity )
d7618 1
a7618 1
       "$Id: FillUtils_1.f90,v 2.111 2015/08/03 21:43:25 pwagner Exp $"
d7630 5
@


2.111
log
@Made quantityType optional in call to ReadL2AUXData
@
text
@d137 2
a138 1
  integer, parameter, public :: NumChansisZero = missingField + 1
d381 2
d4595 3
a4597 3
      integer, intent(in) :: MAXITERATIONS
      real(r8), intent(in) :: PHIWINDOW
      integer, intent(in) :: PHIWINDOWUNITS
d7528 1
a7528 1
       "$Id: FillUtils_1.f90,v 2.110 2015/07/29 00:29:54 vsnyder Exp $"
d7540 3
@


2.110
log
@Convert Phi from pointer to allocatable
@
text
@d7387 1
a7387 1
        call ReadL2AUXData ( MLSFile, name, quantity%template%quantityType, L2AUX )
d7525 1
a7525 1
       "$Id: FillUtils_1.f90,v 2.109 2015/06/04 03:19:36 vsnyder Exp $"
d7537 3
@


2.109
log
@Make the Surfs component of quantity templates allocatable
@
text
@d6599 1
a6599 1
        if ( associated(qty%template%phi) .and. qty%template%stacked ) &
d7525 1
a7525 1
       "$Id: FillUtils_1.f90,v 2.108 2015/06/03 00:35:36 pwagner Exp $"
d7537 3
@


2.108
log
@Should only use sc/VelECI if it is found in l1boa
@
text
@d3596 5
a3600 2
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) :: SOURCE
d4825 1
a4825 1
      real(r8), dimension(:,:), pointer :: HEIGHTS ! might be ptan.
d4856 2
a4858 3
        nullify ( Heights )
        call Allocate_test ( Heights, ptanQuantity%template%nosurfs, &
          & ptanQuantity%template%noinstances, 'Heights', ModuleName )
d4861 1
a4861 1
        Heights => Quantity%template%surfs
d5413 3
d5418 1
a5418 1
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY
d5871 4
a5874 1
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
d6187 3
d6192 1
a6192 1
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY
d7408 1
a7408 1
        elseif ( interpolate .and. associated(quantity%template%surfs) ) then
d7525 1
a7525 1
       "$Id: FillUtils_1.f90,v 2.107 2015/05/28 18:26:48 vsnyder Exp $"
d7537 3
@


2.107
log
@Remove unreferenced USE names and external declarations
@
text
@d4846 5
d7514 1
a7514 1
       "$Id: FillUtils_1.f90,v 2.106 2015/05/05 17:44:01 pwagner Exp $"
d7526 3
@


2.106
log
@Use MAXMANIPULATIONLEN from manipulationUtils; lots of unsetting allcaps
@
text
@d35 1
a35 1
    & l_geocaltitude, l_geocentric, l_geodaltitude, l_geodetic, l_GPH, &
d2433 1
a2433 1
      integer, external :: PGS_DEM_GETQUALITYDATA, PGS_DEM_GETSIZE, PGS_DEM_SORTMODELS
d7509 1
a7509 1
       "$Id: FillUtils_1.f90,v 2.105 2015/04/29 01:17:52 vsnyder Exp $"
d7521 3
@


2.105
log
@Add lots of checking in UsingMagneticModel
@
text
@d16 88
a103 88
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use CHUNKS_M, only: MLSCHUNK_T
  use CONSTANTS, only: DEG2RAD, LN10, RAD2DEG
  use DUMP_0, only: DUMP
  use EXPR_M, only: EXPR, EXPR_CHECK, GETINDEXFLAGSFROMLIST
  use GRIDDEDDATA, only: GRIDDEDDATA_T, DUMP, WRAPGRIDDEDDATA
  use HDF5, only: HSIZE_T, H5DOPEN_F, H5DCLOSE_F
  use HIGHOUTPUT, only: BEVERBOSE, OUTPUTNAMEDVALUE
  use INIT_TABLES_MODULE, only: F_MEASUREMENTS, F_TOTALPOWERVECTOR, &
    & F_WEIGHTSVECTOR, &
    & L_ADDNOISE, L_BASELINE, L_BINMAX, L_BINMEAN, L_BINMIN, L_BINTOTAL, &
    & L_BOUNDARYPRESSURE, L_BOXCAR, L_CHISQBINNED, L_CHISQCHAN, &
    & L_CHISQMMAF, L_CHISQMMIF, &
    & L_CLOUDINDUCEDRADIANCE, L_CLOUDMINMAX, &
    & L_COLUMNABUNDANCE, &
    & L_DNWT_FLAG, L_DNWT_CHISQMINNORM, L_DNWT_CHISQNORM, L_DNWT_CHISQRATIO, &
    & L_DOBSONUNITS, L_DU, &
    & L_ECRTOFOV, &
    & L_FIELDAZIMUTH, L_FIELDELEVATION, L_FIELDSTRENGTH, &
    & L_GeocAltitude, L_Geocentric, L_GeodAltitude, L_Geodetic, L_GPH, &
    & L_HEIGHT, L_ISOTOPERATIO, &
    & L_L1BMAFBASELINE, L_L1BMIF_TAI, &
    & L_LIMBSIDEBANDFRACTION, L_LOSVEL, &
    & L_LSLOCAL, L_LSGLOBAL, L_LSWEIGHTED, &
    & L_MAGNETICFIELD, L_MAX, L_MEAN, L_MIN, L_MOLCM2, &
    & L_NOISEBANDWIDTH, L_NONE, L_NORADSPERMIF, L_NORADSBINNED, &
    & L_ORBITINCLINATION, L_ASCDESCMODE, &
    & L_PRESSURE, L_PTAN,  L_QUALITY, &
    & L_RADIANCE, L_REFGPH, &
    & L_REFLTEMP, &
    & L_SCECI, L_SCGEOCALT, L_SCVELECI, L_SCVELECR, &
    & L_SINGLECHANNELRADIANCE, &
    & L_STATUS, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
    & L_TEMPERATURE, L_TIME, L_TNGTECI, L_TNGTGEODALT, &
    & L_TNGTGEOCALT, L_TOTALPOWERWEIGHT, L_VMR, &
    & L_XYZ, L_ZETA
  use INTRINSIC, only: FIELD_INDICES, LIT_INDICES, &
    & PHYQ_DIMENSIONLESS, PHYQ_INDICES, PHYQ_INVALID, PHYQ_TEMPERATURE, &
    & PHYQ_LENGTH, PHYQ_PRESSURE, PHYQ_ZETA, PHYQ_ANGLE
  use L1BDATA, only: DEALLOCATEL1BDATA, DUMP, GETL1BFILE, L1BDATA_T, &
    & PRECISIONSUFFIX, READL1BDATA, ASSEMBLEL1BQTYNAME
  use L2GPDATA, only: L2GPDATA_T, READl2GPDATA, DESTROYl2GPCONTENTS
  use L2AUXDATA, only: L2AUXDATA_T, MAXSDNAMESBUFSIZE, &
    & READL2AUXDATA, DESTROYL2AUXCONTENTS
  use L3ASCII, only: L3ASCII_INTERP_FIELD
  use MANIPULATEVECTORQUANTITIES, only: DOFGRIDSMATCH, DOHGRIDSMATCH, &
    & DOVGRIDSMATCH, DOQTYSDESCRIBESAMETHING
  use MATRIXMODULE_0, only: MATRIXELEMENT_T, M_FULL, &
    & CREATEBLOCK, SPARSIFY, MATRIXINVERSION
  use MATRIXMODULE_1, only: DUMP, FINDBLOCK, MATRIX_SPD_T, UPDATEDIAGONAL
  ! NOTE: IF YOU EVER WANT TO INCLUDE DEFINED ASSIGNMENT FOR MATRICES, PLEASE
  ! CAREFULLY CHECK OUT THE CODE AROUND THE CALL TO SNOOP.
  use MLSCOMMON, only: MLSFILE_T, DEFAULTUNDEFINEDVALUE
  use MLSFILES, only: HDFVERSION_5, DUMP, GETMLSFILEBYTYPE
  use MLSFILLVALUES, only: ISFILLVALUE, ISFINITE, &
    & MONOTONIZE, REMOVEFILLVALUES
  use MLSKINDS, only: R4, R8, RM, RP, RV
  use MLSL2OPTIONS, only: AURA_L1BFILES, L2CFNODE, MLSMESSAGE, TOOLKIT
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING
  use MLSNUMERICS, only: COEFFICIENTS_R8, INTERPOLATEARRAYSETUP, &
    & INTERPOLATEARRAYTEARDOWN, INTERPOLATEVALUES, HUNT
  use MLSFINDS, only: FINDFIRST, FINDLAST
  use MLSSIGNALS_M, only: GETFIRSTCHANNEL, GETSIGNALNAME, GETMODULENAME, &
    & GETSIGNAL, ISMODULESPACECRAFT, SIGNAL_T, SIGNALS
  use MLSSTRINGLISTS, only: GETHASHELEMENT, NUMSTRINGELEMENTS, &
    & STRINGELEMENT, SWITCHDETAIL
  use MLSSTRINGS, only: INDEXES, LOWERCASE, WRITEINTSTOCHARS
  use MOLECULES, only: L_H2O
  use Monotone, only: IsMonotonic
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT
  use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T
  use RHIFROMH2O, only: H2OPRECFROMRHI, RHIFROMH2O_FACTOR, RHIPRECFROMH2O
  use SCANMODELMODULE, only: GETBASISGPH, GET2DHYDROSTATICTANGENTPRESSURE, &
    & GETGPHPRECISION
  use SPECTROSCOPYCATALOG_M, only: CATALOG
  use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
  use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TREE, only: DECORATION, SUBTREE, NSONS, SUBTREE
  use VECTORSMODULE, only: &
    & CLEARUNDERMASK, CLONEVECTORQUANTITY, COPYVECTOR, CREATEMASK, &
    & DESTROYVECTORINFO, DESTROYVECTORQUANTITYMASK, &
    & DESTROYVECTORQUANTITYVALUE, DUMP, &
    & GETVECTORQTYBYTEMPLATEINDEX, GETVECTORQUANTITYBYTYPE, &
    & ISVECTORQTYMASKED, MASKVECTORQTY, &
    & VALIDATEVECTORQUANTITY, VECTOR_T, &
    & VECTORVALUE_T, M_CLOUD, M_FILL, M_IGNORE, M_LINALG
  use VGRIDSDATABASE, only: VGRID_T, GETUNITFORVERTICALCOORDINATE
d186 2
a187 2
      & IWCFROMEXTINCTION, RHIFROMORTOH2O, NORADSPERMIF, &
      & RHIPRECISIONFROMORTOH2O, WITHESTNOISE, &
d436 1
a436 1
      & quadrature, dontmask, ignoreTemplate )
d441 1
a441 1
      logical, intent(in) :: DONTMASK ! If set ignore baselinequantity mask
d473 1
a473 1
            if ( .not. dontMask .and. associated(baselineQuantity%mask) ) then
d492 1
a492 1
            if ( .not. dontMask .and. associated(baselineQuantity%mask) ) then
d579 1
a579 1
      ! spreads scalar values over all (unmasked) quantity%values
d583 1
a583 1
      ! sends ExtraQuantity%values into all (unmasked) quantity%values
a625 1
      ! character(len=128) :: whichInstances
a634 1
      ! whichInstances = ' '
d736 2
a737 2
            if ( associated ( quantity%mask ) ) then
              if ( iand ( ichar(quantity%mask(j,i)), m_Fill ) /= 0 ) cycle
d903 1
a903 1
      logical, intent(in)           ::       dontMask    ! Use even masked values
d1040 1
a1040 1
      logical, intent(in)           ::       dontMask    ! Use even masked values
d1184 1
a1184 1
      logical, intent(in)           ::       dontMask    ! Use even masked values
d1336 1
a1336 1
      logical, intent(in)           ::       dontMask    ! Use even masked values
d1753 2
a1754 2
      type (Vector_T) :: DMASKED ! Masked diagonal
      type (Vector_T) :: LMASKED ! Masked length scale
d1775 1
a1775 1
      ! Apply mask to diagonal
d1777 3
a1779 3
      call CopyVector ( Dmasked, vectors(diagonal), clone=.true., &
        & vectorNameText='_Dmasked' )
      call ClearUnderMask ( Dmasked )
d1790 3
a1792 3
          call CopyVector ( Lmasked, vectors(lengthScale), clone=.true., &
            & vectorNameText='_Lmasked' )
          call ClearUnderMask ( Lmasked )
d2041 1
a2041 1
    ! Note that this does *NOT* copy the mask (at least for the moment)
d2081 3
a2083 3
          ! If we have a mask and we're going to obey it then do so
          if ( associated(quantity%mask) ) then
            where ( iand ( ichar(quantity%mask(:,inst)), m_Fill ) == 0 )
d2095 3
a2097 3
          ! If we have a mask and we're going to obey it then do so
          if ( associated(quantity%mask) ) then
            where ( iand ( ichar(quantity%mask(:,inst)), m_Fill ) == 0 )
d2109 3
a2111 3
          ! If we have a mask and we're going to obey it then do so
          if ( associated(quantity%mask) ) then
            where ( iand ( ichar(quantity%mask(surf,:)), m_Fill ) == 0 )
d2120 3
a2122 3
        ! If we have a mask and we're going to obey it then do so
        if ( associated(quantity%mask) ) then
          where ( iand ( ichar(quantity%mask(:,:)), m_Fill ) == 0 )
d2164 1
a2164 1
      if ( .not. associated(quantity%mask)) &
d2208 1
a2208 1
              if ( iand ( ichar ( Quantity%mask(i+(mif-1) * &
d2234 1
a2234 1
        ! is only applied to maskbit = m_cloud.
d2243 1
a2243 1
                if ( iand ( ichar ( Quantity%mask( i + &
d2302 1
a2302 1
                if ( iand ( ichar ( Quantity%mask( i + &
d2525 1
a2525 1
      case ( l_gph )
d2533 1
a2533 1
            & "case l_gph failed first test" )
d2538 1
a2538 1
            &  "case l_gph failed second test" )
d2721 1
a2721 1
      ! Count number of valid (i.e., not masked) radiances
d2725 1
a2725 1
      !      masked with bits m_linalg + m_ignore
d2727 1
a2727 1
      !      masked only with bit m_linalg
d2729 1
a2729 1
      !      not masked with bit m_linalg (either alone or with others)
d2755 1
a2755 1
      if ( associated ( measQty%mask ) ) then
d2761 1
a2761 1
              & iand ( ichar ( measQty%mask ( i0:i1, maf ) ), M_LinAlg ) == 0 )
d2763 1
a2763 1
              & count( biteq( ichar(measQty%mask( i0:i1, maf )), M_linAlg) )
d2779 1
a2779 1
      & h2o, orbIncline, ptan, refGPH, temperature, ignoreTemplate )
d2817 2
a2818 2
        if ( .not. ValidateVectorQuantity ( h2o, &
          & quantityType=(/l_vmr/), molecule=(/l_h2o/), coherent=.true., stacked=.true., &
d2820 1
a2820 1
          & call Announce_error ( key, no_error_code, 'Problem with h2o quantity for phiTan fill' )
d2828 1
a2828 1
      if ( .not. DoHGridsMatch ( temperature, h2o ) ) i = i + 2
d2830 1
a2830 1
      if ( .not. DoVGridsMatch ( temperature, h2o ) ) i = i + 8
d2844 1
a2844 1
      ! Interpolate REQ to temperature/h2o/refGPH hGrid
d2863 1
a2863 1
        call refractive_index ( ps, temperature%values(:,i), n, h2o%values(:,i) )
d2874 2
a2875 2
        call interpolateValues ( h2o%template%phi(1,:), quantity%values(:,j), &
          &                      h2o%template%surfs(:,1), ptan%values(:,j), &
d2883 2
a2884 2
      ! ------------------------------------- RHIFromOrToH2O ----
    subroutine RHIFromOrToH2O ( key, quantity, &
d2888 1
a2888 1
      ! Convert h2o vmr to %RHI for all instances, channels, surfaces
d2898 1
a2898 1
      !     I.e., for xQuantity (where x can be h2o or temperature)
d2904 1
a2904 1
      ! (3) if invert is TRUE, like (1) but its inverse: %RHI to h2o vmr
d2907 1
a2907 1
      type (VectorValue_T), intent(inout) :: QUANTITY ! (rhi) Quantity to fill
d2910 2
a2911 2
      logical, intent(in)           ::    dontMask    ! Use even masked values
      logical, intent(in)           ::    ignoreZero  ! Ignore 0 values of h2o
d2915 1
a2915 1
      logical, intent(in)           ::    invert      ! %RHI -> vmr if TRUE
d2919 1
a2919 1
      integer ::                          Chan_h2o    ! Channel loop counter
d2921 1
a2921 1
      logical, parameter ::               DEEBUG_RHI = .false.
d2927 2
a2928 2
      logical                          :: matched_h2o_channels
      logical                          :: matched_h2o_instances
d2938 1
a2938 1
      integer ::                          S_RHI       ! Instance num for surfs
d2953 1
a2953 1
       &                                  zetaH2o, oldH2o
d2957 1
a2957 1
      call trace_begin ( me, 'FillUtils_1.RHIFromOrToH2O', key, &
d2960 1
a2960 1
      ! Let any undefined values be so marked (but not necessarily masked)
d2963 1
a2963 1
      ! Will we convert %RHI to vmr?
d2980 1
a2980 1
        & ' RHIFromOrToH2O unable to invert and interpolate simultaneously' )
d2993 1
a2993 1
        & 'Incompatible quantities in RHIFromOrToH2O--' //&
d3005 1
a3005 1
        & 'Different vertical coords in RHIFromOrToH2O--' //&
d3009 1
a3009 1
      matched_h2o_channels = &
d3011 1
a3011 1
      matched_h2o_instances = &
d3021 1
a3021 1
          s_rhi = 1
d3023 1
a3023 1
          s_rhi = i
d3026 1
a3026 1
          s_h2o = 1
d3028 1
a3028 1
          s_h2o = i
d3037 1
a3037 1
          zeta = -log10 ( quantity%template%surfs(:,s_rhi) )
d3039 1
a3039 1
          zeta = quantity%template%surfs(:,s_rhi)
d3041 2
a3042 2
        if ( interpolate .and. .not. matched_h2o_instances ) then
          i_h2o = 1
d3044 1
a3044 1
          i_h2o = i
d3052 1
a3052 1
          zetah2o = -log10 ( sourceQuantity%template%surfs(:,s_h2o) )
d3054 1
a3054 1
          zetah2o = sourceQuantity%template%surfs(:,s_h2o)
d3063 2
a3064 2
          if ( interpolate .and. .not. matched_h2o_channels ) then
            Chan_h2o = 1
d3066 1
a3066 1
            Chan_h2o = Channel
d3075 2
a3076 2
              qIndex = Chan_h2o + (s-1)*sourceQuantity%template%noChans
              oldH2o(s) = sourceQuantity%values(qIndex, i_h2o)
d3082 1
a3082 1
            call InterpolateValues( zetah2o, oldH2o, &
d3121 1
a3121 1
               & RHIFromH2O_Factor(T, zeta(qIndex), vmr_unit_cnv, invert)
d3127 1
a3127 1
      if ( .not. associated ( quantity%mask ) ) then
d3130 1
a3130 1
        where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
d3134 2
a3135 2
      if ( DEEBUG_RHI ) then
        call output('rhi Num. instances: ', advance='no')
d3143 1
a3143 1
        call output('Were any rhi left undefined? ', advance='no')
d3156 1
a3156 1
          call dump(sourceQuantity%values(:,1), 'RHI(%)')
d3158 1
a3158 1
          call dump(Quantity%values(:,1), 'RHI(%)')
d3161 1
a3161 1
    9 call trace_end ( 'FillUtils_1.RHIFromOrToH2O', &
d3163 1
a3163 1
    end subroutine RHIFromOrToH2O
d3165 2
a3166 2
    ! ----------------------------------  RHIPrecisionFromOrToH2O  -----
    subroutine RHIPrecisionFromOrToH2O ( key, quantity, &
d3172 1
a3172 1
      ! Convert h2o vmr to %RHI for all instances, channels, surfaces
d3182 1
a3182 1
      !     I.e., for xQuantity (where x can be h2o or temperature)
d3194 1
a3194 1
      type (VectorValue_T), intent(inout) :: QUANTITY ! (rhi) Quantity to fill
d3199 2
a3200 2
      logical, intent(in)           ::    dontMask    ! Use even masked values
      logical, intent(in)           ::    ignoreZero  ! Ignore 0 values of h2o
d3204 1
a3204 1
      logical, intent(in)           ::    invert      ! %RHI -> vmr if TRUE
d3208 1
a3208 1
      integer ::                          Chan_h2oPrecision    ! Channel loop counter
d3210 1
a3210 1
      integer ::                          Chan_h2o    ! Channel loop counter
d3212 1
a3212 1
      logical, parameter ::               DEEBUG_RHI = .false.
d3219 4
a3222 4
      logical                          :: matched_h2oPrecision_channels
      logical                          :: matched_h2oPrecision_instances
      logical                          :: matched_h2o_channels
      logical                          :: matched_h2o_instances
d3236 1
a3236 1
      integer ::                          S_RHI       ! Instance num for surfs
d3250 1
a3250 1
       &                                  zetaH2oPrecision, oldH2oPrecision
d3254 1
a3254 1
       &                                  zetaH2o, oldH2o
d3258 1
a3258 1
      call trace_begin ( me, 'FillUtils_1.RHIPrecisionFromOrToH2O', key, &
d3261 1
a3261 1
      ! Let any undefined values be so marked (but not necessarily masked)
d3264 1
a3264 1
      ! Will we convert %RHI to vmr?
d3267 1
a3267 1
      !  & ' RHIPrecisionFromOrToH2O unable to invert' )
d3281 1
a3281 1
        & ' RHIPrecisionFromOrToH2O unable to invert and interpolate simultaneously' )
d3296 1
a3296 1
        & 'Incompatible quantities in RHIPrecisionFromOrToH2O--' //&
d3310 1
a3310 1
        & 'Different vertical coords in RHIPrecisionFromOrToH2O--' //&
d3314 1
a3314 1
      matched_h2oPrecision_channels = &
d3316 1
a3316 1
      matched_h2oPrecision_instances = &
d3322 1
a3322 1
      matched_h2o_channels = &
d3324 1
a3324 1
      matched_h2o_instances = &
d3334 1
a3334 1
          s_rhi = 1
d3336 1
a3336 1
          s_rhi = i
d3339 1
a3339 1
          s_h2o = 1
d3341 1
a3341 1
          s_h2o = i
d3350 1
a3350 1
          zeta = -log10 ( quantity%template%surfs(:,s_rhi) )
d3352 1
a3352 1
          zeta = quantity%template%surfs(:,s_rhi)
d3354 2
a3355 2
        if ( interpolate .and. .not. matched_h2oPrecision_instances ) then
          i_h2oPrecision = 1
d3357 1
a3357 1
          i_h2oPrecision = i
d3364 2
a3365 2
        if ( interpolate .and. .not. matched_h2o_instances ) then
          i_h2o = 1
d3367 1
a3367 1
          i_h2o = i
d3375 1
a3375 1
          zetah2oPrecision = -log10 ( sourcePrecisionQuantity%template%surfs(:,s_h2o) )
d3377 1
a3377 1
          zetah2oPrecision = sourcePrecisionQuantity%template%surfs(:,s_h2o)
d3385 1
a3385 1
          zetah2o = -log10 ( sourceQuantity%template%surfs(:,s_h2o) )
d3387 1
a3387 1
          zetah2o = sourceQuantity%template%surfs(:,s_h2o)
d3396 2
a3397 2
          if ( interpolate .and. .not. matched_h2oPrecision_channels ) then
            Chan_h2oPrecision = 1
d3399 1
a3399 1
            Chan_h2oPrecision = Channel
d3406 2
a3407 2
          if ( interpolate .and. .not. matched_h2o_channels ) then
            Chan_h2o = 1
d3409 1
a3409 1
            Chan_h2o = Channel
d3418 2
a3419 2
              qIndex = Chan_h2oPrecision + (s-1)*sourcePrecisionQuantity%template%noChans
              oldH2oPrecision(s) = sourcePrecisionQuantity%values(qIndex, i_h2oPrecision)
d3425 1
a3425 1
            call InterpolateValues( zetah2oPrecision, oldH2oPrecision, &
d3440 2
a3441 2
              qIndex = Chan_h2o + (s-1)*sourceQuantity%template%noChans
              oldH2o(s) = sourceQuantity%values(qIndex, i_h2o)
d3447 1
a3447 1
            call InterpolateValues( zetah2o, oldH2o, &
d3489 1
a3489 1
                call RHIPrecFromH2O( H2OofZeta(s), &
d3501 1
a3501 1
      if ( .not. associated ( quantity%mask ) ) then
d3504 1
a3504 1
        where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
d3508 2
a3509 2
      if ( DEEBUG_RHI ) then
        call output('rhi Num. instances: ', advance='no')
d3517 1
a3517 1
        call output('Were any rhi left undefined? ', advance='no')
d3530 1
a3530 1
          call dump(sourceQuantity%values(:,1), 'RHI(%)')
d3532 1
a3532 1
          call dump(Quantity%values(:,1), 'RHI(%)')
d3535 1
a3535 1
    9 call trace_end ( 'FillUtils_1.RHIPrecisionFromOrToH2O', &
d3537 1
a3537 1
    end subroutine RHIPrecisionFromOrToH2O
d3581 1
a3581 1
        if ( .not. associated ( quantity%mask ) ) call CreateMask ( quantity )
d3584 1
a3584 1
          quantity%mask = char(ior(ichar(quantity%mask),M_LinAlg))
d3676 1
a3676 1
        ! Work out if we have to obey the mask
d3678 2
a3679 2
        if ( associated ( qty%mask ) ) &
          & myNewValues = any ( iand ( ichar(qty%mask(:,:)), m_fill ) /= 0 )
d3751 1
a3751 1
          where ( iand ( ichar(qty%mask(:,:)),m_fill) == 0 )
d3765 1
a3765 1
        ! If we have a mask and we're going to obey it then do so
d3772 2
a3773 2
        if ( associated(qty%mask) ) then
          where ( iand ( ichar(qty%mask(:,:)), m_Fill ) == 0 )
d3789 1
a3789 1
      ! This is to fill a l2gp type of quantity with a los grid type of quantity.
d3793 1
a3793 1
      ! Linear interpolation is used to fill l2gp grids and unfilled grids are
d3958 6
d3968 1
a3968 1
      use MANIPULATIONUTILS, only: MANIPULATE
a3980 21
      ! The 1 and 2-way manipulations must be entered exactly as shown
      ! Other more general manipulations are automatically recognized
      ! (with autoRecognizeGeneralExp)
      
      ! "More general" means free use of '+', '-', '*', '/' and appropriate
      ! nesting between '(' and ')' where appropriate.
      
      ! Why not do away with the 1-way and 2-way manipulations that can be
      ! done by the general manipulation? E.g., (a+b)/2 is easily 
      ! handled already, why make it a special 2-way?

      ! Isn't there a way to encapsulate the idiom
      ! if ( .not. associated ( quantity%mask ) ) then
      ! .   .   .
      !   end where
      ! endif
      ! So we can shorten this considerably?
      ! Probably need to create a temp array the same shape as quantity%values

      ! Not listed below but also available are the manipulations 
      ! 'a^c' and 'c^a' (also called 'a**c' and 'c**a')
d3990 1
a3990 1
      character (len=128) :: MSTR
a3992 1
      ! logical :: USESC
a4000 2
      ! usesC = present(c)
      ! StatisticalFunction = ( FindFirst( valid1WayManipulations, mstr ) > 7 )
d4057 1
a4057 1
        if ( .not. associated ( quantity%mask ) ) then
d4060 1
a4060 1
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
d4091 2
a4092 2
    ! so that we mask radiances where the corresponding precisions
    ! are negative or masked themselves
d4101 3
a4103 3
      & ISPRECISION, SUFFIX, GEOLOCATION, PRECISIONQUANTITY, BOMASK )
      use BitStuff, only: NEGATIVEIFBITPATTERNSET
      use Init_Tables_Module, only: L_GEOCENTRIC, L_GEODETIC, L_NONE
d4112 1
a4112 1
      integer, intent(in), optional              :: BOMASK ! A pattern of bits--
d4116 1
a4116 1
      type (l1bData_T)                      :: BO_stat
d4121 1
a4121 1
      type (l1bData_T)                      :: L1BDATA
d4220 1
a4220 1
        call ReadL1BData ( L1BFile, nameString, l1bData, noMAFs, flag, &
d4251 1
a4251 1
      if ( quantity%template%noInstances /= size ( l1bData%dpField, 3 ) .or. &
d4253 1
a4253 1
        &   size ( l1bData%dpField, 1 ) * size ( l1bData%dpField, 2 ) ) then
d4262 3
a4264 3
        call output ( size ( l1bData%dpField, 1 ) )
        call output ( size ( l1bData%dpField, 2 ), before=', ' )
        call output ( size ( l1bData%dpField, 3 ), before=', ', &
d4273 2
a4274 2
        noMAFs = size(l1bData%dpField, 3)
        maxMIFs = l1bData%maxMIFs
d4285 1
a4285 1
          call output ( size ( l1bData%dpField, 1 ) )
d4287 1
a4287 1
          call output ( size ( l1bData%dpField, 2 ) )
d4289 2
a4290 2
          call output ( size ( l1bData%dpField, 3 ), advance='yes' )
          call outputNamedValue( 'shape' // trim(namestring), shape(l1bData%dpField) )
d4297 1
a4297 1
          call dump( l1bData%dpField(1,:,:), '(Before applying bright object mask)' )
d4300 2
a4301 2
        l1bData%dpField(channel,:,:) = &
          & NegativeIfBitPatternSet( l1bData%dpField(channel,:,:), &
d4305 1
a4305 1
          & call dump( l1bData%dpField(1,:,:), '(After applying bright object mask)' )
d4309 1
a4309 1
      quantity%values = RESHAPE(l1bData%dpField, &
d4341 1
a4341 1
          call ReadL1BData ( L1BOAFile, nameString, l1bData, noMAFs, flag, &
d4344 1
a4344 1
          quantity%template%geodLat = RESHAPE(l1bData%dpField, &
d4351 1
a4351 1
          call ReadL1BData ( L1BOAFile, nameString, l1bData, noMAFs, flag, &
d4354 1
a4354 1
          quantity%template%geodLat = RESHAPE(l1bData%dpField, &
d4361 1
a4361 1
        call ReadL1BData ( L1BOAFile, nameString, l1bData, noMAFs, flag, &
d4364 1
a4364 1
        quantity%template%Lon = RESHAPE(l1bData%dpField, &
d4368 2
a4369 2
      if ( BeVerbose( 'l1bfill', 0 ) ) call Dump( l1bData )
      call DeallocateL1BData(l1bData)
d4375 1
a4375 1
    subroutine FromL2AUX ( qty, l2aux, errorCode )
d4387 1
a4387 1
      ! Work out which profile in the l2aux this belongs to
d4397 1
a4397 1
      if ( firstProfile < lbound ( l2aux%values, 3 ) ) then
d4401 1
a4401 1
      if ( lastProfile > ubound ( l2aux%values, 3 ) ) then
d4405 2
a4406 2
      if ( size ( l2aux%values, 1 ) /= qty%template%noChans .or. &
        &  size ( l2aux%values, 2 ) /= qty%template%noSurfs ) then
d4411 1
a4411 1
      qty%values = reshape ( l2aux%values ( :, :,  &
d4453 1
a4453 1
        if ( .not. present(gphQuantity) ) then
d4489 3
a4491 3
      if ( present(gphQuantity) ) then
        if ( .not. ValidateVectorQuantity ( gphQuantity, &
             & quantityType=(/l_gph/) ) ) then
d4531 1
a4531 1
        & scVelQuantity, geocAltitudeQuantity, gphQuantity )
d4540 1
a4540 1
      use MANIPULATEVECTORQUANTITIES, only: DoHGridsMatch, DoVGridsMatch
d4556 1
a4556 1
      case ( l_gph )
d4575 1
a4575 1
      & temperatureQuantity, refGPHQuantity, h2oQuantity, &
d4578 2
a4579 2
      use MANIPULATEVECTORQUANTITIES, only: DoHGridsMatch, &
        & FINDCLOSESTINSTANCES
d4610 1
a4610 1
           &   .and. doHGridsMatch ( h2oQuantity, temperatureQuantity ) ) ) then
d4647 1
a4647 1
          & refGPHQuantity, h2oQuantity, orbitInclinationQuantity, &
d4827 1
a4827 1
      type (l1bData_T)                           :: L1BDATA
d5001 1
a5001 1
      use wmoTropopause, only: EXTRATROPICS, TWMO
d5121 2
a5122 2
      use Geometry, only: GEODTOGEOCLAT
      use Hydrostatic_M, only: HYDROSTATIC
d5679 1
a5679 1
    subroutine FromL2GP ( quantity,l2gp, interpolate, profile, &
d5683 1
a5683 1
      ! the appropriate subset of profiles from the l2gp
d5718 2
a5719 2
      if ( (quantity%template%noChans/=l2gp%nFreqs) .and. &
        &  ((quantity%template%noChans/=1) .or. (l2gp%nFreqs/=0)) ) &
d5721 1
a5721 1
        & 'Quantity and l2gp have different number of channels' )
d5723 1
a5723 1
      if ( quantity%template%noSurfs /= l2gp%nLevels .and. (.not. interpolate) ) &
d5725 1
a5725 1
        & 'Quantity and l2gp have different number of surfaces (set interpolate?)' )
d5730 1
a5730 1
            & LOG10(l2gp%pressures)) > TOLERANCE) ) &
d5732 1
a5732 1
            & 'Quantity and l2gp are on different surfaces (set interpolate?)' )
d5735 1
a5735 1
            & LOG10(l2gp%pressures)) > TOLERANCE) ) &
d5737 1
a5737 1
            & 'Quantity and l2gp are on different surfaces (set interpolate?)' )
d5748 1
a5748 1
            & abs(quantity%template%time(1,1)-l2gp%time) &
d5752 1
a5752 1
            & abs(quantity%template%phi(1,1)-l2gp%geodAngle) &
d5759 1
a5759 1
        if ( lastProfile > l2gp%nTimes ) &
d5761 1
a5761 1
          & 'Quantity has profiles beyond the end of the l2gp' )
d5764 1
a5764 1
        if ( any(abs(l2gp%geodAngle(firstProfile:lastProfile)-&
d5768 1
a5768 1
            call dump ( l2gp%geodAngle(firstProfile:lastProfile), 'L2GP geodetic angle' )
d5772 1
a5772 1
            & 'Quantity has profiles that mismatch l2gp in geodetic angle; interpolate?' )
d5776 1
a5776 1
        if ( any(abs(l2gp%time(firstProfile:lastProfile)- &
d5779 1
a5779 1
            call dump ( l2gp%time(firstProfile:lastProfile), 'L2GP geodetic angle' )
d5783 1
a5783 1
          & 'Quantity has profiles that mismatch l2gp in time' )
d5793 1
a5793 1
        if ( profile == 0 .or. profile > l2gp%nTimes ) &
d5795 1
a5795 1
          & 'Illegal profile request in l2gp fill' )
d5800 1
a5800 1
        source => l2gp%l2gpPrecision
d5802 1
a5802 1
        source => l2gp%l2gpValue
d5825 1
a5825 1
        call InterpolateArraySetup ( -log10(real(l2gp%pressures, r8)), &
d5837 1
a5837 1
            & -log10(real(l2gp%pressures, r8)), &  ! Old X
d6003 1
a6003 1
      ! Spread it into the other instances, worry about the mask and instances
d6009 2
a6010 2
              if ( associated(quantity%mask) ) then
                if ( iand ( ichar(quantity%mask(j,i)), m_fill ) == 0 ) &
d6112 2
a6113 2
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGS, only: STREQ
d6514 2
a6515 2
      if ( associated ( radianceQuantity%mask ) ) then
        where ( iand ( ichar(radianceQuantity%mask), M_LinAlg ) /= 0 )
d6652 2
a6653 2
        if ( associated ( quantity%mask ) ) then
          where ( iand ( ichar(quantity%mask(:,i)), m_Fill ) == 0 )
d6674 2
a6675 2
        if ( associated ( quantity%mask ) ) then
          where ( iand ( ichar(quantity%mask(:,i)), m_Fill ) == 0 )
d6710 2
a6711 2
              if ( associated ( quantity%mask ) ) then
                if ( iand ( ichar(quantity%mask(j,i)), m_Fill ) == 1 ) cycle
d6730 2
a6731 2
              if ( associated ( quantity%mask ) ) then
                if ( iand ( ichar(quantity%mask(j,i)), m_Fill ) == 1 ) cycle
d6744 4
a6747 4
    subroutine TransferVectors ( SOURCE, DEST, SKIPMASK, INTERPOLATE, &
      & BOOLEANNAME )
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGS, only: STREQ
d6751 1
a6751 1
      logical, intent(in) :: SKIPMASK
d6799 3
a6801 3
          if ( associated(sq%mask) ) then
            if ( .not. associated(dq%mask)) call CreateMask ( dq )
            dq%mask = sq%mask
d6830 7
a6836 7
    subroutine TransferVectorsByMethod ( KEY, DEST, &
      & SOURCE, METHOD, DONTMASK, INTERPOLATE, &
      & IGNORENEGATIVE, IGNOREZERO, MEASVECTOR, MODELVECTOR, &
      & NOISEVECTOR, PTAN, BOOLEANNAME )
    use MLSL2OPTIONS, only: RUNTIMEVALUES
    use MLSSTRINGS, only: STREQ
    use DUMP_0, only: DUMP
d6841 1
a6841 1
      logical, intent(in)            :: DONTMASK
d7093 1
a7093 1
      use MLSHDF5, only: MATCHHDF5ATTRIBUTES
d7145 1
a7145 1
      use MLSHDF5, only: GETALLHDF5DSNAMES, MATCHHDF5ATTRIBUTES
d7335 1
a7335 1
      use MLSHDF5, only: GETHDF5ATTRIBUTE, GETHDF5DSDIMS, LOADFROMHDF5DS
d7351 2
a7352 2
      type( L2AUXData_T ) :: l2aux ! Result
      type( l2GPData_T ) :: l2gp   ! Result
d7370 4
a7373 4
          &   'Unable to use spread when filling from l2aux file' )
        call ReadL2AUXData ( MLSFile, name, quantity%template%quantityType, l2aux )
        call FromL2Aux( quantity, l2aux, status )
        call DestroyL2AUXContents ( l2aux )
d7376 4
a7379 4
          &   'Unable to use spread when filling from l2gp file' )
        call ReadL2GPData( MLSFile, name, l2gp )
        call FromL2GP ( quantity, l2gp, .false., -1, status, .true., .false. )
        call DestroyL2GPContents ( l2gp )
d7509 1
a7509 1
       "$Id: FillUtils_1.f90,v 2.104 2015/04/09 01:12:32 vsnyder Exp $"
d7521 3
d7758 1
a7758 1
! May Fill H2O precision from RHI precision
d7782 1
a7782 1
! Another fix to masking bit miscues in RHI..
d7788 1
a7788 1
! Consider only mask of quantity being filled, not sources in RHi
d7800 1
a7800 1
! Let precisions explicitly set negative also mask radiances
d7815 1
a7815 1
! Fill by manipulation now respects mask better
@


2.104
log
@Correct message about mismatched vGrid in RotateMagneticField
@
text
@d35 1
a35 1
    & L_GeocAltitude, L_GPH, &
d159 2
a160 1
  integer, parameter, public :: BadScVelECRQuantity = badREFGPHQuantity + 1
d326 2
d333 1
a333 1
        call output ( " ScVelECR quantity is not ScVelECR", advance='yes' )
d4439 2
a4440 2
    subroutine UsingMagneticModel ( qty, GeocAltitudeQuantity, ScVelQuantity, &
                                  & key, MAF )
d4442 1
d4444 4
a4447 4
      type (VectorValue_T), intent(in) :: GeocAltitudeQuantity ! (MIF quantity)
      type (VectorValue_T), intent(in) :: ScVelQuantity        ! (MIF quantity)
      integer, intent(in) :: KEY
      integer, intent(in), optional :: MAF ! to use for Qty quantity
d4456 1
d4464 3
a4466 3
      if ( .not. ValidateVectorQuantity ( geocAltitudeQuantity, &
           & quantityType=(/l_tngtgeocAlt/), frequencyCoordinate=(/ l_none /), &
           & verticalCoordinate=(/l_geocAltitude/) ) ) then
d4468 2
a4469 1
          & 'GeocAltitude quantity does not describe geocentric altitude' )
d4472 46
a4517 2
      if ( .not. ValidateVectorQuantity ( scVelQuantity, &
           & quantityType=(/l_scVelECR/), frequencyCoordinate=(/ l_xyz /) ) ) then
d4519 2
a4520 1
          & 'ScVelECR quantity does not describe spacecraft velocity in ECR' )
d4523 26
d4551 1
a4551 1
        & geocAltitudeQuantity, scVelQuantity, MAF )
d7529 1
a7529 1
       "$Id: FillUtils_1.f90,v 2.103 2015/03/28 02:41:45 vsnyder Exp $"
d7541 3
@


2.103
log
@Got IsMonotonic from Monotone instead of MLSFillValues.  Added support
for cross-track grids.  Use Norm2 to normalize LOS.  Specify whether
latitude is geocentric or geodetic.  Change UsingMagneticModel fill to
use SC velocity quantity to get SC geolocation (we don't care about its
velocity) and a geocentric altitude quantity to get the tangent position
geolocation and geocentric altitude.  Use 3-d Values field for ECRtoFOV
quantity in RotateMagneticField.  Account for cross-track viewing in
RotateMagneticField.  Use ATAN2 instead of ATAN in two places.
@
text
@d6517 1
a6517 1
          & 'Field and result quantity must have matching hGrids' )
d7452 1
a7452 1
       "$Id: FillUtils_1.f90,v 2.102 2014/12/10 21:30:34 pwagner Exp $"
d7464 10
@


2.102
log
@WithAscOrDesc may use PtanQuantity
@
text
@d35 1
a35 1
    & L_GPH, &
d70 1
a70 1
  use MLSFILLVALUES, only: ISFILLVALUE, ISFINITE, ISMONOTONIC, &
d84 1
d159 2
a160 1
  integer, parameter, public :: Miscellaneous_err = badREFGPHQuantity + 1
d329 2
d715 2
a716 1
      numChans = quantity%template%instanceLen / quantity%template%noSurfs
d720 1
d725 1
a725 1
      endif
d2699 1
a2699 1
            los = los / sqrt(sum(los**2))
d3927 1
a3927 1
            & - atan(sLevel/(re%values(1,maf)*0.001_r8 + zt(mif)))*rad2deg
d4271 1
a4271 1
        call output ( 'Quantity shape:' )
d4273 6
a4278 7
        call output ( ' ( ' )
        call output ( quantity%template%noChans )
        call output ( ', ' )
        call output ( quantity%template%noSurfs )
        call output ( ' ), ' )
        call output ( quantity%template%noInstances, advance='yes' )
        call output ( 'L1B shape:' )
d4280 5
a4284 4
        call output ( ', ' )
        call output ( size ( l1bData%dpField, 2 ) )
        call output ( ', ' )
        call output ( size ( l1bData%dpField, 3 ), advance='yes' )
d4363 1
d4373 1
d4436 2
a4437 1
    subroutine UsingMagneticModel ( qty, gphQty, key, SpacingOnly, MAF )
d4439 3
a4441 2
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(inout) :: GPHQTY
d4443 1
a4443 2
      logical, intent(in), optional :: SpacingOnly
      integer, intent(in), optional :: MAF ! to use for GPH quantity
d4459 3
a4461 2
      if ( .not. ValidateVectorQuantity ( gphQty, quantityType=(/l_gph/), &
        & frequencyCoordinate=(/ l_none /), verticalCoordinate=(/l_zeta/) ) ) then
d4463 1
a4463 7
          & 'GPH quantity does not describe gph field' )
        error = .true.
      end if
      if ( .not. present(MAF) ) then
        if ( .not. DoHGridsMatch ( qty, gphQty, spacingOnly ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'Magnetic field quantity and GPHQuantity do not have compatible horizontal basis' )
a4464 1
        end if
d4466 2
a4467 1
      if ( .not. DoVGridsMatch ( qty, gphQty ) ) then
d4469 1
a4469 1
          & 'Magnetic field quantity and GPHQuantity do not share the same vertical basis' )
d4473 2
a4474 1
      if ( .not. error ) call get_Magnetic_Field_Quantity ( qty, GPHQty, MAF )
d6492 1
d6524 8
a6531 3
        maf = minloc ( abs ( qty%template%phi(1,instance) - &
          & ecrToFOV%template%phi(1,:) ) )
        rotation = reshape ( ecrToFOV%values( 1:9, maf), (/ 3, 3 /) )
d6533 3
d6537 28
a6564 26
          ! Get the field in ECR coordinates
          thisField = fieldECR%values ( (surface-1) * 3 + 1 : surface*3, &
            & instance )
          ! Now rotate it into IFOVPP coordinates
          thisField = matmul ( rotation, thisField )
          ! Now work out the strength / angles as appropriate.
          strength = sqrt ( sum ( thisField ** 2 ) )
          select case ( qty%template%quantityType )
          case ( l_fieldStrength )
            qty%values(surface,instance) = strength
          case ( l_fieldElevation )
            if ( strength /= 0.0_r8 ) then
              ! Elevation is constrained to 0--90 degrees instead of 0--180 degrees because
              ! radiative transfer Physics is symmetric.  We save half of l2pc bins.
              qty%values(surface,instance) = acos ( abs ( thisField(3) / strength ) ) * rad2deg
            else
              qty%values(surface,instance) = 0.0
            end if
          case ( l_fieldAzimuth )
            if ( thisField(1) /= 0.0_r8 ) then
              qty%values(surface,instance) = atan ( thisField(2) / thisField(1) ) * rad2deg
            else
              qty%values(surface,instance) = merge ( 90.0_r8, -90.0_r8, &
                & thisField(1) > 0.0_r8 )
            end if
          end select
d7452 1
a7452 1
       "$Id: FillUtils_1.f90,v 2.101 2014/10/31 17:43:45 vsnyder Exp $"
d7464 3
@


2.101
log
@Separate PTan and GPH hydrostatic fills
@
text
@d2503 1
a2503 1
      ! ignoring the of diagonal elements (not available outside
d4747 3
a4749 2
    subroutine WithAscOrDesc ( QUANTITY, CHUNK, FILEDATABASE, HGRIDS )
    use HGRIDSDATABASE, only: HGRID_T
d4752 1
d4757 1
d4759 4
a4762 1
      integer                                    :: I, MAF
d4764 1
d4767 2
d4772 2
d4784 10
a4793 1
      noSurfs = min(quantity%template%noSurfs, size(L1BData%dpField, 2))
d4797 8
a4804 2
        quantity%values(1:noSurfs,i) = sign(1._rv, &
          & L1BData%dpField(3,1:noSurfs,maf))
d4806 2
d4809 2
d7436 1
a7436 1
       "$Id: FillUtils_1.f90,v 2.100 2014/05/13 00:13:22 pwagner Exp $"
d7448 3
@


2.100
log
@FromL2GP may inerpolate in time, instead of phi
@
text
@d185 2
a186 2
      & HYDROSTATICALLY, FROMSPLITSIDEBAND, GPHPRECISION, &
      & FROMISOTOPE, FROMASCIIFILE, ROTATEMAGNETICFIELD, &
d4475 38
a4512 2
    ! ------------------------------------------  Hydrostatically  -----
    subroutine Hydrostatically ( key, quantity, &
d4516 3
a4518 2
      use MANIPULATEVECTORQUANTITIES, only: FINDCLOSESTINSTANCES
      ! Various hydrostatic fill operations
d4542 1
a4542 1
      call trace_begin ( me, 'FillUtils_1.Hydrostatically', key, &
a4545 19
      case ( l_gph )
        if ( (temperatureQuantity%template%noSurfs /= &
          &   quantity%template%noSurfs) .or. &
          &  (refGPHQuantity%template%noInstances /= &
          &   quantity%template%noInstances) .or. &
          &  (temperatureQuantity%template%noInstances /= &
          &   quantity%template%noInstances) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_gph failed first test" )
          go to 9
        end if
        if ( (any(quantity%template%surfs /= temperatureQuantity%template%surfs)) .or. &
          & (any(quantity%template%phi /= temperatureQuantity%template%phi)) .or. &
          & (any(quantity%template%phi /= refGPHQuantity%template%phi)) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            &  "case l_gph failed second test" )
          go to 9
        end if
        call GetBasisGPH ( temperatureQuantity, refGPHQuantity, quantity%values )
d4547 2
a4548 4
        if ( (temperatureQuantity%template%noInstances /= &
          &   refGPHquantity%template%noInstances) .or. &
          &  (temperatureQuantity%template%noInstances /= &
          &   h2oQuantity%template%noInstances) ) then
d4552 1
a4552 7
        end if
        if ( (any(refGPHquantity%template%phi /= temperatureQuantity%template%phi)) .or. &
          & (any(h2oQuantity%template%phi /= temperatureQuantity%template%phi)) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_ptan failed second test" )
          go to 9
        end if
d4589 3
a4591 1
        call Announce_error ( 0, 0, 'No such fill yet' )
d4594 10
a4603 1
    9 call trace_end ( 'FillUtils_1.Hydrostatically', &
d4605 2
a4606 9
      if ( .not. verbose .or. .not. associated(phitanquantity) ) return
      nullify( closestTempProfiles )
      call Allocate_Test ( closestTempProfiles, phitanquantity%template%noInstances, &
        "closestTempProfiles", ModuleName )
      call FindClosestInstances ( temperatureQuantity, phitanquantity, &
        & closestTempProfiles )
      call Deallocate_Test ( closestTempProfiles, "closestTempProfiles", ModuleName )
      
    end subroutine Hydrostatically
d7406 1
a7406 1
       "$Id: FillUtils_1.f90,v 2.99 2014/04/07 18:06:10 pwagner Exp $"
d7418 3
@


2.99
log
@Added check on quantityTypes when Filling WithAscOrDesc
@
text
@d40 1
a40 2
    & L_MAGNETICFIELD, &
    & L_MAX, L_MEAN, L_MIN, L_MOLCM2, &
d49 1
a49 1
    & L_TEMPERATURE, L_TNGTECI, L_TNGTGEODALT, &
d5640 9
a5648 1
        firstProfileAsArray=minloc(abs(quantity%template%phi(1,1)-l2gp%geodAngle))
d5659 2
a5660 1
          &         quantity%template%phi(1,:)) > tolerance) ) then
d7392 1
a7392 1
       "$Id: FillUtils_1.f90,v 2.98 2014/03/13 18:12:26 pwagner Exp $"
d7404 3
@


2.98
log
@GeoidData Fills will warn instead of bomb if running toolkitless
@
text
@d43 1
a43 1
    & L_ORBITINCLINATION, &
d49 1
a49 1
    & L_STATUS, L_SYSTEMTEMPERATURE, &
d4729 1
a4729 1
    ! --------------------------------------------  WithEstdNoise  -----
d4750 5
d7384 1
a7384 1
       "$Id: FillUtils_1.f90,v 2.97 2014/01/09 00:30:24 pwagner Exp $"
d7396 3
@


2.97
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d74 1
a74 1
  use MLSL2OPTIONS, only: AURA_L1BFILES, L2CFNODE, MLSMESSAGE
d2432 8
d7379 1
a7379 1
       "$Id: FillUtils_1.f90,v 2.96 2013/11/22 00:22:49 pwagner Exp $"
d7391 3
@


2.96
log
@Simpler, hopefully better, too, way to prevent NaNs in ChiSqRatio
@
text
@d23 1
d85 1
a85 1
  use OUTPUT_M, only: BEVERBOSE, BLANKS, NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d7371 1
a7371 1
       "$Id: FillUtils_1.f90,v 2.95 2013/11/21 21:23:52 pwagner Exp $"
d7383 3
@


2.95
log
@Further steps to prevent Fiiling convergence ratios with non-finite values
@
text
@d1345 1
d1410 1
d1415 1
d1417 1
a1417 1
          & .not. dontMask .and. ( &
d1419 3
a1421 3
          &   isVectorQtyMasked(minNormQty, qIndex, i, m_linalg) .or. &
          &   minNormQty%values(qIndex, i) == 0. &
          & )
d1423 1
a1423 1
          if ( minNormQty%values(qIndex, i) == 0. ) qty%values(:,i) = 999._rv
d7370 1
a7370 1
       "$Id: FillUtils_1.f90,v 2.94 2013/11/20 01:02:49 pwagner Exp $"
d7382 3
@


2.94
log
@Reduce some printing; switch to use of BeVerbose function
@
text
@d70 2
a71 1
  use MLSFILLVALUES, only: ISFILLVALUE, ISMONOTONIC, MONOTONIZE, REMOVEFILLVALUES
d1317 1
a1317 1
      ! TRUE    all values will equal the ratio of tghe last ieration
d1712 2
a1713 1
        quantity%values(1,:) = scale * sourceQuantity%values(1,1)
d1715 2
a1716 1
        qIndex = findLast( sourceQuantity%values(:,1) /= 0._rv )
d7367 1
a7367 1
       "$Id: FillUtils_1.f90,v 2.93 2013/10/24 21:10:23 pwagner Exp $"
d7379 3
@


2.93
log
@/dontLatch in profile Fills retains profile heights as input
@
text
@d79 1
a79 1
  use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, &
d83 1
a83 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d4272 1
a4272 1
        if ( switchDetail(switches, 'glob') > 0 ) then ! e.g., 'glob1'
d4293 1
a4293 1
        if ( switchDetail(switches, 'glob') > 1 ) then ! e.g., 'glob2'
d4301 1
a4301 1
        if ( switchDetail(switches, 'glob') > 1 ) &
d4363 1
a4363 1
      if ( switchDetail(switches, 'l1bfill') > -1 ) call Dump( l1bData )
d4464 2
a4465 2
      & orbitInclinationQuantity, phiTanQuantity, geocAltitudeQuantity, maxIterations, &
      & phiWindow, phiWindowUnits, chunkNo )
d4489 1
a4489 1
      verbose = ( switchDetail(switches, 'fill') > -1 )
d4570 1
a4570 1
      if ( .not. verbose ) return
d5479 1
a5479 1
      check = (switchDetail(switches, 'cgrid') > -1)
d5633 1
a5633 1
          if ( switchDetail(switches, 'l2gp') > -1) then
d5644 1
a5644 1
          if ( switchDetail(switches, 'l2gp') > -1) then
a5978 1
    use MLSSTRINGLISTS, only: GETHASHELEMENT
a6601 1
    use MLSSTRINGLISTS, only: GETHASHELEMENT, SWITCHDETAIL
a6602 2
    use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
    use TOGGLES, only: SWITCHES
d6623 1
a6623 1
      verbose = ( switchDetail(switches, 'bool') > -1 )
a6689 1
    use MLSSTRINGLISTS, only: GETHASHELEMENT, SWITCHDETAIL
a6690 1
    use OUTPUT_M, only: OUTPUTNAMEDVALUE
a6691 1
    use TOGGLES, only: SWITCHES
d7364 1
a7364 1
       "$Id: FillUtils_1.f90,v 2.92 2013/10/17 18:36:15 pwagner Exp $"
d7376 3
@


2.92
log
@GeoidData needs to call integer externals in DEM (but why?)
@
text
@a4730 1
      type (MLSFile_T), pointer                  :: L1BFile
d5718 1
a5718 1
      & instancesNode, globalUnit, ptan, logSpace )
d5721 6
d5728 2
a5729 2
      real(r8), dimension(:), intent(in) :: inheights
      real(r8), dimension(:), intent(in) :: invalues
d5734 1
d5746 1
d5755 1
d5761 1
d5769 2
d5783 1
d5799 4
a5802 3
      ! Now, if the quantity is coherent, let's assume the user wanted the
      ! 'nearest' values
      if ( quantity%template%coherent .or. associated(ptan) ) then
d5814 4
d5837 5
d5843 2
d5848 2
d5853 4
d5901 1
a5901 1
      & instancesNode, globalUnit, ptan, logSpace )
d5911 1
a5917 1
      ! logical :: MYLOGSPACE             ! Interpolate in log space?
a5938 2
      ! myLogSpace = quantity%template%logBasis
      ! if ( present ( logSpace ) ) myLogSpace = logSpace
d5969 1
a5969 1
        & instancesNode, globalUnit, ptan, logSpace )
d7371 1
a7371 1
       "$Id: FillUtils_1.f90,v 2.91 2013/10/09 00:26:27 pwagner Exp $"
d7383 3
@


2.91
log
@Protect against certain obscure crashes; use c_short instead of 2-byte integer
@
text
@d2397 2
a2398 2
        & PGSd_DEM_DEGREE , &
        & PGS_DEM_GETQUALITYDATA, PGS_DEM_GETSIZE, PGS_DEM_SORTMODELS
d2420 1
a2420 1
      !integer, external :: PGS_DEM_GETQUALITYDATA, PGS_DEM_GETSIZE, PGS_DEM_SORTMODELS
d2467 1
a2467 1
           call dump( buffer, 'buffer' )
d2469 1
a2469 1
            & ModuleName, "nonzero status in GeodData; must quit" )
d7343 1
a7343 1
       "$Id: FillUtils_1.f90,v 2.90 2013/10/02 00:48:55 pwagner Exp $"
d7355 3
@


2.90
log
@Added ascenddescend Fill Method
@
text
@d2395 1
d2403 2
a2404 1
      integer*2, dimension(4000)        :: BUFFER
d6609 1
a6609 1
        if ( verboser ) then
d6627 1
a6627 1
        if ( verboser ) call output( 'Transferring quantities named ' // trim(qName), advance='yes' )
d7343 1
a7343 1
       "$Id: FillUtils_1.f90,v 2.89 2013/09/25 16:39:53 pwagner Exp $"
d7355 3
@


2.89
log
@Repaired GeoidData
@
text
@d190 1
a190 1
      & WITHREICHLERWMOTP, &
d2396 2
a2397 2
        & PGSd_DEM_DEGREE !, &
!        & PGS_DEM_GETQUALITYDATA, PGS_DEM_GETSIZE, PGS_DEM_SORTMODELS
d2418 1
a2418 1
      integer, external :: PGS_DEM_GETQUALITYDATA, PGS_DEM_GETSIZE, PGS_DEM_SORTMODELS
d4713 37
d7341 1
a7341 1
       "$Id: FillUtils_1.f90,v 2.87 2013/09/21 00:24:21 pwagner Exp $"
d7353 3
@


2.88
log
@Use Where instead of Source_Ref for messages
@
text
@d2395 3
a2397 2
      use SDPTOOLKIT, only: PGSd_DEM_90ARC, PGSd_DEM_GEOID, PGSd_DEM_DEGREE, &
        & PGS_DEM_GETQUALITYDATA
d2402 1
a2402 1
      integer*2, dimension(40)          :: BUFFER
d2405 1
a2405 1
      double precision, parameter       :: DLATRANGE = 0.5d0
d2411 5
d2417 2
d2425 3
d2429 29
a2457 4
        latitude(1) = quantity%template%geodLat(1, i) - dlatRange
        latitude(2) = quantity%template%geodLat(1, i) + dlatRange
        longitude(1) = quantity%template%lon(1, i) - dlonRange
        longitude(2) = quantity%template%lon(1, i) + dlonRange
d2460 9
d7316 3
@


2.87
log
@Added geoid Fill methods
@
text
@d92 1
a92 1
  use TREE, only: DECORATION, SUBTREE, NSONS, SOURCE_REF, SUBTREE
d3474 1
d3476 1
a3476 1
      use MOREMESSAGE, only: ONEMOREMESSAGE => MLSMESSAGE
d3496 3
a3498 3
        call io_Error ( "Unable to open ASCII input file ", status, filenameStr )
        call ONEMOREMESSAGE( MLSMSG_Error, ModuleName, 'Error opening ASCII file at %l', &
          & (/ source_ref(key) /) )
d3503 2
a3504 2
        call ONEMOREMESSAGE( MLSMSG_Error, ModuleName, 'Error reading ASCII file %l', &
          & (/ source_ref(key) /) )
d3509 2
a3510 2
        call ONEMOREMESSAGE( MLSMSG_Error, ModuleName, 'Error closing ASCII file at %l', &
          & (/ source_ref(key) /) )
d7259 1
a7259 1
       "$Id: FillUtils_1.f90,v 2.86 2013/09/17 22:47:49 pwagner Exp $"
d7271 3
@


2.86
log
@Added Scatter, Gather methods
@
text
@d179 1
a179 1
      & FROML2GP, FROMPROFILE, GATHER, LOSVELOCITY, &
d2389 49
d7258 1
a7258 1
       "$Id: FillUtils_1.f90,v 2.84 2013/08/30 02:45:38 vsnyder Exp $"
d7270 3
@


2.85
log
@Correct 'no_code_for' error message
@
text
@d26 1
a26 1
    & L_BOUNDARYPRESSURE, L_BOXCAR, L_CHISQBINNED, L_CHISQCHAN, L_CHISQRATIO, &
d179 1
a179 1
      & FROML2GP, FROMPROFILE, LOSVELOCITY, &
d194 1
a194 1
      & SCALEOVERLAPS, SPREADCHANNELFILL, &
d618 1
a618 1
      character(len=128) :: whichInstances
d628 1
a628 1
      whichInstances = ' '
d1341 1
a1341 1
      integer ::                             NOCHANS
d1392 1
a1392 1
      noChans = qty%template%noChans
d1913 1
a1913 2
      type(vectorValue_T), pointer :: BOGUS         ! When we have no "b"
      integer                      :: NOKEY
d1919 2
a1920 2
      nullify( bogus, upper, lower )
      nokey = 0
d2315 74
d2809 1
a2809 1
      integer ::                          invs        ! 1 if invert, else -1
d2847 5
a2851 5
      if ( invert ) then
        invs = 1
      else
        invs = -1
      end if
a3878 1
      integer, parameter :: MAXSTRLISTLENGTH = 128
d3890 1
a3890 1
      logical :: USESC
d3899 1
a3899 1
      usesC = present(c)
d4543 74
a5436 1
      real(r8), parameter :: FTOL = 1.0e-3 ! 1 kHz
a5463 8
!       call dump ( l2gp%frequency, 'l2gp' )
!       call dump ( quantity%template%frequencies, 'quantity' )
!       if ( associated ( quantity%template%frequencies ) ) then
!         if ( any ( abs ( l2gp%frequency - &
!           & quantity%template%frequencies ) > fTol ) ) &
!           & call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & 'Quantity and l2gp have different frequency grids' )
!       end if
d5753 1
a5753 1
      logical :: MYLOGSPACE             ! Interpolate in log space?
d5775 2
a5776 2
      myLogSpace = quantity%template%logBasis
      if ( present ( logSpace ) ) myLogSpace = logSpace
d7221 3
@


2.84
log
@Revise calls to trace_begin and trace_end
@
text
@d361 3
a363 2
        call output ( " no code for " )
        call display_string ( field_indices(extraInfo(i)), advance='yes' )
d7072 1
a7072 1
       "$Id: FillUtils_1.f90,v 2.83 2013/08/20 00:33:40 pwagner Exp $"
d7084 3
@


2.83
log
@Avoid more crashes caused by non-Aura l1boa data
@
text
@d73 1
a73 2
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, &
    & MLSMESSAGECALLS
d92 1
a92 2
  use TREE, only: DECORATION, SUBTREE, NSONS, &
    & SOURCE_REF, SUBTREE
d105 1
d107 2
a108 1
  character (len=*), private, parameter :: ModuleName= "$RCSfile: FillUtils_1.f90,v $"
d207 2
a208 2
    ! ------------------------------------------- addGaussianNoise ---
    subroutine addGaussianNoise ( key, quantity, sourceQuantity, &
d220 1
a220 1
      real, dimension(:), intent(in) ::           multiplier
d227 1
d230 2
a231 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.addGaussianNoise', key )
d281 3
a283 3
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.addGaussianNoise' )
    end subroutine addGaussianNoise
d439 1
d445 2
a446 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ApplyBaseline', key )
d500 2
a501 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ApplyBaseline' )
d504 1
a504 1
    ! ---------------------------------------------- AutoFillVector -----
d511 1
d518 2
a519 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_begin ( 'FillUtils_1.AutoFillVector' )
d532 2
a533 2
            endif
          endif
d536 2
a537 3
      enddo
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_end ( 'FillUtils_1.AutoFillVector' )
d540 2
a541 2
    ! ------------------------------------- deallocateStuff ---
    subroutine deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
d560 1
a560 1
    !=============================================== Explicit ==
d605 1
d621 2
a622 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.Explicit', valuesNode )
d758 2
a759 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.Explicit' )
d787 1
d791 2
a792 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ComputeTotalPower', key )
d843 2
a844 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ComputeTotalPower' )
d847 1
a847 1
    ! ------------------------------------------- ExtractSingleChannel ---
d857 1
d860 2
a861 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ExtractSingleChannel', key )
d878 2
a879 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ExtractSingleChannel' )
d882 1
a882 1
    ! ------------------------------------------- ChiSqChan ---
d912 1
d919 2
a920 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ChiSqChan', key )
d1015 2
a1016 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ChiSqChan' )
d1019 1
a1019 1
    ! ------------------------------------------- ChiSqMMaf ---
a1045 1
      integer ::                             ROW         ! Running 1st coord
d1047 1
d1049 1
d1055 2
a1056 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ChiSqMMaf', key )
d1158 3
a1160 4
      call deallocate_test(values, &
        & 'chi^2 unsummed', ModuleName)
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ChiSqMMaf', key )
d1163 1
a1163 1
    ! ------------------------------------------- ChiSqMMif ---
d1192 1
a1192 1
      integer ::                             QINDEX
d1195 1
d1201 2
a1202 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ChiSqMMif', key )
d1222 1
a1222 1
      elseif ( .not. ValidateVectorQuantity ( qty, &
d1297 2
a1298 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ChiSqMMif' )
d1301 1
a1301 1
    ! ------------------------------------------- ChiSqRatio ---
d1339 2
a1341 1
      integer ::                             NOCHANS
d1346 2
a1347 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ChiSqRatio', key )
d1430 2
a1431 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ChiSqRatio' )
d1467 1
d1475 1
a1475 1
      real (r8) :: DELTAZETA      ! Zetai[s+1] - Zetai[s]
d1489 2
a1490 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ColAbundance', key )
d1684 2
a1685 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ColAbundance' )
d1688 1
a1688 1
    ! -------------------------------------------- ConvergenceFromChisq --------
d1697 1
d1700 2
a1701 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ConvergenceFromChisq', key )
d1708 1
a1708 1
      endif
d1715 2
a1716 3
      endif
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ConvergenceFromChisq' )
d1719 1
a1719 1
    !------------------------------------- FillCovariance ------------
d1745 1
d1758 2
a1759 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FillCovariance' )
d1894 2
a1895 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FillCovariance' )
d1899 1
a1899 1
    !------------------------------------- DerivativeOfSource ------------
d1966 1
d1970 2
a1971 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FoldedRadiance', key )
d2017 2
a2018 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FoldedRadiance' )
d2134 1
d2143 2
a2144 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromSplitSideband', key )
d2311 2
a2312 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromSplitSideband' )
d2315 1
a2315 1
    ! ------------------------------------- GPHPrecision ----
d2327 1
d2330 2
a2331 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.GPHPrecision', key )
d2355 2
a2356 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end( 'FillUtils_1.GPHPrecision' )
d2360 2
a2361 3
      ! ------------------------------------- IWCFromExtinction ----
    subroutine IWCFromExtinction ( quantity, &
     & sourceQuantity, temperatureQuantity)
d2375 1
d2377 2
a2378 3
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_begin ( 'FillUtils_1.IWCFromExtinction' )
      call MLSMessageCalls( 'push', constantName='IWCFromExtinction' )
d2431 2
a2432 3
      call MLSMessageCalls( 'pop' )
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_end ( 'FillUtils_1.IWCFromExtinction' )
d2436 2
a2437 2
    ! ------------------------------------------- LOSVelocity ---
    subroutine LOSVelocity ( key, qty, tngtECI, scECI, scVel)
d2448 2
a2449 2
      integer :: MAF                      ! Loop counter
      integer :: MIF                      ! Loop counter
d2458 2
a2459 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.LOSVelocity', key )
d2486 28
a2513 8
      ! Don't wast any effort if the values are all still zero
      if ( all(tngtECI%values == 0._rv) ) then
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_end ( 'FillUtils_1.LOSVelocity' )
        return
      endif
      noMAFs = qty%template%noInstances
      noMIFs = qty%template%noSurfs
d2515 2
a2516 2
      do maf = 1, noMAFs
        do mif = 1, noMIFs
d2518 3
a2520 26
          ! First compute the tangent point velocity in ECI coordinates due
          ! to the rotation of the earth.  This no doubt makes approximations
          ! due to the slight non alignment between the earth's rotation axis and
          ! the ECI z axis, but I'm going to ignore this.

          ! Work out the indices in 3*mif,maf space
          x = 1 + 3*(mif-1)
          y = x+1
          z = x+2

          tngtVel= omega* (/ -tngtECI%values(y,maf), &
            &                 tngtECI%values(x,maf), 0.0_r8 /)

          ! Now compute the line of sight direction normal
          los = tngtECI%values(x:z,maf) - scECI%values(x:z,maf)
          los = los / sqrt(sum(los**2))

          ! Now compute the net velocity in this direction.  For the moment I'll
          ! assume +ve means the sc and tp are moving apart, and -ve that they're
          ! getting closer.

          qty%values(mif,maf) = dot_product(tngtVel, los) - &
            &                   dot_product(scVel%values(x:z,maf), los)

          ! Note that even though x,y,z have been used up to now for a GHz/THz
          ! minor frame quantity, they're OK with this sc one too.
d2522 3
a2524 3
      end do
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.LOSVelocity' )
d2527 1
a2527 1
    ! ------------------------------------- NoRadsPerMIF -----
a2546 2
      integer  :: possible
      integer  :: MIF, MAF               ! Loop counters
d2548 2
d2551 1
d2554 2
a2555 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.NoRadsPerMif', key )
d2582 2
a2583 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.NoRadsPerMif' )
d2586 1
a2586 1
    ! ------------------------------------ PhiTanWithRefraction --
d2608 2
a2609 1
      integer :: I, J ! Subscripts, loop inductors
d2612 2
a2613 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.PhiTanWithRefraction', key )
      call MLSMessageCalls( 'push', constantName='PhiTanWithRefraction' )
d2688 2
a2689 3
      call MLSMessageCalls( 'pop' )
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.PhiTanWithRefraction' )
a2735 2
      integer ::                          QINDEX
      integer ::                          N           ! Num. of summed values
d2742 3
d2766 2
a2767 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.RHIFromOrToH2O', key )
      call MLSMessageCalls( 'push', constantName='RHIFromOrToH2O' )
d2970 2
a2971 3
      call MLSMessageCalls( 'pop' )
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.RHIFromOrToH2O' )
d2974 1
a2974 1
    ! ------------------------------------- RHIPrecisionFromOrToH2O ----
d3038 1
d3067 2
a3068 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.RHIPrecisionFromOrToH2O', key )
      call MLSMessageCalls( 'push', constantName='RHIPrecisionFromOrToH2O' )
d3344 2
a3345 3
      call MLSMessageCalls( 'pop' )
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.RHIPrecisionFromOrToH2O' )
d3348 1
a3348 1
    ! ----------------------------------- FromASCIIFile --------
d3359 1
d3363 2
a3364 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromAsciiFile', key )
d3395 2
a3396 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromAsciiFile' )
d3399 1
a3399 1
    ! ------------------------------------------- FromInterpolatedQty
d3413 2
a3415 1
      integer :: instance
d3421 2
a3422 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromInterpolatedQty', key )
      call MLSMessageCalls( 'push', constantName='FromInterpolatedQty' )
d3588 2
a3589 3
      call MLSMessageCalls( 'pop' )
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromInterpolatedQty' )
d3617 1
d3629 2
a3630 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromLosGrid', key )
d3760 2
a3761 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromLosGrid' )
d3765 1
a3765 1
    ! --------------------------------------------- ByManipulation ---
d3812 2
a3813 1
      integer :: NUMWAYS ! 1 or 2
d3819 2
a3820 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ByManipulation', key )
      call MLSMessageCalls( 'push', constantName='ByManipulation' )
d3908 2
a3909 3
      call MLSMessageCalls( 'pop' )
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ByManipulation' )
d3913 1
a3913 1
    ! ----------------------------------------- FromL1B ----
d3951 2
a3952 1
      integer                               :: ROW, COLUMN
d3954 1
a3954 1

d3956 2
a3957 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromL1B', root )
d4195 2
a4196 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromL1B' )
d4199 1
a4199 1
    ! ------------------------------------------- FromL2AUX --
d4207 1
d4209 2
a4210 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromL2AUX' )
d4239 2
a4240 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromL2AUX' )
d4243 1
a4243 1
    ! --------------------------------------- UsingMagneticModel --
d4253 1
d4256 2
a4257 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.UsingMagneticModel', key )
d4287 1
a4287 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.UsingMagneticModel' )
d4291 1
a4291 1
    ! ------------------------------------- Hydrostatically ----
d4296 1
a4296 1
    use MANIPULATEVECTORQUANTITIES, only: FINDCLOSESTINSTANCES
d4315 1
d4321 2
a4322 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.Hydrostatically', key )
d4398 2
a4399 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.Hydrostatically' )
d4410 2
a4411 4
    ! -------------------------------------- FromIsotope -----------

    subroutine FromIsotope ( quantity, sourceQuantity, &
              & ratioQuantity )
d4421 1
d4424 2
a4425 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromIsotope' )
d4465 2
a4466 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromIsotope' )
d4470 2
a4471 3
    ! ---------------------------------- WithEstdNoise ---
    subroutine WithEstNoise ( quantity, radiance, &
      & sysTemp, nbw, integrationTime )
d4482 2
a4484 1
      integer :: I                        ! Index into first dimension of values
d4489 2
a4490 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.WithEstNoise' )
d4545 2
a4546 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.WithEstNoise' )
d4550 1
a4550 1
    ! ----------------------------------------- WithReflectorTemperature ---
d4559 1
d4564 2
a4565 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.WithReflectorTemperature', key )
d4589 1
a4589 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.WithReflectorTemperature' )
d4593 1
a4593 1
    ! ----------------------------------------- WithReichlerWMOTP -------------
d4604 1
d4606 5
a4610 2
      integer :: instance
      integer :: invert
d4612 8
a4619 8
      integer :: nlev
      integer :: nvalid
      real, dimension( size(temperature%values, 1) ) :: p ! Pa
      real, parameter :: pliml = 65.*100 ! in Pa
      real, parameter :: plimlex = 65.*100 ! in Pa
      real, parameter :: plimu = 550.*100 ! in Pa
      real, dimension( size(temperature%values, 1) ) :: t
      real :: trp
a4620 1
      logical :: alreadyDumped
d4622 1
d4624 3
a4626 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.WithReichlerWMOTP' )
d4710 2
a4711 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.WithReichlerWMOTP' )
d4714 1
a4714 1
    ! ----------------------------------------- WithWMOTropopause ------
d4729 1
d4731 3
a4734 1
      integer :: LOWCANDIDATE           ! Possbile tb but below 500hPa
a4735 2
      integer :: S0                     ! Surface to start looking from
      integer :: DS                     ! No. surfs less than 2km above s
d4773 2
a4774 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.WithWMOTropopause' )
      call MLSMessageCalls( 'push', constantName='WithWMOTropopause' )
d4858 2
a4859 3
      call MLSMessageCalls( 'pop' )
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.WithWMOTropopause' )
d4862 1
a4862 1
    ! -------------------------------------------- QualityFromChisq --------
d4875 1
d4877 3
d4882 1
a4882 2
      real(r8) :: HEIGHT                ! The height to consider
      integer :: SURFACE                ! Surface index
d4884 2
a4885 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.QualityFromChisq', key )
      call MLSMessageCalls( 'push', constantName='QualityFromChisq' )
d4894 1
a4894 1
      endif
d4912 2
a4913 3
      call MLSMessageCalls( 'pop' )
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.QualityFromChisq' )
d4916 1
a4916 1
    ! -------------------------------------------- StatusQuantity --------
d4930 1
d4933 1
d4937 1
d4939 2
a4940 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.StatusQuantity', key )
      call MLSMessageCalls( 'push', constantName='StatusQuantity' )
d4986 4
a4989 5
        endif
      endif
      call MLSMessageCalls( 'pop' )
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.StatusQuantity' )
d4992 3
a4994 3
    ! ------------------------------------------ UsingLeastSquares -----
    subroutine UsingLeastSquares  ( key, Quantity, SourceQuantity, ptanQuantity, &
      & channel, method, scaleInstances, scaleRatio, scaleSurfs )
d5018 1
d5024 2
a5025 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.UsingLeastSquares', key )
d5170 2
a5171 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.UsingLeastSquares' )
d5175 1
a5175 1
    !=============================== FromGrid ============
d5189 1
d5193 2
a5194 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromGrid' )
d5269 2
a5270 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromGrid' )
d5273 1
a5273 1
    !=============================== FromL2GP ==========
d5296 1
a5296 1
      integer ::    FIRSTPROFILE, LASTPROFILE
d5299 1
d5305 2
a5306 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromL2GP' )
      call MLSMessageCalls( 'push', constantName='FromL2GP' )
d5440 2
a5441 3
      call MLSMessageCalls( 'pop' )
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromL2GP' )
d5445 1
a5445 1
    ! -------------------------------------- FromProfile --
d5467 1
d5478 2
a5479 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromProfile_values', instancesNode )
      call MLSMessageCalls( 'push', constantName='FromProfile_values' )
d5593 2
a5594 3
      call MLSMessageCalls( 'pop' )
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromProfile_values' )
d5597 1
d5619 2
a5620 1
      integer, dimension(2) :: EXPRUNIT   ! Unit for expression
d5623 2
a5624 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.FromProfile_node', instancesNode )
      call MLSMessageCalls( 'push', constantName='FromProfile_node' )
d5669 1
a5669 1
      & instancesNode, globalUnit, ptan, logSpace )
d5672 2
a5673 3
      call MLSMessageCalls( 'pop' )
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.FromProfile_node' )
d5676 1
a5676 1
    ! ---------------------------------------------- ManipulateVectors -----
d5692 1
d5698 2
a5699 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ManipulateVectors' )
d5730 2
a5731 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ManipulateVectors' )
d5734 1
a5734 1
    ! -------------------------------------------- WithBinResults -----
d5758 1
d5765 2
a5766 3
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.WithBinResults', key )
      call MLSMessageCalls( 'push', constantName='WithBinResults' )
d5987 2
a5988 3
    9 call MLSMessageCalls( 'pop' )
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.WithBinResults' )
d5991 1
a5991 1
    ! --------------------------------------------- WithBoxcarFunction  ----
d6000 1
d6004 1
d6008 2
a6009 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.WithBoxcarFunction', key )
d6054 1
a6054 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.WithBoxcarFunction' )
d6058 1
a6058 1
    ! ----------------------------------------- offsetradiancequantity -----
d6064 2
d6067 2
a6068 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_begin ( 'FillUtils_1.OffsetRadianceQuantity' )
d6086 1
a6086 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_end ( 'FillUtils_1.OffsetRadianceQuantity' )
d6089 1
a6089 1
    ! ---------------------------------------------- ResetUnusedRadiances --
d6093 3
d6097 2
a6098 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_begin ( 'FillUtils_1.ResetUnusedRadiances' )
d6106 1
a6106 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_end ( 'FillUtils_1.ResetUnusedRadiances' )
d6109 1
a6109 1
    ! --------------------------------------------- RotateMagneticField ----
d6119 1
d6125 2
a6126 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.RotateMagneticField', key )
d6180 2
a6181 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.RotateMagneticField' )
d6185 1
a6185 1
    ! ---------------------------------------------- ScaleOverlaps -------
d6193 1
d6196 2
a6197 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.ScaleOverlaps', multiplierNode )
d6238 2
a6239 2
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.ScaleOverlaps' )
d6242 1
a6242 1
    ! ----------------------------------------- SpreadChannelFill --------
d6254 1
d6259 2
a6260 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.SpreadChannelFill', key )
d6295 2
a6296 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.SpreadChannelFill' )
d6299 1
a6299 1
    ! ---------------------------------------------- TransferVectors -----
d6317 1
d6325 2
a6326 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_begin ( 'FillUtils_1.TransferVectors' )
d6340 2
a6341 2
        endif
      endif
d6374 2
a6375 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_end ( 'FillUtils_1.TransferVectors' )
d6378 1
a6378 1
    ! ---------------------------------------------- TransferVectorsByMethod -----
d6422 4
a6425 3
      type (VectorValue_T), pointer :: SQ ! Source or meas quantity
      integer                       :: SQI                      ! Quantity index in source or meas
      type (VectorValue_T), pointer :: MQ ! Model quantity
d6430 1
a6430 1
      type (VectorValue_T), pointer :: NQ ! Noise quantity
d6437 1
d6439 2
a6440 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_begin ( 'FillUtils_1.TransferVectorsByMethod' )
d6548 2
a6549 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_end ( 'FillUtils_1.TransferVectorsByMethod' )
d6552 1
a6552 1
    ! ---------------------------------------------- UncompressRadiance -----
d6568 1
d6572 1
a6572 1
      integer, DIMENSION(2) :: UNITASARRAY ! Unit for value given
d6580 2
a6581 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.UncompressRadiance', key )
d6647 2
a6648 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.UncompressRadiance' )
d6652 1
a6652 1
    ! ------------------------------------------- QtyFromFile ----------
d6664 1
d6670 1
d6673 1
d6675 2
a6676 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.QtyFromFile', key )
d6700 2
a6701 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.QtyFromFile' )
d6704 1
a6704 1
    ! ------------------------------------------- VectorFromFile ----------
d6715 1
d6720 1
d6728 1
d6730 2
a6731 2
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_begin ( 'FillUtils_1.VectorFromFile', key )
d6750 1
a6750 1
            endif
d6759 1
a6759 1
            endif
d6771 1
a6771 1
          endif
d6775 4
a6778 4
        enddo
      enddo
      if ( toggle(gen) .and. levels(gen) > 1 ) &
        & call trace_end ( 'FillUtils_1.VectorFromFile' )
d6781 1
a6781 1
  ! -- Private procedures ----------
d6783 1
a6783 1
    ! ------------------------------------------- FillableChiSq ---
d6809 3
a6811 2
     ! Local variables
      logical ::       minorFrame   ! TRUE if radiances, FALSE if vmr
d6813 2
a6814 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_begin ( 'FillUtils_1.FillableChiSq' )
d6890 2
a6891 2
    9 if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_end ( 'FillUtils_1.FillableChiSq' )
d6894 1
a6894 1
    ! ------------------------------------------- NamedQtyFromFile ----------
d6906 1
d6914 2
a6915 1
      type( l2GPData_T ) :: l2gp ! Result
d6922 1
d6924 2
a6925 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_begin ( 'FillUtils_1.NamedQtyFromFile', key )
d7001 3
a7003 2
      if ( toggle(gen) .and. levels(gen) > 2 ) &
        & call trace_end ( 'FillUtils_1.NamedQtyFromFile' )
d7005 2
a7006 1
      subroutine FillMyInstances( values1, values2 )
d7071 1
a7071 1
       "$Id: FillUtils_1.f90,v 2.82 2013/08/16 02:50:42 vsnyder Exp $"
d7083 3
@


2.82
log
@Add MAF and SpacingOnly arguments to UsingMagneticModel
@
text
@d72 1
a72 1
  use MLSL2OPTIONS, only: L2CFNODE, MLSMESSAGE
d285 2
a286 1
    subroutine ANNOUNCE_ERROR ( WHERE, CODE, EXTRAMESSAGE, EXTRAINFO, QUITNOW )
d293 1
d416 1
d2453 3
a2455 2
        & frequencyCoordinate=(/l_none/) ) ) call Announce_Error ( key, No_Error_Code, &
        & 'Quantity to fill is not a valid LOS Velocity' )
d2459 3
a2461 2
        & frequencyCoordinate=(/l_xyz/) ) ) call Announce_Error ( key, No_Error_Code, &
        & 'Tangent ECI quantity is not of an appropriate form' )
d2465 3
a2467 2
        & frequencyCoordinate=(/l_xyz/) ) ) call Announce_Error ( key, No_Error_Code, &
        & 'Spacecraft ECI quantity is not of an approriate form' )
d2475 6
d4060 6
d7034 1
a7034 1
       "$Id: FillUtils_1.f90,v 2.81 2013/08/13 02:23:06 vsnyder Exp $"
d7046 3
@


2.81
log
@Move magnetic field stuff to Magnetic_Field_Quantity
@
text
@d4218 1
a4218 1
    subroutine UsingMagneticModel ( qty, gphQty, key )
d4223 4
d4232 1
d4236 2
a4237 2
          & 'Quantity does not describe magnetic field' )
        go to 9
d4243 1
a4243 1
        go to 9
d4245 6
a4250 4
      if ( .not. DoHGridsMatch ( qty, gphQty ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Quantity and GPHQuanity do not share the same horizontal basis' )
        go to 9
d4254 2
a4255 2
          & 'Quantity and GPHQuantity do not share the same vertical basis' )
        go to 9
d4258 1
a4258 1
      call get_Magnetic_Field_Quantity ( qty, GPHQty )
d4260 1
a4260 1
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
d7016 1
a7016 1
       "$Id: FillUtils_1.f90,v 2.80 2013/08/12 23:49:41 pwagner Exp $"
d7028 3
@


2.80
log
@FindSomethings moved to MLSFinds module
@
text
@d85 1
a85 1
  use QUANTITYTEMPLATES, only: EPOCH, QUANTITYTEMPLATE_T
d4219 1
a4219 2
      use Geometry, only: SECPERYEAR
      use IGRF_INT, only: FELDC, FELDCOF, TO_CART
a4222 8
      ! Local variables
      real :: B(3)                      ! Magnetic field
      integer, save :: Details = -10    ! From switchDetails('mag')
      integer :: INSTANCE               ! Loop counter
      character(len=8) :: options
      integer :: SURF                   ! Loop counter
      integer :: SURFOR1                ! Index
      real    :: XYZ(3)                 ! lat, lon, height for to_cart
d4227 1
a4227 2
      options = ' '
      if ( switchDetail(switches,'clean') > -1 ) options = '-c'
d4251 1
a4251 2
      ! Assume the time is close enough to constant that one call to
      ! FELDCOF is accurate enough.
a4252 23
      call feldcof ( real(qty%template%time(1,1)/secPerYear + epoch) )

      do instance = 1, qty%template%noInstances
        do surf = 1, qty%template%noSurfs
          if ( qty%template%stacked ) then
            surfOr1 = 1
          else
            surfOr1 = surf
          end if
          ! Convert (/ lat(deg), lon(deg), height(km) /) to cartesian (e-radius)
          call to_cart ( real( (/ qty%template%geodLat(surfOr1,instance), &
            &                     qty%template%lon(surfOr1,instance), &
            &                     gphQty%values(surf,instance)*1.0e-3 /) ), xyz )
          ! Compute the field at and w.r.t. cartesian coordinates.  The first
          ! dimension of value3 is field components, not channels.
          call feldc ( xyz, b )
!3          qty%values ( surf*3-2 : surf*3, instance) = b
          qty%value3 ( 1:3, surf, instance) = b
        end do
      end do

      if ( details < -1 ) details = switchDetail(switches,'mag') ! only once
      if ( details > -1 ) call dump ( qty, details=details, options=options )
d7009 1
a7009 1
       "$Id: FillUtils_1.f90,v 2.79 2013/07/18 01:10:57 vsnyder Exp $"
d7021 3
@


2.79
log
@Remove scVel since it's ambiguous whether it's ECI or ECR, and nobody
uses it anyway.
@
text
@d77 1
a77 1
  use MLSSETS, only: FINDFIRST, FINDLAST
d7043 1
a7043 1
       "$Id: FillUtils_1.f90,v 2.78 2013/06/29 00:18:04 pwagner Exp $"
d7055 4
@


2.78
log
@Changed switch to dump l1b fills to -Sl1bfill
@
text
@d46 1
a46 1
    & L_SCECI, L_SCGEOCALT, L_SCVEL, L_SCVELECI, L_SCVELECR, &
a3982 2
      case ( l_scVel )
        nameString = AssembleL1BQtyName('Vel', L1BOAFile%HDFVersion, .FALSE., 'sc')
d7043 1
a7043 1
       "$Id: FillUtils_1.f90,v 2.77 2013/05/31 00:42:12 vsnyder Exp $"
d7055 3
@


2.77
log
@Add geolocation field to fill, used only if method=l1b
@
text
@d3909 2
a3910 2
    subroutine FromL1B ( root, quantity, chunk, filedatabase, &
      & isPrecision, suffix, Geolocation, PrecisionQuantity, BOMask )
d3912 2
a3913 2
      use Init_Tables_Module, only: L_Geocentric, L_Geodetic, L_None
      integer, intent(in) :: root
d3919 1
a3919 1
      integer, intent(in)                        :: Geolocation
d3921 1
a3921 1
      integer, intent(in), optional :: BOMask ! A pattern of bits--
d4170 1
a4170 1
      if ( switchDetail(switches, 'l1b') > -1 ) call Dump( l1bData )
d7045 1
a7045 1
       "$Id: FillUtils_1.f90,v 2.76 2013/05/22 20:09:50 pwagner Exp $"
d7057 3
@


2.76
log
@Print only if verboser
@
text
@d3910 1
a3910 1
      & isPrecision, suffix, PrecisionQuantity, BOMask )
d3912 1
d3914 4
a3917 4
      type (VectorValue_T), INTENT(INOUT) ::        QUANTITY
      type (MLSChunk_T), INTENT(IN) ::              CHUNK
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      logical, intent(in)               ::          ISPRECISION
d3919 1
d4139 31
d4228 1
d4279 2
a4280 1
          ! Compute the field at and w.r.t. cartesian coordinates
d4282 2
a4283 1
          qty%values ( surf*3-2 : surf*3, instance) = b
d4287 2
a4288 2
      if ( switchDetail(switches,'mag') > -1 ) &
        & call dump ( qty, options=options )
d7045 1
a7045 1
       "$Id: FillUtils_1.f90,v 2.75 2013/05/21 01:47:34 vsnyder Exp $"
d7057 3
@


2.75
log
@Don't look at QUITNOW until you're sure it's there
@
text
@d6308 1
a6308 1
        call output( 'Transferring quantities named ' // trim(qName), advance='yes' )
d6347 1
a6347 1
    use MLSSTRINGLISTS, only: GETHASHELEMENT
d6349 3
d6381 1
d6392 2
d6433 5
d7009 1
a7009 1
       "$Id: FillUtils_1.f90,v 2.74 2013/05/17 00:52:01 pwagner Exp $"
d7021 3
@


2.74
log
@May constrain Transfer command command to quantitynames by r/t Boolean; r/t sep now achar(0)
@
text
@d414 5
a418 3
      if ( QUITNOW ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & trim(extraMessage) )
d6998 1
a6998 1
       "$Id: FillUtils_1.f90,v 2.73 2013/04/05 23:20:47 pwagner Exp $"
d7010 3
@


2.73
log
@Requires verbose settings for extra printing
@
text
@d5636 4
a5639 1
    subroutine ManipulateVectors ( manipulation, dest, a, b, c )
d5642 4
a5645 3
      type (Vector_T), intent(in) :: A, B
      type (Vector_T), intent(inout) :: DEST
      real(rv), optional            :: C  ! constant "c" in manipulation
d5648 6
a5653 3
      type (VectorValue_T), pointer :: DQ ! Destination quantity
      type (VectorValue_T), pointer :: AQ, BQ ! Source quantities
      integer :: SQI                      ! Quantity index in source
d5658 9
a5666 1

d5674 5
a5678 1
        if ( all( (/ associated(aq), associated(bq), associated(dq) /) ) ) then
d6252 7
a6258 1
    subroutine TransferVectors ( source, dest, skipMask, interpolate )
d6264 1
d6269 3
d6273 1
d6278 15
d6300 14
a6313 9
        if ( associated ( dq ) ) then
          dq%values = sq%values
          if ( .not. skipMask ) then
            if ( associated(sq%mask) ) then
              if ( .not. associated(dq%mask)) call CreateMask ( dq )
              dq%mask = sq%mask
            else
              call destroyVectorQuantityMask ( dq )
            end if
d6343 4
a6346 1
      & NOISEVECTOR, PTAN )
d6359 1
d6373 3
d6386 9
d6422 5
d6996 1
a6996 1
       "$Id: FillUtils_1.f90,v 2.72 2013/02/01 23:42:25 vsnyder Exp $"
d7008 3
@


2.72
log
@Use CreateVectorValue instead of Allocate_Test
@
text
@d3395 1
d3398 1
d3477 2
a3478 1
          if ( any( (/ source%values <= 0. /) ) ) then
d3480 2
a3481 1
              & 'source values <= 0 in FromInterpolateQty', status=status )
d4261 1
d4279 2
d4283 1
d4364 8
a4371 1

d6925 1
a6925 1
       "$Id: FillUtils_1.f90,v 2.71 2013/01/14 21:22:51 pwagner Exp $"
d6937 3
@


2.71
log
@Changed chiSqRatio when skipped to 999
@
text
@d3382 1
d3494 5
a3498 3
              if ( associated(qty%values) ) then
                if ( any(shape(ptan%values) /= shape(qty%values)) ) &
                  & call deallocate_test ( qty%values, 'qty%values', moduleName )
d3501 1
a3501 2
                & call allocate_test ( qty%values, size(ptan%values,1), &
                  & size(ptan%values,2), 'qty%values', moduleName )
d6910 1
a6910 1
       "$Id: FillUtils_1.f90,v 2.70 2013/01/02 21:41:31 pwagner Exp $"
d6922 3
@


2.70
log
@Added derivative method to Fill command; Transfer can do Fill methods, too
@
text
@d1404 3
a1406 1
        if ( UNIFORMCHISQRATIO .or. &
a1705 1

d6908 1
a6908 1
       "$Id: FillUtils_1.f90,v 2.69 2012/12/20 01:05:26 vsnyder Exp $"
d6920 3
@


2.69
log
@Provide coherent-to-minor frame interpolation
@
text
@d25 2
a26 2
    & L_BASELINE, L_BINMAX, L_BINMEAN, L_BINMIN, L_BINTOTAL, &
    & L_BOUNDARYPRESSURE, L_CHISQBINNED, L_CHISQCHAN, &
d28 1
a28 1
    & L_CLOUDINDUCEDRADIANCE, &
d38 1
a38 1
    & L_LSLOCAL, L_LSWEIGHTED, &
d41 1
a41 1
    & L_NOISEBANDWIDTH, L_NONE, &
d72 1
a72 1
  use MLSL2OPTIONS, only: MLSMESSAGE
d96 3
a98 2
    & CLEARUNDERMASK, COPYVECTOR, CREATEMASK, &
    & DESTROYVECTORINFO, DESTROYVECTORQUANTITYMASK, DUMP, &
d181 1
a181 1
      & COLABUNDANCE, FOLDEDRADIANCE, PHITANWITHREFRACTION, &
d194 3
a196 1
      & SCALEOVERLAPS, SPREADCHANNELFILL, TRANSFERVECTORS, UNCOMPRESSRADIANCE, &
d285 1
a285 1
    subroutine ANNOUNCE_ERROR ( where, CODE, ExtraMessage, ExtraInfo )
d289 1
a289 1
      integer, intent(in) :: where   ! Tree node where error was noticed
d291 3
a293 2
      character (LEN=*), intent(in), optional :: ExtraMessage
      integer, intent(in), dimension(:), optional :: ExtraInfo
d414 3
d1883 54
d3582 1
a3582 1
      type (VectorValue_T), INTENT(INOUT) :: QTY ! Quantity to fill
d5718 6
a5723 2
        if ( sourceQuantity%template%verticalCoordinate /= quantity%template%verticalCoordinate ) &
          & call Announce_Error ( key, no_error_code, &
d5725 1
d5908 2
a5909 2
      call MLSMessageCalls( 'pop' )
    9 if ( toggle(gen) .and. levels(gen) > 1 ) &
d6261 140
d6907 1
a6907 1
       "$Id: FillUtils_1.f90,v 2.68 2012/11/14 00:59:23 pwagner Exp $"
d6919 3
@


2.68
log
@Use dimList for choosing which of {csi} to average over
@
text
@d3319 1
d3425 37
a3461 11
        elseif( qty%template%noInstances /= qty%template%noInstances ) then
          ! You have elected to interpolate 1-d instead of 2-d
          ! when you have different numbers of horizontal instances
          ! The only reasonable thing is to assume homogeneity
          call InterpolateValues ( &
            & oldSurfs, source%values(:,1), &
            & newSurfs, newValues(:,1), &
            & method='Linear', extrapolate='Constant' )
          do instance=2, qty%template%noInstances
            newValues(:,instance) = newValues(:,1)
          enddo
d6701 1
a6701 1
       "$Id: FillUtils_1.f90,v 2.67 2012/11/08 23:21:51 pwagner Exp $"
d6713 3
@


2.67
log
@dimList field lets us specifiy whether to shift by [c,s,i] during manipulate
@
text
@d3652 1
a3652 1
      & spreadflag, dontSumHeights, dontSumInstances, dimList, &
a3663 2
      logical, intent(in) :: DONTSUMHEIGHTS
      logical, intent(in) :: DONTSUMINSTANCES
d3715 1
a3715 1
        &   (/ 'min   ', 'max   ', 'mean  ', 'median', 'rms   ', 'stddev' /) &
d3790 1
a3790 1
          & spreadflag, dontsumheights, dontsuminstances, dimList )
d5556 1
a5556 2
            & ignoreTemplate=.true., spreadflag=.false., dontSumHeights=.true., &
            & dontSumInstances=.true., dimList=' ', &
d6674 1
a6674 1
       "$Id: FillUtils_1.f90,v 2.66 2012/11/05 19:04:28 pwagner Exp $"
d6686 3
@


2.66
log
@Most Fill methods need not handle dontMask themselves
@
text
@d3652 1
a3652 1
      & spreadflag, dontSumHeights, dontSumInstances, &
d3666 1
d3792 1
a3792 1
          & spreadflag, dontsumheights, dontsuminstances )
d5559 1
a5559 1
            & dontSumInstances=.true., &
d6677 1
a6677 1
       "$Id: FillUtils_1.f90,v 2.65 2012/10/22 18:15:47 pwagner Exp $"
d6689 3
@


2.65
log
@Many Subset operations now available in Fill
@
text
@d548 1
a548 1
      & globalUnit, dontmask, channel, AzEl, options, FillValue, extraQuantity )
a567 1
      logical, intent(in) :: DONTMASK     ! Don't bother with the mask
d712 1
a712 1
            if ( .not. dontMask .and. associated ( quantity%mask ) ) then
d1960 1
a1960 1
      & key, ignoreTemplate, spreadflag, dontMask, interpolate, force )
a1966 1
      logical, intent(in) :: DONTMASK ! If set throw caution to the wind
d1977 1
a1977 1
          & key, dontMask, ignoreTemplate, ptan )
d1984 1
a1984 1
            & key, dontMask, ignoreTemplate )
d1991 1
a1991 1
          if ( associated(quantity%mask) .and. .not. dontMask ) then
d2005 1
a2005 1
          if ( associated(quantity%mask) .and. .not. dontMask ) then
d2019 1
a2019 1
          if ( associated(quantity%mask) .and. .not. dontMask ) then
d2030 1
a2030 1
        if ( associated(quantity%mask) .and. .not. dontMask ) then
a2832 5
            ! if ( .not. interpolate ) then
             ! skipMe = skipMe .or. &
             ! & .not. dontMask .and. &
             ! &   isVectorQtyMasked(Quantity, qIndex, i)
            ! end if
a3200 5
            ! if ( .not. interpolate ) then
            !  skipMe = skipMe .or. &
            !  & .not. dontMask .and. &
            !  &   isVectorQtyMasked(Quantity, qIndex, i)
            ! end if
d3318 1
a3318 1
      & DONTMASK, ignoreTemplate, ptan )
a3321 1
      logical, intent(in) :: DONTMASK
d3464 1
a3464 1
        if ( associated(qty%mask) .and. .not. dontMask ) then
d5300 1
a5300 1
      & instancesNode, globalUnit, dontMask, ptan, logSpace )
a5307 1
      logical, intent(in) :: DONTMASK     ! If set don't follow the fill mask
d5426 1
a5426 1
              if ( associated(quantity%mask) .and. .not. dontMask ) then
d5452 1
a5452 1
      & instancesNode, globalUnit, dontMask, ptan, logSpace )
a5459 1
      logical, intent(in) :: DONTMASK     ! If set don't follow the fill mask
d5522 1
a5522 1
      & instancesNode, globalUnit, dontMask, ptan, logSpace )
d6012 1
a6012 1
    subroutine ScaleOverlaps ( quantity, multiplierNode, dontMask )
a6014 1
      logical :: DONTMASK               ! Flag
d6033 1
a6033 1
        if ( associated ( quantity%mask ) .and. .not. dontMask ) then
d6055 1
a6055 1
        if ( associated ( quantity%mask ) .and. .not. dontMask ) then
d6068 1
a6068 1
    subroutine SpreadChannelFill ( quantity, channel, dontMask, key, &
a6071 1
      logical, intent(in) :: DONTMASK
d6082 1
a6082 1
      ! Exectuable code
d6090 1
a6090 1
              if ( associated ( quantity%mask ) .and. .not. dontMask ) then
d6110 1
a6110 1
              if ( associated ( quantity%mask ) .and. .not. dontMask ) then
d6162 1
a6162 1
              & dontmask=.false., ignoreTemplate=.false. )
d6196 1
a6196 1
      ! Exectuable code
a6518 1
      logical, parameter :: dontMask = .false.
d6581 1
a6581 1
              & instancesNode, globalUnit, dontMask, ptan )
d6676 1
a6676 1
       "$Id: FillUtils_1.f90,v 2.64 2012/10/09 00:48:31 pwagner Exp $"
d6688 3
@


2.64
log
@New ignoreTemplate, changed force meaning in Fill
@
text
@d80 1
a80 2
  use MLSSTRINGLISTS, only: CATLISTS, EXPANDSTRINGRANGE, &
    & NUMSTRINGELEMENTS, &
d93 1
a93 1
  use TREE, only: NODE_ID, DECORATION, SUBTREE, NSONS, &
a94 2
  use TREE_TYPES, only: N_COLON_LESS, N_LESS_COLON, &
    & N_LESS_COLON_LESS
d200 1
a200 1
  
d548 1
a548 2
      & globalUnit, dontmask, channel, heightNode, instancesNode, &
      & AzEl, options, FillValue, extraQuantity )
d569 1
a569 3
      integer, intent(in) :: CHANNEL      ! Fill specified channel?
      integer, intent(in) :: HEIGHTNODE   ! Fill (at) specified height?
      integer, intent(in) :: INSTANCESNODE   ! Fill (at) specified instances?
a589 3
      logical, dimension(QUANTITY%template%noInstances) :: doThisInstance
      real(r8) :: HEIGHT                ! The height to consider
      character(len=8) :: heightRange   ! 'above', 'below', 'at'
a596 5
      integer :: rangeID
      integer :: s1
      integer :: s2
      integer :: son
      character(len=16) :: str
a597 1
      integer :: surface
a598 2
      integer :: TYPE                   ! Type of value returned by expr
      integer :: UNITS(2)               ! Units returned by expr
a599 1
      real(r8) :: VALUE(2)              ! Value returned by expr
a612 1
      doThisInstance = .true.
a631 6
      heightRange = 'at'
      if ( index(myOptions, 'a') > 0 ) then
        heightRange = 'above'
      elseif ( index(myOptions, 'b') > 0 ) then
        heightRange = 'below'
      end if
d694 1
a694 21
      ! Work out the height
      if ( heightNode /= 0 ) then
        if ( nsons ( heightNode ) /= 2 ) call Announce_Error ( heightNode, no_error_code, &
          & 'Only one height can be supplied for status fill' )
        if ( Quantity%template%verticalCoordinate /= l_zeta ) &
          & call Announce_Error ( heightNode, no_error_code, 'Bad vertical coordinate for sourceQuantity' )
        call expr_check ( subtree(2,heightNode) , unitAsArray, valueAsArray, &
          & (/PHYQ_Pressure/), unitsError )
        if ( unitsError ) call Announce_error ( heightNode, wrongUnits, &
          & extraInfo=(/unitAsArray(1), PHYQ_Pressure/) )
        height = - log10 ( valueAsArray(1) )
        call Hunt ( Quantity%template%surfs(:,1), height, surface, &
          & nearest=.true. )
        if ( verbose ) then
          call outputNamedValue( 'height', height )
          call dump( Quantity%template%surfs(:,1), 'surfs' )
          call outputNamedValue( 'surface', surface )
          call outputNamedValue( 'surfs(surface)', &
            & Quantity%template%surfs(surface, 1) )
        endif
      endif
d701 1
a701 1
        call announce_error ( heightNode, no_Error_Code, &
a703 37
      ! Do we plan doing some instances or all?
      if ( instancesNode /= 0 ) then
        do j = 2, nsons(InstancesNode)
          son = subtree ( j, InstancesNode )
          rangeId = node_id ( son )
          ! 
          call expr ( son, units, value, type )
          if ( any ( units /= phyq_dimensionless ) ) &
            & call Announce_Error ( InstancesNode, no_error_code, &
            & 'No units allowed in instances field during explicit fill' )
          s1 = max ( min ( value(1), &
            & real(quantity%template%noInstances, r8) ), 1._r8 )
          s2 = max ( min ( value(2), &
            & real(quantity%template%noInstances, r8) ), 1._r8 )
          ! Now consider the open range issue
          select case ( rangeId )
          case ( n_colon_less )
            s1 = min ( s1 + 1, quantity%template%noInstances )
          case ( n_less_colon )
            s2 = max ( s2 - 1, 1 )
          case ( n_less_colon_less )
            s1 = min ( s1 + 1, quantity%template%noInstances )
            s2 = max ( s2 - 1, 1 )
          end select
          if ( s1 == s2 ) then
            write( str, '(i5)' ) s1
          else
            write( str, '(i5, a1, i5)' ) s1, '-', s2
          endif
          whichInstances = catLists( whichInstances, str )
        enddo
        call ExpandStringRange( trim(whichInstances), doThisInstance )
        if ( verbose ) then
          call outputNamedValue( 'whichInstances', trim(whichInstances) )
          call dump( doThisInstance )
        endif
      endif
a706 1
        if ( .not. doThisInstance(i) ) cycle
a712 13
            if ( heightNode /= 0 ) then
              select case (heightRange)
              case('above')
              ! Fill only surfs above supplied height
                if ( surf < surface ) cycle
              case('below')
              ! Fill only surfs below supplied height
                if ( surf > surface ) cycle
              case('at')
              ! Fill only surfs at supplied height
                if ( surface /= surf ) cycle
              end select
            endif
d739 5
a743 2
      ! Tidy up
      if ( .not. present(extraQuantity) ) call Deallocate_test ( values, 'values', ModuleName )
d1954 6
d4732 4
d4742 1
a4742 1
      integer, intent(in)                  :: HEIGHTNODE ! What heights
d4794 1
a4794 1
      integer, intent(in) :: HEIGHTNODE ! What heights
d4909 1
a4909 1
        if ( quantity%template%verticalCoordinate /= l_zeta ) &
d5642 1
a5642 1
        if ( quantity%template%verticalCoordinate /= l_zeta ) &
d6423 1
a6423 1
      LOGICAL ::                                       AOK
d6438 1
a6438 1
      LOGICAL ::       minorFrame   ! TRUE if radiances, FALSE if vmr
d6665 26
d6694 1
a6694 1
       "$Id: FillUtils_1.f90,v 2.63 2012/08/16 17:58:00 pwagner Exp $"
d6706 3
@


2.63
log
@Exploit level 2-savvy MLSMessage
@
text
@d18 2
a19 1
  use CONSTANTS, only: DEG2RAD, RAD2DEG
d21 4
a24 4
  use GRIDDEDDATA, only: GRIDDEDDATA_T, WRAPGRIDDEDDATA
  use HDF5, only: HSIZE_T
  ! NOW THE LITERALS:
  use INIT_TABLES_MODULE, only: &
d33 1
d52 2
a53 2
  use INTRINSIC, only: LIT_INDICES, &
    & PHYQ_DIMENSIONLESS, PHYQ_INVALID, PHYQ_TEMPERATURE, &
d63 2
a64 1
  use MATRIXMODULE_0, only: SPARSIFY, MATRIXINVERSION
d69 3
a71 3
  use MLSFILES, only: GETMLSFILEBYTYPE
  use MLSFILLVALUES, only: ISMONOTONIC, MONOTONIZE
  use MLSKINDS, only: R4, R8, RM, RV
d74 3
a76 2
    & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMESSAGECALLS
  use MLSNUMERICS, only: INTERPOLATEVALUES, HUNT
d79 2
a80 4
    & GETSIGNAL, SIGNAL_T, &
    & ISMODULESPACECRAFT
  use MLSSTATS1, only: MLSMIN, MLSMAX, MLSMEAN, MLSMEDIAN, MLSRMS, MLSSTDDEV
  use MLSSTRINGLISTS, only: CATLISTS, EXPANDSTRINGRANGE, GETSTRINGELEMENT, &
d82 2
a83 2
    & REPLACESUBSTRING, STRINGELEMENT, SWITCHDETAIL
  use MLSSTRINGS, only: INDEXES, LOWERCASE, SPLITNEST
d94 1
a94 1
  use TREE, only: NODE_ID, NSONS, &
d100 1
a100 1
    & DESTROYVECTORINFO, DUMP, &
d105 1
a105 1
  use VGRIDSDATABASE, only: GETUNITFORVERTICALCOORDINATE
a117 6
  type arrayTemp_T
     real(rv), dimension(:,:), pointer :: VALUES => NULL() ! shaped like a
  end type arrayTemp_T
  
  type(arrayTemp_T), dimension(:), save, pointer :: primitives => null()

d178 20
a197 20
  public :: addGaussianNoise, ApplyBaseline, AutoFillVector, &
      & ComputeTotalPower, DeallocateStuff, &
      & ExtractSingleChannel, FillCovariance, FromGrid, &
      & FromL2GP, FromProfile, LOSVelocity, &
      & ChiSqChan, ChiSqMMaf, ChiSqMMif, ChiSqRatio, &
      & ColAbundance, FoldedRadiance, PhiTanWithRefraction, &
      & IWCFromExtinction, RHIFromOrToH2O, NoRadsPerMIF, &
      & RHIPrecisionFromOrToH2O, WithEstNoise, &
      & Hydrostatically, FromSplitSideband, GPHPrecision, &
      & FromIsotope, FromAsciiFile, RotateMagneticField, &
      & Explicit, FromL1B, &
      & FromL2AUX, UsingMagneticModel, &
      & FromInterpolatedQty, FromLosGrid, &
      & ByManipulation, ManipulateVectors, WithReflectorTemperature, &
      & WithReichlerWMOTP, &
      & WithWMOTropopause, WithBinResults, WithBoxcarFunction, &
      & StatusQuantity, QualityFromChisq, ConvergenceFromChisq, &
      & UsingLeastSquares, OffsetRadianceQuantity, ResetUnusedRadiances, &
      & ScaleOverlaps, SpreadChannelFill, TransferVectors, UncompressRadiance, &
      & ANNOUNCE_ERROR, QtyFromFile, VectorFromFile
d209 1
a209 1
              & noiseQty, multiplier )
d220 3
a222 1
      real, dimension(:), intent(in), optional :: multiplier
d232 1
a232 1
      if ( .not. FillableChiSq ( quantity, &
d240 1
a240 4
      if ( .not. present(multiplier) ) then
        a = 1.
        b = 1.
      else if ( &
d253 10
a262 1
      do column=1, size(quantity%values(1, :))
d264 2
a265 2
          quantity%values(row, column) = &
            & sourceQuantity%values(row, column) * a &
d267 10
a276 1
            & drang() * noiseQty%values(row, column) * b
d278 1
a278 1
      end do
a286 2
      use DUMP_0, only: DUMP
      use INTRINSIC, only: FIELD_INDICES, PHYQ_INDICES
d417 1
a417 1
      & quadrature, dontmask )
d423 1
d436 12
a447 10
      if ( quantity%template%quantityType /= l_radiance ) &
        & call Announce_Error ( key, no_Error_Code, &
        &   'Quantity to fill must be a radiance' )
      if ( baselineQuantity%template%quantityType /= l_l1bMAFBaseline ) &
        & call Announce_Error ( key, no_Error_Code, &
        &   'Quantity to fill must be a L1BMAFBaseline' )
      if ( baselineQuantity%template%signal /= quantity%template%signal .or. &
        &  baselineQuantity%template%sideband /= quantity%template%sideband ) &
        & call Announce_Error ( key, no_Error_Code, &
        &   'Quantity and baselineQuantity must have matching signal/sideband' )
d550 1
a550 1
    subroutine Explicit ( quantity, valuesNode, spreadFlag, &
d570 1
d638 2
d667 1
a667 1
        else
a844 2
      use Init_tables_module, only: F_MEASUREMENTS, F_TOTALPOWERVECTOR, F_WEIGHTSVECTOR
      use Tree, only: DECORATION, SUBTREE
d926 2
a927 1
    subroutine ExtractSingleChannel ( key, quantity, sourceQuantity, channel )
d932 1
d939 11
a949 9
      if ( quantity%template%quantityType /= l_singleChannelRadiance ) &
        & call announce_error ( key, no_Error_Code, 'Quantity to fill must be of type singleChannelRadiance' )
      if ( all ( sourceQuantity%template%quantityType /= (/ l_cloudInducedRadiance, l_radiance /) ) ) &
        & call announce_error ( key, no_Error_Code, 'source quantity for fill must be of type [cloudInduced]radiance' )
      if ( quantity%template%signal /= sourceQuantity%template%signal .or. &
        & quantity%template%sideband /= sourceQuantity%template%sideband ) &
        & call announce_error ( key, no_Error_Code, 'quantity/sourceQuantity must be same signal/sideband' )
      if ( .not. sourceQuantity%template%regular ) &
        & call Announce_Error ( key, no_Error_Code, 'source quantity must be regular' )
d961 1
a961 1
    & dontMask, ignoreZero, ignoreNegative, multiplier, &
d974 2
a975 1
      real, dimension(:), intent(in), optional :: multiplier
d999 1
a999 4
      if ( .not. present(multiplier) ) then
        a = 1.
        b = 1.
      else if ( &
d1014 3
a1016 1
      if ( .not. ValidateVectorQuantity ( qty, &
d1097 1
a1097 1
    & dontMask, ignoreZero, ignoreNegative, multiplier, &
d1110 2
a1111 1
      real, dimension(:), intent(in), optional :: multiplier
d1134 4
a1137 1
      if ( .not. present(multiplier) ) then
a1139 3
      else if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
d1152 3
a1154 1
      if ( .not. ValidateVectorQuantity ( qty, &
d1241 1
a1241 1
    & dontMask, ignoreZero, ignoreNegative, multiplier, &
d1254 2
a1255 1
      real, dimension(:), intent(in), optional :: multiplier
d1280 1
a1280 4
      if ( .not. present(multiplier) ) then
        a = 1.
        b = 1.
      else if ( &
d1295 3
a1297 1
      if ( .not. ValidateVectorQuantity ( qty, &
d1378 1
a1378 1
    & dontMask, firstInstance, lastInstance )
d1399 3
a1401 3
      type (VectorValue_T), intent(inout) ::    normQty
      type (VectorValue_T), intent(inout) ::    minNormQty
      type (VectorValue_T), intent(inout) ::    flagQty
d1403 1
d1424 3
a1426 1
      if ( .not. ValidateVectorQuantity ( qty, &
d1507 2
a1508 1
    subroutine ColAbundance ( key, qty, bndPressQty, vmrQty, colmAbUnits, &
a1514 1
      use Constants, only: Ln10
d1520 1
d1563 3
a1565 1
      if ( (qty%template%quantityType /= l_columnAbundance) .or. &
d1760 2
a1761 1
    subroutine ConvergenceFromChisq ( key, quantity, sourceQuantity, scale )
d1766 1
d1773 6
a1778 4
      if ( quantity%template%quantityType /= l_quality ) call Announce_error ( key, no_error_code, &
        & 'Convergence quantity must be quality' )
      if ( sourceQuantity%template%quantityType /= l_dnwt_chisqRatio ) call Announce_error ( &
        & key, no_error_code, 'sourceQuantity must be of type chisqRatio' )
d1793 1
a1793 1
      & lengthScale, fraction, invert )
a1794 1
      use MatrixModule_0, only: CreateBlock, MatrixElement_t, M_Full
d1801 1
d1853 1
a1853 4
        if ( covariance%m%row%vec%template%name /= &
          & dMasked%template%name ) call MLSMessage ( MLSMSG_Error, &
          & ModuleName, "diagonal and covariance not compatible in fillCovariance" )
        if ( lengthScale /= 0 ) then    ! Check length if supplied
d1855 2
a1856 9
            & lMasked%template%name ) call MLSMessage ( MLSMSG_Error, &
            & ModuleName, "lengthScale and covariance not compatible in fillCovariance" )
          if ( lMasked%globalUnit /= phyq_length ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "length vector does not have dimensions of length" )
        else
          thisLength = 0.0
        end if
        if ( fraction /= 0 ) then       ! Check fraction if supplied
d1858 22
a1879 7
            & vectors(fraction)%template%name ) call MLSMessage ( MLSMSG_Error, &
            & ModuleName, "fraction and covariance not compatible in fillCovariance" )
          if ( vectors(fraction)%globalUnit /= phyq_dimensionless ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "fraction vector is not dimensionless" )
        else
          thisFraction = 1.0
d2038 92
d2592 1
a2592 1
      & h2o, orbIncline, ptan, refGPH, temperature )
a2593 1
      use Constants, only: DEG2RAD, RAD2DEG
a2595 1
      use MLSKinds, only: RP
d2606 1
d2619 20
a2638 19
      if ( quantity%template%instrumentModule /= ptan%template%instrumentModule ) &
        & call Announce_Error ( key, No_Error_Code, &
        & 'PHITan and PTan quantities are not for the same module' )
      if ( any(shape(quantity%values)/=shape(ptan%values)) ) &
        & call Announce_Error ( key, No_Error_Code, &
        & 'PHITan and PTan quantities are not the same size' )
      if ( .not. ValidateVectorQuantity ( temperature, &
        & quantityType=(/l_temperature/), coherent=.true., stacked=.true., &
        & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
        & call Announce_error ( key, no_error_code, 'Problem with temperature quantity for phiTan fill' )
      if ( .not. ValidateVectorQuantity ( h2o, &
        & quantityType=(/l_vmr/), molecule=(/l_h2o/), coherent=.true., stacked=.true., &
        & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
        & call Announce_error ( key, no_error_code, 'Problem with h2o quantity for phiTan fill' )
      if ( .not. ValidateVectorQuantity ( refGPH, &
        & quantityType = (/l_refGPH/), coherent=.true., stacked=.true., &
        & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/), noSurfs=(/1/) ) ) &
        & call Announce_Error ( key, badrefGPHQuantity )

d3416 2
a3417 2
    subroutine FromInterpolatedQty ( qty, source, force, key, DONTMASK, &
      & ptan )
a3419 1
      logical, intent(in) :: FORCE
d3421 2
a3422 1
      logical, intent(in) :: dontMask
d3436 21
a3456 19
      if ( .not. DoQtysDescribeSameThing ( qty, source ) .and. .not. force ) then
        call Announce_error ( key, no_error_code, &
          & 'Mismatch in quantities' )
        go to 9
      end if
      if ( .not. doHGridsMatch ( qty, source ) .and. .not. present(ptan) ) then
        call Announce_error ( key, no_error_code, &
          & 'Mismatch in horizontal grid' )
        go to 9
      end if
      if ( qty%template%noInstances /= source%template%noInstances .and. .not. force ) then
        call Announce_error ( key, no_error_code, &
          & 'Mismatch in num of instances' )
        go to 9
      end if
      if ( .not. doFGridsMatch ( qty, source )  .and. .not. present(ptan) ) then
        call Announce_error ( key, no_error_code, &
          & 'Mismatch in frequency grid' )
        go to 9
d3751 2
a3752 2
      & manipulation, key, &
      & force, spreadflag, dontSumHeights, dontSumInstances, &
d3754 1
d3761 1
a3761 1
      logical, intent(in) :: FORCE      ! If set throw caution to the wind
d3839 1
a3839 1
        elseif ( .not. force ) then
d3890 2
a3891 1
        call SimpleExprWithC( quantity, a, b, cc, mstr )
a3896 864
  contains
      subroutine doStatFun( qvalue, name, avalues )
        real(rv), intent(out) :: qvalue
        character(len=*), intent(in) :: name ! of the statistical function
        real(rv), dimension(:), intent(in) :: avalues
          select case ( name )
          case ( 'min(a)' )
            qvalue = mlsmin( avalues )
          case ( 'max(a)' )
            qvalue = mlsmax( avalues )
          case ( 'mean(a)' )
            qvalue = mlsmean( avalues )
          case ( 'median(a)' )
            qvalue = mlsmedian( avalues )
          case ( 'rms(a)' )
            qvalue = mlsrms( avalues )
          case ( 'stddev(a)' )
            qvalue = mlsstddev( avalues )
          case default
            ! Should not have come here
          end select
      end subroutine doStatFun

      subroutine SimpleExprWithC( quantity, a, b, c, mstr )
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), pointer :: A
      type (VectorValue_T), pointer :: B
      real(rv) :: C                     ! constant "c" in manipulation
      character (len=128) :: MSTR
        ! Evaluate mstr assuming it's of the form
        ! expr1 [op1 expr2]
        ! where each expr is either a primitive 'x' (one of {a, b, or c})
        ! or else ['('] 'x op y' [')']
        ! where 'op' is one of {+, -, *, /,<,>}

        ! Method:
        ! Progressively collapse all the '(..)' pairs into their values
        ! (stored in primitives database)
        ! until only primitives remain
        ! Then evaluate the primitives
        !
        ! Limitations:
        ! Does not check for unmatched parens or other illegal syntax
        
        ! Improvements to be made:
        ! (1) Check for illegal syntax 
        ! (2) Make ops into array, and loop over them where convenient
        integer, parameter :: MAXNESTINGS=64 ! Max number of '(..)' pairs
        character(len=MAXSTRLISTLENGTH) :: collapsedstr
        integer :: level
        logical :: MAPFUNCTION
        integer :: np ! number of primitives
        character(len=MAXSTRLISTLENGTH) :: part1
        character(len=MAXSTRLISTLENGTH) :: part2
        character(len=MAXSTRLISTLENGTH) :: part3
        character(len=4) :: vchar
        ! logical, parameter :: DEEBUG = .true.
        ! Executable
        if ( DeeBUG ) print *, 'mstr: ', trim(mstr)
        MapFunction = ( index(mstr, 'map' ) > 0 )
        nullify(primitives)
        np = 0
        
        
        ! Find any terms composed of digits (i.e., literal numbers) ddd and
        ! mark each as val(ddd)
        call markDigits( lowerCase(mstr), collapsedstr )
        if ( DEEBUG ) call outputNamedValue( 'collapsedstr', collapsedstr )

        mstr = collapsedstr
        ! Replace 'e-' with 'e_' to avoid splitting fortran numeric notation
        call ReplaceSubString( mstr, collapsedstr, 'e-', 'e_', &
          & which='all', no_trim=.true. )
        mstr = collapsedstr

        ! We're unable to ensure operator precedence
        ! so we'll attempt to identify multiplications and divisions
        ! and surround such subexpressions with extra parentheses
        
        call reorderPrecedence(mstr, collapsedstr)
        if ( DeeBUG ) then
          print *, 'incoming ', mstr
          print *, 'after reordering precedence ', collapsedstr
        endif
        mstr = collapsedstr
        
        ! 1st--make sure spaces surround each operator
        ! (It takes two steps for each to avoid threat of infinite loop)
        call ReplaceSubString( mstr, collapsedstr, '+', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '+', &
          & which='all', no_trim=.true. )

        call ReplaceSubString( mstr, collapsedstr, '*', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '*', &
          & which='all', no_trim=.true. )

        call ReplaceSubString( mstr, collapsedstr, '-', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '-', &
          & which='all', no_trim=.true. )

        call ReplaceSubString( mstr, collapsedstr, '/', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '/', &
          & which='all', no_trim=.true. )

        call ReplaceSubString( mstr, collapsedstr, '<', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '<', &
          & which='all', no_trim=.true. )

        call ReplaceSubString( mstr, collapsedstr, '>', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '>', &
          & which='all', no_trim=.true. )

        call ReplaceSubString( mstr, collapsedstr, '^', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '^', &
          & which='all', no_trim=.true. )

        collapsedstr = lowerCase(mstr)
        if ( DEEBUG ) call outputNamedValue( 'collapsedstr', collapsedstr )

        ! Restore 'e-'
        mstr = collapsedstr
        call ReplaceSubString( mstr, collapsedstr, 'e_', 'e-', &
          & which='all', no_trim=.true. )

        ! Collapse every sub-formula nested within parentheses
        do level =1, MAXNESTINGS ! To prevent endlessly looping if ill-formed
          if ( index( collapsedstr, '(' ) < 1 ) exit
          call SplitNest ( collapsedstr, part1, part2, part3 )
          ! Now evaluate the part2
          if ( DeeBUG ) then
            print *, 'part1 ', part1
            print *, 'part2 ', part2
            print *, 'part3 ', part3
          endif
          if ( part2 == ' ' ) then
            ! This should never happen with well-formed formulas
            collapsedstr = part1
            cycle
          else
            np = evaluatePrimitive( trim(part2), &
              & a, b, c )
            write(vChar, '(i4)') np
          endif
          ! And substitute its value for the spaces it occupied
          if (  part1 // part3 == ' ' ) then
            collapsedstr = vChar
          elseif (  part1 == ' ' ) then
            ! collapsedstr = trim(vChar) // ' ' // part3
            collapsedstr = catTwoOperands( trim(vChar), part3 )
          elseif ( part3 == ' ' ) then
            ! collapsedstr = trim(part1) // ' ' // vChar
            collapsedstr = catTwoOperands( trim(part1),  vChar )
          else
            ! collapsedstr = trim(part1) // ' ' // trim(vChar) // &
            !   & ' ' // part3
            collapsedstr = catTwoOperands( &
              & trim( catTwoOperands( trim(part1),  trim(vChar) ) ), &
              & part3 )
          endif
          if ( DeeBUG ) then
            print *, 'collapsedstr ', collapsedstr
          endif
        enddo
        ! Presumably we have collapsed all the nested '(..)' pairs by now
        np = evaluatePrimitive( trim(collapsedstr), &
              & a, b, c )
        if ( DeeBUG ) then
          print *, 'np ', np
          print *, 'size(database) ', size(primitives)
        endif
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = 0.
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = 0.
          end where
        endif
        if ( np < 1 .or. np > size(primitives) ) then
          print *, 'np ', np
          print *, 'size(database) ', size(primitives)
          call Announce_Error ( key, no_error_code, &
            & 'Illegal index for primitives array' )
          return
        endif
        if ( spreadFlag ) then
          ! Ignores mask, shape, etc. if we set the "spread" field
          do level=1, min( size(quantity%values, 1), size(a%values, 1) )
            quantity%values(level, :) = primitives(np)%values(level, 1)
          enddo
          if ( level <=  size(quantity%values, 1) ) &
            quantity%values(level:, :) = primitives(np)%values(level-1, 1)
        elseif ( MapFunction ) then
          ! Ignores mask, shape, etc. if we used the "map" function
            quantity%values = reshape( &
              & primitives(np)%values, shape(quantity%values) &
              & )
        elseif ( .not. associated ( quantity%mask ) ) then
          quantity%values = primitives(np)%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = primitives(np)%values
          end where
        end if
        if ( DeeBUG ) call dumpPrimitives(primitives)
        call destroyPrimitives(primitives)
      end subroutine SimpleExprWithC
      
      subroutine markDigits( instr, outstr )
        ! Find each instance of a number, composed of consecultive digits
        ! and mark it
        ! E.g., if
        ! instr =  '0.5 * height(a)'
        ! outstr = ' val($0.5) * height(a)'
        ! Args
        character(len=*), intent(in)  :: instr
        character(len=*), intent(out) :: outstr
        ! Internal variables
        ! logical, parameter            :: DEEBUG = .true.
        character(len=1)              :: c
        integer                       :: i          ! char num of instr
        integer                       :: e          ! char num of outstr
        logical                       :: gotDigit
        character(len=*), parameter :: dlist='1234567890.' ! These are digits
        character(len=*), parameter :: flist='-+e'         ! Fortran adds these
        ! Executable
        if ( DEEBug ) print *, 'instr ', instr
        outstr = instr
        e = 0
        gotDigit = .false.
        do i = 1, len_trim(instr)
          c = instr(i:i)
          if ( index(dlist, c ) > 0 ) then
            ! This was a digit: was it the first?
            if ( gotDigit ) then
              ! Nope, we are just lengthening our number
              e = e + 1
              outstr(e:e) = c
            else
              ! This is the first digit of a number
              ! Distinguish it from index into primitives db
              ! by use of 'val' function and '$' marker
              outstr(e+1:e+5) = 'val($'
              e = e + 6
              outstr(e:e) = c
            endif
            gotDigit = .true.
          elseif ( gotDigit ) then
            ! Check that we're not using fortran's '4.9e-6' notation
            if ( index(flist, c ) > 0 ) then
              ! With Fortran notation, we are just lengthening our number
              e = e + 1
              outstr(e:e) = c
            else
              ! We have come to the end of our digits
              outstr(e+1:e+1) = ')'
              e = e + 2
              outstr(e:e) = c
              gotDigit = .false.
            endif
          else
            e = e + 1
            outstr(e:e) = c
          endif
        enddo
        if ( DeeBug ) print *, 'outstr ', outstr
      end subroutine markDigits

      subroutine reorderPrecedence(mstr, collapsedstr)
        ! Identify all the terms where each term are separated by
        ! the lower-precedence operators {+, -,<,>}
        ! If any terms contain higher-precedence operators {*, /}
        ! then surround them by parentheses
        character(len=*), intent(in)  :: mstr
        character(len=*), intent(out) :: collapsedstr
        ! Internal variables
        integer :: i
        integer :: n
        character(len=(len(mstr)+3)) :: element
        character(len=(len(mstr)+3)) :: temp
        ! Executable
        ! 1st -- replace each '-' with '+-'
        ! (Don't worry--we'll undo this before returning)
        ! (It takes two steps for each to avoid threat of infinite loop)
        call ReplaceSubString( mstr, collapsedstr, '-', '&', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, temp, '&', '+-', &
          & which='all', no_trim=.true. )

        call ReplaceSubString( temp, collapsedstr, '<', '&', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, temp, '&', '+<', &
          & which='all', no_trim=.true. )

        call ReplaceSubString( temp, collapsedstr, '>', '&', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, temp, '&', '+>', &
          & which='all', no_trim=.true. )
        ! Now loop over terms
        n = NumStringElements( temp, COUNTEMPTY, inseparator='+' )
        if ( n < 1 ) then
          call ReplaceSubString( temp, collapsedstr, '+-', '-', &
            & which='all', no_trim=.false. )
          call ReplaceSubString( collapsedstr, temp, '+<', '<', &
            & which='all', no_trim=.false. )
          call ReplaceSubString( temp, collapsedstr, '+>', '>', &
            & which='all', no_trim=.false. )
          return
        endif
        collapsedstr = ' '
        do i=1, n
          call GetStringElement ( temp, element, i, countEmpty, inseparator='+' )
          ! Surround term with parentheses if it's a product or quotient
          ! but not if it's (already) parenthetical
          if ( ( index(element, '*') > 0 .or. index(element, '/') > 0 .or. &
            & index(element, '^') > 0 ) .and. &
            & .not. isParenthetical(element) ) then
            element = '(' // trim(element) // ')'
          endif
          collapsedstr = catLists( collapsedstr, element, inseparator='+' )
        enddo
        
        ! Now undo change by reverting all '+-'
        ! (including any that may have been split by parentheses
        call ReplaceSubString( collapsedstr, temp, '+-', '-', &
          & which='all', no_trim=.false. )
        call ReplaceSubString( temp, collapsedstr, '+(-', '-(', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( collapsedstr, temp, '+<', '<', &
          & which='all', no_trim=.false. )
        call ReplaceSubString( temp, collapsedstr, '+(<', '<(', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( collapsedstr, temp, '+>', '>', &
          & which='all', no_trim=.false. )
        call ReplaceSubString( temp, collapsedstr, '+(>', '>(', &
          & which='all', no_trim=.false. )
      end subroutine reorderPrecedence

      subroutine destroyPrimitives(primitives)
        ! deallocate all the arrays we created
        type(arrayTemp_T), dimension(:), pointer :: primitives
        integer :: i
        if ( .not. associated(primitives) ) return
        if ( size(primitives) < 1 ) return
        do i=1, size(primitives)
          call deallocate_test( primitives(i)%values, &
            & 'values', ModuleName // '/destroyPrimitives' )
        enddo
      end subroutine destroyPrimitives

      subroutine dumpAPrimitive(primitive)
        ! dump all the values in the array
        type(arrayTemp_T), intent(in) :: primitive
        if ( .not. associated(primitive%values) ) then
          call output( 'values not associated ', advance='yes' )
          return
        endif
        if ( size(primitive%values) < 1 ) then
          call output( 'values array is of 0 size ', advance='yes' )
          return
        endif
        call dump( primitive%values, 'values' )
      end subroutine dumpAPrimitive

      subroutine dumpPrimitives(primitives)
        ! dump all the arrays we created
        type(arrayTemp_T), dimension(:), pointer :: primitives
        integer :: i
        if ( .not. associated(primitives) ) then
          call output( 'database not associated ', advance='yes' )
          return
        endif
        if ( size(primitives) < 1 ) then
          call output( 'empty database ', advance='yes' )
          return
        endif
        call output( 'size of primitives database: ', advance='no' )
        call output( size(primitives), advance='yes' )
        do i=1, size(primitives)
          call output ( ' index of primitive: ', advance='no' )
          call output ( i, advance='yes' )
          call dumpAPrimitive( primitives(i) )
        enddo
      end subroutine dumpPrimitives

      integer function AddPrimitiveToDatabase( DATABASE, ITEM )

        ! This function adds a primitive data type to a database of said types,
        ! creating a new database if it doesn't exist.  The result value is
        ! the size -- where it was put.

        ! Dummy arguments
        type (arrayTemp_T), dimension(:), pointer :: DATABASE
        type (arrayTemp_T), intent(in) :: ITEM

        ! Local variables
        type (arrayTemp_T), dimension(:), pointer :: tempDatabase
        !This include causes real trouble if you are compiling in a different
        !directory.
        include "addItemToDatabase.f9h" 

        AddPrimitiveToDatabase = newSize
      end function AddPrimitiveToDatabase

      function evaluatePrimitive( str, a, b, c ) result(value)
        ! Evaluate an expression composed entirely of
        ! (0) constants ('c')
        ! (1) primitives (e.g., '2')
        ! (2) unary operators ('-')
        ! (3) binary operators {'+', '-', '*', '/','<','>'}
        ! (4) recognized functions {'map:', 'exp:', ..}
        ! Dummy args
        character(len=*)                :: str
        integer                         :: value
        type (VectorValue_T), pointer   :: A
        type (VectorValue_T), pointer   :: B
        real(rv) :: C                     ! constant "c" in manipulation
        ! Internal variables
        ! logical, parameter              :: DEEBUG = .true.
        logical                         :: done
        ! fun is blank unless a prior one left us "hungry" for an arg
        character(len=8)                :: fun ! {'exp', 'log', etc.}
        integer                         :: elem
        logical                         :: hit
        integer                         :: iChannel
        integer                         :: ind
        integer                         :: instance
        integer                         :: isurf
        character(len=3)                :: lastOp ! {'+', '-', '*', '/'}
        integer                         :: n
        logical                         :: negating
        type (arrayTemp_T)              :: newone
        integer                         :: NoChans
        integer                         :: NoInstances
        integer                         :: NoSurfs
        character(len=8)                :: op
        type (arrayTemp_T)              :: part
        integer                         :: partID
        real(rv)                        :: qvalue
        integer, dimension(2)           :: shp
        integer                         :: surf
        character(len=32)               :: variable
        ! Executable
        shp = shape(a%values)
        call allocate_test( newone%values, shp(1), shp(2), &
          & 'newone', ModuleName // '/evaluatePrimitive' )
        call allocate_test( part%values, shp(1), shp(2), &
          & 'part', ModuleName // '/evaluatePrimitive' )

        if ( deeBug ) then
          print *, 'Complete dump of database'
          call dumpPrimitives(primitives)
        endif

        done = .false.
        negating = .false.
        elem = 0
        lastOp = 'nul' ! 'or'
        newone%values = 0.
        n = NumStringElements( trim(str), countEmpty=.false., &
          & inseparator=' ' )
        if ( DeeBUG ) then
          print *, n, ' str: ', trim(str)
        endif
        partID = -1
        fun = ' '
        hit = .false.
        do
          ! go through the elements, re-evaluating every time we "hit" a primitive
          ! Otherwise revising our lastOp or negating status
          elem = elem + 1
          call GetStringElement ( trim(str), variable, elem, &
            & countEmpty=.false., inseparator=' ' )
          if ( DeeBUG ) then
            print *, elem, ' variable: ', trim(variable)
          endif
          select case( trim(variable) )
          case ('a')
            partID = -1
            part%values = a%values
            hit = .true.
          case ('b')
            partID = -2
            part%values = b%values
            hit = .true.
          case ('c')
            partID = -3
            part%values = c
            hit = .true.
          case ('+')
            lastOp = '+'
            hit = .false.
          case ('*')
            lastOp = '*'
            hit = .false.
          case ('/')
            lastOp = '/'
            hit = .false.
          case ('^')
            lastOp = '^'
            hit = .false.
          case ('-') ! could be unary or binary; how do we tell?
            if ( hit ) then ! already have a primitive; looking for an op
              lastOp = '-'
              hit = .false.
            else
              ! case ('not', '~')
              negating = .true.
              hit = .false.
            endif
          case ('<')
            lastOp = '<'
            hit = .false.
          case ('>')
            lastOp = '>'
            hit = .false.
          case (' ')
            call Announce_Error ( key, no_error_code, 'parse error of:' // trim(str) )
          case default
            ind = index(variable, ':')
            if ( deeBug ) print *, 'ind of ":" ', ind
            if ( ind > 1 ) then
              ! A function name
              fun = variable(1:ind-1)
              hit = .false.
            elseif ( index(variable, '$') > 0 ) then
              ! A literal number
              if ( deeBug ) print *, 'Trying to read number from ' // variable
              variable = adjustl(variable)
              read( variable(2:), * ) qvalue
              part%values = qvalue
              hit = .true.
              if ( deeBug ) then
                print *, 'part"s values after ' // trim(lastOp) // trim(variable)
                call dumpAPrimitive(part)
              endif
            else
              ! An index into the primitives db
              if ( deeBug ) print *, 'Trying to read partID from ' // variable
              read( variable, * ) partID
              if ( partID < 1 ) then
                print *, 'partID: ', partID
                call Announce_Error ( key, no_error_code, 'partID too small' )
                return
              elseif( partID > size(primitives) ) then
                print *, 'partID: ', partID
                call Announce_Error ( key, no_error_code, 'partID too big' )
                return
              endif
              part%values = primitives(partID)%values
              hit = .true.
              if ( deeBug ) then
                print *, 'part"s values after ' // trim(lastOp) // trim(variable)
                call dumpAPrimitive(part)
                print *, 'based on'
                call dumpAPrimitive(primitives(partID))
              endif
            endif
          end select
          if ( hit ) then
            if ( negating ) part%values = -part%values
            op = lastOp
            if ( fun /= ' ' ) op = fun
            select case(op)
            case ('nul')
                newone%values = part%values
            case ('+')
                newone%values = newone%values + part%values
            case ('-')
                newone%values = newone%values - part%values
            case ('*')
                newone%values = newone%values * part%values
            case ('/')
              where ( part%values /= 0._rv )
                newone%values = newone%values / part%values
              end where
            case ('^')
              where ( newone%values > 0._rv )
                newone%values = newone%values ** part%values
              elsewhere
                newone%values = 0.
              end where
            case ('<')
                newone%values = min( newone%values, part%values )
            case ('>')
                newone%values = max( newone%values, part%values )
            ! Now the functions
            case ('val')
                newone%values = part%values
            case ('abs')
                newone%values = abs( part%values )
            case ('sign')
                where ( part%values /= 0._rv )
                  newone%values = sign(1._rv, part%values)
                end where
            case ('ifpos')
                where ( part%values > 0._rv )
                  newone%values = 1._rv
                end where
            case ('ifneg')
                where ( part%values < 0._rv )
                  newone%values = 1._rv
                end where
            case ('exp')
                newone%values = exp( part%values )
            case ('log', 'ln')
                where ( part%values > 0._rv )
                  newone%values = log(part%values)
                elsewhere
                  newone%values = 0.
                end where
            case ('log10')
                where ( part%values > 0._rv )
                  newone%values = log10(part%values)
                elsewhere
                  newone%values = 0.
                end where
            ! map is a no-op currently
            ! You can use this to map quantities with equal total
            ! size, but distributed differently among channels, sirfs, instances
            case ('map')
                newone%values = part%values
                ! call output( 'Calling function map', advance='yes' )
            case ('channel', 'surface', 'instance', 'height', 'lon', 'lat', 'sza')
              ! These might be useful for filling arrays with indexes
              NoChans     = a%template%NoChans
              NoInstances = a%template%NoInstances
              NoSurfs     = a%template%NoSurfs
              newone%values = 1
              if ( NoChans*NoSurfs*NoInstances < 2 ) cycle
              do instance=1, NoInstances
                do iSurf=1, NoSurfs
                  surf = 1
                  if ( .not. a%template%stacked ) surf = iSurf
                  do iChannel=1, NoChans
                    select case(op)
                    case ('channel')
                      newone%values(iChannel + (isurf-1)*NoChans, instance) = &
                        & iChannel
                    case ('surface')
                      newone%values(iChannel + (isurf-1)*NoChans, instance) = &
                        & iSurf
                    case ('height')
                      if ( a%template%coherent ) then
                        newone%values(iChannel + (isurf-1)*NoChans, instance) = &
                          & a%template%surfs(iSurf, 1)
                      else
                        newone%values(iChannel + (isurf-1)*NoChans, instance) = &
                          & a%template%surfs(iSurf, instance)
                      endif
                    case ('instance')
                      newone%values(iChannel + (isurf-1)*NoChans, instance) = &
                        & instance
                    case ('lat')
                      newone%values(iChannel + (isurf-1)*NoChans, instance) = &
                        & a%template%GeodLat(surf, instance)
                    case ('lon')
                      newone%values(iChannel + (isurf-1)*NoChans, instance) = &
                        & a%template%lon(surf, instance)
                    case ('sza')
                      newone%values(iChannel + (isurf-1)*NoChans, instance) = &
                        & a%template%solarZenith(surf, instance)
                    end select                
                  enddo
                enddo
              enddo
            case ('shift', 'slip')
              ! These are useful for recurrence relations, frequency shifts,
              ! and applying any filter that spans multiple heights or
              ! multiple instances
              ! At present, they apply only to the fastest changing index
              ! in this order: channel, surface, instance
              ! shift(a[n]) = a[n+1]
              ! slip(a[n])  = a[n-1]
              NoChans     = a%template%NoChans
              NoInstances = a%template%NoInstances
              NoSurfs     = a%template%NoSurfs
              if ( NoChans*NoSurfs*NoInstances < 2 ) cycle
              select case(op)
              case ('shift')
                if ( NoChans > 1 ) then
                  do iSurf = 1, NoSurfs
                    newone%values(1 + (isurf-1)*NoChans:isurf*NoChans-1, :) = &
                      & part%values(2 + (isurf-1)*NoChans:isurf*NoChans, :)
                  enddo
                elseif ( NoSurfs > 1 ) then
                  newone%values(1 :NoSurfs-1, :) = &
                    & part%values(2 :NoSurfs, :)
                else
                  newone%values(:, 1:NoInstances-1) = &
                    & part%values(: , 2:NoInstances)
                endif
                ! call output( 'Calling function shift', advance='yes' )
              case ('slip')
                if ( NoChans > 1 ) then
                  do iSurf = 1, NoSurfs
                    newone%values(2 + (isurf-1)*NoChans:isurf*NoChans, :) = &
                      & part%values(1 + (isurf-1)*NoChans:isurf*NoChans-1, :)
                  enddo
                elseif ( NoSurfs > 1 ) then
                  newone%values(2 :NoSurfs, :) = &
                    & part%values(1 :NoSurfs-1, :)
                else
                  newone%values(:, 2:NoInstances) = &
                    & part%values(: , 1:NoInstances-1)
                endif
                ! call output( 'Calling function slip', advance='yes' )
              end select                
            ! statistical function cases
            case ( 'min', 'max', 'mean', 'median', 'rms', 'stddev' )
              ! These are harder--we must interpret how to gather
              ! or "sum" the data
              ! By default we sum over heights, channels and instances
              ! but optional flags may cuase us to pick out
              ! a statistic at each height (dontSumHeights)
              ! or at each instance (dontSumInstances)
              NoChans     = a%template%NoChans
              NoInstances = a%template%NoInstances
              NoSurfs     = a%template%NoSurfs
              if ( dontSumHeights .and. dontSumInstances ) then
                do instance = 1, NoInstances
                  do iSurf = 1, NoSurfs
                    call doStatFun( newone%values(iSurf, instance), &
                      & trim(op) // '(a)', &
                      & part%values(1+(iSurf-1)*NoChans:iSurf*NoChans, instance) )
                  enddo
                enddo
              elseif ( dontSumInstances ) then
                do instance = 1, NoInstances
                  call doStatFun( qvalue, trim(op) // '(a)', &
                    & part%values(:, instance) )
                  if ( spreadFlag ) then
                    newone%values(:, instance) = qvalue
                  else
                    newone%values(1, instance) = qvalue
                  endif
                enddo
              elseif ( dontSumHeights ) then
                do iSurf = 1, NoSurfs
                  call doStatFun( qvalue, trim(op) // '(a)', &
                    & part%values(iSurf, :) )
                  if ( spreadFlag ) then
                    newone%values(iSurf, :) = qvalue
                  else
                    newone%values(iSurf, 1) = qvalue
                  endif
                enddo
              else
                ! Sum over both heights and instances
                select case ( op )
                case ( 'min' )
                  qvalue = mlsmin( part%values )
                case ( 'max' )
                  qvalue = mlsmax( part%values )
                case ( 'mean' )
                  qvalue = mlsmean( part%values )
                case ( 'median' )
                  qvalue = mlsmedian( part%values )
                case ( 'rms' )
                  qvalue = mlsrms( part%values )
                case ( 'stddev' )
                  qvalue = mlsstddev( part%values )
                case default
                  ! Should not have come here
                end select
                if ( spreadFlag ) then
                  newone%values = qvalue
                else
                  newone%values(1, 1) = qvalue
                endif
              endif
            case default
              ! How could this happen?
                call MLSMessage( MLSMSG_Error, ModuleName, &
                  & op // ' not a legal binary op in evaluatePrimitive' )
            end select
            fun = ' '
            negating = .false.
            if ( deeBug ) then
              print *, 'newone"s values after ' // trim(lastOp) // trim(variable)
              call dumpAPrimitive(newone)
            endif
          endif
          if ( DeeBUG ) then
            print *, 'variable ', variable
            print *, 'partID ', partID
            print *, 'hit ', hit
            print *, 'negating ', negating
            print *, 'lastOp ', lastOp
          endif
          done = ( elem >= n )
          if ( done ) exit
        enddo
        value = AddPrimitiveToDatabase( primitives, newone )
!         call deallocate_test( newone%values, &
!           & 'newone', ModuleName // '/evaluatePrimitive' )
        call deallocate_test( part%values, &
          & 'part', ModuleName // '/evaluatePrimitive' )
        if ( .not. DEEBUG ) return
        print *, 'value ', value
        print *, 'newone"s values ' // trim(str)
        call dumpAPrimitive(newone)
        
        print *, 'values stored in db '
        call dumpAPrimitive(primitives(value))
      end function evaluatePrimitive
      
      function catTwoOperands( part1, part2 ) result ( str )
        ! cat together part1 and part2 with a space between them
        ! unless the last non-blank character of part1
        ! and the 1st non-blank character of part2 aren't operators
        ! in which case put a colon ':' between them
        ! E.g., if 
        ! part1 = 'a + b'
        ! and part2 = '/ c' then str = 'a + b / c'
        ! but if part1 = 'map'
        ! and part2 = 'c - a' then str = 'map: c - a'
        ! args
        character(len=*), intent(in)           :: part1
        character(len=*), intent(in)           :: part2
        character(len=MAXSTRLISTLENGTH)        :: str
        ! internal variables
        character(len=1), dimension(9), parameter :: ops = &
          &          (/ '+', '-', '*', '/' , '(', ')', '^', '<', '>' /)
        character(len=1) :: part1Tail, part2Head
        integer :: maxind
        integer :: n
        integer, dimension(4) :: inds
        ! Executable
        n = max(1, len_trim(part1))
        part1Tail = part1(n:n)
        part2Head = adjustl(part2)
        if ( all( indexes(part1Tail // part2Head, ops) == 0 ) ) then
          ! Mark function name "hungry" for an arg by adding a ':' to
          ! str = trim(part1) // ': ' // adjustl(part2)
          ! Must also check if part 1 contains an embedded operator
          inds = indexes( part1, (/ '+', '-', '*', '/' /), mode='last' )
          maxind = maxval(inds)
          if ( maxind < 1 ) then
            str = '(' // trim(part1) // ': ' // trim(adjustl(part2) ) // ')'
          else
            str = part1(:maxind) // '(' // trim(part1(maxind+1:)) &
              & // ': ' // trim(adjustl(part2) ) // ')'
          endif
        else
          str = trim(part1) // ' ' // adjustl(part2)
        endif
      end function catTwoOperands
      
      function isParenthetical ( str ) result ( itIs )
        ! TRUE if 1st non-blank is '(' and last non-blank is ')'
        character(len=*), intent(in) :: str
        logical                      :: itIs
        itIs = index( adjustl(str), '(' ) == 1 .and. &
          &    index( trim(str), ')'    ) == len_trim(str)
      end function isParenthetical
a3915 1
      use MLSFiles, only: HDFVERSION_5
a4433 2
      use MLSSignals_m, only: SIGNALS

a4511 1
      use Constants, only: DEG2RAD
a4554 3
      use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
      use DUMP_0, only: DUMP
      use MLSFILLVALUES, only: ISFILLVALUE, REMOVEFILLVALUES
d4556 1
a4556 1
      use wmoTropopause, only: ExtraTropics, twmo
a4672 1
      use VGridsDatabase, only: VGRID_T
d4819 2
a4820 1
    subroutine QualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )
d4823 4
a4826 3
      type ( VectorValue_T), intent(in) :: SOURCEQUANTITY ! Chisq like quantity on which it's based
      real(r8), intent(in) :: SCALE     ! A scale factor
      integer, intent(in) :: HEIGHTNODE ! What heights
d4837 8
a4844 7
      if ( quantity%template%quantityType /= l_quality ) call Announce_error ( key, no_error_code, &
        & 'Quality quantity must be quality' )
      if ( sourceQuantity%template%quantityType /= l_chisqBinned ) call Announce_error ( &
        & key, no_error_code, 'sourceQuantity must be of type chisqBinned' )
      if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) ) call Announce_error ( &
        & key, no_error_code, 'quantity and sourceQuantity do not have matching hGrids' )

d4869 2
a4870 1
      & minValue, maxValue, heightNode, additional, force, exact )
a4878 1
      logical, intent(in) :: FORCE ! May pound round pegs into square holes?
d4880 1
d4891 7
a4897 6
      if ( quantity%template%quantityType /= l_status ) call Announce_error ( key, no_error_code, &
        & 'status quantity must be status' )
      if ( .not. ( force .or. DoHGridsMatch ( quantity, sourceQuantity ) ) ) &
        & call Announce_error ( &
        & key, no_error_code, 'quantity and sourceQuantity do not have matching hGrids' )

a4948 1
      use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
a5125 2
      use DUMP_0, only: DUMP
      use GRIDDEDDATA, only: DUMP
a5223 2
      use MLSNumerics, only: COEFFICIENTS_R8, INTERPOLATEARRAYSETUP, &
        & INTERPOLATEARRAYTEARDOWN
d5655 1
a5655 1
            & force=.true., spreadflag=.false., dontSumHeights=.true., &
d5921 2
a5922 1
    subroutine WithBoxcarFunction ( key, quantity, sourceQuantity, width, method )
d5924 1
a5924 1
      type (VectorValue_T), intent(inout) :: QUANTITY
d5926 3
a5928 2
      integer, intent(in) :: WIDTH
      integer, intent(in) :: METHOD     ! L_MEAN, L_MAX, L_MIN
d5937 2
a5938 1
      if ( quantity%template%name /= sourceQuantity%template%name ) then
a6035 2
      use Constants, only: RAD2DEG
      use Intrinsic, only: L_FIELDAZIMUTH, L_FIELDELEVATION, L_FIELDSTRENGTH
a6225 1
      use VectorsModule, only: DestroyVectorQuantityMask
d6261 2
a6262 2
            call FromInterpolatedQty( dq, sq, force=.false., key=0, &
              & dontmask=.false. )
a6420 1
      use MLSFiles, only: DUMP
a6421 1
      use MLSSTRINGS, only: WRITEINTSTOCHARS
a6606 2
      use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
      use HDF5, only: H5DOPEN_F, H5DCLOSE_F
d6751 1
a6751 1
       "$Id: FillUtils_1.f90,v 2.62 2012/08/08 19:57:06 vsnyder Exp $"
d6763 3
@


2.62
log
@Use a matrix block instead of a real array in FillCovariance
@
text
@d69 2
a70 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING, &
d3240 1
a3240 1
      use MOREMESSAGE, only: MLSMESSAGE
d3260 1
a3260 1
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error opening ASCII file at %l', &
d3266 1
a3266 1
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error reading ASCII file %l', &
d3272 1
a3272 1
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error closing ASCII file at %l', &
d7494 1
a7494 1
       "$Id: FillUtils_1.f90,v 2.61 2012/07/31 00:49:02 vsnyder Exp $"
d7506 3
@


2.61
log
@Use DestroyVectoryQuantityMask abstraction
@
text
@d1762 1
d1786 1
a1786 1
      real (rm), dimension(:,:), pointer :: M ! The matrix being filled
d1800 1
a1800 1
      nullify ( m, condition )
a1856 1
          call Allocate_test ( m, n, n, 'M', ModuleName )
d1860 3
d1867 1
a1867 1
            m = 0.0_rm
d1869 1
a1869 1
              m(j,j) = d%values(j,i) ** 2.0
d1877 1
a1877 1
                  meanDiag = sqrt ( m(j,j) * m(k,k) )
d1893 1
a1893 1
                    m(j,k) = meanDiag*thisFraction*exp(-distance/thisLength)
d1905 1
a1905 1
                if ( condition(j) ) M(j,j) = 1.0_rm
d1908 1
a1908 1
                call MatrixInversion(M, upper=.true.)
d1911 1
a1911 1
                  m(j,j) = 1.0 / m(j,j)
d1915 1
a1915 1
                if ( condition(j) ) M(j,j) = 0.0_rm
d1920 1
a1920 2
            b = FindBlock ( covariance%m%col, q, i )
            call Sparsify ( M, covariance%m%block(b,b) )
a1921 1
          call Deallocate_test ( m, 'M', ModuleName )
d7493 1
a7493 1
       "$Id: FillUtils_1.f90,v 2.60 2012/06/07 22:46:03 pwagner Exp $"
d7505 3
@


2.60
log
@Turn off warnings about non-monotonic Ptan in FromProfile
@
text
@d6962 1
d6990 1
a6990 2
              if ( associated(dq%mask) ) &
                & call Deallocate_test ( dq%mask, 'dq%mask', ModuleName )
d7492 1
a7492 1
       "$Id: FillUtils_1.f90,v 2.59 2012/06/07 00:53:25 vsnyder Exp $"
d7504 3
@


2.59
log
@More, and more consistent, -g tracing
@
text
@d113 1
d6210 5
a6214 1
          call dump( outHeights, 'outHeights' )
d7492 1
a7492 1
       "$Id: FillUtils_1.f90,v 2.58 2012/05/08 17:51:58 pwagner Exp $"
d7504 3
@


2.58
log
@Disabled another debugging bloc
@
text
@d229 2
d236 1
a236 1
        return
d265 2
d417 1
d419 3
a421 1
      ! call output( 'Now in applyBaseline', advance='yes' )
d473 2
d490 2
d509 2
d608 2
d818 2
d852 2
d904 2
d918 2
d934 2
d973 2
d976 1
a976 1
     ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
d1007 1
a1007 1
        return
d1011 1
a1011 1
        return
d1016 1
a1016 1
        return
d1034 1
a1034 1
      if ( noOutputInstances < 1 ) return
d1070 2
a1104 1
      ! Executable code
d1108 2
d1111 1
a1111 1
     ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
d1142 1
a1142 1
        return
d1146 1
a1146 1
        return
d1151 1
a1151 1
        return
d1169 1
a1169 1
      if ( noOutputInstances < 1 ) return
d1211 2
a1247 1
      ! Executable code
d1251 2
d1254 1
a1254 1
     ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
d1285 1
a1285 1
        return
d1289 1
a1289 1
        return
d1294 1
a1294 1
        return
d1312 1
a1312 1
      if ( noOutputInstances < 1 ) return
d1348 2
d1395 2
d1403 1
a1403 1
        return
d1408 1
a1408 1
        return
d1413 1
a1413 1
        return
d1418 1
a1418 1
        return
d1436 1
a1436 1
      if ( noOutputInstances < 1 ) return
d1475 2
d1487 1
a1498 1
      real(r8) :: LN10         ! = LOG(10.d0)
d1532 2
a1533 1
      LN10 = LOG(10.d0)  ! Compiler won't let this be a parameter
d1540 1
a1540 1
        return
d1544 1
a1544 1
        return
d1549 1
a1549 1
        return
d1554 1
a1554 1
        return
d1558 1
a1558 1
        return
d1579 1
a1579 1
      if ( noOutputInstances < 1 ) return
d1604 1
a1604 1
          return
d1666 1
a1666 1
          return
d1725 2
d1738 2
d1752 2
d1794 2
d1925 2
d1946 2
d1955 1
a1955 1
        return
d1993 2
d2021 2
d2189 2
d2207 2
a2208 3

      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_begin ( "GPHPrecision", key )
d2220 1
a2220 5
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "GPHPrecision")
          return
        end if
        if ( (any(quantity%template%surfs /= tempPrecisionQuantity%template%surfs)) .or. &
d2225 2
a2226 3
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "GPHPrecision")
          return
a2227 1
        call GetGPHPrecision ( tempPrecisionQuantity, refGPHPrecisionQuantity, quantity%values )
d2232 2
a2233 2
      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_end ( "GPHPrecision" )
d2254 2
d2310 2
d2337 2
d2396 2
d2426 2
d2454 2
d2484 2
d2561 2
d2638 2
d2663 1
a2663 1
       return
d2677 1
a2677 1
       return
d2689 1
a2689 1
       return
d2849 2
d2945 2
d2956 1
a2956 1
      ! return
d2970 1
a2970 1
       return
d2986 1
a2986 1
       return
d3000 1
a3000 1
       return
d3229 2
d3247 2
d3279 2
d3301 2
d3307 1
a3307 1
        return
d3312 1
a3312 1
        return
d3317 1
a3317 1
        return
d3322 1
a3322 1
        return
d3338 1
a3338 1
          return
d3342 1
a3342 1
          return
d3439 2
d3479 2
a3480 1
      if ( toggle(gen) ) call trace_begin ( "FromLosGrid", key )
d3610 2
d3668 2
d3727 1
a3727 1
          return
d3750 1
a3750 1
            return
d3758 2
d4668 2
a4671 2
      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_begin ("FromL1B",root)
d4784 1
a4784 3
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "FromL1B")
        return
d4804 1
a4804 3
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "FromL1B")
        return
d4870 1
a4870 2
      if ( switchDetail(switches, 'l1b') > -1 ) &
        & call Dump( l1bData )
d4872 2
a4873 1
      if ( toggle(gen) .and. levels(gen) > 0 ) call trace_end( "FromL1B" )
d4885 2
d4900 1
a4900 1
        return
d4904 1
a4904 1
        return
d4909 1
a4909 1
        return
d4915 2
d4935 2
d4943 1
a4943 1
        return
d4949 1
a4949 1
        return
d4954 1
a4954 1
        return
d4959 1
a4959 1
        return
d4986 2
d5016 2
a5017 2
      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_begin ( "Hydrostatically", key )
d5029 1
a5029 3
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "Hydrostatically")
          return
d5036 1
a5036 3
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "Hydrostatically")
          return
d5046 1
a5046 3
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "Hydrostatically")
          return
d5052 1
a5052 3
          if ( toggle(gen) .and. levels(gen) > 0 )&
            &  call trace_end ( "Hydrostatically")
          return
d5083 1
a5083 3
           if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "Hydrostatically")
          return
d5093 2
a5094 2
      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_end ( "Hydrostatically" )
d5113 2
d5154 2
d5180 2
d5236 2
d5255 2
d5280 2
d5315 2
d5400 2
d5463 2
d5550 2
d5567 2
d5596 2
d5619 2
d5669 2
d5705 2
d5739 1
a5739 1
        return
d5851 2
d5875 2
d5891 1
a5891 1
        return
d5897 1
a5897 1
        return
d5951 2
d5988 2
d6068 1
a6068 1
          return
d6125 2
d6163 2
d6172 1
a6172 1
        return
d6216 1
a6216 1
          return
d6276 2
d6305 2
d6356 2
d6374 2
d6395 2
d6429 2
d6525 1
a6525 1
        return
d6648 2
d6665 2
d6669 1
a6669 1
        return
d6673 1
a6673 1
        return
d6710 2
d6722 2
d6736 7
a6742 4
      if ( .not. associated ( radianceQuantity%mask ) ) return
      where ( iand ( ichar(radianceQuantity%mask), M_LinAlg ) /= 0 )
        quantity%values = quantity%values + amount
      end where
d6750 2
d6759 2
d6780 2
d6786 1
a6786 1
        return
d6791 1
a6791 1
        return
d6796 1
a6796 1
        return
d6835 2
d6851 2
d6861 1
a6861 1
          return
d6883 1
a6883 1
          return
d6893 2
d6914 2
d6929 18
a6946 18
        return
      endif
      ! Deal with any channel numbering issues.
      signal = GetSignal ( quantity%template%signal )
      myChannel = channel - lbound ( signal%frequencies, 1 ) + 1
      if ( myChannel < 1 .or. myChannel > quantity%template%noChans ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Invalid channel for spread channel' )
      do i = 1, quantity%template%noInstances
        do s = 1, quantity%template%noSurfs
          do c = 1, quantity%template%noChans
            if ( c == myChannel ) cycle
            j = (s-1)*quantity%template%noChans + c
            if ( associated ( quantity%mask ) .and. .not. dontMask ) then
              if ( iand ( ichar(quantity%mask(j,i)), m_Fill ) == 1 ) cycle
            end if
            quantity%values ( j, i ) = &
              & quantity%values ( (s-1)*quantity%template%noChans + myChannel, i )
d6949 3
a6951 1
      end do
d6968 2
d6998 2
d7029 2
d7096 2
d7121 2
d7146 2
d7175 2
d7222 2
d7257 2
d7285 1
a7285 1
      if ( .not. aok ) return
d7334 2
a7335 1
      return
d7368 2
d7445 2
d7487 1
a7487 1
       "$Id: FillUtils_1.f90,v 2.57 2012/04/26 23:30:04 pwagner Exp $"
d7499 3
@


2.57
log
@Monotonize ptan heights when needed; (should we sort instead?)
@
text
@a6036 1
      integer, dimension(1)            :: indices
d6370 1
a6370 1
        if ( method==l_binTotal ) then
d7299 1
a7299 1
       "$Id: FillUtils_1.f90,v 2.56 2012/04/20 01:06:03 pwagner Exp $"
d7311 3
@


2.56
log
@Changes to bin, ChiSqRatio, and Interpolating to remove bugs, hopefully adding none
@
text
@d67 1
d6037 1
d6081 5
d6087 1
a6087 1
          & nearest=.true., allowTopValue=.true., fail=fail )
d7300 1
a7300 1
       "$Id: FillUtils_1.f90,v 2.55 2012/03/12 17:11:46 pwagner Exp $"
d7312 3
@


2.55
log
@'ln' same as 'log' in manipulate fills; new 'cgrid' switch
@
text
@d1417 2
a1418 1
        qIndex = findLast( flagQty%values(:,i) /= 0._rv )
d3217 1
d3232 5
d3308 11
d5513 1
a5513 1
        & 'Quality quantity must be quality' )
d6282 3
d6298 8
a6344 2
      ! Work out the horizontal mapping, a function of height for unstacked quantities.
      ! Bin to the center of the profiles rather than the edges.
d6364 4
d6387 1
a6387 1
      do qi = 1, quantity%template%noInstances
d6389 1
a6389 1
          if ( count ( surfs == qs .and. insts == qi ) > 0 ) then
d6395 2
a6396 2
                &   sourceQuantity%template%noChans, : ), &
                & surfs == qs .and. insts == qi ) )
d6398 1
a6398 1
                quantity%values(qs,qi) = max ( quantity%values(qs,qi), v )
d6400 1
a6400 1
                quantity%values(qs,qi) = v
d6406 3
a6408 3
                &   sourceQuantity%template%noChans, : ), &
                & surfs == qs .and. insts == qi ) ) / &
                & max ( count ( surfs == qs .and. insts == qi ), 1 )
d6410 1
a6410 1
                quantity%values(qs,qi) = 0.5 * ( quantity%values(qs,qi) + v )
d6412 1
a6412 1
                quantity%values(qs,qi) = v
d6418 2
a6419 2
                &   sourceQuantity%template%noChans, : ), &
                & surfs == qs .and. insts == qi ) )
d6421 1
a6421 1
                quantity%values(qs,qi) = min ( quantity%values(qs,qi), v )
d6423 1
a6423 1
                quantity%values(qs,qi) = v
d6429 2
a6430 2
                &   sourceQuantity%template%noChans, : ), &
                & surfs == qs .and. insts == qi ) )
d6432 1
a6432 1
                quantity%values(qs,qi) = quantity%values(qs,qi) + v
d6434 1
a6434 1
                quantity%values(qs,qi) = v
d6438 1
a6438 1
            quantity%values(qs,qi) = 0.0
d6441 57
a6497 2
      end do

d7293 1
a7293 1
       "$Id: FillUtils_1.f90,v 2.54 2012/02/24 21:22:02 pwagner Exp $"
d7305 3
@


2.54
log
@DirectRead may /interpolate vertically
@
text
@d4265 1
a4265 1
            case ('log')
d5733 1
d5744 2
d5793 3
a5795 1
            & date=quantity%template%time(surfIndex,instance))
d5802 12
d7207 1
a7207 1
       "$Id: FillUtils_1.f90,v 2.53 2012/02/16 22:39:02 pwagner Exp $"
d7219 3
@


2.53
log
@Dont automatically in AutoFillVector
@
text
@d200 6
d5971 1
a5971 1
    subroutine FromProfile ( quantity, valuesNode, &
d5973 1
a5973 2
      ! This fill is slightly complicated.  Given a values array along
      ! the lines of [ 1000mb : 1.0K, 100mb : 1.0K,  10mb : 2.0K] etc. it
d5976 2
a5977 1
      integer, intent(in) :: VALUESNODE   ! Tree node for values
d5986 8
a5993 1
      integer :: HEIGHTUNIT             ! Unit for height
d5996 2
a5997 1
      integer :: I,J                    ! Loop counters / indices
a5999 5
      integer :: TESTUNIT               ! Unit for value
      logical :: Fail                   ! Status from Hunt
      logical :: LOCALOUTHEIGHTS ! Set if out heights is our own variable
      logical :: MYLOGSPACE             ! Interpolate in log space?
      real (r8), dimension(:), pointer :: HEIGHTS ! Heights for the points
a6000 7
      real (r8), dimension(:), pointer :: OUTHEIGHTS ! Heights for output
      real (r8), dimension(:), pointer :: OUTVALUES ! Single profile for output
      logical, dimension(:), pointer :: INSTANCES ! Flags
      logical, dimension(:), pointer :: DUPLICATED ! Flags
      real (r8), dimension(2) :: EXPRVALUE ! Value of expression
      integer, dimension(2) :: EXPRUNIT   ! Unit for expression
      integer, dimension(:), pointer :: ININDS ! Indices
d6003 1
a6003 12
      call MLSMessageCalls( 'push', constantName='FromProfile' )

      ! Check the quantity is amenable to this type of fill
      if ( .not. ValidateVectorQuantity ( quantity, &
        & coherent=.true. ) .and. .not. associated(ptan) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity is not amenable to a profile fill unless you supply ptan' )

      ! Check the units
      testUnit = quantity%template%unit
      if ( globalUnit /= phyq_Invalid ) testUnit = globalUnit

d6007 5
a6011 1
      noPoints = nsons ( valuesNode ) - 1
d6013 2
a6014 1
      call Allocate_test ( heights, noPoints, 'heights', ModuleName )
d6021 3
a6023 31

      ! Loop over the values
      do i = 1, noPoints
        ! Get value from tree
        call expr ( subtree ( i+1, valuesNode ), exprUnit, exprValue )
        ! Check height unit OK
        heightUnit = GetUnitForVerticalCoordinate ( quantity%template%verticalCoordinate )
        if ( associated(ptan) ) heightUnit = PHYQ_Zeta
        if ( exprUnit(1) /= heightUnit .and. exprUnit(1) /= PHYQ_Dimensionless &
          & .and. .not. ( exprUnit(1) == PHYQ_Pressure .and. heightUnit == PHYQ_Zeta ) ) &
          & call Announce_error ( valuesNode, no_Error_Code, 'Bad height units for profile fill' )
        ! Store height
        if ( heightUnit == PHYQ_Zeta ) then
          ! Assume zeta coordinates are expressed in mb
          heights(i) = -log10 ( exprValue(1) )
        else
          heights(i) = exprValue(1)
        end if
        ! Check value unit OK
        if ( all ( exprUnit(2) /= (/ testUnit, PHYQ_Dimensionless /) ) ) &
          & call Announce_error ( valuesNode, no_error_code, 'Bad units for profile fill' )
        ! Store value
        values ( i ) = exprValue(2)
      end do

      if ( myLogSpace .and. any ( values <= 0.0 ) ) then
        call Announce_Error ( valuesNode, no_error_code, &
          & 'Non-positive input data in log profile fill (reset logSpace=false?)' )
        return
      end if
      if ( myLogSpace ) values = log ( values )
d6047 1
a6047 1
          call Announce_Error ( valuesNode, no_error_code, &
d6105 1
a6106 1
      call Deallocate_test ( outValues, 'outValues', ModuleName )
d6109 77
a6185 1
    end subroutine FromProfile
d6821 1
a6821 1
      & filetype, options, sdname, spread )
d6830 1
d6835 1
d6839 1
d6861 1
a6861 1
        & filetype, name, spread )
d6866 1
a6866 1
      & filetype, options, spread )
d6876 1
d6880 1
d6889 1
d6912 5
a6916 3
            call outputNamedValue( 'shape(values)' // trim(name), &
              & shape(quantity%values) )
            call dump( MLSFile )
d6931 1
a6931 1
            & filetype, name, spread )
d7047 1
a7047 1
      & filetype, name, spread )
d7049 2
a7050 1
      use MLSHDF5, only: GETHDF5DSDIMS, LOADFROMHDF5DS
d7057 2
d7060 6
d7068 2
a7069 2
      integer, dimension(3) :: dimInts
      integer(kind=hSize_t), dimension(3) :: dims
d7071 3
a7073 1
      real, dimension(:,:,:), pointer :: values => null()
d7075 1
d7095 51
a7145 1
        if ( .not. spread ) then
a7146 2
        else
          quantity%values = values(1,1,1)
d7150 35
d7190 1
a7190 1
       "$Id: FillUtils_1.f90,v 2.52 2012/01/25 01:18:05 pwagner Exp $"
d7202 3
@


2.52
log
@Fixed most bugs in QtyFromFile and VectorFromFile; now can select by attributes
@
text
@d471 1
a471 1

d483 4
a486 2
            call outputNamedValue( 'molecule', str )
            call outputNamedValue( 'isotoperatio', Catalog(mol)%DefaultIsotopeRatio )
d7043 1
a7043 1
       "$Id: FillUtils_1.f90,v 2.51 2012/01/18 20:38:36 vsnyder Exp $"
d7055 3
@


2.51
log
@Add 'matrix and vector inconsistent' error message
@
text
@a6770 1

d6775 2
a6776 3
      & filetype, hdfversion, options, sdname, spread )
      use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
      use MLSHDF5, only: GETHDF5DSDIMS, GETALLHDF5DSNAMES, LOADFROMHDF5DS
a6780 1
      integer, intent(in) :: HDFVERSION
d6785 3
a6787 2
      type( L2AUXData_T ) :: l2aux ! Result
      type( l2GPData_T ) :: l2gp ! Result
d6789 1
a6789 4
      integer, dimension(3) :: dimInts
      integer(kind=hSize_t), dimension(3) :: dims
      integer :: status
      real, dimension(:,:,:), pointer :: values => null()
a6798 26
        call GetHDF5DSDims ( MLSFile, name, DIMS )
        dimInts = max(dims, int(1,hsize_t))
        select case (lowercase(fileType))
        case ('l2aux')
          if ( spread ) call Announce_Error ( key, no_Error_Code, &
            &   'Unable to use spread when filling from l2aux file' )
          call ReadL2AUXData ( MLSFile, name, quantity%template%quantityType, l2aux )
          call FromL2Aux( quantity, l2aux, status )
          call DestroyL2AUXContents ( l2aux )
        case ('swath', 'l2gp')
          if ( spread ) call Announce_Error ( key, no_Error_Code, &
            &   'Unable to use spread when filling from l2gp file' )
          call ReadL2GPData( MLSFile, name, l2gp )
          call FromL2GP ( quantity, l2gp, .false., -1, status, .true., .false. )
          call DestroyL2GPContents ( l2gp )
        case default ! E.g., 'hdf'
          call Allocate_test ( values, dimInts(1), dimInts(2), dimInts(3), 'values read from file', ModuleName )
          call loadFromHDF5DS ( MLSFile, &
            & trim(Name), values ) ! quantity%values )
          if ( .not. spread ) then
            quantity%values = reshape( values, (/ dimInts(1)*dimInts(2), dimInts(3) /) )
          else
            quantity%values = values(1,1,1)
          endif
          call DeAllocate_test ( values, 'values read from file', ModuleName )
        end select
d6801 9
a6809 2
        call Announce_Error ( key, no_Error_Code, &
        &   'Unable to read Quantity from File by attribute yet' )
d6811 2
d6814 1
a6814 1

d6817 1
a6817 2
      & filetype, hdfversion, options, spread )
      use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
d6819 1
a6819 1
      use MLSHDF5, only: GETHDF5DSDIMS, GETALLHDF5DSNAMES, LOADFROMHDF5DS
a6824 1
      integer, intent(in) :: HDFVERSION
d6832 3
a6834 3
      ! Local variables
      type( L2AUXData_T ) :: l2aux ! Result
      type( l2GPData_T ) :: l2gp ! Result
d6836 1
a6836 4
      integer :: status
      integer, dimension(3) :: dimInts
      integer(kind=hSize_t), dimension(3) :: dims
      real, dimension(:,:,:), pointer :: values => null()
d6860 2
a6861 1
            call outputNamedValue( 'shape(values)' // trim(name), shape(quantity%values) )
a6862 28
            call GetHDF5DSDims ( MLSFile, name, DIMS )
            dimInts = max(dims, int(1,hsize_t))
            call outputNamedValue ( 'dims', dimInts )
            select case (lowercase(fileType))
            case ('l2aux')
              if ( spread ) call Announce_Error ( key, no_Error_Code, &
                &   'Unable to use spread when filling from l2aux file' )
              call ReadL2AUXData ( MLSFile, name, quantity%template%quantityType, l2aux )
              call FromL2Aux( quantity, l2aux, status )
              call DestroyL2AUXContents ( l2aux )
            case ('swath', 'l2gp')
              if ( spread ) call Announce_Error ( key, no_Error_Code, &
                &   'Unable to use spread when filling from l2gp file' )
              call ReadL2GPData( MLSFile, name, l2gp )
              call FromL2GP ( quantity, l2gp, .false., -1, status, .true., .false. )
              call DestroyL2GPContents ( l2gp )
            case default ! E.g., 'hdf'
              call Allocate_test ( values, dimInts(1), dimInts(2), dimInts(3), 'values read from file', ModuleName )
              call loadFromHDF5DS ( MLSFile, &
                & trim(Name), values ) ! quantity%values )
              if ( .not. spread ) then
                quantity%values = reshape( values, (/ dimInts(1)*dimInts(2), dimInts(3) /) )
              else
                quantity%values = values(1,1,1)
              endif
              call DeAllocate_test ( values, 'values read from file', ModuleName )
              call dump( quantity%values, trim(name) // ' values' )
            end select
d6865 9
a6873 2
            call Announce_Error ( key, no_Error_Code, &
            &   'Unable to read Vector from File by attribute yet' )
d6875 3
d6991 47
d7041 1
a7041 1
       "$Id: FillUtils_1.f90,v 2.50 2011/12/15 01:50:26 pwagner Exp $"
d7053 3
@


2.50
log
@Added sdName and /spread fields to DirectRead
@
text
@d150 5
a154 4
  integer, parameter, public :: NotSPD = WrongUnits + 1
  integer, parameter, public :: NotPlain = NotSPD + 1
  integer, parameter, public :: NotImplemented = notPlain + 1
  integer, parameter, public :: BothFractionAndLength = NotImplemented + 1
d157 1
a157 1
  integer, parameter, public :: BadGeocAltitudeQuantity = bothFractionAndLength + 1
d312 2
a331 2
      case ( needGeocAltitude )
        call output ( " fill needs geocAltitudeQuantity.", advance='yes' )
d335 2
d7038 1
a7038 1
       "$Id: FillUtils_1.f90,v 2.49 2011/11/30 21:30:00 pwagner Exp $"
d7050 3
@


2.49
log
@Fixed bug affecting skipped retrievals
@
text
@d6773 1
a6773 1
      & filetype, hdfversion, options )
d6782 2
d6796 4
a6799 1
        call get_string( lit_indices(quantity%template%name), Name )
d6805 2
d6811 2
d6820 5
a6824 1
          quantity%values = reshape( values, (/ dimInts(1)*dimInts(2), dimInts(3) /) )
d6836 1
a6836 1
      & filetype, hdfversion, options )
d6840 1
d6847 1
d6868 51
a6918 38
        ! How do w access the dataset to read? By name or by attribute?
        if ( index(lowercase(options), 'a') < 1 ) then
          ! By name
          if ( quantity%template%name < 1 ) &
            & call Announce_Error ( key, no_Error_Code, &
            &   'template name is 0?' )
          call get_string( quantity%template%name, Name )
          if ( lowercase(trim(name)) /= &
            & lowercase(StringElement( DSNames, dsi, countEmpty )) ) &
            & cycle
          if ( addSlash ) Name = '/' // Name
          call outputNamedValue( 'shape(values)' // trim(name), shape(quantity%values) )
          call dump( MLSFile )
          call GetHDF5DSDims ( MLSFile, name, DIMS )
          dimInts = max(dims, int(1,hsize_t))
          call outputNamedValue ( 'dims', dimInts )
          select case (lowercase(fileType))
          case ('l2aux')
            call ReadL2AUXData ( MLSFile, name, quantity%template%quantityType, l2aux )
            call FromL2Aux( quantity, l2aux, status )
            call DestroyL2AUXContents ( l2aux )
          case ('swath', 'l2gp')
            call ReadL2GPData( MLSFile, name, l2gp )
            call FromL2GP ( quantity, l2gp, .false., -1, status, .true., .false. )
            call DestroyL2GPContents ( l2gp )
          case default ! E.g., 'hdf'
            call Allocate_test ( values, dimInts(1), dimInts(2), dimInts(3), 'values read from file', ModuleName )
            call loadFromHDF5DS ( MLSFile, &
              & trim(Name), values ) ! quantity%values )
            quantity%values = reshape( values, (/ dimInts(1)*dimInts(2), dimInts(3) /) )
            call DeAllocate_test ( values, 'values read from file', ModuleName )
            call dump( quantity%values, trim(name) // ' values' )
          end select
        else
          ! By attribute
          call Announce_Error ( key, no_Error_Code, &
          &   'Unable to read Quantity from File by attribute yet' )
        endif
d7035 1
a7035 1
       "$Id: FillUtils_1.f90,v 2.48 2011/11/04 23:46:45 pwagner Exp $"
d7047 3
@


2.48
log
@Fixed bug added with last commit
@
text
@d1692 2
a1693 1
        quantity%values(1,:) = scale * sourceQuantity%values(qIndex,1)
d7007 1
a7007 1
       "$Id: FillUtils_1.f90,v 2.47 2011/11/04 00:24:39 pwagner Exp $"
d7019 3
@


2.47
log
@Added procedures to auto special qties in a vector, fill a qty from a file, and fill a vector from a file
@
text
@a3551 1

d4107 1
a4107 1
        n = NumStringElements( trim(str), countEmpty, &
d4120 1
a4120 1
            & countEmpty, inseparator=' ' )
d4164 2
d7006 1
a7006 1
       "$Id: FillUtils_1.f90,v 2.46 2011/07/20 00:53:40 pwagner Exp $"
d7018 3
@


2.46
log
@Fixed bug added in rev2.43
@
text
@d21 1
d50 1
a50 1
  use INTRINSIC, only: &
d55 3
a57 2
  use L2GPDATA, only: L2GPDATA_T
  use L2AUXDATA, only: L2AUXDATA_T
d72 3
a74 2
  use MLSSIGNALS_M, only: GETFIRSTCHANNEL, GETSIGNALNAME, GETMODULENAME, ISMODULESPACECRAFT, &
    & GETSIGNAL, SIGNAL_T
d78 1
a78 1
    & REPLACESUBSTRING, SWITCHDETAIL
d84 3
a86 1
  use SCANMODELMODULE, only: GETBASISGPH, GET2DHYDROSTATICTANGENTPRESSURE, GETGPHPRECISION
d110 1
d121 1
d178 1
a178 1
  public :: addGaussianNoise, ApplyBaseline, &
d197 1
a197 1
      & ANNOUNCE_ERROR
d458 30
d3204 1
d3276 8
a3922 1
        logical, parameter :: COUNTEMPTY = .true.
d4108 1
a4108 1
        n = NumStringElements( trim(str), countEmpty=.false., &
d4121 1
a4121 1
            & countEmpty=.false., inseparator=' ' )
d6769 124
d7005 1
a7005 1
       "$Id: FillUtils_1.f90,v 2.45 2011/06/16 20:51:24 vsnyder Exp $"
d7017 3
@


2.45
log
@Make Announce_Error codes public
@
text
@d16 6
a21 6
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Chunks_m, only: MLSChunk_T
  use Constants, only: Deg2Rad, Rad2Deg
  use Expr_M, only: EXPR, EXPR_CHECK, GetIndexFlagsFromList
  use GriddedData, only: GriddedData_T, WrapGriddedData
  ! Now the literals:
d49 7
a55 7
  use Intrinsic, only: &
    & PHYQ_Dimensionless, PHYQ_Invalid, PHYQ_Temperature, &
    & PHYQ_Length, PHYQ_Pressure, PHYQ_Zeta, PHYQ_Angle
  use L1BData, only: DeallocateL1BData, Dump, GetL1BFile, L1BData_T, &
    & PRECISIONSUFFIX, ReadL1BData, AssembleL1BQtyName
  use L2GPData, only: L2GPData_T
  use L2AUXData, only: L2AUXData_T
d57 1
a57 1
  use ManipulateVectorQuantities, only: DOFGRIDSMATCH, DOHGRIDSMATCH, &
d59 15
a73 15
  use MatrixModule_0, only: Sparsify, MatrixInversion
  use MatrixModule_1, only: Dump, FindBlock, Matrix_SPD_T, UpdateDiagonal
  ! NOTE: If you ever want to include defined assignment for matrices, please
  ! carefully check out the code around the call to snoop.
  use MLSCommon, only: MLSFile_T, DEFAULTUNDEFINEDVALUE
  use MLSFiles, only: GetMLSFileByType
  use MLSKinds, only: R4, R8, RM, RV
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning, &
    & MLSMSG_Allocate, MLSMSG_Deallocate, MLSMessageCalls
  use MLSNumerics, only: InterpolateValues, Hunt
  use MLSSets, only: FindFirst, FindLast
  use MLSSignals_m, only: GetFirstChannel, GetSignalName, GetModuleName, IsModuleSpacecraft, &
    & GetSignal, Signal_T
  use MLSStats1, only: MLSMIN, MLSMAX, MLSMEAN, MLSMEDIAN, MLSRMS, MLSSTDDEV
  use MLSStringLists, only: CATLISTS, EXPANDSTRINGRANGE, GETSTRINGELEMENT, &
d76 2
a77 2
  use MLSStrings, only: INDEXES, LOWERCASE, SPLITNEST
  use Molecules, only: L_H2O
d79 4
a82 4
  use QuantityTemplates, only: Epoch, QuantityTemplate_T
  use RHIFromH2O, only: H2OPrecFromRHI, RHIFromH2O_Factor, RHIPrecFromH2O
  use ScanModelModule, only: GetBasisGPH, Get2DHydrostaticTangentPressure, GetGPHPrecision
  use String_Table, only: Display_String, get_string
d87 1
a87 1
  use Tree_Types, only: N_COLON_LESS, N_LESS_COLON, &
d89 8
a96 8
  use VectorsModule, only: &
    & ClearUnderMask, CopyVector, CreateMask, &
    & DestroyVectorInfo, Dump, &
    & GetVectorQtyByTemplateIndex, GetVectorQuantityByType, &
    & isVectorQtyMasked, MaskVectorQty, &
    & ValidateVectorQuantity, Vector_T, &
    & VectorValue_T, M_Cloud, M_Fill, M_Ignore, M_LinAlg
  use VGridsDatabase, only: GETUNITFORVERTICALCOORDINATE
d197 1
a197 1
      use MLSRandomNumber, only: drang
d253 3
a255 3
      use Dump_0, only: Dump
      use Intrinsic, only: Field_indices, PHYQ_Indices
      use MoreTree, only: Get_Field_Id, StartErrorMessage
d759 1
a759 1
      use MoreTree, only: Get_Field_Id
d2292 1
a2292 1
      use BitStuff, only: biteq
d2349 1
a2349 1
      use Geometry, only: EarthRadA, EarthRadB, GEODTOGEOCLAT
d2352 1
a2352 1
      use Phi_Refractive_Correction_m, only: Phi_Refractive_Correction_Up
d2385 1
a2385 1
        & call Announce_error ( key, no_error_code, 'Problem with temperature quantity for phiTan fill' )
d3109 3
a3111 3
      use IO_stuff, only: GET_LUN
      use Machine, only: IO_Error
      use MoreMessage, only: MLSMessage
d3546 1
a3546 1
          else
d4476 1
a4476 1
      use BitStuff, only: NegativeIfBitPatternSet
d4754 2
a4755 2
      use Geometry, only: SecPerYear
      use IGRF_INT, only: FELDC, FELDCOF, To_Cart
d4998 1
a4998 1
      use MLSSignals_m, only: signals
d5114 3
a5116 3
      use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
      use dump_0, only: dump
      use MLSFillValues, only: IsFillValue, RemoveFillValues
d5491 1
a5491 1
      use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d5665 2
a5666 2
      use dump_0, only: dump
      use Griddeddata, only: dump
d6836 1
a6836 1
       "$Id: FillUtils_1.f90,v 2.44 2011/04/20 16:46:00 pwagner Exp $"
d6848 3
@


2.44
log
@Fixed solecism that NAG complained about
@
text
@d123 3
a125 3
  integer, parameter :: No_Error_code = 0
  integer, parameter :: CantFromL2AUX = No_Error_code + 1
  integer, parameter :: CantFromL1B = cantFromL2AUX + 1
d128 1
a128 1
  integer, parameter :: MissingField = cantFromL1B + 1
d131 10
a140 10
  integer, parameter :: NumChansisZero = missingField + 1
  integer, parameter :: NoSourceGridGiven= numChansisZero + 1
  integer, parameter :: NoSourceL2GPGiven= noSourceGridGiven + 1
  integer, parameter :: NoSourceL2AUXGiven= noSourceL2GPGiven + 1
  integer, parameter :: NoExplicitValuesGiven= noSourceL2AUXGiven + 1
  integer, parameter :: InvalidExplicitFill = noExplicitValuesGiven + 1
  integer, parameter :: BadIsotopeFill = invalidExplicitFill + 1
  integer, parameter :: BadlosGridFill = badIsotopeFill + 1
  integer, parameter :: CantInterpolate3d = badlosGridFill + 1
  integer, parameter :: WrongUnits = CantInterpolate3d + 1
d143 4
a146 4
  integer, parameter :: NotSPD = WrongUnits + 1
  integer, parameter :: NotPlain = NotSPD + 1
  integer, parameter :: NotImplemented = notPlain + 1
  integer, parameter :: BothFractionAndLength = NotImplemented + 1
d149 19
a167 18
  integer, parameter :: Miscellaneous_err = BothFractionAndLength + 1
  integer, parameter :: ErrorReadingL1B = miscellaneous_err + 1
  integer, parameter :: NeedTempREFGPH = errorReadingL1B + 1
  integer, parameter :: NeedH2O = needTempRefGPH + 1
  integer, parameter :: NeedOrbitInclination = needH2O + 1
  integer, parameter :: NeedGeocAltitude = needOrbitInclination + 1
  integer, parameter :: BadGeocAltitudeQuantity = needGeocAltitude + 1
  integer, parameter :: BadTemperatureQuantity = badGeocAltitudeQuantity + 1
  integer, parameter :: BadREFGPHQuantity = badTemperatureQuantity + 1
  integer, parameter :: NonConformingHydrostatic = badREFGPHQuantity + 1
  integer, parameter :: NoSpecialFill = nonConformingHydrostatic + 1
  integer, parameter :: NoTotalPower = noSpecialFill + 1
  integer, parameter :: BadlosVelFill = noTotalPower + 1
  integer, parameter :: NotZetaForGrid = BadLosVelFill + 1
  integer, parameter :: BadEstNoiseFill = NotZetaForGrid + 1
  integer, parameter :: BadRefractFill = BadEstNoiseFill + 1
  integer, parameter :: MissingDataInGrid = BadRefractFill + 1
  integer, parameter :: EmptyGridForFill = MissingDataInGrid + 1
d171 2
a172 1
  public :: addGaussianNoise, ApplyBaseline, ComputeTotalPower, DeallocateStuff, &
d191 1
d324 3
d6836 1
a6836 1
       "$Id: FillUtils_1.f90,v 2.43 2011/04/13 00:28:15 pwagner Exp $"
d6848 3
@


2.43
log
@manipulation can now accept digits
@
text
@d3491 1
a3491 1
      integer :: I, INSTANCE, ISURF
a3492 4
      logical :: NEEDSB
      integer :: NoChans
      integer :: NoInstances
      integer :: NoSurfs
a3495 1
      real(rv) :: qvalue
d3509 1
a3509 1
        & index( &
d3511 1
a3511 1
        &   (/ 'min', 'max', 'mean', 'median', 'rms', 'stddev' /) &
d6830 1
a6830 1
       "$Id: FillUtils_1.f90,v 2.42 2011/04/07 23:35:31 pwagner Exp $"
d6842 3
@


2.42
log
@Fixed bug in handling manipulation='(c - c*a)*b'
@
text
@a3486 25
      integer, parameter :: NO2WAYMANIPULATIONS = 8
      character(len=*), parameter :: VALID2WAYMANIPULATIONS ( NO2WAYMANIPULATIONS ) = (/ &
        & 'a+b     ', &
        & '(a+b)/2 ', &
        & 'a-b     ', &
        & 'a*b     ', &
        & 'a>b     ', &
        & 'a<b     ', &
        & 'a|b     ', &
        & 'a/b     ' /)
      integer, parameter :: NO1WAYMANIPULATIONS = 13
      character(len=*), parameter :: VALID1WAYMANIPULATIONS ( NO1WAYMANIPULATIONS ) = (/ &
        & '-a         ', &
        & '1/a        ', &
        & 'abs(a)     ', &
        & 'sign(a)    ', &
        & 'exp(a)     ', &
        & 'log(a)     ', &
        & 'log10(a)   ', &
        & 'min(a)     ', &
        & 'max(a)     ', &
        & 'mean(a)    ', &
        & 'median(a)  ', &
        & 'rms(a)     ', &
        & 'stddev(a)  ' /)
a3499 1
      logical :: OneWay
a3500 1
      logical :: TwoWay
a3510 2
      OneWay = any ( mstr == valid1WayManipulations )
      TwoWay = any ( mstr == valid2WayManipulations )
d3512 7
a3518 1
      StatisticalFunction = ( FindFirst( valid1WayManipulations, mstr ) > 7 )
a3519 11
      if ( .not. ( OneWay .or. TwoWay .or. usesc ) ) then
        if ( autoRecognizeGeneralExp ) then
          usesC = .true.
          call MLSMessage ( MLSMSG_Warning, moduleName, &
            & 'Automatically recognizing general manipulation: ' // trim(mstr) )
        else
          call Announce_Error ( key, no_error_code, 'Invalid manipulation:' &
            & // trim(mstr) )
          return
        end if
      end if
d3521 1
a3521 26
      needsB = TwoWay .or. (usesC .and. (index(mstr, 'b') > 0) )

      ! Now check the sanity of the request.
      if ( OneWay .or. usesc ) then
        numWays = 1
        if ( .not. associated ( a ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'You must supply the a quantity' )
          return
        end if
      elseif ( TwoWay ) then
        numWays = 2
        if ( .not. associated ( a ) .or. .not. associated ( b ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'You must supply both a and b quantities' )
          return
        end if
      end if

      if ( DEEBUG ) then
        call outputNamedValue( 'mstr', mstr )
        call outputNamedValue( 'numWays', numWays )
        call outputNamedValue( 'StatisticalFunction', StatisticalFunction )
        call outputNamedValue( 'MapFunction', MapFunction )
        call outputNamedValue( 'usesc', usesc )
      endif
d3525 1
d3529 1
a3544 6
          else if ( mstr == 'a*b' ) then
            ! In this case, just check that the coordinate systems for these quantities match
            okSoFar = okSoFar .and. &
              & DoHGridsMatch ( quantity, aorb ) .and. &
              & DoVGridsMatch ( quantity, aorb ) .and. &
              & DoFGridsMatch ( quantity, aorb, sizeOnly=.true. )
a3565 68
      ! OK do the simple work for now
      ! Below we'll do fancy stuff to parse the more general manipulations
      if ( StatisticalFunction ) then
        NoChans     = a%template%NoChans
        NoInstances = a%template%NoInstances
        NoSurfs     = a%template%NoSurfs
        if ( dontSumHeights .and. dontSumInstances ) then
          do instance = 1, NoInstances
            do iSurf = 1, NoSurfs
              call doStatFun( quantity%values(iSurf, instance), mstr, &
                & a%values(1+(iSurf-1)*NoChans:iSurf*NoChans, instance) )
            enddo
          enddo
        elseif ( dontSumInstances ) then
          do instance = 1, NoInstances
            call doStatFun( qvalue, mstr, &
              & a%values(:, instance) )
            if ( spreadFlag ) then
              quantity%values(:, instance) = qvalue
            else
              quantity%values(1, instance) = qvalue
            endif
          enddo
        elseif ( dontSumHeights ) then
          do iSurf = 1, NoSurfs
            call doStatFun( qvalue, mstr, &
              & a%values(iSurf, :) )
            if ( spreadFlag ) then
              quantity%values(iSurf, :) = qvalue
            else
              quantity%values(iSurf, 1) = qvalue
            endif
          enddo
        else
          ! Sum over both heights and instances
          select case ( mstr )
          case ( 'min(a)' )
            qvalue = mlsmin( a%values )
          case ( 'max(a)' )
            qvalue = mlsmax( a%values )
          case ( 'mean(a)' )
            qvalue = mlsmean( a%values )
          case ( 'median(a)' )
            qvalue = mlsmedian( a%values )
          case ( 'rms(a)' )
            qvalue = mlsrms( a%values )
          case ( 'stddev(a)' )
            qvalue = mlsstddev( a%values )
          case default
            ! Should not have come here
          end select
          if ( spreadFlag ) then
            if ( .not. associated ( quantity%mask ) ) then
              quantity%values = qvalue
            else
              where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
                quantity%values = qvalue
              end where
            end if
          else
            quantity%values(1, 1) = qvalue
          endif
        endif
        call MLSMessageCalls( 'pop' )
        if ( SwitchDetail(switches, 'stat') > -1 ) &
          & call dump( quantity%values, mstr )
        return
      endif
a3566 49
      ! The binary manipulations
      case ( 'a+b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = a%values + b%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = a%values + b%values
          end where
        end if
      case ( '(a+b)/2' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = 0.5 * ( a%values + b%values )
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = 0.5 * ( a%values + b%values )
          end where
        end if
      case ( 'a-b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = a%values - b%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = a%values - b%values
          end where
        end if
      case ( 'a*b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = a%values * b%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = a%values * b%values
          end where
        end if
      case ( 'a>b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = max ( a%values, b%values )
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = max ( a%values, b%values )
          end where
        end if
      case ( 'a<b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = min ( a%values, b%values )
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = min ( a%values, b%values )
          end where
        end if
d3568 1
a3575 100
      case ( 'a/b' )
        if ( .not. associated ( quantity%mask ) ) then
          where ( b%values /= 0._rv )
            quantity%values = a%values / b%values
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( b%values /= 0._rv ) )
            quantity%values = a%values / b%values
          end where
        end if
      ! The unary manipulations
      case ( '-a'  )
        if ( .not. associated ( quantity%mask ) ) then
            quantity%values = -a%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0  )
            quantity%values = -a%values
          end where
        end if
      case ( '1/a'  )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values /= 0._rv )
            quantity%values = 1./a%values
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values /= 0._rv ) )
            quantity%values = 1./a%values
          end where
        end if
      case ( 'abs(a)'  )
        if ( .not. associated ( quantity%mask ) ) then
            quantity%values = abs(a%values)
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0  )
            quantity%values = abs(a%values)
          end where
        end if
      case ( 'sign(a)' )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values /= 0._rv )
            quantity%values = sign(1._rv, a%values)
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values /= 0._rv ) )
            quantity%values = sign(1._rv, a%values)
          end where
        end if
      case ( 'exp(a)'  )
        if ( .not. associated ( quantity%mask ) ) then
            quantity%values = exp(a%values)
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0  )
            quantity%values = exp(a%values)
          end where
        end if
      case ( 'log(a)' )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values > 0._rv )
            quantity%values = log(a%values)
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values > 0._rv ) )
            quantity%values = log(a%values)
          end where
        end if
      case ( 'log10(a)' )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values > 0._rv )
            quantity%values = log10(a%values)
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values > 0._rv ) )
            quantity%values = log10(a%values)
          end where
        end if
      ! Special manipulation with c as exponent or base
      case ( 'a^c', 'a**c'  )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values > 0._rv )
            quantity%values = a%values**c
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values > 0._rv ) )
            quantity%values = a%values**c
          end where
        end if
      case ( 'c^a', 'c**a'  )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = c**a%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = c**a%values
          end where
        end if
d3637 4
d3650 1
a3650 1
        ! logical, parameter :: DEEBUG = .false.
d3657 12
d3719 6
d3807 60
d4021 1
a4021 1
        ! logical, parameter              :: DEEBUG = .false.
d4043 1
d4123 1
d4126 11
d4138 1
d4188 2
d4196 8
d4224 1
a4224 1
            case ('channel', 'surface', 'instance')
d4233 2
d4243 8
d4254 9
d4434 1
a4434 1
          ! Mark this as a function "hungry" for an arg
d6835 1
a6835 1
       "$Id: FillUtils_1.f90,v 2.41 2011/03/08 18:29:22 pwagner Exp $"
d6847 3
@


2.41
log
@Added shift,slip,chaannel,surface,instance functions to manipulate fills
@
text
@d3925 1
a3925 1
        logical, parameter :: DEEBUG = .false.
d4111 1
a4111 1
          ! but not if it's not simple
d4114 1
a4114 1
            & index(element, ')')  < 1 ) then
d4218 1
a4218 1
        logical, parameter              :: DEEBUG = .false.
d4263 1
d4265 1
d4317 1
d4322 1
d4603 8
d5293 1
a5293 1
      logical, parameter :: DEEBUG = .false.
d6989 1
a6989 1
       "$Id: FillUtils_1.f90,v 2.40 2010/07/06 16:05:37 pwagner Exp $"
d7001 3
@


2.40
log
@Better error checking in MaanipulateVectors
@
text
@d3517 1
d3542 1
d3578 1
d3594 2
d3919 1
d3928 1
d4043 1
d4049 5
d4224 1
d4388 2
d4393 66
d6977 1
a6977 1
       "$Id: FillUtils_1.f90,v 2.39 2010/07/01 00:49:33 pwagner Exp $"
d6989 3
@


2.39
log
@Transfer between vectors may now also manipulate
@
text
@d6172 1
a6172 1
        if ( associated ( dq ) ) then
d6178 3
d6895 1
a6895 1
       "$Id: FillUtils_1.f90,v 2.38 2010/06/18 16:48:34 pwagner Exp $"
d6907 3
@


2.38
log
@Corrected error that prevented filling radiances qty from l1b
@
text
@d182 1
a182 1
      & ByManipulation, WithReflectorTemperature, &
d6150 32
d6892 1
a6892 1
       "$Id: FillUtils_1.f90,v 2.37 2010/05/24 16:33:52 honghanh Exp $"
d6904 3
@


2.37
log
@Merge changes in version 2.35 and 2.36
@
text
@a68 1
  use MLSRandomNumber, only: drang
d194 1
a251 1
      use MLSMessageModule, only: MLSMSG_Warning, MLSMessage
a252 1
      use String_Table, only: Display_String
a755 1
      use VectorsModule, only: GETVECTORQUANTITYBYTYPE
a3450 1
      use String_table, only: GET_STRING
d4520 13
a4536 2
      use MLSStrings, only: lowercase
      use output_m, only: blanks, output
d4542 1
a4542 1
      integer, intent(in), optional :: SUFFIX
a4557 1
      integer                               :: this_hdfVersion
d4565 1
a4565 1
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
a4566 1
      this_hdfVersion = L1BFile%HDFVersion
d4572 1
a4572 1
        nameString = AssembleL1BQtyName('ECRtoFOV', this_hdfVersion, .TRUE., &
d4577 1
a4577 1
        nameString = AssembleL1BQtyName(nameString, this_hdfVersion, .FALSE.)
d4579 1
a4579 1
        if ( this_hdfVersion == HDFVERSION_5 ) then
d4581 1
a4581 1
          nameString = AssembleL1BQtyName ('MIF_TAI', this_hdfVersion, .FALSE., &
d4588 1
a4588 1
        nameString = AssembleL1BQtyName ('LosVel', this_hdfVersion, .TRUE., &
d4591 1
a4591 1
        nameString = AssembleL1BQtyName('OrbIncl', this_hdfVersion, .FALSE., &
d4595 1
a4595 1
        nameString = AssembleL1BQtyName('ptan', this_hdfVersion, .FALSE., &
d4600 1
a4600 3
        nameString = AssembleL1BQtyName(nameString, this_hdfVersion, .FALSE.)
        L1BFile => GetL1bFile(filedatabase, namestring)
        ! fileID = FindL1BData (filedatabase, nameString )
d4602 1
a4602 1
        nameString = AssembleL1BQtyName('ECI', this_hdfVersion, .FALSE., 'sc')
d4604 1
a4604 1
        nameString = AssembleL1BQtyName('GeocAlt', this_hdfVersion, .FALSE., &
d4607 1
a4607 1
        nameString = AssembleL1BQtyName('Vel', this_hdfVersion, .FALSE., 'sc')
d4609 1
a4609 1
        nameString = AssembleL1BQtyName('VelECI', this_hdfVersion, .FALSE., &
d4612 1
a4612 1
        nameString = AssembleL1BQtyName('VelECR', this_hdfVersion, .FALSE., &
d4616 1
a4616 1
        nameString = AssembleL1BQtyName('ECI', this_hdfVersion, .TRUE., &
d4620 1
a4620 1
        nameString = AssembleL1BQtyName('GeocAlt', this_hdfVersion, .TRUE., &
d4624 1
a4624 1
        nameString = AssembleL1BQtyName('GeodAlt', this_hdfVersion, .TRUE., &
d4633 1
a4633 1
        moduleNameString = AssembleL1BQtyName('BO_stat', this_hdfVersion, .TRUE., &
d4641 9
a4649 9
      if ( present ( suffix ) ) then
        if ( suffix /= 0 ) then
          call Get_String ( suffix, &
            & nameString(len_trim(nameString)+1:), strip=.true. )
          ! Look for the field again
          L1BFile => GetL1bFile(filedatabase, namestring)
          ! fileID = FindL1BData (filedatabase, nameString )
          ! Note we won't find it if it's in the OA file, I'm going to ignore that
          ! possibility for the moment.
d4651 8
a4658 1
        end if
d4660 13
a4672 24

      ! If the quantity exists (or it doesn't exist but it's not a radiance)
      if ( index(lowercase(namestring), 'baseline') > 0 .and. .false. ) then
        call output('namestring: ', advance='no')
        call output(trim(namestring), advance='yes')
        call output('associated(L1BFile): ', advance='no')
        call output(associated(L1BFile), advance='yes')
        call output('qty type: ', advance='no')
        call output(quantity%template%quantityType, advance='no')
        call blanks(3)
        call output(l_radiance, advance='no')
        call blanks(3)
        call output(l_L1BMAFBaseline, advance='yes')
      endif
      if ( quantity%template%quantityType /= l_radiance .and. &
        & quantity%template%quantityType /= l_L1BMAFBaseline ) then
        if ( isPrecision ) nameString = trim(nameString) // PRECISIONSUFFIX
        L1BFile => GetL1bFile(filedatabase, namestring)
        if (associated(L1BFile)) then
           call ReadL1BData ( L1BFile, nameString, l1bData, noMAFs, flag, &
             & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
             & NeverFail= .false., &
             & dontPad=DONTPAD )
           ! If it didn't exist in the not-a-radiance case, then we'll fail here.
a4673 4
           flag = 1 ! Just a trick, so we reuse the printing of error message
        end if
        ! If it didn't exist in the not-a-radiance case, then we'll fail here.
        if ( flag /= 0 ) then
d4675 32
a4706 7
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FromL1B")
          return
        end if
        if ( quantity%template%noInstances /= size ( l1bData%dpField, 3 ) .or. &
          &  quantity%template%instanceLen /= &
          &   size ( l1bData%dpField, 1 ) * size ( l1bData%dpField, 2 ) ) then
d4721 18
a4738 5
          call Announce_Error ( root, no_error_code, 'L1B data is wrong shape' )
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FromL1B")
          return
        end if
d4740 7
a4746 45
        if ( isPrecision .and. myBOMask /= 0 .and. BO_error == 0 ) then
          noMAFs = size(l1bData%dpField, 3)
          maxMIFs = l1bData%maxMIFs
          if ( switchDetail(switches, 'glob') > 0 ) then ! e.g., 'glob1'
            call output ( 'Quantity shape:' )
            call output ( quantity%template%instanceLen )
            call output ( ' ( ' )
            call output ( quantity%template%noChans )
            call output ( ', ' )
            call output ( quantity%template%noSurfs )
            call output ( ' ), ' )
            call output ( quantity%template%noInstances, advance='yes' )
            call output ( 'L1B shape:' )
            call output ( size ( l1bData%dpField, 1 ) )
            call output ( ', ' )
            call output ( size ( l1bData%dpField, 2 ) )
            call output ( ', ' )
            call output ( size ( l1bData%dpField, 3 ), advance='yes' )
            call outputNamedValue( 'shape' // trim(namestring), shape(l1bData%dpField) )
            call outputNamedValue( 'shape(BO_stat)', shape(BO_stat%intField) )
            call outputNamedValue( 'noMAFs', noMAFs )
            call outputNamedValue( 'maxMIFs', maxMIFs )
            call outputNamedValue( 'noChans', quantity%template%noChans )
          endif
          if ( switchDetail(switches, 'glob') > 1 ) then ! e.g., 'glob2'
            call dump( l1bData%dpField(1,:,:), '(Before applying bright object mask)' )
          endif
          do channel = 1, quantity%template%noChans
          l1bData%dpField(channel,:,:) = &
            & NegativeIfBitPatternSet( l1bData%dpField(channel,:,:), &
            & BO_stat%intField(1, 1:maxMIFs, 1:noMAFs), myBOMask )
          enddo
          if ( switchDetail(switches, 'glob') > 1 ) &
            & call dump( l1bData%dpField(1,:,:), '(After applying bright object mask)' )
          call DeallocateL1BData(BO_stat)
        end if

        quantity%values = RESHAPE(l1bData%dpField, &
          & (/ quantity%template%instanceLen, quantity%template%noInstances /) )
        if ( isPrecision ) then
          do column=1, size(quantity%values(1, :))
            do row=1, size(quantity%values(:, 1))
              if ( quantity%values(row, column) < 0.d0 ) &
                & call MaskVectorQty(quantity, row, column, M_LinAlg)
            end do
d4748 6
a4753 6
        else if ( present(precisionQuantity) ) then
          do column=1, size(quantity%values(1, :))
            do row=1, size(quantity%values(:, 1))
              if ( isVectorQtyMasked(precisionQuantity, row, column, M_LinAlg) ) &
                & call MaskVectorQty(quantity, row, column, M_LinAlg)
            end do
d4755 7
a4761 19
          do column=1, size(quantity%values(1, :))
            do row=1, size(quantity%values(:, 1))
              if ( precisionQuantity%values(row, column) < 0.d0 ) then
                call MaskVectorQty(quantity, row, column, M_Ignore)
                call MaskVectorQty(quantity, row, column, M_LinAlg)
              endif
            end do
          end do
        end if

        if ( switchDetail(switches, 'l1b') > -1 ) &
          & call Dump( l1bData )
        call DeallocateL1BData(l1bData)
      else
        ! This is the case where it's a radiance we're after and it's missing
        quantity%values = DEFAULTUNDEFINEDVALUE ! -1.0
        do column=1, size(quantity%values(1,:))
          do row=1, size(quantity%values(:,1))
            call MaskVectorQty ( quantity, row, column, M_LinAlg )
d4765 4
a5175 1
      use output_m, only: output
a5551 1
      use MLSKinds, only: R8
d6860 1
a6860 1
       "$Id: FillUtils_1.f90,v 2.35 2010/05/19 23:06:45 pwagner Exp $"
d6872 3
@


2.36
log
@Fix a bug in FromL1B to check if L1Bfile is associated before reading from it
@
text
@d125 2
a126 2
  integer, parameter :: CantFillFromL2AUX = No_Error_code + 1
  integer, parameter :: CantFillFromL1B = cantFillFromL2AUX + 1
d129 1
a129 1
  integer, parameter :: MissingField = cantFillFromL1B + 1
d131 1
a131 1
  ! More Error codes relating to FillVector
d143 1
a143 1
  ! Error codes resulting from FillCovariance
d172 16
a187 16
      & ExtractSingleChannel, FillCovariance, FillVectorQuantityFromGrid, &
      & FillVectorQuantityFromL2GP, FillVectorQtyFromProfile, FillLOSVelocity, &
      & FillChiSqChan, FillChiSqMMaf, FillChiSqMMif, FillChiSqRatio, &
      & FillColAbundance, FillFoldedRadiance, FillPhiTanWithRefraction, &
      & FillIWCFromExtinction, FillRHIFromH2O, FillNoRadsPerMIF, &
      & FillRHIPrecisionFromOrToH2O, FillVectorQtyWithEstNoise, &
      & FillVectorQtyHydrostatically, FillFromSplitSideband, FillGPHPrecision, &
      & FillVectorQtyFromIsotope, FillQuantityFromAsciiFile, RotateMagneticField, &
      & ExplicitFillVectorQuantity, FillVectorQuantityFromL1B, &
      & FillVectorQuantityFromL2AUX, FillQuantityUsingMagneticModel, &
      & FillQtyFromInterpolatedQty, FillQuantityFromLosGrid, &
      & FillQuantityByManipulation, FillWithReflectorTemperature, &
      & FillQtyWithReichlerWMOTP, &
      & FillQtyWithWMOTropopause, FillWithBinResults, FillWithBoxcarFunction, &
      & FillStatusQuantity, FillQualityFromChisq, FillConvergenceFromChisq, &
      & FillUsingLeastSquares, OffsetRadianceQuantity, ResetUnusedRadiances, &
d293 1
a293 1
      case ( cantFillFromL1B )
d295 1
a295 1
      case ( cantFillFromL2AUX )
d467 2
a468 2
    !=============================================== ExplicitFillVectorQuantity ==
    subroutine ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
d502 2
a503 2
      !   e              replace only values in quantity == FillValue
      !   n              replace only values in quantity != FillValue
d509 1
a509 1
      type (VectorValue_T), optional :: EXTRAQUANTITY ! Instead of FillValue
d519 1
a519 1
      real(kind(quantity%values)) :: myFillValue
a520 1
      integer :: Node
d554 2
a555 2
      myFillValue = 0.
      if ( present(FillValue) ) myFillValue = FillValue
d727 1
a727 1
              if ( quantity%values(j,i) == myFillValue ) cycle
d729 1
a729 1
              if ( quantity%values(j,i) /= myFillValue ) cycle
d751 1
a751 1
    end subroutine ExplicitFillVectorQuantity
d861 2
a862 2
    ! ------------------------------------------- FillChiSqChan ---
    subroutine FillChiSqChan ( key, qty, measQty, modelQty, noiseQty, &
d991 1
a991 1
    end subroutine FillChiSqChan
d993 2
a994 2
    ! ------------------------------------------- FillChiSqMMaf ---
    subroutine FillChiSqMMaf ( key, qty, measQty, modelQty, noiseQty, &
d1129 1
a1129 1
    end subroutine FillChiSqMMaf
d1131 2
a1132 2
    ! ------------------------------------------- FillChiSqMMif ---
    subroutine FillChiSqMMif ( key, qty, measQty, modelQty, noiseQty, &
d1263 1
a1263 1
    end subroutine FillChiSqMMif
d1265 2
a1266 2
    ! ------------------------------------------- FillChiSqRatio ---
    subroutine FillChiSqRatio ( key, qty, normQty, minNormQty, flagQty, &
d1385 1
a1385 1
    end subroutine FillChiSqRatio
d1387 2
a1388 2
    ! ------------------------------------------- FillColAbundance ---
    subroutine FillColAbundance ( key, qty, bndPressQty, vmrQty, colmAbUnits, &
d1632 1
a1632 1
    end subroutine FillColAbundance
d1634 2
a1635 2
    ! -------------------------------------------- FillConvergenceFromChisq --------
    subroutine FillConvergenceFromChisq ( key, quantity, sourceQuantity, scale )
d1654 1
a1654 1
    end subroutine FillConvergenceFromChisq
d1752 1
a1752 1
            & "Unable to handle irregular quantity in FillCovariance" )
d1826 2
a1827 2
    ! ------------------------------------- FillFoldedRadiance ---
    subroutine FillFoldedRadiance ( radiance, lsb, usb, &
d1888 1
a1888 1
    end subroutine FillFoldedRadiance
d1890 2
a1891 2
    ! ------------------------------------- FillFromSplitSideband ----
    subroutine FillFromSplitSideband ( quantity, sourceQuantity, &
d2079 1
a2079 1
    end subroutine FillFromSplitSideband
d2081 2
a2082 2
    ! ------------------------------------- FillGPHPrecision ----
    subroutine FillGPHPrecision ( key, quantity, &
d2097 1
a2097 1
        & call trace_begin ( "FillGPHPrecision", key )
d2110 1
a2110 1
            & call trace_end ( "FillGPHPrecision")
d2119 1
a2119 1
            & call trace_end ( "FillGPHPrecision")
d2124 1
a2124 1
        call Announce_error ( 0, no_error_code, 'GPH precision needed for result of FillGPHPrecision' )
d2128 1
a2128 1
        & call trace_end ( "FillGPHPrecision" )
d2130 1
a2130 1
    end subroutine FillGPHPrecision
d2132 2
a2133 2
      ! ------------------------------------- FillIWCFromExtinction ----
    subroutine FillIWCFromExtinction ( quantity, &
d2149 1
a2149 1
      call MLSMessageCalls( 'push', constantName='FillIWCFromExtinction' )
d2204 1
a2204 1
    end subroutine FillIWCFromExtinction
d2206 2
a2207 2
    ! ------------------------------------------- FillLOSVelocity ---
    subroutine FillLOSVelocity ( key, qty, tngtECI, scECI, scVel)
d2285 1
a2285 1
    end subroutine FillLOSVelocity
d2287 2
a2288 2
    ! ------------------------------------- FillNoRadsPerMIF -----
    subroutine FillNoRadsPerMif ( key, quantity, measQty, asPercentage )
d2339 1
a2339 1
    end subroutine FillNoRadsPerMIF
d2341 2
a2342 2
    ! ------------------------------------ FillPhiTanWithRefraction --
    subroutine FillPhiTanWithRefraction ( key, quantity, &
d2367 1
a2367 1
      call MLSMessageCalls( 'push', constantName='FillPhiTanWithRefraction' )
d2442 1
a2442 1
    end subroutine FillPhiTanWithRefraction
d2444 2
a2445 2
      ! ------------------------------------- FillRHIFromH2O ----
    subroutine FillRHIFromH2O ( key, quantity, &
d2517 1
a2517 1
      call MLSMessageCalls( 'push', constantName='FillRHIFromH2O' )
d2539 1
a2539 1
        & ' FillRHIFromH2O unable to invert and interpolate simultaneously' )
d2552 1
a2552 1
        & 'Incompatible quantities in FillRHIFromH2O--' //&
d2564 1
a2564 1
        & 'Different vertical coords in FillRHIFromH2O--' //&
d2726 1
a2726 1
    end subroutine FillRHIFromH2O
d2728 2
a2729 2
    ! ------------------------------------- FillRHIPrecisionFromOrToH2O ----
    subroutine FillRHIPrecisionFromOrToH2O ( key, quantity, &
d2820 1
a2820 1
      call MLSMessageCalls( 'push', constantName='FillRHIPrecisionFromOrToH2O' )
d2828 1
a2828 1
      !  & ' FillRHIPrecisionFromOrToH2O unable to invert' )
d2842 1
a2842 1
        & ' FillRHIPrecisionFromOrToH2O unable to invert and interpolate simultaneously' )
d2857 1
a2857 1
        & 'Incompatible quantities in FillRHIPrecisionFromOrToH2O--' //&
d2871 1
a2871 1
        & 'Different vertical coords in FillRHIPrecisionFromOrToH2O--' //&
d3102 1
a3102 1
    end subroutine FillRHIPrecisionFromOrToH2O
d3104 2
a3105 2
    ! ----------------------------------- FillQuantityFromASCIIFile --------
    subroutine FillQuantityFromAsciiFile ( key, quantity, filename, badRange )
d3148 1
a3148 1
    end subroutine FillQuantityFromAsciiFile
d3150 2
a3151 2
    ! ------------------------------------------- FillQtyFromInterpolatedQty
    subroutine FillQtyFromInterpolatedQty ( qty, source, force, key, DONTMASK, &
d3166 1
a3166 1
      call MLSMessageCalls( 'push', constantName='FillQtyFromInterpolatedQty' )
d3279 1
a3279 1
    end subroutine FillQtyFromInterpolatedQty
d3281 2
a3282 2
    !=============================== FillQuantityFromLosGrid ====
    subroutine FillQuantityFromLosGrid ( key, Qty, LOS, &
d3316 1
a3316 1
      if ( toggle(gen) ) call trace_begin ( "FillQuantityFromLosGrid", key )
d3323 1
a3323 1
      !      call output ( " quantity vertical grid in FillQuantityFromLOSgrid is not valid")
d3447 1
a3447 1
    end subroutine FillQuantityFromLosGrid
d3449 2
a3450 2
    ! --------------------------------------------- FillQuantityByManipulation ---
    subroutine FillQuantityByManipulation ( quantity, a, b, &
d3534 1
a3534 1
      call MLSMessageCalls( 'push', constantName='FillQuantityByManipulation' )
d4521 1
a4521 1
    end subroutine FillQuantityByManipulation
d4523 2
a4524 2
    ! ----------------------------------------- FillVectorQuantityFromL1B ----
    subroutine FillVectorQuantityFromL1B ( root, quantity, chunk, filedatabase, &
d4557 1
a4557 1
        & call trace_begin ("FillVectorQuantityFromL1B",root)
d4624 1
a4624 1
        call Announce_Error ( root, cantFillFromL1B )
d4670 4
a4673 4
              & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
              & NeverFail= .false., &
              & dontPad=DONTPAD )
              ! If it didn't exist in the not-a-radiance case, then we'll fail here.
d4677 1
d4681 1
a4681 1
            & call trace_end ( "FillVectorQuantityFromL1B")
d4703 1
a4703 1
            & call trace_end ( "FillVectorQuantityFromL1B")
d4782 2
a4783 2
      if ( toggle(gen) .and. levels(gen) > 0 ) call trace_end( "FillVectorQuantityFromL1B" )
    end subroutine FillVectorQuantityFromL1B
d4785 2
a4786 2
    ! ------------------------------------------- FillVectorQuantityFromL2AUX --
    subroutine FillVectorQuantityFromL2AUX ( qty, l2aux, errorCode )
d4806 1
a4806 1
        errorCode = CantFillFromL2AUX
d4810 1
a4810 1
        errorCode = CantFillFromL2AUX
d4815 1
a4815 1
        errorCode = CantFillFromL2AUX
d4822 1
a4822 1
    end subroutine FillVectorQuantityFromL2AUX
d4824 2
a4825 2
    ! --------------------------------------- FillQuantityUsingMagneticModel --
    subroutine FillQuantityUsingMagneticModel ( qty, gphQty, key )
d4890 1
a4890 1
    end subroutine FillQuantityUsingMagneticModel
d4892 2
a4893 2
    ! ------------------------------------- FillVectorQtyHydrostatically ----
    subroutine FillVectorQtyHydrostatically ( key, quantity, &
d4918 1
a4918 1
        & call trace_begin ( "FillVectorQtyHydrostatically", key )
d4931 1
a4931 1
            & call trace_end ( "FillVectorQtyHydrostatically")
d4940 1
a4940 1
            & call trace_end ( "FillVectorQtyHydrostatically")
d4952 1
a4952 1
            & call trace_end ( "FillVectorQtyHydrostatically")
d4960 1
a4960 1
            &  call trace_end ( "FillVectorQtyHydrostatically")
d4993 1
a4993 1
            & call trace_end ( "FillVectorQtyHydrostatically")
d5005 1
a5005 1
        & call trace_end ( "FillVectorQtyHydrostatically" )
d5007 1
a5007 1
    end subroutine FillVectorQtyHydrostatically
d5009 1
a5009 1
    ! -------------------------------------- FillVectorQtyFromIsotope -----------
d5011 1
a5011 1
    subroutine FillVectorQtyFromIsotope ( quantity, sourceQuantity, &
d5064 1
a5064 1
    end subroutine FillVectorQtyFromIsotope
d5066 2
a5067 2
    ! ---------------------------------- FillVectorQtyWithEstdNoise ---
    subroutine FillVectorQtyWithEstNoise ( quantity, radiance, &
d5142 1
a5142 1
    end subroutine FillVectorQtyWithEstNoise
d5144 2
a5145 2
    ! ----------------------------------------- FillWithReflectorTemperature ---
    subroutine FillWithReflectorTemperature ( key, quantity, phiZero, termsNode )
d5182 1
a5182 1
    end subroutine FillWithReflectorTemperature
d5184 2
a5185 2
    ! ----------------------------------------- FillQtyWithReichlerWMOTP -------------
    subroutine FillQtyWithReichlerWMOTP ( tpPres, temperature )
d5194 1
a5194 1
      ! Ideas the same as in FillQtyWithWMOTropopause
d5298 1
a5298 1
    end subroutine FillQtyWithReichlerWMOTP
d5300 2
a5301 2
    ! ----------------------------------------- FillQtyWithWMOTropopause ------
    subroutine FillQtyWithWMOTropopause ( tpPres, temperature, refGPH, grid )
d5359 1
a5359 1
      call MLSMessageCalls( 'push', constantName='FillQtyWithWMOTropopause' )
d5444 1
a5444 1
    end subroutine FillQtyWithWMOTropopause
d5446 2
a5447 2
    ! -------------------------------------------- FillQualityFromChisq --------
    subroutine FillQualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )
d5459 1
a5459 1
      call MLSMessageCalls( 'push', constantName='FillQualityFromChisq' )
d5486 1
a5486 1
    end subroutine FillQualityFromChisq
d5488 2
a5489 2
    ! -------------------------------------------- FillStatusQuantity --------
    subroutine FillStatusQuantity ( key, quantity, sourceQuantity, statusValue, &
d5507 1
a5507 1
      call MLSMessageCalls( 'push', constantName='FillStatusQuantity' )
d5555 1
a5555 1
    end subroutine FillStatusQuantity
d5557 2
a5558 2
    ! ------------------------------------------ FillUsingLeastSquares -----
    subroutine FillUsingLeastSquares  ( key, Quantity, SourceQuantity, ptanQuantity, &
d5735 1
a5735 1
    end subroutine FillUsingLeastSquares
d5737 2
a5738 2
    !=============================== FillVectorQuantityFromGrid ============
    subroutine FillVectorQuantityFromGrid(quantity, grid, allowMissing, errorCode)
d5813 1
a5813 1
    end subroutine FillVectorQuantityFromGrid
d5815 2
a5816 2
    !=============================== FillVectorQuantityFromL2GP ==========
    subroutine FillVectorQuantityFromL2GP ( quantity,l2gp, interpolate, profile, &
d5848 1
a5848 1
      call MLSMessageCalls( 'push', constantName='FillVectorQuantityFromL2GP' )
d5984 1
a5984 1
    end subroutine FillVectorQuantityFromL2GP
d5986 2
a5987 2
    ! -------------------------------------- FillVectorQtyFromProfile --
    subroutine FillVectorQtyFromProfile ( quantity, valuesNode, &
d6023 1
a6023 1
      call MLSMessageCalls( 'push', constantName='FillVectorQtyFromProfile' )
a6076 1

d6163 1
a6163 1
    end subroutine FillVectorQtyFromProfile
d6165 2
a6166 2
    ! -------------------------------------------- FillWithBinResults -----
    subroutine FillWithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
d6192 1
a6192 1
      call MLSMessageCalls( 'push', constantName='FillWithBinResults' )
d6344 1
a6344 1
    end subroutine FillWithBinResults
d6346 2
a6347 2
    ! --------------------------------------------- FillWithBoxcarFunction  ----
    subroutine FillWithBoxcarFunction ( key, quantity, sourceQuantity, width, method )
d6403 1
a6403 1
    end subroutine FillWithBoxcarFunction
d6660 1
a6660 1
            call FillQtyFromInterpolatedQty( dq, sq, force=.false., key=0, &
d6875 1
a6875 1
       "$Id: FillUtils_1.f90,v 2.34 2010/04/28 16:23:52 pwagner Exp $"
d6887 3
d6900 1
a6900 1
! Dont crash in FillVectorQuantityFromGrid if Grid is empty
d6906 1
a6906 1
! Reduce severity of profile mismatch in FillVectorQuantityFromL2GP to permit filling 1d sids with truth
d6918 1
a6918 1
! Fixed bug in ExplicitFillVectorQuantity
d6933 1
a6933 1
! Another fix to masking bit miscues in FillRHI..
d6936 1
a6936 1
! ExplicitFillVectorQuantity can Fill from an optional extraQuantity
d6939 1
a6939 1
! Consider only mask of quantity being filled, not sources in FillRHi
@


2.35
log
@Shorten most Fill routine names
@
text
@d102 1
a102 1
  character (len=*), private, parameter :: ModuleName= "$RCSfile: Utils_1.f90,v $"
d125 2
a126 2
  integer, parameter :: CantFromL2AUX = No_Error_code + 1
  integer, parameter :: CantFromL1B = cantFromL2AUX + 1
d129 1
a129 1
  integer, parameter :: MissingField = cantFromL1B + 1
d131 1
a131 1
  ! More Error codes relating to Vector
d143 1
a143 1
  ! Error codes resulting from Covariance
d172 16
a187 16
      & ExtractSingleChannel, FillCovariance, FromGrid, &
      & FromL2GP, FromProfile, LOSVelocity, &
      & ChiSqChan, ChiSqMMaf, ChiSqMMif, ChiSqRatio, &
      & ColAbundance, FoldedRadiance, PhiTanWithRefraction, &
      & IWCFromExtinction, RHIFromOrToH2O, NoRadsPerMIF, &
      & RHIPrecisionFromOrToH2O, WithEstNoise, &
      & Hydrostatically, FromSplitSideband, GPHPrecision, &
      & FromIsotope, FromAsciiFile, RotateMagneticField, &
      & Explicit, FromL1B, &
      & FromL2AUX, UsingMagneticModel, &
      & FromInterpolatedQty, FromLosGrid, &
      & ByManipulation, WithReflectorTemperature, &
      & WithReichlerWMOTP, &
      & WithWMOTropopause, WithBinResults, WithBoxcarFunction, &
      & StatusQuantity, QualityFromChisq, ConvergenceFromChisq, &
      & UsingLeastSquares, OffsetRadianceQuantity, ResetUnusedRadiances, &
d293 1
a293 1
      case ( cantFromL1B )
d295 1
a295 1
      case ( cantFromL2AUX )
d467 2
a468 2
    !=============================================== Explicit ==
    subroutine Explicit ( quantity, valuesNode, spreadFlag, &
d502 2
a503 2
      !   e              replace only values in quantity == Value
      !   n              replace only values in quantity != Value
d509 1
a509 1
      type (VectorValue_T), optional :: EXTRAQUANTITY ! Instead of Value
d519 1
a519 1
      real(kind(quantity%values)) :: myValue
d521 1
d555 2
a556 2
      myValue = 0.
      if ( present(FillValue) ) myValue = FillValue
d728 1
a728 1
              if ( quantity%values(j,i) == myValue ) cycle
d730 1
a730 1
              if ( quantity%values(j,i) /= myValue ) cycle
d752 1
a752 1
    end subroutine Explicit
d862 2
a863 2
    ! ------------------------------------------- ChiSqChan ---
    subroutine ChiSqChan ( key, qty, measQty, modelQty, noiseQty, &
d992 1
a992 1
    end subroutine ChiSqChan
d994 2
a995 2
    ! ------------------------------------------- ChiSqMMaf ---
    subroutine ChiSqMMaf ( key, qty, measQty, modelQty, noiseQty, &
d1130 1
a1130 1
    end subroutine ChiSqMMaf
d1132 2
a1133 2
    ! ------------------------------------------- ChiSqMMif ---
    subroutine ChiSqMMif ( key, qty, measQty, modelQty, noiseQty, &
d1264 1
a1264 1
    end subroutine ChiSqMMif
d1266 2
a1267 2
    ! ------------------------------------------- ChiSqRatio ---
    subroutine ChiSqRatio ( key, qty, normQty, minNormQty, flagQty, &
d1386 1
a1386 1
    end subroutine ChiSqRatio
d1388 2
a1389 2
    ! ------------------------------------------- ColAbundance ---
    subroutine ColAbundance ( key, qty, bndPressQty, vmrQty, colmAbUnits, &
d1633 1
a1633 1
    end subroutine ColAbundance
d1635 2
a1636 2
    ! -------------------------------------------- ConvergenceFromChisq --------
    subroutine ConvergenceFromChisq ( key, quantity, sourceQuantity, scale )
d1655 1
a1655 1
    end subroutine ConvergenceFromChisq
d1753 1
a1753 1
            & "Unable to handle irregular quantity in Covariance" )
d1827 2
a1828 2
    ! ------------------------------------- FoldedRadiance ---
    subroutine FoldedRadiance ( radiance, lsb, usb, &
d1889 1
a1889 1
    end subroutine FoldedRadiance
d1891 2
a1892 2
    ! ------------------------------------- FromSplitSideband ----
    subroutine FromSplitSideband ( quantity, sourceQuantity, &
d2080 1
a2080 1
    end subroutine FromSplitSideband
d2082 2
a2083 2
    ! ------------------------------------- GPHPrecision ----
    subroutine GPHPrecision ( key, quantity, &
d2098 1
a2098 1
        & call trace_begin ( "GPHPrecision", key )
d2111 1
a2111 1
            & call trace_end ( "GPHPrecision")
d2120 1
a2120 1
            & call trace_end ( "GPHPrecision")
d2125 1
a2125 1
        call Announce_error ( 0, no_error_code, 'GPH precision needed for result of GPHPrecision' )
d2129 1
a2129 1
        & call trace_end ( "GPHPrecision" )
d2131 1
a2131 1
    end subroutine GPHPrecision
d2133 2
a2134 2
      ! ------------------------------------- IWCFromExtinction ----
    subroutine IWCFromExtinction ( quantity, &
d2150 1
a2150 1
      call MLSMessageCalls( 'push', constantName='IWCFromExtinction' )
d2205 1
a2205 1
    end subroutine IWCFromExtinction
d2207 2
a2208 2
    ! ------------------------------------------- LOSVelocity ---
    subroutine LOSVelocity ( key, qty, tngtECI, scECI, scVel)
d2286 1
a2286 1
    end subroutine LOSVelocity
d2288 2
a2289 2
    ! ------------------------------------- NoRadsPerMIF -----
    subroutine NoRadsPerMif ( key, quantity, measQty, asPercentage )
d2340 1
a2340 1
    end subroutine NoRadsPerMIF
d2342 2
a2343 2
    ! ------------------------------------ PhiTanWithRefraction --
    subroutine PhiTanWithRefraction ( key, quantity, &
d2368 1
a2368 1
      call MLSMessageCalls( 'push', constantName='PhiTanWithRefraction' )
d2443 1
a2443 1
    end subroutine PhiTanWithRefraction
d2445 2
a2446 2
      ! ------------------------------------- RHIFromOrToH2O ----
    subroutine RHIFromOrToH2O ( key, quantity, &
d2518 1
a2518 1
      call MLSMessageCalls( 'push', constantName='RHIFromOrToH2O' )
d2540 1
a2540 1
        & ' RHIFromOrToH2O unable to invert and interpolate simultaneously' )
d2553 1
a2553 1
        & 'Incompatible quantities in RHIFromOrToH2O--' //&
d2565 1
a2565 1
        & 'Different vertical coords in RHIFromOrToH2O--' //&
d2727 1
a2727 1
    end subroutine RHIFromOrToH2O
d2729 2
a2730 2
    ! ------------------------------------- RHIPrecisionFromOrToH2O ----
    subroutine RHIPrecisionFromOrToH2O ( key, quantity, &
d2821 1
a2821 1
      call MLSMessageCalls( 'push', constantName='RHIPrecisionFromOrToH2O' )
d2829 1
a2829 1
      !  & ' RHIPrecisionFromOrToH2O unable to invert' )
d2843 1
a2843 1
        & ' RHIPrecisionFromOrToH2O unable to invert and interpolate simultaneously' )
d2858 1
a2858 1
        & 'Incompatible quantities in RHIPrecisionFromOrToH2O--' //&
d2872 1
a2872 1
        & 'Different vertical coords in RHIPrecisionFromOrToH2O--' //&
d3103 1
a3103 1
    end subroutine RHIPrecisionFromOrToH2O
d3105 2
a3106 2
    ! ----------------------------------- FromASCIIFile --------
    subroutine FromAsciiFile ( key, quantity, filename, badRange )
d3149 1
a3149 1
    end subroutine FromAsciiFile
d3151 2
a3152 2
    ! ------------------------------------------- FromInterpolatedQty
    subroutine FromInterpolatedQty ( qty, source, force, key, DONTMASK, &
d3167 1
a3167 1
      call MLSMessageCalls( 'push', constantName='FromInterpolatedQty' )
d3280 1
a3280 1
    end subroutine FromInterpolatedQty
d3282 2
a3283 2
    !=============================== FromLosGrid ====
    subroutine FromLosGrid ( key, Qty, LOS, &
d3317 1
a3317 1
      if ( toggle(gen) ) call trace_begin ( "FromLosGrid", key )
d3324 1
a3324 1
      !      call output ( " quantity vertical grid in FromLOSgrid is not valid")
d3448 1
a3448 1
    end subroutine FromLosGrid
d3450 2
a3451 2
    ! --------------------------------------------- ByManipulation ---
    subroutine ByManipulation ( quantity, a, b, &
d3535 1
a3535 1
      call MLSMessageCalls( 'push', constantName='ByManipulation' )
d4522 1
a4522 1
    end subroutine ByManipulation
d4524 2
a4525 2
    ! ----------------------------------------- FromL1B ----
    subroutine FromL1B ( root, quantity, chunk, filedatabase, &
d4558 1
a4558 1
        & call trace_begin ("FromL1B",root)
d4625 1
a4625 1
        call Announce_Error ( root, cantFromL1B )
d4665 2
a4666 2
      if ( associated(L1BFile) .or. ( quantity%template%quantityType /= l_radiance .and. &
        & quantity%template%quantityType /= l_L1BMAFBaseline ) ) then
d4669 9
a4677 6

        call ReadL1BData ( L1BFile, nameString, l1bData, noMAFs, flag, &
          & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail= .false., &
          & dontPad=DONTPAD )
        ! If it didn't exist in the not-a-radiance case, then we'll fail here.
d4681 1
a4681 1
            & call trace_end ( "FromL1B")
d4703 1
a4703 1
            & call trace_end ( "FromL1B")
d4782 2
a4783 2
      if ( toggle(gen) .and. levels(gen) > 0 ) call trace_end( "FromL1B" )
    end subroutine FromL1B
d4785 2
a4786 2
    ! ------------------------------------------- FromL2AUX --
    subroutine FromL2AUX ( qty, l2aux, errorCode )
d4806 1
a4806 1
        errorCode = CantFromL2AUX
d4810 1
a4810 1
        errorCode = CantFromL2AUX
d4815 1
a4815 1
        errorCode = CantFromL2AUX
d4822 1
a4822 1
    end subroutine FromL2AUX
d4824 2
a4825 2
    ! --------------------------------------- UsingMagneticModel --
    subroutine UsingMagneticModel ( qty, gphQty, key )
d4890 1
a4890 1
    end subroutine UsingMagneticModel
d4892 2
a4893 2
    ! ------------------------------------- Hydrostatically ----
    subroutine Hydrostatically ( key, quantity, &
d4918 1
a4918 1
        & call trace_begin ( "Hydrostatically", key )
d4931 1
a4931 1
            & call trace_end ( "Hydrostatically")
d4940 1
a4940 1
            & call trace_end ( "Hydrostatically")
d4952 1
a4952 1
            & call trace_end ( "Hydrostatically")
d4960 1
a4960 1
            &  call trace_end ( "Hydrostatically")
d4993 1
a4993 1
            & call trace_end ( "Hydrostatically")
d5005 1
a5005 1
        & call trace_end ( "Hydrostatically" )
d5007 1
a5007 1
    end subroutine Hydrostatically
d5009 1
a5009 1
    ! -------------------------------------- FromIsotope -----------
d5011 1
a5011 1
    subroutine FromIsotope ( quantity, sourceQuantity, &
d5064 1
a5064 1
    end subroutine FromIsotope
d5066 2
a5067 2
    ! ---------------------------------- WithEstdNoise ---
    subroutine WithEstNoise ( quantity, radiance, &
d5142 1
a5142 1
    end subroutine WithEstNoise
d5144 2
a5145 2
    ! ----------------------------------------- WithReflectorTemperature ---
    subroutine WithReflectorTemperature ( key, quantity, phiZero, termsNode )
d5182 1
a5182 1
    end subroutine WithReflectorTemperature
d5184 2
a5185 2
    ! ----------------------------------------- WithReichlerWMOTP -------------
    subroutine WithReichlerWMOTP ( tpPres, temperature )
d5194 1
a5194 1
      ! Ideas the same as in WithWMOTropopause
d5298 1
a5298 1
    end subroutine WithReichlerWMOTP
d5300 2
a5301 2
    ! ----------------------------------------- WithWMOTropopause ------
    subroutine WithWMOTropopause ( tpPres, temperature, refGPH, grid )
d5359 1
a5359 1
      call MLSMessageCalls( 'push', constantName='WithWMOTropopause' )
d5444 1
a5444 1
    end subroutine WithWMOTropopause
d5446 2
a5447 2
    ! -------------------------------------------- QualityFromChisq --------
    subroutine QualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )
d5459 1
a5459 1
      call MLSMessageCalls( 'push', constantName='QualityFromChisq' )
d5486 1
a5486 1
    end subroutine QualityFromChisq
d5488 2
a5489 2
    ! -------------------------------------------- StatusQuantity --------
    subroutine StatusQuantity ( key, quantity, sourceQuantity, statusValue, &
d5507 1
a5507 1
      call MLSMessageCalls( 'push', constantName='StatusQuantity' )
d5555 1
a5555 1
    end subroutine StatusQuantity
d5557 2
a5558 2
    ! ------------------------------------------ UsingLeastSquares -----
    subroutine UsingLeastSquares  ( key, Quantity, SourceQuantity, ptanQuantity, &
d5735 1
a5735 1
    end subroutine UsingLeastSquares
d5737 2
a5738 2
    !=============================== FromGrid ============
    subroutine FromGrid(quantity, grid, allowMissing, errorCode)
d5813 1
a5813 1
    end subroutine FromGrid
d5815 2
a5816 2
    !=============================== FromL2GP ==========
    subroutine FromL2GP ( quantity,l2gp, interpolate, profile, &
d5848 1
a5848 1
      call MLSMessageCalls( 'push', constantName='FromL2GP' )
d5984 1
a5984 1
    end subroutine FromL2GP
d5986 2
a5987 2
    ! -------------------------------------- FromProfile --
    subroutine FromProfile ( quantity, valuesNode, &
d6023 1
a6023 1
      call MLSMessageCalls( 'push', constantName='FromProfile' )
d6077 1
d6164 1
a6164 1
    end subroutine FromProfile
d6166 2
a6167 2
    ! -------------------------------------------- WithBinResults -----
    subroutine WithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
d6193 1
a6193 1
      call MLSMessageCalls( 'push', constantName='WithBinResults' )
d6345 1
a6345 1
    end subroutine WithBinResults
d6347 2
a6348 2
    ! --------------------------------------------- WithBoxcarFunction  ----
    subroutine WithBoxcarFunction ( key, quantity, sourceQuantity, width, method )
d6404 1
a6404 1
    end subroutine WithBoxcarFunction
d6661 1
a6661 1
            call FromInterpolatedQty( dq, sq, force=.false., key=0, &
d6876 1
a6876 1
       "$Id: Utils_1.f90,v 2.34 2010/04/28 16:23:52 pwagner Exp $"
d6887 1
a6887 1
! $Log: Utils_1.f90,v $
d6898 1
a6898 1
! Dont crash in FromGrid if Grid is empty
d6904 1
a6904 1
! Reduce severity of profile mismatch in FromL2GP to permit filling 1d sids with truth
d6916 1
a6916 1
! Fixed bug in Explicit
d6931 1
a6931 1
! Another fix to masking bit miscues in RHI..
d6934 1
a6934 1
! Explicit can Fill from an optional extraQuantity
d6937 1
a6937 1
! Consider only mask of quantity being filled, not sources in RHi
@


2.34
log
@May specify instances range in explicit Fill
@
text
@d102 1
a102 1
  character (len=*), private, parameter :: ModuleName= "$RCSfile: FillUtils_1.f90,v $"
d125 2
a126 2
  integer, parameter :: CantFillFromL2AUX = No_Error_code + 1
  integer, parameter :: CantFillFromL1B = cantFillFromL2AUX + 1
d129 1
a129 1
  integer, parameter :: MissingField = cantFillFromL1B + 1
d131 1
a131 1
  ! More Error codes relating to FillVector
d143 1
a143 1
  ! Error codes resulting from FillCovariance
d172 16
a187 16
      & ExtractSingleChannel, FillCovariance, FillVectorQuantityFromGrid, &
      & FillVectorQuantityFromL2GP, FillVectorQtyFromProfile, FillLOSVelocity, &
      & FillChiSqChan, FillChiSqMMaf, FillChiSqMMif, FillChiSqRatio, &
      & FillColAbundance, FillFoldedRadiance, FillPhiTanWithRefraction, &
      & FillIWCFromExtinction, FillRHIFromH2O, FillNoRadsPerMIF, &
      & FillRHIPrecisionFromOrToH2O, FillVectorQtyWithEstNoise, &
      & FillVectorQtyHydrostatically, FillFromSplitSideband, FillGPHPrecision, &
      & FillVectorQtyFromIsotope, FillQuantityFromAsciiFile, RotateMagneticField, &
      & ExplicitFillVectorQuantity, FillVectorQuantityFromL1B, &
      & FillVectorQuantityFromL2AUX, FillQuantityUsingMagneticModel, &
      & FillQtyFromInterpolatedQty, FillQuantityFromLosGrid, &
      & FillQuantityByManipulation, FillWithReflectorTemperature, &
      & FillQtyWithReichlerWMOTP, &
      & FillQtyWithWMOTropopause, FillWithBinResults, FillWithBoxcarFunction, &
      & FillStatusQuantity, FillQualityFromChisq, FillConvergenceFromChisq, &
      & FillUsingLeastSquares, OffsetRadianceQuantity, ResetUnusedRadiances, &
d293 1
a293 1
      case ( cantFillFromL1B )
d295 1
a295 1
      case ( cantFillFromL2AUX )
d467 2
a468 2
    !=============================================== ExplicitFillVectorQuantity ==
    subroutine ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
d502 2
a503 2
      !   e              replace only values in quantity == FillValue
      !   n              replace only values in quantity != FillValue
d509 1
a509 1
      type (VectorValue_T), optional :: EXTRAQUANTITY ! Instead of FillValue
d519 1
a519 1
      real(kind(quantity%values)) :: myFillValue
a520 1
      integer :: Node
d554 2
a555 2
      myFillValue = 0.
      if ( present(FillValue) ) myFillValue = FillValue
d727 1
a727 1
              if ( quantity%values(j,i) == myFillValue ) cycle
d729 1
a729 1
              if ( quantity%values(j,i) /= myFillValue ) cycle
d751 1
a751 1
    end subroutine ExplicitFillVectorQuantity
d861 2
a862 2
    ! ------------------------------------------- FillChiSqChan ---
    subroutine FillChiSqChan ( key, qty, measQty, modelQty, noiseQty, &
d991 1
a991 1
    end subroutine FillChiSqChan
d993 2
a994 2
    ! ------------------------------------------- FillChiSqMMaf ---
    subroutine FillChiSqMMaf ( key, qty, measQty, modelQty, noiseQty, &
d1129 1
a1129 1
    end subroutine FillChiSqMMaf
d1131 2
a1132 2
    ! ------------------------------------------- FillChiSqMMif ---
    subroutine FillChiSqMMif ( key, qty, measQty, modelQty, noiseQty, &
d1263 1
a1263 1
    end subroutine FillChiSqMMif
d1265 2
a1266 2
    ! ------------------------------------------- FillChiSqRatio ---
    subroutine FillChiSqRatio ( key, qty, normQty, minNormQty, flagQty, &
d1385 1
a1385 1
    end subroutine FillChiSqRatio
d1387 2
a1388 2
    ! ------------------------------------------- FillColAbundance ---
    subroutine FillColAbundance ( key, qty, bndPressQty, vmrQty, colmAbUnits, &
d1632 1
a1632 1
    end subroutine FillColAbundance
d1634 2
a1635 2
    ! -------------------------------------------- FillConvergenceFromChisq --------
    subroutine FillConvergenceFromChisq ( key, quantity, sourceQuantity, scale )
d1654 1
a1654 1
    end subroutine FillConvergenceFromChisq
d1752 1
a1752 1
            & "Unable to handle irregular quantity in FillCovariance" )
d1826 2
a1827 2
    ! ------------------------------------- FillFoldedRadiance ---
    subroutine FillFoldedRadiance ( radiance, lsb, usb, &
d1888 1
a1888 1
    end subroutine FillFoldedRadiance
d1890 2
a1891 2
    ! ------------------------------------- FillFromSplitSideband ----
    subroutine FillFromSplitSideband ( quantity, sourceQuantity, &
d2079 1
a2079 1
    end subroutine FillFromSplitSideband
d2081 2
a2082 2
    ! ------------------------------------- FillGPHPrecision ----
    subroutine FillGPHPrecision ( key, quantity, &
d2097 1
a2097 1
        & call trace_begin ( "FillGPHPrecision", key )
d2110 1
a2110 1
            & call trace_end ( "FillGPHPrecision")
d2119 1
a2119 1
            & call trace_end ( "FillGPHPrecision")
d2124 1
a2124 1
        call Announce_error ( 0, no_error_code, 'GPH precision needed for result of FillGPHPrecision' )
d2128 1
a2128 1
        & call trace_end ( "FillGPHPrecision" )
d2130 1
a2130 1
    end subroutine FillGPHPrecision
d2132 2
a2133 2
      ! ------------------------------------- FillIWCFromExtinction ----
    subroutine FillIWCFromExtinction ( quantity, &
d2149 1
a2149 1
      call MLSMessageCalls( 'push', constantName='FillIWCFromExtinction' )
d2204 1
a2204 1
    end subroutine FillIWCFromExtinction
d2206 2
a2207 2
    ! ------------------------------------------- FillLOSVelocity ---
    subroutine FillLOSVelocity ( key, qty, tngtECI, scECI, scVel)
d2285 1
a2285 1
    end subroutine FillLOSVelocity
d2287 2
a2288 2
    ! ------------------------------------- FillNoRadsPerMIF -----
    subroutine FillNoRadsPerMif ( key, quantity, measQty, asPercentage )
d2339 1
a2339 1
    end subroutine FillNoRadsPerMIF
d2341 2
a2342 2
    ! ------------------------------------ FillPhiTanWithRefraction --
    subroutine FillPhiTanWithRefraction ( key, quantity, &
d2367 1
a2367 1
      call MLSMessageCalls( 'push', constantName='FillPhiTanWithRefraction' )
d2442 1
a2442 1
    end subroutine FillPhiTanWithRefraction
d2444 2
a2445 2
      ! ------------------------------------- FillRHIFromH2O ----
    subroutine FillRHIFromH2O ( key, quantity, &
d2517 1
a2517 1
      call MLSMessageCalls( 'push', constantName='FillRHIFromH2O' )
d2539 1
a2539 1
        & ' FillRHIFromH2O unable to invert and interpolate simultaneously' )
d2552 1
a2552 1
        & 'Incompatible quantities in FillRHIFromH2O--' //&
d2564 1
a2564 1
        & 'Different vertical coords in FillRHIFromH2O--' //&
d2726 1
a2726 1
    end subroutine FillRHIFromH2O
d2728 2
a2729 2
    ! ------------------------------------- FillRHIPrecisionFromOrToH2O ----
    subroutine FillRHIPrecisionFromOrToH2O ( key, quantity, &
d2820 1
a2820 1
      call MLSMessageCalls( 'push', constantName='FillRHIPrecisionFromOrToH2O' )
d2828 1
a2828 1
      !  & ' FillRHIPrecisionFromOrToH2O unable to invert' )
d2842 1
a2842 1
        & ' FillRHIPrecisionFromOrToH2O unable to invert and interpolate simultaneously' )
d2857 1
a2857 1
        & 'Incompatible quantities in FillRHIPrecisionFromOrToH2O--' //&
d2871 1
a2871 1
        & 'Different vertical coords in FillRHIPrecisionFromOrToH2O--' //&
d3102 1
a3102 1
    end subroutine FillRHIPrecisionFromOrToH2O
d3104 2
a3105 2
    ! ----------------------------------- FillQuantityFromASCIIFile --------
    subroutine FillQuantityFromAsciiFile ( key, quantity, filename, badRange )
d3148 1
a3148 1
    end subroutine FillQuantityFromAsciiFile
d3150 2
a3151 2
    ! ------------------------------------------- FillQtyFromInterpolatedQty
    subroutine FillQtyFromInterpolatedQty ( qty, source, force, key, DONTMASK, &
d3166 1
a3166 1
      call MLSMessageCalls( 'push', constantName='FillQtyFromInterpolatedQty' )
d3279 1
a3279 1
    end subroutine FillQtyFromInterpolatedQty
d3281 2
a3282 2
    !=============================== FillQuantityFromLosGrid ====
    subroutine FillQuantityFromLosGrid ( key, Qty, LOS, &
d3316 1
a3316 1
      if ( toggle(gen) ) call trace_begin ( "FillQuantityFromLosGrid", key )
d3323 1
a3323 1
      !      call output ( " quantity vertical grid in FillQuantityFromLOSgrid is not valid")
d3447 1
a3447 1
    end subroutine FillQuantityFromLosGrid
d3449 2
a3450 2
    ! --------------------------------------------- FillQuantityByManipulation ---
    subroutine FillQuantityByManipulation ( quantity, a, b, &
d3534 1
a3534 1
      call MLSMessageCalls( 'push', constantName='FillQuantityByManipulation' )
d4521 1
a4521 1
    end subroutine FillQuantityByManipulation
d4523 2
a4524 2
    ! ----------------------------------------- FillVectorQuantityFromL1B ----
    subroutine FillVectorQuantityFromL1B ( root, quantity, chunk, filedatabase, &
d4557 1
a4557 1
        & call trace_begin ("FillVectorQuantityFromL1B",root)
d4624 1
a4624 1
        call Announce_Error ( root, cantFillFromL1B )
d4677 1
a4677 1
            & call trace_end ( "FillVectorQuantityFromL1B")
d4699 1
a4699 1
            & call trace_end ( "FillVectorQuantityFromL1B")
d4778 2
a4779 2
      if ( toggle(gen) .and. levels(gen) > 0 ) call trace_end( "FillVectorQuantityFromL1B" )
    end subroutine FillVectorQuantityFromL1B
d4781 2
a4782 2
    ! ------------------------------------------- FillVectorQuantityFromL2AUX --
    subroutine FillVectorQuantityFromL2AUX ( qty, l2aux, errorCode )
d4802 1
a4802 1
        errorCode = CantFillFromL2AUX
d4806 1
a4806 1
        errorCode = CantFillFromL2AUX
d4811 1
a4811 1
        errorCode = CantFillFromL2AUX
d4818 1
a4818 1
    end subroutine FillVectorQuantityFromL2AUX
d4820 2
a4821 2
    ! --------------------------------------- FillQuantityUsingMagneticModel --
    subroutine FillQuantityUsingMagneticModel ( qty, gphQty, key )
d4886 1
a4886 1
    end subroutine FillQuantityUsingMagneticModel
d4888 2
a4889 2
    ! ------------------------------------- FillVectorQtyHydrostatically ----
    subroutine FillVectorQtyHydrostatically ( key, quantity, &
d4914 1
a4914 1
        & call trace_begin ( "FillVectorQtyHydrostatically", key )
d4927 1
a4927 1
            & call trace_end ( "FillVectorQtyHydrostatically")
d4936 1
a4936 1
            & call trace_end ( "FillVectorQtyHydrostatically")
d4948 1
a4948 1
            & call trace_end ( "FillVectorQtyHydrostatically")
d4956 1
a4956 1
            &  call trace_end ( "FillVectorQtyHydrostatically")
d4989 1
a4989 1
            & call trace_end ( "FillVectorQtyHydrostatically")
d5001 1
a5001 1
        & call trace_end ( "FillVectorQtyHydrostatically" )
d5003 1
a5003 1
    end subroutine FillVectorQtyHydrostatically
d5005 1
a5005 1
    ! -------------------------------------- FillVectorQtyFromIsotope -----------
d5007 1
a5007 1
    subroutine FillVectorQtyFromIsotope ( quantity, sourceQuantity, &
d5060 1
a5060 1
    end subroutine FillVectorQtyFromIsotope
d5062 2
a5063 2
    ! ---------------------------------- FillVectorQtyWithEstdNoise ---
    subroutine FillVectorQtyWithEstNoise ( quantity, radiance, &
d5138 1
a5138 1
    end subroutine FillVectorQtyWithEstNoise
d5140 2
a5141 2
    ! ----------------------------------------- FillWithReflectorTemperature ---
    subroutine FillWithReflectorTemperature ( key, quantity, phiZero, termsNode )
d5178 1
a5178 1
    end subroutine FillWithReflectorTemperature
d5180 2
a5181 2
    ! ----------------------------------------- FillQtyWithReichlerWMOTP -------------
    subroutine FillQtyWithReichlerWMOTP ( tpPres, temperature )
d5190 1
a5190 1
      ! Ideas the same as in FillQtyWithWMOTropopause
d5294 1
a5294 1
    end subroutine FillQtyWithReichlerWMOTP
d5296 2
a5297 2
    ! ----------------------------------------- FillQtyWithWMOTropopause ------
    subroutine FillQtyWithWMOTropopause ( tpPres, temperature, refGPH, grid )
d5355 1
a5355 1
      call MLSMessageCalls( 'push', constantName='FillQtyWithWMOTropopause' )
d5440 1
a5440 1
    end subroutine FillQtyWithWMOTropopause
d5442 2
a5443 2
    ! -------------------------------------------- FillQualityFromChisq --------
    subroutine FillQualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )
d5455 1
a5455 1
      call MLSMessageCalls( 'push', constantName='FillQualityFromChisq' )
d5482 1
a5482 1
    end subroutine FillQualityFromChisq
d5484 2
a5485 2
    ! -------------------------------------------- FillStatusQuantity --------
    subroutine FillStatusQuantity ( key, quantity, sourceQuantity, statusValue, &
d5503 1
a5503 1
      call MLSMessageCalls( 'push', constantName='FillStatusQuantity' )
d5551 1
a5551 1
    end subroutine FillStatusQuantity
d5553 2
a5554 2
    ! ------------------------------------------ FillUsingLeastSquares -----
    subroutine FillUsingLeastSquares  ( key, Quantity, SourceQuantity, ptanQuantity, &
d5731 1
a5731 1
    end subroutine FillUsingLeastSquares
d5733 2
a5734 2
    !=============================== FillVectorQuantityFromGrid ============
    subroutine FillVectorQuantityFromGrid(quantity, grid, allowMissing, errorCode)
d5809 1
a5809 1
    end subroutine FillVectorQuantityFromGrid
d5811 2
a5812 2
    !=============================== FillVectorQuantityFromL2GP ==========
    subroutine FillVectorQuantityFromL2GP ( quantity,l2gp, interpolate, profile, &
d5844 1
a5844 1
      call MLSMessageCalls( 'push', constantName='FillVectorQuantityFromL2GP' )
d5980 1
a5980 1
    end subroutine FillVectorQuantityFromL2GP
d5982 2
a5983 2
    ! -------------------------------------- FillVectorQtyFromProfile --
    subroutine FillVectorQtyFromProfile ( quantity, valuesNode, &
d6019 1
a6019 1
      call MLSMessageCalls( 'push', constantName='FillVectorQtyFromProfile' )
d6159 1
a6159 1
    end subroutine FillVectorQtyFromProfile
d6161 2
a6162 2
    ! -------------------------------------------- FillWithBinResults -----
    subroutine FillWithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
d6188 1
a6188 1
      call MLSMessageCalls( 'push', constantName='FillWithBinResults' )
d6340 1
a6340 1
    end subroutine FillWithBinResults
d6342 2
a6343 2
    ! --------------------------------------------- FillWithBoxcarFunction  ----
    subroutine FillWithBoxcarFunction ( key, quantity, sourceQuantity, width, method )
d6399 1
a6399 1
    end subroutine FillWithBoxcarFunction
d6656 1
a6656 1
            call FillQtyFromInterpolatedQty( dq, sq, force=.false., key=0, &
d6871 1
a6871 1
       "$Id: FillUtils_1.f90,v 2.33 2010/04/22 23:36:00 pwagner Exp $"
d6882 4
a6885 1
! $Log: FillUtils_1.f90,v $
d6893 1
a6893 1
! Dont crash in FillVectorQuantityFromGrid if Grid is empty
d6899 1
a6899 1
! Reduce severity of profile mismatch in FillVectorQuantityFromL2GP to permit filling 1d sids with truth
d6911 1
a6911 1
! Fixed bug in ExplicitFillVectorQuantity
d6926 1
a6926 1
! Another fix to masking bit miscues in FillRHI..
d6929 1
a6929 1
! ExplicitFillVectorQuantity can Fill from an optional extraQuantity
d6932 1
a6932 1
! Consider only mask of quantity being filled, not sources in FillRHi
@


2.33
log
@May fill num rads/MIF as a percentage
@
text
@d74 4
a77 4
  use MLSStringLists, only: catLists, GetStringElement, &
    & NumStringElements, &
    & ReplaceSubString, switchDetail
  use MLSStrings, only: indexes, lowerCase, SplitNest
d79 1
a79 1
  use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, outputNamedValue
d86 1
a86 1
  use TREE, only: NSONS, &
d88 2
d469 1
a469 1
      & globalUnit, dontmask, channel, heightNode, &
d492 1
d513 1
d521 1
d524 5
d532 2
d535 1
d539 1
d547 2
d644 9
a652 5
        call Hunt ( Quantity%template%surfs(:,1), height, surface, nearest=.true. )
        call outputNamedValue( 'height', height )
        call dump( Quantity%template%surfs(:,1), 'surfs' )
        call outputNamedValue( 'surface', surface )
        call outputNamedValue( 'surfs(surface)', Quantity%template%surfs(surface, 1) )
d663 37
d703 1
a703 1
        ! do j = 1, quantity%template%instanceLen
d2290 1
d2293 10
d2308 1
d2316 1
d2329 5
d2338 1
a2339 1
      if ( pct ) quantity%values = 100*quantity%values/measQty%template%noChans
d6872 1
a6872 1
       "$Id: FillUtils_1.f90,v 2.32 2010/02/04 23:12:44 vsnyder Exp $"
d6884 3
@


2.32
log
@Remove USE or declaration for unreferenced names
@
text
@d94 1
a94 1
    & VectorValue_T, M_Fill, M_LinAlg, M_Cloud
d2232 3
a2234 1
    subroutine FillNoRadsPerMif ( key, quantity, measQty )
d2238 1
d2240 3
a2242 2
      integer :: MIF, MAF               ! Loop counters
      integer :: I0, I1                 ! Indices
d2245 2
d2264 1
d4684 4
a4687 2
              if ( precisionQuantity%values(row, column) < 0.d0 ) &
                & call MaskVectorQty(quantity, row, column, M_LinAlg)
d6797 1
a6797 1
       "$Id: FillUtils_1.f90,v 2.31 2009/12/14 18:35:51 pwagner Exp $"
d6809 3
@


2.32.2.1
log
@Must respect SkipMe in FillChiSqRatio
@
text
@a1317 1
        if ( skipMe ) cycle
d6788 1
a6788 1
       "$Id: FillUtils_1.f90,v 2.32 2010/02/04 23:12:44 vsnyder Exp $"
a6799 3
! Revision 2.32  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
@


2.32.2.2
log
@Changed chiSqRatio when skipped to 999
@
text
@d1318 2
a1319 3
        if ( skipMe ) then
          if ( minNormQty%values(qIndex, i) == 0. ) qty%values(:,i) = 999._rv
        elseif ( UNIFORMCHISQRATIO .or. &
d6789 1
a6789 1
       "$Id: FillUtils_1.f90,v 2.32.2.1 2013/01/07 21:55:26 pwagner Exp $"
a6800 3
! Revision 2.32.2.1  2013/01/07 21:55:26  pwagner
! Must respect SkipMe in FillChiSqRatio
!
@


2.31
log
@Dont crash in FillVectorQuantityFromGrid if Grid is empty
@
text
@a713 1
      integer :: S                      ! Signal loop counter
d6788 1
a6788 1
       "$Id: FillUtils_1.f90,v 2.30 2009/10/27 22:14:24 pwagner Exp $"
d6800 3
@


2.30
log
@Compiles with new api for Dump vector quantity
@
text
@d5663 1
d5667 1
a5667 1
      logical :: DEEBUG
d5673 8
a5680 10
      if ( grid%empty ) then
        if ( index(lowercase(grid%description), 'tropopause') > 0 ) then
          ! Must allow this as missing gmao files are a possibility
          ! to be handled with grace and aplomb
          call MLSMessage ( MLSMSG_Warning, moduleName, &
            & 'No tropopause values in grid--filling with missing values' )
          quantity%values = grid%missingValue
        else
          errorCode=EmptyGridForFill
        end if
d6789 1
a6789 1
       "$Id: FillUtils_1.f90,v 2.29 2009/09/01 17:14:02 pwagner Exp $"
d6801 3
@


2.29
log
@Reduce severity of profile mismatch in FillVectorQuantityFromL2GP to permit filling 1d sids with truth
@
text
@d4748 1
d4754 2
a4755 1

d4802 1
a4802 1
        & call dump ( qty, clean=(switchDetail(switches,'clean') > -1) )
d6790 1
a6790 1
       "$Id: FillUtils_1.f90,v 2.28 2009/08/24 20:14:11 pwagner Exp $"
d6802 3
@


2.28
log
@May Fill H2O precision from RHI precision
@
text
@d5817 6
a5822 4
          call dump ( l2gp%geodAngle(firstProfile:lastProfile), 'L2GP geodetic angle' )
          call dump ( quantity%template%phi(1,:), 'Quantity Geodetic angle' )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Quantity has profiles that mismatch l2gp in geodetic angle' )
d5827 6
a5832 2
          &         quantity%template%time(1,:)) > timeTol) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
d5834 1
a5834 1

d6788 1
a6788 1
       "$Id: FillUtils_1.f90,v 2.27 2009/07/21 20:34:56 pwagner Exp $"
d6800 3
@


2.27
log
@chi^2 ratio nay hold values for iterations prior to final
@
text
@d81 1
a81 1
  use RHIFromH2O, only: RHIFromH2O_Factor, RHIPrecFromH2O
d175 1
a175 1
      & FillRHIPrecisionFromH2O, FillVectorQtyWithEstNoise, &
d2648 4
a2651 3
    ! ------------------------------------- FillRHIPrecisionFromH2O ----
    subroutine FillRHIPrecisionFromH2O ( key, quantity, &
     & sourcePrecisionQuantity, tempPrecisionQuantity, sourceQuantity, temperatureQuantity, &
d2715 1
a2715 1
      real (r8) ::                        rhi_precision
d2728 1
a2728 1
       &                                  zeta, TPrecisionofZeta, H2OPrecisionofZeta, TofZeta, H2OofZeta
d2740 1
a2740 1
      call MLSMessageCalls( 'push', constantName='FillRHIPrecisionFromH2O' )
d2746 5
a2750 5
      if ( invert ) then
       call Announce_Error ( key, No_Error_code, &
        & ' FillRHIPrecisionFromH2O unable to invert' )
       return
      end if
d2762 1
a2762 1
        & ' FillRHIPrecisionFromH2O unable to invert and interpolate simultaneously' )
d2777 1
a2777 1
        & 'Incompatible quantities in FillRHIPrecisionFromH2O--' //&
d2791 1
a2791 1
        & 'Different vertical coords in FillRHIPrecisionFromH2O--' //&
d2907 1
a2907 1
             & zeta, H2OPrecisionofZeta, &
d2946 1
a2946 1
              H2OPrecisionofZeta(s) = sourcePrecisionQuantity%values(qIndex, i)
d2969 13
a2981 6
              call RHIPrecFromH2O( H2OofZeta(s), &
               & TofZeta(s), zeta(qIndex), vmr_unit_cnv, &
               & H2OPrecisionofZeta(s), TPrecisionofZeta(s), &
               & rhi_precision, negativeToo )
              ! Quantity%values(qIndex, i) = rhi_precision
              values(qIndex, i) = rhi_precision
d3022 1
a3022 1
    end subroutine FillRHIPrecisionFromH2O
d6782 1
a6782 1
       "$Id: FillUtils_1.f90,v 2.26 2009/07/10 20:56:52 pwagner Exp $"
d6794 3
@


2.26
log
@Fixed bug affecting manipulations like 'a+b+c'
@
text
@d115 1
d1222 5
d1319 3
d1324 5
d1586 1
d1593 6
a1598 2

      quantity%values(1,:) = scale * sourceQuantity%values(1,1)
d6774 1
a6774 1
       "$Id: FillUtils_1.f90,v 2.25 2009/06/30 15:19:05 pwagner Exp $"
d6786 3
@


2.25
log
@Fixed bug in ExplicitFillVectorQuantity
@
text
@d3362 3
a3364 3
      ! Other more general manipulations require the use of the constant
      ! "c". E.g., 'a/b+b/a' could be 'a/b+c*b/a' and set c=1

d3368 4
a3371 9
      ! Remember to use the "c", even for examples where it appears unneeded
      ! e.g., not "-abs(a)" but instead use "c*abs(a)" and set c=-1
      
      ! Long-term question: Why not do away with any difference between general
      ! and non-general manipulations? Just treat them all alike! Then
      ! you would not need the clumsy insertion of unneeded "c".
      ! Of course we would need to take care before calling
      ! SimpleExprWithC to call it with some dummy constant, say 0._rv
      
d3382 2
a3409 1
      character (len=128) :: MSTR
d3411 2
a3412 5
      logical :: OKSOFAR
      logical :: OneWay
      logical :: TwoWay
      logical :: StatisticalFunction
      logical :: USESC
d3419 3
a3421 1
      type (VectorValue_T), pointer :: AORB
d3423 3
a3425 1
      integer, parameter :: MAXSTRLISTLENGTH = 128
d3436 1
a3436 1
      usesc = present(c)
d3439 9
a3447 3
        call Announce_Error ( key, no_error_code, 'Invalid manipulation:' &
          & // trim(mstr) )
        return
d3750 10
a3759 4
          ! How did we get here?
          call Announce_Error ( key, no_error_code, &
            & 'trim(mstr) manipulation but no c supplied' )
          return
d3761 1
a3761 1
        call SimpleExprWithC( quantity, a, b, c, mstr )
d3838 1
a3838 1
          & which='all', no_trim=.false. )
d3843 1
a3843 1
          & which='all', no_trim=.false. )
d3848 1
a3848 1
          & which='all', no_trim=.false. )
d3853 1
a3853 1
          & which='all', no_trim=.false. )
d3858 1
a3858 1
          & which='all', no_trim=.false. )
d3863 1
a3863 1
          & which='all', no_trim=.false. )
d3868 1
a3868 1
          & which='all', no_trim=.false. )
d3969 1
a3969 1
          & which='all', no_trim=.false. )
d3974 1
a3974 1
          & which='all', no_trim=.false. )
d3979 1
a3979 1
          & which='all', no_trim=.false. )
d6755 1
a6755 1
       "$Id: FillUtils_1.f90,v 2.24 2009/06/23 18:46:18 pwagner Exp $"
d6767 3
@


2.24
log
@Prevent Intel from optimizing ident string away
@
text
@d692 1
a692 1
      call Deallocate_test ( values, 'values', ModuleName )
d6746 1
a6746 1
       "$Id: read_apriori.f90 is it here $"
d6758 3
@


2.23
log
@Get constants from Constants, kinds from MLSKinds
@
text
@d6743 1
a6744 1
!---------------------------- RCS Ident Info -------------------------------
d6746 1
a6746 1
       "$Id: FillUtils_1.f90,v 2.22 2009/05/01 23:44:40 pwagner Exp $"
a6747 1
!---------------------------------------------------------------------------
d6749 1
a6749 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d6751 1
d6758 3
@


2.22
log
@Restored nearly all except for conversions between RHi and H2O
@
text
@d18 1
d63 1
a63 2
  use MLSCommon, only: MLSFile_T, R4, R8, RM, RV, &
    & DEFAULTUNDEFINEDVALUE
d65 1
a87 1
  use UNITS, only: Deg2Rad, Rad2Deg
d2246 1
a2251 1
      use Units, only: DEG2RAD, RAD2DEG
d5022 1
a5022 1
      use Units, only: DEG2RAD
d6317 1
a6318 1
      use Units, only: RAD2DEG
d6746 1
a6746 1
       "$Id: FillUtils_1.f90,v 2.21 2009/04/30 22:13:29 pwagner Exp $"
d6758 3
@


2.21
log
@name of bit in MaskVectorQty and isVectorQtyMasked now mandatory
@
text
@d409 1
a409 1
                  &  isVectorQtyMasked(baselineQuantity, chan, i, m_fill)
d428 1
a428 1
                  &  isVectorQtyMasked(baselineQuantity, chan, i, m_fill)
a909 5
            ! skipMe = &
            ! & .not. dontMask .and. ( &
            ! &   isVectorQtyMasked(measQty, qIndex, i) .or. &
            ! &   isVectorQtyMasked(modelQty, qIndex, i) .or. &
            ! &   isVectorQtyMasked(noiseQty, qIndex, i) ) &
d911 4
a914 1
            & .not. dontMask .and. isVectorQtyMasked(qty, qIndex, i, m_fill) &
a1047 5
            ! skipMe = &
            ! & .not. dontMask .and. ( &
            ! &   isVectorQtyMasked(measQty, row, i) .or. &
            ! &   isVectorQtyMasked(modelQty, row, i) .or. &
            ! &   isVectorQtyMasked(noiseQty, row, i) ) &
d1049 4
a1052 1
            & .not. dontMask .and. isVectorQtyMasked(qty, row, i, m_fill) &
a1181 5
            ! skipMe = &
            ! & .not. dontMask .and. ( &
            ! &   isVectorQtyMasked(measQty, qIndex, i) .or. &
            ! &   isVectorQtyMasked(modelQty, qIndex, i) .or. &
            ! &   isVectorQtyMasked(noiseQty, qIndex, i) ) &
d1183 4
a1186 1
            & .not. dontMask .and. isVectorQtyMasked(qty, qIndex, i, m_fill) &
d1308 5
a1312 2
          & .not. dontMask .and. isVectorQtyMasked(qty, qIndex, i, m_fill) .or. &
          &   minNormQty%values(qIndex, i) == 0.
d6746 1
a6746 1
       "$Id: FillUtils_1.f90,v 2.20 2009/04/30 20:15:01 pwagner Exp $"
d6758 3
@


2.20
log
@Another fix to masking bit miscues in FillRHI..
@
text
@d409 1
a409 1
                  &  isVectorQtyMasked(baselineQuantity, chan, i)
d428 1
a428 1
                  &  isVectorQtyMasked(baselineQuantity, chan, i)
d910 5
d916 1
a916 4
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, qIndex, i) .or. &
            &   isVectorQtyMasked(modelQty, qIndex, i) .or. &
            &   isVectorQtyMasked(noiseQty, qIndex, i) ) &
d1050 5
d1056 1
a1056 4
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, row, i) .or. &
            &   isVectorQtyMasked(modelQty, row, i) .or. &
            &   isVectorQtyMasked(noiseQty, row, i) ) &
d1186 5
d1192 1
a1192 4
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, qIndex, i) .or. &
            &   isVectorQtyMasked(modelQty, qIndex, i) .or. &
            &   isVectorQtyMasked(noiseQty, qIndex, i) ) &
d1314 2
a1315 5
          & .not. dontMask .and. ( &
          &   isVectorQtyMasked(normQty, qIndex, i) .or. &
          &   isVectorQtyMasked(minNormQty, qIndex, i) .or. &
          &   minNormQty%values(qIndex, i) == 0. &
          & )
d2237 1
a2237 1
              & iand ( ichar ( measQty%mask ( i0:i1, maf ) ), m_linAlg ) == 0 )
d3041 1
a3041 1
          quantity%mask = char(ior(ichar(quantity%mask),m_linAlg))
d4633 1
a4633 1
                & call MaskVectorQty(quantity, row, column)
d4639 2
a4640 2
              if ( isVectorQtyMasked(precisionQuantity, row, column) ) &
                & call MaskVectorQty(quantity, row, column)
d4646 1
a4646 1
                & call MaskVectorQty(quantity, row, column)
d4659 1
a4659 1
            call MaskVectorQty ( quantity, row, column )
d6299 1
a6299 1
      where ( iand ( ichar(radianceQuantity%mask), m_linAlg ) /= 0 )
d6749 1
a6749 1
       "$Id: FillUtils_1.f90,v 2.19 2009/04/29 23:11:04 pwagner Exp $"
d6761 3
@


2.19
log
@ExplicitFillVectorQuantity can Fill from an optional extraQuantity
@
text
@d470 1
a470 1
      ! fill command line or as part of a compound Fill, e.g. manipulation
d2415 2
d2419 1
d2421 1
d2568 5
a2572 5
            if ( .not. interpolate ) then
             skipMe = skipMe .or. &
             & .not. dontMask .and. &
             &   isVectorQtyMasked(Quantity, qIndex, i)
            end if
d2582 2
a2583 1
              Quantity%values(qIndex, i) = &
d2592 7
d2717 2
d2721 1
d2723 1
d2936 5
a2940 5
            if ( .not. interpolate ) then
             skipMe = skipMe .or. &
             & .not. dontMask .and. &
             &   isVectorQtyMasked(Quantity, qIndex, i)
            end if
d2953 2
a2954 1
              Quantity%values(qIndex, i) = rhi_precision
d2960 7
d3377 8
d3570 7
a3576 1
            quantity%values = qvalue
d6746 1
a6746 1
       "$Id: FillUtils_1.f90,v 2.18 2009/04/28 20:03:49 pwagner Exp $"
d6758 3
@


2.18
log
@Consider only mask of quantity being filled, not sources in FillRHi
@
text
@d467 1
a467 1
      & AzEl, options, FillValue )
d470 10
a479 1
      ! fill command line
d505 1
d535 2
a536 1
      noValues = nsons(valuesNode) - 1
d555 52
a606 51
      ! Check the dimensions work out OK
      if ( myAzEl .and. mod(noValues,3) /= 0 ) &
          & call Announce_Error ( valuesNode, invalidExplicitFill )
      if ( spreadFlag ) then
        if ( noValues /= quantity%template%instanceLen .and. &
          & noValues /= quantity%template%noChans .and. &
          & noValues /= 1 ) &
          & call Announce_Error ( valuesNode, invalidExplicitFill )
      else
        if ( noValues /= &
          & quantity%template%instanceLen * quantity%template%noInstances ) &
          & call Announce_Error ( valuesNode, invalidExplicitFill, &
            & extraInfo = (/ &
              & quantity%template%instanceLen * quantity%template%noInstances /) )
      end if

      ! Get the values the user asked for, checking their units
      nullify ( values )
      call Allocate_test ( values, noValues, 'values', ModuleName )
      if ( .not. myAzEl ) then
        do k = 1, noValues
          call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
            & (/testUnit, PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), testUnit, PHYQ_Dimensionless/) )
          values ( k ) = valueAsArray(1)
        end do
      else
        ! Convert from Mag, Az, El to 3-D projections
        do k = 1, noValues, 3
          call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
            & (/testUnit, PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), testUnit, PHYQ_Dimensionless/) )
          values ( k ) = valueAsArray(1)
          ! Next two quantities have to be angles
          call expr_check ( subtree(k+2,valuesNode) , unitAsArray, valueAsArray, &
            & (/PHYQ_Angle/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
          values (k+1) = deg2rad * valueAsArray(1)
          call expr_check ( subtree(k+3,valuesNode) , unitAsArray, valueAsArray, &
            & (/PHYQ_Angle/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
          values (k+2) = deg2rad * valueAsArray(1)
          values(k:k+2) = values(k) * (/ cos(values(k+1))*cos(values(k+2)), &
                                         sin(values(k+1))*cos(values(k+2)), &
                                         sin(values(k+2)) /)
        end do
      end if
d608 7
a614 6
      if ( verbose ) then
        call output('Explicit fill of values for ', advance='no')
        call display_string ( quantity%template%name )
        call newline
        call output(values)
        call newline
d678 5
a682 1
            quantity%values(j,i) = values ( mod ( k-1, noValues ) + 1 )
d3337 1
a3337 1
      ! The following 1 and 2-way manipulations must be entered exactly as shown
d3342 1
a3342 4
      ! nesting between '(' and ')' where appropriate. It does not permit
      ! use of the functions 'abs', 'sign', etc. within the manipulation
      ! Perhaps a future rewrite might permit this freedom, but for now
      ! you must use intermediate fills and temporary quantities.
d3344 8
a3351 1
      ! Correction: working on this rewrite now
a3406 2
      ! usesc  = .not. ( OneWay .or. TwoWay ) .and. &
      !  & index(mstr, 'c') > 0
d3410 2
a3411 1
        call Announce_Error ( key, no_error_code, 'Invalid manipulation' )
d6708 1
a6708 1
       "$Id: FillUtils_1.f90,v 2.17 2009/04/16 21:55:23 pwagner Exp $"
d6720 3
@


2.17
log
@/exact keyword in status Fill to fix radiance bug
@
text
@d2549 2
a2550 4
             & .not. dontMask .and. ( &
             &   isVectorQtyMasked(sourceQuantity, qIndex, i) .or. &
             &   isVectorQtyMasked(temperatureQuantity, qIndex, i) &
             & )
d2905 2
a2906 6
             & .not. dontMask .and. ( &
             &   isVectorQtyMasked(sourcePrecisionQuantity, qIndex, i) .or. &
             &   isVectorQtyMasked(tempPrecisionQuantity, qIndex, i) .or. &
             &   isVectorQtyMasked(sourceQuantity, qIndex, i) .or. &
             &   isVectorQtyMasked(temperatureQuantity, qIndex, i) &
             & )
d6688 1
a6688 1
       "$Id: FillUtils_1.f90,v 2.16 2009/04/13 20:45:57 pwagner Exp $"
d6700 3
@


2.16
log
@heightRange in explicit Fill can fill above or below specified height
@
text
@d5314 1
a5314 1
      & minValue, maxValue, heightNode, additional, force )
d5324 1
d5356 8
a5363 2
        if ( sourceQuantity%values(surface,1) > maxValue .or. sourceQuantity%values(surface,1) < minValue ) &
          & quantity%values(1,:) = ior ( nint ( quantity%values(1,1) ), statusValue )
d5366 11
a5376 3
        where ( sourceQuantity%values(surface,:) > maxValue .or. sourceQuantity%values(surface,:) < minValue )
          quantity%values(1,:) = ior ( nint ( quantity%values(1,:) ), statusValue )
        end where
d6694 1
a6694 1
       "$Id: FillUtils_1.f90,v 2.15 2009/03/05 18:38:32 pwagner Exp $"
d6706 3
@


2.15
log
@May specifiy height, channel with explicit Fill
@
text
@d479 1
a479 1
      integer, intent(in) :: HEIGHTNODE   ! Fill specified height?
d491 2
d500 1
d537 7
d640 11
a650 1
              if ( surface /= surf ) cycle
d6150 1
a6150 1
    ! --------------------------------------------- FillWithBoxcarAvergage  ----
d6679 1
a6679 1
       "$Id: FillUtils_1.f90,v 2.14 2008/10/15 16:37:28 pwagner Exp $"
d6691 3
@


2.14
log
@Let precisions explicitly set negative also mask radiances
@
text
@d466 1
a466 1
      & globalUnit, dontmask, &
d478 2
d496 2
d504 3
d593 26
d622 25
a646 12
        do j = 1, quantity%template%instanceLen
          k = k + 1
          if ( .not. dontMask .and. associated ( quantity%mask ) ) then
            if ( iand ( ichar(quantity%mask(j,i)), m_Fill ) /= 0 ) cycle
          end if
          select case (whichToReplace)
          case ('/=')
            if ( quantity%values(j,i) == myFillValue ) cycle
          case ('==')
            if ( quantity%values(j,i) /= myFillValue ) cycle
          end select
          quantity%values(j,i) = values ( mod ( k-1, noValues ) + 1 )
d5294 1
a5294 1
      & minValue, maxValue, heightNode, additional )
d5297 1
a5297 1
      type ( VectorValue_T), intent(in) :: SOURCEQUANTITY ! Chisq like quantity on which it's based
d5303 1
d5305 2
a5308 2
      real(r8) :: HEIGHT                ! The height to consider
      integer :: SURFACE                ! Surface index
d5314 2
a5315 1
      if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) ) call Announce_error ( &
d5334 4
d5339 4
a5342 3
      where ( sourceQuantity%values(surface,:) > maxValue .or. sourceQuantity%values(surface,:) < minValue )
        quantity%values(1,:) = ior ( nint ( quantity%values(1,:) ), statusValue )
      end where
d6659 1
a6659 1
       "$Id: FillUtils_1.f90,v 2.13 2008/09/24 16:46:09 livesey Exp $"
d6671 3
@


2.13
log
@Changed ptan from optional to pointer in fill from profile
@
text
@a95 6
  use VectorsModule, only: &
    & ClearUnderMask, CopyVector, CreateMask, &
    & DestroyVectorInfo, Dump, &
    & GetVectorQtyByTemplateIndex, isVectorQtyMasked, MaskVectorQty, &
    & ValidateVectorQuantity, Vector_T, &
    & VectorValue_T, M_Fill, M_LinAlg, M_Cloud
d4522 6
d6606 1
a6606 1
       "$Id: FillUtils_1.f90,v 2.12 2008/09/20 00:03:00 pwagner Exp $"
d6618 3
@


2.12
log
@Added print statement to not_used_here
@
text
@d5719 1
a5719 1
      & instancesNode, globalUnit, dontMask, logSpace, ptan )
d5728 1
a5729 1
      type (VectorValue_T), optional :: PTAN ! press. values
d5758 1
a5758 1
        & coherent=.true. ) .and. .not. present(ptan) ) &
d5760 1
a5760 1
        & 'The quantity is not amenable to a profile fill unless you supply ptan ptan' )
d5785 1
a5785 1
        if ( present(ptan) ) heightUnit = PHYQ_Zeta
d5811 1
a5811 1
      if ( present(ptan) ) then
d5826 1
a5826 1
      if ( quantity%template%coherent .or. present(ptan) ) then
d6606 1
a6606 1
       "$Id: FillUtils_1.f90,v 2.11 2008/09/16 22:30:19 pwagner Exp $"
d6618 3
@


2.11
log
@Use optional arg ptan when source is profile, vector
@
text
@d6606 1
a6606 1
       "$Id: FillUtils_1.f90,v 2.10 2008/08/14 20:58:40 pwagner Exp $"
d6610 1
d6618 3
@


2.10
log
@/interpolate now possible field in Transfer command
@
text
@d2949 2
a2950 1
    subroutine FillQtyFromInterpolatedQty ( qty, source, force, key, DONTMASK )
d2956 1
d2970 1
a2970 1
      if ( .not. doHGridsMatch ( qty, source ) ) then
d2975 1
a2975 1
      if ( .not. doFGridsMatch ( qty, source ) ) then
d2989 3
a2991 1
        if ( qty%template%noChans /= 1 ) then
d2995 1
a2995 2
        end if
        if ( .not. all ( (/ qty%template%coherent, source%template%coherent /) ) ) then
d3002 5
a3006 1
        if ( qty%template%verticalCoordinate == l_pressure ) then
d3397 6
a3402 2
            & .and. quantity%template%noInstances == aorb%template%noInstances &
            & .and. quantity%template%instanceLen == aorb%template%instanceLen
d3811 7
a3817 1
        if ( .not. associated ( quantity%mask ) ) then
d5717 1
a5717 1
    ! -------------------------------------- FillVectorQuantityFromProfile --
d5719 1
a5719 1
      & instancesNode, globalUnit, dontMask, logSpace )
d5729 1
d5758 1
a5758 1
        & coherent=.true. ) ) &
d5760 1
a5760 1
        & 'The quantity is not amenable to a profile fill' )
d5785 1
d5811 4
a5814 1
      if ( quantity%template%verticalCoordinate == l_pressure ) then
d5826 1
a5826 1
      if ( quantity%template%coherent ) then
d5834 2
a5835 2
        return
      end if
d6606 1
a6606 1
       "$Id: FillUtils_1.f90,v 2.9 2008/08/06 17:27:47 pwagner Exp $"
d6617 3
@


2.9
log
@Fill by manipulation now respects mask better
@
text
@d91 2
a92 1
    & GetVectorQtyByTemplateIndex, isVectorQtyMasked, MaskVectorQty, &
d6333 1
a6333 1
    subroutine TransferVectors ( source, dest, skipMask )
d6338 1
d6364 8
d6376 1
a6376 1
    ! ---------------------------------------------- TransferVectors -----
d6584 1
a6584 1
       "$Id: FillUtils_1.f90,v 2.8 2008/06/06 21:02:49 michael Exp $"
d6595 3
@


2.8
log
@added fill method uncompressRadiance
@
text
@d3785 7
a3791 1
        quantity%values = 0.
d5785 1
a5785 1
          & 'Non-positive input data in log profile fill' )
d6574 1
a6574 1
       "$Id: FillUtils_1.f90,v 2.7 2008/04/26 00:39:56 livesey Exp $"
d6585 3
@


2.7
log
@Added total power stuff
@
text
@d163 2
a164 1
  integer, parameter :: BadlosVelFill = noSpecialFill + 1
d344 2
d649 1
a649 1
      do j = 2, nsons(key)
d669 1
d688 10
a697 1
        thisResult%values = thisResult%values / totalWeight
d6370 1
a6370 1
      integer, parameter :: NOTERMS=4
d6374 4
d6381 4
d6390 1
a6390 3
      if ( totalPowerQuantity%template%quantityType /= l_baseline .or. &
        &  .not. totalPowerQuantity%template%minorFrame &
        &  .or. totalPowerQuantity%template%radiometer /= quantity%template%radiometer ) &
d6393 10
a6402 1
        & ' (should be MIF baseline for the right radiometer)' )
d6404 1
a6404 1
      if ( nsons ( termsNode ) /= noTerms - 1 ) &
d6418 1
a6418 1
      ! System temperature is in systemTemperatureQuantity%values%values[1,1]
d6421 32
a6452 1
      ! YOUR CODE HERE
d6568 1
a6568 1
       "$Id: FillUtils_1.f90,v 2.6 2008/04/11 01:17:09 livesey Exp $"
d6579 3
@


2.6
log
@Added uncompressRadiance fill
@
text
@d22 1
a22 1
    & L_BINMAX, L_BINMEAN, L_BINMIN, L_BINTOTAL, &
d46 1
a46 1
    & L_TNGTGEOCALT, L_VMR, &
d172 1
a172 1
  public :: addGaussianNoise, ApplyBaseline, DeallocateStuff, &
d615 73
d6348 2
a6349 1
    subroutine UncompressRadiance ( key, quantity, termsNode )
d6352 2
d6369 7
d6389 5
d6509 1
a6509 1
       "$Id: FillUtils_1.f90,v 2.5 2008/01/07 21:43:03 pwagner Exp $"
d6520 3
@


2.5
log
@Fixed bug regarding unrecognized ops '<' and '>' in catTwoOperands
@
text
@d189 2
a190 1
      & ScaleOverlaps, SpreadChannelFill, TransferVectors, ANNOUNCE_ERROR
d6274 35
d6421 1
a6421 1
       "$Id: FillUtils_1.f90,v 2.4 2007/11/05 18:41:20 pwagner Exp $"
d6432 3
@


2.4
log
@expr with 'c' unambiguous (I hope); '^' power op added to expr
@
text
@d248 1
a248 1
    subroutine ANNOUNCE_ERROR ( where, CODE , ExtraMessage, ExtraInfo )
d252 1
d264 7
d3265 6
d3651 1
d4156 2
a4157 2
        character(len=1), dimension(7), parameter :: ops = &
          &          (/ '+', '-', '*', '/' , '(', ')', '^' /)
d6385 1
a6385 1
       "$Id: FillUtils_1.f90,v 2.3 2007/11/01 23:33:59 pwagner Exp $"
d6396 3
@


2.3
log
@rewrite to permit functions and algebra in same manipulation; needs more testing
@
text
@d3145 1
a3145 1
    subroutine FillQuantityByManipulation ( quantity, a, b, c, &
d3147 2
a3148 1
      & force, spreadflag, dontSumHeights, dontSumInstances )
d3153 1
a3153 1
      real(rv) :: C                     ! constant "c" in manipulation
d3229 3
a3231 2
      usesc  = .not. ( OneWay .or. TwoWay ) .and. &
        & index(mstr, 'c') > 0
d3521 6
d3631 5
d3749 2
a3750 1
          if ( ( index(element, '*') > 0 .or. index(element, '/') > 0 ) .and. &
d3931 3
d3992 6
d4014 2
d4020 2
d4026 1
a4026 1
                call output( 'Calling function map', advance='yes' )
d4141 2
a4142 2
        character(len=1), dimension(6), parameter :: ops = &
          &          (/ '+', '-', '*', '/' , '(', ')' /)
d6370 1
a6370 1
       "$Id: FillUtils_1.f90,v 2.2 2007/10/04 20:43:12 vsnyder Exp $"
d6381 3
@


2.2
log
@Remove unused symbols
@
text
@a15 1
  ! We need many things from Init_Tables_Module.  First the fields:
d59 1
a59 5
  use MatrixModule_1, only: &
    & Dump, &
    & FindBlock, &
    & Matrix_SPD_T, &
    & UpdateDiagonal
d76 1
a76 1
  use MLSStrings, only: lowerCase, SplitNest
d3161 15
d3217 1
d3299 1
a3299 1
      if ( StatisticalFunction) then
d3497 20
a3565 1
        integer, parameter :: MAXSTRLISTLENGTH = 128
d3644 5
a3648 2
          if (  part1 == ' ' ) then
            collapsedstr = trim(vChar) // ' ' // part3
d3650 2
a3651 1
            collapsedstr = trim(part1) // ' ' // vChar
d3653 5
a3657 2
            collapsedstr = trim(part1) // ' ' // trim(vChar) // &
              & ' ' // part3
d3833 1
d3841 1
d3843 2
d3847 3
d3853 6
d3860 1
a3862 3
        type (arrayTemp_T)              :: newone
        type (arrayTemp_T)              :: part
        logical, parameter              :: DEEBUG = .false.
d3882 4
a3885 3
          if ( DeeBUG ) then
            print *, n, ' str: ', trim(str)
          endif
d3933 23
a3955 17
            read( variable, * ) partID
            if ( partID < 1 ) then
              print *, 'partID: ', partID
              call Announce_Error ( key, no_error_code, 'partID too small' )
              return
            elseif( partID > size(primitives) ) then
              print *, 'partID: ', partID
              call Announce_Error ( key, no_error_code, 'partID too big' )
              return
            endif
            part%values = primitives(partID)%values
            hit = .true.
            if ( deeBug ) then
              print *, 'part"s values after ' // trim(lastOp) // trim(variable)
              call dumpAPrimitive(part)
              print *, 'based on'
              call dumpAPrimitive(primitives(partID))
d3960 3
a3962 1
            select case(lastOp)
d3979 84
d4066 1
a4066 1
                  & lastOp // ' not a legal binary op in evaluatePrimitive' )
d4068 1
d4098 42
d6343 1
a6343 1
       "$Id: FillUtils_1.f90,v 2.1 2007/09/27 21:59:00 pwagner Exp $"
d6354 3
@


2.1
log
@First commit
@
text
@d110 1
a110 1
  character (len=*), private, parameter :: ModuleName= "$RCSfile: Fill.f90,v $"
d3199 1
a3199 1
      integer :: I, ICHAN, INSTANCE, ISURF
d6159 1
a6159 1
       "$Id: Fill.f90,v 2.355 2007/08/27 23:56:34 pwagner Exp $"
d6170 3
@

