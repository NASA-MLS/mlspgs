head	2.22;
access;
symbols
	v5-02-NRT-19:2.22
	v6-00:2.22
	v5-02-NRT-18:2.22
	v5-02:2.22
	v5-01-NRT-17:2.22
	v5-01-NRT-16:2.22
	v5-01-NRT-15:2.22
	v5-01-NRT-14:2.22
	neuralnetworks-1-0:2.22.0.10
	cfm-single-freq-0-1:2.22.0.8
	v5-01:2.22
	v5-00:2.22
	v4-23-TA133:2.22.0.6
	mus-emls-1-70:2.22.0.4
	rel-1-0-englocks-work:2.22.0.2
	VUMLS1-00:2.22
	VPL1-00:2.21
	V4-22-NRT-08:2.21
	VAM1-00:2.21
	V4-21:2.21.0.2
	V4-13:2.21
	V4-12:2.21
	V4-11:2.21
	V4-10:2.21
	V3-43:2.15
	M4-00:2.17
	V3-41:2.15
	V3-40-PlusGM57:2.15.0.2
	V2-24-NRT-04:2.14
	V3-33:2.15
	V2-24:2.14
	V3-31:2.15
	V3-30-NRT-05:2.15
	cfm-01-00:2.15
	V3-30:2.15
	V3-20:2.15
	V3-10:2.15
	V2-23-NRT-02:2.14
	V2-23:2.14
	V2-22-NRT-01:2.14
	V2-22:2.14
	V2-21:2.14
	V2-20:2.14
	V2-11:2.13
	V2-10:2.13
	V2-00:2.12
	V1-51:2.11
	V1-50:2.11
	V1-45:2.11
	V1-44:2.11
	V1-43:2.11
	V1-32:2.8
	V1-31:2.8
	V1-30:2.8
	V1-13:2.8
	V1-12:2.8
	V1-11:2.8
	V1-10:2.8
	newfwm-feb03:2.8.0.2
	V1-04:2.5
	V1-03:2.5
	V1-02:2.5
	JointForwardModel:2.5.0.2
	V1-00:2.5
	newfwm-sep01:2.4.0.2
	V0-7:2.4
	V0-5-Level2:2.4
	V0-5-SIPS:2.4;
locks; strict;
comment	@# @;


2.22
date	2017.03.10.00.41.31;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2013.06.12.02.37.14;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2012.06.07.22.43.54;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2012.05.24.21.07.38;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2006.08.05.02.12.27;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2006.07.27.03.52.06;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2005.06.22.18.57.01;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2004.01.24.01.04.21;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2004.01.23.19.08.44;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2004.01.23.05.47.38;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2002.11.22.12.16.44;	author mjf;	state Exp;
branches;
next	2.7;

2.7
date	2002.10.08.17.36.20;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2002.09.25.20.08.05;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.10.15.22.05.20;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.04.10.22.27.47;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.22.21.58.42;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2000.12.19.20.14.57;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.11.16.02.01.03;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.02;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.02.02.05.04;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.22
log
@Make RELATIVEQUANTITIES allocatable
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module ConstructVectorTemplates ! Construct a template for a vector
!=============================================================================

  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use DUMP_0, only: DUMP
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INIT_TABLES_MODULE, only: F_ADOPT, F_QUANTITIES, &
    & F_REMOVEQUANTITIES, F_REMOVETEMPLATE, F_SOURCE, F_TEMPLATE, &
    & FIELD_FIRST, FIELD_LAST
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
  use MLSSETS, only: RELATIVECOMPLEMENT
  use OUTPUT_M, only: OUTPUT
  use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T
  use STRING_TABLE, only: GET_STRING
  use TOGGLES, only: GEN, TOGGLE, LEVELS
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE, WHERE
  use VECTORSMODULE, only: CONSTRUCTVECTORTEMPLATE, VECTORTEMPLATE_T, &
    & NULLIFYVECTORTEMPLATE
  use L2PC_M, only: ADOPTVECTORTEMPLATE

  implicit none
  private
  public :: CreateVecTemplateFromMLSCfInfo
  
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: ConstructVectorTemplates.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  logical, parameter :: DEEBUG = .false.

  ! This module performs the vector template aspects of the construct task

contains ! =====     Public Procedures     =============================

  ! -----------------------------  CreateVecTemplateFromMLSCfInfo  -----
  type (VectorTemplate_T) function CreateVecTemplateFromMLSCfInfo &
    & ( NAME, ROOT, quantityTemplates ) result ( vectorTemplate )

  ! Process the vectorTemplate specification.

    ! Dummy arguments
    integer, intent(in) :: NAME         ! Sub-rosa of name, if any, or zero
    integer, intent(in) :: ROOT         ! Of AST for a vectorTemplate
    type (QuantityTemplate_T), dimension(:), pointer :: quantityTemplates

    ! Local variables
    integer :: I, J                     ! Loop inductors
    integer :: NOQUANTITIES             ! How many selections?
    integer :: NOREMOVEDQUANTITIES      ! How many selections?
    integer :: NOUNIQUEQUANTITIES       ! How many selections are unique?
    integer, dimension(:), pointer :: QUANTITIES
    integer, dimension(:), allocatable :: RELATIVEQUANTITIES
    integer, dimension(:), pointer :: REMOVEDQUANTITIES
    integer :: SON                      ! Son of Root
    integer :: KEY                      ! Son of son
    integer :: ADOPTBIN                 ! Name of l2pc bin to adopt
    integer :: SOURCE                   ! l_rows or l_columns
    logical, dimension(field_first:field_last) :: GOT ! Fields
    character(len=80) :: MESSAGE        ! Possible error message
    logical, parameter :: DIEIFDUP = .false.
        
    ! Executable code

    if ( toggle(gen) .and. levels(gen) > 0 ) call &
      & trace_begin ( "ConstructVectorTemplateFromMLSCfInfo", root )

    call nullifyVectorTemplate ( vectorTemplate ) ! for Sun's still useless compiler
    nullify ( quantities, removedQuantities )
    got = .false.
    noQuantities = 0
    noRemovedQuantities = 0

    ! Loop over the arguments
    ! call outputNamedValue( 'Nsons(root) Construct', nsons(root) )
    do i = 2, nsons(root)     ! Skip the "vectorTemplate" name
      son = subtree(i,root)
      key = subtree(1,son)
      got ( decoration(key) ) = .true.
      select case ( decoration(key) )
      case ( f_adopt )
        adoptBin = sub_rosa(subtree(2,son))
      case ( f_source )
        source = decoration ( subtree(2,son) )
      case ( f_quantities )
        noQuantities = noQuantities + nsons(son) - 1
      case ( f_removeQuantities )
        noRemovedQuantities = noRemovedQuantities + nsons(son) - 1
      case ( f_removeTemplate )
        do j = 2, nsons(son)  ! Skip the "template" name
          call count_quantities ( decoration(subtree(j,son)), noRemovedQuantities )
        end do
      case ( f_template )
        ! call outputNamedValue( 'NoQuantities on entering Construct', noQuantities )
        ! call outputNamedValue( 'Nsons(son) template', nsons(son) )
        do j = 2, nsons(son)  ! Skip the "template" name
          ! call output( 'Entering count_quantities', advance='yes' )
          call count_quantities ( decoration(subtree(j,son)), noQuantities )
        end do
        ! call outputNamedValue( 'NoQuantities on leaving Construct', noQuantities )
      end select
    end do

    if ( got ( f_adopt ) .or. got ( f_source) ) then
      ! Adoption requested
      if ( .not. got ( f_source ) ) call Announce_Error ( key, &
        & 'Must supply source=rows/columns for adoption' )
      vectorTemplate = AdoptVectorTemplate ( adoptBin, name, quantityTemplates, source, message )
      if ( len_trim(message) > 0 ) call Announce_Error ( key, message )
      if ( got ( f_quantities ) ) then
        do j = 1, noQuantities
          if ( all ( quantities(j) /= vectorTemplate%quantities ) ) then
            call get_string ( quantityTemplates(quantities(j))%name, message, strip=.true. )
            call Announce_Error ( key, 'Quantity ' // trim(message) // ' is not in this adopted template' )
          end if
        end do
      end if
      if ( toggle(gen) .and. levels(gen) > 0 ) call &
        & trace_end ( "ConstructVectorTemplateFromMLSCfInfo" )
      return
    else if ( got ( f_quantities ) .or. got ( f_template ) ) then
      ! Not an adoption, just a regular template construction
      call allocate_test ( quantities, noQuantities, "quantities", ModuleName )
      noQuantities = 0
      noUniqueQuantities = 0
      call fill_quantities ( root, quantities )
    else
      ! User didn't give appropriate command
      call Announce_Error ( key, 'Must supply adopt, quantites, source, or template' )
    end if
    ! Do we wish to remove any quantities?
    if ( got ( f_removeQuantities ) .or. got ( f_removeTemplate ) ) then
      if ( DEEBUG ) call outputNamedValue( 'Num of values to be removed', noRemovedQuantities )
      call allocate_test ( removedQuantities, noRemovedQuantities, &
        & "removedQuantities", ModuleName )
      noQuantities = 0
      noUniqueQuantities = 0
      call fill_quantities ( root, removedQuantities, remove=.true. )
      ! Now let's try to remove them
      if ( DEEBUG ) then
        call dump( Quantities, 'Quantities ' )
        call dump( removedQuantities, 'removedQuantities ' )
      endif
      relativeQuantities = RelativeComplement( removedQuantities, Quantities )
      if ( DEEBUG ) call dump( relativeQuantities, 'relativeQuantities ' )
      call ConstructVectorTemplate ( name, &
        & quantityTemplates, relativeQuantities, &
        & vectorTemplate, where=where(root), forWhom=moduleName )
      call deallocate_test ( removedQuantities, "removedQuantities", ModuleName )
      call deallocate_test ( quantities, "quantities", ModuleName )
      call deallocate_test ( relativeQuantities, "relativeQuantities", ModuleName )
    else
      call ConstructVectorTemplate ( name, &
        & quantityTemplates, quantities(1:noUniqueQuantities), &
        & vectorTemplate, where=where(root), forWhom=moduleName )
      call deallocate_test ( quantities, "quantities", ModuleName )
    endif

    if ( toggle(gen) .and. levels(gen) > 0 ) call &
      & trace_end ( "ConstructVectorTemplateFromMLSCfInfo" )

  contains

    recursive subroutine Count_Quantities ( Root, noQuantities )
      integer, intent(in)    :: Root ! of a spec_args in a vectorTemplate
      integer, intent(inout) :: noQuantities ! How many?
      integer :: I, J, Son
      do i = 2, nsons(root)
        son = subtree(i,root)
        select case ( decoration(subtree(1,son)) )
        case ( f_quantities )
          noQuantities = noQuantities + nsons(son) - 1
        case ( f_template )
          ! call outputNamedValue( 'NoQuantities on entering Count', noQuantities )
          do j = 2, nsons(son)  ! Skip the "template" name
            call count_quantities ( decoration(subtree(j,son)), noQuantities )
          end do
          ! call outputNamedValue( 'NoQuantities on leaving Count', noQuantities )
        end select
      end do
    end subroutine Count_Quantities

    recursive subroutine Fill_Quantities ( Root, quantities, remove )
      integer, intent(in)            :: Root ! of a spec_args in a vectorTemplate
      integer, dimension(:), pointer :: quantities
      logical, optional, intent(in)  :: remove
      integer :: I, J, Son
      integer :: qIndex
      logical :: myRemove
      myRemove = .false.
      if ( present(remove) ) myRemove = remove
      if ( myRemove .and. DEEBUG ) call output ( 'Removing quantities', advance='yes' )
      do i = 2, nsons(root)
        son = subtree(i,root)
        if ( myRemove ) then
          if ( any( decoration(subtree(1,son)) == &
            & (/ f_quantities, f_template /) ) ) cycle
        else
          if ( any( decoration(subtree(1,son)) == &
            & (/ f_removequantities, f_removetemplate /) ) ) cycle
        endif
        select case ( decoration(subtree(1,son)) )
        case ( f_quantities, f_removeQuantities )
          do j = 2, nsons(son)
            noQuantities = noQuantities + 1
            ! Get the quantity index that was put into the AST by Construct:
            ! quantities(noQuantities) = decoration(decoration(subtree(j,son)))
            qIndex =  decoration(decoration(subtree(j,son)))
            if ( noUniqueQuantities < 1 ) then
              noUniqueQuantities = noUniqueQuantities + 1
              quantities(noUniqueQuantities) = qIndex
            elseif ( any( qindex == quantities(1:noUniqueQuantities) ) ) then
              if ( DIEIFDUP ) call Announce_Error  ( key, 'Duplicate quantities' )
            else
              noUniqueQuantities = noUniqueQuantities + 1
              quantities(noUniqueQuantities) = qIndex
            endif
          end do ! j = 2, nsons(son)
        case ( f_template, f_removetemplate )
          if ( myRemove .and. DEEBUG ) &
            & call outputnamedValue( 'noQuantities before removeTemplate', &
            & (/ noQuantities, noUniqueQuantities /) )
          do j = 2, nsons(son)  ! Skip the "template" name
          ! The following is a tricky point:
            ! We want to remove the quantities that are part of the template
            ! Note however that when the template was defined, they were
            ! part of a 'quantities" field, not part of a "removeQuantities" field
            call fill_quantities ( decoration(subtree(j,son)), quantities, &
              & remove=.false. )
          end do
          if ( myRemove .and. DEEBUG ) &
            & call outputnamedValue( 'noQuantities after removeTemplate', &
            & (/ noQuantities, noUniqueQuantities /) )
        end select
      end do
    end subroutine Fill_Quantities

  end function CreateVecTemplateFromMLSCfInfo

!=============================================================================

  ! -----------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( where, message, extra )

    use INTRINSIC, only: LIT_INDICES
    use MORETREE, only: STARTERRORMESSAGE
    use STRING_TABLE, only: DISPLAY_STRING

    integer, intent(in) :: WHERE   ! Tree node where error was noticed
    character (LEN=*), intent(in) :: MESSAGE
    integer, intent(in), optional :: EXTRA

    call startErrorMessage ( where )
    call output ( message )
    if ( present ( extra ) ) call display_string ( lit_indices ( extra ), strip=.true. )
    call output ( '', advance='yes' )
    call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem with vector template construction' )
  end subroutine Announce_Error

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ConstructVectorTemplates.f90,v 2.21 2014/01/09 00:30:24 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

END MODULE ConstructVectorTemplates
!=============================================================================

!
! $Log: ConstructVectorTemplates.f90,v $
! Revision 2.21  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.20  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.19  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.18  2013/06/12 02:37:14  vsnyder
! Cruft removal
!
! Revision 2.17  2012/06/07 22:43:54  pwagner
! May remove Quantities, vectorTemplates
!
! Revision 2.16  2012/05/24 21:07:38  vsnyder
! Allow any number of template and quantities fields.  Trace out template
! fields recursively until arriving at template fields.  The quantities of
! the created template are the totality of the quantities in quantities fields,
! and in quantities fields of referenced vector templates.
!
! Revision 2.15  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.14  2006/08/05 02:12:27  vsnyder
! Add ForWhom argument to ConstructVectorTemplate
!
! Revision 2.13  2006/07/27 03:52:06  vsnyder
! Pass source_ref to ConstructVectorTemplate
!
! Revision 2.12  2005/06/22 18:57:01  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.11  2004/01/24 01:04:21  livesey
! Added stuff to allow one to adopt quantities
!
! Revision 2.10  2004/01/23 19:08:44  livesey
! Changes / improvements to the adoption.
!
! Revision 2.9  2004/01/23 05:47:38  livesey
! Added the adoption stuff
!
! Revision 2.8  2002/11/22 12:16:44  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.7  2002/10/08 17:36:20  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.6  2002/09/25 20:08:05  livesey
! Made -g less verbose
!
! Revision 2.5  2001/10/15 22:05:20  livesey
! Got rid of the signals stuff which was never implemented
!
! Revision 2.4  2001/04/10 22:27:47  vsnyder
! Nullify explicitly instead of with <initialization> so as not to give
! pointers the SAVE attribute.  <initialization> is NOT executed on each
! entry to a procedure.
!
! Revision 2.3  2001/02/22 21:58:42  livesey
! Nullified a pointer
!
! Revision 2.2  2000/12/19 20:14:57  vsnyder
! Add test for duplicate quantities.
!
! Revision 2.1  2000/11/16 02:01:03  vsnyder
! Remove unused variable STATUS.
!
! Revision 2.0  2000/09/05 18:57:02  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:04  vsnyder
! Initial entry
!

@


2.21
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d67 1
a67 1
    integer, dimension(:), pointer :: RELATIVEQUANTITIES
d158 1
a158 1
      relativeQuantities => RelativeComplement( removedQuantities, Quantities )
d277 1
a277 1
       "$Id: ConstructVectorTemplates.f90,v 2.20 2013/09/24 23:47:22 vsnyder Exp $"
d289 3
@


2.20
log
@Use Where instead of Source_Ref for messages
@
text
@d18 1
d24 1
a24 1
  use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d277 1
a277 1
       "$Id: ConstructVectorTemplates.f90,v 2.19 2013/08/12 23:49:41 pwagner Exp $"
d289 3
@


2.19
log
@FindSomethings moved to MLSFinds module
@
text
@d28 1
a28 2
  use TREE, only: DECORATION, NSONS, SOURCE_REF, SUB_ROSA, &
    & SUBTREE
d161 1
a161 1
        & vectorTemplate, where=source_ref(root), forWhom=moduleName )
d168 1
a168 1
        & vectorTemplate, where=source_ref(root), forWhom=moduleName )
d276 1
a276 1
       "$Id: ConstructVectorTemplates.f90,v 2.18 2013/06/12 02:37:14 vsnyder Exp $"
d288 3
@


2.18
log
@Cruft removal
@
text
@d16 2
a17 2
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use dump_0, only: DUMP
d21 1
a21 1
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
d23 3
a25 3
  use Output_M, only: OUTPUT, OUTPUTNAMEDVALUE
  use QuantityTemplates, only: QUANTITYTEMPLATE_T
  use String_Table, only: GET_STRING
d30 1
a30 1
  use VectorsModule, only: CONSTRUCTVECTORTEMPLATE, VECTORTEMPLATE_T, &
d32 1
a32 1
  use L2PC_m, only: ADOPTVECTORTEMPLATE
d259 3
a261 3
    use Intrinsic, only: LIT_INDICES
    use MoreTree, only: STARTERRORMESSAGE
    use String_Table, only: DISPLAY_STRING
d277 1
a277 1
       "$Id: ConstructVectorTemplates.f90,v 2.17 2012/06/07 22:43:54 pwagner Exp $"
d289 3
@


2.17
log
@May remove Quantities, vectorTemplates
@
text
@d62 1
a62 1
    integer :: I, J, K                  ! Loop inductors
d277 1
a277 1
       "$Id: ConstructVectorTemplates.f90,v 2.16 2012/05/24 21:07:38 vsnyder Exp $"
d289 3
@


2.16
log
@Allow any number of template and quantities fields.  Trace out template
fields recursively until arriving at template fields.  The quantities of
the created template are the totality of the quantities in quantities fields,
and in quantities fields of referenced vector templates.
@
text
@d16 10
a25 7
  use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
  use INIT_TABLES_MODULE, only: F_ADOPT, F_QUANTITIES, F_SOURCE, F_Template, &
    & FIELD_FIRST, FIELD_LAST, L_ROWS, L_COLUMNS
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
  use Output_M, only: Output
  use QuantityTemplates, only: QuantityTemplate_T
  use String_Table, only: Display_String, Get_String
d28 1
a28 1
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, SOURCE_REF, SUB_ROSA, &
d30 2
a31 2
  use VectorsModule, only: ConstructVectorTemplate, VectorTemplate_T, &
    & NullifyVectorTemplate
d35 2
a36 1
  public
d44 2
d64 2
d67 2
d75 1
d83 1
a83 1
    nullify ( quantities )
d86 1
d89 1
d101 6
d108 2
d111 2
a112 1
          call count_quantities ( decoration(subtree(j,son)) )
d114 1
d132 3
d136 1
d139 23
a161 3
      call fill_quantities ( root )
      ! Not an adoption, just a regular template construction
      call ConstructVectorTemplate ( name, quantityTemplates, quantities, &
d163 1
d165 1
d167 5
a171 3
      ! User didn't give appropriate command
      call Announce_Error ( key, 'Must supplier either quantity list or adoption' )
    end if
d178 4
a181 3
    recursive subroutine Count_Quantities ( Root )
      integer, intent(in) :: Root ! of a spec_args in a vectorTemplate
      integer :: I, Son
d188 1
d190 1
a190 1
            call count_quantities ( decoration(subtree(j,son)) )
d192 1
d197 10
a206 3
    recursive subroutine Fill_Quantities ( Root )
      integer, intent(in) :: Root ! of a spec_args in a vectorTemplate
      integer :: I, J, K, Son
d209 7
d217 1
a217 1
        case ( f_quantities )
d221 11
a231 6
            quantities(noQuantities) = decoration(decoration(subtree(j,son)))
            ! Check for duplicate quantities
            do k = 1, noQuantities - 1
              if ( quantities(k) == quantities(noQuantities) ) &
                & call Announce_Error  ( key, 'Duplicate quantities' )
            end do ! k = 1, noQuantities - 1
d233 4
a236 1
        case ( f_template )
d238 6
a243 1
            call fill_quantities ( decoration(subtree(j,son)) )
d245 3
d260 1
a260 3
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
    use MoreTree, only: StartErrorMessage
    use OUTPUT_M, only: OUTPUT
d277 1
a277 1
       "$Id: ConstructVectorTemplates.f90,v 2.15 2009/06/23 18:46:18 pwagner Exp $"
d289 6
@


2.15
log
@Prevent Intel from optimizing ident string away
@
text
@d17 2
a18 2
  use INIT_TABLES_MODULE, only: F_QUANTITIES, FIELD_FIRST, FIELD_LAST, &
    & F_ADOPT, L_ROWS, L_COLUMNS, F_SOURCE
d36 1
a36 1
       "$RCSfile: $"
d87 5
a91 11
        noQuantities = nsons(son) - 1
        call allocate_test ( quantities, noQuantities, "quantities", ModuleName )
        do j = 2, nsons(son)  ! Skip the "quantities" name
          ! Get the quantity index that was put into the AST by Construct:
          quantities(j-1) = decoration(decoration(subtree(j,son)))
          ! Check for duplicate quantities
          do k = 1, j-2
            if ( quantities(k) == quantities(j-1) ) &
              & call Announce_Error  ( key, 'Duplicate quantities' )
          end do ! k = 1, noQuantities - 1
        end do ! j = 2, nsons(son)
d109 4
a112 1
    else if ( got ( f_quantities ) ) then
d125 43
d195 1
a195 1
       "$Id: read_apriori.f90 is it here $"
d207 3
@


2.14
log
@Add ForWhom argument to ConstructVectorTemplate
@
text
@d36 1
a36 1
       "$RCSfile: ConstructVectorTemplates.f90,v $"
d152 1
a153 1
!---------------------------- RCS Ident Info -------------------------------
d155 2
a156 3
       "$Id: ConstructVectorTemplates.f90,v 2.13 2006/07/27 03:52:06 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d158 1
d160 1
d167 3
@


2.13
log
@Pass source_ref to ConstructVectorTemplate
@
text
@d118 1
a118 1
        & vectorTemplate, where=source_ref(root) )
d135 3
a137 1
    use LEXER_CORE, only: PRINT_SOURCE
a138 2
    use TREE, only: SOURCE_REF
    use Intrinsic, only: LIT_INDICES
a139 1
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
d145 1
a145 7
    call output ( '***** At ' )
    if ( where > 0 ) then
      call print_source ( source_ref(where) )
    else
      call output ( '(no lcf tree available)' )
    end if
    call output ( ': ' )
d155 1
a155 1
       "$Id: ConstructVectorTemplates.f90,v 2.12 2005/06/22 18:57:01 pwagner Exp $"
d166 3
@


2.12
log
@Reworded Copyright statement, moved rcs id
@
text
@d36 1
a36 1
       "$RCSfile: $"
d118 1
a118 1
        & vectorTemplate )
d162 1
a162 1
       "$Id: $"
d173 3
@


2.11
log
@Added stuff to allow one to adopt quantities
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d34 3
a36 5
  private :: Id, ModuleName
  !---------------------------- RCS Ident Info -------------------------------
  character (LEN=256) :: Id = &
       "$Id: ConstructVectorTemplates.f90,v 2.10 2004/01/23 19:08:44 livesey Exp $"
  character (len=*), parameter :: ModuleName= "$RCSfile: ConstructVectorTemplates.f90,v $"
d38 1
a38 1
  !---------------------------------------------------------------------------
d160 5
d173 3
@


2.10
log
@Changes / improvements to the adoption.
@
text
@d14 1
a14 1
  use String_Table, only: Display_String
d29 1
a29 1
       "$Id: ConstructVectorTemplates.f90,v 2.9 2004/01/23 05:47:38 livesey Exp $"
d58 1
a96 2
      if ( got ( f_quantities ) ) call Announce_Error ( key, &
        & 'Cannot supply both quantities and adopt/source' )
d99 10
a108 3
      vectorTemplate = AdoptVectorTemplate ( adoptBin, quantityTemplates, source=source )
      if ( .not. associated ( vectorTemplate%quantities ) ) call Announce_Error ( key, &
        & 'No such l2pc bin to adopt' )
d162 3
@


2.9
log
@Added the adoption stuff
@
text
@d10 1
a10 1
    & F_ADOPTROWS, F_ADOPTCOLUMNS, L_ROWS, L_COLUMNS
d29 1
a29 1
       "$Id: ConstructVectorTemplates.f90,v 2.8 2002/11/22 12:16:44 mjf Exp $"
d50 2
a51 2
    integer :: I, J, K        ! Loop inductors
    integer :: NOQUANTITIES    ! How many selections?
d53 4
a56 2
    integer :: SON            ! Son of Root
    integer :: KEY            ! Son of son
d75 4
a78 6
      case ( f_adoptColumns )
        vectorTemplate = AdoptVectorTemplate ( sub_rosa(subtree(2,son)), quantityTemplates, &
          & source=l_columns )
      case ( f_adoptRows )
        vectorTemplate = AdoptVectorTemplate ( sub_rosa(subtree(2,son)), quantityTemplates, &
          & source=l_rows )
d94 11
a104 7
    if ( (  got ( f_adoptColumns ) .or. got ( f_adoptRows ) ) .and. &
      & .not. associated ( vectorTemplate%quantities ) ) call Announce_Error ( key, &
      & 'No such l2pc bin to adopt' )

    if ( got ( f_quantities ) ) then
      if ( got ( f_adoptColumns ) .or. got ( f_adoptRows ) ) &
        & call Announce_Error ( key, 'Cannot supply both quantities and adoptRows/Columns' )
d108 3
a115 3
    if ( got ( f_adoptColumns ) .and. got ( f_adoptRows ) ) &
      & call Announce_Error ( key, 'Cannot supply both adoptColumns and adoptRows' )

d156 3
@


2.8
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d9 2
a10 1
  use INIT_TABLES_MODULE, only: F_QUANTITIES
d21 1
d29 1
a29 1
       "$Id: ConstructVectorTemplates.f90,v 2.7 2002/10/08 17:36:20 pwagner Exp $"
d47 1
a47 1
    type (QuantityTemplate_T), dimension(:) :: quantityTemplates
d51 2
a52 2
    integer :: nSelections    ! How many selections?
    integer, dimension(:), pointer :: SELECTED
d54 3
a56 2
    integer :: SOURCE         ! 256*line + column of erroneous input

d63 3
a65 7
    nullify ( selected )

    ! Compute the number of selections
    nSelections = 0
    do i = 2, nsons(root)
      nSelections = nSelections + nsons(subtree(i,root)) - 1
    end do
d67 1
a67 7
    call allocate_test ( selected, nSelections, "selected", ModuleName )

    ! Loop through the MLSCF information supplied.  Items are either
    ! lists of quantity template labels, or lists of complete MLS signal
    ! specification strings.

    nSelections = 0
d69 10
a78 3
      son = subtree(i,root)   ! An "assign" vertex of the abstract syntax tree
      ! Currently only one field, but we'll leave the case statement in to be sure
      select case ( decoration(subtree(1,son)) )
d80 2
a82 1
          nSelections = nSelections + 1
d84 1
a84 1
          selected(nSelections) = decoration(decoration(subtree(j,son)))
d86 4
a89 14
          do k = 1, nSelections - 1
            if ( selected(k) == selected(nSelections) ) then
              source = source_ref( subtree(j,son) )
              call output ( 'At line '  )
              call output ( mod(source,256) )
              call output ( ', column ' )
              call output ( source/256 )
              call output ( ', the quantity ' )
              call display_string( sub_rosa(subtree(j,son)) )
              call output ( ' duplicates a previous one.', advance='yes' )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                "Duplicate quantity specified in vector template" )
            end if
          end do ! k = 1, nSelections - 1
d94 11
a104 6
    ! Now finally construct the vector template

    call ConstructVectorTemplate ( name, quantityTemplates, selected, &
         & vectorTemplate )

    call deallocate_test ( selected, "selected", ModuleName )
d109 3
d115 28
d152 4
@


2.7
log
@Added idents to survive zealous Lahey optimizer
@
text
@d18 2
a19 1
  use VectorsModule, only: ConstructVectorTemplate, VectorTemplate_T
d27 1
a27 1
       "$Id: ConstructVectorTemplates.f90,v 2.6 2002/09/25 20:08:05 livesey Exp $"
d59 1
d125 3
@


2.6
log
@Made -g less verbose
@
text
@d26 1
a26 1
       "$Id: ConstructVectorTemplates.f90,v 2.5 2001/10/15 22:05:20 livesey Exp $"
d28 1
d114 4
d123 3
@


2.5
log
@Got rid of the signals stuff which was never implemented
@
text
@d14 1
a14 1
  use TOGGLES, only: GEN, TOGGLE
d26 1
a26 1
       "$Id: ConstructVectorTemplates.f90,v 2.4 2001/04/10 22:27:47 vsnyder Exp $"
d54 1
a54 1
    if ( toggle(gen) ) call &
d107 1
a107 1
    if ( toggle(gen) ) call &
d118 3
@


2.4
log
@Nullify explicitly instead of with <initialization> so as not to give
pointers the SAVE attribute.  <initialization> is NOT executed on each
entry to a procedure.
@
text
@d9 1
a9 1
  use INIT_TABLES_MODULE, only: F_QUANTITIES, F_SIGNALS
d26 1
a26 1
       "$Id: ConstructVectorTemplates.f90,v 2.3 2001/02/22 21:58:42 livesey Exp $"
d74 1
a96 3
      case ( f_signals ) ! ??? Needs work here ???
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          "This version can't handle the SIGNALS field of a vector template" )
d118 5
@


2.3
log
@Nullified a pointer
@
text
@d26 1
a26 1
       "$Id: ConstructVectorTemplates.f90,v 2.2 2000/12/19 20:14:57 vsnyder Exp $"
d48 1
a48 1
    integer, dimension(:), pointer :: SELECTED => NULL()
d57 2
d120 3
@


2.2
log
@Add test for duplicate quantities.
@
text
@d26 1
a26 1
       "$Id: ConstructVectorTemplates.f90,v 2.1 2000/11/16 02:01:03 vsnyder Exp $"
d48 1
a48 1
    integer, dimension(:), pointer :: SELECTED
d118 3
@


2.1
log
@Remove unused variable STATUS.
@
text
@d11 1
d13 1
a13 1
  use VectorsModule, only: ConstructVectorTemplate, VectorTemplate_T
d16 3
a18 1
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, SUBTREE
d26 1
a26 1
       "$Id: ConstructVectorTemplates.f90,v 2.0 2000/09/05 18:57:02 ahanzel Exp $"
d46 1
a46 1
    integer :: I, J           ! Loop inductors
d50 1
d78 16
a93 1
        end do
d118 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@d23 1
a23 1
       "$Id: ConstructVectorTemplates.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
a46 1
    integer :: STATUS         ! From allocate
d99 3
@


1.1
log
@Initial entry
@
text
@d23 1
a23 1
       "$Id: ConstructVectorTemplates.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
d100 3
d106 1
a106 7
! Revision 1.2  2000/01/11 22:51:34  livesey
! Dealt with ramifications of change from read_parse_l2cf to MLSCF
!
! Revision 1.1  1999/12/18 03:00:45  livesey
! First version
!
!
@


