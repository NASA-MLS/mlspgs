head	2.122;
access;
symbols
	v5-02-NRT-19:2.122
	v6-00:2.122
	v5-02-NRT-18:2.122
	v5-02:2.119
	v5-01-NRT-17:2.122
	v5-01-NRT-16:2.122
	v5-01-NRT-15:2.121
	v5-01-NRT-14:2.120
	neuralnetworks-1-0:2.119.0.4
	cfm-single-freq-0-1:2.119.0.2
	v5-01:2.119
	v5-00:2.119
	v4-23-TA133:2.118.0.2
	mus-emls-1-70:2.117.0.4
	rel-1-0-englocks-work:2.117.0.2
	VUMLS1-00:2.113
	VPL1-00:2.110
	V4-22-NRT-08:2.108
	VAM1-00:2.108
	V4-21:2.108.0.2
	V4-13:2.108
	V4-12:2.107
	V4-11:2.107
	V4-10:2.107
	V3-43:2.97
	M4-00:2.101
	V3-41:2.97
	V3-40-PlusGM57:2.97.0.2
	V2-24-NRT-04:2.96
	V3-33:2.97
	V2-24:2.96
	V3-31:2.97
	V3-30-NRT-05:2.97
	cfm-01-00:2.97
	V3-30:2.97
	V3-20:2.97
	V3-10:2.97
	V2-23-NRT-02:2.96
	V2-23:2.96
	V2-22-NRT-01:2.96
	V2-22:2.96
	V2-21:2.94
	V2-20:2.94
	V2-11:2.93
	V2-10:2.93
	V2-00:2.92
	V1-51:2.81
	V1-50:2.81
	V1-45:2.79
	V1-44:2.79
	V1-43:2.76
	V1-32:2.76
	V1-31:2.76
	V1-30:2.74
	V1-13:2.70
	V1-12:2.70
	V1-11:2.70
	V1-10:2.69
	newfwm-feb03:2.69.0.2
	V1-04:2.61
	V1-03:2.61
	V1-02:2.61
	JointForwardModel:2.61.0.2
	V1-00:2.61
	newfwm-sep01:2.53.0.2
	V0-7:2.53
	V0-5-Level2:2.42
	V0-5-SIPS:2.39
	V0_1:1.12;
locks; strict;
comment	@# @;


2.122
date	2022.03.16.22.20.55;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2021.09.01.16.59.40;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2021.07.22.23.16.01;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2019.04.18.16.29.53;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2018.11.01.23.16.25;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2017.11.15.00.15.49;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2017.07.27.16.41.51;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2017.07.10.18.55.35;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2017.03.24.22.58.18;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2017.01.19.23.56.44;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2016.11.08.17.31.47;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2016.09.22.22.57.25;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2016.08.09.21.21.13;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2016.07.28.01.45.07;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2014.09.05.01.26.25;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2014.03.26.17.46.25;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2014.03.07.19.24.48;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2013.12.05.01.43.48;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2013.08.30.02.45.50;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2013.08.17.02.55.23;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2012.08.16.17.49.40;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2012.04.05.20.14.39;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2012.03.28.20.09.38;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2011.06.29.21.49.43;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2007.10.04.20.43.12;	author vsnyder;	state Exp;
branches;
next	2.95;

2.95
date	2007.06.21.00.54.08;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2006.09.21.18.50.33;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2006.07.07.23.11.19;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2006.03.15.23.52.24;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2006.02.16.00.16.01;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2006.02.10.21.16.20;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2006.01.27.01.03.29;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2006.01.19.00.31.54;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2005.09.22.23.38.12;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2005.07.21.23.45.21;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2005.07.12.17.17.46;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2005.06.14.20.39.25;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2005.05.31.17.51.17;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2004.12.28.00.23.03;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2004.12.15.23.35.59;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2004.08.16.17.14.42;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2004.08.04.23.19.58;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2004.06.29.00.10.17;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2003.10.29.00.07.17;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2003.10.09.23.41.06;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2003.09.12.16.28.56;	author cvuu;	state Exp;
branches;
next	2.73;

2.73
date	2003.07.07.23.50.05;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2003.06.09.22.49.34;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2003.05.29.17.55.23;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2003.02.27.21.55.14;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2003.02.01.00.38.33;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2002.12.11.22.18.48;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2002.11.13.01.10.40;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2002.10.08.17.36.22;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2002.10.03.23.02.48;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2002.09.27.23.47.23;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2002.08.28.22.28.37;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2002.08.21.02.23.39;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2002.01.26.00.09.14;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2002.01.24.00.14.26;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2001.12.16.00.57.46;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2001.11.01.21.06.17;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2001.10.30.00.33.24;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2001.10.25.23.33.59;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2001.09.28.23.59.20;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2001.08.09.00.23.05;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2001.05.24.20.34.50;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2001.05.17.22.31.54;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2001.05.17.00.27.55;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2001.05.11.23.43.35;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2001.05.10.18.22.57;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2001.05.09.23.32.15;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2001.05.07.23.28.19;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2001.05.06.20.55.25;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2001.05.04.22.56.40;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2001.05.04.17.09.03;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2001.04.20.18.16.29;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2001.04.19.23.51.40;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2001.04.18.17.33.29;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2001.04.16.23.45.59;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2001.04.16.17.45.54;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2001.04.12.00.20.44;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2001.04.11.02.00.01;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2001.04.11.00.47.25;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2001.04.11.00.33.45;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2001.04.11.00.00.56;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2001.04.10.23.00.29;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2001.04.06.20.20.43;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2001.04.06.18.01.00;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2001.04.05.23.44.53;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2001.04.05.23.40.50;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.04.23.46.18;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.03.20.51.27;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.02.23.39.09;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2001.03.28.19.07.59;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2001.03.28.19.07.08;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2001.03.15.21.18.57;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2001.03.10.07.07.58;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.03.07.22.49.17;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.03.03.00.08.58;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2001.02.27.01.30.46;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.02.23.18.17.35;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.02.23.00.53.07;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.02.16.00.48.07;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.02.13.22.59.36;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2001.02.09.00.38.22;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.02.08.00.58.14;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.01.03.00.47.21;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2000.12.04.21.47.46;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2000.12.02.01.11.59;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2000.12.02.00.00.40;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2000.12.01.23.35.25;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2000.11.30.00.23.58;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2000.11.29.17.35.30;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2000.11.29.00.27.54;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2000.11.16.01.02.16;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2000.09.11.19.48.01;	author ahanzel;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.06;	author ahanzel;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.30.00.10.01;	author lungu;	state Exp;
branches;
next	;


desc
@@


2.122
log
@Remove conflict between mlspcf_l2_param_CrashMsg and mlspcf_l2_param_col_spec_keys
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Open_Init

  !     For level 2 runs that use the PCF
  ! -----------------------------------------------
  ! Opens and closes several files                 |
  ! Creates and destroys the L1BInfo database      |
  ! Reads user params as PCF-supplied config data  |
  ! -----------------------------------------------

  use HighOutput, only: AddRow, AddRow_Divider, AddRow_Header, BeVerbose, &
    & OutputNamedValue, OutputTable, StartTable, StyledOutput
  use MLSCommon, only: FileNameLen, MLSFile_T, NameLen, TAI93_Range_T
  use MLSL2Options, only: MLSL2Message, SpecialDumpFile, Toolkit
  use MLSStringLists, only: Array2List, CatLists, &
    & SwitchDetail
  use Output_M, only: Blanks, NewLine, Output, SwitchOutput, RevertOutput

  implicit none

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (subroutines and functions)
! OpenAndInitialize               Gets run parameters from pcf
! === (end of toc) ===

  private
  public :: DumpL1BDatabase, OpenAndInitialize

  ! -----     Private declarations     ---------------------------------

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: open_init.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  integer, parameter :: MLSPCF_LOG = 10101 ! This seems to be hard-wired into PCF
  integer, parameter :: CCSDSLen   = 27
  integer, parameter :: NUMDOIs    = 27
  logical, parameter :: ALWAYSGETSWITCHESCONFIG = .false.
  integer, private ::   ERROR

  ! -------------------------------------------------------------------
  ! The next parameter optionally sets level 2 to crash with a walkback
  ! if it logs a message containing a fatal string
  ! E.g., put the next line in your PCF
  ! 2008|CrashMsg|Drop. Dead.
  ! and your run will automatically crash at the point where it logs
  ! any message containing the string "Drop. Dead."

  ! We must not reort to hard-wiring this PCFId
  ! The original value chosen (2008) conflicted with the value for
  ! mlspcf_l2_param_col_spec_keys. That leaves us wondering why
  ! it never crashed.
  ! integer, parameter :: mlspcf_l2_param_CrashMsg = 2008
  ! See also MLSL2Options for the same mechanism implemented in the opts file
  ! -------------------------------------------------------------------
  
contains ! =====     Public Procedures     =============================

  ! ------------------------------------------  OpenAndInitialize  -----
  subroutine OpenAndInitialize ( processingRange, filedatabase )

    ! Opens L1 RAD files
    ! Opens L1OA file
    ! Gets the start and end times from the PCF
    ! Gets other user parameters from PCF
    
    ! Note: toolkitless runs bypass all that, getting
    ! the necessary inputs via the l2cf and
    ! processing user inputs during global settings section

    use Dates_Module, only: UTC_To_YYYYMMDD, PrecedesUTC, ResetStartingDate, &
      & YyyyDoy_To_Mmdd
    use Dump_1, only: Dump
    use HDF, only: Dfacc_Rdonly
    use Intrinsic, only: L_HDF
    use L1BData, only: FindMaxMaf, ReadL1BAttribute
    use L2GPData, only: Col_Species_Keys, Col_Species_Hash
    use MLSFiles, only: WildCardHDFVersion, &
      & AddFileToDatabase, InitializeMLSFile, MLS_OpenFile
    use MLSKinds, only: R8
    use MLSL2Timings, only: Section_Times
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, MLSMessage, &
      & MLSMessageConfig
    use MLSPCF2, only: MLSPCF_L1b_Oa_Start, MLSPcf_L1b_Rad_End, &
      & MLSPCF_L1b_Rad_Start, &
      & MLSPCF_L2_Param_Pgeversion, &
      & MLSPCF_L2_Param_Cycle, &
      & MLSPCF_L2_Param_Ccsdsstartid, &
      & MLSPCF_L2_Param_Ccsdsendid, &
      & MLSPCF_L2_Param_Col_Spec_Keys, &
      & MLSPCF_L2_Param_Col_Spec_Mcfnames, &
      & MLSPCF_L2_Param_Col_Spec_Doinames, &
      & MLSPCF_L2_Param_CrashMsg, &
      & MLSPCF_L2_Param_Spec_Keys, &
      & MLSPCF_L2_Param_Spec_Mcfnames, &
      & MLSPCF_L2_Param_Switches, &
      & MLSPCF_Pcf_Start
    use MLSStrings, only: Lowercase
    use Machine, only: NeverCrash
    use PCFHdr, only: GlobalAttributes, CreatePCFAnnotation, FillTAI93Attribute
    use SDPToolkit, only: Max_Orbits, Pgs_Pc_GetFilesize, Pgs_Td_Utctotai,&
      & PGS_PC_GetConfigData, Pgs_Pc_Getreference, Pgs_S_Success, &
      & Pgstd_E_No_Leap_Secs
    use Time_M, only: SayTime, Time_Now
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use WriteMetaData, only: L2PCF, MCFCaseSensitive

    ! Arguments

    type (TAI93_Range_T) :: processingRange ! Data processing range
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE

    ! Local Variables
    ! logical, parameter :: DEBUG = .FALSE.

    character(len=CCSDSlen)      :: CCSDSEndTime
    character(len=CCSDSlen)      :: CCSDSStartTime
    ! The following parameters will only be needed if PCF ids are missing
    character(len=*), parameter :: DEFAULTANTEXT= &
      & 'PCF file number missing from PCF--add this line'
    integer                      :: dd
    integer                      :: Details   ! How much info about l1b files to dump
    character(len=NameLen), dimension(NumDOIs) :: doiArray
    character(len=len(switches)) :: extra_switches
    integer :: i
    integer                      :: Ifl1
    integer                      :: Indx, Version                            
    integer                      :: l1bFlag
    type (MLSFile_T), target     :: L1BFile
    type (MLSFile_T), pointer    :: L1BPtr
    integer                      :: L1FileHandle
    integer                      :: Me = -1           ! String index for trace
    integer                      :: mm
    character (len=fileNameLen)  :: name
    integer                      :: numFiles

    integer                      :: ReturnStatus
    character(len=16)            :: RUNID
    integer                      :: Status, Size ! From allocate

    real                         :: T1                      ! for timing 
    logical                      :: TIMING                                   
    ! Executable
    integer :: OrbNum(max_orbits) = 0
    real(r8) :: OrbPeriod(max_orbits) = 0.0

    ! Executable code
    call trace_begin ( me, "OpenAndInitialize", cond=toggle(gen) )
    timing = section_times
    if ( timing ) call time_now ( t1 )

    error = 0

! Read the PCF into an annotation for file headers

    if ( .not. TOOLKIT ) then
       Status = PGS_S_SUCCESS - 1
    else
     version = 1
     Status = Pgs_pc_getFileSize(mlspcf_pcf_start, version, size)
    end if
   
    if ( Status == PGS_S_SUCCESS ) then
      call createPCFAnnotation(mlspcf_pcf_start, l2pcf%anText)
    else
      if ( TOOLKIT ) then
        call announce_error ( DEFAULTANTEXT )
        error = 1
      endif
      size = LEN(DEFAULTANTEXT) + 1
      allocate ( l2pcf%anText(size), STAT=Status )
      l2pcf%anText(1:size-1) = DEFAULTANTEXT(1:size-1)
    end if

   ! Initialize run parameters: unless reset, either by pcf or l2cf,
   ! these determine how to run
   GlobalAttributes%ProcessLevel = '2'
   CCSDSStartTime = '(undefined)'
   CCSDSEndTime = '(undefined)'
   l2pcf%startutc = '(undefined)'
   l2pcf%endutc = '(undefined)'
   l2pcf%cycle = ' '
   l2pcf%PGEVersion = ' '
   l2pcf%logGranID = '(not applicable)'      ! will not create a Log file
   l2pcf%spec_keys = '(not applicable)'      ! will not create metadata
   l2pcf%spec_mcfnames       = '(not applicable)'      ! will not create metadata
   l2pcf%spec_doinames       = &
     & '10.5067/AURA/MLS/BOGUSDATA201,' // &
     & '10.5067/AURA/MLS/BOGUSDATA202,' // &
     & '10.5067/AURA/MLS/BOGUSDATA203,' // &
     & '10.5067/AURA/MLS/BOGUSDATA204,' // &
     & '10.5067/AURA/MLS/BOGUSDATA205,' // &
     & '10.5067/AURA/MLS/BOGUSDATA206,' // &
     & '10.5067/AURA/MLS/BOGUSDATA207,' // &
     & '10.5067/AURA/MLS/BOGUSDATA208,' // &
     & '10.5067/AURA/MLS/BOGUSDATA209,' // &
     & '10.5067/AURA/MLS/BOGUSDATA210,' // &
     & '10.5067/AURA/MLS/BOGUSDATA211,' // &
     & '10.5067/AURA/MLS/BOGUSDATA212,' // &
     & '10.5067/AURA/MLS/BOGUSDATA213,' // &
     & '10.5067/AURA/MLS/BOGUSDATA214,' // &
     & '10.5067/AURA/MLS/BOGUSDATA215,' // &
     & '10.5067/AURA/MLS/BOGUSDATA216,' // &
     & '10.5067/AURA/MLS/BOGUSDATA217,' // &
     & '10.5067/AURA/MLS/BOGUSDATA218,' // &
     & '10.5067/AURA/MLS/BOGUSDATA219,' // &
     & '10.5067/AURA/MLS/BOGUSDATA220,' // &
     & '10.5067/AURA/MLS/BOGUSDATA222,' // &
     & '10.5067/AURA/MLS/BOGUSDATA223,' // &
     & '10.5067/AURA/MLS/BOGUSDATA224,' // &
     & '10.5067/AURA/MLS/BOGUSDATA225,' // &
     & '10.5067/AURA/MLS/BOGUSDATA226,' // &
     & '10.5067/AURA/MLS/BOGUSDATA227'
     
   if( .not. TOOLKIT ) then
     if ( levels(gen) > 0 .or. switchDetail(switches,'pcf') > -1 ) then
       call output('====== No parameters or radiances read :: no pcf ======', &
         & advance='yes')
       call output('======  These must be supplied through the l2cf  ======', &
         & advance='yes')
     end if
     call trace_end ( "OpenAndInitialize", cond=toggle(gen) )
     if ( timing ) call sayTime ( 'open_init', cumulative=.false. )
     return
   end if

    ifl1 = 0

    ! Open L1 RAD files
    numFiles = 0
    do L1FileHandle = mlspcf_l1b_rad_start, mlspcf_l1b_rad_end
      returnStatus = InitializeMLSFile(L1BFile, content = 'l1brad', &
        & type=l_hdf, access=DFACC_RDONLY)
      L1BFile%PCFIDRange%Top = L1FileHandle
      L1BFile%PCFIDRange%Bottom = L1FileHandle
      L1BFile%hdfVersion = WILDCARDHDFVERSION
      call mls_openFile(L1BFile, returnStatus)
      if ( returnStatus == 0 ) then
        if( switchDetail(switches, 'pro') > -1 ) then  
          call announce_success(L1BFile%name, 'l1brad', &                     
          & hdfVersion=L1BFile%HDFVersion)                    
        end if
        numFiles = addFileToDatabase(filedatabase, L1BFile)
        ifl1 = ifl1 + 1
      end if

    end do ! L1FileHandle = mlspcf_l1b_rad_start, mlspcf_l1b_rad_end

    if ( ifl1 == 0 .AND. TOOLKIT ) &
      &  call announce_error ( "Could not find any L1BRAD files" )

    ! Open L1OA File
    
    returnStatus = InitializeMLSFile(L1BFile, content = 'l1boa', &
      & type=l_hdf, access=DFACC_RDONLY)
    L1BFile%PCFIDRange%Top = mlspcf_l1b_oa_start
    L1BFile%PCFIDRange%Bottom = mlspcf_l1b_oa_start
    L1BPtr => L1BFile
    call mls_openFile(L1BFile, returnStatus)
    if ( returnStatus == PGS_S_SUCCESS ) then

        if( switchDetail(switches, 'pro') > -1 ) then  
          call announce_success(L1BFile%name, 'l1boa', &                     
          & hdfVersion=L1BFile%HDFVersion)                    
        end if
        numFiles = AddFileToDatabase(filedatabase, L1BFile)

        ! read l1boa attributes

        l1bFlag = 0
        call ReadL1BAttribute(l1bFile, OrbNum, 'OrbitNumber', &
          & l1bFlag)
        if (l1bFlag == -1) then
           GlobalAttributes%OrbNum = -1
        else
           GlobalAttributes%OrbNum = OrbNum
        end if
        call ReadL1BAttribute(l1bFile, OrbPeriod, 'OrbitPeriod', &
          & l1bFlag)
        if (l1bFlag == -1) then
           GlobalAttributes%OrbPeriod = -1.0
        else
           GlobalAttributes%OrbPeriod = OrbPeriod
        end if

    else if ( TOOLKIT ) then
      call announce_error ( "Could not find L1BOA file" )
    end if

    ! We'll possibly need the first and last MAF counter numbers, especially
    ! if gaps occur
    ! For now, just look for them in l1boa
    ! Later you may look also in l1brad files
    call startTable
    call addRow_header ( 'Open_Init Settings', 'c' )
    call addRow_divider ( '-' )
    if ( error == 0 ) then
      GlobalAttributes%LastMAFCtr = FindMaxMAF ( L1BPtr, &
        & GlobalAttributes%FirstMAFCtr )
      ! call outputNamedValue ( 'Last MAF', GlobalAttributes%LastMAFCtr )
      ! call outputNamedValue ( 'First MAF', GlobalAttributes%FirstMAFCtr )
      call addRow ( 'Last MAF', GlobalAttributes%LastMAFCtr )
      call addRow ( 'First MAF', GlobalAttributes%FirstMAFCtr )
    endif
    ! Get the Start and End Times from PCF

    returnStatus = PGS_PC_GetConfigData( mlspcf_l2_param_CCSDSStartId, &
                                           CCSDSStartTime )
    if ( returnstatus /= PGS_S_SUCCESS .and. TOOLKIT ) then
      call announce_error ( "Missing pcf param: CCSDSStartTime" )
    end if

    returnStatus = pgs_td_utctotai ( CCSDSStartTime, processingrange%starttime )
    !   ??? Is PGSTD_E_NO_LEAP_SECS an OK status ???
    if ( returnstatus /= PGS_S_SUCCESS .and. &
      &  returnstatus /= PGSTD_E_NO_LEAP_SECS ) &
      & call announce_error ( "Could not convert UTC Start time to TAI" )
    if ( returnstatus == PGSTD_E_NO_LEAP_SECS ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'No leap second information' )

   ! Is CCSDSStartTime before tai93 onset?
   ! call outputNamedValue ( 'CCSDSStartTime', CCSDSStartTime )
   if ( precedesUTC ( CCSDSStartTime, '1993-01-01' ) ) then
     call outputNamedValue ( 'StartTime precedes tai93 onset', CCSDSStartTime )
     if ( .false. ) call ResetStartingDate( '1961-01-01' )
   endif
   returnStatus = PGS_PC_GetConfigData( mlspcf_l2_param_CCSDSEndId, &
                                          CCSDSEndTime )
    if ( returnstatus /= PGS_S_SUCCESS .and. TOOLKIT ) then
      call announce_error ( "Missing pcf param: CCSDSEndTime" )
    end if

    returnStatus = pgs_td_utctotai ( CCSDSEndTime, processingrange%endtime )
    ! call outputNamedValue ( 'CCSDSEndTime', CCSDSEndTime )
    !   ??? Is PGSTD_E_NO_LEAP_SECS an OK status ???
    if ( returnstatus /= PGS_S_SUCCESS .and. &
      & returnstatus /= PGSTD_E_NO_LEAP_SECS) &
        & call announce_error ( "Could not convert UTC End time to TAI" )

    call addRow ( 'CCSDSStartTime', CCSDSStartTime )
    call addRow ( 'CCSDSEndTime', CCSDSEndTime )
    call outputTable ( sep='|', border='-' )
    l2pcf%startutc = CCSDSStartTime
    l2pcf%endutc = CCSDSEndTime

    ! Here's where we define the non-time components of l2pcf

    returnStatus = PGS_PC_GetConfigData(mlspcf_l2_param_PGEVersion, &
                                          l2pcf%PGEVersion)
    if ( returnstatus /= PGS_S_SUCCESS ) then
      call announce_error ( "Missing pcf param: output version" )
    end if

    returnStatus = PGS_PC_GetConfigData(mlspcf_l2_param_Cycle, RunID ) ! l2pcf%cycle)
    if ( len_trim(RunID) < 5 ) then
      l2pcf%cycle = RunID
    else
      l2pcf%cycle = 'c01'
      l2pcf%RunID = RunID
    endif

    if ( returnstatus /= PGS_S_SUCCESS ) then
      call announce_error ( "Missing pcf param: cycle" )
    end if

    returnStatus = PGS_PC_GetConfigData(mlspcf_l2_param_col_spec_keys, col_species_keys)

    if ( returnstatus /= PGS_S_SUCCESS ) then
      call announce_error ( "Missing pcf param: col_spec_keys", &
        & forgiveable=.true. )
    end if

    returnStatus = PGS_PC_GetConfigData(mlspcf_l2_param_col_spec_mcfnames      , col_species_hash)

    if ( returnstatus /= PGS_S_SUCCESS ) then
      call announce_error ( "Missing pcf param: col_spec_mcfnames      ", &
        & forgiveable=.true. )
    end if

    returnStatus = PGS_PC_GetConfigData(mlspcf_l2_param_spec_keys, l2pcf%spec_keys)

    if ( returnstatus /= PGS_S_SUCCESS ) then
      call announce_error ( "Missing pcf param: spec_keys" )
    end if

    returnStatus = PGS_PC_GetConfigData(mlspcf_l2_param_spec_mcfnames      , l2pcf%spec_mcfnames      )

    if ( returnstatus /= PGS_S_SUCCESS ) then
      call announce_error ( "Missing pcf param: spec_mcfnames      " )
    end if

    if ( .NOT. MCFCASESENSITIVE ) then
      l2pcf%spec_mcfnames       = LowerCase(l2pcf%spec_mcfnames      )
      l2pcf%spec_keys = LowerCase(l2pcf%spec_keys)
    end if

   ! If using PCF, it will be difficult to set switches from command-line
   ! so the following allows us to do so inside the PCF
   ! This way we can still dump vectors, monitor iterations or activities
   ! But don't do this if you already set them on the command line
    if ( ALWAYSGETSWITCHESCONFIG .or. switches == ' ' ) then
      returnStatus = PGS_PC_GetConfigData(mlspcf_l2_param_switches, &
        & extra_switches)
      if ( returnstatus == PGS_S_SUCCESS .and. extra_switches /= ' ' ) &
        & switches = catLists(trim(switches), trim(extra_switches))
    end if

    returnStatus = PGS_PC_GetConfigData( mlspcf_l2_param_CrashMsg, &
      & extra_switches )
    if ( returnstatus == PGS_S_SUCCESS ) then
      if ( len_trim(extra_switches) > 0 ) then
        NeverCrash = .false.
        MLSMessageConfig%CrashIfMsgSays = extra_switches
      endif
    endif

    ! This hackery-quackery uses the PCF to
    ! input elements of a string array without using up
    ! a bunch of PCFids
    ! So we accept that the strings are file names
    ! and use Pgs_pc_getReference with the version mechanism
    do i=1, NumDOIs
      version = i
      returnStatus = Pgs_pc_getReference( mlspcf_l2_param_col_spec_doinames, &
        & version, doiArray(NumDOIs-i+1) )
      ! call outputnamedValue( 'returnStatus', returnStatus )
      if ( returnStatus /= PGS_S_SUCCESS ) exit
    enddo
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'Could not find DOIs in PCF file' )
    else
      call Array2List ( doiArray, l2pcf%spec_doinames )
      if ( levels(gen) > 0 .or. BeVerbose('pcf', -1) ) then
        call dump( doiArray, 'doiArray' )
        call dump( l2pcf%spec_doinames, 'doi list' )
      endif
    endif

! Get the name of the log file from the PCF

    version = 1

    returnStatus = Pgs_pc_getReference(MLSPCF_LOG, version, name)
    if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( "Error retrieving log file name from PCF" )
    elseif ( returnStatus == PGS_S_SUCCESS) then
      indx = INDEX(name, '/', .TRUE.)
      l2pcf%logGranID = name(indx+1:)
    else
      l2pcf%logGranID = '(not found)'
    end if
 
    ! Store appropriate user input as global attributes
    GlobalAttributes%StartUTC = l2pcf%StartUTC
    GlobalAttributes%EndUTC = l2pcf%EndUTC
    if ( len_trim(GlobalAttributes%PGEVersion) < 1 ) &
      & GlobalAttributes%PGEVersion = l2pcf%PGEVersion
    call utc_to_yyyymmdd( GlobalAttributes%StartUTC, returnStatus, &
      & GlobalAttributes%GranuleYear, GlobalAttributes%GranuleMonth, &
      & GlobalAttributes%GranuleDay ) 
    ! If mm < 0, then it's yyyy-Doy format, so let's find the actual
    ! month and store it as a negative integer in GranuleMonth
    if ( GlobalAttributes%GranuleMonth == -1 ) then
      call yyyyDoy_to_mmdd( GlobalAttributes%GranuleYear, &
        & mm, dd, GlobalAttributes%GranuleDay )
      GlobalAttributes%GranuleMonth = -mm
    endif
    call FillTAI93Attribute
    
    ! Get name of Parallel Staging file (not any more)
    call MLSL2Message ( MLSMSG_Warning, ModuleName, &
      & 'This version does not use staging file for slave Join commands' )
    ! version = 1

    if ( error /= 0 ) &
      & call MLSL2Message( MLSMSG_Error, ModuleName, &
        & 'Problem with open_init section' )

   Details = switchDetail(switches, 'pcf') - 2 ! -3 means don't dump
   if ( levels(gen) > 0 .or. details > -3 .or. BeVerbose('pcf', -1) ) &
      & call Dump_open_init ( filedatabase, &
          & CCSDSEndTime, CCSDSStartTime, processingrange, details )
   if ( timing ) call sayTime ( 'open_init', cumulative=.false. )
   call trace_end ( "OpenAndInitialize", cond=toggle(gen) )

  end subroutine OpenAndInitialize

! =====     Private Procedures     =====================================

  ! ---------------------------------------------  announce_success  -----
  subroutine announce_success ( FullName, l1_type, hdfVersion )
    use MLSFiles, only: MLS_HDF_Version, Split_Path_Name, WildCardHDFVersion
    character(len=*), intent(in)   :: FullName
    character(len=*), intent(in)   :: l1_type
    integer, optional,  intent(in) :: hdfVersion

    ! Local variables
    integer                        :: myhdfVersion
    character(len=len(FullName))   :: name, path
    integer, save                  :: trip = 0
    ! Executable
    trip = trip + 1
    call split_path_name ( FullName, path, name )
    if ( trip < 2 ) call StyledOutput ( 'Level 1 products', options='--Banner' )
    call StartTable
    call addRow ( 'type', trim(l1_type) )
    if ( present(hdfVersion) ) then
      if ( hdfVersion == WildCardHDFVersion ) then
        myhdfVersion = mls_hdf_version(trim(Name))
      else
        myhdfVersion = hdfVersion
      end if
      call addRow ( 'hdf version', myhdfVersion )
    end if
    call addRow ( 'path', trim(path) )
    call addRow ( 'name', trim(name) )
    Call OutputTable ( sep='|', border='-' )
  end subroutine announce_success

  ! ------------------------------------------  Dump_open_init  -----
  subroutine Dump_open_init ( filedatabase, &
    & CCSDSEndTime, CCSDSStartTime, processingrange, Details )
  
    ! Dump info obtained during OpenAndInitialize:
    ! L1B databse
    ! L1OA file
    ! Start and end times
    ! output version
    ! cycle number
    ! logfile name
  
    use Dump_1, only: Dump
    use L2GPData, only: Col_Species_Keys, Col_Species_Hash
    use WriteMetaData, only: L2PCF

    ! Arguments
    type (MLSFile_T), dimension(:), pointer :: FILEDATABASE
    character(len=CCSDSlen)                 :: CCSDSEndTime
    character(len=CCSDSlen)                 :: CCSDSStartTime
    type (TAI93_Range_T)                    :: processingRange ! Data processing range
    integer, intent(in)                     :: Details

    ! Local
    character (len=*), parameter            :: time_format='(1pD18.12)'

    ! Begin                                                                       
    call output ( '============ Open Initialize ============', advance='yes' )
    call output ( '        (Data entered via pcf)', advance='yes' )
    call output ( ' ', advance='yes' )
    call output ( 'L1B database:', advance='yes' )
    call DumpL1BDatabase ( filedatabase, Details )

    call startTable
    call addRow_header ( 'Run Info', 'c' )
    call addRow_divider ( '-' )
    call addRow ( 'Start Time', CCSDSStartTime )
    call addRow ( 'End Time', CCSDSEndTime )

    call addRow ( 'Start Time (tai)', processingrange%starttime, format=time_format )
    call addRow ( 'End Time (tai)', processingrange%endtime, format=time_format )
    call addRow ( 'Processing Range', processingrange%endtime-processingrange%starttime )
    call addRow ( 'PGE version', l2pcf%PGEVersion )
    call addRow ( 'cycle', l2pcf%cycle )
    call addRow ( 'RunID', l2pcf%RunID )
    call addRow ( 'Log file name', l2pcf%logGranID )
    call outputTable ( sep=' ', border='-' )

    ! Dump special hashes
    call NewLine
    call Dump ( countEmpty=.true., &
      & keys=col_species_keys, values=col_species_hash, &
      & name='l2gp column species, units', separator=',' )

    call NewLine
    call Dump ( countEmpty=.true., &
      & keys=l2pcf%spec_keys, values=l2pcf%spec_mcfnames, &
      & name='l2gp species, mcf : doi', separator=',', &
      & ExtraValues= l2pcf%spec_doinames)
    call blanks ( 80, FillChar='-', advance='yes' )

  end subroutine Dump_open_init

  ! ---------------------------------------------  DumpL1BDatabase  -----
  subroutine DumpL1BDatabase ( filedatabase, Details )
    use L1BData, only: L1BData_t, NameLen, PrecisionSuffix, &
      & AssembleL1BQtyName, DeallocateL1BData, Dump, &
      & ReadL1BData 
    ! Arguments
    type (MLSFile_T), dimension(:), pointer :: FILEDATABASE
    integer, intent(in)                     :: Details
    ! Local variables
    integer                                 :: hdfVersion
    integer                                 :: i
    integer                                 :: ierr
    character(len=namelen)                  :: L1bItemName
    integer                                 :: noMAFs
    type(MLSFile_T), pointer                :: L1BFile
    type (L1BData_T)                        :: l1bDataSet   ! L1B dataset
    ! This next is in case we're to dump at greatest possible detail
    character (len=namelen), parameter ::  BASE_QUANT_NAME = &
                                    &       'R2:190.B3F:N2O.S2.FB25-3'
!                                    &       'R1A:118.B1F:PT.S0.FB25-1'
    character (len=LEN(BASE_QUANT_NAME)) :: l1b_quant_name
    logical, parameter ::                   DUMPPRECISIONTOO = .true.
    ! Executable
    if(associated(filedatabase)) then
      call startTable
      call addRow_header ( 'Run Info', 'c' )
      call addRow_divider ( '-' )
      if ( specialDumpFile /= ' ' .and. Details > -2 ) &
        & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
    else
      call output ( '(null database)', advance='yes' )
      return
    end if
    do i = 1, size(filedatabase)
      L1BFile => filedatabase(i)
      hdfVersion = L1BFile%HDFVersion
      if ( L1BFile%content == 'l1brad' ) then
        call addRow ( 'L1B type ', 'radiance' )
      elseif ( L1BFile%content == 'l1boa' ) then
        call addRow ( 'L1B type ', 'orbit/attitude' )
      else
        cycle
      endif
      call addRow ( 'PCF id', L1BFile%PCFID )
      call addRow ( 'fileid', L1BFile%FileID%f_id )
      call addRow ( 'name', L1BFile%name )
      if ( details > -2 .and. L1BFile%content == 'l1brad' ) then
        l1b_quant_name = BASE_QUANT_NAME
        l1bItemName = AssembleL1BQtyName ( l1b_quant_name, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bDataSet, &
         & NoMAFs, IERR, NeverFail=.true. )
        if ( IERR == 0 ) then
          call Dump( l1bDataSet, details )
          call DeallocateL1BData ( l1bDataSet )
        else
          call output ( 'Error number  ' )
          call output ( IERR )
          call output ( ' while reading quantity named  ' )
          call output ( trim(l1b_quant_name), advance='yes' )
        end if
        if ( .not. DUMPPRECISIONTOO ) cycle
        l1b_quant_name = trim(BASE_QUANT_NAME) // PRECISIONSUFFIX
        l1bItemName = AssembleL1BQtyName ( l1b_quant_name, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bDataSet, &
         & NoMAFs, IERR, NeverFail=.true. )
        if ( IERR == 0 ) then
          call Dump( l1bDataSet, details )
          call DeallocateL1BData ( l1bDataSet )
        else
          call output ( 'Error number  ' )
          call output ( IERR )
          call output ( ' while reading quantity named  ' )
          call output ( trim(l1b_quant_name), advance='yes' )
        end if
      endif
    enddo
    call outputTable ( sep=' ', border='-' )

    if ( specialDumpFile /= ' ' .and. Details > -2 ) &
      & call revertOutput
  end subroutine DumpL1BDatabase

  ! ---------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( Full_message, Use_toolkit, &
    & Error_number, forgiveable )
    ! Arguments

    ! integer, intent(in) :: Lcf_where
    character(LEN=*), intent(in) :: Full_message
    logical, intent(in), optional :: Use_toolkit
    integer, intent(in), optional :: Error_number
    logical, intent(in), optional :: forgiveable

    ! Local
    logical :: Just_print_it
    logical, parameter :: Default_output_by_toolkit = .true.

    just_print_it = .not. default_output_by_toolkit
    if ( present(use_toolkit) ) just_print_it = .not. use_toolkit
    if ( present(forgiveable) ) just_print_it = just_print_it .or. forgiveable

    if ( .not. just_print_it ) then
      error = max(error,1)
      call output ( " The following error occurred:", advance='yes', &
       & from_where=ModuleName )
      call StyledOutput ( trim(full_message), options='--Headline' )
      if ( present(error_number) ) then
        call output ( 'Error number ', advance='no' )
        call output ( error_number, places=9, advance='yes' )
      end if
    else
      call output ( '*** ' )
      if ( present(forgiveable) ) then
        call output ( 'Warning in module' )
      else
        call output ( 'Error in module ' )
      endif
      call output ( ModuleName, advance='yes' )
      call StyledOutput ( trim(full_message), options='--Headline' )
      if ( present(error_number) ) then
        call output ( 'Error number ' )
        call output ( error_number, advance='yes' )
      end if
    end if

!===========================
  end subroutine Announce_Error
!===========================

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: open_init.f90,v 2.121 2021/09/01 16:59:40 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Open_Init

!=============================================================================

!
! $Log: open_init.f90,v $
! Revision 2.121  2021/09/01 16:59:40  pwagner
! Report absence of l1b files more gracefully
!
! Revision 2.120  2021/07/22 23:16:01  pwagner
! Use MLSL2Message to print error mesgs
!
! Revision 2.119  2019/04/18 16:29:53  pwagner
! Overwrite GlobalAttributes%PGEVersion only if currently blank
!
! Revision 2.118  2018/11/01 23:16:25  pwagner
! Improve appearance of settings when dumped
!
! Revision 2.117  2017/11/15 00:15:49  pwagner
! Use OutputTable to Dump list of level 1 files
!
! Revision 2.116  2017/07/27 16:41:51  pwagner
! If yyyy-Doy, store actual actual month number as neg int. in GlobalAttributes%GranuleMonth
!
! Revision 2.115  2017/07/10 18:55:35  pwagner
! Warn if starting date precedes start of tai93
!
! Revision 2.114  2017/03/24 22:58:18  pwagner
! Made new PCFid 2008 that tells level 2 to crash with walkback if special msg logged
!
! Revision 2.113  2017/01/19 23:56:44  pwagner
! Improve appeearance when dumping Run Info
!
! Revision 2.112  2016/11/08 17:31:47  pwagner
! Use SayTime subroutine from time_m module
!
! Revision 2.111  2016/09/22 22:57:25  pwagner
! Added DumpL1BDatabase; improved appearance of Dump_open_init
!
! Revision 2.110  2016/08/09 21:21:13  pwagner
! Survives encounter with non-satellite data
!
! Revision 2.109  2016/07/28 01:45:07  vsnyder
! Refactor dump and diff
!
! Revision 2.108  2014/09/05 01:26:25  vsnyder
! Remove unused parameter; comment out unused USE name
!
! Revision 2.107  2014/03/26 17:46:25  pwagner
! Added ProductionLocation, identifier_product_DOI to attributes
!
! Revision 2.106  2014/03/07 19:24:48  pwagner
! Name_Len changed to nameLen; got from MLSCommon
!
! Revision 2.105  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.104  2013/12/05 01:43:48  pwagner
! Read RunID component from cycle field of pcf; started using BeVerbose
!
! Revision 2.103  2013/08/30 02:45:50  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.102  2013/08/17 02:55:23  vsnyder
! Regularized trace usage
!
! Revision 2.101  2012/08/16 17:49:40  pwagner
! Simplify; remove unused stuff
!
! Revision 2.100  2012/04/05 20:14:39  pwagner
! Erased all traces of parallel staging file
!
! Revision 2.99  2012/03/28 20:09:38  pwagner
! Issue warning--slave tasks lost ability to join quantities
!
! Revision 2.98  2011/06/29 21:49:43  pwagner
! Some cases may safely omit l1b files
!
! Revision 2.97  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.96  2007/10/04 20:43:12  vsnyder
! Remove unused symbols
!
! Revision 2.95  2007/06/21 00:54:08  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.94  2006/09/21 18:50:33  pwagner
! Uncertain why or whether this was necessary but did it anyway
!
! Revision 2.93  2006/07/07 23:11:19  pwagner
! Removed already-commented-out souvenirs
!
! Revision 2.92  2006/03/15 23:52:24  pwagner
! Removed InputVersion component from PCF, l2cf
!
! Revision 2.91  2006/02/16 00:16:01  pwagner
! switchDetail instead of index
!
! Revision 2.90  2006/02/10 21:16:20  pwagner
! dumps may go to special dumpfile
!
! Revision 2.89  2006/01/27 01:03:29  pwagner
! Changed wording when merely a warning
!
! Revision 2.88  2006/01/19 00:31:54  pwagner
! reads col_spec_keys and _hash from PCF
!
! Revision 2.87  2005/09/22 23:38:12  pwagner
! date conversion procedures and functions all moved into dates module
!
! Revision 2.86  2005/07/21 23:45:21  pwagner
! Removed unused l1b fileinfo fields from l2pcf
!
! Revision 2.85  2005/07/12 17:17:46  pwagner
! Dropped global attribute InputVersion
!
! Revision 2.84  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.83  2005/06/14 20:39:25  pwagner
! Many changes to accommodate the new fields in MLSFile_T
!
! Revision 2.82  2005/05/31 17:51:17  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.81  2004/12/28 00:23:03  vsnyder
! Remove unreferenced use names
!
! Revision 2.80  2004/12/15 23:35:59  pwagner
! Should not warn about missing switches setting in PCF
!
! Revision 2.79  2004/08/16 17:14:42  pwagner
! Obtains First,LastMAFCtr global attributes from l1boa file
!
! Revision 2.78  2004/08/04 23:19:58  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.77  2004/06/29 00:10:17  pwagner
! Exploit catlist function
!
! Revision 2.76  2003/10/29 00:07:17  pwagner
! GlobalAttributes%ProcessLevel assigned appropriate value
!
! Revision 2.75  2003/10/09 23:41:06  pwagner
! Ignore illegal PCFids; extra_switches ,-separated
!
! Revision 2.74  2003/09/12 16:28:56  cvuu
! Read OrbitNumber and OrbitPeriod attributes from L1BOA
!
! Revision 2.73  2003/07/07 23:50:05  pwagner
! Now uses saved variable L2pcf from writeMetaData
!
! Revision 2.72  2003/06/09 22:49:34  pwagner
! Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
!
! Revision 2.71  2003/05/29 17:55:23  pwagner
! Can get name of parallel%stagingFile from PCF
!
! Revision 2.70  2003/02/27 21:55:14  pwagner
! Calls FillTAI93Attribute
!
! Revision 2.69  2003/02/01 00:38:33  pwagner
! Defines Global Attributes from user data
!
! Revision 2.68  2002/12/11 22:18:48  pwagner
! broadened error check on sd_id to any value lt 1
!
! Revision 2.67  2002/11/13 01:10:40  pwagner
! Actually reads hdf5 radiances
!
! Revision 2.66  2002/10/08 17:36:22  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.65  2002/10/03 23:02:48  pwagner
! Now opens l1b files with mls_io_gen_openF
!
! Revision 2.64  2002/09/27 23:47:23  pwagner
! Now calls mls_io_gen_closeF rather than mls_sfend
!
! Revision 2.63  2002/08/28 22:28:37  pwagner
! Saves PCFids for l1boa, l1brad for input pointer metadata
!
! Revision 2.62  2002/08/21 02:23:39  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.61  2002/01/26 00:09:14  pwagner
! Convert hdf routines to mlsfiles equivalents
!
! Revision 2.60  2002/01/24 00:14:26  pwagner
! Proclaims level 1 files as input; comments concerning hdf5 conversion
!
! Revision 2.59  2001/12/16 00:57:46  livesey
! Add warning about leap seconds
!
! Revision 2.58  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.57  2001/11/01 21:06:17  pwagner
! Fixed if block; added toc
!
! Revision 2.56  2001/10/30 00:33:24  pwagner
! Renamed Dump_L1B_database Dump_open_init; switches now checked for pcf[n]
!
! Revision 2.55  2001/10/25 23:33:59  pwagner
! Initializes InputVersion, PGEVersion to blank
!
! Revision 2.54  2001/09/28 23:59:20  pwagner
! Fixed various timing problems
!
! Revision 2.53  2001/08/09 00:23:05  pwagner
! pcf param for extra switches added; read
!
! Revision 2.52  2001/05/24 20:34:50  pwagner
! More forgiving of faulty pcf
!
! Revision 2.51  2001/05/17 22:31:54  pwagner
! Simpler info instead of bogus dump if no pcf
!
! Revision 2.50  2001/05/17 00:27:55  pwagner
! Better defaults, dumps
!
! Revision 2.49  2001/05/11 23:43:35  pwagner
! Added some initializations
!
! Revision 2.48  2001/05/10 18:22:57  pwagner
! Improved Dump_L1B_database
!
! Revision 2.47  2001/05/09 23:32:15  pwagner
! Gets toolkit funs from SDPToolkit
!
! Revision 2.46  2001/05/07 23:28:19  pwagner
! Fixed dump..
!
! Revision 2.45  2001/05/06 20:55:25  pwagner
! [De]Allocates l1binfo%filenames along with ids
!
! Revision 2.44  2001/05/04 22:56:40  pwagner
! Detachable from Toolkit
!
! Revision 2.43  2001/05/04 17:09:03  pwagner
! Get MAXNUML1BRADIDS, ILLEGALL1BRADID from global_settings
!
! Revision 2.42  2001/04/20 18:16:29  pwagner
! Added sfend on L1B files to DESTROYL1BInfo
!
! Revision 2.41  2001/04/19 23:51:40  pwagner
! Moved anText to become component of PCFData_T
!
! Revision 2.40  2001/04/18 17:33:29  vsnyder
! I forgot what I REALLY did, but I also made numerous cosmetic changes
!
! Revision 2.39  2001/04/16 23:45:59  pwagner
! Gets penalty settings from MLSL2Options
!
! Revision 2.38  2001/04/16 17:45:54  pwagner
! Makes l2pcf hash, keys lowercase if not MCFCASESENSITIVE
!
! Revision 2.37  2001/04/12 00:20:44  pwagner
! With new PCF params
!
! Revision 2.32  2001/04/10 23:00:29  pwagner
! Keeps track of whether to quit if no metadata
!
! Revision 2.31  2001/04/06 20:20:43  vsnyder
! Improve an error message
!
! Revision 2.30  2001/04/06 18:01:00  pwagner
! Checks on pcf number before PCFCreateAnnotation
!
! Revision 2.29  2001/04/05 23:44:53  pwagner
! Fixed tiny error
!
! Revision 2.28  2001/04/05 23:40:50  pwagner
! Deleted open_mlscf and close_mlscf and all MLSMessages
!
! Revision 2.27  2001/04/04 23:46:18  pwagner
! Added trace_*, dump_l1b_database
!
! Revision 2.26  2001/04/03 20:51:27  pwagner
! Added anText; deleted read_apriori
!
! Revision 2.25  2001/04/02 23:39:09  pwagner
! Now fills components of l2pcf
!
! Revision 2.24  2001/03/28 19:07:59  vsnyder
! Finish removing use of MLSSignalNomenclature
!
! Revision 2.23  2001/03/28 19:07:08  vsnyder
! Remove use of MLSSignalNomenclature
!
! Revision 2.22  2001/03/15 21:18:57  vsnyder
! Use Get_Spec_ID instead of decoration(subtree...
!
! Revision 2.21  2001/03/10 07:07:58  livesey
! Made it not mind if no L1B radiance files.
!
! Revision 2.20  2001/03/07 22:49:17  vsnyder
! Commented-out more USEd entities that NAG says actually aren't used.
!
! Revision 2.19  2001/03/03 00:08:58  pwagner
! Lost read_apriori and read_mlscf to new modules
!
! Revision 2.18  2001/02/27 01:30:46  vsnyder
! Commented-out several USEd entities that NAG says actually aren't used.
!
! Revision 2.17  2001/02/23 18:17:35  livesey
! Added trace calls
!
! Revision 2.16  2001/02/23 00:53:07  vsnyder
! Correct an error message
!
! Revision 2.15  2001/02/16 00:48:07  livesey
! Added stuff to read l2gp's in
!
! Revision 2.14  2001/02/13 22:59:36  pwagner
! l2 modules can only use MLSPCF2
!
! Revision 2.13  2001/02/09 00:38:22  livesey
! Various updates
!
! Revision 2.12  2001/02/08 00:58:14  vsnyder
! Correct calculation of "field"
!
! Revision 2.11  2001/01/03 00:47:21  pwagner
! Calls READL2AUXData from L2AUXData module
!
! Revision 2.10  2000/12/04 21:47:46  pwagner
! Uses parser better
!
! Revision 2.9  2000/12/02 01:11:59  pwagner
! Added ReadL2AUXData
!
! Revision 2.8  2000/12/02 00:00:40  vsnyder
! More misc. cleanup.
!
! Revision 2.7  2000/12/01 23:35:25  vsnyder
! Use abstract syntax tree more efficiently, general clean-up -- alphabetization
! etc.
!
! Revision 2.6  2000/11/30 00:23:58  pwagner
! functions properly moved here from Fill
!
! Revision 2.5  2000/11/29 17:35:30  pwagner
! Compiles now
!
! Revision 2.4  2000/11/29 00:27:54  pwagner
! Began changes to open old l2gp
!
! Revision 2.3  2000/11/16 01:02:16  vsnyder
! Correct an error message.
!
! Revision 2.2  2000/09/11 19:48:01  ahanzel
! Removed old log entries in file.
!
! Revision 2.1  2000/09/08 22:55:56  vsnyder
! Revised to use the tree output by the parser
!

@


2.121
log
@Report absence of l1b files more gracefully
@
text
@d64 6
a69 2
  
  integer, parameter :: mlspcf_l2_param_CrashMsg = 2008
d109 1
d118 1
a118 1
      & Pgs_Pc_GetconfigData, Pgs_Pc_Getreference, Pgs_S_Success, &
d149 1
a149 1
    integer :: Me = -1           ! String index for trace
d324 1
a324 1
    returnStatus = pgs_pc_getConfigData( mlspcf_l2_param_CCSDSStartId, &
d345 1
a345 1
   returnStatus = pgs_pc_getConfigData( mlspcf_l2_param_CCSDSEndId, &
d366 1
a366 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_PGEVersion, &
d372 1
a372 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_Cycle, RunID ) ! l2pcf%cycle)
d384 1
a384 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_col_spec_keys, col_species_keys)
d391 1
a391 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_col_spec_mcfnames      , col_species_hash)
d398 1
a398 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_spec_keys, l2pcf%spec_keys)
d404 1
a404 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_spec_mcfnames      , l2pcf%spec_mcfnames      )
d420 1
a420 1
      returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_switches, &
d426 1
a426 1
    returnStatus = pgs_pc_getConfigData( mlspcf_l2_param_CrashMsg, &
d477 1
a477 1
    call utc_to_yyyymmdd(GlobalAttributes%StartUTC, returnStatus, &
d479 1
a479 1
      & GlobalAttributes%GranuleDay) 
d495 2
a496 2
      & call MLSL2Message(MLSMSG_Error,ModuleName, &
        & 'Problem with open_init section')
d734 1
a734 1
       "$Id: open_init.f90,v 2.120 2021/07/22 23:16:01 pwagner Exp $"
d747 3
@


2.120
log
@Use MLSL2Message to print error mesgs
@
text
@d309 8
a316 6
    GlobalAttributes%LastMAFCtr = FindMaxMAF ( L1BPtr, &
      & GlobalAttributes%FirstMAFCtr )
    ! call outputNamedValue ( 'Last MAF', GlobalAttributes%LastMAFCtr )
    ! call outputNamedValue ( 'First MAF', GlobalAttributes%FirstMAFCtr )
    call addRow ( 'Last MAF', GlobalAttributes%LastMAFCtr )
    call addRow ( 'First MAF', GlobalAttributes%FirstMAFCtr )
d701 2
a702 3
       & from_where=ModuleName)
      call output ( trim(full_message), advance='yes', &
        & from_where=ModuleName)
d715 1
a715 1
      call output ( trim(full_message), advance='yes' )
d729 1
a729 1
       "$Id: open_init.f90,v 2.119 2019/04/18 16:29:53 pwagner Exp $"
d742 3
@


2.119
log
@Overwrite GlobalAttributes%PGEVersion only if currently blank
@
text
@d25 1
a25 1
  use MLSL2Options, only: SpecialDumpFile, Toolkit
d231 1
a231 1
       call output('====  (These must be supplied through the l2cf) ======', &
d329 1
a329 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d441 1
a441 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d483 1
a483 1
    call MLSMessage ( MLSMSG_Warning, ModuleName, &
d488 1
a488 1
      & call MLSMessage(MLSMSG_Error,ModuleName, &
d728 1
a728 1
       "$Id: open_init.f90,v 2.118 2018/11/01 23:16:25 pwagner Exp $"
d741 3
@


2.118
log
@Improve appearance of settings when dumped
@
text
@d468 2
a469 1
    GlobalAttributes%PGEVersion = l2pcf%PGEVersion
d728 1
a728 1
       "$Id: open_init.f90,v 2.117 2017/11/15 00:15:49 pwagner Exp $"
d741 3
@


2.117
log
@Use OutputTable to Dump list of level 1 files
@
text
@d306 3
d311 4
a314 2
    call outputNamedValue ( 'Last MAF', GlobalAttributes%LastMAFCtr )
    call outputNamedValue ( 'First MAF', GlobalAttributes%FirstMAFCtr )
d333 1
a333 1
   call outputNamedValue ( 'CCSDSStartTime', CCSDSStartTime )
d345 1
a345 1
    call outputNamedValue ( 'CCSDSEndTime', CCSDSEndTime )
d351 3
d727 1
a727 1
       "$Id: open_init.f90,v 2.116 2017/07/27 16:41:51 pwagner Exp $"
d740 3
@


2.116
log
@If yyyy-Doy, store actual actual month number as neg int. in GlobalAttributes%GranuleMonth
@
text
@d23 1
a23 1
    & OutputNamedValue, OutputTable, StartTable
d93 1
a93 1
    use MLSL2Timings, only: Section_Times, Total_Times
d153 1
a153 1
    real                         :: T1, T2                      ! for timing 
d251 4
d494 4
a497 3
  subroutine announce_success ( Name, l1_type, hdfVersion )
    character(LEN=*), intent(in)   :: Name
    character(LEN=*), intent(in)   :: l1_type
d500 10
a509 2
    call output ( 'Level 1 product type : ' )
    call output ( trim(l1_type), advance='no')
d511 6
a516 5
      call blanks(4)
      call output ( 'hdf ' )
      call output ( hdfVersion, advance='yes')
    else
      call output ( ' ', advance='yes')
d518 3
a520 4
    call blanks(15)
    call output ( 'name : ' )
    call blanks(8)
    call output ( trim(Name), advance='yes')
d719 1
a719 1
       "$Id: open_init.f90,v 2.115 2017/07/10 18:55:35 pwagner Exp $"
d732 3
@


2.115
log
@Warn if starting date precedes start of tai93
@
text
@d83 2
a84 1
    use Dates_Module, only: UTC_To_YYYYMMDD, PrecedesUTC, resetStartingDate
d133 1
a133 1

d145 1
d460 7
d706 1
a706 1
       "$Id: open_init.f90,v 2.114 2017/03/24 22:58:18 pwagner Exp $"
d719 3
@


2.114
log
@Made new PCFid 2008 that tells level 2 to crash with walkback if special msg logged
@
text
@d83 1
a83 1
    use Dates_Module, only: UTC_To_YYYYMMDD
d306 2
a307 2
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_CCSDSStartId, &
                                           CCSDSStartTime)
d312 1
a312 1
    returnStatus = pgs_td_utctotai (CCSDSStartTime, processingrange%starttime)
d316 1
a316 1
        & call announce_error ( "Could not convert UTC Start time to TAI" )
d318 2
a319 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'No leap second information' )
d321 8
a328 2
   returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_CCSDSEndId, &
                                          CCSDSEndTime)
d333 2
a334 1
    returnStatus = pgs_td_utctotai (CCSDSEndTime, processingrange%endtime)
d697 1
a697 1
       "$Id: open_init.f90,v 2.113 2017/01/19 23:56:44 pwagner Exp $"
d710 3
@


2.113
log
@Improve appeearance when dumping Run Info
@
text
@d22 1
a22 1
  use HighOutput, only: AddRow, AddRow_divider, AddRow_header, BeVerbose, &
d24 1
a24 1
  use MLSCommon, only: FileNameLen, MLSFile_t, NameLen, TAI93_Range_t
d27 2
a28 2
    & switchDetail
  use Output_m, only: Blanks, NewLine, Output, SwitchOutput, RevertOutput
d56 12
d85 2
a86 2
    use HDF, only: dfacc_rdonly
    use intrinsic, only: L_HDF
d88 2
a89 2
    use L2GPData, only: col_species_keys, col_species_hash
    use MLSFiles, only: wildCardHDFVersion, &
d91 19
a109 17
    use MLSKinds, only: r8
    use MLSL2Timings, only: section_times, total_times
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, MLSMessage
    use MLSPCF2, only: MLSPCF_L1b_oa_start, mlspcf_l1b_rad_end, &
      &                MLSPCF_L1b_rad_start, &
      &                MLSPCF_L2_param_pgeversion, &
      &                MLSPCF_L2_param_cycle, &
      &                MLSPCF_L2_param_ccsdsstartid, &
      &                MLSPCF_L2_param_ccsdsendid, &
      &                MLSPCF_L2_param_col_spec_keys, &
      &                MLSPCF_L2_param_col_spec_mcfnames      , &
      &                MLSPCF_L2_param_col_spec_doinames      , &
      &                MLSPCF_L2_param_spec_keys, &
      &                MLSPCF_L2_param_spec_mcfnames      , &
      &                MLSPCF_L2_param_switches, &
      &                MLSPCF_Pcf_start
    use MLSStrings, only: lowercase
d111 7
a117 7
    use SDPToolkit, only: max_orbits, pgs_pc_getfilesize, pgs_td_utctotai,&
      &    pgs_pc_getconfigdata, pgs_pc_getreference, pgs_s_success, &
      &    pgstd_e_no_leap_secs
    use Time_m, only: sayTime, time_now
    use Toggles, only: gen, levels, switches, toggle
    use Trace_m, only: trace_begin, trace_end
    use WriteMetadata, only: L2PCF, MCFCaseSensitive
d397 10
a406 1
    ! This hackery-quackery allows us to use the PCF to
d506 2
a507 2
    use L2GPData, only: col_species_keys, col_species_hash
    use WriteMetadata, only: L2PCF
d689 1
a689 1
       "$Id: open_init.f90,v 2.112 2016/11/08 17:31:47 pwagner Exp $"
d702 3
@


2.112
log
@Use SayTime subroutine from time_m module
@
text
@d22 5
a26 5
  use HighOutput, only: addRow, beVerbose, &
    & OutputNamedValue, outputTable, startTable
  use MLSCommon, only: fileNameLen, MLSFile_t, nameLen, TAI93_Range_t
  use MLSL2Options, only: specialDumpFile, Toolkit
  use MLSStringLists, only: array2List, catLists, &
d28 1
a28 1
  use Output_m, only: Blanks, newLine, Output, switchOutput, revertOutput
d74 2
a75 2
    use intrinsic, only: l_hdf
    use L1BData, only: findMaxMaf, readL1BAttribute
d78 1
a78 1
      & addFileToDatabase, initializeMLSFile, MLS_Openfile
d96 1
a96 1
    use PCFHdr, only: globalattributes, createpcfannotation, filltai93attribute
d504 2
d535 3
a537 3
    use L1BData, only: L1BData_t, nameLen, precisionSuffix, &
      & assembleL1BQtyName, deallocateL1BData, Dump, &
      & readL1BData 
d558 2
d666 1
a666 1
       "$Id: open_init.f90,v 2.111 2016/09/22 22:57:25 pwagner Exp $"
d679 3
@


2.111
log
@Added DumpL1BDatabase; improved appearance of Dump_open_init
@
text
@d100 1
a100 1
    use Time_m, only: time_now
d219 1
a219 1
     if ( timing ) call sayTime
d442 1
a442 1
   if ( timing ) call sayTime         
a444 12
  contains
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for open_init = " )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime
d662 1
a662 1
       "$Id: open_init.f90,v 2.110 2016/08/09 21:21:13 pwagner Exp $"
d675 3
@


2.110
log
@Survives encounter with non-satellite data
@
text
@d22 2
a23 1
  use highOutput, only: beVerbose, outputNamedValue
d26 3
a28 3
  use MLSStringLists, only: array2List, catLists, getStringElement, &
    & numStringElements, switchDetail
  use Output_m, only: Blanks, Output
d41 1
a41 1
  public :: OpenAndInitialize
d494 1
a494 3
    use L1BData, only: L1BData_t, &
      & Assemblel1bqtyname, deallocatel1bdata, dump, readl1bdata
    use L2AUxdata, only: maxsdnamesbufsize
a495 3
    use MLSFiles, only: HDFVersion_4       
    use MLSHdf5, only: getAllHDF5DSNames
    use Output_m, only: revertoutput, switchoutput
d499 5
a503 5
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    character(len=CCSDSlen) CCSDSEndTime
    character(len=CCSDSlen) CCSDSStartTime
    type (TAI93_Range_T) :: processingRange ! Data processing range
    integer, intent(in) :: Details
d506 1
a506 13

    integer :: i, NoMAFs, IERR
    character (len=*), parameter :: time_format='(1pD18.12)'
    character (len=*), parameter :: l1b_quant_name='R1A:118.B1F:PT.S0.FB25-1'
    type (L1BData_T) :: l1bDataSet   ! L1B dataset

    integer ::  hdfVersion
    integer :: item
    character(len=namelen) :: l1bItemName
    character(len=MAXSDNAMESBUFSIZE) :: l1bitemlist
    integer :: nL1bItems
    logical, parameter :: countEmpty = .true.
    type (MLSFile_T), pointer ::     L1BFile
d513 61
a573 4
  
   if(associated(filedatabase)) then
     if ( specialDumpFile /= ' ' .and. Details > -2 ) &
       & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
d576 1
d578 22
a599 41
         call output ( 'PCF id:   ' )                                       
         call output ( L1BFile%PCFID, advance='yes' )
         call output ( 'fileid:   ' )
         call output ( L1BFile%FileID%f_id, advance='yes' )
         call output ( 'name:   ' )                                       
         call output ( TRIM(L1BFile%name), advance='yes' )
         call output ( 'hdf version:   ' )                                       
         call output ( L1BFile%hdfVersion, advance='yes' )
         if ( Details > -2 .and. hdfVersion == HDFVERSION_4 ) then
           l1bItemName = AssembleL1BQtyName ( l1b_quant_name, hdfVersion, .false. )
           call ReadL1BData ( L1BFile, l1bItemname, L1bDataSet, &
            & NoMAFs, IERR, NeverFail=.true. )
           if ( IERR == 0 ) then
             call Dump ( l1bDataSet, Details )
             call DeallocateL1BData ( l1bDataSet )
           else
             call output ( 'Error number  ' )
             call output ( IERR )
             call output ( ' while reading quantity named  ' )
             call output ( trim(l1b_quant_name) )
           end if
         elseif( Details > -2 ) then
           call GetAllHDF5DSNames (L1BFile%FileID%f_id, '/', l1bitemlist)
           nL1bItems = NumStringElements(trim(l1bitemlist), countEmpty)
           do item=1, nL1bItems
             call GetStringElement (trim(l1bitemlist), l1bItemName, item, &
               & countEmpty )
             if ( index('/PCF,/LCF', trim(l1bItemName)) > 0 ) cycle
             call ReadL1BData ( L1BFile, l1bItemName, L1bDataSet, &
              & NoMAFs, IERR, NeverFail=.true. )
             if ( IERR == 0 ) then
               call Dump ( l1bDataSet, Details )
               call DeallocateL1BData ( l1bDataSet )
             else
               call output ( 'Error number  ' )
               call output ( IERR )
               call output ( ' while reading quantity named  ' )
               call output ( trim(l1bItemName) )
             end if
             ! if ( item > 2 ) stop
           enddo
d601 15
a615 10
      elseif ( L1BFile%content == 'l1boa' ) then
        call output ( 'L1OA file:', advance='yes' )
  
        call output ( 'PCFid:   ' )
        call output ( L1BFile%PCFId, advance='yes' )
        call output ( 'fileid:   ' )
        call output ( L1BFile%FileID%f_id, advance='yes' )
        call output ( 'name:   ' )
        call output ( TRIM(L1BFile%Name), advance='yes' )
      end if
d617 1
d619 3
a621 51
     if ( specialDumpFile /= ' ' .and. Details > -2 ) &
       & call revertOutput

   else
    call output ( '(null database)', advance='yes' )

   end if

    call output ( 'Start Time:   ' )
    call output ( CCSDSStartTime, advance='yes' )

    call output ( 'End Time:     ' )
    call output ( CCSDSEndTime, advance='yes' )

    call output ( 'Start Time (tai):   ' )
    call output ( processingrange%starttime, format=time_format, advance='yes' )

    call output ( 'End Time (tai):     ' )
    call output ( processingrange%endtime, format=time_format, advance='yes' )

    call output ( 'Processing Range:     ' )
    call output ( processingrange%endtime-processingrange%starttime, advance='yes' )

    call output ( 'PGE version:   ' )
    call output ( l2pcf%PGEVersion, advance='yes' )

    call output ( 'cycle:   ' )
    call output ( l2pcf%cycle, advance='yes' )

    call output ( 'RunID:   ' )
    call output ( l2pcf%RunID, advance='yes' )

    call output ( 'Log file name:   ' )
    call output ( TRIM(l2pcf%logGranID), advance='yes' )

    call output ( 'l2gp column species name keys:   ' )
    call output ( TRIM(col_species_keys), advance='yes' )

    call output ( 'corresponding units hash:   ' )
    call output ( TRIM(col_species_hash), advance='yes' )

    call output ( 'l2gp species name keys:   ' )
    call output ( TRIM(l2pcf%spec_keys), advance='yes' )

    call output ( 'corresponding mcf names:   ' )
    call output ( TRIM(l2pcf%spec_mcfnames      ), advance='yes' )

    call output ( 'corresponding doi names:   ' )
    call output ( TRIM(l2pcf%spec_doinames      ), advance='yes' )

  end subroutine Dump_open_init
d674 1
a674 1
       "$Id: open_init.f90,v 2.109 2016/07/28 01:45:07 vsnyder Exp $"
d687 3
@


2.109
log
@Refactor dump and diff
@
text
@d22 6
a27 6
  use HIGHOUTPUT, only: BEVERBOSE
  use MLSCOMMON, only: FILENAMELEN, MLSFILE_T, NAMELEN, TAI93_RANGE_T
  use MLSL2OPTIONS, only: SPECIALDUMPFILE, TOOLKIT
  use MLSSTRINGLISTS, only: ARRAY2LIST, CATLISTS, GETSTRINGELEMENT, &
    & NUMSTRINGELEMENTS, SWITCHDETAIL
  use OUTPUT_M, only: BLANKS, OUTPUT
d72 31
a102 31
    use HDF, only: DFACC_RDONLY
    use INTRINSIC, only: L_HDF
    use L1BDATA, only: FINDMAXMAF, READL1BATTRIBUTE
    use L2GPDATA, only: COL_SPECIES_KEYS, COL_SPECIES_HASH
    use MLSFILES, only: WILDCARDHDFVERSION, &
      & ADDFILETODATABASE, INITIALIZEMLSFILE, MLS_OPENFILE
    use MLSKINDS, only: R8
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, MLSMESSAGE
    use MLSPCF2, only: MLSPCF_L1B_OA_START, MLSPCF_L1B_RAD_END, &
      &                MLSPCF_L1B_RAD_START, &
      &                MLSPCF_L2_PARAM_PGEVERSION, &
      &                MLSPCF_L2_PARAM_CYCLE, &
      &                MLSPCF_L2_PARAM_CCSDSSTARTID, &
      &                MLSPCF_L2_PARAM_CCSDSENDID, &
      &                MLSPCF_L2_PARAM_COL_SPEC_KEYS, &
      &                MLSPCF_L2_PARAM_COL_SPEC_MCFNAMES      , &
      &                MLSPCF_L2_PARAM_COL_SPEC_DOINAMES      , &
      &                MLSPCF_L2_PARAM_SPEC_KEYS, &
      &                MLSPCF_L2_PARAM_SPEC_MCFNAMES      , &
      &                MLSPCF_L2_PARAM_SWITCHES, &
      &                MLSPCF_PCF_START
    use MLSSTRINGS, only: LOWERCASE
    use PCFHDR, only: GLOBALATTRIBUTES, CREATEPCFANNOTATION, FILLTAI93ATTRIBUTE
    use SDPTOOLKIT, only: MAX_ORBITS, PGS_PC_GETFILESIZE, PGS_TD_UTCTOTAI,&
      &    PGS_PC_GETCONFIGDATA, PGS_PC_GETREFERENCE, PGS_S_SUCCESS, &
      &    PGSTD_E_NO_LEAP_SECS
    use TIME_M, only: TIME_NOW
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use WRITEMETADATA, only: L2PCF, MCFCASESENSITIVE
d125 2
a126 1
    type (MLSFile_T)             :: L1BFile
d249 1
d285 1
a285 1
    GlobalAttributes%LastMAFCtr = FindMaxMAF ( (/l1BFile/), &
d287 2
d493 8
a500 8
    use L1BDATA, only: L1BDATA_T, &
      & ASSEMBLEL1BQTYNAME, DEALLOCATEL1BDATA, DUMP, READL1BDATA
    use L2AUXDATA, only: MAXSDNAMESBUFSIZE
    use L2GPDATA, only: COL_SPECIES_KEYS, COL_SPECIES_HASH
    use MLSFILES, only: HDFVERSION_4       
    use MLSHDF5, only: GETALLHDF5DSNAMES
    use OUTPUT_M, only: REVERTOUTPUT, SWITCHOUTPUT
    use WRITEMETADATA, only: L2PCF
a516 1
    integer :: ifl1
a532 1
    ifl1 = 0
d693 1
a693 1
       "$Id: open_init.f90,v 2.108 2014/09/05 01:26:25 vsnyder Exp $"
d706 3
@


2.108
log
@Remove unused parameter; comment out unused USE name
@
text
@a21 1
  use DUMP_0, only: DUMP
d70 2
a71 1
    use DATES_MODULE, only: UTC_TO_YYYYMMDD
a72 1
!   use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
d691 1
a691 1
       "$Id: open_init.f90,v 2.107 2014/03/26 17:46:25 pwagner Exp $"
d704 3
@


2.107
log
@Added ProductionLocation, identifier_product_DOI to attributes
@
text
@d73 1
a73 1
    use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
a111 1
    logical, parameter :: CaseSensitive = .true.
d692 1
a692 1
       "$Id: open_init.f90,v 2.106 2014/03/07 19:24:48 pwagner Exp $"
d705 3
@


2.106
log
@Name_Len changed to nameLen; got from MLSCommon
@
text
@d15 6
a20 2
  ! Opens and closes several files
  ! Creates and destroys the L1BInfo database
d22 1
d26 2
a27 2
  use MLSSTRINGLISTS, only: CATLISTS, GETSTRINGELEMENT, NUMSTRINGELEMENTS, &
    & SWITCHDETAIL
d52 2
a53 1
  integer, parameter :: CCSDSLen=27
d73 1
d89 2
a90 1
      &                MLSPCF_L2_PARAM_COL_SPEC_HASH, &
d92 1
a92 1
      &                MLSPCF_L2_PARAM_SPEC_HASH, &
d121 1
d123 1
a123 1

a125 1

d182 29
a210 2
   l2pcf%spec_hash = '(not applicable)'      ! will not create metadata

d345 1
a345 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_col_spec_hash, col_species_hash)
d348 1
a348 1
      call announce_error ( "Missing pcf param: col_spec_hash", &
d358 1
a358 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_spec_hash, l2pcf%spec_hash)
d361 1
a361 1
      call announce_error ( "Missing pcf param: spec_hash" )
d365 1
a365 1
      l2pcf%spec_hash = LowerCase(l2pcf%spec_hash)
d380 23
d634 5
a638 2
    call output ( 'corresponding mcf hash:   ' )
    call output ( TRIM(l2pcf%spec_hash), advance='yes' )
d693 1
a693 1
       "$Id: open_init.f90,v 2.105 2014/01/09 00:30:24 pwagner Exp $"
d706 3
@


2.105
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d19 1
a19 1
  use MLSCOMMON, only: FILENAMELEN, MLSFILE_T, TAI93_RANGE_T
d433 1
a433 1
    use L1BDATA, only: L1BDATA_T, NAME_LEN, &
d459 1
a459 1
    character(len=Name_Len) :: l1bItemName
d632 1
a632 1
       "$Id: open_init.f90,v 2.104 2013/12/05 01:43:48 pwagner Exp $"
d645 3
@


2.104
log
@Read RunID component from cycle field of pcf; started using BeVerbose
@
text
@d18 1
d23 1
a23 1
  use OUTPUT_M, only: BEVERBOSE, BLANKS, OUTPUT
d632 1
a632 1
       "$Id: open_init.f90,v 2.103 2013/08/30 02:45:50 vsnyder Exp $"
d645 3
@


2.103
log
@Revise calls to trace_begin and trace_end
@
text
@d22 1
a22 1
  use OUTPUT_M, only: BLANKS, OUTPUT
d101 2
a102 2
    !Local Variables
    logical, parameter :: DEBUG = .FALSE.
d105 3
a107 1
   ! The following parameters will only be needed if PCF ids are missing
a110 2
    character(len=CCSDSlen)      :: CCSDSEndTime
    character(len=CCSDSlen)      :: CCSDSStartTime
d112 2
d115 3
d121 1
d123 1
d125 1
a127 7
    character (len=fileNameLen)  :: name

    character(len=len(switches)) :: extra_switches

    integer                      :: Indx, Version                            

    integer                      :: l1bFlag
d130 1
a130 1

d290 7
a296 1
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_Cycle, l2pcf%cycle)
d377 1
a377 1
   if ( levels(gen) > 0 .or. details > -3 ) &
d560 3
d631 1
a631 1
       "$Id: open_init.f90,v 2.102 2013/08/17 02:55:23 vsnyder Exp $"
d644 3
@


2.102
log
@Regularized trace usage
@
text
@a17 3
  use DATES_MODULE, only: UTC_TO_YYYYMMDD
  use HDF, only: DFACC_RDONLY
  use INTRINSIC, only: L_HDF
a18 1
  use MLSKINDS, only: R8
a19 1
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, MLSMESSAGE
a22 4
  use PCFHDR, only: GLOBALATTRIBUTES, CREATEPCFANNOTATION, FILLTAI93ATTRIBUTE
  use SDPTOOLKIT, only: MAX_ORBITS
  use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
d64 3
d71 1
d73 1
d87 2
a88 1
    use SDPTOOLKIT, only: PGS_PC_GETFILESIZE, PGS_TD_UTCTOTAI,&
d92 2
d115 1
d134 1
a138 1
    if ( toggle(gen) ) call trace_begin ( "OpenAndInitialize" )
d181 1
a181 1
     if ( toggle(gen) ) call trace_end ( "OpenAndInitialize" )
d371 1
a371 1
        & call Dump_open_init ( filedatabase, &
a372 1
   if ( toggle(gen) ) call trace_end ( "OpenAndInitialize" ) 
d374 1
a374 1
   return                             
d621 1
a621 1
       "$Id: open_init.f90,v 2.101 2012/08/16 17:49:40 pwagner Exp $"
d634 3
@


2.101
log
@Simplify; remove unused stuff
@
text
@d181 1
a181 3
     if ( toggle(gen) ) then
       call trace_end ( "OpenAndInit" )
     end if
d200 1
a200 1
      endif
d373 1
a373 3
   if ( toggle(gen) ) then            
     call trace_end ( "OpenAndInit" ) 
   end if                             
d622 1
a622 1
       "$Id: open_init.f90,v 2.100 2012/04/05 20:14:39 pwagner Exp $"
d635 3
@


2.100
log
@Erased all traces of parallel staging file
@
text
@d22 3
a24 2
  use MLSKinds, only: R8
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
a74 1
    use L2PARINFO, only: PARALLEL
a76 1
    use MLSL2OPTIONS, only: TOOLKIT
d153 1
a153 1
        call announce_error ( 0, DEFAULTANTEXT )
d207 1
a207 1
      &  call announce_error ( 0, "Could not find any L1BRAD files" )
d243 1
a243 1
      call announce_error ( 0, "Could not find L1BOA file" )
d257 1
a257 1
      call announce_error ( 0, "Missing pcf param: CCSDSStartTime" )
d264 1
a264 1
        & call announce_error ( 0, "Could not convert UTC Start time to TAI" )
d271 1
a271 1
      call announce_error ( 0, "Missing pcf param: CCSDSEndTime" )
d278 1
a278 1
        & call announce_error ( 0, "Could not convert UTC End time to TAI" )
d288 1
a288 1
      call announce_error ( 0, "Missing pcf param: output version" )
d294 1
a294 1
      call announce_error ( 0, "Missing pcf param: cycle" )
d300 1
a300 1
      call announce_error ( 0, "Missing pcf param: col_spec_keys", &
d307 1
a307 1
      call announce_error ( 0, "Missing pcf param: col_spec_hash", &
d314 1
a314 1
      call announce_error ( 0, "Missing pcf param: spec_keys" )
d320 1
a320 1
      call announce_error ( 0, "Missing pcf param: spec_hash" )
d345 1
a345 1
      call announce_error ( 0, "Error retrieving log file name from PCF" )
a433 1
    use MLSL2OPTIONS, only: SPECIALDUMPFILE
d576 1
a576 1
  subroutine Announce_Error ( Lcf_where, Full_message, Use_toolkit, &
a577 4

    use LEXER_CORE, only: PRINT_SOURCE
    use TREE, only: DUMP_TREE_NODE, SOURCE_REF
  
d580 1
a580 1
    integer, intent(in) :: Lcf_where
d596 1
a596 16
      call output ( '***** At ' )

      if ( lcf_where > 0 ) then
        call print_source ( source_ref(lcf_where) )
      else
        call output ( '(no lcf node available)' )
      end if

      call output ( ": The " );
      if ( lcf_where > 0 ) then
        call dump_tree_node ( lcf_where, 0 )
      else
        call output ( '(no lcf tree available)' )
      end if

      call output ( " Caused the following error:", advance='yes', &
d626 1
a626 1
       "$Id: open_init.f90,v 2.99 2012/03/28 20:09:38 pwagner Exp $"
d639 3
@


2.99
log
@Issue warning--slave tasks lost ability to join quantities
@
text
@d90 1
a90 1
      &                MLSPCF_PCF_START, MLSPCF_L2PARSF_START
a367 7
    ! returnStatus = Pgs_pc_getReference(mlspcf_l2parsf_start, version, &
    !   & parallel%stagingFile)
    ! if ( returnStatus /= PGS_S_SUCCESS .and. parallel%master ) then
    !  call announce_error ( 0, &
    !    & "Error retrieving parallel staging file name from PCF" )
    ! endif
        
d647 1
a647 1
       "$Id: open_init.f90,v 2.98 2011/06/29 21:49:43 pwagner Exp $"
d660 3
@


2.98
log
@Some cases may safely omit l1b files
@
text
@d19 1
a19 1
  use HDF, only: DFACC_RDonly
d23 1
a23 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
d363 11
a373 9
    ! Get name of Parallel Staging file
    version = 1

    returnStatus = Pgs_pc_getReference(mlspcf_l2parsf_start, version, &
      & parallel%stagingFile)
    if ( returnStatus /= PGS_S_SUCCESS .and. parallel%master ) then
      call announce_error ( 0, &
        & "Error retrieving parallel staging file name from PCF" )
    endif
d654 1
a654 1
       "$Id: open_init.f90,v 2.97 2009/06/23 18:46:18 pwagner Exp $"
d667 3
@


2.97
log
@Prevent Intel from optimizing ident string away
@
text
@d18 13
a30 12
  use dates_module, only: utc_to_yyyymmdd
  use Hdf, only: DFACC_RDONLY
  use intrinsic, only: l_hdf
  use MLSCommon, only: FileNameLen, MLSFile_T, TAI93_Range_T, R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
  use MLSStringLists, only: catLists, GetStringElement, NumStringElements, &
    & switchDetail
  use Output_m, only: Blanks, Output
  use PCFHdr, only: GlobalAttributes, CreatePCFAnnotation, FillTAI93Attribute
  use SDPToolkit, only: max_orbits
  use Toggles, only: Gen, Levels, Switches, Toggle
  use Trace_M, only: Trace_begin, Trace_end
d49 1
a49 1
       "$RCSfile: $"
d72 7
a78 7
    use L1BData, only: FindMaxMAF, ReadL1BAttribute
    use L2GPData, only: col_species_keys, col_species_hash
    use L2ParInfo, only: parallel
    use MLSFiles, only: WILDCARDHDFVERSION, &
      & addFileToDatabase, InitializeMLSFile, mls_openFile
    use MLSL2Options, only: TOOLKIT, PENALTY_FOR_NO_METADATA
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
d81 13
a93 13
      &                MLSPCF_L2_param_PGEVersion, &
      &                MLSPCF_L2_param_Cycle, &
      &                MLSPCF_L2_param_CCSDSStartId, &
      &                MLSPCF_L2_param_CCSDSEndId, &
      &                MLSPCF_L2_param_col_spec_keys, &
      &                MLSPCF_L2_param_col_spec_hash, &
      &                MLSPCF_L2_param_spec_keys, &
      &                MLSPCF_L2_param_spec_hash, &
      &                MLSPCF_L2_param_switches, &
      &                MLSPCF_PCF_start, mlspcf_l2parsf_start
    use MLSStrings, only: LowerCase
    use SDPToolkit, only: Pgs_pc_getFileSize, pgs_td_utctotai,&
      &    pgs_pc_getconfigdata, Pgs_pc_getReference, PGS_S_SUCCESS, &
d95 2
a96 2
    use Time_M, only: Time_Now
    use WriteMetadata, only: L2PCF, MCFCASESENSITIVE
d153 4
a156 1
      if ( TOOLKIT ) call announce_error ( 0, DEFAULTANTEXT )
a159 1
      error = PENALTY_FOR_NO_METADATA
d436 9
a444 9
    use L1BData, only: L1BData_T, NAME_LEN, &
      & AssembleL1BQtyName, DeallocateL1BData, Dump, ReadL1BData
    use L2AUXData, only: MAXSDNAMESBUFSIZE
    use L2GPData, only: col_species_keys, col_species_hash
    use MLSL2Options, only: SPECIALDUMPFILE
    use MLSFiles, only: HDFVERSION_4       
    use MLSHDF5, only: GetAllHDF5DSNames
    use output_m, only: revertoutput, switchOutput
    use WriteMetadata, only: L2PCF
d652 1
a652 1
       "$Id: read_apriori.f90 is it here $"
d665 3
@


2.96
log
@Remove unused symbols
@
text
@d48 1
a48 1
       "$RCSfile: open_init.f90,v $"
d646 1
a647 1
!---------------------------- RCS Ident Info -------------------------------
d649 2
a650 3
       "$Id: open_init.f90,v 2.95 2007/06/21 00:54:08 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d652 1
d654 1
d662 3
@


2.95
log
@Remove tabs, which are not part of the Fortran standard
@
text
@a79 1
      &                MLSPCF_L2_param_InputVersion, &
d437 1
a437 1
    use MLSL2Options, only: TOOLKIT, PENALTY_FOR_NO_METADATA, SPECIALDUMPFILE
d649 1
a649 1
       "$Id: open_init.f90,v 2.94 2006/09/21 18:50:33 pwagner Exp $"
d661 3
@


2.94
log
@Uncertain why or whether this was necessary but did it anyway
@
text
@d227 1
a227 1
	       & l1bFlag)
d234 1
a234 1
	       & l1bFlag)
d289 1
a289 1
	
d295 1
a295 1
	
d302 1
a302 1
	
d309 1
a309 1
	
d315 1
a315 1
	
d321 1
a321 1
	
d337 1
a337 1
	
d450 1
a450 1
	
d481 3
a483 3
    	   call output ( L1BFile%PCFID, advance='yes' )
  	      call output ( 'fileid:   ' )
	      call output ( L1BFile%FileID%f_id, advance='yes' )
d485 1
a485 1
    	   call output ( TRIM(L1BFile%name), advance='yes' )
d487 1
a487 1
    	   call output ( L1BFile%hdfVersion, advance='yes' )
d650 1
a650 1
       "$Id: open_init.f90,v 2.93 2006/07/07 23:11:19 pwagner Exp $"
d662 3
@


2.93
log
@Removed already-commented-out souvenirs
@
text
@d74 1
a74 1
    use MLSFiles, only: &
d196 1
d650 1
a650 1
       "$Id: open_init.f90,v 2.92 2006/03/15 23:52:24 pwagner Exp $"
d662 3
@


2.92
log
@Removed InputVersion component from PCF, l2cf
@
text
@a36 4
!     (data types and parameters)
! MLSPCF_LOG                      PCF number of the log file
! CCSDSLen                        Max length of coded start, end times

a63 1
    ! Opens and reads the signal nomenclature file
d65 5
a167 1
   ! l2pcf%InputVersion = ' '
a199 1
        ! L2pcf%L1BRADPCFIds(ifl1) = L1BFile%PCFID
a215 1
        ! l2pcf%L1BOAPCFId = mlspcf_l1b_oa_start
a282 7
    ! returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_inputVersion, &
    !                                       l2pcf%inputVersion)
    ! if ( returnstatus /= PGS_S_SUCCESS ) then
    !   call announce_error ( 0, "Missing pcf param: input version", &
    !     & forgiveable=.true. )
    ! end if

a351 1
    ! GlobalAttributes%InputVersion = l2pcf%inputVersion
a443 1
    ! integer, intent(in) :: num_l1b_files
a466 1
    ! hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)  
a523 2
        ! call output ( 'PCFid:   ' )
        ! call output ( l2pcf%L1BOAPCFId, advance='yes' )
a558 3
    ! call output ( 'input version:   ' )
    ! call output ( l2pcf%InputVersion, advance='yes' )

d649 1
a649 1
       "$Id: open_init.f90,v 2.91 2006/02/16 00:16:01 pwagner Exp $"
d661 3
@


2.91
log
@switchDetail instead of index
@
text
@a41 1
! DestroyL1BInfo                  Called when the l1bInfo is finished with
a109 4
! character(len=*), parameter :: DEFAULT_SPEC_KEYS= &
!   & 'temp,gph,h2o,hno3,o3,hcl,clo,co,n2o,oh,rhi,so2,ho2,bro,hocl,hcn,cirrus-ice,others'
! character(len=*), parameter :: DEFAULT_SPEC_HASH= &
!   & 't,z,h2o,hno3,o3,hcl,clo,co,n2o,oh,rhi,so2,ho2,bro,hocl,hcn,ice,oth'
d168 1
a168 1
   l2pcf%InputVersion = ' '
d286 6
a291 5
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_inputVersion, &
                                          l2pcf%inputVersion)
    if ( returnstatus /= PGS_S_SUCCESS ) then
      call announce_error ( 0, "Missing pcf param: input version" )
    end if
d574 2
a575 2
    call output ( 'input version:   ' )
    call output ( l2pcf%InputVersion, advance='yes' )
d667 1
a667 1
       "$Id: open_init.f90,v 2.90 2006/02/10 21:16:20 pwagner Exp $"
d679 3
@


2.90
log
@dumps may go to special dumpfile
@
text
@d23 2
a24 1
  use MLSStringLists, only: catLists, NumStringElements, GetStringElement
d180 1
a180 1
     if ( levels(gen) > 0 .or. index(switches,'pcf') /= 0 ) then
d224 1
a224 1
        if(index(switches, 'pro') /= 0) then  
d389 2
a390 10
   if ( index(switches, 'pcf3') /= 0 ) then
     Details = 1
   elseif ( index(switches, 'pcf2') /= 0 ) then
     Details = 0
   elseif ( index(switches, 'pcf1') /= 0 ) then
     Details = -1
   else
     Details = -2
   end if
   if ( levels(gen) > 0 .or. index(switches,'pcf') /= 0 ) &
d671 1
a671 1
       "$Id: open_init.f90,v 2.89 2006/01/27 01:03:29 pwagner Exp $"
d683 3
@


2.89
log
@Changed wording when merely a warning
@
text
@a20 1
  use L2GPData, only: col_species_keys, col_species_hash
d72 1
d458 2
d462 1
d497 2
d559 2
d678 1
a678 1
       "$Id: open_init.f90,v 2.88 2006/01/19 00:31:54 pwagner Exp $"
d690 3
@


2.88
log
@reads col_spec_keys and _hash from PCF
@
text
@d650 6
a655 1
      call output ( '***Error in module ' )
d671 1
a671 1
       "$Id: open_init.f90,v 2.87 2005/09/22 23:38:12 pwagner Exp $"
d683 3
@


2.87
log
@date conversion procedures and functions all moved into dates module
@
text
@d21 1
d85 2
d308 14
d587 6
d603 1
a603 1
    & Error_number )
d614 1
d622 1
d666 1
a666 1
       "$Id: open_init.f90,v 2.86 2005/07/21 23:45:21 pwagner Exp $"
d678 3
@


2.86
log
@Removed unused l1b fileinfo fields from l2pcf
@
text
@d18 1
d23 1
a23 2
  use MLSStringLists, only: catLists, NumStringElements, GetStringElement, &
    & utc_to_yyyymmdd
d641 1
a641 1
       "$Id: open_init.f90,v 2.85 2005/07/12 17:17:46 pwagner Exp $"
d653 3
@


2.85
log
@Dropped global attribute InputVersion
@
text
@d75 1
a75 2
    use MLSL2Options, only: TOOLKIT, PENALTY_FOR_NO_METADATA, &
      & ILLEGALL1BRADID, MAXNUML1BRADIDS
a173 4
   allocate ( L2pcf%L1BRADPCFIds(MAXNUML1BRADIDS), stat=status )
   L2pcf%L1BRADPCFIds = ILLEGALL1BRADID
   if ( status /= 0 ) &
     & call announce_error ( 0, 'Allocation failed for L1BRADPCFIDs' )
d202 1
a202 1
        L2pcf%L1BRADPCFIds(ifl1) = L1BFile%PCFID
d219 1
a219 1
        l2pcf%L1BOAPCFId = mlspcf_l1b_oa_start
a253 2
    ! print *, 'GlobalAttributes%FirstMAFCtr ', GlobalAttributes%FirstMAFCtr
    ! print *, 'GlobalAttributes%LastMAFCtr ', GlobalAttributes%LastMAFCtr
a480 5
         if(associated(l2pcf%L1BRADPCFIds)) then
           ifl1 = ifl1 + 1
  	        call output ( 'PCFid:   ' )
	        call output ( l2pcf%L1BRADPCFIds(ifl1), advance='yes' )
         endif
d526 2
a527 2
        call output ( 'PCFid:   ' )
        call output ( l2pcf%L1BOAPCFId, advance='yes' )
d641 1
a641 1
       "$Id: open_init.f90,v 2.84 2005/06/22 18:57:02 pwagner Exp $"
d653 3
@


2.84
log
@Reworded Copyright statement, moved rcs id
@
text
@d20 1
a20 1
  use MLSCommon, only: FileNameLen, L1BInfo_T, MLSFile_T, TAI93_Range_T, R8, i4
d46 1
a46 1
  public :: DestroyL1BInfo, OpenAndInitialize
d52 1
a52 1
       "$RCSfile: $"
a62 21
  ! ---------------------------------------------  DestroyL1BInfo  -----
  subroutine DestroyL1BInfo ( L1BInfo )

    ! Unneeded now that l1b files part of filedatabase

    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
    integer :: STATUS ! from deallocate
    integer :: id
    error = 0
    if ( toggle(gen) ) call trace_begin ( "DESTROYL1BInfo" )

    if ( error /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Problem with DestroyL1BInfo' )

    if ( toggle(gen) ) then
      call trace_end ( "DESTROYL1BInfo" )
    end if
  end subroutine DestroyL1BInfo


a63 1
  ! subroutine OpenAndInitialize ( processingRange, l1bInfo )
a98 1
    ! type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
a99 1
    ! type(PCFData_T) :: l2pcf
a102 2
    ! integer, parameter :: CCSDSEndId = 10412    ! Illegal PCFid
    ! integer, parameter :: CCSDSStartId = 10411    ! Illegal PCFid
d108 4
a111 4
    character(len=*), parameter :: DEFAULT_SPEC_KEYS= &
      & 'temp,gph,h2o,hno3,o3,hcl,clo,co,n2o,oh,rhi,so2,ho2,bro,hocl,hcn,cirrus-ice,others'
    character(len=*), parameter :: DEFAULT_SPEC_HASH= &
      & 't,z,h2o,hno3,o3,hcl,clo,co,n2o,oh,rhi,so2,ho2,bro,hocl,hcn,ice,oth'
a209 49
    ! Get the l1 file name from the PCF
!     L1_Version = 1
! 
!       returnStatus = Pgs_pc_getReference(L1FileHandle, L1_Version, &
!         & L1physicalFilename)
! 
!       if ( returnStatus == PGS_S_SUCCESS ) then
! 
!         ! Open the HDF file and initialize the SD interface
! 
!         ! Allocate L1BRADIDs, initialize them to illegal values
! 
!       if(.NOT. associated(l1bInfo%L1BRADIDs)) then
!         allocate ( l1bInfo%L1BRADIDs(MAXNUML1BRADIDS), stat=status )
!         allocate ( l1bInfo%L1BRADFileNames(MAXNUML1BRADIDS), stat=status )
!         l1bInfo%L1BRADIDs = ILLEGALL1BRADID
!         if ( status /= 0 ) &
!           & call announce_error ( 0, 'Allocation failed for L1BRADIDs' )
!         allocate ( L2pcf%L1BRADPCFIds(MAXNUML1BRADIDS), stat=status )
!         L2pcf%L1BRADPCFIds = ILLEGALL1BRADID
!         if ( status /= 0 ) &
!           & call announce_error ( 0, 'Allocation failed for L1BRADPCFIDs' )
!       end if
!   ! ((( This will have to change if we wish to convert l1 files to hdf5
!   !          Maybe put another wrapper in MSLFiles
!   !    sd_id = sfstart(L1physicalFilename, DFACC_READ)
!   !    sd_id = mls_sfstart(L1physicalFilename, DFACC_READ, &
!   !       hdfVersion=LEVEL1_HDFVERSION)
!         the_hdf_version = mls_hdf_version(L1PhysicalFileName)
!        sd_id = mls_io_gen_openF('hg', caseSensitive, ErrType, &
!          & record_length, DFACC_READ, &
!          & L1physicalFilename, hdfVersion=LEVEL1_HDFVERSION)
!         if ( sd_id <= 0 ) then
!           call announce_error ( 0, &
!             & 'Error opening L1RAD file: ' //L1physicalFilename)
!         elseif(ifl1 == MAXNUML1BRADIDS) then
!           call announce_error ( 0, "Cannot open any more L1BRAD files" )
!           exit
!         else
!           ifl1 = ifl1 + 1
!           L2pcf%L1BRADPCFIds(ifl1) = L1FileHandle
!           l1bInfo%L1BRADIDs(ifl1) = sd_id
!           l1bInfo%L1BRADFileNames(ifl1) = L1physicalFilename
!           if(index(switches, 'pro') /= 0) then  
!             call announce_success(L1physicalFilename, 'l1brad', &                   
!             & hdfVersion=the_hdf_version)                    
!           end if
!         end if
!       end if
a215 5

    ! l1bInfo%L1BOAID = ILLEGALL1BRADID
!     L1_Version = 1
!     returnStatus = Pgs_pc_getReference(mlspcf_l1b_oa_start, L1_Version, &
!       & L1physicalFilename)
a223 11
      ! Open the HDF file and initialize the SD interface

!         the_hdf_version = mls_hdf_version(L1PhysicalFileName)
!        sd_id = mls_io_gen_openF('hg', caseSensitive, ErrType, &
!          & record_length, DFACC_READ, &
!          & L1physicalFilename, hdfVersion=LEVEL1_HDFVERSION)

!      if ( sd_id <= 0 ) then
!
!        call announce_error ( 0, "Error opening L1OA file "//L1physicalFilename )
!      else
a224 2
!         l1bInfo%L1BOAID = sd_id
!         l1bInfo%L1BOAFileName = L1physicalFilename
a261 2
    ! Temporarily we allow the use of older PCFids: CCSDSStartId, CCSDEndId
    ! (if TOOLKIT is FALSE)
a266 4
    !else if ( returnstatus /= PGS_S_SUCCESS ) then
    !  returnStatus = pgs_pc_getconfigdata (CCSDSStartId, CCSDSStartTime)
    !  if ( returnstatus /= PGS_S_SUCCESS ) &
    !    & call announce_error ( 0, "Could not get CCSDS Start Time" )
a280 4
    !else if ( returnstatus /= PGS_S_SUCCESS ) then
    !  returnStatus = pgs_pc_getconfigdata (CCSDSEndId, CCSDSEndTime)
    !  if ( returnstatus /= PGS_S_SUCCESS ) &
    !    & call announce_error ( 0, "Could not get CCSDS End Time" )
a297 2
    else if ( returnstatus /= PGS_S_SUCCESS ) then
      l2pcf%inputVersion = 'V0-5'
a303 2
    else if ( returnstatus /= PGS_S_SUCCESS ) then
      l2pcf%PGEVersion = 'V0-5'
a309 2
    else if ( returnstatus /= PGS_S_SUCCESS ) then
      l2pcf%cycle = '1'
a315 2
    else if ( returnstatus /= PGS_S_SUCCESS ) then
      l2pcf%spec_keys = DEFAULT_SPEC_KEYS
a321 2
    else if ( returnstatus /= PGS_S_SUCCESS ) then
      l2pcf%spec_hash = DEFAULT_SPEC_HASH
d355 1
a355 1
    GlobalAttributes%InputVersion = l2pcf%inputVersion
a454 2
    ! type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
    ! type(PCFData_T) :: l2pcf
d653 1
a653 1
       "$Id: $"
d665 3
@


2.83
log
@Many changes to accommodate the new fields in MLSFile_T
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d50 3
a52 5
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: IdParm = &
    "$Id: open_init.f90,v 2.82 2005/05/31 17:51:17 pwagner Exp $"
  character(len=len(idParm)) :: Id = idParm
  character(len=*), parameter :: ModuleName="$RCSfile: open_init.f90,v $"
d54 1
a54 1
  !-----------------------------------------------------------------------------
d766 5
d780 3
@


2.82
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d10 2
d44 1
a44 1
    "$Id: open_init.f90,v 2.81 2004/12/28 00:23:03 vsnyder Exp $"
d220 1
a220 1
        & type='hdf', access='rdonly')
d292 1
a292 1
      & type='hdf', access='rdonly')
d769 3
@


2.81
log
@Remove unreferenced use names
@
text
@d10 1
a10 2
  use MLSCommon, only: FileNameLen, L1BInfo_T, TAI93_Range_T, R8, i4
  use MLSL2Options, only: LEVEL1_HDFVERSION
d42 1
a42 1
    "$Id: open_init.f90,v 2.80 2004/12/15 23:35:59 pwagner Exp $"
a47 1
  ! integer, parameter :: LEVEL1_HDFVERSION = 4  ! Until we convert level 1 to hdf5
d58 1
a58 3
    use MLSL2Options, only: ILLEGALL1BRADID
    use MLSFiles, only: mls_io_gen_closeF
    use WriteMetadata, only: L2PCF
a60 1
    ! type (PCFData_T) ::                          L2pcf
a65 32
    if ( associated(l1bInfo%L1BRADIDs) ) then
      do id = 1, SIZE(l1bInfo%L1BRADIDs)
         if(l1bInfo%L1BRADIDs(id) /= ILLEGALL1BRADID) then
  ! ((( This will have to change if we wish to convert l1 files to hdf5
  !          Maybe put another wrapper in MSLFiles
  !      STATUS = sfend(l1bInfo%L1BRADIDs(id))
  !      STATUS = mls_sfend(l1bInfo%L1BRADIDs(id), hdfVersion=LEVEL1_HDFVERSION)
         STATUS = mls_io_gen_closeF('hg', l1bInfo%L1BRADIDs(id), &
           & hdfVersion=LEVEL1_HDFVERSION)

         end if
      end do
      deallocate( l1bInfo%L1BRADIDs, l1bInfo%L1BRADFileNames, stat=status )
      if ( status /= 0 ) then
        call announce_error ( 0, 'Error deallocating l1bInfo' )
      end if
      if(associated(L2pcf%L1BRADPCFIDs)) &
           deallocate(L2pcf%L1BRADPCFIDs, stat=status)
      if ( status /= 0 ) then
        call announce_error ( 0, 'Error deallocating L2pcf%L1BRADPCFIDs' )
      end if
    end if
    
    if(l1bInfo%L1BOAID /= ILLEGALL1BRADID) then
  ! ((( This will have to change if we wish to convert l1 files to hdf5
  !          Maybe put another wrapper in MSLFiles
  !  STATUS = sfend(l1bInfo%L1BOAID)
  !  STATUS = mls_sfend(l1bInfo%L1BOAID, hdfVersion=LEVEL1_HDFVERSION)
     STATUS = mls_io_gen_closeF('hg', l1bInfo%L1BOAID, &
           & hdfVersion=LEVEL1_HDFVERSION)
    end if

d77 2
a78 1
  subroutine OpenAndInitialize ( processingRange, l1bInfo )
a84 1
    use Hdf, only: DFACC_READ   ! , SFSTART, SFEND
d87 2
a88 1
    use MLSFiles, only: mls_io_gen_openF, mls_hdf_version
d90 1
a90 1
      &                   MAXNUML1BRADIDS, ILLEGALL1BRADID
d113 2
a114 1
    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
a133 1
    integer(i4)                  :: ErrType
d135 3
a137 3
    integer                      :: L1FileHandle, L1_Version
    character (len=fileNameLen)  :: L1physicalFilename
    integer(i4)                  :: record_length
a138 1
    integer                      :: Sd_id
d147 1
a147 1
    integer                      :: the_hdf_version, l1bFlag
d193 4
d215 1
d217 10
d229 48
a276 48
    L1_Version = 1

      returnStatus = Pgs_pc_getReference(L1FileHandle, L1_Version, &
        & L1physicalFilename)

      if ( returnStatus == PGS_S_SUCCESS ) then

        ! Open the HDF file and initialize the SD interface

        ! Allocate L1BRADIDs, initialize them to illegal values

      if(.NOT. associated(l1bInfo%L1BRADIDs)) then
        allocate ( l1bInfo%L1BRADIDs(MAXNUML1BRADIDS), stat=status )
        allocate ( l1bInfo%L1BRADFileNames(MAXNUML1BRADIDS), stat=status )
        l1bInfo%L1BRADIDs = ILLEGALL1BRADID
        if ( status /= 0 ) &
          & call announce_error ( 0, 'Allocation failed for L1BRADIDs' )
        allocate ( L2pcf%L1BRADPCFIds(MAXNUML1BRADIDS), stat=status )
        L2pcf%L1BRADPCFIds = ILLEGALL1BRADID
        if ( status /= 0 ) &
          & call announce_error ( 0, 'Allocation failed for L1BRADPCFIDs' )
      end if
  ! ((( This will have to change if we wish to convert l1 files to hdf5
  !          Maybe put another wrapper in MSLFiles
  !    sd_id = sfstart(L1physicalFilename, DFACC_READ)
  !    sd_id = mls_sfstart(L1physicalFilename, DFACC_READ, &
  !       hdfVersion=LEVEL1_HDFVERSION)
        the_hdf_version = mls_hdf_version(L1PhysicalFileName)
       sd_id = mls_io_gen_openF('hg', caseSensitive, ErrType, &
         & record_length, DFACC_READ, &
         & L1physicalFilename, hdfVersion=LEVEL1_HDFVERSION)
        if ( sd_id <= 0 ) then
          call announce_error ( 0, &
            & 'Error opening L1RAD file: ' //L1physicalFilename)
        elseif(ifl1 == MAXNUML1BRADIDS) then
          call announce_error ( 0, "Cannot open any more L1BRAD files" )
          exit
        else
          ifl1 = ifl1 + 1
          L2pcf%L1BRADPCFIds(ifl1) = L1FileHandle
          l1bInfo%L1BRADIDs(ifl1) = sd_id
          l1bInfo%L1BRADFileNames(ifl1) = L1physicalFilename
          if(index(switches, 'pro') /= 0) then  
            call announce_success(L1physicalFilename, 'l1brad', &                   
            & hdfVersion=the_hdf_version)                    
          end if
        end if
      end if
d284 10
a293 5
    l1bInfo%L1BOAID = ILLEGALL1BRADID
    L1_Version = 1
    returnStatus = Pgs_pc_getReference(mlspcf_l1b_oa_start, L1_Version, &
      & L1physicalFilename)

d298 4
a301 4
        the_hdf_version = mls_hdf_version(L1PhysicalFileName)
       sd_id = mls_io_gen_openF('hg', caseSensitive, ErrType, &
         & record_length, DFACC_READ, &
         & L1physicalFilename, hdfVersion=LEVEL1_HDFVERSION)
d303 4
a306 4
      if ( sd_id <= 0 ) then

        call announce_error ( 0, "Error opening L1OA file "//L1physicalFilename )
      else
d308 2
a309 2
        l1bInfo%L1BOAID = sd_id
        l1bInfo%L1BOAFileName = L1physicalFilename
d311 2
a312 2
          call announce_success(L1physicalFilename, 'l1boa', &                     
          & hdfVersion=the_hdf_version)                    
d314 1
d319 2
a320 2
        call ReadL1BAttribute(l1bInfo%L1BOAID, OrbNum, 'OrbitNumber', &
	   & l1bFlag, hdfVersion=the_hdf_version)
d326 2
a327 2
        call ReadL1BAttribute(l1bInfo%L1BOAID, OrbPeriod, 'OrbitPeriod', &
	   & l1bFlag, hdfVersion=the_hdf_version)
a332 1
      end if
d342 1
a342 2
    GlobalAttributes%LastMAFCtr = FindMaxMAF ( (/l1bInfo%L1BOAID/), &
      & the_hdf_version, &
d493 1
a493 1
        & call Dump_open_init ( ifl1, l1binfo, &
d539 1
a539 1
  subroutine Dump_open_init ( Num_l1b_files, L1binfo, &
d553 1
a553 1
    use MLSFiles, only: HDFVERSION_4, mls_hdf_version       
a554 1
    use MLSL2Options, only: ILLEGALL1BRADID, LEVEL1_HDFVERSION
d558 3
a560 2
    integer, intent(in) :: num_l1b_files
    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
d575 1
d581 1
d584 1
a584 1
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)  
d590 5
a594 4
   if(associated(l1bInfo%L1BRADIDs)) then
    if ( num_l1b_files > 0 ) then
      do i = 1, num_l1b_files
        if(l1bInfo%L1BRADIDs(i) /= ILLEGALL1BRADID) then
d596 1
d598 1
a598 1
	        call output ( l2pcf%L1BRADPCFIds(i), advance='yes' )
d600 2
d603 1
a603 1
	      call output ( l1bInfo%L1BRADIDs(i), advance='yes' )
d605 1
a605 1
    	   call output ( TRIM(l1bInfo%L1BRADFileNames(i)), advance='yes' )
d607 1
a607 1
    	   call output ( hdfVersion, advance='yes' )
d610 2
a611 2
           call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1bItemname, L1bDataSet, &
            & NoMAFs, IERR, NeverFail=.true., hdfVersion=hdfVersion )
d622 1
a622 1
           call GetAllHDF5DSNames (l1bInfo%L1BRADIDs(i), '/', l1bitemlist)
d628 2
a629 2
             call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1bItemName, L1bDataSet, &
              & NoMAFs, IERR, NeverFail=.true., hdfVersion=hdfVersion )
a640 1
         end if
d642 13
a654 1
      end do
a655 3
    else
      call output ( '(empty database)', advance='yes' )
    end if
a661 13
    call output ( 'L1OA file:', advance='yes' )
  
   if(l1bInfo%L1BOAID /= ILLEGALL1BRADID) then
      call output ( 'PCFid:   ' )
      call output ( l2pcf%L1BOAPCFId, advance='yes' )
      call output ( 'fileid:   ' )
      call output ( l1bInfo%L1BOAID, advance='yes' )
      call output ( 'name:   ' )
      call output ( TRIM(l1bInfo%L1BOAFileName), advance='yes' )
    else
      call output ( '(file unknown)', advance='yes' )
    end if

d767 3
@


2.80
log
@Should not warn about missing switches setting in PCF
@
text
@d12 1
a12 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Warning, &
    &                         MLSMSG_Error
d15 2
a16 3
  use Output_m, only: BLANKS, Output
  use PCFHdr, only: GlobalAttributes, &
    & CreatePCFAnnotation, FillTAI93Attribute
d43 1
a43 1
    "$Id: open_init.f90,v 2.79 2004/08/16 17:14:42 pwagner Exp $"
d784 3
@


2.79
log
@Obtains First,LastMAFCtr global attributes from l1boa file
@
text
@d45 1
a45 1
    "$Id: open_init.f90,v 2.78 2004/08/04 23:19:58 pwagner Exp $"
d54 1
d364 2
a365 2
    print *, 'GlobalAttributes%FirstMAFCtr ', GlobalAttributes%FirstMAFCtr
    print *, 'GlobalAttributes%LastMAFCtr ', GlobalAttributes%LastMAFCtr
d457 6
a462 4
    returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_switches, extra_switches)

    if ( returnstatus == PGS_S_SUCCESS .and. extra_switches /= ' ') then
      switches = catLists(trim(switches), trim(extra_switches))
d786 3
@


2.78
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d10 1
a10 2
  use L1BData, only: ReadL1BAttribute
  use MLSCommon, only: FileNameLen, L1BInfo_T, TAI93_Range_T, R8, i4, NameLen
d13 3
a15 2
    &                         MLSMSG_Error!, MLSMSG_FileOpen, MLSMSG_Info
  use MLSStringLists, only: catLists, utc_to_yyyymmdd
d17 2
a18 1
  use PCFHdr, only: GlobalAttributes
d45 1
a45 1
    "$Id: open_init.f90,v 2.77 2004/06/29 00:10:17 pwagner Exp $"
d123 1
a140 1
    use PCFHdr, only: CreatePCFAnnotation, FillTAI93Attribute
a315 4
  ! ((( This will have to change if we wish to convert l1 files to hdf5
  !          Maybe put another wrapper in MSLFiles
  !  sd_id = sfstart(L1physicalFilename, DFACC_READ)
  !  sd_id = mls_sfstart(L1physicalFilename, DFACC_READ, hdfVersion=LEVEL1_HDFVERSION)
d356 9
d567 5
a571 3
    use L1BData, only: ReadL1BData, L1BData_T, DeallocateL1BData, Dump, &
      & AssembleL1BQtyName
    use MLSFiles, only: mls_hdf_version       
d591 6
a596 2
    integer ::  hdfVersion                                                        
    character(len=NameLen) :: l1bItemName                                        
d619 1
a619 1
         if ( Details > -2 ) then
d632 20
d783 3
@


2.77
log
@Exploit catlist function
@
text
@d15 1
a15 1
  use MLSStrings, only: catLists, utc_to_yyyymmdd
d44 1
a44 1
    "$Id: open_init.f90,v 2.76 2003/10/29 00:07:17 pwagner Exp $"
d751 3
@


2.76
log
@GlobalAttributes%ProcessLevel assigned appropriate value
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d15 1
a15 1
  use MLSStrings, only: utc_to_yyyymmdd
d44 1
a44 1
    "$Id: open_init.f90,v 2.75 2003/10/09 23:41:06 pwagner Exp $"
d453 1
a453 1
      switches = trim(switches) // ',' // trim(extra_switches)
d751 3
@


2.75
log
@Ignore illegal PCFids; extra_switches ,-separated
@
text
@d44 1
a44 1
    "$Id: open_init.f90,v 2.74 2003/09/12 16:28:56 cvuu Exp $"
d219 1
d751 3
@


2.74
log
@Read OrbitNumber and OrbitPeriod attributes from L1BOA
@
text
@d44 1
a44 1
    "$Id: open_init.f90,v 2.73 2003/07/07 23:50:05 pwagner Exp $"
d154 2
a155 2
    integer, parameter :: CCSDSEndId = 10412    ! Illegal PCFid
    integer, parameter :: CCSDSStartId = 10411    ! Illegal PCFid
d366 4
a369 4
    else if ( returnstatus /= PGS_S_SUCCESS ) then
      returnStatus = pgs_pc_getconfigdata (CCSDSStartId, CCSDSStartTime)
      if ( returnstatus /= PGS_S_SUCCESS ) &
        & call announce_error ( 0, "Could not get CCSDS Start Time" )
d378 1
a378 1
      & call MLSMessage ( MLSMSG_Warning, ModuleName, 'No leap second information' )
d384 4
a387 4
    else if ( returnstatus /= PGS_S_SUCCESS ) then
      returnStatus = pgs_pc_getconfigdata (CCSDSEndId, CCSDSEndTime)
      if ( returnstatus /= PGS_S_SUCCESS ) &
        & call announce_error ( 0, "Could not get CCSDS End Time" )
d451 2
a452 2
    if ( returnstatus == PGS_S_SUCCESS ) then
      switches = trim(switches) // trim(extra_switches)
d750 3
@


2.73
log
@Now uses saved variable L2pcf from writeMetaData
@
text
@d10 2
a11 1
  use MLSCommon, only: FileNameLen, L1BInfo_T, TAI93_Range_T, i4, NameLen
d18 1
d44 1
a44 1
    "$Id: open_init.f90,v 2.72 2003/06/09 22:49:34 pwagner Exp $"
d184 1
a184 1
    integer                      :: the_hdf_version                          
d188 3
d334 18
d750 3
@


2.72
log
@Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
@
text
@d42 1
a42 1
    "$Id: open_init.f90,v 2.71 2003/05/29 17:55:23 pwagner Exp $"
d56 1
a56 1
  subroutine DestroyL1BInfo ( L1BInfo, L2pcf )
d60 1
a60 1
    use WriteMetadata, only: PCFData_T
d63 1
a63 1
    type (PCFData_T) ::                          L2pcf
d112 1
a112 1
  subroutine OpenAndInitialize ( processingRange, l1bInfo, l2pcf )
d142 1
a142 1
    use WriteMetadata, only: PCFData_T, MCFCASESENSITIVE
d148 1
a148 1
    type(PCFData_T) :: l2pcf
d480 1
a480 1
        & call Dump_open_init ( ifl1, l1binfo, l2pcf, &
d526 1
a526 1
  subroutine Dump_open_init ( Num_l1b_files, L1binfo, L2pcf, &
d541 1
a541 1
    use WriteMetadata, only: PCFData_T
d546 1
a546 1
    type(PCFData_T) :: l2pcf
d727 3
@


2.71
log
@Can get name of parallel%stagingFile from PCF
@
text
@d42 1
a42 1
    "$Id: open_init.f90,v 2.70 2003/02/27 21:55:14 pwagner Exp $"
d122 2
a123 3
    use MLSL2Options, only: PUNISH_FOR_INVALID_PCF, PUNISH_FOR_NO_L1BRAD, &
      &                   PUNISH_FOR_NO_L1BOA, PENALTY_FOR_NO_METADATA, &
      &                   PCF, CREATEMETADATA, MAXNUML1BRADIDS, ILLEGALL1BRADID
d195 1
a195 1
    if ( .not.( PCF .and. CREATEMETADATA) ) then
d205 1
a205 1
      if ( PCF .and. CREATEMETADATA ) call announce_error ( 0, DEFAULTANTEXT )
d225 1
a225 1
   if( .not. PCF ) then
d295 1
a295 1
    if ( ifl1 == 0 .AND. PUNISH_FOR_NO_L1BRAD ) &
d331 1
a331 1
    else if ( PUNISH_FOR_NO_L1BOA ) then
d337 1
a337 1
    ! (if PUNISH_FOR_INVALID_PCF is FALSE)
d341 1
a341 1
    if ( returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF ) then
d359 1
a359 1
    if ( returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF ) then
d380 1
a380 1
    if ( returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF ) then
d388 1
a388 1
    if ( returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF ) then
d396 1
a396 1
    if ( returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF ) then
d404 1
a404 1
    if ( returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF ) then
d412 1
a412 1
    if ( returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF ) then
d437 1
a437 1
    if ( returnStatus /= PGS_S_SUCCESS .AND. PUNISH_FOR_INVALID_PCF) then
d727 3
@


2.70
log
@Calls FillTAI93Attribute
@
text
@d42 1
a42 1
    "$Id: open_init.f90,v 2.69 2003/02/01 00:38:33 pwagner Exp $"
d120 1
d136 1
a136 1
      &                MLSPCF_PCF_start
d456 11
d728 3
@


2.69
log
@Defines Global Attributes from user data
@
text
@d42 1
a42 1
    "$Id: open_init.f90,v 2.68 2002/12/11 22:18:48 pwagner Exp $"
d137 1
a137 1
    use PCFHdr, only: CreatePCFAnnotation
d454 1
d716 3
@


2.68
log
@broadened error check on sd_id to any value lt 1
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d14 1
d16 1
d42 1
a42 1
    "$Id: open_init.f90,v 2.67 2002/11/13 01:10:40 pwagner Exp $"
d446 8
d715 3
@


2.67
log
@Actually reads hdf5 radiances
@
text
@d40 1
a40 1
    "$Id: open_init.f90,v 2.66 2002/10/08 17:36:22 pwagner Exp $"
d274 1
a274 1
        if ( sd_id == -1 ) then
d316 1
a316 1
      if ( sd_id == -1 ) then
d559 2
d705 3
@


2.66
log
@Added idents to survive zealous Lahey optimizer
@
text
@d10 1
a10 1
  use MLSCommon, only: FileNameLen, L1BInfo_T, TAI93_Range_T, i4
d40 1
a40 1
    "$Id: open_init.f90,v 2.65 2002/10/03 23:02:48 pwagner Exp $"
d515 4
a518 2
    use MLSL2Options, only: ILLEGALL1BRADID
    use L1BData, only: ReadL1BData, L1BData_T, DeallocateL1BData, Dump
d537 5
a541 1
    ! Begin
d560 3
a562 2
           call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1b_quant_name, L1bDataSet, &
            & NoMAFs, IERR, NeverFail=.true. )
d703 3
@


2.65
log
@Now opens l1b files with mls_io_gen_openF
@
text
@d40 1
a40 1
    "$Id: open_init.f90,v 2.64 2002/09/27 23:47:23 pwagner Exp $"
d43 1
d686 4
d696 3
@


2.64
log
@Now calls mls_io_gen_closeF rather than mls_sfend
@
text
@d10 2
a11 1
  use MLSCommon, only: FileNameLen, L1BInfo_T, TAI93_Range_T
d40 1
a40 1
    "$Id: open_init.f90,v 2.63 2002/08/28 22:28:37 pwagner Exp $"
d45 1
a45 1
  integer, parameter :: LEVEL1_HDFVERSION = 4  ! Until we convert level 1 to hdf5
d117 1
a117 1
    use MLSFiles, only: MLS_sfstart
d119 2
a120 2
      &                      PUNISH_FOR_NO_L1BOA, PENALTY_FOR_NO_METADATA, &
      &                      PCF, CREATEMETADATA, MAXNUML1BRADIDS, ILLEGALL1BRADID
d151 1
d161 21
a181 18
    character(len=CCSDSlen) CCSDSEndTime
    character(len=CCSDSlen) CCSDSStartTime
    integer :: Details   ! How much info about l1b files to dump
    integer :: Ifl1
    integer :: L1FileHandle, L1_Version
    character (len=fileNameLen) :: L1physicalFilename
    integer :: ReturnStatus
    integer :: Sd_id
    integer :: Status, Size ! From allocate

    character (len=fileNameLen) :: name

    character (len=len(switches)) :: extra_switches

    integer :: Indx, Version

    real :: T1, T2                      ! for timing
    logical :: TIMING
d267 6
a272 2
       sd_id = mls_sfstart(L1physicalFilename, DFACC_READ, hdfVersion=LEVEL1_HDFVERSION)

d286 1
a286 1
            & hdfVersion=LEVEL1_HDFVERSION)                    
d309 5
a313 1
     sd_id = mls_sfstart(L1physicalFilename, DFACC_READ, hdfVersion=LEVEL1_HDFVERSION)
d323 2
a324 2
          call announce_success(L1physicalFilename, 'l1brad', &                     
          & hdfVersion=LEVEL1_HDFVERSION)                    
d691 3
@


2.63
log
@Saves PCFids for l1boa, l1brad for input pointer metadata
@
text
@d1 1
a1 1
! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
d19 1
d30 1
d39 1
a39 1
    "$Id: open_init.f90,v 2.62 2002/08/21 02:23:39 vsnyder Exp $"
d55 1
a55 1
    use MLSFiles, only: MLS_sfend
d71 3
a73 1
         STATUS = mls_sfend(l1bInfo%L1BRADIDs(id), hdfVersion=LEVEL1_HDFVERSION)
d92 3
a94 1
     STATUS = mls_sfend(l1bInfo%L1BOAID, hdfVersion=LEVEL1_HDFVERSION)
d678 3
@


2.62
log
@Move USE statements from module scope to procedure scope
@
text
@d37 1
a37 1
    "$Id: open_init.f90,v 2.61 2002/01/26 00:09:14 pwagner Exp $"
d50 1
a50 1
  subroutine DestroyL1BInfo ( L1BInfo )
d52 1
a52 1
    use Global_Settings, only: ILLEGALL1BRADID
d54 1
d57 1
d77 5
a108 1
    use Global_Settings, only: MAXNUML1BRADIDS, ILLEGALL1BRADID
d113 1
a113 1
      &                      PCF, CREATEMETADATA
d248 4
d266 1
d300 1
d495 1
a495 1
    use Global_Settings, only: ILLEGALL1BRADID
d525 4
d561 2
d672 3
@


2.61
log
@Convert hdf routines to mlsfiles equivalents
@
text
@a9 5
  use global_settings, only: MAXNUML1BRADIDS, ILLEGALL1BRADID
  use Hdf, only: DFACC_READ   ! , SFSTART, SFEND
  use L1BData, only: ReadL1BData, L1BData_T, &
    & DeallocateL1BData, Dump
  use LEXER_CORE, only: PRINT_SOURCE
a10 5
  use MLSFiles, only: mls_sfstart, mls_sfend
  use MLSL2Options, only: PUNISH_FOR_INVALID_PCF, PUNISH_FOR_NO_L1BRAD, &
  &                        PUNISH_FOR_NO_L1BOA, PENALTY_FOR_NO_METADATA, &
  &                        PCF, CREATEMETADATA
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
a12 12
  use MLSPCF2, only: MLSPCF_L1B_OA_START, MLSPCF_L1B_RAD_END, &
    &                MLSPCF_L1B_RAD_START, &
    &                mlspcf_l2_param_InputVersion, &
    &                mlspcf_l2_param_PGEVersion, &
    &                mlspcf_l2_param_Cycle, &
    &                mlspcf_l2_param_CCSDSStartId, &
    &                mlspcf_l2_param_CCSDSEndId, &
    &                mlspcf_l2_param_spec_keys, &
    &                mlspcf_l2_param_spec_hash, &
    &                mlspcf_l2_param_switches, &
    &                mlspcf_pcf_start
  use MLSStrings, only: LowerCase
a13 5
  use PCFHdr, only: CreatePCFAnnotation
  use SDPToolkit, only: Pgs_pc_getFileSize, pgs_td_utctotai,&
    &    pgs_pc_getconfigdata, Pgs_pc_getReference, PGS_S_SUCCESS, &
    &    PGSTD_E_NO_LEAP_SECS
  use Time_M, only: Time_Now
a15 2
  use TREE, only: DUMP_TREE_NODE, SOURCE_REF
  use WriteMetadata, only: PCFData_T, MCFCASESENSITIVE
d37 1
a37 1
    "$Id: open_init.f90,v 2.60 2002/01/24 00:14:26 pwagner Exp $"
d51 4
d62 1
a62 1
      do id=1, SIZE(l1bInfo%L1BRADIDs)
d69 2
a70 2
         endif
      enddo
d82 1
a82 1
    endif
d85 2
a86 2
      & call MLSMessage(MLSMSG_Error,ModuleName, &
        & 'Problem with DestroyL1BInfo')
d102 26
d180 1
a180 1
    endif
d211 1
a211 1
     endif
d217 1
a217 1
   endif
d242 1
a242 1
      endif
d261 1
a261 1
          endif
d294 1
a294 1
        endif
d410 1
a410 1
    endif
d424 1
a424 1
   endif
d441 1
a441 1
      endif
d464 1
a464 1
    endif
d483 3
d501 1
a501 1
    type (L1BData_T) :: l1bData   ! L1B dataset
d518 1
a518 1
           call ReadL1BData ( l1bInfo%L1BRADIDs(i), l1b_quant_name, L1bData, &
d521 2
a522 2
             call Dump(l1bData, Details )
             call DeallocateL1BData ( l1bData )
d528 3
a530 3
           endif
         endif
        endif
d540 1
a540 1
   endif
d591 3
d654 3
@


2.60
log
@Proclaims level 1 files as input; comments concerning hdf5 conversion
@
text
@d11 1
a11 1
  use Hdf, only: DFACC_READ, SFSTART, SFEND
d16 1
a16 1
!  use MLSFiles, only: mls_sfstart, mls_sfend
d66 1
a66 1
    "$Id: open_init.f90,v 2.59 2001/12/16 00:57:46 livesey Exp $"
d91 2
a92 2
          STATUS = sfend(l1bInfo%L1BRADIDs(id))
   !      STATUS = mls_sfend(l1bInfo%L1BRADIDs(id), hdfVersion=LEVEL1_HDFVERSION)
d105 2
a106 2
      STATUS = sfend(l1bInfo%L1BOAID)
  !   STATUS = mls_sfend(l1bInfo%L1BOAID, hdfVersion=LEVEL1_HDFVERSION)
d244 2
a245 2
        sd_id = sfstart(L1physicalFilename, DFACC_READ)
  !     sd_id = mls_sfstart(L1physicalFilename, DFACC_READ, hdfVersion=LEVEL1_HDFVERSION)
d258 1
a258 1
            call proclaim(L1physicalFilename, 'l1brad', &                   
d281 2
a282 2
      sd_id = sfstart(L1physicalFilename, DFACC_READ)
  !   sd_id = mls_sfstart(L1physicalFilename, DFACC_READ, hdfVersion=LEVEL1_HDFVERSION)
d291 1
a291 1
          call proclaim(L1physicalFilename, 'l1brad', &                     
d449 2
a450 2
  ! ---------------------------------------------  proclaim  -----
  subroutine proclaim ( Name, l1_type, hdfVersion )
d468 1
a468 1
  end subroutine proclaim
d647 3
@


2.59
log
@Add warning about leap seconds
@
text
@d16 1
d66 1
a66 1
    "$Id: open_init.f90,v 2.58 2001/11/09 23:17:22 vsnyder Exp $"
d71 1
d89 2
d92 2
d103 2
d106 1
d242 2
d245 2
d257 4
d279 2
d282 2
d290 4
d447 23
d647 3
@


2.58
log
@Use Time_Now instead of CPU_TIME
@
text
@d20 1
a20 1
  use MLSMessageModule, only: MLSMessage, &
d65 1
a65 1
    "$Id: open_init.f90,v 2.57 2001/11/01 21:06:17 pwagner Exp $"
d294 2
d599 3
@


2.57
log
@Fixed if block; added toc
@
text
@d39 1
d65 1
a65 1
    "$Id: open_init.f90,v 2.56 2001/10/30 00:33:24 pwagner Exp $"
d158 1
a158 1
    if ( timing ) call cpu_time ( t1 )
d408 1
a408 1
      call cpu_time ( t2 )
d597 3
@


2.56
log
@Renamed Dump_L1B_database Dump_open_init; switches now checked for pcf[n]
@
text
@d45 12
d64 1
a64 1
    "$Id: open_init.f90,v 2.55 2001/10/25 23:33:59 pwagner Exp $"
a121 1
!    integer, external :: Pgs_pc_getFileSize
a153 1
!    integer :: pgs_td_utctotai, pgs_pc_getconfigdata
d164 6
a169 6
   if ( .not.( PCF .and. CREATEMETADATA) ) then
      Status = PGS_S_SUCCESS - 1
   else
    version = 1
    Status = Pgs_pc_getFileSize(mlspcf_pcf_start, version, size)
   endif
d195 11
a205 11
      if ( levels(gen) > 0 .or. index(switches,'pcf') /= 0 ) &
!        & call dump_L1B_database &
!        & ( mlspcf_l1b_rad_end-mlspcf_l1b_rad_start+1, l1binfo, l2pcf, &
!          & CCSDSEndTime, CCSDSStartTime, processingrange )
      call output('======== No parameters or radiances read :: no pcf ========', advance='yes')
      call output('========   (These must supplied through the l2cf)  ========', advance='yes')
    if ( toggle(gen) ) then
      call trace_end ( "OpenAndInit" )
    end if
    if ( timing ) call sayTime
    return
d276 1
a371 1
!    mlspcf_log = 10101			! This seems to be hard-wired into PCF
d399 5
a403 5
    if ( toggle(gen) ) then
      call trace_end ( "OpenAndInit" )
    end if
    if ( timing ) call sayTime
    return
d596 3
@


2.55
log
@Initializes InputVersion, PGEVersion to blank
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d12 2
d52 1
a52 1
    "$Id: open_init.f90,v 2.54 2001/09/28 23:59:20 pwagner Exp $"
d127 1
d171 2
a172 1
! Initialize run parameters: unless reset, these dtermine how to run
d185 1
a185 2
    if ( toggle(gen) ) then
      if ( levels(gen) > 0 .or. index(switches,'O') /= 0 ) &
d191 1
d377 12
a389 3
      if ( levels(gen) > 0 .or. index(switches,'O') /= 0 ) &
        & call dump_L1B_database ( ifl1, l1binfo, l2pcf, &
          & CCSDSEndTime, CCSDSStartTime, processingrange )
d409 3
a411 3
  ! ------------------------------------------  Dump_L1B_database  -----
  subroutine Dump_L1B_database ( Num_l1b_files, L1binfo, L2pcf, &
    & CCSDSEndTime, CCSDSStartTime, processingrange )
d429 1
d433 1
a433 1
    integer :: i
d435 2
d439 3
d447 4
a450 4
      if(l1bInfo%L1BRADIDs(i) /= ILLEGALL1BRADID) then
  	    call output ( 'fileid:   ' )
	    call output ( l1bInfo%L1BRADIDs(i), advance='yes' )
      	call output ( 'name:   ' )
d452 14
a465 1
      endif
d521 1
a521 1
  end subroutine dump_L1B_database
d586 3
@


2.54
log
@Fixed various timing problems
@
text
@d50 1
a50 1
    "$Id: open_init.f90,v 2.53 2001/08/09 00:23:05 pwagner Exp $"
d55 1
d57 1
a57 1
  integer, private :: ERROR
d136 1
a136 1
    integer :: Indx, Mlspcf_log, Version
d174 2
d357 1
a357 1
    mlspcf_log = 10101			! This seems to be hard-wired into PCF
d359 1
a359 1
    returnStatus = Pgs_pc_getReference(mlspcf_log, version, name)
d554 3
@


2.53
log
@pcf param for extra switches added; read
@
text
@d17 1
d32 1
a32 1
  use Output_m, only: Output
d50 1
a50 1
    "$Id: open_init.f90,v 2.52 2001/05/24 20:34:50 pwagner Exp $"
d137 2
d141 4
d187 1
d376 1
d379 12
d551 3
@


2.52
log
@More forgiving of faulty pcf
@
text
@d28 1
d49 1
a49 1
    "$Id: open_init.f90,v 2.51 2001/05/17 22:31:54 pwagner Exp $"
d132 2
d334 9
d530 3
@


2.51
log
@Simpler info instead of bogus dump if no pcf
@
text
@d48 1
a48 1
    "$Id: open_init.f90,v 2.50 2001/05/17 00:27:55 pwagner Exp $"
d337 8
a344 5
    if ( returnStatus /= PGS_S_SUCCESS ) &
      & call announce_error ( 0, "Error retrieving log file name from PCF" )

    indx = INDEX(name, '/', .TRUE.)
    l2pcf%logGranID = name(indx+1:)
d518 3
@


2.50
log
@Better defaults, dumps
@
text
@d48 1
a48 1
    "$Id: open_init.f90,v 2.49 2001/05/11 23:43:35 pwagner Exp $"
d169 6
a174 4
      if ( levels(gen) > 0 .or. index(switches,'ope') /= 0 ) &
        & call dump_L1B_database &
        & ( mlspcf_l1b_rad_end-mlspcf_l1b_rad_start+1, l1binfo, l2pcf, &
          & CCSDSEndTime, CCSDSStartTime, processingrange )
d515 3
@


2.49
log
@Added some initializations
@
text
@d48 1
a48 1
    "$Id: open_init.f90,v 2.48 2001/05/10 18:22:57 pwagner Exp $"
a73 2
        ! call MLSMessage ( MLSMSG_Error, ModuleName, &
        !   & MLSMSG_DeAllocate // "l1bInfo" )
d82 4
d160 3
a162 1
   l2pcf%cycle = '(undefined)'
a233 2
!        call MLSMessage ( MLSMSG_Error, ModuleName, &
!          & "Error opening L1OA file "//L1physicalFilename )
d378 1
a378 2
    character (LEN=FileNameLen) :: physicalFilename
    integer :: i, returnStatus, version
a381 2
    version = 1

a386 2
!        returnStatus = Pgs_pc_getReference(l1bInfo%L1BRADIDs(i), version, &
!        & physicalFilename)
d427 3
d513 3
@


2.48
log
@Improved Dump_L1B_database
@
text
@d48 1
a48 1
    "$Id: open_init.f90,v 2.47 2001/05/09 23:32:15 pwagner Exp $"
d155 7
a161 2
   CCSDSStartTime = ' '
   CCSDSEndTime = ' '
d165 1
a165 1
      if ( levels(gen) > 0 .or. index(switches,'O') /= 0 ) &
d513 3
@


2.47
log
@Gets toolkit funs from SDPToolkit
@
text
@d48 1
a48 1
    "$Id: open_init.f90,v 2.46 2001/05/07 23:28:19 pwagner Exp $"
d163 1
a163 1
          & CCSDSEndTime, CCSDSStartTime )
d341 1
a341 1
          & CCSDSEndTime, CCSDSStartTime )
d350 1
a350 1
    & CCSDSEndTime, CCSDSStartTime )
d367 1
d373 1
d404 1
a404 3
!    returnStatus = Pgs_pc_getReference(l1bInfo%L1BOAID, version, &
!      & physicalFilename)
!    if ( returnStatus == PGS_S_SUCCESS ) then
d409 3
a411 3
!    else
!      call output ( '(file unknown)', advance='yes' )
!    end if
d416 1
a416 1
    call output ( 'End Time:   ' )
d419 6
d508 3
@


2.46
log
@Fixed dump..
@
text
@d32 3
a34 3
  use SDPToolkit, only: &
    &                   Pgs_pc_getReference, PGS_S_SUCCESS, &
    &                   PGSTD_E_NO_LEAP_SECS
d48 1
a48 1
    "$Id: open_init.f90,v 2.45 2001/05/06 20:55:25 pwagner Exp $"
d103 1
a103 1
    integer, external :: Pgs_pc_getFileSize
d131 1
a131 1
    integer :: pgs_td_utctotai, pgs_pc_getconfigdata
d502 3
@


2.45
log
@[De]Allocates l1binfo%filenames along with ids
@
text
@d48 1
a48 1
    "$Id: open_init.f90,v 2.44 2001/05/04 22:56:40 pwagner Exp $"
d161 2
a162 1
        & call dump_L1B_database ( ifl1, l1binfo, l2pcf, &
d378 1
d383 6
a388 4
  	call output ( 'fileid:   ' )
	call output ( l1bInfo%L1BRADIDs(i), advance='yes' )
  	call output ( 'name:   ' )
  	call output ( TRIM(l1bInfo%L1BRADFileNames(i)), advance='yes' )
d390 1
d395 5
d404 1
a404 1
    if ( returnStatus == PGS_S_SUCCESS ) then
d409 3
a411 3
    else
      call output ( '(file unknown)', advance='yes' )
    end if
d502 3
@


2.44
log
@Detachable from Toolkit
@
text
@d48 1
a48 1
    "$Id: open_init.f90,v 2.43 2001/05/04 17:09:03 pwagner Exp $"
d72 1
a72 1
      deallocate( l1bInfo%L1BRADIDs, stat=status )
d76 1
a76 1
        call announce_error ( 0, 'Error deallocating L1BRADIDs' )
d187 1
d492 3
@


2.43
log
@Get MAXNUML1BRADIDS, ILLEGALL1BRADID from global_settings
@
text
@d15 2
a16 1
  &                        PUNISH_FOR_NO_L1BOA, PENALTY_FOR_NO_METADATA
d48 1
a48 1
    "$Id: open_init.f90,v 2.42 2001/04/20 18:16:29 pwagner Exp $"
d138 3
d143 2
d148 1
a148 1
      call announce_error ( 0, DEFAULTANTEXT )
d155 13
d201 1
d228 1
d378 2
a379 2
        returnStatus = Pgs_pc_getReference(l1bInfo%L1BRADIDs(i), version, &
        & physicalFilename)
d383 1
a383 1
  	call output ( TRIM(physicalFilename), advance='yes' )
d391 2
a392 2
    returnStatus = Pgs_pc_getReference(l1bInfo%L1BOAID, version, &
      & physicalFilename)
d397 1
a397 1
      call output ( TRIM(physicalFilename), advance='yes' )
d491 3
@


2.42
log
@Added sfend on L1B files to DESTROYL1BInfo
@
text
@d10 1
d47 1
a47 1
    "$Id: open_init.f90,v 2.41 2001/04/19 23:51:40 pwagner Exp $"
a52 2
  integer, parameter :: ILLEGALL1BRADID=-1      ! something sfstart should catch
  integer, parameter :: MAXNUML1BRADIDS=10      ! In case more than one
d176 3
d470 3
@


2.41
log
@Moved anText to become component of PCFData_T
@
text
@d10 1
a10 1
  use Hdf, only: DFACC_READ, SFSTART
d46 1
a46 1
    "$Id: open_init.f90,v 2.40 2001/04/18 17:33:29 vsnyder Exp $"
d52 2
d62 1
d64 2
d67 5
d79 8
d165 1
a165 1
        ! Allocate L1BRADIDs
d167 3
a169 1
        allocate ( l1bInfo%L1BRADIDs(10), stat=status )
d172 1
a172 1

d189 1
d468 3
@


2.40
log
@I forgot what I REALLY did, but I also made numerous cosmetic changes
@
text
@d46 1
a46 1
    "$Id: open_init.f90,v 1.11 2000/06/19 22:40:51 lungu Exp $"
d73 1
a73 1
  subroutine OpenAndInitialize ( processingRange, l1bInfo, l2pcf, anText )
a84 1
    character (len=1), pointer :: AnText(:)
d123 1
a123 1
      call createPCFAnnotation(mlspcf_pcf_start, anText)
d127 2
a128 2
      allocate ( anText(size), STAT=Status )
      anText(1:size-1) = DEFAULTANTEXT(1:size-1)
d447 3
@


2.39
log
@Gets penalty settings from MLSL2Options
@
text
@d27 3
a29 3
  USE MLSStrings, only: LowerCase
  USE output_m, only: output
  USE PCFHdr, only: CreatePCFAnnotation
d35 1
a35 2
  use TREE, only: &
    &             DUMP_TREE_NODE, SOURCE_REF
a43 1
  private :: Id, ModuleName
d45 3
a47 2
  character(len=130) :: id = &
    "$id: open_init.f90,v 1.11 2000/06/19 22:40:51 lungu Exp $"
d51 1
a51 1
    integer, parameter :: CCSDSLen=27
d61 8
a68 8
    if (associated(l1bInfo%L1BRADIDs)) then
       deallocate( l1bInfo%L1BRADIDs, stat=status )
       if ( status /= 0 ) then
		 !	call MLSMessage ( MLSMSG_Error, ModuleName, &
       !     & MLSMSG_DeAllocate // "l1bInfo" )
		call announce_error(0, 'Error deallocating L1BRADIDs')
    endif
    endif
d84 3
a86 3
	 type(PCFData_T) :: l2pcf
    CHARACTER (LEN=1), POINTER :: anText(:)
	 integer, external :: Pgs_pc_getFileSize
d95 1
a95 1
	 & 'PCF file number missing from PCF--add this line'
d97 1
a97 1
	 & 'temp,gph,h2o,hno3,o3,hcl,clo,co,n2o,oh,rhi,so2,ho2,bro,hocl,hcn,cirrus-ice,others'
d99 1
a99 1
	 & 't,z,h2o,hno3,o3,hcl,clo,co,n2o,oh,rhi,so2,ho2,bro,hocl,hcn,ice,oth'
d103 1
a103 1
    integer :: ifl1
d105 4
a108 4
    character (LEN=FileNameLen) :: L1physicalFilename
    integer :: returnStatus
    integer :: sd_id
    integer :: STATUS, size ! From allocate
d110 1
a110 1
      CHARACTER (LEN=FileNameLen) :: name
d112 1
a112 1
      INTEGER ::  indx, mlspcf_log, version
d121 11
a131 12
      version = 1
      Status = Pgs_pc_getFileSize(mlspcf_pcf_start, version, size)
		if(Status == PGS_S_SUCCESS) then
	      CALL CreatePCFAnnotation(mlspcf_pcf_start, anText)
		else
			call announce_error(0, &
			& DEFAULTANTEXT)
			size = LEN(DEFAULTANTEXT) + 1
     		 ALLOCATE(anText(size), STAT=Status)
			anText(1:size-1) = DEFAULTANTEXT(1:size-1)
         error=PENALTY_FOR_NO_METADATA
		endif
d144 1
a144 1
      if (returnStatus == PGS_S_SUCCESS) then
d150 3
a152 4
        allocate( l1bInfo%L1BRADIDs(10), stat=status )
        if ( status /= 0 ) then
			call announce_error(0, 'Allocation failed for L1BRADIDs')
			endif
d155 3
a157 3
        if (sd_id == -1) then
				call announce_error(0, &
				& 'Error opening L1RAD file: ' //L1physicalFilename)
d165 2
a166 3
    if (ifl1 == 0 .AND. PUNISH_FOR_NO_L1BRAD) then
      call announce_error(0, "Could not find any L1BRAD files" )
   endif
d174 1
a174 1
    if (returnStatus == PGS_S_SUCCESS) then
d179 1
a179 1
      if (sd_id == -1) then
d183 1
a183 1
			call announce_error(0, "Error opening L1OA file "//L1physicalFilename )
d188 2
a189 4
    elseif(PUNISH_FOR_NO_L1BOA) then

			call announce_error(0, "Could not find L1BOA file" )

d195 5
a199 5
   returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_CCSDSStartId, &
                                          CCSDSStartTime)
   if(returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF) then
      call announce_error(0, "Missing pcf param: CCSDSStartTime" )
   elseif(returnstatus /= PGS_S_SUCCESS) then
d201 3
a203 4
      if ( returnstatus /= PGS_S_SUCCESS ) then
			call announce_error(0, "Could not get CCSDS Start Time" )
   	endif
	endif
d208 2
a209 3
      &  returnstatus /= PGSTD_E_NO_LEAP_SECS ) then
			call announce_error(0, "Could not convert UTC Start time to TAI" )
	endif
d213 7
a219 8
   if(returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF) then
      call announce_error(0, "Missing pcf param: CCSDSEndTime" )
   elseif(returnstatus /= PGS_S_SUCCESS) then
    returnStatus = pgs_pc_getconfigdata (CCSDSEndId, CCSDSEndTime)
    if ( returnstatus /= PGS_S_SUCCESS ) then
			call announce_error(0, "Could not get CCSDS End Time" )
   	endif
	endif
d224 2
a225 3
      & returnstatus /= PGSTD_E_NO_LEAP_SECS) then
			call announce_error(0, "Could not convert UTC End time to TAI" )
	endif
d227 2
a228 2
	l2pcf%startutc = CCSDSStartTime
	l2pcf%endutc = CCSDSEndTime
d230 1
a230 1
	! Here's where we define the non-time components of l2pcf
d232 1
a232 1
      returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_inputVersion, &
d234 5
a238 5
   if(returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF) then
			call announce_error(0, "Missing pcf param: input version" )
   elseif(returnstatus /= PGS_S_SUCCESS) then
	   l2pcf%inputVersion = 'V0-5'
   endif
d240 1
a240 1
      returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_PGEVersion, &
d242 5
a246 5
   if(returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF) then
			call announce_error(0, "Missing pcf param: output version" )
   elseif(returnstatus /= PGS_S_SUCCESS) then
	   l2pcf%PGEVersion = 'V0-5'
   endif
d248 1
a248 1
      returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_Cycle, l2pcf%cycle)
d250 5
a254 5
   if(returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF) then
			call announce_error(0, "Missing pcf param: cycle" )
   elseif(returnstatus /= PGS_S_SUCCESS) then
   	l2pcf%cycle = '1'
   endif
d256 1
a256 1
      returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_spec_keys, l2pcf%spec_keys)
d258 5
a262 5
   if(returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF) then
			call announce_error(0, "Missing pcf param: spec_keys" )
   elseif(returnstatus /= PGS_S_SUCCESS) then
   	l2pcf%spec_keys = DEFAULT_SPEC_KEYS
   endif
d264 1
a264 1
      returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_spec_hash, l2pcf%spec_hash)
d266 5
a270 5
   if(returnstatus /= PGS_S_SUCCESS .and. PUNISH_FOR_INVALID_PCF) then
			call announce_error(0, "Missing pcf param: spec_hash" )
   elseif(returnstatus /= PGS_S_SUCCESS) then
   	l2pcf%spec_hash = DEFAULT_SPEC_HASH
   endif
d272 4
a275 4
   if(.NOT. MCFCASESENSITIVE) then
   	l2pcf%spec_hash = LowerCase(l2pcf%spec_hash)
   	l2pcf%spec_keys = LowerCase(l2pcf%spec_keys)
   endif
d279 2
a280 2
      version = 1
      mlspcf_log = 10101			! This seems to be hard-wired into PCF
d282 3
a284 4
      returnStatus = Pgs_pc_getReference(mlspcf_log, version, name)
      IF (returnStatus /= PGS_S_SUCCESS) then
			call announce_error(0, "Error retrieving log file name from PCF" )
	endif
d286 2
a287 2
      indx = INDEX(name, '/', .TRUE.)
      l2pcf%logGranID = name(indx+1:)
d289 3
a291 4
    if (ERROR/=0 ) then
	 	call MLSMessage(MLSMSG_Error,ModuleName, &
      & 'Problem with open_init section')
	end if
d294 3
a296 3
      if ( levels(gen) > 0 .or. index(switches,'C') /= 0 ) &
        & call dump_L1B_database(ifl1, l1binfo, l2pcf, &
  			& CCSDSEndTime, CCSDSStartTime)
d303 3
a305 3
  ! -------------------------------------------------  dump_L1B_database  -----
  subroutine dump_L1B_database(num_l1b_files, l1binfo, l2pcf, &
  & CCSDSEndTime, CCSDSStartTime)
d307 7
a313 7
  ! Dump info obtained during OpenAndInitialize:
  ! L1B databse
  ! L1OA file
  ! Start and end times
  ! output version
  ! cycle number
  ! logfile name
d316 2
a317 2
	! Arguments
	integer, intent(in) :: num_l1b_files
d319 1
a319 1
	 type(PCFData_T) :: l2pcf
d323 1
a323 1
	! Local
d326 1
a326 1
	integer :: i, returnStatus, version
d328 2
a329 2
	! Begin
	version = 1
d331 1
a331 1
  call output('L1B database:', advance='yes')
d333 3
a335 3
if(num_l1b_files > 0) then
  do i=1, num_l1b_files
    returnStatus = Pgs_pc_getReference(l1bInfo%L1BRADIDs(i), version, &
d337 8
a344 8
  	call output('fileid:   ')
	call output(l1bInfo%L1BRADIDs(i), advance='yes')
  	call output('name:   ')
  	call output(TRIM(physicalFilename), advance='yes')
  enddo
else
  	call output('(empty database)', advance='yes')
endif
d346 1
a346 1
  call output('L1OA file:', advance='yes')
d349 24
a372 24
        & physicalFilename)
if(returnStatus == PGS_S_SUCCESS) then
  	call output('fileid:   ')
	call output(l1bInfo%L1BOAID, advance='yes')
  	call output('name:   ')
  	call output(TRIM(physicalFilename), advance='yes')
else
  	call output('(file unknown)', advance='yes')
endif

  	call output('Start Time:   ')
	call output(CCSDSStartTime, advance='yes')

  	call output('End Time:   ')
	call output(CCSDSEndTime, advance='yes')

  	call output('PGE version:   ')
	call output(l2pcf%PGEVersion, advance='yes')

  	call output('input version:   ')
	call output(l2pcf%InputVersion, advance='yes')

  	call output('cycle:   ')
	call output(l2pcf%cycle, advance='yes')
d374 2
a375 2
  	call output('Log file name:   ')
  	call output(TRIM(l2pcf%logGranID), advance='yes')
d377 2
a378 2
  	call output('l2gp species name keys:   ')
  	call output(TRIM(l2pcf%spec_keys), advance='yes')
d380 2
a381 2
  	call output('corresponding mcf hash:   ')
  	call output(TRIM(l2pcf%spec_hash), advance='yes')
d385 3
a387 3
  ! ------------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( lcf_where, full_message, use_toolkit, &
    & error_number )
d448 3
@


2.38
log
@Makes l2pcf hash, keys lowercase if not MCFCASESENSITIVE
@
text
@d13 2
d26 1
a26 1
    &                mlspcf_pcf_start, PENALTY_FOR_NO_METADATA
a54 7
  ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  ! Set the following to TRUE before delivering level 2 to sids
  logical, private :: PUNISH_FOR_INVALID_PCF=.FALSE.  ! set to true
  logical, private :: PUNISH_FOR_NO_L1BRAD=.FALSE.  ! set to true
  logical, private :: PUNISH_FOR_NO_L1BOA=.FALSE.  ! set to true
  ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

a293 2
		!	CALL MLSMessage(MLSMSG_Error, &
      !                  ModuleName, 'Error retrieving log file name from PCF.')
d412 2
a413 2
    just_print_it = default_output_by_toolkit
    if ( present(use_toolkit) ) just_print_it = use_toolkit
d460 3
@


2.37
log
@With new PCF params
@
text
@d25 1
d35 1
a35 1
  use WriteMetadata, only: PCFData_T
d103 1
a103 1
	 & 'temp,gph,h2o,hno3,o3,hcl,clo,n2o,oh,rhi,so2,ho2,bro,hocl,hcn,cirrus-ice,others'
d105 1
a105 1
	 & 't,z,h2o,hno3,o3,hcl,clo,n2o,oh,rhi,so2,ho2,bro,hocl,hcn,ice,oth'
d287 5
d467 3
@


2.36
log
@Add advance='yes' to final output in Announce_Error
@
text
@d13 1
a13 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
d17 7
d25 4
a28 3
  use Output_m, only: Output
  use PCFHdr, only: CreatePCFAnnotation
  use SDPToolkit, only: Pgs_pc_getReference, PGS_S_SUCCESS, &
d32 2
a33 1
  use TREE, only: SUBTREE, DUMP_TREE_NODE, SOURCE_REF
d40 3
d44 3
a46 5
  character(len=*), private, parameter :: IdParm = &
    "$Id: open_init.f90,v 1.11 2000/06/19 22:40:51 lungu Exp $"
  character(len=len(idParm)), private :: Id = idParm
  character(len=*), parameter, private :: ModuleName = &
    & "$RCSfile: open_init.f90,v $"
d49 1
a49 1
  integer, parameter, private :: CCSDSLen = 27
d51 7
d66 2
a67 2
    if ( associated(l1bInfo%L1BRADIDs) ) then
       deallocate ( l1bInfo%L1BRADIDs, stat=status )
d69 5
a73 5
       ! call MLSMessage ( MLSMSG_Error, ModuleName, &
       !   & MLSMSG_DeAllocate // "l1bInfo" )
         call announce_error ( 0, 'Error deallocating L1BRADIDs' )
      end if
    end if
d76 1
d87 5
a91 10
    !??? Specify intents for non-pointer dummy arguments ???
    type(TAI93_Range_T) :: ProcessingRange   ! Data processing range
    type(L1BInfo_T) :: L1bInfo               ! File handles etc. for L1B dataset
    type(PCFData_T) :: L2pcf                 !??? What is it ???
    character (len=1), pointer :: AnText(:)  !??? What is it ???

    !??? Are there interfaces defined for these somewhere ???
    integer, external :: PGS_pc_getConfigData
    integer, external :: Pgs_pc_getFileSize
    integer, external :: PGS_td_utctotai
d95 10
a104 4
    integer, parameter :: CCSDSEndId = 10412
    integer, parameter :: CCSDSStartId = 10411
    character(len=*), parameter :: DefaultAnText = &
      & 'PCF file number missing from PCF--add this line'
a105 1
    !??? Specify what the variables are used for ???
d108 1
a108 2
    integer :: Ifl1
    integer :: Indx
d110 10
a119 8
    character (len=FileNameLen) :: L1physicalFilename
    integer :: Mlspcf_log
    character (len=FileNameLen) :: Name
    integer :: ReturnStatus
    integer :: SD_id
    integer :: Size
    integer :: Status ! From allocate or PGS...
    integer :: Version
a123 3
    if ( DEBUG ) call announce_error ( 0, &
      & 'Read the PCF into an annotation for file headers' )

d126 12
a137 11
    version = 1
    status = Pgs_pc_getFileSize(mlspcf_pcf_start, version, size)
    if ( Status == PGS_S_SUCCESS ) then
      call createPCFAnnotation(mlspcf_pcf_start, anText)
    else
      call announce_error ( 0, defaultAnText )
      size = len(defaultAnText) + 1
      allocate ( anText(size), STAT=Status )
      anText(1:size-1) = defaultAnText(1:size-1)
      error = PENALTY_FOR_NO_METADATA
    end if
a140 2
    if ( DEBUG ) call announce_error ( 0, 'Opening L1 RAD files' )

d144 2
a145 2
      ! Get the l1 file name from the PCF
      L1_Version = 1
d150 1
a150 1
      if ( returnStatus == PGS_S_SUCCESS ) then
d156 1
a156 1
        allocate ( l1bInfo%L1BRADIDs(10), stat=status )
d158 2
a159 4
!         call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & MLSMSG_Allocate // "l1bInfo" )
          call announce_error ( 0, 'Allocation failed for L1BRADIDs' )
        end if
d162 3
a164 5
        if ( sd_id == -1 ) then
!          call MLSMessage ( MLSMSG_Error, ModuleName, &
!            & "Error opening L1RAD file "//L1physicalFilename )
          call announce_error ( 0, &
            & 'Error opening L1RAD file: ' // L1physicalFilename )
d172 3
a174 2
    !if ( ifl1 == 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !  & "Could not find any L1BRAD files" )
a175 1
    if ( DEBUG ) call announce_error ( 0, 'Opening LOA file' )
d182 1
a182 1
    if ( returnStatus == PGS_S_SUCCESS ) then
d187 1
a187 1
      if ( sd_id == -1 ) then
d191 1
a191 2
        call announce_error ( 0, &
          & "Error opening L1OA file " // L1physicalFilename )
d196 1
a196 1
    else
d198 1
a198 2
!      call MLSMessage ( MLSMSG_Error, ModuleName, "Could not find L1BOA file" )
      call announce_error ( 0, "Could not find L1BOA file" )
d203 1
d205 10
a214 6
    returnStatus = pgs_pc_getconfigdata (CCSDSStartId, CCSDSStartTime)
    if ( returnstatus /= PGS_S_SUCCESS ) then
      ! call MLSMessage ( MLSMSG_Error, &
      !   & ModuleName, "Could not get CCSDS Start Time" )
      call announce_error ( 0, "Could not get CCSDS Start Time" )
    end if
d220 2
a221 4
    ! call MLSMessage ( MLSMSG_Error, &
    !   & ModuleName, "Could not convert UTC Start time to TAI" )
      call announce_error ( 0, "Could not convert UTC Start time to TAI" )
    end if
d223 5
d230 3
a232 4
    ! call MLSMessage ( MLSMSG_Error, &
    !  & ModuleName, "Could not get CCSDS End Time" )
      call announce_error ( 0, "Could not get CCSDS End Time" )
    end if
d237 50
a286 19
      & returnstatus /= PGSTD_E_NO_LEAP_SECS ) then
    ! call MLSMessage ( MLSMSG_Error, &
    !   & ModuleName, "Could not convert UTC Start time to TAI" )
      call announce_error ( 0, "Could not convert UTC End time to TAI" )
    end if

    ! -- May need to change these if we have
    !    configuration parameters introduced into PCF file
    !    for now -- outputversion and cycle are hard-wired below
    ! --

    ! Here's where we define the components of l2pcf

!      returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_OutputVersion, &
!                                          l2pcf%outputVersion)
    l2pcf%outputVersion = '1'

!   returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_Cycle, l2pcf%cycle)
    l2pcf%cycle = '1'
d288 2
a289 2
    l2pcf%startutc = CCSDSStartTime
    l2pcf%endutc = CCSDSEndTime
d291 6
a296 12
! Get the name of the log file from the PCF

    version = 1
    !??? Invent a parameter for the number below ???
    mlspcf_log = 10101             ! This seems to be hard-wired into PCF

    returnStatus = Pgs_pc_getReference(mlspcf_log, version, name)
    if ( returnStatus /= PGS_S_SUCCESS ) then
    ! call MLSMessage ( MLSMSG_Error, &
    !   & ModuleName, 'Error retrieving log file name from PCF.' )
      call announce_error ( 0, "Error retrieving log file name from PCF" )
    end if
d298 2
a299 2
    indx = INDEX(name, '/', .TRUE.)
    l2pcf%logGranID = name(indx+1:)
d301 4
a304 4
!   if ( ERROR/=0 ) then
!     call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & 'Problem with open_init section' )
!   end if
d307 3
a309 3
      if ( levels(gen) > 0 .or. index(switches,'L') /= 0 ) &
        & call dump_L1B_database ( ifl1, l1binfo, l2pcf, &
          & CCSDSEndTime, CCSDSStartTime )
d316 12
a327 1
! =====     Private Procedures     =====================================
d329 4
a332 16
  ! ------------------------------------------  Dump_L1B_database  -----
  subroutine Dump_L1B_database ( num_l1b_files, l1binfo, l2pcf, &
    & CCSDSEndTime, CCSDSStartTime )
 
    ! Dump info obtained during OpenAndInitialize:
    ! L1B databse
    ! L1OA file
    ! Start and end times
    ! output version
    ! cycle number
    ! logfile name
 
    ! Arguments
    integer, intent(in) :: num_l1b_files
    type(L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
    type(PCFData_T) :: l2pcf
d335 2
a336 2
 
    ! Local
d339 1
a339 1
    integer :: i, returnStatus, version
d341 2
a342 2
    ! Begin
    version = 1
d344 5
a348 4
    call output ( 'L1B database:', advance='yes')
 
    do i=1, num_l1b_files
      returnStatus = Pgs_pc_getReference(l1bInfo%L1BRADIDs(i), version, &
d350 8
a357 5
      call output ( 'fileid:   ')
      call output ( l1bInfo%L1BRADIDs(i), advance='yes')
      call output ( 'name:   ')
      call output ( TRIM(physicalFilename), advance='yes')
    end do
d359 2
a360 2
    call output ( 'L1OA file:', advance='yes')
 
d362 15
a376 5
      & physicalFilename)
    call output ( 'fileid:   ')
    call output ( l1bInfo%L1BOAID, advance='yes')
    call output ( 'name:   ')
    call output ( TRIM(physicalFilename), advance='yes')
d378 2
a379 2
    call output ( 'Start Time:   ')
    call output ( CCSDSStartTime, advance='yes')
d381 2
a382 2
    call output ( 'End Time:   ')
    call output ( CCSDSEndTime, advance='yes')
d384 2
a385 2
    call output ( 'Output version:   ')
    call output ( l2pcf%outputVersion, advance='yes')
d387 2
a388 2
    call output ( 'cycle:   ')
    call output ( l2pcf%cycle, advance='yes')
d390 2
a391 2
    call output ( 'Log file name:   ')
    call output ( TRIM(l2pcf%logGranID), advance='yes')
d393 4
a396 1
  end subroutine Dump_L1B_database
d459 1
a459 1

a460 9
! Revision 2.35  2001/04/11 00:47:25  vsnyder
! Comment out an error test

! Revision 2.34  2001/04/11 00:33:45  vsnyder
! use 'output' instead of 'print'

! Revision 2.33  2001/04/11 00:00:56  vsnyder
! Improve 'dump'

d463 1
a463 1

d466 1
a466 1

d469 1
a469 1

d472 1
a472 1

d475 1
a475 1

d478 1
a478 1

d481 1
a481 1

d484 1
a484 1

d487 1
a487 1

d490 1
a490 1

d493 1
a493 1

d496 1
a496 1

d499 1
a499 1

d502 1
a502 1

d505 1
a505 1

d508 1
a508 1

d511 1
a511 1

d514 1
a514 1

d517 1
a517 1

d520 1
a520 1

d523 1
a523 1

d525 2
a526 2
! calls READL2AUXData from L2AUXData module

d529 1
a529 1

d532 1
a532 1

d535 1
a535 1

d539 1
a539 1

d542 1
a542 1

d545 1
a545 1

d548 1
a548 1

d551 1
a551 1

d554 1
a554 1

d557 1
a557 1

@


2.35
log
@Comment out an error test
@
text
@a30 3
  ! -----     Private declarations     ---------------------------------

  private :: Id, ModuleName
d32 5
a36 3
  character(len=130) :: id = &
    "$id: open_init.f90,v 1.11 2000/06/19 22:40:51 lungu Exp $"
  character(len=*), parameter :: ModuleName="$RCSfile: open_init.f90,v $"
d39 1
a39 1
  integer, parameter :: CCSDSLen = 27
d53 1
a53 1
       !     & MLSMSG_DeAllocate // "l1bInfo" )
d69 8
a76 4
    type (TAI93_Range_T) :: processingRange ! Data processing range
    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
    type(PCFData_T) :: l2pcf
    character (len=1), pointer :: anText(:)
d78 1
d84 2
d87 1
a87 2
    character(len=*), parameter :: DEFAULTANTEXT = &
	 & 'PCF file number missing from PCF--add this line'
d91 1
d93 3
a95 1
    character (LEN=FileNameLen) :: L1physicalFilename
d98 3
a100 7
    integer :: STATUS, Size ! From allocate

    character (len=FileNameLen) :: Name

    integer ::  Indx, Mlspcf_log, Version

    integer :: PGS_td_utctotai, PGS_pc_getconfigdata
d105 2
a106 2
    if ( DEBUG ) call announce_error(0, &
      & 'Read the PCF into an annotation for file headers')
d111 1
a111 1
    Status = Pgs_pc_getFileSize(mlspcf_pcf_start, version, size)
d115 2
a116 2
      call announce_error ( 0, DEFAULTANTEXT )
      size = len(DEFAULTANTEXT) + 1
d118 2
a119 2
      anText(1:size-1) = DEFAULTANTEXT(1:size-1)
      error=PENALTY_FOR_NO_METADATA
d124 1
a124 1
    if ( DEBUG ) call announce_error(0, 'Opening L1 RAD files')
d144 2
a145 2
!            & MLSMSG_Allocate // "l1bInfo" )
          call announce_error(0, 'Allocation failed for L1BRADIDs')
d152 2
a153 2
          call announce_error(0, &
            & 'Error opening L1RAD file: ' //L1physicalFilename)
d164 1
a164 1
    if ( DEBUG ) call announce_error(0, 'Opening LOA file')
d180 2
a181 1
        call announce_error ( 0, "Error opening L1OA file "//L1physicalFilename )
d189 1
a189 1
      call announce_error(0, "Could not find L1BOA file" )
d199 1
a199 1
      call announce_error(0, "Could not get CCSDS Start Time" )
d206 1
a206 1
    !	call MLSMessage ( MLSMSG_Error, &
d208 1
a208 1
      call announce_error(0, "Could not convert UTC Start time to TAI" )
d213 1
a213 1
    !	call MLSMessage ( MLSMSG_Error, &
d215 1
a215 1
      call announce_error(0, "Could not get CCSDS End Time" )
d222 1
a222 1
    !	call MLSMessage ( MLSMSG_Error, &
d237 1
a237 1
	
d247 2
a248 1
    mlspcf_log = 10101			! This seems to be hard-wired into PCF
d253 2
a254 2
    !                  ModuleName, 'Error retrieving log file name from PCF.' )
      call announce_error(0, "Error retrieving log file name from PCF" )
d268 1
a268 1
  			& CCSDSEndTime, CCSDSStartTime )
d341 1
a341 1
  ! ------------------------------------------------  announce_error  -----
d346 1
a346 1
	
d369 1
a369 2
      call output ( ': ' )
      call output ( "The " );
d381 1
a381 1
        call output ( 'error number ', advance='no' )
d387 1
a387 1
      call output ( trim(full_message) )
d402 1
a402 1
!
d404 3
d409 1
a409 1
!
d412 1
a412 1
!
d415 1
a415 1
!
d418 1
a418 1
!
d421 1
a421 1
!
d424 1
a424 1
!
d427 1
a427 1
!
d430 1
a430 1
!
d433 1
a433 1
!
d436 1
a436 1
!
d439 1
a439 1
!
d442 1
a442 1
!
d445 1
a445 1
!
d448 1
a448 1
!
d451 1
a451 1
!
d454 1
a454 1
!
d457 1
a457 1
!
d460 1
a460 1
!
d463 1
a463 1
!
d466 1
a466 1
!
d469 1
a469 1
!
d472 1
a472 1
!
d475 1
a475 1
!
d478 1
a478 1
!
d481 1
a481 1
!
d484 1
a484 1
!
d487 1
a487 1
!
d491 1
a491 1
!
d494 1
a494 1
!
d497 1
a497 1
!
d500 1
a500 1
!
d503 1
a503 1
!
d506 1
a506 1
!
d509 1
a509 1
!
@


2.34
log
@use 'output' instead of 'print'
@
text
@d139 4
a142 4
!		  	call MLSMessage ( MLSMSG_Error, ModuleName, &
!          & MLSMSG_Allocate // "l1bInfo" )
			call announce_error(0, 'Allocation failed for L1BRADIDs')
			endif
d148 2
a149 2
	  call announce_error(0, &
	  & 'Error opening L1RAD file: ' //L1physicalFilename)
d246 2
a247 2
    ! call MLSMessage(MLSMSG_Error, &
    !                  ModuleName, 'Error retrieving log file name from PCF.')
d254 4
a257 4
    if ( ERROR/=0 ) then
      call MLSMessage(MLSMSG_Error,ModuleName, &
        & 'Problem with open_init section')
    end if
d399 3
@


2.33
log
@Improve 'dump'
@
text
@d20 1
a20 2
  use SDPToolkit, only: &
    &                   Pgs_pc_getReference, PGS_S_SUCCESS, &
d24 1
a24 2
  use TREE, only: &
    &             SUBTREE, DUMP_TREE_NODE, SOURCE_REF
d50 2
a51 2
    if (associated(l1bInfo%L1BRADIDs)) then
       deallocate( l1bInfo%L1BRADIDs, stat=status )
d81 1
a81 1
    character(len=*), parameter :: DEFAULTANTEXT= &
d85 1
a85 1
    integer :: ifl1
d88 3
a90 3
    integer :: returnStatus
    integer :: sd_id
    integer :: STATUS, size ! From allocate
d92 1
a92 1
    character (len=FileNameLen) :: name
d94 1
a94 1
    integer ::  indx, mlspcf_log, version
d96 1
a96 1
    integer :: pgs_td_utctotai, pgs_pc_getconfigdata
d101 1
a101 1
    if(DEBUG) call announce_error(0, &
d112 1
a112 1
      size = LEN(DEFAULTANTEXT) + 1
d120 1
a120 1
    if(DEBUG) call announce_error(0, 'Opening L1 RAD files')
d131 1
a131 1
      if (returnStatus == PGS_S_SUCCESS) then
d137 1
a137 1
        allocate( l1bInfo%L1BRADIDs(10), stat=status )
d145 1
a145 1
        if (sd_id == -1) then
d148 2
a149 2
				call announce_error(0, &
				& 'Error opening L1RAD file: ' //L1physicalFilename)
d157 1
a157 1
    !if (ifl1 == 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
d167 1
a167 1
    if (returnStatus == PGS_S_SUCCESS) then
d172 1
a172 1
      if (sd_id == -1) then
d176 1
a176 1
			call announce_error(0, "Error opening L1OA file "//L1physicalFilename )
d184 1
a184 1
			call announce_error(0, "Could not find L1BOA file" )
d216 1
a216 1
      & returnstatus /= PGSTD_E_NO_LEAP_SECS) then
d245 2
a246 2
    if (returnStatus /= PGS_S_SUCCESS) then
    ! CALL MLSMessage(MLSMSG_Error, &
d254 1
a254 1
    if (ERROR/=0 ) then
d260 1
a260 1
      if ( levels(gen) > 0 .or. index(switches,'C') /= 0 ) &
d269 5
a273 3
  ! -------------------------------------------------  dump_L1B_database  -----
  subroutine dump_L1B_database(num_l1b_files, l1binfo, l2pcf, &
    & CCSDSEndTime, CCSDSStartTime)
d285 1
a285 1
    type (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
d298 1
a298 1
    call output('L1B database:', advance='yes')
d303 4
a306 4
      call output('fileid:   ')
      call output(l1bInfo%L1BRADIDs(i), advance='yes')
      call output('name:   ')
      call output(TRIM(physicalFilename), advance='yes')
d309 1
a309 1
    call output('L1OA file:', advance='yes')
d313 4
a316 4
    call output('fileid:   ')
    call output(l1bInfo%L1BOAID, advance='yes')
    call output('name:   ')
    call output(TRIM(physicalFilename), advance='yes')
d318 2
a319 2
    call output('Start Time:   ')
    call output(CCSDSStartTime, advance='yes')
d321 2
a322 2
    call output('End Time:   ')
    call output(CCSDSEndTime, advance='yes')
d324 2
a325 2
    call output('Output version:   ')
    call output(l2pcf%outputVersion, advance='yes')
d327 2
a328 2
    call output('cycle:   ')
    call output(l2pcf%cycle, advance='yes')
d330 2
a331 2
    call output('Log file name:   ')
    call output(TRIM(l2pcf%logGranID), advance='yes')
d333 1
a333 1
  end subroutine dump_L1B_database
d336 1
a336 1
  subroutine announce_error ( lcf_where, full_message, use_toolkit, &
d341 4
a344 4
    integer, intent(in)    :: lcf_where
    character(LEN=*), intent(in)    :: full_message
    logical, intent(in), optional :: use_toolkit
    integer, intent(in), optional    :: error_number
d347 5
a351 10
    logical :: just_print_it
    logical, parameter :: default_output_by_toolkit = .true.
	
    if(present(use_toolkit)) then
      just_print_it = use_toolkit
    else if(default_output_by_toolkit) then
      just_print_it = .false.
    else
      just_print_it = .true.
    endif
d353 1
a353 1
    if(.not. just_print_it) then
d365 1
a365 1
      if ( lcf_where > 0) then
d373 1
a373 1
      call output(trim(full_message), advance='yes', &
d390 1
a390 1
  end subroutine announce_error
d399 3
d466 1
a466 1
! Calls READL2AUXData from L2AUXData module
@


2.32
log
@Keeps track of whether to quit if no metadata
@
text
@d18 2
a19 2
  USE output_m, only: output
  USE PCFHdr, only: CreatePCFAnnotation
d42 1
a42 1
    integer, parameter :: CCSDSLen=27
d55 1
a55 1
		 !	call MLSMessage ( MLSMSG_Error, ModuleName, &
d57 3
a59 3
		call announce_error(0, 'Error deallocating L1BRADIDs')
    endif
    endif
a61 1

d74 3
a76 3
	 type(PCFData_T) :: l2pcf
    CHARACTER (LEN=1), POINTER :: anText(:)
	 integer, external :: Pgs_pc_getFileSize
d94 1
a94 1
      CHARACTER (LEN=FileNameLen) :: name
d96 1
a96 1
      INTEGER ::  indx, mlspcf_log, version
d103 2
a104 2
	if(DEBUG) call announce_error(0, &
	& 'Read the PCF into an annotation for file headers')
d108 11
a118 12
      version = 1
      Status = Pgs_pc_getFileSize(mlspcf_pcf_start, version, size)
		if(Status == PGS_S_SUCCESS) then
	      CALL CreatePCFAnnotation(mlspcf_pcf_start, anText)
		else
			call announce_error(0, &
			& DEFAULTANTEXT)
			size = LEN(DEFAULTANTEXT) + 1
     		 ALLOCATE(anText(size), STAT=Status)
			anText(1:size-1) = DEFAULTANTEXT(1:size-1)
         error=PENALTY_FOR_NO_METADATA
		endif
d122 1
a122 1
	if(DEBUG) call announce_error(0, 'Opening L1 RAD files')
d127 2
a128 2
    ! Get the l1 file name from the PCF
    L1_Version = 1
d162 1
a162 1
	if(DEBUG) call announce_error(0, 'Opening LOA file')
d194 4
a197 4
	! call MLSMessage ( MLSMSG_Error, &
   !   & ModuleName, "Could not get CCSDS Start Time" )
			call announce_error(0, "Could not get CCSDS Start Time" )
	endif
d203 4
a206 4
	!	call MLSMessage ( MLSMSG_Error, &
   !   & ModuleName, "Could not convert UTC Start time to TAI" )
			call announce_error(0, "Could not convert UTC Start time to TAI" )
	endif
d210 1
a210 1
	 !	call MLSMessage ( MLSMSG_Error, &
d212 2
a213 2
			call announce_error(0, "Could not get CCSDS End Time" )
	endif
d219 9
a227 9
	!	call MLSMessage ( MLSMSG_Error, &
   !   & ModuleName, "Could not convert UTC Start time to TAI" )
			call announce_error(0, "Could not convert UTC End time to TAI" )
	endif

	! -- May need to change these if we have
	!    configuration parameters introduced into PCF file
	!    for now -- outputversion and cycle are hard-wired below
	! --
d229 1
a229 1
	! Here's where we define the components of l2pcf
d233 1
a233 1
	l2pcf%outputVersion = '1'
d235 5
a239 5
!      returnStatus = pgs_pc_getConfigData(mlspcf_l2_param_Cycle, l2pcf%cycle)
	l2pcf%cycle = '1'
	
	l2pcf%startutc = CCSDSStartTime
	l2pcf%endutc = CCSDSEndTime
d243 2
a244 2
      version = 1
      mlspcf_log = 10101			! This seems to be hard-wired into PCF
d246 6
a251 6
      returnStatus = Pgs_pc_getReference(mlspcf_log, version, name)
      IF (returnStatus /= PGS_S_SUCCESS) then
		!	CALL MLSMessage(MLSMSG_Error, &
      !                  ModuleName, 'Error retrieving log file name from PCF.')
			call announce_error(0, "Error retrieving log file name from PCF" )
	endif
d253 2
a254 2
      indx = INDEX(name, '/', .TRUE.)
      l2pcf%logGranID = name(indx+1:)
d257 3
a259 3
	 	call MLSMessage(MLSMSG_Error,ModuleName, &
      & 'Problem with open_init section')
	end if
d263 2
a264 2
        & call dump_L1B_database(ifl1, l1binfo, l2pcf, &
  			& CCSDSEndTime, CCSDSStartTime)
d273 12
a284 13
  & CCSDSEndTime, CCSDSStartTime)
  
  ! Dump info obtained during OpenAndInitialize:
  ! L1B databse
  ! L1OA file
  ! Start and end times
  ! output version
  ! cycle number
  ! logfile name
  

	! Arguments
	integer, intent(in) :: num_l1b_files
d286 1
a286 1
	 type(PCFData_T) :: l2pcf
d289 2
a290 2
	
	! Local
d293 1
a293 1
	integer :: i, returnStatus, version
d295 2
a296 2
	! Begin
	version = 1
d298 4
a301 4
  call output('L1B database:', advance='yes')
  
  do i=1, num_l1b_files
    returnStatus = Pgs_pc_getReference(l1bInfo%L1BRADIDs(i), version, &
d303 5
a307 5
  	call output('fileid:   ')
	call output(l1bInfo%L1BRADIDs(i), advance='yes')
  	call output('name:   ')
  	call output(TRIM(physicalFilename), advance='yes')
  enddo
d309 2
a310 2
  call output('L1OA file:', advance='yes')
  
d312 11
a322 8
        & physicalFilename)
  	call output('fileid:   ')
	call output(l1bInfo%L1BOAID, advance='yes')
  	call output('name:   ')
  	call output(TRIM(physicalFilename), advance='yes')

  	call output('Start Time:   ')
	call output(CCSDSStartTime, advance='yes')
d324 2
a325 2
  	call output('End Time:   ')
	call output(CCSDSEndTime, advance='yes')
d327 2
a328 2
  	call output('Output version:   ')
	call output(l2pcf%outputVersion, advance='yes')
d330 2
a331 5
  	call output('cycle:   ')
	call output(l2pcf%cycle, advance='yes')

  	call output('Log file name:   ')
  	call output(TRIM(l2pcf%logGranID), advance='yes')
d337 1
a337 1
  & error_number )
d339 1
a339 1
   ! Arguments
d341 8
a348 8
	integer, intent(in)    :: lcf_where
	character(LEN=*), intent(in)    :: full_message
	logical, intent(in), optional :: use_toolkit
	integer, intent(in), optional    :: error_number

	! Local
  logical :: just_print_it
  logical, parameter :: default_output_by_toolkit = .true.
d350 43
a392 41
	if(present(use_toolkit)) then
		just_print_it = use_toolkit
	elseif(default_output_by_toolkit) then
		just_print_it = .false.
	else
		just_print_it = .true.
	endif
	
	if(.not. just_print_it) then
    error = max(error,1)
    call output ( '***** At ' )

	if(lcf_where > 0) then
	    call print_source ( source_ref(lcf_where) )
		else
    call output ( '(no lcf node available)' )
		endif

    call output ( ': ' )
    call output ( "The " );
	if(lcf_where > 0) then
    call dump_tree_node ( lcf_where, 0 )
		else
    call output ( '(no lcf tree available)' )
		endif

		CALL output(" Caused the following error:", advance='yes', &
		& from_where=ModuleName)
		CALL output(trim(full_message), advance='yes', &
		& from_where=ModuleName)
		if(present(error_number)) then
			CALL output('error number ', advance='no')
			CALL output(error_number, places=9, advance='yes')
		endif
	else
		print*, '***Error in module ', ModuleName
		print*, trim(full_message)
		if(present(error_number)) then
			print*, 'error number ', error_number
		endif
	endif
d404 3
@


2.31
log
@Improve an error message
@
text
@a10 4
  use Hdfeos, only: swopen, swclose
  use INIT_TABLES_MODULE, only: F_FILE, F_SWATH, S_L2AUX, S_L2GP
  use L2AUXData, only: AddL2AUXToDatabase, L2AUXData_T, ReadL2AUXData
  use L2GPData, only: AddL2GPToDatabase, L2GPData_T, ReadL2GPData
d13 2
a14 2
!  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
!    &                         MLSMSG_Error, MLSMSG_FileOpen!, MLSMSG_Info
d16 2
a17 3
    &                MLSPCF_L1B_RAD_START, MLSPCF_NOMEN_START, &
    &                mlspcf_pcf_start
  use MoreTree, only: Get_Spec_ID
d20 1
a20 1
  use SDPToolkit, only: PGS_IO_Gen_closeF, PGS_IO_Gen_openF, &
d22 1
a22 2
    &                   PGSd_IO_Gen_RSeqFrm, PGSTD_E_NO_LEAP_SECS
  use String_Table, only: Get_String !, L2CFUnit => INUNIT
d25 2
a26 3
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, &
    &             SUB_ROSA, SUBTREE, DUMP_TREE_NODE, SOURCE_REF
  use TREE_TYPES, only: N_NAMED!, N_DOT
d119 1
d258 5
d405 3
@


2.30
log
@Checks on pcf number before PCFCreateAnnotation
@
text
@d380 1
a380 1
		CALL output("Caused the following error:", advance='yes', &
d406 3
@


2.29
log
@Fixed tiny error
@
text
@d84 1
d91 2
d100 1
a100 1
    integer :: STATUS ! From allocate
d116 11
a126 1
      CALL CreatePCFAnnotation(mlspcf_pcf_start, anText)
d406 3
@


2.28
log
@Deleted open_mlscf and close_mlscf and all MLSMessages
@
text
@d38 1
a38 1
  public :: Close_MLSCF, DestroyL1BInfo, OpenAndInitialize, Open_MLSCF
d393 3
@


2.27
log
@Added trace_*, dump_l1b_database
@
text
@d15 1
d17 2
a18 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    &                         MLSMSG_Error, MLSMSG_FileOpen!, MLSMSG_Info
d32 1
a32 1
    &             SUB_ROSA, SUBTREE
d50 1
a53 19
  ! ------------------------------------------------  Close_MLSCF  -----
  subroutine Close_MLSCF ( CF_Unit )

    integer, intent(in) :: CF_Unit

    character (len=32) :: Mnemonic
    character (len=256) :: Msg
    integer :: ReturnStatus

    returnStatus = Pgs_io_gen_closeF ( CF_Unit )

    if ( returnStatus /= PGS_S_SUCCESS ) then
      call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error closing L2CF:  '//mnemonic//' '//msg)
    end if

  end subroutine Close_MLSCF

d58 1
d61 5
a65 2
       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_DeAllocate // "l1bInfo" )
d86 1
d105 1
d107 4
d117 2
d120 2
a124 2
    do L1FileHandle = mlspcf_l1b_rad_start, mlspcf_l1b_rad_end

d135 5
a139 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate // "l1bInfo" )
d143 4
a146 3
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Error opening L1RAD file "//L1physicalFilename )

d157 1
d171 3
a173 3
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Error opening L1OA file "//L1physicalFilename )

d180 2
a181 1
      call MLSMessage ( MLSMSG_Error, ModuleName, "Could not find L1BOA file" )
d188 5
a192 2
    if ( returnstatus /= PGS_S_SUCCESS ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Could not get CCSDS Start Time" )
d197 5
a201 2
      &  returnstatus /= PGSTD_E_NO_LEAP_SECS ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Could not convert UTC Start time to TAI" )
d204 5
a208 2
    if ( returnstatus /= PGS_S_SUCCESS ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Could not get CCSDS End Time" )
d213 5
a217 2
      & returnstatus /= PGSTD_E_NO_LEAP_SECS) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Could not convert UTC Start time to TAI" )
d242 6
a247 2
      IF (returnStatus /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, &
                        ModuleName, 'Error retrieving log file name from PCF.')
a260 24
  ! -------------------------------------------------  Open_MLSCF  -----
  subroutine Open_MLSCF ( MLSPCF_Start, CF_Unit )

    integer, intent(in) :: MLSPCF_Start
    integer, intent(out) :: CF_Unit

    integer :: L2CF_Version
    character (len=32) :: Mnemonic
    character (len=256) :: Msg
    integer :: ReturnStatus

    !   Open the MLSCF as a generic file for reading
    L2CF_Version = 1
    returnStatus = Pgs_io_gen_openF ( mlspcf_start, PGSd_IO_Gen_RSeqFrm, &
      &                               0, CF_Unit, L2CF_Version)

    if ( returnStatus /= PGS_S_SUCCESS ) then
      call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Error opening MLSCF:  "//mnemonic//"  "//msg)
    end if

  end subroutine Open_MLSCF

d326 61
d393 3
@


2.26
log
@Added anText; deleted read_apriori
@
text
@d22 1
d28 2
a29 2
  use TOGGLES, only: GEN, TOGGLE
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
d48 2
a99 1
    integer, parameter :: CCSDSLen=27
d106 1
a106 1
    character (LEN=132) :: L1physicalFilename
d117 1
d234 6
d268 65
d334 1
d339 3
@


2.25
log
@Now fills components of l2pcf
@
text
@d19 2
a20 2
    &                MLSPCF_L1B_RAD_START, MLSPCF_NOMEN_START!, &
!   &                MLSPCF_L2CF_START
d22 1
a28 2
! use TREE, only: DECORATE, DECORATION, DUMP_TREE_NODE, NODE_ID, NSONS, &
!   &             SOURCE_REF, SUB_ROSA, SUBTREE
a31 3
! use VectorsModule, only: AddVectorToDatabase, CreateVector, Dump, Vector_T, &
!   &                      VectorTemplate_T
! use VectorsModule, only: Vector_T
a36 1
  public :: Read_apriori
d81 1
a81 1
  subroutine OpenAndInitialize ( processingRange, l1bInfo, l2pcf )
d93 1
d115 4
a258 136
  ! --------------------------------------------------  read_apriori  -----
  ! Read a priori data from data files, be they l2gp, l2aux, climatology,
  ! NCEP, DAO etc.

  subroutine read_apriori ( root, L2GPDatabase, l2auxDatabase)


    ! Dummy arguments
    integer, intent(in) :: ROOT    ! Of the Read a priori section in the AST
    type (l2gpdata_t), dimension(:), pointer :: L2GPDatabase
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase

    !Local Variables
    integer :: FIELD               ! Son of KEY, must be n_assign
    integer :: fileHandle          ! fileHandle of a priori data file
    integer :: fileName            ! Sub-rosa index of name in file='name'
    character(len=FileNameLen) :: FileNameString   ! actual literal file name
    integer :: FileType            ! either s_l2gp or s_l2aux
    integer :: I, J                ! Loop indices for section, spec
    integer :: KEY                 ! Index of n_spec_args in the AST
    type (L2AUXData_T) :: L2AUX
    type (L2GPData_T) :: L2GP
    integer :: l2Index             ! In the l2gp or l2aux database
    integer :: L2Name              ! Sub-rosa index of L2[aux/gp] label
    character (LEN=480) :: msr     ! Error message if can't find file
!?  type (Vector_T) :: newVector

    integer :: sd_id
    integer :: SON              ! Of root, an n_spec_args or a n_named
    integer :: swathName        ! sub-rosa index of name in swath='name'
    character(len=FileNameLen) :: SwathNameString ! actual literal swath name
!?  integer :: vectorIndex         ! In the vector database


    if ( toggle (gen) ) call trace_begin( "read_apriori", root )

    do i = 2, nsons(root)-1 ! Skip the section name at begin and end
      son = subtree(i,root)
      if ( node_id(son) == n_named ) then ! Is spec labeled?
        key = subtree(2,son)
        l2Name = sub_rosa(subtree(1,son))
      else
        key = son
        l2Name = 0
      end if

      ! Node_id(key) is now n_spec_args.

      FileType = get_spec_id(key)

      ! Now parse file and field names
      fileName = 0
      swathName = 0
      do j = 2, nsons(key)
        field = subtree(j,key)
        select case ( decoration(subtree(1,field)) )
        case ( f_file )
          fileName = sub_rosa(subtree(2,field))
        case ( f_swath )
          swathName = sub_rosa(subtree(2,field))
        end select
      end do
      if ( fileName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'File name not specified in read a priori')
      if ( swathName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Swath name not specified in read a priori')

      call get_string ( FileName, fileNameString )
      call get_string ( swathName, swathNameString )
      fileNameString=fileNameString(2:LEN_TRIM(fileNameString)-1)
      swathNameString=swathNameString(2:LEN_TRIM(swathNameString)-1)

      select case( FileType )
      case ( s_l2gp )

        ! Open the l2gp file
        fileHandle = swopen(FileNameString, DFACC_READ)
        if (fileHandle == -1) then
          msr = MLSMSG_Fileopen // FileNameString
          call MLSMessage ( MLSMSG_Error, ModuleName, trim(msr) )
        end if

        ! Read the swath
        call ReadL2GPData ( fileHandle, swathNameString, l2gp )

        ! Close the file
        fileHandle = swclose(fileHandle)
        if (fileHandle == -1) THEN
          msr = 'Failed to close file ' // FileNameString
          call MLSMessage(MLSMSG_Error, ModuleName, trim(msr))
        end if

        ! Add this l2gp to the database, decorate this key with index
        call decorate ( key, AddL2GPToDatabase( L2GPDatabase, l2gp ) )
        ! Don't call destroy contents as the AddL2GPToDatabase has done a shallow
        ! copy.
      case ( s_l2aux )

        ! create SD interface identifier for l2aux
        sd_id = sfstart(FilenameString, DFACC_READ)
        IF (sd_id == -1) THEN
          msr = MLSMSG_Fileopen // FileNameString
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF
        ! ??? subtree(1,key) is l2aux or l2gp.  It doesn't have a subtree ???
        !       vectorIndex = decoration(decoration(subtree(2,subtree(1,key))))

        ! Create the l2aux, and add it to the database.
        ! This doesn't match the interface in module L2AUXData
        !       CALL SetupNewL2AUXRecord ( l2aux )
        ! It has been relocated to READL2AUXData

        l2aux%name = l2Name

        !        call decorate ( key, AddL2AUXToDatabase( L2AUXDatabase, l2aux ) )

        ! That's the end of the create operation

        ! ??? Should "vectorIndex" be "decoration(key)" ???
        ! ??? If so, do something like
        l2Index = AddL2AUXToDatabase( L2AUXDatabase, l2aux )
        call decorate ( key, l2Index )
        !   call ReadL2AUXData ( ... L2AUXDataBase(l2Index) ... )
        ! Need to add this routine to L2AUXData.f90 before uncommenting this line
        CALL ReadL2AUXData(sd_id, swathNameString, L2AUXDatabase(l2Index))

      case default ! Can't get here if tree_checker worked correctly
      end select


    end do

    if (toggle(gen) ) call trace_end("read_apriori")

  end subroutine read_apriori

d264 3
@


2.24
log
@Finish removing use of MLSSignalNomenclature
@
text
@d36 1
d86 1
a86 1
  subroutine OpenAndInitialize ( processingRange, l1bInfo )
d97 1
d113 4
d203 28
d400 3
@


2.23
log
@Remove use of MLSSignalNomenclature
@
text
@a106 2
    integer :: nomenUnit
    integer :: Nomen_Version
d366 3
@


2.22
log
@Use Get_Spec_ID instead of decoration(subtree...
@
text
@a20 1
  use MLSSignalNomenclature, only: ReadSignalsDatabase
a176 14
    ! Open and Read nomenclature file

    Nomen_Version = 1
    returnStatus = PGS_IO_Gen_openF (mlspcf_nomen_start, PGSd_IO_Gen_RSeqFrm, &
      & 0, NomenUnit, Nomen_Version)
    if ( returnStatus /= PGS_S_SUCCESS ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Could not open nomenclature file" )

    call ReadSignalsDatabase ( Nomenunit )

    returnStatus = PGS_IO_Gen_closeF (Nomenunit)  ! close unit
    if ( returnstatus /= PGS_S_SUCCESS )  call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Could not close nomenclature file" )

d368 3
@


2.21
log
@Made it not mind if no L1B radiance files.
@
text
@d22 1
d290 1
a290 1
      FileType = decoration(subtree(1,decoration(subtree(1,key))))
d383 3
@


2.20
log
@Commented-out more USEd entities that NAG says actually aren't used.
@
text
@d76 5
a80 3
    deallocate( l1bInfo%L1BRADIDs, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "l1bInfo" )
d148 2
a149 2
    if (ifl1 == 0) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Could not find any L1BRAD files" )
d382 3
@


2.19
log
@Lost read_apriori and read_mlscf to new modules
@
text
@d13 2
d19 2
a20 2
    &                MLSPCF_L1B_RAD_START, MLSPCF_NOMEN_START, &
    &                MLSPCF_L2CF_START
d25 1
a25 1
  use String_Table, only: L2CFUnit => INUNIT
d39 2
a40 1
  public :: DestroyL1BInfo, OpenAndInitialize
d53 19
d215 160
d380 3
@


2.18
log
@Commented-out several USEd entities that NAG says actually aren't used.
@
text
@a12 5
  use L2AUXData, only: L2AUXData_T, AddL2AUXToDatabase, &
    &                  ReadL2AUXData!, SetupNewL2AUXRecord
! use L2GPData, only: L2GPData_T, AddL2GPToDatabase, DestroyL2GPContents, &
!   &                 ReadL2GPData, SetupNewL2GPRecord
  use L2GPData, only: L2GPData_T, AddL2GPToDatabase, ReadL2GPData
d23 1
a23 1
  use String_Table, only: L2CFUnit => INUNIT, GET_STRING
d37 1
a37 1
  public :: CloseMLSCF, DestroyL1BInfo, OpenAndInitialize, OpenMLSCF, read_apriori
a49 17
  ! -------------------------------------------------  CloseMLSCF  -----
  subroutine CloseMLSCF

    character (len=32) :: Mnemonic
    character (len=256) :: Msg
    integer :: ReturnStatus

    returnStatus = Pgs_io_gen_closeF ( L2CFUnit )

    if ( returnStatus /= PGS_S_SUCCESS ) then
      call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error closing L2CF:  '//mnemonic//' '//msg)
    end if

  end subroutine CloseMLSCF

a192 158
  ! --------------------------------------------------  OpenMLSCF  -----
  subroutine OpenMLSCF

    integer :: L2CF_Version
    character (len=32) :: Mnemonic
    character (len=256) :: Msg
    integer :: ReturnStatus

    !   Open the MLSCF as a generic file for reading
    L2CF_Version = 1
    returnStatus = Pgs_io_gen_openF ( mlspcf_l2cf_start, PGSd_IO_Gen_RSeqFrm, &
      &                               0, L2CFUnit, L2CF_Version)

    if ( returnStatus /= PGS_S_SUCCESS ) then
      call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Error opening MLSCF:  "//mnemonic//"  "//msg)
    end if

  end subroutine OpenMLSCF

  ! --------------------------------------------------  read_apriori  -----
  ! Read a priori data from data files, be they l2gp, l2aux, climatology,
  ! NCEP, DAO etc.

  subroutine read_apriori ( root, L2GPDatabase, l2auxDatabase)


    ! Dummy arguments
    integer, intent(in) :: ROOT    ! Of the Read a priori section in the AST
    type (l2gpdata_t), dimension(:), pointer :: L2GPDatabase
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase

    !Local Variables
    integer :: FIELD               ! Son of KEY, must be n_assign
    integer :: fileHandle          ! fileHandle of a priori data file
    integer :: fileName            ! Sub-rosa index of name in file='name'
    character(len=FileNameLen) :: FileNameString   ! actual literal file name
    integer :: FileType            ! either s_l2gp or s_l2aux
    integer :: I, J                ! Loop indices for section, spec
    integer :: KEY                 ! Index of n_spec_args in the AST
    type (L2AUXData_T) :: L2AUX
    type (L2GPData_T) :: L2GP
    integer :: l2Index             ! In the l2gp or l2aux database
    integer :: L2Name              ! Sub-rosa index of L2[aux/gp] label
    character (LEN=480) :: msr     ! Error message if can't find file
!?  type (Vector_T) :: newVector

    integer :: sd_id
    integer :: SON              ! Of root, an n_spec_args or a n_named
    integer :: swathName        ! sub-rosa index of name in swath='name'
    character(len=FileNameLen) :: SwathNameString ! actual literal swath name
!?  integer :: vectorIndex         ! In the vector database


    if ( toggle (gen) ) call trace_begin( "read_apriori", root )

    do i = 2, nsons(root)-1 ! Skip the section name at begin and end
      son = subtree(i,root)
      if ( node_id(son) == n_named ) then ! Is spec labeled?
        key = subtree(2,son)
        l2Name = sub_rosa(subtree(1,son))
      else
        key = son
        l2Name = 0
      end if

      ! Node_id(key) is now n_spec_args.

      FileType = decoration(subtree(1,decoration(subtree(1,key))))

      ! Now parse file and field names
      fileName = 0
      swathName = 0
      do j = 2, nsons(key)
        field = subtree(j,key)
        select case ( decoration(subtree(1,field)) )
        case ( f_file )
          fileName = sub_rosa(subtree(2,field))
        case ( f_swath )
          swathName = sub_rosa(subtree(2,field))
        end select
      end do
      if ( fileName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'File name not specified in read a priori')
      if ( swathName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Swath name not specified in read a priori')

      call get_string ( FileName, fileNameString )
      call get_string ( swathName, swathNameString )
      fileNameString=fileNameString(2:LEN_TRIM(fileNameString)-1)
      swathNameString=swathNameString(2:LEN_TRIM(swathNameString)-1)

      select case( FileType )
      case ( s_l2gp )

        ! Open the l2gp file
        fileHandle = swopen(FileNameString, DFACC_READ)
        if (fileHandle == -1) then
          msr = MLSMSG_Fileopen // FileNameString
          call MLSMessage ( MLSMSG_Error, ModuleName, trim(msr) )
        end if

        ! Read the swath
        call ReadL2GPData ( fileHandle, swathNameString, l2gp )

        ! Close the file
        fileHandle = swclose(fileHandle)
        if (fileHandle == -1) THEN
          msr = 'Failed to close file ' // FileNameString
          call MLSMessage(MLSMSG_Error, ModuleName, trim(msr))
        end if

        ! Add this l2gp to the database, decorate this key with index
        call decorate ( key, AddL2GPToDatabase( L2GPDatabase, l2gp ) )
        ! Don't call destroy contents as the AddL2GPToDatabase has done a shallow
        ! copy.
      case ( s_l2aux )

        ! create SD interface identifier for l2aux
        sd_id = sfstart(FilenameString, DFACC_READ)
        IF (sd_id == -1) THEN
          msr = MLSMSG_Fileopen // FileNameString
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF
        ! ??? subtree(1,key) is l2aux or l2gp.  It doesn't have a subtree ???
        !       vectorIndex = decoration(decoration(subtree(2,subtree(1,key))))

        ! Create the l2aux, and add it to the database.
        ! This doesn't match the interface in module L2AUXData
        !       CALL SetupNewL2AUXRecord ( l2aux )
        ! It has been relocated to READL2AUXData

        l2aux%name = l2Name

        !        call decorate ( key, AddL2AUXToDatabase( L2AUXDatabase, l2aux ) )

        ! That's the end of the create operation

        ! ??? Should "vectorIndex" be "decoration(key)" ???
        ! ??? If so, do something like
        l2Index = AddL2AUXToDatabase( L2AUXDatabase, l2aux )
        call decorate ( key, l2Index )
        !   call ReadL2AUXData ( ... L2AUXDataBase(l2Index) ... )
        ! Need to add this routine to L2AUXData.f90 before uncommenting this line
        CALL ReadL2AUXData(sd_id, swathNameString, L2AUXDatabase(l2Index))

      case default ! Can't get here if tree_checker worked correctly
      end select


    end do

    if (toggle(gen) ) call trace_end("read_apriori")

  end subroutine read_apriori


d198 3
@


2.17
log
@Added trace calls
@
text
@d14 4
a17 3
    &                  ReadL2AUXData, SetupNewL2AUXRecord
  use L2GPData, only: L2GPData_T, AddL2GPToDatabase, DestroyL2GPContents, ReadL2GPData, &
    &                 SetupNewL2GPRecord
d20 1
a20 1
    &                         MLSMSG_Error, MLSMSG_FileOpen, MLSMSG_Info
d31 8
a38 5
  use TREE, only: DECORATE, DECORATION, DUMP_TREE_NODE, NODE_ID, NSONS, &
    &             SOURCE_REF, SUB_ROSA, SUBTREE
  use TREE_TYPES, only: N_NAMED, N_DOT
  use VectorsModule, only: AddVectorToDatabase, CreateVector, Dump, Vector_T, &
    &                      VectorTemplate_T
d261 1
a261 1
    type (Vector_T) :: newVector
d267 1
a267 1
    integer :: vectorIndex         ! In the vector database
d378 3
@


2.16
log
@Correct an error message
@
text
@d28 2
d265 3
d364 2
d374 3
@


2.15
log
@Added stuff to read l2gp's in
@
text
@d131 1
a131 1
            & "Error opening L1RAD file"//L1physicalFilename )
d367 3
@


2.14
log
@l2 modules can only use MLSPCF2
@
text
@a5 1
!=============================================================================
d7 2
a8 2
! Opens and closes several files
! Creates and destroys the L1BInfo database
d12 2
a13 2
  use INIT_TABLES_MODULE, only: F_FILE, F_SOURCE, S_L2AUX, S_L2GP
  use L2AUXData, only: L2AUXData_T, AddL2AUXToDatabase, & 
d15 2
a16 2
  use L2GPData, only: L2GPData_T, AddL2GPToDatabase, ReadL2GPData, &
    &                  SetupNewL2GPRecord
d19 1
a19 1
    & MLSMSG_Error, MLSMSG_FileOpen
d21 2
a22 2
    &               MLSPCF_L1B_RAD_START, MLSPCF_NOMEN_START, &
    &               MLSPCF_L2CF_START
d29 1
a29 1
    & SOURCE_REF, SUB_ROSA, SUBTREE
d32 1
a32 1
    & VectorTemplate_T
d43 1
a43 1
     "$id: open_init.f90,v 1.11 2000/06/19 22:40:51 lungu Exp $"
d56 1
a56 1
   returnStatus = Pgs_io_gen_closeF ( L2CFUnit )
d58 5
a62 5
   if ( returnStatus /= PGS_S_SUCCESS ) then
     call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
     call MLSMessage ( MLSMSG_Error, ModuleName, &
       & 'Error closing L2CF:  '//mnemonic//' '//msg)
   end if
d71 2
a72 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate // "l1bInfo" )
d79 4
a82 4
  ! Opens L1 RAD files
  ! Opens L1OA file
  ! Opens and reads the signal nomenclature file
  ! Gets the start and end times from the PCF
d120 1
a120 1
    ! Open the HDF file and initialize the SD interface
d122 1
a122 1
    ! Allocate L1BRADIDs
d151 1
a151 2
    ! Open the HDF file and initialize the SD interface

d190 1
a190 1
!   ??? Is PGSTD_E_NO_LEAP_SECS an OK status ???
d200 1
a200 1
!   ??? Is PGSTD_E_NO_LEAP_SECS an OK status ???
a204 4
    !processingrange%starttime = 220838406.65045166
    !processingrange%endtime = 220841983.31690979
    !processingrange%endtime = 220924616.64530945

d217 1
a217 1
!   Open the MLSCF as a generic file for reading
d219 2
a220 2
   returnStatus = Pgs_io_gen_openF ( mlspcf_l2cf_start, PGSd_IO_Gen_RSeqFrm, &
     &                               0, L2CFUnit, L2CF_Version)
d222 5
a226 5
   if ( returnStatus /= PGS_S_SUCCESS ) then
     call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
     call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Error opening MLSCF:  "//mnemonic//"  "//msg)
   end if
d231 3
a235 1
    ! Read a priori data from l2gp files and l2aux files
d256 1
a256 2
    integer :: NumProfs            ! number of profiles actually read
!   integer :: quantityName        ! Sub-rosa index
d258 3
a260 3
    integer :: SON                 ! Of root, an n_spec_args or a n_named
    integer :: sourceName          ! Sub-rosa index of name in source='name'
    character(len=FileNameLen) :: SourceNameString ! actual literal source name
a262 8
    ! HDFEOS Functions

    integer, external :: SWCLOSE, SWOPEN

    ! Assume specifications take the following form:
    !   vName: fileType, file='fileName', source='fieldName'
    ! Currently, fileType is restricted to one of
    !   'l2gp' or 'l2aux'
d279 1
a279 1
      sourceName = 0
a283 2
          if ( fileName /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'File name specified twice in read a priori')
d285 2
a286 4
        case ( f_source )
          if ( sourceName /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'Source name specified twice in read a priori')
          sourceName = sub_rosa(subtree(2,field))
d291 2
a292 4
      if ( sourceName == 0 ) call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Source name not specified in read a priori')
      call get_string ( FileName, FileNameString )
      call get_string ( sourceName, sourceNameString )
d294 4
d302 6
a307 7
      fileHandle = swopen(FileNameString, DFACC_READ)
      if (fileHandle == -1) then
        msr = MLSMSG_Fileopen // FileNameString
        call MLSMessage ( MLSMSG_Error, ModuleName, trim(msr) )
      end if
! ??? subtree(1,key) is l2aux or l2gp.  It doesn't have a subtree ???
!       vectorIndex = decoration(decoration(subtree(2,subtree(1,key))))
d309 2
a310 3
        ! Create the l2gp, and add it to the database.
        call SetupNewL2GPRecord ( l2gp )
        l2gp%nameIndex = l2Name
d312 6
a317 17
!        call decorate ( key, AddL2GPToDatabase( L2GPDatabase, l2gp ) )

        ! That's the end of the create operation

! ??? Should "vectorIndex" be "decoration(key)" ???
! ??? If so, do something like
        l2Index = AddL2GPToDatabase( L2GPDatabase, l2gp )
        call decorate ( key, l2Index )
! ???        call ReadL2GPData ( ... L2GPDataBase(l2Index) ... )
        call ReadL2GPData ( fileHandle, sourceNameString, &
          & L2GPDatabase(l2Index), numProfs )

          fileHandle = swclose(fileHandle)
          if (fileHandle == -1) THEN
             msr = 'Failed to close file ' // FileNameString
             call MLSMessage(MLSMSG_Error, ModuleName, trim(msr))
          end if
d319 4
d325 8
a332 8
            ! create SD interface identifier for l2aux
                sd_id = sfstart(FilenameString, DFACC_READ)
            IF (sd_id == -1) THEN
               msr = MLSMSG_Fileopen // FileNameString
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
! ??? subtree(1,key) is l2aux or l2gp.  It doesn't have a subtree ???
!       vectorIndex = decoration(decoration(subtree(2,subtree(1,key))))
d335 3
a337 3
! This doesn't match the interface in module L2AUXData
!       CALL SetupNewL2AUXRecord ( l2aux )
! It has been relocated to READL2AUXData
d341 1
a341 1
!        call decorate ( key, AddL2AUXToDatabase( L2AUXDatabase, l2aux ) )
d344 8
a351 9
        
! ??? Should "vectorIndex" be "decoration(key)" ???
! ??? If so, do something like
   l2Index = AddL2AUXToDatabase( L2AUXDatabase, l2aux )
   call decorate ( key, l2Index )
!   call ReadL2AUXData ( ... L2AUXDataBase(l2Index) ... )
! Need to add this routine to L2AUXData.f90 before uncommenting this line
           CALL ReadL2AUXData(sd_id, sourceNameString, L2AUXDatabase(l2Index),&
           & numProfs)
d361 1
a361 1
!=============================================================================
d367 3
@


2.13
log
@Various updates
@
text
@d21 1
a21 1
  use MLSPCF, only: MLSPCF_L1B_OA_START, MLSPCF_L1B_RAD_END, &
d392 3
@


2.12
log
@Correct calculation of "field"
@
text
@d22 2
a23 1
    &               MLSPCF_L1B_RAD_START, MLSPCF_NOMEN_START
d57 1
a57 1
!   returnStatus = Pgs_io_gen_closeF ( L2CFUnit )
d59 5
a63 5
!   if ( returnStatus /= PGS_S_SUCCESS ) then
!     call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
!     call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & 'Error closing L2CF:  '//mnemonic//' '//msg)
!   end if
d225 2
a226 2
!   returnStatus = Pgs_io_gen_openF ( mlspcf_l2cf_start, PGSd_IO_Gen_RSeqFrm, &
!     &                               0, L2CFUnit, L2CF_Version)
d228 5
a232 6
!   if ( returnStatus /= PGS_S_SUCCESS ) then

!     call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
!     call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & "Error opening MLSCF:  "//mnemonic//"  "//msg)
!   end if
d392 3
@


2.11
log
@Calls READL2AUXData from L2AUXData module
@
text
@d295 1
a295 1
        select case ( decoration(subtree(1,decoration(subtree(1,field)))) )
d392 3
@


2.10
log
@Uses parser better
@
text
@d14 2
a15 2
  use L2AUXData, only: L2AUXData_T, AddL2AUXToDatabase, & !, ReadL2AUXData
    &                  SetupNewL2AUXRecord
d27 1
a27 1
  use String_Table, only: L2CFUnit => INUNIT
d375 1
a375 1
           CALL ReadL2AUXData(sd_id, sourceNameString, L2GPDatabase(l2Index),&
d392 3
@


2.9
log
@Added ReadL2AUXData
@
text
@d256 1
a265 1
    integer :: templateIndex       ! In the template database
d268 1
a268 1
    ! Toolkit Functions
d329 1
a329 1
        call decorate ( key, AddL2GPToDatabase( L2GPDatabase, l2gp ) )
d335 3
a337 3
! ???   l2Index = AddL2GPToDatabase( L2GPDatabase, l2gp )
! ???   call decorate ( key, l2Index )
! ???   call ReadL2GPData ( ... L2GPDataBase(l2Index) ... )
d339 1
a339 1
          & L2GPDatabase(vectorIndex), numProfs )
d361 2
d365 1
a365 1
        call decorate ( key, AddL2AUXToDatabase( L2AUXDatabase, l2aux ) )
d371 3
a373 3
! ???   l2Index = AddL2GPToDatabase( L2GPDatabase, l2gp )
! ???   call decorate ( key, l2Index )
! ???   call ReadL2AUXData ( ... L2AUXDataBase(l2Index) ... )
d375 1
a375 1
           CALL ReadL2AUXData(sd_id, sourceNameString, L2GPDatabase(vectorIndex),&
d392 3
@


2.8
log
@More misc. cleanup.
@
text
@d261 1
d313 4
a321 4

      select case( FileType )
      case ( s_l2gp )

d341 6
d349 6
d373 2
a374 2
!       CALL ReadL2AUXData ( fileHandle, sourceNameString, &
!         & L2AUXDatabase(vectorIndex), numProfs )
a378 5
      fileHandle = swclose(fileHandle)
      if (fileHandle == -1) THEN
         msr = 'Failed to close file ' // FileNameString
         call MLSMessage(MLSMSG_Error, ModuleName, trim(msr))
      end if
d390 3
@


2.7
log
@Use abstract syntax tree more efficiently, general clean-up -- alphabetization
etc.
@
text
@d267 1
a267 1
! Toolkit Functions
d269 1
a269 1
    INTEGER, EXTERNAL :: swclose, swopen
d271 4
a274 4
	! Assume specifications take the following form:
        !   vName: fileType, file='fileName', source='fieldName'
        ! Currently, fileType is restricted to one of
        !   'l2gp' or 'l2aux'
a286 3
      if ( nsons(key) /= 4 ) call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'Wrong number of fields in read a priori')

d315 1
a315 1
        call MLSMessage(MLSMSG_Error, ModuleName, msr)
d321 2
a322 1
        vectorIndex = decoration(decoration(subtree(2,subtree(1,key))))
a330 1
        
d332 5
a339 1

d342 2
a343 1
        vectorIndex = decoration(decoration(subtree(2,subtree(1,key))))
d354 5
d361 1
a361 2
!         & L2GPDatabase(vectorIndex), numProfs )

d367 1
a367 1
      IF (fileHandle == -1) THEN
d369 2
a370 2
         CALL MLSMessage(MLSMSG_Error, ModuleName, trim(msr))
      END IF
d382 4
@


2.6
log
@functions properly moved here from Fill
@
text
@d13 6
a18 3
  use L2AUXData, only: L2AUXData_T, AddL2AUXToDatabase	!, ReadL2AUXData
  use L2GPData, only: L2GPData_T, AddL2GPToDatabase, ReadL2GPData
  use MLSCommon, only: L1BInfo_T, TAI93_Range_T
a23 1
  use MLSStrings, only: lowercase
a46 3
  integer, parameter :: s_l2gp = 0   ! to be replaced by entry in init_tables_module
  integer, parameter :: s_l2aux = s_l2gp+1   ! to be replaced by entry in init_tables_module

d239 1
a239 1
	! Read in  a priori data from l2gp files and l2aux files
d243 1
a243 1
    TYPE (L2GPData_T), DIMENSION(:), POINTER :: L2GPDatabase
d247 5
d253 5
a257 1
    integer :: KEY                 ! Definitely n_named
d259 2
d262 2
a265 17
    integer :: vectorName          ! Sub-rosa index
    integer :: quantityName        ! Sub-rosa index
    integer :: sourceName          ! Sub-rosa index
    integer :: FileType            ! Sub-rosa index of either 'l2gp' or 'l2aux'
    integer :: fileHandle          ! fileHandle of a priori data file
    integer :: NumProfs            ! number of profiles actually read
    CHARACTER (LEN=24) :: FileTypeString     ! 'l2gp' or 'l2aux'
    CHARACTER (LEN=480) :: msr     ! Error message if can't find file
    integer :: JName               ! index to spec name of 3rd son of root
    CHARACTER*16 :: JString        ! index to spec name of 3rd son of root
    integer :: FileRoot            ! index to spec name of file field
    integer :: SourceRoot          ! index to spec name of source field
    integer :: FileName            ! subrosa indexed of name in file='name'
    CHARACTER*16 :: FileNameString ! actual literal file name
    CHARACTER*16 :: SourceNameString ! actual literal source name
    TYPE (L2GPData_T) :: L2GP
    TYPE (L2AUXData_T) :: L2AUX
d269 1
a269 1
      INTEGER, EXTERNAL :: swclose, swopen
d279 1
a279 1
        vectorName = sub_rosa(subtree(1,son))
d282 1
a282 1
        vectorName = 0
d287 4
a290 2
        if ( nsons(key) /= 4 ) call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Wrong number of fields in read a priori')
d292 28
a319 29
        FileType = sub_rosa(subtree(2,son))
        CALL get_string(FileType, FileTypeString)
	FileTypeString = lowercase(FileTypeString)

        ! Now parse file and field names
        ! Does file spec precede field spec?
        J = subtree(3, key)
        JName = decoration(subtree(1,decoration(subtree(1,J))))
        CALL get_string(JName, JString)
        JString = lowercase(JString)
        IF(JString.EQ.'file') THEN
 		! Yes
        	fileRoot = subtree(3, key)
        	sourceRoot = subtree(4, key)
	ELSE
 		! No
        	fileRoot = subtree(4, key)
        	sourceRoot = subtree(3, key)
	ENDIF
	FileName=sub_rosa(subtree(2, fileRoot))
        CALL get_string(FileName, FileNameString)
	sourceName=sub_rosa(subtree(2, sourceRoot))
        CALL get_string(sourceName, sourceNameString)

            fileHandle = swopen(FileNameString, DFACC_READ)
            IF (fileHandle == -1) THEN
               msr = MLSMSG_Fileopen // FileNameString
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
d321 2
a322 2
      select case( FileTypeString )
      case ( 'l2gp' )
d327 2
a328 1
        CALL SetupNewL2GPRecord ( l2gp )
d335 2
a336 2
           CALL ReadL2GPData(fileHandle, sourceNameString, L2GPDatabase(vectorIndex),&
           & numProfs)
d339 1
a339 1
      case ( 'l2aux' )
d344 3
a346 1
        CALL SetupNewL2AUXRecord ( l2aux )
d353 2
a354 2
!           CALL ReadL2AUXData(fileHandle, sourceNameString, L2GPDatabase(vectorIndex),&
!           & numProfs)
d360 5
a364 5
            fileHandle = swclose(fileHandle)
            IF (fileHandle == -1) THEN
               msr = 'Failed to close file ' // FileNameString
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF
d376 3
@


2.5
log
@Compiles now
@
text
@d12 3
d17 1
a17 1
    & MLSMSG_Error
d21 1
d238 1
a238 1
  subroutine read_apriori ( root )
d244 2
d257 18
a274 1
    integer :: FileType            ! Sub-rosa index; either 'l2gp' or 'l2aux'
d292 3
d296 2
d299 57
a355 2
      select case( decoration(subtree(1,decoration(subtree(1,key)))) )
      case ( s_l2gp )
a356 1
      case ( s_l2aux )
d361 6
d377 3
@


2.4
log
@Began changes to open old l2gp
@
text
@d24 3
d30 3
a32 1
  public :: CloseMLSCF, DestroyL1BInfo, OpenAndInitialize, OpenMLSCF
d41 3
d289 3
@


2.3
log
@Correct an error message.
@
text
@d22 2
d225 50
d281 3
@


2.2
log
@Removed old log entries in file.
@
text
@d145 1
a145 1
          & "Error opening L1OA file"//L1physicalFilename )
d229 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@a0 2


d5 1
a5 1
MODULE OpenInit ! Opens and reads l2cf info, NCEP, DAO and climatology files
d8 205
d214 1
a214 199
USE MLSCommon
USE MLSMessageModule
USE MLSCF
USE GriddedData
USE MLSPCF
USE Hdf
USE MLSSignalNomenclature
USE ObtainNCEP
USE ObtainDAO
USE ObtainClimatology

IMPLICIT NONE
PUBLIC

PRIVATE :: Id, ModuleName
!------------------------------- RCS Ident Info ------------------------------
CHARACTER(LEN=130) :: id = & 
   "$Id: open_init.f90,v 2.0 2000/09/05 18:57:06 ahanzel Exp $"
CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: open_init.f90,v $"
!-----------------------------------------------------------------------------
CONTAINS
SUBROUTINE OpenAndInitialize(processingRange, l1bInfo, l2cf_data, aprioriData)

! Arguments


TYPE (TAI93_Range_T) :: processingRange ! Data processing range
TYPE (L1BInfo_T) :: l1bInfo   ! File handles etc. for L1B dataset
TYPE (MLSCF_T) :: l2cf_data        ! The information from the l2cf file
TYPE (GriddedData_T), DIMENSION(:), POINTER :: aprioriData ! Input a priori database

!Local Variables
INTEGER ::  returnStatus, L2CFUnit, nomenUnit
Integer :: L1FileHandle, L1_Version, L2CF_Version, Nomen_Version, sd_id, ifl1, recl
CHARACTER (LEN=132) :: L1physicalFilename
CHARACTER (LEN=32) :: mnemonic
CHARACTER (LEN=256) :: msg
INTEGER, PARAMETER :: CCSDSStartId = 10411
INTEGER, PARAMETER :: CCSDSEndId = 10412
INTEGER, PARAMETER :: CCSDSLen=27
character(len=CCSDSlen) CCSDSStartTime
character(len=CCSDSlen) CCSDSEndTime

INTEGER :: pgs_td_utctotai, pgs_pc_getconfigdata

! Open, read and parse L2cf file
! Open the MLSCF as a generic file for reading

L2CF_Version = 1
returnStatus = Pgs_io_gen_openF (mlspcf_l2cf_start, PGSd_IO_Gen_RSeqFrm,0 , &
                                L2CFUnit, L2CF_Version)

IF (returnStatus /= PGS_S_SUCCESS) THEN

  CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
  CALL MLSMessage (MLSMSG_Error, &
                  ModuleName, "Error opening MLSCF:  "//mnemonic// &
                 "  "//msg)

ENDIF

Call read_parse_mlscf(L2CFUnit, l2cf_data)

! Close MLSCF
         
returnStatus = Pgs_io_gen_closeF (L2CFUnit)
IF (returnStatus /= PGS_S_SUCCESS) THEN
   CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
   CALL MLSMessage (MLSMSG_Error, &
                    ModuleName, 'Error closing L2CF:  '//mnemonic// &
                   ' '//msg)
ELSE
     CALL MLSMessage(MLSMSG_Info,ModuleName,'L2CF file read successfully')
               
ENDIF


ifl1 = 0

!Open L1 RAD files
! Get the l1 file name from the PCF
L1_Version = 1

DO L1FileHandle = mlspcf_l1b_rad_start, mlspcf_l1b_rad_end

  returnStatus = Pgs_pc_getReference(L1FileHandle, L1_Version, L1physicalFilename)

  IF(returnStatus == PGS_S_SUCCESS) THEN

! Open the HDF file and initialize the SD interface

! Allocate L1BRADIDs

    ALLOCATE( l1bInfo%L1BRADIDs(10) )

    sd_id = sfstart(L1physicalFilename, DFACC_READ)
    IF(sd_id == -1) THEN
      CALL MLSMessage (MLSMSG_Error, &
                      ModuleName, "Error opening L1RAD file"//L1physicalFilename)
    
    ELSE
      ifl1=ifl1 + 1
      l1bInfo%L1BRADIDs(ifl1)= sd_id
      CALL MLSMessage(MLSMSG_Info,ModuleName,'L1RAD file opened successfully: '&
                     //L1physicalFilename)
    ENDIF
  END IF
END DO ! L1FileHandle = mlspcf_l1b_rad_start, mlspcf_l1b_rad_end

IF(ifl1 == 0)THEN

  CALL MLSMessage (MLSMSG_Error, ModuleName, "Could not find any L1BRAD files")

END IF

!Open L1OA File

L1_Version = 1
returnStatus = Pgs_pc_getReference(mlspcf_l1b_oa_start, L1_Version, L1physicalFilename)

IF(returnStatus == PGS_S_SUCCESS) THEN

! Open the HDF file and initialize the SD interface


  sd_id = sfstart(L1physicalFilename, DFACC_READ)
  IF(sd_id == -1) THEN

    CALL MLSMessage (MLSMSG_Error, &
                     ModuleName, "Error opening L1OA file"//L1physicalFilename)
    
  ELSE
    CALL MLSMessage(MLSMSG_Info,ModuleName,'L1BOA file opened successfully: '//L1physicalFilename)
    l1bInfo%L1BOAID= sd_id
  END IF 
    
ELSE
    
  CALL MLSMessage (MLSMSG_Error, ModuleName, "Could not find  L1BOA file")

END IF
! Open and Read nomenclature file
            
Nomen_Version = 1
returnStatus = PGS_IO_Gen_openF (mlspcf_nomen_start, PGSd_IO_Gen_RSeqFrm, 0, NomenUnit, &
         & Nomen_Version)
IF (returnStatus /= PGS_S_SUCCESS) THEN
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not open nomenclature file")
END IF 

CALL ReadSignalsDatabase (Nomenunit)
          
returnStatus = PGS_IO_Gen_closeF (Nomenunit)  ! close unit
IF (returnstatus /= PGS_S_SUCCESS) THEN
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not close nomenclature file")
ELSE
    CALL MLSMessage(MLSMSG_Info,ModuleName,'Signal Nomenclature file read successfully')
END IF

!Get the Start and End Times from PCF

returnStatus = pgs_pc_getconfigdata(CCSDSStartId, CCSDSStartTime)
IF (returnstatus /= PGS_S_SUCCESS) THEN
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not get CCSDS Start Time")
END IF
returnStatus = pgs_td_utctotai(CCSDSStartTime, processingrange%starttime)

IF (returnstatus /= PGS_S_SUCCESS) THEN
IF (returnstatus /= PGSTD_E_NO_LEAP_SECS ) &
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not convert UTC Start time to TAI")
END IF

returnStatus = pgs_pc_getconfigdata(CCSDSEndId, CCSDSEndTime)
IF (returnstatus /= PGS_S_SUCCESS) THEN
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not get CCSDS End Time")
END IF

returnStatus = pgs_td_utctotai(CCSDSEndTime, processingrange%endtime)
IF (returnstatus /= PGS_S_SUCCESS) THEN 
IF (returnstatus /= PGSTD_E_NO_LEAP_SECS ) &   
    CALL MLSMessage (MLSMSG_Error, ModuleName, &
            & "Could not convert UTC End time to TAI")
END IF 

!processingrange%starttime=220838406.65045166
!processingrange%endtime=220841983.31690979
!processingrange%endtime=220924616.64530945

CALL Obtain_NCEP(aprioriData, l2cf_data)
CALL MLSMessage(MLSMSG_Info,ModuleName,'NCEP data read successfully')
CALL Obtain_DAO(aprioriData, l2cf_data)
CALL MLSMessage(MLSMSG_Info,ModuleName,'DAO data read successfully')
Call Obtain_Clim (aprioriData, l2cf_data)
CALL MLSMessage(MLSMSG_Info,ModuleName,'Climatology data read successfully')
d216 4
a219 1
RETURN
d221 1
a221 1
END Subroutine OpenAndInitialize
d224 1
a224 1
END MODULE OpenInit
d229 2
a230 2
! Revision 2.0  2000/09/05 18:57:06  ahanzel
! Changing file revision to 2.0.
d232 2
a233 2
! Revision 1.13  2000/07/31 18:37:12  lungu
! Logged opening and reading of input files.
@


1.12
log
@Added PGSTD_E_NO_LEAP_SECS status check.
@
text
@d28 1
a28 1
   "$Id: open_init.f90,v 1.12 2000/06/30 00:10:01 lungu Exp $"
d82 2
d114 2
d143 1
a143 1
      
d168 2
d205 1
d207 1
d209 1
d221 2
a222 22
! Revision 1.12  2000/06/30 00:10:01  lungu
! Added PGSTD_E_NO_LEAP_SECS status check.
!
! Revision 1.11  2000/06/19 22:40:51  lungu
! Added code to get the Start and End Times from PCF.
! Uncommented calls to Obtain_ncep, Obtain_dao and Obtain_clim.
! Added code to open and read SignalsDatabase.
!
! Revision 1.10  2000/04/24 21:36:00  lungu
! Allocated L1BRADIDs.
!
! Revision 1.9  2000/02/11 16:35:02  nakamura
! Removed superfluous USE MLSL2Common statement.
!
! Revision 1.8  2000/02/08 20:12:11  nakamura
! Replaced DataProcessingRange_T with TAI93_Range_T.
!
! Revision 1.7  2000/01/21 21:03:42  livesey
! Now uses GriddedData module rather than Temporary_types.
!
! Revision 1.6  2000/01/20 23:22:45  livesey
! Renamed some references to l2cf to MLSCF as appropriate
d224 2
a225 19
! Revision 1.5  2000/01/14 01:14:05  lungu
! Corrected passing sd_id and not L1FileHandle to l1bInfo.
!
! Revision 1.4  2000/01/12 17:31:58  lungu
! Code for opening L1 Rad and OA files.
!
! Revision 1.1  2000/01/07 22:18:37  lungu
! Changed location from lib to l2.
!
! Revision 1.3  2000/01/07 19:50:13  lungu
! "Clean" version, ready to handle read_parse_l2cf.
!
! Revision 1.2  2000/01/07 01:55:07  lungu
! Release containing only open l1 and obtain a priori subroutines.
!
! Revision 1.1  2000/01/05 02:12:39  lungu
! Added subroutines to handle GriddedData
!

@


