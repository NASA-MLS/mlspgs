head	2.121;
access;
symbols
	v5-02-NRT-19:2.121
	v6-00:2.121
	v5-02-NRT-18:2.121
	v5-02:2.120
	v5-01-NRT-17:2.121
	v5-01-NRT-16:2.121
	v5-01-NRT-15:2.121
	v5-01-NRT-14:2.121
	neuralnetworks-1-0:2.121.0.4
	cfm-single-freq-0-1:2.121.0.2
	v5-01:2.120
	v5-00:2.120
	v4-23-TA133:2.119.0.2
	mus-emls-1-70:2.117.0.2
	rel-1-0-englocks-work:2.116.0.2
	VUMLS1-00:2.113
	VPL1-00:2.113
	V4-22-NRT-08:2.113
	VAM1-00:2.112
	V4-21:2.111.0.2
	V4-13:2.111
	V4-12:2.109
	V4-11:2.109
	V4-10:2.109
	V3-43:2.94
	M4-00:2.103
	V3-41:2.94
	V3-40-PlusGM57:2.94.0.2
	V2-24-NRT-04:2.84
	V3-33:2.96
	V2-24:2.84
	V3-31:2.96
	V3-30-NRT-05:2.96
	cfm-01-00:2.96
	V3-30:2.94
	V3-20:2.94
	V3-10:2.93
	V2-23-NRT-02:2.84
	V2-23:2.84
	V2-22-NRT-01:2.84
	V2-22:2.84
	V2-21:2.82
	V2-20:2.78
	V2-11:2.75
	V2-10:2.75
	V2-00:2.75
	V1-51:2.70
	V1-50:2.70
	V1-45:2.66
	V1-44:2.66
	V1-43:2.62
	V1-32:2.61
	V1-31:2.60
	V1-30:2.56
	V1-13:2.43
	V1-12:2.43
	V1-11:2.43
	V1-10:2.42
	newfwm-feb03:2.42.0.2
	V1-04:2.30
	V1-03:2.30
	V1-02:2.30
	JointForwardModel:2.35.0.2
	V1-00:2.27
	newfwm-sep01:2.17.0.2
	V0-7:2.16
	V0-5-Level2:2.1;
locks; strict;
comment	@# @;


2.121
date	2020.07.22.22.57.14;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2019.07.22.22.30.29;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2018.09.13.20.26.07;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2018.07.27.23.18.48;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2018.04.19.01.14.16;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2018.02.09.01.27.31;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2017.12.22.00.34.41;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2017.12.07.01.01.23;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2016.02.29.19.50.46;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2015.03.28.02.48.22;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2014.09.05.01.06.08;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2014.09.05.00.49.06;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2014.04.22.18.17.22;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2013.12.05.01.45.32;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2013.08.30.02.45.43;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2013.04.05.23.31.46;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2013.02.14.19.02.27;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2012.07.02.20.38.02;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2012.03.28.20.05.54;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2011.08.03.21.57.23;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2011.05.26.20.39.34;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2011.05.09.18.21.38;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2010.05.13.23.47.19;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2010.04.22.23.34.47;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2009.09.18.00.30.25;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2009.06.16.17.41.19;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2009.03.18.23.08.27;	author honghanh;	state Exp;
branches;
next	2.90;

2.90
date	2009.01.12.19.22.04;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2008.06.12.22.28.27;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2008.04.03.00.13.39;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2008.01.23.21.26.01;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2007.12.07.01.51.08;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2007.11.01.23.31.47;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2007.09.06.23.34.06;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2007.02.27.00.01.46;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2007.02.14.17.29.51;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2007.02.13.21.36.19;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2007.01.12.00.38.57;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2006.11.22.18.11.04;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2006.10.11.00.30.15;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2006.09.29.00.29.42;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2006.08.05.02.12.27;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2006.04.20.23.21.37;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2005.03.24.21.22.32;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2005.03.15.23.55.48;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2005.02.03.19.09.15;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2004.12.27.23.04.21;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2004.12.14.21.54.23;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2004.09.16.23.57.31;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2004.09.16.00.18.03;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2004.08.05.22.47.47;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2004.08.03.23.14.56;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2004.06.10.00.58.45;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2004.05.19.19.16.11;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2004.04.16.00.47.54;	author livesey;	state Exp;
branches;
next	2.61;

2.61
date	2004.01.22.00.56.35;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2004.01.02.23.36.00;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2003.11.15.00.34.38;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2003.11.14.23.37.13;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2003.09.24.23.41.55;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2003.08.01.20.28.05;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2003.07.11.21.50.02;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2003.07.11.01.23.59;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2003.07.08.17.30.43;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2003.07.07.17.32.00;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2003.07.02.00.54.10;	author livesey;	state Exp;
branches;
next	2.50;

2.50
date	2003.07.01.16.30.52;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2003.06.20.19.38.25;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2003.06.05.23.53.34;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2003.05.22.02.23.59;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2003.05.13.04.48.06;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2003.05.12.02.06.48;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2003.05.10.22.30.12;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2003.02.20.20.32.56;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2003.01.17.21.54.12;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2002.11.08.21.24.00;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2002.10.17.18.19.24;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2002.10.08.17.36.21;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2002.10.05.00.43.34;	author livesey;	state Exp;
branches;
next	2.37;

2.37
date	2002.08.20.04.31.39;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2002.07.18.02.15.29;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2002.05.29.22.43.22;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2002.05.29.21.55.11;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2002.05.22.00.48.36;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2002.05.21.01.12.05;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2002.05.08.16.19.29;	author livesey;	state Exp;
branches
	2.31.2.1;
next	2.30;

2.30
date	2002.04.24.20.20.53;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2002.04.24.16.53.38;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2002.04.08.20.49.17;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2002.03.14.00.15.43;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2002.01.10.01.07.43;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2002.01.09.23.16.34;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2002.01.09.22.55.57;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.11.14.18.03.45;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.11.05.23.21.31;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.10.30.01.45.21;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.09.10.23.39.12;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.09.09.02.52.43;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.09.08.00.21.44;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2001.09.05.20.34.56;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2001.08.02.23.59.22;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2001.08.02.00.18.55;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2001.06.22.05.19.46;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.06.19.22.58.07;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.06.15.19.43.11;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.06.13.20.43.12;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.05.30.23.54.07;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.05.26.00.20.57;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.05.25.05.03.43;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.05.25.04.59.44;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.05.25.01.03.47;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.05.23.21.59.43;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.05.23.03.46.41;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.05.23.03.28.57;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.05.23.01.43.31;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.05.02.23.22.30;	author livesey;	state Exp;
branches;
next	;

2.31.2.1
date	2002.05.22.23.14.25;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.121
log
@Master now passes chunk Start, End times to slave
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module L2Parallel
  ! This module contains low level routines and stuff for dealing with parallel
  ! invocations of the MLSL2 program.

  ! Level 2 programs can be masters or slaves, or neither, not both.  A task
  ! which is neither simply runs through the l2cf as normal.  A master task
  ! does the chunk divide and then launches slave tasks for each chunk, and
  ! awaits their results in the Join section.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use BitStuff, only: BitsToBooleans, BooleansToBits
  use Chunks_M, only: Dump, MLSChunk_T
  use ChunkDivide_M, only: ChunkDivideConfig
  use Dump_0, only: Dump
  use HighOutput, only: BeVerbose, Banner, OutputNamedValue, TimeStamp
  use L2ParInfo, only: Machine_T, Parallel, &
    & Chunktag, Giveuptag, Grantedtag, Notifytag, Masterdumptag, Petitiontag, &
    & Sig_Tojoin, Sig_Finished, Sig_Ackfinish, Sig_Register, &
    & Sig_Requestdirectwrite, Sig_Swearallegiance, Sig_Switchallegiance, &
    & Sig_Directwritegranted, Sig_Directwritefinished, &
    & Sig_Hostdied, Sig_Releasehost, Sig_Requesthost, Sig_Thankshost, &
    & Getnicetidstring, Slavearguments, Machinenamelen, Getmachines, &
    & Machinefixedtag, Directwriterequest_T, &
    & Dw_Pending, Dw_Inprogress, Dw_Completed, &
    & Inflatedirectwriterequestdb, Compactdirectwriterequestdb, Dump, &
    & AddmachinetoDatabase, SigToName
  use Machine, only: Shell_Command, Usleep
  use MLSKinds, only: R8
  use MLSL2options, only: L2Options, OriginalOptions, MLSL2Message
  use MLSMessagemodule, only: MLSMSG_Error, MLSMSG_Warning, PVMErrorMessage
  use MLSFinds, only: Findall, Findfirst
  use MLSStringlists, only: Catlists, Expandstringrange, Removenumfromlist, &
    & Replacesubstring, Switchdetail
  use MLSStrings, only: Lowercase
  use MorePVM, only: PVMunpackstringindex, PVMpackstringindex
  use MLSStrings, only: NAppearances
  use Output_M, only: Blanks, Output
  use PVM, only: Infotag, &
    & PVMDatadefault, PVMFinitSend, PVMf90Pack, PVMFKill, &
    & PVMF90unpack, PVMtaskhost, &
    & MyPVMSpawn, PVMFCatchout, PVMFSend, PVMFNotify, PVMTaskExit, &
    & GetMachineNameFromTID, PVMFFreeBuf, Sig_Abouttodie
  use PVMidl, only: PVMidlunpack
  use String_Table, only: Display_String
  use Time_M, only: Time_Now
  use Toggles, only: Gen, Switches, Toggle
  use Trace_M, only: Trace_Begin, Trace_End
  use WriteMetaData, only: L2pcf

  implicit none
  private

  public :: L2MasterTask
  public :: GetChunkinfoFromMaster
  
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L2Parallel.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! Parameters
  integer, parameter :: HDFNAMELEN = 132 ! Max length of name of swath/sd
  character(len=*), parameter :: &
    &                   GROUPNAME = "mlsl2" ! Set by l2q
  logical, parameter :: NOTFORGOTTEN = .false. ! Note the death of forgottens
  integer, save      :: FIXDELAYFORSLAVETOFINISH   = 1500000 ! 15000000 ! 15 sec
  integer, save      :: KILLINGSLAVESDELAY   = 1000000 ! 1 sec
  ! ***********************************************************************
  ! The following must be longer than the ???? setting in
  ! slavettmplt.sh
  integer, save      :: WaitBeforeKillingSlaves   = 130*1000000 ! 130 sec
  !                      Note: This must be > pgekilldelay in slavetmplt.sh
  ! ***********************************************************************

  ! Private types
  type StoredResult_T
    integer :: key                      ! Tree node for this join
    logical :: gotPrecision             ! If set have precision as well as value
    integer, dimension(:), pointer :: valInds=>NULL() ! Array vec. dtbs. inds (noChunks)
    integer, dimension(:), pointer :: precInds=>NULL() ! Array vec. dtbs. inds (noChunks)
    character(len=HDFNameLen) :: hdfName ! Name of swath/sd
  end type StoredResult_T

contains 
! ================================ Public Procedures ======================
  ! ----------------------------------------------- GetChunkInfoFromMaster ------
  subroutine GetChunkInfoFromMaster ( chunks, chunkNo )
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    ! This function gets a chunk sent by SendChunkToSlave

    ! Dummy arguments and result
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS
    integer, intent(out) :: CHUNKNO

    ! Local parameters
    integer, parameter :: noChunkTerms = 5 ! Number of components in MLSChunk_T

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: BITS
    integer :: BUFFERID                 ! ID for buffer for receive
    integer :: CHUNK                    ! Loop counter
    integer :: INFO                     ! Flag from PVM
    integer :: STATUS                   ! From allocate
    integer :: NOCHUNKS                 ! Size.
    integer :: NOHGRIDS                 ! Size of hGrid information
    integer, dimension(2) :: HEADER     ! No chunks, chunkNo
    logical, dimension(2) :: LOGICALS   ! Allow overlaps outside proc. rnge?
    integer, dimension(noChunkTerms) :: VALUES ! Chunk as integer array

    ! Executable code
    if ( .not. parallel%slave ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'Only slave tasks can receive a chunk' )

    call PVMFrecv ( parallel%masterTid, ChunkTAG, bufferID )
    if ( bufferID <= 0 ) &
      & call PVMErrorMessage ( info, 'receiving chunkInfo' )

    call PVMF90Unpack ( header, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'unpacking chunkInfo header')
    noChunks = header(1)
    chunkNo = header(2)
    
    allocate ( chunks ( noChunks ), STAT=status)
    addr = 0
    if ( status == 0 .and. noChunks>0 ) addr = transfer(c_loc(chunks(1)), addr)
    call test_allocate ( status, moduleName, 'chunks', uBounds = noChunks, &
      & elementSize = storage_size(chunks) / 8, address=addr )

    do chunk = 1, noChunks
      call PVMF90Unpack ( values, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking one chunk')
      chunks(chunk)%firstMAFIndex = values(1)
      chunks(chunk)%lastMAFIndex = values(2)
      chunks(chunk)%noMAFsLowerOverlap = values(3)
      chunks(chunk)%noMAFsUpperOverlap = values(4)
      chunks(chunk)%chunkNumber = values(5)

      call PVMF90Unpack ( noHGrids, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking noHGrids')
      call Allocate_test ( chunks(chunk)%hGridOffsets, noHGrids, &
        & 'hGridOffsets', ModuleName )
      call PVMF90Unpack ( chunks(chunk)%hGridOffsets, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking hGridOffsets')

      call PVMF90Unpack ( noHGrids, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking noHGrids')
      call Allocate_test ( chunks(chunk)%hGridTotals, noHGrids, &
        & 'hGridTotals', ModuleName )
      call PVMF90Unpack ( chunks(chunk)%hGridTotals, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking hGridTotals')

      ! The latest components of the MLSChunk_T
      call PVMF90UnPack ( chunks(chunk)%StartTime, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking Start time of chunk' )
      call PVMF90UnPack ( chunks(chunk)%EndTime, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'unpacking End time of chunk' )
    end do

    call PVMF90Unpack ( bits, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'unpacking overlaps outside proc. rnge')
    call BitsToBooleans( Bits, logicals )
    ChunkDivideConfig%allowPriorOverlaps = logicals(1)
    ChunkDivideConfig%allowPostOverlaps  = logicals(2)
    if( BeVerbose( 'opt', -1 ) .or. parallel%verbosity > 0 ) then
      call output(' (chunk info received from master) ', advance='yes')
      call output(' Chunk number                       :            ', advance='no')
      call blanks(4, advance='no')
      call output(chunkno, advance='yes')
      call output(' Allow overlaps outside proc. range?:            ', advance='no')
      call blanks(4, advance='no')
      call output(ChunkDivideConfig%allowPriorOverlaps, advance='no')
      call blanks(4, advance='no')
      call output(ChunkDivideConfig%allowPostOverlaps, advance='yes')
    endif
    if ( BeVerbose( 'chu', -1 ) ) call dump ( chunks )
     L2Options%currentChunkNumber = chunkno
     OriginalOptions%currentChunkNumber = chunkno

  end subroutine GetChunkInfoFromMaster

  ! --------------------------------------------- L2MasterTask ----------
  subroutine L2MasterTask ( chunks )
    ! This is a `master' task for the l2 software
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS

    ! Local parameter
    integer, parameter :: MAXDIRECTWRITEFILES=200 ! For internal array sizing
    integer, parameter :: DATABASEINFLATION=100

    ! External (C) function

    ! Local variables
    logical :: MACHINEREQUESTQUEUED     ! Set if waiting for a free machine
    logical :: SKIPDELAY                ! Don't wait before doing the next go round
    logical :: SKIPDEATHWATCH           ! Don't check for deaths
    logical :: USINGOLDSUBMIT           ! Set if using the old submit mechanism
    logical :: USINGSUBMIT              ! Set if using the submit or l2q
    logical :: USINGL2Q                 ! Set if using the l2q queue manager
    character(len=MachineNameLen) :: THISNAME
    character(len=8) :: CHUNKNOSTR
    character(len=2048) :: COMMANDLINE
    character(len=16) :: DATESTRING

    integer :: BUFFERIDRCV              ! From PVM
    integer :: BUFFERIDSND              ! From PVM
    integer :: BYTES                    ! Dummy from PVMFBufInfo
    integer :: CHUNK                    ! Loop counter
    integer :: CREATEFILE               ! Flag for direct writes
    integer :: DEADCHUNK                ! A chunk from a dead task
    integer :: DEADMACHINE              ! A machine for a dead task
    integer :: DEADTID                  ! A task that's died
    integer :: DUMMY                    ! From inflate database
    logical :: DUMPFULLDWREQS
    integer :: FILEINDEX                ! Index for a direct write
    integer :: INDX                     ! Where "T" occurs in utc string
    integer :: INFO                     ! From PVM
    integer :: L2QTID                   ! TID of queue manager
    integer :: MACHINE                  ! Index
    integer :: Me = -1                  ! String index for trace
    integer :: MSGTAG                   ! Dummy from PVMFBufInfo
    integer :: NEXTCHUNK                ! A chunk number
    integer :: NEXTTICKET               ! For direct write handling
    integer :: NOCHUNKS                 ! Number of chunks
    integer :: NODE                     ! A tree node
    integer :: NODIRECTWRITEFILES       ! Need to keep track of filenames
    integer :: NODIRECTWRITEREQUESTS    ! Number of (relevantish) directWrite requests
    integer :: NOMACHINES               ! Number of slaves
    integer :: REQUESTEDFILE            ! String index from slave
    integer :: REQUESTINDEX             ! Index of direct write request
    integer :: REQUESTINDEXA(1)         ! Result of minloc
    integer :: RETURNEDTICKET           ! Ticket for completed direct write
    character ( len=256 ) :: sbmtdSlaveArg1, sbmtdSlaveArg2
    character ( len=2048 ) :: sbmtdSlaveArguments ! To remove --chunks if present
    integer :: SIGNAL                   ! From slave
    integer :: SLAVETID                 ! One slave
    ! integer :: STAGEFILEID              ! From HDF5
    integer :: TIDARR(1)                ! One tid

    integer, dimension(size(chunks)) :: CHUNKMACHINES ! Machine indices for chunks
    integer, dimension(size(chunks)) :: CHUNKTIDS ! Tids for chunks
    character(len=16), dimension(size(chunks)) :: CHUNKNICETIDS ! Tids for chunks

    integer, dimension(maxDirectWriteFiles) :: DIRECTWRITEFILENAMES
    logical, dimension(maxDirectWriteFiles) :: DIRECTWRITEFILEBUSY
    real(r8), dimension(maxDirectWriteFiles) :: TIMEDWFILEBEGAN
    real(r8), dimension(maxDirectWriteFiles) :: MAXTIMEDWFILETOOK
    integer, dimension(maxDirectWriteFiles) :: NODIRECTWRITECHUNKS

    logical, dimension(size(chunks)) :: CHUNKSCOMPLETED ! Chunks completed
    logical, dimension(size(chunks)) :: CHUNKSSTARTED ! Chunks being processed
    logical, dimension(size(chunks)) :: CHUNKSABANDONED ! Chunks kept failing
    integer, dimension(size(chunks)) :: CHUNKFAILURES ! Failure count
    logical, dimension(size(chunks)) :: CHUNKSWRITING ! Which chunks are writing
    real(r8), dimension(maxDirectWriteFiles) :: MAXTIMECHUNKSPENTWRITING

    logical, save :: FINISHED = .false. ! This will be called multiple times

    type (Machine_T),dimension(:), pointer :: Machines
    type (Machine_T)                       :: thisMachine
    ! Local vector database
    type (StoredResult_T), dimension(:), pointer :: storedResults
    ! Map into the above arrays
    type (DirectWriteRequest_T), dimension(:), pointer :: DIRECTWRITEREQUESTS
    type (DirectWriteRequest_T), pointer :: REQUEST

    ! Executable code --------------------------------
    KILLINGSLAVESDELAY   = 100*parallel%delay
    ! First, is this the first call. The first call does all the work
    ! so if it's not then quit.
    if ( finished ) return

    call trace_begin ( me, "L2MasterTask", cond=toggle(gen))
    usingSubmit = trim(parallel%submit) /= ''
    usingL2Q = ( index(parallel%submit, 'l2q') > 0 )
    USINGOLDSUBMIT = USINGSUBMIT .and. .not. usingL2Q

    ! Setup some stuff
    noChunks = size(chunks)
    nullify ( machines, storedResults, &
      & directWriteRequests )
    noDirectWriteRequests = 0
    directWriteFileNames = 0
    noDirectWriteChunks = 0
    directWriteFileBusy = .false.
    timeDWFileBegan = 0.d0
    maxTimeDWFileTook = 0.d0
    maxTimeChunkSpentWriting = 0.d0
    noDirectWriteFiles = 0
    nextTicket = 1

    ! Setup the directWrite request database with a default size.
    dummy = InflateDirectWriteRequestDB ( directWriteRequests, DatabaseInflation )

    ! Work out the information on our virtual machine
    if ( usingL2Q ) then
      call RegisterWithL2Q(noChunks, machines, L2QTID)
      noMachines = size(machines)
      if ( noMachines < 1 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'No machines available for master to assign to slave tasks' )
      if ( .not. any(machines%OK) ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'No machines OK for master to assign to slave tasks' )
      if ( BeVerbose( 'mach', -1 ) .or. &
        & parallel%verbosity > 1 ) call dump ( machines )
    elseif ( .not. usingSubmit ) then
      call GetMachines ( machines )
      noMachines = size(machines)
      if ( noMachines < 1 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'No machines available for master to assign to slave tasks' )
      if ( .not. any(machines%OK) ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'No machines OK for master to assign to slave tasks' )
      if ( BeVerbose( 'mach', -1 ).or. &
        & parallel%verbosity > 1 ) call dump ( machines )
    else
      noMachines = 0
    end if

    ! Loop until all chunks are done
    chunksCompleted = .false.
    chunksStarted = .false.
    chunksAbandoned = .false.
    chunksWriting = .false.
    chunkFailures = 0
    chunkTids = 0
    CHUNKNICETIDS = ' '
    chunkMachines = 0
    ! Special switches to control which chunks to process
    ! by pre-abandoning the others right off the bat
    ! Note that this leaves output files possibly as big
    ! as if you ran all the chunks anyway
    
    ! Why isn't '3' actually '2' in the following test?
    if ( size(chunks) < 3 ) then
    elseif ( parallel%chunkRange /= '' ) then
      chunksAbandoned = .true.
      call ExpandStringRange(trim(parallel%chunkRange), chunksAbandoned, &
        & sense=.false.)
      if ( all(chunksAbandoned) ) then
        call KillSlaves ( .true., &
          & 'No chunks to process-was your request within range?' )
      endif
    endif
    if ( BeVerbose( 'l2q', -1 ) ) then
      call outputnamedValue( 'size(chunks)', size(chunks) )
      call outputnamedValue( 'parallel%chunkRange', trim(parallel%chunkRange) )
      call dump( chunksAbandoned, 'chunksAbandoned', options='N' )
    endif

    machineRequestQueued = .false. ! Request one machine at a time from L2Q
    masterLoop: do ! --------------------------- Master loop -----------------------
      skipDelay = .false.               ! Assume we're going to delay
      skipDeathWatch = .false.          ! Assume we'll listen for slave deaths
      ! This loop is in two main parts.

      ! In the first part, we look to see if there are any chunks still to be
      ! started done, and any vacant machines to do them.
      ! --------------------------------------------------------- Start new jobs? --
      do while ( chunkAndMachineReady() ) ! (nextChunk, machine) )
        if ( nextChunk < 1 ) then
          ! Should have returned false
          call KillSlaves (.true., 'Illegal chunk number' )
        elseif ( USINGOLDSUBMIT ) then ! -- Using a batch system
          ! We must remove any --chunk chunkRange from slaveArguments
          info = index(lowerCase(slaveArguments), '--chunk')
          if ( info > 0 ) then
            if ( info == 1 ) then
              sbmtdSlaveArg1 = ' '
            else
              sbmtdSlaveArg1 = slaveArguments(1:info-1)
            endif
            call RemoveNumFromList( slaveArguments(info:), sbmtdSlaveArguments, 1, ' ' )
            call RemoveNumFromList( sbmtdSlaveArguments, sbmtdSlaveArg2, 1, ' ' )
            sbmtdSlaveArguments = trim(sbmtdSlaveArg1) // ' ' // sbmtdSlaveArg2
          else
            sbmtdSlaveArguments = slaveArguments
          endif
          write ( chunkNoStr, '(i0)' ) nextChunk
          commandLine = &
            & trim(parallel%submit) // ' ' // &
            & trim(parallel%executable) // ' ' // &
            & ' --chunk ' // trim(chunkNoStr) // ' ' // &
            & trim(sbmtdSlaveArguments)
          call shell_command ( trim(commandLine) )
          chunksStarted(nextChunk) = .true.
          skipDeathWatch = .true.
          ! We'll have to wait for it to come one line later
          if ( parallel%verbosity > 0 ) then
            call output ( 'Submitted chunk ' )
            call TimeStamp ( nextChunk, advance='yes' )
          end if
        elseif ( machine < 1 ) then
          ! Just go on; should have returned .false. anyway
          exit
        else ! ------------------------------------- Start job using pvmspawn
          commandLine = trim(parallel%pgeName)   ! was 'mlsl2'
          if ( BeVerbose( 'slv', -1 ) ) then
            call PVMFCatchOut ( 1, info )
            if ( info /= 0 ) call PVMErrorMessage ( info, "calling catchout" )
          end if
          info = myPVMSpawn ( trim(commandLine), PvmTaskHost, &
            & trim(machines(machine)%Name), &
            & 1, tidarr )
          call output (tidarr(1), advance = 'no')
          call output (' result is ', advance='no')
          call output (info, advance = 'yes')
          if ( parallel%verbosity > 0 ) then
            call output ( 'Tried to spawn ' )
            call TimeStamp ( trim(commandLine), advance='yes' )
            call output ( 'PvmTaskHost ' )
            call output ( PvmTaskHost, advance='yes' )
            call output ( 'on machine ' )
            call output ( trim(machines(machine)%Name), advance='yes' )
            call output ( 'result was ' )
            call output ( info, advance='yes' )
          end if

          ! Did this launch work
          if ( info == 1 ) then
            machines(machine)%free = .false.
            machines(machine)%tid = tidArr(1)
            machines(machine)%chunk = nextChunk
            indx = INDEX (L2PCF%startUTC, "T")
            if ( indx > 0 ) then
              DateString = L2PCF%startUTC(1:indx-1)
              call ReplaceSubString ( DateString, machines(machine)%master_Date, &
                & '-', 'd' )
            endif
            chunkMachines(nextChunk) = machine
            chunkTids(nextChunk) = tidArr(1)
            chunkNiceTids(nextChunk) = GetNiceTidString(chunkTids(nextChunk))
            chunksStarted(nextChunk) = .true.
            if ( parallel%verbosity > 0 ) then
              if ( BeVerbose( 'l2q', 0 ) ) then
                call output ( tidArr(1) )
                call output ( ' ' )
              endif
              call output ( 'Launched chunk ' )
              call output ( nextChunk )
              call TimeStamp ( ' on slave ' // trim(machines(machine)%name) // &
                & ' ' // trim(chunkNiceTids(nextChunk)), &
                & advance='yes' )
            end if
            if ( BeVerbose( 'l2q', 0 ) ) &
              & call output ( chunkTids(nextChunk), advance='yes' )
            call WelcomeSlave ( nextChunk, chunkTids(nextChunk) )
            if ( usingL2Q ) call ThankL2Q(machines(machine), L2Qtid)
            skipDeathWatch = .true.
          else
            ! Couldn't start this job, mark this machine as unreliable
            if ( parallel%verbosity > 0 ) then
              call output ( 'Unable to start slave task on ' // &
                & trim(machines(machine)%Name) // ' info=' )
              if ( info == -6 ) then
                call TimeStamp ( '(pvm demon dispirited)', advance='yes' )
              elseif ( info == -7 ) then
                call TimeStamp ( '(file system problem)', advance='yes' )
              elseif ( info < 0 ) then
                call TimeStamp ( info, advance='yes' )
              else
                call TimeStamp ( tidArr(1), advance='yes' )
              end if
              call TimeStamp ( 'Marking this machine as not usable', advance='yes')
            end if
            ! Mark all instances of this machine as not to be used.
            where ( machines%Name == machines(machine)%Name )
              machines%OK = .false.
            end where
            ! Send bad news back to l2 queue manager
            if ( usingL2Q ) then
              call TellL2QMachineDied( machines(machine), L2Qtid )
            endif
          end if
        end if
      end do

      ! --------------------------------------------------- Messages from jobs?
      ! In this next part, we listen out for communication from the slaves and
      ! process it accordingly.
      call PVMFNRecv( -1, InfoTag, bufferIDRcv )
      if ( bufferIDRcv < 0 ) then
        call PVMErrorMessage ( info, "checking for Info message" )
      else if ( bufferIDRcv > 0 ) then
        ! So we got a message.  There may be another one following on so don't delay
        ! before going round this loop again.
        skipDelay = .true.
        skipDeathWatch = .true.
        ! Who sent this?
        call PVMFBufInfo ( bufferIDRcv, bytes, msgTag, slaveTid, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, "calling PVMFBufInfo" )
        call PVMF90Unpack ( signal, info )
        if ( info /= 0 ) then
          call PVMErrorMessage ( info, "unpacking signal" )
        endif

        ! Who did this come from
        ! chunk = FindFirst ( chunkTids, slaveTid )
        machine = 0
        if ( associated(machines) ) &
          & machine = FindFirst ( machines%tid, slaveTid )
        if ( USINGOLDSUBMIT ) then
          chunk = FindFirst ( chunkTids, slaveTid )
          if ( chunk == 0 .and. signal /= sig_register ) then
            call output ( 'Signal is:' )
            call output ( signal )
            call outputNamedValue ( ' meaning', SigToName(signal) )
            call TimeStamp ( ' Tid: ' // trim ( GetNiceTidString ( slaveTid ) ), &
              & advance='yes' )
            call MLSL2Message ( MLSMSG_Warning, ModuleName, &
              & "Got a message from an unknown slave" )
          endif
        ! if ( chunk == 0 .and. &
        elseif ( machine == 0 ) then
          call output ( 'Signal is:' )
          call output ( signal )
          call outputNamedValue ( ' meaning', SigToName(signal) )
          call TimeStamp ( ' Tid: ' // trim ( GetNiceTidString ( slaveTid ) ), &
            & advance='yes' )
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & "Got a message from an unknown slave" )
          call dump ( chunkNiceTids, 'chunkNiceTids', options='t' )
          call TimeStamp ( slaveTid, advance='yes' )
          call dump ( chunkTids, 'chunkTids', format='places=10' )
          call dump ( machines%tid, 'machines%Tid', format='places=10' )
          cycle masterLoop
        else
          ! Unpack the first integer in the buffer
          if ( .not. USINGOLDSUBMIT .and. signal /= sig_register ) &
            & chunk = machines(machine)%chunk
            ! & machine = chunkMachines(chunk)
        end if

        select case (signal) 

        case ( sig_abouttodie ) ! --------------- Slave is about to die ---------
          call PVMF90Unpack ( commandLine, info )
          if ( info /= 0 ) then
            call PVMErrorMessage ( info, "unpacking last gasp message" )
          endif
          write ( chunkNoStr, '(i0)' ) chunk
          commandLine = '(' // trim(chunkNoStr) // ')' // commandLine
          parallel%failedMsgs = catLists(parallel%failedMsgs, commandLine, '\')

        case ( sig_register ) ! ----------------- Chunk registering ------
          call PVMF90Unpack ( chunk, info )
          if ( info /= 0 ) then
            call PVMErrorMessage ( info, "unpacking chunk number" )
          endif
          ! Note, we'll ignore the slave MAFNumber sent for fwmParallel stuff
          if ( USINGOLDSUBMIT ) then
            ! We only really care about this message if we're using submit
            
            ! A crude hack to fix a sometimes mlssubmit/pvm error
            ! in which multiple jobs are submitted for the same chunk
            ! (Why??)
            ! No time to explore, we're in the middle of v3 development
            !
            ! What to do?
            
            ! Kill the excess slave and continue
            ! (You're a cruel one, paw)
            if ( chunkTids(chunk) > 0 ) then
              call pvmfkill ( slaveTid, info )
              if ( info /= 0 ) &
                & call PVMErrorMessage ( info, 'killing slave' )
              call output ( 'Killed off excess slave ' // &
                & trim(GetNiceTidString(slaveTid)) // &
                & ' running chunk ' )
              call TimeStamp ( chunk, advance='yes' )
              cycle
            endif
            chunkTids(chunk) = slaveTid
            call GetMachineNameFromTid ( slaveTid, thisName, info )
            if ( info == -1 ) &
              & call KillSlaves (.true., 'Unable to get machine name from tid' )
            call WelcomeSlave ( chunk, slaveTid )
            if ( parallel%verbosity > 0 ) then
              call output ( 'Welcomed task ' // &
                & trim(GetNiceTidString(slaveTid)) // &
                & ' running chunk ' )
              call TimeStamp ( chunk, advance='yes' )
            end if
          endif

        case ( sig_tojoin ) ! --------------- Got a join request ---------
          call MLSL2Message ( MLSMSG_Error, ModuleName, &
            & 'This version does not support slave Join commands' )

        case ( sig_RequestDirectWrite ) ! ------- Direct write permission --
          ! What file did they ask for?
          call PVMUnpackStringIndex ( requestedFile, info )
          if ( info /= 0 )  call PVMErrorMessage ( info, &
            & "unpacking direct write request filename" )
          call PVMF90Unpack ( node, info )
          if ( info /= 0 )  call PVMErrorMessage ( info, &
            & "unpacking direct write request node" )
          ! Is this a new file?
          fileIndex = FindFirst ( directWriteFilenames(1:noDirectWriteFiles), &
            & requestedFile )
          if ( fileIndex == 0 ) then
            ! Clearly, if we don't know about this file it's new
            noDirectWriteFiles = noDirectWriteFiles + 1
            if ( noDirectWriteFiles > maxDirectWriteFiles ) &
              & call KillSlaves (.true., 'Too many direct write files, ' &
              & // 'increase limit maxDirectWriteFiles in ' // ModuleName )
            fileIndex = noDirectWriteFiles
            directWriteFilenames ( fileIndex ) = requestedFile
          end if
          if ( size(directWriteRequests) == noDirectWriteRequests ) then
            dummy = InflateDirectWriteRequestDB ( directWriteRequests, DatabaseInflation )
          end if
          noDirectWriteRequests = noDirectWriteRequests + 1
          request => directWriteRequests ( noDirectWriteRequests )
          ! Record this request, and have it 'take a ticket'
          request%chunk = chunk
          if ( .not. USINGOLDSUBMIT ) request%machine = machine
          request%node = node
          request%fileIndex = fileIndex
          request%ticket = nextTicket
          request%status = DW_Pending
          call time_now(request%whenMade)
          nextTicket = nextTicket + 1

          if ( parallel%verbosity > 1 ) then
            call output ( 'Direct write request from ' )
            if ( .not. USINGOLDSUBMIT ) &
              & call output ( trim(machines(machine)%Name) // ', ' )
            call output ( trim(GetNiceTidString(slaveTid)) )
            call output ( ' chunk ' )
            call output ( chunk )
            call output ( ' ticket ' )
            call output ( nextTicket - 1, advance='no' )
            call output ( ' index ' )
            call output ( fileIndex, advance='no' )
            call output ( ' file ' )
            call TimeStamp ( directWriteFilenames ( fileIndex ), advance='yes' )
            call display_string ( requestedFile, strip=.true., advance='yes' )
          end if

        case ( sig_DirectWriteFinished ) ! - Finished with direct write -
          ! Unpack the ticket number we got back
          call PVMF90Unpack ( returnedTicket, info )
          if ( info /= 0 ) call PVMErrorMessage ( info, &
            & "unpacking returned ticket" )
          ! Record that the chunk has finished direct write
          requestIndex = FindFirst ( directWriteRequests%ticket, returnedTicket )

          request => directWriteRequests(requestIndex)
          request%status = DW_Completed
          call time_now(request%whenFinished)
          fileIndex = request%fileIndex
          directWriteFileBusy ( fileIndex ) = .false.
          chunksWriting ( chunk ) = .false.
          noDirectWriteChunks ( fileIndex ) = noDirectWriteChunks ( fileIndex ) + 1
          if ( parallel%verbosity > 1 ) then
            call output ( 'Direct write finished from ' )
            if ( .not. USINGOLDSUBMIT ) &
              & call output ( trim(machines(machine)%Name) // ', ' )
            call output ( trim(GetNiceTidString(slaveTid)) )
            call output ( ' chunk ' )
            call output ( chunk )
            call output ( ' ticket ' )
            call TimeStamp ( returnedTicket, advance='yes')
            if ( BeVerbose( 'dwtime', -1 ) ) then
              call output ( ' after ' )
              call output( timeDWHasBeenWriting( fileIndex, chunk ) )
              call output ( ' (s) ' )
            endif
            call display_string ( directWriteFilenames(fileIndex), &
              & strip=.true., advance='yes' )
          end if

        case ( sig_finished ) ! -------------- Got a finish message ----
          if ( parallel%verbosity > 0 ) then
            call output ( 'Got a finished message from ' )
            if ( .not. USINGOLDSUBMIT ) &
              & call output ( trim(machines(machine)%Name) // ' ' )
            call output ( trim(GetNiceTidString(slaveTid)) // &
              & ' processing chunk ' )
            call TimeStamp ( chunk, advance='yes')
          endif

          ! Send an acknowledgement
          call PVMFInitSend ( PVMDataDefault, bufferIDSnd )
          if ( bufferIdSnd < 0 ) &
            & call PVMErrorMessage ( bufferIDSnd, 'setting up finish ack.' )
          call PVMF90Pack ( SIG_AckFinish, info )
          if ( info /= 0 ) &
            & call PVMErrorMessage ( info, 'packing finish ack.' )
          call PVMFSend ( slaveTid, InfoTag, info )
          if ( info /= 0 ) &
            & call PVMErrorMessage ( info, 'sending finish ack.' )
          if ( parallel%verbosity > 1 ) &
            & call TimeStamp ( 'Acknowledgment sent', advance='yes')

          ! Now update our information
          chunksCompleted(chunk) = .true.
          chunkTids(chunk) = 0
          if ( .not. USINGOLDSUBMIT ) then
            machines(machine)%free = .true.
            ! Must wait on updating the following--
            ! pvm may tell us later this tid has quit
            ! machines(machine)%tid = 0
            ! machines(machine)%chunk = 0
            chunkMachines(chunk) = 0
          end if
          parallel%numCompletedChunks = parallel%numCompletedChunks + 1
          if ( parallel%verbosity > 0 ) then
            call printMasterStatus
          end if
          ! Send news back to l2 queue manager
          if ( usingL2Q ) then
            call TellL2QMachineFinished( &
              & trim(machines(machine)%name), machines(machine)%tid, L2Qtid, &
              & FIXDELAYFORSLAVETOFINISH )
          endif

        case default
          call KillSlaves (.true., 'Unkown signal from slave')
        end select

        ! Free the receive buffer
        call PVMFFreeBuf ( bufferIDRcv, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'freeing receive buffer' )
      end if

      ! ----------------------------------------------------- Administrative messages?
      ! Listen out for any message telling us to quit now
      call PVMFNRecv ( -1, GiveUpTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        if ( parallel%verbosity > 0 ) then
          call TimeStamp ( 'Received an external message to give up, so finishing now', &
            & advance='yes' )
        end if
        ! We're going to be quitting anyway, so might as well cut the delays
        FIXDELAYFORSLAVETOFINISH = parallel%delay
        KILLINGSLAVESDELAY = parallel%delay
        exit masterLoop
      end if

      ! Listen out for any message telling us to dump current status
      call PVMFNRecv ( -1, masterDumpTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then
        if ( parallel%verbosity > 0 ) then
          call TimeStamp ( 'Received an external message to dump our current status', &
            & advance='yes' )
        end if
        call dumpMastersStatus( chunkmachines, chunknicetids, &
          & directwritefilenames, directwritefilebusy, &
          & chunkscompleted, chunksabandoned, chunkswriting, machines )
      end if

      ! Listen out for any message telling us to switch to a new l2q
      call PVMFNRecv ( -1, sig_switchallegiance, bufferIDRcv )
      if ( bufferIDRcv > 0 .and. usingL2Q ) then
        if ( parallel%verbosity > 0 ) then
          call TimeStamp ( 'Received a message to switch to a new l2q', &
            & advance='yes' )
        end if
        call pvmfgettid(GROUPNAME, 0, L2Qtid)
        if ( L2Qtid < 1 ) then
          call KillSlaves (.true., 'switch l2q queue manager not running--dead or not started yet?')
        else
          call TimeStamp ( 'new l2q tid: ' )
          call TimeStamp ( L2Qtid, advance='yes' )
        endif
        ! Send an acknowledgement, pack machineRequestQueued, swear allegiance
        call PVMFInitSend ( PVMDataDefault, bufferIDSnd )
        if ( bufferIdSnd < 0 ) &
          & call PVMErrorMessage ( bufferIDSnd, 'setting up swearallegiance' )
        call PVMF90Pack ( machineRequestQueued, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing machineRequestQueued' )
        call PVMFSend ( L2Qtid, SIG_swearAllegiance, info )
        call TimeStamp ( 'Sending oath of allegiance; do we need host?: ' )
        call TimeStamp ( machineRequestQueued, advance='yes' )
      end if

      ! Listen out for any message telling us that a machine is OK again
      call PVMFNRecv ( -1, MachineFixedTag, bufferIDRcv )
      if ( bufferIDRcv > 0 ) then 
        ! So we got a message.  There may be another one following on so don't delay
        ! before going round this loop again.
        skipDelay = .true.
        call PVMIDLUnpack ( thisName, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'unpacking machine fixed message' )
        if ( USINGOLDSUBMIT ) then
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'Got unexpected MachineFixed message but using submit method' )
        else
          if ( parallel%verbosity > 0 ) then
            call TimeStamp ( 'Received an external message to trust ' // &
              & trim(thisName) // ' again.' , advance='yes' )
          end if
          where ( machines%Name == thisName )
            machines%OK = .true.
            machines%jobsKilled = 0
          end where
        end if
      end if

      ! Listen out for any message that a slave task has died
      ! ( But only if we're sure there isn't a finished message from it
      !   queued up and waiting for us to read )
      if ( skipDeathWatch ) then
        bufferIDRcv = 0
      else
        call PVMFNRecv ( -1, NotifyTAG, bufferIDRcv )
      endif
      if ( bufferIDRcv > 0 ) then
        ! So we got a message.  There may be another one following on so don't
        ! delay before going round this loop again.
        skipDelay = .true.
        deadTid = 0
        deadChunk = 0
        deadMachine = 0
        ! Get the TID for the dead task
        call PVMF90Unpack ( deadTid, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, 'unpacking deadTid' )
        ! Now this may well be a legitimate exit, detectable by one of 2 cases
        ! either
        ! (1) we won't know about this tid any more
        ! (2) the machine status was reset to free after a finished signal
        ! Otherwise we need to tidy up.
        ! if ( any ( chunkTids == deadTid ) ) then
        !   deadChunk = FindFirst ( chunkTids, deadTid )
        if ( .not. USINGOLDSUBMIT ) then
          deadMachine = FindFirst ( machines%tid, deadTid )
          if ( deadMachine > 0 ) then
            ! On the other hand
            if ( .not. USINGOLDSUBMIT .and. machines(deadMachine)%free ) &
              & deadMachine = 0
          endif
        else
          deadChunk = FindFirst ( chunkTids, deadTid )
          deadMachine = deadChunk ! A trick--only deadChunk matters
        endif

        if ( deadMachine > 0 ) then
          ! Now, to get round a memory management bug, we'll ignore this
          ! if, as far as we're concerned, the task was finished anyway.
          ! if ( deadMachine /= 0 ) then
            if ( .not. USINGOLDSUBMIT ) then
              ! deadMachine = chunkMachines(deadChunk)
              deadChunk = machines(deadMachine)%chunk
              machines(deadMachine)%free = .true.
            end if
            if ( parallel%verbosity > 0 ) then
              if ( BeVerbose( 'l2q', -1 ) ) then
                call output ( deadTID )
                call output ( ' ' )
              endif
              call output ( 'The run of chunk ' )
              call output ( deadChunk )
              call output ( ' ' )
              if ( .not. USINGOLDSUBMIT ) &
                & call output ( 'on ' // trim(machines(deadMachine)%Name) // ' ' )
              call TimeStamp ( trim(GetNiceTidString(deadTid)) // &
                & ' died, try again.', advance='yes' )
            end if
            call CleanUpDeadChunksOutput ( deadChunk, storedResults )
            chunksStarted(deadChunk) = .false.
            chunkFailures(deadChunk) = chunkFailures(deadChunk) + 1
            if ( .not. USINGOLDSUBMIT ) then
              where ( machines(deadMachine)%Name == machines%Name )
                machines%jobsKilled = machines%jobsKilled + 1
              end where
            end if

            ! If the chunk posesses any direct writes, free them up.
            chunksWriting ( deadChunk ) = .false.
            ! First free any files that are in progress
            requestIndex = FindFirst ( directWriteRequests%chunk == deadChunk .and. &
              & directWriteRequests%status == DW_InProgress )
            if ( requestIndex /= 0 ) then
              request => directWriteRequests(requestIndex)
              directWriteFileBusy ( request%fileIndex ) = .false.
            if ( parallel%verbosity > 0 ) then
                call output ( 'Direct write died from ' )
                if ( .not. USINGOLDSUBMIT ) &
                  & call output ( trim(machines(deadMachine)%Name) // ', ' )
                call output ( trim(GetNiceTidString(deadTid)) )
                call output ( ' chunk ' )
                call output ( deadChunk )
                call output ( ' ticket ' )
                call TimeStamp ( request%ticket, advance='yes')
                if ( BeVerbose( 'dwtime', -1 ) ) then
                  call output ( ' after ' )
                  call output( timeDWHasBeenWriting( fileIndex, deadChunk ) )
                  call output ( ' (s) ' )
                endif
                call display_string ( directWriteFilenames(request%fileIndex), &
                  & strip=.true., advance='yes' )
              end if
            end if
            ! Now forget all the requests the dead chunk had pending
            where ( directWriteRequests%chunk == deadChunk )
              directWriteRequests%status = DW_Completed
            end where

            ! Does this chunk keep failing, if so, give up.
            if ( chunkFailures(deadChunk) >= &
              & parallel%maxFailuresPerChunk ) then
              chunksAbandoned(deadChunk) = .true.
            if ( parallel%verbosity > 0 ) then
                call output ( 'Chunk ' )
                call output ( deadChunk )
                call TimeStamp ( ' keeps dying.  Giving up on it.', &
                  & advance='yes' )
                call printMasterStatus
              end if
            end if

            ! Does this machine have a habit of killing jobs.  If so
            ! mark it as not OK.  We can't do much about it though if
            ! we're using submit.
            if ( .not. USINGOLDSUBMIT ) then
              if ( machines(deadMachine)%jobsKilled >= &
                & parallel%maxFailuresPerMachine ) then
              if ( parallel%verbosity > 0 ) &
                  & call TimeStamp ('The machine ' // &
                  & trim(machines(deadMachine)%Name) // &
                  & ' keeps killing things, marking it bad', &
                  & advance='yes' )
                where ( machines(deadMachine)%Name == machines%Name )
                  machines%OK = .false.
                end where
              end if
            end if
            
            ! Save dead chunk number, increment casualty figure
            parallel%failedChunks = catLists(parallel%failedChunks, deadChunk)
            if ( .not. USINGOLDSUBMIT ) &
            & parallel%failedMachs = &
            & catLists(parallel%failedMachs, trim(machines(deadMachine)%Name))
            parallel%numFailedChunks = parallel%numFailedChunks + 1
          else
            ! Otherwise we'd already forgotten about this slave, it told
            ! us it had finished.
            if ( parallel%verbosity > 0 .and. NOTFORGOTTEN ) call TimeStamp ( &
              & "A slave task died after giving results, " // &
              & "we won't worry about it.", &
              & advance='yes' )
          end if
        ! end if
        ! Send bad news back to l2 queue manager
        if ( usingL2Q .and. deadChunk /= 0 ) then
          ! call TellL2QMachineDied( trim(machines(machine)%name), L2Qtid )
          if ( deadTid /= machines(deadMachine)%tid ) then
            call output('deadChunk ', advance='no')
            call output(deadChunk , advance='yes')
            call output('deadTID ', advance='no')
            call output(deadTID , advance='yes')
            call output('machine%tid ', advance='no')
            call output(machines(deadMachine)%tid , advance='yes')
            call KillSlaves (.true., 'Dead slave tid doesnt match machine tid')
          endif
          call TellL2QMachineDied( machines(deadMachine), L2Qtid )
          if ( BeVerbose( 'l2q', -1 ) ) then
            call output ( 'Bad news about chunk ' )
            call output ( deadChunk )
            call TimeStamp ( ' on slave ' // trim(machines(deadMachine)%name) // &
              & ' ' // trim(chunkNiceTids(deadChunk)), &
              & advance='yes' )
          end if
          ! Must zero out its Tid 
          ! (so we won't try to free it when we're finished)
          chunkTids(deadChunk) = 0
        elseif ( usingL2Q ) then
          if ( BeVerbose( 'l2q', -1 ) ) then
            call output ( 'tID ' )
            call output ( deadTID )
            call TimeStamp ( ' finished normally ', advance='yes' )
          end if
        endif
        ! Update info about dead machine
        if ( deadMachine > 0 .and. .not. USINGOLDSUBMIT ) then
          machines(deadMachine)%ok = .false.
          machines(deadMachine)%tid = 0
          machines(deadMachine)%chunk = 0
        endif        
      else if ( bufferIDRcv < 0 ) then
        call PVMErrorMessage ( info, "checking for Notify message" )
      end if

      ! -------------------------------------------- Direct write permission logic ---

      ! Now hand out whatever direct write permissions we are able to give
      ! Give each request a value the same as their ticket number
      directWriteRequests%value = directWriteRequests%ticket
      ! Invalidate all the requests that are not pending
      where ( directWriteRequests%status /= DW_Pending )
        directWriteRequests%value = nextTicket + 1
      end where
      ! Invalidate all requests from a chunk that is busy
      do requestIndex = 1, noDirectWriteRequests
        if ( directWriteRequests(requestIndex)%status == DW_Pending ) then
          if ( chunksWriting(directWriteRequests(requestIndex)%chunk) ) &
            & directWriteRequests(requestIndex)%value = nextTicket + 1
        end if
      end do
      ! Now invalidate all corresponding to busy files
      do fileIndex = 1, noDirectWriteFiles
        if ( directWriteFileBusy ( fileIndex ) ) then
          where ( directWriteRequests%fileIndex == fileIndex )
            directWriteRequests%value = nextTicket + 1
          end where
        end if
      end do
      ! Now find the one with the best cost
      requestIndexA = minloc ( directWriteRequests%value )
      request => directWriteRequests ( requestIndexA(1) )
      ! If we can do this one then do so
      if ( request%value <= nextTicket ) then
        ! So we can do a direct write let's not delay the next time round the loop
        ! in case there are more things we can do immediately
        skipDelay = .true.
        ! OK, we can grant this request, record that in our information
        request%status = DW_InProgress
        call time_now(request%whenGranted)
        fileIndex = request%fileIndex
        directWriteFileBusy ( fileIndex ) = .true.
        call time_now ( timeDWFileBegan(fileIndex) )
        chunksWriting ( request%chunk ) = .true.
        if ( noDirectWriteChunks(fileIndex) == 0 ) then
          createFile = 1
        else
          createFile = 0
        end if
        if ( parallel%verbosity > 1 ) then
          call output ( 'Direct write granted to ' )
          if ( .not. USINGOLDSUBMIT ) &
            & call output ( trim(machines(request%machine)%Name) // ' ' )
          call output ( trim(GetNiceTidString(chunkTids(request%chunk))) )
          call output ( ' chunk ' )
          call output ( request%chunk )
          call output ( ' ticket ' )
          call output ( request%ticket, advance='no' )
          call output ( ' index ' )
          call TimeStamp ( request%fileIndex, advance='yes' )
          call output ( ' file ' )
          call output ( directWriteFilenames(request%fileIndex), advance='yes' )
          call display_string ( directWriteFilenames(request%fileIndex), strip=.true., &
            & advance='yes' )
        end if
        
        ! Tell the slave to go ahead
        call PVMFInitSend ( PvmDataDefault, bufferIdSnd )
        if ( bufferIdSnd < 0 ) &
          & call PVMErrorMessage ( bufferIDSnd, 'setting up direct write granted' )
        call PVMF90Pack ( SIG_DirectWriteGranted, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing direct write granted flag' )
        call PVMF90Pack ( (/ request%node, request%ticket, createFile, &
          & directWriteFilenames(request%fileIndex) /),&
          &  info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing direct write granted info' )
        
        call PVMPackStringIndex ( directWriteFilenames(request%fileIndex), info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, "packing direct write request filename" )
        call PVMFSend ( chunkTids(request%chunk), InfoTag, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'sending direct write granted' )
      end if

      ! Perhaps compact the direct write request database
      if ( count ( directWriteRequests%status /= DW_Completed ) < &
        & noDirectWriteRequests / 2 .and. switchDetail(switches,'dwreq') == -1 ) then
        call CompactDirectWriteRequestDB ( directWriteRequests, noDirectWriteRequests )
        skipDelay = .true. ! This may take time so don't hang around later
      end if

      ! Have we abandoned everything?
      if ( all(chunksAbandoned) ) call KillSlaves ( .true., 'All chunks abandoned' )

      ! If we're done then exit
      if (all(chunksCompleted .or. chunksAbandoned)) then
        if ( parallel%verbosity > 0 ) &
          & call TimeStamp ( 'All chunks either processed or abandoned', advance='yes' )
        exit masterLoop
      end if

      ! Now deal with the case where we have no machines left to use.
      ! When all the chunks that have started have finished (surely this is a
      ! necessary condition anyway?) finish.
      ! Actually it is not a necessary condition as a machine could be listed more
      ! than one time (e.g. when it has multiple processors), and could
      ! have killed one too many jobs, but still have another job running.
      
      ! Oops--this was a bug--if using l2q, someone may revive one or more
      ! dead hosts so we can run, run again
      if ( .not. ( USINGOLDSUBMIT .or. USINGL2Q ) ) then
        if ( .not. any(machines%OK) .and. &
          &  all ( chunksStarted .eqv. chunksCompleted ) ) then
          if ( parallel%verbosity > 0 ) &
            & call TimeStamp ( 'No machines left to do the remaining work', &
            & advance='yes' )
          exit masterLoop
        end if
      end if

      ! Now, rather than chew up cpu time on the master machine, we'll wait a
      ! bit here.
      if ( .not. skipDelay .and. parallel%delay > 0 ) &
        & call usleep ( parallel%delay )
    end do masterLoop ! --------------------- End of master loop --------------

    if ( BeVerbose( 'l2q', -1 )) then
      call TimeStamp ( '   Finished', advance='yes' )
      call dump( chunkNiceTids, 'chunkNiceTids', options='t' )
      call dump( chunkTids, 'chunkTids' )
      call dump( machines%tid, 'machines%Tid', format='(i10)' )
    endif
    ! First kill any children still running (only if we got a give up message).
    call KillSlaves(.false., '')  ! use any string here because isKillMaster = false

    if ( usingL2Q ) then
      call TellL2QMasterFinished(L2Qtid)
      if ( parallel%verbosity > 0 ) &
        & call TimeStamp ( 'Telling l2q we are finished', advance='yes' )
    endif
    ! Now, we have to tidy some stuff up here to ensure we can join things
    where ( .not. chunksCompleted )
      chunksAbandoned = .true.
    end where

    if ( count(chunksCompleted) == 0 ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'No chunks were processed successfully.' )

    if ( BeVerbose( 'dwtime', -1 ) ) then
      call dump( maxTimeDWFileTook, 'max time to do direct writes' )
      call dump( maxTimeChunkSpentWriting, 'max time chunks spent writing' )
    endif

    if ( parallel%verbosity > 0 ) then
      call TimeStamp ( 'All chunks processed, starting join task', advance='yes' )
    endif
    ! Now we join up all our results into l2gp and l2aux quantities

    call DestroyStoredResultsDatabase ( storedResults )

    finished = .true.
    if ( parallel%verbosity > 0 ) then
      call TimeStamp ( 'All chunks joined', advance='yes' )
    endif
    dumpfulldwreqs = switchDetail(switches,'dwreq1') > -1
    if ( switchDetail(switches,'dwreq') > -1 ) &
      & call dump(directWriteRequests, statsOnly=.not. dumpfulldwreqs)
    call trace_end ( "L2MasterTask", cond=toggle(gen) )

  contains

    logical function chunkAndMachineReady()  ! (nextChunk, machine, machineName)
      ! Return .true. if next chunk remaining to be done
      ! and a suitable machine can be found
      ! Also set nextChunk, machineName values (which could be made arguments)
      character(len=MACHINENAMELEN) :: machineName
      nextChunk = 0
      machine = 0
      machineName = ' '
      ! 1st check if any chunks remain
      chunkAndMachineReady = .not. all(chunksStarted .or. chunksAbandoned)
      if ( .not. chunkAndMachineReady ) return
      ! Now divide into 3 cases
      if ( .not. (USINGOLDSUBMIT .or. usingL2Q) ) then
      ! Case (1): Not using submit, nor l2q: master controls choice of machine
        chunkAndMachineReady = any(machines%Free .and. machines%OK)
        if ( .not. chunkAndMachineReady ) return
        nextChunk = FindFirst ( &
          & (.not. chunksStarted) .and. (.not. chunksAbandoned) )
        machine = FindFirst(machines%Free .and. machines%OK)
      elseif ( usingL2Q ) then
      ! Case (2): using l2q
        nextChunk = FindFirst ( &
          & (.not. chunksStarted) .and. (.not. chunksAbandoned) )
        chunkAndMachineReady = .not. machineRequestQueued
        if ( .not. chunkAndMachineReady ) then
          call ReceiveMachineFromL2Q(machineName)
        else
          call RequestMachineFromL2Q(L2Qtid, nextChunk, machineName)
        endif
        if ( len_trim(machineName) < 1 ) then
          ! Sorry--no machine ready yet; but our request is/remains queued
          chunkAndMachineReady = .false.
          machineRequestQueued = .true.
          ! if ( switchDetail(switches,'l2q') > -1 ) call output('Sorry, l2q scorns us', advance='yes')
        else
          ! Good news--a machine was/has become ready
          chunkAndMachineReady = .true.
          machineRequestQueued = .false.
          ! What if the machine has been added after this master began?
          ! Or, troubles other prevented machine from being added
          machine = FindFirst( (trim(machineName) == machines%Name) &
            & .and. machines%free )
          if ( machine < 1 ) then
            thisMachine%name = machineName
            machine = AddMachineToDataBase(machines, thisMachine)
            if ( BeVerbose( 'l2q', -1 ) ) &
              & call output('Added machine to db', advance='yes')
            ! machine = AddMachineNameToDataBase(machines%Name, machineName)
          endif
          ! if ( switchDetail(switches,'l2q') > -1 ) call output('Good news, l2q likes us', advance='yes')
          if ( BeVerbose( 'l2q', -1 ) ) then
            call outputNamedValue( 'machine', machine )
          endif
        endif
      else
      ! Case (3): Using submit
        nextChunk = FindFirst ( &
          & (.not. chunksStarted) .and. (.not. chunksAbandoned) )
      endif
    end function chunkAndMachineReady

    subroutine printMasterStatus
      ! Print status: completed, underway, abandoned
       call TimeStamp ( 'Master status:', advance='yes' )
       call output ( count(chunksCompleted) )
       call output ( ' of ' )
       call output ( noChunks )
       call output ( ' chunks completed, ')
       call output ( count(chunksStarted .and. .not. chunksCompleted) )
       call output ( ' underway, ' )
       call output ( count(chunksAbandoned) )
       call output ( ' abandoned, ' )
       call output ( count(.not. &
         & (chunksStarted .or. chunksCompleted .or. chunksAbandoned ) ) )
       call TimeStamp ( ' left. ', advance='yes' )
       if ( .not. ( USINGOLDSUBMIT .or. USINGL2Q ) ) then
         call output ( count ( .not. machines%Free ) )
         call output ( ' of ' )
         call output ( noMachines )
         call output ( ' machines busy, with ' )
         call output ( count ( .not. machines%OK ) )
         call TimeStamp ( ' being avoided.', advance='yes' )
       end if
    end subroutine printMasterStatus

    function timeDWHasBeenWriting ( fileIndex, chunk ) result ( howLong )
      ! How long has this chunk taken to write to this file?
      ! Args
      integer, intent(in) :: fileIndex
      integer, intent(in) :: chunk
      real(r8) :: howLong
      ! Internal variables
      real(r8) :: t2
      ! Executable
      call time_now ( t2 )
      howLong = t2 - timeDWFileBegan( fileIndex )
      maxTimeDWFileTook( fileIndex ) = max( howLong, maxTimeDWFileTook( fileIndex ) )
      maxTimeChunkSpentWriting( chunk ) = max( howLong, maxTimeChunkSpentWriting( chunk ) )
    end function timeDWHasBeenWriting

    subroutine WelcomeSlave ( chunk, tid )
      ! This routine welcomes a slave into the fold and tells it stuff
      integer, intent(in) :: CHUNK      ! Chunk we're asking it to do
      integer, intent(in) :: TID        ! Task ID for slave

      ! Local variables
      integer :: info

      call SendChunkInfoToSlave ( chunks, chunk, tid )
      ! Now ask to be notified when this task exits
      call PVMFNotify ( PVMTaskExit, NotifyTag, 1, (/ tid /), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, 'setting up notify' )
    end subroutine WelcomeSlave

    subroutine KillSlaves (isKillMaster, killMasterMsg)
      ! This routine kills all running slaves, and if isKillMaster is
      ! true, this routine will invoke MLSMessage with MLSError code
      logical, intent(in) :: isKillMaster
      character (len=*), intent(in) :: killMasterMsg
      integer :: Chunk ! Loop index

      call usleep( WaitBeforeKillingSlaves ) ! This is 130 s
      do chunk = 1, noChunks
        if ( chunkTids(chunk) /= 0 ) then
          call usleep ( KILLINGSLAVESDELAY )
          if ( usingL2Q ) then
            machine = chunkMachines(chunk)
            call TellL2QMachineFinished( &
              & trim(machines(machine)%name), machines(machine)%tid, L2Qtid, 0 )
            if ( BeVerbose( 'l2q', -1 ) ) then
              call output( 'tid: ', advance='no' )
              call output( machines(machine)%tid, advance='no' )
              call output( 'machine name: ', advance='no' )
              call output( trim(machines(machine)%name), advance='no' )
              call TimeStamp ( '   released', &
                & advance='yes' )
            endif
            call usleep ( parallel%delay )
          endif
          call output (chunkTids(chunk), advance='yes')
          call pvmfkill ( chunkTids(chunk), info )
          if ( info /= 0 ) &
            & call PVMErrorMessage ( info, 'killing slave' )
        end if
      end do

      if (isKillMaster) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, killMasterMsg )

    end subroutine KillSlaves

  end subroutine L2MasterTask

  ! ---------------------------------------- Private Procedures ----------
  ! -------------------------------------------- AddStoredQuantityToDatabase ----
  integer function AddStoredResultToDatabase ( database, item )
    ! Add a storedQuantity to a database, or create the database if it
    ! doesn't yet exist

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (StoredResult_T), dimension(:), pointer :: database
    type (StoredResult_T), intent(in) :: item

    ! Local variables
    type (StoredResult_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddStoredResultToDatabase = newSize
  end function AddStoredResultToDatabase

  ! --------------------------------- CleanUpDeadChunksOutput -------------
  subroutine CleanUpDeadChunksOutput ( chunk, storedResults )
    ! This destroys the vector info etc. associated with any output
    ! from a dead chunk.
    integer, intent(in) :: CHUNK        ! Index of chunk
    type (StoredResult_T), dimension(:), pointer :: STOREDRESULTS

    ! Local variables
    integer :: PRECIND                  ! Index for precision (if any)
    integer :: VALIND                   ! Index for value
    integer :: RES                      ! Loop counter

    ! Executable code
    if ( .not. associated(storedResults) ) return
    
    do res = 1, size ( storedResults )
      valInd = storedResults(res)%valInds(chunk)
      if ( valInd /= 0 ) then
        storedResults(res)%valInds(chunk) = 0
      end if

      if ( storedResults(res)%gotPrecision ) then
        precInd = storedResults(res)%precInds(chunk)
        if ( precInd /= 0 ) then
          storedResults(res)%precInds(chunk) = 0
        end if
      end if
    end do
  end subroutine CleanUpDeadChunksOutput
  
  ! ----------------------------------------- DestroyStoredResultsDatabase ---
  subroutine DestroyStoredResultsDatabase ( database )

    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    type (StoredResult_T), dimension(:), pointer :: database

    ! Local variabels
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: i, s, status

    ! Executable code
    if ( .not. associated ( database ) ) return
    do i = 1, size(database)
      call deallocate_test ( database(i)%valInds, 'database(?)%valInds', ModuleName)
      if ( associated ( database(i)%precInds ) ) &
        & call deallocate_test ( database(i)%precInds,&
        & 'database(?)%precInds', ModuleName)
    end do
    s = size(database) * storage_size(database) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
    deallocate ( database, STAT=status )
    call test_deallocate ( status, ModuleName, 'stored quantities database', s, &
      & address=addr )

  end subroutine DestroyStoredResultsDatabase

  ! ----------------------------------------- DumpMastersStatus ---
  subroutine DumpMastersStatus ( CHUNKMACHINES, CHUNKNICETIDS, &
    & DIRECTWRITEFILENAMES, DIRECTWRITEFILEBUSY, &
    & CHUNKSCOMPLETED, CHUNKSABANDONED, CHUNKSWRITING, MACHINES )
    integer, dimension(:) :: CHUNKMACHINES ! Machine indices for chunks
    character(len=16), dimension(:) :: CHUNKNICETIDS ! Tids for chunks
    integer, dimension(:) :: DIRECTWRITEFILENAMES
    logical, dimension(:) :: DIRECTWRITEFILEBUSY
    logical, dimension(:) :: CHUNKSCOMPLETED ! Chunks completed
    logical, dimension(:) :: CHUNKSABANDONED ! Chunks kept failing
    logical, dimension(:) :: CHUNKSWRITING ! Which chunks are writing
    type (Machine_T),dimension(:), pointer :: Machines
    integer, dimension(size(chunkmachines)) :: which, whichNot

    ! Local variabels
    integer :: i, m, n

    ! Executable code
    call banner ( 'Master Status Dumped', (/ 1, 80 /), 'C' )
    call output( 'Chunks', advance='yes' )
    m = 0
    do i = 1, size(chunkmachines)
      if ( chunkmachines(i) == 0 ) cycle
      m = m + 1
      call output( chunkmachines(i), advance='no' )
      call blanks( 3 )
      call output( chunksCompleted(i), advance='no' )
      call blanks( 3 )
      call output( chunksAbandoned(i), advance='no' )
      call blanks( 3 )
      call output( chunksWriting(i), advance='no' )
      call blanks( 3 )
      call output( trim(chunkNiceTids(i)), advance='yes' )
    enddo
    call output( 'Chunks abandoned', advance='yes' )
    call FindAll( chunksAbandoned, which, n, whichNot )
    if ( n > 0 ) &
      & call output( which(1:n), advance='yes' )
    call output( 'Chunks not completed', advance='yes' )
    call FindAll( chunksCompleted, which, n, whichNot )
    if ( n < m ) &
      & call output( whichNot(1:m-n), advance='yes' )
    call output( 'Chunks still writing', advance='yes' )
    call FindAll( chunksWriting, which, n, whichNot )
    if ( n > 0 ) call output( which(1:n), advance='yes' )
    call output( 'Direct Writes', advance='yes' )
    n = 0
    do i = 1, size(directwritefilenames)
      if ( directWriteFilenames(i) > 0 ) then
        n = n + 1
        call display_string ( directWriteFilenames(i), &
          & strip=.true., advance='no' )
        call blanks( 3 )
        call output( directwritefilebusy(i), advance='yes' )
      endif
    enddo
    call FindAll( directwritefilebusy, which, n, whichNot )
    if ( n > 0 ) then
      call output( 'Files still busy writing', advance='yes' )
      call output( directwritefilebusy(1:n), onlyIf = .true., advance='yes' )
    endif
    call dump ( machines )
  end subroutine DumpMastersStatus

  ! -------------------------------------- RecieveMachineFromL2Q --------------
  subroutine ReceiveMachineFromL2Q(machineName)
    !
    ! request a free host from the l2 queue manager
    character(len=MACHINENAMELEN), intent(out)        :: MACHINENAME
    !
    integer :: BEAT
    integer :: INFO                     ! From PVM
    integer :: BUFFERIDRCV              ! From PVM
    ! How many times to listen for queue manager's granting of request
    ! (Setting NBEATS=0 means merely register the request with queue manager;
    ! subsequent trips through master event loop will pick up message
    ! when and if queue manager grants our request)
    integer, parameter :: NBEATS = 0  ! 16   ! ~2x MAXNUMMASTERS  
    ! Possibly a machine is free and the queue manager will
    ! respond quickly
    ! (This idea is tentative, however)
    ! Now let's give queue manager a chance to receive our request
    ! and deliberate a while (but not too long)
    ! before giving up and going back to checking on our own slaves
    
    ! In fact this was a bad idea, or it turned out bad, anyway:
    ! It slowed processing routine communication by the master to no more
    ! than one message per NBEATS*delaytime, so long as the master was
    ! hoping to hear from the queue manager. This meant between 3 and 4 seconds
    ! between each signal being processed, so signals piled up in a huge
    ! line waiting to be received and acted upon.
    machineName = ' '
    do beat = 1, max(NBEATS, 1)
      call PVMFNRecv( -1, GRANTEDTAG, bufferIDRcv )
      if ( bufferIDRcv < 0 ) then
        call PVMErrorMessage ( info, "checking for Granted message" )
      else if ( bufferIDRcv > 0 ) then
        if ( BeVerbose( 'l2q', -1 ) ) &
          & call TimeStamp('Weve been granted a host', advance='yes')
        ! Granted us a machine
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) then
          call PVMErrorMessage ( info, "unpacking machine name" )
        endif
        if ( len_trim(machineName) < 1 ) &
          & call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'granted blank host name' )
        return
      else
        if ( beat < max(NBEATS, 1)) call usleep ( parallel%delay )
      endif
    enddo
    if ( BeVerbose( 'l2q', -1 ) .and. len_trim(machineName) > 0 ) &
      & call TimeStamp('Received from l2q ' // trim(machineName), advance='yes')
  end subroutine ReceiveMachineFromL2Q

  ! -------------------------------------- RegisterWithL2Q --------------
  subroutine RegisterWithL2Q(noChunks, machines, L2Qtid)
    integer, intent(in)                                  :: noChunks
    type(machine_t), dimension(:), pointer :: MACHINES
    ! character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
    integer, intent(out)                                 :: L2Qtid
    !
    integer :: BUFFERID                 ! From PVM
    character(len=16) :: DATESTRING
    integer :: INDX
    integer :: INFO                     ! From PVM
    character(len=16) :: L2QSTRING
    !
    call pvmfgettid(GROUPNAME, 0, L2Qtid)
    if ( L2Qtid < 1 ) then
      call MLSL2Message( MLSMSG_Error, ModuleName, &
        & 'l2q queue manager not running--dead or not started yet?' )
    else
      write ( L2QSTRING, * ) L2QTID
      call TimeStamp('Registering with l2q (l2qtid=' // &
        & trim(L2QSTRING) // ')', advance='yes')
    endif
    call GetMachines ( machines )
    ! Register ourselves with the l2 queue manager
    ! Identify ourselves
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_Register, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing registration' )
    call PVMF90Pack ( noChunks, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing number of chunks' )
    indx = INDEX (L2PCF%startUTC, "T")
    if ( len_trim(l2PCF%RunID) > 0 ) then
      dateString = l2PCF%RunID
    elseif ( indx > 0 ) then
    ! Now send our data date as a string
    ! We might reasonably expect one of two formats for startUTC:
    ! 1996-051T00:00:00.000000Z (using yyyy-dayofyear)
    ! 2006-05-07T00:00:00.000000Z (using yyyy-month-dayofmonth)
    ! (e.g., '2006d121')
      if ( all( NAppearances(L2PCF%startUTC(1:indx-1), (/'-'/)) > 1 ) ) then
        dateString = L2PCF%startUTC(1:indx-1) ! it was yyyy-month-dayofmonth
      else
        call ReplaceSubString ( L2PCF%startUTC(1:indx-1), dateString, &
        & '-', 'd' )  ! it was yyyy-dayofyear
      endif
    else
      dateString = '(unknown)'
    endif
    call PVMF90Pack ( dateString, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing date' )
    call PVMFSend ( L2Qtid, petitionTag, info )
    ! call PVMF90Pack ( noChunks, info )
    ! if ( info /= 0 ) &
    !   & call PVMErrorMessage ( info, 'packing L2QTid' )
    ! call PVMFSend ( L2Qtid, petitionTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending finish packet' )
  end subroutine RegisterWithL2Q

  ! -------------------------------------- RequestMachineFromL2Q --------------
  subroutine RequestMachineFromL2Q(L2Qtid, nextChunk, machineName)
    !
    ! request a free host from the l2 queue manager
    integer, intent(in)                               :: L2Qtid
    integer, intent(in)                               :: nextChunk
    character(len=MACHINENAMELEN), intent(out)        :: MACHINENAME
    !
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    ! Identify ourselves
    if ( BeVerbose( 'l2q', -1 ) ) &
      & call TimeStamp('Requesting host from l2q', advance='yes')
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( sig_requestHost, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing registration' )
    call PVMF90Pack ( nextChunk, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing number of chunk' )
    call PVMFSend ( L2Qtid, petitionTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending finish packet' )
    call ReceiveMachineFromL2Q(machineName)
  end subroutine requestMachineFromL2Q

  ! --------------------------------------------- SendChunkInfoToSlave ------
  subroutine SendChunkInfoToSlave ( chunks, chunkNo, slaveTid )
    ! This routine sends a chunk to a slave task

    ! Dummy arguments
    type (MLSChunk_T), intent(in), dimension(:) :: CHUNKS ! The chunk
    integer, intent(in) :: CHUNKNO      ! Which one is it.
    integer, intent(in) :: SLAVETID     ! Who to send it to

    ! Local variables
    integer :: BUFFERID                 ! ID for buffer to send
    integer :: INFO                     ! Flag from PVM
    integer :: CHUNK                    ! Loop counter
    integer :: BITS

    ! Executable code
    call BooleansToBits( (/ ChunkDivideConfig%allowPriorOverlaps, &
      & ChunkDivideConfig%allowPostOverlaps /), Bits )
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( (/ size(chunks), chunkNo /), info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing noChunks and chunkNo' )
    do chunk = 1, size(chunks)
      call PVMF90Pack ( &
        & (/ chunks(chunk)%firstMAFIndex, &
        &    chunks(chunk)%lastMAFIndex, &
        &    chunks(chunk)%noMAFsLowerOverlap, &
        &    chunks(chunk)%noMAFsUpperOverlap, &
        &    chunks(chunk)%chunkNumber /), info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing one chunk header' )

      if ( associated ( chunks(chunk)%hGridOffsets ) ) then
        call PVMF90Pack ( size ( chunks(chunk)%hGridOffsets ), info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing size(hGridOffsets)' )
        call PVMF90Pack ( chunks(chunk)%hGridOffsets, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing hGridOffsets chunk' )
      else
        call PVMF90Pack ( 0, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing 0 for size(hGridOffsets)' )
      end if

      if ( associated ( chunks(chunk)%hGridTotals ) ) then
        call PVMF90Pack ( size ( chunks(chunk)%hGridTotals ), info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing size(hGridTotals)' )
        call PVMF90Pack ( chunks(chunk)%hGridTotals, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing hGridTotals chunk' )
      else
        call PVMF90Pack ( 0, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing 0 for size(hGridTotals)' )
      end if
      
      ! The latest components added to the MLSChunk_T
      call PVMF90Pack ( chunks(chunk)%StartTime, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing Start time of chunk' )
      call PVMF90Pack ( chunks(chunk)%EndTime, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing End time of chunk' )
      

    end do
    call PVMF90Pack ( Bits, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing overlaps outside proc. rnge' )
    call PVMFSend ( slaveTid, ChunkTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending chunk' )
  end subroutine SendChunkInfoToSlave

  ! -------------------------------------- TellL2QMachineDied --------------
  subroutine TellL2QMachineDied(machine, L2Qtid)
    type(machine_T), intent(in)                         :: machine
    integer, intent(in)                                 :: L2Qtid
    !
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    !
    ! Identify ourselves
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_HostDied, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing signal of dead machine' )
    ! call PVMF90Pack ( machineName, info )
    call PVMF90Pack ( machine%tid, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing dead machine tid' )
    if ( len_trim(machine%name) < 1 ) then
      call PVMF90Pack ( ' ', info )
    else 
      call PVMF90Pack ( trim(machine%name), info )
    endif
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing dead machine name' )
    call PVMFSend ( L2Qtid, petitionTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending finish packet' )
    if ( BeVerbose( 'l2q', -1 ) ) then
      call output('Telling l2q about death of host ', advance='no')
      call output(trim(machine%name), advance='no')
      call blanks(2)
      call TimeStamp(machine%tid, advance='yes')
    endif
  end subroutine TellL2QMachineDied

  ! -------------------------------------- TellL2QMachineFinished --------------
  subroutine TellL2QMachineFinished(machineName, tid, L2Qtid, delay)
    character(len=*), intent(in)                        :: MACHINENAME
    integer, intent(in)                                 :: tid
    integer, intent(in)                                 :: L2Qtid
    integer, intent(in)                                 :: delay
    !
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    !
    ! If slave finished normally, give it enough time to deconstruct gracefully
    call usleep( delay )
    if ( BeVerbose( 'l2q', -1 ) ) then
      call output( 'Releasing ' )
      call output( tid )
      call output( ' ' // trim(machinename), advance='yes' )
    endif
    ! Identify ourselves
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_RELEASEHOST, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing signal of finished machine' )
    call PVMF90Pack ( tid, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing finished tid' )
    call PVMF90Pack ( machineName, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing finished machine name' )
    call PVMFSend ( L2Qtid, petitionTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending finish packet' )
  end subroutine TellL2QMachineFinished

  ! -------------------------------------- TellL2QMasterFinished --------------
  subroutine TellL2QMasterFinished(L2Qtid)
    integer, intent(in)                                 :: L2Qtid
    !
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    !
    ! Identify ourselves
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_FINISHED, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing signal we finished' )
    call PVMFSend ( L2Qtid, petitionTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending finish packet' )
  end subroutine TellL2QMasterFinished

  ! -------------------------------------- ThankL2Q --------------
  subroutine ThankL2Q(machine, L2Qtid)
    type(machine_T), intent(in)         :: machine
    integer, intent(in)                 :: L2Qtid
    !
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    !
    ! Identify ourselves
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_ThanksHost, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing signal of thanks for machine' )
    call PVMF90Pack ( machine%tid, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing tid' )
    call PVMF90Pack ( machine%Name, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing machineName' )
    call PVMF90Pack ( machine%chunk, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing machinechunk' )
    ! info = INDEX (L2PCF%startUTC, "T")
    ! if ( info > 0 ) machine%master_Date = L2PCF%startUTC(1:info-1)
    call PVMF90Pack ( machine%master_date, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing machineMasterDate' )
    call PVMFSend ( L2Qtid, petitionTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending finish packet' )
    if ( BeVerbose( 'l2q', -1 ) ) then
      call output('Thanking l2q for host ', advance='no')
      call TimeStamp(machine%tid, advance='yes')
    endif
  end subroutine ThankL2Q

  ! -------------------------------------- Never used here --------------
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: L2Parallel.f90,v 2.120 2019/07/22 22:30:29 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module L2Parallel

!
! $Log: L2Parallel.f90,v $
! Revision 2.120  2019/07/22 22:30:29  pwagner
! chunksAbandoned now will display the indices where true and the indices where false if array is logical-valued
!
! Revision 2.119  2018/09/13 20:26:07  pwagner
! Now properly sets L2Options%currentChunkNumber
!
! Revision 2.118  2018/07/27 23:18:48  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.117  2018/04/19 01:14:16  vsnyder
! Remove USE statements for unused names
!
! Revision 2.116  2018/02/09 01:27:31  pwagner
! Output the meaning along with the signal number
!
! Revision 2.115  2017/12/22 00:34:41  pwagner
! WaitBeforeKillingSlaves; must be bigger than pgekilldelay
!
! Revision 2.114  2017/12/07 01:01:23  vsnyder
! Don't use host-associated variable as a DO index
!
! Revision 2.113  2016/02/29 19:50:46  pwagner
! Usleep got from machine module instead of being an external
!
! Revision 2.112  2015/03/28 02:48:22  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.111  2014/09/05 01:06:08  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.110  2014/09/05 00:49:06  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.109  2014/04/22 18:17:22  pwagner
! Uses MLSMessage from MLSL2Options module
!
! Revision 2.108  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.107  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.106  2013/12/05 01:45:32  pwagner
! Pass RunID to l2q if non-blank; started using BeVerbose
!
! Revision 2.105  2013/08/30 02:45:43  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.104  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.103  2013/04/05 23:31:46  pwagner
! Added more output controllable by l2q switch setting
!
! Revision 2.102  2013/02/14 19:02:27  pwagner
! Added way for l2q to tell mster to dump status; removed unused stuff
!
! Revision 2.101  2012/07/02 20:38:02  pwagner
! Fix 'no live hosts so must stop' error with l2q; remove outdated staging stuff
!
! Revision 2.100  2012/03/28 20:05:54  pwagner
! slave tasks lost ability to join quantities
!
! Revision 2.99  2011/08/03 21:57:23  pwagner
! Improved routine printing and dumps by master task
!
! Revision 2.98  2011/05/26 20:39:34  pwagner
! Widened fields for dumping machinesTid
!
! Revision 2.97  2011/05/09 18:21:38  pwagner
! Converted to using switchDetail
!
! Revision 2.96  2010/05/13 23:47:19  pwagner
! Dropped superseded options run[first][last]
!
! Revision 2.95  2010/04/22 23:34:47  pwagner
! Print more useful error mesg if no chunks to process
!
! Revision 2.94  2009/09/18 00:30:25  pwagner
! Dont print misleading lines about busy, avoided machines if using l2q
!
! Revision 2.93  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.92  2009/06/16 17:41:19  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.91  2009/03/18 23:08:27  honghanh
! Kill all running slaves before letting the master dies upon encountering errors.
! Added subroutine KillSlaves
!
! Revision 2.90  2009/01/12 19:22:04  pwagner
! Alphabetized procedures; shorten time to finish when told to give up
!
! Revision 2.89  2008/06/12 22:28:27  pwagner
! Added options to print direct write timings
!
! Revision 2.88  2008/04/03 00:13:39  pwagner
! Not the nicest way to fix mlssubmit/pvm launching multiple instances of same slave
!
! Revision 2.87  2008/01/23 21:26:01  pwagner
! filters --chunks from slaveArguments
!
! Revision 2.86  2007/12/07 01:51:08  pwagner
! Removed unused dummy variables, etc.
!
! Revision 2.85  2007/11/01 23:31:47  pwagner
! Print clearer msgs when unable to launch slave
!
! Revision 2.84  2007/09/06 23:34:06  pwagner
! Delays a bit to prevent l2q from killing finishing slave
!
! Revision 2.83  2007/02/27 00:01:46  pwagner
! Change log message so grep -i died gives number died, not 2x
!
! Revision 2.82  2007/02/14 17:29:51  pwagner
! Lengthened time allowed for slaves to complete final tasks
!
! Revision 2.81  2007/02/13 21:36:19  pwagner
! Lengthen delays before telling l2q we finished so slaves may complete timings summary
!
! Revision 2.80  2007/01/12 00:38:57  pwagner
! Switches allegiance to a replacement l2q
!
! Revision 2.79  2006/11/22 18:11:04  pwagner
! Help l2q track hosts freed by killed masters
!
! Revision 2.78  2006/10/11 00:30:15  pwagner
! Fixed bug in length of arg MACHINENAME
!
! Revision 2.77  2006/09/29 00:29:42  pwagner
! Fixes bug where masters try to free dead hosts when finished
!
! Revision 2.76  2006/08/05 02:12:27  vsnyder
! Add ForWhom argument to ConstructVectorTemplate
!
! Revision 2.75  2006/04/20 23:21:37  pwagner
! Pass more chunk info from master to slave
!
! Revision 2.74  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.73  2005/03/24 21:22:32  pwagner
! Tried to fix slowing of masters relying on l2q
!
! Revision 2.72  2005/03/15 23:55:48  pwagner
! Saves error messages from about-to-die chunks
!
! Revision 2.71  2005/02/03 19:09:15  pwagner
! Receives master_date, master_time data from masters for each host
!
! Revision 2.70  2004/12/27 23:04:21  pwagner
! Fixed bug affecting old submit method
!
! Revision 2.69  2004/12/14 21:54:23  pwagner
! Changes related to l2q
!
! Revision 2.68  2004/09/16 23:57:31  pwagner
! Now tracks machine names of failed chunks
!
! Revision 2.67  2004/09/16 00:18:03  pwagner
! Keeps record of completed, failed chunks
!
! Revision 2.66  2004/08/05 22:47:47  pwagner
! New --chunkRange option to run selected chunks in parallel mode
!
! Revision 2.65  2004/08/03 23:14:56  pwagner
! Unseemly switch to allow running first last, or first and last chunks only
!
! Revision 2.64  2004/06/10 00:58:45  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.63  2004/05/19 19:16:11  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.62  2004/04/16 00:47:54  livesey
! Now kills slaves on finishing (probably only happens when told to quit).
!
! Revision 2.61  2004/01/22 00:56:35  pwagner
! Fixed many bugs in auto-distribution of DirectWrites
!
! Revision 2.60  2004/01/02 23:36:00  pwagner
! DirectWrites may choose files automatically from db
!
! Revision 2.59  2003/11/15 00:34:38  pwagner
! Now stops after exactly maxNumFailures
!
! Revision 2.58  2003/11/14 23:37:13  pwagner
! Lets user change masterLoop delay via commandline option
!
! Revision 2.57  2003/09/24 23:41:55  pwagner
! Moved some USE statements around to workaround IFC bugs
!
! Revision 2.56  2003/08/01 20:28:05  pwagner
! Spawns slave tasks with parallel%pgeName as command
!
! Revision 2.55  2003/07/11 21:50:02  livesey
! Bug fix in a diagnostic message
!
! Revision 2.54  2003/07/11 01:23:59  livesey
! Minor bug fix and more informative output
!
! Revision 2.53  2003/07/08 17:30:43  livesey
! Bug fix in ticket issuing
!
! Revision 2.52  2003/07/07 17:32:00  livesey
! New approach to directWrite
!
! Revision 2.51  2003/07/02 00:54:10  livesey
! Various tidy ups and bug fixes
!
! Revision 2.50  2003/07/01 16:30:52  livesey
! Changed error to warning.
!
! Revision 2.49  2003/06/20 19:38:25  pwagner
! Allows direct writing of output products
!
! Revision 2.48  2003/06/05 23:53:34  livesey
! Made the diagnostic output less verbose.
!
! Revision 2.47  2003/05/22 02:23:59  livesey
! More informative error message
!
! Revision 2.46  2003/05/13 04:48:06  livesey
! Can now stage to temporary hdf5 file instead of in memory.
!
! Revision 2.45  2003/05/12 02:06:48  livesey
! Changed to use the inflation of vectors etc for efficiency.
!
! Revision 2.44  2003/05/10 22:30:12  livesey
! Tidy up a message
!
! Revision 2.43  2003/02/20 20:32:56  livesey
! Added the 'take a ticket' approach to direct write conflicts.
!
! Revision 2.42  2003/01/17 21:54:12  livesey
! Added the machineFixed stuff.
!
! Revision 2.41  2002/11/08 21:24:00  livesey
! Minor tidy ups associated with the non-submit mode of doing things.
! Now manages dead macines in a more transparent way.
!
! Revision 2.40  2002/10/17 18:19:24  livesey
! Added the GiveUp signal capability.
!
! Revision 2.39  2002/10/08 17:36:21  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.38  2002/10/05 00:43:34  livesey
! Started work on the FwmParallel stuff
!
! Revision 2.37  2002/08/20 04:31:39  livesey
! Obscure limitation fixed.  Used to hang if chunk died while doing direct
! write.
!
! Revision 2.36  2002/07/18 02:15:29  livesey
! Bug fix, uninitialised variable
!
! Revision 2.35  2002/05/29 22:43:22  livesey
! Embarssing bug fix, finished=.true. was wrong side of if statement.
!
! Revision 2.34  2002/05/29 21:55:11  livesey
! Bug fixes, diagnostic message emitted when not -Smas, and associated
! checks around some deallocates.
!
! Revision 2.33  2002/05/22 00:48:36  livesey
! Added direct write stuff
!
! Revision 2.32  2002/05/21 01:12:05  livesey
! Got rid of machine stuff not relevant in submit case
!
! Revision 2.31  2002/05/08 16:19:29  livesey
! Bug fix.
!
! Revision 2.30  2002/04/24 20:20:53  livesey
! Submit now working, also if pvm specified as host filename, takes
! hostname list from pvm configuration
!
! Revision 2.29  2002/04/24 16:53:38  livesey
! Reordered arrays, on the way to having submit working
!
! Revision 2.28  2002/04/08 20:49:17  pwagner
! Swath name optionally passed to JoinL2GPQuantities
!
! Revision 2.27  2002/03/14 00:15:43  livesey
! Minor bug fix
!
! Revision 2.26  2002/01/10 01:07:43  livesey
! Another bug fix, slave wasn't receiving chunks correctly.
!
! Revision 2.25  2002/01/09 23:16:34  livesey
! Whoops, left the SendChunkInfoToSlave call in the wrong place!
!
! Revision 2.24  2002/01/09 22:55:57  livesey
! Now sends slaves all the chunks as regular HGrids need them.
!
! Revision 2.23  2001/11/14 18:03:45  livesey
! Changed for new FindFirst behavior
!
! Revision 2.22  2001/11/05 23:21:31  livesey
! Can now specify subset of slaves using <filename>:a:b.
!
! Revision 2.21  2001/10/30 01:45:21  livesey
! Some modifications/fixes to parallel join
!
! Revision 2.20  2001/09/10 23:39:12  livesey
! Minor change, not sure what it did, sorry.
!
! Revision 2.19  2001/09/09 02:52:43  livesey
! Now gets find first from a different place
!
! Revision 2.18  2001/09/08 00:21:44  pwagner
! Revised to work for new column Abundance in lone swaths
!
! Revision 2.17  2001/09/05 20:34:56  pwagner
! Reverted to pre-columnAbundance state
!
! Revision 2.16  2001/08/02 23:59:22  pwagner
! Compiles, but incomplete teatment of column abundance(s)
!
! Revision 2.15  2001/08/02 00:18:55  pwagner
! Began adding column quantities; incomplete
!
! Revision 2.14  2001/06/22 05:19:46  livesey
! Moved FindFirst into MLSL2Common
!
! Revision 2.13  2001/06/19 22:58:07  pwagner
! Eliminated duplicate declaration of MLSCommon
!
@


2.120
log
@chunksAbandoned now will display the indices where true and the indices where false if array is logical-valued
@
text
@d173 7
d1674 9
d1818 1
a1818 1
       "$Id: L2Parallel.f90,v 2.119 2018/09/13 20:26:07 pwagner Exp $"
d1829 3
@


2.119
log
@Now properly sets L2Options%currentChunkNumber
@
text
@d362 1
a362 1
      call dump( chunksAbandoned, 'chunksAbandoned' )
d1802 1
a1802 1
       "$Id: L2Parallel.f90,v 2.118 2018/07/27 23:18:48 pwagner Exp $"
d1813 3
@


2.118
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d40 1
a40 1
  use MLSL2options, only: MLSL2Message
d193 2
d1802 1
a1802 1
       "$Id: L2Parallel.f90,v 2.117 2018/04/19 01:14:16 vsnyder Exp $"
d1813 3
@


2.117
log
@Remove USE statements for unused names
@
text
@d40 1
a40 1
  use MLSL2options, only: MLSMessage
d126 1
a126 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d313 1
a313 1
      if ( noMachines < 1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d315 1
a315 1
      if ( .not. any(machines%OK) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d322 1
a322 1
      if ( noMachines < 1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d324 1
a324 1
      if ( .not. any(machines%OK) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d523 2
a524 2
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & "Got a message from an unknown slave")
d533 2
a534 2
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & "Got a message from an unknown slave")
d600 1
a600 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d804 1
a804 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1146 1
a1146 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1319 1
a1319 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, killMasterMsg )
d1509 1
a1509 1
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1535 1
a1535 1
      call MLSMessage( MLSMSG_Error, ModuleName, &
d1800 1
a1800 1
       "$Id: L2Parallel.f90,v 2.116 2018/02/09 01:27:31 pwagner Exp $"
d1811 3
@


2.116
log
@Output the meaning along with the signal number
@
text
@a1331 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d1800 1
a1800 1
       "$Id: L2Parallel.f90,v 2.115 2017/12/22 00:34:41 pwagner Exp $"
d1811 3
@


2.115
log
@WaitBeforeKillingSlaves; must be bigger than pgekilldelay
@
text
@d37 1
a37 1
    & AddmachinetoDatabase
d64 2
a65 2
  public :: L2MASTERTASK
  public :: GETCHUNKINFOFROMMASTER
d520 1
d530 1
d1801 1
a1801 1
       "$Id: L2Parallel.f90,v 2.114 2017/12/07 01:01:23 vsnyder Exp $"
d1812 3
@


2.114
log
@Don't use host-associated variable as a DO index
@
text
@d21 19
a39 19
  use allocate_deallocate, only: allocate_test, deallocate_test
  use bitStuff, only: bitsToBooleans, booleansToBits
  use chunks_m, only: dump, MLSChunk_t
  use chunkDivide_m, only: chunkDivideConfig
  use dump_0, only: dump
  use highOutput, only: beVerbose, banner, outputNamedValue, timeStamp
  use L2ParInfo, only: machine_t, parallel, &
    & chunktag, giveuptag, grantedtag, notifytag, masterdumptag, petitiontag, &
    & sig_tojoin, sig_finished, sig_ackfinish, sig_register, &
    & sig_requestdirectwrite, sig_swearallegiance, sig_switchallegiance, &
    & sig_directwritegranted, sig_directwritefinished, &
    & sig_hostdied, sig_releasehost, sig_requesthost, sig_thankshost, &
    & getnicetidstring, slavearguments, machinenamelen, getmachines, &
    & machinefixedtag, directwriterequest_t, &
    & dw_pending, dw_inprogress, dw_completed, &
    & inflatedirectwriterequestdb, compactdirectwriterequestdb, dump, &
    & addmachinetodatabase
  use machine, only: shell_command, usleep
  use MLSKinds, only: r8
d42 8
a49 8
  use MLSFinds, only: findall, findfirst
  use MLSStringlists, only: catlists, expandstringrange, removenumfromlist, &
    & replacesubstring, switchdetail
  use MLSStrings, only: lowercase
  use morePVM, only: PVMunpackstringindex, PVMpackstringindex
  use MLSStrings, only: nAppearances
  use output_m, only: blanks, output
  use PVM, only: infotag, &
d52 2
a53 2
    & myPVMSpawn, PVMFCatchout, PVMFSend, PVMFNotify, PVMTaskExit, &
    & getMachineNameFromTID, PVMFFreeBuf, sig_abouttodie
d55 5
a59 5
  use string_table, only: display_string
  use time_m, only: time_now
  use toggles, only: gen, switches, toggle
  use trace_m, only: trace_begin, trace_end
  use writeMetadata, only: l2pcf
d80 6
d1291 1
d1799 1
a1799 1
       "$Id: L2Parallel.f90,v 2.113 2016/02/29 19:50:46 pwagner Exp $"
d1810 3
@


2.113
log
@Usleep got from machine module instead of being an external
@
text
@d1283 1
d1792 1
a1792 1
       "$Id: L2Parallel.f90,v 2.112 2015/03/28 02:48:22 vsnyder Exp $"
d1803 3
@


2.112
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d21 39
a59 39
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use BITSTUFF, only: BITSTOBOOLEANS, BOOLEANSTOBITS
  use CHUNKS_M, only: DUMP, MLSCHUNK_T
  use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG
  use DUMP_0, only: DUMP
  use HIGHOUTPUT, only: BEVERBOSE, BANNER, OUTPUTNAMEDVALUE, TIMESTAMP
  use L2PARINFO, only: MACHINE_T, PARALLEL, &
    & CHUNKTAG, GIVEUPTAG, GRANTEDTAG, NOTIFYTAG, MASTERDUMPTAG, PETITIONTAG, &
    & SIG_TOJOIN, SIG_FINISHED, SIG_ACKFINISH, SIG_REGISTER, &
    & SIG_REQUESTDIRECTWRITE, SIG_SWEARALLEGIANCE, SIG_SWITCHALLEGIANCE, &
    & SIG_DIRECTWRITEGRANTED, SIG_DIRECTWRITEFINISHED, &
    & SIG_HOSTDIED, SIG_RELEASEHOST, SIG_REQUESTHOST, SIG_THANKSHOST, &
    & GETNICETIDSTRING, SLAVEARGUMENTS, MACHINENAMELEN, GETMACHINES, &
    & MACHINEFIXEDTAG, DIRECTWRITEREQUEST_T, &
    & DW_PENDING, DW_INPROGRESS, DW_COMPLETED, &
    & INFLATEDIRECTWRITEREQUESTDB, COMPACTDIRECTWRITEREQUESTDB, DUMP, &
    & ADDMACHINETODATABASE
  use MACHINE, only: SHELL_COMMAND
  use MLSKINDS, only: R8
  use MLSL2Options, only: MLSMessage
  use MLSMessageModule, only: MLSMSG_ERROR, MLSMSG_WARNING, PVMERRORMESSAGE
  use MLSFINDS, only: FINDALL, FINDFIRST
  use MLSSTRINGLISTS, only: CATLISTS, EXPANDSTRINGRANGE, REMOVENUMFROMLIST, &
    & REPLACESUBSTRING, SWITCHDETAIL
  use MLSSTRINGS, only: LOWERCASE
  use MOREPVM, only: PVMUNPACKSTRINGINDEX, PVMPACKSTRINGINDEX
  use MLSSTRINGS, only: NAPPEARANCES
  use OUTPUT_M, only: BLANKS, OUTPUT
  use PVM, only: INFOTAG, &
    & PVMDATADEFAULT, PVMFINITSEND, PVMF90PACK, PVMFKILL, &
    & PVMF90UNPACK, PVMTASKHOST, &
    & MYPVMSPAWN, PVMFCATCHOUT, PVMFSEND, PVMFNOTIFY, PVMTASKEXIT, &
    & GETMACHINENAMEFROMTID, PVMFFREEBUF, SIG_ABOUTTODIE
  use PVMIDL, only: PVMIDLUNPACK
  use STRING_TABLE, only: DISPLAY_STRING
  use TIME_M, only: TIME_NOW
  use TOGGLES, only: GEN, SWITCHES, TOGGLE
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use WRITEMETADATA, only: L2PCF
a199 1
    external :: Usleep
d1791 1
a1791 1
       "$Id: L2Parallel.f90,v 2.111 2014/09/05 01:06:08 vsnyder Exp $"
d1802 3
@


2.111
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d95 1
d106 1
d134 2
d137 1
a137 1
      & elementSize = storage_size(chunks) / 8 )
d1323 1
d1371 1
d1376 1
d1388 2
d1391 2
a1392 1
    call test_deallocate ( status, ModuleName, 'stored quantities database', s )
d1792 1
a1792 1
       "$Id: L2Parallel.f90,v 2.110 2014/09/05 00:49:06 vsnyder Exp $"
d1803 3
@


2.110
log
@EmpiricalGeometry.f90
@
text
@d1782 1
a1782 1
       "$Id: L2Parallel.f90,v 2.109 2014/04/22 18:17:22 pwagner Exp $"
d1793 3
@


2.109
log
@Uses MLSMessage from MLSL2Options module
@
text
@d41 1
a41 2
  use MLSMessageModule, only: MLSMSG_ERROR, MLSMSG_ALLOCATE, &
    & MLSMSG_DEALLOCATE, MLSMSG_WARNING, PVMERRORMESSAGE
d94 1
d132 2
a133 3
    if ( status /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Failed to allocate chunks' )
d1318 2
d1364 3
d1370 1
a1370 1
    integer :: i, status
d1380 1
d1382 2
a1383 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'stored quantities database' )
d1782 1
a1782 1
       "$Id: L2Parallel.f90,v 2.108 2014/01/11 01:44:18 vsnyder Exp $"
d1793 3
@


2.108
log
@Decruftification
@
text
@d40 2
a41 1
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_ALLOCATE, &
a234 1
    integer :: NOQUANTITIESACCUMULATED  ! Running counter / index
a296 1
    noQuantitiesAccumulated = 0
d1777 1
a1777 1
       "$Id: L2Parallel.f90,v 2.107 2014/01/09 00:30:24 pwagner Exp $"
d1788 3
@


2.107
log
@Some procedures formerly in output_m now got from highOutput
@
text
@a54 1
  use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T
a58 1
  use VECTORSMODULE, only: VECTOR_T, VECTORTEMPLATE_T
a243 1
    integer :: STATUS                   ! From deallocate etc.
d1778 1
a1778 1
       "$Id: L2Parallel.f90,v 2.106 2013/12/05 01:45:32 pwagner Exp $"
d1789 3
@


2.106
log
@Pass RunID to l2q if non-blank; started using BeVerbose
@
text
@d26 1
d48 1
a48 2
  use OUTPUT_M, only: BANNER, BEVERBOSE, BLANKS, OUTPUT, OUTPUTNAMEDVALUE, &
    & TIMESTAMP
d1781 1
a1781 1
       "$Id: L2Parallel.f90,v 2.105 2013/08/30 02:45:43 vsnyder Exp $"
d1792 3
@


2.105
log
@Revise calls to trace_begin and trace_end
@
text
@d47 2
a48 1
  use OUTPUT_M, only: BANNER, BLANKS, OUTPUT, OUTPUTNAMEDVALUE, TIMESTAMP
d66 2
a67 2
  public :: L2MasterTask
  public :: GetChunkInfoFromMaster
d77 2
a78 1
  character(len=*), parameter :: GROUPNAME = "mlsl2" ! Set by l2q
d173 1
a173 1
    if( switchDetail(switches, 'opt') > -1 .or. parallel%verbosity > 0 ) then
d184 1
a184 1
    if ( switchDetail(switches,'chu') >=0 ) call dump ( chunks )
d313 1
a313 1
      if ( switchDetail(switches,'mach') > -1 .or. &
d322 1
a322 1
      if ( switchDetail(switches,'mach') > -1 .or. &
d353 1
a353 1
    if ( switchDetail(switches,'l2q') > -1 ) then
d406 1
a406 1
          if ( switchDetail(switches,'slv') > -1 ) then
d443 1
a443 1
              if ( switchDetail(switches,'l2q') > 0 ) then
d453 1
a453 1
            if ( switchDetail(switches,'l2q') > 0 ) &
d672 1
a672 1
            if ( switchDetail ( switches, 'dwtime' ) > -1 ) then
d859 1
a859 1
              if ( switchDetail(switches,'l2q') > -1 ) then
d897 1
a897 1
                if ( switchDetail ( switches, 'dwtime' ) > -1 ) then
d969 1
a969 1
          if ( switchDetail(switches,'l2q') > -1 ) then
d980 1
a980 1
          if ( switchDetail(switches,'l2q') > -1 ) then
d1120 1
a1120 1
    if ( switchDetail(switches,'l2q') > -1 ) then
d1143 1
a1143 1
    if ( switchDetail ( switches, 'dwtime' ) > -1 ) then
d1211 1
a1211 1
            if ( switchDetail(switches,'l2q') > -1 ) &
d1216 1
a1216 1
          if ( switchDetail(switches,'l2q') > -1 ) then
d1293 1
a1293 1
            if ( switchDetail(switches,'l2q') > -1 ) then
d1482 1
a1482 1
        if ( switchDetail(switches,'l2q') > -1 ) &
d1497 1
a1497 1
    if ( switchDetail(switches,'l2q') > -1 .and. len_trim(machineName) > 0 ) &
d1533 4
a1541 2
    indx = INDEX (L2PCF%startUTC, "T")
    if ( indx > 0 ) then
d1574 1
a1574 1
    if ( switchDetail(switches,'l2q') > -1 ) &
d1683 1
a1683 1
    if ( switchDetail(switches, 'l2q') > -1 ) then
d1703 1
a1703 1
    if ( switchDetail(switches,'l2q') > -1 ) then
d1771 1
a1771 1
    if ( switchDetail(switches, 'l2q') > -1 ) then
d1781 1
a1781 1
       "$Id: L2Parallel.f90,v 2.104 2013/08/12 23:49:41 pwagner Exp $"
d1792 3
@


2.104
log
@FindSomethings moved to MLSFinds module
@
text
@d225 1
d280 1
a280 1
    if ( toggle(gen) ) call trace_begin ( "L2MasterTask")
d1160 1
a1160 1
    if ( toggle(gen) ) call trace_end ( "L2MasterTask")
d1777 1
a1777 1
       "$Id: L2Parallel.f90,v 2.103 2013/04/05 23:31:46 pwagner Exp $"
d1788 3
@


2.103
log
@Added more output controllable by l2q switch setting
@
text
@d41 1
a41 1
  use MLSSETS, only: FINDALL, FINDFIRST
d1776 1
a1776 1
       "$Id: L2Parallel.f90,v 2.102 2013/02/14 19:02:27 pwagner Exp $"
d1787 3
@


2.102
log
@Added way for l2q to tell mster to dump status; removed unused stuff
@
text
@d349 6
a354 1
    endif    
d1776 1
a1776 1
       "$Id: L2Parallel.f90,v 2.101 2012/07/02 20:38:02 pwagner Exp $"
d1787 3
@


2.101
log
@Fix 'no live hosts so must stop' error with l2q; remove outdated staging stuff
@
text
@a25 2
  use L2AUXDATA, only: L2AUXDATA_T
  use L2GPDATA, only: L2GPDATA_T
d27 2
a28 2
    & CHUNKTAG, GIVEUPTAG, GRANTEDTAG, PETITIONTAG, &
    & SIG_TOJOIN, SIG_FINISHED, SIG_ACKFINISH, SIG_REGISTER, NOTIFYTAG, &
d41 1
a41 1
  use MLSSETS, only: FINDFIRST
d47 1
a47 1
  use OUTPUT_M, only: BLANKS, OUTPUT, TIMESTAMP
d187 1
a187 1
  subroutine L2MasterTask ( chunks, l2gpDatabase, l2auxDatabase )
a189 2
    type (L2GPData_T), dimension(:), pointer :: L2GPDATABASE
    type (L2AuxData_T), dimension(:), pointer :: L2AUXDATABASE
a266 5
    type (QuantityTemplate_T),dimension(:), pointer :: joinedQuantities 
    ! Local quantity template database
    type (VectorTemplate_T), dimension(:), pointer  :: joinedVectorTemplates
    ! Local vector template database
    type (Vector_T), dimension(:), pointer :: joinedVectors
d286 1
a286 2
    nullify ( joinedQuantities, joinedVectorTemplates, joinedVectors, &
      & machines, storedResults, &
d742 12
d863 1
a863 2
            call CleanUpDeadChunksOutput ( deadChunk, joinedQuantities, &
              & joinedVectorTemplates, joinedVectors, storedResults )
a1146 18
    if ( associated ( joinedQuantities ) ) then
      deallocate ( joinedQuantities, STAT=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'joinedQuantities' )
    end if

    if ( associated ( joinedVectorTemplates ) ) then
      deallocate ( joinedVectorTemplates, STAT=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'joinedVectorTemplates' )
    end if

    if ( associated ( joinedVectors ) ) then
      deallocate ( joinedVectors, STAT=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'joinedVectors' )
    end if

d1191 1
a1191 1
          ! if ( switchDetail(switches,'l2q') /=0 ) call output('Sorry, l2q scorns us', advance='yes')
d1207 4
a1210 1
          ! if ( switchDetail(switches,'l2q') /=0 ) call output('Good news, l2q likes us', advance='yes')
d1328 1
a1328 2
  subroutine CleanUpDeadChunksOutput ( chunk, joinedQuantities, &
    & joinedVectorTemplates, joinedVectors, storedResults )
a1331 3
    type (QuantityTemplate_T), dimension(:), pointer :: JOINEDQUANTITIES
    type (VectorTemplate_T), dimension(:), pointer :: JOINEDVECTORTEMPLATES
    type (Vector_T), dimension(:), pointer :: JOINEDVECTORS
d1357 1
a1357 1
  ! ----------------------------------------- DestroyStoredQuantitiesDatabase ---
d1377 64
d1771 1
a1771 1
       "$Id: L2Parallel.f90,v 2.100 2012/03/28 20:05:54 pwagner Exp $"
d1782 3
@


2.100
log
@slave tasks lost ability to join quantities
@
text
@d56 1
a56 4
  use QUANTITYPVM, only: PVMRECEIVEQUANTITY
  use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, &
    & DESTROYQUANTITYTEMPLATECONTENTS, INFLATEQUANTITYTEMPLATEDATABASE, &
    & NULLIFYQUANTITYTEMPLATE
d61 1
a61 4
  use VECTORSMODULE, only: VECTOR_T, VECTORTEMPLATE_T, &
    & CONSTRUCTVECTORTEMPLATE, &
    & CREATEVECTOR, DESTROYVECTORINFO, DESTROYVECTORTEMPLATEINFO, &
    & INFLATEVECTORTEMPLATEDATABASE, INFLATEVECTORDATABASE
d173 1
a173 1
    if( switchDetail(switches, 'opt') > -1 ) then
d320 2
a321 1
      if ( switchDetail(switches,'mach') > -1 ) call dump ( machines )
d329 2
a330 1
      if ( switchDetail(switches,'mach') > -1 ) call dump ( machines )
a334 9
    ! Setup the staging file if we're using one
    if ( .not. parallel%stageInMemory ) then
      ! call H5FCreate_F ( trim(parallel%stagingFile), H5F_ACC_TRUNC_F, stageFileID, status )
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !   & 'Unable to open staging file: '//trim(parallel%stagingFile) )
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'This version does not use staging file for slave Join commands' )
    end if

d399 1
a399 1
          if ( switchDetail(switches,'mas') > -1 ) then
d418 1
a418 1
          if ( switchDetail(switches,'mas') > -1 ) then
d444 1
a444 1
            if ( switchDetail(switches,'mas') > -1 ) then
d462 1
a462 1
            if ( switchDetail(switches,'mas') > -1 ) then
d587 1
a587 1
            if ( switchDetail(switches,'mas') > -1 ) then
a595 4
         !  call StoreSlaveQuantity( joinedQuantities, &
         !    & joinedVectorTemplates, joinedVectors, &
         !    & storedResults, chunk, noChunks, noQuantitiesAccumulated, &
         !    & stageFileID )
d634 1
a634 1
          if ( switchDetail ( switches, 'mas' ) > -1 ) then
d665 1
a665 1
          if ( switchDetail ( switches, 'mas' ) > -1 ) then
d684 1
a684 1
          if ( switchDetail(switches,'mas') > -1 ) then
d703 1
a703 1
          if ( switchDetail(switches,'mas') > -1 ) &
d718 1
a718 1
          if ( switchDetail(switches,'mas') > -1 ) then
d742 1
a742 1
        if ( switchDetail(switches,'mas') > -1 ) then
d755 1
a755 1
        if ( switchDetail(switches,'mas') > -1 ) then
d791 1
a791 1
          if ( switchDetail(switches,'mas') > -1 ) then
d848 1
a848 1
            if ( switchDetail(switches,'mas') > -1 ) then
d879 1
a879 1
              if ( switchDetail(switches,'mas') > -1 ) then
d906 1
a906 1
              if ( switchDetail(switches,'mas') > -1 ) then
d921 1
a921 1
                if ( switchDetail(switches,'mas') > -1 ) &
d941 1
a941 1
            if ( switchDetail(switches,'mas') > -1 .and. NOTFORGOTTEN ) call TimeStamp ( &
d1031 1
a1031 1
        if ( switchDetail(switches,'mas') > -1 ) then
d1081 1
a1081 1
        if ( switchDetail(switches,'mas') > -1 ) &
d1092 4
a1095 1
      if ( .not. USINGOLDSUBMIT ) then
d1098 1
a1098 1
          if ( switchDetail(switches,'mas') > -1 ) &
d1122 2
a1123 3
      if ( switchDetail(switches,'mas') > -1 ) &
        & call TimeStamp ( 'Telling l2q we are finished', &
        & advance='yes' )
d1139 1
a1139 1
    if ( switchDetail(switches,'mas') > -1 ) then
a1143 19
    ! If we're staging to a file, close the file and reopen it.
    if ( .not. parallel%stageInMemory ) then
      ! call H5FClose_F ( stageFileID, status )
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
      !   & 'Unable to close staging file:'//parallel%stagingFile )
      ! call H5FOpen_F ( trim(parallel%stagingFile), H5F_ACC_RDONLY_F, stageFileID, status )
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
      !   & 'Unable to reopen staging file:'//parallel%stagingFile )
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'This version does not use staging file for slave Join commands' )
    end if

    ! Now clean up and quit
    if ( .not. parallel%stageInMemory ) then
      ! call H5FClose_F ( stageFileID, status )
      ! if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
      !   & 'Unable to close staging file:'//parallel%stagingFile )
    end if

d1165 1
a1165 1
    if ( switchDetail(switches,'mas') > -1 ) then
a1362 5
        if ( parallel%stageInMemory ) then
          call DestroyVectorInfo ( joinedVectors(valInd) )
          call DestroyVectorTemplateInfo ( joinedVectorTemplates(valInd) )
          call DestroyQuantityTemplateContents ( joinedQuantities(valInd) )
        end if
a1368 5
          if ( parallel%stageInMemory ) then
            call DestroyVectorInfo ( joinedVectors(precInd) )
            call DestroyVectorTemplateInfo ( joinedVectorTemplates(precInd) )
            call DestroyQuantityTemplateContents ( joinedQuantities(precInd) )
          end if
a1599 151
  ! -------------------------------------- StoreSlaveQuantity --------------
  subroutine StoreSlaveQuantity ( joinedQuantities, joinedVectorTemplates, &
    & joinedVectors, storedResults, chunk, noChunks, noQuantitiesAccumulated,&
    & stageFileID )
    use VECTORHDF5, only: WRITEVECTORASHDF5
    ! This routine reads a vector from a slave and stores it in
    ! an appropriate place.

    type (QuantityTemplate_T), dimension(:), pointer :: JOINEDQUANTITIES
    type (VectorTemplate_T), dimension(:), pointer :: JOINEDVECTORTEMPLATES
    type (Vector_T), dimension(:), pointer :: JOINEDVECTORS
    type (StoredResult_T), dimension(:), pointer :: STOREDRESULTS
    integer, intent(in) :: CHUNK        ! Index of chunk
    integer, intent(in) :: NOCHUNKS     ! Number of chunks
    integer, intent(inout) :: NOQUANTITIESACCUMULATED ! Running counter /index
    integer, intent(in) :: STAGEFILEID  ! For using staging file

    ! Local parameters
    integer, parameter :: DATABASEINFLATION = 500
    ! Local saved variables
    integer, parameter :: NINJOINPACKET   = 2 ! Num of ints in join packet

    ! Local variables
    integer, dimension(NINJOINPACKET) :: I2         ! Array to unpack
    integer :: INFO                                 ! Flag from pvm
    character(len=132) :: HDFNAME                   ! Output name for quantity
    character(len=132) :: GNAME                     ! HDF Group name for quantity
    integer :: KEY                                  ! Tree node
    integer :: GOTPRECISION                         ! Flag
    integer :: VIND                                 ! Index for vector
    integer :: PVIND                                ! Index for precision vector
    integer :: I                                    ! Loop inductor
    integer :: NOSTOREDRESULTS                      ! Array size
    logical :: SEENTHISBEFORE                       ! Flag
    logical :: NEEDTOINFLATE                        ! Flag
    real (r8), dimension(:,:), pointer :: VALUES    ! Values for this vector quantity
    character(len=1), dimension(:,:), pointer :: MASK ! Mask for this vector quantity
    type (QuantityTemplate_T) :: qt                 ! A quantity template
    type (VectorTemplate_T) :: vt                   ! A vector template
    type (Vector_T) :: v                            ! A vector
    type (StoredResult_T), pointer :: THISRESULT    ! Pointer to a storedResult
    type (StoredResult_T) :: ONERESULT              ! A new single storedResult_T

    ! Executable code

    ! First we unpack the rest of the information in the packet we were sent
    call PVMF90Unpack ( i2, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking integers from join packet" )
    call PVMIDLUnpack ( hdfName, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, &
      & "unpacking hdf name from" )
    key = i2(1)
    gotPrecision = i2(2)

    ! Now get the quantity itself, possibly the precision and tropopause
    do i = 1, gotPrecision+1
      ! Increment our counter
      noQuantitiesAccumulated = noQuantitiesAccumulated + 1
      ! Get the quantity
      ! Just going to nullify qt, etc. I know it's intent in PVMRecieve..., but just
      ! to be sure.  Ditto for values and mask
      call NullifyQuantityTemplate ( qt )
      nullify ( values, mask )
      call PVMReceiveQuantity ( qt, values, mask=mask, justUnpack=.true. )

      ! Now we do different things depending on whether we're staging
      ! in memory or to a file
      if ( parallel%stageInMemory ) then
        ! Perhaps inflate our databases, some extra logic to avoig doing size on
        ! unassociated pointer
        needToInflate = noQuantitiesAccumulated == 1
        if ( .not. needToInflate ) &
          & needToInflate = noQuantitiesAccumulated > size ( joinedQuantities )
        if ( needToInflate ) then
          noQuantitiesAccumulated = &
            & InflateQuantityTemplateDatabase ( joinedQuantities, databaseInflation )
          noQuantitiesAccumulated = &
            & InflateVectorTemplateDatabase ( joinedVectorTemplates, databaseInflation )
          noQuantitiesAccumulated = &
            & InflateVectorDatabase ( joinedVectors, databaseInflation )
        end if
        
        ! Now add its template to our template database
        joinedQuantities ( noQuantitiesAccumulated ) = qt
        
        ! Now make a vector template up for this
        call ConstructVectorTemplate ( 0, joinedQuantities, &
          & (/ noQuantitiesAccumulated /), vt, forWhom=moduleName )
        joinedVectorTemplates ( noQuantitiesAccumulated ) = vt
        
        ! Now make a vector up for this
        v = CreateVector ( 0, joinedVectorTemplates( noQuantitiesAccumulated ), &
          & joinedQuantities, vectorNameText='joined' )
      else ! ------------------- Staging in a file

        call ConstructVectorTemplate ( 0, (/ qt /), (/ 1 /), vt, forWhom=moduleName )
        v = CreateVector ( 0, vt, (/ qt /), vectorNameText='joined', noValues=.true. )
      end if
      
      v%quantities(1)%values => values
      v%quantities(1)%mask => mask

      if ( parallel%stageInMemory ) then
        joinedVectors ( noQuantitiesAccumulated ) = v
      else
        ! Write this in our staging file
        write ( gName, '(i0)' ) noQuantitiesAccumulated
        call WriteVectorAsHDF5 ( stageFileID, gName, v )
        ! Destroy the information we got
        call DestroyQuantityTemplateContents ( qt )
        call DestroyVectorTemplateInfo ( vt )
        call DestroyVectorInfo ( v )
      end if

      select case ( i )
      case ( 1 )
        vInd = noQuantitiesAccumulated
      case ( 2 )
        pvInd = noQuantitiesAccumulated
      end select
    end do

    ! Now update our stored result stuff
    seenThisBefore = associated ( storedResults ) ! Perhaps, anyway
    if ( seenThisBefore ) seenThisBefore = any (storedResults%key == key )

    if ( seenThisBefore ) then
      thisResult => storedResults ( FindFirst ( storedResults%key, key ) )
    else
      ! We haven't seen this one before
      oneResult%key = key
      oneResult%gotPrecision = ( gotPrecision == 1 )
      oneResult%hdfName = hdfName
      call allocate_test ( oneResult%valInds, noChunks, &
        & 'valInds', ModuleName )
      if ( oneResult%gotPrecision ) &
        & call allocate_test ( oneResult%precInds, noChunks, &
        & 'precInds', ModuleName )
      ! Shouldn't need these really, but just in case
      oneResult%valInds = 0
      if ( oneResult%gotPrecision ) oneResult%precInds = 0
      noStoredResults = AddStoredResultToDatabase ( storedResults, oneResult )
      thisResult => storedResults ( noStoredResults )
    end if

    thisResult%valInds(chunk) = vInd
    if ( thisResult%gotPrecision ) thisResult%precInds(chunk) = pvInd

  end subroutine StoreSlaveQuantity

d1725 1
a1725 1
       "$Id: L2Parallel.f90,v 2.99 2011/08/03 21:57:23 pwagner Exp $"
d1736 3
@


2.99
log
@Improved routine printing and dumps by master task
@
text
@a25 2
  use INIT_TABLES_MODULE, only: S_L2GP, S_L2AUX
  use JOIN, only: JOINL2GPQUANTITIES, JOINL2AUXQUANTITIES
a48 1
  use MORETREE, only: GET_SPEC_ID
d59 1
a59 1
    & NULLIFYQUANTITYTEMPLATE, DESTROYQUANTITYTEMPLATEDATABASE
a60 2
  use SYMBOL_TABLE, only: ENTER_TERMINAL
  use SYMBOL_TYPES, only: T_STRING
d64 1
a64 1
  use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T, VECTORTEMPLATE_T, &
a195 2
    use HDF5, only: H5FCREATE_F, H5FCLOSE_F, H5FOPEN_F, H5F_ACC_RDONLY_F, H5F_ACC_TRUNC_F
    use VectorHDF5, only: READVECTORFROMHDF5
a230 1
    integer :: HDFNAMEINDEX             ! String index
a243 1
    integer :: PRECIND                  ! Array index
a246 1
    integer :: RESIND                   ! Loop counter
d252 1
a252 1
    integer :: STAGEFILEID              ! From HDF5
a254 1
    integer :: VALIND                   ! Array index
a284 4
    type (VectorValue_T), pointer :: QTY
    type (VectorValue_T), pointer :: PRECQTY
    type (Vector_T), target :: MYVALUES
    type (Vector_T), target :: MYPRECISIONS
d341 5
a345 3
      call H5FCreate_F ( trim(parallel%stagingFile), H5F_ACC_TRUNC_F, stageFileID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to open staging file: '//trim(parallel%stagingFile) )
d609 6
a614 4
          call StoreSlaveQuantity( joinedQuantities, &
            & joinedVectorTemplates, joinedVectors, &
            & storedResults, chunk, noChunks, noQuantitiesAccumulated, &
            & stageFileID )
d1161 8
a1168 6
      call H5FClose_F ( stageFileID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
        & 'Unable to close staging file:'//parallel%stagingFile )
      call H5FOpen_F ( trim(parallel%stagingFile), H5F_ACC_RDONLY_F, stageFileID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
        & 'Unable to reopen staging file:'//parallel%stagingFile )
a1170 72
    if ( associated ( storedResults ) ) then
      do resInd = 1, size ( storedResults )
        hdfNameIndex = enter_terminal ( trim(storedResults(resInd)%hdfName), t_string )
        if ( switchDetail(switches,'mas') > -1 ) then
          call TimeStamp ( 'Joining ' // trim ( storedResults(resInd)%hdfName ), &
            & advance='yes' )
        endif
        
        do chunk = 1, noChunks
          if (.not. chunksAbandoned(chunk) ) then
            ! Setup for this quantity
            if ( parallel%stageInMemory ) then
              valInd = storedResults(resInd)%valInds(chunk)
              qty => joinedVectors(valInd)%quantities(1)
              
              if ( storedResults(resInd)%gotPrecision ) then
                precInd = storedResults(resInd)%precInds(chunk)
                precQty => joinedVectors(precInd)%quantities(1)
              else
                nullify ( precQty )
              endif
            else
              write ( thisName, '(i0)' ) storedResults(resInd)%valInds(chunk)
              call ReadVectorFromHDF5 ( stageFileID, trim(thisName), &
              & myValues, joinedQuantities )
            qty => myValues%quantities(1)
            if ( storedResults(resInd)%gotPrecision ) then
              write ( thisName, '(i0)' ) storedResults(resInd)%precInds(chunk)
              call ReadVectorFromHDF5 ( stageFileID, trim(thisName), &
                & myPrecisions, joinedQuantities )
              precQty => myPrecisions%quantities(1)
            else
              nullify ( precQty )
            end if
          end if

          select case ( get_spec_id ( storedResults(resInd)%key ) )
          case ( s_l2gp )
            call JoinL2GPQuantities ( storedResults(resInd)%key, hdfNameIndex, &
              & qty, precQty, l2gpDatabase, chunk, &
              & nameString=trim(storedResults(resInd)%hdfName))
          case ( s_l2aux )
            call JoinL2AuxQuantities ( storedResults(resInd)%key, hdfNameIndex, &
              & qty, l2auxDatabase, chunks )
            ! Ignore timing and direct writes
          end select

          ! Now destroy this vector.  We'll do this as we go along to make
          ! life easier for the computer.
          if ( parallel%stageInMemory ) then
            call DestroyVectorInfo ( joinedVectors(valInd) )
            call DestroyVectorTemplateInfo ( joinedVectorTemplates(valInd) )
            call DestroyQuantityTemplateContents ( joinedQuantities(valInd) )
            if ( storedResults(resInd)%gotPrecision ) then
              call DestroyVectorInfo ( joinedVectors(precInd) )
              call DestroyVectorTemplateInfo ( joinedVectorTemplates(precInd) )
              call DestroyQuantityTemplateContents ( joinedQuantities(precInd) )
            end if
          else
            call DestroyQuantityTemplateDatabase ( joinedQuantities )
            call DestroyVectorTemplateInfo ( myValues%template )
            call DestroyVectorInfo ( myValues )
            if ( storedResults(resInd)%gotPrecision ) then
              call DestroyVectorTemplateInfo ( myPrecisions%template )
              call DestroyVectorInfo ( myPrecisions )
            end if
          end if
        end if                          ! Didn't give up on this chunk
      end do
    end do
  end if

d1173 3
a1175 3
      call H5FClose_F ( stageFileID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
        & 'Unable to close staging file:'//parallel%stagingFile )
d1920 1
a1920 1
       "$Id: L2Parallel.f90,v 2.98 2011/05/26 20:39:34 pwagner Exp $"
d1931 3
@


2.98
log
@Widened fields for dumping machinesTid
@
text
@d471 1
a471 1
              if ( switchDetail(switches,'l2q') > -1 ) then
d481 2
a482 1
            call output(chunkTids(nextChunk), advance='yes')
d557 4
a560 4
          call dump(chunkNiceTids, 'chunkNiceTids', options='t')
          call TimeStamp(slaveTid, advance='yes')
          call dump(chunkTids, 'chunkTids')
          call dump(machines%tid, 'machines%Tid')
d1992 1
a1992 1
      call output('Thanking l2q for host', advance='no')
d2001 1
a2001 1
       "$Id: L2Parallel.f90,v 2.97 2011/05/09 18:21:38 pwagner Exp $"
d2012 3
@


2.97
log
@Converted to using switchDetail
@
text
@d1139 1
a1139 1
      call dump( machines%tid, 'machines%Tid', format='(i8)' )
d2000 1
a2000 1
       "$Id: L2Parallel.f90,v 2.96 2010/05/13 23:47:19 pwagner Exp $"
d2011 3
@


2.96
log
@Dropped superseded options run[first][last]
@
text
@d21 10
a30 10
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use BitStuff, only: BitsToBooleans, BooleansToBits
  use Chunks_m, only: DUMP, MLSChunk_T
  use ChunkDivide_m, only: ChunkDivideConfig
  use Dump_0, only: DUMP
  use Init_Tables_Module, only: S_L2GP, S_L2AUX
  use Join, only: JOINL2GPQUANTITIES, JOINL2AUXQUANTITIES
  use L2AUXData, only: L2AUXDATA_T
  use L2GPData, only: L2GPDATA_T
  use L2ParInfo, only: MACHINE_T, PARALLEL, &
d41 12
a52 12
  use Machine, only: SHELL_COMMAND
  use MLSCommon, only: R8
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_ALLOCATE, &
    & MLSMSG_Deallocate, MLSMSG_WARNING, PVMERRORMESSAGE
  use MLSSets, only: FINDFIRST
  use MLSStringLists, only: catLists, ExpandStringRange, RemoveNumFromList, &
    & ReplaceSubString, switchDetail
  use MLSStrings, only: lowerCase
  use MorePVM, only: PVMUNPACKSTRINGINDEX, PVMPACKSTRINGINDEX
  use MLSStrings, only: NAppearances
  use MoreTree, only: Get_Spec_ID
  use Output_m, only: BLANKS, Output, TimeStamp
d57 1
a57 1
    & GETMACHINENAMEFROMTID, PVMFFREEBUF, SIG_AboutToDie
d59 2
a60 2
  use QuantityPVM, only: PVMRECEIVEQUANTITY
  use QuantityTemplates, only: QUANTITYTEMPLATE_T, &
d63 5
a67 5
  use String_table, only: Display_String
  use Symbol_Table, only: ENTER_TERMINAL
  use Symbol_Types, only: T_STRING
  use Time_M, only: Time_Now
  use Toggles, only: Gen, Switches, Toggle
d69 1
a69 1
  use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VECTORTEMPLATE_T, &
d73 1
a73 1
  use WriteMetadata, only: L2PCF
d1322 1
a1322 1
          ! if ( index(switches,'l2q') /=0 ) call output('Sorry, l2q scorns us', advance='yes')
d1338 1
a1338 1
          ! if ( index(switches,'l2q') /=0 ) call output('Good news, l2q likes us', advance='yes')
d1728 1
a1728 1
    use VectorHDF5, only: WRITEVECTORASHDF5
d2000 1
a2000 1
       "$Id: L2Parallel.f90,v 2.95 2010/04/22 23:34:47 pwagner Exp $"
d2011 3
@


2.95
log
@Print more useful error mesg if no chunks to process
@
text
@d375 1
a375 1
    ! Mostly superseded by commandline options like chunkRange
a376 6
    elseif ( switchDetail(switches,'runfirstlast') > -1 ) then
      chunksAbandoned(2:size(chunks)-1) = .true.
    elseif ( switchDetail(switches,'runfirst') > -1 ) then
      chunksAbandoned(2:size(chunks)) = .true.
    elseif ( switchDetail(switches,'runlast') > -1 ) then
      chunksAbandoned(1:size(chunks)-1) = .true.
d2000 1
a2000 1
       "$Id: L2Parallel.f90,v 2.94 2009/09/18 00:30:25 pwagner Exp $"
d2011 3
@


2.94
log
@Dont print misleading lines about busy, avoided machines if using l2q
@
text
@d387 4
d2006 1
a2006 1
       "$Id: L2Parallel.f90,v 2.93 2009/06/23 18:46:18 pwagner Exp $"
d2017 3
@


2.93
log
@Prevent Intel from optimizing ident string away
@
text
@d83 1
a83 1
       "$RCSfile: $"
d1363 1
a1363 1
       if ( .not. USINGOLDSUBMIT ) then
d2002 1
a2002 1
       "$Id: read_apriori.f90 is it here $"
d2013 3
@


2.92
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d83 1
a83 1
       "$RCSfile: L2Parallel.f90,v $"
d1999 1
a2000 1
!---------------------------- RCS Ident Info -------------------------------
d2002 2
a2003 3
       "$Id: L2Parallel.f90,v 2.91 2009/03/18 23:08:27 honghanh Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2005 1
a2005 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2007 1
d2013 3
@


2.91
log
@Kill all running slaves before letting the master dies upon encountering errors.
Added subroutine KillSlaves
@
text
@d558 1
a558 1
          call dump(chunkNiceTids, 'chunkNiceTids', trim=.true.)
d1139 1
a1139 1
      call dump( chunkNiceTids, 'chunkNiceTids', trim=.true. )
d2002 1
a2002 1
       "$Id: L2Parallel.f90,v 2.90 2009/01/12 19:22:04 pwagner Exp $"
d2013 4
@


2.90
log
@Alphabetized procedures; shorten time to finish when told to give up
@
text
@d401 1
a401 2
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Illegal chunk number' )
d443 3
d483 1
d611 2
a612 3
            if ( info == -1 ) & 
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unable to get machine name from tid' )
d643 2
a644 3
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Too many direct write files, increase limit maxDirectWriteFiles in ' &
              & // ModuleName )
d758 1
a758 2
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unkown signal from slave' )
d790 1
a790 2
          call MLSMessage( MLSMSG_Error, ModuleName, &
            & 'switch l2q queue manager not running--dead or not started yet?' )
d867 1
d986 1
a986 2
             call MLSMessage ( MLSMSG_Error, ModuleName, &
               & 'Dead slave tid doesnt match machine tid' )
d1106 1
a1106 2
      if ( all(chunksAbandoned) ) call MLSMessage( MLSMSG_Error, ModuleName, &
        & 'All chunks abandoned' )
d1144 1
a1144 22
    do chunk = 1, noChunks
      if ( chunkTids(chunk) /= 0 ) then
        call usleep ( KILLINGSLAVESDELAY )
        if ( usingL2Q ) then
          machine = chunkMachines(chunk)
          call TellL2QMachineFinished( &
            & trim(machines(machine)%name), machines(machine)%tid, L2Qtid, 0 )
          if ( switchDetail(switches,'l2q') > -1 ) then
            call output( 'tid: ', advance='no' )
            call output( machines(machine)%tid, advance='no' )
            call output( 'machine name: ', advance='no' )
            call output( trim(machines(machine)%name), advance='no' )
            call TimeStamp ( '   released', &
            & advance='yes' )
          endif
          call usleep ( parallel%delay )
        endif
        call pvmfkill ( chunkTids(chunk), info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'killing slave' )
      end if
    end do
d1402 35
d2002 1
a2002 1
       "$Id: L2Parallel.f90,v 2.89 2008/06/12 22:28:27 pwagner Exp $"
d2013 3
@


2.89
log
@Added options to print direct write timings
@
text
@d91 2
a92 1
  integer, parameter :: FIXDELAYFORSLAVETOFINISH   = 1500000 ! 15000000 ! 15 sec
d103 2
a104 69
contains ! ================================ Procedures ======================

  ! --------------------------------------------- SendChunkInfoToSlave ----------
  subroutine SendChunkInfoToSlave ( chunks, chunkNo, slaveTid )
    ! This routine sends a chunk to a slave task

    ! Dummy arguments
    type (MLSChunk_T), intent(in), dimension(:) :: CHUNKS ! The chunk
    integer, intent(in) :: CHUNKNO      ! Which one is it.
    integer, intent(in) :: SLAVETID     ! Who to send it to

    ! Local variables
    integer :: BUFFERID                 ! ID for buffer to send
    integer :: INFO                     ! Flag from PVM
    integer :: CHUNK                    ! Loop counter
    integer :: BITS

    ! Executable code
    call BooleansToBits( (/ ChunkDivideConfig%allowPriorOverlaps, &
      & ChunkDivideConfig%allowPostOverlaps /), Bits )
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( (/ size(chunks), chunkNo /), info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing noChunks and chunkNo' )
    do chunk = 1, size(chunks)
      call PVMF90Pack ( &
        & (/ chunks(chunk)%firstMAFIndex, &
        &    chunks(chunk)%lastMAFIndex, &
        &    chunks(chunk)%noMAFsLowerOverlap, &
        &    chunks(chunk)%noMAFsUpperOverlap, &
        &    chunks(chunk)%chunkNumber /), info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing one chunk header' )

      if ( associated ( chunks(chunk)%hGridOffsets ) ) then
        call PVMF90Pack ( size ( chunks(chunk)%hGridOffsets ), info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing size(hGridOffsets)' )
        call PVMF90Pack ( chunks(chunk)%hGridOffsets, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing hGridOffsets chunk' )
      else
        call PVMF90Pack ( 0, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing 0 for size(hGridOffsets)' )
      end if

      if ( associated ( chunks(chunk)%hGridTotals ) ) then
        call PVMF90Pack ( size ( chunks(chunk)%hGridTotals ), info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing size(hGridTotals)' )
        call PVMF90Pack ( chunks(chunk)%hGridTotals, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing hGridTotals chunk' )
      else
        call PVMF90Pack ( 0, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'packing 0 for size(hGridTotals)' )
      end if

    end do
    call PVMF90Pack ( Bits, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing overlaps outside proc. rnge' )
    call PVMFSend ( slaveTid, ChunkTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending chunk' )
  end subroutine SendChunkInfoToSlave

d304 1
a304 1

d775 3
d1148 1
a1148 1
        call usleep ( 100*parallel%delay )
a1169 1
      ! call usleep ( 500*parallel%delay )
d1427 1
a1427 1

d1445 44
d1509 205
d1865 1
a1865 179
  ! --------------------------------- CleanUpDeadChunksOutput -------------
  subroutine CleanUpDeadChunksOutput ( chunk, joinedQuantities, &
    & joinedVectorTemplates, joinedVectors, storedResults )
    ! This destroys the vector info etc. associated with any output
    ! from a dead chunk.
    integer, intent(in) :: CHUNK        ! Index of chunk
    type (QuantityTemplate_T), dimension(:), pointer :: JOINEDQUANTITIES
    type (VectorTemplate_T), dimension(:), pointer :: JOINEDVECTORTEMPLATES
    type (Vector_T), dimension(:), pointer :: JOINEDVECTORS
    type (StoredResult_T), dimension(:), pointer :: STOREDRESULTS

    ! Local variables
    integer :: PRECIND                  ! Index for precision (if any)
    integer :: VALIND                   ! Index for value
    integer :: RES                      ! Loop counter

    ! Executable code
    if ( .not. associated(storedResults) ) return
    
    do res = 1, size ( storedResults )
      valInd = storedResults(res)%valInds(chunk)
      if ( valInd /= 0 ) then
        if ( parallel%stageInMemory ) then
          call DestroyVectorInfo ( joinedVectors(valInd) )
          call DestroyVectorTemplateInfo ( joinedVectorTemplates(valInd) )
          call DestroyQuantityTemplateContents ( joinedQuantities(valInd) )
        end if
        storedResults(res)%valInds(chunk) = 0
      end if

      if ( storedResults(res)%gotPrecision ) then
        precInd = storedResults(res)%precInds(chunk)
        if ( precInd /= 0 ) then
          if ( parallel%stageInMemory ) then
            call DestroyVectorInfo ( joinedVectors(precInd) )
            call DestroyVectorTemplateInfo ( joinedVectorTemplates(precInd) )
            call DestroyQuantityTemplateContents ( joinedQuantities(precInd) )
          end if
          storedResults(res)%precInds(chunk) = 0
        end if
      end if
    end do
  end subroutine CleanUpDeadChunksOutput
  
  subroutine RegisterWithL2Q(noChunks, machines, L2Qtid)
    integer, intent(in)                                  :: noChunks
    type(machine_t), dimension(:), pointer :: MACHINES
    ! character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
    integer, intent(out)                                 :: L2Qtid
    !
    integer :: BUFFERID                 ! From PVM
    character(len=16) :: DATESTRING
    integer :: INDX
    integer :: INFO                     ! From PVM
    character(len=16) :: L2QSTRING
    !
    call pvmfgettid(GROUPNAME, 0, L2Qtid)
    if ( L2Qtid < 1 ) then
      call MLSMessage( MLSMSG_Error, ModuleName, &
        & 'l2q queue manager not running--dead or not started yet?' )
    else
      write ( L2QSTRING, * ) L2QTID
      call TimeStamp('Registering with l2q (l2qtid=' // &
        & trim(L2QSTRING) // ')', advance='yes')
    endif
    call GetMachines ( machines )
    ! Register ourselves with the l2 queue manager
    ! Identify ourselves
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( SIG_Register, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing registration' )
    call PVMF90Pack ( noChunks, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing number of chunks' )
    ! Now send our data date as a string
    ! We might reasonably expect one of two formats for startUTC:
    ! 1996-051T00:00:00.000000Z (using yyyy-dayofyear)
    ! 2006-05-07T00:00:00.000000Z (using yyyy-month-dayofmonth)
    ! (e.g., '2006d121')
    indx = INDEX (L2PCF%startUTC, "T")
    if ( indx > 0 ) then
      if ( all( NAppearances(L2PCF%startUTC(1:indx-1), (/'-'/)) > 1 ) ) then
        dateString = L2PCF%startUTC(1:indx-1) ! it was yyyy-month-dayofmonth
      else
        call ReplaceSubString ( L2PCF%startUTC(1:indx-1), dateString, &
        & '-', 'd' )  ! it was yyyy-dayofyear
      endif
    else
      dateString = '(unknown)'
    endif
    call PVMF90Pack ( dateString, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing date' )
    call PVMFSend ( L2Qtid, petitionTag, info )
    ! call PVMF90Pack ( noChunks, info )
    ! if ( info /= 0 ) &
    !   & call PVMErrorMessage ( info, 'packing L2QTid' )
    ! call PVMFSend ( L2Qtid, petitionTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending finish packet' )
  end subroutine RegisterWithL2Q

  subroutine RequestMachineFromL2Q(L2Qtid, nextChunk, machineName)
    !
    ! request a free host from the l2 queue manager
    integer, intent(in)                               :: L2Qtid
    integer, intent(in)                               :: nextChunk
    character(len=MACHINENAMELEN), intent(out)        :: MACHINENAME
    !
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM
    ! Identify ourselves
    if ( switchDetail(switches,'l2q') > -1 ) &
      & call TimeStamp('Requesting host from l2q', advance='yes')
    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( sig_requestHost, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing registration' )
    call PVMF90Pack ( nextChunk, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'packing number of chunk' )
    call PVMFSend ( L2Qtid, petitionTag, info )
    if ( info /= 0 ) &
      & call PVMErrorMessage ( info, 'sending finish packet' )
    call ReceiveMachineFromL2Q(machineName)
  end subroutine requestMachineFromL2Q

  subroutine ReceiveMachineFromL2Q(machineName)
    !
    ! request a free host from the l2 queue manager
    character(len=MACHINENAMELEN), intent(out)        :: MACHINENAME
    !
    integer :: BEAT
    integer :: INFO                     ! From PVM
    integer :: BUFFERIDRCV              ! From PVM
    ! How many times to listen for queue manager's granting of request
    ! (Setting NBEATS=0 means merely register the request with queue manager;
    ! subsequent trips through master event loop will pick up message
    ! when and if queue manager grants our request)
    integer, parameter :: NBEATS = 0  ! 16   ! ~2x MAXNUMMASTERS  
    ! Possibly a machine is free and the queue manager will
    ! respond quickly
    ! (This idea is tentative, however)
    ! Now let's give queue manager a chance to receive our request
    ! and deliberate a while (but not too long)
    ! before giving up and going back to checking on our own slaves
    
    ! In fact this was a bad idea, or it turned out bad, anyway:
    ! It slowed processing routine communication by the master to no more
    ! than one message per NBEATS*delaytime, so long as the master was
    ! hoping to hear from the queue manager. This meant between 3 and 4 seconds
    ! between each signal being processed, so signals piled up in a huge
    ! line waiting to be received and acted upon.
    machineName = ' '
    do beat = 1, max(NBEATS, 1)
      call PVMFNRecv( -1, GRANTEDTAG, bufferIDRcv )
      if ( bufferIDRcv < 0 ) then
        call PVMErrorMessage ( info, "checking for Granted message" )
      else if ( bufferIDRcv > 0 ) then
        if ( switchDetail(switches,'l2q') > -1 ) &
          & call TimeStamp('Weve been granted a host', advance='yes')
        ! Granted us a machine
        call PVMF90Unpack ( machineName, info )
        if ( info /= 0 ) then
          call PVMErrorMessage ( info, "unpacking machine name" )
        endif
        if ( len_trim(machineName) < 1 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'granted blank host name' )
        return
      else
        if ( beat < max(NBEATS, 1)) call usleep ( parallel%delay )
      endif
    enddo
    if ( switchDetail(switches,'l2q') > -1 .and. len_trim(machineName) > 0 ) &
      & call TimeStamp('Received from l2q ' // trim(machineName), advance='yes')
  end subroutine ReceiveMachineFromL2Q

d1900 1
d1933 1
d1950 1
d1986 1
d1990 1
a1990 1
       "$Id: L2Parallel.f90,v 2.88 2008/04/03 00:13:39 pwagner Exp $"
d1994 1
d2001 3
@


2.88
log
@Not the nicest way to fix mlssubmit/pvm launching multiple instances of same slave
@
text
@d339 2
d348 1
d389 3
d768 5
d980 5
d1117 1
d1248 5
d1460 15
d1979 1
a1979 1
       "$Id: L2Parallel.f90,v 2.87 2008/01/23 21:26:01 pwagner Exp $"
d1989 3
@


2.87
log
@filters --chunks from slaveArguments
@
text
@d646 20
d1942 1
a1942 1
       "$Id: L2Parallel.f90,v 2.86 2007/12/07 01:51:08 pwagner Exp $"
d1952 3
@


2.86
log
@Removed unused dummy variables, etc.
@
text
@d46 3
a48 2
  use MLSStringLists, only: catLists, ExpandStringRange, ReplaceSubString, &
    & switchDetail
d324 2
d464 14
d483 1
a483 1
            & trim(slaveArguments)
d1922 1
a1922 1
       "$Id: L2Parallel.f90,v 2.85 2007/11/01 23:31:47 pwagner Exp $"
d1932 3
@


2.85
log
@Print clearer msgs when unable to launch slave
@
text
@d646 1
a646 1
            & storedResults, chunk, noChunks, slaveTid, noQuantitiesAccumulated, &
d1252 1
a1252 1
              & qty, l2auxDatabase, chunk, chunks )
d1344 1
a1344 1
          call ReceiveMachineFromL2Q(L2Qtid, machineName)
d1457 1
a1457 1
    & joinedVectors, storedResults, chunk, noChunks, tid, noQuantitiesAccumulated,&
a1468 1
    integer, intent(in) :: TID          ! Slave tid
d1731 1
a1731 1
    call ReceiveMachineFromL2Q(L2Qtid, machineName)
d1734 1
a1734 1
  subroutine ReceiveMachineFromL2Q(L2Qtid, machineName)
a1736 1
    integer, intent(in)                               :: L2Qtid
d1905 1
a1905 1
       "$Id: L2Parallel.f90,v 2.84 2007/09/06 23:34:06 pwagner Exp $"
d1915 3
@


2.84
log
@Delays a bit to prevent l2q from killing finishing slave
@
text
@d532 5
a536 1
              if ( info < 0 ) then
d1907 1
a1907 1
       "$Id: L2Parallel.f90,v 2.83 2007/02/27 00:01:46 pwagner Exp $"
d1917 3
@


2.83
log
@Change log message so grep -i died gives number died, not 2x
@
text
@d90 1
a90 4
  ! integer, parameter :: MAXCHUNK = 10000

  integer :: counterStart
  parameter ( counterStart = 2 * (huge (0) / 4 ) )
a184 1
    ! character(len=16) :: CHUNKSTR
a206 4
!     write(chunkStr, *) chunkNo
!     if ( ChunkNo > MAXCHUNK ) &
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & 'chunk number too great: ' // trim(chunkStr) )
a337 3
    ! logical, dimension(:), pointer :: MACHINEFREE ! Is this machine busy
    ! logical, dimension(:), pointer :: MACHINEOK ! Is this machine working?
    ! integer, dimension(:), pointer :: JOBSMACHINEKILLED ! Counts failures per machine.
a378 3
    ! nullify ( joinedQuantities, joinedVectorTemplates, joinedVectors, &
    !  & machineNames, machineFree, storedResults, machineOK, jobsMachineKilled, &
    !  & directWriteRequests )
a454 2
      ! do while ( (.not. all(chunksStarted .or. chunksAbandoned)) .and. &
      !  & ( any(machineFree .and. machineOK) .or. usingSubmit ) )
a455 1
        ! nextChunk = FindFirst ( (.not. chunksStarted) .and. (.not. chunksAbandoned) )
a478 1
          ! machine = FindFirst(machineFree .and. machineOK)
d766 2
a767 1
              & trim(machines(machine)%name), machines(machine)%tid, L2Qtid )
d1146 3
a1148 3
      call dump(chunkNiceTids, 'chunkNiceTids', trim=.true.)
      call dump(chunkTids, 'chunkTids')
      call dump(machines%tid, 'machines%Tid')
d1157 1
a1157 1
            & trim(machines(machine)%name), machines(machine)%tid, L2Qtid )
d1175 1
a1175 1
      call usleep ( 500*parallel%delay )
d1817 1
a1817 1
  subroutine TellL2QMachineFinished(machineName, tid, L2Qtid)
d1821 1
d1826 2
d1903 1
a1903 1
       "$Id: L2Parallel.f90,v 2.82 2007/02/14 17:29:51 pwagner Exp $"
d1913 3
@


2.82
log
@Lengthened time allowed for slaves to complete final tasks
@
text
@d1827 1
a1827 1
      call output('Telling l2q host died ', advance='no')
d1917 1
a1917 1
       "$Id: L2Parallel.f90,v 2.81 2007/02/13 21:36:19 pwagner Exp $"
d1927 3
@


2.81
log
@Lengthen delays before telling l2q we finished so slaves may complete timings summary
@
text
@d1170 1
a1170 1
        call usleep ( 50*parallel%delay )
d1192 1
a1192 1
      call usleep ( 100*parallel%delay )
d1917 1
a1917 1
       "$Id: L2Parallel.f90,v 2.80 2007/01/12 00:38:57 pwagner Exp $"
d1927 3
@


2.80
log
@Switches allegiance to a replacement l2q
@
text
@d1170 1
d1192 1
a1192 1
      call usleep ( parallel%delay )
d1917 1
a1917 1
       "$Id: L2Parallel.f90,v 2.79 2006/11/22 18:11:04 pwagner Exp $"
d1927 3
@


2.79
log
@Help l2q track hosts freed by killed masters
@
text
@d33 1
a33 1
    & SIG_REQUESTDIRECTWRITE, &
d49 1
d88 1
d809 27
d1193 3
d1673 1
a1673 1
    character(len=*), parameter :: GROUPNAME = "mlsl2"
d1679 4
d1695 3
d1701 6
a1706 2
      call ReplaceSubString ( L2PCF%startUTC(1:indx-1), dateString, &
        & '-', 'd' )
d1810 1
a1810 1
      & call PVMErrorMessage ( info, 'packing registration' )
d1850 1
a1850 1
      & call PVMErrorMessage ( info, 'packing registration' )
d1872 1
a1872 1
      & call PVMErrorMessage ( info, 'packing registration' )
d1889 1
a1889 1
      & call PVMErrorMessage ( info, 'packing registration' )
d1916 1
a1916 1
       "$Id: L2Parallel.f90,v 2.78 2006/10/11 00:30:15 pwagner Exp $"
d1926 3
@


2.78
log
@Fixed bug in length of arg MACHINENAME
@
text
@d1132 6
a1140 3
        call pvmfkill ( chunkTids(chunk), info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, 'killing slave' )
d1145 9
d1155 3
d1162 1
d1798 5
d1873 1
a1873 1
       "$Id: L2Parallel.f90,v 2.77 2006/09/29 00:29:42 pwagner Exp $"
d1883 3
@


2.77
log
@Fixes bug where masters try to free dead hosts when finished
@
text
@d30 1
a30 1
  use L2ParInfo, only: L2PARALLELINFO_T, MACHINE_T, PARALLEL, &
d52 2
a53 2
    & PVMDATADEFAULT, PVMFINITSEND, PVMF90PACK, PVMFKILL, PVMFMYTID, &
    & PVMF90UNPACK, PVMTASKHOST, PVMFSPAWN, &
d56 2
a57 2
  use PVMIDL, only: PVMIDLPACK, PVMIDLUNPACK
  use QuantityPVM, only: PVMSENDQUANTITY, PVMRECEIVEQUANTITY
d273 1
a273 1
    use VectorHDF5, only: WRITEVECTORASHDF5, READVECTORFROMHDF5
a301 1
    integer :: COMPLETEDFILE            ! String index from slave
a303 1
    integer :: DEADFILE                 ! ID of file writen by dead task
a353 1
    logical :: INTEGRITY
d1423 1
a1423 1
    use VectorHDF5, only: WRITEVECTORASHDF5, READVECTORFROMHDF5
a1669 1
    integer :: BEAT
a1671 1
    integer :: BUFFERIDRCV              ! From PVM
a1694 1
    integer :: BUFFERID                 ! From PVM
d1775 1
a1775 1
    character(len=MACHINENAMELEN)        :: MACHINENAME
d1852 1
a1852 1
       "$Id: L2Parallel.f90,v 2.76 2006/08/05 02:12:27 vsnyder Exp $"
d1862 3
@


2.76
log
@Add ForWhom argument to ConstructVectorTemplate
@
text
@d46 2
a47 1
  use MLSStringLists, only: catLists, ExpandStringRange, switchDetail
d296 1
d523 5
a527 2
            if ( indx > 0 ) &
              & machines(machine)%master_Date = L2PCF%startUTC(1:indx-1)
d994 3
d1625 2
d1645 12
d1658 4
d1858 1
a1858 1
       "$Id: L2Parallel.f90,v 2.75 2006/04/20 23:21:37 pwagner Exp $"
d1868 3
@


2.75
log
@Pass more chunk info from master to slave
@
text
@d1503 1
a1503 1
          & (/ noQuantitiesAccumulated /), vt )
d1511 1
a1511 1
        call ConstructVectorTemplate ( 0, (/ qt /), (/ 1 /), vt )
d1832 1
a1832 1
       "$Id: L2Parallel.f90,v 2.74 2005/06/22 18:57:02 pwagner Exp $"
d1842 3
@


2.74
log
@Reworded Copyright statement, moved rcs id
@
text
@d22 1
d24 1
d46 1
a46 1
  use MLSStringLists, only: catLists, ExpandStringRange
d80 1
a80 1
       "$RCSfile: $"
d116 1
d119 2
d162 3
d182 1
d191 1
d248 18
a265 1
    if ( index(switches,'chu') /=0 ) call dump ( chunks )
d411 1
a411 1
      if ( index(switches,'mach') /=0 ) call dump ( machines )
d419 1
a419 1
      if ( index(switches,'mach') /=0 ) call dump ( machines )
d444 2
d447 1
a447 1
    elseif ( index(switches,'runfirstlast') /=0 ) then
d449 1
a449 1
    elseif ( index(switches,'runfirst') /=0 ) then
d451 1
a451 1
    elseif ( index(switches,'runlast') /=0 ) then
d487 1
a487 1
          if ( index(switches,'mas') /= 0 ) then
d497 1
a497 1
          if ( index(switches,'slv') /= 0 ) then
d504 1
a504 1
          if ( index(switches,'mas') /= 0 ) then
d527 2
a528 2
            if ( index(switches,'mas') /= 0 ) then
              if ( index(switches,'l2q') /= 0 ) then
d543 1
a543 1
            if ( index(switches,'mas') /= 0 ) then
d645 1
a645 1
            if ( index(switches,'mas') /= 0 ) then
d695 1
a695 1
          if ( index ( switches, 'mas' ) /= 0 ) then
d726 1
a726 1
          if ( index ( switches, 'mas' ) /= 0 ) then
d740 1
a740 1
          if ( index(switches,'mas') /= 0 ) then
d759 1
a759 1
          if ( index(switches,'mas') /= 0 ) &
d774 1
a774 1
          if ( index(switches,'mas') /= 0 ) then
d798 1
a798 1
        if ( index(switches,'mas') /= 0 ) then
d818 1
a818 1
          if ( index(switches,'mas') /= 0 ) then
d874 2
a875 2
            if ( index(switches,'mas') /= 0 ) then
              if ( index(switches,'l2q') /= 0 ) then
d905 1
a905 1
              if ( index(switches,'mas') /= 0 ) then
d927 1
a927 1
              if ( index(switches,'mas') /= 0 ) then
d942 1
a942 1
                if ( index(switches,'mas') /= 0 ) &
d962 1
a962 1
            if ( index(switches,'mas') /= 0 .and. NOTFORGOTTEN ) call TimeStamp ( &
d982 1
a982 1
          if ( index(switches,'l2q') /= 0 ) then
d990 1
a990 1
          if ( index(switches,'l2q') /= 0 ) then
d1049 1
a1049 1
        if ( index(switches,'mas') /= 0 ) then
d1089 1
a1089 1
        & noDirectWriteRequests / 2 .and. index(switches,'dwreq') == 0 ) then
d1100 1
a1100 1
        if ( index(switches,'mas') /= 0 ) &
d1114 1
a1114 1
          if ( index(switches,'mas') /= 0 ) &
d1153 1
a1153 1
    if ( index(switches,'mas') /= 0 ) then
d1171 1
a1171 1
        if ( index(switches,'mas') /= 0 ) then
d1268 1
a1268 1
    if ( index(switches,'mas') /= 0 ) then
d1271 2
a1272 2
    dumpfulldwreqs = index(switches,'dwreq1') /= 0
    if ( index(switches,'dwreq') /= 0 ) &
d1323 1
a1323 1
            if ( index(switches,'l2q') /=0 ) &
d1652 1
a1652 1
    if ( index(switches,'l2q') /=0 ) &
d1701 1
a1701 1
        if ( index(switches,'l2q') /=0 ) &
d1716 1
a1716 1
    if ( index(switches,'l2q') /=0 .and. len_trim(machineName) > 0 ) &
a1719 1
  ! subroutine TellL2QMachineDied(tid, L2Qtid)
a1720 2
    ! character(len=MACHINENAMELEN)        :: MACHINENAME
    ! integer, intent(in)                                 :: tid
d1746 1
a1746 1
    if ( index(switches, 'l2q') > 0 ) then
d1823 1
a1823 1
    if ( index(switches, 'l2q') > 0 ) then
d1832 1
a1832 1
       "$Id: $"
d1842 3
@


2.73
log
@Tried to fix slowing of masters relying on l2q
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d76 1
a76 4
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
    "$Id: L2Parallel.f90,v 2.72 2005/03/15 23:55:48 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d78 1
a78 1
    "$RCSfile: L2Parallel.f90,v $"
d80 1
a80 1
  !---------------------------------------------------------------------------
d1804 5
d1816 3
@


2.72
log
@Saves error messages from about-to-die chunks
@
text
@d53 1
d70 1
a70 1
    "$Id: L2Parallel.f90,v 2.71 2005/02/03 19:09:15 pwagner Exp $"
d80 1
a80 1
  integer, parameter :: MAXCHUNK = 10000
d171 1
a171 1
    character(len=16) :: CHUNKSTR
d193 4
a196 4
    write(chunkStr, *) chunkNo
    if ( ChunkNo > MAXCHUNK ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'chunk number too great: ' // trim(chunkStr) )
d275 1
d658 1
d687 1
d741 1
a741 20
            call TimeStamp ( 'Master status:', advance='yes' )
            call output ( count(chunksCompleted) )
            call output ( ' of ' )
            call output ( noChunks )
            call output ( ' chunks completed, ')
            call output ( count(chunksStarted .and. .not. chunksCompleted) )
            call output ( ' underway, ' )
            call output ( count(chunksAbandoned) )
            call output ( ' abandoned, ' )
            call output ( count(.not. &
              & (chunksStarted .or. chunksCompleted .or. chunksAbandoned ) ) )
            call TimeStamp ( ' left. ', advance='yes' )
            if ( .not. USINGOLDSUBMIT ) then
              call output ( count ( .not. machines%Free ) )
              call output ( ' of ' )
              call output ( noMachines )
              call output ( ' machines busy, with ' )
              call output ( count ( .not. machines%OK ) )
              call TimeStamp ( ' being avoided.', advance='yes' )
            end if
d892 1
d898 1
a899 1
              chunksAbandoned(deadChunk) = .true.
d1006 1
d1055 1
a1055 1
        & noDirectWriteRequests / 2 ) then
d1237 3
a1241 4
    ! call Deallocate_test ( machineFree, 'machineFree', ModuleName )
    ! call Deallocate_test ( machineOK, 'machineOK', ModuleName )
    ! call Deallocate_test ( jobsMachineKilled, 'jobsMachineKilled', ModuleName )

d1302 24
d1647 1
a1647 1
    integer, parameter :: NBEATS = 16   ! ~2x MAXNUMMASTERS  
d1654 7
d1662 1
a1662 1
    do beat = 1, NBEATS
d1679 1
a1679 1
        call usleep ( parallel%delay )
d1806 3
@


2.71
log
@Receives master_date, master_time data from masters for each host
@
text
@d21 1
a21 1
    & INFOTAG, CHUNKTAG, GIVEUPTAG, GRANTEDTAG, PETITIONTAG, &
d34 1
a34 1
    & MLSMSG_Deallocate, MLSMSG_WARNING
d40 3
a42 2
  use PVM, only: PVMDATADEFAULT, PVMFINITSEND, PVMF90PACK, PVMFKILL, PVMFMYTID, &
    & PVMF90UNPACK, PVMERRORMESSAGE, PVMTASKHOST, PVMFSPAWN, &
d44 1
a44 1
    & GETMACHINENAMEFROMTID, PVMFFREEBUF
d69 1
a69 1
    "$Id: L2Parallel.f90,v 2.70 2004/12/27 23:04:21 pwagner Exp $"
d79 1
d170 1
d192 4
a245 1
    ! integer, parameter :: DELAY = 200000  ! For Usleep, no. microsecs
a258 1
    ! character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
d586 9
d604 4
a607 1
            call GetMachineNameFromTid ( slaveTid, thisName )
d1789 3
@


2.70
log
@Fixed bug affecting old submit method
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d39 1
a39 1
  use Output_m, only: BLANKS, Output
d58 1
d68 1
a68 1
    "$Id: L2Parallel.f90,v 2.69 2004/12/14 21:54:23 pwagner Exp $"
d271 1
a383 6
    ! call Allocate_test ( machineFree, noMachines, 'machineFree', ModuleName )
    ! call Allocate_test ( machineOK, noMachines, 'machineOK', ModuleName )
    ! call Allocate_test ( jobsMachineKilled, noMachines, 'jobsMachineKilled', ModuleName )
    ! machineFree = .true.
    ! machineOK = .true.
    ! jobsMachineKilled = 0
d448 1
a448 1
            call output ( nextChunk, advance='yes' )
d465 1
a465 1
            call output ( trim(commandLine), advance='yes' )
d479 3
d493 1
a493 1
              call output ( ' on slave ' // trim(machines(machine)%name) // &
a497 1
            ! if ( usingL2Q ) call ThankL2Q(chunkTids(nextChunk), L2Qtid)
d506 1
a506 1
                call output ( info, advance='yes' )
d508 1
a508 1
                call output ( tidArr(1), advance='yes' )
d510 1
a510 1
              call output ( 'Marking this machine as not usable', advance='yes')
d554 1
a554 1
            call output ( ' Tid: ' // trim ( GetNiceTidString ( slaveTid ) ), &
d563 1
a563 1
          call output ( ' Tid: ' // trim ( GetNiceTidString ( slaveTid ) ), &
d568 1
a568 1
          call output(slaveTid, advance='yes')
d596 1
a596 1
              call output ( chunk, advance='yes' )
d653 1
a653 1
            call output ( directWriteFilenames ( fileIndex ), advance='yes' )
d679 1
a679 1
            call output ( returnedTicket, advance='yes')
d691 1
a691 1
            call output ( chunk, advance='yes')
d705 1
a705 1
            & call output ( 'Acknowledgment sent', advance='yes')
d720 1
a720 1
            call output ( 'Master status:', advance='yes' )
d731 1
a731 1
            call output ( ' left. ', advance='yes' )
d738 1
a738 1
              call output ( ' being avoided.', advance='yes' )
d763 1
a763 1
          call output ( 'Received an external message to give up, so finishing now', &
d783 1
a783 1
            call output ( 'Received an external message to trust ' // &
d848 1
a848 1
              call output ( trim(GetNiceTidString(deadTid)) // &
d877 1
a877 1
                call output ( request%ticket, advance='yes')
d893 1
a893 1
                call output ( ' keeps dying.  Giving up on it.', &
d906 1
a906 1
                  & call output ('The machine ' // &
d925 1
a925 1
            if ( index(switches,'mas') /= 0 .and. NOTFORGOTTEN ) call output ( &
d948 1
a948 1
            call output ( ' on slave ' // trim(machines(deadMachine)%name) // &
d956 1
a956 1
            call output ( ' finished normally ', advance='yes' )
d1021 1
a1021 1
          call output ( request%fileIndex, advance='yes' )
d1063 1
a1063 1
          & call output ( 'All chunks either processed or abandoned', advance='yes' )
d1077 1
a1077 1
            & call output ( 'No machines left to do the remaining work', &
d1116 1
a1116 1
      call output ( 'All chunks processed, starting join task', advance='yes' )
d1134 1
a1134 1
          call output ( 'Joining ' // trim ( storedResults(resInd)%hdfName ), &
d1231 1
a1231 1
      call output ( 'All chunks joined', advance='yes' )
d1286 2
a1287 1
            if ( index(switches,'l2q') /=0 ) call output('Added machine to db', advance='yes')
d1591 2
a1592 1
    if ( index(switches,'l2q') /=0 ) call output('Requesting host from l2q', advance='yes')
d1634 1
a1634 1
          & call output('Weve been granted a host', advance='yes')
d1649 1
a1649 1
      & call output('Received from l2q ' // trim(machineName), advance='yes')
d1685 1
a1685 1
      call output(machine%tid, advance='yes')
d1730 2
a1731 4
  ! subroutine ThankL2Q(tid, L2Qtid)
    ! integer, intent(in)                                 :: tid
    type(machine_T), intent(in)                         :: machine
    integer, intent(in)                                 :: L2Qtid
d1747 8
d1760 1
a1760 1
      call output(machine%tid, advance='yes')
d1772 3
@


2.69
log
@Changes related to l2q
@
text
@d67 1
a67 1
    "$Id: L2Parallel.f90,v 2.68 2004/09/16 23:57:31 pwagner Exp $"
d551 10
d562 1
a562 2
        if ( machine == 0 .and. &
          &  (.not. USINGOLDSUBMIT .or. signal /= sig_register) ) then
d1766 3
@


2.68
log
@Now tracks machine names of failed chunks
@
text
@d20 2
a21 1
  use L2ParInfo, only: L2PARALLELINFO_T, PARALLEL, INFOTAG, CHUNKTAG, GIVEUPTAG, &
d23 8
a30 4
    & SIG_REQUESTDIRECTWRITE, SIG_DIRECTWRITEGRANTED, SIG_DIRECTWRITEFINISHED, &
    & GETNICETIDSTRING, SLAVEARGUMENTS, MACHINENAMELEN, GETMACHINENAMES, &
    & MACHINEFIXEDTAG, DIRECTWRITEREQUEST_T, DW_PENDING, DW_INPROGRESS, DW_COMPLETED, &
    & INFLATEDIRECTWRITEREQUESTDB, COMPACTDIRECTWRITEREQUESTDB, DUMP
d39 1
a39 1
  use Output_m, only: Output
d53 1
d67 1
a67 1
    "$Id: L2Parallel.f90,v 2.67 2004/09/16 00:18:03 pwagner Exp $"
d76 1
d246 1
a246 1
    logical :: USINGSUBMIT              ! Set if using the submit mechanism
d248 5
a252 1
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES
d271 1
d297 1
d303 3
a305 3
    logical, dimension(:), pointer :: MACHINEFREE ! Is this machine busy
    logical, dimension(:), pointer :: MACHINEOK ! Is this machine working?
    integer, dimension(:), pointer :: JOBSMACHINEKILLED ! Counts failures per machine.
d315 2
d338 1
d340 2
d346 1
a346 1
      & machineNames, machineFree, storedResults, machineOK, jobsMachineKilled, &
d348 3
d363 16
a378 3
    if ( .not. usingSubmit ) then
      call GetMachineNames ( machineNames )
      noMachines = size(machineNames)
d382 6
a387 6
    call Allocate_test ( machineFree, noMachines, 'machineFree', ModuleName )
    call Allocate_test ( machineOK, noMachines, 'machineOK', ModuleName )
    call Allocate_test ( jobsMachineKilled, noMachines, 'jobsMachineKilled', ModuleName )
    machineFree = .true.
    machineOK = .true.
    jobsMachineKilled = 0
d403 1
d422 1
d425 1
d431 9
a439 4
      do while ( (.not. all(chunksStarted .or. chunksAbandoned)) .and. &
        & ( any(machineFree .and. machineOK) .or. usingSubmit ) )
        nextChunk = FindFirst ( (.not. chunksStarted) .and. (.not. chunksAbandoned) )
        if ( usingSubmit ) then ! --------------------- Using a batch system
d448 1
d454 5
a458 2
        else ! ----------------------------------------- Start job using pvmspawn
          machine = FindFirst(machineFree .and. machineOK)
d465 1
a465 1
            & trim(machineNames(machine)), &
d473 1
a473 1
            call output ( trim(machineNames(machine)), advance='yes' )
d480 3
a482 1
            machineFree(machine) = .false.
d485 1
d488 4
d494 2
a495 2
              call output ( ' on slave ' // trim(machineNames(machine)) // &
                & ' ' // trim(GetNiceTidString(chunkTids(nextChunk))), &
d499 3
d506 1
a506 1
                & trim(machineNames(machine)) // ' info=' )
d515 2
a516 2
            where ( machineNames == machineNames(machine) )
              machineOK = .false.
d518 4
d536 1
d547 7
a553 3
        chunk = FindFirst ( chunkTids, slaveTid )
        if ( chunk == 0 .and. &
          &  (.not. usingSubmit .or. signal /= sig_register) ) then
d560 4
d567 3
a569 2
          if ( .not. usingSubmit .and. signal /= sig_register ) &
            & machine = chunkMachines(chunk)
d580 1
a580 1
          if ( usingSubmit ) then
d627 1
a627 1
          if ( .not. usingSubmit ) request%machine = machine
d636 2
a637 2
            if ( .not. usingSubmit ) &
              & call output ( trim(machineNames(machine)) // ', ' )
d666 2
a667 2
            if ( .not. usingSubmit ) &
              & call output ( trim(machineNames(machine)) // ', ' )
d680 2
a681 2
            if ( .not. usingSubmit ) &
              & call output ( trim(machineNames(machine)) // ' ' )
d697 2
d703 6
a708 2
          if ( .not. usingSubmit ) then
            machineFree(machine) = .true.
d725 2
a726 2
            if ( .not. usingSubmit ) then
              call output ( count ( .not. machineFree ) )
d730 1
a730 1
              call output ( count ( .not. machineOK ) )
d734 5
d745 1
a745 1
        ! Free the recieve buffer
d771 1
a771 1
        if ( usingSubmit ) then
d779 3
a781 3
          where ( machineNames == thisName )
            machineOK = .true.
            jobsMachineKilled = 0
d787 7
a793 1
      call PVMFNRecv ( -1, NotifyTAG, bufferIDRcv )
d795 2
a796 2
        ! So we got a message.  There may be another one following on so don't delay
        ! before going round this loop again.
d798 3
d804 15
a818 3
        ! Now this may well be a legitimate exit, in which case, we won't
        ! know about this tid any more.  Otherwise we need to tidy up.
        if ( any ( chunkTids == deadTid ) ) then
d820 3
a822 1

d825 5
a829 4
          if ( deadChunk /= 0 ) then
            if ( .not. usingSubmit ) then
              deadMachine = chunkMachines(deadChunk)
              machineFree(deadMachine) = .true.
d832 4
d839 2
a840 2
              if ( .not. usingSubmit ) &
                & call output ( 'on ' // trim(machineNames(deadMachine)) // ' ' )
d848 3
a850 3
            if ( .not. usingSubmit ) then
              where ( machineNames(deadMachine) == machineNames )
                jobsMachineKilled = jobsMachineKilled + 1
d864 2
a865 2
                if ( .not. usingSubmit ) &
                  & call output ( trim(machineNames(deadMachine)) // ', ' )
d895 2
a896 2
            if ( .not. usingSubmit ) then
              if ( jobsMachineKilled(deadMachine) >= &
d900 1
a900 1
                  & trim(machineNames(deadMachine)) // &
d903 2
a904 2
                where ( machineNames(deadMachine) == machineNames )
                  machineOK = .false.
d911 1
a911 1
            if ( .not. usingSubmit ) &
d913 1
a913 1
            & catLists(parallel%failedMachs, trim(machineNames(deadMachine)))
d918 1
a918 1
            if ( index(switches,'mas') /= 0 ) call output ( &
d923 35
a957 2
        end if

d1006 2
a1007 2
          if ( .not. usingSubmit ) &
            & call output ( trim(machineNames(request%machine)) // ' ' )
d1066 2
a1067 2
      if ( .not. usingSubmit ) then
        if ( .not. any(machineOK) .and. &
d1088 5
d1096 3
d1226 1
d1228 3
a1230 3
    call Deallocate_test ( machineFree, 'machineFree', ModuleName )
    call Deallocate_test ( machineOK, 'machineOK', ModuleName )
    call Deallocate_test ( jobsMachineKilled, 'jobsMachineKilled', ModuleName )
d1234 57
d1540 208
d1757 3
@


2.67
log
@Keeps record of completed, failed chunks
@
text
@d61 1
a61 1
    "$Id: L2Parallel.f90,v 2.66 2004/08/05 22:47:47 pwagner Exp $"
d802 3
d1341 3
@


2.66
log
@New --chunkRange option to run selected chunks in parallel mode
@
text
@d31 1
a31 1
  use MLSStringLists, only: ExpandStringRange
d61 1
a61 1
    "$Id: L2Parallel.f90,v 2.65 2004/08/03 23:14:56 pwagner Exp $"
d635 1
d799 4
d1338 3
@


2.65
log
@Unseemly switch to allow running first last, or first and last chunks only
@
text
@d31 1
d61 1
a61 1
    "$Id: L2Parallel.f90,v 2.64 2004/06/10 00:58:45 vsnyder Exp $"
d381 4
d1333 3
@


2.64
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.63 2004/05/19 19:16:11 vsnyder Exp $"
d369 12
d1328 3
@


2.63
log
@Move MLSChunk_t to Chunks_m
@
text
@d16 1
d18 1
a18 14
  use PVM, only: PVMDATADEFAULT, PVMFINITSEND, PVMF90PACK, PVMFKILL, PVMFMYTID, &
    & PVMF90UNPACK, PVMERRORMESSAGE, PVMTASKHOST, PVMFSPAWN, &
    & MYPVMSPAWN, PVMFCATCHOUT, PVMFSEND, PVMFNOTIFY, PVMTASKEXIT, &
    & GETMACHINENAMEFROMTID, PVMFFREEBUF
  use PVMIDL, only: PVMIDLPACK, PVMIDLUNPACK
  use QuantityPVM, only: PVMSENDQUANTITY, PVMRECEIVEQUANTITY
  use MLSCommon, only: R8, FINDFIRST
  use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VECTORTEMPLATE_T, &
    & CONSTRUCTVECTORTEMPLATE, &
    & CREATEVECTOR, DESTROYVECTORINFO, DESTROYVECTORTEMPLATEINFO, &
    & INFLATEVECTORTEMPLATEDATABASE, INFLATEVECTORDATABASE
  use Machine, only: SHELL_COMMAND
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_ALLOCATE, &
    & MLSMSG_Deallocate, MLSMSG_WARNING
a19 1
  use L2AUXData, only: L2AUXDATA_T
d26 14
d43 1
a43 2
  use Toggles, only: Gen, Switches, Toggle
  use Output_m, only: Output
d46 5
a50 5
  use String_table, only: Display_String
  use Init_Tables_Module, only: S_L2GP, S_L2AUX
  use MoreTree, only: Get_Spec_ID
  use MorePVM, only: PVMUNPACKSTRINGINDEX, PVMPACKSTRINGINDEX
  use VectorsModule, only: CHECKINTEGRITY
d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.62 2004/04/16 00:47:54 livesey Exp $"
d469 1
a469 1
        chunk = FindFirst ( chunkTids == slaveTid )
d521 1
a521 1
          fileIndex = FindFirst ( directWriteFilenames(1:noDirectWriteFiles) == &
d569 1
a569 1
          requestIndex = FindFirst ( directWriteRequests%ticket == returnedTicket )
d699 1
a699 1
          deadChunk = FindFirst ( chunkTids == deadTid )
d1241 1
a1241 1
      thisResult => storedResults ( FindFirst ( storedResults%key == key ) )
d1316 3
@


2.62
log
@Now kills slaves on finishing (probably only happens when told to quit).
@
text
@d14 1
a15 1
  use Dumper, only: DUMP
d23 1
a23 1
  use MLSCommon, only: R8, MLSCHUNK_T, FINDFIRST
d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.61 2004/01/22 00:56:35 pwagner Exp $"
d1316 3
@


2.61
log
@Fixed many bugs in auto-distribution of DirectWrites
@
text
@d17 1
a17 1
  use PVM, only: PVMDATADEFAULT, PVMFINITSEND, PVMF90PACK, PVMFMYTID, &
d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.60 2004/01/02 23:36:00 pwagner Exp $"
d915 9
d1316 3
@


2.60
log
@DirectWrites may choose files automatically from db
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.59 2003/11/15 00:34:38 pwagner Exp $"
d555 5
a559 1
            call output ( nextTicket - 1, advance='yes' )
d845 5
a849 1
          call output ( request%ticket, advance='yes' )
d861 2
a862 1
        call PVMF90Pack ( (/ request%node, request%ticket, createFile, request%fileIndex /),&
d867 3
d1307 3
@


2.59
log
@Now stops after exactly maxNumFailures
@
text
@d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.58 2003/11/14 23:37:13 pwagner Exp $"
d853 2
a854 1
        call PVMF90Pack ( (/ request%node, request%ticket, createFile /), info )
d1295 3
@


2.58
log
@Lets user change masterLoop delay via commandline option
@
text
@d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.57 2003/09/24 23:41:55 pwagner Exp $"
d750 1
a750 1
            if ( chunkFailures(deadChunk) > &
d765 1
a765 1
              if ( jobsMachineKilled(deadMachine) > &
d1294 3
@


2.57
log
@Moved some USE statements around to workaround IFC bugs
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.56 2003/08/01 20:28:05 pwagner Exp $"
d230 1
a230 1
    integer, parameter :: DELAY = 200000  ! For Usleep, no. microsecs
d898 2
a899 1
      if ( .not. skipDelay ) call usleep ( delay )
d1294 3
@


2.56
log
@Spawns slave tasks with parallel%pgeName as command
@
text
@a49 3
  use VectorHDF5, only: WRITEVECTORASHDF5, READVECTORFROMHDF5
  use HDF5, only: H5FCREATE_F, H5FCLOSE_F, H5FOPEN_F, H5F_ACC_RDONLY_F, H5F_ACC_TRUNC_F

d60 1
a60 1
    "$Id: L2Parallel.f90,v 2.55 2003/07/11 21:50:02 livesey Exp $"
d222 2
d1093 1
d1293 3
@


2.55
log
@Bug fix in a diagnostic message
@
text
@d63 1
a63 1
    "$Id: L2Parallel.f90,v 2.54 2003/07/11 01:23:59 livesey Exp $"
d397 1
a397 1
          commandLine = 'mlsl2'
d405 10
d1293 3
@


2.54
log
@Minor bug fix and more informative output
@
text
@d63 1
a63 1
    "$Id: L2Parallel.f90,v 2.53 2003/07/08 17:30:43 livesey Exp $"
d531 1
a531 1
          request%machine = machine
d1283 3
@


2.53
log
@Bug fix in ticket issuing
@
text
@d63 1
a63 1
    "$Id: L2Parallel.f90,v 2.52 2003/07/07 17:32:00 livesey Exp $"
d719 17
a735 3
            if ( requestIndex /= 0 ) directWriteFileBusy ( &
              & directWriteRequests(requestIndex)%fileIndex ) = .false.
            ! Now forget all the requests we had pending
d916 21
a936 17
    do resInd = 1, size ( storedResults )
      hdfNameIndex = enter_terminal ( trim(storedResults(resInd)%hdfName), t_string )
      if ( index(switches,'mas') /= 0 ) then
        call output ( 'Joining ' // trim ( storedResults(resInd)%hdfName ), &
          & advance='yes' )
      endif
      
      do chunk = 1, noChunks
        if (.not. chunksAbandoned(chunk) ) then
          ! Setup for this quantity
          if ( parallel%stageInMemory ) then
            valInd = storedResults(resInd)%valInds(chunk)
            qty => joinedVectors(valInd)%quantities(1)

            if ( storedResults(resInd)%gotPrecision ) then
              precInd = storedResults(resInd)%precInds(chunk)
              precQty => joinedVectors(precInd)%quantities(1)
d938 2
a939 5
              nullify ( precQty )
            endif
          else
            write ( thisName, '(i0)' ) storedResults(resInd)%valInds(chunk)
            call ReadVectorFromHDF5 ( stageFileID, trim(thisName), &
d986 1
d1283 3
@


2.52
log
@New approach to directWrite
@
text
@d63 1
a63 1
    "$Id: L2Parallel.f90,v 2.51 2003/07/02 00:54:10 livesey Exp $"
d233 1
a233 1
    integer, parameter :: DATABASEINFLATION=5
d723 1
a723 1
              directWriteRequests%status = dw_Completed
d768 2
d781 1
a781 1
            & directWriteRequests%value = nextTicket + 1
d1267 3
@


2.51
log
@Various tidy ups and bug fixes
@
text
@a35 1
    & SIG_DIRECTWRITEABANDONED, SIG_DIRECTWRITEWAIT, &
d37 2
a38 1
    & MACHINEFIXEDTAG
d49 1
a49 1
  use MorePVM, only: PVMUNPACKSTRINGINDEX
d63 1
a63 1
    "$Id: L2Parallel.f90,v 2.50 2003/07/01 16:30:52 livesey Exp $"
d233 1
d240 1
d251 1
a251 1
    logical :: CREATEFILE               ! Flag for direct writes
d256 1
a259 1
    integer :: NEXTTICKET               ! For direct write handling
d263 1
d265 1
d267 1
d271 3
d275 1
a275 1
    integer :: REQUESTEDFILE            ! String index from slave
d278 1
a279 1
    integer :: STAGEFILEID              ! From HDF5
d286 2
a287 3
    integer, dimension(size(chunks)) :: DIRECTWRITESTATUS
    integer, dimension(size(chunks)) :: DIRECTWRITETICKET
    integer, dimension(maxDirectWriteFiles) :: DIRECTWRITEFILES
d297 1
d314 2
d328 4
a331 2
      & machineNames, machineFree, storedResults, machineOK, jobsMachineKilled )
    directWriteFiles = 0
d333 1
a333 1
    directWriteStatus = 0
a334 1
    directWriteTicket = 0
d338 3
d366 1
d372 1
d447 3
d507 4
a510 1
            & "unpacking direct write request" )
d512 2
a513 1
          fileIndex = FindFirst ( directWriteFiles(1:noDirectWriteFiles) == requestedFile )
a515 1
            createFile = .true.
d519 2
a520 1
              & 'Too many direct write files, increase limit' )
d522 4
a525 5
            directWriteFiles ( fileIndex ) = requestedFile
          else
            ! On the other hand, if the first task that tried to write to it died
            ! we'll know about it, but we might want to recreate it anyway.
            createFile = noDirectWriteChunks ( fileIndex ) == 0
d527 10
a543 41
            call output ( chunk, advance='yes' )
            call display_string ( requestedFile, strip=.true., advance='yes' )
          end if
          ! Is anyone else using this file?
          if ( any ( directWriteStatus == requestedFile ) ) then
            ! If so, log a request for it by setting our status to 
            ! -requestedFile, and have this chunk 'take a ticket'
            if ( index ( switches, 'mas' ) /= 0 ) then
              call output ( 'Request is pending as ticket ')
              call output ( nextTicket, advance='yes' )
            end if
            directWriteStatus(chunk) = -requestedFile
            directWriteTicket(chunk) = nextTicket
            nextTicket = nextTicket + 1
            ! Send the slave a message that it will have to wait
            call TellSlaveToWait ( slaveTid )
            ! At this point, create file, true or otherwise, becomes irrelevant.
          else
            ! Otherwise, go ahead
            if ( index ( switches, 'mas' ) /= 0 ) then
              call output ( 'Request was immediately granted' )
              if ( createFile ) then
                call output ( ' (new file)', advance='yes' )
              else
                call output ( ' (old file)', advance='yes' )
              end if
            end if
            call GrantDirectWrite ( slaveTid, createFile )
            directWriteStatus(chunk) = requestedFile
            directWriteTicket(chunk) = 0
          end if

        case ( sig_DirectWriteAbandoned )
          ! This chunk doesn't want to wait for the ticket, perhaps will 
          ! try for another file
          if ( index ( switches, 'mas' ) /= 0 ) then
            call output ( 'Direct write request abandoned by ' )
            if ( .not. usingSubmit ) &
              & call output ( trim(machineNames(machine)) // ' ' )
            call output ( trim(GetNiceTidString(slaveTid)) )
            call output ( ' chunk ' )
d546 2
a547 3
            call output ( directWriteTicket(chunk), advance='yes' )
            call display_string ( -directWriteStatus(chunk), strip=.true., &
              & advance='yes' )
a548 2
          directWriteStatus ( chunk ) = 0
          directWriteTicket ( chunk ) = 0
d551 4
d556 8
a563 6
          completedFile = directWriteStatus(chunk)
          fileIndex = FindFirst ( directWriteFiles(1:noDirectWriteFiles) == requestedFile )
          noDirectWriteChunks ( fileIndex ) = &
            & noDirectWriteChunks ( fileIndex ) + 1
          directWriteStatus(chunk) = 0
          directWriteTicket(chunk) = 0
d570 5
a574 2
            call output ( chunk, advance='yes')
            call display_string ( completedFile, strip=.true., advance='yes' )
a575 2
          ! OK, perhaps someone else's turn to write to this file
          call NextSlaveToWrite ( completedFile )
d653 3
d677 3
a707 2
            directWriteStatus(deadChunk) = 0 
            directWriteTicket(deadChunk) = 0
d714 11
a724 14
            ! If the chunk posesses any direct writes, free them up
            ! and tell any other chunks wanting to write that they can do so.
            if ( directWriteStatus(deadChunk) > 0 ) then
              ! If this file has not had the first chunk written sucessfully (i.e.
              ! it was deadChunk's task to do so).  Tell the next person who wants
              ! to write it to create it again.
              deadFile = directWriteStatus ( deadChunk )
              fileIndex = FindFirst ( directWriteFiles(1:noDirectWriteFiles) == deadFile )
              createFile = noDirectWriteChunks ( fileIndex ) == 0
              ! OK perhaps someone else's turn for this file, sort that out.
              call NextSlaveToWrite ( deadFile )
            end if
            directWriteStatus ( deadChunk ) = 0
            directWriteTicket ( deadChunk ) = 0
d755 2
d768 76
d873 1
a873 1
      call usleep ( delay )
a1007 70
    subroutine GrantDirectWrite ( tid, createFile )
      ! This routine sends a direct write grant message to a slave
      integer, intent(in) :: TID        ! Slave tid
      logical, intent(in) :: CREATEFILE ! Set if new file
      ! Local variables
      integer :: INFO                   ! From PVM
      integer :: BUFFERID               ! From PVM
      integer :: CREATE                 ! Integer version of createFile
      ! Executable code
      create = 0
      if ( createFile ) create = 1
      call PVMFInitSend ( PvmDataDefault, bufferID ) 
      call PVMF90Pack ( (/ SIG_DirectWriteGranted, create /), info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing direct write permission' )
      call PVMFSend ( tid, InfoTag, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'sending direct write permission' )
    end subroutine GrantDirectWrite

    subroutine NextSlaveToWrite ( file )
      ! This routine works out who is the next slave to do a direct
      ! write and lets them know
      ! Dummy arguments
      integer, intent(in) :: FILE
      ! Local variables
      integer, dimension(size(chunks)) :: RELEVANTTICKETS
      integer :: LOCATION(1)            ! Result of minloc
      integer :: CHUNK                  ! Chunk index
      ! Exectuable code
      relevantTickets = directWriteTicket
      where ( directWriteStatus /= -file .or. directWriteTicket == 0 )
        ! Mark the irrelevant ones out as being very new (i.e. never chosen)
        relevantTickets = nextTicket + 1
      end where
      if ( any ( relevantTickets /= nextTicket + 1 ) ) then
        location = minloc ( relevantTickets )
        chunk = location ( 1 )
        if ( index ( switches, 'mas' ) /= 0 ) then
          call output ( 'Permission now granted to ' // &
            & trim(GetNiceTidString(chunkTids(chunk))) // &
            & ' chunk ' )
          call output ( chunk )
          call output ( ' ticket ' )
          call output ( relevantTickets(location(1)), advance='yes' )
        end if
        ! We know createFile is false here because someone else just
        ! wrote to the file sucessfully!
        call GrantDirectWrite ( chunkTids(chunk), .false. )
        directWriteStatus ( chunk ) = file
        directWriteTicket ( chunk ) = 0
      end if
    end subroutine NextSlaveToWrite

    subroutine TellSlaveToWait ( tid )
      ! This routine sends a simple 'please wait' message to a slave
      ! who has asked for a direct write
      integer, intent(in) :: TID
      ! Local variables
      integer :: INFO                   ! From PVM
      integer :: BUFFERID               ! From PVM
      call PVMFInitSend ( PvmDataDefault, bufferID ) 
      call PVMF90Pack ( SIG_DirectWriteWait, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing direct write wait' )
      call PVMFSend ( tid, InfoTag, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'sending direct write wait' )
    end subroutine TellSlaveToWait

d1265 3
@


2.50
log
@Changed error to warning.
@
text
@d63 1
a63 1
    "$Id: L2Parallel.f90,v 2.49 2003/06/20 19:38:25 pwagner Exp $"
a507 1
            call output ( ' from ' )
d509 1
a509 1
              & call output ( trim(machineNames(machine)) // ' ' )
d556 1
a556 1
            call display_string ( directWriteStatus(requestedFile), strip=.true., &
d571 1
a571 2
            call output ( 'Direct write finished on by ' )
            call output ( ' by ' )
d573 1
a573 1
              & call output ( trim(machineNames(machine)) // ' ' )
d1261 3
@


2.49
log
@Allows direct writing of output products
@
text
@d63 1
a63 1
    "$Id: L2Parallel.f90,v 2.48 2003/06/05 23:53:34 livesey Exp $"
d446 3
a448 2
          call output ( 'Tid: ' // GetNiceTidString ( slaveTid ) )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d450 1
d1263 3
@


2.48
log
@Made the diagnostic output less verbose.
@
text
@d36 1
d49 1
d63 1
a63 1
    "$Id: L2Parallel.f90,v 2.47 2003/05/22 02:23:59 livesey Exp $"
d112 1
a112 1
        &    chunks(chunk)%accumulatedMAFs /), info )
d114 28
a141 1
        & call PVMErrorMessage ( info, 'packing one chunk' )
d165 1
d193 24
a216 2
      chunks(chunk) = MLSChunk_T ( &
        & values(1), values(2), values(3), values(4), values(5) )
d484 1
a484 1
          call PVMF90Unpack ( requestedFile, info )
d505 1
a505 2
            call output ( 'Direct write request for file ' )
            call output ( requestedFile )
d511 2
a512 1
            call output ( chunk, advance='yes')
d519 2
a520 2
              call output ( 'Request pending', &
                & advance='yes' )
d525 2
d531 1
a531 1
              call output ( 'Request was granted' )
d543 18
d570 1
a570 2
            call output ( 'Direct write finished on file ' )
            call output ( completedFile )
d577 1
d973 1
a973 1
          call output ( 'Permission granted to ' // &
d976 3
a978 1
          call output ( chunk, advance='yes' )
d988 16
a1077 2
    integer, save      :: JOINEDQTCOUNTER = CounterStart ! To place in qt%id
    integer, save      :: JOINEDVTCOUNTER = CounterStart ! To place in vt%id
a1141 2
        qt%id = joinedQTCounter
        joinedQTCounter = joinedQTCounter + 1
a1146 2
        vt%id = joinedVTCounter
        joinedVTCounter = joinedVTCounter + 1
d1261 3
@


2.47
log
@More informative error message
@
text
@d61 1
a61 1
    "$Id: L2Parallel.f90,v 2.46 2003/05/13 04:48:06 livesey Exp $"
d756 5
a761 1
        
a788 7
          if ( index(switches,'mas') /= 0 ) then
            call output ( 'Joining ' )
            call display_string ( qty%template%name )
            call output ( ' Chunk ' )
            call output ( chunk, advance='yes' )
          endif

d1177 3
@


2.46
log
@Can now stage to temporary hdf5 file instead of in memory.
@
text
@d61 1
a61 1
    "$Id: L2Parallel.f90,v 2.45 2003/05/12 02:06:48 livesey Exp $"
d392 3
d1180 3
@


2.45
log
@Changed to use the inflation of vectors etc for efficiency.
@
text
@d20 1
a20 1
    & GETMACHINENAMEFROMTID
d39 2
a40 1
    & DESTROYQUANTITYTEMPLATECONTENTS, INFLATEQUANTITYTEMPLATEDATABASE
d48 4
d61 1
a61 1
    "$Id: L2Parallel.f90,v 2.44 2003/05/10 22:30:12 livesey Exp $"
d192 2
a193 1
    integer :: BUFFERID                 ! From PVM
d218 2
a219 1
    integer :: STATUS                   ! From deallocate
d240 2
a241 1
    
d252 3
a254 1
    
d289 7
d310 2
a311 2
      if ( (.not. all(chunksStarted .or. chunksAbandoned)) .and. &
        & ( any(machineFree .and. machineOK) .or. usingSubmit ) ) then
d370 1
a370 1
      end if
d375 29
a403 11
      receiveInfoLoop: do
        call PVMFNRecv( -1, InfoTag, bufferID )
        if ( bufferID == 0 ) exit receiveInfoLoop
        if ( bufferID < 0 ) then
          call PVMErrorMessage ( info, "checking for Info message" )
        else if ( bufferID > 0 ) then
          ! Who sent this?
          call PVMFBufInfo ( bufferID, bytes, msgTag, slaveTid, info )
          if ( info /= 0 ) &
            & call PVMErrorMessage ( info, "calling PVMFBufInfo" )
          call PVMF90Unpack ( signal, info )
d405 14
a418 1
            call PVMErrorMessage ( info, "unpacking signal" )
d421 22
a442 6
          ! Who did this come from
          chunk = FindFirst ( chunkTids == slaveTid )
          if ( chunk == 0 .and. &
            &  (.not. usingSubmit .or. signal /= sig_register) ) then
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "Got a message from an unknown slave")
d444 3
a446 3
            ! Unpack the first integer in the buffer
            if ( .not. usingSubmit .and. signal /= sig_register ) &
              & machine = chunkMachines(chunk)
d449 17
a465 46
          select case (signal) 
            
          case ( sig_register ) ! ----------------- Chunk registering ------
            call PVMF90Unpack ( chunk, info )
            if ( info /= 0 ) then
              call PVMErrorMessage ( info, "unpacking chunk number" )
            endif
            ! Note, we'll ignore the slave MAFNumber sent for fwmParallel stuff
            if ( usingSubmit ) then
              ! We only really care about this message if we're using submit
              chunkTids(chunk) = slaveTid
              call GetMachineNameFromTid ( slaveTid, thisName )
              call WelcomeSlave ( chunk, slaveTid )
              if ( index(switches,'mas') /= 0 ) then
                call output ( 'Welcomed task ' // &
                  & trim(GetNiceTidString(slaveTid)) // &
                  & ' running chunk ' )
                call output ( chunk, advance='yes' )
              end if
            endif
            
          case ( sig_tojoin ) ! --------------- Got a join request ---------
            call StoreSlaveQuantity( joinedQuantities, &
              & joinedVectorTemplates, joinedVectors, &
              & storedResults, chunk, noChunks, slaveTid, noQuantitiesAccumulated )

          case ( sig_RequestDirectWrite ) ! ------- Direct write permission --
            ! What file did they ask for?
            call PVMF90Unpack ( requestedFile, info )
            if ( info /= 0 )  call PVMErrorMessage ( info, &
              & "unpacking direct write request" )
            ! Is this a new file?
            fileIndex = FindFirst ( directWriteFiles(1:noDirectWriteFiles) == requestedFile )
            if ( fileIndex == 0 ) then
              ! Clearly, if we don't know about this file it's new
              createFile = .true.
              noDirectWriteFiles = noDirectWriteFiles + 1
              if ( noDirectWriteFiles > maxDirectWriteFiles ) &
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Too many direct write files, increase limit' )
              fileIndex = noDirectWriteFiles
              directWriteFiles ( fileIndex ) = requestedFile
            else
              ! On the other hand, if the first task that tried to write to it died
              ! we'll know about it, but we might want to recreate it anyway.
              createFile = noDirectWriteChunks ( fileIndex ) == 0
d467 6
a472 1

d474 5
a478 16
              call output ( 'Direct write request for file ' )
              call output ( requestedFile )
              call output ( ' from ' )
              if ( .not. usingSubmit ) &
                & call output ( trim(machineNames(machine)) // ' ' )
              call output ( trim(GetNiceTidString(slaveTid)) )
              call output ( ' chunk ' )
              call output ( chunk, advance='yes')
            end if
            ! Is anyone else using this file?
            if ( any ( directWriteStatus == requestedFile ) ) then
              ! If so, log a request for it by setting our status to 
              ! -requestedFile, and have this chunk 'take a ticket'
              if ( index ( switches, 'mas' ) /= 0 ) then
                call output ( 'Request pending', &
                  & advance='yes' )
a479 17
              directWriteStatus(chunk) = -requestedFile
              directWriteTicket(chunk) = nextTicket
              nextTicket = nextTicket + 1
              ! At this point, create file, true or otherwise, becomes irrelevant.
            else
              ! Otherwise, go ahead
              if ( index ( switches, 'mas' ) /= 0 ) then
                call output ( 'Request was granted' )
                if ( createFile ) then
                  call output ( ' (new file)', advance='yes' )
                else
                  call output ( ' (old file)', advance='yes' )
                end if
              end if
              call GrantDirectWrite ( slaveTid, createFile )
              directWriteStatus(chunk) = requestedFile
              directWriteTicket(chunk) = 0
d481 4
d486 41
a526 20
          case ( sig_DirectWriteFinished ) ! - Finished with direct write -
            ! Record that the chunk has finished direct write
            completedFile = directWriteStatus(chunk)
            fileIndex = FindFirst ( directWriteFiles(1:noDirectWriteFiles) == requestedFile )
            noDirectWriteChunks ( fileIndex ) = &
              & noDirectWriteChunks ( fileIndex ) + 1
            directWriteStatus(chunk) = 0
            directWriteTicket(chunk) = 0
            if ( index ( switches, 'mas' ) /= 0 ) then
              call output ( 'Direct write finished on file ' )
              call output ( completedFile )
              call output ( ' by ' )
              if ( .not. usingSubmit ) &
                & call output ( trim(machineNames(machine)) // ' ' )
              call output ( trim(GetNiceTidString(slaveTid)) )
              call output ( ' chunk ' )
              call output ( chunk, advance='yes')
            end if
            ! OK, perhaps someone else's turn to write to this file
            call NextSlaveToWrite ( completedFile )
d528 20
a547 24
          case ( sig_finished ) ! -------------- Got a finish message ----
            if ( index(switches,'mas') /= 0 ) then
              call output ( 'Got a finished message from ' )
              if ( .not. usingSubmit ) &
                & call output ( trim(machineNames(machine)) // ' ' )
              call output ( trim(GetNiceTidString(slaveTid)) // &
                & ' processing chunk ' )
              call output ( chunk, advance='yes')
            endif
            
            ! Send an acknowledgement
            call PVMFInitSend ( PVMDataDefault, bufferID )
            if ( bufferId < 0 ) &
              & call PVMErrorMessage ( bufferID, 'setting up finish ack.' )
            call PVMF90Pack ( SIG_AckFinish, info )
            if ( info /= 0 ) &
              & call PVMErrorMessage ( info, 'packing finish ack.' )
            call PVMFSend ( slaveTid, InfoTag, info )
            if ( info /= 0 ) &
              & call PVMErrorMessage ( info, 'sending finish ack.' )
            
            ! Now update our information
            chunksCompleted(chunk) = .true.
            chunkTids(chunk) = 0
d549 1
a549 6
              machineFree(machine) = .true.
              chunkMachines(chunk) = 0
            end if
            if ( index(switches,'mas') /= 0 ) then
              call output ( 'Master status:', advance='yes' )
              call output ( count(chunksCompleted) )
d551 4
a554 17
              call output ( noChunks )
              call output ( ' chunks completed, ')
              call output ( count(chunksStarted .and. .not. chunksCompleted) )
              call output ( ' underway, ' )
              call output ( count(chunksAbandoned) )
              call output ( ' abandoned, ' )
              call output ( count(.not. &
                & (chunksStarted .or. chunksCompleted .or. chunksAbandoned ) ) )
              call output ( ' left. ', advance='yes' )
              if ( .not. usingSubmit ) then
                call output ( count ( .not. machineFree ) )
                call output ( ' of ' )
                call output ( noMachines )
                call output ( ' machines busy, with ' )
                call output ( count ( .not. machineOK ) )
                call output ( ' being avoided.', advance='yes' )
              end if
d556 12
a567 7
            
          case default
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unkown signal from slave' )
          end select
        end if
      end do receiveInfoLoop
d569 1
d571 2
a572 2
      call PVMFNRecv ( -1, GiveUpTag, bufferID )
      if ( bufferID > 0 ) then
d581 2
a582 2
      call PVMFNRecv ( -1, MachineFixedTag, bufferID )
      if ( bufferID > 0 ) then 
d602 2
a603 2
      call PVMFNRecv ( -1, NotifyTAG, bufferID )
      if ( bufferID > 0 ) then
d634 1
a634 1
           if ( .not. usingSubmit ) then
d654 1
a654 1
            
d666 1
a666 1
            
d690 2
a691 1
      else if ( bufferID < 0 ) then
d740 11
d754 1
a754 1

d757 10
a766 6
          valInd = storedResults(resInd)%valInds(chunk)
          qty => joinedVectors(valInd)%quantities(1)
          
          if ( storedResults(resInd)%gotPrecision ) then
            precInd = storedResults(resInd)%precInds(chunk)
            precQty => joinedVectors(precInd)%quantities(1)
d768 15
a782 4
            nullify ( precQty )
          endif
          
          if ( index(switches,'mas') /= 0 .and. chunk==1 ) then
d784 3
a786 3
            call display_string ( qty%template%name, advance='yes' )
            call output ( 'Minor frame:' )
            call output ( qty%template%minorFrame, advance='yes' )
d788 1
a788 1
          
d799 1
a799 1
          
d802 17
a818 8
          call DestroyVectorInfo ( joinedVectors(valInd) )
          call DestroyVectorTemplateInfo ( joinedVectorTemplates(valInd) )
          call DestroyQuantityTemplateContents ( joinedQuantities(valInd) )

          if ( storedResults(resInd)%gotPrecision ) then
            call DestroyVectorInfo ( joinedVectors(precInd) )
            call DestroyVectorTemplateInfo ( joinedVectorTemplates(precInd) )
            call DestroyQuantityTemplateContents ( joinedQuantities(precInd) )
a819 1

d823 1
a823 1
    
d825 6
d921 1
a921 1
      
d968 1
a968 1
  ! -------------------------------------- StoreSlaveQuantity -------------------
d970 2
a971 1
    & joinedVectors, storedResults, chunk, noChunks, tid, noQuantitiesAccumulated )
d983 1
d995 2
a996 1
    character(len=132) :: HDFNAME                   ! HDF name for quantity
a998 2
    integer :: QTIND                                ! Index for quantity template
    integer :: VTIND                                ! Index for vector template
d1006 1
d1027 1
d1029 43
a1071 12
      ! Perhaps inflate our databases, some extra logic to avoig doing size on
      ! unassociated pointer
      needToInflate = noQuantitiesAccumulated == 1
      if ( .not. needToInflate ) &
        & needToInflate = noQuantitiesAccumulated > size ( joinedQuantities )
      if ( needToInflate ) then
        noQuantitiesAccumulated = &
          & InflateQuantityTemplateDatabase ( joinedQuantities, databaseInflation )
        noQuantitiesAccumulated = &
          & InflateVectorTemplateDatabase ( joinedVectorTemplates, databaseInflation )
        noQuantitiesAccumulated = &
          & InflateVectorDatabase ( joinedVectors, databaseInflation )
a1072 14
      call PVMReceiveQuantity ( qt, values, justUnpack=.true. )
        
      ! Now add its template to our template database
      qt%id = joinedQTCounter
      joinedQTCounter = joinedQTCounter + 1
      qtInd = noQuantitiesAccumulated
      joinedQuantities ( qtInd ) = qt
      
      ! Now make a vector template up for this
      call ConstructVectorTemplate ( 0, joinedQuantities, (/ qtInd /), vt )
      vt%id = joinedVTCounter
      joinedVTCounter = joinedVTCounter + 1
      vtInd = noQuantitiesAccumulated
      joinedVectorTemplates ( vtInd ) = vt
a1073 3
      ! Now make a vector up for this
      v = CreateVector ( 0, joinedVectorTemplates(vtInd), &
        & joinedQuantities, vectorNameText='joined' )
d1075 14
a1088 1
      joinedVectors ( noQuantitiesAccumulated ) = v
d1147 5
a1151 3
        call DestroyVectorInfo ( joinedVectors(valInd) )
        call DestroyVectorTemplateInfo ( joinedVectorTemplates(valInd) )
        call DestroyQuantityTemplateContents ( joinedQuantities(valInd) )
d1158 5
a1162 3
          call DestroyVectorInfo ( joinedVectors(precInd) )
          call DestroyVectorTemplateInfo ( joinedVectorTemplates(precInd) )
          call DestroyQuantityTemplateContents ( joinedQuantities(precInd) )
d1177 3
@


2.44
log
@Tidy up a message
@
text
@d25 3
a27 2
    & ADDVECTORTEMPLATETODATABASE, CONSTRUCTVECTORTEMPLATE, ADDVECTORTODATABASE, &
    & CREATEVECTOR, DESTROYVECTORINFO, DESTROYVECTORTEMPLATEINFO
d38 2
a39 2
  use QuantityTemplates, only: QUANTITYTEMPLATE_T, ADDQUANTITYTEMPLATETODATABASE, &
    & DESTROYQUANTITYTEMPLATECONTENTS
d56 1
a56 1
    "$Id: L2Parallel.f90,v 2.43 2003/02/20 20:32:56 livesey Exp $"
a165 1

d206 1
d263 1
d409 1
a409 1
              & storedResults, chunk, noChunks, slaveTid )
d908 1
a908 1
    & joinedVectors, storedResults, chunk, noChunks, tid )
d919 1
d921 2
d941 1
d960 1
a960 1
    
d963 14
d978 1
a978 1
      
d982 2
a983 1
      qtInd = AddQuantityTemplateToDatabase ( joinedQuantities, qt )
d989 2
a990 1
      vtInd = AddVectorTemplateToDatabase ( joinedVectorTemplates, vt )
d996 1
d999 1
a999 1
        vInd = AddVectorToDatabase ( joinedVectors, v )
d1001 1
a1001 1
        pvInd = AddVectorToDatabase ( joinedVectors, v )
a1005 1

d1081 3
@


2.43
log
@Added the 'take a ticket' approach to direct write conflicts.
@
text
@d55 1
a55 1
    "$Id: L2Parallel.f90,v 2.42 2003/01/17 21:54:12 livesey Exp $"
d599 1
d601 1
a601 1
                & call output ( ' on ' // trim(machineNames(deadMachine)) // ' ' )
d1059 3
@


2.42
log
@Added the machineFixed stuff.
@
text
@d55 1
a55 1
    "$Id: L2Parallel.f90,v 2.41 2002/11/08 21:24:00 livesey Exp $"
d199 1
a205 1
    integer :: PENDINGCHUNK             ! Chunk waiting for direct write permission
d219 1
d260 2
d444 1
a444 1
              ! -requestedFile
d450 2
d465 1
d475 1
d486 2
a487 14
            ! Is anyone else waiting for this file?
            pendingChunk = FindFirst ( directWriteStatus == -completedFile )
            if ( pendingChunk /= 0 ) then
              if ( index ( switches, 'mas' ) /= 0 ) then
                call output ( 'Permission granted to ' // &
                  & trim(GetNiceTidString(chunkTids(pendingChunk))) // &
                  & ' chunk ' )
                call output ( pendingChunk, advance='yes' )
              end if
              ! We know createFile is false here because someone else just
              ! wrote to the file sucessfully!
              call GrantDirectWrite ( chunkTids(pendingChunk), .false. )
              directWriteStatus ( pendingChunk ) = completedFile
            end if
d608 3
a610 2
            directWriteStatus(deadChunk) = 0
            if ( .not. usingSubmit ) then
d625 2
a626 12
              pendingChunk = FindFirst ( directWriteStatus == -deadFile )
              if ( pendingChunk /= 0 ) then
                ! Was the dead chunk the first to write the file?
                if ( index ( switches, 'mas' ) /= 0 ) then
                  call output ( 'Permission granted to ' // &
                    & trim(GetNiceTidString(chunkTids(pendingChunk))) // &
                    & ' chunk ' )
                  call output ( pendingChunk, advance='yes' )
                end if
                call GrantDirectWrite ( chunkTids(pendingChunk), createFile )
                directWriteStatus ( pendingChunk ) = deadFile
              end if
d629 1
d817 32
d1058 3
@


2.41
log
@Minor tidy ups associated with the non-submit mode of doing things.
Now manages dead macines in a more transparent way.
@
text
@d29 1
a29 1
    & MLSMSG_Deallocate
d35 2
a36 1
    & GETNICETIDSTRING, SLAVEARGUMENTS, MACHINENAMELEN, GETMACHINENAMES
d55 1
a55 1
    "$Id: L2Parallel.f90,v 2.40 2002/10/17 18:19:24 livesey Exp $"
d561 22
d1039 4
@


2.40
log
@Added the GiveUp signal capability.
@
text
@d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.39 2002/10/08 17:36:21 pwagner Exp $"
d341 4
a344 1
            machineOK(machine) = .false.
d553 7
a559 2
      if ( bufferID > 0 ) exit masterLoop

d674 3
d1016 3
@


2.39
log
@Added idents to survive zealous Lahey optimizer
@
text
@d32 1
a32 1
  use L2ParInfo, only: L2PARALLELINFO_T, PARALLEL, INFOTAG, CHUNKTAG, &
d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.38 2002/10/05 00:43:34 livesey Exp $"
d548 4
d1005 3
@


2.38
log
@Started work on the FwmParallel stuff
@
text
@d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.37 2002/08/20 04:31:39 livesey Exp $"
d58 1
d993 4
d1001 3
@


2.37
log
@Obscure limitation fixed.  Used to hang if chunk died while doing direct
write.
@
text
@d35 1
a35 1
    & GETNICETIDSTRING, SLAVEARGUMENTS
d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.36 2002/07/18 02:15:29 livesey Exp $"
a60 1
  integer, parameter :: MACHINENAMELEN = 64 ! Max length of name of machine
a162 122
  ! ---------------------------------------- GetMachineNames ------------
  subroutine GetMachineNames ( machineNames )
    ! This reads the parallel slave name file and returns
    ! an array of machine names
    character(len=MachineNameLen), dimension(:), pointer :: MACHINENAMES

    ! Local variables
    character(len=MachineNameLen) :: LINE ! A line from the file
    character(len=MachineNameLen) :: ORIGINAL ! A line from the file
    character(len=MachineNameLen) :: ARCH ! A line from the file
    logical :: EXIST                    ! Flag from inquire
    logical :: GOTFIRSTLAST             ! Got a range
    logical :: OPENED                   ! Flag from inquire

    integer :: DTID                     ! From PVMFConfig
    integer :: FIRST                    ! First machine in file to use
    integer :: FIRSTCOLONPOS            ! Position in string
    integer :: I                        ! Loop inductor
    integer :: INFO                     ! From PVMFConfig
    integer :: LAST                     ! Last machine in file to use
    integer :: LUN                      ! Logical unit number
    integer :: MACHINE                  ! Counter
    integer :: NARCH                    ! From PVMFConfig
    integer :: NOLINES                  ! Number of lines in file
    integer :: NOMACHINES               ! Array size
    integer :: SECONDCOLONPOS           ! Position in string
    integer :: SPEED                    ! From PVMFConfig
    integer :: STAT                     ! Status flag from read

    ! Executable code
    ! The slave filename may contain starting and ending line numbers

    original = parallel%slaveFilename

    if ( trim(original) == 'pvm' ) then
      ! If the user specifies 'pvm' then just get the names of the machines
      ! in the pvm system
      machine = 1
      hostLoop: do
        call PVMFConfig ( noMachines, narch, dtid, line, arch, speed, info )
        if ( info < 0 ) call PVMErrorMessage ( info, &
          & 'Calling PVMFConfig' )
        if ( machine == 1 ) then
          call Allocate_test ( machineNames, noMachines, 'machineNames', moduleName )
        end if
        machineNames(machine) = trim(line)
        machine = machine + 1
        if ( machine == noMachines + 1 ) exit hostLoop
      end do hostLoop
    else
      gotFirstLast = .false.
      firstColonPos = index ( parallel%slaveFilename, ':' )
      if ( firstColonPos /= 0 ) then
        gotFirstLast = .true.
        parallel%slaveFilename(firstColonPos:firstColonPos) = ' '
        secondColonPos = index ( parallel%slaveFilename,':' )
        if ( secondColonPos < firstColonPos ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Incorrect syntax for slave info:'//trim(original) )
        parallel%slaveFilename(secondColonPos:secondColonPos) = ' '
        read (parallel%slaveFilename(firstColonPos+1:),*,iostat=stat) first, last
        if ( stat /= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Incorrect syntax for slave info:'//trim(original) )
      else
        firstColonPos = len_trim(parallel%slaveFilename)+1
      end if

      ! Find a free logical unit number
      do lun = 20, 99
        inquire ( unit=lun, exist=exist, opened=opened )
        if ( exist .and. .not. opened ) exit
      end do
      if ( opened .or. .not. exist ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & "No logical unit numbers available" )
      open ( unit=lun, file=parallel%slaveFilename(1:firstColonPos-1),&
        & status='old', form='formatted', &
        & access='sequential', iostat=stat )
      if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to open slave file " // parallel%slaveFilename(1:firstColonPos-1) )

      ! Now read the file and count the lines
      noMachines = 0
      noLines = 0
      firstTimeRound: do
        read ( unit=lun, fmt=*, iostat=stat ) line
        if ( stat < 0 ) exit firstTimeRound
        noLines = noLines + 1
        line = adjustl ( line )
        if ( line(1:1) /= '#' ) noMachines = noMachines + 1
      end do firstTimeRound

      ! Now setup the result array
      if ( .not. gotFirstLast ) then
        first = 1
        last = noMachines
      else
        first = min( max ( first, 1 ), noMachines )
        last = max( 1, min ( last, noMachines ) )
      end if
      noMachines = last - first + 1

      allocate ( machineNames(noMachines), stat=stat )
      if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//' machineNames')

      ! Now rewind the file and read the names
      rewind ( lun )
      machine = 1
      do i = 1, noLines
        read ( unit=lun, fmt=* ) line
        line = adjustl ( line )
        if ( line(1:1) /= '#' ) then
          if ( (machine >= first) .and. (machine <= last) ) &
            & machineNames(machine-first+1) = line
          machine = machine + 1
        endif
      end do

      close ( unit=lun )
    end if
  end subroutine GetMachineNames
d259 6
a264 2
    call GetMachineNames ( machineNames )
    noMachines = size(machineNames)
d371 2
a372 1
            if ( signal /= sig_register ) machine = chunkMachines(chunk)
d382 1
a386 5
              machine = FindFirst ( trim(thisName) == machineNames )
              if ( machine == 0 ) &
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
                & "An unknown machine sent a registration message!" )
              chunkMachines(chunk) = machine
d392 1
a392 3
                call output ( chunk )
                call output ( ' on machine ' // &
                  & trim(machineNames(machine)), advance='yes' )
d426 5
a430 4
              call output ( ' from ' // &
                & trim(machineNames(machine)) // ' ' // &
                & trim(GetNiceTidString(slaveTid)) // &
                & ' chunk ' )
d467 5
a471 4
              call output ( ' by ' // &
                & trim(machineNames(machine)) // ' ' // &
                & trim(GetNiceTidString(slaveTid)) // &
                & ' chunk ' )
d491 4
a494 3
              call output ( 'Got a finished message from ' // &
                & trim(machineNames(machine)) // ' ' // &
                & trim(GetNiceTidString(slaveTid)) // &
a511 1
            if ( .not. usingSubmit ) machineFree(machine) = .true.
d513 4
a516 1
            chunkMachines(chunk) = 0
d561 4
a564 2
            deadMachine = chunkMachines(deadChunk)
            if ( .not. usingSubmit ) machineFree(deadMachine) = .true.
d568 3
a570 2
              call output ( ' on ' // trim(machineNames(deadMachine)) // &
                & ' ' // trim(GetNiceTidString(deadTid)) // &
d578 5
a582 3
            where ( machineNames(deadMachine) == machineNames )
              jobsMachineKilled = jobsMachineKilled + 1
            end where
d623 12
a634 10
            if ( jobsMachineKilled(deadMachine) > &
              & parallel%maxFailuresPerMachine .and. .not. usingSubmit) then
              if ( index(switches,'mas') /= 0 ) &
                & call output ('The machine ' // &
                & trim(machineNames(deadMachine)) // &
                & ' keeps killing things, marking it bad', &
                & advance='yes' )
              where ( machineNames(deadMachine) == machineNames )
                machineOK = .false.
              end where
d661 8
a668 6
      if ( .not. any(machineOK) .and. &
        &  all ( chunksStarted .eqv. chunksCompleted ) ) then
        if ( index(switches,'mas') /= 0 ) &
          & call output ( 'No machines left to do the remaining work', &
          & advance='yes' )
        exit masterLoop
d996 4
@


2.36
log
@Bug fix, uninitialised variable
@
text
@d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.35 2002/05/29 22:43:22 livesey Exp $"
d314 1
d317 1
d341 1
d377 1
d531 4
a534 2
            createFile = .not. any ( directWriteFiles == requestedFile )
            if ( createFile ) then
d539 6
a544 1
              directWriteFiles ( noDirectWriteFiles ) = requestedFile
d546 1
d565 1
d583 3
a598 1
              ! We know createFile is false here.
d605 2
d697 24
d1106 3
@


2.35
log
@Embarssing bug fix, finished=.true. was wrong side of if statement.
@
text
@d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.34 2002/05/29 21:55:11 livesey Exp $"
d375 1
d1065 3
@


2.34
log
@Bug fixes, diagnostic message emitted when not -Smas, and associated
checks around some deallocates.
@
text
@d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.33 2002/05/22 00:48:36 livesey Exp $"
a825 1
      finished = .true.
d828 1
d1064 4
@


2.33
log
@Added direct write stuff
@
text
@d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.32 2002/05/21 01:12:05 livesey Exp $"
d547 4
a550 2
              call output ( 'Request pending', &
                & advance='yes' )
d810 5
a814 3
    deallocate ( joinedQuantities, STAT=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'joinedQuantities' )
d816 5
a820 3
    deallocate ( joinedVectorTemplates, STAT=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'joinedVectorTemplates' )
d822 6
a827 4
    deallocate ( joinedVectors, STAT=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'joinedVectors' )
    finished = .true.
d1064 3
@


2.32
log
@Got rid of machine stuff not relevant in submit case
@
text
@d34 1
d54 1
a54 1
    "$Id: L2Parallel.f90,v 2.31 2002/05/08 16:19:29 livesey Exp $"
d296 1
d311 2
d322 1
d324 1
d327 1
d337 3
d373 2
d519 72
a590 1
            
d673 1
d786 1
d831 20
d893 1
d1056 3
@


2.31
log
@Bug fix.
@
text
@d53 1
a53 1
    "$Id: L2Parallel.f90,v 2.30 2002/04/24 20:20:53 livesey Exp $"
a390 1
        machine = FindFirst(machineFree .and. machineOK)
d406 1
a491 1
              machineFree(machine) = .false.
d530 1
a530 1
            machineFree(machine) = .true.
d546 9
a554 8
              
              call output ( count ( .not. machineFree ) )
              call output ( ' of ' )
              call output ( noMachines )
              call output ( ' machines busy, with ' )
              call output ( count ( .not. machineOK ) )
              call output ( ' being avoided.', advance='yes' )
            endif
d578 1
a578 1
            machineFree(deadMachine) = .true.
d690 2
d950 3
@


2.31.2.1
log
@*** empty log message ***
@
text
@a33 1
    & SIG_REQUESTDIRECTWRITE, SIG_DIRECTWRITEGRANTED, SIG_DIRECTWRITEFINISHED, &
d53 1
a53 1
    "$Id: L2Parallel.f90,v 2.33 2002/05/22 00:48:36 livesey Exp $"
a294 1
    integer, parameter :: MAXDIRECTWRITEFILES=200 ! For internal array sizing
a308 2
    integer :: COMPLETEDFILE            ! String index from slave
    logical :: CREATEFILE               ! Flag for direct writes
a317 1
    integer :: NODIRECTWRITEFILES       ! Need to keep track of filenames
a318 1
    integer :: PENDINGCHUNK             ! Chunk waiting for direct write permission
a320 1
    integer :: REQUESTEDFILE            ! String index from slave
a329 3
    integer, dimension(size(chunks)) :: DIRECTWRITESTATUS
    integer, dimension(maxDirectWriteFiles) :: DIRECTWRITEFILES

a362 2
    directWriteFiles = 0
    directWriteStatus = 0
d391 1
a406 1
          machine = FindFirst(machineFree .and. machineOK)
d492 1
d508 1
a508 72

          case ( sig_RequestDirectWrite ) ! ------- Direct write permission --
            ! What file did they ask for?
            call PVMF90Unpack ( requestedFile, info )
            if ( info /= 0 )  call PVMErrorMessage ( info, &
              & "unpacking direct write request" )
            ! Is this a new file?
            createFile = .not. any ( directWriteFiles == requestedFile )
            if ( createFile ) then
              noDirectWriteFiles = noDirectWriteFiles + 1
              if ( noDirectWriteFiles > maxDirectWriteFiles ) &
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Too many direct write files, increase limit' )
              directWriteFiles ( noDirectWriteFiles ) = requestedFile
            end if
            if ( index ( switches, 'mas' ) /= 0 ) then
              call output ( 'Direct write request for file ' )
              call output ( requestedFile )
              call output ( ' from ' // &
                & trim(machineNames(machine)) // ' ' // &
                & trim(GetNiceTidString(slaveTid)) // &
                & ' chunk ' )
              call output ( chunk, advance='yes')
            end if
            ! Is anyone else using this file?
            if ( any ( directWriteStatus == requestedFile ) ) then
              ! If so, log a request for it by setting our status to 
              ! -requestedFile
              call output ( 'Request pending', &
                & advance='yes' )
              directWriteStatus(chunk) = -requestedFile
            else
              ! Otherwise, go ahead
              if ( index ( switches, 'mas' ) /= 0 ) then
                call output ( 'Request was granted' )
                if ( createFile ) then
                  call output ( ' (new file)', advance='yes' )
                else
                  call output ( ' (old file)', advance='yes' )
                end if
              end if
              call GrantDirectWrite ( slaveTid, createFile )
              directWriteStatus(chunk) = requestedFile
            end if

          case ( sig_DirectWriteFinished ) ! - Finished with direct write -
            ! Record that the chunk has finished direct write
            completedFile = directWriteStatus(chunk)
            directWriteStatus(chunk) = 0
            if ( index ( switches, 'mas' ) /= 0 ) then
              call output ( 'Direct write finished on file ' )
              call output ( completedFile )
              call output ( ' by ' // &
                & trim(machineNames(machine)) // ' ' // &
                & trim(GetNiceTidString(slaveTid)) // &
                & ' chunk ' )
              call output ( chunk, advance='yes')
            end if
            ! Is anyone else waiting for this file?
            pendingChunk = FindFirst ( directWriteStatus == -completedFile )
            if ( pendingChunk /= 0 ) then
              ! We know createFile is false here.
              if ( index ( switches, 'mas' ) /= 0 ) then
                call output ( 'Permission granted to ' // &
                  & trim(GetNiceTidString(chunkTids(pendingChunk))) // &
                  & ' chunk ' )
                call output ( pendingChunk, advance='yes' )
              end if
              call GrantDirectWrite ( chunkTids(pendingChunk), .false. )
              directWriteStatus ( pendingChunk ) = completedFile
            end if

d531 1
a531 1
            if ( .not. usingSubmit ) machineFree(machine) = .true.
d547 8
a554 9
              if ( .not. usingSubmit ) then
                call output ( count ( .not. machineFree ) )
                call output ( ' of ' )
                call output ( noMachines )
                call output ( ' machines busy, with ' )
                call output ( count ( .not. machineOK ) )
                call output ( ' being avoided.', advance='yes' )
              end if
            end if
d578 1
a578 1
            if ( .not. usingSubmit ) machineFree(deadMachine) = .true.
a589 1
            directWriteStatus(deadChunk) = 0
a689 2
            call output ( 'Minor frame:' )
            call output ( qty%template%minorFrame, advance='yes' )
a699 1
            ! Ignore timing and direct writes
a743 20
    subroutine GrantDirectWrite ( tid, createFile )
      ! This routine sends a direct write grant message to a slave
      integer, intent(in) :: TID        ! Slave tid
      logical, intent(in) :: CREATEFILE ! Set if new file
      ! Local variables
      integer :: INFO                   ! From PVM
      integer :: BUFFERID               ! From PVM
      integer :: CREATE                 ! Integer version of createFile
      ! Executable code
      create = 0
      if ( createFile ) create = 1
      call PVMFInitSend ( PvmDataDefault, bufferID ) 
      call PVMF90Pack ( (/ SIG_DirectWriteGranted, create /), info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'packing direct write permission' )
      call PVMFSend ( tid, InfoTag, info )
      if ( info /= 0 ) &
        & call PVMErrorMessage ( info, 'sending direct write permission' )
    end subroutine GrantDirectWrite

a785 1
    if ( .not. associated ( database ) ) return
a947 9
! Revision 2.33  2002/05/22 00:48:36  livesey
! Added direct write stuff
!
! Revision 2.32  2002/05/21 01:12:05  livesey
! Got rid of machine stuff not relevant in submit case
!
! Revision 2.31  2002/05/08 16:19:29  livesey
! Bug fix.
!
@


2.30
log
@Submit now working, also if pvm specified as host filename, takes
hostname list from pvm configuration
@
text
@d53 1
a53 1
    "$Id: L2Parallel.f90,v 2.29 2002/04/24 16:53:38 livesey Exp $"
d473 1
a473 1
            machine = chunkMachines(chunk)
d948 4
@


2.29
log
@Reordered arrays, on the way to having submit working
@
text
@d19 2
a20 1
    & MYPVMSPAWN, PVMFCATCHOUT, PVMFSEND, PVMFNOTIFY, PVMTASKEXIT
d27 1
d34 1
a34 1
    & GETNICETIDSTRING
d53 1
a53 1
    "$Id: L2Parallel.f90,v 2.28 2002/04/08 20:49:17 pwagner Exp $"
d172 1
d177 1
a177 2
    integer :: FIRSTCOLONPOS          ! Position in string
    integer :: SECONDCOLONPOS         ! Position in string
d179 1
d181 1
d185 1
d188 2
d196 16
a211 14
    gotFirstLast = .false.
    firstColonPos = index ( parallel%slaveFilename, ':' )
    if ( firstColonPos /= 0 ) then
      gotFirstLast = .true.
      parallel%slaveFilename(firstColonPos:firstColonPos) = ' '
      secondColonPos = index ( parallel%slaveFilename,':' )
      if ( secondColonPos < firstColonPos ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Incorrect syntax for slave info:'//trim(original) )
      parallel%slaveFilename(secondColonPos:secondColonPos) = ' '
      read (parallel%slaveFilename(firstColonPos+1:),*,iostat=stat) first, last
      if ( stat /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Incorrect syntax for slave info:'//trim(original) )
d213 17
a229 2
      firstColonPos = len_trim(parallel%slaveFilename)+1
    end if
d231 33
a263 33
    ! Find a free logical unit number
    do lun = 20, 99
      inquire ( unit=lun, exist=exist, opened=opened )
      if ( exist .and. .not. opened ) exit
    end do
    if ( opened .or. .not. exist ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "No logical unit numbers available" )
    open ( unit=lun, file=parallel%slaveFilename(1:firstColonPos-1),&
      & status='old', form='formatted', &
      & access='sequential', iostat=stat )
    if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "Unable to open slave file " // parallel%slaveFilename(1:firstColonPos-1) )

    ! Now read the file and count the lines
    noMachines = 0
    noLines = 0
    firstTimeRound: do
      read ( unit=lun, fmt=*, iostat=stat ) line
      if ( stat < 0 ) exit firstTimeRound
      noLines = noLines + 1
      line = adjustl ( line )
      if ( line(1:1) /= '#' ) noMachines = noMachines + 1
    end do firstTimeRound

    ! Now setup the result array
    if ( .not. gotFirstLast ) then
      first = 1
      last = noMachines
    else
      first = min( max ( first, 1 ), noMachines )
      last = max( 1, min ( last, noMachines ) )
    end if
    noMachines = last - first + 1
d265 16
a280 16
    allocate ( machineNames(noMachines), stat=stat )
    if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//' machineNames')

    ! Now rewind the file and read the names
    rewind ( lun )
    machine = 1
    do i = 1, noLines
      read ( unit=lun, fmt=* ) line
      line = adjustl ( line )
      if ( line(1:1) /= '#' ) then
        if ( (machine >= first) .and. (machine <= last) ) &
          & machineNames(machine-first+1) = line
        machine = machine + 1
      endif
    end do
d282 2
a283 1
    close ( unit=lun )
d302 3
a304 1
    character(len=132) :: COMMANDLINE
d357 1
a357 1
    usingSubmit = trim(parallel%submit) == ''
d387 1
d389 1
a389 1
        & any(machineFree .and. machineOK) ) then
d392 8
a399 15
        commandLine = 'mlsl2'

        if ( index(switches,'slv') /= 0 ) then
          call PVMFCatchOut ( 1, info )
          if ( info /= 0 ) call PVMErrorMessage ( info, "calling catchout" )
        end if
        info = myPVMSpawn ( trim(commandLine), PvmTaskHost, &
          & trim(machineNames(machine)), &
          & 1, tidarr )

        ! Did this launch work
        if ( info == 1) then
          machineFree(machine) = .false.
          chunkMachines(nextChunk) = machine
          chunkTids(nextChunk) = tidArr(1)
d401 1
d403 8
a410 5
            call output ( 'Launched chunk ' )
            call output ( nextChunk )
            call output ( ' on slave ' // trim(machineNames(machine)) // &
              & ' ' // trim(GetNiceTidString(chunkTids(nextChunk))), &
              & advance='yes' )
d412 29
a440 15
          call SendChunkInfoToSlave ( chunks, nextChunk, &
            & chunkTids(nextChunk) )
          ! Now ask to be notified when this task exits
          call PVMFNotify ( PVMTaskExit, NotifyTag, 1, &
            & (/ chunkTids(nextChunk) /), info )
          if ( info /= 0 ) call PVMErrorMessage ( info, 'setting up notify' )
        else
          ! Couldn't start this job, mark this machine as unreliable
          if ( index(switches,'mas') /= 0 ) then
            call output ( 'Unable to start slave task on ' // &
              & trim(machineNames(machine)) // ' info=' )
            if ( info < 0 ) then
              call output ( info, advance='yes' )
            else
              call output ( tidArr(1), advance='yes' )
d442 1
a442 1
            call output ( 'Marking this machine as not usable', advance='yes')
a443 1
          machineOK(machine) = .false.
d447 1
a459 5
          chunk = FindFirst ( chunkTids == slaveTid )
          if ( chunk == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Got a message from an unknown slave")
          ! Unpack the first integer in the buffer
          machine = chunkMachines(chunk)
d464 12
d485 17
a501 1
              
d607 2
a608 1
            ! mark it as not OK
d610 1
a610 1
              & parallel%maxFailuresPerMachine ) then
d742 16
d760 1
d948 3
@


2.28
log
@Swath name optionally passed to JoinL2GPQuantities
@
text
@d31 1
a31 1
    & SIG_TOJOIN, SIG_FINISHED, SIG_ACKFINISH, NOTIFYTAG, &
d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.27 2002/03/14 00:15:43 livesey Exp $"
d275 1
d300 2
a301 2
    integer, dimension(:), pointer :: SLAVECHUNKS ! Chunks for machines
    integer, dimension(:), pointer :: SLAVETIDS ! Taks ids for machines
d330 2
d335 1
a335 2
      & machineNames, slaveTids, slaveChunks, &
      & machineFree, storedResults, machineOK, jobsMachineKilled )
a339 2
    call Allocate_test ( slaveTids, noMachines, 'slaveTids', ModuleName )
    call Allocate_test ( slaveChunks, noMachines, 'slaveChunks', ModuleName )
d352 2
d377 2
a378 2
          slaveChunks(machine) = nextChunk
          slaveTids(machine) = tidArr(1)
d384 1
a384 1
              & ' ' // trim(GetNiceTidString(slaveTids(machine))), &
d388 1
a388 1
            & slaveTids(machine) )
d391 1
a391 1
            & (/ slaveTids(machine) /), info )
d421 2
a422 2
          machine = FindFirst ( slaveTids == slaveTid )
          if ( machine == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d425 1
d429 69
a497 60
          else
            select case (signal) 

            case ( sig_tojoin ) ! --------------- Got a join request ---------
              call StoreSlaveQuantity( joinedQuantities, &
                & joinedVectorTemplates, joinedVectors, &
                & storedResults, slaveChunks(machine), noChunks, slaveTid )

            case ( sig_finished ) ! -------------- Got a finish message ----
              if ( index(switches,'mas') /= 0 ) then
                call output ( 'Got a finished message from ' // &
                  & trim(machineNames(machine)) // ' ' // &
                  & trim(GetNiceTidString(slaveTid)) // &
                  & ' processing chunk ' )
                call output ( slaveChunks(machine), advance='yes')
              endif

              ! Send an acknowledgement
              call PVMFInitSend ( PVMDataDefault, bufferID )
              if ( bufferId < 0 ) &
                & call PVMErrorMessage ( bufferID, 'setting up finish ack.' )
              call PVMF90Pack ( SIG_AckFinish, info )
              if ( info /= 0 ) &
                & call PVMErrorMessage ( info, 'packing finish ack.' )
              call PVMFSend ( slaveTid, InfoTag, info )
              if ( info /= 0 ) &
                & call PVMErrorMessage ( info, 'sending finish ack.' )

              ! Now update our information
              chunksCompleted(slaveChunks(machine)) = .true.
              machineFree(machine) = .true.
              slaveChunks(machine) = 0
              slaveTids(machine) = 0
              if ( index(switches,'mas') /= 0 ) then
                call output ( 'Master status:', advance='yes' )
                call output ( count(chunksCompleted) )
                call output ( ' of ' )
                call output ( noChunks )
                call output ( ' chunks completed, ')
                call output ( count(chunksStarted .and. .not. chunksCompleted) )
                call output ( ' underway, ' )
                call output ( count(chunksAbandoned) )
                call output ( ' abandoned, ' )
                call output ( count(.not. &
                  & (chunksStarted .or. chunksCompleted .or. chunksAbandoned ) ) )
                call output ( ' left. ', advance='yes' )
                
                call output ( count ( .not. machineFree ) )
                call output ( ' of ' )
                call output ( noMachines )
                call output ( ' machines busy, with ' )
                call output ( count ( .not. machineOK ) )
                call output ( ' being avoided.', advance='yes' )
              endif

            case default
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unkown signal from slave' )
            end select
          end if
d509 2
a510 2
        if ( any ( slaveTids == deadTid ) ) then
          deadMachine = FindFirst ( slaveTids == deadTid )
d514 2
a515 1
          if ( deadMachine /= 0 ) then
a516 1
            deadChunk = slaveChunks ( deadMachine )
d675 4
d868 3
@


2.27
log
@Minor bug fix
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.26 2002/01/10 01:07:43 livesey Exp $"
d620 2
a621 1
              & qty, precQty, l2gpDatabase, chunk)
d852 3
@


2.26
log
@Another bug fix, slave wasn't receiving chunks correctly.
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.25 2002/01/09 23:16:34 livesey Exp $"
d832 1
d834 1
d841 1
a843 2
      storedResults(res)%valInds(chunk) = 0
      storedResults(res)%precInds(chunk) = 0
d851 3
@


2.25
log
@Whoops, left the SendChunkInfoToSlave call in the wrong place!
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.24 2002/01/09 22:55:57 livesey Exp $"
d153 1
a153 1
      chunks(chunkNo) = MLSChunk_T ( &
d850 3
@


2.24
log
@Now sends slaves all the chunks as regular HGrids need them.
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.23 2001/11/14 18:03:45 livesey Exp $"
a383 2
            call SendChunkInfoToSlave ( chunks, nextChunk, &
              & slaveTids(machine) )
d385 2
d850 3
@


2.23
log
@Changed for new FindFirst behavior
@
text
@d15 1
d47 1
a47 1
  public :: GetChunkFromMaster
d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.22 2001/11/05 23:21:31 livesey Exp $"
d75 2
a76 2
  ! --------------------------------------------- SendChunkToSlave ----------
  subroutine SendChunkToSlave ( chunk, chunkNo, slaveTid )
d80 1
a80 1
    type (MLSChunk_T), intent(in) :: CHUNK ! The chunk
d87 1
d91 1
a91 7
    call PVMF90Pack ( &
      & (/ chunkNo, &
      &    chunk%firstMAFIndex, &
      &    chunk%lastMAFIndex, &
      &    chunk%noMAFsLowerOverlap, &
      &    chunk%noMAFsUpperOverlap, &
      &    chunk%accumulatedMAFs /), info )
d93 11
a103 1
      & call PVMErrorMessage ( info, 'packing chunk' )
d107 1
a107 1
  end subroutine SendChunkToSlave
d109 2
a110 2
  ! ----------------------------------------------- GetChunkFromMaster ------
  subroutine GetChunkFromMaster ( chunks )
d115 1
d122 1
d125 3
a127 1
    integer, dimension(noChunkTerms+1) :: VALUES ! Chunk as integer array
d136 3
a138 2
      & call PVMErrorMessage ( info, 'receiving chunk' )
    call PVMF90Unpack ( values, info )
d140 3
a142 1
      & call PVMErrorMessage ( info, 'unpacking chunk')
d144 1
a144 1
    allocate ( chunks ( values(1):values(1) ), STAT=status)
d147 1
a147 1
      & 'Failed to allocate one chunk' )
d149 9
a157 2
    chunks(lbound(chunks)) = MLSChunk_T ( &
      & values(2), values(3), values(4), values(5), values(6) )
d159 1
a159 1
  end subroutine GetChunkFromMaster
a276 1
    character(len=132) :: WORD
a285 1
    integer :: LUN                      ! File handle
d384 1
a384 1
            call SendChunkToSlave ( chunks(nextChunk), nextChunk, &
d850 3
@


2.22
log
@Can now specify subset of slaves using <filename>:a:b.
@
text
@d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.21 2001/10/30 01:45:21 livesey Exp $"
d402 1
a402 1
          if ( machine == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d832 3
@


2.21
log
@Some modifications/fixes to parallel join
@
text
@d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.20 2001/09/10 23:39:12 livesey Exp $"
d148 11
a159 1
    character(len=MachineNameLen) :: LINE ! A line from the file
d161 1
a162 2
    logical :: EXIST                    ! Flag from inquire
    logical :: OPENED                   ! Flag from inquire
d166 20
d194 2
a195 1
    open ( unit=lun, file=parallel%slaveFilename, status='old', form='formatted', &
d198 1
a198 1
      & "Unable to open slave file " // parallel%slaveFilename )
d202 1
d206 3
a208 1
      noMachines = noMachines + 1
d212 9
d227 9
a235 2
    do machine = 1, noMachines
      read ( unit=lun, fmt=* ) machineNames(machine)
d832 3
@


2.20
log
@Minor change, not sure what it did, sorry.
@
text
@d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.19 2001/09/09 02:52:43 livesey Exp $"
a66 1
    logical :: gotBP                    ! If set have tropopause, too.
a68 1
    integer, dimension(:), pointer :: BPInds=>NULL() ! Array vec. dtbs. inds (noChunks)
a209 1
    integer :: BPIND                    ! Array index
a252 1
    type (VectorValue_T), pointer :: BPQTY
a544 7
          if ( storedResults(resInd)%gotBP ) then
            BPInd = storedResults(resInd)%BPInds(chunk)
            BPQty => joinedVectors(BPInd)%quantities(1)
          else
            nullify ( BPQty )
          endif
          
d553 1
a553 1
              & qty, precQty, BPQty, l2gpDatabase, chunk)
a570 5
          if ( storedResults(resInd)%gotBP ) then
            call DestroyVectorInfo ( joinedVectors(BPInd) )
            call DestroyVectorTemplateInfo ( joinedVectorTemplates(BPInd) )
            call DestroyQuantityTemplateContents ( joinedQuantities(BPInd) )
          end if
a626 3
      if ( associated ( database(i)%bpInds ) ) &
        & call deallocate_test ( database(i)%bpInds,&
        & 'database(?)%bpInds', ModuleName)
d650 1
a650 1
    integer, parameter :: NINJOINPACKET   = 3 ! Num of ints in join packet
a657 1
    integer :: GOTBP                                ! Flag
a661 1
    integer :: BPIND                                ! Index for tropopause vector
a682 1
    gotBP = i2(3)
d685 24
a708 29
!    do i = 1, gotPrecision+1
    do i = 1, NINJOINPACKET
      if( i2(i) /= 0 ) then	
        call PVMReceiveQuantity ( qt, values, justUnpack=.true. )

        ! Now add its template to our template database
        qt%id = joinedQTCounter
        joinedQTCounter = joinedQTCounter + 1
        qtInd = AddQuantityTemplateToDatabase ( joinedQuantities, qt )
 
        ! Now make a vector template up for this
        call ConstructVectorTemplate ( 0, joinedQuantities, (/ qtInd /), vt )
        vt%id = joinedVTCounter
        joinedVTCounter = joinedVTCounter + 1
        vtInd = AddVectorTemplateToDatabase ( joinedVectorTemplates, vt )
 
        ! Now make a vector up for this
        v = CreateVector ( 0, joinedVectorTemplates(vtInd), &
          & joinedQuantities, vectorNameText='joined' )
        v%quantities(1)%values => values
        select case ( i )
        case ( 1 )
          vInd = AddVectorToDatabase ( joinedVectors, v )
        case ( 2 )
          pvInd = AddVectorToDatabase ( joinedVectors, v )
        case ( 3 )
          bpInd = AddVectorToDatabase ( joinedVectors, v )
        end select
      end if
a736 1
    if ( thisResult%gotBP ) thisResult%BPInds(chunk) = BPInd
a751 1
    integer :: BPIND                    ! Index for tropopause (if any)
a773 6
      if ( storedResults(res)%gotBP ) then
        bpInd = storedResults(res)%bpInds(chunk)
        call DestroyVectorInfo ( joinedVectors(bpInd) )
        call DestroyVectorTemplateInfo ( joinedVectorTemplates(bpInd) )
        call DestroyQuantityTemplateContents ( joinedQuantities(bpInd) )
      end if
a775 1
      storedResults(res)%bpInds(chunk) = 0
d783 3
@


2.19
log
@Now gets find first from a different place
@
text
@d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.18 2001/09/08 00:21:44 pwagner Exp $"
d790 5
a794 3
      call DestroyVectorInfo ( joinedVectors(valInd) )
      call DestroyVectorTemplateInfo ( joinedVectorTemplates(valInd) )
      call DestroyQuantityTemplateContents ( joinedQuantities(valInd) )
d797 5
a801 3
        call DestroyVectorInfo ( joinedVectors(precInd) )
        call DestroyVectorTemplateInfo ( joinedVectorTemplates(precInd) )
        call DestroyQuantityTemplateContents ( joinedQuantities(precInd) )
d819 3
@


2.18
log
@Revised to work for new column Abundance in lone swaths
@
text
@d21 1
a21 2
  use MLSCommon, only: R8, MLSCHUNK_T
  use MLSL2Common, only: FindFirst
d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.17 2001/09/05 20:34:56 pwagner Exp $"
d815 3
@


2.17
log
@Reverted to pre-columnAbundance state
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.16 2001/08/02 23:59:22 pwagner Exp $"
d68 1
d71 1
d213 1
d257 1
d550 7
d565 1
a565 1
              & qty, precQty, l2gpDatabase, chunk)
d582 6
d644 3
d668 3
a670 2
    integer, save :: JOINEDQTCOUNTER = CounterStart ! To place in qt%id
    integer, save :: JOINEDVTCOUNTER = CounterStart ! To place in vt%id
d673 20
a692 18
    integer, dimension(2) :: I2         ! Array to unpack
    integer :: INFO                     ! Flag from pvm
    character(len=132) :: HDFNAME       ! HDF name for quantity
    integer :: KEY                      ! Tree node
    integer :: GOTPRECISION             ! Flag
    integer :: QTIND                    ! Index for quantity template
    integer :: VTIND                    ! Index for vector template
    integer :: VIND                     ! Index for vector
    integer :: PVIND                    ! Index for precision vector
    integer :: I                        ! Loop inductor
    integer :: NOSTOREDRESULTS          ! Array size
    logical :: SEENTHISBEFORE           ! Flag
    real (r8), dimension(:,:), pointer :: VALUES ! Values for this vector quantity
    type (QuantityTemplate_T) :: qt     ! A quantity template
    type (VectorTemplate_T) :: vt       ! A vector template
    type (Vector_T) :: v                ! A vector
    type (StoredResult_T), pointer :: THISRESULT ! Pointer to a storedResult
    type (StoredResult_T) :: ONERESULT  ! A new single storedResult_T
d705 1
d707 29
a735 23
    ! Now get the quantity itself, possibly also the precision
    do i = 1, gotPrecision+1
      call PVMReceiveQuantity ( qt, values, justUnpack=.true. )

      ! Now add its template to our template database
      qt%id = joinedQTCounter
      joinedQTCounter = joinedQTCounter + 1
      qtInd = AddQuantityTemplateToDatabase ( joinedQuantities, qt )
      
      ! Now make a vector template up for this
      call ConstructVectorTemplate ( 0, joinedQuantities, (/ qtInd /), vt )
      vt%id = joinedVTCounter
      joinedVTCounter = joinedVTCounter + 1
      vtInd = AddVectorTemplateToDatabase ( joinedVectorTemplates, vt )
      
      ! Now make a vector up for this
      v = CreateVector ( 0, joinedVectorTemplates(vtInd), &
        & joinedQuantities, vectorNameText='joined' )
      v%quantities(1)%values => values
      if ( i == 1 ) then
        vInd = AddVectorToDatabase ( joinedVectors, v )
      else
        pvInd = AddVectorToDatabase ( joinedVectors, v )
d765 1
d781 1
d800 6
d808 1
d816 3
@


2.16
log
@Compiles, but incomplete teatment of column abundance(s)
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.15 2001/08/02 00:18:55 pwagner Exp $"
a67 1
    integer :: nColumns                 ! If > 0, have column abundances
d254 2
a255 11
     type (VectorValue_T), pointer :: QTY
     type (VectorValue_T), pointer :: PRECQTY

  integer, parameter :: MAXNCOLUMNS=30 ! Why would you need more tropopauses defs

   ! The following probably need to be components of StoredResults
   ! (but I don't understand how to do this properly)
    integer, dimension(MAXNCOLUMNS) :: COLMVECTORINDEX 
    integer, dimension(MAXNCOLUMNS) :: COLMQTYINDEX    
    integer, dimension(MAXNCOLUMNS) :: BPRSVECTORINDEX 
    integer, dimension(MAXNCOLUMNS) :: BPRSQTYINDEX    
a545 4
          if ( storedResults(resInd)%nColumns > 0 ) then
 ! Unknown yet how to deal with this
          endif
          
d554 1
a554 4
              & qty, precQty, joinedVectors, l2gpDatabase, &
              & colmvectorindex, colmqtyindex, &
              & bprsvectorindex, bprsqtyindex, &
              & storedResults(resInd)%nColumns, chunk)
d777 3
@


2.15
log
@Began adding column quantities; incomplete
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.14 2001/06/22 05:19:46 livesey Exp $"
d68 1
a68 1
    logical :: gotColumn                ! If set have column quantities
d255 11
a265 4
    type (VectorValue_T), pointer :: QTY
    type (VectorValue_T), pointer :: PRECQTY
    type (VectorValue_T), pointer :: ColumnQty
    type (VectorValue_T), pointer :: BoundaryPressures
d556 2
a557 2
          if ( storedResults(resInd)%gotColumn ) then
 ! Figure this out tomorrow
d568 4
a571 2
              & qty, precQty, BoundaryPressures, ColumnQty, &
              & l2gpDatabase, chunk )
d794 3
@


2.14
log
@Moved FindFirst into MLSL2Common
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.13 2001/06/19 22:58:07 pwagner Exp $"
d68 1
d257 2
d549 4
d561 2
a562 1
              & qty, precQty, l2gpDatabase, chunk )
d785 3
@


2.13
log
@Eliminated duplicate declaration of MLSCommon
@
text
@d22 1
d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.12 2001/06/15 19:43:11 livesey Exp $"
a192 18
  ! -------------------------------------------- FindFirst --------------
  integer function FindFirst ( condition )
    ! Find the first logical in the array that is true
    logical, dimension(:), intent(in) :: CONDITION

    ! Local variables
    integer :: I                        ! Loop counter

    ! Executable code
    FindFirst = -1
    do i = 1, size(condition)
      if ( condition(i) ) then
        FindFirst = i
        return
      end if
    end do
  end function FindFirst

d777 3
@


2.12
log
@Bug fix.
@
text
@a33 1
  use MLSCommon, only: MLSCHUNK_T
d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.11 2001/06/13 20:43:12 livesey Exp $"
d791 3
@


2.11
log
@Made it less sensitive to chunks that die at the last minute.
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.10 2001/05/30 23:54:07 livesey Exp $"
d746 1
a746 1
      oneResult%precInds = 0
@


2.10
log
@Vectors now sent as part of info packets
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.9 2001/05/26 00:20:57 livesey Exp $"
d451 6
a456 20
          machineFree(deadMachine) = .true.
          deadChunk = slaveChunks ( deadMachine )
          if ( index(switches,'mas') /= 0 ) then
            call output ( 'The run of chunk ' )
            call output ( deadChunk )
            call output ( ' on ' // trim(machineNames(deadMachine)) // &
              & ' ' // trim(GetNiceTidString(deadTid)) // &
              & ' died, try again.', advance='yes' )
          end if
          call CleanUpDeadChunksOutput ( deadChunk, joinedQuantities, &
            & joinedVectorTemplates, joinedVectors, storedResults )
          chunksStarted(deadChunk) = .false.
          chunkFailures(deadChunk) = chunkFailures(deadChunk) + 1
          where ( machineNames(deadMachine) == machineNames )
            jobsMachineKilled = jobsMachineKilled + 1
          end where

          ! Does this chunk keep failing, if so, give up.
          if ( chunkFailures(deadChunk) > &
            & parallel%maxFailuresPerChunk ) then
d458 1
a458 1
              call output ( 'Chunk ' )
d460 32
a491 1
              call output ( ' keeps dying.  Giving up on it.', &
d493 3
d497 4
a500 11
            chunksAbandoned(deadChunk) = .true.
          end if

          ! Does this machine have a habit of killing jobs.  If so
          ! mark it as not OK
          if ( jobsMachineKilled(deadMachine) > &
            & parallel%maxFailuresPerMachine ) then
            if ( index(switches,'mas') /= 0 ) &
              & call output ('The machine ' // &
              & trim(machineNames(deadMachine)) // &
              & ' keeps killing things, marking it bad', &
a501 3
            where ( machineNames(deadMachine) == machineNames )
              machineOK = .false.
            end where
@


2.9
log
@Lots of changes to diagnostic output
@
text
@d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.8 2001/05/25 05:03:43 livesey Exp $"
d503 5
a507 1
      if (all(chunksCompleted .or. chunksAbandoned)) exit masterLoop
d513 6
a518 1
        &  all ( chunksStarted .eqv. chunksCompleted ) ) exit masterLoop
d525 5
d671 1
a671 1
    logical :: CONDITION                ! Flag
d693 1
a693 1
      call PVMReceiveQuantity ( qt, values, tid )
d719 6
a724 3
    condition = .not. associated ( storedResults )
    if (.not. condition ) condition = .not. any (storedResults%key == key )
    if ( condition ) then
d734 3
a738 2
    else
      thisResult => storedResults ( FindFirst ( storedResults%key == key ) )
d776 2
@


2.8
log
@Cosmetic changes to -Smas output
@
text
@d30 2
a31 1
    & SIG_TOJOIN, SIG_FINISHED, SIG_ACKFINISH, NOTIFYTAG
d51 1
a51 1
    "$Id: L2Parallel.f90,v 2.7 2001/05/25 04:59:44 livesey Exp $"
a319 6
        if ( index(switches,'mas') /= 0 ) then
          call output ( 'Launching chunk ' )
          call output ( nextChunk )
          call output ( ' on slave '//trim(machineNames(machine)), &
            & advance='yes' )
        endif
d330 9
a338 2
          call SendChunkToSlave ( chunks(nextChunk), nextChunk, &
            & slaveTids(machine) )
a381 6
              if ( index(switches,'mas') /= 0 ) then
                call output ( 'Got a vector join from ' // &
                  & trim(machineNames(machine)) )
                call output ( ' processing chunk ' )
                call output ( slaveChunks(machine), advance='yes')
              endif
d389 3
a391 2
                  & trim(machineNames(machine)) )
                call output ( ' processing chunk ' )
d413 18
a430 3
                call dump ( chunksCompleted, name='Chunks completed')
                call dump ( machineFree, name='Machines free' )
                call dump ( machineOK, name='Machines ok' )
d457 2
a458 1
              & ' seems to have died.  Being requeued.', advance='yes' )
d460 2
d487 1
a487 1
              & 'keeps killing things, marking it bad', &
d498 4
d505 5
a509 8
      ! If we're just going to have to give up then exit too.


      ! If all the machines are dead, and there is still work to be done
      ! what can we do!
      if ( (.not. any(machineOK)) .and. (.not. all(chunksStarted) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'None of the slave machines are reliable!' )
d511 1
a511 1
      ! Now, rather than chew up cpu time on the master process, we'll wait a
d514 1
d516 3
a518 1
    end do masterLoop ! --------------------- End of master loop -----------------
d727 33
@


2.7
log
@Now keeps statistics accross all machines sharing the same name.
@
text
@d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.6 2001/05/25 01:03:47 livesey Exp $"
d456 6
a461 3
            if ( index(switches,'mas') /= 0 ) &
              & call output ('This chunk keeps dying.  Giving up on it.', &
              & advance='yes' )
@


2.6
log
@Working parallel version
@
text
@d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.5 2001/05/23 21:59:43 livesey Exp $"
d449 3
a451 1
          jobsMachineKilled(deadMachine) = jobsMachineKilled(deadMachine) + 1
d467 3
a469 1
              & call output ('This machine keeps killing things, marking it bad', &
d471 3
a473 1
            machineOK(deadMachine) = .false.
@


2.5
log
@Interim version, almost there
@
text
@d18 1
a18 1
    & MYPVMSPAWN, PVMFCATCHOUT
d24 1
a24 1
    & CREATEVECTOR
d30 3
a32 2
    & SIG_TOJOIN, SIG_FINISHED
  use QuantityTemplates, only: QUANTITYTEMPLATE_T, ADDQUANTITYTEMPLATETODATABASE
d38 1
d50 1
a50 1
    "$Id: L2Parallel.f90,v 2.4 2001/05/23 03:46:41 livesey Exp $"
d97 1
a97 2
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to pack chunk' )
d100 1
a100 2
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to send chunk' )
d126 1
a126 2
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to receive chunk' )
d129 1
a129 2
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to unpack chunk')
d226 1
d231 3
d239 1
a239 1
    integer :: NEXTCHUNK                ! Which chunk is next to be done
d242 1
d246 1
d248 1
d254 6
a259 1
    logical, dimension(size(chunks)) :: COMPLETED
d283 2
a284 1
      & machineNames, slaveTids, slaveChunks, machineFree, storedResults )
d292 2
d295 2
d299 6
a304 3
    completed = .false.
    nextChunk = 1
    masterLoop: do
d308 5
a312 3
      ! done, and any vacant machines to do them.
      if ( nextChunk <= noChunks .and. any(machineFree) ) then 
        machine = FindFirst(machineFree)
d328 28
a355 9
        slaveTids(machine) = tidArr(1)
        if ( info < 0 ) call PVMErrorMessage ( info, "launching slave" )
        if ( info == 0 ) call PVMErrorMessage ( slaveTids(machine), "launching slave" )
        call SendChunkToSlave ( chunks(nextChunk), nextChunk, &
          & slaveTids(machine) )
        machineFree(machine) = .false.
        slaveChunks(machine) = nextChunk
        nextChunk = nextChunk + 1
      endif
d359 1
a359 1
      receiveLoop: do
d361 1
a361 1
        if ( bufferID == 0 ) exit receiveLoop
d397 14
a410 1
              completed(slaveChunks(machine)) = .true.
d412 2
d416 1
a416 1
                call dump ( completed, name='Chunks completed')
d418 1
d427 46
a472 1
      end do receiveLoop
d475 10
a484 1
      if (all(completed)) exit masterLoop
d490 1
a490 1
    end do masterLoop
d492 3
d500 38
a537 16
        ! Setup for this quantity
        qty => joinedVectors(storedResults(resInd)%valInds(chunk))%quantities(1)
        if ( storedResults(resInd)%gotPrecision ) then
          precQty => joinedVectors(storedResults(resInd)%precInds(chunk))%quantities(1)
        else
          nullify ( precQty )
        endif

        select case ( get_spec_id ( storedResults(resInd)%key ) )
        case ( s_l2gp )
          call JoinL2GPQuantities ( storedResults(resInd)%key, hdfNameIndex, &
            & qty, precQty, l2gpDatabase, chunk )
        case ( s_l2aux )
          call JoinL2AuxQuantities ( storedResults(resInd)%key, hdfNameIndex, &
            & qty, l2auxDatabase, chunk, chunks )
        end select
d543 12
d556 4
@


2.4
log
@Minor changes
@
text
@d14 2
d19 1
a19 1
  use PVMIDL, only: PVMIDLPACK
d22 5
a26 2
  use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VECTORTEMPLATE_T
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_ALLOCATE
d29 3
a31 1
  use QuantityTemplates, only: QuantityTemplate_T
d33 6
a38 1

d43 2
a44 2
  public :: L2ParallelInfo_T, parallel, InitParallel, L2MasterTask
  public :: SlaveJoin, GetChunkFromMaster, CloseParallel
d48 1
a48 1
    "$Id: L2Parallel.f90,v 2.3 2001/05/23 03:28:57 livesey Exp $"
d54 3
a56 17
  ! This datatype defines configuration for the parallel code
  type L2ParallelInfo_T
    logical :: master = .false.         ! Set if this is a master task
    logical :: slave = .false.          ! Set if this is a slace task
    integer :: myTid                    ! My task ID in pvm
    integer :: masterTid                ! task ID in pvm
    character(len=132) :: slaveFilename ! Filename with list of slaves
  end type L2ParallelInfo_T

  ! Shared variables

  type (L2ParallelInfo_T), save :: parallel

  ! Private parameters

  integer, parameter :: CHUNKTAG   = 10
  integer, parameter :: INFOTAG    = ChunkTag + 1
d58 2
a59 5
  integer, parameter :: SIG_TOJOIN = 1
  integer, parameter :: SIG_FINISHED = SIG_toJoin + 1

  ! Parameters
  integer, parameter :: MACHINENAMELEN = 64 ! Name of machine
d63 1
d65 3
a67 2
    integer, dimension(:), pointer :: valInds ! Array vec. dtbs. inds (noChunks)
    integer, dimension(:), pointer :: precInds ! Array vec. dtbs. inds (noChunks)
a71 30
  ! ---------------------------------------------- InitParallel -------------
  subroutine InitParallel
    ! This routine initialises the parallel code
    ! Executable code
    if ( parallel%master .or. parallel%slave ) then
      call PVMFMyTid ( parallel%myTid )
    end if
  end subroutine InitParallel

  ! --------------------------------------------- CloseParallel -------------
  subroutine CloseParallel
    ! This routine closes down any parallel stuff
    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: INFO                     ! From PVM

    ! Exeuctable code
    if ( parallel%slave ) then
      call PVMFInitSend ( PvmDataDefault, bufferID )
      call PVMF90Pack ( (/ SIG_Finished /), info )
      if ( info /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to pack finished signal' )
      call PVMFSend ( parallel%masterTid, InfoTag, info )
      if ( info /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to send finish packet' )
    end if
  end subroutine CloseParallel

a142 33
  ! ------------------------------------------- SlaveJoin ---------------
  subroutine SlaveJoin ( quantity, precisionQuantity, hdfName, key )
    ! This simply sends a vector quantity (or two) down a pvm spigot.
    type (VectorValue_T), pointer :: QUANTITY    ! Quantity to join
    type (VectorValue_T), pointer :: PRECISIONQUANTITY ! Its precision
    character(len=*), intent(in) :: HDFNAME ! Swath / sd name
    integer, intent(in) :: KEY          ! Tree node

    ! Local variables
    integer :: BUFFERID                 ! From PVM
    integer :: GOTPRECISION             ! really boolean
    integer :: INFO                     ! Flag from PVM

    ! Executable code
    gotPrecision = 0
    if ( associated ( precisionQuantity) ) gotPrecision = 1

    call PVMFInitSend ( PvmDataDefault, bufferID )
    call PVMF90Pack ( (/ SIG_ToJoin, key, gotPrecision /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing kind" )
    call PVMIDLPack ( hdfName, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "packing hdfName" )
    call PVMFSend ( parallel%masterTid, InfoTag, info )
    if ( info /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to send join packet' )

    call PVMSendQuantity ( quantity, parallel%masterTid )
    if ( associated ( precisionQuantity ) ) &
      call PVMSendQuantity ( precisionQuantity, parallel%masterTid )
    
  end subroutine SlaveJoin

d231 2
d240 1
d259 4
d273 1
a273 1
      & machineNames, slaveTids, slaveChunks, machineFree )
d291 1
a291 1
      if ( nextChunk < noChunks .and. any(machineFree) ) then 
d295 10
a304 4
        print*,'Calling catchout'
        call PVMFCatchOut ( 1, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "calling catchout" )
        print*,'Launching '//trim(commandLine)//' on '//trim(machineNames(machine))
d339 19
a357 2
            case ( sig_tojoin )
            case ( sig_finished )
d360 6
d384 25
a408 1

d413 113
a525 1
end module L2Parallel
d527 17
d545 2
d548 1
d550 1
@


2.3
log
@Minor changes and bug fixes
@
text
@d36 1
a36 1
    "$Id: L2Parallel.f90,v 2.2 2001/05/23 01:43:31 livesey Exp $"
d286 1
a286 1
    integer, parameter :: DELAY=200000  ! For Usleep, no. microsecs
d373 28
a400 25
      call PVMFNRecv( -1, InfoTag, bufferID )
      if ( bufferID < 0 ) then
        call PVMErrorMessage ( info, "checking for Info message" )
      else if ( bufferID > 0 ) then
        ! Who sent this?
        call PVMFBufInfo ( bufferID, bytes, msgTag, slaveTid, info )
        if ( info /= 0 ) &
          & call PVMErrorMessage ( info, "calling PVMFBufInfo" )
        machine = FindFirst ( slaveTids == slaveTid )
        if ( machine == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Got a message from an unknown slave")
        ! Unpack the first integer in the buffer
        call PVMF90Unpack ( signal, info )
        if ( info /= 0 ) then
          call PVMErrorMessage ( info, "unpacking signal" )
        else
          select case (signal) 
          case ( sig_tojoin )
          case ( sig_finished )
            completed(slaveChunks(machine)) = .true.
            machineFree(machine) = .true.
          case default
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unkown signal from slave' )
          end select
d402 2
a403 2
      end if
      
@


2.2
log
@New version. Starting to be functional
@
text
@d36 1
a36 1
    "$Id: L2Parallel.f90,v 2.1 2001/05/02 23:22:30 livesey Exp $"
a383 1
        
d388 1
@


2.1
log
@First version.
@
text
@d13 1
d15 4
a18 1
    & PVMF90UNPACK
d20 7
a26 2
  use VectorsModule, only: VECTOR_T
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d31 2
a32 1
  public :: L2ParallelInfo_T, parallel, InitParallel, GetChunkFromMaster
d36 1
a36 1
    "$Id: VectorsModule.f90,v 2.36 2001/05/02 20:44:37 vsnyder Exp $"
d39 1
a39 1
    "$RCSfile: VectorsModule.f90,v $"
d48 1
d51 4
d57 5
a61 2
  integer, parameter :: ChunkTag = 10
  integer, parameter :: VectorTag = ChunkTag + 1
d63 2
a64 1
  ! Shared variables
d66 6
a71 1
  type (L2ParallelInfo_T), save :: parallel
d84 21
d175 240
@

