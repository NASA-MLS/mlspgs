head	2.191;
access;
symbols
	v5-02-NRT-19:2.191
	v6-00:2.191
	v5-02-NRT-18:2.191
	v5-02:2.190
	v5-01-NRT-17:2.191
	v5-01-NRT-16:2.191
	v5-01-NRT-15:2.191
	v5-01-NRT-14:2.190
	neuralnetworks-1-0:2.190.0.4
	cfm-single-freq-0-1:2.190.0.2
	v5-01:2.190
	v5-00:2.188
	v4-23-TA133:2.188.0.2
	mus-emls-1-70:2.185.0.2
	rel-1-0-englocks-work:2.183.0.2
	VUMLS1-00:2.178
	VPL1-00:2.175
	V4-22-NRT-08:2.174
	VAM1-00:2.170
	V4-21:2.161.0.2
	V4-13:2.161
	V4-12:2.161
	V4-11:2.161
	V4-10:2.161
	V3-43:2.141
	M4-00:2.150
	V3-41:2.141
	V3-40-PlusGM57:2.141.0.2
	V2-24-NRT-04:2.131
	V3-33:2.141
	V2-24:2.131
	V3-31:2.141
	V3-30-NRT-05:2.141
	cfm-01-00:2.141
	V3-30:2.141
	V3-20:2.141
	V3-10:2.139
	V2-23-NRT-02:2.131
	V2-23:2.131
	V2-22-NRT-01:2.131
	V2-22:2.131
	V2-21:2.130
	V2-20:2.130
	V2-11:2.128
	V2-10:2.128
	V2-00:2.127
	V1-51:2.116
	V1-50:2.116
	V1-45:2.115
	V1-44:2.115
	V1-43:2.111
	V1-32:2.108
	V1-31:2.100
	V1-30:2.93
	V1-13:2.69
	V1-12:2.69
	V1-11:2.69
	V1-10:2.68
	newfwm-feb03:2.69.0.2
	V1-04:2.57
	V1-03:2.57
	V1-02:2.57
	JointForwardModel:2.60.0.2
	V1-00:2.55
	newfwm-sep01:2.47.0.2
	V0-7:2.46
	V0-5-Level2:2.33
	V0-5-SIPS:2.20
	V0_1:1.11;
locks; strict;
comment	@# @;


2.191
date	2021.09.02.22.50.08;	author pwagner;	state Exp;
branches;
next	2.190;

2.190
date	2020.02.13.21.28.04;	author pwagner;	state Exp;
branches;
next	2.189;

2.189
date	2020.02.07.01.12.10;	author pwagner;	state Exp;
branches;
next	2.188;

2.188
date	2019.02.13.19.15.46;	author pwagner;	state Exp;
branches;
next	2.187;

2.187
date	2019.02.13.17.29.33;	author pwagner;	state Exp;
branches;
next	2.186;

2.186
date	2018.07.27.23.18.48;	author pwagner;	state Exp;
branches;
next	2.185;

2.185
date	2018.04.16.22.21.41;	author pwagner;	state Exp;
branches;
next	2.184;

2.184
date	2018.04.13.00.19.51;	author pwagner;	state Exp;
branches;
next	2.183;

2.183
date	2018.02.09.00.56.16;	author pwagner;	state Exp;
branches;
next	2.182;

2.182
date	2018.01.12.00.19.37;	author pwagner;	state Exp;
branches;
next	2.181;

2.181
date	2017.12.07.01.01.23;	author vsnyder;	state Exp;
branches;
next	2.180;

2.180
date	2017.08.03.21.41.04;	author pwagner;	state Exp;
branches;
next	2.179;

2.179
date	2017.07.27.17.03.53;	author pwagner;	state Exp;
branches;
next	2.178;

2.178
date	2016.11.08.17.34.15;	author pwagner;	state Exp;
branches;
next	2.177;

2.177
date	2016.11.01.17.44.40;	author pwagner;	state Exp;
branches;
next	2.176;

2.176
date	2016.09.07.22.47.12;	author pwagner;	state Exp;
branches;
next	2.175;

2.175
date	2016.07.28.01.43.51;	author vsnyder;	state Exp;
branches;
next	2.174;

2.174
date	2016.05.18.01.37.30;	author vsnyder;	state Exp;
branches;
next	2.173;

2.173
date	2016.04.01.00.27.15;	author pwagner;	state Exp;
branches;
next	2.172;

2.172
date	2016.02.29.19.49.49;	author pwagner;	state Exp;
branches;
next	2.171;

2.171
date	2015.10.06.00.26.37;	author pwagner;	state Exp;
branches;
next	2.170;

2.170
date	2015.09.17.23.24.30;	author pwagner;	state Exp;
branches;
next	2.169;

2.169
date	2015.09.10.17.49.19;	author pwagner;	state Exp;
branches;
next	2.168;

2.168
date	2015.08.25.21.56.34;	author pwagner;	state Exp;
branches;
next	2.167;

2.167
date	2015.07.15.17.09.05;	author pwagner;	state Exp;
branches;
next	2.166;

2.166
date	2015.07.14.23.31.16;	author pwagner;	state Exp;
branches;
next	2.165;

2.165
date	2015.05.05.16.47.25;	author pwagner;	state Exp;
branches;
next	2.164;

2.164
date	2015.04.07.02.53.50;	author vsnyder;	state Exp;
branches;
next	2.163;

2.163
date	2015.03.31.21.01.07;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2015.03.28.02.47.14;	author vsnyder;	state Exp;
branches;
next	2.161;

2.161
date	2014.04.07.18.03.28;	author pwagner;	state Exp;
branches;
next	2.160;

2.160
date	2014.03.31.23.43.49;	author pwagner;	state Exp;
branches;
next	2.159;

2.159
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.158;

2.158
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.157;

2.157
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.156;

2.156
date	2013.11.01.00.15.15;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2013.10.09.23.41.36;	author vsnyder;	state Exp;
branches;
next	2.154;

2.154
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.153;

2.153
date	2013.09.04.17.35.23;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2013.08.30.02.45.42;	author vsnyder;	state Exp;
branches;
next	2.151;

2.151
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2012.08.16.17.58.24;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2012.07.02.20.40.43;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2012.05.08.17.51.11;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2012.05.01.23.16.35;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2012.03.12.17.22.20;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2012.02.24.21.19.44;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2011.11.04.00.09.53;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2011.10.07.00.06.02;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2011.05.09.18.18.45;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2009.10.26.17.11.53;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2009.09.29.23.40.45;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2009.06.02.17.53.15;	author cvuu;	state Exp;
branches;
next	2.137;

2.137
date	2009.04.23.23.02.25;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2009.04.01.23.35.59;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2008.12.18.21.14.24;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2008.12.02.23.27.09;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2007.12.07.01.50.52;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2007.11.05.18.37.19;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2007.06.21.00.54.08;	author vsnyder;	state Exp;
branches;
next	2.130;

2.130
date	2006.10.11.22.58.00;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2006.09.21.18.55.04;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2006.06.21.22.06.56;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2006.04.11.23.34.27;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2006.03.04.00.20.13;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2006.02.10.21.17.33;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2005.11.11.21.47.08;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2005.11.04.18.54.04;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2005.10.28.23.17.37;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2005.10.18.23.11.36;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2005.06.22.18.57.01;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2005.06.16.18.43.01;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2005.06.14.20.43.19;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2005.03.24.21.31.55;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2004.12.14.22.51.35;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2004.07.22.20.49.58;	author cvuu;	state Exp;
branches;
next	2.114;

2.114
date	2004.06.10.00.58.45;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2004.05.19.20.16.29;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2004.05.19.19.16.10;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2004.04.27.23.56.17;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2004.04.24.00.21.33;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2004.04.17.07.00.54;	author livesey;	state Exp;
branches;
next	2.108;

2.108
date	2004.03.03.19.28.04;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2004.02.19.23.56.23;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2004.02.11.23.11.38;	author livesey;	state Exp;
branches;
next	2.105;

2.105
date	2004.02.11.17.21.51;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2004.02.10.19.28.36;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2004.02.05.23.40.35;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2004.01.23.01.09.48;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2004.01.22.00.56.35;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2004.01.02.23.36.00;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2003.12.05.00.41.14;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2003.12.03.17.50.54;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2003.11.14.23.38.45;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2003.11.07.00.46.51;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2003.10.20.18.21.45;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2003.10.10.00.00.24;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2003.09.12.21.45.52;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2003.09.04.22.40.04;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2003.09.03.23.05.49;	author livesey;	state Exp;
branches;
next	2.90;

2.90
date	2003.09.03.00.53.50;	author livesey;	state Exp;
branches;
next	2.89;

2.89
date	2003.08.28.23.51.58;	author livesey;	state Exp;
branches;
next	2.88;

2.88
date	2003.08.14.20.11.30;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2003.08.01.20.38.31;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2003.07.25.00.51.06;	author livesey;	state Exp;
branches;
next	2.85;

2.85
date	2003.07.23.18.30.35;	author cvuu;	state Exp;
branches;
next	2.84;

2.84
date	2003.07.15.23.39.01;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2003.07.11.01.24.20;	author livesey;	state Exp;
branches;
next	2.82;

2.82
date	2003.07.09.21.49.53;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2003.07.08.00.15.51;	author livesey;	state Exp;
branches;
next	2.80;

2.80
date	2003.07.07.23.52.13;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2003.07.07.20.29.43;	author livesey;	state Exp;
branches;
next	2.78;

2.78
date	2003.07.07.17.31.11;	author livesey;	state Exp;
branches;
next	2.77;

2.77
date	2003.07.02.00.55.27;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2003.06.26.23.13.52;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2003.06.24.23.54.07;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2003.06.24.23.30.00;	author livesey;	state Exp;
branches;
next	2.73;

2.73
date	2003.06.23.23.55.17;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2003.06.20.19.38.25;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2003.05.30.00.09.27;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2003.05.12.02.06.23;	author livesey;	state Exp;
branches;
next	2.69;

2.69
date	2003.02.08.00.31.31;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2003.01.30.01.03.24;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2003.01.17.23.11.26;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2002.12.19.15.53.47;	author livesey;	state Exp;
branches;
next	2.65;

2.65
date	2002.11.26.23.38.01;	author livesey;	state Exp;
branches;
next	2.64;

2.64
date	2002.10.29.21.54.21;	author livesey;	state Exp;
branches;
next	2.63;

2.63
date	2002.10.08.17.36.21;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2002.08.20.22.10.50;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2002.08.20.20.10.30;	author livesey;	state Exp;
branches;
next	2.60;

2.60
date	2002.05.28.17.09.57;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2002.05.22.00.48.52;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2002.05.16.22.36.46;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2002.04.08.20.49.17;	author pwagner;	state Exp;
branches
	2.57.2.1;
next	2.56;

2.56
date	2002.04.06.00.35.21;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2002.03.20.00.46.47;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2001.10.30.01.45.21;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2001.10.08.23.38.58;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2001.10.06.00.27.42;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2001.09.28.23.59.20;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2001.09.28.17.50.30;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2001.09.08.00.21.44;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2001.09.05.20.34.56;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2001.08.03.23.13.52;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2001.08.02.23.58.31;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2001.08.02.00.18.55;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2001.07.31.23.25.32;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2001.06.19.22.52.31;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2001.05.23.21.59.43;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2001.05.23.01.43.19;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2001.05.19.01.19.58;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2001.05.14.22.23.53;	author livesey;	state Exp;
branches;
next	2.37;

2.37
date	2001.05.12.00.18.17;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2001.05.10.16.31.24;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.08.23.25.32;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2001.05.08.21.51.02;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2001.05.03.20.32.19;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2001.05.02.22.22.43;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2001.04.28.01.30.14;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2001.04.27.21.52.39;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2001.04.26.20.02.09;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2001.04.26.15.59.30;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.26.00.07.16;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.25.21.54.22;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.04.25.21.51.46;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.04.25.20.33.28;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.24.20.20.27;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.24.20.04.54;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.10.23.44.44;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.03.15.23.26.56;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.03.15.21.18.57;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.03.06.22.40.41;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.03.05.20.46.41;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.03.05.01.19.45;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.03.05.01.01.12;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.03.01.18.38.27;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.02.27.17.38.21;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.02.27.00.50.31;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.02.16.00.50.17;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.02.09.19.30.16;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.02.09.18.01.46;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.02.09.00.38.22;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.01.03.18.15.13;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2000.11.16.02.19.01;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2000.11.13.23.02.21;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2000.10.05.16.37.19;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2000.09.11.19.34.35;	author ahanzel;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.29.23.51.16;	author lungu;	state Exp;
branches;
next	;

2.57.2.1
date	2002.05.22.23.14.16;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.191
log
@-Sprofiled prints MAF data in addition to profiles
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Join                     ! Join together chunk based data.
!=============================================================================

  use JoinUtils_1, only: Error, Announce_Error, DWSwath, DWHDF, DWQty
  use MLSL2Options, only: CheckPaths, L2Options, L2CFNode, &
    & SkipDirectWrites, SpecialDumpFile, MLSL2Message
  use MLSStringLists, only: GetHashElement, SwitchDetail
  use MLSStrings, only: LowerCase
  ! This module performs the 'join' task in the MLS level 2 software.

  implicit none
  private
  public :: MLSL2Join, JoinL2GPQuantities, JoinL2AuxQuantities

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Join.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! logical, parameter, private :: FORCEDIRWRITEREOPEN = .false. ! Usually FALSE
  real, parameter             :: timeReasonable = 500.

  ! Parameters for Announce_Error

  ! integer :: ERROR  ! Now got from JoinUtils
  logical, parameter :: CATENATESPLITS  = .true.
  logical, parameter :: countEmpty = .true. ! Except where overriden locally
  integer, parameter :: NO_ERROR_CODE   = 0

contains ! =====     Public Procedures     =============================

  ! --------------------------------------------------  MLSL2Join  -----

  ! This is the main routine for the Join block.  This one just goes
  ! through the tree and dispatches work to other routines.
  ! Broadly it does so in two sweeps:
  ! The first sweep focuses on the DirectWrite commands
  ! The second sweep picks up any other command
  ! Both sweeps must be sensitive to contol structures
  ! like Skip and Select

  subroutine MLSL2Join ( root, vectors, l2gpDatabase, l2auxDatabase, &
    & DirectDataBase, chunkNo, chunks, FWModelConfig, filedatabase, HGrids, &
    & Matrices, Hessians )
    ! Imports

   use Allocate_Deallocate, only: Test_Allocate
   use Chunks_M, only: MLSChunk_T
   use DirectWrite_M, only: DirectData_T
   use Dumpcommand_M, only: DumpCommand, ExecuteCommand, &
     & MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, Skip
   use ForwardModelConfig, only: ForwardModelConfig_T
   use HessianModule_1, only: Hessian_T
   use HGridsDatabase, only: HGrids_T
   use HighOutput, only: BeVerbose, LetsDebug, OutputNamedValue
   use Init_Tables_Module, only: F_Reset, &
     & S_L2gp, S_L2aux, S_Time, S_Directwrite, &
     & S_Endselect, S_Case, S_Diff, S_Dump, S_Execute, S_Label, S_Select, &
     & S_Skip
   use L2GPData, only: L2GPData_T
   use L2AuxData, only: L2AuxData_T
   use L2ParInfo, only: Parallel, WaitForDirectWritePermission
   use Lexer_Core, only: Print_Source
   use MatrixModule_1, only: Matrix_Database_T
   use MLSCommon, only: MLSFile_T
   use MLSL2Timings, only: Section_Times, &
     & Add_To_DirectWrite_Timing, Add_To_Section_Timing
   use MLSMessageModule, only: MLSMSG_Error
   use MoreTree, only: Get_Boolean, Get_Field_Id, Get_Label_And_Spec, &
     & Get_Spec_Id
   use Next_Tree_Node_M, only: Init_Next_Tree_Node, Next_Tree_Node, &
     & Next_Tree_Node_State
   use Output_M, only: Output, RevertOutput, SwitchOutput
   use Toggles, only: Gen, Toggle, Switches
   use Tree, only: Where_At => Where, Nsons, Subtree
   use Time_M, only: SayTime, Time_Now
   use Trace_M, only: Trace_Begin, Trace_End
   use VectorsModule, only: Vector_T

    ! Dummy arguments
    integer, intent(in) :: ROOT    ! Of the JOIN section in the AST
    type (Vector_T), dimension(:), pointer :: vectors
    type (L2GPData_T), dimension(:), pointer :: l2gpDatabase
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase
    type (DirectData_T), dimension(:), pointer :: DirectDatabase
    integer, intent(in) :: chunkNo
    type (MLSChunk_T), dimension(:), intent(in) :: chunks
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (HGrids_T), dimension(:), pointer  ::     HGrids
    type (matrix_database_T), dimension(:), pointer :: Matrices
    type (Hessian_T), dimension(:), pointer :: Hessians

    ! Local parameters
    ! External (C) function
    ! Local variables
    logical :: AUTODIRECTWRITE
    logical :: CREATEFILE               ! Flag
    logical :: DIDTHEWRITE
    integer :: DIRECTWRITENODEGRANTED   ! Which request was granted
    real :: DWT1                        ! Time we started
    real :: DWT2                        ! Time we finished
    real :: DWT22                       ! Time we finished, too
    integer :: field
    integer :: gson
    integer :: KEY                      ! Tree node
    integer :: Label                    ! Not actually used
    integer :: Me = -1                  ! String index for trace
    integer :: NODIRECTWRITES           ! Array size
    integer :: NODIRECTWRITESCOMPLETED  ! Counter
    integer :: NOEXTRAWRITES            ! Correction to NODIRECTWRITES
    character(len=16) :: outputTyp
    ! integer :: PASS                     ! Loop counter
    logical :: reset
    integer :: SON                      ! Tree node
    integer :: SPECID                   ! Type of l2cf line this is
    type(next_tree_node_state) :: State ! of tree traverser
    integer :: STATUS
    integer :: TICKET                   ! Direct write permission ticket
    ! integer :: THEFILE                  ! Direct write permission on file
    character(len=4096) :: THEFILE  ! Which file permission granted for
    logical :: TIMING                   ! Flag
    real :: T1                          ! Time we started
    real :: timeSpentWaiting
    logical :: namedFile                ! set true if DirectWrite named file
    logical :: DEEBUG
    logical :: verbose
    
    ! Executable code
    DEEBUG = LetsDebug ( 'direct', 0 )
    verbose = BeVerbose( 'direct', -1 )
    call trace_begin ( me, "MLSL2Join", root, cond=toggle(gen) )
    timing = section_times
    if ( timing ) call time_now ( t1 )
    if ( specialDumpFile /= ' ' ) &
      & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
    ! Will we (perhaps) be automatically assigning Direct writes to
    ! files declared in global settings section?
    autoDirectWrite = .false.
    if ( associated(DirectDataBase) ) then
      if ( size(DirectDataBase) > 0 ) then
        autoDirectWrite = any(DirectDataBase%autoType > 0)
      end if
    end if
    ! First we'll just do any DirectWrite commands
    ! These may require waiting for permission if we're a slave
    call AnyDirectWrites
    
    ! Next we'll perform any of the other commands
    ! like the Dump, Diff, or the outmoded l2gp and l2aux
    ! (which were the classic Join specs)
    call AnyOtherCommands
    
    if ( specialDumpFile /= ' ' ) &
      & call revertOutput
    ! Check for errors
    if ( error /= 0 ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, 'Error in Join section' )

    call trace_end ( "MLSL2Join", cond=toggle(gen) )
    if ( timing ) call sayTime ( 'Join', t1=t1, cumulative=.false. )

contains
  subroutine AnyDirectWrites
    ! This is going to be somewhat atypical, as the code may run in 'passes'
    ! If we are a slave run in parrallel, we make many passes
    ! In pass 1 we simply count the direct writes
    ! In pass 2 we log all our direct write requests.
    ! In the later passes (as many as there are direct writes) we do the
    ! direct writes we've been given permission for.
    integer :: DBINDEX
    integer :: J
    integer :: Pass
    ! othrwise one pass is sufficient.

    error = 0
    pass = 1
    noDirectWrites = 0
    noDirectWritesCompleted = 0
    ticket = 0                          ! Default value for serial case
    didthewrite = .true.
    passLoop: do
      ! For the later passes, we wait for permission to do one of the direct writes
      if ( pass > 2 ) then
        if ( skipDirectWrites ) exit passLoop
        call time_now ( dwt2 )
        call WaitForDirectWritePermission ( directWriteNodeGranted, ticket, &
          & theFile, createFile )
        call time_now ( dwt22 )
        timeSpentWaiting = dwt22-dwt2
        if ( timeSpentWaiting > timeReasonable ) then
          call output('Unreasonable time waiting for permission', advance='yes')
        end if
        if ( parallel%verbosity > 0 ) then
          call output ( "Got permission for ticket " )
          call output ( ticket )
          call output ( " node " )
          call output ( directWriteNodeGranted, advance='no' )
          call output ( " create file? " )
          call output ( createFile, advance='no' )
          call output ( " file " )
          call output ( trim(theFile), advance='yes' )
        end if
        call add_to_directwrite_timing ( 'waiting', dwt2)
        didthewrite = .false.
      end if
      
      ! Simply loop over lines in the l2cf
      ! related to DiretWrites;
      ! e.g., the Label commands which endoww the datasets with Names
      call init_next_tree_node ( state )
      do 
        son = next_tree_node ( root, state )
        if ( son == 0 ) exit
        call get_label_and_spec ( son, label, key )
        L2CFNODE = key
        reset = .false.

        do j = 2, nsons(key) ! fields of the "time" specification
          gson = subtree(j, key)
          field = get_field_id(gson)   ! tree_checker prevents duplicates
          if (nsons(gson) > 1 ) gson = subtree(2,gson) ! Gson is value
          select case ( field )
          case ( f_reset )
            reset = Get_Boolean ( gson )
          case default
            ! Shouldn't get here if the type checker worked
          end select
        end do ! j = 2, nsons(key)
        if ( MLSSelecting .and. &
          & .not. any( get_spec_id(key) == (/ s_endselect, s_select, s_case /) ) ) cycle
        specId = get_spec_id ( key )
        select case ( specId )
        ! We should care only about DirectWrite, Label, and Control Structures
        ! (Like Case, SSkip, etc.)
        case ( s_skip ) ! ============================== Skip ==========
          ! We'll skip the rest of the section if the Boolean cond'n is TRUE
          if ( Skip(key) ) exit
        case ( s_select ) ! ============ Start of select .. case ==========
          ! We'll start seeking a matching case
          call MLSSelect (key)
        case ( s_case ) ! ============ seeking matching case ==========
          ! We'll continue seeking a match unless the case is TRUE
          call MLSCase (key)
        case ( s_endSelect ) ! ============ End of select .. case ==========
          ! We'done with seeking a match
          call MLSEndSelect (key)
        case ( s_time )
          ! Only say the time the first time round
          if ( pass == 1 ) then
            if ( timing .and. .not. reset ) then
              call sayTime ( 'Join', t1=t1, cumulative=.false. )
            else
              call time_now ( t1 )
              timing = .true.
            end if
          end if
        case ( s_label )
          ! Only do these the first time round
          if ( pass == 1 .and. .not. checkpaths ) then
            call LabelVectorQuantity ( son, vectors )
          end if
        case ( s_directWrite )
          ! if ( SKIPDIRECTWRITES ) exit
          if ( DEEBUG ) then
            call output ( 'Now have a DirectWrite Command', advance='yes' )
            call outputNamedValue ( 'pass', pass )
            call outputNamedValue ( 'parallel%slave', parallel%slave )
            call outputNamedValue ( 'autoDirectWrite', autoDirectWrite )
            call outputNamedValue ( 'explicitFile(son)', explicitFile(son) )
          endif
          call time_now ( dwt1 )
          if ( pass == 1 ) then
            ! On the first pass just count the number of direct writes
            noDirectWrites = noDirectWrites + 1
            ! Unless we're not a slave in which case just get on with it.
            if ( .not. parallel%slave ) then
              if( DEEBUG ) print*,'Calling DirectWrite, not slave'
              call time_now ( dwt2 )
              if ( autoDirectWrite .and. .not. explicitFile(son) ) then
                ! Pretend we're given permission to write to each of the files
                do dbIndex=1, size(DirectdataBase)
                  if ( DirectDataBase(dbIndex)%autoType < 1 ) cycle
                  if(DEEBUG)print*,'DirectWrite to ', &
                    & trim(DirectDataBase(dbIndex)%fileNameBase)
                  call DirectWriteCommand ( son, ticket, vectors, &
                    & DirectdataBase, filedatabase, &
                    & chunkNo, chunks, outputTyp, FWModelConfig, HGrids, &
                    & theFile=DirectDataBase(dbIndex)%fileNameBase, &
                    & namedFile=namedFile )
                  if ( namedFile ) exit
                end do
              else
                if( DEEBUG ) print*,'Calling DirectWrite, ready to write'
                call DirectWriteCommand ( son, ticket, vectors, &
                  & DirectdataBase, filedatabase, &
                  & chunkNo, chunks, outputTyp, FWModelConfig, HGrids )
              end if
              call add_to_directwrite_timing ( 'writing', dwt2)
            end if
          else if ( pass == 2 ) then
            ! On the second pass, log all our direct write requests.
            ! (and correct the count of Direct Writes if we're automatically
            !  distributing them, instead of relying on one line/one write)
            if(DEEBUG)call print_source ( where_at(son) )
            if(DEEBUG)print*,'Calling direct write to do a setup'
            call DirectWriteCommand ( son, ticket, vectors, &
              & DirectdataBase, fileDatabase,  &
              & chunkNo, chunks, outputTyp, FWModelConfig, HGrids, &
              & makeRequest=.true., NoExtraWrites=noExtraWrites )
            noDirectWrites = noDirectWrites + noExtraWrites
          else
            ! On the later passes we do the actual direct write we've been
            ! given permission for.
            if ( son == directWriteNodeGranted ) then
              didTheWrite = .true.
              call time_now ( dwt2 )
              if ( DeeBug  ) then
                call print_source ( where_at(son) )
                print*,'Calling direct write to do the write'
                print*,'Asked to create file? ', createFile
                print*,'the file ', trim(theFile)
              endif
              call DirectWriteCommand ( son, ticket, vectors, &
                & DirectdataBase, filedatabase, &
                & chunkNo, chunks, outputTyp, FWModelConfig, HGrids, &
                & create=createFile, &
                & theFile=theFile )
              call time_now(dwt22)
              if ( dwt22-dwt2 > timeReasonable .and. &
                & switchDetail(switches,'dwreq') > -1 ) then
                call output('Unreasonable time for directwritecommand', advance='yes')
                call output('Chunk: ', advance='no')
                call output(ChunkNo, advance='yes')
                call output('File: ', advance='no')
                call output(trim(theFile), advance='yes')
              end if
              if ( verbose ) then
                call sayTime ( 'Completing this DW, ' // &
                  & trim(outputTyp), t1=dwt2, cumulative=.false. )
                call outputNamedValue( 'Waiting time', TimeSpentWaiting )
                call outputNamedValue( 'File name', trim(theFile) )
              end if
              call add_to_directwrite_timing ( 'writing', dwt2 )
              noDirectWritesCompleted = noDirectWritesCompleted + 1
              ! If that was the last one then bail out
              if(DEEBUG)print*,'noDirectWritesCompleted: ', noDirectWritesCompleted, &
                & 'noDirectWrites: ', noDirectWrites
              if ( noDirectWritesCompleted == noDirectWrites ) exit passLoop
            end if
          end if
          call add_to_section_timing ( 'directwrite', dwt1)
        end select
      end do                            ! End loop over l2cf lines

      ! If we're not in parallel mode then one pass is enough
      if ( .not. parallel%slave ) exit passLoop

      ! Bail out of pass loop if there are no direct writes, or there was
      ! an error.
      ! if ( noDirectWrites == 0 .or. SKIPDIRECTWRITES .or. error /= 0 ) exit passLoop
      if ( noDirectWrites == 0 .or. error /= 0 ) exit passLoop
      pass = pass + 1
      ! Did we receive permission to write to a "ghost node"
      if ( .not. didTheWrite ) then
        call announce_error(root, no_error_code, &
            & 'Ghost node' ,ticket, 0 )
        print *, 'Ticket: ', ticket
        print *, 'ghost node: ', directWriteNodeGranted
        print*,'noDirectWritesCompleted: ', noDirectWritesCompleted, &
                & 'noDirectWrites: ', noDirectWrites        
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'We received permission to write, but could not find node' )
      end if
    end do passLoop                     ! End loop over passes
  end subroutine AnyDirectWrites

  subroutine AnyOtherCommands
    ! Whatever isn't a DirectWrite
    integer :: J

    error = 0
      
    ! Simply loop over lines in the l2cf
    ! (Except or the DirectWrites which we already did)
    call init_next_tree_node ( state )
    do 
      son = next_tree_node ( root, state )
      if ( son == 0 ) exit
      call get_label_and_spec ( son, label, key )
      L2CFNODE = key
      reset = .false.

      do j = 2, nsons(key) ! fields of the "time" specification
        gson = subtree(j, key)
        field = get_field_id(gson)   ! tree_checker prevents duplicates
        if (nsons(gson) > 1 ) gson = subtree(2,gson) ! Gson is value
        select case ( field )
        case ( f_reset )
          reset = Get_Boolean ( gson )
        case default
          ! Shouldn't get here if the type checker worked
        end select
      end do ! j = 2, nsons(key)
      if ( MLSSelecting .and. &
        & .not. any( get_spec_id(key) == (/ s_endselect, s_select, s_case /) ) ) cycle
      specId = get_spec_id ( key )
      select case ( specId )
      case ( s_diff, s_dump ) ! ======================= Diff, Dump ==========
        ! Handle disassociated pointers by allocating them with zero size
        status = 0
        call outputNamedValue( 'CHECKPATHS in Join%Dump', CHECKPATHS )
        if ( CHECKPATHS ) cycle
        if ( .not. associated(vectors) ) allocate ( vectors(0), stat=status )
        call test_allocate ( status, moduleName, 'Vectors', (/0/), (/0/) )
        call dumpCommand ( key, vectors=vectors, HGrids=HGrids, &
          & ForwardModelConfigs=FWModelConfig, FileDataBase=FileDataBase, &
          & MatrixDatabase=matrices, HessianDatabase=Hessians )
      case ( s_execute ) ! ======================== ExecuteCommand ==========
        call ExecuteCommand ( key )
      case ( s_skip ) ! ============================== Skip ==========
        ! We'll skip the rest of the section if the Boolean cond'n is TRUE
        if ( Skip(key) ) exit
      case ( s_select ) ! ============ Start of select .. case ==========
        ! We'll start seeking a matching case
        call MLSSelect (key)
      case ( s_case ) ! ============ seeking matching case ==========
        ! We'll continue seeking a match unless the case is TRUE
        call MLSCase (key)
      case ( s_endSelect ) ! ============ End of select .. case ==========
        ! We'done with seeking a match
        call MLSEndSelect (key)
      case ( s_time )
            if ( timing .and. .not. reset ) then
              call sayTime ( 'Join', t1=t1, cumulative=.false. )
            else
              call time_now ( t1 )
              timing = .true.
            end if
      case ( s_l2gp, s_l2aux )
        ! Don't do these if we're just checking paths
        if ( .not. checkpaths ) then
          call JoinQuantities ( key, vectors, l2gpDatabase, l2auxDatabase, &
            & chunkNo, chunks )
        end if
      case ( s_label )
        ! Don't do these if we're just checking paths
        if ( .not. checkpaths ) then
          call LabelVectorQuantity ( son, vectors )
        end if
      end select
    end do                            ! End loop over l2cf lines

  end subroutine AnyOtherCommands

  end subroutine MLSL2Join

  ! -----------------------------------------  DirectWriteCommand  -----
  ! 
  ! Direct write is the preferred method for writing hdf-formatted
  ! quantities, with the exception of Spectroscopy and Matrices
  ! like l2pcs and TScat

  ! This routine may be called by a serial run, or by a slave.
  ! If called by a serial run, just do the write and return.

  ! For a slave it will be called many times for each direct write.  The first
  ! is a pass through to check the syntax etc.
  ! If it is successful, in a second pass (makeRequests=.true.)
  ! a request will be made to the master.

  ! Subsequent calls will arrive with permission to actually do the writing,
  ! each time to a specific named file.

  ! There are two modes:
  ! (1) The DirectWrite command named the file explicitly--then write the
  !     quantities to that file
  ! (2) The DirectWrite command did not name any file
  !     then distribute the quantities among the appropriate DirectFiles
  !     i.e., swaths go to DGG files, hdf datasets to DGM files
  subroutine DirectWriteCommand ( node, ticket, vectors, &
    & DirectDataBase, fileDatabase, &
    & chunkNo, chunks, outputTypeStr, &
    & FWModelConfig, HGrids, makeRequest, create, theFile, &
    & noExtraWrites, namedFile )
    ! Imports
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Chunks_M, only: MLSChunk_T
    use DirectWrite_M, only: DirectData_T, &
      & Dump, ExpandDirectdb, FileNameToID
    use Dump_0, only: Dump
    use Expr_M, only: Expr
    use ForwardModelConfig, only: ForwardModelConfig_T
    use HDF, only: Dfacc_Create, Dfacc_Rdwr
    use HGridsDatabase, only: HGrids_T
    use HighOutput, only: OutputNamedValue
    use Init_Tables_Module, only: F_AscDescMode, F_Boolean, F_Convergence, &
      & F_File, F_GroupName, F_HDFVersion, F_InputFile, &
      & F_Label, F_LowerOverlap, F_NoPCFid, F_Options, &
      & F_Precision, F_PrefixSignal, F_Quality, F_Rank, &
      & F_Single, F_Source, F_Status, F_Type, F_UpperOverlap, F_Vector, &
      & Field_First, Field_Last
    use Init_Tables_Module, only: L_L2gp, L_L2aux, L_L2dgg, L_L2fwm, &
      & L_MagneticField, L_Pressure, L_Quantity, L_Zeta
    use Intrinsic, only: L_None, L_HDF, L_Swath, Lit_Indices, Phyq_Dimensionless
    use L2parinfo, only: Parallel, LogDirectwriteRequest, FinishedDirectwrite
    use ManipulateVectorQuantities, only: DoHGridsMatch
    use MLSCommon, only: FileNameLen, MLSFile_T
    use MLSFiles, only: HDFVersion_5, &
      & AddInitializeMLSFile, Dump, GetMLSFileByName, GetPCFromRef, &
      & Split_Path_Name
    use MLSFinds, only: FindFirst, FindNext
    use MLSKinds, only: R8
    use MLSL2Options, only: CheckPaths, Default_HDFVersion_Write, &
      & Patch, RuntimeValues, SkipDirectWrites, Toolkit
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning
    use MLSPCF2, only: MLSPCF_ElevOffset_Start, MLSPCF_Misc_End, &
      & MLSPCF_L2gp_Start, MLSPCF_L2gp_End, &
      & MLSPCF_L2dgm_Start, MLSPCF_L2dgm_End, &
      & MLSPCF_L2fwm_Full_Start, MLSPCF_L2fwm_Full_End, &
      & MLSPCF_L2dgg_Start, MLSPCF_L2dgg_End
    use MLSSignals_M, only: Getsignalname
    use Moretree, only: Get_Field_Id, Get_Boolean
    use Output_M, only: Blanks, Output
    use String_Table, only: Display_String, Get_String
    use Symbol_Table, only: Enter_Terminal
    use Symbol_Types, only: T_String
    use Time_M, only: Time_Now
    use Toggles, only: Gen, Toggle, Switches
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
    use VectorsModule, only: Vector_T, VectorValue_T, ValidateVectorQuantity, &
      & GetVectorQtyByTemplateIndex
    ! Dummy arguments
    integer, intent(in) :: NODE         ! Of the JOIN section in the AST
    integer, intent(in) :: TICKET       ! Ticket number from master
    type (Vector_T), dimension(:), pointer :: VECTORS
    type (DirectData_T), dimension(:), pointer :: DirectDatabase
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    type (HGrids_T), dimension(:), pointer ::     HGrids
    integer, intent(in) :: CHUNKNO
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    character(len=*), intent(out) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    ! The next 3 args are used in the multi-pass followed by each slave:
    ! 1st pass just counts up requests to write
    ! 2nd pass just logs requests to write
    ! later passes come with permission granted to write
    logical, intent(in), optional :: MAKEREQUEST  ! Set on first pass through
    logical, intent(in), optional :: CREATE       ! Set if slave is to create file.
    character(len=*), intent(in), optional :: THEFILE  ! Which file permission granted for
    integer, intent(out), optional :: NOEXTRAWRITES ! How many extras if distributing
    logical, intent(out), optional :: namedFile ! Did it name the file?
    ! Local parameters
    integer, parameter :: MAXFILES = 1000 ! Set for an internal array
    ! Saved variable - used to work out the createFile flag in the serial case
    integer, dimension(maxFiles), save :: CREATEDFILENAMES = 0
    integer, save :: NOCREATEDFILES=0   ! Number of files created
    ! Local variables
    integer :: AFILE
    character(len=1024) :: BoolKey      ! The boolean's key
    logical :: CREATEFILEFLAG           ! Flag (often copy of create)
    logical :: CREATETHISSWATH
    logical :: DEEBUG
    type(MLSFile_T), pointer :: directFile
    logical :: DISTRIBUTINGSOURCES      ! No field 'file=...' in l2cf line
    logical :: DUMMY
    integer :: ERRORTYPE
    integer :: EXPECTEDTYPE             ! l2gp/l2aux
    integer :: EXPRUNITS(2)             ! From expr
    real (r8) :: EXPRVALUE(2)           ! From expr
    integer :: FILE                     ! File name string index
    integer :: FILEACCESS               ! DFACC_CREATE or DFACC_RDWR
    integer :: FIELDINDEX               ! Type of field in l2cf line
    character(len=1024) :: FILENAME     ! Output full filename
    character(len=1024) :: FILE_BASE    ! made up of
    integer :: FILETYPE
    logical, dimension(field_first:field_last) :: GOT
    logical :: GOTSOURCE                ! TRUE if already had a source field
    integer :: GSON                     ! Son of son
    character(len=1024) :: groupName    ! Store sdName under this group
    integer :: HANDLE                   ! File handle from hdf/hdf-eos
    character(len=1024) :: HDFNAME      ! Output swath/sd name
    integer :: HDFVERSION               ! 4 or 5
    character(len=1024) :: inputFile    ! Input full filename
    integer :: i
    logical :: ISNEWDIRECT              ! TRUE if not already in database
    integer :: KEYNO                    ! Loop counter, field in l2cf line
    integer :: l2gp_Version
    integer :: labelId                ! No. things to output
    character(len=1024) :: LABELSTR     ! The label itself
    logical :: lowerOverlap
    ! integer :: LASTFIELDINDEX           ! Type of previous field in l2cf line
    integer :: Me = -1                  ! String index for trace
    integer :: MYFILE                   ! File permission granted for
    logical :: MYMAKEREQUEST            ! Copy of makeRequest
    character(len=FileNameLen) :: MYTHEFILE  ! File permission granted for
    integer :: NEXTFILE
    integer :: NOSOURCES                ! No. things to output
    character(len=16) :: OPTIONS
    ! integer :: AscDescModeVECTOR
    ! integer :: AscDescModeQTYINDX
    logical :: noPCFid
    integer :: OUTPUTTYPE               ! l_l2gp, l_l2aux, l_l2fwm, l_l2dgg
    character(len=1024) :: PATH         ! path/file_base
    integer :: PCBottom
    integer :: PCTop
    logical :: prefixSignal
    integer :: Rank
    integer :: RETURNSTATUS
    logical :: SINGLE
    logical :: SKIPDGG
    logical :: SKIPDGM
    integer :: SON                      ! A tree node
    integer :: SOURCE                   ! Loop counter
    logical :: upperOverlap

    integer, dimension(:), pointer :: CONVERGVECTORS ! Indices
    integer, dimension(:), pointer :: CONVERGQUANTITIES ! Indices
    integer, dimension(:), pointer :: SOURCEVECTORS ! Indices
    integer, dimension(:), pointer :: SOURCEQUANTITIES ! Indices
    integer, dimension(:), pointer :: PRECISIONVECTORS ! Indices
    integer, dimension(:), pointer :: PRECISIONQUANTITIES ! Indices
    integer, dimension(:), pointer :: QUALITYVECTORS ! Indices
    integer, dimension(:), pointer :: QUALITYQUANTITIES ! Indices
    integer, dimension(:), pointer :: STATUSVECTORS ! Indices
    integer, dimension(:), pointer :: STATUSQUANTITIES ! Indices
    integer, dimension(:), pointer :: DIRECTFILES ! Indices
    integer, dimension(:), pointer :: Labels ! Indices
    type(VectorValue_T), pointer :: CONVERGQTY ! The quantities convergence ratio
    type(VectorValue_T), pointer :: QTY ! The quantity
    type(VectorValue_T), pointer :: PRECQTY ! The quantities precision
    type(VectorValue_T), pointer :: QUALITYQTY ! The quantities quality
    type(VectorValue_T), pointer :: STATUSQTY ! The quantities status
    ! type(VectorValue_T), pointer :: AscDescModeQTY ! The shared quantity AscDescMode
    type(DirectData_T), pointer  :: thisDirect ! => null()
    real :: TimeIn, TimeToClose, TimeOut

    ! Executable code
    ! call output ( 'We are in DirectWriteCommand now', advance='yes' )
    DEEBUG = ( switchDetail(switches, 'direct') > 0 ) ! .or. SKIPDIRECTWRITES
    SKIPDGG = ( switchDetail(switches, 'skipdgg') > -1 )
    SKIPDGM = ( switchDetail(switches, 'skipdgm') > -1 )
    outputTypeStr = 'unknown'
    nullify(thisDirect)

    call trace_begin ( me, "DirectWriteCommand", node, &
      & cond=toggle(gen) .and. switchDetail(switches,'dwreq') > -1 )
    call time_now ( timeIn )
    timeToClose = TimeIn
    timeOut = TimeIn
    myMakeRequest = .false.
    if ( present ( makeRequest ) ) myMakeRequest = makeRequest
    myTheFile = 'undefined'   ! 0
    if ( present ( theFile ) ) myTheFile = theFile
    if ( present(noExtraWrites) ) noExtraWrites = 0
    if ( DeeBug ) call outputNamedValue ( 'present(create)', present(create) )
    if ( present(create) .and. DeeBug ) call outputNamedValue ( '(create)',create )

    ! lastFieldIndex = 0
    noSources = 0
    hdfVersion = DEFAULT_HDFVERSION_WRITE
    error = 0
    file = 0
    filename = 'undefined'
    groupname = ' '
    inputFile = 'undefined'
    lowerOverlap = .false.
    got = .false.
    noPCFid = .false.
    prefixSignal = .false.
    options = ' '
    outputType=0
    outputtypestr = 'unknown'
    if ( present(namedFile) ) namedFile = .false.
    rank = 0
    single = .false.
    upperOverlap = .false.
    gotsource = .false.
    do keyNo = 2, nsons(node)           ! Skip DirectWrite command
      son = subtree ( keyNo, node )
      ! if ( keyNo > 2 ) lastFieldIndex = fieldIndex
      fieldIndex = get_field_id ( son )
      got ( fieldIndex ) = .true.
      select case ( fieldIndex )
      case ( f_Boolean )
        call get_string ( sub_rosa(subtree(2,son)), BoolKey, strip=.true. )
        BoolKey = lowerCase(BoolKey)
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & trim(BoolKey), groupName, countEmpty, &
          & inseparator=runTimeValues%sep )
      case ( f_source, f_vector )
        noSources = noSources + 1
        gotsource = .true.
      case ( f_AscDescMode )
        gson = subtree(2,son)
        ! AscDescModeVector = decoration(decoration(subtree(1,gson)))
        ! AscDescModeQtyIndx = decoration(decoration(decoration(subtree(2,gson))))
      case ( f_precision )
        if ( .not. gotsource ) &
          & call Announce_Error ( son, no_error_code, &
            & 'A precision can only be given following a source' )
      case ( f_quality )
        if ( .not. gotsource ) &
          & call Announce_Error ( son, no_error_code, &
            & 'A quality can only be given following a source' )
      case ( f_status )
        if ( .not. gotsource ) &
          & call Announce_Error ( son, no_error_code, &
            & 'A status can only be given following a source' )
      case ( f_hdfVersion )
        call expr ( subtree(2,son), exprUnits, exprValue )
        if ( exprUnits(1) /= phyq_dimensionless ) &
          & call Announce_error ( son, NO_ERROR_CODE, &
          & 'No units allowed for hdfVersion: just integer 4 or 5')
        hdfVersion = exprValue(1)
      case ( f_noPCFid )
        noPCFid = get_boolean ( son )
      case ( f_groupName )
        call get_string ( sub_rosa(subtree(2,son)), groupName, strip=.true. )
      case ( f_options )
        call get_string ( sub_rosa(subtree(2,son)), options, strip=.true. )
      case ( f_file )
        file = sub_rosa(subtree(2,son))
        if ( present(namedFile) ) namedFile = .true.
      case ( f_inputfile )
        call get_string ( sub_rosa(subtree(2,son)), inputfile, strip=.true. )
      case ( f_type )
        outputType = decoration(subtree(2,son))
        call get_string ( lit_indices(outputType), outputTypeStr, strip=.true. )
      case ( f_lowerOverlap )
        lowerOverlap = get_boolean ( son )
      case ( f_upperOverlap )
        upperOverlap = get_boolean ( son )
      case ( f_prefixSignal )
        prefixSignal = get_boolean ( son )
      case ( f_rank )
        call expr ( subtree(2,son), exprUnits, exprValue )
        if ( exprUnits(1) /= phyq_dimensionless ) &
          & call Announce_error ( son, NO_ERROR_CODE, &
          & 'No units allowed for rank: just integer 0..4')
        rank = nint(exprValue(1))
        ! call outputnamedValue ( 'rank field', rank )
      case ( f_single )
        single = get_boolean ( son )
      end select
    end do

    if ( file > 0 ) then
      call get_string ( file, filename, strip=.true. )
    else if ( myTheFile /= 'undefined' ) then
      filename = myTheFile
    end if
    myFile =  FileNameToID(trim(filename), DirectDataBase ) 
    distributingSources = (file < 1)
    if ( DeeBug ) then
      call outputNamedValue ( 'filename', trim(filename) )
      call outputNamedValue ( 'distributingSources', distributingSources )
    endif
    ! Now identify the quantities we're after
    nullify ( sourceVectors, sourceQuantities, &
      & qualityVectors, qualityQuantities, &
      & convergQuantities, convergVectors, &
      & statusVectors, statusQuantities, &
      & precisionVectors, precisionQuantities, directFiles, labels )
    call Allocate_test ( sourceVectors, noSources, 'sourceVectors', ModuleName )
    call Allocate_test ( sourceQuantities, noSources, 'sourceQuantities', &
      &  ModuleName, Fill=-1 )
    call Allocate_test ( precisionVectors, noSources, 'precisionVectors', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( precisionQuantities, noSources, 'precisionQuantities', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( qualityVectors, noSources, 'qualityVectors', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( qualityQuantities, noSources, 'qualityQuantities', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( statusVectors, noSources, 'statusVectors', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( statusQuantities, noSources, 'statusQuantities', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( convergVectors, noSources, 'convergVectors', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( convergQuantities, noSources, 'convergQuantities', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( directFiles, noSources, 'directFiles', &
      &  ModuleName, Fill=0 )
    call Allocate_test ( labels, noSources, 'directFiles', &
      &  ModuleName, Fill=0 )
    ! Go round again and identify each quantity, work out what kind of file
    ! we're talking about
    labelId = 0
    source = 0
    do keyNo = 2, nsons(node)
      l2gp_Version = 1
      son = subtree ( keyNo, node )
      fieldIndex = get_field_id ( son )
      select case ( fieldIndex )
      case ( f_source )
        source = source + 1
        gson = subtree(2,son)
        sourceVectors(source) = decoration(decoration(subtree(1,gson)))
        sourceQuantities(source) = decoration(decoration(decoration(subtree(2,gson))))
      case ( f_convergence )
        if ( all ( outputType /= (/ l_l2gp, l_l2dgg /) ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Convergence only appropriate for l2gp files" )
        gson = subtree(2,son)
        convergVectors(source) = decoration(decoration(subtree(1,gson)))
        convergQuantities(source) = decoration(decoration(decoration(subtree(2,gson))))
      case ( f_precision )
        if ( all ( outputType /= (/ l_l2gp, l_l2dgg /) ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Precision only appropriate for l2gp files" )
        gson = subtree(2,son)
        precisionVectors(source) = decoration(decoration(subtree(1,gson)))
        precisionQuantities(source) = decoration(decoration(decoration(subtree(2,gson))))
      case ( f_quality )
        if ( all ( outputType /= (/ l_l2gp, l_l2dgg /) ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Quality only appropriate for l2gp files" )
        gson = subtree(2,son)
        qualityVectors(source) = decoration(decoration(subtree(1,gson)))
        qualityQuantities(source) = decoration(decoration(decoration(subtree(2,gson))))
      case ( f_status )
        if ( all ( outputType /= (/ l_l2gp, l_l2dgg /) ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Status only appropriate for l2gp files" )
        gson = subtree(2,son)
        statusVectors(source) = decoration(decoration(subtree(1,gson)))
        statusQuantities(source) = decoration(decoration(decoration(subtree(2,gson))))
      case ( f_vector )
        source = source + 1
        sourceVectors(source) = decoration(decoration(subtree(2,son)))
      case ( f_label )
        labelId = labelId + 1
        labels(labelId) = sub_rosa(subtree(2,son))
      case default
      end select
    end do

    ! Label quantities if we supplied labels on the command line
    if ( checkpaths ) then
      ! No, don't label if just messing around
    elseif ( prefixSignal .and. labelId > 0 ) then
      ! All sources have the same label suffix
      ! They differ only in which signal string they begin with
      do i=1, noSources
        qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(i)), sourceQuantities(i) )
        if ( qty%template%signal == 0 ) then
          call Announce_Error ( node, no_error_code, &
            & 'The quantity has no signal so prefixSignal is not appropriate' )
          cycle
        end if
        call GetSignalName ( qty%template%signal, labelStr, &
          & sideband=qty%template%sideband )
        call Get_String( labels(1), labelStr(len_trim(labelStr)+1:), strip=.true. )
        ! Now get an index for this possibly new name which may include the signal
        qty%label = enter_terminal ( trim(labelStr), t_string, caseSensitive=.true. )
      enddo
    else
      ! Each label corresponds to a source
      do i=1, labelId
        qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(i)), sourceQuantities(i) )
        qty%label = labels(i)
      enddo
    end if

    if ( .not. checkpaths ) then
      ! Now go through and do some sanity checking
      ! On the way let's pick out Qty, PrecQty, .. to be written
      ! nullify ( AscDescModeQty )
      ! if ( got(f_AscDescMode) ) AscDescModeQty => GetVectorQtyByTemplateIndex ( vectors(AscDescModevector), &
      ! & AscDescModeQtyIndx )
      do source = 1, noSources
        if ( sourceQuantities(source) < 1 ) cycle
        qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
        & sourceQuantities(source) )
        if ( qty%label == 0 ) call Announce_Error ( son, no_error_code, &
        & "Quantity does not have a label" )
        if ( precisionVectors(source) /= 0 ) then
          precQty => &
            & GetVectorQtyByTemplateIndex ( vectors(precisionVectors(source)), &
            & precisionQuantities(source) )
          ! Check that this is compatible with its value quantity
          if ( qty%template%name /= precQty%template%name ) &
          & call Announce_Error ( son, no_error_code, &
          & "Precision and quantity do not match" )
        else
          precQty => NULL()
        end if
        if ( qualityVectors(source) /= 0 ) then
          qualityQty => &
            & GetVectorQtyByTemplateIndex ( vectors(qualityVectors(source)), &
            & qualityQuantities(source) )
          ! Check that value and quality share same HGrid
          if ( .not. DoHgridsMatch( qty, qualityQty ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Source and quality not on matching HGrids" )
        else
          qualityQty => NULL()
        end if
        if ( statusVectors(source) /= 0 ) then
          statusQty => &
            & GetVectorQtyByTemplateIndex ( vectors(statusVectors(source)), &
            & statusQuantities(source) )
          ! Check that value and quality share same HGrid
          if ( .not. DoHgridsMatch( qty, statusQty ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Source and status not on matching HGrids" )
        else
          statusQty => NULL()
        end if
        if ( convergVectors(source) /= 0 ) then
          convergQty => &
            & GetVectorQtyByTemplateIndex ( vectors(convergVectors(source)), &
            & convergQuantities(source) )
          ! Check that value and convergence share same HGrid
          if ( .not. DoHgridsMatch( qty, convergQty ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Source and convergence not on matching HGrids" )
        else
          convergQty => NULL()
        end if
        ! Now check that things make sense
        if ( ValidateVectorQuantity ( qty, &
          & coherent=.true., stacked=.true., regular=.true., &
          & verticalCoordinate = (/ l_pressure, l_zeta, l_none/), &
          & minorFrame=.false., majorFrame=.false. ) ) then
          expectedType = l_l2gp
        elseif ( qty%template%quantityType == l_magneticField ) then
          expectedType = l_quantity
        else
          expectedType = l_l2aux
        end if
        if ( outputType /= expectedType .and. .not. &
          & ( outputType == l_l2dgg .and. expectedType == l_l2gp ) &
          &                           .and. .not.  &
          & ( outputType == l_l2fwm .and. expectedType == l_l2aux ) ) then
          call output ( "Offending quantity " )
          call display_string ( qty%template%name, strip=.true., advance='yes' )
          call output ( "Expected type " )
          call display_string ( lit_indices(expectedType), advance='yes' )
          call output ( "Output file type " )
          call display_string ( lit_indices(outputType), advance='yes' )
          call Announce_Error ( son, no_error_code, &
            & "Inappropriate quantity for this file type in direct write", &
            & Penalty=0 )
        end if
      end do
    end if
    
    ! Bail out at this stage if there is some kind of error.
    if ( error /= 0 ) then
      call trace_end ( "DirectWriteCommand", &
        & cond=toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 )
      return
    end if

    ! Distribute sources among available DirectWrite files if filename undefined
    if ( distributingSources ) then
       call DistributeSources
    end if
    if ( DeeBUG ) then
      call output('Direct write to file', advance='yes')
      call output('File name: ', advance='no')
      call output(trim(filename), advance='yes')
      call output('hdfVersion: ', advance='no')
      call output(hdfVersion, advance='yes')
      call output('Num sources: ', advance='no')
      call output(noSources, advance='yes')
      if ( present(theFile) ) then
        call output('my(theFile): ', advance='no')
        call output(trim(myTheFile), advance='yes')
      end if
      call output('size(DirectDB): ', advance='no')
      call output(size(DirectDatabase), advance='yes')
    end if

    ! If we're skipping all directwrites, let's deallocate and return
    if ( SKIPDIRECTWRITES ) then
      call DeallocateStuff
      call trace_end ( "DirectWriteCommand", &
        & cond=toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 )
      return
    end if

    ! If this is the first pass through, then we just log our request
    ! with the master
    if ( myMakeRequest ) then
      if ( file < 1 ) then
        ! Here's a crude idea: loop until we've wrapped
        ! (A better idea would pick out only unique integers from an array)
        nextFile = directFiles(1)
        call LogDirectWriteRequest ( DirectDatabase(nextfile)%fileIndex, node )
        if ( DEEBug ) then
          call output('Logged directwrite rq for: ', advance='no')
          call output(DirectDatabase(nextfile)%fileIndex, advance='no')
          call output('   node: ', advance='no')
          call output(node, advance='no')
          call output('  (named): ', advance='no')
          call display_string(DirectDatabase(nextfile)%fileIndex, advance='yes')
        end if
        if ( noSources > 1 ) then
          do source = 2, noSources
            aFile = nextFile
            nextFile = directFiles(source)
            if ( nextFile < aFile ) exit
            call LogDirectWriteRequest ( DirectDatabase(nextfile)%fileIndex, node )
            if ( present(noExtraWrites) ) noExtraWrites = noExtraWrites + 1
            if ( DEEBug ) then
              call output('Logged directwrite rq for: ', advance='no')
              call output(DirectDatabase(nextfile)%fileIndex, advance='no')
              call output('   node: ', advance='no')
              call output(node, advance='no')
              call output('  (named): ', advance='no')
              call display_string(DirectDatabase(nextfile)%fileIndex, advance='yes')
            end if
          end do
        end if
        if ( DEEBug .and. present(noExtraWrites) ) then
          call output('noExtraWrites: ', advance='no')
          call output(noExtraWrites, advance='no')
        end if
      else
        call LogDirectWriteRequest ( file, node )
      end if
    else if ( skipdgg .and. any ( outputType == (/ l_l2dgg /) ) ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
      & 'DirectWriteCommand skipping all dgg writes ' // trim(filename) )
      call DeallocateStuff
      call trace_end ( "DirectWriteCommand", &
        & cond=toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 )
      return
    else if ( skipdgm .and. any ( outputType == (/ l_l2fwm, l_l2aux, l_hdf /) ) ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
      & 'DirectWriteCommand skipping all dgm/fwm writes ' // trim(filename) )
      call DeallocateStuff
      call trace_end ( "DirectWriteCommand", &
        & cond=toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 )
      return
    else
      ! OK, it's time to write this bit of the file
      if ( parallel%slave ) then
        createFileFlag = .false.
        if ( present ( create ) ) createFileFlag = create
       if ( DeeBug ) call outputNamedValue( 'Were a slave; createFileFlag', createFileFlag )
      else if ( distributingSources ) then
        ! Short-circuit this direct write if outputType fails to match
        if ( myFile < 1 ) then
          call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'DirectWriteCommand unable to auto-direct write ' // trim(filename) )
        else if ( outputType /= DirectDataBase(myFile)%type ) then
          call DeallocateStuff
          if ( DeeBUG ) print *, 'Short-circuiting ' // trim(filename)
          call trace_end ( "DirectWriteCommand", &
            & cond=toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 )
          return
        end if
        createFileFlag = .not. any ( createdFilenames == myFile )
        if ( createFileFlag ) then
          noCreatedFiles = noCreatedFiles + 1
          if ( DeeBug ) call outputNamedValue( 'Incrementing noCreatedFiles', noCreatedFiles )
          if ( noCreatedFiles > maxFiles ) call MLSL2Message ( &
            & MLSMSG_Error, ModuleName, 'Too many direct write files' )
          createdFilenames ( noCreatedFiles ) = myFile
        end if
      else
        createFileFlag = .not. any ( createdFilenames == file )
        if ( createFileFlag ) then
          noCreatedFiles = noCreatedFiles + 1
          if ( DeeBug ) call outputNamedValue( 'Incrementing noCreatedFiles', noCreatedFiles )
          if ( noCreatedFiles > maxFiles ) call MLSL2Message ( &
            & MLSMSG_Error, ModuleName, 'Too many direct write files' )
          createdFilenames ( noCreatedFiles ) = file
        end if
      end if
      
      returnStatus = 0
      ! Open/create the file of interest
      isnewdirect = .true.  ! Just so it has a value even for toolkitless runs
      call split_path_name(filename, path, file_base)
      if ( distributingSources .or. TOOLKIT .or. CATENATESPLITS ) then
        call ExpandDirectDB ( DirectDatabase, file_base, thisDirect, &
        & isnewdirect )
        if ( DeeBUG ) then
          call output('Did we need to expand DB for ' // trim(file_base), &
            & advance='yes')
          call output(isnewdirect, advance='yes')
        end if
        if ( .not. associated(thisDirect) ) then
          call Announce_Error ( son, NO_ERROR_CODE, &
              & 'ExpandDirectDB returned unassociated thisDirect' )
          call dump(DirectDatabase)
          call MLSL2Message( MLSMSG_Error, ModuleName, &
          & 'ExpandDirectDB returned unassociated thisDirect' )
        end if
      end if
      if ( .not. (TOOLKIT .or. CATENATESPLITS) ) then
        handle = 0
      else if ( .not. isnewdirect ) then
        Filename = thisDirect%fileName
        Handle = thisDirect%Handle
      else if ( noPCFid ) then
        Handle = -2
      else if ( .not. TOOLKIT ) then
        Handle = -1
      else if ( any ( outputType == (/ l_l2gp /) ) ) then
        Handle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
          & mlspcf_l2gp_end, &
          & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
          & exactName=Filename)
      else if ( any ( outputType == (/ l_l2dgg /) ) ) then
        Handle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
          & mlspcf_l2dgg_end, &
          & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
          & exactName=Filename)
      else if ( any ( outputType == (/ l_l2fwm /) ) ) then
        Handle = GetPCFromRef(file_base, mlspcf_l2fwm_full_start, &
          & mlspcf_l2fwm_full_end, &
          & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
          & exactName=Filename)
      else
        Handle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
          & mlspcf_l2dgm_end, &
          & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
          & exactName=Filename)
      end if
      if ( returnStatus /= 0 ) then
          call Announce_Error ( node, NO_ERROR_CODE, &
          & 'Uh-oh' )
         call MLSL2Message ( &
         & MLSMSG_Error, ModuleName, &
         & 'Failed in GetPCFromRef for ' // trim(filename) )
      end if
      if ( isnewdirect .and. (TOOLKIT .or. CATENATESPLITS) ) then
        thisDirect%Handle = Handle
        thisDirect%FileName = FileName
      end if
      if ( isnewdirect .and. distributingSources ) then
          call Announce_Error ( node, NO_ERROR_CODE, &
          & 'Uh-oh' )
        call MLSL2Message( MLSMSG_Error, ModuleName, &
          & 'ExpandDirectDB thinks we need a new directFile; ' // &
          & 'did you enter any in global settings?' )
      end if
      ! Done what we wished to do if just checking paths or SKIPDIRECTWRITES
      if ( checkPaths ) then
      ! if ( SKIPDIRECTWRITES .or. checkPaths ) then
        call trace_end ( "DirectWriteCommand", &
          & cond=toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 )
        return
      end if
      
      if ( createFileFlag .and. .not. patch ) then
        fileaccess = DFACC_CREATE
        if ( DeeBUG ) call output( 'Setting file access to create', advance='yes' )
      else
        fileaccess = DFACC_RDWR ! DFACC_CREATE ! DFACC_RDWR
        if ( DeeBUG ) call output( 'Setting file access to read/write', advance='yes' )
      end if
      if ( DeeBUG ) then
        print *, 'Trying to open ', trim(FileName)
        print *, 'FileAccess ', FileAccess
        print *, 'hdfVersion ', hdfVersion
        print *, 'outputType ', outputType
        print *, 'myFile ', myFile
        print *, 'createFileFlag ', createFileFlag
      end if
      if ( .not. isnewdirect ) then
        ! if ( outputType /= thisDirect%type ) then
        if ( .not. doOutputTypesMatch( outputType, thisDirect%type ) ) then
          call outputNamedValue ( 'outputType', outputType )
          call outputNamedValue ( 'thisDirect%type', thisDirect%type )
          call dump ( thisDirect )
          call MLSL2Message ( MLSMSG_Error, ModuleName, &
            & 'DirectWriteCommand mismatched outputTypes for ' // trim(filename) )
        end if
      end if

      ! Call the l2gp open/create routine.  Filename is 'filename'
      ! file id should go into 'handle'
      if ( .not. TOOLKIT .or. noPCFid ) then
        directFile => GetMLSFileByName( filedatabase, filename, &
          & ignore_paths=.false. )
      else
        directFile => GetMLSFileByName( filedatabase, filename, &
          & ignore_paths=.true. )
      endif
      select case ( outputType )
      case ( l_l2gp )
        fileType = l_swath
        PCBottom = mlspcf_l2gp_start
        PCTop    = mlspcf_l2gp_end
      case ( l_l2dgg )
        fileType = l_swath
        PCBottom = mlspcf_l2dgg_start
        PCTop    = mlspcf_l2dgg_end
      case ( l_l2fwm )
        fileType = l_hdf
        PCBottom = mlspcf_l2fwm_full_start
        PCTop    = mlspcf_l2fwm_full_end
      case ( l_l2aux )
        fileType = l_hdf
        PCBottom = mlspcf_l2dgm_start
        PCTop    = mlspcf_l2dgm_end
      case ( l_hdf )
        fileType = l_hdf
        PCBottom = mlspcf_l2dgm_start
        PCTop    = mlspcf_l2dgm_end
        ! The following do not yet have their own PCFid ranges assigned to them
        ! If they become used routinely in std or nrt processing, this
        ! should be done. Instead for the present we just loop over the
        ! PCF range 
        !       mlspcf_ElevOffset_start <= pcfID <= mlspcf_Misc_end
        if ( len_trim(file_base) > 0 ) then
          PCBottom = mlspcf_ElevOffset_start
          PCTop    = mlspcf_Misc_end
        endif
      case ( l_quantity )
        fileType = l_hdf
        PCBottom = mlspcf_l2dgm_start
        PCTop    = mlspcf_l2dgm_end
      end select
      if ( .not. associated(directFile) ) then
        if(DEEBUG) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'No entry in filedatabase for ' // trim(filename) )
        directFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=Filename, shortName=file_base, &
          & type=fileType, access=DFACC_CREATE, HDFVersion=HDFVERSION_5, &
          & PCBottom=PCBottom, PCTop=PCTop)
      end if
      directFile%access = FileAccess
      if(DEEBUG) call dump(directFile)

      ! Now write according to the type of DirectWrite File it is
      ! Some indicators of where to find the file in the PCF
      ! and what type of file it will be (fileType will be redefined later)
      select case ( outputType )
      case ( l_l2gp )
        call DWSwath ( Son, Node, noSources, distributingSources, TimeIn, &
          & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
          & chunkNo, chunks, createFileFlag, createthisswath, &
          & lowerOverlap, upperOverlap, NoCreatedFiles, &
          & sourceVectors, sourceQuantities, &
          & precisionVectors, precisionQuantities, &
          & qualityVectors, qualityQuantities, &
          & statusVectors, statusQuantities, &
          & convergVectors, convergQuantities, &
          & vectors, DirectDatabase, directfiles, &
          & directfile, thisDirect )
      case ( l_l2dgg )
        call DWSwath ( Son, Node, noSources, distributingSources, TimeIn, &
          & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
          & chunkNo, chunks, createFileFlag, createthisswath, &
          & lowerOverlap, upperOverlap, NoCreatedFiles, &
          & sourceVectors, sourceQuantities, &
          & precisionVectors, precisionQuantities, &
          & qualityVectors, qualityQuantities, &
          & statusVectors, statusQuantities, &
          & convergVectors, convergQuantities, &
          & vectors, DirectDatabase, directfiles, &
          & directfile, thisDirect )
      case ( l_l2fwm )
        if ( DeeBug ) then
          call Dump( createdFilenames(1:noCreatedFiles), 'Created Files' )
          call OutputNamedValue &
            & ( 'NoCreatedFiles before DWHDF', NoCreatedFiles )
        endif
        call DWHDF ( Son, Node, noSources, distributingSources, TimeIn, &
          & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
          & chunkNo, createFileFlag, createthisswath, &
          & lowerOverlap, upperOverlap, NoCreatedFiles, &
          & sourceVectors, sourceQuantities, &
          & precisionVectors, precisionQuantities, &
          & vectors, DirectDatabase, directfiles, &
          & directfile, thisDirect, chunks, FWModelConfig, single, L2Aux=.true. )
        if ( DeeBug ) call outputNamedValue &
          & ( 'NoCreatedFiles after DWHDF', NoCreatedFiles )
      case ( l_l2aux )
        call DWHDF ( Son, Node, noSources, distributingSources, TimeIn, &
          & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
          & chunkNo, createFileFlag, createthisswath, &
          & lowerOverlap, upperOverlap, NoCreatedFiles, &
          & sourceVectors, sourceQuantities, &
          & precisionVectors, precisionQuantities, &
          & vectors, DirectDatabase, directfiles, &
          & directfile, thisDirect, chunks, FWModelConfig, single, L2Aux=.true. )
      case ( l_hdf )
        call DWHDF ( Son, Node, noSources, distributingSources, TimeIn, &
          & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
          & chunkNo, createFileFlag, createthisswath, &
          & lowerOverlap, upperOverlap, NoCreatedFiles, &
          & sourceVectors, sourceQuantities, &
          & precisionVectors, precisionQuantities, &
          & vectors, DirectDatabase, directfiles, &
          & directfile, thisDirect, chunks, FWModelConfig, single, L2Aux=.false. )
      case ( l_quantity )
        call DWQty ( Son, Node, noSources, distributingSources, TimeIn, &
          & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
          & chunkNo, createFileFlag, createthisswath, &
          & lowerOverlap, upperOverlap, NoCreatedFiles, &
          & sourceVectors, sourceQuantities, &
          & vectors, DirectDatabase, directfiles, &
          & directfile, thisDirect )
      end select
      
      ! Tell the master we're done
      if ( parallel%slave ) call FinishedDirectWrite ( ticket )
      call time_now ( timeOut )
      if ( timeOut-timeToClose > timeReasonable .and. &
        & switchDetail(switches,'dwreq') > -1 ) then
        call output('Unreasonable time out ' //trim(hdfname), advance='yes')
      end if
    end if

    call trace_end ( "DirectWriteCommand", &
      & cond=toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 )
    call DeallocateStuff

  contains
    subroutine DistributeSources
      ! Distribute noSources among the files in the directWrite db
      ! Of course, the types must match
      ! Local variables
      integer :: afile
      integer :: nextfile
      integer :: NumSuitablesFiles   ! How many with matching types
      integer :: source
      ! Executable
      if ( size(DirectDataBase) < 1 ) call MLSL2Message ( &
        & MLSMSG_Error, ModuleName, &
        & 'No files in directDatabase to distribute sources among' )
      NumSuitablesFiles = 0
      do afile = 1, size(DirectDataBase)
        if ( outputType == DirectDataBase(afile)%autoType ) &
          & NumSuitablesFiles = NumSuitablesFiles + 1
      end do
      if ( NumSuitablesFiles < 1 ) then
        call Announce_Error ( son, NO_ERROR_CODE, &
              & 'No suitable files in directDatabaset' )
        call output('outputType: ')
        call output(outputType, advance='yes')
        call display_string ( lit_indices(outputType), advance='yes' )
        call output(DirectDataBase%autoType)
        call MLSL2Message ( &
        & MLSMSG_Error, ModuleName, &
        & 'No suitable files in directDatabase to distribute sources among' )
      end if
      nextfile = FindFirst(DirectDataBase%autoType, outputType)
      do source = 1, noSources
        afile = nextFile
        directfiles(source) = afile
        nextFile = FindNext(DirectDataBase%autoType, outputType, afile, &
          & wrap=.true.)
      end do
      if ( DeeBug ) then
       call output ( "NumSources = " )
       call output ( NoSources, advance='no' )
       call output ( "    NumSuitablesFiles = " )
       call output ( NumSuitablesFiles, advance='yes' )
       do source=1, noSources
         aFile= directfiles(source)
         call output ( source, after='    ', advance='no' )
         call output ( aFile, after='    ', advance='no' )
         call output ( trim(DirectDatabase(aFile)%fileName), advance='no' )
         call blanks ( 4, advance='no' )
         call display_string(DirectDatabase(aFile)%fileIndex, advance='yes')
       end do
      end if
    end subroutine DistributeSources
    subroutine DeallocateStuff
      call Deallocate_test ( sourceVectors, 'sourceVectors', ModuleName )
      call Deallocate_test ( sourceQuantities, 'sourceQuantities', ModuleName )
      call Deallocate_test ( precisionVectors, 'precisionVectors', ModuleName )
      call Deallocate_test ( precisionQuantities, 'precisionQuantities', ModuleName )
      call Deallocate_test ( qualityVectors, 'qualityVectors', ModuleName )
      call Deallocate_test ( qualityQuantities, 'qualityQuantities', ModuleName )
      call Deallocate_test ( statusVectors, 'statusVectors', ModuleName )
      call Deallocate_test ( statusQuantities, 'statusQuantities', ModuleName )
      call Deallocate_test ( convergVectors, 'convergVectors', ModuleName )
      call Deallocate_test ( convergQuantities, 'convergQuantities', ModuleName )
      call Deallocate_test ( directFiles, 'directFiles', ModuleName )
    end subroutine DeallocateStuff
    function doOutputTypesMatch( type1, type2 ) result( match )
      ! Args
      integer, intent(in) :: type1, type2
      logical :: match
      select case ( type1 )
      case ( l_l2gp, l_l2dgg )
        match = any ( type2 == (/ l_l2gp, l_l2dgg /) )
      case ( l_l2aux, l_hdf, l_quantity )
        match = any ( type2 == (/ l_l2aux, l_hdf, l_quantity /) )
      case ( l_l2fwm )
        match = any ( type2 == (/ l_l2fwm, l_hdf /) )
      case default
        ! In case we add later types (which we did: l_quantity for one)
        match = ( type1 == type2 )
      end select
    end function doOutputTypesMatch
  end subroutine DirectWriteCommand

  ! ------------------------------------------ LabelVectorQuantity -----
  subroutine LabelVectorQuantity ( node, vectors )
    use Init_Tables_Module, only: F_Boolean, F_Label, F_Prefixsignal, &
      & F_Quantity, F_Vector
    use MLSL2Options, only: RuntimeValues
    use MLSSignals_M, only: GetSignalName
    use Moretree, only: Get_Field_Id, Get_Boolean
    use Symbol_Table, only: Enter_Terminal
    use Symbol_Types, only: T_String
    use String_Table, only: Get_String
    use Tree, only: Nsons, Subtree, Sub_Rosa, Decoration
    use VectorsModule, only: Vector_T, VectorValue_T, &
      & GetVectorQuantity, GetVectorQtyByTemplateIndex
    ! Dummy arguments
    integer, intent(in) :: NODE          ! Tree node for l2cf line
    type (Vector_T), dimension(:), pointer :: VECTORS ! Vectors database
    ! Local variables
    character(len=1024) :: BoolKey      ! The boolean's key
    integer :: FIELDINDEX               ! Type of field
    integer :: KEYNO                    ! Field index
    integer :: LABEL                    ! String index
    character(len=1024) :: LABELSTR     ! The label itself
    integer :: QUANTITYINDEX            ! Index into quantities database
    integer :: SON                      ! Tree node
    integer :: SOURCE                   ! Tree node
    integer :: VECTORINDEX              ! Index into database
    logical :: PREFIXSIGNAL             ! From l2cf
    ! logical :: SUFFIXLABEL              ! From l2cf
    integer :: VLABEL                   ! String index
    character(len=8) :: whatToLabel     ! 'quantity' or 'vector'
    ! Executable code
    type (VectorValue_T), pointer :: QTY ! The quantity

    prefixSignal = .false.
    ! Loop over the fields of the mlscf line
    do keyNo = 2, nsons(node) ! Skip spec name
      son = subtree(keyNo,node)
      fieldIndex = get_field_id(son)
      select case ( fieldIndex )
      case ( f_quantity )
        source = subtree(2,son) ! required to be an n_dot vertex
        vectorIndex = decoration(decoration(subtree(1,source)))
        quantityIndex = decoration(decoration(decoration(subtree(2,source))))
        whatToLabel = 'quantity'
      case ( f_vector )
        vectorIndex = decoration(decoration(subtree(2,son)))
        whatToLabel = 'vector'
      case ( f_prefixSignal )
        prefixSignal = get_boolean ( son )
      ! case ( f_suffixLabel )
        ! suffixLabel = get_boolean ( son )
      case ( f_label )
        label = sub_rosa(subtree(2,son))
      case ( f_Boolean )
        call get_string ( sub_rosa(subtree(2,son)), BoolKey, strip=.true. )
        BoolKey = lowerCase(BoolKey)
        call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
          & trim(BoolKey), labelStr, countEmpty, &
          & inseparator=runTimeValues%sep )
        ! How to get an index for this possibly new name
        label = enter_terminal ( trim(labelStr), t_string, caseSensitive=.true. )
      case default ! Can't get here if tree_checker worked properly
      end select
    end do

    select case ( whatToLabel )
    case ( 'quantity' )
      ! Get the quantity
      qty => GetVectorQtyByTemplateIndex ( vectors(vectorIndex), quantityIndex )

      ! Adapt the label if the prefix signal flag is set.
      if ( prefixSignal ) then
        if ( qty%template%signal == 0 ) then
          call Announce_Error ( node, no_error_code, &
            & 'The quantity has no signal so prefixSignal is not appropriate' )
          return
        end if
        call GetSignalName ( qty%template%signal, labelStr, &
          & sideband=qty%template%sideband )
        call Get_String( label, labelStr(len_trim(labelStr)+1:), strip=.true. )
        ! Now get an index for this possibly new name which may include the signal
        label = enter_terminal ( trim(labelStr), t_string, caseSensitive=.true. )
      end if

      ! Attach the label
      qty%label = label
    case ( 'vector' )
      do quantityIndex=1, size( vectors(vectorIndex)%quantities )
        qty => GetVectorQuantity( vectors(vectorIndex), quantityIndex )
        labelStr = ' '
        if ( qty%template%name /= 0 ) then
          call get_string( qty%template%name, labelStr, strip=.true. )
        end if
        if ( len_trim(labelStr) == 0 ) then
          write( labelStr, '(a9,i3.3,a1)' ) 'quantity[', quantityIndex, ']'
        end if
        call Get_String( label, labelStr(len_trim(labelStr)+1:), strip=.true. )
        ! Attach the label
        vlabel = enter_terminal ( trim(labelStr), t_string, caseSensitive=.true. )
        qty%label = vlabel
      enddo
    case default
      call Announce_Error ( node, NO_ERROR_CODE, &
        & 'Must specify quantity or vector in Label' )
    end select
  end subroutine LabelVectorQuantity

  ! --------------------------------------------------  JoinQuantities  -----
  ! This routine parses a line of the l2cf that is designed to join
  ! quantities together into l2gp/l2aux files
  subroutine JoinQuantities ( node, vectors, l2gpDatabase, l2auxDatabase, &
    & chunkNo, chunks )

    use Chunks_M, only: MLSChunk_T
    ! use Expr_M, only: Expr
    use Init_Tables_Module, only: &
      & F_Precision, F_Prefixsignal, F_Source, F_Sdname, F_Swath, Field_First, &
      & Field_Last
    use Init_Tables_Module, only: L_Pressure, L_Zeta, S_L2aux, S_L2gp
    use Intrinsic, only: L_None!, Phyq_Dimensionless
    use L2auxData, only: L2auxData_T
    use L2gpData, only: L2gpData_T
    use L2parinfo, only: Parallel, Slavejoin
    use MLSMessageModule, only: MLSMSG_Error
    use MLSSignals_M, only: Getsignalname
    use Moretree, only: Get_Boolean, Get_Field_Id, Get_Spec_Id
    use String_Table, only: Get_String
    use Symbol_Table, only: Enter_Terminal
    use Symbol_Types, only: T_String
    use Tree, only: Decoration, Nsons, Null_Tree, Sub_Rosa, Subtree
    use VectorsModule, only: GetVectorQtyByTemplateIndex, &
      & ValidateVectorQuantity, Vector_T, VectorValue_T

    ! Dummy arguments
    integer, intent(in) :: NODE         ! The start of the l2cf line
    type (Vector_T), dimension(:), pointer :: vectors
    type (L2GPData_T), dimension(:), pointer :: l2gpDatabase
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase
    integer, intent(in) :: chunkNo
    type (MLSChunk_T), dimension(:), intent(in) :: chunks

    ! Local variables
    ! integer :: EXPRUNITS(2)                 ! From expr
    integer :: FIELDINDEX               ! F_..., see Init_Tables_Module
    ! integer :: FILE                     ! Name of output file for direct write
    integer :: HDFNAMEINDEX             ! Name of swath/sd
    ! integer :: HDFVERSION               ! Version of hdf for directwrite
    integer :: KEY                      ! Index of an L2GP or L2AUX tree
    integer :: KEYNO                    ! Index of subtree of KEY
    integer :: NAME                     ! Sub-rosa index of name of L2GP or L2AUX
    integer :: PRECQTYINDEX             ! Index for precision qty (in database not vector)
    integer :: PRECVECTORINDEX          ! Index for precision vector
    integer :: QUANTITYINDEX            ! ind in qty tmpl database, not vector
    integer :: SON                      ! Son of Key
    integer :: SOURCE                   ! Index in AST
    integer :: VECTORINDEX              ! Index for vector to join
    ! logical :: COMPAREOVERLAPS
    ! logical :: OutputOverlaps
    logical :: PREFIXSIGNAL             ! Prefix (i.e. make) the sd name the signal
    ! real (r8) :: EXPRVALUE(2)               ! From expr

    character(len=132) :: HDFNAME          ! Name for swath/sd
    logical :: GOT(field_first:field_last)
    type (VectorValue_T), pointer :: Quantity
    type (VectorValue_T), pointer :: PrecisionQuantity

    ! We know this node is named
    key = subtree(2,node)
    name = sub_rosa(subtree(1,node))

    got = .false.
    source = null_tree
    ! compareOverlaps = .false.
    ! outputOverlaps = .false.
    hdfNameIndex=name
    prefixSignal = .false.
    ! hdfVersion = 4

    ! Loop over the fields of the mlscf line
    do keyNo = 2, nsons(key) ! Skip spec name
      son = subtree(keyNo,key)
      fieldIndex = get_field_id(son)
      got(fieldIndex) = .true.
      select case ( fieldIndex )
      case ( f_source )
        source = subtree(2,son) ! required to be an n_dot vertex
        vectorIndex = decoration(decoration(subtree(1,source)))
        quantityIndex = decoration(decoration(decoration(subtree(2,source))))
      case ( f_precision )
        source = subtree(2,son) ! required to be an n_dot vertex
        precVectorIndex = decoration(decoration(subtree(1,source)))
        precQtyIndex = decoration(decoration(decoration(subtree(2,source))))
      ! case ( f_hdfVersion )
        ! call expr ( subtree(2,son), exprUnits, exprValue )
        ! if ( exprUnits(1) /= phyq_dimensionless ) &
        !   & call Announce_error ( son, NO_ERROR_CODE, &
        !  & 'No units allowed for hdfVersion: just integer 4 or 5')
        ! hdfVersion = exprValue(1)
      case ( f_prefixSignal )
        prefixSignal = get_boolean(son)
      ! case ( f_compareoverlaps )
        ! compareOverlaps = get_boolean(son)
      ! case ( f_outputoverlaps )
        ! outputOverlaps = get_boolean(son)
      case ( f_swath )
        hdfNameIndex = sub_rosa(subtree(2,son))
      case ( f_sdName )
        hdfNameIndex = sub_rosa(subtree(2,son))
      ! case ( f_file )
      !   file = sub_rosa(subtree(2,son))
      case default ! Can't get here if tree_checker worked properly
      end select
    end do
    
      ! Some final checks
    ! if ( any ( got ( (/ f_file, f_hdfVersion /) ) ) ) &
    !   & call Announce_Error ( key, NO_ERROR_CODE, &
    !  & 'File or hdfVersion not appropriate arguments for output l2aux/l2gp' )

    if ( error /= 0 ) call MLSL2Message ( MLSMSG_Error, &
      & ModuleName, "Errors in configuration prevent proceeding" )

    ! Identify the quantity
    quantity => GetVectorQtyByTemplateIndex(vectors(vectorIndex),quantityIndex)
    ! Get the precision quantity too perhaps
    if ( got ( f_precision ) ) then
      precisionQuantity => &
        & GetVectorQtyByTemplateIndex(vectors(precVectorIndex),precQtyIndex)
      if ( quantity%template%name /= precisionQuantity%template%name ) &
        & call announce_error(key, NO_ERROR_CODE, &
        & 'Quantity and precision quantity do not match')
    else
      precisionQuantity => NULL()
    end if
    
    ! Establish a swath/sd name for this quantity.
    hdfName = ''
    if ( prefixSignal ) &
      & call GetSignalName ( quantity%template%signal, hdfName, &
      &   sideband=quantity%template%sideband )
    call Get_String( hdfNameIndex, hdfName(len_trim(hdfName)+1:), strip=.true. )
    ! Now get an index for this possibly new name which may include the signal
    hdfNameIndex = enter_terminal ( trim(hdfName), t_string, caseSensitive=.true. )
    
    ! Now do the join, perhaps as a parallel slave, perhaps more directly.
    if ( parallel%slave ) then
      ! For slave tasks in a PVM system, simply ship this vector off to the master
      call SlaveJoin ( quantity, precisionQuantity, hdfName, key )
    else
      ! Now, depending on the properties of the source we deal with the
      ! vector quantity appropriately.
      if ( ValidateVectorQuantity ( quantity, &
        & coherent=.true., stacked=.true., regular=.true., &
        & minorFrame=.false., majorFrame=.false., &
        & verticalCoordinate = (/ l_pressure, l_zeta, l_none/) ) ) then 
        ! Coherent, stacked, regular quantities on pressure surfaces, or
        ! with no vertical coordinate system go in l2gp files.
        if ( get_spec_id(key) /= s_l2gp ) then
          call Announce_Error ( key, NO_ERROR_CODE, &
            & 'This quantity should be joined as an l2gp' )
          call MLSL2Message ( MLSMSG_Error,&
            & ModuleName, 'This quantity should be joined as an l2gp' )
        end if
        call JoinL2GPQuantities ( key, hdfNameIndex, quantity, &
          & precisionQuantity, l2gpDatabase, chunkNo )
      else
        ! All others go in l2aux files.
        if ( get_spec_id(key) /= s_l2aux ) then
          call Announce_Error ( key, NO_ERROR_CODE, &
            & 'This quantity should be joined as an l2aux' )
          call MLSL2Message ( MLSMSG_Error,&
            & ModuleName, 'This quantity should be joined as an l2aux' )
        end if
        call JoinL2AUXQuantities ( key, hdfNameIndex, quantity, &
          & l2auxDatabase, chunks )
      end if
    end if

  end subroutine JoinQuantities

  ! -----------------------------------------  JoinL2GPQuantities  -----

  ! Warning: outmoded--may not work properly
  ! We have not kept this subroutine up-to-date
  ! as we have shifted almost entirely to doing things
  ! by DirectWrite instead of the older Join then Output
  
  ! This routine joins an l2gp line quantity to a database of such quantities.
  ! If this is the first time through, the database is created.

  ! The firstInstance and lastInstance arguments give an optional range of
  ! the instances that we wish to store in the l2gp quantity.  Otherwise, it
  ! defaults to the non overlapped region.

  subroutine JoinL2GPQuantities ( key, name, quantity, &
    & precision, l2gpDatabase, chunkNo, &
    & firstInstance, lastInstance, nameString )

    use Init_Tables_Module, only: L_Pressure, L_Zeta
    use Intrinsic, only: L_None, L_GPH
    use L2gpData, only: Addl2GPtoDatabase, Expandl2GPDatainplace, &
      & L2gpData_T, Setupnewl2GPrecord, Rgp
    use MLSKinds, only: Rv
    use String_Table, only: Get_String
    use Toggles, only: Gen, Toggle, Levels
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decorate, Decoration
    use VectorsModule, only: VectorValue_T

    ! Dummy arguments
    integer, intent(in) :: KEY          ! spec_args to Decorate with the L2GP index
    integer, intent(in) :: NAME         ! For the swath
    type (VectorValue_T), intent(in) :: QUANTITY ! Vector quantity
    type (VectorValue_T), pointer :: precision ! Optional vector quantity
    type (L2GPData_T), dimension(:), pointer :: L2GPDATABASE
    integer, intent(in) :: CHUNKNO
    integer, intent(in), optional :: Firstinstance, Lastinstance
    !                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ! These two are set if only part (e.g. overlap regions) of the quantity
    ! is to be stored in the l2gp data.
    character(len=*), intent(in), optional :: nameString

    ! Local variables
    type (L2GPData_T) :: NewL2GP
    type (L2GPData_T), pointer :: ThisL2GP
    integer :: Indx
    integer :: FirstProfile, LastProfile ! Profile range in the l2gp to output to
    real(rv) :: HUGERGP
    integer :: Me = -1                   ! String index for trace
    integer :: NoSurfsInL2GP, NoFreqsInL2GP
    integer :: UseFirstInstance, UseLastInstance, NoOutputInstances
    logical :: L2gpDataIsNew
    character(len=64)         :: myNameString
   
    hugeRgp = real ( huge(0.0_rgp), rv )
    call trace_begin ( me, "JoinL2GPQuantities", key, &
      & cond=toggle(gen) .and. levels(gen) > 0 )

    ! If this is the first chunk, we have to setup the l2gp quantity from
    ! scratch.  Otherwise, we expand it and fill up our part of it.
    l2gpDataIsNew = (.not. associated(l2gpDatabase))
    if ( .not. l2gpDataIsNew ) then
      Indx = decoration(key)
      l2gpDataIsNew = (Indx>=0)
    end if

    ! Work out what to do with the first and last instance information
    
    if ( present(firstInstance) ) then
      useFirstInstance = firstInstance
    else
      useFirstInstance = quantity%template%noInstancesLowerOverlap+1
    end if

    if ( present(lastInstance) ) then
      useLastInstance = lastInstance
    else
      useLastInstance = quantity%template%noInstances- &
        & quantity%template%noInstancesUpperOverlap
    end if
    
    myNameString = ' '
    if ( present(NameString) ) myNameString = NameString

    noOutputInstances = useLastInstance-useFirstInstance+1
    ! If we've not been asked to output anything then don't carry on
    if ( noOutputInstances < 1 ) return

    if ( l2gpDataIsNew ) then
      ! Now create an empty L2GP record with this dimension

      if (any(quantity%template%verticalCoordinate == (/l_Pressure, l_Zeta /) )) then
        noSurfsInL2GP = quantity%template%noSurfs
      else
        noSurfsInL2GP = 0
      end if

      if ( quantity%template%frequencyCoordinate == l_None) then
         noFreqsInL2GP=0
      else
         noFreqsInL2GP=quantity%template%noChans
      end if

      call SetupNewL2GPRecord ( newL2GP, noFreqsInL2GP, noSurfsInL2GP )
      ! Setup the standard stuff, only pressure as it turns out.
      if ( quantity%template%verticalCoordinate == l_Pressure ) &
        & newL2GP%pressures = quantity%template%surfs(:,1)
      if ( quantity%template%verticalCoordinate == l_Zeta ) &
        & newL2GP%pressures = 10.0**(-quantity%template%surfs(:,1))
      ! It inherits its quantity type from the quantity template
      ! newL2GP%quantityType=quantity%template%quantityType
      ! Do something about frequency
      if ( associated ( quantity%template%frequencies ) ) then
        newL2GP%frequency = quantity%template%frequencies
      else
        newL2GP%frequency = 0.0
      end if

      ! We must choose a custom FillValue for GPH because
      ! -999.99 is a possibly legitimate value
      if ( quantity%template%QuantityType == l_gph .or. &
        & index( lowercase(myNameString), 'gph' ) > 0 ) &
        & newL2GP%MissingL2GP = L2Options%GPH_MissingValue
      ! Add it to the database of l2gp quantities
      Indx = AddL2GPToDatabase ( l2gpDatabase, newL2GP )
      ! Setup the pointer and index to be used later
      call decorate ( key, -Indx ) ! Remember where it is
      thisL2GP => l2gpDatabase(Indx)

    else
      ! Setup the index and pointer
      thisL2GP => l2gpDatabase(-Indx)
    end if

    ! Expand l2gp (initially all zero-size arrays) to take the new information
    call ExpandL2GPDataInPlace ( thisL2GP, &
      &thisL2GP%nTimes+noOutputInstances )
    thisL2GP%nTimesTotal = quantity%template%grandTotalInstances
    ! Now copy the information from the quantity to the l2gpData

    ! name is an integer, but L2GP%name is Character data
    thisL2GP%nameIndex = name
    if ( present(nameString) ) then
      thisL2GP%name = nameString
    else
      call Get_String( name, thisL2GP%name, strip=.true.)
    end if
    lastProfile=thisL2GP%nTimes
    firstProfile=lastProfile-noOutputInstances+1

    ! Now fill the data, first the geolocation
    thisL2GP%latitude(firstProfile:lastProfile) = &
      & quantity%template%geodLat(1,useFirstInstance:useLastInstance)
    thisL2GP%longitude(firstProfile:lastProfile) = &
      & quantity%template%lon(1,useFirstInstance:useLastInstance)
    thisL2GP%solarTime(firstProfile:lastProfile) = &
      & quantity%template%solarTime(1,useFirstInstance:useLastInstance)
    thisL2GP%solarZenith(firstProfile:lastProfile) = &
      & quantity%template%solarZenith(1,useFirstInstance:useLastInstance)
    thisL2GP%losAngle(firstProfile:lastProfile) = &
      & quantity%template%losAngle(1,useFirstInstance:useLastInstance)
    thisL2GP%geodAngle(firstProfile:lastProfile) = &
      & quantity%template%phi(1,useFirstInstance:useLastInstance)
    thisL2GP%time(firstProfile:lastProfile) = &
      & quantity%template%time(1,useFirstInstance:useLastInstance)
    thisL2GP%chunkNumber(firstProfile:lastProfile)=chunkNo

    ! Now the various data quantities.

    ! For v0.1 we're only thinking about value.  The precision will
    ! come from matrices later in 0.5, and the diagnostics such as status
    ! and quality will come later too (probably 0.5, but maybe 1.0)

    thisL2GP%l2gpValue(:,:,firstProfile:lastProfile) = &
      & reshape ( max ( -hugeRgp, min ( hugeRgp, &
      &   quantity%values(:,useFirstInstance:useLastInstance) ) ), &
      &  (/max(thisL2GP%nFreqs,1),max(thisL2GP%nLevels,1),lastProfile-firstProfile+1/))
    if (associated(precision)) then
      thisL2GP%l2gpPrecision(:,:,firstProfile:lastProfile) = &
        & reshape ( max ( -hugeRgp, min ( hugeRgp, &
        &   precision%values(:,useFirstInstance:useLastInstance) ) ), &
        &  (/max(thisL2GP%nFreqs,1),max(thisL2GP%nLevels,1),lastProfile-firstProfile+1/))
    else
      thisL2GP%l2gpPrecision(:,:,firstProfile:lastProfile) = 0.0
    end if
    thisL2GP%status(firstProfile:lastProfile)=0
    thisL2GP%quality(firstProfile:lastProfile)=0.0

    call trace_end ( "JoinL2GPQuantities", &
      & cond=toggle(gen) .and. levels(gen) > 0 )
  end subroutine JoinL2GPQuantities

  ! ----------------------------------------  JoinL2AUXQuantities  -----

  ! This subroutine is like the one above, except that the quantities it joins
  ! are destined to go in L2AUX quantities.

  subroutine JoinL2AUXQuantities ( key, name, quantity, l2auxDatabase, &
   & chunks, firstInstance, lastInstance )

    use Chunks_M, only: MLSChunk_T
    use Intrinsic, only: L_Geodangle, L_Maf
    use L2auxData, only: Addl2auxtoDatabase, Resizel2auxData, &
      & L2auxData_T, L2auxrank, Setupnewl2auxrecord
    use MLSKinds, only: R4, R8
    use MLSMessagemodule, only: MLSMSG_Error
    use Output_M, only: Output
    use String_Table, only: Display_String
    use Toggles, only: Gen, Toggle, Levels, Switches
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decorate, Decoration
    use VectorsModule, only: VectorValue_T

    ! Dummy arguments
    integer, intent(in) :: KEY     ! spec_args to decorate with the L2AUX index
    integer, intent(in) :: NAME    ! for the sd
    type (VectorValue_T), intent(in) :: quantity
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase
    type (MLSChunk_T), dimension(:), intent(in) :: chunks
    integer, intent(in), optional :: firstInstance, lastInstance
    ! The last two are set if only part (e.g. overlap regions) of the quantity
    ! is to be stored in the l2aux data.

    ! Local variables
    logical :: DEEBUG
    integer :: FIRSTMAF
    integer :: FIRSTPROFILE
    integer :: DB_INDEX
    integer :: LASTMAF
    integer :: LASTPROFILE
    integer :: MAF
    integer :: Me = -1             ! String index for trace
    integer :: NOMAFS
    integer :: NOOUTPUTINSTANCES
    integer :: USEFIRSTINSTANCE
    integer :: USELASTINSTANCE
    logical :: L2AUXDATAISNEW

    real(r8) :: HUGER4
    type (L2AUXData_T) :: NEWL2AUX
    type (L2AUXData_T), pointer :: THISL2AUX

    ! Executable code

    DEEBUG = ( switchDetail(switches, 'join') > -1 )
    call trace_begin ( me, "JoinL2AUXQuantities", key, &
      & cond=toggle(gen) .and. levels(gen) > 0 )

    hugeR4 = real ( huge(0.0_r4), r8 )

    if ( DEEBUG ) then
      call output('Joining vector quantity to L2AUX quantities', advance='yes')
      call output('minor frame? ', advance='no')
      call output(quantity%template%minorFrame, advance='no')
      call output('   major frame? ', advance='no')
      call output(quantity%template%majorFrame, advance='no')
      call output('   template  name ', advance='no')
      if ( quantity%template%name < 1 ) then
        call output('   (unnamed) ', advance='yes')
      else
        call display_string(quantity%template%name, strip=.true., advance='yes' )
      end if
    end if

    ! If this is the first chunk, we have to setup the l2aux quantity from
    ! scratch.  Otherwise, we expand it and fill up our part of it.
    l2auxDataIsNew = (.not. associated(l2auxDatabase))
    if ( .not. l2auxDataIsNew ) then
      db_index = decoration(key)
      l2auxDataIsNew = (db_index>=0)
    end if

    ! Work out what to do with the first and last Instance information
    if ( present(firstInstance) ) then
      useFirstInstance = firstInstance
    else
      useFirstInstance = quantity%template%noInstancesLowerOverlap+1
    end if
    if ( present(lastInstance) ) then
      useLastInstance = lastInstance
    else
      useLastInstance = quantity%template%noInstances- &
        & quantity%template%noInstancesUpperOverlap
    end if
    noOutputInstances = useLastInstance - useFirstInstance + 1

    ! If we've not been asked to output anything then don't carry on
    if ( noOutputInstances < 1 ) return

    if ( DEEBUG ) then
      call output('Joining L2Aux quantity with ', advance='no')
      call output(noOutputInstances, advance='no')
      call output(' instances ', advance='yes')
    end if

    ! Now if this is a new l2aux quantity, we need to setup an l2aux data type
    ! for it.
    if ( l2auxDataIsNew ) then
      ! We need to setup the quantity.  In some cases (minor/major frame)
      ! we can tell how big it is going to be.  Otherwise, create it empty
      if ( any ((/ quantity%template%minorFrame, quantity%template%majorFrame /)) ) then
        firstMAF = minval ( chunks%firstMAFIndex )
        lastMAF = maxval ( chunks%lastMAFIndex )
        noMAFs = lastMAF - firstMAF + 1
        if ( DEEBUG ) then
          call output('  firstMAF ', advance='no')
          call output(firstMAF, advance='no')
          call output('  noMAFs ', advance='no')
          call output(noMAFs, advance='yes')
        end if
      else
        ! Otherwise, we don't know how big it will be (at least in the Join
        ! scenario), so create it empty to begin with.
        firstMAF = 1
        noMAFs = 0
      end if
      ! Create the record accordingly
      call SetupNewL2AUXRecord ( newL2AUX, quantity%template, firstMAF, noMAFs )
      newL2AUX%instrumentModule=quantity%template%instrumentModule
      newL2AUX%quantityType=quantity%template%quantityType

      ! Add this l2aux to the database
      db_index = AddL2AUXToDatabase ( l2auxDatabase, newL2AUX )

      ! Setup the pointer and the index to be used later
      call decorate ( key, -db_index ) ! Remember where it is
      thisL2AUX => l2auxDatabase(db_index)
      thisL2AUX%name = name
    else
      ! Not a new l2aux, so just point ourselves to the old one.
      thisL2AUX => l2auxDatabase(-db_index)
    end if

    ! OK, now thisL2AUX points to an appropriate l2aux to fill, be it newly created,
    ! or old, and be it big enough or not.
    ! First, do we need to expand this?
    if ( .not. any ((/ quantity%template%minorFrame, quantity%template%majorFrame /)) ) then
      ! We need to expand this L2AUX to fit in the latest data.
      call ResizeL2AUXData ( thisL2AUX, noOutputInstances )
    end if

    if ( quantity%template%minorFrame .or. quantity%template%majorFrame ) then
      ! Don't forget instanceOffset is for the first non-overlapped instance (ie MAF)
      ! Also remember the L2AUX data is already indexed from zero! Great!
      if (DEEBUG) call output ( "Doing the special calculation of first/last profile", advance='yes' )
      lastProfile = quantity%template%instanceOffset + quantity%template%noInstances - &
        & quantity%template%noInstancesUpperOverlap - &
        & quantity%template%noInstancesLowerOverlap - 1
    else
      lastProfile = thisL2AUX%dimensions(L2AUXRank)%noValues
    end if
    firstProfile = lastProfile - noOutputInstances + 1

    if ( DEEBUG ) then
      call output('  instance offset ' )
      call output( quantity%template%instanceOffset, advance='yes' )
      call output('  firstProfile ', advance='no')
      call output(firstProfile, advance='no')
      call output('   lastProfile ', advance='no')
      call output(lastProfile, advance='yes')
      call output('  FirstInstance ', advance='no')
      call output(useFirstInstance, advance='no')
      call output('   LastInstance ', advance='no')
      call output(useLastInstance, advance='yes')
      call output('  L2AUX%dimensions ', advance='no')
      call output(trim(thisL2AUX%dim_names), advance='yes')
      call output('  L2AUX%dim_units ', advance='no')
      call output(trim(thisL2AUX%dim_units), advance='yes')
      call output('  L2AUX%value_units ', advance='no')
      call output(trim(thisL2AUX%value_units), advance='yes')
      call output('  L2AUX%dimensions(1)%noValues ', advance='no')
      call output(thisL2AUX%dimensions(1)%noValues, advance='no')
      call output('  L2AUX%dimensions(2)%noValues ', advance='no')
      call output(thisL2AUX%dimensions(2)%noValues, advance='no')
      call output('  L2AUX%dimensions(3)%noValues ', advance='no')
      call output(thisL2AUX%dimensions(3)%noValues, advance='yes')
      call output('shape(l2aux values) ', advance='no')
      call output(shape(thisL2AUX%values), advance='yes')
      if ( any ( thisL2AUX%dimensions(L2AUXRank)%dimensionFamily &
        & == (/ L_GeodAngle, L_MAF /) ) ) then
        call output('   dimensions ', advance='no')
        call output(size(thisL2AUX%dimensions(L2AUXRank)%values), advance='no')
      else
        call output(' (dimensions unassociated)', advance='no')
      end if
      call output('   values 3rd coord ', advance='no')
      call output(size(thisL2AUX%values(1,1,:)), advance='yes')
    end if

    select case (thisL2AUX%dimensions(L2AUXRank)%dimensionFamily)
    case ( L_GeodAngle )
      thisL2AUX%dimensions(L2AUXRank)%values(firstProfile:lastProfile)=&
        & quantity%template%phi(1,useFirstInstance:useLastInstance)
    case ( L_MAF )
      do maf = firstProfile, lastProfile
        thisL2AUX%dimensions(L2AUXRank)%values(maf) = maf
      end do
    case default
    end select
    
    ! Check that reshape has a prayer of succeeding
    if ( DEEBUG ) then
      call output('  num l2aux values/profile ', advance='no')
      call output(size(thisL2AUX%values, 1)*size(thisL2AUX%values, 2), &
       & advance='yes')
      call output('   num dim values/profile ', advance='no')
      call output(thisL2AUX%dimensions(1)%noValues* &
       &              thisL2AUX%dimensions(2)%noValues, advance='yes')
      call output('  num l2aux values (total) ', advance='no')
      call output(size(thisL2AUX%values, 1)*size(thisL2AUX%values, 2)* &
       &              (lastProfile-firstProfile+1), advance='yes')
      call output('   num qty values ', advance='no')
      call output(size(quantity%values, 1)* &
       &              (useLastInstance-useFirstInstance+1), advance='yes')
    end if
    if ( size(thisL2AUX%values, 1)*size(thisL2AUX%values, 2) &
     & /= thisL2AUX%dimensions(1)%noValues*thisL2AUX%dimensions(2)%noValues ) &
     & call MLSL2Message ( MLSMSG_Error, &
     & ModuleName, "Reshape fails: size mismatch betw. dims and values" )
    if ( size(thisL2AUX%values, 1)*size(thisL2AUX%values, 2)*(lastProfile-firstProfile+1) &
     & /= size(quantity%values, 1)*(useLastInstance-useFirstInstance+1) ) &
     & call MLSL2Message ( MLSMSG_Error, &
     & ModuleName, "Reshape fails: size mismatch betw. quantity and l2aux" )
    thisL2AUX%values(:,:,firstProfile:lastProfile) = &
      & reshape ( max ( -hugeR4, min ( hugeR4, &
      & quantity%values(:,useFirstInstance:useLastInstance) ) ), &
      &   (/ thisL2AUX%dimensions(1)%noValues, &
      &      thisL2AUX%dimensions(2)%noValues, &
      &      lastProfile-firstProfile+1/) )
    
    call trace_end ( "JoinL2AUXQuantities", &
      & cond=toggle(gen) .and. levels(gen) > 0 )

  end subroutine JoinL2AUXQuantities

! =====     Private Procedures     =====================================

  function explicitFile ( node ) result ( gotTheFile )
    ! Loop overs fields in DirectWrite command to discover whether
    ! the file is explicitly named
    use Init_Tables_Module, only: F_File
    use Moretree, only: Get_Field_Id
    use Tree, only: Nsons, Subtree
    ! Args
    integer, intent(in) :: node
    logical :: gotTheFile
    ! Private variables
    integer :: keyNo
    integer :: fieldIndex
    integer :: son
    ! Executable
    gotTheFile = .false.
    do keyNo = 2, nsons(node)           ! Skip DirectWrite command
      son = subtree ( keyNo, node )
      fieldIndex = get_field_id ( son )
      select case ( fieldIndex )
      case ( f_file )
        gotTheFile = .true.
      end select
    end do
  end function explicitFile

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Join.f90,v 2.190 2020/02/13 21:28:04 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Join

!
! $Log: Join.f90,v $
! Revision 2.190  2020/02/13 21:28:04  pwagner
! Fix errors relating to separate MissingValue for GPH
!
! Revision 2.189  2020/02/07 01:12:10  pwagner
! Commented-out unused stuff
!
! Revision 2.188  2019/02/13 19:15:46  pwagner
! Removed more unused stuff
!
! Revision 2.187  2019/02/13 17:29:33  pwagner
! New GPH_MissingValue field of L2Options can now be st to a value other than default -999.99
!
! Revision 2.186  2018/07/27 23:18:48  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.185  2018/04/16 22:21:41  pwagner
! Improved how we DirectWrite plain hdf files
!
! Revision 2.184  2018/04/13 00:19:51  pwagner
! Plain hdf DirectWrites and -Reads are now 'auto'
!
! Revision 2.183  2018/02/09 00:56:16  pwagner
! repaired bug that left PCBottom, PCTop undefined
!
! Revision 2.182  2018/01/12 00:19:37  pwagner
! Reorganized DirectWriteCommand; now Uses JoinUtils_1
!
! Revision 2.181  2017/12/07 01:01:23  vsnyder
! Don't use host-associated variable as a DO index
!
! Revision 2.180  2017/08/03 21:41:04  pwagner
! Split MLSL2Join into calls to 2 internal procedures; fix problem of not doing DirecWrites if section contains Dump, /stop
!
! Revision 2.179  2017/07/27 17:03:53  pwagner
! DirectWrite-ing an entire vector may put it under a named group
!
! Revision 2.178  2016/11/08 17:34:15  pwagner
! Use SayTime subroutine from time_m module; process /reset field
!
! Revision 2.177  2016/11/01 17:44:40  pwagner
! Fixed error in getting directFile to ignore_paths or not
!
! Revision 2.176  2016/09/07 22:47:12  pwagner
! Removed unused QuantityType component from L2GPData type
!
! Revision 2.175  2016/07/28 01:43:51  vsnyder
! Remove unreferenced USE
!
! Revision 2.174  2016/05/18 01:37:30  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.173  2016/04/01 00:27:15  pwagner
! May now Execute a single command or a script of lines from l2cf
!
! Revision 2.172  2016/02/29 19:49:49  pwagner
! Usleep got from machine module instead of being an external
!
! Revision 2.171  2015/10/06 00:26:37  pwagner
! magneticField belongs in type=quantity DirectWrite file
!
! Revision 2.170  2015/09/17 23:24:30  pwagner
! Passes Max chunk size for l2gp DirectWrites
!
! Revision 2.169  2015/09/10 17:49:19  pwagner
! Verbose now times DirectWrites
!
! Revision 2.168  2015/08/25 21:56:34  pwagner
! Had failed to give prefixSignal a default value; now FALSE
!
! Revision 2.167  2015/07/15 17:09:05  pwagner
! Fixed some bugs related to label field in DirectWWrite commands
!
! Revision 2.166  2015/07/14 23:31:16  pwagner
! label and inputFile fields in DirectWrite
!
! Revision 2.165  2015/05/05 16:47:25  pwagner
! /noPCFid allows us to DirectWrite to files not named in PCF
!
! Revision 2.164  2015/04/07 02:53:50  vsnyder
! Correct error message about units for RANK, some cannonball polishing
!
! Revision 2.163  2015/03/31 21:01:07  pwagner
! rank is a new field for DirectWrite-ing quantity values as, say, rank3
!
! Revision 2.162  2015/03/28 02:47:14  vsnyder
! Paul added Quantity type to Direct write.
!
! Revision 2.161  2014/04/07 18:03:28  pwagner
! May specify AscDescMode when DirectWrite-ing swaths
!
! Revision 2.160  2014/03/31 23:43:49  pwagner
! Commented-out unused stuff; renamed procedure ResizeL2AUXData, generalizing it to expand or contract
!
! Revision 2.159  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.158  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.157  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.156  2013/11/01 00:15:15  pwagner
! Match trace_begins and _ends scrupulously
!
! Revision 2.155  2013/10/09 23:41:36  vsnyder
! Add Evaluate_Variable
!
! Revision 2.154  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.153  2013/09/04 17:35:23  pwagner
! Replaced '--cat' cmdline option; 'Catenate' now an Output section command
!
! Revision 2.152  2013/08/30 02:45:42  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.151  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.150  2012/08/16 17:58:24  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.149  2012/07/02 20:40:43  pwagner
! Once-routine output now requires verbosity > 0
!
! Revision 2.148  2012/05/08 17:51:11  pwagner
! Added Select .. Case .. EndSelect control structure
!
! Revision 2.147  2012/05/01 23:16:35  pwagner
! Partly retreated from last optimistic commit
!
! Revision 2.146  2012/03/12 17:22:20  pwagner
! Believe we can drop odious workaround for hdfeos 'bug'--may have been our mistake
!
! Revision 2.145  2012/02/24 21:19:44  pwagner
! May DirectWrite a /single instance only
!
! Revision 2.144  2011/11/04 00:09:53  pwagner
! Fixed bug that prevented writing matched output types
!
! Revision 2.143  2011/10/07 00:06:02  pwagner
! May dump Matrices, Hessians from Fill, Join
!
! Revision 2.142  2011/05/09 18:18:45  pwagner
! Consistent with new api for DirectWrite
!
! Revision 2.141  2009/10/26 17:11:53  pwagner
! Added Diff command to be used like Dump in l2cf
!
! Revision 2.140  2009/09/29 23:40:45  pwagner
! Unjam error message when DirectWrite type is unexpected
!
! Revision 2.139  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.138  2009/06/02 17:53:15  cvuu
! Add NRT Lat and Lon bounding to metadata
!
! Revision 2.137  2009/04/23 23:02:25  pwagner
! May specify upperOverlap or lowerOverlap in DirectWrites
!
! Revision 2.136  2009/04/01 23:35:59  pwagner
! First attempt at fixing bug that wrote missing values to Temperature-APriori
!
! Revision 2.135  2008/12/18 21:14:24  pwagner
! May now dump an l2pc or allL2PCs (use with caution)
!
! Revision 2.134  2008/12/02 23:27:09  pwagner
! May automatically label every quantity in a vector now
!
! Revision 2.133  2007/12/07 01:50:52  pwagner
! Removed unused dummy variables, etc.
!
! Revision 2.132  2007/11/05 18:37:19  pwagner
! May Skip remaining lines in Fill, Join, Retrieve sections depending on Boolean
!
! Revision 2.131  2007/06/21 00:54:08  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.130  2006/10/11 22:58:00  pwagner
! Will write convergence ratio as another quality-like field of l2gp
!
! Revision 2.129  2006/09/21 18:55:04  pwagner
! Fixed bug causing freezes when band13 off; cosmetic changes too
!
! Revision 2.128  2006/06/21 22:06:56  pwagner
! Downgraded inappropriate quantity output to warning mesg
!
! Revision 2.127  2006/04/11 23:34:27  pwagner
! Fixed bug which added excess profiles
!
! Revision 2.126  2006/03/04 00:20:13  pwagner
! Account for directdatabase even if skipping directWrites
!
! Revision 2.125  2006/02/10 21:17:33  pwagner
! dumps may go to special dumpfile
!
! Revision 2.124  2005/11/11 21:47:08  pwagner
! May have fixed bugs Besetting Alyn and Dong
!
! Revision 2.123  2005/11/04 18:54:04  pwagner
! Accommodates changed interface to add_metadata
!
! Revision 2.122  2005/10/28 23:17:37  pwagner
! Print missing outputType when unable to find suitable for distributing sources
!
! Revision 2.121  2005/10/18 23:11:36  pwagner
! Fixed bug causing standalone, toolkitless run to put split dgg/dgm files in cwd
!
! Revision 2.120  2005/06/22 18:57:01  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.119  2005/06/16 18:43:01  pwagner
! Should not bomb if catenating split files w/o toolkit
!
! Revision 2.118  2005/06/14 20:43:19  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.117  2005/03/24 21:31:55  pwagner
! May warn of unreasonable directWrite waiting, writing times
!
! Revision 2.116  2004/12/14 22:51:35  pwagner
! Changes related to stopping early
!
! Revision 2.115  2004/07/22 20:49:58  cvuu
! Add forwardModelConfigDatabase to the call MLSL2Join and MLSL2Fill
!
! Revision 2.114  2004/06/10 00:58:45  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.113  2004/05/19 20:16:29  vsnyder
! Remove declarations and uses for unreferenced symbols, polish some cannonballs
!
! Revision 2.112  2004/05/19 19:16:10  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.111  2004/04/27 23:56:17  pwagner
! SKIPDIRECTWRITES acts much like checkpaaths
!
! Revision 2.110  2004/04/24 00:21:33  pwagner
! Bombs less readily when not a slave
!
! Revision 2.109  2004/04/17 07:00:54  livesey
! Bug fix possibly?
!
! Revision 2.108  2004/03/03 19:28:04  pwagner
! Should not add metadata if dgg/dgm to be unsplit
!
! Revision 2.107  2004/02/19 23:56:23  pwagner
! Fixed tiny memory leak; skipdgg/m skips directwrite of filetype
!
! Revision 2.106  2004/02/11 23:11:38  livesey
! Logic wrong in calls to DoHGridsMatch
!
! Revision 2.105  2004/02/11 17:21:51  pwagner
! May DirectWrite l2gp status and quality quantities
!
! Revision 2.104  2004/02/10 19:28:36  pwagner
! Prevents named DirectWrites from being looped over
!
! Revision 2.103  2004/02/05 23:40:35  pwagner
! More bugs fixed in automatic directwrites
!
! Revision 2.102  2004/01/23 01:09:48  pwagner
! Only directwrite files entered in global settings eligible to be auto-sourced
!
! Revision 2.101  2004/01/22 00:56:35  pwagner
! Fixed many bugs in auto-distribution of DirectWrites
!
! Revision 2.100  2004/01/02 23:36:00  pwagner
! DirectWrites may choose files automatically from db
!
! Revision 2.99  2003/12/05 00:41:14  pwagner
! patch option avoids deleting existing data in file
!
! Revision 2.98  2003/12/03 17:50:54  pwagner
! L2GP tracks both nTimes (for this slave) and nTimesTotal (done by all)
!
! Revision 2.97  2003/11/14 23:38:45  pwagner
! Uses DirectWrite databse in preference to repeated calls to toolkit
!
! Revision 2.96  2003/11/07 00:46:51  pwagner
! New quicker preflight option: --checkPaths
!
! Revision 2.95  2003/10/20 18:21:45  pwagner
! Timings breakdown added for directWrite
!
! Revision 2.94  2003/10/10 00:00:24  pwagner
! Should quit properly if SIPS and no PCFid match for file name
!
! Revision 2.93  2003/09/12 21:45:52  pwagner
! Only prints l2gp label during DirectWrite if DEEBUG
!
! Revision 2.92  2003/09/04 22:40:04  pwagner
! Gets dgg file name from dgg PCFid when DirectWrite usingPCF
!
! Revision 2.91  2003/09/03 23:05:49  livesey
! More problems with precision in DirectWrite, hope I've got them all now.
!
! Revision 2.90  2003/09/03 00:53:50  livesey
! Bug fix on directWrite, it was storing the value field in the precision
! too!
!
! Revision 2.89  2003/08/28 23:51:58  livesey
! Renamed some variables to make them more obvious
!
! Revision 2.88  2003/08/14 20:11:30  pwagner
! DirectWrite may take l2fwm types for fwm radiances
!
! Revision 2.87  2003/08/01 20:38:31  pwagner
! Distinguishes between l2dgg and l2gp when writing metadata as part of directwrite
!
! Revision 2.86  2003/07/25 00:51:06  livesey
! Added file type l2dgg to support metadata.
!
! Revision 2.85  2003/07/23 18:30:35  cvuu
! reduce routine printing
!
! Revision 2.84  2003/07/15 23:39:01  pwagner
! Disabled most printing
!
! Revision 2.83  2003/07/11 01:24:20  livesey
! More changes trying to get the direct write going.
!
! Revision 2.82  2003/07/09 21:49:53  pwagner
! Tries to figure out in advance whether to create swath
!
! Revision 2.81  2003/07/08 00:15:51  livesey
! Various tidy ups and reworks
!
! Revision 2.80  2003/07/07 23:52:13  pwagner
! Slave that creates DirectWrite file may also add_metadata
!
! Revision 2.79  2003/07/07 20:29:43  livesey
! Mainly cosmetic changes
!
! Revision 2.78  2003/07/07 17:31:11  livesey
! Various things to get DirectWrite working
!
! Revision 2.77  2003/07/02 00:55:27  pwagner
! Some improvements in DirectWrites of l2aux, l2gp
!
! Revision 2.76  2003/06/26 23:13:52  pwagner
! New debugging output; distinguishes between l2gp/l2aux quantities better
!
! Revision 2.75  2003/06/24 23:54:07  pwagner
! New db indexes stored for entire direct file
!
! Revision 2.74  2003/06/24 23:30:00  livesey
! Finished LabelVectorQuantity and made some other bug fixes.
!
! Revision 2.73  2003/06/23 23:55:17  pwagner
! Added DirectData_T to keep track of data written directly
!
! Revision 2.72  2003/06/20 19:38:25  pwagner
! Allows direct writing of output products
!
! Revision 2.71  2003/05/30 00:09:27  livesey
! Can now directWrite major frame quantities
!
! Revision 2.70  2003/05/12 02:06:23  livesey
! Bug fix for prefixSignal L2GPs and also bound r8->r4 conversion
!
! Revision 2.69  2003/02/08 00:31:31  pwagner
! Now saves quantityType in newl2gp
!
! Revision 2.68  2003/01/30 01:03:24  pwagner
! Stores quantity type taken from source vector in l2aux
!
! Revision 2.67  2003/01/17 23:11:26  pwagner
! Moved most ops out of LoinL2AUXData to SetupL2AUXData
!
! Revision 2.66  2002/12/19 15:53:47  livesey
! Allowed verticalCoordinate=l_none quantities back into the l2gp fold.
!
! Revision 2.65  2002/11/26 23:38:01  livesey
! Better joining of major frame quantities
!
! Revision 2.64  2002/10/29 21:54:21  livesey
! Made join less verbose.
!
! Revision 2.63  2002/10/08 17:36:21  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.62  2002/08/20 22:10:50  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.61  2002/08/20 20:10:30  livesey
! Dealt with frequency in l2gps
!
! Revision 2.60  2002/05/28 17:09:57  livesey
! Removed print statements
!
! Revision 2.59  2002/05/22 00:48:52  livesey
! Added direct write stuff
!
! Revision 2.58  2002/05/16 22:36:46  livesey
! Fixed a bug with joining minor frame quantities with overlaps.
!
! Revision 2.57  2002/04/08 20:49:17  pwagner
! Swath name optionally passed to JoinL2GPQuantities
!
! Revision 2.56  2002/04/06 00:35:21  pwagner
! Should accept actual case of swathname for l2gp
!
! Revision 2.55  2002/03/20 00:46:47  pwagner
! Removed 2 unused lits
!
! Revision 2.54  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.53  2001/10/30 01:45:21  livesey
! Some modifications/fixes to parallel join
!
! Revision 2.52  2001/10/08 23:38:58  pwagner
! Tiny fixes; not perfect yet
!
! Revision 2.51  2001/10/06 00:27:42  pwagner
! Still some problems with diagnostics
!
! Revision 2.50  2001/09/28 23:59:20  pwagner
! Fixed various timing problems
!
! Revision 2.49  2001/09/28 17:50:30  pwagner
! MLSL2Timings module keeps timing info
!
! Revision 2.48  2001/09/08 00:21:44  pwagner
! Revised to work for new column Abundance in lone swaths
!
! Revision 2.47  2001/09/05 20:34:56  pwagner
! Reverted to pre-columnAbundance state
!
! Revision 2.46  2001/08/03 23:13:52  pwagner
! Began testing; at least now exits normally again
!
! Revision 2.45  2001/08/02 23:58:31  pwagner
! More complete treatment of column abundance(s)
!
! Revision 2.44  2001/08/02 00:18:55  pwagner
! Began adding column quantities; incomplete
!
! Revision 2.43  2001/07/31 23:25:32  pwagner
! Able to accept 2 new fields for join of column; does nothing yet
!
! Revision 2.42  2001/06/19 22:52:31  pwagner
! l_none  no longer got from init_tables_module
!
! Revision 2.41  2001/05/23 21:59:43  livesey
! Interim version, almost there
!
! Revision 2.40  2001/05/23 01:43:19  livesey
! New parallel version in progress
!
! Revision 2.39  2001/05/19 01:19:58  livesey
! Fills precision correctly for l2gp!
!
! Revision 2.38  2001/05/14 22:23:53  livesey
! Embarassing bug fix, to do with renumbering of minor frame L2AUX quantities.
!
! Revision 2.37  2001/05/12 00:18:17  livesey
! Tidied up array bounds for L2AUX/MAF.
!
! Revision 2.36  2001/05/10 16:31:24  livesey
! Added prefix signal option for swath/sd name
!
! Revision 2.35  2001/05/08 23:25:32  livesey
! Added the precision stuff for l2gp's
!
! Revision 2.34  2001/05/08 21:51:02  livesey
! Removed some old xStar, yStar, kStar stuff.
!
! Revision 2.33  2001/05/03 20:32:19  vsnyder
! Cosmetic changes
!
! Revision 2.32  2001/05/02 22:22:43  pwagner
! Removed SDPToolkit use
!
! Revision 2.31  2001/04/28 01:30:14  livesey
! Basically gone back to an earlier version.  As l2pc's now output
! directly as matrices there is no need for Join to think about them.
!
! Revision 2.30  2001/04/27 21:52:39  livesey
! Removed l2pc stuff
!
! Revision 2.29  2001/04/26 20:02:09  livesey
! Made l2pc database a saved array in L2PC_m
!
! Revision 2.28  2001/04/26 15:59:30  livesey
! Tidied up uses
!
! Revision 2.27  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.26  2001/04/26 00:07:16  livesey
! Insulate vector is gone
!
! Revision 2.25  2001/04/25 21:54:22  livesey
! Added candol2pc flag
!
! Revision 2.24  2001/04/25 21:51:46  livesey
! Tidied up Join for l2pcs
!
! Revision 2.23  2001/04/25 20:33:28  livesey
! Minor improvements to Join l2pc stuff
!
! Revision 2.22  2001/04/24 20:20:27  livesey
! L2PC moved to lib and word bin dropped from types etc.
!
! Revision 2.21  2001/04/24 20:04:54  livesey
! Added l2pc joining
!
! Revision 2.20  2001/04/10 23:44:44  vsnyder
! Improve 'dump'
!
! Revision 2.19  2001/03/15 23:26:56  livesey
! Avoid calling ExpandL2AUXQuantitiesInPlace for minor frame quantities.
! Really saves on memory thrashing.
!
! Revision 2.18  2001/03/15 21:18:57  vsnyder
! Use Get_Spec_ID instead of decoration(subtree...
!
! Revision 2.17  2001/03/06 22:40:41  livesey
! New L2AUX stuff
!
! Revision 2.16  2001/03/05 20:46:41  livesey
! Removed a debugging statement left behind
!
! Revision 2.15  2001/03/05 01:19:45  livesey
! Removed a print statement
!
! Revision 2.14  2001/03/05 01:01:12  livesey
! Bug fix, now uses GetVectorQtyFromTemplateIndex
!
! Revision 2.13  2001/03/01 18:38:27  livesey
! Fixed bug with verticalCoordinate==l_Zeta
!
! Revision 2.12  2001/02/27 17:38:21  livesey
! Tidied things up, removed unnecessary arguments
!
! Revision 2.11  2001/02/27 00:50:31  livesey
! Added ability to Join verticalCoordinate=l_zeta quantities into l2gp entities.
!
! Revision 2.10  2001/02/16 00:50:17  livesey
! Added error to avoid confusion with L2GP in ReadApriori section
!
! Revision 2.9  2001/02/09 19:30:16  vsnyder
! Move checking for required and duplicate fields to init_tables_module
!
! Revision 2.8  2001/02/09 18:01:46  livesey
! Various further updates, set default values for status and quality
!
! Revision 2.7  2001/02/09 00:38:22  livesey
! Various updates
!
! Revision 2.6  2001/01/03 18:15:13  pwagner
! Changed types of t1, t2 to real
!
! Revision 2.5  2000/11/16 02:19:01  vsnyder
! Implement timing.
!
! Revision 2.4  2000/11/13 23:02:21  pwagner
! Adapted for rank2 vectorsModule
!
! Revision 2.3  2000/10/05 16:37:19  pwagner
! Now compiles with new L2GPData module
!
! Revision 2.2  2000/09/11 19:34:35  ahanzel
! Removed old log entries in file.
!
! Revision 2.1  2000/09/08 22:55:56  vsnyder
! Revised to use the tree output by the parser
!

@


2.190
log
@Fix errors relating to separate MissingValue for GPH
@
text
@a1218 3
      ! The following do not yet have heir own PCFid ranges assigned to them
      ! If they become used routinely in std or nrt processing, this
      ! should be done
d1223 5
d1256 1
a1256 1
          & chunkNo, createFileFlag, createthisswath, &
d1268 1
a1268 1
          & chunkNo, createFileFlag, createthisswath, &
d2161 1
a2161 1
       "$Id: Join.f90,v 2.189 2020/02/07 01:12:10 pwagner Exp $"
d2172 3
@


2.189
log
@Commented-out unused stuff
@
text
@d1816 1
a1816 1
        & newL2GP%MissingValue = L2Options%GPH_MissingValue
d2159 1
a2159 1
       "$Id: Join.f90,v 2.188 2019/02/13 19:15:46 pwagner Exp $"
d2170 3
@


2.188
log
@Removed more unused stuff
@
text
@d614 2
a615 2
    integer :: AscDescModeVECTOR
    integer :: AscDescModeQTYINDX
d648 1
a648 1
    type(VectorValue_T), pointer :: AscDescModeQTY ! The shared quantity AscDescMode
d710 2
a711 2
        AscDescModeVector = decoration(decoration(subtree(1,gson)))
        AscDescModeQtyIndx = decoration(decoration(decoration(subtree(2,gson))))
d884 3
a886 3
      nullify ( AscDescModeQty )
      if ( got(f_AscDescMode) ) AscDescModeQty => GetVectorQtyByTemplateIndex ( vectors(AscDescModevector), &
      & AscDescModeQtyIndx )
d2159 1
a2159 1
       "$Id: Join.f90,v 2.187 2019/02/13 17:29:33 pwagner Exp $"
d2170 3
@


2.187
log
@New GPH_MissingValue field of L2Options can now be st to a value other than default -999.99
@
text
@d524 1
a524 1
      & MLS_OpenFile, Split_Path_Name
d529 1
a529 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d650 1
a650 1
    real :: TimeIn, TimeSetUp, TimeWriting, timeToClose, TimeOut
a662 2
    TimeSetUp = TimeIn
    TimeWriting = TimeIn
d1537 1
a1537 2
    ! use MLSKinds, only: R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d1899 1
a1899 1
    use MLSMessagemodule, only: MLSMessage, MLSMSG_Error
d2159 1
a2159 1
       "$Id: Join.f90,v 2.186 2018/07/27 23:18:48 pwagner Exp $"
d2170 3
@


2.186
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d17 1
a17 1
  use MLSL2Options, only: CheckPaths, L2CFNode, &
d1716 1
a1716 1
    use Intrinsic, only: L_None
d1733 4
a1736 1
    integer, intent(in), optional :: FIRSTINSTANCE, LASTINSTANCE
a1737 2
    ! The last two are set if only part (e.g. overlap regions) of the quantity
    ! is to be stored in the l2gp data.
d1742 1
a1742 1
    integer :: Index
d1749 1
d1759 2
a1760 2
      index = decoration(key)
      l2gpDataIsNew = (index>=0)
d1777 3
d1815 5
d1821 1
a1821 1
      index = AddL2GPToDatabase ( l2gpDatabase, newL2GP )
d1823 2
a1824 2
      call decorate ( key, -index ) ! Remember where it is
      thisL2GP => l2gpDatabase(index)
d1828 1
a1828 1
      thisL2GP => l2gpDatabase(-index)
d2162 1
a2162 1
       "$Id: Join.f90,v 2.185 2018/04/16 22:21:41 pwagner Exp $"
d2173 3
@


2.185
log
@Improved how we DirectWrite plain hdf files
@
text
@d16 3
a20 1
  use JoinUtils_1, only: Error, Announce_Error, DWSwath, DWHDF, DWQty
a78 2
   use MLSL2Options, only: CheckPaths, L2CFNode, &
     & SkipDirectWrites, SpecialDumpFile, MLSMessage
d171 1
a171 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Error in Join section' )
d385 1
a385 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d1043 1
a1043 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1050 1
a1050 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1065 1
a1065 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d1078 1
a1078 1
          if ( noCreatedFiles > maxFiles ) call MLSMessage ( &
d1087 1
a1087 1
          if ( noCreatedFiles > maxFiles ) call MLSMessage ( &
d1109 1
a1109 1
          call MLSMessage( MLSMSG_Error, ModuleName, &
d1146 1
a1146 1
         call MLSMessage ( &
d1157 1
a1157 1
        call MLSMessage( MLSMSG_Error, ModuleName, &
d1190 1
a1190 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d1238 1
a1238 1
        if(DEEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1344 1
a1344 1
      if ( size(DirectDataBase) < 1 ) call MLSMessage ( &
d1359 1
a1359 1
        call MLSMessage ( &
d1636 1
a1636 1
    if ( error /= 0 ) call MLSMessage ( MLSMSG_Error, &
d1677 2
a1678 2
          call MLSMessage ( MLSMSG_Error,&
            & ModuleName, 'This quantity should be joined as an l2gp')
d1687 2
a1688 2
          call MLSMessage ( MLSMSG_Error,&
            & ModuleName, 'This quantity should be joined as an l2aux')
d2104 1
a2104 1
     & call MLSMessage ( MLSMSG_Error, &
d2108 1
a2108 1
     & call MLSMessage ( MLSMSG_Error, &
d2152 1
a2152 1
       "$Id: Join.f90,v 2.184 2018/04/13 00:19:51 pwagner Exp $"
d2163 3
@


2.184
log
@Plain hdf DirectWrites and -Reads are now 'auto'
@
text
@d530 4
a533 3
    use MLSPCF2, only: MLSPCF_L2gp_Start, MLSPCF_L2gp_End, &
      & MLSPCF_L2dgm_Start, MLSPCF_L2dgm_End, MLSPCF_L2fwm_Full_Start, &
      & MLSPCF_L2fwm_Full_End, &
a657 1
    DEEBUG = .true.
d771 4
a774 2
    call outputNamedValue ( 'filename', trim(filename) )
    call outputNamedValue ( 'distributingSources', distributingSources )
d1228 4
d2152 1
a2152 1
       "$Id: Join.f90,v 2.183 2018/02/09 00:56:16 pwagner Exp $"
d2163 3
@


2.183
log
@repaired bug that left PCBottom, PCTop undefined
@
text
@d278 7
d291 1
a291 1
              if(DEEBUG)print*,'Calling DirectWrite, not slave'
d307 1
d425 1
d652 1
d657 1
d771 2
d1249 10
a1258 10
    & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
    & chunkNo, createFileFlag, createthisswath, lowerOverlap, upperOverlap, &
    & NoCreatedFiles, &
    & sourceVectors, sourceQuantities, &
    & precisionVectors, precisionQuantities, &
    & qualityVectors, qualityQuantities, &
    & statusVectors, statusQuantities, &
    & convergVectors, convergQuantities, &
    & vectors, DirectDatabase, directfiles, &
    & directfile, thisDirect )
d1261 10
a1270 10
    & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
    & chunkNo, createFileFlag, createthisswath, lowerOverlap, upperOverlap, &
    & NoCreatedFiles, &
    & sourceVectors, sourceQuantities, &
    & precisionVectors, precisionQuantities, &
    & qualityVectors, qualityQuantities, &
    & statusVectors, statusQuantities, &
    & convergVectors, convergQuantities, &
    & vectors, DirectDatabase, directfiles, &
    & directfile, thisDirect )
d1274 2
a1275 1
          call OutputNamedValue ( 'NoCreatedFiles before DWHDF', NoCreatedFiles )
d1278 19
a1296 9
    & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
    & chunkNo, createFileFlag, createthisswath, lowerOverlap, upperOverlap, &
    & NoCreatedFiles, &
    & sourceVectors, sourceQuantities, &
    & precisionVectors, precisionQuantities, &
    & vectors, DirectDatabase, directfiles, &
    & directfile, thisDirect, chunks, FWModelConfig, single )
    if ( DeeBug ) call outputNamedValue ( 'NoCreatedFiles after DWHDF', NoCreatedFiles )
      case ( l_l2aux, l_hdf )
d1298 7
a1304 7
    & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
    & chunkNo, createFileFlag, createthisswath, lowerOverlap, upperOverlap, &
    & NoCreatedFiles, &
    & sourceVectors, sourceQuantities, &
    & precisionVectors, precisionQuantities, &
    & vectors, DirectDatabase, directfiles, &
    & directfile, thisDirect, chunks, FWModelConfig, single )
d1307 6
a1312 6
    & Rank, Options, GroupName, Ticket, InputFile, myTheFile,  &
    & chunkNo, createFileFlag, createthisswath, lowerOverlap, upperOverlap, &
    & NoCreatedFiles, &
    & sourceVectors, sourceQuantities, &
    & vectors, DirectDatabase, directfiles, &
    & directfile, thisDirect )
d2146 1
a2146 1
       "$Id: Join.f90,v 2.182 2018/01/12 00:19:37 pwagner Exp $"
d2157 3
@


2.182
log
@Reorganized DirectWriteCommand; now Uses JoinUtils_1
@
text
@d1158 1
a1158 1
        fileaccess = DFACC_RDWR
d1190 5
a1194 1
      case ( l_l2gp, l_l2dgg )
d1196 3
a1198 1
      case ( l_l2fwm, l_l2aux, l_hdf, l_quantity )
d1200 17
d2122 1
a2122 1
       "$Id: Join.f90,v 2.181 2017/12/07 01:01:23 vsnyder Exp $"
d2133 3
@


2.181
log
@Don't use host-associated variable as a DO index
@
text
@d18 1
a31 1
  logical, parameter, private :: SKIPMETADATA = .false. ! Usually FALSE
d36 1
a36 1
  integer :: ERROR
a39 1
  integer, parameter :: NotAllowed      = 1
d212 2
d323 6
a328 4
              if(DEEBUG)call print_source ( where_at(son) )
              if(DEEBUG)print*,'Calling direct write to do the write'
              if(DEEBUG)print*,'Asked to create file? ', createFile
              if(DEEBUG)print*,'the file ', trim(theFile)
d494 1
a494 2
      & DirectWrite, Dump, &
      & ExpandDirectdb, ExpandSDNames, FileNameToID
d512 1
a512 1
    use MLSCommon, only: FileNameLen, MLSFile_T, L2MetaData_T
d515 1
a515 1
      & MLS_CloseFile, MLS_OpenFile, Split_Path_Name
a516 1
    use MLSHDFeos, only: MLS_Swath_In_File
d519 1
a519 1
      & MaxChunkSize, Patch, RuntimeValues, SkipDirectWrites, Toolkit
a527 1
    use OutputAndClose, only: Add_MetaData
a565 1
    logical, dimension(:), pointer :: CREATETHISSOURCE
a586 1
    integer :: HDFNAMEINDEX             ! String index for output name
a600 1
    character(len=256), dimension(:), pointer :: NAMEBUFFER
a602 3
    integer :: NumPermitted             ! No. things permitted to output
    integer :: NumOutput                ! No. things actually output
    logical, parameter :: OPENHERE = .false.
a639 1
    type(Vector_T), pointer      :: Vector ! => null()
a640 1
    type(L2Metadata_T) :: l2metaData
d661 2
a867 1
    ! if ( .not. (SKIPDIRECTWRITES .or. checkpaths) ) then
d869 81
a949 80
    ! Now go through and do some sanity checking
    nullify ( AscDescModeQty )
    if ( got(f_AscDescMode) ) AscDescModeQty => GetVectorQtyByTemplateIndex ( vectors(AscDescModevector), &
    & AscDescModeQtyIndx )
    do source = 1, noSources
      if ( sourceQuantities(source) < 1 ) cycle
      qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
      & sourceQuantities(source) )
      if ( qty%label == 0 ) call Announce_Error ( son, no_error_code, &
      & "Quantity does not have a label" )
      if ( precisionVectors(source) /= 0 ) then
        precQty => &
          & GetVectorQtyByTemplateIndex ( vectors(precisionVectors(source)), &
          & precisionQuantities(source) )
        ! Check that this is compatible with its value quantity
        if ( qty%template%name /= precQty%template%name ) &
        & call Announce_Error ( son, no_error_code, &
        & "Precision and quantity do not match" )
      else
        precQty => NULL()
      end if
      if ( qualityVectors(source) /= 0 ) then
        qualityQty => &
          & GetVectorQtyByTemplateIndex ( vectors(qualityVectors(source)), &
          & qualityQuantities(source) )
        ! Check that value and quality share same HGrid
        if ( .not. DoHgridsMatch( qty, qualityQty ) ) &
        & call Announce_Error ( son, no_error_code, &
        & "Source and quality not on matching HGrids" )
      else
        qualityQty => NULL()
      end if
      if ( statusVectors(source) /= 0 ) then
        statusQty => &
          & GetVectorQtyByTemplateIndex ( vectors(statusVectors(source)), &
          & statusQuantities(source) )
        ! Check that value and quality share same HGrid
        if ( .not. DoHgridsMatch( qty, statusQty ) ) &
        & call Announce_Error ( son, no_error_code, &
        & "Source and status not on matching HGrids" )
      else
        statusQty => NULL()
      end if
      if ( convergVectors(source) /= 0 ) then
        convergQty => &
          & GetVectorQtyByTemplateIndex ( vectors(convergVectors(source)), &
          & convergQuantities(source) )
        ! Check that value and convergence share same HGrid
        if ( .not. DoHgridsMatch( qty, convergQty ) ) &
        & call Announce_Error ( son, no_error_code, &
        & "Source and convergence not on matching HGrids" )
      else
        convergQty => NULL()
      end if
      ! Now check that things make sense
      if ( ValidateVectorQuantity ( qty, &
        & coherent=.true., stacked=.true., regular=.true., &
        & verticalCoordinate = (/ l_pressure, l_zeta, l_none/), &
        & minorFrame=.false., majorFrame=.false. ) ) then
        expectedType = l_l2gp
      elseif ( qty%template%quantityType == l_magneticField ) then
        expectedType = l_quantity
      else
        expectedType = l_l2aux
      end if
      if ( outputType /= expectedType .and. .not. &
        & ( outputType == l_l2dgg .and. expectedType == l_l2gp ) &
        &                           .and. .not.  &
        & ( outputType == l_l2fwm .and. expectedType == l_l2aux ) ) then
        call output ( "Offending quantity " )
        call display_string ( qty%template%name, strip=.true., advance='yes' )
        call output ( "Expected type " )
        call display_string ( lit_indices(expectedType), advance='yes' )
        call output ( "Output file type " )
        call display_string ( lit_indices(outputType), advance='yes' )
        call Announce_Error ( son, no_error_code, &
          & "Inappropriate quantity for this file type in direct write", &
          & Penalty=0 )
      end if
    end do
d1046 1
d1062 1
d1071 1
d1156 1
d1159 1
a1179 21
      ! Some indicators of where to find the file in the PCF
      ! and what type of file it will be (fileType will be redefined later)
      select case ( outputType )
      case ( l_l2gp )
        PCBottom = mlspcf_l2gp_start
        PCTop    = mlspcf_l2gp_end
        fileType = l_swath
      case ( l_l2dgg )
        PCBottom = mlspcf_l2dgg_start
        PCTop    = mlspcf_l2dgg_end
        fileType = l_swath
      case ( l_l2fwm )
        PCBottom = mlspcf_l2fwm_full_start
        PCTop    = mlspcf_l2fwm_full_end
        fileType = l_hdf
      case ( l_l2aux, l_hdf, l_quantity )
        PCBottom = mlspcf_l2dgm_start
        PCTop    = mlspcf_l2dgm_end
        fileType = l_hdf
      end select

d1189 6
a1204 1
      if ( OPENHERE ) call mls_openFile(directFile, ErrorType)
d1207 3
a1209 1
      errorType = 0
d1211 55
a1265 354
      case ( l_l2gp, l_l2dgg )
        ! Before opening file, see which swaths are already there
        ! and which ones need to be created
        if ( DeeBUG ) print *, 'Allocating ', noSources
        nullify(createThisSource, nameBuffer)
        call Allocate_test ( createThisSource, noSources, 'createThisSource', &
          & ModuleName )
        call Allocate_test ( nameBuffer, noSources, 'nameBuffer', &
          & ModuleName )
        if(DEEBUG)print *, 'Must we create this file?', createFileFlag
        if ( .not. createFileFlag ) then
          do source = 1, noSources
            if(DEEBUG)print*,'Source:', source
            if ( sourceQuantities(source) > 0 ) then
              qty => GetVectorQtyByTemplateIndex ( &
                & vectors(sourceVectors(source)), sourceQuantities(source) )
            else
              qty => GetVectorQtyByTemplateIndex ( &
                & vectors(sourceVectors(source)), 1 )
            end if
            hdfNameIndex = qty%label
            if(DEEBUG) &
              & call display_string ( hdfNameIndex, strip=.true., advance='yes' )
            call get_string ( hdfNameIndex, nameBuffer(source), strip=.true. )
            if(DEEBUG)print*,'Done'
          end do
          if(DEEBUG)print *, '************** Checking for swaths in file ***************'
          if(DEEBUG)call dump(directFile)
          dummy = MLS_SWATH_IN_FILE(directFile%Name, nameBuffer, HdfVersion, &
            & createThisSource, returnStatus )
          if(DEEBUG)print*,'Got out of MLS_SWATH_IN_FILE'
          if ( returnStatus /= 0 ) then
            call MLSMessage(MLSMSG_Warning, ModuleName, &
              & 'Unable to check on swath in ' // trim(filename) )
          end if
          if(DEEBUG)call dump( createThisSource, 'createThisSource' )
          source = findFirst( createThisSource )
          if(DEEBUG)call outputNamedValue ( 'source number of T', source )
        else
          createThisSource = .false.
        end if
      case ( l_l2aux, l_l2fwm, l_hdf, l_quantity )
        ! Nothing special
        ! (Why don't we need to know which SDs are there and which aren't?)
      case default
          call MLSMessage(MLSMSG_Warning, ModuleName, &
          & 'Unrecognized output type ' // trim(directFile%name), &
          & MLSFile=directFile )
      end select
      
      if ( ErrorType /= 0 .and. OPENHERE ) then
        print *, 'Tried to open ', trim(directFile%Name)
        print *, 'ErrorType ', ErrorType
        print *, 'Output Type ', OutputType
        print *, 'Output Type ', OutputTypeStr
        print *, 'FileAccess ', directFile%Access
        print *, 'hdfVersion ', directFile%hdfVersion
        print *, 'myFile ', myFile
        print *, 'createFileFlag ', createFileFlag
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'DirectWriteCommand unable to open ' // trim(filename), &
          & MLSFIle=directFile )
      end if
      ! Loop over the quantities to output
      NumPermitted = 0
      NumOutput = 0
      if(DEEBUG)print *, '************** Loop over quantities to output ***************'
      do source = 1, noSources
        ! At this point we're ready to write the data
        ! Make certain that the sources match the permitted file
        ! if the sources are being distributed, however
        if ( distributingSources ) then
          if ( DirectDataBase(directfiles(source))%filename /= myTheFile &
            & .and. &
            & DirectDataBase(directfiles(source))%filenameBase /= myTheFile &
            & ) cycle
        end if
        NumPermitted = NumPermitted + 1
        if ( sourceQuantities(source) < 1 ) then
          ! This is the case where we write an entire vector
          vector => vectors(sourceVectors(source))
          select case ( outputType )
          case ( l_l2gp, l_l2dgg )
            call DirectWrite ( directFile, vector, &
            & chunkNo, &
            & createSwath=createthisswath, &
            & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
            & maxChunkSize=maxChunkSize )
          case ( l_l2aux, l_l2fwm, l_hdf )
            call DirectWrite ( directFile, vector, &
              & chunkNo, chunks, FWModelConfig, &
              & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
              & single=single, options=options, groupName=groupName )
          case ( l_quantity )
            call DirectWrite ( directFile, &
              & vector, &
              & chunkNo, options=options, rank=rank )
          case default
          end select
          cycle
        end if
        qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
          & sourceQuantities(source) )
        hdfNameIndex = qty%label
        call get_string ( hdfNameIndex, hdfName, strip=.true. )
        if ( TOOLKIT .or. CATENATESPLITS ) &
          & call ExpandSDNames(thisDirect, trim(hdfName))
        if ( (TOOLKIT .or. CATENATESPLITS) .and. DEEBUG ) call dump(thisDirect)
        if ( precisionVectors(source) /= 0 ) then
          precQty => GetVectorQtyByTemplateIndex &
            & ( vectors(precisionVectors(source)), precisionQuantities(source) )
          ! Check that this is compatible with its value quantitiy
          if ( qty%template%name /= precQty%template%name ) &
            & call Announce_Error ( son, no_error_code, &
            & "Precision and quantity do not match" )
        else
          precQty => NULL()
        end if
        if ( qualityVectors(source) /= 0 ) then
          qualityQty => &
            & GetVectorQtyByTemplateIndex ( vectors(qualityVectors(source)), &
            & qualityQuantities(source) )
          ! Check that value and quality share same HGrid
          if ( .not. DoHgridsMatch( qty, qualityQty ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Source and quality not on matching HGrids" )
        else
          qualityQty => NULL()
        end if
        if ( statusVectors(source) /= 0 ) then
          statusQty => &
            & GetVectorQtyByTemplateIndex ( vectors(statusVectors(source)), &
            & statusQuantities(source) )
          ! Check that value and quality share same HGrid
          if ( .not. DoHgridsMatch( qty, statusQty ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Source and status not on matching HGrids" )
        else
          statusQty => NULL()
        end if
        if ( convergVectors(source) /= 0 ) then
          convergQty => &
            & GetVectorQtyByTemplateIndex ( vectors(convergVectors(source)), &
            & convergQuantities(source) )
          ! Check that value and convergence share same HGrid
          if ( .not. DoHgridsMatch( qty, convergQty ) ) &
          & call Announce_Error ( son, no_error_code, &
          & "Source and convergence not on matching HGrids" )
        else
          convergQty => NULL()
        end if
        
        if ( DeeBUG ) then
          call output('CreateFileFlag: ', advance='no')
          call output(createFileFlag, advance='yes')
          call output('file access: ', advance='no')
          call output(fileaccess, advance='yes')
          call output('file handle: ', advance='no')
          call output(handle, advance='yes')
          call output('outputType: ', advance='no')
          call output(outputType, advance='yes')
          call output('sd name: ', advance='no')
          call output(trim(hdfname), advance='yes')
        end if
        call time_now ( timeSetup )
        if ( timeSetup-timeIn > timeReasonable .and. &
          & switchDetail(switches,'dwreq') > -1 ) then
          call output('Unreasonable set up time for ' // trim(hdfname), &
            & advance='yes')
        end if

        ! Do the actual DirectWrite
        ! (Why do we need to redefine fileType? Is add_metadata so stupid?)
        select case ( outputType )
        case ( l_l2gp, l_l2dgg )
          ! Call the l2gp swath write routine.  This should write the 
          ! non-overlapped portion of qty (with possibly precision in precQty)
          ! into the l2gp swath named 'hdfName' starting at profile 
          ! qty%template%instanceOffset + 1
          ! May optionally supply first, last profiles
          if ( DEEBUG) then
            call dump(directFile, details=1)
            call output('createSwath: ', advance='no')
            call output(.not. createThisSource(source), advance='yes')
            call outputNamedValue ( 'source number of DW', source )
          end if
          createthisswath = (.not. createThisSource(source))
          ! We had a bug somewhere in hdfeos
          ! When we created the first swath in an hdfeos file
          ! mls_swath_in_file didn't find it
          ! What we'll try is to create the swath, then close the file
          ! and reset its access to read/write--could be that it was confused 
          ! by the DFACC_CREATE
          call DirectWrite ( directFile, &
            & qty, precQty, qualityQty, statusQty, convergQty, AscDescModeQty, &
            & hdfName, chunkNo, &
            & createSwath=createthisswath, &
            & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
            & maxChunkSize=maxChunkSize )
          if ( createthisswath ) then
            if ( directFile%stillOpen ) &
              & call mls_closeFile(directFile, errorType)
            directFile%access = DFACC_RDWR
          end if
          if ( fileaccess == DFACC_CREATE ) then
            ! OK, because the bug is still there (!), we'll repeat
            call DirectWrite ( directFile, &
              & qty, precQty, qualityQty, statusQty, convergQty, AscDescModeQty, &
              & hdfName, chunkNo, &
              & createSwath=createthisswath, &
              & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
              & maxChunkSize=maxChunkSize )
          end if
          NumOutput= NumOutput + 1
          if ( outputType == l_l2dgg ) then
            filetype=l_l2dgg
          else
            filetype=l_swath
          end if
        case ( l_l2aux, l_l2fwm, l_hdf )
          if ( got(f_inputFile) ) then
            ! Write the ascii file as if it contained the quantity's values
            call DirectWrite ( directFile, qty, hdfName, &
              & chunkNo, options=options, rank=rank, inputFile=inputFile  )
          else
            ! Call the l2aux sd write routine.  This should write the 
            ! non-overlapped portion of qty (with possibly precision in precQty)
            ! into the l2aux sd named 'hdfName' starting at profile 
            ! qty%template%instanceOffset ( + 1 ? )
            ! Note sure about the +1 in this case, probably depends whether it's a
            ! minor frame quantity or not.  This mixed zero/one indexing is becoming
            ! a real pain.  I wish I never went down that road!
            call DirectWrite ( directFile, qty, precQty, hdfName, &
              & chunkNo, chunks, FWModelConfig, &
              & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
              & single=single, options=options )
          end if
          NumOutput = NumOutput + 1
          filetype=l_hdf
        case ( l_quantity )
          if ( got(f_inputFile) ) then
            ! Write the ascii file as if it contained the quantity's values
            call DirectWrite ( directFile, qty, hdfName, &
              & chunkNo, options=options, rank=rank, inputFile=inputFile  )
          else
            ! Write the quantity with all its geolocations
            ! call outputnamedValue( 'Calling DirectWrite with rank', rank )
            call DirectWrite ( directFile, qty, hdfName, &
              & chunkNo, options=options, rank=rank )
          end if
          NumOutput = NumOutput + 1
          filetype=l_quantity
        case default
          call output('outputType: ', advance='no')
          call output(outputType, advance='yes')
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unrecognized OutputType in ' // trim(filename) )
        end select
      end do ! End loop over swaths/sds
      call time_now ( timeWriting )
      if ( timeWriting-timeSetup > timeReasonable .and. &
        & switchDetail(switches,'dwreq') > -1 ) then
        call output('Unreasonable writing time for ' //trim(hdfname), advance='yes')
      end if
      
      if ( DEEBUG ) then
        print *, 'Num permitted to ', trim(FileName), ' ', NumPermitted
        print *, 'Num actually output ', NumOutput
      end if
      if ( NumPermitted < 1 ) then
        if ( parallel%slave) then
          call Announce_Error ( son, no_error_code, &
            & "NumPermitted=0", penalty=0 )
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No sources permitted for writing to  ' // trim(filename) )
          call FinishedDirectWrite ( ticket )
        else
          ! But did we claim we were created this file? If so, decrement
          if ( createFileFlag ) noCreatedFiles = noCreatedFiles - 1
          if ( DEEBUG ) then
            print *, 'No sources written to ', trim(FileName)
            print *, 'FileAccess ', FileAccess
            print *, 'hdfVersion ', hdfVersion
            print *, 'myFile ', myFile
            print *, 'createFileFlag ', createFileFlag
            print *, 'noCreatedFiles ', noCreatedFiles
          end if
        end if
        call DeallocateStuff
        if ( any ( outputType == (/ l_l2gp, l_l2dgg /) ) ) then
          call Deallocate_test ( createThisSource, 'createThisSource', ModuleName )
          call Deallocate_test ( nameBuffer, 'nameBuffer', ModuleName )
        end if

        ! Don't forget to close file
        select case ( outputType )
        case ( l_l2gp, l_l2dgg, l_l2aux, l_l2fwm, l_hdf )
          if ( OPENHERE ) call mls_closeFile(directFile, ErrorType)
        case default
          call output('outputType: ', advance='no')
          call output(outputType, advance='yes')
          call output('ErrorType: ', advance='no')
          call output(ErrorType, advance='yes')
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Tried to close Unrecognized OutputType in ' // trim(filename), &
            & MLSFile=directFile )
        end select
        call time_now ( timeToClose )
        if ( timeToClose-timeWriting > timeReasonable .and. &
          & switchDetail(switches,'dwreq') > -1 ) then
          call output('Unreasonable closing time for ' // trim(hdfname), &
            & advance='yes')
        end if
        if ( errortype /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'DirectWriteCommand unable to close (1)' // trim(filename), &
          & MLSFile=directFile )
        call trace_end ( "DirectWriteCommand", &
          & cond=toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 )
        return
      end if
      if ( isnewdirect .and. (TOOLKIT .or. CATENATESPLITS) ) then
        thisDirect%type = outputType
        thisDirect%fileNameBase = file_base
      end if
      
      if ( DEEBug ) then
        call output('outputType: ', advance='no')
        call DISPLAY_STRING(lit_indices(outputType), advance='yes')
        call output('fileType: ', advance='no')
        call DISPLAY_STRING(lit_indices(fileType), advance='yes')
      end if

      ! Close the output file of interest (does this need to be split like this?)
      select case ( outputType )
      case ( l_l2gp, l_l2dgg )
        if ( DeeBUG ) print *, 'Deallocating ', noSources
        call Deallocate_test ( createThisSource, 'createThisSource', ModuleName )
        call Deallocate_test ( nameBuffer, 'nameBuffer', ModuleName )
        ! Call the l2gp close routine
        if ( OPENHERE ) call mls_closeFile(directFile, errorType)
        if ( DeeBUG ) then
          print *, 'Tried to close ', trim(FIleName)
          print *, 'Handle ', Handle
          print *, 'hdfVersion ', hdfVersion
          print *, 'errortype ', errortype
        end if
      case ( l_l2aux, l_l2fwm, l_hdf, l_quantity )
        ! Call the l2aux close routine
        if ( OPENHERE ) call mls_closeFile(directFile, errorType)
      case default
        call DISPLAY_STRING(lit_indices(outputType), before='outputType: ', advance='yes')
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Tried to closeUnrecognized output type ' // trim(filename), &
        & MLSFile=directFile )
a1266 18
      call time_now ( timeToClose )
      if ( timeToClose-timeWriting > timeReasonable .and. &
        & switchDetail(switches,'dwreq') > -1 ) then
        call output('Unreasonable closing time for ' // trim(hdfname), &
          & advance='yes')
      end if
      if ( errortype /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'DirectWriteCommand unable to close (2)' // trim(filename), &
        & MLSFile=directFile )
      if ( createFileFlag .and. TOOLKIT .and. .not. SKIPMETADATA .and. &
        & .not. any( outputType == (/l_l2fwm, l_hdf /)) .and. &
        & .not. (distributingSources .and. CATENATESPLITS) ) then
        call add_metadata ( node, file_base, l2metaData, &
          & hdfVersion, filetype, errortype, NumPermitted, thisDirect%sdNames )
        if ( errortype /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'DirectWriteCommand unable to addmetadata to ' // trim(filename), &
          & MLSFile=directFile )
      end if
a1364 1
!     use highOutput, only: outputNamedValue
a1458 1
        ! call outputNamedValue( 'label string start', labelStr, advance='yes' )
a2095 41
  ! ---------------------------------------------  Announce_Error  -----
  subroutine ANNOUNCE_ERROR ( where, CODE, ExtraMessage, FIELDINDEX, Penalty )

    use Intrinsic, only: Field_Indices
    use Lexer_Core, only: Print_Source
    use Output_M, only: Output
    use String_Table, only: Display_String
    use Tree, only: Where_At => Where

    integer, intent(in) :: where   ! Tree node where error was noticed
    integer, intent(in) :: CODE    ! Code for error message
    integer, intent(in), optional :: FIELDINDEX ! Extra information for msg
    character (LEN=*), intent(in), optional :: ExtraMessage

    integer, intent(in), optional :: Penalty
    integer :: myPenalty

    myPenalty = 1
    if ( present(penalty) ) myPenalty = penalty
    error = max( error, myPenalty )

    call output ( '***** At ' )
    if ( where > 0 ) then
      call print_source ( where_at(where) )
    else
      call output ( '(no lcf tree available)' )
    end if
    call output ( ': ' )
    select case ( code )
      case ( NotAllowed )
        call output( 'Field ' )
        call display_string( field_indices(fieldIndex) )
        call output( ' is not allowed in this context',advance='yes' )
      case default
        call output ( " command caused an unrecognized programming error", advance='yes' )
    end select
    if ( present(ExtraMessage) ) then
      call output( ExtraMessage, advance='yes' )
    end if
  end subroutine ANNOUNCE_ERROR

d2099 1
a2099 1
       "$Id: Join.f90,v 2.180 2017/08/03 21:41:04 pwagner Exp $"
d2110 3
@


2.180
log
@Split MLSL2Join into calls to 2 internal procedures; fix problem of not doing DirecWrites if section contains Dump, /stop
@
text
@a112 1
    integer :: DBINDEX
a119 1
    integer :: j
d185 3
a187 1
    integer :: pass
d382 1
d2474 1
a2474 1
       "$Id: Join.f90,v 2.179 2017/07/27 17:03:53 pwagner Exp $"
d2485 3
@


2.179
log
@DirectWrite-ing an entire vector may put it under a named group
@
text
@d48 5
d80 1
a80 1
   use MLSL2Timings, only: Section_Times, Total_Times, &
d87 1
a87 1
   use Output_M, only: Blanks, Output, RevertOutput, SwitchOutput
d129 1
a129 1
    integer :: PASS                     ! Loop counter
a139 1
    real :: T2                          ! Time we finished
d161 20
d182 2
a183 1
    ! In pass 1 we do all the regular join statements and count the direct writes
d187 2
a188 2

    ! In the non-parallel slave mode, one pass is sufficient.
d221 2
d246 2
a247 11
        case ( s_diff, s_dump ) ! ======================= Diff, Dump ==========
          ! Handle disassociated pointers by allocating them with zero size
          status = 0
          if ( CHECKPATHS ) cycle
          if ( .not. associated(vectors) ) allocate ( vectors(0), stat=status )
          call test_allocate ( status, moduleName, 'Vectors', (/0/), (/0/) )
          call dumpCommand ( key, vectors=vectors, HGrids=HGrids, &
            & ForwardModelConfigs=FWModelConfig, FileDataBase=FileDataBase, &
            & MatrixDatabase=matrices, HessianDatabase=Hessians )
        case ( s_execute ) ! ======================== ExecuteCommand ==========
          call ExecuteCommand ( key )
a269 6
        case ( s_l2gp, s_l2aux )
          ! Only do these the first time round
          if ( pass == 1 .and. .not. checkpaths ) then
            call JoinQuantities ( key, vectors, l2gpDatabase, l2auxDatabase, &
              & chunkNo, chunks )
          end if
d378 4
d383 70
a452 5
    if ( specialDumpFile /= ' ' ) &
      & call revertOutput
    ! Check for errors
    if ( error /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Error in Join section' )
d454 1
a454 2
    call trace_end ( "MLSL2Join", cond=toggle(gen) )
    if ( timing ) call sayTime ( 'Join', t1=t1, cumulative=.false. )
d460 3
a462 3
  ! Direct write is probably going to become the predominant form
  ! of output in the software, as the other forms have become a
  ! little too intensive.
d464 2
a465 2
  ! This routine may be called by a standalone run, or by a slave.
  ! If called by a standalone run, just do the write and return.
d2473 1
a2473 1
       "$Id: Join.f90,v 2.178 2016/11/08 17:34:15 pwagner Exp $"
d2484 3
@


2.178
log
@Use SayTime subroutine from time_m module; process /reset field
@
text
@d16 2
a17 1
  use MLSStringLists, only: switchDetail
d38 1
d54 34
a87 34
    use Allocate_Deallocate, only: Test_Allocate
    use Chunks_m, only: MLSChunk_t
    use DirectWrite_m, only: DirectData_t
    use Dumpcommand_m, only: DumpCommand, ExecuteCommand, &
      & MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, Skip
    use ForwardModelConfig, only: ForwardModelConfig_t
    use HessianModule_1, only: Hessian_t
    use HGridsDatabase, only: HGrids_t
    use highOutput, only: beVerbose, letsDebug, outputNamedValue
    use Init_Tables_Module, only: f_reset, &
      & s_l2gp, s_l2aux, s_time, s_directwrite, &
      & s_endselect, s_case, s_diff, s_dump, s_execute, s_label, s_select, &
      & s_skip
    use L2GPData, only: L2GPData_t
    use L2AuxData, only: l2AuxData_t
    use L2ParInfo, only: Parallel, WaitForDirectWritePermission
    use Lexer_core, only: Print_Source
    use MatrixModule_1, only: Matrix_Database_t
    use MLSCommon, only: MLSFile_t
    use MLSL2Options, only: CheckPaths, L2CFNode, &
      & SkipDirectWrites, SpecialDumpFile, MLSMessage
    use MLSL2Timings, only: Section_Times, Total_Times, &
      & Add_to_DirectWrite_Timing, Add_to_Section_Timing
    use MLSMessageModule, only: MLSMSG_Error
    use MoreTree, only: get_boolean, get_field_id, Get_Label_and_Spec, &
      & Get_Spec_Id
    use Next_Tree_Node_m, only: Init_Next_Tree_Node, Next_Tree_Node, &
      & Next_Tree_Node_State
    use Output_m, only: Blanks, Output, RevertOutput, SwitchOutput
    use Toggles, only: Gen, Toggle, Switches
    use Tree, only: Where_at => Where, nsons, subtree
    use Time_m, only: SayTime, Time_Now
    use Trace_m, only: Trace_Begin, Trace_End
    use VectorsModule, only: Vector_t
d407 23
a429 23
    use allocate_deallocate, only: allocate_test, deallocate_test
    use chunks_m, only: mlschunk_t
    use directWrite_m, only: directData_t, &
      & directWrite, dump, &
      & expandDirectdb, expandSDNames, fileNameToID
    use dump_0, only: dump
    use expr_m, only: expr
    use forwardModelConfig, only: forwardModelConfig_t
    use hdf, only: dfacc_create, dfacc_rdwr
    use HGridsDatabase, only: HGrids_t
    use highOutput, only: outputNamedValue
    use init_tables_module, only: f_ascDescMode, f_convergence, f_file, &
      & f_hdfVersion, f_inputFile, &
      & f_label, f_lowerOverlap, f_noPCFid, f_options, &
      & f_precision, f_prefixSignal, f_quality, f_rank, &
      & f_single, f_source, f_status, f_type, f_upperOverlap, f_vector, &
      & field_first, field_last
    use init_tables_module, only: l_l2gp, l_l2aux, l_l2dgg, l_l2fwm, &
      & l_magneticField, l_pressure, l_quantity, l_zeta
    use intrinsic, only: l_none, l_hdf, l_swath, lit_indices, phyq_dimensionless
    use l2parinfo, only: parallel, logDirectwriteRequest, finishedDirectwrite
    use manipulateVectorQuantities, only: doHGridsMatch
    use MLSCommon, only: fileNameLen, MLSFile_t, l2Metadata_t
d431 7
a437 8
      & addInitializeMLSFile, dump, getMLSFileByName, getPCFromRef, &
      & mls_CloseFile, mls_OpenFile, split_path_name
    use MLSFinds, only: findFirst, findNext
    use MLSHdfeos, only: mls_swath_in_file
    use MLSKinds, only: r8
    use MLSL2Options, only: checkPaths, &
      & default_HDFVersion_Write, maxChunkSize, patch, skipDirectWrites, &
      & toolkit
d439 17
a455 17
    use MLSPCF2, only: MLSPCF_l2gp_start, MLSPCF_l2gp_end, &
      & MLSPCF_l2dgm_start, MLSPCF_l2dgm_end, MLSPCF_l2fwm_full_start, &
      & MLSPCF_l2fwm_full_end, &
      & MLSPCF_l2dgg_start, MLSPCF_l2dgg_end
    use MLSSignals_m, only: getsignalname
    use moretree, only: get_field_id, get_boolean
    use output_m, only: blanks, output
    use outputAndClose, only: add_metadata
    use string_table, only: display_string, get_string
    use symbol_table, only: enter_terminal
    use symbol_types, only: t_string
    use time_m, only: time_now
    use toggles, only: gen, toggle, switches
    use trace_m, only: trace_begin, trace_end
    use tree, only: decoration, nsons, sub_rosa, subtree
    use vectorsModule, only: vector_t, vectorValue_t, validateVectorQuantity, &
      & getVectorQtyByTemplateIndex
d483 1
d504 1
d595 1
d615 6
d648 2
d1237 1
a1237 1
              & single=single, options=options )
d1617 11
a1627 10
    use init_tables_module, only: f_label, f_prefixsignal, &
      & f_quantity, f_vector
    use MLSSignals_m, only: getSignalName
    use moretree, only: get_field_id, get_boolean
    use symbol_table, only: enter_terminal
    use symbol_types, only: t_string
    use string_table, only: get_string
    use tree, only: nsons, subtree, sub_rosa, decoration
    use vectorsModule, only: vector_t, vectorvalue_t, &
      & getVectorQuantity, getVectorQtyByTemplateIndex
d1632 1
d1636 1
a1646 2
    character(len=1024) :: LABELSTR     ! The label itself
    ! character(len=128)  :: QTYSTR       ! The template name
d1668 8
d1729 11
a1739 11
    use chunks_m, only: mlschunk_t
    ! use expr_m, only: expr
    use init_tables_module, only: &
      & f_precision, f_prefixsignal, f_source, f_sdname, f_swath, field_first, &
      & field_last
    use init_tables_module, only: l_pressure, l_zeta, s_l2aux, s_l2gp
    use intrinsic, only: l_none! , phyq_dimensionless
    use l2auxdata, only: l2auxdata_t
    use l2gpdata, only: l2gpdata_t
    use l2parinfo, only: parallel, slavejoin
    ! use mlskinds, only: r8
d1741 8
a1748 8
    use MLSSignals_m, only: getsignalname
    use moretree, only: get_boolean, get_field_id, get_spec_id
    use string_table, only: get_string
    use symbol_table, only: enter_terminal
    use symbol_types, only: t_string
    use tree, only: decoration, nsons, null_tree, sub_rosa, subtree
    use vectorsModule, only: getVectorQtyByTemplateIndex, &
      & validateVectorQuantity, vector_t, vectorValue_t
d1915 10
a1924 10
    use init_tables_module, only: l_pressure, l_zeta
    use intrinsic, only: l_none
    use l2gpdata, only: addl2gptodatabase, expandl2gpdatainplace, &
      & l2gpdata_t, setupnewl2gprecord, rgp
    use MLSKinds, only: rv
    use string_table, only: get_string
    use toggles, only: gen, toggle, levels
    use trace_m, only: trace_begin, trace_end
    use tree, only: decorate, decoration
    use vectorsModule, only: vectorValue_t
d2087 5
a2091 5
    use chunks_m, only: mlschunk_t
    use intrinsic, only: l_geodangle, l_maf
    use l2auxdata, only: addl2auxtodatabase, resizel2auxdata, &
      & l2auxdata_t, l2auxrank, setupnewl2auxrecord
    use MLSKinds, only: r4, r8
d2093 6
a2098 6
    use output_m, only: output
    use string_table, only: display_string
    use toggles, only: gen, toggle, levels, switches
    use trace_m, only: trace_begin, trace_end
    use tree, only: decorate, decoration
    use vectorsModule, only: vectorValue_t
d2327 3
a2329 3
    use init_tables_module, only: f_file
    use moretree, only: get_field_id
    use tree, only: nsons, subtree
d2352 5
a2356 5
    use intrinsic, only: field_indices
    use lexer_core, only: print_source
    use output_m, only: output
    use string_table, only: display_string
    use tree, only: Where_At => Where
d2393 1
a2393 1
       "$Id: Join.f90,v 2.177 2016/11/01 17:44:40 pwagner Exp $"
d2404 3
@


2.177
log
@Fixed error in getting directFile to ignore_paths or not
@
text
@d61 2
a62 1
    use Init_Tables_Module, only: s_l2gp, s_l2aux, s_time, s_directwrite, &
d76 2
a77 1
    use MoreTree, only: Get_Label_and_Spec, Get_Spec_Id
d82 2
a83 2
    use Tree, only: Where_at => Where
    use Time_m, only: Time_Now
d112 3
d123 1
d200 13
d243 2
a244 2
            if ( timing ) then
              call sayTime
d327 2
a328 2
                call sayJustThisTime ( 'Completing this DW, ' // &
                  & trim(outputTyp), dwt2 )
d372 1
a372 28
    if ( timing ) call sayTime

  contains
    ! Private procedures
    subroutine SayJustThisTime ( ForWhat, t1 )
      ! Args
      character(len=*), intent(in) :: ForWhat
      real, intent(in) :: t1
      ! Internal variables
      real             :: t2
      ! Executable
      call time_now ( t2 )
      call output ( "Timing for ", advance='no' )
      call output ( trim(ForWhat), advance='no' )
      call blanks ( 1 )
      call output ( dble(t2 - t1), advance = 'yes' )
    end subroutine SayJustThisTime

    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), after='    ', advance = 'no' )
      end if
      call output ( "Timing for MLSL2Join =" )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime
d2372 1
a2372 1
       "$Id: Join.f90,v 2.176 2016/09/07 22:47:12 pwagner Exp $"
d2383 3
@


2.176
log
@Removed unused QuantityType component from L2GPData type
@
text
@d1119 7
a1125 1
      directFile => GetMLSFileByName(filedatabase, filename, ignore_paths=.true.)
d2380 1
a2380 1
       "$Id: Join.f90,v 2.175 2016/07/28 01:43:51 vsnyder Exp $"
d2391 3
@


2.175
log
@Remove unreferenced USE
@
text
@d1983 1
a1983 1
      newL2GP%quantityType=quantity%template%quantityType
d2374 1
a2374 1
       "$Id: Join.f90,v 2.174 2016/05/18 01:37:30 vsnyder Exp $"
d2385 3
@


2.174
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@a67 1
    use machine, only: USleep
a99 1
    ! integer, parameter :: DELAY = 500000  ! For Usleep, no. microsecs
d1604 1
a1604 1
  ! ------------------------------------------------ LabelVectorQuantity -----
d1606 1
a1606 1
    use highOutput, only: outputNamedValue
d2374 1
a2374 1
       "$Id: Join.f90,v 2.173 2016/04/01 00:27:15 pwagner Exp $"
d2385 4
@


2.173
log
@May now Execute a single command or a script of lines from l2cf
@
text
@d59 1
a59 1
    use HGridsDatabase, only: HGrid_t
d96 1
a96 1
    type (HGrid_T), dimension(:), pointer ::     HGrids
d176 1
a176 1
        endif
d184 1
a184 1
        endif
d308 1
a308 1
              endif
d314 1
a314 1
              endif
d424 1
a424 1
    use HGridsDatabase, only: HGrid_t
d472 1
a472 1
    type (HGrid_T), dimension(:), pointer ::     HGrids
d789 1
a789 1
    endif
d880 1
a880 1
    endif
d908 1
a908 1
    endif
d1072 1
a1072 1
      endif
d1130 1
a1130 1
      endif
d1156 1
a1156 1
            endif
d1171 1
a1171 1
          endif
d1221 1
a1221 1
            & chunkNo, HGrids, &
d1237 1
a1237 1
        endif
d1306 1
a1306 1
        endif
d1322 1
a1322 1
          endif
d1332 1
a1332 1
            & hdfName, chunkNo, HGrids, &
d1340 1
a1340 1
          endif
d1345 1
a1345 1
              & hdfName, chunkNo, HGrids, &
d1349 1
a1349 1
          endif
d1373 1
a1373 1
          endif
d1386 1
a1386 1
          endif
d1400 1
a1400 1
      endif
d1449 1
a1449 1
        endif
d1497 1
a1497 1
      endif
d1517 1
a1517 1
      endif
d1690 1
a1690 1
        endif
d1693 1
a1693 1
        endif
d2376 1
a2376 1
       "$Id: Join.f90,v 2.172 2016/02/29 19:49:49 pwagner Exp $"
d2387 3
@


2.172
log
@Usleep got from machine module instead of being an external
@
text
@d55 1
a55 1
    use Dumpcommand_m, only: dumpcommand, &
d62 2
a63 1
      & s_endselect, s_case, s_diff, s_dump, s_label, s_select, s_skip
d209 2
d2376 1
a2376 1
       "$Id: Join.f90,v 2.171 2015/10/06 00:26:37 pwagner Exp $"
d2387 3
@


2.171
log
@magneticField belongs in type=quantity DirectWrite file
@
text
@d67 1
a101 1
    external :: Usleep
d2373 1
a2373 1
       "$Id: Join.f90,v 2.170 2015/09/17 23:24:30 pwagner Exp $"
d2384 3
@


2.170
log
@Passes Max chunk size for l2gp DirectWrites
@
text
@d430 1
a430 1
      & l_pressure, l_quantity, l_zeta
d850 2
a857 2
        & ( outputType == l_quantity ) &
        &                           .and. .not.  &
d2348 1
a2348 1
    error = max(error,myPenalty)
d2359 3
a2361 3
        call output('Field ')
        call display_string(field_indices(fieldIndex))
        call output(' is not allowed in this context',advance='yes')
d2366 1
a2366 1
      call output(ExtraMessage, advance='yes')
d2373 1
a2373 1
       "$Id: Join.f90,v 2.169 2015/09/10 17:49:19 pwagner Exp $"
d2384 3
@


2.169
log
@Verbose now times DirectWrites
@
text
@d442 2
a443 1
      & default_HDFVersion_Write, patch, skipDirectWrites, toolkit
d1218 4
a1221 3
              & chunkNo, chunks, FWModelConfig, &
              & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
              & single=single, options=options )
d1331 2
a1332 1
            & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
d1344 2
a1345 1
              & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
d2373 1
a2373 1
       "$Id: Join.f90,v 2.168 2015/08/25 21:56:34 pwagner Exp $"
d2384 3
@


2.168
log
@Had failed to give prefixSignal a default value; now FALSE
@
text
@d60 1
d77 1
a77 1
    use Output_m, only: Output, RevertOutput, SwitchOutput
d117 1
d129 1
d132 1
d135 2
a136 1
    DEEBUG = ( switchDetail(switches, 'direct') > -1 )!  .or. .true.
d172 2
a173 1
        if ( dwt22-dwt2 > timeReasonable ) then
d259 1
a259 1
                    & chunkNo, chunks, FWModelConfig, HGrids, &
d267 1
a267 1
                  & chunkNo, chunks, FWModelConfig, HGrids )
d279 2
a280 2
              & chunkNo, chunks, FWModelConfig, HGrids, makeRequest=.true., &
              & NoExtraWrites=noExtraWrites )
d294 2
a295 1
                & chunkNo, chunks, FWModelConfig, HGrids, create=createFile, &
d306 7
a312 1
              call add_to_directwrite_timing ( 'writing', dwt2)
d355 15
a369 1
    ! Private procedure
d408 2
a409 1
    & chunkNo, chunks, FWModelConfig, HGrids, makeRequest, create, theFile, &
d471 1
a535 1
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
d576 1
d2369 1
a2369 1
       "$Id: Join.f90,v 2.167 2015/07/15 17:09:05 pwagner Exp $"
d2380 3
@


2.167
log
@Fixed some bugs related to label field in DirectWWrite commands
@
text
@d68 1
a68 1
    use MLSL2options, only: CheckPaths, L2CFNode, &
d70 1
a70 1
    use MLSL2timings, only: Section_Times, Total_Times, &
d72 1
a72 1
    use MLSMessagemodule, only: MLSMSG_Error
d386 3
a388 3
    use directwrite_m, only: directdata_t, &
      & directwrite, dump, &
      & expanddirectdb, expandsdnames, filenametoid
d391 1
a391 1
    use forwardmodelconfig, only: forwardmodelconfig_t
d393 5
a397 5
    use hgridsdatabase, only: hgrid_t
    use highoutput, only: outputnamedvalue
    use init_tables_module, only: f_ascdescmode, f_convergence, f_file, &
      & f_hdfversion, f_inputFile, &
      & f_label, f_loweroverlap, f_noPCFid, f_options, &
d399 1
a399 1
      & f_single, f_source, f_status, f_type, f_upperoverlap, f_vector, &
d404 7
a410 7
    use l2parinfo, only: parallel, logdirectwriterequest, finisheddirectwrite
    use manipulatevectorquantities, only: dohgridsmatch
    use MLSCommon, only: filenamelen, mlsfile_t, l2metadata_t
    use MLSFiles, only: hdfversion_5, &
      & addinitializemlsfile, dump, getmlsfilebyname, getpcfromref, &
      & mls_closefile, mls_openfile, split_path_name
    use MLSFinds, only: findfirst, findnext
d423 1
a423 1
    use outputandclose, only: add_metadata
d431 2
a432 2
    use vectorsmodule, only: vector_t, vectorvalue_t, validatevectorquantity, &
      & getvectorqtybytemplateindex
d573 1
d2340 1
a2340 1
       "$Id: Join.f90,v 2.166 2015/07/14 23:31:16 pwagner Exp $"
d2351 3
@


2.166
log
@label and inputFile fields in DirectWrite
@
text
@d730 27
a847 26
    ! Label quantities if we supplied labels on the command line
    if ( checkpaths ) then
      ! No, don't label if just messing around
    elseif ( prefixSignal .and. labelId > 0 ) then
      ! All sources have the same label suffix
      ! They differ only in which signal string they begin with
      do i=1, noSources
        qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(i)), sourceQuantities(i) )
        if ( qty%template%signal == 0 ) then
          call Announce_Error ( node, no_error_code, &
            & 'The quantity has no signal so prefixSignal is not appropriate' )
          cycle
        end if
        call GetSignalName ( qty%template%signal, labelStr, &
          & sideband=qty%template%sideband )
        call Get_String( labels(1), labelStr(len_trim(labelStr)+1:), strip=.true. )
        ! Now get an index for this possibly new name which may include the signal
        qty%label = enter_terminal ( trim(labelStr), t_string, caseSensitive=.true. )
      enddo
    else
      ! Each label corresponds to a source
      do i=1, labelId
        qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(i)), sourceQuantities(i) )
        qty%label = labels(i)
      enddo
    endif
d1558 2
a1559 2
      case ( l_l2aux, l_hdf )
        match = any ( type2 == (/ l_l2aux, l_hdf /) )
d2339 1
a2339 1
       "$Id: Join.f90,v 2.165 2015/05/05 16:47:25 pwagner Exp $"
d2350 3
@


2.165
log
@/noPCFid allows us to DirectWrite to files not named in PCF
@
text
@d396 3
a398 2
      & f_hdfversion, f_loweroverlap, f_noPCFid, f_options, f_precision, &
      & f_quality, f_rank, &
d410 1
d413 8
a420 8
    use MLSL2options, only: checkpaths, &
      & defAult_hdfversion_write, patch, skipdirectwrites, toolkit
    use MLSMessagemodule, only: mlsmessage, mlsmsg_error, mlsmsg_warning
    use MLSPCF2, ONLY: MLSPCF_L2GP_START, MLSPCF_L2GP_END, &
      & MLSPCF_L2DGM_START, MLSPCF_L2DGM_END, MLSPCF_L2FWM_FULL_START, &
      & MLSPCF_L2FWM_FULL_END, &
      & MLSPCF_L2DGG_START, MLSPCF_L2DGG_END
    use MLSFinds, only: findfirst, findnext
d425 2
d483 2
d488 2
d511 1
d532 1
d545 1
a545 1
    DEEBUG = ( switchDetail(switches, 'direct') > -1 ) ! .or. SKIPDIRECTWRITES
d569 1
d619 2
d628 2
d654 1
a654 1
      & precisionVectors, precisionQuantities, directFiles )
d676 2
d680 1
d723 3
d821 26
d1319 17
a1335 11
          ! Call the l2aux sd write routine.  This should write the 
          ! non-overlapped portion of qty (with possibly precision in precQty)
          ! into the l2aux sd named 'hdfName' starting at profile 
          ! qty%template%instanceOffset ( + 1 ? )
          ! Note sure about the +1 in this case, probably depends whether it's a
          ! minor frame quantity or not.  This mixed zero/one indexing is becoming
          ! a real pain.  I wish I never went down that road!
          call DirectWrite ( directFile, qty, precQty, hdfName, &
            & chunkNo, chunks, FWModelConfig, &
            & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
            & single=single, options=options )
d1339 10
a1348 4
          ! Write the quantity with all its geolocations
          ! call outputnamedValue( 'Calling DirectWrite with rank', rank )
          call DirectWrite ( directFile, qty, hdfName, &
            & chunkNo, options=options, rank=rank )
d1570 1
d1573 1
a1573 1
    use MLSSignals_m, only: getsignalname
d2338 1
a2338 1
       "$Id: Join.f90,v 2.164 2015/04/07 02:53:50 vsnyder Exp $"
d2349 3
@


2.164
log
@Correct error message about units for RANK, some cannonball polishing
@
text
@d395 3
a397 2
    use init_tables_module, only: f_convergence, f_file, f_hdfversion, &
      & f_loweroverlap, f_options, f_ascdescmode, f_precision, f_quality, f_rank, &
d497 1
d561 1
d601 2
d941 2
d2278 1
a2278 1
       "$Id: Join.f90,v 2.163 2015/03/31 21:01:07 pwagner Exp $"
d2289 3
@


2.163
log
@rank is a new field for DirectWrite-ing quantity values as, say, rank3
@
text
@d51 10
a60 9
    use allocate_deallocate, only: test_allocate
    use chunks_m, only: mlschunk_t
    use directwrite_m, only: directdata_t
    use dumpcommand_m, only: dumpcommand, &
      & mlscase, mlsendselect, mlsselect, mlsselecting, skip
    use forwardmodelconfig, only: forwardmodelconfig_t
    use hessianmodule_1, only: hessian_t
    use hgridsdatabase, only: hgrid_t
    use init_tables_module, only: s_l2gp, s_l2aux, s_time, s_directwrite, &
d62 5
a66 5
    use l2gpdata, only: l2gpdata_t
    use l2auxdata, only: l2auxdata_t
    use l2parinfo, only: parallel, waitfordirectwritepermission
    use lexer_core, only: print_source
    use matrixmodule_1, only: matrix_database_t
d68 4
a71 4
    use MLSL2options, only: checkpaths, l2cfnode, &
      & skipdirectwrites, specialDumpFile, MLSMessage
    use MLSL2timings, only: section_times, total_times, &
      & add_to_directwrite_timing, add_to_section_timing
d73 10
a82 9
    use moretree, only: get_label_and_spec, get_spec_id
    use next_tree_node_m, only: init_next_tree_node, next_tree_node, &
      & next_tree_node_state
    use output_m, only: output, revertoutput, switchoutput
    use toggles, only: gen, toggle, switches
    use tree, only: where_at => where
    use time_m, only: time_now
    use trace_m, only: trace_begin, trace_end
    use vectorsModule, only: vector_t
d614 2
a615 2
          & 'No units allowed for rank: just integer 1, 2, or 3')
        rank = exprValue(1)
d2271 1
a2271 1
       "$Id: Join.f90,v 2.162 2015/03/28 02:47:14 vsnyder Exp $"
d2282 3
@


2.162
log
@Paul added Quantity type to Direct write.
@
text
@d16 1
a16 1
  use MLSStringLists, only: SWITCHDETAIL
d51 30
a80 30
    use ALLOCATE_DEALLOCATE, only: TEST_ALLOCATE
    use CHUNKS_M, only: MLSCHUNK_T
    use DIRECTWRITE_M, only: DIRECTDATA_T
    use DUMPCOMMAND_M, only: DUMPCOMMAND, &
      & MLSCASE, MLSENDSELECT, MLSSELECT, MLSSELECTING, SKIP
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use HESSIANMODULE_1, only: HESSIAN_T
    use HGRIDSDATABASE, only: HGRID_T
    use INIT_TABLES_MODULE, only: S_L2GP, S_L2AUX, S_TIME, S_DIRECTWRITE, &
      & S_ENDSELECT, S_CASE, S_DIFF, S_DUMP, S_LABEL, S_SELECT, S_SKIP
    use L2GPDATA, only: L2GPDATA_T
    use L2AUXDATA, only: L2AUXDATA_T
    use L2PARINFO, only: PARALLEL, WAITFORDIRECTWRITEPERMISSION
    use LEXER_CORE, only: PRINT_SOURCE
    use MatrixModule_1, only: MATRIX_DATABASE_T
    use MLSCOMMON, only: MLSFILE_T
    use MLSL2OPTIONS, only: CHECKPATHS, L2CFNODE, &
      & SKIPDIRECTWRITES, SPECIALDUMPFILE, MLSMESSAGE
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES, &
      & ADD_TO_DIRECTWRITE_TIMING, ADD_TO_SECTION_TIMING
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR
    use MORETREE, only: Get_Label_And_Spec, GET_SPEC_ID
    use Next_Tree_Node_m, only: Init_Next_Tree_Node, Next_Tree_Node, &
      & Next_Tree_Node_State
    use OUTPUT_M, only: OUTPUT, REVERTOUTPUT, SWITCHOUTPUT
    use TOGGLES, only: GEN, TOGGLE, SWITCHES
    use TREE, only: Where_At => Where
    use TIME_M, only: TIME_NOW
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use VECTORSMODULE, only: VECTOR_T
d382 30
a411 30
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use CHUNKS_M, only: MLSCHUNK_T
    use DIRECTWRITE_M, only: DIRECTDATA_T, &
      & DIRECTWRITE, DUMP, &
      & EXPANDDIRECTDB, EXPANDSDNAMES, FILENAMETOID
    use DUMP_0, only: DUMP
    use EXPR_M, only: EXPR
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use HDF, only: DFACC_CREATE, DFACC_RDWR
    use HGRIDSDATABASE, only: HGRID_T
    use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
    use INIT_TABLES_MODULE, only: F_CONVERGENCE, F_FILE, F_HDFVERSION, &
      & F_LOWEROVERLAP, F_OPTIONS, F_AscDescMode, F_PRECISION, F_QUALITY, &
      & F_SINGLE, F_SOURCE, F_STATUS, F_TYPE, F_UPPEROVERLAP, F_VECTOR, &
      & FIELD_FIRST, FIELD_LAST
    use INIT_TABLES_MODULE, only: L_L2GP, L_L2AUX, L_L2DGG, L_L2FWM, &
      & L_PRESSURE, L_QUANTITY, L_ZETA
    use INTRINSIC, only: L_NONE, L_HDF, L_SWATH, LIT_INDICES, PHYQ_DIMENSIONLESS
    use L2PARINFO, only: PARALLEL, LOGDIRECTWRITEREQUEST, FINISHEDDIRECTWRITE
    use MANIPULATEVECTORQUANTITIES, only: DOHGRIDSMATCH
    use MLSCOMMON, only: FILENAMELEN, MLSFILE_T, L2METADATA_T
    use MLSFILES, only: HDFVERSION_5, &
      & ADDINITIALIZEMLSFILE, DUMP, GETMLSFILEBYNAME, GETPCFROMREF, &
      & MLS_CLOSEFILE, MLS_OPENFILE, SPLIT_PATH_NAME
    use MLSHDFEOS, only: MLS_SWATH_IN_FILE
    use MLSKINDS, only: R8
    use MLSL2OPTIONS, only: CHECKPATHS, &
      & DEFAULT_HDFVERSION_WRITE, PATCH, SKIPDIRECTWRITES, TOOLKIT
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
    use MLSPCF2, only: MLSPCF_L2GP_START, MLSPCF_L2GP_END, &
d415 11
a425 11
    use MLSFINDS, only: FINDFIRST, FINDNEXT
    use MORETREE, only: GET_FIELD_ID, GET_BOOLEAN
    use OUTPUT_M, only: BLANKS, OUTPUT
    use OUTPUTANDCLOSE, only: ADD_METADATA
    use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
    use TIME_M, only: TIME_NOW
    use TOGGLES, only: GEN, TOGGLE, SWITCHES
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
    use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T, VALIDATEVECTORQUANTITY, &
      & GETVECTORQTYBYTEMPLATEINDEX
d499 1
d561 1
d608 7
d999 3
d1141 1
a1141 1
              & chunkNo, options=options )
d1278 1
d1280 1
a1280 1
            & chunkNo, options=options )
d1494 2
a1495 1
        match = .false.
d1502 10
a1511 10
    use INIT_TABLES_MODULE, only: F_LABEL, F_PREFIXSIGNAL, &
      & F_QUANTITY, F_VECTOR
    use MLSSIGNALS_M, only: GETSIGNALNAME
    use MORETREE, only: GET_FIELD_ID, GET_BOOLEAN
    use SYMBOL_TABLE, only: ENTER_TERMINAL
    use SYMBOL_TYPES, only: T_STRING
    use STRING_TABLE, only: GET_STRING
    use TREE, only: NSONS, SUBTREE, SUB_ROSA, DECORATION
    use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T, &
      & GETVECTORQUANTITY, GETVECTORQTYBYTEMPLATEINDEX
d1605 20
a1624 20
    use CHUNKS_M, only: MLSCHUNK_T
    ! use EXPR_M, only: EXPR
    use INIT_TABLES_MODULE, only: &
      & F_PRECISION, F_PREFIXSIGNAL, F_SOURCE, F_SDNAME, F_SWATH, FIELD_FIRST, &
      & FIELD_LAST
    use INIT_TABLES_MODULE, only: L_PRESSURE, L_ZETA, S_L2AUX, S_L2GP
    use INTRINSIC, only: L_NONE! , PHYQ_DIMENSIONLESS
    use L2AUXDATA, only: L2AUXDATA_T
    use L2GPDATA, only: L2GPDATA_T
    use L2PARINFO, only: PARALLEL, SLAVEJOIN
    ! use MLSKINDS, only: R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSSIGNALS_M, only: GETSIGNALNAME
    use MORETREE, only: GET_BOOLEAN, GET_FIELD_ID, GET_SPEC_ID
    use STRING_TABLE, only: GET_STRING
    use SYMBOL_TABLE, only: ENTER_TERMINAL
    use SYMBOL_TYPES, only: T_STRING
    use TREE, only: DECORATION, NSONS, NULL_TREE, SUB_ROSA, SUBTREE
    use VECTORSMODULE, only: GETVECTORQTYBYTEMPLATEINDEX, &
      & VALIDATEVECTORQUANTITY, VECTOR_T, VECTORVALUE_T
d1791 10
a1800 10
    use INIT_TABLES_MODULE, only: L_PRESSURE, L_ZETA
    use INTRINSIC, only: L_NONE
    use L2GPDATA, only: ADDL2GPTODATABASE, EXPANDL2GPDATAINPLACE, &
      & L2GPDATA_T, SETUPNEWL2GPRECORD, RGP
    use MLSKINDS, only: RV
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, TOGGLE, LEVELS
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATE, DECORATION
    use VECTORSMODULE, only: VECTORVALUE_T
d1963 12
a1974 12
    use CHUNKS_M, only: MLSCHUNK_T
    use INTRINSIC, only: L_GEODANGLE, L_MAF
    use L2AUXDATA, only: ADDL2AUXTODATABASE, RESIZEL2AUXDATA, &
      & L2AUXDATA_T, L2AUXRANK, SETUPNEWL2AUXRECORD
    use MLSKINDS, only: R4, R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use OUTPUT_M, only: OUTPUT
    use STRING_TABLE, only: DISPLAY_STRING
    use TOGGLES, only: GEN, TOGGLE, LEVELS, SWITCHES
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATE, DECORATION
    use VECTORSMODULE, only: VECTORVALUE_T
d2203 3
a2205 3
    use INIT_TABLES_MODULE, only: F_FILE
    use MORETREE, only: GET_FIELD_ID
    use TREE, only: NSONS, SUBTREE
d2228 5
a2232 5
    use INTRINSIC, only: FIELD_INDICES
    use LEXER_CORE, only: PRINT_SOURCE
    use OUTPUT_M, only: OUTPUT
    use STRING_TABLE, only: DISPLAY_STRING
    use TREE, only: Where_At => Where
d2269 1
a2269 1
       "$Id: Join.f90,v 2.161 2014/04/07 18:03:28 pwagner Exp $"
d2280 3
@


2.161
log
@May specify AscDescMode when DirectWrite-ing swaths
@
text
@d56 2
a60 2
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use HESSIANMODULE_1, only: HESSIAN_T
d398 1
a398 1
      & L_PRESSURE, L_ZETA
d761 2
d1010 1
a1010 1
      case ( l_l2aux, l_hdf )
d1075 1
a1075 1
      case ( l_l2aux, l_l2fwm, l_hdf )
d1117 4
a1120 5
            call DirectWrite ( directFile, &
              & vector, &
              & chunkNo, HGrids, &
              & createSwath=.true., &
              & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
d1126 4
d1256 2
a1257 2
          ! minor frame quantity or not.  This mixed zero/one indexing is beomming
          ! a real pain.  I wish I never want down that road!
d1264 6
d1364 1
a1364 1
      case ( l_l2aux, l_l2fwm, l_hdf )
d1368 1
d2255 1
a2255 1
       "$Id: Join.f90,v 2.160 2014/03/31 23:43:49 pwagner Exp $"
d2266 3
@


2.160
log
@Commented-out unused stuff; renamed procedure ResizeL2AUXData, generalizing it to expand or contract
@
text
@d393 4
a396 3
    use INIT_TABLES_MODULE, only: F_CONVERGENCE, F_FILE, &
      & F_HDFVERSION, F_LOWEROVERLAP, F_OPTIONS, F_PRECISION, F_QUALITY, &
      & F_SINGLE, F_SOURCE, F_STATUS, F_TYPE, F_UPPEROVERLAP, F_VECTOR
d469 1
d492 2
d523 1
d555 1
d567 1
d572 4
d696 3
d1222 1
a1222 1
            & qty, precQty, qualityQty, statusQty, convergQty, &
d1234 1
a1234 1
              & qty, precQty, qualityQty, statusQty, convergQty, &
d2243 1
a2243 1
       "$Id: Join.f90,v 2.159 2014/01/11 01:44:18 vsnyder Exp $"
d2254 3
@


2.159
log
@Decruftification
@
text
@d29 1
a29 1
  logical, parameter, private :: FORCEDIRWRITEREOPEN = .false. ! Usually FALSE
d96 1
a96 1
    integer, parameter :: DELAY = 500000  ! For Usleep, no. microsecs
d478 1
a478 1
    integer :: LASTFIELDINDEX           ! Type of previous field in l2cf line
d543 1
a543 1
    lastFieldIndex = 0
d559 1
a559 1
      if ( keyNo > 2 ) lastFieldIndex = fieldIndex
d1463 1
a1463 1
      & F_QUANTITY, F_SUFFIXLABEL, F_VECTOR
d1484 1
a1484 1
    logical :: SUFFIXLABEL              ! From l2cf
d1508 2
a1509 2
      case ( f_suffixLabel )
        suffixLabel = get_boolean ( son )
d1566 1
a1566 1
    use EXPR_M, only: EXPR
a1567 1
      & F_COMPAREOVERLAPS, F_FILE, F_HDFVERSION, F_OUTPUTOVERLAPS, &
d1571 1
a1571 1
    use INTRINSIC, only: L_NONE, PHYQ_DIMENSIONLESS
d1575 1
a1575 1
    use MLSKINDS, only: R8
d1595 1
a1595 1
    integer :: EXPRUNITS(2)                 ! From expr
d1597 1
a1597 1
    integer :: FILE                     ! Name of output file for direct write
d1599 1
a1599 1
    integer :: HDFVERSION               ! Version of hdf for directwrite
d1609 2
a1610 2
    logical :: COMPAREOVERLAPS
    logical :: OutputOverlaps
d1612 1
a1612 1
    real (r8) :: EXPRVALUE(2)               ! From expr
d1625 2
a1626 2
    compareOverlaps = .false.
    outputOverlaps = .false.
d1629 1
a1629 1
    hdfVersion = 4
d1645 6
a1650 6
      case ( f_hdfVersion )
        call expr ( subtree(2,son), exprUnits, exprValue )
        if ( exprUnits(1) /= phyq_dimensionless ) &
          & call Announce_error ( son, NO_ERROR_CODE, &
          & 'No units allowed for hdfVersion: just integer 4 or 5')
        hdfVersion = exprValue(1)
d1653 4
a1656 4
      case ( f_compareoverlaps )
        compareOverlaps = get_boolean(son)
      case ( f_outputoverlaps )
        outputOverlaps = get_boolean(son)
d1661 2
a1662 2
      case ( f_file )
        file = sub_rosa(subtree(2,son))
d1668 3
a1670 3
    if ( any ( got ( (/ f_file, f_hdfVersion /) ) ) ) &
      & call Announce_Error ( key, NO_ERROR_CODE, &
      & 'File or hdfVersion not appropriate arguments for output l2aux/l2gp' )
d1925 1
a1925 1
    use L2AUXDATA, only: ADDL2AUXTODATABASE, EXPANDL2AUXDATAINPLACE, &
d2061 1
a2061 1
      call ExpandL2AUXDataInPlace ( thisL2AUX, noOutputInstances )
d2229 1
a2229 1
       "$Id: Join.f90,v 2.158 2014/01/09 00:30:24 pwagner Exp $"
d2240 3
@


2.158
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d77 1
a77 1
    use TREE, only: SUBTREE, NSONS, Where_At => Where
d2230 1
a2230 1
       "$Id: Join.f90,v 2.157 2013/12/12 02:11:26 vsnyder Exp $"
d2241 3
@


2.157
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d392 1
d416 1
a416 1
    use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE
d2230 1
a2230 1
       "$Id: Join.f90,v 2.156 2013/11/01 00:15:15 pwagner Exp $"
d2241 3
@


2.156
log
@Match trace_begins and _ends scrupulously
@
text
@a55 1
    use Evaluate_Variable_m, only: Evaluate_Variable
d72 3
a74 1
    use MORETREE, only: GET_SPEC_ID
d77 1
a77 2
    use TREE, only: SUBTREE, NSONS, NODE_ID, Where_At => Where
    use TREE_TYPES, only: N_NAMED, N_Variable
d109 1
a110 1
    integer :: MLSCFLINE                ! Line number in l2cf
d117 1
d181 5
a185 11
      do mlscfLine = 2, nsons(root) - 1 ! Skip begin/end section
        son = subtree(mlscfLine,root)
        if ( node_id(son) == n_variable ) then
          call evaluate_variable ( son )
      cycle
        end if
        if ( node_id(son) == n_named ) then ! Is spec labeled?
          key = subtree(2,son)
        else
          key = son
        end if
d225 1
a225 1
            call JoinQuantities ( son, vectors, l2gpDatabase, l2auxDatabase, &
d2229 1
a2229 1
       "$Id: Join.f90,v 2.155 2013/10/09 23:41:36 vsnyder Exp $"
d2240 3
@


2.155
log
@Add Evaluate_Variable
@
text
@d550 1
d766 5
a770 1
    if ( error /= 0 ) return
d795 2
d1313 2
d2234 1
a2234 1
       "$Id: Join.f90,v 2.154 2013/09/24 23:47:22 vsnyder Exp $"
d2245 3
@


2.154
log
@Use Where instead of Source_Ref for messages
@
text
@d56 1
d77 1
a77 1
    use TREE_TYPES, only: N_NAMED
d182 4
d2225 1
a2225 1
       "$Id: Join.f90,v 2.153 2013/09/04 17:35:23 pwagner Exp $"
d2236 3
@


2.153
log
@Replaced '--cat' cmdline option; 'Catenate' now an Output section command
@
text
@d75 1
a75 1
    use TREE, only: SUBTREE, NSONS, NODE_ID, SOURCE_REF
d267 1
a267 1
            if(DEEBUG)call print_source ( source_ref(son) )
d280 1
a280 1
              if(DEEBUG)call print_source ( source_ref(son) )
d2183 1
a2183 1
    use TREE, only: SOURCE_REF
d2199 1
a2199 1
      call print_source ( source_ref(where) )
d2220 1
a2220 1
       "$Id: Join.f90,v 2.152 2013/08/30 02:45:42 vsnyder Exp $"
d2231 3
@


2.152
log
@Revise calls to trace_begin and trace_end
@
text
@d36 3
a38 2
  integer, parameter :: NO_ERROR_CODE=0
  integer, parameter :: NotAllowed=1
d406 1
a406 1
    use MLSL2OPTIONS, only: CATENATESPLITS, CHECKPATHS, &
d2220 1
a2220 1
       "$Id: Join.f90,v 2.151 2013/08/12 23:49:41 pwagner Exp $"
d2231 3
@


2.151
log
@FindSomethings moved to MLSFinds module
@
text
@d107 1
d127 1
a127 1
    if ( toggle(gen) ) call trace_begin ( "MLSL2Join", root )
d335 1
a335 1
    if ( toggle(gen) ) call trace_end ( "MLSL2Join" )
d353 1
a353 1
  ! ------------------------------------------------ DirectWriteCommand -----
d477 2
a478 1
    integer :: MYFILE              ! File permission granted for
d528 2
a529 2
    if ( toggle(gen) .and. switchDetail(switches,'dwreq') > -1 ) &
      & call trace_begin ( "DirectWriteCommand", node )
d831 2
a832 2
      if ( toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 ) &
        & call trace_end ( "DirectWriteCommand" )
d838 2
a839 2
      if ( toggle(gen) .and. switchDetail(switches, 'dwreq') > -1 ) &
        & call trace_end ( "DirectWriteCommand" )
d854 2
a855 2
          if ( toggle(gen) .and. switchDetail(switches,'dwreq') > -1 ) &
            & call trace_end ( "DirectWriteCommand" )
d944 2
a945 2
        if ( toggle(gen) .and. switchDetail(switches,'dwreq') > -1 ) &
        & call trace_end ( "DirectWriteCommand" )
d1364 2
a1365 2
    if ( toggle(gen) .and. switchDetail(switches,'dwreq') > -1 ) &
      & call trace_end ( "DirectWriteCommand" )
d1769 2
a1773 1
    real(rv) :: HUGERGP
d1776 2
a1777 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_begin ( "JoinL2GPQuantities", key )
d1901 2
a1902 1
    if ( toggle(gen) .and. levels(gen) > 0 ) call trace_end ( "JoinL2GPQuantities" )
d1944 1
d1958 2
a1959 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_begin ( "JoinL2AUXQuantities", key )
d2143 2
a2144 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_end ( "JoinL2AUXQuantities" )
d2219 1
a2219 1
       "$Id: Join.f90,v 2.150 2012/08/16 17:58:24 pwagner Exp $"
d2230 3
@


2.150
log
@Exploit level 2-savvy MLSMessage
@
text
@d411 1
a411 1
    use MLSSETS, only: FINDFIRST, FINDNEXT
d2214 1
a2214 1
       "$Id: Join.f90,v 2.149 2012/07/02 20:40:43 pwagner Exp $"
d2225 3
@


2.149
log
@Once-routine output now requires verbosity > 0
@
text
@d66 2
a67 1
    use MLSL2OPTIONS, only: CHECKPATHS, SKIPDIRECTWRITES, SPECIALDUMPFILE
d70 1
a70 1
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
d184 1
d2214 1
a2214 1
       "$Id: Join.f90,v 2.148 2012/05/08 17:51:11 pwagner Exp $"
d2225 3
@


2.148
log
@Added Select .. Case .. EndSelect control structure
@
text
@d163 8
a170 6
        call output ( "Got permission for ticket " )
        call output ( ticket )
        call output ( " node " )
        call output ( directWriteNodeGranted, advance='no' )
        call output ( " file " )
        call output ( trim(theFile), advance='yes' )
d2212 1
a2212 1
       "$Id: Join.f90,v 2.147 2012/05/01 23:16:35 pwagner Exp $"
d2223 3
@


2.147
log
@Partly retreated from last optimistic commit
@
text
@d53 2
a54 1
    use DUMPCOMMAND_M, only: DUMPCOMMAND, SKIP
d57 1
a57 1
      & S_DIFF, S_DUMP, S_LABEL, S_SKIP
d181 2
d197 9
d2210 1
a2210 1
       "$Id: Join.f90,v 2.146 2012/03/12 17:22:20 pwagner Exp $"
d2221 3
@


2.146
log
@Believe we can drop odious workaround for hdfeos 'bug'--may have been our mistake
@
text
@d1190 8
d2198 1
a2198 1
       "$Id: Join.f90,v 2.145 2012/02/24 21:19:44 pwagner Exp $"
d2209 3
@


2.145
log
@May DirectWrite a /single instance only
@
text
@d1174 11
a1184 3
          ! We have a bug somewhere in hdfeos
          ! When we create the first swath in an hdfeos file
          ! mls_swath_in_file can't find it
d1186 3
a1188 22
            do while ( createthisswath )
              call DirectWrite ( directFile, &
                & qty, precQty, qualityQty, statusQty, convergQty, &
                & hdfName, chunkNo, HGrids, &
                & createSwath=.true., &
                & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
              createthisswath = .not. &
                & mls_swath_in_file( directFile%name, hdfName, hdfVersion, returnStatus )
              if(DEEBUG)print *, 'file name ', trim(directFile%name)
              if(DEEBUG)print *, 'hdfName ', trim(hdfName)
              if(DEEBUG)print *, 'still need to createthisswath ', createthisswath
              if ( createthisswath ) &
                & call MLSMessage ( MLSMSG_Warning, ModuleName, &
                  & 'Needed to recreate swath ' // trim(hdfName) // ' in ' // &
                  & trim(directFile%name) )
            enddo
          else
            call DirectWrite ( directFile, &
              & qty, precQty, qualityQty, statusQty, convergQty, &
              & hdfName, chunkNo, HGrids, &
              & createSwath=.false., &
              & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
d2190 1
a2190 1
       "$Id: Join.f90,v 2.144 2011/11/04 00:09:53 pwagner Exp $"
d2201 3
@


2.144
log
@Fixed bug that prevented writing matched output types
@
text
@d16 1
a16 1
  use MLSStringLists, only: SwitchDetail
d376 1
a376 1
      & F_SOURCE, F_STATUS, F_TYPE, F_UPPEROVERLAP, F_VECTOR
d476 1
d533 1
d574 2
d1070 1
d1083 1
a1083 1
              & options=options )
d1218 1
a1218 1
            & options=options )
d2201 1
a2201 1
       "$Id: Join.f90,v 2.143 2011/10/07 00:06:02 pwagner Exp $"
d2212 3
@


2.143
log
@May dump Matrices, Hessians from Fill, Join
@
text
@d374 3
a376 3
    use INIT_TABLES_MODULE, only: F_CONVERGENCE, F_FILE, F_HDFVERSION, &
      & F_LOWEROVERLAP, F_PRECISION, F_QUALITY, F_SOURCE, F_STATUS, F_TYPE, &
      & F_UPPEROVERLAP, F_VECTOR
d469 1
d528 1
d560 2
d812 1
a812 1
    else if ( skipdgm .and. any ( outputType == (/ l_l2fwm, l_l2aux /) ) ) then
d941 2
a942 1
        if ( outputType /= thisDirect%type ) then
d963 1
a963 1
      case ( l_l2aux )
d1028 1
a1028 1
      case ( l_l2aux, l_l2fwm )
d1074 1
a1074 1
          case ( l_l2aux, l_l2fwm )
d1077 2
a1078 1
              & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
d1202 1
a1202 1
        case ( l_l2aux, l_l2fwm )
d1212 2
a1213 1
            & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
d1260 1
a1260 1
        case ( l_l2gp, l_l2dgg, l_l2aux, l_l2fwm )
d1308 1
a1308 1
      case ( l_l2aux, l_l2fwm )
d1326 1
a1326 1
        & outputType /= l_l2fwm .and. &
d1412 15
d2196 1
a2196 1
       "$Id: Join.f90,v 2.142 2011/05/09 18:18:45 pwagner Exp $"
d2207 3
@


2.142
log
@Consistent with new api for DirectWrite
@
text
@d47 2
a48 1
    & DirectDataBase, chunkNo, chunks, FWModelConfig, filedatabase, HGrids )
d58 1
d63 1
d88 2
d189 2
a190 1
            & ForwardModelConfigs=FWModelConfig, FileDataBase=FileDataBase )
d2174 1
a2174 1
       "$Id: Join.f90,v 2.141 2009/10/26 17:11:53 pwagner Exp $"
d2185 3
@


2.141
log
@Added Diff command to be used like Dump in l2cf
@
text
@d49 6
a54 6
    use Allocate_Deallocate, only: Test_Allocate
    use Chunks_m, only: MLSChunk_T
    use DirectWrite_m, only: DirectData_T
    use DumpCommand_m, only: DumpCommand, Skip
    use HGridsDatabase, only: HGrid_T
    use Init_Tables_Module, only: S_L2GP, S_L2AUX, S_TIME, S_DIRECTWRITE, &
d56 4
a59 4
    use ForwardModelConfig, only: ForwardModelConfig_T
    use L2GPData, only: L2GPDATA_T
    use L2AUXData, only: L2AUXDATA_T
    use L2ParInfo, only: PARALLEL, WAITFORDIRECTWRITEPERMISSION
d61 7
a67 7
    use MLSCommon, only: MLSFile_T
    use MLSL2Options, only: CHECKPATHS, SKIPDIRECTWRITES, SPECIALDUMPFILE
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES, &
      & add_to_directwrite_timing, add_to_section_timing
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MoreTree, only: GET_SPEC_ID
    use Output_m, only: OUTPUT, revertoutput, switchOutput
d69 1
a69 1
    use Tree, only: SUBTREE, NSONS, NODE_ID, SOURCE_REF
d71 1
a71 1
    use Time_M, only: Time_Now
d73 1
a73 1
    use VectorsModule, only: VECTOR_T
d358 14
a371 14
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use Chunks_m, only: MLSChunk_T
    use DirectWrite_m, only: DirectData_T, &
      & DirectWrite_l2GP, DirectWrite_l2aux, Dump, &
      & ExpandDirectDB, ExpandSDNames, FileNameToID
    use dump_0, only: dump
    use Expr_m, only: EXPR
    use ForwardModelConfig, only: ForwardModelConfig_T
    use Hdf, only: DFACC_CREATE, DFACC_RDWR
    use HGridsDatabase, only: HGrid_T
    use Init_tables_module, only: F_CONVERGENCE, F_FILE, F_HDFVERSION, &
      & F_LOWEROVERLAP, F_PRECISION, f_QUALITY, F_SOURCE, F_STATUS, F_TYPE, &
      & F_UPPEROVERLAP
    use Init_tables_module, only: L_L2GP, L_L2AUX, L_L2DGG, L_L2FWM, &
d373 10
a382 9
    use intrinsic, only: L_NONE, L_HDF, L_SWATH, Lit_indices, PHYQ_DIMENSIONLESS
    use L2ParInfo, only: PARALLEL, LOGDIRECTWRITEREQUEST, FINISHEDDIRECTWRITE
    use ManipulateVectorQuantities, only: DOHGRIDSMATCH
    use MLSCommon, only: R8, FileNameLen, MLSFile_T, L2Metadata_T
    use MLSFiles, only: HDFVERSION_5, &
      & AddInitializeMLSFile, dump, GetMLSFileByName, GetPCFromRef, &
      & mls_closeFile, mls_openFile, Split_path_name
    use MLSHDFEOS, only: mls_swath_in_file
    use MLSL2Options, only: CATENATESPLITS, CHECKPATHS, &
d384 11
a394 11
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSPCF2, only: mlspcf_l2gp_start, mlspcf_l2gp_end, &
      & mlspcf_l2dgm_start, mlspcf_l2dgm_end, mlspcf_l2fwm_full_start, &
      & mlspcf_l2fwm_full_end, &
      & mlspcf_l2dgg_start, mlspcf_l2dgg_end
    use MLSSets, only: FindFirst, FindNext
    use MoreTree, only: GET_FIELD_ID, GET_BOOLEAN
    use Output_m, only: Blanks, OUTPUT, outputNamedValue
    use OutputAndClose, only: add_metadata
    use String_Table, only: DISPLAY_STRING, GET_STRING
    use Time_M, only: Time_Now
d398 1
a398 1
    use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VALIDATEVECTORQUANTITY, &
d491 2
a492 1
    type(DirectData_T), pointer :: thisDirect ! => null()
d531 1
a531 1
      case ( f_source )
d579 20
a598 10
    call Allocate_test ( sourceQuantities, noSources, 'sourceQuantities', ModuleName )
    call Allocate_test ( precisionVectors, noSources, 'precisionVectors', ModuleName )
    call Allocate_test ( precisionQuantities, noSources, 'precisionQuantities', ModuleName )
    call Allocate_test ( qualityVectors, noSources, 'qualityVectors', ModuleName )
    call Allocate_test ( qualityQuantities, noSources, 'qualityQuantities', ModuleName )
    call Allocate_test ( statusVectors, noSources, 'statusVectors', ModuleName )
    call Allocate_test ( statusQuantities, noSources, 'statusQuantities', ModuleName )
    call Allocate_test ( convergVectors, noSources, 'convergVectors', ModuleName )
    call Allocate_test ( convergQuantities, noSources, 'convergQuantities', ModuleName )
    call Allocate_test ( directFiles, noSources, 'directFiles', ModuleName )
a600 8
    precisionVectors = 0
    precisionQuantities = 0
    qualityVectors = 0
    qualityQuantities = 0
    statusVectors = 0
    statusQuantities = 0
    convergVectors = 0
    convergQuantities = 0
a601 1
    directFiles = 0
d640 3
d651 1
d989 7
a995 2
            qty => GetVectorQtyByTemplateIndex ( &
              & vectors(sourceVectors(source)), sourceQuantities(source) )
d1054 17
d1162 1
a1162 1
              call DirectWrite_l2GP ( directFile, &
d1178 1
a1178 1
            call DirectWrite_l2GP ( directFile, &
d1198 1
a1198 1
          call DirectWrite_L2Aux ( directFile, qty, precQty, hdfName, &
d1403 9
a1411 1
    use VectorsModule, only: VECTOR_T, VECTORVALUE_T, &
a1412 9
    use MoreTree, only: GET_FIELD_ID, GET_BOOLEAN
    use Init_tables_module, only: F_LABEL, F_PREFIXSIGNAL, &
      & F_QUANTITY, F_SUFFIXLABEL, F_VECTOR
    ! use Output_m, only: outputNamedValue
    use Symbol_Table, only: ENTER_TERMINAL
    use Symbol_Types, only: T_STRING
    use String_Table, only: GET_STRING
    use MLSSignals_m, only: GETSIGNALNAME
    use Tree, only: NSONS, SUBTREE, SUB_ROSA, DECORATION
d1506 2
a1507 2
    use Chunks_m, only: MLSChunk_T
    use Expr_m, only: EXPR
d1513 11
a1523 11
    use intrinsic, only: L_NONE, PHYQ_DIMENSIONLESS
    use L2AUXData, only: L2AUXData_T
    use L2GPData, only: L2GPData_T
    use L2ParInfo, only: PARALLEL, SLAVEJOIN
    use MLSCommon, only: R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_M, only: GetSignalName
    use MoreTree, only: GET_BOOLEAN, GET_FIELD_ID, GET_SPEC_ID
    use String_Table, only: GET_STRING
    use Symbol_Table, only: ENTER_TERMINAL
    use Symbol_Types, only: T_STRING
d1525 2
a1526 2
    use VectorsModule, only: GetVectorQtyByTemplateIndex, &
      & ValidateVectorQuantity, Vector_T, VectorValue_T
d1694 5
a1698 5
    use intrinsic, only: L_NONE
    use L2GPData, only: AddL2GPToDatabase, ExpandL2GPDataInPlace, &
      & L2GPData_T, SetupNewL2GPRecord, RGP
    use MLSCommon, only: RV
    use String_Table, only: GET_STRING
d1702 1
a1702 1
    use VectorsModule, only: VectorValue_T
d1863 6
a1868 6
    use Chunks_m, only: MLSChunk_T
    use intrinsic, only: L_GEODANGLE, L_MAF
    use L2AUXData, only: AddL2AUXToDatabase, ExpandL2AUXDataInPlace, &
      & L2AUXData_T, L2AUXRank, SetupNewL2AUXRecord
    use MLSCommon, only: R4, R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d1870 1
a1870 1
    use String_Table, only: DISPLAY_STRING
d1874 1
a1874 1
    use VectorsModule, only: VectorValue_T
d2102 2
a2103 2
    use Init_tables_module, only: F_FILE
    use MoreTree, only: GET_FIELD_ID
d2127 1
a2127 1
    use intrinsic, only: FIELD_INDICES
d2130 1
a2130 1
    use String_Table, only: DISPLAY_STRING
d2168 1
a2168 1
       "$Id: Join.f90,v 2.140 2009/09/29 23:40:45 pwagner Exp $"
d2179 3
@


2.140
log
@Unjam error message when DirectWrite type is unexpected
@
text
@d55 1
a55 1
      & S_DUMP, S_LABEL, S_SKIP
d177 1
a177 1
        case ( s_dump ) ! ============================== Dump ==========
d2140 1
a2140 1
       "$Id: Join.f90,v 2.139 2009/06/23 18:46:18 pwagner Exp $"
d2151 3
@


2.139
log
@Prevent Intel from optimizing ident string away
@
text
@d25 1
a25 1
       "$RCSfile: $"
d709 1
a709 1
        call display_string ( lit_indices(expectedType) )
d711 1
a711 1
        call display_string ( lit_indices(outputType) )
d2140 1
a2140 1
       "$Id: read_apriori.f90 is it here $"
d2151 3
@


2.138
log
@Add NRT Lat and Lon bounding to metadata
@
text
@d25 1
a25 1
       "$RCSfile: Join.f90,v $"
d2137 1
a2138 1
!---------------------------- RCS Ident Info -------------------------------
d2140 2
a2141 3
       "$Id: Join.f90,v 2.137 2009/04/23 23:02:25 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2143 1
a2143 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2145 1
d2151 3
@


2.137
log
@May specify upperOverlap or lowerOverlap in DirectWrites
@
text
@d376 1
a376 1
    use MLSCommon, only: R8, FileNameLen, MLSFile_T
d492 2
d1286 1
a1286 1
        call add_metadata ( node, file_base, &
d2140 1
a2140 1
       "$Id: Join.f90,v 2.136 2009/04/01 23:35:59 pwagner Exp $"
d2151 3
@


2.136
log
@First attempt at fixing bug that wrote missing values to Temperature-APriori
@
text
@d248 1
a248 1
              & NoExtraWrites=noExtraWrites)
d356 1
a356 1
    & noExtraWrites, namedFile)
d369 2
a370 1
      & F_PRECISION, f_QUALITY, F_SOURCE, F_STATUS, F_TYPE
d389 1
a389 1
    use MoreTree, only: GET_FIELD_ID
d451 1
d472 1
d516 1
d520 1
d554 4
d999 1
a999 1
          call outputNamedValue ( 'source number of T', source )
d1123 1
a1124 1
          call outputNamedValue ( 'source number of DW', source )
d1134 2
a1135 1
                & createSwath=.true. )
d1150 2
a1151 1
              & createSwath=.false. )
d1168 2
a1169 1
            & chunkNo, chunks, FWModelConfig )
d2138 1
a2138 1
       "$Id: Join.f90,v 2.135 2008/12/18 21:14:24 pwagner Exp $"
d2149 3
@


2.135
log
@May now dump an l2pc or allL2PCs (use with caution)
@
text
@d258 2
d363 1
d389 1
a389 1
    use Output_m, only: Blanks, OUTPUT
d426 1
d967 1
d979 2
d988 3
d1019 1
d1115 27
a1141 4
          call DirectWrite_l2GP ( directFile, &
            & qty, precQty, qualityQty, statusQty, convergQty, &
            & hdfName, chunkNo, HGrids, &
            & createSwath=(.not. createThisSource(source)) )
d2126 1
a2126 1
       "$Id: Join.f90,v 2.134 2008/12/02 23:27:09 pwagner Exp $"
d2137 3
@


2.134
log
@May automatically label every quantity in a vector now
@
text
@d184 1
a184 1
            & ForwardModelConfigs=FWModelConfig )
d1331 1
a1331 1
    use Output_m, only: outputNamedValue
d2092 1
a2092 1
       "$Id: Join.f90,v 2.133 2007/12/07 01:50:52 pwagner Exp $"
d2103 3
@


2.133
log
@Removed unused dummy variables, etc.
@
text
@d180 1
d1326 2
a1327 1
    use VectorsModule, only: VECTOR_T, VECTORVALUE_T, GETVECTORQTYBYTEMPLATEINDEX
d1329 3
a1331 1
    use Init_tables_module, only: F_QUANTITY, F_PREFIXSIGNAL, F_LABEL
d1349 3
d1355 1
d1367 4
d1373 2
d1381 17
a1397 9
    ! Get the quantity
    qty => GetVectorQtyByTemplateIndex ( vectors(vectorIndex), quantityIndex )

    ! Adapt the label if the prefix signal flag is set.
    if ( prefixSignal ) then
      if ( qty%template%signal == 0 ) then
        call Announce_Error ( node, no_error_code, &
          & 'The quantity has no signal so prefixSignal is not appropriate' )
        return
a1398 6
      call GetSignalName ( qty%template%signal, labelStr, &
        & sideband=qty%template%sideband )
      call Get_String( label, labelStr(len_trim(labelStr)+1:), strip=.true. )
      ! Now get an index for this possibly new name which may include the signal
      label = enter_terminal ( trim(labelStr), t_string, caseSensitive=.true. )
    end if
d1400 22
a1421 2
    ! Attach the label
    qty%label = label
d2092 1
a2092 1
       "$Id: Join.f90,v 2.132 2007/11/05 18:37:19 pwagner Exp $"
d2096 1
d2103 3
@


2.132
log
@May Skip remaining lines in Fill, Join, Retrieve sections depending on Boolean
@
text
@d1557 1
a1557 1
          & l2auxDatabase, chunkNo, chunks )
d1749 1
a1749 1
   & chunkNo, chunks, firstInstance, lastInstance )
a1768 1
    integer, intent(in) :: chunkNo
d2056 1
a2056 1
       "$Id: Join.f90,v 2.131 2007/06/21 00:54:08 vsnyder Exp $"
d2066 3
@


2.131
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d49 1
d52 1
d54 2
a55 1
    use Init_Tables_Module, only: S_L2GP, S_L2AUX, S_TIME, S_DIRECTWRITE, S_LABEL
d107 1
d177 10
d2057 1
a2057 1
       "$Id: Join.f90,v 2.130 2006/10/11 22:58:00 pwagner Exp $"
d2067 3
@


2.130
log
@Will write convergence ratio as another quality-like field of l2gp
@
text
@d233 1
a233 1
	           & NoExtraWrites=noExtraWrites)
d246 1
a246 1
		          & theFile=theFile )
d2043 1
a2043 1
       "$Id: Join.f90,v 2.129 2006/09/21 18:55:04 pwagner Exp $"
d2053 3
@


2.129
log
@Fixed bug causing freezes when band13 off; cosmetic changes too
@
text
@d114 1
a114 1
    DEEBUG = ( switchDetail(switches, 'direct') > -1 )
d350 2
a351 2
    use Init_tables_module, only: F_SOURCE, F_PRECISION, F_HDFVERSION, F_FILE, &
      & f_QUALITY, F_STATUS, F_TYPE
d452 2
d463 1
d543 1
d554 2
d565 2
d579 7
d652 11
d1044 11
d1089 2
a1090 1
          call DirectWrite_l2GP ( directFile, qty, precQty, qualityQty, statusQty, &
d1303 2
d1551 5
d2043 1
a2043 1
       "$Id: Join.f90,v 2.128 2006/06/21 22:06:56 pwagner Exp $"
d2053 3
@


2.128
log
@Downgraded inappropriate quantity output to warning mesg
@
text
@d16 1
d59 1
a59 1
    use MLSL2Options, only: CHECKPATHS, SPECIALDUMPFILE
d114 1
a114 1
    DEEBUG = (index(switches, 'direct') /= 0)
d145 1
d248 2
a249 1
              if ( dwt22-dwt2 > timeReasonable .and. index(switches,'dwreq') /= 0 ) then
d468 3
a470 3
    DEEBUG = (index(switches, 'direct') /= 0)
    SKIPDGG = (index(switches, 'skipdgg') /= 0)
    SKIPDGM = (index(switches, 'skipdgm') /= 0)
d473 1
a473 1
    if ( toggle(gen) .and. index(switches,'dwreq') /= 0) &
d736 1
a736 1
      if ( toggle(gen) .and. index(switches,'dwreq') /= 0) &
d743 1
a743 1
      if ( toggle(gen) .and. index(switches,'dwreq') /= 0) &
d759 1
a759 1
          if ( toggle(gen) .and. index(switches,'dwreq') /= 0) &
d849 1
a849 1
        if ( toggle(gen) .and. index(switches,'dwreq') /= 0) &
d1033 1
a1033 1
          & index(switches,'dwreq') /= 0 ) then
d1081 2
a1082 1
      if ( timeWriting-timeSetup > timeReasonable .and. index(switches,'dwreq') /= 0 ) then
d1130 1
a1130 1
          & index(switches,'dwreq') /= 0 ) then
d1175 1
a1175 1
        & index(switches,'dwreq') /= 0 ) then
d1196 1
a1196 1
        & index(switches,'dwreq') /= 0 ) then
d1201 1
a1201 1
    if ( toggle(gen) .and. index(switches,'dwreq') /= 0) &
d1736 1
a1736 1
    DEEBUG = (index(switches, 'join') /= 0)
d1998 1
a1998 1
       "$Id: Join.f90,v 2.127 2006/04/11 23:34:27 pwagner Exp $"
d2008 3
@


2.127
log
@Fixed bug which added excess profiles
@
text
@d649 4
d654 2
a655 1
          & "Inappropriate quantity for this file type in direct write" )
d1994 1
a1994 1
       "$Id: Join.f90,v 2.126 2006/03/04 00:20:13 pwagner Exp $"
d2004 3
@


2.126
log
@Account for directdatabase even if skipping directWrites
@
text
@d46 1
a46 1
    & DirectDataBase, chunkNo, chunks, FWModelConfig, filedatabase )
d50 1
d80 1
d210 1
a210 1
                    & chunkNo, chunks, FWModelConfig, &
d218 1
a218 1
                  & chunkNo, chunks, FWModelConfig )
d230 1
a230 1
              & chunkNo, chunks, FWModelConfig, makeRequest=.true., &
d243 1
a243 1
                & chunkNo, chunks, FWModelConfig, create=createFile, &
d335 1
a335 1
    & chunkNo, chunks, FWModelConfig, makeRequest, create, theFile, &
d346 1
d384 1
d1039 5
d1045 1
a1045 1
            & hdfName, chunkNo, &
d1989 1
a1989 1
       "$Id: Join.f90,v 2.125 2006/02/10 21:17:33 pwagner Exp $"
d1999 3
@


2.125
log
@dumps may go to special dumpfile
@
text
@d57 1
a57 1
    use MLSL2Options, only: CHECKPATHS, SKIPDIRECTWRITES, SPECIALDUMPFILE
d191 1
a191 1
          if ( SKIPDIRECTWRITES ) exit
d268 2
a269 1
      if ( noDirectWrites == 0 .or. SKIPDIRECTWRITES .or. error /= 0 ) exit passLoop
d589 2
a590 1
    if ( .not. (SKIPDIRECTWRITES .or. checkpaths) ) then
d674 6
d835 2
a836 2
      ! if ( checkPaths ) return
      if ( SKIPDIRECTWRITES .or. checkPaths ) then
d1980 1
a1980 1
       "$Id: Join.f90,v 2.124 2005/11/11 21:47:08 pwagner Exp $"
d1990 3
@


2.124
log
@May have fixed bugs Besetting Alyn and Dong
@
text
@d57 1
a57 1
    use MLSL2Options, only: CHECKPATHS, SKIPDIRECTWRITES
d62 1
a62 1
    use Output_m, only: OUTPUT
d115 2
d283 2
d1972 1
a1972 1
       "$Id: Join.f90,v 2.123 2005/11/04 18:54:04 pwagner Exp $"
d1982 3
@


2.123
log
@Accommodates changed interface to add_metadata
@
text
@d304 22
a405 1
    ! character(len=8) :: FILEACCESSSTR   ! 'create' or 'rdwrite'
a418 1
    !type(MLSFile_T), pointer :: l2gpFile
a433 1
    ! integer :: record_length
a473 9
    ! Direct write is probably going to become the predominant form
    ! of output in the software, as the other forms have become a
    ! little too intensive.

    ! This routine will be called twice for each direct write.  The first
    ! (makeRequests=.true.) is a pass through to check the syntax etc.
    ! If it is successful a request will be made to the master.

    ! The second call will be to actually do the writing.
a491 1
        ! if ( lastFieldIndex /= f_source ) &
a519 2
   !  else if ( myTheFile > 0 ) then
   !   call get_string ( myTheFile, filename, strip=.true. )
a583 1
    ! if ( .not. checkpaths ) then
d760 1
a760 1
      if ( distributingSources .or. TOOLKIT .or. CATENATESPLITS ) then ! Was if TOOLKIT !?????? Check with PAW - NJL
a831 1
        ! fileaccessstr = 'create'
a833 1
        ! fileaccessstr = 'rdwrite'
d849 3
d856 1
d860 1
d864 1
d868 1
d871 16
d901 2
a902 2
            qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
              & sourceQuantities(source) )
d904 2
a905 1
            if(DEEBUG)call display_string ( hdfNameIndex, strip=.true., advance='yes' )
d909 2
a910 2
          dummy = MLS_SWATH_IN_FILE(trim(fileName), nameBuffer, HdfVersion, &
            & createThisSource )
d912 4
a918 17
        ! Call the l2gp open/create routine.  Filename is 'filename'
        ! file id should go into 'handle'
        directFile => GetMLSFileByName(filedatabase, filename, ignore_paths=.true.)
        if ( .not. associated(directFile) ) then
          if(DEEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'No entry in filedatabase for ' // trim(filename) )
          directFile => AddInitializeMLSFile(filedatabase, &
            & content=outputTypeStr, &
            & name=Filename, shortName=file_base, &
            & type=l_swath, access=DFACC_CREATE, HDFVersion=HDFVERSION_5, &
            & PCBottom=PCBottom, PCTop=PCTop)
        endif
        directFile%access = FileAccess
        if ( OPENHERE ) call mls_openFile(directFile, ErrorType)
        if(DEEBUG) call dump(directFile)
        ! handle = mls_io_gen_openF('sw', .true., ErrorType, &
        !  & record_length, FileAccess, trim(FileName), hdfVersion=hdfVersion)
d920 2
a921 17
        ! Call the l2aux open/create routine.  Filename is 'filename'
        ! file id should go into 'handle'
        ! handle = mls_io_gen_openF('hg', .true., ErrorType, &
        !  & record_length, FileAccess, FileName, hdfVersion=hdfVersion)
        directFile => GetMLSFileByName(filedatabase, filename, ignore_paths=.true.)
        if ( .not. associated(directFile) ) then
          if(DEEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'No entry in filedatabase for ' // trim(filename) )
          directFile => AddInitializeMLSFile(filedatabase, &
            & content=outputTypeStr, &
            & name=Filename, shortName=file_base, &
            & type=l_hdf, access=DFACC_CREATE, HDFVersion=HDFVERSION_5, &
            & PCBottom=PCBottom, PCTop=PCTop)
        endif
        directFile%access = FileAccess
        if ( OPENHERE ) call mls_openFile(directFile, ErrorType)
        if(DEEBUG) call dump(directFile)
d924 2
a925 1
          & 'Unrecognized output type ' // trim(filename), MLSFile=directFile )
d1008 4
a1011 2
        if ( timeSetup-timeIn > timeReasonable .and. index(switches,'dwreq') /= 0 ) then
          call output('Unreasonable set up time for ' //trim(hdfname), advance='yes')
d1013 3
d1084 1
a1088 4
        ! case ( l_l2gp, l_l2dgg )
          ! errortype = mls_io_gen_closeF('sw', Handle, hdfVersion=hdfVersion)
        !  case ( l_l2aux, l_l2fwm )
          ! errortype = mls_io_gen_closeF('hg', Handle, hdfVersion=hdfVersion)
d1099 4
a1102 2
        if ( timeToClose-timeWriting > timeReasonable .and. index(switches,'dwreq') /= 0 ) then
          call output('Unreasonable closing time for ' //trim(hdfname), advance='yes')
a1127 2
        ! errortype = mls_io_gen_closeF('sw', Handle, hdfVersion=hdfVersion)
        ! errortype = he5_SWclose(Handle)
a1136 1
        ! errortype = mls_io_gen_closeF('hg', Handle, hdfVersion=hdfVersion)
d1144 4
a1147 2
      if ( timeToClose-timeWriting > timeReasonable .and. index(switches,'dwreq') /= 0 ) then
        call output('Unreasonable closing time for ' //trim(hdfname), advance='yes')
d1165 2
a1166 1
      if ( timeOut-timeToClose > timeReasonable .and. index(switches,'dwreq') /= 0 ) then
d1968 1
a1968 1
       "$Id: Join.f90,v 2.122 2005/10/28 23:17:37 pwagner Exp $"
d1978 3
@


2.122
log
@Print missing outputType when unable to find suitable for distributing sources
@
text
@d1151 2
a1152 2
        call add_metadata ( node, file_base, NumPermitted, thisDirect%sdNames, &
          & hdfVersion, filetype, errortype )
d1963 1
a1963 1
       "$Id: Join.f90,v 2.121 2005/10/18 23:11:36 pwagner Exp $"
d1973 3
@


2.121
log
@Fixed bug causing standalone, toolkitless run to put split dgg/dgm files in cwd
@
text
@d1193 1
d1963 1
a1963 1
       "$Id: Join.f90,v 2.120 2005/06/22 18:57:01 pwagner Exp $"
d1973 3
@


2.120
log
@Reworded Copyright statement, moved rcs id
@
text
@d24 1
a24 1
       "$RCSfile: $"
d414 1
a414 1
    integer :: record_length
d889 1
a889 1
        directFile => GetMLSFileByName(filedatabase, filename)
d909 1
a909 1
        directFile => GetMLSFileByName(filedatabase, filename)
d1962 1
a1962 1
       "$Id: $"
d1972 3
@


2.119
log
@Should not bomb if catenating split files w/o toolkit
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d22 1
a22 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: Join.f90,v 2.118 2005/06/14 20:43:19 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d24 1
a24 1
       "$RCSfile: Join.f90,v $"
d1960 5
d1972 3
@


2.118
log
@Interfaces changed to accept MLSFile_T args
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.117 2005/03/24 21:31:55 pwagner Exp $"
d749 1
a749 1
      if ( distributingSources .or. TOOLKIT ) then ! Was if TOOLKIT !?????? Check with PAW - NJL
d765 1
a765 1
      if ( .not. TOOLKIT ) then
d770 2
d800 1
a800 1
      if ( isnewdirect .and. TOOLKIT ) then
d953 3
a955 2
        if ( TOOLKIT ) call ExpandSDNames(thisDirect, trim(hdfName))
        if ( TOOLKIT .and. DEEBUG ) call dump(thisDirect)
d1099 1
a1099 1
      if ( isnewdirect .and. TOOLKIT ) then
d1962 3
@


2.117
log
@May warn of unreasonable directWrite waiting, writing times
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.116 2004/12/14 22:51:35 pwagner Exp $"
a22 1
  ! logical, parameter, private :: DEEBUG = .true.           ! Usually FALSE
d41 1
a41 1
    & DirectDataBase, chunkNo, chunks, FWModelConfig )
d51 1
d73 1
d200 2
a201 1
                    & DirectdataBase, chunkNo, chunks, FWModelConfig, &
d208 2
a209 1
                  & DirectdataBase, chunkNo, chunks, FWModelConfig )
d219 2
a220 1
            call DirectWriteCommand ( son, ticket, vectors, DirectdataBase, &
d232 2
a233 1
              call DirectWriteCommand ( son, ticket, vectors, DirectdataBase, &
d299 2
a300 1
  subroutine DirectWriteCommand ( node, ticket, vectors, DirectDataBase, &
d319 4
a322 3
    use MLSCommon, only: R8, FileNameLen
    use MLSFiles, only: Split_path_name, GetPCFromRef, MLS_IO_gen_openF, &
      & MLS_IO_gen_closeF
d347 1
d370 1
d379 1
d393 1
d403 1
d405 1
d407 2
d464 2
d500 1
d819 1
d822 1
d839 16
d882 15
a896 2
        handle = mls_io_gen_openF('sw', .true., ErrorType, &
          & record_length, FileAccess, trim(FileName), hdfVersion=hdfVersion)
d900 18
a917 2
        handle = mls_io_gen_openF('hg', .true., ErrorType, &
          & record_length, FileAccess, FileName, hdfVersion=hdfVersion)
d920 7
a926 4
      if ( ErrorType /= 0 ) then
        print *, 'Tried to open ', trim(FIleName)
        print *, 'FileAccess ', FileAccess
        print *, 'hdfVersion ', hdfVersion
d930 2
a931 1
          & 'DirectWriteCommand unable to open ' // trim(filename) )
d1009 2
a1010 2
          call DirectWrite_l2GP ( handle, qty, precQty, qualityQty, statusQty, &
            & hdfName, chunkNo, hdfVersion, filename=filename, &
d1026 1
a1026 1
          call DirectWrite_L2Aux ( handle, qty, precQty, hdfName, hdfVersion, &
d1072 6
a1077 4
        case ( l_l2gp, l_l2dgg )
          errortype = mls_io_gen_closeF('sw', Handle, hdfVersion=hdfVersion)
        case ( l_l2aux, l_l2fwm )
          errortype = mls_io_gen_closeF('hg', Handle, hdfVersion=hdfVersion)
d1081 2
d1084 2
a1085 1
            & 'Tried to close Unrecognized OutputType in ' // trim(filename) )
d1092 2
a1093 1
          & 'DirectWriteCommand unable to close ' // trim(filename) )
d1115 1
a1115 1
        errortype = mls_io_gen_closeF('sw', Handle, hdfVersion=hdfVersion)
d1117 1
d1126 6
a1131 1
        errortype = mls_io_gen_closeF('hg', Handle, hdfVersion=hdfVersion)
d1138 2
a1139 1
        & 'DirectWriteCommand unable to close ' // trim(filename) )
d1146 2
a1147 1
          & 'DirectWriteCommand unable to addmetadata to ' // trim(filename) )
d1959 3
@


2.116
log
@Changes related to stopping early
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d16 1
a16 1
       "$Id: Join.f90,v 2.115 2004/07/22 20:49:58 cvuu Exp $"
d26 1
d86 1
d137 4
d231 8
d329 3
a331 1
    use TOGGLES, only: SWITCHES
d415 1
a415 1

d422 7
d435 1
a435 1
    ! Direct write is probably going to be come the predominant form
d683 2
d690 2
d706 2
d793 5
a797 1
      if ( SKIPDIRECTWRITES .or. checkPaths ) return
d929 4
a932 1
        
d968 4
d1013 4
d1052 4
d1069 4
d1075 2
d1876 3
@


2.115
log
@Add forwardModelConfigDatabase to the call MLSL2Join and MLSL2Fill
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.114 2004/06/10 00:58:45 vsnyder Exp $"
d51 1
a51 1
    use MLSL2Options, only: CHECKPATHS
d177 1
d212 1
a212 1
	      & NoExtraWrites=noExtraWrites)
d224 1
a224 1
		& theFile=theFile )
d242 1
a242 1
      if ( noDirectWrites == 0 .or. error /= 0 ) exit passLoop
d1822 3
@


2.114
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.113 2004/05/19 20:16:29 vsnyder Exp $"
d41 1
a41 1
    & DirectDataBase, chunkNo, chunks )
d46 1
d71 1
d192 1
a192 1
                    & DirectdataBase, chunkNo, chunks, &
d199 1
a199 1
                  & DirectdataBase, chunkNo, chunks )
d210 2
a211 1
              & chunkNo, chunks, makeRequest=.true., NoExtraWrites=noExtraWrites )
d222 2
a223 1
                & chunkNo, chunks, create=createFile, theFile=theFile )
d280 2
a281 1
    & chunkNo, chunks, makeRequest, create, theFile, noExtraWrites, namedFile )
d289 1
d323 1
d921 1
a921 1
            & chunkNo, chunks )
d1821 3
@


2.113
log
@Remove declarations and uses for unreferenced symbols, polish some cannonballs
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.112 2004/05/19 19:16:10 vsnyder Exp $"
d292 1
a292 1
    use MLSCommon, only: FindFirst, FindNext, R8, FileNameLen
d303 1
d1045 1
a1045 1
      nextfile = FindFirst(outputType == DirectDataBase%autoType)
d1049 1
a1049 1
        nextFile = FindNext(outputType == DirectDataBase%autoType, afile, &
d1814 3
@


2.112
log
@Move MLSChunk_t to Chunks_m
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.111 2004/04/27 23:56:17 pwagner Exp $"
a42 1
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
d55 2
a56 2
    use Output_m, only: OUTPUT, BLANKS
    use TOGGLES, only: GEN, TOGGLE, LEVELS, SWITCHES
a80 1
    integer :: DWINDEX                  ! Direct Write index
a97 1
    integer :: I
d111 2
a112 2
      endif
    endif
d194 1
a194 1
                enddo
d249 1
a249 1
      endif
d265 1
a265 2
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
d281 1
a281 1
      & AddDirectToDatabase, DirectWrite_l2GP, DirectWrite_l2aux, Dump, &
d284 1
a284 1
    use Hdf, only: DFACC_CREATE, DFACC_RDONLY, DFACC_RDWR
d289 1
a289 2
    use intrinsic, only: L_NONE, L_GEODANGLE, L_HDF, L_SWATH, &
      & L_MAF, lit_indices, PHYQ_DIMENSIONLESS
d292 3
a294 4
    use MLSCommon, only: FindFirst, FindNext, R4, R8, RV, FileNameLen
    use MLSFiles, only: HDFVERSION_5, NAMENOTFOUND, &
      & MLS_EXISTS, split_path_name, GetPCFromRef, &
      & mls_io_gen_openF, mls_io_gen_closeF, mls_sfstart, mls_sfend
d304 1
a304 1
    use Output_m, only: OUTPUT, BLANKS
d307 2
a308 3
    use TOGGLES, only: GEN, TOGGLE, LEVELS, SWITCHES
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, NULL_TREE, SOURCE_REF, &
      & SUB_ROSA, SUBTREE
a333 1
    integer :: DBINDEX
a388 1
    type(DirectData_T) :: newDirect
d456 1
a456 1
   !  elseif ( myTheFile > 0 ) then
d458 1
a458 1
    elseif ( myTheFile /= 'undefined' ) then
d460 1
a460 1
    endif
d590 1
a590 1
    endif
d602 1
a602 1
      endif
d605 1
a605 1
    endif
d622 1
a622 1
        endif
d637 3
a639 3
            endif
          enddo
        endif
d643 1
a643 1
        endif
d646 2
a647 2
      endif
    elseif ( skipdgg .and. any ( outputType == (/ l_l2dgg /) ) ) then
d652 1
a652 1
    elseif ( skipdgm .and. any ( outputType == (/ l_l2fwm, l_l2aux /) ) ) then
d662 1
a662 1
      elseif ( distributingSources ) then
d667 1
a667 1
        elseif ( outputType /= DirectDataBase(myFile)%type ) then
d671 1
a671 1
        endif
d700 1
a700 1
        endif
d707 2
a708 2
        endif
      endif
d711 1
a711 1
      elseif ( .not. isnewdirect ) then
d714 1
a714 1
      elseif ( any ( outputType == (/ l_l2gp /) ) ) then
d719 1
a719 1
      elseif ( any ( outputType == (/ l_l2dgg /) ) ) then
d724 1
a724 1
      elseif ( any ( outputType == (/ l_l2fwm /) ) ) then
d741 1
a741 1
      endif
d745 1
a745 1
      endif
d752 1
a752 1
      endif
d761 1
a761 1
      endif
d769 1
a769 1
      endif
d774 2
a775 2
        endif
      endif
d795 1
a795 1
          enddo
d821 1
a821 1
      endif
d834 1
a834 1
        endif
d886 1
a886 1
        endif
d903 1
a903 1
          endif
d927 1
a927 1
      endif
d945 2
a946 2
          endif
        endif
d951 1
a951 1
        endif
d967 1
a967 1
      endif
d971 1
a971 1
      endif
d978 1
a978 1
      endif
d994 1
a994 1
        endif
d1008 1
a1008 1
      endif
d1033 1
a1033 1
      enddo
d1043 1
a1043 1
      endif
d1050 1
a1050 1
      enddo
d1058 2
a1059 4
         call output ( source, advance='no' )
         call blanks ( 4, advance = 'no' )
         call output ( aFile, advance='no' )
         call blanks ( 4, advance = 'no' )
d1061 1
a1061 1
         call blanks ( 4, advance = 'no' )
d1063 2
a1064 2
       enddo
      endif
d1156 2
a1157 4
    use INIT_TABLES_MODULE, only: L_PRESSURE, &
      & L_TRUE, L_ZETA, S_DIRECTWRITE, S_L2AUX, S_L2GP, S_TIME, S_LABEL
    use intrinsic, only: L_NONE, L_GEODANGLE, &
      & L_MAF, PHYQ_DIMENSIONLESS
a1161 1
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
d1168 1
a1168 3
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, NULL_TREE, SOURCE_REF, &
      & SUB_ROSA, SUBTREE
    use TREE_TYPES, only: N_NAMED, N_SET_ONE
d1181 4
a1184 4
    logical :: COMPAREOVERLAPS
    integer :: FIELDINDEX              ! F_..., see Init_Tables_Module
    integer :: FILE                 ! Name of output file for direct write
    integer :: SON                      ! Son of Key
a1185 1
    integer :: HDFNAMEINDEX             ! Name of swath/sd
a1187 2
    integer :: MLSCFLine
    logical :: OutputOverlaps
d1189 4
a1193 1
    integer :: VALUE                    ! Value of a field
d1195 2
a1196 1
    integer :: QUANTITYINDEX            ! ind in qty tmpl database, not vector
a1197 4
    integer :: PRECVECTORINDEX          ! Index for precision vector
    integer :: PRECQTYINDEX             ! Index for precision qty (in database not vector)
    logical :: TIMING
    integer :: EXPRUNITS(2)                 ! From expr
a1199 2
    real :: T1, T2     ! for timing

d1301 1
a1301 1
        endif
d1311 1
a1311 1
        endif
d1336 1
a1336 1
    use MLSCommon, only: R4, R8, RV
d1338 1
a1338 1
    use TOGGLES, only: GEN, TOGGLE, LEVELS, SWITCHES
d1340 1
a1340 2
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, NULL_TREE, SOURCE_REF, &
      & SUB_ROSA, SUBTREE
d1364 1
a1364 2
!   real(r8), dimension(:,:), pointer :: Values !??? Not used ???
    
d1503 1
a1503 2
    use intrinsic, only: L_NONE, L_GEODANGLE, &
      & L_MAF, PHYQ_DIMENSIONLESS
d1506 1
a1506 1
    use MLSCommon, only: R4, R8, RV
d1508 2
a1509 2
    use OUTPUT_M, only: BLANKS, OUTPUT
    use String_Table, only: DISPLAY_STRING, GET_STRING
d1512 1
a1512 2
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, NULL_TREE, SOURCE_REF, &
      & SUB_ROSA, SUBTREE
a1539 1
    character (LEN=32) :: QUANTITYNAMESTR
d1611 1
a1611 1
        endif
d1716 1
a1716 1
    endif
d1769 1
a1769 1
    use OUTPUT_M, only: BLANKS, OUTPUT
d1771 1
a1771 2
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, NULL_TREE, SOURCE_REF, &
      & SUB_ROSA, SUBTREE
d1813 3
@


2.111
log
@SKIPDIRECTWRITES acts much like checkpaaths
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.110 2004/04/24 00:21:33 pwagner Exp $"
d44 1
a50 1
    use MLSCommon, only: MLSCHUNK_T
d283 1
d297 1
a297 2
    use MLSCommon, only: FindFirst, FindNext, &
      & MLSCHUNK_T, R4, R8, RV, FileNameLen
d1161 1
d1174 1
a1174 1
    use MLSCommon, only: MLSCHUNK_T, R8
d1525 1
d1530 1
a1530 1
    use MLSCommon, only: MLSCHUNK_T, R4, R8, RV
d1840 3
@


2.110
log
@Bombs less readily when not a slave
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.109 2004/04/17 07:00:54 livesey Exp $"
d303 1
a303 1
      & DEFAULT_HDFVERSION_WRITE, PATCH, TOOLKIT
d531 2
a532 1
    if ( .not. checkpaths ) then
d762 3
a764 2
      ! Done what we wished to do if just checking paths
      if ( checkPaths ) return
d1838 3
@


2.109
log
@Bug fix possibly?
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.108 2004/03/03 19:28:04 pwagner Exp $"
d186 1
a186 1
              if ( autoDirectWrite ) then
d701 1
a701 1
      if ( distributingSources ) then ! Was if TOOLKIT !?????? Check with PAW - NJL
d1761 25
d1836 3
@


2.108
log
@Should not add metadata if dgg/dgm to be unsplit
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.107 2004/02/19 23:56:23 pwagner Exp $"
d701 1
a701 1
      if ( TOOLKIT ) then
d1811 3
@


2.107
log
@Fixed tiny memory leak; skipdgg/m skips directwrite of filetype
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.106 2004/02/11 23:11:38 livesey Exp $"
d302 2
a303 2
    use MLSL2Options, only: CHECKPATHS, DEFAULT_HDFVERSION_WRITE, &
      & PATCH, TOOLKIT
d848 1
d1009 2
a1010 1
        & outputType /= l_l2fwm ) then
d1811 3
@


2.106
log
@Logic wrong in calls to DoHGridsMatch
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.105 2004/02/11 17:21:51 pwagner Exp $"
d379 2
d402 2
d655 10
d676 1
a676 9
          call Deallocate_test ( sourceVectors, 'sourceVectors', ModuleName )
          call Deallocate_test ( sourceQuantities, 'sourceQuantities', ModuleName )
          call Deallocate_test ( precisionVectors, 'precisionVectors', ModuleName )
          call Deallocate_test ( precisionQuantities, 'precisionQuantities', ModuleName )
          call Deallocate_test ( qualityVectors, 'qualityVectors', ModuleName )
          call Deallocate_test ( qualityQuantities, 'qualityQuantities', ModuleName )
          call Deallocate_test ( statusVectors, 'statusVectors', ModuleName )
          call Deallocate_test ( statusQuantities, 'statusQuantities', ModuleName )
          call Deallocate_test ( directFiles, 'directFiles', ModuleName )
d953 5
a957 9
        call Deallocate_test ( sourceVectors, 'sourceVectors', ModuleName )
        call Deallocate_test ( sourceQuantities, 'sourceQuantities', ModuleName )
        call Deallocate_test ( precisionVectors, 'precisionVectors', ModuleName )
        call Deallocate_test ( precisionQuantities, 'precisionQuantities', ModuleName )
        call Deallocate_test ( qualityVectors, 'qualityVectors', ModuleName )
        call Deallocate_test ( qualityQuantities, 'qualityQuantities', ModuleName )
        call Deallocate_test ( statusVectors, 'statusVectors', ModuleName )
        call Deallocate_test ( statusQuantities, 'statusQuantities', ModuleName )
        call Deallocate_test ( directFiles, 'directFiles', ModuleName )
d1019 1
a1019 9
    call Deallocate_test ( sourceVectors, 'sourceVectors', ModuleName )
    call Deallocate_test ( sourceQuantities, 'sourceQuantities', ModuleName )
    call Deallocate_test ( precisionVectors, 'precisionVectors', ModuleName )
    call Deallocate_test ( precisionQuantities, 'precisionQuantities', ModuleName )
    call Deallocate_test ( qualityVectors, 'qualityVectors', ModuleName )
    call Deallocate_test ( qualityQuantities, 'qualityQuantities', ModuleName )
    call Deallocate_test ( statusVectors, 'statusVectors', ModuleName )
    call Deallocate_test ( statusQuantities, 'statusQuantities', ModuleName )
    call Deallocate_test ( directFiles, 'directFiles', ModuleName )
d1073 11
d1809 3
@


2.105
log
@May DirectWrite l2gp status and quality quantities
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.104 2004/02/10 19:28:36 pwagner Exp $"
d550 1
a550 1
        if ( DoHgridsMatch( qty, qualityQty ) ) &
d561 1
a561 1
        if ( DoHgridsMatch( qty, statusQty ) ) &
d857 1
a857 1
          if ( DoHgridsMatch( qty, qualityQty ) ) &
d868 1
a868 1
          if ( DoHgridsMatch( qty, statusQty ) ) &
d1501 1
a1501 1
    thisL2GP%status(firstProfile:lastProfile)='G'
d1804 3
@


2.104
log
@Prevents named DirectWrites from being looped over
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.103 2004/02/05 23:40:35 pwagner Exp $"
d288 2
a289 1
    use Init_tables_module, only: F_SOURCE, F_PRECISION, F_HDFVERSION, F_FILE, F_TYPE
d295 1
d357 1
d386 4
d393 2
d423 1
d431 1
d433 2
a434 1
        if ( lastFieldIndex /= f_source ) &
d436 9
a444 1
            & 'A precision can only be given immediately following a source' )
d470 2
d477 4
d486 4
d509 14
d535 5
a539 4
      precQty => GetVectorQtyByTemplateIndex ( vectors(precisionVectors(source)), &
        & precisionQuantities(source) )
      ! Check that this is compatible with it's value quantitiy
      if ( qty%template%name /= precQty%template%name ) &
d545 22
d666 4
d852 22
d895 2
a896 2
          call DirectWrite_l2GP ( handle, qty, precQty, hdfName, chunkNo, &
            & hdfVersion, filename=filename, &
d951 4
d1021 4
d1804 3
@


2.103
log
@More bugs fixed in automatic directwrites
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.102 2004/01/23 01:09:48 pwagner Exp $"
d99 1
a99 1

d190 2
d194 3
a196 1
                    & theFile=DirectDataBase(dbIndex)%fileNameBase )
d280 1
a280 1
    & chunkNo, chunks, makeRequest, create, theFile, noExtraWrites )
d331 1
d370 2
a371 1
    integer :: NumPermitted             ! No. things to output
d413 1
d433 1
d754 1
d805 1
d821 1
d831 4
d845 8
a852 6
          print *, 'No sources written to ', trim(FileName)
          print *, 'FileAccess ', FileAccess
          print *, 'hdfVersion ', hdfVersion
          print *, 'myFile ', myFile
          print *, 'createFileFlag ', createFileFlag
          print *, 'noCreatedFiles ', noCreatedFiles
d1703 3
@


2.102
log
@Only directwrite files entered in global settings eligible to be auto-sourced
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.101 2004/01/22 00:56:35 pwagner Exp $"
d77 1
d79 1
d108 8
a115 1

d186 12
a197 2
              call DirectWriteCommand ( son, ticket, vectors, DirectdataBase, &
                & chunkNo, chunks )
a381 1
    ! integer, external :: he5_SWclose
d399 1
a399 1
    ! If it is sucessfull a request will be made to the master.
d582 13
d684 14
a698 1

d736 5
d821 16
a836 5
        call Announce_Error ( son, no_error_code, &
        & "NumPermitted=0", penalty=0 )
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'No sources permitted for writing to  ' // trim(filename) )
        if ( parallel%slave ) call FinishedDirectWrite ( ticket )
d842 14
d893 1
a893 1
        call add_metadata ( node, file_base, noSources, thisDirect%sdNames, &
d1686 3
@


2.101
log
@Fixed many bugs in auto-distribution of DirectWrites
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.100 2004/01/02 23:36:00 pwagner Exp $"
d589 2
a590 1
          call output('Did we need to expand DB for ' // trim(file_base), advance='yes')
a694 5
      ! call SetUpNewDirect(newDirect, noSources)
      ! Add it to the database of directly writeable quantities
      ! dbindex = AddDirectToDatabase ( DirectDatabase, newDirect )
      ! call decorate ( node, -dbindex ) ! So we can find it later
      ! thisDirect => DirectDatabase(dbindex)
d714 2
a715 2
          precQty => GetVectorQtyByTemplateIndex ( vectors(precisionVectors(source)), &
            & precisionQuantities(source) )
d784 1
a784 1
      if ( TOOLKIT ) then
d850 1
a850 1
        if ( outputType == DirectDataBase(afile)%type ) &
d853 7
a859 1
      if ( NumSuitablesFiles < 1 ) call MLSMessage ( &
d862 2
a863 1
      nextfile = FindFirst(outputType == DirectDataBase%type)
d867 2
a868 1
        nextFile = FindNext(outputType == DirectDataBase%type, afile, wrap=.true.)
d1612 3
@


2.100
log
@DirectWrites may choose files automatically from db
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d16 1
a16 1
       "$Id: Join.f90,v 2.99 2003/12/05 00:41:14 pwagner Exp $"
d49 1
d58 1
a58 1
    use Tree, only: SUBTREE, NSONS, NODE_ID
d77 2
d87 1
d92 2
a93 2
    integer :: THEFILE                  ! Direct write permission on file
    logical :: CREATEFILE               ! Flag
d120 1
d130 3
a132 1
        call output ( directWriteNodeGranted, advance='yes' )
d134 1
d183 3
d188 2
a189 1
              & chunkNo, chunks, makeRequest=.true. )
d194 1
d196 1
d203 2
d219 11
d257 1
a257 1
    & chunkNo, chunks, makeRequest, create, theFile )
d262 1
a262 1
      & ExpandDirectDB, ExpandSDNames
d269 1
a269 1
      & L_MAF, PHYQ_DIMENSIONLESS
d271 2
a272 1
    use MLSCommon, only: MLSCHUNK_T, R4, R8, RV
d279 1
a279 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d306 2
a307 1
    integer, intent(in), optional :: THEFILE      ! Which file permission granted for
d314 1
d319 1
d340 1
d342 1
a342 1
    integer :: MYTHEFILE                ! File permission granted for
d344 1
d346 1
d358 1
d371 1
a371 1
    myTheFile = 0
d373 1
d397 2
a398 1
        if ( lastFieldIndex /= f_source ) call Announce_Error ( son, no_error_code, &
d415 7
a421 1
    endif    
d423 2
a424 1
    nullify ( sourceVectors, sourceQuantities, precisionVectors, precisionQuantities )
d429 1
d435 1
d499 1
a499 1
    if ( filename == 'undefined' ) then
d510 6
d521 37
a557 1
      call LogDirectWriteRequest ( file, node )
d563 8
d588 4
d626 4
a629 1
      if ( returnStatus /= 0 ) call MLSMessage ( &
d632 1
a632 1

d637 7
d700 1
d702 10
a715 1
        ! thisDirect%sdNames(source) = hdfName
d720 1
a720 1
          ! Check that this is compatible with it's value quantitiy
d767 5
d774 14
a787 1

d792 7
d823 1
a823 1
        call add_metadata ( file_base, noSources, thisDirect%sdNames, &
d837 1
d841 41
a881 1
      
d1559 1
a1559 1
  subroutine ANNOUNCE_ERROR ( where, CODE, ExtraMessage, FIELDINDEX )
d1573 7
a1579 1
    error = max(error,1)
d1608 3
@


2.99
log
@patch option avoids deleting existing data in file
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.98 2003/12/03 17:50:54 pwagner Exp $"
d88 1
d120 2
a121 1
        call WaitForDirectWritePermission ( directWriteNodeGranted, ticket, createFile )
d185 1
a185 1
                & chunkNo, chunks, create=createFile )
d230 1
a230 1
    & chunkNo, chunks, makeRequest, create )
d272 4
d278 1
d286 4
d292 2
d297 2
d302 1
d307 1
d309 3
d314 3
a318 8
    integer :: RETURNSTATUS
    logical :: CREATEFILEFLAG           ! Flag (often copy of create)
    logical :: MYMAKEREQUEST            ! Copy of makeRequest
    logical :: DUMMY
    logical, dimension(:), pointer :: CREATETHISSOURCE
    character(len=256), dimension(:), pointer :: NAMEBUFFER
    integer :: record_length
    integer :: l2gp_Version
d320 4
a323 10
    integer :: EXPRUNITS(2)             ! From expr
    real (r8) :: EXPRVALUE(2)           ! From expr
    integer, dimension(:), pointer :: SOURCEVECTORS ! Indicies
    integer, dimension(:), pointer :: SOURCEQUANTITIES ! Indicies
    integer, dimension(:), pointer :: PRECISIONVECTORS ! Indicies
    integer, dimension(:), pointer :: PRECISIONQUANTITIES ! Indicies
    character(len=1024) :: FILENAME     ! Output full filename
    character(len=1024) :: FILE_BASE    ! made up of
    character(len=1024) :: PATH         ! path/file_base
    character(len=1024) :: HDFNAME      ! Output swath/sd name
d328 1
a328 2
    logical :: DEEBUG
    integer, external :: he5_SWclose
d336 2
d351 2
d376 3
a378 2
    call get_string ( file, filename, strip=.true. )
    
d452 4
d693 4
d1416 3
@


2.98
log
@L2GP tracks both nTimes (for this slave) and nTimesTotal (done by all)
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.97 2003/11/14 23:38:45 pwagner Exp $"
d247 2
a248 1
    use MLSL2Options, only: CHECKPATHS, TOOLKIT, DEFAULT_HDFVERSION_WRITE
d520 1
a520 1
      if ( createFileFlag ) then
a652 11
        if ( hdfVersion == HDFVERSION_5 .and. FORCEDIRWRITEREOPEN ) then
          print *, 'Now forcibly opening and closing the hdf5'
          Handle =   mls_sfstart(trim(FileName), DFACC_RDONLY, hdfVersion, &
           & addingmetadata=.false. )
          if ( HANDLE == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'DirectWriteCommand unable to h5fopen ' // trim(filename) )
          errortype =   mls_sfend(Handle, hdfVersion, &
           & addingmetadata=.false. )
          if ( errortype /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'DirectWriteCommand unable to h5fclose ' // trim(filename) )
        endif
d1395 3
@


2.97
log
@Uses DirectWrite databse in preference to repeated calls to toolkit
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.96 2003/11/07 00:46:51 pwagner Exp $"
d1060 1
a1060 1

d1405 3
@


2.96
log
@New quicker preflight option: --checkPaths
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.95 2003/10/20 18:21:45 pwagner Exp $"
d232 2
a233 2
      & AddDirectToDatabase, DirectWrite_l2GP, DirectWrite_l2aux, &
      & SetUpNewDirect
a276 1
    integer :: fileaccess               ! DFACC_CREATE or DFACC_RDWR
d280 2
a282 1
    integer :: FILE                     ! File name string index
d288 1
d317 1
a317 1
    type(DirectData_T), pointer :: thisDirect
d323 1
d467 1
d469 1
d471 11
d484 3
a486 1
        returnStatus = 0
d512 4
d566 1
a566 1
      call SetUpNewDirect(newDirect, noSources)
d568 3
a570 3
      dbindex = AddDirectToDatabase ( DirectDatabase, newDirect )
      call decorate ( node, -dbindex ) ! So we can find it later
      thisDirect => DirectDatabase(dbindex)
d577 2
a578 1
        thisDirect%sdNames(source) = hdfName
d632 4
a635 2
      thisDirect%type = outputType
      thisDirect%fileNameBase = file_base
d1405 3
@


2.95
log
@Timings breakdown added for directWrite
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.94 2003/10/10 00:00:24 pwagner Exp $"
d50 1
d149 1
a149 1
          if ( pass == 1 ) then
d155 1
a155 1
          if ( pass == 1 ) then
d247 1
a247 1
    use MLSL2Options, only: TOOLKIT, DEFAULT_HDFVERSION_WRITE
d395 1
d399 1
a399 1
        & sourceQuantities(source) )
d401 1
a401 1
        & "Quantity does not have a label" )
d403 6
a408 6
        precQty => GetVectorQtyByTemplateIndex ( vectors(precisionVectors(source)), &
          & precisionQuantities(source) )
        ! Check that this is compatible with it's value quantitiy
        if ( qty%template%name /= precQty%template%name ) &
          & call Announce_Error ( son, no_error_code, &
          & "Precision and quantity do not match" )
d431 1
d495 3
d1381 3
@


2.94
log
@Should quit properly if SIPS and no PCFid match for file name
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.93 2003/09/12 21:45:52 pwagner Exp $"
d50 2
a51 1
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
d77 2
d117 1
d123 1
d158 1
d165 1
d168 1
d179 1
d183 1
d189 1
d1375 3
@


2.93
log
@Only prints l2gp label during DirectWrite if DEEBUG
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.92 2003/09/04 22:40:04 pwagner Exp $"
d231 1
a231 1
    use MLSFiles, only: HDFVERSION_5, &
d455 1
d477 3
d1364 3
@


2.92
log
@Gets dgg file name from dgg PCFid when DirectWrite usingPCF
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.91 2003/09/03 23:05:49 livesey Exp $"
d499 1
a499 1
            call display_string ( hdfNameIndex, strip=.true., advance='yes' )
d731 1
a731 1
    use String_Table, only: DISPLAY_STRING, GET_STRING
d910 1
a910 1
    use String_Table, only: DISPLAY_STRING, GET_STRING
d1360 3
@


2.91
log
@More problems with precision in DirectWrite, hope I've got them all now.
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.90 2003/09/03 00:53:50 livesey Exp $"
d239 2
a240 1
      & mlspcf_l2fwm_full_end
d455 1
a455 1
      elseif ( any ( outputType == (/ l_l2gp, l_l2dgg /) ) ) then
d460 5
d1360 3
@


2.90
log
@Bug fix on directWrite, it was storing the value field in the precision
too!
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.89 2003/08/28 23:51:58 livesey Exp $"
d531 2
a532 2
          precQty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
            & sourceQuantities(source) )
d1354 4
@


2.89
log
@Renamed some variables to make them more obvious
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.88 2003/08/14 20:11:30 pwagner Exp $"
d389 2
a390 2
        precQty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
          & sourceQuantities(source) )
d1354 3
@


2.88
log
@DirectWrite may take l2fwm types for fwm radiances
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.87 2003/08/01 20:38:31 pwagner Exp $"
d284 3
a286 3
    logical :: ANOTHERLOG_VAR
    logical, dimension(:), pointer :: logicalBuffer
    character(len=256), dimension(:), pointer :: nameBuffer
d297 2
a298 2
    character(len=1024) :: FILE_base    ! made up of
    character(len=1024) :: path         ! path/file_base
d482 2
a483 2
        nullify(logicalBuffer, nameBuffer)
        call Allocate_test ( logicalBuffer, noSources, 'logicalBuffer', &
d497 2
a498 2
          ANOTHERLOG_VAR = MLS_SWATH_IN_FILE(trim(fileName), nameBuffer, HdfVersion, &
            & logicalBuffer )
d501 1
a501 1
          logicalBuffer = .false.
d563 1
a563 1
            & createSwath=(.not. logicalBuffer(source)) )
d590 1
a590 1
        call Deallocate_test ( logicalBuffer, 'logicalBuffer', ModuleName )
d1354 3
@


2.87
log
@Distinguishes between l2dgg and l2gp when writing metadata as part of directwrite
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.86 2003/07/25 00:51:06 livesey Exp $"
d225 2
a226 1
    use Init_tables_module, only: L_L2GP, L_L2AUX, L_L2DGG, L_PRESSURE, L_ZETA
d238 2
a239 1
      & mlspcf_l2dgm_start, mlspcf_l2dgm_end
d278 1
a278 1
    integer :: OUTPUTTYPE               ! l_l2gp, l_l2aux, l_l2dgg
d408 3
a410 1
        & ( outputType == l_l2dgg .and. expectedType == l_l2gp ) ) then
d459 5
d507 1
a507 1
      case ( l_l2aux )
d569 1
a569 1
        case ( l_l2aux )
d612 1
a612 1
      case ( l_l2aux )
d618 2
a619 1
      if ( createFileFlag .and. TOOLKIT .and. .not. SKIPMETADATA ) then
d1354 3
@


2.86
log
@Added file type l2dgg to support metadata.
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.85 2003/07/23 18:30:35 cvuu Exp $"
d25 1
d360 1
d555 5
a559 1
          filetype=l_swath
d609 1
a609 1
      if ( createFileFlag .and. TOOLKIT ) then
d1344 3
@


2.85
log
@reduce routine printing
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.84 2003/07/15 23:39:01 pwagner Exp $"
d224 1
a224 1
    use Init_tables_module, only: L_L2GP, L_L2AUX, L_PRESSURE, L_ZETA
d275 1
a275 1
    integer :: OUTPUTTYPE               ! l_l2gp, l_l2aux
d368 2
a369 1
        if ( outputType /= l_l2gp ) call Announce_Error ( son, no_error_code, &
d403 2
a404 1
      if ( outputType /= expectedType ) then
d448 1
a448 1
      elseif ( outputType == l_l2gp ) then
d467 1
a467 1
      case ( l_l2gp )
d544 1
a544 1
        case ( l_l2gp )
d573 1
a573 1
      case ( l_l2gp )
d1338 3
@


2.84
log
@Disabled most printing
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.83 2003/07/11 01:24:20 livesey Exp $"
d1199 1
a1199 1
      call output ( "Doing the special calculation of first/last profile", advance='yes' )
d1336 3
@


2.83
log
@More changes trying to get the direct write going.
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.82 2003/07/09 21:49:53 pwagner Exp $"
d24 1
d89 1
d92 1
d157 1
a157 1
              print*,'Calling DirectWrite, not slave'
d163 1
a163 1
            print*,'Calling direct write to do a setup'
d170 1
a170 1
              print*,'Calling direct write to do the write'
d222 1
a222 1
    use Hdf, only: DFACC_CREATE, DFACC_RDWR
d229 3
a231 2
    use MLSFiles, only: MLS_EXISTS, split_path_name, GetPCFromRef, &
      & mls_io_gen_openF, mls_io_gen_closeF
d468 1
a468 1
        print *, 'Allocating ', noSources
d476 1
a476 1
            print*,'Source:', source
d482 1
a482 1
            print*,'Done'
d486 1
a486 1
          print*,'Got out of MLS_SWATH_IN_FILE'
d572 1
a572 1
        print *, 'Deallocating ', noSources
d578 17
a594 4
        print *, 'Tried to close ', trim(FIleName)
        print *, 'Handle ', Handle
        print *, 'hdfVersion ', hdfVersion
        print *, 'errortype ', errortype
d1336 3
@


2.82
log
@Tries to figure out in advance whether to create swath
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.81 2003/07/08 00:15:51 livesey Exp $"
d453 1
a453 5
      ! > if ( mls_exists(trim(Filename)) == 0 ) then
      ! >   fileaccess = DFACC_RDWR
      ! > else
      ! >   fileaccess = DFACC_CREATE
      ! > endif
d460 1
d470 16
a485 8
        do source = 1, noSources
          qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
          & sourceQuantities(source) )
          hdfNameIndex = qty%label
          call get_string ( hdfNameIndex, nameBuffer(source), strip=.true. )
        enddo
        ANOTHERLOG_VAR = MLS_SWATH_IN_FILE(fileName, nameBuffer, HdfVersion, &
          & logicalBuffer )
d489 1
a489 1
          & record_length, FileAccess, FileName, hdfVersion=hdfVersion)
d1319 3
@


2.81
log
@Various tidy ups and reworks
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.80 2003/07/07 23:52:13 pwagner Exp $"
d228 1
d277 3
d465 16
d538 1
d540 2
a541 1
            & hdfVersion )   ! May optionally supply first, last profiles
d563 3
d1314 3
@


2.80
log
@Slave that creates DirectWrite file may also add_metadata
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.79 2003/07/07 20:29:43 livesey Exp $"
d144 4
a147 3
          ! Need to keep changing the label each pass so that the directWrites 
          ! have the correct output name
          call LabelVectorQuantity ( son, vectors )
d388 2
a389 1
        & verticalCoordinate = (/ l_pressure, l_zeta, l_none/) ) ) then
d394 6
a399 2
      if ( outputType /= expectedType ) call Announce_Error ( son, no_error_code, &
        & "Inappropriate quantity for this file type in direct write" )
d1289 3
@


2.79
log
@Mainly cosmetic changes
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.78 2003/07/07 17:31:11 livesey Exp $"
d221 1
a221 1
    use intrinsic, only: L_NONE, L_GEODANGLE, &
d233 1
d261 1
d514 1
d525 1
d548 6
d1283 3
@


2.78
log
@Various things to get DirectWrite working
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.77 2003/07/02 00:55:27 pwagner Exp $"
d1036 1
a1036 1
    DEEBUG = (index(switches, 'direct') /= 0)
d1052 1
a1052 2
        call get_string(quantity%template%name, quantityNameStr, strip=.true., noerror=.true.)
        call output(trim(quantityNameStr), advance='yes')
d1136 1
d1146 2
d1273 3
@


2.77
log
@Some improvements in DirectWrites of l2aux, l2gp
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.76 2003/06/26 23:13:52 pwagner Exp $"
d46 1
d72 1
a72 4
    real :: T1                          ! Time we started
    real :: T2                          ! Time we finished
    integer :: PASS                     ! Loop counter
    integer :: NODIRECTWRITES           ! Array size
d75 4
a79 1
    integer :: MLSCFLINE                ! Line number in l2cf
d81 2
d84 2
d87 1
a87 1
    logical, dimension(:), pointer :: DWCOMPLETED
d95 6
a100 2
    ! This is to allow us to try to write the direct write files in an arbitrary
    ! order as they become free.
d103 1
a103 1
    pass = 0
d105 2
d108 9
a116 1
      dwIndex = 1
d129 1
a129 1
          if ( pass == 0 ) then
d139 1
a139 1
          if ( pass == 0 ) then
d148 1
a148 1
          if ( pass == 0 ) then
d151 11
d163 9
a171 7
            ! On the later passes deal with them if they are still pending.
            if ( .not. dwCompleted(dwIndex) ) then
              ! Have it be patient if it's the only one left, other wise
              ! we'll try the next one.
              call DirectWriteCommand ( son, vectors, DirectdataBase, &
                & chunkNo, chunks, &
                & count(.not. dwCompleted)==1, dwCompleted(dwIndex) )
a172 3
            dwIndex = dwIndex + 1
            ! If we've now completed all the direct writes, it's time to move on.
            if ( all ( dwCompleted ) ) exit passLoop
d177 2
a178 11
      ! On first pass setup dwCompleted, later passes, wait a moment.
      if ( pass == 0 ) then
        nullify ( dwCompleted )
        call Allocate_test ( dwCompleted, noDirectWrites, 'dwCompleted', ModuleName )
        dwCompleted = .false.
      else
        ! Once we've done a complete pass through the direct writes
        ! let's wait a while, to avoid pestering the master with 
        ! direct write requests too often
        call usleep ( delay )
      end if
a189 2
    call Deallocate_test ( dwCompleted, 'dwCompleted', ModuleName )

d210 2
a211 2
  subroutine DirectWriteCommand ( node, vectors, DirectDataBase, &
    & chunkNo, chunks, waitItOut, completed )
d223 1
a223 1
    use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, FINISHEDDIRECTWRITE
d240 2
a241 1
    integer, intent(in) :: NODE    ! Of the JOIN section in the AST
d246 2
a247 2
    logical, intent(in) :: WAITITOUT    ! If set, wait patiently for the ability to write
    logical, intent(out) :: COMPLETED    ! True if we sucessfully wrote the file
d250 1
a250 1
    ! Saved variable - used to work out file information.
d271 2
a272 1
    logical :: CREATEFILE               ! Flag
d296 3
d301 7
a307 11
    ! little too intensive.  The key is to make the actual writing part
    ! as efficient as possible, so we 'hold the flag' for the minimum
    ! time.  Otherwise we'll start to clog up the sytem with direct
    ! writes

    ! The time critical section is marked in the comments below.
    ! First, let's go through the l2cf command and work out what
    ! we've been asked to do
    
    ! Take a first pass through, count the number of things we're outputing
    ! Also pick upthe hdfVersion and the filename
d394 3
d407 4
a410 7
    ! If we're a slave, we need to request permission from the master.
    if ( parallel%slave ) then
      call RequestDirectWritePermission ( file, createFile, waitItOut, completed )
      ! If we weren't prepared to wait then return to the calling code.
      if ( .not. completed ) return
      ! From this point on we have exclusive access to the output file, so let's
      ! be quick about what we do so as not to block others.
d412 12
a423 8
      ! In serial mode there is no doubt that we will write file now.
      completed = .true.
      createFile = .not. any ( createdFilenames == file )
      if ( createFile ) then
        noCreatedFiles = noCreatedFiles + 1
        if ( noCreatedFiles > maxFiles ) call MLSMessage ( &
          & MLSMSG_Error, ModuleName, 'Too many direct write files' )
        createdFilenames ( noCreatedFiles ) = file
d425 10
a434 69
    end if

    ! Bail out at this stage if there is some kind of error.
    if ( error /= 0 ) return

    ! vvvvvvvvvv ------ Speed is of the essence in this section ----- vvvvvvvvvv
    ! --------------------------------------------------------------------------

    ! Open/create the file of interest
    call split_path_name(filename, path, file_base)
    if ( .not. TOOLKIT ) then
      handle = 0
    elseif ( outputType == l_l2gp ) then
      Handle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
      & mlspcf_l2gp_end, &
      & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
      & exactName=Filename)
    else
      Handle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
      & mlspcf_l2dgm_end, &
      & TOOLKIT, returnStatus, l2gp_Version, DEEBUG, &
      & exactName=Filename)
    end if
    ! > if ( mls_exists(trim(Filename)) == 0 ) then
    ! >   fileaccess = DFACC_RDWR
    ! > else
    ! >   fileaccess = DFACC_CREATE
    ! > endif
    if ( createFile ) then
      fileaccess = DFACC_CREATE
    else
      fileaccess = DFACC_RDWR
    endif
    select case ( outputType )
    case ( l_l2gp )
      ! Call the l2gp open/create routine.  Filename is 'filename'
      ! file id should go into 'handle'
      handle = mls_io_gen_openF('sw', .true., ErrorType, &
        & record_length, FileAccess, FileName, hdfVersion=hdfVersion)
    case ( l_l2aux )
      ! Call the l2aux open/create routine.  Filename is 'filename'
      ! file id should go into 'handle'
      handle = mls_io_gen_openF('hg', .true., ErrorType, &
        & record_length, FileAccess, FileName, hdfVersion=hdfVersion)
    end select

    if ( ErrorType /= 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'DirectWriteCommand unable to open ' // trim(filename) )
    endif
    call SetUpNewDirect(newDirect, noSources)
    ! Add it to the database of directly writeable quantities
    dbindex = AddDirectToDatabase ( DirectDatabase, newDirect )
    call decorate ( node, -dbindex ) ! So we can find it later
    thisDirect => DirectDatabase(dbindex)
    ! Loop over the quantities to output
    do source = 1, noSources
      qty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
        & sourceQuantities(source) )
      hdfNameIndex = qty%label
      call get_string ( hdfNameIndex, hdfName, strip=.true. )
      thisDirect%sdNames(source) = hdfName
      if ( precisionVectors(source) /= 0 ) then
        precQty => GetVectorQtyByTemplateIndex ( vectors(sourceVectors(source)), &
          & sourceQuantities(source) )
        ! Check that this is compatible with it's value quantitiy
        if ( qty%template%name /= precQty%template%name ) &
          & call Announce_Error ( son, no_error_code, &
          & "Precision and quantity do not match" )
d436 4
a439 1
        precQty => NULL()
d441 83
d525 2
a526 12
      if ( DeeBUG ) then
        call output('CREATEFILE: ', advance='no')
        call output(CREATEFILE, advance='yes')
        call output('file access: ', advance='no')
        call output(fileaccess, advance='yes')
        call output('file handle: ', advance='no')
        call output(handle, advance='yes')
        call output('outputType: ', advance='no')
        call output(outputType, advance='yes')
        call output('sd name: ', advance='no')
        call output(trim(hdfname), advance='yes')
      endif
d528 1
d531 7
a537 6
        ! Call the l2gp swath write routine.  This should write the 
        ! non-overlapped portion of qty (with possibly precision in precQty)
        ! into the l2gp swath named 'hdfName' starting at profile 
        ! qty%template%instanceOffset + 1
        call DirectWrite_l2GP ( handle, qty, precQty, hdfName, chunkNo, &
          & hdfVersion )   ! May optionally supply first, last profiles
d539 2
a540 9
        ! Call the l2aux sd write routine.  This should write the 
        ! non-overlapped portion of qty (with possibly precision in precQty)
        ! into the l2aux sd named 'hdfName' starting at profile 
        ! qty%template%instanceOffset ( + 1 ? )
        ! Note sure about the +1 in this case, probably depends whether it's a
        ! minor frame quantity or not.  This mixed zero/one indexing is beomming
        ! a real pain.  I wish I never want down that road!
        call DirectWrite_L2Aux ( handle, qty, precQty, hdfName, hdfVersion, &
          & chunkNo, chunks )
d542 1
a542 20
    end do ! End loop over swaths/sds

    thisDirect%type = outputType
    thisDirect%fileNameBase = file_base
    
    ! Close the output file of interest (does this need to be split like this?)
    select case ( outputType )
    case ( l_l2gp )
      ! Call the l2gp close routine
      errortype = mls_io_gen_closeF('sw', Handle, hdfVersion=hdfVersion)
      ! errortype = he5_SWclose(Handle)
      print *, 'Tried to close ', trim(FIleName)
      print *, 'Handle ', Handle
      print *, 'hdfVersion ', hdfVersion
      print *, 'errortype ', errortype
    case ( l_l2aux )
      ! Call the l2aux close routine
      errortype = mls_io_gen_closeF('hg', Handle, hdfVersion=hdfVersion)
    end select
    if ( errortype /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d544 4
a547 5

    ! Tell the master we're done
    if ( parallel%slave ) call FinishedDirectWrite
    ! --------------------------------------------------------------------------
    ! ^^^^^^^^^^ ------------ End of time critical section ---------- ^^^^^^^^^^
d1271 3
@


2.76
log
@New debugging output; distinguishes between l2gp/l2aux quantities better
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.75 2003/06/24 23:54:07 pwagner Exp $"
d271 1
d425 8
a432 1
    if ( mls_exists(trim(Filename)) == 0 ) then
a433 2
    else
      fileaccess = DFACC_CREATE
d450 1
a450 1
        & 'DirectWriteCommand unable to open' // trim(filename) )
d476 2
d516 6
a521 2
      errortype = mls_io_gen_closeF('swclose', Handle, FileName=FileName, &
      & hdfVersion=hdfVersion)
d524 1
a524 2
      errortype = mls_io_gen_closeF('hg', Handle, FileName=FileName, &
      & hdfVersion=hdfVersion)
d526 2
d1256 3
@


2.75
log
@New db indexes stored for entire direct file
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.74 2003/06/24 23:30:00 livesey Exp $"
d199 1
d201 2
d205 1
a205 2
    use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VALIDATEVECTORQUANTITY, &
      & GETVECTORQTYBYTEMPLATEINDEX
d209 1
a209 1
    use MLSL2Options, only: TOOLKIT
a212 4
    use Init_tables_module, only: F_SOURCE, F_PRECISION, F_HDFVERSION, F_FILE, F_TYPE
    use Init_tables_module, only: L_L2GP, L_L2AUX, L_PRESSURE, L_ZETA
    use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, FINISHEDDIRECTWRITE
    use Expr_m, only: EXPR
d214 1
d219 2
d290 1
d373 10
d442 4
d469 11
d750 1
d754 6
a759 2
        if ( get_spec_id(key) /= s_l2gp ) call MLSMessage ( MLSMSG_Error,&
          & ModuleName, 'This quantity should be joined as an l2gp')
d764 6
a769 2
        if ( get_spec_id(key) /= s_l2aux ) call MLSMessage ( MLSMSG_Error,&
          & ModuleName, 'This quantity should be joined as an l2aux')
d1243 3
@


2.74
log
@Finished LabelVectorQuantity and made some other bug fixes.
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.73 2003/06/23 23:55:17 pwagner Exp $"
d197 2
a198 1
      & AddDirectToDatabase, DirectWrite_l2GP, DirectWrite_l2aux
d268 1
d430 5
d441 1
a452 5
      newDirect%type = outputType
      newDirect%sdname = hdfName
      ! Add it to the database of directly writeable quantities
      dbindex = AddDirectToDatabase ( DirectDatabase, newDirect )

d474 3
d1207 3
@


2.73
log
@Added DirectData_T to keep track of data written directly
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.72 2003/06/20 19:38:25 pwagner Exp $"
d85 1
a85 1
    if ( toggle(gen) ) call trace_end ( "MLSL2Join" )
d456 1
a456 2
        call DirectWrite_l2GP( Handle, &
          & qty, precQty, hdfName, chunkNo, &
d466 1
a466 1
        call DirectWrite_L2Aux(Handle, qty, precQty, hdfName, hdfVersion, &
d497 1
a497 1
    use VectorsModule, only: VECTOR_T
d500 4
d518 2
d521 1
d538 20
d1201 3
@


2.72
log
@Allows direct writing of output products
@
text
@d16 1
a16 1
       "$Id: Join.f90,v 2.71 2003/05/30 00:09:27 livesey Exp $"
d39 1
a39 1
    & chunkNo, chunks )
d42 1
d62 1
d137 2
a138 1
              call DirectWriteCommand ( son, vectors, chunkNo, chunks, &
d192 2
a193 1
  subroutine DirectWriteCommand ( node, vectors, chunkNo, chunks, waitItOut, completed )
d196 2
a197 1
    use DirectWrite_m, only: DirectWrite_l2GP, DirectWrite_l2aux
d222 1
d234 1
d266 1
d445 5
d1175 3
@


2.71
log
@Can now directWrite major frame quantities
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
a8 10
  use intrinsic, only: FIELD_INDICES, L_NONE, L_GEODANGLE, &
    & L_MAF, PHYQ_DIMENSIONLESS
  use MLSCommon, only: MLSChunk_T, R4, R8, RV
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
  use OUTPUT_M, only: BLANKS, OUTPUT
  use String_Table, only: DISPLAY_STRING, GET_STRING
  use TOGGLES, only: GEN, TOGGLE, LEVELS
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, NULL_TREE, SOURCE_REF, &
    & SUB_ROSA, SUBTREE
d16 1
a16 1
       "$Id: Join.f90,v 2.70 2003/05/12 02:06:23 livesey Exp $"
d23 1
a23 1
  logical, parameter, private :: DEEBUG = .false.           ! Usually FALSE
d35 2
a36 4
  ! This is the main routine for join.  Most of the time it is fairly simple.
  ! However, for the first time round a little more has to be done as the
  ! routine has to create the l2gp and l2aux structures with the correct size
  ! in order to be able to store all the chunks.
d40 486
d533 3
a535 1
      & L_TRUE, L_ZETA, S_DIRECTWRITE, S_L2AUX, S_L2GP, S_TIME
d539 1
d541 1
d543 2
a544 2
    use MoreTree, only: Get_Spec_ID
    use OutputAndClose, only: DIRECTWRITE
d547 2
a548 1
    use Time_M, only: Time_Now
d554 1
a554 1
    integer, intent(in) :: ROOT    ! Of the JOIN section in the AST
d563 1
a563 2
    integer :: FIELD                    ! Subtree index of "field" node
    integer :: FIELD_INDEX              ! F_..., see Init_Tables_Module
d565 1
a565 1
    integer :: GSON                     ! Son of Key
a572 1
    integer :: SON                      ! A son of ROOT
d587 1
a587 1
    logical :: GOT_FIELD(field_first:field_last)
d591 48
a638 85
    ! Executable code
    timing = section_times
    if ( timing ) call time_now ( t1 )

    if ( toggle(gen) ) call trace_begin ( "MLSL2Join", root )

    error = 0

    ! We simply loop over the lines in the mlscf

    do mlscfLine = 2, nsons(root)-1     ! Skip name at begin and end of section
      ! Each line represents a different join operation; clear various
      ! flags etc.
      son = subtree(mlscfLine,root)
      if ( node_id(son) == n_named ) then ! Is spec labeled?
        key = subtree(2,son)
        name = sub_rosa(subtree(1,son))
      else
        key = son
        name = 0
      end if

      ! Node_id(key) is now n_spec_args.

      ! ??? Does this need to do anything somewhere ???
      if ( get_spec_id(key) == s_time ) then
        if ( timing ) then
          call sayTime
        else
          call time_now ( t1 )
          timing = .true.
        end if
      end if

      got_field = .false.
      source = null_tree
      compareOverlaps = .false.
      outputOverlaps = .false.
      hdfNameIndex=name
      prefixSignal = .false.
      hdfVersion = 4

      ! Loop over the fields of the mlscf line

      do keyNo = 2, nsons(key) ! Skip spec name
        gson = subtree(keyNo,key)
        field = subtree(1,gson)
        if ( node_id(gson) == n_set_one ) then
          value = l_true
        else
          value = decoration(subtree(2,gson))
        end if
        field_index = decoration(field)
        got_field(field_index) = .true.
        select case ( field_index )
        case ( f_source )
          source = subtree(2,gson) ! required to be an n_dot vertex
          vectorIndex = decoration(decoration(subtree(1,source)))
          quantityIndex = decoration(decoration(decoration(subtree(2,source))))
        case ( f_precision )
          source = subtree(2,gson) ! required to be an n_dot vertex
          precVectorIndex = decoration(decoration(subtree(1,source)))
          precQtyIndex = decoration(decoration(decoration(subtree(2,source))))
        case ( f_hdfVersion )
          call expr ( subtree(2,gson), exprUnits, exprValue )
          if ( exprUnits(1) /= phyq_dimensionless ) &
            & call Announce_error ( gson, NO_ERROR_CODE, &
            & 'No units allowed for hdfVersion: just integer 4 or 5')
          hdfVersion = exprValue(1)
        case ( f_prefixSignal )
          prefixSignal= value == l_true
        case ( f_compareoverlaps )
          compareOverlaps = value == l_true
        case ( f_outputoverlaps )
          outputOverlaps = value == l_true 
        case ( f_swath )
          hdfNameIndex = sub_rosa(subtree(2,gson))
        case ( f_sdName )
          hdfNameIndex = sub_rosa(subtree(2,gson))
        case ( f_file )
          file = sub_rosa(subtree(2,gson))
        case default ! Can't get here if tree_checker worked properly
        end select
      end do

d640 51
a690 69
      if ( any ( get_spec_id(key) == (/ s_l2gp, s_l2aux /) ) ) then
        if ( any ( got_field ( (/ f_file, f_hdfVersion /) ) ) ) &
          & call Announce_Error ( key, NO_ERROR_CODE, &
          & 'File or hdfVersion not appropriate arguments for l2aux/l2gp' )
      end if

      if ( error > 0 ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Errors in configuration prevent proceeding" )

      ! Now, for commands other than timing, do more complicated stuff.
      if ( get_spec_id(key) /= s_time ) then
        ! Identify the quantity
        quantity => GetVectorQtyByTemplateIndex(vectors(vectorIndex),quantityIndex)
        ! Get the precision quantity too perhaps
        if ( got_field ( f_precision ) ) then
          precisionQuantity => &
            & GetVectorQtyByTemplateIndex(vectors(precVectorIndex),precQtyIndex)
          if ( quantity%template%id /= precisionQuantity%template%id ) &
            & call announce_error(key, NO_ERROR_CODE, &
            & 'Quantity and precision quantity do not match')
        else
          precisionQuantity => NULL()
        end if

        ! Establish a swath/sd name for this quantity.
        hdfName = ''
        if ( prefixSignal ) &
          & call GetSignalName ( quantity%template%signal, hdfName, &
          &   sideband=quantity%template%sideband )
        call Get_String( hdfNameIndex, hdfName(len_trim(hdfName)+1:), strip=.true. )

        ! Now get an index for this possibly new name which may include the signal
        hdfNameIndex = enter_terminal ( trim(hdfName), t_string, caseSensitive=.true. )

        ! Now three possible cases, a direct write (either parallel or not), a
        ! parallel slave join, or a manual join
        if ( get_spec_id(key) == s_directWrite ) then
          ! For the direct write command, call some special code
          if ( .not. any ( (/ quantity%template%minorFrame, &
            &                 quantity%template%majorFrame /) ) ) &
            & call Announce_Error ( key, NO_ERROR_CODE, &
            & 'Invalid quantity for direct write, must be minor or major frame' )
          call DirectWrite ( quantity, hdfNameIndex, file, hdfVersion, &
            & chunkNo, chunks )
        else if ( parallel%slave ) then
          ! For slave tasks in a PVM system, simply ship this vector off
          ! Otherwise, do a join.
          call SlaveJoin ( quantity, precisionQuantity, &
            & hdfName, key )
        else
          ! Now, depending on the properties of the source we deal with the
          ! vector quantity appropriately.
          if (ValidateVectorQuantity(quantity,coherent=.true.,stacked=.true.,regular=.true.,&
            & verticalCoordinate=(/L_Pressure,L_Zeta,L_None/),&
            & minorFrame=.false.,majorFrame=.false.)) then
            ! Coherent, stacked, regular quantities on pressure surfaces, or
            ! with no vertical coordinate system go in l2gp files.
            if ( get_spec_id(key) /= s_l2gp ) call MLSMessage ( MLSMSG_Error,&
              & ModuleName, 'This quantity should be joined as an l2gp')
            call JoinL2GPQuantities ( key, hdfNameIndex, quantity, &
              & precisionQuantity, l2gpDatabase, chunkNo )
          else
            ! All others go in l2aux files.
            if ( get_spec_id(key) /= s_l2aux ) call MLSMessage ( MLSMSG_Error,&
              & ModuleName, 'This quantity should be joined as an l2aux')
            call JoinL2AUXQuantities ( key, hdfNameIndex, quantity, &
             & l2auxDatabase, chunkNo, chunks )
          end if
        end if
d692 1
a692 1
    end do
d694 1
a694 21
   if ( ERROR /= 0 ) then
     call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem with Join section' )
   end if

    if ( toggle(gen) ) call trace_end ( "MLSL2Join" )
    if ( timing ) call sayTime

  contains
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for MLSL2Join =" )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime

  end subroutine MLSL2Join
d710 1
d713 6
a732 1

a733 1

d881 2
d885 8
a898 1
!   integer, intent(in) :: quantityNo
d907 14
a920 14
    integer :: FIRSTMAF                 ! Index
    integer :: LASTMAF                  ! Index
    integer ::                           UseFirstInstance, UseLastInstance, &
    &                                    NoOutputInstances
    type (L2AUXData_T) ::                NewL2AUX
    type (L2AUXData_T), pointer ::       ThisL2AUX
    logical ::                           L2auxDataIsNew
!   integer, dimension(3) ::             DimensionFamilies, DimensionSizes, DimensionStarts
    integer ::                           AuxFamily     ! Channel or Frequency
!    integer ::                           DimensionIndex, Channel, Surf
    integer   ::                         NoMAFs, index
    integer ::                           FirstProfile, LastProfile
!   real(r8), dimension(:,:), pointer :: values !??? Not used ???
    character (LEN=32) :: quantityNameStr
d922 2
d927 1
a949 1

d952 2
a953 2
      index = decoration(key)
      l2auxDataIsNew = (index>=0)
d955 1
a956 1
    
a961 1

d968 2
a969 1
    noOutputInstances = useLastInstance-useFirstInstance+1
d976 1
a976 1
      call output(' instances ', advance='no')
a980 1

d982 3
a984 18

      ! If the quantity is a minor frame quantity, then we deal with it 
      ! as such.  Otherwise we output it as a geodAngle based quantity

      if ( (quantity%template%noChans/=1) .and. &
        & (quantity%template%frequencyCoordinate == L_None) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Quantity has multiple channels but no frequency coordinate" )

      auxFamily=quantity%template%frequencyCoordinate

      ! if ( quantity%template%minorFrame .or. quantity%template%majorFrame ) then
        ! For minor frame quantities, the dimensions are:
        ! ([frequency or channel],MIF,MAF)
        !
        ! For minor frame quantities, we're going to allocate them to the full
        ! size from the start, rather than expand them, as this will be more
        ! efficient
d988 13
a1000 50
        ! THINK HERE ABOT RUNS THAT DON'T START AT THE BEGINNING !???????
        ! MAY NEED TO CHANGE ALLOCATE
! >         if ( quantity%template%frequencyCoordinate==L_None ) then
! >           dimensionFamilies = (/L_None, L_MIF, L_MAF/)
! >           dimensionSizes = (/1, quantity%template%noSurfs, noMAFs/)
! >           dimensionStarts = (/1, 1, firstMAF /)
! >         else
! >           dimensionFamilies = (/auxFamily, L_MIF, L_MAF/)
! >           dimensionSizes = (/quantity%template%noChans, quantity%template%noSurfs, &
! >             & noMAFs/)
! >           dimensionStarts = (/1, 1, firstMAF /)
! >         end if
! >       else
! >         ! Not a minor frame quantity; for non minor frame l2aux quantities
! >         ! our ability to output them will probably increase, but at the
! >         ! moment, I can't really forsee what form they may take.
! > 
! >         ! For the moment (ie. v0.1) I'm going to be restrictive and only
! >         ! allow quantities with no vertical coordinate.  This may and
! >         ! probably will change in later versions, leading to more L2AUXDim
! >         ! paramters etc., to parallel those from type t_verticalCoordinate
! >         ! in Init_Tables_Module.
! > 
! >         if ( quantity%template%verticalCoordinate /= l_None ) &
! >           & call MLSMessage ( MLSMSG_Error, ModuleName, &
! >           & "Cannot currently output L2AUX quantities with obscure "// &
! >           & "vertical coordinates, sorry!" )
! > 
! >         if ( quantity%template%frequencyCoordinate==L_None ) then
! >           dimensionFamilies = (/L_geodAngle, L_None, &
! >             & L_None/)
! >           dimensionSizes = (/quantity%template%noInstances, 1, 1/)
! >           dimensionStarts = (/1, 1, 1/)
! >         else
! >           dimensionFamilies = (/auxFamily, L_geodAngle, &
! >             & L_None/)
! >           dimensionSizes = (/quantity%template%noChans, quantity%template%noInstances, 1/)
! >           dimensionStarts = (/1, 1, 1/)
! >         end if
! >       end if

      ! Now we setup the new quantity
!     call SetupNewL2AUXRecord ( dimensionFamilies, dimensionSizes, &
!       & dimensionStarts, newL2AUX )
      if ( DEEBUG ) then
        call output('  firstMAF ', advance='no')
        call output(firstMAF, advance='no')
        call output('  noMAFs ', advance='no')
        call output(noMAFs, advance='yes')
      endif
a1001 2
!     newL2AUX%minorFrame=quantity%template%minorFrame
!     newL2AUX%majorFrame=quantity%template%majorFrame
a1004 22
      ! Setup the standard `vertical' and `channel' dimensions

! >       do dimensionIndex = 1, L2AUXRank
! >         select case ( newL2AUX%dimensions(dimensionIndex)%dimensionFamily )
! >         case ( L_None )          ! Do nothing
! >         case ( L_Channel )
! >           do channel = 1,quantity%template%noChans
! >             newL2AUX%dimensions(dimensionIndex)%values(channel) = channel
! >           end do
! >         case ( L_IntermediateFrequency, l_USBFrequency, L_LSBFrequency )
! >           newL2AUX%dimensions(dimensionIndex)%values = quantity%template%frequencies
! >         case ( L_MIF )
! >           do surf = 1, quantity%template%noSurfs
! >             newL2AUX%dimensions(dimensionIndex)%values(surf) = surf
! >           end do
! >         case default                    ! Ignore horizontal dimensions
! >         end select
! >         ! The error message here is rather vague.  The issue is that
! >         ! both MAF and geodAngle should only occur for the `last' dimension
! >         ! which our loop is explicity avoiding.
! >       end do ! The `last' dimension is dealt with later on.

d1006 1
a1006 1
      index = AddL2AUXToDatabase ( l2auxDatabase, newL2AUX )
d1009 3
a1011 3
      call decorate ( key, -index ) ! Remember where it is
      thisL2AUX => l2auxDatabase(index)

d1013 3
a1015 5
      ! Setup the index and pointer
      thisL2AUX => l2auxDatabase(-index)

      ! Expand this l2aux along the `last' dimension to take up the new
      ! information.
d1017 6
a1022 14
      ! ??? The noMAFs computation isn't consistent with the initial case ???
      noMAFs = quantity%template%mafCounter( &
        & quantity%template%noInstances-quantity%template%noInstancesUpperOverlap)

      ! ??? WVS would like to make this work as in the L2GP case:  The
      ! "setup..." routine allocates zero size in the MAF's direction,
      ! Then "expand..." is called in either case (but does no copying when
      ! called immediately after the initial one).
      ! For minor frame quantities we don't need to expand, as they're created
      ! at full size from the start.
      if ( .not. &
        & (quantity%template%minorFrame .or. quantity%template%majorFrame) ) then
        call ExpandL2AUXDataInPlace ( thisL2AUX, noMAFs )
      end if
a1024 3
    ! Now we are ready to fill up the l2aux quantity with the new data.
    thisL2AUX%name = name

d1026 5
a1030 2
      lastProfile = quantity%template%mafIndex(quantity%template%noInstances - &
        & quantity%template%noInstancesUpperOverlap)
d1034 2
a1035 2
    firstProfile = lastProfile-noOutputInstances+1
    
d1059 1
a1059 1
      if ( any( thisL2AUX%dimensions(L2AUXRank)%dimensionFamily &
d1075 3
a1077 2
      thisL2AUX%dimensions(L2AUXRank)%values(firstProfile:lastProfile)=&
        & quantity%template%mafCounter(useFirstInstance:useLastInstance)
d1121 1
d1123 4
d1162 3
@


2.70
log
@Bug fix for prefixSignal L2GPs and also bound r8->r4 conversion
@
text
@d26 1
a26 1
       "$Id: Join.f90,v 2.69 2003/02/08 00:31:31 pwagner Exp $"
d238 2
a239 1
          if ( .not. ValidateVectorQuantity ( quantity, minorFrame=.true. ) ) &
d241 1
a241 1
            & 'Invalid quantity for direct write, must be minor frame' )
d825 3
@


2.69
log
@Now saves quantityType in newl2gp
@
text
@d11 1
a11 1
  use MLSCommon, only: MLSChunk_T, R8
d26 1
a26 1
       "$Id: Join.f90,v 2.68 2003/01/30 01:03:24 pwagner Exp $"
a89 1
    logical :: IS_SWATHNAME_CASESENSITIVE
a137 1
      is_swathname_casesensitive = .false.   ! Don't use the actual swath name
d139 1
a139 5
      select case( get_spec_id(key) )
      case ( s_l2aux )
      case ( s_l2gp )
        is_swathname_casesensitive = .true.   ! Use the actual swath name
      case ( s_time )
d146 1
a146 1
      end select
d230 3
a232 5
        ! Unless the name is case sensitive, look up the swath/sdName
        ! and seize upon its first invocation as the one to use
        !  (although the question why is a natural one to ask)
        if ( .not. is_swathname_casesensitive) &
          & hdfNameIndex = enter_terminal ( trim(hdfName), t_string )
d308 1
a308 1
      & L2GPData_T, SetupNewL2GPRecord
d323 1
d333 1
d336 1
d448 3
a450 2
         reshape(quantity%values(:,useFirstInstance:useLastInstance),&
         (/max(thisL2GP%nFreqs,1),max(thisL2GP%nLevels,1),lastProfile-firstProfile+1/))
d453 3
a455 2
      reshape(precision%values(:,useFirstInstance:useLastInstance),&
         (/max(thisL2GP%nFreqs,1),max(thisL2GP%nLevels,1),lastProfile-firstProfile+1/))
d504 1
d511 2
d772 2
a773 1
      & reshape(quantity%values(:,useFirstInstance:useLastInstance), &
d824 3
@


2.68
log
@Stores quantity type taken from source vector in l2aux
@
text
@d26 1
a26 1
       "$Id: Join.f90,v 2.67 2003/01/17 23:11:26 pwagner Exp $"
d393 2
a394 1

d823 3
@


2.67
log
@Moved most ops out of LoinL2AUXData to SetupL2AUXData
@
text
@d26 1
a26 1
       "$Id: Join.f90,v 2.66 2002/12/19 15:53:47 livesey Exp $"
d638 1
d822 3
@


2.66
log
@Allowed verticalCoordinate=l_none quantities back into the l2gp fold.
@
text
@d9 2
a10 3
  use intrinsic, only: FIELD_INDICES, L_NONE, L_CHANNEL, L_GEODANGLE, &
    & L_INTERMEDIATEFREQUENCY, L_LSBFREQUENCY, L_MAF, L_MIF, L_USBFREQUENCY, &
    & PHYQ_DIMENSIONLESS
d26 1
a26 1
       "$Id: Join.f90,v 2.65 2002/11/26 23:38:01 livesey Exp $"
d273 1
a273 1
              & l2auxDatabase, chunkNo, chunks )
d473 1
a473 1
    & chunkNo, chunks, firstInstance, lastInstance )
d499 1
a499 1
    integer, dimension(3) ::             DimensionFamilies, DimensionSizes, DimensionStarts
d501 2
a502 2
    integer ::                           DimensionIndex, Channel, Surf, &
    &                                    NoMAFs,index
d558 1
d574 1
a574 1
      if ( quantity%template%minorFrame .or. quantity%template%majorFrame ) then
d586 38
a623 38
        if ( quantity%template%frequencyCoordinate==L_None ) then
          dimensionFamilies = (/L_None, L_MIF, L_MAF/)
          dimensionSizes = (/1, quantity%template%noSurfs, noMAFs/)
          dimensionStarts = (/1, 1, firstMAF /)
        else
          dimensionFamilies = (/auxFamily, L_MIF, L_MAF/)
          dimensionSizes = (/quantity%template%noChans, quantity%template%noSurfs, &
            & noMAFs/)
          dimensionStarts = (/1, 1, firstMAF /)
        end if
      else
        ! Not a minor frame quantity; for non minor frame l2aux quantities
        ! our ability to output them will probably increase, but at the
        ! moment, I can't really forsee what form they may take.

        ! For the moment (ie. v0.1) I'm going to be restrictive and only
        ! allow quantities with no vertical coordinate.  This may and
        ! probably will change in later versions, leading to more L2AUXDim
        ! paramters etc., to parallel those from type t_verticalCoordinate
        ! in Init_Tables_Module.

        if ( quantity%template%verticalCoordinate /= l_None ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Cannot currently output L2AUX quantities with obscure "// &
          & "vertical coordinates, sorry!" )

        if ( quantity%template%frequencyCoordinate==L_None ) then
          dimensionFamilies = (/L_geodAngle, L_None, &
            & L_None/)
          dimensionSizes = (/quantity%template%noInstances, 1, 1/)
          dimensionStarts = (/1, 1, 1/)
        else
          dimensionFamilies = (/auxFamily, L_geodAngle, &
            & L_None/)
          dimensionSizes = (/quantity%template%noChans, quantity%template%noInstances, 1/)
          dimensionStarts = (/1, 1, 1/)
        end if
      end if
d626 11
a636 4
      call SetupNewL2AUXRecord ( dimensionFamilies, dimensionSizes, &
        & dimensionStarts, newL2AUX )
      newL2AUX%minorFrame=quantity%template%minorFrame
      newL2AUX%majorFrame=quantity%template%majorFrame
d641 19
a659 19
      do dimensionIndex = 1, L2AUXRank
        select case ( dimensionFamilies(dimensionIndex) )
        case ( L_None )          ! Do nothing
        case ( L_Channel )
          do channel = 1,quantity%template%noChans
            newL2AUX%dimensions(dimensionIndex)%values(channel) = channel
          end do
        case ( L_IntermediateFrequency, l_USBFrequency, L_LSBFrequency )
          newL2AUX%dimensions(dimensionIndex)%values = quantity%template%frequencies
        case ( L_MIF )
          do surf = 1, quantity%template%noSurfs
            newL2AUX%dimensions(dimensionIndex)%values(surf) = surf
          end do
        case default                    ! Ignore horizontal dimensions
        end select
        ! The error message here is rather vague.  The issue is that
        ! both MAF and geodAngle should only occur for the `last' dimension
        ! which our loop is explicity avoiding.
      end do ! The `last' dimension is dealt with later on.
d706 19
a724 1
      call output(lastProfile, advance='no')
d746 23
d821 3
@


2.65
log
@Better joining of major frame quantities
@
text
@d27 1
a27 1
       "$Id: Join.f90,v 2.64 2002/10/29 21:54:21 livesey Exp $"
d261 1
a261 1
            & verticalCoordinate=(/L_Pressure,L_Zeta/),&
d773 3
@


2.64
log
@Made join less verbose.
@
text
@d27 1
a27 1
       "$Id: Join.f90,v 2.63 2002/10/08 17:36:21 pwagner Exp $"
d261 2
a262 1
            & verticalCoordinate=(/L_Pressure,L_Zeta,L_None/))) then
d773 3
@


2.63
log
@Added idents to survive zealous Lahey optimizer
@
text
@d16 1
a16 1
  use TOGGLES, only: GEN, TOGGLE
d27 1
a27 1
       "$Id: Join.f90,v 2.62 2002/08/20 22:10:50 vsnyder Exp $"
d342 2
a343 1
    if ( toggle(gen) ) call trace_begin ( "JoinL2GPQuantities", key )
d464 1
a464 1
    if ( toggle(gen) ) call trace_end ( "JoinL2GPQuantities" )
d509 2
a510 1
    if ( toggle(gen) ) call trace_begin ( "JoinL2AUXQuantities", key )
d726 2
a727 1
    if ( toggle(gen) ) call trace_end ( "JoinL2AUXQuantities" )
d772 3
@


2.62
log
@Move USE statements from module scope to procedure scope
@
text
@d27 1
a27 1
       "$Id: Join.f90,v 2.61 2002/08/20 20:10:30 livesey Exp $"
d31 1
d761 4
d769 3
@


2.61
log
@Dealt with frequency in l2gps
@
text
@a8 8

  use Expr_m, only: EXPR
  use INIT_TABLES_MODULE, only: &
    & F_COMPAREOVERLAPS, F_FILE, F_HDFVERSION, F_OUTPUTOVERLAPS, &
    & F_PRECISION, F_PREFIXSIGNAL, F_SOURCE, F_SDNAME, F_SWATH, FIELD_FIRST, &
    & FIELD_LAST
  use INIT_TABLES_MODULE, only: L_PRESSURE, &
    & L_TRUE, L_ZETA, S_DIRECTWRITE, S_L2AUX, S_L2GP, S_TIME
d12 1
a12 9
  use L2AUXData, only: AddL2AUXToDatabase, ExpandL2AUXDataInPlace, &
    & L2AUXData_T, L2AUXRank, SetupNewL2AUXRecord
  use L2GPData, only: AddL2GPToDatabase, ExpandL2GPDataInPlace, &
    & L2GPData_T, SetupNewL2GPRecord
  use L2ParInfo, only: PARALLEL, SLAVEJOIN
  use LEXER_CORE, only: PRINT_SOURCE
  use ManipulateVectorQuantities, only: DOHGRIDSMATCH
  use MLSCommon, only: MLSChunk_T,R8
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
a13 2
  use MLSSignals_M, only: GETSIGNALNAME
  use MoreTree, only: Get_Spec_ID
a14 1
  use OutputAndClose, only: DIRECTWRITE
a15 3
  use Symbol_Table, only: ENTER_TERMINAL
  use Symbol_Types, only: T_STRING
  use Time_M, only: Time_Now
a19 3
  use TREE_TYPES, only: N_NAMED, N_SET_ONE
  use VectorsModule, only: GetVectorQtyByTemplateIndex, &
    & ValidateVectorQuantity, Vector_T, VectorValue_T
d27 1
a27 1
       "$Id: Join.f90,v 2.60 2002/05/28 17:09:57 livesey Exp $"
d53 21
d228 1
a228 1
        endif
d292 1
a292 1
      endif
a299 29
! =====     Private Procedures     =====================================

  ! ---------------------------------------------  Announce_Error  -----
  subroutine ANNOUNCE_ERROR ( where, CODE, ExtraMessage, FIELDINDEX )
    integer, intent(in) :: where   ! Tree node where error was noticed
    integer, intent(in) :: CODE    ! Code for error message
    integer, intent(in), optional :: FIELDINDEX ! Extra information for msg
    character (LEN=*), intent(in), optional :: ExtraMessage

    error = max(error,1)
    call output ( '***** At ' )
    if ( where > 0 ) then
      call print_source ( source_ref(where) )
    else
      call output ( '(no lcf tree available)' )
    end if
    call output ( ': ' )
    select case ( code )
      case ( NotAllowed )
        call output('Field ')
        call display_string(field_indices(fieldIndex))
        call output(' is not allowed in this context',advance='yes')
      case default
        call output ( " command caused an unrecognized programming error", advance='yes' )
    end select
    if ( present(ExtraMessage) ) then
      call output(ExtraMessage, advance='yes')
    end if
  end subroutine ANNOUNCE_ERROR
d313 5
d383 1
a383 1
      endif
d422 1
a422 1
    endif
d473 4
d521 2
a522 2
      endif
    endif
d554 1
a554 1
    endif
d688 1
a688 1
    endif
d702 1
a702 1
      endif
d705 1
a705 1
    endif
d727 33
d764 3
@


2.60
log
@Removed print statements
@
text
@d52 1
a52 1
       "$Id: Join.f90,v 2.59 2002/05/22 00:48:52 livesey Exp $"
d420 6
a425 1
      ! ??? In later versions we'll need to think about frequency stuff (NJL)
d755 3
@


2.59
log
@Added direct write stuff
@
text
@d52 1
a52 1
       "$Id: Join.f90,v 2.58 2002/05/16 22:36:46 livesey Exp $"
a550 1
    print*,'L2AUXDataIsNew:',l2auxDataIsNew
a640 1
      print*,'Setting up l2aux'
a694 1
        print*,'Expanding l2aux'
d750 3
@


2.58
log
@Fixed a bug with joining minor frame quantities with overlaps.
@
text
@d10 1
d12 1
a12 1
    & F_COMPAREOVERLAPS, F_FILE, F_OUTPUTOVERLAPS, &
d16 4
a19 3
    & L_TRUE, L_ZETA, S_L2AUX, S_L2GP, S_TIME
  use Intrinsic, ONLY: FIELD_INDICES, L_NONE, L_CHANNEL, L_GEODANGLE, &
    & L_INTERMEDIATEFREQUENCY, L_LSBFREQUENCY, L_MAF, L_MIF, L_USBFREQUENCY
d27 1
a27 1
  use MLSCommon, only: MLSChunk_T         ! , R8 (not used???)
d33 1
d52 1
a52 1
       "$Id: Join.f90,v 2.57 2002/04/08 20:49:17 pwagner Exp $"
d58 1
a58 1
  logical, parameter, private :: DEEBUG = .FALSE.           ! Usually FALSE
d90 1
d92 1
d109 2
d160 2
a161 2
      compareOverlaps = .FALSE.
      outputOverlaps = .FALSE.
d164 1
d187 6
d204 1
a204 1
          call announce_error(key,NotAllowed,FIELDINDEX=field_index)
d209 7
d219 3
a221 2
      select case ( get_spec_id(key) )
      case ( s_l2gp, s_l2aux ) ! ------------- L2GP and L2AUX Data     ------------
d223 1
d234 1
d244 1
a244 1
         & hdfNameIndex = enter_terminal ( trim(hdfName), t_string )
d246 12
a257 3
        ! For slave tasks in a PVM system, simply ship this vector off
        ! Otherwise, do a join.
        if ( parallel%slave ) then
d263 1
a263 1
          if (ValidateVectorQuantity(quantity,coherent=.TRUE.,stacked=.TRUE.,regular=.TRUE.,&
d279 1
a279 4

      case default ! Timing
      end select

d298 1
a298 1
      call output ( DBLE(t2 - t1), advance = 'yes' )
d307 2
a308 2
  subroutine ANNOUNCE_ERROR ( WHERE, CODE, ExtraMessage, FIELDINDEX )
    integer, intent(in) :: WHERE   ! Tree node where error was noticed
d310 1
a310 1
    integer, intent(in), OPTIONAL :: FIELDINDEX ! Extra information for msg
d350 1
a350 1
    type (VectorValue_T), pointer :: PRECISION ! Optional vector quantity
d373 1
a373 1
    l2gpDataIsNew = (.NOT. associated(l2gpDatabase))
d381 1
a381 1
    if ( PRESENT(firstInstance) ) then
d387 1
a387 1
    if ( PRESENT(lastInstance) ) then
d473 2
a474 2
         RESHAPE(quantity%values(:,useFirstInstance:useLastInstance),&
         (/MAX(thisL2GP%nFreqs,1),MAX(thisL2GP%nLevels,1),lastProfile-firstProfile+1/))
d477 2
a478 2
      RESHAPE(precision%values(:,useFirstInstance:useLastInstance),&
         (/MAX(thisL2GP%nFreqs,1),MAX(thisL2GP%nLevels,1),lastProfile-firstProfile+1/))
d546 2
a547 2
    l2auxDataIsNew = (.NOT. associated(l2auxDatabase))
    if ( .NOT. l2auxDataIsNew ) then
d551 1
d554 1
a554 1
    if ( PRESENT(firstInstance) ) then
d560 1
a560 1
    if ( PRESENT(lastInstance) ) then
d583 1
a583 1
      if ( (quantity%template%noChans/=1) .AND. &
d585 1
a585 1
        & CALL MLSMessage ( MLSMSG_Error, ModuleName, &
d624 1
a624 1
          & CALL MLSMessage ( MLSMSG_Error, ModuleName, &
d642 1
d696 4
a699 2
        & (quantity%template%minorFrame .or. quantity%template%majorFrame) ) &
        & call ExpandL2AUXDataInPlace ( thisL2AUX, noMAFs )
d753 3
@


2.57
log
@Swath name optionally passed to JoinL2GPQuantities
@
text
@d49 1
a49 1
       "$Id: Join.f90,v 2.56 2002/04/06 00:35:21 pwagner Exp $"
d672 2
a673 1
      lastProfile = quantity%template%mafIndex(quantity%template%noInstances)
d719 3
@


2.57.2.1
log
@*** empty log message ***
@
text
@a9 1
  use Expr_m, only: EXPR
d11 1
a11 1
    & F_COMPAREOVERLAPS, F_FILE, F_HDFVERSION, F_OUTPUTOVERLAPS, &
d15 3
a17 4
    & L_TRUE, L_ZETA, S_DIRECTWRITE, S_L2AUX, S_L2GP, S_TIME
  use intrinsic, only: FIELD_INDICES, L_NONE, L_CHANNEL, L_GEODANGLE, &
    & L_INTERMEDIATEFREQUENCY, L_LSBFREQUENCY, L_MAF, L_MIF, L_USBFREQUENCY, &
    & PHYQ_DIMENSIONLESS
d25 1
a25 1
  use MLSCommon, only: MLSChunk_T,R8
a30 1
  use OutputAndClose, only: DIRECTWRITE
d49 1
a49 1
       "$Id: Join.f90,v 2.59 2002/05/22 00:48:52 livesey Exp $"
d55 1
a55 1
  logical, parameter, private :: DEEBUG = .false.           ! Usually FALSE
a86 1
    integer :: FILE                 ! Name of output file for direct write
a87 1
    integer :: HDFVERSION               ! Version of hdf for directwrite
a103 2
    integer :: EXPRUNITS(2)                 ! From expr
    real (r8) :: EXPRVALUE(2)               ! From expr
d153 2
a154 2
      compareOverlaps = .false.
      outputOverlaps = .false.
a156 1
      hdfVersion = 4
a178 6
        case ( f_hdfVersion )
          call expr ( subtree(2,gson), exprUnits, exprValue )
          if ( exprUnits(1) /= phyq_dimensionless ) &
            & call Announce_error ( gson, NO_ERROR_CODE, &
            & 'No units allowed for hdfVersion: just integer 4 or 5')
          hdfVersion = exprValue(1)
d190 1
a190 1
          file = sub_rosa(subtree(2,gson))
a194 7
      ! Some final checks
      if ( any ( get_spec_id(key) == (/ s_l2gp, s_l2aux /) ) ) then
        if ( any ( got_field ( (/ f_file, f_hdfVersion /) ) ) ) &
          & call Announce_Error ( key, NO_ERROR_CODE, &
          & 'File or hdfVersion not appropriate arguments for l2aux/l2gp' )
      end if

d198 2
a199 3
      ! Now, for commands other than timing, do more complicated stuff.
      if ( get_spec_id(key) /= s_time ) then
        ! Identify the quantity
a200 1
        ! Get the precision quantity too perhaps
a210 1
        ! Establish a swath/sd name for this quantity.
d220 1
a220 1
          & hdfNameIndex = enter_terminal ( trim(hdfName), t_string )
d222 3
a224 12
        ! Now three possible cases, a direct write (either parallel or not), a
        ! parallel slave join, or a manual join
        if ( get_spec_id(key) == s_directWrite ) then
          ! For the direct write command, call some special code
          if ( .not. ValidateVectorQuantity ( quantity, minorFrame=.true. ) ) &
            & call Announce_Error ( key, NO_ERROR_CODE, &
            & 'Invalid quantity for direct write, must be minor frame' )
          call DirectWrite ( quantity, hdfNameIndex, file, hdfVersion, &
            & chunkNo, chunks )
        else if ( parallel%slave ) then
          ! For slave tasks in a PVM system, simply ship this vector off
          ! Otherwise, do a join.
d230 1
a230 1
          if (ValidateVectorQuantity(quantity,coherent=.true.,stacked=.true.,regular=.true.,&
d246 4
a249 1
      end if
d268 1
a268 1
      call output ( dble(t2 - t1), advance = 'yes' )
d277 2
a278 2
  subroutine ANNOUNCE_ERROR ( where, CODE, ExtraMessage, FIELDINDEX )
    integer, intent(in) :: where   ! Tree node where error was noticed
d280 1
a280 1
    integer, intent(in), optional :: FIELDINDEX ! Extra information for msg
d320 1
a320 1
    type (VectorValue_T), pointer :: precision ! Optional vector quantity
d343 1
a343 1
    l2gpDataIsNew = (.not. associated(l2gpDatabase))
d351 1
a351 1
    if ( present(firstInstance) ) then
d357 1
a357 1
    if ( present(lastInstance) ) then
d443 2
a444 2
         reshape(quantity%values(:,useFirstInstance:useLastInstance),&
         (/max(thisL2GP%nFreqs,1),max(thisL2GP%nLevels,1),lastProfile-firstProfile+1/))
d447 2
a448 2
      reshape(precision%values(:,useFirstInstance:useLastInstance),&
         (/max(thisL2GP%nFreqs,1),max(thisL2GP%nLevels,1),lastProfile-firstProfile+1/))
d516 2
a517 2
    l2auxDataIsNew = (.not. associated(l2auxDatabase))
    if ( .not. l2auxDataIsNew ) then
a520 1
    print*,'L2AUXDataIsNew:',l2auxDataIsNew
d523 1
a523 1
    if ( present(firstInstance) ) then
d529 1
a529 1
    if ( present(lastInstance) ) then
d552 1
a552 1
      if ( (quantity%template%noChans/=1) .and. &
d554 1
a554 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d593 1
a593 1
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
a610 1
      print*,'Setting up l2aux'
d664 2
a665 4
        & (quantity%template%minorFrame .or. quantity%template%majorFrame) ) then
        print*,'Expanding l2aux'
        call ExpandL2AUXDataInPlace ( thisL2AUX, noMAFs )
      end if
d672 1
a672 2
      lastProfile = quantity%template%mafIndex(quantity%template%noInstances - &
        & quantity%template%noInstancesUpperOverlap)
a717 9
! Revision 2.59  2002/05/22 00:48:52  livesey
! Added direct write stuff
!
! Revision 2.58  2002/05/16 22:36:46  livesey
! Fixed a bug with joining minor frame quantities with overlaps.
!
! Revision 2.57  2002/04/08 20:49:17  pwagner
! Swath name optionally passed to JoinL2GPQuantities
!
@


2.56
log
@Should accept actual case of swathname for l2gp
@
text
@d49 1
a49 1
       "$Id: Join.f90,v 2.55 2002/03/20 00:46:47 pwagner Exp $"
d314 1
a314 1
    & firstInstance, lastInstance )
d324 1
d411 5
a415 1
    call Get_String( name, thisL2GP%name, strip=.true.)
d718 3
@


2.55
log
@Removed 2 unused lits
@
text
@d49 1
a49 1
       "$Id: Join.f90,v 2.54 2001/11/09 23:17:22 vsnyder Exp $"
d87 1
d89 1
a89 1
    integer :: GSON                     ! Son of Key
d136 1
d141 1
d216 5
a220 1
        hdfNameIndex = enter_terminal ( trim(hdfName), t_string )
d713 3
@


2.54
log
@Use Time_Now instead of CPU_TIME
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d14 1
a14 2
  use INIT_TABLES_MODULE, only: L_BOUNDARYPRESSURE, L_COLUMNABUNDANCE, &
    & L_PRESSURE, &
d49 1
a49 1
       "$Id: Join.f90,v 2.53 2001/10/30 01:45:21 livesey Exp $"
d182 1
a182 1
        case (f_swath)
d184 1
a184 1
        case (f_sdName)
d186 1
a186 1
       case ( f_file)
d706 3
@


2.53
log
@Some modifications/fixes to parallel join
@
text
@d35 1
d50 1
a50 1
       "$Id: Join.f90,v 2.52 2001/10/08 23:38:58 pwagner Exp $"
d114 1
a114 1
    if ( timing ) call cpu_time ( t1 )
d144 1
a144 1
          call cpu_time ( t1 )
d255 1
a255 1
      call cpu_time ( t2 )
d707 3
@


2.52
log
@Tiny fixes; not perfect yet
@
text
@d10 1
a10 1
  use INIT_TABLES_MODULE, only: F_BOUNDARYPRESSURE, &
d49 1
a49 1
       "$Id: Join.f90,v 2.51 2001/10/06 00:27:42 pwagner Exp $"
a101 2
    integer :: BPVECTORINDEX            ! Index for bnd. pr. vector
    integer :: BPQTYINDEX               ! Index for bnd. pr. qty (in database not vector)
a109 1
    type (VectorValue_T), pointer :: BPQuantity
a175 4
        case ( f_boundaryPressure )
          source = subtree(2,gson) ! required to be an n_dot vertex
          BPVectorIndex = decoration(decoration(subtree(1,source)))
          BPQtyIndex = decoration(decoration(decoration(subtree(2,source))))
a207 26
        if ( got_field ( f_boundaryPressure ) ) then
          BPQuantity => &
            & GetVectorQtyByTemplateIndex(vectors(BPVectorIndex),BPQtyIndex)
          if ( BPQuantity%template%quantityType /= l_boundaryPressure ) then
            call announce_error(key, NO_ERROR_CODE, &
            & 'boundaryPressure field type appears not to be bnd. pr.')
          elseif ( Quantity%template%quantityType /= l_columnAbundance ) then
            call announce_error(key, NO_ERROR_CODE, &
            & 'swath field type appears not to be colm. abund.')
          elseif ( .not. DoHgridsMatch( quantity, BPQuantity ) ) then
            call announce_error(key, NO_ERROR_CODE, &
            & 'boundaryPressure on different HGrid')
!            print *, 'quantity: nInstances ', quantity%template%noInstances
!            print *, 'BP: nInstances ', BPQuantity%template%noInstances
!            print *, 'quantity: noSurfs ', quantity%template%noSurfs
!            print *, 'BP: noSurfs ', BPQuantity%template%noSurfs
!            print *, 'quantity: phi ', quantity%template%phi
!            print *, 'BP: phi ', BPQuantity%template%phi
          elseif ( get_spec_id(key) /= s_l2gp ) then
            call announce_error(key, NO_ERROR_CODE, &
            & 'boundaryPressure field appropriate only for l2gp')
          endif
        else
          BPQuantity => NULL()
        endif

d218 1
a218 1
          call SlaveJoin ( quantity, precisionQuantity, BPQuantity, &
d230 1
a230 1
              & precisionQuantity, BPQuantity, l2gpDatabase, chunkNo )
d306 1
a306 1
    & precision, BPressure, l2gpDatabase, chunkNo, &
a313 1
    type (VectorValue_T), pointer :: BPRESSURE ! Optional vector quantity
d363 1
a363 3
      if ( associated(BPressure) ) then
        noSurfsInL2GP = 1
      elseif (any(quantity%template%verticalCoordinate == (/l_Pressure, l_Zeta /) )) then
d377 4
a380 8
      if ( associated(BPressure) ) then
        newL2GP%pressures = BPressure%values(1, 1)
      else
        if ( quantity%template%verticalCoordinate == l_Pressure ) &
          & newL2GP%pressures = quantity%template%surfs(:,1)
        if ( quantity%template%verticalCoordinate == l_Zeta ) &
          & newL2GP%pressures = 10.0**(-quantity%template%surfs(:,1))
      endif
d706 3
@


2.51
log
@Still some problems with diagnostics
@
text
@d26 1
a26 1
  use MLSCommon, only: MLSChunk_T, R8
d49 1
a49 1
       "$Id: Join.f90,v 2.50 2001/09/28 23:59:20 pwagner Exp $"
d516 1
a516 1
    integer ::                           DimensionIndex, Channel, Surf, Prof, &
d587 1
a587 1
      if ( quantity%template%minorFrame ) then
d746 3
@


2.50
log
@Fixed various timing problems
@
text
@d49 1
a49 1
       "$Id: Join.f90,v 2.49 2001/09/28 17:50:30 pwagner Exp $"
d55 2
d520 1
d526 15
d567 5
d642 1
d662 1
a662 1
        ! The error message here is rather vaugue.  The issue is that
d691 2
a692 1
      if (.not. quantity%template%minorFrame) &
d699 1
a699 1
    if (quantity%template%minorFrame) then
d706 16
d746 3
@


2.49
log
@MLSL2Timings module keeps timing info
@
text
@d28 1
a28 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, &
    & MLSMSG_Allocate, MLSMSG_Deallocate
a31 1
  use QuantityTemplates, only: QuantityTemplate_T
d35 1
a35 1
  use TOGGLES, only: GEN, LEVELS, TOGGLE
d40 2
a41 2
  use VectorsModule, only: GetVectorQuantity, GetVectorQtyByTemplateIndex, &
    & ValidateVectorQuantity, Vector_T, VectorValue_T, DUMP
d49 1
a49 1
       "$Id: Join.f90,v 2.48 2001/09/08 00:21:44 pwagner Exp $"
a93 1
    integer :: STATUS                   ! Flag
d114 1
a353 1
    integer :: FreqNo, ProfNo, Status
a506 1
    integer ::                           Status, ProfNo
d515 1
a515 1
    &                                    NoMAFs,index, InstanceNo
a517 1
    integer ::                           IERR
d705 3
@


2.48
log
@Revised to work for new column Abundance in lone swaths
@
text
@d27 1
d32 1
a32 1
  use OUTPUT_M, only: OUTPUT
d51 1
a51 1
       "$Id: Join.f90,v 2.47 2001/09/05 20:34:56 pwagner Exp $"
d116 1
a116 1
    timing = .false.
d288 5
d710 3
@


2.47
log
@Reverted to pre-columnAbundance state
@
text
@d10 2
a11 1
  use INIT_TABLES_MODULE, only: F_COMPAREOVERLAPS, F_FILE, F_OUTPUTOVERLAPS, &
d14 2
a15 1
  use INIT_TABLES_MODULE, only: L_PRESSURE, &
d25 1
d50 1
a50 1
       "$Id: Join.f90,v 2.46 2001/08/03 23:13:52 pwagner Exp $"
d102 2
d112 1
d178 4
d208 1
a208 1
            & call MLSMessage(MLSMSG_Error,ModuleName, &
d214 26
d250 1
a250 1
          call SlaveJoin ( quantity, precisionQuantity, &
d262 1
a262 1
              & precisionQuantity, l2gpDatabase, chunkNo )
d333 1
a333 1
    & precision, l2gpDatabase, chunkNo, &
d341 1
d392 3
a394 1
      if (any(quantity%template%verticalCoordinate == (/l_Pressure, l_Zeta /) )) then
d408 8
a415 4
      if ( quantity%template%verticalCoordinate == l_Pressure ) &
        & newL2GP%pressures = quantity%template%surfs(:,1)
      if ( quantity%template%verticalCoordinate == l_Zeta ) &
        & newL2GP%pressures = 10.0**(-quantity%template%surfs(:,1))
d704 3
@


2.46
log
@Began testing; at least now exits normally again
@
text
@d10 1
a10 2
  use INIT_TABLES_MODULE, only: F_BOUNDARYPRESSURE, F_COLUMNABUNDANCE, &
    & F_COMPAREOVERLAPS, F_FILE, F_OUTPUTOVERLAPS, &
d13 1
a13 1
  use INIT_TABLES_MODULE, only: L_COLUMNABUNDANCE, L_PRESSURE, &
d47 1
a47 1
       "$Id: Join.f90,v 2.45 2001/08/02 23:58:31 pwagner Exp $"
a58 2
  integer, parameter :: MAXNCOLUMNS=30 ! Why would you need more tropopauses defs

a98 3
    integer :: NCOLUMNS                 ! number of elements in column field
    integer :: COLUMNINDEX              ! Index for looping over nColumns
    integer :: NBNDPRESS                ! n. of els in boundaryPressure field
a100 5
    integer :: COLMVECTORINDEX(MAXNCOLUMNS) ! Index for column vector
    integer :: COLMQTYINDEX(MAXNCOLUMNS)    ! Index for col. qty (in database not vector)
    integer :: BPRSVECTORINDEX(MAXNCOLUMNS) ! Index for bnd. press. vector
    integer :: BPRSQTYINDEX(MAXNCOLUMNS)    ! Index for bnd. press. qty (in database not vector)

a106 2
    type (VectorValue_T), pointer :: ColAbundQuantity
    type (VectorValue_T), pointer :: BndPressQuantity
a149 2
      ncolumns = 0
      nbndpress = 0
a171 26
        case ( f_columnAbundance )
          ncolumns = nsons(gson)-1  ! less the "column" name
          if(ncolumns > MAXNCOLUMNS) then
             call announce_error(key,NO_ERROR_CODE, &
             & 'Too many columnAbundances in field' )
          endif
          do columnindex = 1, nColumns
            source = subtree(columnindex+1,gson) ! required to be an n_dot vertex
            colmVectorIndex(columnindex) = &
              & decoration(decoration(subtree(1,source)))
            colmQtyIndex(columnindex) = &
              & decoration(decoration(decoration(subtree(2,source))))
          enddo
        case ( f_boundaryPressure )
          nbndpress = nsons(gson)-1  ! less the "column" name
          if(nbndpress > MAXNCOLUMNS) then
             call announce_error(key,NO_ERROR_CODE, &
             & 'Too many boundaryPressures in field' )
          endif
          do columnindex = 1, nbndpress
            source = subtree(columnindex+1,gson) ! required to be an n_dot vertex
            bPrsVectorIndex(columnindex) = &
              & decoration(decoration(subtree(1,source)))
            bPrsQtyIndex(columnindex) = &
              & decoration(decoration(decoration(subtree(2,source))))
          enddo
a187 6
   ! Check that same num of columns and bnd. press.
      if( ncolumns /= nbndpress ) then
             call announce_error(key, NO_ERROR_CODE, &
             & 'nColumns != nBoundaryPressures in Join' )
      endif

a202 33
        if ( got_field ( f_columnAbundance ) ) then
          do columnindex=1, nColumns
             ColAbundQuantity => &
               & GetVectorQtyByTemplateIndex( &
               & vectors(colmVectorIndex(columnindex)), &
               & colmQtyIndex(columnindex) &
               & )
!              What features of quantity and ColAbundQuantity need to match?
!             if ( quantity%template%id /= &
!               & ColAbundQuantity%template%id ) then
             if ( l_ColumnAbundance /= &
               & ColAbundQuantity%template%QuantityType ) then
               call announce_error(key,NO_ERROR_CODE, &
               & 'Column abundance not of proper type')
               call output(' l_columnAbundance type: ', advance='no')
               call output(l_columnAbundance, advance='yes')
               call output(' column abundance type: ', advance='no')
               call output(ColAbundQuantity%template%QuantityType, advance='yes')
             endif
           enddo
        else
          ColAbundQuantity => NULL()
        endif
        if ( got_field ( f_boundaryPressure ) ) then
          do columnindex=1, nColumns
             BndPressQuantity => &
               & GetVectorQtyByTemplateIndex( &
               & vectors(bPrsVectorIndex(columnindex)), &
               & bPrsQtyIndex(columnindex))
          enddo
        else
          BndPressQuantity => NULL()
        endif
d226 1
a226 3
              & precisionQuantity, vectors, l2gpDatabase, &
              & colmvectorindex, colmqtyindex, &
              & bprsvectorindex, bprsqtyindex, nColumns, chunkNo )
d297 1
a297 3
    & precision, vectors, l2gpDatabase, &
    & colmvectorindex, colmqtyindex, &
    & bprsvectorindex, bprsqtyindex, nColumns, chunkNo, &
a304 1
    type (Vector_T), dimension(:), pointer :: vectors
a305 5
    integer, intent(in), dimension(:) :: COLMVECTORINDEX 
    integer, intent(in), dimension(:) :: COLMQTYINDEX    
    integer, intent(in), dimension(:) :: BPRSVECTORINDEX 
    integer, intent(in), dimension(:) :: BPRSQTYINDEX    
    integer, intent(in) :: NCOLUMNS
d313 1
a313 1
    integer :: FreqNo, ProfNo, Status, ColumnIndex
a315 2
    type (VectorValue_T), pointer :: BndPressQuantity ! Vector quantity
    type (VectorValue_T), pointer :: ColAbundQuantity ! Vector quantity
d389 1
a389 2
      & newNTimes=thisL2GP%nTimes+noOutputInstances, &
      & newNColumns=nColumns )
a434 20
   ! Column stuff
   if(nColumns > 0) then
      do columnindex=1, nColumns
         ColAbundQuantity => &
           & GetVectorQtyByTemplateIndex( &
           & vectors(colmVectorIndex(columnindex)), &
           & colmQtyIndex(columnindex) &
           & )
         BndPressQuantity => &
           & GetVectorQtyByTemplateIndex( &
           & vectors(bPrsVectorIndex(columnindex)), &
           & bPrsQtyIndex(columnindex))
         thisL2GP%columnTypes(columnindex) = 'Tropopause not defined'
         thisL2GP%columnValues(firstProfile:lastProfile,columnindex) = &
           & ColAbundQuantity%values(1,useFirstInstance:useLastInstance)
         thisL2GP%boundaryPressures(firstProfile:lastProfile,columnindex) = &
           & BndPressQuantity%values(1,useFirstInstance:useLastInstance)
      enddo
   endif

d661 3
@


2.45
log
@More complete treatment of column abundance(s)
@
text
@d14 1
a14 1
  use INIT_TABLES_MODULE, only: L_PRESSURE, &
d48 1
a48 1
       "$Id: Join.f90,v 2.44 2001/08/02 00:18:55 pwagner Exp $"
d257 13
a269 5
             if ( quantity%template%id /= &
               & ColAbundQuantity%template%id ) &
               & call MLSMessage(MLSMSG_Error,ModuleName, &
               & 'Quantity and column abundance do not match')
          enddo
d323 4
d774 3
@


2.44
log
@Began adding column quantities; incomplete
@
text
@d48 1
a48 1
       "$Id: Join.f90,v 2.43 2001/07/31 23:25:32 pwagner Exp $"
d57 1
d60 2
d102 3
a104 4
    integer :: COLMVECTORINDEX          ! Index for column vector
    integer :: COLMQTYINDEX             ! Index for column qty (in database not vector)
    integer :: BPRSVECTORINDEX          ! Index for bound. press. vector
    integer :: BPRSQTYINDEX             ! Index for bound. press. qty (in database not vector)
d107 5
d163 2
d188 12
a199 3
          source = subtree(2,gson) ! required to be an n_dot vertex
          colmVectorIndex = decoration(decoration(subtree(1,source)))
          colmQtyIndex = decoration(decoration(decoration(subtree(2,source))))
d201 12
a212 3
          source = subtree(2,gson) ! required to be an n_dot vertex
          bPrsVectorIndex = decoration(decoration(subtree(1,source)))
          bPrsQtyIndex = decoration(decoration(decoration(subtree(2,source))))
d224 1
a224 1
          call announce_error(key,NotAllowed,field_index)
d229 6
d251 11
a261 5
          ColAbundQuantity => &
            & GetVectorQtyByTemplateIndex(vectors(colmVectorIndex),colmQtyIndex)
          if ( quantity%template%id /= ColAbundQuantity%template%id ) &
            & call MLSMessage(MLSMSG_Error,ModuleName, &
            & 'Quantity and column abundance do not match')
d266 6
a271 2
          BndPressQuantity => &
            & GetVectorQtyByTemplateIndex(vectors(bPrsVectorIndex),bPrsQtyIndex)
d298 3
a300 2
            & precisionQuantity, BndPressQuantity, ColAbundQuantity, &
              & l2gpDatabase, chunkNo )
d331 1
a331 1
  subroutine ANNOUNCE_ERROR ( WHERE, CODE, FIELDINDEX )
d335 1
d339 5
a343 1
    call print_source ( source_ref(where) )
d350 2
d353 3
d367 4
a370 2
    & precision, BndPressQuantity, ColAbundQuantity, l2gpDatabase, &
    & chunkNo, firstInstance, lastInstance )
d377 1
a377 2
    type (VectorValue_T), pointer :: BndPressQuantity ! Vector quantity
    type (VectorValue_T), pointer :: ColAbundQuantity ! Vector quantity
d379 5
d391 1
a391 1
    integer :: FreqNo, ProfNo, Status
d394 2
a400 1
    logical :: newColumn
a404 2
   newColumn = associated(BndPressQuantity) .and. associated(ColAbundQuantity)

d470 1
a470 1
      & newColumn=newColumn )
d516 20
d762 3
@


2.43
log
@Able to accept 2 new fields for join of column; does nothing yet
@
text
@d48 1
a48 1
       "$Id: Join.f90,v 2.42 2001/06/19 22:52:31 pwagner Exp $"
d254 2
a255 1
            call JoinL2GPQuantities ( key, hdfNameIndex, quantity, precisionQuantity, &
d312 2
a313 1
  subroutine JoinL2GPQuantities ( key, name, quantity, precision, l2gpDatabase, &
d321 2
d339 1
d344 2
d410 2
a411 1
      & thisL2GP%nTimes+noOutputInstances )
d683 3
@


2.42
log
@l_none  no longer got from init_tables_module
@
text
@d10 2
a11 1
  use INIT_TABLES_MODULE, only: F_COMPAREOVERLAPS, F_FILE, F_OUTPUTOVERLAPS, &
d48 1
a48 1
       "$Id: Join.f90,v 2.41 2001/05/23 21:59:43 livesey Exp $"
d99 4
d111 2
d178 8
d217 15
d675 3
@


2.41
log
@Interim version, almost there
@
text
@d13 1
a13 1
  use INIT_TABLES_MODULE, only: L_PRESSURE, L_NONE, &
d47 1
a47 1
       "$Id: Join.f90,v 2.40 2001/05/23 01:43:19 livesey Exp $"
d645 3
@


2.40
log
@New parallel version in progress
@
text
@d21 1
a21 1
  use L2Parallel, only: PARALLEL, SLAVEJOIN
d43 1
a43 1
  public :: MLSL2Join
d47 1
a47 1
       "$Id: Join.f90,v 2.39 2001/05/19 01:19:58 livesey Exp $"
d645 3
@


2.39
log
@Fills precision correctly for l2gp!
@
text
@d21 1
d47 1
a47 1
       "$Id: Join.f90,v 2.38 2001/05/14 22:23:53 livesey Exp $"
d202 1
a202 1
        
d210 5
a214 10
        ! Now, depending on the properties of the source we deal with the
        ! vector quantity appropriately.
        if (ValidateVectorQuantity(quantity,coherent=.TRUE.,stacked=.TRUE.,regular=.TRUE.,&
          & verticalCoordinate=(/L_Pressure,L_Zeta,L_None/))) then
          ! Coherent, stacked, regular quantities on pressure surfaces, or
          ! with no vertical coordinate system go in l2gp files.
          if ( get_spec_id(key) /= s_l2gp ) call MLSMessage ( MLSMSG_Error,&
            & ModuleName, 'This quantity should be joined as an l2gp')
          call JoinL2GPQuantities ( key, hdfNameIndex, quantity, precisionQuantity, &
            & l2gpDatabase, chunkNo )
d216 18
a233 6
          ! All others go in l2aux files.
          if ( get_spec_id(key) /= s_l2aux ) call MLSMessage ( MLSMSG_Error,&
            & ModuleName, 'This quantity should be joined as an l2aux')
          call JoinL2AUXQuantities ( key, hdfNameIndex, quantity, &
            & l2auxDatabase, chunkNo, chunks )
        endif
d645 3
@


2.38
log
@Embarassing bug fix, to do with renumbering of minor frame L2AUX quantities.
@
text
@d46 1
a46 1
       "$Id: Join.f90,v 2.37 2001/05/12 00:18:17 livesey Exp $"
d401 1
a401 1
    if (associated(precision)) &
d405 3
a407 1
    thisL2GP%l2gpPrecision(:,:,firstProfile:lastProfile) = 0.0 ! Later put something here
d637 3
@


2.37
log
@Tidied up array bounds for L2AUX/MAF.
@
text
@d46 1
a46 1
       "$Id: Join.f90,v 2.36 2001/05/10 16:31:24 livesey Exp $"
d509 1
a509 1
          dimensionStarts = (/1, quantity%template%noSurfs, firstMAF /)
d635 3
@


2.36
log
@Added prefix signal option for swath/sd name
@
text
@d46 1
a46 1
       "$Id: Join.f90,v 2.35 2001/05/08 23:25:32 livesey Exp $"
d433 2
a434 1

d441 1
a441 1
    integer, dimension(3) ::             DimensionFamilies, DimensionSizes
d501 3
a503 2
        noMAFs = maxval( chunks%lastMAFIndex ) - &
          &      minval( chunks%firstMAFIndex ) + 1
d509 1
d514 1
d536 1
d541 1
d546 2
a547 1
      call SetupNewL2AUXRecord ( dimensionFamilies, dimensionSizes, newL2AUX )
d635 3
@


2.35
log
@Added the precision stuff for l2gp's
@
text
@d11 1
a11 1
    & F_PRECISION, F_SOURCE, F_SDNAME, F_SWATH, FIELD_FIRST, &
d25 1
d30 2
d46 1
a46 1
       "$Id: Join.f90,v 2.34 2001/05/08 21:51:02 livesey Exp $"
d81 1
a87 1
    integer :: SDNAME                   ! Name index
a90 1
    integer :: SWATHNAME                ! Name index
d94 1
d101 1
d146 2
a147 2
      sdName=name
      swathName=name
d170 2
d177 1
a177 1
          swathName= sub_rosa(subtree(2,gson))
d179 1
a179 1
          sdName= sub_rosa(subtree(2,gson))
d202 7
d217 1
a217 1
          call JoinL2GPQuantities ( key, swathName, quantity, precisionQuantity, &
d223 2
a224 1
          call JoinL2AUXQuantities ( key, sdName, quantity, l2auxDatabase, chunkNo, chunks )
d277 2
a278 2
    integer, intent(in) :: KEY     ! spec_args to Decorate with the L2GP index
    integer, intent(in) :: NAME    ! Of the l2gp command
d371 1
a371 1
    call get_string(name, thisL2gp%name, strip=.true.)
d422 1
a422 1
    integer, intent(in) :: NAME    ! of the l2aux command
d628 3
@


2.34
log
@Removed some old xStar, yStar, kStar stuff.
@
text
@d11 1
a11 1
    & F_SOURCE, F_SDNAME, F_SWATH, FIELD_FIRST, &
d43 1
a43 1
       "$Id: Join.f90,v 2.33 2001/05/03 20:32:19 vsnyder Exp $"
d75 1
a75 1
    logical :: CompareOverlaps
a77 1
    logical :: GOT_FIELD(field_first:field_last)
a82 1
    type (VectorValue_T), pointer :: Quantity
d90 6
a95 1
    integer :: VECTORINDEX, QUANTITYINDEX
d97 4
a100 1
    logical :: TIMING
d162 4
d186 9
d204 2
a205 1
          call JoinL2GPQuantities ( key, swathName, quantity, l2gpDatabase, chunkNo )
d259 1
a259 1
  subroutine JoinL2GPQuantities ( key, name, quantity, l2gpDatabase, &
d265 2
a266 1
    type (VectorValue_T), intent(in) :: QUANTITY
d384 1
a384 1
    thisL2GP%l2gpValue(:,:,firstProfile:lastProfile)=&
d387 4
d614 3
@


2.33
log
@Cosmetic changes
@
text
@d11 1
a11 1
    & F_SOURCE, F_SDNAME, F_SWATH, F_XSTAR, F_YSTAR, F_KSTAR, FIELD_FIRST, &
d43 1
a43 1
       "$Id: Join.f90,v 2.32 2001/05/02 22:22:43 pwagner Exp $"
a81 1
    integer :: KSTARINDEX               ! Matrix index
a92 2
    integer :: XSTARINDEX               ! Vector index
    integer :: YSTARINDEX               ! Vector index
a137 3
      xStarIndex = 0
      yStarIndex = 0
      kStarIndex = 0
a151 6
        case ( f_xStar )
          xStarIndex = decoration(value)
        case ( f_yStar )
          yStarIndex = decoration(value)
        case ( f_kStar )
          kStarIndex = decoration(value)
d589 3
@


2.32
log
@Removed SDPToolkit use
@
text
@d43 1
a43 1
       "$Id: Join.f90,v 2.31 2001/04/28 01:30:14 livesey Exp $"
d75 1
d83 3
a85 1
    integer :: mlscfLine
a86 1
    integer :: SWATHNAME                ! Name index
d91 1
d96 1
a96 3
    type (VectorValue_T), pointer :: quantity
    logical :: compareOverlaps, outputOverlaps
    REAL :: T1, T2     ! for timing
d266 9
a274 9
    integer :: status,profNo,freqNo
    type (L2GPData_T) :: newL2GP
    type (L2GPData_T), pointer :: thisL2GP
    integer :: index
    integer :: firstProfile,lastProfile ! Profile range in the l2gp to output to
    integer :: noSurfsInL2GP,noFreqsInL2GP
    integer :: useFirstInstance,useLastInstance,noOutputInstances
    logical :: l2gpDataIsNew
    real(r8), dimension(:,:), pointer :: values
d407 13
a419 13
    integer ::                              status, profNo
    integer ::                              useFirstInstance, useLastInstance, &
    &                                          noOutputInstances
    type (L2AUXData_T) ::                   newL2AUX
    type (L2AUXData_T), pointer ::          thisL2AUX
    logical ::                              l2auxDataIsNew
    integer, dimension(3) ::                dimensionFamilies, dimensionSizes
    integer ::                              auxFamily     ! Channel or Frequency
    integer ::                              dimensionIndex,channel,surf,prof, &
    &                                         noMAFs,index, InstanceNo
    integer ::                              firstProfile,lastProfile
    real(r8), dimension(:,:), pointer ::    values
    INTEGER                              :: IERR
d601 3
@


2.31
log
@Basically gone back to an earlier version.  As l2pc's now output
directly as matrices there is no need for Join to think about them.
@
text
@a27 1
  use SDPToolkit, only: PGS_S_SUCCESS, PGS_TD_TAItoUTC, PGSTD_E_NO_LEAP_SECS
d43 1
a43 1
       "$Id: Join.f90,v 2.30 2001/04/27 21:52:39 livesey Exp $"
d600 4
@


2.30
log
@Removed l2pc stuff
@
text
@a21 2
  use MatrixModule_1, only: CopyMatrix, Matrix_Database_T, &
    & Dump, GetFromMatrixDatabase, Matrix_T
d44 1
a44 1
       "$Id: Join.f90,v 2.29 2001/04/26 20:02:09 livesey Exp $"
d64 1
a64 1
  subroutine MLSL2Join ( root, vectors, matrices, l2gpDatabase, l2auxDatabase, &
a69 1
    type (Matrix_Database_T), dimension(:), pointer :: matrices
d601 3
@


2.29
log
@Made l2pc database a saved array in L2PC_m
@
text
@d14 1
a14 1
    & L_TRUE, L_ZETA, S_L2AUX, S_L2GP, S_L2PC, S_TIME
a20 1
  use L2PC_M, only: L2PC_T, AddL2PCToDatabase, l2pcDatabase
d25 2
a26 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d46 1
a46 1
       "$Id: Join.f90,v 2.28 2001/04/26 15:59:30 livesey Exp $"
d67 1
a67 1
    & canDoL2PC, chunkNo, chunks )
a74 1
    logical, intent(in) :: canDoL2PC
d92 1
a101 3
    type (Matrix_T), pointer :: tmpKStar
    type (L2PC_T) :: thisL2PC

a128 1
      case ( s_l2pc )
a207 9
      case ( s_l2pc ) ! ------------------- L2PC Bins ------------------------
        if (.not. canDoL2PC) call MLSMessage(MLSMSG_Error,ModuleName,&
          & "Cannot join l2pcs in multi chunk l2cfs")
        thisL2PC%xStar = vectors(xStarIndex)
        thisL2PC%yStar = vectors(yStarIndex)
        call GetFromMatrixDatabase ( matrices(kStarIndex), tmpKStar )
        thisL2PC%kStar=tmpKStar
        call decorate ( key, AddL2PCToDatabase ( l2pcDatabase, thisL2PC ) )
        
d604 3
@


2.28
log
@Tidied up uses
@
text
@d21 1
a21 1
  use L2PC_M, only: L2PC_T, AddL2PCToDatabase
d46 1
a46 1
       "$Id: Join.f90,v 2.27 2001/04/26 02:44:17 vsnyder Exp $"
d67 1
a67 1
    & l2pcDatabase, canDoL2PC, chunkNo, chunks )
a74 1
    type (L2PC_T), dimension(:), pointer :: l2pcDatabase
d617 3
@


2.27
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@a26 1
  use MatrixModule_1, only: Matrix_Database_T, GetFromMatrixDatabase, Matrix_T
d46 1
a46 1
       "$Id: $"
d49 1
a49 1
       "$RCSfile: $"
d618 3
@


2.26
log
@Insulate vector is gone
@
text
@d10 3
a12 2
  use INIT_TABLES_MODULE, only: F_COMPAREOVERLAPS, F_FILE, F_OUTPUTOVERLAPS, F_SOURCE, &
    & F_SDNAME, F_SWATH, F_XSTAR, F_YSTAR, F_KSTAR, FIELD_FIRST, FIELD_INDICES, FIELD_LAST
d15 2
d21 1
a22 1
  use L2PC_M, only: L2PC_T, AddL2PCToDatabase
d27 1
a39 2
  use Intrinsic, ONLY: L_NONE, L_CHANNEL, L_GEODANGLE, L_USBFREQUENCY, L_LSBFREQUENCY,&
       L_INTERMEDIATEFREQUENCY, L_MIF, L_MAF
d45 7
a51 5
  !---------------------------- RCS Ident Info -------------------------------
  character (len=256) :: Id = &
       "$Id: Join.f90,v 2.25 2001/04/25 21:54:22 livesey Exp $"
  character (len=*), parameter :: ModuleName= "$RCSfile: Join.f90,v $"
  !---------------------------------------------------------------------------
d619 3
@


2.25
log
@Added candol2pc flag
@
text
@d35 1
a35 1
    & ValidateVectorQuantity, Vector_T, VectorValue_T, DUMP, InsulateVector
d45 1
a45 1
       "$Id: Join.f90,v 2.24 2001/04/25 21:51:46 livesey Exp $"
d216 1
a216 1
        thisL2PC%kStar = tmpKStar
d615 3
@


2.24
log
@Tidied up Join for l2pcs
@
text
@d45 1
a45 1
       "$Id: Join.f90,v 2.23 2001/04/25 20:33:28 livesey Exp $"
d64 1
a64 1
    & l2pcDatabase, chunkNo, chunks )
d73 1
d211 2
d615 3
@


2.23
log
@Minor improvements to Join l2pc stuff
@
text
@d20 2
a21 1
  use MatrixModule_1, only: Matrix_Database_T, GetFromMatrixDatabase, Matrix_T
d45 1
a45 1
       "$Id: Join.f90,v 2.22 2001/04/24 20:20:27 livesey Exp $"
a210 1
        call InsulateVector(thisL2PC%xStar)
a211 1
        call InsulateVector(thisL2PC%yStar)
d612 3
a681 3



@


2.22
log
@L2PC moved to lib and word bin dropped from types etc.
@
text
@d34 1
a34 1
    & ValidateVectorQuantity, Vector_T, VectorValue_T, DUMP
d44 1
a44 1
       "$Id: Join.f90,v 2.21 2001/04/24 20:04:54 livesey Exp $"
d210 1
d212 1
d613 3
@


2.21
log
@Added l2pc joining
@
text
@d19 1
a19 1
  use L2PC_M, only: L2PCBin_T, AddL2PCBinToDatabase
d44 1
a44 1
       "$Id: Join.f90,v 2.20 2001/04/10 23:44:44 vsnyder Exp $"
d71 1
a71 1
    type (L2PCBin_T), dimension(:), pointer :: l2pcDatabase
d99 1
a99 1
    type (L2PCBin_T) :: thisL2PC
d213 1
a213 1
        call decorate ( key, AddL2PCBinToDatabase ( l2pcDatabase, thisL2PC ) )
d611 3
@


2.20
log
@Improve 'dump'
@
text
@d11 3
a13 2
    & F_SDNAME, F_SWATH, FIELD_FIRST, FIELD_INDICES, FIELD_LAST, L_PRESSURE, L_NONE, &
    & L_TRUE, L_ZETA, S_L2AUX, S_L2GP, S_TIME
d19 2
a21 1
! use MLSL2Common
d44 1
a44 1
       "$Id: Join.f90,v 2.19 2001/03/15 23:26:56 livesey Exp $"
d62 2
a63 1
  subroutine MLSL2Join ( root, vectors, l2gpDatabase, l2auxDatabase, chunkNo, chunks )
d67 2
a68 1
    type (Vector_T), dimension(:), intent(in) :: vectors
d71 2
a73 1
    integer, intent(in) :: chunkNo
d76 2
a77 2
    integer :: FIELD               ! Subtree index of "field" node
    integer :: FIELD_INDEX         ! F_..., see Init_Tables_Module
d79 4
a82 3
    integer :: GSON                ! Son of Key
    integer :: KEY                 ! Index of an L2GP or L2AUX tree
    integer :: KEYNO               ! Index of subtree of KEY
d84 1
a84 1
    integer :: NAME                ! Sub-rosa index of name of L2GP or L2AUX
d87 6
a92 4
    integer :: SON                 ! A son of ROOT
    integer :: SOURCE              ! Index in AST
    integer :: VALUE               ! Value of a field
    integer :: vectorIndex, quantityIndex
d98 3
d128 1
a139 1
!     name=mlscfSection%entries(mlscfLine)%mlscfEntryName
d144 3
d161 6
d188 29
a216 4
      quantity => GetVectorQtyByTemplateIndex(vectors(vectorIndex),quantityIndex)

      ! Now, depending on the properties of the source we deal with the
      ! vector quantity appropriately.
a217 9
      if (ValidateVectorQuantity(quantity,coherent=.TRUE.,stacked=.TRUE.,regular=.TRUE.,&
        & verticalCoordinate=(/L_Pressure,L_Zeta,L_None/))) then
        ! Coherent, stacked, regular quantities on pressure surfaces, or
        ! with no vertical coordinate system go in l2gp files.
        call JoinL2GPQuantities ( key, swathName, quantity, l2gpDatabase, chunkNo )
      else
        ! All others go in l2aux files.
        call JoinL2AUXQuantities ( key, sdName, quantity, l2auxDatabase, chunkNo, chunks )
      endif
d220 1
a220 6
    if ( toggle(gen) ) then
      if ( levels(gen) > 0 ) then
!       call dump ( ???, details=levels(gen)-1 )
      end if
      call trace_end ( "MLSL2Join" )
    end if
d611 3
@


2.19
log
@Avoid calling ExpandL2AUXQuantitiesInPlace for minor frame quantities.
Really saves on memory thrashing.
@
text
@d42 1
a42 1
       "$Id: Join.f90,v 2.18 2001/03/15 21:18:57 vsnyder Exp $"
d186 1
a186 1
!       call dump ( ??? )
d580 4
@


2.18
log
@Use Get_Spec_ID instead of decoration(subtree...
@
text
@d42 1
a42 1
       "$Id: Join.f90,v 2.17 2001/03/06 22:40:41 livesey Exp $"
d60 1
a60 1
  subroutine MLSL2Join ( root, vectors, l2gpDatabase, l2auxDatabase, chunkNo )
d67 1
d180 1
a180 1
        call JoinL2AUXQuantities ( key, sdName, quantity, l2auxDatabase, chunkNo )
d370 1
a370 1
    & chunkNo, firstInstance, lastInstance )
d379 1
d449 7
a455 2
        noMAFs = quantity%template%mafIndex(quantity%template%noInstances) - &
          & quantity%template%noInstancesUpperOverlap
d540 4
a543 1
      call ExpandL2AUXDataInPlace ( thisL2AUX, noMAFs )
d549 5
a553 1
    lastProfile = thisL2AUX%dimensions(L2AUXRank)%noValues
d565 1
a565 1
     
d568 3
a570 1
      &   shape(thisL2AUX%values(:,:,firstProfile:lastProfile)))
d580 3
@


2.17
log
@New L2AUX stuff
@
text
@d21 1
d42 1
a42 1
       "$Id: Join.f90,v 2.16 2001/03/05 20:46:41 livesey Exp $"
d113 1
a113 1
      select case( decoration(subtree(1,decoration(subtree(1,key)))) )
d564 3
@


2.16
log
@Removed a debugging statement left behind
@
text
@d11 1
a11 1
    & F_UNPACKOUTPUT, FIELD_FIRST, FIELD_INDICES, FIELD_LAST, L_PRESSURE, L_NONE, &
d14 1
a14 3
    & L2AUXData_T, L2AUXDim_Channel, L2AUXDim_geodAngle, &
    & L2AUXDim_IntermediateFrequency, L2AUXDim_LSBFrequency, L2AUXDim_MAF, &
    & L2AUXDim_MIF, L2AUXDim_None, L2AUXDim_USBFrequency, SetupNewL2AUXRecord
d24 1
a24 1
  use String_Table, only: DISPLAY_STRING
d32 2
a33 2
  use Intrinsic, ONLY: L_NONE, L_INSTRUMENTCHANNEL, L_USBFREQUENCY, L_LSBFREQUENCY,&
       L_INTERMEDIATEFREQUENCY
d41 1
a41 1
       "$Id: Join.f90,v 2.15 2001/03/05 01:19:45 livesey Exp $"
d77 2
d84 1
a84 1
    logical :: compareOverlaps, outputOverlaps, unpackOutput
d129 2
a130 1
      unpackOutput = .FALSE.
d152 6
a157 2
          outputOverlaps = value == l_true
        case ( f_file)
a158 2
        case ( f_unpackoutput )
          unpackOutput = value == l_true
d175 1
a175 1
        call JoinL2GPQuantities ( key, name, quantity, l2gpDatabase, chunkNo )
d178 1
a178 2
        call JoinL2AUXQuantities ( key, name, quantity, l2auxDatabase, chunkNo, &
          & unpackOutput=unpackOutput )
d325 1
a366 4
  ! The unpackOutput argument warrants some explanation.  If it is set false,
  ! then the data is output with no gaps in the arrays.  If it is true, then
  ! the last dimension if it's MAF is used as an index into the arrays.

d368 1
a368 1
    & chunkNo, firstInstance, lastInstance, unpackOutput)
a377 1
    logical, intent(in), optional :: unpackOutput
d388 1
a388 1
    logical ::                              l2auxDataIsNew, useUnpackOutput
a408 1

a422 1

a426 12
    ! Sort out the unpackOutput flag

    if ( PRESENT(unpackOutput) ) then
      useUnpackOutput = unpackOutput
    else
      useUnpackOutput = .FALSE.
    end if

    if ( useUnpackOutput.AND.(.NOT.quantity%template%minorFrame) ) call MLSMessage ( &
      & MLSMSG_Error ,ModuleName, "Can only use the unpack output flag"// &
      & " for minor frame quantities")

d440 1
a440 14
      select case (quantity%template%frequencyCoordinate)
      case ( L_InstrumentChannel )
        auxFamily = L2AUXDim_Channel
      case ( L_IntermediateFrequency )
        auxFamily = L2AUXDim_IntermediateFrequency
      case ( L_USBFrequency )
        auxFamily = L2AUXDim_USBFrequency
      case ( L_LSBFrequency )
        auxFamily = L2AUXDim_LSBFrequency
      case ( L_None ) ! OK to do nothing
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Unrecognised frequency coordinate" )
      end select
d446 2
a447 6
        if ( useUnpackOutput ) then
          noMAFs = quantity%template%mafIndex(quantity%template%noInstances)
        else
          noMAFs = quantity%template%noInstances
        end if

d449 1
a449 1
          dimensionFamilies = (/L2AUXDim_None, L2AUXDim_MIF, L2AUXDim_MAF/)
d452 1
a452 1
          dimensionFamilies = (/auxFamily, L2AUXDim_MIF, L2AUXDim_MAF/)
d473 2
a474 2
          dimensionFamilies = (/L2AUXDim_geodAngle, L2AUXDim_None, &
            & L2AUXDim_None/)
d477 2
a478 2
          dimensionFamilies = (/auxFamily, L2AUXDim_geodAngle, &
            & L2AUXDim_None/)
a483 1

d485 2
d490 1
a490 1
      do dimensionIndex = 1, newL2aux%noDimensionsUsed-1
d492 2
a493 3
        case ( L2AUXDim_None )
          newL2AUX%dimensions(dimensionIndex)%values = 1
        case ( L2AUXDim_Channel )
d497 1
a497 5
        case ( L2AUXDim_IntermediateFrequency )
          newL2AUX%dimensions(dimensionIndex)%values = quantity%template%frequencies
        case ( L2AUXDim_USBFrequency )
          newL2AUX%dimensions(dimensionIndex)%values = quantity%template%frequencies
        case ( L2AUXDim_LSBFrequency )
d499 1
a499 1
        case ( L2AUXDim_MIF )
d503 1
a503 3
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Obscure error with coordinates in l2aux data" )
a516 4
      ! Finally destroy the information in the interim, non database l2aux
!     call DestroyL2AUXContents ( newL2AUX )
      ! No! Don't do this! It deallocates all the pointers we just
      ! copied into the database!
d525 2
a526 6
      if ( useUnpackOutput ) then
        noMAFs = thisL2AUX%dimensions(thisL2AUX%noDimensionsUsed)%noValues+&
          & quantity%template%noInstances
      else
        noMAFs = quantity%template%mafCounter(quantity%template%noInstances)
      end if
a535 3
    ! We do this differently depending on whether we want packed or unpacked
    ! data.

d538 17
a554 13
    if ( .NOT. useUnpackOutput ) then
!     lastProfile = thisL2AUX%dimensions(thisL2AUX%noDimensionsUsed)%noValues
!     firstProfile = lastProfile-noOutputInstances+1
    end if

!    vectorQuantity = GetVectorQuantity ( vector, quantity%template%name, &
!      & quantityIsName=.TRUE. )

!    thisL2AUX%values = &
!      & vectorQuantity%values(useFirstInstance:useLastInstance,:,:)
    CALL unsqueeze(quantity%values(:, useFirstInstance:useLastInstance), &
    & thisL2AUX%values, IERR)

a558 59
  ! ---------------------------------------------------------------------------

!=============================== unsqueeze ==========================
SUBROUTINE unsqueeze(source, sink, IERR)
!=============================== unsqueeze ==========================
    ! takes a rank2 object source and returns a rank3 object sink
    ! source(1..n1*n2, 1..n3) -> sink(1..n1, 1..n2, 1..n3)
    ! unless it can't--then it returns iERR /= 0
    ! One reason it may fail: shape of sink too small
    !
    ! Assuming that shape(sink) = {n1, n2, n3}
    !     =>      shape(source) = {m1, m2}
    ! then we must further assume (else set IERR)
    ! m1 <= n1*n2
    ! m2 <= n3
    !
    ! (A future improvement might take as optional arguments
    !  integer arrays source_shape, sink_shape, 
    !  or else shape-params n1, n2, m1)
    !--------Argument--------!
    REAL(r8), DIMENSION(:,:), INTENT(IN)     :: source
    REAL(r8), DIMENSION(:,:,:), INTENT(OUT)  :: sink
    INTEGER, INTENT(OUT)                     :: IERR
 
    !----------Local vars----------!
    ! Error codes
    INTEGER               :: m1_is_zero = 1
    INTEGER               :: m2_is_zero = 2
    INTEGER               :: m1_too_big = 4
    INTEGER               :: m2_too_big = 5
    
    INTEGER, DIMENSION(4) :: source_shape
    INTEGER, DIMENSION(4) :: sink_shape
    INTEGER::i,icode,offset
    !----------Executable part----------!
    source_shape(1:2) = shape(source)
    sink_shape(1:3) = shape(sink)

    IF (source_shape(1) == 0) THEN
    	IERR = m1_is_zero
        RETURN
    ELSEIF (source_shape(2) == 0) THEN
    	IERR = m2_is_zero
        RETURN
    ELSEIF (sink_shape(1)*sink_shape(2) < source_shape(1)) THEN
    	IERR = m1_too_big
        RETURN
    ELSEIF (sink_shape(3) < source_shape(2)) THEN
    	IERR = m2_too_big
        RETURN
    ELSE
    	IERR = 0
    ENDIF

    sink = reshape(source, sink_shape(1:3))
    
END SUBROUTINE unsqueeze

!=============================================================================
a559 1
!=============================================================================
d563 3
@


2.15
log
@Removed a print statement
@
text
@d43 1
a43 1
       "$Id: Join.f90,v 2.14 2001/03/05 01:01:12 livesey Exp $"
a171 1
        call display_string(quantity%template%name)
d669 3
@


2.14
log
@Bug fix, now uses GetVectorQtyFromTemplateIndex
@
text
@d43 1
a43 1
       "$Id: Join.f90,v 2.13 2001/03/01 18:38:27 livesey Exp $"
a172 1
        print*,'Quantity dimensions:',quantity%template%noSurfs, quantity%template%noInstances
d670 3
@


2.13
log
@Fixed bug with verticalCoordinate==l_Zeta
@
text
@d32 2
a33 2
  use VectorsModule, only: GetVectorQuantity, ValidateVectorQuantity, Vector_T, &
    & VectorValue_T, DUMP
d43 1
a43 1
       "$Id: Join.f90,v 2.12 2001/02/27 17:38:21 livesey Exp $"
d162 2
a163 1
      quantity => vectors(vectorIndex)%quantities(quantityIndex)
d172 2
d671 3
@


2.12
log
@Tidied things up, removed unnecessary arguments
@
text
@d33 1
a33 1
    & VectorValue_T
d43 1
a43 1
       "$Id: Join.f90,v 2.11 2001/02/27 00:50:31 livesey Exp $"
d282 1
a282 1
      if ( quantity%template%verticalCoordinate == l_Pressure ) then
d668 3
@


2.11
log
@Added ability to Join verticalCoordinate=l_zeta quantities into l2gp entities.
@
text
@d32 2
a33 1
  use VectorsModule, only: GetVectorQuantity, Vector_T, VectorValue_T
d43 1
a43 1
       "$Id: Join.f90,v 2.10 2001/02/16 00:50:17 livesey Exp $"
d61 1
a61 2
  subroutine MLSL2Join ( root, vectors, l2gpDatabase, l2auxDatabase, &
    & qtyTemplates, chunks, chunkNo )
a67 2
    type (QuantityTemplate_T), dimension(:), target, intent(in) :: qtyTemplates
    type (MLSChunk_T), dimension(:), intent(in) :: chunks
d83 1
a83 1
    type (QuantityTemplate_T), pointer :: quantity
d162 1
a162 2
      quantity => qtyTemplates(quantityIndex)
!     quantity => vectors(vectorIndex)%template%quantities(quantityIndex)
d167 2
a168 9
      if ( .NOT. quantity%regular ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Irregular quantities cannot be output"// &
        & "they must be regularised first" )
 
      if ( quantity%coherent .AND. &
        &  quantity%stacked .AND. &
        & ( (quantity%verticalCoordinate == l_Pressure) &
        &  .OR. (quantity%verticalCoordinate == l_None) &
        &  .OR. (quantity%verticalCoordinate == l_Zeta) ) ) then
d171 1
a171 2
        call JoinL2GPQuantities ( key, name, vectors(vectorIndex), quantityIndex, &
          & l2gpDatabase, chunkNo )
d174 2
a175 2
        call JoinL2AUXQuantities ( key, name, vectors(vectorIndex), quantity, &
          & l2auxDatabase, chunkNo, unpackOutput=unpackOutput )
d225 1
a225 1
  subroutine JoinL2GPQuantities ( key, name, vector, quantityNo, l2gpDatabase, &
d231 4
a234 5
    type (Vector_T), intent(in) :: VECTOR
    integer, intent(in) :: QUANTITYNO ! Index into the vector
    type (L2GPData_T), dimension(:), pointer :: L2gpDatabase
    integer, intent(in) :: chunkNo
    integer, intent(in), optional :: firstInstance, lastInstance
a249 3
    type (QuantityTemplate_T), pointer :: quantity
    ! Executable code

a251 2
    quantity=>vector%quantities(quantityNo)%template

d265 1
a265 1
      useFirstInstance = quantity%noInstancesLowerOverlap+1
d271 2
a272 1
      useLastInstance = quantity%noInstances-quantity%noInstancesUpperOverlap
d282 2
a283 2
      if ( quantity%verticalCoordinate == l_Pressure ) then
        noSurfsInL2GP = quantity%noSurfs
d288 1
a288 1
      if ( quantity%frequencyCoordinate == l_None) then
d291 1
a291 1
         noFreqsInL2GP=quantity%noChans
d296 4
a299 4
      if ( quantity%verticalCoordinate == l_Pressure ) &
        & newL2GP%pressures = quantity%surfs(:,1)
      if ( quantity%verticalCoordinate == l_Zeta ) &
        & newL2GP%pressures = 10.0**(-quantity%surfs(:,1))
a308 4
      ! Finally destroy the interim, non databased l2gp quantity
!     call DestroyL2GPContents ( newL2GP )
      ! No! Don't do this! It deallocates all the pointers we just
      ! copied into the database!
a320 1
!    thisL2GP%name = name
d327 1
a327 1
      & quantity%geodLat(1,useFirstInstance:useLastInstance)
d329 1
a329 1
      & quantity%lon(1,useFirstInstance:useLastInstance)
d331 1
a331 1
      & quantity%solarTime(1,useFirstInstance:useLastInstance)
d333 1
a333 1
      & quantity%solarZenith(1,useFirstInstance:useLastInstance)
d335 1
a335 1
      & quantity%losAngle(1,useFirstInstance:useLastInstance)
d337 1
a337 1
      & quantity%phi(1,useFirstInstance:useLastInstance)
d339 1
a339 1
      & quantity%time(1,useFirstInstance:useLastInstance)
d349 1
a349 1
         RESHAPE(vector%quantities(quantityNo)%values(:,useFirstInstance:useLastInstance),&
d351 1
a351 1
    thisL2GP%l2gpPrecision(:,:,firstProfile:lastProfile) = 0.0
d367 1
a367 1
  subroutine JoinL2AUXQuantities ( key, name, vector, quantity, l2auxDatabase, &
d373 1
a373 2
    type (Vector_T), intent(in) :: vector
    type (QuantityTemplate_T), intent(in) :: quantity
a395 1
    type(VectorValue_T), pointer ::         vectorQuantity
a401 2
!   quantity => vector%template%quantities(quantityNo)

d416 1
a416 1
      useFirstInstance = quantity%noInstancesLowerOverlap+1
d422 2
a423 1
      useLastInstance = quantity%noInstances-quantity%noInstancesUpperOverlap
d438 1
a438 1
    if ( useUnpackOutput.AND.(.NOT.quantity%minorFrame) ) call MLSMessage ( &
d450 2
a451 2
      if ( (quantity%noChans/=1) .AND. &
        & (quantity%frequencyCoordinate == L_None) ) &
d455 1
a455 1
      select case (quantity%frequencyCoordinate)
d470 1
a470 1
      if ( quantity%minorFrame ) then
d475 1
a475 1
          noMAFs = quantity%mafIndex(quantity%noInstances)
d477 1
a477 1
          noMAFs = quantity%noInstances
d480 1
a480 1
        if ( quantity%frequencyCoordinate==L_None ) then
d482 1
a482 1
          dimensionSizes = (/1, quantity%noSurfs, noMAFs/)
d485 1
a485 1
          dimensionSizes = (/quantity%noChans, quantity%noSurfs, &
d499 1
a499 1
        if ( quantity%verticalCoordinate /= l_None ) &
d504 1
a504 1
        if ( quantity%frequencyCoordinate==L_None ) then
d507 1
a507 1
          dimensionSizes = (/quantity%noInstances, 1, 1/)
d511 1
a511 1
          dimensionSizes = (/quantity%noChans, quantity%noInstances, 1/)
d526 1
a526 1
          do channel = 1,quantity%noChans
d530 1
a530 1
          newL2AUX%dimensions(dimensionIndex)%values = quantity%frequencies
d532 1
a532 1
          newL2AUX%dimensions(dimensionIndex)%values = quantity%frequencies
d534 1
a534 1
          newL2AUX%dimensions(dimensionIndex)%values = quantity%frequencies
d536 1
a536 1
          do surf = 1, quantity%noSurfs
d569 1
a569 1
          & quantity%noInstances
d571 1
a571 1
        noMAFs = quantity%mafCounter(quantity%noInstances)
d592 1
a592 1
!    vectorQuantity = GetVectorQuantity ( vector, quantity%name, &
a594 2
    vectorQuantity = GetVectorQuantity ( vector, quantity%name)

d597 1
a597 1
    CALL unsqueeze(vectorQuantity%values(:, useFirstInstance:useLastInstance), &
d668 3
@


2.10
log
@Added error to avoid confusion with L2GP in ReadApriori section
@
text
@d12 1
a12 1
    & L_TRUE, S_L2AUX, S_L2GP, S_TIME
d42 1
a42 1
       "$Id: Join.f90,v 2.9 2001/02/09 19:30:16 vsnyder Exp $"
d177 2
a178 1
        &  .OR. (quantity%verticalCoordinate == l_None) ) ) then
d314 2
d694 3
@


2.9
log
@Move checking for required and duplicate fields to init_tables_module
@
text
@d10 3
a12 3
  use INIT_TABLES_MODULE, only: F_COMPAREOVERLAPS, F_OUTPUTOVERLAPS, F_SOURCE, &
    & F_UNPACKOUTPUT, FIELD_FIRST, FIELD_LAST, L_PRESSURE, L_NONE, L_TRUE, &
    & S_L2AUX, S_L2GP, S_TIME
d26 1
d42 1
a42 1
       "$Id: Join.f90,v 2.8 2001/02/09 18:01:46 livesey Exp $"
d49 1
d154 2
d210 1
a210 1
  subroutine ANNOUNCE_ERROR ( WHERE, CODE )
d213 1
d220 4
d691 3
@


2.8
log
@Various further updates, set default values for status and quality
@
text
@d41 1
a41 1
       "$Id: Join.f90,v 2.7 2001/02/09 00:38:22 livesey Exp $"
a45 2
  integer, parameter :: duplicateField = 1
  integer, parameter :: noSourceField = 2
d113 1
a113 1
      case( s_l2aux )
a141 2
        if ( got_field(field_index) ) &
          & call announce_error ( field, duplicateField )
a157 2
      if ( .not. got_field(f_source) ) &
        & call announce_error ( key, noSourceField )
a214 4
    case ( duplicateField )
      call output ( 'duplicate fields are not allowed.', advance='yes' )
    case ( noSourceField )
      call output ( 'A "source" field is required.', advance='yes' )
d682 3
@


2.7
log
@Various updates
@
text
@d41 1
a41 1
       "$Id: Join.f90,v 2.6 2001/01/03 18:15:13 pwagner Exp $"
d182 1
a182 1
        call JoinL2GPQuantities ( key, name, vectors(vectorIndex), quantity, &
d236 1
a236 1
  subroutine JoinL2GPQuantities ( key, name, vector, quantity, l2gpDatabase, &
d243 1
a243 1
    type (QuantityTemplate_T), intent(in) :: quantity
d261 2
d267 2
d367 6
a372 12
    do profNo = firstProfile, lastProfile
!     CALL GetVectorQuantity ( vector, values, quantityNo, &
!       & profNo-firstProfile+useFirstInstance, &
!       & firstIndexChannel=.TRUE. )
      thisL2GP%l2gpValue(:,:,profNo) = 0.0 
      thisL2GP%l2gpPrecision(:,:,profNo) = 0.0
! to avoid for 0.1 floating overflow in converting double precision to real

      thisL2GP%l2gpValue(:,:,profNo) = 0.0
!     call deallocate_test ( values, "values", ModuleName )
    end do
    thisL2GP%quality = 0.0
d692 3
@


2.6
log
@Changed types of t1, t2 to real
@
text
@d24 1
a24 2
  use QuantityTemplates, only: FG_InstrumentChannel, FG_IntermediateFrequency, &
    & FG_LSBFrequency, FG_None, FG_USBFrequency, QuantityTemplate_T
d32 2
d41 1
a41 1
       "$Id: Join.f90,v 2.5 2000/11/16 02:19:01 vsnyder Exp $"
a243 1
!   integer, intent(in) :: quantityNo
a254 1
!   type (QuantityTemplate_T), pointer :: quantity
d257 1
a257 1
    integer :: noSurfsInL2GP
a264 2
!   quantity => vector%template%quantities(quantityNo)

d300 5
a304 3
      !Reordered args in following routine
!      call SetupNewL2GPRecord ( noSurfsInL2GP, quantity%noChans, newL2GP )
      call SetupNewL2GPRecord ( newL2GP, quantity%noChans, noSurfsInL2GP )
d306 1
a354 25
    ! Convert the time to CCSDS format too.
    ! Nope, dropped the CCSDS format from our L2GP Data type
!    do profNo = firstProfile, lastProfile
!<<<<<<< Join.f90
!      status = PGS_TD_TAItoUTC ( &
!        & quantity%time(1,useFirstInstance+profNo-firstProfile), &
!        & thisL2GP%ccsdsTime(profNo) )
!      if ( status /= PGS_S_SUCCESS .and. status /= PGSTD_E_NO_LEAP_SECS ) &
!        & call MLSMessage ( MLSMSG_Error, ModuleName, &
!        & "Unable to convert time in l2gp to CCSDS format" )
!    end do

!=======
!      TAItime = quantity%time(1,useFirstInstance+profNo-firstProfile)
!
!      status = PGS_TD_TAItoUTC(TAItime, CCSDST)
!      if ( status /= PGS_S_SUCCESS ) then
!        if ( status /= PGSTD_E_NO_LEAP_SECS ) &
!          call MLSMessage ( MLSMSG_Error, ModuleName, &
!            & "Could not convert TAI time to UTC")  
!      end if  
!      thisL2GP%ccsdsTime(profNo) = CCSDST 
!
!    end do
!>>>>>>> 1.11
d475 1
a475 1
        & (quantity%frequencyCoordinate == FG_None) ) &
d480 1
a480 1
      case ( FG_InstrumentChannel )
d482 1
a482 1
      case ( FG_IntermediateFrequency )
d484 1
a484 1
      case ( FG_USBFrequency )
d486 1
a486 1
      case ( FG_LSBFrequency )
d488 1
a488 1
      case ( FG_None ) ! OK to do nothing
d504 1
a504 1
        if ( quantity%frequencyCoordinate==FG_None ) then
d528 1
a528 1
        if ( quantity%frequencyCoordinate==FG_None ) then
d694 3
@


2.5
log
@Implement timing.
@
text
@d40 1
a40 1
       "$Id: Join.f90,v 2.4 2000/11/13 23:02:21 pwagner Exp $"
d86 1
a86 1
    double precision :: T1, T2     ! for timing
d202 1
a202 1
      call output ( t2 - t1, advance = 'yes' )
d641 4
a644 2
    vectorQuantity = GetVectorQuantity ( vector, quantity%name, &
      & quantityIsName=.TRUE. )
d719 3
@


2.4
log
@Adapted for rank2 vectorsModule
@
text
@d12 1
a12 1
    & S_L2AUX, S_L2GP
d40 1
a40 1
       "$Id: Join.f90,v 2.3 2000/10/05 16:37:19 pwagner Exp $"
d86 2
d90 1
d116 7
d196 9
d717 3
@


2.3
log
@Now compiles with new L2GPData module
@
text
@d40 1
a40 1
       "$Id: Join.f90,v 2.2 2000/09/11 19:34:35 ahanzel Exp $"
d412 14
a425 11
    integer :: status, profNo
    integer :: useFirstInstance, useLastInstance, noOutputInstances
    type (L2AUXData_T) :: newL2AUX
    type (L2AUXData_T), pointer :: thisL2AUX
    logical :: l2auxDataIsNew, useUnpackOutput
    integer, dimension(3) :: dimensionFamilies, dimensionSizes
    integer :: auxFamily     ! Channel or Frequency
    integer :: dimensionIndex,channel,surf,prof, noMAFs,index, InstanceNo
    integer :: firstProfile,lastProfile
    real(r8), dimension(:,:), pointer :: values
    type(VectorValue_T), pointer :: vectorQuantity
d625 4
a628 2
    thisL2AUX%values = &
      & vectorQuantity%values(useFirstInstance:useLastInstance,:,:)
d636 56
d698 3
@


2.2
log
@Removed old log entries in file.
@
text
@d40 1
a40 1
       "$Id: Join.f90,v 2.1 2000/09/08 22:55:56 vsnyder Exp $"
d283 4
a286 1
      call SetupNewL2GPRecord ( noSurfsInL2GP, quantity%noChans, newL2GP )
d311 1
a311 1
      & thisL2GP%noInstances+noOutputInstances )
d315 4
a318 2
    thisL2GP%name = name
    lastProfile=thisL2GP%noInstances
d337 2
a338 1
    do profNo = firstProfile, lastProfile
d340 7
a346 7
      status = PGS_TD_TAItoUTC ( &
        & quantity%time(1,useFirstInstance+profNo-firstProfile), &
        & thisL2GP%ccsdsTime(profNo) )
      if ( status /= PGS_S_SUCCESS .and. status /= PGSTD_E_NO_LEAP_SECS ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Unable to convert time in l2gp to CCSDS format" )
    end do
d637 3
@


1.11
log
@added status check vs. PGSTD_E_NO_LEAP_SECS.
Zeroed out  thisL2GP%l2gpValue and
thisL2GP%l2gpPrecision, so that converting
them to single precision does not cause a
floating overflow (contents is garbage).
@
text
@a0 1

d5 1
a5 1
MODULE Join                     ! Join together chunk based data.
d8 30
a37 13
  USE MLSCommon
  USE MLSL2Common
  USE MLSMessageModule
  USE L2GPData
  USE L2AUXData
  USE VectorsModule
  USE QuantityTemplates
  USE SDPToolkit

  IMPLICIT NONE
  PUBLIC
  
  PRIVATE :: Id, ModuleName
d39 3
a41 3
  CHARACTER (LEN=256) :: Id = &
       "$Id: Join.f90,v 1.11 2000/06/29 23:51:16 lungu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: Join.f90,v $"
d44 46
d91 1
a91 1
  ! This module performs the 'join' task in the MLS level 2 software.
d93 1
a93 1
CONTAINS
d95 113
a207 1
  ! ---------------------------------------------------------------------------
d212 2
a213 2
  ! The firstSubVector and lastSubVector arguments give an optional range of
  ! the subvectors that we wish to store in the l2gp quantity.  Otherwise, it
d216 2
a217 2
  SUBROUTINE JoinL2GPQuantities(vector,quantityNo,l2gpDatabase,name,chunkNo,&
       & firstSubVector,lastSubVector)
d220 8
a227 6
    TYPE (Vector_T), INTENT(IN) :: vector
    INTEGER, INTENT(IN) :: quantityNo
    TYPE (L2GPData_T), DIMENSION(:), POINTER :: l2gpDatabase
    CHARACTER (LEN=*), INTENT(IN) :: name
    INTEGER, INTENT(IN) :: chunkNo
    INTEGER, INTENT(IN), OPTIONAL :: firstSubVector,lastSubVector
d233 10
a242 12
    INTEGER :: status,profNo,freqNo
    TYPE (L2GPData_T):: newL2GP
    TYPE (L2GPData_T), POINTER :: thisL2GP
    TYPE (QuantityTemplate_T), POINTER :: quantity
    INTEGER :: l2gpindex
    INTEGER :: firstProfile,lastProfile ! Profile range in the l2gp to output to
    INTEGER :: noSurfsInL2GP
    INTEGER :: useFirstSubVector,useLastSubVector,noOutputSubVectors
    LOGICAL :: l2gpDataIsNew
    double precision TAItime
    character(len=CCSDSlen) CCSDST
    REAL(r8), DIMENSION(:,:), POINTER :: values
d244 4
a247 1
    quantity=>vector%template%quantities(quantityNo)
d251 21
a271 22
    l2gpDataIsNew=(.NOT. ASSOCIATED(l2gpDatabase))
    IF (.NOT. l2gpDataIsNew) THEN
       l2gpindex=LinearSearchStringArray(l2gpDatabase%name,name)
       l2gpDataIsNew=(l2gpindex==0)
    END IF

    ! Work out what to do with the first and last subvector information

    IF (PRESENT(firstSubVector)) THEN
       useFirstSubVector=firstSubVector
    ELSE
!        useFirstSubVector=1
       useFirstSubVector=quantity%noSubVectorsLowerOverlap+1
    ENDIF

    IF (PRESENT(lastSubVector)) THEN
       useLastSubVector=lastSubVector
    ELSE
!       useLastSubVector=quantity%noSubVectors
 useLastSubVector=quantity%noSubVectors-quantity%noSubVectorsUpperOverlap
    ENDIF
    noOutputSubVectors=useLastSubVector-useFirstSubVector+1
d273 1
a273 1
    IF (noOutputSubVectors<1) RETURN
d275 2
a276 2
    IF (l2gpDataIsNew) THEN
       ! Now create an empty L2GP record with this dimension
d278 31
a308 31
       IF (quantity%verticalCoordinate == VC_Pressure) THEN
          noSurfsInL2GP=quantity%noSurfs
       ELSE
          noSurfsInL2GP=0
       ENDIF
       CALL SetupNeWL2GPRecord(noOutputSubVectors,noSurfsInL2GP,&
            & quantity%noChans,newL2GP)
       ! Setup the standard stuff, only pressure as it turns out.

       IF (quantity%verticalCoordinate==VC_Pressure) &
            & newL2GP%pressures=quantity%surfs(:,1)

       ! In later versions we'll need to think about frequency stuff (NJL)
       
       ! Add it to the database of l2gp quantities
       CALL AddL2GPToDatabase(l2gpDatabase,newL2GP)
       ! Setup the pointer and index to be used later
       l2gpindex=SIZE(l2gpDatabase)
       thisL2GP=>l2gpDatabase(l2gpindex)
       ThisL2GP%name = name
       ! Finally destroy the interim, non databased l2gp quantity
!       CALL DestroyL2GPContents(newL2GP)
    ELSE
       ! Setup the index and pointer
       l2gpindex=LinearSearchStringArray(l2gpDatabase%name,TRIM(name), &
            & caseInsensitive=.TRUE.)
       thisL2GP=>l2gpDatabase(l2gpindex)
       ! Expand this l2gp to take the new information
       CALL ExpandL2GPDataInPlace(thisL2GP,&
            & thisL2GP%noProfs+noOutputSubVectors)
    END IF
d312 4
a315 2
    lastProfile=thisL2GP%noProfs
    firstProfile=lastProfile-noOutputSubVectors+1
d317 14
a330 15
    thisL2GP%latitude(firstProfile:lastProfile)= &
         & quantity%geodLat(1,useFirstSubVector:useLastSubVector)

    thisL2GP%longitude(firstProfile:lastProfile)= &
         & quantity%lon(1,useFirstSubVector:useLastSubVector)
    thisL2GP%solarTime(firstProfile:lastProfile)= &
         & quantity%solarTime(1,useFirstSubVector:useLastSubVector)
    thisL2GP%solarZenith(firstProfile:lastProfile)= &
         & quantity%solarZenith(1,useFirstSubVector:useLastSubVector)
    thisL2GP%losAngle(firstProfile:lastProfile)= &
         & quantity%losAngle(1,useFirstSubVector:useLastSubVector)
    thisL2GP%geodAngle(firstProfile:lastProfile)= &
         & quantity%phi(1,useFirstSubVector:useLastSubVector)
    thisL2GP%time(firstProfile:lastProfile)= &
        & quantity%time(1,useFirstSubVector:useLastSubVector)
d332 23
a354 12
    DO profNo=firstProfile,lastProfile
       TAItime = quantity%time(1,useFirstSubVector+profNo-firstProfile)

       status = PGS_TD_TAItoUTC(TAItime, CCSDST)
       IF (status /= PGS_S_SUCCESS) THEN
       IF (status /= PGSTD_E_NO_LEAP_SECS ) &
          CALL MLSMessage (MLSMSG_Error, ModuleName, &
                         & "Could not convert TAI time to UTC")  
       END IF  
       thisL2GP%ccsdsTime(profNo) = CCSDST 

    END DO
a361 6
    DO profNo=firstProfile,lastProfile
!       CALL GetSubVectorAs2DArray(vector,values,quantityNo,&
!            &profNo-firstProfile+useFirstSubVector,&
!            &firstIndexChannel=.TRUE.)
       thisL2GP%l2gpValue(:,:,profNo)=0.0 
       thisL2GP%l2gpPrecision(:,:,profNo)=0.0
d363 6
a369 4
       thisL2GP%l2gpValue(:,:,profNo)=0.0
!       deallocate(values, stat=status)
!       IF (status/=PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error,ModuleName, &
!            & "Unable to dealocate values")
d371 3
a373 1
    END DO
d376 2
a377 1
  END SUBROUTINE JoinL2GPQuantities
d379 1
a379 1
  ! ---------------------------------------------------------------------------
d388 2
a389 2
  SUBROUTINE JoinL2AUXQuantities(vector,quantityNo,l2auxDatabase,name,chunkNo,&
       & firstSubVector,lastSubVector,unpackOutput)
d392 9
a400 7
    TYPE (Vector_T), INTENT(IN) :: vector
    INTEGER, INTENT(IN) :: quantityNo
    TYPE (L2AUXData_T), DIMENSION(:), POINTER :: l2auxDatabase
    CHARACTER (LEN=*), INTENT(IN) :: name
    INTEGER, INTENT(IN) :: chunkNo
    INTEGER, INTENT(IN), OPTIONAL :: firstSubVector,lastSubVector
    LOGICAL, INTENT(IN), OPTIONAL :: unpackOutput
d406 12
a417 13
    INTEGER :: status,profNo
    INTEGER :: useFirstSubVector,useLastSubVector,noOutputSubVectors
    TYPE (L2AUXData_T) :: newL2AUX
    TYPE (L2AUXData_T), POINTER :: thisL2AUX
    TYPE (QuantityTemplate_T), POINTER :: quantity
    LOGICAL :: l2auxDataIsNew, useUnpackOutput, found
    INTEGER, DIMENSION(3) :: dimensionFamilies, dimensionSizes
    INTEGER :: auxFamily     ! Channel or Frequency
    INTEGER :: dimensionIndex,channel,surf,prof, noMAFs,l2auxindex, subVectorNo
    INTEGER :: firstProfile,lastProfile
    REAL(r8), DIMENSION(:,:), POINTER :: values
    INTEGER :: l2auxDataSize
    
d419 4
a422 1
    quantity=>vector%template%quantities(quantityNo)
d427 7
a433 18
    l2auxDataIsNew=(.NOT. ASSOCIATED(l2auxDatabase))
    IF (.NOT. l2auxDataIsNew) THEN
       l2auxDataSize = size(l2auxDatabase)
       found =.false.
       l2auxindex = 1
       do while (.not. found .and. l2auxindex <= l2auxDataSize)
          if (Capitalize(TRIM(name)) == &
              Capitalize(TRIM(l2auxDatabase(l2auxindex)%name)))THEN
             found = .true.
          else
             l2auxindex = l2auxindex +1
          end if
       end do
!       l2auxindex=LinearSearchStringArray(l2auxDatabase%name,TRIM(name))
       
       l2auxDataIsNew=.not. found
    END IF
    ! Work out what to do with the first and last subvector information
d435 11
a445 13
    IF (PRESENT(firstSubVector)) THEN
       useFirstSubVector=firstSubVector
    ELSE
       useFirstSubVector=quantity%noSubVectorsLowerOverlap+1
    ENDIF

    IF (PRESENT(lastSubVector)) THEN
       useLastSubVector=lastSubVector
    ELSE
       useLastSubVector=quantity%noSubVectors-quantity%noSubVectorsUpperOverlap
    ENDIF

    noOutputSubVectors=useLastSubVector-useFirstSubVector+1
d447 1
d449 1
a449 1
    IF (noOutputSubVectors<1) RETURN
d453 9
a461 9
    IF (PRESENT(unpackOutput)) THEN
       useUnpackOutput=unpackOutput
    ELSE
       useUnpackOutput=.FALSE.
    END IF

    IF (useUnpackOutput.AND.(.NOT.quantity%minorFrame)) CALL MLSMessage(&
         & MLSMSG_Error,ModuleName,"Can only use the unpack output flag"//&
         & " for minor frame quantities")
d466 1
a466 1
    IF (l2auxDataIsNew) THEN
d468 2
a469 2
       ! If the quantity is a minor frame quantity, then we deal with it 
       ! as such.  Otherwise we output it as a geodAngle based quantity
d471 130
a600 131
       IF ( (quantity%noChans/=1).AND.&
            & (quantity%frequencyCoordinate==FG_None) ) &
            & CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & "Quantity has multiple channels but no frequency coordinate")

       IF (quantity%frequencyCoordinate/=FG_None) THEN
          SELECT CASE (quantity%frequencyCoordinate)
          CASE (FG_InstrumentChannel)
             auxFamily=L2AUXDim_Channel
          CASE (FG_IntermediateFrequency)
             auxFamily=L2AUXDim_IntermediateFrequency
          CASE (FG_USBFrequency)
             auxFamily=L2AUXDim_USBFrequency
          CASE (FG_LSBFrequency)
             auxFamily=L2AUXDim_LSBFrequency
          CASE DEFAULT
             CALL MLSMessage(MLSMSG_Error,ModuleName,&
                  & "Unrecognised frequency coordinate")
          END SELECT
       ENDIF
       IF (quantity%minorFrame) THEN
          ! For minor frame quantities, the dimensions are:
          ! ([frequency or channel],MIF,MAF)
          !
          IF (useUnpackOutput) THEN
             noMAFs=quantity%mafIndex(quantity%noSubVectors)
          ELSE
!              noMAFs = noOutputSubVectors
             noMAFs=quantity%noSubVectors
          END IF
          IF (quantity%frequencyCoordinate==FG_None) THEN
             dimensionFamilies=(/L2AUXDim_MIF,L2AUXDim_MAF,L2AUXDim_None/)
             dimensionSizes=(/quantity%noSurfs,noMAFs,1/)
          ELSE
             dimensionFamilies=(/auxFamily,L2AUXDim_MIF,L2AUXDim_MAF/)
             dimensionSizes=(/quantity%noChans,quantity%noSurfs,&
                  & noMAFs/)
          END IF
       ELSE
          ! Not a minor frame quantity, for non minor frame l2aux quantities
          ! our ability to output them will probably increase, but at the
          ! moment, I can't really forsee what form they may take.

          ! For the moment (ie. v0.1) I'm going to be restrictive and only
          ! allow quantities with no vertical coordinate.  This may and
          ! probably will change in later versions, leading to more L2AUXDim
          ! paramters etc., to copy those from VC_....

          IF (quantity%verticalCoordinate/=VC_None) &
               & CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & "Cannot currently output L2AUX quantities with obscure "//&
               & "vertical coordinates, sorry!")

          IF (quantity%frequencyCoordinate==FG_None) THEN
             dimensionFamilies=(/L2AUXDim_geodAngle,L2AUXDim_None, &
                  & L2AUXDim_None/)
             dimensionSizes=(/quantity%noSubVectors,1,1/)
          ELSE
             dimensionFamilies=(/auxFamily,L2AUXDim_geodAngle,&
                  & L2AUXDim_None/)
             dimensionSizes=(/quantity%noChans,quantity%noSubVectors,1/)
          END IF
       END IF
       ! Now we setup the new quantity
       newL2AUX%name = name       
       CALL SetupNewL2AUXRecord(dimensionFamilies,dimensionSizes,newL2AUX)
       ! Setup the standard `vertical' and `channel' dimensions


       DO dimensionIndex=1,newL2aux%noDimensionsUsed-1
          SELECT CASE (dimensionFamilies(dimensionIndex))
          CASE (L2AUXDim_Channel)
             DO channel=1,quantity%noChans
                newL2AUX%dimensions(dimensionIndex)%values(channel)=channel
             END DO
          CASE (L2AUXDim_IntermediateFrequency)
             newL2AUX%dimensions(dimensionIndex)%values=quantity%frequencies
          CASE (L2AUXDim_USBFrequency)
             newL2AUX%dimensions(dimensionIndex)%values=quantity%frequencies
          CASE (L2AUXDim_LSBFrequency)
             newL2AUX%dimensions(dimensionIndex)%values=quantity%frequencies
          CASE (L2AUXDim_MIF)
             DO surf=1,quantity%noSurfs
                newL2AUX%dimensions(dimensionIndex)%values(surf)=surf
             END DO
          CASE DEFAULT
             CALL MLSMessage(MLSMSG_Error,ModuleName, &
                  & "Obscure error with coordinates in l2aux data")
          END SELECT
          ! The error message here is rather vaugue.  The issue is that
          ! both MAF and geodAngle should only occur for the `last' dimenison
          ! which our loop is explicity avoiding.
       END DO ! The `last' dimension is dealt with later on.
       ! Add this l2aux to the database
       CALL AddL2AUXToDatabase(l2auxDatabase,newL2AUX)

       ! Setup the pointer and the index to be used later
       l2auxindex=SIZE(l2AUXDatabase)
       thisL2AUX=>l2auxDatabase(l2auxindex)
       ! Finally destroy the information in the interim, non database l2aux
!       CALL DestroyL2AUXContents(newL2AUX)
    ELSE
       ! Setup the index and pointer
       l2auxDataSize = size(l2auxDatabase)
       found =.false.
       l2auxindex = 1
       do while (.not. found .and. l2auxindex <= l2auxDataSize)
          if (Capitalize(TRIM(name)) == &
              Capitalize(TRIM(l2auxDatabase(l2auxindex)%name)))THEN
             found = .true.
          else
             l2auxindex = l2auxindex +1
          end if
       end do
       if (.not. found) l2auxindex = 0
!       l2auxindex=LinearSearchStringArray(l2auxDatabase%name,TRIM(name), &
!            & caseInsensitive=.TRUE.)
       thisL2AUX=>l2auxDatabase(l2auxindex)

       ! Expand this l2aux along the `last' dimension to take up the new
       ! information.

       IF (useUnpackOutput) THEN
          noMAFs=thisL2AUX%dimensions(thisL2AUX%noDimensionsUsed)%noValues+&
            & noOutputSubVectors
       ELSE
          noMAFs=quantity%mafCounter(quantity%noSubVectors)
          
       END IF
       CALL ExpandL2AUXDataInPlace(thisL2AUX,noMAFs)
    END IF
d606 1
a606 27
    IF (.NOT. useUnpackOutput) THEN
       lastProfile=thisL2AUX%dimensions(thisL2AUX%noDimensionsUsed)%noValues
       firstProfile=lastProfile-noOutputSubVectors+1
    END IF
    DO subVectorNo=useFirstSubVector,useLastSubVector
       ! Get the relevant subvector from the quantity

!       CALL GetSubVectorAs2DArray(vector,values,quantityNo,subVectorNo,&
!            & firstIndexChannel=.TRUE.)

       ! Work out where this will be placed in the output l2aux quantity.

       IF (useUnpackOutput) THEN
          profNo=quantity%mafIndex(subVectorNo)
       ELSE
          profNo=firstProfile+subVectorNo-useFirstSubVector
       ENDIF
       ! Now place this in the l2aux data and the correspondign dimensions.
!       thisL2AUX%values(profno,:,:)=values
!       deallocate(values, stat=status)
       
!       IF (status/=PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error,ModuleName, &
!            & "Unable to deallocate l2aux values")

       thisL2AUX%dimensions(thisL2AUX%noDimensionsUsed)%values(profNo)=&
            & quantity%mafCounter(subVectorNo)
    END DO
d608 4
a611 1
  END SUBROUTINE JoinL2AUXQuantities
d613 2
a614 1
  ! ---------------------------------------------------------------------------
d616 2
a617 4
  ! This is the main routine for join.  Most of the time it is fairly simple.
  ! However, for the first time round a little more has to be done as the
  ! routine has to create the l2gp and l2aux structures with the correct size
  ! in order to be able to store all the chunks.
d619 1
a619 1
  SUBROUTINE MLSL2Join(mlscf,vectors,l2gpDatabase,l2auxDatabase,chunks,chunkNo)
d621 1
a621 7
    ! Dummy arguments
    TYPE (MLSCF_T), INTENT(IN) :: mlscf
    TYPE (Vector_T), DIMENSION(:), INTENT(IN) :: vectors
    TYPE (L2GPData_T), DIMENSION(:), POINTER :: l2gpDatabase
    TYPE (L2AUXData_T), DIMENSION(:), POINTER :: l2auxDatabase
    TYPE (MLSChunk_T), DIMENSION(:), INTENT(IN) :: chunks
    INTEGER, INTENT(IN) :: chunkNo
d623 1
a623 84
    ! Local parameters

    ! Local variables
    TYPE (MLSCFSection_T) :: mlscfSection
    INTEGER :: mlscfLine,mlscfCellIndex
    CHARACTER (LEN=NameLen) :: name
    CHARACTER (LEN=NameLen) :: source
    CHARACTER (LEN=NameLen) :: vectorName,quantityName
    INTEGER :: vectorIndex, quantityIndex
    TYPE (QuantityTemplate_T), POINTER :: quantity
    LOGICAL :: compareOverlaps, outputOverlaps, unpackOutput
    TYPE (MLSCFCell_T) :: cell

    ! Executable code

    mlscfSection=GetMLSCFSection(mlscf,"Join")

    ! We simply loop over the lines in the mlscf

    DO mlscfLine=1,mlscfSection%noSectionEntries
       ! Each line represents a different join operation, clear various
       ! flags etc.

       source=""
!       name=mlscfSection%entries(mlscfLine)%mlscfEntryName
       compareOverlaps=.FALSE.
       outputOverlaps=.FALSE.
       unpackOutput=.FALSE.

       ! Loop over the segments of the mlscf line

       DO mlscfCellIndex=1,mlscfSection%entries(mlscfLine)%mlscfEntryNoKeys
          cell=mlscfSection%entries(mlscfLine)%cells(mlscfCellIndex)
          SELECT CASE(TRIM(cell%keyword))
          CASE ("SOURCE")
             source=cell%charValue
          CASE ("NAME")
              name=cell%charValue
          CASE ("COMPAREOVERLAPS")
             compareOverlaps=(cell%intValue==1)
          CASE ("OUTPUTOVERLAPS")
             outputOverlaps=(cell%intValue==1)
          CASE ("UNPACKOUTPUT")
             unpackOutput=(cell%intValue==1)
          CASE DEFAULT
             CALL MLSMessage(MLSMSG_Error,ModuleName, &
                  & "Unrecognised join instruction: "//cell%keyword)
          END SELECT
       END DO

       ! Now we've worked out what we've been asked, work out what to do
       ! First, we identify the source

       CALL SplitWords(source,vectorName,quantityName,delimiter=".")
       vectorIndex=LinearSearchStringArray(vectors%name,vectorName)
       IF (vectorIndex==0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & "No such vector defined: "//vectorName)
       quantityIndex=LinearSearchStringArray(vectors(vectorIndex)% &
            & template%quantities%name,quantityName)
       IF (quantityIndex==0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            & "No such quantity in this vector: "//source)
       quantity=>vectors(vectorIndex)%template%quantities(quantityIndex)
       ! Now, depending on the properties of the source we deal with the
       ! vector quantity approrpriately.

       IF (.NOT. quantity%regular) CALL MLSMessage(MLSMSG_Error,&
            & ModuleName,"Irregular quantities cannot be output"//&
            & "they must be regularised first")
       
       IF (quantity%coherent .AND. &
            & quantity%stacked .AND. &
            & ( (quantity%verticalCoordinate==VC_Pressure) &
            &  .OR. (quantity%verticalCoordinate==VC_None) )) THEN
          ! Coherent, stacked, regular quantities on pressure surfaces, or
          ! with no vertical coordinate system go in l2gp files.
          CALL JoinL2GPQuantities(vectors(vectorIndex),quantityIndex,&
               & l2gpDatabase,name,chunkNo)
       ELSE
          ! All others go in l2aux files.
          CALL JoinL2AUXQuantities(vectors(vectorIndex),quantityIndex,&
               & l2auxDatabase,name,chunkNo,unpackOutput=unpackOutput)
       ENDIF
    END DO
  END SUBROUTINE MLSL2Join
d626 1
a626 1
END MODULE Join
d631 2
a632 6
! Revision 1.11  2000/06/29 23:51:16  lungu
! added status check vs. PGSTD_E_NO_LEAP_SECS.
! Zeroed out  thisL2GP%l2gpValue and
! thisL2GP%l2gpPrecision, so that converting
! them to single precision does not cause a
! floating overflow (contents is garbage).
d634 2
a635 3
! thisL2GP%l2gpPrecision, so that converting
! them to single precision does not cause a
! floating overflow (contents is garbage).
d640 1
a640 35
! Revision 1.10  2000/06/19 22:17:19  lungu
! Stored name in Thisl2gp%name, Thisl2aux%name.
! Replaced LinearSearchStringArray with explicit search (doesn't work on IRIX64).
! Fixed noOutputSubVectors.
!
! Revision 1.9  2000/01/21 06:37:14  livesey
! A couple of typos
!
! Revision 1.8  2000/01/20 23:10:49  livesey
! Finally finished the l2aux quantity join, and have something that compiles.
!
! Revision 1.7  2000/01/20 01:24:39  livesey
! None finished version transfered home.  Just the last touches to do to
! JoinL2AUXQuantities, and a possible tidy up of MLSL2Join
!
! Revision 1.6  2000/01/18 00:08:42  livesey
! Nonworking version transfered home.
!
! Revision 1.5  2000/01/12 20:34:12  livesey
! Make sure that quantities with VC_None (which implies, coherent, stacked and
! regular) get placed in L2GP data.
!
! Revision 1.4  2000/01/12 20:28:37  livesey
! Modified to deal with l2gp's with no vertical coordinate.
!
! Revision 1.3  2000/01/11 23:40:08  livesey
! This version compiles and links for the first time!
!
! Revision 1.2  2000/01/07 23:53:34  livesey
! Nearly integrated, just a few tweaks.
!
! Revision 1.1  1999/12/21 00:32:52  livesey
! First version, not ready yet.
!
!
@


