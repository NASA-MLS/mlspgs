head	2.160;
access;
symbols
	v5-02-NRT-19:2.160
	v6-00:2.159
	v5-02-NRT-18:2.159
	v5-02:2.154
	v5-01-NRT-17:2.159
	v5-01-NRT-16:2.159
	v5-01-NRT-15:2.156
	v5-01-NRT-14:2.156
	neuralnetworks-1-0:2.156.0.4
	cfm-single-freq-0-1:2.156.0.2
	v5-01:2.154
	v5-00:2.154
	v4-23-TA133:2.153.0.2
	mus-emls-1-70:2.151.0.2
	rel-1-0-englocks-work:2.149.0.2
	VUMLS1-00:2.146
	VPL1-00:2.138
	V4-22-NRT-08:2.130
	VAM1-00:2.126
	V4-21:2.120.0.2
	V4-13:2.118
	V4-12:2.114
	V4-11:2.114
	V4-10:2.114
	V3-43:2.96
	M4-00:2.101
	V3-41:2.96
	V3-40-PlusGM57:2.96.0.2
	V2-24-NRT-04:2.92
	V3-33:2.97
	V2-24:2.92
	V3-31:2.97
	V3-30-NRT-05:2.97
	cfm-01-00:2.97
	V3-30:2.96
	V3-20:2.96
	V3-10:2.96
	V2-23-NRT-02:2.92
	V2-23:2.92
	V2-22-NRT-01:2.92
	V2-22:2.92
	V2-21:2.90
	V2-20:2.90
	V2-11:2.90
	V2-10:2.90
	V2-00:2.88
	V1-51:2.67
	V1-50:2.67
	V1-45:2.66
	V1-44:2.65
	V1-43:2.60
	V1-32:2.57
	V1-31:2.57
	V1-30:2.57
	V1-13:2.48
	V1-12:2.48
	V1-11:2.48
	V1-10:2.46
	merged-HEAD:2.46.2.1
	newfwm-feb03:2.46.0.2
	V1-04:2.22
	V1-03:2.22
	V1-02:2.22
	JointForwardModel:2.28.0.2
	V1-00:2.22
	newfwm-sep01:2.19.0.2
	V0-7:2.19
	V0-5-Level2:2.14
	V0-5-SIPS:2.8;
locks; strict;
comment	@# @;


2.160
date	2024.08.08.20.39.50;	author pwagner;	state Exp;
branches;
next	2.159;

2.159
date	2022.04.13.21.31.28;	author pwagner;	state Exp;
branches;
next	2.158;

2.158
date	2021.11.18.18.11.28;	author pwagner;	state Exp;
branches;
next	2.157;

2.157
date	2021.11.03.23.47.58;	author pwagner;	state Exp;
branches;
next	2.156;

2.156
date	2019.11.22.00.38.43;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2019.11.14.22.28.32;	author pwagner;	state Exp;
branches;
next	2.154;

2.154
date	2019.07.09.22.26.19;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2018.08.06.20.24.15;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2018.08.03.23.45.43;	author vsnyder;	state Exp;
branches;
next	2.151;

2.151
date	2018.04.19.00.49.06;	author vsnyder;	state Exp;
branches;
next	2.150;

2.150
date	2018.04.16.22.20.21;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2018.03.02.00.58.17;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2018.02.23.22.20.51;	author mmadatya;	state Exp;
branches;
next	2.147;

2.147
date	2018.01.03.01.17.56;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2016.11.04.19.36.24;	author pwagner;	state Exp;
branches;
next	2.145;

2.145
date	2016.10.19.00.31.18;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2016.10.14.00.04.28;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2016.10.01.01.53.28;	author vsnyder;	state Exp;
branches;
next	2.142;

2.142
date	2016.10.01.01.37.36;	author vsnyder;	state Exp;
branches;
next	2.141;

2.141
date	2016.09.14.20.11.42;	author vsnyder;	state Exp;
branches;
next	2.140;

2.140
date	2016.09.03.00.06.01;	author vsnyder;	state Exp;
branches;
next	2.139;

2.139
date	2016.09.02.00.48.08;	author vsnyder;	state Exp;
branches;
next	2.138;

2.138
date	2016.08.23.00.43.34;	author vsnyder;	state Exp;
branches;
next	2.137;

2.137
date	2016.08.17.00.47.52;	author vsnyder;	state Exp;
branches;
next	2.136;

2.136
date	2016.08.09.21.12.50;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2016.07.28.02.02.26;	author vsnyder;	state Exp;
branches;
next	2.134;

2.134
date	2016.07.28.01.45.07;	author vsnyder;	state Exp;
branches;
next	2.133;

2.133
date	2016.07.27.23.02.20;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2016.07.22.20.04.46;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2016.07.21.20.55.09;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2016.05.18.01.37.30;	author vsnyder;	state Exp;
branches;
next	2.129;

2.129
date	2016.02.26.02.07.18;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2016.02.12.20.10.53;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2015.10.14.23.23.01;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2015.07.14.23.34.22;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2015.06.19.21.12.44;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2015.06.03.23.10.51;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2015.05.05.16.45.13;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2015.04.29.01.16.34;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2015.03.28.02.45.56;	author vsnyder;	state Exp;
branches;
next	2.120;

2.120
date	2015.03.10.23.40.18;	author pwagner;	state Exp;
branches
	2.120.2.1;
next	2.119;

2.119
date	2015.03.10.00.20.53;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2014.09.05.01.02.36;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2014.09.05.00.49.06;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2014.08.06.23.30.29;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2014.08.01.01.45.52;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2014.04.24.23.56.43;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2014.03.18.17.15.09;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2014.03.01.03.10.56;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2013.10.01.22.17.51;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2013.08.30.02.45.41;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2013.08.21.00.25.04;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2013.08.17.00.20.25;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2013.08.13.01.27.42;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2013.08.13.00.58.54;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2013.06.12.02.37.14;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2012.04.25.20.32.24;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2012.04.20.01.09.22;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2011.06.29.21.54.26;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2011.03.10.21.39.11;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2010.03.23.23.26.03;	author honghanh;	state Exp;
branches;
next	2.96;

2.96
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2009.06.16.17.42.16;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2009.05.13.20.41.55;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2008.12.02.23.29.41;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2007.10.02.22.40.51;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2007.06.21.00.54.07;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2006.07.12.20.42.30;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2006.06.29.21.56.25;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2006.05.31.17.48.49;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2006.04.19.20.48.13;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2006.04.11.23.33.51;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2006.03.07.23.23.28;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2006.02.21.19.11.30;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2006.02.07.00.56.26;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2006.01.10.23.52.11;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2005.12.16.00.07.12;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2005.12.14.01.55.33;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2005.12.14.01.43.33;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2005.12.13.22.15.30;	author livesey;	state Exp;
branches;
next	2.77;

2.77
date	2005.12.13.21.26.02;	author livesey;	state Exp;
branches;
next	2.76;

2.76
date	2005.11.15.00.20.18;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2005.11.04.18.52.36;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2005.10.22.00.49.26;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2005.10.19.00.06.09;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2005.09.21.23.19.47;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2005.09.14.00.12.33;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2005.08.31.19.41.16;	author livesey;	state Exp;
branches;
next	2.69;

2.69
date	2005.06.22.18.57.01;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2005.05.31.17.51.17;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2004.12.27.23.05.47;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2004.08.20.17.58.42;	author livesey;	state Exp;
branches;
next	2.65;

2.65
date	2004.08.16.17.10.26;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2004.08.05.20.04.48;	author livesey;	state Exp;
branches;
next	2.63;

2.63
date	2004.07.30.00.16.36;	author livesey;	state Exp;
branches;
next	2.62;

2.62
date	2004.06.14.20.00.36;	author livesey;	state Exp;
branches;
next	2.61;

2.61
date	2004.05.19.19.16.10;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2004.03.24.17.55.19;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2004.03.24.01.30.16;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2004.03.24.01.03.23;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2003.08.28.23.52.36;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2003.08.11.20.55.20;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2003.08.11.18.08.27;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2003.06.25.22.27.02;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2003.06.25.22.05.31;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2003.06.24.23.30.30;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2003.06.20.19.37.06;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2003.05.11.01.43.17;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2003.05.05.23.00.34;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2003.03.07.00.41.24;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2003.02.13.19.05.39;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2003.02.07.00.41.32;	author livesey;	state Exp;
branches
	2.46.2.1;
next	2.45;

2.45
date	2003.02.06.23.30.50;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2003.01.06.20.13.46;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2002.12.11.22.17.05;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2002.12.06.01.07.54;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2002.12.05.02.21.08;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2002.11.22.12.20.42;	author mjf;	state Exp;
branches;
next	2.39;

2.39
date	2002.11.13.01.07.04;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2002.10.08.17.36.20;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2002.09.11.17.40.38;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2002.08.09.16.56.37;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2002.08.04.16.03.33;	author mjf;	state Exp;
branches;
next	2.34;

2.34
date	2002.08.01.17.19.56;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2002.07.17.06.02.50;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2002.07.01.23.57.06;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2002.07.01.23.42.42;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2002.06.29.06.11.36;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2002.06.29.05.55.19;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2002.06.18.22.41.26;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2002.05.24.20.56.53;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2002.05.24.16.47.39;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2002.05.06.22.31.28;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2002.05.06.21.59.28;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2002.05.06.21.37.40;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.12.16.00.58.24;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.12.14.01.43.02;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.12.10.20.21.36;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.07.09.20.15.07;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.07.06.21.33.23;	author dwu;	state Exp;
branches;
next	2.17;

2.17
date	2001.07.06.18.48.16;	author dwu;	state Exp;
branches;
next	2.16;

2.16
date	2001.05.30.23.53.15;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.05.12.00.17.24;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.05.03.20.32.19;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.04.24.22.21.05;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.04.23.23.25.26;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.21.01.24.55;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.20.23.11.48;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.02.01.27.06;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.02.22.23.44.29;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.02.22.23.43.26;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.02.21.01.09.24;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.09.19.30.16;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.09.00.38.22;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.08.01.50.11;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.12.04.23.34.38;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.11.19.18.01;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.07.17.36.29;	author vsnyder;	state Exp;
branches;
next	;

2.120.2.1
date	2015.04.14.22.37.33;	author pwagner;	state Exp;
branches;
next	;

2.46.2.1
date	2003.02.13.20.36.06;	author livesey;	state Exp;
branches;
next	2.46.2.2;

2.46.2.2
date	2003.03.06.19.26.17;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.160
log
@Require elevated verbosity to warn of print values when reading from l1boa
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module HGrid                    ! Horizontal grid information
!=============================================================================

  use HGridsDatabase, only: HGrid_T, HGridGeolocations, &
    & L1BGeolocation, L1BSubsample
  use MLSCommon, only: MLSFile_T, NameLen, TAI93_Range_T
  use MLSFiles, only: HDFVersion_5, GetMLSFileByType
  use MLSFinds, only: FindAll
  use MLSKinds, only: Rk => R8, R8
  use MLSSignals_M, only: GetModuleName
  
  implicit none
  private
  public :: CreateHGridfromMLSCFInfo, ComputeNextChunksHGridOffsets, &
   & ComputeAllHGridOffsets, DealWithObstructions, DestroyHGridGeoLocations

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: HGrid.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! -----     Private declarations     ---------------------------------

  logical, save, private :: computingOffsets = .false.
  integer, private       :: error                     

  interface PlaceArray
    module procedure PlaceArray_r4
    module procedure PlaceArray_r8
  end interface

  real :: T0, T1, T2               ! For timing

! Error codes for "announce_error"
  integer, private, parameter :: BadTime = 1
  integer, private, parameter :: NoFraction = BadTime + 1
  integer, private, parameter :: NoHeight = NoFraction + 1
  integer, private, parameter :: NoL1Bfiles = NoHeight + 1
  integer, private, parameter :: NoMIF = NoL1Bfiles + 1
  integer, private, parameter :: NoModule = NoMIF + 1
  integer, private, parameter :: NoPolygon = NoModule + 1
  integer, private, parameter :: NoSpacingOrigin = NoPolygon + 1


contains ! =====     Public Procedures     =============================

  ! -----------------------------------  CreateHGridFromMLSCFInfo  -----
  type(hGrid_T) function CreateHGridFromMLSCFInfo &
    & ( name, root, filedatabase, l2gpDatabase, &
    & processingRange, chunk, onlyComputingOffsets, check ) result ( hGrid )

    use Allocate_Deallocate, only: Deallocate_Test
    use Chunks_M, only: MLSChunk_T
    use Constants, only: Ln2
    use Dates_Module, only: Tai93s2hid
    use Expr_M, only: Expr
    use HGridsDatabase, only: HGrid_T, CreateEmptyHGrid, NullifyHGrid
    use HighOutput, only: BeVerbose, LetsDebug, OutputNamedValue
    use Init_Tables_Module, only: F_Coordinate, F_Date, &
      & F_Extendible, F_Forbidoverspill, F_Fraction, F_Geodangle, F_Geodlat, &
      & F_Height, F_Inclination, F_Insetoverlaps, F_Interpolationfactor, &
      & F_Lon, F_Losangle, F_Maxloweroverlap, F_Maxupperoverlap, F_Mif, &
      & F_Module, F_Origin, F_QTMlevel, &
      & F_Single, F_Solartime, F_Solarzenith, F_Sourcel2GP, F_Spacing, &
      & F_Time, F_Type, &
      & Field_First, Field_Last, &
      & L_Explicit, L_Fixed, L_Fractional, L_Height, &
      & L_L2gp, L_QTM, L_Regular
    use Intrinsic, only: PHYQ_Angle, PHYQ_Dimensionless, PHYQ_Length
    use L1BData, only: CheckForCorruptFileDatabase
    use L2GPData, only: L2GPData_T
    use MLSHDF5, only: IsHDF5DSInFile
    use MLSL2options, only: Need_L1BFiles
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSNumerics, only: Hunt
    use MLSStringLists, only: SwitchDetail
    use MoreMessage, only: MLSMessage
    use MoreTree, only: Get_Boolean
    use Output_M, only: Output
    use Polygon_M, only: Polygon_Inside, Polygon_Vertices
    use QTM_M, only: QTM_Depth ! Maximum Depth That Will Fit In One Integer
    ! use String_Table, only: Get_String
    use Time_M, only: SayTime, Time_Now
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decoration, NSons, Sub_Rosa, Subtree, Where

  ! This routine creates an hGrid based on the user requests.

    ! Dummy arguments
    integer, intent(in) :: NAME               ! String index of name
    integer, intent(in) :: ROOT               ! Root of hGrid subtree
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (L2GPData_T), pointer, dimension(:) :: L2GPDATABASE
    type (TAI93_Range_T), intent(in) :: PROCESSINGRANGE
    ! logical, intent(in), optional :: SUPPRESSGEOMETRYDUMP
    logical, intent(in), optional :: onlyComputingOffsets
    logical, intent(in), optional :: check
    type (MLSChunk_T), intent(in) :: CHUNK ! The chunk

    ! Local variables
    integer :: DATE                     ! Tree node
    integer :: EXPR_UNITS(2)            ! Output from Expr subroutine
    double precision :: EXPR_VALUE(2)   ! Output from Expr subroutine
    real(rk) :: fraction, height
    integer :: hGridType
    real(rk) :: interpolationFactor
    integer :: instrumentModule
    type (L2GPData_T), pointer :: L2GP  ! The l2gp to use 
    integer :: Me = -1                  ! String index for trace
    real(rk) :: spacing, origin

    integer :: keyNo                    ! Entry in the mlscf line
    integer :: fieldValue               ! Node in the tree

    real(rk) :: MINTIME, MAXTIME        ! Span for a chunk
    logical :: MYSUPPRESSGEOMETRYDUMP
    integer, dimension(2) :: PROFRANGE  ! Profile range
    integer :: A,B                      ! Elements of profile range
    logical :: DeeBug
    logical :: EXTENDIBLE               ! If set don't lose profiles between chunks
    integer :: FIELD                    ! Subtree index of "field" node
    integer :: FIELD_INDEX              ! F_..., see Init_Tables_Module
    double precision, dimension(:), pointer :: FullArray
    integer :: GEODANGLENODE            ! Tree node
    integer :: GEODLATNODE            ! Tree node
    logical :: GOT_FIELD(field_first:field_last)
    real(rk) :: Incline                 ! Orbit inclination, degrees
    logical :: INSETOVERLAPS            ! Flag
    integer :: LONNODE                  ! Tree node
    integer :: LOSANGLENODE             ! Tree node
    integer :: MAXLOWEROVERLAP          ! For some hGrids
    integer :: MAXUPPEROVERLAP          ! For some hGrids
    integer :: MIF                      ! For fixed hGrids
    logical :: myCheck
    integer :: NOMAFS                   ! Number of MAFs of L1B data read
    integer :: QTM_Level                ! From QTMLevel field
    logical :: SINGLE                   ! Just one profile please
    integer :: SON                      ! Son of Root
    integer :: SOLARTIMENODE            ! Tree node
    integer :: SOLARZENITHNODE          ! Tree node
    double precision, dimension(:), pointer :: TAI
    integer :: TIMENODE                 ! Tree node
    logical :: verbose

    character (len=NameLen) :: InstrumentModuleName

    type (MLSFile_T), pointer             :: L1BFile

    ! Executable code
    call trace_begin ( me, "CreateHGridFromMLSCFInfo", root, &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

    nullify ( fullArray, TAI )

    deebug = LetsDebug ( 'hgrid', 2 )
    verbose = beVerbose ( 'hgrid', 1 )
    computingOffsets       = .false.               
    mySuppressGeometryDump = .false.               
    if ( present ( onlyComputingOffsets ) ) then   
      mySuppressGeometryDump = onlyComputingOffsets
      computingOffsets       = onlyComputingOffsets
    endif
    if ( verbose ) then
      call time_now ( t1 )
    endif
    myCheck = .false.
    if ( present(check) ) myCheck = check

    L1BFile => GetMLSFileByType( filedatabase, content='l1boa' )
    if ( .not. associated(L1BFile) .and. NEED_L1BFILES ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName // '/' &
      & // 'CreateHGridFromMLSCFInfo', &
      & "Didn't I warn you about not having an L1BOA file?" )

    call nullifyHGrid ( hgrid ) ! for Sun's rubbish compiler
    if ( mycheck ) then
      call outputNamedValue( 'Before creating HGrid', chunk%chunkNumber )
      call CheckForCorruptFileDatabase( filedatabase )
    endif
    
    hGrid%name = name

    date = 0
    extendible = .false.
    geodAngleNode = 0
    geodLatNode = 0
    got_field = .false.
    incline = 90 ! Latitude same as phi, not projected onto orbit plane
    insetOverlaps = .false.
    interpolationFactor = 1.0
    lonNode = 0
    LosAngleNode = 0
    maxLowerOverlap = 999 ! was -1 but now -1 is a legal value
    maxUpperOverlap = 999 ! was -1 but ..
    QTM_level = 6             ! QTM level 6 gives 156 km resolution
    single = .false.
    solarTimeNode = 0
    solarZenithNode = 0
    timeNode = 0

    do keyNo = 2, nsons(root)
      son = subtree(keyNo,root)
      field = subtree(1,son)
      if ( nsons(son) > 1 ) then
        fieldValue = decoration(subtree(2,son)) ! The field's value
      else
        fieldValue = son
      end if
      field_index = decoration(field)
      ! The tree checker prevents duplicate fields
      got_field(field_index) = .true.

      select case ( field_index )
      case ( f_type ) ! Required
        hGridType = decoration(subtree(2,son))
      case ( f_coordinate )
        hGrid%masterCoordinate = decoration(subtree(2,son))
      case ( f_date )
        date = sub_rosa(subtree(2,son))
      case  ( f_extendible )
        extendible = get_boolean ( fieldValue )
      case  ( f_forbidOverspill )
        hGrid%forbidOverspill = get_boolean ( fieldValue )
      case ( f_fraction )
        call expr ( subtree(2,son), expr_units, expr_value )
        fraction = expr_value(1)
      case ( f_height )
        call expr ( subtree(2,son), expr_units, expr_value )
        height = expr_value(1)
      case ( f_insetOverlaps )
        insetOverlaps = get_boolean ( fieldValue )
      case ( f_interpolationFactor )
        call expr ( subtree(2,son), expr_units, expr_value )
        interpolationFactor = expr_value(1)
      case ( f_geodAngle )
        geodAngleNode = son
      case ( f_geodLat )
        geodLatNode = son
      case ( f_inclination )
        call expr (subtree ( 2, son), expr_units, expr_value )
        incline = expr_value(1)
      case ( f_lon )
        lonNode = son
      case ( f_losAngle )
        losAngleNode = son
      case ( f_maxLowerOverlap )
        call expr ( subtree(2,son), expr_units, expr_value )
        maxLowerOverlap = nint(expr_value(1))
      case ( f_maxUpperOverlap )
        call expr ( subtree(2,son), expr_units, expr_value )
        maxUpperOverlap = nint(expr_value(1))
      case ( f_mif )
        call expr ( subtree(2,son), expr_units, expr_value )
        mif = nint(expr_value(1))
      case ( f_module )
        ! instrumentModule = sub_rosa(subtree(2,son))
        ! call get_string ( instrumentModule , instrumentModuleName )
        instrumentModule = decoration(decoration(subtree(2,son)))
        call GetModuleName ( instrumentModule , instrumentModuleName )
        hGrid%module = instrumentModule
        if ( deebug ) then
          call output('insrumentModuleName in the case f_module is ' )
          call output(instrumentModuleName, advance='yes')
        endif
      case ( f_origin )
        call expr ( subtree(2,son), expr_units, expr_value )
        origin = expr_value(1)
      case ( f_QTMlevel )
        call expr ( subtree(2,son), expr_units, expr_value )
          QTM_level = nint(expr_value(1))
        select case ( expr_units(1) )
        case ( phyq_angle ) ! expr_value is in degrees
          QTM_level = ceiling ( log ( 180.0d0 / expr_value(1) ) / ln2 )
        case ( phyq_dimensionless )
          QTM_level = nint(expr_value(1))
        case ( phyq_length ) ! expr_value is in meters
          QTM_level = ceiling ( log (20.0d6 / expr_value(1)) / ln2 )
        case default ! Don't really need this because units are checked already
          call MLSMessage ( MLSMSG_Error, ModuleName // '/' &
            & // 'CreateHGridFromMLSCFInfo', &
            & "Units of QTMLevel not dimensionless, length, or angle." )
        end select
        if ( QTM_level > QTM_Depth ) then
          call MLSMessage ( MLSMSG_Error, ModuleName // '/' &
            & // 'CreateHGridFromMLSCFInfo', &
            & "QTM resolution is too fine; maximum depth is %D.", QTM_depth, &
            & where=where(son), advance='no' )
          call MLSMessage ( MLSMSG_Error, ModuleName // '/' &
            & // 'CreateHGridFromMLSCFInfo', &
            & " QTM resolution is 20000/2**level km or 180/2**level degrees." )
        end if
      case ( f_single )
        single = get_boolean ( fieldValue )
      case ( f_solarTime )
        solarTimeNode = son
      case ( f_solarZenith )
        solarZenithNode = son
      case ( f_sourceL2gp )
        l2gp => l2gpDatabase(decoration(decoration(subtree(2,son))))
      case ( f_spacing )
        call expr ( subtree(2,son), expr_units, expr_value )
        spacing = expr_value(1)
      case ( f_time )
        timeNode = son
      case default ! Can't get here if tree_checker works correctly
      end select
    end do

    hGrid%type = hGridType
    select case (hGridType)

    case ( l_height, l_fractional, l_fixed ) ! --Fixed, Fractional or Height --
      if (.not. got_field(f_module) ) then
        call announce_error ( root, NoModule )
      else if (.not. NEED_L1BFILES ) then
        call announce_error ( root, NoL1BFILES )
      else
        if ( verbose ) call output ( 'Creating MIF-Based HGrid', advance='yes' )
        ! 1st--did we set any explicit geolocations?
        if ( any ( got_field ( (/ f_geodAngle, f_geodLat, f_losAngle, f_lon, &
          & f_solarTime, f_solarZenith, f_time /) ) ) ) then
          call CreateExplicitHGrid ( son, date, geodAngleNode, geodLatNode, &
            & solarTimeNode, solarZenithNode, lonNode, losAngleNode, incline, &
            & processingRange%startTime, timeNode, hGrid )
        end if
        ! call Dump ( filedatabase, details=2 )
        if ( mycheck ) then
          call outputNamedValue( 'Before creating mif-based MGrid', chunk%chunkNumber )
          call CheckForCorruptFileDatabase( filedatabase )
        endif
        call CreateMIFBasedHGrids ( filedatabase, hGridType, chunk, &
          & got_field, root, height, fraction, interpolationFactor, &
          & instrumentModuleName, mif, maxLowerOverlap, maxUpperOverlap, hGrid )
        if ( mycheck ) then
          call outputNamedValue( 'After creating mif-based MGrid', chunk%chunkNumber )
          call CheckForCorruptFileDatabase( filedatabase )
        endif
      end if

    case ( l_explicit ) ! ---------------------- Explicit --------------
      if ( verbose ) call output ( 'Creating Explicit HGrid', advance='yes' )
      call CreateExplicitHGrid ( son, date, geodAngleNode, geodLatNode, &
        & solarTimeNode, solarZenithNode, lonNode, losAngleNode, incline, &
        & processingRange%startTime, timeNode, hGrid )

    case ( l_l2gp) ! --------------------------- L2GP ------------------
      
      if ( verbose ) call output ( 'Creating L2GP-Based HGrid', advance='yes' )
      ! Get the time from the l1b file
      call L1BGeoLocation ( filedatabase, "MAFStartTimeTAI", &
        & instrumentModuleName, fullArray )
      call L1BSubsample ( chunk, FullArray, values=TAI )
      noMAFs = size(TAI)
      minTime = TAI(1) ! l1bField%dpField(1,1,1)
      maxTime = TAI(noMAFs) ! l1bField%dpField(1,1,noMAFs)

      call Hunt ( l2gp%time, (/minTime, maxTime/), profRange, allowTopValue=.true. )
      profRange(1) = min ( profRange(1)+1, l2gp%nTimes )
      
      a = profRange(1)
      b = profRange(2)
      hGrid%noProfs = b - a + 1
      call CreateEmptyHGrid(hGrid)
      hGrid%phi(1,:) =         l2gp%geodAngle(a:b)
      hGrid%geodLat(1,:) =     l2gp%latitude(a:b)
      hGrid%lon(1,:) =         l2gp%longitude(a:b) 
      hGrid%time(1,:) =        l2gp%time(a:b)
      hGrid%solarTime(1,:) =   l2gp%solarTime(a:b)
      hGrid%solarZenith(1,:) = l2gp%solarZenith(a:b)
      hGrid%losAngle(1,:) =    l2gp%losAngle(a:b)

      call Deallocate_test ( fullArray, 'fullArray', ModuleName )
      call Deallocate_test ( TAI, 'TAI', ModuleName )
      ! call deallocateL1BData ( l1bField ) ! Avoid memory leaks

    case ( l_QTM ) ! --------------------------- Regular ---------------
      if ( verbose ) call output ( 'Creating QTM HGrid', advance='yes' )
      if ( .not. allocated(polygon_vertices) ) then
        call announce_error ( root, noPolygon )
      else
        call output('insrumentModuleName is ' )
        call output(instrumentModuleName, advance='yes')
        call create_QTM_hgrid ( filedatabase, polygon_inside, polygon_vertices, QTM_level, &
          & hGrid, trim(instrumentModuleName) )
      end if

    case ( l_regular ) ! ----------------------- Regular ---------------
      if ( verbose ) call output ( 'Creating Regular HGrid', advance='yes' )
      if ( .not. got_field(f_module) ) then
        call announce_error ( root, NoModule )
      else if ( .not. all(got_field((/f_spacing, f_origin/)))) then
        call announce_error ( root, NoSpacingOrigin )
      else if (.not. NEED_L1BFILES ) then
        call announce_error ( root, NoL1BFILES )
      else
        call CreateRegularHGrid ( filedatabase, processingRange, chunk, &
          & spacing, origin, trim(instrumentModuleName), extendible, &
          & maxLowerOverlap, maxUpperOverlap, insetOverlaps, single, hGrid, &
          & onlyComputingOffsets )
      end if

    end select
    
    if ( mycheck ) then
      call outputNamedValue( 'Before finding nearest maf', chunk%chunkNumber )
      call CheckForCorruptFileDatabase( filedatabase )
    end if
    if ( hGridType /= l_QTM ) then
      ! Find nearest maf based on time
      if ( L1BFile%hdfVersion /= HDFVERSION_5 ) then
      elseif ( .not. IsHDF5DSInFile ( L1BFile%name, "MAFStartTimeTAI" ) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName // '/' &
          & // 'CreateHGridFromMLSCFInfo', &
          & "MAFStartTimeTAI not found in l1b file" )
        call trace_end ( "CreateHGridFromMLSCFInfo", &
          & cond=toggle(gen) .and. ( levels(gen) > 1 .or. .not. computingOffsets ) )
        return
      endif
      if ( verbose ) call output ( 'Reading MAFStartTimeTAI', advance='yes' )
      call L1BGeoLocation ( filedatabase, "MAFStartTimeTAI", &
          & instrumentModuleName, fullArray )
      if ( verbose ) call output ( 'Subsampling MAFStartTimeTAI', advance='yes' )
      call L1BSubsample ( chunk, fullArray, values=TAI )
      if ( verbose ) call output ( 'Hunting MAFStartTimeTAI', advance='yes' )
      call Hunt ( TAI, hgrid%time(1,:), hgrid%maf, &
        & allowTopValue=.true. )
    end if

    if ( DeeBug ) then
      call outputNamedValue ( 'firstMAF', chunk%firstMAFIndex )
      call outputNamedValue ( 'lastMAF',  chunk%lastMAFIndex )
      call outputNamedValue ( 'shape(MAFStartTimeTAI)', &
        &                      shape(TAI) )
      call outputNamedValue ( 'MAFStartTimeTAI (hid)',  &
        & tai93s2hid(TAI, leapsec=.true.) )
      call outputNamedValue ( 'hgrid time (hid)', &
        & tai93s2hid(hgrid%time(1,:), leapsec=.true.) )
      call outputNamedValue ( 'nearest maf', hgrid%maf + chunk%firstMAFIndex )
      call outputNamedValue ( 'nearest maf time', &
        & tai93s2hid(TAI(hgrid%maf), leapsec=.true.) )
    end if
    ! No--we already use hgrid%maf as a relativee maf numbr elsewhere in l2
    ! hgrid%maf = hgrid%maf + chunk%firstMAFIndex - 1
    ! call deallocateL1BData ( l1bField )
    if ( hGridType /= l_QTM ) then
      call Deallocate_test ( fullArray, 'fullArray', ModuleName )
      call Deallocate_test ( TAI, 'TAI', ModuleName )
      if ( switchDetail(switches, 'geom') >= 0 .and. .not. mySuppressGeometryDump ) &
        & call DumpChunkHGridGeometry ( hGrid, chunk, &
        & trim(instrumentModuleName), filedatabase )
    end if
    if ( verbose ) then
      call sayTime ( 'Constructing this HGrid' )
      call time_now( t1 )
    end if

    if ( error /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName // '/' &
      & // 'CreateHGridFromMLSCFInfo', &
      & "See ***** above for error message" )
    call trace_end ( "CreateHGridFromMLSCFInfo", &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
  end function CreateHGridFromMLSCFInfo

  ! ----------------------------------------  CreateExplicitHGrid  -----
  subroutine CreateExplicitHGrid ( key, date, geodAngleNode, geodLatNode, &
        & solarTimeNode, solarZenithNode, lonNode, losAngleNode, incline, &
        & Time, timeNode, hGrid )

    use Dates_Module, only: UTC2TAI93s
    use Error_Handler, only: Simple, Error_Intro
    use Expr_M, only: Expr
    use HighOutput, only: BeVerbose, OutputNamedValue
    use Geometry, only: Phi_To_Lat_Deg
    use Global_Settings, only: LeapSecFilename
    use HgridsDatabase, only: CreateEmptyHGrid, HGrid_T
    use MLSKinds, only: Rk => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use SDPToolkit, only: MLS_UTCtoTAI
    use String_Table, only: Get_String
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: NSons, Source_Ref, Subtree

    ! dummy arguments
    integer, intent(in) :: KEY           ! Tree node
    integer, intent(in) :: DATE          ! Date if any
    integer, intent(in) :: GEODANGLENODE ! Geod angle if any
    integer, intent(in) :: GEODLATNODE   ! Geod latitude if any
    integer, intent(in) :: LONNODE       ! longitude if any
    integer, intent(in) :: LOSANGLENODE  ! los angle if any
    real(rk), intent(in) :: Incline      ! Orbit inclination, degrees
    integer, intent(in) :: SOLARTIMENODE ! Solar time if any
    integer, intent(in) :: SOLARZENITHNODE ! Solar zenith angle if any
    integer, intent(in) :: TIMENODE ! Explicit d.p. numeric time field if any
    real(rk), intent(in) :: TIME        ! Time for HGrid
    type (HGrid_T), intent(inout) :: HGRID
    ! Local variables
    character(len=80) :: DATESTRING
    integer :: EXPR_UNITS(2)            ! Output from Expr subroutine
    real(rk) :: EXPR_VALUE(2)   ! Output from Expr subroutine
    integer :: NOPROFS                  ! Number of profiles
    integer :: NODE                     ! A tree node
    integer :: Me = -1                  ! String index for tracing
    integer :: PARAM                    ! Loop counter
    integer :: PROF                     ! Loop counter
    integer :: RETURNSTATUS             ! Flag
    real(rk), dimension(:,:), pointer :: VALUES
    logical :: verbose
    ! The following mysterious integers allow us
    ! to engage in some contemptible trickery to fill
    ! the HGrid's geolocation fields--a better
    ! method would call a well-written procedure, passing it appropriate
    ! args for each field
    ! However, we inherited this piece-o-work and just
    ! expanded it include three more fields
    integer, parameter :: PHIPARAM = 1
    integer, parameter :: SOLARTIMEPARAM = PHIPARAM + 1
    integer, parameter :: SOLARZENITHPARAM = SOLARTIMEPARAM + 1
    integer, parameter :: TIMEPARAM = SOLARZENITHPARAM + 1
    integer, parameter :: LONPARAM = TIMEPARAM + 1
    integer, parameter :: LOSANGLEPARAM = LONPARAM + 1
    integer, parameter :: GEODLATPARAM = LOSANGLEPARAM + 1
    integer, parameter :: NUMPARAMS = GEODLATPARAM

    integer :: ParamNode(numParams)

    ! Executable code

    call trace_begin ( me, "CreateExplicitHGrid", key, &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
    verbose = BeVerbose( 'hgrid', -1 )

    paramNode = [ &
      & geodAngleNode             , & ! PHIPARAM
      & solarTimeNode             , & ! SOLARTIMEPARAM
      & solarZenithNode           , & ! SOLARZENITHPARAM
      & TimeNode                  , & ! TIMEPARAM
      & lonNode                   , & ! LONPARAM
      & losAngleNode              , & ! LOSANGLEPARAM
      & geodLatNode               ]   ! GEODLATPARAM

    ! 1st--try to get the number of instances by rude count
    noProfs = 0
    do param = 1, NUMPARAMS
      node = paramNode(param)
      if ( node /= 0 ) then
        if ( noProfs /= 0 ) then
          if ( nSons(node) - 1 /= noProfs ) then
            call error_intro ( simple, source_ref(node) )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Explicit HGrid fields have different sizes' )
          end if
        end if
        noProfs = nSons ( node ) - 1
      end if
    end do

    ! Create an hGrid with this many profiles and no overlaps
    hGrid%noProfs = noProfs
    hGrid%noProfsLowerOverlap = 0
    hGrid%noProfsUpperOverlap = 0

    call CreateEmptyHGrid(hGrid)
    ! Fill up the obvious stuff
    hGrid%lon = 0.0_rk
    hGrid%losAngle = 0.0_rk
    if ( date /= 0 ) then
      call get_string ( date, dateString, strip=.true. )
      if ( verbose ) call outputNamedValue( 'dateString', dateString )
      if ( verbose ) call outputNamedValue( 'LeapSecFileName', LeapSecFileName )
      if ( len_trim(LeapSecFileName) > 1 ) then
        returnStatus = mls_utctotai &
          & ( trim(LeapSecFileName), trim(dateString), hGrid%time(1,1) )
      else
        ! Without a leapsec file, let's use date_module's built-in feature
        hGrid%time(1,1) = utc2tai93s ( dateString, leapsec=.true. )
      end if
      if ( returnStatus /= 0 ) call announce_error( key, badTime )
      hGrid%time = hGrid%time(1,1)
    else
      hGrid%time = time                   ! Get it from input time range
    end if
    ! Set defaults for the others, our expressions may overwrite them
    hGrid%phi = 0.0_rk
    hGrid%geodLat = 0.0_rk
    hGrid%solarTime = 0.0_rk
    hGrid%solarZenith = 0.0_rk
    hGrid%lon = 0.0_rk
    hGrid%losAngle = 0.0_rk

    ! Loop over the parameters we might have
    ! which may override any set above
    do param = 1, NUMPARAMS
      node = paramNode(param)
      if ( node /= 0 ) then
        select case ( param )
        case ( PHIPARAM )
          values => hGrid%phi
        case ( SOLARTIMEPARAM )
          values => hGrid%solarTime
        case ( SOLARZENITHPARAM )
          values => hGrid%solarZenith
        case ( TIMEPARAM )
          values => hGrid%Time
        case ( LONPARAM )
          values => hGrid%lon
        case ( LOSANGLEPARAM )
          values => hGrid%losAngle
        case ( GEODLATPARAM )
          values => hGrid%GeodLat
        end select
        do prof = 1, hGrid%noProfs
          call expr ( subtree ( prof+1, node), expr_units, expr_value )
          ! Units are checked in the type checker.
          values(1,prof) = expr_value(1)
        end do
      end if
    end do

    ! If the geodetic latitude isn't explicitly specified, compute it from
    ! orbit geodetic angle and orbit inclination.
    if ( geodLatNode == 0 ) &
      & hGrid%geodLat = Phi_To_Lat_Deg ( hGrid%phi, incline )

    call trace_end ( "CreateExplicitHGrid", &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

  end subroutine CreateExplicitHGrid

  ! ---------------------------------------  CreateMIFBasedHGrids  -----
  subroutine CreateMIFBasedHGrids ( filedatabase, hGridType, &
    & chunk, got_field, root, height, fraction, interpolationFactor,&
    & instrumentModuleName, mif, maxLowerOverlap, maxUpperOverlap, hGrid )
    ! This is part of ConstructHGridFromMLSCFInfo

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Chunks_M, only: MLSCHunk_T
    use Dump_0, only: Dump
    use HGridsDatabase, only: CreateEmptyHGrid, Dump, HGrid_T, TrimHGrid
    use HighOutput, only: LetsDebug, OutputNamedValue
    use Init_Tables_Module, only: F_Fraction, F_Geodangle, F_Geodlat, F_Height, &
      & F_Lon, F_Losangle, F_Mif, F_Time, &
      & F_Solartime, F_Solarzenith, L_Fixed, L_Fractional, L_Height, L_Mif
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName, CheckForCorruptFileDatabase
    use MLSHDF5, only: IsHDF5DSInFile
    use MLSKinds, only: Rk => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead, &
      & MLSMSG_Warning
    use MLSNumerics, only: Hunt, InterpolateValues
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End

    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    integer, intent(in)               :: HGRIDTYPE
    type (MLSChunk_T), intent(in)     :: CHUNK
    integer                           :: error
    logical, dimension(:), intent(in) :: GOT_FIELD
    integer, intent(in)               :: ROOT
    real(rk), intent(in)              :: INTERPOLATIONFACTOR
    real(rk), intent(in)              :: HEIGHT
    real(rk), intent(in)              :: FRACTION
    character (len=*), intent(in)     :: INSTRUMENTMODULENAME
    integer, intent(in)               :: MIF
    integer, intent(in)               :: MAXLOWEROVERLAP
    integer, intent(in)               :: MAXUPPEROVERLAP
    type (HGrid_T), intent(inout)     :: HGRID ! Needs inout as name set by caller

    ! Local variables / parameters
    integer, parameter :: L1B_MAFSTARTTIMETAI = 1
    integer, parameter :: L1B_TPGEODLAT       = l1b_MAFStartTimeTAI + 1
    integer, parameter :: L1B_TPLON           = l1b_tpGeodLat + 1
    integer, parameter :: L1B_TPGEODANGLE     = l1b_tpLon + 1
    integer, parameter :: L1B_TPSOLARZENITH   = l1b_tpGeodAngle + 1
    integer, parameter :: L1B_TPSOLARTIME     = l1b_tpSolarZenith + 1
    integer, parameter :: L1B_TPLOSANGLE      = l1b_tpSolarTime + 1
    integer, parameter :: NOL1BITEMSTOREAD=l1b_tpLosAngle
    integer, parameter :: FIRSTMODULARITEM=l1b_tpGeodLat

    real(rk), parameter :: SIXTH = 1.0_rk / 6.0_rk

    character (len=15), dimension(noL1BItemsToRead) :: L1bItemNames
    ! Entries in the above array following FirstModularItem are prefixed
    ! with either GHz or THz. 

    logical :: deeBug
    integer :: L1BFLAG                  ! Flag
    integer :: L1BITEM                  ! Loop counter
    integer :: MAF                      ! Loop counter etc.
    integer :: Me = -1                  ! String index for trace
    real(rk) :: MinAngle, MaxAngle
    logical :: MissingOK
    logical :: MissingThisOK
    logical :: myCheck
    integer :: NOMAFS                   ! Dimension
    real(rk), dimension(:,:,:), pointer :: TpGeodAlt, TpGeodAngle

    ! MIFs it would choose in the non over/undersampled case
    real(rk), dimension(:), pointer :: defaultField, interpolatedField

    type (L1BData_T) :: l1bField ! L1B data
    integer, dimension(:), pointer :: defaultMIFs
    real(rk), dimension(:), pointer :: defaultIndex
    real(rk), dimension(:), pointer :: interpolatedIndex
    integer ::  hdfVersion
    ! integer ::  status
    character (len=NameLen) :: L1BItemName
    type (MLSFile_T), pointer             :: L1BFile

    ! Executable code
    deebug = LetsDebug ( 'hgrid', 1 )
    call trace_begin ( me, "CreateMIFBasedHGrids", root, &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    hdfversion = L1BFile%HDFVersion
    myCheck = .false. ! (chunk%chunkNumber == 1)
    if ( mycheck ) then
      call outputNamedValue( 'On entering mif-based MGrid', chunk%chunkNumber )
      call CheckForCorruptFileDatabase( filedatabase )
    endif
    ! call MLS_closeFile ( L1BFile, status )
    ! call outputNamedValue ( 'Status on close', status )
    ! call Dump ( L1BFile, details=2 )
    ! call MLS_openFile ( L1BFile, status )
    ! call outputNamedValue ( 'Status on open', status )
    ! call Dump ( L1BFile, details=2 )
    nullify ( tpGeodAlt, tpGeodAngle, defaultField, interpolatedField, &
      & defaultMIFs, defaultIndex, interpolatedIndex )

    l1bItemNames(l1b_mafstarttimetai ) = 'MAFStartTimeTAI'
    l1bItemNames(l1b_tpgeodlat       ) = 'tpGeodLat'
    l1bItemNames(l1b_tplon           ) = 'tpLon'
    l1bItemNames(l1b_tpgeodangle     ) = 'tpGeodAngle'
    l1bItemNames(l1b_tpsolarzenith   ) = 'tpSolarZenith'
    l1bItemNames(l1b_tpsolartime     ) = 'tpSolarTime'
    l1bItemNames(l1b_tplosangle      ) = 'tpLosAngle'

    select case ( hGridType )
    case ( l_Fractional )
      if ( .not. got_field(f_Fraction) ) &
        & call announce_error ( root, noFraction )
      l1bItemName = trim(instrumentModuleName)//"."//"tpGeodAngle"
    case ( l_Height )
      if ( .not. got_field(f_height) ) call announce_error ( root, noHeight )
      l1bItemName = trim(instrumentModuleName)//"."//"tpGeodAlt"
    case ( l_Fixed )
      if ( .not. got_field(f_mif) ) call announce_error ( root, noMIF )
    case ( l_mif )
      ! ??? Does something go here?
      ! ??? Probably not, since L_MIF isn't in hGridType in init_tables_module
    end select

    if ( hGridType /= l_Fixed ) then
      l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
      call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex, &
        & dontPad=.true. )
      if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_L1BRead//l1bItemName )
    else
      noMAFs = chunk%lastMafIndex - chunk%firstMafIndex + 1
    end if

    ! allocate default MIFs
    call Allocate_test ( defaultMIFs, noMAFs, 'defaultMIFs', ModuleName )
    
    ! Work out which MIF should have the profile for each MAF.
    select case ( hGridType )
    case ( l_Fractional )
      ! A fractional hGrid, we need to read the tangent point phi
      tpGeodAngle=> l1bField%dpField
      
      ! Loop over the MAFs
      do maf = 1, noMAFs
        ! ??? Think about missing data here! ***
        ! Probably need to do a pack on tpGeodAngle and then unpack on
        ! defaultMIFs
        
        minAngle=minval(tpGeodAngle(1,:,maf))
        maxAngle=maxval(tpGeodAngle(1,:,maf))
        
        call Hunt ( tpGeodAngle(1,:,maf), &
          & minAngle+fraction*(maxAngle-minAngle) , defaultMIFs(maf) )
      end do
    case ( l_Height )
      tpGeodAlt => l1bField%dpField
      
      ! Loop over the MAFs
      do maf = 1, noMAFs
        ! ??? Think about missing data here! ***
        ! Probably need to do a pack on tpGeodAngle and then unpack on
        ! defaultMIFs
        
        call Hunt ( tpGeodAlt(1,:,maf), height, defaultMIFs(maf) )
      end do
    case ( l_fixed )
      defaultMIFs = mif
    end select
    
    if ( mycheck ) then
      call outputNamedValue( 'After reading 1st l1bdata', chunk%chunkNumber )
      call CheckForCorruptFileDatabase( filedatabase )
    endif
    ! Done with this piece of l1b data for the moment
    call DeallocateL1BData ( l1bField )
    
    ! Now we have a default MIFs array; this is a list of the `standard'
    ! MIFs we would choose in the interpolationFactor=1 case.
    ! Work out how many profiles this is going to be.
    
    if ( .not. any( got_field ( (/ f_geodAngle, f_geodLat, f_losAngle, f_lon, &
      & f_solarTime, f_solarZenith, f_time /) ) ) ) then
      ! Create an empty hGrid
      hGrid%noProfs = NINT(noMAFs*interpolationFactor)
      call CreateEmptyHGrid( hGrid )
      MissingOK = .false.
    else
      MissingOK = .true.
      ! call dump( hGrid )
    end if
    
    hGrid%noProfsLowerOverlap = 0
    hGrid%noProfsUpperOverlap = 0
    
    ! Setup some arrays
    call allocate_test ( defaultField, noMAFs, 'defaultField', ModuleName )
    call allocate_test ( interpolatedField, hGrid%noProfs, 'interpolatedField', ModuleName )
    call allocate_test ( defaultIndex, noMAFs, 'defaultIndex', ModuleName )
    call allocate_test ( interpolatedIndex, hGrid%noProfs, 'interpolatedIndex', ModuleName )

    ! Now we go through all the important geolocation quantities, read them
    ! in, interpolate them if required and store the result in the hGrid
    error = 0
    do l1bItem = 1, NoL1BItemsToRead
      ! Get the name of the item to read
      l1bItemName = l1bItemNames(l1bItem)
      MissingThisOK = MissingOK .and. l1bItem /= l1b_mafstarttimetai
      if ( l1bItem >= firstModularItem ) l1bItemName = &
        & trim(instrumentModuleName)//"."//l1bItemName
      
      ! Read it from the l1boa file
      l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
      if ( deebug ) then
        call outputNamedValue( 'item', trim(l1bItemName) )
        call outputNamedValue( 'MissingOK', MissingOK )
      endif
      if ( .not. IsHDF5DSInFile( L1BFile%name, l1bItemName ) &
        & .and. MissingthisOK ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_L1BRead//l1bItemName )
        cycle
      endif
      if ( mycheck ) then
        call outputNamedValue( 'Before next reading l1bdata', trim(l1bItemName) )
        call CheckForCorruptFileDatabase( filedatabase )
      endif
      call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex, &
        & neverfail=(MissingOK .or. l1bItem == l1b_tplosangle), dontPad=.true. )
      if ( mycheck ) then
        call outputNamedValue( 'After next reading l1bdata', trim(l1bItemName) )
        call CheckForCorruptFileDatabase( filedatabase )
      endif
      if ( deebug ) call outputNamedValue( 'l1bFlag', l1bFlag )
      if ( l1bFlag==-1 .and. .not. MissingthisOK ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_L1BRead//l1bItemName )
        error = 1
        stop
        cycle
      elseif ( .not. IsHDF5DSInFile ( L1BFile%name, trim(l1bItemName) ) ) then
        call outputNamedValue ( 'item missing from l1b file', trim(l1bItemName) )
        cycle
      endif
      if ( deebug .and. index(l1bItemName, 'MAFStartTimeTAI') > 0 ) then
        call dump(l1bField%DpField(1,1,:), 'MAFStartTimeTAI (before interpolating)')
      end if
      
      if ( l1bItem == 1 ) then       ! do something special for time
        do maf = 1, noMAFs
          defaultField(maf) = l1bField%dpField(1,1,maf) + &
            & (defaultMIFs(maf)-1)*sixth
        end do
      else                         ! Otherwise this is fairly "easy". ???
        if ( associated(l1bField%intField) ) then
          do maf = 1, noMAFs
            defaultField(maf) = l1bField%intField(1,defaultMIFs(maf),maf)
          end do
        else
          do maf = 1, noMAFs
            defaultField(maf) = l1bField%dpField(1,defaultMIFs(maf),maf)
          end do
        endif
      end if

      if ( mycheck ) then
        call outputNamedValue( 'After setting default field', trim(l1bItemName) )
        call CheckForCorruptFileDatabase( filedatabase )
      endif
      if ( deebug .and. index(l1bItemName, 'MAFStartTimeTAI') > 0 ) then
        call dump(defaultField, 'MAFStartTimeTAI, corrected to defaultMIFs')
      end if
      call DeallocateL1BData(l1bField)
      
      if ( interpolationFactor == 1.0 ) then
        interpolatedField = defaultField
      else
        ! Interpolations are performed based on MAF index and periodic variables
        ! like lon, solartime, losAngle are handled specially so that it can cope
        ! with the period jump between two adjacent MAFs. The range of the periods
        ! of these variable must be specified, i.e., (lower, upper) bounds. 

        ! create index of the old and new hGrid indices
        do maf=1,noMAFs
          defaultIndex(maf)=maf*1.0_rk 
        end do
        do maf=1,hGrid%noProfs 
          interpolatedIndex(maf)=maf/interpolationFactor
        end do

        select case ( l1bItem )
        case ( l1b_tpLon )
          call InterpolateValues(defaultIndex,defaultField,interpolatedIndex,&
                interpolatedField,method='Linear',rangeofPeriod=(/-180.0_rk,180.0_rk/))
        case ( l1b_tpSolarTime )
          call InterpolateValues(defaultIndex,defaultField,interpolatedIndex,&
                interpolatedField,method='Linear',rangeofPeriod=(/0.0_rk,24.0_rk/))
        case ( l1b_tpLosAngle )
          call InterpolateValues(defaultIndex,defaultField,interpolatedIndex,&
                interpolatedField,method='Linear',rangeofPeriod=(/0.0_rk,360.0_rk/))
        case default
          call InterpolateValues(defaultIndex,defaultField,interpolatedIndex,&
                interpolatedField,method='Linear')
        end select

      end if
      
      if ( mycheck ) then
        call outputNamedValue( 'After interpolating', trim(l1bItemName) )
        call CheckForCorruptFileDatabase( filedatabase )
      endif
      if ( deebug .and. index(l1bItemName, 'MAFStartTimeTAI') > 0 ) then
        call dump(InterpolatedField, 'MAFStartTimeTAI (after interpolating)')
      end if
      select case ( l1bItem )
      case ( l1b_MAFStartTimeTAI )
        hGrid%time(1,:) = interpolatedField
      case ( l1b_tpGeodLat )
        hGrid%geodLat(1,:) = interpolatedField
      case ( l1b_tpLon )
        hGrid%lon(1,:) = interpolatedField
      case ( l1b_tpGeodAngle )
        hGrid%phi(1,:) = interpolatedField
      case ( l1b_tpSolarZenith )
        hGrid%solarZenith(1,:) = interpolatedField
      case ( l1b_tpSolarTime )
        hGrid%solarTime(1,:) = interpolatedField
      case ( l1b_tpLosAngle )
        hGrid%losAngle(1,:) = interpolatedField
      end select
      if ( mycheck ) then
        call outputNamedValue( 'After filling HGrid with this l1bdata', chunk%chunkNumber )
        call CheckForCorruptFileDatabase( filedatabase )
      endif
    end do
    
    call Deallocate_test ( defaultMIFs, 'defaultMIFs', ModuleName )
    call Deallocate_test ( defaultField, 'defaultField', ModuleName )
    call Deallocate_test ( defaultIndex, 'defaultIndex', ModuleName )
    call Deallocate_test ( interpolatedField, 'interpolatedField', ModuleName )
    call Deallocate_test ( interpolatedIndex, 'interpolatedIndex', ModuleName )
    
    ! ??? This calculation may need attention! ***
    if ( deeBug ) call outputNamedValue( 'interpolationFactor', interpolationFactor )
    hGrid%noProfsLowerOverlap = &
      & nint(chunk%noMAFsLowerOverlap*interpolationFactor)
    hGrid%noProfsUpperOverlap = &
      & nint(chunk%noMAFsUpperOverlap*interpolationFactor)
    if ( deeBug ) call outputNamedValue( 'overlaps', &
      & (/ hGrid%noProfsLowerOverlap, hGrid%noProfsUpperOverlap/) )

    ! Now deal with the user requests
    if ( maxLowerOverlap >= 0 .and. &
      & ( hGrid%noProfsLowerOverlap > maxLowerOverlap ) .and. error == 0 ) &
      call TrimHGrid ( hGrid, -1, hGrid%noProfsLowerOverlap - maxLowerOverlap )
    if ( maxUpperOverlap >= 0 .and. &
      & ( hGrid%noProfsUpperOverlap > maxUpperOverlap ) .and. error == 0 ) &
      call TrimHGrid ( hGrid, -1, hGrid%noProfsUpperOverlap - maxUpperOverlap )

    if ( mycheck ) then
      call outputNamedValue( 'After trimming hgrid', chunk%chunkNumber )
      call CheckForCorruptFileDatabase( filedatabase )
    endif
    call trace_end ( "CreateMIFBasedHGrids", &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

  end subroutine CreateMIFBasedHGrids

  ! -------------------------------------------  Create_QTM_HGrid  -----
  subroutine Create_QTM_HGrid ( filedatabase, Polygon_Inside, Polygon_Vertices, Level, HGrid, instrumentModuleName )

    ! Create a QTM within the specified polygon with the specified level
    ! of refinement.

    ! Presumably we don't get here until it's been checked whether the
    ! polygon exists.

    ! We need to know both the polygon boundary and a point inside the
    ! polygon because the concept "inside a polygon" is ambiguous on the
    ! surface of a sphere.

    use Allocate_Deallocate, only: Test_Allocate
    use Generate_QTM_M, only: Generate_QTM
    use Geolocation_0, only: H_T
    use HGridsDatabase, only: CreateEmptyHGrid
    use MLSStringLists, only: SwitchDetail
    use QTM_Output, only: Write_QTM_Unformatted
    use Toggles, only: Switches
    use Output_M, only: Output
    use L1bData, only: L1bData_T, ReadL1BData, Namelen, &
      & AssembleL1Bqtyname, Dump
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use Geometry, only: To_XYZ
    
    type (MLSFile_T), dimension(:), pointer ::     FileDatabase
    type(h_t), intent(in) :: Polygon_Inside ! A point inside the polygon
    type(h_t), intent(in) :: Polygon_Vertices(:)
    integer, intent(in) :: Level
    type(hGrid_t), intent(inout) :: HGrid
    character (len=*), intent(in) :: InstrumentModuleName

    integer :: I, QTMFile, Stat
    type (L1BData_T) :: lats            ! lats data
    type (L1BData_T) :: lons            ! lons data
    type (MLSFile_T), pointer             :: L1BFile
    integer :: L1BFLAG                  ! error Flag
    integer :: NoMAFs
    integer :: MAFsofar
    character (len=NameLen) :: L1BItemName
    real(r8), dimension(:, :), pointer :: xyz
    real(r8), dimension(:, :), pointer :: xyz_p
    integer :: MAF
    integer :: noP
    real(r8), dimension(:),  pointer :: r
    real(r8) :: rsofar
    type (L1BData_T) :: SolarTimes            ! SolarTime data
    type (L1BData_T) ::SolarZenith
    type (L1BData_T) ::MAFStartTimeTAI
     
    
    call output ('Inside Create_QTM_HGrid', advance='yes' )
    ! 1st-- read lats and lons from the l1b file
    
    L1BFile => GetMLSFileByType( filedatabase, content='l1boa' )  
    if ( .not. associated(L1BFile) ) &
          & call MLSMessage  ( MLSMSG_Error, ModuleName, &
          & 'Can not make progress in  Create_QTM_HGrid without L1BOA files' )
    l1bItemName = AssembleL1BQtyName (  instrumentModuleName//".tpGeodLat", L1BFile%HDFVersion, .false. )
    call output (trim(l1bItemName), advance ='yes')
    call ReadL1BData ( L1BFile, l1bItemName, lats, noMAFs, &
        & l1bFlag )
    if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Create_QTM_HGrid Where is ' // l1bItemName )
    call output ('lats is ', advance='yes' )
    call output( lats%dpField(1,1,1::NoMAFS), advance='yes')
    call dump ( lats, 0)
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpLon", L1BFile%HDFVersion, .false. )
    call output (trim(l1bItemName), advance ='yes')
    call ReadL1BData ( L1BFile, l1bItemName, lons, noMAFs, &
        & l1bFlag )
    if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Create_QTM_HGrid Where is ' // l1bItemName )
    call output ('lons is ' )
    call output( lons%dpField(1,1,1::NoMAFS), advance='yes')
    call dump ( lons, 0 ) 
    
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpSolarTime", L1BFile%HDFVersion, .false. )
    call output (trim(l1bItemName), advance ='yes')
    call ReadL1BData ( L1BFile, l1bItemName, SolarTimes, noMAFs, &
        & l1bFlag )
    if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Create_QTM_HGrid Where is ' // l1bItemName )
    call output ('SolarTimes is ' )
    call output( SolarTimes%dpField(1,1,1::NoMAFS), advance='yes')
    call dump ( SolarTimes, 0 ) 
    
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpSolarZenith", L1BFile%HDFVersion, .false. )
    call output (trim(l1bItemName), advance ='yes')
    call ReadL1BData ( L1BFile, l1bItemName, SolarZenith, noMAFs, &
        & l1bFlag )
    if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Create_QTM_HGrid Where is ' // l1bItemName )
    call output ('SolarZenith is ' )
    call output( SolarZenith%dpField(1,1,1::NoMAFS), advance='yes')
    call dump ( SolarZenith, 0 ) 
   
    l1bItemName = AssembleL1BQtyName ( "MAFStartTimeTAI", L1BFile%HDFVersion, .false. )
    call output (trim(l1bItemName), advance ='yes')
    call ReadL1BData ( L1BFile, l1bItemName, MAFStartTimeTAI, noMAFs, &
        & l1bFlag )
    if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Create_QTM_HGrid Where is ' // l1bItemName )
    call output ('MAFStartTimeTAI is ' )
    call output( MAFStartTimeTAI%dpField(1,1,1::NoMAFS), advance='yes')
    call dump ( MAFStartTimeTAI, 0 )
  
    !Converting lats, lons to XYZ
    call output ('Create_QTM_HGrid before do MAF loop', advance='yes')
    allocate (xyz(3,NoMAFs), stat = stat)
    call test_allocate (stat, moduleName, "xyz", &
        & [3], [NoMAFS], storage_size(3*NoMAFs ) )
    do MAF=1, NoMAFs
       call output('lat = ')
       call output( lats%dpField(1,1,MAF) )
       call output ('  lon = ')   
       call output( lons%dpField(1,1,MAF), advance='yes')
       xyz(1:3,MAF) = to_xyz ( lats%dpField(1,1,MAF), lons%dpField(1,1,MAF))
       call output ('xyz is ')
       call output (xyz(1:3, MAF), advance='yes')
    enddo
    
    call output('Testing xyz array after population', advance='yes')
    do MAF = 1, NoMAFs
       call output ('MAF = ')
       call output (MAF)
       call output (' , XYZ is ')
       call output ( xyz(1:3, MAF), advance='yes')
    enddo
               
    allocate ( hGrid%QTM_tree, stat=stat )
    call test_allocate ( stat, moduleName, "hGrid%QTM_tree", &
      & [1], [1], storage_size(hGrid%QTM_tree) / 8 )
    hGrid%QTM_tree%level = level
    hGrid%QTM_tree%in_geo = polygon_inside
    ! Explicit allocation won't be necessary when compilers support
    ! automatic allocation for assignment to allocatable arrays.
    allocate ( hGrid%QTM_tree%polygon_geo(size(polygon_vertices)), stat=stat )
    call test_allocate ( stat, moduleName, "hGrid%Polygon_geo", &
      & [1], [size(polygon_vertices)], storage_size(polygon_vertices) / 8 )
    hGrid%QTM_tree%polygon_geo = polygon_vertices

    call generate_QTM ( hGrid%QTM_tree )

    hGrid%noProfs = hGrid%QTM_tree%n_in
    call CreateEmptyHGrid(hGrid)

    ! Put imaginative values in HGrid fields so they're not undefined.
    ! They might actually be useful.  Some might get more meaningful
    ! values elsewhere.

    hGrid%maf = [ ( i, i = 1, hGrid%noProfs ) ]
    hGrid%phi(1,:) = 0 ! Phi is kind of meaningless for QTM
    hGrid%geodLat(1,:) = hGrid%QTM_tree%geo_in%lat
    hGrid%lon(1,:) = hGrid%QTM_tree%geo_in%lon%d
    hGrid%time(1,:) = 0
    hGrid%solarTime(1,:) = 0
    hGrid%solarZenith(1,:) = 0
    hGrid%losAngle(1,:) = 0

    allocate (xyz_p(3,hGrid%noProfs), stat = stat)
    call test_allocate (stat, moduleName, "xyz_p", &
        & [3], [hGrid%noProfs], storage_size(3*hGrid%noProfs ) )
     
    do noP=1, hGrid%noProfs
       call output('lat for profile = ')
       call output( hGrid%geodLat(1,noP) )
       call output ('  lon for profile  = ')   
       call output( hGrid%lon(1,noP), advance='yes')
       xyz_p(1:3,noP) = to_xyz ( hGrid%geodLat(1,noP), hGrid%lon(1,noP))
       call output ('xyz_p is ')
       call output (xyz_p(1:3,noP), advance='yes')   
    enddo 
     
    allocate (r(NoMAFs), stat = stat)
    call test_allocate (stat, moduleName, "r", &
        & [NoMAFs], [0], storage_size(NoMAFs) )
        
    call output('Ready to compute distance r', advance='yes')
    
    do  noP=1, hGrid%noProfs   
       r = (xyz(1,:) - xyz_p(1,noP))**2 + &
           &(xyz(2,:) - xyz_p(2,noP))**2 +  &
           &(xyz(3,:) - xyz_p(3,noP))**2
       call output('distance for ')
       call output(noP)
       call output ('  profile is ')
       call output (r, advance='yes') 
       rsofar = r(1)
       MAFsofar = 1
       do  MAF=2, noMAFS 
         if(r(MAF) .GE. rsofar) cycle
         rsofar = r(MAF)
         MAFsofar = MAF
       enddo        
       call output ('rsofar is ')
       call output (rsofar, advance = 'yes') 
       call output ('MAFsofar is ')
       call output (MAFsofar, advance = 'yes') 
       hGrid%time(1,noP) =  MAFStartTimeTAI%dpField(1,1,MAFsofar)
       hGrid%solarTime(1,noP) =  SolarTimes%dpField(1,1,MAFsofar)
       hGrid%solarZenith(1,noP) =  SolarZenith%dpField(1,1,MAFsofar)      
    enddo
       
    
    QTMFile = switchDetail ( switches, 'QTMFile' )
    if ( QTMFile > 0 ) then
      ! Write a Fortran unformatted file to make it easier to look at a QTM
      ! using other tools, e.g., IDL
      call write_QTM_unformatted ( hGrid%QTM_tree, QTMFile )
    end if

  end subroutine Create_QTM_HGrid

  ! -----------------------------------------  CreateRegularHGrid  -----
  subroutine CreateRegularHGrid ( filedatabase, processingRange, chunk, &
    & spacing, origin, instrumentModuleName, extendible, &
    & maxLowerOverlap, maxUpperOverlap, insetOverlaps, single, hGrid, &
    & onlyComputingOffsets )

    ! Creates an HGrid with coordinates laid out in
    ! a regular spacing w.r.t. master coordinate, phi, aka Geodetic Angle

    ! Depends on an approximation to the Earth's shape (Empirical Geometry)
    ! and interpolation
    
    ! With older l1b files (pre v2.0), some coordinates
    ! (solar time, solar zenith angle) are mean rather than apparent local
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use ChunkDivide_M, only: ChunkDivideConfig
    use Chunks_M, only: MLSChunk_T, Dump
    use Dump_0, only: Dump
    use Diff_1, only: Selfdiff
    use EmpiricalGeometry, only: EmpiricalLongitude, ChooseOptimumLon0
    use Geometry, only: Phi_To_Lat_Deg
    use HGridsDatabase, only: CreateEmptyHGrid, HGrid_T, TrimHGrid, &
      & FindClosestMatch
    use HighOutput, only: BeVerbose, LetsDebug, OutputNamedValue
    use MLSFillValues, only: IsFillValue, Monotonize
    use MLSKinds, only: Rk => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSNumerics, only: Hunt, InterpolateValues
    use MLSStringLists, only: SwitchDetail
    use MLSStrings, only: Lowercase
    use Monotone, only: IsMonotonic
    use Output_M, only: Blanks, Newline, Output
    use String_Table, only: Display_String, Get_String, IsStringInTable
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End

    type (MLSFile_T), dimension(:), pointer ::     FileDatabase
    type (TAI93_Range_T), intent(in) :: ProcessingRange
    type (MLSChunk_T), intent(in) :: Chunk
    real(rk), intent(in) :: Spacing
    real(rk), intent(in) :: Origin
    character (len=*), intent(in) :: InstrumentModuleName
    logical, intent(in) :: Extendible
    integer, intent(in) :: MaxLowerOverlap
    integer, intent(in) :: MaxUpperOverlap
    logical, intent(in) :: InsetOverlaps
    logical, intent(in) :: Single
    type (HGrid_T), intent(inout) :: HGrid ! Needs inout as name set by caller
    logical, intent(in), optional :: onlyComputingOffsets

    ! Local variables/parameters
    real(rk), dimension(:,:), pointer :: AllGeodAngle ! For every MIF
    logical :: deeBug
    real(rk), parameter :: SecondsInDay = 24*60*60
    ! Note this next one is ONLY NEEDED for the case where we have only
    ! one MAF in the chunk
    real(rk), parameter :: OrbitalPeriod = 98.8418*60.0

    logical :: DeebugHere
    real(rk) :: Delta                   ! A change in angle
    integer :: Extra                    ! How many profiles over 1 are we
    real(rk) :: First                   ! First point in of hGrid
    integer :: FirstProfInRun           ! Index of first profile in processing time
    double precision, dimension(:), pointer :: FullArray
    double precision, dimension(:,:), pointer :: FullArray2d
    integer :: I                        ! Loop counter
    real(rk) :: Incline                 ! Mean orbital inclination
    type (MLSFile_T), pointer             :: L1BFile
    integer :: LastProfInRun            ! Index of last profile in processing time
    real(rk) :: Last                    ! Last point in hGrid
    integer :: Left                     ! How many profiles to delete from the LHS in single
    real(rk) :: MaxAngle                ! Largest angle in chunk
    real(rk) :: MaxAngleFirstMAF        ! Gives 'range' of first maf
    integer :: Me = -1                  ! String index for tracing
    real(rk), dimension(:), pointer :: MIF1GEODANGLE ! For first mif
    real(rk) :: MinAngle                ! Smallest angle in chunk
    real(rk) :: MinAngleLastMAF         ! Gives 'range' of last maf
    integer :: N                        ! Guess at number of profiles
    character(len=64) :: Name
    integer :: NoMAFs                   ! How many in chunk
    integer :: NoMIFs
    real(rk) :: NextAngle               ! First non ovl. MAF for next chunk
    integer :: Right                     ! How many profiles to delete from the RHS in single
    double precision, dimension(:), pointer :: GeodAngle
    double precision, dimension(:,:), pointer :: GeodAngle2d
    double precision, dimension(:), pointer :: LosAngle
    double precision, dimension(:), pointer :: scOrbIncl
    double precision, dimension(:), pointer :: SolarZenith
    double precision, dimension(:,:), pointer :: SolarZenith2d
    double precision, dimension(:), pointer :: TAI
    real(rk), dimension(:), pointer :: TmpAngle ! A temporary array for the single case
    logical :: Verbose
    logical :: WarnIfNoProfs
    logical :: profiled  ! Print grep-able info about overlaps discarded

    ! Executable code
    deebug = LetsDebug ( 'hgrid', 1 )
    call trace_begin ( me, "CreateRegularHGrid", &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
    deebughere = deebug .or. ( switchDetail(switches, 'hgrid') > 0 ) ! e.g., 'hgrid1' 
    warnIfNoProfs = single ! .or. ChunkDivideConfig%maxLength < 2 ! .false.
    ! call outputNamedValue ( 'maxLength', ChunkDivideConfig%maxLength, options='--Banner' )
    ! call outputNamedValue ( 'warnIfNoProfs', warnIfNoProfs, options='--Banner' )
    verbose = BeVerbose ( 'hgrid', -1 ) ! deebughere
    profiled = BeVerbose ( 'profiled', -1 )
    if ( present(onlyComputingOffsets) ) then
      ! verbose = .not. onlyComputingOffsets
      warnIfNoProfs = warnIfNoProfs .or. onlyComputingOffsets
      deebughere = deebug .or. ( switchDetail(switches, 'hgrid') > 1 ) ! e.g., 'hgrid2' 
      ! verbose = verbose .or. deebughere
      verbose = BeVerbose ( 'hgrid', 1 ) ! deebughere
      profiled = .not. onlyComputingOffsets !.false.
    end if
    ! We may need the Grid's name
    if ( isStringInTable(hgrid%name) ) then
      call Get_String ( hgrid%name, name )
      profiled = profiled .and. index(lowercase(name), 'standard') > 0
    else
      ! call output('(unknown)' )
      name = '(unknown)'
    end if
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'l1boa file not in database' )

    ! Setup the empircal geometry estimate of lon0
    ! (it makes sure it's not done twice
    call ChooseOptimumLon0 ( filedatabase, chunk, instrumentModuleName )

    ! First we're going to work out the geodetic angle range
    ! Read an extra MAF if possible, as we may use it later
    ! when computing the overlaps.
    call L1BGeoLocation ( filedatabase, "tpGeodAngle", instrumentModuleName, &
      & fullArray, FullArray2d )
    call L1BSubsample ( chunk, fullArray, fullArray2d, GeodAngle, GeodAngle2d )
    if ( any(isFillValue(FullArray2d) ) .and. deebug ) then
      call output( 'Fill values among full array', advance='yes' )
    endif
    if ( any(isFillValue(GeodAngle2d) ) .and. verbose ) then
      call output( 'Fill values among reduced array', advance='yes' )
    endif
    noMAFs = chunk%lastMAFIndex - chunk%firstMAFIndex + 1
    noMIFs = size(GeodAngle2d(:,1))
    if ( deebughere ) then
      call outputnamedValue ( 'noMAFs', noMAFs )
      call outputnamedValue ( 'noMIFs', noMIFs )
      call outputnamedValue ( 'shape(GeodAngle)', shape(GeodAngle) )
      call outputnamedValue ( 'shape(GeodAngle2d)', shape(GeodAngle2d) )
      call Dump ( chunk )
      call Dump ( GeodAngle2d, 'GeodAngle2d' )
    endif
    minAngle = minval ( GeodAngle2d(:,1) )
    maxAngleFirstMAF = maxval ( GeodAngle2d(:,1) )
    maxAngle = maxval ( GeodAngle2d(:,noMAFs) )
    minAngleLastMAF = minval ( GeodAngle2d(:,noMAFs) )
    nullify ( mif1GeodAngle, allgeodangle )
    call Allocate_test ( mif1GeodAngle, noMAFs, 'mif1Geodangle', ModuleName )
    call Allocate_test ( allGeodAngle, noMIFs, noMAFs, 'allGeodangle', ModuleName )
    mif1GeodAngle = GeodAngle2d(1,1:noMAFs)
    allGeodAngle = GeodAngle2d(1:noMIFs,1:noMAFs)
    if ( .not. isMonotonic(mif1GeodAngle) ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'mif1GeodAngle is not monotonic--will try anyway' )
      call dump( mif1GeodAngle, 'mif1GeodAngle (before)' )
      call monotonize(mif1GeodAngle)
      call dump( mif1GeodAngle, 'mif1GeodAngle (after)' )
    end if

    ! Get or guess the start of the next chunk.
    i = noMAFs - chunk%noMAFsUpperOverlap + 1
    if ( deebughere ) then
      call outputNamedValue( 'i', i )
      call outputNamedValue( 'NoMAFs', size(FullArray2d, 2) )
      call outputNamedValue( 'maxAngle + spacing', maxAngle + spacing )
    endif
    if ( i < 1 ) then
      if ( deebughere ) then
        call output ( 'While constructing regular hGrid ', advance='yes' )
        call output ( 'minAngle: ' )
        call output ( minAngle, format='(F7.2)' )
        call output ( ' maxAngle: ' )
        call output ( maxAngle, format='(F7.2)' )
        call output ( 'i: ' )
        call output ( i, advance='yes' )
        call output ( 'noMAFs: ' )
        call output ( noMAFs, advance='yes' )
        call output ( 'chunk%noMAFsUpperOverlap: ' )
        call output ( chunk%noMAFsUpperOverlap, advance='yes' )
        call dump(chunk)
      endif
      if ( .not. associated(L1BFile) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Obviously impossible guess where to start next chunk' )
      
    else if ( i < size(GeodAngle2d, 2) + 1 ) then ! noMAFsInFile + 1 ) then
      nextAngle = GeodAngle2d(1, i)
    else
      nextAngle = maxAngle + spacing
    end if

    ! Now choose the geodetic angles for the hGrid
    if ( .not. single ) then 
      ! First identify the first point - 
      ! the one closest to the start of the first MAF
      first = origin + spacing * int ( (minAngle-origin)/spacing )
      delta = first - minAngle            ! So +ve means first could be smaller
      if ( delta > spacing/2 ) then
        first = first - spacing
      else if ( delta < -spacing/2 ) then
        first = first + spacing
      end if
    
      ! Now work out the last point in a similar manner
      if ( extendible ) then
        last = origin + spacing * (1 + int ( (maxAngle-origin)/spacing ) )
        delta = last - maxAngle            ! So +ve means last could be smaller
        if ( delta > 3*spacing/2 ) then
          last = last - spacing
        else if ( delta < -spacing/2 ) then
          last = last + spacing
        end if
      else
        last = origin + spacing * int ( (maxAngle-origin)/spacing )
        delta = last - maxAngle            ! So +ve means last could be smaller
        if ( delta > spacing/2 ) then
          last = last - spacing
        else if ( delta < -spacing/2 ) then
          last = last + spacing
        end if
      end if
    else
      ! The 'single' option is typically used for running single profile retrievals
      ! in a debug mode.  In order to ensure we choose the same profile for each MAF
      ! that a phiWindow=0 forward model would select, we have to do some extra work.

      ! First check this is a sane request
      if ( noMAFs /= 1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Single hGrid option set but more than one MAF in chunk' )
      ! Now construct a temporary HGrid that spans an orbit either side of this MAF
      ! Overkill I know but not harmfull.
      first = origin + spacing * int ( (minAngle-origin)/spacing ) - 360.0_rk
      last = first + 720.0_rk
      n = ( last - first ) / spacing
      nullify ( tmpAngle )
      call Allocate_test ( tmpAngle, n, 'tmpAngle', ModuleName )
      do i = 1, n
        tmpAngle ( i ) = first + (i-1) * spacing
      end do
      i = FindClosestMatch ( tmpAngle, GeodAngle2d, 1 )
      first = tmpAngle ( i )
      last = first
      call Deallocate_test ( tmpAngle, 'tmpAngle', ModuleName )
    end if

    ! Done with the L1B data
    call Deallocate_test ( fullArray, 'fullArray', ModuleName )
    call Deallocate_test ( fullArray2d, 'fullArray2d', ModuleName )

    ! Now in the case where we have overlaps, let's try and have the
    ! first and last profile inside the MAF range
    if ( .not. single ) then
      if ( chunk%noMAFsLowerOverlap > 0 ) then
        setFirstLoop: do
          if ( first >= last ) exit setFirstLoop
          if ( first > maxAngleFirstMAF ) exit setFirstLoop
          first = first + spacing
        end do setFirstLoop
      else 
        if ( .not. insetOverlaps .and. first > minAngle ) first = first - spacing
      end if
      if ( chunk%noMAFsUpperOverlap > 0 ) then
        setLastLoop: do
          if ( last <= first ) exit setLastLoop
          if ( extendible ) then
            if ( last < max( nextAngle, minAngleLastMAF ) ) exit setLastLoop
          else
            if ( last < minAngleLastMAF ) exit setLastLoop
          end if
          last = last - spacing
        end do setLastLoop
      else
        if ( .not. insetOverlaps .and. last < maxAngle ) last = last + spacing
      end if
    end if

    ! Now work out how many profiles that is and lay them down
    hGrid%noProfs = nint( (last-first) / spacing ) + 1
    call CreateEmptyHGrid ( hGrid )
    do i = 1, hGrid%noProfs
      hGrid%phi(1,i) = first + (i-1)*spacing
    end do

    if ( verbose ) then
      call output ( 'Constructing regular hGrid ' )
      if ( hgrid%name /= 0 ) call display_string ( hgrid%name )
      call output ( '', advance='yes' )
      call outputNamedValue ( 'Number of profiles', hGrid%noProfs )
      call output ( 'minAngle: ' )
      call output ( minAngle, format='(F7.2)' )
      call output ( ' maxAngle: ' )
      call output ( maxAngle, format='(F7.2)' )
      call output ( ' nextAngle: ' )
      call output ( nextAngle, format='(F7.2)', advance='yes' )
      call output ( 'Num profiles: ' )
      call output ( hGrid%noProfs )
      call output ( ' Spacing: ' )
      call output ( spacing )
      call output ( ' first: ' )
      call output ( first, format='(F7.2)' )
      call output ( ' last: ' )
      call output ( last, format='(F7.2)', advance='yes' )
      call output ( ' firstMAFIndex: ' )
      call output ( chunk%firstMAFIndex )
      call output ( ' lastMAFIndex: ' )
      call output ( chunk%lastMAFIndex )
      call output ( ' extendible: ' )
      call output ( extendible, advance='yes' )
      call output ( ' forbidoverspill: ' )
      call output ( hGrid%forbidoverspill, advance='yes' )
      call output ( ' allowPriorOverlaps: ' )
      call output ( ChunkDivideConfig%allowPriorOverlaps, advance='yes' )
      call output ( ' allowPostOverlaps: ' )
      call output ( ChunkDivideConfig%allowPostOverlaps, advance='yes' )
    end if

    ! Now fill the other geolocation information, first latitude
    ! Get orbital inclination
    ! l1bItemName = AssembleL1BQtyName ( "scOrbIncl", hdfVersion, .false. )
    if ( .not. associated(L1BFile) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'l1boa file not in database' )
    call L1BGeoLocation ( filedatabase, "scOrbIncl", &
      & instrumentModuleName, fullArray )
    call L1BSubsample ( chunk, FullArray, values=scOrbIncl )
    if ( deebughere ) then
      call dump(scOrbIncl, "scOrbIncl")
    end if
    ! Use the average of all the first MIFs to get inclination for chunk
    incline = sum ( scOrbIncl ) / size(scOrbIncl) ! noMAFs
    if ( noMAFs /= size(scOrbIncl) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'num of MAFs /= size(orb inclination qty)' )
    if ( deebughere ) then
      call dump( (/incline/), 'Average inclination')
    end if
    call Deallocate_test ( fullArray, 'fullArray', ModuleName )
    call Deallocate_test ( scOrbIncl, 'scOrbIncl', ModuleName )
    hGrid%geodLat = phi_to_lat_deg ( hGrid%phi, incline )

    ! Now longitude
    call EmpiricalLongitude ( hGrid%phi(1,:), hGrid%lon(1,:) )

    call L1BGeoLocation ( filedatabase, "MAFStartTimeTAI", &
      & instrumentModuleName, fullArray )
    call L1BSubsample ( chunk, FullArray, values=TAI )
    if ( deebughere ) then
      call dump( TAI, "MAFStartTimeTAI" // ' (before interpolating)')
      call selfdiff( TAI, "MAFStartTimeTAI"  )
    end if
    if ( chunk%firstMAFIndex /= chunk%lastMAFIndex ) then
      if ( deebughere ) call outputNamedValue( 'shape(hGrid%phi)', size(hGrid%phi) )
      if ( deebughere ) call outputNamedValue( 'noProfs', hGrid%noProfs )
      call InterpolateValues ( mif1GeodAngle, TAI, &
        & hGrid%phi(1,:), hGrid%time(1,:), &
        & method='Linear', extrapolate='Allow' )
    else
      ! Case where only single MAF per chunk, treat it specially
      hGrid%time = TAI(1) + &
        & ( OrbitalPeriod/360.0 ) * ( hGrid%phi - mif1GeodAngle(1) )
    end if
    if ( deebughere ) then
      call dump( hGrid%time(1,:), "MAFStartTimeTAI" // ' (after interpolating)' )
      call output( 'geod angle, before and after interpolating', &
        & advance='yes' )
      call dump( mif1GeodAngle, 'before' )
      call dump( HGrid%phi(1,:), 'after' )
    end if
    call Deallocate_test ( fullArray, 'fullArray', ModuleName )
    call Deallocate_test ( TAI, 'TAI', ModuleName )
      
    ! Solar time
    ! First get fractional day, note this neglects leap seconds.
    ! Perhaps fix this later !???????? NJL. We do have access to the
    ! UTC ascii time field, perhaps we could use that?
    hGrid%solarTime = modulo ( hGrid%time, secondsInDay ) / secondsInDay
    ! Now correct for longitude and convert to hours
    hGrid%solarTime = 24.0 * ( hGrid%solarTime + hGrid%lon/360.0 )
    hGrid%solarTime = modulo ( hGrid%solarTime, 24.0_rk )
    if ( deebughere ) call output ( 'Content with l1boa solartime', advance='yes' )

    ! Solar zenith
    call L1BGeoLocation ( filedatabase, "tpSolarZenith", &
      & instrumentModuleName,  fullArray, fullArray2d )
    call L1BSubsample ( chunk, FullArray, fullArray2d, SolarZenith, SolarZenith2d )
    if ( deebughere ) then
      call dump( SolarZenith, "SolarZenith" // &
        & ' (before interpolating)')
    end if
    ! This we'll have to do with straight interpolation
    call InterpolateValues ( mif1GeodAngle, SolarZenith, &
      & hGrid%phi(1,:), hGrid%solarZenith(1,:), &
      & method='Linear', extrapolate='Allow' )
    if ( deebughere ) then
      call dump( hGrid%solarZenith(1,:), "SolarZenith" // &
        & ' (after interpolating)' )
    end if
    call Deallocate_test ( fullArray, 'fullArray', ModuleName )
    call Deallocate_test ( SolarZenith, 'SolarZenith', ModuleName )
    call Deallocate_test ( fullArray2d, 'fullArray2d', ModuleName )
    call Deallocate_test ( SolarZenith2d, 'SolarZenith2d', ModuleName )

    ! Line of sight angle
    call L1BGeoLocation ( filedatabase, "tpLosAngle", &
      & instrumentModuleName, fullArray )
    call L1BSubsample ( chunk, FullArray, values=LosAngle )
    if ( deebughere ) then
      call dump( LosAngle, 'LosAngle' // ' (before interpolating)')
    end if
    call InterpolateValues ( mif1GeodAngle, LosAngle, &
      & hGrid%phi(1,:), hGrid%losAngle(1,:), &
      & method='Linear', extrapolate='Allow' )
    if ( deebughere ) then
      call dump( hGrid%losAngle(1,:), 'LosAngle' // ' (after interpolating)')
    end if
    call Deallocate_test ( fullArray, 'fullArray', ModuleName )
    call Deallocate_test ( LosAngle, 'LosAngle', ModuleName )
    hGrid%losAngle = modulo ( hGrid%losAngle, 360.0_rk )

    ! Now work out how much of this HGrid is overlap
    ! The deal will be the first legitimate profile is the first one who's phi
    ! is above the first non overlapped MAF.
    call Hunt ( hGrid%phi(1,:), mif1GeodAngle(chunk%noMAFsLowerOverlap+1), &
       & hGrid%noProfsLowerOverlap, allowTopValue=.true., allowBelowValue=.true. )
    if ( verbose ) &
      & call outputNamedValue ( 'hGrid%noProfsLowerOverlap (after Hunt)', &
        & hGrid%noProfsLowerOverlap )
    ! So the hunt returns the index of the last overlapped, which is
    ! the number we want to be in the overlap.
    call Hunt ( hGrid%phi(1,:), nextAngle, &
       & hGrid%noProfsUpperOverlap, allowTopValue=.true., allowBelowValue=.true. )
    ! Here the hunt returns the index of the last non overlapped profile
    ! So we do a subtraction to get the number in the overlap.
    hGrid%noProfsUpperOverlap = hGrid%noProfs - hGrid%noProfsUpperOverlap
    ! call outputNamedValue ( 'hGrid%noProfsUpperOverlap (after Hunt)', &
    !  & hGrid%noProfsUpperOverlap )

    if ( verbose .or. hGrid%noProfs == 0 ) then
      call output ( 'Initial Hgrid size: ' )
      call output ( hGrid%noProfs ) 
      call output ( ', overlaps: ' )
      call output ( hGrid%noProfsLowerOverlap )
      call output ( ', ' )
      call output ( hGrid%noProfsUpperOverlap, advance='yes' )
    end if

    ! Now, we want to ensure we don't spill beyond the processing time range.
    ! First an optional 'hard' limit.  This guarantees that no part of the
    ! chunk (even an overlap) spills beyond the processing range.  This is
    ! important for runs using sids L2GP data which has hard limits (would
    ! crash Fill otherwise).  However, it's not important for other runs, so is
    ! optional.
    if ( hGrid%forbidOverspill ) then
      call Hunt ( hGrid%time(1,:), processingRange%startTime, &
        & firstProfInRun, allowTopValue=.true., allowBelowValue=.true. )
      if ( deebughere ) then
        call dump( hGrid%time(1,:), 'Hgrid times')
        call dump( hGrid%time(1,:)-hGrid%time(1,1), 'Hgrid delta times')
        call output ( 'First profile in Run: ' )
        call output ( firstProfInRun, advance='no' )
        call output ( '    processingRange%startTime: ' )
        call output ( processingRange%startTime, advance='yes' )
      end if
      ! if ( firstProfInRun > 0 .and. .not. ChunkDivideConfig%allowPriorOverlaps ) then
      if ( firstProfInRun > 0 ) then
        if ( verbose ) &
          & call output ( 'hGrid starts before run trimming start.', &
          & advance='yes' )
        call TrimHGrid ( hGrid, -1, firstProfInRun )
      end if

      call Hunt ( hGrid%time(1,:), processingRange%endTime, &
        & lastProfInRun, allowTopValue=.true., allowBelowValue=.true. )
      if ( deebughere ) then
        call output ( 'Last profile in Run: ' )
        call output ( lastProfInRun, advance='no' )
        call output ( '    processingRange%endTime: ' )
        call output ( processingRange%endTime, advance='yes' )
      end if
      ! if ( lastProfInRun < hGrid%noProfs .and. .not. ChunkDivideConfig%allowPostOverlaps ) then
      if ( lastProfInRun < hGrid%noProfs ) then
        if ( verbose ) &
          & call output ( 'hGrid ends after run trimming end.',&
          & advance='yes' )
        call TrimHGrid ( hGrid, 1, hGrid%noProfs-lastProfInRun )
      end if
    end if
    ! Now a 'softer' limit that applies to all cases, this just moves the
    ! overlap regions around if necessary to deal with overspill.
    if ( hGrid%noProfsLowerOverlap+1 <= hGrid%noProfs ) then
      if ( hGrid%time(1,hGrid%noProfsLowerOverlap+1) < processingRange%startTime ) then
        if ( verbose ) &
          & call output ( &
          & 'Non overlapped part of hGrid starts before run, extending overlap.', &
          & advance='yes' )
        call Hunt ( hGrid%time(1,:), processingRange%startTime, &
          &   hGrid%noProfsLowerOverlap, allowTopValue=.true., allowBelowValue=.true. )
      end if
    end if

    if ( hGrid%noProfs-hGrid%noProfsUpperOverlap >= 1 ) then
      if ( hGrid%time(1,hGrid%noProfs-hGrid%noProfsUpperOverlap) > &
        & processingRange%endTime ) then
        if ( verbose ) &
          & call output ( &
          & 'Non overlapped part of hGrid end after run, extending overlap.', &
          & advance='yes' )
        call Hunt ( hGrid%time(1,:), processingRange%endTime, &
          & hGrid%noProfsUpperOverlap, allowTopValue=.true., allowBelowValue=.true. )
        hGrid%noProfsUpperOverlap = hGrid%noProfs - hGrid%noProfsUpperOverlap
      end if
    end if

    ! Now deal with the user requests
    if ( single ) then
       ! Set up for no overlaps
       if ( verbose ) call outputNamedValue( 'Before TrimHGrid', hGrid%noProfs )
       hGrid%noProfsLowerOverlap = 0
       hGrid%noProfsUpperOverlap = 0
       ! Delete all but the 'center' profile
       extra = hGrid%noProfs - 1
       left = extra / 2
       right = extra - left
       if ( verbose ) call outputNamedValue( '/single: left, right', (/ left, right /) )
       if ( left > 0 ) call TrimHGrid ( hGrid, -1, left )
       if ( right > 0 ) call TrimHGrid ( hGrid, 1, right )
    else if (hgrid%noProfs > 1) then
       if ( verbose ) call outputNamedValue( 'Before TrimHGrid', hGrid%noProfs )
       if ( maxLowerOverlap >= 0 .and. &
          & ( hGrid%noProfsLowerOverlap > maxLowerOverlap ) ) then
          if ( verbose ) call outputNamedValue( 'Lower overlap too big', hGrid%noProfs )
          call TrimHGrid ( hGrid, -1, hGrid%noProfsLowerOverlap - maxLowerOverlap )
       end if
       if ( maxUpperOverlap >= 0 .and. &
          & ( hGrid%noProfsUpperOverlap > maxUpperOverlap ) ) then
          if ( verbose ) call outputNamedValue( 'Upper overlap too big', hGrid%noProfs )
          call TrimHGrid ( hGrid, 1, hGrid%noProfsUpperOverlap - maxUpperOverlap )
       end if
       ! Setting maxLowerOverlap to -m means we always trim away 
       ! the first m profiles
       if ( maxLowerOverlap < 0 .and. &
         & (hgrid%noProfs > 2) ) then
         if ( verbose ) call outputNamedValue( 'Trimmed away first m profile; m', -maxLowerOverlap )
         call TrimHGrid ( hGrid, -1, -maxLowerOverlap )
         ! A trick!
         ! May need to Trim again if the number of lower overlaps remains > 0
         if ( hGrid%noProfsLowerOverlap == 1 ) &
           & call TrimHGrid ( hGrid, -1, -maxLowerOverlap )
       endif
       ! Setting maxUpperOverlap to -m means we always trim away 
       ! the last m profiles
       if ( maxUpperOverlap < 0 .and. &
         & (hgrid%noProfs > 2) ) then
         if ( verbose ) call outputNamedValue( 'Trimmed away last m profile; m', -maxUpperOverlap )
         call TrimHGrid ( hGrid, 1, -maxUpperOverlap )
       endif
    else ! if there is only one profile, then don't care about overlap
       hGrid%noProfsLowerOverlap = 0
       hGrid%noProfsUpperOverlap = 0
    end if
    if ( profiled ) then
      call output ( '### ### '                 , advance='no' )
      call Blanks ( 2 )
      call output ( chunk%chunkNumber                                  , advance='no' )
      call Blanks ( 2 )
      call output ( hGrid%noProfsLowerOverlap, advance='no' )
      call Blanks ( 2 )
      call output ( hGrid%noProfsUpperOverlap, advance='no' )
      call Newline
    endif

    if ( hGrid%noProfs == 0 ) then
      call dump(chunk)
      if ( warnIfNoProfs ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, 'No profiles in hGrid' )
      else
        call MLSMessage ( MLSMSG_Error, ModuleName, 'No profiles in hGrid' )
      end if
    end if

    ! Finally we're done.
    if ( verbose .or. hGrid%noProfs == 0 ) then
      call output ( 'Final Hgrid size: ' )
      call output ( hGrid%noProfs )
      call output ( ', overlaps: ' )
      call output ( hGrid%noProfsLowerOverlap )
      call output ( ', ' )
      call output ( hGrid%noProfsUpperOverlap, advance='yes' )
    end if

    ! That's it
    call Deallocate_test ( mif1GeodAngle, 'mif1GeodAngle', ModuleName )
    call Deallocate_test ( allGeodAngle, 'allGeodAngle', ModuleName )

    call trace_end ( "CreateRegularHGrid", &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

  end subroutine CreateRegularHGrid

  ! --------------------------------------- DealWithObstructions -----
  subroutine DealWithObstructions ( HGrid, obstructions, DestroyOld )
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Chunkdivide_M, only: Obstruction_T
    use HgridsDatabase, only: Hgrid_T, Createemptyhgrid, Destroyhgridcontents
    use HighOutput, only: LetsDebug
    use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    ! Args
    type (HGRID_T), pointer :: HGRID
    type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
    logical, optional, intent(in) :: DestroyOld
    ! This routine modifies the chunks according to the information
    ! given in the obstructions.

    ! Local variables
    logical :: deeBug
    type (HGRID_T), target :: NEWHGrid ! The one we'll create create
    integer :: FIRSTMAF                 ! Index of first MAF in range
    integer :: LASTMAF                  ! Index of last MAF in range
    integer :: Me = -1                  ! String index for tracing
    integer :: MAF                      ! Index of MAF for wall
    logical :: mayDestroyOld
    integer :: newProfile               ! Counter in newHGrid
    integer :: OBSTRUCTION              ! Loop counter
    integer :: PROFILE                  ! Loop counter
    logical, dimension(:), pointer :: obstructed => null()

    ! Executable code
    deebug = LetsDebug ( 'hgrid', 1 )
    ! 1st--some short-circuits
    if ( hGrid%noProfs < 1 ) return
    if ( .not. associated(obstructions) ) return
    if ( .not. associated(hGrid%phi) ) return
    call trace_begin ( me, "DealWithObstructions", &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
    mayDestroyOld = .false.
    if ( present(DestroyOld) ) mayDestroyOld = DestroyOld
    
    ! Next--fill obstructed array
    nullify (obstructed)
    call Allocate_Test ( obstructed, hGrid%noProfs, &
      & 'obstructed', ModuleName )
    obstructed = .false.
    do obstruction=1, size(obstructions)
      if ( obstructions(obstruction)%range ) then
        ! A range obstruction
        firstMAF = obstructions(obstruction)%mafs(1)
        lastMAF = obstructions(obstruction)%mafs(2)
        if ( firstMAF < 0 .or. firstMAF+1 > hGrid%noProfs ) cycle
        if ( lastMAF < firstMAF .or. lastMAF+1 > hGrid%noProfs ) cycle
        obstructed(firstMAF+1:lastMAF+1) = .true. ! MAF indexes start at 0
      else
        ! A wall obstruction
        maf = obstructions(obstruction)%mafs(1)
        if ( maf < 0 .or. maf+1 > hGrid%noProfs ) cycle
        obstructed(maf+1:maf+1) = .true. ! MAF indexes start at 0
      end if
    end do
    if ( any(obstructed) ) then
      newHGrid%noProfs = count( .not. obstructed )
      call CreateEmptyHGrid(newHGrid)
      newHGrid%name = hgrid%name
      newProfile = 0
      do profile=1, hGrid%noProfs
        if ( obstructed(profile) ) cycle
        newProfile = newProfile + 1
        newHGrid%phi        (1, newProfile) = hgrid%phi        (1, profile)
        newHGrid%geodLat    (1, newProfile) = hgrid%geodLat    (1, profile)
        newHGrid%lon        (1, newProfile) = hgrid%lon        (1, profile)
        newHGrid%time       (1, newProfile) = hgrid%time       (1, profile)
        newHGrid%solarTime  (1, newProfile) = hgrid%solarTime  (1, profile)
        newHGrid%solarZenith(1, newProfile) = hgrid%solarZenith(1, profile)
        newHGrid%losAngle   (1, newProfile) = hgrid%losAngle   (1, profile)
      end do
      if ( hgrid%noProfsLowerOverlap > 0 ) then
        newHGrid%noProfsLowerOverlap = hgrid%noProfsLowerOverlap &
          & - count( obstructed(1:hgrid%noProfsLowerOverlap) )
      end if
      if ( hgrid%noProfsUpperOverlap > 0 ) then
        newHGrid%noProfsUpperOverlap = hgrid%noProfsUpperOverlap &
          & - count( obstructed(hgrid%noProfs-hgrid%noProfsUpperOverlap+1:hgrid%noProfs) )
      end if
      if ( mayDestroyOld ) then
        call DestroyHGridContents(hGrid)
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Destroying old HGrid known to corrupt other HGrid' )
      end if
      hGrid => newHGrid
    end if
    call DeAllocate_Test( obstructed, 'obstructed', ModuleName )

    call trace_end ( "DealWithObstructions", &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

  end subroutine DealWithObstructions

  ! ---------------------------------------------  DestroyHGridGeoLocations  -----
  ! Deallocate all components of HGridGeolocations.
  subroutine DestroyHGridGeoLocations
    use Allocate_Deallocate, only: Deallocate_Test
    call Deallocate_test ( HGridGeolocations%MAFStartTimeTAI, 'MAFStartTimeTAI', ModuleName )
    call Deallocate_test ( HGridGeolocations%GHzGeodAngle   , 'GHzGeodAngle   ', ModuleName )
    call Deallocate_test ( HGridGeolocations%Orbincl        , 'Orbincl        ', ModuleName )
    call Deallocate_test ( HGridGeolocations%GHzGeodAlt     , 'GHzGeodAlt     ', ModuleName )
    call Deallocate_test ( HGridGeolocations%GHzGeodLat     , 'GHzGeodLat     ', ModuleName )
    call Deallocate_test ( HGridGeolocations%GHzLon         , 'GHzLon         ', ModuleName )
    call Deallocate_test ( HGridGeolocations%GHzSolarTime   , 'GHzSolarTime   ', ModuleName )
    call Deallocate_test ( HGridGeolocations%GHzSolarZenith , 'GHzSolarZenith ', ModuleName )
  end subroutine DestroyHGridGeoLocations

  ! -------------------------------------  DumpChunkHGridGeometry  -----
  subroutine DumpChunkHGridGeometry ( hGrid, chunk, &
    & instrumentModuleName, filedatabase )

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Chunks_M, only: MLSChunk_T
    use HgridsDatabase, only: Hgrid_T
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1Bqtyname
    use MLSKinds, only: R8
    use Output_M, only: Output
    use String_Table, only: Display_String

    type (HGrid_T), intent(in) :: HGRID
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    character (len=*) :: INSTRUMENTMODULENAME
    type (MLSChunk_T), intent(in) :: CHUNK

    ! Local parameters
    real (r8), parameter :: BINSIZE=0.05 ! Width of one character in degrees
    integer, parameter :: NOLINES=8     ! Number of lines that make up a scan
    integer, parameter :: WIDTH=75      ! Number of columns to print at a time

    ! Local variables
    character (len=1), dimension(:,:), pointer :: TEXT
    integer :: CHAR                     ! Loop counter
    integer :: CHARMAX                  ! Last character to fill
    integer :: CHARMIN                  ! First character to fill
    integer :: FIRSTMIF                 ! First mif to consider
    integer :: FLAG                     ! From L1B read
    integer :: LASTMIF                  ! Last mif to consider
    integer :: LINE                     ! Loop counter
    integer :: MAF                      ! Loop counter
    integer :: MIFSPERLINE              ! Number of mifs covered by a line
    integer :: NOEMPTYWINDOWS           ! Number of empty windows
    integer :: NOBINS                   ! Number of characters to print
    integer :: NOMAFS                   ! From L1B read
    integer :: NOMIFS                   ! Deduced
    integer :: NOWINDOWS                ! Number of blocks of text
    integer :: PROF                     ! Loop counter
    integer :: START                    ! Index
    integer :: WINDOW                   ! Loop counter
    integer :: WINDOWSIZE               ! Number of characters in this window
    real (r8) :: PHIMAX                 ! Maximum value to consider
    real (r8) :: PHIMIN                 ! Minimum value to consider
    real (r8) :: THISPHIMAX             ! Max phi in a line for a maf
    real (r8) :: THISPHIMIN             ! Min phi in a line for a maf
    real (r8), dimension(:,:), pointer :: MIFPHI ! Tangent phis
    type (L1BData_T) :: L1BFIELD

    integer ::  hdfVersion
    character(len=NameLen) :: l1bItemName
    type (MLSFile_T), pointer             :: L1BFile

    ! Executable code
    call output ( "Dumping geometry for HGrid: " )
    if ( hGrid%name /= 0 ) then
      call display_string ( hGrid%name, strip=.true., advance='yes' )
    else
      call output ( "<no-name>", advance='yes' )
    end if

      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      hdfversion = L1BFile%HDFVersion

    ! Read the geodetic angle from the L1Bfile
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpGeodAngle", hdfVersion, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, &
      & l1bField, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, &
      & lastMAF=chunk%lastMAFIndex, &
      & dontPad=.true. )
    mifPhi => l1bField%dpField(1,:,:)

    phiMin = minval ( mifPhi )
    phiMax = maxval ( mifPhi )
    if ( hGrid%noProfs > 0 ) then
      phiMin = min ( phiMin, hGrid%phi(1,1) )
      phiMax = max ( phiMax, hGrid%phi(1,hGrid%noProfs) )
    end if

    ! Now setup the text to print
    noBins = ( phiMax - phiMin ) / binSize
    call allocate_test ( text, noBins, noLines, 'text', moduleName, fill='' )

    ! Trivial stuff to setup
    noMIFs = size ( mifPhi, 1 )
    mifsPerLine = noMIFs / noLines
    
    ! Now loop over the mafs and fill them up
    do maf = 1, noMAFs
      do line = 1, noLines
        firstMIF = (line-1) * mifsPerLine + 1
        lastMIF = firstMIF + mifsPerLine - 1
        if ( line == noLines ) lastMIF = noMIFs
        thisPhiMin = minval ( mifPhi ( firstMIF:lastMIF, maf ) )
        thisPhiMax = maxval ( mifPhi ( firstMIF:lastMIF, maf ) )
        charMin = ( thisPhiMin - phiMin ) / binSize + 1
        charMax = ( thisPhiMax - phiMin ) / binSize + 1
        charMin = min ( max ( charMin, 1 ), noBins )
        charMax = min ( max ( charMax, 1 ), noBins )
        if ( ( maf < chunk%noMAFsLowerOverlap+1 ) .or. &
          &  ( maf > chunk%lastMAFIndex - chunk%firstMAFIndex + 1 - &
          & chunk%noMAFsUpperOverlap) ) then
          text ( charMin:charMax , line ) = '*'
        else
          text ( charMin:charMax , line ) = '#'
        end if
      end do
    end do

    ! Now loop over the profiles and place them
    do prof = 1, hGrid%noProfs
      charMin = ( hGrid%phi(1,prof) - phiMin ) / binSize + 1
      charMin = min ( max ( charMin, 1 ), noBins )
      if ( ( prof < hGrid%noProfsLowerOverlap+1 ) .or. &
        &  ( prof > hGrid%noProfs-hGrid%noProfsUpperOverlap) ) then
        text ( charMin, : ) = ':'
      else
        text ( charMin, : ) = '|'
      end if
    end do

    ! Now print them out
    noWindows = noBins / width
    noEmptyWindows = 0
    if ( mod ( noBins, width ) /= 0 ) noWindows = noWindows + 1
    do window = 1, noWindows
      windowSize = width
      start = ( window-1 ) * width + 1
      if ( window == noWindows ) windowSize = mod ( noBins, width )
      if ( all ( text ( start : start+windowSize-1, : ) == ' ' ) ) then
        noEmptyWindows = noEmptyWindows + 1
      else
        if ( noEmptyWindows > 0 ) then
          call output ( noEmptyWindows )
          call output ( ' empty windows suppressed', advance='yes' )
          noEmptyWindows = 0
        end if
        call output ( ' ', advance='yes' )
        do line = noLines, 1, -1
          do char = start, start+windowSize-2
            call output ( text ( char, line ) )
          end do
          call output  ( text ( start+windowSize-1, line ), advance='yes' ) 
        end do
        do char = start, start+windowSize-2
          call output ( '-' )
        end do
        call output ( '-', advance='yes' )
      end if
    end do

    ! Finish off
    call deallocate_test ( text, 'text', moduleName )

    call DeallocateL1BData ( l1bField )

  end subroutine DumpChunkHGridGeometry

  ! -------------------------------------  ComputeAllHGridOffsets  -----
  subroutine ComputeAllHGridOffsets ( root, first_section, chunks, filedatabase, &
    & l2gpDatabase, processingRange )
    ! This routine goes through the L2CF up to an Output section to accumulate
    ! HGrid sizes from the Construct sections, and through the L1 file to work
    ! out how big each HGrid is going to be
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Chunks_M, only: MLSChunk_T
    use ChunkDivide_M, only: ChunkDivideConfig
    use Dump_0, only: Dump
    use HGridsDatabase, only: HGrid_T, CopyHGrid, DestroyHGridContents, Dump
    use HighOutput, only: BeVerbose, LetsDebug, OutputNamedValue
    use Init_Tables_Module, only: Z_Construct, S_Hgrid, Z_Output
    use L1BData, only: CheckForCorruptFileDatabase
    use L2GPData, only: L2GPData_T
    use MLSKinds, only: Rk => R8
    use MLSL2Options, only: SpecialDumpFile
    use Moretree, only: Get_Spec_Id
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use Next_Tree_Node_M, only: Init_Next_Tree_Node, Next_Tree_Node, &
      & Next_Tree_Node_State
    use Output_M, only: Output, RevertOutput, SwitchOutput
    use Time_M, only: SayTime, Time_Now
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Subtree, Node_Id, Decoration
    use Tree_Types, only: N_Named
    ! Dummy arguments
    integer, intent(in) :: Root         ! of the entire tree
    integer, intent(in) :: First_Section ! First subtree after definitions
    type(MLSChunk_T), dimension(:), intent(inout) :: CHUNKS
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type(L2GPData_T), dimension(:), pointer :: L2GPDatabase
    type(TAI93_Range_T), intent(in) :: PROCESSINGRANGE
    ! Local variables
    integer :: CHUNK                    ! Loop counter
    integer :: C                        ! Inner loop counter
    logical :: deeBug
    integer :: HGRID                    ! Loop counter
    integer :: How_many
    integer :: Me = -1                  ! String index for trace
    integer :: NOHGRIDS                 ! Number of hGrids
    integer :: SON                      ! Tree node
    integer :: sum1, sum2, sum3
    integer :: GSON                     ! son of son
    integer :: KEY                      ! Tree node
    integer :: KEYINDEX
    type(HGrid_T) :: dummyHGrid         ! A temporary hGrid
    type(HGrid_T), dimension(size(chunks)) :: FirstHGrid     ! The "std" HGrid
    type(next_tree_node_state) :: State1 ! while hunting for Construct sections
    type(next_tree_node_state) :: State2 ! within Construct sections
    integer, dimension(100) :: keyArray
    integer, dimension(:), pointer :: LowerOverlaps => null()
    integer :: nkeys
    integer :: nsections
    logical :: verbose
    logical :: verboser
    real(rk), dimension(:), pointer :: MAFStartTimeTAI, OrbIncl, &
      & GeodAngle, GeodAlt, GeodLat, Lon, LosAngle, SolarTime, SolarZenith
    integer :: InstrumentModule
    character (len=NameLen) :: InstrumentModuleName
    integer, dimension(size(chunks)) :: ChunksWithoutProfiles
    ! Executable code
    computingOffsets = .true.
    deebug = LetsDebug ( 'hgrid', 1 )
    verbose = beVerbose ( 'hgrid', 1 )
    verboser = beVerbose ( 'hgrid', 2 )
    call OutputnamedValue ( 'deebug', deebug )
    call OutputnamedValue ( 'verbose', verbose )
    call OutputnamedValue ( 'verboser', verboser )
    call trace_begin ( me, "ComputeAllHGridOffsets", root, &
      & cond=toggle(gen) )
    if ( specialDumpFile /= ' ' ) &
      & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
    ! Slightly clever loop here, the zero run doesn't do anything except
    ! count the number of hGrids.  The other run works out how big each HGrid
    ! is going to be for each chunk.  This is stored in chunks%hGridOffsets.
    ! Finally we accumulate these to get offsets.
    noHGrids = 0
    nkeys = 0
    if ( deebug .and. .false. ) then
      call outputNamedValue ( 'size(chunks)', size(chunks) )
      call output( 'Before loop of chunks', advance='yes' )
      call CheckForCorruptFileDatabase( filedatabase )
    endif
    do chunk = 0, size(chunks)
      if ( chunk > 0 ) chunks(chunk)%hGridOffsets = 0 ! Initialize
      call time_now ( t0 )
      call time_now ( t1 )
      hGrid = 1
      ! if ( chunk > 20) stop
      ! Loop over all the setions in the l2cf, look for construct sections
      if ( verbose ) &
        & call outputNamedValue ( 'Computing offsets for chunk number', chunk, &
        & Before='*   ', After = '  *' )
      call init_next_tree_node ( state1 )
      nsections = 0
      keyindex = 0
      sectionLoop: do
        nsections = nsections + 1
        son = next_tree_node ( root, state1, start=first_section, traceLevel=4 )
        if ( son == 0 ) exit
        call trace_begin ( me, "ComputeAllHGridOffsets.loop", son, &
          & cond=toggle(gen) .and. levels(gen) > 1 .and. verboser )
        select case ( decoration ( subtree ( 1, son ) ) )
        case ( z_construct )
          ! Now loop through the construct section and identify the hGrids
          call init_next_tree_node ( state2 )
          do ! if chunk == 0, loop over every statement; if chunk > 0, just the keys
            if ( chunk == 0 ) then
              ! For the 'zeroth' pass just count up the hgrids
              gson = next_tree_node ( son, state2, traceLevel=5 )
              if ( gson == 0 ) exit ! Past end-of-section?
              if ( node_id(gson) /= n_named ) cycle ! Is spec labeled?
              key = subtree(2,gson)
              if ( get_spec_id(key) /= s_hGrid ) cycle ! Is it an hgrid?
              nkeys = nkeys + 1
              keyArray(nkeys) = key
              noHGrids = noHGrids + 1
            else
              keyindex = keyindex + 1
              if ( keyindex > nkeys ) exit ! did all keys?
              key = keyArray(keyIndex)
              ! nullify ( dummyHGrid )
              if ( verbose ) then
                call output ( 'Creating dummyHGrid', advance='yes' )
                call sayTime( 'Getting set to call CreateHGrid' )
                call outputnamedValue ( 'This section, keyindex #', &
                  & (/ nsections, keyindex /) )
                call time_now( t1 )
              endif
              ! call Dump ( filedatabase, details=2 )
              if ( chunk == 1 .and. deebug .and. .false. ) then
                call outputNamedValue( 'Before making dummyHGrid', chunk )
                call CheckForCorruptFileDatabase( filedatabase )
              endif
              ! print *, 'About to  call CreateHGridFromMLSCFInfo'
              dummyHGrid = CreateHGridFromMLSCFInfo ( 0, key, filedatabase, l2gpDatabase, &
                & processingRange, chunks(chunk), onlyComputingOffsets=.true., &
                & check=.false. )
                ! & check=(chunk == 1) )
              ! print *, 'Done with CreateHGridFromMLSCFInfo'
              if ( chunk == 1 .and. deebug.and. .false.  ) then
                call outputNamedValue( 'During chunk#', chunk )
                call CheckForCorruptFileDatabase( filedatabase )
              endif
              if ( keyindex == 1 ) then
                if ( verbose ) call output ( 'Creating firstHGrid', advance='yes' )
                  ! firstHGrid(chunk) = CreateHGridFromMLSCFInfo ( 0, key, filedatabase, &
                  !& l2gpDatabase, processingRange, chunks(chunk), &
                  !  & onlyComputingOffsets=.true. )
                call time_now ( t1 )
                call copyHGrid( dummyHGrid, firstHGrid(chunk) )
                if ( verbose ) then
                  call Dump ( firstHGrid(chunk) )
                  call outputNamedValue( 'num Profs copied', dummyHGrid%noProfs )
                  call sayTime( 'Copying HGrid' )
                endif
                InstrumentModule = dummyHGrid%module
                call time_now( t1 )
              endif
              if ( chunk == 1 ) then
                LowerOverlaps(hGrid) = dummyHGrid%noProfsLowerOverlap
                if ( ChunkDivideConfig%allowPriorOverlaps .and. .false. ) then
                  chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                  & dummyHGrid%noProfsUpperOverlap
                else
                  chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                  & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                end if
                if ( deebug .and. .false. ) then
                  call outputNamedValue( 'During chunk#', chunk )
                  call CheckForCorruptFileDatabase( filedatabase )
                endif
              else if ( chunk == size(chunks) ) then
                if ( ChunkDivideConfig%allowPostOverlaps ) then
                  chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                  & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                else
                  chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                  & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                end if
              else
                chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                if ( verbose .and. &
                  & any( dummyHGrid%phi(1,:) /= 0.) .and. key==9927 ) then
                  call outputNamedValue( 'num Profs', dummyHGrid%noProfs )
                  call outputNamedValue( 'key', key )
                  call outputNamedValue( 'phis', dummyHGrid%phi(1,:) )
                endif
              end if
              ! Sometimes we have been computing negative offsets which is .. offsetting
              if ( chunk > 0 ) &
                & chunks(chunk)%hGridOffsets(hGrid) = max( 0, chunks(chunk)%hGridOffsets(hGrid) )
              call time_now ( t1 )
              if ( DEEBUG ) &
                & call dump(dummyHGrid)
              call DestroyHGridContents ( dummyHGrid )
              if ( verbose ) call sayTime ( 'Dumping and destroying this HGrid' )
              call time_now( t1 )
              hGrid = hGrid + 1
            end if
          end do
        case ( z_output )
          ! exit sectionLoop ! No, don't exit the section loop w/o trace_end
        case default
        end select
        call trace_end ( "ComputeAllHGridOffsets.loop", &
          & cond=toggle(gen) .and. levels(gen) > 1 .and. verboser )
      end do sectionLoop
      if ( verbose ) then
        call outputNamedValue( 'number of keys', nKeys )
        call outputNamedValue( 'number of sections', nSections )
        call Dump ( keyArray(:nKeys), 'keys', width=5 )
      endif

      ! If this is the first time round, we now know how many hGrids there
      ! are, set up our arrays
      ! call outputNamedValue ( 'noHGrids', noHGrids )
      ! call outputNamedValue ( 'hGrid', hGrid )
      if ( chunk == 0 ) then
        do c = 1, size ( chunks )
          call Allocate_Test ( chunks(c)%hGridOffsets, noHGrids, &
            & 'chunks(?)%hGridOffsets', ModuleName )
          call Allocate_Test ( chunks(c)%hGridTotals, noHGrids, &
            & 'chunks(?)%hGridTotals', ModuleName )
          call Allocate_Test ( LowerOverlaps, noHGrids, &
            & 'LowerOverlaps', ModuleName )
        end do
        if ( deebug.and. .false.  ) then
          call output( 'After 0th chunk', advance='yes' )
          call CheckForCorruptFileDatabase( filedatabase )
        endif
      elseif ( nkeys /= noHGrids ) then
        call outputnamedValue ( 'nKeys, noHGrids', (/ nkeys, noHGrids /) )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Got a different number of hGrids than expected!' )
      elseif ( chunk < 10 .and. deebug.and. .false.  ) then
        call outputNamedValue( 'After chunk#', chunk )
        call CheckForCorruptFileDatabase( filedatabase )
      end if
    end do                              ! Chunk loop
    ! call output( 'After loop of chunks', advance='yes' )
    ! call CheckForCorruptFileDatabase( filedatabase )
    ! call output( 'Done with chunk Loop', advance='yes' )
    
    if ( DEEBUG ) then
      sum1 = 0
      sum2 = 0
      sum3 = 0
      call output ( "number of profiles in each chunk/grid: " , advance='yes')
      do chunk = 1, size ( chunks )
        call output ( chunk, before='Chunk ', after=': ' )
        call output ( chunks(chunk)%hGridOffsets, advance='yes' )
        sum1 = sum1 + chunks(chunk)%hGridOffsets(1)
        if ( size(chunks(chunk)%hGridOffsets) > 1 ) then
          sum2 = sum2 + chunks(chunk)%hGridOffsets(2)
          if ( size(chunks(chunk)%hGridOffsets) > 2 ) &
            & sum3 = sum3 + chunks(chunk)%hGridOffsets(3)
        end if
      end do
      call output ( "Total number of profiles" , advance='yes')
      call output ( (/ sum1, sum2, sum3 /), advance='yes' )
    end if
    ! Now accumulate hGridOffsets which currently contains the number
    ! of non-overlap profiles in each chunk/hGrid.  After this it will contain
    ! the accumulated number.  This is equivalent to storing the
    ! index of the last profile in each chunk.
    if ( verbose ) &
      & call output( chunks(1)%hGridOffsets(1), before='Chunk 1: ', advance='yes' )
    do chunk = 2, size ( chunks )
      chunks(chunk)%hGridOffsets = chunks(chunk)%hGridOffsets + &
        & chunks(chunk-1)%hGridOffsets
      if ( verbose ) then
        call output ( chunk, before='Chunk ', after=': ' )
        call output ( chunks(chunk)%hGridOffsets(1), advance='yes' )
      end if
    end do
    ! Now fill (i.e. spread) the hGridTotals array
    do chunk = 1, size ( chunks )
      chunks(chunk)%hGridTotals = chunks(size(chunks))%hGridOffsets
    end do
    ! Now move hGridOffsets back one to get the offsets we want.
    ! Each hGridOffsets will now contain the last profile index in the preceding
    ! chunk, which is the offset we desire.
    do chunk = size ( chunks ), 2, -1
      chunks(chunk)%hGridOffsets = chunks(chunk-1)%hGridOffsets
    end do
    chunks(1)%hGridOffsets = 0
    if ( DEEBUG .or. verbose ) then
      call output ( 'chunks(1)%hGridOffsets: ', advance='no' )
      call output ( chunks(1)%hGridOffsets, advance='yes' )
    end if
    if ( ChunkDivideConfig%allowPriorOverlaps .and. &
      & chunks(1)%noMAFsLowerOverlap > 0 .and. firstHGrid(1)%forbidOverspill ) then
      ! This dubious sequence disallows the very Prior overlaps you pretended to
      ! allow
      call dump( LowerOverlaps, 'LowerOverlaps' )
      chunks(1)%hGridOffsets = 0
      do chunk=1, size(chunks)
        chunks(chunk)%hGridOffsets = chunks(chunk)%hGridOffsets + LowerOverlaps
      end do
    else
      chunks(1)%hGridOffsets = 0
    end if
    
    if ( verbose ) then
      call output ( "Dumping offsets, hgridTotals for all chunks: " , &
        & advance='yes')
      do chunk = 1, size ( chunks )
        call output ( chunk, before='Chunk ', after=': ' )
        call output ( chunks(chunk)%hGridOffsets )
        call output ( ' totals ' )
        call output ( chunks(chunk)%hGridTotals, advance='yes' )
      end do
    end if

    if ( verbose ) then
      instrumentModuleName = 'none'
      if ( instrumentModule > 0 ) &
        & call GetModuleName ( instrumentModule, instrumentModuleName )
      ! Read the l1boa items we will need
      nullify( MAFStartTimeTAI, GeodAngle, GeodAlt, GeodLat, &
        & LosAngle, OrbIncl, SolarTime, SolarZenith )
      call L1BGeoLocation ( filedatabase, 'MAFStartTimeTAI  ', instrumentModuleName,  MAFStartTimeTAI, neverFail=.true. )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAngle    ', instrumentModuleName,  GeodAngle, neverFail=.true. )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAlt      ', instrumentModuleName,  GeodAlt, neverFail=.true. )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodLat      ', instrumentModuleName,  GeodLat, neverFail=.true. )
      call L1BGeoLocation ( filedatabase, 'GHz/Lon          ', instrumentModuleName,  Lon, neverFail=.true. )
      call L1BGeoLocation ( filedatabase, 'GHz/LosAngle     ', instrumentModuleName,  LosAngle, neverFail=.true. )
      ! call L1BGeoLocation ( filedatabase, 'sc/OrbIncl       ', instrumentModuleName,  OrbIncl, neverFail=.true. )
      call L1BGeoLocation ( filedatabase, 'GHz/SolarTime    ', instrumentModuleName,  SolarTime, neverFail=.true. )
      call L1BGeoLocation ( filedatabase, 'GHz/SolarZenith  ', instrumentModuleName,  SolarZenith, neverFail=.true. )
      call output ( "Comparing start, end geolocations all chunks: " , &
        & advance='yes')
      do chunk = 1, size ( chunks )
        call outputnamedValue( 'Chunk', chunk )
        if ( firstHGrid(chunk)%noProfs < 1 ) then
          call output ( '(No profiles in this chunk', advance='yes' )
        else
          if ( all ( [ associated(MAFStartTimeTAI), associated(GeodAngle), &
                     & associated(GeodAlt), associated(GeodLat), &
                     & associated(SolarTime) ] ) ) &
            & call CompareWithChunk( chunks(chunk), &
                & chunks(min(size ( chunks ), chunk+1)), firstHGrid(chunk), &
                & MAFStartTimeTAI, GeodAngle, GeodAlt, GeodLat, SolarTime )
        end if
      end do
      call deAllocate_Test ( MAFStartTimeTAI, 'MAFStartTimeTAI', ModuleName )
      ! call deAllocate_Test ( OrbIncl        , 'OrbIncl        ', ModuleName )
      call deAllocate_Test ( GeodAngle      , 'GHz/GeodAngle  ', ModuleName )
      call deAllocate_Test ( GeodAlt        , 'GHz/GeodAlt    ', ModuleName )
      call deAllocate_Test ( GeodLat        , 'GHz/GeodLat    ', ModuleName )
      call deAllocate_Test ( GeodLat        , 'GHz/GeodLat    ', ModuleName )
      call deAllocate_Test ( Lon            , 'GHz/Lon        ', ModuleName )
      call deAllocate_Test ( LosAngle       , 'GHz/LosAngle   ', ModuleName )
      call deAllocate_Test ( SolarTime      , 'GHz/SolarTime  ', ModuleName )
      call deAllocate_Test ( SolarZenith    , 'GHz/SolarZenith', ModuleName )
    end if

    ! Before destroying anything, 
    ! let's reveal which any chunks have no profiles.
    ! We might need this info if we later choose to run just a few, select chunks
    if ( verboser ) call Dump( firstHGrid%noProfs, 'Num of Profiles in each chunk' )
    if ( any(firstHGrid%noProfs == 0) ) then
      call FindAll ( firstHGrid%noProfs, 0, ChunksWithoutProfiles, how_many )
      call Dump( ChunksWithoutProfiles(1:How_many), 'Chunks with no profiles' )
    endif
    do chunk = 1, size ( chunks )
      if ( verbose ) call Dump ( firstHGrid(chunk), Details=1 )
      call DestroyHGridContents ( firstHGrid(chunk) )
    enddo
    call deAllocate_Test ( LowerOverlaps, 'LowerOverlaps', ModuleName )
    if ( specialDumpFile /= ' ' ) call revertOutput
    call trace_end ( "ComputeAllHGridOffsets", &
      & cond=toggle(gen) )
    ! stop
  end subroutine ComputeAllHGridOffsets

  ! ------------------------------  ComputeNextChunksHGridOffsets  -----
  ! This routine is CURRENTLY NOT USED!
  subroutine ComputeNextChunksHGridOffsets ( chunks, chunkNo, hGrids )
    use Allocate_Deallocate, only: Allocate_Test
    use Chunks_m, only: MLSChunk_T
    use HGridsDatabase, only: HGrids_T
    ! Dummy arguments
    type(MLSChunk_T), dimension(:), intent(inout) :: CHUNKS
    integer, intent(in) :: CHUNKNO
    type(HGrids_T), dimension(:), intent(in) :: HGrids
    integer :: I
    ! Executable code
    ! Do nothing if this is the last chunk
    if ( chunkNo == size(chunks) ) return
    ! Allocate the array
    call Allocate_Test ( chunks(chunkNo+1)%hGridOffsets, size(hGrids), &
      & 'chunks(?)%hGridOffsets', ModuleName )
    ! Compute our number of output instances
    do i = 1, size(hGrids)
      chunks(chunkNo+1)%hGridOffsets = hGrids(i)%the_hGrid%noProfs - &
        & hGrids(i)%the_hGrid%noProfsLowerOverlap - &
        & hGrids(i)%the_hGrid%noProfsUpperOverlap
    end do
    ! For later chunks, add on the accumulated previous stuff
    if ( chunkNo > 1 ) &
      & chunks(chunkNo+1)%hGridOffsets = chunks(chunkNo+1)%hGridOffsets + &
      & chunks(chunkNo)%hGridOffsets + 1
  end subroutine ComputeNextChunksHGridOffsets
  
  ! ------------------------------------- PlaceHGridContents --
  subroutine PlaceHGridContents ( HGrid1, HGrid2, offset )
    ! Place the contents of one Hgrid1 inside HGrid2, possibly offset
    use HGridsDatabase, only: HGrid_t
    ! Args
    type(HGrid_T), intent(in)     :: HGrid1
    type(HGrid_T), intent(inout)  :: HGrid2
    integer, optional, intent(in) :: offset ! where in HGrid2 to place HGrid1
    ! Internal variables
    integer :: myOffset
    ! Executable
    myOffset = 0
    if ( present(offset) ) myOffset=offset
    call PlaceArray(HGrid1%phi, HGrid2%phi, myOffset)
    call PlaceArray(HGrid1%geodLat, HGrid2%geodLat, myOffset)
    call PlaceArray(HGrid1%lon, HGrid2%lon, myOffset)
    call PlaceArray(HGrid1%time, HGrid2%time, myOffset)
    call PlaceArray(HGrid1%solarTime, HGrid2%solarTime, myOffset)
    call PlaceArray(HGrid1%solarZenith, HGrid2%solarZenith, myOffset)
    call PlaceArray(HGrid1%losAngle, HGrid2%losAngle, myOffset)
  end subroutine PlaceHGridContents
  
! =====     Private Procedures     =====================================

  ! ---------------------------------------------  ANNOUNCE_ERROR  -----
  subroutine ANNOUNCE_ERROR ( WHERE, CODE )

    use Lexer_Core, only: Print_Source
    use Output_M, only: Output
    use Tree, only: Where_At => Where

    integer, intent(in) :: WHERE   ! Tree node where error was noticed
    integer, intent(in) :: CODE    ! Code for error message

    error = max(error,1)
    call output ( '***** At ' )
    call print_source ( where_at(where) )
    call output ( ': ' )
    select case ( code )
    case ( noFraction )
      call output ( "TYPE = FRACTIONAL but no fraction is specified", &
        & advance='yes' )
    case ( noHeight )
      call output ( "TYPE = HEIGHT but no height is specified", advance='yes' )
    case ( noL1Bfiles )
      call output ( "This type of hgrid needs an l1boa file", advance='yes' )
    case ( noMIF )
      call output ( "TYPE = FIXED but no MIF is specified", advance='yes' )
    case ( noModule )
      call output ( "Instrument module must be specified", advance='yes' )
    case ( noPolygon )
      call output ( "A polygon has not been defined", advance='yes' )
    case ( noSpacingOrigin )
      call output ( "TYPE = Regular but no spacing and/or origin is specified", &
        & advance='yes' )
    case ( badTime )
      call output ( "Bad information given for date in explicit hGrid", &
        & advance='yes' )
    end select
  end subroutine ANNOUNCE_ERROR
    

  ! ---------------------------------------------  CompareWithChunk  -----
  subroutine CompareWithChunk ( chunk, nextChunk, hgrid, &
    & MAFStartTimeTAI, GeodAngle, GeodAlt, GeodLat, SolarTime )

     use Chunks_M, only: MLSChunk_T ! , Dump
     use Dates_Module, only: Gethid
     use HGridsDatabase, only: HGrid_T
     use HighOutput, only: BlanksToColumn, OutputNamedValue
     ! use Machine, only: Crash_Burn
     use MLSKinds, only: Rk => R8
     use Output_M, only: Blanks, NewLine, Output

    ! Args
    type (MLSChunk_T), intent(in)      :: chunk
    type (MLSChunk_T), intent(in)      :: nextChunk
    type (HGrid_T), intent(in)         :: hgrid
    real(rk), dimension(:), pointer    :: MAFStartTimeTAI, GeodAngle, &
      &                                   GeodAlt, GeodLat, SolarTime
    ! Local variables
    integer :: firstMAF
    integer :: lastMAF
    integer :: lowMAF
    integer :: highMAF
    integer :: firstProfile
    integer :: firstProfIndx
    integer :: lastProfile
    integer :: lastProfIndx
    real(rk) :: firstVal
    real(rk) :: lastVal
    ! Executable
    ! call Dump( chunk )
    ! call Dump( nextChunk )
    call output( 'First, last MAFs (then times)', advance='no' )
    call blanks( 20 )
    call output ( (/chunk%firstMAFIndex, chunk%lastMAFIndex/), advance='no' )
    call gethid( MAFStartTimeTAI ( chunk%firstMAFIndex + 1 ), leapsec=.true. , hid=firstVal )
    call gethid( MAFStartTimeTAI ( chunk%lastMAFIndex + 1 ), leapsec=.true. , hid=lastVal  )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call newLine
!     call crash_burn
    firstMAF = chunk%firstMAFIndex + chunk%noMAFsLowerOverlap
    lastMAF = chunk%lastMAFIndex - chunk%noMAFsUpperOverlap
    firstProfile = 1 + chunk%HGridOffsets(1)
    if ( chunk%lastMAFIndex <  nextChunk%lastMAFIndex ) then
      lastProfile = nextChunk%HGridOffsets(1)
    else
      lastProfile = firstProfile + lastMAF - firstMAF
    endif
    call output( 'First, last non-overlap MAFs', advance='no' )
    call blanks( 6 )
    call output ( (/firstMAF, lastMAF/), advance='yes' )
    
    call output( 'First, last profiles', advance='no' )
    call blanks( 6 )
    call output ( (/firstProfile, lastProfile/), advance='yes' )
    if ( lastProfile > chunk%hGridTotals(1) ) then
      call output ( 'Uh-oh, last profile beyond chunk grand total', advance='yes' )
    elseif ( lastProfile < firstProfile ) then
      call output ( '(No profiles in this chunk)', advance='yes' )
      return
    endif
    ! Must reset profile first, last prfile numbers
    ! before using them as indexes into HGrid
    firstProfIndx = firstProfile - chunk%HGridOffsets(1)
    lastProfIndx = lastProfile - chunk%HGridOffsets(1)
    call outputnamedValue ( 'numMAFs (non-overlap)', lastMAF - firstMAF + 1 )
    call outputnamedValue ( 'num Profiles', lastProfile - firstProfile + 1 )
    call outputnamedValue ( 'noProfs', hGrid%noProfs )
    call outputnamedValue ( 'net Profs', hGrid%noProfs &
      & - hGrid%noProfsLowerOverlap - hGrid%noProfsUpperOverlap )
    if ( lastProfIndx > size(hGrid%time, 2) ) then
      call output ( 'Uh-oh, last profile beyond hgrid upper bound', advance='yes' )
      lastProfIndx = size(hGrid%time, 2)
    endif
    lowMAF = hgrid%maf(1) + chunk%firstMAFIndex - 1
    highMAF = hgrid%maf(hGrid%noProfs) + chunk%firstMAFIndex - 1
    highMAF = min(highMAF, size(MAFStartTimeTAI) - 1 )
    call output( 'First, last MAFs matching grid (then times)', advance='no' )
    call blanks( 6 )
    call output ( (/lowMAF, highMAF/), advance='no' )
    call gethid( MAFStartTimeTAI ( lowMAF + 1 ), leapsec=.true. , hid=firstVal )
    call gethid( MAFStartTimeTAI ( highMAF + 1 ), leapsec=.true. , hid=lastVal  )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call newLine
    
    call blanksToColumn( 24 )
    call output( 'Chunk', advance='no' )
    call blanksToColumn( 48 )
    call output( 'HGrid', advance='yes' )

    call blanksToColumn( 4 )
    call output( 'First', advance='no' )
    call blanksToColumn( 18 )
    call output( 'Last', advance='no' )
    call blanksToColumn( 30 )
    call output( 'First', advance='no' )
    call blanksToColumn( 46 )
    call output( 'Last', advance='yes' )
    ! Time
    call gethid( MAFStartTimeTAI ( firstMAF + 1 ), leapsec=.true. , hid=firstVal )
    call gethid( MAFStartTimeTAI ( lastMAF + 1  ), leapsec=.true. , hid=lastVal  )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call blanksToColumn( 28 )
    call gethid( hGrid%time ( 1,firstProfIndx ), leapsec=.true. , hid=firstVal )
    call gethid( hGrid%time ( 1,lastProfIndx  ), leapsec=.true. , hid=lastVal  )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call blanksToColumn( 54 )
    call output( 'hours in day', advance='yes' )

    ! GeodAngle
    firstVal = GeodAngle ( firstMAF + 1 )
    lastVal  = GeodAngle ( lastMAF + 1 )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call blanksToColumn( 28 )
    firstVal = hGrid%phi ( 1,firstProfIndx )
    lastVal  = hGrid%phi ( 1,lastProfIndx  )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call blanksToColumn( 54 )
    call output( 'geodangle', advance='yes' )

    ! geodLat
    firstVal = geodLat ( firstMAF + 1 )
    lastVal  = geodLat ( lastMAF + 1 )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call blanksToColumn( 28 )
    firstVal = hGrid%geodLat ( 1,firstProfIndx )
    lastVal  = hGrid%geodLat ( 1,lastProfIndx  )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call blanksToColumn( 54 )
    call output( 'geodLat', advance='yes' )

    ! SolarTime
    firstVal = SolarTime ( firstMAF + 1 )
    lastVal  = SolarTime ( lastMAF + 1 )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call blanksToColumn( 28 )
    firstVal = hGrid%SolarTime ( 1,firstProfIndx )
    lastVal  = hGrid%SolarTime ( 1,lastProfIndx  )
    call output ( firstVal, format='(f9.4)', advance='no' )
    call blanks ( 3 )
    call output ( lastVal, format='(f9.4)', advance='no' )
    call blanksToColumn( 54 )
    call output( 'SolarTime', advance='yes' )
  end subroutine CompareWithChunk

  subroutine PlaceArray_r4(array1, array2, offset)
    ! place contents of array1 inside array2, possibly offset
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    integer, parameter :: R4 = kind(0.0e0)
    ! Args
    real(r4), dimension(:,:), intent(in)     :: array1
    real(r4), dimension(:,:), intent(inout)  :: array2
    integer, intent(in) :: offset ! Where inside array2 to place array
    ! Internal variables
    integer :: N
    ! Executable
    N = size(array1, 2)
    if ( size(array1, 1) /= size(array2, 1) ) &
      & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/PlaceArray_r4', &
      & 'array sizes mismatched in first index' )
    if ( N+offset > size(array2, 2) ) &
      & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/PlaceArray_r4', &
      & 'array1 too big to place in array2 with given offset' )
    array2(:, 1+offset:N+offset) = array1
  end subroutine PlaceArray_r4

  subroutine PlaceArray_r8(array1, array2, offset)
    ! place contents of array1 inside array2, possibly offset
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    integer, parameter :: R8 = kind(0.0d0)
    ! Args
    real(r8), dimension(:,:), intent(in)     :: array1
    real(r8), dimension(:,:), intent(inout)  :: array2
    integer, intent(in) :: offset ! Where inside array2 to place array
    ! Internal variables
    integer :: N
    ! Executable
    N = size(array1, 2)
    if ( size(array1, 1) /= size(array2, 1) ) &
      & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/PlaceArray_r4', &
      & 'array sizes mismatched in first index' )
    if ( N+offset > size(array2, 2) ) &
      & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/PlaceArray_r4', &
      & 'array1 too big to place in array2 with given offset' )
    array2(:, 1+offset:N+offset) = array1
  end subroutine PlaceArray_r8

  subroutine SayTimeHere ( What )
    use Output_M, only: Blanks, Output
    use Time_M, only: Time_Now
    character(len=*), intent(in) :: What
    call time_now ( t2 )
    call output ( "Timing for " // what // " = " )
    call output ( dble(t2 - t1), advance = 'no' )
    if ( .true. ) then
      call blanks ( 4, advance = 'no' )
      call output ( "Total = " )
      call output ( dble(t2-t0), advance = 'yes' )
    end if
  end subroutine SayTimeHere

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: HGrid.f90,v 2.159 2022/04/13 21:31:28 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module HGrid
!=============================================================================

!
! $Log: HGrid.f90,v $
! Revision 2.159  2022/04/13 21:31:28  pwagner
! Skipped some unneeded output
!
! Revision 2.158  2021/11/18 18:11:28  pwagner
! Re-Trim regular HGrid to remove unwanted stubby overlap
!
! Revision 2.157  2021/11/03 23:47:58  pwagner
! maxLowerOverlap and -Upper many now be negative, meaning to trim away profiles from either end
!
! Revision 2.156  2019/11/22 00:38:43  pwagner
! Be less prone to printing lots; show which chunks have no profiles
!
! Revision 2.155  2019/11/14 22:28:32  pwagner
! Now requires more coaxing to trace sectionLoop in ComputeAllHGridOffsets
!
! Revision 2.154  2019/07/09 22:26:19  pwagner
! Reduce unwanted Checks ForCorruptFileDatabase
!
! Revision 2.153  2018/08/06 20:24:15  pwagner
! Dont exit section loop in ComputeAllHGridOffsets w/o trace_end
!
! Revision 2.152  2018/08/03 23:45:43  vsnyder
! Add tracing to several routines.  Improve some debugging output.  Add
! NeverFail=.true. to L1BGeolcation calls in verbose case to prevent crashing
! if irrelevant stuff is attempted to be found.
!
! Revision 2.151  2018/04/19 00:49:06  vsnyder
! Remove USE statements for unused names
!
! Revision 2.150  2018/04/16 22:20:21  pwagner
! More thorough CamelCase in use statements
!
! Revision 2.149  2018/03/02 00:58:17  pwagner
! Reduce non-debug printing
!
! Revision 2.148  2018/02/23 22:20:51  mmadatya
! Updates for Create_QTM_HGrid for ASMLS
!
! Revision 2.147  2018/01/03 01:17:56  pwagner
! Removed disused solving of a quadratic equation
!
! Revision 2.146  2016/11/04 19:36:24  pwagner
! begin transition to sayTime from time_m
!
! Revision 2.145  2016/10/19 00:31:18  pwagner
! Trying to avoid certain crashes; may be signs of deeper problems
!
! Revision 2.144  2016/10/14 00:04:28  pwagner
! Avoid negative hGridOffsets
!
! Revision 2.143  2016/10/01 01:53:28  vsnyder
! Fill hGrid fields after creating QTM
!
! Revision 2.142  2016/10/01 01:37:36  vsnyder
! Make QTM_Tree component of HGrid_t allocatable
!
! Revision 2.141  2016/09/14 20:11:42  vsnyder
! Move writing QTM to QTM_Output module
!
! Revision 2.140  2016/09/03 00:06:01  vsnyder
! Turn off some debug printing
!
! Revision 2.139  2016/09/02 00:48:08  vsnyder
! Use Inclination field of explicit HGrid to compute latitude from phi.
! Simplify method of filling fields of explicit HGrid.  Verify that fields
! of explicit HGrid have the same sizes.  Use Phi_To_Lat_Deg from Geometry.
!
! Revision 2.138  2016/08/23 00:43:34  vsnyder
! Components within or adjacent to the polygon are now within the QTM_Tree_t
! structure instead of the HGrid_t structure.
!
! Revision 2.137  2016/08/17 00:47:52  vsnyder
! Allow QTM resolution to be defined by level, length along meridian, or
! degrees along meridian.  Don't get the instrument module name in
! ComputeAllHGridOffsets unless verbose is set.
!
! Revision 2.136  2016/08/09 21:12:50  pwagner
! Survives encounter with non-satellite data
!
! Revision 2.135  2016/07/28 02:02:26  vsnyder
! Removed unreferenceed USE
!
! Revision 2.134  2016/07/28 01:45:07  vsnyder
! Refactor dump and diff
!
! Revision 2.133  2016/07/27 23:02:20  pwagner
! Works better with Aircraft-borne instrument data
!
! Revision 2.132  2016/07/22 20:04:46  pwagner
! Permit using hdf4 l1b files
!
! Revision 2.131  2016/07/21 20:55:09  pwagner
! Deal smootly when items missing from l1b file
!
! Revision 2.130  2016/05/18 01:37:30  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.129  2016/02/26 02:07:18  vsnyder
! Add QTM support
!
! Revision 2.128  2016/02/12 20:10:53  pwagner
! Better error checking, more complete DestroyHGridGeoLocations
!
! Revision 2.127  2015/10/14 23:23:01  pwagner
! Warn instead of crashing if no profiles in chunk; housekeeping
!
! Revision 2.126  2015/07/14 23:34:22  pwagner
! May easily debug cases when gaps in counterMAF
!
! Revision 2.125  2015/06/19 21:12:44  pwagner
! Sped up Computing HGrid offsets
!
! Revision 2.124  2015/06/03 23:10:51  pwagner
! Prevent certain crashes
!
! Revision 2.123  2015/05/05 16:45:13  pwagner
! Merged changes in branch v4.21
!
! Revision 2.122  2015/04/29 01:16:34  vsnyder
! Cosmetic changes
!
! Revision 2.121  2015/03/28 02:45:56  vsnyder
! Get IsMonotonic from Monotone instead of MLSFillValues.  Save HGrid type.
!
! Revision 2.120  2015/03/10 23:40:18  pwagner
! Revert maf component of HGrid to being relative, not absolute
!
! Revision 2.119  2015/03/10 00:20:53  pwagner
! Many diagnostics added; HGrid%maf now stores absolute maf
!
! Revision 2.118  2014/09/05 01:02:36  vsnyder
! More complete and accurate allocate/deallocate size tracking.
! Add some tracing.  Correct some names to be reported to Allocate_Test.
! Plug a potential memory leak.
!
! Revision 2.117  2014/09/05 00:49:06  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.116  2014/08/06 23:30:29  vsnyder
! Remove CoordIndex, which is set but not referenced
!
! Revision 2.115  2014/08/01 01:45:52  vsnyder
! Remove unreferenced USE names
!
! Revision 2.114  2014/04/24 23:56:43  pwagner
! May set master coordinate in hGrid specification
!
! Revision 2.113  2014/03/18 17:15:09  pwagner
! Can get leapseconds from dates module if run sans toolkit
!
! Revision 2.112  2014/03/01 03:10:56  vsnyder
! Move units checking to init_tables_module
!
! Revision 2.111  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.110  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.109  2013/10/01 22:17:51  pwagner
! Added maf component to HGrid_T
!
! Revision 2.108  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.107  2013/08/30 02:45:41  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.106  2013/08/21 00:25:04  pwagner
! Removed a debugging remnant dumped when overriding geolocations
!
! Revision 2.105  2013/08/17 00:20:25  pwagner
! Fixed HGrids may have geolocations overridden
!
! Revision 2.104  2013/08/13 01:27:42  vsnyder
! Get kind type parameters from MLSKinds instead of MLSCommon
!
! Revision 2.103  2013/08/13 00:58:54  vsnyder
! Move SolveQuadratic into MLSNumerics
!
! Revision 2.102  2013/06/12 02:37:14  vsnyder
! Cruft removal
!
! Revision 2.101  2012/04/25 20:32:24  pwagner
! Inserting missing profiles after chunk end now an option controlled by 'extendible' field
!
! Revision 2.100  2012/04/20 01:09:22  pwagner
! Regular HGrids no longer drop profiles between chunks
!
! Revision 2.99  2011/06/29 21:54:26  pwagner
! Some cases may safely omit l1b files
!
! Revision 2.98  2011/03/10 21:39:11  pwagner
! May now specify time in explicit hGrids
!
! Revision 2.97  2010/03/23 23:26:03  honghanh
! Add a case where single option is not set, but hgrid%noProfs is 1
! then set overlap fields to 0.
!
! Revision 2.96  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.95  2009/06/16 17:42:16  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.94  2009/05/13 20:41:55  vsnyder
! Get constants from Constants, kinds from MLSKinds
!
! Revision 2.93  2008/12/02 23:29:41  pwagner
! Added print to not_used_here
!
! Revision 2.92  2007/10/02 22:40:51  vsnyder
! Increase trace level for CreateHGridFromMLSCFInfo
!
! Revision 2.91  2007/06/21 00:54:07  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.90  2006/07/12 20:42:30  pwagner
! 0 profiles in an HGrid will stop unless computing offsets
!
! Revision 2.89  2006/06/29 21:56:25  pwagner
! Some debugging stuff removed from routine processing
!
! Revision 2.88  2006/05/31 17:48:49  pwagner
! Another bug fix relating to extra profiles
!
! Revision 2.87  2006/04/19 20:48:13  pwagner
! Undid most of the changes regarding extra MAFs; perhaps fixed bugs
!
! Revision 2.86  2006/04/11 23:33:51  pwagner
! Fixed bug which added excess profiles
!
! Revision 2.85  2006/03/07 23:23:28  vsnyder
! Crash gently if there's bo L1BOA file
!
! Revision 2.84  2006/02/21 19:11:30  pwagner
! Some tweaks to where, when to dump
!
! Revision 2.83  2006/02/07 00:56:26  pwagner
! Now allows overlaps after data end time
!
! Revision 2.82  2006/01/10 23:52:11  pwagner
! Fixed segment fault when hdf4 l1boa file
!
! Revision 2.81  2005/12/16 00:07:12  pwagner
! Changes to reflect new MLSFillValues module
!
! Revision 2.80  2005/12/14 01:55:33  pwagner
! Inadvertantly omitted some of the statements from r2.78
!
! Revision 2.79  2005/12/14 01:43:33  pwagner
! Now stores local apparent solar time
!
! Revision 2.78  2005/12/13 22:15:30  livesey
! New approach to the single option in regular hGrids.  Now it uses
! exactly the same approach to that chosen by forward models when
! phiWindow=0 to allow for useful truth in truth out 1D tests.
!
! Revision 2.77  2005/12/13 21:26:02  livesey
! Minor buglet fix for single case in regular hGrid construction.
!
! Revision 2.76  2005/11/15 00:20:18  pwagner
! Should catch error arising from chunks with bad data
!
! Revision 2.75  2005/11/04 18:52:36  pwagner
! Added warning, correction if mif1GeodAngle non-monotonic
!
! Revision 2.74  2005/10/22 00:49:26  pwagner
! Should throw error when l1boa file not in filedatabase
!
! Revision 2.73  2005/10/19 00:06:09  pwagner
! Fixed bug causing DealWithObstructions to corrupt HGrid
!
! Revision 2.72  2005/09/21 23:19:47  pwagner
! Added DealWithObstructions
!
! Revision 2.71  2005/09/14 00:12:33  pwagner
! Uses ChunkDivideConfig%allowPriorOverlaps in calculating offsets
!
! Revision 2.70  2005/08/31 19:41:16  livesey
! Added option to suppress the geometry dump in that first run through
! generating the HGrids that is done by tree walker to assess where each
! direct write places stuff in the output files.
!
! Revision 2.69  2005/06/22 18:57:01  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.68  2005/05/31 17:51:17  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.67  2004/12/27 23:05:47  vsnyder
! Remove unreferenced use names
!
! Revision 2.66  2004/08/20 17:58:42  livesey
! Made dontpad=true on most calls.
!
! Revision 2.65  2004/08/16 17:10:26  pwagner
! Passes dontPad option to readL1BData
!
! Revision 2.64  2004/08/05 20:04:48  livesey
! Changed some spline interpolations to linear to allow for more
! stability.
!
! Revision 2.63  2004/07/30 00:16:36  livesey
! Minor update in the 'single' option.
!
! Revision 2.62  2004/06/14 20:00:36  livesey
! A bit more helpful information in dumping and geometry dumping
!
! Revision 2.61  2004/05/19 19:16:10  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.60  2004/03/24 17:55:19  livesey
! Just tidying up after myself
!
! Revision 2.59  2004/03/24 01:30:16  livesey
! Bug fix in hGrid%time
!
! Revision 2.58  2004/03/24 01:03:23  livesey
! Added date option to explicit hGrid
!
! Revision 2.57  2003/08/28 23:52:36  livesey
! Bug fix for computing total size of hGrid, and tidied up the geometry
! dumper.
!
! Revision 2.56  2003/08/11 20:55:20  livesey
! Changed 0 profiles error to warning
!
! Revision 2.55  2003/08/11 18:08:27  livesey
! Added the single option for regular hGrids
!
! Revision 2.54  2003/06/25 22:27:02  livesey
! Fixed an undefined variable
!
! Revision 2.53  2003/06/25 22:05:31  vsnyder
! Don't run off the end of the tree if there's no output section
!
! Revision 2.52  2003/06/24 23:30:30  livesey
! Got ComputeAllHGridOffsets working (on the surface at least)
!
! Revision 2.51  2003/06/20 19:37:06  pwagner
! Quanities now share grids stored separately in databses
!
! Revision 2.50  2003/05/11 01:43:17  livesey
! Made the hgrid switch a little less voluable
!
! Revision 2.49  2003/05/05 23:00:34  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.48  2003/03/07 00:41:24  pwagner
! DeeBug is turned on by switch
!
! Revision 2.47  2003/02/13 19:05:39  vsnyder
! Move USEs from module to procedure scope, cosmetic changes
!
! Revision 2.46.2.2  2003/03/06 19:26:17  vsnyder
! Delete unreferenced USEd name, show hGrid's label on debugging output
!
! Revision 2.46.2.1  2003/02/13 20:36:06  livesey
! Changes merged in from HEAD
!
! Revision 2.47  2003/02/13 19:05:39  vsnyder
! Move USEs from module to procedure scope, cosmetic changes
!
! Revision 2.46  2003/02/07 00:41:32  livesey
! Bug fix (or at least workaround)
!
! Revision 2.45  2003/02/06 23:30:50  livesey
! New approach for explicit hGrids
!
! Revision 2.44  2003/01/06 20:13:46  livesey
! New handling of overlaps
!
! Revision 2.43  2002/12/11 22:17:05  pwagner
! Added error checks on hdf version
!
! Revision 2.42  2002/12/06 01:07:54  pwagner
! A lot of extra debugging output possible
!
! Revision 2.41  2002/12/05 02:21:08  livesey
! Cosmetic changes
!
! Revision 2.40  2002/11/22 12:20:42  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.39  2002/11/13 01:07:04  pwagner
! Actually reads hdf5 radiances
!
! Revision 2.38  2002/10/08 17:36:20  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.37  2002/09/11 17:40:38  livesey
! Bug fix
!
! Revision 2.36  2002/08/09 16:56:37  livesey
! Modified the edge handling to avoid having 'orphaned' profiles beyond
! the edges of the scan range.
!
! Revision 2.35  2002/08/04 16:03:33  mjf
! Added some nullify statements for Sun's rubbish compiler.
!
! Revision 2.34  2002/08/01 17:19:56  livesey
! Flipped geometry dump over the right way.
!
! Revision 2.33  2002/07/17 06:02:50  livesey
! More conservative settings
!
! Revision 2.32  2002/07/01 23:57:06  livesey
! Explicit HGrids now inherit the processing start time as their time.
!
! Revision 2.31  2002/07/01 23:42:42  vsnyder
! Plug a memory leak
!
! Revision 2.30  2002/06/29 06:11:36  livesey
! Typo!
!
! Revision 2.29  2002/06/29 05:55:19  livesey
! Added the geom diagnostic
!
! Revision 2.28  2002/06/18 22:41:26  livesey
! More fixes to do with nasty aspects of regular hGrids on day boundaries
!
! Revision 2.27  2002/05/24 20:56:53  livesey
! Some fixes for cases where the chunk is only 1 MAF long
!
! Revision 2.26  2002/05/24 16:47:39  livesey
! Added some diagnostics
!
! Revision 2.25  2002/05/06 22:31:28  livesey
! Fixed nullify stuff
!
! Revision 2.24  2002/05/06 21:59:28  livesey
! Fixed get_Boolean bug
!
! Revision 2.23  2002/05/06 21:37:40  livesey
! Added forbidOverspill option
!
! Revision 2.22  2001/12/16 00:58:24  livesey
! Working version. Deals with first and last chunks in day properly.
!
! Revision 2.21  2001/12/14 01:43:02  livesey
! Various bug fixes
!
! Revision 2.20  2001/12/10 20:21:36  livesey
! Added code for regular HGrids
!
! Revision 2.19  2001/07/09 20:15:07  livesey
! Fixed an embarassing memory leak I thought I caught before. Also
! changed some allocatables to pointers to let us use Allocate_Deallocate
!
! Revision 2.18  2001/07/06 21:33:23  dwu
! forgot to deallocate variables
!
! Revision 2.17  2001/07/06 18:48:16  dwu
! Add codes to make interpolationFactor functioning
!
! Revision 2.16  2001/05/30 23:53:15  livesey
! For new version of L1BData
!
! Revision 2.15  2001/05/12 00:17:24  livesey
! Brief tidy up of constructing from l2gp.  Tree walker currently prevents
! this however.
!
! Revision 2.14  2001/05/03 20:32:19  vsnyder
! Cosmetic changes
!
! Revision 2.13  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.12  2001/04/24 22:21:05  livesey
! Gave up on latitude stuff
!
! Revision 2.11  2001/04/23 23:25:26  livesey
! Changed l2gpDatabase to pointer
!
! Revision 2.10  2001/04/21 01:24:55  livesey
! New version, tidied up, can create hGrid from L2GP now
!
! Revision 2.9  2001/04/20 23:11:48  livesey
! Added explicit functionality
!
! Revision 2.8  2001/03/02 01:27:06  livesey
! For new MLSSignals
!
! Revision 2.7  2001/02/22 23:44:29  livesey
! Typo
!
! Revision 2.6  2001/02/22 23:43:26  livesey
! Nullified pointer elements of HGrid_T
!
! Revision 2.5  2001/02/21 01:09:24  livesey
! Tidied stuff up a bit
!
! Revision 2.4  2001/02/09 19:30:16  vsnyder
! Move checking for required and duplicate fields to init_tables_module
!
! Revision 2.3  2001/02/09 00:38:22  livesey
! Various updates
!
! Revision 2.2  2001/02/08 01:50:11  vsnyder
! Move duplicate field checking to tree_checker, set by init_tables
!
! Revision 2.1  2000/12/04 23:34:38  vsnyder
! Move more of addItemToDatabase into the include.
!
! Revision 2.0  2000/09/11 19:18:01  ahanzel
! Changing revision to 2.0.
!
! Revision 1.1  2000/09/07 17:36:29  vsnyder
! Initial version 2.0
!
! Revision 1.9  2000/05/17 23:33:51  lungu
! Added dots between MLSInstrumentModuleName and l1bItemName so that is consistent with L1BOA file.
! Added check "if ( ASSOCIATED(database))deallocate(database)" so it doesn't chrash trying to dealocate
! an "empty" database.
!
! Revision 1.8  2000/05/17 18:15:23  livesey
! Finished off interaction with l2cf.
!

@


2.159
log
@Skipped some unneeded output
@
text
@d1365 1
a1365 1
    if ( any(isFillValue(FullArray2d) ) ) then
d1368 1
a1368 1
    if ( any(isFillValue(GeodAngle2d) ) ) then
d2803 1
a2803 1
       "$Id: HGrid.f90,v 2.158 2021/11/18 18:11:28 pwagner Exp $"
d2815 3
@


2.158
log
@Re-Trim regular HGrid to remove unwanted stubby overlap
@
text
@d1348 2
a1349 1
      call output('(unknown)' )
d2245 1
d2250 1
d2803 1
a2803 1
       "$Id: HGrid.f90,v 2.157 2021/11/03 23:47:58 pwagner Exp $"
d2815 3
@


2.157
log
@maxLowerOverlap and -Upper many now be negative, meaning to trim away profiles from either end
@
text
@d1259 1
d1261 2
a1262 2
    use Output_M, only: Output
    use String_Table, only: Display_String
d1308 1
d1323 1
d1334 1
d1341 8
d1781 4
d1797 10
d2800 1
a2800 1
       "$Id: HGrid.f90,v 2.156 2019/11/22 00:38:43 pwagner Exp $"
d2812 3
@


2.156
log
@Be less prone to printing lots; show which chunks have no profiles
@
text
@d207 2
a208 2
    maxLowerOverlap = -1
    maxUpperOverlap = -1
d1251 3
a1253 2
    use HGridsDatabase, only: CreateEmptyHGrid, HGrid_T, TrimHGrid, FindClosestMatch
    use HighOutput, only: LetsDebug, OutputNamedValue
d1330 1
a1330 1
    verbose = deebughere
d1336 1
d1360 1
a1360 1
    if ( verbose ) then
d1387 1
a1387 1
    if ( verbose ) then
d1393 1
a1393 1
      if ( verbose ) then
d1748 1
a1748 1
       if ( verbose ) call outputNamedValue( 'left, right', (/ left, right /) )
d1755 1
a1755 1
          call outputNamedValue( 'Lower overlap too big', hGrid%noProfs )
d1760 1
a1760 1
          call outputNamedValue( 'Upper overlap too big', hGrid%noProfs )
d1763 14
d2774 1
a2774 1
       "$Id: HGrid.f90,v 2.155 2019/11/14 22:28:32 pwagner Exp $"
d2786 3
@


2.155
log
@Now requires more coaxing to trace sectionLoop in ComputeAllHGridOffsets
@
text
@d20 1
d165 1
a165 1
      & cond=toggle(gen) .and. ( levels(gen) > 1 .or. .not. computingOffsets ) )
d476 1
a476 1
      & cond=toggle(gen) .and. ( levels(gen) > 1 .or. .not. computingOffsets ) )
d546 1
a546 1
    verbose = BeVerbose( 'hgrid', -1 ) .or. .true.
d2105 1
a2112 1
    ! integer, parameter :: MAXNUMChunks = 400
d2127 1
d2425 8
d2758 1
a2758 1
       "$Id: HGrid.f90,v 2.154 2019/07/09 22:26:19 pwagner Exp $"
d2770 3
@


2.154
log
@Reduce unwanted Checks ForCorruptFileDatabase
@
text
@d2121 1
d2130 1
d2133 1
d2167 1
a2167 1
          & cond=toggle(gen) .and. levels(gen) > 1 )
d2271 1
a2271 1
          & cond=toggle(gen) .and. levels(gen) > 1 )
d2748 1
a2748 1
       "$Id: HGrid.f90,v 2.153 2018/08/06 20:24:15 pwagner Exp $"
d2760 3
@


2.153
log
@Dont exit section loop in ComputeAllHGridOffsets w/o trace_end
@
text
@d720 1
a720 1
    integer ::  status
d1035 3
a1037 3
    use L1bData, only: L1bData_T, ReadL1BData, GetL1BFile, Namelen, &
      & AssembleL1Bqtyname, Precisionsuffix, DeallocateL1BData, Dump
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
a1319 7
    real(rk) :: A
    real(rk) :: B
    real(rk) :: C
    real(rk) :: ImPart
    real(rk) :: R1
    real(rk) :: R2

d1330 1
a1330 1
      verbose = .not. onlyComputingOffsets
a1468 1
    ! call DeallocateL1BData ( l1bField )
a1557 1
    ! call DeallocateL1BData ( l1bField )
d2086 1
a2086 1
    use Output_M, only: Blanks, Output, RevertOutput, SwitchOutput
d2129 2
d2141 1
a2141 1
    if ( deebug ) then
d2193 1
a2193 1
              if ( chunk == 1 .and. deebug ) then
d2199 1
a2199 1
                & check=(chunk == 1) .and. deebug )
d2201 1
a2201 1
              if ( chunk == 1 .and. deebug ) then
d2229 1
a2229 1
                if ( deebug ) then
d2244 6
d2289 1
a2289 1
        if ( deebug ) then
d2297 1
a2297 1
      elseif ( chunk < 10 .and. deebug ) then
d2421 1
d2428 1
d2530 1
a2530 1
     use Machine, only: Crash_Burn
d2745 1
a2745 1
       "$Id: HGrid.f90,v 2.152 2018/08/03 23:45:43 vsnyder Exp $"
d2757 3
@


2.152
log
@Add tracing to several routines.  Improve some debugging output.  Add
NeverFail=.true. to L1BGeolcation calls in verbose case to prevent crashing
if irrelevant stuff is attempted to be found.
@
text
@d2265 1
a2265 1
          exit sectionLoop
d2744 1
a2744 1
       "$Id: HGrid.f90,v 2.151 2018/04/19 00:49:06 vsnyder Exp $"
d2756 5
@


2.151
log
@Remove USE statements for unused names
@
text
@d2097 1
a2097 1
    use Toggles, only: Gen, Toggle
d2170 2
d2268 2
d2272 3
a2274 3
        call outputNamedValue( 'number of keys', nkeys )
        call outputNamedValue( 'number of sections', nsections )
        call Dump ( keyArray, 'keys', width=5 )
d2295 1
a2295 1
        call outputnamedValue ( 'nkeys, noHGrids', (/ nkeys, noHGrids /) )
d2313 1
a2313 2
        call output ( chunk )
        call blanks ( 3 )
d2316 5
a2320 2
        sum2 = sum2 + chunks(chunk)%hGridOffsets(2)
        sum3 = sum3 + chunks(chunk)%hGridOffsets(3)
d2326 1
a2326 1
    ! of non-overlap profiles each chunk/hGrid.  After this it will contain
d2329 2
a2330 1
    if ( verbose ) call output( (/ 1, chunks(1)%hGridOffsets(1) /), advance='yes' )
d2334 4
a2337 1
      if ( verbose ) call output( (/ chunk, chunks(chunk)%hGridOffsets(1) /), advance='yes' )
d2371 1
a2371 2
        call output ( chunk )
        call blanks ( 3 )
d2373 1
a2373 1
        call blanks ( 3 )
d2385 9
a2393 9
      call L1BGeoLocation ( filedatabase, 'MAFStartTimeTAI  ', instrumentModuleName,  MAFStartTimeTAI )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAngle    ', instrumentModuleName,  GeodAngle )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAlt      ', instrumentModuleName,  GeodAlt )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodLat      ', instrumentModuleName,  GeodLat )
      call L1BGeoLocation ( filedatabase, 'GHz/Lon          ', instrumentModuleName,  Lon )
      call L1BGeoLocation ( filedatabase, 'GHz/LosAngle     ', instrumentModuleName,  LosAngle )
      ! call L1BGeoLocation ( filedatabase, 'sc/OrbIncl       ', instrumentModuleName,  OrbIncl )
      call L1BGeoLocation ( filedatabase, 'GHz/SolarTime    ', instrumentModuleName,  SolarTime )
      call L1BGeoLocation ( filedatabase, 'GHz/SolarZenith  ', instrumentModuleName,  SolarZenith )
d2397 1
a2397 1
        call outputnamedValue( 'chunk', chunk )
d2401 7
a2407 4
          call CompareWithChunk( chunks(chunk), &
            & chunks(min(size ( chunks ), chunk+1)), firstHGrid(chunk), &
            & MAFStartTimeTAI, GeodAngle, GeodAlt, GeodLat, SolarTime )
        endif
d2744 1
a2744 1
       "$Id: HGrid.f90,v 2.150 2018/04/16 22:20:21 pwagner Exp $"
d2756 3
@


2.150
log
@More thorough CamelCase in use statements
@
text
@d2513 1
a2513 1
     use Chunks_M, only: MLSChunk_T, Dump
d2520 1
d2550 1
a2550 1
    ! call crash_burn
d2732 1
a2732 1
       "$Id: HGrid.f90,v 2.149 2018/03/02 00:58:17 pwagner Exp $"
d2744 3
@


2.149
log
@Reduce non-debug printing
@
text
@d18 1
a18 1
  use MLSCommon, only: MLSFile_t, nameLen, TAI93_Range_t
d20 2
a21 2
  use MLSKinds, only: rk => r8, r8
  use MLSSignals_m, only: GetModuleName
d25 2
a26 2
  public :: createHGridfromMLSCFInfo, computeNextChunksHGridOffsets, &
    & computeAllHGridOffsets, dealWithObstructions, DestroyHGridGeoLocations
d64 2
a65 2
    use Allocate_deallocate, only: Deallocate_test
    use Chunks_m, only: MLSChunk_t
d67 14
a80 14
    use Dates_module, only: tai93s2hid
    use Expr_m, only: expr
    use HGridsDatabase, only: HGrid_t, createEmptyHGrid, nullifyHGrid
    use HighOutput, only: beVerbose, letsDebug, outputNamedValue
    use Init_tables_module, only: f_coordinate, f_date, &
      & f_extendible, f_forbidoverspill, f_fraction, f_geodangle, f_geodlat, &
      & f_height, f_inclination, f_insetoverlaps, f_interpolationfactor, &
      & f_lon, f_losangle, f_maxloweroverlap, f_maxupperoverlap, f_mif, &
      & f_module, f_origin, f_QTMlevel, &
      & f_single, f_solartime, f_solarzenith, f_sourcel2gp, f_spacing, &
      & f_time, f_type, &
      & field_first, field_last, &
      & l_explicit, l_fixed, l_fractional, l_height, &
      & l_l2gp, l_QTM, l_regular
d83 1
a83 1
    use L2GPData, only: L2GPData_t
d85 1
a85 1
    use MLSL2options, only: need_L1Bfiles
d87 2
a88 2
    use MLSNumerics, only: hunt
    use MLSStringLists, only: switchDetail
d91 8
a98 8
    use Output_m, only: Output
    use Polygon_m, only: Polygon_Inside, Polygon_Vertices
    use QTM_m, only: QTM_Depth ! Maximum depth that will fit in one integer
!     use string_table, only: get_string
    use Time_m, only: SayTime, time_now
    use Toggles, only: gen, levels, switches, toggle
    use Trace_m, only: trace_begin, trace_end
    use Tree, only: Decoration, NSons, Sub_rosa, Subtree, Where
d483 1
a483 1
    use Dates_module, only: UTC2TAI93s
d485 1
a485 1
    use Expr_m, only: expr
d488 3
a490 3
    use Global_settings, only: LeapSecFilename
    use HgridsDatabase, only: CreateEmptyHGrid, HGrid_t
    use MLSKinds, only: rk => r8
d493 3
a495 3
    use String_table, only: Get_String
    use Toggles, only: gen, levels, toggle
    use Trace_m, only: Trace_Begin, Trace_End
d650 10
a659 10
    use allocate_deallocate, only: allocate_test, deallocate_test
    use chunks_m, only: MLSCHunk_t
    use dump_0, only: dump
    use HGridsdatabase, only: createEmptyHGrid, Dump, HGrid_t, trimHGrid
    use highOutput, only: letsDebug, outputNamedValue
    use init_tables_module, only: f_fraction, f_geodangle, f_geodlat, f_height, &
      & f_lon, f_losangle, f_mif, f_time, &
      & f_solartime, f_solarzenith, l_fixed, l_fractional, l_height, l_mif
    use L1BData, only: deallocateL1BData, L1BData_t, readL1BData, &
      & assembleL1BQtyName, CheckForCorruptFileDatabase
d661 1
a661 1
    use MLSKinds, only: rk => r8
d664 3
a666 3
    use MLSNumerics, only: hunt, interpolateValues
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
d1028 3
a1030 3
    use Generate_QTM_m, only: Generate_QTM
    use Geolocation_0, only: H_t
    use HGridsdatabase, only: CreateEmptyHGrid
d1034 3
a1036 3
    use Output_m, only: Output
    use l1bdata, only: l1bdata_t, readl1bdata, getl1bfile, namelen, &
      & assemblel1bqtyname, precisionsuffix, deallocatel1bdata, dump
d1243 3
a1245 3
    use Allocate_deallocate, only: allocate_test, deallocate_test
    use ChunkDivide_m, only: chunkDivideConfig
    use Chunks_m, only: MLSChunk_t, dump
d1250 1
a1250 1
    use HGridsDatabase, only: CreateEmptyHGrid, HGrid_t, trimHGrid, FindClosestMatch
d1252 2
a1253 2
    use MLSFillvalues, only: IsFillValue, Monotonize
    use MLSKinds, only: rk => r8
d1255 2
a1256 2
    use MLSNumerics, only: hunt, interpolateValues
    use MLSStringLists, only: switchDetail
d1258 1
a1258 1
    use Output_m, only: Output
d1261 1
a1261 1
    use Trace_m, only: Trace_Begin, Trace_End
d1804 4
a1807 4
    use allocate_deallocate, only: allocate_test, deallocate_test
    use chunkdivide_m, only: obstruction_t
    use hgridsdatabase, only: hgrid_t, createemptyhgrid, destroyhgridcontents
    use highOutput, only: letsDebug
d1809 2
a1810 2
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
d1903 1
a1903 1
    use allocate_deallocate, only: deallocate_test
d1919 7
a1925 7
    use chunks_m, only: mlschunk_t
    use hgridsdatabase, only: hgrid_t
    use L1BData, only: deallocateL1BData, L1BData_t, readL1BData, &
      & assemblel1bqtyname
    use MLSKinds, only: r8
    use output_m, only: output
    use string_table, only: display_string
d2080 7
a2086 7
    use Allocate_deallocate, only: allocate_test, deallocate_test
    use Chunks_m, only: MLSChunk_t
    use ChunkDivide_m, only: chunkDivideConfig
    use Dump_0, only: dump
    use HGridsDatabase, only: HGrid_t, copyHGrid, destroyHGridContents, Dump
    use HighOutput, only: beVerbose, letsDebug, outputNamedValue
    use Init_tables_module, only: z_construct, s_hgrid, z_output
d2088 4
a2091 4
    use L2GPData, only: L2GPData_t
    use MLSKinds, only: rk => r8
    use MLSL2Options, only: specialDumpFile
    use Moretree, only: get_spec_id
d2093 1
a2093 1
    use Next_Tree_Node_m, only: Init_Next_Tree_Node, Next_Tree_Node, &
d2095 6
a2100 6
    use Output_m, only: blanks, output, revertOutput, switchOutput
    use time_m, only: SayTime, time_now
    use Toggles, only: gen, toggle
    use Trace_m, only: trace_begin, trace_end
    use Tree, only: subtree, node_id, decoration
    use Tree_types, only: n_named
d2474 3
a2476 3
    use lexer_core, only: print_source
    use output_m, only: output
    use tree, only: where_at => where
d2513 7
a2519 7
    use chunks_m, only: MLSChunk_t, Dump
    use dates_module, only: gethid
    use HGridsDatabase, only: HGrid_T
    use highOutput, only: blanksToColumn, outputNamedValue
    use machine, only: crash_burn
    use MLSKinds, only: rk => r8
    use output_m, only: blanks, newLine, output
d2694 1
a2694 1
    use mlsmessagemodule, only: mlsmessage, mlsmsg_error
d2714 2
a2715 2
    use Output_m, only: blanks, output
    use time_m, only: time_now
d2731 1
a2731 1
       "$Id: HGrid.f90,v 2.148 2018/02/23 22:20:51 mmadatya Exp $"
d2743 3
@


2.148
log
@Updates for Create_QTM_HGrid for ASMLS
@
text
@d274 4
a277 2
        call output('insrumentModuleName in the case f_module is ' )
        call output(instrumentModuleName, advance='yes')
d2731 1
a2731 1
       "$Id: HGrid.f90,v 2.147 2018/01/03 01:17:56 pwagner Exp $"
d2743 3
@


2.147
log
@Removed disused solving of a quadratic equation
@
text
@d20 1
a20 1
  use MLSKinds, only: rk => r8
d274 2
d392 4
a395 2
        call create_QTM_hgrid ( polygon_inside, polygon_vertices, QTM_level, &
          & hGrid )
d1013 1
a1013 1
  subroutine Create_QTM_HGrid ( Polygon_Inside, Polygon_Vertices, Level, HGrid )
d1032 7
a1038 1

d1043 1
d1046 97
a1142 1

d1173 45
d2729 1
a2729 1
       "$Id: HGrid.f90,v 2.146 2016/11/04 19:36:24 pwagner Exp $"
d2741 3
@


2.146
log
@begin transition to sayTime from time_m
@
text
@d1101 1
a1101 1
    use MLSNumerics, only: hunt, interpolateValues, solveQuadratic
d1178 3
a1180 1
    warnIfNoProfs = single ! .false.
a1187 14
    if ( deebughere .and. .false.) then
      print *, 'Checking quadratic solution'
      do i=1, 10
        a = 0.25
        b = i - 5
        c = 3
        print *, 'a, b, c: ', a, b, c
        print *, 'b^2 - 4 a c ', b**2 - 4*a*c
        call SolveQuadratic( a, b, c, &
              & r1, r2, imPart )
        print *, 'r1, r2, ImPart: ', r1, r2, imPart
      end do
      stop
    end if
d2577 1
a2577 1
       "$Id: HGrid.f90,v 2.145 2016/10/19 00:31:18 pwagner Exp $"
d2589 3
@


2.145
log
@Trying to avoid certain crashes; may be signs of deeper problems
@
text
@d95 1
a95 1
    use Time_m, only: time_now
d1954 1
a1954 1
    use time_m, only: time_now
d2571 1
a2571 1
  subroutine SayTime ( What )
d2583 1
a2583 1
  end subroutine SayTime
d2589 1
a2589 1
       "$Id: HGrid.f90,v 2.144 2016/10/14 00:04:28 pwagner Exp $"
d2601 3
@


2.144
log
@Avoid negative hGridOffsets
@
text
@d426 1
d429 1
d431 1
a469 1

d2228 3
a2230 1
      call GetModuleName ( instrumentModule, instrumentModuleName )
d2240 1
a2240 1
      call L1BGeoLocation ( filedatabase, 'sc/OrbIncl       ', instrumentModuleName,  OrbIncl )
d2256 1
a2256 1
      call deAllocate_Test ( OrbIncl        , 'OrbIncl        ', ModuleName )
d2444 1
d2589 1
a2589 1
       "$Id: HGrid.f90,v 2.143 2016/10/01 01:53:28 vsnyder Exp $"
d2601 3
@


2.143
log
@Fill hGrid fields after creating QTM
@
text
@d2075 1
d2106 3
d2367 1
a2367 1
    use chunks_m, only: mlschunk_t
d2371 1
d2403 1
a2403 1
    
d2421 3
d2584 1
a2584 1
       "$Id: HGrid.f90,v 2.142 2016/10/01 01:37:36 vsnyder Exp $"
d2596 3
@


2.142
log
@Make QTM_Tree component of HGrid_t allocatable
@
text
@d1051 13
d2576 1
a2576 1
       "$Id: HGrid.f90,v 2.141 2016/09/14 20:11:42 vsnyder Exp $"
d2588 3
@


2.141
log
@Move writing QTM to QTM_Output module
@
text
@d1034 3
a1036 2
    hGrid%noProfs = hGrid%QTM_tree%n_in !!!!!????? or maybe zero ?????
    call CreateEmptyHGrid(hGrid)
d1048 3
d2563 1
a2563 1
       "$Id: HGrid.f90,v 2.140 2016/09/03 00:06:01 vsnyder Exp $"
d2575 3
@


2.140
log
@Turn off some debug printing
@
text
@d166 2
d414 18
a431 16
    endif
    ! Find nearest maf based on time
    if ( L1BFile%hdfVersion /= HDFVERSION_5 ) then
    elseif ( .not. IsHDF5DSInFile ( L1BFile%name, "MAFStartTimeTAI" ) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName // '/' &
        & // 'CreateHGridFromMLSCFInfo', &
        & "MAFStartTimeTAI not found in l1b file" )
      call trace_end ( "CreateHGridFromMLSCFInfo", &
        & cond=toggle(gen) .and. ( levels(gen) > 1 .or. .not. computingOffsets ) )
      return
    endif
    call L1BGeoLocation ( filedatabase, "MAFStartTimeTAI", &
        & instrumentModuleName, fullArray )
    call L1BSubsample ( chunk, fullArray, values=TAI )
    call Hunt ( TAI, hgrid%time(1,:), hgrid%maf, &
      & allowTopValue=.true. )
d445 1
a445 1
    endif
d449 7
a455 5
    call Deallocate_test ( fullArray, 'fullArray', ModuleName )
    call Deallocate_test ( TAI, 'TAI', ModuleName )
    if ( switchDetail(switches, 'geom') >= 0 .and. .not. mySuppressGeometryDump ) &
      & call DumpChunkHGridGeometry ( hGrid, chunk, &
      & trim(instrumentModuleName), filedatabase )
d459 1
a459 1
    endif
a481 1
    use Init_tables_module, only: phyq_angle, phyq_dimensionless, phyq_time
a512 1
    integer :: UNITS                    ! Units
d1019 1
a1019 1
    use allocate_deallocate, only: Test_Allocate
d1022 4
d1032 1
a1032 1
    integer :: Stat
d1034 2
d1046 7
a1052 2
    ! Explicit allocation won't be necessary when compilers support
    ! automatic allocation for assignment to allocatable arrays.
a1072 1
    use Constants, only: deg2rad, rad2deg
d1075 1
a1075 1
    use Empiricalgeometry, only: empiricalLongitude, chooseOptimumLon0
d1077 3
a1079 3
    use HGridsDatabase, only: createEmptyHGrid, HGrid_t, trimHGrid, findClosestMatch
    use highOutput, only: letsDebug, outputNamedValue
    use MLSFillvalues, only: isFillValue, Monotonize
d1085 4
a1088 4
    use output_m, only: output
    use string_table, only: display_string
    use toggles, only: gen, levels, switches, toggle
    use trace_m, only: trace_begin, trace_end
d1090 12
a1101 12
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (TAI93_Range_T), intent(in) :: PROCESSINGRANGE
    type (MLSChunk_T), intent(in) :: CHUNK
    real(rk), intent(in) :: SPACING
    real(rk), intent(in) :: ORIGIN
    character (len=*), intent(in) :: INSTRUMENTMODULENAME
    logical, intent(in) :: EXTENDIBLE
    integer, intent(in) :: MAXLOWEROVERLAP
    integer, intent(in) :: MAXUPPEROVERLAP
    logical, intent(in) :: INSETOVERLAPS
    logical, intent(in) :: SINGLE
    type (HGrid_T), intent(inout) :: HGRID ! Needs inout as name set by caller
d1105 1
a1105 1
    real(rk), dimension(:,:), pointer :: ALLGEODANGLE ! For every mif
d1107 1
a1107 1
    real(rk), parameter :: SECONDSINDAY = 24*60*60
d1110 1
a1110 1
    real(rk), parameter :: ORBITALPERIOD = 98.8418*60.0
d1112 5
a1116 5
    logical :: DEEBUGHERE
    real(rk) :: DELTA                   ! A change in angle
    integer :: EXTRA                    ! How many profiles over 1 are we
    real(rk) :: FIRST                   ! First point in of hGrid
    integer :: FIRSTPROFINRUN           ! Index of first profile in processing time
d1120 1
a1120 1
    real(rk) :: INCLINE                 ! Mean orbital inclination
d1122 5
a1126 5
    integer :: LASTPROFINRUN            ! Index of last profile in processing time
    real(rk) :: LAST                    ! Last point in hGrid
    integer :: LEFT                     ! How many profiles to delete from the LHS in single
    real(rk) :: MAXANGLE                ! Largest angle in chunk
    real(rk) :: MAXANGLEFIRSTMAF        ! Gives 'range' of first maf
d1129 2
a1130 2
    real(rk) :: MINANGLE                ! Smallest angle in chunk
    real(rk) :: MINANGLELASTMAF         ! Gives 'range' of last maf
d1132 4
a1135 4
    integer :: NOMAFS                   ! How many in chunk
    integer :: NOMIFS
    real(rk) :: NEXTANGLE               ! First non ovl. MAF for next chunk
    integer :: RIGHT                     ! How many profiles to delete from the RHS in single
d1143 7
a1149 7
    real(rk), dimension(:), pointer :: TMPANGLE ! A temporary array for the single case
    logical :: verbose
    logical :: warnIfNoProfs

    real(rk) :: a
    real(rk) :: b
    real(rk) :: c
d1151 2
a1152 2
    real(rk) :: r1
    real(rk) :: r2
d2559 1
a2559 1
       "$Id: HGrid.f90,v 2.139 2016/09/02 00:48:08 vsnyder Exp $"
d2571 3
@


2.139
log
@Use Inclination field of explicit HGrid to compute latitude from phi.
Simplify method of filling fields of explicit HGrid.  Verify that fields
of explicit HGrid have the same sizes.  Use Phi_To_Lat_Deg from Geometry.
@
text
@d1985 1
a1985 1
      if ( verbose .or. .true. ) &
d2545 1
a2545 1
       "$Id: HGrid.f90,v 2.138 2016/08/23 00:43:34 vsnyder Exp $"
d2557 5
@


2.138
log
@Components within or adjacent to the polygon are now within the QTM_Tree_t
structure instead of the HGrid_t structure.
@
text
@d20 1
a84 1
    use MLSKinds, only: rk => r8
d140 1
d199 1
d252 1
a252 1
        ! incline = expr_value(1) !??? Never used
d285 1
a285 1
        case default
d330 1
a330 1
            & solarTimeNode, solarZenithNode, lonNode, losAngleNode, &
d350 1
a350 1
        & solarTimeNode, solarZenithNode, lonNode, losAngleNode, &
d466 1
a466 1
        & solarTimeNode, solarZenithNode, lonNode, losAngleNode, &
d469 8
a476 6
    use dates_module, only: utc2tai93s
    use expr_m, only: expr
    use highOutput, only: beverbose, outputnamedvalue
    use global_settings, only: leapsecfilename
    use hgridsDatabase, only: createEmptyHGrid, HGrid_t
    use init_tables_module, only: phyq_angle, phyq_dimensionless, phyq_time
d479 5
a483 5
    use SDPToolkit, only: mls_utctotai
    use string_table, only: get_string
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: nsons, subtree
d486 1
a486 1
    integer, intent(in) :: KEY          ! Tree node
d492 1
a517 1
    integer, parameter :: NUMPARAMS = 7
d525 3
d534 10
d546 13
a558 13
    if ( geodAngleNode /= 0 ) then
      noProfs = nsons ( geodAngleNode ) - 1
    else if ( geodLatNode /= 0 ) then
      noProfs = nsons ( geodLatNode ) - 1
    else if ( solarTimeNode /= 0 ) then
      noProfs = nsons ( solarTimeNode ) - 1
    else if ( solarZenithNode /= 0 ) then
      noProfs = nsons ( solarZenithNode ) - 1
    else if ( lonNode /= 0 ) then
      noProfs = nsons ( lonNode ) - 1
    else if ( losAngleNode /= 0 ) then
      noProfs = nsons ( losAngleNode ) - 1
    end if
d596 1
a596 30
      select case ( param )
      case ( PHIPARAM )
        values => hGrid%phi
        node = geodAngleNode
        units = phyq_angle
      case ( SOLARTIMEPARAM )
        values => hGrid%solarTime
        node = solarTimeNode
        units = phyq_time
      case ( SOLARZENITHPARAM )
        values => hGrid%solarZenith
        node = solarZenithNode
        units = phyq_angle
      case ( TIMEPARAM )
        values => hGrid%Time
        node = TimeNode
        units = phyq_time
      case ( LONPARAM )
        values => hGrid%lon
        node = lonNode
        units = phyq_angle
      case ( LOSANGLEPARAM )
        values => hGrid%losAngle
        node = losAngleNode
        units = phyq_angle
      case ( GEODLATPARAM )
        values => hGrid%GeodLat
        node = geodLatNode
        units = phyq_angle
      end select
d598 16
d616 1
a616 3
          if ( all ( expr_units(1) /= (/ phyq_dimensionless, units /) ) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Invalid units for explicit hGrid' )
d621 5
a625 3
    ! Make the latitude the same as the geod angle
    ! This is a bit of a hack, but it should be OK in all cases.
    hGrid%geodLat = hGrid%phi
d1062 1
d1394 1
a1394 2
    hGrid%geodLat = rad2deg * asin ( sin( deg2Rad*hGrid%phi ) * &
      & sin ( deg2Rad*incline ) )
d2545 1
a2545 1
       "$Id: HGrid.f90,v 2.137 2016/08/17 00:47:52 vsnyder Exp $"
d2557 4
@


2.137
log
@Allow QTM resolution to be defined by level, length along meridian, or
degrees along meridian.  Don't get the instrument module name in
ComputeAllHGridOffsets unless verbose is set.
@
text
@d1031 1
a1031 1
    call generate_QTM ( hGrid%QTM_tree, hGrid%QTM_ZOT )
a1033 4
    allocate ( hGrid%QTM_geo(size(hGrid%QTM_ZOT)), stat=stat )
    call test_allocate ( stat, moduleName, "hGrid%QTM_geo", &
      & [1], [size(hGrid%QTM_ZOT)], storage_size(hGrid%QTM_geo) / 8 )
    hGrid%QTM_geo = hGrid%QTM_ZOT%ZOT_to_geo()
d2541 1
a2541 1
       "$Id: HGrid.f90,v 2.136 2016/08/09 21:12:50 pwagner Exp $"
d2553 5
@


2.136
log
@Survives encounter with non-satellite data
@
text
@d63 5
a67 4
    use allocate_deallocate, only: Deallocate_test
    use chunks_m, only: MLSChunk_t
    use dates_module, only: tai93s2hid
    use expr_m, only: expr
d69 2
a70 2
    use highOutput, only: beVerbose, letsDebug, outputNamedValue
    use init_tables_module, only: f_coordinate, f_date, &
d80 1
d89 3
a91 2
    use moretree, only: get_boolean
    use Output_m, only: output
d93 1
d95 4
a98 4
    use time_m, only: time_now
    use toggles, only: gen, levels, switches, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: decoration, nsons, sub_rosa, subtree
d275 22
a296 1
        QTM_level = nint(expr_value(1))
a2189 1
    call GetModuleName ( instrumentModule, instrumentModuleName )
d2191 1
d2545 1
a2545 1
       "$Id: HGrid.f90,v 2.135 2016/07/28 02:02:26 vsnyder Exp $"
d2557 3
@


2.135
log
@Removed unreferenceed USE
@
text
@d16 1
a16 1
  use HGridsdatabase, only: HGrid_T, HGridGeolocations, &
d18 3
a36 2
  logical, parameter     :: deeBug = .false.          
  logical, parameter     :: dontPad = .false.         
d61 1
a61 1
    & processingRange, chunk, onlyComputingOffsets ) result ( hGrid )
d79 1
a80 2
    use MLSCommon, only: MLSfile_t, namelen, tai93_range_t
    use MLSFiles, only: HDFVERSION_5, getMLSFileByType
a85 1
    use MLSSignals_m, only: GetModuleName
d106 1
d142 1
d161 1
a161 1
    deebug = LetsDebug ( 'hgrid', 1 )
d172 2
d182 4
d265 1
d306 5
d314 4
d330 2
a331 1
      call L1BGeoLocation ( filedatabase, "MAFStartTimeTAI", fullArray )
d382 4
d396 2
a397 1
    call L1BGeoLocation ( filedatabase, "MAFStartTimeTAI", fullArray )
d610 1
a610 1
    use chunks_m, only: mlschunk_t
d612 1
a612 1
    use hgridsdatabase, only: createemptyhgrid, dump, hgrid_t, trimhgrid
d618 1
a618 3
      & assembleL1BQtyName
    use MLSCommon, only: MLSFile_t, NameLen
    use MLSFiles, only: getMLSFileByType
d667 1
d679 1
d688 13
a700 2
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      hdfversion = L1BFile%HDFVersion
d774 4
d817 1
a817 1
      if ( deebug  ) then
d827 4
d834 4
d870 4
d912 4
d935 4
d964 4
d1031 1
a1031 1
    use Chunkdivide_m, only: chunkdivideconfig
d1036 2
a1037 2
    use Empiricalgeometry, only: empiricallongitude, chooseoptimumlon0
    use hgridsDatabase, only: createemptyhgrid, hgrid_t, trimhgrid, findclosestmatch
a1038 2
    use MLSCommon, only: mlsfile_t, tai93_range_t
    use MLSFiles, only: Dump, getMLSFileByType
d1042 2
a1043 2
    use MLSNumerics, only: hunt, interpolatevalues, solvequadratic
    use MLSStringlists, only: switchdetail
d1147 1
a1147 1
    call ChooseOptimumLon0 ( filedatabase, chunk )
d1152 2
a1153 1
    call L1BGeoLocation ( filedatabase, "tpGeodAngle", fullArray, FullArray2d )
d1351 2
a1352 1
    call L1BGeoLocation ( filedatabase, "scOrbIncl", fullArray )
d1374 2
a1375 1
    call L1BGeoLocation ( filedatabase, "MAFStartTimeTAI", fullArray )
d1413 2
a1414 1
    call L1BGeoLocation ( filedatabase, "tpSolarZenith", fullArray, fullArray2d )
d1434 2
a1435 1
    call L1BGeoLocation ( filedatabase, "tpLosAngle", fullArray )
a1722 2
    use MLSCommon, only: mlsfile_t, namelen
    use MLSFiles, only: getMLSFileByType
d1887 2
a1888 2
    use L2GPdata, only: l2gpdata_t
    use MLSCommon, only: mlsfile_t, tai93_range_t
d1932 2
d1948 5
a1952 1
    ! call outputNamedValue ( 'size(chunks)', size(chunks) )
d1960 1
a1960 1
      if ( verbose ) &
d1997 5
d2003 7
a2009 1
                & processingRange, chunks(chunk), onlyComputingOffsets=.true. )
d2021 1
d2033 4
d2082 4
d2090 3
d2095 2
d2165 1
d2170 9
a2178 9
      call L1BGeoLocation ( filedatabase, 'MAFStartTimeTAI  ', MAFStartTimeTAI )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAngle    ', GeodAngle )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAlt      ', GeodAlt )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodLat      ', GeodLat )
      call L1BGeoLocation ( filedatabase, 'GHz/Lon          ', Lon )
      call L1BGeoLocation ( filedatabase, 'GHz/LosAngle     ', LosAngle )
      call L1BGeoLocation ( filedatabase, 'sc/OrbIncl       ', OrbIncl )
      call L1BGeoLocation ( filedatabase, 'GHz/SolarTime    ', SolarTime )
      call L1BGeoLocation ( filedatabase, 'GHz/SolarZenith  ', SolarZenith )
d2520 1
a2520 1
       "$Id: HGrid.f90,v 2.134 2016/07/28 01:45:07 vsnyder Exp $"
d2532 3
@


2.134
log
@Refactor dump and diff
@
text
@d91 1
a91 1
    use string_table, only: get_string
d2425 1
a2425 1
       "$Id: HGrid.f90,v 2.133 2016/07/27 23:02:20 pwagner Exp $"
d2437 3
@


2.133
log
@Works better with Aircraft-borne instrument data
@
text
@d16 1
a16 1
  use HGridsdatabase, only: HGrid_T, HGridGeolocations_T, HGridGeolocations, &
d968 7
a974 6
    use allocate_deallocate, only: allocate_test, deallocate_test
    use chunkdivide_m, only: chunkdivideconfig
    use chunks_m, only: MLSChunk_t, dump
    use constants, only: deg2rad, rad2deg
    use dump_0, only: dump, selfdiff
    use empiricalgeometry, only: empiricallongitude, chooseoptimumlon0
d2425 1
a2425 1
       "$Id: HGrid.f90,v 2.132 2016/07/22 20:04:46 pwagner Exp $"
d2437 3
@


2.132
log
@Permit using hdf4 l1b files
@
text
@d86 1
d254 4
a257 2
        instrumentModule = sub_rosa(subtree(2,son))
        call get_string ( instrumentModule , instrumentModuleName )
d600 2
a601 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
d779 1
a779 1
      if ( deebug ) then
d783 6
d793 1
a793 1
      if ( l1bFlag==-1 .and. .not. MissingthisOK) then
d807 1
a807 1
      if ( l1bItem==1 ) then       ! do something special for time
d812 10
a821 4
      else                         ! Otherwise this is fairly easy.
        do maf = 1, noMAFs
          defaultField(maf) = l1bField%dpField(1,defaultMIFs(maf),maf)
        end do
d2424 1
a2424 1
       "$Id: HGrid.f90,v 2.131 2016/07/21 20:55:09 pwagner Exp $"
d2436 3
@


2.131
log
@Deal smootly when items missing from l1b file
@
text
@d80 1
a80 1
    use MLSFiles, only: getMLSfilebytype
d362 2
a363 1
    if ( .not. IsHDF5DSInFile ( L1BFile%name, "MAFStartTimeTAI" ) ) then
d1642 1
a1642 1
    use MLSFiles, only: getmlsfilebytype
d2408 1
a2408 1
       "$Id: HGrid.f90,v 2.130 2016/05/18 01:37:30 vsnyder Exp $"
d2420 3
@


2.130
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@d81 1
d362 8
d594 1
d604 1
d640 1
d764 1
a764 1
    
d768 1
d774 4
d781 11
a791 2
      if ( l1bFlag==-1 .and. .not. MissingOK) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_L1BRead//l1bItemName )
d883 1
a883 1
      & ( hGrid%noProfsLowerOverlap > maxLowerOverlap ) ) &
d886 1
a886 1
      & ( hGrid%noProfsUpperOverlap > maxUpperOverlap ) ) &
a1549 2
    call trace_begin ( me, "DealWithObstructions", &
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
d1554 2
d2407 1
a2407 1
       "$Id: HGrid.f90,v 2.129 2016/02/26 02:07:18 vsnyder Exp $"
d2419 4
@


2.129
log
@Add QTM support
@
text
@d2078 1
a2078 1
    use HGridsDatabase, only: HGRID_T
d2082 2
a2083 1
    type(HGrid_T), dimension(:), intent(in) :: HGRIDS
d2091 5
a2095 3
    chunks(chunkNo+1)%hGridOffsets = hGrids%noProfs - &
      & hGrids%noProfsLowerOverlap - &
      & hGrids%noProfsUpperOverlap
d2105 1
a2105 1
    use hgridsdatabase, only: hgrid_t
d2107 2
a2108 2
    type(HGRID_T), intent(in)     :: HGrid1
    type(HGRID_T), intent(inout)  :: HGrid2
d2381 1
a2381 1
       "$Id: HGrid.f90,v 2.128 2016/02/12 20:10:53 pwagner Exp $"
d2393 3
@


2.128
log
@Better error checking, more complete DestroyHGridGeoLocations
@
text
@d45 2
a46 1
  integer, private, parameter :: NoFraction = 1
d49 5
a53 5
  integer, private, parameter :: NoModule = NoL1Bfiles + 1
  integer, private, parameter :: NoMIF = NoModule + 1
  integer, private, parameter :: NoSpacingOrigin = NoMIF + 1
  integer, private, parameter :: BadTime = NoSpacingOrigin + 1
  
d72 1
a72 1
      & f_module, f_origin, &
d77 1
a77 1
      & l_l2gp, l_regular
d88 1
d141 1
d180 4
d185 1
d187 2
a188 1
    extendible = .false.
d191 1
a191 1
    insetOverlaps = .false.
a193 1
    date = 0
a195 4
    geodAngleNode = 0
    geodLatNode = 0
    LosAngleNode = 0
    lonNode = 0
d257 3
d307 1
a307 1
        if ( verbose ) call output ( 'Creating L2GP-Based HGrid', advance='yes' )
d334 9
d868 43
d2149 2
d2378 1
a2378 1
       "$Id: HGrid.f90,v 2.127 2015/10/14 23:23:01 pwagner Exp $"
d2390 3
@


2.127
log
@Warn instead of crashing if no profiles in chunk; housekeeping
@
text
@d304 1
d1193 4
a1196 1
    incline = sum ( scOrbIncl ) / noMAFs
d1538 1
d1541 1
d1543 1
d2317 1
a2317 1
       "$Id: HGrid.f90,v 2.126 2015/07/14 23:34:22 pwagner Exp $"
d2329 3
@


2.126
log
@May easily debug cases when gaps in counterMAF
@
text
@a76 2
    use L1BData, only: deallocateL1BData, L1BData_t, readL1BData, &
      & assembleL1BQtyName
d82 1
a82 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSmsg_L1Bread
d86 1
a86 1
    use Output_m, only: blanks, output
d88 1
a88 1
    use time_m, only: begin, finish, time_now, time_config
a119 3
    type (L1BData_T) :: l1bField ! L1B data

    real(rk) :: incline                 ! Orbital inclination / degrees
a128 1
    double precision, dimension(:,:), pointer :: FullArray2d
a132 1
    integer :: L1BFLAG
a148 2
    integer ::  hdfVersion
    character(len=NameLen) :: l1bItemName
a171 1
    hdfversion = L1BFile%HDFVersion
d233 1
a233 1
        incline = expr_value(1) !??? Never used
a301 7
      ! l1bItemName = AssembleL1BQtyName ( "MAFStartTimeTAI", hdfVersion, .false. )
      ! call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
      !   & l1bFlag, firstMAF=chunk%firstMAFIndex, &
      !  & lastMAF=chunk%lastMAFIndex, &
      !  & dontPad=DONTPAD )
      ! if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
      !  & MLSMSG_L1BRead//"MAFStartTimeTAI" )
a343 5
    ! l1bItemName = AssembleL1BQtyName ( "MAFStartTimeTAI", hdfVersion, .false. )
    ! call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
    !  & l1bFlag, &
    !  & firstMAF=chunk%firstMAFIndex, &
    !  & lastMAF=chunk%lastMAFIndex, dontPad=DONTPAD )
d869 1
a869 2
    use dates_module, only: utc_to_time
    use dump_0, only: diff, dump, selfdiff
d873 2
a874 4
    use L1BData, only: deallocateL1BData, L1BData_t, readL1BData, &
      & assembleL1BQtyName
    use MLSCommon, only: mlsfile_t, namelen, tai93_range_t
    use MLSFiles, only: hdfversion_5, dump, getmlsfilebytype
a875 1
    use MLSHdf5, only: ishdf5attributeinfile
a879 1
    use MLSStrings, only: hhmmss_value
a912 1
    integer :: FLAG                     ! From ReadL1B
a914 1
    integer ::  hdfVersion
a916 1
    type (L1BData_T) :: L1BFIELD        ! A field read from L1 file
a917 1
    character(len=NameLen) :: l1bItemName
a928 1
    integer :: NOMAFSINFILE             ! From ReadL1B
a930 2
    real(rk), dimension(:,:), pointer :: OldMethodValues ! For comparing with
    logical :: PreV2Oh                  ! Old way (mean) or new (apparent)?
a934 1
    double precision, dimension(:,:), pointer :: LosAngle2d
a953 1
    nullify(OldMethodValues)
d955 1
a955 1
    warnIfNoProfs = .false.
d959 1
a959 1
      warnIfNoProfs = onlyComputingOffsets
d980 1
a980 7
    hdfversion = L1BFile%HDFVersion
    if ( ( L1BFile%hdfVersion == HDFVERSION_5 ) .and. .false. ) then
      PreV2Oh = .not. IsHDF5AttributeInFile(L1BFile%name, 'BO_name')
    else
      PreV2Oh= .true.
    end if
    ! call outputNamedValue ( 'PreV2Oh', PreV2Oh )
a987 8
    ! l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpGeodAngle", &
    !  & hdfVersion, .false. )
    ! call ReadL1BData ( L1BFile, l1bItemName, &
    !  & l1bField, noMAFsInFile, flag, &
    !  & firstMAF=chunk%firstMAFIndex, &
    !  & lastMAF=chunk%lastMAFIndex+1, dontPad=.true. )
    ! if ( .not. associated(L1BFile) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !  & 'l1boa file nullified during read' )
a1185 9
    ! print *, 'About to try to read ', trim(l1bItemName)
    ! call dump(L1BFile)
    ! call ReadL1BData ( L1BFile, l1bItemName, &
    !  & l1bField, noMAFs, flag, &
    !  & firstMAF=chunk%firstMAFIndex, &
    !  & lastMAF=chunk%lastMAFIndex, &
    !  & dontPad=.true. )
    !if ( .not. associated(L1BFile) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !  & 'l1boa file nullified in read' )
a1204 7
    ! Now time, because this is important to get right, I'm going to put in
    ! special code for the case where the chunk is of length one.
    ! l1bItemName = AssembleL1BQtyName ( "MAFStartTimeTAI", hdfVersion, .false. )
    ! call ReadL1BData ( L1BFile, l1bItemName, &
    !  & l1bField, noMAFs, flag, &
    !  & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
    !  & dontPad=.true. )
a1228 1
    ! call DeallocateL1BData ( l1bField )
a1242 6
    ! l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpSolarZenith", &
    !  & hdfVersion, .false. )
    ! call ReadL1BData ( L1BFile, l1bItemName, &
    !  & l1bField, noMAFs, flag, &
    !  & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
    !  & dontPad=.true. )
a1256 1
    ! call DeallocateL1BData ( l1bField )
a1262 7
    ! This we'll have to do with straight interpolation
    ! l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpLosAngle", &
    !  & hdfVersion, .false. )
    ! call ReadL1BData ( L1BFile, l1bItemName, &
    !  & l1bField, noMAFs, flag, &
    !  & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
    !  & dontPad=.true. )
a1273 1
    ! call DeallocateL1BData ( l1bField )
d1403 1
a1421 1
    ! call DeallocateL1BData ( l1bField ) ! Belt and Suspenders
d1707 2
a1708 3
    use Allocate_deallocate, only: allocate_test, deallocate_test, &
      & Test_Allocate, Test_Deallocate
    use Chunks_m, only: mlschunk_t
a1719 1
    use MLSStringLists, only: switchDetail
d1723 2
a1724 2
    use time_m, only: begin, finish, time_now, time_config
    use Toggles, only: gen, levels, switches, toggle
a1755 1
    integer :: status
d2097 2
a2098 3
    use chunks_m, only: mlschunk_t, dump
    use dates_module, only: gethid, tai93s2hid
    use dump_0, only: dump
a2180 3
    ! call output( 'HGrid times', advance='yes' )
    ! call dump( tai93s2hid(hGrid%time(1,:)), 'times' )
    ! stop    
d2294 1
a2294 1
    use time_m, only: begin, finish, time_now, time_config
d2310 1
a2310 1
       "$Id: HGrid.f90,v 2.125 2015/06/19 21:12:44 pwagner Exp $"
d2322 3
@


2.125
log
@Sped up Computing HGrid offsets
@
text
@d900 1
a900 1
    use MLSFillvalues, only: Monotonize
d1040 6
d1307 1
a1307 1
    call output ( 'Content with l1boa solartime', advance='yes' )
d1457 1
a1457 1
       call outputNamedValue( 'Before TrimHGrid', hGrid%noProfs )
d1464 1
a1464 1
       call outputNamedValue( 'left, right', (/ left, right /) )
d1468 1
a1468 1
       call outputNamedValue( 'Before TrimHGrid', hGrid%noProfs )
d1943 1
a1943 1
              call sayTime ( 'Dumping and destroying this HGrid' )
d2399 1
a2399 1
       "$Id: HGrid.f90,v 2.123 2015/05/05 16:45:13 pwagner Exp $"
d2411 3
@


2.124
log
@Prevent certain crashes
@
text
@d16 3
d21 2
a22 2
  public :: CREATEHGRIDFROMMLSCFINFO, COMPUTENEXTCHUNKSHGRIDOFFSETS, &
    & COMPUTEALLHGRIDOFFSETS, DEALWITHOBSTRUCTIONS
d42 2
d52 1
d61 1
d66 1
a66 1
    use highOutput, only: letsDebug, outputNamedValue
d88 1
d90 1
d133 2
d150 1
d152 1
d162 1
a162 1
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
d165 1
d171 4
a174 1
    endif                                          
d289 1
d303 1
d310 1
d312 11
a322 10
      l1bItemName = AssembleL1BQtyName ( "MAFStartTimeTAI", hdfVersion, .false. )
      call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, firstMAF=chunk%firstMAFIndex, &
        & lastMAF=chunk%lastMAFIndex, &
        & dontPad=DONTPAD )
      if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_L1BRead//"MAFStartTimeTAI" )
      
      minTime = l1bField%dpField(1,1,1)
      maxTime = l1bField%dpField(1,1,noMAFs)
d339 3
a341 1
      call deallocateL1BData ( l1bField ) ! Avoid memory leaks
d344 1
d361 8
a368 6
    l1bItemName = AssembleL1BQtyName ( "MAFStartTimeTAI", hdfVersion, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
      & l1bFlag, &
      & firstMAF=chunk%firstMAFIndex, &
      & lastMAF=chunk%lastMAFIndex, dontPad=DONTPAD )
    call Hunt ( l1bField%dpField(1,1,:), hgrid%time(1,:), hgrid%maf, &
d375 1
a375 1
        &                      shape(l1bField%dpField(1,1,:)) )
d377 1
a377 1
        & tai93s2hid(l1bField%dpField(1,1,:), leapsec=.true.) )
d382 1
a382 1
        & tai93s2hid(l1bField%dpField(1,1,hgrid%maf), leapsec=.true.) )
d386 3
a388 1
    call deallocateL1BData ( l1bField )
d392 4
d402 1
a402 1
      & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
d470 1
a470 1
    verbose = BeVerbose( 'hgrid', -1 )
d941 2
d966 8
d997 1
a997 1
      verbose = verbose .or. deebughere
d1022 1
d1030 10
a1039 8
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpGeodAngle", &
      & hdfVersion, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, &
      & l1bField, noMAFsInFile, flag, &
      & firstMAF=chunk%firstMAFIndex, &
      & lastMAF=chunk%lastMAFIndex+1, dontPad=.true. )
    if ( .not. associated(L1BFile) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'l1boa file nullified during read' )
d1041 13
a1053 5
    noMIFs = size(l1bField%dpField(1,:,1))
    minAngle = minval ( l1bField%dpField(1,:,1) )
    maxAngleFirstMAF = maxval ( l1bField%dpField(1,:,1) )
    maxAngle = maxval ( l1bField%dpField(1,:,noMAFs) )
    minAngleLastMAF = minval ( l1bField%dpField(1,:,noMAFs) )
d1057 2
a1058 2
    mif1GeodAngle = l1bField%dpField(1,1,1:noMAFs)
    allGeodAngle = l1bField%dpField(1,1:noMIFs,1:noMAFs)
d1069 5
d1075 14
a1088 12
      call output ( 'While constructing regular hGrid ', advance='yes' )
      call output ( 'minAngle: ' )
      call output ( minAngle, format='(F7.2)' )
      call output ( ' maxAngle: ' )
      call output ( maxAngle, format='(F7.2)' )
      call output ( 'i: ' )
      call output ( i, advance='yes' )
      call output ( 'noMAFs: ' )
      call output ( noMAFs, advance='yes' )
      call output ( 'chunk%noMAFsUpperOverlap: ' )
      call output ( chunk%noMAFsUpperOverlap, advance='yes' )
      call dump(chunk)
d1093 2
a1094 2
    else if ( i < noMAFsInFile + 1 ) then
      nextAngle = l1bField%dpField(1,1,i)
d1147 1
a1147 1
      i = FindClosestMatch ( tmpAngle, l1bField%dpField(1,:,:), 1 )
d1154 3
a1156 1
    call DeallocateL1BData ( l1bField )
d1227 1
a1227 1
    l1bItemName = AssembleL1BQtyName ( "scOrbIncl", hdfVersion, .false. )
d1232 9
a1240 7
    call ReadL1BData ( L1BFile, l1bItemName, &
      & l1bField, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, &
      & lastMAF=chunk%lastMAFIndex, &
      & dontPad=.true. )
    if ( .not. associated(L1BFile) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'l1boa file nullified in read' )
d1242 1
a1242 1
      call dump(l1bField%DpField(1,1,:), l1bItemName)
d1245 1
a1245 1
    incline = sum ( l1bField%dpField(1,1,:) ) / noMAFs
d1249 3
a1251 1
    call DeallocateL1BData ( l1bField )
d1260 7
a1266 5
    l1bItemName = AssembleL1BQtyName ( "MAFStartTimeTAI", hdfVersion, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, &
      & l1bField, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
      & dontPad=.true. )
d1268 2
a1269 2
      call dump( l1bField%DpField(1,1,:), trim(l1bItemName) // ' (before interpolating)')
      call selfdiff( l1bField%DpField(1,1,:), trim(l1bItemName)  )
d1274 1
a1274 1
      call InterpolateValues ( mif1GeodAngle, l1bField%dpField(1,1,:), &
d1279 1
a1279 1
      hGrid%time = l1bField%dpField(1,1,1) + &
d1283 5
a1287 5
      call dump(hGrid%time(1,:), trim(l1bItemName) // ' (after interpolating)')
      call output('geod angle, before and after interpolating', &
        & advance='yes')
      call dump(mif1GeodAngle, 'before')
      call dump(HGrid%phi(1,:), 'after')
d1289 3
a1291 1
    call DeallocateL1BData ( l1bField )
d1294 8
a1301 49
    if ( Prev2Oh ) then
      ! First get fractional day, note this neglects leap seconds.
      ! Perhaps fix this later !???????? NJL. We do have access to the
      ! UTC ascii time field, perhaps we could use that?
      hGrid%solarTime = modulo ( hGrid%time, secondsInDay ) / secondsInDay
      ! Now correct for longitude and convert to hours
      hGrid%solarTime = 24.0 * ( hGrid%solarTime + hGrid%lon/360.0 )
      hGrid%solarTime = modulo ( hGrid%solarTime, 24.0_rk )
    else
      if ( deebughere ) then
        call output ( 'About to attempt to get solar time', advance='yes')
        call output ( 'L1Bfile ' // trim(L1BFile%name), advance='yes')
        call output ( 'Module ' // trim(instrumentModuleName), advance='yes')
        call output ( 'firstMAF ')
        call output ( chunk%firstMAFIndex, advance='yes')
        call output ( 'lastMAF ')
        call output ( chunk%lastMAFIndex, advance='yes')
        call output ( 'shape(solarTime) ')
        call output ( shape(hGrid%solarTime), advance='yes')
      end if
      call GetApparentLocalSolarTime( L1BFile, instrumentModuleName, chunk, &
        & hGrid )
      ! What the heck, let's compute the old way, too, and compare
      
      noMIFs = size(hGrid%solarTime, 1)
      if ( deebughere ) then
        call output('NoMAFs ')
        call output(NoMAFs, advance='yes' )
        call output('NoMIFs ')
        call output(NoMIFs, advance='yes' )
        call output('About to allocate', advance='yes')
        call allocate_test(OldMethodValues, noMIFs, size(hGrid%solarTime, 2), &
          & 'OldMethodValues', ModuleName)
        call output('Managed to allocate', advance='yes')
        OldMethodValues = modulo ( hGrid%time, secondsInDay ) / secondsInDay
        OldMethodValues = 24.0 * ( OldMethodValues + hGrid%lon/360.0 )
        OldMethodValues = modulo ( OldMethodValues, 24.0_rk )
        call output('About to diff solartimes', advance='yes')
        call output('Shape(v1.51) ')
        call output(Shape(OldMethodValues), advance='yes')
        call output('Shape(v2.0) ')
        call output(Shape(hGrid%solarTime), advance='yes')
        call dump(OldMethodValues, 'v1.51')
        call dump(hGrid%solarTime, 'v2.0')
        call diff( OldMethodValues, 'v1.51', hGrid%solarTime, 'v2.0', &
          & options='rs' )
        call deallocate_test(OldMethodValues, 'OldMethodValues', ModuleName)
      end if
    end if
d1304 8
a1311 6
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpSolarZenith", &
      & hdfVersion, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, &
      & l1bField, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
      & dontPad=.true. )
d1313 1
a1313 1
      call dump(l1bField%DpField(1,1,:), trim(l1bItemName) // &
d1316 7
a1322 31
    if ( Prev2Oh .or. .true. ) then ! Haven't been able to get the other to work
      ! This we'll have to do with straight interpolation
      call InterpolateValues ( mif1GeodAngle, l1bField%dpField(1,1,:), &
        & hGrid%phi(1,:), hGrid%solarZenith(1,:), &
        & method='Linear', extrapolate='Allow' )
      if ( deebughere ) then
        call dump(hGrid%solarZenith(1,:), trim(l1bItemName) // &
          & ' (after interpolating)')
      end if
    else
!       call GetApparentLocalSolarZenith( L1BFile, hGrid, &
!         & l1bField%dpField(1,1,:), chunk )
      call closestApparentLocalSolarZenith( allGeodAngle, l1bField%dpField(1,:,:), &
        & hGrid%phi(1,:), hGrid%solarZenith(1,:) )
      ! What the heck, let's compute the old way, too, and compare
      call allocate_test(OldMethodValues, noMIFs, size(hGrid%solarTime, 2), &
        & 'OldMethodValues', ModuleName)
      call InterpolateValues ( mif1GeodAngle, l1bField%dpField(1,1,:), &
        & hGrid%phi(1,:), OldMethodValues(1,:), &
        & method='Linear', extrapolate='Allow' )
      call output('About to diff solar zeniths', advance='yes')
      call output('Shape(v1.51) ')
      call output(Shape(OldMethodValues), advance='yes')
      call output('Shape(v2.0) ')
      call output(Shape(hGrid%solarZenith), advance='yes')
      call dump(OldMethodValues, 'v1.51')
      call dump(hGrid%solarZenith, 'v2.0')
      call diff( OldMethodValues, 'v1.51', hGrid%solarZenith, 'v2.0', &
        & options='rs' )
      call deallocate_test(OldMethodValues, 'OldMethodValues', ModuleName)
      
d1324 5
a1328 1
    call DeallocateL1BData ( l1bField )
d1332 8
a1339 6
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpLosAngle", &
      & hdfVersion, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, &
      & l1bField, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
      & dontPad=.true. )
d1341 1
a1341 1
      call dump(l1bField%DpField(1,1,:), trim(l1bItemName) // ' (before interpolating)')
d1343 1
a1343 1
    call InterpolateValues ( mif1GeodAngle, l1bField%dpField(1,1,:), &
d1347 1
a1347 1
      call dump(hGrid%losAngle(1,:), trim(l1bItemName) // ' (after interpolating)')
d1349 3
a1351 1
    call DeallocateL1BData ( l1bField )
d1359 3
a1361 1
    if ( verbose ) call outputNamedValue ( 'hGrid%noProfsLowerOverlap (after Hunt)', hGrid%noProfsLowerOverlap )
d1369 2
a1370 1
    ! call outputNamedValue ( 'hGrid%noProfsUpperOverlap (after Hunt)', hGrid%noProfsUpperOverlap )
d1372 1
a1372 1
    if ( verbose ) then
d1451 1
d1458 1
d1462 1
d1465 1
d1470 1
d1487 1
a1487 1
    if ( verbose ) then
d1497 1
a1497 1
    call DeallocateL1BData ( l1bField ) ! Belt and Suspenders
a1503 416
  contains
    subroutine GetApparentLocalSolarTime ( L1BFile, instrumentModuleName, &
      & chunk, HGrid )
      character (len=*), intent(in) :: INSTRUMENTMODULENAME
      type (MLSFile_T), pointer     :: L1BFile
      type (MLSChunk_T), intent(in) :: CHUNK
      type(HGrid_T) :: hGrid
      ! real(rk), dimension(:,:)      :: solarTime
      ! Local variables
      type (L1BData_T) :: L1BFIELD        ! A field read from L1 file
      real (rk), dimension(:), pointer :: GMT => null()
      real (rk), dimension(:,:), pointer :: MAFLongitude => null()
      real (rk), dimension(:,:), pointer :: MAFTime => null()
      integer :: maf
      integer :: Me = -1                  ! String index for tracing
      integer :: noMAFs
      integer :: noMIFs
      character(len=1), parameter :: SEPARATOR = ':'
      real (rk), dimension(:), pointer :: SolarLongitude => null()
      real (rk), dimension(:), pointer :: SolarTimeCalibration => null()
      integer :: status
      logical, parameter :: STRICT = .true.
      character(len=27) :: time

      ! Executable

      call trace_begin ( me, "GetApparentLocalSolarTime", &
        & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
      nullify ( GMT, MAFLongitude, MAFTime, &
        & SolarLongitude, SolarTimeCalibration )
      
      ! The 1st formula:

      ! (LST) = (GMT) + ( (LON) - (LON_S) ) / 15

      ! Where (LST)  Local Solar Time
      ! (GMT)   Greenwich mean time (aka utc)
      ! (LON)   Local longitude
      ! (LON_S) Solar longitude (which we will infer as a 1st step)
      l1bItemName = AssembleL1BQtyName ( "Lon", &
        & hdfVersion, .false., instrumentModuleName )
      call ReadL1BData ( L1BFile, l1bItemName, &
        & l1bField, noMAFs, status, &
        & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & dontPad=.true. )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to read Lon from l1boa', MLSFile=L1BFile )
      noMIFs = size(l1bField%dpField, 2)
      call allocate_test(GMT, noMAFs, 'GMT', ModuleName)
      call allocate_test(MAFLongitude, noMIFs, noMAFs, 'MAFLongitude', ModuleName)
      call allocate_test(MAFTime, noMIFs, noMAFs, 'MAFTime', ModuleName)
      call allocate_test(SolarLongitude, noMAFs, 'SolarLongitude', ModuleName)
      call allocate_test(SolarTimeCalibration, noMAFs, 'SolarTimeCalibration', ModuleName)
      MAFLongitude = l1bField%dpField(1,:,:)
      call DeallocateL1BData ( l1bField )

      l1bItemName = AssembleL1BQtyName ( "MAFStartTimeTAI", &
        & hdfVersion, .false. )
      call ReadL1BData ( L1BFile, l1bItemName, &
        & l1bField, noMAFs, status, &
        & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & dontPad=.true. )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to read MAFStartTimeTAI from l1boa', MLSFile=L1BFile )
      MAFTime = l1bField%dpField(1,:,:)

      l1bItemName = AssembleL1BQtyName ( "MAFStartTimeUTC", &
        & hdfVersion, .false. )
      call ReadL1BData ( L1BFile, l1bItemName, &
        & l1bField, noMAFs, status, &
        & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & dontPad=.true. )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to read MAFStatTimeUTC from l1boa', MLSFile=L1BFile )
      ! This converts the utc string into time into the day (in hours)
      do maf=1, noMAFs
          call utc_to_time(l1bField%CharField(1,1,maf), status, time, strict)
          GMT(maf) = hhmmss_value ( time, status, separator, strict ) / 3600
      end do
      call DeallocateL1BData ( l1bField )

      l1bItemName = AssembleL1BQtyName ( "SolarTime", &
        & hdfVersion, .false., instrumentModuleName )
      call ReadL1BData ( L1BFile, l1bItemName, &
        & l1bField, noMAFs, status, &
        & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & dontPad=.true. )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to read SolarTime from l1boa', MLSFile=L1BFile )
      SolarTimeCalibration = l1bField%dpField(1,1,:)
      call DeallocateL1BData ( l1bField )

      ! 1st we will find the calibrated solar longitude (in deg)
      ! assuming our 1st formula above holds for all mifs
      SolarLongitude = MAFLongitude(1,:) - &
        & (SolarTimeCalibration-GMT(:))*360./24

      ! 2nd we need the GMT corrected for the regular HGrid offsets from MAFs
      GMT = GMT + ( HGrid%time(1,:) - MAFTime(1,:) ) / 3600
      do maf=1, noMAFs
        HGrid%SolarTime(:,maf) = GMT(maf) + &
          & ( HGrid%Lon(:,maf) - SolarLongitude(maf) ) / 15
      end do

      ! Now deallocate all the junk we allocated
      call deallocate_test(GMT, 'GMT', ModuleName)
      call deallocate_test(MAFLongitude, 'MAFLongitude', ModuleName)
      call deallocate_test(MAFTime, 'MAFTime', ModuleName)
      call deallocate_test(SolarLongitude, 'SolarLongitude', ModuleName)
      call deallocate_test(SolarTimeCalibration, 'SolarTimeCalibration', ModuleName)

      call trace_end ( "GetApparentLocalSolarTime", &
        & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

    end subroutine GetApparentLocalSolarTime

    subroutine closestApparentLocalSolarZenith ( allGeodAngle, allSolarZenith, &
      & GeodAngle, solarZenith )
      use MLSNumerics, only: closestElement
      ! Another approach--compare against linear interpolation
      ! Dummy arguments
      real(rk), dimension(:,:), intent(in) :: allGeodAngle
      real(rk), dimension(:,:), intent(in) :: allSolarZenith
      real(rk), dimension(:), intent(in)   :: GeodAngle
      real(rk), dimension(:), intent(out)  :: solarZenith
      ! Local variables
      integer :: indices(2)
      integer :: maf
      integer :: Me = -1                  ! String index for tracing
      ! Executable

      call trace_begin ( me, "closestApparentLocalSolarZenith", &
        & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
      do maf = 1, size(GeodAngle)
        call closestElement( GeodAngle(maf), allGeodAngle, indices )
        if ( any(indices < 1) .or. &
          & ( indices(1) > size(allGeodAngle, 1) ) .or. &
          & ( indices(2) > size(allGeodAngle, 2) ) ) then
          call dump(indices, 'indices')
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unable to find closest element' )
        end if
        solarZenith(maf) = allSolarZenith( indices(1), indices(2) )
      end do
      call trace_end ( "closestApparentLocalSolarZenith", &
        & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

    end subroutine closestApparentLocalSolarZenith

    subroutine GetApparentLocalSolarZenith ( L1BFile, hGrid, solarZenithAtMIF1, &
      & chunk )
      ! Alas, was unable to get this to work properly
      ! There is a web page at
      ! http://www.pcigeomatics.com/cgi-bin/pcihlp/AVHRRAD%7CDETAILS%7CANGLE+GENERATION
      ! that includes a summary of some of the same equations we're trying to
      ! implement here, but starting from the assumed equations
      ! for solar declination and right ascension
      ! In any case, we're doing no better than linear interpolation
      ! for other quantities, so we'll resort to that for solarzenithangle, too
      type (MLSFile_T), pointer     :: L1BFile
      type(HGrid_T) :: hGrid
      real(rk), dimension(:), intent(in) :: solarZenithAtMIF1
      type (MLSChunk_T), intent(in) :: CHUNK
      ! The key equation to be considered is

      ! cos(SZA) = sin(LAT) sin(LAT_S) + cos(LAT) cos(LAT_S) cos( 15 (LST-12) )

      ! where SZA is the solar zenit angle we are seeking
      ! LAT is the local latitude, LAT_S is the sun's latitude, and
      ! LST is the local solar time
      ! We will have to solve for LAT_S and assume it's constant over a maf
      ! Note that all angles are assumed to be in degrees, not radians

      ! Local variables
      real(rk) :: a ! sin(local latitude)
      real(rk) :: b ! cos(local latitude) cos( 15 (local solar time - 12) )
      real(rk) :: c ! cos(SZA calibrating)
      ! The next variables are used if we forego the quadratic solution
      ! and instead rely on solving two equations in two "independent"
      ! variables, s=sin(LAT_S) and c=cos(LAT_S)
      ! So we solve
      ! y1 = cos(SZA[1]) = s sin(Lat[1]) + c Q[1] cos(Lat[1])
      ! y2 = cos(SZA[2]) = s sin(Lat[2]) + c Q[2] cos(Lat[2])
      ! where
      ! Q[i] = cos( 15 (LST[i]-12) )
      ! The solution is of course
      !
      !  s        sin(Lat[1])  Q[1] cos(Lat[1])            y1
      ! ( )  =  (                               ) ^ (-1)  (  )
      !  c        sin(Lat[2])  Q[2] cos(Lat[2])            y2
      !
      ! Rewrite the matrix above as
      ! a11  a12
      !(        )
      ! a21  a22
      ! and let its determinant delta = ( a11 a22 - a12 a21 )
      ! then the inverse will be
      ! a22  -a12
      !(         ) / delta
      ! a21   a11
      real(rk) :: delta ! determinant
      real(rk) :: a11, a12, a21, a22, y1, y2, s
      type (L1BData_T) :: L1BFIELD        ! A field read from L1 file
      real (rk), dimension(:), pointer :: LocalLatitude => null()
      real (rk), dimension(:), pointer :: LocalSolarTime => null()
      integer :: maf
      integer :: Me = -1                  ! String index for tracing
      integer :: mif
      integer :: noMAFs
      integer :: noMIFs
      real(rk) :: r1, r2, imPart, root
      real (rk), dimension(:,:), pointer :: sinSZA => null()
      real (rk), dimension(:), pointer :: SolarLatitudeCalibration => null()
      integer :: status
      logical, parameter :: TESTFIRST = .true. ! Test whether key eq'n true
      real (rk), dimension(:,:), pointer :: testLAT => null()
      real (rk), dimension(:,:), pointer :: testLST => null()
      real (rk), dimension(:,:), pointer :: testSZA => null()
      real (rk), dimension(:,:), pointer :: testSSL => null() ! sin solar lat
      logical, parameter                 :: USEQUADRATIC = .false.

      ! Executable

      call trace_begin ( me, "GetApparentLocalSolarZenith", &
        & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )

      ! (We'll put stuff here when we're ready)
      ! call output('Darn! Noone coded this part yet .. tell paw', advance='yes')
      ! hGrid%solarZenith = -999.99

      ! Try to solve for sin(LAT_S) knowing that
      ! sin^2(LAT_S) + cos^2(LAT_S) = 1
      l1bItemName = AssembleL1BQtyName ( "GeodLat", &
        & hdfVersion, .false., instrumentModuleName )
      call ReadL1BData ( L1BFile, l1bItemName, &
        & l1bField, noMAFs, status, &
        & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & dontPad=.true. )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to read Lon from l1boa', MLSFile=L1BFile )
      noMIFs = size(l1bField%dpField, 2)
      call allocate_test(LocalLatitude,  noMAFs, 'LocalLatitude', ModuleName)
      call allocate_test(LocalSolarTime, noMAFs, 'LocalSolarTime', ModuleName)
      call allocate_test(SolarLatitudeCalibration, noMAFs, 'SolarLatitudeCalibration', ModuleName)
      LocalLatitude = l1bField%dpField(1,1,:)

      if ( TESTFIRST .or. .not. USEQUADRATIC ) then
        ! Test whether whatever is stored in l1boa file satisfies
        ! key equation
        call allocate_test(testLAT,  noMIFs, noMAFs, 'testLAT', ModuleName)
        call allocate_test(testLST,  noMIFs, noMAFs, 'testLST', ModuleName)
        call allocate_test(testSZA,  noMIFs, noMAFs, 'testSZA', ModuleName)
        call allocate_test(testSSL,  noMIFs, noMAFs, 'testSSL', ModuleName)
        testLAT = l1bField%dpField(1,:,:)
        call dump(testLAT, 'Latitude')
        call DeallocateL1BData ( l1bField )

        l1bItemName = AssembleL1BQtyName ( "SolarTime", &
          & hdfVersion, .false., instrumentModuleName )
        call ReadL1BData ( L1BFile, l1bItemName, &
          & l1bField, noMAFs, status, &
          & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & dontPad=.true. )
        testLST = l1bField%dpField(1,:,:)
        call dump(testLST, 'Solar Time')
        call DeallocateL1BData ( l1bField )

        l1bItemName = AssembleL1BQtyName ( "SolarZenith", &
          & hdfVersion, .false., instrumentModuleName )
        call ReadL1BData ( L1BFile, l1bItemName, &
          & l1bField, noMAFs, status, &
          & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & dontPad=.true. )
        testSZA = l1bField%dpField(1,:,:)
        call dump(testSZA, 'Solar Zenith')
        call DeallocateL1BData ( l1bField )

        if ( .not. USEQUADRATIC ) then
          ! Just pick two different points and solve for
          ! sin(LAT_S) and cos(LAT_S) as if they were independent variables
          noMAFs = HGrid%noProfs
          y1 = cos( deg2rad * testSZA(1, 1) )
          y2 = cos( deg2rad * testSZA(1, noMAFs) )
          a11 = sin( deg2rad * testLAT(1, 1) )
          a21 = sin( deg2rad * testLAT(1, noMAFs) )
          a12 = cos( deg2rad * testLAT(1, 1) ) * &
            &   cos( deg2rad * 15 * (testLST(1, 1) - 12) )
          a22 = cos( deg2rad * testLAT(1, 1) ) * &
            &   cos( deg2rad * 15 * (testLST(1, noMAFs) - 12) )
          delta = a11*a22 - a12*a21
          if ( delta == 0._rk)  call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'determinant vanishes in GetApparentLocalSolarZenith', &
          & MLSFile=L1BFile )
          s = ( a22*y1 - a12*y2 ) / delta
          c = ( a21*y1 + a11*y2 ) / delta
          ! How reasonable are these?
          print *, 's, c: ', s, c
          print *, 's^2 + c^2: ', s**2 + c**2
          print *, 'atan(s/c): ', rad2deg*atan2(s, c)
          ! Now with s and c in hand, we can go ahead and apply our formula
          ! (and get answers we hope to be correct)
          HGrid%solarZenith = acos( &
            & s * sin( deg2rad * HGrid%geodLat ) + &
            & c * cos( deg2rad * HGrid%geodLat ) * &
            &     cos( deg2rad * 15 * (HGrid%solarTime - 12) ) &
            & )
          return
        end if
        do maf=1, noMAFs
          do mif=1, noMIFs
            a = sin( deg2rad * testLAT(mif, maf) )
            b = cos( deg2rad * testLAT(mif, maf) ) * &
              & cos( deg2rad * 15 * (testLST(mif, maf) - 12) )
            c = cos( deg2rad * testSZA(mif, maf) )
            call SolveQuadratic( (a**2 + b**2), -2*a*c, c**2 - b**2, &
              & r1, r2, imPart )
            if ( imPart /= 0._rk ) then
              call output('mif, maf: ', advance='no')
              call output(mif, advance='no')
              call output(maf, advance='yes')
              call output('testLAT ', advance='no')
              call output(testLAT(mif, maf), advance='yes')
              call output('testLST ', advance='no')
              call output(testLST(mif, maf), advance='yes')
              call output('testSZA ', advance='no')
              call output(testSZA(mif, maf), advance='yes')
              call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'quadratic solver returned complex roots during test', &
              & MLSFile=L1BFile )
            end if
            if ( (c - a*r1)/b > 0. ) then
              testSSL(mif, maf) = asin( rad2deg * r1 )
            else
              testSSL(mif, maf) = asin( rad2deg * r2 )
            end if
          end do
        end do
        call dump(testSSL, 'test solar latitudes')
        call deallocate_test(testLAT, 'testLAT', ModuleName)
        call deallocate_test(testLST, 'testLST', ModuleName)
        call deallocate_test(testSZA, 'testSZA', ModuleName)
        call deallocate_test(testSSL, 'testSSL', ModuleName)
      else
        call DeallocateL1BData ( l1bField )
      end if

      l1bItemName = AssembleL1BQtyName ( "SolarTime", &
        & hdfVersion, .false., instrumentModuleName )
      call ReadL1BData ( L1BFile, l1bItemName, &
        & l1bField, noMAFs, status, &
        & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & dontPad=.true. )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to read SolarTime from l1boa', MLSFile=L1BFile )
      LocalSolarTime = l1bField%dpField(1,1,:)
      call DeallocateL1BData ( l1bField )

      ! The 1st thing to do is to compute calibrating LAT_S
      do maf=1, noMAFs
      
        ! Now solve the key equation above for LAT_S given the l1b data
        a = sin( deg2rad * LocalLatitude(maf) )
        b = cos( deg2rad * LocalLatitude(maf) ) * &
          & cos( deg2rad * 15 * (LocalSolarTime(maf) - 12) )
        c = cos( deg2rad * solarZenithAtMIF1(maf) )
        ! b = 0 is a special case--don't need to solve quadratic
        call output('LocalLatitude: ')
        call output(LocalLatitude(maf), advance='yes')
        call output('LocalSolarTime: ')
        call output(LocalSolarTime(maf), advance='yes')
        call output('solarZenithAtMIF1: ')
        call output(solarZenithAtMIF1(maf), advance='yes')
        call output('a, b, c: ')
        call output( (/a, b, c/), advance='yes')
        if ( b == 0._rk ) then
          root = c / a
        else
          call SolveQuadratic( (a**2 + b**2), -2*a*c, c**2 - b**2, &
            & r1, r2, imPart )
          if ( imPart /= 0._rk ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'quadratic solver returned complex roots', MLSFile=L1BFile )
          ! Only one of the roots satisfies (c - a x) / b > 0
          if ( (c - a*r1)/b > 0._rk ) then
            root = r1
          else if ( (c - a*r2)/b > 0._rk ) then
            root = r2
          else
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Neither root satisfies (c - a x)/b > 0', MLSFile=L1BFile )
          end if
        end if
        if ( abs(root) > 1._rk ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'abs(root) > 1', MLSFile=L1BFile )
        SolarLatitudeCalibration(maf) = rad2deg * asin(root)
      end do
      call deallocate_test(LocalLatitude, 'LocalLatitude', ModuleName)
      call deallocate_test(LocalSolarTime, 'LocalSolarTime', ModuleName)

      call allocate_test(sinSZA, noMIFs, noMAFs, 'sinSZA', ModuleName)
      ! Now use key equation to find SZA
      do maf=1, noMAFs
        sinSZA(:,maf) = sin( deg2rad * hGrid%geodLat(:,maf) ) * &
          &             sin( deg2rad * SolarLatitudeCalibration(maf) ) &
          &   + &
          &             cos( deg2rad * hGrid%geodLat(:,maf) ) * &
          &             cos( deg2rad * SolarLatitudeCalibration(maf) ) * &
          &             cos( deg2rad * 15 * (hGrid%SolarTime(:,maf) - 12) )
      end do
      hGrid%solarZenith = rad2deg * asin(sinSZA)
      call deallocate_test(sinSZA, 'sinSZA', ModuleName)
      call deallocate_test(SolarLatitudeCalibration, 'SolarLatitudeCalibration', ModuleName)

      call trace_end ( "GetApparentLocalSolarZenith", &
        & cond=toggle(gen) .and. levels(gen) > 1 .and. .not. computingOffsets )
    end subroutine GetApparentLocalSolarZenith

d1604 11
d1788 1
a1788 1
    use HGridsDatabase, only: HGrid_t, destroyHGridContents, dump
d1801 1
d1824 1
d1830 1
d1832 2
d1836 2
a1837 1
    real(rk), dimension(:), pointer :: MAFStartTimeTAI, GeodAngle, GeodAlt, GeodLat, SolarTime
d1839 1
a1839 1
    ! computingOffsets = .true.
d1841 1
a1841 1
    verbose = beVerbose ( 'hgrid', 0 )
d1843 1
a1843 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d1851 1
d1854 3
d1858 1
d1860 3
a1862 1
      ! call outputnamedValue ( 'Beginning chunk number', chunk )
d1864 2
d1867 1
d1874 6
a1879 4
          do
            gson = next_tree_node ( son, state2, traceLevel=5 )
            if ( gson == 0 ) exit
            if ( node_id(gson) == n_named ) then ! Is spec labeled?
d1881 44
a1924 5
              if ( get_spec_id(key) == s_hGrid ) then
                ! This is an hGrid definition
                if ( chunk == 0 ) then
                  ! For the 'zeroth' pass just count up the hgrids
                  noHGrids = noHGrids + 1
d1926 2
a1927 32
                  ! nullify ( dummyHGrid )
                  dummyHGrid = CreateHGridFromMLSCFInfo ( 0, key, filedatabase, l2gpDatabase, &
                    & processingRange, chunks(chunk), onlyComputingOffsets=.true. )
                  if ( HGrid ==1 ) &
                    & firstHGrid(chunk) = CreateHGridFromMLSCFInfo ( 0, key, filedatabase, &
                    & l2gpDatabase, processingRange, chunks(chunk), &
                    & onlyComputingOffsets=.true. )
                  if ( chunk == 1 ) then
                    LowerOverlaps(hGrid) = dummyHGrid%noProfsLowerOverlap
                    if ( ChunkDivideConfig%allowPriorOverlaps .and. .false. ) then
                      chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                      & dummyHGrid%noProfsUpperOverlap
                    else
                      chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                      & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                    end if
                  else if ( chunk == size(chunks) ) then
                    if ( ChunkDivideConfig%allowPostOverlaps ) then
                      chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                      & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                    else
                      chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                      & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                    end if
                  else
                    chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                    & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                  end if
                  if ( DEEBUG ) &
                    & call dump(dummyHGrid)
                  call DestroyHGridContents ( dummyHGrid )
                  hGrid = hGrid + 1
d1929 3
d1933 7
a1939 2
            else ! Son is n_spec_args
              key = gson
d1947 5
a1951 1
      ! call output( 'Done with section Loop', advance='yes' )
d1966 4
a1969 5
      else
        ! Otherwise, at least check we got the same number of hGrids each chunk
        if ( hGrid /= noHGrids + 1 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Got a different number of hGrids for different chunks, that makes no sense!' )
d2042 11
a2052 6
      nullify( MAFStartTimeTAI, GeodAngle, GeodAlt, GeodLat, SolarTime )
      call L1BGeoLocation ( filedatabase, 'MAFStartTimeTAI', MAFStartTimeTAI )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAngle  ', GeodAngle )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodAlt    ', GeodAlt )
      call L1BGeoLocation ( filedatabase, 'GHz/GeodLat    ', GeodLat )
      call L1BGeoLocation ( filedatabase, 'GHz/SolarTime  ', SolarTime )
a2059 1
          call outputnamedValue( 'chunk', chunk )
d2066 1
d2070 3
d2074 1
d2083 1
a2083 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d2274 1
a2274 1
    call gethid( MAFStartTimeTAI ( lastMAF + 1 ), leapsec=.true. , hid=lastVal  )
a2332 30
  ! ---------------------------------------------  L1BGeoLocation  -----
  subroutine L1BGeoLocation ( filedatabase, name, values )

    use allocate_deallocate, only: allocate_test
    use L1BData, only: deallocateL1BData, L1BData_t, readL1BData, &
      & assembleL1BQtyName
    use MLSCommon, only: MLSfile_t
    use MLSFiles, only: getMLSfilebytype
    use MLSKinds, only: rk => r8
    ! Args
    type (MLSFile_T), dimension(:), pointer :: FILEDATABASE
    character(len=*), intent(in)            :: name
    real(rk), dimension(:), pointer         :: values
    ! Local variables
    type (L1BData_T) :: l1bField ! L1B data
    type (MLSFile_T), pointer             :: L1BFile
    character(len=64)                     :: l1bItemName
    integer                               :: hdfVersion
    integer                               :: noMAFs
    integer                               :: status
    ! Executable
    L1BFile => GetMLSFileByType( filedatabase, content='l1boa' )
    hdfversion = L1BFile%HDFVersion
    l1bItemName = AssembleL1BQtyName ( Name, hdfVersion, .false. )
    call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, status )
    call Allocate_test ( values, noMAFs, 'values of ' // trim(name), ModuleName )
    values = l1bField%dpField(1,1,:)
    call deallocateL1BData ( l1bField ) ! Avoid memory leaks
  end subroutine L1BGeoLocation

d2375 14
d2405 3
@


2.123
log
@Merged changes in branch v4.21
@
text
@d2396 8
a2403 3
        call CompareWithChunk( chunks(chunk), &
          & chunks(min(size ( chunks ), chunk+1)), firstHGrid(chunk), &
          & MAFStartTimeTAI, GeodAngle, GeodAlt, GeodLat, SolarTime )
d2541 2
a2542 2
    call gethid( MAFStartTimeTAI ( chunk%firstMAFIndex  ), leapsec=.true. , hid=firstVal )
    call gethid( MAFStartTimeTAI ( chunk%lastMAFIndex ), leapsec=.true. , hid=lastVal  )
d2584 2
a2585 2
    call gethid( MAFStartTimeTAI ( lowMAF  ), leapsec=.true. , hid=firstVal )
    call gethid( MAFStartTimeTAI ( highMAF ), leapsec=.true. , hid=lastVal  )
d2608 2
a2609 2
    call gethid( MAFStartTimeTAI ( firstMAF ), leapsec=.true. , hid=firstVal )
    call gethid( MAFStartTimeTAI ( lastMAF  ), leapsec=.true. , hid=lastVal  )
d2623 2
a2624 2
    firstVal = GeodAngle ( firstMAF )
    lastVal  = GeodAngle ( lastMAF )
d2638 2
a2639 2
    firstVal = geodLat ( firstMAF )
    lastVal  = geodLat ( lastMAF )
d2653 2
a2654 2
    firstVal = SolarTime ( firstMAF )
    lastVal  = SolarTime ( lastMAF )
d2744 1
a2744 1
       "$Id: HGrid.f90,v 2.122 2015/04/29 01:16:34 vsnyder Exp $"
d2756 3
@


2.122
log
@Cosmetic changes
@
text
@a123 1
    logical :: FORBIDOVERSPILL          ! If set don't allow overlaps beyond L1B
a172 1
    forbidOverspill = .false.
d208 1
a208 1
        forbidOverspill = get_boolean ( fieldValue )
a329 1
          & forbidOverspill, &
d843 1
a843 1
    & spacing, origin, instrumentModuleName, extendible, forbidOverspill, &
a887 1
    logical, intent(in) :: FORBIDOVERSPILL
d1156 1
a1156 1
      call output ( forbidoverspill, advance='yes' )
d1369 1
a1369 1
    if ( forbidOverspill ) then
d2332 1
a2332 3
      call output ( sum1 , advance='no' )
      call output ( sum2 , advance='no' )
      call output ( sum3 , advance='yes' )
d2338 1
d2342 1
d2355 1
a2355 1
    if ( DEEBUG ) then
d2360 3
a2362 1
      & chunks(1)%noMAFsLowerOverlap > 0 ) then
d2558 3
d2739 1
a2739 1
       "$Id: HGrid.f90,v 2.121 2015/03/28 02:45:56 vsnyder Exp $"
d2751 3
@


2.121
log
@Get IsMonotonic from Monotone instead of MLSFillValues.  Save HGrid type.
@
text
@d52 2
a53 2
    & ( name, root, filedatabase, l2gpDatabase, processingRange, chunk, &
    & onlyComputingOffsets ) result ( hGrid )
d201 1
a201 1
      case ( f_type )
d205 2
a206 3
      case ( f_module )
        instrumentModule = sub_rosa(subtree(2,son))
        call get_string ( instrumentModule , instrumentModuleName )
d211 3
d217 3
a219 1
      case ( f_mif )
d221 12
a232 1
        mif = nint(expr_value(1))
d239 1
a239 1
      case ( f_fraction )
d241 4
a244 9
        fraction = expr_value(1)
      case ( f_insetOverlaps )
        insetOverlaps = get_boolean ( fieldValue )
      case ( f_interpolationFactor )
        call expr ( subtree(2,son), expr_units, expr_value )
        interpolationFactor = expr_value(1)
      case ( f_spacing )
        call expr ( subtree(2,son), expr_units, expr_value )
        spacing = expr_value(1)
a247 8
      case ( f_geodAngle )
        geodAngleNode = son
      case ( f_geodLat )
        geodLatNode = son
      case ( f_losAngle )
        losAngleNode = son
      case ( f_lon )
        lonNode = son
d254 5
a260 7
      case ( f_date )
        date = sub_rosa(subtree(2,son))
      case ( f_sourceL2gp )
        l2gp => l2gpDatabase(decoration(decoration(subtree(2,son))))
      case ( f_inclination )
        call expr (subtree ( 2, son), expr_units, expr_value )
        incline = expr_value(1) !??? Never used
d286 1
a286 1
    case ( l_explicit ) ! ----------------- Explicit ------------------
d291 1
a291 16
    case ( l_regular ) ! ----------------------- Regular --------------
      if (.not. got_field(f_module) ) then
        call announce_error ( root, NoModule )
      else if ( .not. all(got_field((/f_spacing, f_origin/)))) then
        call announce_error ( root, NoSpacingOrigin )
      else if (.not. NEED_L1BFILES ) then
        call announce_error ( root, NoL1BFILES )
      else
        call CreateRegularHGrid ( filedatabase, processingRange, chunk, &
          & spacing, origin, trim(instrumentModuleName), extendible, &
          & forbidOverspill, &
          & maxLowerOverlap, maxUpperOverlap, insetOverlaps, single, hGrid, &
          & onlyComputingOffsets )
      end if

    case ( l_l2gp) ! -------------------- L2GP ------------------------
d321 16
d649 1
d2169 1
a2169 1
    use allocate_deallocate, only: allocate_test, deallocate_test, &
d2171 3
a2173 3
    use chunks_m, only: mlschunk_t
    use chunkDivide_m, only: chunkDivideConfig
    use dump_0, only: dump
d2175 2
a2176 2
    use highOutput, only: beVerbose, letsDebug, outputNamedValue
    use init_tables_module, only: z_construct, s_hgrid, z_output
d2181 1
a2181 1
    use moretree, only: get_spec_id
d2186 5
a2190 5
    use output_m, only: blanks, output, revertOutput, switchOutput
    use toggles, only: gen, levels, switches, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: subtree, node_id, decoration
    use tree_types, only: n_named
d2259 3
a2261 2
                    & firstHGrid(chunk) = CreateHGridFromMLSCFInfo ( 0, key, filedatabase, l2gpDatabase, &
                    & processingRange, chunks(chunk), onlyComputingOffsets=.true. )
d2738 1
a2738 1
       "$Id: HGrid.f90,v 2.120 2015/03/10 23:40:18 pwagner Exp $"
d2750 3
@


2.120
log
@Revert maf component of HGrid to being relative, not absolute
@
text
@d265 1
d735 1
a735 1
      call ReadL1BData ( L1BFile, l1bItemName, l1bField,noMAFs, &
d869 1
a869 1
    use MLSFillvalues, only: ismonotonic, monotonize
d876 1
d2735 1
a2735 1
       "$Id: HGrid.f90,v 2.119 2015/03/10 00:20:53 pwagner Exp $"
d2747 3
@


2.120.2.1
log
@Treat HGrid%forbidOverspill properly
@
text
@d124 1
d174 1
d211 1
a211 1
        hGrid%forbidOverspill = get_boolean ( fieldValue )
d264 1
d300 1
d843 1
a843 1
    & spacing, origin, instrumentModuleName, extendible, &
d887 1
d1156 1
a1156 1
      call output ( hGrid%forbidoverspill, advance='yes' )
d1369 1
a1369 1
    if ( hGrid%forbidOverspill ) then
d2317 1
a2317 1
    if ( DEEBUG .or. verbose ) then
d2331 3
a2333 1
      call output ( (/ sum1, sum2, sum3 /), advance='yes' )
a2338 1
    if ( verbose ) call output( (/ 1, chunks(1)%hGridOffsets(1) /), advance='yes' )
a2341 1
      if ( verbose ) call output( (/ chunk, chunks(chunk)%hGridOffsets(1) /), advance='yes' )
d2354 1
a2354 1
    if ( DEEBUG .or. verbose ) then
d2359 1
a2359 3
      & chunks(1)%noMAFsLowerOverlap > 0 .and. firstHGrid(1)%forbidOverspill ) then
      ! This dubious sequence disallows the very Prior overlaps you pretended to
      ! allow
a2554 3
    if ( lastProfile > chunk%hGridTotals(1) ) then
      call output ( 'Uh-oh, last profile beyond chunk grand total', advance='yes' )
    endif
d2733 1
a2733 1
       "$Id: HGrid.f90,v 2.120 2015/03/10 23:40:18 pwagner Exp $"
d2744 1
a2744 4
! $Log: HGrid.f90,v $                                                     
! Revision 2.120  2015/03/10 23:40:18  pwagner
! Revert maf component of HGrid to being relative, not absolute
!
@


2.119
log
@Many diagnostics added; HGrid%maf now stores absolute maf
@
text
@d359 2
a360 1
    hgrid%maf = hgrid%maf + chunk%firstMAFIndex - 1
d2207 1
a2207 1
    type(HGrid_T), dimension(:), pointer :: FirstHGrid     ! The "std" HGrid
a2227 3
    nullify ( FirstHGrid )
    allocate( FirstHGrid(size(chunks)), stat=status )
    call test_allocate ( status, moduleName, "FirstHGrid" )
a2408 2
    deallocate( FirstHGrid, stat=status )
    call test_deallocate ( status, moduleName, "FirstHGrid" )
d2568 2
a2569 2
    lowMAF = hgrid%maf(1)
    highMAF = hgrid%maf(hGrid%noProfs)
d2733 1
a2733 1
       "$Id: HGrid.f90,v 2.118 2014/09/05 01:02:36 vsnyder Exp $"
d2745 3
@


2.118
log
@More complete and accurate allocate/deallocate size tracking.
Add some tracing.  Correct some names to be reported to Allocate_Test.
Plug a potential memory leak.
@
text
@d29 4
a32 3
  integer, private :: ERROR
  logical, parameter     :: DEEBUG = .false.
  logical, parameter :: DONTPAD = .false.
d55 5
a59 3
    use CHUNKS_M, only: MLSCHUNK_T
    use EXPR_M, only: EXPR
    use HGRIDSDATABASE, only: HGRID_T, CREATEEMPTYHGRID, NULLIFYHGRID
d61 3
a63 3
      & f_extendible, f_forbidOverspill, f_fraction, f_geodAngle, f_geodLat, &
      & f_height, f_inclination, f_insetOverlaps, f_interpolationFactor, &
      & f_lon, f_losAngle, f_maxLowerOverlap, f_maxUpperOverlap, f_mif, &
d65 1
a65 1
      & f_single, f_solarTime, f_solarZenith, f_sourceL2gp, f_spacing, &
d70 15
a84 15
    use L1BDATA, only: DEALLOCATEL1BDATA, L1BDATA_T, READL1BDATA, &
      & ASSEMBLEL1BQTYNAME
    use L2GPDATA, only: L2GPDATA_T
    use MLSCOMMON, only: MLSFILE_T, NAMELEN, TAI93_RANGE_T
    use MLSFILES, only: GETMLSFILEBYTYPE
    use MLSKINDS, only: RK => R8
    use MLSL2OPTIONS, only: NEED_L1BFILES
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_L1BREAD
    use MLSNUMERICS, only: HUNT
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MORETREE, only: GET_BOOLEAN
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
d120 1
a120 1

d150 1
a150 1
      & cond=toggle(gen) .and. levels(gen) > 1 )
d152 7
a158 3
    mySuppressGeometryDump = .false.
    if ( present ( onlyComputingOffsets ) ) &
      & mySuppressGeometryDump = onlyComputingOffsets
d160 1
a160 1
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
d340 21
a360 5
      & l1bFlag, firstMAF=chunk%firstMAFIndex, &
      & lastMAF=chunk%lastMAFIndex, &
      & dontPad=DONTPAD )
    call Hunt ( l1bField%dpField(1,1,:), hgrid%time(1,:), hgrid%maf, allowTopValue=.true. )

d370 1
a370 1
      & cond=toggle(gen) .and. levels(gen) > 1 )
d379 13
a391 13
    use DATES_MODULE, only: UTC2TAI93S
    use EXPR_M, only: EXPR
    use HIGHOUTPUT, only: BEVERBOSE, OUTPUTNAMEDVALUE
    use GLOBAL_SETTINGS, only: LEAPSECFILENAME
    use HGRIDSDATABASE, only: CREATEEMPTYHGRID, HGRID_T
    use INIT_TABLES_MODULE, only: PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_TIME
    use MLSKINDS, only: RK => R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use SDPTOOLKIT, only: MLS_UTCTOTAI
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: NSONS, SUBTREE
d437 1
a437 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d536 1
a536 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d546 17
a562 16
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use CHUNKS_M, only: MLSCHUNK_T
    use DUMP_0, only: DUMP
    use HGRIDSDATABASE, only: CREATEEMPTYHGRID, DUMP, HGRID_T, TRIMHGRID
    use INIT_TABLES_MODULE, only: F_FRACTION, F_GEODANGLE, F_GEODLAT, F_HEIGHT, &
      & F_LON, F_LOSANGLE, F_MIF, F_TIME, &
      & F_SOLARTIME, F_SOLARZENITH, L_FIXED, L_FRACTIONAL, L_HEIGHT, L_MIF
    use L1BDATA, only: DEALLOCATEL1BDATA, L1BDATA_T, READL1BDATA, &
      & ASSEMBLEL1BQTYNAME
    use MLSCOMMON, only: MLSFILE_T, NAMELEN
    use MLSFILES, only: GETMLSFILEBYTYPE
    use MLSKINDS, only: RK => R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_L1BREAD
    use MLSNUMERICS, only: HUNT, INTERPOLATEVALUES
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d595 1
d617 1
a617 1

d619 1
a619 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d819 1
d824 2
d836 1
a836 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d854 24
a877 24
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG
    use CHUNKS_M, only: MLSCHUNK_T, DUMP
    use CONSTANTS, only: DEG2RAD, RAD2DEG
    use DATES_MODULE, only: UTC_TO_TIME
    use DUMP_0, only: DIFF, DUMP, selfdiff
    use EMPIRICALGEOMETRY, only: EMPIRICALLONGITUDE, CHOOSEOPTIMUMLON0
    use HGRIDSDATABASE, only: CREATEEMPTYHGRID, HGRID_T, TRIMHGRID, FINDCLOSESTMATCH
    use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
    use L1BDATA, only: DEALLOCATEL1BDATA, L1BDATA_T, READL1BDATA, &
      & ASSEMBLEL1BQTYNAME
    use MLSCOMMON, only: MLSFILE_T, NAMELEN, TAI93_RANGE_T
    use MLSFILES, only: HDFVERSION_5, DUMP, GETMLSFILEBYTYPE
    use MLSFILLVALUES, only: ISMONOTONIC, MONOTONIZE
    use MLSHDF5, only: ISHDF5ATTRIBUTEINFILE
    use MLSKINDS, only: RK => R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
    use MLSNUMERICS, only: HUNT, INTERPOLATEVALUES, SOLVEQUADRATIC
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MLSSTRINGS, only: HHMMSS_VALUE
    use OUTPUT_M, only: OUTPUT
    use STRING_TABLE, only: DISPLAY_STRING
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d896 1
d943 1
a943 1

d945 1
a945 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d1133 1
d1343 1
a1343 1

d1351 1
d1478 1
a1478 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d1507 1
a1507 1
        & cond=toggle(gen) .and. levels(gen) > 0 )
d1592 1
a1592 1
        & cond=toggle(gen) .and. levels(gen) > 0 )
d1598 1
a1598 1
      use MLSNUMERICS, only: CLOSESTELEMENT
d1612 1
a1612 1
        & cond=toggle(gen) .and. levels(gen) > 0 )
d1625 1
a1625 1
        & cond=toggle(gen) .and. levels(gen) > 0 )
d1704 1
a1704 1
        & cond=toggle(gen) .and. levels(gen) > 0 )
d1893 1
a1893 1
        & cond=toggle(gen) .and. levels(gen) > 0 )
d1900 7
a1906 6
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use CHUNKDIVIDE_M, only: OBSTRUCTION_T
    use HGRIDSDATABASE, only: HGRID_T, CREATEEMPTYHGRID, DESTROYHGRIDCONTENTS
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_WARNING
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d1915 1
d1928 1
a1928 1

d1930 1
a1930 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d1992 1
a1992 1
      & cond=toggle(gen) .and. levels(gen) > 0 )
d2001 9
a2009 9
    use CHUNKS_M, only: MLSCHUNK_T
    use HGRIDSDATABASE, only: HGRID_T
    use L1BDATA, only: DEALLOCATEL1BDATA, L1BDATA_T, READL1BDATA, &
      & ASSEMBLEL1BQTYNAME
    use MLSCOMMON, only: MLSFILE_T, NAMELEN
    use MLSFILES, only: GETMLSFILEBYTYPE
    use MLSKINDS, only: R8
    use OUTPUT_M, only: OUTPUT
    use STRING_TABLE, only: DISPLAY_STRING
a2052 1

d2164 15
a2178 11
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use CHUNKS_M, only: MLSCHUNK_T
    use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG
    use HGRIDSDATABASE, only: HGRID_T, DESTROYHGRIDCONTENTS, DUMP
    use INIT_TABLES_MODULE, only: Z_CONSTRUCT, S_HGRID, Z_OUTPUT
    use L2GPDATA, only: L2GPDATA_T
    use MLSCOMMON, only: MLSFILE_T, TAI93_RANGE_T
    use MLSL2OPTIONS, only: SPECIALDUMPFILE
    use MORETREE, only: GET_SPEC_ID
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSSTRINGLISTS, only: SWITCHDETAIL
d2181 5
a2185 5
    use OUTPUT_M, only: BLANKS, OUTPUT, REVERTOUTPUT, SWITCHOUTPUT
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: SUBTREE, NODE_ID, DECORATION
    use TREE_TYPES, only: N_NAMED
d2196 1
d2204 3
a2206 1
    type(HGrid_T) :: DUMMYHGRID         ! A temporary hGrid
d2210 3
d2214 3
d2226 4
d2233 1
d2253 1
d2256 3
d2280 1
a2280 1
                  if ( switchDetail(switches, 'hgrid') >= 0 .and. DEEBUG ) &
d2295 1
d2299 2
d2317 1
d2319 1
a2319 1
    if ( switchDetail(switches, 'hgrid') >= 0 .and. DEEBUG ) then
d2350 1
a2350 1
    ! Each hGridOffsets will now contain the last profile index in the preceeding
d2355 2
a2356 1
    if ( switchDetail(switches, 'pro') >= 0 .or. DEEBUG ) then
d2362 1
d2371 1
a2371 1
    if ( switchDetail(switches, 'pro') >= 0 .or. DEEBUG ) then
d2383 26
d2411 2
d2446 1
a2446 1
    use HGRIDSDATABASE, only: HGRID_T
d2470 3
a2472 3
    use LEXER_CORE, only: PRINT_SOURCE
    use OUTPUT_M, only: OUTPUT
    use TREE, only: WHERE_AT => WHERE
d2500 43
a2542 1
    end subroutine ANNOUNCE_ERROR
d2544 188
a2731 41
    subroutine PlaceArray_r4(array1, array2, offset)
      ! place contents of array1 inside array2, possibly offset
      use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
      integer, parameter :: R4 = kind(0.0e0)
      ! Args
      real(r4), dimension(:,:), intent(in)     :: array1
      real(r4), dimension(:,:), intent(inout)  :: array2
      integer, intent(in) :: offset ! Where inside array2 to place array
      ! Internal variables
      integer :: N
      ! Executable
      N = size(array1, 2)
      if ( size(array1, 1) /= size(array2, 1) ) &
        & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/PlaceArray_r4', &
        & 'array sizes mismatched in first index' )
      if ( N+offset > size(array2, 2) ) &
        & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/PlaceArray_r4', &
        & 'array1 too big to place in array2 with given offset' )
      array2(:, 1+offset:N+offset) = array1
    end subroutine PlaceArray_r4

    subroutine PlaceArray_r8(array1, array2, offset)
      ! place contents of array1 inside array2, possibly offset
      use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
      integer, parameter :: R8 = kind(0.0d0)
      ! Args
      real(r8), dimension(:,:), intent(in)     :: array1
      real(r8), dimension(:,:), intent(inout)  :: array2
      integer, intent(in) :: offset ! Where inside array2 to place array
      ! Internal variables
      integer :: N
      ! Executable
      N = size(array1, 2)
      if ( size(array1, 1) /= size(array2, 1) ) &
        & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/PlaceArray_r4', &
        & 'array sizes mismatched in first index' )
      if ( N+offset > size(array2, 2) ) &
        & call MLSMessage ( MLSMSG_Error, trim(ModuleName) // '/PlaceArray_r4', &
        & 'array1 too big to place in array2 with given offset' )
      array2(:, 1+offset:N+offset) = array1
    end subroutine PlaceArray_r8
d2737 1
a2737 1
       "$Id: HGrid.f90,v 2.117 2014/09/05 00:49:06 vsnyder Exp $"
d2749 5
@


2.117
log
@EmpiricalGeometry.f90
@
text
@d2460 1
a2460 1
       "$Id: HGrid.f90,v 2.116 2014/08/06 23:30:29 vsnyder Exp $"
d2472 3
@


2.116
log
@Remove CoordIndex, which is set but not referenced
@
text
@d146 3
a162 2
    call trace_begin ( me, "CreateHGridFromMLSCFInfo", root, &
      & cond=toggle(gen) .and. levels(gen) > 1 )
d263 1
a263 1
      elseif (.not. NEED_L1BFILES ) then
d272 1
a272 1
        endif
d288 1
a288 1
      elseif (.not. NEED_L1BFILES ) then
d366 2
d388 1
d412 3
d420 1
a420 1
    elseif ( geodLatNode /= 0 ) then
d422 1
a422 1
    elseif ( solarTimeNode /= 0 ) then
d424 1
a424 1
    elseif ( solarZenithNode /= 0 ) then
d426 1
a426 1
    elseif ( lonNode /= 0 ) then
d428 1
a428 1
    elseif ( losAngleNode /= 0 ) then
d430 1
a430 1
    endif
d451 1
a451 1
      endif
d512 3
d537 2
d574 1
d593 3
d686 1
a686 1
    endif
d693 3
a695 3
    call allocate_test ( interpolatedField, hGrid%noProfs, 'defaultField', ModuleName )
    call allocate_test ( defaultIndex, noMAFs, 'defaultField', ModuleName )
    call allocate_test ( interpolatedIndex, hGrid%noProfs, 'defaultField', ModuleName )
d806 4
a809 1
    
d848 2
a849 1
    use TOGGLES, only: SWITCHES
d890 1
d899 1
a899 1
    real(rk), dimension(:,:), pointer :: OldMethodValues=> null() ! For comparing with
d914 3
d926 1
a926 1
    endif
d938 1
a938 1
      enddo
d940 1
a940 1
    endif
d949 1
a949 1
    endif
d982 1
a982 1
    endif
d1003 1
a1003 1
    elseif ( i < noMAFsInFile + 1 ) then
d1061 1
a1061 1
    endif
d1085 1
a1085 1
          endif
d1212 1
a1212 1
      endif
d1240 2
a1241 2
      endif
    endif
d1285 1
a1285 1
    endif
d1411 1
a1411 1
          & ( hGrid%noProfsLowerOverlap > maxLowerOverlap ) ) &
d1413 1
d1415 1
a1415 1
          & ( hGrid%noProfsUpperOverlap > maxUpperOverlap ) ) &
d1417 1
d1442 1
d1446 3
d1450 2
a1451 2
    subroutine GetApparentLocalSolarTime( L1BFile, instrumentModuleName, chunk, &
        & HGrid )
d1463 1
d1472 1
d1474 4
a1477 1
      nullify( GMT, MAFLongitude, MAFTime, &
d1501 1
a1501 1
      call allocate_test(SolarTimeCalibration, noMAFs, 'SolarLongitude', ModuleName)
d1527 1
a1527 1
      enddo
d1551 1
a1551 1
      enddo
d1559 4
d1565 1
a1565 1
    subroutine closestApparentLocalSolarZenith( allGeodAngle, allSolarZenith, &
d1567 1
a1567 1
    use MLSNUMERICS, only: CLOSESTELEMENT
d1577 1
d1579 3
d1590 1
a1590 1
        endif
d1592 4
a1595 1
      enddo
d1598 1
a1598 1
    subroutine GetApparentLocalSolarZenith(L1BFile, hGrid, solarZenithAtMIF1, &
d1655 1
d1669 1
d1671 4
d1756 1
a1756 1
        endif
d1778 1
a1778 1
            endif
d1783 3
a1785 3
            endif
          enddo
        enddo
d1793 1
a1793 1
      endif
d1833 1
a1833 1
          elseif ( (c - a*r2)/b > 0._rk ) then
d1838 2
a1839 2
          endif
        endif
d1843 1
a1843 1
      enddo
d1856 1
a1856 1
      enddo
d1860 3
d1873 2
d1886 1
d1895 3
d1923 2
a1924 2
      endif
    enddo
d1940 1
a1940 1
      enddo
d1944 1
a1944 1
      endif
d1948 1
a1948 1
      endif
d1953 1
a1953 1
      endif
d1955 1
a1955 1
    endif
d1957 4
d1967 1
a1974 2
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, &
      & MLSMSG_DEALLOCATE, MLSMSG_ERROR
d2049 1
a2049 4
    allocate ( text ( noBins, noLines ), stat=flag )
    if ( flag /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'text' )
    text = ' '
d2120 2
a2121 3
    deallocate ( text, stat=flag )
    if ( flag /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'text' )
d2146 1
a2146 1
    use TOGGLES, only: GEN, SWITCHES, TOGGLE
d2172 2
a2173 1
    call trace_begin ( me, "ComputeAllHGridOffsets", root, cond=toggle(gen) )
d2213 2
a2214 2
                    endif
                  elseif ( chunk == size(chunks) ) then
d2221 1
a2221 1
                    endif
d2225 1
a2225 1
                  endif
d2243 1
a2243 1
      ! are, setup our arrays
d2278 1
a2278 1
    endif
d2300 1
a2300 1
    endif
d2306 1
a2306 1
      enddo
d2309 1
a2309 1
    endif
d2321 1
a2321 1
    endif
d2325 2
a2326 1
    call trace_end ( "ComputeAllHGridOffsets", cond=toggle(gen) )
d2332 1
a2332 1
    use Allocate_Deallocate, only :ALLOCATE_TEST
d2460 1
a2460 1
       "$Id: HGrid.f90,v 2.115 2014/08/01 01:45:52 vsnyder Exp $"
d2472 3
@


2.115
log
@Remove unreferenced USE names
@
text
@a95 1
    integer :: coordIndex               ! Tree node
a195 1
        coordIndex = field
d2398 1
a2398 1
       "$Id: HGrid.f90,v 2.114 2014/04/24 23:56:43 pwagner Exp $"
d2410 3
@


2.114
log
@May set master coordinate in hGrid specification
@
text
@d817 1
a817 1
    use HIGHOUTPUT, only: BEVERBOSE, OUTPUTNAMEDVALUE
d2324 1
a2324 1
    use TREE, only: DUMP_TREE_NODE, WHERE_AT => WHERE
d2400 1
a2400 1
       "$Id: HGrid.f90,v 2.113 2014/03/18 17:15:09 pwagner Exp $"
d2412 3
@


2.113
log
@Can get leapseconds from dates module if run sans toolkit
@
text
@d57 10
a66 10
    use INIT_TABLES_MODULE, only: F_DATE, &
      & F_EXTENDIBLE, F_FORBIDOVERSPILL, F_FRACTION, F_GEODANGLE, F_GEODLAT, &
      & F_HEIGHT, F_INCLINATION, F_INSETOVERLAPS, F_INTERPOLATIONFACTOR, &
      & F_LON, F_LOSANGLE, F_MAXLOWEROVERLAP, F_MAXUPPEROVERLAP, F_MIF, &
      & F_MODULE, F_ORIGIN, &
      & F_SINGLE, F_SOLARTIME, F_SOLARZENITH, F_SOURCEL2GP, F_SPACING, &
      & F_TIME, F_TYPE, &
      & FIELD_FIRST, FIELD_LAST, &
      & L_EXPLICIT, L_FIXED, L_FRACTIONAL, L_HEIGHT, &
      & L_L2GP, L_REGULAR
d96 1
d196 3
d696 1
a696 1
        & neverfail=MissingOK, dontPad=.true. )
d814 1
a814 1
    use DUMP_0, only: DIFF, DUMP
d817 1
d903 1
d1147 2
a1148 1
      call dump(l1bField%DpField(1,1,:), trim(l1bItemName) // ' (before interpolating)')
d1151 2
d2400 1
a2400 1
       "$Id: HGrid.f90,v 2.112 2014/03/01 03:10:56 vsnyder Exp $"
d2412 3
@


2.112
log
@Move units checking to init_tables_module
@
text
@d353 1
a353 1
    use SDPTOOLKIT, only: MLS_UTCTOTAI
d355 2
d361 2
a363 2
    use STRING_TABLE, only: GET_STRING
    use GLOBAL_SETTINGS, only: LEAPSECFILENAME
d378 3
a380 1
    integer :: PROF                     ! Loop counter
d382 1
d384 2
a385 1
    integer :: NODE                     ! A tree node
d388 1
a388 4
    integer :: EXPR_UNITS(2)            ! Output from Expr subroutine
    real(rk) :: EXPR_VALUE(2)   ! Output from Expr subroutine
    integer :: RETURNSTATUS             ! Flag
    character(len=80) :: DATESTRING
d406 1
d434 9
a442 1
      returnStatus = mls_utctotai ( trim(LeapSecFileName), trim(dateString), hGrid%time(1,1) )
d2391 1
a2391 1
       "$Id: HGrid.f90,v 2.111 2014/01/11 01:44:18 vsnyder Exp $"
d2403 3
@


2.111
log
@Decruftification
@
text
@d39 1
a39 3
  integer, private, parameter :: AngleUnitMessage = 1
  integer, private, parameter :: LengthUnitMessage = AngleUnitMessage + 1
  integer, private, parameter :: NoFraction = LengthUnitMessage + 1
d41 1
a41 2
  integer, private, parameter :: UnitlessMessage = NoHeight + 1
  integer, private, parameter :: NoL1Bfiles = UnitlessMessage + 1
d66 1
a66 1
      & L_L2GP, L_REGULAR, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_LENGTH
a204 2
        if ( expr_units(1) /= PHYQ_Length) &
          & call announce_error ( field, lengthUnitMessage )
d207 1
a207 3
        mif = expr_value(1)
        if ( expr_units(1) /= PHYQ_Dimensionless) &
          & call announce_error ( field, lengthUnitMessage )
d210 1
a210 3
        maxLowerOverlap = expr_value(1)
        if ( expr_units(1) /= PHYQ_Dimensionless) &
          & call announce_error ( field, unitlessMessage )
d213 1
a213 3
        maxUpperOverlap = expr_value(1)
        if ( expr_units(1) /= PHYQ_Dimensionless) &
          & call announce_error ( field, unitlessMessage )
a216 2
        if ( expr_units(1) /= PHYQ_Dimensionless) &
          & call announce_error ( field, unitlessMessage )
a221 2
        if ( expr_units(1) /= PHYQ_Dimensionless) &
          & call announce_error ( field, unitlessMessage )
a224 2
        if ( expr_units(1) /= PHYQ_Angle) &
          & call announce_error ( field, angleUnitMessage )
a227 2
        if ( expr_units(1) /= PHYQ_Angle) &
          & call announce_error ( field, angleUnitMessage )
a2312 10
    case ( angleUnitMessage )
      call output ( "Value for the " )
      call dump_tree_node ( where, 0 )
      call output ( " field is required to be an angle, e.g. degrees", &
        advance='yes' )
    case ( lengthUnitMessage )
      call output ( "Value for the " )
      call dump_tree_node ( where, 0 )
      call output ( " field is required to be a length, e.g. km", &
        advance='yes' )
a2329 4
    case ( unitlessMessage )
      call output ( "Value for the " )
      call dump_tree_node ( where, 0 )
      call output ( " field is required to be dimensionless", advance='yes' )
d2379 1
a2379 1
       "$Id: HGrid.f90,v 2.110 2013/12/12 02:11:26 vsnyder Exp $"
d2391 3
@


2.110
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d2088 1
a2088 1
    use TREE, only: SUBTREE, NSONS, NODE_ID, DECORATION
a2097 1
    integer :: LINE                     ! Line in l2cf
d2412 1
a2412 1
       "$Id: HGrid.f90,v 2.109 2013/10/01 22:17:51 pwagner Exp $"
d2424 3
@


2.109
log
@Added maf component to HGrid_T
@
text
@d2067 1
a2067 1
  subroutine ComputeAllHGridOffsets ( root, treeindex, chunks, filedatabase, &
d2069 3
a2071 1
    ! This routine goes through the L1 file and works out how big each HGrid is going to be
d2083 2
d2091 2
a2092 2
    integer, intent(in) :: ROOT         ! Tree node for whole l2cf
    integer, intent(in) :: treeindex    ! Where in the tree are we
a2097 1
    integer :: SECTION                  ! Index of section
a2101 1
    integer :: HowMany                  ! How many sons does Root have?
d2109 2
a2119 1
    howMany = nsons(root)
a2121 1
      section = treeindex
d2124 4
a2127 2
      sectionLoop: do while ( section <= howMany )
        son = subtree ( section, root )
d2131 4
a2134 2
          do line = 2, nsons ( son ) - 1 ! Skip begin and end
            gson = subtree ( line, son )
a2179 1
        section = section + 1
d2413 1
a2413 1
       "$Id: HGrid.f90,v 2.108 2013/09/24 23:47:22 vsnyder Exp $"
d2425 3
@


2.108
log
@Use Where instead of Source_Ref for messages
@
text
@d18 2
a19 2
  public :: CreateHGridFromMLSCFInfo, ComputeNextChunksHGridOffsets, &
    & ComputeAllHGridOffsets, DealWithObstructions
d57 1
a57 1
    use Chunks_m, only: MLSChunk_T
d59 1
a59 1
    use HGridsDatabase, only: HGRID_T, CREATEEMPTYHGRID, NULLIFYHGRID
d70 11
a80 11
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName
    use L2GPData, only: L2GPDATA_T
    use MLSCommon, only: MLSFile_T, NameLen, TAI93_RANGE_T
    use MLSFiles, only: GetMLSFileByType
    use MLSKinds, only: RK => R8
    use MLSL2Options, only: NEED_L1BFILES
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
    use MLSNumerics, only: HUNT
    use MLSStringLists, only: SwitchDetail
    use MoreTree, only: GET_BOOLEAN
d345 8
d372 1
a372 1
    use SDPToolkit, only: MLS_UTCTOTAI
d374 1
a374 1
    use HGridsDatabase, only: CREATEEMPTYHGRID, HGRID_T
d376 2
a377 2
    use MLSKinds, only: RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d379 2
a380 2
    use String_table, only: GET_STRING
    use Global_Settings, only: LEAPSECFILENAME
d518 4
a521 4
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Chunks_m, only: MLSChunk_T
    use Dump_0, only: DUMP
    use HGridsDatabase, only: CREATEEMPTYHGRID, DUMP, HGRID_T, TRIMHGRID
d525 7
a531 7
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName
    use MLSCommon, only: MLSFile_T, NameLen
    use MLSFiles, only: GetMLSFileByType
    use MLSKinds, only: RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
    use MLSNumerics, only: HUNT, InterpolateValues
d812 19
a830 19
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use ChunkDivide_m, only: ChunkDivideConfig
    use Chunks_m, only: MLSChunk_T, Dump
    use Constants, only: DEG2RAD, RAD2DEG
    use Dates_module, only: utc_to_time
    use Dump_0, only: DIFF, DUMP
    use EmpiricalGeometry, only: EmpiricalLongitude, ChooseOptimumLon0
    use HGridsDatabase, only: CREATEEMPTYHGRID, HGRID_T, TRIMHGRID, FINDCLOSESTMATCH
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName
    use MLSCommon, only: MLSFile_T, NameLen, TAI93_RANGE_T
    use MLSFiles, only: HDFVERSION_5, Dump, GetMLSFileByType
    use MLSFillValues, only: isMonotonic, Monotonize
    use MLSHDF5, only: IsHDF5AttributeInFile
    use MLSKinds, only: RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSNumerics, only: HUNT, InterpolateValues, SolveQuadratic
    use MLSStringLists, only: SwitchDetail
    use MLSStrings, only: hhmmss_value
d832 1
a832 1
    use String_Table, only: Display_String
d1528 1
a1528 1
    use MLSNumerics, only: CLOSESTELEMENT
d1814 4
a1817 4
    use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
    use ChunkDivide_m, only: Obstruction_T
    use HGridsDatabase, only: HGRID_T, CreateEmptyHGrid, DestroyHGridContents
    use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
d1902 9
a1910 9
    use Chunks_m, only: MLSChunk_T
    use HGridsDatabase, only: HGRID_T
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName
    use MLSCommon, only: MLSFile_T, NameLen
    use MLSFiles, only: GetMLSFileByType
    use MLSKinds, only: R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_allocate, &
      & MLSMSG_DeAllocate, MLSMSG_Error
d1912 1
a1912 1
    use String_Table, only: DISPLAY_STRING
d2070 11
a2080 11
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use Chunks_m, only: MLSChunk_T
    use ChunkDivide_m, only: ChunkDivideConfig
    use HGridsDatabase, only: HGRID_T, DESTROYHGRIDCONTENTS, DUMP
    use Init_Tables_Module, only: Z_CONSTRUCT, S_HGRID, Z_OUTPUT
    use L2GPData, only: L2GPDATA_T
    use MLSCommon, only: MLSFILE_T, TAI93_RANGE_T
    use MLSL2Options, only: SPECIALDUMPFILE
    use MoreTree, only: GET_SPEC_ID
    use MLSMessageModule, only: MLSMessage, MLSMSG_ERROR
    use MLSStringLists, only: SwitchDetail
d2084 1
a2084 1
    use Tree, only: SUBTREE, NSONS, NODE_ID, DECORATION
d2292 1
a2292 1
    use HGridsDatabase, only: HGRID_T
d2318 1
a2318 1
    use TREE, only: DUMP_TREE_NODE, Where_At => Where
d2364 1
a2364 1
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d2385 1
a2385 1
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d2408 1
a2408 1
       "$Id: HGrid.f90,v 2.107 2013/08/30 02:45:41 vsnyder Exp $"
d2420 3
@


2.107
log
@Revise calls to trace_begin and trace_end
@
text
@d2310 1
a2310 1
    use TREE, only: DUMP_TREE_NODE, SOURCE_REF
d2317 1
a2317 1
    call print_source ( source_ref(where) )
d2400 1
a2400 1
       "$Id: HGrid.f90,v 2.106 2013/08/21 00:25:04 pwagner Exp $"
d2412 3
@


2.106
log
@Removed a debugging remnant dumped when overriding geolocations
@
text
@d99 1
a99 1
    integer :: DATE                 ! Tree node
d102 1
d106 2
a107 1
    real(rk) :: fraction, height
a108 1
    type (L2GPData_T), pointer :: L2GP  ! The l2gp to use 
d163 2
a164 2
    if ( toggle(gen) .and. levels(gen) > 1 ) &
      & call trace_begin ( "CreateHGridFromMLSCFInfo", root )
d354 2
a355 2
    if ( toggle(gen) .and. levels(gen) > 1 ) &
      & call trace_end ( "CreateHGridFromMLSCFInfo" )
d2058 1
a2058 1
  ! ------------------------------------------------ ComputeAllHGridOffsets ---
d2092 1
d2101 1
a2101 1
    if ( toggle(gen) ) call trace_begin ( "ComputeAllHGridOffsets", root )
d2252 1
a2252 1
    if ( toggle(gen) ) call trace_end ( "ComputeAllHGridOffsets" )
d2255 1
a2255 1
  ! ------------------------------------- ComputeNextChunksHGridOffsets --
d2400 1
a2400 1
       "$Id: HGrid.f90,v 2.105 2013/08/17 00:20:25 pwagner Exp $"
d2412 3
@


2.105
log
@Fixed HGrids may have geolocations overridden
@
text
@d665 1
a665 1
      call dump( hGrid )
d2398 1
a2398 1
       "$Id: HGrid.f90,v 2.104 2013/08/13 01:27:42 vsnyder Exp $"
d2410 3
@


2.104
log
@Get kind type parameters from MLSKinds instead of MLSCommon
@
text
@d61 1
a61 1
      & F_EXTENDIBLE, F_FORBIDOVERSPILL, F_FRACTION, F_GEODANGLE, &
d63 1
a63 1
      & F_MAXLOWEROVERLAP, F_MAXUPPEROVERLAP, F_MIF, &
d125 1
d129 2
d178 3
d248 6
d275 1
a275 1
    case ( l_height, l_fractional, l_fixed ) ! ----- Fractional or Height ------
d281 7
d294 3
a296 2
      call CreateExplicitHGrid ( son, date, geodAngleNode, solarTimeNode, &
        & solarZenithNode, processingRange%startTime, timeNode, hGrid )
d359 3
a361 2
  subroutine CreateExplicitHGrid ( key, date, geodAngleNode, solarTimeNode, &
    & solarZenithNode, time, timeNode, hGrid )
d375 1
a375 1
    integer, intent(in) :: DATE     ! Date if any
d377 3
d396 15
d413 1
a413 1

d415 13
a427 19
    if ( geodAngleNode /= 0 ) noProfs = nsons ( geodAngleNode ) - 1
    if ( solarTimeNode /= 0 ) then
      if ( noProfs /= 0 ) then
        if ( nsons ( solarTimeNode ) - 1 /= noProfs ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Inconsistent explicit hGrid definition' )
      else
        noProfs = nsons ( solarTimeNode ) - 1
      end if
    end if
    if ( solarZenithNode /= 0 ) then
      if ( noProfs /= 0 ) then
        if ( nsons ( solarZenithNode ) - 1 /= noProfs ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Inconsistent explicit hGrid definition' )
      else
        noProfs = nsons ( solarZenithNode ) - 1
      end if
    end if
d451 2
d456 1
a456 1
    do param = 1, 4
d458 1
a458 1
      case ( 1 )
d462 1
a462 1
      case ( 2 )
d466 1
a466 1
      case ( 3 )
d470 1
a470 1
      case ( 4 )
d474 12
d512 4
a515 3
    use HGridsDatabase, only: CREATEEMPTYHGRID, HGRID_T, TRIMHGRID
    use INIT_TABLES_MODULE, only: F_FRACTION, F_HEIGHT, &
      & F_MIF, L_FIXED, L_FRACTIONAL, L_HEIGHT, L_MIF
d559 1
d657 10
a666 3
    ! Create an empty hGrid
    hGrid%noProfs = NINT(noMAFs*interpolationFactor)
    call CreateEmptyHGrid(hGrid)
d690 2
a691 2
        & dontPad=.true. )
      if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2398 1
a2398 1
       "$Id: HGrid.f90,v 2.103 2013/08/13 00:58:54 vsnyder Exp $"
d2410 3
@


2.103
log
@Move SolveQuadratic into MLSNumerics
@
text
@d73 1
a73 1
    use MLSCommon, only: MLSFile_T, NameLen, RK => R8, TAI93_RANGE_T
d75 1
d346 1
a346 1
    use MLSCommon, only: RK => R8
d470 1
a470 1
    use MLSCommon, only: MLSFile_T, NameLen, RK => R8
d472 1
d1841 1
a1841 1
    use MLSCommon, only: MLSFile_T, NameLen, R8
d1843 1
d2292 1
a2292 1
      call output ( " field is required to dimensionless", advance='yes' )
a2297 1
      use MLSCommon, only: r4
d2299 1
a2318 1
      use MLSCommon, only: r8
d2320 1
d2342 1
a2342 1
       "$Id: HGrid.f90,v 2.102 2013/06/12 02:37:14 vsnyder Exp $"
d2354 3
@


2.102
log
@Cruft removal
@
text
@d761 1
a761 1
    use MLSNumerics, only: HUNT, InterpolateValues
a1742 48
    subroutine SolveQuadratic( a, b, c, r1, r2, imPart )
      ! Solve

      ! a x^2 + b x + c = 0

      ! for x = r1 + i imPart, and x = r2 - i imPart
      ! where i^2 = -1

      ! Of course because a, b, and c are all purely real
      ! if imPart /= 0, r1 = r2

      ! We bother with this to avoid truncation that would result
      ! from taking a difference between like-signed quantities
      ! b and + or - sqrt(disc)

      ! Special cases (which you may prefer to intercept yourself)
      ! If a = 0, we return the same root in both r1 and r2
      ! If a = b = 0, we divide c by zero
      real(rk), intent(in)  :: a, b, c
      real(rk), intent(out) :: r1, r2, imPart
      ! Local variables
      real(rk) :: disc ! b^2 - 4 a c
      ! Executable
      call output('a, b, c: ')
      call output( (/a, b, c/), advance='yes')
      imPart = 0.
      if ( a == 0._rk ) then
        ! strictly, in this degenerate case, the root is unique, not repeated
        r1 = -c/b
        r2 = r1
        return
      endif
      disc = b*b - 4*a*c
      if ( disc < 0._rk ) then
        imPart = sqrt(-disc) / (2*a)
        r1 = -b / (2*a)
        r2 = r1
      elseif ( b < 0._rk ) then
        r1 = ( -b + sqrt(disc) ) / (2*a)
        r2 = c / (a*r1)
      else
        r1 = ( -b - sqrt(disc) ) / (2*a)
        r2 = c / (a*r1)
      endif
      call output('r1, r2, imPart: ')
      call output( (/r1, r2, imPart/), advance='yes')
    end subroutine SolveQuadratic

d2339 1
a2339 1
       "$Id: HGrid.f90,v 2.101 2012/04/25 20:32:24 pwagner Exp $"
d2351 3
@


2.101
log
@Inserting missing profiles after chunk end now an option controlled by 'extendible' field
@
text
@d1469 1
a1469 1
      integer, dimension(2) :: indices(2)
d2387 1
a2387 1
       "$Id: HGrid.f90,v 2.100 2012/04/20 01:09:22 pwagner Exp $"
d2399 3
@


2.100
log
@Regular HGrids no longer drop profiles between chunks
@
text
@d61 1
a61 1
      & F_FORBIDOVERSPILL, F_FRACTION, F_GEODANGLE, &
d119 1
d163 1
d193 2
d286 2
a287 1
          & spacing, origin, trim(instrumentModuleName), forbidOverspill, &
d733 1
a733 1
    & spacing, origin, instrumentModuleName, forbidOverspill, &
d774 1
d934 16
a949 6
      last = origin + spacing * (1 + int ( (maxAngle-origin)/spacing ) )
      delta = last - maxAngle            ! So +ve means last could be smaller
      if ( delta > 3*spacing/2 ) then
        last = last - spacing
      else if ( delta < -spacing/2 ) then
        last = last + spacing
d993 5
a997 1
          if ( last < max( nextAngle, minAngleLastMAF ) ) exit setLastLoop
d1034 2
d2387 1
a2387 1
       "$Id: HGrid.f90,v 2.99 2011/06/29 21:54:26 pwagner Exp $"
d2399 3
@


2.99
log
@Some cases may safely omit l1b files
@
text
@d805 2
a806 1
    integer :: NOMAFS                   ! From ReadL1B
d866 1
a866 1
      & l1bField, noMAFs, flag, &
d909 1
a909 1
    elseif ( i < noMAFs + 1 ) then
d928 1
a928 1
      last = origin + spacing * int ( (maxAngle-origin)/spacing )
d930 1
a930 1
      if ( delta > spacing/2 ) then
d977 1
a977 1
          if ( last < minAngleLastMAF ) exit setLastLoop
d2091 1
a2091 1
                  ! For the 'zeroth' pass just count up the chunks
d2365 1
a2365 1
       "$Id: HGrid.f90,v 2.98 2011/03/10 21:39:11 pwagner Exp $"
d2377 3
@


2.98
log
@May now specify time in explicit hGrids
@
text
@d44 2
a45 1
  integer, private, parameter :: NoModule = UnitlessMessage + 1
d75 1
d148 3
a150 1
    if ( .not. associated(L1BFile) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d261 2
d278 2
d323 4
d2299 2
d2364 1
a2364 1
       "$Id: HGrid.f90,v 2.97 2010/03/23 23:26:03 honghanh Exp $"
d2376 3
@


2.97
log
@Add a case where single option is not set, but hgrid%noProfs is 1
then set overlap fields to 0.
@
text
@d59 9
a67 5
    use INIT_TABLES_MODULE, only: F_DATE, F_FORBIDOVERSPILL, F_FRACTION, F_GEODANGLE, &
      & F_HEIGHT, FIELD_FIRST, FIELD_LAST, F_INCLINATION, F_INSETOVERLAPS, &
      & F_INTERPOLATIONFACTOR, F_MAXLOWEROVERLAP, F_MAXUPPEROVERLAP, F_MIF, &
      & F_MODULE, F_ORIGIN, F_SINGLE, F_SOLARTIME, F_SOLARZENITH, F_SOURCEL2GP, &
      & F_SPACING, F_TYPE, L_EXPLICIT, L_FIXED, L_FRACTIONAL, L_HEIGHT, &
d119 1
d132 1
a132 1
    logical :: FORBIDOVERSPILL          ! If set don't allow overlaps beyond L1B
d166 1
d239 2
d265 1
a265 1
        & solarZenithNode, processingRange%startTime, hGrid )
d322 1
a322 1
    & solarZenithNode, time, hGrid )
d340 1
d402 2
a403 1
    do param = 1, 3
d417 4
d2350 1
a2350 1
       "$Id: HGrid.f90,v 2.96 2009/06/23 18:46:18 pwagner Exp $"
d2362 4
@


2.96
log
@Prevent Intel from optimizing ident string away
@
text
@d23 1
a23 1
       "$RCSfile: $"
d795 1
d1172 2
a1173 1
      & hGrid%noProfsLowerOverlap, allowTopValue=.true., allowBelowValue=.true. )
a1175 1

d1177 1
a1177 1
      & hGrid%noProfsUpperOverlap, allowTopValue=.true., allowBelowValue=.true. )
a1231 1

d1260 19
a1278 16
      ! Set up for no overlaps
      hGrid%noProfsLowerOverlap = 0
      hGrid%noProfsUpperOverlap = 0
      ! Delete all but the 'center' profile
      extra = hGrid%noProfs - 1
      left = extra / 2
      right = extra - left
      if ( left > 0 ) call TrimHGrid ( hGrid, -1, left )
      if ( right > 0 ) call TrimHGrid ( hGrid, 1, right )
    else
      if ( maxLowerOverlap >= 0 .and. &
        & ( hGrid%noProfsLowerOverlap > maxLowerOverlap ) ) &
        call TrimHGrid ( hGrid, -1, hGrid%noProfsLowerOverlap - maxLowerOverlap )
      if ( maxUpperOverlap >= 0 .and. &
        & ( hGrid%noProfsUpperOverlap > maxUpperOverlap ) ) &
        call TrimHGrid ( hGrid, 1, hGrid%noProfsUpperOverlap - maxUpperOverlap )
d2336 1
a2336 1
       "$Id: read_apriori.f90 is it here $"
d2348 3
@


2.95
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d23 1
a23 1
       "$RCSfile: HGrid.f90,v $"
d2330 1
a2331 1
!---------------------------- RCS Ident Info -------------------------------
d2333 2
a2334 3
       "$Id: HGrid.f90,v 2.94 2009/05/13 20:41:55 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d2336 1
a2336 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2338 1
d2345 3
@


2.94
log
@Get constants from Constants, kinds from MLSKinds
@
text
@d1097 1
a1097 1
          & stats=.true., rms=.true. )
d1141 1
a1141 1
        & stats=.true., rms=.true. )
d2333 1
a2333 1
       "$Id: HGrid.f90,v 2.93 2008/12/02 23:29:41 pwagner Exp $"
d2345 3
@


2.93
log
@Added print to not_used_here
@
text
@d715 1
d717 2
a718 2
    use ChunkDivide_m, only: ChunkDivideConfig
    use dates_module, only: utc_to_time
d724 1
a724 1
    use MLSCommon, only: MLSFile_T, NameLen, RK => R8, TAI93_RANGE_T
d727 2
a735 2
    use UNITS, only: DEG2RAD, RAD2DEG
    use MLSHDF5, only: IsHDF5AttributeInFile
d2333 1
a2333 1
       "$Id: HGrid.f90,v 2.92 2007/10/02 22:40:51 vsnyder Exp $"
d2345 3
@


2.92
log
@Increase trace level for CreateHGridFromMLSCFInfo
@
text
@d856 1
d858 1
d2332 1
a2332 1
       "$Id: HGrid.f90,v 2.91 2007/06/21 00:54:07 vsnyder Exp $"
d2336 1
d2344 3
@


2.91
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d75 1
a75 1
    use TOGGLES, only: GEN, TOGGLE, SWITCHES
d148 2
a149 1
    if ( toggle(gen) ) call trace_begin ( "CreateHGridFromMLSCFInfo", root )
a301 2
    
    if ( toggle(gen) ) call trace_end ( "CreateHGridFromMLSCFInfo" )
d307 3
d2182 3
a2184 5
   call deAllocate_Test ( LowerOverlaps, &
     & 'LowerOverlaps', ModuleName )
    if ( specialDumpFile /= ' ' ) &
      & call revertOutput
    if ( toggle(gen) ) call trace_end ( "MLSL2Fill" )
d2330 1
a2330 1
       "$Id: HGrid.f90,v 2.90 2006/07/12 20:42:30 pwagner Exp $"
d2341 3
@


2.90
log
@0 profiles in an HGrid will stop unless computing offsets
@
text
@d625 12
a636 12
	! Interpolations are performed based on MAF index and periodic variables
	! like lon, solartime, losAngle are handled specially so that it can cope
	! with the period jump between two adjacent MAFs. The range of the periods
	! of these variable must be specified, i.e., (lower, upper) bounds. 

	! create index of the old and new hGrid indices
	do maf=1,noMAFs
		defaultIndex(maf)=maf*1.0_rk 
	end do
	do maf=1,hGrid%noProfs 
		interpolatedIndex(maf)=maf/interpolationFactor
	end do
d638 1
a638 1
      	select case ( l1bItem )
d640 2
a641 2
	  call InterpolateValues(defaultIndex,defaultField,interpolatedIndex,&
		interpolatedField,method='Linear',rangeofPeriod=(/-180.0_rk,180.0_rk/))
d643 2
a644 2
	  call InterpolateValues(defaultIndex,defaultField,interpolatedIndex,&
		interpolatedField,method='Linear',rangeofPeriod=(/0.0_rk,24.0_rk/))
d646 5
a650 5
	  call InterpolateValues(defaultIndex,defaultField,interpolatedIndex,&
		interpolatedField,method='Linear',rangeofPeriod=(/0.0_rk,360.0_rk/))
	case default
	  call InterpolateValues(defaultIndex,defaultField,interpolatedIndex,&
		interpolatedField,method='Linear')
d2330 1
a2330 1
       "$Id: HGrid.f90,v 2.89 2006/06/29 21:56:25 pwagner Exp $"
d2341 3
@


2.89
log
@Some debugging stuff removed from routine processing
@
text
@d54 1
a54 1
    & suppressGeometryDump ) result ( hGrid )
d87 2
a88 1
    logical, intent(in), optional :: SUPPRESSGEOMETRYDUMP
d137 2
a138 1
    if ( present ( suppressGeometryDump ) ) mySuppressGeometryDump = suppressGeometryDump
d266 2
a267 1
          & maxLowerOverlap, maxUpperOverlap, insetOverlaps, single, hGrid )
d701 2
a702 1
    & maxLowerOverlap, maxUpperOverlap, insetOverlaps, single, hGrid )
d746 1
d783 2
d795 7
a801 1

d959 1
a959 1
    if ( switchDetail(switches, 'hgrid') >= 0 .or. deebughere ) then
d1176 1
a1176 1
    if ( switchDetail(switches, 'hgrid') >= 0 .or. deebughere ) then
d1204 1
a1204 1
        if ( switchDetail(switches, 'hgrid') >= 0  .or. deebughere ) &
d1220 1
a1220 1
        if ( switchDetail(switches, 'hgrid') >= 0  .or. deebughere ) &
d1231 1
a1231 1
        if ( switchDetail(switches, 'hgrid') >= 0  .or. deebughere ) &
d1243 1
a1243 1
        if ( switchDetail(switches, 'hgrid') >= 0  .or. deebughere ) &
d1274 5
a1278 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, 'No profiles in hGrid' )
d1282 1
a1282 1
    if ( switchDetail(switches, 'hgrid') >= 0  .or. deebughere ) then
d2060 1
a2060 1
                    & processingRange, chunks(chunk), suppressGeometryDump=.true. )
d2330 1
a2330 1
       "$Id: HGrid.f90,v 2.88 2006/05/31 17:48:49 pwagner Exp $"
d2341 3
@


2.88
log
@Another bug fix relating to extra profiles
@
text
@d2137 4
a2140 2
    call output ( 'chunks(1)%hGridOffsets: ', advance='no' )
    call output ( chunks(1)%hGridOffsets, advance='yes' )
d2313 1
a2313 1
       "$Id: HGrid.f90,v 2.87 2006/04/19 20:48:13 pwagner Exp $"
d2324 3
@


2.87
log
@Undid most of the changes regarding extra MAFs; perhaps fixed bugs
@
text
@d2139 2
a2140 1
    if ( ChunkDivideConfig%allowPriorOverlaps ) then
d2311 1
a2311 1
       "$Id: HGrid.f90,v 2.86 2006/04/11 23:33:51 pwagner Exp $"
d2322 3
@


2.86
log
@Fixed bug which added excess profiles
@
text
@d1189 2
a1190 1
      if ( firstProfInRun > 0 .and. .not. ChunkDivideConfig%allowPriorOverlaps ) then
d1205 2
a1206 1
      if ( lastProfInRun < hGrid%noProfs .and. .not. ChunkDivideConfig%allowPostOverlaps ) then
d1976 1
a1976 1
    use Allocate_Deallocate, only: ALLOCATE_TEST
a2043 1
                  LowerOverlaps(hGrid) = dummyHGrid%noProfsLowerOverlap
d2045 2
a2046 1
                    if ( ChunkDivideConfig%allowPriorOverlaps ) then
d2120 1
a2120 1
    ! of profiles each chunk/hGrid.  After this it will contain
d2133 1
a2133 1
    ! chunk, which is the offeset we desire.
d2140 4
a2143 1
      chunks(1)%hGridOffsets = LowerOverlaps
d2160 1
a2160 1
   call Allocate_Test ( LowerOverlaps, noHGrids, &
d2310 1
a2310 1
       "$Id: HGrid.f90,v 2.85 2006/03/07 23:23:28 vsnyder Exp $"
d2321 3
@


2.85
log
@Crash gently if there's bo L1BOA file
@
text
@d2010 1
a2010 1

d2042 18
a2059 1
                  if ( chunk /= 1 .or. .not. ChunkDivideConfig%allowPriorOverlaps ) then
a2061 3
                  else
                    chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                    & dummyHGrid%noProfsUpperOverlap
d2088 2
d2135 7
a2141 1
    chunks(1)%hGridOffsets = 0
d2155 2
d2305 1
a2305 1
       "$Id: HGrid.f90,v 2.84 2006/02/21 19:11:30 pwagner Exp $"
d2316 3
@


2.84
log
@Some tweaks to where, when to dump
@
text
@d139 2
d2281 1
a2281 1
       "$Id: HGrid.f90,v 2.83 2006/02/07 00:56:26 pwagner Exp $"
d2292 3
@


2.83
log
@Now allows overlaps after data end time
@
text
@a73 1
    use output_m, only: output
a1287 1
      integer :: mif
d1392 1
a1392 1
      integer :: maf, mif
d1720 1
a1720 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d1979 1
d1983 3
a1985 2
    use OUTPUT_M, only: BLANKS, OUTPUT
    use TOGGLES, only: SWITCHES
d2010 3
d2119 15
a2133 9
    if ( switchDetail(switches, 'pro') < 0 .or. .not. DEEBUG ) return
    call output ( "Dumping offsets, hgridTotals for all chunks: " , advance='yes')
    do chunk = 1, size ( chunks )
      call output ( chunk )
      call blanks ( 3 )
      call output ( chunks(chunk)%hGridOffsets )
      call blanks ( 3 )
      call output ( chunks(chunk)%hGridTotals, advance='yes' )
    end do
d2279 1
a2279 1
       "$Id: HGrid.f90,v 2.82 2006/01/10 23:52:11 pwagner Exp $"
d2290 3
@


2.82
log
@Fixed segment fault when hdf4 l1boa file
@
text
@d971 2
d1203 1
a1203 1
      if ( lastProfInRun < hGrid%noProfs ) then
d2270 1
a2270 1
       "$Id: HGrid.f90,v 2.81 2005/12/16 00:07:12 pwagner Exp $"
d2281 3
@


2.81
log
@Changes to reflect new MLSFillValues module
@
text
@d74 1
d717 1
a717 1
    use MLSFiles, only: Dump, GetMLSFileByType
d743 1
d806 5
a810 1
    PreV2Oh = .not. IsHDF5AttributeInFile(L1BFile%name, 'BO_name')
d827 1
d832 1
a832 1
    nullify ( mif1GeodAngle )
d834 1
d836 1
d1102 4
a1105 2
      call GetApparentLocalSolarZenith( L1BFile, hGrid, &
        & l1bField%dpField(1,1,:), chunk )
d1271 1
d1283 1
a1283 1
      real (rk), dimension(:,:), pointer :: GMT => null()
d1317 1
a1317 1
      call allocate_test(GMT, noMIFs, noMAFs, 'GMT', ModuleName)
d1345 2
a1346 4
        do mif=1, noMIFs
          call utc_to_time(l1bField%CharField(1,mif,maf), status, time, strict)
          GMT(mif,maf) = hhmmss_value ( time, status, separator, strict ) / 3600
        enddo
d1364 1
a1364 1
        & (SolarTimeCalibration-GMT(1,:))*360./24
d1367 1
a1367 1
      GMT = GMT + ( HGrid%time - MAFTime ) / 3600
d1369 1
a1369 1
        HGrid%SolarTime(:,maf) = GMT(1,maf) + &
a1370 2
        ! SolarTime(:,maf) = GMT(:,maf) + &
        !  & ( MAFLongitude(:,maf) - SolarLongitude(maf) ) / 15
d1381 26
d2268 1
a2268 1
       "$Id: HGrid.f90,v 2.80 2005/12/14 01:55:33 pwagner Exp $"
d2279 3
@


2.80
log
@Inadvertantly omitted some of the statements from r2.78
@
text
@d717 1
d719 1
a719 1
    use MLSNumerics, only: HUNT, InterpolateValues, isMonotonic, Monotonize
d2234 1
a2234 1
       "$Id: HGrid.f90,v 2.79 2005/12/14 01:43:33 pwagner Exp $"
d2245 3
@


2.79
log
@Now stores local apparent solar time
@
text
@d766 1
d773 1
d2233 1
a2233 1
       "$Id: HGrid.f90,v 2.78 2005/12/13 22:15:30 livesey Exp $"
d2244 3
@


2.78
log
@New approach to the single option in regular hGrids.  Now it uses
exactly the same approach to that chosen by forward models when
phiWindow=0 to allow for useful truth in truth out 1D tests.
@
text
@d698 8
d709 2
a710 1
    use Dump_0, only: DUMP
d720 1
d725 1
d747 4
a750 1
    integer :: NOMAFS                   ! From ReadL1B
d752 1
d754 6
a759 2
    integer :: N                        ! Guess at number of profiles
    integer :: EXTRA                    ! How many profiles over 1 are we
a760 6
    integer :: RIGHT                     ! How many profiles to delete from the RHS in single
    integer :: FIRSTPROFINRUN           ! Index of first profile in processing time
    integer :: LASTPROFINRUN            ! Index of last profile in processing time

    real(rk) :: MINANGLE                ! Smallest angle in chunk
    real(rk) :: MINANGLELASTMAF         ! Gives 'range' of last maf
a762 3
    real(rk) :: FIRST                   ! First point in of hGrid
    real(rk) :: LAST                    ! Last point in hGrid
    real(rk), dimension(:), pointer :: TMPANGLE ! A temporary array for the single case
d764 4
a767 2
    real(rk) :: INCLINE                 ! Mean orbital inclination
    real(rk) :: DELTA                   ! A change in angle
d769 3
d773 6
a778 6
    type (L1BData_T) :: L1BFIELD        ! A field read from L1 file

    integer ::  hdfVersion
    character(len=NameLen) :: l1bItemName
    type (MLSFile_T), pointer             :: L1BFile

d780 1
d783 14
d801 1
a801 1

d858 2
a859 1
      ! First identify the first point - the one closest to the start of the first MAF
d867 1
d1009 7
a1015 3
      if ( deebughere ) then
        call dump(hGrid%time(1,:), trim(l1bItemName) // ' (after interpolating)')
      end if
d1019 49
a1067 7
    ! First get fractional day, note this neglects leap seconds.
    ! Perhaps fix this later !???????? NJL. We do have access to the
    ! UTC ascii time field, perhaps we could use that?
    hGrid%solarTime = modulo ( hGrid%time, secondsInDay ) / secondsInDay
    ! Now correct for longitude and convert to hours
    hGrid%solarTime = 24.0 * ( hGrid%solarTime + hGrid%lon/360.0 )
    hGrid%solarTime = modulo ( hGrid%solarTime, 24.0_rk )
a1069 1
    ! This we'll have to do with straight interpolation
d1077 2
a1078 7
      call dump(l1bField%DpField(1,1,:), trim(l1bItemName) // ' (before interpolating)')
    end if
    call InterpolateValues ( mif1GeodAngle, l1bField%dpField(1,1,:), &
      & hGrid%phi(1,:), hGrid%solarZenith(1,:), &
      & method='Linear', extrapolate='Allow' )
    if ( deebughere ) then
      call dump(hGrid%solarZenith(1,:), trim(l1bItemName) // ' (after interpolating)')
d1080 30
d1258 418
d2077 1
a2077 1
    if ( switchDetail(switches, 'pro') < 0 .and. DEEBUG ) return
d2231 1
a2231 1
       "$Id: HGrid.f90,v 2.77 2005/12/13 21:26:02 livesey Exp $"
d2242 5
@


2.77
log
@Minor buglet fix for single case in regular hGrid construction.
@
text
@d703 1
a703 1
    use HGridsDatabase, only: CREATEEMPTYHGRID, HGRID_T, TRIMHGRID
d739 1
d752 1
a825 6
    call DeallocateL1BData ( l1bField )

    ! Check that the single option is appropriate if set
    if ( single .and. noMAFs /= 1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Single hGrid option set but more than one MAF in chunk' )

a826 9
    ! First identify the first point - the one closest to the start of the first MAF
    first = origin + spacing * int ( (minAngle-origin)/spacing )
    delta = first - minAngle            ! So +ve means first could be smaller
    if ( delta > spacing/2 ) then
      first = first - spacing
    else if ( delta < -spacing/2 ) then
      first = first + spacing
    end if
    
d828 8
d845 19
d865 1
d868 3
d1711 1
a1711 1
       "$Id: HGrid.f90,v 2.76 2005/11/15 00:20:18 pwagner Exp $"
d1722 3
@


2.76
log
@Should catch error arising from chunks with bad data
@
text
@d1103 9
a1111 11
      if ( hGrid%noProfs /= 1 ) then
        ! Set up for no overlaps
        hGrid%noProfsLowerOverlap = 0
        hGrid%noProfsUpperOverlap = 0
        ! Delete all but the 'center' profile
        extra = hGrid%noProfs - 1
        left = extra / 2
        right = extra - left
        if ( left > 0 ) call TrimHGrid ( hGrid, -1, left )
        if ( right > 0 ) call TrimHGrid ( hGrid, 1, right )
      end if
d1693 1
a1693 1
       "$Id: HGrid.f90,v 2.75 2005/11/04 18:52:36 pwagner Exp $"
d1704 3
@


2.75
log
@Added warning, correction if mif1GeodAngle non-monotonic
@
text
@d699 1
a699 1
    use Chunks_m, only: MLSChunk_T
d801 18
a818 1
    if ( i < noMAFs + 1 ) then
d1695 1
a1695 1
       "$Id: HGrid.f90,v 2.74 2005/10/22 00:49:26 pwagner Exp $"
d1706 3
@


2.74
log
@Should throw error when l1boa file not in filedatabase
@
text
@d709 1
a709 1
    use MLSNumerics, only: HUNT, InterpolateValues
d793 5
d1678 1
a1678 1
       "$Id: HGrid.f90,v 2.73 2005/10/19 00:06:09 pwagner Exp $"
d1689 3
@


2.73
log
@Fixed bug causing DealWithObstructions to corrupt HGrid
@
text
@d707 1
a707 1
    use MLSFiles, only: GetMLSFileByType
d766 2
d783 2
d892 4
d901 2
d1673 1
a1673 1
       "$Id: HGrid.f90,v 2.72 2005/09/21 23:19:47 pwagner Exp $"
d1684 3
@


2.72
log
@Added DealWithObstructions
@
text
@a56 1
    use ChunkDivide_m, only: ChunkDivideConfig
d1111 1
a1111 1
  subroutine DealWithObstructions ( HGrid, obstructions )
d1115 2
d1119 1
d1128 1
d1139 3
d1186 5
a1190 1
      call DestroyHGridContents(hGrid)
d1549 1
a1549 1
    use HGridsDatabase, only: HGRID_T, CREATEEMPTYHGRID, NULLIFYHGRID
d1619 2
a1620 2
      use MLSCommon, only: r4, r8
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d1640 2
a1641 2
      use MLSCommon, only: r4, r8
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d1663 1
a1663 1
       "$Id: HGrid.f90,v 2.71 2005/09/14 00:12:33 pwagner Exp $"
d1674 3
@


2.71
log
@Uses ChunkDivideConfig%allowPriorOverlaps in calculating offsets
@
text
@d19 1
a19 1
    & ComputeAllHGridOffsets
d30 1
a144 1
    ! hGrid%allowPriorOverlaps = ChunkDivideConfig%allowPriorOverlaps
a483 1
    logical, parameter     :: DEEBUG = .false.
d701 1
d736 1
a760 1
    logical     :: deebug = .FALSE.
d764 1
a764 1
    deebug = deebug .or. ( switchDetail(switches, 'hgrid') >= 0 )
d858 1
a858 1
    if ( switchDetail(switches, 'hgrid') >= 0 .or. deebug ) then
d868 3
a870 1
      call output ( 'Spacing: ' )
d879 5
a883 1
      call output ( chunk%lastMAFIndex, advance='yes' )
d894 1
a894 1
    if ( deebug ) then
d899 1
a899 1
    if ( deebug ) then
d916 1
a916 1
    if ( deebug ) then
d928 1
a928 1
      if ( deebug ) then
d950 1
a950 1
    if ( deebug ) then
d956 1
a956 1
    if ( deebug ) then
d969 1
a969 1
    if ( deebug ) then
d975 1
a975 1
    if ( deebug ) then
d995 1
a995 1
    if ( switchDetail(switches, 'hgrid') >= 0 .or. deebug ) then
d1013 1
a1013 1
      if ( deebug ) then
d1021 2
a1022 2
      if ( firstProfInRun > 0 .and. forbidOverspill ) then
        if ( switchDetail(switches, 'hgrid') >= 0  .or. deebug ) &
d1030 1
a1030 1
      if ( deebug ) then
d1036 2
a1037 2
      if ( lastProfInRun < hGrid%noProfs .and. forbidOverspill ) then
        if ( switchDetail(switches, 'hgrid') >= 0  .or. deebug ) &
d1048 1
a1048 1
        if ( switchDetail(switches, 'hgrid') >= 0  .or. deebug ) &
d1060 1
a1060 1
        if ( switchDetail(switches, 'hgrid') >= 0  .or. deebug ) &
d1097 1
a1097 1
    if ( switchDetail(switches, 'hgrid') >= 0  .or. deebug ) then
d1111 75
d1427 2
a1428 1
                  if ( switchDetail(switches, 'hgrid') >= 0 ) call dump(dummyHGrid)
d1461 1
a1461 1
    if ( switchDetail(switches, 'hgrid') >= 0 ) then
d1499 1
a1499 1
    if ( switchDetail(switches, 'pro') < 0 ) return
d1653 1
a1653 1
       "$Id: HGrid.f90,v 2.70 2005/08/31 19:41:16 livesey Exp $"
d1664 3
@


2.70
log
@Added option to suppress the geometry dump in that first run through
generating the HGrids that is done by tree walker to assess where each
direct write places stuff in the output files.
@
text
@d32 5
a53 1
    ! & ( name, root, l1bInfo, l2gpDatabase, processingRange, chunk ) result ( hGrid )
d56 1
d72 1
a84 1
    ! type (L1BInfo_T), intent(in) :: L1BINFO
d87 1
a88 1
    logical, intent(in), optional :: SUPPRESSGEOMETRYDUMP
d138 2
a139 6
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      hdfversion = L1BFile%HDFVersion
!     hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
!     if ( hdfversion <= 0 ) &                                            
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
!       & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
d144 1
a245 1
        ! call CreateMIFBasedHGrids ( l1bInfo, hGridType, chunk, &
a260 1
        ! call CreateRegularHGrid ( l1bInfo, processingRange, chunk, &
d300 1
a300 1
    if ( index ( switches, 'geom' ) /= 0 .and. .not. mySuppressGeometryDump ) &
a302 1
      ! & trim(instrumentModuleName), l1bInfo )
a418 1
  ! subroutine CreateMIFBasedHGrids ( l1bInfo, hGridType, &
a437 1
    ! type( L1BInfo_T ), intent(in) :: L1BINFO
a490 4
!     hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
!     if ( hdfversion <= 0 ) &                                            
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
!       & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
a695 1
  ! subroutine CreateRegularHGrid ( l1bInfo, processingRange, chunk, &
d711 1
a717 1
    ! type( L1BInfo_T ), intent(in) :: L1BINFO
d764 1
a764 1
    deebug = deebug .or. ( index ( switches, 'hgrid' ) /= 0 )
a767 4
!     hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
!     if ( hdfversion <= 0 ) &                                            
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
!       & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
a770 1
    ! call ChooseOptimumLon0 ( l1bInfo, chunk )
d858 1
a858 1
    if ( index ( switches, 'hgrid' ) /= 0 .or. deebug ) then
d888 3
a890 3
      if ( deebug ) then
        call dump(l1bField%DpField(1,1,:), l1bItemName)
      end if
d893 3
d989 1
a989 1
    if ( index ( switches, 'hgrid' ) /= 0 .or. deebug ) then
d1016 1
a1016 1
        if ( index ( switches, 'hgrid' ) /= 0  .or. deebug ) &
d1031 1
a1031 1
        if ( index ( switches, 'hgrid' ) /= 0  .or. deebug ) &
d1042 1
a1042 1
        if ( index ( switches, 'hgrid' ) /= 0  .or. deebug ) &
d1054 1
a1054 1
        if ( index ( switches, 'hgrid' ) /= 0  .or. deebug ) &
d1091 1
a1091 1
    if ( index ( switches, 'hgrid' ) /= 0  .or. deebug ) then
a1107 1
    ! & instrumentModuleName, l1bInfo )
a1121 1
    ! type( L1BInfo_T ), intent(in) :: L1BINFO
a1171 4
!     hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
!     if ( hdfversion <= 0 ) &                                            
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
!       & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
d1273 1
a1273 2
  ! subroutine ComputeAllHGridOffsets ( root, index, chunks, l1bInfo, &
  subroutine ComputeAllHGridOffsets ( root, index, chunks, filedatabase, &
d1278 4
d1283 5
a1287 1
    use L2GPData, only: L2GPDATA_T
a1288 1
    use MoreTree, only: GET_SPEC_ID
a1289 3
    use Init_Tables_Module, only: Z_CONSTRUCT, S_HGRID, Z_OUTPUT
    use HGridsDatabase, only: HGRID_T, DESTROYHGRIDCONTENTS
    use MLSMessageModule, only: MLSMessage, MLSMSG_ERROR
d1292 1
a1292 1
    integer, intent(in) :: INDEX        ! Where in the tree are we
a1294 1
    ! type( L1BInfo_T ), intent(in) :: L1BINFO
d1306 1
d1319 1
a1319 1
      section = index
a1336 1
                  ! dummyHGrid = CreateHGridFromMLSCFInfo ( 0, key, l1bInfo, l2gpDatabase, &
d1339 2
a1340 1
                  chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
d1342 5
d1379 18
d1417 9
d1454 22
d1524 42
d1571 1
a1571 1
       "$Id: HGrid.f90,v 2.69 2005/06/22 18:57:01 pwagner Exp $"
d1582 5
@


2.69
log
@Reworded Copyright statement, moved rcs id
@
text
@d23 1
a23 1
       "$RCSfile: $"
d47 2
a48 1
    & ( name, root, filedatabase, l2gpDatabase, processingRange, chunk ) result ( hGrid )
d83 1
d103 1
d130 2
d300 1
a300 1
    if ( index ( switches, 'geom' ) /= 0 ) &
d1352 1
a1352 1
                    & processingRange, chunks(chunk) )
d1488 1
a1488 1
       "$Id: $"
d1499 3
@


2.68
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d21 1
a21 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: HGrid.f90,v 2.67 2004/12/27 23:05:47 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d23 1
a23 1
       "$RCSfile: HGrid.f90,v $"
d1481 5
d1494 3
@


2.67
log
@Remove unreferenced use names
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d15 1
a15 1
       "$Id: HGrid.f90,v 2.66 2004/08/20 17:58:42 livesey Exp $"
d42 2
a43 1
    & ( name, root, l1bInfo, l2gpDatabase, processingRange, chunk ) result ( hGrid )
d57 2
a58 3
    use MLSCommon, only: L1BInfo_T, NameLen, RK => R8, TAI93_RANGE_T
    use MLSFiles, only: MLS_HDF_Version       
    use MLSL2Options, only: LEVEL1_HDFVERSION  
d72 2
a73 1
    type (L1BInfo_T), intent(in) :: L1BINFO   ! File handles for l1b data
d119 1
d123 6
a128 4
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
    if ( hdfversion <= 0 ) &                                            
      & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
d234 2
a235 1
        call CreateMIFBasedHGrids ( l1bInfo, hGridType, chunk, &
d250 2
a251 1
        call CreateRegularHGrid ( l1bInfo, processingRange, chunk, &
d260 1
a260 1
      call ReadL1BData ( l1bInfo%l1boaID, l1bItemName, l1bField, noMAFs, &
d262 1
a262 1
        & lastMAF=chunk%lastMAFIndex, hdfVersion=hdfVersion, &
d292 2
a293 1
      & trim(instrumentModuleName), l1bInfo )
d410 2
a411 1
  subroutine CreateMIFBasedHGrids ( l1bInfo, hGridType, &
d424 2
a425 3
    use MLSCommon, only: L1BInfo_T, NameLen, RK => R8
    use MLSFiles, only: MLS_HDF_Version       
    use MLSL2Options, only: LEVEL1_HDFVERSION  
d429 2
a430 1
    type (L1BInfo_T), intent(in)      :: L1BINFO
d478 1
d482 6
a487 4
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
    if ( hdfversion <= 0 ) &                                            
      & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
d515 1
a515 1
      call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
a516 1
        & hdfVersion=hdfVersion, &
d591 1
a591 1
      call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField,noMAFs, &
a592 1
        & hdfVersion=hdfVersion, &
d693 2
a694 1
  subroutine CreateRegularHGrid ( l1bInfo, processingRange, chunk, &
d705 2
a706 3
    use MLSCommon, only: L1BInfo_T, NameLen, RK => R8, TAI93_RANGE_T
    use MLSFiles, only: MLS_HDF_Version       
    use MLSL2Options, only: LEVEL1_HDFVERSION  
d714 2
a715 1
    type (L1BInfo_T), intent(in) :: L1BINFO
d759 1
d764 6
a769 4
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
    if ( hdfversion <= 0 ) &                                            
      & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
d773 2
a774 1
    call ChooseOptimumLon0 ( l1bInfo, chunk )
d781 1
a781 1
    call ReadL1BData ( l1bInfo%l1bOAID, l1bItemName, &
d784 1
a784 1
      & lastMAF=chunk%lastMAFIndex+1, hdfVersion=hdfVersion, dontPad=.true. )
d886 1
a886 1
    call ReadL1BData ( l1bInfo%l1bOAID, l1bItemName, &
d889 1
a889 1
      & lastMAF=chunk%lastMAFIndex, hdfVersion=hdfVersion, &
d906 1
a906 1
    call ReadL1BData ( l1bInfo%l1bOAID, l1bItemName, &
a908 1
      & hdfVersion=hdfVersion, &
d940 1
a940 1
    call ReadL1BData ( l1bInfo%l1bOAID, l1bItemName, &
a942 1
      & hdfVersion=hdfVersion, &
d959 1
a959 1
    call ReadL1BData ( l1bInfo%l1bOAID, l1bItemName, &
a961 1
      & hdfVersion=hdfVersion, &
d1107 2
a1108 1
    & instrumentModuleName, l1bInfo )
d1114 2
a1115 3
    use MLSCommon, only: L1BInfo_T, NameLen, R8
    use MLSFiles, only: MLS_HDF_Version       
    use MLSL2Options, only: LEVEL1_HDFVERSION  
d1122 2
a1123 1
    type (L1BInfo_T), intent(in) :: L1BINFO
d1161 1
d1172 6
a1177 4
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
    if ( hdfversion <= 0 ) &                                            
      & call MLSMessage ( MLSMSG_Error, ModuleName, &                      
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )    
d1181 1
a1181 1
    call ReadL1BData ( l1bInfo%l1bOAID, l1bItemName, &
d1184 1
a1184 1
      & lastMAF=chunk%lastMAFIndex, hdfVersion=hdfVersion, &
d1279 2
a1280 1
  subroutine ComputeAllHGridOffsets ( root, index, chunks, l1bInfo, &
d1285 1
a1285 1
    use MLSCommon, only: L1BINFO_T, TAI93_RANGE_T
d1297 2
a1298 1
    type(L1BInfo_T), intent(in) :: L1BINFO
d1340 2
a1341 1
                  dummyHGrid = CreateHGridFromMLSCFInfo ( 0, key, l1bInfo, l2gpDatabase, &
d1484 3
@


2.66
log
@Made dontpad=true on most calls.
@
text
@a7 2
  use MLSCommon, only: RK => R8

d15 1
a15 1
       "$Id: HGrid.f90,v 2.65 2004/08/16 17:10:26 pwagner Exp $"
d46 1
a46 2
    use HGridsDatabase, only: HGRID_T, CREATEEMPTYHGRID, NULLIFYHGRID, &
      & ADDHGRIDTODATABASE
d62 1
a62 2
    use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
    use Output_M, only: OUTPUT
d411 1
a411 1
    use HGridsDatabase, only: CREATEEMPTYHGRID, HGRID_T, NULLIFYHGRID, TRIMHGRID
d692 1
a692 1
    use HGridsDatabase, only: CREATEEMPTYHGRID, HGRID_T, NULLIFYHGRID, TRIMHGRID
d1099 1
a1099 1
    use HGridsDatabase, only: HGRID_T, NULLIFYHGRID, CREATEEMPTYHGRID
d1267 1
a1267 1
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
d1466 3
@


2.65
log
@Passes dontPad option to readL1BData
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.64 2004/08/05 20:04:48 livesey Exp $"
d511 1
a511 1
        & dontPad=DONTPAD )
d588 1
a588 1
        & dontPad=DONTPAD )
d774 1
a774 2
      & lastMAF=chunk%lastMAFIndex+1, hdfVersion=hdfVersion, &
        & dontPad=DONTPAD )
d880 1
a880 1
      & dontPad=DONTPAD )
d900 1
a900 1
      & dontPad=DONTPAD )
d935 1
a935 1
      & dontPad=DONTPAD )
d955 1
a955 1
      & dontPad=DONTPAD )
d1174 1
a1174 1
      & dontPad=DONTPAD )
d1470 3
@


2.64
log
@Changed some spline interpolations to linear to allow for more
stability.
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d17 1
a17 1
       "$Id: HGrid.f90,v 2.63 2004/07/30 00:16:36 livesey Exp $"
d27 1
d260 2
a261 1
        & lastMAF=chunk%lastMAFIndex, hdfVersion=hdfVersion)
d510 2
a511 1
        & hdfVersion=hdfVersion )
d587 2
a588 1
        & hdfVersion=hdfVersion )
d774 2
a775 1
      & lastMAF=chunk%lastMAFIndex+1, hdfVersion=hdfVersion )
d880 2
a881 1
      & lastMAF=chunk%lastMAFIndex, hdfVersion=hdfVersion )
d900 2
a901 1
      & hdfVersion=hdfVersion )
d935 2
a936 1
      & hdfVersion=hdfVersion )
d955 2
a956 1
      & hdfVersion=hdfVersion )
d1174 2
a1175 1
      & lastMAF=chunk%lastMAFIndex, hdfVersion=hdfVersion )
d1471 4
@


2.63
log
@Minor update in the 'single' option.
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.62 2004/06/14 20:00:36 livesey Exp $"
d901 1
a901 1
        & method='Spline', extrapolate='Allow' )
d934 1
a934 1
      & method='Spline', extrapolate='Allow' )
d953 1
a953 1
      & method='Spline', extrapolate='Allow' )
d994 1
d1006 1
a1006 1
      
d1461 3
@


2.62
log
@A bit more helpful information in dumping and geometry dumping
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.61 2004/05/19 19:16:10 vsnyder Exp $"
d803 13
a815 9

    ! Now work out the last point in a similar manner
    last = origin + spacing * int ( (maxAngle-origin)/spacing )
    delta = last - maxAngle            ! So +ve means last could be smaller
    if ( delta > spacing/2 ) then
      last = last - spacing
    else if ( delta < -spacing/2 ) then
      last = last + spacing
    end if
d1460 3
@


2.61
log
@Move MLSChunk_t to Chunks_m
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.60 2004/03/24 17:55:19 livesey Exp $"
d64 2
a65 1
    use STRING_TABLE, only: GET_STRING
d1099 1
d1143 7
d1165 4
a1168 2
    phiMin = min ( phiMin, hGrid%phi(1,1) )
    phiMax = max ( phiMax, hGrid%phi(1,hGrid%noProfs) )
d1456 3
@


2.60
log
@Just tidying up after myself
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.59 2004/03/24 01:30:16 livesey Exp $"
d45 1
d58 1
a58 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8, TAI93_RANGE_T
d410 1
d417 1
a417 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8
d688 1
d694 1
a694 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8, TAI93_RANGE_T
d1088 1
d1092 1
a1092 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, R8
d1247 2
a1248 1
    use MLSCommon, only: MLSCHUNK_T, L1BINFO_T, TAI93_RANGE_T
d1364 1
a1364 1
    use MLSCommon, only: MLSCHUNK_T
d1445 3
@


2.59
log
@Bug fix in hGrid%time
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.58 2004/03/24 01:03:23 livesey Exp $"
a300 1
    use Output_m, only: OUTPUT
a357 1
      call output ( ' Date: ' // trim ( dateString ), advance='yes' )
a358 1
      call output ( hGrid%time(1,1), advance='yes' )
d1440 3
@


2.58
log
@Added date option to explicit hGrid
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.57 2003/08/28 23:52:36 livesey Exp $"
d363 1
d1443 3
@


2.57
log
@Bug fix for computing total size of hGrid, and tidied up the geometry
dumper.
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.56 2003/08/11 20:55:20 livesey Exp $"
d37 1
d48 1
a48 1
    use INIT_TABLES_MODULE, only: F_FORBIDOVERSPILL, F_FRACTION, F_GEODANGLE, &
d79 1
d140 1
d214 2
d237 1
a237 1
      call CreateExplicitHGrid ( geodAngleNode, solarTimeNode, &
d291 1
a291 1
  subroutine CreateExplicitHGrid ( geodAngleNode, solarTimeNode, &
d294 1
d301 3
d306 2
d322 2
d357 9
a365 1
    hGrid%time = time
d1422 3
d1442 4
@


2.56
log
@Changed 0 profiles error to warning
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.55 2003/08/11 18:08:27 livesey Exp $"
d1097 1
d1183 1
a1185 1
      call output ( ' ', advance='yes' )
d1189 15
a1203 1
      do line = noLines, 1, -1
d1205 1
a1205 1
          call output ( text ( char, line ) )
d1207 2
a1208 6
        call output  ( text ( start+windowSize-1, line ), advance='yes' ) 
      end do
      do char = start, start+windowSize-2
        call output ( '-' )
      end do
      call output ( '-', advance='yes' )
d1323 1
a1323 1
    do chunk = 1, size ( chunks ) - 1
d1418 3
@


2.55
log
@Added the single option for regular hGrids
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.54 2003/06/25 22:27:02 livesey Exp $"
d675 1
a675 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d1044 1
a1044 1
      call MLSMessage ( MLSMSG_Error, ModuleName, 'No profiles in hGrid' )
d1407 3
@


2.54
log
@Fixed an undefined variable
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.53 2003/06/25 22:05:31 vsnyder Exp $"
d50 1
a50 1
      & F_MODULE, F_ORIGIN, F_SOLARTIME, F_SOLARZENITH, F_SOURCEL2GP, &
d107 1
d136 1
d205 2
d243 1
a243 1
          & maxLowerOverlap, maxUpperOverlap, insetOverlaps, hGrid )
d664 1
a664 1
    & maxLowerOverlap, maxUpperOverlap, insetOverlaps, hGrid )
d692 1
d704 3
d767 4
d792 19
a810 17
    if ( chunk%noMAFsLowerOverlap > 0 ) then
      setFirstLoop: do
        if ( first >= last ) exit setFirstLoop
        if ( first > maxAngleFirstMAF ) exit setFirstLoop
        first = first + spacing
      end do setFirstLoop
    else 
      if ( .not. insetOverlaps .and. first > minAngle ) first = first - spacing
    end if
    if ( chunk%noMAFsUpperOverlap > 0 ) then
      setLastLoop: do
        if ( last <= first ) exit setLastLoop
        if ( last < minAngleLastMAF ) exit setLastLoop
        last = last - spacing
      end do setLastLoop
    else
      if ( .not. insetOverlaps .and. last < maxAngle ) last = last + spacing
d1022 24
a1045 6
    if ( maxLowerOverlap >= 0 .and. &
      & ( hGrid%noProfsLowerOverlap > maxLowerOverlap ) ) &
      call TrimHGrid ( hGrid, -1, hGrid%noProfsLowerOverlap - maxLowerOverlap )
    if ( maxUpperOverlap >= 0 .and. &
      & ( hGrid%noProfsUpperOverlap > maxUpperOverlap ) ) &
      call TrimHGrid ( hGrid, -1, hGrid%noProfsUpperOverlap - maxUpperOverlap )
d1407 3
@


2.53
log
@Don't run off the end of the tree if there's no output section
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.52 2003/06/24 23:30:30 livesey Exp $"
a1206 1
    integer :: NAME                     ! Dummy string index
d1235 1
a1235 1
                  dummyHGrid = CreateHGridFromMLSCFInfo ( name, key, l1bInfo, l2gpDatabase, &
d1375 3
@


2.52
log
@Got ComputeAllHGridOffsets working (on the surface at least)
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.51 2003/06/20 19:37:06 pwagner Exp $"
d1202 1
d1212 1
a1212 1
    ! count the number of hGrids.  The other run work out how big each HGrid
d1215 1
d1221 1
a1221 1
      sectionLoop: do
d1376 3
@


2.51
log
@Quanities now share grids stored separately in databses
@
text
@d17 1
a17 1
       "$Id: HGrid.f90,v 2.50 2003/05/11 01:43:17 livesey Exp $"
d1217 1
a1217 1
      hGrid = 0
a1219 1
        print*,'Location:', chunk, section
d1224 2
a1225 2
          do line = 2, nsons ( son - 1 ) ! Skip begin and end
            gson = subtree(line,son)
d1228 14
d1243 1
a1243 14
              key = son
            end if
            if ( get_spec_id(key) == s_hGrid ) then
              ! Now the intelligent bit
              if ( chunk == 0 ) then
                noHGrids = noHGrids + 1
              else
                dummyHGrid = CreateHGridFromMLSCFInfo ( name, key, l1bInfo, l2gpDatabase, &
                  & processingRange, chunks(chunk) )
                chunks(chunk)%hGridOffsets(hGrid) = dummyHGrid%noProfs - &
                  & dummyHGrid%noProfsLowerOverlap - dummyHGrid%noProfsUpperOverlap
                call DestroyHGridContents ( dummyHGrid )
                hGrid = hGrid + 1
              end if
d1248 1
d1250 1
d1257 1
a1257 1
          call Allocate_Test ( chunks(chunk)%hGridOffsets, noHGrids, &
d1259 1
a1259 1
          call Allocate_Test ( chunks(chunk)%hGridTotals, noHGrids, &
d1264 1
a1264 1
        if ( hGrid /= noHGrids ) &
d1266 1
a1266 1
          & 'Got a different number of hGrids, new l2cf conditional stuff?' )
d1374 3
@


2.50
log
@Made the hgrid switch a little less voluable
@
text
@d11 3
d17 1
a17 1
       "$Id$"
d20 1
a20 1
       "$RCSfile$"
a23 22
  ! This module contains datatypes and routines for handling HGrid information
  ! HGrids are the horizontal gridding information that get into vector
  ! quantities.

  ! This is the main datatype, an HGrid.

  type HGrid_T
    integer :: NAME                 ! String index of name.
    integer :: noProfs              ! Number of profiles in this grid
    integer :: noProfsLowerOverlap  ! Number of profiles in the lower overlap
    integer :: noProfsUpperOverlap  ! Number of profiles in the upper overlap

    ! Now the various coordinates in the HGrid, all dimensioned (noProfs)
    real(rk), dimension(:), pointer :: phi => NULL()
    real(rk), dimension(:), pointer :: geodLat => NULL()
    real(rk), dimension(:), pointer :: lon => NULL()
    real(rk), dimension(:), pointer :: time => NULL()
    real(rk), dimension(:), pointer :: solarTime => NULL()
    real(rk), dimension(:), pointer :: solarZenith => NULL()
    real(rk), dimension(:), pointer :: losAngle => NULL()
  end type HGrid_T

a39 18
  ! -----------------------------------------  AddHGridToDatabase  -----
  integer function AddHGridToDatabase ( database, item )

    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, &
      & MLSMSG_DeAllocate, MLSMSG_Error

    ! Dummy arguments
    type (HGrid_T), dimension(:), pointer :: database
    type (HGrid_T), intent(in) :: item

    ! Local variables
    type (HGrid_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddHGridToDatabase = newSize
  end function AddHGridToDatabase

d42 1
a42 1
    & ( name, root, l1bInfo, l2gpDatabase, processingRange, chunks, chunkNo ) result ( hGrid )
d45 2
d75 1
a75 2
    type (MLSChunk_T), intent(in), dimension(:) :: CHUNKS ! The chunks
    integer, intent(in) :: CHUNKNO
d222 1
a222 1
        call CreateMIFBasedHGrids ( l1bInfo, hGridType, chunks(chunkNo), &
d237 1
a237 1
        call CreateRegularHGrid ( l1bInfo, processingRange, chunks, chunkNo, &
d247 2
a248 3
        & l1bFlag, &
        & firstMAF=chunks(chunkNo)%firstMAFIndex, &
        & lastMAF=chunks(chunkNo)%lastMAFIndex, hdfVersion=hdfVersion)
d262 7
a268 7
      hGrid%phi =         l2gp%geodAngle(a:b)
      hGrid%geodLat =     l2gp%latitude(a:b)
      hGrid%lon =         l2gp%longitude(a:b) 
      hGrid%time =        l2gp%time(a:b)
      hGrid%solarTime =   l2gp%solarTime(a:b)
      hGrid%solarZenith = l2gp%solarZenith(a:b)
      hGrid%losAngle =    l2gp%losAngle(a:b)
d276 1
a276 1
      & call DumpChunkHGridGeometry ( hGrid, chunks(chunkNo), &
d286 1
d304 1
a304 1
    real(rk), dimension(:), pointer :: VALUES
d369 1
a369 1
          values(prof) = expr_value(1)
d387 1
d619 1
a619 1
        hGrid%time = interpolatedField
d621 1
a621 1
        hGrid%geodLat = interpolatedField
d623 1
a623 1
        hGrid%lon = interpolatedField
d625 1
a625 1
        hGrid%phi = interpolatedField
d627 1
a627 1
        hGrid%solarZenith = interpolatedField
d629 1
a629 1
        hGrid%solarTime = interpolatedField
d631 1
a631 1
        hGrid%losAngle = interpolatedField
d658 1
a658 1
  subroutine CreateRegularHGrid ( l1bInfo, processingRange, chunks, chunkNo, &
d665 1
d680 1
a680 2
    type (MLSChunk_T), intent(in), dimension(:) :: CHUNKS
    integer, intent(in) :: CHUNKNO
a713 1
    type (MLSChunk_T) :: CHUNK
a725 1
    chunk = chunks ( chunkNo )
d803 1
a803 1
      hGrid%phi(i) = first + (i-1)*spacing
d845 1
a845 1
    call EmpiricalLongitude ( hGrid%phi, hGrid%lon )
d859 1
a859 1
        & hGrid%phi, hGrid%time, &
d867 1
a867 1
        call dump(hGrid%time, trim(l1bItemName) // ' (after interpolating)')
d892 1
a892 1
      & hGrid%phi, hGrid%solarZenith, &
d895 1
a895 1
      call dump(hGrid%solarZenith, trim(l1bItemName) // ' (after interpolating)')
d911 1
a911 1
      & hGrid%phi, hGrid%losAngle, &
d914 1
a914 1
      call dump(hGrid%losAngle, trim(l1bItemName) // ' (after interpolating)')
d922 1
a922 1
    call Hunt ( hGrid%phi, mif1GeodAngle(chunk%noMAFsLowerOverlap+1), &
d927 1
a927 1
    call Hunt ( hGrid%phi, nextAngle, &
d949 1
a949 1
      call Hunt ( hGrid%time, processingRange%startTime, &
d952 1
a952 1
        call dump( hGrid%time, 'Hgrid times')
d965 1
a965 1
      call Hunt ( hGrid%time, processingRange%endTime, &
d984 1
a984 1
      if ( hGrid%time(hGrid%noProfsLowerOverlap+1) < processingRange%startTime ) then
d989 1
a989 1
        call Hunt ( hGrid%time, processingRange%startTime, &
d995 1
a995 1
      if ( hGrid%time(hGrid%noProfs-hGrid%noProfsUpperOverlap) > &
d1001 1
a1001 1
        call Hunt ( hGrid%time, processingRange%endTime, &
a1029 127
  ! -------------------------------------------  CreateEmptyHGrid  -----
  subroutine CreateEmptyHGrid ( hGrid )
    ! Just does allocates etc.

    use Allocate_Deallocate, only: Allocate_Test

    type (HGrid_T), intent(inout) :: HGRID

    ! Executable code
    call Allocate_Test ( hGrid%phi, hGrid%noProfs, 'hGrid%phi', ModuleName)
    call Allocate_Test ( hGrid%geodLat, hGrid%noProfs, 'hGrid%geodLat', ModuleName)
    call Allocate_Test ( hGrid%lon, hGrid%noProfs, 'hGrid%lon', ModuleName)
    call Allocate_Test ( hGrid%time, hGrid%noProfs, 'hGrid%time', ModuleName)
    call Allocate_Test ( hGrid%solarTime, hGrid%noProfs, 'hGrid%solarTime', ModuleName)
    call Allocate_Test ( hGrid%solarZenith, hGrid%noProfs, 'hGrid%solarZenith', ModuleName)
    call Allocate_Test ( hGrid%losAngle, hGrid%noProfs, 'hGrid%losAngle', ModuleName)

  end subroutine CreateEmptyHGrid

  ! -------------------------------------------------  TrimHGrid  ------
  subroutine TrimHGrid ( hGrid, side, NOTODELETE )

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use MLSCommon, only: RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error

    type (HGrid_T), intent(inout) :: HGrid
    integer, intent(in) :: SIDE         ! -1 = lower, 1 = upper
    integer, intent(in) :: NOTODELETE ! How many to delete, default all
    ! Local variables
    integer :: newNoProfs
    real(rk), dimension(:), pointer :: temp
    integer :: first, last

    ! Executable code
    select case ( side )
    case ( -1 )
      newNoProfs = hGrid%noProfs - noToDelete
      first = noToDelete + 1
      last = hGrid%noProfs
      hGrid%noProfsLowerOverlap = max ( hGrid%noProfsLowerOverlap - noToDelete, 0 )
    case ( 1 )
      newNoProfs = hGrid%noProfs - noToDelete
      first = 1
      last = newNoProfs
      hGrid%noProfsUpperOverlap = max ( hGrid%noProfsUpperOverlap - noToDelete, 0 )
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Invalid side argument to TrimHGrid' )
    end select
    if ( newNoProfs <= 0 ) call MLSMessage ( &
        & MLSMSG_Error, ModuleName, 'Too many profiles to delete' )

    nullify ( temp )
    call allocate_test ( temp, hGrid%noProfs, 'temp', ModuleName )
    hGrid%noProfs = newNoProfs

    ! Now allocate each entry and trim it
    temp = hGrid%phi                    ! ------------------------- Phi
    call Allocate_Test ( hGrid%phi, newNoProfs, 'hGrid%phi', ModuleName)
    hGrid%phi = temp ( first : last )
    temp = hGrid%geodLat                ! ------------------------- GeodLat
    call Allocate_Test ( hGrid%geodLat, newNoProfs, 'hGrid%geodLat', ModuleName)
    hGrid%geodLat = temp ( first : last )
    temp = hGrid%lon                    ! ------------------------- Lon
    call Allocate_Test ( hGrid%lon, newNoProfs, 'hGrid%lon', ModuleName)
    hGrid%lon = temp ( first : last )
    temp = hGrid%time                   ! ------------------------- Time
    call Allocate_Test ( hGrid%time, newNoProfs, 'hGrid%time', ModuleName)
    hGrid%time = temp ( first : last )
    temp = hGrid%solarTime              ! ------------------------- SolarTime
    call Allocate_Test ( hGrid%solarTime, newNoProfs, 'hGrid%solarTime', ModuleName)
    hGrid%solarTime = temp ( first : last )
    temp = hGrid%solarZenith            ! ------------------------- SolarZenith
    call Allocate_Test ( hGrid%solarZenith, newNoProfs, 'hGrid%solarZenith', ModuleName)
    hGrid%solarZenith = temp ( first : last )
    temp = hGrid%losAngle               ! ------------------------- LosAngle
    call Allocate_Test ( hGrid%losAngle, newNoProfs, 'hGrid%losAngle', ModuleName)
    hGrid%losAngle = temp ( first : last )

    call Deallocate_test ( temp, 'temp', ModuleName )
  end subroutine TrimHGrid
    
  ! ---------------------------------------  DestroyHGridContents  -----
  subroutine DestroyHGridContents ( hGrid )

    use Allocate_Deallocate, only: Deallocate_Test

  ! This routine destroys the information associated with an hGrid

    ! Dummy arguments
    type (HGrid_T), intent(inout) :: hGrid

    ! Executable code
    
    call deallocate_test ( hGrid%phi, 'hGrid%phi', ModuleName )
    call deallocate_test ( hGrid%geodLat, 'hGrid%geodLat', ModuleName )
    call deallocate_test ( hGrid%lon, 'hGrid%lon', ModuleName )
    call deallocate_test ( hGrid%time, 'hGrid%time', ModuleName )
    call deallocate_test ( hGrid%solarTime, 'hGrid%solarTime', ModuleName )
    call deallocate_test ( hGrid%solarZenith, 'hGrid%solarZenith', ModuleName )
    call deallocate_test ( hGrid%losAngle, 'hGrid%losAngle', ModuleName )
    hGrid%noProfs = 0
  end subroutine DestroyHGridContents

  ! ---------------------------------------  DestroyHGridDatabase  -----
  subroutine DestroyHGridDatabase ( database )

    use MLSMessageModule, only: MLSMessage, MLSMSG_DeAllocate, MLSMSG_Error

  ! This subroutine destroys a quantity template database

    ! Dummy argument
    type (HGrid_T), dimension(:), pointer :: database

    ! Local variables
    integer :: hGridIndex, status
    if ( associated(database) ) then
      do hGridIndex=1,SIZE(database)
        call DestroyHGridContents ( database(hGridIndex) )
      end do
      deallocate ( database, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate // "database" )
    end if
  end subroutine DestroyHGridDatabase

d1034 1
d1037 1
a1037 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8
d1050 1
a1050 1
    real (rk), parameter :: BINSIZE=0.05 ! Width of one character in degrees
d1073 5
a1077 5
    real (rk) :: PHIMAX                 ! Maximum value to consider
    real (rk) :: PHIMIN                 ! Minimum value to consider
    real (rk) :: THISPHIMAX             ! Max phi in a line for a maf
    real (rk) :: THISPHIMIN             ! Min phi in a line for a maf
    real (rk), dimension(:,:), pointer :: MIFPHI ! Tangent phis
d1100 2
a1101 2
    phiMin = min ( phiMin, hGrid%phi(1) )
    phiMax = max ( phiMax, hGrid%phi(hGrid%noProfs) )
d1138 1
a1138 1
      charMin = ( hGrid%phi(prof) - phiMin ) / binSize + 1
d1175 33
a1207 5
 
  ! ----------------------------------------NullifyHGrid -----
  subroutine NullifyHGrid ( H )
    ! Given a hGrid, nullify all the pointers associated with it
    type ( HGrid_T ), intent(out) :: H
d1210 79
a1288 8
    nullify ( h%phi )
    nullify ( h%geodLat )
    nullify ( h%lon )
    nullify ( h%time )
    nullify ( h%solarTime )
    nullify ( h%solarZenith )
    nullify ( h%losAngle )
  end subroutine NullifyHGrid
d1290 26
d1371 4
a1374 1
! $Log$
@


2.49
log
@Merged in feb03 newfwm branch
@
text
@d480 1
a480 1
    logical, parameter     :: DEEBUG = .FALSE.
d596 2
a597 2
      if ( DEEBUG .and. index(l1bItemName, 'MAFStartTimeTAI') > 0 ) then
        call dump(l1bField%DpField, 'MAFStartTimeTAI (before interpolating)')
d611 2
a612 2
      if ( DEEBUG .and. index(l1bItemName, 'MAFStartTimeTAI') > 0 ) then
        call dump(defaultField, 'MAFStartTimeTAI (after something special)')
d649 1
a649 1
      if ( DEEBUG .and. index(l1bItemName, 'MAFStartTimeTAI') > 0 ) then
d753 1
a753 1
    logical     :: DEEBUG = .FALSE.
d756 1
a756 1
    DEEBUG = DEEBUG .or. ( index ( switches, 'hgrid' ) /= 0 )
a776 3
      if ( DEEBUG ) then
        call dump(l1bField%DpField, l1bItemName)
      end if
d843 1
a843 1
    if ( index ( switches, 'hgrid' ) /= 0 .or. DEEBUG ) then
d872 2
a873 2
      if ( DEEBUG ) then
        call dump(l1bField%DpField, l1bItemName)
d891 2
a892 2
    if ( DEEBUG ) then
      call dump(l1bField%DpField, trim(l1bItemName) // ' (before interpolating)')
d903 1
a903 1
      if ( DEEBUG ) then
d925 2
a926 2
    if ( DEEBUG ) then
      call dump(l1bField%DpField, trim(l1bItemName) // ' (before interpolating)')
d931 1
a931 1
    if ( DEEBUG ) then
d944 2
a945 2
    if ( DEEBUG ) then
      call dump(l1bField%DpField, trim(l1bItemName) // ' (before interpolating)')
d950 1
a950 1
    if ( DEEBUG ) then
d970 1
a970 1
    if ( index ( switches, 'hgrid' ) /= 0 .or. DEEBUG ) then
d988 2
a989 2
      if ( DEEBUG ) then
        call dump( hGrid%time, 'hgrid times')
d996 1
a996 1
        if ( index ( switches, 'hgrid' ) /= 0  .or. DEEBUG ) &
d1004 1
a1004 1
      if ( DEEBUG ) then
d1011 1
a1011 1
        if ( index ( switches, 'hgrid' ) /= 0  .or. DEEBUG ) &
d1022 1
a1022 1
        if ( index ( switches, 'hgrid' ) /= 0  .or. DEEBUG ) &
d1034 1
a1034 1
        if ( index ( switches, 'hgrid' ) /= 0  .or. DEEBUG ) &
d1053 1
a1053 1
    if ( index ( switches, 'hgrid' ) /= 0  .or. DEEBUG ) then
d1410 3
@


2.48
log
@DeeBug is turned on by switch
@
text
@d14 1
a14 1
       "$Id: HGrid.f90,v 2.47 2003/02/13 19:05:39 vsnyder Exp $"
d17 1
a17 1
       "$RCSfile: HGrid.f90,v $"
d87 1
a87 2
      & L_L2GP, L_REGULAR, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_LENGTH, &
      & PHYQ_TIME
d708 1
d847 3
a849 1
      call output ( 'Constructing regular hGrid', advance='yes' )
d1412 13
a1424 1
! $Log: HGrid.f90,v $
@


2.47
log
@Move USEs from module to procedure scope, cosmetic changes
@
text
@d14 1
a14 1
       "$Id: HGrid.f90,v 2.46 2003/02/07 00:41:32 livesey Exp $"
d753 1
a753 1
    logical, parameter     :: DEEBUG = .FALSE.
d756 1
d860 4
d1411 3
@


2.46
log
@Bug fix (or at least workaround)
@
text
@d8 1
a8 29
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use EmpiricalGeometry, only: EmpiricalLongitude, ChooseOptimumLon0
  use EXPR_M, only: EXPR
  use Dump_0, only: DUMP
  use INIT_TABLES_MODULE, only: F_FRACTION, F_HEIGHT, F_INCLINATION, &
    & F_INTERPOLATIONFACTOR, F_INSETOVERLAPS, F_MIF, F_MODULE, F_TYPE, &
    & FIELD_FIRST, F_SPACING, F_ORIGIN, F_FORBIDOVERSPILL, &
    & F_SOURCEL2GP, FIELD_LAST, L_EXPLICIT, L_FIXED, L_FRACTIONAL, L_HEIGHT, L_L2GP,&
    & F_SOLARTIME, F_SOLARZENITH, F_GEODANGLE, &
    & L_MIF, L_REGULAR, PHYQ_DIMENSIONLESS, PHYQ_LENGTH, PHYQ_ANGLE,&
    & F_MAXLOWEROVERLAP, F_MAXUPPEROVERLAP, PHYQ_TIME
  use LEXER_CORE, only: PRINT_SOURCE
  use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
    & AssembleL1BQtyName
  use L2GPData, only: L2GPDATA_T
  use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, R8, TAI93_RANGE_T
  use MLSFiles, only: mls_hdf_version       
  use MLSL2Options, only: LEVEL1_HDFVERSION  
  use MLSMessageModule, only: MLSMessage, MLSMSG_allocate, &
    & MLSMSG_DeAllocate, MLSMSG_Error, MLSMSG_Info, MLSMSG_L1BRead
  use MLSNumerics, only: HUNT, InterpolateValues
  use MoreTree, only: GET_BOOLEAN
  use OUTPUT_M, only: OUTPUT
  use STRING_TABLE, only: GET_STRING
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TOGGLES, only: GEN, TOGGLE, SWITCHES
  use TREE, only: DECORATION, DUMP_TREE_NODE, NSONS, NULL_TREE, SOURCE_REF, &
                  SUB_ROSA, SUBTREE
  use UNITS, only: DEG2RAD, RAD2DEG
d14 1
a14 1
       "$Id: HGrid.f90,v 2.45 2003/02/06 23:30:50 livesey Exp $"
d34 7
a40 7
    real(r8), dimension(:), pointer :: phi => NULL()
    real(r8), dimension(:), pointer :: geodLat => NULL()
    real(r8), dimension(:), pointer :: lon => NULL()
    real(r8), dimension(:), pointer :: time => NULL()
    real(r8), dimension(:), pointer :: solarTime => NULL()
    real(r8), dimension(:), pointer :: solarZenith => NULL()
    real(r8), dimension(:), pointer :: losAngle => NULL()
d62 3
d81 22
d118 1
a118 1
    real(r8) :: interpolationFactor
d120 2
a121 2
    real(r8) :: fraction, height
    real(r8) :: spacing, origin
d129 2
a130 2
    real(r8) :: incline                 ! Orbital inclination / degrees
    real(r8) :: MINTIME, MAXTIME        ! Span for a chunk
a139 2
    integer :: L1BITEM                  ! Loop counter
    integer :: MAF                      ! Loop counters
a143 1
    integer :: PROF                     ! Loop counter
a146 1
    integer :: STATUS                   ! From Allocate, ReadL1B... etc.
d248 1
a248 1
        incline = expr_value(1)
d319 1
a319 1
  ! ----------------------------------------- CreateExplicitHGrid -------
d322 7
d333 1
a333 1
    real(r8), intent(in) :: TIME        ! Time for HGrid
d341 1
a341 1
    real(r8), dimension(:), pointer :: VALUES
d343 1
a343 1
    real(r8) :: EXPR_VALUE(2)   ! Output from Expr subroutine
d375 2
a376 2
    hGrid%lon = 0.0_r8
    hGrid%losAngle = 0.0_r8
d379 4
a382 4
    hGrid%phi = 0.0_r8
    hGrid%geodLat = 0.0_r8
    hGrid%solarTime = 0.0_r8
    hGrid%solarZenith = 0.0_r8
d416 1
a416 1
  ! ------------------------------------- CreateMIFBasedHGrids -----------
d421 13
d439 3
a441 3
    real(r8), intent(in)              :: INTERPOLATIONFACTOR
    real(r8), intent(in)              :: HEIGHT
    real(r8), intent(in)              :: FRACTION
d459 1
a459 1
    real(r8), parameter :: SIXTH = 1.0_r8 / 6.0_r8
d468 1
a468 1
    real(r8) :: MinAngle, MaxAngle
d470 1
a470 2
    integer :: STATUS                   ! Flag
    real(r8), dimension(:,:,:), pointer :: TpGeodAlt, TpGeodAngle
d473 1
a473 1
    real(r8), dimension(:), pointer :: defaultField, interpolatedField
d477 2
a478 2
    real(r8), dimension(:), pointer :: defaultIndex
    real(r8), dimension(:), pointer :: interpolatedIndex
d511 1
a511 1

d523 1
a523 1
    endif
d599 1
a599 1
      endif
d614 1
a614 1
      endif
d627 1
a627 1
		defaultIndex(maf)=maf*1.0_r8 
d636 1
a636 1
		interpolatedField,method='Linear',rangeofPeriod=(/-180.0_r8,180.0_r8/))
d639 1
a639 1
		interpolatedField,method='Linear',rangeofPeriod=(/0.0_r8,24.0_r8/))
d642 1
a642 1
		interpolatedField,method='Linear',rangeofPeriod=(/0.0_r8,360.0_r8/))
d652 1
a652 1
      endif
d693 1
a693 1
  ! ----------------------------------- CreateRegularHGrid ------------
d697 15
d716 2
a717 2
    real(r8), intent(in) :: SPACING
    real(r8), intent(in) :: ORIGIN
d726 1
a726 1
    real(r8), parameter :: SECONDSINDAY = 24*60*60
d729 1
a729 1
    real(r8), parameter :: ORBITALPERIOD = 98.8418*60.0
d737 10
a746 11
    real(r8) :: MINANGLE                ! Smallest angle in chunk
    real(r8) :: MINANGLELASTMAF         ! Gives 'range' of last maf
    real(r8) :: MAXANGLE                ! Largest angle in chunk
    real(r8) :: MAXANGLEFIRSTMAF        ! Gives 'range' of first maf
    real(r8) :: FIRST                   ! First point in of hGrid
    real(r8) :: LAST                    ! Last point in hGrid
    real(r8), dimension(:), pointer :: MIF1GEODANGLE ! For first mif
    real(r8) :: DAYSTART                ! Start of day
    real(r8) :: INCLINE                 ! Mean orbital inclination
    real(r8) :: DELTA                   ! A change in angle
    real(r8) :: NEXTANGLE               ! First non ovl. MAF for next chunk
d778 1
a778 1
      endif
d794 1
a794 1
    endif
d870 1
a870 1
      endif
d889 1
a889 1
    endif
d901 1
a901 1
      endif
d911 1
a911 1
    hGrid%solarTime = modulo ( hGrid%solarTime, 24.0_r8 )
d923 1
a923 1
    endif
d929 1
a929 1
    endif
d942 1
a942 1
    endif
d948 1
a948 1
    endif
d950 1
a950 1
    hGrid%losAngle = modulo ( hGrid%losAngle, 360.0_r8 )
d1063 1
a1063 1
  ! ----------------------------------- CreateEmptyHGrid ---------------
d1066 3
d1082 1
a1082 1
  ! ---------------------------------------  TrimHGrid ---
d1084 5
d1094 1
a1094 1
    real(r8), dimension(:), pointer :: temp
d1149 2
a1155 3
    ! Local Variables
    integer :: STATUS    ! From Deallocate

d1171 2
d1190 1
a1190 1
  ! ----------------------------------------- DumpChunkHGridGeometry
d1193 10
d1209 1
a1209 1
    real (r8), parameter :: BINSIZE=0.05 ! Width of one character in degrees
d1232 5
a1236 5
    real (r8) :: PHIMAX                 ! Maximum value to consider
    real (r8) :: PHIMIN                 ! Minimum value to consider
    real (r8) :: THISPHIMAX             ! Max phi in a line for a maf
    real (r8) :: THISPHIMIN             ! Min phi in a line for a maf
    real (r8), dimension(:,:), pointer :: MIFPHI ! Tangent phis
d1354 5
d1406 3
@


2.46.2.1
log
@Changes merged in from HEAD
@
text
@d8 29
a36 1
  use MLSCommon, only: RK => R8
d42 1
a42 1
       "$Id: HGrid.f90,v 2.47 2003/02/13 19:05:39 vsnyder Exp $"
d62 7
a68 7
    real(rk), dimension(:), pointer :: phi => NULL()
    real(rk), dimension(:), pointer :: geodLat => NULL()
    real(rk), dimension(:), pointer :: lon => NULL()
    real(rk), dimension(:), pointer :: time => NULL()
    real(rk), dimension(:), pointer :: solarTime => NULL()
    real(rk), dimension(:), pointer :: solarZenith => NULL()
    real(rk), dimension(:), pointer :: losAngle => NULL()
a89 3
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, &
      & MLSMSG_DeAllocate, MLSMSG_Error

a105 22
    use EXPR_M, only: EXPR
    use INIT_TABLES_MODULE, only: F_FORBIDOVERSPILL, F_FRACTION, F_GEODANGLE, &
      & F_HEIGHT, FIELD_FIRST, FIELD_LAST, F_INCLINATION, F_INSETOVERLAPS, &
      & F_INTERPOLATIONFACTOR, F_MAXLOWEROVERLAP, F_MAXUPPEROVERLAP, F_MIF, &
      & F_MODULE, F_ORIGIN, F_SOLARTIME, F_SOLARZENITH, F_SOURCEL2GP, &
      & F_SPACING, F_TYPE, L_EXPLICIT, L_FIXED, L_FRACTIONAL, L_HEIGHT, &
      & L_L2GP, L_REGULAR, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_LENGTH, &
      & PHYQ_TIME
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName
    use L2GPData, only: L2GPDATA_T
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8, TAI93_RANGE_T
    use MLSFiles, only: MLS_HDF_Version       
    use MLSL2Options, only: LEVEL1_HDFVERSION  
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
    use MLSNumerics, only: HUNT
    use MoreTree, only: GET_BOOLEAN
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, TOGGLE, SWITCHES
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE

d121 1
a121 1
    real(rk) :: interpolationFactor
d123 2
a124 2
    real(rk) :: fraction, height
    real(rk) :: spacing, origin
d132 2
a133 2
    real(rk) :: incline                 ! Orbital inclination / degrees
    real(rk) :: MINTIME, MAXTIME        ! Span for a chunk
d143 2
d149 1
d153 1
d255 1
a255 1
        incline = expr_value(1) !??? Never used
d326 1
a326 1
  ! ----------------------------------------  CreateExplicitHGrid  -----
a328 7

    use EXPR_M, only: EXPR
    use INIT_TABLES_MODULE, only: PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_TIME
    use MLSCommon, only: RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use TREE, only: NSONS, SUBTREE

d333 1
a333 1
    real(rk), intent(in) :: TIME        ! Time for HGrid
d341 1
a341 1
    real(rk), dimension(:), pointer :: VALUES
d343 1
a343 1
    real(rk) :: EXPR_VALUE(2)   ! Output from Expr subroutine
d375 2
a376 2
    hGrid%lon = 0.0_rk
    hGrid%losAngle = 0.0_rk
d379 4
a382 4
    hGrid%phi = 0.0_rk
    hGrid%geodLat = 0.0_rk
    hGrid%solarTime = 0.0_rk
    hGrid%solarZenith = 0.0_rk
d416 1
a416 1
  ! ---------------------------------------  CreateMIFBasedHGrids  -----
a420 13

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Dump_0, only: DUMP
    use INIT_TABLES_MODULE, only: F_FRACTION, F_HEIGHT, &
      & F_MIF, L_FIXED, L_FRACTIONAL, L_HEIGHT, L_MIF
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8
    use MLSFiles, only: MLS_HDF_Version       
    use MLSL2Options, only: LEVEL1_HDFVERSION  
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
    use MLSNumerics, only: HUNT, InterpolateValues

d426 3
a428 3
    real(rk), intent(in)              :: INTERPOLATIONFACTOR
    real(rk), intent(in)              :: HEIGHT
    real(rk), intent(in)              :: FRACTION
d446 1
a446 1
    real(rk), parameter :: SIXTH = 1.0_rk / 6.0_rk
d455 1
a455 1
    real(rk) :: MinAngle, MaxAngle
d457 2
a458 1
    real(rk), dimension(:,:,:), pointer :: TpGeodAlt, TpGeodAngle
d461 1
a461 1
    real(rk), dimension(:), pointer :: defaultField, interpolatedField
d465 2
a466 2
    real(rk), dimension(:), pointer :: defaultIndex
    real(rk), dimension(:), pointer :: interpolatedIndex
d499 1
a499 1
      ! ??? Does something go here?
d511 1
a511 1
    end if
d587 1
a587 1
      end if
d602 1
a602 1
      end if
d615 1
a615 1
		defaultIndex(maf)=maf*1.0_rk 
d624 1
a624 1
		interpolatedField,method='Linear',rangeofPeriod=(/-180.0_rk,180.0_rk/))
d627 1
a627 1
		interpolatedField,method='Linear',rangeofPeriod=(/0.0_rk,24.0_rk/))
d630 1
a630 1
		interpolatedField,method='Linear',rangeofPeriod=(/0.0_rk,360.0_rk/))
d640 1
a640 1
      end if
d681 1
a681 1
  ! -----------------------------------------  CreateRegularHGrid  -----
a684 15

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Dump_0, only: DUMP
    use EmpiricalGeometry, only: EmpiricalLongitude, ChooseOptimumLon0
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8, TAI93_RANGE_T
    use MLSFiles, only: MLS_HDF_Version       
    use MLSL2Options, only: LEVEL1_HDFVERSION  
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSNumerics, only: HUNT, InterpolateValues
    use OUTPUT_M, only: OUTPUT
    use TOGGLES, only: SWITCHES
    use UNITS, only: DEG2RAD, RAD2DEG

d689 2
a690 2
    real(rk), intent(in) :: SPACING
    real(rk), intent(in) :: ORIGIN
d699 1
a699 1
    real(rk), parameter :: SECONDSINDAY = 24*60*60
d702 1
a702 1
    real(rk), parameter :: ORBITALPERIOD = 98.8418*60.0
d710 11
a720 10
    real(rk) :: MINANGLE                ! Smallest angle in chunk
    real(rk) :: MINANGLELASTMAF         ! Gives 'range' of last maf
    real(rk) :: MAXANGLE                ! Largest angle in chunk
    real(rk) :: MAXANGLEFIRSTMAF        ! Gives 'range' of first maf
    real(rk) :: FIRST                   ! First point in of hGrid
    real(rk) :: LAST                    ! Last point in hGrid
    real(rk), dimension(:), pointer :: MIF1GEODANGLE ! For first mif
    real(rk) :: INCLINE                 ! Mean orbital inclination
    real(rk) :: DELTA                   ! A change in angle
    real(rk) :: NEXTANGLE               ! First non ovl. MAF for next chunk
d752 1
a752 1
      end if
d768 1
a768 1
    end if
d844 1
a844 1
      end if
d863 1
a863 1
    end if
d875 1
a875 1
      end if
d885 1
a885 1
    hGrid%solarTime = modulo ( hGrid%solarTime, 24.0_rk )
d897 1
a897 1
    end if
d903 1
a903 1
    end if
d916 1
a916 1
    end if
d922 1
a922 1
    end if
d924 1
a924 1
    hGrid%losAngle = modulo ( hGrid%losAngle, 360.0_rk )
d1037 1
a1037 1
  ! -------------------------------------------  CreateEmptyHGrid  -----
a1039 3

    use Allocate_Deallocate, only: Allocate_Test

d1053 1
a1053 1
  ! -------------------------------------------------  TrimHGrid  ------
a1054 5

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use MLSCommon, only: RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error

d1060 1
a1060 1
    real(rk), dimension(:), pointer :: temp
a1114 2
    use Allocate_Deallocate, only: Deallocate_Test

d1120 3
a1137 2
    use MLSMessageModule, only: MLSMessage, MLSMSG_DeAllocate, MLSMSG_Error

d1155 1
a1155 1
  ! -------------------------------------  DumpChunkHGridGeometry  -----
a1157 10

    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData, &
      & AssembleL1BQtyName
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8
    use MLSFiles, only: MLS_HDF_Version       
    use MLSL2Options, only: LEVEL1_HDFVERSION  
    use MLSMessageModule, only: MLSMessage, MLSMSG_allocate, &
      & MLSMSG_DeAllocate, MLSMSG_Error
    use OUTPUT_M, only: OUTPUT

d1164 1
a1164 1
    real (rk), parameter :: BINSIZE=0.05 ! Width of one character in degrees
d1187 5
a1191 5
    real (rk) :: PHIMAX                 ! Maximum value to consider
    real (rk) :: PHIMIN                 ! Minimum value to consider
    real (rk) :: THISPHIMAX             ! Max phi in a line for a maf
    real (rk) :: THISPHIMIN             ! Min phi in a line for a maf
    real (rk), dimension(:,:), pointer :: MIFPHI ! Tangent phis
a1308 5

    use LEXER_CORE, only: PRINT_SOURCE
    use OUTPUT_M, only: OUTPUT
    use TREE, only: DUMP_TREE_NODE, SOURCE_REF

a1355 6
! Revision 2.47  2003/02/13 19:05:39  vsnyder
! Move USEs from module to procedure scope, cosmetic changes
!
! Revision 2.46  2003/02/07 00:41:32  livesey
! Bug fix (or at least workaround)
!
@


2.46.2.2
log
@Delete unreferenced USEd name, show hGrid's label on debugging output
@
text
@d14 1
a14 1
       "$Id: HGrid.f90,v 2.46.2.1 2003/02/13 20:36:06 livesey Exp $"
d87 2
a88 1
      & L_L2GP, L_REGULAR, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_LENGTH
a708 1
    use String_Table, only: Display_String
d846 1
a846 3
      call output ( 'Constructing regular hGrid ' )
      if ( hgrid%name /= 0 ) call display_string ( hgrid%name )
      call output ( '', advance='yes' )
a1405 3
! Revision 2.46.2.1  2003/02/13 20:36:06  livesey
! Changes merged in from HEAD
!
@


2.45
log
@New approach for explicit hGrids
@
text
@a36 1
  use Intrinsic, only: T_NUMERIC
d42 1
a42 1
       "$Id: HGrid.f90,v 2.44 2003/01/06 20:13:46 livesey Exp $"
d309 1
a309 1
      hGrid%lon =         l2gp%longitude(a:b)
a340 1
    integer :: TYPE                     ! Type of a tree node
d400 9
a408 10

      do prof = 1, hGrid%noProfs
        call expr ( subtree ( prof+1, node), expr_units, expr_value, type )
        if ( type /= t_numeric ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Only numerics, not ranges allowed in explicit hGrid' )
        if ( all ( expr_units(1) /= (/ phyq_dimensionless, units /) ) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Invalid units for explicit hGrid' )
        values(prof) = expr_value(1)
      end do
d1356 3
@


2.44
log
@New handling of overlaps
@
text
@d13 1
a13 1
    & F_INTERPOLATIONFACTOR, F_INSETOVERLAPS, F_MIF, F_MODULE, F_TYPE, F_VALUES, &
d16 1
d18 1
a18 1
    & F_MAXLOWEROVERLAP, F_MAXUPPEROVERLAP
d37 1
d43 1
a43 1
       "$Id: HGrid.f90,v 2.43 2002/12/11 22:17:05 pwagner Exp $"
d140 1
d152 2
a154 1
    integer :: VALUESNODE               ! Node of tree for explicit
d180 3
d246 6
a251 2
      case ( f_values )
        valuesNode = son
d273 2
a274 17
      ! For explicit hGrids, do things differently
      hGrid%noProfs = nsons(valuesNode)-1
      hGrid%noProfsLowerOverlap = 0
      hGrid%noProfsUpperOverlap = 0
      call CreateEmptyHGrid(hGrid)
      hGrid%lon = 0.0_r8
      hGrid%time = 0.0_r8
      hGrid%solarTime = 0.0_r8
      hGrid%losAngle = 0.0_r8
      hGrid%solarZenith = 0.0_r8
      
      do prof = 1, hGrid%noProfs
        call expr ( subtree ( prof+1, valuesNode), expr_units, expr_value )
        hGrid%phi(prof) = expr_value(1)
        hGrid%geodLat(prof) = hGrid%phi(prof) !???? Sort this out later!
        hGrid%time = processingRange%startTime
      end do
d327 92
d1359 3
@


2.43
log
@Added error checks on hdf version
@
text
@d13 2
a14 2
    & F_INTERPOLATIONFACTOR, F_MIF, F_MODULE, F_TYPE, F_VALUES, FIELD_FIRST,&
    & F_SPACING, F_ORIGIN, F_FORBIDOVERSPILL, &
d16 2
a17 1
    & L_MIF, L_REGULAR, PHYQ_DIMENSIONLESS, PHYQ_LENGTH, PHYQ_ANGLE
d41 1
a41 1
       "$Id: HGrid.f90,v 2.42 2002/12/06 01:07:54 pwagner Exp $"
d139 1
d143 2
d173 3
d207 10
d222 2
d258 1
a258 1
          & instrumentModuleName, mif, hGrid )
d287 2
a288 1
          & spacing, origin, trim(instrumentModuleName), forbidOverspill, hGrid )
d334 1
a334 1
    & instrumentModuleName, mif, hGrid )
d346 2
d585 8
d598 2
a599 1
    & spacing, origin, instrumentModuleName, forbidOverspill, hGrid )
d608 3
d714 2
a715 4
      ! I'm commenting this bit out for the moment, as I think I don't
      ! want it.
      ! else 
      !   if ( first > minAngle ) first = first - spacing
d723 2
a724 4
      ! I'm commenting this bit out for the moment, as I think I don't
      ! want it.
      ! else
      !   if ( last < maxAngle ) last = last + spacing
d929 8
d1271 3
@


2.42
log
@A lot of extra debugging output possible
@
text
@d40 1
a40 1
       "$Id: HGrid.f90,v 2.40 2002/11/22 12:20:42 mjf Exp $"
d157 3
d367 3
d613 3
d1077 3
d1233 3
@


2.41
log
@Cosmetic changes
@
text
@d359 1
d472 3
d487 3
d525 3
d602 1
d622 3
d695 1
a695 1
    if ( index ( switches, 'hgrid' ) /= 0 ) then
d718 3
d737 3
d749 3
d771 3
d777 3
d790 3
d796 3
d816 1
a816 1
    if ( index ( switches, 'hgrid' ) /= 0 ) then
d834 7
d842 1
a842 1
        if ( index ( switches, 'hgrid' ) /= 0 ) &
d850 6
d857 1
a857 1
        if ( index ( switches, 'hgrid' ) /= 0 ) &
d868 1
a868 1
        if ( index ( switches, 'hgrid' ) /= 0 ) &
d880 1
a880 1
        if ( index ( switches, 'hgrid' ) /= 0 ) &
d891 1
a891 1
    if ( index ( switches, 'hgrid' ) /= 0 ) then
d1221 3
@


2.40
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d40 1
a40 1
       "$Id: HGrid.f90,v 2.39 2002/11/13 01:07:04 pwagner Exp $"
d605 2
a606 1
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpGeodAngle", hdfVersion, .false. )
d742 2
a743 1
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpSolarZenith", hdfVersion, .false. )
d755 2
a756 1
    l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpLosAngle", hdfVersion, .false. )
d1173 4
@


2.39
log
@Actually reads hdf5 radiances
@
text
@d40 1
a40 1
       "$Id: HGrid.f90,v 2.38 2002/10/08 17:36:20 pwagner Exp $"
d158 1
a158 2
    nullify ( hgrid%phi, hgrid%geodLat, hgrid%lon, hgrid%time, &
      & hgrid%solarTime, hgrid%solarZenith, hgrid%losAngle ) ! for Sun's rubbish compiler
d1104 15
d1170 3
@


2.38
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 2
a19 1
  use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData
d22 2
d40 1
a40 1
       "$Id: HGrid.f90,v 2.37 2002/09/11 17:40:38 livesey Exp $"
d151 3
d156 2
d272 2
a273 1
      call ReadL1BData ( l1bInfo%l1boaID, "MAFStartTimeTAI", l1bField, noMAFs, &
d276 1
a276 1
        & lastMAF=chunks(chunkNo)%lastMAFIndex)
d358 1
d363 1
d390 1
d392 2
a393 1
        & l1bFlag, firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex )
d466 1
d468 2
a469 1
        & l1bFlag, firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex )
d591 3
d595 2
d606 2
a607 1
    call ReadL1BData ( l1bInfo%l1bOAID, instrumentModuleName//".tpGeodAngle", &
d610 1
a610 1
      & lastMAF=chunk%lastMAFIndex+1 )
d699 2
a700 1
    call ReadL1BData ( l1bInfo%l1bOAID, "scOrbIncl", &
d703 1
a703 1
      & lastMAF=chunk%lastMAFIndex )
d715 2
a716 1
    call ReadL1BData ( l1bInfo%l1bOAID, "MAFStartTimeTAI", &
d718 2
a719 1
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
d742 2
a743 1
    call ReadL1BData ( l1bInfo%l1bOAID, instrumentModuleName//".tpSolarZenith", &
d745 2
a746 1
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
d754 2
a755 1
    call ReadL1BData ( l1bInfo%l1bOAID, instrumentModuleName//".tpLosAngle", &
d757 2
a758 1
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
d1012 3
d1017 2
d1020 2
a1021 1
    call ReadL1BData ( l1bInfo%l1bOAID, instrumentModuleName//".tpGeodAngle", &
d1024 1
a1024 1
      & lastMAF=chunk%lastMAFIndex )
d1156 3
@


2.37
log
@Bug fix
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.36 2002/08/09 16:56:37 livesey Exp $"
d41 1
d1113 4
d1122 3
@


2.36
log
@Modified the edge handling to avoid having 'orphaned' profiles beyond
the edges of the scan range.
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.35 2002/08/04 16:03:33 mjf Exp $"
d787 9
a795 7
    if ( hGrid%time(hGrid%noProfsLowerOverlap+1) < processingRange%startTime ) then
      if ( index ( switches, 'hgrid' ) /= 0 ) &
        & call output ( &
        & 'Non overlapped part of hGrid starts before run, extending overlap.', &
        & advance='yes' )
      call Hunt ( hGrid%time, processingRange%startTime, &
        &   hGrid%noProfsLowerOverlap, allowTopValue=.true., allowBelowValue=.true. )
d798 11
a808 9
    if ( hGrid%time(hGrid%noProfs-hGrid%noProfsUpperOverlap) > &
      & processingRange%endTime ) then
      if ( index ( switches, 'hgrid' ) /= 0 ) &
        & call output ( &
        & 'Non overlapped part of hGrid end after run, extending overlap.', &
        & advance='yes' )
      call Hunt ( hGrid%time, processingRange%endTime, &
        & hGrid%noProfsUpperOverlap, allowTopValue=.true., allowBelowValue=.true. )
      hGrid%noProfsUpperOverlap = hGrid%noProfs - hGrid%noProfsUpperOverlap
d1117 4
@


2.35
log
@Added some nullify statements for Sun's rubbish compiler.
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.34 2002/08/01 17:19:56 livesey Exp $"
d561 1
d563 1
d591 1
d593 1
d627 24
a650 3
    ! Now outset by one in the case where we're inside the MAFs
    if ( first > minAngle ) first = first - spacing
    if ( last < maxAngle ) last = last + spacing
d739 10
a748 20
    ! The exceptions are for the first and last chunks, where the later test
    ! for the processing time range is the limiting factor
    if ( chunkNo > 1 ) then
      call Hunt ( hGrid%phi, mif1GeodAngle(chunk%noMAFsLowerOverlap+1), &
        & hGrid%noProfsLowerOverlap, allowTopValue=.true., allowBelowValue=.true. )
      ! So the hunt returns the index of the last overlapped, which is
      ! the number we want to be in the overlap.
    else
      hGrid%noProfsLowerOverlap = 0
    end if

    if ( chunkNo < size(chunks) ) then
      call Hunt ( hGrid%phi, nextAngle, &
        & hGrid%noProfsUpperOverlap, allowTopValue=.true., allowBelowValue=.true. )
      ! Here the hunt returns the index of the last non overlapped profile
      ! So we do a subtraction to get the number in the overlap.
      hGrid%noProfsUpperOverlap = hGrid%noProfs - hGrid%noProfsUpperOverlap
    else
      hGrid%noProfsUpperOverlap = 0
    end if
d1113 3
@


2.34
log
@Flipped geometry dump over the right way.
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.33 2002/07/17 06:02:50 livesey Exp $"
d149 3
d1098 3
@


2.33
log
@More conservative settings
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.32 2002/07/01 23:57:06 livesey Exp $"
d1028 1
a1028 1
      do line = 1, noLines
d1095 3
@


2.32
log
@Explicit HGrids now inherit the processing start time as their time.
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.31 2002/07/01 23:42:42 vsnyder Exp $"
d620 3
a622 3
    ! Now outset by one to be sure
    first = first - spacing
    last = last + spacing
d1095 3
@


2.31
log
@Plug a memory leak
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.30 2002/06/29 06:11:36 livesey Exp $"
d244 1
d1095 3
@


2.30
log
@Typo!
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.29 2002/06/29 05:55:19 livesey Exp $"
d284 1
d1094 3
@


2.29
log
@Added the geom diagnostic
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.28 2002/06/18 22:41:26 livesey Exp $"
d965 1
a965 1
      & lastMAF=chunk%lastMAFIndex
d1093 3
@


2.28
log
@More fixes to do with nasty aspects of regular hGrids on day boundaries
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.27 2002/05/24 20:56:53 livesey Exp $"
d288 4
d618 1
a618 3
    ! Now, for the moment at least I'm going to 'outset' these.
    ! This is to ensure that even if one's asked for overlaps=0 in
    ! chunkDivide, that we'll not get any funny gaps
d752 1
a752 1
        call DeleteHGridOverlap ( hGrid, -1, firstProfInRun )
d761 1
a761 1
        call DeleteHGridOverlap ( hGrid, 1, hGrid%noProfs-lastProfInRun )
d818 2
a819 2
  ! ---------------------------------------  DeleteHGridOverlap ---
  subroutine DeleteHGridOverlap ( hGrid, side, noProfs )
d822 1
a822 1
    integer, intent(in), optional :: NOPROFS ! How many to delete, default all
a826 1
    integer :: toDelete                 ! Number to delete
d831 2
a832 4
      toDelete = hGrid%noProfsLowerOverlap
      if ( present ( noProfs ) ) toDelete = noProfs
      newNoProfs = hGrid%noProfs - toDelete
      first = toDelete + 1
d834 1
a834 1
      hGrid%noProfsLowerOverlap = max ( hGrid%noProfsLowerOverlap - toDelete, 0 )
d836 1
a836 3
      toDelete = hGrid%noProfsUpperOverlap
      if ( present ( noProfs ) ) toDelete = noProfs
      newNoProfs = hGrid%noProfs - toDelete
d839 1
a839 1
      hGrid%noProfsUpperOverlap = max ( hGrid%noProfsUpperOverlap - toDelete, 0 )
d842 1
a842 1
        & 'Invalid side argument to DeleteOverlaps' )
d875 1
a875 1
  end subroutine DeleteHGridOverlap
d920 126
d1093 3
@


2.27
log
@Some fixes for cases where the chunk is only 1 MAF long
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.26 2002/05/24 16:47:39 livesey Exp $"
d548 2
d635 1
a635 1
      call output ( ' Spacing: ' )
d638 1
a638 1
      call output ( first )
d640 1
a640 1
      call output ( last, advance='yes' )
d666 1
a666 1
        & method='spline', extrapolate='Allow' )
d690 1
a690 1
      & method='spline', extrapolate='Allow' )
d700 1
a700 1
      & method='spline', extrapolate='Allow' )
d737 28
a764 1
    ! Now, we want to ensure we don't spill beyond the processing time range
d767 3
a769 1
        & call output ( 'Hgrid starts before start of dataset, ' )
a771 8
      if ( forbidOverspill ) then
        call DeleteHGridOverlap ( hGrid, -1 )
        if ( index ( switches, 'hgrid' ) /= 0 ) &
          & call output ( 'deleting overspill.', advance='yes' )
      else
        if ( index ( switches, 'hgrid' ) /= 0 ) &
          & call output ( 'extending overlap.', advance='yes' )
      end if
d777 3
a779 1
        & call output ( 'Hgrid finishes after end of dataset, ' )
a782 8
      if ( forbidOverspill ) then
        call DeleteHGridOverlap ( hGrid, 1 )
        if ( index ( switches, 'hgrid' ) /= 0 ) &
          & call output ( 'deleting overspill.', advance='yes' )
      else
        if ( index ( switches, 'hgrid' ) /= 0 ) &
          & call output ( 'extending overlap.', advance='yes' )
      end if
d785 1
d817 1
a817 1
  subroutine DeleteHGridOverlap ( hGrid, side )
d820 1
d823 1
a823 1
    real, dimension(:), pointer :: temp
d825 1
d830 4
a833 2
      newNoProfs = hGrid%noProfs - hGrid%noProfsLowerOverlap
      first = hGrid%noProfsLowerOverlap + 1
d835 1
a835 1
      hGrid%noProfsLowerOverlap = 0
d837 3
a839 1
      newNoProfs = hGrid%noProfs - hGrid%noProfsUpperOverlap
d842 1
a842 1
      hGrid%noProfsUpperOverlap = 0
d847 2
d970 3
@


2.26
log
@Added some diagnostics
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.25 2002/05/06 22:31:28 livesey Exp $"
d541 3
d656 2
a657 1
    ! Now time
d661 9
a669 3
    call InterpolateValues ( mif1GeodAngle, l1bField%dpField(1,1,:), &
      & hGrid%phi, hGrid%time, &
      & method='spline', extrapolate='Allow' )
d671 1
a671 1

d727 3
a729 1
      call output ( 'Initial overlaps: ' )
d737 2
d741 8
a748 1
      if ( forbidOverspill ) call DeleteHGridOverlap ( hGrid, -1 )
d753 2
d758 8
a765 1
      if ( forbidOverspill ) call DeleteHGridOverlap ( hGrid, 1 )
d769 3
a771 1
      call output ( 'Final overlaps: ' )
d944 3
@


2.25
log
@Fixed nullify stuff
@
text
@d28 1
a28 1
  use TOGGLES, only: GEN, TOGGLE
d37 1
a37 1
       "$Id: HGrid.f90,v 2.24 2002/05/06 21:59:28 livesey Exp $"
d563 1
a563 1
    ! (it makes sure it's not done twice)
d622 16
d716 7
d738 7
d912 3
@


2.24
log
@Fixed get_Boolean bug
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.23 2002/05/06 21:37:40 livesey Exp $"
d762 1
d882 3
@


2.23
log
@Added forbidOverspill option
@
text
@d37 1
a37 1
       "$Id: HGrid.f90,v 2.22 2001/12/16 00:58:24 livesey Exp $"
d121 2
a122 1
    integer :: keyNo            ! Entry in the mlscf line
d159 5
d167 1
d175 1
a175 1
        forbidOverspill = get_boolean ( field )
d881 3
@


2.22
log
@Working version. Deals with first and last chunks in day properly.
@
text
@d14 1
a14 1
    & F_SPACING, F_ORIGIN, &
d24 1
d37 1
a37 1
       "$Id: HGrid.f90,v 2.21 2001/12/14 01:43:02 livesey Exp $"
d142 1
d153 1
d167 2
d246 1
a246 1
          & spacing, origin, trim(instrumentModuleName), hGrid )
d521 1
a521 1
    & spacing, origin, instrumentModuleName, hGrid )
d529 1
d694 6
a699 3
    if ( hGrid%time(hGrid%noProfsLowerOverlap+1) < processingRange%startTime ) &
      & call Hunt ( hGrid%time, processingRange%startTime, &
      &   hGrid%noProfsLowerOverlap, allowTopValue=.true., allowBelowValue=.true. )
d705 1
d729 55
d874 3
@


2.21
log
@Various bug fixes
@
text
@d36 1
a36 1
       "$Id: HGrid.f90,v 2.20 2001/12/10 20:21:36 livesey Exp $"
d97 1
a97 1
    & ( name, root, l1bInfo, l2gpDatabase, processingRange, chunk ) result ( hGrid )
d107 2
a108 1
    type (MLSChunk_T), intent(in) :: CHUNK    ! This chunk
d211 1
a211 1
        call CreateMIFBasedHGrids ( l1bInfo, hGridType, chunk, &
d240 2
a241 2
        call CreateRegularHGrid ( l1bInfo, processingRange, chunk, spacing, origin, &
          & trim(instrumentModuleName), hGrid )
d248 3
a250 1
        & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex)
d515 1
a515 1
  subroutine CreateRegularHGrid ( l1bInfo, processingRange, chunk, &
d519 2
a520 1
    type (MLSChunk_T), intent(in) :: CHUNK
d544 1
d547 1
d613 2
a614 1
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
d665 21
a685 10
    ! is above the first non overlapped MAF
    call Hunt ( hGrid%phi, mif1GeodAngle(chunk%noMAFsLowerOverlap+1), &
      & hGrid%noProfsLowerOverlap, allowTopValue=.true., allowBelowValue=.true. )
    ! So the hunt returns the index of the last overlapped, which is
    ! the number we want to be in the overlap.
    call Hunt ( hGrid%phi, nextAngle, &
      & hGrid%noProfsUpperOverlap, allowTopValue=.true., allowBelowValue=.true. )
    ! Here the hunt returns the index of the last non overlapped profile
    ! So we do a subtraction to get the number in the overlap.
    hGrid%noProfsUpperOverlap = hGrid%noProfs - hGrid%noProfsUpperOverlap
d688 1
a688 1
    if ( hGrid%time(hGrid%noProfsLowerOverlap) < processingRange%startTime ) &
d809 3
@


2.20
log
@Added code for regular HGrids
@
text
@d20 1
a20 1
  use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, R8
d36 1
a36 1
       "$Id: HGrid.f90,v 2.19 2001/07/09 20:15:07 livesey Exp $"
d97 1
a97 1
    & ( name, root, l1bInfo, l2gpDatabase, chunk ) result ( hGrid )
d106 1
d239 1
a239 1
        call CreateRegularHGrid ( l1bInfo, chunk, spacing, origin, &
d512 1
a512 1
  subroutine CreateRegularHGrid ( l1bInfo, chunk, &
d515 1
d531 2
a532 1
    real(r8) :: FIRST                   ! Origin of hGrid
d536 2
d548 2
d552 3
a554 1
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
d559 10
a568 1
    mif1GeodAngle = l1bField%dpField(1,1,:)
d572 26
a597 3
    first = spacing * int ( (origin+minAngle)/spacing )
    if ( minAngle < 0 ) first = first - spacing
    hGrid%noProfs = int((maxAngle-first)/spacing)
d628 2
a629 1
    ! Perhaps fix this later !???????? NJL
d661 6
a666 2
    call Hunt ( hGrid%phi, mif1GeodAngle(noMAFs-chunk%noMAFsUpperOverlap), &
      & hGrid%noProfsUpperOverlap, allowTopValue=.true. )
d669 11
d791 3
@


2.19
log
@Fixed an embarassing memory leak I thought I caught before. Also
changed some allocatables to pointers to let us use Allocate_Deallocate
@
text
@d9 1
d14 1
d16 1
a16 1
    & L_MIF, PHYQ_DIMENSIONLESS, PHYQ_LENGTH
d36 1
a36 1
       "$Id: HGrid.f90,v 2.18 2001/07/06 21:33:23 dwu Exp $"
d69 2
a70 1
  integer, private, parameter :: LengthUnitMessage = 1
d76 1
d115 1
d182 10
d209 1
a209 1
        call CreateCommonHGrids ( l1bInfo, hGridType, chunk, &
d232 10
d274 2
a275 2
  ! ------------------------------------- CreateCommonHGrids -----------
  subroutine CreateCommonHGrids ( l1bInfo, hGridType, &
d287 1
a287 1
    character (len=*)                 :: INSTRUMENTMODULENAME
d368 1
a368 1
      tpGeodAngle => l1bField%dpField
d508 119
a626 1
  end subroutine CreateCommonHGrids
d699 5
d718 3
d734 4
@


2.18
log
@forgot to deallocate variables
@
text
@d12 3
a14 3
    & F_INTERPOLATIONFACTOR, F_MODULE, F_TYPE, F_VALUES, FIELD_FIRST,&
    & F_SOURCEL2GP, FIELD_LAST, L_EXPLICIT, L_FRACTIONAL, L_HEIGHT, L_L2GP,&
    & PHYQ_DIMENSIONLESS, PHYQ_LENGTH
d34 1
a34 1
       "$Id: HGrid.f90,v 2.17 2001/07/06 18:48:16 dwu Exp $"
d72 1
d122 2
a123 2
    integer :: FIELD              ! Subtree index of "field" node
    integer :: FIELD_INDEX        ! F_..., see Init_Tables_Module
d126 4
a129 3
    integer :: L1BITEM            ! Loop counter
    integer :: MAF                ! Loop counters
    integer :: NOMAFS             ! Number of MAFs of L1B data read
d131 2
a132 2
    integer :: SON                ! Son of Root
    integer :: STATUS             ! From Allocate, ReadL1B... etc.
d162 5
d190 1
a190 1
    case ( l_height, l_fractional ) ! ----- Fractional or Height ------
d196 1
a196 1
          & instrumentModuleName, hGrid )
d252 1
a252 1
    & instrumentModuleName, hGrid )
d263 1
d292 1
a292 1
    real(r8), dimension(:), allocatable :: defaultField, interpolatedField
d295 3
a297 3
    integer, dimension(:), allocatable :: defaultMIFs
    real(r8), dimension(:), allocatable :: defaultIndex
    real(r8), dimension(:), allocatable :: interpolatedIndex
d301 4
d321 4
d327 9
a335 5
    call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
      & l1bFlag, firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex )
    if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_L1BRead//l1bItemName )
    
d337 1
a337 3
    allocate ( defaultMIFs(noMAFs), STAT=status )
    if ( status/=0) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_allocate//"defaultMIFs" )
d368 2
d387 4
a390 2
    allocate ( defaultField(noMAFs), interpolatedField(hGrid%noProfs), &
	defaultIndex(noMAFs), interpolatedIndex(hGrid%noProfs), STAT=status )
a391 3
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_allocate//"defaultField and/or interpolatedField" )
    
d416 3
a418 1
      end IF
d471 5
a475 15
    deallocate ( defaultIndex, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "defaultIndex" )
    deallocate ( defaultMIFs, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "defaultMIFs" )
    deallocate ( defaultField, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "defaultField" )
    deallocate ( interpolatedField, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "interpolatedField" )
    deallocate ( interpolatedIndex, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "interpolatedIndex" )
d479 1
a479 1
      & NINT(chunk%noMAFsLowerOverlap*interpolationFactor)
d481 1
a481 1
      & NINT(chunk%noMAFsUpperOverlap*interpolationFactor)
d566 2
d583 3
@


2.17
log
@Add codes to make interpolationFactor functioning
@
text
@d34 1
a34 1
       "$Id: HGrid.f90,v 2.16 2001/05/30 23:53:15 livesey Exp $"
d450 3
d462 3
d570 3
@


2.16
log
@For new version of L1BData
@
text
@d21 1
a21 1
  use MLSNumerics, only: HUNT
d34 1
a34 1
       "$Id: HGrid.f90,v 2.15 2001/05/12 00:17:24 livesey Exp $"
d288 2
d368 2
a369 1
      & STAT=status )
d399 1
a399 1
      if ( interpolationFactor==1.0 ) then
d402 28
a429 11
        ! ??? Some interpolation is wanted.  I'm going to hold off writing
        ! this because we certaintly don't need it for 0.1 and probably
        ! won't till 1.0.  For the sake of getting things down I'll state
        ! here what I think would be implemented.  One would simply
        ! interpolate from the defaultField to the interpolatedField, using
        ! linear or spline I imagine.  However, there are issues with roll
        ! overs for quantities such as longitude and solarTime.  This is
        ! why I have chosen to defer this piece of code. NJL - 16 December
        ! 1999
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Sorry -- interpolation of hGrids is not yet supported" )
d564 3
@


2.15
log
@Brief tidy up of constructing from l2gp.  Tree walker currently prevents
this however.
@
text
@d34 1
a34 1
       "$Id: HGrid.f90,v 2.14 2001/05/03 20:32:19 vsnyder Exp $"
d351 1
a351 1
    call DeallocateL1BData ( l1bField, l1bFlag )
d544 4
@


2.14
log
@Cosmetic changes
@
text
@d34 1
a34 1
       "$Id: HGrid.f90,v 2.13 2001/04/26 02:44:17 vsnyder Exp $"
d71 1
d184 7
a190 3
      call CreateCommonHGrids ( l1bInfo, hGridType, chunk, &
        & got_field, root, height, fraction, interpolationFactor, &
        & instrumentModuleName, hGrid )
d529 2
d544 3
@


2.13
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d34 1
a34 1
       "$Id: $"
d37 1
a37 1
       "$RCSfile: $"
d266 2
a267 2
    character (len=15), DIMENSION(noL1BItemsToRead) :: l1bItemNames
    ! Entries in the above array follwing FirstModularItem are prefixed
d270 1
d272 2
a273 1
    integer :: L1BFLAG                  ! Flag
d276 1
a276 3
    integer :: MAF                      ! Loop counter etc.
    real(r8) :: minAngle, maxAngle
    real(r8), dimension(:,:,:), pointer :: tpGeodAngle, tpGeodAlt
d537 3
@


2.12
log
@Gave up on latitude stuff
@
text
@d14 1
a14 1
    & LIT_INDICES, PHYQ_DIMENSIONLESS, PHYQ_LENGTH
d17 1
a28 1
  use L2GPData, only: L2GPDATA_T
d32 7
a38 6
  private :: Id, ModuleName
  !---------------------------- RCS Ident Info -------------------------------
  character (len=256) :: Id = &
       "$Id: HGrid.f90,v 2.11 2001/04/23 23:25:26 livesey Exp $"
  character (len=*), parameter :: ModuleName= "$RCSfile: HGrid.f90,v $"
  ! ---------------------------------------------------------------------------
d537 3
@


2.11
log
@Changed l2gpDatabase to pointer
@
text
@d10 1
d27 1
a27 1
  use UNITS, only: DEG2RAD
d35 1
a35 1
       "$Id: HGrid.f90,v 2.10 2001/04/21 01:24:55 livesey Exp $"
d201 1
a201 2
        hGrid%geodLat(prof) = asin( sin(deg2rad*hGrid%phi(prof)) * &
          &                         sin(deg2rad*incline) )/deg2rad
d536 3
@


2.10
log
@New version, tidied up, can create hGrid from L2GP now
@
text
@d34 1
a34 1
       "$Id: HGrid.f90,v 2.9 2001/04/20 23:11:48 livesey Exp $"
d97 1
a97 1
    type (L2GPData_T), intent(in), target, DIMENSION(:) :: L2GPDATABASE
d190 1
d536 3
@


2.9
log
@Added explicit functionality
@
text
@d8 1
d12 2
a13 2
    & FIELD_LAST, L_EXPLICIT, L_FRACTIONAL, L_HEIGHT, LIT_INDICES, &
    & PHYQ_DIMENSIONLESS, PHYQ_LENGTH
d27 1
d34 1
a34 1
       "$Id: HGrid.f90,v 2.8 2001/03/02 01:27:06 livesey Exp $"
d89 1
a89 1
    & ( name, root, l1bInfo, chunk ) result ( hGrid )
d96 3
a98 19
    type (L1BInfo_T), intent(in) :: l1bInfo   ! File handles for l1b data
    type (MLSChunk_T), intent(in) :: chunk    ! This chunk

    ! Local parameters
    real(r8), parameter :: SIXTH = 1.0_r8 / 6.0_r8

    integer, parameter :: L1B_MAFSTARTTIMETAI = 1
    integer, parameter :: L1B_TPGEODLAT       = l1b_MAFStartTimeTAI + 1
    integer, parameter :: L1B_TPLON           = l1b_tpGeodLat + 1
    integer, parameter :: L1B_TPGEODANGLE     = l1b_tpLon + 1
    integer, parameter :: L1B_TPSOLARZENITH   = l1b_tpGeodAngle + 1
    integer, parameter :: L1B_TPSOLARTIME     = l1b_tpSolarZenith + 1
    integer, parameter :: L1B_TPLOSANGLE      = l1b_tpSolarTime + 1
    integer, parameter :: NOL1BITEMSTOREAD=l1b_tpLosAngle
    integer, parameter :: FIRSTMODULARITEM=l1b_tpGeodLat
    
    character (len=15), DIMENSION(noL1BItemsToRead) :: l1bItemNames
    ! Entries in the above array follwing FirstModularItem are prefixed
    ! with either GHz or THz. 
d107 1
a111 1
    real(r8), dimension(:,:,:), pointer :: tpGeodAngle, tpGeodAlt
a112 1
    real(r8) :: minAngle, maxAngle
d114 3
a117 1
    integer, dimension(:), allocatable :: defaultMIFs
a120 1
    character (len=NameLen) :: InstrumentModuleName
a122 1
    character (len=NameLen) :: L1BItemName
d130 1
a130 2
    ! MIFs it would choose in the non over/undersampled case
    real(r8), dimension(:), allocatable :: defaultField, interpolatedField
a134 9

    l1bItemNames(l1b_mafstarttimetai ) = 'MAFStartTimeTAI'
    l1bItemNames(l1b_tpgeodlat       ) = 'tpGeodLat'
    l1bItemNames(l1b_tplon           ) = 'tpLon'
    l1bItemNames(l1b_tpgeodangle     ) = 'tpGeodAngle'
    l1bItemNames(l1b_tpsolarzenith   ) = 'tpSolarZenith'
    l1bItemNames(l1b_tpsolartime     ) = 'tpSolarTime'
    l1bItemNames(l1b_tplosangle      ) = 'tpLosAngle'

d169 2
d178 89
a266 2
    ! The tree checker verifies that required fields "type" and "module"
    ! are present.
d268 23
a290 1
    ! This is where we will start reading the l1bdata to get the name to read
d302 69
a370 3
    ! For height and fractional grids get stuff from L1BOA file
    if ( any ( hGridType == (/ l_Fractional, l_Height /) ) ) then
      ! Read the data
d372 2
a373 1
      call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
d375 1
a375 1
      if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
d378 1
a378 11
      ! allocate default MIFs
      allocate ( defaultMIFs(noMAFs), STAT=status )
      if ( status/=0) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_allocate//"defaultMIFs" )
      
      ! Work out which MIF should have the profile for each MAF.
      if ( hGridType==l_Fractional ) then
        ! A fractional hGrid, we need to read the tangent point phi
        tpGeodAngle => l1bField%dpField
        
        ! Loop over the MAFs
d380 2
a381 9
          ! ??? Think about missing data here! ***
          ! Probably need to do a pack on tpGeodAngle and then unpack on
          ! defaultMIFs
          
          minAngle=minval(tpGeodAngle(1,:,maf))
          maxAngle=maxval(tpGeodAngle(1,:,maf))

          call Hunt ( tpGeodAngle(1,:,maf), &
            & minAngle+fraction*(maxAngle-minAngle) , defaultMIFs(maf) )
d383 1
a383 4
      else
        tpGeodAlt => l1bField%dpField

        ! Loop over the MAFs
d385 1
a385 5
          ! ??? Think about missing data here! ***
          ! Probably need to do a pack on tpGeodAngle and then unpack on
          ! defaultMIFs
          
          call Hunt ( tpGeodAlt(1,:,maf), height, defaultMIFs(maf) )
d387 16
d405 40
a444 102
      ! Done with this piece of l1b data for the moment
      call DeallocateL1BData ( l1bField, l1bFlag )
      
      ! Now we have a default MIFs array; this is a list of the `standard'
      ! MIFs we would choose in the interpolationFactor=1 case.
      ! Work out how many profiles this is going to be.
      
      ! Create an empty hGrid
      hGrid%name = name
      hGrid%noProfs = NINT(noMAFs*interpolationFactor)
      allocate ( hGrid%phi(hGrid%noProfs), hGrid%geodLat(hGrid%noProfs), &
        & hGrid%lon(hGrid%noProfs), hGrid%time(hGrid%noProfs), &
        & hGrid%solarTime(hGrid%noProfs), hGrid%solarZenith(hGrid%noProfs), &
        & hGrid%losAngle(hGrid%noProfs), STAT=status )
      if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "hGrid information" )
      
      hGrid%noProfsLowerOverlap = 0
      hGrid%noProfsUpperOverlap = 0
      
      ! Setup some arrays
      allocate ( defaultField(noMAFs), interpolatedField(hGrid%noProfs), &
        & STAT=status )
      if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_allocate//"defaultField and/or interpolatedField" )
      
      ! Now we go through all the important geolocation quantities, read them
      ! in, interpolate them if required and store the result in the hGrid
      
      do l1bItem = 1, NoL1BItemsToRead
        ! Get the name of the item to read
        l1bItemName = l1bItemNames(l1bItem)
        if ( l1bItem >= firstModularItem ) l1bItemName = &
          & trim(instrumentModuleName)//"."//l1bItemName
        
        ! Read it from the l1boa file
        call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField,noMAFs, &
          & l1bFlag, firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex )
        if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_L1BRead//l1bItemName )
        
        if ( l1bItem==1 ) then       ! do something special for time
          do maf = 1, noMAFs
            defaultField(maf) = l1bField%dpField(1,1,maf) + &
              & (defaultMIFs(maf)-1)*sixth
          end do
        else                         ! Otherwise this is fairly easy.
          do maf = 1, noMAFs
            defaultField(maf) = l1bField%dpField(1,defaultMIFs(maf),maf)
          end do
        end IF
        
        if ( interpolationFactor==1.0 ) then
          interpolatedField = defaultField
        else
          ! ??? Some interpolation is wanted.  I'm going to hold off writing
          ! this because we certaintly don't need it for 0.1 and probably
          ! won't till 1.0.  For the sake of getting things down I'll state
          ! here what I think would be implemented.  One would simply
          ! interpolate from the defaultField to the interpolatedField, using
          ! linear or spline I imagine.  However, there are issues with roll
          ! overs for quantities such as longitude and solarTime.  This is
          ! why I have chosen to defer this piece of code. NJL - 16 December
          ! 1999
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Sorry -- interpolation of hGrids is not yet supported" )
        end if
        
        select case ( l1bItem )
        case ( l1b_MAFStartTimeTAI )
          hGrid%time = interpolatedField
        case ( l1b_tpGeodLat )
          hGrid%geodLat = interpolatedField
        case ( l1b_tpLon )
          hGrid%lon = interpolatedField
        case ( l1b_tpGeodAngle )
          hGrid%phi = interpolatedField
        case ( l1b_tpSolarZenith )
          hGrid%solarZenith = interpolatedField
        case ( l1b_tpSolarTime )
          hGrid%solarTime = interpolatedField
        case ( l1b_tpLosAngle )
          hGrid%losAngle = interpolatedField
        end select
      end do
      
      deallocate ( defaultMIFs, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate // "defaultMIFs" )
      deallocate ( defaultField, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate // "defaultField" )
      deallocate ( interpolatedField, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate // "interpolatedField" )
      
      ! ??? This calculation may need attention! ***
      hGrid%noProfsLowerOverlap = &
        & NINT(chunk%noMAFsLowerOverlap*interpolationFactor)
      hGrid%noProfsUpperOverlap = &
        & NINT(chunk%noMAFsUpperOverlap*interpolationFactor)
    endif
d446 8
a453 10
    if ( hGridType == l_explicit) then
      ! For explicit hGrids, do things differently
      hGrid%noProfs = nsons(valuesNode)-1
      hGrid%noProfsLowerOverlap = 0
      hGrid%noProfsUpperOverlap = 0
      hGrid%lon = 0.0_r8
      hGrid%time = 0.0_r8
      hGrid%solarTime = 0.0_r8
      hGrid%losAngle = 0.0_r8
      hGrid%solarZenith = 0.0_r8
d455 1
a455 11
      do prof = 1, hGrid%noProfs
        call expr ( subtree ( prof+1, valuesNode), expr_units, expr_value )
        hGrid%phi(prof) = expr_value(1)
        hGrid%geodLat(prof) = asin( sin(deg2rad*hGrid%phi(prof)) * &
          &                         sin(deg2rad*incline) )/deg2rad
      end do
    endif
      
    if ( toggle(gen) ) call trace_end ( "CreateHGridFromMLSCFInfo" )
    
  end function CreateHGridFromMLSCFInfo
d470 7
a476 22
    deallocate ( hGrid%phi, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "hGrid%phi" )
    deallocate ( hGrid%geodLat, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "hGrid%geodLat" )
    deallocate ( hGrid%lon, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "hGrid%lon" )
    deallocate ( hGrid%time, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "hGrid%time" )
    deallocate ( hGrid%solarTime, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "hGrid%solarTime" )
    deallocate ( hGrid%solarZenith, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "hGrid%solarZenith" )
    deallocate ( hGrid%losAngle, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "hGrid%losAngle" )

d535 3
@


2.8
log
@For new MLSSignals
@
text
@d9 4
a12 4
  use INIT_TABLES_MODULE, only: F_FRACTION, F_HEIGHT, F_INTERPOLATIONFACTOR, &
                                F_MODULE, F_TYPE, FIELD_FIRST, FIELD_LAST, &
                                L_FRACTIONAL, L_HEIGHT, LIT_INDICES, &
                                PHYQ_DIMENSIONLESS, PHYQ_LENGTH
d25 1
d32 1
a32 1
       "$Id: HGrid.f90,v 2.7 2001/02/22 23:44:29 livesey Exp $"
d128 1
d139 2
a140 1
    integer :: noMAFs             ! Number of MAFs of L1B data read
d143 1
d149 3
d192 5
d216 5
a220 81
    ! Read the data

    call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
       & l1bFlag, firstMAF=chunk%firstMafIndex, lastMAF=chunk%lastMafIndex )
    if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
       & MLSMSG_L1BRead//l1bItemName )

    ! allocate default MIFs

    allocate ( defaultMIFs(noMAFs), STAT=status )
    if ( status/=0) call MLSMessage ( MLSMSG_Error, ModuleName, &
       & MLSMSG_allocate//"defaultMIFs" )
   
    ! Work out which MIF should have the profile for each MAF.

    if ( hGridType==l_Fractional ) then
      ! A fractional hGrid, we need to read the tangent point phi
      tpGeodAngle => l1bField%dpField

      ! Loop over the MAFs
      do maf = 1, noMAFs
        ! ??? Think about missing data here! ***
        ! Probably need to do a pack on tpGeodAngle and then unpack on
        ! defaultMIFs

        minAngle=minval(tpGeodAngle(1,:,maf))
        maxAngle=maxval(tpGeodAngle(1,:,maf))

        call Hunt ( tpGeodAngle(1,:,maf), &
          & minAngle+fraction*(maxAngle-minAngle) , defaultMIFs(maf) )
      end do
    else
      tpGeodAlt => l1bField%dpField

      ! Loop over the MAFs
      do maf = 1, noMAFs
        ! ??? Think about missing data here! ***
        ! Probably need to do a pack on tpGeodAngle and then unpack on
        ! defaultMIFs

        call Hunt ( tpGeodAlt(1,:,maf), height, defaultMIFs(maf) )
      end do
    end if

    ! Done with this piece of l1b data for the moment
    call DeallocateL1BData ( l1bField, l1bFlag )

    ! Now we have a default MIFs array; this is a list of the `standard'
    ! MIFs we would choose in the interpolationFactor=1 case.
    ! Work out how many profiles this is going to be.

    ! Create an empty hGrid
    hGrid%name = name
    hGrid%noProfs = NINT(noMAFs*interpolationFactor)
    allocate ( hGrid%phi(hGrid%noProfs), hGrid%geodLat(hGrid%noProfs), &
      & hGrid%lon(hGrid%noProfs), hGrid%time(hGrid%noProfs), &
      & hGrid%solarTime(hGrid%noProfs), hGrid%solarZenith(hGrid%noProfs), &
      & hGrid%losAngle(hGrid%noProfs), STAT=status )
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "hGrid information" )

    hGrid%noProfsLowerOverlap = 0
    hGrid%noProfsUpperOverlap = 0

    ! Setup some arrays
    allocate ( defaultField(noMAFs), interpolatedField(hGrid%noProfs), &
      & STAT=status )
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_allocate//"defaultField and/or interpolatedField" )

    ! Now we go through all the important geolocation quantities, read them
    ! in, interpolate them if required and store the result in the hGrid

    do l1bItem = 1, NoL1BItemsToRead
      ! Get the name of the item to read
      l1bItemName = l1bItemNames(l1bItem)
      if ( l1bItem >= firstModularItem ) l1bItemName = &
        & trim(instrumentModuleName)//"."//l1bItemName

      ! Read it from the l1boa file
      call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField,noMAFs, &
d222 1
a222 1
      if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d224 25
d250 1
a250 6
      if ( l1bItem==1 ) then       ! do something special for time
        do maf = 1, noMAFs
          defaultField(maf) = l1bField%dpField(1,1,maf) + &
            & (defaultMIFs(maf)-1)*sixth
         end do
      else                         ! Otherwise this is fairly easy.
d252 5
a256 1
          defaultField(maf) = l1bField%dpField(1,defaultMIFs(maf),maf)
a257 16
      end IF

      if ( interpolationFactor==1.0 ) then
        interpolatedField = defaultField
      else
        ! ??? Some interpolation is wanted.  I'm going to hold off writing
        ! this because we certaintly don't need it for 0.1 and probably
        ! won't till 1.0.  For the sake of getting things down I'll state
        ! here what I think would be implemented.  One would simply
        ! interpolate from the defaultField to the interpolatedField, using
        ! linear or spline I imagine.  However, there are issues with roll
        ! overs for quantities such as longitude and solarTime.  This is
        ! why I have chosen to defer this piece of code. NJL - 16 December
        ! 1999
        call MLSMessage ( MLSMSG_Error, ModuleName, &
             & "Sorry -- interpolation of hGrids is not yet supported" )
d259 123
a381 35

      select case ( l1bItem )
      case ( l1b_MAFStartTimeTAI )
        hGrid%time = interpolatedField
      case ( l1b_tpGeodLat )
        hGrid%geodLat = interpolatedField
      case ( l1b_tpLon )
        hGrid%lon = interpolatedField
      case ( l1b_tpGeodAngle )
        hGrid%phi = interpolatedField
      case ( l1b_tpSolarZenith )
        hGrid%solarZenith = interpolatedField
      case ( l1b_tpSolarTime )
        hGrid%solarTime = interpolatedField
      case ( l1b_tpLosAngle )
        hGrid%losAngle = interpolatedField
      end select
    end do

    deallocate ( defaultMIFs, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "defaultMIFs" )
    deallocate ( defaultField, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "defaultField" )
    deallocate ( interpolatedField, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "interpolatedField" )

    ! ??? This calculation may need attention! ***
    hGrid%noProfsLowerOverlap = &
      & NINT(chunk%noMAFsLowerOverlap*interpolationFactor)
    hGrid%noProfsUpperOverlap = &
      & NINT(chunk%noMAFsUpperOverlap*interpolationFactor)

d479 3
@


2.7
log
@Typo
@
text
@d31 1
a31 1
       "$Id: HGrid.f90,v 2.6 2001/02/22 23:43:26 livesey Exp $"
d168 2
a169 2
        instrumentModule = decoration(subtree(2,son))
        call get_string ( lit_indices(instrumentModule), instrumentModuleName )
d447 3
@


2.6
log
@Nullified pointer elements of HGrid_T
@
text
@d31 1
a31 1
       "$Id: HGrid.f90,v 2.5 2001/02/21 01:09:24 livesey Exp $"
d54 1
a54 1
    real(r8), dimension(:), pointer :: logAngle => NULL()
d447 3
@


2.5
log
@Tidied stuff up a bit
@
text
@d31 1
a31 1
       "$Id: HGrid.f90,v 2.4 2001/02/09 19:30:16 vsnyder Exp $"
d48 7
a54 2
    real(r8), dimension(:), pointer :: phi, geodLat, lon, time, &
      & solarTime, solarZenith, losAngle
d447 3
@


2.4
log
@Move checking for required and duplicate fields to init_tables_module
@
text
@d17 1
a17 1
    & MLSMSG_DeAllocate, MLSMSG_Error, MLSMSG_L1BRead
d31 1
a31 1
       "$Id: HGrid.f90,v 2.3 2001/02/09 00:38:22 livesey Exp $"
d94 13
a106 14
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! IF MODIFYING THIS SECTION PLEASE TAKE CARE, SEE BELOW!
    integer, parameter :: NoL1BItemsToRead=7
    character (len=15), dimension(NoL1BItemsToRead), &
         &   parameter :: L1bItemsToRead = &
         & (/"MAFStartTimeTAI","tpGeodLat      ","tpLon          ",&
         &   "tpGeodAngle    ","tpSolarZenith  ","tpSolarTime    ",&
         &   "tpLosAngle     "/)
    integer, parameter :: TransitionToModularItems = 2
    ! Entries in the above array below TransitionToModularItems are prefixed
    ! with either GHz or THz.  The layout of the above array is critically
    ! bound to the "select case ( l1bItem )" code below.  So TAKE CARE! when
    ! modifing it.
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
d140 7
d274 2
a275 2
      l1bItemName = l1bItemsToRead(l1bItem)
      if ( l1bItem >= TransitionToModularItems ) l1bItemName = &
a310 5
      ! Now we have to save this field in the hGrid data.  This is rather a
      ! kludgy way of doing it but this worked out the least boring way to
      ! write the code.  See the definition of L1BItemsToRead above for
      ! reference.

d312 1
a312 1
      case ( 1 )
d314 1
a314 1
      case ( 2 )
d316 1
a316 1
      case ( 3 )
d318 1
a318 1
      case ( 4 )
d320 1
a320 1
      case ( 5 )
d322 1
a322 1
      case ( 6 )
d324 1
a324 1
      case ( 7 )
d442 3
@


2.3
log
@Various updates
@
text
@d31 1
a31 1
       "$Id: HGrid.f90,v 2.2 2001/02/08 01:50:11 vsnyder Exp $"
d60 1
a60 3
  integer, private, parameter :: NoInstrumentModule = NoHeight + 1
  integer, private, parameter :: NoType = NoInstrumentModule + 1
  integer, private, parameter :: UnitlessMessage = NoType + 1
d178 2
a179 5
    ! Now check the sanity of what we have

    if ( .not. got_field(f_type) ) call announce_error ( root, noType )
    if ( .not. got_field(f_module) ) &
      & call announce_error ( root, noInstrumentModule )
a427 5
    case ( noInstrumentModule )
      call output ( "No instrument module specified for the hGrid", &
        & advance='yes' )
    case ( noType )
      call output ( "No type specified for the hGrid", advance='yes' )
d441 3
@


2.2
log
@Move duplicate field checking to tree_checker, set by init_tables
@
text
@d31 1
a31 1
       "$Id: HGrid.f90,v 2.1 2000/12/04 23:34:38 vsnyder Exp $"
d359 1
a359 1
    type (HGrid_T), intent(out) :: hGrid
d365 1
a365 1

a400 1

d451 3
@


2.1
log
@Move more of addItemToDatabase into the include.
@
text
@d31 1
a31 1
       "$Id: HGrid.f90,v 2.0 2000/09/11 19:18:01 ahanzel Exp $"
d57 6
a62 7
  integer, private, parameter :: DuplicateField = 1
  integer, private, parameter :: LengthUnitMessage = 2
  integer, private, parameter :: NoFraction = 3
  integer, private, parameter :: NoHeight = 4
  integer, private, parameter :: NoInstrumentModule = 5
  integer, private, parameter :: NoType = 6
  integer, private, parameter :: UnitlessMessage = 7
d153 1
a153 2
      if ( got_field(field_index) ) &
        & call announce_error ( field, duplicateField )
a423 4
    case ( duplicateField )
      call output ( "The " )
      call dump_tree_node ( where, 0 )
      call output ( " field appears more than once.", advance='yes' )
d452 3
@


2.0
log
@Changing revision to 2.0.
@
text
@d31 1
a31 1
       "$Id: HGrid.f90,v 1.1 2000/09/07 17:36:29 vsnyder Exp $"
a78 1
    database(newSize) = item
d458 3
@


1.1
log
@Initial version 2.0
@
text
@d31 1
a31 1
       "$Id: HGrid.f90,v 1.1 2000/09/07 17:36:29 vsnyder Exp $"
d459 3
d473 1
a473 23
! Revision 1.7  2000/05/16 19:59:37  livesey
! Added stuff to deal with `time' correctly.
!
! Revision 1.6  2000/01/18 00:14:51  livesey
! Removed profileIndices etc. No longer relevant, as Join deals with this stuff
! for l2gp quantities.
!
! Revision 1.5  2000/01/11 22:51:34  livesey
! Dealt with ramifications of change from read_parse_l2cf to MLSCF
!
! Revision 1.4  2000/01/07 23:53:34  livesey
! Nearly integrated, just a few tweaks.
!
! Revision 1.3  1999/12/17 21:39:34  livesey
! Added check for duplicate name in database.
!
! Revision 1.2  1999/12/16 18:23:20  livesey
! First version that compiles.
!
! Revision 1.1  1999/12/16 01:26:46  livesey
! Nightly checkin
!
!
@


