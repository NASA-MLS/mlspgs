head	2.214;
access;
symbols
	v5-02-NRT-19:2.214
	v6-00:2.214
	v5-02-NRT-18:2.214
	v5-02:2.213
	v5-01-NRT-17:2.214
	v5-01-NRT-16:2.214
	v5-01-NRT-15:2.214
	v5-01-NRT-14:2.214
	neuralnetworks-1-0:2.214.0.4
	cfm-single-freq-0-1:2.214.0.2
	v5-01:2.213
	v5-00:2.213
	v4-23-TA133:2.212.0.2
	mus-emls-1-70:2.210.0.2
	rel-1-0-englocks-work:2.208.0.2
	VUMLS1-00:2.207
	VPL1-00:2.204
	V4-22-NRT-08:2.203
	VAM1-00:2.199
	V4-21:2.196.0.2
	V4-13:2.196
	V4-12:2.194
	V4-11:2.193
	V4-10:2.193
	V3-43:2.169.2.1
	M4-00:2.182
	V3-41:2.169.2.1
	V3-40-PlusGM57:2.169.0.2
	V2-24-NRT-04:2.161
	V3-33:2.172
	V2-24:2.161
	V3-31:2.172
	V3-30-NRT-05:2.172
	cfm-01-00:2.172
	V3-30:2.169
	V3-20:2.169
	V3-10:2.167
	V2-23-NRT-02:2.161
	V2-23:2.161
	V2-22-NRT-01:2.161
	V2-22:2.161
	V2-21:2.153
	V2-20:2.151
	V2-11:2.144
	V2-10:2.144
	V2-00:2.142
	V1-51:2.129
	V1-50:2.129
	V1-45:2.128
	V1-44:2.128
	V1-43:2.126
	V1-32:2.122
	V1-31:2.122
	V1-30:2.116
	V1-13:2.104
	V1-12:2.104
	V1-11:2.104
	V1-10:2.102
	newfwm-feb03:2.102.0.2
	V1-04:2.82
	V1-03:2.82
	V1-02:2.82
	JointForwardModel:2.82.0.2
	V1-00:2.82
	newfwm-sep01:2.58.0.2
	V0-7:2.58
	V0-5-Level2:2.50
	V0-5-SIPS:2.33;
locks; strict;
comment	@# @;


2.214
date	2020.04.30.23.28.37;	author pwagner;	state Exp;
branches;
next	2.213;

2.213
date	2019.09.19.16.13.01;	author pwagner;	state Exp;
branches;
next	2.212;

2.212
date	2018.09.13.20.23.23;	author pwagner;	state Exp;
branches;
next	2.211;

2.211
date	2018.07.27.23.19.53;	author pwagner;	state Exp;
branches;
next	2.210;

2.210
date	2018.04.19.23.44.36;	author pwagner;	state Exp;
branches;
next	2.209;

2.209
date	2018.04.19.00.49.44;	author vsnyder;	state Exp;
branches;
next	2.208;

2.208
date	2018.03.14.22.08.36;	author pwagner;	state Exp;
branches;
next	2.207;

2.207
date	2017.01.25.17.24.22;	author pwagner;	state Exp;
branches;
next	2.206;

2.206
date	2016.11.08.17.31.26;	author pwagner;	state Exp;
branches;
next	2.205;

2.205
date	2016.09.21.00.40.17;	author pwagner;	state Exp;
branches;
next	2.204;

2.204
date	2016.08.09.22.08.33;	author pwagner;	state Exp;
branches;
next	2.203;

2.203
date	2016.05.18.01.37.30;	author vsnyder;	state Exp;
branches;
next	2.202;

2.202
date	2016.05.06.17.50.17;	author pwagner;	state Exp;
branches;
next	2.201;

2.201
date	2016.05.04.18.22.59;	author pwagner;	state Exp;
branches;
next	2.200;

2.200
date	2015.10.13.23.51.53;	author pwagner;	state Exp;
branches;
next	2.199;

2.199
date	2015.09.03.20.29.47;	author pwagner;	state Exp;
branches;
next	2.198;

2.198
date	2015.08.03.21.46.59;	author pwagner;	state Exp;
branches;
next	2.197;

2.197
date	2015.06.19.20.40.04;	author pwagner;	state Exp;
branches;
next	2.196;

2.196
date	2014.10.07.00.22.32;	author pwagner;	state Exp;
branches;
next	2.195;

2.195
date	2014.09.05.01.28.14;	author vsnyder;	state Exp;
branches;
next	2.194;

2.194
date	2014.06.30.23.30.45;	author pwagner;	state Exp;
branches;
next	2.193;

2.193
date	2014.04.10.00.43.11;	author pwagner;	state Exp;
branches;
next	2.192;

2.192
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.191;

2.191
date	2014.01.08.21.04.16;	author vsnyder;	state Exp;
branches;
next	2.190;

2.190
date	2013.12.13.21.25.30;	author vsnyder;	state Exp;
branches;
next	2.189;

2.189
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.188;

2.188
date	2013.10.09.00.24.30;	author pwagner;	state Exp;
branches;
next	2.187;

2.187
date	2013.10.01.22.18.56;	author pwagner;	state Exp;
branches;
next	2.186;

2.186
date	2013.08.30.02.45.52;	author vsnyder;	state Exp;
branches;
next	2.185;

2.185
date	2013.08.23.23.32.55;	author pwagner;	state Exp;
branches;
next	2.184;

2.184
date	2013.08.17.02.54.32;	author vsnyder;	state Exp;
branches;
next	2.183;

2.183
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.182;

2.182
date	2013.04.05.23.25.41;	author pwagner;	state Exp;
branches;
next	2.181;

2.181
date	2013.02.14.19.04.29;	author pwagner;	state Exp;
branches;
next	2.180;

2.180
date	2012.08.16.17.56.54;	author pwagner;	state Exp;
branches;
next	2.179;

2.179
date	2012.04.26.23.15.28;	author pwagner;	state Exp;
branches;
next	2.178;

2.178
date	2011.10.07.00.06.02;	author pwagner;	state Exp;
branches;
next	2.177;

2.177
date	2011.06.29.21.51.17;	author pwagner;	state Exp;
branches;
next	2.176;

2.176
date	2011.06.16.23.18.01;	author pwagner;	state Exp;
branches;
next	2.175;

2.175
date	2011.05.09.18.27.56;	author pwagner;	state Exp;
branches;
next	2.174;

2.174
date	2011.04.20.16.53.43;	author pwagner;	state Exp;
branches;
next	2.173;

2.173
date	2011.04.08.00.10.00;	author pwagner;	state Exp;
branches;
next	2.172;

2.172
date	2010.04.13.01.43.09;	author vsnyder;	state Exp;
branches;
next	2.171;

2.171
date	2010.03.17.20.57.35;	author pwagner;	state Exp;
branches;
next	2.170;

2.170
date	2010.02.25.18.20.44;	author pwagner;	state Exp;
branches;
next	2.169;

2.169
date	2010.02.04.19.10.58;	author pwagner;	state Exp;
branches
	2.169.2.1;
next	2.168;

2.168
date	2009.10.01.19.58.00;	author vsnyder;	state Exp;
branches;
next	2.167;

2.167
date	2009.06.23.18.46.19;	author pwagner;	state Exp;
branches;
next	2.166;

2.166
date	2008.12.18.21.12.41;	author pwagner;	state Exp;
branches;
next	2.165;

2.165
date	2008.09.19.23.56.28;	author pwagner;	state Exp;
branches;
next	2.164;

2.164
date	2008.05.20.00.29.19;	author vsnyder;	state Exp;
branches;
next	2.163;

2.163
date	2008.04.01.17.00.15;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2007.12.07.01.15.01;	author pwagner;	state Exp;
branches;
next	2.161;

2.161
date	2007.10.09.00.34.21;	author pwagner;	state Exp;
branches;
next	2.160;

2.160
date	2007.09.13.21.51.39;	author pwagner;	state Exp;
branches;
next	2.159;

2.159
date	2007.09.06.23.35.16;	author pwagner;	state Exp;
branches;
next	2.158;

2.158
date	2007.08.31.00.03.26;	author pwagner;	state Exp;
branches;
next	2.157;

2.157
date	2007.06.21.00.54.08;	author vsnyder;	state Exp;
branches;
next	2.156;

2.156
date	2007.06.07.20.41.07;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2007.04.03.17.36.44;	author vsnyder;	state Exp;
branches;
next	2.154;

2.154
date	2007.03.23.00.29.41;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2007.02.14.17.31.00;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2007.01.12.00.34.04;	author pwagner;	state Exp;
branches;
next	2.151;

2.151
date	2006.10.09.18.39.35;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2006.10.05.23.32.43;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2006.08.14.16.22.28;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2006.08.10.21.46.50;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2006.08.05.02.10.46;	author vsnyder;	state Exp;
branches;
next	2.146;

2.146
date	2006.08.05.00.41.50;	author vsnyder;	state Exp;
branches;
next	2.145;

2.145
date	2006.08.02.19.53.26;	author vsnyder;	state Exp;
branches;
next	2.144;

2.144
date	2006.07.24.20.35.04;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2006.07.21.20.12.26;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2006.06.12.16.28.25;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2006.05.05.16.49.23;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2006.04.11.23.30.00;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2006.03.04.00.22.04;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2006.02.16.00.16.32;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2006.02.10.21.15.26;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2006.01.11.17.02.16;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2006.01.06.01.15.01;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2005.08.19.23.35.01;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2005.07.12.17.37.20;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2005.06.14.20.44.36;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2005.06.03.02.05.29;	author vsnyder;	state Exp;
branches;
next	2.130;

2.130
date	2005.05.31.17.51.17;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2004.12.14.21.56.50;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2004.07.22.20.49.58;	author cvuu;	state Exp;
branches;
next	2.127;

2.127
date	2004.05.19.19.16.12;	author vsnyder;	state Exp;
branches;
next	2.126;

2.126
date	2004.04.28.23.07.44;	author livesey;	state Exp;
branches;
next	2.125;

2.125
date	2004.02.10.19.29.36;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2004.01.17.00.28.09;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2004.01.14.18.49.58;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2003.12.16.01.28.56;	author livesey;	state Exp;
branches;
next	2.121;

2.121
date	2003.12.11.22.59.32;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2003.12.05.00.42.05;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2003.11.07.00.46.51;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2003.11.05.21.27.54;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2003.10.09.23.31.26;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2003.09.03.15.56.18;	author cvuu;	state Exp;
branches;
next	2.115;

2.115
date	2003.09.02.18.04.38;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2003.08.21.21.24.39;	author cvuu;	state Exp;
branches;
next	2.113;

2.113
date	2003.08.21.16.07.34;	author livesey;	state Exp;
branches;
next	2.112;

2.112
date	2003.08.11.23.24.02;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2003.07.07.23.51.06;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2003.06.30.22.56.16;	author cvuu;	state Exp;
branches;
next	2.109;

2.109
date	2003.06.24.23.54.07;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2003.06.24.23.00.53;	author livesey;	state Exp;
branches;
next	2.107;

2.107
date	2003.06.23.23.55.17;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2003.06.20.19.38.26;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2003.06.09.22.51.35;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2003.03.08.00.46.08;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2003.02.21.21.03.39;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2003.01.13.20.59.14;	author livesey;	state Exp;
branches;
next	2.101;

2.101
date	2002.12.05.19.45.20;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2002.12.04.01.18.21;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2002.11.22.12.24.25;	author mjf;	state Exp;
branches;
next	2.98;

2.98
date	2002.11.22.01.14.06;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2002.11.21.18.45.04;	author livesey;	state Exp;
branches;
next	2.96;

2.96
date	2002.11.21.18.38.34;	author livesey;	state Exp;
branches;
next	2.95;

2.95
date	2002.10.08.17.41.50;	author livesey;	state Exp;
branches;
next	2.94;

2.94
date	2002.10.08.17.36.23;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2002.10.05.00.44.29;	author livesey;	state Exp;
branches;
next	2.92;

2.92
date	2002.09.25.20.09.32;	author livesey;	state Exp;
branches;
next	2.91;

2.91
date	2002.09.24.22.17.50;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2002.09.24.18.18.47;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2002.08.28.22.29.19;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2002.08.22.01.26.00;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2002.08.21.19.05.04;	author livesey;	state Exp;
branches;
next	2.86;

2.86
date	2002.08.21.00.55.35;	author livesey;	state Exp;
branches;
next	2.85;

2.85
date	2002.08.20.22.10.50;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2002.08.07.00.05.27;	author livesey;	state Exp;
branches;
next	2.83;

2.83
date	2002.08.04.16.10.43;	author mjf;	state Exp;
branches;
next	2.82;

2.82
date	2002.03.20.00.49.44;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2002.02.05.00.44.03;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2002.01.24.00.58.28;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2002.01.22.18.14.47;	author livesey;	state Exp;
branches;
next	2.78;

2.78
date	2002.01.21.23.11.06;	author livesey;	state Exp;
branches;
next	2.77;

2.77
date	2002.01.18.18.55.37;	author livesey;	state Exp;
branches;
next	2.76;

2.76
date	2002.01.09.22.56.17;	author livesey;	state Exp;
branches;
next	2.75;

2.75
date	2001.12.16.00.57.12;	author livesey;	state Exp;
branches;
next	2.74;

2.74
date	2001.12.14.01.43.20;	author livesey;	state Exp;
branches;
next	2.73;

2.73
date	2001.12.13.23.21.26;	author livesey;	state Exp;
branches;
next	2.72;

2.72
date	2001.12.10.20.22.09;	author livesey;	state Exp;
branches;
next	2.71;

2.71
date	2001.11.20.00.48.15;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2001.11.16.17.24.13;	author livesey;	state Exp;
branches;
next	2.69;

2.69
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2001.10.31.19.07.52;	author livesey;	state Exp;
branches;
next	2.67;

2.67
date	2001.10.31.18.36.58;	author livesey;	state Exp;
branches;
next	2.66;

2.66
date	2001.10.26.23.16.15;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2001.10.12.23.14.22;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2001.10.09.23.43.42;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2001.10.02.16.49.56;	author livesey;	state Exp;
branches;
next	2.62;

2.62
date	2001.09.29.00.01.00;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2001.09.28.17.50.30;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2001.09.21.17.40.57;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2001.09.10.23.37.32;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2001.08.06.18.34.59;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2001.07.11.21.40.21;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2001.06.13.20.44.08;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2001.06.07.21.58.28;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2001.05.23.22.00.16;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2001.05.23.01.44.35;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2001.05.10.00.43.23;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2001.05.04.17.12.25;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2001.05.03.20.34.08;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2001.05.02.23.23.00;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2001.04.28.01.31.46;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2001.04.26.20.02.09;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2001.04.26.00.08.02;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2001.04.25.21.54.16;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2001.04.25.21.52.13;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2001.04.25.20.34.36;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2001.04.25.19.31.13;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2001.04.24.23.05.54;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2001.04.24.20.20.02;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2001.04.24.20.05.50;	author livesey;	state Exp;
branches;
next	2.37;

2.37
date	2001.04.21.01.41.35;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2001.04.21.01.26.37;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2001.04.20.17.12.38;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2001.04.19.23.51.40;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2001.04.11.17.47.47;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2001.04.10.22.27.47;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2001.04.10.02.46.17;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2001.04.10.00.02.19;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2001.04.07.01.50.49;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2001.04.06.20.12.59;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.04.02.15.12;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.03.20.50.45;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.02.23.41.09;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2001.03.29.19.13.03;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.03.28.23.47.48;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.03.28.01.24.55;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2001.03.17.03.30.25;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2001.03.17.00.45.53;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.03.15.23.26.09;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.03.15.21.20.54;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2001.03.15.21.05.23;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.03.14.02.04.53;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.03.09.19.57.48;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2001.03.08.18.21.11;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.03.08.03.23.10;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.03.07.22.46.05;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.03.03.00.13.30;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.02.28.01.17.57;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.02.27.17.38.07;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.02.23.02.51.44;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.02.08.01.40.53;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.01.03.17.48.43;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2000.12.05.00.41.50;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2000.11.30.00.21.08;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2000.11.29.00.27.54;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2000.10.10.00.37.46;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2000.10.10.00.27.09;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.06;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.02.02.05.04;	author vsnyder;	state Exp;
branches;
next	;

2.169.2.1
date	2011.11.16.23.33.51;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.214
log
@Add call To FinalMemoryReport at start of each cnunk
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module TREE_WALKER

! Traverse the tree output by the parser and checked by the tree checker.
! Perform the actions of the MLS L2 processing in the order indicated.

  implicit none
  private

  public :: WALK_TREE_TO_DO_MLS_L2
  
  logical, parameter :: ComplainIfSkippedEveryChunk = .true.
  logical, parameter :: MustCheckForCorruptFileDatabase = .false.

!---------------------------- RCS Ident Info -------------------------------
  character(len=*), private, parameter :: ModuleName= &
       "$RCSfile: tree_walker.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains ! ====     Public Procedures     ==============================
  ! -------------------------------------  WALK_TREE_TO_DO_MLS_L2  -----
  subroutine WALK_TREE_TO_DO_MLS_L2 ( ROOT, ERROR_FLAG, FIRST_SECTION, &
    & COUNTCHUNKS, FILEDATABASE )

    use Algebra_M, only: Algebra
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, FinalMemoryReport
    use AntennaPatterns_M, only: Destroy_Ant_Patterns_Database
    use ChunkDivide_M, only: ChunkDivide, DestroyChunkDatabase
    use Chunks_M, only: Dump, MLSChunk_T
    use Construct, only: MLSL2Construct, MLSL2Deconstruct, &
      & ConstructMIFGeolocation, DestroyMIFGeolocation
    use DirectWrite_M, only: DirectData_T, DestroydirectDatabase
    use Dump_0, only: Dump
    use EmpiricalGeometry, only: ForgetOptimumLon0
    use FGrid, only: Fgrid_T, DestroyFGridDatabase, Dump
    use Fill, only: MLSL2Fill
    use ForwardModelConfig, only: ForwardModelConfig_T, &
      & DestroyFwmConfigDatabase, &
      & StripForwardModelConfigDatabase
    use ForwardModelSupport, only: PrintForwardModelTiming
    use Global_Settings, only: Set_Global_Settings
    use GriddedData, only: GriddedData_T, DestroyGriddedDataDatabase, Dump
    use HessianModule_1, only: DestroyHessianDatabase, Hessian_T
    use HGridsDatabase, only: HGrids_T
    use HGrid, only: ComputeAllHGridOffsets, DestroyHGridGeoLocations
    use HighOutput, only: BeVerbose, GetStamp, HeadLine, OutputNamedValue, &
      & SetStamp
    use Init_Tables_Module, only: L_Chisqchan, L_Chisqmmaf, L_Chisqmmif, &
      & Section_First, Section_Last, &
      & Z_Algebra, Z_Chunkdivide, Z_Construct, Z_Fill, Z_Globalsettings, &
      & Z_Join, Z_Mergegrids, Z_MLSsignals, Z_Output, Z_Readapriori, &
      & Z_Retrieve, Z_Spectroscopy
    use Intrinsic, only: Section_Indices
    use Join, only: MLSL2Join
    use L1BData, only: CheckForCorruptFileDatabase
    use L2AUXData, only: DestroyL2AUXDatabase, L2AUXData_T, Dump
    use L2FWMParallel, only: L2FWMSlaveTask, LaunchFWMSlaves
    use L2GPData, only: DestroyL2GPDatabase, L2GPData_T, Dump
    use L2Parallel, only: GetChunkInfoFromMaster, L2MasterTask
    use L2Parinfo, only: Parallel, CloseParallel
    use L2PC_M, only: DestroyL2PCDatabase, DestroyBinSelectorDatabase
    use L2PCBins_M, only: FlushLockedBins
    use MatrixModule_1, only: DestroyMatrixDatabase, Matrix_Database_T
    use MergeGridsModule, only: MergeGrids
    use MLSCommon, only: TAI93_Range_T, MLSFile_T
    use MLSL2Options, only: Aura_L1BFiles, &
      & CheckPaths, L2Options, ExitToNextChunk, &
      & L2CFNode, MLSL2Message, Need_L1BFiles, PhasesToSkip, &
      & SectionsToSkip, SkipDirectWrites, SkipDirectWritesOriginal, &
      & SlavesCleanUpSelves, SpecialDumpFile, StopAfterSection, &
      & Toolkit
    use MLSMessageModule, only: MLSMSG_Allocate, MLSMSG_Info, &
      & MLSMSG_Error, SummarizeWarnings
    use MLSPCF2, only: MLSPCF_Spectroscopy_End
    use MLSFinds, only: FindFirst
    use MLSSignals_M, only: Bands, DestroyBandDatabase, DestroyModuleDatabase, &
      & DestroyRadiometerDatabase, DestroySignalDatabase, &
      & DestroySpectrometerTypeDatabase, IsSpacecraftAura, &
      & MLSSignals, Modules, Radiometers, &
      & Signals, SpectrometerTypes
    use MLSStringLists, only: ExpandStringRange, IsInList, SwitchDetail
    use MLSStrings, only: Lowercase
    use MLSL2Timings, only: Add_To_Section_Timing, RestartTimings
    use Next_Tree_Node_M, only: Dump, &
      & Next_Tree_Node, Next_Tree_Node_State
    use Open_Init, only: OpenAndInitialize
    use OutputAndClose, only: Output_Close
    use Output_M, only: Output, ResumeOutput, RevertOutput, SwitchOutput
    use PointingGrid_M, only: Destroy_Pointing_Grid_Database
    use QuantityTemplates, only: QuantityTemplate_T ! , &
!       & DestroyQuantityTemplateDatabase
    use ReadApriori, only: Read_Apriori
    use RetrievalModule, only: Retrieve
    use SpectroscopyCatalog_M, only: Destroy_Line_Database, &
      & Destroy_Spectcat_Database, Spectroscopy
    use String_Table, only: Get_String
    use Time_M, only: SayTime, Time_Now
    use Toggles, only: Gen, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decoration, Subtree
    use VectorsModule, only: DestroyVectorDatabase, Dump_Vectors, &
      & Vector_T, VectorTemplate_T
    use VGridsDatabase, only: DestroyVGridDatabase, VGrids

    integer, intent(in) ::     ROOT        ! Root of the abstract syntax tree
    integer, intent(out) ::    ERROR_FLAG  ! Nonzero means failure
    integer, intent(in) ::     FIRST_SECTION! Index of son of root of first n_cf
    logical, intent(in) ::     COUNTCHUNKS ! Just count, print, and quit

    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    ! Internal variables
    logical ::                                   canWriteL2PC
    integer ::                                   chunkNo ! Index of Chunks
    type (MLSChunk_T), dimension(:), pointer ::  Chunks  ! of data
    logical, dimension(:), pointer :: CHUNKSSKIPPED => null() ! Don't do these
    integer                                   :: details
    logical                                   :: doneWithChunks
    type (DirectData_T), dimension(:), pointer :: DirectDatabase
    type (FGrid_T), dimension(:), pointer ::     FGrids
    ! Forward model configurations:
    integer ::                                   FIRSTCHUNK ! For chunk loop
    type (ForwardModelConfig_T), dimension(:), &
      & pointer ::                               ForwardModelConfigDatabase
    type (GriddedData_T), dimension(:), &
      & pointer ::                               GriddedDataBase
    type (Hessian_T), dimension(:), pointer ::   Hessians
    type (HGrids_T), dimension(:), pointer ::    HGrids
    integer ::                                   I       ! Loop inductors
    integer, dimension(1) :: ICHUNKS
    integer ::                                   LASTCHUNK ! For chunk loop
    type (L2AUXData_T), dimension(:), pointer :: L2AUXDatabase
    type (L2GPData_T), dimension(:), pointer  :: L2GPDatabase
    type (Matrix_Database_T), dimension(:), &
      & pointer ::                               Matrices
    integer :: Me = -1                           ! String index for trace
    logical ::                                   now_stop
    type (TAI93_Range_T) ::                      ProcessingRange  ! Data processing range
    integer ::                                   section_index
    character(len=32) ::                         section_name
    logical ::                                   showTime
    logical, dimension(SECTION_FIRST:SECTION_LAST) :: skipSections
    integer ::                                   SON     ! Son of Root
    type(next_tree_node_state) ::                State, Save1, Save2 ! of tree traverser
    logical ::                                   STOPBEFORECHUNKLOOP
    real    ::                                   t1, tChunk
    character(len=24) ::                         textCode
    type (Vector_T), dimension(:), pointer ::    Vectors
    logical :: verbose
    logical :: verboser
    logical :: warnOnDestroy        ! Whether to warn before destroying dbs

    ! Arguments for Construct not declared above:
    type (QuantityTemplate_T), dimension(:), pointer :: MifGeolocation
    type (QuantityTemplate_T), dimension(:), pointer :: QtyTemplates
    type (VectorTemplate_T), dimension(:), pointer :: VectorTemplates

    ! Executable
    verbose = BeVerbose ( 'walker', -1 )
    verboser = BeVerbose ( 'walker', 0 )
    call trace_begin ( me, 'WALK_TREE_TO_DO_MLS_L2', &
      & subtree(first_section,root), index=first_section, cond=toggle(gen) )
    call time_now ( t1 )

    nullify ( chunks, forwardModelConfigDatabase, griddedDataBase, hessians, &
      & directDatabase, hGrids, l2auxDatabase, l2gpDatabase, matrices, mifGeolocation, &
      & qtyTemplates, vectorTemplates, fGrids, vGrids )

    ! Allocate Vectors with size zero so nobody has to check whether it's
    ! associated.  This allows to remove the pointer attribute in several
    ! places.
    allocate ( vectors(0), stat=error_flag )
    if ( error_flag /= 0 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // 'vectors' )
    allocate ( directDatabase(0), stat=error_flag )
    if ( error_flag /= 0 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // 'direct write files' )

    nullify ( chunksSkipped )
    warnOnDestroy = ( switchDetail(switches, 'destroy' ) > -1 )
    canWriteL2PC = .false.
    stopBeforeChunkLoop          = ( &
      & index('global_setting,chunk_divide', &
      & lowercase( trim(stopAfterSection) ) ) > 0 )
    stopBeforeChunkLoop = ( stopBeforeChunkLoop .and. stopAfterSection /= ' ' )
    skipSections = .false.
    do i = section_first, section_last
      call get_string ( section_indices(i), section_name, strip=.true. )
      skipSections(i) = isInList( sectionstoskip, section_name, '-fc' )
    end do
    call OpenAndInitialize ( processingRange, filedatabase )
    call add_to_section_timing ( 'open_init', t1, now_stop )
    if ( now_stop ) then
      call finishUp ( .true. )
      return
    end if

    ! -----------------------------------------------------
    ! ----------------------------------------------------- Loop over tree

    chunkNo = 0
    doneWithChunks = .false.
    ! Now loop over the sections in the tree
    do
      save1 = state
      son = next_tree_node(root,state,start=first_section)
      if ( son == 0 ) exit
      L2CFNODE = son
      section_index = decoration(subtree(1,son))
      call get_string ( section_indices(section_index), section_name, &
        & strip=.true. )
      if ( section_index > SECTION_FIRST - 1 .and. &
        & section_index < SECTION_LAST + 1 ) then
        if( skipSections(section_index) ) &
          & section_index = SECTION_FIRST - 1 ! skip
      end if
      ! First those involved in 'preprocessing'
      select case ( section_index )

        ! -------------------------------------------------------- Init sections
      case ( z_globalsettings )
        if ( verboser ) call Dump ( state, 'at globalsettings' )
        call set_global_settings ( son, forwardModelConfigDatabase, &
          & filedatabase, fGrids, l2gpDatabase, DirectDatabase, processingRange )
        call add_to_section_timing ( 'global_settings', t1, now_stop )
        if ( now_stop .and. .not. parallel%slave ) then
          call finishUp(.true.)
          return
        end if
        if ( verbose .and. MustCheckForCorruptFileDatabase ) then
          call output( 'Done with global settings', advance='yes' )
          call CheckForCorruptFileDatabase( filedatabase )
        endif
      case ( z_mlsSignals )
        if ( verboser ) call Dump ( state, 'at mlsSignals' )
        call MLSSignals ( son )
        if ( switchDetail(switches,'tps') > -1 ) then
          ! call test_parse_signals
          call MLSL2Message ( MLSMSG_Info, ModuleName, &
            & 'Go back and uncomment the previous line in tree_walker' )
        end if
        ! Here's one way for the l2cf to set Aura to .false.
        ! Put a line like
        !  SC: Module, Aura=false, /spaceCraft
        ! in your MLSSignals section
        AURA_L1BFILES = AURA_L1BFILES .and. IsSpaceCraftAura()
        call add_to_section_timing ( 'signals', t1, now_stop )
        if ( now_stop ) then
          call finishUp(.true.)
          return
        end if
      case ( z_spectroscopy )
        if ( verboser ) call Dump ( state, 'at spectroscopy' )
        call spectroscopy ( son, &
          & TOOLKIT, mlspcf_spectroscopy_end, fileDatabase )
        call add_to_section_timing ( 'spectroscopy', t1, now_stop )
        if ( now_stop ) then
          call finishUp(.true.)
          return
        end if
      case ( z_readapriori )
        if ( verboser ) call Dump ( state, 'at readapriori' )
        if ( .not. ( stopBeforeChunkLoop .or. parallel%master ) ) &
          & call read_apriori ( son , &
          & l2gpDatabase, l2auxDatabase, griddedDataBase, fileDataBase )
        call add_to_section_timing ( 'read_apriori', t1, now_stop )
        if ( now_stop ) then
          call finishUp(.true.)
          return
        end if
      case ( z_mergeGrids )
        if ( .not. &
          & ( stopBeforeChunkLoop .or. checkPaths .or. parallel%master ) &
          & ) call mergeGrids ( son, l2gpDatabase, l2auxDatabase, &
          & griddedDataBase, fileDataBase )

        ! ------------------------------------------------------- Chunk divide
        ! Chunk divide can be a special one, in slave mode, we just listen out
        ! for instructions.
        call add_to_section_timing ( 'merge_grids', t1, now_stop )
        if ( now_stop ) then
          call finishUp(.true.)
          return
        end if
      case ( z_chunkdivide )
        if ( verboser ) call Dump ( state, 'at chunkdivide' )
        if ( parallel%slave .and. .not. parallel%fwmParallel ) then
          call GetChunkInfoFromMaster ( chunks, chunkNo )
          firstChunk = chunkNo
          lastChunk = chunkNo
          parallel%ChunkNo = chunkNo
          L2Options%CurrentChunkNumber = chunkNo
        else
          if ( (.not. checkPaths .or. parallel%chunkRange /= '') .and. &
            & NEED_L1BFILES ) then
            if ( verbose .and. MustCheckForCorruptFileDatabase ) then
              call output( 'before chunk divide', advance='yes' )
              call CheckForCorruptFileDatabase( filedatabase )
            endif
            call ChunkDivide ( son, processingRange, filedatabase, chunks )
            if ( verbose .and. MustCheckForCorruptFileDatabase ) then
              call output( 'after chunk divide', advance='yes' )
              call CheckForCorruptFileDatabase( filedatabase )
            endif
            call ComputeAllHGridOffsets ( root, first_section, chunks, &
              & filedatabase, &
              & l2gpDatabase, processingRange )
            if ( verbose .and. MustCheckForCorruptFileDatabase ) then
              call output( 'after computing hgrid offsets', advance='yes' )
              call CheckForCorruptFileDatabase( filedatabase )
            endif
          else
            allocate ( chunks(1), stat=error_flag )
            if ( error_flag /= 0 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
              & MLSMSG_Allocate // 'chunks' )
            if ( .not. NEED_L1BFILES ) then
              call output( 'Creating artificial chunk', advance='yes' )
              if ( switchDetail(switches, 'chu' ) > -1 ) &
                & call dump( chunks(1) )
            end if
          end if
          firstChunk = 1
          lastChunk = size(chunks)
          if ( countChunks ) then
            error_flag = 0
            call output ( size(chunks) )
            return
          end if
        end if
        call add_to_section_timing ( 'chunk_divide', t1, now_stop )
        if ( now_stop ) then
          call finishUp(.true.)
          return
        end if
        if ( verbose ) &
          & call outputNamedValue ( 'First, last chunks', (/ firstChunk, lastChunk /) )
      case ( z_algebra )
        call algebra ( son, vectors, matrices, chunks(1), &
          & forwardModelConfigDatabase )
        ! ---------------------------------------------------- Chunk processing
        ! Now construct, fill, join and retrieve live inside the 'chunk loop'
      case ( z_construct, z_fill, z_join, z_retrieve )
        if ( doneWithChunks ) cycle
        if ( verboser ) call Dump ( state, 'at other' )
        ! Do special stuff in some parallel cases, or where there are
        ! no chunks.
        if ( .not. associated(chunks) ) then
          allocate(chunks(1), stat=error_flag)
          if ( error_flag /= 0 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
            & 'unable to allocate chunks' )
          firstChunk = 1
          lastChunk = size(chunks)
        end if
        if ( ( size(chunks) < 1 ) .or. &
          & ( parallel%master .and. .not. parallel%fwmParallel ) .or. &
          & ( parallel%slave .and. parallel%fwmParallel ) ) then
          if ( parallel%master .and. .not. parallel%fwmParallel ) then
            call outputNamedValue( 'Calling L2MasterTask with num chunks ', size(chunks) )
            call L2MasterTask ( chunks )
            doneWithChunks = .true.
            call add_to_section_timing ( 'master', t1, now_stop )
            cycle
          end if
          if ( parallel%slave .and. parallel%fwmParallel ) then
            call ExpandStringRange( parallel%chunkRange, iChunks )
            call ConstructMIFGeolocation ( mifGeolocation, filedatabase, &
              & chunks(iChunks(1)) ) 
            call L2FWMSlaveTask ( mifGeolocation )
          end if
          ! Sort out the timings
          select case ( section_index )
          case ( z_algebra )
            call add_to_section_timing ( 'algebra', t1, now_stop )
          case ( z_construct )
            call add_to_section_timing ( 'construct', t1, now_stop )
          case ( z_fill )
            call add_to_section_timing ( 'fill', t1, now_stop )
          case ( z_join )
            call add_to_section_timing ( 'join', t1, now_stop )
          case ( z_retrieve )
            call add_to_section_timing ( 'retrieve', t1, now_stop )
          case default
            ! This is one of the skipped sections
          end select
          ! print the timing for FullForwardModel, the following return
          ! if fmt1 or fmt2 is true
          if ( switchDetail(switches, 'fmt') > -1 .and. &
            & associated(forwardModelConfigDatabase)) then
                  call printForwardModelTiming ( forwardModelConfigDatabase )
          end if
          canWriteL2PC = .true.
        else
        ! Otherwise, this is the 'standard' work for these sections.
          call allocate_test( chunksSkipped, size(chunks), 'chunksSkipped', ModuleName )
          chunksSkipped = .false.
          if ( parallel%chunkRange /= '' ) then
            chunksSkipped = .true.
            call ExpandStringRange(trim(parallel%chunkRange), chunksSkipped, &
              & sense=.false.)
          end if  
          canWriteL2PC = ( count(.not. chunksSkipped) < 2 )
          if ( .not. associated(chunks) ) then
            allocate(chunks(1), stat=error_flag)
            if ( error_flag /= 0 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
              & 'unable to allocate chunks' )
            firstChunk = 1
            lastChunk = size(chunks)
          end if
          if ( FindFirst( .not. chunksSkipped(firstChunk:lastChunk) ) < 1 .and. &
            & COMPLAINIFSKIPPEDEVERYCHUNK ) &
              & call MLSL2Message ( MLSMSG_Error, ModuleName, &
              & 'We have skipped every chunk' )
          if ( verboser ) call Dump( save1, 'save1' )
          do chunkNo = firstChunk, lastChunk ! --------------------- Chunk loop
            state = save1 ! Back up so first repeated section is next
            call resumeOutput ! In case the last phase was  silent
            call restartTimings( 'flags' ) ! reset only the flags
            if ( chunksSkipped(chunkNo) ) cycle
            call time_now ( tChunk )
            if ( BeVerbose( (/ 'chu', 'pro' /), 0) .or. verbose ) then
              call output ( " ================ Starting processing for chunk " )
              call output ( chunkNo )
              call output ( " ================ ", advance='yes' )
            end if
            if ( parallel%master .and. parallel%fwmParallel ) then
              call LaunchFWMSlaves ( chunks ( chunkNo ) )
            elseif( .not. parallel%slave ) then
              L2Options%CurrentChunkNumber = chunkNo  ! Stored for dumping
            endif
            if ( verbose .and. MustCheckForCorruptFileDatabase ) then
              call output( 'Now in loop of chunks', advance='yes' )
              call CheckForCorruptFileDatabase( filedatabase )
            endif
            exitToNextChunk = .false.
            call FinalMemoryReport
subtrees:   do
              ! in the outer loop
              save2 = state ! before advancing to section below
              son = next_tree_node(root,state)
              if ( verboser ) call Dump ( state, 'inner state' )
              if ( exitToNextChunk ) &
                & call output ( &
                & 'Commanded to Skip remaining sections of this chunk', &
                & advance='yes' )
              if ( son == 0 .or. exitToNextChunk ) exit subtrees
              L2CFNODE = son
              section_index = decoration(subtree(1,son))
              call get_string ( section_indices(section_index), section_name, &
                & strip=.true. )
              ! Are we to skip this section? Reasons could be
              ! (1) It's in the list of sections to Skip
              ! (2) The phase is one we've been asked to skip
              if( skipSections(section_index) ) &
                & section_index = SECTION_FIRST - 1 ! skip
              if ( isInList( PhasesToSkip, trim(L2Options%CurrentPhaseName), '-fc' ) ) &
                & section_index = SECTION_FIRST - 2 ! skip
              if ( verboser ) call MLSL2Message ( MLSMSG_Info, ModuleName, &
                & 'Innermost loop ' // trim(section_name) )
              ! Start inner loop for one chunk at the current position
              select case ( section_index ) ! section index
              case ( z_algebra )
                call algebra ( son, vectors, matrices, chunks(chunkNo), forwardModelConfigDatabase )
              case ( z_construct )
                if ( .not. checkPaths ) &
                & call MLSL2Construct ( son, filedatabase, processingRange, &
                  & chunks(chunkNo), qtyTemplates, vectorTemplates, vectors, &
                  & fGrids, hGrids, l2gpDatabase, forwardModelConfigDatabase, &
                  & griddedDataBase, mifGeolocation )
                call add_to_section_timing ( 'construct', t1, now_stop )
                if ( associated(hGrids) ) then
                  if ( HGrids(1)%the_hGrid%noProfs < 1 ) then
                    call headLine ( 'No profiles, so skipping this chunk' )
                    exit subtrees
                  endif
                endif
              case ( z_fill )
                if ( .not. checkPaths ) then 
                  call MLSL2Fill ( son, filedatabase, griddedDataBase, &
                  & vectorTemplates, vectors, qtyTemplates, matrices, hessians, &
                  & l2gpDatabase, l2auxDatabase, forwardModelConfigDatabase, &
                  & chunks, chunkNo, hgrids )
                end if
                call add_to_section_timing ( 'fill', t1, now_stop )
              case ( z_join )
                call MLSL2Join ( son, vectors, l2gpDatabase, &
                  & l2auxDatabase, DirectDatabase, chunkNo, chunks, &
                  & forwardModelConfigDatabase, fileDatabase, HGrids, &
                  & matrices, Hessians )
                call add_to_section_timing ( 'join', t1, now_stop )
              case ( z_retrieve )
                if ( .not. checkPaths) &
                & call retrieve ( son, vectors, matrices, hessians, &
                  & forwardModelConfigDatabase, &
                  & chunks(chunkNo), fileDataBase )
                call add_to_section_timing ( 'retrieve', t1, now_stop )
              case ( z_output )
                exit subtrees
              case default
                ! exit subtrees
                ! This may simply be a skipped section
                if ( verbose ) then
                  if ( section_index == SECTION_FIRST - 1 ) then
                    call output ( 'Skipping this section', advance='yes' )
                  else
                    call output ( 'Skipping ' // trim(L2Options%CurrentPhaseName), advance='yes' )
                  endif
                endif
              end select
            end do subtrees

            if ( switchDetail(switches,'chi') > 0 .and. chunkNo > 1 ) then
              ! Dumps nothing after 1st chunk
            else if ( switchDetail(switches,'chi') > -1 ) then
              if ( specialDumpFile /= ' ' ) &
                & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
              call output('Here are our diagnostics for chunk ', advance='no')
              call output(chunkNo, advance='yes')
              call dump_vectors( vectors, details=1, &
              & quantityTypes = (/l_chisqchan, l_chisqmmaf, l_chisqmmif/) )
              if ( specialDumpFile /= ' ' ) &
                & call revertOutput
            end if

            ! Now, if we're dealing with more than one chunk destroy stuff
            ! Otherwise, we'll save them as we may need to output them as l2pc files.
            if ( .not. canWriteL2PC ) then
              if ( warnOnDestroy ) call output('About to MLSL2Deconstruct', advance='yes' )
              call MLSL2DeConstruct ( vectorTemplates, hGrids )
              if ( warnOnDestroy ) call output('About to destroy hessian db', advance='yes' )
              call DestroyHessianDatabase ( hessians )
              if ( warnOnDestroy ) call output('About to destroy matrix db', advance='yes' )
              call DestroyMatrixDatabase ( matrices )
              if ( warnOnDestroy ) call output('About to destroy vector db', advance='yes' )
              call DestroyVectorDatabase ( vectors )
            end if
            if ( warnOnDestroy ) call output('About to forget optimum Lon0', advance='yes' )
            call ForgetOptimumLon0
            ! print the timing for FullForwardModel
            ! fmt2: at each chunk, fmt1: at last chunk
            if ( switchDetail(switches, 'fmt') > 1 ) then
                  call printForwardModelTiming ( forwardModelConfigDatabase )
            end if
            if ( switchDetail(switches, 'fmt') == 1 .and. &
              & chunkNo == lastChunk ) then
                  call printForwardModelTiming ( forwardModelConfigDatabase )
            end if
            if ( warnOnDestroy ) call output('About to strip fwmconfig db', advance='yes' )
            call StripForwardModelConfigDatabase ( forwardModelConfigDatabase )
            if ( switchDetail(switches,'chu') > -1 ) then
              call sayTime( 'processing this chunk', t1=tChunk )
            end if
            if ( now_stop ) then
              call finishUp(.true.)
              return
            end if
            call DestroyMIFGeolocation( mifGeolocation ) 
          end do ! ---------------------------------- End of chunk loop
          doneWithChunks = .true.
          state = save2
          ! Continue the outer loop after the last section processed in
          ! the chunk loop
          ! Clear any locked l2pc bins out.
          if ( warnOnDestroy ) call output('About to flushl2pc bins', advance='yes' )
          call FlushLockedBins
          ! Done with the chunksSkipped array
          call deallocate_test( chunksSkipped, 'chunksSkipped', ModuleName )
        end if

        ! If we're stamping stdout with phase, times, etc.
        ! we'll want to show the last phase is over
        call getStamp( textcode=textcode, showTime=showTime )
        if ( showTime .or. textCode /= ' ' ) then
          call setStamp( textCode="Output" )
        end if
        ! And resume directwrites
        skipDirectwrites = skipDirectwritesOriginal

        ! ------------------------------------------- Output section
      case ( z_output ) ! Write out the data
        call resumeOutput ! In case the last phase was  silent
        if ( parallel%slave .and. .not. slavesCleanUpSelves ) then
          exit
        else if ( .not. parallel%slave ) then
          call Output_Close ( son, l2gpDatabase, l2auxDatabase, DirectDatabase, &
            & matrices, hessians, vectors, fileDataBase, griddedDataBase, &
            & chunks, processingRange, &
            & canWriteL2PC )
        end if

        call add_to_section_timing ( 'output', t1)

      case default
        ! This is one of the skipped sections
        if ( .not. parallel%master ) then
          call output('Skipping ', advance='no')
          call output(trim(section_name), advance='yes')
        end if
      end select
    end do

    ! Now finish up
    call finishUp

  contains

    ! Housekeeping
    ! Fortran compilers are good at garbage collection
    ! Nonetheless, we make a stab at it ourselves, hoping to
    ! avoid memory leaks
    subroutine FinishUp ( Early )
      ! Deallocate and utterly destroy all the arrays we allocated
      ! Some are known to us, ebing arrays of user-defined datatypes
      ! These we try to deallocate first
      use FilterShapes_M, only: Destroy_Filter_Shapes_Database, &
        & Destroy_Dacs_Filter_Database
      logical, intent(in), optional :: Early ! If so, can't deallocate everything
      ! Local variables
      logical :: myEarly
      integer :: numChunks
      ! Executable
      myEarly = .false.
      if ( present(early) ) myEarly = early
      numChunks = 0
      if ( associated(Chunks) ) numChunks = size(Chunks)
      ! This used to be done at the end of the Output section
      ! For case where there was one chunk, destroy vectors etc.
      ! This is to guard against destroying stuff needed by l2pc writing
      if ( canWriteL2PC ) then
        if ( warnOnDestroy ) call output('About to MLSL2Deconstruct', advance='yes' )
        call MLSL2DeConstruct ( vectorTemplates, hGrids )
        if ( warnOnDestroy ) call output('About to destroy hessian db', advance='yes' )
        call DestroyHessianDatabase ( hessians )
        if ( warnOnDestroy ) call output('About to destroy matrix db', advance='yes' )
        call DestroyMatrixDatabase ( matrices )
        if ( warnOnDestroy ) call output('About to destroy vector db', advance='yes' )
        call DestroyVectorDatabase ( vectors )
        if ( warnOnDestroy ) call output('Unable to destroy qty template db', advance='yes' )
        ! call destroyQuantityTemplateDatabase ( QtyTemplates )
      end if

      if ( specialDumpFile /= ' ' ) &
        & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
      ! Now tidy up any remaining `pointer' data.
      ! processingRange needs no deallocation
      details = SwitchDetail(switches, 'gridd')
      if ( details > -1 .and. .not. parallel%slave &
       & .and. associated(griddedDataBase) ) then
        call Dump( griddedDataBase, details )
      end if
      if ( warnOnDestroy ) call output('About to destroy gridded db', advance='yes' )
      call DestroyGriddedDataDatabase ( griddedDataBase )
      details = SwitchDetail(switches, 'l2gp')
      if ( details > -1 .and. .not. parallel%slave) then
        call Dump( l2gpDatabase, details=details )
      else if ( switchDetail(switches,'cab') > -1 .and. .not. parallel%slave) then
        call Dump( l2gpDatabase, ColumnsOnly=.true. )
      end if
      if ( warnOnDestroy ) call output('About to destroy l2gp db', advance='yes' )
      call DestroyL2GPDatabase ( l2gpDatabase )
      details = SwitchDetail(switches, 'l2aux')
      if ( details > -1 .and. .not. parallel%slave) then
        call Dump( l2auxDatabase, details=details )
      end if
      if ( warnOnDestroy ) call output('About to destroy l2aux db', advance='yes' )
      call DestroyL2AUXDatabase ( l2auxDatabase )
      if ( warnOnDestroy ) call output('About to destroy direct db', advance='yes' )
      call DestroyDirectDatabase ( DirectDatabase )
      ! vectors, vectorTemplates and qtyTemplates destroyed at the
      ! end of each chunk
      ! fileDataBase is deallocated in MLSL2
      details = SwitchDetail(switches, 'pro') - 2 ! 'pro' prints only size(DB)
      if ( details > -3 &
        & .and. associated(fileDataBase) ) then
        call Dump( fileDataBase, details=details, table=.true. )
      end if
      if ( specialDumpFile /= ' ' ) &
        & call revertOutput

      call SummarizeWarnings
      call CloseParallel(numChunks, early)
      ! Let's try to deallocate all the module-scope pointers
      ! trusting each module to know what they are
      if ( parallel%slave .and. .not. slavesCleanUpSelves ) return
      if ( .not. (myEarly .or. L2Options%SkipRetrieval .or. checkPaths) ) then
        call trace_begin ( 'Destroying databases', cond=toggle(gen) )
        if ( parallel%slave ) then
          ! Some things a slave can safely destroy
          call destroyChunkDatabase ( chunks )
          ! call destroy_Ant_Patterns_database
          call destroy_DACS_Filter_Database
          ! call destroy_Filter_Shapes_Database
          call destroyBinSelectorDatabase
          ! call destroyL2PCDatabase
          call destroyFWMConfigDatabase ( forwardModelConfigDatabase )
          call destroy_line_database
          ! call destroy_pointing_grid_database
          call destroy_spectcat_database
          call destroyBandDatabase ( Bands )
          call destroyModuleDatabase ( Modules )
          call destroyRadiometerDatabase ( Radiometers )
          call destroySpectrometerTypeDatabase ( SpectrometerTypes )
          call destroySignalDatabase ( Signals )
          call destroyVGridDatabase ( vGrids )
          call destroyFGridDatabase ( fGrids )
        else
          ! Others only a master can safely destroy
          call destroyChunkDatabase ( chunks )
          call DestroyHGridGeoLocations
          call destroy_Ant_Patterns_database
          call destroy_DACS_Filter_Database
          call destroy_Filter_Shapes_Database
          call destroyBinSelectorDatabase
          call destroyL2PCDatabase
          if ( switchDetail ( switches, 'l2pc' ) > -1 ) &
            & call output('Destroyed l2pc db', advance='yes')
          call destroyFWMConfigDatabase ( forwardModelConfigDatabase )
          call destroy_line_database
          call destroy_pointing_grid_database
          call destroy_spectcat_database
          call destroyBandDatabase ( Bands )
          call destroyModuleDatabase ( Modules )
          call destroyRadiometerDatabase ( Radiometers )
          call destroySpectrometerTypeDatabase ( SpectrometerTypes )
          call destroySignalDatabase ( Signals )
          call destroyVGridDatabase ( vGrids )
          call destroyFGridDatabase ( fGrids )
        end if
        call trace_end ( 'Destroying databases', cond=toggle(gen) )
      end if
      error_flag = 0
      call trace_end ( 'WALK_TREE_TO_DO_MLS_L2', cond=toggle(gen) )
    end subroutine FinishUp

  end subroutine WALK_TREE_TO_DO_MLS_L2

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: tree_walker.f90,v 2.213 2019/09/19 16:13:01 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module TREE_WALKER

! $Log: tree_walker.f90,v $
! Revision 2.213  2019/09/19 16:13:01  pwagner
! Fixed bug in timings when processing multiple chunks serially
!
! Revision 2.212  2018/09/13 20:23:23  pwagner
! Moved changeable options to new L2Options; added DumpOptions
!
! Revision 2.211  2018/07/27 23:19:53  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.210  2018/04/19 23:44:36  pwagner
! Skip may take /nextChunk flag
!
! Revision 2.209  2018/04/19 00:49:44  vsnyder
! Remove USE statements and declarations for unused names
!
! Revision 2.208  2018/03/14 22:08:36  pwagner
! May print section in innemost loop if verbose enough
!
! Revision 2.207  2017/01/25 17:24:22  pwagner
! May skip certain Phases named in phasesToSkip cmdline opt
!
! Revision 2.206  2016/11/08 17:31:26  pwagner
! Use SayTime subroutine from time_m module
!
! Revision 2.205  2016/09/21 00:40:17  pwagner
! Usually dump FileDB as a table
!
! Revision 2.204  2016/08/09 22:08:33  pwagner
! May check for corrupt file database
!
! Revision 2.203  2016/05/18 01:37:30  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.202  2016/05/06 17:50:17  pwagner
! Still unable to reliably destroyQuantityTemplateDatabase
!
! Revision 2.201  2016/05/04 18:22:59  pwagner
! Restored ability of serial runs to process multiple chunks; updated api for MLSL2DeConstruct; deallocated qty templates before end
!
! Revision 2.200  2015/10/13 23:51:53  pwagner
! Will skip a chunk w/o profiles instead of crashing
!
! Revision 2.199  2015/09/03 20:29:47  pwagner
! We were calling L2MasterTask more than once; fixed
!
! Revision 2.198  2015/08/03 21:46:59  pwagner
! May debug Next_tree_node_m calls
!
! Revision 2.197  2015/06/19 20:40:04  pwagner
! Explicitly destroy HGrid gelocations if a master
!
! Revision 2.196  2014/10/07 00:22:32  pwagner
! -gn doesnt automatically dump chunks
!
! Revision 2.195  2014/09/05 01:28:14  vsnyder
! Add some tracing, remove unreferenced USSE name
!
! Revision 2.194  2014/06/30 23:30:45  pwagner
! Renamed global setting to slavesCleanUpSelves
!
! Revision 2.193  2014/04/10 00:43:11  pwagner
! Moved currentChunkNumber, currentPhaseName from MLSL2Timings to MLSL2Options
!
! Revision 2.192  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.191  2014/01/08 21:04:16  vsnyder
! Add more info to entry trace
!
! Revision 2.190  2013/12/13 21:25:30  vsnyder
! Use the iterator correctly so the correct number of chunks are run, and
! the output section is run
!
! Revision 2.189  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.188  2013/10/09 00:24:30  pwagner
! May have multiple Output sections
!
! Revision 2.187  2013/10/01 22:18:56  pwagner
! Passes hgrids to MLSL2Fill
!
! Revision 2.186  2013/08/30 02:45:52  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.185  2013/08/23 23:32:55  pwagner
! May use l2cf to set l1b file type to non-Aura
!
! Revision 2.184  2013/08/17 02:54:32  vsnyder
! Remove references to DEPTH from trace_m
!
! Revision 2.183  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.182  2013/04/05 23:25:41  pwagner
! Made 'master' a 'section' for timings summary
!
! Revision 2.181  2013/02/14 19:04:29  pwagner
! Consistent with changed L2MasterTask api
!
! Revision 2.180  2012/08/16 17:56:54  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.179  2012/04/26 23:15:28  pwagner
! Now tracks currentPhaseName and currentChunkNumber
!
! Revision 2.178  2011/10/07 00:06:02  pwagner
! May dump Matrices, Hessians from Fill, Join
!
! Revision 2.177  2011/06/29 21:51:17  pwagner
! Some cases may safely omit l1b files
!
! Revision 2.176  2011/06/16 23:18:01  pwagner
! Pass details from switches when dumping dbs
!
! Revision 2.175  2011/05/09 18:27:56  pwagner
! Converted to using switchDetail
!
! Revision 2.174  2011/04/20 16:53:43  pwagner
! Added new flexibility to l2cf control flow by run-time booleans affecting gridded data
!
! Revision 2.173  2011/04/08 00:10:00  pwagner
! Raise error if every chunk was skipped
!
! Revision 2.172  2010/04/13 01:43:09  vsnyder
! Move FlushLockedBins from LinearizedForwardModel_m to L2PCBins_m
!
! Revision 2.171  2010/03/17 20:57:35  pwagner
! Print about destroyed l2pc db only if -S'l2pc'
!
! Revision 2.170  2010/02/25 18:20:44  pwagner
! Adds support for new Hessian database
!
! Revision 2.169  2010/02/04 19:10:58  pwagner
! Allocate directwrite db with zero size
!
! Revision 2.168  2009/10/01 19:58:00  vsnyder
! Pass file database to set_global_settings
!
! Revision 2.167  2009/06/23 18:46:19  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.166  2008/12/18 21:12:41  pwagner
! May now dump an l2pc or allL2PCs (use with caution)
!
! Revision 2.165  2008/09/19 23:56:28  pwagner
! May now Destroy GriddedData
!
! Revision 2.164  2008/05/20 00:29:19  vsnyder
! Don't leave J undefined if no chunks processed
!
! Revision 2.163  2008/04/01 17:00:15  pwagner
! Can get hdf5 spectroscopy file path/name from PCF
!
! Revision 2.162  2007/12/07 01:15:01  pwagner
! Removed unused dummp varaibles, etc.
!
! Revision 2.161  2007/10/09 00:34:21  pwagner
! ifort was crashing in destroy_DACS_Filter_Database during checkPaths; we now skip
!
! Revision 2.160  2007/09/13 21:51:39  pwagner
! Resumed destroying dbs (unless slave)
!
! Revision 2.159  2007/09/06 23:35:16  pwagner
! slaves need not do own cleanup
!
! Revision 2.158  2007/08/31 00:03:26  pwagner
! Summarizes warnings at end
!
! Revision 2.157  2007/06/21 00:54:08  vsnyder
! Remove tabs, which are not part of the Fortran standard
!
! Revision 2.156  2007/06/07 20:41:07  pwagner
! Avoid read_ and Merge_apriori if master task
!
! Revision 2.155  2007/04/03 17:36:44  vsnyder
! Allocate Vectors with zero size so others don't need to check whether
! it's associated; indeed, they don't need the pointer attribute.
!
! Revision 2.154  2007/03/23 00:29:41  pwagner
! Switch destroy warns when destroying dbs
!
! Revision 2.153  2007/02/14 17:31:00  pwagner
! Commented-out destroyL2PCDatabase (was it killing slaves?)
!
! Revision 2.152  2007/01/12 00:34:04  pwagner
! Renamed routine outputNamedValue
!
! Revision 2.151  2006/10/09 18:39:35  pwagner
! Fixed bug preventing a call to Output_CLose
!
! Revision 2.150  2006/10/05 23:32:43  pwagner
! skipSections can skip named sections
!
! Revision 2.149  2006/08/14 16:22:28  pwagner
! Should not double-deallocate if canWriteL2PC
!
! Revision 2.148  2006/08/10 21:46:50  pwagner
! --chunk commandline option now synonym for --chunkRange
!
! Revision 2.147  2006/08/05 02:10:46  vsnyder
! Delete some debugging print I shouldn't have left at the last check-in
!
! Revision 2.146  2006/08/05 00:41:50  vsnyder
! Comment out filter database destruction -- causes memory trouble
!
! Revision 2.145  2006/08/02 19:53:26  vsnyder
! Send Vectors database to outputClose for destroy command
!
! Revision 2.144  2006/07/24 20:35:04  pwagner
! Fixed bug when stopAfterSection is blank
!
! Revision 2.143  2006/07/21 20:12:26  pwagner
! Can select what section to stop after
!
! Revision 2.142  2006/06/12 16:28:25  pwagner
! Added ability to dump Gridded Data
!
! Revision 2.141  2006/05/05 16:49:23  pwagner
! May convertEtaToP and create a VGrid in MergeGrids section
!
! Revision 2.140  2006/04/11 23:30:00  pwagner
! chunkRange option effective in serial runs, too
!
! Revision 2.139  2006/03/04 00:22:04  pwagner
! Restore original skipDirectWrites after chunkLoop ends
!
! Revision 2.138  2006/02/16 00:16:32  pwagner
! switchDetail instead of index
!
! Revision 2.137  2006/02/10 21:15:26  pwagner
! dumps may go to special dumpfile
!
! Revision 2.136  2006/01/11 17:02:16  pwagner
! Repaired erroneous report when single chunk > size(chunks)
!
! Revision 2.135  2006/01/06 01:15:01  pwagner
! Resumes output at start of each chunk, and OutputClose
!
! Revision 2.134  2005/08/19 23:35:01  pwagner
! Allow Output to repair l2gp with HGrid while copying files
!
! Revision 2.133  2005/07/12 17:37:20  pwagner
! Removed unused DestroyL1BInfo
!
! Revision 2.132  2005/06/14 20:44:36  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.131  2005/06/03 02:05:29  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! get VGrids from VGridsDatabase instead of passing as an argument.
!
! Revision 2.130  2005/05/31 17:51:17  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.129  2004/12/14 21:56:50  pwagner
! Changes related to stopping early
!
! Revision 2.128  2004/07/22 20:49:58  cvuu
! Add forwardModelConfigDatabase to the call MLSL2Join and MLSL2Fill
!
! Revision 2.127  2004/05/19 19:16:12  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.126  2004/04/28 23:07:44  livesey
! Now passes more stuff to Algebra
!
! Revision 2.125  2004/02/10 19:29:36  pwagner
! Prints time for processing each chunk at chunks end
!
! Revision 2.124  2004/01/17 00:28:09  vsnyder
! Provide for Algebra section
!
! Revision 2.123  2004/01/14 18:49:58  vsnyder
! Stuff to support the Algebra section
!
! Revision 2.122  2003/12/16 01:28:56  livesey
! Moved the destruction of the chunk database to after closeParallel.
!
! Revision 2.121  2003/12/11 22:59:32  pwagner
! May fill DirectWriteDatabase in global settings
!
! Revision 2.120  2003/12/05 00:42:05  pwagner
! Removed last vestige of explicit garbage collection
!
! Revision 2.119  2003/11/07 00:46:51  pwagner
! New quicker preflight option: --checkPaths
!
! Revision 2.118  2003/11/05 21:27:54  pwagner
! Can enter range of chunks to be processed instead of single
!
! Revision 2.117  2003/10/09 23:31:26  pwagner
! Changed grid switch to gridd
!
! Revision 2.116  2003/09/03 15:56:18  cvuu
! Move the do loop over the forwardModel inside subroutine PrintForwardModelTiming
!
! Revision 2.115  2003/09/02 18:04:38  pwagner
! Can do a singleChunk even if master task
!
! Revision 2.114  2003/08/21 21:24:39  cvuu
! Change the output format for fullForwardModel Timing
!
! Revision 2.113  2003/08/21 16:07:34  livesey
! Now calls FlushLockedBins automatically at the end of each chunk.
!
! Revision 2.112  2003/08/11 23:24:02  pwagner
! Stores ChunkNo as component of L2ParallelInfo_T
!
! Revision 2.111  2003/07/07 23:51:06  pwagner
! Need not pass around l2pc as L2pcf now a saved variable in WriteMetaData
!
! Revision 2.110  2003/06/30 22:56:16  cvuu
! Print mean, std dev for fullForwardModel timing
!
! Revision 2.109  2003/06/24 23:54:07  pwagner
! New db indexes stored for entire direct file
!
! Revision 2.108  2003/06/24 23:00:53  livesey
! Nullified directDatabase
!
! Revision 2.107  2003/06/23 23:55:17  pwagner
! Added DirectData_T to keep track of data written directly
!
! Revision 2.106  2003/06/20 19:38:26  pwagner
! Allows direct writing of output products
!
! Revision 2.105  2003/06/09 22:51:35  pwagner
! Renamed scan_divide to chunk_divide in timings table
!
! Revision 2.104  2003/03/08 00:46:08  pwagner
! Per njl, checks for illegal single chunk runs
!
! Revision 2.103  2003/02/21 21:03:39  pwagner
! Disabled tps switch to eliminate need for Test_Parse_Signals
!
! Revision 2.102  2003/01/13 20:59:14  livesey
! Removed a print statement
!
! Revision 2.101  2002/12/05 19:45:20  pwagner
! Moved MLSFile_T from MLSFiles to MLSCommon
!
! Revision 2.100  2002/12/04 01:18:21  pwagner
! First halting steps toward using filedatabase
!
! Revision 2.99  2002/11/22 12:24:25  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.98  2002/11/22 01:14:06  vsnyder
! Remove USE'd but unreferenced symbols and two unused local variables
!
! Revision 2.97  2002/11/21 18:45:04  livesey
! Changes to way the destroy stuff is called based on chunks
!
! Revision 2.96  2002/11/21 18:38:34  livesey
! Bug fix in canWriteL2PC flag passed to output_close
!
! Revision 2.95  2002/10/08 17:41:50  livesey
! Various bug fixes associated with FWMParallel
!
! Revision 2.94  2002/10/08 17:36:23  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.93  2002/10/05 00:44:29  livesey
! Included the FWMParallel stuff
!
! Revision 2.92  2002/09/25 20:09:32  livesey
! Changes to allow chunk based forwardModel configs
!
! Revision 2.91  2002/09/24 22:17:50  pwagner
! Defines t1 before call to add_to_section_timing
!
! Revision 2.90  2002/09/24 18:18:47  pwagner
! Consistent with add_to_section_timing now calling time_now at its end
!
! Revision 2.89  2002/08/28 22:29:19  pwagner
! Moved DestroyL1BInfo to after end of loop of chunks
!
! Revision 2.88  2002/08/22 01:26:00  vsnyder
! Cosmetic changes
!
! Revision 2.87  2002/08/21 19:05:04  livesey
! Removed calls to H5Open/close as they are now done in MLSL2.
!
! Revision 2.86  2002/08/21 00:55:35  livesey
! Changed error to warning when fail to close hdf5 (at least for the
! moment).
!
! Revision 2.85  2002/08/20 22:10:50  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.84  2002/08/07 00:05:27  livesey
! Added calls to H5Open_F and H5Close_F
!
! Revision 2.83  2002/08/04 16:10:43  mjf
! Added some nullify statements for Sun's rubbish compiler.
!
! Revision 2.82  2002/03/20 00:49:44  pwagner
! chi1 dumps only 1st chunk, unlike chi
!
! Revision 2.81  2002/02/05 00:44:03  pwagner
! Added garbage collection stuff
!
! Revision 2.80  2002/01/24 00:58:28  livesey
! Now calls MergeGrids at the appropriate time
!
! Revision 2.79  2002/01/22 18:14:47  livesey
! Fixed typo
!
! Revision 2.78  2002/01/21 23:11:06  livesey
! Added call to DestroyBinSelectorsDatabase etc.
!
! Revision 2.77  2002/01/18 18:55:37  livesey
! Code to support the --chunk option
!
! Revision 2.76  2002/01/09 22:56:17  livesey
! Now sends slaves all chunks as regular HGrids need them.
!
! Revision 2.75  2001/12/16 00:57:12  livesey
! Now passes all chunks to construct
!
! Revision 2.74  2001/12/14 01:43:20  livesey
! Passes processingRange to HGrid via Construct
!
! Revision 2.73  2001/12/13 23:21:26  livesey
! Added countChunks option
!
! Revision 2.72  2001/12/10 20:22:09  livesey
! Added code for EmpiricalGeometry.
!
! Revision 2.71  2001/11/20 00:48:15  livesey
! Fixed problem when no chunks to process
!
! Revision 2.70  2001/11/16 17:24:13  livesey
! Now calls new ChunkDivide routine.
!
! Revision 2.69  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.68  2001/10/31 19:07:52  livesey
! Hooked fGrids into quantity templates
!
! Revision 2.67  2001/10/31 18:36:58  livesey
! Added fGrids stuff
!
! Revision 2.66  2001/10/26 23:16:15  pwagner
! Similar dump interfaces for l2gp, l2aux, Griddeddata databases
!
! Revision 2.65  2001/10/12 23:14:22  pwagner
! Debugging when dumping diagnostics; may remove later
!
! Revision 2.64  2001/10/09 23:43:42  pwagner
! Some further improvements in dumping vectors
!
! Revision 2.63  2001/10/02 16:49:56  livesey
! Removed fmStat%finished and change loop ordering in forward models
!
! Revision 2.62  2001/09/29 00:01:00  pwagner
! Fixed various timing problems
!
! Revision 2.61  2001/09/28 17:50:30  pwagner
! MLSL2Timings module keeps timing info
!
! Revision 2.60  2001/09/21 17:40:57  pwagner
! May dump diagnostic quantities chi..
!
! Revision 2.59  2001/09/10 23:37:32  livesey
! New GriddedData etc.
!
! Revision 2.58  2001/08/06 18:34:59  pwagner
! Now dumps l2gp and l2aux databases when asked
!
! Revision 2.57  2001/07/11 21:40:21  livesey
! Added -Schu option
!
! Revision 2.56  2001/06/13 20:44:08  livesey
! Moved the CloseParallel higher up, to work around the memory management
! problem (somethine [HDF?] seems to stamp on PointingFrequencyDatabase)
!
! Revision 2.55  2001/06/07 21:58:28  pwagner
! Added Copyright statement
!
! Revision 2.54  2001/05/23 22:00:16  livesey
! Interim version
!
! Revision 2.53  2001/05/23 01:44:35  livesey
! Parallel stuff taking shape
!
! Revision 2.52  2001/05/10 00:43:23  livesey
! Tree walker now owns hGrids
!
! Revision 2.51  2001/05/04 17:12:25  pwagner
! Passes necessary args to global_settings
!
! Revision 2.50  2001/05/03 20:34:08  vsnyder
! Cosmetic changes
!
! Revision 2.49  2001/05/02 23:23:00  livesey
! Added some of the parallel stuff
!
! Revision 2.48  2001/04/28 01:31:46  livesey
! Changes for new l2pc / matrix handling.
!
! Revision 2.47  2001/04/26 20:02:09  livesey
! Made l2pc database a saved array in L2PC_m
!
! Revision 2.46  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.45  2001/04/26 00:08:02  livesey
! Stuff to support reading of l2pc files
!
! Revision 2.44  2001/04/25 21:54:16  livesey
! Added canDoL2PC flag to join
!
! Revision 2.43  2001/04/25 21:52:13  livesey
! Moved DeConstruct to after output for 1 chunk cases.
! This is to protect vectors and matrices stored in l2pcs.
!
! Revision 2.42  2001/04/25 20:34:36  livesey
! Now supports writing of l2pc files
!
! Revision 2.41  2001/04/25 19:31:13  livesey
! Fixed bug, now nullifies l2pcDatabase
!
! Revision 2.40  2001/04/24 23:05:54  vsnyder
! Make 'test_parse_signals' depend on 'switches' containing 'tps'
!
! Revision 2.39  2001/04/24 20:20:02  livesey
! L2PC moved to lib, and renamed
!
! Revision 2.38  2001/04/24 20:05:50  livesey
! New stuff to support joining of l2pc's
!
! Revision 2.37  2001/04/21 01:41:35  vsnyder
! Fix memory leaks
!
! Revision 2.36  2001/04/21 01:26:37  livesey
! Now passes l2gpDatabase to more people
!
! Revision 2.35  2001/04/20 17:12:38  livesey
! Add vGrids argument to fill to support fill from vGrid
!
! Revision 2.34  2001/04/19 23:51:40  pwagner
! Moved anText to become component of PCFData_T
!
! Revision 2.33  2001/04/11 17:47:47  pwagner
! presets anText to null
!
! Revision 2.32  2001/04/10 22:27:47  vsnyder
! Nullify explicitly instead of with <initialization> so as not to give
! pointers the SAVE attribute.  <initialization> is NOT executed on each
! entry to a procedure.
!
! Revision 2.31  2001/04/10 02:46:17  livesey
! Working version, no more FMI/TFMI
!
! Revision 2.30  2001/04/10 00:02:19  vsnyder
! Implement 'matrix' spec in Fill section
!
! Revision 2.29  2001/04/07 01:50:49  vsnyder
! Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
! some related stuff to fwdmdl/ForwardModelConfig.
!
! Revision 2.28  2001/04/06 20:12:59  vsnyder
! Make 'call test_parse_signal' depend on 'emit' toggle
!
! Revision 2.27  2001/04/04 02:15:12  vsnyder
! Add Spectroscopy section
!
! Revision 2.26  2001/04/03 20:50:45  pwagner
! Added anText to hold PCF file contents
!
! Revision 2.25  2001/04/02 23:41:09  pwagner
! Now keeps l2pcf and transmits as needed
!
! Revision 2.24  2001/03/29 19:13:03  livesey
! Renamed apriorDatabase to griddedData
!
! Revision 2.23  2001/03/28 23:47:48  livesey
! Added arguments to sids etc.
!
! Revision 2.22  2001/03/28 01:24:55  vsnyder
! Move vGrid from construct section to global settings section
!
! Revision 2.21  2001/03/17 03:30:25  vsnyder
! Remove FMI and TFMI from the call to set_global_settings, since it no
! longer uses them.
!
! Revision 2.20  2001/03/17 00:45:53  livesey
! Added forwardModelConfigDatabase
!
! Revision 2.19  2001/03/15 23:26:09  livesey
! Added chunks to call to MLSL2Join
!
! Revision 2.18  2001/03/15 21:20:54  pwagner
! Split between GriddedData and ncep_dao modules
!
! Revision 2.17  2001/03/15 21:05:23  vsnyder
! Set up to test Parse_Signal
!
! Revision 2.16  2001/03/14 02:04:53  vsnyder
! Moved MLSSignals_m to mlspgs/lib
!
! Revision 2.15  2001/03/09 19:57:48  vsnyder
! Add 'z_retrieve' to a case branch
!
! Revision 2.14  2001/03/08 18:21:11  vsnyder
! Even more stuff for L2_Load
!
! Revision 2.13  2001/03/08 03:23:10  vsnyder
! More stuff to work with L2_Load
!
! Revision 2.12  2001/03/07 22:46:05  vsnyder
! Add temporary stuff for Zvi's "l2_load", which will wither away.
!
! Revision 2.11  2001/03/03 00:13:30  pwagner
! Gets read_apriori from ReadAPriori module
!
! Revision 2.10  2001/02/28 01:17:57  livesey
! Removed obtain_ncep etc. These will later be in lower down modules
!
! Revision 2.9  2001/02/27 17:38:07  livesey
! Tidied up arguments to MLSL2Join
!
! Revision 2.8  2001/02/23 02:51:44  vsnyder
! Improve progress messages triggered by -g option
!
! Revision 2.7  2001/02/08 01:40:53  vsnyder
! Don't know what I have done, but "cvs update" said M instead of U
!
! Revision 2.6  2001/01/03 17:48:43  pwagner
! added chunk args to call to Fill
!
! Revision 2.5  2000/12/05 00:41:50  pwagner
! Added L2AUXDatabase arg in call to MLSL2Fill
!
! Revision 2.4  2000/11/30 00:21:08  pwagner
! passes l2*databses to read a priori
!
! Revision 2.3  2000/11/29 00:27:54  pwagner
! Began changes to open old l2gp
!
! Revision 2.2  2000/10/10 00:37:46  vsnyder
! Added $Log for CVS at end.
!
@


2.213
log
@Fixed bug in timings when processing multiple chunks serially
@
text
@d37 1
a37 1
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d445 1
d749 1
a749 1
       "$Id: tree_walker.f90,v 2.212 2018/09/13 20:23:23 pwagner Exp $"
d759 3
@


2.212
log
@Moved changeable options to new L2Options; added DumpOptions
@
text
@d94 1
a94 1
    use MLSL2Timings, only: Add_To_Section_Timing
d427 1
d748 1
a748 1
       "$Id: tree_walker.f90,v 2.211 2018/07/27 23:19:53 pwagner Exp $"
d758 3
@


2.211
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d78 1
a78 1
      & CheckPaths, CurrentChunkNumber, CurrentPhaseName, ExitToNextChunk, &
d81 1
a81 1
      & SkipRetrieval, SlavesCleanUpSelves, SpecialDumpFile, StopAfterSection, &
d302 1
a302 1
          currentChunkNumber = chunkNo
d437 1
a437 1
              currentChunkNumber = chunkNo  ! Stored for dumping
d463 1
a463 1
              if ( isInList( PhasesToSkip, trim(currentPhaseName), '-fc' ) ) &
d513 1
a513 1
                    call output ( 'Skipping ' // trim(currentPhaseName), advance='yes' )
d692 1
a692 1
      if ( .not. (myEarly .or. skipRetrieval .or. checkPaths) ) then
d747 1
a747 1
       "$Id: tree_walker.f90,v 2.210 2018/04/19 23:44:36 pwagner Exp $"
d757 3
@


2.210
log
@Skip may take /nextChunk flag
@
text
@d79 1
a79 1
      & L2CFNode, MLSMessage, Need_L1BFiles, PhasesToSkip, &
d183 1
a183 1
    if ( error_flag /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d186 1
a186 1
    if ( error_flag /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d249 1
a249 1
          call MLSMessage ( MLSMSG_Info, ModuleName, &
d324 1
a324 1
            if ( error_flag /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d359 1
a359 1
          if ( error_flag /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d414 1
a414 1
            if ( error_flag /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d421 1
a421 1
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
d465 1
a465 1
              if ( verboser ) call MLSMessage ( MLSMSG_Info, ModuleName, &
d747 1
a747 1
       "$Id: tree_walker.f90,v 2.209 2018/04/19 00:49:44 vsnyder Exp $"
d757 3
@


2.209
log
@Remove USE statements and declarations for unused names
@
text
@d78 1
a78 1
      & CheckPaths, CurrentChunkNumber, CurrentPhaseName, &
d429 1
a429 1
            if ( switchDetail(switches,'chu') > -1 .or. verbose ) then
d443 1
d449 5
a453 1
              if ( son == 0 ) exit subtrees
d747 1
a747 1
       "$Id: tree_walker.f90,v 2.208 2018/03/14 22:08:36 pwagner Exp $"
d757 3
@


2.208
log
@May print section in innemost loop if verbose enough
@
text
@d99 1
a99 2
    use Output_M, only: Output, &
      & ResumeOutput, RevertOutput, SwitchOutput
d101 2
a102 1
    use QuantityTemplates, only: QuantityTemplate_T
d156 1
a156 1
    real    ::                                   t1, t2, tChunk
d742 1
a742 1
       "$Id: tree_walker.f90,v 2.207 2017/01/25 17:24:22 pwagner Exp $"
d752 3
@


2.207
log
@May skip certain Phases named in phasesToSkip cmdline opt
@
text
@d94 1
a94 1
    use MLSL2Timings, only: Add_To_Section_Timing, Total_Times
d99 1
a99 1
    use Output_M, only: Blanks, Output, &
d102 1
a102 2
    use QuantityTemplates, only: QuantityTemplate_T, &
      & DestroyQuantityTemplateDatabase
a443 1
              ! Start inner loop for one chunk at the current position
d460 3
d742 1
a742 1
       "$Id: tree_walker.f90,v 2.206 2016/11/08 17:31:26 pwagner Exp $"
d752 3
@


2.206
log
@Use SayTime subroutine from time_m module
@
text
@d22 1
a22 1
  logical, parameter :: COMPLAINIFSKIPPEDEVERYCHUNK = .true.
d34 1
a34 1
    & COUNTCHUNKS, FILEDATABASE, SECTIONSTOSKIP )
d36 5
a40 5
    use Algebra_m, only: algebra
    use Allocate_deallocate, only: allocate_test, deallocate_test
    use AntennaPatterns_m, only: destroy_ant_patterns_database
    use ChunkDivide_m, only: chunkDivide, destroyChunkDatabase
    use Chunks_m, only: dump, MLSChunk_t
d43 4
a46 4
    use DirectWrite_m, only: directdata_t, destroydirectdatabase
    use Dump_0, only: dump
    use EmpiricalGeometry, only: forgetOptimumLon0
    use FGrid, only: fgrid_t, destroyFGridDatabase, dump
d48 1
a48 1
    use ForwardModelConfig, only: forwardModelConfig_t, &
d51 15
a65 15
    use ForwardModelSupport, only: printForwardModelTiming
    use Global_settings, only: set_global_settings
    use GriddedData, only: griddedData_t, destroyGriddedDataDatabase, dump
    use HessianModule_1, only: destroyHessianDatabase, hessian_t
    use HGridsDatabase, only: HGrids_t
    use HGrid, only: computeAllHGridOffsets, DestroyHGridGeoLocations
    use HighOutput, only: beVerbose, getStamp, headLine, outputNamedValue, &
      & setStamp
    use Init_tables_module, only: l_chisqchan, l_chisqmmaf, l_chisqmmif,  &
      & Section_first, section_last, &
      & Z_algebra, z_chunkdivide,  z_construct, z_fill, z_globalsettings, &
      & Z_join, z_mergegrids, z_MLSsignals, z_output, z_readapriori,      &
      & Z_retrieve, z_spectroscopy
    use Intrinsic, only: section_indices
    use Join, only: MLSl2join
d67 16
a82 15
    use L2AUXData, only: destroyL2AUXDatabase, L2AUXData_t, dump
    use L2FWMParallel, only: L2FWMSlaveTask, launchFWMSlaves
    use L2GPData, only: destroyL2GPDatabase, L2GPData_t, dump
    use L2Parallel, only: getChunkInfoFromMaster, L2MasterTask
    use L2Parinfo, only: parallel, closeparallel
    use L2PC_m, only: destroyL2PCDatabase, destroyBinSelectorDatabase
    use L2PCBins_m, only: flushlockedbins
    use MatrixModule_1, only: destroyMatrixDatabase, matrix_database_t
    use MergeGridsModule, only: mergeGrids
    use MLSCommon, only: tai93_range_t, MLSFile_t
    use MLSL2Options, only: aura_L1BFiles, checkPaths, currentChunkNumber, &
      & L2CFNode, need_L1BFiles, &
      & SkipDirectWrites, skipDirectWritesOriginal, &
      & SkipRetrieval, slavesCleanUpSelves, specialDumpFile, stopAfterSection, &
      & MLSMessage, toolkit
d84 32
a115 32
      & MLSMSG_Error, summarizeWarnings
    use MLSPCF2, only: MLSPCF_Spectroscopy_end
    use MLSFinds, only: findFirst
    use MLSSignals_m, only: bands, destroyBandDatabase, destroyModuleDatabase, &
      & DestroyRadiometerDatabase, destroySignalDatabase, &
      & DestroySpectrometerTypeDatabase, isSpacecraftAura, &
      & MLSSignals, modules, radiometers, &
      & Signals, spectrometerTypes
    use MLSStringLists, only: expandStringRange, isInList, switchDetail
    use MLSStrings, only: lowercase
    use MLSL2Timings, only: add_to_section_timing, total_times
    use Next_tree_node_m, only: dump, &
      & Next_tree_node, next_tree_node_state
    use Open_init, only: openAndInitialize
    use OutputAndClose, only: output_close
    use Output_m, only: blanks, output, &
      & ResumeOutput, revertOutput, switchOutput
    use PointingGrid_m, only: destroy_pointing_grid_database
    use QuantityTemplates, only: quantityTemplate_t, &
      & destroyQuantityTemplateDatabase
    use ReadApriori, only: read_apriori
    use RetrievalModule, only: retrieve
    use SpectroscopyCatalog_m, only: destroy_line_database, &
      & Destroy_spectcat_database, spectroscopy
    use String_table, only: get_string
    use Time_m, only: SayTime, time_now
    use Toggles, only: gen, switches, toggle
    use Trace_m, only: trace_begin, trace_end
    use Tree, only: decoration, subtree
    use VectorsModule, only: destroyVectorDatabase, dump_vectors, &
      & Vector_t, vectorTemplate_t
    use VGridsDatabase, only: destroyVGridDatabase, VGrids
a122 1
    character(len=*), intent(in) :: SECTIONSTOSKIP
d161 1
d170 2
a171 1
    verbose = BeVerbose ( 'walk', -1 )
d233 1
a233 1
        if ( verbose ) call Dump ( state, 'at globalsttings' )
d246 1
a246 1
        if ( verbose ) call Dump ( state, 'at mlsSignals' )
d264 1
a264 1
        if ( verbose ) call Dump ( state, 'at spectroscopy' )
d273 1
a273 1
        if ( verbose ) call Dump ( state, 'at readapriori' )
d297 1
a297 1
        if ( verbose ) call Dump ( state, 'at chunkdivide' )
d355 1
a355 1
        if ( verbose ) call Dump ( state, 'at other' )
d424 1
a424 1
          if ( verbose ) call Dump( save1, 'save1' )
d449 1
a449 1
              if ( verbose ) call Dump ( state, 'inner state' )
d455 3
d460 2
d494 2
a495 1
                & call retrieve ( son, vectors, matrices, hessians, forwardModelConfigDatabase, &
d503 7
d616 2
a617 2
      use FilterShapes_m, only: Destroy_filter_shapes_database, &
        & Destroy_dacs_filter_database
d741 1
a741 1
       "$Id: tree_walker.f90,v 2.205 2016/09/21 00:40:17 pwagner Exp $"
d751 3
@


2.205
log
@Usually dump FileDB as a table
@
text
@d108 1
a108 1
    use Time_m, only: time_now
d537 1
a537 1
              call sayTime('processing this chunk', tChunk)
a720 19
    subroutine SayTime ( What, startTime )
      character(len=*), intent(in) :: What
      real, intent(in), optional :: startTime
      real :: myt1
      if ( present(startTime) ) then
        myt1 = startTime
      else
        myt1 = t1
      end if
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for " // what // " = " )
      call output ( dble(t2 - myt1), advance = 'yes' )
    end subroutine SayTime

d726 1
a726 1
       "$Id: tree_walker.f90,v 2.204 2016/08/09 22:08:33 pwagner Exp $"
d736 3
@


2.204
log
@May check for corrupt file database
@
text
@d45 1
a45 1
    use Empiricalgeometry, only: forgetOptimumLon0
d601 2
a602 2
      use filtershapes_m, only: destroy_filter_shapes_database, &
        & destroy_dacs_filter_database
d661 1
a661 1
        call Dump( fileDataBase, details=details )
d745 1
a745 1
       "$Id: tree_walker.f90,v 2.203 2016/05/18 01:37:30 vsnyder Exp $"
d755 3
@


2.203
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@d23 1
d66 1
d239 4
d305 4
d310 4
d316 5
a320 1
            & l2gpDatabase, processingRange )
d344 2
d438 4
d745 1
a745 1
       "$Id: tree_walker.f90,v 2.202 2016/05/06 17:50:17 pwagner Exp $"
d755 4
@


2.202
log
@Still unable to reliably destroyQuantityTemplateDatabase
@
text
@d54 1
a54 1
    use HGridsDatabase, only: HGrid_t
d137 1
a137 1
    type (HGrid_T), dimension(:), pointer ::     HGrids
d442 1
a442 1
                  if ( HGrids(1)%noProfs < 1 ) then
d721 1
a721 1
       "$Id: tree_walker.f90,v 2.201 2016/05/04 18:22:59 pwagner Exp $"
d731 3
@


2.201
log
@Restored ability of serial runs to process multiple chunks; updated api for MLSL2DeConstruct; deallocated qty templates before end
@
text
@d600 2
a601 2
        if ( warnOnDestroy ) call output('About to destroy qty template db', advance='yes' )
        call destroyQuantityTemplateDatabase ( QtyTemplates )
d721 1
a721 1
       "$Id: tree_walker.f90,v 2.200 2015/10/13 23:51:53 pwagner Exp $"
d731 3
@


2.200
log
@Will skip a chunk w/o profiles instead of crashing
@
text
@d37 5
a41 5
    use Antennapatterns_m, only: destroy_ant_patterns_database
    use Chunkdivide_m, only: chunkdivide, destroychunkdatabase
    use Chunks_m, only: dump, MLSchunk_t
    use Construct, only: MLSl2construct, MLSl2deconstruct, &
      & Constructmifgeolocation
d44 4
a47 4
    use Empiricalgeometry, only: forgetoptimumlon0
    use Fgrid, only: fgrid_t, destroyfgriddatabase, dump
    use Fill, only: MLSl2fill
    use Forwardmodelconfig, only: forwardmodelconfig_t, &
d50 1
a50 1
    use Forwardmodelsupport, only: printForwardModelTiming
d52 4
a55 4
    use Griddeddata, only: griddeddata_t, destroygriddeddatadatabase, dump
    use Hessianmodule_1, only: destroyhessiandatabase, hessian_t
    use Hgridsdatabase, only: hgrid_t
    use Hgrid, only: computeAllHGridOffsets, DestroyHGridGeoLocations
d65 1
a65 1
    use L2AUXData, only: destroyl2auxdatabase, l2auxdata_t, dump
d72 7
a78 7
    use MatrixModule_1, only: destroymatrixdatabase, matrix_database_t
    use Mergegridsmodule, only: mergegrids
    use MLSCommon, only: tai93_range_t, MLSfile_t
    use MLSL2Options, only: aura_l1bfiles, checkpaths, currentchunknumber, &
      & L2cfnode, need_l1bfiles, &
      & Skipdirectwrites, skipdirectwritesoriginal, &
      & Skipretrieval, slavescleanupselves, specialdumpfile, stopaftersection, &
d81 6
a86 6
      & MLSMsg_error, summarizewarnings
    use MLSPCF2, only: MLSpcf_spectroscopy_end
    use MLSFinds, only: findfirst
    use MLSSignals_m, only: bands, destroybanddatabase, destroymoduledatabase, &
      & Destroyradiometerdatabase, destroysignaldatabase, &
      & Destroyspectrometertypedatabase, isspacecraftaura, &
d88 2
a89 2
      & Signals, spectrometertypes
    use MLSStringlists, only: expandstringrange, isinlist, switchdetail
d94 2
a95 2
    use Open_init, only: openandinitialize
    use Outputandclose, only: output_close
d97 1
a97 1
      & Resumeoutput, revertoutput, switchoutput
d99 2
a100 1
    use QuantityTemplates, only: quantitytemplate_t
d109 1
a109 1
    use Tree, only: decoration, nsons, subtree
d112 1
a112 1
    use VgridsDatabase, only: destroyVGridDatabase, vgrids
d117 1
a117 1
    logical, intent(in) ::     COUNTCHUNKS ! Just count the chunks, print them out and quit
d491 1
a491 2
              call MLSL2DeConstruct ( qtyTemplates, vectorTemplates, &
                & mifGeolocation, hGrids )
d519 1
d593 1
a593 2
        call MLSL2DeConstruct ( qtyTemplates, vectorTemplates, &
          & mifGeolocation, hGrids )
d600 2
d721 1
a721 1
       "$Id: tree_walker.f90,v 2.199 2015/09/03 20:29:47 pwagner Exp $"
d731 3
@


2.199
log
@We were calling L2MasterTask more than once; fixed
@
text
@d48 3
a50 3
      & Destroyfwmconfigdatabase, &
      & Stripforwardmodelconfigdatabase
    use Forwardmodelsupport, only: printforwardmodeltiming
d55 3
a57 2
    use Hgrid, only: computeallhgridoffsets, DestroyHGridGeoLocations
    use HighOutput, only: beVerbose, outputNamedValue, getstamp, setstamp
d65 8
a72 8
    use L2auxdata, only: destroyl2auxdatabase, l2auxdata_t, dump
    use L2fwmparallel, only: l2fwmslavetask, launchfwmslaves
    use L2gpdata, only: destroyl2gpdatabase, l2gpdata_t, dump
    use L2parallel, only: getchunkinfofrommaster, l2mastertask
    use L2parinfo, only: parallel, closeparallel
    use L2pc_m, only: destroyl2pcdatabase, destroybinselectordatabase
    use L2pcbins_m, only: flushlockedbins
    use Matrixmodule_1, only: destroymatrixdatabase, matrix_database_t
d92 1
a92 1
    use Next_tree_node_m, only: dump, isStateNull, &
d106 1
a106 1
    use Toggles, only: gen, levels, switches, toggle
a136 1
    integer ::                                   HOWMANY ! Nsons(Root)
a146 1
    logical ::                                   REDUCEDCHUNKS
a191 1
    reducedChunks      = .false.
a202 1
    howmany = nsons(root)
d440 6
d719 1
a719 1
       "$Id: tree_walker.f90,v 2.198 2015/08/03 21:46:59 pwagner Exp $"
d729 3
@


2.198
log
@May debug Next_tree_node_m calls
@
text
@d125 1
d211 1
d334 1
d349 1
d351 1
d517 1
d716 1
a716 1
       "$Id: tree_walker.f90,v 2.197 2015/06/19 20:40:04 pwagner Exp $"
d726 3
@


2.197
log
@Explicitly destroy HGrid gelocations if a master
@
text
@d35 76
a110 75
    use algebra_m, only: algebra
    use allocate_deallocate, only: allocate_test, deallocate_test
    use antennapatterns_m, only: destroy_ant_patterns_database
    use chunkdivide_m, only: chunkdivide, destroychunkdatabase
    use chunks_m, only: dump, MLSchunk_t
    use construct, only: MLSl2construct, MLSl2deconstruct, &
      & constructmifgeolocation
    use directwrite_m, only: directdata_t, destroydirectdatabase
    use dump_0, only: dump
    use empiricalgeometry, only: forgetoptimumlon0
    use fgrid, only: fgrid_t, destroyfgriddatabase, dump
    use fill, only: MLSl2fill
    use forwardmodelconfig, only: forwardmodelconfig_t, &
      & destroyfwmconfigdatabase, &
      & stripforwardmodelconfigdatabase
    use forwardmodelsupport, only: printforwardmodeltiming
    use global_settings, only: set_global_settings
    use griddeddata, only: griddeddata_t, destroygriddeddatadatabase, dump
    use hessianmodule_1, only: destroyhessiandatabase, hessian_t
    use hgridsdatabase, only: hgrid_t
    use hgrid, only: computeallhgridoffsets, DestroyHGridGeoLocations
    use highoutput, only: getstamp, setstamp
    use init_tables_module, only: l_chisqchan, l_chisqmmaf, l_chisqmmif,  &
      & section_first, section_last, &
      & z_algebra, z_chunkdivide,  z_construct, z_fill, z_globalsettings, &
      & z_join, z_mergegrids, z_MLSsignals, z_output, z_readapriori,      &
      & z_retrieve, z_spectroscopy
    use intrinsic, only: section_indices
    use join, only: MLSl2join
    use l2auxdata, only: destroyl2auxdatabase, l2auxdata_t, dump
    use l2fwmparallel, only: l2fwmslavetask, launchfwmslaves
    use l2gpdata, only: destroyl2gpdatabase, l2gpdata_t, dump
    use l2parallel, only: getchunkinfofrommaster, l2mastertask
    use l2parinfo, only: parallel, closeparallel
    use l2pc_m, only: destroyl2pcdatabase, destroybinselectordatabase
    use l2pcbins_m, only: flushlockedbins
    use matrixmodule_1, only: destroymatrixdatabase, matrix_database_t
    use mergegridsmodule, only: mergegrids
    use MLScommon, only: tai93_range_t, MLSfile_t
    use MLSl2options, only: aura_l1bfiles, checkpaths, currentchunknumber, &
      & l2cfnode, need_l1bfiles, &
      & skipdirectwrites, skipdirectwritesoriginal, &
      & skipretrieval, slavescleanupselves, specialdumpfile, stopaftersection, &
      & MLSmessage, toolkit
    use MLSmessagemodule, only: MLSmsg_allocate, MLSmsg_info, &
      & MLSmsg_error, summarizewarnings
    use MLSpcf2, only: MLSpcf_spectroscopy_end
    use MLSfinds, only: findfirst
    use MLSsignals_m, only: bands, destroybanddatabase, destroymoduledatabase, &
      & destroyradiometerdatabase, destroysignaldatabase, &
      & destroyspectrometertypedatabase, isspacecraftaura, &
      & MLSsignals, modules, radiometers, &
      & signals, spectrometertypes
    use MLSstringlists, only: expandstringrange, isinlist, switchdetail
    use MLSstrings, only: lowercase
    use MLSl2timings, only: add_to_section_timing, total_times
    use next_tree_node_m, only: next_tree_node, next_tree_node_state
    use open_init, only: openandinitialize
    use outputandclose, only: output_close
    use output_m, only: blanks, output, &
      & resumeoutput, revertoutput, switchoutput
    use pointinggrid_m, only: destroy_pointing_grid_database
    use quantitytemplates, only: quantitytemplate_t
    use readapriori, only: read_apriori
    use retrievalmodule, only: retrieve
    use spectroscopycatalog_m, only: destroy_line_database, &
      & destroy_spectcat_database, spectroscopy
    use string_table, only: get_string
    use time_m, only: time_now
    use toggles, only: gen, levels, switches, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: decoration, nsons, subtree
    use vectorsmodule, only: destroyvectordatabase, dump_vectors, &
      & vector_t, vectortemplate_t
    use vgridsdatabase, only: destroyvgriddatabase, vgrids
d157 1
d166 1
d209 1
d229 1
d238 1
d256 1
d265 1
d289 1
d332 1
d399 1
d405 1
a405 1
            if ( switchDetail(switches,'chu') > -1 ) then
d420 1
d710 1
a710 1
       "$Id: tree_walker.f90,v 2.196 2014/10/07 00:22:32 pwagner Exp $"
d720 3
@


2.196
log
@-gn doesnt automatically dump chunks
@
text
@d55 1
a55 1
    use hgrid, only: computeallhgridoffsets
d547 4
d553 2
d557 1
a557 1
      logical, intent(in), optional :: Early
d621 2
d627 1
d646 1
d648 1
d698 1
a698 1
       "$Id: tree_walker.f90,v 2.195 2014/09/05 01:28:14 vsnyder Exp $"
d708 3
@


2.195
log
@Add some tracing, remove unreferenced USSE name
@
text
@a311 1
        if ( toggle(gen) .and. levels(gen) > 0 ) call dump ( chunks )
d687 1
a687 1
       "$Id: tree_walker.f90,v 2.194 2014/06/30 23:30:45 pwagner Exp $"
d697 3
@


2.194
log
@Renamed global setting to slavesCleanUpSelves
@
text
@d56 1
a56 1
    use highoutput, only: getstamp, outputnamedvalue, setstamp
d618 1
d658 1
d688 1
a688 1
       "$Id: tree_walker.f90,v 2.193 2014/04/10 00:43:11 pwagner Exp $"
d698 3
@


2.193
log
@Moved currentChunkNumber, currentPhaseName from MLSL2Timings to MLSL2Options
@
text
@d35 75
a109 75
    use ALGEBRA_M, only: ALGEBRA
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use ANTENNAPATTERNS_M, only: DESTROY_ANT_PATTERNS_DATABASE
    use CHUNKDIVIDE_M, only: CHUNKDIVIDE, DESTROYCHUNKDATABASE
    use CHUNKS_M, only: DUMP, MLSCHUNK_T
    use CONSTRUCT, only: MLSL2CONSTRUCT, MLSL2DECONSTRUCT, &
      & CONSTRUCTMIFGEOLOCATION
    use DIRECTWRITE_M, only: DIRECTDATA_T, DESTROYDIRECTDATABASE
    use DUMP_0, only: DUMP
    use EMPIRICALGEOMETRY, only: FORGETOPTIMUMLON0
    use FGRID, only: FGRID_T, DESTROYFGRIDDATABASE, DUMP
    use FILL, only: MLSL2FILL
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T, &
      & DESTROYFWMCONFIGDATABASE, &
      & STRIPFORWARDMODELCONFIGDATABASE
    use FORWARDMODELSUPPORT, only: PRINTFORWARDMODELTIMING
    use GLOBAL_SETTINGS, only: SET_GLOBAL_SETTINGS
    use GRIDDEDDATA, only: GRIDDEDDATA_T, DESTROYGRIDDEDDATADATABASE, DUMP
    use HESSIANMODULE_1, only: DESTROYHESSIANDATABASE, HESSIAN_T
    use HGRIDSDATABASE, only: HGRID_T
    use HGRID, only: COMPUTEALLHGRIDOFFSETS
    use HIGHOUTPUT, only: GETSTAMP, SETSTAMP
    use INIT_TABLES_MODULE, only: L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF,  &
      & SECTION_FIRST, SECTION_LAST, &
      & Z_ALGEBRA, Z_CHUNKDIVIDE,  Z_CONSTRUCT, Z_FILL, Z_GLOBALSETTINGS, &
      & Z_JOIN, Z_MERGEGRIDS, Z_MLSSIGNALS, Z_OUTPUT, Z_READAPRIORI,      &
      & Z_RETRIEVE, Z_SPECTROSCOPY
    use INTRINSIC, only: SECTION_INDICES
    use JOIN, only: MLSL2JOIN
    use L2AUXDATA, only: DESTROYL2AUXDATABASE, L2AUXDATA_T, DUMP
    use L2FWMPARALLEL, only: L2FWMSLAVETASK, LAUNCHFWMSLAVES
    use L2GPDATA, only: DESTROYL2GPDATABASE, L2GPDATA_T, DUMP
    use L2PARALLEL, only: GETCHUNKINFOFROMMASTER, L2MASTERTASK
    use L2PARINFO, only: PARALLEL, CLOSEPARALLEL
    use L2PC_M, only: DESTROYL2PCDATABASE, DESTROYBINSELECTORDATABASE
    use L2PCBINS_M, only: FLUSHLOCKEDBINS
    use MATRIXMODULE_1, only: DESTROYMATRIXDATABASE, MATRIX_DATABASE_T
    use MERGEGRIDSMODULE, only: MERGEGRIDS
    use MLSCOMMON, only: TAI93_RANGE_T, MLSFILE_T
    use MLSL2OPTIONS, only: AURA_L1BFILES, CHECKPATHS, currentChunkNumber, &
      & L2CFNODE, NEED_L1BFILES, &
      & SKIPDIRECTWRITES, SKIPDIRECTWRITESORIGINAL, &
      & SKIPRETRIEVAL, SLAVESDOOWNCLEANUP, SPECIALDUMPFILE, STOPAFTERSECTION, &
      & MLSMESSAGE, TOOLKIT
    use MLSMESSAGEMODULE, only: MLSMSG_ALLOCATE, MLSMSG_INFO, &
      & MLSMSG_ERROR, SUMMARIZEWARNINGS
    use MLSPCF2, only: MLSPCF_SPECTROSCOPY_END
    use MLSFINDS, only: FINDFIRST
    use MLSSIGNALS_M, only: BANDS, DESTROYBANDDATABASE, DESTROYMODULEDATABASE, &
      & DESTROYRADIOMETERDATABASE, DESTROYSIGNALDATABASE, &
      & DESTROYSPECTROMETERTYPEDATABASE, ISSPACECRAFTAURA, &
      & MLSSIGNALS, MODULES, RADIOMETERS, &
      & SIGNALS, SPECTROMETERTYPES
    use MLSSTRINGLISTS, only: EXPANDSTRINGRANGE, ISINLIST, SWITCHDETAIL
    use MLSSTRINGS, only: LOWERCASE
    use MLSL2TIMINGS, only: ADD_TO_SECTION_TIMING, TOTAL_TIMES
    use Next_Tree_Node_m, only: Next_Tree_Node, Next_Tree_Node_State
    use OPEN_INIT, only: OPENANDINITIALIZE
    use OUTPUTANDCLOSE, only: OUTPUT_CLOSE
    use OUTPUT_M, only: BLANKS, OUTPUT, &
      & RESUMEOUTPUT, REVERTOUTPUT, SWITCHOUTPUT
    use POINTINGGRID_M, only: DESTROY_POINTING_GRID_DATABASE
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T
    use READAPRIORI, only: READ_APRIORI
    use RETRIEVALMODULE, only: RETRIEVE
    use SPECTROSCOPYCATALOG_M, only: DESTROY_LINE_DATABASE, &
      & DESTROY_SPECTCAT_DATABASE, SPECTROSCOPY
    use STRING_TABLE, only: GET_STRING
    use TIME_M, only: TIME_NOW
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NSONS, SUBTREE
    use VECTORSMODULE, only: DESTROYVECTORDATABASE, DUMP_VECTORS, &
      & VECTOR_T, VECTORTEMPLATE_T
    use VGRIDSDATABASE, only: DESTROYVGRIDDATABASE, VGRIDS
d523 1
a523 1
        if ( parallel%slave .and. .not. SLAVESDOOWNCLEANUP ) then
d550 2
a551 2
      use FILTERSHAPES_M, only: DESTROY_FILTER_SHAPES_DATABASE, &
        & DESTROY_DACS_FILTER_DATABASE
d616 1
a616 1
      if ( parallel%slave .and. .not. SLAVESDOOWNCLEANUP ) return
d686 1
a686 1
       "$Id: tree_walker.f90,v 2.192 2014/01/09 00:30:24 pwagner Exp $"
d696 3
@


2.192
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d74 3
a76 1
    use MLSL2OPTIONS, only: AURA_L1BFILES, CHECKPATHS, NEED_L1BFILES, &
d78 1
a78 1
      & MLSMESSAGE
d90 1
a90 4
    use MLSL2OPTIONS, only: L2CFNODE, &
      & SKIPDIRECTWRITES, SKIPDIRECTWRITESORIGINAL, TOOLKIT
    use MLSL2TIMINGS, only: ADD_TO_SECTION_TIMING, TOTAL_TIMES, &
      & CURRENTCHUNKNUMBER
d686 1
a686 1
       "$Id: tree_walker.f90,v 2.191 2014/01/08 21:04:16 vsnyder Exp $"
d696 3
@


2.191
log
@Add more info to entry trace
@
text
@d56 1
d95 2
a96 2
    use OUTPUT_M, only: BLANKS, GETSTAMP, OUTPUT, &
      & RESUMEOUTPUT, REVERTOUTPUT, SETSTAMP, SWITCHOUTPUT
d687 1
a687 1
       "$Id: tree_walker.f90,v 2.190 2013/12/13 21:25:30 vsnyder Exp $"
d697 3
@


2.190
log
@Use the iterator correctly so the correct number of chunks are run, and
the output section is run
@
text
@d165 1
a165 1
      & subtree(first_section,root), cond=toggle(gen) )
d686 1
a686 1
       "$Id: tree_walker.f90,v 2.189 2013/12/12 02:11:26 vsnyder Exp $"
d696 4
@


2.189
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d91 1
a91 2
    use Next_Tree_Node_m, only: Init_Next_Tree_Node, Next_Tree_Node, &
      & Next_Tree_Node_State
a137 1
    integer ::                                   LastInner ! subtree number
d151 1
a151 1
    type(next_tree_node_state) ::                State, State2 ! of tree traverser
d208 1
a389 1
          lastInner = state%ancestors(1)%subtree ! In case no chunks get processed
d391 1
a404 1
            call init_next_tree_node ( state2 )
d408 2
a409 1
              son = next_tree_node(root,state2,start=state%ancestors(1)%subtree)
a410 1
              lastInner = state2%ancestors(1)%subtree
d501 1
a503 1
          state%ancestors(1)%subtree = lastInner
d686 1
a686 1
       "$Id: tree_walker.f90,v 2.188 2013/10/09 00:24:30 pwagner Exp $"
d696 3
@


2.188
log
@May have multiple Output sections
@
text
@d91 2
d116 1
d135 2
a136 2
    integer ::                                   HOWMANY  ! Nsons(Root)
    integer ::                                   I, J     ! Loop inductors
d139 1
d152 2
a153 1
    integer ::                                   SON              ! Son of Root
d193 1
a193 1
    do i=section_first, section_last
a202 1
    i = first_section
d209 3
a211 2
    do while ( i <= howmany )
      son = subtree(i,root)
d236 3
a238 3
            ! call test_parse_signals
            call MLSMessage ( MLSMSG_Info, ModuleName, &
              & 'Go back and uncomment the previous line in tree_walker' )
d292 2
a293 1
            call ComputeAllHGridOffsets ( root, i+1, chunks, filedatabase, &
a339 1
            i = i + 1
d387 5
a391 5
          j = FindFirst( .not. chunksSkipped(firstChunk:lastChunk) )
          if ( j < 1 .and. COMPLAINIFSKIPPEDEVERYCHUNK ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'We have skipped every chunk' )
          j = i + 1 ! In case no chunks get processed
d406 7
a412 3
            j = i
subtrees:   do while ( j <= howmany )
              son = subtree(j,root)
a453 1
              j = j + 1
d503 3
a510 1
          i = j - 1 ! one gets added back in at the end of the outer loop
a542 1
      i = i + 1
d688 1
a688 1
       "$Id: tree_walker.f90,v 2.187 2013/10/01 22:18:56 pwagner Exp $"
d698 3
@


2.187
log
@Passes hgrids to MLSL2Fill
@
text
@a523 51
        ! For case where there was one chunk, destroy vectors etc.
        ! This is to guard against destroying stuff needed by l2pc writing
        if ( canWriteL2PC ) then
          if ( warnOnDestroy ) call output('About to MLSL2Deconstruct', advance='yes' )
          call MLSL2DeConstruct ( qtyTemplates, vectorTemplates, &
            & mifGeolocation, hGrids )
          if ( warnOnDestroy ) call output('About to destroy hessian db', advance='yes' )
          call DestroyHessianDatabase ( hessians )
          if ( warnOnDestroy ) call output('About to destroy matrix db', advance='yes' )
          call DestroyMatrixDatabase ( matrices )
          if ( warnOnDestroy ) call output('About to destroy vector db', advance='yes' )
          call DestroyVectorDatabase ( vectors )
        end if

        if ( specialDumpFile /= ' ' ) &
          & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
        ! Now tidy up any remaining `pointer' data.
        ! processingRange needs no deallocation
        details = SwitchDetail(switches, 'gridd')
        if ( details > -1 .and. .not. parallel%slave &
         & .and. associated(griddedDataBase) ) then
          call Dump( griddedDataBase, details )
        end if
        if ( warnOnDestroy ) call output('About to destroy gridded db', advance='yes' )
        call DestroyGriddedDataDatabase ( griddedDataBase )
        details = SwitchDetail(switches, 'l2gp')
        if ( details > -1 .and. .not. parallel%slave) then
          call Dump( l2gpDatabase, details=details )
        else if ( switchDetail(switches,'cab') > -1 .and. .not. parallel%slave) then
          call Dump( l2gpDatabase, ColumnsOnly=.true. )
        end if
        if ( warnOnDestroy ) call output('About to destroy l2gp db', advance='yes' )
        call DestroyL2GPDatabase ( l2gpDatabase )
        details = SwitchDetail(switches, 'l2aux')
        if ( details > -1 .and. .not. parallel%slave) then
          call Dump( l2auxDatabase, details=details )
        end if
        if ( warnOnDestroy ) call output('About to destroy l2aux db', advance='yes' )
        call DestroyL2AUXDatabase ( l2auxDatabase )
        if ( warnOnDestroy ) call output('About to destroy direct db', advance='yes' )
        call DestroyDirectDatabase ( DirectDatabase )
        ! vectors, vectorTemplates and qtyTemplates destroyed at the
        ! end of each chunk
        ! fileDataBase is deallocated in MLSL2
        details = SwitchDetail(switches, 'pro') - 2 ! 'pro' prints only size(DB)
        if ( details > -3 &
          & .and. associated(fileDataBase) ) then
          call Dump( fileDataBase, details=details )
        end if
        if ( specialDumpFile /= ' ' ) &
          & call revertOutput
d542 1
d546 1
d549 1
d554 53
d679 1
a679 1
       "$Id: tree_walker.f90,v 2.186 2013/08/30 02:45:52 vsnyder Exp $"
d689 3
@


2.186
log
@Revise calls to trace_begin and trace_end
@
text
@d425 1
a425 1
                  & chunks, chunkNo )
d674 1
a674 1
       "$Id: tree_walker.f90,v 2.185 2013/08/23 23:32:55 pwagner Exp $"
d684 3
@


2.185
log
@May use l2cf to set l1b file type to non-Aura
@
text
@d140 1
d161 4
a191 3
    if ( toggle(gen) ) call trace_begin ( 'WALK_TREE_TO_DO_MLS_L2', &
      & subtree(first_section,root) )
    call time_now ( t1 )
d647 1
a647 1
      if ( toggle(gen) ) call trace_end ( 'WALK_TREE_TO_DO_MLS_L2' )
d674 1
a674 1
       "$Id: tree_walker.f90,v 2.184 2013/08/17 02:54:32 vsnyder Exp $"
d684 3
@


2.184
log
@Remove references to DEPTH from trace_m
@
text
@d73 1
a73 1
    use MLSL2OPTIONS, only: CHECKPATHS, NEED_L1BFILES, &
d82 2
a83 1
      & DESTROYSPECTROMETERTYPEDATABASE, MLSSIGNALS, MODULES, RADIOMETERS, &
d233 5
d672 1
a672 1
       "$Id: tree_walker.f90,v 2.183 2013/08/12 23:49:41 pwagner Exp $"
d682 3
@


2.183
log
@FindSomethings moved to MLSFinds module
@
text
@d103 1
a103 1
    use TRACE_M, only: DEPTH, TRACE_BEGIN, TRACE_END
a180 1
    depth = 0
d666 1
a666 1
       "$Id: tree_walker.f90,v 2.182 2013/04/05 23:25:41 pwagner Exp $"
d676 3
@


2.182
log
@Made 'master' a 'section' for timings summary
@
text
@d79 1
a79 1
    use MLSSETS, only: FINDFIRST
d667 1
a667 1
       "$Id: tree_walker.f90,v 2.181 2013/02/14 19:04:29 pwagner Exp $"
d677 3
@


2.181
log
@Consistent with changed L2MasterTask api
@
text
@d326 3
d599 39
a637 19
        call destroyChunkDatabase ( chunks )
        call destroy_Ant_Patterns_database
        call destroy_DACS_Filter_Database
        call destroy_Filter_Shapes_Database
        call destroyBinSelectorDatabase
        call destroyL2PCDatabase
        if ( switchDetail ( switches, 'l2pc' ) > -1 ) &
          & call output('Destroyed l2pc db', advance='yes')
        call destroyFWMConfigDatabase ( forwardModelConfigDatabase )
        call destroy_line_database
        call destroy_pointing_grid_database
        call destroy_spectcat_database
        call destroyBandDatabase ( Bands )
        call destroyModuleDatabase ( Modules )
        call destroyRadiometerDatabase ( Radiometers )
        call destroySpectrometerTypeDatabase ( SpectrometerTypes )
        call destroySignalDatabase ( Signals )
        call destroyVGridDatabase ( vGrids )
        call destroyFGridDatabase ( fGrids )
d667 1
a667 1
       "$Id: tree_walker.f90,v 2.180 2012/08/16 17:56:54 pwagner Exp $"
d677 3
@


2.180
log
@Exploit level 2-savvy MLSMessage
@
text
@d325 1
a325 1
            call L2MasterTask ( chunks, l2gpDatabase, l2auxDatabase )
d644 1
a644 1
       "$Id: tree_walker.f90,v 2.179 2012/04/26 23:15:28 pwagner Exp $"
d654 3
@


2.179
log
@Now tracks currentPhaseName and currentChunkNumber
@
text
@d74 3
a76 2
      & SKIPRETRIEVAL, SLAVESDOOWNCLEANUP, SPECIALDUMPFILE, STOPAFTERSECTION
    use MLSMESSAGEMODULE, only: MLSMSG_ALLOCATE, MLSMESSAGE, MLSMSG_INFO, &
d86 2
a87 1
    use MLSL2OPTIONS, only: SKIPDIRECTWRITES, SKIPDIRECTWRITESORIGINAL, TOOLKIT
d89 1
a89 1
      & CURRENTCHUNKNUMBER, CURRENTPHASENAME
d205 1
d394 1
d644 1
a644 1
       "$Id: tree_walker.f90,v 2.178 2011/10/07 00:06:02 pwagner Exp $"
d654 3
@


2.178
log
@May dump Matrices, Hessians from Fill, Join
@
text
@d86 2
a87 1
    use MLSL2TIMINGS, only: ADD_TO_SECTION_TIMING, TOTAL_TIMES
d272 1
d383 5
a387 2
            if ( parallel%master .and. parallel%fwmParallel ) &
              & call LaunchFWMSlaves ( chunks ( chunkNo ) )
d640 1
a640 1
       "$Id: tree_walker.f90,v 2.177 2011/06/29 21:51:17 pwagner Exp $"
d650 3
@


2.177
log
@Some cases may safely omit l1b files
@
text
@d412 2
a413 1
                  & forwardModelConfigDatabase, fileDatabase, HGrids )
d635 1
a635 1
       "$Id: tree_walker.f90,v 2.176 2011/06/16 23:18:01 pwagner Exp $"
d645 3
@


2.176
log
@Pass details from switches when dumping dbs
@
text
@d73 1
a73 1
    use MLSL2OPTIONS, only: CHECKPATHS, &
d272 2
a273 1
          if ( .not. checkPaths .or. parallel%chunkRange /= '' ) then
d281 5
d634 1
a634 1
       "$Id: tree_walker.f90,v 2.175 2011/05/09 18:27:56 pwagner Exp $"
d644 3
@


2.175
log
@Converted to using switchDetail
@
text
@d516 2
a517 1
        if ( switchDetail(switches,'gridd') > -1 .and. .not. parallel%slave &
d519 1
a519 1
          call Dump(griddedDataBase)
d523 3
a525 2
        if ( switchDetail(switches,'l2gp') > -1 .and. .not. parallel%slave) then
          call Dump(l2gpDatabase)
d527 1
a527 1
          call Dump(l2gpDatabase, ColumnsOnly=.true.)
d531 3
a533 2
        if ( switchDetail(switches,'l2aux') > -1 .and. .not. parallel%slave) then
          call Dump(l2auxDatabase)
d542 2
a543 1
        if ( switchDetail(switches,'pro') > -1 &
d545 1
a545 2
          details = SwitchDetail(switches, 'pro') - 2 ! 'pro' prints only size(DB)
          call Dump(fileDataBase, details=details)
d567 2
a568 2
      use FilterShapes_m, only: Destroy_Filter_Shapes_Database, &
        & destroy_DACS_Filter_Database
d628 1
a628 1
       "$Id: tree_walker.f90,v 2.174 2011/04/20 16:53:43 pwagner Exp $"
d638 3
@


2.174
log
@Added new flexibility to l2cf control flow by run-time booleans affecting gridded data
@
text
@d35 22
a56 22
    use Algebra_M, only: Algebra
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use AntennaPatterns_m, only: Destroy_Ant_Patterns_Database
    use ChunkDivide_m, only: ChunkDivide, DestroyChunkDatabase
    use Chunks_m, only: Dump, MLSChunk_T
    use Construct, only: MLSL2Construct, MLSL2DeConstruct, &
      & ConstructMIFGeolocation
    use DirectWrite_m, only: DirectData_T, DestroyDirectDatabase
    use dump_0, only: dump
    use EmpiricalGeometry, only: ForgetOptimumLon0
    use FGrid, only: FGrid_T, DestroyFGridDatabase, DUMP
    use Fill, only: MLSL2Fill
    use ForwardModelConfig, only: ForwardModelConfig_T, &
      & DestroyFWMConfigDatabase, &
      & StripForwardModelConfigDatabase
    use ForwardModelSupport, only: printForwardModelTiming
    use Global_Settings, only: Set_Global_Settings
    use GriddedData, only: GriddedData_T, DestroyGriddedDataDatabase, Dump
    use HessianModule_1, only: DestroyHessianDatabase, Hessian_T
    use HGridsDatabase, only: HGrid_T
    use HGrid, only: COMPUTEALLHGRIDOFFSETS
    use Init_Tables_Module, only: L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF,  &
d61 13
a73 13
    use intrinsic, only: section_indices
    use JOIN, only: MLSL2Join
    use L2AUXData, only: DestroyL2AUXDatabase, L2AUXData_T, Dump
    use L2FWMParallel, only: L2FWMSlaveTask, LaunchFWMSlaves
    use L2GPData, only: DestroyL2GPDatabase, L2GPData_T, Dump
    use L2Parallel, only: GETCHUNKINFOFROMMASTER, L2MASTERTASK
    use L2ParInfo, only: PARALLEL, CLOSEPARALLEL
    use L2PC_m, only: DestroyL2PCDatabase, DestroyBinSelectorDatabase
    use L2PCBins_m, only: FLUSHLOCKEDBINS
    use MatrixModule_1, only: DestroyMatrixDatabase, Matrix_Database_T
    use MergeGridsModule, only: MergeGrids
    use MLSCommon, only: TAI93_RANGE_T, MLSFile_T
    use MLSL2Options, only: CHECKPATHS, &
d75 22
a96 22
    use MLSMessageModule, only: MLSMSG_Allocate, MLSMessage, MLSMSG_Info, &
      & MLSMSG_Error, SummarizeWarnings
    use MLSPCF2, only: mlspcf_spectroscopy_end
    use MLSSets, only: FindFirst
    use MLSSignals_M, only: Bands, DestroyBandDatabase, DestroyModuleDatabase, &
      & DestroyRadiometerDatabase, DestroySignalDatabase, &
      & DestroySpectrometerTypeDatabase, MLSSignals, Modules, Radiometers, &
      & Signals, SpectrometerTypes
    use MLSStringLists, only: ExpandStringRange, isInList, SwitchDetail
    use MLSStrings, only: lowerCase
    use MLSL2Options, only: SKIPDIRECTWRITES, SKIPDIRECTWRITESORIGINAL, TOOLKIT
    use MLSL2Timings, only: add_to_section_timing, TOTAL_TIMES
    use Open_Init, only: OpenAndInitialize
    use OutputAndClose, only: Output_Close
    use Output_m, only: BLANKS, getStamp, Output, &
      & RESUMEOUTPUT, revertoutput, setStamp, switchOutput
    use PointingGrid_m, only: Destroy_Pointing_Grid_Database
    use QuantityTemplates, only: QuantityTemplate_T
    use ReadAPriori, only: read_apriori
    use RetrievalModule, only: Retrieve
    use SpectroscopyCatalog_m, only: Destroy_Line_Database, &
      & Destroy_SpectCat_Database, Spectroscopy
d98 7
a104 7
    use Time_M, only: Time_Now
    use Toggles, only: GEN, LEVELS, SWITCHES, TOGGLE
    use Trace_m, only: DEPTH, TRACE_BEGIN, TRACE_END
    use Tree, only: DECORATION, NSONS, SUBTREE
    use VectorsModule, only: DestroyVectorDatabase, DUMP_VECTORS, &
      & Vector_T, VectorTemplate_T
    use VGridsDatabase, only: DestroyVGridDatabase, VGrids
d583 1
a583 1
        if ( index ( switches, 'l2pc' ) > 0 ) &
d625 1
a625 1
       "$Id: tree_walker.f90,v 2.173 2011/04/08 00:10:00 pwagner Exp $"
d635 3
@


2.173
log
@Raise error if every chunk was skipped
@
text
@d254 2
a255 1
          & ) call mergeGrids ( son, griddedDataBase )
d625 1
a625 1
       "$Id: tree_walker.f90,v 2.172 2010/04/13 01:43:09 vsnyder Exp $"
d635 3
@


2.172
log
@Move FlushLockedBins from LinearizedForwardModel_m to L2PCBins_m
@
text
@d21 2
d78 1
d360 4
d624 1
a624 1
       "$Id: tree_walker.f90,v 2.171 2010/03/17 20:57:35 pwagner Exp $"
d634 3
@


2.171
log
@Print about destroyed l2pc db only if -S'l2pc'
@
text
@d67 1
a67 1
    use LinearizedForwardModel_m, only: FLUSHLOCKEDBINS
d617 1
a617 1
       "$Id: tree_walker.f90,v 2.170 2010/02/25 18:20:44 pwagner Exp $"
d627 3
@


2.170
log
@Adds support for new Hessian database
@
text
@d575 2
a576 1
        call output('Destroyed l2pc db', advance='yes')
d617 1
a617 1
       "$Id: tree_walker.f90,v 2.169 2010/02/04 19:10:58 pwagner Exp $"
d627 3
@


2.169
log
@Allocate directwrite db with zero size
@
text
@d51 1
d123 1
d153 1
a153 1
    nullify ( chunks, forwardModelConfigDatabase, griddedDataBase, &
d390 1
a390 1
                  & vectorTemplates, vectors, qtyTemplates, matrices, &
d402 1
a402 1
                & call retrieve ( son, vectors, matrices, forwardModelConfigDatabase, &
d433 4
a438 2
              if ( warnOnDestroy ) call output('About to destroy matrix db', advance='yes' )
              call DestroyMatrixDatabase ( matrices )
d485 1
a485 1
            & matrices, vectors, fileDataBase, griddedDataBase, &
d496 4
a501 2
          if ( warnOnDestroy ) call output('About to destroy matrix db', advance='yes' )
          call DestroyMatrixDatabase ( matrices )
d616 1
a616 1
       "$Id: tree_walker.f90,v 2.168 2009/10/01 19:58:00 vsnyder Exp $"
d626 3
@


2.169.2.1
log
@Can Read GEOS5.7.2 meteorology; based on v3.33
@
text
@d249 1
a249 2
          & ) call mergeGrids ( son, l2gpDatabase, l2auxDatabase, &
          & griddedDataBase, fileDataBase )
d610 1
a610 1
       "$Id: tree_walker.f90,v 2.169 2010/02/04 19:10:58 pwagner Exp $"
a619 3
! Revision 2.169  2010/02/04 19:10:58  pwagner
! Allocate directwrite db with zero size
!
@


2.168
log
@Pass file database to set_global_settings
@
text
@d161 3
d610 1
a610 1
       "$Id: tree_walker.f90,v 2.167 2009/06/23 18:46:19 pwagner Exp $"
d620 3
@


2.167
log
@Prevent Intel from optimizing ident string away
@
text
@d207 2
a208 2
        call set_global_settings ( son, forwardModelConfigDatabase, fGrids, &
          & l2gpDatabase, DirectDatabase, processingRange, filedatabase )
d607 1
a607 1
       "$Id: read_apriori.f90 is it here $"
d617 3
@


2.166
log
@May now dump an l2pc or allL2PCs (use with caution)
@
text
@d604 1
a605 1
!---------------------------- RCS Ident Info -------------------------------
d607 1
a607 1
       "$Id: tree_walker.f90,v 2.165 2008/09/19 23:56:28 pwagner Exp $"
a608 1
!---------------------------------------------------------------------------
d610 1
a610 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d612 1
d617 3
@


2.165
log
@May now Destroy GriddedData
@
text
@d398 1
a398 1
                  & chunks(chunkNo) )
d607 1
a607 1
       "$Id: tree_walker.f90,v 2.164 2008/05/20 00:29:19 vsnyder Exp $"
d617 3
@


2.164
log
@Don't leave J undefined if no chunks processed
@
text
@d478 2
a479 1
            & matrices, vectors, fileDataBase, chunks, processingRange, &
d607 1
a607 1
       "$Id: tree_walker.f90,v 2.163 2008/04/01 17:00:15 pwagner Exp $"
d611 1
d617 3
@


2.163
log
@Can get hdf5 spectroscopy file path/name from PCF
@
text
@a27 1

d162 1
a162 1
    nullify(chunksSkipped)
d175 1
a175 1
    enddo
d182 1
a182 1
      call finishUp(.true.)
d201 1
a201 1
      endif
d300 1
a300 1
        endif
d343 1
a343 1
          endif  
d351 2
a352 1
          endif
d462 9
a471 8
      ! If we're stamping stdout with phase, times, etc.
      ! we'll want to show the last phase is over
      call getStamp( textcode=textcode, showTime=showTime )
      if ( showTime .or. textCode /= ' ' ) then
        call setStamp( textCode="Output" )
      endif
      ! And resume directwrites
      skipDirectwrites = skipDirectwritesOriginal
d476 1
a476 1
        elseif ( .not. parallel%slave ) then
d492 1
a492 1
        endif
d506 1
a506 1
        elseif ( switchDetail(switches,'cab') > -1 .and. .not. parallel%slave) then
d535 1
a535 1
        endif
d544 1
d606 1
a606 1
       "$Id: tree_walker.f90,v 2.162 2007/12/07 01:15:01 pwagner Exp $"
d615 3
@


2.162
log
@Removed unused dummp varaibles, etc.
@
text
@d75 1
d82 1
a82 1
    use MLSL2Options, only: SKIPDIRECTWRITES, SKIPDIRECTWRITESORIGINAL
d206 1
a206 1
        ! --------------------------------------------------------- Init sections
d228 2
a229 1
        call spectroscopy ( son )
d236 2
a237 1
        if ( .not. ( stopBeforeChunkLoop .or. parallel%master ) ) call read_apriori ( son , &
d245 3
a247 2
        if ( .not. ( stopBeforeChunkLoop .or. checkPaths .or. parallel%master ) ) &
          & call mergeGrids ( son, griddedDataBase )
d249 1
a249 1
        ! --------------------------------------------------------- Chunk divide
d288 3
a290 2
        call algebra ( son, vectors, matrices, chunks(1), forwardModelConfigDatabase )
        ! --------------------------------------------------------- Chunk processing
d604 1
a604 1
       "$Id: tree_walker.f90,v 2.161 2007/10/09 00:34:21 pwagner Exp $"
d613 3
@


2.161
log
@ifort was crashing in destroy_DACS_Filter_Database during checkPaths; we now skip
@
text
@d243 1
a243 1
          & call mergeGrids ( son, griddedDataBase, l2gpDatabase )
d599 1
a599 1
       "$Id: tree_walker.f90,v 2.160 2007/09/13 21:51:39 pwagner Exp $"
d608 3
@


2.160
log
@Resumed destroying dbs (unless slave)
@
text
@d551 1
a551 1
      if ( .not. (myEarly .or. skipRetrieval) ) then
d599 1
a599 1
       "$Id: tree_walker.f90,v 2.159 2007/09/06 23:35:16 pwagner Exp $"
d608 3
@


2.159
log
@slaves need not do own cleanup
@
text
@d539 2
a540 1
      use FilterShapes_m, only: Destroy_Filter_Shapes_Database
d554 2
a555 4
!??? Inscrutably, destroying these databases causes memory management crashes
!??? Someday we should find out why
!        call destroy_DACS_Filter_Database
!        call destroy_Filter_Shapes_Database
d557 2
a558 3
!        call destroyL2PCDatabase
!        call output('Destroyed l2pc db', advance='yes')
        call destroy_filter_shapes_database
d599 1
a599 1
       "$Id: tree_walker.f90,v 2.158 2007/08/31 00:03:26 pwagner Exp $"
d608 3
@


2.158
log
@Summarizes warnings at end
@
text
@d72 1
a72 1
      & SKIPRETRIEVAL, SPECIALDUMPFILE, STOPAFTERSECTION
d468 3
a470 1
        if ( .not. parallel%slave ) then
d549 1
d601 1
a601 1
       "$Id: tree_walker.f90,v 2.157 2007/06/21 00:54:08 vsnyder Exp $"
d610 3
@


2.157
log
@Remove tabs, which are not part of the Fortran standard
@
text
@d74 1
a74 1
      & MLSMSG_Error
d545 1
d598 1
a598 1
       "$Id: tree_walker.f90,v 2.156 2007/06/07 20:41:07 pwagner Exp $"
d607 3
@


2.156
log
@Avoid read_ and Merge_apriori if master task
@
text
@d325 1
a325 1
	  ! if fmt1 or fmt2 is true
d327 1
a327 1
	     & associated(forwardModelConfigDatabase)) then
d382 2
a383 2
		            & chunks, chunkNo )
		          end if
d388 1
a388 1
		            & forwardModelConfigDatabase, fileDatabase, HGrids )
d470 1
a470 1
	         & matrices, vectors, fileDataBase, chunks, processingRange, &
d597 1
a597 1
       "$Id: tree_walker.f90,v 2.155 2007/04/03 17:36:44 vsnyder Exp $"
d606 3
@


2.155
log
@Allocate Vectors with zero size so others don't need to check whether
it's associated; indeed, they don't need the pointer attribute.
@
text
@d234 1
a234 1
        if ( .not. stopBeforeChunkLoop ) call read_apriori ( son , &
d242 1
a242 1
        if ( .not. ( stopBeforeChunkLoop .or. checkPaths ) ) &
d290 7
d341 7
d597 1
a597 1
       "$Id: tree_walker.f90,v 2.154 2007/03/23 00:29:41 pwagner Exp $"
d606 4
@


2.154
log
@Switch destroy warns when destroying dbs
@
text
@d73 2
a74 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Info, MLSMSG_Error
d153 8
a160 1
      & qtyTemplates, vectors, vectorTemplates, fGrids, vGrids )
d265 1
a265 1
            allocate(chunks(1), stat=error_flag)
d267 1
a267 1
              & 'unable to allocate chunks' )
d583 1
a583 1
       "$Id: tree_walker.f90,v 2.153 2007/02/14 17:31:00 pwagner Exp $"
d592 3
@


2.153
log
@Commented-out destroyL2PCDatabase (was it killing slaves?)
@
text
@d142 1
d155 1
d398 1
d401 1
d403 1
d406 1
d417 1
d428 1
d455 1
d458 1
d460 1
d472 1
d479 1
d484 1
d486 1
d575 1
a575 1
       "$Id: tree_walker.f90,v 2.152 2007/01/12 00:34:04 pwagner Exp $"
d584 3
@


2.152
log
@Renamed routine outputNamedValue
@
text
@a160 1
    ! call output( 'Sections to skip: ' // trim(sectionsToSkip), advance='yes' )
a164 3
      ! call outputNamedValue ( 'i', i, advance='no')
      ! call outputNamedValue ( '  section_name', section_name, advance='no')
      ! call outputNamedValue ( '  skip?', skipSections(i), advance='yes')
a165 2
    ! call dump( skipSections, 'skipping sections' )
    ! stop
a181 1
    ! call outputNamedValue( 'Output_Close index', z_output, advance='yes' )
a191 4
      ! call outputNamedValue( 'tree section_index', section_index, advance='yes' )
      ! if ( section_index == z_output ) then
      !   call output("Now is our chance to go through output", advance='yes')
      ! endif
a305 2
            ! call output('Skipping ', advance='no')
            ! call output(trim(section_name), advance='yes')
a336 1
              ! call output( 'Now inside subtrees loop', advance='yes' )
a342 1
              ! call outputNamedValue( 'subtree section_index', section_index, advance='yes' )
a378 1
            ! call output( 'Now outside subtrees loop', advance='yes' )
a436 1
        ! call output( 'Now our chance to call Output_Close', advance='yes' )
a438 1
          ! call output( 'Now calling Output_Close', advance='yes' )
d517 2
a518 1
        call destroyL2PCDatabase
d560 1
a560 1
       "$Id: tree_walker.f90,v 2.151 2006/10/09 18:39:35 pwagner Exp $"
d569 3
@


2.151
log
@Fixed bug preventing a call to Output_CLose
@
text
@d37 1
a37 2
    use ChunkDivide_m, only: ChunkDivide, DestroyChunkDatabase, &
      & ReduceChunkDatabase
d84 1
a84 1
    use Output_m, only: BLANKS, getStamp, Output, output_name_v_pair, &
d166 3
a168 3
      ! call output_name_v_pair ( 'i', i, advance='no')
      ! call output_name_v_pair ( '  section_name', section_name, advance='no')
      ! call output_name_v_pair ( '  skip?', skipSections(i), advance='yes')
d188 1
a188 1
    ! call output_name_v_pair( 'Output_Close index', z_output, advance='yes' )
d199 1
a199 1
      ! call output_name_v_pair( 'tree section_index', section_index, advance='yes' )
d243 1
a243 1
        if ( .not. stopBeforeChunkLoop ) &
d357 1
a357 1
              ! call output_name_v_pair( 'subtree section_index', section_index, advance='yes' )
d518 1
a518 2
      use FilterShapes_m, only: Destroy_DACS_Filter_Database, &
        & Destroy_Filter_Shapes_Database
d577 1
a577 1
       "$Id: tree_walker.f90,v 2.150 2006/10/05 23:32:43 pwagner Exp $"
d586 3
@


2.150
log
@skipSections can skip named sections
@
text
@d189 1
d200 4
d351 1
d358 1
d387 2
d395 1
d454 1
d457 1
d579 1
a579 1
       "$Id: tree_walker.f90,v 2.149 2006/08/14 16:22:28 pwagner Exp $"
d588 3
@


2.149
log
@Should not double-deallocate if canWriteL2PC
@
text
@d32 1
a32 1
    & COUNTCHUNKS, FILEDATABASE )
d43 1
d56 1
d60 1
d79 1
a79 1
    use MLSStringLists, only: ExpandStringRange, SwitchDetail
d85 1
a85 1
    use Output_m, only: BLANKS, getStamp, Output, &
d93 1
a93 1
  ! use Test_Parse_Signals_m, only: Test_Parse_Signals
d107 1
d134 2
d137 1
d162 11
d185 2
a186 2
    ! -------------------------------------------------------------
    ! ------------------------------------------------------------- Loop over tree
d191 8
a198 1

d200 1
a200 1
      select case ( decoration(subtree(1,son)) ) ! section index
d300 1
a300 1
          select case ( decoration(subtree(1,son)) ) ! section index
d311 4
d333 1
a333 1
          do chunkNo = firstChunk, lastChunk ! ----------------------- Chunk loop
d347 6
a352 1
              select case ( decoration(subtree(1,son)) ) ! section index
d381 2
a382 1
                exit subtrees
d492 6
d567 1
a567 1
       "$Id: tree_walker.f90,v 2.148 2006/08/10 21:46:50 pwagner Exp $"
d576 3
@


2.148
log
@--chunk commandline option now synonym for --chunkRange
@
text
@d418 1
d423 1
d526 1
a526 1
       "$Id: tree_walker.f90,v 2.147 2006/08/05 02:10:46 vsnyder Exp $"
d535 3
@


2.147
log
@Delete some debugging print I shouldn't have left at the last check-in
@
text
@a27 2
  ! logical :: GLOBALSETTINGSONLY = .false.
  ! logical :: CHUNKDIVIDEONLY = .false.
d32 1
a32 1
    & COUNTCHUNKS, SINGLECHUNK, LASTCHUNKIN, FILEDATABASE )
a102 2
    integer, intent(in) ::     SINGLECHUNK ! Just run this one chunk (0 if all)
    integer, intent(in) ::     LASTCHUNKIN ! Just run range [single,last]
d105 1
d108 1
a108 1
    logical, dimension(:), pointer :: CHUNKSSKIPPED=> null() ! Don't do these
d121 1
d142 1
d147 2
a148 2
    ! globalsettingsonly = STOPAFTERGLOBAL
    ! chunkdivideonly    = STOPAFTERCHUNKDIVIDE
a152 2
    ! print *, 'trim(stopAfterSection): ', trim(stopAfterSection)
    ! print *, 'stopBeforeChunkLoop: ', stopBeforeChunkLoop
d232 1
a232 1
          if ( .not. checkPaths ) then
d241 2
a242 22
          if ( singleChunk /= 0 ) then
            if ( singleChunk < 0 ) then
              call output ( " single chunk " )
              call output ( singleChunk, advance='yes' )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'single chunk number < 0' )
            else if ( singleChunk > size(chunks) ) then
              call output ( " single chunk " )
              call output ( singleChunk, advance='yes' )
              call output ( " size(chunks) " )
              call output ( size(chunks), advance='yes' )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'single chunk number > size(chunks)' )
            end if
            firstChunk = singleChunk
            lastChunk = singleChunk
            if ( lastChunkIn > firstChunk ) &
              & lastChunk = min(lastChunkIn, size(chunks))
          else
            firstChunk = 1
            lastChunk = size(chunks)
          end if
a265 4
            if ( singleChunk /= 0 .and. .not. reducedChunks ) then
              call ReduceChunkDatabase(chunks, singleChunk, lastChunk )
              reducedChunks = .true.  ! So we don't try this more than once
            end if
d269 1
d271 1
a271 1
              & chunks(singleChunk) ) 
d293 1
a295 1
          nullify(chunksSkipped)
d303 1
d367 1
a367 2
            if ( size(chunks) > 1 .and. &
              & ( singleChunk == 0 .or. lastChunkIn /= 0 ) ) then
d413 1
a413 1
            & size(chunks)==1 .or. singleChunk /= 0 )
a417 2
!        if ( size(chunks) == 1 .or. &
!          & (singleChunk /= 0 .and. lastChunk == 0) ) then
a421 1
!        end if
a494 1
        ! call dump(fGrids, destroy=.true.)
d524 1
a524 1
       "$Id: tree_walker.f90,v 2.146 2006/08/05 00:41:50 vsnyder Exp $"
d533 3
@


2.146
log
@Comment out filter database destruction -- causes memory trouble
@
text
@a388 3
call output ( size(chunks), before='Size(chunks) = ' )
call output ( singleChunk, before=', SingleChunk = ' )
call output ( lastChunkIn, before=', LastChunkIn = ', advance='yes' )
d441 1
a441 3
call output ( size(chunks), before='size(chunks) = ' )
call output ( singleChunk, before=', singleChunk = ' )
call output ( lastChunk, before=', lastChunk = ', advance='yes' )
d554 1
a554 1
       "$Id: tree_walker.f90,v 2.145 2006/08/02 19:53:26 vsnyder Exp $"
d563 3
@


2.145
log
@Send Vectors database to outputClose for destroy command
@
text
@a47 1
    use FilterShapes_m, only: Destroy_Filter_Shapes_Database
d389 3
d444 3
a446 1

d449 2
a450 2
        if ( size(chunks) == 1 .or. &
          & (singleChunk /= 0 .and. lastChunk == 0) ) then
d455 1
a455 1
        end if
d498 2
d509 8
a516 4
        call DestroyChunkDatabase ( chunks )
        call destroy_ant_patterns_database
        call DestroyBinSelectorDatabase
        call DestroyL2PCDatabase
d518 1
a518 1
        call DestroyFWMConfigDatabase ( forwardModelConfigDatabase )
d522 5
a526 5
        call DestroyBandDatabase ( Bands )
        call DestroyModuleDatabase ( Modules )
        call DestroyRadiometerDatabase ( Radiometers )
        call DestroySpectrometerTypeDatabase ( SpectrometerTypes )
        call DestroySignalDatabase ( Signals )
d559 1
a559 1
       "$Id: tree_walker.f90,v 2.144 2006/07/24 20:35:04 pwagner Exp $"
d568 3
@


2.144
log
@Fixed bug when stopAfterSection is blank
@
text
@d439 1
a439 1
	         & matrices, fileDataBase, chunks, processingRange, &
d549 1
a549 1
       "$Id: tree_walker.f90,v 2.143 2006/07/21 20:12:26 pwagner Exp $"
d558 3
@


2.143
log
@Can select what section to stop after
@
text
@d154 3
d549 1
a549 1
       "$Id: tree_walker.f90,v 2.142 2006/06/12 16:28:25 pwagner Exp $"
d558 3
@


2.142
log
@Added ability to dump Gridded Data
@
text
@d28 2
a29 2
  logical :: GLOBALSETTINGSONLY = .false.
  logical :: CHUNKDIVIDEONLY = .false.
a68 1
    use MACHINE, only: MLS_HOWMANY_GC
d73 1
a73 1
      & SKIPRETRIEVAL, SPECIALDUMPFILE, STOPAFTERCHUNKDIVIDE, STOPAFTERGLOBAL
d80 1
d130 1
d135 1
a135 1
    logical ::                                   STOPEARLY
d149 5
a153 3
    globalsettingsonly = STOPAFTERGLOBAL
    chunkdivideonly    = STOPAFTERCHUNKDIVIDE
    stopearly          = globalsettingsonly .or. chunkdivideonly
d160 5
a164 1
    call add_to_section_timing ( 'open_init', t1)
d182 2
a183 2
        call add_to_section_timing ( 'global_settings', t1)
        if ( GLOBALSETTINGSONLY .and. .not. parallel%slave ) then
d194 5
a198 1
        call add_to_section_timing ( 'signals', t1)
d201 5
a205 1
        call add_to_section_timing ( 'spectroscopy', t1)
d207 1
a207 1
        if ( .not. stopearly ) call read_apriori ( son , &
d209 5
a213 1
        call add_to_section_timing ( 'read_apriori', t1)
d215 1
a215 1
        if ( .not. stopearly ) &
d221 5
d271 2
a272 2
        call add_to_section_timing ( 'chunk_divide', t1)
        if ( CHUNKDIVIDEONLY .or. GLOBALSETTINGSONLY ) then
a275 1

d301 1
a301 1
            call add_to_section_timing ( 'algebra', t1)
d303 1
a303 1
            call add_to_section_timing ( 'construct', t1)
d305 1
a305 1
            call add_to_section_timing ( 'fill', t1)
d307 1
a307 1
            call add_to_section_timing ( 'join', t1)
d309 1
a309 1
            call add_to_section_timing ( 'retrieve', t1)
d350 1
a350 1
                call add_to_section_timing ( 'construct', t1)
d358 1
a358 1
                call add_to_section_timing ( 'fill', t1)
d363 1
a363 1
                call add_to_section_timing ( 'join', t1)
d368 1
a368 1
                call add_to_section_timing ( 'retrieve', t1)
d411 4
d546 1
a546 1
       "$Id: tree_walker.f90,v 2.141 2006/05/05 16:49:23 pwagner Exp $"
d555 3
@


2.141
log
@May convertEtaToP and create a VGrid in MergeGrids section
@
text
@d326 1
a326 1
                  & mifGeolocation )
d519 1
a519 1
       "$Id: tree_walker.f90,v 2.140 2006/04/11 23:30:00 pwagner Exp $"
d528 3
@


2.140
log
@chunkRange option effective in serial runs, too
@
text
@d196 2
a197 1
        if ( .not. stopearly ) call mergeGrids ( son, griddedDataBase )
d519 1
a519 1
       "$Id: tree_walker.f90,v 2.139 2006/03/04 00:22:04 pwagner Exp $"
d528 3
@


2.139
log
@Restore original skipDirectWrites after chunkLoop ends
@
text
@d37 1
d80 1
a80 1
    use MLSStringLists, only: SwitchDetail
d112 1
d295 8
d305 1
d338 1
a338 1
		            & forwardModelConfigDatabase, fileDatabase )
d390 2
d518 1
a518 1
       "$Id: tree_walker.f90,v 2.138 2006/02/16 00:16:32 pwagner Exp $"
d527 3
@


2.138
log
@switchDetail instead of index
@
text
@d17 1
a17 1
  implicit NONE
d80 1
d312 1
a312 1
                  & chunks(chunkNo), qtyTemplates, vectorTemplates, &
d389 2
d505 1
a505 1
       "$Id: tree_walker.f90,v 2.137 2006/02/10 21:15:26 pwagner Exp $"
d514 3
@


2.137
log
@dumps may go to special dumpfile
@
text
@d83 2
a84 1
    use Output_m, only: BLANKS, Output, RESUMEOUTPUT, revertoutput, switchOutput
d129 1
a129 1
    ! logical ::                                   show_totalNGC = .true.
d133 1
a133 1
    integer ::                                   totalNGC   ! Total num garbage colls.
a149 1
    totalNGC = 0
d179 1
a179 1
        if ( index(switches,'tps') /= 0 ) then
d286 1
a286 1
          if ( index(switches, 'fmt') /= 0 .and. &
d295 1
a295 1
            if ( index(switches,'chu') /= 0 ) then
d316 1
a316 2
                !if ( .not. checkPaths) &
                if ( .not. checkPaths) then 
d339 1
a339 1
            if ( index(switches,'chi1') /= 0 .and. chunkNo > 1) then
d341 1
a341 1
            else if ( index(switches,'chi') /= 0 ) then
a359 3
              ! if (garbage_collection_by_chunk) call mls_gc_now
              ! if ( index(switches,'ngc') /= 0 ) &
              !  & totalNGC = Say_num_gcs()
d364 1
a364 1
            if ( index(switches, 'fmt2') /= 0 ) then
d367 2
a368 1
            if ( index(switches, 'fmt1') /= 0 .and. chunkNo == lastChunk) then
d372 1
a372 1
            if ( index(switches,'chu') /= 0 ) then
d382 6
d410 1
a410 1
        if ( index(switches,'gridd') /= 0 .and. .not. parallel%slave &
a413 1
        ! print *, 'About to destroy gridded databse'
d415 1
a415 1
        if ( index(switches,'l2gp') /= 0 .and. .not. parallel%slave) then
d417 1
a417 1
        elseif ( index(switches,'cab') /= 0 .and. .not. parallel%slave) then
a419 1
        ! print *, 'About to destroy l2gp databse'
d421 1
a421 1
        if ( index(switches,'l2aux') /= 0 .and. .not. parallel%slave) then
a423 1
        ! print *, 'About to destroy l2aux databse'
a424 1
        ! print *, 'About to destroy direct databse'
d429 2
a430 2
        if ( index(switches,'pro') /= 0  .and. associated(fileDataBase) ) then
          ! details = min(index(switches,'pro1'), 1)
a496 14
!     integer function Say_num_gcs ( )
!       Say_num_gcs = mls_howmany_gc()
!       if ( show_totalNGC ) then
!         call output ( "Total = " )
!         call output ( Say_num_gcs, advance = 'no' )
!         call blanks ( 4, advance = 'no' )
!       end if
!       call output ( "garbage collections for chunk ")
!       call blanks ( 2, advance = 'no' )
!       call output ( chunkNo )
!       call output ( " = ")
!       call output ( Say_num_gcs - totalNGC, advance = 'yes' )
!     end function Say_num_gcs

d502 1
a502 1
       "$Id: tree_walker.f90,v 2.136 2006/01/11 17:02:16 pwagner Exp $"
d511 3
@


2.136
log
@Repaired erroneous report when single chunk > size(chunks)
@
text
@d73 1
a73 1
      & SKIPRETRIEVAL, STOPAFTERCHUNKDIVIDE, STOPAFTERGLOBAL
d83 1
a83 1
    use Output_m, only: BLANKS, Output, RESUMEOUTPUT
d343 2
d349 2
d403 2
d435 2
d517 1
a517 1
       "$Id: tree_walker.f90,v 2.135 2006/01/06 01:15:01 pwagner Exp $"
d526 3
@


2.135
log
@Resumes output at start of each chunk, and OutputClose
@
text
@d223 2
a224 2
              call output ( " lastChunk " )
              call output ( lastChunk, advance='yes' )
d226 1
a226 1
              & 'single chunk number > lastChunk' )
d509 1
a509 1
       "$Id: tree_walker.f90,v 2.134 2005/08/19 23:35:01 pwagner Exp $"
d518 3
@


2.134
log
@Allow Output to repair l2gp with HGrid while copying files
@
text
@d83 1
a83 1
    use Output_m, only: BLANKS, Output
d293 1
d382 1
d509 1
a509 1
       "$Id: tree_walker.f90,v 2.133 2005/07/12 17:37:20 pwagner Exp $"
d518 3
@


2.133
log
@Removed unused DestroyL1BInfo
@
text
@d383 2
a384 1
	         & matrices, fileDataBase,  size(chunks)==1 .or. singleChunk /= 0 )
d507 1
a507 1
       "$Id: tree_walker.f90,v 2.132 2005/06/14 20:44:36 pwagner Exp $"
d516 3
@


2.132
log
@Interfaces changed to accept MLSFile_T args
@
text
@d81 1
a81 1
    use Open_Init, only: DestroyL1BInfo, OpenAndInitialize
a462 1
        ! call DestroyL1BInfo ( l1bInfo )
d506 1
a506 1
       "$Id: tree_walker.f90,v 2.131 2005/06/03 02:05:29 vsnyder Exp $"
d515 3
@


2.131
log
@New copyright notice, move Id to not_used_here to avoid cascades,
get VGrids from VGridsDatabase instead of passing as an argument.
@
text
@a67 1
!   use MACHINE, only: MLS_GC_NOW
a71 1
  ! use MLSFiles, only: MLSFile_T
d79 1
d106 1
a106 1

d109 2
a121 1
    ! type (L1BInfo_T) ::                          L1BInfo  ! File handles etc. for L1B dataset
a122 1
    type (DirectData_T), dimension(:), pointer :: DirectDatabase
a123 1
    ! type (PCFData_T) ::                          L2pcf
d128 1
a132 1
    logical ::                                   show_totalNGC = .true.
a152 1
    ! call OpenAndInitialize ( processingRange, l1bInfo )
a171 1
          ! & l2gpDatabase, DirectDatabase, processingRange, l1bInfo )
d189 2
a190 1
        if ( .not. stopearly ) call read_apriori ( son , l2gpDatabase, l2auxDatabase, griddedDataBase )
a205 1
            ! call ChunkDivide ( son, processingRange, l1bInfo, chunks )
a206 1
            ! call ComputeAllHGridOffsets ( root, i+1, chunks, l1bInfo, &
a266 1
            ! call ConstructMIFGeolocation ( mifGeolocation, l1bInfo, &
a316 1
                  ! call MLSL2Fill ( son, l1bInfo, griddedDataBase, &
d326 1
a326 1
		            & forwardModelConfigDatabase )
d383 1
a383 1
	    & matrices, size(chunks)==1 .or. singleChunk /= 0 )
d420 6
d488 13
a500 13
    integer function Say_num_gcs ( )
      Say_num_gcs = mls_howmany_gc()
      if ( show_totalNGC ) then
        call output ( "Total = " )
        call output ( Say_num_gcs, advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "garbage collections for chunk ")
      call blanks ( 2, advance = 'no' )
      call output ( chunkNo )
      call output ( " = ")
      call output ( Say_num_gcs - totalNGC, advance = 'yes' )
    end function Say_num_gcs
d507 1
a507 1
       "$Id: tree_walker.f90,v 2.130 2005/05/31 17:51:17 pwagner Exp $"
d516 4
@


2.130
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d1 10
a10 2
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a16 1

d23 1
a23 4
  character (len=*), private, parameter :: IdParm = &
       "$Id: tree_walker.f90,v 2.129 2004/12/14 21:56:50 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
  character (len=*), private, parameter :: ModuleName= &
d27 1
d73 1
a73 1
    ! use MLSFiles, only: MLSFile_T
d91 1
a91 1
    ! use Test_Parse_Signals_m, only: Test_Parse_Signals
d98 1
a98 1
    use VGridsDatabase, only: DestroyVGridDatabase, VGrid_T
d100 1
a100 1
    integer, intent(in) ::     ROOT         ! Root of the abstract syntax tree
d108 2
a109 2
    integer ::                                  chunkNo ! Index of Chunks
    type (MLSChunk_T), dimension(:), pointer :: Chunks  ! of data
a135 1
    type (VGrid_T), dimension(:), pointer ::     VGrids
d173 1
a173 1
        call set_global_settings ( son, forwardModelConfigDatabase, fGrids, vGrids, &
d180 1
a180 1
        endif
d187 1
a187 1
        endif
d218 1
a218 1
          endif
d232 1
a232 1
            endif
d252 1
a252 1
        endif
d268 1
a268 1
            endif
d317 1
a317 1
                  & fGrids, vGrids, hGrids, l2gpDatabase, forwardModelConfigDatabase, &
d325 1
a325 1
                  & vectorTemplates, vectors, qtyTemplates, matrices, vGrids, &
d328 1
a328 1
		          endif
d437 2
a438 2
    subroutine finishUp(early)
      logical, intent(in), optional :: early
d465 1
a465 1
      endif
d468 1
a468 1
    end subroutine finishUp
d478 1
a478 1
      endif
d506 5
d517 3
@


2.129
log
@Changes related to stopping early
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.128 2004/07/22 20:49:58 cvuu Exp $"
d67 1
a67 1
    use MLSCommon, only: L1BINFO_T, TAI93_RANGE_T, MLSFile_T
d116 1
a116 1
    type (L1BInfo_T) ::                          L1BInfo  ! File handles etc. for L1B dataset
d151 2
a152 1
    call OpenAndInitialize ( processingRange, l1bInfo )
d170 2
a171 1
          & l2gpDatabase, DirectDatabase, processingRange, l1bInfo )
d205 4
a208 2
            call ChunkDivide ( son, processingRange, l1bInfo, chunks )
            call ComputeAllHGridOffsets ( root, i+1, chunks, l1bInfo, &
d268 2
a269 1
            call ConstructMIFGeolocation ( mifGeolocation, l1bInfo, &
d311 1
a311 1
                & call MLSL2Construct ( son, l1bInfo, processingRange, &
d319 2
a320 1
                  call MLSL2Fill ( son, l1bInfo, griddedDataBase, &
d460 1
a460 1
        call DestroyL1BInfo ( l1bInfo )
d508 3
@


2.128
log
@Add forwardModelConfigDatabase to the call MLSL2Join and MLSL2Fill
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.127 2004/05/19 19:16:12 vsnyder Exp $"
d23 2
d40 1
a40 1
    use FGrid, only: FGrid_T, DestroyFGridDatabase
d69 2
a70 1
    use MLSL2Options, only: CHECKPATHS
d124 1
d126 1
d142 4
d171 4
d187 1
a187 1
        call read_apriori ( son , l2gpDatabase, l2auxDatabase, griddedDataBase )
d190 1
a190 1
        call mergeGrids ( son, griddedDataBase )
d202 1
a202 1
          if ( .not. checkPaths) then
d241 4
d257 1
a257 1
            if ( singleChunk /= 0 ) then
d259 1
d305 1
a305 1
                if ( .not. checkPaths) &
d317 2
a318 2
		  & chunks, chunkNo )
		endif
d323 1
a323 1
		  & forwardModelConfigDatabase )
d399 1
d406 1
d411 1
d413 1
d424 1
a424 20
    call CloseParallel(size(Chunks))
    call DestroyChunkDatabase ( chunks )
    call destroy_ant_patterns_database
    call DestroyBinSelectorDatabase
    call DestroyL2PCDatabase
    call destroy_filter_shapes_database
    call DestroyFWMConfigDatabase ( forwardModelConfigDatabase )
    call destroy_line_database
    call destroy_pointing_grid_database
    call destroy_spectcat_database
    call DestroyBandDatabase ( Bands )
    call DestroyModuleDatabase ( Modules )
    call DestroyRadiometerDatabase ( Radiometers )
    call DestroySpectrometerTypeDatabase ( SpectrometerTypes )
    call DestroySignalDatabase ( Signals )
    call destroyVGridDatabase ( vGrids )
    call destroyFGridDatabase ( fGrids )
    call DestroyL1BInfo ( l1bInfo )
    error_flag = 0
    if ( toggle(gen) ) call trace_end ( 'WALK_TREE_TO_DO_MLS_L2' )
d427 33
d502 3
@


2.127
log
@Move MLSChunk_t to Chunks_m
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.126 2004/04/28 23:07:44 livesey Exp $"
d294 3
a296 2
                if ( .not. checkPaths) &
                & call MLSL2Fill ( son, l1bInfo, griddedDataBase, &
d298 3
a300 1
                  & l2gpDatabase, l2auxDatabase, chunks, chunkNo )
d304 2
a305 1
                  & l2auxDatabase, DirectDatabase, chunkNo, chunks )
d362 1
a362 1
            & matrices, size(chunks)==1 .or. singleChunk /= 0 )
d466 3
@


2.126
log
@Now passes more stuff to Algebra
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.125 2004/02/10 19:29:36 pwagner Exp $"
d33 1
a36 1
    use Dumper, only: Dump
d44 1
a44 2
    use ForwardModelSupport, only: printForwardModelTiming, &
      & resetForwardModelTiming
d61 2
a62 1
    use MACHINE, only: MLS_GC_NOW, MLS_HOWMANY_GC
d65 1
a65 1
    use MLSCommon, only: L1BINFO_T, MLSCHUNK_T, TAI93_RANGE_T, MLSFile_T
a123 1
    integer ::                                   fwmIndex  ! Index
d462 3
@


2.125
log
@Prints time for processing each chunk at chunks end
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.124 2004/01/17 00:28:09 vsnyder Exp $"
d231 1
a231 1
        call algebra ( son, vectors, matrices )
d286 1
a286 1
                call algebra ( son, vectors, matrices )
d463 3
@


2.124
log
@Provide for Algebra section
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.123 2004/01/14 18:49:58 vsnyder Exp $"
d122 1
a122 1
    real    ::                                   t1, t2
a269 1

d273 1
d346 3
d421 1
a421 1
    subroutine SayTime ( What )
d423 7
d437 1
a437 1
      call output ( dble(t2 - t1), advance = 'yes' )
d463 3
@


2.123
log
@Stuff to support the Algebra section
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.122 2003/12/16 01:28:56 livesey Exp $"
d29 1
d230 2
d234 1
a234 1
      case ( z_algebra, z_construct, z_fill, z_join, z_retrieve )
d286 1
d453 3
@


2.122
log
@Moved the destruction of the chunk database to after closeParallel.
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.121 2003/12/11 22:59:32 pwagner Exp $"
d49 4
a52 4
    use Init_Tables_Module, only: L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, &
      & Z_CHUNKDIVIDE,  Z_CONSTRUCT, Z_FILL, Z_GLOBALSETTINGS, Z_JOIN, &
      & Z_MERGEGRIDS, Z_MLSSIGNALS, Z_OUTPUT, Z_READAPRIORI, Z_RETRIEVE, &
      & Z_SPECTROSCOPY
d231 1
a231 1
      case ( z_construct, z_fill, z_join, z_retrieve )
d250 2
d282 1
d449 3
@


2.121
log
@May fill DirectWriteDatabase in global settings
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.120 2003/12/05 00:42:05 pwagner Exp $"
a368 1
        call DestroyChunkDatabase (chunks )
d390 1
d446 3
@


2.120
log
@Removed last vestige of explicit garbage collection
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.119 2003/11/07 00:46:51 pwagner Exp $"
d99 2
a100 2
    integer ::                                  chunkNo                  ! Index of Chunks
    type (MLSChunk_T), dimension(:), pointer :: Chunks ! of data
d160 1
a160 1
          & l2gpDatabase, processingRange, l1bInfo )
d390 1
a390 1
    call CloseParallel
d446 3
@


2.119
log
@New quicker preflight option: --checkPaths
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.118 2003/11/05 21:27:54 pwagner Exp $"
d66 1
a66 1
    use MLSL2Options, only: GARBAGE_COLLECTION_BY_CHUNK, CHECKPATHS
d325 3
a327 3
              if (garbage_collection_by_chunk) call mls_gc_now
              if ( index(switches,'ngc') /= 0 ) &
                & totalNGC = Say_num_gcs()
d446 3
@


2.118
log
@Can enter range of chunks to be processed instead of single
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.117 2003/10/09 23:31:26 pwagner Exp $"
d66 1
a66 1
    use MLSL2Options, only: GARBAGE_COLLECTION_BY_CHUNK
d189 9
a197 3
          call ChunkDivide ( son, processingRange, l1bInfo, chunks )
          call ComputeAllHGridOffsets ( root, i+1, chunks, l1bInfo, l2gpDatabase, &
            & processingRange )
d281 2
a282 1
                call MLSL2Construct ( son, l1bInfo, processingRange, &
d288 2
a289 1
                call MLSL2Fill ( son, l1bInfo, griddedDataBase, &
d298 2
a299 1
                call retrieve ( son, vectors, matrices, forwardModelConfigDatabase, &
d446 3
@


2.117
log
@Changed grid switch to gridd
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.116 2003/09/03 15:56:18 cvuu Exp $"
d27 1
a27 1
    & COUNTCHUNKS, SINGLECHUNK, FILEDATABASE )
d96 1
d208 2
d233 1
a233 1
              call ReduceChunkDatabase(chunks, singleChunk, singleChunk )
d310 2
a311 1
            if ( size(chunks) > 1 .and. singleChunk == 0 ) then
d345 2
a346 1
        if ( size(chunks) == 1 .or. singleChunk /= 0 ) then
d437 3
@


2.116
log
@Move the do loop over the forwardModel inside subroutine PrintForwardModelTiming
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.115 2003/09/02 18:04:38 pwagner Exp $"
d350 1
a350 1
        if ( index(switches,'grid') /= 0 .and. .not. parallel%slave &
d432 3
@


2.115
log
@Can do a singleChunk even if master task
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.114 2003/08/21 21:24:39 cvuu Exp $"
d254 2
a255 17
	       call output ("======= printForwardModelTiming =========", &
		  & advance = 'yes')
	       call output ( " ", advance = 'yes')
	       call output ( "Name", advance='no')
	       call blanks (18, advance ='no')
	       call output ("| Invocation ", advance = 'no')
	       call output ( "| Mean_time / s ", advance='no') 
	       call output ("| St. dev. / s", advance='yes') 
	       call output ("-------------------------------------------&
	              &-----------------------------", advance= 'yes')    
               do fwmIndex =1, size(forwardModelConfigDatabase)
                  call printForwardModelTiming ( forwardModelConfigDatabase &
                        & (fwmIndex))
                  call resetForwardModelTiming ( forwardModelConfigDatabase &
                        & (fwmIndex))
               end do
          end if  !--------- End of if fmt
d320 2
a321 17
	       call output ( "======= printForwardModelTiming =========", &
		  & advance = 'yes')
	       call output ( " ", advance = 'yes')
	       call output ( "Name", advance='no')
	       call blanks (18, advance ='no')
	       call output ("| Invocation ", advance = 'no')
	       call output ( "| Mean_time / s ", advance='no') 
	       call output ("| St. dev. / s", advance='yes') 
	       call output ("-------------------------------------------&
	              &-----------------------------", advance= 'yes')    
               do fwmIndex =1, size(forwardModelConfigDatabase)
                  call printForwardModelTiming ( forwardModelConfigDatabase &
                        & (fwmIndex))
                  call resetForwardModelTiming ( forwardModelConfigDatabase &
                        & (fwmIndex))
               end do
            end if  !--------- End of if fmt2
d323 2
a324 15
	       call output ("======= printForwardModelTiming =========", &
		  & advance = 'yes')
	       call output ( " ", advance = 'yes')
	       call output ( "Name", advance='no')
	       call blanks (18, advance ='no')
	       call output ("| Invocation ", advance = 'no')
	       call output ( "| Mean_time / s ", advance='no') 
	       call output ("| St. dev. / s", advance='yes') 
	       call output ("-------------------------------------------&
	              &-----------------------------", advance= 'yes')    
               do fwmIndex =1, size(forwardModelConfigDatabase)
                  call printForwardModelTiming ( &
                   & forwardModelConfigDatabase(fwmIndex))
               end do
            end if  ! ---------- End of if fmt1
d432 3
@


2.114
log
@Change the output format for fullForwardModel Timing
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.113 2003/08/21 16:07:34 livesey Exp $"
d30 4
a33 2
    use ChunkDivide_m, only: ChunkDivide, DestroyChunkDatabase
    use Construct, only: MLSL2Construct, MLSL2DeConstruct, ConstructMIFGeolocation
d40 2
a41 1
    use ForwardModelConfig, only: ForwardModelConfig_T, DestroyFWMConfigDatabase, &
d229 3
d475 3
@


2.113
log
@Now calls FlushLockedBins automatically at the end of each chunk.
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.112 2003/08/11 23:24:02 pwagner Exp $"
d248 10
d329 10
d347 10
d469 3
@


2.112
log
@Stores ChunkNo as component of L2ParallelInfo_T
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.111 2003/07/07 23:51:06 pwagner Exp $"
d57 1
d334 2
d439 3
@


2.111
log
@Need not pass around l2pc as L2pcf now a saved variable in WriteMetaData
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.110 2003/06/30 22:56:16 cvuu Exp $"
d182 1
d436 3
@


2.110
log
@Print mean, std dev for fullForwardModel timing
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.109 2003/06/24 23:54:07 pwagner Exp $"
a85 1
    use WriteMetadata, only: PCFData_T
d111 1
a111 1
    type (PCFData_T) ::                          L2pcf
d137 1
a137 1
    call OpenAndInitialize ( processingRange, l1bInfo, l2pcf )
d155 1
a155 1
          & l2gpDatabase, l2pcf, processingRange, l1bInfo )
d339 1
a339 1
            & matrices, l2pcf, size(chunks)==1 .or. singleChunk /= 0 )
d395 1
a395 1
    call DestroyL1BInfo ( l1bInfo, l2pcf )
d435 3
@


2.109
log
@New db indexes stored for entire direct file
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.108 2003/06/24 23:00:53 livesey Exp $"
d40 2
d119 1
d243 11
d315 16
d436 3
@


2.108
log
@Nullified directDatabase
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.107 2003/06/23 23:55:17 pwagner Exp $"
d309 2
a310 2
          call Output_Close ( son, l2gpDatabase, l2auxDatabase, matrices, l2pcf,&
            & size(chunks)==1 .or. singleChunk /= 0 )
d406 3
@


2.107
log
@Added DirectData_T to keep track of data written directly
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.106 2003/06/20 19:38:26 pwagner Exp $"
d127 1
a127 1
      & hGrids, l2auxDatabase, l2gpDatabase, matrices, mifGeolocation, &
d406 3
@


2.106
log
@Allows direct writing of output products
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.105 2003/06/09 22:51:35 pwagner Exp $"
d32 1
d108 1
d268 1
a268 1
                  & l2auxDatabase, chunkNo, chunks )
d340 1
d406 3
@


2.105
log
@Renamed scan_divide to chunk_divide in timings table
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.104 2003/03/08 00:46:08 pwagner Exp $"
d41 2
a42 1
    use HGrid, only: HGrid_T
a127 2
!   The following should not be needed
!    call nullifyPCFData ( l2pcf ) ! for Sun's rubbish compiler
d138 3
d147 2
d170 3
a172 2
      ! Chunk divide can be a special one, in slave mode, we just listen out
      ! for instructions.
d180 2
d188 1
a188 1
            elseif ( singleChunk > size(chunks) ) then
d211 2
a212 1
      ! Now construct, fill, join and retrieve live inside the 'chunk loop'
d219 3
a221 2
          if ( parallel%master .and. .not. parallel%fwmParallel ) &
            & call L2MasterTask ( chunks, l2gpDatabase, l2auxDatabase )
d224 1
a224 1
              & chunks, singleChunk ) 
d255 1
a255 1
                  & chunks, chunkNo, qtyTemplates, vectorTemplates, &
d262 1
a262 1
                  & l2gpDatabase, l2auxDatabase, chunks, chunkNo)
d277 1
d280 1
a280 1
            elseif ( index(switches,'chi') /= 0 ) then
a299 1

d303 2
a304 1
      ! Output is always the last section
d403 3
@


2.104
log
@Per njl, checks for illegal single chunk runs
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.103 2003/02/21 21:03:39 pwagner Exp $"
d202 1
a202 1
        call add_to_section_timing ( 'scan_divide', t1)
d393 3
@


2.103
log
@Disabled tps switch to eliminate need for Test_Parse_Signals
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d17 1
a17 1
       "$Id: tree_walker.f90,v 2.102 2003/01/13 20:59:14 livesey Exp $"
d59 1
a59 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Info
d176 13
d393 3
@


2.102
log
@Removed a print statement
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.101 2002/12/05 19:45:20 pwagner Exp $"
d59 1
d74 1
a74 1
    use Test_Parse_Signals_m, only: Test_Parse_Signals
d151 5
a155 1
        if ( index(switches,'tps') /= 0 ) call test_parse_signals
d380 3
@


2.101
log
@Moved MLSFile_T from MLSFiles to MLSCommon
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.100 2002/12/04 01:18:21 pwagner Exp $"
a195 1
            print*,'Single chunk is:', singleChunk
d375 3
@


2.100
log
@First halting steps toward using filedatabase
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.99 2002/11/22 12:24:25 mjf Exp $"
d56 2
a57 2
    use MLSCommon, only: L1BINFO_T, MLSCHUNK_T, TAI93_RANGE_T
    use MLSFiles, only: MLSFile_T
d376 3
@


2.99
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.98 2002/11/22 01:14:06 vsnyder Exp $"
d27 1
a27 1
    & COUNTCHUNKS, SINGLECHUNK )
d57 1
d88 1
d376 4
@


2.98
log
@Remove USE'd but unreferenced symbols and two unused local variables
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.97 2002/11/21 18:45:04 livesey Exp $"
d124 2
a125 1
    nullify ( l2pcf%anText ) ! for Sun's rubbish compiler
d374 3
@


2.97
log
@Changes to way the destroy stuff is called based on chunks
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.96 2002/11/21 18:38:34 livesey Exp $"
d42 4
a45 5
    use Init_Tables_Module, only: L_CHISQCHAN, &
      & L_CHISQMMAF, L_CHISQMMIF, L_RADIANCE, L_PTAN, &
      & Z_CHUNKDIVIDE,  Z_CONSTRUCT, Z_FILL, &
      & Z_GLOBALSETTINGS, Z_JOIN, Z_MERGEGRIDS, Z_MLSSIGNALS, Z_OUTPUT, &
      & Z_READAPRIORI, Z_RETRIEVE, Z_SPECTROSCOPY
a57 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d61 1
a61 1
      & Signals, SpectrometerTypes, GetSignalIndex
a107 1
    integer ::                                   signal_index
a108 1
    integer ::                                   STATUS ! Flag from HDF5
d373 3
@


2.96
log
@Bug fix in canWriteL2PC flag passed to output_close
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.95 2002/10/08 17:41:50 livesey Exp $"
d263 1
a263 1
            if ( size(chunks) > 1) then
d287 1
a287 1
        if ( size(chunks) == 1) then
d377 3
@


2.95
log
@Various bug fixes associated with FWMParallel
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.94 2002/10/08 17:36:23 pwagner Exp $"
d282 1
a282 1
            & size(chunks)==1 )
d377 3
@


2.94
log
@Added idents to survive zealous Lahey optimizer
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.93 2002/10/05 00:44:29 livesey Exp $"
d165 5
a169 1
        if ( .not. parallel%slave ) then
a182 4
        else
          call GetChunkInfoFromMaster ( chunks, chunkNo )
          firstChunk = chunkNo
          lastChunk = chunkNo
d191 2
a192 1
        if ( size(chunks) < 1 .or. parallel%master .or. &
d194 1
a194 1
          if ( parallel%master ) &
d197 1
d199 1
a199 1
              & chunks, chunkNo ) 
d377 3
@


2.93
log
@Included the FWMParallel stuff
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.92 2002/09/25 20:09:32 livesey Exp $"
d21 1
d368 4
d375 3
@


2.92
log
@Changes to allow chunk based forwardModel configs
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.91 2002/09/24 22:17:50 pwagner Exp $"
d30 1
a30 1
    use Construct, only: MLSL2Construct, MLSL2DeConstruct
d48 1
d137 2
d141 2
d160 3
a164 2
          ! This is the old routine, which will be going away shortly
          ! call ScanAndDivide ( son, processingRange, l1bInfo, chunks )
d185 2
d188 4
a191 2
        ! In case where there are no chunks or we're a master do special stuff
        if ( parallel%master .or. size(chunks) < 1 ) then 
d194 6
d210 1
d212 2
a213 1
          do chunkNo = firstChunk, lastChunk
d219 2
a251 14
            !if ( .not. (toggle(gen) .and. levels(gen) > 0 ) .and. &
            !  & index(switches,'chi') /= 0 ) then
              ! Dumps every chunk
              
              !call output('Here is a minor frame example', advance='yes')
              !call dump_vectors( vectors, details=1, &
              !& quantityTypes = (/l_Ptan/) )
              !call GetSignalIndex('R2:190.B3F:N2O', signal_index)
              !call output('Here is one that is not minor frame', advance='yes')
              !call output('R2:190.B3F:N2O index: ', advance='no')
              !call output(signal_index, advance='yes')
              !call dump_vectors( vectors, details=1, &
              !& quantityTypes = (/l_radiance/), signal_ids = (/signal_index/), &
              !& thenditchafterdump=.true. )
d257 1
d271 2
a272 1
          end do ! on chunkNo
d275 1
d316 2
d370 3
@


2.91
log
@Defines t1 before call to add_to_section_timing
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.90 2002/09/24 18:18:47 pwagner Exp $"
d36 2
a37 1
    use ForwardModelConfig, only: ForwardModelConfig_T, DestroyFWMConfigDatabase
d208 2
a209 1
                  & fGrids, vGrids, hGrids, l2gpDatabase, mifGeolocation )
d263 1
d359 3
@


2.90
log
@Consistent with add_to_section_timing now calling time_now at its end
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.89 2002/08/28 22:29:19 pwagner Exp $"
d130 1
d356 3
@


2.89
log
@Moved DestroyL1BInfo to after end of loop of chunks
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d17 1
a17 1
       "$Id: tree_walker.f90,v 2.88 2002/08/22 01:26:00 vsnyder Exp $"
a129 1
    call time_now ( t1 )
a135 1
      call time_now ( t1 )
a200 1
              call time_now ( t1 )
d355 3
@


2.88
log
@Cosmetic changes
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.87 2002/08/21 19:05:04 livesey Exp $"
a282 1
        call DestroyL1BInfo ( l1bInfo )
d322 1
d358 3
@


2.87
log
@Removed calls to H5Open/close as they are now done in MLSL2.
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.86 2002/08/21 00:55:35 livesey Exp $"
d25 2
a26 2
  subroutine WALK_TREE_TO_DO_MLS_L2 ( ROOT, ERROR_FLAG, FIRST_SECTION, COUNTCHUNKS, &
    & SINGLECHUNK )
d29 1
d33 1
a34 1
    use FGrid, only: FGrid_T, DestroyFGridDatabase
d48 1
a49 1
    use L2Parallel, only: GETCHUNKINFOFROMMASTER, L2MASTERTASK
d63 1
a64 1
    use OutputAndClose, only: Output_Close
a68 1
    use ChunkDivide_m, only: ChunkDivide, DestroyChunkDatabase
d358 3
@


2.86
log
@Changed error to warning when fail to close hdf5 (at least for the
moment).
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.85 2002/08/20 22:10:50 vsnyder Exp $"
a124 5
    ! Open hdf5 (believe it or not there is no interface for this routine!)
    call H5Open_F ( status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to open HDF5' )

a325 5
    ! Close hdf5 (believe it or not there is no interface for this routine!)
    call H5Close_F ( status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & 'Unable to close HDF5' )

d358 4
@


2.85
log
@Move USE statements from module scope to procedure scope
@
text
@d17 1
a17 1
       "$Id: tree_walker.f90,v 2.84 2002/08/07 00:05:27 livesey Exp $"
d55 1
a55 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d333 1
a333 1
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d368 3
@


2.84
log
@Added calls to H5Open_F and H5Close_F
@
text
@a8 52
  use AntennaPatterns_m, only: Destroy_Ant_Patterns_Database
  use Construct, only: MLSL2Construct, MLSL2DeConstruct
  use Dumper, only: Dump
  use EmpiricalGeometry, only: ForgetOptimumLon0
  use Fill, only: MLSL2Fill
  use FGrid, only: FGrid_T, DestroyFGridDatabase
  use FilterShapes_m, only: Destroy_Filter_Shapes_Database
  use ForwardModelConfig, only: ForwardModelConfig_T, DestroyFWMConfigDatabase
  use Global_Settings, only: Set_Global_Settings
  use GriddedData, only: GriddedData_T, DestroyGriddedDataDatabase, Dump
  use HGrid, only: HGrid_T
  use Init_Tables_Module, only: L_CHISQCHAN, &
    & L_CHISQMMAF, L_CHISQMMIF, L_RADIANCE, L_PTAN, &
    & Z_CHUNKDIVIDE,  Z_CONSTRUCT, Z_FILL, &
    & Z_GLOBALSETTINGS, Z_JOIN, Z_MERGEGRIDS, Z_MLSSIGNALS, Z_OUTPUT, &
    & Z_READAPRIORI, Z_RETRIEVE, Z_SPECTROSCOPY
  use JOIN, only: MLSL2Join
  use L2AUXData, only: DestroyL2AUXDatabase, L2AUXData_T, Dump
  use L2GPData, only: DestroyL2GPDatabase, L2GPData_T, Dump
  use L2ParInfo, only: PARALLEL, CLOSEPARALLEL
  use L2Parallel, only: GETCHUNKINFOFROMMASTER, L2MASTERTASK
  use L2PC_m, only: DestroyL2PCDatabase, DestroyBinSelectorDatabase
  use MACHINE, only: MLS_GC_NOW, MLS_HOWMANY_GC
  use MatrixModule_1, only: DestroyMatrixDatabase, Matrix_Database_T
  use MergeGridsModule, only: MergeGrids
  use MLSCommon, only: L1BINFO_T, MLSCHUNK_T, TAI93_RANGE_T
  use MLSL2Options, only: GARBAGE_COLLECTION_BY_CHUNK
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
  use MLSSignals_M, only: Bands, DestroyBandDatabase, DestroyModuleDatabase, &
    & DestroyRadiometerDatabase, DestroySignalDatabase, &
    & DestroySpectrometerTypeDatabase, MLSSignals, Modules, Radiometers, &
    & Signals, SpectrometerTypes, GetSignalIndex
  use MLSL2Timings, only: add_to_section_timing, TOTAL_TIMES
  use Open_Init, only: DestroyL1BInfo, OpenAndInitialize
  use Output_m, only: BLANKS, Output
  use OutputAndClose, only: Output_Close
  use PointingGrid_m, only: Destroy_Pointing_Grid_Database
  use QuantityTemplates, only: QuantityTemplate_T
  use ReadAPriori, only: read_apriori
  use RetrievalModule, only: Retrieve
  use ChunkDivide_m, only: ChunkDivide, DestroyChunkDatabase
  use SpectroscopyCatalog_m, only: Destroy_Line_Database, &
    & Destroy_SpectCat_Database, Spectroscopy
  use Test_Parse_Signals_m, only: Test_Parse_Signals
  use Time_M, only: Time_Now
  use Toggles, only: GEN, LEVELS, SWITCHES, TOGGLE
  use Trace_m, only: DEPTH, TRACE_BEGIN, TRACE_END
  use Tree, only: DECORATION, NSONS, SUBTREE
  use VectorsModule, only: DestroyVectorDatabase, DUMP_VECTORS, &
    & Vector_T, VectorTemplate_T
  use VGridsDatabase, only: DestroyVGridDatabase, VGrid_T
  use WriteMetadata, only: PCFData_T
d17 1
a17 1
       "$Id: tree_walker.f90,v 2.83 2002/08/04 16:10:43 mjf Exp $"
d27 54
d95 1
a95 1
      & pointer ::                               GriddedData
d121 1
a121 1
    nullify ( chunks, forwardModelConfigDatabase, griddedData, &
d156 1
a156 1
        call read_apriori ( son , l2gpDatabase, l2auxDatabase, griddedData)
d159 1
a159 1
        call mergeGrids ( son, griddedData )
d171 1
a171 1
          endif
d181 1
a181 1
        endif
d205 1
a205 1
            endif
d217 3
a219 3
                call MLSL2Fill ( son, l1bInfo, griddedData, vectorTemplates, &
                  & vectors, qtyTemplates, matrices, vGrids, l2gpDatabase , &
                  & l2auxDatabase, chunks, chunkNo)
d255 1
a255 1
            endif
d275 1
a275 1
        endif
d290 4
a293 4
         & .and. associated(griddedData) ) then
          call Dump(griddedData)
        endif
        call DestroyGriddedDataDatabase ( griddedData )
d299 1
a299 1
        endif
d303 1
a303 1
        endif
d344 1
a344 1
      endif
d355 1
a355 1
      endif
d368 3
@


2.83
log
@Added some nullify statements for Sun's rubbish compiler.
@
text
@d36 1
d69 1
a69 1
       "$Id: tree_walker.f90,v 2.82 2002/03/20 00:49:44 pwagner Exp $"
d107 1
d123 5
d329 5
d366 3
@


2.82
log
@chi1 dumps only 1st chunk, unlike chi
@
text
@d68 1
a68 1
       "$Id: tree_walker.f90,v 2.81 2002/02/05 00:44:03 pwagner Exp $"
d121 1
d354 3
@


2.81
log
@Added garbage collection stuff
@
text
@d68 1
a68 1
       "$Id: tree_walker.f90,v 2.80 2002/01/24 00:58:28 livesey Exp $"
d224 19
a242 13
            if ( .not. (toggle(gen) .and. levels(gen) > 0 ) .and. &
              & index(switches,'chi') /= 0 ) then
              call output('Here is a minor frame example', advance='yes')
              call dump_vectors( vectors, details=1, &
              & quantityTypes = (/l_Ptan/) )
              call GetSignalIndex('R2:190.B3F:N2O', signal_index)
              call output('Here is one that is not minor frame', advance='yes')
              call output('R2:190.B3F:N2O index: ', advance='no')
              call output(signal_index, advance='yes')
              call dump_vectors( vectors, details=1, &
              & quantityTypes = (/l_radiance/), signal_ids = (/signal_index/), &
              & thenditchafterdump=.true. )
              call output('Here are our diagnostics', advance='yes')
d353 3
@


2.80
log
@Now calls MergeGrids at the appropriate time
@
text
@d31 1
d35 1
d40 1
a40 1
  use MLSL2Timings, only: add_to_section_timing
d42 1
a42 1
  use Output_m, only: Output
d68 1
a68 1
       "$Id: tree_walker.f90,v 2.79 2002/01/22 18:14:47 livesey Exp $"
d106 3
a108 1
    real    ::                                   t1
d122 1
d247 3
d314 28
d343 1
d347 3
@


2.79
log
@Fixed typo
@
text
@d23 1
a23 1
    & Z_GLOBALSETTINGS, Z_JOIN, Z_MERGEAPRIORI, Z_MLSSIGNALS, Z_OUTPUT, &
d32 1
d66 1
a66 1
       "$Id: tree_walker.f90,v 2.78 2002/01/21 23:11:06 livesey Exp $"
d143 2
a144 2
      case ( z_mergeapriori )
        ! Merge apriori here
d310 3
@


2.78
log
@Added call to DestroyBinSelectorsDatabase etc.
@
text
@d30 1
a30 1
  use L2PC_m, only: DestroyL2PCDatabase, DestroyBinSelectorsDatabase
d65 1
a65 1
       "$Id: tree_walker.f90,v 2.77 2002/01/18 18:55:37 livesey Exp $"
d309 3
@


2.77
log
@Code to support the --chunk option
@
text
@d30 1
a30 1
  use L2PC_m, only: DestroyL2PCDatabase
d65 1
a65 1
       "$Id: tree_walker.f90,v 2.76 2002/01/09 22:56:17 livesey Exp $"
d289 1
d309 3
@


2.76
log
@Now sends slaves all chunks as regular HGrids need them.
@
text
@d65 1
a65 1
       "$Id: tree_walker.f90,v 2.75 2001/12/16 00:57:12 livesey Exp $"
d73 2
a74 1
  subroutine WALK_TREE_TO_DO_MLS_L2 ( ROOT, ERROR_FLAG, FIRST_SECTION, COUNTCHUNKS )
d79 1
d149 7
a155 2
          firstChunk = 1
          lastChunk = size(chunks)
d308 3
@


2.75
log
@Now passes all chunks to construct
@
text
@d29 1
a29 1
  use L2Parallel, only: GETCHUNKFROMMASTER, L2MASTERTASK
d65 1
a65 1
       "$Id: tree_walker.f90,v 2.74 2001/12/14 01:43:20 livesey Exp $"
d83 1
d91 1
d147 2
d155 3
a157 1
          call GetChunkFromMaster ( chunks )
d163 1
a163 2
        if ( parallel%master .or. &
          & lbound(chunks,1) > ubound(chunks,1) ) then 
d177 1
a177 1
          do chunkNo = lbound(chunks,1), ubound(chunks,1)
d301 3
@


2.74
log
@Passes processingRange to HGrid via Construct
@
text
@d65 1
a65 1
       "$Id: tree_walker.f90,v 2.73 2001/12/13 23:21:26 livesey Exp $"
d185 1
a185 1
                  & chunks(chunkNo), qtyTemplates, vectorTemplates, &
d296 3
@


2.73
log
@Added countChunks option
@
text
@d65 1
a65 1
       "$Id: tree_walker.f90,v 2.72 2001/12/10 20:22:09 livesey Exp $"
d184 3
a186 3
                call MLSL2Construct ( son, l1bInfo, chunks(chunkNo), &
                  & qtyTemplates, vectorTemplates, fGrids, vGrids, hGrids, &
                  & l2gpDatabase, mifGeolocation )
d296 3
@


2.72
log
@Added code for EmpiricalGeometry.
@
text
@d65 1
a65 1
       "$Id: tree_walker.f90,v 2.71 2001/11/20 00:48:15 livesey Exp $"
d73 1
a73 1
  subroutine WALK_TREE_TO_DO_MLS_L2 ( ROOT, ERROR_FLAG, FIRST_SECTION )
d77 1
d145 5
d296 3
@


2.71
log
@Fixed problem when no chunks to process
@
text
@d12 1
d65 1
a65 1
       "$Id: tree_walker.f90,v 2.70 2001/11/16 17:24:13 livesey Exp $"
d224 1
d290 3
@


2.70
log
@Now calls new ChunkDivide routine.
@
text
@d64 1
a64 1
       "$Id: tree_walker.f90,v 2.69 2001/11/09 23:17:22 vsnyder Exp $"
d149 15
a163 12
        if ( parallel%master ) then 
          call L2MasterTask ( chunks, l2gpDatabase, l2auxDatabase )
            select case ( decoration(subtree(1,son)) ) ! section index
            case ( z_construct )
              call add_to_section_timing ( 'construct', t1)
            case ( z_fill )
              call add_to_section_timing ( 'fill', t1)
            case ( z_join )
              call add_to_section_timing ( 'join', t1)
            case ( z_retrieve )
              call add_to_section_timing ( 'retrieve', t1)
            end select
d288 3
@


2.69
log
@Use Time_Now instead of CPU_TIME
@
text
@d44 1
a44 1
  use ScanDivide, only: DestroyChunkDatabase, ScanAndDivide
d64 1
a64 1
       "$Id: tree_walker.f90,v 2.68 2001/10/31 19:07:52 livesey Exp $"
d140 3
a142 1
          call ScanAndDivide ( son, processingRange, l1bInfo, chunks )
d285 3
@


2.68
log
@Hooked fGrids into quantity templates
@
text
@d48 1
d64 1
a64 1
       "$Id: tree_walker.f90,v 2.67 2001/10/31 18:36:58 livesey Exp $"
d113 1
a113 1
    call cpu_time ( t1 )
d120 1
a120 1
      call cpu_time ( t1 )
d168 1
a168 1
              call cpu_time ( t1 )
d283 3
@


2.67
log
@Added fGrids stuff
@
text
@d63 1
a63 1
       "$Id: tree_walker.f90,v 2.66 2001/10/26 23:16:15 pwagner Exp $"
d107 1
a107 1
      & qtyTemplates, vectors, vectorTemplates, vGrids )
d122 1
a122 1
        call set_global_settings ( son, forwardModelConfigDatabase, vGrids, &
d172 1
a172 1
                  & qtyTemplates, vectorTemplates, vGrids, hGrids, &
d282 3
@


2.66
log
@Similar dump interfaces for l2gp, l2aux, Griddeddata databases
@
text
@d13 1
d63 1
a63 1
       "$Id: tree_walker.f90,v 2.65 2001/10/12 23:14:22 pwagner Exp $"
d78 1
d275 1
d282 3
@


2.65
log
@Debugging when dumping diagnostics; may remove later
@
text
@d16 1
a16 1
  use GriddedData, only: GriddedData_T, DestroyGriddedDataDatabase
d24 2
a25 2
  use L2AUXData, only: DestroyL2AUXDatabase, L2AUXData_T, Dump_L2AUX
  use L2GPData, only: DestroyL2GPDatabase, L2GPData_T, Dump_L2GP
d62 1
a62 1
       "$Id: tree_walker.f90,v 2.64 2001/10/09 23:43:42 pwagner Exp $"
d236 4
d243 1
a243 1
          call Dump_L2GP(l2gpDatabase)
d245 1
a245 1
          call Dump_L2GP(l2gpDatabase, ColumnsOnly=.true.)
d249 1
a249 1
          call Dump_L2AUX(l2auxDatabase)
d279 3
@


2.64
log
@Some further improvements in dumping vectors
@
text
@d19 1
a19 1
    & L_CHISQMMAF, L_CHISQMMIF, L_REFGPH, L_PTAN, &
d34 1
a34 1
    & Signals, SpectrometerTypes
d62 1
a62 1
       "$Id: tree_walker.f90,v 2.63 2001/10/02 16:49:56 livesey Exp $"
d92 2
a93 1
    integer ::                                   SON                      ! Son of Root
d196 1
d198 2
d201 3
a203 1
              & quantityTypes = (/l_refgph/) )
d275 3
@


2.63
log
@Removed fmStat%finished and change loop ordering in forward models
@
text
@d19 2
a20 1
    & L_CHISQMMAF, L_CHISQMMIF, Z_CHUNKDIVIDE,  Z_CONSTRUCT, Z_FILL, &
d62 1
a62 1
       "$Id: tree_walker.f90,v 2.62 2001/09/29 00:01:00 pwagner Exp $"
d191 8
a198 2
              & index(switches,'chi') /= 0 ) &
              & call dump_vectors( vectors, details=1, &
d200 1
d269 3
@


2.62
log
@Fixed various timing problems
@
text
@d61 1
a61 1
       "$Id: tree_walker.f90,v 2.61 2001/09/28 17:50:30 pwagner Exp $"
d181 2
a182 1
                call retrieve ( son, vectors, matrices, forwardModelConfigDatabase)
d261 3
@


2.61
log
@MLSL2Timings module keeps timing info
@
text
@d61 1
a61 1
       "$Id: tree_walker.f90,v 2.60 2001/09/21 17:40:57 pwagner Exp $"
d163 1
d260 3
@


2.60
log
@May dump diagnostic quantities chi..
@
text
@d34 1
d61 1
a61 1
       "$Id: tree_walker.f90,v 2.59 2001/09/10 23:37:32 livesey Exp $"
d70 3
a72 3
    integer, intent(in) :: ROOT         ! Root of the abstract syntax tree
    integer, intent(out) :: ERROR_FLAG  ! Nonzero means failure
    integer, intent(in) :: FIRST_SECTION! Index of son of root of first n_cf
d74 1
a74 1
    integer :: chunkNo                  ! Index of Chunks
d78 7
a84 6
      & pointer :: ForwardModelConfigDatabase
    type (GriddedData_T), dimension(:), pointer :: GriddedData
    type (HGrid_T), dimension(:), pointer :: HGrids
    integer :: HOWMANY                  ! Nsons(Root)
    integer :: I, J                     ! Loop inductors
    type (L1BInfo_T) :: L1BInfo         ! File handles etc. for L1B dataset
d87 8
a94 6
    type (PCFData_T) :: L2pcf
    type (Matrix_Database_T), dimension(:), pointer :: Matrices
    type (TAI93_Range_T) :: ProcessingRange  ! Data processing range
    integer :: SON                      ! Son of Root
    type (Vector_T), dimension(:), pointer :: Vectors
    type (VGrid_T), dimension(:), pointer :: VGrids
d108 1
d110 1
a110 1

d115 1
d120 1
d124 1
d127 1
d129 2
a130 1
      	call read_apriori ( son , l2gpDatabase, l2auxDatabase, griddedData)
d140 1
d144 10
d169 1
d174 1
d178 1
d181 1
d203 4
a206 3
        if ( .not. parallel%slave ) &
          & call Output_Close ( son, l2gpDatabase, l2auxDatabase, matrices, l2pcf,&
          & size(chunks)==1 )
d234 1
d259 3
@


2.59
log
@New GriddedData etc.
@
text
@d18 2
a19 1
  use Init_Tables_Module, only: Z_CHUNKDIVIDE,  Z_CONSTRUCT, Z_FILL, &
d48 2
a49 1
  use VectorsModule, only: DestroyVectorDatabase, Vector_T, VectorTemplate_T
d60 1
a60 1
       "$Id: tree_walker.f90,v 2.58 2001/08/06 18:34:59 pwagner Exp $"
d162 4
d232 3
@


2.58
log
@Now dumps l2gp and l2aux databases when asked
@
text
@d16 1
a16 1
  use GriddedData, only: GriddedData_T
a32 1
  use NCEP_DAO, only: DestroyGridTemplateDatabase
d58 1
a58 1
       "$Id: tree_walker.f90,v 2.57 2001/07/11 21:40:21 livesey Exp $"
d188 1
a188 1
        call DestroyGridTemplateDatabase ( griddedData )
d226 3
@


2.57
log
@Added -Schu option
@
text
@d22 2
a23 2
  use L2AUXData, only: DestroyL2AUXDatabase, L2AUXData_T
  use L2GPData, only: DestroyL2GPDatabase, L2GPData_T
d59 1
a59 1
       "$Id: tree_walker.f90,v 2.56 2001/06/13 20:44:08 livesey Exp $"
d191 5
d197 3
d227 3
@


2.56
log
@Moved the CloseParallel higher up, to work around the memory management
problem (somethine [HDF?] seems to stamp on PointingFrequencyDatabase)
@
text
@d35 1
d59 1
a59 1
       "$Id: tree_walker.f90,v 2.55 2001/06/07 21:58:28 pwagner Exp $"
d134 5
d219 4
@


2.55
log
@Added Copyright statement
@
text
@d58 1
a58 1
       "$Id: tree_walker.f90,v 2.54 2001/05/23 22:00:16 livesey Exp $"
d193 1
a206 1
    call CloseParallel
d213 3
@


2.54
log
@Interim version
@
text
@d1 3
d58 1
a58 1
       "$Id: tree_walker.f90,v 2.53 2001/05/23 01:44:35 livesey Exp $"
d213 3
@


2.53
log
@Parallel stuff taking shape
@
text
@d21 2
a22 2
  use L2Parallel, only: PARALLEL, GETCHUNKFROMMASTER, L2MASTERTASK, &
    & CLOSEPARALLEL
d55 1
a55 1
       "$Id: tree_walker.f90,v 2.52 2001/05/10 00:43:23 livesey Exp $"
d210 3
@


2.52
log
@Tree walker now owns hGrids
@
text
@d21 2
a22 1
  use L2Parallel, only: PARALLEL, INITPARALLEL, GETCHUNKFROMMASTER
d55 1
a55 1
       "$Id: tree_walker.f90,v 2.51 2001/05/04 17:12:25 pwagner Exp $"
d80 1
a80 1
    type(PCFData_T) :: L2pcf
a95 2
    call InitParallel

d126 37
a162 33
        do chunkNo = lbound(chunks,1), ubound(chunks,1)
          j = i
subtrees: do while ( j <= howmany )
            son = subtree(j,root)
            select case ( decoration(subtree(1,son)) ) ! section index
            case ( z_construct )
              call MLSL2Construct ( son, l1bInfo, chunks(chunkNo), &
                & qtyTemplates, vectorTemplates, vGrids, hGrids, &
                & l2gpDatabase, mifGeolocation )
            case ( z_fill )
              call MLSL2Fill ( son, l1bInfo, griddedData, vectorTemplates, &
                & vectors, qtyTemplates, matrices, vGrids, l2gpDatabase , &
                & l2auxDatabase, chunks, chunkNo)
            case ( z_join )
              call MLSL2Join ( son, vectors, l2gpDatabase, &
                & l2auxDatabase, chunkNo, chunks )
            case ( z_retrieve )
              call retrieve ( son, vectors, matrices, forwardModelConfigDatabase)
            case default
          exit subtrees
            end select
            j = j + 1
          end do subtrees
          ! Now, if we're dealing with more than one chunk destroy stuff
          ! Otherwise, we'll save them as we may need to output them as l2pc files.
          if ( size(chunks) > 1) then
            call MLSL2DeConstruct ( qtyTemplates, vectorTemplates, &
              & mifGeolocation, hGrids )
            call DestroyVectorDatabase ( vectors )
            call DestroyMatrixDatabase ( matrices )
          end if
        end do ! on chunkNo
        i = j - 1 ! one gets added back in at the end of the outer loop
d164 2
a165 1
        call Output_Close ( son, l2gpDatabase, l2auxDatabase, matrices, l2pcf,&
d203 1
d210 3
@


2.51
log
@Passes necessary args to global_settings
@
text
@d14 1
d54 1
a54 1
       "$Id: tree_walker.f90,v 2.50 2001/05/03 20:34:08 vsnyder Exp $"
d73 1
d92 1
a92 1
      & l2auxDatabase, l2gpDatabase, matrices, mifGeolocation, &
d134 2
a135 1
                & qtyTemplates, vectorTemplates, vGrids, l2gpDatabase, mifGeolocation )
d154 1
a154 1
              & mifGeolocation )
d168 1
a168 1
            & mifGeolocation )
d205 3
@


2.50
log
@Cosmetic changes
@
text
@d53 1
a53 1
       "$Id: tree_walker.f90,v 2.49 2001/05/02 23:23:00 livesey Exp $"
d107 1
a107 1
          & l2gpDatabase )
d202 3
@


2.49
log
@Added some of the parallel stuff
@
text
@d53 1
a53 1
       "$Id: tree_walker.f90,v 2.48 2001/04/28 01:31:46 livesey Exp $"
a65 1
    type (GriddedData_T), dimension(:), pointer :: GriddedData
d68 4
d75 3
a77 2
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase
    type (L2GPData_T), dimension(:), pointer  :: l2gpDatabase
a78 1
	 type(PCFData_T) :: l2pcf
a83 4
    ! Forward model configurations
    type (ForwardModelConfig_T), dimension(:), &
      & pointer :: ForwardModelConfigDatabase

d85 7
a91 7
    type (QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
    type (QuantityTemplate_T), dimension(:), pointer :: mifGeolocation
    type (VectorTemplate_T), dimension(:), pointer :: vectorTemplates

    nullify ( griddedData, chunks, l2auxDatabase, l2gpDatabase, &
      & matrices, vectors, vGrids, forwardModelConfigDatabase, qtyTemplates, &
      & mifGeolocation, vectorTemplates )
d202 3
@


2.48
log
@Changes for new l2pc / matrix handling.
@
text
@d20 1
d53 1
a53 1
       "$Id: tree_walker.f90,v 2.47 2001/04/26 20:02:09 livesey Exp $"
d94 2
d119 5
a123 1
        call ScanAndDivide ( son, processingRange, l1bInfo, chunks )
d126 1
a126 1
        do chunkNo = 1, size(chunks)
d203 3
@


2.47
log
@Made l2pc database a saved array in L2PC_m
@
text
@d52 1
a52 1
       "$Id: tree_walker.f90,v 2.46 2001/04/26 02:44:17 vsnyder Exp $"
d132 2
a133 2
              call MLSL2Join ( son, vectors, matrices, l2gpDatabase, &
                & l2auxDatabase, size(chunks)==1, chunkNo, chunks )
d152 1
a152 1
        call Output_Close ( son, l2gpDatabase, l2auxDatabase, l2pcf,&
d196 3
@


2.46
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d20 1
a20 1
  use L2PC_m, only: L2PC_T, DestroyL2PCDatabase
d52 1
a52 1
       "$Id: $"
d55 1
a55 1
       "$RCSfile: $"
a74 1
    type(L2PC_T), dimension(:), pointer :: l2pcDatabase
d89 1
a89 1
    nullify ( griddedData, chunks, l2auxDatabase, l2gpDatabase, l2pcDatabase, &
d105 1
a105 1
          & l2gpDatabase, l2pcDatabase )
d133 1
a133 1
                & l2auxDatabase, l2pcDatabase, size(chunks)==1, chunkNo, chunks )
d152 1
a152 1
        call Output_Close ( son, l2gpDatabase, l2auxDatabase, l2pcDatabase, l2pcf,&
a170 1
        call DestroyL2PCDatabase ( l2pcDatabase )
d178 1
d196 3
@


2.45
log
@Stuff to support reading of l2pc files
@
text
@d14 3
a16 4
  use Init_Tables_Module, only: Field_Indices, Lit_Indices, &
    & Z_CHUNKDIVIDE,  Z_CONSTRUCT, Z_FILL, Z_GLOBALSETTINGS, Z_JOIN, &
    & Z_MERGEAPRIORI, Z_MLSSIGNALS, Z_OUTPUT, Z_READAPRIORI, Z_RETRIEVE, &
    & Z_SPECTROSCOPY
d50 7
a56 6
!---------------------------- RCS Ident Info ---------------------------
  character (len=256) :: Id = &
       "$Id: tree_walker.f90,v 2.44 2001/04/25 21:54:16 livesey Exp $"
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: tree_walker.f90,v $"
!-----------------------------------------------------------------------
d108 1
a108 1
        call MLSSignals ( son, field_indices )
d111 1
a111 1
        call spectroscopy ( son, lit_indices )
d197 3
@


2.44
log
@Added canDoL2PC flag to join
@
text
@d53 1
a53 1
       "$Id: tree_walker.f90,v 2.43 2001/04/25 21:52:13 livesey Exp $"
d105 2
a106 1
        call set_global_settings ( son, forwardModelConfigDatabase, vGrids, l2gpDatabase )
d197 3
@


2.43
log
@Moved DeConstruct to after output for 1 chunk cases.
This is to protect vectors and matrices stored in l2pcs.
@
text
@d53 1
a53 1
       "$Id: tree_walker.f90,v 2.42 2001/04/25 20:34:36 livesey Exp $"
d133 1
a133 1
                & l2auxDatabase, l2pcDatabase, chunkNo, chunks )
d196 4
@


2.42
log
@Now supports writing of l2pc files
@
text
@d53 1
a53 1
       "$Id: tree_walker.f90,v 2.41 2001/04/25 19:31:13 livesey Exp $"
d141 17
d162 1
a162 4
        end do ! on chunkNo
        i = j - 1 ! one gets added back in at the end of the outer loop
      case ( z_output ) ! Write out the data
        call Output_Close ( son, l2gpDatabase, l2auxDatabase, l2pcDatabase, l2pcf )
d196 3
@


2.41
log
@Fixed bug, now nullifies l2pcDatabase
@
text
@d53 1
a53 1
       "$Id: tree_walker.f90,v 2.40 2001/04/24 23:05:54 vsnyder Exp $"
d148 1
a148 1
        call Output_Close ( son, l2gpDatabase, l2auxDatabase, l2pcf )
d182 3
@


2.40
log
@Make 'test_parse_signals' depend on 'switches' containing 'tps'
@
text
@d53 1
a53 1
       "$Id: tree_walker.f90,v 2.39 2001/04/24 20:20:02 livesey Exp $"
d90 2
a91 2
    nullify ( griddedData, chunks, l2auxDatabase, l2gpDatabase, matrices, &
      & vectors, vGrids, forwardModelConfigDatabase, qtyTemplates, &
d182 3
@


2.39
log
@L2PC moved to lib, and renamed
@
text
@d39 1
a39 1
  use Toggles, only: EMIT, GEN, LEVELS, TOGGLE
d53 1
a53 1
       "$Id: tree_walker.f90,v 2.38 2001/04/24 20:05:50 livesey Exp $"
d108 1
a108 1
        if ( toggle(emit) ) call test_parse_signals
d182 3
@


2.38
log
@New stuff to support joining of l2pc's
@
text
@d21 1
a21 1
  use L2PC_m, only: L2PCBin_T
d53 1
a53 1
       "$Id: tree_walker.f90,v 2.37 2001/04/21 01:41:35 vsnyder Exp $"
d75 1
a75 1
    type(L2PCBin_T), dimension(:), pointer :: l2pcDatabase
d157 1
d182 3
@


2.37
log
@Fix memory leaks
@
text
@d21 1
d53 1
a53 1
       "$Id: tree_walker.f90,v 2.36 2001/04/21 01:26:37 livesey Exp $"
d75 1
d132 2
a133 1
              call MLSL2Join ( son, vectors, l2gpDatabase, l2auxDatabase, chunkNo, chunks )
d181 3
@


2.36
log
@Now passes l2gpDatabase to more people
@
text
@d6 1
a6 1
  use Test_Parse_Signals_m, only: Test_Parse_Signals ! Uncomment to test Parse_Signals
d8 3
a10 2
  use DUMPER, only: DUMP
  use FILL, only: MLSL2Fill
d12 1
a12 1
  use GLOBAL_SETTINGS, only: SET_GLOBAL_SETTINGS
d14 1
a14 1
  use INIT_TABLES_MODULE, only: Field_Indices, Lit_Indices, &
d21 1
a21 1
  use MatrixModule_1, only: Matrix_Database_T
d23 6
a28 4
  use MLSSignals_M, only: MLSSignals
  use ncep_dao, only: DestroyGridTemplateDatabase
  use OPEN_INIT, only: DestroyL1BInfo, OpenAndInitialize
  use ReadAPriori, only: read_apriori
d30 1
d32 1
d35 6
a40 5
  use SpectroscopyCatalog_m, only: Spectroscopy
  use TOGGLES, only: EMIT, GEN, LEVELS, TOGGLE
  use TRACE_M, only: DEPTH, TRACE_BEGIN, TRACE_END
  use TREE, only: DECORATION, NSONS, SUBTREE
  use TREE_TYPES ! Everything, especially everything beginning with N_
d52 1
a52 1
       "$Id: tree_walker.f90,v 2.35 2001/04/20 17:12:38 livesey Exp $"
d141 1
a153 1
        call DestroyFWMConfigDatabase ( forwardModelConfigDatabase )
d160 11
d178 3
@


2.35
log
@Add vGrids argument to fill to support fill from vGrid
@
text
@d46 1
a46 1
       "$Id: tree_walker.f90,v 2.34 2001/04/19 23:51:40 pwagner Exp $"
d97 1
a97 1
        call set_global_settings ( son, forwardModelConfigDatabase, vGrids )
d118 1
a118 1
                & qtyTemplates, vectorTemplates, vGrids, mifGeolocation )
d161 3
@


2.34
log
@Moved anText to become component of PCFData_T
@
text
@d46 1
a46 1
       "$Id: tree_walker.f90,v 2.33 2001/04/11 17:47:47 pwagner Exp $"
d121 1
a121 1
                & vectors, qtyTemplates, matrices, l2gpDatabase , &
d161 3
@


2.33
log
@presets anText to null
@
text
@d46 1
a46 1
       "$Id: tree_walker.f90,v 2.32 2001/04/10 22:27:47 vsnyder Exp $"
a57 1
    CHARACTER (LEN=1), POINTER :: anText(:) => null()
d89 1
a89 1
    call OpenAndInitialize ( processingRange, l1bInfo, l2pcf, anText )
d138 1
a138 1
        call Output_Close ( son, l2gpDatabase, l2auxDatabase, l2pcf, anText )
d161 3
@


2.32
log
@Nullify explicitly instead of with <initialization> so as not to give
pointers the SAVE attribute.  <initialization> is NOT executed on each
entry to a procedure.
@
text
@d13 1
a13 1
  use INIT_TABLES_MODULE, only: Field_Indices, Lit_Indices, Spec_Indices, &
d46 1
a46 1
       "$Id: tree_walker.f90,v 2.31 2001/04/10 02:46:17 livesey Exp $"
d58 1
a58 1
    CHARACTER (LEN=1), POINTER :: anText(:)
d162 5
@


2.31
log
@Working version, no more FMI/TFMI
@
text
@d46 1
a46 1
       "$Id: tree_walker.f90,v 2.30 2001/04/10 00:02:19 vsnyder Exp $"
d59 1
a59 1
    type (GriddedData_T), dimension(:), pointer :: griddedData => NULL() 
d61 1
a61 1
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS => NULL() ! of data
d65 3
a67 3
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase => NULL()
    type (L2GPData_T), dimension(:), pointer  :: l2gpDatabase => NULL()
    type (Matrix_Database_T), dimension(:), pointer :: Matrices => NULL()
d71 2
a72 2
    type (Vector_T), dimension(:), pointer :: Vectors => NULL()
    type (VGrid_T), dimension(:), pointer :: VGrids => NULL()
d76 1
a76 1
      & pointer :: ForwardModelConfigDatabase => NULL()
d79 7
a85 3
    type (QuantityTemplate_T), dimension(:), pointer :: qtyTemplates => NULL()
    type (QuantityTemplate_T), dimension(:), pointer :: mifGeolocation => NULL()
    type (VectorTemplate_T), dimension(:), pointer :: vectorTemplates => NULL()
d162 3
@


2.30
log
@Implement 'matrix' spec in Fill section
@
text
@a17 3
  !??? The next USE statement is Temporary for l2load:
  use L2_TEST_STRUCTURES_M, only: FWD_MDL_CONFIG, FWD_MDL_INFO, &
    & TEMPORARY_FWD_MDL_INFO
d46 1
a46 1
       "$Id: tree_walker.f90,v 2.29 2001/04/07 01:50:49 vsnyder Exp $"
a82 6
!??? Begin temporary stuff to start up the forward model
  type(fwd_mdl_config) :: FMC
  type(fwd_mdl_info), dimension(:), pointer :: FMI => NULL()
  type(temporary_fwd_mdl_info), dimension(:), pointer :: TFMI => NULL()
!??? End of temporary stuff to start up the forward model

d94 1
a94 3
!       call set_global_settings ( son, forwardModelConfigDatabase, vGrids ) !??? Restore when l2load isn't needed
        call set_global_settings ( son, forwardModelConfigDatabase, vGrids, &
          & fmc, fmi, tfmi ) !??? This line is temporary for l2load
d123 1
a123 3
!             call retrieve ( son, vectors, matrices, forwardModelInfo ) !??? Restore when l2load isn't needed
              call retrieve ( son, vectors, matrices, forwardModelConfigDatabase, &
                & fmc, fmi, tfmi ) !??? This line is temporary for l2load
d158 3
@


2.29
log
@Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
some related stuff to fwdmdl/ForwardModelConfig.
@
text
@d49 1
a49 1
       "$Id: tree_walker.f90,v 2.28 2001/04/06 20:12:59 vsnyder Exp $"
d129 2
a130 2
                & vectors, qtyTemplates, l2gpDatabase , l2auxDatabase, &
                & chunks, chunkNo)
d171 4
@


2.28
log
@Make 'call test_parse_signal' depend on 'emit' toggle
@
text
@d10 1
a10 1
  use ForwardModelInterface, only: ForwardModelConfig_T, DestroyFWMConfigDatabase
d39 1
a39 1
  use VGrid, only: DestroyVGridDatabase, VGrid_T
d49 1
a49 1
       "$Id: tree_walker.f90,v 2.27 2001/04/04 02:15:12 vsnyder Exp $"
d171 3
@


2.27
log
@Add Spectroscopy section
@
text
@d6 1
a6 1
! use Test_Parse_Signals_m, only: Test_Parse_Signals ! Uncomment to test Parse_Signals
d34 1
a34 1
  use TOGGLES, only: GEN, LEVELS, TOGGLE
d49 1
a49 1
       "$Id: tree_walker.f90,v 2.26 2001/04/03 20:50:45 pwagner Exp $"
d108 1
a108 1
!       call test_parse_signals  ! Uncomment this to test Parse_Signals
d171 3
@


2.26
log
@Added anText to hold PCF file contents
@
text
@d13 4
a16 3
  use INIT_TABLES_MODULE, only: Field_Indices, Spec_Indices, Z_CHUNKDIVIDE, &
    & Z_CONSTRUCT, Z_FILL, Z_GLOBALSETTINGS, Z_JOIN, Z_MERGEAPRIORI,& 
    & Z_MLSSIGNALS, Z_OUTPUT, Z_READAPRIORI, Z_RETRIEVE
d33 1
d49 1
a49 1
       "$Id: tree_walker.f90,v 2.25 2001/04/02 23:41:09 pwagner Exp $"
d109 2
d112 1
a112 2
        ! Read apriori here
      	CALL read_apriori ( son , l2gpDatabase, l2auxDatabase, griddedData)
d171 3
@


2.25
log
@Now keeps l2pcf and transmits as needed
@
text
@a24 1
!  use OPEN_INIT, only: DestroyL1BInfo, OpenAndInitialize, read_apriori
d47 1
a47 1
       "$Id: tree_walker.f90,v 2.24 2001/03/29 19:13:03 livesey Exp $"
d59 1
d93 1
a93 1
    call OpenAndInitialize ( processingRange, l1bInfo, l2pcf )
d145 1
a145 1
        call Output_Close ( son, l2gpDatabase, l2auxDatabase, l2pcf )
d168 3
@


2.24
log
@Renamed apriorDatabase to griddedData
@
text
@d39 1
d48 1
a48 1
       "$Id: tree_walker.f90,v 2.23 2001/03/28 23:47:48 livesey Exp $"
d69 1
d93 1
a93 1
    call OpenAndInitialize ( processingRange, l1bInfo )
d145 1
a145 1
        call Output_Close ( son, l2gpDatabase, l2auxDatabase )
d168 3
@


2.23
log
@Added arguments to sids etc.
@
text
@d47 1
a47 1
       "$Id: tree_walker.f90,v 2.22 2001/03/28 01:24:55 vsnyder Exp $"
d59 1
a59 1
    type (GriddedData_T), dimension(:), pointer :: aprioriData => NULL() 
d107 1
a107 1
      	CALL read_apriori ( son , l2gpDatabase, l2auxDatabase, aprioriData)
d123 1
a123 1
              call MLSL2Fill ( son, l1bInfo, aprioriData, vectorTemplates, &
d148 1
a148 1
        call DestroyGridTemplateDatabase ( aprioriData )
d166 3
@


2.22
log
@Move vGrid from construct section to global settings section
@
text
@d47 1
a47 1
       "$Id: tree_walker.f90,v 2.21 2001/03/17 03:30:25 vsnyder Exp $"
d101 1
a101 1
          & fmc ) !??? This line is temporary for l2load
d166 3
@


2.21
log
@Remove FMI and TFMI from the call to set_global_settings, since it no
longer uses them.
@
text
@d38 1
d47 1
a47 1
       "$Id: tree_walker.f90,v 2.20 2001/03/17 00:45:53 livesey Exp $"
d71 1
d99 2
a100 2
!       call set_global_settings ( son, forwardModelConfigDatabase ) !??? Restore when l2load isn't needed
        call set_global_settings ( son, forwardModelConfigDatabase, &
d121 1
a121 1
                & qtyTemplates, vectorTemplates, mifGeolocation )
d159 1
d166 4
@


2.20
log
@Added forwardModelConfigDatabase
@
text
@d46 1
a46 1
       "$Id: tree_walker.f90,v 2.19 2001/03/15 23:26:09 livesey Exp $"
d99 1
a99 1
          & fmc, fmi, tfmi ) !??? This line is temporary for l2load
d163 3
@


2.19
log
@Added chunks to call to MLSL2Join
@
text
@d10 1
a10 1
  use ForwardModelInterface, only: ForwardModelInfo_T
d46 1
a46 1
       "$Id: tree_walker.f90,v 2.18 2001/03/15 21:20:54 pwagner Exp $"
a60 1
    type(forwardModelInfo_T) :: FwdModelInfo ! From ForwardModelSetup
d71 4
d97 2
a98 2
!       call set_global_settings ( son, fwdModelInfo ) !??? Restore when l2load isn't needed
        call set_global_settings ( son, fwdModelInfo, &
d127 2
a128 2
!             call retrieve ( son, vectors, matrices, fwdModelInfo ) !??? Restore when l2load isn't needed
              call retrieve ( son, vectors, matrices, fwdModelInfo, &
d148 3
a152 2
        call DestroyL2GPDatabase ( l2gpDatabase )
        call DestroyL2AUXDatabase ( l2auxDatabase )
d163 3
@


2.18
log
@Split between GriddedData and ncep_dao modules
@
text
@d46 1
a46 1
       "$Id: tree_walker.f90,v 2.17 2001/03/15 21:05:23 vsnyder Exp $"
d122 1
a122 1
              call MLSL2Join ( son, vectors, l2gpDatabase, l2auxDatabase, chunkNo )
d159 3
@


2.17
log
@Set up to test Parse_Signal
@
text
@d12 1
a12 1
  use GriddedData, only: DestroyGridTemplateDatabase, GriddedData_T
d26 1
d46 1
a46 1
       "$Id: tree_walker.f90,v 2.16 2001/03/14 02:04:53 vsnyder Exp $"
d159 3
@


2.16
log
@Moved MLSSignals_m to mlspgs/lib
@
text
@d6 1
d45 1
a45 1
       "$Id: tree_walker.f90,v 2.15 2001/03/09 19:57:48 vsnyder Exp $"
d97 2
a98 1
        call MLSSignals ( son, field_indices, spec_indices )
d158 3
@


2.15
log
@Add 'z_retrieve' to a case branch
@
text
@d12 3
a14 3
  use INIT_TABLES_MODULE, only: Z_CHUNKDIVIDE, Z_CONSTRUCT, Z_FILL, &
    & Z_GLOBALSETTINGS, Z_JOIN, Z_MERGEAPRIORI, Z_MLSSIGNALS, Z_OUTPUT, &
    & Z_READAPRIORI, Z_RETRIEVE
d44 1
a44 1
       "$Id: tree_walker.f90,v 2.14 2001/03/08 18:21:11 vsnyder Exp $"
d96 1
a96 1
        call MLSSignals ( son )
d156 3
@


2.14
log
@Even more stuff for L2_Load
@
text
@d44 1
a44 1
       "$Id: tree_walker.f90,v 2.13 2001/03/08 03:23:10 vsnyder Exp $"
d105 1
a105 1
      case ( z_construct, z_fill, z_join )
d156 3
@


2.13
log
@More stuff to work with L2_Load
@
text
@d44 1
a44 1
       "$Id: tree_walker.f90,v 2.12 2001/03/07 22:46:05 vsnyder Exp $"
d93 2
a94 1
        call set_global_settings ( son, fwdModelInfo, fmc, fmi, tfmi ) !??? for l2load
d121 3
a123 2
!             call retrieve ( son, vectors, matrices ) !??? Restore when l2load isn't needed
              call retrieve ( son, vectors, matrices, fmc, fmi, tfmi )
d156 3
@


2.12
log
@Add temporary stuff for Zvi's "l2_load", which will wither away.
@
text
@d9 1
d44 1
a44 1
       "$Id: tree_walker.f90,v 2.11 2001/03/03 00:13:30 pwagner Exp $"
d59 1
d92 2
a93 2
!       call set_global_settings ( son ) !??? Restore when l2load isn't needed
        call set_global_settings ( son, fmc, fmi, tfmi ) !??? for l2load
d154 3
@


2.11
log
@Gets read_apriori from ReadAPriori module
@
text
@d15 3
d43 1
a43 1
       "$Id: tree_walker.f90,v 2.10 2001/02/28 01:17:57 livesey Exp $"
d73 6
d90 2
a91 1
        call set_global_settings ( son )
d118 2
a119 1
              call retrieve ( son, vectors, matrices )
d152 3
@


2.10
log
@Removed obtain_ncep etc. These will later be in lower down modules
@
text
@d20 3
a22 1
  use OPEN_INIT, only: DestroyL1BInfo, OpenAndInitialize, read_apriori
d40 1
a40 1
       "$Id: tree_walker.f90,v 2.9 2001/02/27 17:38:07 livesey Exp $"
d86 1
a86 1
      	CALL read_apriori ( son , l2gpDatabase, l2auxDatabase)
d141 3
@


2.9
log
@Tidied up arguments to MLSL2Join
@
text
@a19 3
  use ObtainClimatology, only: OBTAIN_CLIM
  use ObtainDAO, only: OBTAIN_DAO
  use ObtainNCEP, only: OBTAIN_NCEP
d38 1
a38 1
       "$Id: tree_walker.f90,v 2.8 2001/02/23 02:51:44 vsnyder Exp $"
a71 5
    ! For now, the next three are simply done.  Eventually, they should be
    ! triggered by a command
    call Obtain_NCEP ( aprioriData, root )
    call Obtain_DAO ( aprioriData, root )
    call Obtain_Clim ( aprioriData, root )
d139 3
@


2.8
log
@Improve progress messages triggered by -g option
@
text
@d41 1
a41 1
       "$Id: tree_walker.f90,v 2.7 2001/02/08 01:40:53 vsnyder Exp $"
d112 1
a112 2
              call MLSL2Join ( son, vectors, l2gpDatabase, l2auxDatabase, &
                & qtyTemplates, chunks, chunkNo )
d147 3
@


2.7
log
@Don't know what I have done, but "cvs update" said M instead of U
@
text
@d41 1
a41 1
       "$Id: tree_walker.f90,v 2.6 2001/01/03 17:48:43 pwagner Exp $"
d72 2
a73 1
    if ( toggle(gen) ) call trace_begin ( 'WALK_TREE_TO_DO_MLS_L2', root )
d148 3
@


2.6
log
@added chunk args to call to Fill
@
text
@d12 2
a13 1
    & Z_GLOBALSETTINGS, Z_JOIN, Z_MERGEAPRIORI, Z_OUTPUT, Z_READAPRIORI
d17 1
d19 1
d26 1
d41 1
a41 1
       "$Id: tree_walker.f90,v 2.5 2000/12/05 00:41:50 pwagner Exp $"
d59 3
a61 2
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase
    type (L2GPData_T), dimension(:), pointer  :: l2gpDatabase
d87 2
d113 2
a114 1
!           case ( z_retrieve )
d147 3
@


2.5
log
@Added L2AUXDatabase arg in call to MLSL2Fill
@
text
@d37 1
a37 1
       "$Id: tree_walker.f90,v 2.4 2000/11/30 00:21:08 pwagner Exp $"
d101 2
a102 1
                & vectors, qtyTemplates, l2gpDatabase , l2auxDatabase)
d139 3
@


2.4
log
@passes l2*databses to read a priori
@
text
@d37 1
a37 1
       "$Id: tree_walker.f90,v 2.3 2000/11/29 00:27:54 pwagner Exp $"
d101 1
a101 1
                & vectors, qtyTemplates, l2gpDatabase )
d138 3
@


2.3
log
@Began changes to open old l2gp
@
text
@d37 1
a37 1
       "$Id: tree_walker.f90,v 2.2 2000/10/10 00:37:46 vsnyder Exp $"
d84 1
a84 1
      	CALL read_apriori ( son )
d138 3
@


2.2
log
@Added $Log for CVS at end.
@
text
@d20 1
a20 1
  use OPEN_INIT, only: DestroyL1BInfo, OpenAndInitialize
d37 1
a37 1
       "$Id: tree_walker.f90,v 2.1 2000/10/10 00:27:09 vsnyder Exp $"
d84 1
d137 4
a140 1
! $Log: $
@


2.1
log
@Add new argument "l2gpdataBase" in call to MLSL2fill
@
text
@d37 1
a37 1
       "$Id: tree_walker.f90,v 2.0 2000/09/05 18:57:06 ahanzel Exp $"
d135 2
@


2.0
log
@Changing file revision to 2.0.
@
text
@d37 1
a37 1
       "$Id: tree_walker.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
d100 1
a100 1
                & vectors, qtyTemplates )
@


1.1
log
@Initial entry
@
text
@d37 1
a37 1
       "$Id: tree_walker.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
@


