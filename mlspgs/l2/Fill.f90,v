head	2.488;
access;
symbols
	v5-02-NRT-19:2.488
	v6-00:2.487
	v5-02-NRT-18:2.487
	v5-02:2.481
	v5-01-NRT-17:2.485
	v5-01-NRT-16:2.485
	v5-01-NRT-15:2.485
	v5-01-NRT-14:2.485
	neuralnetworks-1-0:2.485.0.4
	cfm-single-freq-0-1:2.485.0.2
	v5-01:2.481
	v5-00:2.481
	v4-23-TA133:2.481.0.2
	mus-emls-1-70:2.477.0.2
	rel-1-0-englocks-work:2.474.0.2
	VUMLS1-00:2.464
	VPL1-00:2.461
	V4-22-NRT-08:2.460
	VAM1-00:2.456
	V4-21:2.447.0.2
	V4-13:2.445
	V4-12:2.442
	V4-11:2.442
	V4-10:2.441
	V3-43:2.376
	M4-00:2.416
	V3-41:2.376
	V3-40-PlusGM57:2.376.0.2
	V2-24-NRT-04:2.356
	V3-33:2.389
	V2-24:2.356
	V3-31:2.389
	V3-30-NRT-05:2.388
	cfm-01-00:2.384
	V3-30:2.376
	V3-20:2.376
	V3-10:2.374
	V2-23-NRT-02:2.356
	V2-23:2.356
	V2-22-NRT-01:2.356
	V2-22:2.356
	V2-21:2.349
	V2-20:2.348
	V2-11:2.341
	V2-10:2.341
	V2-00:2.336
	V1-51:2.297
	V1-50:2.297
	V1-45:2.280
	V1-44:2.278
	V1-43:2.270
	V1-32:2.248
	V1-31:2.248
	V1-30:2.240
	V1-13:2.190
	V1-12:2.190
	V1-11:2.189
	V1-10:2.181
	newfwm-feb03:2.181.0.2
	V1-04:2.121
	V1-03:2.121
	V1-02:2.121
	JointForwardModel:2.131.0.2
	V1-00:2.115
	newfwm-sep01:2.70.0.2
	V0-7:2.70
	V0-5-Level2:2.45
	V0-5-SIPS:2.38
	V0_1:1.1;
locks; strict;
comment	@# @;


2.488
date	2024.07.02.22.09.35;	author pwagner;	state Exp;
branches;
next	2.487;

2.487
date	2023.12.07.23.07.20;	author pwagner;	state Exp;
branches;
next	2.486;

2.486
date	2023.10.19.20.38.53;	author pwagner;	state Exp;
branches;
next	2.485;

2.485
date	2020.07.29.23.36.19;	author pwagner;	state Exp;
branches;
next	2.484;

2.484
date	2020.07.22.23.00.17;	author pwagner;	state Exp;
branches;
next	2.483;

2.483
date	2020.07.09.23.55.06;	author pwagner;	state Exp;
branches;
next	2.482;

2.482
date	2019.10.16.20.55.57;	author pwagner;	state Exp;
branches;
next	2.481;

2.481
date	2019.02.21.22.37.22;	author pwagner;	state Exp;
branches;
next	2.480;

2.480
date	2019.02.13.18.59.44;	author pwagner;	state Exp;
branches;
next	2.479;

2.479
date	2018.09.13.20.24.17;	author pwagner;	state Exp;
branches;
next	2.478;

2.478
date	2018.07.27.23.18.48;	author pwagner;	state Exp;
branches;
next	2.477;

2.477
date	2018.05.12.00.10.24;	author pwagner;	state Exp;
branches;
next	2.476;

2.476
date	2018.04.16.22.14.48;	author pwagner;	state Exp;
branches;
next	2.475;

2.475
date	2018.04.13.00.17.39;	author pwagner;	state Exp;
branches;
next	2.474;

2.474
date	2018.03.14.22.52.32;	author pwagner;	state Exp;
branches;
next	2.473;

2.473
date	2018.02.23.22.09.23;	author mmadatya;	state Exp;
branches;
next	2.472;

2.472
date	2017.12.15.18.33.19;	author mmadatya;	state Exp;
branches;
next	2.471;

2.471
date	2017.12.07.01.01.23;	author vsnyder;	state Exp;
branches;
next	2.470;

2.470
date	2017.11.15.00.38.35;	author pwagner;	state Exp;
branches;
next	2.469;

2.469
date	2017.07.27.16.57.37;	author pwagner;	state Exp;
branches;
next	2.468;

2.468
date	2017.07.10.18.50.47;	author pwagner;	state Exp;
branches;
next	2.467;

2.467
date	2017.04.07.18.46.17;	author pwagner;	state Exp;
branches;
next	2.466;

2.466
date	2017.04.06.23.43.10;	author pwagner;	state Exp;
branches;
next	2.465;

2.465
date	2017.03.23.16.44.40;	author pwagner;	state Exp;
branches;
next	2.464;

2.464
date	2017.02.08.17.55.28;	author pwagner;	state Exp;
branches;
next	2.463;

2.463
date	2016.11.08.17.32.57;	author pwagner;	state Exp;
branches;
next	2.462;

2.462
date	2016.09.02.00.49.40;	author vsnyder;	state Exp;
branches;
next	2.461;

2.461
date	2016.06.14.22.52.46;	author vsnyder;	state Exp;
branches;
next	2.460;

2.460
date	2016.05.18.01.37.30;	author vsnyder;	state Exp;
branches;
next	2.459;

2.459
date	2016.04.01.00.27.15;	author pwagner;	state Exp;
branches;
next	2.458;

2.458
date	2015.12.01.21.19.57;	author pwagner;	state Exp;
branches;
next	2.457;

2.457
date	2015.09.30.20.32.36;	author pwagner;	state Exp;
branches;
next	2.456;

2.456
date	2015.09.25.02.13.26;	author vsnyder;	state Exp;
branches;
next	2.455;

2.455
date	2015.09.22.23.39.05;	author vsnyder;	state Exp;
branches;
next	2.454;

2.454
date	2015.09.17.23.16.15;	author pwagner;	state Exp;
branches;
next	2.453;

2.453
date	2015.08.25.17.32.53;	author vsnyder;	state Exp;
branches;
next	2.452;

2.452
date	2015.04.30.02.54.31;	author vsnyder;	state Exp;
branches;
next	2.451;

2.451
date	2015.04.29.01.18.41;	author vsnyder;	state Exp;
branches;
next	2.450;

2.450
date	2015.04.21.17.48.08;	author pwagner;	state Exp;
branches;
next	2.449;

2.449
date	2015.04.09.22.18.58;	author pwagner;	state Exp;
branches;
next	2.448;

2.448
date	2015.03.28.02.34.16;	author vsnyder;	state Exp;
branches;
next	2.447;

2.447
date	2014.12.10.21.29.12;	author pwagner;	state Exp;
branches;
next	2.446;

2.446
date	2014.10.31.17.43.45;	author vsnyder;	state Exp;
branches;
next	2.445;

2.445
date	2014.09.30.02.14.38;	author vsnyder;	state Exp;
branches;
next	2.444;

2.444
date	2014.09.05.00.56.02;	author vsnyder;	state Exp;
branches;
next	2.443;

2.443
date	2014.09.05.00.49.06;	author vsnyder;	state Exp;
branches;
next	2.442;

2.442
date	2014.06.03.22.42.54;	author pwagner;	state Exp;
branches;
next	2.441;

2.441
date	2014.04.22.00.45.36;	author vsnyder;	state Exp;
branches;
next	2.440;

2.440
date	2014.03.20.01.41.48;	author vsnyder;	state Exp;
branches;
next	2.439;

2.439
date	2014.03.01.03.10.56;	author vsnyder;	state Exp;
branches;
next	2.438;

2.438
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.437;

2.437
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.436;

2.436
date	2013.11.20.01.01.33;	author pwagner;	state Exp;
branches;
next	2.435;

2.435
date	2013.10.24.21.05.20;	author pwagner;	state Exp;
branches;
next	2.434;

2.434
date	2013.10.09.23.41.20;	author vsnyder;	state Exp;
branches;
next	2.433;

2.433
date	2013.10.02.00.48.26;	author pwagner;	state Exp;
branches;
next	2.432;

2.432
date	2013.10.01.22.20.58;	author pwagner;	state Exp;
branches;
next	2.431;

2.431
date	2013.09.28.00.31.34;	author pwagner;	state Exp;
branches;
next	2.430;

2.430
date	2013.09.27.00.39.59;	author pwagner;	state Exp;
branches;
next	2.429;

2.429
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.428;

2.428
date	2013.09.21.00.24.44;	author pwagner;	state Exp;
branches;
next	2.427;

2.427
date	2013.09.17.22.43.45;	author pwagner;	state Exp;
branches;
next	2.426;

2.426
date	2013.09.17.00.52.38;	author vsnyder;	state Exp;
branches;
next	2.425;

2.425
date	2013.08.30.02.45.37;	author vsnyder;	state Exp;
branches;
next	2.424;

2.424
date	2013.07.12.23.26.51;	author vsnyder;	state Exp;
branches;
next	2.423;

2.423
date	2013.07.12.23.25.28;	author vsnyder;	state Exp;
branches;
next	2.422;

2.422
date	2013.06.14.18.49.22;	author vsnyder;	state Exp;
branches;
next	2.421;

2.421
date	2013.05.31.00.42.12;	author vsnyder;	state Exp;
branches;
next	2.420;

2.420
date	2013.05.17.00.49.29;	author pwagner;	state Exp;
branches;
next	2.419;

2.419
date	2013.04.24.00.37.42;	author pwagner;	state Exp;
branches;
next	2.418;

2.418
date	2013.04.22.17.51.32;	author pwagner;	state Exp;
branches;
next	2.417;

2.417
date	2013.04.17.00.05.07;	author pwagner;	state Exp;
branches;
next	2.416;

2.416
date	2013.01.17.20.02.02;	author pwagner;	state Exp;
branches;
next	2.415;

2.415
date	2013.01.02.21.40.59;	author pwagner;	state Exp;
branches;
next	2.414;

2.414
date	2012.11.14.20.04.11;	author pwagner;	state Exp;
branches;
next	2.413;

2.413
date	2012.11.14.00.58.42;	author pwagner;	state Exp;
branches;
next	2.412;

2.412
date	2012.11.08.23.21.30;	author pwagner;	state Exp;
branches;
next	2.411;

2.411
date	2012.11.05.19.02.48;	author pwagner;	state Exp;
branches;
next	2.410;

2.410
date	2012.10.31.00.08.40;	author pwagner;	state Exp;
branches;
next	2.409;

2.409
date	2012.10.29.17.18.24;	author pwagner;	state Exp;
branches;
next	2.408;

2.408
date	2012.10.27.00.27.29;	author pwagner;	state Exp;
branches;
next	2.407;

2.407
date	2012.10.22.18.14.50;	author pwagner;	state Exp;
branches;
next	2.406;

2.406
date	2012.10.09.00.48.30;	author pwagner;	state Exp;
branches;
next	2.405;

2.405
date	2012.08.16.17.57.16;	author pwagner;	state Exp;
branches;
next	2.404;

2.404
date	2012.07.31.00.48.16;	author vsnyder;	state Exp;
branches;
next	2.403;

2.403
date	2012.05.08.17.49.04;	author pwagner;	state Exp;
branches;
next	2.402;

2.402
date	2012.02.24.21.20.44;	author pwagner;	state Exp;
branches;
next	2.401;

2.401
date	2012.02.13.23.28.45;	author pwagner;	state Exp;
branches;
next	2.400;

2.400
date	2012.02.10.23.45.43;	author vsnyder;	state Exp;
branches;
next	2.399;

2.399
date	2012.02.02.01.19.05;	author pwagner;	state Exp;
branches;
next	2.398;

2.398
date	2012.01.25.01.19.01;	author pwagner;	state Exp;
branches;
next	2.397;

2.397
date	2012.01.18.20.38.59;	author vsnyder;	state Exp;
branches;
next	2.396;

2.396
date	2011.12.15.01.49.43;	author pwagner;	state Exp;
branches;
next	2.395;

2.395
date	2011.11.04.00.28.18;	author pwagner;	state Exp;
branches;
next	2.394;

2.394
date	2011.10.07.00.06.02;	author pwagner;	state Exp;
branches;
next	2.393;

2.393
date	2011.06.16.20.52.22;	author vsnyder;	state Exp;
branches;
next	2.392;

2.392
date	2011.04.20.16.46.37;	author pwagner;	state Exp;
branches;
next	2.391;

2.391
date	2011.03.22.23.47.54;	author pwagner;	state Exp;
branches;
next	2.390;

2.390
date	2011.03.15.22.51.58;	author pwagner;	state Exp;
branches;
next	2.389;

2.389
date	2010.11.20.00.01.14;	author pwagner;	state Exp;
branches;
next	2.388;

2.388
date	2010.08.06.23.08.48;	author pwagner;	state Exp;
branches;
next	2.387;

2.387
date	2010.07.22.17.42.24;	author pwagner;	state Exp;
branches;
next	2.386;

2.386
date	2010.07.06.16.06.06;	author pwagner;	state Exp;
branches;
next	2.385;

2.385
date	2010.07.01.00.49.19;	author pwagner;	state Exp;
branches;
next	2.384;

2.384
date	2010.05.19.23.06.45;	author pwagner;	state Exp;
branches;
next	2.383;

2.383
date	2010.05.19.17.53.19;	author pwagner;	state Exp;
branches;
next	2.382;

2.382
date	2010.04.28.16.24.11;	author pwagner;	state Exp;
branches;
next	2.381;

2.381
date	2010.04.22.23.36.46;	author pwagner;	state Exp;
branches;
next	2.380;

2.380
date	2010.04.13.01.43.09;	author vsnyder;	state Exp;
branches;
next	2.379;

2.379
date	2010.03.26.23.16.56;	author vsnyder;	state Exp;
branches;
next	2.378;

2.378
date	2010.03.25.01.50.25;	author vsnyder;	state Exp;
branches;
next	2.377;

2.377
date	2010.02.25.18.37.51;	author pwagner;	state Exp;
branches;
next	2.376;

2.376
date	2009.10.26.17.11.28;	author pwagner;	state Exp;
branches;
next	2.375;

2.375
date	2009.08.24.20.13.47;	author pwagner;	state Exp;
branches;
next	2.374;

2.374
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.373;

2.373
date	2009.04.29.23.12.54;	author pwagner;	state Exp;
branches;
next	2.372;

2.372
date	2009.04.28.20.02.50;	author pwagner;	state Exp;
branches;
next	2.371;

2.371
date	2009.04.16.21.55.05;	author pwagner;	state Exp;
branches;
next	2.370;

2.370
date	2009.04.13.20.45.57;	author pwagner;	state Exp;
branches;
next	2.369;

2.369
date	2009.03.05.18.37.59;	author pwagner;	state Exp;
branches;
next	2.368;

2.368
date	2008.12.18.21.14.05;	author pwagner;	state Exp;
branches;
next	2.367;

2.367
date	2008.11.06.21.50.46;	author pwagner;	state Exp;
branches;
next	2.366;

2.366
date	2008.09.24.16.46.37;	author livesey;	state Exp;
branches;
next	2.365;

2.365
date	2008.09.19.23.55.05;	author pwagner;	state Exp;
branches;
next	2.364;

2.364
date	2008.09.16.22.29.05;	author pwagner;	state Exp;
branches;
next	2.363;

2.363
date	2008.08.14.20.59.00;	author pwagner;	state Exp;
branches;
next	2.362;

2.362
date	2008.05.28.21.52.48;	author pwagner;	state Exp;
branches;
next	2.361;

2.361
date	2008.04.26.00.40.07;	author livesey;	state Exp;
branches;
next	2.360;

2.360
date	2008.04.11.01.17.22;	author livesey;	state Exp;
branches;
next	2.359;

2.359
date	2007.12.07.01.13.39;	author pwagner;	state Exp;
branches;
next	2.358;

2.358
date	2007.11.15.22.53.16;	author pwagner;	state Exp;
branches;
next	2.357;

2.357
date	2007.11.05.18.38.09;	author pwagner;	state Exp;
branches;
next	2.356;

2.356
date	2007.09.27.22.00.45;	author pwagner;	state Exp;
branches;
next	2.355;

2.355
date	2007.08.27.23.56.34;	author pwagner;	state Exp;
branches;
next	2.354;

2.354
date	2007.08.23.22.17.05;	author pwagner;	state Exp;
branches;
next	2.353;

2.353
date	2007.08.20.22.04.48;	author pwagner;	state Exp;
branches;
next	2.352;

2.352
date	2007.07.06.17.09.16;	author pwagner;	state Exp;
branches;
next	2.351;

2.351
date	2007.06.21.22.34.32;	author pwagner;	state Exp;
branches;
next	2.350;

2.350
date	2007.03.23.00.26.09;	author pwagner;	state Exp;
branches;
next	2.349;

2.349
date	2007.01.12.00.34.04;	author pwagner;	state Exp;
branches;
next	2.348;

2.348
date	2006.11.03.19.40.17;	author pwagner;	state Exp;
branches;
next	2.347;

2.347
date	2006.11.03.00.26.07;	author pwagner;	state Exp;
branches;
next	2.346;

2.346
date	2006.10.11.22.56.11;	author pwagner;	state Exp;
branches;
next	2.345;

2.345
date	2006.10.03.20.24.11;	author pwagner;	state Exp;
branches;
next	2.344;

2.344
date	2006.10.02.23.05.03;	author pwagner;	state Exp;
branches;
next	2.343;

2.343
date	2006.08.03.01.58.03;	author vsnyder;	state Exp;
branches;
next	2.342;

2.342
date	2006.08.02.19.52.29;	author vsnyder;	state Exp;
branches;
next	2.341;

2.341
date	2006.07.28.01.55.20;	author vsnyder;	state Exp;
branches;
next	2.340;

2.340
date	2006.07.27.23.07.38;	author pwagner;	state Exp;
branches;
next	2.339;

2.339
date	2006.07.27.03.54.11;	author vsnyder;	state Exp;
branches;
next	2.338;

2.338
date	2006.07.12.20.41.16;	author pwagner;	state Exp;
branches;
next	2.337;

2.337
date	2006.07.07.23.08.53;	author pwagner;	state Exp;
branches;
next	2.336;

2.336
date	2006.06.13.22.14.18;	author pwagner;	state Exp;
branches;
next	2.335;

2.335
date	2006.06.12.19.28.52;	author pwagner;	state Exp;
branches;
next	2.334;

2.334
date	2006.06.08.17.29.27;	author dwu;	state Exp;
branches;
next	2.333;

2.333
date	2006.06.03.01.43.36;	author vsnyder;	state Exp;
branches;
next	2.332;

2.332
date	2006.05.22.21.56.00;	author pwagner;	state Exp;
branches;
next	2.331;

2.331
date	2006.05.19.00.00.13;	author pwagner;	state Exp;
branches;
next	2.330;

2.330
date	2006.05.03.22.18.26;	author pwagner;	state Exp;
branches;
next	2.329;

2.329
date	2006.03.23.03.06.35;	author vsnyder;	state Exp;
branches;
next	2.328;

2.328
date	2006.03.23.00.38.57;	author vsnyder;	state Exp;
branches;
next	2.327;

2.327
date	2006.03.22.23.47.37;	author vsnyder;	state Exp;
branches;
next	2.326;

2.326
date	2006.03.15.23.55.11;	author pwagner;	state Exp;
branches;
next	2.325;

2.325
date	2006.03.13.23.42.37;	author pwagner;	state Exp;
branches;
next	2.324;

2.324
date	2006.03.09.16.25.01;	author pwagner;	state Exp;
branches;
next	2.323;

2.323
date	2006.03.08.21.30.32;	author pwagner;	state Exp;
branches;
next	2.322;

2.322
date	2006.02.21.19.16.10;	author pwagner;	state Exp;
branches;
next	2.321;

2.321
date	2006.02.15.00.01.19;	author pwagner;	state Exp;
branches;
next	2.320;

2.320
date	2006.02.10.21.18.48;	author pwagner;	state Exp;
branches;
next	2.319;

2.319
date	2006.01.11.17.04.32;	author pwagner;	state Exp;
branches;
next	2.318;

2.318
date	2006.01.06.01.16.34;	author pwagner;	state Exp;
branches;
next	2.317;

2.317
date	2006.01.05.03.48.17;	author vsnyder;	state Exp;
branches;
next	2.316;

2.316
date	2006.01.05.00.04.45;	author vsnyder;	state Exp;
branches;
next	2.315;

2.315
date	2005.12.22.21.05.20;	author vsnyder;	state Exp;
branches;
next	2.314;

2.314
date	2005.11.17.20.12.51;	author pwagner;	state Exp;
branches;
next	2.313;

2.313
date	2005.11.15.00.21.12;	author pwagner;	state Exp;
branches;
next	2.312;

2.312
date	2005.11.11.21.49.41;	author pwagner;	state Exp;
branches;
next	2.311;

2.311
date	2005.10.18.16.56.43;	author pwagner;	state Exp;
branches;
next	2.310;

2.310
date	2005.09.21.23.21.58;	author pwagner;	state Exp;
branches;
next	2.309;

2.309
date	2005.08.04.03.28.50;	author vsnyder;	state Exp;
branches;
next	2.308;

2.308
date	2005.08.03.18.09.38;	author vsnyder;	state Exp;
branches;
next	2.307;

2.307
date	2005.07.21.23.42.31;	author pwagner;	state Exp;
branches;
next	2.306;

2.306
date	2005.07.12.17.40.52;	author pwagner;	state Exp;
branches;
next	2.305;

2.305
date	2005.06.21.23.56.24;	author livesey;	state Exp;
branches;
next	2.304;

2.304
date	2005.06.03.02.05.29;	author vsnyder;	state Exp;
branches;
next	2.303;

2.303
date	2005.05.31.18.11.45;	author pwagner;	state Exp;
branches;
next	2.302;

2.302
date	2005.05.31.17.51.17;	author pwagner;	state Exp;
branches;
next	2.301;

2.301
date	2005.05.28.03.25.40;	author vsnyder;	state Exp;
branches;
next	2.300;

2.300
date	2005.05.27.20.03.06;	author vsnyder;	state Exp;
branches;
next	2.299;

2.299
date	2005.03.24.21.23.46;	author pwagner;	state Exp;
branches;
next	2.298;

2.298
date	2005.03.12.00.50.27;	author pwagner;	state Exp;
branches;
next	2.297;

2.297
date	2004.12.01.01.24.44;	author livesey;	state Exp;
branches;
next	2.296;

2.296
date	2004.11.30.01.41.58;	author livesey;	state Exp;
branches;
next	2.295;

2.295
date	2004.11.29.21.53.33;	author livesey;	state Exp;
branches;
next	2.294;

2.294
date	2004.11.24.22.51.37;	author livesey;	state Exp;
branches;
next	2.293;

2.293
date	2004.11.08.21.57.00;	author livesey;	state Exp;
branches;
next	2.292;

2.292
date	2004.10.21.19.32.55;	author livesey;	state Exp;
branches;
next	2.291;

2.291
date	2004.10.16.17.26.08;	author livesey;	state Exp;
branches;
next	2.290;

2.290
date	2004.10.13.02.25.11;	author livesey;	state Exp;
branches;
next	2.289;

2.289
date	2004.09.28.22.26.46;	author livesey;	state Exp;
branches;
next	2.288;

2.288
date	2004.09.27.20.11.29;	author livesey;	state Exp;
branches;
next	2.287;

2.287
date	2004.09.25.00.16.31;	author livesey;	state Exp;
branches;
next	2.286;

2.286
date	2004.09.24.17.55.57;	author livesey;	state Exp;
branches;
next	2.285;

2.285
date	2004.09.24.03.38.26;	author livesey;	state Exp;
branches;
next	2.284;

2.284
date	2004.09.21.22.59.18;	author livesey;	state Exp;
branches;
next	2.283;

2.283
date	2004.09.21.19.17.23;	author livesey;	state Exp;
branches;
next	2.282;

2.282
date	2004.09.16.23.55.04;	author livesey;	state Exp;
branches;
next	2.281;

2.281
date	2004.09.10.23.53.10;	author livesey;	state Exp;
branches;
next	2.280;

2.280
date	2004.08.24.23.24.46;	author pwagner;	state Exp;
branches;
next	2.279;

2.279
date	2004.08.23.21.59.42;	author pwagner;	state Exp;
branches;
next	2.278;

2.278
date	2004.08.03.18.01.14;	author pwagner;	state Exp;
branches;
next	2.277;

2.277
date	2004.07.30.00.17.22;	author livesey;	state Exp;
branches;
next	2.276;

2.276
date	2004.07.22.20.39.14;	author cvuu;	state Exp;
branches;
next	2.275;

2.275
date	2004.06.29.18.06.28;	author pwagner;	state Exp;
branches;
next	2.274;

2.274
date	2004.06.10.00.58.45;	author vsnyder;	state Exp;
branches;
next	2.273;

2.273
date	2004.05.28.00.57.49;	author vsnyder;	state Exp;
branches;
next	2.272;

2.272
date	2004.05.19.20.38.04;	author vsnyder;	state Exp;
branches;
next	2.271;

2.271
date	2004.05.19.19.16.09;	author vsnyder;	state Exp;
branches;
next	2.270;

2.270
date	2004.05.04.01.03.56;	author livesey;	state Exp;
branches;
next	2.269;

2.269
date	2004.05.01.04.04.36;	author vsnyder;	state Exp;
branches;
next	2.268;

2.268
date	2004.04.28.00.30.58;	author livesey;	state Exp;
branches;
next	2.267;

2.267
date	2004.04.19.21.04.02;	author livesey;	state Exp;
branches;
next	2.266;

2.266
date	2004.04.16.00.49.03;	author livesey;	state Exp;
branches;
next	2.265;

2.265
date	2004.04.13.21.19.10;	author livesey;	state Exp;
branches;
next	2.264;

2.264
date	2004.04.02.01.06.46;	author livesey;	state Exp;
branches;
next	2.263;

2.263
date	2004.03.22.18.25.25;	author livesey;	state Exp;
branches;
next	2.262;

2.262
date	2004.03.18.17.41.31;	author livesey;	state Exp;
branches;
next	2.261;

2.261
date	2004.03.17.17.16.11;	author livesey;	state Exp;
branches;
next	2.260;

2.260
date	2004.03.10.22.19.51;	author livesey;	state Exp;
branches;
next	2.259;

2.259
date	2004.03.03.22.40.59;	author livesey;	state Exp;
branches;
next	2.258;

2.258
date	2004.03.03.19.26.38;	author pwagner;	state Exp;
branches;
next	2.257;

2.257
date	2004.02.20.00.43.27;	author pwagner;	state Exp;
branches;
next	2.256;

2.256
date	2004.02.19.23.59.00;	author pwagner;	state Exp;
branches;
next	2.255;

2.255
date	2004.02.17.14.08.27;	author livesey;	state Exp;
branches;
next	2.254;

2.254
date	2004.02.06.01.01.40;	author livesey;	state Exp;
branches;
next	2.253;

2.253
date	2004.01.30.23.28.33;	author livesey;	state Exp;
branches;
next	2.252;

2.252
date	2004.01.29.03.32.42;	author livesey;	state Exp;
branches;
next	2.251;

2.251
date	2004.01.23.19.07.35;	author livesey;	state Exp;
branches;
next	2.250;

2.250
date	2004.01.23.05.47.38;	author livesey;	state Exp;
branches;
next	2.249;

2.249
date	2004.01.20.20.26.03;	author livesey;	state Exp;
branches;
next	2.248;

2.248
date	2003.12.04.22.19.32;	author livesey;	state Exp;
branches;
next	2.247;

2.247
date	2003.11.25.21.54.47;	author livesey;	state Exp;
branches;
next	2.246;

2.246
date	2003.11.05.18.37.25;	author pwagner;	state Exp;
branches;
next	2.245;

2.245
date	2003.10.22.21.17.06;	author pwagner;	state Exp;
branches;
next	2.244;

2.244
date	2003.10.15.23.12.08;	author livesey;	state Exp;
branches;
next	2.243;

2.243
date	2003.10.07.15.44.27;	author cvuu;	state Exp;
branches;
next	2.242;

2.242
date	2003.09.25.16.41.12;	author michael;	state Exp;
branches;
next	2.241;

2.241
date	2003.09.09.22.06.38;	author livesey;	state Exp;
branches;
next	2.240;

2.240
date	2003.08.28.00.44.54;	author livesey;	state Exp;
branches;
next	2.239;

2.239
date	2003.08.21.16.07.17;	author livesey;	state Exp;
branches;
next	2.238;

2.238
date	2003.08.20.20.05.42;	author livesey;	state Exp;
branches;
next	2.237;

2.237
date	2003.08.16.00.29.37;	author vsnyder;	state Exp;
branches;
next	2.236;

2.236
date	2003.08.15.23.58.48;	author vsnyder;	state Exp;
branches;
next	2.235;

2.235
date	2003.08.13.19.23.45;	author vsnyder;	state Exp;
branches;
next	2.234;

2.234
date	2003.08.08.23.07.02;	author livesey;	state Exp;
branches;
next	2.233;

2.233
date	2003.07.16.22.39.47;	author livesey;	state Exp;
branches;
next	2.232;

2.232
date	2003.07.08.00.17.46;	author livesey;	state Exp;
branches;
next	2.231;

2.231
date	2003.06.24.19.59.42;	author livesey;	state Exp;
branches;
next	2.230;

2.230
date	2003.06.20.19.37.06;	author pwagner;	state Exp;
branches;
next	2.229;

2.229
date	2003.06.05.22.08.55;	author livesey;	state Exp;
branches;
next	2.228;

2.228
date	2003.06.03.19.23.51;	author livesey;	state Exp;
branches;
next	2.227;

2.227
date	2003.05.29.20.01.55;	author livesey;	state Exp;
branches;
next	2.226;

2.226
date	2003.05.29.16.41.56;	author livesey;	state Exp;
branches;
next	2.225;

2.225
date	2003.05.28.06.00.06;	author livesey;	state Exp;
branches;
next	2.224;

2.224
date	2003.05.26.06.32.50;	author livesey;	state Exp;
branches;
next	2.223;

2.223
date	2003.05.22.02.23.15;	author livesey;	state Exp;
branches;
next	2.222;

2.222
date	2003.05.22.00.26.33;	author dwu;	state Exp;
branches;
next	2.221;

2.221
date	2003.05.21.18.58.57;	author dwu;	state Exp;
branches;
next	2.220;

2.220
date	2003.05.21.18.04.30;	author livesey;	state Exp;
branches;
next	2.219;

2.219
date	2003.05.20.23.10.24;	author dwu;	state Exp;
branches;
next	2.218;

2.218
date	2003.05.20.20.20.01;	author dwu;	state Exp;
branches;
next	2.217;

2.217
date	2003.05.15.19.09.17;	author dwu;	state Exp;
branches;
next	2.216;

2.216
date	2003.05.14.23.14.00;	author dwu;	state Exp;
branches;
next	2.215;

2.215
date	2003.05.12.23.53.55;	author dwu;	state Exp;
branches;
next	2.214;

2.214
date	2003.05.12.22.11.07;	author dwu;	state Exp;
branches;
next	2.213;

2.213
date	2003.05.11.00.05.06;	author livesey;	state Exp;
branches;
next	2.212;

2.212
date	2003.05.10.23.40.27;	author livesey;	state Exp;
branches;
next	2.211;

2.211
date	2003.05.10.22.20.12;	author livesey;	state Exp;
branches;
next	2.210;

2.210
date	2003.05.10.01.07.58;	author livesey;	state Exp;
branches;
next	2.209;

2.209
date	2003.05.08.19.34.58;	author dwu;	state Exp;
branches;
next	2.208;

2.208
date	2003.05.07.00.16.52;	author livesey;	state Exp;
branches;
next	2.207;

2.207
date	2003.05.06.21.00.23;	author livesey;	state Exp;
branches;
next	2.206;

2.206
date	2003.04.30.22.07.14;	author pwagner;	state Exp;
branches;
next	2.205;

2.205
date	2003.04.24.22.17.02;	author dwu;	state Exp;
branches;
next	2.204;

2.204
date	2003.04.24.00.35.14;	author dwu;	state Exp;
branches;
next	2.203;

2.203
date	2003.04.24.00.29.45;	author dwu;	state Exp;
branches;
next	2.202;

2.202
date	2003.04.23.17.06.36;	author livesey;	state Exp;
branches;
next	2.201;

2.201
date	2003.04.11.23.15.09;	author livesey;	state Exp;
branches;
next	2.200;

2.200
date	2003.04.11.21.56.40;	author livesey;	state Exp;
branches;
next	2.199;

2.199
date	2003.04.08.23.13.01;	author dwu;	state Exp;
branches;
next	2.198;

2.198
date	2003.04.07.06.37.42;	author dwu;	state Exp;
branches;
next	2.197;

2.197
date	2003.04.05.00.26.47;	author livesey;	state Exp;
branches;
next	2.196;

2.196
date	2003.04.05.00.05.37;	author livesey;	state Exp;
branches;
next	2.195;

2.195
date	2003.04.04.23.53.57;	author livesey;	state Exp;
branches;
next	2.194;

2.194
date	2003.04.04.22.01.59;	author livesey;	state Exp;
branches;
next	2.193;

2.193
date	2003.04.04.00.08.06;	author livesey;	state Exp;
branches;
next	2.192;

2.192
date	2003.03.27.20.45.02;	author livesey;	state Exp;
branches;
next	2.191;

2.191
date	2003.03.26.21.23.47;	author livesey;	state Exp;
branches;
next	2.190;

2.190
date	2003.03.19.19.22.24;	author pwagner;	state Exp;
branches;
next	2.189;

2.189
date	2003.03.07.03.16.12;	author livesey;	state Exp;
branches;
next	2.188;

2.188
date	2003.03.06.00.46.30;	author livesey;	state Exp;
branches;
next	2.187;

2.187
date	2003.03.05.19.11.11;	author livesey;	state Exp;
branches;
next	2.186;

2.186
date	2003.02.28.02.26.23;	author livesey;	state Exp;
branches;
next	2.185;

2.185
date	2003.02.27.00.38.52;	author livesey;	state Exp;
branches;
next	2.184;

2.184
date	2003.02.18.23.59.06;	author livesey;	state Exp;
branches;
next	2.183;

2.183
date	2003.02.15.00.35.03;	author livesey;	state Exp;
branches;
next	2.182;

2.182
date	2003.02.13.21.42.12;	author livesey;	state Exp;
branches;
next	2.181;

2.181
date	2003.01.29.01.59.19;	author livesey;	state Exp;
branches
	2.181.2.1;
next	2.180;

2.180
date	2003.01.28.21.53.07;	author pwagner;	state Exp;
branches;
next	2.179;

2.179
date	2003.01.16.21.48.58;	author vsnyder;	state Exp;
branches;
next	2.178;

2.178
date	2003.01.15.23.29.41;	author pwagner;	state Exp;
branches;
next	2.177;

2.177
date	2003.01.15.02.49.06;	author vsnyder;	state Exp;
branches;
next	2.176;

2.176
date	2003.01.14.23.53.10;	author livesey;	state Exp;
branches;
next	2.175;

2.175
date	2003.01.14.22.39.25;	author livesey;	state Exp;
branches;
next	2.174;

2.174
date	2003.01.14.21.58.59;	author vsnyder;	state Exp;
branches;
next	2.173;

2.173
date	2003.01.14.21.34.09;	author vsnyder;	state Exp;
branches;
next	2.172;

2.172
date	2003.01.12.07.34.05;	author dwu;	state Exp;
branches;
next	2.171;

2.171
date	2003.01.12.05.13.50;	author dwu;	state Exp;
branches;
next	2.170;

2.170
date	2003.01.08.23.52.16;	author livesey;	state Exp;
branches;
next	2.169;

2.169
date	2003.01.07.23.46.38;	author livesey;	state Exp;
branches;
next	2.168;

2.168
date	2002.11.29.22.46.15;	author livesey;	state Exp;
branches;
next	2.167;

2.167
date	2002.11.27.22.59.21;	author livesey;	state Exp;
branches;
next	2.166;

2.166
date	2002.11.27.22.18.10;	author dwu;	state Exp;
branches;
next	2.165;

2.165
date	2002.11.27.19.25.45;	author livesey;	state Exp;
branches;
next	2.164;

2.164
date	2002.11.21.01.18.11;	author livesey;	state Exp;
branches;
next	2.163;

2.163
date	2002.11.14.17.28.01;	author livesey;	state Exp;
branches;
next	2.162;

2.162
date	2002.11.13.01.06.42;	author pwagner;	state Exp;
branches;
next	2.161;

2.161
date	2002.11.06.02.01.05;	author livesey;	state Exp;
branches;
next	2.160;

2.160
date	2002.10.26.00.02.51;	author livesey;	state Exp;
branches;
next	2.159;

2.159
date	2002.10.26.00.00.07;	author livesey;	state Exp;
branches;
next	2.158;

2.158
date	2002.10.25.23.59.45;	author livesey;	state Exp;
branches;
next	2.157;

2.157
date	2002.10.25.23.56.14;	author livesey;	state Exp;
branches;
next	2.156;

2.156
date	2002.10.17.18.18.50;	author livesey;	state Exp;
branches;
next	2.155;

2.155
date	2002.10.16.20.15.27;	author mjf;	state Exp;
branches;
next	2.154;

2.154
date	2002.10.10.23.52.57;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2002.10.08.17.36.20;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2002.10.03.13.44.04;	author mjf;	state Exp;
branches;
next	2.151;

2.151
date	2002.10.02.23.04.47;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2002.10.01.18.28.04;	author mjf;	state Exp;
branches;
next	2.149;

2.149
date	2002.09.26.20.41.04;	author vsnyder;	state Exp;
branches;
next	2.148;

2.148
date	2002.09.25.20.08.14;	author livesey;	state Exp;
branches;
next	2.147;

2.147
date	2002.09.13.18.10.10;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2002.09.12.22.07.05;	author livesey;	state Exp;
branches;
next	2.145;

2.145
date	2002.09.10.20.50.33;	author livesey;	state Exp;
branches;
next	2.144;

2.144
date	2002.09.10.01.00.32;	author livesey;	state Exp;
branches;
next	2.143;

2.143
date	2002.09.06.00.54.13;	author livesey;	state Exp;
branches;
next	2.142;

2.142
date	2002.09.05.21.48.54;	author livesey;	state Exp;
branches;
next	2.141;

2.141
date	2002.09.05.20.49.38;	author livesey;	state Exp;
branches;
next	2.140;

2.140
date	2002.08.28.01.13.52;	author livesey;	state Exp;
branches;
next	2.139;

2.139
date	2002.08.26.20.01.09;	author livesey;	state Exp;
branches;
next	2.138;

2.138
date	2002.08.21.23.06.12;	author livesey;	state Exp;
branches;
next	2.137;

2.137
date	2002.08.20.22.10.49;	author vsnyder;	state Exp;
branches;
next	2.136;

2.136
date	2002.08.20.19.30.24;	author livesey;	state Exp;
branches;
next	2.135;

2.135
date	2002.08.20.19.19.41;	author livesey;	state Exp;
branches;
next	2.134;

2.134
date	2002.08.16.16.08.58;	author livesey;	state Exp;
branches;
next	2.133;

2.133
date	2002.08.15.03.52.52;	author livesey;	state Exp;
branches;
next	2.132;

2.132
date	2002.08.03.20.41.40;	author livesey;	state Exp;
branches;
next	2.131;

2.131
date	2002.06.26.01.26.21;	author livesey;	state Exp;
branches;
next	2.130;

2.130
date	2002.06.18.20.00.36;	author livesey;	state Exp;
branches;
next	2.129;

2.129
date	2002.06.14.16.40.00;	author livesey;	state Exp;
branches;
next	2.128;

2.128
date	2002.06.04.23.22.36;	author livesey;	state Exp;
branches;
next	2.127;

2.127
date	2002.06.04.22.40.44;	author livesey;	state Exp;
branches;
next	2.126;

2.126
date	2002.05.28.17.08.42;	author livesey;	state Exp;
branches;
next	2.125;

2.125
date	2002.05.23.20.51.53;	author livesey;	state Exp;
branches;
next	2.124;

2.124
date	2002.05.17.17.55.48;	author livesey;	state Exp;
branches;
next	2.123;

2.123
date	2002.05.14.00.26.25;	author livesey;	state Exp;
branches;
next	2.122;

2.122
date	2002.05.06.22.30.51;	author livesey;	state Exp;
branches;
next	2.121;

2.121
date	2002.04.25.20.47.02;	author livesey;	state Exp;
branches;
next	2.120;

2.120
date	2002.04.18.20.14.52;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2002.04.16.23.27.43;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2002.04.13.00.31.46;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2002.04.11.23.51.28;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2002.04.10.17.45.44;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2002.04.04.16.32.42;	author livesey;	state Exp;
branches;
next	2.114;

2.114
date	2002.03.27.17.37.57;	author livesey;	state Exp;
branches;
next	2.113;

2.113
date	2002.03.19.00.52.40;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2002.03.14.17.29.59;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2002.03.14.01.01.17;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2002.03.13.22.01.41;	author livesey;	state Exp;
branches;
next	2.109;

2.109
date	2002.03.08.08.07.00;	author livesey;	state Exp;
branches;
next	2.108;

2.108
date	2002.03.07.19.20.11;	author livesey;	state Exp;
branches;
next	2.107;

2.107
date	2002.02.20.22.42.35;	author livesey;	state Exp;
branches;
next	2.106;

2.106
date	2002.02.20.02.08.14;	author livesey;	state Exp;
branches;
next	2.105;

2.105
date	2002.02.06.01.35.29;	author livesey;	state Exp;
branches;
next	2.104;

2.104
date	2002.02.05.01.45.21;	author livesey;	state Exp;
branches;
next	2.103;

2.103
date	2002.01.18.00.24.21;	author livesey;	state Exp;
branches;
next	2.102;

2.102
date	2002.01.16.18.06.31;	author livesey;	state Exp;
branches;
next	2.101;

2.101
date	2002.01.09.00.00.04;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2001.12.06.23.45.07;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2001.10.26.23.23.05;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2001.10.26.18.15.18;	author livesey;	state Exp;
branches;
next	2.96;

2.96
date	2001.10.25.23.32.11;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2001.10.24.22.35.33;	author dwu;	state Exp;
branches;
next	2.94;

2.94
date	2001.10.23.16.38.09;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2001.10.19.23.42.50;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2001.10.19.22.32.44;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2001.10.19.00.00.36;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2001.10.18.23.29.57;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2001.10.18.23.07.40;	author livesey;	state Exp;
branches;
next	2.88;

2.88
date	2001.10.18.23.06.05;	author livesey;	state Exp;
branches;
next	2.87;

2.87
date	2001.10.18.22.30.30;	author livesey;	state Exp;
branches;
next	2.86;

2.86
date	2001.10.18.03.51.46;	author livesey;	state Exp;
branches;
next	2.85;

2.85
date	2001.10.18.00.46.32;	author livesey;	state Exp;
branches;
next	2.84;

2.84
date	2001.10.17.23.40.08;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2001.10.16.23.34.05;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2001.10.16.00.07.48;	author livesey;	state Exp;
branches;
next	2.81;

2.81
date	2001.10.15.22.10.42;	author livesey;	state Exp;
branches;
next	2.80;

2.80
date	2001.10.02.23.12.50;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2001.09.28.23.59.20;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2001.09.28.17.50.30;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2001.09.24.17.28.15;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2001.09.21.23.23.35;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2001.09.20.20.57.25;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2001.09.19.23.42.29;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2001.09.18.23.53.08;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2001.09.17.23.12.21;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2001.09.14.23.34.13;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2001.08.03.23.13.52;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2001.08.02.00.17.06;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2001.08.01.00.05.25;	author dwu;	state Exp;
branches;
next	2.67;

2.67
date	2001.07.31.23.53.37;	author dwu;	state Exp;
branches;
next	2.66;

2.66
date	2001.07.31.23.24.17;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2001.07.30.23.28.38;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2001.07.26.20.33.40;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2001.07.20.20.03.30;	author dwu;	state Exp;
branches;
next	2.62;

2.62
date	2001.07.20.19.25.03;	author dwu;	state Exp;
branches;
next	2.61;

2.61
date	2001.07.19.21.45.33;	author dwu;	state Exp;
branches;
next	2.60;

2.60
date	2001.07.19.18.05.42;	author dwu;	state Exp;
branches;
next	2.59;

2.59
date	2001.07.19.00.56.27;	author dwu;	state Exp;
branches;
next	2.58;

2.58
date	2001.07.19.00.19.42;	author dwu;	state Exp;
branches;
next	2.57;

2.57
date	2001.06.22.05.37.27;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2001.06.13.20.41.35;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2001.05.30.23.56.39;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2001.05.30.20.16.26;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2001.05.23.04.38.16;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2001.05.19.00.15.39;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2001.05.19.00.13.41;	author livesey;	state Exp;
branches;
next	2.50;

2.50
date	2001.05.18.22.39.45;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2001.05.18.19.50.50;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2001.05.16.19.44.16;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2001.05.10.23.25.12;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2001.05.08.20.34.26;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2001.05.03.20.30.29;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2001.04.28.01.43.21;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2001.04.24.23.12.02;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2001.04.23.23.26.05;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2001.04.20.17.12.24;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2001.04.19.00.09.34;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2001.04.10.23.45.17;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2001.04.10.20.04.17;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2001.04.10.00.02.19;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2001.04.07.00.12.05;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2001.04.05.23.45.39;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2001.03.29.19.12.40;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2001.03.15.23.28.23;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2001.03.15.21.18.57;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2001.03.15.21.12.11;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2001.03.15.18.40.38;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2001.03.14.05.33.39;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2001.03.07.22.42.23;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2001.03.06.22.41.07;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2001.03.06.00.34.46;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.03.05.01.20.14;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.03.03.05.54.29;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.03.03.00.10.14;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.03.03.00.07.40;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.02.27.17.39.03;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.02.27.01.25.15;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.02.27.00.50.53;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.02.23.18.16.26;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.02.21.01.07.34;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.02.08.01.17.41;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2001.01.26.00.11.12;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2001.01.24.23.31.00;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.01.10.21.47.45;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.01.03.18.15.13;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.01.03.17.49.49;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2000.12.07.00.41.46;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2000.12.06.00.01.20;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2000.12.05.00.40.50;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2000.11.30.00.22.52;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2000.11.16.02.15.25;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2000.11.13.23.02.21;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2000.10.06.22.18.47;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2000.09.11.19.52.51;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.21.21.04.06;	author livesey;	state Exp;
branches;
next	;

2.181.2.1
date	2003.03.06.23.54.40;	author vsnyder;	state Exp;
branches;
next	2.181.2.2;

2.181.2.2
date	2003.03.27.00.49.25;	author vsnyder;	state Exp;
branches;
next	2.181.2.3;

2.181.2.3
date	2003.03.27.23.18.03;	author vsnyder;	state Exp;
branches;
next	2.181.2.4;

2.181.2.4
date	2003.04.15.23.14.00;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.488
log
@Corrected error mesg in convergence Fill
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Fill                     ! Create vector quantities and fill them.
!=============================================================================

  use MLSCommon, only: MLSFile_T, DefaultUndefinedValue
  use MLSKinds, only: R8, Rv
  use HighOutput, only: Dump
  use Output_M, only: OutputOptions, StampOptions, SwitchOutput, RevertOutput
  use MLSMessageModule, only: DumpConfig
  ! This module performs the Fill operation in the Level 2 software.
  ! This takes a quantity template, 
  ! then creates and fills an appropriate vector quantity

  implicit none
  private
  public :: MLSL2Fill

! === (start of toc) ===
! MLSL2Fill          given a quantity template, then creates and fills a 
!                      vector  quantity
! === (end of toc) ===

! === (start of api) ===
! MLSL2Fill ( int root, 
!        *MLSFile_T fileDataBase(:), 
!        *GriddedData_T GriddedDataBase(:),
!        *VectorTemplate_T VectorTemplates(:),
!        *Vector_t Vectors(:), *quantityTemplate_T QtyTemplates(:),
!        *Matrix_database_T Matrices(:),
!        *L2GPData_T L2GPDatabase(:), *l2AUXData_T L2AUXDatabase(:),
!        *ForwardModelConfig_T FWModelConfig(:),
!        *MlSChunk_T Chunks(:), int ChunkNo, *HGrid_T HGrids(:) )
! === (end of api) ===
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= "$RCSfile: Fill.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

  logical, parameter :: countEmpty = .true. ! Except where overriden locally
  logical, parameter :: USEREICHLER = .true.

contains ! =====     Public Procedures     =============================

  !---------------------------------------------------  MLSL2Fill  -----

  subroutine MLSL2Fill ( root, fileDatabase, griddedDatabase, vectorTemplates, &
    & Vectors, QtyTemplates, Matrices, Hessians, L2GPDatabase, L2AUXDatabase, &
    & FwmodelConfig, chunks, chunkNo, HGrids )

    ! This is the main routine for the module.  It parses the relevant lines
    ! of the l2cf and works out what to do.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    use Chunks_M, only: MLSChunk_T
    use DestroyCommand_M, only: DestroyCommand
    use DumpCommand_M, only: BooleanFromAnyGoodRadiances, &
      & BooleanFromAnygoodValues, BooleanFromCatchwarning, &
      & BooleanFromChunkEndsBefore, BooleanFromChunkStartsAfter, &
      & BooleanFromComparingQtys, BooleanFromEmptyGrid, BooleanFromFormula, &
      & DumpCommand, ExecuteCommand, Initializerepeat, Nextrepeat, &
      & MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, &
      & Repeat=>skip, Skip
    use Expr_M, only: Expr
    use FillUtils_1, only: Addgaussiannoise, Applybaseline, AutoFillVector, &
      & Computetotalpower, Derivativeofsource, Fillcovariance, &
      & Extractsinglechannel, Fillerror, Fromanother, Fromgrid, &
      & FromL2GP, Fromprofile, Gather, GeoidData, Losvelocity, &
      & Chisqchan, Chisqmmaf, Chisqmmif, Chisqratio, &
      & Colabundance, FoldedRadiance, Phitanwithrefraction, HeightFromPressure, &
      & Iwcfromextinction, Rhifromortoh2o, Noradspermif, &
      & Rhiprecisionfromortoh2o, Withestnoise, &
      & Hydrostatically_Gph, Hydrostatically_Ptan, Fromsplitsideband, &
      & Gphprecision, Fromisotope, Fromasciifile, Rotatemagneticfield, &
      & Explicit, Froml1b, ResidualCorrection, &
      & Froml2aux, Usingmagneticmodel, &
      & Frominterpolatedqty, Fromlosgrid, NearestProfiles, &
      & Bymanipulation, ManipulateVectors, Withreflectortemperature, &
      & Withascordesc, Withreichlerwmotp, &
      & Withwmotropopause, Withbinresults, Withboxcarfunction, &
      & StatusQuantity, Qualityfromchisq, Convergencefromchisq, &
      & Usingleastsquares, OffsetRadianceQuantity, ResetunusedRadiances, &
      & Scaleoverlaps, Scatter, SpreadchannelFill, TransferVectors, &
      & TransferVectorsbymethod, UncompressRadiance, &
      & Qtyfromfile, Vectorfromfile, Announce_Error, &
    ! Codes For Announce_Error:
      & BadestnoiseFill, BadgeocaltitudeQuantity, BadisotopeFill, &
      & BadlosgridFill, BadlosvelFill, BadrefgphQuantity, BadgphQuantity, &
      & BadrefractFill, BadscvelecrQuantity, BadtemperatureQuantity, &
      & Bothfractionandlength, Missingfield, &
      & Needgeocaltitude, Needh2o, Needorbitinclination, Needtemprefgph, &
      & NegativePhiWindow, Nocodefor, No_Error_Code, NoexplicitValuesgiven, &
      & Nosourcegridgiven, Nosourcel2auxgiven, NosourceL2GPgiven, &
      & Notimplemented, Notplain, Notspd, &
      & Wrongunits
    use ForwardModelConfig, only: Forwardmodelconfig_T
    use ForwardModelSupport, only: Fillfwdmodeltimings
    use Global_Settings, only: Brightobjects
    use GriddedData, only: GriddedData_T, &
      & AddGriddedDataToDatabase,  &
      & DestroyGriddedData, Dump, DumpDBFootPrint
    use Hessianmodule_1, only: AddhessiantoDatabase, Createemptyhessian, &
      & Streamlinehessian, Hessian_T
    use HGridsDatabase, only: HGrids_T
    use HighOutput, only: LetsDebug, OutputNamedValue
    ! We Need Many Things From Init_Tables_Module. First The Fields:
    use Init_Tables_Module, only: F_A, F_Additional, F_Allowmissing, &
      & F_Aprioriprecision, F_Aspercentage, F_Autofill, F_Avoidbrightobjects, &
      & F_B, F_Badrange, F_Baselinequantity, F_Bin, F_Block, F_Boolean, &
      & F_Boundarypressure, F_Boxcarmethod, &
      & F_C, F_Centervertically, F_Channel, F_Channels, F_Columns, F_Count, &
      & F_Destination, F_Diagonal, F_Dimlist, &
      & F_Dontlatch, F_DontMask, &
      & F_Ecrtofov, F_Earthradius, F_Exact, F_Excludebelowbottom, &
      & F_ExplicitValues, F_Expr, F_ExpandMask, F_Extinction, &
      & F_Fieldecr, F_File, F_Flags, F_Force, F_Shape, &
      & F_Fraction, F_Fromprecision, F_Grid, &
      & F_Geocaltitudequantity, F_Geolocation, F_Gphquantity, F_GroupName, &
      & F_Height, F_Heightrange, F_Hessian, &
      & F_Highbound, F_H2oquantity, F_H2oprecisionquantity, F_HGrid, &
      & F_Ifmissinggmao, &
      & F_Ignorenegative, F_Ignoregeolocation, F_IgnoreTemplate, F_Ignorezero, &
      & F_Instances, F_Integrationtime, F_Internalvgrid, &
      & F_Interpolate, F_Invert, F_Intrinsic, F_Isprecision, &
      & F_Lengthscale, F_Logspace, F_Losqty, F_Lowbound, F_Lsb, F_Lsbfraction, &
      & F_Manipulation, F_Matrix, F_Maxiterations, F_MaxValue, F_Measurements, &
      & F_Method, F_Minnormqty, F_MinValue, F_Model, F_Multiplier, &
      & F_Nofinegrid, F_Noise, F_Noisebandwidth, F_NoPCFid, F_Normqty, &
      & F_NoZeros, F_Offsetamount, F_Options, F_Orbitinclination, F_Phitan, &
      & F_Phiwindow, F_Phizero, F_Precision, F_Precisionfactor, &
      & F_Profile, F_ProfileValues, F_Ptanquantity, &
      & F_Quadrature, F_Quantity, F_Quantitynames, &
      & F_Radiancequantity, F_Rank, F_Ratioquantity, F_Refract, F_Refgphquantity, &
      & F_Refgphprecisionquantity, F_ReferenceMIF, F_Regular, &
      & F_ReplaceMissingValue, F_Reset, F_Resetseed, &
      & F_Rows, F_Rhiprecisionquantity, F_Rhiquantity, &
      & F_Scale, F_Scaleinsts, F_Scaleratio, F_Scalesurfs, F_Sceci, &
      & F_Scvel, F_Scveleci, F_Scvelecr, F_Sdname, F_Seed, F_SkipMask, F_SkipValues, &
      & F_Source, F_Sourcegrid, F_Sourcel2aux, F_Sourcel2gp, F_SourceMask, &
      & F_Sourcequantity, F_SourceType, F_Sourcevgrid, F_Spread, F_Start, &
      & F_Status, F_Stride, F_Suffix, F_Surface, &
      & F_Systemtemperature, F_Temperaturequantity, F_Tempprecisionquantity, &
      & F_Template, F_Tngteci, F_Terms, F_Totalpowerquantity, &
      & F_Type, F_Unit, F_Usb, F_Usbfraction, F_Vector, F_Vmrquantity, &
      & F_Wherefill, F_Wherenotfill, F_Width, &
      & Field_First, Field_Last
    ! Now The Literals:
    use Init_Tables_Module, only: L_Addnoise, L_Applybaseline, L_Ascenddescend, &
      & L_Asciifile, L_Binmax, L_Binmean, L_Binmin, L_Bintotal, &
      & L_Boundarypressure, L_Boxcar, L_Chisqchan, &
      & L_Chisqmmaf, L_Chisqmmif, L_Chisqratio, L_Cholesky, &
      & L_Cloudice, L_Cloudextinction, &
      & L_Combinechannels, L_Columnabundance, L_Convergenceratio, &
      & L_Derivative, L_Dobsonunits, L_Du, &
      & L_Estimatednoise, L_Explicit, L_Extractchannel, L_Fold, &
      & L_Fwdmodeltiming, L_Fwdmodelmean, L_Fwdmodelstddev, &
      & L_Gather, L_Geocaltitude, L_Geodaltitude, L_Geolocation, &
      & L_GeoidData, L_Gph, L_Gphprecision, L_Gphresettogeoid, L_Gridded, &
      & L_H2ofromrhi, L_H2oprecisionfromrhi, L_Hdf, L_Hydrostatic, &
      & L_Isotope, L_Iwcfromextinction, L_Kronecker, &
      & L_L1b, L_L2gp, L_L2aux, &
      & L_Losvel, L_Lsglobal, L_Lslocal, L_Lsweighted, &
      & L_Magazel, L_Magneticmodel, &
      & L_Manipulate, L_Mean, L_ModifyTemplate, L_Molcm2, &
      & L_Negativeprecision, L_None, &
      & L_Noradspermif, L_Offsetradiance, &
      & L_Phasetiming, L_Phitan, &
      & L_Plain, L_Profile, L_Ptan, L_Quality, &
      & L_Rectanglefromlos, L_Refgph, L_Refract,  L_HeightFromPressure, &
      & L_Reflectortempmodel, L_Resetunusedradiances, L_Rhi, &
      & L_Rhifromh2o, L_Rhiprecisionfromh2o, L_ResidualCorrection, &
      & L_Rotatefield, L_Scaleoverlaps, &
      & L_Sectiontiming, L_Scatter, L_Scvelecr, L_Spd, L_Spreadchannel, &
      & L_Splitsideband, L_Status, L_SwapValues, &
      & L_Temperature, L_Tngtgeodalt, L_Tngtgeocalt, &
      & L_Uncompressradiance, L_Vector, L_Vgrid, L_Vmr, L_Wmotropopause, &
      & L_Zeta
    ! Now The Specifications:
    use Init_Tables_Module, only: S_AnygoodValues, S_Anygoodradiances, &
      & S_Case, S_Catchwarning, S_ChunkEndsBefore, S_ChunkStartsAfter, &
      & S_Compare, S_Computetotalpower, &
      & S_Concatenate, S_ConcatenateGrids, S_ConvertEtaToP, S_Delete, &
      & S_Destroy, S_Diff, S_Directread, S_Dump, S_Endselect, S_Execute, &
      & S_Fill, S_Fillcovariance, S_Filldiagonal, &
      & S_Flagcloud, S_Flushl2pcbins, S_Flushpfa, S_Gridded, S_Hessian, S_IsGridEmpty, &
      & S_Load, S_Matrix, S_Merge, S_MergeGrids, S_Negativeprecision, S_Phase, S_Populatel2pcbin, &
      & S_ReadGriddedData, S_Reevaluate, S_Repeat, S_Restrictrange, S_ChangeSettings, &
      & S_Select, S_Skip, S_Snoop, S_Streamlinehessian, S_Subset, &
      & S_Time, S_Transfer, S_UpdateMask, S_Vector, S_WMOTropFromGrids
    ! Now Some Arrays
    use Intrinsic, only: Lit_Indices, &
      & Phyq_Angle, Phyq_Dimensionless, Phyq_Invalid, Phyq_Length, &
      & Phyq_Profiles
    use, Intrinsic :: Iso_C_Binding, only: C_Intptr_T, C_Loc
    use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData
    use L2GPData, only: L2GPData_T, Col_Species_Hash, Col_Species_Keys
    use L2AUXData, only: L2AUXData_T
    use L2PC_M, only: Populatel2pcbinbyname, Loadhessian, Loadmatrix, LoadVector
    use L2PCBins_M, only: Flushlockedbins
    use ManipulateVectorQuantities, only: DoHGridsMatch, &
      & FillWithCombinedChannels
    use MatrixModule_1, only: AddToMatrixDatabase, CreateEmptyMatrix, &
      & GetActualMatrixFromDatabase, GetDiagonal, &
      & GetkindfrommatrixDatabase, GetfrommatrixDatabase, K_Plain, K_Spd, &
      & Matrix_Cholesky_T, Matrix_Database_T, Matrix_Kronecker_T, Matrix_Spd_T, &
      & Matrix_T, Nullifymatrix
    ! Note: If You Ever Want To Include Defined Assignment For Matrices, Please
    ! Carefully Check Out The Code Around The Call To Snoop.
    use MergeGridsModule, only: Concatenate, ConvertEtaToP, DeleteGriddedData, &
      & MergeGrids, MergeOneGrid, WMOTropFromGrid
    use MLSFiles, only: HDFVersion_5, GetMLSFileByType
    use MLSL2Options, only: L2cfnode, &
      & DumpMacros, RuntimeValues, L2Options, SpecialDumpFile, MLSL2Message
    use MLSL2Timings, only: Section_Times, &
      & AddPhaseToPhaseNames, FillTimings, FinishTimings
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, &
      & MLSMsg_L1bread, MLSMessageReset
    use MLSPCF2, only: MLSPCF_ElevOffset_Start, MLSPCF_Misc_End, &
      & MLSPCF_L2apriori_Start, MLSPCF_L2apriori_End, &
      & MLSPCF_L2clim_Start, MLSPCF_L2clim_End, &
      & MLSPCF_L2dao_Start, MLSPCF_L2dao_End, &
      & MLSPCF_L2geos5_Start, MLSPCF_L2geos5_End, &
      & MLSPCF_L2ncep_Start, MLSPCF_L2ncep_End, &
      & MLSPCF_Surfaceheight_Start, MLSPCF_Surfaceheight_End
    use MLSRandomNumber, only: MLS_Random_Seed, Math77_Ran_Pack
    use MLSStringlists, only: Catlists, GethashElement, &
      & NumstringElements, PuthashElement, &
      & StringElement, StringElementnum, SwitchDetail
    use MLSStrings, only: Lowercase
    use Molecules, only: L_H2O
    use Moretree, only: Get_Boolean, Get_Field_Id, Get_Label_And_Spec, &
      & Get_Spec_Id
    use Next_Tree_Node_M, only: Next_Tree_Node, Next_Tree_Node_State
    use Output_M, only: Output, RevertOutput, SwitchOutput
    use PCFHdr, only: GranuleDay, GranuleDayOfYear, GranuleMonth, GranuleYear
    use PFAData_M, only: Flush_PFAData
    use QuantityTemplates, only: QuantityTemplate_T, &
      & ModifyQuantityTemplate
    use ReadAPriori, only: APrioriFiles, ProcessOneAprioriFile
    use SnoopMLSL2, only: Snoop
    use String_Table, only: Get_String
    use Subsetmodule, only: ApplyMasktoquantity, Restrictrange, &
      & Setupflagcloud, Setupsubset, UpdateMask
    use Time_M, only: SayTime, Time_Now
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decorate, Decoration, Nsons, Sub_Rosa, Subtree, Where
    use VectorsModule, only: AddVectortoDatabase, &
      & ClearMask, CloneVectorQuantity, CreateVector, &
      & DumpQuantityMask, &
      & GetVectorQtybyTemplateindex, &
      & ValidateVectorQuantity, Vector_T, &
      & VectorTemplate_T, VectorValue_T, M_Fill
    use VGridsDatabase, only: VGrids

    ! Dummy arguments
    integer, intent(in)                               :: ROOT ! Of the FILL section in the AST
    type (MLSFile_T), dimension(:), pointer           :: FILEDATABASE
    type (griddedData_T), dimension(:), pointer       :: GRIDDEDDATABASE
    type (vectorTemplate_T), dimension(:), pointer    :: VECTORTEMPLATES
    type (vector_T), dimension(:), pointer            :: VECTORS
    type (quantityTemplate_T), dimension(:), pointer  :: QTYTEMPLATES
    type (matrix_database_T), dimension(:), pointer   :: MATRICES
    type (Hessian_T), dimension(:), pointer           :: HESSIANS
    type (l2GPData_T), dimension(:), pointer          :: L2GPDATABASE
    type (l2AUXData_T), dimension(:), pointer         :: L2AUXDATABASE
    type(ForwardModelConfig_T), dimension(:), pointer :: FWMODELCONFIG
    type (mlSChunk_T), dimension(:), pointer          :: CHUNKS
    integer, intent(in)                               :: CHUNKNO
    type (HGrids_T), dimension(:), pointer            :: HGrids

    ! -----     Declarations for Fill and internal subroutines     -------

    logical, parameter :: DEEBUG = .FALSE.                 ! Usually FALSE

    ! -999.99 ! Same as %template%badvalue
    real, parameter ::    UNDEFINED_VALUE = DEFAULTUNDEFINEDVALUE

    ! Local variables

    type (vectorValue_T), pointer :: APRIORIPRECISION
    type (vectorValue_T), pointer :: AQUANTITY
    type (vectorValue_T), pointer :: BASELINEQUANTITY
    type (vectorValue_T), pointer :: BNDPRESSQTY
    type (vector_T),      pointer :: DESTVECTOR
    type (vectorValue_T), pointer :: BQUANTITY
    type (vectorValue_T), pointer :: EARTHRADIUSQTY
    type (vectorValue_T), pointer :: ECRTOFOV
    type (vectorValue_T), pointer :: FIELDECR
    type (vectorValue_T), pointer :: FLAGQTY
    type (vectorValue_T), pointer :: GEOCALTITUDEQUANTITY
    type (vectorValue_T), pointer :: GPHQUANTITY
    type (vectorValue_T), pointer :: H2OPRECISIONQUANTITY
    type (vectorValue_T), pointer :: H2OQUANTITY
    type (vectorValue_T), pointer :: LOSQTY
    type (vectorValue_T), pointer :: LSB
    type (vectorValue_T), pointer :: LSBFRACTION
    type (vectorValue_T), pointer :: MEASQTY
    type (vector_T),      pointer :: MEASVECTOR
    type (vectorValue_T), pointer :: MINNORMQTY
    type (vectorValue_T), pointer :: MODELQTY
    type (vector_T),      pointer :: MODELVECTOR
    type (vectorValue_T), pointer :: NBWQUANTITY
    type (vectorValue_T), pointer :: NOISEQTY
    type (vector_T),      pointer :: NOISEVECTOR
    type (vectorValue_T), pointer :: NORMQTY
    type (vectorValue_T), pointer :: NULLQUANTITY
    type (vectorValue_T), pointer :: ODQUANTITY              ! optical depth
    type (vectorValue_T), pointer :: ORBITINCLINATIONQUANTITY
    type (vectorValue_T), pointer :: PHITANQUANTITY
    type (vectorValue_T), pointer :: PRECISIONQUANTITY
    type (vectorValue_T), pointer :: PTANQUANTITY
    type (vectorValue_T), pointer :: RADQUANTITY
    type (vectorValue_T), pointer :: QUANTITY ! Quantity to be filled
    type (vectorValue_T), pointer :: RADIANCEQUANTITY
    type (vectorValue_T), pointer :: RATIOQUANTITY
    type (vectorValue_T), pointer :: REFGPHQUANTITY
    type (vectorValue_T), pointer :: REFGPHPRECISIONQUANTITY
    type (vectorValue_T), pointer :: RHIPRECISIONQUANTITY
    type (vectorValue_T), pointer :: SCECIQUANTITY
    type (vectorValue_T), pointer :: SCVELQUANTITY
    type (vectorValue_T), pointer :: SOURCEQUANTITY
    type (vector_T),      pointer :: SOURCEVECTOR
    type (vectorValue_T), pointer :: SYSTEMPQUANTITY
    type (vectorValue_T), pointer :: TEMPERATUREQUANTITY
    type (vectorValue_T), pointer :: TEMPPRECISIONQUANTITY
    type (vectorValue_T)          :: TEMPSWAPQUANTITY
    type (vectorValue_T), pointer :: TOTALPOWERQUANTITY
    type (vectorValue_T), pointer :: TNGTECIQUANTITY
    type (vectorValue_T), pointer :: USB
    type (vectorValue_T), pointer :: USBFRACTION
    type (vectorValue_T), pointer :: VMRQTY

    type (Matrix_T), dimension(:), pointer :: SNOOPMATRICES
    type (Matrix_T), pointer :: ONEMATRIX

    type(next_tree_node_state) :: State ! of tree traverser

    logical :: ADDITIONAL               ! Flag for binMax/binMin
    integer(c_intptr_t) :: Addr         ! For tracing
    logical :: ALLOWMISSING             ! Flag from l2cf
    integer :: APRPRECQTYINDEX          ! Index of apriori precision quantity
    integer :: APRPRECVCTRINDEX         ! Index of apriori precision vector
    integer :: AQTYINDEX                ! Index of a quantity in vector
    logical :: ASPERCENTAGE             ! Flag for noRadsPerMIF
    logical :: AUTOFILL                 ! Flag for automatically filling qtys
    integer :: AVECINDEX                ! Index of a vector
    character(len=256) :: AVOIDOBJECTS  ! Which bright objects to avoid
    real(r8) :: BADRANGE(2)             ! Range for 'missing' data value
    integer :: BASELINEQTYINDEX
    integer :: BASELINEVCTRINDEX
    integer :: BINNAME                  ! Name of an l2pc bin
    integer :: BNDPRESSQTYINDEX
    integer :: BNDPRESSVCTRINDEX
    integer :: BOMASK                   ! Set Prec. neg. if which BO in FOV
    integer :: BONUM
    character(len=80) :: BOOLEANNAME    ! E.g., 'BQTYS'
    integer :: BOXCARMETHOD             ! l_min, l_max, l_mean
    integer :: BQTYINDEX                ! Index of a quantity in vector
    integer :: BVECINDEX                ! Index of a vector
    logical :: carryover
    character(len=32) :: cvalue
    real(rv) :: C                       ! constant "c" in manipulation
    logical :: CENTERVERTICALLY         ! For bin based fills
    integer :: CHANNEL                  ! For spreadChannels fill
    integer :: CHANNELSNODE
    integer :: COLMABUNITS              ! l_DOBSONUNITS, or l_MOLCM2
    integer :: COLVECTOR                ! Vector defining columns of Matrix
    type(matrix_SPD_T), pointer :: Covariance
    integer :: DESTINATIONVECTORINDEX   ! For transfer commands
    !                                     -- for Covariance
    integer :: EARTHRADIUSQTYINDEX
    integer :: EARTHRADIUSVECTORINDEX
    character(len=256) :: EXTRAOBJECTS  ! Which bright objects to avoid
    logical :: Debug
    integer :: Diagonal                 ! Index of diagonal vector in database
    !                                     -- for Covariance
    character(len=16) :: DIMLIST        ! 's', 'c', or 'i' in manipulation's shift
    logical :: DONTLATCH                ! Dont latch supplied heights to quantity's own
    logical :: DONTMASK                 ! Use even masked values if TRUE
    integer :: ECRTOFOVQUANTITYINDEX    ! Rotation matrix
    integer :: ECRTOFOVVECTORINDEX      ! Rotation matirx
    integer :: ERRORCODE                ! 0 unless error; returned by called routines
    logical :: EXACT                    ! Set STATUS to value exactly, don't OR bits
    logical :: EXCLUDEBELOWBOTTOM       ! If set in binmax/binmin does not consider stuff below bottom
    logical :: ExpandMask               ! Flag for transfer
    character(len=16)  :: explicitUnit  ! E.g., DU
    integer :: Expr_Type                ! From expr
    logical :: Extinction               ! Flag for cloud extinction calculation
    integer :: FIELDINDEX               ! Entry in tree
    integer :: Field
    integer :: FieldValue               ! Value of a field in the L2CF
    integer :: FIELDECRQUANTITYINDEX    ! Magnetic field
    integer :: FIELDECRVECTORINDEX      ! Magnetic field
    integer :: FILLMETHOD               ! How will we fill this quantity
    integer :: FILENAME                 ! String index for ascii fill
    integer :: FLAGQTYINDEX
    integer :: FLAGVECTORINDEX
    logical :: FORCE                    ! Fill in as many (instances) as will fit
    integer :: SHAPENODE              ! For the parser
    integer :: FRACTION                 ! Index of fraction vector in database
    logical :: FROMPRECISION            ! Fill from l2gpPrecision not l2gpValue
    integer :: GEOCALTITUDEQUANTITYINDEX    ! In the source vector
    integer :: GEOCALTITUDEVECTORINDEX      ! In the vector database
    integer :: GLOBALUNIT               ! To go into the vector
    character(len=16) :: GLSTR          ! geo. loc. in manipulation='..'
    integer :: GPHQUANTITYINDEX         ! In the source vector
    integer :: GPHVECTORINDEX           ! In the vector database
    logical, dimension(field_first:field_last) :: GOT
    type(GriddedData_T), pointer :: Grid
    integer :: GRIDINDEX                ! Index of requested grid
    integer :: GSON                     ! Descendant of Son
    integer :: HEIGHTNODE               ! Descendant of son
    character(len=8) :: HEIGHTRANGE     ! 'above', 'below', or ' '
    type(hessian_T), pointer :: hessian
    integer :: HESSIANINDEX             ! An index into the hessians
    integer :: HESSIANTOFILL             ! Index in database
    logical :: HIGHBOUND                ! Flag
    integer :: H2OQUANTITYINDEX         ! in the quantities database
    integer :: H2OVECTORINDEX           ! In the vector database
    integer :: H2OPRECISIONQUANTITYINDEX         ! in the quantities database
    integer :: H2OPRECISIONVECTORINDEX           ! In the vector database
    integer :: J                        ! Loop indices for section, spec, expr
    logical :: IGNOREGEOLOCATION        ! Don't copy geolocation to vector qua
    logical :: IGNORENEGATIVE           ! Don't sum chi^2 at values of noise < 0
    logical :: IGNORETEMPLATE           ! Don't check compatible--just fill values
    logical :: IGNOREZERO               ! Don't sum chi^2 at values of noise = 0
    integer :: INTERNALVGRIDINDEX       ! Index for internal vgrid (wmoTrop)
    real(r8) :: INTEGRATIONTIME         ! For estimated noise
    logical :: INTERPOLATE              ! Flag for l2gp etc. fill
    integer :: INSTANCESNODE            ! Tree node
    logical :: INVERT                   ! "Invert the specified covariance matrix"
    logical :: ISPRECISION              ! l1b precision, not radiances if TRUE
    integer :: KEY                      ! Definitely n_named
    type (L1BData_T) :: l1bField ! L1B data
    type (MLSFile_T), pointer             :: L1BFile
    integer :: L2AUXINDEX               ! Index into L2AUXDatabase
    integer :: L2GPINDEX                ! Index into L2GPDatabase
    integer :: LastAprioriPCF = 1
    integer :: LastClimPCF    = 1
    integer :: LastDAOPCF     = 1
    integer :: LastGEOS5PCF   = 1
    integer :: LastHeightPCF  = 1
    integer :: LastNCEPPCF    = 1
    integer :: LENGTHSCALE              ! Index of lengthscale vector in database
    logical :: LOGSPACE                 ! Interpolate in log space?
    integer :: LOSVECTORINDEX           ! index in vector database
    integer :: LOSQTYINDEX              ! index in QUANTITY database
    logical :: LOWBOUND                 ! Flag
    integer :: LSBVECTORINDEX           ! Index in vector database
    integer :: LSBQUANTITYINDEX         ! Index in vector database
    integer :: LSBFRACTIONVECTORINDEX   ! Index in vector database
    integer :: LSBFRACTIONQUANTITYINDEX ! Index in vector database
    type(matrix_Cholesky_T) :: MATRIXCHOLESKY
    type(matrix_Kronecker_T) :: MATRIXKRONECKER
    type(matrix_SPD_T) :: MATRIXSPD
    type(matrix_T) ::     MATRIXPLAIN
    real(r8) :: MAXVALUE                ! Value of f_maxValue field
    integer :: MAXVALUEUNIT             ! Unit for f_maxValue field
    integer :: MANIPULATION             ! String index
    type(matrix_T), pointer :: MATRIX
    integer :: MATRIXTOFILL             ! Index in database
    integer :: MATRIXTYPE               ! Type of matrix, L_... from init_tables
    integer :: MAXITERATIONS            ! For hydrostatic fill
    integer :: Me = -1                  ! String index for trace
    integer :: Me_FillCommand = -1      ! String index for trace
    integer :: Me_FlagCloud = -1        ! String index for trace
    integer :: Me_RestrictRange = -1    ! String index for trace
    integer :: Me_Spec = -1             ! String index for trace
    integer :: Me_Subset = -1           ! String index for trace
    integer :: Me_UpdateMask = -1       ! String index for trace
    integer :: Me_Transfer = -1         ! String index for trace
    integer :: MEASQTYINDEX
    integer :: MEASVECTORINDEX
    character(len=80) :: MESSAGE        ! Possible error message
    integer :: MINNORMQTYINDEX
    integer :: MINNORMVECTORINDEX
    integer :: MODELQTYINDEX
    integer :: MODELVECTORINDEX
    character(len=16)  :: MOL  ! E.g., H2O
    real, dimension(2) :: MULTIPLIER   ! To scale source,noise part of addNoise
    real(r8) :: MINVALUE                 ! Value of f_minValue field
    integer :: MINVALUEUNIT              ! Unit for f_minValue field
    logical :: MISSINGGMAO              ! Only if missing GMAO
    type (MLSFile_T), pointer   :: MLSFILE
    integer :: MULTIPLIERNODE           ! For the parser
    integer :: NBO
    integer :: NBWVECTORINDEX           ! In vector database
    integer :: NBWQUANTITYINDEX         ! In vector database
    integer :: NEEDEDCOORDINATE         ! For vGrid fills
    integer :: NOFINEGRID               ! no of fine grids for cloud extinction calculation
    integer :: NOISEQTYINDEX
    integer :: NOISEVECTORINDEX
    logical :: noPCFid                  ! Obey file='..' w/o recourse to PCF
    logical :: noZeros                  ! Don't allow 0-valued Precisions
    integer :: NORMQTYINDEX
    integer :: NORMVECTORINDEX
    integer :: NOSNOOPEDMATRICES        ! No matrices to snoop
    real(rv) :: OFFSETAMOUNT            ! For offsetRadiance
    logical :: OLD_MATH77_RAN_PACK      ! To restore math77_ran_pack
    character(len=16) :: OPTIONS
    integer :: ORBITINCLINATIONVECTORINDEX ! In the vector database
    integer :: ORBITINCLINATIONQUANTITYINDEX ! In the quantities database
    integer :: PCBottom
    integer :: PCTop
    integer :: PHITANVECTORINDEX        ! In the vector database
    integer :: PHITANQUANTITYINDEX      ! In the quantities database
    real(r8) :: PHIWINDOW(2)            ! For hydrostatic ptan guesser
    real(r8) :: PHIZERO                 ! For hydrostatic ptan guesser
    integer :: PHIWINDOWUNITS           ! For hydrostatic ptan guesser
    real(r8) :: PRECISIONFACTOR         ! For setting -ve error bars
    integer :: PRECISIONQUANTITYINDEX   ! For precision quantity
    integer :: PRECISIONVECTORINDEX     ! In the vector database
    integer :: PROFILE                  ! A single profile
    integer :: PTANVECTORINDEX          ! In the vector database
    integer :: PTANQUANTITYINDEX        ! In the quantities database
    logical :: QUADRATURE               ! Apply baseline in quadrature
    integer :: QUANTITYINDEX            ! Within the vector
    integer :: RADIANCEQUANTITYINDEX    ! For radiance quantity
    integer :: RADIANCEVECTORINDEX      ! For radiance quantity
    integer :: RATIOQUANTITYINDEX       ! in the quantities database
    integer :: RATIOVECTORINDEX         ! In the vector database
    logical :: REFRACT                  ! Do refraction in phiTan fill
    integer :: REFGPHQUANTITYINDEX      ! in the quantities database
    integer :: REFGPHVECTORINDEX        ! In the vector database
    integer :: REFGPHPRECISIONQUANTITYINDEX      ! in the quantities database
    integer :: REFGPHPRECISIONVECTORINDEX        ! In the vector database
    logical :: REPEATLOOP               ! Do we repeat this section?
    real(rv) :: replaceMissingValue     ! hat do we replace missing Values with?
    logical :: RESET
    logical :: RESETSEED                ! Let mls_random_seed choose new seed
    integer :: RHIPRECISIONQUANTITYINDEX         ! in the quantities database
    integer :: RHIPRECISIONVECTORINDEX           ! In the vector database
    integer :: ROWVECTOR                ! Vector defining rows of Matrix
    integer :: S                        ! Size in bytes of object to deallocate
    real(r8) :: SCALE                   ! Scale factor
    real(r8) :: SCALEINSTANCES          ! Scale factor for weighted LS fill
    real(r8) :: SCALERATIO              ! Scale factor for weighted LS fill
    real(r8) :: SCALESURFS              ! Scale factor for weighted LS fill
    integer :: SCECIQUANTITYINDEX       ! In the quantities database
    integer :: SCECIVECTORINDEX         ! In the vector database
    integer :: SCVELQUANTITYINDEX       ! In the quantities database
    integer :: SCVELVECTORINDEX         ! In the vector database
    character(len=256) :: sdname
    integer, dimension(2) :: SEED       ! integers used by random_numbers
    integer :: SEEDNODE                 ! For the parser
    integer, dimension(2) :: SHP
    logical :: SKIPMASK                 ! Flag for transfer
    logical :: SKIPValues               ! Flag for transfer
    integer :: SON                      ! Of root, an n_spec_args or a n_named
    integer :: SOURCE                   ! l_rows or l_colums for adoption
    logical :: SOURCEMASK               ! obey Masking bits from source
    integer :: SOURCETYPE               ! String index
    integer :: SOURCEQUANTITYINDEX      ! in the quantities database
    integer :: SOURCEVECTORINDEX        ! In the vector database
    logical :: SKIPFILL                 ! Don't execute Fill command
    logical :: SPREADFLAG               ! Do we spread values accross instances in explict
    integer :: STATUS                   ! Flag from allocate etc.
    integer :: STATUSVALUE              ! Vaue of f_status
!   logical :: STRICT                   ! Maximize checking
    ! integer :: SUPERDIAGONAL            ! Index of superdiagonal matrix in database
    integer :: SURFNODE                 ! Descendant of son
    logical :: SWITCH2INTRINSIC         ! Have mls_random_seed call intrinsic
    !                                     -- for Covariance
    real :: T1                          ! for timing
    integer :: SYSTEMPQUANTITYINDEX     ! in the quantities database
    integer :: SYSTEMPVECTORINDEX       ! in the vector database
    integer :: SUFFIX                   ! Possible suffix in reading L1BData
    integer :: TEMPERATUREQUANTITYINDEX ! in the quantities database
    integer :: TEMPERATUREVECTORINDEX   ! In the vector database
    integer :: TEMPPRECISIONQUANTITYINDEX ! in the quantities database
    integer :: TEMPPRECISIONVECTORINDEX   ! In the vector database
    integer :: TEMPLATEINDEX            ! In the template database
    integer :: TERMSNODE                ! Tree index
    logical :: TIMING
    integer :: TNGTECIQUANTITYINDEX     ! In the quantities database
    integer :: TNGTECIVECTORINDEX       ! In the vector database
    integer :: TOTALPOWERQUANTITYINDEX    ! In the quantities database
    integer :: TOTALPOWERVECTORINDEX      ! In the vector database
    integer, dimension(2) :: UNITASARRAY ! From expr
    integer :: USBVECTORINDEX           ! Inddex in vector database
    integer :: USBQUANTITYINDEX         ! Inddex in vector database
    integer :: USBFRACTIONVECTORINDEX   ! Index in vector database
    integer :: USBFRACTIONQUANTITYINDEX ! Index in vector database
    integer :: Value
    real(r8), dimension(2) :: VALUEASARRAY ! From expr
    integer :: VALUESNODE               ! For the parser
    integer :: VECTORINDEX              ! In the vector database
    integer :: VECTORNAME               ! Name of vector to create
    integer :: VGRIDINDEX               ! Index of sourceVGrid
    integer :: VMRQTYINDEX
    integer :: VMRQTYVCTRINDEX
    logical :: WHEREFILL                ! Replace only fill values
    logical :: WHERENOTFILL             ! Don't replace fill values
    integer, parameter :: whereRange  = 0
    integer :: WIDTH                    ! Width of boxcar
    logical :: verbose
    logical :: verboser

    ! Executable code
    timing = section_times
    if ( timing ) call time_now ( t1 )
    old_math77_ran_pack = math77_ran_pack

    call trace_begin ( me, "MLSL2Fill", root, cond=toggle(gen) )
    if ( specialDumpFile /= ' ' ) &
      & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )

    verbose = ( switchDetail(switches, 'grid' ) > -1 )
    verboser = ( switchDetail(switches, 'grid' ) > 0 )
    call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
      & 'carryover', cvalue, countEmpty=countEmpty, &
      & inseparator=runTimeValues%sep )
    carryover = ( index(lowercase(cvalue), 't') > 0 )
    if ( verbose ) call dumpMacros
    if ( verboser ) call outputNamedValue( 'carryover', carryover )
    if ( .not. carryover ) then
      LastAprioriPCF = mlspcf_l2apriori_start - 1
      lastClimPCF = mlspcf_l2clim_start - 1
      lastDAOPCF = mlspcf_l2dao_start - 1
      lastNCEPPCF = mlspcf_l2ncep_start - 1
      lastGEOS5PCF = mlspcf_l2geos5_start - 1
      LastHeightPCF = mlspcf_surfaceHeight_start - 1
    end if
    if ( verboser ) call outputNamedValue ( 'mlspcf_l2geos5_start', mlspcf_l2geos5_start )
    if ( verboser ) call outputNamedValue ( 'lastGEOS5PCF', lastGEOS5PCF )
    if ( verboser ) call outputNamedValue ( 'LastClimPCF', LastClimPCF )
    if ( verboser ) call outputNamedValue ( 'carryOver', carryOver )
    ! Don't initialize field values here--instead place them after the do below
    fillerror = 0
    templateIndex = -1
    vectorIndex = -1
    maxIterations = 4
    repeatLoop = .false. ! By default, we will not repeat
    call InitializeRepeat

    ! If the Command Repeat is within the section
    ! and Repeat(key) is evaluated as true, e.g.
    ! Repeat, Boolean=OK ; or you give it a list to repeat over
    ! Repeat, values=["a", "amigo", "3", "4-sassafras"]
    repeat_loop: do ! RepeatLoop
    ! Loop over the lines in the configuration file

    do 
      son = next_tree_node ( root, state )
      if ( son == 0 ) exit
      call trace_begin ( me_spec, "Fill.spec", son, &
        & cond=toggle(gen) .and. levels(gen) > 0 )
      call get_label_and_spec ( son, vectorName, key )
      L2CFNode = key
      if ( MLSSelecting .and. &
        & .not. any( get_spec_id(key) == (/ s_endselect, s_select, s_case /) ) ) cycle
      ! Initialize fields
      additional = .false.
      allowMissing = .false.
      asPercentage = .false.
      autoFill = .false.
      boxCarMethod = l_mean
      c = 0.
      centerVertically = .false.
      channel = 0
      channelsNode = 0
      colmabunits = l_molcm2 ! default units for column abundances
      dontLatch = .false.
      dontMask = .false.
      exact = .false.
      excludeBelowBottom = .false.
      extinction = .false.
      fillMethod = l_none
      force = .false.
      fromPrecision = .false.
      GLStr = ' '
      got= .false.
      heightNode = 0
      heightRange = ' '
      ignoreZero = .false.
      ignoreNegative = .false.
      ignoreGeolocation = .false.
      ignoreTEMPLATE = .false.
      instancesNode = 0
      interpolate = .false.
      invert = .false.
      isPrecision = .false.
      manipulation = 0
      maxValue = huge(0.0_r8)
      maxValueUnit = 0
      minValue = -huge(0.0_r8)
      minValueUnit = 0
      MissingGMAO = .false.
      logSpace = .false.
      noPCFid = .false.
      noZeros = .false.
      options = ' '
      replaceMissingValue = 0.
      reset = .false.
      resetSeed = .false.
      refract = .false.
      scale = 0.0
      scaleInstances = -1.0
      scaleRatio = 1.0
      scaleSurfs = -1.0
      sourcemask = .false.
      sourceType = 0
      spreadFlag = .false.
!     strict = .false.
      surfNode = 0
      switch2intrinsic = .false.
      suffix = 0
      seed = 0
      noFineGrid = 1
      precisionFactor = 0.5
      offsetAmount = 1000.0             ! Default to 1000K
      profile = -1
      phiWindow = [ 1, 2 ] ! One before tangent, two after
      phiWindowUnits = phyq_angle
      phiZero = 0.0
      quadrature = .false.
      skipFill = .false.
      statusValue = 0
      whereFill = .false.
      whereNotFill = .false.
      nullify ( nullQuantity, ptanQuantity, radQuantity, odQuantity )

      do j = 2, nsons(key) ! fields of the "time" specification
        gson = subtree(j, key)
        field = get_field_id(gson)   ! tree_checker prevents duplicates
        if (nsons(gson) > 1 ) gson = subtree(2,gson) ! Gson is value
        select case ( field )
        case ( f_reset )
          reset = Get_Boolean ( gson )
        case default
          ! Shouldn't get here if the type checker worked
        end select
      end do ! j = 2, nsons(key)
      ! Node_id(key) is now n_spec_args.

      if ( get_spec_id(key) /= s_catchWarning ) &
        & call MLSMessageReset( clearLastWarning=.true. )
      select case( get_spec_id(key) )
      case ( s_vector ) ! ===============================  Vector  =====
        got = .false.
        globalUnit = PHYQ_Invalid
        lowBound = .false.
        highBound = .false.
        do j = 2, nsons(key)
          son = subtree(j,key)              ! The field
          fieldIndex = get_field_id(son)
          got(fieldIndex) = .true.
          if ( nsons(son) > 1 ) then
            fieldValue = decoration(subtree(2,son)) ! The field's value
          else
            fieldValue = son
          end if
          select case ( fieldIndex )
          case ( f_template )
            templateIndex = decoration(decoration(subtree(2,son)))
          case ( f_autoFill )
            autoFill = get_boolean ( fieldValue )
          case ( f_lengthScale )
            if ( get_boolean(fieldValue) ) globalUnit = phyq_length
          case ( f_fraction )
            if ( get_boolean(fieldValue) ) globalUnit = phyq_dimensionless
          case ( f_lowBound )
            lowBound = get_boolean ( fieldValue )
          case ( f_highBound )
            highBound = get_boolean ( fieldValue )
          end select
        end do

        if ( all(got((/f_lengthScale,f_fraction/))) ) &
          & call Announce_Error ( key, bothFractionAndLength )
        ! Create the vector, and add it to the database.
        call decorate ( key, AddVectorToDatabase ( vectors, &
          & CreateVector ( vectorName, vectorTemplates(templateIndex), &
          & qtyTemplates, globalUnit=globalUnit, highBound=highBound, lowBound=lowBound, &
          & where=where(key) ) ) )
        ! That's the end of the create operation
        ! Do we want to autofill any of its qtys?
        if ( autoFill .and. associated(vectors) ) &
          & call AutoFillVector ( vectors(size(vectors)) )

      case ( s_anygoodvalues )
        call decorate ( key, &
          & BooleanFromAnyGoodValues ( key, vectors ) )
      case ( s_anygoodradiances )
        call decorate ( key, &
          & BooleanFromAnyGoodRadiances ( key, chunks(chunkNo), filedatabase ) )
      case ( s_select ) ! ============ Start of select .. case ==========
        ! We'll start seeking a matching case
        call MLSSelect (key)
      case ( s_case ) ! ============ seeking matching case ==========
        ! We'll continue seeking a match unless the case is TRUE
        call MLSCase (key)
      case ( s_delete )
        call DeleteGriddedData ( key, griddedDatabase )
        if ( DumpDBFootPrint ) call Dump ( griddedDataBase, Details=-4 )
      case ( s_endSelect ) ! ============ End of select .. case ==========
        ! We'done with seeking a match
        call MLSEndSelect (key)
      case ( s_catchWarning )
        call decorate ( key,  BooleanFromCatchWarning ( key ) )
      case ( s_ChunkEndsBefore )
        call decorate ( key, &
          & BooleanFromChunkEndsBefore ( key, chunks(ChunkNo), griddedDatabase ) )
      case ( s_IsGridEmpty )
        call decorate ( key, &
          & BooleanFromEmptyGrid ( key, griddedDataBase ) )
      case ( s_ChunkStartsAfter )
        call decorate ( key, &
          & BooleanFromChunkStartsAfter ( key, chunks(ChunkNo), griddedDatabase ) )
      case ( s_compare )
        call decorate ( key,  BooleanFromComparingQtys ( key, vectors ) )
      case ( s_computeTotalPower )
        call ComputeTotalPower ( key, vectors )
      case ( s_concatenate )
        call decorate ( key, AddgriddedDataToDatabase ( griddedDataBase, &
          & Concatenate ( key, griddedDataBase ) ) )
        if ( DumpDBFootPrint ) call Dump ( griddedDataBase, Details=-4 )
      case ( s_ConvertEtaToP )
        call decorate ( key, AddgriddedDataToDatabase ( griddedDataBase, &
          & ConvertEtaToP ( key, griddedDataBase ) ) )
        if ( DumpDBFootPrint ) call Dump ( griddedDataBase, Details=-4 )
      case ( s_merge )
        call decorate ( key, AddgriddedDataToDatabase ( griddedDataBase, &
          & MergeOneGrid ( key, griddedDataBase ) ) )
        if ( DumpDBFootPrint ) call Dump ( griddedDataBase, Details=-4 )
      case ( s_concatenateGrids, s_mergeGrids )
        ! We must get "grid" field from command
        do j = 2, nsons(key)
          gson = subtree(j, key)
          select case ( decoration(subtree(1, gson) ) )
          case ( f_grid )
            value = decoration ( decoration ( subtree(2, gson) ) )
          case default
          end select
        enddo
        grid => griddedDataBase(value)
        call DestroyGriddedData( grid )
        if ( get_spec_id(key) == s_mergeGrids ) then
          grid = MergeOneGrid ( key, griddedDataBase )
        else
          grid = Concatenate ( key, griddedDataBase )
        endif
        if ( verbose ) then
          call output( 'The GriddedDatabase, ' )
          call outputNamedValue( 'size(db)', size(griddedDataBase) )
          call outputNamedValue( 'our index', value )
          call outputNamedValue( 'is it empty?', grid%empty )
        endif
        if ( DumpDBFootPrint ) call Dump ( griddedDataBase, Details=-4 )
      case ( s_Reevaluate )
        call decorate ( key,  BooleanFromFormula ( 0, key, vectors ) )
      case ( s_diff, s_dump ) ! ======================== Diff, Dump ==========
        ! Handle disassociated pointers by allocating them with zero size
        status = 0
        if ( .not. associated(qtyTemplates) ) allocate ( qtyTemplates(0), stat=status )
        call test_allocate ( status, moduleName, 'QtyTemplates', (/0/), (/0/) )
        if ( .not. associated(vectorTemplates) ) allocate ( vectorTemplates(0), stat=status )
        call test_allocate ( status, moduleName, 'VectorTemplates', (/0/), (/0/) )
        if ( .not. associated(vectors) ) allocate ( vectors(0), stat=status )
        call test_allocate ( status, moduleName, 'Vectors', (/0/), (/0/) )
        call dumpCommand ( key, qtyTemplates, vectorTemplates, vectors, &
          & GriddedDataBase=GriddedDataBase, hGrids=hGrids, &
          & FileDataBase=FileDataBase, &
          & MatrixDatabase=Matrices, HessianDatabase=Hessians )
      case ( s_execute ) ! ======================== ExecuteCommand ==========
        call ExecuteCommand ( key )
      case ( s_Gridded, s_ReadGriddedData )
        call processOneAprioriFile ( key, L2GPDatabase, L2auxDatabase, &
          & GriddedDatabase, fileDataBase, &
          & LastAprioriPCF , &
          & LastClimPCF    , &
          & LastDAOPCF     , &
          & LastGEOS5PCF   , &
          & LastHeightPCF  , &
          & LastNCEPPCF     &
            )
        if ( DumpDBFootPrint ) call Dump ( griddedDataBase, Details=-4 )
      case ( s_hessian ) ! ===============================  Hessian  =====
        got = .false.
        do j = 2, nsons(key)
          gson = subtree(j,key)              ! The field
          fieldIndex = get_field_id(gson)
          got(fieldIndex) = .true.
          if ( nsons(gson) > 1 ) &
            & fieldValue = decoration(subtree(2,gson)) ! The field's value
          select case ( fieldIndex )
          case ( f_columns )
            colVector = decoration(fieldValue)
          case ( f_rows )
            rowVector = decoration(fieldValue)
          end select
        end do
        if ( got(f_columns) .and. got(f_rows) ) then
          ! We decorate with a negative number to differentiate hessians from
          ! Jacobians when it comes time to write them out
          ! *******************************************
          ! The above is an enormously bad idea
          ! The pronounced justification fails because
          ! Hessians and Jacobians are stored in separate databases
          ! databases.
          ! Long term: Don't decorate with a negative number
          ! which was an unacceptably crude hack even if it had been
          ! necessary, which it was not
          ! *******************************************
          call decorate ( key, -addHessianToDatabase(hessians, &
            & createEmptyHessian ( vectorName, &
            & vectors(rowVector), vectors(colVector), where=where(key) )) )
        else
          call announce_error ( key, missingField, &
            & extraInfo = (/ f_columns, f_rows /) )
        end if

      case ( s_Repeat ) ! ============================== Repeat ==========
        ! We'll Repeat the section as long as the Boolean cond'n is TRUE
        RepeatLoop = Repeat(key)
        ! call outputNamedValue ( 'repeat loop?', repeatLoop )
        if ( .not. RepeatLoop ) exit repeat_loop
        call nextRepeat
      case ( s_skip ) ! ============================== Skip ==========
        ! We'll skip the rest of the section if the Boolean cond'n is TRUE
        if ( Skip(key) ) exit repeat_loop
      case ( s_wmoTropFromGrids )
        ! We must get "grid" field from command
        do j = 2, nsons(key)
          gson = subtree(j, key)
          select case ( decoration(subtree(1, gson) ) )
          case ( f_grid )
            value = decoration ( decoration ( subtree(2, gson) ) )
          case default
          end select
        enddo
        grid => griddedDataBase(value)
        call DestroyGriddedData( grid )
        grid = wmoTropFromGrid ( key, griddedDataBase )
        if ( DumpDBFootPrint ) call Dump ( griddedDataBase, Details=-4 )
      case ( s_matrix ) ! ===============================  Matrix  =====
        got = .false.
        matrixType = l_plain
        do j = 2, nsons(key)
          gson = subtree(j,key)              ! The field
          fieldIndex = get_field_id(gson)
          got(fieldIndex) = .true.
          if ( nsons(gson) > 1 ) &
            & fieldValue = decoration(subtree(2,gson)) ! The field's value
          select case ( fieldIndex )
          case ( f_columns )
            colVector = decoration(fieldValue)
          case ( f_rows )
            rowVector = decoration(fieldValue)
          case ( f_type )
            matrixType = fieldValue
          end select
        end do
        if ( got(f_columns) .and. (got(f_rows) .or. matrixType == l_spd) ) then
          select case ( matrixType )
          case ( l_cholesky )
            call NullifyMatrix ( matrixCholesky%m )
            call createEmptyMatrix ( matrixCholesky%m, vectorName, &
              & vectors(rowVector), vectors(colVector), where=where(key) )
            call decorate ( key, addToMatrixDatabase(matrices, matrixCholesky) )
          case ( l_kronecker )
            call NullifyMatrix ( matrixKronecker%m )
            call createEmptyMatrix ( matrixKronecker%m, vectorName, &
              & vectors(rowVector), vectors(colVector), where=where(key) )
            call decorate ( key, addToMatrixDatabase(matrices, matrixKronecker) )
          case ( l_plain )
            call NullifyMatrix ( matrixPlain )
            call createEmptyMatrix ( matrixPlain, vectorName, vectors(rowVector), &
              vectors(colVector), where=where(key) )
            call decorate ( key, addToMatrixDatabase(matrices, matrixPlain) )
          case ( l_spd )
            call NullifyMatrix ( matrixSPD%m )
            call createEmptyMatrix ( matrixSPD%m, vectorName, &
              & vectors(colVector), vectors(colVector), where=where(key) )
            call decorate ( key, addToMatrixDatabase(matrices, matrixSPD) )
          end select
        else
          call announce_error ( key, missingField, &
            & extraInfo = (/ f_columns, f_rows /) )
        end if

      case ( s_subset )
        call trace_begin ( me_subset, "Fill.subset", root, &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        call SetupSubset ( key, vectors )
        call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )

      case ( s_restrictRange )
        call trace_begin ( me_restrictRange, "Fill.RestrictRange", root, &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        call RestrictRange ( key, vectors )
        call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )

      case ( s_flushL2PCBins )
        call FlushLockedBins

      case ( s_flushPFA )
        call flush_PFAData ( key, status )
        fillerror = max(fillerror,status)

      case ( s_load )
        got = .false.
        do j = 2, nsons(key)
          gson = subtree(j,key)              ! The field
          fieldIndex = get_field_id(gson)
          got(fieldIndex) = .true.
          select case ( fieldIndex )
          case ( f_matrix )
            matrixToFill = decoration(decoration( subtree(2, gson) ))
            if ( getKindFromMatrixDatabase(matrices(matrixToFill)) /= k_plain ) &
              call announce_error ( key, notPlain )
          case ( f_hessian )
            hessianToFill = decoration(decoration( subtree(2, gson) ))
          case ( f_vector )
            vectorIndex = decoration(decoration( subtree(2, gson) ))
          case ( f_bin )
            binName = sub_rosa ( subtree(2,gson) )
          case ( f_source )
            source = decoration ( subtree(2,gson) )
          end select
        end do
        if ( got ( f_hessian ) ) then
          if ( got ( f_vector ) ) call Announce_Error ( key, no_Error_Code, &
            & 'Cannot load both vector and hessian (Why not?)' )
          Hessian => hessians(hessianToFill)
          call LoadHessian ( Hessian, binName, message )
          if ( len_trim(message) > 0 ) call output( '* * *' // message, advance='yes' )
          if ( got ( f_matrix ) ) then
            call GetFromMatrixDatabase ( matrices(matrixToFill), matrix )
            call LoadMatrix ( matrix, binName, message )
          endif
        elseif ( got ( f_matrix ) ) then
          if ( got ( f_vector ) ) call Announce_Error ( key, no_Error_Code, &
            & 'Cannot load both vector and matrix (Why not?)' )
          call GetFromMatrixDatabase ( matrices(matrixToFill), matrix )
          call LoadMatrix ( matrix, binName, message )
          if ( len_trim(message) > 0 ) call output( '* * *' // message, advance='yes' )
        else if ( got ( f_vector ) ) then
          if ( .not. got ( f_source ) ) call Announce_Error ( key, no_Error_Code, &
            & 'Must supply source=rows/columns for vector adoption' )
          call LoadVector ( vectors(vectorIndex), binName, source, message )
        else
          call Announce_Error ( key, no_Error_Code, &
            & 'Must supply hessian, matrix or vector to adopt' )
        end if
        if ( len_trim(message) /= 0 ) &
          & call Announce_Error ( key, no_Error_Code, trim(message) )

      case ( s_populateL2PCBin )
        got = .false.
        do j = 2, nsons(key)
          gson = subtree(j,key)              ! The field
          fieldIndex = get_field_id(gson)
          got(fieldIndex) = .true.
          select case ( fieldIndex )
          case ( f_bin )
            call PopulateL2PCBinByName ( sub_rosa ( subtree(2,gson) ) )
          end select
        end do

      case ( s_updateMask )
        call trace_begin ( me_updateMask, "Fill.UpdateMask", root, &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        call UpdateMask ( key, vectors )
        call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )

      case ( s_flagCloud )
        call trace_begin ( me_flagCloud, "Fill.flagCloud", root, &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        call SetupflagCloud ( key, vectors )
        call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )

      case ( s_directRead ) ! =======================  directRead  =====
        call directReadCommand
      case ( s_fill ) ! ===================================  Fill  =====
        call trace_begin ( me_fillCommand, "Fill.fillCommand", key, &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        call fillCommand
        call trace_end ( cond=toggle(gen) .and. levels(gen) > 1 )
      case ( s_fillcovariance ) ! ===================  Covariance  =====
        invert = .false. ! Default if the field isn't present
        lengthScale = 0
        fraction = 0
        do j = 2, nsons(key)
          gson = subtree(j,key) ! The argument
          fieldIndex = get_field_id(gson)
          if ( nsons(gson) > 1) gson =  &
            & decoration(decoration(subtree(2,gson))) ! Now value of said argument
          select case ( fieldIndex )
          case ( f_matrix )
            matrixToFill = gson
            if ( getKindFromMatrixDatabase(matrices(matrixToFill)) /= k_spd ) &
              call announce_error ( key, notSPD )
          case ( f_diagonal )
            diagonal = gson
          case ( f_ignoreTemplate )
            ignoreTemplate = get_boolean ( gson )
          case ( f_lengthScale )
            lengthScale = gson
          case ( f_fraction )
            fraction = gson
            call announce_error ( key, notImplemented, "Decay" ) !???
          case ( f_invert )
            invert = get_boolean ( gson )
          !      case ( f_superDiagonal )
          !        superDiagonal = gson
          !        call announce_error ( key, notImplemented, "SuperDiagonal" ) !???
          end select
        end do

        call getFromMatrixDatabase ( matrices(matrixToFill), covariance )
        if ( L2Options%Skipretrieval ) then
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'Unable to fill covariance when skipping retrievals' )
        else
          call FillCovariance ( covariance, &
            & vectors, diagonal, lengthScale, fraction, invert, ignoreTemplate )
        endif

      case ( S_FILLDIAGONAL ) ! ===============  Diagonal  =====
        do j = 2, nsons(key)
          gson = subtree(j,key) ! The argument
          fieldIndex = get_field_id(gson)
          if ( nsons(gson) > 1) gson = &
            & decoration(decoration(subtree(2,gson))) ! Now value of said argument
          select case ( fieldIndex )
          case ( f_matrix )
            matrixToFill = gson
            if ( getKindFromMatrixDatabase(matrices(matrixToFill)) /= k_spd ) &
              call announce_error ( key, notSPD )
          case ( f_diagonal )
            diagonal = gson
          end select
        end do

        call getFromMatrixDatabase ( matrices(matrixToFill), covariance )
        call getDiagonal( covariance%m, vectors(diagonal))

      ! End of fill operations

      case ( s_destroy ) ! ===============================  Destroy ==
        call destroyCommand ( key, matrices, vectors, griddedDataBase )

      case ( s_negativePrecision ) ! =======================  negativePrecision ==
        ! Here we're on a setNegative instruction
        ! Loop over the instructions
        skipMask = .false.
        do j = 2, nsons(key)
          gson = subtree(j,key)  ! The argument
          fieldIndex = get_field_id(gson)
          if ( nsons(gson) > 1 ) then
            gson = subtree(2,gson) ! Now the value of said argument
            fieldValue = decoration(gson) ! The field's value
          else
            fieldValue = gson
          end if
          select case ( fieldIndex )
          case ( f_precision )
            precisionVectorIndex = decoration(fieldValue)
          case ( f_aprioriPrecision )
            aprPrecVctrIndex =  decoration(fieldValue)
          case ( f_noZeros )
            noZeros = get_boolean ( gson )
          case ( f_precisionFactor )
            call expr ( gson , unitAsArray, valueAsArray )
            precisionFactor = valueAsArray(1)
          case default ! Can't get here if type checker worked
          end select
        end do
        if ( vectors(precisionVectorIndex)%template%name /= &
          & vectors(aprPrecVctrIndex)%template%name ) then
          call Announce_error ( key, no_error_code, &
            & 'Incompatible vectors in negativePrecision statement' )
        else
          do j = 1, vectors(precisionVectorIndex)%template%noQuantities
            where ( vectors(precisionVectorIndex)%quantities(j)%values > &
              & vectors(aprPrecVctrIndex)%quantities(j)%values * precisionFactor )
              vectors(precisionVectorIndex)%quantities(j)%values = &
                & - vectors(precisionVectorIndex)%quantities(j)%values
            end where
            if ( .not. noZeros ) cycle
            ! Enforce noZeros by resetting all 0 to -1
            where ( vectors(precisionVectorIndex)%quantities(j)%values == 0._rv )
              vectors(precisionVectorIndex)%quantities(j)%values = -1._rv
            end where
          end do
        end if

      case ( s_phase ) ! ===============================  Phase ==
        ! Set the name for this phase
        debug = LetsDebug ( 'phase', 4 )
        call addPhaseToPhaseNames ( vectorname, key )
        if ( debug ) then
          call SwitchOutput ( 'stdout' )
          call Dump( OutputOptions )
          call Dump( StampOptions )
          call DumpConfig
          call RevertOutput
        endif
 
      case ( s_changeSettings ) ! ===============================  changeSettings ==
        ! Change settings for this phase
        call addPhaseToPhaseNames ( 0, key )
        debug = LetsDebug ( 'phase', 4 )
        if ( debug ) then
          call SwitchOutput ( 'stdout' )
          call Dump( OutputOptions )
          call Dump( StampOptions )
          call DumpConfig
          call RevertOutput
        endif

      case ( s_transfer ) ! ===============================  Transfer ==
        ! Here we're on a transfer instruction
        ! Loop over the instructions
        call trace_begin ( me_transfer, "Fill.Transfer", key, &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        nullify( destVector, measvector, modelvector, noisevector, sourceVector )
        ExpandMask = .false.
        interpolate = .false.
        skipMask = .false.
        skipValues = .false.
        booleanName = ' '
        do j = 2, nsons(key)
          gson = subtree(j,key)  ! The argument
          fieldIndex = get_field_id(gson)
          got(fieldIndex) = .true.
          if ( nsons(gson) > 1 ) then
            gson = subtree(2,gson) ! Now the value of said argument
            fieldValue = decoration(gson) ! The field's value
          else
            fieldValue = gson
          end if
          select case ( fieldIndex )
          case ( f_a )
            aVecIndex = decoration(fieldValue)
          case ( f_b )
            bVecIndex = decoration(fieldValue)
          case(f_c)
            call expr ( gson, unitAsArray, valueAsArray )
            c = valueAsArray(1)
          case ( f_source )
            sourceVectorIndex = decoration(fieldValue)
            sourceVector => vectors( sourceVectorIndex )
          case ( f_destination )
            destinationVectorIndex = decoration(fieldValue)
            destVector => vectors( destinationVectorIndex )
          case ( f_dontLatch )
            dontLatch = get_boolean ( gson )
          case ( f_dontMask )
            dontMask = get_boolean ( gson )
          case ( f_ExpandMask )
            ExpandMask = get_boolean ( gson )
          case ( f_ignoreNegative )
            ignoreNegative = get_boolean ( gson )
          case ( f_ignoreZero )
            ignoreZero = get_boolean ( gson )
          case ( f_interpolate )
            interpolate = get_boolean ( gson )
          case ( f_manipulation )
            manipulation = sub_rosa ( gson )
          case ( f_method )   ! How ? (if not default copy)
            fillMethod = decoration(gson)
          case ( f_measurements )   ! Only used for diagnostic special fills
            measVectorIndex = decoration(fieldValue)
            measVector => vectors( measVectorIndex )
          case ( f_model )   ! Only used for diagnostic special fills
            modelVectorIndex = decoration(fieldValue)
            modelVector => vectors( modelVectorIndex )
          case ( f_noise )   ! Only used for chi^2 special fills or addnoise
            noiseVectorIndex = decoration(fieldValue)
            noiseVector => vectors( noiseVectorIndex )
          case ( f_PtanQuantity ) ! For minorframe qty
            PtanVectorIndex = decoration(decoration(subtree(1,gson)))
            PtanQuantityIndex = &
              & decoration(decoration(decoration(subtree(2,gson))))
          case (f_quantityNames)
            call get_string ( sub_rosa(gson), booleanName, strip=.true. )
            booleanName = lowerCase(booleanName)
          case ( f_skipMask )
            skipMask = get_boolean ( gson )
          case ( f_skipValues )
            skipValues = get_boolean ( gson )
          case default ! Can't get here if type checker worked
          end select
        end do
        if ( got(f_a) ) then
          if ( .not. got(f_b) ) bVecIndex = aVecIndex
          if ( got(f_c) ) then
            call ManipulateVectors ( manipulation, &
              & vectors(destinationVectorIndex), &
              & vectors(aVecIndex), vectors(bVecIndex), c, &
              & booleanName=booleanName )
          else
            call ManipulateVectors ( manipulation, &
              & vectors(destinationVectorIndex), &
              & vectors(aVecIndex), vectors(bVecIndex), &
              & booleanName=booleanName )
          endif
        else if ( fillMethod /= l_none ) then
          if ( got ( f_ptanQuantity )  ) then
            ptanQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(ptanVectorIndex), ptanQuantityIndex)
          endif
          call TransferVectorsByMethod ( key, destvector, &
            & sourceVector, fillMethod, dontMask, interpolate, &
            & ignorenegative, ignoreZero, measVector, modelVector, &
            & noiseVector, ptanQuantity, booleanName )
        else if ( got(f_source) ) then
          call TransferVectors ( vectors(sourceVectorIndex), &
            & vectors(destinationVectorIndex), &
            & expandMask, skipMask, skipValues, interpolate, booleanName )
        else
          call MLSL2Message ( MLSMSG_Error, ModuleName, &
            & 'Transfer command requires either source or a to be present' )
        end if
        call trace_end ( "Fill.Transfer", cond=toggle(gen) .and. levels(gen) > 1 )

      case ( s_time ) ! ===================================  Time  =====
        if ( timing .and. .not. reset ) then
          call sayTime ( 'Fill', t1=t1, cumulative=.false. )
        else
          call time_now ( t1 )
          timing = .true.
        end if

      case ( s_snoop )
        ! Generate a matrix database
        noSnoopedMatrices = 0
        if ( associated ( matrices ) ) then
          do j = 1, size ( matrices )
            call GetActualMatrixFromDatabase ( matrices(j), oneMatrix )
            if ( associated ( oneMatrix ) ) &
              & noSnoopedMatrices = noSnoopedMatrices + 1
          end do
        end if
        allocate ( snoopMatrices ( noSnoopedMatrices ), STAT=status )
        addr = 0
        if ( status == 0 .and. noSnoopedMatrices>0 ) &
          addr = transfer(c_loc(snoopMatrices(1)), addr )
        call test_allocate ( status, moduleName, 'snoopMatrices', &
          & uBounds = noSnoopedMatrices, &
          & elementSize = storage_size(snoopMatrices) / 8, address=addr )
        if ( associated ( matrices ) ) then
          noSnoopedMatrices = 1
          do j = 1, size ( matrices )
            call GetActualMatrixFromDatabase ( matrices(j), oneMatrix )
            if ( associated ( oneMatrix ) ) then
              ! This is a shallow copy
              snoopMatrices(noSnoopedMatrices) = oneMatrix
              noSnoopedMatrices = noSnoopedMatrices + 1
            end if
          end do
        end if
        call Snoop ( key=key, vectorDatabase=vectors, &
          & matrixDatabase=snoopMatrices )
        do j = 1, size ( snoopMatrices )
          ! The assignment from oneMatrix to snoopMatrices(.) is a shallow
          ! copy.  We do this so that the matrix finalizer doesn't
          ! deallocate out from under the real matrix database....
!     The following is probably necessary to make final subroutines for
!     RC_Info and Matrix_T work, else the finalizers deallocate targets
!     out from under pointers in the matrix database... but it causes a
!     crash.  I don't know why.
!           call nullifyMatrix ( snoopMatrices(j) )
        end do
        s = size(snoopMatrices) * storage_size(snoopMatrices) / 8
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(snoopMatrices(1)), addr)
        deallocate ( snoopMatrices, STAT=status )
        call test_deallocate ( status, moduleName, 'snoopMatrices', s, address=addr )

      case ( s_StreamlineHessian ) ! =============== StreamlineHessian =====
        call doStreamline

      ! End of fill operations

      case default ! Can't get here if tree_checker worked correctly
      end select
      call trace_end ( "Fill.spec", cond=toggle(gen) .and. levels(gen) > 0 )
    end do ! End of loop of specs
    if ( .not. repeatLoop ) exit ! Otherwise, we will repeat the section
    end do  repeat_loop!  RepeatLoop

    if ( fillError /= 0 ) then
      call MLSL2Message ( MLSMSG_Error, ModuleName, 'Problem with Fill section' )
    end if

    if ( specialDumpFile /= ' ' ) call revertOutput
    call trace_end ( "MLSL2Fill", cond=toggle(gen) )
    math77_ran_pack = old_math77_ran_pack
    if ( timing ) call sayTime ( 'Fill', cumulative=.false. )

  ! =====     Internal Procedures     ==================================

  contains

    ! ---------------------------------------------- DoStreamline  -----
    subroutine DoStreamline
      use Init_Tables_Module, only: F_Geodangle, F_Hessian, &
        & F_Scaleheight, F_Surface, F_Threshold
      real(r8) :: GEODANGLE        ! For StreamlineHessian
      integer :: J                 ! Loop index
      real(r8) :: SCALEHEIGHT      ! Scale height for StreamlineHessian
      integer :: SURFACE           ! Number of surfaces for StreamlineHessian
      real(r8) :: THRESHOLD
      geodAngle = -1.0   ! means "not specified"
      scaleHeight = -1.0 ! means "not specified"
      surface = -1       ! means "not specified"
      threshold = -1.0   ! means "not specified"
      do j = 2, nsons(key)
        gson = subtree(j,key) ! The argument
        fieldIndex = get_field_id(gson)
        select case ( fieldIndex )
        case ( f_geodAngle )
          call expr ( subtree(2,gson), unitAsArray, valueAsArray )
          geodAngle = valueAsArray(1)
        case ( f_hessian )
          hessianIndex = -decoration(decoration(subtree(2,gson)))
        case ( f_scaleHeight )
          call expr ( subtree(2,gson), unitAsArray, valueAsArray )
          scaleHeight = valueAsArray(1)
        case ( f_surface )
          call expr ( subtree(2,gson), unitAsArray, valueAsArray )
          surface = valueAsArray(1)
        case ( f_threshold )
          call expr ( subtree(2,gson), unitAsArray, valueAsArray )
          threshold = valueAsArray(1)
        end select
      end do
      call StreamlineHessian ( hessians ( hessianIndex ), &
        & surface, scaleHeight, geodAngle, threshold )
    end subroutine DoStreamline

    ! ------------------------------------------------ directReadCommand -----
    subroutine directReadCommand
      use DirectWrite_m, only: DirectRead
      use L2PC_M, only: ReadCompleteHDF5L2PCFile
      ! Now we're on actual directRead instructions.
      character(len=1024) :: BoolKey      ! The boolean's key
      logical, parameter :: DEEBUG = .false.
      integer :: EXPRUNITS(2)             ! From expr
      real (r8) :: EXPRVALUE(2)           ! From expr
      integer :: fieldIndex
      integer :: file                     ! Index into string table
      integer :: fileType
      character(len=8) :: fileTypeStr
      logical :: geolocation
      character(len=32) :: groupName
      integer :: gson
      ! integer :: hdfversion
      logical :: interpolate
      integer :: j
      integer :: rank
      character(len=32) :: sdname
      logical :: spread
      type (vector_T), pointer :: Vector
      ! Loop over the instructions to the directRead command
      geolocation= .false.
      got = .false.
      ! hdfVersion = DEFAULT_HDFVERSION_READ
      file = 0
      groupName = ' '
      options = ' '
      binname = 0
      rank = 0
      sdname = ' '
      spread = .false.
      interpolate = .false.
      if ( DEEBUG ) call output ( 'In DirectReadCommand', advance='yes' )
      do j = 2, nsons(key)
        gson = subtree(j,key) ! The argument
        fieldIndex = get_field_id(gson)
        if ( nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
        got(fieldIndex)=.TRUE.
        select case ( fieldIndex )
        case ( f_Boolean )
          call get_string ( sub_rosa(gson), BoolKey, strip=.true. )
          BoolKey = lowerCase(BoolKey)
          call GetHashElement( runTimeValues%lkeys, runTimeValues%lvalues, &
            & trim(BoolKey), groupName, countEmpty, &
            & inseparator=runTimeValues%sep )
        case ( f_quantity )
          vectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_vector )
          vectorIndex = decoration(decoration(gson))
          if ( DEEBUG ) call output ( 'Processing vector field', advance='yes' )
        case ( f_matrix )
          matrixToFill = decoration(decoration(gson))
          if ( DEEBUG ) call output ( 'Processing matrix field', advance='yes' )
        case ( f_hessian )
          hessianToFill = decoration(decoration(gson))
          if ( DEEBUG ) call output ( 'Processing hessian field', advance='yes' )
        !case ( f_hdfVersion )
        !  if ( DEEBUG ) call output ( 'Begin Processing hdfversion field', advance='yes' )
        !  call expr ( gson, exprUnits, exprValue )
        !  if ( DEEBUG ) call output ( 'Processing hdfversion field', advance='yes' )
        !  if ( exprUnits(1) /= phyq_dimensionless ) &
        !    & call Announce_error ( son, NO_ERROR_CODE, &
        !    & 'No units allowed for hdfVersion: just integer 4 or 5')
        !  hdfVersion = exprValue(1)
        case ( f_bin )
          binName = sub_rosa ( gson )
        case ( f_file )
          file = sub_rosa(gson)
          if ( DEEBUG ) call outputNamedValue ( 'Processing file field', file )
        case ( f_geolocation )
            geolocation = get_boolean ( gson )
        case ( f_groupName )
          if ( DEEBUG ) call output ( 'Begin Processing groupName field', advance='yes' )
          call get_string ( sub_rosa(gson), groupName, strip=.true. )
          if ( DEEBUG ) call output ( 'Processing groupName field', advance='yes' )
        case ( f_options )
          if ( DEEBUG ) call output ( 'Begin Processing options field', advance='yes' )
          call get_string ( sub_rosa(gson), options, strip=.true. )
          if ( DEEBUG ) call output ( 'Processing options field', advance='yes' )
        case ( f_sdName )
          if ( DEEBUG ) call output ( 'Begin Processing sdName field', advance='yes' )
          call get_string ( sub_rosa(gson), sdName, strip=.true. )
          if ( DEEBUG ) call output ( 'Processing sdName field', advance='yes' )
        case ( f_interpolate )
            interpolate = get_boolean ( gson )
        case ( f_noPCFid )
            noPCFid = get_boolean ( gson )
        case ( f_rank )
          call expr ( gson, exprUnits, exprValue )
          if ( exprUnits(1) /= phyq_dimensionless ) &
            & call Announce_error ( son, NO_ERROR_CODE, &
            & 'No units allowed for rank: just integer 1, 2, or 3')
          rank = exprValue(1)
          ! call outputnamedValue ( 'rank field', rank )
        case ( f_spread )
            spread = get_boolean ( gson )
        case ( f_type )
          if ( DEEBUG ) call output ( 'Begin Processing type field', advance='yes' )
          fileType = decoration(gson)
          call get_string ( lit_indices(fileType), fileTypeStr, strip=.true. )
          if ( DEEBUG ) call output ( 'Processing type field', advance='yes' )
        end select
      end do
      if ( geolocation ) options = trim(options) // 'g'
      if ( DEEBUG ) call output ( 'Done processing fields', advance='yes' )
      if ( .not. got(f_file) ) call Announce_error ( key, 0, 'No file supplied' )
      if ( .not. got(f_type) ) call Announce_error ( key, 0, 'No type supplied' )
      if ( .not. any( (/ &
        & got(f_quantity), got(f_vector), got(f_matrix), got(f_hessian) /) ) )&
        & call Announce_error ( key, 0, &
        & 'Must supply one of matrix, quantity or vector' )
      if ( DEEBUG ) call output ( 'About to  get_file_name', advance='yes' )
      if ( lowercase(fileTypeStr) == 'quantity' .or. &
        &  lowercase(fileTypeStr) == 'hdf' ) then
          PCBottom = mlspcf_ElevOffset_start
          PCTop    = mlspcf_Misc_end
      else
          PCBottom = mlspcf_l2apriori_start
          PCTop    = mlspcf_l2apriori_end
      endif
      call get_file_name ( file, PCBottom, &
            & fileType, filedatabase, MLSFile, &
            & 'DirectRead File not found in PCF', PCTop )
      if ( DEEBUG ) call output ( 'Done with get_file_name', advance='yes' )
      if ( got(f_quantity) ) then
        quantity => GetVectorQtyByTemplateIndex( &
          & vectors(vectorIndex), quantityIndex )
        if ( lowercase(fileTypeStr) == 'quantity' ) then
          MLSFile%type = l_hdf
          MLSFile%content = 'quantity'
          MLSFile%hdfversion = HDFVERSION_5
          call DirectRead ( MLSFile, quantity, sdName, &
            & chunkNo, options, rank )
        else
          call QtyFromFile ( key, quantity, MLSFile, &
            & filetypestr, options, sdName, spread, interpolate )
        endif
      elseif ( got ( f_hessian ) ) then
        Hessian => hessians(hessianToFill)
        call ReadCompleteHDF5L2PCFile ( MLSFile, key, shallow=.false. )
        call LoadHessian ( Hessian, binName, message )
        if ( len_trim(message) > 0 ) call output( '* * *' // message, advance='yes' )
        if ( got ( f_matrix ) ) then
          call GetFromMatrixDatabase ( matrices(matrixToFill), matrix )
          call LoadMatrix ( matrix, binName, message )
        endif
      elseif ( got(f_matrix) ) then
        if ( .not. got(f_bin) ) call Announce_error ( key, 0, 'No bin supplied' )
        call GetFromMatrixDatabase ( matrices(matrixToFill), matrix )
        call ReadCompleteHDF5L2PCFile ( MLSFile, key, shallow=.false. )
        call LoadMatrix ( matrix, binName, message )
        if ( len_trim(message) > 0 ) call output( '* * *' // message, advance='yes' )
      else
        vector => vectors(vectorIndex)
        call VectorFromFile ( key, vector, MLSFile, &
          & filetypestr, options, spread, interpolate, groupName )
      end if
    end subroutine directReadCommand

    ! ----------------------------------------------  FillCommand  -----
    subroutine FillCommand
    ! Now we're on actual Fill instructions.
      use Declaration_Table, only: Base_Unit, Range
      ! use DUMP_0, only: DUMP
      use Init_Tables_Module, only: L_Geodetic, L_None
      use Intrinsic, only: Lit_Indices, T_Boolean, T_Numeric
      use String_Table, only: Display_String
      use Vector_Qty_Expr_M, only: Dot, Vector_Qty_Expr
      use Vectorsmodule, only: DestroyVectorquantityMask, DestroyVectorquantityValue, &
        & Dump_Vector_Quantity
      double precision :: Number
      integer :: Stat
      logical, parameter :: DONTPAD = .false.
      integer :: fieldValue
      integer :: Geolocation
      integer :: hGridIndex
      integer :: I, IBo
      integer :: J
      integer :: JJ
      integer :: L1BFLAG
      integer :: MAF
      integer :: MUL
      integer :: NOMAFS
      integer :: NOSURFS
      integer, dimension(3) :: START, COUNT, STRIDE, BLOCK
      logical :: QTYWASMASKED
      real(kind(valueAsArray)) :: ReferenceMIF
      integer :: ReferenceMIFunits
      logical :: Regular  ! Magnetif field is coherent and stacked
      type(vectorValue_T) :: TEMPQUANTITY  ! For storing original qty's mask
      integer :: TheUnits
      ! Executable
      ! Loop over the instructions to the Fill command
      BOMask = 0
      AvoidObjects = ' '
      dimList = 'c' ! defaults to shift or slip by channel, or surface if noFreqs < 2
      geolocation = l_geodetic
      got = .false.
      hGridIndex = 0
      multiplier = 1.
      referenceMIF = 1
      referenceMIFunits = PHYQ_Dimensionless
      regular = .false.
      start = 0
      count = 0
      stride = 0
      block = 0
      do j = 2, nsons(key)
        gson = subtree(j,key) ! The argument
        if ( nsons(gson) > 1 ) then
          fieldValue = decoration(subtree(2,gson)) ! The field's value
        else
          fieldValue = gson
        end if
        fieldIndex = get_field_id(gson)
        if ( nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
        got(fieldIndex)=.TRUE.
        select case ( fieldIndex )
        case ( f_a )
          aVecIndex = decoration(decoration(subtree(1,gson)))
          aQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_additional )
          additional = get_boolean ( gson )
        case ( f_allowMissing )
          allowMissing = get_boolean ( gson )
        case ( f_aprioriPrecision )
          aprPrecVctrIndex = decoration(decoration(subtree(1,gson)))
          aprPrecQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_asPercentage )
          asPercentage = get_boolean ( gson )
        case ( f_avoidBrightObjects )
          call get_string( sub_rosa(gson), extraObjects, strip=.true. )
          avoidObjects = catLists( avoidObjects, extraObjects )
        case ( f_b )
          bVecIndex = decoration(decoration(subtree(1,gson)))
          bQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_badRange )
          call expr ( gson , unitAsArray, valueAsArray )
          badRange = valueAsArray
        case ( f_baselineQuantity )
          baselineVctrIndex = decoration(decoration(subtree(1,gson)))
          baselineQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_boxCarMethod )
          boxCarMethod = decoration(gson)
        case ( f_boundaryPressure )     ! For special fill of columnAbundance
          bndPressVctrIndex = decoration(decoration(subtree(1,gson)))
          bndPressQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case(f_c)
          call expr ( gson , unitAsArray, valueAsArray )
          c = valueAsArray(1)
        case ( f_channel )
          call expr ( gson , unitAsArray, valueAsArray )
          channel = valueAsArray(1)
        case ( f_channels )
          channelsNode = son
        case ( f_centerVertically )
          centerVertically = get_boolean ( gson )
        case ( f_dimList )
          ! dimList = sub_rosa ( gson )
          call get_string ( sub_rosa ( gson ), dimList, strip=.true. )
          dimList = lowercase( dimList )
        case ( f_earthRadius ) ! For losGrid fill
          earthRadiusVectorIndex = decoration(decoration(subtree(1,gson)))
          earthRadiusQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_excludeBelowBottom )
          excludeBelowBottom = get_boolean ( gson )
        case ( f_ECRToFOV ) ! For hydrostatic
          ecrToFOVVectorIndex = decoration(decoration(subtree(1,gson)))
          ecrToFOVQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_exact )
          exact = get_boolean ( gson )
        case ( f_explicitValues ) ! For explicit fill
          valuesNode = subtree(j,key)
        case ( f_expr )
!         valuesNode = subtree(j,key)
          do jj = 2, nsons(subtree(j,key))
            stat = vector_qty_expr ( subtree(jj,subtree(j,key)), vectors, tempQuantity, &
            number, theUnits, 'Fill' )
            select case ( stat )
            case ( t_numeric )
              call output ( number, before='Numeric value of "expr" field = ' )
              if ( theUnits /= phyq_dimensionless ) &
              call display_string ( lit_indices(base_unit(theUnits)), &
                & before=' ', advance='yes' )
            case ( t_boolean )
              call display_string ( lit_indices(nint(number)), &
                & before='Value of "expr" field = ', advance='yes' )
            case ( dot )
              call output ( 'Got vector qty result', advance='yes' )
              call dump_vector_quantity ( tempQuantity, details=1, name='Quantity value of "expr" field' )
              call destroyVectorQuantityMask ( tempQuantity )
              call destroyVectorQuantityValue ( tempQuantity )
            case default
              call output ( 'Got Vector_Qty_Expr_Error', advance='yes' )
            end select
          end do
          call Announce_Error ( gson, noCodeFor, extraInfo=(/ f_expr /) )
        case ( f_extinction ) ! For cloud extinction fill
          extinction = get_boolean ( gson )
        case ( f_fieldECR ) ! For hydrostatic
          fieldECRVectorIndex = decoration(decoration(subtree(1,gson)))
          fieldECRQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_file ) ! For asciifile
          filename = sub_rosa ( gson )
        case ( f_flags ) ! For chi^2 ratio
          flagVectorIndex = decoration(decoration(subtree(1,gson)))
          flagQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_force )
          force = get_boolean ( gson )
        case ( f_shape )
          shapeNode = subtree(j,key)
        case ( f_fromPrecision )
          fromPrecision = get_boolean ( gson )
        case ( f_geocAltitudeQuantity ) ! For hydrostatic or magnetic field fill
          geocAltitudeVectorIndex = decoration(decoration(subtree(1,gson)))
          geocAltitudeQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_geolocation )
          geolocation = decoration(gson)
        case ( f_gphQuantity ) ! For gphResetToGeoid fill
          gphVectorIndex = decoration(decoration(subtree(1,gson)))
          gphQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_height )
          heightNode = subtree(j,key)
        case ( f_h2oQuantity ) ! For hydrostatic or rhi
          h2oVectorIndex = decoration(decoration(subtree(1,gson)))
          h2oQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_h2oPrecisionQuantity ) ! For rhi precision
          h2oPrecisionVectorIndex = decoration(decoration(subtree(1,gson)))
          h2oPrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_dontLatch )
          dontLatch = get_boolean ( gson )
        case ( f_dontMask )
          dontMask = get_boolean ( gson )
        case ( f_heightRange )
          manipulation = sub_rosa ( gson )
          heightRange = ' '
          ! If heightRange field was present, it should have been one of
          ! 'a[bove]' meaning fill heights above supplied value
          ! 'b[elow]' meaning fill heights below supplied value
          call get_string ( manipulation, heightRange, strip=.true. )
          select case ( heightRange(1:1) )
          case ( 'a' )
            heightRange = 'above'
          case ( 'b' )
            heightRange = 'below'
          case ( ' ' )
            heightRange = ' '
          case default
            call Announce_Error ( key, no_Error_Code, &
            & 'invalid heightRange: ' // trim(heightRange) )
          end select
        case ( f_hGrid )   ! For geoLocation
          hGridIndex = decoration(fieldValue)
        case ( f_ignoreZero )
          ignoreZero = get_boolean ( gson )
        case ( f_ignoreGeolocation ) ! For l2gp etc. fill
          ignoreGeolocation =get_boolean ( gson )
        case ( f_ignoreNegative )
          ignoreNegative = get_boolean ( gson )
        case ( f_ignoreTemplate )
          ignoreTemplate = get_boolean ( gson )
        case ( f_ifMissingGMAO )
          MissingGMAO = get_boolean ( gson ) .and. &
            & ( APrioriFiles%dao // AprioriFiles%ncep  // AprioriFiles%geos5 &
            &   == ' ' )
        case ( f_instances )
          instancesNode = subtree(j,key)
        case ( f_integrationTime )
          call expr ( gson , unitAsArray, valueAsArray )
          integrationTime = valueAsArray(1)
        case ( f_internalVGrid )
          internalVGridIndex=decoration(decoration(gson))
        case ( f_interpolate ) ! For l2gp etc. fill
          interpolate =get_boolean ( gson )
        case ( f_intrinsic )
          switch2intrinsic = get_boolean ( gson )
!         case ( f_invert )
!           invert = get_boolean ( gson )
        case ( f_isPrecision )
          isPrecision = get_boolean ( gson )
        case ( f_logSpace )
          logSpace = get_boolean ( gson )
        case ( f_losQty ) ! For losGrid fill
          losVectorIndex = decoration(decoration(subtree(1,gson)))
          losQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_lsb ) ! For folding
          lsbVectorIndex = decoration(decoration(subtree(1,gson)))
          lsbQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_lsbFraction ) ! For folding
          lsbFractionVectorIndex = decoration(decoration(subtree(1,gson)))
          lsbFractionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_manipulation )
          manipulation = sub_rosa ( gson )
        case ( f_maxIterations )      ! For hydrostatic fill
          call expr ( gson , unitAsArray, valueAsArray )
          maxIterations = valueAsArray(1)
        case ( f_maxValue )      ! For status fill
          call expr ( gson, unitAsArray, valueAsArray )
          maxValueUnit = unitAsArray(1)
          maxValue = valueAsArray(1)
        case ( f_measurements )   ! Only used for diagnostic special fills
          measVectorIndex = decoration(decoration(subtree(1,gson)))
          measQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_method )   ! How are we going to fill it?
          fillMethod = decoration(gson)
        case ( f_minNormQty )   ! Only used for chi^2 ratio fills
          minNormVectorIndex = decoration(decoration(subtree(1,gson)))
          minNormQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_minValue )      ! For status fill
          call expr ( gson, unitAsArray, valueAsArray )
          minValueUnit = unitAsArray(1)
          minValue = valueAsArray(1)
        case ( f_model )   ! Only used for diagnostic special fills
          modelVectorIndex = decoration(decoration(subtree(1,gson)))
          modelQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_multiplier ) ! For scaling noise part of addnoise
          multiplierNode=subtree(j,key)
          ! Either multiplier = [a, b] or multiplier = b are possible
          multiplier = UNDEFINED_VALUE
          do jj=1, min(nsons(multiplierNode)-1, 2)
            call expr(subtree(jj+1,multiplierNode),unitAsArray,valueAsArray)
            multiplier(jj) = valueAsArray(1)
          end do
          if ( DEEBUG ) then
            call output('Using multipliers: ', advance='no')
            call output(multiplier, advance='yes')
          end if
        case ( f_noFineGrid )       ! For cloud extinction fill
          call expr ( gson , unitAsArray, valueAsArray )
          noFineGrid = valueAsArray(1)
        case ( f_noise )   ! Only used for chi^2 special fills or addnoise
          noiseVectorIndex = decoration(decoration(subtree(1,gson)))
          noiseQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_noiseBandwidth )
          nbwVectorIndex = decoration(decoration(subtree(1,gson)))
          nbwQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_normQty )          ! Only used for chi^2 ratio fills
          normVectorIndex = decoration(decoration(subtree(1,gson)))
          normQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_offsetAmount )     ! For marking unused radiances
          call expr ( gson , unitAsArray, valueAsArray )
          offsetAmount = valueAsArray(1)
        case ( f_orbitInclination ) ! For hydrostatic fill
          orbitinclInationVectorIndex = &
            & decoration(decoration(subtree(1,gson)))
          orbitinclInationQuantityIndex = &
            & decoration(decoration(decoration(subtree(2,gson))))
        case ( f_precision )        ! For masking l1b radiances
          precisionVectorIndex = decoration(decoration(subtree(1,gson)))
          precisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_precisionFactor )  ! For setting negative errors
          call expr ( gson, unitAsArray, valueAsArray )
          precisionFactor = valueAsArray(1)
        case ( f_profile )
          call expr ( gson , unitAsArray, valueAsArray )
          profile = valueAsArray(1)
        case ( f_profileValues )
          valuesNode = subtree(j,key)
        case ( f_PtanQuantity )     ! For minorframe qty
          PtanVectorIndex = decoration(decoration(subtree(1,gson)))
          PtanQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_Phitan )           ! For losGrid fill
          PhitanVectorIndex = decoration(decoration(subtree(1,gson)))
          PhitanQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_phiWindow )
          call expr ( gson, unitAsArray, valueAsArray, expr_type )
          phiWindow = valueAsArray
          if ( any ( phiWindow < 0 ) ) &
            & call Announce_error ( gson, negativePhiWindow )
          ! Make sure the window units are profiles or angle.  Allow one of
          ! them to be dimensionless if it's a range.
          if ( expr_type /= range ) unitAsArray(2) = unitAsArray(1)
          if ( unitAsArray(1) == PHYQ_Dimensionless ) unitAsArray(1) = unitAsArray(2)
          if ( unitAsArray(2) == PHYQ_Dimensionless ) unitAsArray(2) = unitAsArray(1)
          if ( unitAsArray(1) /= unitAsArray(2) .or. &
            & all ( unitAsArray(1) /= (/ PHYQ_Profiles, PHYQ_Angle /) ) ) &
            & call Announce_Error ( gson, wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Profiles, PHYQ_Angle/) )
          phiWindowUnits = unitAsArray(1)
          if ( expr_type /= range ) then ! only one valueAsArray was given
            if ( phiWindowUnits == PHYQ_Angle ) then
              ! Assume a symmetric window
              phiWindow(1) = 0.5 * valueAsArray(1)
              phiWindow(2) = phiWindow(1)
            else ! phiWindowUnits == PHYQ_Profiles
              ! Center the window with valueAsArray(1) total profiles.
              ! If even, put one more before the tangent than after it.
              phiWindow(2) = nint(valueAsArray(1)-1)/2 ! after tangent point
              phiWindow(1) = max(nint(valueAsArray(1)) - phiWindow(2) - 1,0.0_r8) ! before
            end if
          end if
        case ( f_phiZero )
          call expr ( gson , unitAsArray, valueAsArray )
          phiZero = valueAsArray(1)
        case ( f_quadrature )
          quadrature = get_boolean ( gson )
        case ( f_quantity )   ! What quantity are we filling quantity=vector.quantity
          vectorIndex = decoration(decoration(subtree(1,gson)))
          quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_radianceQuantity  ) ! For estimated noise
          radianceVectorIndex = decoration(decoration(subtree(1,gson)))
          radianceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_ratioQuantity )    ! For isotope ratio
          ratioVectorIndex = decoration(decoration(subtree(1,gson)))
          ratioQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_refract )
          refract = get_boolean ( gson )
        case ( f_refGPHQuantity )   ! For hydrostatic or rhi
          refGPHVectorIndex = decoration(decoration(subtree(1,gson)))
          refGPHQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_refGPHPrecisionQuantity ) ! For GPH precision
          refGPHPrecisionVectorIndex = decoration(decoration(subtree(1,gson)))
          refGPHPrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_referenceMIF )
          call expr ( gson, unitAsArray, valueAsArray, expr_type )
          referenceMIF = valueAsArray(1)
          referenceMIFunits = unitAsArray(1)
        case ( f_regular )
          regular = get_boolean ( gson )
        case(f_replaceMissingValue)
          call expr ( gson, unitAsArray, valueAsArray )
          replaceMissingValue = valueAsArray(1)
        case ( f_resetSeed )
          resetSeed = get_boolean ( gson )
        case ( f_rhiPrecisionQuantity ) ! For converting to h2o precision
          rhiPrecisionVectorIndex = decoration(decoration(subtree(1,gson)))
          rhiPrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_rhiQuantity ) ! For h2o from rhi
          sourceVectorIndex = decoration(decoration(subtree(1,gson)))
          sourceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_scale, f_scaleInsts, f_scaleRatio, f_scaleSurfs )
          call expr ( gson , unitAsArray, valueAsArray )
          select case ( fieldIndex )
          case ( f_scale )
            scale = valueAsArray(1)
          case ( f_scaleInsts )
            scaleInstances = valueAsArray(1)
          case ( f_scaleRatio )
            scaleRatio = valueAsArray(1)
          case ( f_scaleSurfs )
            scaleSurfs = valueAsArray(1)
          end select
        case ( f_scECI )                ! For special fill of losVel
          scECIVectorIndex = decoration(decoration(subtree(1,gson)))
          scECIQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_scVel )                ! For special fill of losVel
          scVelVectorIndex = decoration(decoration(subtree(1,gson)))
          scVelQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_scVelECI )             ! For special fill of losVel
          scVelVectorIndex = decoration(decoration(subtree(1,gson)))
          scVelQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_scVelECR )             ! For magnetic model and special fill of losVel
          scVelVectorIndex = decoration(decoration(subtree(1,gson)))
          scVelQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_seed ) ! For explicitly setting mls_random_seed
          seedNode=subtree(j,key)
        case ( f_sdname )
           call get_string ( sub_rosa ( gson ), sdName, strip=.true. )
        case ( f_source )
          sourceVectorIndex = decoration(fieldValue)
          sourceVector => vectors( sourceVectorIndex )
        case ( f_sourceL2AUX )          ! Which L2AUXDatabase entry to use
          l2auxIndex = decoration(decoration(gson))
        case ( f_sourceL2GP )           ! Which L2GPDatabase entry to use
          l2gpIndex=decoration(decoration(gson))
        case ( f_sourceMask )
          sourceMask = get_boolean ( gson )
        case ( f_sourceGrid )
          gridIndex=decoration(decoration(gson))
        case ( f_sourceQuantity )       ! When filling from a vector, what vector/quantity
          sourceVectorIndex = decoration(decoration(subtree(1,gson)))
          sourceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_sourceType )
          sourceType = sub_rosa ( gson )
        case ( f_sourceVGrid )
          vGridIndex=decoration(decoration(gson))
        case ( f_spread ) ! For explicit fill, note that gson here is not same as others
          spreadFlag = get_boolean ( gson )
        case ( f_start, f_count, f_stride, f_block ) ! For selecting hyperslab
          multiplierNode = subtree(j,key)
          ! Either start = [a, b] or start = b are possible
          do jj=1, min(nsons(multiplierNode)-1, 2)
            call expr( subtree(jj+1,multiplierNode), unitAsArray, valueAsArray )
            mul = valueAsArray(1)
            select case ( fieldIndex )
            case ( f_start )
              start(jj) = mul
            case ( f_count )
              count(jj) = mul
            case ( f_stride )
              stride(jj) = mul
            case ( f_block )
              block(jj) = mul
            end select
          end do
          if ( DEEBUG ) then
            call output('index start: ', advance='no')
            call output(valueAsArray, advance='yes')
          end if
        case ( f_status )
          valuesNode = subtree(j,key)
          call expr ( gson , unitAsArray, valueAsArray )
          statusValue = nint ( valueAsArray(1) )
        ! case ( f_strict )
        !   strict = get_boolean ( gson )
        case ( f_suffix )
          suffix = sub_rosa ( gson )
        case ( f_surface )
          surfNode = subtree(j,key)
        case ( f_systemTemperature )
          sysTempVectorIndex = decoration(decoration(subtree(1,gson)))
          sysTempQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_tngtECI )              ! For special fill of losVel
          tngtECIVectorIndex = decoration(decoration(subtree(1,gson)))
          tngtECIQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_temperatureQuantity ) ! For hydrostatic or rhi
          temperatureVectorIndex = decoration(decoration(subtree(1,gson)))
          temperatureQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_tempPrecisionQuantity ) ! For rhi precision
          tempPrecisionVectorIndex = decoration(decoration(subtree(1,gson)))
          tempPrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_terms )
          termsNode = subtree(j,key)
        case ( f_totalPowerQuantity )
          totalpowerVectorIndex = decoration(decoration(subtree(1,gson)))
          totalpowerQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_unit ) ! For folding
          colmabunits = decoration(gson) ! decoration(subtree(2,gson))
        case ( f_usb ) ! For folding
          usbVectorIndex = decoration(decoration(subtree(1,gson)))
          usbQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_usbFraction ) ! For folding
          usbFractionVectorIndex = decoration(decoration(subtree(1,gson)))
          usbFractionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_vmrQuantity )     ! For special fill of columnAbundance
          vmrQtyVctrIndex = decoration(decoration(subtree(1,gson)))
          vmrQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
        case ( f_whereFill )
          whereFill = get_boolean ( gson )
        case ( f_whereNotFill )
          whereNotFill = get_boolean ( gson )
        case ( f_width )
          call expr ( gson, unitAsArray, valueAsArray )
          width = valueAsArray(1)
        end select
      end do                  ! Loop over arguments to fill instruction
      ! Put various conditions under which you would want to skip this fill
      if ( got(f_ifMissingGMAO) .and. .not. MissingGMAO ) skipFill = .true.
      if ( skipFill ) fillMethod = -1 ! We'll assume no l_value can be this

      ! Now call various routines to do the filling
      ! This is the actual quantity we shall Fill
      quantity => GetVectorQtyByTemplateIndex( &
        & vectors(vectorIndex), quantityIndex )
      if ( got ( f_ptanQuantity )  ) then
        ptanQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(ptanVectorIndex), ptanQuantityIndex)
      endif

      ! However, we will first mask the quantity to account for
      ! any height, instances, etc. constraints you may have set
      qtyWasMasked = associated( quantity%mask )
      call CloneVectorQuantity ( tempQuantity, quantity )
      ! Ignore original mask if /dontMask 
      if ( qtyWasMasked .and. dontMask .and. fillMethod /= l_l1b ) &
        & quantity%mask = char(0)
      if ( any( fillMethod == (/ l_status, l_quality /) ) ) then
        call ApplyMaskToQuantity( quantity, &
          & radQuantity, ptanQuantity, odQuantity, nullQuantity, 0._r8, &
          & maxValue, minValue, -999.99_r8, &
          & heightRange, whereRange, &
          & .false., .false., additional=.true., expandMask=.false., reset=.false., &
          & maskBit=M_Fill, heightNode=0, surfNode=0, &
          & instancesNode=instancesNode, channelsNode=0, got=got )
      else
        call ApplyMaskToQuantity( quantity, &
          & radQuantity, ptanQuantity, odQuantity, nullQuantity, 0._r8, &
          & maxValue, minValue, -999.99_r8, &
          & heightRange, whereRange, &
          & .false., .false., additional=.true., expandMask=.false., reset=.false., &
          & maskBit=M_Fill, heightNode=heightNode, surfNode=surfNode, &
          & instancesNode=instancesNode, channelsNode=channelsNode, got=got )
      endif
      if ( heightNode /= 0 .and. DEEBUG ) call dumpQuantityMask ( quantity )
      ! Then we Fill the newly masked quantity
      select case ( fillMethod )
      case ( l_addNoise ) ! ----- Add random noise to source Quantity -------
        if ( DEEBUG) call output('add noise method', advance='yes')
        if ( .not. all(got( (/f_Quantity, f_sourceQuantity, f_noise/) ) ) ) &
          call Announce_error ( key, No_Error_code, &
           'Missing a required field to add noise'  )
        Quantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        noiseQty => GetVectorQtyByTemplateIndex( &
          & vectors(noiseVectorIndex), noiseQtyIndex)
        math77_ran_pack = .not. switch2intrinsic
        if ( DEEBUG ) then
          call output('Switch to intrinsic? ', advance='no')
          call output(switch2intrinsic, advance='yes')
          call output('resetSeed? ', advance='no')
          call output(resetSeed, advance='yes')
          call output('got(f_seed)? ', advance='no')
          call output(got(f_seed), advance='yes')
        end if
        if ( resetSeed ) then
          call mls_random_seed(new_seed=seed(1:))
          if ( DEEBUG ) then
            call output('Letting mls choose new seed ', advance='no')
            call output(seed, advance='yes')
          end if
        else if ( got(f_seed) ) then
          do j=1, min(nsons(seedNode)-1, 2)
            call expr(subtree(j+1,seedNode),unitAsArray,valueAsArray)
            seed(j) = int(valueAsArray(1))+chunkNo
          end do
          if ( seed(1) /= 0 .and. seed(2) /= 0 ) then
            call mls_random_seed(pput=seed(1:))
            if ( DEEBUG ) then
              call output('Setting new seed ', advance='no')
              call output(seed, advance='yes')
            end if
          else
            call mls_random_seed(new_seed=seed(1:))
            if ( DEEBUG ) then
              call output('Letting mls choose new seed ', advance='no')
              call output(seed, advance='yes')
            end if
          end if
        else
          if ( DEEBUG ) then
            call mls_random_seed(gget=seed(1:))
            call output('Reusing current seed ', advance='no')
            call output(seed, advance='yes')
          end if
        end if

        ! Either multiplier = [a, b] or multiplier = b are possible
        if ( got(f_multiplier) ) then
          multiplier = UNDEFINED_VALUE
          do j=1, min(nsons(multiplierNode)-1, 2)
            call expr(subtree(j+1,multiplierNode),unitAsArray,valueAsArray)
            multiplier(j) = valueAsArray(1)
          end do
        else
          multiplier = 1.
        end if

        if ( DEEBUG ) then
          call output('Using multipliers: ', advance='no')
          call output(multiplier, advance='yes')
        end if
        call addGaussianNoise ( key, quantity, sourceQuantity, &
          & noiseQty, multiplier, spreadFlag, ignoreTemplate )

      case ( l_applyBaseline )
        if ( .not. got ( f_baselineQuantity ) ) &
          & call Announce_Error ( key, no_Error_Code, &
          & 'Need baselineQuantity for applyBaseline fill' )
        baselineQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(baselineVctrIndex), baselineQtyIndex )
        call ApplyBaseline ( key, quantity, baselineQuantity, &
          & quadrature, dontMask, ignoreTemplate )

      case ( l_ascenddescend )
        if ( .not. got(f_sourceType) ) &
          & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'Defaulting to read sc/VelECI from L1BOA file for Asc/Desc mode Fill' )
        call WithAscOrDesc ( key, quantity, chunks(chunkNo), fileDatabase, &
          & hgrids, ptanQuantity, sourceType )

      case ( l_asciiFile )
        if ( .not. got ( f_file ) ) &
          & call Announce_Error ( key, no_Error_Code, &
          & 'Need filename for asciiFile fill' )
        if ( got ( f_badRange ) ) then
          call FromASCIIFile ( key, quantity, filename, badRange )
        else
          call FromASCIIFile ( key, quantity, filename )
        end if

      case ( l_binMax, l_binMean, l_binMin, l_binTotal, &
           & l_lsLocal, l_lsGlobal, l_lsWeighted )
        if ( .not. got ( f_sourceQuantity ) ) &
          & call Announce_Error ( key, no_Error_Code, &
          & 'Need source quantity for bin fill or least-squares fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )

        if ( sourceQuantity%template%verticalCoordinate /= &
          & quantity%template%verticalCoordinate ) then
          if ( .not. sourceQuantity%template%minorFrame .or. &
            &  .not. got ( f_ptanQuantity ) .or. &
            &  quantity%template%verticalCoordinate /= l_zeta ) then
              call Announce_Error ( key, no_Error_Code, &
              & ' vertical coordinates mismatch, perhaps supply tangent pressure?' )
          else
            if ( ptanQuantity%template%instrumentModule .ne. &
              & sourceQuantity%template%instrumentModule ) &
              & call Announce_Error ( key, no_Error_Code, &
              & 'Instrument module mismatch between ptan and source quantity' )
          end if
        end if

        if ( fillerror == 0 ) then
          select case ( fillMethod )
          case ( l_binMax, l_binMean, l_binMin, l_binTotal )
            call WithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
              & channel, fillMethod, additional, excludeBelowBottom, centerVertically )
          case default
            call UsingLeastSquares ( key, quantity, sourceQuantity, ptanQuantity, &
              & channel, fillMethod, scaleInstances, scaleRatio, scaleSurfs )
          end select
        end if

      case ( l_boxcar )
        if ( .not. got ( f_sourceQuantity ) ) &
          & call Announce_Error ( key, no_Error_Code, &
          & 'Need source quantity for boxcar fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        if ( .not. got ( f_width ) ) call Announce_Error ( key, no_Error_Code, &
          & 'Must supply width for boxcar fill' )
        if ( width == 1 ) then
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'Boxcar Fill with width=1 results in straightforward copy' )
          call FromAnother ( quantity, sourceQuantity, ptanQuantity, &
            & key, ignoreTemplate=.true., spreadflag=.false., &
            & interpolate=.false., force=.false., sourceMask=.false. )
        elseif (  mod ( width, 2 ) == 0 ) then
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'Boxcar Fill called with even width: adding one to make it odd' )
          call WithBoxcarFunction ( key, quantity, sourceQuantity, width+1, &
            & boxCarMethod, ignoreTemplate )
        else
          call WithBoxcarFunction ( key, quantity, sourceQuantity, width, &
            & boxCarMethod, ignoreTemplate )
        endif

      case ( l_chiSQChan )
        if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
          call Announce_error ( key, No_Error_code, &
          & 'Missing a required field to fill chi^2 on channels'  )
        else
          measQty => GetVectorQtyByTemplateIndex( &
            & vectors(measVectorIndex), measQtyIndex)
          modelQty => GetVectorQtyByTemplateIndex( &
            & vectors(modelVectorIndex), modelQtyIndex)
          noiseQty => GetVectorQtyByTemplateIndex( &
            & vectors(noiseVectorIndex), noiseQtyIndex)
          call ChiSqChan ( key, quantity, &
            & measQty, modelQty, noiseQty, &
            & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier )
        end if
      case ( l_chiSQMMaf )
        if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
          call Announce_error ( key, No_Error_code, &
          & 'Missing a required field to fill chi^2 on MAFs'  )
        else
          measQty => GetVectorQtyByTemplateIndex( &
            & vectors(measVectorIndex), measQtyIndex)
          modelQty => GetVectorQtyByTemplateIndex( &
            & vectors(modelVectorIndex), modelQtyIndex)
          noiseQty => GetVectorQtyByTemplateIndex( &
            & vectors(noiseVectorIndex), noiseQtyIndex)
          call ChiSqMMaf ( key, quantity, &
            & measQty, modelQty, noiseQty, &
            & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier )
        end if
      case ( l_chiSQMMif )
        if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
          call Announce_error ( key, No_Error_code, &
          & 'Missing a required field to fill chi^2 on MIFs'  )
        else
          measQty => GetVectorQtyByTemplateIndex( &
            & vectors(measVectorIndex), measQtyIndex)
          modelQty => GetVectorQtyByTemplateIndex( &
            & vectors(modelVectorIndex), modelQtyIndex)
          noiseQty => GetVectorQtyByTemplateIndex( &
            & vectors(noiseVectorIndex), noiseQtyIndex)
          call ChiSqMMif ( key, quantity, &
            & measQty, modelQty, noiseQty, &
            & dontMask, ignoreZero, ignoreNegative, ignoreTemplate, multiplier )
        end if
      case ( l_chiSqRatio ) ! ----------- Fill with convergence ratio ---
        if ( .not. all(got( (/ f_normQty, &
          & f_minNormQty, f_flags /)))) &
          & call Announce_Error ( key, no_Error_Code, &
            & 'Missing required fields for chi^2 ratio' )
        normQty => GetVectorQtyByTemplateIndex( &
          & vectors(normVectorIndex), normQtyIndex )
        minNormQty => GetVectorQtyByTemplateIndex( &
          & vectors(minNormVectorIndex), minNormQtyIndex )
        flagQty => GetVectorQtyByTemplateIndex( &
          & vectors(flagVectorIndex), flagQtyIndex )
        call ChiSqRatio ( key, &
          & quantity, normQty, minNormQty, flagQty, dontMask, ignoreTemplate )

      case ( l_columnAbundance )
        if ( .not. any(got( (/f_vmrQuantity, f_boundaryPressure/) )) ) then
          call Announce_error ( key, No_Error_code, &
          & 'Missing a required field to fill column abundance'  )
        elseif ( .not. &
          & any( colmabunits == (/l_dobsonUnits, l_DU, l_molcm2/) ) ) then
          call Announce_error ( key, No_Error_code, &
          & 'Wrong units to fill column abundance'  )
        else
          bndPressQty => GetVectorQtyByTemplateIndex( &
            & vectors(bndPressVctrIndex), bndPressQtyIndex)
          vmrQty => GetVectorQtyByTemplateIndex( &
            & vectors(vmrQtyVctrIndex), vmrQtyIndex)
          if ( got(f_unit) ) then
            ! Switch column species hash to explicit unit
            call get_string( lit_indices(colmabunits), explicitUnit, &
              & strip=.true. )
            call get_string( lit_indices(quantity%template%molecule), mol, &
              & strip=.true. )
            call PutHashElement( col_species_keys, col_species_hash, &
              & lowerCase(mol), ExplicitUnit, countEmpty=.true. )
          else
            call get_string( lit_indices(quantity%template%molecule), mol, &
              & strip=.true. )
            call GetHashElement (col_species_keys, &
              & col_species_hash, trim(lowercase(mol)), &
              & ExplicitUnit, .true.)
            if ( index(lowerCase(ExplicitUnit), 'd') > 0 ) colmabunits = l_DU
          end if
          call ColAbundance ( key, quantity, &
            & bndPressQty, vmrQty, colmAbUnits, ignoreTemplate )
        end if

      case ( l_combineChannels )
        if ( .not. got ( f_sourceQuantity ) ) &
          & call Announce_Error ( key, no_Error_Code, &
          & 'Need source quantity for combine channels fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        call FillWithCombinedChannels ( quantity, sourceQuantity, message )
        if ( message /= '' ) call Announce_Error ( key, no_Error_Code, trim(message) )

      case ( l_convergenceRatio )
        if ( .not. all ( got ( (/ f_sourceQuantity, f_scale /) ) ) ) &
          call Announce_error ( key, no_error_code, &
          & 'Need sourceQuanitity and scale for convergence fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex ( vectors(sourceVectorIndex), &
          & sourceQuantityIndex )
        call ConvergenceFromChisq ( key, quantity, sourceQuantity, scale, &
          & ignoreTemplate )

      case ( l_derivative )
        if ( .not. any ( got( &
          & (/ f_sourceQuantity, f_geocAltitudeQuantity, f_dimList /) &
          & ) ) ) &
          & call Announce_Error ( key, no_Error_Code, &
          & 'Need source quantity, geocAltitudeQuantity, dimList for ' // &
          & 'derivative fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        geocAltitudeQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(geocAltitudeVectorIndex), geocAltitudeQuantityIndex)
        call DerivativeOfSource ( quantity, sourceQuantity, geocAltitudeQuantity, &
          & dimList, ignoreTemplate )

      case ( l_estimatedNoise ) ! ----------- Fill with estimated noise ---
        if ( .not. all(got( (/ f_radianceQuantity, &
          & f_systemTemperature, f_integrationTime /)))) &
          & call Announce_Error ( key, badEstNoiseFill )
        radianceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(radianceVectorIndex), radianceQuantityIndex )
        sysTempQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sysTempVectorIndex), sysTempQuantityIndex )
        if ( got ( f_noiseBandwidth ) ) then
          nbwQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(nbwVectorIndex), nbwQuantityIndex )
        else
          nbwQuantity => NULL()
        end if
        call WithEstNoise ( &
          & quantity, radianceQuantity, sysTempQuantity, nbwQuantity, &
          & integrationTime )

      case ( l_explicit ) ! ---------  Explicitly fill from l2cf  -----
        if ( .not. got(f_explicitValues) ) &
          & call Announce_Error ( key, noExplicitValuesGiven )
        call Explicit ( quantity, valuesNode, spreadFlag, force, &
          & vectors(vectorIndex)%globalUnit, channel, &
          & .false., options=heightRange(1:1) )
      case ( l_extractChannel )
        if ( .not. all(got ( (/f_sourceQuantity,f_channel/)))) &
          & call Announce_Error ( key, no_Error_Code, &
            & 'Need sourceQuantity and channel for this fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        call ExtractSingleChannel ( key, quantity, sourceQuantity, channel, &
          & ignoreTemplate )

      case ( l_fold ) ! --------------- Fill by sideband folding -----
        nullify ( lsb, lsbFraction, usb, usbFraction )
        if ( got ( f_lsb ) ) lsb => GetVectorQtyByTemplateIndex ( &
          & vectors(lsbVectorIndex), lsbQuantityIndex )
        if ( got ( f_lsbFraction ) ) lsbFraction => GetVectorQtyByTemplateIndex ( &
          & vectors(lsbFractionVectorIndex), lsbFractionQuantityIndex )
        if ( got ( f_usb ) ) usb => GetVectorQtyByTemplateIndex ( &
          & vectors(usbVectorIndex), usbQuantityIndex )
        if ( got ( f_usbFraction ) ) usbFraction => GetVectorQtyByTemplateIndex ( &
          & vectors(usbFractionVectorIndex), usbFractionQuantityIndex )
        call FoldedRadiance ( quantity, lsb, usb, lsbFraction, usbFraction, key )

      case ( l_fwdModelTiming ) ! --- Fill timings for forward model  -----
        call FillFwdModelTimings (quantity%values(:,1), FWModelConfig, 'fwdTiming')
      case ( l_fwdModelMean ) ! --- Fill mean for forward model  -----
        call FillFwdModelTimings (quantity%values(:,1), FWModelConfig, 'mean')
      case ( l_fwdModelStdDev ) ! --- Fill std_dev for forward model  -----
        call FillFwdModelTimings (quantity%values(:,1), FWModelConfig, 'stdDev')
      case ( l_geoLocation )
        ! otherwise hard-to-obtain geo location data, settings, switches, etc.
        if ( .not. got ( f_manipulation ) ) &
          & call Announce_error ( key, no_Error_Code,'manipulation not supplied' )
        call get_string ( manipulation, GLStr, strip=.true. )
        select case (lowercase( trim(GLStr) ))
        ! Things about our chunk
        case ( 'abandoned' )
          quantity%values = 0
          if ( Chunks(ChunkNo)%abandoned ) quantity%values = 1
        case ( 'chunk' )
          quantity%values = ChunkNo
        case ( 'day' )
          quantity%values = GranuleDay()
        case ( 'dayofyear' )
          quantity%values = GranuleDayOfYear()
        case ( '1stmaf' )
          quantity%values = Chunks(ChunkNo)%firstMAFIndex
        ! Things about our Quantity template
        case ( 'frequencies' )
          quantity%values(:,1) = quantity%template%frequencies
        case ( 'geodlat' )
          quantity%values = quantity%template%geodLat
        case ( 'lon' )
          quantity%values = quantity%template%lon
        case ( 'losangle' )
          quantity%values = quantity%template%losangle
        case ( 'month' )
          quantity%values = GranuleMonth()
        case ( 'phi' )
          quantity%values = quantity%template%phi
        case ( 'solartime' )
          quantity%values = quantity%template%solartime
        case ( 'solarzenith' )
          quantity%values = quantity%template%solarzenith
        case ( 'surfs' )
          quantity%values = quantity%template%surfs
        case ( 'time' )
          quantity%values = quantity%template%time
        case ( 'year' )
          quantity%values = GranuleYear()
        ! Try to infer the profile number corresponding to each maf
        case ( 'profile' )
          if ( .not. got(f_hgrid) )  &
            & call Announce_error ( key, no_Error_Code,'hGrid not supplied' )
          call NearestProfiles ( &
            & quantity, HGrids(hgridIndex)%the_hGrid, &
            & Chunks(ChunkNo)%HGridOffsets(hgridIndex) &
            & )
        case default
          ! We will try to read it from the l1boa file--hope you named it properly
          L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
          call ReadL1BData ( L1BFile, GLStr, l1bField, noMAFs, &
            & l1bFlag, firstMAF=Chunks(ChunkNo)%firstMAFIndex, &
            & lastMAF=Chunks(ChunkNo)%lastMAFIndex, &
            & dontPad=DONTPAD )
          if ( l1bFlag == -1 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
            & MLSMSG_L1BRead//trim(GLStr) )
          ! call Announce_error ( key, no_Error_Code, trim(GLStr) // &
          !  & 'geolocation not recognized' )
          noSurfs = quantity%template%noSurfs
          if ( quantity%template%hGridIndex > 0 .and. &
            & noSurfs /= size(l1bField%dpField, 2) ) then
            noSurfs = min(noSurfs, size(l1bField%dpField, 2))
            do i=1, quantity%template%noInstances
              maf = Hgrids(quantity%template%hGridIndex)%the_hGrid%maf(i)
              quantity%value3(:,1:noSurfs,i) = l1bField%dpField(:,1:noSurfs,maf)
            enddo
          else
            quantity%value3 = l1bField%dpField
          endif
          call deallocateL1BData ( l1bField ) ! Avoid memory leaks
        end select

      case ( l_gather, l_scatter ) ! ------------  Gather  -----
        if ( .not. all(got( &
          &(/ f_sourceQuantity, f_start, f_count, f_stride, f_block /) &
          & )) ) &
          & call Announce_Error ( key, no_Error_Code, &
            & 'Need sourceQuantity, start, count, stride, and block for this fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        if ( fillMethod == l_gather ) then
          call Gather( quantity, sourceQuantity, start, count, stride, block )
        else
          call Scatter( quantity, sourceQuantity, start, count, stride, block )
        endif

      case ( l_geoidData ) ! ------------  geoidData  -----
        call geoidData ( quantity )

      case ( l_gphResetToGeoid ) ! ------------  gphResetToGeoid  -----
        if ( .not. got(f_GPHQuantity) ) &
          call Announce_Error ( key, no_Error_Code, &
          'Need gphQuantity for this method' )
        gphQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(GPHVectorIndex), GPHQuantityIndex )
        call geoidData ( quantity, gphQuantity )


      case ( l_gphPrecision) ! -------------  GPH precision  -----
        ! Need a tempPrecision and a refgphPrecision quantity
        if ( .not. all(got( (/ f_refGPHPrecisionQuantity, f_tempPrecisionQuantity /))) ) &
          call Announce_Error ( key, needTempREFGPH )

        tempPrecisionQuantity => GetVectorQtyByTemplateIndex( &
          &  vectors(tempPrecisionVectorIndex), tempPrecisionQuantityIndex)
        if ( tempPrecisionQuantity%template%quantityType /= l_Temperature ) &
          & call Announce_Error ( key, badTemperatureQuantity )

        refGPHPrecisionQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(refGPHPrecisionVectorIndex), refGPHPrecisionQuantityIndex)
        if ( refGPHPrecisionQuantity%template%quantityType /= l_refGPH ) &
          & call Announce_Error ( key, badrefGPHQuantity )

        call GPHPrecision ( key, quantity, tempPrecisionQuantity, &
          & refGPHPrecisionQuantity )

      case ( l_gridded ) ! ------------  Fill from gridded data  -----
        if ( .not. got(f_sourceGrid) ) &
          & call Announce_Error ( key, noSourceGridGiven )
        call FromGrid ( quantity, griddedDataBase(gridIndex), &
            & allowMissing, replaceMissingValue, errorCode )
        if ( errorCode /= 0 ) call Announce_error ( key, errorCode )

      case ( l_l1b ) ! --------------------  Fill from L1B data  -----
        if ( any( got( &
          & (/ f_height, f_heightRange, f_surface, f_instances, &
          & f_maxValue, f_minValue /) &
          & ) ) ) then
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'Mask bits set during l1b Fill are sticky--use Subset to clear them' )
        endif
        if ( got(f_precision) ) then
          precisionQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(precisionVectorIndex), precisionQuantityIndex )
          call FromL1B ( key, quantity, chunks(chunkNo), &
            & filedatabase, isPrecision, suffix=suffix, geolocation=geolocation, &
            & precisionQuantity=precisionQuantity )
        elseif ( got(f_avoidbrightobjects) ) then
          avoidObjects = lowerCase(avoidObjects)
          nBO = NumStringElements( avoidObjects, .true. )
          do iBO = 1, nBO
            BOnum = StringElementNum(lowercase(BrightObjects), &
              & trim(StringElement(avoidObjects, iBO, .true.)), &
              & .true.)
            if ( BOnum > 0 ) BOMask = ibset( BOMask, BOnum )
          end do
          ! Special case: moon in space port
          if ( index(avoidObjects, 'mooninsp') > 0 ) &
            & BOMask = ibset( BOMask, 0 )
          call FromL1B ( key, quantity, chunks(chunkNo), &
            & filedatabase, isPrecision, suffix=suffix, geolocation=geolocation, &
            & BOMask=BOMask )
        else
          call FromL1B ( key, quantity, chunks(chunkNo), &
            & filedatabase, isPrecision, suffix=suffix, geolocation=geolocation )
        end if

      case ( l_l2gp ) ! --------------  Fill from L2GP quantity  -----
        if ( .NOT. got(f_sourceL2GP) ) &
          & call Announce_Error ( key, noSourceL2GPGiven )
        call FromL2GP &
          & ( quantity, l2gpDatabase(l2gpIndex), interpolate, profile, errorCode, &
          & ignoreGeolocation, fromPrecision  )
        if ( errorCode /= 0 ) call Announce_error ( key, errorCode )

      case ( l_l2aux ) ! ------------  Fill from L2AUX quantity  -----
        if ( .NOT. got(f_sourceL2AUX) ) &
          & call Announce_Error ( key, noSourceL2AUXGiven )
        call FromL2AUX(quantity,l2auxDatabase(l2auxIndex),errorCode)
        if ( errorCode /= 0 ) call Announce_error ( key, errorCode )

      case ( l_H2OfromRHI ) ! -------fill H2O from RHI quantity -------
          if ( .not. any(got( &
           & (/f_rhiQuantity, f_temperatureQuantity/) &
           & )) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill h2o from rhi'  )
          else
            sourceQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(sourceVectorIndex), sourceQuantityIndex)
            temperatureQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(temperatureVectorIndex), temperatureQuantityIndex)
            if ( .not. ValidateVectorQuantity(sourceQuantity, &
              & quantityType=(/l_rhi, l_vmr/)) ) then
              call Announce_Error ( key, No_Error_code, &
              & 'The rhiQuantity is not an rhi'  )
            else if ( .not. ValidateVectorQuantity(Quantity, &
              & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
              call Announce_Error ( key, No_Error_code, &
              & 'The Quantity is not a vmr for the H2O molecule'  )
            else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
              & quantityType=(/l_temperature/)) ) then
              call Announce_Error ( key, No_Error_code, &
              & 'The temperatureQuantity is not a temperature'  )
            else
              invert = .true.
              call RHIFromOrToH2O ( key, quantity, &
                & sourceQuantity, temperatureQuantity, &
                & dontMask, ignoreZero, ignoreNegative, interpolate, &
                & .false., &   ! Mark Undefined values?
                & invert )    ! invert rather than convert?
            end if
          end if

      case ( l_H2OPrecisionfromRHi ) ! --fill H2O prec. from RHi quantity --
        if ( .not. any(got( &
          & (/f_h2oquantity, f_temperatureQuantity, &
          & f_rhiPrecisionquantity, f_tempPrecisionQuantity/) &
          & )) ) then
          call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill h2o precision'  )
        else
          h2oQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(h2oVectorIndex), h2oQuantityIndex)
          temperatureQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(temperatureVectorIndex), temperatureQuantityIndex)
          rhiPrecisionQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(rhiPrecisionVectorIndex), rhiPrecisionQuantityIndex)
          tempPrecisionQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(tempPrecisionVectorIndex), tempPrecisionQuantityIndex)
          if ( .not. ValidateVectorQuantity(h2oQuantity, &
            & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
            call Announce_Error ( key, No_Error_code, &
              & 'The h2oQuantity is not a vmr for the H2O molecule'  )
          else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
            & quantityType=(/l_temperature/)) ) then
            call Announce_Error ( key, No_Error_code, &
              & 'The temperatureQuantity is not a temperature'  )
          else if ( .not. ValidateVectorQuantity(tempPrecisionQuantity, &
            & quantityType=(/l_temperature/)) ) then
            call Announce_Error ( key, No_Error_code, &
              & 'The tempPrecisionQuantity is not a temperature'  )
          else
            call RHIPrecisionFromOrToH2O ( key, quantity, &
              & rhiPrecisionQuantity, tempPrecisionQuantity, h2oQuantity, &
              & temperatureQuantity, dontMask, ignoreZero, &
              & ignoreNegative, interpolate, &
              & .true., &   ! Mark Undefined values?
              & invert=.true. )    ! convert RHiPrecisionToH2O
          end if
        end if

      case ( l_hydrostatic ) ! -------------  Hydrostatic fills  -----
        ! Need a temperature and a refgph quantity
        if ( .not.all(got( (/ f_refGPHQuantity, f_temperatureQuantity /))) ) &
          call Announce_Error ( key, needTempREFGPH )
        nullify( phiTanQuantity ) ! We may accidentally refer to it later
        temperatureQuantity => GetVectorQtyByTemplateIndex( &
          &  vectors(temperatureVectorIndex), temperatureQuantityIndex)
        if ( temperatureQuantity%template%quantityType /= l_Temperature ) &
          & call Announce_Error ( key, badTemperatureQuantity )

        refGPHQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(refGPHVectorIndex), refGPHQuantityIndex)
        if ( refGPHQuantity%template%quantityType /= l_refGPH ) &
          & call Announce_Error ( key, badrefGPHQuantity )

        select case ( quantity%template%quantityType )
        case ( l_gph )
          call Hydrostatically_GPH ( key, quantity, temperatureQuantity, &
            & refGPHQuantity )
        case ( l_ptan )
          if ( .not. got(f_geocAltitudeQuantity) ) &
            & call Announce_Error ( key, needGeocAltitude )
          geocAltitudeQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(geocAltitudeVectorIndex), geocAltitudeQuantityIndex)
          if ( geocAltitudeQuantity%template%quantityType /= l_tngtgeocAlt ) &
            & call Announce_Error ( key, badGeocAltitudeQuantity )

          if ( .not. got(f_phiTan) ) &
            & call Announce_Error ( key, no_Error_Code, 'Needs phiTan quantity' )
          phiTanQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(phiTanVectorIndex), phiTanQuantityIndex)
          if ( phiTanQuantity%template%quantityType /= l_phiTan ) &
            & call Announce_Error ( key, no_Error_Code, 'Has a bad phiTan quantity' )

          if ( .not. got(f_h2oQuantity) ) &
            & call Announce_Error ( key, needH2O )
          h2oQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(h2oVectorIndex), h2oQuantityIndex)
          if ( .not. ValidateVectorQuantity(h2oQuantity, &
            & quantityType=(/l_vmr/), molecule=(/l_h2o/)) )&
            & call Announce_Error ( key, badGeocAltitudeQuantity )

          if ( .not. got(f_orbitInclination) ) &
            & call Announce_Error ( key, needOrbitInclination )
          orbitInclinationQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(orbitInclinationVectorIndex), orbitInclinationQuantityIndex)
          call Hydrostatically_PTan ( key, quantity, temperatureQuantity, &
            & refGPHQuantity, h2oQuantity, orbitInclinationQuantity, &
            & phiTanQuantity, geocAltitudeQuantity, maxIterations, &
            & phiWindow, phiWindowUnits, chunkNo )
        case default
          call announce_error ( key, no_error_code, &
            & 'Hydrostatic fill for quantity that is neither GPH nor PTan' )
        end select

      case ( l_isotope ) ! --------------- Isotope based fills -------
        if ( .not. all(got( (/f_ratioQuantity, f_sourceQuantity/) ) ) ) &
          & call Announce_Error ( key, badIsotopeFill )
        ratioQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(ratioVectorIndex), ratioQuantityIndex )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        call FromIsotope ( quantity, sourceQuantity, &
          & ratioQuantity )

      case ( l_IWCfromExtinction ) ! -------fill IWC from cloud extinction -------
          if ( .not. any(got( &
           & (/f_extinction, f_temperatureQuantity/) &
           & )) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill iwc from cloudextinction'  )
          else
            sourceQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(sourceVectorIndex), sourceQuantityIndex)
            temperatureQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(temperatureVectorIndex), temperatureQuantityIndex)
            if ( .not. ValidateVectorQuantity(sourceQuantity, &
              & quantityType=(/l_cloudextinction/)) ) then
              call Announce_Error ( key, No_Error_code, &
              & 'The extinctionQuantity is not an cloudextinction'  )
            else if ( .not. ValidateVectorQuantity(Quantity, &
              & quantityType=(/l_cloudice/)) ) then
              call Announce_Error ( key, No_Error_code, &
              & 'The filled Quantity is not a type of cloudice '  )
            else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
              & quantityType=(/l_temperature/)) ) then
              call Announce_Error ( key, No_Error_code, &
              & 'The temperatureQuantity is not a temperature'  )
            else
              call IWCFromExtinction ( quantity, &
                & sourceQuantity, temperatureQuantity)
            end if
          end if

      case ( l_losVel )
        if ( .not. any(got( &
        & (/f_tngtECI, f_scECI, f_scVel, f_scVelECI, f_scVelECR/) )) ) then
          call Announce_error ( key, badlosVelFill )
        else
          tngtECIQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(tngtECIVectorIndex), tngtECIQuantityIndex)
          scECIQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(scECIVectorIndex), scECIQuantityIndex)
          scVelQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(scVelVectorIndex), scVelQuantityIndex)
          call LOSVelocity ( key, quantity, tngtECIQuantity, &
            & scECIquantity, scVelQuantity )
        end if
      case ( l_manipulate ) ! ---------------------------- Manipulate --
        if ( .not. got ( f_a ) ) &
          & call Announce_error ( key, no_Error_Code,'aQuantity not supplied' )
        if ( .not. got ( f_manipulation ) ) &
          & call Announce_error ( key, no_Error_Code,'manipulation not supplied' )
        aQuantity => GetVectorQtyByTemplateIndex ( &
          & vectors(aVecIndex), aQtyIndex )
        if ( got ( f_b ) ) then
          bQuantity => GetVectorQtyByTemplateIndex ( &
            & vectors(bVecIndex), bQtyIndex )
        else
          nullify ( bQuantity )
        end if
        ! We can make this simpler by imitating Van's use of pointers in
        ! place of optional args
        ! (Later, for now just see if you can make it work at all)
        if ( got(f_c) ) then
          if ( any( got( &
            & (/ f_height, f_channel /) &
            & ) ) ) then
            call CloneVectorQuantity( tempswapquantity, quantity )
            call ByManipulation ( tempswapquantity, aQuantity, bQuantity, &
              & manipulation, key, ignoreTemplate, &
              & spreadflag, dimList, &
              & c )
            call Explicit ( quantity, valuesNode, spreadFlag, force, &
              & vectors(vectorIndex)%globalUnit, channel, &
              & .false., options=heightRange(1:1), extraQuantity=tempswapquantity )
            call destroyVectorQuantityValue ( tempswapquantity, destroyMask=.true., &
              forWhom = 'tempswapquantity' )
          else
            call ByManipulation ( quantity, aQuantity, bQuantity, &
              & manipulation, key, ignoreTemplate, &
              & spreadflag, dimList, &
              & c )
          endif
        else
          if ( any( got( &
            & (/ f_height, f_channel /) &
            & ) ) ) then
            call CloneVectorQuantity( tempswapquantity, quantity )
            call ByManipulation ( tempswapquantity, aQuantity, bQuantity, &
              & manipulation, key, ignoreTemplate, &
              & spreadflag, dimList )
            call Explicit ( quantity, valuesNode, spreadFlag, force, &
              & vectors(vectorIndex)%globalUnit, channel, &
              & .false., options=heightRange(1:1), &
              & extraQuantity=tempswapquantity )
            call destroyVectorQuantityValue ( tempswapquantity, destroyMask=.true., &
              forWhom = 'tempswapquantity' )
          else
            call ByManipulation ( quantity, aQuantity, bQuantity, &
              & manipulation, key, ignoreTemplate, &
              & spreadflag, dimList )
          endif
        endif

      case ( l_magAzEl ) ! -- Magnetic Explicit from stren, azim, elev --
        if ( .not. got(f_explicitValues) ) &
          & call Announce_Error ( key, noExplicitValuesGiven )
        call Explicit ( quantity, valuesNode, spreadFlag, force, &
          & vectors(vectorIndex)%globalUnit, channel, &
          & azEl=.true. )

      case ( l_magneticModel ) ! --------------------- Magnetic Model --
        nullify ( geocAltitudeQuantity, gphQuantity, scVelQuantity )
        if ( got ( f_geocAltitudeQuantity ) ) then
          geocAltitudeQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(geocAltitudeVectorIndex), geocAltitudeQuantityIndex)
          if ( geocAltitudeQuantity%template%quantityType /= l_tngtgeocAlt ) then
            call Announce_Error ( key, badGeocAltitudeQuantity )
            nullify ( geocAltitudeQuantity )
          end if
        end if
        if ( got ( f_GPHQuantity ) ) then
          gphQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(GPHVectorIndex), GPHQuantityIndex)
          if ( gphQuantity%template%quantityType /= l_gph ) then
            call Announce_Error ( key, badGPHQuantity )
            nullify ( gphQuantity )
          end if
        end if
        if ( got ( f_scVelECR ) ) then
          scVelQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(scVelVectorIndex), scVelQuantityIndex)
          if ( scVelQuantity%template%quantityType /= l_scVelECR ) then
            call Announce_Error ( key, badScVelECRQuantity )
            nullify ( scVelQuantity )
          end if
        end if
! This ought to work.  I don't know why ifort 15.0.2.164 gets a seg fault if
! gphQuantity is not associated.
!         if ( associated(gphQuantity) .or. &
!            & ( associated(scVelQuantity) .and. associated(geocAltitudeQuantity) ) ) then
!           call UsingMagneticModel ( quantity, key, scVelQuantity, &
!                                   & geocAltitudeQuantity, gphQuantity )
        if ( associated(gphQuantity) ) then
          if ( .not. got(f_referenceMIF) ) then
            referenceMIF = gphQuantity%template%noSurfs / 2
            referenceMIFunits = PHYQ_Dimensionless
          end if
          if ( associated(scVelQuantity) .and. associated(geocAltitudeQuantity) ) then
            call UsingMagneticModel ( quantity, key, scVelQuantity, &
                                    & geocAltitudeQuantity, gphQuantity, &
                                    & regular=regular, referenceMIF=referenceMIF, &
                                    & referenceMIFunits=referenceMIFunits )
          else
            call UsingMagneticModel ( quantity, key, gphQuantity=gphQuantity, &
                                    & regular=regular, referenceMIF=referenceMIF, &
                                    & referenceMIFunits=referenceMIFunits )
          end if
        else if ( associated(scVelQuantity) .and. associated(geocAltitudeQuantity) ) then
          if ( .not. got(f_referenceMIF) ) then
            referenceMIF = scVelQuantity%template%noSurfs / 2
            referenceMIFunits = PHYQ_Dimensionless
          end if
          call UsingMagneticModel ( quantity, key, scVelQuantity, &
                                  & geocAltitudeQuantity, &
                                  & regular=regular, referenceMIF=referenceMIF, &
                                  & referenceMIFunits=referenceMIFunits )
        else
          call UsingMagneticModel ( quantity, key )
        end if

      case ( l_modifyTemplate )
        shp = 0
        ! override qty template fields: time, phi, longitude, etc.
        if ( .not. got ( f_manipulation ) ) &
          & call Announce_error ( key, no_Error_Code,'manipulation not supplied' )
        call get_string ( manipulation, GLStr, strip=.true. )
        if ( got( f_shape ) ) then
          do j = 2, nsons(shapeNode)
            call expr ( subtree ( j, shapeNode ), unitAsArray, valueAsArray )
            shp(j-1) = valueAsArray(1)
          enddo
        endif
        if ( got( f_sourceQuantity ) ) then
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          call ModifyQuantityTemplate  ( quantity%template, GLStr, &
            & sourceQuantity%values, spreadFlag )
        elseif ( got( f_explicitValues ) ) then
          if ( .not. got ( f_shape ) ) &
            & call Announce_error ( key, no_Error_Code,'shape not supplied' )
          call ModifyQuantityTemplate  ( quantity%template, GLStr, &
            & shp, valuesNode, spreadFlag )
        elseif ( .not. got( f_c ) ) then
          call Announce_error ( key, no_Error_Code, &
          & 'Must supply c for new value(s)' )
        else
          call ModifyQuantityTemplate  ( quantity%template, GLStr, c )
        endif

      case ( l_negativePrecision ) ! ------------ Set output SD -ve wrt apriori
        if ( .not. got ( f_aprioriPrecision ) ) &
          & call Announce_Error ( key, No_Error_code, &
          & 'Missing aprioriPrecision field for negativePrecision fill' )
        aprioriPrecision => GetVectorQtyByTemplateIndex ( &
          & vectors(aprPrecVctrIndex), aprPrecQtyIndex )
        where ( quantity%values >= aprioriPrecision%values*precisionFactor .and. &
          & aprioriPrecision%values > 0.0_r8 )
          quantity%values = - quantity%values
        end where

      case ( l_noRadsPerMIF )
        if ( .not. got ( f_measurements ) ) then
          call Announce_error ( key, No_Error_code, &
          & 'Missing a required field to fill noRadsPerMIF on MIFs'  )
        else
          measQty => GetVectorQtyByTemplateIndex( &
            & vectors(measVectorIndex), measQtyIndex)
          call NoRadsPerMif ( key, quantity, measQty, asPercentage )
        end if

      case ( l_offsetRadiance ) ! ------------------- Offset radiance --
        if ( .not. got ( f_radianceQuantity ) ) &
          & call Announce_error ( key, no_Error_Code, &
          & 'radianceQuantity not supplied' )
        radianceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(radianceVectorIndex), radianceQuantityIndex )
        call OffsetRadianceQuantity ( quantity, radianceQuantity, offsetAmount )

      case ( l_residualCorrection ) ! ------------------- Residual correction --
        if ( .not. got ( f_source ) ) &
          & call Announce_error ( key, no_Error_Code, &
          & 'source radiance vector not supplied' )
        if ( .not. got ( f_file ) ) &
          & call Announce_Error ( key, no_Error_Code, &
          & 'Need filename for asciiFile fill' )
        call ResidualCorrection ( key, quantity, sourceVector, filename )

      case ( l_phaseTiming ) ! ---------  Fill timings for phases  -----
        call finishTimings('phases', returnStatus=status)
        if ( status /= 0 ) then
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'Unable to finish phases timings (Is this still apriori?)' )
        else
          call fillTimings ( quantity%values(:,1), 'phases', 'all', .true. )
          ! call dump( quantity%values(:,1), 'phases' )
        end if

      case ( l_sectionTiming ) ! ---------  Fill timings for sections  -----
        call finishTimings('sections', returnStatus=status)
        if ( status /= 0 ) then
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'Unable to finish sections timings (Is this still apriori?)' )
        else
          call fillTimings ( quantity%values(:,1), 'sections', 'all', .true. )
          ! call dump( quantity%values(:,1), 'sections' )
        end if

      case ( l_profile ) ! ------------------------ Profile fill -------
        if ( .not. got ( f_profileValues ) ) &
          call Announce_error ( key, no_Error_Code, 'profileValues not supplied' )
        if ( .not. got ( f_instances ) ) instancesNode = 0
        ! The next bit may seem odd - why not just pass logSpace on and let it default to false?
        ! The problem is, it should default to quantity%template%logSpace so absent means
        ! "don't care", not "logSpace=.false."
        if ( got ( f_logSpace ) ) then
          call FromProfile ( quantity, valuesNode, &
            & instancesNode, vectors(vectorIndex)%globalUnit, &
            & ptanQuantity, logSpace=logSpace, dontLatch=dontLatch )
        else
          call FromProfile ( quantity, valuesNode, &
            & instancesNode, vectors(vectorIndex)%globalUnit, &
            & ptanQuantity, dontLatch=dontLatch )
        end if
        ! if ( associated(ptanQuantity) ) call dump( quantity%values(:,1), 'profile values' )

      case ( l_refract )              ! --------- refraction for phiTan -----
        ! More sanity checks
        if ( .not. ValidateVectorQuantity ( quantity, &
          & quantityType=(/l_phiTan/), minorFrame=.true. ) ) &
          & call Announce_error ( key, no_Error_Code, 'Quantity to fill is not phiTan' )
        ! Start off with a copy from the template
        quantity%values = quantity%template%phi
        if ( refract ) then
          if ( .not. all ( got ( (/ f_h2oQuantity, f_orbitinclination, &
          & f_ptanQuantity, f_refGPHquantity, f_temperatureQuantity /) ) ) ) then
            call Announce_error ( key, badRefractFill )
            call Announce_error ( key, missingField, extraInfo= &
              & (/ f_h2oQuantity, f_orbitinclination, &
              & f_ptanQuantity, f_refGPHquantity, f_temperatureQuantity /) )
          end if
          h2oQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(h2oVectorIndex), h2oQuantityIndex)
          orbitInclinationQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(orbitInclinationVectorIndex), orbitInclinationQuantityIndex)
          ptanQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(ptanVectorIndex), ptanQuantityIndex)
          refGPHquantity => GetVectorQtyByTemplateIndex( &
            & vectors(refGPHVectorIndex), refGPHQuantityIndex)
          temperatureQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(temperatureVectorIndex), temperatureQuantityIndex)
          call PhiTanWithRefraction ( key, quantity, h2oQuantity, &
            & orbitInclinationQuantity, &
            & ptanQuantity, refGPHquantity, temperatureQuantity, &
            & ignoreTemplate )
        end if
      
      case (l_heightFromPressure )
          if ( .not. all ( got ( (/ f_h2oQuantity, f_orbitinclination, &
          & f_ptanQuantity, f_refGPHquantity, f_temperatureQuantity /) ) ) ) then
            call Announce_error ( key, badRefractFill )
            call Announce_error ( key, missingField, extraInfo= &
              & (/ f_h2oQuantity, f_orbitinclination, &
              & f_ptanQuantity, f_refGPHquantity, f_temperatureQuantity /) )
          end if
          h2oQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(h2oVectorIndex), h2oQuantityIndex)
          orbitInclinationQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(orbitInclinationVectorIndex), orbitInclinationQuantityIndex)
          ptanQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(ptanVectorIndex), ptanQuantityIndex)
          refGPHquantity => GetVectorQtyByTemplateIndex( &
            & vectors(refGPHVectorIndex), refGPHQuantityIndex)
          temperatureQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(temperatureVectorIndex), temperatureQuantityIndex)
          call HeightFromPressure ( key, quantity, h2oQuantity, &
            & orbitInclinationQuantity, &
            & ptanQuantity, refGPHquantity, temperatureQuantity, &
            & ignoreTemplate )
        
      case ( l_reflectorTempModel ) ! --------------- Reflector temperature model
        call WithReflectorTemperature ( key, quantity, phiZero, termsNode )

      case ( l_resetUnusedRadiances )
        call ResetUnusedRadiances ( quantity, offsetAmount )

      case ( l_rectanglefromlos ) ! -------fill from losGrid quantity -------
        if ( .not. all(got((/f_losQty,f_earthRadius,f_PtanQuantity/))))&
          & call Announce_Error ( key, badlosGridFill )
        earthRadiusQty => GetVectorQtyByTemplateIndex( &
          & vectors(earthRadiusVectorIndex), earthRadiusQtyIndex )
        PtanQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(PtanVectorIndex), PtanQuantityIndex )
        losQty => GetVectorQtyByTemplateIndex( &
          & vectors(losVectorIndex), losQtyIndex )
        call FromLosGrid ( key, Quantity, losQty, &
          & ptanQuantity, earthRadiusQty, &
          & noFineGrid, extinction, errorCode )

      case ( l_RHIfromH2O ) ! -------fill RHI from H2O quantity -------
        if ( .not. any(got( &
         & (/f_h2oquantity, f_temperatureQuantity/) &
         & )) ) then
          call Announce_error ( key, No_Error_code, &
          & 'Missing a required field to fill rhi'  )
        else ! value
            h2oQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(h2oVectorIndex), h2oQuantityIndex)
            temperatureQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(temperatureVectorIndex), temperatureQuantityIndex)
            if ( .not. ValidateVectorQuantity(h2oQuantity, &
              & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
              call Announce_Error ( key, No_Error_code, &
                & 'The h2oQuantity is not a vmr for the H2O molecule'  )
            else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
              & quantityType=(/l_temperature/)) ) then
              call Announce_Error ( key, No_Error_code, &
                & 'The temperatureQuantity is not a temperature'  )
            else
              call RHIFromOrToH2O ( key, quantity, &
                & h2oQuantity, temperatureQuantity, &
                & dontMask, ignoreZero, ignoreNegative, interpolate, &
                & .false., &   ! Mark Undefined values?
                & invert )    ! invert rather than convert?
            end if
        end if

      case ( l_quality )
        if ( .not. all ( got ( (/ f_sourceQuantity, f_scale /) ) ) ) &
          call Announce_error ( key, no_error_code, &
          & 'Need sourceQuanitity and scale for quality fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex ( vectors(sourceVectorIndex), &
          & sourceQuantityIndex )
        call QualityFromChisq ( key, quantity, sourceQuantity, &
          & scale, heightNode, ignoreTemplate )

      case ( l_RHIPrecisionfromH2O ) ! --fill RHI prec. from H2O quantity --
        if ( .not. any(got( &
          & (/f_h2oquantity, f_temperatureQuantity, &
          & f_h2oPrecisionquantity, f_tempPrecisionQuantity/) &
          & )) ) then
          call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill rhi precision'  )
        else
          h2oQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(h2oVectorIndex), h2oQuantityIndex)
          temperatureQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(temperatureVectorIndex), temperatureQuantityIndex)
          h2oPrecisionQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(h2oPrecisionVectorIndex), h2oPrecisionQuantityIndex)
          tempPrecisionQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(tempPrecisionVectorIndex), tempPrecisionQuantityIndex)
          if ( .not. ValidateVectorQuantity(h2oQuantity, &
            & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
            call Announce_Error ( key, No_Error_code, &
              & 'The h2oQuantity is not a vmr for the H2O molecule'  )
          else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
            & quantityType=(/l_temperature/)) ) then
            call Announce_Error ( key, No_Error_code, &
              & 'The temperatureQuantity is not a temperature'  )
          else if ( .not. ValidateVectorQuantity(h2oPrecisionQuantity, &
            & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
            call Announce_Error ( key, No_Error_code, &
              & 'The h2oPrecisionQuantity is not a vmr for the H2O molecule'  )
          else if ( .not. ValidateVectorQuantity(tempPrecisionQuantity, &
            & quantityType=(/l_temperature/)) ) then
            call Announce_Error ( key, No_Error_code, &
              & 'The tempPrecisionQuantity is not a temperature'  )
          else
            call RHIPrecisionFromOrToH2O ( key, quantity, &
              & h2oPrecisionQuantity, tempPrecisionQuantity, h2oQuantity, &
              & temperatureQuantity, dontMask, ignoreZero, &
              & ignoreNegative, interpolate, &
              & .true., &   ! Mark Undefined values?
              & invert )    ! invert rather than convert?
          end if
        end if

      case ( l_rotateField )
        if ( .not. all ( got ( (/ f_fieldECR, f_ecrtofov /) ) ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'Must supply field and ecrToFov for rotateField fill' )
        else
          fieldECR => GetVectorQtyByTemplateIndex ( &
            & vectors(fieldECRVectorIndex), fieldECRQuantityIndex )
          ecrToFOV => GetVectorQtyByTemplateIndex ( &
            & vectors(ecrToFOVVectorIndex), ecrToFovQuantityIndex )
          call RotateMagneticField ( key, quantity, fieldECR, ecrToFov )
        end if

      case ( l_scaleOverlaps )
        if ( .not. got ( f_multiplier ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'Must supply multipler for scaleOverlaps fill' )
        else
          call ScaleOverlaps ( quantity, multiplierNode )
        end if

      case ( l_splitSideband ) ! --------------- Split the sidebands
        if ( .not. got(f_sourceQuantity) ) &
          & call Announce_Error ( key, No_Error_Code, &
          & 'Missing a source field for vector fill' )
        if ( .not. all(got( (/f_lsbFraction,f_usbFraction/) ))) &
          & call Announce_Error ( key, No_Error_Code, &
          & 'Missing a usb/lsb fraction field for vector fill' )
        if ( .not. got ( f_channel ) ) call Announce_Error ( key, &
          & no_error_code, 'Must supply channel for spreadChannel fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        lsbFraction => GetVectorQtyByTemplateIndex ( &
          & vectors(lsbFractionVectorIndex), lsbFractionQuantityIndex )
        usbFraction => GetVectorQtyByTemplateIndex ( &
          & vectors(usbFractionVectorIndex), usbFractionQuantityIndex )
        if ( got ( f_usb ) ) then
             usb => GetVectorQtyByTemplateIndex ( &
             & vectors(usbVectorIndex), usbQuantityIndex )
        else
          nullify ( usb )
        end if

        call FromSplitSideband ( quantity, sourceQuantity, &
          & lsbFraction, usbFraction, spreadFlag, usb, channel, key )

      case ( l_spreadChannel )
        if ( .not. got ( f_channel ) .and. .not. got( f_sourceQuantity ) ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Must supply channel or sourcequantity for spreadChannel fill' )
        if ( got(f_sourceQuantity) ) then
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
          if ( .not. got(f_channel) ) channel = 1
          call SpreadChannelFill ( quantity, channel, key, &
            & sourceQuantity )
        else
          call SpreadChannelFill ( quantity, channel, key )
        endif

      case ( l_status )
        if ( got(f_ifMissingGMAO) ) then
          if ( MissingGMAO ) call Explicit ( quantity, &
            & valuesNode, .true., .false., phyq_Invalid, &
            & channel, .false., options=heightRange(1:1) )
        elseif ( .not. all ( got ( (/ f_sourceQuantity, f_status /) ) ) ) then
          call Announce_Error ( key, no_error_code, &
          & 'Need sourceQuantity and status fields for status fill' )
        elseif ( .not. any ( got ( (/ f_minValue, f_maxValue /) ) ) ) then
          call Announce_Error ( key, no_error_code, &
          & 'Need one or both of maxValue, minValue for status fill' )
        else
          sourceQuantity => &
            &GetVectorQtyByTemplateIndex ( vectors(sourceVectorIndex), &
            & sourceQuantityIndex )
          if ( got ( f_maxValue) .and. &
            &  all ( maxValueUnit /= &
            & (/ sourceQuantity%template%unit, PHYQ_Dimensionless/) ) ) &
            & call Announce_Error ( key, no_error_code, &
            & 'Bad unit for maxValue' )
          if ( got ( f_minValue) .and. &
            &  all ( minValueUnit /= &
            & (/ sourceQuantity%template%unit, PHYQ_Dimensionless/) ) ) &
            & call Announce_Error ( key, no_error_code, &
            & 'Bad unit for minValue' )
          if ( all ( got ( (/ f_minValue, f_maxValue /) ) ) .and. &
            &  maxValue <= minValue ) call Announce_Error ( key, no_error_code, &
            & 'Bad combination of max/min values' )
          call StatusQuantity ( key, quantity, &
            & sourceQuantity, statusValue, &
            & minValue, maxValue, heightNode, &
            & additional, exact, ignoreTemplate )
        end if

      case ( l_swapvalues )
        if ( .not. got( f_sourceQuantity ) ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Must supply sourcequantity for swapValues fill' )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        ! nullify( tempswapquantity )
        call CloneVectorQuantity( tempswapquantity, quantity )
        if ( quantity%template%name /= sourceQuantity%template%name ) then
          if ( .not. interpolate .and. .not. ignoreTemplate ) then
            call Announce_Error ( key, No_Error_Code, &
              & 'Quantity and sourceQuantity do not have the same template' )
          else
            call FromInterpolatedQty ( tempswapquantity, sourceQuantity, &
              & key, ignoreTemplate )
            call FromInterpolatedQty ( sourceQuantity, quantity, &
              & key, ignoreTemplate )
            call FromInterpolatedQty ( quantity, tempswapquantity, &
              & key, ignoreTemplate )
          end if
        else
          ! Just a straight copy
          ! If we have a mask and we're going to obey it then do so
          if ( associated(quantity%mask) ) then
            where ( iand ( ichar(quantity%mask(:,:)), m_Fill ) == 0 )
              tempswapquantity%values(:,:) = sourceQuantity%values(:,:)
              sourceQuantity%values(:,:) = Quantity%values(:,:)
              quantity%values(:,:) = tempswapquantity%values(:,:)
            end where
          else ! Otherwise, just blindly copy
            tempswapquantity%values = sourceQuantity%values
            sourceQuantity%values = Quantity%values
            quantity%values = tempswapquantity%values
          end if
        end if
        call destroyVectorQuantityValue ( tempswapquantity, destroyMask=.true., &
          forWhom = 'tempswapquantity' )
      case ( l_vector ) ! ---------------- Fill from another qty.
        if ( .not. got(f_sourceQuantity) ) &
          & call Announce_Error ( key, No_Error_Code, &
          & 'Missing a source field for vector fill' )
        Quantity => GetVectorQtyByTemplateIndex( &
          & vectors(VectorIndex), QuantityIndex )
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        call FromAnother ( quantity, sourceQuantity, ptanQuantity, &
          & key, ignoreTemplate, spreadflag, interpolate, force, sourceMask )
      case ( l_uncompressRadiance )
        if ( .not. got(f_systemTemperature) ) &
          & call Announce_Error ( key, No_Error_Code, &
          & 'Missing a systemTemperature field for uncompress radiance fill' )
        if ( .not. got(f_totalPowerQuantity) ) &
          & call Announce_Error ( key, No_Error_Code, &
          & 'Missing a totalPowerQuantity field for uncompress radiance fill' )
        if ( .not. got(f_terms) ) &
          & call Announce_Error ( key, No_Error_Code, &
          & 'Missing a terms field for uncompress radiance fill' )

        sysTempQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sysTempVectorIndex), sysTempQuantityIndex )
        totalpowerQuantity => GetVectorQtyByTemplateIndex ( &
          & vectors(totalpowerVectorIndex), totalpowerQuantityIndex )
        call UncompressRadiance ( key, quantity, totalPowerQuantity, sysTempQuantity, termsNode )

      case ( l_vGrid ) ! ---------------------  Fill from vGrid  -----
        select case ( quantity%template%quantityType )
        case ( l_ptan )
          neededCoordinate = l_zeta
        case ( l_tngtGeodAlt )
          neededCoordinate = l_geodAltitude
        case ( l_tngtGeocAlt )
          neededCoordinate = l_geocAltitude
        end select
        if ( vGrids(vGridIndex)%verticalCoordinate /= neededCoordinate ) &
          & call Announce_Error ( key, No_Error_code, &
          &  'Vertical coordinate vGrid does not match fill' )
        if ( vGrids(vGridIndex)%noSurfs /= quantity%template%noSurfs )&
          & call Announce_Error ( key, No_Error_code, &
          &  'VGrid is not of the same size as the quantity' )
        quantity%values = spread ( vGrids(vGridIndex)%surfs(:,1), 2, &
          & quantity%template%noInstances )

      case ( l_wmoTropopause ) ! ---------------- Fill with wmo tropopause --
        if ( .not. all(got( (/ f_temperatureQuantity, f_refGPHquantity /) ))) &
          & call Announce_Error ( key, no_error_code, &
          & 'wmoTropopause fill needs temperatureQuantity, refGPHQuantity' )
        if ( .not. ValidateVectorQuantity ( quantity, &
          & quantityType = (/l_boundaryPressure/), verticalCoordinate=(/l_none/), &
          & coherent=.true., stacked=.true. ) ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Quantity is not a boundary pressure' )

        temperatureQuantity => GetVectorQtyByTemplateIndex( &
          &  vectors(temperatureVectorIndex), temperatureQuantityIndex)
        if ( .not. ValidateVectorQuantity ( temperatureQuantity, &
          & quantityType = (/l_temperature/), verticalCoordinate=(/l_zeta/), &
          & coherent=.true., stacked=.true. ) ) &
          & call Announce_Error ( key, badTemperatureQuantity )

        refGPHQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(refGPHVectorIndex), refGPHQuantityIndex)
        if ( .not. ValidateVectorQuantity ( refGPHQuantity, &
          & quantityType = (/l_refGPH/), verticalCoordinate=(/l_zeta/), &
          & coherent=.true., stacked=.true., noSurfs=(/1/) ) ) &
          & call Announce_Error ( key, badrefGPHQuantity )

        if ( .not. DoHGridsMatch ( quantity, temperatureQuantity ) .or. &
          &  .not. DoHGridsMatch ( quantity, refGPHQuantity ) ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Horizontal coordinates for temperature/refGPH and/or quantity disagree' )

        ! OK, we must be ready to go
        if ( .not. USEREICHLER ) then
          call WithWMOTropopause ( quantity, &
          & temperatureQuantity, refGPHQuantity, vGrids(internalVGridIndex) )
        else
          call WithReichlerWMOTP ( quantity, &
          & temperatureQuantity )
        end if
      case (-1)
        ! We must have decided to skip this fill
      case default
        call Announce_error ( key, no_Error_Code, 'This fill method not yet implemented' )
      end select      ! s_method
      ! Before leaving, we must restore the original mask (or lack of one)
      ! (unless the Fill method is l1b because we may be using the
      ! radiance precision to set the radiance mask)
      if ( fillMethod == l_l1b ) then
        ! For this Fill method the new mask is sticky
        qtyWasMasked = associated(quantity%mask)
      elseif ( qtyWasMasked ) then
        quantity%mask = tempQuantity%mask
      else
        if ( associated(quantity%mask) ) call ClearMask( quantity%mask )
      endif
      ! Housekeeping
      call destroyVectorQuantityValue ( tempQuantity, &
        & destroyMask=.true., destroyTemplate=.false. )
    end subroutine FillCommand

    ! ............................................  Get_File_Name  .....
    subroutine Get_File_Name ( fileIndex, pcfCode, &
      & fileType, fileDataBase, MLSFile, MSG, pcfEndCode )
      use FillUtils_1, only: Announce_Error
      use Hdf, only: Dfacc_Rdonly
      use Intrinsic, only: L_Ascii, L_Hdf
      use MLSCommon, only: MLSFile_T
      use MLSFiles, only: HDFVersion_5, &
        & AddInitializeMLSFile, GetPCFromRef, Split_Path_Name
      use MLSL2Options, only: Toolkit
      use SDPToolkit, only: Pgs_Pc_Getreference
      use String_Table, only: Get_String
      ! Dummy args
      integer, intent(in) :: fileIndex ! index into string table
      integer, intent(in) :: pcfCode
      integer, intent(in) :: fileType ! l_hdf, etc.
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (MLSFile_T), pointer   :: MLSFile
      character(len=*), intent(in) :: MSG ! in case of error
      integer, intent(in), optional :: pcfEndCode
      ! Internal variables
      character(len=255) :: fileName, fileTypeStr, PCFFileName, path, shortName
      integer :: lun
      integer :: mypcfEndCode
      integer :: returnStatus             ! non-zero means trouble
      integer :: version
      ! Executable
      mypcfEndCode = 0
      lun = 0
      version = 1
      if ( deebug ) call outputNamedValue( 'About to get_string for file name', fileIndex )
      call get_string ( fileIndex, shortName, strip=.true. )
      fileName = shortName
      if ( deebug ) call outputNamedValue( 'Result', fileName )
      if ( deebug ) call outputNamedValue( 'About to get_string for file type', lit_indices(fileType) )
      call get_string ( lit_indices(fileType), fileTypeStr, strip=.true. )
      if ( deebug ) call outputNamedValue( 'Result', fileTypeStr )
      if ( noPCFid ) then
        ! Already have fileName; must trust it's OK and not just a fragment
      elseif ( TOOLKIT .and. index (fileName, '/') < 1 ) then
        mypcfEndCode = pcfCode
        if ( present(pcfEndCode) ) mypcfEndCode = pcfEndCode
        if ( fileName == ' ' ) then
          returnStatus = Pgs_pc_getReference( pcfCode, version, fileName )
          lun = pcfCode
        else
          PCFFileName = fileName
          call split_path_name ( PCFFileName, path, fileName )
          lun = GetPCFromRef( fileName, pcfCode, &
            & mypcfEndCode, &
            & TOOLKIT, returnStatus, Version, DEEBUG, &
            & exactName=PCFFileName )
          if ( returnStatus /= 0 ) then
            call Announce_Error ( 0, son, extraMessage=MSG )
          else
            fileName = PCFFileName
          end if
        end if
      end if
      if ( fileType == l_hdf ) then
        MLSFile => AddInitializeMLSFile(filedatabase, &
          & content=fileTypeStr, &
          & name=Filename, shortName=shortName, &
          & type=l_hdf, access=dfacc_rdonly, HDFVersion=HDFVERSION_5)
      else
        MLSFile => AddInitializeMLSFile(filedatabase, &
          & content=fileTypeStr, &
          & name=Filename, shortName=shortName, &
          & type=l_ascii, access=dfacc_rdonly)
      endif      
      MLSFile%PCFId = lun
    end subroutine Get_File_Name

  end subroutine MLSL2Fill

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Fill.f90,v 2.487 2023/12/07 23:07:20 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------
end module Fill
!=============================================================================

!
! $Log: Fill.f90,v $
! Revision 2.487  2023/12/07 23:07:20  pwagner
! Improved ResidualCorrection Fill method
!
! Revision 2.486  2023/10/19 20:38:53  pwagner
! Added residualCorrection Fill method
!
! Revision 2.485  2020/07/29 23:36:19  pwagner
! May utilize BooleanFromEmptyGrid in Fill sections
!
! Revision 2.484  2020/07/22 23:00:17  pwagner
! Many changes to allow GriddedData to be read and used during Fill sections
!
! Revision 2.483  2020/07/09 23:55:06  pwagner
! Many cmds from readApriori and MergeGrids phase now available to Fill phase
!
! Revision 2.482  2019/10/16 20:55:57  pwagner
! Subset command may take a MissingValue field
!
! Revision 2.481  2019/02/21 22:37:22  pwagner
! Assure Dumps are sent to stdout
!
! Revision 2.480  2019/02/13 18:59:44  pwagner
! Corrected mispelling, added debug Dumps
!
! Revision 2.479  2018/09/13 20:24:17  pwagner
! Moved changeable options to new L2Options; added DumpOptions
!
! Revision 2.478  2018/07/27 23:18:48  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.477  2018/05/12 00:10:24  pwagner
! Print less if not deebugging
!
! Revision 2.476  2018/04/16 22:14:48  pwagner
! Improved how we DirectRead plain hdf files
!
! Revision 2.475  2018/04/13 00:17:39  pwagner
! Reduced non-debug printing
!
! Revision 2.474  2018/03/14 22:52:32  pwagner
! Reduce output when changing settings
!
! Revision 2.473  2018/02/23 22:09:23  mmadatya
! Added l_instECR for ASMLS
!
! Revision 2.472  2017/12/15 18:33:19  mmadatya
! Added heightFromPressure as new Fill method
!
! Revision 2.471  2017/12/07 01:01:23  vsnyder
! Don't use host-associated variable as a DO index
!
! Revision 2.470  2017/11/15 00:38:35  pwagner
! Must Dump options for output if debugging a phase or changing settings
!
! Revision 2.469  2017/07/27 16:57:37  pwagner
! Geolocations now add day, month, etc.; DirectRead may look under groupName
!
! Revision 2.468  2017/07/10 18:50:47  pwagner
! Transfer may /expandMask to all masking bits; may /skipValues to transfer only mask; Fill may replaceMissingValue=
!
! Revision 2.467  2017/04/07 18:46:17  pwagner
! sourceType used when choosing how to Fill ascenddescend
!
! Revision 2.466  2017/04/06 23:43:10  pwagner
! May choose to base on asc/desc mode on GHz/GeodAngle via manipulation field
!
! Revision 2.465  2017/03/23 16:44:40  pwagner
! Improved message printed when unable to time sections
!
! Revision 2.464  2017/02/08 17:55:28  pwagner
! /sourceMask causes vector Fills to obey mask from source, not destination
!
! Revision 2.463  2016/11/08 17:32:57  pwagner
! Use SayTime subroutine from time_m module; process /reset field
!
! Revision 2.462  2016/09/02 00:49:40  vsnyder
! Change default geolocation from L_None to L_Geodetic.  The result is that
! the geodLat and Lon fields of HGrids are always filled.
!
! Revision 2.461  2016/06/14 22:52:46  vsnyder
! The default for ReferenceMIFUnits is PHYQ_Dimensionless, but just to make
! sure, set it to PHYQ_Dimensionless every place that ReferenceMIF is an
! index instead of an altitude.
!
! Revision 2.460  2016/05/18 01:37:30  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.459  2016/04/01 00:27:15  pwagner
! May now Execute a single command or a script of lines from l2cf
!
! Revision 2.458  2015/12/01 21:19:57  pwagner
! May Fill with nearest profile number
!
! Revision 2.457  2015/09/30 20:32:36  pwagner
! With /noZeros field negativePrecision command now resets 0 to -1
!
! Revision 2.456  2015/09/25 02:13:26  vsnyder
! Add ReferenceMIFUnits to call to UsingMagneticModel
!
! Revision 2.455  2015/09/22 23:39:05  vsnyder
! Add ReferenceMIF and Regular fields
!
! Revision 2.454  2015/09/17 23:16:15  pwagner
! Added changeSettings command
!
! Revision 2.453  2015/08/25 17:32:53  vsnyder
! PhiWindow is a tuple, with the first element specifying the angles or
! number of profiles/MAFs before the tangent point, and the second
! specifying the angles or number after.  Set its default to [1,2] instead
! of 4.  Check that the units are either angles or profiles.  If it's input
! as a tuple, allow one to be dimensionless.  If it's not a tuple, and its
! units are profiles, it specifies the total number of profiles; put (n-1)/2
! before and the rest after after, with one more before if n is even.  If
! it's not a tuple and its units are angles, put half before and half after.
!
! Revision 2.452  2015/04/30 02:54:31  vsnyder
! Allow to run the magnetic model without ScVelECR and TngtGeocAlt
!
! Revision 2.451  2015/04/29 01:18:41  vsnyder
! Correct reference to UsingMagneticModel
!
! Revision 2.450  2015/04/21 17:48:08  pwagner
! May DirectRead, DirectWrite files with /noPCFid even when usingPCF; may DirectRead qty geolocations
!
! Revision 2.449  2015/04/09 22:18:58  pwagner
! We may DirectRead a quantity type
!
! Revision 2.448  2015/03/28 02:34:16  vsnyder
! Add requirement for ScVelECR and TngtGeocAlt fields for magnetic field
! fill.  Remove GPHQuantity from magnetic field fill (because we use
! geometric height now).  Added stuff to trace allocate/deallocate addresses.
!
! Revision 2.447  2014/12/10 21:29:12  pwagner
! Pass ptanQuantity for AscendDescend method
!
! Revision 2.446  2014/10/31 17:43:45  vsnyder
! Separate PTan and GPH hydrostatic fills
!
! Revision 2.445  2014/09/30 02:14:38  vsnyder
! Some stuff that might be useful if we turn on matrix finalizers
!
! Revision 2.444  2014/09/05 00:56:02  vsnyder
! More complete and accurate allocate/deallocate size tracking.  Remove
! declarations of unused variables.  Send HGrids database to DumpCommand.
!
! Revision 2.443  2014/09/05 00:49:06  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.442  2014/06/03 22:42:54  pwagner
! Pass hGrids to Dump so we may Dump them
!
! Revision 2.441  2014/04/22 00:45:36  vsnyder
! Cannonball polishing
!
! Revision 2.440  2014/03/20 01:41:48  vsnyder
! Get Base_Unit from Declaration_Table, improve some tracing
!
! Revision 2.439  2014/03/01 03:10:56  vsnyder
! Move units checking to init_tables_module
!
! Revision 2.438  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.437  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.436  2013/11/20 01:01:33  pwagner
! Prevent accidental reference to undefined pointer phiTanQuantity
!
! Revision 2.435  2013/10/24 21:05:20  pwagner
! /dontLatch in profile Fills retains profile heights as input
!
! Revision 2.434  2013/10/09 23:41:20  vsnyder
! Add Evaluate_Variable
!
! Revision 2.433  2013/10/02 00:48:26  pwagner
! Added ascenddescend Fill Method
!
! Revision 2.432  2013/10/01 22:20:58  pwagner
! geolocation Fill method can fill from any named dataset in l1boa file
!
! Revision 2.431  2013/09/28 00:31:34  pwagner
! Added check for required GPHQuantity with gphResetToGeoid method
!
! Revision 2.430  2013/09/27 00:39:59  pwagner
! More intuitive interpretations for geoidData, gphResetToGeoid methods
!
! Revision 2.429  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.428  2013/09/21 00:24:44  pwagner
! Added geoid Fill methods
!
! Revision 2.427  2013/09/17 22:43:45  pwagner
! Added Scatter, Gather methods
!
! Revision 2.426  2013/09/17 00:52:38  vsnyder
! Correct 'no_code_for' error message
!
! Revision 2.425  2013/08/30 02:45:37  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.424  2013/07/12 23:26:51  vsnyder
! Mistakenly commited a bunch of debugging stuff
!
! Revision 2.423  2013/07/12 23:25:28  vsnyder
! Remove unreferenced error messages
!
! Revision 2.422  2013/06/14 18:49:22  vsnyder
! Decruftification
!
! Revision 2.421  2013/05/31 00:42:12  vsnyder
! Add geolocation field to fill, used only if method=l1b
!
! Revision 2.420  2013/05/17 00:49:29  pwagner
! May constrain Transfer command command to quantitynames by r/t Boolean
!
! Revision 2.419  2013/04/24 00:37:42  pwagner
! Added InitRepeat and NextRepeat calls to set/increment r/t Boolean count
!
! Revision 2.418  2013/04/22 17:51:32  pwagner
! Reevaluate may store a literal instead of a Boolean value
!
! Revision 2.417  2013/04/17 00:05:07  pwagner
! Added new Repeat control structure to Fill, Retrieve sections
!
! Revision 2.416  2013/01/17 20:02:02  pwagner
! New where field in Subset command
!
! Revision 2.415  2013/01/02 21:40:59  pwagner
! Added derivative method to Fill command; Transfer can do Fill methods, too
!
! Revision 2.414  2012/11/14 20:04:11  pwagner
! Fix boxcar bug added with last commit
!
! Revision 2.413  2012/11/14 00:58:42  pwagner
! Use dimList for choosing which of {csi} to average over; finished treating width=1
!
! Revision 2.412  2012/11/08 23:21:30  pwagner
! dimList field lets us specifiy whether to shift by [c,s,i] during manipulate
!
! Revision 2.411  2012/11/05 19:02:48  pwagner
! Fixed various bugs related to last changes
!
! Revision 2.410  2012/10/31 00:08:40  pwagner
! Must treat Fill method L1B specially when restoring quantity mask
!
! Revision 2.409  2012/10/29 17:18:24  pwagner
! Made consistent with FillUtils_1 api
!
! Revision 2.408  2012/10/27 00:27:29  pwagner
! Temporary fixes; cause of error not yet understood
!
! Revision 2.407  2012/10/22 18:14:50  pwagner
! Many Subset operations now available in Fill
!
! Revision 2.406  2012/10/09 00:48:30  pwagner
! New ignoreTemplate, changed force meaning in Fill
!
! Revision 2.405  2012/08/16 17:57:16  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.404  2012/07/31 00:48:16  vsnyder
! Use DestroyVectorQuantityValue abstraction
!
! Revision 2.403  2012/05/08 17:49:04  pwagner
! Added Select .. Case .. EndSelect control structure
!
! Revision 2.402  2012/02/24 21:20:44  pwagner
! DirectRead may /interpolate vertically
!
! Revision 2.401  2012/02/13 23:28:45  pwagner
! Corrected error message
!
! Revision 2.400  2012/02/10 23:45:43  vsnyder
! Add more tracing, change some tracing levels
!
! Revision 2.399  2012/02/02 01:19:05  pwagner
! Can DirectRead matrix or hessian
!
! Revision 2.398  2012/01/25 01:19:01  pwagner
! Removed unused args to ..FromFile calls
!
! Revision 2.397  2012/01/18 20:38:59  vsnyder
! Check consistency of covariance matrix and diagonal vector
!
! Revision 2.396  2011/12/15 01:49:43  pwagner
! Added sdName and /spread fields to DirectRead
!
! Revision 2.395  2011/11/04 00:28:18  pwagner
! Added autoFill flag to Vector Spec to start it off with non-zero values in appropriated quantities
!
! Revision 2.394  2011/10/07 00:06:02  pwagner
! May dump Matrices, Hessians from Fill, Join
!
! Revision 2.393  2011/06/16 20:52:22  vsnyder
! Get codes for Announce_Error from FillUtils.  Add f_expr, but with a
! noCodeFor error message -- to be implemented later.
!
! Revision 2.392  2011/04/20 16:46:37  pwagner
! Removed unused declaration
!
! Revision 2.391  2011/03/22 23:47:54  pwagner
! May now reshape qty template field while filling explicitly
!
! Revision 2.390  2011/03/15 22:51:58  pwagner
! May now modify quantity template fields with fill method
!
! Revision 2.389  2010/11/20 00:01:14  pwagner
! May specifiy surfaces gap beyond which to zero out in Streamline
!
! Revision 2.388  2010/08/06 23:08:48  pwagner
! Pass Hessians, matrices to DumpCommand
!
! Revision 2.387  2010/07/22 17:42:24  pwagner
! Replaced method=special fills with unique names
!
! Revision 2.386  2010/07/06 16:06:06  pwagner
! Better error checking in Transfer
!
! Revision 2.385  2010/07/01 00:49:19  pwagner
! Transfer between vectors may now also manipulate
!
! Revision 2.384  2010/05/19 23:06:45  pwagner
! Shorten most Fill routine names
!
! Revision 2.383  2010/05/19 17:53:19  pwagner
! Removed unused stuff
!
! Revision 2.382  2010/04/28 16:24:11  pwagner
! May specify instances range in explicit Fill
!
! Revision 2.381  2010/04/22 23:36:46  pwagner
! May fill num rads/MIF as a percentage
!
! Revision 2.380  2010/04/13 01:43:09  vsnyder
! Move FlushLockedBins from LinearizedForwardModel_m to L2PCBins_m
!
! Revision 2.379  2010/03/26 23:16:56  vsnyder
! Add Threshold to StreamlineHessian
!
! Revision 2.378  2010/03/25 01:50:25  vsnyder
! Make sure GeodAngle and ScaleHeight get values in StreamlineHessian
!
! Revision 2.377  2010/02/25 18:37:51  pwagner
! Adds support for new Hessian data type
!
! Revision 2.376  2009/10/26 17:11:28  pwagner
! Added Diff command to be used like Dump in l2cf
!
! Revision 2.375  2009/08/24 20:13:47  pwagner
! May Fill H2O precision from RHI precision
!
! Revision 2.374  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.373  2009/04/29 23:12:54  pwagner
! Manipulation Fills can be restricted by height and heightRange
!
! Revision 2.372  2009/04/28 20:02:50  pwagner
! No longer sets undefined values in RHI to -999.99
!
! Revision 2.371  2009/04/16 21:55:05  pwagner
! /exact keyword in status Fill to fix radiance bug
!
! Revision 2.370  2009/04/13 20:45:57  pwagner
! heightRange in explicit Fill can fill above or below specified height
!
! Revision 2.369  2009/03/05 18:37:59  pwagner
! May specifiy height, channel with explicit Fill
!
! Revision 2.368  2008/12/18 21:14:05  pwagner
! May now dump an l2pc or allL2PCs (use with caution)
!
! Revision 2.367  2008/11/06 21:50:46  pwagner
! Fill method swapValues swaps values between two quantities
!
! Revision 2.366  2008/09/24 16:46:37  livesey
! Tidy up handling of ptan in profile fill
!
! Revision 2.365  2008/09/19 23:55:05  pwagner
! May now Destroy GriddedData
!
! Revision 2.364  2008/09/16 22:29:05  pwagner
! pass optional field ptanQuantity to profile, vector methods
!
! Revision 2.363  2008/08/14 20:59:00  pwagner
! /interpolate now possible field in Transfer command
!
! Revision 2.362  2008/05/28 21:52:48  pwagner
! geo location Fill method to fill chunk numbers[maf]
!
! Revision 2.361  2008/04/26 00:40:07  livesey
! Added total power stuff
!
! Revision 2.360  2008/04/11 01:17:22  livesey
! Added uncompressRadiance fill
!
! Revision 2.359  2007/12/07 01:13:39  pwagner
! Lets us catch warnings and assign to runtime Booleans
!
! Revision 2.358  2007/11/15 22:53:16  pwagner
! May set runtimeBooleans by anyGood.., Compare, Reevaluate commands
!
! Revision 2.357  2007/11/05 18:38:09  pwagner
! May Skip remaining lines in Fill, Join, Retrieve sections depending on Boolean
!
! Revision 2.356  2007/09/27 22:00:45  pwagner
! Much moved into new FillUtils_1 module; Intel compiler can now optimize
!
! Revision 2.355  2007/08/27 23:56:34  pwagner
! /spread flag now affects statistical manipulation Fills
!
! Revision 2.354  2007/08/23 22:17:05  pwagner
! manipulation Fills can now use statistical functions
!
! Revision 2.353  2007/08/20 22:04:48  pwagner
! Many procedures now push their names onto MLSCallStack
!
! Revision 2.352  2007/07/06 17:09:16  pwagner
! Reverted to former ApplyBaseline
!
! Revision 2.351  2007/06/21 22:34:32  pwagner
! Fixed inconsequential bug in adding baseline when quantity was masked
!
! Revision 2.350  2007/03/23 00:26:09  pwagner
! More unused debugging; skips filling covariance matrix if skipping retrievals
!
! Revision 2.349  2007/01/12 00:34:04  pwagner
! Renamed routine outputNamedValue
!
! Revision 2.348  2006/11/03 19:40:17  pwagner
! Fixed unassociated pointers NAG caught
!
! Revision 2.347  2006/11/03 00:26:07  pwagner
! Fixed bug in tropopause calculation
!
! Revision 2.346  2006/10/11 22:56:11  pwagner
! May fill convergence from dnwt_chisqRatio
!
! Revision 2.345  2006/10/03 20:24:11  pwagner
! Optional test, tweaks to ChiSqRatio
!
! Revision 2.344  2006/10/02 23:05:03  pwagner
! May Fill chi^2 ratio to measure convergence
!
! Revision 2.343  2006/08/03 01:58:03  vsnyder
! Better error message if profile is out of order
!
! Revision 2.342  2006/08/02 19:52:29  vsnyder
! Move destroy processing to DestroyCommand_m
!
! Revision 2.341  2006/07/28 01:55:20  vsnyder
! Improve error detection and reporting for some allocations.
! Comment out matrix and vector dumps conditioned on the -g level since
! these dumps can be gotten by dump and dumpBlocks commands.  Inserted
! a comment to that effect.
!
! Revision 2.340  2006/07/27 23:07:38  pwagner
! Attempt to enforce conformity between column unit attributes and how we compute them
!
! Revision 2.339  2006/07/27 03:54:11  vsnyder
! Include source_ref in created vectors and matrices
!
! Revision 2.338  2006/07/12 20:41:16  pwagner
! Fixed BO size mismatch that only NAG caught
!
! Revision 2.337  2006/07/07 23:08:53  pwagner
! Fixed bug in filling from GEOS5-derived grid
!
! Revision 2.336  2006/06/13 22:14:18  pwagner
! Recover gracefully if l1boa file lacks BO_stat dataset
!
! Revision 2.335  2006/06/12 19:28:52  pwagner
! Fallback to climatology noted only if all of ncep, goes4/5 missing
!
! Revision 2.334  2006/06/08 17:29:27  dwu
! add option to allow sourceQuantity in spreadChannel
!
! Revision 2.333  2006/06/03 01:43:36  vsnyder
! Allow multiple fields and multiple vectors/matrices per field on destroy
!
! Revision 2.332  2006/05/22 21:56:00  pwagner
! Fixed bug besetting manipulation fills
!
! Revision 2.331  2006/05/19 00:00:13  pwagner
! Added min, max operators ('<', '>') to manipulation fills with c
!
! Revision 2.330  2006/05/03 22:18:26  pwagner
! Sets mask reading quantities missing from l1b file
!
! Revision 2.329  2006/03/23 03:06:35  vsnyder
! Use HFTI instead of Cholesky for UsingLeastSquares, for stability
!
! Revision 2.328  2006/03/23 00:38:57  vsnyder
! Make SolveLS a little more general, in case somebody else wants to use it
!
! Revision 2.327  2006/03/22 23:47:37  vsnyder
! More work on least-squares fill
!
! Revision 2.326  2006/03/15 23:55:11  pwagner
! Use reorderPrecedence to ensure higher precedes lower in manipulations
!
! Revision 2.325  2006/03/13 23:42:37  pwagner
! Added c=numeric type field to Fill via manipulation
!
! Revision 2.324  2006/03/09 16:25:01  pwagner
! Fixed a bug only NAG caught
!
! Revision 2.323  2006/03/08 21:30:32  pwagner
! Added new manipulations: a/b, 1/a, -a, abs(a), sign(a), log(a)
!
! Revision 2.322  2006/02/21 19:16:10  pwagner
! GetHashElement is now a generic
!
! Revision 2.321  2006/02/15 00:01:19  pwagner
! Shoule let you fill H2O from new RHIvmr quantity
!
! Revision 2.320  2006/02/10 21:18:48  pwagner
! Added code for wmoTropopause (unused); dumps may go to special dumpfile
!
! Revision 2.319  2006/01/11 17:04:32  pwagner
! May specify unit when filling column abundances
!
! Revision 2.318  2006/01/06 01:16:34  pwagner
! silent boolean field can silence selected phases
!
! Revision 2.317  2006/01/05 03:48:17  vsnyder
! Use Interp_Bilinear_2d_1d (as InterpolateValues)
!
! Revision 2.316  2006/01/05 00:04:45  vsnyder
! Implement refractive correction for PhiTan fill, correct some error
! messages and rephrase others to make sense.
!
! Revision 2.315  2005/12/22 21:05:20  vsnyder
! Use Hydrostatic_no_der (by way of generic)
!
! Revision 2.314  2005/11/17 20:12:51  pwagner
! Can now read BO_stat successfully
!
! Revision 2.313  2005/11/15 00:21:12  pwagner
! Removed space between Is and Precision
!
! Revision 2.312  2005/11/11 21:49:41  pwagner
! May set l1b precisions negative if avoidBrightObjects set
!
! Revision 2.311  2005/10/18 16:56:43  pwagner
! Negative RHIPrecision when either T or H2O Precisions are
!
! Revision 2.310  2005/09/21 23:21:58  pwagner
! Use of single arg options in Explicit replaces three
!
! Revision 2.309  2005/08/04 03:28:50  vsnyder
! Correct fill for goofy L1BMIF_TAI, lots of cannonball polishing
!
! Revision 2.308  2005/08/03 18:09:38  vsnyder
! Cannon ball polishing, scan averaging
!
! Revision 2.307  2005/07/21 23:42:31  pwagner
! Repaired bugs in Fill status for missingGMAO; extras for explicit fill
!
! Revision 2.306  2005/07/12 17:40:52  pwagner
! May fill status with condition that no gmaos found
!
! Revision 2.305  2005/06/21 23:56:24  livesey
! Added forgiveZeros handling to Covariance for efficiency.
!
! Revision 2.304  2005/06/03 02:05:29  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! get VGrids from VGridsDatabase instead of passing as an argument.
!
! Revision 2.303  2005/05/31 18:11:45  pwagner
! Restored 2.300 revisions mistakenly omitted from 2.302
!
! Revision 2.302  2005/05/31 17:51:17  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.301  2005/05/28 03:25:40  vsnyder
! Cannonball polishing
!
! Revision 2.300  2005/05/27 20:03:06  vsnyder
! Dissassociated -> zero size before dump
!
! Revision 2.299  2005/03/24 21:23:46  pwagner
! Removed buggy, unused ColAbundance
!
! Revision 2.298  2005/03/12 00:50:27  pwagner
! May restart warnings counter at each phase
!
! Revision 2.297  2004/12/01 01:24:44  livesey
! Handles missing L1BMAFBaselines in the same manner as missing radiances.
!
! Revision 2.296  2004/11/30 01:41:58  livesey
! Make folded sideband fill cope with absence of one sideband (for R1A
! case).
!
! Revision 2.295  2004/11/29 21:53:33  livesey
! Bug fix for reading L1B data when no radiances files specified.
! Also, added (a+b)/2 manipulation and changed definition of quality to be
! 1.0/chisq.
!
! Revision 2.294  2004/11/24 22:51:37  livesey
! Bug fix in off line sideband folding
!
! Revision 2.293  2004/11/08 21:57:00  livesey
! Added handling of 'badRange' in ASCII fill
!
! Revision 2.292  2004/10/21 19:32:55  livesey
! Got the Fill from ASCII file working.
!
! Revision 2.291  2004/10/16 17:26:08  livesey
! Added stub of fill from ascii file
!
! Revision 2.290  2004/10/13 02:25:11  livesey
! Changes to fill from vGrid
!
! Revision 2.289  2004/09/28 22:26:46  livesey
! Bug fix in applyBaseline, had quadrature handled the wrong way round.
!
! Revision 2.288  2004/09/27 20:11:29  livesey
! Added stuff for reading and applying L1BMAFBaseline.  This includes new
! suffix argument to L1B reading.
!
! Revision 2.287  2004/09/25 00:16:31  livesey
! Removed 'key' argument in CombineChannels call
!
! Revision 2.286  2004/09/24 17:55:57  livesey
! Moved WithCombinedChannels into ManipulateVectorQuantitites
!
! Revision 2.285  2004/09/24 03:38:26  livesey
! Added optional mapping matrix output to combine channels fill
!
! Revision 2.284  2004/09/21 22:59:18  livesey
! Another change to the chi-squared to quality conversion.
!
! Revision 2.283  2004/09/21 19:17:23  livesey
! Changed the 1-tanh to an exp in converting from chi squared to quality.
!
! Revision 2.282  2004/09/16 23:55:04  livesey
! Stopped binned fill from being so fussy.
!
! Revision 2.281  2004/09/10 23:53:10  livesey
! Added centerVertically option for binmean/max/min fill
!
! Revision 2.280  2004/08/24 23:24:46  pwagner
! Asks ReadL1BData to pad, contract--partly tested
!
! Revision 2.279  2004/08/23 21:59:42  pwagner
! Disabled debugging dumps of section, phase timings
!
! Revision 2.278  2004/08/03 18:01:14  pwagner
! Gets DEFAULTUNDEFINEDVALUE from MLSCommon
!
! Revision 2.277  2004/07/30 00:17:22  livesey
! Changed some errors to warnings
!
! Revision 2.276  2004/07/22 20:39:14  cvuu
! Now can fill ForwardModel time, mean and std_dev
!
! Revision 2.275  2004/06/29 18:06:28  pwagner
! May fill phase, section timings
!
! Revision 2.274  2004/06/10 00:58:45  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.273  2004/05/28 00:57:49  vsnyder
! Move GetIndexFlagsFromList from MoreTree to Expr_m
!
! Revision 2.272  2004/05/19 20:38:04  vsnyder
! Remove unreferenced symbols, polish some cannonballs
!
! Revision 2.271  2004/05/19 19:16:09  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.270  2004/05/04 01:03:56  livesey
! Added excludeBelowBottom flag for binmax/binmin fill
!
! Revision 2.269  2004/05/01 04:04:36  vsnyder
! Use DumpCommand
!
! Revision 2.268  2004/04/28 00:30:58  livesey
! Added a|b option in manipulate fill.
!
! Revision 2.267  2004/04/19 21:04:02  livesey
! Bug fix in ExtractSingleChannel
!
! Revision 2.266  2004/04/16 00:49:03  livesey
! Added extractChannel fill
!
! Revision 2.265  2004/04/13 21:19:10  livesey
! Bug fix in negative precision flagging.
!
! Revision 2.264  2004/04/02 01:06:46  livesey
! Got the status filling working.
!
! Revision 2.263  2004/03/22 18:25:25  livesey
! Added CombineChannels fill (may actually replace this before too long).
!
! Revision 2.262  2004/03/18 17:41:31  livesey
! Bug fix in quality fill.
!
! Revision 2.261  2004/03/17 17:16:11  livesey
! New status fill and new manipulations.
!
! Revision 2.260  2004/03/10 22:19:51  livesey
! Added quality fill method
!
! Revision 2.259  2004/03/03 22:40:59  livesey
! Added a<b and a>b to manipulations
!
! Revision 2.258  2004/03/03 19:26:38  pwagner
! More printing if tropopause outside pressure grid
!
! Revision 2.257  2004/02/20 00:43:27  pwagner
! Clarified warning message when tropopause too big/little
!
! Revision 2.256  2004/02/19 23:59:00  pwagner
! Integrates column abundances using WReads method
!
! Revision 2.255  2004/02/17 14:08:27  livesey
! Added functionality to the box car and binning fills
!
! Revision 2.254  2004/02/06 01:01:40  livesey
! Added boxcar fill method
!
! Revision 2.253  2004/01/30 23:28:33  livesey
! Insist on loading a plain matrix
!
! Revision 2.252  2004/01/29 03:32:42  livesey
! Made Covariance (temporarily?) fill both sides of the digaonal (in
! any case was wrongly doing upper).
!
! Revision 2.251  2004/01/23 19:07:35  livesey
! Finished off the adoption stuff
!
! Revision 2.250  2004/01/23 05:47:38  livesey
! Added the adoption stuff
!
! Revision 2.249  2004/01/20 20:26:03  livesey
! Added the binMean fill
!
! Revision 2.248  2003/12/04 22:19:32  livesey
! Added ability to fill from l2gpPrecision field
!
! Revision 2.247  2003/11/25 21:54:47  livesey
! Made the column filling algorithm much less fussy.
!
! Revision 2.246  2003/11/05 18:37:25  pwagner
! Now can dump either entire vector or a single quantity
!
! Revision 2.245  2003/10/22 21:17:06  pwagner
! aPhaseName: Phase added to Fill, Construct sections to time phases
!
! Revision 2.244  2003/10/15 23:12:08  livesey
! Added ResetUnusedRadiances
!
! Revision 2.243  2003/10/07 15:44:27  cvuu
! add new flag ignoreGeolocation in subroutine FromL2GP
!
! Revision 2.242  2003/09/25 16:41:12  michael
! magnetic field Elevation angle is constrained to 0-90 degrees.
!
! Revision 2.241  2003/09/09 22:06:38  livesey
! Added resilency to missing radiances.
!
! Revision 2.240  2003/08/28 00:44:54  livesey
! Made the a*b manipulation even more lenient
!
! Revision 2.239  2003/08/21 16:07:17  livesey
! Now calls FlushLockedBins (LinearizedForwardModel) rather than
! FlushL2PCBins (which is called by the former), as we want it also to
! forget which bin it chose.
!
! Revision 2.238  2003/08/20 20:05:42  livesey
! Added the a*b possibility to the manipulation fill.
!
! Revision 2.237  2003/08/16 00:29:37  vsnyder
! Correct a blunder: deg2rad should have been rad2deg
!
! Revision 2.236  2003/08/15 23:58:48  vsnyder
! Add MagAzEl fill method
!
! Revision 2.235  2003/08/13 19:23:45  vsnyder
! Make an error message more informative
!
! Revision 2.234  2003/08/08 23:07:02  livesey
! Added the rotate field fill.
!
! Revision 2.233  2003/07/16 22:39:47  livesey
! Bug fix in fill from l2aux
!
! Revision 2.232  2003/07/08 00:17:46  livesey
! Bug fix in column filling
!
! Revision 2.231  2003/06/24 19:59:42  livesey
! Fixed something in OffsetRadianceQuantity that might have become a bug
! one day (assumed m_linAlg=1).
!
! Revision 2.230  2003/06/20 19:37:06  pwagner
! Quanities now share grids stored separately in databses
!
! Revision 2.229  2003/06/05 22:08:55  livesey
! Cosmetic and superficial changes to FromSplitSideband
!
! Revision 2.228  2003/06/03 19:23:51  livesey
! Added flushL2PCBins
!
! Revision 2.227  2003/05/29 20:01:55  livesey
! Added reflector temperature model.
!
! Revision 2.226  2003/05/29 16:41:56  livesey
! Renamed sideband fraction
!
! Revision 2.225  2003/05/28 06:00:06  livesey
! Bug fix in profile fill where the 'latching' to the output surfaces was
! leading to redundancy in the interpolation
!
! Revision 2.224  2003/05/26 06:32:50  livesey
! Various mainly cosmetic changes to the column stuff
!
! Revision 2.223  2003/05/22 02:23:15  livesey
! Rewrite of explicit fill to make spread option more flexible.
!
! Revision 2.222  2003/05/22 00:26:33  dwu
! fix a problem in iwcfromextinction
!
! Revision 2.221  2003/05/21 18:58:57  dwu
! allow temperature and iwc on different hGrids in iwcFromExtinction
!
! Revision 2.220  2003/05/21 18:04:30  livesey
! Added a bit more intelligence to Covariance
!
! Revision 2.219  2003/05/20 23:10:24  dwu
! complete the addition of fill IWC from extinction
!
! Revision 2.218  2003/05/20 20:20:01  dwu
! add IWCfromExtinction
!
! Revision 2.217  2003/05/15 19:09:17  dwu
! changes in splitsideband
!
! Revision 2.216  2003/05/14 23:14:00  dwu
! nullify pointers in splitsideband
!
! Revision 2.215  2003/05/12 23:53:55  dwu
! fix a bug in splitsideband
!
! Revision 2.214  2003/05/12 22:11:07  dwu
! add more checkpoints in splitsideband
!
! Revision 2.213  2003/05/11 00:05:06  livesey
! Informative error message when L1B data wrong size
!
! Revision 2.212  2003/05/10 23:40:27  livesey
! Bug fixes in bining, other general tidyups.
!
! Revision 2.211  2003/05/10 22:20:12  livesey
! Made wmo tropopause resilient to being given stupid (i.e. 0) profiles.
!
! Revision 2.210  2003/05/10 01:07:58  livesey
! Added binTotal and noRads fills
!
! Revision 2.209  2003/05/08 19:34:58  dwu
! add more options to splitsideband, and tidy up
!
! Revision 2.208  2003/05/07 00:16:52  livesey
! Added the dump for magnetic field results.
!
! Revision 2.207  2003/05/06 21:00:23  livesey
! Bug fix on L1B stuff
!
! Revision 2.206  2003/04/30 22:07:14  pwagner
! Always sets errorCode to 0 in return from FromL2AUX
!
! Revision 2.205  2003/04/24 22:17:02  dwu
! remove dump statement in fill binMinMax
!
! Revision 2.204  2003/04/24 00:35:14  dwu
! modify splitSideband to allow the splitted sideband cloud radiances being spread to other bands assuming the f**4 law
!
! Revision 2.203  2003/04/24 00:29:45  dwu
! modify splitSideband to allow the splitted sideband cloud radiances being spread to other bands assuming the f**4 law
!
! Revision 2.202  2003/04/23 17:06:36  livesey
! Added binmax binmin fills
!
! Revision 2.201  2003/04/11 23:15:09  livesey
! Added force option to vector fill, and spreadChannel fill method.
!
! Revision 2.200  2003/04/11 21:56:40  livesey
! Added wmo tropopause stuff
!
! Revision 2.199  2003/04/08 23:13:01  dwu
! an update on splitsideband
!
! Revision 2.198  2003/04/07 06:37:42  dwu
! implement splitsideband for cloud radiance
!
! Revision 2.197  2003/04/05 00:26:47  livesey
! Bug fix in sideband splitting stub
!
! Revision 2.196  2003/04/05 00:05:37  livesey
! Added call to getSignal in split sideband
!
! Revision 2.195  2003/04/04 23:53:57  livesey
! Added skeleton for split sideband fill
!
! Revision 2.194  2003/04/04 22:01:59  livesey
! Added call to updateMask
!
! Revision 2.193  2003/04/04 00:08:06  livesey
! Added the wrapping of the gridded data before it's used in fill.
!
! Revision 2.192  2003/03/27 20:45:02  livesey
! Added logSpace argument to profile fill, and made it obey the dontMask
! flag
!
! Revision 2.191  2003/03/26 21:23:47  livesey
! Added ScaleOverlaps stuff
!
! Revision 2.190  2003/03/19 19:22:24  pwagner
! Passes chunkNo around more widely
!
! Revision 2.189  2003/03/07 03:16:12  livesey
! Added RestrictRange
!
! Revision 2.188  2003/03/06 00:46:30  livesey
! Added ability to do subset and flagCloud
!
! Revision 2.187  2003/03/05 19:11:11  livesey
! Added allowMissing capability to gridded fill.
!
! Revision 2.186  2003/02/28 02:26:23  livesey
! Added checking for bad/missing data in fill from gridded data.
!
! Revision 2.185  2003/02/27 00:38:52  livesey
! Better handling of missing length scale in Covariance
!
! Revision 2.184  2003/02/18 23:59:06  livesey
! Added phiWindow for hydrostatic fill.
!
! Revision 2.183  2003/02/15 00:35:03  livesey
! Added error checking for range of profile on L2GP fill.
!
! Revision 2.182  2003/02/13 21:42:12  livesey
! Added specific profile stuff to fill from l2gp.
!
! Revision 2.181  2003/01/29 01:59:19  livesey
! Changed some MLSMessages to Announce_Errors to get a line number.
!
! Revision 2.180  2003/01/28 21:53:07  pwagner
! RHI H2O conversions moved to fwdmdl from l2/Fill
!
! Revision 2.179  2003/01/16 21:48:58  vsnyder
! Fix a comment
!
! Revision 2.178  2003/01/15 23:29:41  pwagner
! Compatible with adjustable data types L2GPData
!
! Revision 2.177  2003/01/15 02:49:06  vsnyder
! Get SecPerYear from Geometry module
!
! Revision 2.176  2003/01/14 23:53:10  livesey
! Bug fix in magnetic model
!
! Revision 2.175  2003/01/14 22:39:25  livesey
! Bug fixes in magnetic stuff
!
! Revision 2.174  2003/01/14 21:58:59  vsnyder
! OOPS, Left out 'template' in reference to verticalCoordinate
!
! Revision 2.173  2003/01/14 21:34:09  vsnyder
! More work on magnetic field vector quantity
!
! Revision 2.172  2003/01/12 07:34:05  dwu
! with some fix for a-b manipulation
!
! Revision 2.171  2003/01/12 05:13:50  dwu
! add a-b manipulation (under the same conditions of the a+b case
!
! Revision 2.170  2003/01/08 23:52:16  livesey
! Bug fix in offset radiance
!
! Revision 2.169  2003/01/07 23:46:38  livesey
! Added magentic model
!
! Revision 2.168  2002/11/29 22:46:15  livesey
! Tidyup on l2aux fill
!
! Revision 2.167  2002/11/27 22:59:21  livesey
! Made the checking in ByManipulation a little more lenient
!
! Revision 2.166  2002/11/27 22:18:10  dwu
! Change the error handling in the new manipulation feature. Instead of quitting, just send off a warning
!
! Revision 2.165  2002/11/27 19:25:45  livesey
! Added manipulate method and bug fix in snooper when no matrices
!
! Revision 2.164  2002/11/21 01:18:11  livesey
! Added negativePrecision command (as distinct from fill method of same
! name).
!
! Revision 2.163  2002/11/14 17:28:01  livesey
! Made the profile fill do a 'nearest' on the input heights in the case of
! coherent quantities.
!
! Revision 2.162  2002/11/13 01:06:42  pwagner
! Fixed small bug
!
! Revision 2.161  2002/11/06 02:01:05  livesey
! Changes to fill from l2aux
!
! Revision 2.160  2002/10/26 00:02:51  livesey
! Another typo! Going too fast!
!
! Revision 2.159  2002/10/26 00:00:07  livesey
! Typo
!
! Revision 2.158  2002/10/25 23:59:45  livesey
! Forgot to include parameter f_offsetamount
!
! Revision 2.157  2002/10/25 23:56:14  livesey
! Added the offsetAmount argument default 1000K
!
! Revision 2.156  2002/10/17 18:18:50  livesey
! Added low/high bound to vector creation
!
! Revision 2.155  2002/10/16 20:15:27  mjf
! Added GPH precision.
!
! Revision 2.154  2002/10/10 23:52:57  pwagner
! Added code to fill from L1bdata with hdf5; untested
!
! Revision 2.153  2002/10/08 17:36:20  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.152  2002/10/03 13:44:04  mjf
! Renamed temperaturePrecisionQuantitiy to tempPrecisionQuantity to get
! names < 31 long.
!
! Revision 2.151  2002/10/02 23:04:47  pwagner
! RHI now separate fill methods
!
! Revision 2.150  2002/10/01 18:28:04  mjf
! New Fill for RHi precision including T error.
!
! Revision 2.149  2002/09/26 20:41:04  vsnyder
! Get Omega from Geometry instead of Units -- that's where it really belongs
!
! Revision 2.148  2002/09/25 20:08:14  livesey
! Made -g less verbose
!
! Revision 2.147  2002/09/13 18:10:10  pwagner
! May change matrix precision rm from r8
!
! Revision 2.146  2002/09/12 22:07:05  livesey
! Added masking to interpolated vector fill
!
! Revision 2.145  2002/09/10 20:50:33  livesey
! Added interpolated vector fill
!
! Revision 2.144  2002/09/10 01:00:32  livesey
! Added calls to NullifyMatrix
!
! Revision 2.143  2002/09/06 00:54:13  livesey
! Tiny change
!
! Revision 2.142  2002/09/05 21:48:54  livesey
! More fixes in transfer skipmask
!
! Revision 2.141  2002/09/05 20:49:38  livesey
! Added skipMask to transfer
!
! Revision 2.140  2002/08/28 01:13:52  livesey
! Added OffsetRadianceQuantity
!
! Revision 2.139  2002/08/26 20:01:09  livesey
! Added instances argument to profile fill
!
! Revision 2.138  2002/08/21 23:06:12  livesey
! Bug fix in profile fill
!
! Revision 2.137  2002/08/20 22:10:49  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.136  2002/08/20 19:30:24  livesey
! Typo!
!
! Revision 2.135  2002/08/20 19:19:41  livesey
! Tidied up FromProfile
!
! Revision 2.134  2002/08/16 16:08:58  livesey
! Bug fix in the Matrix fill (covariance with frequency variation).
!
! Revision 2.133  2002/08/15 03:52:52  livesey
! Added profile fill, still not complete though.
!
! Revision 2.132  2002/08/03 20:41:40  livesey
! Added snooping of matrices
!
! Revision 2.131  2002/06/26 01:26:21  livesey
! Added 2D pressure guesser
!
! Revision 2.130  2002/06/18 20:00:36  livesey
! Removed unwanted print
!
! Revision 2.129  2002/06/14 16:40:00  livesey
! Orbital inclination can now be filled from l1b
!
! Revision 2.128  2002/06/04 23:22:36  livesey
! Bug fixes on phiTan fill, other cleanups
!
! Revision 2.127  2002/06/04 22:40:44  livesey
! Added framework for phiTan fill
!
! Revision 2.126  2002/05/28 17:08:42  livesey
! More explicit error message still in l2gp fill.
!
! Revision 2.125  2002/05/23 20:51:53  livesey
! Bug fix, checking wrong in special fill for los velocity.
!
! Revision 2.124  2002/05/17 17:55:48  livesey
! Added sideband folding fill
!
! Revision 2.123  2002/05/14 00:26:25  livesey
! New code for system temperatures etc.
!
! Revision 2.122  2002/05/06 22:30:51  livesey
! Tidied up l2gp fill.
!
! Revision 2.121  2002/04/25 20:47:02  livesey
! Added channel dependent system temperature, and removed
! embarassing bug whereby radiance noise was sqrt(10) too small!
!
! Revision 2.120  2002/04/18 20:14:52  pwagner
! Fills either rhi from h2o or inverse; passes non-interpolating test
!
! Revision 2.119  2002/04/16 23:27:43  pwagner
! RHI testing begun; incomplete
!
! Revision 2.118  2002/04/13 00:31:46  pwagner
! More flesh on FillrhiFromH2o; still untested
!
! Revision 2.117  2002/04/11 23:51:28  pwagner
! Fleshed out RHIFromH2O; untested yet
!
! Revision 2.116  2002/04/10 17:45:44  pwagner
! Added RHI from h2oquantity (just a placeholder)
!
! Revision 2.115  2002/04/04 16:32:42  livesey
! Added negative error bar stuff
!
! Revision 2.114  2002/03/27 17:37:57  livesey
! Minor changes to random number stuff.
! Now seed incremented with chunk number
!
! Revision 2.113  2002/03/19 00:52:40  pwagner
! Some new checks added to FillLOSVelocity
!
! Revision 2.112  2002/03/14 17:29:59  pwagner
! Fixed check in FillLOSVelocity
!
! Revision 2.111  2002/03/14 01:01:17  pwagner
! Can fill scVelECI and scVelECR from l1b
!
! Revision 2.110  2002/03/13 22:01:41  livesey
! Added masking of fill from vector quantity, also changed
! from m_explicitfill to m_fill
!
! Revision 2.109  2002/03/08 08:07:00  livesey
! Added explicit fill mask
!
! Revision 2.105  2002/02/06 01:35:29  livesey
! Added ability to load ptan from l1b
!
! Revision 2.104  2002/02/05 01:45:21  livesey
! Added preliminary vector/vector fill, not yet tested.
!
! Revision 2.103  2002/01/18 00:24:21  livesey
! Added sideband argument to call to GetSignalName when reading
! L1B radiances (so can now read split signals).
!
! Revision 2.102  2002/01/16 18:06:31  livesey
! Changed neverFail flag in ReadL1B to false.  I want to see
! the error message.
!
! Revision 2.101  2002/01/09 00:00:04  pwagner
! Replaced write or print statements with calls to output
!
! Revision 2.100  2001/12/06 23:45:07  livesey
! Dealt with move of Omega to Units
!
! Revision 2.99  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.98  2001/10/26 23:23:05  pwagner
! Complies with l1b data dump
!
! Revision 2.97  2001/10/26 18:15:18  livesey
! Added upper argument to MatrixInversion in FillCovariance
!
! Revision 2.96  2001/10/25 23:32:11  pwagner
! Responds to l1b switch by dumping l1b quantity during Fill
!
! Revision 2.95  2001/10/24 22:35:33  dwu
! add Diagonal
!
! Revision 2.94  2001/10/23 16:38:09  pwagner
! Fill from l1b can fill precision, set mask
!
! Revision 2.93  2001/10/19 23:42:50  pwagner
! Applies multipliers to chi^2 fills, too
!
! Revision 2.92  2001/10/19 22:32:44  pwagner
! Can destroy a vector or a matrix; def. multiplier(s) in addNoise
!
! Revision 2.91  2001/10/19 00:00:36  pwagner
! Replaced remove with destroy
!
! Revision 2.90  2001/10/18 23:29:57  pwagner
! Fixes in addNoise, remove
!
! Revision 2.89  2001/10/18 23:07:40  livesey
! Removed debug dump statement
!
! Revision 2.88  2001/10/18 23:06:05  livesey
! Tidied up some bugs in transfer, must have been asleep or something!
!
! Revision 2.87  2001/10/18 22:30:30  livesey
! Added s_dump and more functionality to fillCovariance
!
! Revision 2.86  2001/10/18 03:51:46  livesey
! Just some tidying up.
!
! Revision 2.85  2001/10/18 00:46:32  livesey
! Bug fixes in Transfer
!
! Revision 2.84  2001/10/17 23:40:08  pwagner
! Exploits visibility of MATH77_ran_pack
!
! Revision 2.83  2001/10/16 23:34:05  pwagner
! intrinsic, resetseed, seed fields added to addnoise method
!
! Revision 2.82  2001/10/16 00:07:48  livesey
! Got smoothing working.
!
! Revision 2.81  2001/10/15 22:10:42  livesey
! Interim version with smoothing stubbed
!
! Revision 2.80  2001/10/02 23:12:50  pwagner
! More chi^2 fixes
!
! Revision 2.79  2001/09/28 23:59:20  pwagner
! Fixed various timing problems
!
! Revision 2.78  2001/09/28 17:50:30  pwagner
! MLSL2Timings module keeps timing info
!
! Revision 2.77  2001/09/24 17:28:15  pwagner
! Gets drang from MLSRandomNumber
!
! Revision 2.76  2001/09/21 23:23:35  pwagner
! Stiff fails to add noise properly
!
! Revision 2.75  2001/09/20 20:57:25  pwagner
! Fleshed out adding noise thing
!
! Revision 2.74  2001/09/19 23:42:29  pwagner
! New Remove command, ignore() fields
!
! Revision 2.73  2001/09/18 23:53:08  pwagner
! Replaced error field name with noise; began addNoise Fill method
!
! Revision 2.72  2001/09/17 23:12:21  pwagner
! Fleshed out FillChi.. some more
!
! Revision 2.71  2001/09/14 23:34:13  pwagner
! Now should allow special fill of chi^2..
!
! Revision 2.70  2001/08/03 23:13:52  pwagner
! Began testing; at least now exits normally again
!
! Revision 2.69  2001/08/02 00:17:06  pwagner
! Mostly done with column fill; untested
!
! Revision 2.68  2001/08/01 00:05:25  dwu
! remove f_sourceSGrid
!
! Revision 2.67  2001/07/31 23:53:37  dwu
! remove sGrid source
!
! Revision 2.66  2001/07/31 23:24:17  pwagner
! column abundance calculation more fleshed out--not tested
!
! Revision 2.65  2001/07/30 23:28:38  pwagner
! Added columnAbundances scaffolding--needs fleshing out
!
! Revision 2.64  2001/07/26 20:33:40  vsnyder
! Eliminate the 'extra' field of the 'matrix' spec
!
! Revision 2.63  2001/07/20 20:03:30  dwu
! fix problems in cloud extinction calculation
!
! Revision 2.62  2001/07/20 19:25:03  dwu
! add cloud extinction calculation
!
! Revision 2.61  2001/07/19 21:45:33  dwu
! some fixes for FillFromLOS
!
! Revision 2.60  2001/07/19 18:05:42  dwu
! add sourceSGRID
!
! Revision 2.59  2001/07/19 00:56:27  dwu
! fix bugs in FillFromLos
!
! Revision 2.58  2001/07/19 00:19:42  dwu
! add new method=rectanglefromlos
!
! Revision 2.57  2001/06/22 05:37:27  livesey
! First version of transfer command
!
! Revision 2.56  2001/06/13 20:41:35  vsnyder
! Make sure 'invert' has a value
!
! Revision 2.55  2001/05/30 23:56:39  livesey
! Changed for new L1BData
!
! Revision 2.54  2001/05/30 20:16:26  vsnyder
! Add 'invert' field to 'fillCovariance' spec
!
! Revision 2.53  2001/05/23 04:38:16  livesey
! Changes chunks to pointer rather than intent(in), so it gets the right indices
!
! Revision 2.52  2001/05/19 00:15:39  livesey
! OK, that should have been square!!! (fool!)
!
! Revision 2.51  2001/05/19 00:13:41  livesey
! Made fillcovariance apply square root option to update diagonal
!
! Revision 2.50  2001/05/18 22:39:45  livesey
! Bug fix.
!
! Revision 2.49  2001/05/18 19:50:50  livesey
! Added interpolate option for l2gp fills
!
! Revision 2.48  2001/05/16 19:44:16  livesey
! Added estimated noise stuff
!
! Revision 2.47  2001/05/10 23:25:12  livesey
! Added isotope scaling stuff, tidied up some old code.
!
! Revision 2.46  2001/05/08 20:34:26  vsnyder
! Cosmetic changes
!
! Revision 2.45  2001/05/03 20:30:29  vsnyder
! Add a 'nullify' and some cosmetic changes
!
! Revision 2.44  2001/04/28 01:43:21  vsnyder
! Improved the timing message
!
! Revision 2.43  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.42  2001/04/24 23:12:02  livesey
! Made spread more flexible
!
! Revision 2.41  2001/04/23 23:26:05  livesey
! Removed some unnecessary logic
!
! Revision 2.40  2001/04/20 17:12:24  livesey
! Add fill from l2gp
!
! Revision 2.39  2001/04/19 00:09:34  pwagner
! Longer error messages; halts if problem in fill
!
! Revision 2.38  2001/04/10 23:45:17  vsnyder
! Construct matrix properly
!
! Revision 2.37  2001/04/10 20:04:17  livesey
! Now does fill from Grid.
!
! Revision 2.36  2001/04/10 00:02:19  vsnyder
! Implement 'matrix' spec in Fill section
!
! Revision 2.35  2001/04/07 00:12:05  pwagner
! Calls trace_end if needed before every return
!
! Revision 2.34  2001/04/05 23:45:39  pwagner
! Deleted all MLSMessages
!
! Revision 2.33  2001/03/29 19:12:40  livesey
! Added gridded data fill
!
! Revision 2.32  2001/03/15 23:28:23  livesey
! Bug fix
!
! Revision 2.31  2001/03/15 21:18:57  vsnyder
! Use Get_Spec_ID instead of decoration(subtree...
!
! Revision 2.30  2001/03/15 21:12:11  livesey
! Added special fill for losVel, and dealt with new MLSSignals_m
!
! Revision 2.29  2001/03/15 18:40:38  livesey
! Added some more l1b fill options.
!
! Revision 2.28  2001/03/14 05:33:39  livesey
! Added snoop option
!
! Revision 2.27  2001/03/07 22:42:23  livesey
! Got pressure guesser to work
!
! Revision 2.26  2001/03/06 22:41:07  livesey
! New L2AUX stuff
!
! Revision 2.25  2001/03/06 00:34:46  livesey
! Regular commit.
!
! Revision 2.24  2001/03/05 01:20:14  livesey
! Regular commit, hydrostatic stuff in place.
!
! Revision 2.23  2001/03/03 05:54:29  livesey
! Started hydrostic stuff
!
! Revision 2.22  2001/03/03 00:10:14  livesey
! Removed debuging dump.
!
! Revision 2.21  2001/03/03 00:07:40  livesey
! Added fill from l1b
!
! Revision 2.20  2001/02/27 17:39:03  livesey
! Tidied stuff up a bit.
!
! Revision 2.19  2001/02/27 01:25:15  livesey
! Used new ValidateVectorQuantity routine
!
! Revision 2.18  2001/02/27 00:50:53  livesey
! Made sure verticalCoordinate=l_zeta worked for filling from L2GP
!
! Revision 2.17  2001/02/23 18:16:26  livesey
! Regular commit
!
! Revision 2.16  2001/02/21 01:07:34  livesey
! Got the explicit fill to work.
!
! Revision 2.15  2001/02/08 01:17:41  vsnyder
! Simplify access to abstract syntax tree.
!
! Revision 2.14  2001/01/26 00:11:12  pwagner
! Can fill from prev. defd. vector
!
! Revision 2.13  2001/01/24 23:31:00  pwagner
! Using announce_error, simplified
!
! Revision 2.12  2001/01/10 21:47:45  pwagner
! Chunk bounds determined by geodet.ang.
!
! Revision 2.11  2001/01/03 18:15:13  pwagner
! Changed types of t1, t2 to real
!
! Revision 2.10  2001/01/03 17:49:49  pwagner
! Accounts for chunking when filling from old L2GP
!
! Revision 2.9  2000/12/07 00:41:46  pwagner
! added whatquantitynumber
!
! Revision 2.8  2000/12/06 00:01:20  pwagner
! Completed FillL2AUXData; changed squeeze, nearby
!
! Revision 2.7  2000/12/05 00:40:50  pwagner
! Added FillL2AUXVector
!
! Revision 2.6  2000/11/30 00:22:52  pwagner
! functions properly moved to read a priori
!
! Revision 2.5  2000/11/16 02:15:25  vsnyder
! Implement timing.
!
! Revision 2.4  2000/11/13 23:02:21  pwagner
! Adapted for rank2 vectorsModule
!
! Revision 2.3  2000/10/06 22:18:47  pwagner
! Fills from old l2gp data
!
! Revision 2.2  2000/09/11 19:52:51  ahanzel
! Removed old log entries in file.
!
! Revision 2.1  2000/09/08 22:55:56  vsnyder
! Revised to use the tree output by the parser
!
!
@


2.487
log
@Improved ResidualCorrection Fill method
@
text
@d2394 1
a2394 1
          & 'Need sourceQuanitity and scale for quality fill' )
d2943 1
a2943 1
        ! override qty template fileds: time, phi, longitude, etc.
d3509 1
a3509 1
       "$Id: Fill.f90,v 2.486 2023/10/19 20:38:53 pwagner Exp $"
d3520 3
@


2.486
log
@Added residualCorrection Fill method
@
text
@d2008 3
d3000 1
a3000 1
        if ( .not. got ( f_radianceQuantity ) ) &
d3002 1
a3002 1
          & 'radianceQuantity not supplied' )
d3006 1
a3006 3
        radianceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(radianceVectorIndex), radianceQuantityIndex )
        call ResidualCorrection ( key, quantity, radianceQuantity, filename )
d3509 1
a3509 1
       "$Id: Fill.f90,v 2.485 2020/07/29 23:36:19 pwagner Exp $"
d3520 3
@


2.485
log
@May utilize BooleanFromEmptyGrid in Fill sections
@
text
@d85 1
a85 1
      & Explicit, Froml1b, &
d181 2
a182 1
      & L_Rhifromh2o, L_Rhiprecisionfromh2o, L_Rotatefield, L_Scaleoverlaps, &
d2996 11
d3508 1
a3508 1
       "$Id: Fill.f90,v 2.484 2020/07/22 23:00:17 pwagner Exp $"
d3519 3
@


2.484
log
@Many changes to allow GriddedData to be read and used during Fill sections
@
text
@d70 1
a70 1
      & BooleanFromComparingQtys, BooleanFromFormula, &
d194 1
a194 1
      & S_Flagcloud, S_Flushl2pcbins, S_Flushpfa, S_Gridded, S_Hessian, &
d814 3
d3496 1
a3496 1
       "$Id: Fill.f90,v 2.483 2020/07/09 23:55:06 pwagner Exp $"
d3507 3
@


2.483
log
@Many cmds from readApriori and MergeGrids phase now available to Fill phase
@
text
@d66 1
a66 1
    use Destroycommand_M, only: DestroyCommand
d68 4
a71 3
      & BooleanFromAnygoodValues, &
      & BooleanFromCatchwarning, BooleanFromComparingQtys, BooleanFromFormula, &
      & Dumpcommand, ExecuteCommand, Initializerepeat, Nextrepeat, &
d189 3
a191 2
      & S_Case, S_Catchwarning, S_Compare, S_Computetotalpower, &
      & S_Concatenate, S_ConcatenateGrids, S_ConvertEtaToP, &
d198 1
a198 1
      & S_Time, S_Transfer, S_UpdateMask, S_Vector
d218 2
a219 2
    use MergeGridsModule, only: Concatenate, ConvertEtaToP, &
      & MergeGrids, MergeOneGrid
d222 1
a222 1
      & RuntimeValues, L2Options, SpecialDumpFile, MLSL2Message
d228 6
a233 1
      & MLSpcf_L2apriori_Start, MLSpcf_L2apriori_End
d370 2
d620 18
d803 3
d811 6
d929 14
d3493 1
a3493 1
       "$Id: Fill.f90,v 2.482 2019/10/16 20:55:57 pwagner Exp $"
d3504 3
@


2.482
log
@Subset command may take a MissingValue field
@
text
@d108 3
a110 1
    use GriddedData, only: GriddedData_T
d126 1
a126 1
      & F_Fraction, F_Fromprecision, &
d188 3
a190 2
      & S_Case, S_Catchwarning, S_Compare, S_Computetotalpower, S_Destroy, &
      & S_Diff, S_Directread, S_Dump, S_Endselect, S_Execute, &
d192 3
a194 3
      & S_Flagcloud, S_Flushl2pcbins, S_Flushpfa, S_Hessian, &
      & S_Load, S_Matrix, S_Negativeprecision, S_Phase, S_Populatel2pcbin, &
      & S_Reevaluate, S_Repeat, S_Restrictrange, S_ChangeSettings, &
d216 2
d230 1
a230 1
      & StringElement, StringElementnum
d241 1
a241 1
    use ReadAPriori, only: APrioriFiles
d247 1
a247 1
    use Toggles, only: Gen, Levels, Toggle
d410 1
d439 6
d585 1
d597 2
d609 2
d785 36
d838 11
d3443 1
a3443 1
       "$Id: Fill.f90,v 2.481 2019/02/21 22:37:22 pwagner Exp $"
d3454 3
@


2.481
log
@Assure Dumps are sent to stdout
@
text
@d1998 2
a1999 1
          & maxValue, minValue, heightRange, whereRange, &
d2002 1
a2002 1
          & instancesNode=instancesNode, channelsNode=0 )
d2006 2
a2007 1
          & maxValue, minValue, heightRange, whereRange, &
d2010 1
a2010 1
          & instancesNode=instancesNode, channelsNode=channelsNode )
d3379 1
a3379 1
       "$Id: Fill.f90,v 2.480 2019/02/13 18:59:44 pwagner Exp $"
d3390 3
@


2.480
log
@Corrected mispelling, added debug Dumps
@
text
@d13 2
a14 2
module Fill                     ! Create vectors and fill them.
  !=============================================================================
d19 1
a19 1
  use Output_M, only: OutputOptions, StampOptions
d22 2
a23 1
  ! This takes a vector template, and creates and fills an appropriate vector
d30 2
a31 1
! MLSL2Fill          given a vector template, and creates and fills a vector
d35 7
a41 6
! MLSL2Fill (int root, *MLSFile_T fileDataBase(:), 
!        *griddedData_T GriddedDataBase(:),
!        *vectorTemplate_T VectorTemplates(:),
!        *vector_t Vectors(:), *quantityTemplate_T QtyTemplates(:),
!        *matrix_database_T Matrices(:),
!        *l2GPData_T L2GPDatabase(:), *l2AUXData_T L2AUXDatabase(:),
d43 1
a43 1
!        *mlSChunk_T Chunks(:), int ChunkNo )
d1087 1
d1091 1
d1097 1
d1099 1
d1103 1
d3377 1
a3377 1
       "$Id: Fill.f90,v 2.479 2018/09/13 20:24:17 pwagner Exp $"
d3388 3
@


2.479
log
@Moved changeable options to new L2Options; added DumpOptions
@
text
@d1092 5
a1096 3
        ! call Dump( OutputOptions )
        ! call Dump( StampOptions )
        ! call DumpConfig
d2872 1
a2872 1
            & 'Unable to finish phases timings (Is this still ariori?)' )
d2882 1
a2882 1
            & 'Unable to finish sections timings (Is this still ariori?)' )
d3369 1
a3369 1
       "$Id: Fill.f90,v 2.478 2018/07/27 23:18:48 pwagner Exp $"
d3380 3
@


2.478
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d212 1
a212 1
      & RuntimeValues, SkipRetrieval, SpecialDumpFile, MLSL2Message
d1002 1
a1002 1
        if ( SKIPRETRIEVAL ) then
d3367 1
a3367 1
       "$Id: Fill.f90,v 2.477 2018/05/12 00:10:24 pwagner Exp $"
d3378 3
@


2.477
log
@Print less if not deebugging
@
text
@d212 1
a212 1
      & RuntimeValues, SkipRetrieval, SpecialDumpFile, MLSMessage
d1003 1
a1003 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1197 1
a1197 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d1269 1
a1269 1
      call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem with Fill section' )
d2084 1
a2084 1
          & call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2142 1
a2142 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2148 1
a2148 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2388 1
a2388 1
          if ( l1bFlag == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2462 1
a2462 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2869 1
a2869 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2879 1
a2879 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d3367 1
a3367 1
       "$Id: Fill.f90,v 2.476 2018/04/16 22:14:48 pwagner Exp $"
d3378 3
@


2.476
log
@Improved how we DirectRead plain hdf files
@
text
@d3325 1
a3325 1
      call outputNamedValue( 'Result', fileTypeStr )
d3367 1
a3367 1
       "$Id: Fill.f90,v 2.475 2018/04/13 00:17:39 pwagner Exp $"
d3378 3
@


2.475
log
@Reduced non-debug printing
@
text
@d217 2
a218 1
    use MLSPcf2, only: MLSpcf_L2apriori_Start, MLSpcf_L2apriori_End
d489 2
d1434 9
a1442 1
      call get_file_name ( file, mlspcf_l2apriori_start, &
d1444 1
a1444 1
            & 'DirectRead File not found in PCF', mlspcf_l2apriori_end )
d3367 1
a3367 1
       "$Id: Fill.f90,v 2.474 2018/03/14 22:52:32 pwagner Exp $"
d3378 3
@


2.474
log
@Reduce output when changing settings
@
text
@d3308 1
a3308 1
      call outputNamedValue( 'About to get_string for file name', fileIndex )
d3311 2
a3312 2
      call outputNamedValue( 'Result', fileName )
      call outputNamedValue( 'About to get_string for file type', lit_indices(fileType) )
d3356 1
a3356 1
       "$Id: Fill.f90,v 2.473 2018/02/23 22:09:23 mmadatya Exp $"
d3367 3
@


2.473
log
@Added l_instECR for ASMLS
@
text
@d1089 3
a1091 3
        call Dump( OutputOptions )
        call Dump( StampOptions )
        call DumpConfig
d3356 1
a3356 1
       "$Id: Fill.f90,v 2.472 2017/12/15 18:33:19 mmadatya Exp $"
d3367 3
@


2.472
log
@Added heightFromPressure as new Fill method
@
text
@d526 1
d1867 2
d3356 1
a3356 1
       "$Id: Fill.f90,v 2.471 2017/12/07 01:01:23 vsnyder Exp $"
d3367 3
@


2.471
log
@Don't use host-associated variable as a DO index
@
text
@d76 1
a76 1
      & Colabundance, FoldedRadiance, Phitanwithrefraction, &
d173 1
a173 1
      & L_Rectanglefromlos, L_Refgph, L_Refract, &
d2920 24
a2943 1

d3353 1
a3353 1
       "$Id: Fill.f90,v 2.470 2017/11/15 00:38:35 pwagner Exp $"
d3364 3
@


2.470
log
@Must Dump options for output if debugging a phase or changing settings
@
text
@a413 1
    integer :: IBO
d1282 1
d1486 2
a1487 1
      integer :: I
d3330 1
a3330 1
       "$Id: Fill.f90,v 2.469 2017/07/27 16:57:37 pwagner Exp $"
d3341 3
@


2.469
log
@Geolocations now add day, month, etc.; DirectRead may look under groupName
@
text
@d18 3
d109 1
a109 1
    use HighOutput, only: OutputNamedValue
d228 1
a228 2
    use PCFHdr, only: GlobalAttributes, &
      & GranuleDay, GranuleDayOfYear, GranuleMonth, GranuleYear
d366 1
d1078 1
d1080 6
a1085 1

d1089 3
d3329 1
a3329 1
       "$Id: Fill.f90,v 2.468 2017/07/10 18:50:47 pwagner Exp $"
d3340 3
@


2.468
log
@Transfer may /expandMask to all masking bits; may /skipValues to transfer only mask; Fill may replaceMissingValue=
@
text
@d44 1
d106 1
a106 1
    use HighOutput, only: OutputnamedValue
d110 1
a110 1
      & F_B, F_Badrange, F_Baselinequantity, F_Bin, F_Block, &
d119 1
a119 1
      & F_Geocaltitudequantity, F_Geolocation, F_Gphquantity, &
d209 1
a209 1
      & SkipRetrieval, SpecialDumpFile, MLSMessage
d225 2
d1307 1
d1316 1
d1330 1
d1344 6
d1377 4
d1453 1
a1453 1
          & filetypestr, options, spread, interpolate )
d2317 4
d2332 2
d2344 2
d3317 1
a3317 1
       "$Id: Fill.f90,v 2.467 2017/04/07 18:46:17 pwagner Exp $"
d3328 3
@


2.467
log
@sourceType used when choosing how to Fill ascenddescend
@
text
@d115 1
a115 1
      & F_ExplicitValues, F_Expr, F_Extinction, &
d133 6
a138 5
      & F_Radiancequantity, F_Ratioquantity, F_Refract, &
      & F_Refgphquantity, F_Refgphprecisionquantity, F_ReferenceMIF, F_Regular, &
      & F_Reset, F_Resetseed, F_Rhiprecisionquantity, F_Rhiquantity, F_Rank, &
      & F_Rows, F_Scale, F_Scaleinsts, F_Scaleratio, F_Scalesurfs, F_Sceci, &
      & F_Scvel, F_Scveleci, F_Scvelecr, F_Sdname, F_Seed, F_SkipMask, &
d371 1
d506 1
d525 1
d647 1
d985 1
a985 1
            invert = get_boolean ( subtree(j,key) )
d1084 1
d1087 1
d1117 2
d1124 1
a1124 1
            interpolate = get_boolean ( fieldValue )
d1146 3
a1148 1
            skipMask = get_boolean ( fieldValue )
d1176 2
a1177 2
            & vectors(destinationVectorIndex), skipMask, interpolate, &
            & booleanName )
d1800 3
d1946 1
a1946 1
          & .false., .false., additional=.true., reset=.false., &
d1953 1
a1953 1
          & .false., .false., additional=.true., reset=.false., &
d2402 2
a2403 3
        call FromGrid &
          & ( quantity, griddedDataBase(gridIndex), allowMissing, errorCode )
        ! call outputNamedValue( 'error code', errorCode )
d3293 1
a3293 1
       "$Id: Fill.f90,v 2.466 2017/04/06 23:43:10 pwagner Exp $"
d3304 3
@


2.466
log
@May choose to base on asc/desc mode on GHz/GeodAngle via manipulation field
@
text
@d139 2
a140 2
      & F_Sourcequantity, F_Sourcevgrid, F_Spread, F_Start, F_Status, F_Stride, &
      & F_Suffix, F_Surface, &
d525 1
d651 1
d1834 2
d2026 1
a2026 1
        if ( .not. got(f_manipulation) ) &
d2030 1
a2030 1
          & hgrids, ptanQuantity, manipulation )
d3280 1
a3280 1
       "$Id: Fill.f90,v 2.465 2017/03/23 16:44:40 pwagner Exp $"
d3291 3
@


2.465
log
@Improved message printed when unable to time sections
@
text
@d577 1
d585 4
d601 1
d632 1
d2022 3
d2026 1
a2026 1
          & hgrids, ptanQuantity )
d3276 1
a3276 1
       "$Id: Fill.f90,v 2.464 2017/02/08 17:55:28 pwagner Exp $"
d3287 3
@


2.464
log
@/sourceMask causes vector Fills to obey mask from source, not destination
@
text
@d57 185
a241 185
 use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
 use Chunks_M, only: MLSChunk_T
 use Destroycommand_M, only: DestroyCommand
 use DumpCommand_M, only: BooleanFromAnyGoodRadiances, &
   & BooleanFromAnygoodValues, &
   & BooleanFromCatchwarning, BooleanFromComparingQtys, BooleanFromFormula, &
   & Dumpcommand, ExecuteCommand, Initializerepeat, Nextrepeat, &
   & MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, &
   & Repeat=>skip, Skip
 use Expr_M, only: Expr
 use FillUtils_1, only: Addgaussiannoise, Applybaseline, AutoFillVector, &
   & Computetotalpower, Derivativeofsource, Fillcovariance, &
   & Extractsinglechannel, Fillerror, Fromanother, Fromgrid, &
   & FromL2GP, Fromprofile, Gather, GeoidData, Losvelocity, &
   & Chisqchan, Chisqmmaf, Chisqmmif, Chisqratio, &
   & Colabundance, FoldedRadiance, Phitanwithrefraction, &
   & Iwcfromextinction, Rhifromortoh2o, Noradspermif, &
   & Rhiprecisionfromortoh2o, Withestnoise, &
   & Hydrostatically_Gph, Hydrostatically_Ptan, Fromsplitsideband, &
   & Gphprecision, Fromisotope, Fromasciifile, Rotatemagneticfield, &
   & Explicit, Froml1b, &
   & Froml2aux, Usingmagneticmodel, &
   & Frominterpolatedqty, Fromlosgrid, NearestProfiles, &
   & Bymanipulation, ManipulateVectors, Withreflectortemperature, &
   & Withascordesc, Withreichlerwmotp, &
   & Withwmotropopause, Withbinresults, Withboxcarfunction, &
   & StatusQuantity, Qualityfromchisq, Convergencefromchisq, &
   & Usingleastsquares, OffsetRadianceQuantity, ResetunusedRadiances, &
   & Scaleoverlaps, Scatter, SpreadchannelFill, TransferVectors, &
   & TransferVectorsbymethod, UncompressRadiance, &
   & Qtyfromfile, Vectorfromfile, Announce_Error, &
 ! Codes For Announce_Error:
   & BadestnoiseFill, BadgeocaltitudeQuantity, BadisotopeFill, &
   & BadlosgridFill, BadlosvelFill, BadrefgphQuantity, BadgphQuantity, &
   & BadrefractFill, BadscvelecrQuantity, BadtemperatureQuantity, &
   & Bothfractionandlength, Missingfield, &
   & Needgeocaltitude, Needh2o, Needorbitinclination, Needtemprefgph, &
   & NegativePhiWindow, Nocodefor, No_Error_Code, NoexplicitValuesgiven, &
   & Nosourcegridgiven, Nosourcel2auxgiven, NosourceL2GPgiven, &
   & Notimplemented, Notplain, Notspd, &
   & Wrongunits
 use ForwardModelConfig, only: Forwardmodelconfig_T
 use ForwardModelSupport, only: Fillfwdmodeltimings
 use Global_Settings, only: Brightobjects
 use GriddedData, only: GriddedData_T
 use Hessianmodule_1, only: AddhessiantoDatabase, Createemptyhessian, &
   & Streamlinehessian, Hessian_T
 use HGridsDatabase, only: HGrids_T
 use HighOutput, only: OutputnamedValue
 ! We Need Many Things From Init_Tables_Module. First The Fields:
 use Init_Tables_Module, only: F_A, F_Additional, F_Allowmissing, &
   & F_Aprioriprecision, F_Aspercentage, F_Autofill, F_Avoidbrightobjects, &
   & F_B, F_Badrange, F_Baselinequantity, F_Bin, F_Block, &
   & F_Boundarypressure, F_Boxcarmethod, &
   & F_C, F_Centervertically, F_Channel, F_Channels, F_Columns, F_Count, &
   & F_Destination, F_Diagonal, F_Dimlist, &
   & F_Dontlatch, F_DontMask, &
   & F_Ecrtofov, F_Earthradius, F_Exact, F_Excludebelowbottom, &
   & F_ExplicitValues, F_Expr, F_Extinction, &
   & F_Fieldecr, F_File, F_Flags, F_Force, F_Shape, &
   & F_Fraction, F_Fromprecision, &
   & F_Geocaltitudequantity, F_Geolocation, F_Gphquantity, &
   & F_Height, F_Heightrange, F_Hessian, &
   & F_Highbound, F_H2oquantity, F_H2oprecisionquantity, F_HGrid, &
   & F_Ifmissinggmao, &
   & F_Ignorenegative, F_Ignoregeolocation, F_IgnoreTemplate, F_Ignorezero, &
   & F_Instances, F_Integrationtime, F_Internalvgrid, &
   & F_Interpolate, F_Invert, F_Intrinsic, F_Isprecision, &
   & F_Lengthscale, F_Logspace, F_Losqty, F_Lowbound, F_Lsb, F_Lsbfraction, &
   & F_Manipulation, F_Matrix, F_Maxiterations, F_MaxValue, F_Measurements, &
   & F_Method, F_Minnormqty, F_MinValue, F_Model, F_Multiplier, &
   & F_Nofinegrid, F_Noise, F_Noisebandwidth, F_NoPCFid, F_Normqty, &
   & F_NoZeros, F_Offsetamount, F_Options, F_Orbitinclination, F_Phitan, &
   & F_Phiwindow, F_Phizero, F_Precision, F_Precisionfactor, &
   & F_Profile, F_ProfileValues, F_Ptanquantity, &
   & F_Quadrature, F_Quantity, F_Quantitynames, &
   & F_Radiancequantity, F_Ratioquantity, F_Refract, &
   & F_Refgphquantity, F_Refgphprecisionquantity, F_ReferenceMIF, F_Regular, &
   & F_Reset, F_Resetseed, F_Rhiprecisionquantity, F_Rhiquantity, F_Rank, &
   & F_Rows, F_Scale, F_Scaleinsts, F_Scaleratio, F_Scalesurfs, F_Sceci, &
   & F_Scvel, F_Scveleci, F_Scvelecr, F_Sdname, F_Seed, F_SkipMask, &
   & F_Source, F_Sourcegrid, F_Sourcel2aux, F_Sourcel2gp, F_SourceMask, &
   & F_Sourcequantity, F_Sourcevgrid, F_Spread, F_Start, F_Status, F_Stride, &
   & F_Suffix, F_Surface, &
   & F_Systemtemperature, F_Temperaturequantity, F_Tempprecisionquantity, &
   & F_Template, F_Tngteci, F_Terms, F_Totalpowerquantity, &
   & F_Type, F_Unit, F_Usb, F_Usbfraction, F_Vector, F_Vmrquantity, &
   & F_Wherefill, F_Wherenotfill, F_Width, &
   & Field_First, Field_Last
 ! Now The Literals:
 use Init_Tables_Module, only: L_Addnoise, L_Applybaseline, L_Ascenddescend, &
   & L_Asciifile, L_Binmax, L_Binmean, L_Binmin, L_Bintotal, &
   & L_Boundarypressure, L_Boxcar, L_Chisqchan, &
   & L_Chisqmmaf, L_Chisqmmif, L_Chisqratio, L_Cholesky, &
   & L_Cloudice, L_Cloudextinction, &
   & L_Combinechannels, L_Columnabundance, L_Convergenceratio, &
   & L_Derivative, L_Dobsonunits, L_Du, &
   & L_Estimatednoise, L_Explicit, L_Extractchannel, L_Fold, &
   & L_Fwdmodeltiming, L_Fwdmodelmean, L_Fwdmodelstddev, &
   & L_Gather, L_Geocaltitude, L_Geodaltitude, L_Geolocation, &
   & L_GeoidData, L_Gph, L_Gphprecision, L_Gphresettogeoid, L_Gridded, &
   & L_H2ofromrhi, L_H2oprecisionfromrhi, L_Hdf, L_Hydrostatic, &
   & L_Isotope, L_Iwcfromextinction, L_Kronecker, &
   & L_L1b, L_L2gp, L_L2aux, &
   & L_Losvel, L_Lsglobal, L_Lslocal, L_Lsweighted, &
   & L_Magazel, L_Magneticmodel, &
   & L_Manipulate, L_Mean, L_ModifyTemplate, L_Molcm2, &
   & L_Negativeprecision, L_None, &
   & L_Noradspermif, L_Offsetradiance, &
   & L_Phasetiming, L_Phitan, &
   & L_Plain, L_Profile, L_Ptan, L_Quality, &
   & L_Rectanglefromlos, L_Refgph, L_Refract, &
   & L_Reflectortempmodel, L_Resetunusedradiances, L_Rhi, &
   & L_Rhifromh2o, L_Rhiprecisionfromh2o, L_Rotatefield, L_Scaleoverlaps, &
   & L_Sectiontiming, L_Scatter, L_Scvelecr, L_Spd, L_Spreadchannel, &
   & L_Splitsideband, L_Status, L_SwapValues, &
   & L_Temperature, L_Tngtgeodalt, &
   & L_Tngtgeocalt, L_Uncompressradiance, L_Vector, L_Vgrid, L_Vmr, L_Wmotropopause, &
   & L_Zeta
 ! Now The Specifications:
 use Init_Tables_Module, only: S_AnygoodValues, S_Anygoodradiances, &
   & S_Case, S_Catchwarning, S_Compare, S_Computetotalpower, S_Destroy, &
   & S_Diff, S_Directread, S_Dump, S_Endselect, S_Execute, &
   & S_Fill, S_Fillcovariance, S_Filldiagonal, &
   & S_Flagcloud, S_Flushl2pcbins, S_Flushpfa, S_Hessian, &
   & S_Load, S_Matrix, S_Negativeprecision, S_Phase, S_Populatel2pcbin, &
   & S_Reevaluate, S_Repeat, S_Restrictrange, &
   & S_Select, S_ChangeSettings, S_Skip, S_Snoop, S_Streamlinehessian, S_Subset, &
   & S_Time, S_Transfer, S_UpdateMask, S_Vector
 ! Now Some Arrays
 use Intrinsic, only: Lit_Indices, &
   & Phyq_Angle, Phyq_Dimensionless, Phyq_Invalid, Phyq_Length, &
   & Phyq_Profiles
 use, Intrinsic :: Iso_C_Binding, only: C_Intptr_T, C_Loc
 use L1BData, only: DeallocateL1BData, L1BData_T, ReadL1BData
 use L2GPData, only: L2GPData_T, Col_Species_Hash, Col_Species_Keys
 use L2AUXData, only: L2AUXData_T
 use L2PC_M, only: Populatel2pcbinbyname, Loadhessian, Loadmatrix, LoadVector
 use L2PCBins_M, only: Flushlockedbins
 use ManipulateVectorQuantities, only: DoHGridsMatch, &
   & FillWithCombinedChannels
 use MatrixModule_1, only: AddToMatrixDatabase, CreateEmptyMatrix, &
   & GetActualMatrixFromDatabase, GetDiagonal, &
   & GetkindfrommatrixDatabase, GetfrommatrixDatabase, K_Plain, K_Spd, &
   & Matrix_Cholesky_T, Matrix_Database_T, Matrix_Kronecker_T, Matrix_Spd_T, &
   & Matrix_T, Nullifymatrix
 ! Note: If You Ever Want To Include Defined Assignment For Matrices, Please
 ! Carefully Check Out The Code Around The Call To Snoop.
 use MLSFiles, only: HDFVersion_5, GetMLSFileByType
 use MLSL2Options, only: L2cfnode, &
   & SkipRetrieval, SpecialDumpFile, MLSMessage
 use MLSL2Timings, only: Section_Times, Total_Times, &
   & AddPhaseToPhaseNames, FillTimings, FinishTimings
 use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, &
   & MLSMsg_L1bread, MLSMessageReset
 use MLSPcf2, only: MLSpcf_L2apriori_Start, MLSpcf_L2apriori_End
 use MLSRandomNumber, only: MLS_Random_Seed, Math77_Ran_Pack
 use MLSStringlists, only: Catlists, GethashElement, &
   & NumstringElements, PuthashElement, &
   & StringElement, StringElementnum
 use MLSStrings, only: Lowercase
 use Molecules, only: L_H2o
 use Moretree, only: Get_Boolean, Get_Field_Id, Get_Label_And_Spec, &
   & Get_Spec_Id
 use Next_Tree_Node_M, only: Next_Tree_Node, Next_Tree_Node_State
 use Output_M, only: Blanks, Output, RevertOutput, SwitchOutput
 use PFAData_M, only: Flush_PFAData
 use QuantityTemplates, only: QuantityTemplate_T, &
   & ModifyQuantityTemplate
 use ReadAPriori, only: APrioriFiles
 use SnoopMLSL2, only: Snoop
 use String_Table, only: Get_String
 use Subsetmodule, only: ApplyMasktoquantity, Restrictrange, &
   & Setupflagcloud, Setupsubset, UpdateMask
 use Time_M, only: SayTime, Time_Now
 use Toggles, only: Gen, Levels, Toggle
 use Trace_M, only: Trace_Begin, Trace_End
 use Tree, only: Decorate, Decoration, Nsons, Sub_Rosa, Subtree, Where
 use VectorsModule, only: AddVectortoDatabase, &
   & ClearMask, CloneVectorQuantity, CreateVector, &
   & DumpQuantityMask, &
   & GetVectorQtybyTemplateindex, &
   & ValidateVectorQuantity, Vector_T, &
   & VectorTemplate_T, VectorValue_T, M_Fill
 use VGridsDatabase, only: VGrids
d536 1
a536 1
    real :: T1, T2                      ! for timing
d2782 2
a2783 1
          & call Announce_error ( key, no_Error_Code, 'radianceQuantity not supplied' )
d2792 1
a2792 1
            & 'Unable to finish phases timings' )
d2801 2
a2802 1
          call MLSMessage ( MLSMSG_Warning, ModuleName, 'Unable to finish sections timings' )
d3266 1
a3266 1
       "$Id: Fill.f90,v 2.463 2016/11/08 17:32:57 pwagner Exp $"
d3277 3
@


2.463
log
@Use SayTime subroutine from time_m module; process /reset field
@
text
@d16 2
a17 2
  use MLSCommon, only: MLSFile_T, defaultUndefinedValue
  use MLSKinds, only: r8, rv
d57 185
a241 185
    use allocate_deallocate, only: test_allocate, test_deallocate
    use chunks_m, only: MLSChunk_t
    use destroycommand_m, only: destroyCommand
    use dumpCommand_m, only: booleanFromAnyGoodRadiances, &
      & booleanFromAnygoodvalues, &
      & booleanFromCatchwarning, booleanFromComparingQtys, booleanFromFormula, &
      & dumpcommand, ExecuteCommand, initializerepeat, nextrepeat, &
      & MLSCase, MLSEndSelect, MLSSelect, MLSSelecting, &
      & repeat=>skip, skip
    use expr_m, only: expr
    use FillUtils_1, only: addgaussiannoise, applybaseline, autoFillVector, &
      & computetotalpower, derivativeofsource, Fillcovariance, &
      & extractsinglechannel, Fillerror, fromanother, fromgrid, &
      & fromL2GP, fromprofile, gather, geoiddata, losvelocity, &
      & chisqchan, chisqmmaf, chisqmmif, chisqratio, &
      & colabundance, foldedRadiance, phitanwithrefraction, &
      & iwcfromextinction, rhifromortoh2o, noradspermif, &
      & rhiprecisionfromortoh2o, withestnoise, &
      & hydrostatically_gph, hydrostatically_ptan, fromsplitsideband, &
      & gphprecision, fromisotope, fromasciifile, rotatemagneticfield, &
      & explicit, froml1b, &
      & froml2aux, usingmagneticmodel, &
      & frominterpolatedqty, fromlosgrid, NearestProfiles, &
      & bymanipulation, manipulateVectors, withreflectortemperature, &
      & withascordesc, withreichlerwmotp, &
      & withwmotropopause, withbinresults, withboxcarfunction, &
      & statusQuantity, qualityfromchisq, convergencefromchisq, &
      & usingleastsquares, offsetRadianceQuantity, resetunusedRadiances, &
      & scaleoverlaps, scatter, spreadchannelFill, transferVectors, &
      & transferVectorsbymethod, uncompressRadiance, &
      & qtyfromfile, Vectorfromfile, announce_error, &
      ! codes for announce_error:
      & badestnoiseFill, badgeocaltitudeQuantity, badisotopeFill, &
      & badlosgridFill, badlosvelFill, badrefgphQuantity, badgphQuantity, &
      & badrefractFill, badscvelecrQuantity, badtemperatureQuantity, &
      & bothfractionandlength, missingfield, &
      & needgeocaltitude, needh2o, needorbitinclination, needtemprefgph, &
      & negativePhiWindow, nocodefor, no_error_code, noexplicitvaluesgiven, &
      & nosourcegridgiven, nosourcel2auxgiven, nosourceL2GPgiven, &
      & notimplemented, notplain, notspd, &
      & wrongunits
    use forwardModelConfig, only: forwardmodelconfig_t
    use forwardModelSupport, only: fillfwdmodeltimings
    use global_settings, only: brightobjects
    use griddeddata, only: griddeddata_t
    use hessianmodule_1, only: addhessiantodatabase, createemptyhessian, &
      & streamlinehessian, hessian_t
    use HGridsDatabase, only: HGrids_t
    use highoutput, only: outputnamedvalue
    ! we need many things from init_tables_module.  first the fields:
    use init_tables_module, only: f_a, f_additional, f_allowmissing, &
      & f_aprioriprecision, f_aspercentage, f_autofill, f_avoidbrightobjects, &
      & f_b, f_badrange, f_baselinequantity, f_bin, f_block, &
      & f_boundarypressure, f_boxcarmethod, &
      & f_c, f_centervertically, f_channel, f_channels, f_columns, f_count, &
      & f_destination, f_diagonal, f_dimlist, &
      & f_dontlatch, f_dontmask, &
      & f_ecrtofov, f_earthradius, f_exact, f_excludebelowbottom, &
      & f_explicitvalues, f_expr, f_extinction, &
      & f_fieldecr, f_file, f_flags, f_force, f_shape, &
      & f_fraction, f_fromprecision, &
      & f_geocaltitudequantity, f_geolocation, f_gphquantity, &
      & f_height, f_heightrange, f_hessian, &
      & f_highbound, f_h2oquantity, f_h2oprecisionquantity, f_hGrid, &
      & f_ifmissinggmao, &
      & f_ignorenegative, f_ignoregeolocation, f_ignoretemplate, f_ignorezero, &
      & f_instances, f_integrationtime, f_internalvgrid, &
      & f_interpolate, f_invert, f_intrinsic, f_isprecision, &
      & f_lengthscale, f_logspace, f_losqty, f_lowbound, f_lsb, f_lsbfraction, &
      & f_manipulation, f_matrix, f_maxiterations, f_maxvalue, f_measurements, &
      & f_method, f_minnormqty, f_minvalue, f_model, f_multiplier, &
      & f_nofinegrid, f_noise, f_noisebandwidth, f_noPCFid, f_normqty, &
      & f_noZeros, f_offsetamount, f_options, f_orbitinclination, f_phitan, &
      & f_phiwindow, f_phizero, f_precision, f_precisionfactor, &
      & f_profile, f_profilevalues, f_ptanquantity, &
      & f_quadrature, f_quantity, f_quantitynames, &
      & f_radiancequantity, f_ratioquantity, f_refract, &
      & f_refgphquantity, f_refgphprecisionquantity, f_referenceMIF, f_regular, &
      & f_reset, f_resetseed, f_rhiprecisionquantity, f_rhiquantity, f_rank, &
      & f_rows, f_scale, f_scaleinsts, f_scaleratio, f_scalesurfs, f_sceci, &
      & f_scvel, f_scveleci, f_scvelecr, f_sdname, f_seed, f_skipmask, &
      & f_source, f_sourcegrid, f_sourcel2aux, f_sourcel2gp, &
      & f_sourcequantity, f_sourcevgrid, f_spread, f_start, f_status, f_stride, &
      & f_suffix, f_surface, &
      & f_systemtemperature, f_temperaturequantity, f_tempprecisionquantity, &
      & f_template, f_tngteci, f_terms, f_totalpowerquantity, &
      & f_type, f_unit, f_usb, f_usbfraction, f_vector, f_vmrquantity, &
      & f_wherefill, f_wherenotfill, f_width, &
      & field_first, field_last
    ! now the literals:
    use init_tables_module, only: l_addnoise, l_applybaseline, l_ascenddescend, &
      & l_asciifile, l_binmax, l_binmean, l_binmin, l_bintotal, &
      & l_boundarypressure, l_boxcar, l_chisqchan, &
      & l_chisqmmaf, l_chisqmmif, l_chisqratio, l_cholesky, &
      & l_cloudice, l_cloudextinction, &
      & l_combinechannels, l_columnabundance, l_convergenceratio, &
      & l_derivative, l_dobsonunits, l_du, &
      & l_estimatednoise, l_explicit, l_extractchannel, l_fold, &
      & l_fwdmodeltiming, l_fwdmodelmean, l_fwdmodelstddev, &
      & l_gather, l_geocaltitude, l_geodaltitude, l_geolocation, &
      & l_geoiddata, l_gph, l_gphprecision, l_gphresettogeoid, l_gridded, &
      & l_h2ofromrhi, l_h2oprecisionfromrhi, l_hdf, l_hydrostatic, &
      & l_isotope, l_iwcfromextinction, l_kronecker, &
      & l_l1b, l_l2gp, l_l2aux, &
      & l_losvel, l_lsglobal, l_lslocal, l_lsweighted, &
      & l_magazel, l_magneticmodel, &
      & l_manipulate, l_mean, l_modifytemplate, l_molcm2, &
      & l_negativeprecision, l_none, &
      & l_noradspermif, l_offsetradiance, &
      & l_phasetiming, l_phitan, &
      & l_plain, l_profile, l_ptan,  l_quality, &
      & l_rectanglefromlos, l_refgph, l_refract, &
      & l_reflectortempmodel, l_resetunusedradiances, l_rhi, &
      & l_rhifromh2o, l_rhiprecisionfromh2o, l_rotatefield, l_scaleoverlaps, &
      & l_sectiontiming, l_scatter, l_scvelecr, l_spd, l_spreadchannel, &
      & l_splitsideband, l_status, l_swapvalues, &
      & l_temperature, l_tngtgeodalt, &
      & l_tngtgeocalt, l_uncompressradiance, l_vector, l_vgrid, l_vmr, l_wmotropopause, &
      & l_zeta
    ! now the specifications:
    use init_tables_module, only: s_anygoodvalues, s_anygoodradiances, &
      & s_case, s_catchwarning, s_compare, s_computetotalpower, s_destroy, &
      & s_diff, s_directread, s_dump, s_endselect, s_execute, &
      & s_fill, s_fillcovariance, s_filldiagonal, &
      & s_flagcloud, s_flushl2pcbins, s_flushpfa, s_hessian, &
      & s_load, s_matrix,  s_negativeprecision, s_phase, s_populatel2pcbin, &
      & s_reevaluate, s_repeat, s_restrictrange, &
      & s_select, s_changeSettings, s_skip, s_snoop, s_streamlinehessian, s_subset, &
      & s_time, s_transfer, s_updatemask, s_vector
    ! now some arrays
    use intrinsic, only: lit_indices, &
      & phyq_angle, phyq_dimensionless, phyq_invalid, phyq_length, &
      & phyq_profiles
    use, intrinsic :: iso_c_binding, only: c_intptr_t, c_loc
    use L1BData, only: deallocateL1BData, L1BData_t, readL1BData
    use L2GPData, only: L2GPData_t, col_species_hash, col_species_keys
    use L2AUXdata, only: L2AUXData_t
    use L2PC_m, only: populatel2pcbinbyname, loadhessian, loadmatrix, loadvector
    use L2PCBins_m, only: flushlockedbins
    use manipulateVectorQuantities, only: doHGridsMatch, &
      & fillWithCombinedChannels
    use matrixModule_1, only: addToMatrixDatabase, createEmptyMatrix, &
      & getActualMatrixFromDatabase, getDiagonal, &
      & getkindfrommatrixdatabase, getfrommatrixdatabase, k_plain, k_spd, &
      & matrix_cholesky_t, matrix_database_t, matrix_kronecker_t, matrix_spd_t, &
      & matrix_t, nullifymatrix
    ! note: if you ever want to include defined assignment for matrices, please
    ! carefully check out the code around the call to snoop.
    use MLSFiles, only: HDFVersion_5, getMlsFileByType
    use MLSL2Options, only: l2cfnode, &
      & skipRetrieval, specialDumpFile, MLSMessage
    use MLSL2Timings, only: section_times, total_times, &
      & addPhaseToPhaseNames, fillTimings, finishTimings
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, &
      & MLSMsg_l1bread, MLSMessageReset
    use MLSPcf2, only: mlspcf_l2apriori_start, mlspcf_l2apriori_end
    use MLSRandomnumber, only: mls_random_seed, math77_ran_pack
    use MLSStringlists, only: catlists, gethashelement, &
      & numstringelements, puthashelement, &
      & stringelement, stringelementnum
    use MLSStrings, only: lowercase
    use molecules, only: l_h2o
    use moretree, only: get_boolean, get_field_id, get_label_and_spec, &
      & get_spec_id
    use next_tree_node_m, only: next_tree_node, next_tree_node_state
    use output_m, only: blanks, output, revertoutput, switchoutput
    use PFAData_m, only: flush_PFAData
    use quantityTemplates, only: quantityTemplate_t, &
      & modifyQuantityTemplate
    use readAPriori, only: APrioriFiles
    use snoopMLSL2, only: snoop
    use string_table, only: get_string
    use subsetmodule, only: applymasktoquantity, restrictrange, &
      & setupflagcloud, setupsubset, updatemask
    use time_m, only: SayTime, time_now
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: decorate, decoration, nsons, sub_rosa, subtree, where
    use VectorsModule, only: addVectortodatabase, &
      & clearmask, cloneVectorQuantity, createVector, &
      & dumpQuantitymask, &
      & getVectorQtybytemplateindex, &
      & validateVectorQuantity, Vector_t, &
      & Vectortemplate_t, Vectorvalue_t, m_fill
    use VGridsDatabase, only: VGrids
d524 1
d642 1
d1245 2
a1246 2
      use init_tables_module, only: f_geodangle, f_hessian, &
        & f_scaleheight, f_surface, f_threshold
d1282 1
a1282 1
      use L2PC_M, only: readCompleteHDF5L2PCFile
d1425 6
a1430 6
!     use DUMP_0, only: DUMP
      use Init_tables_module, only: L_Geodetic, L_None
      use Intrinsic, only: lit_indices, t_boolean, t_numeric
      use String_table, only: display_string
      use Vector_qty_expr_m, only: dot, vector_qty_expr
      use Vectorsmodule, only: destroyvectorquantitymask, destroyvectorquantityvalue, &
d1818 2
d2075 1
a2075 1
            & interpolate=.false., force=.false. )
d3092 1
a3092 1
          & key, ignoreTemplate, spreadflag, interpolate, force )
d3189 3
a3191 3
      use fillUtils_1, only: announce_error
      use hdf, only: dfacc_rdonly
      use intrinsic, only: l_ascii, l_hdf
d3194 4
a3197 4
        & AddInitializeMLSFile, GetPCFromRef, split_path_name
      use MLSL2Options, only: toolkit
      use SDPToolkit, only: pgs_pc_getreference
      use string_table, only: get_string
d3264 1
a3264 1
       "$Id: Fill.f90,v 2.462 2016/09/02 00:49:40 vsnyder Exp $"
d3275 3
@


2.462
log
@Change default geolocation from L_None to L_Geodetic.  The result is that
the geodLat and Lon fields of HGrids are always filled.
@
text
@d133 3
a135 3
      & f_radiancequantity, f_ratioquantity, &
      & f_refract, f_refgphquantity, f_refgphprecisionquantity, f_referenceMIF, &
      & f_regular, f_resetseed, f_rhiprecisionquantity, f_rhiquantity, f_rank, &
d231 1
a231 1
    use time_m, only: time_now
d374 1
d504 1
d634 1
d661 11
d1163 2
a1164 2
        if ( timing ) then
          call sayTime
d1235 1
a1235 1
    if ( timing ) call sayTime
a3254 13
    ! --------------------------------------------------  SayTime  -----
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for MLSL2Fill = " )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime

d3260 1
a3260 1
       "$Id: Fill.f90,v 2.461 2016/06/14 22:52:46 vsnyder Exp $"
d3271 4
@


2.461
log
@The default for ReferenceMIFUnits is PHYQ_Dimensionless, but just to make
sure, set it to PHYQ_Dimensionless every place that ReferenceMIF is an
index instead of an altitude.
@
text
@d1410 1
a1410 1
      use Init_tables_module, only: L_None
d1441 1
a1441 1
      geolocation = l_none
d3259 1
a3259 1
       "$Id: Fill.f90,v 2.460 2016/05/18 01:37:30 vsnyder Exp $"
d3270 5
@


2.460
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@d2700 4
a2703 2
          if ( .not. got(f_referenceMIF) ) &
            & referenceMIF = scVelQuantity%template%noSurfs / 2
d3259 1
a3259 1
       "$Id: Fill.f90,v 2.459 2016/04/01 00:27:15 pwagner Exp $"
d3270 4
@


2.459
log
@May now Execute a single command or a script of lines from l2cf
@
text
@d104 1
a104 1
    use hgridsdatabase, only: hgrid_t
d257 1
a257 1
    type (HGrid_T), dimension(:), pointer ::     HGrids
d2281 1
a2281 1
            & quantity, HGrids(hgridIndex), &
d2300 1
a2300 1
              maf = Hgrids(quantity%template%hGridIndex)%maf(i)
d3257 1
a3257 1
       "$Id: Fill.f90,v 2.458 2015/12/01 21:19:57 pwagner Exp $"
d3268 3
@


2.458
log
@May Fill with nearest profile number
@
text
@d50 3
a52 3
  subroutine MLSL2FILL ( ROOT, FILEDATABASE, GRIDDEDDATABASE, VECTORTEMPLATES, &
    & VECTORS, QTYTEMPLATES, MATRICES, HESSIANS, L2GPDATABASE, L2AUXDATABASE, &
    & FWMODELCONFIG, CHUNKS, CHUNKNO, HGRIDS )
d63 2
a64 2
      & dumpcommand, initializerepeat, nextrepeat, &
      & mlscase, mlsendselect, mlsselect, mlsselecting, &
d67 4
a70 4
    use fillUtils_1, only: addgaussiannoise, applybaseline, autofillvector, &
      & computetotalpower, derivativeofsource, fillcovariance, &
      & extractsinglechannel, fillerror, fromanother, fromgrid, &
      & froml2gp, fromprofile, gather, geoiddata, losvelocity, &
d72 1
a72 1
      & colabundance, foldedradiance, phitanwithrefraction, &
d80 1
a80 1
      & bymanipulation, manipulatevectors, withreflectortemperature, &
d83 5
a87 5
      & statusquantity, qualityfromchisq, convergencefromchisq, &
      & usingleastsquares, offsetradiancequantity, resetunusedradiances, &
      & scaleoverlaps, scatter, spreadchannelfill, transfervectors, &
      & transfervectorsbymethod, uncompressradiance, &
      & qtyfromfile, vectorfromfile, announce_error, &
d89 3
a91 3
      & badestnoisefill, badgeocaltitudequantity, badisotopefill, &
      & badlosgridfill, badlosvelfill, badrefgphquantity, badgphquantity, &
      & badrefractfill, badscvelecrquantity, badtemperaturequantity, &
d95 1
a95 1
      & nosourcegridgiven, nosourcel2auxgiven, nosourcel2gpgiven, &
d179 3
a181 2
      & s_diff, s_directread, s_dump, s_endselect, s_fill, s_fillcovariance, &
      & s_filldiagonal, s_flagcloud, s_flushl2pcbins, s_flushpfa, s_hessian, &
d192 2
a193 2
    use L2GPData, only: l2gpdata_t, col_species_hash, col_species_keys
    use L2AUXdata, only: l2auxdata_t
d223 5
a227 5
    use pfadata_m, only: flush_pfadata
    use quantitytemplates, only: quantitytemplate_t, &
      & modifyquantitytemplate
    use readapriori, only: apriorifiles
    use snoopmlsl2, only: snoop
d235 7
a241 7
    use vectorsmodule, only: addvectortodatabase, &
      & clearmask, clonevectorquantity, createvector, &
      & dumpquantitymask, &
      & getvectorqtybytemplateindex, &
      & validatevectorquantity, vector_t, &
      & vectortemplate_t, vectorvalue_t, m_fill
    use vgridsdatabase, only: vgrids
d590 1
a590 1
      L2CFNODE = key
d741 2
d3257 1
a3257 1
       "$Id: Fill.f90,v 2.457 2015/09/30 20:32:36 pwagner Exp $"
d3268 3
@


2.457
log
@With /noZeros field negativePrecision command now resets 0 to -1
@
text
@d79 1
a79 1
      & frominterpolatedqty, fromlosgrid, &
d120 1
a120 1
      & f_highbound, f_h2oquantity, f_h2oprecisionquantity, &
d1416 1
d1418 1
d1440 1
d1451 5
d1593 2
d2273 8
d3254 1
a3254 1
       "$Id: Fill.f90,v 2.456 2015/09/25 02:13:26 vsnyder Exp $"
d3265 3
@


2.456
log
@Add ReferenceMIFUnits to call to UsingMagneticModel
@
text
@d129 1
a129 1
      & f_offsetamount, f_options, f_orbitinclination, f_phitan, &
d470 1
d629 1
d1010 2
d1029 5
d3236 1
a3236 1
       "$Id: Fill.f90,v 2.455 2015/09/22 23:39:05 vsnyder Exp $"
d3247 3
@


2.455
log
@Add ReferenceMIF and Regular fields
@
text
@d2674 2
a2675 1
                                  & regular=regular, referenceMIF=referenceMIF )
d3227 1
a3227 1
       "$Id: Fill.f90,v 2.454 2015/09/17 23:16:15 pwagner Exp $"
d3238 3
@


2.454
log
@Added changeSettings command
@
text
@d45 1
d66 1
a66 1
    use expr_m, only: expr, expr_check
d134 3
a136 3
      & f_refract, f_refgphquantity, f_refgphprecisionquantity, f_resetseed, &
      & f_rhiprecisionquantity, f_rhiquantity, f_rank, f_rows, f_scale, &
      & f_scaleinsts, f_scaleratio, f_scalesurfs, f_sceci, &
a546 1
    logical :: UNITSERROR               ! From expr
d1417 3
d1430 3
d1736 6
d2655 4
d2661 3
a2663 1
                                    & geocAltitudeQuantity, gphQuantity )
d2665 3
a2667 1
            call UsingMagneticModel ( quantity, key, gphQuantity=gphQuantity )
d2670 2
d2673 2
a2674 1
                                  & geocAltitudeQuantity)
d3226 1
a3226 1
       "$Id: Fill.f90,v 2.453 2015/08/25 17:32:53 vsnyder Exp $"
d3237 3
@


2.453
log
@PhiWindow is a tuple, with the first element specifying the angles or
number of profiles/MAFs before the tangent point, and the second
specifying the angles or number after.  Set its default to [1,2] instead
of 4.  Check that the units are either angles or profiles.  If it's input
as a tuple, allow one to be dimensionless.  If it's not a tuple, and its
units are profiles, it specifies the total number of profiles; put (n-1)/2
before and the rest after after, with one more before if n is even.  If
it's not a tuple and its units are angles, put half before and half after.
@
text
@d182 1
a182 1
      & s_select, s_skip, s_snoop, s_streamlinehessian, s_subset, &
d1032 4
d2295 2
a2296 2
        if ( .not.all(got( (/ f_refGPHPrecisionQuantity, f_tempPrecisionQuantity /))) ) &
          call Announce_Error ( key,needTempREFGPH )
a2313 1
        ! call output( 'Filling quantity from grid', advance='yes' )
d3203 1
a3203 1
       "$Id: Fill.f90,v 2.452 2015/04/30 02:54:31 vsnyder Exp $"
d3214 10
@


2.452
log
@Allow to run the magnetic model without ScVelECR and TngtGeocAlt
@
text
@d92 2
a93 2
      & needgeocaltitude, needh2o, needorbitinclination, &
      & needtemprefgph, nocodefor, no_error_code, noexplicitvaluesgiven, &
d369 1
d479 1
a479 1
    real(r8) :: PHIWINDOW               ! For hydrostatic ptan guesser
d645 1
a645 1
      phiWindow = 4
d1392 1
a1392 1
      use Declaration_Table, only: BASE_UNIT
d1394 5
a1398 5
      use init_tables_module, only: l_none
      use intrinsic, only: lit_indices, t_boolean, t_numeric
      use string_table, only: display_string
      use vector_qty_expr_m, only: dot, vector_qty_expr
      use vectorsmodule, only: destroyvectorquantitymask, destroyvectorquantityvalue, &
d1678 12
a1689 3
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/ PHYQ_Profiles, PHYQ_Angle /), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
a1690 1
          phiWindow = valueAsArray(1)
d1692 12
d3200 1
a3200 1
       "$Id: Fill.f90,v 2.451 2015/04/29 01:18:41 vsnyder Exp $"
d3211 3
@


2.451
log
@Correct reference to UsingMagneticModel
@
text
@d2629 1
a2629 4
          call Announce_Error ( key, no_Error_Code, &
            & 'Need either geopotential height quantity, or ' // &
            & 'tangent geocentric altitude and spacecraft ECR ' // &
            & 'velocity quantities, for magnetic model' )
d3179 1
a3179 1
       "$Id: Fill.f90,v 2.450 2015/04/21 17:48:08 pwagner Exp $"
d3190 3
@


2.450
log
@May DirectRead, DirectWrite files with /noPCFid even when usingPCF; may DirectRead qty geolocations
@
text
@d89 1
a89 1
      & badlosgridfill, badlosvelfill, badrefgphquantity, &
d2587 2
a2588 5
        nullify ( geocAltitudeQuantity, scVelQuantity )
        if ( .not. got ( f_geocAltitudeQuantity ) ) then
          call Announce_Error ( key, no_Error_Code, &
            & 'Need geocentric altitude for magnetic model' )
        else
d2596 9
a2604 4
        if ( .not. got ( f_scVelECR ) ) then
          call Announce_Error ( key, no_Error_Code, &
            & 'Spacecraft Velocity ECR needed for magnetic model' )
        else
d2608 1
a2608 1
            call Announce_Error ( key, BadScVelECRQuantity )
d2612 22
a2633 4
        if ( associated ( geocAltitudeQuantity ) .and. &
           & associated ( scVelQuantity ) ) &
             & call UsingMagneticModel ( quantity, geocAltitudeQuantity, &
                                       & scVelQuantity, key )
d3182 1
a3182 1
       "$Id: Fill.f90,v 2.449 2015/04/09 22:18:58 pwagner Exp $"
d3193 3
@


2.449
log
@We may DirectRead a quantity type
@
text
@d127 1
a127 1
      & f_nofinegrid, f_noise, f_noisebandwidth, f_normqty, &
d467 1
d626 1
d1258 1
d1268 1
d1310 2
d1322 2
d1340 1
d3108 3
a3110 1
      if ( TOOLKIT .and. index (fileName, '/') < 1 ) then
d3114 1
a3114 2
          returnStatus = Pgs_pc_getReference(pcfCode, version, &
            & fileName)
d3119 1
a3119 1
          lun = GetPCFromRef(fileName, pcfCode, &
d3122 1
a3122 1
            & exactName=PCFFileName)
d3162 1
a3162 1
       "$Id: Fill.f90,v 2.448 2015/03/28 02:34:16 vsnyder Exp $"
d3173 3
@


2.448
log
@Add requirement for ScVelECR and TngtGeocAlt fields for magnetic field
fill.  Remove GPHQuantity from magnetic field fill (because we use
geometric height now).  Added stuff to trace allocate/deallocate addresses.
@
text
@d16 2
a17 2
  use MLSCOMMON, only: MLSFILE_T, DEFAULTUNDEFINEDVALUE
  use MLSKINDS, only: R8, RV
d56 146
a201 146
    use ALLOCATE_DEALLOCATE, only: Test_Allocate, Test_Deallocate
    use CHUNKS_M, only: MLSCHUNK_T
    use DESTROYCOMMAND_M, only: DESTROYCOMMAND
    use DUMPCOMMAND_M, only: BOOLEANFROMANYGOODRADIANCES, &
      & BOOLEANFROMANYGOODVALUES, &
      & BOOLEANFROMCATCHWARNING, BOOLEANFROMCOMPARINGQTYS, BOOLEANFROMFORMULA, &
      & DUMPCOMMAND, INITIALIZEREPEAT, NEXTREPEAT, &
      & MLSCASE, MLSENDSELECT, MLSSELECT, MLSSELECTING, &
      & REPEAT=>SKIP, SKIP
    use EXPR_M, only: EXPR, EXPR_CHECK
    use FILLUTILS_1, only: ADDGAUSSIANNOISE, APPLYBASELINE, AUTOFILLVECTOR, &
      & COMPUTETOTALPOWER, DERIVATIVEOFSOURCE, FILLCOVARIANCE, &
      & EXTRACTSINGLECHANNEL, FILLERROR, FROMANOTHER, FROMGRID, &
      & FROML2GP, FROMPROFILE, GATHER, GEOIDDATA, LOSVELOCITY, &
      & CHISQCHAN, CHISQMMAF, CHISQMMIF, CHISQRATIO, &
      & COLABUNDANCE, FOLDEDRADIANCE, PHITANWITHREFRACTION, &
      & IWCFROMEXTINCTION, RHIFROMORTOH2O, NORADSPERMIF, &
      & RHIPRECISIONFROMORTOH2O, WITHESTNOISE, &
      & Hydrostatically_GPH, Hydrostatically_PTan, FROMSPLITSIDEBAND, &
      & GPHPRECISION, FROMISOTOPE, FROMASCIIFILE, ROTATEMAGNETICFIELD, &
      & EXPLICIT, FROML1B, &
      & FROML2AUX, USINGMAGNETICMODEL, &
      & FROMINTERPOLATEDQTY, FROMLOSGRID, &
      & BYMANIPULATION, MANIPULATEVECTORS, WITHREFLECTORTEMPERATURE, &
      & WITHASCORDESC, WITHREICHLERWMOTP, &
      & WITHWMOTROPOPAUSE, WITHBINRESULTS, WITHBOXCARFUNCTION, &
      & STATUSQUANTITY, QUALITYFROMCHISQ, CONVERGENCEFROMCHISQ, &
      & USINGLEASTSQUARES, OFFSETRADIANCEQUANTITY, RESETUNUSEDRADIANCES, &
      & SCALEOVERLAPS, SCATTER, SPREADCHANNELFILL, TRANSFERVECTORS, &
      & TRANSFERVECTORSBYMETHOD, UNCOMPRESSRADIANCE, &
      & QTYFROMFILE, VECTORFROMFILE, ANNOUNCE_ERROR, &
      ! codes for ANNOUNCE_ERROR:
      & BADESTNOISEFILL, BADGEOCALTITUDEQUANTITY, BADISOTOPEFILL, &
      & BADLOSGRIDFILL, BADLOSVELFILL, BADREFGPHQUANTITY, &
      & BADREFRACTFILL, BadScVelECRQuantity, BADTEMPERATUREQUANTITY, &
      & BOTHFRACTIONANDLENGTH, MISSINGFIELD, &
      & NEEDGEOCALTITUDE, NEEDH2O, NEEDORBITINCLINATION, &
      & NEEDTEMPREFGPH, NOCODEFOR, NO_ERROR_CODE, NOEXPLICITVALUESGIVEN, &
      & NOSOURCEGRIDGIVEN, NOSOURCEL2AUXGIVEN, NOSOURCEL2GPGIVEN, &
      & NOTIMPLEMENTED, NOTPLAIN, NOTSPD, &
      & WRONGUNITS
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use FORWARDMODELSUPPORT, only: FILLFWDMODELTIMINGS
    use GLOBAL_SETTINGS, only: BRIGHTOBJECTS
    use GRIDDEDDATA, only: GRIDDEDDATA_T
    use HESSIANMODULE_1, only: ADDHESSIANTODATABASE, CREATEEMPTYHESSIAN, &
      & STREAMLINEHESSIAN, HESSIAN_T
    use HGRIDSDATABASE, only: HGRID_T
    use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
    ! We need many things from init_tables_module.  first the fields:
    use INIT_TABLES_MODULE, only: F_A, F_ADDITIONAL, F_ALLOWMISSING, &
      & F_APRIORIPRECISION, F_ASPERCENTAGE, F_AUTOFILL, F_AVOIDBRIGHTOBJECTS, &
      & F_B, F_BADRANGE, F_BASELINEQUANTITY, F_BIN, F_BLOCK, &
      & F_BOUNDARYPRESSURE, F_BOXCARMETHOD, &
      & F_C, F_CENTERVERTICALLY, F_CHANNEL, F_CHANNELS, F_COLUMNS, F_COUNT, &
      & F_DESTINATION, F_DIAGONAL, F_DIMLIST, &
      & F_DONTLATCH, F_DONTMASK, &
      & F_ECRTOFOV, F_EARTHRADIUS, F_EXACT, F_EXCLUDEBELOWBOTTOM, &
      & F_EXPLICITVALUES, F_EXPR, F_EXTINCTION, &
      & F_FIELDECR, F_FILE, F_FLAGS, F_FORCE, F_SHAPE, &
      & F_FRACTION, F_FROMPRECISION, &
      & F_GEOCALTITUDEQUANTITY, F_GEOLOCATION, F_GPHQUANTITY, &
      & F_HEIGHT, F_HEIGHTRANGE, F_HESSIAN, &
      & F_HIGHBOUND, F_H2OQUANTITY, F_H2OPRECISIONQUANTITY, &
      & F_IFMISSINGGMAO, &
      & F_IGNORENEGATIVE, F_IGNOREGEOLOCATION, F_IGNORETEMPLATE, F_IGNOREZERO, &
      & F_INSTANCES, F_INTEGRATIONTIME, F_INTERNALVGRID, &
      & F_INTERPOLATE, F_INVERT, F_INTRINSIC, F_ISPRECISION, &
      & F_LENGTHSCALE, F_LOGSPACE, F_LOSQTY, F_LOWBOUND, F_LSB, F_LSBFRACTION, &
      & F_MANIPULATION, F_MATRIX, F_MAXITERATIONS, F_MAXVALUE, F_MEASUREMENTS, &
      & F_METHOD, F_MINNORMQTY, F_MINVALUE, F_MODEL, F_MULTIPLIER, &
      & F_NOFINEGRID, F_NOISE, F_NOISEBANDWIDTH, F_NORMQTY, &
      & F_OFFSETAMOUNT, F_OPTIONS, F_ORBITINCLINATION, F_PHITAN, &
      & F_PHIWINDOW, F_PHIZERO, F_PRECISION, F_PRECISIONFACTOR, &
      & F_PROFILE, F_PROFILEVALUES, F_PTANQUANTITY, &
      & F_QUADRATURE, F_QUANTITY, F_QUANTITYNAMES, &
      & F_RADIANCEQUANTITY, F_RATIOQUANTITY, &
      & F_REFRACT, F_REFGPHQUANTITY, F_REFGPHPRECISIONQUANTITY, F_RESETSEED, &
      & F_RHIPRECISIONQUANTITY, F_RHIQUANTITY, F_ROWS, F_SCALE, &
      & F_SCALEINSTS, F_SCALERATIO, F_SCALESURFS, F_SCECI, &
      & F_SCVEL, F_SCVELECI, F_SCVELECR, F_SDNAME, F_SEED, F_SKIPMASK, &
      & F_SOURCE, F_SOURCEGRID, F_SOURCEL2AUX, F_SOURCEL2GP, &
      & F_SOURCEQUANTITY, F_SOURCEVGRID, F_SPREAD, F_START, F_STATUS, F_STRIDE, &
      & F_SUFFIX, F_SURFACE, &
      & F_SYSTEMTEMPERATURE, F_TEMPERATUREQUANTITY, F_TEMPPRECISIONQUANTITY, &
      & F_TEMPLATE, F_TNGTECI, F_TERMS, F_TOTALPOWERQUANTITY, &
      & F_TYPE, F_UNIT, F_USB, F_USBFRACTION, F_VECTOR, F_VMRQUANTITY, &
      & F_WHEREFILL, F_WHERENOTFILL, F_WIDTH, &
      & FIELD_FIRST, FIELD_LAST
    ! Now the literals:
    use INIT_TABLES_MODULE, only: L_ADDNOISE, L_APPLYBASELINE, L_ASCENDDESCEND, &
      & L_ASCIIFILE, L_BINMAX, L_BINMEAN, L_BINMIN, L_BINTOTAL, &
      & L_BOUNDARYPRESSURE, L_BOXCAR, L_CHISQCHAN, &
      & L_CHISQMMAF, L_CHISQMMIF, L_CHISQRATIO, L_CHOLESKY, &
      & L_CLOUDICE, L_CLOUDEXTINCTION, &
      & L_COMBINECHANNELS, L_COLUMNABUNDANCE, L_CONVERGENCERATIO, &
      & L_DERIVATIVE, L_DOBSONUNITS, L_DU, &
      & L_ESTIMATEDNOISE, L_EXPLICIT, L_EXTRACTCHANNEL, L_FOLD, &
      & L_FWDMODELTIMING, L_FWDMODELMEAN, L_FWDMODELSTDDEV, &
      & L_GATHER, L_GEOCALTITUDE, L_GEODALTITUDE, L_GEOLOCATION, &
      & L_GEOIDDATA, L_GPH, L_GPHPRECISION, L_GPHRESETTOGEOID, L_GRIDDED, &
      & L_H2OFROMRHI, L_H2OPRECISIONFROMRHI, L_HYDROSTATIC, L_ISOTOPE, &
      & L_IWCFROMEXTINCTION, L_KRONECKER, &
      & L_L1B, L_L2GP, L_L2AUX, &
      & L_LOSVEL, L_LSGLOBAL, L_LSLOCAL, L_LSWEIGHTED, &
      & L_MAGAZEL, L_MAGNETICMODEL, &
      & L_MANIPULATE, L_MEAN, L_MODIFYTEMPLATE, L_MOLCM2, &
      & L_NEGATIVEPRECISION, L_NONE, &
      & L_NORADSPERMIF, L_OFFSETRADIANCE, &
      & L_PHASETIMING, L_PHITAN, &
      & L_PLAIN, L_PROFILE, L_PTAN,  L_QUALITY, &
      & L_RECTANGLEFROMLOS, L_REFGPH, L_REFRACT, &
      & L_REFLECTORTEMPMODEL, L_RESETUNUSEDRADIANCES, L_RHI, &
      & L_RHIFROMH2O, L_RHIPRECISIONFROMH2O, L_ROTATEFIELD, L_SCALEOVERLAPS, &
      & L_SECTIONTIMING, L_SCATTER, L_ScVelECR, L_SPD, L_SPREADCHANNEL, &
      & L_SPLITSIDEBAND, L_STATUS, L_SWAPVALUES, &
      & L_TEMPERATURE, L_TNGTGEODALT, &
      & L_TNGTGEOCALT, L_UNCOMPRESSRADIANCE, L_VECTOR, L_VGRID, L_VMR, L_WMOTROPOPAuse, &
      & L_ZETA
    ! Now the specifications:
    use INIT_TABLES_MODULE, only: S_ANYGOODVALUES, S_ANYGOODRADIANCES, &
      & S_CASE, S_CATCHWARNING, S_COMPARE, S_COMPUTETOTALPOWER, S_DESTROY, &
      & S_DIFF, S_DIRECTREAD, S_DUMP, S_ENDSELECT, S_FILL, S_FILLCOVARIANCE, &
      & S_FILLDIAGONAL, S_FLAGCLOUD, S_FLUSHL2PCBINS, S_FLUSHPFA, S_HESSIAN, &
      & S_LOAD, S_MATRIX,  S_NEGATIVEPRECISION, S_PHASE, S_POPULATEL2PCBIN, &
      & S_REEVALUATE, S_REPEAT, S_RESTRICTRANGE, &
      & S_SELECT, S_SKIP, S_SNOOP, S_STREAMLINEHESSIAN, S_SUBSET, &
      & S_TIME, S_TRANSFER, S_UPDATEMASK, S_VECTOR
    ! Now some arrays
    use INTRINSIC, only: LIT_INDICES, &
      & PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_INVALID, PHYQ_LENGTH, &
      & PHYQ_PROFILES
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use L1BDATA, only: DEALLOCATEL1BDATA, L1BDATA_T, READL1BDATA
    use L2GPDATA, only: L2GPDATA_T, COL_SPECIES_HASH, COL_SPECIES_KEYS
    use L2AUXDATA, only: L2AUXDATA_T
    use L2PC_M, only: POPULATEL2PCBINBYNAME, LOADHESSIAN, LOADMATRIX, LOADVECTOR
    use L2PCBINS_M, only: FLUSHLOCKEDBINS
    use MANIPULATEVECTORQUANTITIES, only: DOHGRIDSMATCH, &
      & FILLWITHCOMBINEDCHANNELS
    use MATRIXMODULE_1, only: ADDTOMATRIXDATABASE, CREATEEMPTYMATRIX, &
      & GETACTUALMATRIXFROMDATABASE, GETDIAGONAL, &
      & GETKINDFROMMATRIXDATABASE, GETFROMMATRIXDATABASE, K_PLAIN, K_SPD, &
      & MATRIX_CHOLESKY_T, MATRIX_DATABASE_T, MATRIX_KRONECKER_T, MATRIX_SPD_T, &
      & MATRIX_T, NULLIFYMATRIX
    ! NOTE: if you ever want to include defined assignment for matrices, please
d203 37
a239 37
    use MLSFILES, only: GETMLSFILEBYTYPE
    use MLSL2OPTIONS, only: L2CFNODE, &
      & SKIPRETRIEVAL, SPECIALDUMPFILE, MLSMESSAGE
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES, &
      & ADDPHASETOPHASENAMES, FILLTIMINGS, FINISHTIMINGS
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING, &
      & MLSMSG_L1BREAD, MLSMESSAGERESET
    use MLSPCF2, only: MLSPCF_L2APRIORI_START, MLSPCF_L2APRIORI_END
    use MLSRANDOMNUMBER, only: MLS_RANDOM_SEED, MATH77_RAN_PACK
    use MLSSTRINGLISTS, only: CATLISTS, GETHASHELEMENT, &
      & NUMSTRINGELEMENTS, PUTHASHELEMENT, &
      & STRINGELEMENT, STRINGELEMENTNUM
    use MLSSTRINGS, only: LOWERCASE
    use MOLECULES, only: L_H2O
    use MORETREE, only: GET_BOOLEAN, GET_FIELD_ID, Get_Label_And_Spec, &
      & GET_SPEC_ID
    use Next_Tree_Node_m, only: Next_Tree_Node, Next_Tree_Node_State
    use OUTPUT_M, only: BLANKS, OUTPUT, REVERTOUTPUT, SWITCHOUTPUT
    use PFADATA_M, only: FLUSH_PFADATA
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, &
      & MODIFYQUANTITYTEMPLATE
    use READAPRIORI, only: APRIORIFILES
    use SNOOPMLSL2, only: SNOOP
    use STRING_TABLE, only: GET_STRING
    use SUBSETMODULE, only: APPLYMASKTOQUANTITY, RESTRICTRANGE, &
      & SETUPFLAGCLOUD, SETUPSUBSET, UPDATEMASK
    use TIME_M, only: TIME_NOW
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATE, DECORATION, NSONS, SUB_ROSA, SUBTREE, WHERE
    use VECTORSMODULE, only: ADDVECTORTODATABASE, &
      & CLEARMASK, CLONEVECTORQUANTITY, CREATEVECTOR, &
      & DUMPQUANTITYMASK, &
      & GETVECTORQTYBYTEMPLATEINDEX, &
      & VALIDATEVECTORQUANTITY, VECTOR_T, &
      & VECTORTEMPLATE_T, VECTORVALUE_T, M_FILL
    use VGRIDSDATABASE, only: VGRIDS
d1210 2
a1211 2
      use INIT_TABLES_MODULE, only: F_GEODANGLE, F_HESSIAN, &
        & F_SCALEHEIGHT, F_SURFACE, F_THRESHOLD
d1246 2
a1247 1
      use L2PC_M, only: READCOMPLETEHDF5L2PCFILE
d1250 2
a1251 2
      ! integer :: EXPRUNITS(2)             ! From expr
      ! real (r8) :: EXPRVALUE(2)           ! From expr
d1260 1
d1270 1
d1316 7
d1347 10
a1356 2
        call QtyFromFile ( key, quantity, MLSFile, &
          & filetypestr, options, sdName, spread, interpolate )
d1384 6
a1389 6
      use INIT_TABLES_MODULE, only: L_NONE
      use INTRINSIC, only: LIT_INDICES, T_Boolean, T_Numeric
      use STRING_TABLE, only: DISPLAY_STRING
      use VECTOR_QTY_EXPR_M, only: DOT, VECTOR_QTY_EXPR
      use VECTORSMODULE, only: DESTROYVECTORQUANTITYMASK, DESTROYVECTORQUANTITYVALUE, &
      Dump_Vector_Quantity
d3065 9
a3073 9
      use FILLUTILS_1, only: ANNOUNCE_ERROR
      use HDF, only: DFACC_RDONLY
      use INTRINSIC, only: L_ASCII, L_HDF
      use MLSCOMMON, only: MLSFILE_T
      use MLSFILES, only: HDFVERSION_5, &
        & ADDINITIALIZEMLSFILE, GETPCFROMREF, SPLIT_PATH_NAME
      use MLSL2OPTIONS, only: TOOLKIT
      use SDPTOOLKIT, only: PGS_PC_GETREFERENCE
      use STRING_TABLE, only: GET_STRING
d3152 1
a3152 1
       "$Id: Fill.f90,v 2.447 2014/12/10 21:29:12 pwagner Exp $"
d3163 5
@


2.447
log
@Pass ptanQuantity for AscendDescend method
@
text
@d56 1
a56 1
    use ALLOCATE_DEALLOCATE, only: TEST_ALLOCATE, Test_Deallocate
d90 2
a91 2
      & BADREFRACTFILL, BADTEMPERATUREQUANTITY, BOTHFRACTIONANDLENGTH, &
      & MISSINGFIELD, &
d170 1
a170 1
      & L_SECTIONTIMING, L_SCATTER, L_SPD, L_SPREADCHANNEL, &
d188 1
d325 1
d1148 3
d1153 1
a1153 1
          & elementSize = storage_size(snoopMatrices) / 8 )
d1178 2
d1181 1
a1181 1
        call test_deallocate ( status, moduleName, 'snoopMatrices', s )
d1500 1
a1500 1
        case ( f_geocAltitudeQuantity ) ! For hydrostatic
d1505 1
a1505 1
        case ( f_gphQuantity ) ! For magnetic field fill
d1704 1
a1704 1
        case ( f_scVelECI )                ! For special fill of losVel
d1707 1
a1707 1
        case ( f_scVelECR )                ! For special fill of losVel
d2560 4
a2563 2
        if ( .not. got ( f_gphQuantity ) ) then
          call Announce_Error ( key, no_Error_Code, 'Need gphQuantity for magnetic model' )
d2565 6
a2570 3
          GPHQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(GPHVectorIndex), GPHQuantityIndex)
          call UsingMagneticModel ( quantity, gphQuantity, key )
d2572 15
d3134 1
a3134 1
       "$Id: Fill.f90,v 2.446 2014/10/31 17:43:45 vsnyder Exp $"
d3145 3
@


2.446
log
@Separate PTan and GPH hydrostatic fills
@
text
@d1904 2
a1905 1
        call WithAscOrDesc ( quantity, chunks(chunkNo), fileDatabase, hgrids )
d3107 1
a3107 1
       "$Id: Fill.f90,v 2.445 2014/09/30 02:14:38 vsnyder Exp $"
d3118 3
@


2.445
log
@Some stuff that might be useful if we turn on matrix finalizers
@
text
@d74 2
a75 2
      & HYDROSTATICALLY, FROMSPLITSIDEBAND, GPHPRECISION, &
      & FROMISOTOPE, FROMASCIIFILE, ROTATEMAGNETICFIELD, &
d156 1
a156 1
      & L_GEOIDDATA, L_GPHPRECISION, L_GPHRESETTOGEOID, L_GRIDDED, &
d2394 5
a2398 1
        if ( quantity%template%quantityType==l_ptan ) then
d2425 8
a2432 8

        else
          nullify ( geocAltitudeQuantity, h2oQuantity )
        end if
        call Hydrostatically ( key, quantity, temperatureQuantity, &
          & refGPHQuantity, h2oQuantity, orbitInclinationQuantity, &
          & phiTanQuantity, geocAltitudeQuantity, maxIterations, &
          & phiWindow, phiWindowUnits, chunkNo )
d3106 1
a3106 1
       "$Id: Fill.f90,v 2.444 2014/09/05 00:56:02 vsnyder Exp $"
d3117 3
@


2.444
log
@More complete and accurate allocate/deallocate size tracking.  Remove
declarations of unused variables.  Send HGrids database to DumpCommand.
@
text
@d1154 1
d1162 10
d3102 1
a3102 1
       "$Id: Fill.f90,v 2.443 2014/09/05 00:49:06 vsnyder Exp $"
d3113 4
@


2.443
log
@EmpiricalGeometry.f90
@
text
@d3091 1
a3091 1
       "$Id: Fill.f90,v 2.442 2014/06/03 22:42:54 pwagner Exp $"
d3102 3
@


2.442
log
@Pass hGrids to Dump so we may Dump them
@
text
@d56 1
a56 1
    use ALLOCATE_DEALLOCATE, only: TEST_ALLOCATE
d208 1
a208 1
      & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMSG_L1BREAD, MLSMESSAGERESET
d399 1
a399 1
    integer :: I, J                     ! Loop indices for section, spec, expr
d500 1
d1146 3
a1148 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'snoopMatrices' )
d1161 1
d1163 1
a1163 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate//'snoopMatrices' )
d1340 1
a1340 1
      endif
d1347 1
a1347 1
      use DUMP_0, only: DUMP
a1774 1

d3091 1
a3091 1
       "$Id: Fill.f90,v 2.441 2014/04/22 00:45:36 vsnyder Exp $"
d3102 3
@


2.441
log
@Cannonball polishing
@
text
@d729 2
a730 1
          & GriddedDataBase=GriddedDataBase, FileDataBase=FileDataBase, &
d3090 1
a3090 1
       "$Id: Fill.f90,v 2.440 2014/03/20 01:41:48 vsnyder Exp $"
d3101 3
@


2.440
log
@Get Base_Unit from Declaration_Table, improve some tracing
@
text
@d1441 21
a1461 21
        do jj = 2, nsons(subtree(j,key))
          stat = vector_qty_expr ( subtree(jj,subtree(j,key)), vectors, tempQuantity, &
          number, theUnits, 'Fill' )
          select case ( stat )
          case ( t_numeric )
            call output ( number, before='Numeric value of "expr" field = ' )
            if ( theUnits /= phyq_dimensionless ) &
            call display_string ( lit_indices(base_unit(theUnits)), &
              & before=' ', advance='yes' )
          case ( t_boolean )
            call display_string ( lit_indices(nint(number)), &
              & before='Value of "expr" field = ', advance='yes' )
          case ( dot )
            call output ( 'Got vector qty result', advance='yes' )
            call dump_vector_quantity ( tempQuantity, details=1, name='Quantity value of "expr" field' )
            call destroyVectorQuantityMask ( tempQuantity )
            call destroyVectorQuantityValue ( tempQuantity )
          case default
            call output ( 'Got Vector_Qty_Expr_Error', advance='yes' )
          end select
        end do
d3089 1
a3089 1
       "$Id: Fill.f90,v 2.439 2014/03/01 03:10:56 vsnyder Exp $"
d3100 3
@


2.439
log
@Move units checking to init_tables_module
@
text
@d1343 2
d1346 1
a1346 2
      use DUMP_0, only: DUMP
      use INTRINSIC, only: LIT_INDICES
d1348 1
a1348 2
      use UNITS, only: BASE_UNIT
      use VECTOR_QTY_EXPR_M, only: DOT, LOG_VALUE, NUM_VALUE, VECTOR_QTY_EXPR
d1445 1
a1445 1
          case ( log_value, num_value )
d1448 5
a1452 2
            call display_string ( lit_indices(base_unit(theUnits)), before=' ' )
            call output ( '', advance='yes' )
d3089 1
a3089 1
       "$Id: Fill.f90,v 2.438 2014/01/09 00:30:24 pwagner Exp $"
d3100 3
@


2.438
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d186 2
a187 2
      & PHYQ_DIMENSIONLESS, PHYQ_INVALID, PHYQ_TEMPERATURE, &
      & PHYQ_TIME, PHYQ_LENGTH, PHYQ_ANGLE, PHYQ_PROFILES
d1002 1
a1002 4
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1050 1
a1050 1
            call expr ( gson , unitAsArray, valueAsArray )
d1204 1
a1204 4
          call expr_check ( subtree(2,gson), unitAsArray, valueAsArray, &
            & (/PHYQ_Angle/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
d1209 1
a1209 4
          call expr_check ( subtree(2,gson), unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1212 1
a1212 4
          call expr_check ( subtree(2,gson), unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1215 1
a1215 4
          call expr_check ( subtree(2,gson), unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1417 1
a1417 4
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1529 1
a1529 4
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Time/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Time/) )
d1555 1
a1555 4
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1588 2
a1589 5
        case ( f_noFineGrid )      ! For cloud extinction fill
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1597 1
a1597 1
        case ( f_normQty )   ! Only used for chi^2 ratio fills
d1600 2
a1601 5
        case ( f_offsetAmount )    ! For marking unused radiances
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Temperature/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Temperature/) )
d1608 1
a1608 1
        case ( f_precision )      ! For masking l1b radiances
d1611 2
a1612 5
        case ( f_precisionFactor )    ! For setting negative errors
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1615 1
a1615 4
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1619 1
a1619 1
        case ( f_PtanQuantity ) ! For minorframe qty
d1622 1
a1622 1
        case ( f_Phitan ) ! For losGrid fill
d1633 1
a1633 4
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Angle/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
d1640 1
a1640 1
        case ( f_radianceQuantity )      ! For estimated noise
d1643 1
a1643 1
        case ( f_ratioQuantity )      ! For isotope ratio
d1648 1
a1648 1
        case ( f_refGPHQuantity ) ! For hydrostatic or rhi
d1663 1
a1663 4
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1705 1
a1705 1
            call expr(subtree(jj+1,multiplierNode),unitAsArray,valueAsArray)
d1724 1
a1724 4
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d1765 1
a1765 4
          call expr_check ( gson , unitAsArray, valueAsArray, &
            & (/PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
d3086 1
a3086 1
       "$Id: Fill.f90,v 2.437 2013/12/12 02:11:26 vsnyder Exp $"
d3097 3
@


2.437
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d104 1
d219 1
a219 2
    use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE, &
      & REVERTOUTPUT, SWITCHOUTPUT
d3134 1
a3134 1
       "$Id: Fill.f90,v 2.436 2013/11/20 01:01:33 pwagner Exp $"
d3145 3
@


2.436
log
@Prevent accidental reference to undefined pointer phiTanQuantity
@
text
@a64 1
    use Evaluate_Variable_m, only: Evaluate_Variable
d215 3
a217 1
    use MORETREE, only: GET_BOOLEAN, GET_FIELD_ID, GET_SPEC_ID
d231 1
a231 3
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, &
      & SUB_ROSA, SUBTREE, WHERE
    use TREE_TYPES, only: N_NAMED, N_Variable
d321 2
d577 3
a579 2
    do i = 2, nsons(root)-1 ! Skip the section name at begin and end
      son = subtree(i,root)
d582 1
a582 11
      if ( node_id(son) == n_variable ) then
        call evaluate_variable ( son )
    go to 9
      end if
      if ( node_id(son) == n_named ) then ! Is spec labeled?
        key = subtree(2,son)
        vectorName = sub_rosa(subtree(1,son))
      else
        key = son
        vectorName = 0
      end if
d1172 1
a1172 1
    9 call trace_end ( "Fill.spec", cond=toggle(gen) .and. levels(gen) > 0 )
d3134 1
a3134 1
       "$Id: Fill.f90,v 2.435 2013/10/24 21:05:20 pwagner Exp $"
d3145 3
@


2.435
log
@/dontLatch in profile Fills retains profile heights as input
@
text
@d2423 1
a2423 1

d3142 1
a3142 1
       "$Id: Fill.f90,v 2.434 2013/10/09 23:41:20 vsnyder Exp $"
d3153 3
@


2.434
log
@Add Evaluate_Variable
@
text
@d112 1
a112 1
      & F_DONTMASK, &
d118 1
a118 1
      & F_HEIGHT, F_HDFVERSION, F_HEIGHTRANGE, F_HESSIAN, &
d139 1
a139 1
      & F_SUFFIX, F_SUPERDIAGONAL, F_SURFACE, &
d188 1
a188 2
    use L1BDATA, only: DEALLOCATEL1BDATA, L1BDATA_T, READL1BDATA, &
      & ASSEMBLEL1BQTYNAME
d203 1
a203 1
    use MLSL2OPTIONS, only: DEFAULT_HDFVERSION_READ, L2CFNODE, &
d235 1
a235 1
      & DESTROYVECTORQUANTITYVALUE, DUMPQUANTITYMASK, &
d358 1
d520 1
a520 1
    integer :: SUPERDIAGONAL            ! Index of superdiagonal matrix in database
d604 1
d952 3
a954 3
          case ( f_superDiagonal )
            superDiagonal = gson
            call announce_error ( key, notImplemented, "SuperDiagonal" ) !???
d1069 2
d1248 5
a1252 5
    use L2PC_M, only: READCOMPLETEHDF5L2PCFILE
    ! Now we're on actual directRead instructions.
    logical, parameter :: DEEBUG = .true.
      integer :: EXPRUNITS(2)             ! From expr
      real (r8) :: EXPRVALUE(2)           ! From expr
d1258 1
a1258 1
      integer :: hdfversion
d1266 1
a1266 1
      hdfVersion = DEFAULT_HDFVERSION_READ
d1292 8
a1299 8
        case ( f_hdfVersion )
          if ( DEEBUG ) call output ( 'Begin Processing hdfversion field', advance='yes' )
          call expr ( gson, exprUnits, exprValue )
          if ( DEEBUG ) call output ( 'Processing hdfversion field', advance='yes' )
          if ( exprUnits(1) /= phyq_dimensionless ) &
            & call Announce_error ( son, NO_ERROR_CODE, &
            & 'No units allowed for hdfVersion: just integer 4 or 5')
          hdfVersion = exprValue(1)
a1369 1
      use TREE, only: DUMP_TREE_NODE
d1518 2
d2682 1
a2682 1
            & ptanQuantity, logSpace=logSpace )
d2686 1
a2686 1
            & ptanQuantity )
d2688 1
d2701 1
a2701 1
            call announce_error ( key, missingField, extraInfo= &
d3142 1
a3142 1
       "$Id: Fill.f90,v 2.433 2013/10/02 00:48:26 pwagner Exp $"
d3153 3
@


2.433
log
@Added ascenddescend Fill Method
@
text
@d65 1
d233 1
a233 1
    use TREE_TYPES, only: N_NAMED
d580 4
d1177 1
a1177 1
      call trace_end ( "Fill.spec", cond=toggle(gen) .and. levels(gen) > 0 )
d3137 1
a3137 1
       "$Id: Fill.f90,v 2.432 2013/10/01 22:20:58 pwagner Exp $"
d3148 3
@


2.432
log
@geolocation Fill method can fill from any named dataset in l1boa file
@
text
@d80 1
a80 1
      & WITHREICHLERWMOTP, &
d145 2
a146 2
    use INIT_TABLES_MODULE, only: L_ADDNOISE, L_APPLYBASELINE, L_ASCIIFILE, &
      & L_BINMAX, L_BINMEAN, L_BINMIN, L_BINTOTAL, &
d1934 3
d2227 1
a2227 1
            noSurfs = min(quantity%template%noSurfs, size(l1bField%dpField, 2))
d3132 1
a3132 1
       "$Id: Fill.f90,v 2.431 2013/09/28 00:31:34 pwagner Exp $"
d3143 3
@


2.431
log
@Added check for required GPHQuantity with gphResetToGeoid method
@
text
@d51 1
a51 1
    & FWMODELCONFIG, CHUNKS, CHUNKNO )
d103 1
d187 2
d202 1
d208 1
a208 1
      & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMESSAGERESET
d255 1
d410 2
d1358 12
a1369 11
      use Init_Tables_Module, only: L_None
use Dump_0, only: Dump
use Intrinsic, only: Lit_Indices
use String_Table, only: Display_String
use Tree, only: Dump_Tree_Node
use Units, only: Base_Unit
use Vector_Qty_Expr_m, only: Dot, Log_Value, Num_Value, Vector_Qty_Expr
use VectorsModule, only: DestroyVectorQuantityMask, DestroyVectorQuantityValue, &
Dump_Vector_Quantity
double precision :: Number
integer :: Stat
d1371 1
d1373 2
d1376 2
d1381 1
a1381 1
integer :: TheUnits
d1460 18
a1477 18
do jj = 2, nsons(subtree(j,key))
stat = vector_qty_expr ( subtree(jj,subtree(j,key)), vectors, tempQuantity, &
number, theUnits, 'Fill' )
select case ( stat )
case ( log_value, num_value )
call output ( number, before='Numeric value of "expr" field = ' )
if ( theUnits /= phyq_dimensionless ) &
call display_string ( lit_indices(base_unit(theUnits)), before=' ' )
call output ( '', advance='yes' )
case ( dot )
call output ( 'Got vector qty result', advance='yes' )
call dump_vector_quantity ( tempQuantity, details=1, name='Quantity value of "expr" field' )
call destroyVectorQuantityMask ( tempQuantity )
call destroyVectorQuantityValue ( tempQuantity )
case default
call output ( 'Got Vector_Qty_Expr_Error', advance='yes' )
end select
end do
d2211 22
a2232 2
          call Announce_error ( key, no_Error_Code, trim(GLStr) // &
            & 'geolocation not recognized' )
d3129 1
a3129 1
       "$Id: Fill.f90,v 2.430 2013/09/27 00:39:59 pwagner Exp $"
d3140 3
@


2.430
log
@More intuitive interpretations for geoidData, gphResetToGeoid methods
@
text
@d2220 3
d3096 1
a3096 1
       "$Id: Fill.f90,v 2.429 2013/09/24 23:47:22 vsnyder Exp $"
d3107 3
@


2.429
log
@Use Where instead of Source_Ref for messages
@
text
@d115 1
a115 1
      & F_GEOCALTITUDEQUANTITY, F_Geolocation, F_GPHQUANTITY, &
d2217 1
a2217 3
        sourceQuantity => GetVectorQtyByTemplateIndex( &
          & vectors(sourceVectorIndex), sourceQuantityIndex )
        call geoidData ( quantity, sourceQuantity )
d2220 4
a2223 1
        call geoidData ( quantity )
d3093 1
a3093 1
       "$Id: Fill.f90,v 2.428 2013/09/21 00:24:44 pwagner Exp $"
d3104 3
@


2.428
log
@Added geoid Fill methods
@
text
@d227 1
a227 1
      & SOURCE_REF, SUB_ROSA, SUBTREE
d685 1
a685 1
          & where=source_ref(key) ) ) )
d755 1
a755 1
            & vectors(rowVector), vectors(colVector), where=source_ref(key) )) )
d793 1
a793 1
              & vectors(rowVector), vectors(colVector), where=source_ref(key) )
d798 1
a798 1
              & vectors(rowVector), vectors(colVector), where=source_ref(key) )
d803 1
a803 1
              vectors(colVector), where=source_ref(key) )
d808 1
a808 1
              & vectors(colVector), vectors(colVector), where=source_ref(key) )
d1348 2
a1349 2
    ! ------------------------------------------------ fillCommand -----
    subroutine fillCommand
d1352 11
a1362 1
      integer :: GEOLOCATION
d1368 1
d1446 19
d1824 1
a1824 2
      if ( any( fillMethod == (/ &
        & l_status, l_quality /) ) ) then
d3000 1
a3000 1
    end subroutine fillCommand
d3092 1
a3092 1
       "$Id: Fill.f90,v 2.427 2013/09/17 22:43:45 pwagner Exp $"
d3103 3
@


2.427
log
@Added Scatter, Gather methods
@
text
@d69 1
a69 1
      & FROML2GP, FROMPROFILE, GATHER, LOSVELOCITY, &
d153 2
a154 2
      & L_GATHER, L_GEOLOCATION, &
      & L_GEOCALTITUDE, L_GEODALTITUDE, L_GPHPRECISION, L_GRIDDED, &
d2187 8
d3063 1
a3063 1
       "$Id: Fill.f90,v 2.425 2013/08/30 02:45:37 vsnyder Exp $"
d3074 3
@


2.426
log
@Correct 'no_code_for' error message
@
text
@d69 1
a69 1
      & FROML2GP, FROMPROFILE, LOSVELOCITY, &
d84 1
a84 1
      & SCALEOVERLAPS, SPREADCHANNELFILL, TRANSFERVECTORS, &
d87 1
a87 1
      ! CODES FOR ANNOUNCE_ERROR:
d103 1
a103 1
    ! WE NEED MANY THINGS FROM INIT_TABLES_MODULE.  FIRST THE FIELDS:
d106 1
a106 1
      & F_B, F_BADRANGE, F_BASELINEQUANTITY, F_BIN, &
d108 1
a108 1
      & F_C, F_CENTERVERTICALLY, F_CHANNEL, F_CHANNELS, F_COLUMNS, &
d136 1
a136 1
      & F_SOURCEQUANTITY, F_SOURCEVGRID, F_SPREAD, F_STATUS, &
d143 1
a143 1
    ! NOW THE LITERALS:
d152 2
a153 1
      & L_FWDMODELTIMING, L_FWDMODELMEAN, L_FWDMODELSTDDEV, L_GEOLOCATION, &
d168 1
a168 1
      & L_SECTIONTIMING, L_SPD, L_SPREADCHANNEL, &
d173 1
a173 1
    ! NOW THE SPECIFICATIONS:
d182 1
a182 1
    ! NOW SOME ARRAYS
d197 2
a198 2
    ! NOTE: IF YOU EVER WANT TO INCLUDE DEFINED ASSIGNMENT FOR MATRICES, PLEASE
    ! CAREFULLY CHECK OUT THE CODE AROUND THE CALL TO SNOOP.
d1352 1
a1352 1
      integer :: Geolocation
d1354 2
d1366 4
d1699 21
d2173 14
d3066 3
@


2.425
log
@Revise calls to trace_begin and trace_end
@
text
@d1428 1
a1428 1
          call Announce_Error ( key, noCodeFor )
d3013 1
a3013 1
       "$Id: Fill.f90,v 2.424 2013/07/12 23:26:51 vsnyder Exp $"
d3024 3
@


2.424
log
@Mistakenly commited a bunch of debugging stuff
@
text
@d419 2
a420 2
    real(r8) :: MAXVALUE                 ! Value of f_maxValue field
    integer :: MAXVALUEUNIT              ! Unit for f_maxValue field
d426 8
d553 1
a553 1
    if ( toggle(gen) ) call trace_begin ( "MLSL2Fill", root )
d569 2
a570 2
      if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_begin ( "Fill.spec", son )
d816 2
a817 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_begin ( "Fill.subset", root )
d819 1
a819 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_end ( "Fill.subset" )
d822 2
a823 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_begin ( "Fill.RestrictRange", root )
d825 1
a825 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_end ( "Fill.RestrictRange" )
d895 2
a896 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_begin ( "Fill.UpdateMask", root )
d898 1
a898 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_end ( "Fill.UpdateMask" )
d901 2
a902 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_begin ( "Fill.flagCloud", root )
d904 1
a904 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_end ( "Fill.flagCloud" )
d906 1
a906 1
      case ( s_directRead ) ! =============================  direectRead  =====
d909 2
a910 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_begin ( "Fill.fillCommand", key )
d912 2
a913 3
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_end ( "Fill.fillCommand" )
      case ( s_fillcovariance ) ! ===============  Covariance  =====
d1025 2
a1026 2
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_begin ( "Fill.Transfer", key )
d1117 2
a1118 3
        endif
        if ( toggle(gen) .and. levels(gen) > 1 ) &
          & call trace_end ( "Fill.Transfer" )
d1164 1
a1164 2
      if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "Fill.spec" )
d1167 1
a1167 1
    enddo  repeat_loop!  RepeatLoop
d1174 1
a1174 1
    if ( toggle(gen) ) call trace_end ( "MLSL2Fill" )
d3013 1
a3013 1
       "$Id: Fill.f90,v 2.423 2013/07/12 23:25:28 vsnyder Exp $"
d3024 3
@


2.423
log
@Remove unreferenced error messages
@
text
@a2078 1
print *, 'Got back from Explicit'
a2905 1
print *, 'End of s_method'
a2912 6
print *, 'Associated(tempQuantity%mask) = ', Associated(tempQuantity%mask)
if ( Associated(tempQuantity%mask) ) print *, 'Shape(tempQuantity%mask) = ', Shape(tempQuantity%mask)
print *, 'Associated(Quantity%mask) = ', Associated(Quantity%mask)
if ( Associated(Quantity%mask) ) print *, 'Shape(Quantity%mask) = ', Shape(Quantity%mask)
print *, 'associated(Quantity%mask,tempQuantity%mask) = ', associated(Quantity%mask,tempQuantity%mask)
print *, 'before quantity%mask = tempQuantity%mask'
a2914 1
print *, 'Before ClearMask'
a2917 1
print *, 'Before destroyVectorQuantityValue'
a2919 1
print *, 'Leaving FillCommand'
d3012 1
a3012 1
       "$Id: Fill.f90,v 2.422 2013/06/14 18:49:22 vsnyder Exp $"
d3023 3
@


2.422
log
@Decruftification
@
text
@d2079 1
a2079 1

d2907 1
a2907 1
      
d2915 6
d2923 1
d2927 1
d2930 1
d3023 1
a3023 1
       "$Id: Fill.f90,v 2.421 2013/05/31 00:42:12 vsnyder Exp $"
d3034 3
@


2.421
log
@Add geolocation field to fill, used only if method=l1b
@
text
@d135 1
a135 1
      & F_SOURCE, F_SOURCEGRID, F_SOURCEL2AUX, F_SOURCEL2GP, F_SOURCEQUANTITIES, &
d141 1
a141 1
      & F_WHERE, F_WHEREFILL, F_WHERENOTFILL, F_WIDTH, &
d502 1
a502 1
    logical :: STRICT                   ! Maximize checking
d616 1
a616 1
      strict = .false.
a716 1

d3014 1
a3014 1
       "$Id: Fill.f90,v 2.420 2013/05/17 00:49:29 pwagner Exp $"
d3025 3
@


2.420
log
@May constrain Transfer command command to quantitynames by r/t Boolean
@
text
@d115 1
a115 1
      & F_GEOCALTITUDEQUANTITY, F_GPHQUANTITY, &
d1350 2
d1360 1
d1448 2
d2185 1
a2185 1
            & filedatabase, isPrecision, suffix=suffix, &
d2200 2
a2201 1
            & filedatabase, isPrecision, suffix=suffix, BOMask=BOMask )
d2204 1
a2204 1
            & filedatabase, isPrecision, suffix=suffix )
d3015 1
a3015 1
       "$Id: Fill.f90,v 2.419 2013/04/24 00:37:42 pwagner Exp $"
d3026 3
@


2.419
log
@Added InitRepeat and NextRepeat calls to set/increment r/t Boolean count
@
text
@d106 2
a107 2
      & F_B, F_BADRANGE, F_BASELINEQUANTITY, F_BIN, F_BOUNDARYPRESSURE, &
      & F_BOXCARMETHOD, &
d129 2
a130 1
      & F_QUADRATURE, F_QUANTITY, F_RADIANCEQUANTITY, F_RATIOQUANTITY, &
d333 2
a336 1
    integer :: BOXCARMETHOD             ! l_min, l_max, l_mean
d1028 1
d1076 5
a1080 1
            PtanQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
d1091 2
a1092 1
              & vectors(aVecIndex), vectors(bVecIndex), c )
d1096 2
a1097 1
              & vectors(aVecIndex), vectors(bVecIndex) )
d1107 1
a1107 1
            & noiseVector, ptanQuantity )
d1110 2
a1111 1
            & vectors(destinationVectorIndex), skipMask, interpolate )
d1150 2
a1151 1
        call Snoop ( key=key, vectorDatabase=vectors, matrixDatabase=snoopMatrices )
d1186 3
a1188 3
      real(r8) :: GEODANGLE               ! For StreamlineHessian
      real(r8) :: SCALEHEIGHT             ! Scale height for StreamlineHessian
      integer :: SURFACE                  ! Number of surfaces for StreamlineHessian
d3009 1
a3009 1
       "$Id: Fill.f90,v 2.418 2013/04/22 17:51:32 pwagner Exp $"
d3020 3
@


2.418
log
@Reevaluate may store a literal instead of a Boolean value
@
text
@d49 3
a51 3
  subroutine MLSL2Fill ( Root, filedatabase, GriddedDataBase, VectorTemplates, &
    & Vectors, QtyTemplates, Matrices, Hessians, L2GPDatabase, L2AUXDatabase, &
    & FWModelConfig, Chunks, ChunkNo )
d62 2
a63 1
      & DUMPCOMMAND, MLSCASE, MLSENDSELECT, MLSSELECT, MLSSELECTING, &
d236 13
a248 13
    integer, intent(in) :: ROOT    ! Of the FILL section in the AST
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (griddedData_T), dimension(:), pointer :: GriddedDataBase
    type (vectorTemplate_T), dimension(:), pointer :: VectorTemplates
    type (vector_T), dimension(:), pointer :: Vectors
    type (quantityTemplate_T), dimension(:), pointer :: QtyTemplates
    type (matrix_database_T), dimension(:), pointer :: Matrices
    type (Hessian_T), dimension(:), pointer :: Hessians
    type (l2GPData_T), dimension(:), pointer :: L2GPDatabase
    type (l2AUXData_T), dimension(:), pointer :: L2AUXDatabase
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    type (mlSChunk_T), dimension(:), pointer :: Chunks
    integer, intent(in) :: ChunkNo
d552 1
d756 1
d2998 1
a2998 1
       "$Id: Fill.f90,v 2.417 2013/04/17 00:05:07 pwagner Exp $"
d3009 3
@


2.417
log
@Added new Repeat control structure to Fill, Retrieve sections
@
text
@d700 1
a700 1
        call decorate ( key,  BooleanFromFormula ( 0, key ) )
d2995 1
a2995 1
       "$Id: Fill.f90,v 2.416 2013/01/17 20:02:02 pwagner Exp $"
d3006 3
@


2.416
log
@New where field in Subset command
@
text
@d62 2
a63 1
      & DUMPCOMMAND, SKIP, MLSCASE, MLSENDSELECT, MLSSELECT, MLSSELECTING
d163 1
a163 1
      & L_REFLECTORTEMPMODEL, L_RESETUNuseDRADIANCES, L_RHI, &
d174 5
a178 5
      & S_FILLDIAGONAL, S_FLAGCLOUD, S_FLUSHL2PCBINS, S_FLUSHPFA, &
      & S_HESSIAN, S_LOAD, S_MATRIX,  S_NEGATIVEPRECISION, S_PHASE, S_POPULATEL2PCBIN, &
      & S_REEVALUATE, S_RESTRICTRANGE, &
      & S_SELECT, S_SKIP, S_SNOOP, S_STREAMLINEHESSIAN, &
      & S_SUBSET, S_TIME, S_TRANSFER, S_UPDATEMASK, S_VECTOR
d474 1
d550 1
d552 1
a700 1

d749 5
d756 1
a756 1
        if ( Skip(key) ) exit
d1152 2
d2995 1
a2995 1
       "$Id: Fill.f90,v 2.415 2013/01/02 21:40:59 pwagner Exp $"
d3006 3
@


2.415
log
@Added derivative method to Fill command; Transfer can do Fill methods, too
@
text
@d132 2
a133 2
      & F_SOURCE, F_SOURCEGRID, F_SOURCEL2AUX, F_SOURCEL2GP, F_SOURCEQUANTITY, &
      & F_SOURCEVGRID, F_SPREAD, F_STATUS, &
d138 1
a138 1
      & F_WHEREFILL, F_WHERENOTFILL, F_WIDTH, &
d283 2
d286 1
d288 2
a305 4
    type (vectorValue_T), pointer :: ODQUANTITY              ! optical depth
    type (vectorValue_T), pointer :: PHITANQUANTITY
    type (vectorValue_T), pointer :: PTANQUANTITY
    type (vectorValue_T), pointer :: RADQUANTITY
d532 1
d625 1
a625 1
      nullify ( ptanQuantity, radQuantity, odQuantity )
d1740 2
a1741 2
          & radQuantity, ptanQuantity, odQuantity, 0._r8, &
          & maxValue, minValue, heightRange, &
d1747 2
a1748 2
          & radQuantity, ptanQuantity, odQuantity, 0._r8, &
          & maxValue, minValue, heightRange, &
d2985 1
a2985 1
       "$Id: Fill.f90,v 2.414 2012/11/14 20:04:11 pwagner Exp $"
d2996 3
@


2.414
log
@Fix boxcar bug added with last commit
@
text
@d65 1
a65 1
      & COMPUTETOTALPOWER, FILLCOVARIANCE, &
d82 2
a83 1
      & SCALEOVERLAPS, SPREADCHANNELFILL, TRANSFERVECTORS, UNCOMPRESSRADIANCE, &
d147 1
a147 1
      & L_DOBSONUNITS, L_DU, &
d227 1
a227 1
      & DUMPQUANTITYMASK, &
d261 1
d275 1
d278 1
d281 1
d294 1
d577 1
d892 1
a892 1
          & call trace_begin ( "Fill.fillCommand", root )
d1008 3
d1033 1
d1036 7
d1047 14
d1077 9
d1093 2
a1323 1
      use VECTORSMODULE, only: DESTROYVECTORQUANTITYVALUE
d1573 1
a1573 1
        case ( f_PtanQuantity ) ! For losGrid fill
d2011 14
d2983 1
a2983 1
       "$Id: Fill.f90,v 2.413 2012/11/14 00:58:42 pwagner Exp $"
d2994 3
@


2.413
log
@Use dimList for choosing which of {csi} to average over; finished treating width=1
@
text
@d1850 5
d2927 1
a2927 1
       "$Id: Fill.f90,v 2.412 2012/11/08 23:21:30 pwagner Exp $"
d2938 3
@


2.412
log
@dimList field lets us specifiy whether to shift by [c,s,i] during manipulate
@
text
@d107 1
a107 1
      & F_DONTMASK, F_DONTSUMHEIGHTS, F_DONTSUMINSTANCES, &
a341 2
    logical :: DONTSUMHEIGHTS
    logical :: DONTSUMINSTANCES
a567 2
      dontSumHeights = .false.
      dontSumInstances = .false.
d1343 1
a1389 4
        case ( f_dontSumHeights )
          dontSumHeights = get_boolean ( gson )
        case ( f_dontSumInstances )
          dontSumInstances = get_boolean ( gson )
d1846 3
d1850 2
a1852 2
        call WithBoxcarFunction ( key, quantity, sourceQuantity, width, &
          & boxCarMethod, ignoreTemplate )
d2326 1
a2326 1
              & spreadflag, dontSumHeights, dontSumInstances, dimList, &
d2336 1
a2336 1
              & spreadflag, dontSumHeights, dontSumInstances, dimList, &
d2346 1
a2346 1
              & spreadflag, dontSumHeights, dontSumInstances, dimList )
d2356 1
a2356 1
              & spreadflag, dontSumHeights, dontSumInstances, dimList )
d2922 1
a2922 1
       "$Id: Fill.f90,v 2.411 2012/11/05 19:02:48 pwagner Exp $"
d2933 3
@


2.411
log
@Fixed various bugs related to last changes
@
text
@d106 1
a106 1
      & F_DESTINATION, F_DIAGONAL, &
d340 1
d1293 1
d1344 3
d1850 5
d2330 1
a2330 1
              & spreadflag, dontSumHeights, dontSumInstances, &
d2340 1
a2340 1
              & spreadflag, dontSumHeights, dontSumInstances, &
d2350 1
a2350 1
              & spreadflag, dontSumHeights, dontSumInstances )
d2360 1
a2360 1
              & spreadflag, dontSumHeights, dontSumInstances )
d2926 1
a2926 1
       "$Id: Fill.f90,v 2.410 2012/10/31 00:08:40 pwagner Exp $"
d2937 3
@


2.410
log
@Must treat Fill method L1B specially when restoring quantity mask
@
text
@d212 1
a212 1
      & DUMP, MODIFYQUANTITYTEMPLATE
d215 1
a215 1
    use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
d226 1
a226 1
      & DESTROYVECTORQUANTITYMASK, DUMPQUANTITYMASK, &
d1689 1
a1689 1
      ! any height, instances, etc. restrictions you may have set
d1692 3
a1694 6
      if ( qtyWasMasked ) then
        if ( any(tempQuantity%mask /= quantity%mask) ) then
          call Announce_error ( key, no_Error_Code, &
            & 'Mask not cloned successfully' )
        endif
      endif
d1697 13
a1709 17
      call ApplyMaskToQuantity( quantity, &
        & radQuantity, ptanQuantity, odQuantity, 0._r8, &
        & maxValue, minValue, heightRange, &
        & .false., .false., additional, .false., &
        & M_Fill, 0, 0, instancesNode, 0 )
      elseif ( .not. dontMask .or. &
        & any( fillMethod == (/ &
        & l_applyBaseline, l_chiSQChan, l_chiSQMMaf, l_chiSQMMif, l_chiSqRatio, &
        & l_H2OfromRHI, l_H2OPrecisionfromRHi, &
        & l_RHIfromH2O, l_RHIPrecisionfromH2O /) ) ) then
      call ApplyMaskToQuantity( quantity, &
        & radQuantity, ptanQuantity, odQuantity, 0._r8, &
        & maxValue, minValue, heightRange, &
        & .false., .false., additional, .false., &
        & M_Fill, heightNode, surfNode, instancesNode, 0 )
      elseif ( dontMask ) then
        if ( qtyWasMasked ) quantity%mask = char(0)
d1791 1
a1791 1
          & quadrature, dontmask, ignoreTemplate )
d1980 1
a1980 1
          & vectors(vectorIndex)%globalUnit, dontmask, channel, &
d2076 7
d2323 1
a2323 1
              & vectors(vectorIndex)%globalUnit, dontmask, channel, &
d2342 1
a2342 1
              & vectors(vectorIndex)%globalUnit, dontmask, channel, &
d2358 1
a2358 1
          & vectors(vectorIndex)%globalUnit, dontmask, channel, &
d2455 1
a2455 1
            & instancesNode, vectors(vectorIndex)%globalUnit, dontMask, &
d2459 1
a2459 1
            & instancesNode, vectors(vectorIndex)%globalUnit, dontMask, &
d2609 1
a2609 1
          call ScaleOverlaps ( quantity, multiplierNode, dontMask )
d2645 1
a2645 1
          call SpreadChannelFill ( quantity, channel, dontMask, key, &
d2648 1
a2648 1
          call SpreadChannelFill ( quantity, channel, dontMask, key )
d2654 1
a2654 1
            & valuesNode, .true., .false., phyq_Invalid, .true., &
d2699 1
a2699 1
              & key, dontMask, ignoreTemplate )
d2701 1
a2701 1
              & key, dontMask, ignoreTemplate )
d2703 1
a2703 1
              & key, dontMask, ignoreTemplate )
d2708 1
a2708 1
          if ( associated(quantity%mask) .and. .not. dontMask ) then
d2731 1
a2731 1
          & key, ignoreTemplate, spreadflag, dontMask, interpolate, force )
a2812 4
      if ( qtyWasMasked ) then
        ! if ( any(tempQuantity%mask /= quantity%mask) ) &
        !   & call output( 'Masks changed', advance='yes' )
      endif
a2817 3
      ! elseif ( associated(quantity%mask) ) then
        ! quantity%mask = tempQuantity%mask
        ! call DestroyVectorQuantityMask( quantity )
a2818 3
        ! call outputNamedValue( 'mask associated?', associated( quantity%mask ) )
        ! call output( 'Hey, this quantity was not masked:', advance='no' )
        ! call display_string( quantity%template%name, advance='yes' )
d2916 1
a2916 1
       "$Id: Fill.f90,v 2.409 2012/10/29 17:18:24 pwagner Exp $"
d2927 3
@


2.409
log
@Made consistent with FillUtils_1 api
@
text
@d16 1
a16 1
  use MLSCommon, only: MLSFILE_T, DEFAULTUNDEFINEDVALUE
d215 1
a215 1
    use STRING_TABLE, only: GET_STRING
d225 1
a225 1
      & CLONEVECTORQUANTITY, CREATEVECTOR, &
a1690 1
      if ( .true. ) then
d1698 13
a1710 3
      ! call dump( tempQuantity%template )
      ! call dump( Quantity%template )
      if ( .true. ) call ApplyMaskToQuantity( quantity, &
d1715 2
d2811 2
d2814 2
a2815 2
        if ( any(tempQuantity%mask /= quantity%mask) ) &
          & call output( 'Masks changed', advance='yes' )
d2817 4
a2820 2
      if ( .true. ) then
      if ( qtyWasMasked ) then
d2822 8
a2829 3
      !else
        !call DestroyVectorQuantityMask( quantity )
      endif
d2926 1
a2926 1
       "$Id: Fill.f90,v 2.408 2012/10/27 00:27:29 pwagner Exp $"
d2937 3
@


2.408
log
@Temporary fixes; cause of error not yet understood
@
text
@d1977 1
a1977 2
          & heightNode, instancesNode, &
      & .false., options=heightRange(1:1) )
a2312 1
              & heightNode, instancesNode, &
d2332 2
a2333 2
              & heightNode, instancesNode, &
              & .false., options=heightRange(1:1), extraQuantity=tempswapquantity )
d2347 2
a2348 2
          & vectors(vectorIndex)%globalUnit, dontmask, channel, heightNode, instancesNode, &
      & azEl=.true. )
d2644 1
a2644 2
            & channel, 0, instancesNode, &
            & .false., options=heightRange(1:1) )
d2906 1
a2906 1
       "$Id: Fill.f90,v 2.407 2012/10/22 18:14:50 pwagner Exp $"
d2917 3
@


2.407
log
@Many Subset operations now available in Fill
@
text
@d211 2
a212 1
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, MODIFYQUANTITYTEMPLATE
d1286 1
d1690 2
d1693 9
a1701 1
      call ApplyMaskToQuantity( quantity, &
d1703 1
a1703 1
        & maxvalue, minValue, heightRange, &
d1706 1
a1706 1

d1977 2
a1978 1
          & options=options(1:1) )
d2314 2
a2315 1
              & options=options(1:1), extraQuantity=tempswapquantity )
d2334 2
a2335 1
              & options=options(1:1), extraQuantity=tempswapquantity )
d2349 2
a2350 1
          & vectors(vectorIndex)%globalUnit, dontmask, channel, azEl=.true. )
d2646 2
a2647 1
            & channel, options=options(1:1) )
d2803 6
a2808 1
      if ( associated(tempQuantity%mask) ) then
d2810 3
a2812 2
      else
        call DestroyVectorQuantityMask ( quantity )
d2815 2
a2816 1
      call destroyVectorQuantityValue ( tempQuantity, destroyMask=.true. )
d2909 1
a2909 1
       "$Id: Fill.f90,v 2.406 2012/10/09 00:48:30 pwagner Exp $"
d2920 3
@


2.406
log
@New ignoreTemplate, changed force meaning in Fill
@
text
@d105 1
a105 1
      & F_C, F_CENTERVERTICALLY, F_CHANNEL, F_COLUMNS, &
d133 1
a133 1
      & F_SUFFIX, F_SUPERDIAGONAL, &
d215 2
a216 1
    use SUBSETMODULE, only: SETUPSUBSET, SETUPFLAGCLOUD, RESTRICTRANGE, UPDATEMASK
d225 1
d294 1
d297 1
d328 1
d371 1
d492 1
d565 1
d578 1
d602 1
d618 1
d886 2
d889 2
d1283 4
a1286 2
      use VectorsModule, only: DestroyVectorQuantityValue
      integer :: jj
d1336 2
d1392 1
a1392 1
          options = ' '
d1396 12
a1407 4
          call get_string ( manipulation, options, strip=.true. )
          if ( index(' ab', options(1:1)) < 1 ) &
            & call Announce_Error ( key, no_Error_Code, &
              & 'invalid heightRange: ' // trim(options) )
d1630 2
d1678 1
d1681 13
d1695 2
a1793 6
        if ( got ( f_ptanQuantity ) ) then
          ptanQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(ptanVectorIndex), ptanQuantityIndex)
        else
          nullify ( ptanQuantity )
        end if
d1964 2
a1965 2
          & vectors(vectorIndex)%globalUnit, dontmask, channel, heightNode, &
          & instancesNode, options=options(1:1) )
d2300 2
a2301 2
              & vectors(vectorIndex)%globalUnit, dontmask, channel, heightNode, &
              & instancesNode, options=options(1:1), extraQuantity=tempswapquantity )
d2319 2
a2320 2
              & vectors(vectorIndex)%globalUnit, dontmask, channel, heightNode, &
              & instancesNode, options=options(1:1), extraQuantity=tempswapquantity )
d2334 1
a2334 2
          & vectors(vectorIndex)%globalUnit, dontmask, channel, heightNode, &
          & instancesNode, azEl=.true. )
a2424 6
        if ( got ( f_ptanQuantity ) ) then
          ptanQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(ptanVectorIndex), ptanQuantityIndex)
        else
          nullify ( ptanQuantity )
        end if
d2630 1
a2630 2
            & channel, heightNode, &
            & instancesNode, options=options(1:1) )
a2704 6
        if ( got ( f_ptanQuantity )  ) then
          ptanQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(ptanVectorIndex), ptanQuantityIndex)
        else
          nullify ( ptanQuantity )
        endif
d2784 9
d2885 1
a2885 1
       "$Id: Fill.f90,v 2.405 2012/08/16 17:57:16 pwagner Exp $"
d2896 3
@


2.405
log
@Exploit level 2-savvy MLSMessage
@
text
@d16 1
a16 1
  use MLSCommon, only: MLSFile_T, DEFAULTUNDEFINEDVALUE
d65 2
a66 2
      & COMPUTETOTALPOWER, &
      & EXTRACTSINGLECHANNEL, FILLCOVARIANCE, FILLERROR, FROMGRID, &
d88 1
a88 1
      & Inconsistent, MISSINGFIELD, &
d108 3
a110 2
      & F_ECRTOFOV, F_EARTHRADIUS, F_EXACT, F_EXCLUDEBELOWBOTTOM, F_EXPLICITVALUES, &
      & F_EXPR, F_EXTINCTION, F_FIELDECR, F_FILE, F_FLAGS, F_FORCE, F_SHAPE, &
d115 2
a116 1
      & F_IFMISSINGGMAO, F_IGNORENEGATIVE, F_IGNOREGEOLOCATION, F_IGNOREZERO, &
d131 3
a133 2
      & F_SOURCE, F_SOURCEGRID, F_SOURCEL2AUX, F_SOURCEL2GP, &
      & F_SOURCEQUANTITY, F_SOURCEVGRID, F_SPREAD, F_STATUS, F_SUFFIX, F_SUPERDIAGONAL, &
d352 2
a353 2
    logical :: FORCE                    ! Bypass checks on some operations
    integer :: shapeNode              ! For the parser
d359 1
a359 1
    character(len=16) :: GLStr          ! geo. loc. in manipulation='..'
d376 3
a379 2
    logical :: IGNORENEGATIVE           ! Don't sum chi^2 at values of noise < 0
    logical :: IGNOREGEOLOCATION        ! Don't copy geolocation to vector qua
d398 4
a401 4
    type(matrix_Cholesky_T) :: MatrixCholesky
    type(matrix_Kronecker_T) :: MatrixKronecker
    type(matrix_SPD_T) :: MatrixSPD
    type(matrix_T) :: MatrixPlain
d421 1
a421 1
    type (MLSFile_T), pointer   :: MLSFile
d484 1
d486 1
a486 1
    logical :: Switch2intrinsic         ! Have mls_random_seed call intrinsic
d573 1
d592 1
d892 2
a910 3
        else if ( covariance%m%row%vec%template%name /= &
                & vectors(diagonal)%template%name ) then
          call announce_error ( key, inconsistent )
d913 1
a913 1
            & vectors, diagonal, lengthScale, fraction, invert )
d1037 1
a1037 1
            & 'Transfer command requires either source or a field' )
d1387 2
d1599 2
d1721 1
a1721 1
          & noiseQty, multiplier )
d1730 1
a1730 1
          & quadrature, dontmask )
d1791 1
a1791 1
          & boxCarMethod )
d1806 1
a1806 1
            & dontMask, ignoreZero, ignoreNegative, multiplier )
d1821 1
a1821 1
            & dontMask, ignoreZero, ignoreNegative, multiplier )
d1836 1
a1836 1
            & dontMask, ignoreZero, ignoreNegative, multiplier )
d1850 1
a1850 1
          & quantity, normQty, minNormQty, flagQty, dontMask )
d1882 1
a1882 1
            & bndPressQty, vmrQty, colmAbUnits )
d1900 2
a1901 1
        call ConvergenceFromChisq ( key, quantity, sourceQuantity, scale )
d1924 1
a1924 1
        call Explicit ( quantity, valuesNode, spreadFlag, &
d1934 2
a1935 1
        call ExtractSingleChannel ( key, quantity, sourceQuantity, channel )
d2257 2
a2258 2
              & manipulation, key, &
              & force, spreadflag, dontSumHeights, dontSumInstances, &
d2260 1
a2260 1
            call Explicit ( quantity, valuesNode, spreadFlag, &
d2267 2
a2268 2
              & manipulation, key, &
              & force, spreadflag, dontSumHeights, dontSumInstances, &
d2277 3
a2279 3
              & manipulation, key, &
              & force, spreadflag, dontSumHeights, dontSumInstances )
            call Explicit ( quantity, valuesNode, spreadFlag, &
d2286 2
a2287 2
              & manipulation, key, &
              & force, spreadflag, dontSumHeights, dontSumInstances )
d2294 1
a2294 1
        call Explicit ( quantity, valuesNode, spreadFlag, &
d2394 2
a2395 2
        ! The problem is, it should default to quantity%template%logSpace so absent means I don't
        ! care not logSpace=.false.
d2432 3
a2434 1
            & orbitInclinationQuantity, ptanQuantity, refGPHquantity, temperatureQuantity )
d2490 2
a2491 1
        call QualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )
d2597 2
a2598 1
            & valuesNode, .true., phyq_Invalid, .true., channel, heightNode, &
d2625 2
a2626 1
            & minValue, maxValue, heightNode, additional, force, exact )
d2638 1
a2638 1
          if ( .not. interpolate .and. .not. force ) then
d2643 1
a2643 1
              & force, key, dontMask )
d2645 1
a2645 1
              & force, key, dontMask )
d2647 1
a2647 1
              & force, key, dontMask )
a2666 5
        ! This is VERY PRELIMINARY, A more fancy one needs to be written
        ! before too long.
        ! Note that this does *NOT* copy the mask (at least for the moment)
        ! It is assumed that the original one (e.g. inherited from transfer)
        ! is still relevant.
d2674 1
a2674 1
        if ( got ( f_ptanQuantity ) ) then
a2676 10
          call FromInterpolatedQty ( quantity, sourceQuantity, &
            & force, key, dontMask, ptanQuantity )
        elseif ( quantity%template%name /= sourceQuantity%template%name ) then
          if ( .not. interpolate .and. .not. force ) then
            call Announce_Error ( key, No_Error_Code, &
              & 'Quantity and sourceQuantity do not have the same template' )
          else
            call FromInterpolatedQty ( quantity, sourceQuantity, &
              & force, key, dontMask )
          end if
d2678 4
a2681 11
          ! Just a straight copy
          ! If we have a mask and we're going to obey it then do so
          if ( associated(quantity%mask) .and. .not. dontMask ) then
            where ( iand ( ichar(quantity%mask(:,:)), m_Fill ) == 0 )
              quantity%values(:,:) = sourceQuantity%values(:,:)
            end where
          else ! Otherwise, just blindly copy
            quantity%values = sourceQuantity%values
          end if
        end if

d2851 1
a2851 1
       "$Id: Fill.f90,v 2.404 2012/07/31 00:48:16 vsnyder Exp $"
d2862 3
@


2.404
log
@Use DestroyVectorQuantityValue abstraction
@
text
@d56 1
a56 1
    use ALLOCATE_DEALLOCATE, only: TEST_ALLOCATE, DEALLOCATE_TEST
d191 2
a192 1
    use MLSL2OPTIONS, only: DEFAULT_HDFVERSION_READ, SKIPRETRIEVAL, SPECIALDUMPFILE
d196 1
a196 1
      & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMESSAGE, MLSMESSAGERESET
d542 1
d2856 1
a2856 1
       "$Id: Fill.f90,v 2.403 2012/05/08 17:49:04 pwagner Exp $"
d2867 3
@


2.403
log
@Added Select .. Case .. EndSelect control structure
@
text
@d1260 1
d2249 2
a2250 4
            call deallocate_test( tempswapquantity%values, 'tempswapquantity%values', &
              & moduleName )
            call deallocate_test( tempswapquantity%mask, 'tempswapquantity%mask', &
              & moduleName )
d2268 2
a2269 4
            call deallocate_test( tempswapquantity%values, 'tempswapquantity%values', &
              & moduleName )
            call deallocate_test( tempswapquantity%mask, 'tempswapquantity%mask', &
              & moduleName )
d2645 2
a2646 4
        call deallocate_test( tempswapquantity%values, 'tempswapquantity%values', &
          & moduleName )
        call deallocate_test( tempswapquantity%mask, 'tempswapquantity%mask', &
          & moduleName )
d2854 1
a2854 1
       "$Id: Fill.f90,v 2.402 2012/02/24 21:20:44 pwagner Exp $"
d2865 3
@


2.402
log
@DirectRead may /interpolate vertically
@
text
@d62 1
a62 1
      & DUMPCOMMAND, SKIP
d167 2
a168 2
      & S_CATCHWARNING, S_COMPARE, S_COMPUTETOTALPOWER, S_DESTROY, &
      & S_DIFF, S_DIRECTREAD, S_DUMP, S_FILL, S_FILLCOVARIANCE, &
d171 2
a172 1
      & S_REEVALUATE, S_RESTRICTRANGE, S_SKIP, S_SNOOP, S_STREAMLINEHESSIAN, &
d541 2
d653 9
d2859 1
a2859 1
       "$Id: Fill.f90,v 2.401 2012/02/13 23:28:45 pwagner Exp $"
d2870 3
@


2.401
log
@Corrected error message
@
text
@d1141 1
d1154 1
d1195 2
a1198 1
            call outputNamedValue( 'spread', spread )
d1222 1
a1222 1
          & filetypestr, options, sdName, spread )
d1241 1
a1241 1
          & filetypestr, options, spread )
d2847 1
a2847 1
       "$Id: Fill.f90,v 2.400 2012/02/10 23:45:43 vsnyder Exp $"
d2858 3
@


2.400
log
@Add more tracing, change some tracing levels
@
text
@d820 1
a820 1
            & 'Must supply either matrix or vector to adopt' )
d2844 1
a2844 1
       "$Id: Fill.f90,v 2.399 2012/02/02 01:19:05 pwagner Exp $"
d2855 3
@


2.399
log
@Can DirectRead matrix or hessian
@
text
@d531 2
d757 1
a757 1
        if ( toggle(gen) .and. levels(gen) > 0 ) &
d760 1
a760 1
        if ( toggle(gen) .and. levels(gen) > 0 ) &
d764 1
a764 1
        if ( toggle(gen) .and. levels(gen) > 0 ) &
d767 1
a767 1
        if ( toggle(gen) .and. levels(gen) > 0 ) &
d838 1
a838 1
        if ( toggle(gen) .and. levels(gen) > 0 ) &
d841 1
a841 1
        if ( toggle(gen) .and. levels(gen) > 0 ) &
d845 1
a845 1
        if ( toggle(gen) .and. levels(gen) > 0 ) &
d848 1
a848 1
        if ( toggle(gen) .and. levels(gen) > 0 ) &
d1063 2
d2844 1
a2844 1
       "$Id: Fill.f90,v 2.398 2012/01/25 01:19:01 pwagner Exp $"
d2855 3
@


2.398
log
@Removed unused args to ..FromFile calls
@
text
@d111 2
a112 1
      & F_GEOCALTITUDEQUANTITY, F_GPHQUANTITY, F_HEIGHT, F_HDFVERSION, F_HEIGHTRANGE, &
d179 1
a179 1
    use L2PC_M, only: POPULATEL2PCBINBYNAME, LOADMATRIX, LOADVECTOR
d361 1
d363 1
d786 2
d796 11
a806 1
        if ( got ( f_matrix ) ) then
d808 1
a808 1
            & 'Cannot load both vector and matrix' )
d811 1
d1126 1
d1146 1
d1162 6
d1176 2
d1203 3
a1205 2
        & got(f_quantity), got(f_vector) /) ) )&
        & call Announce_error ( key, 0, 'Must supply either quantity or vector' )
d1216 15
d2840 1
a2840 1
       "$Id: Fill.f90,v 2.397 2012/01/18 20:38:59 vsnyder Exp $"
d2851 3
@


2.397
log
@Check consistency of covariance matrix and diagonal vector
@
text
@d1188 1
a1188 1
          & filetypestr, hdfversion, options, sdName, spread )
d1192 1
a1192 1
          & filetypestr, hdfversion, options, spread )
d2798 1
a2798 1
       "$Id: Fill.f90,v 2.396 2011/12/15 01:49:43 pwagner Exp $"
d2809 3
@


2.396
log
@Added sdName and /spread fields to DirectRead
@
text
@d88 1
a88 1
      & MISSINGFIELD, &
d870 3
d2798 1
a2798 1
       "$Id: Fill.f90,v 2.395 2011/11/04 00:28:18 pwagner Exp $"
d2809 3
@


2.395
log
@Added autoFill flag to Vector Spec to start it off with non-zero values in appropriated quantities
@
text
@d126 2
a127 2
      & F_SCALEINSTS, F_SCALERATIO, F_SCALESURFS, &
      & F_SCECI, F_SCVEL, F_SCVELECI, F_SCVELECR, F_SEED, F_SKIPMASK, &
d1118 2
d1126 2
d1156 7
d1185 1
a1185 1
          & filetypestr, hdfversion, options )
d1189 1
a1189 1
          & filetypestr, hdfversion, options )
d2795 1
a2795 1
       "$Id: Fill.f90,v 2.394 2011/10/07 00:06:02 pwagner Exp $"
d2806 3
@


2.394
log
@May dump Matrices, Hessians from Fill, Join
@
text
@d16 2
a17 3
  use MLSCommon, only: MLSFile_T, R8, RV, &
    & DEFAULTUNDEFINEDVALUE

d64 3
a66 3
    use FILLUTILS_1, only: FILLERROR, &
      & ADDGAUSSIANNOISE, APPLYBASELINE, COMPUTETOTALPOWER, &
      & EXTRACTSINGLECHANNEL, FILLCOVARIANCE, FROMGRID, &
d79 1
a79 1
      & WITHWMOTROPOPAuse, WITHBINRESULTS, WITHBOXCARFUNCTION, &
d81 1
a81 1
      & USINGLEASTSQUARES, OFFSETRADIANCEQUANTITY, RESETUNuseDRADIANCES, &
d83 1
a83 1
      & ANNOUNCE_ERROR, &
d98 2
a99 2
    use HESSIANMODULE_1, only: ADDHESSIANTODATABASE, CREATEEMPTYHESSIAN, HESSIAN_T, &
      & STREAMLINEHESSIAN
d102 1
a102 1
      & F_APRIORIPRECISION, F_ASPERCENTAGE, F_AVOIDBRIGHTOBJECTS, &
d111 1
a111 1
      & F_GEOCALTITUDEQUANTITY, F_GPHQUANTITY, F_HEIGHT, F_HEIGHTRANGE, &
d120 1
a120 1
      & F_OFFSETAMOUNT, F_ORBITINCLINATION, F_PHITAN, &
d167 1
a167 1
      & S_DIFF, S_DUMP, S_FILL, S_FILLCOVARIANCE, &
d189 1
a189 1
    use MLSL2OPTIONS, only: SKIPRETRIEVAL, SPECIALDUMPFILE
d194 1
d202 1
a202 1
    use OUTPUT_M, only: BLANKS, OUTPUT, &
d301 1
d412 1
d538 1
d614 2
a633 1

d635 3
d801 2
a802 1
          call Announce_Error ( key, no_Error_Code, 'Must supply either matrix or vector to adopt' )
d833 2
d844 2
a845 2
          if ( nsons(gson) > 1) &
            & gson = decoration(decoration(subtree(2,gson))) ! Now value of said argument
d871 2
a872 2
          call FillCovariance ( covariance, vectors, diagonal, lengthScale, fraction, &
            & invert )
d879 2
a880 2
          if ( nsons(gson) > 1) &
            & gson = decoration(decoration(subtree(2,gson))) ! Now value of said argument
d1105 77
d2694 72
d2784 1
a2784 1
       "$Id: Fill.f90,v 2.393 2011/06/16 20:52:22 vsnyder Exp $"
d2795 3
@


2.393
log
@Get codes for Announce_Error from FillUtils.  Add f_expr, but with a
noCodeFor error message -- to be implemented later.
@
text
@d57 27
a83 27
    use Allocate_Deallocate, only: test_allocate, Deallocate_Test
    use Chunks_m, only: MLSChunk_T
    use DestroyCommand_m, only: DestroyCommand
    use DumpCommand_m, only: BooleanFromAnyGoodRadiances, &
      & BooleanFromAnyGoodValues, &
      & BooleanFromCatchWarning, BooleanFromComparingQtys, BooleanFromFormula, &
      & DumpCommand, Skip
    use Expr_M, only: EXPR, EXPR_CHECK
    use FillUtils_1, only: fillError, &
      & addGaussianNoise, ApplyBaseline, ComputeTotalPower, &
      & ExtractSingleChannel, FillCovariance, FromGrid, &
      & FromL2GP, FromProfile, LOSVelocity, &
      & ChiSqChan, ChiSqMMaf, ChiSqMMif, ChiSqRatio, &
      & ColAbundance, FoldedRadiance, PhiTanWithRefraction, &
      & IWCFromExtinction, RHIFromOrToH2O, NoRadsPerMIF, &
      & RHIPrecisionFromOrToH2O, WithEstNoise, &
      & Hydrostatically, FromSplitSideband, GPHPrecision, &
      & FromIsotope, FromAsciiFile, RotateMagneticField, &
      & Explicit, FromL1B, &
      & FromL2AUX, UsingMagneticModel, &
      & FromInterpolatedQty, FromLosGrid, &
      & ByManipulation, ManipulateVectors, WithReflectorTemperature, &
      & WithReichlerWMOTP, &
      & WithWMOTropopause, WithBinResults, WithBoxcarFunction, &
      & StatusQuantity, QualityFromChisq, ConvergenceFromChisq, &
      & UsingLeastSquares, OffsetRadianceQuantity, ResetUnusedRadiances, &
      & ScaleOverlaps, SpreadChannelFill, TransferVectors, UncompressRadiance, &
d85 17
a101 17
      ! Codes for ANNOUNCE_ERROR:
      & badEstNoiseFill, badGeocAltitudeQuantity, badIsotopeFill, &
      & badlosGridFill, badlosVelFill, badRefGPHQuantity, &
      & badRefractFill, badTemperatureQuantity, bothFractionAndLength, &
      & missingField, &
      & needGeocAltitude, needH2O, needOrbitInclination, &
      & needTempREFGPH, noCodeFor, no_Error_Code, noExplicitValuesGiven, &
      & noSourceGridGiven, noSourceL2AUXGiven, noSourceL2GPGiven, &
      & notImplemented, notPlain, notSPD, &
      & wrongUnits
    use ForwardModelConfig, only: ForwardModelConfig_T
    use ForwardModelSupport, only: FillFwdModelTimings
    use GLOBAL_SETTINGS, only: BrightObjects
    use GriddedData, only: GriddedData_T
    use HessianModule_1, only: AddHessianToDatabase, CreateEmptyHessian, Hessian_T, &
      & StreamlineHessian
    ! We need many things from Init_Tables_Module.  First the fields:
d110 1
a110 1
      & F_EXPR, F_EXTINCTION, F_FIELDECR, F_FILE, F_FLAGS, F_FORCE, f_shape, &
d136 1
a136 1
    ! Now the literals:
d141 1
a141 1
      & L_cloudice, L_cloudextinction, &
d158 1
a158 1
      & L_REFLECTORTEMPMODEL, L_RESETUNUSEDRADIANCES, L_RHI, &
d163 1
a163 1
      & L_TNGTGEOCALT, L_UNCOMPRESSRADIANCE, L_VECTOR, L_VGRID, L_VMR, L_WMOTROPOPAUSE, &
d165 1
a165 1
    ! Now the specifications:
d173 9
a181 9
    ! Now some arrays
    use Intrinsic, only: lit_indices, &
      & PHYQ_Dimensionless, PHYQ_Invalid, PHYQ_Temperature, &
      & PHYQ_Time, PHYQ_Length, PHYQ_Angle, PHYQ_Profiles
    use L2GPData, only: L2GPData_T, COL_SPECIES_HASH, COL_SPECIES_KEYS
    use L2AUXData, only: L2AUXData_T
    use L2PC_m, only: POPULATEL2PCBINBYNAME, LOADMATRIX, LOADVECTOR
    use L2PCBins_m, only: FLUSHLOCKEDBINS
    use ManipulateVectorQuantities, only: DOHGRIDSMATCH, &
d183 19
a201 19
    use MatrixModule_1, only: AddToMatrixDatabase, CreateEmptyMatrix, &
      & GetActualMatrixFromDatabase, GetDiagonal, &
      & GetKindFromMatrixDatabase, GetFromMatrixDatabase, K_Plain, K_SPD, &
      & Matrix_Cholesky_T, Matrix_Database_T, Matrix_Kronecker_T, Matrix_SPD_T, &
      & Matrix_T, NullifyMatrix
    ! NOTE: If you ever want to include defined assignment for matrices, please
    ! carefully check out the code around the call to snoop.
    use MLSL2Options, only: SKIPRETRIEVAL, SPECIALDUMPFILE
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES, &
      & addPhaseToPhaseNames, fillTimings, finishTimings
    use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning, &
      & MLSMSG_Allocate, MLSMSG_Deallocate, MLSMessage, MLSMessageReset
    use MLSRandomNumber, only: mls_random_seed, MATH77_RAN_PACK
    use MLSStringLists, only: catLists, GetHashElement, &
      & NumStringElements, PutHashElement, &
      & StringElement, StringElementNum
    use MLSStrings, only: lowerCase
    use Molecules, only: L_H2O
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
d203 8
a210 8
      & revertoutput, switchOutput
    use PFAData_m, only: Flush_PFAData
    use QuantityTemplates, only: QuantityTemplate_T, ModifyQuantityTemplate
    use readAPriori, only: APrioriFiles
    use SnoopMLSL2, only: SNOOP
    use String_Table, only: get_string
    use SubsetModule, only: SETUPSUBSET, SETUPFLAGCLOUD, RESTRICTRANGE, UPDATEMASK
    use Time_M, only: Time_Now
d216 6
a221 6
    use VectorsModule, only: AddVectorToDatabase, &
      & CloneVectorQuantity, CreateVector, &
      & GetVectorQtyByTemplateIndex, &
      & ValidateVectorQuantity, Vector_T, &
      & VectorTemplate_T, VectorValue_T, M_Fill
    use VGridsDatabase, only: VGRIDS
d657 2
a658 1
          & GriddedDataBase=GriddedDataBase, FileDataBase=FileDataBase )
d2625 1
a2625 1
       "$Id: Fill.f90,v 2.392 2011/04/20 16:46:37 pwagner Exp $"
d2636 4
@


2.392
log
@Removed unused declaration
@
text
@d84 11
a94 1
      & ANNOUNCE_ERROR
d110 1
a110 1
      & F_EXTINCTION, F_FIELDECR, F_FILE, F_FLAGS, F_FORCE, f_shape, &
a241 45
    ! Error codes for "announce_error"
    integer, parameter :: No_Error_code = 0
    integer, parameter :: CantFromL2AUX = No_Error_code + 1
    integer, parameter :: CantFromL1B = cantFromL2AUX + 1

    ! Error codes for "Matrix" specification
    integer, parameter :: MissingField = cantFromL1B + 1

    ! More Error codes relating to Vector
    integer, parameter :: NumChansisZero = missingField + 1
    integer, parameter :: NoSourceGridGiven= numChansisZero + 1
    integer, parameter :: NoSourceL2GPGiven= noSourceGridGiven + 1
    integer, parameter :: NoSourceL2AUXGiven= noSourceL2GPGiven + 1
    integer, parameter :: NoExplicitValuesGiven= noSourceL2AUXGiven + 1
    integer, parameter :: InvalidExplicitFill = noExplicitValuesGiven + 1
    integer, parameter :: BadIsotopeFill = invalidExplicitFill + 1
    integer, parameter :: BadlosGridFill = badIsotopeFill + 1
    integer, parameter :: CantInterpolate3d = badlosGridFill + 1
    integer, parameter :: WrongUnits = CantInterpolate3d + 1

    ! Error codes resulting from FillCovariance
    integer, parameter :: NotSPD = WrongUnits + 1
    integer, parameter :: NotPlain = NotSPD + 1
    integer, parameter :: NotImplemented = notPlain + 1
    integer, parameter :: BothFractionAndLength = NotImplemented + 1

    ! Miscellaneous
    integer, parameter :: Miscellaneous_err = BothFractionAndLength + 1
    integer, parameter :: ErrorReadingL1B = miscellaneous_err + 1
    integer, parameter :: NeedTempREFGPH = errorReadingL1B + 1
    integer, parameter :: NeedH2O = needTempRefGPH + 1
    integer, parameter :: NeedOrbitInclination = needH2O + 1
    integer, parameter :: NeedGeocAltitude = needOrbitInclination + 1
    integer, parameter :: BadGeocAltitudeQuantity = needGeocAltitude + 1
    integer, parameter :: BadTemperatureQuantity = badGeocAltitudeQuantity + 1
    integer, parameter :: BadREFGPHQuantity = badTemperatureQuantity + 1
    integer, parameter :: NonConformingHydrostatic = badREFGPHQuantity + 1
    integer, parameter :: NoSpecialFill = nonConformingHydrostatic + 1
    integer, parameter :: BadlosVelFill = noSpecialFill + 1
    integer, parameter :: NotZetaForGrid = BadLosVelFill + 1
    integer, parameter :: BadEstNoiseFill = NotZetaForGrid + 1
    integer, parameter :: BadRefractFill = BadEstNoiseFill + 1
    integer, parameter :: MissingDataInGrid = BadRefractFill + 1
    integer, parameter :: EmptyGridForFill = MissingDataInGrid + 1

d1161 2
d1207 2
a1208 1
            & call Announce_Error ( key, 0, 'invalid heightRange: ' // trim(options) )
d2405 2
a2406 2
          & call Announce_Error ( key, &
          & no_error_code, 'Must supply channel or sourcequantity for spreadChannel fill' )
d2452 2
a2453 2
          & call Announce_Error ( key, &
          & no_error_code, 'Must supply sourcequantity for swapValues fill' )
d2624 1
a2624 1
       "$Id: Fill.f90,v 2.391 2011/03/22 23:47:54 pwagner Exp $"
d2635 3
@


2.391
log
@May now reshape qty template field while filling explicitly
@
text
@a526 1
    integer, dimension(2) :: UNITS
d2656 1
a2656 1
       "$Id: Fill.f90,v 2.390 2011/03/15 22:51:58 pwagner Exp $"
d2667 3
@


2.390
log
@May now modify quantity template fields with fill method
@
text
@d100 1
a100 1
      & F_EXTINCTION, F_FIELDECR, F_FILE, F_FLAGS, F_FORCE, &
d381 1
d498 1
d527 1
d585 1
d1209 2
d2167 1
a2170 3
        if ( .not. got ( f_c ) .and. .not. got( f_sourceQuantity ) ) &
          & call Announce_error ( key, no_Error_Code, &
          & 'Neither sourceQuantity nor c for new value(s) supplied' )
d2172 6
d2183 8
d2657 1
a2657 1
       "$Id: Fill.f90,v 2.389 2010/11/20 00:01:14 pwagner Exp $"
d2668 3
@


2.389
log
@May specifiy surfaces gap beyond which to zero out in Streamline
@
text
@d142 1
a142 1
      & L_MANIPULATE, L_MEAN, L_MOLCM2, &
d195 1
a195 1
    use QuantityTemplates, only: QuantityTemplate_T
d2160 17
d2639 1
a2639 1
       "$Id: Fill.f90,v 2.388 2010/08/06 23:08:48 pwagner Exp $"
d2650 3
@


2.388
log
@Pass Hessians, matrices to DumpCommand
@
text
@d1080 2
a1081 2
      use INIT_TABLES_MODULE, only: F_GEODANGLE, F_HESSIAN, F_SCALEHEIGHT, &
        & F_THRESHOLD
d1084 1
d1088 1
d1108 6
d1123 1
a1123 1
        & scaleHeight, geodAngle, threshold )
d2622 1
a2622 1
       "$Id: Fill.f90,v 2.387 2010/07/22 17:42:24 pwagner Exp $"
d2633 3
@


2.387
log
@Replaced method=special fills with unique names
@
text
@d709 9
d2614 1
a2614 1
       "$Id: Fill.f90,v 2.386 2010/07/06 16:06:06 pwagner Exp $"
d2625 3
@


2.386
log
@Better error checking in Transfer
@
text
@d150 1
a150 1
      & L_SECTIONTIMING, L_SPD, L_SPECIAL, L_SPREADCHANNEL, &
d1112 1
d1117 1
d1287 10
d1627 45
d1686 33
d2053 14
d2154 10
a2358 122
      case ( l_special ) ! -  Special fills for some quantities  -----
          ! Either multiplier = [a, b] or multiplier = b are possible
        if ( got(f_multiplier) ) then
          multiplier = UNDEFINED_VALUE
          do j=1, min(nsons(multiplierNode)-1, 2)
            call expr(subtree(j+1,multiplierNode),unitAsArray,valueAsArray)
            multiplier(j) = valueAsArray(1)
          end do
        else
          multiplier = 1.
        end if

        if ( DEEBUG ) then
          call output('Using multipliers: ', advance='no')
          call output(multiplier, advance='yes')
        end if

        select case ( quantity%template%quantityType )
        case ( l_losVel )
          if ( .not. any(got( &
          & (/f_tngtECI, f_scECI, f_scVel, f_scVelECI, f_scVelECR/) )) ) then
            call Announce_error ( key, badlosVelFill )
          else
            tngtECIQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(tngtECIVectorIndex), tngtECIQuantityIndex)
            scECIQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(scECIVectorIndex), scECIQuantityIndex)
            scVelQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(scVelVectorIndex), scVelQuantityIndex)
            call LOSVelocity ( key, quantity, tngtECIQuantity, &
              & scECIquantity, scVelQuantity )
          end if
        case ( l_columnAbundance )
          if ( .not. any(got( (/f_vmrQuantity, f_boundaryPressure/) )) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill column abundance'  )
          elseif ( .not. &
            & any( colmabunits == (/l_dobsonUnits, l_DU, l_molcm2/) ) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Wrong units to fill column abundance'  )
          else
            bndPressQty => GetVectorQtyByTemplateIndex( &
              & vectors(bndPressVctrIndex), bndPressQtyIndex)
            vmrQty => GetVectorQtyByTemplateIndex( &
              & vectors(vmrQtyVctrIndex), vmrQtyIndex)
            if ( got(f_unit) ) then
              ! Switch column species hash to explicit unit
              call get_string( lit_indices(colmabunits), explicitUnit, &
                & strip=.true. )
              call get_string( lit_indices(quantity%template%molecule), mol, &
                & strip=.true. )
              call PutHashElement( col_species_keys, col_species_hash, &
                & lowerCase(mol), ExplicitUnit, countEmpty=.true. )
            else
              call get_string( lit_indices(quantity%template%molecule), mol, &
                & strip=.true. )
              call GetHashElement (col_species_keys, &
                & col_species_hash, trim(lowercase(mol)), &
                & ExplicitUnit, .true.)
              if ( index(lowerCase(ExplicitUnit), 'd') > 0 ) colmabunits = l_DU
            end if
            call ColAbundance ( key, quantity, &
              & bndPressQty, vmrQty, colmAbUnits )
          end if
        case ( l_chiSQChan )
          if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill chi^2 on channels'  )
          else
            measQty => GetVectorQtyByTemplateIndex( &
              & vectors(measVectorIndex), measQtyIndex)
            modelQty => GetVectorQtyByTemplateIndex( &
              & vectors(modelVectorIndex), modelQtyIndex)
            noiseQty => GetVectorQtyByTemplateIndex( &
              & vectors(noiseVectorIndex), noiseQtyIndex)
            call ChiSqChan ( key, quantity, &
              & measQty, modelQty, noiseQty, &
              & dontMask, ignoreZero, ignoreNegative, multiplier )
          end if
        case ( l_chiSQMMaf )
          if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill chi^2 on MAFs'  )
          else
            measQty => GetVectorQtyByTemplateIndex( &
              & vectors(measVectorIndex), measQtyIndex)
            modelQty => GetVectorQtyByTemplateIndex( &
              & vectors(modelVectorIndex), modelQtyIndex)
            noiseQty => GetVectorQtyByTemplateIndex( &
              & vectors(noiseVectorIndex), noiseQtyIndex)
            call ChiSqMMaf ( key, quantity, &
              & measQty, modelQty, noiseQty, &
              & dontMask, ignoreZero, ignoreNegative, multiplier )
          end if
        case ( l_chiSQMMif )
          if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill chi^2 on MIFs'  )
          else
            measQty => GetVectorQtyByTemplateIndex( &
              & vectors(measVectorIndex), measQtyIndex)
            modelQty => GetVectorQtyByTemplateIndex( &
              & vectors(modelVectorIndex), modelQtyIndex)
            noiseQty => GetVectorQtyByTemplateIndex( &
              & vectors(noiseVectorIndex), noiseQtyIndex)
            call ChiSqMMif ( key, quantity, &
              & measQty, modelQty, noiseQty, &
              & dontMask, ignoreZero, ignoreNegative, multiplier )
          end if
        case ( l_noRadsPerMIF )
          if ( .not. got ( f_measurements ) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill noRadsPerMIF on MIFs'  )
          else
            measQty => GetVectorQtyByTemplateIndex( &
              & vectors(measVectorIndex), measQtyIndex)
            call NoRadsPerMif ( key, quantity, measQty, asPercentage )
          end if
        case default
          call Announce_error ( key, noSpecialFill )
        end select ! quantity types in special fill cases

d2605 1
a2605 1
       "$Id: Fill.f90,v 2.385 2010/07/01 00:49:19 pwagner Exp $"
d2616 3
@


2.385
log
@Transfer between vectors may now also manipulate
@
text
@d964 1
d1003 1
a1003 1
        else
d1006 3
d2613 1
a2613 1
       "$Id: Fill.f90,v 2.384 2010/05/19 23:06:45 pwagner Exp $"
d2624 3
@


2.384
log
@Shorten most Fill routine names
@
text
@d78 1
a78 1
      & ByManipulation, WithReflectorTemperature, &
d971 7
d984 2
d991 15
a1005 2
        call TransferVectors ( vectors(sourceVectorIndex), &
          & vectors(destinationVectorIndex), skipMask, interpolate )
d2609 1
a2609 1
       "$Id: Fill.f90,v 2.383 2010/05/19 17:53:19 pwagner Exp $"
d2620 3
@


2.383
log
@Removed unused stuff
@
text
@d67 16
a82 16
      & ExtractSingleChannel, FillCovariance, FillVectorQuantityFromGrid, &
      & FillVectorQuantityFromL2GP, FillVectorQtyFromProfile, FillLOSVelocity, &
      & FillChiSqChan, FillChiSqMMaf, FillChiSqMMif, FillChiSqRatio, &
      & FillColAbundance, FillFoldedRadiance, FillPhiTanWithRefraction, &
      & FillIWCFromExtinction, FillRHIFromH2O, FillNoRadsPerMIF, &
      & FillRHIPrecisionFromOrToH2O, FillVectorQtyWithEstNoise, &
      & FillVectorQtyHydrostatically, FillFromSplitSideband, FillGPHPrecision, &
      & FillVectorQtyFromIsotope, FillQuantityFromAsciiFile, RotateMagneticField, &
      & ExplicitFillVectorQuantity, FillVectorQuantityFromL1B, &
      & FillVectorQuantityFromL2AUX, FillQuantityUsingMagneticModel, &
      & FillQtyFromInterpolatedQty, FillQuantityFromLosGrid, &
      & FillQuantityByManipulation, FillWithReflectorTemperature, &
      & FillQtyWithReichlerWMOTP, &
      & FillQtyWithWMOTropopause, FillWithBinResults, FillWithBoxcarFunction, &
      & FillStatusQuantity, FillQualityFromChisq, FillConvergenceFromChisq, &
      & FillUsingLeastSquares, OffsetRadianceQuantity, ResetUnusedRadiances, &
d234 2
a235 2
    integer, parameter :: CantFillFromL2AUX = No_Error_code + 1
    integer, parameter :: CantFillFromL1B = cantFillFromL2AUX + 1
d238 1
a238 1
    integer, parameter :: MissingField = cantFillFromL1B + 1
d240 1
a240 1
    ! More Error codes relating to FillVector
d356 1
a356 1
    !                                     -- for FillCovariance
d361 1
a361 1
    !                                     -- for FillCovariance
d508 1
a508 1
    !                                     -- for FillCovariance
d849 1
a849 1
      case ( s_FillCovariance ) ! ===============  FillCovariance  =====
d887 1
a887 1
      case ( s_FillDiagonal ) ! ===============  FillDiagonal  =====
d1533 1
a1533 1
          call FillQuantityFromASCIIFile ( key, quantity, filename, badRange )
d1535 1
a1535 1
          call FillQuantityFromASCIIFile ( key, quantity, filename )
d1570 1
a1570 1
            call FillWithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
d1573 1
a1573 1
            call FillUsingLeastSquares ( key, quantity, sourceQuantity, ptanQuantity, &
d1586 1
a1586 1
        call FillWithBoxcarFunction ( key, quantity, sourceQuantity, width, &
d1600 1
a1600 1
        call FillChiSqRatio ( key, &
d1618 1
a1618 1
        call FillConvergenceFromChisq ( key, quantity, sourceQuantity, scale )
d1634 1
a1634 1
        call FillVectorQtyWithEstNoise ( &
d1641 1
a1641 1
        call ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
d1663 1
a1663 1
        call FillFoldedRadiance ( quantity, lsb, usb, lsbFraction, usbFraction, key )
d1724 1
a1724 1
        call FillGPHPrecision ( key, quantity, tempPrecisionQuantity, &
d1731 1
a1731 1
        call FillVectorQuantityFromGrid &
d1740 1
a1740 1
          call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), &
d1755 1
a1755 1
          call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), &
d1758 1
a1758 1
          call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), &
d1765 1
a1765 1
        call FillVectorQuantityFromL2GP &
d1773 1
a1773 1
        call FillVectorQuantityFromL2AUX(quantity,l2auxDatabase(l2auxIndex),errorCode)
d1801 1
a1801 1
              call FillRHIFromH2O ( key, quantity, &
d1838 1
a1838 1
            call FillRHIPrecisionFromOrToH2O ( key, quantity, &
d1893 1
a1893 1
        call FillVectorQtyHydrostatically ( key, quantity, temperatureQuantity, &
d1905 1
a1905 1
        call FillVectorQtyFromIsotope ( quantity, sourceQuantity, &
d1932 1
a1932 1
              call FillIWCFromExtinction ( quantity, &
d1958 1
a1958 1
            call FillQuantityByManipulation ( tempswapquantity, aQuantity, bQuantity, &
d1962 1
a1962 1
            call ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
d1970 1
a1970 1
            call FillQuantityByManipulation ( quantity, aQuantity, bQuantity, &
d1980 1
a1980 1
            call FillQuantityByManipulation ( tempswapquantity, aQuantity, bQuantity, &
d1983 1
a1983 1
            call ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
d1991 1
a1991 1
            call FillQuantityByManipulation ( quantity, aQuantity, bQuantity, &
d2000 1
a2000 1
        call ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
d2010 1
a2010 1
          call FillQuantityUsingMagneticModel ( quantity, gphQuantity, key )
d2037 1
a2037 1
          call FillTimings ( quantity%values(:,1), 'phases', 'all', .true. )
d2046 1
a2046 1
          call FillTimings ( quantity%values(:,1), 'sections', 'all', .true. )
d2064 1
a2064 1
          call FillVectorQtyFromProfile ( quantity, valuesNode, &
d2068 1
a2068 1
          call FillVectorQtyFromProfile ( quantity, valuesNode, &
d2098 1
a2098 1
          call FillPhiTanWithRefraction ( key, quantity, h2oQuantity, &
d2103 1
a2103 1
        call FillWithReflectorTemperature ( key, quantity, phiZero, termsNode )
d2117 1
a2117 1
        call FillQuantityFromLosGrid ( key, Quantity, losQty, &
d2141 1
a2141 1
              call FillRHIFromH2O ( key, quantity, &
d2155 1
a2155 1
        call FillQualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )
d2190 1
a2190 1
            call FillRHIPrecisionFromOrToH2O ( key, quantity, &
d2248 1
a2248 1
            call FillLOSVelocity ( key, quantity, tngtECIQuantity, &
d2280 1
a2280 1
            call FillColAbundance ( key, quantity, &
d2294 1
a2294 1
            call FillChiSqChan ( key, quantity, &
d2309 1
a2309 1
            call FillChiSqMMaf ( key, quantity, &
d2324 1
a2324 1
            call FillChiSqMMif ( key, quantity, &
d2335 1
a2335 1
            call FillNoRadsPerMif ( key, quantity, measQty, asPercentage )
d2363 1
a2363 1
        call FillFromSplitSideband ( quantity, sourceQuantity, &
d2382 1
a2382 1
          if ( MissingGMAO ) call ExplicitFillVectorQuantity ( quantity, &
d2408 1
a2408 1
          call FillStatusQuantity ( key, quantity, &
d2426 1
a2426 1
            call FillQtyFromInterpolatedQty ( tempswapquantity, sourceQuantity, &
d2428 1
a2428 1
            call FillQtyFromInterpolatedQty ( sourceQuantity, quantity, &
d2430 1
a2430 1
            call FillQtyFromInterpolatedQty ( quantity, tempswapquantity, &
d2468 1
a2468 1
          call FillQtyFromInterpolatedQty ( quantity, sourceQuantity, &
d2475 1
a2475 1
            call FillQtyFromInterpolatedQty ( quantity, sourceQuantity, &
d2556 1
a2556 1
          call FillQtyWithWMOTropopause ( quantity, &
d2559 1
a2559 1
          call FillQtyWithReichlerWMOTP ( quantity, &
d2587 1
a2587 1
       "$Id: Fill.f90,v 2.382 2010/04/28 16:24:11 pwagner Exp $"
d2598 3
d2632 1
a2632 1
! No longer sets undefined values in FillRHI to -999.99
d2713 1
a2713 1
! Optional test, tweaks to FillChiSqRatio
d2764 1
a2764 1
! Use HFTI instead of Cholesky for FillUsingLeastSquares, for stability
d2822 1
a2822 1
! Use of single arg options in ExplicitFillVectorQuantity replaces three
d2837 1
a2837 1
! Added forgiveZeros handling to FillCovariance for efficiency.
d2856 1
a2856 1
! Removed buggy, unused FillColAbundance
d2899 1
a2899 1
! Moved FillWithCombinedChannels into ManipulateVectorQuantitites
d3001 1
a3001 1
! Made FillCovariance (temporarily?) fill both sides of the digaonal (in
d3029 1
a3029 1
! add new flag ignoreGeolocation in subroutine FillVectorQuantityFromL2GP
d3074 1
a3074 1
! Cosmetic and superficial changes to FillFromSplitSideband
d3102 1
a3102 1
! Added a bit more intelligence to FillCovariance
d3144 1
a3144 1
! Always sets errorCode to 0 in return from FillVectorQuantityFromL2AUX
d3208 1
a3208 1
! Better handling of missing length scale in FillCovariance
d3262 1
a3262 1
! Made the checking in FillQuantityByManipulation a little more lenient
d3361 1
a3361 1
! Tidied up FillVectorQtyFromProfile
d3410 1
a3410 1
! FillRHI testing begun; incomplete
d3416 1
a3416 1
! Fleshed out FillRHIFromH2O; untested yet
d3419 1
a3419 1
! Added FillRHI from h2oquantity (just a placeholder)
d3429 1
a3429 1
! SOme new checks added to FillLOSVelocity
d3477 1
a3477 1
! add FillDiagonal
d3579 1
a3579 1
! some fixes for FillQuantityFromLOS
d3585 1
a3585 1
! fix bugs in FillQuantityFromLos
d3738 1
a3738 1
! Completed FillOL2AUXData; changed squeeze, nearby
d3741 1
a3741 1
! Added FillOL2AUXVector
@


2.382
log
@May specify instances range in explicit Fill
@
text
@d90 1
a90 1
      & NullifyHessian, StreamlineHessian
a392 1
    type (Hessian_T) :: Hessian         ! A Hessian to create
d2587 1
a2587 1
       "$Id: Fill.f90,v 2.381 2010/04/22 23:36:46 pwagner Exp $"
d2598 3
@


2.381
log
@May fill num rads/MIF as a percentage
@
text
@d588 1
d1644 1
a1644 1
          & options=options(1:1) )
d1965 1
a1965 1
              & options=options(1:1), extraQuantity=tempswapquantity )
d1986 1
a1986 1
              & options=options(1:1), extraQuantity=tempswapquantity )
d2003 1
a2003 1
          & azEl=.true. )
d2385 1
a2385 1
            & options='-v' )
d2588 1
a2588 1
       "$Id: Fill.f90,v 2.380 2010/04/13 01:43:09 vsnyder Exp $"
d2599 3
@


2.380
log
@Move FlushLockedBins from LinearizedForwardModel_m to L2PCBins_m
@
text
@d93 1
a93 1
      & F_APRIORIPRECISION, F_AVOIDBRIGHTOBJECTS, &
d335 1
d569 1
d1106 2
d2335 1
a2335 1
            call FillNoRadsPerMif ( key, quantity, measQty )
d2587 1
a2587 1
       "$Id: Fill.f90,v 2.379 2010/03/26 23:16:56 vsnyder Exp $"
d2598 3
@


2.379
log
@Add Threshold to StreamlineHessian
@
text
@d170 1
a170 1
    use LinearizedForwardModel_m, only: FLUSHLOCKEDBINS
d2583 1
a2583 1
       "$Id: Fill.f90,v 2.378 2010/03/25 01:50:25 vsnyder Exp $"
d2594 3
@


2.378
log
@Make sure GeodAngle and ScaleHeight get values in StreamlineHessian
@
text
@d102 2
a103 2
      & F_GEOCALTITUDEQUANTITY, F_GEODANGLE, F_GPHQUANTITY, F_HEIGHT, F_HEIGHTRANGE, &
      & F_HESSIAN, F_HIGHBOUND, F_H2OQUANTITY, F_H2OPRECISIONQUANTITY, &
d116 1
a116 1
      & F_RHIPRECISIONQUANTITY, F_RHIQUANTITY, F_ROWS, F_SCALE, F_SCALEHEIGHT, &
a383 1
    real(r8) :: GEODANGLE               ! For StreamlineHessian
a487 1
    real(r8) :: SCALEHEIGHT             ! Scale height for StreamlineHessian
a855 1
          got(fieldIndex)=.true.
a890 1
          got(fieldIndex)=.true.
d1020 1
a1020 24
        geodAngle = -1.0 ! means "not specified"
        scaleHeight = -1.0 ! means "not specified"
        do j = 2, nsons(key)
          gson = subtree(j,key) ! The argument
          fieldIndex = get_field_id(gson)
          got(fieldIndex)=.true.
          select case ( fieldIndex )
          case ( f_hessian )
            hessianIndex = -decoration(decoration(subtree(2,gson)))
          case ( f_scaleHeight )
            call expr_check ( subtree(2,gson), unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            scaleHeight = valueAsArray(1)
          case ( f_geodAngle )
            call expr_check ( subtree(2,gson), unitAsArray, valueAsArray, &
              & (/PHYQ_Angle/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
            geodAngle = valueAsArray(1)
          end select
        end do
        call StreamlineHessian ( hessians ( hessianIndex ), scaleHeight, geodAngle )
d1041 41
a1081 1
    ! ------------------------------------------------- fillCommand ------
d1087 1
d2583 1
a2583 1
       "$Id: Fill.f90,v 2.377 2010/02/25 18:37:51 pwagner Exp $"
d2594 3
@


2.377
log
@Adds support for new Hessian data type
@
text
@d1024 2
d2569 1
a2569 1
       "$Id: Fill.f90,v 2.376 2009/10/26 17:11:28 pwagner Exp $"
d2580 3
@


2.376
log
@Added Diff command to be used like Dump in l2cf
@
text
@d51 1
a51 1
    & Vectors, QtyTemplates, Matrices, L2GPDatabase, L2AUXDatabase, &
d89 2
d102 2
a103 2
      & F_GEOCALTITUDEQUANTITY, F_GPHQUANTITY, F_HEIGHT, F_HEIGHTRANGE, &
      & F_HIGHBOUND, F_H2OQUANTITY, F_H2OPRECISIONQUANTITY, &
d116 1
a116 1
      & F_RHIPRECISIONQUANTITY, F_RHIQUANTITY, F_ROWS, F_SCALE, &
d160 2
a161 2
      & S_LOAD, S_MATRIX,  S_NEGATIVEPRECISION, S_PHASE, S_POPULATEL2PCBIN, &
      & S_REEVALUATE, S_RESTRICTRANGE, S_SKIP, S_SNOOP, &
d221 1
d384 1
d393 2
d489 1
d691 26
d1023 26
d2567 1
a2567 1
       "$Id: Fill.f90,v 2.375 2009/08/24 20:13:47 pwagner Exp $"
d2578 3
@


2.375
log
@May Fill H2O precision from RHI precision
@
text
@d156 1
a156 1
      & S_DUMP, S_FILL, S_FILLCOVARIANCE, &
d672 1
a672 1
      case ( s_dump ) ! ============================== Dump ==========
d2508 1
a2508 1
       "$Id: Fill.f90,v 2.374 2009/06/23 18:46:18 pwagner Exp $"
d2519 3
@


2.374
log
@Prevent Intel from optimizing ident string away
@
text
@d72 1
a72 1
      & FillRHIPrecisionFromH2O, FillVectorQtyWithEstNoise, &
d114 1
a114 1
      & F_RHIQUANTITY, F_ROWS, F_SCALE, &
d134 2
a135 2
      & L_GEOCALTITUDE, L_GEODALTITUDE, L_GPHPRECISION, L_GRIDDED, L_H2OFROMRHI, &
      & L_HYDROSTATIC, L_ISOTOPE, &
d308 1
d479 2
d1263 3
d1730 38
d2111 1
a2111 1
            call FillRHIPrecisionFromH2O ( key, quantity, &
d2508 1
a2508 1
       "$Id: read_apriori.f90 is it here $"
d2519 3
@


2.373
log
@Manipulation Fills can be restricted by height and heightRange
@
text
@d1621 1
a1621 1
            & 'manipulation not recognized' )
d2461 1
a2462 1
!---------------------------- RCS Ident Info -------------------------------
d2464 1
a2464 1
       "$Id: Fill.f90,v 2.372 2009/04/28 20:02:50 pwagner Exp $"
a2465 1
!---------------------------------------------------------------------------
d2467 1
a2467 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2469 1
a2469 1

d2475 3
@


2.372
log
@No longer sets undefined values in FillRHI to -999.99
@
text
@d587 1
d1100 9
d1148 1
a1148 1
        case ( f_heightRange, f_manipulation )
a1555 8
        options = ' '
        ! If heightRange field was present, it should have been one of
        ! 'a[bove]' meaning fill heights above supplied value
        ! 'b[elow]' meaning fill heights below supplied value
        if ( got ( f_heightRange ) ) &
          & call get_string ( manipulation, options, strip=.true. )
        if ( index(' ab', options(1:1)) < 1 ) &
          & call Announce_Error ( key, 0, 'invalid heightRange: ' // trim(options) )
d1827 3
d1831 41
a1871 8
          call FillQuantityByManipulation ( quantity, aQuantity, bQuantity, &
            & manipulation, key, &
            & force, spreadflag, dontSumHeights, dontSumInstances, &
            & c )
        else
          call FillQuantityByManipulation ( quantity, aQuantity, bQuantity, &
            & manipulation, key, &
            & force, spreadflag, dontSumHeights, dontSumInstances )
d2464 1
a2464 1
       "$Id: Fill.f90,v 2.371 2009/04/16 21:55:05 pwagner Exp $"
d2476 3
@


2.371
log
@/exact keyword in status Fill to fix radiance bug
@
text
@d1717 1
a1717 1
                & .true., &   ! Mark Undefined values?
d1983 1
a1983 1
                & .true., &   ! Mark Undefined values?
d2426 1
a2426 1
       "$Id: Fill.f90,v 2.370 2009/04/13 20:45:57 pwagner Exp $"
d2438 3
@


2.370
log
@heightRange in explicit Fill can fill above or below specified height
@
text
@d97 1
a97 1
      & F_ECRTOFOV, F_EARTHRADIUS, F_EXCLUDEBELOWBOTTOM, F_EXPLICITVALUES, &
d363 1
d568 1
d1061 2
d2249 1
a2249 1
            & minValue, maxValue, heightNode, additional, force )
d2426 1
a2426 1
       "$Id: Fill.f90,v 2.369 2009/03/05 18:37:59 pwagner Exp $"
d2438 3
@


2.369
log
@May specifiy height, channel with explicit Fill
@
text
@d99 3
a101 2
      & F_FRACTION, F_FROMPRECISION, F_GEOCALTITUDEQUANTITY, F_GPHQUANTITY, &
      & F_HEIGHT, F_HIGHBOUND, F_H2OQUANTITY, F_H2OPRECISIONQUANTITY, &
d379 2
a392 2
    integer :: GLOBALUNIT               ! To go into the vector
    character(len=16) :: GLStr          ! geo. loc. in manipulation='..'
d451 1
d1134 1
a1134 1
        case ( f_manipulation )
d1542 8
d1551 2
a1552 1
          & vectors(vectorIndex)%globalUnit, dontmask, channel, heightNode )
d2422 1
a2422 1
       "$Id: Fill.f90,v 2.368 2008/12/18 21:14:05 pwagner Exp $"
d2434 3
@


2.368
log
@May now dump an l2pc or allL2PCs (use with caution)
@
text
@d559 1
a566 1
      centerVertically = .false.
d570 1
a570 1
      MissingGMAO = .false.
d581 1
a602 1
      heightNode = 0
d1541 1
a1541 1
          & vectors(vectorIndex)%globalUnit, dontmask )
d1576 3
d1825 2
a1826 1
          & vectors(vectorIndex)%globalUnit, dontmask, azEl=.true. )
d2207 2
a2208 1
            & valuesNode, .true., phyq_Invalid, .true., options='-v' )
d2234 1
a2234 1
            & minValue, maxValue, heightNode, additional )
d2411 1
a2411 1
       "$Id: Fill.f90,v 2.367 2008/11/06 21:50:46 pwagner Exp $"
d2423 3
@


2.367
log
@Fill method swapValues swaps values between two quantities
@
text
@d205 1
a205 1
      & GetVectorQtyByTemplateIndex, NullifyVectorValue, &
d674 1
a674 1
          & GriddedDataBase=GriddedDataBase )
d2406 1
a2406 1
       "$Id: Fill.f90,v 2.366 2008/09/24 16:46:37 livesey Exp $"
d2418 3
@


2.366
log
@Tidy up handling of ptan in profile fill
@
text
@d57 1
a57 1
    use Allocate_Deallocate, only: Test_Allocate
d137 1
a137 2
      & L_LOSVEL, &
      & L_LSGLOBAL, L_LSLOCAL, L_LSWEIGHTED, &
d139 2
a140 2
      & L_MANIPULATE, L_MEAN, L_MOLCM2, L_NEGATIVEPRECISION, &
      & L_NONE, &
d146 3
a148 5
      & L_RHIFROMH2O, L_RHIPRECISIONFROMH2O, L_ROTATEFIELD, &
      & L_SCALEOVERLAPS, &
      & L_SECTIONTIMING, &
      & L_SPD, L_SPECIAL, L_SPREADCHANNEL, &
      & L_SPLITSIDEBAND, L_STATUS, &
d204 2
a205 2
      & CreateVector, &
      & GetVectorQtyByTemplateIndex, &
d313 1
d2232 39
d2406 1
a2406 1
       "$Id: Fill.f90,v 2.365 2008/09/19 23:55:05 pwagner Exp $"
d2418 3
@


2.365
log
@May now Destroy GriddedData
@
text
@d1882 3
d1888 1
a1888 1
            & logSpace=logSpace )
d1892 1
a1892 1
            & ptan=ptanQuantity )
d2369 1
a2369 1
       "$Id: Fill.f90,v 2.364 2008/09/16 22:29:05 pwagner Exp $"
d2381 3
@


2.364
log
@pass optional field ptanQuantity to profile, vector methods
@
text
@d872 1
a872 1
        call destroyCommand ( key, matrices, vectors )
d2366 1
a2366 1
       "$Id: Fill.f90,v 2.363 2008/08/14 20:59:00 pwagner Exp $"
d2370 1
d2378 3
@


2.363
log
@/interpolate now possible field in Transfer command
@
text
@d1876 6
d1884 2
a1885 1
            & instancesNode, vectors(vectorIndex)%globalUnit, dontMask, logSpace=logSpace )
d1888 2
a1889 1
            & instancesNode, vectors(vectorIndex)%globalUnit, dontMask )
d2244 6
a2249 1
        if ( quantity%template%name /= sourceQuantity%template%name ) then
d2366 1
a2366 1
       "$Id: Fill.f90,v 2.362 2008/05/28 21:52:48 pwagner Exp $"
d2377 3
@


2.362
log
@geo location Fill method to fill chunk numbers[maf]
@
text
@d922 1
d938 2
d946 1
a946 1
          & vectors(destinationVectorIndex), skipMask )
d2353 1
a2353 1
       "$Id: Fill.f90,v 2.361 2008/04/26 00:40:07 livesey Exp $"
d2364 3
@


2.361
log
@Added total power stuff
@
text
@d132 1
a132 1
      & L_FWDMODELTIMING, L_FWDMODELMEAN, L_FWDMODELSTDDEV, &
d393 1
d1568 35
d2350 1
a2350 1
       "$Id: Fill.f90,v 2.360 2008/04/11 01:17:22 livesey Exp $"
d2361 3
@


2.360
log
@Added uncompressRadiance fill
@
text
@d66 1
a66 1
      & addGaussianNoise, ApplyBaseline, &
d119 1
a119 1
      & F_TEMPLATE, F_TNGTECI, F_TERMS, &
d157 2
a158 1
      & S_CATCHWARNING, S_COMPARE, S_DESTROY, S_DUMP, S_FILL, S_FILLCOVARIANCE, &
d316 1
d512 2
d660 2
d1310 3
d2218 15
a2232 1
        call UncompressRadiance ( key, quantity, termsNode )
d2314 1
a2314 1
       "$Id: Fill.f90,v 2.359 2007/12/07 01:13:39 pwagner Exp $"
d2325 3
@


2.359
log
@Lets us catch warnings and assign to runtime Booleans
@
text
@d83 2
a84 1
      & ScaleOverlaps, SpreadChannelFill, TransferVectors, ANNOUNCE_ERROR
d153 1
a153 1
      & L_TNGTGEOCALT, L_VECTOR, L_VGRID, L_VMR, L_WMOTROPOPAUSE, &
d2208 3
d2291 1
a2291 1
       "$Id: Fill.f90,v 2.358 2007/11/15 22:53:16 pwagner Exp $"
d2302 3
@


2.358
log
@May set runtimeBooleans by anyGood.., Compare, Reevaluate commands
@
text
@d61 2
a62 1
      & BooleanFromAnyGoodValues, BooleanFromComparingQtys, BooleanFromFormula, &
d156 1
a156 1
      & S_COMPARE, S_DESTROY, S_DUMP, S_FILL, S_FILLCOVARIANCE, &
d181 2
a182 2
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning, &
      & MLSMSG_Allocate, MLSMSG_Deallocate
d604 2
d651 2
d975 1
a975 1
    end do
d2287 1
a2287 1
       "$Id: Fill.f90,v 2.357 2007/11/05 18:38:09 pwagner Exp $"
d2298 3
@


2.357
log
@May Skip remaining lines in Fill, Join, Retrieve sections depending on Boolean
@
text
@d60 3
a62 1
    use DumpCommand_m, only: DumpCommand, Skip
d154 6
a159 4
    use INIT_TABLES_MODULE, only: S_LOAD, S_DESTROY, S_DUMP, S_FILL, S_FILLCOVARIANCE, &
      & S_FILLDIAGONAL, S_FLUSHL2PCBINS, S_FLUSHPFA, S_MATRIX,  S_NEGATIVEPRECISION, &
      & S_PHASE, S_POPULATEL2PCBIN, S_SKIP, S_SNOOP, S_TIME, &
      & S_TRANSFER, S_VECTOR, S_SUBSET, S_FLAGCLOUD, S_RESTRICTRANGE, S_UPDATEMASK
d642 11
d2282 1
a2282 1
       "$Id: Fill.f90,v 2.356 2007/09/27 22:00:45 pwagner Exp $"
d2293 3
@


2.356
log
@Much moved into new FillUtils_1 module; Intel compiler can now optimize
@
text
@d51 1
a51 1
    & Vectors, QtyTemplates , Matrices, L2GPDatabase, L2AUXDatabase, &
d60 1
a60 1
    use DumpCommand_m, only: DumpCommand
d154 1
a154 1
      & S_PHASE, S_POPULATEL2PCBIN, S_SNOOP, S_TIME, &
d456 1
a456 1
    logical :: QUADRATURE               ! Apply baseline in quadarture
d650 3
d1740 10
a1749 3
        call FillQuantityByManipulation ( quantity, aQuantity, bQuantity, c, &
          & manipulation, key, &
          & force, spreadflag, dontSumHeights, dontSumInstances )
d2267 1
a2267 1
       "$Id: Fill.f90,v 2.355 2007/08/27 23:56:34 pwagner Exp $"
d2278 3
@


2.355
log
@/spread flag now affects statistical manipulation Fills
@
text
@d16 1
a16 1
  use MLSCommon, only: MLSFile_T, R4, R8, RM, RV, &
a44 1
  logical, parameter :: DONTPAD = .false.
a45 7

  type arrayTemp_T
     real(rv), dimension(:,:), pointer :: VALUES => NULL() ! shaped like a
  end type arrayTemp_T
  
  type(arrayTemp_T), dimension(:), save, pointer :: primitives => null()

d57 1
a57 1
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate
d61 20
a80 1
    use Expr_M, only: EXPR, EXPR_CHECK, GetIndexFlagsFromList
d84 1
a84 1
    use GriddedData, only: GriddedData_T, WrapGriddedData
d122 1
a122 1
      & L_BOUNDARYPRESSURE, L_BOXCAR, L_CHISQBINNED, L_CHISQCHAN, &
d124 1
a124 1
      & L_cloudice, L_cloudextinction, L_cloudInducedRADIANCE, &
a125 1
      & l_dnwt_flag, l_dnwt_chiSqMinNorm, l_dnwt_chiSqNorm, l_dnwt_chiSqRatio, &
d127 1
a127 1
      & L_ECRTOFOV, L_ESTIMATEDNOISE, L_EXPLICIT, L_EXTRACTCHANNEL, L_FOLD, &
d129 2
a130 2
      & L_GEOCALTITUDE, L_GEODALTITUDE, L_GPH, L_GPHPRECISION, L_GRIDDED, L_H2OFROMRHI, &
      & L_HEIGHT, L_HYDROSTATIC, L_ISOTOPE, L_ISOTOPERATIO, &
d132 2
a133 2
      & L_L1B, L_L1BMAFBASELINE, L_L1BMIF_TAI, L_L2GP, L_L2AUX, &
      & L_LIMBSIDEBANDFRACTION, L_LOSVEL, &
d135 4
a138 4
      & L_MAGAZEL, L_MAGNETICFIELD, L_MAGNETICMODEL, &
      & L_MANIPULATE, L_MAX, L_MEAN, L_MIN, L_MOLCM2, L_NEGATIVEPRECISION, &
      & L_NOISEBANDWIDTH, L_NONE, &
      & L_NORADSPERMIF, L_OFFSETRADIANCE, L_ORBITINCLINATION, &
d140 3
a142 3
      & L_PLAIN, L_PRESSURE, L_PROFILE, L_PTAN,  L_QUALITY, &
      & L_RADIANCE, L_RECTANGLEFROMLOS, L_REFGPH, L_REFRACT, &
      & L_REFLECTORTEMPMODEL, L_REFLTEMP, L_RESETUNUSEDRADIANCES, L_RHI, &
d144 1
a144 1
      & L_SCALEOVERLAPS, L_SCECI, L_SCGEOCALT, L_SCVEL, L_SCVELECI, L_SCVELECR, &
d146 3
a148 3
      & L_SINGLECHANNELRADIANCE, L_SPD, L_SPECIAL, L_SPREADCHANNEL, &
      & L_SPLITSIDEBAND, L_STATUS, L_SYSTEMTEMPERATURE, &
      & L_TEMPERATURE, L_TNGTECI, L_TNGTGEODALT, &
d150 1
a150 1
      & L_XYZ, L_ZETA
d159 1
a159 3
      & PHYQ_Time, PHYQ_Length, PHYQ_Pressure, PHYQ_Zeta, PHYQ_Angle, PHYQ_Profiles
    use L1BData, only: DeallocateL1BData, Dump, GetL1BFile, L1BData_T, &
      & PRECISIONSUFFIX, ReadL1BData, AssembleL1BQtyName
d164 2
a165 4
    use L3ASCII, only: L3ASCII_INTERP_FIELD
    use ManipulateVectorQuantities, only: DOFGRIDSMATCH, DOHGRIDSMATCH, &
      & DOVGRIDSMATCH, DOQTYSDESCRIBESAMETHING, FILLWITHCOMBINEDCHANNELS
    use MatrixModule_0, only: Sparsify, MatrixInversion
d167 2
a168 2
      & Dump, GetActualMatrixFromDatabase, GetDiagonal, &
      & FindBlock, GetKindFromMatrixDatabase, GetFromMatrixDatabase, K_Plain, K_SPD, &
d170 1
a170 1
      & Matrix_T, NullifyMatrix, UpdateDiagonal
a172 1
    use MLSFiles, only: GetMLSFileByType
d177 3
a179 8
      & MLSMSG_Allocate, MLSMSG_Deallocate, MLSMessageCalls
    use MLSNumerics, only: InterpolateValues, Hunt
    use MLSRandomNumber, only: drang, mls_random_seed, MATH77_RAN_PACK
    use MLSSets, only: FindFirst, FindLast
    use MLSSignals_m, only: GetFirstChannel, GetSignalName, GetModuleName, IsModuleSpacecraft, &
      & GetSignal, Signal_T
    use MLSStats1, only: MLSMIN, MLSMAX, MLSMEAN, MLSMEDIAN, MLSRMS, MLSSTDDEV
    use MLSStringLists, only: catLists, GetHashElement, GetStringElement, &
d181 2
a182 2
      & ReplaceSubString, StringElement, StringElementNum, switchDetail
    use MLSStrings, only: lowerCase, SplitNest
d185 1
a185 1
    use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, outputNamedValue, &
d188 1
a188 1
    use QuantityTemplates, only: Epoch, QuantityTemplate_T
a189 2
    use RHIFromH2O, only: RHIFromH2O_Factor, RHIPrecFromH2O
    use ScanModelModule, only: GetBasisGPH, Get2DHydrostaticTangentPressure, GetGPHPrecision
d191 1
a191 1
    use String_Table, only: Display_String, get_string
d194 1
a194 1
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
a198 1
    use UNITS, only: Deg2Rad, Rad2Deg
d200 2
a201 3
      & ClearUnderMask, CopyVector, CreateMask, CreateVector, &
      & DestroyVectorInfo, Dump, &
      & GetVectorQtyByTemplateIndex, isVectorQtyMasked, MaskVectorQty, &
d203 2
a204 2
      & VectorTemplate_T, VectorValue_T, M_Fill, M_LinAlg, M_Cloud
    use VGridsDatabase, only: VGRIDS, GETUNITFORVERTICALCOORDINATE
a221 1
    integer :: ERROR
d530 1
a530 1
    error = 0
d715 1
a715 1
        error = max(error,status)
d778 1
a778 1283
        ! Now we're on actual Fill instructions.
        ! Loop over the instructions to the Fill command
        BOMask = 0
        AvoidObjects = ' '
        do j = 2, nsons(key)
          gson = subtree(j,key) ! The argument
          fieldIndex = get_field_id(gson)
          if ( nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
          got(fieldIndex)=.TRUE.
          select case ( fieldIndex )
          case ( f_a )
            aVecIndex = decoration(decoration(subtree(1,gson)))
            aQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_additional )
            additional = get_boolean ( gson )
          case ( f_allowMissing )
            allowMissing = get_boolean ( gson )
          case ( f_aprioriPrecision )
            aprPrecVctrIndex = decoration(decoration(subtree(1,gson)))
            aprPrecQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_avoidBrightObjects )
            call get_string( sub_rosa(gson), extraObjects, strip=.true. )
            avoidObjects = catLists( avoidObjects, extraObjects )
          case ( f_b )
            bVecIndex = decoration(decoration(subtree(1,gson)))
            bQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_badRange )
            call expr ( gson , unitAsArray, valueAsArray )
            badRange = valueAsArray
          case ( f_baselineQuantity )
            baselineVctrIndex = decoration(decoration(subtree(1,gson)))
            baselineQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_boxCarMethod )
            boxCarMethod = decoration(gson)
          case ( f_boundaryPressure )     ! For special fill of columnAbundance
            bndPressVctrIndex = decoration(decoration(subtree(1,gson)))
            bndPressQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case(f_c)
            call expr ( gson , unitAsArray, valueAsArray )
            c = valueAsArray(1)
          case ( f_channel )
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            channel = valueAsArray(1)
          case ( f_centerVertically )
            centerVertically = get_boolean ( gson )
          case ( f_earthRadius ) ! For losGrid fill
            earthRadiusVectorIndex = decoration(decoration(subtree(1,gson)))
            earthRadiusQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_excludeBelowBottom )
            excludeBelowBottom = get_boolean ( gson )
          case ( f_ECRToFOV ) ! For hydrostatic
            ecrToFOVVectorIndex = decoration(decoration(subtree(1,gson)))
            ecrToFOVQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_explicitValues ) ! For explicit fill
            valuesNode = subtree(j,key)
          case ( f_extinction ) ! For cloud extinction fill
            extinction = get_boolean ( gson )
          case ( f_fieldECR ) ! For hydrostatic
            fieldECRVectorIndex = decoration(decoration(subtree(1,gson)))
            fieldECRQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_file ) ! For asciifile
            filename = sub_rosa ( gson )
          case ( f_flags ) ! For chi^2 ratio
            flagVectorIndex = decoration(decoration(subtree(1,gson)))
            flagQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_force )
            force = get_boolean ( gson )
          case ( f_fromPrecision )
            fromPrecision = get_boolean ( gson )
          case ( f_geocAltitudeQuantity ) ! For hydrostatic
            geocAltitudeVectorIndex = decoration(decoration(subtree(1,gson)))
            geocAltitudeQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_gphQuantity ) ! For magnetic field fill
            gphVectorIndex = decoration(decoration(subtree(1,gson)))
            gphQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_height )
            heightNode = subtree(j,key)
          case ( f_h2oQuantity ) ! For hydrostatic or rhi
            h2oVectorIndex = decoration(decoration(subtree(1,gson)))
            h2oQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_h2oPrecisionQuantity ) ! For rhi precision
            h2oPrecisionVectorIndex = decoration(decoration(subtree(1,gson)))
            h2oPrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_dontMask )
            dontMask = get_boolean ( gson )
          case ( f_dontSumHeights )
            dontSumHeights = get_boolean ( gson )
          case ( f_dontSumInstances )
            dontSumInstances = get_boolean ( gson )
          case ( f_ignoreZero )
            ignoreZero = get_boolean ( gson )
          case ( f_ignoreGeolocation ) ! For l2gp etc. fill
            ignoreGeolocation =get_boolean ( gson )
          case ( f_ignoreNegative )
            ignoreNegative = get_boolean ( gson )
          case ( f_ifMissingGMAO )
            MissingGMAO = get_boolean ( gson ) .and. &
              & ( APrioriFiles%dao // AprioriFiles%ncep  // AprioriFiles%geos5 &
              &   == ' ' )
          case ( f_instances )
            instancesNode = subtree(j,key)
          case ( f_integrationTime )
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Time/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Time/) )
            integrationTime = valueAsArray(1)
          case ( f_internalVGrid )
            internalVGridIndex=decoration(decoration(gson))
          case ( f_interpolate ) ! For l2gp etc. fill
            interpolate =get_boolean ( gson )
          case ( f_intrinsic )
            switch2intrinsic = get_boolean ( gson )
!         case ( f_invert )
!           invert = get_boolean ( gson )
          case ( f_isPrecision )
            isPrecision = get_boolean ( gson )
          case ( f_logSpace )
            logSpace = get_boolean ( gson )
          case ( f_losQty ) ! For losGrid fill
            losVectorIndex = decoration(decoration(subtree(1,gson)))
            losQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_lsb ) ! For folding
            lsbVectorIndex = decoration(decoration(subtree(1,gson)))
            lsbQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_lsbFraction ) ! For folding
            lsbFractionVectorIndex = decoration(decoration(subtree(1,gson)))
            lsbFractionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_manipulation )
            manipulation = sub_rosa ( gson )
          case ( f_maxIterations )      ! For hydrostatic fill
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            maxIterations = valueAsArray(1)
          case ( f_maxValue )      ! For status fill
            call expr ( gson, unitAsArray, valueAsArray )
            maxValueUnit = unitAsArray(1)
            maxValue = valueAsArray(1)
          case ( f_measurements )   ! Only used for diagnostic special fills
            measVectorIndex = decoration(decoration(subtree(1,gson)))
            measQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_method )   ! How are we going to fill it?
            fillMethod = decoration(gson)
          case ( f_minNormQty )   ! Only used for chi^2 ratio fills
            minNormVectorIndex = decoration(decoration(subtree(1,gson)))
            minNormQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_minValue )      ! For status fill
            call expr ( gson, unitAsArray, valueAsArray )
            minValueUnit = unitAsArray(1)
            minValue = valueAsArray(1)
          case ( f_model )   ! Only used for diagnostic special fills
            modelVectorIndex = decoration(decoration(subtree(1,gson)))
            modelQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_multiplier ) ! For scaling noise part of addnoise
            multiplierNode=subtree(j,key)
          case ( f_noFineGrid )      ! For cloud extinction fill
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            noFineGrid = valueAsArray(1)
          case ( f_noise )   ! Only used for chi^2 special fills or addnoise
            noiseVectorIndex = decoration(decoration(subtree(1,gson)))
            noiseQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_noiseBandwidth )
            nbwVectorIndex = decoration(decoration(subtree(1,gson)))
            nbwQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_normQty )   ! Only used for chi^2 ratio fills
            normVectorIndex = decoration(decoration(subtree(1,gson)))
            normQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_offsetAmount )    ! For marking unused radiances
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Temperature/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Temperature/) )
            offsetAmount = valueAsArray(1)
          case ( f_orbitInclination ) ! For hydrostatic fill
            orbitinclInationVectorIndex = &
              & decoration(decoration(subtree(1,gson)))
            orbitinclInationQuantityIndex = &
              & decoration(decoration(decoration(subtree(2,gson))))
          case ( f_precision )      ! For masking l1b radiances
            precisionVectorIndex = decoration(decoration(subtree(1,gson)))
            precisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_precisionFactor )    ! For setting negative errors
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            precisionFactor = valueAsArray(1)
          case ( f_profile )
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            profile = valueAsArray(1)
          case ( f_profileValues )
            valuesNode = subtree(j,key)
          case ( f_PtanQuantity ) ! For losGrid fill
            PtanVectorIndex = decoration(decoration(subtree(1,gson)))
            PtanQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_Phitan ) ! For losGrid fill
            PhitanVectorIndex = decoration(decoration(subtree(1,gson)))
            PhitanQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_phiWindow )
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/ PHYQ_Profiles, PHYQ_Angle /), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Profiles, PHYQ_Angle/) )
            phiWindow = valueAsArray(1)
            phiWindowUnits = unitAsArray(1)
          case ( f_phiZero )
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Angle/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
            phiZero = valueAsArray(1)
          case ( f_quadrature )
            quadrature = get_boolean ( gson )
          case ( f_quantity )   ! What quantity are we filling quantity=vector.quantity
            vectorIndex = decoration(decoration(subtree(1,gson)))
            quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_radianceQuantity )      ! For estimated noise
            radianceVectorIndex = decoration(decoration(subtree(1,gson)))
            radianceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_ratioQuantity )      ! For isotope ratio
            ratioVectorIndex = decoration(decoration(subtree(1,gson)))
            ratioQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_refract )
            refract = get_boolean ( gson )
          case ( f_refGPHQuantity ) ! For hydrostatic or rhi
            refGPHVectorIndex = decoration(decoration(subtree(1,gson)))
            refGPHQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_refGPHPrecisionQuantity ) ! For GPH precision
            refGPHPrecisionVectorIndex = decoration(decoration(subtree(1,gson)))
            refGPHPrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_resetSeed )
            resetSeed = get_boolean ( gson )
          case ( f_rhiQuantity ) ! For h2o from rhi
            sourceVectorIndex = decoration(decoration(subtree(1,gson)))
            sourceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_scale, f_scaleInsts, f_scaleRatio, f_scaleSurfs )
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            select case ( fieldIndex )
            case ( f_scale )
              scale = valueAsArray(1)
            case ( f_scaleInsts )
              scaleInstances = valueAsArray(1)
            case ( f_scaleRatio )
              scaleRatio = valueAsArray(1)
            case ( f_scaleSurfs )
              scaleSurfs = valueAsArray(1)
            end select
          case ( f_scECI )                ! For special fill of losVel
            scECIVectorIndex = decoration(decoration(subtree(1,gson)))
            scECIQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_scVel )                ! For special fill of losVel
            scVelVectorIndex = decoration(decoration(subtree(1,gson)))
            scVelQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_scVelECI )                ! For special fill of losVel
            scVelVectorIndex = decoration(decoration(subtree(1,gson)))
            scVelQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_scVelECR )                ! For special fill of losVel
            scVelVectorIndex = decoration(decoration(subtree(1,gson)))
            scVelQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_seed ) ! For explicitly setting mls_random_seed
            seedNode=subtree(j,key)
          case ( f_sourceL2AUX )          ! Which L2AUXDatabase entry to use
            l2auxIndex = decoration(decoration(gson))
          case ( f_sourceL2GP )           ! Which L2GPDatabase entry to use
            l2gpIndex=decoration(decoration(gson))
          case ( f_sourceGrid )
            gridIndex=decoration(decoration(gson))
          case ( f_sourceQuantity )       ! When filling from a vector, what vector/quantity
            sourceVectorIndex = decoration(decoration(subtree(1,gson)))
            sourceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_sourceVGrid )
            vGridIndex=decoration(decoration(gson))
          case ( f_spread ) ! For explicit fill, note that gson here is not same as others
            spreadFlag = get_boolean ( gson )
          case ( f_status )
            valuesNode = subtree(j,key)
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            statusValue = nint ( valueAsArray(1) )
          case ( f_suffix )
            suffix = sub_rosa ( gson )
          case ( f_systemTemperature )
            sysTempVectorIndex = decoration(decoration(subtree(1,gson)))
            sysTempQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_tngtECI )              ! For special fill of losVel
            tngtECIVectorIndex = decoration(decoration(subtree(1,gson)))
            tngtECIQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_temperatureQuantity ) ! For hydrostatic or rhi
            temperatureVectorIndex = decoration(decoration(subtree(1,gson)))
            temperatureQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_tempPrecisionQuantity ) ! For rhi precision
            tempPrecisionVectorIndex = decoration(decoration(subtree(1,gson)))
            tempPrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_terms )
            termsNode = subtree(j,key)
          case ( f_unit ) ! For folding
            colmabunits = decoration(gson) ! decoration(subtree(2,gson))
          case ( f_usb ) ! For folding
            usbVectorIndex = decoration(decoration(subtree(1,gson)))
            usbQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_usbFraction ) ! For folding
            usbFractionVectorIndex = decoration(decoration(subtree(1,gson)))
            usbFractionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_vmrQuantity )     ! For special fill of columnAbundance
            vmrQtyVctrIndex = decoration(decoration(subtree(1,gson)))
            vmrQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_whereFill )
            whereFill = get_boolean ( gson )
          case ( f_whereNotFill )
            whereNotFill = get_boolean ( gson )
          case ( f_width )
            call expr_check ( gson , unitAsArray, valueAsArray, &
              & (/PHYQ_Dimensionless/), unitsError )
            if ( unitsError ) call Announce_error ( subtree(j,key), wrongUnits, &
              & extraInfo=(/unitAsArray(1), PHYQ_Dimensionless/) )
            width = valueAsArray(1)
          end select
        end do                  ! Loop over arguments to fill instruction

        ! Put various conditions under which you would want to skip this fill
        if ( got(f_ifMissingGMAO) .and. .not. MissingGMAO ) skipFill = .true.
        if ( skipFill ) fillMethod = -1 ! We'll assume no l_value can be this

        ! Now call various routines to do the filling
        quantity => GetVectorQtyByTemplateIndex( &
          & vectors(vectorIndex), quantityIndex )

        select case ( fillMethod )
        case ( l_addNoise ) ! ----- Add random noise to source Quantity -------
          if ( DEEBUG) call output('add noise method', advance='yes')
          if ( .not. all(got( (/f_Quantity, f_sourceQuantity, f_noise/) ) ) ) &
            call Announce_error ( key, No_Error_code, &
             'Missing a required field to add noise'  )
          Quantity => GetVectorQtyByTemplateIndex( &
            & vectors(VectorIndex), QuantityIndex )
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          noiseQty => GetVectorQtyByTemplateIndex( &
            & vectors(noiseVectorIndex), noiseQtyIndex)
          math77_ran_pack = .not. switch2intrinsic
          if ( DEEBUG ) then
            call output('Switch to intrinsic? ', advance='no')
            call output(switch2intrinsic, advance='yes')
            call output('resetSeed? ', advance='no')
            call output(resetSeed, advance='yes')
            call output('got(f_seed)? ', advance='no')
            call output(got(f_seed), advance='yes')
          end if
          if ( resetSeed ) then
            call mls_random_seed(new_seed=seed(1:))
            if ( DEEBUG ) then
              call output('Letting mls choose new seed ', advance='no')
              call output(seed, advance='yes')
            end if
          else if ( got(f_seed) ) then
            do j=1, min(nsons(seedNode)-1, 2)
              call expr(subtree(j+1,seedNode),unitAsArray,valueAsArray)
              seed(j) = int(valueAsArray(1))+chunkNo
            end do
            if ( seed(1) /= 0 .and. seed(2) /= 0 ) then
              call mls_random_seed(pput=seed(1:))
              if ( DEEBUG ) then
                call output('Setting new seed ', advance='no')
                call output(seed, advance='yes')
              end if
            else
              call mls_random_seed(new_seed=seed(1:))
              if ( DEEBUG ) then
                call output('Letting mls choose new seed ', advance='no')
                call output(seed, advance='yes')
              end if
            end if
          else
            if ( DEEBUG ) then
              call mls_random_seed(gget=seed(1:))
              call output('Reusing current seed ', advance='no')
              call output(seed, advance='yes')
            end if
          end if

          ! Either multiplier = [a, b] or multiplier = b are possible
          if ( got(f_multiplier) ) then
            multiplier = UNDEFINED_VALUE
            do j=1, min(nsons(multiplierNode)-1, 2)
              call expr(subtree(j+1,multiplierNode),unitAsArray,valueAsArray)
              multiplier(j) = valueAsArray(1)
            end do
          else
            multiplier = 1.
          end if

          if ( DEEBUG ) then
            call output('Using multipliers: ', advance='no')
            call output(multiplier, advance='yes')
          end if
          call addGaussianNoise ( key, quantity, sourceQuantity, &
            & noiseQty, multiplier )

        case ( l_applyBaseline )
          if ( .not. got ( f_baselineQuantity ) ) &
            & call Announce_Error ( key, no_Error_Code, &
            & 'Need baselineQuantity for applyBaseline fill' )
          baselineQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(baselineVctrIndex), baselineQtyIndex )
          call ApplyBaseline ( key, quantity, baselineQuantity, &
            & quadrature, dontmask )

        case ( l_asciiFile )
          if ( .not. got ( f_file ) ) &
            & call Announce_Error ( key, no_Error_Code, &
            & 'Need filename for asciiFile fill' )
          if ( got ( f_badRange ) ) then
            call FillQuantityFromASCIIFile ( key, quantity, filename, badRange )
          else
            call FillQuantityFromASCIIFile ( key, quantity, filename )
          end if

        case ( l_binMax, l_binMean, l_binMin, l_binTotal, &
             & l_lsLocal, l_lsGlobal, l_lsWeighted )
          if ( .not. got ( f_sourceQuantity ) ) &
            & call Announce_Error ( key, no_Error_Code, &
            & 'Need source quantity for bin fill or least-squares fill' )
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          if ( got ( f_ptanQuantity ) ) then
            ptanQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(ptanVectorIndex), ptanQuantityIndex)
          else
            nullify ( ptanQuantity )
          end if

          if ( sourceQuantity%template%verticalCoordinate /= &
            & quantity%template%verticalCoordinate ) then
            if ( .not. sourceQuantity%template%minorFrame .or. &
              &  .not. got ( f_ptanQuantity ) .or. &
              &  quantity%template%verticalCoordinate /= l_zeta ) then
                call Announce_Error ( key, no_Error_Code, &
                & ' vertical coordinates mismatch, perhaps supply tangent pressure?' )
            else
              if ( ptanQuantity%template%instrumentModule .ne. &
                & sourceQuantity%template%instrumentModule ) &
                & call Announce_Error ( key, no_Error_Code, &
                & 'Instrument module mismatch between ptan and source quantity' )
            end if
          end if

          if ( error == 0 ) then
            select case ( fillMethod )
            case ( l_binMax, l_binMean, l_binMin, l_binTotal )
              call FillWithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
                & channel, fillMethod, additional, excludeBelowBottom, centerVertically )
            case default
              call FillUsingLeastSquares ( key, quantity, sourceQuantity, ptanQuantity, &
                & channel, fillMethod, scaleInstances, scaleRatio, scaleSurfs )
            end select
          end if

        case ( l_boxcar )
          if ( .not. got ( f_sourceQuantity ) ) &
            & call Announce_Error ( key, no_Error_Code, &
            & 'Need source quantity for boxcar fill' )
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          if ( .not. got ( f_width ) ) call Announce_Error ( key, no_Error_Code, &
            & 'Must supply width for boxcar fill' )
          call FillWithBoxcarFunction ( key, quantity, sourceQuantity, width, &
            & boxCarMethod )

        case ( l_chiSqRatio ) ! ----------- Fill with convergence ratio ---
          if ( .not. all(got( (/ f_normQty, &
            & f_minNormQty, f_flags /)))) &
            & call Announce_Error ( key, no_Error_Code, &
              & 'Missing required fields for chi^2 ratio' )
          normQty => GetVectorQtyByTemplateIndex( &
            & vectors(normVectorIndex), normQtyIndex )
          minNormQty => GetVectorQtyByTemplateIndex( &
            & vectors(minNormVectorIndex), minNormQtyIndex )
          flagQty => GetVectorQtyByTemplateIndex( &
            & vectors(flagVectorIndex), flagQtyIndex )
          call FillChiSqRatio ( key, &
            & quantity, normQty, minNormQty, flagQty, dontMask )

        case ( l_combineChannels )
          if ( .not. got ( f_sourceQuantity ) ) &
            & call Announce_Error ( key, no_Error_Code, &
            & 'Need source quantity for combine channels fill' )
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          call FillWithCombinedChannels ( quantity, sourceQuantity, message )
          if ( message /= '' ) call Announce_Error ( key, no_Error_Code, trim(message) )

        case ( l_convergenceRatio )
          if ( .not. all ( got ( (/ f_sourceQuantity, f_scale /) ) ) ) &
            call Announce_error ( key, no_error_code, &
            & 'Need sourceQuanitity and scale for quality fill' )
          sourceQuantity => GetVectorQtyByTemplateIndex ( vectors(sourceVectorIndex), &
            & sourceQuantityIndex )
          call FillConvergenceFromChisq ( key, quantity, sourceQuantity, scale )

        case ( l_estimatedNoise ) ! ----------- Fill with estimated noise ---
          if ( .not. all(got( (/ f_radianceQuantity, &
            & f_systemTemperature, f_integrationTime /)))) &
            & call Announce_Error ( key, badEstNoiseFill )
          radianceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(radianceVectorIndex), radianceQuantityIndex )
          sysTempQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sysTempVectorIndex), sysTempQuantityIndex )
          if ( got ( f_noiseBandwidth ) ) then
            nbwQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(nbwVectorIndex), nbwQuantityIndex )
          else
            nbwQuantity => NULL()
          end if
          call FillVectorQtyWithEstNoise ( &
            & quantity, radianceQuantity, sysTempQuantity, nbwQuantity, &
            & integrationTime )

        case ( l_explicit ) ! ---------  Explicitly fill from l2cf  -----
          if ( .not. got(f_explicitValues) ) &
            & call Announce_Error ( key, noExplicitValuesGiven )
          call ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
            & vectors(vectorIndex)%globalUnit, dontmask )

        case ( l_extractChannel )
          if ( .not. all(got ( (/f_sourceQuantity,f_channel/)))) &
            & call Announce_Error ( key, no_Error_Code, &
              & 'Need sourceQuantity and channel for this fill' )
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          call ExtractSingleChannel ( key, quantity, sourceQuantity, channel )

        case ( l_fold ) ! --------------- Fill by sideband folding -----
          nullify ( lsb, lsbFraction, usb, usbFraction )
          if ( got ( f_lsb ) ) lsb => GetVectorQtyByTemplateIndex ( &
            & vectors(lsbVectorIndex), lsbQuantityIndex )
          if ( got ( f_lsbFraction ) ) lsbFraction => GetVectorQtyByTemplateIndex ( &
            & vectors(lsbFractionVectorIndex), lsbFractionQuantityIndex )
          if ( got ( f_usb ) ) usb => GetVectorQtyByTemplateIndex ( &
            & vectors(usbVectorIndex), usbQuantityIndex )
          if ( got ( f_usbFraction ) ) usbFraction => GetVectorQtyByTemplateIndex ( &
            & vectors(usbFractionVectorIndex), usbFractionQuantityIndex )
          call FillFoldedRadiance ( quantity, lsb, usb, lsbFraction, usbFraction, key )

        case ( l_fwdModelTiming ) ! --- Fill timings for forward model  -----
          call FillFwdModelTimings (quantity%values(:,1), FWModelConfig, 'fwdTiming')
        case ( l_fwdModelMean ) ! --- Fill mean for forward model  -----
          call FillFwdModelTimings (quantity%values(:,1), FWModelConfig, 'mean')
        case ( l_fwdModelStdDev ) ! --- Fill std_dev for forward model  -----
          call FillFwdModelTimings (quantity%values(:,1), FWModelConfig, 'stdDev')
        case ( l_gphPrecision) ! -------------  GPH precision  -----
          ! Need a tempPrecision and a refgphPrecision quantity
          if ( .not.all(got( (/ f_refGPHPrecisionQuantity, f_tempPrecisionQuantity /))) ) &
            call Announce_Error ( key,needTempREFGPH )

          tempPrecisionQuantity => GetVectorQtyByTemplateIndex( &
            &  vectors(tempPrecisionVectorIndex), tempPrecisionQuantityIndex)
          if ( tempPrecisionQuantity%template%quantityType /= l_Temperature ) &
            & call Announce_Error ( key, badTemperatureQuantity )

          refGPHPrecisionQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(refGPHPrecisionVectorIndex), refGPHPrecisionQuantityIndex)
          if ( refGPHPrecisionQuantity%template%quantityType /= l_refGPH ) &
            & call Announce_Error ( key, badrefGPHQuantity )

          call FillGPHPrecision ( key, quantity, tempPrecisionQuantity, &
            & refGPHPrecisionQuantity )

        case ( l_gridded ) ! ------------  Fill from gridded data  -----
          if ( .not. got(f_sourceGrid) ) &
            & call Announce_Error ( key, noSourceGridGiven )
          ! call output( 'Filling quantity from grid', advance='yes' )
          call FillVectorQuantityFromGrid &
            & ( quantity, griddedDataBase(gridIndex), allowMissing, errorCode )
          ! call outputNamedValue( 'error code', errorCode )
          if ( errorCode /= 0 ) call Announce_error ( key, errorCode )

        case ( l_l1b ) ! --------------------  Fill from L1B data  -----
          if ( got(f_precision) ) then
            precisionQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(precisionVectorIndex), precisionQuantityIndex )
            call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), &
              & filedatabase, isPrecision, suffix=suffix, &
              & precisionQuantity=precisionQuantity )
          elseif ( got(f_avoidbrightobjects) ) then
            avoidObjects = lowerCase(avoidObjects)
            nBO = NumStringElements( avoidObjects, .true. )
            do iBO = 1, nBO
              BOnum = StringElementNum(lowercase(BrightObjects), &
                & trim(StringElement(avoidObjects, iBO, .true.)), &
                & .true.)
              if ( BOnum > 0 ) BOMask = ibset( BOMask, BOnum )
            end do
            ! Special case: moon in space port
            if ( index(avoidObjects, 'mooninsp') > 0 ) &
              & BOMask = ibset( BOMask, 0 )
            call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), &
              & filedatabase, isPrecision, suffix=suffix, BOMask=BOMask )
          else
            call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), &
              & filedatabase, isPrecision, suffix=suffix )
          end if

        case ( l_l2gp ) ! --------------  Fill from L2GP quantity  -----
          if ( .NOT. got(f_sourceL2GP) ) &
            & call Announce_Error ( key, noSourceL2GPGiven )
          call FillVectorQuantityFromL2GP &
            & ( quantity, l2gpDatabase(l2gpIndex), interpolate, profile, errorCode, &
            & ignoreGeolocation, fromPrecision  )
          if ( errorCode /= 0 ) call Announce_error ( key, errorCode )

        case ( l_l2aux ) ! ------------  Fill from L2AUX quantity  -----
          if ( .NOT. got(f_sourceL2AUX) ) &
            & call Announce_Error ( key, noSourceL2AUXGiven )
          call FillVectorQuantityFromL2AUX(quantity,l2auxDatabase(l2auxIndex),errorCode)
          if ( errorCode /= 0 ) call Announce_error ( key, errorCode )

        case ( l_H2OfromRHI ) ! -------fill H2O from RHI quantity -------
            if ( .not. any(got( &
             & (/f_rhiQuantity, f_temperatureQuantity/) &
             & )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill h2o from rhi'  )
            else
              sourceQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(sourceVectorIndex), sourceQuantityIndex)
              temperatureQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(temperatureVectorIndex), temperatureQuantityIndex)
              if ( .not. ValidateVectorQuantity(sourceQuantity, &
                & quantityType=(/l_rhi, l_vmr/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The rhiQuantity is not an rhi'  )
              else if ( .not. ValidateVectorQuantity(Quantity, &
                & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The Quantity is not a vmr for the H2O molecule'  )
              else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                & quantityType=(/l_temperature/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The temperatureQuantity is not a temperature'  )
              else
                invert = .true.
                call FillRHIFromH2O ( key, quantity, &
                  & sourceQuantity, temperatureQuantity, &
                  & dontMask, ignoreZero, ignoreNegative, interpolate, &
                  & .true., &   ! Mark Undefined values?
                  & invert )    ! invert rather than convert?
              end if
            end if

        case ( l_hydrostatic ) ! -------------  Hydrostatic fills  -----
          ! Need a temperature and a refgph quantity
          if ( .not.all(got( (/ f_refGPHQuantity, f_temperatureQuantity /))) ) &
            call Announce_Error ( key, needTempREFGPH )

          temperatureQuantity => GetVectorQtyByTemplateIndex( &
            &  vectors(temperatureVectorIndex), temperatureQuantityIndex)
          if ( temperatureQuantity%template%quantityType /= l_Temperature ) &
            & call Announce_Error ( key, badTemperatureQuantity )

          refGPHQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(refGPHVectorIndex), refGPHQuantityIndex)
          if ( refGPHQuantity%template%quantityType /= l_refGPH ) &
            & call Announce_Error ( key, badrefGPHQuantity )

          if ( quantity%template%quantityType==l_ptan ) then
            if ( .not. got(f_geocAltitudeQuantity) ) &
              & call Announce_Error ( key, needGeocAltitude )
            geocAltitudeQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(geocAltitudeVectorIndex), geocAltitudeQuantityIndex)
            if ( geocAltitudeQuantity%template%quantityType /= l_tngtgeocAlt ) &
              & call Announce_Error ( key, badGeocAltitudeQuantity )

            if ( .not. got(f_phiTan) ) &
              & call Announce_Error ( key, no_Error_Code, 'Needs phiTan quantity' )
            phiTanQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(phiTanVectorIndex), phiTanQuantityIndex)
            if ( phiTanQuantity%template%quantityType /= l_phiTan ) &
              & call Announce_Error ( key, no_Error_Code, 'Has a bad phiTan quantity' )

            if ( .not. got(f_h2oQuantity) ) &
              & call Announce_Error ( key, needH2O )
            h2oQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(h2oVectorIndex), h2oQuantityIndex)
            if ( .not. ValidateVectorQuantity(h2oQuantity, &
              & quantityType=(/l_vmr/), molecule=(/l_h2o/)) )&
              & call Announce_Error ( key, badGeocAltitudeQuantity )

            if ( .not. got(f_orbitInclination) ) &
              & call Announce_Error ( key, needOrbitInclination )
            orbitInclinationQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(orbitInclinationVectorIndex), orbitInclinationQuantityIndex)

          else
            nullify ( geocAltitudeQuantity, h2oQuantity )
          end if
          call FillVectorQtyHydrostatically ( key, quantity, temperatureQuantity, &
            & refGPHQuantity, h2oQuantity, orbitInclinationQuantity, &
            & phiTanQuantity, geocAltitudeQuantity, maxIterations, &
            & phiWindow, phiWindowUnits, chunkNo )

        case ( l_isotope ) ! --------------- Isotope based fills -------
          if ( .not. all(got( (/f_ratioQuantity, f_sourceQuantity/) ) ) ) &
            & call Announce_Error ( key, badIsotopeFill )
          ratioQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(ratioVectorIndex), ratioQuantityIndex )
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          call FillVectorQtyFromIsotope ( quantity, sourceQuantity, &
            & ratioQuantity )

        case ( l_IWCfromExtinction ) ! -------fill IWC from cloud extinction -------
            if ( .not. any(got( &
             & (/f_extinction, f_temperatureQuantity/) &
             & )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill iwc from cloudextinction'  )
            else
              sourceQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(sourceVectorIndex), sourceQuantityIndex)
              temperatureQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(temperatureVectorIndex), temperatureQuantityIndex)
              if ( .not. ValidateVectorQuantity(sourceQuantity, &
                & quantityType=(/l_cloudextinction/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The extinctionQuantity is not an cloudextinction'  )
              else if ( .not. ValidateVectorQuantity(Quantity, &
                & quantityType=(/l_cloudice/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The filled Quantity is not a type of cloudice '  )
              else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                & quantityType=(/l_temperature/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The temperatureQuantity is not a temperature'  )
              else
                call FillIWCFromExtinction ( quantity, &
                  & sourceQuantity, temperatureQuantity)
              end if
            end if

        case ( l_manipulate ) ! ---------------------------- Manipulate --
          if ( .not. got ( f_a ) ) &
            & call Announce_error ( key, no_Error_Code,'aQuantity not supplied' )
          if ( .not. got ( f_manipulation ) ) &
            & call Announce_error ( key, no_Error_Code,'manipulation not supplied' )
          aQuantity => GetVectorQtyByTemplateIndex ( &
            & vectors(aVecIndex), aQtyIndex )
          if ( got ( f_b ) ) then
            bQuantity => GetVectorQtyByTemplateIndex ( &
              & vectors(bVecIndex), bQtyIndex )
          else
            nullify ( bQuantity )
          end if
          call FillQuantityByManipulation ( quantity, aQuantity, bQuantity, c, &
            & manipulation, key, &
            & force, spreadflag, dontSumHeights, dontSumInstances )

        case ( l_magAzEl ) ! -- Magnetic Explicit from stren, azim, elev --
          if ( .not. got(f_explicitValues) ) &
            & call Announce_Error ( key, noExplicitValuesGiven )
          call ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
            & vectors(vectorIndex)%globalUnit, dontmask, azEl=.true. )

        case ( l_magneticModel ) ! --------------------- Magnetic Model --
          if ( .not. got ( f_gphQuantity ) ) then
            call Announce_Error ( key, no_Error_Code, 'Need gphQuantity for magnetic model' )
          else
            GPHQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(GPHVectorIndex), GPHQuantityIndex)
            call FillQuantityUsingMagneticModel ( quantity, gphQuantity, key )
          end if

        case ( l_negativePrecision ) ! ------------ Set output SD -ve wrt apriori
          if ( .not. got ( f_aprioriPrecision ) ) &
            & call Announce_Error ( key, No_Error_code, &
            & 'Missing aprioriPrecision field for negativePrecision fill' )
          aprioriPrecision => GetVectorQtyByTemplateIndex ( &
            & vectors(aprPrecVctrIndex), aprPrecQtyIndex )
          where ( quantity%values >= aprioriPrecision%values*precisionFactor .and. &
            & aprioriPrecision%values > 0.0_r8 )
            quantity%values = - quantity%values
          end where

        case ( l_offsetRadiance ) ! ------------------- Offset radiance --
          if ( .not. got ( f_radianceQuantity ) ) &
            & call Announce_error ( key, no_Error_Code, 'radianceQuantity not supplied' )
          radianceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(radianceVectorIndex), radianceQuantityIndex )
          call OffsetRadianceQuantity ( quantity, radianceQuantity, offsetAmount )

        case ( l_phaseTiming ) ! ---------  Fill timings for phases  -----
          call finishTimings('phases', returnStatus=status)
          if ( status /= 0 ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'Unable to finish phases timings' )
          else
            call FillTimings ( quantity%values(:,1), 'phases', 'all', .true. )
            ! call dump( quantity%values(:,1), 'phases' )
          end if

        case ( l_sectionTiming ) ! ---------  Fill timings for sections  -----
          call finishTimings('sections', returnStatus=status)
          if ( status /= 0 ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, 'Unable to finish sections timings' )
          else
            call FillTimings ( quantity%values(:,1), 'sections', 'all', .true. )
            ! call dump( quantity%values(:,1), 'sections' )
          end if

        case ( l_profile ) ! ------------------------ Profile fill -------
          if ( .not. got ( f_profileValues ) ) &
            call Announce_error ( key, no_Error_Code, 'profileValues not supplied' )
          if ( .not. got ( f_instances ) ) instancesNode = 0
          if ( got ( f_logSpace ) ) then
            call FillVectorQtyFromProfile ( quantity, valuesNode, &
              & instancesNode, vectors(vectorIndex)%globalUnit, dontMask, logSpace=logSpace )
          else
            call FillVectorQtyFromProfile ( quantity, valuesNode, &
              & instancesNode, vectors(vectorIndex)%globalUnit, dontMask )
          end if

        case ( l_refract )              ! --------- refraction for phiTan -----
          ! More sanity checks
          if ( .not. ValidateVectorQuantity ( quantity, &
            & quantityType=(/l_phiTan/), minorFrame=.true. ) ) &
            & call Announce_error ( key, no_Error_Code, 'Quantity to fill is not phiTan' )
          ! Start off with a copy from the template
          quantity%values = quantity%template%phi
          if ( refract ) then
            if ( .not. all ( got ( (/ f_h2oQuantity, f_orbitinclination, &
            & f_ptanQuantity, f_refGPHquantity, f_temperatureQuantity /) ) ) ) then
              call Announce_error ( key, badRefractFill )
              call announce_error ( key, missingField, extraInfo= &
                & (/ f_h2oQuantity, f_orbitinclination, &
                & f_ptanQuantity, f_refGPHquantity, f_temperatureQuantity /) )
            end if
            h2oQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(h2oVectorIndex), h2oQuantityIndex)
            orbitInclinationQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(orbitInclinationVectorIndex), orbitInclinationQuantityIndex)
            ptanQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(ptanVectorIndex), ptanQuantityIndex)
            refGPHquantity => GetVectorQtyByTemplateIndex( &
              & vectors(refGPHVectorIndex), refGPHQuantityIndex)
            temperatureQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(temperatureVectorIndex), temperatureQuantityIndex)
            call FillPhiTanWithRefraction ( key, quantity, h2oQuantity, &
              & orbitInclinationQuantity, ptanQuantity, refGPHquantity, temperatureQuantity )
          end if

        case ( l_reflectorTempModel ) ! --------------- Reflector temperature model
          call FillWithReflectorTemperature ( key, quantity, phiZero, termsNode )

        case ( l_resetUnusedRadiances )
          call ResetUnusedRadiances ( quantity, offsetAmount )

        case ( l_rectanglefromlos ) ! -------fill from losGrid quantity -------
          if ( .not. all(got((/f_losQty,f_earthRadius,f_PtanQuantity/))))&
            & call Announce_Error ( key, badlosGridFill )
          earthRadiusQty => GetVectorQtyByTemplateIndex( &
            & vectors(earthRadiusVectorIndex), earthRadiusQtyIndex )
          PtanQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(PtanVectorIndex), PtanQuantityIndex )
          losQty => GetVectorQtyByTemplateIndex( &
            & vectors(losVectorIndex), losQtyIndex )
          call FillQuantityFromLosGrid ( key, Quantity, losQty, &
            & ptanQuantity, earthRadiusQty, &
            & noFineGrid, extinction, errorCode )

        case ( l_RHIfromH2O ) ! -------fill RHI from H2O quantity -------
          if ( .not. any(got( &
           & (/f_h2oquantity, f_temperatureQuantity/) &
           & )) ) then
            call Announce_error ( key, No_Error_code, &
            & 'Missing a required field to fill rhi'  )
          else ! value
              h2oQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(h2oVectorIndex), h2oQuantityIndex)
              temperatureQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(temperatureVectorIndex), temperatureQuantityIndex)
              if ( .not. ValidateVectorQuantity(h2oQuantity, &
                & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                call Announce_Error ( key, No_Error_code, &
                  & 'The h2oQuantity is not a vmr for the H2O molecule'  )
              else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                & quantityType=(/l_temperature/)) ) then
                call Announce_Error ( key, No_Error_code, &
                  & 'The temperatureQuantity is not a temperature'  )
              else
                call FillRHIFromH2O ( key, quantity, &
                  & h2oQuantity, temperatureQuantity, &
                  & dontMask, ignoreZero, ignoreNegative, interpolate, &
                  & .true., &   ! Mark Undefined values?
                  & invert )    ! invert rather than convert?
              end if
          end if

        case ( l_quality )
          if ( .not. all ( got ( (/ f_sourceQuantity, f_scale /) ) ) ) &
            call Announce_error ( key, no_error_code, &
            & 'Need sourceQuanitity and scale for quality fill' )
          sourceQuantity => GetVectorQtyByTemplateIndex ( vectors(sourceVectorIndex), &
            & sourceQuantityIndex )
          call FillQualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )

        case ( l_RHIPrecisionfromH2O ) ! --fill RHI prec. from H2O quantity --
          if ( .not. any(got( &
            & (/f_h2oquantity, f_temperatureQuantity, &
            & f_h2oPrecisionquantity, f_tempPrecisionQuantity/) &
            & )) ) then
            call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill rhi precision'  )
          else
            h2oQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(h2oVectorIndex), h2oQuantityIndex)
            temperatureQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(temperatureVectorIndex), temperatureQuantityIndex)
            h2oPrecisionQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(h2oPrecisionVectorIndex), h2oPrecisionQuantityIndex)
            tempPrecisionQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(tempPrecisionVectorIndex), tempPrecisionQuantityIndex)
            if ( .not. ValidateVectorQuantity(h2oQuantity, &
              & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
              call Announce_Error ( key, No_Error_code, &
                & 'The h2oQuantity is not a vmr for the H2O molecule'  )
            else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
              & quantityType=(/l_temperature/)) ) then
              call Announce_Error ( key, No_Error_code, &
                & 'The temperatureQuantity is not a temperature'  )
            else if ( .not. ValidateVectorQuantity(h2oPrecisionQuantity, &
              & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
              call Announce_Error ( key, No_Error_code, &
                & 'The h2oPrecisionQuantity is not a vmr for the H2O molecule'  )
            else if ( .not. ValidateVectorQuantity(tempPrecisionQuantity, &
              & quantityType=(/l_temperature/)) ) then
              call Announce_Error ( key, No_Error_code, &
                & 'The tempPrecisionQuantity is not a temperature'  )
            else
              call FillRHIPrecisionFromH2O ( key, quantity, &
                & h2oPrecisionQuantity, tempPrecisionQuantity, h2oQuantity, &
                & temperatureQuantity, dontMask, ignoreZero, &
                & ignoreNegative, interpolate, &
                & .true., &   ! Mark Undefined values?
                & invert )    ! invert rather than convert?
            end if
          end if

        case ( l_rotateField )
          if ( .not. all ( got ( (/ f_fieldECR, f_ecrtofov /) ) ) ) then
            call Announce_Error ( key, no_error_code, &
              & 'Must supply field and ecrToFov for rotateField fill' )
          else
            fieldECR => GetVectorQtyByTemplateIndex ( &
              & vectors(fieldECRVectorIndex), fieldECRQuantityIndex )
            ecrToFOV => GetVectorQtyByTemplateIndex ( &
              & vectors(ecrToFOVVectorIndex), ecrToFovQuantityIndex )
            call RotateMagneticField ( key, quantity, fieldECR, ecrToFov )
          end if

        case ( l_scaleOverlaps )
          if ( .not. got ( f_multiplier ) ) then
            call Announce_Error ( key, no_error_code, &
              & 'Must supply multipler for scaleOverlaps fill' )
          else
            call ScaleOverlaps ( quantity, multiplierNode, dontMask )
          end if

        case ( l_special ) ! -  Special fills for some quantities  -----
            ! Either multiplier = [a, b] or multiplier = b are possible
          if ( got(f_multiplier) ) then
            multiplier = UNDEFINED_VALUE
            do j=1, min(nsons(multiplierNode)-1, 2)
              call expr(subtree(j+1,multiplierNode),unitAsArray,valueAsArray)
              multiplier(j) = valueAsArray(1)
            end do
          else
            multiplier = 1.
          end if

          if ( DEEBUG ) then
            call output('Using multipliers: ', advance='no')
            call output(multiplier, advance='yes')
          end if

          select case ( quantity%template%quantityType )
          case ( l_losVel )
            if ( .not. any(got( &
            & (/f_tngtECI, f_scECI, f_scVel, f_scVelECI, f_scVelECR/) )) ) then
              call Announce_error ( key, badlosVelFill )
            else
              tngtECIQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(tngtECIVectorIndex), tngtECIQuantityIndex)
              scECIQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(scECIVectorIndex), scECIQuantityIndex)
              scVelQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(scVelVectorIndex), scVelQuantityIndex)
              call FillLOSVelocity ( key, quantity, tngtECIQuantity, &
                & scECIquantity, scVelQuantity )
            end if
          case ( l_columnAbundance )
            if ( .not. any(got( (/f_vmrQuantity, f_boundaryPressure/) )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill column abundance'  )
            elseif ( .not. &
              & any( colmabunits == (/l_dobsonUnits, l_DU, l_molcm2/) ) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Wrong units to fill column abundance'  )
            else
              bndPressQty => GetVectorQtyByTemplateIndex( &
                & vectors(bndPressVctrIndex), bndPressQtyIndex)
              vmrQty => GetVectorQtyByTemplateIndex( &
                & vectors(vmrQtyVctrIndex), vmrQtyIndex)
              if ( got(f_unit) ) then
                ! Switch column species hash to explicit unit
                call get_string( lit_indices(colmabunits), explicitUnit, &
                  & strip=.true. )
                call get_string( lit_indices(quantity%template%molecule), mol, &
                  & strip=.true. )
                call PutHashElement( col_species_keys, col_species_hash, &
                  & lowerCase(mol), ExplicitUnit, countEmpty=.true. )
                ! print *,'col_species_keys: '
                ! print *,col_species_keys
                ! print *,'col_species_hash: '
                ! print *,col_species_hash
                ! call dump( .true., col_species_keys, col_species_hash, &
                !   & 'column species units' )
              else
                call get_string( lit_indices(quantity%template%molecule), mol, &
                  & strip=.true. )
                call GetHashElement (col_species_keys, &
                  & col_species_hash, trim(lowercase(mol)), &
                  & ExplicitUnit, .true.)
                if ( index(lowerCase(ExplicitUnit), 'd') > 0 ) colmabunits = l_DU
              end if
              ! print *, 'species, column unit: ', mol, ExplicitUnit
              call FillColAbundance ( key, quantity, &
                & bndPressQty, vmrQty, colmAbUnits )
            end if
          case ( l_chiSQChan )
            if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill chi^2 on channels'  )
            else
              measQty => GetVectorQtyByTemplateIndex( &
                & vectors(measVectorIndex), measQtyIndex)
              modelQty => GetVectorQtyByTemplateIndex( &
                & vectors(modelVectorIndex), modelQtyIndex)
              noiseQty => GetVectorQtyByTemplateIndex( &
                & vectors(noiseVectorIndex), noiseQtyIndex)
              call FillChiSqChan ( key, quantity, &
                & measQty, modelQty, noiseQty, &
                & dontMask, ignoreZero, ignoreNegative, multiplier )
            end if
          case ( l_chiSQMMaf )
            if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill chi^2 on MAFs'  )
            else
              measQty => GetVectorQtyByTemplateIndex( &
                & vectors(measVectorIndex), measQtyIndex)
              modelQty => GetVectorQtyByTemplateIndex( &
                & vectors(modelVectorIndex), modelQtyIndex)
              noiseQty => GetVectorQtyByTemplateIndex( &
                & vectors(noiseVectorIndex), noiseQtyIndex)
              call FillChiSqMMaf ( key, quantity, &
                & measQty, modelQty, noiseQty, &
                & dontMask, ignoreZero, ignoreNegative, multiplier )
            end if
          case ( l_chiSQMMif )
            if ( .not. any(got( (/f_measurements, f_model, f_noise/) )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill chi^2 on MIFs'  )
            else
              measQty => GetVectorQtyByTemplateIndex( &
                & vectors(measVectorIndex), measQtyIndex)
              modelQty => GetVectorQtyByTemplateIndex( &
                & vectors(modelVectorIndex), modelQtyIndex)
              noiseQty => GetVectorQtyByTemplateIndex( &
                & vectors(noiseVectorIndex), noiseQtyIndex)
              call FillChiSqMMif ( key, quantity, &
                & measQty, modelQty, noiseQty, &
                & dontMask, ignoreZero, ignoreNegative, multiplier )
            end if
          case ( l_noRadsPerMIF )
            if ( .not. got ( f_measurements ) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill noRadsPerMIF on MIFs'  )
            else
              measQty => GetVectorQtyByTemplateIndex( &
                & vectors(measVectorIndex), measQtyIndex)
              call FillNoRadsPerMif ( key, quantity, measQty )
            end if
          case default
            call Announce_error ( key, noSpecialFill )
          end select ! quantity types in special fill cases

        case ( l_splitSideband ) ! --------------- Split the sidebands
          if ( .not. got(f_sourceQuantity) ) &
            & call Announce_Error ( key, No_Error_Code, &
            & 'Missing a source field for vector fill' )
          if ( .not. all(got( (/f_lsbFraction,f_usbFraction/) ))) &
            & call Announce_Error ( key, No_Error_Code, &
            & 'Missing a usb/lsb fraction field for vector fill' )
          if ( .not. got ( f_channel ) ) call Announce_Error ( key, &
            & no_error_code, 'Must supply channel for spreadChannel fill' )
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          lsbFraction => GetVectorQtyByTemplateIndex ( &
            & vectors(lsbFractionVectorIndex), lsbFractionQuantityIndex )
          usbFraction => GetVectorQtyByTemplateIndex ( &
            & vectors(usbFractionVectorIndex), usbFractionQuantityIndex )
          if ( got ( f_usb ) ) then
               usb => GetVectorQtyByTemplateIndex ( &
               & vectors(usbVectorIndex), usbQuantityIndex )
          else
            nullify ( usb )
          end if

          call FillFromSplitSideband ( quantity, sourceQuantity, &
            & lsbFraction, usbFraction, spreadFlag, usb, channel, key )

        case ( l_spreadChannel )
          if ( .not. got ( f_channel ) .and. .not. got( f_sourceQuantity ) ) &
            & call Announce_Error ( key, &
            & no_error_code, 'Must supply channel or sourcequantity for spreadChannel fill' )
          if ( got(f_sourceQuantity) ) then
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
            if ( .not. got(f_channel) ) channel = 1
            call SpreadChannelFill ( quantity, channel, dontMask, key, &
              & sourceQuantity )
          else
            call SpreadChannelFill ( quantity, channel, dontMask, key )
          endif

        case ( l_status )
          if ( got(f_ifMissingGMAO) ) then
            if ( MissingGMAO ) call ExplicitFillVectorQuantity ( quantity, &
              & valuesNode, .true., phyq_Invalid, .true., options='-v' )
          elseif ( .not. all ( got ( (/ f_sourceQuantity, f_status /) ) ) ) then
            call Announce_Error ( key, no_error_code, &
            & 'Need sourceQuantity and status fields for status fill' )
          elseif ( .not. any ( got ( (/ f_minValue, f_maxValue /) ) ) ) then
            call Announce_Error ( key, no_error_code, &
            & 'Need one or both of maxValue, minValue for status fill' )
          else
            sourceQuantity => &
              &GetVectorQtyByTemplateIndex ( vectors(sourceVectorIndex), &
              & sourceQuantityIndex )
            if ( got ( f_maxValue) .and. &
              &  all ( maxValueUnit /= &
              & (/ sourceQuantity%template%unit, PHYQ_Dimensionless/) ) ) &
              & call Announce_Error ( key, no_error_code, &
              & 'Bad unit for maxValue' )
            if ( got ( f_minValue) .and. &
              &  all ( minValueUnit /= &
              & (/ sourceQuantity%template%unit, PHYQ_Dimensionless/) ) ) &
              & call Announce_Error ( key, no_error_code, &
              & 'Bad unit for minValue' )
            if ( all ( got ( (/ f_minValue, f_maxValue /) ) ) .and. &
              &  maxValue <= minValue ) call Announce_Error ( key, no_error_code, &
              & 'Bad combination of max/min values' )
            call FillStatusQuantity ( key, quantity, &
              & sourceQuantity, statusValue, &
              & minValue, maxValue, heightNode, additional )
          end if

        case ( l_vector ) ! ---------------- Fill from another qty.
          ! This is VERY PRELIMINARY, A more fancy one needs to be written
          ! before too long.
          ! Note that this does *NOT* copy the mask (at least for the moment)
          ! It is assumed that the original one (e.g. inherited from transfer)
          ! is still relevant.
          if ( .not. got(f_sourceQuantity) ) &
            & call Announce_Error ( key, No_Error_Code, &
            & 'Missing a source field for vector fill' )
          Quantity => GetVectorQtyByTemplateIndex( &
            & vectors(VectorIndex), QuantityIndex )
          sourceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sourceVectorIndex), sourceQuantityIndex )
          if ( quantity%template%name /= sourceQuantity%template%name ) then
            if ( .not. interpolate .and. .not. force ) then
              call Announce_Error ( key, No_Error_Code, &
                & 'Quantity and sourceQuantity do not have the same template' )
            else
              call FillQtyFromInterpolatedQty ( quantity, sourceQuantity, force, key )
            end if
          else
            ! Just a straight copy
            ! If we have a mask and we're going to obey it then do so
            if ( associated(quantity%mask) .and. .not. dontMask ) then
              where ( iand ( ichar(quantity%mask(:,:)), m_Fill ) == 0 )
                quantity%values(:,:) = sourceQuantity%values(:,:)
              end where
            else ! Otherwise, just blindly copy
              quantity%values = sourceQuantity%values
            end if
          end if

        case ( l_vGrid ) ! ---------------------  Fill from vGrid  -----
          select case ( quantity%template%quantityType )
          case ( l_ptan )
            neededCoordinate = l_zeta
          case ( l_tngtGeodAlt )
            neededCoordinate = l_geodAltitude
          case ( l_tngtGeocAlt )
            neededCoordinate = l_geocAltitude
          end select
          if ( vGrids(vGridIndex)%verticalCoordinate /= neededCoordinate ) &
            & call Announce_Error ( key, No_Error_code, &
            &  'Vertical coordinate vGrid does not match fill' )
          if ( vGrids(vGridIndex)%noSurfs /= quantity%template%noSurfs )&
            & call Announce_Error ( key, No_Error_code, &
            &  'VGrid is not of the same size as the quantity' )
          quantity%values = spread ( vGrids(vGridIndex)%surfs(:,1), 2, &
            & quantity%template%noInstances )

        case ( l_wmoTropopause ) ! ---------------- Fill with wmo tropopause --
!           if ( .not. all(got( (/ f_temperatureQuantity, f_refGPHquantity, &
!             & f_internalVGrid /) ))) &
!             & call Announce_Error ( key, no_error_code, &
!             & 'wmoTropopause fill needs temperatureQuantity, refGPHQuantity ' // &
!             & 'and internalVGrid' )
!           if ( vGrids(internalVGridIndex)%verticalCoordinate /= l_zeta ) &
!             & call Announce_Error ( key, No_Error_code, &
!             &  'Vertical coordinate in internal vGrid is not log pressure' )
          if ( .not. all(got( (/ f_temperatureQuantity, f_refGPHquantity /) ))) &
            & call Announce_Error ( key, no_error_code, &
            & 'wmoTropopause fill needs temperatureQuantity, refGPHQuantity' )
          if ( .not. ValidateVectorQuantity ( quantity, &
            & quantityType = (/l_boundaryPressure/), verticalCoordinate=(/l_none/), &
            & coherent=.true., stacked=.true. ) ) &
            & call Announce_Error ( key, no_error_code, &
            & 'Quantity is not a boundary pressure' )

          temperatureQuantity => GetVectorQtyByTemplateIndex( &
            &  vectors(temperatureVectorIndex), temperatureQuantityIndex)
          if ( .not. ValidateVectorQuantity ( temperatureQuantity, &
            & quantityType = (/l_temperature/), verticalCoordinate=(/l_zeta/), &
            & coherent=.true., stacked=.true. ) ) &
            & call Announce_Error ( key, badTemperatureQuantity )

          refGPHQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(refGPHVectorIndex), refGPHQuantityIndex)
          if ( .not. ValidateVectorQuantity ( refGPHQuantity, &
            & quantityType = (/l_refGPH/), verticalCoordinate=(/l_zeta/), &
            & coherent=.true., stacked=.true., noSurfs=(/1/) ) ) &
            & call Announce_Error ( key, badrefGPHQuantity )

          if ( .not. DoHGridsMatch ( quantity, temperatureQuantity ) .or. &
            &  .not. DoHGridsMatch ( quantity, refGPHQuantity ) ) &
            & call Announce_Error ( key, no_error_code, &
            & 'Horizontal coordinates for temperature/refGPH and/or quantity disagree' )

          ! OK, we must be ready to go
          if ( .not. USEREICHLER ) then
            call FillQtyWithWMOTropopause ( quantity, &
            & temperatureQuantity, refGPHQuantity, vGrids(internalVGridIndex) )
          else
            call FillQtyWithReichlerWMOTP ( quantity, &
            & temperatureQuantity )
          end if
        case (-1)
          ! We must have decided to skip this fill
        case default
          call Announce_error ( key, no_Error_Code, 'This fill method not yet implemented' )
        end select      ! s_method

d954 1
a954 1
    if ( ERROR /= 0 ) then
a957 8
!   User can put dumpBlocks, details=whatever, /allMatrices
!   and dump, details=whatever, /allVectors at the end of the Fill section.
!     if ( toggle(gen) ) then
!       if ( levels(gen) > 0 ) then
!         call dump ( vectors, details=levels(gen)-1 )
!         call dump ( matrices, details=levels(gen)-1 )
!       end if
!     end if
d967 405
a1371 2209
    ! --------------------------------------------------  SayTime  -----
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for MLSL2Fill = " )
      call output ( dble(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime

    ! ------------------------------------------- addGaussianNoise ---
    subroutine addGaussianNoise ( key, quantity, sourceQuantity, &
              & noiseQty, multiplier )
      ! A special fill: quantity = sourceQuantity + g() noiseQty
      ! where g() is a random number generator with mean 0 and std. dev. 1
      ! Generalized into ( a sourceQuantity + b g() noiseQty )
      ! where a and b are multipliers)
      ! Formal arguments
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) ::      quantity
      type (VectorValue_T), intent(in) ::         sourceQuantity
      type (VectorValue_T), intent(in) ::         noiseQty
      real, dimension(:), intent(in), optional :: multiplier

      ! Local variables
      integer                          ::    ROW, COLUMN
      real                             ::    a, b

      ! Executable code
      ! First check that things are OK.
      if ( .not. FillableChiSq ( quantity, &
        & sourceQuantity, noiseQty ) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Incompatibility among vector quantities adding noise'  )
        return
      end if

     ! Either multiplier = [a, b] or multiplier = b are possible
      if ( .not. present(multiplier) ) then
        a = 1.
        b = 1.
      else if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
        a = 1.
        b = 1.
      else if ( multiplier(2) == UNDEFINED_VALUE ) then
        a = 1.
        b = multiplier(1)
      else
        a = multiplier(1)
        b = multiplier(2)
      end if

      do column=1, size(quantity%values(1, :))
        do row=1, size(quantity%values(:, 1))
          quantity%values(row, column) = &
            & sourceQuantity%values(row, column) * a &
            & + &
            & drang() * noiseQty%values(row, column) * b
        end do
      end do

    end subroutine addGaussianNoise

    ! ------------------------------------------- ApplyBaseline ----------
    subroutine ApplyBaseline ( key, quantity, baselineQuantity, &
      & quadrature, dontmask )
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Radiance quantity to modify
      type (VectorValue_T), intent(in) :: BASELINEQUANTITY ! L1B MAF baseline to use
      logical, intent(in) :: QUADRATURE ! If set add in quadrature (for noise)
      logical, intent(in) :: DONTMASK ! If set ignore baselinequantity mask
      ! Local variables
      integer :: MIF
      integer :: CHAN
      integer :: IND                    ! Combined MIF/CHAN
      integer :: i
      integer :: numProfs
      logical :: skipMe
      ! Executable code
      ! call output( 'Now in applyBaseline', advance='yes' )
      if ( quantity%template%quantityType /= l_radiance ) &
        & call Announce_Error ( key, no_Error_Code, &
        &   'Quantity to fill must be a radiance' )
      if ( baselineQuantity%template%quantityType /= l_l1bMAFBaseline ) &
        & call Announce_Error ( key, no_Error_Code, &
        &   'Quantity to fill must be a L1BMAFBaseline' )
      if ( baselineQuantity%template%signal /= quantity%template%signal .or. &
        &  baselineQuantity%template%sideband /= quantity%template%sideband ) &
        & call Announce_Error ( key, no_Error_Code, &
        &   'Quantity and baselineQuantity must have matching signal/sideband' )
      ind = 1
      numProfs = size( quantity%values ( ind, : ) )
      if ( quadrature ) then
        do mif = 1, quantity%template%noSurfs
          do chan = 1, quantity%template%noChans
            if ( .not. dontMask .and. associated(baselineQuantity%mask) ) then
              do i=1, numProfs
                skipMe = .not. dontMask .and. &
                  &  isVectorQtyMasked(baselineQuantity, chan, i)
                if ( .not. skipMe )  &
                & quantity%values ( ind, i ) = sqrt ( &
                  & quantity%values ( ind, i )**2 + &
                  & baselineQuantity%values ( chan, i )**2 )
              enddo
            else
              quantity%values ( ind, : ) = sqrt ( quantity%values ( ind, : )**2 + &
                & baselineQuantity%values ( chan, : )**2 )
            endif
            ind = ind + 1
          end do
        end do
      else
        do mif = 1, quantity%template%noSurfs
          do chan = 1, quantity%template%noChans
            if ( .not. dontMask .and. associated(baselineQuantity%mask) ) then
              do i=1, numProfs
                skipMe = .not. dontMask .and. &
                  &  isVectorQtyMasked(baselineQuantity, chan, i)
                if ( .not. skipMe )  &
                & quantity%values ( ind, i ) = &
                  & quantity%values ( ind, i ) + &
                  & baselineQuantity%values ( chan, i )
              enddo
            else
              quantity%values ( ind, : ) = quantity%values ( ind, : ) + &
                & baselineQuantity%values ( chan, : )
            endif
            ind = ind + 1
          end do
        end do
      end if
    end subroutine ApplyBaseline

    ! ------------------------------------- deallocateStuff ---
    subroutine deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
      real (r8), pointer, dimension(:) :: Zetab
      real (r8), pointer, dimension(:) :: Zetac
      real (r8), pointer, dimension(:) :: Zetai
      real (r8), pointer, dimension(:) :: Pb         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pc         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pi         ! p[i] in hPa
      ! call Deallocate_test ( pa, 'pa', ModuleName )
      call Deallocate_test ( pb, 'pb', ModuleName )
      call Deallocate_test ( pc, 'pc', ModuleName )
      ! call Deallocate_test ( pd, 'pd', ModuleName )
      call Deallocate_test ( pi, 'pi', ModuleName )
      ! call Deallocate_test ( Zetaa, 'Zetaa', ModuleName )
      call Deallocate_test ( Zetab, 'Zetab', ModuleName )
      call Deallocate_test ( Zetac, 'Zetac', ModuleName )
      ! call Deallocate_test ( Zetad, 'Zetad', ModuleName )
      call Deallocate_test ( Zetai, 'Zetai', ModuleName )
    end subroutine DeallocateStuff

    ! ------------------------------------------- ExtractSingleChannel ---
    subroutine ExtractSingleChannel ( key, quantity, sourceQuantity, channel )
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY ! Source quantity for radiances
      integer, intent(in) :: CHANNEL    ! Channel number
      ! Local variables
      integer :: CHANIND                ! Channel index
      integer :: MIF                    ! Minor frame index
      ! Executable code
      if ( quantity%template%quantityType /= l_singleChannelRadiance ) &
        & call announce_error ( key, no_Error_Code, 'Quantity to fill must be of type singleChannelRadiance' )
      if ( all ( sourceQuantity%template%quantityType /= (/ l_cloudInducedRadiance, l_radiance /) ) ) &
        & call announce_error ( key, no_Error_Code, 'source quantity for fill must be of type [cloudInduced]radiance' )
      if ( quantity%template%signal /= sourceQuantity%template%signal .or. &
        & quantity%template%sideband /= sourceQuantity%template%sideband ) &
        & call announce_error ( key, no_Error_Code, 'quantity/sourceQuantity must be same signal/sideband' )
      if ( .not. sourceQuantity%template%regular ) &
        & call Announce_Error ( key, no_Error_Code, 'source quantity must be regular' )
      chanInd = channel - GetFirstChannel ( quantity%template%signal ) + 1
      do mif = 1, quantity%template%noSurfs
        quantity%values ( mif, : ) = &
          & sourceQuantity%values ( chanInd + ( mif - 1 ) * sourceQuantity%template%noChans, : )
      end do
    end subroutine ExtractSingleChannel

    !------------------------------------- FillCovariance ------------

    subroutine FillCovariance ( covariance, vectors, diagonal, &
      & lengthScale, fraction, invert )
      ! This routine fills a covariance matrix from a given set of vectors
      type (Matrix_SPD_T), intent(inout) :: COVARIANCE ! The matrix to fill
      type (Vector_T), dimension(:), intent(in), target :: VECTORS ! The vector database
      integer, intent(in) :: DIAGONAL     ! Index of vector describing diagonal
      integer, intent(in) :: LENGTHSCALE  ! Index of vector describing length scale
      integer, intent(in) :: FRACTION     ! Index of vector describing fraction
      logical, intent(in) :: INVERT       ! We actually want the inverse

      ! Local parameters
      real(r8), parameter :: DECADE = 16000.0 ! Number of meters per decade.

      ! Local variables
      type (VectorValue_T), pointer :: d  ! Diagonal
      type (VectorValue_T), pointer :: l  ! Length
      type (VectorValue_T), pointer :: f  ! Fraction
      type (QuantityTemplate_T), pointer :: qt ! One quantity template
      type (Vector_T) :: DMASKED ! Masked diagonal
      type (Vector_T) :: LMASKED ! Masked length scale
      integer :: B                        ! Block index
      integer :: I                        ! Instance index
      integer :: J                        ! Loop index
      integer :: K                        ! Loop index
      integer :: N                        ! Size of matrix block
      integer :: Q                        ! Quantity index
      real (rm), dimension(:,:), pointer :: M ! The matrix being filled
      real (r8), dimension(:), pointer :: SURFS ! The vertical coordinate
      real (r8) :: distance               ! Distance between two points
      real (r8) :: thisLength             ! Geometric mean length scale
      real (r8) :: meanDiag               ! Geometric mean diagonal value
      real (r8) :: thisFraction           ! Geometric mean diagonal value
      logical, dimension(:), pointer :: condition ! Condition
      logical :: ANYOFFDIAG             ! Flag to indicate presence of off diagonal elements

      ! Executable code

      ! Apply mask to diagonal
      nullify ( m, condition )
      call CopyVector ( Dmasked, vectors(diagonal), clone=.true., &
        & vectorNameText='_Dmasked' )
      call ClearUnderMask ( Dmasked )

      if ( lengthScale == 0 ) then
        call updateDiagonal ( covariance, vectors(diagonal), square=.true.,&
          & invert=invert, forgiveZeros=.true. )
      else
        ! Do a more complex fill, either we're doing non-diagonal, or there might
        ! be zeros to 'invert'

        ! Setup some stuff
        if ( lengthScale /= 0 ) then
          call CopyVector ( Lmasked, vectors(lengthScale), clone=.true., &
            & vectorNameText='_Lmasked' )
          call ClearUnderMask ( Lmasked )
        end if

        ! Check the validity of the supplied vectors
        if ( covariance%m%row%vec%template%name /= &
          & dMasked%template%name ) call MLSMessage ( MLSMSG_Error, &
          & ModuleName, "diagonal and covariance not compatible in fillCovariance" )
        if ( lengthScale /= 0 ) then    ! Check length if supplied
          if ( covariance%m%row%vec%template%name /= &
            & lMasked%template%name ) call MLSMessage ( MLSMSG_Error, &
            & ModuleName, "lengthScale and covariance not compatible in fillCovariance" )
          if ( lMasked%globalUnit /= phyq_length ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "length vector does not have dimensions of length" )
        else
          thisLength = 0.0
        end if
        if ( fraction /= 0 ) then       ! Check fraction if supplied
          if ( covariance%m%row%vec%template%name /= &
            & vectors(fraction)%template%name ) call MLSMessage ( MLSMSG_Error, &
            & ModuleName, "fraction and covariance not compatible in fillCovariance" )
          if ( vectors(fraction)%globalUnit /= phyq_dimensionless ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "fraction vector is not dimensionless" )
        else
          thisFraction = 1.0
        end if

        ! Now loop over the quantities
        do q = 1, covariance%m%col%vec%template%noQuantities

          ! Setup pointers etc.
          d => dMasked%quantities(q)
          qt => d%template
          if ( lengthScale /= 0 ) l => lMasked%quantities(q)
          if ( fraction /=0 ) f => vectors(fraction)%quantities(q)
          n = qt%instanceLen
          if ( qt%coherent ) surfs => qt%surfs(:,1)
          if ( .not. qt%regular ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Unable to handle irregular quantity in FillCovariance" )
          call Allocate_test ( m, n, n, 'M', ModuleName )

          ! Loop over the instances
          do i = 1, qt%noInstances
            anyOffDiag = .false.
            if ( .not. qt%coherent ) surfs => qt%surfs(:,i)

            ! Clear the working matrix and load the diagonal
            m = 0.0_rm
            do j = 1, n
              m(j,j) = d%values(j,i) ** 2.0
            end do

            ! Now if appropriate add off diagonal terms.
            if ( any( qt%verticalCoordinate == (/ l_height, l_pressure, l_zeta /) ) ) then
              ! Loop over off diagonal terms
              do j = 1, n
                do k = 1, j-1
                  meanDiag = sqrt ( m(j,j) * m(k,k) )
                  if ( lengthScale /= 0 ) &
                    & thisLength = sqrt ( l%values(j,i) * l%values(k,i) )
                  if ( fraction /= 0 ) thisFraction = f%values(j,i)
                  select case (qt%verticalCoordinate)
                  case ( l_height )
                    distance = abs ( surfs ( (j-1)/qt%noChans + 1 ) - &
                      & surfs ( (k-1)/qt%noChans + 1) )
                  case ( l_zeta )
                    distance = abs ( surfs ( (j-1)/qt%noChans + 1 ) - &
                      & surfs ( (k-1)/qt%noChans + 1 ) ) * decade
                  case ( l_pressure )
                    distance = abs ( -log10 ( surfs( (j-1)/qt%noChans + 1) ) + &
                      &               log10 ( surfs( (k-1)/qt%noChans + 1) ) ) / decade
                  end select
                  if ( thisLength > 0.0 .and. thisFraction > 0.0 ) then
                    m(j,k) = meanDiag*thisFraction*exp(-distance/thisLength)
                    anyOffDiag = .true.
                  end if
                end do                    ! Loop over k (in M)
              end do                      ! Loop over j (in M)
            end if                        ! An appropriate vertical coordinate

            ! Now we may need to invert this, if so we need to be clever.
            if ( invert ) then
              call Allocate_test ( condition, n, 'condition', ModuleName )
              condition = d%values(:,i) <= 0.0_rv
              do j = 1, n
                if ( condition(j) ) M(j,j) = 1.0_rm
              end do
              if ( anyOffDiag ) then
                call MatrixInversion(M, upper=.true.)
              else
                do j = 1, n
                  m(j,j) = 1.0 / m(j,j)
                end do
              end if
              do j = 1, n
                if ( condition(j) ) M(j,j) = 0.0_rm
              end do
              call Deallocate_test ( condition, 'condition', ModuleName )
            end if

            b = FindBlock ( covariance%m%col, q, i )
            call Sparsify ( M, covariance%m%block(b,b) )
          end do                          ! Loop over instances
          call Deallocate_test ( m, 'M', ModuleName )
        end do                            ! Loop over quantities
      end if                              ! A non diagonal fill

      call DestroyVectorInfo ( DMasked )
      call DestroyVectorInfo ( LMasked )

    end subroutine FillCovariance

    !=============================== FillVectorQuantityFromGrid ============
    subroutine FillVectorQuantityFromGrid(quantity, grid, allowMissing, errorCode)
      use dump_0, only: dump
      use Griddeddata, only: dump
      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (GriddedData_T), intent(inout) :: GRID ! Grid to fill it from
      ! Needs to be inout because we wrap it.
      logical, intent(in) :: ALLOWMISSING ! If set missing data in grid ok
      integer, intent(out) :: ERRORCODE   ! Error code (one of constants defined above)

      ! Local variables
      integer :: instance,surf            ! Loop counter
      integer :: instIndex,surfIndex      ! Indices
      real(rv) :: newValue
      logical :: DEEBUG
      ! Executable code
      errorCode = 0
      DEEBUG = .false.
      ! DEEBUG = ( grid%quantityName == 'TEMPERATURE' .or. &
      !   & grid%description == 'Temperature' )
      if ( grid%empty ) then
        if ( index(lowercase(grid%description), 'tropopause') > 0 ) then
          ! Must allow this as missing gmao files are a possibility
          ! to be handled with grace and aplomb
          call MLSMessage ( MLSMSG_Warning, moduleName, &
            & 'No tropopause values in grid--filling with missing values' )
          quantity%values = grid%missingValue
        else
          errorCode=EmptyGridForFill
        end if
        return
      end if

      if ( quantity%template%verticalCoordinate /= l_zeta .and. &
        & quantity%template%noInstances > 1 .and. grid%noHeights > 1 ) then
        errorCode=NotZetaForGrid
        return
      end if

      instIndex=1
      surfIndex=1

      ! Wrap the grid to be sure that we can interpolate it in longitude
      ! This will skip out if it's already been done.
      call WrapGriddedData ( grid )

      if ( DEEBUG ) then
        call dump( grid )
        call dump( quantity%template%surfs, 'zeta surfs' )
        call outputNamedValue( '(noSurfs,noInstances)', &
          & (/ quantity%template%noSurfs,quantity%template%noInstances /) )
      endif
      do instance = 1, quantity%template%noInstances
        if ( .not. quantity%template%stacked) instIndex=instance

        do surf = 1, quantity%template%noSurfs
          if ( .not. quantity%template%coherent) surfIndex=surf
          if ( DEEBUG ) then
            call outputNamedValue( 'interp pressure', 10.0**(-quantity%template%surfs(surf,instIndex)) )
            if ( 10.0**(-quantity%template%surfs(surf,instIndex)) < 1.E-6 ) then
              call outputNamedValue( '(surf,instIndex)', (/ surf,instIndex /) )
            endif
          endif
          call l3ascii_interp_field(grid, newValue, &
            & pressure=10.0**(-quantity%template%surfs(surf,instIndex)), &
            & lat=quantity%template%geodLat(surfIndex,instance), &
            & lon=quantity%template%lon(surfIndex,instance), &
            & lst=quantity%template%solarTime(surfIndex,instance), &
            & sza=quantity%template%solarZenith(surfIndex,instance), &
            & date=quantity%template%time(surfIndex,instance))
          if ( newValue >= nearest ( grid%missingValue, -1.0 ) .and. &
            &  newValue <= nearest ( grid%missingValue,  1.0 ) .and. &
            & .not. allowMissing ) errorCode = MissingDataInGrid
          quantity%values(surf,instance) = newValue
        end do                            ! End surface loop
      end do                              ! End instance loop
    end subroutine FillVectorQuantityFromGrid

    !=============================== FillVectorQuantityFromL2GP ==========
    subroutine FillVectorQuantityFromL2GP ( quantity,l2gp, interpolate, profile, &
      & errorCode, ignoreGeolocation, fromPrecision )
      use MLSNumerics, only: COEFFICIENTS_R8, INTERPOLATEARRAYSETUP, &
        & INTERPOLATEARRAYTEARDOWN

      ! If the times, pressures, and geolocations match, fill the quantity with
      ! the appropriate subset of profiles from the l2gp

      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (L2GPData_T), intent(in), target :: L2GP ! L2GP to fill from
      logical, intent(in) :: interpolate  ! Flag
      integer, intent(in) :: profile    ! Single profile to use or -1 for default
      integer, intent(out) :: errorCode ! Error code
      logical, intent(in) :: ignoreGeolocation  ! Flag
      logical, intent(in) :: fromPrecision ! Flag

      ! Local parameters
      real(r8), parameter :: FTOL = 1.0e-3 ! 1 kHz
      real(r8), parameter :: TOLERANCE=0.05 ! Tolerence for angles
      real(r8), parameter :: TIMETOL=5.0  ! Tolerence for time (not sure why this
      ! needs to be so big !????????? NJL)

      ! Local variables
      integer ::    FIRSTPROFILE, LASTPROFILE
      integer, dimension(1) :: FIRSTPROFILEASARRAY
      integer :: INSTANCE               ! Loop counter
      integer :: THISPROFILE            ! Index
      type (Coefficients_R8) :: COEFFS  ! For interpolation
      real (r8), dimension(quantity%template%noSurfs) :: outZeta
      real (r4), dimension(:,:,:), pointer :: SOURCE

      call MLSMessageCalls( 'push', constantName='FillVectorQuantityFromL2GP' )
      errorCode=0
      ! Make sure this quantity is appropriate
      if ( .not. ValidateVectorQuantity(quantity, coherent=.TRUE., stacked=.TRUE., &
        & verticalCoordinate= (/ l_pressure, l_zeta /) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity to fill is not on pressure or zeta coordinates' )

      if ( (quantity%template%noChans/=l2gp%nFreqs) .and. &
        &  ((quantity%template%noChans/=1) .or. (l2gp%nFreqs/=0)) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity and l2gp have different number of channels' )
!       call dump ( l2gp%frequency, 'l2gp' )
!       call dump ( quantity%template%frequencies, 'quantity' )
!       if ( associated ( quantity%template%frequencies ) ) then
!         if ( any ( abs ( l2gp%frequency - &
!           & quantity%template%frequencies ) > fTol ) ) &
!           & call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & 'Quantity and l2gp have different frequency grids' )
!       end if

      if ( quantity%template%noSurfs /= l2gp%nLevels .and. (.not. interpolate) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity and l2gp have different number of surfaces (set interpolate?)' )

      if ( .not. interpolate ) then
        if ( quantity%template%verticalCoordinate == l_pressure ) then
          if ( any(ABS(-LOG10(quantity%template%surfs(:,1))+ &
            & LOG10(l2gp%pressures)) > TOLERANCE) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Quantity and l2gp are on different surfaces (set interpolate?)' )
        else                                ! Must be l_zeta
          if ( any(ABS(quantity%template%surfs(:,1)+ &
            & LOG10(l2gp%pressures)) > TOLERANCE) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Quantity and l2gp are on different surfaces (set interpolate?)' )
        end if
      end if

      ! Skip the position checks if we're forcing in a particular profile.
      firstProfile = 1
      lastProfile=firstProfile+quantity%template%noInstances-1
      if ( (profile == -1) .and. (.not. ignoreGeolocation) ) then
        ! Attempt to match up the first location
        firstProfileAsArray=minloc(abs(quantity%template%phi(1,1)-l2gp%geodAngle))
        firstProfile=firstProfileAsArray(1)

        ! Well, the last profile has to be noInstances later, check this would be OK
        lastProfile=firstProfile+quantity%template%noInstances-1
        if ( lastProfile > l2gp%nTimes ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Quantity has profiles beyond the end of the l2gp' )

        ! Now check that geodAngle's are a sufficient match
        if ( any(abs(l2gp%geodAngle(firstProfile:lastProfile)-&
          &         quantity%template%phi(1,:)) > tolerance) ) then
          call dump ( l2gp%geodAngle(firstProfile:lastProfile), 'L2GP geodetic angle' )
          call dump ( quantity%template%phi(1,:), 'Quantity Geodetic angle' )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Quantity has profiles that mismatch l2gp in geodetic angle' )
        end if

        ! Now check that the times match
        if ( any(abs(l2gp%time(firstProfile:lastProfile)- &
          &         quantity%template%time(1,:)) > timeTol) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Quantity has profiles that mismatch l2gp in time' )

        ! Currently the code cannot interpolate in 3 dimensions, wouldn't
        ! be hard to code up, but no need as yet.
        if ( interpolate .and. quantity%template%noChans /= 1 ) then
          errorCode=cantInterpolate3D
          return
        end if
      else
        ! Given a specific profile, check it's legal
        if ( profile == 0 .or. profile > l2gp%nTimes ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Illegal profile request in l2gp fill' )
      end if

      ! OK, things seem to be OK, so start getting the data
      if ( fromPrecision ) then
        source => l2gp%l2gpPrecision
      else
        source => l2gp%l2gpValue
      end if

      ! OK, now do the filling, it's easier if we don't have to interpolate
      if ( .not. interpolate ) then
        if ( profile == -1 ) then
          ! Not forcing a particular profile to all instances
          quantity%values=reshape(source(:,:,firstProfile:lastProfile),&
            & (/quantity%template%noChans*quantity%template%noSurfs,&
            &   quantity%template%noInstances/))
        else
          ! Spread one profile onto all instances
          quantity%values = spread ( reshape ( source(:,:,profile), &
            &   (/ quantity%template%noChans*quantity%template%noSurfs/) ), &
            & 2, quantity%template%noInstances )
        end if
      else
        if ( quantity%template%verticalCoordinate == l_pressure ) then
          outZeta = -log10 ( quantity%template%surfs(:,1) )
        else
          outZeta = quantity%template%surfs(:,1)
        end if
        ! Setup the interpolation we'll be doing.
        call InterpolateArraySetup ( -log10(real(l2gp%pressures, r8)), &
          & outZeta, 'Linear', coeffs, extrapolate='Clamp' )
        do instance = 1, quantity%template%noInstances
          if ( profile == -1 ) then
            thisProfile = firstProfile + instance - 1
          else
            thisProfile = profile
          end if
          ! Guess I don't really need the loop here, but it
          ! does make the spread stuff much easier, and the setup/teardown
          ! at least makes it more efficient.
          call InterpolateValues ( coeffs, &
            & -log10(real(l2gp%pressures, r8)), &  ! Old X
            & real(source(1,:,thisProfile), r8), & ! OldY
            & outZeta, & ! New X
            & quantity%values(:,instance), & ! New Y
            & method='Linear', extrapolate='Clamp' )
        end do
        call InterpolateArrayTeardown ( coeffs )
      end if
      call MLSMessageCalls( 'pop' )

    end subroutine FillVectorQuantityFromL2GP

    ! -------------------------------------- FillVectorQuantityFromProfile --
    subroutine FillVectorQtyFromProfile ( quantity, valuesNode, &
      & instancesNode, globalUnit, dontMask, logSpace )
      ! This fill is slightly complicated.  Given a values array along
      ! the lines of [ 1000mb : 1.0K, 100mb : 1.0K,  10mb : 2.0K] etc. it
      ! does the linear interpolation appropriate to perform the fill.
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      integer, intent(in) :: VALUESNODE   ! Tree node for values
      integer, intent(in) :: INSTANCESNODE ! Tree node for instances
      integer, intent(in) :: GLOBALUNIT   ! Possible global unit
      logical, intent(in) :: DONTMASK     ! If set don't follow the fill mask
      logical, intent(in), optional :: LOGSPACE ! Interpolate in logspace

      ! Local variables
      integer :: C                      ! Channel loop counter
      integer :: HEIGHTUNIT             ! Unit for height
      integer :: NOPOINTS               ! Number of points supplied
      integer :: NOUNIQUE               ! Number of unique heights supplied
      integer :: I,J                    ! Loop counters / indices
      integer :: S                      ! Surface loop counter
      integer :: STATUS                 ! Flag
      integer :: TESTUNIT               ! Unit for value
      logical :: Fail                   ! Status from Hunt
      logical :: LOCALOUTHEIGHTS ! Set if out heights is our own variable
      logical :: MYLOGSPACE             ! Interpolate in log space?
      real (r8), dimension(:), pointer :: HEIGHTS ! Heights for the points
      real (r8), dimension(:), pointer :: VALUES ! Values for the points
      real (r8), dimension(:), pointer :: OUTHEIGHTS ! Heights for output
      real (r8), dimension(:), pointer :: OUTVALUES ! Single profile for output
      logical, dimension(:), pointer :: INSTANCES ! Flags
      logical, dimension(:), pointer :: DUPLICATED ! Flags
      real (r8), dimension(2) :: EXPRVALUE ! Value of expression
      integer, dimension(2) :: EXPRUNIT   ! Unit for expression
      integer, dimension(:), pointer :: ININDS ! Indices

      ! Executable code
      call MLSMessageCalls( 'push', constantName='FillVectorQtyFromProfile' )

      ! Check the quantity is amenable to this type of fill
      if ( .not. ValidateVectorQuantity ( quantity, &
        & coherent=.true. ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The quantity is not amenable to a profile fill' )

      ! Check the units
      testUnit = quantity%template%unit
      if ( globalUnit /= phyq_Invalid ) testUnit = globalUnit

      ! Set some stuff up
      myLogSpace = quantity%template%logBasis
      if ( present ( logSpace ) ) myLogSpace = logSpace
      noPoints = nsons ( valuesNode ) - 1
      nullify ( heights, values, duplicated, outHeights, outValues, instances )
      call Allocate_test ( heights, noPoints, 'heights', ModuleName )
      call Allocate_test ( values, noPoints, 'values', ModuleName )
      call Allocate_test ( duplicated, noPoints, 'duplicated', ModuleName )
      call Allocate_test ( outValues, quantity%template%noSurfs, &
        & 'outValues', ModuleName )
      call Allocate_test ( instances, quantity%template%noInstances, &
        & 'instances', ModuleName )

      ! Loop over the values
      do i = 1, noPoints
        ! Get value from tree
        call expr ( subtree ( i+1, valuesNode ), exprUnit, exprValue )
        ! Check height unit OK
        heightUnit = GetUnitForVerticalCoordinate ( quantity%template%verticalCoordinate )
        if ( exprUnit(1) /= heightUnit .and. exprUnit(1) /= PHYQ_Dimensionless &
          & .and. .not. ( exprUnit(1) == PHYQ_Pressure .and. heightUnit == PHYQ_Zeta ) ) &
          & call Announce_error ( valuesNode, no_Error_Code, 'Bad height units for profile fill' )
        ! Store height
        if ( heightUnit == PHYQ_Zeta ) then
          ! Assume zeta coordinates are expressed in mb
          heights(i) = -log10 ( exprValue(1) )
        else
          heights(i) = exprValue(1)
        end if
        ! Check value unit OK
        if ( all ( exprUnit(2) /= (/ testUnit, PHYQ_Dimensionless /) ) ) &
          & call Announce_error ( valuesNode, no_error_code, 'Bad units for profile fill' )
        ! Store value
        values ( i ) = exprValue(2)
      end do

      if ( myLogSpace .and. any ( values <= 0.0 ) ) then
        call Announce_Error ( valuesNode, no_error_code, &
          & 'Non-positive input data in log profile fill' )
        return
      end if
      if ( myLogSpace ) values = log ( values )

      ! Get the appropriate height coordinate for output, for pressure take log.
      if ( quantity%template%verticalCoordinate == l_pressure ) then
        localOutHeights = .true.
        call Allocate_test ( outHeights, quantity%template%noSurfs, &
          & 'outHeights', ModuleName )
        outHeights = -log10 ( quantity%template%surfs(:,1) )
      else
        localOutHeights = .false.
        outHeights => quantity%template%surfs(:,1)
      end if

      ! Now, if the quantity is coherent, let's assume the user wanted the
      ! 'nearest' values
      if ( quantity%template%coherent ) then
        nullify ( inInds )
        call allocate_test ( inInds, noPoints, 'inInds', ModuleName )
        call hunt ( outHeights, heights, inInds, &
          & nearest=.true., allowTopValue=.true., fail=fail )
        if ( fail ) then
          call Announce_Error ( valuesNode, no_error_code, &
          & 'Problem in Hunt' )
        return
      end if
        duplicated = .false.
        do i = 1, noPoints - 1
          do j = i + 1, noPoints
            if ( inInds(i) == inInds(j) ) then
              duplicated ( j ) = .true.
            end if
          end do
        end do
        noUnique = count ( .not. duplicated )
        inInds(1:noUnique) = pack ( inInds, .not. duplicated )
        heights(1:noUnique) = outHeights ( inInds(1:noUnique) )
        values(1:noUnique) = pack ( values, .not. duplicated )
        call deallocate_test ( inInds, 'inInds', ModuleName )
      end if

      ! Now do the interpolation for the first instance
      call InterpolateValues ( heights(1:noUnique), values(1:noUnique), outHeights, &
        & outValues, 'Linear', extrapolate='Constant' )

      if ( myLogSpace ) outValues = exp ( outValues )

      ! Work out what instances we're going to spread this to
      instances = .true.
      if ( instancesNode /= 0 ) then
        call GetIndexFlagsFromList ( instancesNode, instances, &
          & status, noError = .true. )
        if ( status /= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unable to parse instances (wrong units?)' )
      end if

      ! Spread it into the other instances, worry about the mask and instances
      do i = 1, quantity%template%noInstances
        if ( instances(i) ) then
          j = 1
          do s = 1, quantity%template%noSurfs
            do c = 1, quantity%template%noChans
              if ( associated(quantity%mask) .and. .not. dontMask ) then
                if ( iand ( ichar(quantity%mask(j,i)), m_fill ) == 0 ) &
                  & quantity%values(j,i) = outValues(s)
              else
                quantity%values(j,i) = outValues(s)
              end if
              j = j + 1
            end do
          end do
        end if
      end do

      ! Finish off
      if ( localOutHeights ) call Deallocate_test ( outHeights, &
        & 'outHeights', ModuleName )
      call Deallocate_test ( heights, 'heights', ModuleName )
      call Deallocate_test ( values, 'values', ModuleName )
      call Deallocate_test ( duplicated, 'duplicated', ModuleName )
      call Deallocate_test ( outValues, 'outValues', ModuleName )
      call Deallocate_test ( instances, 'instances', ModuleName )
      call MLSMessageCalls( 'pop' )
    end subroutine FillVectorQtyFromProfile

    ! ------------------------------------------- FillLOSVelocity ---
    subroutine FillLOSVelocity ( key, qty, tngtECI, scECI, scVel)
      ! A special fill from geometry arguments
      use Geometry, only: OMEGA => W
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) :: TNGTECI
      type (VectorValue_T), intent(in) :: SCECI
      type (VectorValue_T), intent(in) :: SCVEL


      ! Local variables
      integer :: MAF                      ! Loop counter
      integer :: MIF                      ! Loop counter
      integer :: noMAFs                   ! Number of major frames
      integer :: noMIFs                   ! Number of minor frames for this module
      integer :: x,y,z                    ! Indicies into the vectors

      real (r8), dimension(3) :: tngtVel   ! Due to rotation of earth
      real (r8), dimension(3) :: los       ! Normalised line of sight vector

      ! Executable code
      ! First check that things are OK.
      if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_losVel/), &
        & minorFrame=.true., &
        & frequencyCoordinate=(/l_none/) ) ) call Announce_Error ( key, No_Error_Code, &
        & 'Quantity to fill is not a valid LOS Velocity' )
      if ( .not. ValidateVectorQuantity ( tngtECI, &
        & quantityType=(/l_tngtECI/), &
        & minorFrame=.true., &
        & frequencyCoordinate=(/l_xyz/) ) ) call Announce_Error ( key, No_Error_Code, &
        & 'Tangent ECI quantity is not of an appropriate form' )
      if ( .not. ValidateVectorQuantity ( scECI, &
        & quantityType=(/l_scECI/), &
        & minorFrame=.true., &
        & frequencyCoordinate=(/l_xyz/) ) ) call Announce_Error ( key, No_Error_Code, &
        & 'Spacecraft ECI quantity is not of an approriate form' )
      if ( qty%template%instrumentModule /= tngtECI%template%instrumentModule ) &
        & call Announce_Error ( key, No_Error_Code, &
        & 'LOS Velocity and Tangent ECI quantities are not for the same module' )
      if ( .not. IsModuleSpacecraft ( scECI%template%instrumentModule ) ) &
        & call Announce_Error ( key, No_Error_Code, &
        & 'Spacecraft ECI quantity is not for the spacecraft' )

      noMAFs = qty%template%noInstances
      noMIFs = qty%template%noSurfs

      do maf = 1, noMAFs
        do mif = 1, noMIFs

          ! First compute the tangent point velocity in ECI coordinates due
          ! to the rotation of the earth.  This no doubt makes approximations
          ! due to the slight non alignment between the earth's rotation axis and
          ! the ECI z axis, but I'm going to ignore this.

          ! Work out the indices in 3*mif,maf space
          x = 1 + 3*(mif-1)
          y = x+1
          z = x+2

          tngtVel= omega* (/ -tngtECI%values(y,maf), &
            &                 tngtECI%values(x,maf), 0.0_r8 /)

          ! Now compute the line of sight direction normal
          los = tngtECI%values(x:z,maf) - scECI%values(x:z,maf)
          los = los / sqrt(sum(los**2))

          ! Now compute the net velocity in this direction.  For the moment I'll
          ! assume +ve means the sc and tp are moving apart, and -ve that they're
          ! getting closer.

          qty%values(mif,maf) = dot_product(tngtVel, los) - &
            &                   dot_product(scVel%values(x:z,maf), los)

          ! Note that even though x,y,z have been used up to now for a GHz/THz
          ! minor frame quantity, they're OK with this sc one too.
        end do
      end do
    end subroutine FillLOSVelocity

    ! ------------------------------------------- FillableChiSq ---
    function FillableChiSq ( qty, measQty, modelQty, noiseQty ) result ( aok )
      ! Purpose (A)
      !   Check whether we may proceed with special fill of chi squared
      !   case where all VectorValue_T args present
      ! Purpose (B)
      !   Check whether we may proceed with special fill of addNoise
      !   case where missing noiseQty arg
      type (VectorValue_T), intent(in) ::              QTY
      type (VectorValue_T), intent(in) ::              modelQty
      type (VectorValue_T), intent(in) ::              measQty
      type (VectorValue_T), optional, intent(in) ::    noiseQty
      LOGICAL ::                                       AOK

      ! What we will check is that (for the args we have been given):
      ! (0) all quantities have associated values
      ! (1) all quantities have same molecule
      ! (2) all quantities have same signal
      ! (3) all quantities have same HGrid
      ! (4A) all but qty (chiSq) have same VGrid
      ! (4B) all have same VGrid
      ! Ah, but radiances have no VGrid or HGrid,
      ! and molecule should be part of signal, so
      ! if radiances need only check on signal
      ! if vmr, check on others

     ! Local variables
      LOGICAL ::       minorFrame   ! TRUE if radiances, FALSE if vmr

      aok = .true.

      ! (0)
      if ( present(noiseQty) ) then
        aok = associated(noiseQty%values)
        if ( DEEBUG .and. .not. associated(noiseQty%values) ) &
          & call announce_error( no_Error_Code, No_Error_code, &
          & 'Noise values unassociated in FillableChiSq')
      end if
      aok = aok .and. &
        & associated(qty%values) .and. &
        & associated(measQty%values) .and. &
        & associated(modelQty%values)

      if ( DEEBUG ) then
        if ( .not. associated(qty%values) ) &
          & call announce_error( no_Error_Code, No_Error_code, &
          & 'Quantity values unassociated in FillableChiSq')
        if ( .not. associated(measQty%values) ) &
          & call announce_error( no_Error_Code, No_Error_code, &
          & 'Measurements values unassociated in FillableChiSq')
        if ( .not. associated(modelQty%values) ) &
          & call announce_error( no_Error_Code, No_Error_code, &
          & 'Model values unassociated in FillableChiSq')
      end if

      if ( .not. aok ) return

      minorFrame = qty%template%minorFrame .or. qty%template%majorFrame
      ! (1)
      if ( .not. minorFrame ) then
        aok = aok .and. &
          & (qty%template%molecule == measQty%template%molecule) &
          & .and. &
          & (qty%template%molecule == modelQty%template%molecule)
        if ( present(noiseQty) ) aok = aok &
          & .and. &
          & (qty%template%molecule == noiseQty%template%molecule)
      end if

      ! (2)
      if ( minorFrame ) then
        aok = aok .and. &
          & (qty%template%signal == measQty%template%signal) &
          & .and. &
          & (qty%template%signal == modelQty%template%signal)
        if ( present(noiseQty) ) aok = aok &
          & .and. &
          & (qty%template%signal == noiseQty%template%signal)
      end if

      ! (3)
      if ( .not. minorFrame ) then
        aok = aok .and. &
          & DoHgridsMatch( qty, measQty ) &
          & .and. &
          & DoHgridsMatch( qty, modelQty )
        if ( present(noiseQty) ) aok = aok &
          & .and. &
          & DoHgridsMatch( qty, noiseQty )

        ! (4)
        aok = aok .and. &
          & DoVgridsMatch( measqty, modelQty )
        if ( present(noiseQty) ) then
          aok = aok &
          & .and. &
          & DoVgridsMatch( measqty, noiseQty )
        else
          aok = aok &
          & .and. &
          & DoVgridsMatch( measqty, Qty )
        end if
      end if

      return
    end function FillableChiSq

    ! ------------------------------------------- FillChiSqChan ---
    subroutine FillChiSqChan ( key, qty, measQty, modelQty, noiseQty, &
    & dontMask, ignoreZero, ignoreNegative, multiplier, &
    & firstInstance, lastInstance )
      ! A special fill of chi squared
      ! broken out according to channels
      ! Formal arguments
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) ::    modelQty
      type (VectorValue_T), intent(in) ::    measQty
      type (VectorValue_T), intent(in) ::    noiseQty
      logical, intent(in)           ::       dontMask    ! Use even masked values
      logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
      logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
      real, dimension(:), intent(in), optional :: multiplier

      integer, intent(in), optional ::       firstInstance, lastInstance
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in qty

      ! Local variables
      real(r8), dimension(:), pointer  ::    VALUES => NULL()
      integer ::                             UseFirstInstance, UseLastInstance, &
      &                                      NoOutputInstances
      integer ::                             C           ! Channel loop counter
      integer ::                             S           ! Surface loop counter
      integer ::                             I           ! Instances
      integer ::                             QINDEX
      integer ::                             NOCHANS
      integer ::                             N           ! Num. of summed values
      logical ::                             skipMe
      real                             ::    a, b

      ! Executable code

     ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
      if ( .not. present(multiplier) ) then
        a = 1.
        b = 1.
      else if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
        a = 1.
        b = 1.
      else if ( multiplier(2) == UNDEFINED_VALUE ) then
        a = 0.
        if ( multiplier(1) /= 0.0 ) a = 1.0/multiplier(1)
        b = a
      else
        a = multiplier(1)
        b = multiplier(2)
      end if

      ! First check that things are OK.
      if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_chiSqChan/), majorFrame=.true.) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Attempting to fill wrong quantity with chi^2 channelwise'  )
        if ( DEEBUG ) then
          call output('major frame? ', advance = 'no')
          call output(qty%template%majorFrame, advance = 'no')
          call output('   quantity type ', advance = 'no')
          call output(qty%template%quantityType, advance = 'no')
          call output('   compared with ', advance = 'no')
          call output(l_chiSqChan, advance = 'yes')
        end if
        return
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Incompatibility among vector quantities filling chi^2 channelwise'  )
        return
      else if ( any ( noiseQty%values == 0.0) .and. &
        & .not. (ignoreZero .or. .not. dontMask) ) then
        call Announce_error ( key, No_Error_code, &
        & 'A vanishing error filling chi^2 channelwise'  )
        return
      end if

      ! Work out what to do with the first and last Instance information

      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) return

      call allocate_test(values, measQty%template%noSurfs, &
        & 'chi^2 unsummed', ModuleName)
      noChans = qty%template%noChans
      do i=useFirstInstance, useLastInstance
        do c=1, noChans
          N = 0
          values = 0.0
          do s=1, measQty%template%noSurfs
            qIndex = c + (s-1)*nochans
            skipMe = &
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, qIndex, i) .or. &
            &   isVectorQtyMasked(modelQty, qIndex, i) .or. &
            &   isVectorQtyMasked(noiseQty, qIndex, i) ) &
            & .or. (ignoreNegative .and. noiseQty%values(qIndex, i) < 0.0 ) &
            & .or. (ignoreZero .and. noiseQty%values(qIndex, i) == 0.0 )
            if ( .not. skipMe ) then
              values(s) = ( &
              & (a*measQty%values(qIndex, i) - b*modelQty%values(qIndex, i)) &
              & / &
              & noiseQty%values(qIndex, i) &
              &  ) ** 2
              N = N + 1
            end if
          end do
          if ( N > 0 ) then
            qty%values(c, i) = sum(values) / N
          else
            qty%values(c, i) = 0.
          end if
        end do
      end do
      call deallocate_test(values, &
        & 'chi^2 unsummed', ModuleName)
    end subroutine FillChiSqChan

    ! ------------------------------------------- FillChiSqMMaf ---
    subroutine FillChiSqMMaf ( key, qty, measQty, modelQty, noiseQty, &
    & dontMask, ignoreZero, ignoreNegative, multiplier, &
    & firstInstance, lastInstance )
      ! A special fill of chi squared
      ! broken out according to major frames
      ! Formal arguments
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) ::    modelQty
      type (VectorValue_T), intent(in) ::    measQty
      type (VectorValue_T), intent(in) ::    noiseQty
      logical, intent(in)           ::       dontMask    ! Use even masked values
      logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
      logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
      real, dimension(:), intent(in), optional :: multiplier

      integer, intent(in), optional ::       firstInstance, lastInstance
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in the qty

      ! Local variables
      real(r8), dimension(:), pointer  ::    VALUES => NULL()
      integer ::                             UseFirstInstance, UseLastInstance, &
      &                                      NoOutputInstances
      integer ::                             I           ! Instances
      integer ::                             ROW         ! Running 1st coord
      integer ::                             INSTANCELEN ! Num of rows
      integer ::                             N           ! Num. of summed values
      logical ::                             skipMe

      ! Executable code
      real                             ::    a, b

      ! Executable code

     ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
      if ( .not. present(multiplier) ) then
        a = 1.
        b = 1.
      else if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
        a = 1.
        b = 1.
      else if ( multiplier(2) == UNDEFINED_VALUE ) then
        a = 0.
        if ( multiplier(1) /= 0.0 ) a = 1.0/multiplier(1)
        b = a
      else
        a = multiplier(1)
        b = multiplier(2)
      end if

      ! First check that things are OK.
      if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_chiSqMMaf/), majorFrame=.true.) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Attempting to fill wrong quantity with chi^2 MMAFwise'  )
        if ( DEEBUG ) then
          call output('major frame? ', advance = 'no')
          call output(qty%template%majorFrame, advance = 'no')
          call output('   quantity type ', advance = 'no')
          call output(qty%template%quantityType, advance = 'no')
          call output('   compared with ', advance = 'no')
          call output(l_chiSqMMaf, advance = 'yes')
        end if
        return
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Incompatibility among vector quantities filling chi^2 MMAFwise'  )
        return
      else if ( any ( noiseQty%values == 0.0) .and. &
        & .not. (ignoreZero .or. .not. dontMask) ) then
        call Announce_error ( key, No_Error_code, &
        & 'A vanishing noise filling chi^2 MMAFwise'  )
        return
      end if

      ! Work out what to do with the first and last Instance information

      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) return

      instanceLen = measQty%template%noChans * measQty%template%noSurfs
      call allocate_test(values, instanceLen, &
        & 'chi^2 unsummed', ModuleName)
      do i=useFirstInstance, useLastInstance
        if ( .not. (.not. dontMask .or. ignoreNegative .or. ignoreZero ) ) then
            values = ( &
            & (measQty%values(:, i) - modelQty%values(:, i)) &
            & / &
            & noiseQty%values(:, i) &
            &  ) ** 2
            qty%values(1, i) = sum(values) / instanceLen
        else
          N = 0
          values = 0.0
          do row = 1, instanceLen
            skipMe = &
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, row, i) .or. &
            &   isVectorQtyMasked(modelQty, row, i) .or. &
            &   isVectorQtyMasked(noiseQty, row, i) ) &
            & .or. (ignoreNegative .and. noiseQty%values(row, i) < 0.0 ) &
            & .or. (ignoreZero .and. noiseQty%values(row, i) == 0.0 )
            if ( .not. skipMe ) then
              values(row) = ( &
              & (a*measQty%values(row, i) - b*modelQty%values(row, i)) &
              & / &
              & noiseQty%values(row, i) &
              &  ) ** 2
              N = N + 1
            end if
          end do
          if ( N > 0 ) then
            qty%values(1, i) = sum(values) / N
          else
            qty%values(1, i) = 0.
          end if
        end if
      end do
      call deallocate_test(values, &
        & 'chi^2 unsummed', ModuleName)
    end subroutine FillChiSqMMaf

    ! ------------------------------------------- FillChiSqMMif ---
    subroutine FillChiSqMMif ( key, qty, measQty, modelQty, noiseQty, &
    & dontMask, ignoreZero, ignoreNegative, multiplier, &
    & firstInstance, lastInstance )
      ! A special fill of chi squared
      ! broken out according to Mifs
      ! Formal arguments
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) ::    modelQty
      type (VectorValue_T), intent(in) ::    measQty
      type (VectorValue_T), intent(in) ::    noiseQty
      logical, intent(in)           ::       dontMask    ! Use even masked values
      logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
      logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
      real, dimension(:), intent(in), optional :: multiplier

      integer, intent(in), optional ::       firstInstance, lastInstance
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in the qty

      ! Local variables
      real(r8), dimension(:), pointer  ::    VALUES => NULL()
      integer ::                             UseFirstInstance, UseLastInstance, &
      &                                      NoOutputInstances
      integer ::                             C           ! Channel loop counter
      integer ::                             S           ! Surface loop counter
      integer ::                             I           ! Instances
      integer ::                             QINDEX
      integer ::                             NOMIFS
      integer ::                             N           ! Num. of summed values
      logical ::                             skipMe

      ! Executable code
      real                             ::    a, b

      ! Executable code

     ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
      if ( .not. present(multiplier) ) then
        a = 1.
        b = 1.
      else if ( &
      & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
      & ) then
        a = 1.
        b = 1.
      else if ( multiplier(2) == UNDEFINED_VALUE ) then
        a = 0.
        if ( multiplier(1) /= 0.0 ) a = 1.0/multiplier(1)
        b = a
      else
        a = multiplier(1)
        b = multiplier(2)
      end if

      ! First check that things are OK.
      if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_chiSqMMif/), minorFrame=.true.) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Attempting to fill wrong quantity with chi^2 MMIFwise'  )
        if ( DEEBUG ) then
          call output('minor frame? ', advance = 'no')
          call output(qty%template%minorFrame, advance = 'no')
          call output('   quantity type ', advance = 'no')
          call output(qty%template%quantityType, advance = 'no')
          call output('   compared with ', advance = 'no')
          call output(l_chiSqMMif, advance = 'yes')
        end if
        return
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Incompatibility among vector quantities filling chi^2 MMIFwise'  )
        return
      else if ( any ( noiseQty%values == 0.0) .and. &
        & .not. (ignoreZero .or. .not. dontMask) ) then
        call Announce_error ( key, No_Error_code, &
        & 'A vanishing noise filling chi^2 MMIFwise'  )
        return
      end if

      ! Work out what to do with the first and last Instance information

      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) return

      call allocate_test(values, measQty%template%noChans, &
        & 'chi^2 unsummed', ModuleName)
      noMIFs = measQty%template%noSurfs
      do i=useFirstInstance, useLastInstance
        do s=1, noMIFs
          N = 0
          values = 0.0
          do c=1, measQty%template%noChans
            qIndex = c + (s-1)*measQty%template%noChans
            skipMe = &
            & .not. dontMask .and. ( &
            &   isVectorQtyMasked(measQty, qIndex, i) .or. &
            &   isVectorQtyMasked(modelQty, qIndex, i) .or. &
            &   isVectorQtyMasked(noiseQty, qIndex, i) ) &
            & .or. (ignoreNegative .and. noiseQty%values(qIndex, i) < 0.0 ) &
            & .or. (ignoreZero .and. noiseQty%values(qIndex, i) == 0.0 )
            if ( .not. skipMe ) then
              values(c) = ( &
              & (a*measQty%values(qIndex, i) - b*modelQty%values(qIndex, i)) &
              & / &
              & noiseQty%values(qIndex, i) &
              &  ) ** 2
              N = N + 1
            end if
          end do
          if ( N > 0 ) then
            qty%values(s, i) = sum(values) / N
          else
            qty%values(s, i) = 0.
          end if
        end do
      end do
      call deallocate_test(values, &
        & 'chi^2 unsummed', ModuleName)
    end subroutine FillChiSqMMif

    ! ------------------------------------------- FillChiSqRatio ---
    subroutine FillChiSqRatio ( key, qty, normQty, minNormQty, flagQty, &
    & dontMask, firstInstance, lastInstance )
      ! A special fill of the ratio
      !  chi squared Norm
      ! ----------------     [iter_n, *]
      ! chi squared Min Norm
      ! where iter_n is the final iteration number
      
      ! Note the following tricks:
      ! The number of surfaces is the maximum allowed number of iterations
      ! The actual number of iterations will be less than this
      ! After the last iteration, all "surfaces" above this are zero-filled
      
      ! The number of instances will be the number of chunks
      ! (yes, an unfortunate fact)
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(inout) ::    normQty
      type (VectorValue_T), intent(inout) ::    minNormQty
      type (VectorValue_T), intent(inout) ::    flagQty
      logical, intent(in)           ::       dontMask    ! Use even masked values

      integer, intent(in), optional ::       firstInstance, lastInstance
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in qty

      ! Local variables
      integer ::                             UseFirstInstance, UseLastInstance, &
      &                                      NoOutputInstances
      integer ::                             I           ! Instances
      integer ::                             ITER        ! Instances
      integer ::                             QINDEX
      integer ::                             NOCHANS
      logical ::                             skipMe
      logical, parameter ::                  FakeData = .false.

      ! Executable code

      ! First check that things are OK.
      if ( .not. ValidateVectorQuantity ( qty, &
        & quantityType=(/l_dnwt_chiSqRatio/) ) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Attempting to fill wrong quantity with chi^2 ratio'  )
        return
      elseif ( .not. ValidateVectorQuantity ( normqty, &
        & quantityType=(/l_dnwt_chiSqNorm/) ) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Attempting to fill using wrong norm quantity with chi^2 ratio'  )
        return
      elseif ( .not. ValidateVectorQuantity ( minnormqty, &
        & quantityType=(/l_dnwt_chiSqMinNorm/) ) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Attempting to fill using wrong min norm quantity with chi^2 ratio'  )
        return
      elseif ( .not. ValidateVectorQuantity ( flagqty, &
        & quantityType=(/l_dnwt_flag/) ) ) then
        call Announce_error ( key, No_Error_code, &
        & 'Attempting to fill using wrong flag quantity with chi^2 ratio'  )
        return
      end if

      ! Work out what to do with the first and last Instance information

      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) return

      noChans = qty%template%noChans
      do i=useFirstInstance, useLastInstance
        if ( FakeData ) then
          ! Let's just fake up some data here
          flagQty%values(:,i) = 0._rv
          normQty%values(:,i) = 0._rv
          minNormQty%values(:,i) = 0._rv
          ! Say we converged at iteration number 5
          qIndex = 5
          flagQty%values(:qIndex,i) = -2._rv
          minNormQty%values(:qIndex,i) = -2._rv
          do iter = 1, qIndex
            minNormQty%values(iter, i) = 1.1
            normQty%values(iter, i) = 1.1 + 0.05*(qIndex+1-iter)
          enddo
        endif
        ! Now find the iteration number
        qIndex = findLast( flagQty%values(:,i) /= 0._rv )
        if ( qIndex == 0 .or. qIndex >= qty%template%noSurfs ) cycle
        skipMe = &
          & .not. dontMask .and. ( &
          &   isVectorQtyMasked(normQty, qIndex, i) .or. &
          &   isVectorQtyMasked(minNormQty, qIndex, i) .or. &
          &   minNormQty%values(qIndex, i) == 0. &
          & )
          qty%values(:,i) = &
            & normQty%values(qIndex, i) / minNormQty%values(qIndex, i)
      end do
    end subroutine FillChiSqRatio

    ! ------------------------------------------- FillColAbundance ---
    subroutine FillColAbundance ( key, qty, bndPressQty, vmrQty, colmAbUnits, &
      & firstInstance, lastInstance )
      ! A special fill according to W.R.Read's idl code
      ! Similar to his hand-written notes, but with a small correction

      ! Assumptions:
      ! (See above)
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) :: BNDPRESSQTY
      type (VectorValue_T), intent(in) :: VMRQTY
      integer, intent(in) :: colmAbUnits
      integer, intent(in), optional :: FIRSTINSTANCE
      integer, intent(in), optional :: LASTINSTANCE
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in the column data.

      ! Local parameters
      real(r8) :: LN10         ! = LOG(10.d0)
      real(r8), parameter :: INVERMGPPMV = 0.789 ! in DU / (ppmv hPa)
      real(r8), parameter :: INVERMGDU = INVERMGPPMV*1.d6 ! in DU / (vmr hPa)
      real(r8), parameter :: INVERMGMOLCM2 = INVERMGDU*2.687d16 ! in mol / cm^2

      ! Local variables
      logical :: printMe
      integer :: SURFACE
      integer :: INSTANCE
      integer :: FIRSTSURFACEABOVE
      integer :: FIRSTSURFACEBELOW
      integer :: USEFIRSTINSTANCE
      integer :: USELASTINSTANCE
      integer :: N
      integer :: NOOUTPUTINSTANCES
      real (r8) :: THISBNDPRESS
      real (r8) :: zeta            ! -log(THISBNDPRESS)
      real (r8) :: zetaTmp
      real (r8) :: COLUMNSUM
      real (r8) :: TRAPEZOIDSUM
      real (r8) :: DELTAZETA      ! Zetai[s+1] - Zetai[s]
      real (r8) :: INVERMG
      real (r8)                        :: Zetaa
      real (r8), pointer, dimension(:) :: Zetab
      real (r8), pointer, dimension(:) :: Zetac
      real (r8)                        :: Zetad
      real (r8), pointer, dimension(:) :: Zetai
      real (r8)                        :: Pa         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pb         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pc         ! p[i] in hPa
      real (r8)                        :: Pd         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pi         ! p[i] in hPa

      ! Executable code
      LN10 = LOG(10.d0)  ! Compiler won't let this be a parameter
      ! First check that things are OK.
      if ( (qty%template%quantityType /= l_columnAbundance) .or. &
        &  (bndPressQty%template%quantityType /= l_boundaryPressure) .or. &
        &  (vmrQty%template%quantityType /= l_vmr) ) then
        call Announce_error ( key, No_Error_code, &
          & 'Wrong quantity type found while filling column abundance'  )
        return
      else if ( qty%template%molecule /= vmrQty%template%molecule ) then
        call Announce_error ( key, No_Error_code, &
          & 'Attempt to fill column abundance with different molecule'  )
        return
      else if ( .not. ( DoHgridsMatch( qty, vmrQty ) .and. &
        & DoHgridsMatch( qty, bndPressQty ) ) ) then
        call Announce_error ( key, No_Error_code, &
          & 'Attempt to fill column abundance with different HGrids'  )
        return
      else if ( .not. any(vmrQty%template%verticalCoordinate == &
        & (/l_zeta/)) ) then
        call Announce_error ( key, No_Error_code, &
          & 'Fill column abundance, but vmr not on zeta surfs.'  )
        return
      else if ( vmrQty%template%noSurfs < 2 ) then
        call Announce_error ( key, No_Error_code, &
          & 'Fill column abundance, but too few vmr surfaces'  )
        return
      end if
      select case (colmAbUnits)
      case (l_DobsonUnits)
        INVERMG = INVERMGDU
      case (l_DU)
        INVERMG = INVERMGDU
      case (l_molcm2)
        INVERMG = INVERMGMOLCM2
      case default
        call Announce_error ( key, No_Error_code, &
          & 'Fill column abundance, but wrong units.'  )
      end select
      ! Work out what to do with the first and last Instance information
      useFirstInstance = 1
      useLastInstance = qty%template%noInstances
      if ( present ( firstInstance ) ) useFirstInstance = firstInstance
      if ( present ( lastInstance ) ) useLastInstance = lastInstance
      noOutputInstances = useLastInstance-useFirstInstance+1

      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) return

      nullify ( Zetab, Zetac, Zetai, pb, pc, pi )
      call allocate_test ( Zetab, vmrQty%template%noSurfs, 'Zetab', ModuleName )
      call allocate_test ( Zetac, vmrQty%template%noSurfs, 'Zetac', ModuleName )
      call allocate_test ( Zetai, vmrQty%template%noSurfs, 'Zetai', ModuleName )
      call allocate_test ( pb, vmrQty%template%noSurfs, 'pb', ModuleName )
      call allocate_test ( pc, vmrQty%template%noSurfs, 'pc', ModuleName )
      call allocate_test ( pi, vmrQty%template%noSurfs, 'pi', ModuleName )
      Zetai = vmrQty%template%surfs(:,1)
      pi = 10.0 ** ( -Zetai  )
      N = vmrQty%template%noSurfs
      do instance = useFirstInstance, useLastInstance
        printMe = ( instance == useFirstInstance) .and. &
         & (switchDetail(switches, 'column') > -1 )
        if ( printMe ) print *, 'switches: ', trim(switches)
        if ( printMe ) &
          & print *, 'switchDetail(switches, column) ', switchDetail(switches, 'column')
        ! Find 1st surface at or above tropopause
        ! (i.e., at a pressure equal to or less than boundaryPressure)
        ! This next check should be unnecessary--the HGrids were already matched
        if ( instance > size(bndPressQty%values, 2) ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Cant fill column--instance outside b.pres. range' )
          call deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
          return
        end if
        thisBndPress = bndPressQty%values(1,instance)
        ! In case where WMO algorithm failed, use bottom of basis
        if ( thisBndPress <= 0.0 ) &
          & thisBndPress = 10.0 ** ( - vmrQty%template%surfs(1,1) )
        if ( thisBndPress <= 0._r8 ) then
          call Announce_error ( key, No_Error_code, &
          & 'Fill column abundance, illegal bound. pr. at this instance' )
        end if
        zeta = -log10 ( thisBndPress )
        Zetaa = max(Zetai(N), zeta)
        do surface=1, N
          Zetab(surface) = Zetai(min(surface+1,N))
        end do
        do surface=1, N
          Zetab(surface) = min(max(zeta, Zetai(surface)), Zetab(surface))
          zetaTmp = zeta
          if ( surface > 1 ) zetaTmp = max(zeta, Zetai(surface-1))
          Zetac(surface) = min(zetaTmp, Zetai(surface))
        end do
        Zetad = min(Zetai(1), zeta)
        Pa = 10. ** (-Zetaa)
        Pb = 10. ** (-Zetab)
        Pc = 10. ** (-Zetac)
        Pd = 10. ** (-Zetad)
        if ( printMe ) then
          call output ( 'zeta: ', advance='no')
          call output ( zeta, advance='yes')
          call output ( 'zetaA: ', advance='no')
          call output ( zetaA, advance='yes')
          call output ( 'zetaD: ', advance='no')
          call output ( zetaD, advance='yes')
          call output ( 'PA: ', advance='no')
          call output ( PA, advance='yes')
          call output ( 'PD: ', advance='no')
          call output ( PD, advance='yes')
          call output ( 'zetaI   zetaB     zetaC      Pi   Pb   Pc', advance='yes')
          do surface=1, N
            call output( (/ zetai(surface), zetab(surface), zetac(surface), &
             & Pi(surface), Pb(surface), Pc(surface)/) , advance='yes')
          end do
        end if
        ! Find 1st surface immediately above tropopause
        firstSurfaceAbove = FindFirst (Pi < thisBndPress)
        if ( firstSurfaceAbove < 1 ) then
          call output ( 'tropopause: ', advance='no')
          call output ( thisBndPress, advance='yes')
          call output ( 'p0 ', advance='no')
          call output ( Pi(1), advance='yes')
          call output ( 'pTop ', advance='no')
          call output ( Pi(N), advance='yes')
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Filling column, but tropopause outside pres. surfaces' )
          firstSurfaceBelow = 1
        else if ( firstSurfaceAbove == 1 ) then
          ! Nothing special
          firstSurfaceBelow = 1
        else if ( firstSurfaceAbove > N ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Cant column, tropopause above top surface' )
          call deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
          return
        else  ! Nothing special
          firstSurfaceBelow = firstSurfaceAbove - 1
        end if
        if ( printMe ) then
          print *, 'thisBndPress: ', thisBndPress
          print *, 'firstSurfaceAbove: ', firstSurfaceAbove
          print *, 'firstSurfaceBelow: ', firstSurfaceBelow
        end if
        ! Do summation
        columnSum = vmrQty%values(N, instance) * Pa  ! Initialize sum
        if ( printMe ) then
          print *, 'columnSum: ', columnSum
          trapezoidSum = 0.
          do surface=firstSurfaceAbove, N-1
            trapezoidsum = trapezoidsum + 0.5 * ( &
              & vmrQty%values(surface, instance) + vmrQty%values(surface+1, instance) &
              & ) * ( Pi(surface+1)-Pi(surface))
          end do
        end if
        ! Loop over surfaces from 1 to uppermost-1
        do surface = 1, N-1
          deltaZeta = Zetai(surface+1) - Zetai(surface)
          if ( deltaZeta == 0._r8 ) cycle
          columnSum = columnSum + &
            & vmrQty%values(surface, instance) / deltaZeta * &
            & ( &
            & Pb(surface)*(Zetai(surface+1)-Zetab(surface)) &
            & + &
            & (Pi(surface+1) - Pb(surface))/ln10 &
            & )
        if ( printMe ) print *, 'columnSum: ', columnSum, surface
        end do
        ! Loop over surfaces from 2 to uppermost
        do surface = 2, N
          deltaZeta = Zetai(surface) - Zetai(surface-1)
          if ( deltaZeta == 0._r8 ) cycle
          columnSum = columnSum + &
            & vmrQty%values(surface, instance) / deltaZeta * &
            & ( &
            & Pc(surface)*(Zetac(surface)-Zetai(surface)) &
            & + &
            & (Pc(surface) - Pi(surface))*(1./ln10 + deltaZeta) &
            & )
          ! columnSum = columnSum + &
          ! & vmrQty%values(surface, instance) / deltaZeta * &
          ! & ( &
          ! & Pc(surface)*(Zetac(surface)-Zetai(surface)) &
          ! & + &
          ! & (Pc(surface) - Pi(surface))/ln10 &
          ! & )
        if ( printMe ) print *, 'columnSum: ', columnSum, surface
        end do
        columnSum = columnSum + vmrQty%values(1, instance) * (Pd - Pi(1))
        if ( printMe ) print *, 'columnSum: ', columnSum
        if ( printMe ) print *, 'trapezoid: ', -trapezoidSum
        qty%values ( 1, instance ) = InverMg * columnSum
      end do
      call deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)
    end subroutine FillColAbundance

    ! ------------------------------------- FillFoldedRadiance ---
    subroutine FillFoldedRadiance ( radiance, lsb, usb, &
      & lsbFraction, usbFraction, key )
      type (VectorValue_T), intent(inout) :: RADIANCE
      type (VectorValue_T), pointer :: USB
      type (VectorValue_T), pointer :: LSB
      type (VectorValue_T), pointer :: USBFRACTION
      type (VectorValue_T), pointer :: LSBFRACTION
      integer, intent(in) :: KEY

      ! Local variables
      integer :: C                        ! Channel loop inductor
      integer :: I                        ! Array index
      integer :: MIF                      ! Minor frame loop inductor

      ! Executable code
      ! First some sanity checks
      if ( .not. ValidateVectorQuantity ( radiance, quantityType=(/l_radiance/), &
        & sideband=(/0/), minorFrame=.true. )) &
        & call Announce_Error ( key, no_error_code, 'Inappropriate radiance quantity to fill' )
      if ( ( associated ( lsb ) .neqv. associated ( lsbFraction ) ) .or. &
        &  ( associated ( usb ) .neqv. associated ( usbFraction ) ) ) then
        call Announce_Error ( key, no_error_code, 'Must supply sidebands and fractions together' )
        return
      end if
      if ( associated ( lsb ) ) then
        if ( .not. ValidateVectorQuantity ( lsb, quantityType=(/l_radiance/), &
          & sideband=(/-1/), signal=(/radiance%template%signal/), minorFrame=.true. )) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate lsb radiance quantity for fill' )
        if ( .not. ValidateVectorQuantity ( lsbFraction, &
          & quantityType=(/l_limbSidebandFraction/), &
          & signal=(/radiance%template%signal/), sideband=(/-1/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate lsbFraction quantity for fill' )
      end if
      if ( associated ( usb ) ) then
        if ( .not. ValidateVectorQuantity ( usb, quantityType=(/l_radiance/), &
          & sideband=(/1/), signal=(/radiance%template%signal/), minorFrame=.true. )) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate usb radiance quantity for fill' )
        if ( .not. ValidateVectorQuantity ( usbFraction, &
          & quantityType=(/l_limbSidebandFraction/), &
          & signal=(/radiance%template%signal/), sideband=(/1/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate usbFraction quantity for fill' )
      end if

      if ( .not. associated ( lsb ) .and. .not. associated ( usb ) ) &
        & call Announce_Error ( key, no_error_code, 'Must supply one or both of lsb/usb' )

      ! Now do the work
      ! Note that this is a very inefficient loop, but I don't really care as it's
      ! Never used in routine processing.
      i = 1                               ! Use i as a composit mif,channel index
      do mif = 1, radiance%template%noSurfs
        do c = 1, radiance%template%noChans
          radiance%values(i,:) = 0.0
          if ( associated ( lsb ) ) radiance%values(i,:) = radiance%values(i,:) + &
            & lsbFraction%values(c,1) * lsb%values(i,:)
          if ( associated ( usb ) ) radiance%values(i,:) = radiance%values(i,:) + &
            & usbFraction%values(c,1) * usb%values(i,:)
          i = i + 1
        end do
      end do

    end subroutine FillFoldedRadiance

    ! ------------------------------------ FillPhiTanWithRefraction --
    subroutine FillPhiTanWithRefraction ( key, quantity, &
      & h2o, orbIncline, ptan, refGPH, temperature )

      use Geometry, only: EarthRadA, EarthRadB, GEODTOGEOCLAT
      use Hydrostatic_M, only: HYDROSTATIC
      use MLSKinds, only: RP
      use Phi_Refractive_Correction_m, only: Phi_Refractive_Correction_Up
      use Refraction_m, only: REFRACTIVE_INDEX
      use Units, only: DEG2RAD, RAD2DEG

      integer, intent(in) :: KEY          ! Tree node, for error messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! PhiTan quantity to update
      type (VectorValue_T), intent(in) :: H2O         ! Water vapor
      type (VectorValue_T), intent(in) :: OrbIncline  ! Orbital inclination
      type (VectorValue_T), intent(in) :: PTan        ! Tangent pressure
      type (VectorValue_T), intent(in) :: RefGPH      ! Reference GPH
      type (VectorValue_T), intent(in) :: TEMPERATURE ! Temperature

      real(rp), dimension(quantity%template%noInstances) :: CP2, CSQ, REQ, SP2
      real(rp) :: PhiCorrs(temperature%template%noInstances,temperature%template%noSurfs)
      real(rp), dimension(temperature%template%noInstances) :: REQS
      real(rv), dimension(temperature%template%noSurfs) :: Heights, N, PhiCorr, PS
      integer :: I, J ! Subscripts, loop inductors

      ! Executable code
      call MLSMessageCalls( 'push', constantName='FillPhiTanWithRefraction' )
      ! More sanity checks
      if ( quantity%template%instrumentModule /= ptan%template%instrumentModule ) &
        & call Announce_Error ( key, No_Error_Code, &
        & 'PHITan and PTan quantities are not for the same module' )
      if ( any(shape(quantity%values)/=shape(ptan%values)) ) &
        & call Announce_Error ( key, No_Error_Code, &
        & 'PHITan and PTan quantities are not the same size' )
      if ( .not. ValidateVectorQuantity ( temperature, &
        & quantityType=(/l_temperature/), coherent=.true., stacked=.true., &
        & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
        & call Announce_error ( key, no_error_code, 'Problem with temperature quantity for phiTan fill' )
      if ( .not. ValidateVectorQuantity ( h2o, &
        & quantityType=(/l_vmr/), molecule=(/l_h2o/), coherent=.true., stacked=.true., &
        & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
        & call Announce_error ( key, no_error_code, 'Problem with temperature quantity for phiTan fill' )
      if ( .not. ValidateVectorQuantity ( refGPH, &
        & quantityType = (/l_refGPH/), coherent=.true., stacked=.true., &
        & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/), noSurfs=(/1/) ) ) &
        & call Announce_Error ( key, badrefGPHQuantity )

      i = 0
      if ( .not. DoHGridsMatch ( temperature, refGPH ) ) i = i + 1
      if ( .not. DoHGridsMatch ( temperature, h2o ) ) i = i + 2
      if ( quantity%template%noInstances /= orbincline%template%noInstances ) i = i + 4
      if ( .not. DoVGridsMatch ( temperature, h2o ) ) i = i + 8
      if ( i /= 0 ) call Announce_Error ( key, no_error_code, &
        & ' coordinates for temperature/refGPH/H2O disagree', &
        & extraInfo = (/i/) )

      ! compute equivalent earth radius at uncorrected tangent phi nearest surface
      csq = (earthrada * earthradb)**2 / &
            & ((earthrada**2-earthradb**2)*sin(orbincline%values(1,:)*deg2rad)**2 + &
            &   earthradb**2)
      cp2 = cos(quantity%values(1,:)*deg2rad)**2
      sp2 = 1.0_rp - cp2
      req = 0.001_rp*sqrt((earthrada**4*sp2 + csq**2*cp2) / &
                        & (earthrada**2*cp2 + csq*sp2))

      ! Interpolate REQ to temperature/h2o/refGPH hGrid
      call InterpolateValues ( quantity%values(1,:), req, &
        & temperature%template%phi(1,:), reqs, 'Linear', extrapolate='Constant' )

      ! Get pressures corresponding to Temperature etc
      ps = 10.0**(-temperature%template%surfs(:,1))

      ! OK, do the refraction calculation on Temperature's grids
      do i = 1, temperature%template%noInstances

        ! Get heights.  Temperature and RefGPH are on same hGrids.
        ! RefGPH is in meters, but Hydrostatic wants it in km.
        call Hydrostatic ( GeodToGeocLat ( temperature%template%geodLat(1,i) ), &
          & temperature%template%surfs(:,1), temperature%values(:,i), &
          & temperature%template%surfs(:,1), &
          & refGPH%template%surfs(1,1), 0.001*refGPH%values(1,i), &
          & heights )
        heights = heights + reqs(i)
        ! Get refractive indices.  Temperature and H2O are on same grids.
        call refractive_index ( ps, temperature%values(:,i), n, h2o%values(:,i) )
        do j = 1, temperature%template%noSurfs
          call phi_refractive_correction_up ( n(j:), heights(j:), phiCorr(j:) )
          phiCorrs(i,j) = phiCorr(temperature%template%noSurfs) * rad2deg
        end do
      end do

      ! Now interpolate Phi corrections onto the PhiTan grid and apply them.
      ! Its zeta grid is the value of PTan; its phi grid is its own value.

      do j = 1, size(quantity%values,2)
        call interpolateValues ( h2o%template%phi(1,:), quantity%values(:,j), &
          &                      h2o%template%surfs(:,1), ptan%values(:,j), &
          &                      phiCorrs, quantity%values(:,j), update=.true. )
      end do ! j

      call MLSMessageCalls( 'pop' )
    end subroutine FillPhiTanWithRefraction

      ! ------------------------------------- FillIWCFromExtinction ----
    subroutine FillIWCFromExtinction ( quantity, &
     & sourceQuantity, temperatureQuantity)
      ! Actually, the meaning of the next two is reversed if invert is TRUE)
      type (VectorValue_T), intent(inout) :: QUANTITY ! (IWC) Quantity to fill
      type (VectorValue_T), intent(in) :: sourceQuantity ! cloud extinction
      type (VectorValue_T), intent(in) :: temperatureQuantity ! T(zeta)

      ! local variables
      real (r8), dimension(Temperaturequantity%template%noSurfs,quantity%template%noInstances) :: temp
      real (r8), dimension(Temperaturequantity%template%noSurfs) :: zt, yt
      real (r8), dimension(sourceQuantity%template%noSurfs) :: ze, ye
      real (r8), dimension(quantity%template%noSurfs) :: z, Tz, Ez, iwc0
      real (r8), dimension(quantity%template%noInstances) :: x2, y2
      real (r8), dimension(Temperaturequantity%template%noInstances) :: x1, y1
      integer :: i

      call MLSMessageCalls( 'push', constantName='FillIWCFromExtinction' )
      if ( .not. (quantity%template%coherent .and. sourceQuantity%template%coherent &
         .and. Temperaturequantity%template%coherent)) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "one of the quantities is not coherent")
      if ( sourceQuantity%template%noInstances /= Quantity%template%noInstances) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "IWC and Extinction profile numbers are not matched")

      if ( TemperatureQuantity%template%noInstances /= Quantity%template%noInstances ) then
         x1 = TemperatureQuantity%template%phi(1,:)
         x2 = quantity%template%phi(1,:)
         do i=1,Temperaturequantity%template%noSurfs
           y1 = TemperatureQuantity%values(i, :)
           call InterpolateValues( x1, y1, x2, y2, method='Linear' )
           temp(i,:) = y2
         end do
      else
         temp = TemperatureQuantity%values
      end if

      if ( quantity%template%verticalCoordinate == l_pressure ) then
        z = -log10 ( quantity%template%surfs(:,1) )
      else
        z = quantity%template%surfs(:,1)
      end if

      if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then
        ze = -log10 ( sourceQuantity%template%surfs(:,1) )
      else
        ze = sourceQuantity%template%surfs(:,1)
      end if

      if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then
        zt = -log10 ( Temperaturequantity%template%surfs(:,1) )
      else
        zt = Temperaturequantity%template%surfs(:,1)
      end if

      do i=1, quantity%template%noInstances
        yt = Temp(:, i)
        call InterpolateValues( zt, yt, z,  Tz, method='Linear' )
        ye = sourceQuantity%values(:, i)*1000._r8  ! converted to 1/km
        call InterpolateValues( ze, ye, z, Ez, method='Linear' )
        ! see ATBD for the conversion based on the size distribution from
        ! McFarquhar and Heymsfield [1996]
        !
        iwc0 = 10**(-2.77+0.01*(Tz-273.15))
        where(Ez < 0._r8) Ez = 0._r8
        Ez = Ez**(1./1.4)

        quantity%values(:,i) = iwc0*Ez
      end do
      call MLSMessageCalls( 'pop' )

    end subroutine FillIWCFromExtinction

      ! ------------------------------------- FillRHIFromH2O ----
    subroutine FillRHIFromH2O ( key, quantity, &
     & sourceQuantity, temperatureQuantity, &
     & dontMask, ignoreZero, ignoreNegative, interpolate, &
     & markUndefinedValues, invert )
      ! Convert h2o vmr to %RHI for all instances, channels, surfaces
      ! (See Eq. 9 from "UARS Microwave Limb Sounder upper tropospheric
      !  humidity measurement: Method and validation" Read et. al.
      !  J. Geoph. Res. Dec. 2001 (106) D23)

      !  Method:
      ! (1) straight convert--all quantities must have the same shape
      !     (strictly we assume they have _all_ the same geolocations)
      ! (2) interpolate--all quantities may have different shapes
      !     (the interpolation will be along the vertical coordinate only)
      !     I.e., for xQuantity (where x can be h2o or temperature)
      !     if NoChans(xQuantity) /= NoChans(Quantity)
      !        => use only xQuantity(channel==1)
      !     if NoInstances(xQuantity) /= NoInstances(Quantity)
      !        => use only xQuantity(instance==1)
      !
      ! (3) if invert is TRUE, like (1) but its inverse: %RHI to h2o vmr
      integer, intent(in) :: key          ! For messages
      ! Actually, the meaning of the next two is reversed if invert is TRUE)
      type (VectorValue_T), intent(inout) :: QUANTITY ! (rhi) Quantity to fill
      type (VectorValue_T), intent(in) :: sourceQuantity ! vmr (unless invert)
      type (VectorValue_T), intent(in) :: temperatureQuantity ! T(zeta)
      logical, intent(in)           ::    dontMask    ! Use even masked values
      logical, intent(in)           ::    ignoreZero  ! Ignore 0 values of h2o
      logical, intent(in)           ::    ignoreNegative  ! Ignore <0 values
      logical, intent(in)           ::    interpolate ! If VGrids or HGrids differ
      logical, intent(in)           ::    markUndefinedValues ! as UNDEFINED_VALUE
      logical, intent(in)           ::    invert      ! %RHI -> vmr if TRUE

      ! Local variables
      integer ::                          Channel     ! Channel loop counter
      integer ::                          Chan_h2o    ! Channel loop counter
      integer ::                          Chan_T      ! Channel loop counter
      logical, parameter ::               DEEBUG_RHI = .false.
      integer                          :: dim
      integer ::                          I           ! Instances
      integer ::                          I_H2O       ! Instance num for values
      integer ::                          I_T         ! Instance num for values
      integer ::                          invs        ! 1 if invert, else -1
      integer ::                          QINDEX
      integer ::                          N           ! Num. of summed values
      logical                          :: matched_h2o_channels
      logical                          :: matched_h2o_instances
      logical                          :: matched_sizes
      logical                          :: matched_surfs
      logical                          :: matched_T_channels
      logical                          :: matched_T_instances
      integer ::                          S           ! Surface loop counter
      integer ::                          S_H2O       ! Instance num for surfs
      integer ::                          S_RHI       ! Instance num for surfs
      integer ::                          S_T         ! Instance num for surfs
      logical ::                          skipMe
      real (r8) ::                        T
      character(len=*), parameter ::      VMR_UNITS = 'vmr'
      integer ::                          VMR_UNIT_CNV
      logical ::                          wereAnySkipped
      ! These automatic arrays could cause trouble later
      ! You may consider declaring them as pointers and
      ! calling allocate_test and deallocate_test
      real (r8), dimension(quantity%template%noSurfs) :: &
       &                                  zeta, TofZeta, H2OofZeta
      real (r8), dimension(Temperaturequantity%template%noSurfs) :: &
       &                                  zetaTemperature, oldTemperature
      real (r8), dimension(sourceQuantity%template%noSurfs) :: &
       &                                  zetaH2o, oldH2o
      ! Executable statements
      call MLSMessageCalls( 'push', constantName='FillRHIFromH2O' )
      ! Let any undefined values be so marked (but not necessarily masked)
      if ( markUndefinedValues ) Quantity%values = UNDEFINED_VALUE
      ! Will we convert %RHI to vmr?
      if ( invert ) then
        invs = 1
      else
        invs = -1
      end if
      ! Do we need to internally convert the vmr units?
      if ( VMR_UNITS == 'ppmv' ) then
        vmr_unit_cnv = 6
      else if ( VMR_UNITS == 'ppbv' ) then
        vmr_unit_cnv = 9
      else
        vmr_unit_cnv = 0
      end if
      ! Check that all is well
      if ( invert .and. interpolate ) then
       call Announce_Error ( key, No_Error_code, &
        & ' FillRHIFromH2O unable to invert and interpolate simultaneously' )
       return
      end if
      matched_sizes = .true.
      do dim=1, 2
        matched_sizes = matched_sizes .and. &
        & .not. any( size(Quantity%values,dim) /= &
        &(/ size(sourceQuantity%values,dim), &
        & size(temperatureQuantity%values,dim) /)&
        & )
      end do
      if ( .not. (matched_sizes .or. interpolate) ) then
       call Announce_Error ( key, No_Error_code, &
        & 'Incompatible quantities in FillRHIFromH2O--' //&
        & '(unless interpolating, all must have same shape)' )
       return
      end if
      matched_surfs = .true.
      matched_surfs = matched_surfs .and. &
       & .not. any( Quantity%template%noSurfs /= &
       &(/ sourceQuantity%template%noSurfs, &
       & temperatureQuantity%template%noSurfs /)&
       & )
      if ( .not. (matched_surfs .or. interpolate) ) then
       call Announce_Error ( key, No_Error_code, &
        & 'Different vertical coords in FillRHIFromH2O--' //&
        & '(unless interpolating, all must be on the same VGrid)' )
       return
      end if
      matched_h2o_channels = &
       &   (sourceQuantity%template%noChans == Quantity%template%noChans)
      matched_h2o_instances = &
       &   (sourceQuantity%template%noInstances == Quantity%template%noInstances)
      matched_T_channels = &
       &   (TemperatureQuantity%template%noChans == Quantity%template%noChans)
      matched_T_instances = &
       &   (TemperatureQuantity%template%noInstances == Quantity%template%noInstances)
      wereAnySkipped = .false.
      ! Now let's do the actual conversion
      do i=1, quantity%template%noInstances
        if ( quantity%template%coherent ) then
          s_rhi = 1
        else
          s_rhi = i
        end if
        if ( sourceQuantity%template%coherent ) then
          s_h2o = 1
        else
          s_h2o = i
        end if
        if ( temperaturequantity%template%coherent ) then
          s_t = 1
        else
          s_t = i
        end if
        ! zeta must be in log(hPa) units
        if ( quantity%template%verticalCoordinate == l_pressure ) then
          zeta = -log10 ( quantity%template%surfs(:,s_rhi) )
        else
          zeta = quantity%template%surfs(:,s_rhi)
        end if
        if ( interpolate .and. .not. matched_h2o_instances ) then
          i_h2o = 1
        else
          i_h2o = i
        end if
        if ( interpolate .and. .not. matched_T_instances ) then
          i_T = 1
        else
          i_T = i
        end if
        if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then
          zetah2o = -log10 ( sourceQuantity%template%surfs(:,s_h2o) )
        else
          zetah2o = sourceQuantity%template%surfs(:,s_h2o)
        end if
        if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then
          zetaTemperature = -log10 ( Temperaturequantity%template%surfs(:,s_T) )
        else
          zetaTemperature = Temperaturequantity%template%surfs(:,s_T)
        end if
        N = 0
        do Channel=1, quantity%template%noChans
          if ( interpolate .and. .not. matched_h2o_channels ) then
            Chan_h2o = 1
          else
            Chan_h2o = Channel
          end if
          if ( interpolate .and. .not. matched_T_channels ) then
            Chan_T = 1
          else
            Chan_T = Channel
          end if
          if ( interpolate ) then
            do s=1, sourceQuantity%template%noSurfs
              qIndex = Chan_h2o + (s-1)*sourceQuantity%template%noChans
              oldH2o(s) = sourceQuantity%values(qIndex, i_h2o)
            end do
            ! Know the following about the procedure we will call:
            ! First pair of args are old(X,Y), next pair are new(X,Y)
            ! We want newY(newX) via linear interp. w/o extrapolating
            ! and mark undefined values among oldY with UNDEFINED_VALUE
            call InterpolateValues( zetah2o, oldH2o, &
             & zeta, H2OofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
            do s=1, Temperaturequantity%template%noSurfs
              qIndex = Chan_T + (s-1)*Temperaturequantity%template%noChans
              oldTemperature(s) = TemperatureQuantity%values(qIndex, i_T)
            end do
            call InterpolateValues( zetaTemperature, oldTemperature, &
             & zeta, TofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
          else
            do s=1, quantity%template%noSurfs
              N = N + 1
              qIndex = Channel + (s-1)*quantity%template%noChans
              H2OofZeta(s) = sourceQuantity%values(qIndex, i)
              TofZeta(s) = TemperatureQuantity%values(qIndex, i)
            end do
          end if
          do s=1, quantity%template%noSurfs
            N = N + 1
            qIndex = Channel + (s-1)*quantity%template%noChans
            skipMe = .false.
            if ( .not. interpolate ) then
             skipMe = skipMe .or. &
             & .not. dontMask .and. ( &
             &   isVectorQtyMasked(sourceQuantity, qIndex, i) .or. &
             &   isVectorQtyMasked(temperatureQuantity, qIndex, i) &
             & )
            end if
            skipMe = skipMe .or. &
            & .not. dontMask .and. ( &
            & (ignoreNegative .and. H2OofZeta(s) < 0.0 ) &
            & .or. (ignoreZero .and. H2OofZeta(s) == 0.0 ) &
            & )
            ! But skip no matter what else if temperature illegal
            skipMe = skipMe .or. TofZeta(s) <= 0.0
            if ( .not. skipMe ) then
              T = TofZeta(s)
              Quantity%values(qIndex, i) = &
               & H2OofZeta(s) &
               & * &
               & RHIFromH2O_Factor(T, zeta(qIndex), vmr_unit_cnv, invert)
            end if
            wereAnySkipped = wereAnySkipped .or. skipMe
          end do
        end do
      end do
      if ( DEEBUG_RHI ) then
        call output('rhi Num. instances: ', advance='no')
        if ( invert ) then
          call output(sourceQuantity%template%noInstances, advance='yes')
d1373 1
a1373 1901
          call output(quantity%template%noInstances, advance='yes')
        end if
        call output('  size(surfs,2) ', advance='no')
        call output(size(quantity%template%surfs,2), advance='yes')
        call output('Were any rhi left undefined? ', advance='no')
        call output(wereAnySkipped, advance='yes')
        call dump(zeta, 'zeta(-log hPa)')
        do s=1, quantity%template%noSurfs
          if ( invert ) then
            zeta(s) = 1000000*Quantity%values(s,1)
          else
            zeta(s) = 1000000*sourceQuantity%values(s,1)
          end if
        end do
        call dump(zeta, 'H2O(ppmv)')
        call dump(TemperatureQuantity%values(:,1), 'Temperature(K)')
        if ( invert ) then
          call dump(sourceQuantity%values(:,1), 'RHI(%)')
        else
          call dump(Quantity%values(:,1), 'RHI(%)')
        end if
      end if
      call MLSMessageCalls( 'pop' )
    end subroutine FillRHIFromH2O
!MJF
    ! ------------------------------------- FillNoRadsPerMIF -----
    subroutine FillNoRadsPerMif ( key, quantity, measQty )
      integer, intent(in) :: KEY
      type(VectorValue_T), intent(inout) :: QUANTITY
      type(VectorValue_T), intent(in) :: MEASQTY
      ! Local variables
      integer :: MIF, MAF               ! Loop counters
      integer :: I0, I1                 ! Indices

      ! Executable code
      ! Do some fairly limited checking.
      if ( .not. ValidateVectorQuantity ( measQty, quantityType=(/l_radiance/), &
        & signal=(/quantity%template%signal/), sideband=(/quantity%template%sideband/) ) ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Quantity and measurement quantity disagree' )
      if ( associated ( measQty%mask ) ) then
        do maf = 1, quantity%template%noInstances
          do mif = 1, quantity%template%noSurfs
            i0 = 1 +  ( mif-1 ) * measQty%template%noChans
            i1 = i0 + measQty%template%noChans - 1
            quantity%values ( mif, maf ) = count ( &
              & iand ( ichar ( measQty%mask ( i0:i1, maf ) ), m_linAlg ) == 0 )
          end do
        end do
      else
        quantity%values = measQty%template%noChans
      end if
    end subroutine FillNoRadsPerMIF

    ! ------------------------------------- FillRHIPrecisionFromH2O ----
    subroutine FillRHIPrecisionFromH2O ( key, quantity, &
     & sourcePrecisionQuantity, tempPrecisionQuantity, sourceQuantity, temperatureQuantity, &
     & dontMask, ignoreZero, ignoreNegative, interpolate, &
     & markUndefinedValues, invert )
      ! For precisions:
      ! Convert h2o vmr to %RHI for all instances, channels, surfaces
      ! (See Eq. 9 from "UARS Microwave Limb Sounder upper tropospheric
      !  humidity measurement: Method and validation" Read et. al.
      !  J. Geoph. Res. Dec. 2001 (106) D23)

      !  Method:
      ! (1) straight convert--all quantities must have the same shape
      !     (strictly we assume they have _all_ the same geolocations)
      ! (2) interpolate--all quantities may have different shapes
      !     (the interpolation will be along the vertical coordinate only)
      !     I.e., for xQuantity (where x can be h2o or temperature)
      !     if NoChans(xQuantity) /= NoChans(Quantity)
      !        => use only xQuantity(channel==1)
      !     if NoInstances(xQuantity) /= NoInstances(Quantity)
      !        => use only xQuantity(instance==1)
      !
      ! (3) Don't know how to invert precisions
      !
      ! Note: If either of TempPrecision or H2OPrecision is negative, then
      ! set Precision to negative, too (if NEGATIVETOO is TRUE)
      integer, intent(in) :: key          ! For messages
      ! Actually, the meaning of the next two is reversed if invert is TRUE)
      type (VectorValue_T), intent(inout) :: QUANTITY ! (rhi) Quantity to fill
      type (VectorValue_T), intent(in) :: sourcePrecisionQuantity ! vmr (unless invert)
      type (VectorValue_T), intent(in) :: tempPrecisionQuantity ! T(zeta)
      type (VectorValue_T), intent(in) :: sourceQuantity ! vmr (unless invert)
      type (VectorValue_T), intent(in) :: temperatureQuantity ! T(zeta)
      logical, intent(in)           ::    dontMask    ! Use even masked values
      logical, intent(in)           ::    ignoreZero  ! Ignore 0 values of h2o
      logical, intent(in)           ::    ignoreNegative  ! Ignore <0 values
      logical, intent(in)           ::    interpolate ! If VGrids or HGrids differ
      logical, intent(in)           ::    markUndefinedValues ! as UNDEFINED_VALUE
      logical, intent(in)           ::    invert      ! %RHI -> vmr if TRUE

      ! Local variables
      integer ::                          Channel     ! Channel loop counter
      integer ::                          Chan_h2oPrecision    ! Channel loop counter
      integer ::                          Chan_TPrecision      ! Channel loop counter
      integer ::                          Chan_h2o    ! Channel loop counter
      integer ::                          Chan_T      ! Channel loop counter
      logical, parameter ::               DEEBUG_RHI = .false.
      integer                          :: dim
      integer ::                          I           ! Instances
      integer ::                          I_H2OPrecision       ! Instance num for values
      integer ::                          I_TPrecision         ! Instance num for values
      integer ::                          I_H2O       ! Instance num for values
      integer ::                          I_T         ! Instance num for values
      logical                          :: matched_h2oPrecision_channels
      logical                          :: matched_h2oPrecision_instances
      logical                          :: matched_h2o_channels
      logical                          :: matched_h2o_instances
      logical                          :: matched_sizes
      logical                          :: matched_surfs
      logical                          :: matched_TPrecision_channels
      logical                          :: matched_TPrecision_instances
      logical                          :: matched_T_channels
      logical                          :: matched_T_instances
      integer ::                          N           ! Num. of summed values
      logical, parameter ::               NEGATIVETOO = .true.
      integer ::                          QINDEX
      real (r8) ::                        rhi_precision
      integer ::                          S           ! Surface loop counter
      integer ::                          S_H2O       ! Instance num for surfs
      integer ::                          S_RHI       ! Instance num for surfs
      integer ::                          S_T         ! Instance num for surfs
      logical ::                          skipMe
      character(len=*), parameter ::      VMR_UNITS = 'vmr'
      integer ::                          VMR_UNIT_CNV
      logical ::                          wereAnySkipped
      ! These automatic arrays could cause trouble later
      ! You may consider declaring them as pointers and
      ! calling allocate_test and deallocate_test
      real (r8), dimension(quantity%template%noSurfs) :: &
       &                                  zeta, TPrecisionofZeta, H2OPrecisionofZeta, TofZeta, H2OofZeta
      real (r8), dimension(TempPrecisionquantity%template%noSurfs) :: &
       &                                  zetaTempPrecision, oldTempPrecision
      real (r8), dimension(sourcePrecisionQuantity%template%noSurfs) :: &
       &                                  zetaH2oPrecision, oldH2oPrecision
      real (r8), dimension(Temperaturequantity%template%noSurfs) :: &
       &                                  zetaTemperature, oldTemperature
      real (r8), dimension(sourceQuantity%template%noSurfs) :: &
       &                                  zetaH2o, oldH2o
      ! Executable statements
      call MLSMessageCalls( 'push', constantName='FillRHIPrecisionFromH2O' )
      ! Let any undefined values be so marked (but not necessarily masked)
      if ( markUndefinedValues ) Quantity%values = UNDEFINED_VALUE
      ! Will we convert %RHI to vmr?
      if ( invert ) then
       call Announce_Error ( key, No_Error_code, &
        & ' FillRHIPrecisionFromH2O unable to invert' )
       return
      end if
      ! Do we need to internally convert the vmr units?
      if ( VMR_UNITS == 'ppmv' ) then
        vmr_unit_cnv = 6
      else if ( VMR_UNITS == 'ppbv' ) then
        vmr_unit_cnv = 9
      else
        vmr_unit_cnv = 0
      end if
      ! Check that all is well
      if ( invert .and. interpolate ) then
       call Announce_Error ( key, No_Error_code, &
        & ' FillRHIPrecisionFromH2O unable to invert and interpolate simultaneously' )
       return
      end if
      matched_sizes = .true.
      do dim=1, 2
        matched_sizes = matched_sizes .and. &
        & .not. any( size(Quantity%values,dim) /= &
        &(/ size(sourcePrecisionQuantity%values,dim), &
        & size(tempPrecisionQuantity%values,dim), &
        & size(sourceQuantity%values,dim), &
        & size(temperatureQuantity%values,dim) /)&
        & )
      end do
      if ( .not. (matched_sizes .or. interpolate) ) then
       call Announce_Error ( key, No_Error_code, &
        & 'Incompatible quantities in FillRHIPrecisionFromH2O--' //&
        & '(unless interpolating, all must have same shape)' )
       return
      end if
      matched_surfs = .true.
      matched_surfs = matched_surfs .and. &
       & .not. any( Quantity%template%noSurfs /= &
       &(/ sourcePrecisionQuantity%template%noSurfs, &
       & tempPrecisionQuantity%template%noSurfs, &
       & sourceQuantity%template%noSurfs, &
       & temperatureQuantity%template%noSurfs /)&
       & )
      if ( .not. (matched_surfs .or. interpolate) ) then
       call Announce_Error ( key, No_Error_code, &
        & 'Different vertical coords in FillRHIPrecisionFromH2O--' //&
        & '(unless interpolating, all must be on the same VGrid)' )
       return
      end if
      matched_h2oPrecision_channels = &
       &   (sourcePrecisionQuantity%template%noChans == Quantity%template%noChans)
      matched_h2oPrecision_instances = &
       &   (sourcePrecisionQuantity%template%noInstances == Quantity%template%noInstances)
      matched_TPrecision_channels = &
       &   (TempPrecisionQuantity%template%noChans == Quantity%template%noChans)
      matched_TPrecision_instances = &
       &   (TempPrecisionQuantity%template%noInstances == Quantity%template%noInstances)
      matched_h2o_channels = &
       &   (sourceQuantity%template%noChans == Quantity%template%noChans)
      matched_h2o_instances = &
       &   (sourceQuantity%template%noInstances == Quantity%template%noInstances)
      matched_T_channels = &
       &   (TemperatureQuantity%template%noChans == Quantity%template%noChans)
      matched_T_instances = &
       &   (TemperatureQuantity%template%noInstances == Quantity%template%noInstances)
      wereAnySkipped = .false.
      ! Now let's do the actual conversion
      do i=1, quantity%template%noInstances
        if ( quantity%template%coherent ) then
          s_rhi = 1
        else
          s_rhi = i
        end if
        if ( sourceQuantity%template%coherent ) then
          s_h2o = 1
        else
          s_h2o = i
        end if
        if ( temperaturequantity%template%coherent ) then
          s_t = 1
        else
          s_t = i
        end if
        ! zeta must be in log(hPa) units
        if ( quantity%template%verticalCoordinate == l_pressure ) then
          zeta = -log10 ( quantity%template%surfs(:,s_rhi) )
        else
          zeta = quantity%template%surfs(:,s_rhi)
        end if
        if ( interpolate .and. .not. matched_h2oPrecision_instances ) then
          i_h2oPrecision = 1
        else
          i_h2oPrecision = i
        end if
        if ( interpolate .and. .not. matched_TPrecision_instances ) then
          i_TPrecision = 1
        else
          i_TPrecision = i
        end if
        if ( interpolate .and. .not. matched_h2o_instances ) then
          i_h2o = 1
        else
          i_h2o = i
        end if
        if ( interpolate .and. .not. matched_T_instances ) then
          i_T = 1
        else
          i_T = i
        end if
        if ( sourcePrecisionQuantity%template%verticalCoordinate == l_pressure ) then
          zetah2oPrecision = -log10 ( sourcePrecisionQuantity%template%surfs(:,s_h2o) )
        else
          zetah2oPrecision = sourcePrecisionQuantity%template%surfs(:,s_h2o)
        end if
        if ( TempPrecisionquantity%template%verticalCoordinate == l_pressure ) then
          zetaTempPrecision = -log10 ( TempPrecisionquantity%template%surfs(:,s_T) )
        else
          zetaTempPrecision = TempPrecisionquantity%template%surfs(:,s_T)
        end if
        if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then
          zetah2o = -log10 ( sourceQuantity%template%surfs(:,s_h2o) )
        else
          zetah2o = sourceQuantity%template%surfs(:,s_h2o)
        end if
        if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then
          zetaTemperature = -log10 ( Temperaturequantity%template%surfs(:,s_T) )
        else
          zetaTemperature = Temperaturequantity%template%surfs(:,s_T)
        end if
        N = 0
        do Channel=1, quantity%template%noChans
          if ( interpolate .and. .not. matched_h2oPrecision_channels ) then
            Chan_h2oPrecision = 1
          else
            Chan_h2oPrecision = Channel
          end if
          if ( interpolate .and. .not. matched_TPrecision_channels ) then
            Chan_TPrecision = 1
          else
            Chan_TPrecision = Channel
          end if
          if ( interpolate .and. .not. matched_h2o_channels ) then
            Chan_h2o = 1
          else
            Chan_h2o = Channel
          end if
          if ( interpolate .and. .not. matched_T_channels ) then
            Chan_T = 1
          else
            Chan_T = Channel
          end if
          if ( interpolate ) then
            do s=1, sourcePrecisionQuantity%template%noSurfs
              qIndex = Chan_h2oPrecision + (s-1)*sourcePrecisionQuantity%template%noChans
              oldH2oPrecision(s) = sourcePrecisionQuantity%values(qIndex, i_h2oPrecision)
            end do
            ! Know the following about the procedure we will call:
            ! First pair of args are old(X,Y), next pair are new(X,Y)
            ! We want newY(newX) via linear interp. w/o extrapolating
            ! and mark undefined values among oldY with UNDEFINED_VALUE
            call InterpolateValues( zetah2oPrecision, oldH2oPrecision, &
             & zeta, H2OPrecisionofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
            do s=1, TempPrecisionquantity%template%noSurfs
              qIndex = Chan_TPrecision + (s-1)*TempPrecisionquantity%template%noChans
              oldTempPrecision(s) = TempPrecisionQuantity%values(qIndex, i_TPrecision)
            end do
            call InterpolateValues( zetaTempPrecision, oldTempPrecision, &
             & zeta, TPrecisionofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
            do s=1, sourceQuantity%template%noSurfs
              qIndex = Chan_h2o + (s-1)*sourceQuantity%template%noChans
              oldH2o(s) = sourceQuantity%values(qIndex, i_h2o)
            end do
            ! Know the following about the procedure we will call:
            ! First pair of args are old(X,Y), next pair are new(X,Y)
            ! We want newY(newX) via linear interp. w/o extrapolating
            ! and mark undefined values among oldY with UNDEFINED_VALUE
            call InterpolateValues( zetah2o, oldH2o, &
             & zeta, H2OofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
            do s=1, Temperaturequantity%template%noSurfs
              qIndex = Chan_T + (s-1)*Temperaturequantity%template%noChans
              oldTemperature(s) = TemperatureQuantity%values(qIndex, i_T)
            end do
            call InterpolateValues( zetaTemperature, oldTemperature, &
             & zeta, TofZeta, &
             & 'Linear', extrapolate='Constant', &
             & badValue=real(UNDEFINED_VALUE, r8), &
             & missingRegions=.TRUE. )
          else
            do s=1, quantity%template%noSurfs
              N = N + 1
              qIndex = Channel + (s-1)*quantity%template%noChans
              H2OPrecisionofZeta(s) = sourcePrecisionQuantity%values(qIndex, i)
              TPrecisionofZeta(s) = TempPrecisionQuantity%values(qIndex, i)
              H2OofZeta(s) = sourceQuantity%values(qIndex, i)
              TofZeta(s) = TemperatureQuantity%values(qIndex, i)
            end do
          end if
          do s=1, quantity%template%noSurfs
            N = N + 1
            qIndex = Channel + (s-1)*quantity%template%noChans
            skipMe = .false.
            if ( .not. interpolate ) then
             skipMe = skipMe .or. &
             & .not. dontMask .and. ( &
             &   isVectorQtyMasked(sourcePrecisionQuantity, qIndex, i) .or. &
             &   isVectorQtyMasked(tempPrecisionQuantity, qIndex, i) .or. &
             &   isVectorQtyMasked(sourceQuantity, qIndex, i) .or. &
             &   isVectorQtyMasked(temperatureQuantity, qIndex, i) &
             & )
            end if
            skipMe = skipMe .or. &
            & .not. dontMask .and. ( &
            & (ignoreNegative .and. H2OofZeta(s) < 0.0 ) &
            & .or. (ignoreZero .and. H2OofZeta(s) == 0.0 ) &
            & )
            ! But skip no matter what else if temperature illegal
            skipMe = skipMe .or. TofZeta(s) <= 0.0
            if ( .not. skipMe ) then
              call RHIPrecFromH2O( H2OofZeta(s), &
               & TofZeta(s), zeta(qIndex), vmr_unit_cnv, &
               & H2OPrecisionofZeta(s), TPrecisionofZeta(s), &
               & rhi_precision, negativeToo )
              Quantity%values(qIndex, i) = rhi_precision
            end if
            wereAnySkipped = wereAnySkipped .or. skipMe
          end do
        end do
      end do
      if ( DEEBUG_RHI ) then
        call output('rhi Num. instances: ', advance='no')
        if ( invert ) then
          call output(sourceQuantity%template%noInstances, advance='yes')
        else
          call output(quantity%template%noInstances, advance='yes')
        end if
        call output('  size(surfs,2) ', advance='no')
        call output(size(quantity%template%surfs,2), advance='yes')
        call output('Were any rhi left undefined? ', advance='no')
        call output(wereAnySkipped, advance='yes')
        call dump(zeta, 'zeta(-log hPa)')
        do s=1, quantity%template%noSurfs
          if ( invert ) then
            zeta(s) = 1000000*Quantity%values(s,1)
          else
            zeta(s) = 1000000*sourceQuantity%values(s,1)
          end if
        end do
        call dump(zeta, 'H2O(ppmv)')
        call dump(TemperatureQuantity%values(:,1), 'Temperature(K)')
        if ( invert ) then
          call dump(sourceQuantity%values(:,1), 'RHI(%)')
        else
          call dump(Quantity%values(:,1), 'RHI(%)')
        end if
      end if
      call MLSMessageCalls( 'pop' )
    end subroutine FillRHIPrecisionFromH2O
!MJF
    ! ---------------------------------- FillVectorQuantityWithEsimatedNoise ---
    subroutine FillVectorQtyWithEstNoise ( quantity, radiance, &
      & sysTemp, nbw, integrationTime )

      use MLSSignals_m, only: signals

      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: RADIANCE ! Radiances to use in calculation
      type (VectorValue_T), intent(in) :: SYSTEMP ! System temperature
      type (VectorValue_T), pointer :: NBW ! Noise bandwidth
      real(r8), intent(in) :: INTEGRATIONTIME ! Integration time in seconds

      ! Local variables
      integer :: C                        ! Channel loop counter
      integer :: S                        ! Surface loop counter
      integer :: I                        ! Index into first dimension of values

      real (r8), dimension(:), pointer :: WIDTH ! Channel widths in MHz

      ! Executable code

      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/), minorFrame=.true.) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Invalid quantity for estimated noise fill.")

      if ( .not. ValidateVectorQuantity ( radiance, &
        & quantityType=(/l_radiance/), minorFrame=.true.) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Invalid quantity for estimated noise fill.")

      if ( ( radiance%template%signal /= quantity%template%signal ) .or. &
        &  ( radiance%template%sideband /= quantity%template%sideband ) ) &
        & call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & "Quantity and radiances not same signal for estimated noise fill.")

      if ( ( systemp%template%signal /= quantity%template%signal ) .or. &
        &  ( systemp%template%sideband /= quantity%template%sideband ) ) &
        & call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & "Quantity and system temperature not same signal for estimated noise fill." )

      if ( .not. ValidateVectorQuantity ( &
        & sysTemp, &
        & quantityType=(/l_systemTemperature/), &
        & verticalCoordinate=(/l_none/), &
        & noInstances=(/1/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Invalid system temperature quantity for estimated noise fill.")

      if ( associated ( nbw ) ) then
        if ( .not. ValidateVectorQuantity ( &
          & nbw, &
          & quantityType=(/l_noiseBandwidth/), &
          & verticalCoordinate=(/l_none/), &
          & noInstances=(/1/) ) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Invalid noise bandwidth quantity for estimated noise fill.")
        if ( ( nbw%template%signal /= quantity%template%signal ) .or. &
          &    ( nbw%template%sideband /= quantity%template%sideband ) ) &
          & call MLSMEssage ( MLSMSG_Error, ModuleName, &
          & "Quantity and noise bandwidth not same signal for estimated noise fill." )
        width => nbw%values(:,1)
      else
        width => signals(radiance%template%signal)%widths(:)
      end if

      i = 1
      do s = 1, quantity%template%noSurfs
        do c = 1, quantity%template%noChans
          quantity%values(i,:) = ( radiance%values(i,:) + sysTemp%values(c,1) ) / &
            & sqrt ( integrationTime * 1e6 * width(c) )
          i = i + 1
        end do
      end do

    end subroutine FillVectorQtyWithEstNoise

    ! ------------------------------------- FillVectorQtyHydrostatically ----
    subroutine FillVectorQtyHydrostatically ( key, quantity, &
      & temperatureQuantity, refGPHQuantity, h2oQuantity, &
      & orbitInclinationQuantity, phiTanQuantity, geocAltitudeQuantity, maxIterations, &
      & phiWindow, phiWindowUnits, chunkNo )
      ! Various hydrostatic fill operations
      integer, intent(in) :: key          ! For messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: TEMPERATUREQUANTITY
      type (VectorValue_T), intent(in) :: REFGPHQUANTITY
      type (VectorValue_T), pointer :: H2OQUANTITY
      type (VectorValue_T), pointer :: ORBITINCLINATIONQUANTITY
      type (VectorValue_T), pointer :: PHITANQUANTITY
      type (VectorValue_T), pointer :: GEOCALTITUDEQUANTITY
      integer, intent(in) :: MAXITERATIONS
      real(r8), intent(in) :: PHIWINDOW
      integer, intent(in) :: PHIWINDOWUNITS
      integer, intent(in), optional :: chunkNo
      ! H2OQuantity and GeocAltitudeQuantity have to be pointers
      ! as they may be absent.

      ! Local variables

      ! Executable code

      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_begin ( "FillVectorQtyHydrostatically", key )

      select case ( quantity%template%quantityType )
      case ( l_gph )
        if ( (temperatureQuantity%template%noSurfs /= &
          &   quantity%template%noSurfs) .or. &
          &  (refGPHQuantity%template%noInstances /= &
          &   quantity%template%noInstances) .or. &
          &  (temperatureQuantity%template%noInstances /= &
          &   quantity%template%noInstances) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_gph failed first test" )
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FillVectorQtyHydrostatically")
          return
        end if
        if ( (any(quantity%template%surfs /= temperatureQuantity%template%surfs)) .or. &
          & (any(quantity%template%phi /= temperatureQuantity%template%phi)) .or. &
          & (any(quantity%template%phi /= refGPHQuantity%template%phi)) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            &  "case l_gph failed second test" )
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FillVectorQtyHydrostatically")
          return
        end if
        call GetBasisGPH ( temperatureQuantity, refGPHQuantity, quantity%values )
      case ( l_ptan )
        if ( (temperatureQuantity%template%noInstances /= &
          &   refGPHquantity%template%noInstances) .or. &
          &  (temperatureQuantity%template%noInstances /= &
          &   h2oQuantity%template%noInstances) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_ptan failed first test" )
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FillVectorQtyHydrostatically")
          return
        end if
        if ( (any(refGPHquantity%template%phi /= temperatureQuantity%template%phi)) .or. &
          & (any(h2oQuantity%template%phi /= temperatureQuantity%template%phi)) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_ptan failed second test" )
          if ( toggle(gen) .and. levels(gen) > 0 )&
            &  call trace_end ( "FillVectorQtyHydrostatically")
          return
        end if
        if ( (.not. ValidateVectorQuantity(quantity, minorFrame=.true.) ) .or. &
          &  (.not. ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ) .or. &
          &  (quantity%template%instrumentModule /= &
          &   geocAltitudeQuantity%template%instrumentModule) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_ptan failed third test" )
           call output('ValidateVectorQuantity(quantity, minorFrame=.true.) ')
           call blanks(3)
           call output( &
           & ValidateVectorQuantity(quantity, minorFrame=.true., sayWhyNot=.true.), &
           & advance='yes')

           call output('ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ')
           call blanks(3)
           call output( &
           & ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true., sayWhyNot=.true.), &
           & advance='yes')

           call output('quantity%template%instrumentModule ')
           call blanks(3)
           call output( &
           & quantity%template%instrumentModule, &
           & advance='yes')

           call output('geocAltitudeQuantity%template%instrumentModule ')
           call blanks(3)
           call output( &
           & geocAltitudeQuantity%template%instrumentModule, &
           & advance='yes')
           if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FillVectorQtyHydrostatically")
          return
        end if
        call Get2DHydrostaticTangentPressure ( quantity, temperatureQuantity,&
          & refGPHQuantity, h2oQuantity, orbitInclinationQuantity, &
          & phiTanQuantity, geocAltitudeQuantity, maxIterations, &
          & phiWindow, phiWindowUnits, chunkNo )
      case default
        call Announce_error ( 0, 0, 'No such fill yet' )
      end select

      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_end ( "FillVectorQtyHydrostatically" )

    end subroutine FillVectorQtyHydrostatically

    ! ------------------------------------- FillFromSplitSideband ----
    subroutine FillFromSplitSideband ( quantity, sourceQuantity, &
      & lsbFraction, usbFraction, spreadFlag, usb, channel, key )

      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY
      type (VectorValue_T), intent(in) :: LSBFRACTION
      type (VectorValue_T), intent(in) :: USBFRACTION
      type (VectorValue_T), pointer :: USB
      logical, intent(in) :: SPREADFLAG   ! One instance given, spread to all
      integer, intent(in) :: CHANNEL
      integer, intent(in) :: KEY
      ! Local variables
      integer :: MYCHANNEL              ! Possibly offset channel
      integer :: i, mif, maf
      type (Signal_T) :: signalIn, signalOut, signalRef
      real(r8), dimension(:), pointer :: freq1, freqL1, freqU1
      real(r8), dimension(:), pointer :: freq2, freqL2, freqU2
      real(r8), dimension(:), pointer :: freq, freqL, freqU
      real(r8) :: ratio1, ratio2    ! signal sideband fractions
      real(r8) :: scaledRad   ! scaled radiance according to the f^4 law

      ! Executable code
      nullify(freq, freqL, freqU, freq1, freqL1, freqU1, freq2, freqL2, freqU2)

      ! check for qualified quantity
      if ( .not. ValidateVectorQuantity ( quantity, quantityType=(/l_cloudInducedRadiance/), &
        & sideband=(/-1,1/), minorFrame=.true. )) &
        & call Announce_Error ( key, no_error_code, 'Quantity must be cloud-induced-radiances to fill' )
      if ( .not. associated(quantity%mask)) &
        & call Announce_Error ( key, no_error_code, 'Quantity must be a subset to fill' )

      signalIn = GetSignal ( sourceQuantity%template%signal )     ! sideband info gets lost
      signalOut = GetSignal ( Quantity%template%signal )          ! sideband info gets lost

      myChannel = channel

      call allocate_test ( freq1, size(signalIn%frequencies), 'frequencies', ModuleName )
      call allocate_test ( freqL1, size(signalIn%frequencies), 'LSBfrequencies', ModuleName )
      call allocate_test ( freqU1, size(signalIn%frequencies), 'USBfrequencies', ModuleName )
      call allocate_test ( freq2, size(signalOut%frequencies), 'frequencies', ModuleName )
      call allocate_test ( freqL2, size(signalOut%frequencies), 'LSBfrequencies', ModuleName )
      call allocate_test ( freqU2, size(signalOut%frequencies), 'USBfrequencies', ModuleName )

      ! find input signal frequencies
      freqL1 = signalIn%lo - signalIn%centerFrequency - &
        & signalIn%direction*signalIn%frequencies    ! lower sideband freq
      freqU1 = signalIn%lo + signalIn%centerFrequency + &
        & signalIn%direction*signalIn%frequencies     ! upper sideband freq
      if ( sourceQuantity%template%sideband == -1) freq1 = freqL1
      if ( sourceQuantity%template%sideband == 1) freq1 = freqU1
      ! find output signal frequencies
      freqL2 = signalOut%lo - signalOut%centerFrequency - &
        & signalOut%direction*signalOut%frequencies      ! lower sideband freq
      freqU2 = signalOut%lo + signalOut%centerFrequency + &
        & signalOut%direction*signalOut%frequencies    ! upper sideband freq
      if ( quantity%template%sideband == -1) freq2 = freqL2
      if ( quantity%template%sideband == 1) freq2 = freqU2

      quantity%values=0._r8
      if ( spreadFlag ) then
        ! spread a cloudy radiance to other bands according to the f^4 law
        ! The source cloudy radiance must be from a single sideband signal
        if ( .not. ValidateVectorQuantity ( sourceQuantity, &
          & quantityType=(/l_cloudInducedRadiance/), &
          & sideband=(/-1,1/), minorFrame=.true. )) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate sourceQuantity radiance for fill' )
        do i=1,size(signalOut%frequencies)
          do maf=1, quantity%template%noInstances
            do mif=1, quantity%template%noSurfs
              scaledRad = sourceQuantity%values ( MyChannel + &
                & (mif-1) * size(signalIn%frequencies), maf) * &
                & freq2(i)**4/freq1(MyChannel)**4
              if ( iand ( ichar ( Quantity%mask(i+(mif-1) * &
                & size(signalOut%frequencies), maf)), m_cloud) /= 0 ) &
                & quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = scaledRad
            end do
          end do
        end do

      else
        ! split two sideband radiances according to the f^4 law
        ! The source cloudy radiance must be from the same signal of double sideband

        if ( .not. ValidateVectorQuantity ( sourceQuantity, &
          & quantityType=(/l_cloudInducedRadiance/), &
          & sideband=(/0/), signal=(/quantity%template%signal/), minorFrame=.true. )) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate sourceQuantity radiance for fill' )
        if ( .not. ValidateVectorQuantity ( lsbFraction, &
          & quantityType=(/l_limbSidebandFraction/), &
          & signal=(/quantity%template%signal/), sideband=(/-1/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate lsbFraction quantity for fill' )
        if ( .not. ValidateVectorQuantity ( usbFraction, &
          & quantityType=(/l_limbSidebandFraction/), &
          & signal=(/quantity%template%signal/), sideband=(/1/) ) ) &
          & call Announce_Error ( key, no_error_code, 'Inappropriate usbFraction quantity for fill' )

        ! This method is only appliable to the cloud-induced radiances. One may assume
        ! that the scattering radiances are proportional to f^4. And this operation
        ! is only applied to maskbit = m_cloud.

        if ( .not. associated(usb) ) then
          ! If both sidebands are within 20GHz and have similar penetration depths
          ! in the attenuative atmosphere. We can neglect the attenuation and split cloudy
          ! radiances assuming that they are fully due to scattering and obey the f^4 law.
          do i=1,size(signalOut%frequencies)
            do maf=1, quantity%template%noInstances
              do mif=1, quantity%template%noSurfs
                if ( iand ( ichar ( Quantity%mask( i + &
                  & (mif-1) * size(signalOut%frequencies), maf)), m_cloud) /= 0 ) then
                  quantity%values(i+(mif-1)*size(signalOut%frequencies), maf ) = &
                    & sourceQuantity%values ( myChannel + &
                    & (mif-1)*size(signalIn%frequencies), maf) *freq2(i)**4/ &
                    & (lsbFraction%values ( myChannel, 1 ) * freqL1(MyChannel)**4 + &
                    & usbFraction%values ( myChannel, 1 ) * freqU1(MyChannel)**4)
                end if
              end do
            end do
          end do
        else
          ! If both sidebands are within 20GHz but have very different penetration depths,
          ! where one is optically thick and one is optically thin. We may use a reference
          ! cloud radiance near the optically-thin sideband to split cloud radiance in the
          ! optically-thick sideband. The reference radiance must be a single sideband
          ! radiance in this case, namely usb (upper sideband in most cases). The usb is
          ! scaled to the sourceQty upperside (thin) via the f^4 law, and the rest cloud
          ! radiance is for the lower sideband.
          !
          ! In this case, channel will for the reference signal and sideband frac remains for
          ! source signal.
          !
          if ( .not. ValidateVectorQuantity ( usb, &
            & quantityType=(/l_cloudInducedRadiance/), sideband=(/-1,1/), &
            & minorFrame=.true. )) call Announce_Error ( key, no_error_code, &
            & 'Inappropriate reference radiance for splitting' )

          signalRef = GetSignal ( usb%template%signal )

          call allocate_test ( freq, size(signalRef%frequencies), 'frequencies', ModuleName )
          call allocate_test ( freqL, size(signalRef%frequencies), &
            & 'LSBfrequencies', ModuleName )
          call allocate_test ( freqU, size(signalRef%frequencies), &
            & 'USBfrequencies', ModuleName )
          freq = signalRef%centerFrequency + signalRef%direction*signalRef%frequencies
          freqL = signalOut%lo - freq    ! lower sideband freq
          freqU = signalOut%lo + freq    ! upper sideband freq
          if ( usb%template%sideband == -1) freq = freqL
          if ( usb%template%sideband == 1) freq = freqU
          do i=1,size(signalOut%frequencies)

            ! need to scale the opposite sideband for the output signal
            if ( quantity%template%sideband == 1 ) then
              ratio1 = lsbFraction%values(i,1)
              ratio2 = usbFraction%values(i,1)
              freq2 = freqL2
            end if
            if ( quantity%template%sideband == -1 ) then
              ratio2 = lsbFraction%values(i,1)
              ratio1 = usbFraction%values(i,1)
              freq2 = freqU2
            end if

            do maf=1, quantity%template%noInstances
              do mif=1, quantity%template%noSurfs
                scaledRad = usb%values(MyChannel+(mif-1)*size(signalIn%frequencies), maf) * &
                  & freq2(i)**4/freq(MyChannel)**4

                if ( iand ( ichar ( Quantity%mask( i + &
                  & (mif-1)*size(signalOut%frequencies), maf)), m_cloud) /= 0 ) then
                  quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = &
                    &  (sourceQuantity%values(i+(mif-1)*size(signalIn%frequencies), maf) - &
                    &  ratio1*scaledRad)/ratio2
                end if
              end do
            end do
          end do

          call deallocate_test ( freq, 'frequencies', ModuleName )
          call deallocate_test ( freqL,'LSBfrequencies', ModuleName )
          call deallocate_test ( freqU,'USBfrequencies', ModuleName )
        end if
      end if

      call deallocate_test ( freq1, 'frequencies', ModuleName )
      call deallocate_test ( freqL1,'LSBfrequencies', ModuleName )
      call deallocate_test ( freqU1,'USBfrequencies', ModuleName )
      call deallocate_test ( freq2, 'frequencies', ModuleName )
      call deallocate_test ( freqL2,'LSBfrequencies', ModuleName )
      call deallocate_test ( freqU2,'USBfrequencies', ModuleName )
    end subroutine FillFromSplitSideband

    ! ------------------------------------- FillVectorHydrostatically ----
    subroutine FillGPHPrecision ( key, quantity, &
      & tempPrecisionQuantity, refGPHPrecisionQuantity )
      ! Fill the GPH precision from the temperature and refGPH precision,
      ! ignoring the of diagonal elements (not available outside
      ! RetrievalModule anyway).
      integer, intent(in) :: key          ! For messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: TEMPPRECISIONQUANTITY
      type (VectorValue_T), intent(in) :: REFGPHPRECISIONQUANTITY

      ! Local variables

      ! Executable code

      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_begin ( "FillGPHPrecision", key )

      select case ( quantity%template%quantityType )
      case ( l_gph )
        if ( (tempPrecisionQuantity%template%noSurfs /= &
          &   quantity%template%noSurfs) .or. &
          &  (refGPHPrecisionQuantity%template%noInstances /= &
          &   quantity%template%noInstances) .or. &
          &  (tempPrecisionQuantity%template%noInstances /= &
          &   quantity%template%noInstances) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            & "case l_gph failed first test" )
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FillGPHPrecision")
          return
        end if
        if ( (any(quantity%template%surfs /= tempPrecisionQuantity%template%surfs)) .or. &
          & (any(quantity%template%phi /= tempPrecisionQuantity%template%phi)) .or. &
          & (any(quantity%template%phi /= refGPHPrecisionQuantity%template%phi)) ) then
          call Announce_Error ( key, nonConformingHydrostatic, &
            &  "case l_gph failed second test" )
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FillGPHPrecision")
          return
        end if
        call GetGPHPrecision ( tempPrecisionQuantity, refGPHPrecisionQuantity, quantity%values )
      case default
        call Announce_error ( 0, no_error_code, 'GPH precision needed for result of FillGPHPrecision' )
      end select

      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_end ( "FillGPHPrecision" )

    end subroutine FillGPHPrecision

    ! -------------------------------------- FillVectorQtyFromIsotope -----------

    subroutine FillVectorQtyFromIsotope ( quantity, sourceQuantity, &
              & ratioQuantity )
      ! This routine fills one vector from another, given an appropriate
      ! isotope ratio.

      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY ! Quantity to take vmr from
      type (VectorValue_T), intent(in) :: RATIOQUANTITY ! Isotope ratio information

      ! Local variables
      real (r8) :: FACTOR                 ! Multiplier to apply to sourceQuantity

      ! Executable code

      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/ l_vmr /), frequencyCoordinate=(/ l_none /) ) ) &
        &   call MLSMessage ( MLSMSG_Error, ModuleName, &
        &      "Inappropriate quantity for isotope fill")

      if ( .not. ValidateVectorQuantity ( sourceQuantity, &
        & quantityType=(/ l_vmr /), frequencyCoordinate=(/ l_none /) ) ) &
        &   call MLSMessage ( MLSMSG_Error, ModuleName, &
        &      "Inappropriate source quantity for isotope fill")

      if ( .not. ValidateVectorQuantity ( ratioQuantity, &
        & quantityType=(/ l_isotopeRatio /), frequencyCoordinate=(/ l_none /), &
        & noInstances=(/1/), noSurfs=(/1/) ) ) &
        &   call MLSMessage ( MLSMSG_Error, ModuleName, &
        &     "Inappropriate form/quantity for isotope ratio")


      if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) .or. &
        &  .not. DoVGridsMatch ( quantity, sourceQuantity ) ) &
        &    call MLSMessage ( MLSMSG_Error, ModuleName, &
        &      "Quantity and source quantity don't match for isotope fill" )

      if ( quantity%template%molecule == sourceQuantity%template%molecule ) &
        & call MLSMessage( MLSMSG_Error, ModuleName, &
        &   "Source and quantity both describe same molecule in isotope fill")

      if ( ratioQuantity%template%molecule == quantity%template%molecule ) then
        ! Going from parent to isotope
        factor = ratioQuantity%values(1,1)
      else if ( ratioQuantity%template%molecule == sourceQuantity%template%molecule ) then
        ! Going from isotope to parent
        factor = 1.0/ratioQuantity%values(1,1)
      else
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Unable to understand isotope fill" )
      end if

      quantity%values = sourceQuantity%values * factor

    end subroutine FillVectorQtyFromIsotope

    ! ----------------------------------- FillQuantityFromASCIIFile --------
    subroutine FillQuantityFromAsciiFile ( key, quantity, filename, badRange )
      use IO_stuff, only: GET_LUN
      use Machine, only: IO_Error
      use MoreMessage, only: MLSMessage
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      integer, intent(in) :: FILENAME   ! ASCII filename to read from
      real(r8), dimension(2), optional, intent(in) :: BADRANGE ! Range for missing data
      ! Local variables
      integer :: LUN                    ! Unit number
      integer :: STATUS                 ! Flag from open/close/read etc.
      character(len=1024) :: FILENAMESTR
      ! Executable code
      call get_lun ( lun, msg=.false. )
      if ( lun < 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "No logical unit numbers available" )
      call Get_String ( filename, filenameStr, strip=.true. )
      open ( unit=lun, file=filenameStr, status='old', form='formatted', &
        & access='sequential', iostat=status )
      if ( status /= 0 ) then
        call io_Error ( "Unable to open ASCII input file ", status, filenameStr )
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error opening ASCII file at %l', &
          & (/ source_ref(key) /) )
      end if
      read ( unit=lun, fmt=*, iostat=status ) quantity%values
      if ( status /= 0 ) then
        call io_Error ( "Unable to read ASCII input file ", status, filenameStr )
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error reading ASCII file %l', &
          & (/ source_ref(key) /) )
      end if
      close ( unit=lun, iostat=status )
      if ( status /= 0 ) then
        call io_Error ( "Unable to close ASCII input file ", status, filenameStr )
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error closing ASCII file at %l', &
          & (/ source_ref(key) /) )
      end if
      if ( present ( badRange ) ) then
        if ( .not. associated ( quantity%mask ) ) call CreateMask ( quantity )
        where ( quantity%values >= badRange(1) .and. &
          & quantity%values <= badRange(2) )
          quantity%mask = char(ior(ichar(quantity%mask),m_linAlg))
        end where
      end if
    end subroutine FillQuantityFromAsciiFile

    ! --------------------------------------------- RotateMagneticField ----
    subroutine RotateMagneticField ( key, qty, fieldECR, ecrToFOV )
      use Intrinsic, only: L_FIELDAZIMUTH, L_FIELDELEVATION, L_FIELDSTRENGTH
      use Units, only: RAD2DEG
      integer, intent(in) :: KEY        ! Where are we in the l2cf?
      type (VectorValue_T), intent(inout) :: QTY ! The quantity to fill
      type (VectorValue_T), intent(in) :: FIELDECR ! The input field
      type (VectorValue_T), intent(in) :: ECRTOFOV ! The rotation matrix
      ! Local variables
      integer :: INSTANCE               ! Loop counter
      integer :: SURFACE                ! Loop counter
      integer :: MAF(1)                 ! Which MAF is the best match to this instance
      real(r8) :: THISFIELD(3)          ! A magnetic field vector
      real(r8) :: ROTATION(3,3)         ! One rotation matrix
      real(r8) :: STRENGTH              ! The field strength

      ! Executable code
      ! Do some sanity checks
      if ( .not. any ( qty%template%quantityType == &
        & (/ l_fieldStrength, l_fieldAzimuth, l_fieldElevation /) ) ) then
        call Announce_Error ( key, no_error_code, 'Inappropriate quantity for this fill' )
        return
      end if
      if ( .not. DoHGridsMatch ( qty, fieldECR ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Field and result quantity must have matching hGrids' )
        return
      end if
      if ( .not. DoVGridsMatch ( qty, fieldECR ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Field and result quantity must have matching hGrids' )
        return
      end if

      do instance = 1, qty%template%noInstances
        ! Identify the relevant MAF and pull out the first MIF's rotation matrix
        ! (first MIF is probably close enough to all the others to be useful).
        maf = minloc ( abs ( qty%template%phi(1,instance) - &
          & ecrToFOV%template%phi(1,:) ) )
        rotation = reshape ( ecrToFOV%values( 1:9, maf), (/ 3, 3 /) )
        ! Now loop over the pressure levels in the input and output field information
        do surface = 1, qty%template%noSurfs
          ! Get the field in ECR coordinates
          thisField = fieldECR%values ( (surface-1) * 3 + 1 : surface*3, &
            & instance )
          ! Now rotate it into IFOVPP coordinates
          thisField = matmul ( rotation, thisField )
          ! Now work out the strength / angles as appropriate.
          strength = sqrt ( sum ( thisField ** 2 ) )
          select case ( qty%template%quantityType )
          case ( l_fieldStrength )
            qty%values(surface,instance) = strength
          case ( l_fieldElevation )
            if ( strength /= 0.0_r8 ) then
              ! Elevation is constrained to 0--90 degrees instead of 0--180 degrees because
              ! radiative transfer Physics is symmetric.  We save half of l2pc bins.
              qty%values(surface,instance) = acos ( abs ( thisField(3) / strength ) ) * rad2deg
            else
              qty%values(surface,instance) = 0.0
            end if
          case ( l_fieldAzimuth )
            if ( thisField(1) /= 0.0_r8 ) then
              qty%values(surface,instance) = atan ( thisField(2) / thisField(1) ) * rad2deg
            else
              qty%values(surface,instance) = merge ( 90.0_r8, -90.0_r8, &
                & thisField(1) > 0.0_r8 )
            end if
          end select
        end do
      end do

    end subroutine RotateMagneticField

    !=============================================== ExplicitFillVectorQuantity ==
    subroutine ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
      & globalUnit, dontmask, &
      & AzEl, options, FillValue )

      ! This routine is called from MLSL2Fill to fill values from an explicit
      ! fill command line

      ! Dummy arguments
      type (VectorValue_T), intent(inout) :: QUANTITY ! The quantity to fill
      integer, intent(in) :: VALUESNODE   ! Tree node
      logical, intent(in) :: SPREADFLAG   ! One instance given, spread to all
      integer, intent(in) :: GLOBALUNIT   ! From parent vector
      logical, intent(in) :: DONTMASK     ! Don't bother with the mask
      logical, intent(in), optional :: AzEl ! Values are in [Mag, Az, El]; the
        ! desired quantity is components of Mag in the coordinate system to
        ! which Az and El are referenced.  So the number of values has to be
        ! a multiple of 3.
                                          ! (defaults to replacing all)
      ! The options are peculiar to this procedure, apart from verbose
      ! option           meaning
      ! ------           -------
      !   v              verbose
      !   e              replace only values in quantity == FillValue
      !   n              replace only values in quantity != FillValue
      !                   (defaults to replacing all)
      character (len=*), optional, intent(in) :: options ! E.g., '-v'
      real(r8), intent(in), optional :: FillValue

      ! Local variables
      integer :: K                        ! Loop counter
      integer :: I,J                      ! Other indices
      logical :: MyAzEl
      real(kind(quantity%values)) :: myFillValue
      character (len=8) :: myOptions
      integer :: NoValues
      integer :: TestUnit                 ! Unit to use
      integer, dimension(2) :: unitAsArray ! Unit for value given
      real (r8), pointer, dimension(:) :: VALUES
      real (r8), dimension(2) :: valueAsArray ! Value given
      logical :: Verbose
      character(len=2) :: whichToReplace ! '/=' (.ne. fillValue), '==', or ' ' (always)

      ! Executable code
      myAzEl = .false.
      if ( present(azEl) ) myAzEl = azEl
      myOptions = ' '
      if ( present(options) ) myOptions = options

      testUnit = quantity%template%unit
      if ( globalUnit /= phyq_Invalid ) testUnit = globalUnit
      noValues = nsons(valuesNode) - 1

      myFillValue = 0.
      if ( present(FillValue) ) myFillValue = FillValue

      whichToReplace = ' '
      if ( index(myOptions, 'e') > 0 ) then
        whichToReplace = '=='
      elseif ( index(myOptions, 'n') > 0 ) then
        whichToReplace = '/='
      end if
      verbose = ( index(myOptions, 'v') > 0 )
      ! Check the dimensions work out OK
      if ( myAzEl .and. mod(noValues,3) /= 0 ) &
          & call Announce_Error ( valuesNode, invalidExplicitFill )
      if ( spreadFlag ) then
        if ( noValues /= quantity%template%instanceLen .and. &
          & noValues /= quantity%template%noChans .and. &
          & noValues /= 1 ) &
          & call Announce_Error ( valuesNode, invalidExplicitFill )
      else
        if ( noValues /= &
          & quantity%template%instanceLen * quantity%template%noInstances ) &
          & call Announce_Error ( valuesNode, invalidExplicitFill, &
            & extraInfo = (/ &
              & quantity%template%instanceLen * quantity%template%noInstances /) )
      end if

      ! Get the values the user asked for, checking their units
      nullify ( values )
      call Allocate_test ( values, noValues, 'values', ModuleName )
      if ( .not. myAzEl ) then
        do k = 1, noValues
          call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
            & (/testUnit, PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), testUnit, PHYQ_Dimensionless/) )
          values ( k ) = valueAsArray(1)
        end do
      else
        ! Convert from Mag, Az, El to 3-D projections
        do k = 1, noValues, 3
          call expr_check ( subtree(k+1,valuesNode) , unitAsArray, valueAsArray, &
            & (/testUnit, PHYQ_Dimensionless/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), testUnit, PHYQ_Dimensionless/) )
          values ( k ) = valueAsArray(1)
          ! Next two quantities have to be angles
          call expr_check ( subtree(k+2,valuesNode) , unitAsArray, valueAsArray, &
            & (/PHYQ_Angle/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
          values (k+1) = deg2rad * valueAsArray(1)
          call expr_check ( subtree(k+3,valuesNode) , unitAsArray, valueAsArray, &
            & (/PHYQ_Angle/), unitsError )
          if ( unitsError ) call Announce_error ( valuesNode, wrongUnits, &
            & extraInfo=(/unitAsArray(1), PHYQ_Angle/) )
          values (k+2) = deg2rad * valueAsArray(1)
          values(k:k+2) = values(k) * (/ cos(values(k+1))*cos(values(k+2)), &
                                         sin(values(k+1))*cos(values(k+2)), &
                                         sin(values(k+2)) /)
        end do
      end if

      if ( verbose ) then
        call output('Explicit fill of values for ', advance='no')
        call display_string ( quantity%template%name )
        call newline
        call output(values)
        call newline
      end if
      ! Now loop through the quantity
      k = 0
      do i = 1, quantity%template%noInstances
        do j = 1, quantity%template%instanceLen
          k = k + 1
          if ( .not. dontMask .and. associated ( quantity%mask ) ) then
            if ( iand ( ichar(quantity%mask(j,i)), m_Fill ) /= 0 ) cycle
          end if
          select case (whichToReplace)
          case ('/=')
            if ( quantity%values(j,i) == myFillValue ) cycle
          case ('==')
            if ( quantity%values(j,i) /= myFillValue ) cycle
          end select
          quantity%values(j,i) = values ( mod ( k-1, noValues ) + 1 )
        end do
      end do

      if ( verbose ) then
        call output(quantity%values(1,:))
        call newline
      end if
      ! Tidy up
      call Deallocate_test ( values, 'values', ModuleName )

    end subroutine ExplicitFillVectorQuantity

    ! ----------------------------------------- FillVectorQuantityFromL1B ----
    subroutine FillVectorQuantityFromL1B ( root, quantity, chunk, filedatabase, &
      & isPrecision, suffix, PrecisionQuantity, BOMask )
      use BitStuff, only: NegativeIfBitPatternSet
      use MLSFiles, only: HDFVERSION_5
      use MLSStrings, only: lowercase
      use output_m, only: blanks, output
      integer, intent(in) :: root
      type (VectorValue_T), INTENT(INOUT) ::        QUANTITY
      type (MLSChunk_T), INTENT(IN) ::              CHUNK
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      logical, intent(in)               ::          ISPRECISION
      integer, intent(in), optional :: SUFFIX
      type (VectorValue_T), INTENT(IN), optional :: PRECISIONQUANTITY
      integer, intent(in), optional :: BOMask ! A pattern of bits--
                                              ! set prec. neg. if matched
      ! Local variables
      integer                               :: BO_error
      type (l1bData_T)                      :: BO_stat
      integer                               :: channel
      character (len=132)                   :: MODULENAMESTRING
      character (len=132)                   :: NAMESTRING
      integer                               :: FLAG, NOMAFS, maxMIFs
      type (l1bData_T)                      :: L1BDATA
      type (MLSFile_T), pointer             :: L1BFile
      type (MLSFile_T), pointer             :: L1BOAFile
      integer                               :: ROW, COLUMN
      integer                               :: myBOMask
      integer                               :: this_hdfVersion

      ! Executable code
      myBOMask = 0
      if ( present(BOMask) ) myBOMask = BOMask
      if ( toggle(gen) .and. levels(gen) > 0 ) &
        & call trace_begin ("FillVectorQuantityFromL1B",root)
      ! print *, 'Filling vector quantity from l1b'
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      L1BOAFile => GetMLSFileByType(filedatabase, content='l1boa')
      this_hdfVersion = L1BFile%HDFVersion
      ! fileID = L1BFile%FileID%f_id

      select case ( quantity%template%quantityType )
      case ( l_ECRtoFOV )
        call GetModuleName( quantity%template%instrumentModule, nameString )
        nameString = AssembleL1BQtyName('ECRtoFOV', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case ( l_L1BMAFBaseline )
        call GetSignalName ( quantity%template%signal, nameString, &
          & sideband=quantity%template%sideband, noChannels=.TRUE. )
        nameString = AssembleL1BQtyName(nameString, this_hdfVersion, .FALSE.)
      case ( l_l1bMIF_TAI )
        if ( this_hdfVersion == HDFVERSION_5 ) then
          call GetModuleName ( quantity%template%instrumentModule, nameString )
          nameString = AssembleL1BQtyName ('MIF_TAI', this_hdfVersion, .FALSE., &
            & trim(nameString) )
        else ! ??? MIF_TAI is goofy in HDF4 files -- no sc, no tp, no GHz....
          nameString = 'MIF_TAI'
        end if
      case ( l_LosVel )
        call GetModuleName ( quantity%template%instrumentModule, nameString )
        nameString = AssembleL1BQtyName ('LosVel', this_hdfVersion, .TRUE., &
          & trim(nameString) )
      case ( l_orbitInclination )
        nameString = AssembleL1BQtyName('OrbIncl', this_hdfVersion, .FALSE., &
          & 'sc')
      case ( l_ptan )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('ptan', this_hdfVersion, .FALSE., &
          & trim(nameString))
      case ( l_radiance )
        call GetSignalName ( quantity%template%signal, nameString, &
          & sideband=quantity%template%sideband, noChannels=.TRUE. )
        nameString = AssembleL1BQtyName(nameString, this_hdfVersion, .FALSE.)
        L1BFile => GetL1bFile(filedatabase, namestring)
        ! fileID = FindL1BData (filedatabase, nameString )
      case ( l_scECI )
        nameString = AssembleL1BQtyName('ECI', this_hdfVersion, .FALSE., 'sc')
      case ( l_scGeocAlt )
        nameString = AssembleL1BQtyName('GeocAlt', this_hdfVersion, .FALSE., &
          & 'sc')
      case ( l_scVel )
        nameString = AssembleL1BQtyName('Vel', this_hdfVersion, .FALSE., 'sc')
      case ( l_scVelECI )
        nameString = AssembleL1BQtyName('VelECI', this_hdfVersion, .FALSE., &
          & 'sc')
      case ( l_scVelECR )
        nameString = AssembleL1BQtyName('VelECR', this_hdfVersion, .FALSE., &
          & 'sc')
      case ( l_tngtECI )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('ECI', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case ( l_tngtGeocAlt )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('GeocAlt', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case ( l_tngtGeodAlt )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('GeodAlt', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case default
        call Announce_Error ( root, cantFillFromL1B )
      end select

      ! Perhaps will need to read bright object status from l1bOA file
      if ( isPrecision .and. myBOMask /= 0 ) then
        call GetModuleName ( quantity%template%instrumentModule, moduleNameString )
        moduleNameString = AssembleL1BQtyName('BO_stat', this_hdfVersion, .TRUE., &
          & trim(moduleNameString))
        call ReadL1BData ( L1BOAFile, moduleNameString, BO_stat, noMAFs, &
          & flag=BO_error, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail= .true., &
          & dontPad=DONTPAD )
      end if

      if ( present ( suffix ) ) then
        if ( suffix /= 0 ) then
          call Get_String ( suffix, &
            & nameString(len_trim(nameString)+1:), strip=.true. )
          ! Look for the field again
          L1BFile => GetL1bFile(filedatabase, namestring)
          ! fileID = FindL1BData (filedatabase, nameString )
          ! Note we won't find it if it's in the OA file, I'm going to ignore that
          ! possibility for the moment.

        end if
      end if

      ! If the quantity exists (or it doesn't exist but it's not a radiance)
      if ( index(lowercase(namestring), 'baseline') > 0 .and. .false. ) then
        call output('namestring: ', advance='no')
        call output(trim(namestring), advance='yes')
        call output('associated(L1BFile): ', advance='no')
        call output(associated(L1BFile), advance='yes')
        call output('qty type: ', advance='no')
        call output(quantity%template%quantityType, advance='no')
        call blanks(3)
        call output(l_radiance, advance='no')
        call blanks(3)
        call output(l_L1BMAFBaseline, advance='yes')
      endif
      if ( associated(L1BFile) .or. ( quantity%template%quantityType /= l_radiance .and. &
        & quantity%template%quantityType /= l_L1BMAFBaseline ) ) then
        if ( isPrecision ) nameString = trim(nameString) // PRECISIONSUFFIX
        L1BFile => GetL1bFile(filedatabase, namestring)

        call ReadL1BData ( L1BFile, nameString, l1bData, noMAFs, flag, &
          & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail= .false., &
          & dontPad=DONTPAD )
        ! If it didn't exist in the not-a-radiance case, then we'll fail here.
        if ( flag /= 0 ) then
          call Announce_Error ( root, errorReadingL1B )
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FillVectorQuantityFromL1B")
          return
        end if
        if ( quantity%template%noInstances /= size ( l1bData%dpField, 3 ) .or. &
          &  quantity%template%instanceLen /= &
          &   size ( l1bData%dpField, 1 ) * size ( l1bData%dpField, 2 ) ) then
          call output ( 'Quantity shape:' )
          call output ( quantity%template%instanceLen )
          call output ( ' ( ' )
          call output ( quantity%template%noChans )
          call output ( ', ' )
          call output ( quantity%template%noSurfs )
          call output ( ' ), ' )
          call output ( quantity%template%noInstances, advance='yes' )
          call output ( 'L1B shape:' )
          call output ( size ( l1bData%dpField, 1 ) )
          call output ( ', ' )
          call output ( size ( l1bData%dpField, 2 ) )
          call output ( ', ' )
          call output ( size ( l1bData%dpField, 3 ), advance='yes' )
          call Announce_Error ( root, no_error_code, 'L1B data is wrong shape' )
          if ( toggle(gen) .and. levels(gen) > 0 ) &
            & call trace_end ( "FillVectorQuantityFromL1B")
          return
        end if

        if ( isPrecision .and. myBOMask /= 0 .and. BO_error == 0 ) then
          noMAFs = size(l1bData%dpField, 3)
          maxMIFs = l1bData%maxMIFs
          if ( switchDetail(switches, 'glob') > 0 ) then ! e.g., 'glob1'
            call output ( 'Quantity shape:' )
            call output ( quantity%template%instanceLen )
            call output ( ' ( ' )
            call output ( quantity%template%noChans )
            call output ( ', ' )
            call output ( quantity%template%noSurfs )
            call output ( ' ), ' )
            call output ( quantity%template%noInstances, advance='yes' )
            call output ( 'L1B shape:' )
            call output ( size ( l1bData%dpField, 1 ) )
            call output ( ', ' )
            call output ( size ( l1bData%dpField, 2 ) )
            call output ( ', ' )
            call output ( size ( l1bData%dpField, 3 ), advance='yes' )
            call outputNamedValue( 'shape' // trim(namestring), shape(l1bData%dpField) )
            call outputNamedValue( 'shape(BO_stat)', shape(BO_stat%intField) )
            call outputNamedValue( 'noMAFs', noMAFs )
            call outputNamedValue( 'maxMIFs', maxMIFs )
            call outputNamedValue( 'noChans', quantity%template%noChans )
          endif
          if ( switchDetail(switches, 'glob') > 1 ) then ! e.g., 'glob2'
            call dump( l1bData%dpField(1,:,:), '(Before applying bright object mask)' )
          endif
          do channel = 1, quantity%template%noChans
          l1bData%dpField(channel,:,:) = &
            & NegativeIfBitPatternSet( l1bData%dpField(channel,:,:), &
            & BO_stat%intField(1, 1:maxMIFs, 1:noMAFs), myBOMask )
          enddo
          if ( switchDetail(switches, 'glob') > 1 ) &
            & call dump( l1bData%dpField(1,:,:), '(After applying bright object mask)' )
          call DeallocateL1BData(BO_stat)
        end if

        quantity%values = RESHAPE(l1bData%dpField, &
          & (/ quantity%template%instanceLen, quantity%template%noInstances /) )
        if ( isPrecision ) then
          do column=1, size(quantity%values(1, :))
            do row=1, size(quantity%values(:, 1))
              if ( quantity%values(row, column) < 0.d0 ) &
                & call MaskVectorQty(quantity, row, column)
            end do
          end do
        else if ( present(precisionQuantity) ) then
          do column=1, size(quantity%values(1, :))
            do row=1, size(quantity%values(:, 1))
              if ( isVectorQtyMasked(precisionQuantity, row, column) ) &
                & call MaskVectorQty(quantity, row, column)
            end do
          end do
        end if

        if ( switchDetail(switches, 'l1b') > -1 ) &
          & call Dump( l1bData )
        call DeallocateL1BData(l1bData)
      else
        ! This is the case where it's a radiance we're after and it's missing
        quantity%values = DEFAULTUNDEFINEDVALUE ! -1.0
        do column=1, size(quantity%values(1,:))
          do row=1, size(quantity%values(:,1))
            call MaskVectorQty ( quantity, row, column )
          end do
        end do
      end if
      if ( toggle(gen) .and. levels(gen) > 0 ) call trace_end( "FillVectorQuantityFromL1B" )
    end subroutine FillVectorQuantityFromL1B

    ! ------------------------------------------- FillVectorQuantityFromL2AUX --
    subroutine FillVectorQuantityFromL2AUX ( qty, l2aux, errorCode )
      type ( VectorValue_T), intent(inout) :: QTY
      type ( L2AUXData_T), intent(in) :: L2AUX
      integer, intent(inout) :: ERRORCODE
      ! Local variables
      integer :: FIRSTPROFILE
      integer :: LASTPROFILE
      ! Executable code
      errorCode = 0
      ! Work out which profile in the l2aux this belongs to
      firstProfile = qty%template%instanceOffset - qty%template%noInstancesLowerOverlap
      lastProfile = firstProfile + qty%template%noInstances - 1
      ! In the case of minor/major frame quanties, while instanceOffset is
      ! Numbered from zero, as in L1B, our array starts from 1.
      if ( qty%template%minorFrame .or. qty%template%majorFrame ) then
        firstProfile = firstProfile + 1
        lastProfile = lastProfile + 1
      end if
      ! Check that the dimensions are appropriate
      if ( firstProfile < lbound ( l2aux%values, 3 ) ) then
        errorCode = CantFillFromL2AUX
        return
      end if
      if ( lastProfile > ubound ( l2aux%values, 3 ) ) then
        errorCode = CantFillFromL2AUX
        return
      end if
      if ( size ( l2aux%values, 1 ) /= qty%template%noChans .or. &
        &  size ( l2aux%values, 2 ) /= qty%template%noSurfs ) then
        errorCode = CantFillFromL2AUX
        return
      end if
      ! Do the fill
      qty%values = reshape ( l2aux%values ( :, :,  &
        & firstProfile : lastProfile ), &
        & (/ qty%template%instanceLen, qty%template%noInstances /) )
    end subroutine FillVectorQuantityFromL2AUX

    ! --------------------------------------- FillQuantityUsingMagneticModel --
    subroutine FillQuantityUsingMagneticModel ( qty, gphQty, key )
      use Geometry, only: SecPerYear
      use IGRF_INT, only: FELDC, FELDCOF, To_Cart
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(inout) :: GPHQTY
      integer, intent(in) :: KEY
      ! Local variables
      real :: B(3)                      ! Magnetic field
      integer :: INSTANCE               ! Loop counter
      integer :: SURF                   ! Loop counter
      integer :: SURFOR1                ! Index
      real    :: XYZ(3)                 ! lat, lon, height for to_cart

      ! Executable code

      if ( .not. ValidateVectorQuantity ( qty, quantityType=(/l_magneticField/), &
        & frequencyCoordinate=(/ l_xyz /) ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Quantity does not describe magnetic field' )
        return
      end if
      if ( .not. ValidateVectorQuantity ( gphQty, quantityType=(/l_gph/), &
        & frequencyCoordinate=(/ l_none /), verticalCoordinate=(/l_zeta/) ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'GPH quantity does not describe gph field' )
        return
      end if
      if ( .not. DoHGridsMatch ( qty, gphQty ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Quantity and GPHQuanity do not share the same horizontal basis' )
        return
      end if
      if ( .not. DoVGridsMatch ( qty, gphQty ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'Quantity and GPHQuantity do not share the same vertical basis' )
        return
      end if

      ! Assume the time is close enough to constant that one call to
      ! FELDCOF is accurate enough.

      call feldcof ( real(qty%template%time(1,1)/secPerYear + epoch) )

      do instance = 1, qty%template%noInstances
        do surf = 1, qty%template%noSurfs
          if ( qty%template%stacked ) then
            surfOr1 = 1
          else
            surfOr1 = surf
          end if
          ! Convert (/ lat(deg), lon(deg), height(km) /) to cartesian (e-radius)
          call to_cart ( real( (/ qty%template%geodLat(surfOr1,instance), &
            &                     qty%template%lon(surfOr1,instance), &
            &                     gphQty%values(surf,instance)*1.0e-3 /) ), xyz )
          ! Compute the field at and w.r.t. cartesian coordinates
          call feldc ( xyz, b )
          qty%values ( surf*3-2 : surf*3, instance) = b
        end do
      end do

      if ( switchDetail(switches,'mag') > -1 ) &
        & call dump ( qty, clean=(switchDetail(switches,'clean') > -1) )

    end subroutine FillQuantityUsingMagneticModel

    ! ------------------------------------------- FillQtyFromInterpolatedQty
    subroutine FillQtyFromInterpolatedQty ( qty, source, force, key )
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) :: SOURCE
      logical, intent(in) :: FORCE
      integer, intent(in) :: KEY

      ! Local variables
      real (r8), dimension(:), pointer :: oldSurfs, newSurfs
      real (r8), dimension(:,:), pointer :: newValues
      logical :: mySurfs, myNewValues

      ! Executable code
      call MLSMessageCalls( 'push', constantName='FillQtyFromInterpolatedQty' )
      if ( .not. DoQtysDescribeSameThing ( qty, source ) .and. .not. force ) then
        call Announce_error ( key, no_error_code, &
          & 'Mismatch in quantities' )
        return
      end if
      if ( .not. doHGridsMatch ( qty, source ) ) then
        call Announce_error ( key, no_error_code, &
          & 'Mismatch in horizontal grid' )
        return
      end if
      if ( .not. doFGridsMatch ( qty, source ) ) then
        call Announce_error ( key, no_error_code, &
          & 'Mismatch in frequency grid' )
        return
      end if

      ! Two cases here, one where we have to interpolate vertically (has to be
      ! single channel quantity).  The other where we don't.  Most of the latter
      ! cases can be handled by the code that calls this routine.  The exception
      ! is when we've used the force option to e.g. copy one band into another.
      if ( .not. doVGridsMatch ( qty, source ) ) then
        ! This quantity needs vertical interpolation
        ! These checks are for cases the code can't (yet) handle,
        ! may add this functionality later.
        if ( qty%template%noChans /= 1 ) then
          call Announce_error ( key, no_error_code, &
            & 'Code cannot (yet?) interpolate multi channel quantities' )
          return
        end if
        if ( .not. all ( (/ qty%template%coherent, source%template%coherent /) ) ) then
          call Announce_error ( key, no_error_code, &
            & 'Code cannot (yet?) interpolate incoherent quantities' )
          return
        end if

        ! Work out vertical coordinate issues
        if ( qty%template%verticalCoordinate == l_pressure ) then
          nullify ( oldSurfs, newSurfs )
          call Allocate_test ( oldSurfs, source%template%noSurfs, 'oldSurfs', ModuleName )
          call Allocate_test ( newSurfs, qty%template%noSurfs, 'newSurfs', ModuleName )
          oldSurfs = -log10 ( source%template%surfs(:,1) )
          newSurfs = -log10 ( qty%template%surfs(:,1) )
          mySurfs = .true.
        else
          oldSurfs => source%template%surfs ( :, 1 )
          newSurfs => qty%template%surfs ( :, 1 )
          mySurfs = .false.
        end if

        ! Work out if we have to obey the mask
        myNewValues = .false.
        if ( associated ( qty%mask ) ) &
          & myNewValues = any ( iand ( ichar(qty%mask(:,:)), m_fill ) /= 0 )
        if ( myNewValues ) then
          nullify ( newValues )
          call Allocate_test ( newValues, qty%template%instanceLen, &
            & qty%template%noInstances, 'myNewValues', ModuleName )
        else
          newValues => qty%values
        end if

        ! OK, do the work
        if ( qty%template%logBasis ) then
          call InterpolateValues ( &
            & oldSurfs, log ( max ( source%values, sqrt(tiny(0.0_r8)) ) ), &
            & newSurfs, newValues, &
            & method='Linear', extrapolate='Constant' )
          newValues = exp ( newValues )
        else
          call InterpolateValues ( &
            & oldSurfs, source%values, &
            & newSurfs, newValues, &
            & method='Linear', extrapolate='Constant' )
        end if

        if ( myNewValues ) then
          where ( iand ( ichar(qty%mask(:,:)),m_fill) == 0 )
            qty%values = newValues
          end where
          call Deallocate_test ( newValues, 'myNewValues', ModuleName )
        end if

        ! Tidy up
        if ( mySurfs ) then
          call Deallocate_test ( oldSurfs, 'oldSurfs', ModuleName )
          call Deallocate_test ( newSurfs, 'newSurfs', ModuleName )
        end if
      else ! ------------------------
        ! No interpolation needed, more like the
        ! case handled in the calling code, except we're more lenient
        ! If we have a mask and we're going to obey it then do so
        if ( associated(quantity%mask) .and. .not. dontMask ) then
          where ( iand ( ichar(quantity%mask(:,:)), m_Fill ) == 0 )
            quantity%values(:,:) = sourceQuantity%values(:,:)
          end where
        else ! Otherwise, just blindly copy
          quantity%values = sourceQuantity%values
        end if
      end if
      call MLSMessageCalls( 'pop' )

    end subroutine FillQtyFromInterpolatedQty

    !=============================== FillQuantityFromLosGrid ====
    subroutine FillQuantityFromLosGrid ( key, Qty, LOS, &
      & Ptan, Re, noFineGrid, extinction, errorCode )

      ! This is to fill a l2gp type of quantity with a los grid type of quantity.
      ! The los quantity is a vector quantity that has dimension of (s, mif, maf),
      ! where s is the path along los.

      ! Linear interpolation is used to fill l2gp grids and unfilled grids are
      ! marked with the baddata flag (-999.)

      ! Dummy arguments
      integer, intent(in) :: key          ! For messages
      type (VectorValue_T), intent(in) :: LOS ! Vector quantity to fill from
      type (VectorValue_T), intent(in) :: Ptan ! tangent pressure
      type (VectorValue_T), intent(in) :: Re ! Earth's radius
      type (VectorValue_T), INTENT(INOUT) :: QTY ! Quantity to fill
      integer, intent(in) :: noFineGrid   ! make finer sGrid with this number
      logical, intent(in) :: extinction  ! Flag for extinction fill and calculation
      integer, intent(out) :: errorCode ! Error code

      ! Local variables
      integer :: i, j, maf, mif                ! Loop counter
      integer :: maxZ, minZ                    ! pressure range indices of sGrid
      integer :: noMAFs,noMIFs,noDepths
      integer, dimension(qty%template%noSurfs,qty%template%noInstances) :: cnt
      real (r8), dimension(qty%template%noSurfs,qty%template%noInstances) :: out
      real (r8), dimension(qty%template%noSurfs) :: outZeta, phi_out, beta_out
      real (r8), dimension(los%template%noChans) :: x_in, y_in, sLevel
      real (r8), dimension(los%template%noSurfs) :: zt
      real (r8), dimension(los%template%noChans*noFineGrid) :: betaFine, TransFine, SFine
      real (r8), dimension(los%template%noChans, &
        & los%template%noSurfs,los%template%noInstances) :: beta
      real (r8) :: ds, ColTrans

      if ( toggle(gen) ) call trace_begin ( "FillQuantityFromLosGrid", key )

      errorCode=0

      ! Make sure this quantity is appropriate
      !    if ( .not. ValidateVectorQuantity(qty, coherent=.TRUE., stacked=.TRUE., &
      !      & verticalCoordinate= (/ l_pressure, l_zeta /) ) ) then
      !      call output ( " quantity vertical grid in FillQuantityFromLOSgrid is not valid")
      !    end if

      if ( qty%template%verticalCoordinate == l_pressure ) then
        outZeta = -log10 ( qty%template%surfs(:,1) )
      else
        outZeta = qty%template%surfs(:,1)
      end if

      noMAFs=los%template%noInstances
      noMIFs=los%template%noSurfs
      ! Now, we use frequency coordinate as sGrid along the path
      noDepths=los%template%noChans
      sLevel = los%template%frequencies

      ! the input losQty is the increment of cloud transmission function by default.
      ! it is converted to cloud extinction if extinction flag is on.
      if ( extinction ) then
        ! both sGrid and sFineGrid are expected to be evenly spaced at present
        ds = sLevel(2)-sLevel(1)
        do i=1,noDepths
          do j=1,noFineGrid
            Sfine(j+(i-1)*noFineGrid) = sLevel(i)+(j-1._r8)*ds/noFineGrid
          end do
        end do

        do maf=1,noMafs
          do mif=1,noMifs
            do i=1,noDepths
              ! convert increments to derivatives
              y_in(i) = los%values(i+(mif-1)*noDepths,maf)/ds
            end do
            call InterpolateValues(sLevel,y_in,sFine,TransFine,method='Linear')
            ! calculate column transmission function by integrating
            ! the derivatives on fine grid
            do i=1,noFineGrid*noDepths
              betaFine(i) = 0._r8
              colTrans=0._r8
              do j=1,i
                colTrans=colTrans + transFine(j)*ds/noFineGrid
              end do
              colTrans = 1._r8 - colTrans
              if ( colTrans > 0.02_r8) betaFine(i)= transFine(i)/colTrans
            end do
            ! interpolate betaFine back to the coarser sGrid
            call InterpolateValues(sFine,betaFine,sLevel,beta(:,mif,maf),method='Linear')

          end do
        end do

      else

        do maf=1,noMafs
          do mif=1,noMifs
            do i=1,noDepths
              beta(i,mif,maf)=los%values(i+(mif-1)*noDepths,maf)
            end do
          end do
        end do

      end if

      ! initialize quantity
      do j = 1, qty%template%noInstances
        do i = 1, qty%template%noSurfs
          qty%values(i,j)=qty%template%badValue
          cnt(i,j)=0
          out(i,j)=0._r8
        end do
      end do

      do maf=1,noMAFs
        zt = ptan%values(:,maf)   ! noChans=1 for ptan
        zt = (zt+3.)*16.                      ! converted to height in km
        do mif=1,noMIFs
          if ( ptan%values(mif,maf) .gt. -2.5) cycle ! for testing
          ! find altitude of each s grid
          x_in = sLevel**2/2./(re%values(1,maf)*0.001_r8 + zt(mif))
          ! converted to zeta
          x_in = x_in/16. + ptan%values(mif,maf)
          ! find minimum and maximum pressures indices in sGrid
          do i = 2,qty%template%noSurfs-1
            if ( ptan%values(mif,maf) < (outZeta(i)+outZeta(i+1))/2. .and. &
              & ptan%values(mif,maf) > (outZeta(i)+outZeta(i-1))/2.) &
              & minZ = i
          end do
          if ( ptan%values(mif,maf) < (outZeta(1)+outZeta(2))/2.) minZ=1
          if ( ptan%values(mif,maf) > outZeta(qty%template%noSurfs)) cycle ! goto next mif

          do i = 2,qty%template%noSurfs-1
            if ( x_in(noDepths) < (outZeta(i)+outZeta(i+1))/2. .and. &
              & x_in(noDepths) > (outZeta(i)+outZeta(i-1))/2.) &
              & maxZ = i
          end do
          if ( x_in(noDepths) < (outZeta(1)+outZeta(2))/2.) cycle    ! goto next mif
          if ( x_in(noDepths) > outZeta(qty%template%noSurfs)) maxZ=qty%template%noSurfs

          ! get phi along path for each mif ( phi is in degree)
          y_in = los%template%phi(mif,maf) &
            & - atan(sLevel/(re%values(1,maf)*0.001_r8 + zt(mif)))*rad2deg
          ! interpolate phi onto standard vertical grids
          call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),phi_out(minZ:maxZ), &
            & method='Linear')
          ! interpolate quantity to standard vertical grids
          y_in = beta(:,mif,maf)
          call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),beta_out(minZ:maxZ), &
            & method='Linear')
          ! interpolate quantity to standard phi grids
          do i=minZ,maxZ
            do j = 2, qty%template%noInstances-1
              if ( phi_out(i) .lt. &
                & (qty%template%phi(1,j)+qty%template%phi(1,j+1))/2. &
                & .and. phi_out(i) .ge. &
                & (qty%template%phi(1,j-1)+qty%template%phi(1,j))/2. ) then
                out(i,j)=out(i,j) + beta_out(i)
                cnt(i,j)=cnt(i,j)+1       !  counter
              end if
            end do
          end do
        end do                            ! End surface loop
      end do                              ! End instance loop
      ! average all non-zero bins
      where (cnt > 0) qty%values = out/cnt

    end subroutine FillQuantityFromLosGrid

    ! --------------------------------------------- FillQuantityByManipulation ---
    subroutine FillQuantityByManipulation ( quantity, a, b, c, &
      & manipulation, key, &
      & force, spreadflag, dontSumHeights, dontSumInstances )
      use String_table, only: GET_STRING
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), pointer :: A
      type (VectorValue_T), pointer :: B
      real(rv) :: C                     ! constant "c" in manipulation
      integer, intent(in) :: MANIPULATION
      integer, intent(in) :: KEY        ! Tree node
      logical, intent(in) :: FORCE      ! If set throw caution to the wind
      ! The following args are important only for statistical functions
      logical, intent(in) :: SPREADFLAG ! If set spread across summed dimension
      logical, intent(in) :: DONTSUMHEIGHTS
      logical, intent(in) :: DONTSUMINSTANCES
      ! Local parameters
      integer, parameter :: NO2WAYMANIPULATIONS = 8
      character(len=*), parameter :: VALID2WAYMANIPULATIONS ( NO2WAYMANIPULATIONS ) = (/ &
        & 'a+b     ', &
        & '(a+b)/2 ', &
        & 'a-b     ', &
        & 'a*b     ', &
        & 'a>b     ', &
        & 'a<b     ', &
        & 'a|b     ', &
        & 'a/b     ' /)
      integer, parameter :: NO1WAYMANIPULATIONS = 13
      character(len=*), parameter :: VALID1WAYMANIPULATIONS ( NO1WAYMANIPULATIONS ) = (/ &
        & '-a         ', &
        & '1/a        ', &
        & 'abs(a)     ', &
        & 'sign(a)    ', &
        & 'exp(a)     ', &
        & 'log(a)     ', &
        & 'log10(a)   ', &
        & 'min(a)     ', &
        & 'max(a)     ', &
        & 'mean(a)    ', &
        & 'median(a)  ', &
        & 'rms(a)     ', &
        & 'stddev(a)  ' /)
      ! Local variables
      character (len=128) :: MSTR
      character (len=1) :: ABNAME
      logical :: OKSOFAR
      logical :: OneWay
      logical :: TwoWay
      logical :: StatisticalFunction
      logical :: USESC
      integer :: I, ICHAN, INSTANCE, ISURF
      logical :: NEEDSB
      integer :: NoChans
      integer :: NoInstances
      integer :: NoSurfs
      integer :: NUMWAYS ! 1 or 2
      type (VectorValue_T), pointer :: AORB
      real(rv) :: qvalue
      ! Executable code
      call MLSMessageCalls( 'push', constantName='FillQuantityByManipulation' )

      ! Currently we have a rather brain dead approach to this, so
      ! check that what the user has asked for, we can supply.
      call get_string ( manipulation, mstr, strip=.true. )
      mstr = lowercase(mstr)
      
      OneWay = any ( mstr == valid1WayManipulations )
      TwoWay = any ( mstr == valid2WayManipulations )
      usesc  = .not. ( OneWay .or. TwoWay ) .and. &
        & index(mstr, 'c') > 0
      StatisticalFunction = ( FindFirst( valid1WayManipulations, mstr ) > 7 )
      if ( .not. ( OneWay .or. TwoWay .or. usesc ) ) then
        call Announce_Error ( key, no_error_code, 'Invalid manipulation' )
        return
      end if
      
      needsB = TwoWay .or. (usesC .and. (index(mstr, 'b') > 0) )

      ! Now check the sanity of the request.
      if ( OneWay .or. usesc ) then
        numWays = 1
        if ( .not. associated ( a ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'You must supply the a quantity' )
          return
a1374 8
      elseif ( TwoWay ) then
        numWays = 2
        if ( .not. associated ( a ) .or. .not. associated ( b ) ) then
          call Announce_Error ( key, no_error_code, &
            & 'You must supply both a and b quantities' )
          return
        end if
      end if
d1376 3
a1378 8
      okSoFar = .true.
      do i = 1, numWays ! 2
        if ( i == 1 ) then
          aorb => a
          abName = 'a'
        else
          aorb => b
          abName = 'b'
d1380 2
d1383 45
a1427 18
        ! For minor frame quantities, check that we're on the same page
        if ( StatisticalFunction ) then
          ! We don't check for anything
        elseif ( .not. force ) then
          if ( quantity%template%minorFrame ) then
            okSoFar = okSoFar .and. aorb%template%minorFrame .and. &
              & quantity%template%signal == aorb%template%signal .and. &
              & quantity%template%sideband == aorb%template%sideband .and. &
              & quantity%template%frequencyCoordinate == aorb%template%frequencyCoordinate
          else if ( mstr == 'a*b' ) then
            ! In this case, just check that the coordinate systems for these quantities match
            okSoFar = okSoFar .and. &
              & DoHGridsMatch ( quantity, aorb ) .and. &
              & DoVGridsMatch ( quantity, aorb ) .and. &
              & DoFGridsMatch ( quantity, aorb, sizeOnly=.true. )
          else
            ! For a+/-b these quantities must share a template
            okSoFar = okSoFar .and. quantity%template%name == aorb%template%name
a1428 10
        else
          okSoFar = okSoFar &
            & .and. quantity%template%noInstances == aorb%template%noInstances &
            & .and. quantity%template%instanceLen == aorb%template%instanceLen
        end if

        if ( .not. okSoFar ) then
          call Announce_Error ( key, no_error_code, &
            & abName // ' is not of the same (or close enough) type as quantity' )
          return
a1429 1
      end do
d1431 5
a1435 48
      ! OK do the simple work for now
      ! Below we'll do fancy stuff to parse the more general manipulations
      if ( StatisticalFunction) then
        NoChans     = a%template%NoChans
        NoInstances = a%template%NoInstances
        NoSurfs     = a%template%NoSurfs
        if ( dontSumHeights .and. dontSumInstances ) then
          do instance = 1, NoInstances
            do iSurf = 1, NoSurfs
              call doStatFun( quantity%values(iSurf, instance), mstr, &
                & a%values(1+(iSurf-1)*NoChans:iSurf*NoChans, instance) )
            enddo
          enddo
        elseif ( dontSumInstances ) then
          do instance = 1, NoInstances
            call doStatFun( qvalue, mstr, &
              & a%values(:, instance) )
            if ( spreadFlag ) then
              quantity%values(:, instance) = qvalue
            else
              quantity%values(1, instance) = qvalue
            endif
          enddo
        elseif ( dontSumHeights ) then
          do iSurf = 1, NoSurfs
            call doStatFun( qvalue, mstr, &
              & a%values(iSurf, :) )
            if ( spreadFlag ) then
              quantity%values(iSurf, :) = qvalue
            else
              quantity%values(iSurf, 1) = qvalue
            endif
          enddo
        else
          ! Sum over both heights and instances
          select case ( mstr )
          case ( 'min(a)' )
            qvalue = mlsmin( a%values )
          case ( 'max(a)' )
            qvalue = mlsmax( a%values )
          case ( 'mean(a)' )
            qvalue = mlsmean( a%values )
          case ( 'median(a)' )
            qvalue = mlsmedian( a%values )
          case ( 'rms(a)' )
            qvalue = mlsrms( a%values )
          case ( 'stddev(a)' )
            qvalue = mlsstddev( a%values )
d1437 2
a1438 1
            ! Should not have come here
a1439 88
          if ( spreadFlag ) then
            quantity%values = qvalue
          else
            quantity%values(1, 1) = qvalue
          endif
        endif
        call MLSMessageCalls( 'pop' )
        if ( SwitchDetail(switches, 'stat') > -1 ) &
          & call dump( quantity%values, mstr )
        return
      endif
      select case ( mstr )
      ! The binary manipulations
      case ( 'a+b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = a%values + b%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = a%values + b%values
          end where
        end if
      case ( '(a+b)/2' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = 0.5 * ( a%values + b%values )
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = 0.5 * ( a%values + b%values )
          end where
        end if
      case ( 'a-b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = a%values - b%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = a%values - b%values
          end where
        end if
      case ( 'a*b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = a%values * b%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = a%values * b%values
          end where
        end if
      case ( 'a>b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = max ( a%values, b%values )
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = max ( a%values, b%values )
          end where
        end if
      case ( 'a<b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = min ( a%values, b%values )
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = min ( a%values, b%values )
          end where
        end if
      case ( 'a|b' )
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = ior ( nint(a%values), nint(b%values) )
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = ior ( nint(a%values), nint(b%values) )
          end where
        end if
      case ( 'a/b' )
        if ( .not. associated ( quantity%mask ) ) then
          where ( b%values /= 0._rv )
            quantity%values = a%values / b%values
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( b%values /= 0._rv ) )
            quantity%values = a%values / b%values
          end where
        end if
      ! The unary manipulations
      case ( '-a'  )
        if ( .not. associated ( quantity%mask ) ) then
            quantity%values = -a%values
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0  )
            quantity%values = -a%values
          end where
a1440 65
      case ( '1/a'  )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values /= 0._rv )
            quantity%values = 1./a%values
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values /= 0._rv ) )
            quantity%values = 1./a%values
          end where
        end if
      case ( 'abs(a)'  )
        if ( .not. associated ( quantity%mask ) ) then
            quantity%values = abs(a%values)
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0  )
            quantity%values = abs(a%values)
          end where
        end if
      case ( 'sign(a)' )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values /= 0._rv )
            quantity%values = sign(1._rv, a%values)
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values /= 0._rv ) )
            quantity%values = sign(1._rv, a%values)
          end where
        end if
      case ( 'exp(a)'  )
        if ( .not. associated ( quantity%mask ) ) then
            quantity%values = exp(a%values)
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0  )
            quantity%values = exp(a%values)
          end where
        end if
      case ( 'log(a)' )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values > 0._rv )
            quantity%values = log(a%values)
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values > 0._rv ) )
            quantity%values = log(a%values)
          end where
        end if
      case ( 'log10(a)' )
        if ( .not. associated ( quantity%mask ) ) then
          where ( a%values > 0._rv )
            quantity%values = log10(a%values)
          end where
        else
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 .and. &
            & ( a%values > 0._rv ) )
            quantity%values = log10(a%values)
          end where
        end if
      case default
        ! This should be one of the cases which use the constant "c"
        call SimpleExprWithC( quantity, a, b, c, mstr )
      end select
      call MLSMessageCalls( 'pop' )
d1442 33
a1474 1
    end subroutine FillQuantityByManipulation
d1476 124
a1599 21
      subroutine doStatFun( qvalue, name, avalues )
        real(rv), intent(out) :: qvalue
        character(len=*), intent(in) :: name ! of the statistical function
        real(rv), dimension(:), intent(in) :: avalues
          select case ( name )
          case ( 'min(a)' )
            qvalue = mlsmin( avalues )
          case ( 'max(a)' )
            qvalue = mlsmax( avalues )
          case ( 'mean(a)' )
            qvalue = mlsmean( avalues )
          case ( 'median(a)' )
            qvalue = mlsmedian( avalues )
          case ( 'rms(a)' )
            qvalue = mlsrms( avalues )
          case ( 'stddev(a)' )
            qvalue = mlsstddev( avalues )
          case default
            ! Should not have come here
          end select
      end subroutine doStatFun
d1601 6
a1606 93
      subroutine SimpleExprWithC( quantity, a, b, c, mstr )
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), pointer :: A
      type (VectorValue_T), pointer :: B
      real(rv) :: C                     ! constant "c" in manipulation
      character (len=128) :: MSTR
        ! Evaluate mstr assuming it's of the form
        ! expr1 [op1 expr2]
        ! where each expr is either a primitive 'x' (one of {a, b, or c})
        ! or else ['('] 'x op y' [')']
        ! where 'op' is one of {+, -, *, /,<,>}

        ! Method:
        ! Progressively collapse all the '(..)' pairs into their values
        ! (stored in primitives database)
        ! until only primitives remain
        ! Then evaluate the primitives
        !
        ! Limitations:
        ! Does not check for unmatched parens or other illegal syntax
        integer, parameter :: MAXSTRLISTLENGTH = 128
        integer, parameter :: MAXNESTINGS=64 ! Max number of '(..)' pairs
        character(len=MAXSTRLISTLENGTH) :: collapsedstr
        integer :: level
        integer :: np ! number of primitives
        character(len=MAXSTRLISTLENGTH) :: part1
        character(len=MAXSTRLISTLENGTH) :: part2
        character(len=MAXSTRLISTLENGTH) :: part3
        character(len=4) :: vchar
        logical, parameter :: DEEBUG = .false.
        ! Executable
        if ( DeeBUG ) print *, 'mstr: ', trim(mstr)
        nullify(primitives)
        np = 0
        
        ! We're unable to ensure operator precedence
        ! so we'll attempt to identify multiplications and divisions
        ! and surround such subexpressions with extra parentheses
        
        call reorderPrecedence(mstr, collapsedstr)
        if ( DeeBUG ) then
          print *, 'incoming ', mstr
          print *, 'after reordering precedence ', collapsedstr
        endif
        mstr = collapsedstr
        
        ! 1st--make sure spaces surround each operator
        ! (It takes two steps for each to avoid threat of infinite loop)
        call ReplaceSubString( mstr, collapsedstr, '+', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '+', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( mstr, collapsedstr, '*', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '*', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( mstr, collapsedstr, '-', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '-', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( mstr, collapsedstr, '/', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '/', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( mstr, collapsedstr, '<', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '<', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( mstr, collapsedstr, '>', ' & ', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, mstr, '&', '>', &
          & which='all', no_trim=.false. )

        collapsedstr = lowerCase(mstr)
        ! Collapse every sub-formula nested within parentheses
        do level =1, MAXNESTINGS ! To prevent endlessly looping if ill-formed
          if ( index( collapsedstr, '(' ) < 1 ) exit
          call SplitNest ( collapsedstr, part1, part2, part3 )
          ! Now evaluate the part2
          if ( DeeBUG ) then
            print *, 'part1 ', part1
            print *, 'part2 ', part2
            print *, 'part3 ', part3
          endif
          if ( part2 == ' ' ) then
            ! This should never happen with well-formed formulas
            collapsedstr = part1
            cycle
d1608 69
a1676 34
            np = evaluatePrimitive( trim(part2), &
              & a, b, c )
            write(vChar, '(i4)') np
          endif
          ! And substitute its value for the spaces it occupied
          if (  part1 == ' ' ) then
            collapsedstr = trim(vChar) // ' ' // part3
          elseif ( part3 == ' ' ) then
            collapsedstr = trim(part1) // ' ' // vChar
          else
            collapsedstr = trim(part1) // ' ' // trim(vChar) // &
              & ' ' // part3
          endif
          if ( DeeBUG ) then
            print *, 'collapsedstr ', collapsedstr
          endif
        enddo
        ! Presumably we have collapsed all the nested '(..)' pairs by now
        np = evaluatePrimitive( trim(collapsedstr), &
              & a, b, c )
        if ( DeeBUG ) then
          print *, 'np ', np
          print *, 'size(database) ', size(primitives)
        endif
        quantity%values = 0.
        if ( np < 1 .or. np > size(primitives) ) then
          print *, 'np ', np
          print *, 'size(database) ', size(primitives)
          call Announce_Error ( key, no_error_code, &
            & 'Illegal index for primitives array' )
          return
        endif
        if ( .not. associated ( quantity%mask ) ) then
          quantity%values = primitives(np)%values
d1678 1
a1678 3
          where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
            quantity%values = primitives(np)%values
          end where
d1680 4
a1683 101
        if ( DeeBUG ) call dumpPrimitives(primitives)
        call destroyPrimitives(primitives)
      end subroutine SimpleExprWithC

      subroutine reorderPrecedence(mstr, collapsedstr)
        ! Identify all the terms where each term are separated by
        ! the lower-precedence operators {+, -,<,>}
        ! If any terms contain higher-precedence operators {*, /}
        ! then surround them by parentheses
        character(len=*), intent(in)  :: mstr
        character(len=*), intent(out) :: collapsedstr
        ! Internal variables
        logical, parameter :: COUNTEMPTY = .true.
        integer :: i
        integer :: n
        character(len=(len(mstr)+3)) :: element
        character(len=(len(mstr)+3)) :: temp
        ! Executable
        ! 1st -- replace each '-' with '+-'
        ! (Don't worry--we'll undo this before returning)
        ! (It takes two steps for each to avoid threat of infinite loop)
        call ReplaceSubString( mstr, collapsedstr, '-', '&', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, temp, '&', '+-', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( temp, collapsedstr, '<', '&', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, temp, '&', '+<', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( temp, collapsedstr, '>', '&', &
          & which='all', no_trim=.true. )
        call ReplaceSubString( collapsedstr, temp, '&', '+>', &
          & which='all', no_trim=.false. )
        ! Now loop over terms
        n = NumStringElements( temp, COUNTEMPTY, inseparator='+' )
        if ( n < 1 ) then
          call ReplaceSubString( temp, collapsedstr, '+-', '-', &
            & which='all', no_trim=.false. )
          call ReplaceSubString( collapsedstr, temp, '+<', '<', &
            & which='all', no_trim=.false. )
          call ReplaceSubString( temp, collapsedstr, '+>', '>', &
            & which='all', no_trim=.false. )
          return
        endif
        collapsedstr = ' '
        do i=1, n
          call GetStringElement ( temp, element, i, countEmpty, inseparator='+' )
          ! Surround term with parentheses if it's a product or quotient
          ! but not if it's not simple
          if ( ( index(element, '*') > 0 .or. index(element, '/') > 0 ) .and. &
            & index(element, ')')  < 1 ) then
            element = '(' // trim(element) // ')'
          endif
          collapsedstr = catLists( collapsedstr, element, inseparator='+' )
        enddo
        
        ! Now undo change by reverting all '+-'
        ! (including any that may have been split by parentheses
        call ReplaceSubString( collapsedstr, temp, '+-', '-', &
          & which='all', no_trim=.false. )
        call ReplaceSubString( temp, collapsedstr, '+(-', '-(', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( collapsedstr, temp, '+<', '<', &
          & which='all', no_trim=.false. )
        call ReplaceSubString( temp, collapsedstr, '+(<', '<(', &
          & which='all', no_trim=.false. )

        call ReplaceSubString( collapsedstr, temp, '+>', '>', &
          & which='all', no_trim=.false. )
        call ReplaceSubString( temp, collapsedstr, '+(>', '>(', &
          & which='all', no_trim=.false. )
      end subroutine reorderPrecedence

      subroutine destroyPrimitives(primitives)
        ! deallocate all the arrays we created
        type(arrayTemp_T), dimension(:), pointer :: primitives
        integer :: i
        if ( .not. associated(primitives) ) return
        if ( size(primitives) < 1 ) return
        do i=1, size(primitives)
          call deallocate_test( primitives(i)%values, &
            & 'values', ModuleName // '/destroyPrimitives' )
        enddo
      end subroutine destroyPrimitives

      subroutine dumpAPrimitive(primitive)
        ! dump all the values in the array
        type(arrayTemp_T), intent(in) :: primitive
        if ( .not. associated(primitive%values) ) then
          call output( 'values not associated ', advance='yes' )
          return
        endif
        if ( size(primitive%values) < 1 ) then
          call output( 'values array is of 0 size ', advance='yes' )
          return
        endif
        call dump( primitive%values, 'values' )
      end subroutine dumpAPrimitive
d1685 9
a1693 76
      subroutine dumpPrimitives(primitives)
        ! dump all the arrays we created
        type(arrayTemp_T), dimension(:), pointer :: primitives
        integer :: i
        if ( .not. associated(primitives) ) then
          call output( 'database not associated ', advance='yes' )
          return
        endif
        if ( size(primitives) < 1 ) then
          call output( 'empty database ', advance='yes' )
          return
        endif
        call output( 'size of primitives database: ', advance='no' )
        call output( size(primitives), advance='yes' )
        do i=1, size(primitives)
          call output ( ' index of primitive: ', advance='no' )
          call output ( i, advance='yes' )
          call dumpAPrimitive( primitives(i) )
        enddo
      end subroutine dumpPrimitives

      integer function AddPrimitiveToDatabase( DATABASE, ITEM )

        ! This function adds a primitive data type to a database of said types,
        ! creating a new database if it doesn't exist.  The result value is
        ! the size -- where it was put.

        ! Dummy arguments
        type (arrayTemp_T), dimension(:), pointer :: DATABASE
        type (arrayTemp_T), intent(in) :: ITEM

        ! Local variables
        type (arrayTemp_T), dimension(:), pointer :: tempDatabase
        !This include causes real trouble if you are compiling in a different
        !directory.
        include "addItemToDatabase.f9h" 

        AddPrimitiveToDatabase = newSize
      end function AddPrimitiveToDatabase

      function evaluatePrimitive( str, a, b, c ) result(value)
        ! Evaluate an expression composed entirely of
        ! (0) constants ('c')
        ! (1) primitives (e.g., '2')
        ! (2) unary operators ('-')
        ! (3) binary operators {'+', '-', '*', '/','<','>'}
        ! Dummy args
        character(len=*)                :: str
        integer                         :: value
        type (VectorValue_T), pointer   :: A
        type (VectorValue_T), pointer   :: B
        real(rv) :: C                     ! constant "c" in manipulation
        ! Internal variables
        logical                         :: done
        integer                         :: elem
        logical                         :: hit
        character(len=3)                :: lastOp ! {'+', '-', '*', '/'}
        integer                         :: n
        logical                         :: negating
        integer                         :: partID
        integer, dimension(2)           :: shp
        character(len=32)               :: variable
        type (arrayTemp_T)              :: newone
        type (arrayTemp_T)              :: part
        logical, parameter              :: DEEBUG = .false.
        ! Executable
        shp = shape(a%values)
        call allocate_test( newone%values, shp(1), shp(2), &
          & 'newone', ModuleName // '/evaluatePrimitive' )
        call allocate_test( part%values, shp(1), shp(2), &
          & 'part', ModuleName // '/evaluatePrimitive' )

        if ( deeBug ) then
          print *, 'Complete dump of database'
          call dumpPrimitives(primitives)
        endif
d1695 23
a1717 45
        done = .false.
        negating = .false.
        elem = 0
        lastOp = 'nul' ! 'or'
        newone%values = 0.
        n = NumStringElements( trim(str), countEmpty=.false., &
          & inseparator=' ' )
          if ( DeeBUG ) then
            print *, n, ' str: ', trim(str)
          endif
        do
          ! go through the elements, re-evaluating every time we "hit" a primitive
          ! Otherwise revising our lastOp or negating status
          elem = elem + 1
          call GetStringElement ( trim(str), variable, elem, &
            & countEmpty=.false., inseparator=' ' )
          if ( DeeBUG ) then
            print *, elem, ' variable: ', trim(variable)
          endif
          select case( trim(variable) )
          case ('a')
            partID = -1
            part%values = a%values
            hit = .true.
          case ('b')
            partID = -2
            part%values = b%values
            hit = .true.
          case ('c')
            partID = -3
            part%values = c
            hit = .true.
          case ('+')
            lastOp = '+'
            hit = .false.
          case ('*')
            lastOp = '*'
            hit = .false.
          case ('/')
            lastOp = '/'
            hit = .false.
          case ('-') ! could be unary or binary; how do we tell?
            if ( hit ) then ! already have a primitive; looking for an op
              lastOp = '-'
              hit = .false.
d1719 60
a1778 115
              ! case ('not', '~')
              negating = .true.
              hit = .false.
            endif
          case ('<')
            lastOp = '<'
            hit = .false.
          case ('>')
            lastOp = '>'
            hit = .false.
          case default
            read( variable, * ) partID
            if ( partID < 1 ) then
              print *, 'partID: ', partID
              call Announce_Error ( key, no_error_code, 'partID too small' )
              return
            elseif( partID > size(primitives) ) then
              print *, 'partID: ', partID
              call Announce_Error ( key, no_error_code, 'partID too big' )
              return
            endif
            part%values = primitives(partID)%values
            hit = .true.
            if ( deeBug ) then
              print *, 'part"s values after ' // trim(lastOp) // trim(variable)
              call dumpAPrimitive(part)
              print *, 'based on'
              call dumpAPrimitive(primitives(partID))
            endif
          end select
          if ( hit ) then
            if ( negating ) part%values = -part%values
            select case(lastOp)
            case ('nul')
                newone%values = part%values
            case ('+')
                newone%values = newone%values + part%values
            case ('-')
                newone%values = newone%values - part%values
            case ('*')
                newone%values = newone%values * part%values
            case ('/')
              where ( part%values /= 0._rv )
                newone%values = newone%values / part%values
              end where
            case ('<')
                newone%values = min( newone%values, part%values )
            case ('>')
                newone%values = max( newone%values, part%values )
            case default
              ! How could this happen?
                call MLSMessage( MLSMSG_Error, ModuleName, &
                  & lastOp // ' not a legal binary op in evaluatePrimitive' )
            end select
            negating = .false.
            if ( deeBug ) then
              print *, 'newone"s values after ' // trim(lastOp) // trim(variable)
              call dumpAPrimitive(newone)
            endif
          endif
          if ( DeeBUG ) then
            print *, 'variable ', variable
            print *, 'partID ', partID
            print *, 'hit ', hit
            print *, 'negating ', negating
            print *, 'lastOp ', lastOp
          endif
          done = ( elem >= n )
          if ( done ) exit
        enddo
        value = AddPrimitiveToDatabase( primitives, newone )
!         call deallocate_test( newone%values, &
!           & 'newone', ModuleName // '/evaluatePrimitive' )
        call deallocate_test( part%values, &
          & 'part', ModuleName // '/evaluatePrimitive' )
        if ( .not. DEEBUG ) return
        print *, 'value ', value
        print *, 'newone"s values ' // trim(str)
        call dumpAPrimitive(newone)
        
        print *, 'values stored in db '
        call dumpAPrimitive(primitives(value))
      end function evaluatePrimitive

    ! ----------------------------------------- FillWithReflectorTemperature ---
    subroutine FillWithReflectorTemperature ( key, quantity, phiZero, termsNode )
      use Units, only: DEG2RAD
      integer, intent(in) :: KEY         ! Tree node for messages
      type (VectorValue_T), intent(inout) :: QUANTITY ! The quantity to fill
      real(r8), intent(in) :: PHIZERO   ! Offset term
      integer, intent(in) :: TERMSNODE

      ! Local variables
      integer :: I                      ! Loop counter
      integer, DIMENSION(2) :: UNITASARRAY ! Unit for value given
      real (r8), DIMENSION(2) :: VALUEASARRAY ! Value give

      ! Executable code
      if ( quantity%template%quantityType /= l_reflTemp ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Inappropriate quantity for reflector temperature fill' )

      ! Loop over fourier terms, coefficients are son i+2
      do i = 0, nsons ( termsNode ) - 2
        call expr_check ( subtree(i+2,termsNode), unitAsArray, valueAsArray, &
          & (/PHYQ_Temperature/), unitsError )
        if ( unitsError ) call Announce_error ( termsNode, wrongUnits, &
          & extraInfo=(/unitAsArray(1), PHYQ_Temperature/) )
        ! Add in this coefficient
        if ( i == 0 ) then
          quantity%values = valueAsArray(1)
        else if ( mod ( i, 2 ) == 1 ) then
          ! A sine term
          quantity%values(1,:) = quantity%values(1,:) + 2 * valueAsArray(1) * &
            & cos ( Deg2Rad * ((i+1)/2) * ( quantity%template%phi(1,:) - phiZero ) )
d1780 2
a1781 3
          ! A cosine term
          quantity%values(1,:) = quantity%values(1,:) - 2 * valueAsArray(1) * &
            & sin ( Deg2Rad * ((i+1)/2) * ( quantity%template%phi(1,:) - phiZero ) )
a1782 1
      end do
d1784 96
a1879 1
    end subroutine FillWithReflectorTemperature
d1881 15
a1895 70
    ! ----------------------------------------- FillQtyWithReichlerWMOTP -------------
    subroutine FillQtyWithReichlerWMOTP ( tpPres, temperature )
      use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
      use dump_0, only: dump
      use MLSFillValues, only: IsFillValue, RemoveFillValues
      use output_m, only: output
      
      use wmoTropopause, only: ExtraTropics, twmo
      ! Implements the algorithm published in GRL
      ! Loosely called the "Reichler" algorithm
      ! Ideas the same as in FillQtyWithWMOTropopause
      ! But implemented differently
      ! 
      type (VectorValue_T), intent(inout) :: TPPRES ! Result
      type (VectorValue_T), intent(in) :: TEMPERATURE
      ! Local variables
      integer :: instance
      integer :: invert
      real :: MISSINGVALUE
      integer :: nlev
      integer :: nvalid
      real, dimension( size(temperature%values, 1) ) :: p ! Pa
      real, parameter :: pliml = 65.*100 ! in Pa
      real, parameter :: plimlex = 65.*100 ! in Pa
      real, parameter :: plimu = 550.*100 ! in Pa
      real, dimension( size(temperature%values, 1) ) :: t
      real :: trp
      real, dimension(:), pointer :: xyTemp, xyPress
      logical :: alreadyDumped
      logical, parameter :: DEEBUG = .false.
      ! Executable
      nullify( xyTemp, xyPress )
      nlev = size(temperature%values, 1)
      MISSINGVALUE = REAL( DEFAULTUNDEFINEDVALUE )
      ! Loop over the instances
      tpPres%values = MISSINGVALUE
      if ( DEEBUG ) then
      call output( 'num levels', advance='no' )
      call output( nlev, advance='yes' )
      call output( 'num instances', advance='no' )
      call output( temperature%template%noInstances, advance='yes' )
      call output( 'shape of tpPress values', advance='no' )
      call output( shape(tpPres%values), advance='yes' )
      endif
      if ( -temperature%template%surfs(1,1) .gt.&
        & -temperature%template%surfs(2,1) ) then
        invert=1
        ! p = refGPH%values(nlev:1:-1,instance)*100.  ! hPa > Pa
        p = 10.0**(-temperature%template%surfs(nlev:1:-1,1))
        p = p * 100.  ! hPa > Pa
      else
        invert=0
        ! p=refGPH%values(:,instance)*100.         ! hPa > Pa
        p = 10.0**(-temperature%template%surfs(:,1)) 
        p = p * 100.  ! hPa > Pa
      end if
      instanceLoop: do instance = 1, temperature%template%noInstances
      alreadyDumped = .false.
        ! Check the temperatures are in a sensible range
        if ( any ( &
          & temperature%values(:,instance) < 10.0 .or. &
          & temperature%values(:,instance) > 1000.0 ) ) then
          call output('invalid temperatures in this instance', advance='yes' )
          cycle instanceLoop
        end if
        ! check vertical orientation of data
        ! (twmo expects ordered from top downward)
        ! but surfs are -1.0 * log10(press)
        if ( invert == 1 ) then
          t = temperature%values(nlev:1:-1,instance)
d1897 31
a1927 159
          t = temperature%values(:,instance)
        end if
        where ( t < 0. .or. t > 100000. )
          t = MissingValue
        end where
        nvalid = count( .not. isFillValue(t) )
        if ( nvalid < 2 ) then
          if ( DEEBUG ) then
          call output('not enough valid temperatures in this instance', advance='yes' )
          call output(count( .not. isFillValue(t) ), advance='yes' )
          call output(count( isFillValue(t) ), advance='yes' )
          call dump(temperature%values(:,instance), 'temperature%values')
          endif
          cycle
        endif
        call Allocate_test (xyTemp, nvalid, 'xyTemp', ModuleName )
        call Allocate_test (xyPress, nvalid, 'xyPress', ModuleName )
        call RemoveFillValues( t, MISSINGVALUE, xyTemp, &
          & p, xyPress )
        call twmo(nvalid, xyTemp, xyPress, plimu, pliml, trp)
        if ( .not. alreadyDumped .and. DEEBUG ) then
           alreadyDumped = .true.
           call dump(p, 'p ')
           call dump(t, 't ')
           call dump(xyTemp, 'xyTemp')
           call dump(xyPress, 'xyPress')
           call output( 'plimu, pliml, trp', advance='no' )
           call output( (/ plimu, pliml, trp /), advance='yes' )
        endif
        ! Don't let tropopause sink too low in "extra tropics"
        if ( trp < plimlex .and. &
          & extraTropics(temperature%template%geodLat(1, instance) ) ) then
          if ( DEEBUG ) then
          call output( 'trp too low in extra tropics', advance='no' )
          call output( (/ plimlex, trp /), advance='yes' )
          endif
          trp = MISSINGVALUE
        endif
        if ( trp > 0. .and. trp < 100000000. ) tpPres%values(1, instance) = trp/100
        call Deallocate_test ( xyTemp, 'xyTemp', ModuleName )
        call Deallocate_test ( xyPress, 'xyPress', ModuleName )
      end do instanceLoop
      if ( DEEBUG ) call dump( tpPres%values, 'tpPres%values' )
    end subroutine FillQtyWithReichlerWMOTP

    ! ----------------------------------------- FillQtyWithWMOTropopause ------
    subroutine FillQtyWithWMOTropopause ( tpPres, temperature, refGPH, grid )
      use Geometry, only: GEODTOGEOCLAT
      use Hydrostatic_M, only: HYDROSTATIC
      use VGridsDatabase, only: VGRID_T

      type (VectorValue_T), intent(inout) :: TPPRES ! Result
      type (VectorValue_T), intent(in) :: TEMPERATURE
      type (VectorValue_T), intent(in) :: REFGPH
      type (VGrid_T), intent(in) :: GRID

      ! Local variables
      real(rv), dimension(grid%noSurfs) :: TFINE ! Temperature on fine grid
      real(rv), dimension(grid%noSurfs) :: HFINE ! Temperature on fine grid
      real(rv), dimension(grid%noSurfs) :: DTDH ! d(tFine)/d(hFine)
      real(rv), dimension(grid%noSurfs) :: DUMMYT ! Extra arg. for interpolateValues
      integer :: I                      ! Instance counter
      integer :: S500                   ! 500mb surface?
      integer :: LOWCANDIDATE           ! Possbile tb but below 500hPa
      integer :: S                      ! Surface counter
      integer :: S0                     ! Surface to start looking from
      integer :: DS                     ! No. surfs less than 2km above s
      logical :: VALIDTP                ! Flag

      ! Now the rules for the WMO tropopause are:

      ! 1. The "first tropopause" is defined as the lowest height at which the
      ! lapse rate decreases to 2K per kilometer or less, provided also that
      ! the average lapse rate between this height and all higher altitudes
      ! within 2 kilometers does not exceed 2K per kilometer.

      ! 2. If, above the first tropopause, the average lapse rate between any
      ! height and all higher altitudes within a 1-kilometer intend exceeds 3K
      ! per kilometer, then another tropopause is defined by the same criteria
      ! as under 1 above. This second tropopause may be within or above the
      ! 1-kilometer layer.

      ! There are also two qualifying remarks attached to the selection
      ! criteria. They are as follows:

      ! 1. A height below the 500-mb level is not designated as a tropopause
      ! unless the sounding reaches the 200-mb level and the height is the only
      ! height satisfying the above definitions.

      ! 2. When the second or higher tropopauses are being determined, the
      ! 1-kilometer interval with an average lapse rate of 3K per kilometer can
      ! occur at any height above the conventional tropopause and not only at a
      ! height more than 2 kilometers above the first tropopause.

      ! Stricly melding the WMO tropopause definition with our own
      ! 'linear interpolation between tie points' mantra is problematic.
      ! If we are strict we'd only ever give the one of our basis points as
      ! the solution.  So we're going to interpolate to a higher resolution
      ! using a spline which pop's out the derivatives too.

      ! Note here we assume that the quantities supplied are all valid
      ! (ie describe the right quantities, and all on the same horizontal
      ! grid).

      call MLSMessageCalls( 'push', constantName='FillQtyWithWMOTropopause' )
      ! Loop over the instances
      tpPres%values = 0.0
      instanceLoop: do i = 1, temperature%template%noInstances
        ! Check the temperatures are in a sensible range
        if ( any ( &
          & temperature%values(:,i) < 10.0 .or. &
          & temperature%values(:,i) > 1000.0 ) ) then
          cycle instanceLoop
        end if
        ! Perhaps think later about keeping track of the 'top'.
        ! Currently we're going to assert that we have data extending to
        ! pressures lower than 200mb.

        ! Interpolate temperature onto 'finer' pressure grid
        call InterpolateValues ( &
          & temperature%template%surfs(:,1), temperature%values(:,i), &
          & grid%surfs(:,1), tFine, method='Spline' )
        ! Now get the height for this.
        call Hydrostatic ( GeodToGeocLat ( temperature%template%geodLat(1,i) ), &
          & grid%surfs(:,1), tFine, grid%surfs(:,1), &
          & refGPH%template%surfs(1,1), refGPH%values(1,i), hFine )
        ! Note while much of the software thinks in meters, the hydrostatic
        ! routine works in km.
        ! Now do another spline 'interpolation' to get dTdH
        call InterpolateValues ( hFine, tFine, hFine, dummyT, &
          & dYbyDx=dtdh, method='Spline' )
        ! Negate dTdH to turn it into lapse rate
        dTdH = - dTdH

        ! Locate the 500mb surface
        call Hunt ( grid%surfs(:,1), -log10(500.0_r8), s500 )

        ! Find the 'first' tropopause.  We're not going to bother
        ! with the 'second'
        lowCandidate = 0
        validTP = .false.
        s0 = 1
        tpHunt: do
          ! Find first place where lapse rate less than 2K/km
          s = FindFirst ( dtdh(s0:) < 2.0 ) + s0 - 1
          ! If not found such a place give up looking
          if ( s == s0 - 1 ) exit tpHunt
          ! Find last surface within 2km of this one
          ds = FindFirst ( hFine(s:) > hFine(s) + 2.0 ) - 1
          ! If not got data 2km above s0 (FindFirst gave 0, so ds=-1), give up
          ! Also, if data on such coarse resolution that the next point above
          ! s0 is more than 2km away (FindFirst gave 1 so ds=0), also give up
          if ( ds <= 0 ) exit tpHunt
          ! Must have mean lapse rate less than 2K/km within 2km of s.
          validTp = sum ( dTdH ( s : s + ds - 1 ) / ds ) < 2.0
          ! If this is below 500mb, keep an eye on it and keep looking
          if ( s < s500 .and. validTP ) then
            validTP = .false.
            lowCandidate = s
a1928 10
          if ( validTP ) exit tpHunt
          ! Otherwise keep looking higher up
          s0 = s + 1
          if ( s0 > grid%noSurfs ) exit tpHunt
        end do tpHunt

        ! Now pick up the pieces of that complex logic
        if ( .not. validTP .and. lowCandidate > 0 ) then
          s = lowCandidate
          validTP = .true.
d1931 4
a1934 12
        ! If we never found one, leave 0 in the result and move onto
        ! the next instance
        if ( .not. validTP ) cycle instanceLoop

        ! OK, our tropopause is below surface s
        ! Now we do some interpolation to get
        ! the value we really want.
        if ( s > 1 ) then
          tpPres%values(1,i) = 10.0 ** ( -( &
            & grid%surfs(s-1,1) + &
            & ( grid%surfs(s,1) - grid%surfs(s-1,1) ) * ( dTdH(s-1) - 2.0 ) / &
            & ( dTdH(s-1) - dTdH(s) ) ) )
d1936 5
a1940 1
          tpPres%values(1,i) = 10.0 ** ( - grid%surfs(s,1) )
a1941 58
      end do instanceLoop
      call MLSMessageCalls( 'pop' )
    end subroutine FillQtyWithWMOTropopause

    ! -------------------------------------------- FillWithBinResults -----
    subroutine FillWithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
      & channel, method, additional, excludeBelowBottom, centerVertically )
      ! This fills a coherent quantity with the max/min binned value of
      ! a typically incoherent one.  The bins are centered horizontally
      ! on the profiles in quantity, but vertically the bins run between one
      ! surface and the next one up.
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY
      type (VectorValue_T), pointer :: PTANQUANTITY
      integer, intent(in) :: CHANNEL
      integer, intent(in) :: METHOD
      logical, intent(in) :: ADDITIONAL
      logical, intent(in) :: EXCLUDEBELOWBOTTOM
      logical, intent(in) :: CENTERVERTICALLY

      ! Local variables
      real(r8), dimension(:,:), pointer :: SOURCEHEIGHTS ! might be ptan.
      real(r8), dimension(:), pointer :: PHIBOUNDARIES
      real(r8) :: V                     ! A value
      integer, dimension(:,:), pointer :: SURFS ! Surface mapping source->quantity
      integer, dimension(:,:), pointer :: INSTS ! Instance mapping source->quantity
      integer :: QS, QI, SS, SI                   ! Loop counters
      integer :: MYCHANNEL              ! Channel or 1

      ! Executable code
      call MLSMessageCalls( 'push', constantName='FillWithBinResults' )

      ! Check the output quantity
      if ( .not. ValidateVectorQuantity ( quantity, &
        & coherent=.true., stacked=.true. ) ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Illegal quantity for bin min/max/total fill' )

      ! Also should have the condition:
      !  quantityType = (/ sourceQuantity%template%quantityType /)
      ! However, the code does not yet really support the ability to do that.

      ! Work out source vertical coordinate
      if ( associated ( ptanQuantity ) .and. sourceQuantity%template%minorFrame ) then
        nullify ( sourceHeights )
        call Allocate_test ( sourceHeights, sourceQuantity%template%nosurfs, &
          & sourceQuantity%template%noinstances, 'sourceHeights', ModuleName )
        sourceHeights = ptanQuantity%values
        if ( quantity%template%verticalCoordinate /= l_zeta ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Vertical coordinate in quantity to fill is not zeta' )
      else
        sourceHeights => sourceQuantity%template%surfs
        if ( sourceQuantity%template%verticalCoordinate /= quantity%template%verticalCoordinate ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Vertical coordinates in binned fill do not match' )
      end if
d1943 4
a1946 36
      ! Setup index arrays
      nullify ( surfs, insts )
      call Allocate_test ( surfs, sourceQuantity%template%nosurfs, &
        & sourceQuantity%template%noinstances, 'surfs', ModuleName )
      call Allocate_test ( insts, sourceQuantity%template%nosurfs, &
        & sourceQuantity%template%noinstances, 'insts', ModuleName )

      ! Work out the vertical mapping, a function of instance for
      ! incoherent quantities
      if ( sourceQuantity%template%coherent ) then
        call Hunt ( quantity%template%surfs(:,1), sourceHeights(:,1), surfs(:,1), &
          & allowTopValue=.true., allowBelowValue=excludeBelowBottom, nearest=centerVertically )
        surfs = spread ( surfs(:,1), 2, sourceQuantity%template%noInstances )
      else
        do si = 1, sourceQuantity%template%noInstances
          call Hunt ( quantity%template%surfs(:,1), sourceHeights(:,si), surfs(:,si), &
            & allowTopValue=.true., allowBelowValue=excludeBelowBottom, nearest=centerVertically )
        end do
      end if

!      call dump ( surfs, 'surfs' )

      ! Work out the horizontal mapping, a function of height for unstacked quantities.
      ! Bin to the center of the profiles rather than the edges.
      if ( quantity%template%noInstances > 1 ) then
        ! Setup and work out the phiBoundaries
        nullify ( phiBoundaries )
        call Allocate_test ( phiBoundaries, quantity%template%noInstances-1, &
          & 'phiBoundaries', ModuleName )
        phiBoundaries = 0.5 * ( &
          & quantity%template%phi(1,1:quantity%template%noInstances-1) + &
          & quantity%template%phi(1,2:quantity%template%noInstances) )
        if ( sourceQuantity%template%stacked ) then
          call Hunt ( phiBoundaries, sourceQuantity%template%phi(1,:), &
            & insts(1,:), allowTopValue=.true., allowBelowValue=.true. )
          insts = spread ( surfs(1,:), 1, sourceQuantity%template%noSurfs ) + 1
d1948 1
a1948 5
          do ss = 1, sourceQuantity%template%noSurfs
            call Hunt ( phiBoundaries, sourceQuantity%template%phi(ss,:), &
              & insts(ss,:), allowTopValue=.true., allowBelowValue=.true. )
          end do
          insts = insts + 1
a1949 4
        call Deallocate_test ( phiBoundaries, 'phiBoundaries', ModuleName )
      else
        insts = 1
      end if
d1951 8
a1958 324
!      call dump ( insts, 'insts' )

      ! Modify the surfs index to account for the channel, so now it's more
      ! of a 'values' index
      if ( sourceQuantity%template%frequencyCoordinate /= l_none .and. &
        & channel == 0 ) then
        call Announce_Error ( key, no_error_code, &
          & 'Must supply channel for this bin max/min fill' )
        return
      end if
      myChannel = channel
      if ( channel == 0 ) myChannel = 1

      ! Now loop over the output quantity points and work out the information
      do qi = 1, quantity%template%noInstances
        do qs = 1, quantity%template%noSurfs
          if ( count ( surfs == qs .and. insts == qi ) > 0 ) then
            select case ( method )
            case  ( l_binMax )
              ! Compute the maximum value in the bin
              v = maxval ( pack ( sourceQuantity%values ( &
                & myChannel : sourceQuantity%template%instanceLen : &
                &   sourceQuantity%template%noChans, : ), &
                & surfs == qs .and. insts == qi ) )
              if ( additional ) then
                quantity%values(qs,qi) = max ( quantity%values(qs,qi), v )
              else
                quantity%values(qs,qi) = v
              end if
            case ( l_binMean )
              ! Compute the average in the bin, be careful about dividing by zero
              v = sum ( pack ( sourceQuantity%values ( &
                & myChannel : sourceQuantity%template%instanceLen : &
                &   sourceQuantity%template%noChans, : ), &
                & surfs == qs .and. insts == qi ) ) / &
                & max ( count ( surfs == qs .and. insts == qi ), 1 )
              if ( additional ) then
                quantity%values(qs,qi) = 0.5 * ( quantity%values(qs,qi) + v )
              else
                quantity%values(qs,qi) = v
              end if
            case ( l_binMin )
              ! Compute the minimum value in the bin
              v = minval ( pack ( sourceQuantity%values ( &
                & myChannel : sourceQuantity%template%instanceLen : &
                &   sourceQuantity%template%noChans, : ), &
                & surfs == qs .and. insts == qi ) )
              if ( additional ) then
                quantity%values(qs,qi) = min ( quantity%values(qs,qi), v )
              else
                quantity%values(qs,qi) = v
              end if
            case ( l_binTotal )
              ! Compute the total in the bin
              v = sum ( pack ( sourceQuantity%values ( &
                & myChannel : sourceQuantity%template%instanceLen : &
                &   sourceQuantity%template%noChans, : ), &
                & surfs == qs .and. insts == qi ) )
              if ( additional ) then
                quantity%values(qs,qi) = quantity%values(qs,qi) + v
              else
                quantity%values(qs,qi) = v
              end if
            end select
          else
            quantity%values(qs,qi) = 0.0
          end if
        end do
      end do

      ! Now tidy up
      call Deallocate_test ( surfs, 'surfs', ModuleName )
      call Deallocate_test ( insts, 'insts', ModuleName )
      if ( associated ( ptanQuantity ) .and. sourceQuantity%template%minorFrame ) &
        & call Deallocate_test ( sourceHeights, 'sourceHeights', ModuleName )
      call MLSMessageCalls( 'pop' )
    end subroutine FillWithBinResults

    ! --------------------------------------------- FillWithBoxcarAvergage  ----
    subroutine FillWithBoxcarFunction ( key, quantity, sourceQuantity, width, method )
      integer, intent(in) :: KEY        ! Key for tree node
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in), target :: SOURCEQUANTITY
      integer, intent(in) :: WIDTH
      integer, intent(in) :: METHOD     ! L_MEAN, L_MAX, L_MIN
      ! Local variables
      integer :: I, I1, I2              ! Instance indices
      integer :: HALFWIDTH
      real(r8), dimension(:,:), pointer :: OLDVALUES

      ! Executable code
      if ( quantity%template%name /= sourceQuantity%template%name ) then
        call Announce_Error ( key, no_error_code, 'Quantity and source quantity do not match' )
        return
      end if
      if ( width <= 1 .or. mod ( width, 2 ) == 0 ) then
        call Announce_Error ( key, no_error_code, 'width must be greater than 1 and odd' )
        return
      end if

      if ( associated ( quantity%values, sourceQuantity%values ) ) then
        nullify ( oldValues )
        call Allocate_test ( oldValues, quantity%template%instanceLen, quantity%template%noInstances, &
          & 'oldValues', ModuleName )
        oldValues = sourceQuantity%values
      else
        oldValues => sourceQuantity%values
      end if

      halfWidth = width/2
      select case ( method )
      case ( l_mean )
        do i = 1, quantity%template%noInstances
          i1 = max ( i - halfWidth, 1 )
          i2 = min ( i + halfWidth, quantity%template%noInstances )
          quantity%values(:,i) = sum ( oldValues(:,i1:i2), dim=2 ) / (i2-i1+1)
        end do
      case ( l_min )
        do i = 1, quantity%template%noInstances
          i1 = max ( i - halfWidth, 1 )
          i2 = min ( i + halfWidth, quantity%template%noInstances )
          quantity%values(:,i) = minval ( oldValues(:,i1:i2), dim=2 )
        end do
      case ( l_max )
        do i = 1, quantity%template%noInstances
          i1 = max ( i - halfWidth, 1 )
          i2 = min ( i + halfWidth, quantity%template%noInstances )
          quantity%values(:,i) = maxval ( oldValues(:,i1:i2), dim=2 )
        end do
      end select

      if ( associated ( quantity%values, sourceQuantity%values ) ) then
        call Deallocate_test ( oldValues, 'oldValues', ModuleName )
      end if

    end subroutine FillWithBoxcarFunction

    ! -------------------------------------------- FillStatusQuantity --------
    subroutine FillStatusQuantity ( key, quantity, sourceQuantity, statusValue, &
      & minValue, maxValue, heightNode, additional )
      integer, intent(in) :: KEY        ! Tree node
      type ( VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type ( VectorValue_T), intent(in) :: SOURCEQUANTITY ! Chisq like quantity on which it's based
      integer, intent(in) :: STATUSVALUE
      real(r8), intent(in) :: MINVALUE     ! A scale factor
      real(r8), intent(in) :: MAXVALUE     ! A scale factor
      integer, intent(in) :: HEIGHTNODE ! What heights
      logical, intent(in) :: ADDITIONAL ! Is this an additional flag or a fresh start?
      ! Local variables
      integer, dimension(2) :: UNITASARRAY ! From expr
      real(r8), dimension(2) :: VALUEASARRAY ! From expr
      real(r8) :: HEIGHT                ! The height to consider
      integer :: SURFACE                ! Surface index
      ! Executable code
      call MLSMessageCalls( 'push', constantName='FillStatusQuantity' )
      ! Do some sanity checking
      if ( quantity%template%quantityType /= l_status ) call Announce_error ( key, no_error_code, &
        & 'Quality quantity must be quality' )
      if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) ) call Announce_error ( &
        & key, no_error_code, 'quantity and sourceQuantity do not have matching hGrids' )

      ! Work out the height
      if ( heightNode /= 0 ) then
        if ( nsons ( heightNode ) /= 2 ) call Announce_Error ( key, no_error_code, &
          & 'Only one height can be supplied for status fill' )
        if ( sourceQuantity%template%verticalCoordinate /= l_zeta ) &
          & call Announce_Error ( key, no_error_code, 'Bad vertical coordinate for sourceQuantity' )
        call expr_check ( subtree(2,heightNode) , unitAsArray, valueAsArray, &
          & (/PHYQ_Pressure/), unitsError )
        if ( unitsError ) call Announce_error ( heightNode, wrongUnits, &
          & extraInfo=(/unitAsArray(1), PHYQ_Pressure/) )
        height = - log10 ( valueAsArray(1) )
        call Hunt ( sourceQuantity%template%surfs(:,1), height, surface, nearest=.true. )
      else
        surface = 1
      end if
      if ( .not. additional ) quantity%values = 0.0_r8
        ! quantity%values = iand ( nint ( quantity%values ), not ( statusValue ) )
      where ( sourceQuantity%values(surface,:) > maxValue .or. sourceQuantity%values(surface,:) < minValue )
        quantity%values(1,:) = ior ( nint ( quantity%values(1,:) ), statusValue )
      end where
      call MLSMessageCalls( 'pop' )
    end subroutine FillStatusQuantity

    ! -------------------------------------------- FillQualityFromChisq --------
    subroutine FillQualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )
      integer, intent(in) :: KEY        ! Tree node
      type ( VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type ( VectorValue_T), intent(in) :: SOURCEQUANTITY ! Chisq like quantity on which it's based
      real(r8), intent(in) :: SCALE     ! A scale factor
      integer, intent(in) :: HEIGHTNODE ! What heights
      ! Local variables
      integer, dimension(2) :: UNITASARRAY ! From expr
      real(r8), dimension(2) :: VALUEASARRAY ! From expr
      real(r8) :: HEIGHT                ! The height to consider
      integer :: SURFACE                ! Surface index
      ! Executable code
      call MLSMessageCalls( 'push', constantName='FillQualityFromChisq' )
      ! Do some sanity checking
      if ( quantity%template%quantityType /= l_quality ) call Announce_error ( key, no_error_code, &
        & 'Quality quantity must be quality' )
      if ( sourceQuantity%template%quantityType /= l_chisqBinned ) call Announce_error ( &
        & key, no_error_code, 'sourceQuantity must be of type chisqBinned' )
      if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) ) call Announce_error ( &
        & key, no_error_code, 'quantity and sourceQuantity do not have matching hGrids' )

      ! Work out the height
      if ( heightNode /= 0 ) then
        if ( nsons ( heightNode ) /= 2 ) call Announce_Error ( key, no_error_code, &
          & 'Only one height can be supplied for quality fill' )
        call expr_check ( subtree(2,heightNode) , unitAsArray, valueAsArray, &
          & (/PHYQ_Pressure/), unitsError )
        if ( unitsError ) call Announce_error ( heightNode, wrongUnits, &
          & extraInfo=(/unitAsArray(1), PHYQ_Pressure/) )
        height = - log10 ( valueAsArray(1) )
        call Hunt ( sourceQuantity%template%surfs(:,1), height, surface, nearest=.true. )
      else
        surface = 1
      end if
      quantity%values(1,:) = 0.0_r8
      where ( sourceQuantity%values(surface,:) /= 0.0_r8 )
        quantity%values(1,:) = scale / sourceQuantity%values(surface,:)
      end where
      call MLSMessageCalls( 'pop' )
    end subroutine FillQualityFromChisq

    ! -------------------------------------------- FillConvergenceFromChisq --------
    subroutine FillConvergenceFromChisq ( key, quantity, sourceQuantity, scale )
      integer, intent(in) :: KEY        ! Tree node
      type ( VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type ( VectorValue_T), intent(in) :: SOURCEQUANTITY ! dnwt_ChisqRatio quantity on which it's based
      real(r8), intent(in) :: SCALE     ! A scale factor
      ! Local variables
      ! Executable code
      ! Do some sanity checking
      if ( quantity%template%quantityType /= l_quality ) call Announce_error ( key, no_error_code, &
        & 'Convergence quantity must be quality' )
      if ( sourceQuantity%template%quantityType /= l_dnwt_chisqRatio ) call Announce_error ( &
        & key, no_error_code, 'sourceQuantity must be of type chisqRatio' )

      quantity%values(1,:) = scale * sourceQuantity%values(1,1)
    end subroutine FillConvergenceFromChisq

    ! ------------------------------------------ FillUsingLeastSquares -----
    subroutine FillUsingLeastSquares  ( key, Quantity, SourceQuantity, ptanQuantity, &
      & channel, method, scaleInstances, scaleRatio, scaleSurfs )
      ! This fills a coherent Quantity from a a typically incoherent
      ! SourceQuantity using a least-squares approximation to a first-order
      ! Taylor series.

      use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
      use HFTI_M, only: HFTI
      use MLSKinds, only: R8

      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY
      type (VectorValue_T), pointer :: PTANQUANTITY
      integer, intent(in) :: CHANNEL
      integer, intent(in) :: METHOD
      real(r8), intent(inout) :: ScaleInstances, ScaleRatio, ScaleSurfs

      ! Local variables
      real(r8), dimension(:,:), pointer :: INSTS ! Instance coordinates for source
      real(r8), dimension(:,:), pointer :: LSMatrix ! Least Squares problem matrix
      real(r8), dimension(:), pointer :: RHS
      real(r8), dimension(:,:), pointer :: SOURCEHEIGHTS ! might be ptan.
      real(r8), dimension(:,:), pointer :: SURFS ! Surface coordinates for source
      real(r8) :: W, WMAX               ! Weight if method == l_lsWeighted
      integer :: QS, QI, SS, SI         ! Loop counters
      integer :: KRANK                  ! Rank of least-squares solution
      integer :: MYCHANNEL              ! Channel or 1
      integer :: NRows
      integer :: NSourceQuant  ! Number of values in SourceQuantity

      ! Executable code

      ! Check the output quantity
      if ( .not. ValidateVectorQuantity ( quantity, &
        & coherent=.true., stacked=.true. ) ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Quantity for least-squares fill must be stacked and coherent' )

      ! Also should have the condition:
      !  quantityType = (/ sourceQuantity%template%quantityType /)
      ! However, the code does not yet really support the ability to do that.

      ! Work out source vertical coordinate
      if ( associated ( ptanQuantity ) .and. sourceQuantity%template%minorFrame ) then
        nullify ( sourceHeights )
        call Allocate_test ( sourceHeights, sourceQuantity%template%nosurfs, &
          & sourceQuantity%template%noinstances, 'sourceHeights', ModuleName )
        sourceHeights = ptanQuantity%values
        if ( quantity%template%verticalCoordinate /= l_zeta ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Vertical coordinate in quantity to fill is not zeta' )
      else
        sourceHeights => sourceQuantity%template%surfs
        if ( sourceQuantity%template%verticalCoordinate /= quantity%template%verticalCoordinate ) &
          & call Announce_Error ( key, no_error_code, &
          & 'Vertical coordinates in least-squares fill do not match' )
      end if

      ! Get the channel number
      if ( sourceQuantity%template%frequencyCoordinate /= l_none .and. &
        & channel == 0 ) then
        call Announce_Error ( key, no_error_code, &
          & 'Must supply channel for this least-squares fill' )
        return
      end if
      myChannel = max(channel,1)

      ! Setup coordinate arrays
      nullify ( surfs, insts )
      call Allocate_test ( surfs, sourceQuantity%template%nosurfs, &
        & sourceQuantity%template%noinstances, 'surfs', ModuleName )
      call Allocate_test ( insts, sourceQuantity%template%nosurfs, &
        & sourceQuantity%template%noinstances, 'insts', ModuleName )

      ! Get the vertical coordinates, a function of instance for
      ! incoherent quantities
      do ss = 1, sourceQuantity%template%noSurfs
        if ( sourceQuantity%template%coherent ) then
          surfs(ss,:) = sourceHeights(ss,1)
d1960 1
a1960 1
          surfs(ss,:) = sourceHeights(ss,:)
a1961 1
      end do
d1963 3
a1965 8
!      call dump ( surfs, 'surfs' )

      ! Get the horizontal coordinates, a function of height for unstacked quantities.
      do si = 1, sourceQuantity%template%noInstances
        if ( sourceQuantity%template%coherent ) then
          insts(:,si) = sourceQuantity%template%phi(1,si)
        else
          insts(:,si) = sourceQuantity%template%phi(:,si)
a1966 1
      end do
d1968 23
a1990 61
!      call dump ( insts, 'insts' )

      ! Allocate the arrays
      nullify ( lsMatrix, RHS )
      if ( sourceQuantity%template%regular ) then
        nSourceQuant = sourceQuantity%template%noInstances * &
          &            sourceQuantity%template%noSurfs
      else
        nSourceQuant = sourceQuantity%template%noInstances * &
          &                sourceQuantity%template%instanceLen
      end if
      call allocate_test ( lsMatrix, nSourceQuant, 4, 'LSMatrix', moduleName )
      call allocate_test ( RHS, nSourceQuant, 'RHS', moduleName )

      if ( method == l_lsWeighted ) then
        if ( scaleInstances < 0.0 ) scaleInstances = &
          ( quantity%template%phi(1,quantity%template%noInstances) - &
            quantity%template%phi(1,1) ) / &
          ( quantity%template%noInstances - 1 )
        if ( scaleSurfs < 0.0 ) scaleSurfs = &
          ( quantity%template%surfs(quantity%template%noSurfs,1) - &
            quantity%template%surfs(1,1) ) / &
          ( quantity%template%noSurfs - 1 )
        scaleSurfs = scaleSurfs * scaleRatio
      end if
      ! Now loop over the output quantity points and set up the least-squares
      ! problem.
      do qi = 1, quantity%template%noInstances
        do qs = 1, quantity%template%noSurfs
          nRows = 0
          wMax = -1.0
          do si = 1, sourceQuantity%template%noInstances
            do ss = 1, sourceQuantity%template%noSurfs
              if ( method == l_lslocal ) then
                if ( surfs(ss,si) < quantity%template%surfs(max(qs-1,1),1) ) cycle
                if ( surfs(ss,si) > quantity%template%surfs(min(qs+1,quantity%template%noSurfs),1) ) cycle
                if ( insts(ss,si) < quantity%template%phi(1,max(qi-1,1)) ) cycle
                if ( insts(ss,si) > quantity%template%phi(1,min(qi+1,quantity%template%noInstances)) ) cycle
              end if
              nRows = nRows + 1
              lsMatrix(nRows,:3) = (/ 1.0_r8, &
                & insts(ss,si) - quantity%template%phi(1,qi), &
                & surfs(ss,si) - quantity%template%surfs(qs,1) /)
              lsMatrix(nRows,4) = 0.5 * lsMatrix(nRows,2) * lsMatrix(nRows,3)
              rhs(nRows) = sourceQuantity%values(myChannel+(ss-1)*sourceQuantity%template%noChans,si)
              if ( method == l_lsWeighted ) then
                w = exp( - (lsMatrix(nRows,2)/scaleInstances)**2 &
                       & - (lsMatrix(nRows,3)/scaleSurfs)**2 )
                if ( w > wMax ) then
                  wMax = w
                else if ( w < sqrt(epsilon(w))*wMax ) then
                  nRows = nRows - 1
                  cycle
                end if
                lsMatrix(nRows,:) = lsMatrix(nRows,:) * w
                rhs(nRows) = rhs(nRows) * w
              end if
            end do
          end do
          if ( nRows < 4 ) then
            quantity%values(qs,qi) = quantity%template%badValue
d1992 19
a2010 6
            ! Solve the least squares problem
            call hfti ( lsMatrix(:nRows,:), rhs(:nRows), krank=krank )
            if ( krank < 4 ) then
              quantity%values(qs,qi) = quantity%template%badValue
            else
              quantity%values(qs,qi) = rhs(1)
d2012 56
d2069 3
a2071 2
        end do
      end do
d2073 35
a2107 74
      ! Now tidy up
      call deallocate_test ( surfs,    'surfs',    moduleName )
      call deallocate_test ( insts,    'insts',    moduleName )
      call deallocate_test ( lsMatrix, 'LSMatrix', moduleName )
      call deallocate_test ( RHS,      'RHS',      moduleName )
      if ( associated ( ptanQuantity ) .and. sourceQuantity%template%minorFrame ) &
        & call Deallocate_test ( sourceHeights, 'sourceHeights', ModuleName )

    end subroutine FillUsingLeastSquares

    ! ----------------------------------------- offsetradiancequantity -----
    subroutine OffsetRadianceQuantity ( quantity, radianceQuantity, amount )
      type (VectorValue_T), intent(inout) :: QUANTITY
      type (VectorValue_T), intent(in) :: RADIANCEQUANTITY
      real (rv), intent(in) :: AMOUNT

      ! Executable code
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity for offsetRadiance fill is not radiance' )
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Radiance quantity for offsetRadiance fill is not radiance' )
      if ( quantity%template%signal /= radianceQuantity%template%signal .or. &
        & quantity%template%sideband /= radianceQuantity%template%sideband ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity and rad. qty. in offsetRadiance fill different signal/sideband' )
      if ( .not. associated ( radianceQuantity%mask ) ) return
      where ( iand ( ichar(radianceQuantity%mask), m_linAlg ) /= 0 )
        quantity%values = quantity%values + amount
      end where
    end subroutine OffsetRadianceQuantity

    ! ---------------------------------------------- ResetUnusedRadiances --
    subroutine ResetUnusedRadiances ( quantity, amount )
      type (VectorValue_T), intent(inout) :: QUANTITY
      real (rv), intent(in) :: AMOUNT
      ! Executable code
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_radiance/) ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity for resetUnusedRadiances fill is not radiance' )
      where ( quantity%values > amount*0.9 )
        quantity%values = quantity%values - amount
      end where
    end subroutine ResetUnusedRadiances

    ! ---------------------------------------------- ScaleOverlaps -------
    subroutine ScaleOverlaps ( quantity, multiplierNode, dontMask )
      type (VectorValue_T), intent(inout) :: QUANTITY
      integer, intent(in) :: MULTIPLIERNODE ! Tree node for factors
      logical :: DONTMASK               ! Flag
      ! Local variables
      real (r8) :: exprValue(2)         ! Tree expression
      integer :: exprUnit(2)            ! Tree units
      integer :: i,j                    ! Loop counters / indices

      ! Executable code
      scaleLowerLoop: do i = 1, quantity%template%noInstancesLowerOverlap
        if ( i+1 > nsons ( multiplierNode ) ) exit scaleLowerLoop
        call expr_check ( subtree( i+1, multiplierNode ), exprUnit, exprValue, &
          & (/PHYQ_Dimensionless/), unitsError )
        if ( unitsError ) then
          call Announce_error ( multiplierNode, wrongUnits, &
            & extraMessage="for scaleOverlaps fill", &
            & extraInfo=(/exprUnit(1), PHYQ_Dimensionless/) )
          return
        end if
        if ( associated ( quantity%mask ) .and. .not. dontMask ) then
          where ( iand ( ichar(quantity%mask(:,i)), m_Fill ) == 0 )
            quantity%values ( :, i ) = quantity%values ( :, i ) * exprValue(1)
          end where
d2109 2
a2110 3
          quantity%values ( :, i ) = quantity%values ( :, i ) * exprValue(1)
        end if
      end do scaleLowerLoop
d2112 10
a2121 17
      scaleUpperLoop: do i = quantity%template%noInstances, &
        & quantity%template%noInstances - &
        & quantity%template%noInstancesUpperOverlap + 1, - 1
        j = quantity%template%noInstances - i + 1
        if ( j+1 > nsons ( multiplierNode ) ) exit scaleUpperLoop
        call expr_check ( subtree( j+1, multiplierNode ), exprUnit, exprValue, &
          & (/PHYQ_Dimensionless/), unitsError )
        if ( unitsError ) then
          call Announce_error ( multiplierNode, wrongUnits, &
            & extraMessage="for scaleOverlaps fill", &
            & extraInfo=(/exprUnit(1), PHYQ_Dimensionless/) )
          return
        end if
        if ( associated ( quantity%mask ) .and. .not. dontMask ) then
          where ( iand ( ichar(quantity%mask(:,i)), m_Fill ) == 0 )
            quantity%values ( :, i ) = quantity%values ( :, i ) * exprValue(1)
          end where
d2123 52
a2174 1
          quantity%values ( :, i ) = quantity%values ( :, i ) * exprValue(1)
a2175 2
      end do scaleUpperLoop
    end subroutine ScaleOverlaps
d2177 27
a2203 52
    ! ----------------------------------------- SpreadChannelFill --------
    subroutine SpreadChannelFill ( quantity, channel, dontMask, key, &
      & sourceQuantity )
      type(VectorValue_T), intent(inout) :: QUANTITY
      integer, intent(in) :: CHANNEL
      logical, intent(in) :: DONTMASK
      integer, intent(in) :: KEY
      type(VectorValue_T), intent(in), optional :: SOURCEQUANTITY
      ! Local variables
      integer :: I                      ! Instance loop counter
      integer :: C                      ! Channel loop counter
      integer :: S                      ! Surface loop counter
      integer :: J                      ! Destination index
      integer :: MYCHANNEL              ! Possibly offset channel
      type (Signal_T) ::  signal        ! Signal for this quantity

      ! Exectuable code
      if ( present(sourceQuantity) ) then
        do i = 1, quantity%template%noInstances
          do s = 1, quantity%template%noSurfs
            do c = 1, quantity%template%noChans
              j = (s-1)*quantity%template%noChans + c
              if ( associated ( quantity%mask ) .and. .not. dontMask ) then
                if ( iand ( ichar(quantity%mask(j,i)), m_Fill ) == 1 ) cycle
              end if
              quantity%values ( j, i ) = &
                & sourceQuantity%values ( s, i )
            end do
          end do
        end do
        return
      endif
      ! Deal with any channel numbering issues.
      signal = GetSignal ( quantity%template%signal )
      myChannel = channel - lbound ( signal%frequencies, 1 ) + 1
      if ( myChannel < 1 .or. myChannel > quantity%template%noChans ) &
        & call Announce_Error ( key, no_error_code, &
        & 'Invalid channel for spread channel' )
      do i = 1, quantity%template%noInstances
        do s = 1, quantity%template%noSurfs
          do c = 1, quantity%template%noChans
            if ( c == myChannel ) cycle
            j = (s-1)*quantity%template%noChans + c
            if ( associated ( quantity%mask ) .and. .not. dontMask ) then
              if ( iand ( ichar(quantity%mask(j,i)), m_Fill ) == 1 ) cycle
            end if
            quantity%values ( j, i ) = &
              & quantity%values ( (s-1)*quantity%template%noChans + myChannel, i )
          end do
        end do
      end do
    end subroutine SpreadChannelFill
d2205 13
a2217 34
    ! ---------------------------------------------- TransferVectors -----
    subroutine TransferVectors ( source, dest, skipMask )
      ! Copy common items in source to those in dest
      type (Vector_T), intent(in) :: SOURCE
      type (Vector_T), intent(inout) :: DEST
      logical, intent(in) :: SKIPMASK

      ! Local variables
      type (VectorValue_T), pointer :: DQ ! Destination quantity
      type (VectorValue_T), pointer :: SQ ! Source quantity
      integer :: SQI                      ! Quantity index in source

      ! Executable code

      ! First copy those things in source, loop over them
      dest%globalUnit = source%globalUnit
      do sqi = 1, size ( source%quantities )
        ! Try to find this in dest
        sq => source%quantities(sqi)
        dq => GetVectorQtyByTemplateIndex ( dest, source%template%quantities(sqi) )
        if ( associated ( dq ) ) then
          dq%values = sq%values
          if ( .not. skipMask ) then
            if ( associated(sq%mask) ) then
              if ( .not. associated(dq%mask)) call CreateMask ( dq )
              dq%mask = sq%mask
            else
              if ( associated(dq%mask) ) &
                & call Deallocate_test ( dq%mask, 'dq%mask', ModuleName )
            end if
          end if
        end if
      end do
    end subroutine TransferVectors
d2219 4
a2222 2
    ! ---------------------------------------------  ANNOUNCE_ERROR  -----
    subroutine ANNOUNCE_ERROR ( where, CODE , ExtraMessage, ExtraInfo )
d2224 7
a2230 107
      use Dump_0, only: Dump
      use Intrinsic, only: Field_indices, PHYQ_Indices
      use MoreTree, only: Get_Field_Id, StartErrorMessage
      use String_Table, only: Display_String

      integer, intent(in) :: where   ! Tree node where error was noticed
      integer, intent(in) :: CODE    ! Code for error message
      character (LEN=*), intent(in), optional :: ExtraMessage
      integer, intent(in), dimension(:), optional :: ExtraInfo

      integer :: I

      error = max(error,1)
      call StartErrorMessage ( where )
      if ( code  > no_Error_Code ) call output ( 'The' );

      select case ( code )
      case ( badEstNoiseFill )
        call output ( " estimated noise fill is missing information", advance='yes' )
      case ( badGeocAltitudeQuantity )
        call output ( " geocAltitudeQuantity is not geocAltitude", advance='yes' )
      case ( badlosGridfill )
        call output ( " information for los Grid fill is incomplete/incorrect", advance='yes' )
      case ( badlosvelfill )
        call output ( " information for los velocity is incomplete/incorrect", advance='yes' )
      case ( badIsotopeFill )
        call output ( " information for isotope fill is incomplete/incorrect", advance='yes' )
      case ( badREFGPHQuantity )
        call output ( " refGPHQuantity is not refGPH", advance='yes' )
      case ( badRefractFill )
        call output ( " phiTan refract fill is missing information", advance='yes' )
      case ( badTemperatureQuantity )
        call output ( " temperatureQuantity is not temperature", advance='yes' )
      case ( bothFractionAndLength )
        call output ( " config specifies both fraction and lengthScale", advance='yes' )
      case ( cantFillFromL1B )
        call output ( " command could not be filled from L1B.", advance='yes' )
      case ( cantFillFromL2AUX )
        call output ( " command could not be filled from L2AUX.", advance='yes' )
      case ( cantInterpolate3D )
        call output ( " program cannot interpolate 3d quantities (yet).", advance='yes' )
      case ( emptyGridForFill )
        call output ( " config specifies an empty grid for the fill", advance='yes' )
      case ( errorReadingL1B )
        call output ( " L1B file could not be read.", advance='yes' )
      case ( invalidExplicitFill )
        call output ( " value has inappropriate dimensionality for explicit fill.", advance='yes' )
        call output ( " Should have " )
        call output ( extraInfo )
        call output ( " elements.", advance='yes' )
      case ( missingDataInGrid )
        call output ( " grid for fill has missing/bad data points", advance='yes' )
      case ( missingField )
        call output ( " fields " )
        do i = 1, size(extraInfo)
          call display_string ( field_indices(extraInfo(i)) )
          if ( i == size(extraInfo) ) then
            call output ( " and " )
          else
            call output ( ", " )
          end if
        end do
        call output ( " are required.", advance='yes' )
      case ( needGeocAltitude )
        call output ( " fill needs geocAltitudeQuantity.", advance='yes' )
      case ( needH2O )
        call output ( " fill needs H2OQuantity.", advance='yes' )
      case ( needOrbitInclination )
        call output ( " fill needs OrbitalInclination.", advance='yes' )
      case ( needTempREFGPH )
        call output ( " needs temperatureQuantity and refGPHquantity.", advance='yes' )
      case ( no_Error_Code ) ! Handled at the bottom
      case ( noExplicitValuesGiven )
        call output ( " explicit fill requires explicit values.", advance='yes' )
      case ( nonConformingHydrostatic )
        call output ( " quantities needed for hydrostatic fill do not conform", advance='yes' )
      case ( noSourceGridGiven )
        call output ( " gridded fill requires a sourceGrid field.", advance='yes' )
      case ( noSourceL2AUXGiven )
        call output ( " L2AUX fill requires a sourceL2AUX field.", advance='yes' )
      case ( noSourceL2GPGiven )
        call output ( " L2GP fill requires a sourceL2GP field.", advance='yes' )
      case ( noSpecialFill )
        call output ( " special fill is invalid", advance='yes' )
      case ( notImplemented )
        call output ( extraMessage )
        call output ( " method is not implemented yet.", advance='yes' )
      case ( notSPD )
        call output ( " matrix is not a SPD matrix.", advance='yes' )
      case ( notPlain )
        call output ( " matrix is not a plain matrix.", advance='yes' )
      case ( NotZetaForGrid )
        call output ( " Quantity not on zeta surfaces.", advance='yes' )
      case ( wrongUnits )
        call display_string ( field_indices(Get_Field_Id(where)), &
          & before=" values of the " )
        call output ( " field have the wrong units", advance="yes" )
        if ( present(extraInfo) ) then
          i = 1
          if ( size(extraInfo) > 1 ) then
            call display_String ( phyq_indices(extraInfo(1)), &
              & before="Units are " )
            call output ( ", " )
            i = 2
          end if
          call display_String ( phyq_indices(extraInfo(i:)), advance='yes', &
            & before="Units should be" )
d2232 2
d2235 16
a2250 7
        call outputNamedValue( ' error code', Code, advance='no' )
        call output ( " command caused an unrecognized programming error", advance='yes' )
      end select
      if ( present(ExtraMessage) )  call output(ExtraMessage, advance='yes')
      if ( code == no_Error_Code .and. present(extraInfo) ) &
        & call dump ( extraInfo, name='Extra info' )
    end subroutine ANNOUNCE_ERROR
d2257 1
a2257 1
       "$Id: Fill.f90,v 2.354 2007/08/23 22:17:05 pwagner Exp $"
d2268 3
@


2.354
log
@manipulation Fills can now use statistical functions
@
text
@d1551 3
a1553 2
          call FillQuantityByManipulation ( quantity, aQuantity, bQuantity, &
            & manipulation, key, force, dontSumHeights, dontSumInstances, c )
d6289 3
a6291 2
    subroutine FillQuantityByManipulation ( quantity, a, b, manipulation, &
      & key, force, dontSumHeights, dontSumInstances, c )
d6296 1
d6300 4
a6303 3
      logical, intent(in) :: dontSumHeights   ! When doing statistics
      logical, intent(in) :: dontSumInstances ! When doing statistics
      real(rv) :: C                     ! constant "c" in manipulation
d6345 1
d6440 1
a6440 1
            call doStatFun( quantity%values(1, instance), mstr, &
d6442 5
d6450 1
a6450 1
            call doStatFun( quantity%values(iSurf, 1), mstr, &
d6452 5
d6462 1
a6462 1
            quantity%values(1, 1) = mlsmin( a%values )
d6464 1
a6464 1
            quantity%values(1, 1) = mlsmax( a%values )
d6466 1
a6466 1
            quantity%values(1, 1) = mlsmean( a%values )
d6468 1
a6468 1
            quantity%values(1, 1) = mlsmedian( a%values )
d6470 1
a6470 1
            quantity%values(1, 1) = mlsrms( a%values )
d6472 1
a6472 1
            quantity%values(1, 1) = mlsstddev( a%values )
d6476 5
d8230 1
a8230 1
       "$Id: Fill.f90,v 2.353 2007/08/20 22:04:48 pwagner Exp $"
d8241 3
@


2.353
log
@Many procedures now push their names onto MLSCallStack
@
text
@d80 2
a81 1
      & F_DESTINATION, F_DIAGONAL, F_DONTMASK,&
d178 1
d356 2
d558 2
d871 4
d1552 1
a1552 1
            & manipulation, key, force, c )
d6289 1
a6289 1
      & key, force, c )
d6297 2
d6311 1
a6311 1
      integer, parameter :: NO1WAYMANIPULATIONS = 7
d6313 13
a6325 7
        & '-a      ', &
        & '1/a     ', &
        & 'abs(a)  ', &
        & 'sign(a) ', &
        & 'exp(a)  ', &
        & 'log(a)  ', &
        & 'log10(a)' /)
d6332 1
d6334 1
a6334 1
      integer :: I
d6336 3
d6342 1
d6353 1
d6389 3
a6391 1
        if ( .not. force ) then
d6421 46
a6466 1
      ! Later we'll do fancy stuff to parse the manipulation.
d6609 1
d6613 22
d8210 1
a8210 1
       "$Id: Fill.f90,v 2.352 2007/07/06 17:09:16 pwagner Exp $"
d8221 3
@


2.352
log
@Reverted to former ApplyBaseline
@
text
@d171 1
a171 1
      & MLSMSG_Allocate, MLSMSG_Deallocate
d2717 1
d2845 1
a2851 1
      use MLSNumerics, only: HUNT
d2885 1
d3020 1
a4041 1
      use MLSNumerics, only: InterpolateValues
d4061 1
d4135 1
d4155 1
d4208 1
d4283 1
d4483 1
d4604 1
d4872 1
d6005 1
d6105 1
a7142 1
      use MLSNumerics, only: HUNT
d7198 1
d7282 1
d7312 1
d7463 1
d7542 1
d7569 1
d7585 1
d7611 1
d8116 1
a8116 1
       "$Id: Fill.f90,v 2.351 2007/06/21 22:34:32 pwagner Exp $"
d8127 3
@


2.351
log
@Fixed inconsequential bug in adding baseline when quantity was masked
@
text
@d2351 1
a2351 3
            if ( .not. dontMask .and. &
              & ( associated(baselineQuantity%mask) .or. &
              &   associated(quantity%mask) )) then
d2353 1
a2353 1
                skipMe = isVectorQtyMasked(Quantity, chan, i) .or. &
d2370 1
a2370 3
            if ( .not. dontMask .and. &
              & ( associated(baselineQuantity%mask) .or. &
              &   associated(quantity%mask) )) then
d2372 1
a2372 1
                skipMe = isVectorQtyMasked(Quantity, chan, i) .or. &
d8097 1
a8097 1
       "$Id: Fill.f90,v 2.350 2007/03/23 00:26:09 pwagner Exp $"
d8108 3
@


2.350
log
@More unused debugging; skips filling covariance matrix if skipping retrievals
@
text
@d2351 3
a2353 1
            if ( .not. dontMask .and. associated(baselineQuantity%mask) ) then
d2355 1
a2355 1
                skipMe = .not. dontMask .and. &
d2372 3
a2374 1
            if ( .not. dontMask .and. associated(baselineQuantity%mask) ) then
d2376 1
a2376 1
                skipMe = .not. dontMask .and. &
d5833 4
d5843 2
d8101 1
a8101 1
       "$Id: Fill.f90,v 2.349 2007/01/12 00:34:04 pwagner Exp $"
d8112 3
@


2.349
log
@Renamed routine outputNamedValue
@
text
@d167 1
a167 1
    use MLSL2Options, only: SPECIALDUMPFILE
d646 2
a647 1
        call dumpCommand ( key, qtyTemplates, vectorTemplates, vectors )
d2047 1
a2047 1
            & temperatureQuantity, refGPHQuantity )
d2086 7
a2092 2
        call FillCovariance ( covariance, vectors, diagonal, lengthScale, fraction, &
          & invert )
d2607 2
d2620 1
a2620 1

d2623 3
d2652 6
d2663 6
d7006 1
a7006 1
    subroutine FillQtyWithReichlerWMOTP ( tpPres, temperature, refGPH )
a7019 1
      type (VectorValue_T), intent(in) :: REFGPH
d8091 1
a8091 1
       "$Id: Fill.f90,v 2.348 2006/11/03 19:40:17 pwagner Exp $"
d8102 3
@


2.348
log
@Fixed unassociated pointers NAG caught
@
text
@d183 1
a183 1
    use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, output_name_v_pair, &
d1361 1
a1361 1
          ! call output_name_v_pair( 'error code', errorCode )
d5802 4
a5805 4
            call output_name_v_pair( 'shape' // trim(namestring), shape(l1bData%dpField) )
            call output_name_v_pair( 'shape(BO_stat)', shape(BO_stat%intField) )
            call output_name_v_pair( 'noMAFs', noMAFs )
            call output_name_v_pair( 'maxMIFs', maxMIFs )
d8056 1
a8056 1
        call output_name_v_pair( ' error code', Code, advance='no' )
d8069 1
a8069 1
       "$Id: Fill.f90,v 2.347 2006/11/03 00:26:07 pwagner Exp $"
d8080 3
@


2.347
log
@Fixed bug in tropopause calculation
@
text
@d7014 1
d8069 1
a8069 1
       "$Id: Fill.f90,v 2.346 2006/10/11 22:56:11 pwagner Exp $"
d8080 3
@


2.346
log
@May fill convergence from dnwt_chisqRatio
@
text
@d46 1
a46 1
  logical, parameter :: USEREICHLER = .false.
d6985 1
d6987 2
d7004 1
a7004 1
      real, dimension(size(refGPH%values, 1)) :: p ! Pa
d7008 1
a7008 1
      real, dimension(size(refGPH%values, 1)) :: t
d7011 2
d7014 1
a7014 1
      nlev = size(refGPH%values, 1)
d7018 20
d7039 1
d7044 1
d7049 2
a7050 3
        if (refGPH%values(1,instance) .gt. refGPH%values(2,instance)) then
          invert=1
          p=refGPH%values(nlev:1:-1,instance)*100.  ! hPa > Pa
a7052 2
          invert=0
          p=refGPH%values(:,instance)*100.         ! hPa > Pa
d7059 9
a7067 1
        if ( nvalid < 2 ) cycle
d7073 9
d7084 7
a7090 2
          & extraTropics(temperature%template%geodLat(1, instance) ) ) &
          & trp = MISSINGVALUE
d7095 1
d8068 1
a8068 1
       "$Id: Fill.f90,v 2.345 2006/10/03 20:24:11 pwagner Exp $"
d8079 3
@


2.345
log
@Optional test, tweaks to FillChiSqRatio
@
text
@d113 1
a113 1
      & L_COMBINECHANNELS, L_COLUMNABUNDANCE, &
d1279 8
d1656 6
a1661 43
            if ( .not. any(got( &
             & (/f_h2oquantity, f_temperatureQuantity/) &
             & )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill rhi'  )
            else ! value
                h2oQuantity => GetVectorQtyByTemplateIndex( &
                  & vectors(h2oVectorIndex), h2oQuantityIndex)
                temperatureQuantity => GetVectorQtyByTemplateIndex( &
                  & vectors(temperatureVectorIndex), temperatureQuantityIndex)
                if ( .not. ValidateVectorQuantity(h2oQuantity, &
                  & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                  call Announce_Error ( key, No_Error_code, &
                    & 'The h2oQuantity is not a vmr for the H2O molecule'  )
                else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                  & quantityType=(/l_temperature/)) ) then
                  call Announce_Error ( key, No_Error_code, &
                    & 'The temperatureQuantity is not a temperature'  )
                else
                  call FillRHIFromH2O ( key, quantity, &
                    & h2oQuantity, temperatureQuantity, &
                    & dontMask, ignoreZero, ignoreNegative, interpolate, &
                    & .true., &   ! Mark Undefined values?
                    & invert )    ! invert rather than convert?
                end if
            end if

          case ( l_quality )
            if ( .not. all ( got ( (/ f_sourceQuantity, f_scale /) ) ) ) &
              call Announce_error ( key, no_error_code, &
              & 'Need sourceQuanitity and scale for quality fill' )
            sourceQuantity => GetVectorQtyByTemplateIndex ( vectors(sourceVectorIndex), &
              & sourceQuantityIndex )
            call FillQualityFromChisq ( key, quantity, sourceQuantity, scale, heightNode )

          case ( l_RHIPrecisionfromH2O ) ! --fill RHI prec. from H2O quantity --
            if ( .not. any(got( &
              & (/f_h2oquantity, f_temperatureQuantity, &
              & f_h2oPrecisionquantity, f_tempPrecisionQuantity/) &
              & )) ) then
              call Announce_error ( key, No_Error_code, &
                & 'Missing a required field to fill rhi precision'  )
            else
a1665 4
              h2oPrecisionQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(h2oPrecisionVectorIndex), h2oPrecisionQuantityIndex)
              tempPrecisionQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(tempPrecisionVectorIndex), tempPrecisionQuantityIndex)
a1673 8
              else if ( .not. ValidateVectorQuantity(h2oPrecisionQuantity, &
                & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                call Announce_Error ( key, No_Error_code, &
                  & 'The h2oPrecisionQuantity is not a vmr for the H2O molecule'  )
              else if ( .not. ValidateVectorQuantity(tempPrecisionQuantity, &
                & quantityType=(/l_temperature/)) ) then
                call Announce_Error ( key, No_Error_code, &
                  & 'The tempPrecisionQuantity is not a temperature'  )
d1675 3
a1677 4
                call FillRHIPrecisionFromH2O ( key, quantity, &
                  & h2oPrecisionQuantity, tempPrecisionQuantity, h2oQuantity, &
                  & temperatureQuantity, dontMask, ignoreZero, &
                  & ignoreNegative, interpolate, &
d1681 1
a1681 1
            end if
d1683 40
a1722 4
          case ( l_rotateField )
            if ( .not. all ( got ( (/ f_fieldECR, f_ecrtofov /) ) ) ) then
              call Announce_Error ( key, no_error_code, &
                & 'Must supply field and ecrToFov for rotateField fill' )
d1724 6
a1729 5
              fieldECR => GetVectorQtyByTemplateIndex ( &
                & vectors(fieldECRVectorIndex), fieldECRQuantityIndex )
              ecrToFOV => GetVectorQtyByTemplateIndex ( &
                & vectors(ecrToFOVVectorIndex), ecrToFovQuantityIndex )
              call RotateMagneticField ( key, quantity, fieldECR, ecrToFov )
d1731 13
a3616 1
      real(r8), dimension(:), pointer  ::    VALUES => NULL()
a3618 2
      integer ::                             C           ! Channel loop counter
      integer ::                             S           ! Surface loop counter
a3622 1
      integer ::                             N           ! Num. of summed values
d7519 17
d8021 1
a8021 1
       "$Id: Fill.f90,v 2.344 2006/10/02 23:05:03 pwagner Exp $"
d8032 3
@


2.344
log
@May Fill chi^2 ratio to measure convergence
@
text
@d3599 3
a3601 3
      type (VectorValue_T), intent(in) ::    normQty
      type (VectorValue_T), intent(in) ::    minNormQty
      type (VectorValue_T), intent(in) ::    flagQty
d3615 1
d3620 1
a3620 1
      real                             ::    a, b
d3666 14
d3681 1
a3681 1
        qIndex = findLast(flagQty%values(:,i) /= 0)
d8000 1
a8000 1
       "$Id: Fill.f90,v 2.343 2006/08/03 01:58:03 vsnyder Exp $"
d8011 3
@


2.343
log
@Better error message if profile is out of order
@
text
@d82 1
a82 1
      & F_EXTINCTION, F_FIELDECR, F_FILE, F_FORCE, &
d89 3
a91 2
      & F_MANIPULATION, F_MATRIX, F_MAXITERATIONS, F_MAXVALUE, F_MEASUREMENTS, F_METHOD, &
      & F_MINVALUE, F_MODEL, F_MULTIPLIER, F_NOFINEGRID, F_NOISE, F_NOISEBANDWIDTH, &
d111 1
a111 1
      & L_CHISQMMAF, L_CHISQMMIF, L_CHOLESKY, &
d113 3
a115 1
      & L_COMBINECHANNELS, L_COLUMNABUNDANCE, L_DOBSONUNITS, L_DU, &
d174 1
a174 1
    use MLSSets, only: FindFirst
d285 1
d294 1
d298 1
d366 2
d419 2
d422 4
d437 4
d443 1
a520 7
    integer :: MEASQTYINDEX
    integer :: MEASVECTORINDEX
    integer :: MODELQTYINDEX
    integer :: MODELVECTORINDEX
    integer :: NOISEQTYINDEX
    integer :: NOISEVECTORINDEX
    logical :: OLD_MATH77_RAN_PACK      ! To restore math77_ran_pack
a828 3
          case ( f_noise )   ! Only used for chi^2 special fills or addnoise
            noiseVectorIndex = decoration(decoration(subtree(1,gson)))
            noiseQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
d841 3
d920 3
d938 3
d944 3
d1256 14
d3581 98
d7877 1
a7877 1
      call output ( 'The' );
d7985 1
a7985 1
       "$Id: Fill.f90,v 2.342 2006/08/02 19:52:29 vsnyder Exp $"
d7996 3
@


2.342
log
@Move destroy processing to DestroyCommand_m
@
text
@d2804 2
a2806 1
      logical :: LOCALOUTHEIGHTS ! Set if out heights is our own variable
d2889 6
a2894 1
          & nearest=.true., allowTopValue=.true. )
d7852 1
a7852 1
       "$Id: Fill.f90,v 2.341 2006/07/28 01:55:20 vsnyder Exp $"
d7863 3
@


2.341
log
@Improve error detection and reporting for some allocations.
Comment out matrix and vector dumps conditioned on the -g level since
these dumps can be gotten by dump and dumpBlocks commands.  Inserted
a comment to that effect.
@
text
@d67 1
d157 1
a157 1
      & DestroyMatrix, Dump, GetActualMatrixFromDatabase, GetDiagonal, &
d376 1
a376 1
    integer :: I, J, K                  ! Loop indices for section, spec, expr
a408 1
    integer :: MATRIXTOKILL             ! Index in database
d2068 1
a2068 55
        if ( DEEBUG) call output('Destroy vector/matrix instruction', &
        &  advance='no')
        ! Here we're to try to shrink the vector database by destroying a vector
        ! or the matrix database database by destroying a matrix
        ! Loop over the instructions
        do j = 2, nsons(key)
          son = subtree(j,key)  ! The argument
          fieldIndex = get_field_id(son)
          got(fieldIndex)=.true.
          if ( nsons(son) > 1 ) then
            fieldValue = decoration(subtree(2,son)) ! The field's value
          else
            fieldValue = son
          end if
          select case ( fieldIndex )
          case ( f_matrix )
            do k = 2, nsons(son)
              matrixToKill = decoration(decoration(subtree(k,son)))
              if ( DEEBUG ) then
                ! if ( matrices(matrixToKill)%matrix%name /= 0 ) then
                 ! call output ( '   Matrix Name = ' )
                 ! call display_string ( matrices(matrixToKill)%matrix%name )
                 call dump(matrices(matrixToKill), -1)
                ! end if
              end if

              call DestroyMatrix ( matrices(matrixToKill) )
            end do
          case ( f_vector )
            do k = 2, nsons(son)
              sourceVectorIndex = decoration(decoration(subtree(k,son)))
              if ( DEEBUG ) then
                if ( vectors(sourceVectorIndex)%name /= 0 ) then
                  call output ( '   Vector Name = ' )
                  call display_string ( vectors(sourceVectorIndex)%name )
                end if
                if ( vectors(sourceVectorIndex)%template%name /= 0 ) then
                  call output ( ' Template_Name = ' )
                  call display_string ( vectors(sourceVectorIndex)%template%name )
                  call output ( ' ', advance='yes' )
                end if
                call output ( ' -- vector database before removal --', advance='yes' )
                call dump(vectors, details=-2)
              end if

              call DestroyVectorInfo ( vectors(sourceVectorIndex) )
         !    vectorindex = rmVectorFromDatabase ( vectors, vectors(sourceVectorIndex) )
              if ( DEEBUG ) then
                call output ( ' -- vector database after removal --', advance='yes' )
                call dump(vectors, details=-2)
              end if
            end do
          case default ! Can't get here if type checker worked
          end select
        end do
d7846 1
a7846 1
       "$Id: Fill.f90,v 2.340 2006/07/27 23:07:38 pwagner Exp $"
d7857 6
@


2.340
log
@Attempt to enforce conformity between column unit attributes and how we compute them
@
text
@d65 1
a65 1
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d629 1
d631 1
d633 1
a633 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate // 'one of QtyTemplates, VectorTemplates or Vectors' )
d2239 9
a2247 8
    if ( toggle(gen) ) then
      if ( levels(gen) > 0 ) then
        call dump ( vectors, details=levels(gen)-1 )
        call dump ( matrices, details=levels(gen)-1 )
      end if
    end if
    if ( specialDumpFile /= ' ' ) &
      & call revertOutput
d7900 1
a7900 1
       "$Id: Fill.f90,v 2.339 2006/07/27 03:54:11 vsnyder Exp $"
d7911 3
@


2.339
log
@Include source_ref in created vectors and matrices
@
text
@d173 2
a174 2
    use MLSStringLists, only: catLists, GetStringElement, NumStringElements, &
      & PutHashElement, &
d1768 7
d1776 1
d7898 1
a7898 1
       "$Id: Fill.f90,v 2.338 2006/07/12 20:41:16 pwagner Exp $"
d7909 3
@


2.338
log
@Fixed BO size mismatch that only NAG caught
@
text
@d620 2
a621 1
          & qtyTemplates, globalUnit=globalUnit, highBound=highBound, lowBound=lowBound ) ) )
d658 1
a658 1
              & vectors(rowVector), vectors(colVector) )
d663 1
a663 1
              & vectors(rowVector), vectors(colVector) )
d668 1
a668 1
              vectors(colVector) )
d673 1
a673 1
              & vectors(colVector), vectors(colVector) )
d7890 1
a7890 1
       "$Id: Fill.f90,v 2.337 2006/07/07 23:08:53 pwagner Exp $"
d7901 3
@


2.337
log
@Fixed bug in filling from GEOS5-derived grid
@
text
@d5508 1
d5672 25
a5696 2
          l1bData%dpField = NegativeIfBitPatternSet(l1bData%dpField, &
            & BO_stat%intField(:, 1:maxMIFs, 1:noMAFs), myBOMask)
d7889 1
a7889 1
       "$Id: Fill.f90,v 2.336 2006/06/13 22:14:18 pwagner Exp $"
d7900 3
@


2.336
log
@Recover gracefully if l1boa file lacks BO_stat dataset
@
text
@d179 2
a180 1
    use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT, revertoutput, switchOutput
d1313 1
d1316 1
a2315 1
      ! use output_m, only: blanks, output
d2616 9
a2624 1
        errorCode=EmptyGridForFill
d2628 2
a2629 1
      if ( quantity%template%verticalCoordinate /= l_zeta ) then
d7814 1
a7814 1
      case ( no_Error_Code ) ! Handled at the botom
d7834 2
d7852 1
d7865 1
a7865 1
       "$Id: Fill.f90,v 2.335 2006/06/12 19:28:52 pwagner Exp $"
d7876 3
@


2.335
log
@Fallback to climatology noted only if all of ncep, goes4/5 missing
@
text
@d5495 1
d5586 3
a5588 3
        call ReadL1BData ( L1BOAFile, moduleNameString, BO_stat, noMAFs, flag, &
          & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & NeverFail= .false., &
d5657 1
a5657 1
        if ( isPrecision .and. myBOMask /= 0 ) then
d7851 1
a7851 1
       "$Id: Fill.f90,v 2.334 2006/06/08 17:29:27 dwu Exp $"
d7862 3
@


2.334
log
@add option to allow sourceQuantity in spreadChannel
@
text
@d857 2
a858 1
              & ( APrioriFiles%dao // AprioriFiles%ncep == ' ' )
a1261 2
          ! if ( .not. ifMissingGMAO .or. APrioriFiles%dao // AprioriFiles%ncep == ' ') &
          !  & call ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
d7850 1
a7850 1
       "$Id: Fill.f90,v 2.333 2006/06/03 01:43:36 vsnyder Exp $"
d7861 3
@


2.333
log
@Allow multiple fields and multiple vectors/matrices per field on destroy
@
text
@d1853 12
a1864 3
          if ( .not. got ( f_channel ) ) call Announce_Error ( key, &
            & no_error_code, 'Must supply channel for spreadChannel fill' )
          call SpreadChannelFill ( quantity, channel, dontMask, key )
d7642 2
a7643 1
    subroutine SpreadChannelFill ( quantity, channel, dontMask, key )
d7648 1
d7658 15
d7851 1
a7851 1
       "$Id: Fill.f90,v 2.332 2006/05/22 21:56:00 pwagner Exp $"
d7862 3
@


2.332
log
@Fixed bug besetting manipulation fills
@
text
@d374 1
a374 1
    integer :: I, J                     ! Loop indices for section, spec, expr
a2051 1
        ! (Shall we allow multiple vectors on a single line? Maybe later)
d2063 12
a2074 1
            matrixToKill = decoration(decoration(subtree(2,son)))
d2076 23
a2098 1
            sourceVectorIndex = decoration(decoration(subtree(2,son)))
a2101 32
        if ( got(f_vector) ) then
          if ( DEEBUG ) then
            if ( vectors(sourceVectorIndex)%name /= 0 ) then
              call output ( '   Vector Name = ' )
              call display_string ( vectors(sourceVectorIndex)%name )
            end if
            if ( vectors(sourceVectorIndex)%template%name /= 0 ) then
              call output ( ' Template_Name = ' )
              call display_string ( vectors(sourceVectorIndex)%template%name )
              call output ( ' ', advance='yes' )
            end if
            call output ( ' -- vector database before removal --', advance='yes' )
            call dump(vectors, details=-2)
          end if

          call DestroyVectorInfo ( vectors(sourceVectorIndex) )
     !    vectorindex = rmVectorFromDatabase ( vectors, vectors(sourceVectorIndex) )
          if ( DEEBUG ) then
            call output ( ' -- vector database after removal --', advance='yes' )
            call dump(vectors, details=-2)
          end if
        else if ( got(f_matrix) ) then
          if ( DEEBUG ) then
            ! if ( matrices(matrixToKill)%matrix%name /= 0 ) then
             ! call output ( '   Matrix Name = ' )
             ! call display_string ( matrices(matrixToKill)%matrix%name )
             call dump(matrices(matrixToKill), -1)
            ! end if
          end if

          call DestroyMatrix ( matrices(matrixToKill) )
        end if
d7825 1
a7825 1
       "$Id: Fill.f90,v 2.331 2006/05/19 00:00:13 pwagner Exp $"
d7836 3
@


2.331
log
@Added min, max operators ('<', '>') to manipulation fills with c
@
text
@a6374 1
        quantity%values = 0.
d6459 1
d6465 1
a6465 1
        return
d7825 1
a7825 1
       "$Id: Fill.f90,v 2.330 2006/05/03 22:18:26 pwagner Exp $"
d7836 3
@


2.330
log
@Sets mask reading quantities missing from l1b file
@
text
@d6090 18
a6107 17
      character(len=7), parameter :: VALID2WAYMANIPULATIONS ( NO2WAYMANIPULATIONS ) = (/ &
        & 'a+b    ', &
        & '(a+b)/2', &
        & 'a-b    ', &
        & 'a*b    ', &
        & 'a>b    ', &
        & 'a<b    ', &
        & 'a|b    ', &
        & 'a/b    ' /)
      integer, parameter :: NO1WAYMANIPULATIONS = 6
      character(len=7), parameter :: VALID1WAYMANIPULATIONS ( NO1WAYMANIPULATIONS ) = (/ &
        & '-a     ', &
        & '1/a    ', &
        & 'abs(a) ', &
        & 'sign(a)', &
        & 'exp(a) ', &
        & 'log(a) ' /)
d6323 11
d6351 1
a6351 1
        ! where 'op' is one of {+, -, *, /}
d6410 10
d6480 1
a6480 1
        ! the lower-precedence operators {+, -}
d6499 10
d6514 4
d6538 10
d6621 1
a6621 1
        ! (3) binary operators {'+', '-', '*', '/'}
d6660 3
d6669 3
d6703 6
d6744 4
d7825 1
a7825 1
       "$Id: Fill.f90,v 2.329 2006/03/23 03:06:35 vsnyder Exp $"
d7836 3
@


2.329
log
@Use HFTI instead of Cholesky for FillUsingLeastSquares, for stability
@
text
@d1167 2
a1168 1
          call ApplyBaseline ( key, quantity, baselineQuantity, quadrature )
d2303 3
a2305 1
    subroutine ApplyBaseline ( key, quantity, baselineQuantity, quadrature )
d2310 1
d2315 3
d2319 1
d2331 1
d2335 13
a2347 2
            quantity%values ( ind, : ) = sqrt ( quantity%values ( ind, : )**2 + &
              & baselineQuantity%values ( chan, : )**2 )
d2354 13
a2366 2
            quantity%values ( ind, : ) = quantity%values ( ind, : ) + &
              & baselineQuantity%values ( chan, : )
a4286 5
! >                & exp(invs*( &
! >                & (C(T)+zeta(qIndex)+vmr_unit_cnv) * log(10.) &
! >                & + &
! >                & 3.56654*log(T/273.16) &
! >                & ))
a4417 1
!     integer ::                          S_H2OPrecision       ! Instance num for surfs
a4419 1
!     integer ::                          S_TPrecision         ! Instance num for surfs
a4514 10
!         if ( sourcePrecisionQuantity%template%coherent ) then
!           s_h2oPrecision = 1
!         else
!           s_h2oPrecision = i
!         end if
!         if ( tempPrecisionquantity%template%coherent ) then
!           s_tPrecision = 1
!         else
!           s_tPrecision = i
!         end if
d5475 2
d5597 12
d5679 1
a5679 1
        quantity%values = -1.0
d7763 1
a7763 1
       "$Id: Fill.f90,v 2.328 2006/03/23 00:38:57 vsnyder Exp $"
d7774 3
@


2.328
log
@Make SolveLS a little more general, in case somebody else wants to use it
@
text
@d7278 1
d7296 2
a7297 1
      integer :: QS, QI, SS, SI                  ! Loop counters
d7429 7
a7435 3
            ! Solve the least squares problem locally
            call solveLS ( lsMatrix(:nRows,:), rhs(:nRows), &
              & quantity%values(qs,qi), quantity%template%badValue )
a7449 64
    ! -------------------------------------------------------- SolveLS -----
    subroutine SolveLS ( LSMatrix, RHS, Result, Bad )
    ! Solve a least-squares problem for FillUsingLeastSquares

    !{ Given the least-squares problem $A x \simeq b$, form normal equations
    !  $A^T A x = A^T b$ (if the condition number might be far from 1.0, we
    !  should really use householder).  Decompose $A^T A$ using Cholesky
    !  decomposition giving $A^T A x = C^T C x = A^T b$, where $C$ is upper
    !  triangular.  Then backsolve once to get $C x = C^{-T} A^T b$ and
    !  again to get $x = C^{-1} C^{-T} A^T b$.

      use MatrixModule_0, only: DenseCholesky
      use MLSKinds, only: R8, RM
      real(r8), intent(in) :: LSMatrix(:,:), RHS(:)
      real(r8), intent(out) :: Result
      real(r8), intent(in) :: Bad
      real(rm), dimension(size(lsMatrix,2),size(lsMatrix,2)) :: NormalMatrix
      real(rm), dimension(size(lsMatrix,2)) :: NormalRHS, X
      real(rm) :: D ! Diagonal of factored normalMatrix
      integer :: I, J, Stat

      !{ Form normal equations $A^T A x \simeq A^T b$ -- yeah, we really
      !  should use Householder....  $A^T A$ is in {\tt NormalMatrix} and
      !  $A^T b$ is in {\tt NormalRHS}.
      do i = 1, size(lsMatrix,2)
        normalRHS(i) = dot_product(lsMatrix(:,i),rhs)
        do j = i, size(lsMatrix,2)
          normalMatrix(i,j) = dot_product(lsMatrix(:,i),lsMatrix(:,j))
        end do
      end do
      !{ Factor the normal equations' matrix $C^T C = A^T A$ leaving $C$ in
      !  {\tt NormalMatrix}.
      call denseCholesky ( normalMatrix, normalMatrix, stat )
      if ( stat == 0 ) then
        !{ Backsolve $C^T (C x) = A^T b$ for $C x$, storing
        !  $C x = C^{-T} A^T b$ in {\tt x}.
        do i = 1, size(lsMatrix,2)
          d = normalMatrix(i,i)
          if ( abs(d) > tiny(0.0_r8) ) then
            x(i) = ( normalRHS(i) - dot_product(normalMatrix(:i-1,i), x(:i-1)) ) / d
          else
            result = bad
            return
          end if
        end do
        !{ Backsolve $C x = C^{-T} A^T b$ storing $C^{-1} C^{-T} A^T b$ in
        !  {\tt x}.
        do i = size(lsMatrix,2), 1, -1
          d = normalMatrix(i,i)
          if ( abs(d) > tiny(0.0_r8) ) then
            x(i) = ( x(i) - dot_product(normalMatrix(i,i+1:), x(i+1:)) ) / d
          else
            result = bad
            return
          end if
        end do
      else
        result = bad
        return
      end if
      result = x(1)

    end subroutine SolveLS

d7735 1
a7735 1
       "$Id: Fill.f90,v 2.327 2006/03/22 23:47:37 vsnyder Exp $"
d7746 3
@


2.327
log
@More work on least-squares fill
@
text
@d7460 2
a7461 2
      real(rm), dimension(4,4) :: NormalMatrix
      real(rm), dimension(4) :: NormalRHS, X
d7793 1
a7793 1
       "$Id: Fill.f90,v 2.326 2006/03/15 23:55:11 pwagner Exp $"
d7804 3
@


2.326
log
@Use reorderPrecedence to ensure higher precedes lower in manipulations
@
text
@d96 1
d119 1
d163 1
a163 1
    use MLSL2Options, only: RESTARTWARNINGS, SPECIALDUMPFILE
d451 3
d562 3
d993 1
a993 1
          case ( f_scale )
d998 10
a1007 1
            scale = valueAsArray(1)
d1179 2
a1180 1
        case ( l_binMax, l_binMean, l_binMin, l_binTotal )
d1183 1
a1183 1
            & 'Need source quantity for bin max/min fill' )
d1197 9
a1205 7
              &  quantity%template%verticalCoordinate /= l_zeta ) &
              & call Announce_Error ( key, no_Error_Code, &
              & 'Vertical coordinate mismatch, perhaps supply tangent pressure?' )
            if ( ptanQuantity%template%instrumentModule .ne. &
              & sourceQuantity%template%instrumentModule ) &
              & call Announce_Error ( key, no_Error_Code, &
              & 'Instrument module mismatch between ptan and source quantity' )
d1208 10
a1217 2
          call FillWithBinResults ( key, quantity, sourceQuantity, ptanQuantity, &
            & channel, fillMethod, additional, excludeBelowBottom, centerVertically )
d1222 1
a1222 1
            & 'Need source quantity for bin max/min fill' )
d1331 1
a1331 1
            enddo
d1536 1
a1536 1
          endif
d1702 1
a1702 1
            call ScaleOverlaps ( key, quantity, multiplierNode, dontMask )
d1764 1
a1764 1
              endif
d1886 1
a1886 1
          endif
d1982 1
a1982 1
          endif
a3850 1
      use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
d4810 1
a4810 1
	       if ( toggle(gen) .and. levels(gen) > 0 ) &
d4819 1
a4819 1
	       if ( toggle(gen) .and. levels(gen) > 0 ) &
d4831 1
a4831 1
	       if ( toggle(gen) .and. levels(gen) > 0 ) &
d4839 1
a4839 1
	       if ( toggle(gen) .and. levels(gen) > 0 )&
d4872 1
a4872 1
	        if ( toggle(gen) .and. levels(gen) > 0 ) &
d5108 1
a5108 1
	  if ( toggle(gen) .and. levels(gen) > 0 ) &
d5117 1
a5117 1
	  if ( toggle(gen) .and. levels(gen) > 0 ) &
d5368 1
a5368 1
      endif
d5428 1
a5428 1
      endif
d5450 1
a5450 1
      endif
d5565 1
a5565 1
      endif
d5626 1
a5626 1
        endif
d5795 1
a5795 1
      ! Two cases here, one where we have to interpolate verticall (has to be
a6746 1
      integer :: i
d6781 1
a6781 1
        endif
d7023 1
a7023 1
      ! Work out the horizontal mapping, a function of height for unstakced quantities.
d7270 239
a7508 1
    ! ----------------------------------------------- offsetradiancequantity ---
d7548 1
a7548 2
    subroutine ScaleOverlaps ( key, quantity, multiplierNode, dontMask )
      integer, intent(in) :: KEY        ! Tree node for command
d7793 1
a7793 1
       "$Id: Fill.f90,v 2.325 2006/03/13 23:42:37 pwagner Exp $"
d7804 3
@


2.325
log
@Added c=numeric type field to Fill via manipulation
@
text
@d6309 12
d6401 48
d7530 1
a7530 1
       "$Id: Fill.f90,v 2.323 2006/03/08 21:30:32 pwagner Exp $"
d7541 3
@


2.324
log
@Fixed a bug only NAG caught
@
text
@d16 3
d48 6
d78 1
a78 1
      & F_CENTERVERTICALLY, F_CHANNEL, F_COLUMNS, &
a159 2
    use MLSCommon, only: MLSFile_T, R4, R8, RM, RV, &
      & DEFAULTUNDEFINEDVALUE
d171 4
a174 3
    use MLSStringLists, only: catLists, PutHashElement, NumStringElements, &
      & StringElement, StringElementNum, switchDetail
    use MLSStrings, only: lowerCase
d330 1
d532 1
d790 3
d1465 1
a1465 1
            & manipulation, key, force )
d6023 2
a6024 1
    subroutine FillQuantityByManipulation ( quantity, a, b, manipulation, key, force )
d6032 1
d6044 1
a6044 1
      integer, parameter :: NO1WAYMANIPULATIONS = 5
d6050 1
d6058 1
d6060 1
d6068 1
d6072 3
a6074 1
      if ( .not. ( OneWay .or. TwoWay ) ) then
d6078 2
d6082 1
a6082 1
      if ( OneWay ) then
d6248 8
d6267 3
d6274 332
a6648 1
      use MLSCommon, only: DEFAULTUNDEFINEDVALUE
d7481 3
@


2.323
log
@Added new manipulations: a/b, 1/a, -a, abs(a), sign(a), log(a)
@
text
@d6217 1
a6217 1
            quantity%values = sign(1., a%values)
d6222 1
a6222 1
            quantity%values = sign(1., a%values)
d7105 1
a7105 1
       "$Id: Fill.f90,v 2.322 2006/02/21 19:16:10 pwagner Exp $"
d7116 3
@


2.322
log
@GetHashElement is now a generic
@
text
@d6019 2
a6020 2
      integer, parameter :: NOMANIPULATIONS = 7
      character(len=7), parameter :: VALIDMANIPULATIONS ( noManipulations ) = (/ &
d6027 9
a6035 1
        & 'a|b    ' /)
d6040 2
d6043 1
d6050 4
a6053 1
      if ( all ( mstr /= validManipulations ) ) then
d6059 14
a6072 4
      if ( .not. associated ( a ) .or. .not. associated ( b ) ) then
        call Announce_Error ( key, no_error_code, &
          & 'You must supply both the a and b quantities' )
        return
d6076 1
a6076 1
      do i = 1, 2
d6118 1
d6175 61
d7105 1
a7105 1
       "$Id: Fill.f90,v 2.321 2006/02/15 00:01:19 pwagner Exp $"
d7116 3
@


2.321
log
@Shoule let you fill H2O from new RHIvmr quantity
@
text
@d164 2
a165 2
    use MLSStringLists, only: catLists, MakeStringHashElement, NumStringElements, &
      & StringElement, StringElementNum
d1715 1
a1715 1
                call MakeStringHashElement( col_species_keys, col_species_hash, &
d3604 2
a3605 1
        printMe = (instance == useFirstInstance) .and. (index(switches, 'column') /= 0)
d3607 2
a3608 1
        if ( printMe ) print *, 'index(switches, column) ', index(switches, 'column')
d5606 1
a5606 1
        if ( index(switches, 'l1b') /= 0 ) &
d5721 2
a5722 2
      if ( index(switches,'mag') /= 0 ) &
        & call dump ( qty, clean=index(switches,'clean') /= 0 )
d7019 1
a7019 1
       "$Id: Fill.f90,v 2.320 2006/02/10 21:18:48 pwagner Exp $"
d7030 3
@


2.320
log
@Added code for wmoTropopause (unused); dumps may go to special dumpfile
@
text
@d1327 1
a1327 1
                & quantityType=(/l_rhi/)) ) then
d7017 1
a7017 1
       "$Id: Fill.f90,v 2.319 2006/01/11 17:04:32 pwagner Exp $"
d7028 3
@


2.319
log
@May specify unit when filling column abundances
@
text
@d43 1
d101 1
a101 1
      & L_COMBINECHANNELS, L_COLUMNABUNDANCE, L_DOBSONUNITS, &
d131 1
a131 1
    use Intrinsic, only: &
d136 1
a136 1
    use L2GPData, only: L2GPData_T
d154 1
a154 1
    use MLSL2Options, only: RESTARTWARNINGS
d164 1
a164 1
    use MLSStringLists, only: catLists, NumStringElements, &
d169 1
a169 1
    use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT
d339 1
d400 1
d501 2
d1701 1
a1701 1
              & any( colmabunits == (/l_dobsonUnits, l_molcm2/) ) ) then
d1709 15
d1898 9
a1906 2
          if ( .not. all(got( (/ f_temperatureQuantity, f_refGPHquantity, &
            & f_internalVGrid /) ))) &
d1908 1
a1908 5
            & 'wmoTropopause fill needs temperatureQuantity, refGPHQuantity ' // &
            & 'and internalVGrid' )
          if ( vGrids(internalVGridIndex)%verticalCoordinate /= l_zeta ) &
            & call Announce_Error ( key, No_Error_code, &
            &  'Vertical coordinate in internal vGrid is not log pressure' )
d1935 2
a1936 1
          call FillQtyWithWMOTropopause ( quantity, &
d1938 4
a1941 1

a2180 1
      call trace_end ( "MLSL2Fill" )
d2182 3
d3575 2
a5268 1
      ! & AzEl, whereNotFill, whereFill, FillValue, verbose )
a5282 4
      ! logical, intent(in), optional :: verbose       ! Print some extra stuff
      ! The next two determine which values to replace
      ! logical, intent(in), optional :: whereNotFill  ! only values /= FillValue
      ! logical, intent(in), optional :: whereFill     ! only values == FillValue
a5305 2
      ! logical :: mywhereFill
      ! logical :: mywhereNotFill
a5321 4
      ! mywhereFill = .false.
      ! mywhereNotFill = .false.
      ! if ( present(whereFill) ) mywhereFill = whereFill
      ! if ( present(whereNotFill) ) mywhereNotFill = whereNotFill
a5326 2
      ! myVerbose = .false.
      ! if ( present(verbose) ) myVerbose = verbose
d5432 1
a5432 2
!     integer                               :: fileID
      integer                               :: FLAG, NOMAFS
d5579 2
d5582 1
a5582 1
            & BO_stat%intField, myBOMask)
d6192 71
d7017 1
a7017 1
       "$Id: Fill.f90,v 2.318 2006/01/06 01:16:34 pwagner Exp $"
d7028 3
@


2.318
log
@silent boolean field can silence selected phases
@
text
@d91 1
a91 1
      & F_TYPE, F_USB, F_USBFRACTION, F_VECTOR, F_VMRQUANTITY, &
d100 1
a100 1
      & L_COMBINECHANNELS, L_COLUMNABUNDANCE, &
d109 1
a109 1
      & L_MANIPULATE, L_MAX, L_MEAN, L_MIN, L_NEGATIVEPRECISION, &
d323 1
d519 1
d1023 2
d1695 4
d1705 1
a1705 1
                & bndPressQty, vmrQty )
d3464 1
a3464 1
    subroutine FillColAbundance ( key, qty, bndPressQty, vmrQty, &
d3475 1
d3484 2
a3485 1
      real(r8), parameter :: INVERMG = INVERMGPPMV*1.d6 ! in DU / (vmr hPa)
d3503 1
a3503 1

d3543 9
a3551 1

d6927 1
a6927 1
       "$Id: Fill.f90,v 2.317 2006/01/05 03:48:17 vsnyder Exp $"
d6938 3
@


2.317
log
@Use Interp_Bilinear_2d_1d (as InterpolateValues)
@
text
@d28 3
a30 2
! MLSL2Fill (int root, l1binfo_t l1binfo, *griddedData_T GriddedDataBase(:),
!        *vectorTemplate_T VectorTemplates(:), &
d34 1
d155 1
a155 1
      & add_to_phase_timing, fillTimings, finishTimings
d157 1
a157 1
      & MLSMSG_Allocate, MLSMSG_Deallocate, MLSMessageReset
a410 1
    character(len=80) :: PHASESTRING    ! E.g., 'Core'
d2069 1
a2069 3
        call get_string(vectorname, phaseString)
        call add_to_phase_timing(trim(phaseString))
        if ( RESTARTWARNINGS ) call MLSMessageReset(Warnings=.true.)
d6909 1
a6909 1
       "$Id: Fill.f90,v 2.316 2006/01/05 00:04:45 vsnyder Exp $"
d6920 3
@


2.316
log
@Implement refractive correction for PhiTan fill, correct some error
messages and rephrase others to make sense.
@
text
@d3761 1
a3761 1
      use MLSNumerics, only: Hunt
d3775 1
a3775 1
      real(rp) :: PhiCorrs(temperature%template%noSurfs,temperature%template%noInstances)
d3778 1
a3778 4
      real(rv) :: Hphi, Hzeta ! Interpolating factors
      integer, dimension(size(quantity%values,1)) :: &
        & HuntPhi, HuntZeta
      integer :: I, IP, IZ, J ! Subscripts, loop inductors
d3827 1
a3827 1
      do j = 1, temperature%template%noInstances
d3831 2
a3832 2
        call Hydrostatic ( GeodToGeocLat ( temperature%template%geodLat(1,j) ), &
          & temperature%template%surfs(:,1), temperature%values(:,j), &
d3834 1
a3834 1
          & refGPH%template%surfs(1,1), 0.001*refGPH%values(1,j), &
d3836 1
a3836 1
        heights = heights + reqs(j)
d3838 3
a3840 3
        call refractive_index ( ps, temperature%values(:,j), n, h2o%values(:,j) )
        do i = 1, temperature%template%noSurfs
          call phi_refractive_correction_up ( n(i:), heights(i:), phiCorr(i:) )
d3849 3
a3851 17
        ! Hunt in zeta, phi grids
        call hunt ( h2o%template%phi(1,:), quantity%values(:,j), huntPhi )
        call hunt ( h2o%template%surfs(:,1), ptan%values(:,j), huntZeta )
        do i = 1, size(quantity%values,1)
          ! Interpolate from PhiCorr's (phi,zeta), which is the same as
          ! h2o's, to PhiTan's, using bilinear interpolation, and
          ! apply the interpolated correction.
          ip = huntPhi(i)
          iz = huntZeta(i)
          hPhi = (quantity%values(i,j)-h2o%template%phi(1,ip)) / &
                 (h2o%template%phi(1,ip+1)-h2o%template%phi(1,ip))
          hZeta = (ptan%values(i,j)-h2o%template%surfs(iz,1)) / &
                 (h2o%template%surfs(iz+1,1)-h2o%template%surfs(iz,1))
          quantity%values(i,j) = quantity%values(i,j) + &
            & (1.0-hZeta) * ((1.0-hphi)*phiCorrs(iz,ip) + hphi*phiCorrs(iz,ip+1)) + &
            & hZeta*((1.0-hphi)*phiCorrs(iz+1,ip) + hphi*phiCorrs(iz+1,ip+1))
        end do ! i
d4302 1
a4302 1
      integer ::                          S_H2OPrecision       ! Instance num for surfs
d4305 1
a4305 1
      integer ::                          S_TPrecision         ! Instance num for surfs
d4401 10
a4410 10
        if ( sourcePrecisionQuantity%template%coherent ) then
          s_h2oPrecision = 1
        else
          s_h2oPrecision = i
        end if
        if ( tempPrecisionquantity%template%coherent ) then
          s_tPrecision = 1
        else
          s_tPrecision = i
        end if
d5397 2
a5398 1
      integer                               :: fileID, FLAG, NOMAFS
d5415 1
a5415 1
      fileID = L1BFile%FileID%f_id
d6910 1
a6910 1
       "$Id: Fill.f90,v 2.315 2005/12/22 21:05:20 vsnyder Exp $"
d6921 4
@


2.315
log
@Use Hydrostatic_no_der (by way of generic)
@
text
@d16 1
a16 1
  ! This module performs the Fill operation in the Level 2 software.  
d33 1
a33 1
!        *mlSChunk_T Chunks(:), int ChunkNo )      
d37 1
a37 1
  private :: not_used_here 
d72 1
a72 1
      & F_IFMISSINGGMAO, F_IGNORENEGATIVE, F_IGNOREGEOLOCATION, F_IGNOREZERO, & 
a127 1
    use Intrinsic, only: FIELD_INDICES
d209 1
a209 1
    ! Error codes for "announce_error"  
d255 1
a255 1
    real, parameter ::    UNDEFINED_VALUE = DEFAULTUNDEFINEDVALUE 
d303 1
a303 1
    integer :: APRPRECQTYINDEX          ! Index of apriori precision quantity    
d363 1
a363 1
    logical :: IGNOREGEOLOCATION        ! Don't copy geolocation to vector qua 
d453 1
a453 1
    real :: T1, T2                      ! for timing 
d688 1
a688 1
            binName = sub_rosa ( subtree(2,gson) )  
d694 1
a694 1
          if ( got ( f_vector ) ) call Announce_Error ( key, 0, &
d699 1
a699 1
          if ( .not. got ( f_source ) ) call Announce_Error ( key, 0, &
d703 1
a703 1
          call Announce_Error ( key, 0, 'Must supply either matrix or vector to adopt' )
d705 2
a706 1
        if ( len_trim(message) /= 0 ) call Announce_Error ( key, 0, trim(message) )
d955 1
a955 1
            refGPHQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))    
d958 1
a958 1
            refGPHPrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))    
d963 1
a963 1
            sourceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))    
d1045 1
a1045 1
        
d1123 1
a1123 1
            & call Announce_Error ( key, 0, &
d1131 1
a1131 1
            & call Announce_Error ( key, 0, &
d1141 1
a1141 1
            & call Announce_Error ( key, 0, &
d1157 1
a1157 1
              & call Announce_Error ( key, 0, &
d1161 1
a1161 1
              & call Announce_Error ( key, 0, &
d1170 1
a1170 1
            & call Announce_Error ( key, 0, &
d1174 1
a1174 1
          if ( .not. got ( f_width ) ) call Announce_Error ( key, 0, &
d1181 1
a1181 1
            & call Announce_Error ( key, 0, &
d1186 1
a1186 1
          if ( message /= '' ) call Announce_Error ( key, 0, trim(message) )
d1216 2
a1217 1
            & call Announce_Error ( key, 0, 'Need sourceQuantity and channel for this fill' )
d1256 1
a1256 1
            & refGPHPrecisionQuantity )          
d1362 1
a1362 1
              & call Announce_Error ( key, 0, 'Needs phiTan quantity' )
d1366 1
a1366 1
              & call Announce_Error ( key, 0, 'Has a bad phiTan quantity' )
d1387 1
a1387 1
            & phiWindow, phiWindowUnits, chunkNo )          
d1424 1
a1424 1
                  & sourceQuantity, temperatureQuantity) 
d1430 1
a1430 1
            & call Announce_error ( key, 0 ,'aQuantity not supplied' )
d1432 1
a1432 1
            & call Announce_error ( key, 0 ,'manipulation not supplied' )
d1452 1
a1452 1
            call Announce_Error ( key, 0, 'Need gphQuantity for magnetic model' )
d1456 1
a1456 1
            call FillQuantityUsingMagneticModel ( quantity, gphQuantity, key )          
d1458 1
a1458 1
          
d1472 1
a1472 1
            & call Announce_error ( key, 0, 'radianceQuantity not supplied' )
d1498 1
a1498 1
            call Announce_error ( key, 0, 'profileValues not supplied' )
d1509 14
a1522 6
          if ( refract ) then 
            if ( .not. all ( got ( &
            & (/ f_temperatureQuantity, f_h2oQuantity, f_ptanQuantity /) ) ) ) &
            & call Announce_error ( key, badRefractFill )
            temperatureQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(temperatureVectorIndex), temperatureQuantityIndex)
d1525 2
d1529 6
a1534 4
          else
            temperatureQuantity => NULL()
            h2oQuantity => NULL()
            ptanQuantity => NULL()
a1535 2
          call FillPhiTanWithRefraction ( key, quantity, ptanQuantity, temperatureQuantity, &
            & h2oQuantity, refract )
d1633 1
a1633 1
            
d1817 1
a1817 1
          
d1900 1
a1900 1
            & 'Horizontal coordinates for temperature/refGPH and/or quanity disagree' )
d1909 1
a1909 1
          call Announce_error ( key, 0, 'This fill method not yet implemented' )
d2065 1
a2065 1
      
d2071 1
a2071 1
      
d2123 1
a2123 1
            if ( associated ( oneMatrix ) ) then 
d2236 1
a2236 1
        & call Announce_Error ( key, 0, &
d2239 1
a2239 1
        & call Announce_Error ( key, 0, &
d2243 1
a2243 1
        & call Announce_Error ( key, 0, &
d2246 1
a2246 1
      if ( quadrature ) then 
d2266 1
a2266 1
    subroutine deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)    
d2283 1
a2283 1
    end subroutine DeallocateStuff    
d2296 1
a2296 1
        & call announce_error ( key, 0, 'Quantity to fill must be of type singleChannelRadiance' )
d2298 1
a2298 1
        & call announce_error ( key, 0, 'source quantity for fill must be of type [cloudInduced]radiance' )
d2301 1
a2301 1
        & call announce_error ( key, 0, 'quantity/sourceQuantity must be same signal/sideband' )
d2303 1
a2303 1
        & call Announce_Error ( key, 0, 'source quantity must be regular' )
d2366 1
a2366 1
            & vectorNameText='_Lmasked' ) 
d2369 1
a2369 1
          
d2426 1
a2426 1
                  meanDiag = sqrt ( m(j,j) * m(k,k) ) 
d2456 1
a2456 1
              if ( anyOffDiag ) then 
d2561 1
a2561 1
      integer :: INSTANCE               ! Loop counter 
d2591 1
a2591 1
      if ( .not. interpolate ) then 
d2612 1
a2612 1
        
d2633 1
a2633 1
        
d2765 1
a2765 1
          & call Announce_error ( valuesNode, 0, 'Bad height units for profile fill' )
d2775 1
a2775 1
          & call Announce_error ( valuesNode, 0, 'Bad units for profile fill' )
d2781 1
a2781 1
        call Announce_Error ( valuesNode, 0, &
d2915 1
a2915 1
          ! First compute the tangent point velocity in ECI coordinates due 
d2980 1
a2980 1
          & call announce_error( 0, No_Error_code, &
d2990 1
a2990 1
          & call announce_error( 0, No_Error_code, &
d2993 1
a2993 1
          & call announce_error( 0, No_Error_code, &
d2996 1
a2996 1
          & call announce_error( 0, No_Error_code, &
d3056 1
a3056 1
      ! A special fill of chi squared 
d3188 1
a3188 1
      ! A special fill of chi squared 
d3326 1
a3326 1
      ! A special fill of chi squared 
d3708 1
a3708 1
        & call Announce_Error ( key, 0, 'Inappropriate radiance quantity to fill' )
d3711 1
a3711 1
        call Announce_Error ( key, 0, 'Must supply sidebands and fractions together' )
d3714 1
a3714 1
      if ( associated ( lsb ) ) then 
d3717 1
a3717 1
          & call Announce_Error ( key, 0, 'Inappropriate lsb radiance quantity for fill' )
d3721 1
a3721 1
          & call Announce_Error ( key, 0, 'Inappropriate lsbFraction quantity for fill' )
d3726 1
a3726 1
          & call Announce_Error ( key, 0, 'Inappropriate usb radiance quantity for fill' )
d3730 1
a3730 1
          & call Announce_Error ( key, 0, 'Inappropriate usbFraction quantity for fill' )
d3734 1
a3734 1
        & call Announce_Error ( key, 0, 'Must supply one or both of lsb/usb' )
d3754 28
a3781 8
    subroutine FillPhiTanWithRefraction ( key, quantity, ptanQuantity, &
      & temperatureQuantity, h2oQuantity, refract )
      integer, intent(in) :: KEY          ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! PhiTan quantity to fill
      type (VectorValue_T), pointer :: PTANQUANTITY ! Ptan for same module
      type (VectorValue_T), pointer :: TEMPERATUREQUANTITY ! Temperature
      type (VectorValue_T), pointer :: H2OQUANTITY ! Water vapor
      logical, intent(in) :: REFRACT      ! Do refraction or not
d3784 66
a3849 20
      ! First check sanity
      if ( .not. ValidateVectorQuantity ( quantity, &
        & quantityType=(/l_phiTan/), minorFrame=.true. ) ) &
        & call Announce_error ( key, 0, 'Quantity to fill is not phiTan' )
      if ( refract ) then
        ! More sanity checks
        if ( .not. ValidateVectorQuantity ( ptanQuantity, &
          & quantityType=(/l_ptan/), minorFrame=.true. ) ) &
          & call Announce_error ( key, 0, 'Problem with ptan quantity for phiTan fill' )
        if ( quantity%template%instrumentModule /= &
          &  ptanQuantity%template%instrumentModule ) &
          & call Announce_error ( key, 0, 'phiTan and ptan quantities not for same module' )
        if ( .not. ValidateVectorQuantity ( temperatureQuantity, &
          & quantityType=(/l_temperature/), coherent=.true., stacked=.true., &
          & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
          & call Announce_error ( key, 0, 'Problem with temperature quantity for phiTan fill' )
        if ( .not. ValidateVectorQuantity ( h2oQuantity, &
          & quantityType=(/l_vmr/), molecule=(/l_h2o/), coherent=.true., stacked=.true., &
          & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
          & call Announce_error ( key, 0, 'Problem with temperature quantity for phiTan fill' )
d3851 19
a3869 6
        ! OK, do the refraction calculation
        call Announce_error ( key, 0, 'Refract=true, not yet supported' )
      else
        ! Just copy it from the template
        quantity%values = quantity%template%phi
      end if
d3882 1
a3882 1
      real (r8), dimension(Temperaturequantity%template%noSurfs,quantity%template%noInstances) :: temp 
d3889 1
a3889 1
     
d3910 16
a3925 16
      if ( quantity%template%verticalCoordinate == l_pressure ) then 
        z = -log10 ( quantity%template%surfs(:,1) )             
      else                                                           
        z = quantity%template%surfs(:,1)            
      end if
      
      if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then 
        ze = -log10 ( sourceQuantity%template%surfs(:,1) )             
      else                                                           
        ze = sourceQuantity%template%surfs(:,1)            
      end if
      
      if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then 
        zt = -log10 ( Temperaturequantity%template%surfs(:,1) )             
      else                                                           
        zt = Temperaturequantity%template%surfs(:,1)    
d3927 1
a3927 1
        
d3934 3
a3936 3
        ! McFarquhar and Heymsfield [1996] 
        ! 
        iwc0 = 10**(-2.77+0.01*(Tz-273.15))  
d3939 1
a3939 1
        
d3943 2
a3944 2
    end subroutine FillIWCFromExtinction 
    
d3952 1
a3952 1
      !  humidity measurement: Method and validation" Read et. al. 
d3980 3
a3982 3
      integer ::                          Channel     ! Channel loop counter    
      integer ::                          Chan_h2o    ! Channel loop counter    
      integer ::                          Chan_T      ! Channel loop counter    
d3989 2
a3990 2
      integer ::                          QINDEX                                
      integer ::                          N           ! Num. of summed values   
d3997 1
a3997 1
      integer ::                          S           ! Surface loop counter    
d4001 1
a4001 1
      logical ::                          skipMe                                
d4091 2
a4092 2
        if ( quantity%template%verticalCoordinate == l_pressure ) then 
          zeta = -log10 ( quantity%template%surfs(:,s_rhi) )             
d4094 1
a4094 1
          zeta = quantity%template%surfs(:,s_rhi)                        
d4106 9
a4114 9
        if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then 
          zetah2o = -log10 ( sourceQuantity%template%surfs(:,s_h2o) )             
        else                                                           
          zetah2o = sourceQuantity%template%surfs(:,s_h2o)            
        end if
        if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then 
          zetaTemperature = -log10 ( Temperaturequantity%template%surfs(:,s_T) )             
        else                                                           
          zetaTemperature = Temperaturequantity%template%surfs(:,s_T)            
d4259 1
a4259 1
      !  humidity measurement: Method and validation" Read et. al. 
d4292 5
a4296 5
      integer ::                          Channel     ! Channel loop counter    
      integer ::                          Chan_h2oPrecision    ! Channel loop counter    
      integer ::                          Chan_TPrecision      ! Channel loop counter    
      integer ::                          Chan_h2o    ! Channel loop counter    
      integer ::                          Chan_T      ! Channel loop counter    
d4314 1
a4314 1
      integer ::                          N           ! Num. of summed values   
d4316 1
a4316 1
      integer ::                          QINDEX                                
d4318 1
a4318 1
      integer ::                          S           ! Surface loop counter    
d4324 1
a4324 1
      logical ::                          skipMe                                
d4439 2
a4440 2
        if ( quantity%template%verticalCoordinate == l_pressure ) then 
          zeta = -log10 ( quantity%template%surfs(:,s_rhi) )             
d4442 1
a4442 1
          zeta = quantity%template%surfs(:,s_rhi)                        
d4464 19
a4482 19
        if ( sourcePrecisionQuantity%template%verticalCoordinate == l_pressure ) then 
          zetah2oPrecision = -log10 ( sourcePrecisionQuantity%template%surfs(:,s_h2o) )             
        else                                                           
          zetah2oPrecision = sourcePrecisionQuantity%template%surfs(:,s_h2o)            
        end if
        if ( TempPrecisionquantity%template%verticalCoordinate == l_pressure ) then 
          zetaTempPrecision = -log10 ( TempPrecisionquantity%template%surfs(:,s_T) )             
        else                                                           
          zetaTempPrecision = TempPrecisionquantity%template%surfs(:,s_T)            
        end if
        if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then 
          zetah2o = -log10 ( sourceQuantity%template%surfs(:,s_h2o) )             
        else                                                           
          zetah2o = sourceQuantity%template%surfs(:,s_h2o)            
        end if
        if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then 
          zetaTemperature = -log10 ( Temperaturequantity%template%surfs(:,s_T) )             
        else                                                           
          zetaTemperature = Temperaturequantity%template%surfs(:,s_T)            
d4671 1
a4671 1
      if ( associated ( nbw ) ) then 
d4836 1
a4836 1
      real(r8) :: scaledRad   ! scaled radiance according to the f^4 law 
d4844 1
a4844 1
        & call Announce_Error ( key, 0, 'Quantity must be cloud-induced-radiances to fill' )
d4846 1
a4846 1
        & call Announce_Error ( key, 0, 'Quantity must be a subset to fill' )
d4882 1
a4882 1
          & call Announce_Error ( key, 0, 'Inappropriate sourceQuantity radiance for fill' )
d4898 1
a4898 1
        ! The source cloudy radiance must be from the same signal of double sideband 
d4903 1
a4903 1
          & call Announce_Error ( key, 0, 'Inappropriate sourceQuantity radiance for fill' )
d4907 1
a4907 1
          & call Announce_Error ( key, 0, 'Inappropriate lsbFraction quantity for fill' )
d4911 1
a4911 1
          & call Announce_Error ( key, 0, 'Inappropriate usbFraction quantity for fill' )
d4913 2
a4914 2
        ! This method is only appliable to the cloud-induced radiances. One may assume 
        ! that the scattering radiances are proportional to f^4. And this operation 
d4939 2
a4940 2
          ! optically-thick sideband. The reference radiance must be a single sideband 
          ! radiance in this case, namely usb (upper sideband in most cases). The usb is 
d4949 1
a4949 1
            & minorFrame=.true. )) call Announce_Error ( key, 0, &
d4959 1
a4959 1
          freq = signalRef%centerFrequency + signalRef%direction*signalRef%frequencies 
d4967 1
a4967 1
            if ( quantity%template%sideband == 1 ) then 
d4987 1
a4987 1
                    &  ratio1*scaledRad)/ratio2 
d5050 1
a5050 1
        call Announce_error ( 0, 0, 'GPH precision needed for result of FillGPHPrecision' )
d5106 1
a5106 1
      else 
d5141 1
a5141 1
      if ( status /= 0 ) then 
d5147 1
a5147 1
      if ( status /= 0 ) then 
d5152 1
a5152 1
      if ( present ( badRange ) ) then 
d5155 1
a5155 1
          & quantity%values <= badRange(2) ) 
d5176 1
a5176 1
      
d5216 1
a5216 1
              ! radiative transfer Physics is symmetric.  We save half of l2pc bins. 
d5231 1
a5231 1
            
d5296 1
a5296 1
      
d5432 1
a5432 1
      
d5656 1
a5656 1
        call Announce_Error ( key, 0, &
d5662 1
a5662 1
        call Announce_Error ( key, 0, &
d5667 1
a5667 1
        call Announce_Error ( key, 0, &
d5672 1
a5672 1
        call Announce_Error ( key, 0, &
d5739 2
a5740 2
        ! These checks are for cases the code can't (yet) handle, 
        ! may add this functionality later. 
d5765 1
a5765 1
        
d5777 1
a5777 1
        
d5791 1
a5791 1
        
d5798 1
a5798 1
        
d5805 1
a5805 1
        ! No interpolation needed, more like the 
d5831 1
a5831 1
      integer, intent(in) :: key          ! For messages    
d5880 1
a5880 1
        ds = sLevel(2)-sLevel(1)  
d5893 1
a5893 1
            call InterpolateValues(sLevel,y_in,sFine,TransFine,method='Linear')  
d5932 1
a5932 1
      do maf=1,noMAFs  
d5961 1
a5961 1
          ! interpolate phi onto standard vertical grids     
d5964 1
a5964 1
          ! interpolate quantity to standard vertical grids      
d5969 1
a5969 1
          do i=minZ,maxZ  
d5971 1
a5971 1
              if ( phi_out(i) .lt. &     
d5973 1
a5973 1
                & .and. phi_out(i) .ge. &  
d6018 1
a6018 1
        call Announce_Error ( key, 0, 'Invalid manipulation' )
d6024 1
a6024 1
        call Announce_Error ( key, 0, &
d6038 1
a6038 1
        
d6061 1
a6061 1
        
d6063 1
a6063 1
          call Announce_Error ( key, 0, &
d6174 1
a6175 1
      use Geometry, only: GEODTOGEOCLAT
d6198 1
a6198 1
      
d6212 1
a6212 1
      
d6216 1
a6216 1
      
d6224 1
a6224 1
      ! If we are strict we'd only ever give the one of our basis points as 
d6253 1
a6253 1
        ! Note while much of the software thinks in meters.  The hydrostatic
d6260 1
a6260 1
        
d6320 1
a6320 1
      ! This fills a coherent quantity with the max/min binned value of 
d6348 1
a6348 1
        & call Announce_Error ( key, 0, &
d6362 1
a6362 1
          & call Announce_Error ( key, 0, &
d6367 1
a6367 1
          & call Announce_Error ( key, 0, &
d6378 1
a6378 1
      ! Work out the vertical mapping, a function of instance for 
d6420 1
a6420 1
      
d6425 1
a6425 1
        call Announce_Error ( key, 0, &
d6431 1
a6431 1
     
d6510 1
a6510 1
        call Announce_Error ( key, 0, 'Quantity and source quantity do not match' )
d6514 1
a6514 1
        call Announce_Error ( key, 0, 'width must be greater than 1 and odd' )
d6583 1
a6583 1
          & call Announce_Error ( key, 0, 'Bad vertical coordinate for sourceQuantity' )
d6807 1
d6825 1
a6825 1
        call output ( " missing information for estimated noise fill", advance='yes' )
d6829 1
a6829 1
        call output ( " incomplete/incorrect information for los Grid fill", advance='yes' )
d6831 1
a6831 1
        call output ( " incomplete/incorrect information for los velocity", advance='yes' )
d6833 1
a6833 1
        call output ( " incomplete/incorrect information for isotope fill", advance='yes' )
d6837 1
a6837 1
        call output ( " missing information for phiTan refract fill", advance='yes' )
d6841 1
a6841 1
        call output ( " specified both fraction and lengthScale", advance='yes' )
d6847 1
a6847 1
        call output ( " cannot interpolate 3d quantities (yet).", advance='yes' )
d6849 1
a6849 1
        call output ( " an empty grid for the fill", advance='yes' )
d6858 1
a6858 1
        call output ( " missing/bad data points in grid for fill", advance='yes' )
d6862 1
a6862 1
          call display_string ( field_indices(i) )
d6871 1
a6871 1
        call output ( " needs geocAltitudeQuantity.", advance='yes' )
d6873 1
a6873 1
        call output ( " needs H2OQuantity.", advance='yes' )
d6875 1
a6875 1
        call output ( " needs OrbitalInclination.", advance='yes' )
d6878 1
d6880 1
a6880 1
        call output ( " no explicit values given for explicit fill.", advance='yes' )
d6884 1
a6884 1
        call output ( " no sourceGrid field given for gridded fill.", advance='yes' )
d6886 1
a6886 1
        call output ( " no sourceL2AUX field given for L2AUX fill.", advance='yes' )
d6888 1
a6888 1
        call output ( " no sourceL2GP field given for L2GP fill.", advance='yes' )
d6890 1
a6890 1
        call output ( " invalid special fill", advance='yes' )
d6893 1
a6893 1
        call output ( " is not implemented yet.", advance='yes' )
d6895 1
a6895 1
        call output ( " is not a SPD matrix.", advance='yes' )
d6897 1
a6897 1
        call output ( " is not a plain matrix.", advance='yes' )
d6916 3
a6918 3
      if ( present(ExtraMessage) ) then
        call output(ExtraMessage, advance='yes')
      end if
d6926 1
a6926 1
       "$Id: Fill.f90,v 2.314 2005/11/17 20:12:51 pwagner Exp $"
d6937 3
@


2.314
log
@Can now read BO_stat successfully
@
text
@d6098 1
a6098 3
      real(rv), dimension(grid%noSurfs) :: DUMMYT ! Extra arg. for hydrostatic
      real(rv), dimension(grid%noSurfs) :: DUMMYDHDZ ! Extra arg. for hydrostatic
      real(rv), dimension(grid%noSurfs,grid%noSurfs) :: DUMMYDHDT ! Extra arg. for hydrostatic
d6162 1
a6162 2
          & refGPH%template%surfs(1,1), refGPH%values(1,i), &
          & dummyT, hFine, dummyDHDT, dummyDHDZ )
d6834 1
a6834 1
       "$Id: Fill.f90,v 2.313 2005/11/15 00:21:12 pwagner Exp $"
d6845 3
@


2.313
log
@Removed space between Is and Precision
@
text
@d756 1
a756 1
            call get_string( gson, extraObjects, strip=.true. )
d5321 5
a5325 5
      type (l1bData_T) :: BO_stat
      character (len=132) :: MODULENAMESTRING
      character (len=132) :: NAMESTRING
      integer :: fileID, FLAG, NOMAFS
      type (l1bData_T) :: L1BDATA
d5327 4
a5330 3
      integer :: ROW, COLUMN
      integer :: myBOMask
      integer :: this_hdfVersion
d5339 1
d5411 1
a5411 1
        call ReadL1BData ( L1BFile, moduleNameString, BO_stat, noMAFs, flag, &
d6837 1
a6837 1
       "$Id: Fill.f90,v 2.312 2005/11/11 21:49:41 pwagner Exp $"
d6848 3
@


2.312
log
@May set l1b precisions negative if avoidBrightObjects set
@
text
@a5326 1
      type (MLSFile_T), pointer             :: L1BOAFile
d5405 1
a5405 1
      if ( is Precision .and. myBOMask /= 0 ) then
d5468 1
a5468 1
        if ( is Precision .and. myBOMask /= 0 ) then
d6835 1
a6835 1
       "$Id: Fill.f90,v 2.311 2005/10/18 16:56:43 pwagner Exp $"
d6846 3
@


2.311
log
@Negative RHIPrecision when either T or H2O Precisions are
@
text
@d59 1
d63 5
a67 2
      & F_APRIORIPRECISION, F_B, F_BADRANGE, F_BASELINEQUANTITY, F_BIN, F_BOUNDARYPRESSURE, F_BOXCARMETHOD, &
      & F_CENTERVERTICALLY, F_CHANNEL, F_COLUMNS, F_DESTINATION, F_DIAGONAL, F_dontMask,&
d162 3
d308 1
d315 2
d328 1
d361 1
d401 1
d737 2
a738 1

d755 3
d1271 14
a4130 2


a4131 1

a5306 1
    ! subroutine FillVectorQuantityFromL1B ( root, quantity, chunk, l1bInfo, &
d5308 2
a5309 1
      & isPrecision, suffix, PrecisionQuantity )
a5314 1
      ! type( L1BInfo_T ), intent(in) :: L1BINFO
d5318 2
a5319 1

d5321 2
d5326 2
d5329 1
a5330 1
      type (MLSFile_T), pointer             :: L1BFile
d5333 2
a5334 1

d5341 1
a5341 21
!       fileID=l1bInfo%l1bOAID
!       if ( quantity%template%quantityType /= l_radiance ) then
!         filenamestring = l1bInfo%L1BOAFileName
!       else
!         if ( .not. associated(l1bInfo%L1BRADFilenames) ) then
!           call Announce_Error ( root, No_Error_code, &
!             & 'No radiances files to read from' )
!           return
!         else
!           filenamestring = l1bInfo%L1BRADFileNames(1)
!         end if
!       end if
!       this_hdfVersion = mls_hdf_version(trim(filenamestring), LEVEL1_HDFVERSION)
!       if ( this_hdfVersion == ERRORINH5FFUNCTION ) then
!         call Announce_Error ( root, No_Error_code, &
!           & 'Error in finding hdfversion of l1b file' )
!       else if ( this_hdfVersion == WRONGHDFVERSION ) then
!         call Announce_Error ( root, No_Error_code, &
!           & 'Wrong hdfversion declared/coded for l1b file' )
!       end if

d5405 11
d5435 1
a5435 1
        call ReadL1BData ( L1BFile , nameString, l1bData, noMAFs, flag, &
d5469 6
d6836 1
a6836 1
       "$Id: Fill.f90,v 2.310 2005/09/21 23:21:58 pwagner Exp $"
d6847 3
@


2.310
log
@Use of single arg options in ExplicitFillVectorQuantity replaces three
@
text
@a181 1
!   use VectorsModule, only: rmVectorFromDatabase
a1581 11
                ! This is not the right way to do an invert fill
                ! The first quantity named on the fill line must
                ! _always_ be the one getting filled according to
                ! the pattern '[verb] [direct-object] [modifier(s)]'
                ! see case l_vmr below for how to do this
                !else if ( invert ) then
                !  call FillRHIFromH2O ( key, h2oquantity, &
                  !  & Quantity, temperatureQuantity, &
                !  & dontMask, ignoreZero, ignoreNegative, interpolate, &
                  !  & .true., &   ! Mark Undefined values?
                !  & invert )    ! invert rather than convert?
a1747 3
!             if ( MissingGMAO ) call FillStatusQuantity ( key, quantity, &
!               & sourceQuantity, statusValue, &
!               & 0._r8, 0._r8, heightNode, additional )
a1770 3
            ! if ( .not. ifMissingGMAO .or. APrioriFiles%dao // AprioriFiles%ncep == ' ') &
            !  & call FillStatusQuantity ( key, quantity, sourceQuantity, statusValue, &
            !  & minValue, maxValue, heightNode, additional )
d2252 1
a2252 1
      ! Exectuable code
a3414 1
    ! subroutine FillColAbundance_idl ( key, qty, bndPressQty, vmrQty, &
a3503 1
      ! call allocate_test ( Zetaa, vmrQty%template%noSurfs, 'Zetaa', ModuleName )
a3505 1
      ! call allocate_test ( Zetad, vmrQty%template%noSurfs, 'Zetad', ModuleName )
a3506 1
      ! call allocate_test ( pa, vmrQty%template%noSurfs, 'pa', ModuleName )
a3508 1
      ! call allocate_test ( pd, vmrQty%template%noSurfs, 'pd', ModuleName )
a3850 1
  !   type (VectorValue_T), intent(in) :: refGPHQuantity ! zeta
a4100 17
      ! Properly belongs in FillRHIFromH2O, but that would make two levels
! >       function C ( T )
! >         ! As found in ref.
! >         real(r8), intent(in)   :: T
! >         real(r8)               :: C
! >         ! Local
! >         real(r8), parameter    :: a0 = -1.2141649d0
! >         real(r8), parameter    :: a1 = 9.09718d0
! >         real(r8), parameter    :: a2 = 0.876793d0
! >         real, parameter        :: ILLEGALTEMP = UNDEFINED_VALUE
! >         !
! >         if ( T > 0.d0 ) then
! >           C = a0 - a1*(273.16/T -1.0d0) + a2*(1.0d0 - T/273.16)
! >         else
! >           C = ILLEGALTEMP
! >         end if
! >       end function C
d4156 3
a4165 1
  !   type (VectorValue_T), intent(in) :: refGPHQuantity ! zeta
a4185 3
      integer ::                          invs        ! 1 if invert, else -1
      integer ::                          QINDEX                                
      integer ::                          N           ! Num. of summed values   
d4196 4
a4206 2
!     real (r8) ::                        TPrecision
!     real (r8) ::                        T
a4209 3
!     real (r8) ::                        df_db       ! RHi deriv wrt H2O
!     real (r8) ::                        df_dT       ! RHi deriv wrt T
      real (r8) ::                        rhi_precision
a4231 5
!!$      if ( invert ) then
!!$        invs = 1
!!$      else
        invs = -1
!!$      end if
a4460 7
!!$            skipMe = skipMe .or. &
!!$            & .not. dontMask .and. ( &
!!$            & (ignoreNegative .and. H2OPrecisionofZeta(s) < 0.0 ) &
!!$            & .or. (ignoreZero .and. H2OPrecisionofZeta(s) == 0.0 ) &
!!$            & .or. (ignoreNegative .and. H2OofZeta(s) < 0.0 ) &
!!$            & .or. (ignoreZero .and. H2OofZeta(s) == 0.0 ) &
!!$            & )
d4464 1
a4464 17
!               T = TofZeta(s)
!               df_db = exp(invs*( &
!                & (C(T)+zeta(qIndex)+vmr_unit_cnv) * log(10.) &
!                & + &
!                & 3.56654*log(T/273.16) &
!                & ))
!               df_dT = H2OofZeta(s) * exp(invs*( &
!                & (C(T)+zeta(qIndex)+vmr_unit_cnv) * log(10.) &
!                & + &
!                & 3.56654*log(T/273.16) &
!                & )) &
!                & * invs * ( dC_dT(T) * log(10.) + 3.56654 / T )
!               Quantity%values(qIndex, i) = sqrt (&
!                & ( H2OPrecisionofZeta(s) * df_db )**2 &
!                & + ( TPrecisionofZeta(s) * df_dT )**2 &
!                & )
              call RHIPrecFromH2O(H2OofZeta(s), &
d4467 1
a4467 1
               & rhi_precision)
a4501 21

      ! Properly belongs in FillRHIPrecisionFromH2O, but that would make two levels
!       function dC_dT ( T )
!         ! As found in ref.
!         real(r8), intent(in)   :: T
!         real(r8)               :: dC_dT
!         ! Local
!         real(r8), parameter    :: a0 = -1.2141649d0
!         real(r8), parameter    :: a1 = 9.09718d0
!         real(r8), parameter    :: a2 = 0.876793d0
!         real, parameter        :: ILLEGALTEMP = UNDEFINED_VALUE
!         !
!         if ( T > 0.d0 ) then
!           dC_dT = a1*(273.16/T**2) - a2/273.16
! !!$          C = a0 - a1*(273.16/T -1.0d0) + a2*(1.0d0 - T/273.16)
!         else
!           dC_dT = ILLEGALTEMP
! !!$          C = ILLEGALTEMP
!         end if
!       end function dC_dT

d6806 1
a6806 1
       "$Id: Fill.f90,v 2.309 2005/08/04 03:28:50 vsnyder Exp $"
d6817 3
@


2.309
log
@Correct fill for goofy L1BMIF_TAI, lots of cannonball polishing
@
text
@d1759 1
a1759 1
              & valuesNode, .true., phyq_Invalid, .true., verbose=.true. )
d5211 2
a5212 1
      & AzEl, whereNotFill, whereFill, FillValue, verbose )
d5227 1
a5227 1
      logical, intent(in), optional :: verbose       ! Print some extra stuff
d5229 2
a5230 2
      logical, intent(in), optional :: whereNotFill  ! only values /= FillValue
      logical, intent(in), optional :: whereFill     ! only values == FillValue
d5232 8
d5247 1
a5247 3
      logical :: myVerbose
      logical :: mywhereFill
      logical :: mywhereNotFill
d5251 1
d5253 3
a5255 1
      real (r8), pointer, dimension(:) :: VALUES
d5261 2
d5272 5
a5276 5
      mywhereFill = .false.
      mywhereNotFill = .false.
      if ( present(whereFill) ) mywhereFill = whereFill
      if ( present(whereNotFill) ) mywhereNotFill = whereNotFill
      if ( mywhereFill ) then
d5278 1
a5278 1
      elseif ( mywhereNotFill ) then
d5281 3
a5283 2
      myVerbose = .false.
      if ( present(verbose) ) myVerbose = verbose
d5336 1
a5336 1
      if ( myVerbose ) then
d5361 1
a5361 1
      if ( myVerbose ) then
d6898 1
a6898 1
       "$Id: Fill.f90,v 2.308 2005/08/03 18:09:38 vsnyder Exp $"
d6909 3
@


2.308
log
@Cannon ball polishing, scan averaging
@
text
@d56 1
a56 1
    use Expr_M, only: EXPR, GetIndexFlagsFromList
d206 2
a207 8
    integer, parameter :: Wrong_Number = No_Error_code+1     ! of fields of a VECTOR command
    integer, parameter :: UnknownQuantityName = wrong_number + 1
    integer, parameter :: Source_not_in_db = unknownQuantityName + 1
    integer, parameter :: ZeroProfilesFound = source_not_in_db + 1
    integer, parameter :: ZeroGeodSpan = zeroProfilesFound + 1
    integer, parameter :: CantFillFromL2AUX = ZeroGeodSpan + 1
    integer, parameter :: VectorWontMatchPDef = cantFillFromL2AUX + 1
    integer, parameter :: CantFillFromL1B = vectorWontMatchPDef + 1
d213 2
a214 6
    integer, parameter :: NumInstancesisZero = missingField + 1
    integer, parameter :: NumSurfsisZero = numInstancesisZero + 1
    integer, parameter :: NumChansisZero = numSurfsisZero + 1
    integer, parameter :: ObjIsFullRank3 = numChansisZero + 1
    integer, parameter :: OtherErrorInFillVector = objIsFullRank3 + 1
    integer, parameter :: NoSourceGridGiven= otherErrorInFillVector + 1
d218 2
a219 8
    integer, parameter :: NoSourceQuantityGiven= noExplicitValuesGiven + 1
    integer, parameter :: InvalidExplicitFill= noSourceQuantityGiven + 1
    integer, parameter :: BadUnitsForExplicit= invalidExplicitFill + 1
    integer, parameter :: BadUnitsForIntegrationTime = badUnitsForExplicit + 1
    integer, parameter :: BadUnitsForStatus = badUnitsForIntegrationTime + 1
    integer, parameter :: BadUnitsForSystemTemperature = badUnitsForStatus + 1
    integer, parameter :: BadUnitsForWidth = badUnitsForSystemTemperature + 1
    integer, parameter :: BadIsotopeFill = badUnitsForWidth + 1
d222 1
d225 1
a225 1
    integer, parameter :: NotSPD = CantInterpolate3D + 1
a229 10
    ! Error codes resulting from squeeze
    integer, parameter :: N1_is_zero = BothFractionAndLength + 1
    integer, parameter :: N2_is_zero = n1_is_zero + 1
    integer, parameter :: N3_is_zero = n2_is_zero + 1
    integer, parameter :: M1_too_small = n3_is_zero + 1
    integer, parameter :: M2_too_small = m1_too_small + 1
    integer, parameter :: Not_permutation = m2_too_small + 1
    integer, parameter :: Allocation_err = not_permutation + 1
    integer, parameter :: Deallocation_err = allocation_err + 1

d231 1
a231 1
    integer, parameter :: Miscellaneous_err = deallocation_err + 1
d237 1
a237 2
    integer, parameter :: NeedGeodAltitude = needGeocAltitude + 1
    integer, parameter :: BadGeocAltitudeQuantity = needGeodAltitude + 1
d241 1
a241 2
    integer, parameter :: BadUnitsForMaxIterations = nonConformingHydrostatic + 1
    integer, parameter :: NoSpecialFill = badUnitsForMaxIterations + 1
d456 1
d757 4
a760 4
            call expr ( gson , unitAsArray, valueAsArray )
            if ( all ( unitAsArray /= (/PHYQ_Dimensionless, PHYQ_Invalid/) ) ) &
              call Announce_error ( key, no_error_code, &
              & 'Channel should be dimensionless' )
d776 1
a776 1
            valuesNode=subtree(j,key)
d816 4
a819 3
            call expr ( gson , unitAsArray, valueAsArray )
            if ( all (unitAsArray /= (/PHYQ_Time, PHYQ_Invalid/) ) ) &
              call Announce_error ( key, badUnitsForIntegrationtime )
d845 4
a848 3
            call expr ( subtree(2,subtree(j,key)), unitAsArray,valueAsArray )
            if ( all(unitAsArray(1) /= (/PHYQ_Dimensionless,PHYQ_Invalid/)) ) &
              & call Announce_error ( key, badUnitsForMaxIterations )
d851 1
a851 1
            call expr ( subtree(2,subtree(j,key)), unitAsArray,valueAsArray )
d860 1
a860 1
            call expr ( subtree(2,subtree(j,key)), unitAsArray,valueAsArray )
d869 4
a872 3
            call expr ( subtree(2,subtree(j,key)), unitAsArray,valueAsArray )
            if ( all(unitAsArray(1) /= (/PHYQ_Dimensionless,PHYQ_Invalid/)) ) &
              & call Announce_error ( key, badUnitsForMaxIterations )
d878 4
a881 4
            call expr ( subtree(2,subtree(j,key)), unitAsArray, valueAsArray )
            if ( unitAsArray(1) /= PHYQ_Temperature ) &
              & call Announce_error ( key, No_Error_code, &
              & 'Bad units for offsetAmount' )
d892 4
a895 4
            call expr ( subtree(2,subtree(j,key)), unitAsArray, valueAsArray )
            if ( unitAsArray(1) /= PHYQ_Dimensionless ) &
              & call Announce_error ( key, No_Error_code, &
              & 'Bad units for precisionFactor' )
d898 4
a901 3
            call expr ( gson , unitAsArray, valueAsArray )
            if ( all (unitAsArray /= (/PHYQ_Dimensionless, PHYQ_Invalid/) ) ) &
              call Announce_error ( key, 0, 'Bad units for profile' )
d912 4
a915 1
            call expr ( gson, unitAsArray, valueAsArray )
a916 2
            if ( all ( unitAsArray(1) /= (/ PHYQ_Profiles, PHYQ_Angle /) ) ) &
              call Announce_Error ( key, 0, 'Bad units for phiWindow' )
d919 4
a922 1
            call expr ( gson, unitAsArray, valueAsArray )
a923 2
            if ( all ( unitAsArray(1) /= (/ PHYQ_Angle /) ) ) &
              call Announce_Error ( key, 0, 'Bad units for phiZero' )
d949 4
a952 1
            call expr ( gson, unitAsArray, valueAsArray )
a953 2
            if ( unitAsArray(1) /= PHYQ_Dimensionless ) &
              call Announce_Error ( key, 0, 'Bad units for scale' )
d982 5
a986 4
            valuesNode=subtree(j,key)
            call expr ( gson , unitAsArray, valueAsArray )
            if ( unitAsArray(1) /= PHYQ_Dimensionless ) &
              call Announce_error ( key, badUnitsForStatus )
d1018 4
a1021 3
            call expr ( gson , unitAsArray, valueAsArray )
            if ( unitAsArray(1) /= PHYQ_Dimensionless ) &
              call Announce_error ( key, badUnitsForWidth )
d1243 1
a1243 1
            & call Announce_Error ( key,noSourceGridGiven )
d1310 1
a1310 1
            call Announce_Error ( key,needTempREFGPH )
d2020 4
a2023 4
            call expr ( gson, unitAsArray, valueAsArray )
            if ( unitAsArray(1) /= PHYQ_Dimensionless ) &
              & call Announce_error ( key, No_Error_code, &
              & 'Bad units for precisionFactor' )
d5292 4
a5295 5
          call expr(subtree(k+1,valuesNode),unitAsArray,valueAsArray)
          ! Check unit OK
          if ( (unitAsArray(1) /= testUnit) .and. &
            &  (unitAsArray(1) /= PHYQ_Dimensionless) ) &
            & call Announce_error ( valuesNode, badUnitsForExplicit )
d5301 4
a5304 6
          call expr(subtree(k+1,valuesNode),unitAsArray,valueAsArray)
          ! Check unit OK
          if ( (unitAsArray(1) /= testUnit) .and. &
            &  (unitAsArray(1) /= PHYQ_Dimensionless) ) &
            & call Announce_error ( valuesNode, badUnitsForExplicit, &
              & extraInfo = (/ testUnit, PHYQ_Dimensionless /) )
d5307 4
a5310 5
          call expr(subtree(k+2,valuesNode),unitAsArray,valueAsArray)
          ! Check unit OK
          if ( unitAsArray(1) /= PHYQ_Angle ) &
            & call Announce_error ( valuesNode, badUnitsForExplicit, &
              & extraInfo = (/ PHYQ_Angle /) )
d5312 4
a5315 5
          call expr(subtree(k+3,valuesNode),unitAsArray,valueAsArray)
          ! Check unit OK
          if ( unitAsArray(1) /= PHYQ_Angle ) &
            & call Announce_error ( valuesNode, badUnitsForExplicit, &
              & extraInfo = (/ PHYQ_Angle /) )
d5361 1
d5418 7
a5424 3
        call GetModuleName ( quantity%template%instrumentModule, nameString )
        nameString = AssembleL1BQtyName ('MIF_TAI', this_hdfVersion, .TRUE., &
          & trim(nameString) )
d6110 4
a6113 4
        call expr(subtree(i+2,termsNode),unitAsArray,valueAsArray)
        ! Check unit OK
        if ( unitAsArray(1) /= PHYQ_Temperature ) &
          & call Announce_error ( termsNode, no_error_code, 'Bad unit for fourier term' )
d6545 5
a6549 5
        call expr ( heightNode, unitAsArray, valueAsArray )
        height = valueAsArray(1)
        if ( all ( unitAsArray(1) /= (/ PHYQ_Pressure /) ) ) &
          call Announce_Error ( key, 0, 'Bad units for height' )
        height = - log10 ( height )
d6586 5
a6590 6
        call expr ( heightNode, unitAsArray, valueAsArray )
        height = valueAsArray(1)
        if ( all ( unitAsArray(1) /= (/ PHYQ_Pressure /) ) ) &
          call Announce_Error ( key, 0, 'Bad units for height' )
        ! chisqBinned must be on zeta surfaces already, forced at construction, so take log.
        height = - log10 ( height )
d6654 6
a6659 4
        call expr ( subtree( i+1, multiplierNode ), exprUnit, exprValue )
        if ( exprUnit(1) /= PHYQ_Dimensionless ) then
          call Announce_Error ( key, no_error_code, &
            & 'multipliers in scaleOverlaps must be dimensionless' )
d6676 6
a6681 4
        call expr ( subtree( j+1, multiplierNode ), exprUnit, exprValue )
        if ( exprUnit(1) /= PHYQ_Dimensionless ) then
          call Announce_Error ( key, no_error_code, &
            & 'multipliers in scaleOverlaps must be dimensionless' )
d6768 2
a6769 2
      use Intrinsic, only: PHYQ_Indices
      use LEXER_CORE, only: PRINT_SOURCE
d6780 2
a6781 9
      call output ( '***** At ' )

      if ( where > 0 ) then
        call print_source ( source_ref(where) )
      else
        call output ( '(no lcf tree available)' )
      end if

      call output ( ': The' );
a6783 2
      case ( allocation_err )
        call output ( " command caused an allocation error in squeeze.", advance='yes' )
d6796 2
a6799 21
      case ( badUnitsForExplicit )
        call output ( " explitictValues field has inappropriate " // &
          & "units for Fill instruction.", advance='yes' )
        if ( present(extraInfo) ) then
          call output ( "Units should be" )
          do i = 1, size(extraInfo)
            call output ( ' ' )
            call display_String ( phyq_indices(extraInfo(i)) )
          end do
          call output ( '', advance='yes' )
        end if
      case ( badUnitsForIntegrationTime )
        call output ( " has inappropriate units for integration time.", advance='yes' )
      case ( badUnitsForSystemTemperature )
        call output ( " has inappropriate units for system temperature.", advance='yes' )
      case ( badUnitsForStatus )
        call output ( " has inappropriate units for status.", advance='yes' )
      case ( badUnitsForMaxIterations )
        call output ( " maxIterations should be dimensionless", advance='yes' )
      case ( badUnitsForWidth )
        call output ( " width should be dimensionless", advance='yes' )
d6808 2
a6809 2
      case ( deallocation_err )
        call output ( " command caused an deallocation error in squeeze.", advance='yes' )
d6817 2
a6818 4
      case ( m1_too_small )
        call output ( " command caused a m1 too small error in squeeze.", advance='yes' )
      case ( m2_too_small )
        call output ( " command caused a m2 too small error in squeeze.", advance='yes' )
a6831 3
      case ( needGeodAltitude )
        call output ( " vertical coordinate should be geoditic altitude.", &
          & advance='yes' )
a6847 2
      case ( noSourceQuantityGiven )
        call output ( " no sourceQuantity field given for vector fill.", advance='yes' )
d6857 15
a6871 34
      case ( not_permutation )
        call output ( " command caused an illegal permutation in squeeze.", advance='yes' )
      case ( numInstancesisZero )
        call output ( " command has zero instances.", advance='yes' )
      case ( numSurfsisZero )
        call output ( " command has zero surfaces.", advance='yes' )
      case ( n1_is_zero )
        call output ( " command caused an n1=0 error in squeeze.", advance='yes' )
      case ( n2_is_zero )
        call output ( " command caused an n2=0 error in squeeze.", advance='yes' )
      case ( n3_is_zero )
        call output ( " command caused an n3=0 error in squeeze.", advance='yes' )
      case ( objIsFullRank3 )
        call output ( " command array is full rank 3.", advance='yes' )
      case ( otherErrorInFillVector )
        call output ( " command caused an error in FillVector.", advance='yes' )
      case ( source_not_in_db )
        call output ( " source was not found in the db.", advance='yes' )
      case ( unknownQuantityName )
        call output ( " quantity was not found in the vector", advance='yes' )
      case ( vectorWontMatchPDef )
        call output ( " command found new and prev. vectors unmatched.", advance='yes' )
      case ( wrong_number )
        call output ( " command does not have exactly one field.", advance='yes' )
      case ( zeroGeodSpan )
        call output ( " command found zero geod. ang. span.", advance='yes' )
      case ( zeroProfilesFound )
        call output ( " command found zero profiles.", advance='yes' )
      case ( badRefractFill )
        call output ( " missing information for phiTan refract fill", advance='yes' )
      case ( missingDataInGrid )
        call output ( " missing/bad data points in grid for fill", advance='yes' )
      case ( emptyGridForFill )
        call output ( " an empty grid for the fill", advance='yes' )
d6879 1
d6885 1
a6885 1
       "$Id: Fill.f90,v 2.307 2005/07/21 23:42:31 pwagner Exp $"
d6896 3
@


2.307
log
@Repaired bugs in Fill status for missingGMAO; extras for explicit fill
@
text
@d100 2
a101 1
      & L_L1B, L_L1BMAFBASELINE, L_L2GP, L_L2AUX, L_LIMBSIDEBANDFRACTION, L_LOSVEL, &
d5438 11
a5458 16
      case ( l_tngtECI )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('ECI', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case ( l_tngtGeodAlt )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('GeodAlt', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case ( l_LosVel )
        call GetModuleName ( quantity%template%instrumentModule, nameString )
        nameString = AssembleL1BQtyName ('LosVel', this_hdfVersion, .TRUE., &
          & trim(nameString) )
      case ( l_tngtGeocAlt )
        call GetModuleName( quantity%template%instrumentModule,nameString )
        nameString = AssembleL1BQtyName('GeocAlt', this_hdfVersion, .TRUE., &
          & trim(nameString))
d5461 3
d5472 12
a5483 6
      case ( l_scGeocAlt )
        nameString = AssembleL1BQtyName('GeocAlt', this_hdfVersion, .FALSE., &
          & 'sc')
      case ( l_orbitInclination )
        nameString = AssembleL1BQtyName('OrbIncl', this_hdfVersion, .FALSE., &
          & 'sc')
d6952 1
a6952 1
       "$Id: Fill.f90,v 2.306 2005/07/12 17:40:52 pwagner Exp $"
d6963 3
@


2.306
log
@May fill status with condition that no gmaos found
@
text
@a45 1
  ! subroutine MLSL2Fill ( Root, L1bInfo, GriddedDataBase, VectorTemplates, &
d85 2
a86 1
      & F_TYPE, F_USB, F_USBFRACTION, F_VECTOR, F_VMRQUANTITY, F_WIDTH, &
d159 1
a159 1
    use OUTPUT_M, only: BLANKS, OUTPUT
a186 1
    ! type( L1BInfo_T ), intent(in) :: L1BINFO
a376 1
    logical :: IFMISSINGGMAO            ! Only if missing GMAO
d414 1
d461 1
d493 2
d538 1
a538 1
      ifMissingGMAO = .false.
d565 1
d568 2
d836 2
a837 1
            ifMissingGMAO = get_boolean ( gson )
d1000 1
d1030 4
d1042 4
d1209 2
d1773 8
a1780 2
          if ( .not. all ( got ( (/ f_sourceQuantity, f_status /) ) ) ) &
            & call Announce_Error ( key, no_error_code, &
d1782 2
a1783 2
          if ( .not. any ( got ( (/ f_minValue, f_maxValue /) ) ) ) &
            & call Announce_Error ( key, no_error_code, &
d1785 24
a1808 16
          sourceQuantity => GetVectorQtyByTemplateIndex ( vectors(sourceVectorIndex), &
            & sourceQuantityIndex )
          if ( got ( f_maxValue) .and. &
            &  all ( maxValueUnit /= (/ sourceQuantity%template%unit, PHYQ_Dimensionless/) ) ) &
            & call Announce_Error ( key, no_error_code, &
            & 'Bad unit for maxValue' )
          if ( got ( f_minValue) .and. &
            &  all ( minValueUnit /= (/ sourceQuantity%template%unit, PHYQ_Dimensionless/) ) ) &
            & call Announce_Error ( key, no_error_code, &
            & 'Bad unit for minValue' )
          if ( all ( got ( (/ f_minValue, f_maxValue /) ) ) .and. &
            &  maxValue <= minValue ) call Announce_Error ( key, no_error_code, &
            & 'Bad combination of max/min values' )
          if ( .not. ifMissingGMAO .or. APrioriFiles%dao // AprioriFiles%ncep == ' ') &
            & call FillStatusQuantity ( key, quantity, sourceQuantity, statusValue, &
            & minValue, maxValue, heightNode, additional )
d1898 2
a1899 1

d5226 2
a5227 1
      & globalUnit, dontmask, AzEl )
d5242 6
d5253 4
d5262 1
d5272 15
d5344 7
d5359 6
d5369 4
d6947 1
a6947 1
       "$Id: Fill.f90,v 2.305 2005/06/21 23:56:24 livesey Exp $"
d6958 3
@


2.305
log
@Added forgiveZeros handling to FillCovariance for efficiency.
@
text
@d69 2
a70 2
      & F_IGNORENEGATIVE, F_IGNOREGEOLOCATION, F_IGNOREZERO, F_INSTANCES, & 
      &	F_INTEGRATIONTIME, F_INTERNALVGRID, &
d162 1
d378 1
d536 1
d830 2
d1775 2
a1776 1
          call FillStatusQuantity ( key, quantity, sourceQuantity, statusValue, &
d6452 1
a6452 1
    ! -------------------------------------------- FillQualityFromChisq --------
d6478 1
a6478 1
          & 'Only one height can be supplied for satus fill' )
d6871 1
a6871 1
       "$Id: Fill.f90,v 2.304 2005/06/03 02:05:29 vsnyder Exp $"
d6882 3
@


2.304
log
@New copyright notice, move Id to not_used_here to avoid cascades,
get VGrids from VGridsDatabase instead of passing as an argument.
@
text
@d2310 1
a2310 1
      if ( lengthScale == 0 .and. .not. invert ) then
d2312 1
a2312 1
          & invert=invert )
d6865 1
a6865 1
       "$Id: Fill.f90,v 2.303 2005/05/31 18:11:45 pwagner Exp $"
d6876 4
@


2.303
log
@Restored 2.300 revisions mistakenly omitted from 2.302
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d31 1
a31 1
!        *matrix_database_T Matrices(:), VGrid_T vGrids(:),
d36 1
a36 5
  character (len=*), private, parameter :: IdParm = &
       "$Id: Fill.f90,v 2.302 2005/05/31 17:51:17 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Fill.f90,v $"
d48 1
a48 1
    & Vectors, QtyTemplates , Matrices, vGrids, L2GPDatabase, L2AUXDatabase, &
d92 1
a92 1
      & L_CHANNEL, L_CHISQMMAF, L_CHISQMMIF, L_CHOLESKY, &
d144 1
a144 1
    use MLSCommon, only: FileNameLen, MLSFile_T, R4, R8, RM, RV, &
d181 1
a181 1
    use VGridsDatabase, only: VGRID_T, GETUNITFORVERTICALCOORDINATE
a191 1
    type (VGrid_T), dimension(:), pointer :: vGrids
d6065 2
a6066 1
      
d6863 5
d6876 3
@


2.302
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.299 2005/03/24 21:23:46 pwagner Exp $"
d115 1
a115 1
      & S_FILLDIAGONAL, S_FLUSHL2PCBINS, S_MATRIX,  S_NEGATIVEPRECISION, &
d156 1
d601 7
d673 4
d6867 3
d6873 3
@


2.301
log
@Cannonball polishing
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.300 2005/05/27 20:03:06 vsnyder Exp $"
d42 2
a43 1
  subroutine MLSL2Fill ( Root, L1bInfo, GriddedDataBase, VectorTemplates, &
d88 1
a88 1
      & L_CHISQMMAF, L_CHISQMMIF, L_CHOLESKY, &
d115 1
a115 1
      & S_FILLDIAGONAL, S_FLUSHL2PCBINS, S_FLUSHPFA, S_MATRIX,  S_NEGATIVEPRECISION, &
d123 1
a123 1
    use L1BData, only: DeallocateL1BData, Dump, FindL1BData, L1BData_T, &
d140 1
a140 1
    use MLSCommon, only: FileNameLen, L1BInfo_T, R4, R8, RM, RV, &
d142 2
a143 3
    use MLSFiles, only: mls_hdf_version, &
      & ERRORINH5FFUNCTION, WRONGHDFVERSION
    use MLSL2Options, only: LEVEL1_HDFVERSION, RESTARTWARNINGS
a155 1
    use PFAData_m, only: Flush_PFAData
d180 2
a181 1
    type (l1BInfo_T), intent(in) :: L1bInfo
a599 7
        ! Handle disassociated pointers by allocating them with zero size
        status = 0
        if ( .not. associated(qtyTemplates) ) allocate ( qtyTemplates(0), stat=status )
        if ( .not. associated(vectorTemplates) ) allocate ( vectorTemplates(0), stat=status )
        if ( .not. associated(vectors) ) allocate ( vectors(0), stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate // 'one of QtyTemplates, VectorTemplates or Vectors' )
a664 4
      case ( s_flushPFA )
        call flush_PFAData ( key, status )
        error = max(error,status)

d1232 1
a1232 1
              & l1bInfo, isPrecision, suffix=suffix, &
d1236 1
a1236 1
              & l1bInfo, isPrecision, suffix=suffix )
a5056 1
      use Tree, only: Source_Ref
d5282 2
a5283 1
    subroutine FillVectorQuantityFromL1B ( root, quantity, chunk, l1bInfo, &
d5288 2
a5289 1
      type (l1bInfo_T), INTENT(IN) ::               L1BINFO
a5295 1
      character (len=FileNameLen) :: FILENAMESTRING
d5300 1
d5306 24
a5329 20
      fileID=l1bInfo%l1bOAID
      if ( quantity%template%quantityType /= l_radiance ) then
        filenamestring = l1bInfo%L1BOAFileName
      else
        if ( .not. associated(l1bInfo%L1BRADFilenames) ) then
          call Announce_Error ( root, No_Error_code, &
            & 'No radiances files to read from' )
          return
        else
          filenamestring = l1bInfo%L1BRADFileNames(1)
        end if
      end if
      this_hdfVersion = mls_hdf_version(trim(filenamestring), LEVEL1_HDFVERSION)
      if ( this_hdfVersion == ERRORINH5FFUNCTION ) then
        call Announce_Error ( root, No_Error_code, &
          & 'Error in finding hdfversion of l1b file' )
      else if ( this_hdfVersion == WRONGHDFVERSION ) then
        call Announce_Error ( root, No_Error_code, &
          & 'Wrong hdfversion declared/coded for l1b file' )
      end if
d5348 2
a5349 1
        fileID = FindL1BData (l1bInfo%l1bRadIDs, nameString, this_hdfVersion )
d5391 2
a5392 1
          fileID = FindL1BData (l1bInfo%l1bRadIDs, nameString, this_hdfVersion )
d5400 1
a5400 1
      if ( fileId /= 0 .or. ( quantity%template%quantityType /= l_radiance .and. &
d5403 1
d5405 1
a5405 1
        call ReadL1BData ( fileID , nameString, l1bData, noMAFs, flag, &
d5407 2
a5408 2
          & NeverFail= .false., hdfVersion=this_hdfVersion, &
        & dontPad=DONTPAD )
d6855 2
a6856 2
! Revision 2.300  2005/05/27 20:03:06  vsnyder
! Dissassociated -> zero size before dump
@


2.300
log
@Dissassociated -> zero size before dump
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.299 2005/03/24 21:23:46 pwagner Exp $"
d5067 2
d5086 2
a5087 1
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error opening ASCII file' )
d5092 2
a5093 1
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error reading ASCII file' )
d5098 2
a5099 1
        call MLSMessage( MLSMSG_Error, ModuleName, 'Error closing ASCII file' )
d6858 3
@


2.299
log
@Removed buggy, unused FillColAbundance
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.298 2005/03/12 00:50:27 pwagner Exp $"
d87 1
a87 1
      & L_CHANNEL, L_CHISQMMAF, L_CHISQMMIF, L_CHOLESKY, &
d114 1
a114 1
      & S_FILLDIAGONAL, S_FLUSHL2PCBINS, S_MATRIX,  S_NEGATIVEPRECISION, &
d156 1
d600 7
d672 4
d6853 3
@


2.298
log
@May restart warnings counter at each phase
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.297 2004/12/01 01:24:44 livesey Exp $"
d2203 20
d3395 1
a3397 183
      ! A special fill according to Appendix A of EOS MLS ATBD
      ! JPL D-16159
      ! EOS MLS DRL 601 (part 3)
      ! ATBD-MLS-03
      ! (Livesey and Wu)

      ! Assumptions:
      ! (1)This fill operation is triggered by a command
      !    such as the following in the lcf
      !      Fill, state.columnO3, method=special, vmrQuantity=state.o3, $
      !      boundaryPressure=state.tpPressure
      ! (2)the vmr is in units of PHYQ_VMR and not, say, ppmv;
      !    it is in fact identical to the coefficients of the mls basis functions
      ! (3)The pressure surfaces are in hPa, but not all necessarily at the
      !    same logarithmic distance from one another
      ! (4)The tropospheric boundary pressure is somewhere in between the surfs
      ! (5)Unless first,last instances are args, fill all instances
      !    (unlike join which has to worry about chunks and overlaps)
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) :: BNDPRESSQTY
      type (VectorValue_T), intent(in) :: VMRQTY
      integer, intent(in), optional :: FIRSTINSTANCE
      integer, intent(in), optional :: LASTINSTANCE
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in the column data.
      ! Parameters                               or newer idl-like one (default)
      logical, parameter :: OLDBUGS = .false.  ! Whether to use older buggy
      logical :: useoldbugs
      ! Executable
      useoldbugs = OLDBUGS
      if ( index(switches, 'colold') /= 0 ) useoldbugs = .true.
      if ( index(switches, 'colidl') /= 0 ) useoldbugs = .false.
      if ( useoldbugs ) then
        if ( index(switches, 'l2gp') /= 0 ) &
          & call output('Filling column using buggy old method', advance='yes')
        call  FillColAbundance_bug ( key, qty, bndPressQty, vmrQty, &
          & firstInstance, lastInstance )
      else
        if ( index(switches, 'l2gp') /= 0 ) &
          & call output('Filling column using Bills idl method', advance='yes')
        call  FillColAbundance_idl ( key, qty, bndPressQty, vmrQty, &
          & firstInstance, lastInstance )
      end if
    end subroutine FillColAbundance


    ! ------------------------------------------- FillColAbundance_bug ---
    subroutine FillColAbundance_bug ( key, qty, bndPressQty, vmrQty, &
      & firstInstance, lastInstance )
      ! A special fill according to Appendix A of EOS MLS ATBD
      ! JPL D-16159
      ! EOS MLS DRL 601 (part 3)
      ! ATBD-MLS-03
      ! (Livesey and Wu)

      ! Assumptions:
      ! (See above)
      integer, intent(in) :: KEY
      type (VectorValue_T), intent(inout) :: QTY
      type (VectorValue_T), intent(in) :: BNDPRESSQTY
      type (VectorValue_T), intent(in) :: VMRQTY
      integer, intent(in), optional :: FIRSTINSTANCE
      integer, intent(in), optional :: LASTINSTANCE
      ! The last two are set if only part (e.g. overlap regions) of the quantity
      ! is to be stored in the column data.

      ! Local parameters
      real(r8), parameter :: AOVERMG = 4.12e5 / (2.687 * 0.192)

      ! Local variables
      logical :: printMe
      integer :: SURFACE
      integer :: INSTANCE
      integer :: FIRSTSURFACE
      integer :: USEFIRSTINSTANCE
      integer :: USELASTINSTANCE
      integer :: NOOUTPUTINSTANCES
      real (r8) :: THISBNDPRESS
      real (r8) :: COLUMNSUM
      real (r8) :: DELTA_P_PLUS    ! p[j+1] - p[j]
      real (r8) :: DELTA_P_MINUS   ! p[j-1] - p[j]
      real (r8) :: DELTA_LOG_PLUS  ! ln p[j+1] - ln p[j]
      real (r8) :: DELTA_LOG_MINUS ! ln p[j-1] - ln p[j]

      real (r8), pointer, dimension(:) :: P         ! p[i] in hPa

      ! Executable code
      ! First check that things are OK.
      if ( (qty%template%quantityType /= l_columnAbundance) .or. &
        &  (bndPressQty%template%quantityType /= l_boundaryPressure) .or. &
        &  (vmrQty%template%quantityType /= l_vmr) ) then
        call Announce_error ( key, No_Error_code, &
          & 'Wrong quantity type found while filling column abundance'  )
        return
      else if ( qty%template%molecule /= vmrQty%template%molecule ) then
        call Announce_error ( key, No_Error_code, &
          & 'Attempt to fill column abundance with different molecule'  )
        return
      else if ( .not. ( DoHgridsMatch( qty, vmrQty ) .and. &
        & DoHgridsMatch( qty, bndPressQty ) ) ) then
        call Announce_error ( key, No_Error_code, &
          & 'Attempt to fill column abundance with different HGrids'  )
        return
      else if ( .not. any(vmrQty%template%verticalCoordinate == &
        & (/l_zeta/)) ) then
        call Announce_error ( key, No_Error_code, &
          & 'Fill column abundance, but vmr not on zeta surfs.'  )
        return
      end if

      ! Work out what to do with the first and last Instance information
      useFirstInstance = 1
      useLastInstance = qty%template%noInstances
      if ( present ( firstInstance ) ) useFirstInstance = firstInstance
      if ( present ( lastInstance ) ) useLastInstance = lastInstance
      noOutputInstances = useLastInstance-useFirstInstance+1

      ! If we've not been asked to output anything then don't carry on
      if ( noOutputInstances < 1 ) return
      ! AoverMg = 4.12e25 / (2.687e20 * 0.192)
      ! This assumes that
      ! (1) p is in hPa
      ! (2) f is in PHYQ_vmr (*not* ppmv)

      nullify ( p )
      call allocate_test ( p, vmrQty%template%noSurfs, 'p', ModuleName )
      p = 10.0 ** ( - vmrQty%template%surfs(:,1) )

      do instance = useFirstInstance, useLastInstance
        printMe = (instance == useFirstInstance) .and. (index(switches, 'column') /= 0)
        if ( printMe ) print *, 'switches: ', trim(switches)
        if ( printMe ) print *, 'index(switches, column) ', index(switches, 'column')
        ! Find 1st surface at or above tropopause
        ! (i.e., at a pressure equal to or less than boundaryPressure)
        if ( instance > size(bndPressQty%values, 2) ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Cant fill column--instance outside b.pres. range' )
          call deallocate_test(p, 'p', ModuleName )
          return
        end if
        thisBndPress = bndPressQty%values(1,instance)
        ! In case where WMO algorithm failed, use bottom of basis
        if ( thisBndPress <= 0.0 ) &
          & thisBndPress = 10.0 ** ( - vmrQty%template%surfs(1,1) )
        call Hunt ( vmrQty%template%surfs(:,1), &
          & -log10 ( thisBndPress ), firstSurface )
        do surface=1, vmrQty%template%noSurfs
          if ( p(surface) <= thisBndPress ) exit
        end do

        ! Do summation
        ! Initialize sum, Deltas
        columnSum = 0.0
        Delta_p_plus = p(firstSurface+1) - p(firstSurface)
        Delta_log_plus = log(p(firstSurface+1)) - log(p(firstSurface))
        if ( printMe ) then
          print *, 'thisBndPress: ', thisBndPress
          print *, 'firstSurface: ', firstSurface
        end if
        ! Loop over surfaces from tropoause+1 to uppermost-1
        do surface = firstSurface + 1, vmrQty%template%noSurfs - 1
          Delta_p_minus = - Delta_p_plus
          Delta_log_minus = - Delta_log_plus
          Delta_p_plus = p(surface+1) - p(surface)
          Delta_log_plus = log(p(surface+1)) - log(p(surface))
          columnSum = columnSum + &
            & vmrQty%values(surface, instance) * &
            & ( Delta_p_minus/Delta_log_minus - &
            &   Delta_p_plus/Delta_log_plus )          
        if ( printMe ) then
          print *, 'columnSum: ', columnSum
        end if
        end do
        qty%values ( 1, instance ) = AoverMg * columnSum
      end do

      call Deallocate_test ( p, 'p', ModuleName )
    end subroutine FillColAbundance_bug

    ! ------------------------------------------- FillColAbundance_idl ---
    subroutine FillColAbundance_idl ( key, qty, bndPressQty, vmrQty, &
      & firstInstance, lastInstance )
d3630 1
a3630 19
    end subroutine FillColAbundance_idl
    subroutine deallocateStuff(Zetab, Zetac, Zetai, Pb, Pc, Pi)    
      real (r8), pointer, dimension(:) :: Zetab
      real (r8), pointer, dimension(:) :: Zetac
      real (r8), pointer, dimension(:) :: Zetai
      real (r8), pointer, dimension(:) :: Pb         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pc         ! p[i] in hPa
      real (r8), pointer, dimension(:) :: Pi         ! p[i] in hPa
      ! call Deallocate_test ( pa, 'pa', ModuleName )
      call Deallocate_test ( pb, 'pb', ModuleName )
      call Deallocate_test ( pc, 'pc', ModuleName )
      ! call Deallocate_test ( pd, 'pd', ModuleName )
      call Deallocate_test ( pi, 'pi', ModuleName )
      ! call Deallocate_test ( Zetaa, 'Zetaa', ModuleName )
      call Deallocate_test ( Zetab, 'Zetab', ModuleName )
      call Deallocate_test ( Zetac, 'Zetac', ModuleName )
      ! call Deallocate_test ( Zetad, 'Zetad', ModuleName )
      call Deallocate_test ( Zetai, 'Zetai', ModuleName )
    end subroutine DeallocateStuff    
d6841 3
@


2.297
log
@Handles missing L1BMAFBaselines in the same manner as missing radiances.
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d29 1
a29 1
       "$Id: Fill.f90,v 2.296 2004/11/30 01:41:58 livesey Exp $"
d143 1
a143 1
    use MLSL2Options, only: LEVEL1_HDFVERSION
d147 1
a147 1
      & MLSMSG_Allocate, MLSMSG_Deallocate
d2008 1
d7021 3
@


2.296
log
@Make folded sideband fill cope with absence of one sideband (for R1A
case).
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.295 2004/11/29 21:53:33 livesey Exp $"
d5566 2
a5567 1
      if ( fileId /= 0 .or. quantity%template%quantityType /= l_radiance ) then
d7020 4
@


2.295
log
@Bug fix for reading L1B data when no radiances files specified.
Also, added (a+b)/2 manipulation and changed definition of quality to be
1.0/chisq.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.294 2004/11/24 22:51:37 livesey Exp $"
d1184 2
a1185 1
          lsb => GetVectorQtyByTemplateIndex ( &
d1187 1
a1187 1
          lsbFraction => GetVectorQtyByTemplateIndex ( &
d1189 1
a1189 1
          usb => GetVectorQtyByTemplateIndex ( &
d1191 1
a1191 1
          usbFraction => GetVectorQtyByTemplateIndex ( &
d3815 4
a3818 4
      type (VectorValue_T), intent(in) :: USB
      type (VectorValue_T), intent(in) :: LSB
      type (VectorValue_T), intent(in) :: USBFRACTION
      type (VectorValue_T), intent(in) :: LSBFRACTION
d3831 26
a3856 14
      if ( .not. ValidateVectorQuantity ( lsb, quantityType=(/l_radiance/), &
        & sideband=(/-1/), signal=(/radiance%template%signal/), minorFrame=.true. )) &
        & call Announce_Error ( key, 0, 'Inappropriate lsb radiance quantity for fill' )
      if ( .not. ValidateVectorQuantity ( usb, quantityType=(/l_radiance/), &
        & sideband=(/1/), signal=(/radiance%template%signal/), minorFrame=.true. )) &
        & call Announce_Error ( key, 0, 'Inappropriate usb radiance quantity for fill' )
      if ( .not. ValidateVectorQuantity ( lsbFraction, &
        & quantityType=(/l_limbSidebandFraction/), &
        & signal=(/radiance%template%signal/), sideband=(/-1/) ) ) &
        & call Announce_Error ( key, 0, 'Inappropriate lsbFraction quantity for fill' )
      if ( .not. ValidateVectorQuantity ( usbFraction, &
        & quantityType=(/l_limbSidebandFraction/), &
        & signal=(/radiance%template%signal/), sideband=(/1/) ) ) &
        & call Announce_Error ( key, 0, 'Inappropriate usbFraction quantity for fill' )
d3859 2
d3864 4
a3867 2
          radiance%values(i,:) = &
            & lsbFraction%values(c,1) * lsb%values(i,:) + &
d7019 5
@


2.294
log
@Bug fix in off line sideband folding
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.293 2004/11/08 21:57:00 livesey Exp $"
d5465 7
a5471 1
        filenamestring = l1bInfo%L1BRADFileNames(1)
d6017 9
a6025 3
      integer, parameter :: NOMANIPULATIONS = 6
      character(len=3), parameter :: VALIDMANIPULATIONS ( noManipulations ) = &
        & (/ 'a+b', 'a-b', 'a*b', 'a>b', 'a<b', 'a|b' /)
d6100 8
d6657 4
a6660 2

      quantity%values(1,:) = min ( exp ( 1.0_r8 - sourceQuantity%values(surface,:) / scale ), 1.0_r8 )
d7002 3
@


2.293
log
@Added handling of 'badRange' in ASCII fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.292 2004/10/21 19:32:55 livesey Exp $"
d3842 1
a3842 1
        & signal=(/radiance%template%signal/), sideband=(/-1/) ) ) &
d6980 3
@


2.292
log
@Got the Fill from ASCII file working.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.291 2004/10/16 17:26:08 livesey Exp $"
d58 1
a58 1
      & F_APRIORIPRECISION, F_B, F_BASELINEQUANTITY, F_BIN, F_BOUNDARYPRESSURE, F_BOXCARMETHOD, &
d323 1
d746 3
d1097 5
a1101 1
          call FillQuantityFromASCIIFile ( key, quantity, filename )
d5214 1
a5214 1
    subroutine FillQuantityFromAsciiFile ( key, quantity, filename )
d5220 1
d5246 7
d6980 3
@


2.291
log
@Added stub of fill from ascii file
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.290 2004/10/13 02:25:11 livesey Exp $"
d5207 2
d5212 25
d6964 3
@


2.290
log
@Changes to fill from vGrid
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.289 2004/09/28 22:26:46 livesey Exp $"
d61 1
a61 1
      & F_EXTINCTION, F_FIELDECR, F_FORCE, &
d84 1
a84 1
    use INIT_TABLES_MODULE, only: L_ADDNOISE, L_APPLYBASELINE, &
d100 1
a100 1
      & l_PHASETIMING, L_PHITAN, &
d352 1
d779 2
d1089 6
d5205 7
d6937 3
@


2.289
log
@Bug fix in applyBaseline, had quadrature handled the wrong way round.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.288 2004/09/27 20:11:29 livesey Exp $"
d92 1
a92 1
      & L_GPH, L_GPHPRECISION, L_GRIDDED, L_H2OFROMRHI, &
d410 1
d1772 9
a1780 3
          if ( .not. ValidateVectorQuantity(quantity, &
            & quantityType=(/l_ptan/), &
            & frequencyCoordinate=(/l_none/) ) ) &
d1782 1
a1782 4
            &   'vGrids can only be used to fill ptan quantities' )
          if ( vGrids(vGridIndex)%verticalCoordinate /= l_zeta ) &
            & call Announce_Error ( key, No_Error_code, &
            &  'Vertical coordinate in vGrid is not zeta' )
d6921 3
@


2.288
log
@Added stuff for reading and applying L1BMAFBaseline.  This includes new
suffix argument to L1B reading.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.287 2004/09/25 00:16:31 livesey Exp $"
d2164 2
a2165 2
            quantity%values ( ind, : ) = quantity%values ( ind, : ) + &
              & baselineQuantity%values ( chan, : )
d2172 2
a2173 2
            quantity%values ( ind, : ) = sqrt ( quantity%values ( ind, : )**2 + &
              & baselineQuantity%values ( chan, : )**2 )
d6917 4
@


2.287
log
@Removed 'key' argument in CombineChannels call
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.286 2004/09/24 17:55:57 livesey Exp $"
d58 1
a58 1
      & F_APRIORIPRECISION, F_B, F_BIN, F_BOUNDARYPRESSURE, F_BOXCARMETHOD, &
d73 1
a73 1
      & F_QUANTITY, F_RADIANCEQUANTITY, F_RATIOQUANTITY, &
d78 1
a78 1
      & F_SOURCEQUANTITY, F_SOURCEVGRID, F_SPREAD, F_STATUS, F_SUPERDIAGONAL, &
d84 1
a84 1
    use INIT_TABLES_MODULE, only: L_ADDNOISE, &
d95 1
a95 1
      & L_L1B, L_L2GP, L_L2AUX, L_LIMBSIDEBANDFRACTION, L_LOSVEL, &
d277 1
d323 2
d427 1
d461 1
d542 1
d551 1
d743 3
d908 2
d969 2
d1077 8
d1210 1
a1210 1
            & vectors(precisionVectorIndex), precisionQuantityIndex )
d1212 2
a1213 1
              & l1bInfo, isPrecision, precisionQuantity )
d1216 1
a1216 1
              & l1bInfo, isPrecision )
d2139 41
d5377 1
a5377 1
      & isPrecision, PrecisionQuantity )
d5383 1
d5387 1
a5387 1
      character (len=80) :: NAMESTRING
d5418 4
d5467 12
d6917 3
@


2.286
log
@Moved FillWithCombinedChannels into ManipulateVectorQuantitites
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.285 2004/09/24 03:38:26 livesey Exp $"
d1109 1
a1109 1
          call FillWithCombinedChannels ( key, quantity, sourceQuantity, message )
d6836 3
@


2.285
log
@Added optional mapping matrix output to combine channels fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.284 2004/09/21 22:59:18 livesey Exp $"
d130 2
a131 2
      & DOVGRIDSMATCH, DOQTYSDESCRIBESAMETHING
    use MatrixModule_0, only: Sparsify, MatrixInversion, MatrixElement_T, M_Full, CreateBlock 
d1109 2
a1110 1
          call FillWithCombinedChannels ( key, quantity, sourceQuantity )
a6496 88
    ! -------------------------------------- FillWithCombinedChannels ----------
    subroutine FillWithCombinedChannels ( key, quantity, sourceQuantity, mapping )
      ! This routine takes a (typically radiance) quantity on one set of channels
      ! and combines the channels together appropriately to make them representative
      ! of the data in another (presumably at a finer resolution.
      integer, intent(in) :: KEY        ! Tree node
      type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY ! Quantitiy on finer(?) channel grid
      type (MatrixElement_T), intent(inout), optional :: MAPPING ! A matrix_0 mapping
      ! Local variables
      type (Signal_T) :: signal, sourceSignal
      integer :: COUT, CIN              ! Channel counters
      integer :: IOUT, IIN              ! Indices
      integer :: SURF                   ! Loop counter
      real(r8) :: CENTER, HALFWIDTH     ! Channel locations
      integer, dimension(:), pointer :: NOINSIDE ! Number of channels that were caught

      ! Do some sanity checking
      if ( .not. DoVGridsMatch ( quantity, sourceQuantity ) ) &
        & call Announce_Error ( key, no_error_code, 'Quantities must have matching vGrids' )
      if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) ) &
        & call Announce_Error ( key, no_error_code, 'Quantities must have matching hGrids' )

      if ( quantity%template%signal == 0 .or. &
        &  quantity%template%frequencyCoordinate /= l_channel ) &
        & call Announce_Error ( key, no_error_code, 'Quantity must have channels' )
      if ( sourceQuantity%template%signal == 0 .or. &
        &  sourceQuantity%template%frequencyCoordinate /= l_channel ) &
        & call Announce_Error ( key, no_error_code, 'source quantity must have channels' )

      signal = GetSignal ( quantity%template%signal )
      sourceSignal = GetSignal ( sourceQuantity%template%signal )

      if ( signal%radiometer /= sourceSignal%radiometer ) &
        & call Announce_Error ( key, no_error_code, 'quantities must be from same radiometer' )

      nullify ( noInside )
      call Allocate_test ( noInside, quantity%template%noChans, 'noInside', ModuleName )

      ! Possibly setup a mapping matrix
      if ( present ( mapping ) ) then
        call CreateBlock ( mapping, &
          & quantity%template%instanceLen, sourceQuantity%template%instanceLen, &
          & kind=m_full )
      end if

      ! Do a quick first pass to get the numbers in each output channel
      do cOut = 1, quantity%template%noChans
        ! Work out where this output channel is
        center = signal%centerFrequency + signal%direction * signal%frequencies ( cOut )
        halfWidth = signal%frequencies ( cOut )
        ! Now map this back into sourceSignal%frequencies
        center = ( center - sourceSignal%centerFrequency ) * sourceSignal%direction
        noInside(cOut) = count ( &
          & ( sourceSignal%frequencies >= ( center - halfWidth ) ) .and. &
          & ( sourceSignal%frequencies < ( center + halfWidth ) ) )
      end do
      if ( any ( noInside == 0 ) ) call Announce_Error ( key, no_error_code, &
        & 'Some channels have no source' )

      ! Loop over the channels in the result
      do cOut = 1, quantity%template%noChans
        ! Work out where this output channel is
        center = signal%centerFrequency + signal%direction * signal%frequencies ( cOut )
        halfWidth = signal%frequencies ( cOut )
        ! Now map this back into sourceSignal%frequencies
        center = ( center - sourceSignal%centerFrequency ) * sourceSignal%direction
        ! Use nested loops to make the code easier to read, rather than complicated indexing
        do cIn = 1, sourceQuantity%template%noChans
          if ( ( sourceSignal%frequencies(cIn) >= ( center - halfWidth ) ) .and. &
            &  (  sourceSignal%frequencies(cIn) < ( center + halfWidth ) ) ) then
            do surf = 0, quantity%template%noSurfs - 1 ! 0..n-1 makes indexing easier
              iOut = cOut + surf * quantity%template%noChans
              iIn = cIn + surf * sourceQuantity%template%noChans
              quantity%values ( iOut, : ) = quantity%values ( iOut, : ) + &
                & sourceQuantity%values ( iIn, : ) / noInside(cOut)
              ! Possibly fill mapping matrix
              if ( present ( mapping ) ) then
                mapping%values ( iOut, iIn ) = 1.0 / noInside(cOut)
              end if
            end do
          end if
        end do
      end do
      
      call Deallocate_test ( noInside, 'noInside', ModuleName )
    end subroutine FillWithCombinedChannels

d6836 3
@


2.284
log
@Another change to the chi-squared to quality conversion.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.283 2004/09/21 19:17:23 livesey Exp $"
d131 1
a131 1
    use MatrixModule_0, only: Sparsify, MatrixInversion
d6497 1
a6497 1
    subroutine FillWithCombinedChannels ( key, quantity, sourceQuantity )
d6504 1
d6508 1
d6535 7
d6568 8
a6575 4
              quantity%values ( cOut + surf * quantity%template%noChans, : ) = &
                & quantity%values ( cOut +  surf * quantity%template%noChans, : ) + &
                & sourceQuantity%values ( cIn + surf * sourceQuantity%template%noChans, : ) / &
                &   noInside(cOut)
d6923 3
@


2.283
log
@Changed the 1-tanh to an exp in converting from chi squared to quality.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.282 2004/09/16 23:55:04 livesey Exp $"
d6493 1
a6493 1
      quantity%values(1,:) = exp ( - sourceQuantity%values(surface,:) / scale )
d6910 3
@


2.282
log
@Stopped binned fill from being so fussy.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.281 2004/09/10 23:53:10 livesey Exp $"
d6493 1
a6493 1
      quantity%values(1,:) = 1.0 - tanh ( sourceQuantity%values(surface,:) / scale )
d6910 3
@


2.281
log
@Added centerVertically option for binmean/max/min fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.280 2004/08/24 23:24:46 pwagner Exp $"
d6204 1
a6204 1
        & coherent=.true., stacked=.true., frequencyCoordinate=(/l_none/) ) ) &
d6910 3
@


2.280
log
@Asks ReadL1BData to pad, contract--partly tested
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.279 2004/08/23 21:59:42 pwagner Exp $"
d59 1
a59 1
      & F_CHANNEL, F_COLUMNS, F_DESTINATION, F_DIAGONAL, F_dontMask,&
d328 1
d517 1
d747 2
d1090 1
a1090 1
            & channel, fillMethod, additional, excludeBelowBottom )
d6176 1
a6176 1
      & channel, method, additional, excludeBelowBottom )
d6189 1
d6218 3
d6223 3
d6239 1
a6239 1
          & allowTopValue=.true., allowBelowValue=excludeBelowBottom )
d6244 1
a6244 1
            & allowTopValue=.true., allowBelowValue=excludeBelowBottom )
d6910 3
@


2.279
log
@Disabled debugging dumps of section, phase timings
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.278 2004/08/03 18:01:14 pwagner Exp $"
d36 2
d5399 2
a5400 1
          & NeverFail= .false., hdfVersion=this_hdfVersion )
d6899 3
@


2.278
log
@Gets DEFAULTUNDEFINEDVALUE from MLSCommon
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.277 2004/07/30 00:17:22 livesey Exp $"
d1382 1
a1382 1
            call dump( quantity%values(:,1), 'phases' )
d1391 1
a1391 1
            call dump( quantity%values(:,1), 'sections' )
d6896 3
@


2.277
log
@Changed some errors to warnings
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.276 2004/07/22 20:39:14 cvuu Exp $"
d137 2
a138 1
    use MLSCommon, only: FileNameLen, L1BInfo_T, R4, R8, RM, RV
d268 2
a269 1
    real, parameter ::    UNDEFINED_VALUE = -999.99 ! Same as %template%badvalue
d6896 3
@


2.276
log
@Now can fill ForwardModel time, mean and std_dev
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.275 2004/06/29 18:06:28 pwagner Exp $"
d1375 7
a1381 4
          if ( status /= 0 ) &
            & call Announce_error ( key, 0, 'Unable to finish phases timings' )
          call FillTimings ( quantity%values(:,1), 'phases', 'all', .true. )
          call dump( quantity%values(:,1), 'phases' )
d1385 6
a1390 4
          if ( status /= 0 ) &
            & call Announce_error ( key, 0, 'Unable to finish sections timings' )
          call FillTimings ( quantity%values(:,1), 'sections', 'all', .true. )
          call dump( quantity%values(:,1), 'sections' )
d6894 3
@


2.275
log
@May fill phase, section timings
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.274 2004/06/10 00:58:45 vsnyder Exp $"
d42 1
a42 1
    & Chunks, ChunkNo )
d51 2
d89 1
d186 1
d1145 6
d6889 3
@


2.274
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.273 2004/05/28 00:57:49 vsnyder Exp $"
d80 2
a81 1
    use INIT_TABLES_MODULE, only: L_ADDNOISE, L_BINMAX, L_BINMEAN, L_BINMIN, L_BINTOTAL, &
d84 2
a85 1
      & L_cloudice, L_cloudextinction, L_cloudInducedRADIANCE, L_COMBINECHANNELS, L_COLUMNABUNDANCE, &
d89 3
a91 2
      & L_IWCFROMEXTINCTION, L_KRONECKER, L_L1B, L_L2GP, &
      & L_L2AUX, L_LOSVEL, L_MAGAZEL, L_MAGNETICFIELD, L_MAGNETICMODEL, &
d94 2
a95 1
      & L_NORADSPERMIF, L_OFFSETRADIANCE, L_ORBITINCLINATION, L_PHITAN, &
d97 3
a99 2
      & L_RADIANCE, L_RECTANGLEFROMLOS, L_REFGPH, L_REFRACT, L_REFLECTORTEMPMODEL, &
      & L_REFLTEMP, L_RESETUNUSEDRADIANCES, L_RHI, L_RHIFROMH2O, L_RHIPRECISIONFROMH2O, L_ROTATEFIELD, &
d101 2
a102 1
      & L_LIMBSIDEBANDFRACTION, L_SINGLECHANNELRADIANCE, L_SPD, L_SPECIAL, L_SPREADCHANNEL, &
d138 2
a139 1
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES, add_to_phase_timing
d1117 1
a1117 1
        case ( l_explicit ) ! ---------  Explicity fill from l2cf  -----
d1363 14
d6879 3
@


2.273
log
@Move GetIndexFlagsFromList from MoreTree to Expr_m
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.272 2004/05/19 20:38:04 vsnyder Exp $"
d128 1
a128 1
    use MLSCommon, only: FileNameLen, L1BInfo_T, R4, R8, RM, RV, FindFirst
d137 1
d6858 3
@


2.272
log
@Remove unreferenced symbols, polish some cannonballs
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.271 2004/05/19 19:16:09 vsnyder Exp $"
d50 1
a50 1
    use Expr_M, only: EXPR
d140 1
a140 1
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID, GetIndexFlagsFromList
d6857 3
@


2.271
log
@Move MLSChunk_t to Chunks_m
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.270 2004/05/04 01:03:56 livesey Exp $"
d84 1
a84 1
      & L_ECRTOFOV, L_ESTIMATEDNOISE, L_EXPLICIT, L_EXTRACTCHANNEL, L_FOLD, L_GEODALTITUDE, &
d99 1
a99 1
      & L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VGRID, L_VMR, L_WMOTROPOPAUSE, &
d129 1
a129 1
    use MLSFiles, only: mls_hdf_version, HDFVERSION_5, &
d138 1
a138 1
      & GetSignal, Signal_T, Dump_signals
d153 1
a153 1
    use TREE_TYPES, only: N_NAMED, N_SET_ONE
d159 1
a159 1
      & rmVectorFromDatabase, ValidateVectorQuantity, Vector_T, &
d161 1
a285 1
    type (vectorValue_T), pointer :: SIDEBANDFRACTION
a355 1
    integer :: INSTANCE                 ! Loop counter
d702 1
a702 1
          if (nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
d974 2
a975 2
          if (DEEBUG) call output('add noise method', advance='yes')
          if (.not. all(got( (/f_Quantity, f_sourceQuantity, f_noise/) ) ) ) &
d985 1
a985 1
          if (DEEBUG) then
d995 1
a995 1
            if (DEEBUG) then
d1006 1
a1006 1
              if (DEEBUG) then
d1012 1
a1012 1
              if (DEEBUG) then
d1018 1
a1018 1
            if (DEEBUG) then
d1036 1
a1036 1
          if (DEEBUG) then
d1092 1
a1092 1
          if (.not. all(got( (/ f_radianceQuantity, &
d1268 1
a1268 1
          if (.not. all(got( (/f_ratioQuantity, f_sourceQuantity/) ) ) ) &
d1274 1
a1274 1
          call FillVectorQtyFromIsotope ( key, quantity, sourceQuantity, &
d1301 1
a1301 1
                call FillIWCFromExtinction ( key, quantity, &
d1360 1
a1360 1
            call FillVectorQtyFromProfile ( key, quantity, valuesNode, &
d1363 1
a1363 1
            call FillVectorQtyFromProfile ( key, quantity, valuesNode, &
d1365 1
a1365 1
          endif
d1393 1
a1393 1
          if (.not. all(got((/f_losQty,f_earthRadius,f_PtanQuantity/))))&
d1526 1
a1526 1
          if (DEEBUG) then
d1610 1
a1610 1
              call FillNoRadsPerMIF ( key, quantity, measQty )
d1702 1
a1702 1
          if (.not. ValidateVectorQuantity(quantity, &
d1766 1
a1766 1
          if (nsons(gson) > 1) &
d1797 1
a1797 1
          if (nsons(gson) > 1) &
d1816 1
a1816 1
        if (DEEBUG) call output('Destroy vector/matrix instruction', &
d1840 1
a1840 1
          if (DEEBUG) then
d1856 1
a1856 1
          if (DEEBUG) then
d1861 1
a1861 1
          if (DEEBUG) then
d2035 1
a2035 1
      if (.not. FillableChiSq ( quantity, &
d2046 1
a2046 1
      else if (&
d2287 1
a2287 1
      if (quantity%template%verticalCoordinate /= l_zeta) then
d2300 1
a2300 1
        if (.not. quantity%template%stacked) instIndex=instance
d2303 1
a2303 1
          if (.not. quantity%template%coherent) surfIndex=surf
d2354 1
a2354 1
      if (.not. ValidateVectorQuantity(quantity, coherent=.TRUE., stacked=.TRUE., &
d2376 1
a2376 1
      if (.not. interpolate) then 
d2393 1
a2393 1
      if ( (profile == -1) .and. (.not. ignoreGeolocation)) then
d2400 1
a2400 1
        if (lastProfile > l2gp%nTimes ) &
d2405 1
a2405 1
        if (any(abs(l2gp%geodAngle(firstProfile:lastProfile)-&
d2414 1
a2414 1
        if (any(abs(l2gp%time(firstProfile:lastProfile)- &
d2421 1
a2421 1
        if (interpolate .and. quantity%template%noChans /= 1) then
d2440 1
a2440 1
      if (.not. interpolate) then
d2483 1
a2483 1
    subroutine FillVectorQtyFromProfile ( key, quantity, valuesNode, &
a2488 1
      integer, intent(in) :: KEY          ! Tree node
d2789 1
a2789 1
      if (.not. minorFrame ) then
d2800 1
a2800 1
      if (minorFrame ) then
d2811 1
a2811 1
      if (.not. minorFrame ) then
d2877 1
a2877 1
      else if (&
d2892 1
a2892 1
      if (.not. ValidateVectorQuantity ( qty, &
d2905 1
a2905 1
      else if (.not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
d2909 1
a2909 1
      else if (any ( noiseQty%values == 0.0) .and. &
d3009 1
a3009 1
      else if (&
d3024 1
a3024 1
      if (.not. ValidateVectorQuantity ( qty, &
d3037 1
a3037 1
      else if (.not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
d3041 1
a3041 1
      else if (any ( noiseQty%values == 0.0) .and. &
d3069 1
a3069 1
        if( .not. (.not. dontMask .or. ignoreNegative .or. ignoreZero )) then
d3149 1
a3149 1
      else if (&
d3164 1
a3164 1
      if (.not. ValidateVectorQuantity ( qty, &
d3177 1
a3177 1
      else if (.not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
d3181 1
a3181 1
      else if (any ( noiseQty%values == 0.0) .and. &
d3287 1
a3287 1
      endif
d3339 1
a3339 1
      else if ( qty%template%molecule /= vmrQty%template%molecule) then
d3384 1
a3384 1
        endif
d3403 1
a3403 1
        endif
d3416 1
a3416 1
        endif
d3483 1
a3483 1
      else if ( qty%template%molecule /= vmrQty%template%molecule) then
d3539 1
a3539 1
        endif
d3547 1
a3547 1
        endif
d3579 2
a3580 2
          enddo
        endif
d3593 1
a3593 1
        elseif ( firstSurfaceAbove == 1 ) then
d3596 1
a3596 1
        elseif ( firstSurfaceAbove > N ) then
d3603 1
a3603 1
        endif
d3608 1
a3608 1
        endif
d3618 2
a3619 2
          enddo
        endif
d3696 1
a3696 1
      if (.not. ValidateVectorQuantity ( radiance, quantityType=(/l_radiance/), &
d3699 1
a3699 1
      if (.not. ValidateVectorQuantity ( lsb, quantityType=(/l_radiance/), &
d3702 1
a3702 1
      if (.not. ValidateVectorQuantity ( usb, quantityType=(/l_radiance/), &
d3705 1
a3705 1
      if (.not. ValidateVectorQuantity ( lsbFraction, &
d3709 1
a3709 1
      if (.not. ValidateVectorQuantity ( usbFraction, &
d3769 1
a3769 1
    subroutine FillIWCFromExtinction ( key, quantity, &
a3770 1
      integer, intent(in) :: key          ! For messages
d3785 1
a3785 1
      if(.not. (quantity%template%coherent .and. sourceQuantity%template%coherent &
d3789 1
a3789 1
      if(sourceQuantity%template%noInstances /= Quantity%template%noInstances) &
d3793 1
a3793 1
      if(TemperatureQuantity%template%noInstances /= Quantity%template%noInstances) then
d4059 1
a4059 1
            if ( .not. interpolate) then
d4139 1
a4139 1
    subroutine FillNoRadsPerMIF ( key, quantity, measQty )
d4488 1
a4488 1
            if ( .not. interpolate) then
d4610 1
a4610 1
      if (.not. ValidateVectorQuantity ( quantity, &
d4615 1
a4615 1
      if (.not. ValidateVectorQuantity ( radiance, &
d4630 1
a4630 1
      if (.not. ValidateVectorQuantity ( &
d4639 1
a4639 1
        if (.not. ValidateVectorQuantity ( &
d4740 1
a4740 1
          &   geocAltitudeQuantity%template%instrumentModule) )  then
d4809 1
a4809 1
      if (.not. ValidateVectorQuantity ( quantity, quantityType=(/l_cloudInducedRadiance/), &
d4812 1
a4812 1
      if (.not. associated(quantity%mask)) &
d4832 2
a4833 2
      if(sourceQuantity%template%sideband == -1) freq1 = freqL1
      if(sourceQuantity%template%sideband == 1) freq1 = freqU1
d4839 2
a4840 2
      if(quantity%template%sideband == -1) freq2 = freqL2
      if(quantity%template%sideband == 1) freq2 = freqU2
d4843 1
a4843 1
      if (spreadFlag) then
d4846 1
a4846 1
        if (.not. ValidateVectorQuantity ( sourceQuantity, &
d4859 3
a4861 3
            enddo
          enddo
        enddo
d4867 1
a4867 1
        if (.not. ValidateVectorQuantity ( sourceQuantity, &
d4871 1
a4871 1
        if (.not. ValidateVectorQuantity ( lsbFraction, &
d4875 1
a4875 1
        if (.not. ValidateVectorQuantity ( usbFraction, &
d4884 1
a4884 1
        if(.not. associated(usb)) then
d4899 3
a4901 3
              enddo
            enddo
          enddo
d4914 1
a4914 1
          if (.not. ValidateVectorQuantity ( usb, &
d4929 2
a4930 2
          if(usb%template%sideband == -1) freq = freqL
          if(usb%template%sideband == 1) freq = freqU
d4934 1
a4934 1
            if(quantity%template%sideband == 1) then 
d4938 2
a4939 2
            endif
            if(quantity%template%sideband == -1) then
d4943 1
a4943 1
            endif
d4956 3
a4958 3
              enddo
            enddo
          enddo
d4963 2
a4964 2
        endif
      endif
d5027 1
a5027 1
    subroutine FillVectorQtyFromIsotope ( key, quantity, sourceQuantity, &
a5031 1
      integer, intent(in) :: KEY          ! Tree node
d5041 1
a5041 1
      if (.not. ValidateVectorQuantity ( quantity, &
d5046 1
a5046 1
      if (.not. ValidateVectorQuantity ( sourceQuantity, &
d5051 1
a5051 1
      if (.not. ValidateVectorQuantity ( ratioQuantity, &
d5292 1
a5292 1
      endif
d5297 1
a5297 1
      elseif ( this_hdfVersion == WRONGHDFVERSION ) then
d5300 1
a5300 1
      endif
d5419 1
a5419 1
      if (toggle(gen) .and. levels(gen) > 0 ) call trace_end( "FillVectorQuantityFromL1B" )
d5620 1
a5620 1
        endif
d5682 1
a5682 1
      !    if (.not. ValidateVectorQuantity(qty, coherent=.TRUE., stacked=.TRUE., &
d5701 1
a5701 1
      if(extinction) then
d5726 1
a5726 1
              if(colTrans > 0.02_r8) betaFine(i)= transFine(i)/colTrans
d5759 1
a5759 1
          if (ptan%values(mif,maf) .gt. -2.5) cycle ! for testing
d5766 1
a5766 1
            if (ptan%values(mif,maf) < (outZeta(i)+outZeta(i+1))/2. .and. &
d5770 2
a5771 2
          if (ptan%values(mif,maf) < (outZeta(1)+outZeta(2))/2.) minZ=1
          if (ptan%values(mif,maf) > outZeta(qty%template%noSurfs)) cycle ! goto next mif
d5774 1
a5774 1
            if (x_in(noDepths) < (outZeta(i)+outZeta(i+1))/2. .and. &
d5778 2
a5779 2
          if (x_in(noDepths) < (outZeta(1)+outZeta(2))/2.) cycle    ! goto next mif
          if (x_in(noDepths) > outZeta(qty%template%noSurfs)) maxZ=qty%template%noSurfs
d5781 1
a5781 1
          ! get phi along path for each mif (phi is in degree)
d5794 1
a5794 1
              if(phi_out(i) .lt. &     
d6666 2
a6667 2
            if (associated(sq%mask)) then
              if (.not. associated(dq%mask)) call CreateMask ( dq )
d6857 3
@


2.270
log
@Added excludeBelowBottom flag for binmax/binmin fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.269 2004/05/01 04:04:36 vsnyder Exp $"
d48 1
d128 1
a128 1
    use MLSCommon, only: FileNameLen, L1BInfo_T, MLSChunk_T, R4, R8, RM, RV, FindFirst
d6861 3
@


2.269
log
@Use DumpCommand
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.268 2004/04/28 00:30:58 livesey Exp $"
d55 2
a56 1
      & F_ECRTOFOV, F_EARTHRADIUS, F_EXPLICITVALUES, F_EXTINCTION, F_FIELDECR, F_FORCE, &
d324 1
d498 1
d732 2
d1070 1
a1070 1
            & channel, fillMethod, additional )
d6133 1
a6133 1
      & channel, method, additional )
d6145 1
d6189 1
a6189 1
          & allowTopValue=.true. )
d6194 1
a6194 1
            & allowTopValue=.true. )
d6860 3
@


2.268
log
@Added a|b option in manipulate fill.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.267 2004/04/19 21:04:02 livesey Exp $"
d48 1
a115 1
    use LEXER_CORE, only: PRINT_SOURCE
d568 1
a568 39
        ! Currently the only field here is the quantity, but let's
        ! do a loop anyway, as I may add more later
        do j = 2, nsons(key)
          gson = subtree(j,key) ! The argument
          fieldIndex = get_field_id(gson)
          if (nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
          got(fieldIndex) = .true.
          select case ( fieldIndex )
          case ( f_quantity )
            vectorIndex = decoration(decoration(subtree(1,gson)))
            quantityIndex = decoration(decoration(decoration(subtree(2,gson))))
            ! print *, 'vectorIndex: ', vectorIndex
            ! print *, 'quantityIndex: ', quantityIndex
            ! print *, 'size(vector database): ', size(vectors)
            if ( vectorIndex > size(vectors) ) then
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'vector index too big' )
            endif
            ! print *, 'Num of quantities: ', vectors(vectorIndex)%template%noQuantities
            if ( quantityIndex > vectors(vectorIndex)%template%noQuantities ) then
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'quantity index too big' )
            endif
          case ( f_vector )
            vectorIndex = decoration(decoration(gson))
          end select
        end do
        if ( got(f_vector) ) then
          call dump ( vectors(vectorIndex) )
        elseif ( got(f_quantity) ) then
          ! print *, 'About to try to obtain aQuantity'
          aQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(vectorIndex), quantityIndex)
          ! print *, 'About to try to dump aQuantity'
          call dump ( aQuantity )
        else
          call Announce_error ( key, no_error_code, &
          & 'Sorry-dont know how to dump this field' )
        endif
d2358 8
a2365 6
      if ( associated ( quantity%template%frequencies ) ) then
        if ( any ( abs ( l2gp%frequency - &
          & quantity%template%frequencies ) > fTol ) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Quantity and l2pg have different frequency grids' )
      end if
d6679 1
d6854 3
@


2.267
log
@Bug fix in ExtractSingleChannel
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.266 2004/04/16 00:49:03 livesey Exp $"
d5854 1
a5854 1
      integer, parameter :: NOMANIPULATIONS = 5
d5856 1
a5856 1
        & (/ 'a+b', 'a-b', 'a*b', 'a>b', 'a<b' /)
d5963 8
d6889 3
@


2.266
log
@Added extractChannel fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.265 2004/04/13 21:19:10 livesey Exp $"
d2122 1
a2122 1
      chanInd = channel - GetFirstChannel ( quantity%template%signal )
d2125 1
a2125 1
          & sourceQuantity%values ( mif + chanInd * sourceQuantity%template%noChans, : )
d6881 3
@


2.265
log
@Bug fix in negative precision flagging.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.264 2004/04/02 01:06:46 livesey Exp $"
d81 1
a81 1
      & L_ECRTOFOV, L_ESTIMATEDNOISE, L_EXPLICIT, L_FOLD, L_GEODALTITUDE, &
d93 1
a93 1
      & L_LIMBSIDEBANDFRACTION, L_SPD, L_SPECIAL, L_SPREADCHANNEL, &
d135 1
a135 1
    use MLSSignals_m, only: GetSignalName, GetModuleName, IsModuleSpacecraft, &
d1148 7
d2103 26
d6881 3
@


2.264
log
@Got the status filling working.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.263 2004/03/22 18:25:25 livesey Exp $"
d1369 2
a1370 1
          where ( quantity%values >= aprioriPrecision%values*precisionFactor )
d6848 3
@


2.263
log
@Added CombineChannels fill (may actually replace this before too long).
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.262 2004/03/18 17:41:31 livesey Exp $"
d208 2
a209 1
    integer, parameter :: BadUnitsForSystemTemperature = badUnitsForIntegrationTime + 1
d431 1
a431 1
    real(r8) :: STATUSVALUE              ! Vaue of f_status
d524 1
a524 1
      statusValue = 0.0
d965 5
d1691 1
a1691 1
          call FillStatusQuantity ( key, quantity, sourceQuantity, nint ( statusValue ), &
d6388 2
a6389 3

      if ( .not. additional ) &
        & quantity%values = iand ( nint ( quantity%values ), not ( statusValue ) )
d6725 2
d6847 3
@


2.262
log
@Bug fix in quality fill.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.261 2004/03/17 17:16:11 livesey Exp $"
d79 2
a80 2
      & L_CHISQMMAF, L_CHISQMMIF, L_CHOLESKY, &
      & L_cloudice, L_cloudextinction, L_cloudInducedRADIANCE, L_COLUMNABUNDANCE, &
d691 1
a691 1
            & 'Cannot adopt both vector and matrix' )
d1110 8
d6429 75
d6840 3
@


2.261
log
@New status fill and new manipulations.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.260 2004/03/10 22:19:51 livesey Exp $"
d6418 1
a6418 1
      quantity%values(1,:) = 1.0 - tanh ( sourceQuantity%values(surface,1) / scale )
d6757 3
@


2.260
log
@Added quality fill method
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.259 2004/03/03 22:40:59 livesey Exp $"
d61 2
a62 2
      & F_MANIPULATION, F_MATRIX, F_MAXITERATIONS, F_MEASUREMENTS, F_METHOD, &
      & F_MODEL, F_MULTIPLIER, F_NOFINEGRID, F_NOISE, F_NOISEBANDWIDTH, &
d71 1
a71 1
      & F_SOURCEQUANTITY, F_SOURCEVGRID, F_SPREAD, F_SUPERDIAGONAL, &
d94 1
a94 1
      & L_SPLITSIDEBAND, L_SYSTEMTEMPERATURE, &
d372 2
d382 2
d430 1
d505 4
d523 1
d840 4
d849 4
d1332 1
a1332 1
            & manipulation, key )
d1445 1
a1445 1
            if ( .not. all ( got ( (/ f_sourceQuantity, f_height, f_scale /) ) ) ) &
d1447 1
a1447 1
              & 'Need sourceQuanitity, height and scale for quality fill' )
d1656 23
d1694 1
a1694 1
            if ( .not. interpolate) then
d5797 1
a5797 1
    subroutine FillQuantityByManipulation ( quantity, a, b, manipulation, key )
d5804 1
d5843 16
a5858 11
        if ( quantity%template%minorFrame ) then
          okSoFar = okSoFar .and. aorb%template%minorFrame .and. &
            & quantity%template%signal == aorb%template%signal .and. &
            & quantity%template%sideband == aorb%template%sideband .and. &
            & quantity%template%frequencyCoordinate == aorb%template%frequencyCoordinate
        else if ( mstr == 'a*b' ) then
          ! In this case, just check that the coordinate systems for these quantities match
          okSoFar = okSoFar .and. &
            & DoHGridsMatch ( quantity, aorb ) .and. &
            & DoVGridsMatch ( quantity, aorb ) .and. &
            & DoFGridsMatch ( quantity, aorb, sizeOnly=.true. )
d5860 3
a5862 2
          ! For a+/-b these quantities must share a template
          okSoFar = okSoFar .and. quantity%template%name == aorb%template%name
d6281 1
a6281 1
      type (VectorValue_T), intent(in) :: SOURCEQUANTITY
d6287 2
d6299 9
d6314 1
a6314 1
          quantity%values(:,i) = sum ( quantity%values(:,i1:i2), dim=2 ) / (i2-i1+1)
d6320 1
a6320 1
          quantity%values(:,i) = minval ( quantity%values(:,i1:i2), dim=2 )
d6326 1
a6326 1
          quantity%values(:,i) = maxval ( quantity%values(:,i1:i2), dim=2 )
d6330 4
d6337 46
d6402 1
a6402 2
      if ( nsons ( heightNode ) /= 2 ) call Announce_Error ( key, no_error_code, &
        & 'Only one height can be supplied for quality fill' )
d6404 13
a6417 7
      call expr ( heightNode, unitAsArray, valueAsArray )
      height = valueAsArray(1)
      if ( all ( unitAsArray(1) /= (/ PHYQ_Pressure /) ) ) &
        call Announce_Error ( key, 0, 'Bad units for height' )
      ! chisqBinned must be on zeta surfaces already, forced at construction, so take log.
      height = - log10 ( height )
      call Hunt ( sourceQuantity%template%surfs(:,1), height, surface, nearest=.true. )
d6757 3
@


2.259
log
@Added a<b and a>b to manipulations
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.258 2004/03/03 19:26:38 pwagner Exp $"
d56 1
a56 1
      & F_HIGHBOUND, F_H2OQUANTITY, F_H2OPRECISIONQUANTITY, &
d68 1
a68 1
      & F_RHIQUANTITY, F_Rows, &
d78 1
a78 1
      & L_BOUNDARYPRESSURE, L_BOXCAR, L_CHISQCHAN, &
d89 1
a89 1
      & L_PLAIN, L_PRESSURE, L_PROFILE, L_PTAN, &
d338 1
d412 1
d503 1
d514 1
d779 2
d914 5
d1426 8
d6273 35
a6307 1
    ! ----------------------------------------------- OffsetRadianceQuantity ---
d6643 3
@


2.258
log
@More printing if tropopause outside pressure grid
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.257 2004/02/20 00:43:27 pwagner Exp $"
d5744 4
d5759 2
a5760 3
      if ( mstr /= 'a+b' .and. mstr /= 'a-b' .and. mstr /= 'a*b' ) then
        call Announce_Error ( key, 0, &
          & 'Only a+b, a-b, or a*b allowed for manipulation at the moment' )
d5807 2
a5808 1
      if ( mstr .eq. 'a+b' ) then
d5816 1
a5816 2
      end if
      if ( mstr .eq. 'a-b' ) then
d5824 1
a5824 2
      end if
      if ( mstr .eq. 'a*b' ) then
d5832 17
a5848 1
      end if
d6590 3
@


2.257
log
@Clarified warning message when tropopause too big/little
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.256 2004/02/19 23:59:00 pwagner Exp $"
d3508 6
d6572 3
@


2.256
log
@Integrates column abundances using WReads method
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d29 1
a29 1
       "$Id: Fill.f90,v 2.255 2004/02/17 14:08:27 livesey Exp $"
d3225 1
a3225 11
      ! (1)This fill operation is triggered by a command
      !    such as the following in the lcf
      !      Fill, state.columnO3, method=special, vmrQuantity=state.o3, $
      !      boundaryPressure=state.tpPressure
      ! (2)the vmr is in units of PHYQ_VMR and not, say, ppmv;
      !    it is in fact identical to the coefficients of the mls basis functions
      ! (3)The pressure surfaces are in hPa, but not all necessarily at the
      !    same logarithmic distance from one another
      ! (4)The tropospheric boundary pressure is somewhere in between the surfs
      ! (5)Unless first,last instances are args, fill all instances
      !    (unlike join which has to worry about chunks and overlaps)
d3352 1
d3355 1
a3355 11
      ! (1)This fill operation is triggered by a command
      !    such as the following in the lcf
      !      Fill, state.columnO3, method=special, vmrQuantity=state.o3, $
      !      boundaryPressure=state.tpPressure
      ! (2)the vmr is in units of PHYQ_VMR and not, say, ppmv;
      !    it is in fact identical to the coefficients of the mls basis functions
      ! (3)The pressure surfaces are in hPa, but not all necessarily at the
      !    same logarithmic distance from one another
      ! (4)The tropospheric boundary pressure is somewhere in between the surfs
      ! (5)Unless first,last instances are args, fill all instances
      !    (unlike join which has to worry about chunks and overlaps)
d3421 4
d3509 1
a3509 1
          & 'Filling column, but tropopause below 1st surface' )
d6566 3
@


2.255
log
@Added functionality to the box car and binning fills
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.254 2004/02/06 01:01:40 livesey Exp $"
d3194 50
d3249 1
d3308 3
d3334 4
d3348 3
d3356 255
a3610 1
    end subroutine FillColAbundance
d6581 3
@


2.254
log
@Added boxcar fill method
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.253 2004/01/30 23:28:33 livesey Exp $"
d51 2
a52 2
    use INIT_TABLES_MODULE, only: F_A, F_ALLOWMISSING, &
      & F_APRIORIPRECISION, F_B, F_BIN, F_BOUNDARYPRESSURE, &
d86 2
a87 1
      & L_MANIPULATE, L_NEGATIVEPRECISION, L_NOISEBANDWIDTH, L_NONE, &
d297 1
d308 1
d483 1
d485 1
d728 2
d738 2
d1068 1
a1068 1
            & channel, fillMethod )
d1078 2
a1079 1
          call FillWithBoxcarAverage ( key, quantity, sourceQuantity, width )
d5717 1
a5717 1
      & channel, method )
d5728 1
d5733 1
d5829 1
a5829 1
              quantity%values(qs,qi) = maxval ( pack ( sourceQuantity%values ( &
d5833 5
d5840 1
a5840 1
              quantity%values(qs,qi) = sum ( pack ( sourceQuantity%values ( &
d5845 5
d5852 1
a5852 1
              quantity%values(qs,qi) = minval ( pack ( sourceQuantity%values ( &
d5856 5
d5863 1
a5863 1
              quantity%values(qs,qi) = sum ( pack ( sourceQuantity%values ( &
d5867 5
d5887 1
a5887 1
    subroutine FillWithBoxcarAverage ( key, quantity, sourceQuantity, width )
d5892 1
d5907 22
a5928 7
      do i = 1, quantity%template%noInstances
        i1 = max ( i - halfWidth, 1 )
        i2 = min ( i + halfWidth, quantity%template%noInstances )
        quantity%values(:,i) = sum ( quantity%values(:,i1:i2), dim=2 ) / (i2-i1+1)
      end do
        
    end subroutine FillWithBoxcarAverage
d6266 3
@


2.253
log
@Insist on loading a plain matrix
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.252 2004/01/29 03:32:42 livesey Exp $"
d74 1
a74 1
      & F_TYPE, F_USB, F_USBFRACTION, F_VECTOR, F_VMRQUANTITY, &
d78 1
a78 1
      & L_BOUNDARYPRESSURE, L_CHISQCHAN, &
d208 2
a209 1
    integer, parameter :: BadIsotopeFill = badUnitsForSystemTemperature + 1
d446 10
a455 9
    integer :: vmrQtyIndex
    integer :: vmrQtyVctrIndex
    integer :: measQtyIndex
    integer :: measVectorIndex
    integer :: modelQtyIndex
    integer :: modelVectorIndex
    integer :: noiseQtyIndex
    integer :: noiseVectorIndex
    logical :: old_math77_ran_pack      ! To restore math77_ran_pack
d949 5
d1061 10
d5854 28
d6100 2
d6218 3
@


2.252
log
@Made FillCovariance (temporarily?) fill both sides of the digaonal (in
any case was wrongly doing upper).
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.251 2004/01/23 19:07:35 livesey Exp $"
d120 1
a120 1
      & FindBlock, GetKindFromMatrixDatabase, GetFromMatrixDatabase, K_SPD, &
d214 2
a215 1
    integer, parameter :: NotImplemented = notSPD + 1
d658 2
d2108 1
a2108 1
                do k = 1, j -1
a2125 1
                    m(k,j) = meanDiag*thisFraction*exp(-distance/thisLength)
d6117 2
d6171 4
@


2.251
log
@Finished off the adoption stuff
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.250 2004/01/23 05:47:38 livesey Exp $"
d2105 1
a2105 1
                do k = j+1, n
d2123 1
d6167 3
@


2.250
log
@Added the adoption stuff
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.249 2004/01/20 20:26:03 livesey Exp $"
d98 1
a98 1
    use INIT_TABLES_MODULE, only: S_ADOPT, S_DESTROY, S_DUMP, S_FILL, S_FILLCOVARIANCE, &
d111 1
a111 1
    use L2PC_m, only: POPULATEL2PCBINBYNAME, ADOPTMATRIX
d414 1
d648 1
a648 1
      case ( s_adopt )
d657 2
d661 2
d665 12
a676 2
        call GetFromMatrixDatabase ( matrices(matrixToFill), matrix )
        call AdoptMatrix ( matrix, binName, message )
d6166 3
@


2.249
log
@Added the binMean fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.248 2003/12/04 22:19:32 livesey Exp $"
d52 1
a52 1
      & F_APRIORIPRECISION, F_B, F_BOUNDARYPRESSURE, &
d98 1
a98 1
    use INIT_TABLES_MODULE, only: S_DESTROY, S_DUMP, S_FILL, S_FILLCOVARIANCE, &
d100 1
a100 1
      & S_PHASE, S_SNOOP, S_TIME, &
d111 1
d168 1
a168 1
    type (VGrid_T), dimension(:), intent(in) :: vGrids
d299 1
d367 1
d372 1
d647 29
d6151 3
@


2.248
log
@Added ability to fill from l2gpPrecision field
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.247 2003/11/25 21:54:47 livesey Exp $"
d77 1
a77 1
    use INIT_TABLES_MODULE, only: L_ADDNOISE, L_BINMAX, L_BINMIN, L_BINTOTAL, &
d974 1
a974 1
        case ( l_binMax, l_binMin, l_binTotal )
d5748 1
d5753 7
d5761 1
d5767 1
d6118 3
@


2.247
log
@Made the column filling algorithm much less fussy.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.246 2003/11/05 18:37:25 pwagner Exp $"
d55 2
a56 2
      & F_FRACTION, F_GEOCALTITUDEQUANTITY, F_GPHQUANTITY, F_HIGHBOUND, F_H2OQUANTITY, &
      & F_H2OPRECISIONQUANTITY, &
d124 1
a124 1
    use MLSCommon, only: FileNameLen, L1BInfo_T, MLSChunk_T, R8, RM, RV, FindFirst
d323 1
d477 1
d705 2
d1078 2
a1079 1
            & ( quantity, l2gpDatabase(l2gpIndex), interpolate, profile, errorCode, ignoreGeolocation )
d2168 1
a2168 1
      & errorCode, ignoreGeolocation )
d2177 1
a2177 1
      type (L2GPData_T), intent(in) :: L2GP ! L2GP to fill from
d2182 1
d2197 1
d2277 7
d2288 1
a2288 1
          quantity%values=reshape(l2gp%l2gpValue(:,:,firstProfile:lastProfile),&
d2293 1
a2293 1
          quantity%values = spread ( reshape ( l2gp%l2gpValue(:,:,profile), &
d2317 1
a2317 1
            & real(l2gp%l2gpValue(1,:,thisProfile), r8), & ! OldY
d6108 3
@


2.246
log
@Now can dump either entire vector or a single quantity
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.245 2003/10/22 21:17:06 pwagner Exp $"
d3113 1
a3171 10
        elseif ( bndPressQty%values(1,instance) <= 0. ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Cant fill column--zero boundary pressure' )
          call deallocate_test(p, 'p', ModuleName )
          call output('Instance: ', advance='no')
          call output(Instance, advance='yes')
          call announce_error(key, No_Error_code, &
          & ' (Will try to continue)')
          call dump ( bndPressQty )
          return
d3173 4
d3178 1
a3178 1
          & -log10 ( bndPressQty%values(1,instance) ), firstSurface )
d3180 1
a3180 1
          if ( p(surface) <= bndPressQty%values(1, instance)) exit
d6094 3
@


2.245
log
@aPhaseName: Phase added to Fill, Construct sections to time phases
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.244 2003/10/15 23:12:08 livesey Exp $"
d129 2
a130 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, MLSMSG_Deallocate
d546 15
d565 12
a576 1
        call dump ( vectors(vectorIndex) )
d3166 16
d6099 3
@


2.244
log
@Added ResetUnusedRadiances
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.243 2003/10/07 15:44:27 cvuu Exp $"
d99 2
a100 1
      & S_FILLDIAGONAL, S_FLUSHL2PCBINS, S_MATRIX,  S_NEGATIVEPRECISION, S_SNOOP, S_TIME, &
d128 1
a128 1
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
d141 1
a141 1
    use String_Table, only: Display_String
d376 1
d1713 1
a1713 1
      case ( s_negativePrecision ) ! ===============================  Transfer ==
d1754 5
d6056 3
@


2.243
log
@add new flag ignoreGeolocation in subroutine FillVectorQuantityFromL2GP
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.242 2003/09/25 16:41:12 michael Exp $"
d90 1
a90 1
      & L_REFLTEMP, L_RHI, L_RHIFROMH2O, L_RHIPRECISIONFROMH2O, L_ROTATEFIELD, &
d1259 3
d5742 14
d6049 3
@


2.242
log
@magnetic field Elevation angle is constrained to 0-90 degrees.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.241 2003/09/09 22:06:38 livesey Exp $"
d57 2
a58 2
      & F_IGNORENEGATIVE, F_IGNOREZERO, F_INSTANCES, F_INTEGRATIONTIME, &
      & F_INTERNALVGRID, &
d337 1
d476 1
d690 2
d1045 1
a1045 1
            & ( quantity, l2gpDatabase(l2gpIndex), interpolate, profile, errorCode )
d2126 1
a2126 1
      & errorCode )
d2139 1
d2192 3
a2194 1
      if ( profile == -1 ) then
d6032 3
@


2.241
log
@Added resilency to missing radiances.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.240 2003/08/28 00:44:54 livesey Exp $"
d4609 3
a4611 1
              qty%values(surface,instance) = acos ( thisField(3) / strength ) * rad2deg
d6025 3
@


2.240
log
@Made the a*b manipulation even more lenient
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.239 2003/08/21 16:07:17 livesey Exp $"
d4772 1
a4772 1
      
d4798 1
a4798 1
             & trim(nameString) )
d4823 36
a4858 1
      if ( isPrecision ) nameString = trim(nameString) // PRECISIONSUFFIX
d4860 17
a4876 32
      call ReadL1BData ( fileID , nameString, l1bData, noMAFs, flag, &
        & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & NeverFail= .false., hdfVersion=this_hdfVersion )
      ! We'll have to think about `bad' values here .....
      if ( flag /= 0 ) then
        call Announce_Error ( root, errorReadingL1B )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "FillVectorQuantityFromL1B")
        return
      end if
      if ( quantity%template%noInstances /= size ( l1bData%dpField, 3 ) .or. &
        &  quantity%template%instanceLen /= &
        &   size ( l1bData%dpField, 1 ) * size ( l1bData%dpField, 2 ) ) then
        call output ( 'Quantity shape:' )
        call output ( quantity%template%instanceLen )
        call output ( ' ( ' )
        call output ( quantity%template%noChans )
        call output ( ', ' )
        call output ( quantity%template%noSurfs )
        call output ( ' ), ' )
        call output ( quantity%template%noInstances, advance='yes' )
        call output ( 'L1B shape:' )
        call output ( size ( l1bData%dpField, 1 ) )
        call output ( ', ' )
        call output ( size ( l1bData%dpField, 2 ) )
        call output ( ', ' )
        call output ( size ( l1bData%dpField, 3 ), advance='yes' )
        call Announce_Error ( root, no_error_code, 'L1B data is wrong shape' )
        if ( toggle(gen) .and. levels(gen) > 0 ) &
          & call trace_end ( "FillVectorQuantityFromL1B")
        return
      end if
d4878 9
a4886 14
      quantity%values = RESHAPE(l1bData%dpField, &
        & (/ quantity%template%instanceLen, quantity%template%noInstances /) )
      if ( isPrecision ) then
        do column=1, size(quantity%values(1, :))
          do row=1, size(quantity%values(:, 1))
            if ( quantity%values(row, column) < 0.d0 ) &
              & call MaskVectorQty(quantity, row, column)
          end do
        end do
      else if ( present(precisionQuantity) ) then
        do column=1, size(quantity%values(1, :))
          do row=1, size(quantity%values(:, 1))
            if ( isVectorQtyMasked(precisionQuantity, row, column) ) &
              & call MaskVectorQty(quantity, row, column)
a4889 5

      if ( index(switches, 'l1b') /= 0 ) &
        & call Dump( l1bData )
      call DeallocateL1BData(l1bData)

d6023 3
@


2.239
log
@Now calls FlushLockedBins (LinearizedForwardModel) rather than
FlushL2PCBins (which is called by the former), as we want it also to
forget which bin it chose.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.238 2003/08/20 20:05:42 livesey Exp $"
d5324 1
a5324 1
            & DoFGridsMatch ( quantity, aorb )
d6013 5
@


2.238
log
@Added the a*b possibility to the manipulation fill.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.237 2003/08/16 00:29:37 vsnyder Exp $"
d110 1
a110 1
    use L2PC_m, only: FLUSHL2PCBINS
d608 1
a608 1
        call FlushL2PCBins
d6013 3
@


2.237
log
@Correct a blunder: deg2rad should have been rad2deg
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.236 2003/08/15 23:58:48 vsnyder Exp $"
d5275 1
a5275 1
      type (VectorValue_T), intent(inout) :: A
d5281 4
d5286 3
d5290 1
a5290 1
      if ( mstr /= 'a+b' .and. mstr /= 'a-b' ) then
d5292 1
a5292 1
          & 'Only a+b or a-b allowed for manipulation at the moment' )
d5295 3
a5297 9
      ! Check that this operation makes sense. Most of the time this means that
      ! the quantities have the same template. In some cases however, we can be
      ! a little more lenient
      if ( a%template%name /= quantity%template%name .and. .not. ( &
          &  ( a%template%minorFrame .and. quantity%template%minorFrame ) .and. &
          &  ( a%template%signal == quantity%template%signal ) .and. &
          &  ( a%template%sideband == quantity%template%sideband ) .and. &
          &  ( a%template%frequencyCoordinate == &
          &      quantity%template%frequencyCoordinate ) ) ) then
d5299 1
a5299 1
          & 'a is not of the same (or close enough) type as quantity' )
d5302 29
a5330 7
      if ( associated ( b ) ) then
        if ( b%template%name /= quantity%template%name .and. .not. ( &
          &  ( b%template%minorFrame .and. quantity%template%minorFrame ) .and. &
          &  ( b%template%signal == quantity%template%signal ) .and. &
          &  ( b%template%sideband == quantity%template%sideband ) .and. &
          &  ( b%template%frequencyCoordinate == &
          &      quantity%template%frequencyCoordinate ) ) ) then
d5332 1
a5332 1
            & 'b is not of the same (or close enough) type as quantity' )
d5335 2
a5336 6
      else
        ! Later we'll be more tolerant of this
        call Announce_Error ( key, 0, &
          & 'You did not supply a b quantity' )
        return
      end if
d5339 1
a5339 1
      if(mstr .eq. 'a+b') then
d5348 1
a5348 1
      if(mstr .eq. 'a-b') then
d5357 10
d6013 3
@


2.236
log
@Add MagAzEl fill method
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.235 2003/08/13 19:23:45 vsnyder Exp $"
d148 1
a148 1
    use UNITS, only: Deg2Rad
d5244 1
a5244 1
            & - atan(sLevel/(re%values(1,maf)*0.001_r8 + zt(mif)))*deg2rad
d5984 3
@


2.235
log
@Make an error message more informative
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.234 2003/08/08 23:07:02 livesey Exp $"
d85 1
a85 1
      & L_L2AUX, L_LOSVEL, L_MAGNETICFIELD, L_MAGNETICMODEL, &
d148 1
a148 1
    use UNITS, only: PI
d1189 6
d4627 2
a4628 2
    subroutine ExplicitFillVectorQuantity(quantity, valuesNode, spreadFlag, globalUnit, &
      & dontmask)
d4639 4
d4647 2
a4648 2
      integer, DIMENSION(2) :: unitAsArray ! Unit for value given
      real (r8), DIMENSION(2) :: valueAsArray ! Value given
d4650 2
a4651 1
      integer :: noValues
d4655 3
d4663 2
d4681 37
a4717 8
      do k = 1, noValues
        call expr(subtree(k+1,valuesNode),unitAsArray,valueAsArray)
        ! Check unit OK
        if ( (unitAsArray(1) /= testUnit) .and. &
          &  (unitAsArray(1) /= PHYQ_Dimensionless) ) &
          & call Announce_error ( valuesNode, badUnitsForExplicit )
        values ( k ) = valueAsArray(1)
      end do
d5244 1
a5244 1
            & - atan(sLevel/(re%values(1,maf)*0.001_r8 + zt(mif)))*180._r8/Pi
d5814 4
d5856 8
d5984 3
@


2.234
log
@Added the rotate field fill.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.233 2003/07/16 22:39:47 livesey Exp $"
d4657 3
a4659 1
          & call Announce_Error ( valuesNode, invalidExplicitFill )
d5826 4
a5829 1
        call output ( " has inappropriate dimensionality for explicit fill.", advance='yes' )
d5927 3
@


2.233
log
@Bug fix in fill from l2aux
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.232 2003/07/08 00:17:46 livesey Exp $"
d54 1
a54 1
      & F_EARTHRADIUS, F_EXPLICITVALUES, F_EXTINCTION, F_FORCE, &
d90 2
a91 2
      & L_REFLTEMP, L_RHI, L_RHIFROMH2O, L_RHIPRECISIONFROMH2O, L_SCALEOVERLAPS, &
      & L_SCECI, L_SCGEOCALT, L_SCVEL, L_SCVELECI, L_SCVELECR, &
d254 2
d310 2
d316 2
d660 3
d667 3
d1290 1
a1290 1
        case ( l_RHIPrecisionfromH2O ) ! --fill RHI prec. from H2O quantity --
d1342 3
a1344 3

        case ( l_scaleOverlaps )
            if ( .not. got ( f_multiplier ) ) then
d1346 1
a1346 1
                & 'Must supply multipler for scaleOverlaps fill' )
d1348 5
a1352 1
              call ScaleOverlaps ( key, quantity, multiplierNode, dontMask )
d1355 8
d4549 71
d5922 3
@


2.232
log
@Bug fix in column filling
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.231 2003/06/24 19:59:42 livesey Exp $"
d4765 1
a4765 1
      if ( lastProfile > lbound ( l2aux%values, 3 ) ) then
d5827 3
@


2.231
log
@Fixed something in OffsetRadianceQuantity that might have become a bug
one day (assumed m_linAlg=1).
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.230 2003/06/20 19:37:06 pwagner Exp $"
d3087 1
a3087 1
      p = 10.0 ** ( - vmrQty%template%surfs(:,instance) )
d5827 4
@


2.230
log
@Quanities now share grids stored separately in databses
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.229 2003/06/05 22:08:55 livesey Exp $"
d5544 1
a5544 1
      where ( iand ( ichar(radianceQuantity%mask), m_linAlg ) == 1 )
d5827 3
@


2.229
log
@Cosmetic and superficial changes to FillFromSplitSideband
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.228 2003/06/03 19:23:51 livesey Exp $"
d1515 1
a1515 1
          quantity%values = spread ( vGrids(vGridIndex)%surfs, 2, &
d1927 2
a1928 2
        if ( covariance%m%row%vec%template%id /= &
          & dMasked%template%id ) call MLSMessage ( MLSMSG_Error, &
d1931 2
a1932 2
          if ( covariance%m%row%vec%template%id /= &
            & lMasked%template%id ) call MLSMessage ( MLSMSG_Error, &
d1941 2
a1942 2
          if ( covariance%m%row%vec%template%id /= &
            & vectors(fraction)%template%id ) call MLSMessage ( MLSMSG_Error, &
d4746 3
a4748 1

d4751 24
a4774 2
      ! Should check maybe that the following reshape will work
      ! otherwise return informative errorcode
d4776 1
a4776 2
        & qty%template%mafIndex(1)+1 : &
        & qty%template%mafIndex(qty%template%noInstances)+1 ), &
d5315 1
a5315 1
          & grid%surfs, tFine, method='Spline' )
d5318 1
a5318 1
          & grid%surfs, tFine, grid%surfs, &
d5330 1
a5330 1
        call Hunt ( grid%surfs, -log10(500.0_r8), s500 )
d5376 2
a5377 2
            & grid%surfs(s-1) + &
            & ( grid%surfs(s) - grid%surfs(s-1) ) * ( dTdH(s-1) - 2.0 ) / &
d5380 1
a5380 1
          tpPres%values(1,i) = 10.0 ** ( - grid%surfs(s) )
d5827 3
@


2.228
log
@Added flushL2PCBins
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.227 2003/05/29 20:01:55 livesey Exp $"
a4240 1
!      type (Signal_T), dimension(2) :: signals
d4246 1
a4246 1
      
d4255 1
a4255 1
         & call Announce_Error ( key, 0, 'Quantity must be a subset to fill' )
d4259 1
a4259 1
      
d4271 1
a4271 1
               & signalIn%direction*signalIn%frequencies    ! lower sideband freq
d4273 3
a4275 3
               & signalIn%direction*signalIn%frequencies     ! upper sideband freq
         if(sourceQuantity%template%sideband == -1) freq1 = freqL1
         if(sourceQuantity%template%sideband == 1) freq1 = freqU1
d4278 1
a4278 1
               & signalOut%direction*signalOut%frequencies      ! lower sideband freq
d4280 3
a4282 3
               & signalOut%direction*signalOut%frequencies    ! upper sideband freq
         if(quantity%template%sideband == -1) freq2 = freqL2
         if(quantity%template%sideband == 1) freq2 = freqU2
d4286 6
a4291 5
      ! spread a cloudy radiance to other bands according to the f^4 law
      ! The source cloudy radiance must be from a single sideband signal
        if (.not. ValidateVectorQuantity ( sourceQuantity, quantityType=(/l_cloudInducedRadiance/), &
        & sideband=(/-1,1/), minorFrame=.true. )) &
        & call Announce_Error ( key, 0, 'Inappropriate sourceQuantity radiance for fill' )
d4293 10
a4302 8
           do maf=1, quantity%template%noInstances
           do mif=1, quantity%template%noSurfs
	          scaledRad = sourceQuantity%values(MyChannel+(mif-1)*size(signalIn%frequencies), maf) * &
             &    freq2(i)**4/freq1(MyChannel)**4
             if(iand(ichar(Quantity%mask(i+(mif-1)*size(signalOut%frequencies), maf)), m_cloud) == 16) &
             & quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = scaledRad
   	     enddo
	        enddo
d4304 1
a4304 1
              
d4306 2
a4307 2
      ! split two sideband radiances according to the f^4 law
      ! The source cloudy radiance must be from the same signal of double sideband 
d4310 3
a4312 3
        & quantityType=(/l_cloudInducedRadiance/), &
        & sideband=(/0/), signal=(/quantity%template%signal/), minorFrame=.true. )) &
        & call Announce_Error ( key, 0, 'Inappropriate sourceQuantity radiance for fill' )
d4327 48
a4374 42
        ! If both sidebands are within 20GHz and have similar penetration depths
        ! in the attenuative atmosphere. We can neglect the attenuation and split cloudy
        ! radiances assuming that they are fully due to scattering and obey the f^4 law.
         do i=1,size(signalOut%frequencies)
           do maf=1, quantity%template%noInstances
           do mif=1, quantity%template%noSurfs
             if(iand(ichar(Quantity%mask(i+(mif-1)*size(signalOut%frequencies), maf)), m_cloud) == 16) &
	          & quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = &
	          &   sourceQuantity%values(MyChannel+(mif-1)*size(signalIn%frequencies), maf) *freq2(i)**4/ &
	          &   (lsbFraction%values(MyChannel,1) * freqL1(MyChannel)**4 + &
	          &   usbFraction%values(MyChannel,1) * freqU1(MyChannel)**4)
   	     enddo
	        enddo
         enddo
        else
        ! If both sidebands are within 20GHz but have very different penetration depths,
        ! where one is optically thick and one is optically thin. We may use a reference
        ! cloud radiance near the optically-thin sideband to split cloud radiance in the
        ! optically-thick sideband. The reference radiance must be a single sideband 
        ! radiance in this case, namely usb (upper sideband in most cases). The usb is 
        ! scaled to the sourceQty upperside (thin) via the f^4 law, and the rest cloud
        ! radiance is for the lower sideband.
        !
        ! In this case, channel will for the reference signal and sideband frac remains for
        ! source signal.
        !
         if (.not. ValidateVectorQuantity ( usb, &
          & quantityType=(/l_cloudInducedRadiance/), sideband=(/-1,1/), minorFrame=.true. )) &
          & call Announce_Error ( key, 0, 'Inappropriate reference radiance for splitting' )

            signalRef = GetSignal ( usb%template%signal )

            call allocate_test ( freq, size(signalRef%frequencies), 'frequencies', ModuleName )
            call allocate_test ( freqL, size(signalRef%frequencies), 'LSBfrequencies', ModuleName )
            call allocate_test ( freqU, size(signalRef%frequencies), 'USBfrequencies', ModuleName )
            freq = signalRef%centerFrequency + signalRef%direction*signalRef%frequencies 
            freqL = signalOut%lo - freq    ! lower sideband freq
            freqU = signalOut%lo + freq    ! upper sideband freq
               if(usb%template%sideband == -1) freq = freqL
               if(usb%template%sideband == 1) freq = freqU
            do i=1,size(signalOut%frequencies)
         
d4376 29
a4404 27
               if(quantity%template%sideband == 1) then 
                  ratio1 = lsbFraction%values(i,1)
                  ratio2 = usbFraction%values(i,1)
                  freq2 = freqL2
               endif
               if(quantity%template%sideband == -1) then
                  ratio2 = lsbFraction%values(i,1)
                  ratio1 = usbFraction%values(i,1)
                  freq2 = freqU2
               endif

               do maf=1, quantity%template%noInstances
               do mif=1, quantity%template%noSurfs
	               scaledRad = usb%values(MyChannel+(mif-1)*size(signalIn%frequencies), maf) * &
                  &    freq2(i)**4/freq(MyChannel)**4

                  if(iand(ichar(Quantity%mask(i+(mif-1)*size(signalOut%frequencies), maf)), m_cloud) == 16) &
	               & quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = &
	               &   (sourceQuantity%values(i+(mif-1)*size(signalIn%frequencies), maf) - &
                  &    ratio1*scaledRad)/ratio2 
   	         enddo
	            enddo
            enddo        

            call deallocate_test ( freq, 'frequencies', ModuleName )
            call deallocate_test ( freqL,'LSBfrequencies', ModuleName )
            call deallocate_test ( freqU,'USBfrequencies', ModuleName )
d5804 3
@


2.227
log
@Added reflector temperature model.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.226 2003/05/29 16:41:56 livesey Exp $"
d99 1
a99 1
      & S_FILLDIAGONAL, S_MATRIX,  S_NEGATIVEPRECISION, S_SNOOP, S_TIME, &
d110 1
d601 3
d5194 2
a5195 2
          quantity%values(1,:) = quantity%values(1,:) + valueAsArray(1) * &
            & sin ( Deg2Rad * ((i+1)/2) * ( quantity%template%phi(1,:) - phiZero ) )
d5198 2
a5199 2
          quantity%values(1,:) = quantity%values(1,:) + valueAsArray(1) * &
            & cos ( Deg2Rad * ((i+1)/2) * ( quantity%template%phi(1,:) - phiZero ) )
d5794 3
@


2.226
log
@Renamed sideband fraction
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.225 2003/05/28 06:00:06 livesey Exp $"
d64 1
a64 1
      & F_PHIWINDOW, F_PRECISION, F_PRECISIONFACTOR, &
d73 1
a73 1
      & F_TEMPLATE, F_TNGTECI, &
d89 2
a90 2
      & L_RADIANCE, L_RECTANGLEFROMLOS, L_REFGPH, L_REFRACT, L_RHI, &
      & L_RHIFROMH2O, L_RHIPRECISIONFROMH2O, L_SCALEOVERLAPS, &
d370 1
d413 1
d483 1
d766 5
d832 2
d1230 3
d5161 40
d5790 3
@


2.225
log
@Bug fix in profile fill where the 'latching' to the output surfaces was
leading to redundancy in the interpolation
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.224 2003/05/26 06:32:50 livesey Exp $"
d92 1
a92 1
      & L_SIDEBANDRATIO, L_SPD, L_SPECIAL, L_SPREADCHANNEL, &
d3129 2
a3130 1
      if (.not. ValidateVectorQuantity ( lsbFraction, quantityType=(/l_sidebandRatio/), &
d3133 2
a3134 1
      if (.not. ValidateVectorQuantity ( usbFraction, quantityType=(/l_sidebandRatio/), &
d4294 8
a4301 6
        if (.not. ValidateVectorQuantity ( lsbFraction, quantityType=(/l_sidebandRatio/), &
        & signal=(/quantity%template%signal/), sideband=(/-1/) ) ) &
        & call Announce_Error ( key, 0, 'Inappropriate lsbFraction quantity for fill' )
        if (.not. ValidateVectorQuantity ( usbFraction, quantityType=(/l_sidebandRatio/), &
        & signal=(/quantity%template%signal/), sideband=(/1/) ) ) &
        & call Announce_Error ( key, 0, 'Inappropriate usbFraction quantity for fill' )
d5737 4
@


2.224
log
@Various mainly cosmetic changes to the column stuff
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.223 2003/05/22 02:23:15 livesey Exp $"
d2241 1
d2253 1
d2274 1
a2274 1
      nullify ( heights, values, outHeights, outValues, instances )
d2277 1
d2331 12
a2342 1
        heights = outHeights ( inInds )
d2347 1
a2347 1
      call InterpolateValues ( heights, values, outHeights, &
d2385 1
d5733 3
@


2.223
log
@Rewrite of explicit fill to make spread option more flexible.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.222 2003/05/22 00:26:33 dwu Exp $"
d2969 1
a2969 1
    & firstInstance, lastInstance )
d2990 4
a2993 3
      type (VectorValue_T), intent(in) ::    bndPressQty
      type (VectorValue_T), intent(in) ::    vmrQty
      integer, intent(in), optional ::       firstInstance, lastInstance
d2997 3
d3001 11
a3011 14
      real (r8) :: AoverMg         ! A/(M g) from Appendix A
      logical ::   zeta_surfs      ! If true, surfs are zeta-type; else pressures
      integer ::   status
      integer ::   surface
      integer ::   instance
      integer ::   surfaceInstance
      integer ::   firstSurface
      integer ::   UseFirstInstance, UseLastInstance, &
      &            NoOutputInstances
      real (r8) :: columnSum
      real (r8) :: Delta_p_plus    ! p[j+1] - p[j]
      real (r8) :: Delta_p_minus   ! p[j-1] - p[j]
      real (r8) :: Delta_log_plus  ! ln p[j+1] - ln p[j]
      real (r8) :: Delta_log_minus ! ln p[j-1] - ln p[j]
d3013 1
a3013 1
      real (r8), allocatable, dimension(:) :: p         ! p[i] in hPa
d3020 2
a3021 2
            call Announce_error ( key, No_Error_code, &
                & 'Wrong quantity type found while filling column abundance'  )
d3024 2
a3025 2
            call Announce_error ( key, No_Error_code, &
                & 'Attempt to fill column abundance with different molecule'  )
d3027 4
a3030 9
      else if ( &
      & .not. ( &
      & DoHgridsMatch( qty, vmrQty ) &
      & .and. &
      & DoHgridsMatch( qty, bndPressQty ) &
      & ) &
      & ) then
            call Announce_error ( key, No_Error_code, &
                & 'Attempt to fill column abundance with different HGrids'  )
d3032 4
a3035 5
      else if ( .not. &
      & any(vmrQty%template%verticalCoordinate == (/l_pressure, l_zeta/)) &
      & ) then
            call Announce_error ( key, No_Error_code, &
                & 'Fill column abundance, but vmr not on [log]pressure surfs.'  )
d3040 5
a3045 12
      if ( PRESENT(firstInstance) ) then
        useFirstInstance = firstInstance
      else
        useFirstInstance = 1
      end if

      if ( PRESENT(lastInstance) ) then
        useLastInstance = lastInstance
      else
        useLastInstance = qty%template%noInstances
      end if
      noOutputInstances = useLastInstance-useFirstInstance+1
d3048 14
a3061 41
     !    AoverMg = 4.12e25 / (2.687e20 * 0.192)
     !    This assumes that
     ! (1) p is in hPa
     ! (2) f is in PHYQ_vmr (*not* ppmv)
     AoverMg = 4.12e5 / (2.687 * 0.192)

     zeta_surfs = vmrQty%template%verticalCoordinate == l_zeta
     allocate(p(vmrQty%template%noSurfs), stat=status)
     if(status /= 0) then
            call Announce_error ( key, No_Error_code, &
                & 'Error in allocating p'  )
        return
     end if   
  !   do instance=1, vmrQty%template%noInstances
     do instance=useFirstInstance, useLastInstance
        if(vmrQty%template%coherent) then
           surfaceInstance=1
        else
           surfaceInstance=instance
        end if

        if(zeta_surfs) then
           ! Invert zeta = -log10(p)
           do surface=1, vmrQty%template%noSurfs
              p(surface) = exp(-log(10.)* &
              & vmrQty%template%surfs(surface, surfaceInstance))
           end do
        else
           do surface=1, vmrQty%template%noSurfs
              p(surface) = vmrQty%template%surfs(surface, surfaceInstance)
           end do
        end if

        if(p(1) &
           &  < bndPressQty%values(1, instance)) then
            call Announce_error ( key, No_Error_code, &
                & 'Fill column abundance, but tropopause below VGrid'  )
        end if

     ! Find 1st surface at or above tropopause
     ! (i.e., at a pressure equal to or less than boundaryPressure)
d3063 1
a3063 2
           if(p(surface) &
           &  <= bndPressQty%values(1, instance)) exit
d3065 4
a3068 8
        firstSurface = surface
        if(firstSurface > vmrQty%template%noSurfs-2) then
            call Announce_error ( key, No_Error_code, &
                & 'Fill column abundance, but tropopause above VGrid'  )
        end if
     ! Do summation
     ! Initialize sum, Deltas
        columnSum = 0.
d3071 10
a3080 13
     ! Loop over surfaces from tropoause+1 to uppermost-1
        do surface = firstSurface+1, vmrQty%template%noSurfs-1
           Delta_p_minus = - Delta_p_plus
           Delta_log_minus = - Delta_log_plus
           Delta_p_plus = p(surface+1) - p(surface)
           Delta_log_plus = log(p(surface+1)) - log(p(surface))
           columnSum = columnSum + &
           & vmrQty%values(surface, instance)* &
           & ( &
           & Delta_p_minus/Delta_log_minus &
           & - &
           & Delta_p_plus/Delta_log_plus &
           & )          
d3082 2
a3083 8
        qty%values(1, instance) = AoverMg * columnSum
     end do

     deallocate(p, stat=status)
     if(status /= 0) then
            call Announce_error ( key, No_Error_code, &
                & 'Error in deallocating p'  )
     end if   
d3085 1
d5718 3
@


2.222
log
@fix a problem in iwcfromextinction
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.221 2003/05/21 18:58:57 dwu Exp $"
d4551 2
d4557 1
d4559 11
a4569 1
      if (spreadFlag) then ! 1 instance/value given, spread to all instances
d4571 17
a4587 15
        ! Check we have the right number of values
        if ( ( (nsons(valuesNode)-1 /= quantity%template%instanceLen) .and. &
          &    (nsons(valuesNode)-1 /= 1) ) .or. &
          &  (.not. quantity%template%regular)) &
          & call Announce_error ( valuesNode, invalidExplicitFill )

        ! Loop over the values
        do k=1,nsons(valuesNode)-1
          ! Get value from tree
          call expr(subtree(k+1,valuesNode),unitAsArray,valueAsArray)
          ! Check unit OK
          if ( (unitAsArray(1) /= testUnit) .and. &
            &  (unitAsArray(1) /= PHYQ_Dimensionless) ) &
            & call Announce_error ( valuesNode, badUnitsForExplicit )
          ! Store value
d4589 1
a4589 16
            if ( nsons(valuesNode)-1 == 1 ) then
              where ( iand ( ichar(quantity%mask), m_Fill ) == 0 )
                quantity%values=valueAsArray(1)
              end where
            else
              where ( iand ( ichar(quantity%mask(k,:)), m_Fill ) == 0 )
                quantity%values(k,:)=valueAsArray(1)
              end where
            end if
          else
            ! No mask to worry about
            if (nsons(valuesNode)-1 == 1) then
              quantity%values=valueAsArray(1)
            else
              quantity%values(k,:)=valueAsArray(1)
            end if
d4591 1
d4593 1
d4595 2
a4596 1
      else                              ! Not spread, fill all values
a4597 24
        ! Check we have the right number of values
        if (nsons(valuesNode)-1 /= &
          & quantity%template%noInstances*quantity%template%instanceLen) &
          & call Announce_error ( valuesNode, invalidExplicitFill )

        ! Loop over values
        do k=1,nsons(valuesNode)-1
          ! Get value from tree
          call expr(subtree(k+1,valuesNode),unitAsArray,valueAsArray)
          ! Check unit OK
          if ( (unitAsArray(1) /= testUnit) .and. &
            &  (unitAsArray(1) /= PHYQ_Dimensionless) ) &
            & call Announce_error ( valuesNode, badUnitsForExplicit )
          ! Store value
          i = mod(k-1,quantity%template%instanceLen) + 1
          j = (k-1) / quantity%template%instanceLen + 1
          if ( .not. dontMask .and. associated ( quantity%mask ) ) then
            if ( iand ( ichar(quantity%mask(i,j)), m_Fill ) == 0 ) &
              & quantity%values(i,j) = valueAsArray(1)
          else
            quantity%values(i,j) = valueAsArray(1)
          end if
        end do
      end if
d5770 3
@


2.221
log
@allow temperature and iwc on different hGrids in iwcFromExtinction
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.220 2003/05/21 18:04:30 livesey Exp $"
d3235 1
d3237 3
d3241 2
a3242 4
      real (r8), dimension(Temperaturequantity%template%noSurfs) :: zt
      real (r8), dimension(sourceQuantity%template%noSurfs) :: ze
      ! new temperature on the same hGrid as in quantity
      real (r8), dimension(Temperaturequantity%template%noSurfs,quantity%template%noInstances) :: temp 
d3254 2
d3257 3
a3259 2
           call InterpolateValues( temp(i,:), TemperatureQuantity%values(i, :), &
             & quantity%template%phi(1,:),TemperatureQuantity%template%phi(1,:) , 'Linear' )
d3265 11
a3275 1
      do i=1, quantity%template%noInstances
d3277 5
a3281 5
        if ( quantity%template%verticalCoordinate == l_pressure ) then 
          z = -log10 ( quantity%template%surfs(:,i) )             
        else                                                           
          z = quantity%template%surfs(:,i)            
        end if
d3283 5
a3287 17
        if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then 
          ze = -log10 ( sourceQuantity%template%surfs(:,i) )             
        else                                                           
          ze = sourceQuantity%template%surfs(:,i)            
        end if
        
        if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then 
          zt = -log10 ( Temperaturequantity%template%surfs(:,i) )             
        else                                                           
          zt = Temperaturequantity%template%surfs(:,i)            
        end if
        
        call InterpolateValues( Tz, Temp(:, i), &
             & z, zt, 'Linear', extrapolate='Constant' )
        call InterpolateValues( Ez, sourceQuantity%values(:, i), &
             & z, ze, 'Linear', extrapolate='Constant' )
             
d5791 3
@


2.220
log
@Added a bit more intelligence to FillCovariance
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.219 2003/05/20 23:10:24 dwu Exp $"
d3239 2
a3242 6
      if(sourceQuantity%template%noInstances /= Quantity%template%noInstances) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "IWC and Extinction profile numbers are not matched")
      if(TemperatureQuantity%template%noInstances /= Quantity%template%noInstances) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "IWC and Temperature profile numbers are not matched")
d3247 12
d3280 1
a3280 1
        call InterpolateValues( Tz, TemperatureQuantity%values(:, i), &
d5788 3
@


2.219
log
@complete the addition of fill IWC from extinction
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.218 2003/05/20 20:20:01 dwu Exp $"
d1885 1
d1951 1
d1980 4
a1983 2
                  if ( thisLength > 0.0 ) &
                    & m(j,k) = meanDiag*thisFraction*exp(-distance/thisLength)
d1995 7
a2001 1
              call MatrixInversion(M, upper=.true.)
d5780 3
@


2.218
log
@add IWCfromExtinction
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.217 2003/05/15 19:09:17 dwu Exp $"
d1118 1
a1118 1
        case ( l_IWCfromExtinction ) ! -------fill H2O from RHI quantity -------
d3222 2
a3223 2
      type (VectorValue_T), intent(inout) :: QUANTITY ! (rhi) Quantity to fill
      type (VectorValue_T), intent(in) :: sourceQuantity ! extinction
d3225 5
d3231 46
d5770 3
@


2.217
log
@changes in splitsideband
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.216 2003/05/14 23:14:00 dwu Exp $"
d53 2
a54 2
      & F_CHANNEL, F_COLUMNS, F_DESTINATION, F_DIAGONAL, F_dontMask, F_EARTHRADIUS, &
      & F_EXPLICITVALUES, F_EXTINCTION, F_FORCE, &
d79 2
a80 1
      & L_CHISQMMAF, L_CHISQMMIF, L_CHOLESKY, L_cloudInducedRADIANCE, L_COLUMNABUNDANCE, &
d83 2
a84 2
      & L_HEIGHT, &
      & L_HYDROSTATIC, L_ISOTOPE, L_ISOTOPERATIO, L_KRONECKER, L_L1B, L_L2GP, &
d1118 29
d3217 11
d5719 3
@


2.216
log
@nullify pointers in splitsideband
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.215 2003/05/12 23:53:55 dwu Exp $"
d130 1
a130 1
      & GetSignal, Signal_T
d4146 1
d4163 2
a4164 2
      signalIn = GetSignal ( sourceQuantity%template%signal )
      signalOut = GetSignal ( Quantity%template%signal )
d4166 1
a4166 1
      myChannel = channel - lbound ( signalIn%frequencies, 1 ) + 1
d4176 6
a4181 5
      freq1 = signalIn%centerFrequency + signalIn%direction*signalIn%frequencies 
      freqL1 = signalIn%lo - freq1    ! lower sideband freq
      freqU1 = signalIn%lo + freq1    ! upper sideband freq
         if(signalIn%sideband == -1) freq1 = freqL1
         if(signalIn%sideband == 1) freq1 = freqU1
d4183 6
a4188 5
      freq2 = signalOut%centerFrequency + signalOut%direction*signalOut%frequencies 
      freqL2 = signalOut%lo - freq2    ! lower sideband freq
      freqU2 = signalOut%lo + freq2    ! upper sideband freq
         if(signalOut%sideband == -1) freq2 = freqL2
         if(signalOut%sideband == 1) freq2 = freqU2
d4202 1
a4202 1
             if(iand(ichar(Quantity%mask(i+(mif-1)*size(signalOut%frequencies), maf)), m_cloud) == 1) &
d4234 1
a4234 1
             if(iand(ichar(Quantity%mask(i+(mif-1)*size(signalOut%frequencies), maf)), m_cloud) == 1) &
d4241 1
a4241 1
         enddo        
d4266 2
a4267 2
               if(signalRef%sideband == -1) freq = freqL
               if(signalRef%sideband == 1) freq = freqU
d4271 1
a4271 1
               if(signalOut%sideband == 1) then 
d4276 1
a4276 1
               if(signalOut%sideband == -1) then
d4287 1
a4287 1
                  if(iand(ichar(Quantity%mask(i+(mif-1)*size(signalOut%frequencies), maf)), m_cloud) == 1) &
d5678 3
@


2.215
log
@fix a bug in splitsideband
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.214 2003/05/12 22:11:07 dwu Exp $"
d4153 1
d5675 3
@


2.214
log
@add more checkpoints in splitsideband
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.213 2003/05/11 00:05:06 livesey Exp $"
d4144 1
a4144 1
      integer :: mif, maf
a4165 3
      call allocate_test ( freq, size(signalIn%frequencies), 'frequencies', ModuleName )
      call allocate_test ( freqL, size(signalIn%frequencies), 'LSBfrequencies', ModuleName )
      call allocate_test ( freqU, size(signalIn%frequencies), 'USBfrequencies', ModuleName )
d4255 4
d4264 1
a4264 1
         do i=1,size(signalOut%frequencies)
d4266 28
a4293 25
           ! need to scale the opposite sideband for the output signal
           if(signalOut%sideband == 1) then 
               ratio1 = lsbFraction%values(i,1)
               ratio2 = usbFraction%values(i,1)
               freq2 = freqL2
           endif
           if(signalOut%sideband == -1) then
               ratio2 = lsbFraction%values(i,1)
               ratio1 = usbFraction%values(i,1)
               freq2 = freqU2
           endif

           do maf=1, quantity%template%noInstances
           do mif=1, quantity%template%noSurfs
	          scaledRad = usb%values(MyChannel+(mif-1)*size(signalIn%frequencies), maf) * &
             &    freq2(i)**4/freq(MyChannel)**4

             if(iand(ichar(Quantity%mask(i+(mif-1)*size(signalOut%frequencies), maf)), m_cloud) == 1) &
	          & quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = &
	          &   (sourceQuantity%values(i+(mif-1)*size(signalIn%frequencies), maf) - &
             &    ratio1*scaledRad)/ratio2 
   	     enddo
	        enddo
         enddo        

a4296 3
      call deallocate_test ( freq, 'frequencies', ModuleName )
      call deallocate_test ( freqL,'LSBfrequencies', ModuleName )
      call deallocate_test ( freqU,'USBfrequencies', ModuleName )
d5674 3
@


2.213
log
@Informative error message when L1B data wrong size
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.212 2003/05/10 23:40:27 livesey Exp $"
d4153 2
d4157 3
a4159 1
        & call Announce_Error ( key, 0, 'Inappropriate radiance quantity to fill' )
d5673 3
@


2.212
log
@Bug fixes in bining, other general tidyups.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.211 2003/05/10 22:20:12 livesey Exp $"
d4601 14
d5669 3
@


2.211
log
@Made wmo tropopause resilient to being given stupid (i.e. 0) profiles.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.210 2003/05/10 01:07:58 livesey Exp $"
d3506 1
a3506 1
              & iand ( ichar ( quantity%mask ( i0:i1, maf ) ), m_linAlg ) == 0 )
d4598 9
d5128 1
a5133 1
          tpPres%values(1,i) = 0.0
a5161 1
        tpPres%values(1,i) = 0.0
d5213 1
a5213 1
    ! -------------------------------------------- FillWithBinMinMax -----
d5233 1
d5310 7
a5316 2
        & channel == 0 ) call Announce_Error ( key, 0, &
        & 'Must supply channel for this bin max/min fill' )
d5325 1
a5325 1
                & channel : sourceQuantity%template%instanceLen : &
d5330 1
a5330 1
                & channel : sourceQuantity%template%instanceLen : &
d5335 1
a5335 1
                & channel : sourceQuantity%template%instanceLen : &
d5655 3
@


2.210
log
@Added binTotal and noRads fills
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.209 2003/05/08 19:34:58 dwu Exp $"
d5120 7
d5641 3
@


2.209
log
@add more options to splitsideband, and tidy up
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.208 2003/05/07 00:16:52 livesey Exp $"
d77 1
a77 1
    use INIT_TABLES_MODULE, only: L_ADDNOISE, L_BINMAX, L_BINMIN, &
d86 1
a86 1
      & L_OFFSETRADIANCE, L_ORBITINCLINATION, L_PHITAN, &
d910 1
a910 1
        case ( l_binMax, l_binMin )
d936 2
a937 2
          call FillWithBinMinMax ( key, quantity, sourceQuantity, ptanQuantity, &
            & channel, fillMethod == l_binMax )
d1381 9
d3484 31
a3514 1
      ! ------------------------------------- FillRHIPrecisionFromH2O ----
d5199 2
a5200 2
    subroutine FillWithBinMinMax ( key, quantity, sourceQuantity, ptanQuantity, &
      & channel, fillMax )
d5210 1
a5210 1
      logical, intent(in) :: FILLMAX
d5225 1
a5225 1
        & 'Illegal quantity for bin max/min fill' )
d5301 2
a5302 1
            if ( fillMax ) then
d5307 1
a5307 1
            else
d5312 6
a5317 1
            end if
d5329 1
a5329 1
    end subroutine FillWithBinMinMax
d5634 3
@


2.208
log
@Added the dump for magnetic field results.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.207 2003/05/06 21:00:23 livesey Exp $"
d939 35
d992 64
d1142 10
d1230 2
a1231 33
        case ( l_H2OfromRHI ) ! -------fill H2O from RHI quantity -------
            if ( .not. any(got( &
             & (/f_rhiQuantity, f_temperatureQuantity/) &
             & )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill h2o from rhi'  )
            else
              sourceQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(sourceVectorIndex), sourceQuantityIndex)
              temperatureQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(temperatureVectorIndex), temperatureQuantityIndex)
              if ( .not. ValidateVectorQuantity(sourceQuantity, &
                & quantityType=(/l_rhi/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The rhiQuantity is not an rhi'  )
              else if ( .not. ValidateVectorQuantity(Quantity, &
                & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The Quantity is not a vmr for the H2O molecule'  )
              else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                & quantityType=(/l_temperature/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The temperatureQuantity is not a temperature'  )
              else
                invert = .true.
                call FillRHIFromH2O ( key, quantity, &
                  & sourceQuantity, temperatureQuantity, &
                  & dontMask, ignoreZero, ignoreNegative, interpolate, &
                  & .true., &   ! Mark Undefined values?
                  & invert )    ! invert rather than convert?
              end if
            end if
          case ( l_RHIPrecisionfromH2O ) ! --fill RHI prec. from H2O quantity --
d1284 1
a1284 1
          case ( l_scaleOverlaps )
d1292 1
a1292 1
          case ( l_special ) ! -  Special fills for some quantities  -----
d1383 1
a1383 96
          end select

        case ( l_negativePrecision ) ! ------------ Set output SD -ve wrt apriori
          if ( .not. got ( f_aprioriPrecision ) ) &
            & call Announce_Error ( key, No_Error_code, &
            & 'Missing aprioriPrecision field for negativePrecision fill' )
          aprioriPrecision => GetVectorQtyByTemplateIndex ( &
            & vectors(aprPrecVctrIndex), aprPrecQtyIndex )
          where ( quantity%values >= aprioriPrecision%values*precisionFactor )
            quantity%values = - quantity%values
          end where

        case ( l_vGrid ) ! ---------------------  Fill from vGrid  -----
          if (.not. ValidateVectorQuantity(quantity, &
            & quantityType=(/l_ptan/), &
            & frequencyCoordinate=(/l_none/) ) ) &
            & call Announce_Error ( key, No_Error_code, &
            &   'vGrids can only be used to fill ptan quantities' )
          if ( vGrids(vGridIndex)%verticalCoordinate /= l_zeta ) &
            & call Announce_Error ( key, No_Error_code, &
            &  'Vertical coordinate in vGrid is not zeta' )
          if ( vGrids(vGridIndex)%noSurfs /= quantity%template%noSurfs )&
            & call Announce_Error ( key, No_Error_code, &
            &  'VGrid is not of the same size as the quantity' )
          quantity%values = spread ( vGrids(vGridIndex)%surfs, 2, &
            & quantity%template%noInstances )

        case ( l_wmoTropopause ) ! ---------------- Fill with wmo tropopause --
          if ( .not. all(got( (/ f_temperatureQuantity, f_refGPHquantity, &
            & f_internalVGrid /) ))) &
            & call Announce_Error ( key, no_error_code, &
            & 'wmoTropopause fill needs temperatureQuantity, refGPHQuantity ' // &
            & 'and internalVGrid' )
          if ( vGrids(internalVGridIndex)%verticalCoordinate /= l_zeta ) &
            & call Announce_Error ( key, No_Error_code, &
            &  'Vertical coordinate in internal vGrid is not log pressure' )
          if ( .not. ValidateVectorQuantity ( quantity, &
            & quantityType = (/l_boundaryPressure/), verticalCoordinate=(/l_none/), &
            & coherent=.true., stacked=.true. ) ) &
            & call Announce_Error ( key, no_error_code, &
            & 'Quantity is not a boundary pressure' )

          temperatureQuantity => GetVectorQtyByTemplateIndex( &
            &  vectors(temperatureVectorIndex), temperatureQuantityIndex)
          if ( .not. ValidateVectorQuantity ( temperatureQuantity, &
            & quantityType = (/l_temperature/), verticalCoordinate=(/l_zeta/), &
            & coherent=.true., stacked=.true. ) ) &
            & call Announce_Error ( key, badTemperatureQuantity )

          refGPHQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(refGPHVectorIndex), refGPHQuantityIndex)
          if ( .not. ValidateVectorQuantity ( refGPHQuantity, &
            & quantityType = (/l_refGPH/), verticalCoordinate=(/l_zeta/), &
            & coherent=.true., stacked=.true., noSurfs=(/1/) ) ) &
            & call Announce_Error ( key, badrefGPHQuantity )

          if ( .not. DoHGridsMatch ( quantity, temperatureQuantity ) .or. &
            &  .not. DoHGridsMatch ( quantity, refGPHQuantity ) ) &
            & call Announce_Error ( key, no_error_code, &
            & 'Horizontal coordinates for temperature/refGPH and/or quanity disagree' )

          ! OK, we must be ready to go
          call FillQtyWithWMOTropopause ( quantity, &
            & temperatureQuantity, refGPHQuantity, vGrids(internalVGridIndex) )


        case ( l_fold ) ! --------------- Fill by sideband folding -----
          lsb => GetVectorQtyByTemplateIndex ( &
            & vectors(lsbVectorIndex), lsbQuantityIndex )
          lsbFraction => GetVectorQtyByTemplateIndex ( &
            & vectors(lsbFractionVectorIndex), lsbFractionQuantityIndex )
          usb => GetVectorQtyByTemplateIndex ( &
            & vectors(usbVectorIndex), usbQuantityIndex )
          usbFraction => GetVectorQtyByTemplateIndex ( &
            & vectors(usbFractionVectorIndex), usbFractionQuantityIndex )
          call FillFoldedRadiance ( quantity, lsb, usb, lsbFraction, usbFraction, key )

        case ( l_gridded ) ! ------------  Fill from gridded data  -----
          if ( .not. got(f_sourceGrid) ) &
            & call Announce_Error ( key,noSourceGridGiven )
          call FillVectorQuantityFromGrid &
            & ( quantity, griddedDataBase(gridIndex), allowMissing, errorCode )
          if ( errorCode /= 0 ) call Announce_error ( key, errorCode )

        case ( l_l2gp ) ! --------------  Fill from L2GP quantity  -----
          if ( .NOT. got(f_sourceL2GP) ) &
            & call Announce_Error ( key, noSourceL2GPGiven )
          call FillVectorQuantityFromL2GP &
            & ( quantity, l2gpDatabase(l2gpIndex), interpolate, profile, errorCode )
          if ( errorCode /= 0 ) call Announce_error ( key, errorCode )

        case ( l_l2aux ) ! ------------  Fill from L2AUX quantity  -----
          if ( .NOT. got(f_sourceL2AUX) ) &
            & call Announce_Error ( key, noSourceL2AUXGiven )
          call FillVectorQuantityFromL2AUX(quantity,l2auxDatabase(l2auxIndex),errorCode)
          if ( errorCode /= 0 ) call Announce_error ( key, errorCode )
d1400 7
d1408 1
a1408 1
            & lsbFraction, usbFraction, spreadFlag, channel, key )
d1447 48
a1494 17
        case ( l_estimatedNoise ) ! ----------- Fill with estimated noise ---
          if (.not. all(got( (/ f_radianceQuantity, &
            & f_systemTemperature, f_integrationTime /)))) &
            & call Announce_Error ( key, badEstNoiseFill )
          radianceQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(radianceVectorIndex), radianceQuantityIndex )
          sysTempQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(sysTempVectorIndex), sysTempQuantityIndex )
          if ( got ( f_noiseBandwidth ) ) then
            nbwQuantity => GetVectorQtyByTemplateIndex( &
              & vectors(nbwVectorIndex), nbwQuantityIndex )
          else
            nbwQuantity => NULL()
          end if
          call FillVectorQtyWithEstNoise ( &
            & quantity, radianceQuantity, sysTempQuantity, nbwQuantity, &
            & integrationTime )
d1496 3
a1498 5
        case ( l_explicit ) ! ---------  Explicity fill from l2cf  -----
          if ( .not. got(f_explicitValues) ) &
            & call Announce_Error ( key, noExplicitValuesGiven )
          call ExplicitFillVectorQuantity ( quantity, valuesNode, spreadFlag, &
            & vectors(vectorIndex)%globalUnit, dontmask )
a1499 10
        case ( l_l1b ) ! --------------------  Fill from L1B data  -----
          if ( got(f_precision) ) then
            precisionQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(precisionVectorIndex), precisionQuantityIndex )
            call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), &
              & l1bInfo, isPrecision, precisionQuantity )
          else
            call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), &
              & l1bInfo, isPrecision )
          end if
d1503 1
a1503 1
        end select
d4093 1
a4093 1
      & lsbFraction, usbFraction, spreadFlag, channel, key )
d4099 1
d4106 1
a4106 1
      type (Signal_T) :: signalIn, signalOut
d4109 4
a4112 1

a4120 5
      ! this method is only appliable to the cloud-induced radiances that have 
      ! similar penetration depth (usually close in frequency) and are 
      ! proportional to frequency^4. And this operation is only applied to
      ! maskbit = m_cloud

d4123 3
d4156 2
d4159 1
a4159 3
             & quantity%values(i+(mif-1)*size(signalOut%frequencies), maf) = &
	          &    sourceQuantity%values(MyChannel+(mif-1)*size(signalIn%frequencies), maf) * &
             &    freq2(i)**4/freq1(MyChannel)**4
d4167 3
a4169 1
        if (.not. ValidateVectorQuantity ( sourceQuantity, quantityType=(/l_cloudInducedRadiance/), &
d4178 10
a4187 1
        do i=1,size(signalOut%frequencies)
d4197 51
a4247 1
        enddo
d4250 3
d5589 3
@


2.207
log
@Bug fix on L1B stuff
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.206 2003/04/30 22:07:14 pwagner Exp $"
d4586 3
d5514 3
@


2.206
log
@Always sets errorCode to 0 in return from FillVectorQuantityFromL2AUX
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.205 2003/04/24 22:17:02 dwu Exp $"
d80 1
a80 1
      & L_ESTIMATEDNOISE, L_EXPLICIT, L_FOLD, L_GEODALTITUDE, &
d4423 4
a4428 1
!        nameString=TRIM(nameString)//'.ptan'
a4437 1
!        nameString=TRIM(nameString)//'.tpECI'
a4441 1
!        nameString=TRIM(nameString)//'.tpGeodAlt'
d4444 4
a4449 1
!        nameString=TRIM(nameString)//'.tpGeocAlt'
a4452 1
!        nameString='scECI'
a4454 1
!        nameString='scVel'
a4456 1
!        nameString='scVelECI'
a4459 1
!        nameString='scVelECR'
a4462 1
!        nameString='scGeocAlt'
a4465 1
!        nameString='scOrbIncl'
d5511 3
@


2.205
log
@remove dump statement in fill binMinMax
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.204 2003/04/24 00:35:14 dwu Exp $"
d4518 3
d5513 3
@


2.204
log
@modify splitSideband to allow the splitted sideband cloud radiances being spread to other bands assuming the f**4 law
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.203 2003/04/24 00:29:45 dwu Exp $"
d5143 1
a5143 1
      call dump ( surfs, 'surfs' )
d5171 1
a5171 1
      call dump ( insts, 'insts' )
d5510 3
@


2.203
log
@modify splitSideband to allow the splitted sideband cloud radiances being spread to other bands assuming the f**4 law
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.202 2003/04/23 17:06:36 livesey Exp $"
d1409 2
d5510 3
@


2.202
log
@Added binmax binmin fills
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.201 2003/04/11 23:15:09 livesey Exp $"
d79 1
a79 1
      & L_CHISQMMAF, L_CHISQMMIF, L_CHOLESKY, L_COLUMNABUNDANCE, &
d1416 1
a1416 1
            & lsbFraction, usbFraction, key )
d4082 1
a4082 1
      & lsbFraction, usbFraction, key )
d4088 2
d4092 2
a4093 2
      logical, dimension(:), pointer :: doChannel    ! Do this channel?
      integer :: noFreqs, mif, maf
d4095 2
a4096 1
      real(r8), dimension(:), pointer :: freq, freqL, freqU
d4099 1
a4099 2
      ! Do some checking first
      if (.not. ValidateVectorQuantity ( quantity, quantityType=(/l_radiance/), &
a4101 9
      if (.not. ValidateVectorQuantity ( sourceQuantity, quantityType=(/l_radiance/), &
        & sideband=(/0/), signal=(/quantity%template%signal/), minorFrame=.true. )) &
        & call Announce_Error ( key, 0, 'Inappropriate sourceQuantity radiance for fill' )
      if (.not. ValidateVectorQuantity ( lsbFraction, quantityType=(/l_sidebandRatio/), &
        & signal=(/quantity%template%signal/), sideband=(/-1/) ) ) &
        & call Announce_Error ( key, 0, 'Inappropriate lsbFraction quantity for fill' )
      if (.not. ValidateVectorQuantity ( usbFraction, quantityType=(/l_sidebandRatio/), &
        & signal=(/quantity%template%signal/), sideband=(/1/) ) ) &
        & call Announce_Error ( key, 0, 'Inappropriate usbFraction quantity for fill' )
a4104 7

      ! OK Dong, this is where you do your stuff
      ! You're filling the lsb or usb radiance quantity 'quantity', using
      ! the folded radiances in 'sourceQuantity' and the fractions in
      ! 'usbFraction' and 'lsbFraction'.

      ! NOTE, THINK ABOUT WHETHER YOU WANT THE FILL MASK TO BE OBEYED HERE.
d4111 1
a4111 1
      noFreqs = size(signalIn%frequencies)
d4113 19
a4131 13
      call allocate_test ( doChannel, noFreqs, 'doChannel', ModuleName )
      call allocate_test ( freq, noFreqs, 'frequencies', ModuleName )
      call allocate_test ( freqL, noFreqs, 'LSBfrequencies', ModuleName )
      call allocate_test ( freqU, noFreqs, 'USBfrequencies', ModuleName )

      doChannel = signalIn%channels
      freq = signalIn%centerFrequency + signalIn%direction*signalIn%frequencies 
      freqL = signalIn%lo - freq    ! lower sideband freq
      freqU = signalIn%lo + freq    ! upper sideband freq

      ! redefine freq as output signal frequency
      if(signalOut%sideband == -1) freq=freqL
      if(signalOut%sideband == 1) freq=freqU
d4134 48
a4181 18
      do i=1,noFreqs
       if (doChannel(i)) then
         do maf=1, size(quantity%values(1,:))
         do mif=1, quantity%template%noSurfs
      	if(iand(ichar(sourceQuantity%mask(i+(mif-1)*noFreqs, maf)), m_cloud) == 0) &
	      & quantity%values(i+(mif-1)*noFreqs, maf) = &
	      &   sourceQuantity%values(i+(mif-1)*noFreqs, maf) *freq(i)**4/ &
	      &   (lsbFraction%values(i,1) * freqL(i)**4 + &
	      &   usbFraction%values(i,1) * freqU(i)**4)
   	   enddo
	      enddo
       endif
      enddo

      call deallocate_test ( doChannel, 'doChannel', ModuleName )
      call deallocate_test ( freq, 'frequencies', ModuleName )
      call deallocate_test ( freqL,'LSBfrequencies', ModuleName )
      call deallocate_test ( freqU,'USBfrequencies', ModuleName )
d5508 3
@


2.201
log
@Added force option to vector fill, and spreadChannel fill method.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.200 2003/04/11 21:56:40 livesey Exp $"
d77 2
a78 1
    use INIT_TABLES_MODULE, only: L_ADDNOISE, L_BOUNDARYPRESSURE, L_CHISQCHAN, &
d127 1
a127 1
    use MLSNumerics, only: InterpolateValues
d910 29
d5056 127
d5486 3
@


2.200
log
@Added wmo tropopause stuff
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.199 2003/04/08 23:13:01 dwu Exp $"
d53 2
a54 2
      & F_COLUMNS, F_DESTINATION, F_DIAGONAL, F_dontMask, F_EARTHRADIUS, &
      & F_EXPLICITVALUES, F_EXTINCTION, &
d90 2
a91 1
      & L_SIDEBANDRATIO, L_SPD, L_SPECIAL, L_SPLITSIDEBAND, L_SYSTEMTEMPERATURE, &
d295 1
d310 1
d457 1
d460 1
d633 6
d648 3
a650 5
            if ( node_id(gson) == n_set_one ) then
              extinction=.TRUE.
            else
              extinction = decoration(subtree(2,gson)) == l_true
            end if
d679 1
a679 5
            if ( node_id(gson) == n_set_one ) then
              interpolate=.TRUE.
            else
              interpolate = decoration(subtree(2,gson)) == l_true
            end if
d809 1
a809 5
            if ( node_id(gson) == n_set_one ) then
              spreadFlag = .true.
            else
              spreadFlag = decoration(subtree(2,gson)) == l_true
            end if
d1388 5
d1411 1
a1411 1
              call FillQtyFromInterpolatedQty ( quantity, sourceQuantity, key )
d4534 1
a4534 1
    subroutine FillQtyFromInterpolatedQty ( qty, source, key )
d4537 1
d4546 1
a4546 1
      if ( .not. DoQtysDescribeSameThing ( qty, source ) ) then
d4562 18
a4579 12
      ! These checks are for cases the code can't (yet) handle, 
      ! may add this functionality later. 
      if ( qty%template%noChans /= 1 ) then
        call Announce_error ( key, no_error_code, &
          & 'Code cannot (yet?) interpolate multi channel quantities' )
        return
      end if
      if ( .not. all ( (/ qty%template%coherent, source%template%coherent /) ) ) then
        call Announce_error ( key, no_error_code, &
          & 'Code cannot (yet?) interpolate incoherent quantities' )
        return
      end if
d4581 63
a4643 51
      ! Work out vertical coordinate issues
      if ( qty%template%verticalCoordinate == l_pressure ) then
        nullify ( oldSurfs, newSurfs )
        call Allocate_test ( oldSurfs, source%template%noSurfs, 'oldSurfs', ModuleName )
        call Allocate_test ( newSurfs, qty%template%noSurfs, 'newSurfs', ModuleName )
        oldSurfs = -log10 ( source%template%surfs(:,1) )
        newSurfs = -log10 ( qty%template%surfs(:,1) )
        mySurfs = .true.
      else
        oldSurfs => source%template%surfs ( :, 1 )
        newSurfs => qty%template%surfs ( :, 1 )
        mySurfs = .false.
      end if

      ! Work out if we have to obey the mask
      myNewValues = .false.
      if ( associated ( qty%mask ) ) &
        & myNewValues = any ( iand ( ichar(qty%mask(:,:)), m_fill ) /= 0 )
      if ( myNewValues ) then
        nullify ( newValues )
        call Allocate_test ( newValues, qty%template%instanceLen, &
          & qty%template%noInstances, 'myNewValues', ModuleName )
      else
        newValues => qty%values
      end if
      
      ! OK, do the work
      if ( qty%template%logBasis ) then
        call InterpolateValues ( &
          & oldSurfs, log ( max ( source%values, sqrt(tiny(0.0_r8)) ) ), &
          & newSurfs, newValues, &
          & method='Linear', extrapolate='Constant' )
        newValues = exp ( newValues )
      else
        call InterpolateValues ( &
          & oldSurfs, source%values, &
          & newSurfs, newValues, &
          & method='Linear', extrapolate='Constant' )
      end if

      if ( myNewValues ) then
        where ( iand ( ichar(qty%mask(:,:)),m_fill) == 0 )
          qty%values = newValues
        end where
        call Deallocate_test ( newValues, 'myNewValues', ModuleName )
      endif

      ! Tidy up
      if ( mySurfs ) then
        call Deallocate_test ( oldSurfs, 'oldSurfs', ModuleName )
        call Deallocate_test ( newSurfs, 'newSurfs', ModuleName )
d5101 36
d5329 3
@


2.199
log
@an update on splitsideband
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.198 2003/04/07 06:37:42 dwu Exp $"
d58 1
d92 2
a93 1
      & L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VGRID, L_VMR, L_XYZ, L_ZETA
d119 1
a119 1
    use MLSCommon, only: FileNameLen, L1BInfo_T, MLSChunk_T, R8, RM, RV
d325 1
d667 2
d1301 39
d4860 141
d5268 3
@


2.198
log
@implement splitsideband for cloud radiance
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.197 2003/04/05 00:26:47 livesey Exp $"
d4064 9
a4072 9
        do maf=1, size(quantity%values(1,:))
        do mif=1, quantity%template%noSurfs
      	if(iand(ichar(sourceQuantity%mask(i+(mif-1)*noFreqs, maf)), m_cloud) == 1) &
	& quantity%values(i+(mif-1)*noFreqs, maf) = &
	&   sourceQuantity%values(i+(mif-1)*noFreqs, maf) *freq(i)**4/ &
	&   (lsbFraction%values(i,1) * freqL(i)**4 + &
	&   usbFraction%values(i,1) * freqU(i)**4)
	enddo
	enddo
d5083 3
@


2.197
log
@Bug fix in sideband splitting stub
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.196 2003/04/05 00:05:37 livesey Exp $"
d148 1
a148 1
      & VectorTemplate_T, VectorValue_T, M_Fill, M_LinAlg
d4003 1
d4010 4
a4013 1
      type (Signal_T) :: signal
d4027 1
a4027 1
        & signal=(/quantity%template%signal/), sideband=(/-1/) ) ) &
d4030 2
a4031 1
      signal = GetSignal ( sourceQuantity%template%signal )
d4039 41
a4079 1

d5083 3
@


2.196
log
@Added call to getSignal in split sideband
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.195 2003/04/04 23:53:57 livesey Exp $"
d125 2
a126 1
    use MLSSignals_m, only: GetSignalName, GetModuleName, IsModuleSpacecraft, GetSignal
d4009 1
a4009 1
      type (MLSSignals_T) :: signal
d5038 3
@


2.195
log
@Added skeleton for split sideband fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.194 2003/04/04 22:01:59 livesey Exp $"
d125 1
a125 1
    use MLSSignals_m, only: GetSignalName, GetModuleName, IsModuleSpacecraft
d4008 1
d4025 2
d5037 3
@


2.194
log
@Added call to updateMask
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.193 2003/04/04 00:08:06 livesey Exp $"
d89 1
a89 1
      & L_SIDEBANDRATIO, L_SPD, L_SPECIAL, L_SYSTEMTEMPERATURE, &
d267 1
d1326 16
d3999 34
d5034 3
@


2.193
log
@Added the wrapping of the gridded data before it's used in fill.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.192 2003/03/27 20:45:02 livesey Exp $"
d95 1
a95 1
      & S_TRANSFER, S_VECTOR, S_SUBSET, S_FLAGCLOUD, S_RESTRICTRANGE
d134 1
a134 1
    use SubsetModule, only: SETUPSUBSET, SETUPFLAGCLOUD, RESTRICTRANGE
d585 7
d4983 3
@


2.192
log
@Added logSpace argument to profile fill, and made it obey the dontMask
flag
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.191 2003/03/26 21:23:47 livesey Exp $"
d49 1
a49 1
    use GriddedData, only: GriddedData_T
d236 1
d1859 2
a1860 1
      type (GriddedData_T), intent(in) :: GRID ! Grid to fill it from
d1871 4
d1884 4
d2138 1
a2138 1
      if ( myLogSpace .and. any ( values < 0.0 ) ) then
d2140 1
a2140 1
          & 'Negative input data in log profile fill' )
d4956 2
d4976 4
@


2.191
log
@Added ScaleOverlaps stuff
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.190 2003/03/19 19:22:24 pwagner Exp $"
d59 1
a59 1
      & F_LENGTHSCALE, F_LOSQTY, F_LOWBOUND, F_LSB, F_LSBFRACTION, &
d330 1
d456 1
d666 2
d1008 7
a1014 2
          call FillVectorQtyFromProfile ( key, quantity, valuesNode, &
            & instancesNode, vectors(vectorIndex)%globalUnit, dontMask )
d2049 1
a2049 1
      & instancesNode, globalUnit, dontMask )
d2060 1
d2070 1
d2094 2
d2128 7
d2161 2
d2179 1
a2179 1
              if ( associated(quantity%mask) ) then
d4964 3
@


2.190
log
@Passes chunkNo around more widely
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.189 2003/03/07 03:16:12 livesey Exp $"
d87 1
a87 1
      & L_RHIFROMH2O, L_RHIPRECISIONFROMH2O, &
d1092 4
a1095 4
                & sourceQuantity, temperatureQuantity, &
                & dontMask, ignoreZero, ignoreNegative, interpolate, &
                & .true., &   ! Mark Undefined values?
                & invert )    ! invert rather than convert?
d1098 63
a1160 53
        case ( l_RHIPrecisionfromH2O ) ! --fill RHI prec. from H2O quantity --
                if ( .not. any(got( &
                  & (/f_h2oquantity, f_temperatureQuantity, &
                  & f_h2oPrecisionquantity, f_tempPrecisionQuantity/) &
                  & )) ) then
                  call Announce_error ( key, No_Error_code, &
                    & 'Missing a required field to fill rhi precision'  )
                else
                  h2oQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(h2oVectorIndex), h2oQuantityIndex)
                  temperatureQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(temperatureVectorIndex), temperatureQuantityIndex)
                  h2oPrecisionQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(h2oPrecisionVectorIndex), h2oPrecisionQuantityIndex)
                  tempPrecisionQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(tempPrecisionVectorIndex), tempPrecisionQuantityIndex)
                  if ( .not. ValidateVectorQuantity(h2oQuantity, &
                    & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                    call Announce_Error ( key, No_Error_code, &
                      & 'The h2oQuantity is not a vmr for the H2O molecule'  )
                  else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                    & quantityType=(/l_temperature/)) ) then
                    call Announce_Error ( key, No_Error_code, &
                      & 'The temperatureQuantity is not a temperature'  )
                  else if ( .not. ValidateVectorQuantity(h2oPrecisionQuantity, &
                    & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                    call Announce_Error ( key, No_Error_code, &
                      & 'The h2oPrecisionQuantity is not a vmr for the H2O molecule'  )
                  else if ( .not. ValidateVectorQuantity(tempPrecisionQuantity, &
                    & quantityType=(/l_temperature/)) ) then
                    call Announce_Error ( key, No_Error_code, &
                      & 'The tempPrecisionQuantity is not a temperature'  )
                    ! This is not the right way to do an invert fill
                    ! The first quantity named on the fill line must
                    ! _always_ be the one getting filled according to
                    ! the pattern '[verb] [direct-object] [modifier(s)]'
                    ! see case l_vmr below for how to do this
                    !else if ( invert ) then
                    !  call FillRHIFromH2O ( key, h2oquantity, &
                    !  & Quantity, temperatureQuantity, &
                    !  & dontMask, ignoreZero, ignoreNegative, interpolate, &
                    !  & .true., &   ! Mark Undefined values?
                    !  & invert )    ! invert rather than convert?
                  else
                    call FillRHIPrecisionFromH2O ( key, quantity, &
                      & h2oPrecisionQuantity, tempPrecisionQuantity, h2oQuantity, temperatureQuantity, &
                      & dontMask, ignoreZero, ignoreNegative, interpolate, &
                      & .true., &   ! Mark Undefined values?
                      & invert )    ! invert rather than convert?
                  end if
                end if
        case ( l_special ) ! -  Special fills for some quantities  -----
          ! Either multiplier = [a, b] or multiplier = b are possible
d4702 51
a4752 1
    ! ---------------------------------------------- TRANSFERVECTORS -----
d4942 3
@


2.189
log
@Added RestrictRange
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.188 2003/03/06 00:46:30 livesey Exp $"
d956 1
a956 1
            & phiWindow, phiWindowUnits )          
d3816 1
a3816 1
    ! ------------------------------------- FillVectorHydrostatically ----
d3820 1
a3820 1
      & phiWindow, phiWindowUnits )
d3833 1
d3854 1
a3854 1
	  if ( toggle(gen) .and. levels(gen) > 0 ) &
d3863 1
a3863 1
	  if ( toggle(gen) .and. levels(gen) > 0 ) &
d3875 1
a3875 1
	  if ( toggle(gen) .and. levels(gen) > 0 ) &
d3883 1
a3883 1
	  if ( toggle(gen) .and. levels(gen) > 0 )&
a3892 8
  !        print *, 'ValidateVectorQuantity(quantity, minorFrame=.true.) ', &
  !        &  ValidateVectorQuantity(quantity, minorFrame=.true., sayWhyNot=.true.)
  !        print *, 'ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ', &
  !        & ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true., sayWhyNot=.true.)
  !        print *, 'quantity%template%instrumentModule ', &
  !        & quantity%template%instrumentModule
  !        print *, 'geocAltitudeQuantity%template%instrumentModule ', &
  !        & geocAltitudeQuantity%template%instrumentModule
d3916 1
a3916 1
	  if ( toggle(gen) .and. levels(gen) > 0 ) &
d3923 1
a3923 1
          & phiWindow, phiWindowUnits )
d4882 3
@


2.188
log
@Added ability to do subset and flagCloud
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.187 2003/03/05 19:11:11 livesey Exp $"
d95 1
a95 1
      & S_TRANSFER, S_VECTOR, S_SUBSET, S_FLAGCLOUD
d134 1
a134 1
    use SubsetModule, only: SETUPSUBSET, SETUPFLAGCLOUD
d570 1
a570 1
          & call trace_begin ( "Retrieve.subset", root )
d573 8
a580 1
          & call trace_end ( "Retrieve.subset" )
d584 1
a584 1
          & call trace_begin ( "Retrieve.flagCloud", root )
d587 1
a587 1
          & call trace_end ( "Retrieve.flagCloud" )
d4889 3
@


2.187
log
@Added allowMissing capability to gridded fill.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.186 2003/02/28 02:26:23 livesey Exp $"
d95 1
a95 1
      & S_TRANSFER, S_VECTOR
d134 1
d568 14
d4882 3
@


2.186
log
@Added checking for bad/missing data in fill from gridded data.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.185 2003/02/27 00:38:52 livesey Exp $"
d51 2
a52 1
    use INIT_TABLES_MODULE, only: F_A, F_APRIORIPRECISION, F_B, F_BOUNDARYPRESSURE, &
d279 1
d445 1
d580 2
d1260 1
a1260 1
            & ( quantity, griddedDataBase(gridIndex), errorCode )
d1814 1
a1814 1
    subroutine FillVectorQuantityFromGrid(quantity,grid, errorCode)
d1818 1
d1850 2
a1851 2
            &  newValue <= nearest ( grid%missingValue,  1.0 ) ) &
            & errorCode = MissingDataInGrid
d4867 3
@


2.185
log
@Better handling of missing length scale in FillCovariance
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.184 2003/02/18 23:59:06 livesey Exp $"
d233 1
d1818 1
d1836 1
a1836 1
          call l3ascii_interp_field(grid, quantity%values(surf,instance), &
d1843 4
d4841 2
d4861 3
@


2.184
log
@Added phiWindow for hydrostatic fill.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.183 2003/02/15 00:35:03 livesey Exp $"
d1678 1
a1678 1
      real (r8) :: meanLength             ! Geometric mean length scale
d1691 2
a1692 2
      if ( lengthScale == 0 ) then
        call updateDiagonal ( covariance, vectors(diagonal), square=.true., &
d1694 3
a1696 2

      else ! Do a more complex fill.
d1699 6
a1704 4
        call CopyVector ( Lmasked, vectors(lengthScale), clone=.true., &
          & vectorNameText='_Lmasked' ) 
        call ClearUnderMask ( Lmasked )

d1709 11
a1719 8
        if ( covariance%m%row%vec%template%id /= &
          & lMasked%template%id ) call MLSMessage ( MLSMSG_Error, &
          & ModuleName, "lengthScale and covariance not compatible in fillCovariance" )
        if ( lMasked%globalUnit /= phyq_length ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "length vector does not have dimensions of length" )

        if ( fraction /= 0 ) then
d1736 2
a1737 2
          l => lMasked%quantities(q)
          if (fraction /=0) f => vectors(fraction)%quantities(q)
a1759 1
                  meanLength = sqrt ( l%values(j,i) * l%values(k,i) )
d1761 3
a1763 1
                  if ( fraction /= 0) thisFraction = f%values(j,i)
d1775 2
a1776 2
                  if ( meanLength > 0.0 ) &
                    & m(j,k) = meanDiag*thisFraction*exp(-distance/meanLength)
d4853 3
@


2.183
log
@Added error checking for range of profile on L2GP fill.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.182 2003/02/13 21:42:12 livesey Exp $"
d61 2
a62 2
      & F_OFFSETAMOUNT, &
      & F_ORBITINCLINATION, F_PHITAN, F_PRECISION, F_PRECISIONFACTOR, &
d99 1
a99 1
      & PHYQ_Time, PHYQ_Length, PHYQ_Pressure, PHYQ_Zeta
d353 2
d459 2
d703 6
d927 2
a928 1
            & phiTanQuantity, geocAltitudeQuantity, maxIterations )          
d3778 2
a3779 1
      & orbitInclinationQuantity, phiTanQuantity, geocAltitudeQuantity, maxIterations )
d3790 2
d3888 2
a3889 1
          & phiTanQuantity, geocAltitudeQuantity, maxIterations )
d4846 3
@


2.182
log
@Added specific profile stuff to fill from l2gp.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.181 2003/01/29 01:59:19 livesey Exp $"
d1926 5
d4831 3
@


2.181
log
@Changed some MLSMessages to Announce_Errors to get a line number.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.180 2003/01/28 21:53:07 pwagner Exp $"
d63 1
a63 1
      & F_PROFILEVALUES, F_PTANQUANTITY, &
d356 1
d381 1
a381 1
    logical :: SPREAD                   ! Do we spread values accross instances in explict
d450 1
a450 1
      spread = .false.
d456 1
d686 5
d748 1
a748 1
              spread=.TRUE.
d750 1
a750 1
              spread = decoration(subtree(2,gson)) == l_true
d1225 2
a1226 5
          do instance = 1, quantity%template%noInstances
            quantity%values(:,instance) = vGrids(vGridIndex)%surfs
          end do
          !quantity%values = spread ( vGrids(vGridIndex)%surfs, 2, &
          !  & quantity%template%noInstances )
d1250 1
a1250 1
            & ( quantity, l2gpDatabase(l2gpIndex), interpolate, errorCode )
d1312 1
a1312 1
          call ExplicitFillVectorQuantity ( quantity, valuesNode, spread, &
d1828 4
a1831 1
    subroutine FillVectorQuantityFromL2GP ( quantity,l2gp, interpolate, errorCode )
d1840 1
d1852 3
a1854 2
      integer :: INSTANCE                 ! Loop counter 

d1893 11
a1903 9
      ! Attempt to match up the first location
      firstProfileAsArray=MINLOC(ABS(quantity%template%phi(1,1)-l2gp%geodAngle))
      firstProfile=firstProfileAsArray(1)

      ! Well, the last profile has to be noInstances later, check this would be OK
      lastProfile=firstProfile+quantity%template%noInstances-1
      if (lastProfile > l2gp%nTimes ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity has profiles beyond the end of the l2gp' )
d1905 8
a1912 8
      ! Now check that geodAngle's are a sufficient match
      if (any(abs(l2gp%geodAngle(firstProfile:lastProfile)-&
        &         quantity%template%phi(1,:)) > tolerance) ) then
        call dump ( l2gp%geodAngle(firstProfile:lastProfile), 'L2GP geodetic angle' )
        call dump ( quantity%template%phi(1,:), 'Quantity Geodetic angle' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Quantity has profiles that mismatch l2gp in geodetic angle' )
      end if
d1914 12
a1925 8
      if (any(abs(l2gp%time(firstProfile:lastProfile)- &
        &         quantity%template%time(1,:)) > timeTol) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity has profiles that mismatch l2gp in time' )

      if (interpolate .and. quantity%template%noChans /= 1) then
        errorCode=cantInterpolate3D
        return
d1928 1
d1930 11
a1940 3
        quantity%values=RESHAPE(l2gp%l2gpValue(:,:,firstProfile:lastProfile),&
          & (/quantity%template%noChans*quantity%template%noSurfs,&
          &   quantity%template%noInstances/))
d1947 3
d1951 9
a1959 1
          call InterpolateValues ( &
d1961 1
a1961 1
            & real(l2gp%l2gpValue(1,:,firstProfile+instance-1), r8), & ! OldY
d1966 1
d3989 1
a3989 1
    subroutine ExplicitFillVectorQuantity(quantity, valuesNode, spread, globalUnit, &
d3998 1
a3998 1
      logical, intent(in) :: SPREAD       ! One instance given, spread to all
d4013 1
a4013 1
      if (spread) then      ! 1 instance/value given, spread to all instances
d4050 1
a4050 1
      else                  ! Not spread, fill all values
d4826 3
@


2.181.2.1
log
@Add dump for magnetic field, cosmetic changes
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.181 2003/01/29 01:59:19 livesey Exp $"
d502 1
a502 1
          if ( nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
d564 1
a564 1
          if ( nsons(gson) > 1) gson = subtree(2,gson) ! Now value of said argument
d775 2
a776 2
          if ( DEEBUG) call output('add noise method', advance='yes')
          if ( .not. all(got( (/f_Quantity, f_sourceQuantity, f_noise/) ) ) ) &
d786 1
a786 1
          if ( DEEBUG ) then
d796 1
a796 1
            if ( DEEBUG ) then
d807 1
a807 1
              if ( DEEBUG ) then
d813 1
a813 1
              if ( DEEBUG ) then
d819 1
a819 1
            if ( DEEBUG ) then
d837 1
a837 1
          if ( DEEBUG ) then
d913 1
a913 1
          if ( .not. all(got( (/f_ratioQuantity, f_sourceQuantity/) ) ) ) &
d981 1
a981 1
          if ( .not. all(got((/f_losQty,f_earthRadius,f_PtanQuantity/))))&
d1115 1
a1115 1
          if ( DEEBUG ) then
d1207 1
a1207 1
          if ( .not. ValidateVectorQuantity(quantity, &
d1269 1
a1269 1
            if ( .not. interpolate ) then
d1288 1
a1288 1
          if ( .not. all(got( (/ f_radianceQuantity, &
d1333 1
a1333 1
          if ( nsons(gson) > 1) &
d1364 1
a1364 1
          if ( nsons(gson) > 1) &
d1383 1
a1383 1
        if ( DEEBUG) call output('Destroy vector/matrix instruction', &
d1407 1
a1407 1
          if ( DEEBUG ) then
d1423 1
a1423 1
          if ( DEEBUG ) then
d1428 1
a1428 1
          if ( DEEBUG ) then
d1597 1
a1597 1
      if ( .not. FillableChiSq ( quantity, &
d1608 1
a1608 1
      else if ( &
d1716 1
a1716 1
          if ( fraction /=0) f => vectors(fraction)%quantities(q)
d1799 1
a1799 1
      if ( quantity%template%verticalCoordinate /= l_zeta ) then
d1808 1
a1808 1
        if ( .not. quantity%template%stacked) instIndex=instance
d1811 1
a1811 1
          if ( .not. quantity%template%coherent) surfIndex=surf
d1850 1
a1850 1
      if ( .not. ValidateVectorQuantity(quantity, coherent=.TRUE., stacked=.TRUE., &
d1870 1
a1870 1
      if ( .not. interpolate ) then 
d1890 1
a1890 1
      if ( lastProfile > l2gp%nTimes ) &
d1895 1
a1895 1
      if ( any(abs(l2gp%geodAngle(firstProfile:lastProfile)-&
d1903 1
a1903 1
      if ( any(abs(l2gp%time(firstProfile:lastProfile)- &
d1908 1
a1908 1
      if ( interpolate .and. quantity%template%noChans /= 1 ) then
d1913 1
a1913 1
      if ( .not. interpolate ) then
d2215 1
a2215 1
      if ( .not. minorFrame ) then
d2226 1
a2226 1
      if ( minorFrame ) then
d2237 1
a2237 1
      if ( .not. minorFrame ) then
d2303 1
a2303 1
      else if ( &
d2318 1
a2318 1
      if ( .not. ValidateVectorQuantity ( qty, &
d2331 1
a2331 1
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
d2335 1
a2335 1
      else if ( any ( noiseQty%values == 0.0) .and. &
d2435 1
a2435 1
      else if ( &
d2450 1
a2450 1
      if ( .not. ValidateVectorQuantity ( qty, &
d2463 1
a2463 1
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
d2467 1
a2467 1
      else if ( any ( noiseQty%values == 0.0) .and. &
d2495 1
a2495 1
        if ( .not. (.not. dontMask .or. ignoreNegative .or. ignoreZero ) ) then
d2575 1
a2575 1
      else if ( &
d2590 1
a2590 1
      if ( .not. ValidateVectorQuantity ( qty, &
d2603 1
a2603 1
      else if ( .not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
d2607 1
a2607 1
      else if ( any ( noiseQty%values == 0.0) .and. &
d2722 1
a2722 1
      else if ( qty%template%molecule /= vmrQty%template%molecule ) then
d2768 1
a2768 1
     if ( status /= 0 ) then
d2775 1
a2775 1
        if ( vmrQty%template%coherent ) then
d2781 1
a2781 1
        if ( zeta_surfs ) then
d2793 2
a2794 2
        if ( p(1) &
           &  < bndPressQty%values(1, instance) ) then
d2802 1
a2802 1
           if ( p(surface) &
d2806 1
a2806 1
        if ( firstSurface > vmrQty%template%noSurfs-2 ) then
d2833 1
a2833 1
     if ( status /= 0 ) then
d2857 1
a2857 1
      if ( .not. ValidateVectorQuantity ( radiance, quantityType=(/l_radiance/), &
d2860 1
a2860 1
      if ( .not. ValidateVectorQuantity ( lsb, quantityType=(/l_radiance/), &
d2863 1
a2863 1
      if ( .not. ValidateVectorQuantity ( usb, quantityType=(/l_radiance/), &
d2866 1
a2866 1
      if ( .not. ValidateVectorQuantity ( lsbFraction, quantityType=(/l_sidebandRatio/), &
d2869 1
a2869 1
      if ( .not. ValidateVectorQuantity ( usbFraction, quantityType=(/l_sidebandRatio/), &
d3146 1
a3146 1
            if ( .not. interpolate ) then
d3545 1
a3545 1
            if ( .not. interpolate ) then
d3667 1
a3667 1
      if ( .not. ValidateVectorQuantity ( quantity, &
d3672 1
a3672 1
      if ( .not. ValidateVectorQuantity ( radiance, &
d3687 1
a3687 1
      if ( .not. ValidateVectorQuantity ( &
d3696 1
a3696 1
        if ( .not. ValidateVectorQuantity ( &
d3793 1
a3793 1
          &   geocAltitudeQuantity%template%instrumentModule) ) then
d3911 1
a3911 1
      if ( .not. ValidateVectorQuantity ( quantity, &
d3916 1
a3916 1
      if ( .not. ValidateVectorQuantity ( sourceQuantity, &
d3921 1
a3921 1
      if ( .not. ValidateVectorQuantity ( ratioQuantity, &
d3977 1
a3977 1
      if ( spread ) then      ! 1 instance/value given, spread to all instances
d4006 1
a4006 1
            if ( nsons(valuesNode)-1 == 1 ) then
d4017 1
a4017 1
        if ( nsons(valuesNode)-1 /= &
d4046 3
a4048 3
      type (VectorValue_T), intent(inout) ::        QUANTITY
      type (MLSChunk_T), intent(in) ::              CHUNK
      type (l1bInfo_T), intent(in) ::               L1BINFO
d4050 1
a4050 1
      type (VectorValue_T), intent(in), optional :: PRECISIONQUANTITY
d4069 1
a4069 1
      end if
d4074 1
a4074 1
      else if ( this_hdfVersion == WRONGHDFVERSION ) then
d4077 1
a4077 1
      end if
d4165 1
a4165 1
      if ( toggle(gen) .and. levels(gen) > 0 ) call trace_end( "FillVectorQuantityFromL1B" )
a4241 2
      if ( index(switches,'mag') /= 0 ) call dump ( qty )

d4330 1
a4330 1
      end if
d4380 1
a4380 1
      !    if ( .not. ValidateVectorQuantity(qty, coherent=.TRUE., stacked=.TRUE., &
d4399 1
a4399 1
      if ( extinction ) then
d4424 1
a4424 1
              if ( colTrans > 0.02_r8) betaFine(i)= transFine(i)/colTrans
d4457 1
a4457 1
          if ( ptan%values(mif,maf) .gt. -2.5) cycle ! for testing
d4464 1
a4464 1
            if ( ptan%values(mif,maf) < (outZeta(i)+outZeta(i+1))/2. .and. &
d4468 2
a4469 2
          if ( ptan%values(mif,maf) < (outZeta(1)+outZeta(2))/2.) minZ=1
          if ( ptan%values(mif,maf) > outZeta(qty%template%noSurfs)) cycle ! goto next mif
d4472 1
a4472 1
            if ( x_in(noDepths) < (outZeta(i)+outZeta(i+1))/2. .and. &
d4476 2
a4477 2
          if ( x_in(noDepths) < (outZeta(1)+outZeta(2))/2.) cycle    ! goto next mif
          if ( x_in(noDepths) > outZeta(qty%template%noSurfs)) maxZ=qty%template%noSurfs
d4479 1
a4479 1
          ! get phi along path for each mif ( phi is in degree)
d4492 1
a4492 1
              if ( phi_out(i) .lt. &     
d4557 1
a4557 1
      if ( mstr .eq. 'a+b' ) then
d4566 1
a4566 1
      if ( mstr .eq. 'a-b' ) then
d4625 2
a4626 2
            if ( associated(sq%mask) ) then
              if ( .not. associated(dq%mask)) call CreateMask ( dq )
a4789 3
! Revision 2.181  2003/01/29 01:59:19  livesey
! Changed some MLSMessages to Announce_Errors to get a line number.
!
@


2.181.2.2
log
@Add ECRtoFOV
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.181.2.1 2003/03/06 23:54:40 vsnyder Exp $"
d97 1
a97 1
    use Intrinsic, only: L_ECRtoFOV, &
d4063 1
a4063 1
        & call trace_begin ( "FillVectorQuantityFromL1B", root )
a4079 9
      case ( l_ECRtoFOV )
        call GetModuleName( quantity%template%instrumentModule, nameString )
!        nameString=TRIM(nameString)//'.tpECRtoFOV'
        nameString = AssembleL1BQtyName('ECRtoFOV', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case ( l_orbitInclination )
!        nameString='scOrbIncl'
        nameString = AssembleL1BQtyName('OrbIncl', this_hdfVersion, .FALSE., &
          & 'sc')
d4090 15
a4107 4
      case ( l_scGeocAlt )
!        nameString='scGeocAlt'
        nameString = AssembleL1BQtyName('GeocAlt', this_hdfVersion, .FALSE., &
          & 'sc')
d4119 8
a4126 15
      case ( l_tngtECI )
        call GetModuleName( quantity%template%instrumentModule, nameString )
!        nameString=TRIM(nameString)//'.tpECI'
        nameString = AssembleL1BQtyName('ECI', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case ( l_tngtGeocAlt )
        call GetModuleName( quantity%template%instrumentModule, nameString )
!        nameString=TRIM(nameString)//'.tpGeocAlt'
        nameString = AssembleL1BQtyName('GeocAlt', this_hdfVersion, .TRUE., &
          & trim(nameString))
      case ( l_tngtGeodAlt )
        call GetModuleName( quantity%template%instrumentModule, nameString )
!        nameString=TRIM(nameString)//'.tpGeodAlt'
        nameString = AssembleL1BQtyName('GeodAlt', this_hdfVersion, .TRUE., &
          & trim(nameString))
d4146 3
a4148 3
        do column=1, size(quantity%values,2)
          do row=1, size(quantity%values,1)
            if ( quantity%values(row, column) < 0.0d0 ) &
d4153 2
a4154 2
        do column=1, size(quantity%values,2)
          do row=1, size(quantity%values,1)
d4161 2
a4162 1
      if ( index(switches, 'l1b') /= 0 ) call Dump( l1bData )
a4791 3
! Revision 2.181.2.1  2003/03/06 23:54:40  vsnyder
! Add dump for magnetic field, cosmetic changes
!
@


2.181.2.3
log
@Improve error messages
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.181.2.2 2003/03/27 00:49:25 vsnyder Exp $"
d132 1
a132 1
    use String_Table, only: Display_String, Get_String
d1845 1
a1846 1
      character(127) :: QuantityName      ! For an error message
d1890 3
a1892 6
      if ( lastProfile > l2gp%nTimes ) then
        call get_string ( quantity%template%name, quantityName )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity ' // trim(quantityName) // &
        & ' has profiles beyond the end of the l2gp' )
      end if
d1894 1
a1894 1
      ! Now check that geodAngles are a sufficient match
d1898 1
a1898 3
        call display_string ( quantity%template%name, advance='no' )
        call dump ( quantity%template%phi(1,:), ' Quantity Geodetic angle' )
        call get_string ( quantity%template%name, quantityName )
d1900 1
a1900 2
          & 'Quantity ' // trim(quantityName) // &
          & ' has profiles that mismatch l2gp in geodetic angle' )
d1904 3
a1906 6
        &         quantity%template%time(1,:)) > timeTol) ) then
        call get_string ( quantity%template%name, quantityName )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Quantity ' // trim(quantityName) // &
          & ' has profiles that mismatch l2gp in time' )
      end if
a4795 3
! Revision 2.181.2.2  2003/03/27 00:49:25  vsnyder
! Add ECRtoFOV
!
@


2.181.2.4
log
@Add 'clean' switch to 'mag' dump
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.181.2.3 2003/03/27 23:18:03 vsnyder Exp $"
d4255 1
a4255 2
      if ( index(switches,'mag') /= 0 ) &
        & call dump ( qty, clean=index(switches,'clean') /= 0 )
a4804 3
! Revision 2.181.2.3  2003/03/27 23:18:03  vsnyder
! Improve error messages
!
@


2.180
log
@RHI H2O conversions moved to fwdmdl from l2/Fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.179 2003/01/16 21:48:58 vsnyder Exp $"
d1210 1
a1210 1
            & call MLSMessage ( MLSMSG_Error,ModuleName,&
d1213 1
a1213 1
            & call MLSMessage ( MLSMSG_Error,ModuleName, &
d1216 1
a1216 1
            & call MLSMessage ( MLSMSG_Error,ModuleName, &
d4790 3
@


2.179
log
@Fix a comment
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.178 2003/01/15 23:29:41 pwagner Exp $"
d129 1
d3165 6
a3170 5
               & exp(invs*( &
               & (C(T)+zeta(qIndex)+vmr_unit_cnv) * log(10.) &
               & + &
               & 3.56654*log(T/273.16) &
               & ))
d3206 16
a3221 16
      function C ( T )
        ! As found in ref.
        real(r8), intent(in)   :: T
        real(r8)               :: C
        ! Local
        real(r8), parameter    :: a0 = -1.2141649d0
        real(r8), parameter    :: a1 = 9.09718d0
        real(r8), parameter    :: a2 = 0.876793d0
        real, parameter        :: ILLEGALTEMP = UNDEFINED_VALUE
        !
        if ( T > 0.d0 ) then
          C = a0 - a1*(273.16/T -1.0d0) + a2*(1.0d0 - T/273.16)
        else
          C = ILLEGALTEMP
        end if
      end function C
d3295 2
a3296 2
      real (r8) ::                        TPrecision
      real (r8) ::                        T
d3300 3
a3302 2
      real (r8) ::                        df_db       ! RHi deriv wrt H2O
      real (r8) ::                        df_dT       ! RHi deriv wrt T
d3569 21
a3589 16
              T = TofZeta(s)
              df_db = exp(invs*( &
               & (C(T)+zeta(qIndex)+vmr_unit_cnv) * log(10.) &
               & + &
               & 3.56654*log(T/273.16) &
               & ))
              df_dT = H2OofZeta(s) * exp(invs*( &
               & (C(T)+zeta(qIndex)+vmr_unit_cnv) * log(10.) &
               & + &
               & 3.56654*log(T/273.16) &
               & )) &
               & * invs * ( dC_dT(T) * log(10.) + 3.56654 / T )
              Quantity%values(qIndex, i) = sqrt (&
               & ( H2OPrecisionofZeta(s) * df_db )**2 &
               & + ( TPrecisionofZeta(s) * df_dT )**2 &
               & )
d3625 18
a3642 18
      function dC_dT ( T )
        ! As found in ref.
        real(r8), intent(in)   :: T
        real(r8)               :: dC_dT
        ! Local
        real(r8), parameter    :: a0 = -1.2141649d0
        real(r8), parameter    :: a1 = 9.09718d0
        real(r8), parameter    :: a2 = 0.876793d0
        real, parameter        :: ILLEGALTEMP = UNDEFINED_VALUE
        !
        if ( T > 0.d0 ) then
          dC_dT = a1*(273.16/T**2) - a2/273.16
!!$          C = a0 - a1*(273.16/T -1.0d0) + a2*(1.0d0 - T/273.16)
        else
          dC_dT = ILLEGALTEMP
!!$          C = ILLEGALTEMP
        end if
      end function dC_dT
d4790 3
@


2.178
log
@Compatible with adjustable data types L2GPData
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.177 2003/01/15 02:49:06 vsnyder Exp $"
d4224 1
a4224 1
          ! Convert (/ lat(deg), lon(deg), height(m) /) to cartesian (e-radius)
d4782 3
@


2.177
log
@Get SecPerYear from Geometry module
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.176 2003/01/14 23:53:10 livesey Exp $"
d1924 2
a1925 2
            & -log10(l2gp%pressures), &  ! Old X
            & l2gp%l2gpValue(1,:,firstProfile+instance-1), & ! OldY
d4782 3
@


2.176
log
@Bug fix in magnetic model
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.175 2003/01/14 22:39:25 livesey Exp $"
a48 1
    use Geometry, only: OMEGA => W
d2077 1
d4175 1
d4215 1
a4215 1
      call feldcof ( real(qty%template%time(1,1)/(365.25*86400.0) + epoch) )
d4224 1
a4224 1
          ! Convert (/ lat, lon, height /) to cartesian
d4227 1
a4227 1
            &                     gphQty%values(surf,instance)*1e-3 /) ), xyz )
d4782 3
@


2.175
log
@Bug fixes in magnetic stuff
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.174 2003/01/14 21:58:59 vsnyder Exp $"
d4214 1
a4214 1
      call feldcof ( real(qty%template%time(1,1) + epoch) )
d4229 1
a4229 1
          qty%values(surf*3-2 : surf*3, surfOr1) = b
d4781 3
@


2.174
log
@OOPS, Left out 'template' in reference to verticalCoordinate
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.173 2003/01/14 21:34:09 vsnyder Exp $"
d939 7
a945 1
          call FillQuantityUsingMagneticModel ( quantity, key )          
d4174 1
a4174 1
    subroutine FillQuantityUsingMagneticModel ( qty, key )
d4177 1
d4194 14
a4207 2
      if ( qty%template%verticalCoordinate /= l_geodAltitude ) then
        call Announce_Error ( key, needGeodAltitude )
a4215 17
      ! Extent:
      ! qty%template%noInstances, qty%template%noSurfs

      ! Latitude, longitude, time (s since 1Jan93) etc:
      ! qty%template%geodLat(1,<profile>)

      ! Values for GPH:
      ! gph%values(<surface>,<profile>)

      ! Values for mag field
      ! qty%values(3*<surface>, <profile>)

      ! Remember, arrays start from 1, so
      ! qty%values ( surf*3-2, prof ) = xCalculation
      ! qty%values ( surf*3-1, prof ) = yCalculation
      ! qty%values ( surf*3, prof ) = zCalculation

d4226 1
a4226 1
            &                     qty%template%surfs(surfOr1,instance) /) ), xyz )
d4781 3
@


2.173
log
@More work on magnetic field vector quantity
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.172 2003/01/12 07:34:05 dwu Exp $"
d4187 1
a4187 1
      if ( qty%verticalCoordinate /= l_geodAltitude ) then
d4779 3
@


2.172
log
@with some fix for a-b manipulation
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.171 2003/01/12 05:13:50 dwu Exp $"
d78 2
a79 2
      & L_ESTIMATEDNOISE, L_EXPLICIT, L_FOLD, L_GPH, L_GPHPRECISION, &
      & L_GRIDDED, L_H2OFROMRHI, &
d129 1
a129 1
    use QuantityTemplates, only: QuantityTemplate_T
d222 2
a223 1
    integer, parameter :: BadGeocAltitudeQuantity = needGeocAltitude + 1
d939 1
a939 5
          if ( .not. got ( f_gphQuantity ) ) &
            & call Announce_error ( key, 0, 'gphQuantity not supplied' )
          gphQuantity => GetVectorQtyByTemplateIndex ( vectors(gphVectorIndex), &
            & gphQuantityIndex )
          call FillQuantityUsingMagneticModel ( quantity, gphQuantity, key )          
d4168 2
a4169 2
    subroutine FillQuantityUsingMagneticModel ( qty, gph, key )
!      use MichaelsF77Code, only: MyMagneticModel
a4170 1
      type (VectorValue_T), intent(in) :: GPH
d4173 1
d4177 1
d4180 1
a4180 10
      if ( .not. DoVGridsMatch ( qty, gph ) ) then
        call Announce_Error ( key, 0, &
          & 'Quantity and GPH quantity not on same vertical grid' )
        return
      end if
      if ( .not. DoHGridsMatch ( qty, gph ) ) then
        call Announce_Error ( key, 0, &
          & 'Quantity and GPH quantity not on same horizontal grid' )
        return
      end if
d4187 2
a4188 3
      if ( .not. ValidateVectorQuantity ( qty, quantityType=(/l_gph/) ) ) then
        call Announce_Error ( key, 0, &
          & 'GPH quantity does not describe GPH field' )
d4192 5
d4221 7
a4227 3
!           qty%values ( surf*3-2 : surf*3 ) = &
!             & MyMagenticModel ( qty%template%geodLat(surfOr1,instance), &
!             & qty%template%lon(surfOr1,instance), gph%values(surf,instance) )
d4644 1
a4644 2
      call output ( ': ' )
      call output ( "The " );
d4703 3
d4779 3
@


2.171
log
@add a-b manipulation (under the same conditions of the a+b case
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.170 2003/01/08 23:52:16 livesey Exp $"
d4512 1
a4512 1
      if ( mstr /= 'a+b' .or. mstr /= 'a-b' ) then
d4549 2
a4550 5
      if ( .not. associated ( quantity%mask ) ) then
        if(mstr .eq. 'a+b') quantity%values = a%values + b%values
        if(mstr .eq. 'a-b') quantity%values = a%values - b%values
      else
        where ( iand ( ichar(quantity%mask(:,:)), m_fill ) == 0 )
d4552 14
a4565 1
        end where
d4780 3
@


2.170
log
@Bug fix in offset radiance
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.169 2003/01/07 23:46:38 livesey Exp $"
d4512 1
a4512 1
      if ( mstr /= 'a+b' ) then
d4514 1
a4514 1
          & 'Only a+b allowed for manipulation at the moment' )
d4550 2
a4551 1
        quantity%values = a%values + b%values
d4770 3
@


2.169
log
@Added magentic model
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.168 2002/11/29 22:46:15 livesey Exp $"
d4577 1
d4769 3
@


2.168
log
@Tidyup on l2aux fill
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.167 2002/11/27 22:59:21 livesey Exp $"
d55 1
a55 1
      & F_FRACTION, F_GEOCALTITUDEQUANTITY, F_HIGHBOUND, F_H2OQUANTITY, &
d82 2
a83 2
      & L_L2AUX, L_LOSVEL, L_MANIPULATE, L_NEGATIVEPRECISION, &
      & L_NOISEBANDWIDTH, L_NONE, &
d243 1
d301 2
d595 3
d936 7
d4170 66
d4768 3
@


2.167
log
@Made the checking in FillQuantityByManipulation a little more lenient
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.166 2002/11/27 22:18:10 dwu Exp $"
d4151 4
a4154 11
      if ( .not. qty%template%minorFrame ) then
        errorCode = CantFillFromL2AUX
      else
        if ( size(l2aux%values,3) /= 1 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Can only fill from 2D minor frame l2auxs until hdf5 comes along')
        qty%values = reshape ( l2aux%values ( :, &
          & qty%template%mafIndex(1)+1 : &
          & qty%template%mafIndex(qty%template%noInstances)+1, 1 ), &
          & (/ qty%template%instanceLen, qty%template%noInstances /) )
      end if
d4689 3
@


2.166
log
@Change the error handling in the new manipulation feature. Instead of quitting, just send off a warning
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.165 2002/11/27 19:25:45 livesey Exp $"
d4445 9
a4453 2
      ! Check that this operation makes sense
      if ( a%template%name /= quantity%template%name ) then
d4455 2
a4456 1
          & 'Warning:  The a quantity is not of the same type as the result quantity' )
d4459 6
a4464 1
        if ( b%template%name /= quantity%template%name ) then
d4466 2
a4467 1
            & 'Warning:  The a quantity is not of the same type as the result quantity' )
d4696 3
@


2.165
log
@Added manipulate method and bug fix in snooper when no matrices
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.164 2002/11/21 01:18:11 livesey Exp $"
d4448 1
a4448 2
          & 'The a quantity is not of the same type as the result quantity' )
        return
d4453 1
a4453 2
            & 'The a quantity is not of the same type as the result quantity' )
          return
d4682 3
@


2.164
log
@Added negativePrecision command (as distinct from fill method of same
name).
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.163 2002/11/14 17:28:01 livesey Exp $"
d52 1
a52 1
    use INIT_TABLES_MODULE, only: F_APRIORIPRECISION, F_BOUNDARYPRESSURE, &
d60 1
a60 1
      & F_MATRIX, F_MAXITERATIONS, F_MEASUREMENTS, F_METHOD, &
d82 2
a83 1
      & L_L2AUX, L_LOSVEL, L_NEGATIVEPRECISION, L_NOISEBANDWIDTH, L_NONE, &
d97 1
a97 1
    use Intrinsic, only: Field_Indices
d238 1
d240 1
d243 1
a244 1
    type (vectorValue_T), pointer :: H2OPRECISIONQUANTITY
d275 1
d277 2
a278 1
    integer :: APRPRECQTYINDEX          ! Index of apriori precision quantity    
d281 2
d333 4
a336 3
    integer :: MatrixToFill             ! Index in database
    integer :: MatrixToKill             ! Index in database
    integer :: MatrixType               ! Type of matrix, L_... from init_tables
d563 3
d569 3
d632 2
d915 16
d1501 7
a1507 5
        do j = 1, size ( matrices )
          call GetActualMatrixFromDatabase ( matrices(j), oneMatrix )
          if ( associated ( oneMatrix ) ) &
            & noSnoopedMatrices = noSnoopedMatrices + 1
        end do
d1511 10
a1520 8
        noSnoopedMatrices = 1
        do j = 1, size ( matrices )
          call GetActualMatrixFromDatabase ( matrices(j), oneMatrix )
          if ( associated ( oneMatrix ) ) then 
            snoopMatrices(noSnoopedMatrices) = oneMatrix
            noSnoopedMatrices = noSnoopedMatrices + 1
          end if
        end do
d4428 46
d4684 4
@


2.163
log
@Made the profile fill do a 'nearest' on the input heights in the case of
coherent quantities.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.162 2002/11/13 01:06:42 pwagner Exp $"
d93 2
a94 1
      & S_FILLDIAGONAL, S_MATRIX,  S_SNOOP, S_TIME, S_TRANSFER, S_VECTOR
d272 5
a276 5
    integer :: aprPrecVctrIndex         ! Index of apriori precision vector
    integer :: aprPrecQtyIndex          ! Index of apriori precision quantity    
    integer :: bndPressQtyIndex
    integer :: bndPressVctrIndex
    integer :: ColVector                ! Vector defining columns of Matrix
d341 3
a346 3
    real(r8) :: PRECISIONFACTOR         ! For setting -ve error bars
    integer :: PRECISIONQUANTITYINDEX   ! For precision quantity
    integer :: PRECISIONVECTORINDEX     ! For precision quantity
d1391 41
d4602 4
@


2.162
log
@Fixed small bug
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.161 2002/11/06 02:01:05 livesey Exp $"
d1844 1
d1871 1
d1929 11
d4560 3
@


2.161
log
@Changes to fill from l2aux
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.160 2002/10/26 00:02:51 livesey Exp $"
d4020 1
a4020 1
        & NeverFail= .false., hdfVersion=LEVEL1_HDFVERSION )
d4547 3
@


2.160
log
@Another typo! Going too fast!
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.159 2002/10/26 00:00:07 livesey Exp $"
d1203 1
a1203 1
!          call FillVectorQuantityFromL2AUX(quantity,l2auxDatabase(l2auxIndex),errorCode)
d1742 1
d1765 6
d4053 20
d4547 3
@


2.159
log
@Typo
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.158 2002/10/25 23:59:45 livesey Exp $"
d62 1
a62 1
      & F_OFFSET_AMOUNT, &
d4520 3
@


2.158
log
@Forgot to include parameter f_offsetamount
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.157 2002/10/25 23:56:14 livesey Exp $"
d61 1
a61 1
      & F_MODEL, F_MULTIPLIER, F_NOFINEGRID, F_NOISE, F_NOISEBANDWIDTH, &&
d4520 3
@


2.157
log
@Added the offsetAmount argument default 1000K
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.156 2002/10/17 18:18:50 livesey Exp $"
d61 2
a62 1
      & F_MODEL, F_MULTIPLIER, F_NOFINEGRID, F_NOISE, F_NOISEBANDWIDTH, &
d4520 3
@


2.156
log
@Added low/high bound to vector creation
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.155 2002/10/16 20:15:27 mjf Exp $"
d334 1
d440 1
d639 6
d902 1
a902 1
          call OffsetRadianceQuantity ( quantity, radianceQuantity )
d4310 1
a4310 1
    subroutine OffsetRadianceQuantity ( quantity, radianceQuantity )
d4312 2
a4313 1
      type (VectorValue_T), intent(inout) :: RADIANCEQUANTITY
d4329 1
a4329 1
        quantity%values = quantity%values + 1000.0
d4519 3
@


2.155
log
@Added GPH precision.
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.154 2002/10/10 23:52:57 pwagner Exp $"
d55 1
a55 1
      & F_FRACTION, F_GEOCALTITUDEQUANTITY, F_H2OQUANTITY, &
d59 1
a59 1
      & F_LENGTHSCALE, F_LOSQTY, F_LSB, F_LSBFRACTION, &
d294 1
d315 3
a317 2
    integer :: LSBVECTORINDEX           ! Inddex in vector database
    integer :: LSBQUANTITYINDEX         ! Inddex in vector database
d446 2
d464 4
d476 1
a476 1
          & qtyTemplates, globalUnit=globalUnit ) ) )
d4510 3
@


2.154
log
@Added code to fill from L1bdata with hdf5; untested
@
text
@d29 1
a29 1
       "$Id: Fill.f90,v 2.153 2002/10/08 17:36:20 pwagner Exp $"
d65 2
a66 1
      & F_REFRACT, F_REFGPHQUANTITY, F_RESETSEED, F_RHIQUANTITY, F_Rows, &
d77 2
a78 1
      & L_ESTIMATEDNOISE, L_EXPLICIT, L_FOLD, L_GPH, L_GRIDDED, L_H2OFROMRHI, &
d127 1
a127 1
    use ScanModelModule, only: GetBasisGPH, Get2DHydrostaticTangentPressure
d253 1
d349 2
d665 3
d803 18
d3704 51
d4502 3
@


2.153
log
@Added idents to survive zealous Lahey optimizer
@
text
@d15 12
d29 1
a29 1
       "$Id: Fill.f90,v 2.152 2002/10/03 13:44:04 mjf Exp $"
d97 1
a97 1
      & PRECISIONSUFFIX, ReadL1BData
d112 4
a115 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, R8, RM, RV
d3838 1
d3842 1
a3847 1

d3849 14
d3866 3
a3868 1
        nameString=TRIM(nameString)//'.ptan'
d3872 2
a3873 1
        fileID = FindL1BData (l1bInfo%l1bRadIDs, nameString )
d3876 3
a3878 1
        nameString=TRIM(nameString)//'.tpECI'
d3881 3
a3883 1
        nameString=TRIM(nameString)//'.tpGeodAlt'
d3886 3
a3888 1
        nameString=TRIM(nameString)//'.tpGeocAlt'
d3890 2
a3891 1
        nameString='scECI'
d3893 2
a3894 1
        nameString='scVel'
d3896 3
a3898 1
        nameString='scVelECI'
d3900 3
a3902 1
        nameString='scVelECR'
d3904 3
a3906 1
        nameString='scGeocAlt'
d3908 3
a3910 1
        nameString='scOrbIncl'
d3919 1
a3919 1
        & NeverFail= .false. )
d4425 3
@


2.152
log
@Renamed temperaturePrecisionQuantitiy to tempPrecisionQuantity to get
names < 31 long.
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.151 2002/10/02 23:04:47 pwagner Exp $"
d21 1
d4367 4
d4376 4
@


2.151
log
@RHI now separate fill methods
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.150 2002/10/01 18:28:04 mjf Exp $"
d56 1
a56 1
      & F_SYSTEMTEMPERATURE, F_TEMPERATUREQUANTITY, F_TEMPERATUREPRECISIONQUANTITY, &
d240 1
a240 1
    type (vectorValue_T), pointer :: TEMPERATUREPRECISIONQUANTITY
d352 2
a353 2
    integer :: TEMPERATUREPRECISIONQUANTITYINDEX ! in the quantities database
    integer :: TEMPERATUREPRECISIONVECTORINDEX   ! In the vector database
d689 3
a691 3
          case ( f_temperaturePrecisionQuantity ) ! For rhi precision
            temperaturePrecisionVectorIndex = decoration(decoration(subtree(1,gson)))
            temperaturePrecisionQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
d947 1
a947 1
                  & f_h2oPrecisionquantity, f_temperaturePrecisionQuantity/) &
d958 2
a959 2
                  temperaturePrecisionQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(temperaturePrecisionVectorIndex), temperaturePrecisionQuantityIndex)
d972 1
a972 1
                  else if ( .not. ValidateVectorQuantity(temperaturePrecisionQuantity, &
d975 1
a975 1
                      & 'The temperaturePrecisionQuantity is not a temperature'  )
d989 1
a989 1
                      & h2oPrecisionQuantity, temperaturePrecisionQuantity, h2oQuantity, temperatureQuantity, &
d3051 1
a3051 1
     & sourcePrecisionQuantity, temperaturePrecisionQuantity, sourceQuantity, temperatureQuantity, &
d3076 1
a3076 1
      type (VectorValue_T), intent(in) :: temperaturePrecisionQuantity ! T(zeta)
d3132 2
a3133 2
      real (r8), dimension(TemperaturePrecisionquantity%template%noSurfs) :: &
       &                                  zetaTemperaturePrecision, oldTemperaturePrecision
d3173 1
a3173 1
        & size(temperaturePrecisionQuantity%values,dim), &
d3188 1
a3188 1
       & temperaturePrecisionQuantity%template%noSurfs, &
d3203 1
a3203 1
       &   (TemperaturePrecisionQuantity%template%noChans == Quantity%template%noChans)
d3205 1
a3205 1
       &   (TemperaturePrecisionQuantity%template%noInstances == Quantity%template%noInstances)
d3227 1
a3227 1
        if ( temperaturePrecisionquantity%template%coherent ) then
d3273 2
a3274 2
        if ( TemperaturePrecisionquantity%template%verticalCoordinate == l_pressure ) then 
          zetaTemperaturePrecision = -log10 ( TemperaturePrecisionquantity%template%surfs(:,s_T) )             
d3276 1
a3276 1
          zetaTemperaturePrecision = TemperaturePrecisionquantity%template%surfs(:,s_T)            
d3324 3
a3326 3
            do s=1, TemperaturePrecisionquantity%template%noSurfs
              qIndex = Chan_TPrecision + (s-1)*TemperaturePrecisionquantity%template%noChans
              oldTemperaturePrecision(s) = TemperaturePrecisionQuantity%values(qIndex, i_TPrecision)
d3328 1
a3328 1
            call InterpolateValues( zetaTemperaturePrecision, oldTemperaturePrecision, &
d3360 1
a3360 1
              TPrecisionofZeta(s) = TemperaturePrecisionQuantity%values(qIndex, i)
d3373 1
a3373 1
             &   isVectorQtyMasked(temperaturePrecisionQuantity, qIndex, i) .or. &
d4371 3
@


2.150
log
@New Fill for RHi precision including T error.
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.149 2002/09/26 20:41:04 vsnyder Exp $"
d63 2
a64 1
      & L_ESTIMATEDNOISE, L_EXPLICIT, L_FOLD, L_GPH, L_GRIDDED, L_HEIGHT, &
d70 1
d885 110
a1083 128
          case ( l_rhi )
            ! Later may allow inverted fill specified by /invert field
            ! which would fill h2o quantity form rhi
            if ( .not. any(got( &
             & (/f_h2oquantity, f_temperatureQuantity/) &
             & )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill rhi'  )
            else
              if ( any(got( &
                & (/f_h2oPrecisionquantity, f_temperaturePrecisionQuantity/) &
                & )) ) then ! precision
                if ( .not. any(got( &
                  & (/f_h2oPrecisionquantity, f_temperaturePrecisionQuantity/) &
                  & )) ) then
                  call Announce_error ( key, No_Error_code, &
                    & 'Missing a required field to fill rhi precision'  )
                else
                  h2oQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(h2oVectorIndex), h2oQuantityIndex)
                  temperatureQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(temperatureVectorIndex), temperatureQuantityIndex)
                  h2oPrecisionQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(h2oPrecisionVectorIndex), h2oPrecisionQuantityIndex)
                  temperaturePrecisionQuantity => GetVectorQtyByTemplateIndex( &
                    & vectors(temperaturePrecisionVectorIndex), temperaturePrecisionQuantityIndex)
                  if ( .not. ValidateVectorQuantity(h2oQuantity, &
                    & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                    call Announce_Error ( key, No_Error_code, &
                      & 'The h2oQuantity is not a vmr for the H2O molecule'  )
                  else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                    & quantityType=(/l_temperature/)) ) then
                    call Announce_Error ( key, No_Error_code, &
                      & 'The temperatureQuantity is not a temperature'  )
                  else if ( .not. ValidateVectorQuantity(h2oPrecisionQuantity, &
                    & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                    call Announce_Error ( key, No_Error_code, &
                      & 'The h2oPrecisionQuantity is not a vmr for the H2O molecule'  )
                  else if ( .not. ValidateVectorQuantity(temperaturePrecisionQuantity, &
                    & quantityType=(/l_temperature/)) ) then
                    call Announce_Error ( key, No_Error_code, &
                      & 'The temperaturePrecisionQuantity is not a temperature'  )
                    ! This is not the right way to do an invert fill
                    ! The first quantity named on the fill line must
                    ! _always_ be the one getting filled according to
                    ! the pattern '[verb] [direct-object] [modifier(s)]'
                    ! see case l_vmr below for how to do this
                    !else if ( invert ) then
                    !  call FillRHIFromH2O ( key, h2oquantity, &
                    !  & Quantity, temperatureQuantity, &
                    !  & dontMask, ignoreZero, ignoreNegative, interpolate, &
                    !  & .true., &   ! Mark Undefined values?
                    !  & invert )    ! invert rather than convert?
                  else
                    call FillRHIPrecisionFromH2O ( key, quantity, &
                      & h2oPrecisionQuantity, temperaturePrecisionQuantity, h2oQuantity, temperatureQuantity, &
                      & dontMask, ignoreZero, ignoreNegative, interpolate, &
                      & .true., &   ! Mark Undefined values?
                      & invert )    ! invert rather than convert?
                  end if
                end if
              else ! value
                h2oQuantity => GetVectorQtyByTemplateIndex( &
                  & vectors(h2oVectorIndex), h2oQuantityIndex)
                temperatureQuantity => GetVectorQtyByTemplateIndex( &
                  & vectors(temperatureVectorIndex), temperatureQuantityIndex)
                if ( .not. ValidateVectorQuantity(h2oQuantity, &
                  & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                  call Announce_Error ( key, No_Error_code, &
                    & 'The h2oQuantity is not a vmr for the H2O molecule'  )
                else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                  & quantityType=(/l_temperature/)) ) then
                  call Announce_Error ( key, No_Error_code, &
                    & 'The temperatureQuantity is not a temperature'  )
                  ! This is not the right way to do an invert fill
                  ! The first quantity named on the fill line must
                  ! _always_ be the one getting filled according to
                  ! the pattern '[verb] [direct-object] [modifier(s)]'
                  ! see case l_vmr below for how to do this
                  !else if ( invert ) then
                  !  call FillRHIFromH2O ( key, h2oquantity, &
                  !  & Quantity, temperatureQuantity, &
                  !  & dontMask, ignoreZero, ignoreNegative, interpolate, &
                  !  & .true., &   ! Mark Undefined values?
                  !  & invert )    ! invert rather than convert?
                else
                  call FillRHIFromH2O ( key, quantity, &
                    & h2oQuantity, temperatureQuantity, &
                    & dontMask, ignoreZero, ignoreNegative, interpolate, &
                    & .true., &   ! Mark Undefined values?
                    & invert )    ! invert rather than convert?
                end if
              end if
            end if
          case ( l_vmr )
            ! Later may allow other special fills of vmr quantities
            ! For now only vmr from rhi
            if ( .not. any(got( &
             & (/f_rhiQuantity, f_temperatureQuantity/) &
             & )) ) then
              call Announce_error ( key, No_Error_code, &
              & 'Missing a required field to fill h2o from rhi'  )
            else
              sourceQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(sourceVectorIndex), sourceQuantityIndex)
              temperatureQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(temperatureVectorIndex), temperatureQuantityIndex)
              if ( .not. ValidateVectorQuantity(sourceQuantity, &
                & quantityType=(/l_rhi/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The rhiQuantity is not an rhi'  )
              else if ( .not. ValidateVectorQuantity(Quantity, &
                & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The Quantity is not a vmr for the H2O molecule'  )
              else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                & quantityType=(/l_temperature/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The temperatureQuantity is not a temperature'  )
              else
                invert = .true.
                call FillRHIFromH2O ( key, quantity, &
                & sourceQuantity, temperatureQuantity, &
                & dontMask, ignoreZero, ignoreNegative, interpolate, &
                & .true., &   ! Mark Undefined values?
                & invert )    ! invert rather than convert?
              end if
            end if
d4371 3
@


2.149
log
@Get Omega from Geometry instead of Units -- that's where it really belongs
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.148 2002/09/25 20:08:14 livesey Exp $"
d43 1
d56 2
a57 1
      & F_SYSTEMTEMPERATURE, F_TEMPERATUREQUANTITY, F_TEMPLATE, F_TNGTECI, &
d219 1
d238 1
d275 2
d350 2
d546 3
d687 3
d981 83
a1063 29
              h2oQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(h2oVectorIndex), h2oQuantityIndex)
              temperatureQuantity => GetVectorQtyByTemplateIndex( &
                & vectors(temperatureVectorIndex), temperatureQuantityIndex)
              if ( .not. ValidateVectorQuantity(h2oQuantity, &
                & quantityType=(/l_vmr/), molecule=(/l_h2o/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The h2oQuantity is not a vmr for the H2O molecule'  )
              else if ( .not. ValidateVectorQuantity(temperatureQuantity, &
                & quantityType=(/l_temperature/)) ) then
                call Announce_Error ( key, No_Error_code, &
                & 'The temperatureQuantity is not a temperature'  )
              ! This is not the right way to do an invert fill
              ! The first quantity named on the fill line must
              ! _always_ be the one getting filled according to
              ! the pattern '[verb] [direct-object] [modifier(s)]'
              ! see case l_vmr below for how to do this
              !else if ( invert ) then
              !  call FillRHIFromH2O ( key, h2oquantity, &
              !  & Quantity, temperatureQuantity, &
              !  & dontMask, ignoreZero, ignoreNegative, interpolate, &
              !  & .true., &   ! Mark Undefined values?
              !  & invert )    ! invert rather than convert?
              else
                call FillRHIFromH2O ( key, quantity, &
                & h2oQuantity, temperatureQuantity, &
                & dontMask, ignoreZero, ignoreNegative, interpolate, &
                & .true., &   ! Mark Undefined values?
                & invert )    ! invert rather than convert?
d3064 416
d4387 3
@


2.148
log
@Made -g less verbose
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.147 2002/09/13 18:10:10 pwagner Exp $"
d36 1
d114 1
a114 1
    use UNITS, only: Omega, PI
d3903 3
@


2.147
log
@May change matrix precision rm from r8
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.146 2002/09/12 22:07:05 livesey Exp $"
d3094 2
a3095 1
      if ( toggle(gen) ) call trace_begin ( "FillVectorQtyHydrostatically", key )
d3107 2
a3108 1
	  if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d3116 2
a3117 1
	  if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d3128 2
a3129 1
	  if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d3136 2
a3137 1
	  if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d3177 2
a3178 1
	  if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d3188 2
a3189 1
      if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically" )
d3359 2
a3360 1
      if ( toggle(gen) ) call trace_begin ("FillVectorQuantityFromL1B",root)
d3404 2
a3405 1
        if ( toggle(gen) ) call trace_end ( "FillVectorQuantityFromL1B")
d3430 1
a3430 1
      if (toggle(gen) ) call trace_end( "FillVectorQuantityFromL1B" )
d3902 3
@


2.146
log
@Added masking to interpolated vector fill
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.145 2002/09/10 20:50:33 livesey Exp $"
d94 1
a94 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, R8
d1454 1
a1454 1
      real (r8), dimension(:,:), pointer :: M ! The matrix being filled
d1523 1
a1523 1
            m = 0.0
d1556 1
a1556 1
              condition = d%values(:,i) <= 0.0
d1558 1
a1558 1
                if ( condition(j) ) M(j,j) = 1.0
d1562 1
a1562 1
                if ( condition(j) ) M(j,j) = 0.0
d3893 3
@


2.145
log
@Added interpolated vector fill
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.144 2002/09/10 01:00:32 livesey Exp $"
d3432 2
a3433 1
      logical :: mySurfs
d3478 12
d3495 1
a3495 1
          & newSurfs, qty%values, &
d3497 1
a3497 1
        qty%values = exp ( qty%values )
d3501 1
a3501 1
          & newSurfs, qty%values, &
d3505 7
d3893 3
@


2.144
log
@Added calls to NullifyMatrix
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.143 2002/09/06 00:54:13 livesey Exp $"
d84 2
a85 1
    use ManipulateVectorQuantities, only: DOHGRIDSMATCH, DOVGRIDSMATCH
d1107 17
a1123 11
          if ( quantity%template%name /= sourceQuantity%template%name ) &
            & call Announce_Error ( key, No_Error_Code, &
            & 'Quantity and sourceQuantity do not have the same template' )

          ! If we have a mask and we're going to obey it then do so
          if ( associated(quantity%mask) .and. .not. dontMask ) then
            where ( iand ( ichar(quantity%mask(:,:)), m_Fill ) == 0 )
              quantity%values(:,:) = sourceQuantity%values(:,:)
            end where
          else ! Otherwise, just blindly copy
            quantity%values = sourceQuantity%values
d3424 76
d3873 3
@


2.143
log
@Tiny change
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.142 2002/09/05 21:48:54 livesey Exp $"
d90 1
a90 1
      & Matrix_T, UpdateDiagonal
d475 1
d480 1
d485 1
d490 1
d3790 3
@


2.142
log
@More fixes in transfer skipmask
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.141 2002/09/05 20:49:38 livesey Exp $"
a3611 1
      integer :: Dummy                   ! Dummy integer
d3623 1
a3623 1
        dq => GetVectorQtyByTemplateIndex ( dest, source%template%quantities(sqi), dummy )
d3786 3
@


2.141
log
@Added skipMask to transfer
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.140 2002/08/28 01:13:52 livesey Exp $"
d1274 3
a1276 3
          gson = subtree(2,gson) ! Now the value of said argument
          if ( nsons(son) > 1 ) then
            fieldValue = decoration(subtree(2,son)) ! The field's value
d1278 1
a1278 1
            fieldValue = son
d1282 1
a1282 1
            sourceVectorIndex = decoration(decoration(gson))
d1284 1
a1284 1
            destinationVectorIndex = decoration(decoration(gson))
a1289 1

d3787 3
@


2.140
log
@Added OffsetRadianceQuantity
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.139 2002/08/26 20:01:09 livesey Exp $"
d51 1
a51 1
      & F_SCECI, F_SCVEL, F_SCVELECI, F_SCVELECR, F_SEED, &
d328 1
d1270 1
d1275 5
d1285 2
d1292 1
a1292 1
          & vectors(destinationVectorIndex) )
d3606 1
a3606 1
    subroutine TransferVectors ( source, dest )
d3610 1
d3628 8
a3635 6
          if (associated(sq%mask)) then
            if (.not. associated(dq%mask)) call CreateMask ( dq )
            dq%mask = sq%mask
          else
            if ( associated(dq%mask) ) &
              & call Deallocate_test ( dq%mask, 'dq%mask', ModuleName )
d3788 3
@


2.139
log
@Added instances argument to profile fill
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.138 2002/08/21 23:06:12 livesey Exp $"
d63 2
a64 1
      & L_ORBITINCLINATION, L_PHITAN, L_PLAIN, L_PRESSURE, L_PROFILE, L_PTAN, &
d118 1
a118 1
      & VectorTemplate_T, VectorValue_T, M_Fill
d816 7
d3573 23
d3776 3
@


2.138
log
@Bug fix in profile fill
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.137 2002/08/20 22:10:49 vsnyder Exp $"
d42 1
a42 1
      & F_IGNORENEGATIVE, F_IGNOREZERO, F_INTEGRATIONTIME, &
d99 1
a99 1
    use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
d275 1
d536 2
d818 1
d820 1
a820 1
            & vectors(vectorIndex)%globalUnit, dontMask )
d1697 1
a1697 1
      & globalUnit, dontMask )
d1704 1
d1709 8
a1716 5
      integer :: HEIGHTUNIT               ! Unit for height
      integer :: NOPOINTS                 ! Number of points supplied
      integer :: I                        ! Loop counter
      integer :: TESTUNIT                 ! Unit for value
      logical :: LOCALOUTHEIGHTS          ! Set if out heights is our own variable
d1721 1
a1724 2
      intrinsic :: Spread                 ! Because there's a variable of
                                          ! the same name in the host
d1729 1
a1729 1
        & coherent=.true., frequencyCoordinate=(/l_none/) ) ) &
d1739 1
a1739 1
      nullify ( heights, values, outHeights, outValues )
d1742 4
a1745 2
      call Allocate_test ( outValues, quantity%template%instanceLen, &
        &'outValues', ModuleName )
d1784 9
a1792 10
      ! Spread it into the other instances, worry about the mask
      if ( .not. associated ( quantity%mask ) ) then
        quantity%values = spread ( &
          & outValues, 2, quantity%template%noInstances )
      else
        do i = 1, quantity%template%noInstances
          where ( iand ( ichar(quantity%mask(:,i)) , m_fill ) == 0 )
            quantity%values(:,i) = outValues(:)
          end where
        end do
d1794 19
d1819 1
d3745 3
@


2.137
log
@Move USE statements from module scope to procedure scope
@
text
@d17 1
a17 1
       "$Id: Fill.f90,v 2.136 2002/08/20 19:30:24 livesey Exp $"
d1778 1
a1778 1
          & outValues, quantity%template%noInstances, 2 )
d3717 3
@


2.136
log
@Typo!
@
text
@d8 2
a9 84
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Expr_M, only: EXPR
  use GriddedData, only: GriddedData_T
  ! We need many things from Init_Tables_Module.  First the fields:
  use INIT_TABLES_MODULE, only: F_APRIORIPRECISION, F_BOUNDARYPRESSURE, &
    & F_COLUMNS, F_DESTINATION, F_DIAGONAL, F_NOISE, &
    & F_GEOCALTITUDEQUANTITY, F_EARTHRADIUS, F_EXPLICITVALUES, &
    & F_EXTINCTION, F_FRACTION, F_H2OQUANTITY, F_LOSQTY,&
    & F_dontMask, F_IGNORENEGATIVE, F_IGNOREZERO, &
    & F_INTEGRATIONTIME, F_INTERPOLATE, F_INVERT, F_INTRINSIC, F_ISPRECISION, &
    & F_LSB, F_LSBFRACTION, &
    & F_LENGTHSCALE, F_MATRIX, F_MAXITERATIONS, F_METHOD, F_MEASUREMENTS, &
    & F_MODEL, F_MULTIPLIER, F_NOFINEGRID, F_NOISEBANDWIDTH, F_PRECISION,  &
    & F_ORBITINCLINATION, F_PRECISIONFACTOR, F_PROFILEVALUES, &
    & F_PTANQUANTITY, F_PHITAN, F_QUANTITY, F_RADIANCEQUANTITY, F_RATIOQUANTITY, &
    & F_REFRACT, F_REFGPHQUANTITY, F_RESETSEED, F_RHIQUANTITY, F_Rows, &
    & F_SCECI, F_SCVEL, F_SCVELECI, F_SCVELECR, F_SEED, &
    & F_SOURCE, F_SOURCEGRID, &
    & F_SOURCEL2AUX, F_SOURCEL2GP, F_SOURCEQUANTITY, F_SOURCEVGRID, &
    & F_SPREAD, F_SUPERDIAGONAL, &
    & F_SYSTEMTEMPERATURE, F_TEMPERATUREQUANTITY, F_TEMPLATE, F_TNGTECI, &
    & F_TYPE, F_USB, F_USBFRACTION, F_VECTOR, F_VMRQUANTITY, FIELD_FIRST, FIELD_LAST
  ! Now the literals:
  use INIT_TABLES_MODULE, only: L_ADDNOISE, L_BOUNDARYPRESSURE, L_CHISQCHAN, &
    & L_CHISQMMAF, L_CHISQMMIF, L_CHOLESKY, &
    & L_COLUMNABUNDANCE, L_ESTIMATEDNOISE, L_EXPLICIT, L_FOLD, L_GPH, L_GRIDDED, L_HEIGHT, &
    & L_HYDROSTATIC, L_ISOTOPE, L_ISOTOPERATIO, L_KRONECKER, L_L1B, L_L2GP, L_L2AUX, &
    & L_RECTANGLEFROMLOS, L_NEGATIVEPRECISION, L_NOISEBANDWIDTH, L_ORBITINCLINATION, &
    & L_LOSVEL, L_NONE, L_PLAIN, &
    & L_PRESSURE, L_PHITAN, L_PROFILE, L_PTAN, L_RADIANCE, L_RHI, &
    & L_REFGPH, L_REFRACT, L_SCECI, L_SCGEOCALT, L_SCVEL, L_SCVELECI, L_SCVELECR, &
    & L_SIDEBANDRATIO, L_SPD, L_SPECIAL, L_SYSTEMTEMPERATURE, &
    & L_TEMPERATURE, L_TNGTECI, L_TNGTGEODALT, &
    & L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VGRID, L_VMR, L_XYZ, L_ZETA
  ! Now the specifications:
  use INIT_TABLES_MODULE, only: S_DESTROY, S_DUMP, S_FILL, S_FILLCOVARIANCE, &
    & S_FILLDIAGONAL, S_MATRIX,  S_SNOOP, S_TIME, S_TRANSFER, S_VECTOR
  ! Now some arrays
  use Intrinsic, only: Field_Indices
  use Intrinsic, only: &
    & PHYQ_Dimensionless, PHYQ_Invalid, PHYQ_Temperature, &
    & PHYQ_Time, PHYQ_Length, PHYQ_Pressure, PHYQ_Zeta
  use L1BData, only: DeallocateL1BData, Dump, FindL1BData, L1BData_T, &
    & PRECISIONSUFFIX, ReadL1BData
  use L2GPData, only: L2GPData_T
  use L2AUXData, only: L2AUXData_T
  use L3ASCII, only: L3ASCII_INTERP_FIELD
  use LEXER_CORE, only: PRINT_SOURCE
  use ManipulateVectorQuantities, only: DOHGRIDSMATCH, DOVGRIDSMATCH
  use MatrixModule_0, only: Sparsify, MatrixInversion
  use MatrixModule_1, only: AddToMatrixDatabase, CreateEmptyMatrix, &
    & DestroyMatrix, Dump, GetActualMatrixFromDatabase, GetDiagonal, &
    & FindBlock, GetKindFromMatrixDatabase, GetFromMatrixDatabase, K_SPD, &
    & Matrix_Cholesky_T, Matrix_Database_T, Matrix_Kronecker_T, Matrix_SPD_T, &
    & Matrix_T, UpdateDiagonal
  ! NOTE: If you ever want to include defined assignment for matrices, please
  ! carefully check out the code around the call to snoop.
  use MLSCommon, only: L1BInfo_T, MLSChunk_T, R8
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, MLSMSG_Deallocate
  use MLSNumerics, only: InterpolateValues
  use MLSRandomNumber, only: drang, mls_random_seed, MATH77_RAN_PACK
  use MLSSignals_m, only: GetSignalName, GetModuleName, IsModuleSpacecraft
  use Molecules, only: L_H2O
  use MoreTree, only: Get_Boolean, Get_Field_ID, Get_Spec_ID
  use OUTPUT_M, only: BLANKS, OUTPUT
  use QuantityTemplates, only: QuantityTemplate_T
  use ScanModelModule, only: GetBasisGPH, Get2DHydrostaticTangentPressure
  use SnoopMLSL2, only: SNOOP
  use String_Table, only: Display_String
  use Time_M, only: Time_Now
  use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, &
    & SOURCE_REF, SUB_ROSA, SUBTREE
  use TREE_TYPES, only: N_NAMED, N_SET_ONE
  use UNITS, only: Omega, PI
  use VectorsModule, only: AddVectorToDatabase, &
    & ClearUnderMask, CopyVector, CreateMask, CreateVector, &
    & DestroyVectorInfo, Dump, &
    & GetVectorQtyByTemplateIndex, isVectorQtyMasked, MaskVectorQty, &
    & rmVectorFromDatabase, ValidateVectorQuantity, Vector_T, &
    & VectorTemplate_T, VectorValue_T, M_Fill
  use VGridsDatabase, only: VGRID_T, GETUNITFORVERTICALCOORDINATE
a14 73
  ! -----     Private declarations     ---------------------------------

  integer, private :: ERROR
  logical, parameter :: DEEBUG = .FALSE.                 ! Usually FALSE

  ! Error codes for "announce_error"  
  integer, parameter :: No_Error_code = 0
  integer, parameter :: Wrong_Number = No_Error_code+1     ! of fields of a VECTOR command
  integer, parameter :: UnknownQuantityName = wrong_number + 1
  integer, parameter :: Source_not_in_db = unknownQuantityName + 1
  integer, parameter :: ZeroProfilesFound = source_not_in_db + 1
  integer, parameter :: ZeroGeodSpan = zeroProfilesFound + 1
  integer, parameter :: CantFillFromL2AUX = ZeroGeodSpan + 1
  integer, parameter :: VectorWontMatchPDef = cantFillFromL2AUX + 1
  integer, parameter :: CantFillFromL1B = vectorWontMatchPDef + 1

  ! Error codes for "Matrix" specification
  integer, parameter :: MissingField = cantFillFromL1B + 1

  ! More Error codes relating to FillVector
  integer, parameter :: NumInstancesisZero = missingField + 1
  integer, parameter :: NumSurfsisZero = numInstancesisZero + 1
  integer, parameter :: NumChansisZero = numSurfsisZero + 1
  integer, parameter :: ObjIsFullRank3 = numChansisZero + 1
  integer, parameter :: OtherErrorInFillVector = objIsFullRank3 + 1
  integer, parameter :: NoSourceGridGiven= otherErrorInFillVector + 1
  integer, parameter :: NoSourceL2GPGiven= noSourceGridGiven + 1
  integer, parameter :: NoSourceL2AUXGiven= noSourceL2GPGiven + 1
  integer, parameter :: NoExplicitValuesGiven= noSourceL2AUXGiven + 1
  integer, parameter :: NoSourceQuantityGiven= noExplicitValuesGiven + 1
  integer, parameter :: InvalidExplicitFill= noSourceQuantityGiven + 1
  integer, parameter :: BadUnitsForExplicit= invalidExplicitFill + 1
  integer, parameter :: BadUnitsForIntegrationTime = badUnitsForExplicit + 1
  integer, parameter :: BadUnitsForSystemTemperature = badUnitsForIntegrationTime + 1
  integer, parameter :: BadIsotopeFill = badUnitsForSystemTemperature + 1
  integer, parameter :: BadlosGridFill = badIsotopeFill + 1
  integer, parameter :: CantInterpolate3d = badlosGridFill + 1

  ! Error codes resulting from FillCovariance
  integer, parameter :: NotSPD = CantInterpolate3D + 1
  integer, parameter :: NotImplemented = notSPD + 1
  integer, parameter :: BothFractionAndLength = NotImplemented + 1

  ! Error codes resulting from squeeze
  integer, parameter :: N1_is_zero = BothFractionAndLength + 1
  integer, parameter :: N2_is_zero = n1_is_zero + 1
  integer, parameter :: N3_is_zero = n2_is_zero + 1
  integer, parameter :: M1_too_small = n3_is_zero + 1
  integer, parameter :: M2_too_small = m1_too_small + 1
  integer, parameter :: Not_permutation = m2_too_small + 1
  integer, parameter :: Allocation_err = not_permutation + 1
  integer, parameter :: Deallocation_err = allocation_err + 1

  ! Miscellaneous
  integer, parameter :: Miscellaneous_err = deallocation_err + 1
  integer, parameter :: ErrorReadingL1B = miscellaneous_err + 1
  integer, parameter :: NeedTempREFGPH = errorReadingL1B + 1
  integer, parameter :: NeedH2O = needTempRefGPH + 1
  integer, parameter :: NeedOrbitInclination = needH2O + 1
  integer, parameter :: NeedGeocAltitude = needOrbitInclination + 1
  integer, parameter :: BadGeocAltitudeQuantity = needGeocAltitude + 1
  integer, parameter :: BadTemperatureQuantity = badGeocAltitudeQuantity + 1
  integer, parameter :: BadREFGPHQuantity = badTemperatureQuantity + 1
  integer, parameter :: NonConformingHydrostatic = badREFGPHQuantity + 1
  integer, parameter :: BadUnitsForMaxIterations = nonConformingHydrostatic + 1
  integer, parameter :: NoSpecialFill = badUnitsForMaxIterations + 1
  integer, parameter :: BadlosVelFill = noSpecialFill + 1
  integer, parameter :: NotZetaForGrid = BadLosVelFill + 1
  integer, parameter :: BadEstNoiseFill = NotZetaForGrid + 1
  integer, parameter :: BadRefractFill = BadEstNoiseFill + 1
  
  real, parameter ::    UNDEFINED_VALUE = -999.99 ! Same as %template%badvalue

d17 1
a17 1
       "$Id: Fill.f90,v 2.135 2002/08/20 19:19:41 livesey Exp $"
a22 3
  ! This module performs the Fill operation in the Level 2 software.  
  ! This takes a vector template, and creates and fills an appropriate vector

d27 3
a29 2
  subroutine MLSL2Fill ( Root, L1bInfo, GriddedData, VectorTemplates, Vectors, &
    & QtyTemplates , Matrices, vGrids, L2GPDatabase, L2AUXDatabase, Chunks, ChunkNo )
d34 86
d123 1
a123 1
    type (griddedData_T), dimension(:), pointer :: GriddedData
d134 73
d701 1
a701 1
          endif
d707 2
a708 2
            endif
          elseif ( got(f_seed) ) then
d712 1
a712 1
            enddo
d718 1
a718 1
              endif
d724 2
a725 2
              endif
            endif
d731 2
a732 2
            endif
          endif
d740 1
a740 1
            enddo
d743 1
a743 1
          endif
d748 1
a748 1
          endif
d857 1
a857 1
            enddo
d860 1
a860 1
          endif
d865 1
a865 1
          endif
d893 1
a893 1
            endif
d908 1
a908 1
            endif
d923 1
a923 1
            endif
d938 1
a938 1
            endif
d956 1
a956 1
              elseif ( .not. ValidateVectorQuantity(temperatureQuantity, &
d965 1
a965 1
              !elseif ( invert ) then
d977 2
a978 2
              endif
            endif
d996 1
a996 1
              elseif ( .not. ValidateVectorQuantity(Quantity, &
d1000 1
a1000 1
              elseif ( .not. ValidateVectorQuantity(temperatureQuantity, &
d1011 2
a1012 2
              endif
            endif
d1060 1
a1060 1
            & ( quantity, griddedData(gridIndex), errorCode )
d1135 1
a1135 1
          endif
d1234 1
a1234 1
          endif
d1241 2
a1242 2
          endif
        elseif ( got(f_matrix) ) then
d1249 1
a1249 1
          endif
d1252 1
a1252 1
        endif
d1323 2
d1326 2
d1334 1
a1334 1
      endif
a1338 1
  end subroutine MLSL2Fill
d1340 26
a1365 1
  ! =====     Private Procedures     =====================================
d1367 16
d1384 8
a1391 13
  ! ------------------------------------------- addGaussianNoise ---
  subroutine addGaussianNoise ( key, quantity, sourceQuantity, &
            & noiseQty, multiplier )
    ! A special fill: quantity = sourceQuantity + g() noiseQty
    ! where g() is a random number generator with mean 0 and std. dev. 1
    ! Generalized into ( a sourceQuantity + b g() noiseQty )
    ! where a and b are multipliers)
    ! Formal arguments
    integer, intent(in) :: KEY
    type (VectorValue_T), intent(inout) ::      quantity
    type (VectorValue_T), intent(in) ::         sourceQuantity
    type (VectorValue_T), intent(in) ::         noiseQty
    real, dimension(:), intent(in), optional :: multiplier
d1393 1
a1393 3
    ! Local variables
    integer                          ::    ROW, COLUMN
    real                             ::    a, b
d1395 1
a1395 48
    ! Executable code
    ! First check that things are OK.
    if (.not. FillableChiSq ( quantity, &
      & sourceQuantity, noiseQty ) ) then
      call Announce_error ( key, No_Error_code, &
      & 'Incompatibility among vector quantities adding noise'  )
      return
    endif
    
   ! Either multiplier = [a, b] or multiplier = b are possible
    if ( .not. present(multiplier) ) then
      a = 1.
      b = 1.
    elseif (&
    & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
    & ) then
      a = 1.
      b = 1.
    elseif ( multiplier(2) == UNDEFINED_VALUE ) then
      a = 1.
      b = multiplier(1)
    else
      a = multiplier(1)
      b = multiplier(2)
    endif
    
    do column=1, size(quantity%values(1, :))
      do row=1, size(quantity%values(:, 1))
        quantity%values(row, column) = &
          & sourceQuantity%values(row, column) * a &
          & + &
          & drang() * noiseQty%values(row, column) * b
      enddo
    enddo

  end subroutine addGaussianNoise

  !------------------------------------- FillCovariance ------------

  subroutine FillCovariance ( covariance, vectors, diagonal, &
    & lengthScale, fraction, invert )
    ! This routine fills a covariance matrix from a given set of vectors
    type (Matrix_SPD_T), intent(inout) :: COVARIANCE ! The matrix to fill
    type (Vector_T), dimension(:), intent(in), target :: VECTORS ! The vector database
    integer, intent(in) :: DIAGONAL     ! Index of vector describing diagonal
    integer, intent(in) :: LENGTHSCALE  ! Index of vector describing length scale
    integer, intent(in) :: FRACTION     ! Index of vector describing fraction
    logical, intent(in) :: INVERT       ! We actually want the inverse
d1397 52
a1448 2
    ! Local parameters
    real(r8), parameter :: DECADE = 16000.0 ! Number of meters per decade.
d1450 4
a1453 52
    ! Local variables
    type (VectorValue_T), pointer :: d  ! Diagonal
    type (VectorValue_T), pointer :: l  ! Length
    type (VectorValue_T), pointer :: f  ! Fraction
    type (QuantityTemplate_T), pointer :: qt ! One quantity template
    type (Vector_T) :: DMASKED ! Masked diagonal
    type (Vector_T) :: LMASKED ! Masked length scale
    integer :: B                        ! Block index
    integer :: I                        ! Instance index
    integer :: J                        ! Loop index
    integer :: K                        ! Loop index
    integer :: N                        ! Size of matrix block
    integer :: Q                        ! Quantity index
    real (r8), dimension(:,:), pointer :: M ! The matrix being filled
    real (r8), dimension(:), pointer :: SURFS ! The vertical coordinate
    real (r8) :: distance               ! Distance between two points
    real (r8) :: meanLength             ! Geometric mean length scale
    real (r8) :: meanDiag               ! Geometric mean diagonal value
    real (r8) :: thisFraction           ! Geometric mean diagonal value
    logical, dimension(:), pointer :: condition ! Condition

    ! Executable code

    ! Apply mask to diagonal
    nullify ( m, condition )
    call CopyVector ( Dmasked, vectors(diagonal), clone=.true., &
      & vectorNameText='_Dmasked' )
    call ClearUnderMask ( Dmasked )
    
    if ( lengthScale == 0 ) then
      call updateDiagonal ( covariance, vectors(diagonal), square=.true., &
        & invert=invert )

    else ! Do a more complex fill.

      ! Setup some stuff
      call CopyVector ( Lmasked, vectors(lengthScale), clone=.true., &
        & vectorNameText='_Lmasked' ) 
      call ClearUnderMask ( Lmasked )
      
      ! Check the validity of the supplied vectors
      if ( covariance%m%row%vec%template%id /= &
        & dMasked%template%id ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "diagonal and covariance not compatible in fillCovariance" )
      if ( covariance%m%row%vec%template%id /= &
        & lMasked%template%id ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "lengthScale and covariance not compatible in fillCovariance" )
      if ( lMasked%globalUnit /= phyq_length ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "length vector does not have dimensions of length" )

      if ( fraction /= 0 ) then
d1455 3
a1457 3
          & vectors(fraction)%template%id ) call MLSMessage ( MLSMSG_Error, &
          & ModuleName, "fraction and covariance not compatible in fillCovariance" )
        if ( vectors(fraction)%globalUnit /= phyq_dimensionless ) &
d1459 1
a1459 4
          & "fraction vector is not dimensionless" )
      else
        thisFraction = 1.0
      end if
d1461 10
a1470 14
      ! Now loop over the quantities
      do q = 1, covariance%m%col%vec%template%noQuantities

        ! Setup pointers etc.
        d => dMasked%quantities(q)
        qt => d%template
        l => lMasked%quantities(q)
        if (fraction /=0) f => vectors(fraction)%quantities(q)
        n = qt%instanceLen
        if ( qt%coherent ) surfs => qt%surfs(:,1)
        if ( .not. qt%regular ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Unable to handle irregular quantity in FillCovariance" )
        call Allocate_test ( m, n, n, 'M', ModuleName )
d1472 2
a1473 9
        ! Loop over the instances
        do i = 1, qt%noInstances
          if ( .not. qt%coherent ) surfs => qt%surfs(:,i)

          ! Clear the working matrix and load the diagonal
          m = 0.0
          do j = 1, n
            m(j,j) = d%values(j,i) ** 2.0
          end do
d1475 15
a1489 24
          ! Now if appropriate add off diagonal terms.
          if ( any( qt%verticalCoordinate == (/ l_height, l_pressure, l_zeta /) ) ) then
            ! Loop over off diagonal terms
            do j = 1, n
              do k = j+1, n
                meanLength = sqrt ( l%values(j,i) * l%values(k,i) )
                meanDiag = sqrt ( m(j,j) * m(k,k) ) 
                if ( fraction /= 0) thisFraction = f%values(j,i)
                select case (qt%verticalCoordinate)
                case ( l_height )
                  distance = abs ( surfs ( (j-1)/qt%noChans + 1 ) - &
                    & surfs ( (k-1)/qt%noChans + 1) )
                case ( l_zeta )
                  distance = abs ( surfs ( (j-1)/qt%noChans + 1 ) - &
                    & surfs ( (k-1)/qt%noChans + 1 ) ) * decade
                case ( l_pressure )
                  distance = abs ( -log10 ( surfs( (j-1)/qt%noChans + 1) ) + &
                    &               log10 ( surfs( (k-1)/qt%noChans + 1) ) ) / decade
                end select
                if ( meanLength > 0.0 ) &
                  & m(j,k) = meanDiag*thisFraction*exp(-distance/meanLength)
              end do                    ! Loop over k (in M)
            end do                      ! Loop over j (in M)
          end if                        ! An appropriate vertical coordinate
d1491 2
a1492 4
          ! Now we may need to invert this, if so we need to be clever.
          if ( invert ) then
            call Allocate_test ( condition, n, 'condition', ModuleName )
            condition = d%values(:,i) <= 0.0
d1494 1
a1494 1
              if ( condition(j) ) M(j,j) = 1.0
a1495 6
            call MatrixInversion(M, upper=.true.)
            do j = 1, n
              if ( condition(j) ) M(j,j) = 0.0
            end do
            call Deallocate_test ( condition, 'condition', ModuleName )
          endif
d1497 38
a1534 6
          b = FindBlock ( covariance%m%col, q, i )
          call Sparsify ( M, covariance%m%block(b,b) )
        end do                          ! Loop over instances
        call Deallocate_test ( m, 'M', ModuleName )
      end do                            ! Loop over quantities
    end if                              ! A non diagonal fill
d1536 22
a1557 2
    call DestroyVectorInfo ( DMasked )
    call DestroyVectorInfo ( LMasked )
d1559 2
a1560 1
  end subroutine FillCovariance
d1562 4
a1565 6
  !=============================== FillVectorQuantityFromGrid ============
  subroutine FillVectorQuantityFromGrid(quantity,grid, errorCode)
    ! Dummy arguments
    type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
    type (GriddedData_T), intent(in) :: GRID ! Grid to fill it from
    integer, intent(out) :: ERRORCODE   ! Error code (one of constants defined above)
d1567 2
a1568 3
    ! Local variables
    integer :: instance,surf            ! Loop counter
    integer :: instIndex,surfIndex      ! Indices
d1570 2
a1571 2
    ! Executable code
    errorCode = 0
d1573 43
a1615 4
    if (quantity%template%verticalCoordinate /= l_zeta) then
      errorCode=NotZetaForGrid
      return
    endif
d1617 4
a1620 2
    instIndex=1
    surfIndex=1
d1622 3
a1624 2
    do instance = 1, quantity%template%noInstances
      if (.not. quantity%template%stacked) instIndex=instance
d1626 13
a1638 12
      do surf = 1, quantity%template%noSurfs
        if (.not. quantity%template%coherent) surfIndex=surf
        call l3ascii_interp_field(grid, quantity%values(surf,instance), &
          & pressure=10.0**(-quantity%template%surfs(surf,instIndex)), &
          & lat=quantity%template%geodLat(surfIndex,instance), &
          & lon=quantity%template%lon(surfIndex,instance), &
          & lst=quantity%template%solarTime(surfIndex,instance), &
          & sza=quantity%template%solarZenith(surfIndex,instance), &
          & date=quantity%template%time(surfIndex,instance))
      end do                            ! End surface loop
    end do                              ! End instance loop
  end subroutine FillVectorQuantityFromGrid
d1640 9
a1648 2
  !=============================== FillVectorQuantityFromL2GP ==========
  subroutine FillVectorQuantityFromL2GP ( quantity,l2gp, interpolate, errorCode )
d1650 8
a1657 2
    ! If the times, pressures, and geolocations match, fill the quantity with
    ! the appropriate subset of profiles from the l2gp
d1659 4
a1662 10
    ! Dummy arguments
    type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
    type (L2GPData_T), intent(in) :: L2GP ! L2GP to fill from
    logical, intent(in) :: interpolate  ! Flag
    integer, intent(out) :: errorCode ! Error code

    ! Local parameters
    real(r8), parameter :: TOLERANCE=0.05 ! Tolerence for angles
    real(r8), parameter :: TIMETOL=5.0  ! Tolerence for time (not sure why this
    ! needs to be so big !????????? NJL)
d1664 4
a1667 22
    ! Local variables
    integer ::    FIRSTPROFILE, LASTPROFILE
    integer, dimension(1) :: FIRSTPROFILEASARRAY
    integer :: INSTANCE                 ! Loop counter 

    real (r8), dimension(quantity%template%noSurfs) :: outZeta

    errorCode=0
    ! Make sure this quantity is appropriate
    if (.not. ValidateVectorQuantity(quantity, coherent=.TRUE., stacked=.TRUE., &
      & verticalCoordinate= (/ l_pressure, l_zeta /) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Quantity to fill is not on pressure or zeta coordinates' )

    if ( (quantity%template%noChans/=l2gp%nFreqs) .and. &
      &  ((quantity%template%noChans/=1) .or. (l2gp%nFreqs/=0)) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Quantity and l2gp have different number of channels' )

    if ( quantity%template%noSurfs /= l2gp%nLevels .and. (.not. interpolate) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Quantity and l2gp have different number of surfaces (set interpolate?)' )
d1669 18
a1686 11
    if (.not. interpolate) then 
      if ( quantity%template%verticalCoordinate == l_pressure ) then
        if ( any(ABS(-LOG10(quantity%template%surfs(:,1))+ &
          & LOG10(l2gp%pressures)) > TOLERANCE) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Quantity and l2gp are on different surfaces (set interpolate?)' )
      else                                ! Must be l_zeta
        if ( any(ABS(quantity%template%surfs(:,1)+ &
          & LOG10(l2gp%pressures)) > TOLERANCE) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Quantity and l2gp are on different surfaces (set interpolate?)' )
a1687 1
    end if
d1689 36
a1724 18
    ! Attempt to match up the first location
    firstProfileAsArray=MINLOC(ABS(quantity%template%phi(1,1)-l2gp%geodAngle))
    firstProfile=firstProfileAsArray(1)

    ! Well, the last profile has to be noInstances later, check this would be OK
    lastProfile=firstProfile+quantity%template%noInstances-1
    if (lastProfile > l2gp%nTimes ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Quantity has profiles beyond the end of the l2gp' )

    ! Now check that geodAngle's are a sufficient match
    if (any(abs(l2gp%geodAngle(firstProfile:lastProfile)-&
      &         quantity%template%phi(1,:)) > tolerance) ) then
      call dump ( l2gp%geodAngle(firstProfile:lastProfile), 'L2GP geodetic angle' )
      call dump ( quantity%template%phi(1,:), 'Quantity Geodetic angle' )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Quantity has profiles that mismatch l2gp in geodetic angle' )
    end if
d1726 11
a1736 4
    if (any(abs(l2gp%time(firstProfile:lastProfile)- &
      &         quantity%template%time(1,:)) > timeTol) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Quantity has profiles that mismatch l2gp in time' )
d1738 22
a1759 4
    if (interpolate .and. quantity%template%noChans /= 1) then
      errorCode=cantInterpolate3D
      return
    endif
d1761 1
a1761 5
    if (.not. interpolate) then
      quantity%values=RESHAPE(l2gp%l2gpValue(:,:,firstProfile:lastProfile),&
        & (/quantity%template%noChans*quantity%template%noSurfs,&
        &   quantity%template%noInstances/))
    else
d1763 4
a1766 1
        outZeta = -log10 ( quantity%template%surfs(:,1) )
d1768 3
a1770 25
        outZeta = quantity%template%surfs(:,1)
      endif
      do instance = 1, quantity%template%noInstances
        call InterpolateValues ( &
          & -log10(l2gp%pressures), &  ! Old X
          & l2gp%l2gpValue(1,:,firstProfile+instance-1), & ! OldY
          & outZeta, & ! New X
          & quantity%values(:,instance), & ! New Y
          & method='Linear', extrapolate='Clamp' )
      enddo
    endif

  end subroutine FillVectorQuantityFromL2GP

  ! -------------------------------------- FillVectorQuantityFromProfile --
  subroutine FillVectorQtyFromProfile ( key, quantity, valuesNode, &
    & globalUnit, dontMask )
    ! This fill is slightly complicated.  Given a values array along
    ! the lines of [ 1000mb : 1.0K, 100mb : 1.0K,  10mb : 2.0K] etc. it
    ! does the linear interpolation appropriate to perform the fill.
    integer, intent(in) :: KEY          ! Tree node
    type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
    integer, intent(in) :: VALUESNODE   ! Tree node for values
    integer, intent(in) :: GLOBALUNIT   ! Possible global unit
    logical, intent(in) :: DONTMASK     ! If set don't follow the fill mask
d1772 92
a1863 12
    ! Local variables
    integer :: HEIGHTUNIT               ! Unit for height
    integer :: NOPOINTS                 ! Number of points supplied
    integer :: I                        ! Loop counter
    integer :: TESTUNIT                 ! Unit for value
    logical :: LOCALOUTHEIGHTS          ! Set if out heights is our own variable
    real (r8), dimension(:), pointer :: HEIGHTS ! Heights for the points
    real (r8), dimension(:), pointer :: VALUES ! Values for the points
    real (r8), dimension(:), pointer :: OUTHEIGHTS ! Heights for output
    real (r8), dimension(:), pointer :: OUTVALUES ! Single profile for output
    real (r8), dimension(2) :: EXPRVALUE ! Value of expression
    integer, dimension(2) :: EXPRUNIT   ! Unit for expression
d1865 2
a1866 1
    ! Executable code
d1868 3
a1870 64
    ! Check the quantity is amenable to this type of fill
    if ( .not. ValidateVectorQuantity ( quantity, &
      & coherent=.true., frequencyCoordinate=(/l_none/) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'The quantity is not amenable to a profile fill' )

    ! Check the units
    testUnit = quantity%template%unit
    if ( globalUnit /= phyq_Invalid ) testUnit = globalUnit

    ! Set some stuff up
    noPoints = nsons ( valuesNode ) - 1
    nullify ( heights, values, outHeights, outValues )
    call Allocate_test ( heights, noPoints, 'heights', ModuleName )
    call Allocate_test ( values, noPoints, 'values', ModuleName )
    call Allocate_test ( outValues, quantity%template%instanceLen, &
      &'outValues', ModuleName )

    ! Loop over the values
    do i = 1, noPoints
      ! Get value from tree
      call expr ( subtree ( i+1, valuesNode ), exprUnit, exprValue )
      ! Check height unit OK
      heightUnit = GetUnitForVerticalCoordinate ( quantity%template%verticalCoordinate )
      if ( exprUnit(1) /= heightUnit .and. exprUnit(1) /= PHYQ_Dimensionless &
        & .and. .not. ( exprUnit(1) == PHYQ_Pressure .and. heightUnit == PHYQ_Zeta ) ) &
        & call Announce_error ( valuesNode, 0, 'Bad height units for profile fill' )
      ! Store height
      if ( heightUnit == PHYQ_Zeta ) then
        ! Assume zeta coordinates are expressed in mb
        heights(i) = -log10 ( exprValue(1) )
      else
        heights(i) = exprValue(1)
      end if
      ! Check value unit OK
      if ( all ( exprUnit(2) /= (/ testUnit, PHYQ_Dimensionless /) ) ) &
        & call Announce_error ( valuesNode, 0, 'Bad units for profile fill' )
      ! Store value
      values ( i ) = exprValue(2)
    end do

    ! Get the appropriate height coordinate for output, for pressure take log.
    if ( quantity%template%verticalCoordinate == l_pressure ) then
      localOutHeights = .true.
      call Allocate_test ( outHeights, quantity%template%noSurfs, &
        & 'outHeights', ModuleName )
      outHeights = -log10 ( quantity%template%surfs(:,1) )
    else
      localOutHeights = .false.
      outHeights => quantity%template%surfs(:,1)
    endif

    ! Now do the interpolation for the first instance
    call InterpolateValues ( heights, values, outHeights, &
      & outValues, 'Linear', extrapolate='Constant' )
    ! Spread it into the other instances, worry about the mask
    if ( .not. associated ( quantity%mask ) ) then
      quantity%values = spread ( &
        & outValues, quantity%template%noInstances, 2 )
    else
      do i = 1, quantity%template%noInstances
        where ( iand ( ichar(quantity%mask(:,i)) , m_fill ) == 0 )
          quantity%values(:,i) = outValues(:)
        end where
d1872 1
a1872 17
    end if
    ! Finish off
    if ( localOutHeights ) call Deallocate_test ( outHeights, &
      & 'outHeights', ModuleName )
    call Deallocate_test ( heights, 'heights', ModuleName )
    call Deallocate_test ( values, 'values', ModuleName )
    call Deallocate_test ( outValues, 'outValues', ModuleName )
  end subroutine FillVectorQtyFromProfile

  ! ------------------------------------------- FillLOSVelocity ---
  subroutine FillLOSVelocity ( key, qty, tngtECI, scECI, scVel)
    ! A special fill from geometry arguments
    integer, intent(in) :: KEY
    type (VectorValue_T), intent(inout) :: QTY
    type (VectorValue_T), intent(in) :: TNGTECI
    type (VectorValue_T), intent(in) :: SCECI
    type (VectorValue_T), intent(in) :: SCVEL
d1874 25
d1900 2
a1901 6
    ! Local variables
    integer :: MAF                      ! Loop counter
    integer :: MIF                      ! Loop counter
    integer :: noMAFs                   ! Number of major frames
    integer :: noMIFs                   ! Number of minor frames for this module
    integer :: x,y,z                    ! Indicies into the vectors
d1903 1
a1903 2
    real (r8), dimension(3) :: tngtVel   ! Due to rotation of earth
    real (r8), dimension(3) :: los       ! Normalised line of sight vector
d1905 11
a1915 50
    ! Executable code
    ! First check that things are OK.
    if ( .not. ValidateVectorQuantity ( qty, &
      & quantityType=(/l_losVel/), &
      & minorFrame=.true., &
      & frequencyCoordinate=(/l_none/) ) ) call Announce_Error ( key, No_Error_Code, &
      & 'Quantity to fill is not a valid LOS Velocity' )
    if ( .not. ValidateVectorQuantity ( tngtECI, &
      & quantityType=(/l_tngtECI/), &
      & minorFrame=.true., &
      & frequencyCoordinate=(/l_xyz/) ) ) call Announce_Error ( key, No_Error_Code, &
      & 'Tangent ECI quantity is not of an appropriate form' )
    if ( .not. ValidateVectorQuantity ( scECI, &
      & quantityType=(/l_scECI/), &
      & minorFrame=.true., &
      & frequencyCoordinate=(/l_xyz/) ) ) call Announce_Error ( key, No_Error_Code, &
      & 'Spacecraft ECI quantity is not of an approriate form' )
    if ( qty%template%instrumentModule /= tngtECI%template%instrumentModule ) &
      & call Announce_Error ( key, No_Error_Code, &
      & 'LOS Velocity and Tangent ECI quantities are not for the same module' )
    if ( .not. IsModuleSpacecraft ( scECI%template%instrumentModule ) ) &
      & call Announce_Error ( key, No_Error_Code, &
      & 'Spacecraft ECI quantity is not for the spacecraft' )

    noMAFs = qty%template%noInstances
    noMIFs = qty%template%noSurfs

    do maf = 1, noMAFs
      do mif = 1, noMIFs

        ! First compute the tangent point velocity in ECI coordinates due 
        ! to the rotation of the earth.  This no doubt makes approximations
        ! due to the slight non alignment between the earth's rotation axis and
        ! the ECI z axis, but I'm going to ignore this.

        ! Work out the indices in 3*mif,maf space
        x = 1 + 3*(mif-1)
        y = x+1
        z = x+2

        tngtVel= omega* (/ -tngtECI%values(y,maf), &
          &                 tngtECI%values(x,maf), 0.0_r8 /)

        ! Now compute the line of sight direction normal
        los = tngtECI%values(x:z,maf) - scECI%values(x:z,maf)
        los = los / sqrt(sum(los**2))

        ! Now compute the net velocity in this direction.  For the moment I'll
        ! assume +ve means the sc and tp are moving apart, and -ve that they're
        ! getting closer.
d1917 11
a1927 2
        qty%values(mif,maf) = dot_product(tngtVel, los) - &
          &                   dot_product(scVel%values(x:z,maf), los)
d1929 1
a1929 5
        ! Note that even though x,y,z have been used up to now for a GHz/THz
        ! minor frame quantity, they're OK with this sc one too.
      end do
    end do
  end subroutine FillLOSVelocity
d1931 11
a1941 68
  ! ------------------------------------------- FillableChiSq ---
  function FillableChiSq ( qty, measQty, modelQty, noiseQty ) result ( aok )
    ! Purpose (A)
    !   Check whether we may proceed with special fill of chi squared
    !   case where all VectorValue_T args present
    ! Purpose (B)
    !   Check whether we may proceed with special fill of addNoise
    !   case where missing noiseQty arg
    type (VectorValue_T), intent(in) ::              QTY
    type (VectorValue_T), intent(in) ::              modelQty
    type (VectorValue_T), intent(in) ::              measQty
    type (VectorValue_T), optional, intent(in) ::    noiseQty
    LOGICAL ::                                       AOK
    
    ! What we will check is that (for the args we have been given):
    ! (0) all quantities have associated values
    ! (1) all quantities have same molecule
    ! (2) all quantities have same signal
    ! (3) all quantities have same HGrid
    ! (4A) all but qty (chiSq) have same VGrid
    ! (4B) all have same VGrid
    ! Ah, but radiances have no VGrid or HGrid,
    ! and molecule should be part of signal, so
    ! if radiances need only check on signal
    ! if vmr, check on others

   ! Local variables
    LOGICAL ::       minorFrame   ! TRUE if radiances, FALSE if vmr

    aok = .true.
    
    ! (0)
    if ( present(noiseQty) ) then
      aok = associated(noiseQty%values)
      if ( DEEBUG .and. .not. associated(noiseQty%values) ) &
        & call announce_error( 0, No_Error_code, &
        & 'Noise values unassociated in FillableChiSq')
    endif
    aok = aok .and. &
      & associated(qty%values) .and. &
      & associated(measQty%values) .and. &
      & associated(modelQty%values)

    if ( DEEBUG ) then
      if ( .not. associated(qty%values) ) &
        & call announce_error( 0, No_Error_code, &
        & 'Quantity values unassociated in FillableChiSq')
      if ( .not. associated(measQty%values) ) &
        & call announce_error( 0, No_Error_code, &
        & 'Measurements values unassociated in FillableChiSq')
      if ( .not. associated(modelQty%values) ) &
        & call announce_error( 0, No_Error_code, &
        & 'Model values unassociated in FillableChiSq')
    endif

    if ( .not. aok ) return

    minorFrame = qty%template%minorFrame .or. qty%template%majorFrame
    ! (1)
    if (.not. minorFrame ) then
      aok = aok .and. &
        & (qty%template%molecule == measQty%template%molecule) &
        & .and. &
        & (qty%template%molecule == modelQty%template%molecule)
      if ( present(noiseQty) ) aok = aok &
        & .and. &
        & (qty%template%molecule == noiseQty%template%molecule)
    endif
d1943 10
a1952 10
    ! (2)
    if (minorFrame ) then
      aok = aok .and. &
        & (qty%template%signal == measQty%template%signal) &
        & .and. &
        & (qty%template%signal == modelQty%template%signal)
      if ( present(noiseQty) ) aok = aok &
        & .and. &
        & (qty%template%signal == noiseQty%template%signal)
    endif
d1954 23
a1976 9
    ! (3)
    if (.not. minorFrame ) then
      aok = aok .and. &
        & DoHgridsMatch( qty, measQty ) &
        & .and. &
        & DoHgridsMatch( qty, modelQty )
      if ( present(noiseQty) ) aok = aok &
        & .and. &
        & DoHgridsMatch( qty, noiseQty )
d1978 2
a1979 37
      ! (4)
      aok = aok .and. &
        & DoVgridsMatch( measqty, modelQty )
      if ( present(noiseQty) ) then
        aok = aok &
        & .and. &
        & DoVgridsMatch( measqty, noiseQty )
      else
        aok = aok &
        & .and. &
        & DoVgridsMatch( measqty, Qty )
      endif
    endif
    
    return
  end function FillableChiSq

  ! ------------------------------------------- FillChiSqChan ---
  subroutine FillChiSqChan ( key, qty, measQty, modelQty, noiseQty, &
  & dontMask, ignoreZero, ignoreNegative, multiplier, &
  & firstInstance, lastInstance )
    ! A special fill of chi squared 
    ! broken out according to channels
    ! Formal arguments
    integer, intent(in) :: KEY
    type (VectorValue_T), intent(inout) :: QTY
    type (VectorValue_T), intent(in) ::    modelQty
    type (VectorValue_T), intent(in) ::    measQty
    type (VectorValue_T), intent(in) ::    noiseQty
    logical, intent(in)           ::       dontMask    ! Use even masked values
    logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
    logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
    real, dimension(:), intent(in), optional :: multiplier

    integer, intent(in), optional ::       firstInstance, lastInstance
    ! The last two are set if only part (e.g. overlap regions) of the quantity
    ! is to be stored in qty
d1981 53
a2033 12
    ! Local variables
    real(r8), dimension(:), pointer  ::    VALUES => NULL()
    integer ::                             UseFirstInstance, UseLastInstance, &
    &                                      NoOutputInstances
    integer ::                             C           ! Channel loop counter
    integer ::                             S           ! Surface loop counter
    integer ::                             I           ! Instances
    integer ::                             QINDEX
    integer ::                             NOCHANS
    integer ::                             N           ! Num. of summed values
    logical ::                             skipMe
    real                             ::    a, b
d2035 24
a2058 44
    ! Executable code
    
   ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
    if ( .not. present(multiplier) ) then
      a = 1.
      b = 1.
    elseif (&
    & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
    & ) then
      a = 1.
      b = 1.
    elseif ( multiplier(2) == UNDEFINED_VALUE ) then
      a = 0.
      if ( multiplier(1) /= 0. ) a = 1./multiplier(1)
      b = a
    else
      a = multiplier(1)
      b = multiplier(2)
    endif

    ! First check that things are OK.
    if (.not. ValidateVectorQuantity ( qty, &
      & quantityType=(/l_chiSqChan/), majorFrame=.true.) ) then
      call Announce_error ( key, No_Error_code, &
      & 'Attempting to fill wrong quantity with chi^2 channelwise'  )
      if ( DEEBUG ) then
        call output('major frame? ', advance = 'no')
        call output(qty%template%majorFrame, advance = 'no')
        call output('   quantity type ', advance = 'no')
        call output(qty%template%quantityType, advance = 'no')
        call output('   compared with ', advance = 'no')
        call output(l_chiSqChan, advance = 'yes')
      endif
      return
    elseif (.not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
      call Announce_error ( key, No_Error_code, &
      & 'Incompatibility among vector quantities filling chi^2 channelwise'  )
      return
    elseif (any ( noiseQty%values == 0.0) .and. &
      & .not. (ignoreZero .or. .not. dontMask) ) then
      call Announce_error ( key, No_Error_code, &
      & 'A vanishing error filling chi^2 channelwise'  )
      return
    endif
d2060 1
a2060 7
    ! Work out what to do with the first and last Instance information
    
    if ( PRESENT(firstInstance) ) then
      useFirstInstance = firstInstance
    else
      useFirstInstance = 1
    end if
d2062 5
a2066 65
    if ( PRESENT(lastInstance) ) then
      useLastInstance = lastInstance
    else
      useLastInstance = qty%template%noInstances
    end if
    noOutputInstances = useLastInstance-useFirstInstance+1
    ! If we've not been asked to output anything then don't carry on
    if ( noOutputInstances < 1 ) return

    call allocate_test(values, measQty%template%noSurfs, &
      & 'chi^2 unsummed', ModuleName)
    noChans = qty%template%noChans
    do i=useFirstInstance, useLastInstance
      do c=1, noChans
        N = 0
        values = 0.0
        do s=1, measQty%template%noSurfs
          qIndex = c + (s-1)*nochans
          skipMe = &
          & .not. dontMask .and. ( &
          &   isVectorQtyMasked(measQty, qIndex, i) .or. &
          &   isVectorQtyMasked(modelQty, qIndex, i) .or. &
          &   isVectorQtyMasked(noiseQty, qIndex, i) ) &
          & .or. (ignoreNegative .and. noiseQty%values(qIndex, i) < 0.0 ) &
          & .or. (ignoreZero .and. noiseQty%values(qIndex, i) == 0.0 )
          if ( .not. skipMe ) then
            values(s) = ( &
            & (a*measQty%values(qIndex, i) - b*modelQty%values(qIndex, i)) &
            & / &
            & noiseQty%values(qIndex, i) &
            &  ) ** 2
            N = N + 1
          endif
        enddo
        if ( N > 0 ) then
          qty%values(c, i) = sum(values) / N
        else
          qty%values(c, i) = 0.
        endif
      enddo
    enddo
    call deallocate_test(values, &
      & 'chi^2 unsummed', ModuleName)
  end subroutine FillChiSqChan

  ! ------------------------------------------- FillChiSqMMaf ---
  subroutine FillChiSqMMaf ( key, qty, measQty, modelQty, noiseQty, &
  & dontMask, ignoreZero, ignoreNegative, multiplier, &
  & firstInstance, lastInstance )
    ! A special fill of chi squared 
    ! broken out according to major frames
    ! Formal arguments
    integer, intent(in) :: KEY
    type (VectorValue_T), intent(inout) :: QTY
    type (VectorValue_T), intent(in) ::    modelQty
    type (VectorValue_T), intent(in) ::    measQty
    type (VectorValue_T), intent(in) ::    noiseQty
    logical, intent(in)           ::       dontMask    ! Use even masked values
    logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
    logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
    real, dimension(:), intent(in), optional :: multiplier

    integer, intent(in), optional ::       firstInstance, lastInstance
    ! The last two are set if only part (e.g. overlap regions) of the quantity
    ! is to be stored in the qty
d2068 98
a2165 9
    ! Local variables
    real(r8), dimension(:), pointer  ::    VALUES => NULL()
    integer ::                             UseFirstInstance, UseLastInstance, &
    &                                      NoOutputInstances
    integer ::                             I           ! Instances
    integer ::                             ROW         ! Running 1st coord
    integer ::                             INSTANCELEN ! Num of rows
    integer ::                             N           ! Num. of summed values
    logical ::                             skipMe
d2167 24
a2190 2
    ! Executable code
    real                             ::    a, b
d2192 1
a2192 44
    ! Executable code
    
   ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
    if ( .not. present(multiplier) ) then
      a = 1.
      b = 1.
    elseif (&
    & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
    & ) then
      a = 1.
      b = 1.
    elseif ( multiplier(2) == UNDEFINED_VALUE ) then
      a = 0.
      if ( multiplier(1) /= 0. ) a = 1./multiplier(1)
      b = a
    else
      a = multiplier(1)
      b = multiplier(2)
    endif

    ! First check that things are OK.
    if (.not. ValidateVectorQuantity ( qty, &
      & quantityType=(/l_chiSqMMaf/), majorFrame=.true.) ) then
      call Announce_error ( key, No_Error_code, &
      & 'Attempting to fill wrong quantity with chi^2 MMAFwise'  )
      if ( DEEBUG ) then
        call output('major frame? ', advance = 'no')
        call output(qty%template%majorFrame, advance = 'no')
        call output('   quantity type ', advance = 'no')
        call output(qty%template%quantityType, advance = 'no')
        call output('   compared with ', advance = 'no')
        call output(l_chiSqMMaf, advance = 'yes')
      endif
      return
    elseif (.not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
      call Announce_error ( key, No_Error_code, &
      & 'Incompatibility among vector quantities filling chi^2 MMAFwise'  )
      return
    elseif (any ( noiseQty%values == 0.0) .and. &
      & .not. (ignoreZero .or. .not. dontMask) ) then
      call Announce_error ( key, No_Error_code, &
      & 'A vanishing noise filling chi^2 MMAFwise'  )
      return
    endif
d2194 5
a2198 7
    ! Work out what to do with the first and last Instance information
    
    if ( PRESENT(firstInstance) ) then
      useFirstInstance = firstInstance
    else
      useFirstInstance = 1
    end if
d2200 2
a2201 20
    if ( PRESENT(lastInstance) ) then
      useLastInstance = lastInstance
    else
      useLastInstance = qty%template%noInstances
    end if
    noOutputInstances = useLastInstance-useFirstInstance+1
    ! If we've not been asked to output anything then don't carry on
    if ( noOutputInstances < 1 ) return

    instanceLen = measQty%template%noChans * measQty%template%noSurfs
    call allocate_test(values, instanceLen, &
      & 'chi^2 unsummed', ModuleName)
    do i=useFirstInstance, useLastInstance
      if( .not. (.not. dontMask .or. ignoreNegative .or. ignoreZero )) then
          values = ( &
          & (measQty%values(:, i) - modelQty%values(:, i)) &
          & / &
          & noiseQty%values(:, i) &
          &  ) ** 2
          qty%values(1, i) = sum(values) / instanceLen
d2203 13
a2215 13
        N = 0
        values = 0.0
        do row = 1, instanceLen
          skipMe = &
          & .not. dontMask .and. ( &
          &   isVectorQtyMasked(measQty, row, i) .or. &
          &   isVectorQtyMasked(modelQty, row, i) .or. &
          &   isVectorQtyMasked(noiseQty, row, i) ) &
          & .or. (ignoreNegative .and. noiseQty%values(row, i) < 0.0 ) &
          & .or. (ignoreZero .and. noiseQty%values(row, i) == 0.0 )
          if ( .not. skipMe ) then
            values(row) = ( &
            & (a*measQty%values(row, i) - b*modelQty%values(row, i)) &
d2217 1
a2217 1
            & noiseQty%values(row, i) &
d2219 1
a2219 5
            N = N + 1
          endif
        enddo
        if ( N > 0 ) then
          qty%values(1, i) = sum(values) / N
d2221 85
a2305 28
          qty%values(1, i) = 0.
        endif
      endif
    enddo
    call deallocate_test(values, &
      & 'chi^2 unsummed', ModuleName)
  end subroutine FillChiSqMMaf

  ! ------------------------------------------- FillChiSqMMif ---
  subroutine FillChiSqMMif ( key, qty, measQty, modelQty, noiseQty, &
  & dontMask, ignoreZero, ignoreNegative, multiplier, &
  & firstInstance, lastInstance )
    ! A special fill of chi squared 
    ! broken out according to Mifs
    ! Formal arguments
    integer, intent(in) :: KEY
    type (VectorValue_T), intent(inout) :: QTY
    type (VectorValue_T), intent(in) ::    modelQty
    type (VectorValue_T), intent(in) ::    measQty
    type (VectorValue_T), intent(in) ::    noiseQty
    logical, intent(in)           ::       dontMask    ! Use even masked values
    logical, intent(in)           ::       ignoreZero  ! Ignore 0 values of noiseQty
    logical, intent(in)           ::       ignoreNegative  ! Ignore <0 values of noiseQty
    real, dimension(:), intent(in), optional :: multiplier

    integer, intent(in), optional ::       firstInstance, lastInstance
    ! The last two are set if only part (e.g. overlap regions) of the quantity
    ! is to be stored in the qty
d2307 32
a2338 11
    ! Local variables
    real(r8), dimension(:), pointer  ::    VALUES => NULL()
    integer ::                             UseFirstInstance, UseLastInstance, &
    &                                      NoOutputInstances
    integer ::                             C           ! Channel loop counter
    integer ::                             S           ! Surface loop counter
    integer ::                             I           ! Instances
    integer ::                             QINDEX
    integer ::                             NOMIFS
    integer ::                             N           ! Num. of summed values
    logical ::                             skipMe
d2340 121
a2460 2
    ! Executable code
    real                             ::    a, b
d2462 1
a2462 44
    ! Executable code
    
   ! Either multiplier = [a, b] or multiplier = 1/a if a=b are possible
    if ( .not. present(multiplier) ) then
      a = 1.
      b = 1.
    elseif (&
    & multiplier(1) == UNDEFINED_VALUE .and. multiplier(2) == UNDEFINED_VALUE &
    & ) then
      a = 1.
      b = 1.
    elseif ( multiplier(2) == UNDEFINED_VALUE ) then
      a = 0.
      if ( multiplier(1) /= 0. ) a = 1./multiplier(1)
      b = a
    else
      a = multiplier(1)
      b = multiplier(2)
    endif

    ! First check that things are OK.
    if (.not. ValidateVectorQuantity ( qty, &
      & quantityType=(/l_chiSqMMif/), minorFrame=.true.) ) then
      call Announce_error ( key, No_Error_code, &
      & 'Attempting to fill wrong quantity with chi^2 MMIFwise'  )
      if ( DEEBUG ) then
        call output('minor frame? ', advance = 'no')
        call output(qty%template%minorFrame, advance = 'no')
        call output('   quantity type ', advance = 'no')
        call output(qty%template%quantityType, advance = 'no')
        call output('   compared with ', advance = 'no')
        call output(l_chiSqMMif, advance = 'yes')
      endif
      return
    elseif (.not. FillableChiSq ( qty, measQty, modelQty, noiseQty ) ) then
      call Announce_error ( key, No_Error_code, &
      & 'Incompatibility among vector quantities filling chi^2 MMIFwise'  )
      return
    elseif (any ( noiseQty%values == 0.0) .and. &
      & .not. (ignoreZero .or. .not. dontMask) ) then
      call Announce_error ( key, No_Error_code, &
      & 'A vanishing noise filling chi^2 MMIFwise'  )
      return
    endif
d2464 5
a2468 7
    ! Work out what to do with the first and last Instance information
    
    if ( PRESENT(firstInstance) ) then
      useFirstInstance = firstInstance
    else
      useFirstInstance = 1
    end if
d2470 25
a2494 36
    if ( PRESENT(lastInstance) ) then
      useLastInstance = lastInstance
    else
      useLastInstance = qty%template%noInstances
    end if
    noOutputInstances = useLastInstance-useFirstInstance+1
    ! If we've not been asked to output anything then don't carry on
    if ( noOutputInstances < 1 ) return

    call allocate_test(values, measQty%template%noChans, &
      & 'chi^2 unsummed', ModuleName)
    noMIFs = measQty%template%noSurfs
    do i=useFirstInstance, useLastInstance
      do s=1, noMIFs
        N = 0
        values = 0.0
        do c=1, measQty%template%noChans
          qIndex = c + (s-1)*measQty%template%noChans
          skipMe = &
          & .not. dontMask .and. ( &
          &   isVectorQtyMasked(measQty, qIndex, i) .or. &
          &   isVectorQtyMasked(modelQty, qIndex, i) .or. &
          &   isVectorQtyMasked(noiseQty, qIndex, i) ) &
          & .or. (ignoreNegative .and. noiseQty%values(qIndex, i) < 0.0 ) &
          & .or. (ignoreZero .and. noiseQty%values(qIndex, i) == 0.0 )
          if ( .not. skipMe ) then
            values(c) = ( &
            & (a*measQty%values(qIndex, i) - b*modelQty%values(qIndex, i)) &
            & / &
            & noiseQty%values(qIndex, i) &
            &  ) ** 2
            N = N + 1
          endif
        enddo
        if ( N > 0 ) then
          qty%values(s, i) = sum(values) / N
d2496 2
a2497 36
          qty%values(s, i) = 0.
        endif
      enddo
    enddo
    call deallocate_test(values, &
      & 'chi^2 unsummed', ModuleName)
  end subroutine FillChiSqMMif

  ! ------------------------------------------- FillColAbundance ---
  subroutine FillColAbundance ( key, qty, bndPressQty, vmrQty, &
  & firstInstance, lastInstance )
    ! A special fill according to Appendix A of EOS MLS ATBD
    ! JPL D-16159
    ! EOS MLS DRL 601 (part 3)
    ! ATBD-MLS-03
    ! (Livesey and Wu)
    
    ! Assumptions:
    ! (1)This fill operation is triggered by a command
    !    such as the following in the lcf
    !      Fill, state.columnO3, method=special, vmrQuantity=state.o3, $
    !      boundaryPressure=state.tpPressure
    ! (2)the vmr is in units of PHYQ_VMR and not, say, ppmv;
    !    it is in fact identical to the coefficients of the mls basis functions
    ! (3)The pressure surfaces are in hPa, but not all necessarily at the
    !    same logarithmic distance from one another
    ! (4)The tropospheric boundary pressure is somewhere in between the surfs
    ! (5)Unless first,last instances are args, fill all instances
    !    (unlike join which has to worry about chunks and overlaps)
    integer, intent(in) :: KEY
    type (VectorValue_T), intent(inout) :: QTY
    type (VectorValue_T), intent(in) ::    bndPressQty
    type (VectorValue_T), intent(in) ::    vmrQty
    integer, intent(in), optional ::       firstInstance, lastInstance
    ! The last two are set if only part (e.g. overlap regions) of the quantity
    ! is to be stored in the column data.
d2499 11
a2509 15
    ! Local variables
    real (r8) :: AoverMg         ! A/(M g) from Appendix A
    logical ::   zeta_surfs      ! If true, surfs are zeta-type; else pressures
    integer ::   status
    integer ::   surface
    integer ::   instance
    integer ::   surfaceInstance
    integer ::   firstSurface
    integer ::   UseFirstInstance, UseLastInstance, &
    &            NoOutputInstances
    real (r8) :: columnSum
    real (r8) :: Delta_p_plus    ! p[j+1] - p[j]
    real (r8) :: Delta_p_minus   ! p[j-1] - p[j]
    real (r8) :: Delta_log_plus  ! ln p[j+1] - ln p[j]
    real (r8) :: Delta_log_minus ! ln p[j-1] - ln p[j]
d2511 5
a2515 1
    real (r8), allocatable, dimension(:) :: p         ! p[i] in hPa
d2517 32
a2548 29
    ! Executable code
    ! First check that things are OK.
    if ( (qty%template%quantityType /= l_columnAbundance) .or. &
      &  (bndPressQty%template%quantityType /= l_boundaryPressure) .or. &
      &  (vmrQty%template%quantityType /= l_vmr) ) then
          call Announce_error ( key, No_Error_code, &
              & 'Wrong quantity type found while filling column abundance'  )
      return
    elseif ( qty%template%molecule /= vmrQty%template%molecule) then
          call Announce_error ( key, No_Error_code, &
              & 'Attempt to fill column abundance with different molecule'  )
      return
    elseif ( &
    & .not. ( &
    & DoHgridsMatch( qty, vmrQty ) &
    & .and. &
    & DoHgridsMatch( qty, bndPressQty ) &
    & ) &
    & ) then
          call Announce_error ( key, No_Error_code, &
              & 'Attempt to fill column abundance with different HGrids'  )
      return
    elseif ( .not. &
    & any(vmrQty%template%verticalCoordinate == (/l_pressure, l_zeta/)) &
    & ) then
          call Announce_error ( key, No_Error_code, &
              & 'Fill column abundance, but vmr not on [log]pressure surfs.'  )
      return
    end if
d2550 5
a2554 7
    ! Work out what to do with the first and last Instance information
    
    if ( PRESENT(firstInstance) ) then
      useFirstInstance = firstInstance
    else
      useFirstInstance = 1
    end if
d2556 1
a2556 97
    if ( PRESENT(lastInstance) ) then
      useLastInstance = lastInstance
    else
      useLastInstance = qty%template%noInstances
    end if
    noOutputInstances = useLastInstance-useFirstInstance+1
    ! If we've not been asked to output anything then don't carry on
    if ( noOutputInstances < 1 ) return
   !    AoverMg = 4.12e25 / (2.687e20 * 0.192)
   !    This assumes that
   ! (1) p is in hPa
   ! (2) f is in PHYQ_vmr (*not* ppmv)
   AoverMg = 4.12e5 / (2.687 * 0.192)

   zeta_surfs = vmrQty%template%verticalCoordinate == l_zeta
   allocate(p(vmrQty%template%noSurfs), stat=status)
   if(status /= 0) then
          call Announce_error ( key, No_Error_code, &
              & 'Error in allocating p'  )
      return
   endif   
!   do instance=1, vmrQty%template%noInstances
   do instance=useFirstInstance, useLastInstance
      if(vmrQty%template%coherent) then
         surfaceInstance=1
      else
         surfaceInstance=instance
      endif

      if(zeta_surfs) then
         ! Invert zeta = -log10(p)
         do surface=1, vmrQty%template%noSurfs
            p(surface) = exp(-log(10.)* &
            & vmrQty%template%surfs(surface, surfaceInstance))
         enddo
      else
         do surface=1, vmrQty%template%noSurfs
            p(surface) = vmrQty%template%surfs(surface, surfaceInstance)
         enddo
      endif
 
      if(p(1) &
         &  < bndPressQty%values(1, instance)) then
          call Announce_error ( key, No_Error_code, &
              & 'Fill column abundance, but tropopause below VGrid'  )
      endif

   ! Find 1st surface at or above tropopause
   ! (i.e., at a pressure equal to or less than boundaryPressure)
      do surface=1, vmrQty%template%noSurfs
         if(p(surface) &
         &  <= bndPressQty%values(1, instance)) exit
      enddo
      firstSurface = surface
      if(firstSurface > vmrQty%template%noSurfs-2) then
          call Announce_error ( key, No_Error_code, &
              & 'Fill column abundance, but tropopause above VGrid'  )
      endif
   ! Do summation
   ! Initialize sum, Deltas
      columnSum = 0.
      Delta_p_plus = p(firstSurface+1) - p(firstSurface)
      Delta_log_plus = log(p(firstSurface+1)) - log(p(firstSurface))
   ! Loop over surfaces from tropoause+1 to uppermost-1
      do surface = firstSurface+1, vmrQty%template%noSurfs-1
         Delta_p_minus = - Delta_p_plus
         Delta_log_minus = - Delta_log_plus
         Delta_p_plus = p(surface+1) - p(surface)
         Delta_log_plus = log(p(surface+1)) - log(p(surface))
         columnSum = columnSum + &
         & vmrQty%values(surface, instance)* &
         & ( &
         & Delta_p_minus/Delta_log_minus &
         & - &
         & Delta_p_plus/Delta_log_plus &
         & )          
      enddo
      qty%values(1, instance) = AoverMg * columnSum
   enddo

   deallocate(p, stat=status)
   if(status /= 0) then
          call Announce_error ( key, No_Error_code, &
              & 'Error in deallocating p'  )
   endif   

  end subroutine FillColAbundance
  
  ! ------------------------------------- FillFoldedRadiance ---
  subroutine FillFoldedRadiance ( radiance, lsb, usb, &
    & lsbFraction, usbFraction, key )
    type (VectorValue_T), intent(inout) :: RADIANCE
    type (VectorValue_T), intent(in) :: USB
    type (VectorValue_T), intent(in) :: LSB
    type (VectorValue_T), intent(in) :: USBFRACTION
    type (VectorValue_T), intent(in) :: LSBFRACTION
    integer, intent(in) :: KEY
d2558 43
a2600 4
    ! Local variables
    integer :: C                        ! Channel loop inductor
    integer :: I                        ! Array index
    integer :: MIF                      ! Minor frame loop inductor
d2602 1
a2602 28
    ! Executable code
    ! First some sanity checks
    if (.not. ValidateVectorQuantity ( radiance, quantityType=(/l_radiance/), &
      & sideband=(/0/), minorFrame=.true. )) &
      & call Announce_Error ( key, 0, 'Inappropriate radiance quantity to fill' )
    if (.not. ValidateVectorQuantity ( lsb, quantityType=(/l_radiance/), &
      & sideband=(/-1/), signal=(/radiance%template%signal/), minorFrame=.true. )) &
      & call Announce_Error ( key, 0, 'Inappropriate lsb radiance quantity for fill' )
    if (.not. ValidateVectorQuantity ( usb, quantityType=(/l_radiance/), &
      & sideband=(/1/), signal=(/radiance%template%signal/), minorFrame=.true. )) &
      & call Announce_Error ( key, 0, 'Inappropriate usb radiance quantity for fill' )
    if (.not. ValidateVectorQuantity ( lsbFraction, quantityType=(/l_sidebandRatio/), &
      & signal=(/radiance%template%signal/), sideband=(/-1/) ) ) &
      & call Announce_Error ( key, 0, 'Inappropriate lsbFraction quantity for fill' )
    if (.not. ValidateVectorQuantity ( usbFraction, quantityType=(/l_sidebandRatio/), &
      & signal=(/radiance%template%signal/), sideband=(/-1/) ) ) &
      & call Announce_Error ( key, 0, 'Inappropriate usbFraction quantity for fill' )

    ! Now do the work
    i = 1                               ! Use i as a composit mif,channel index
    do mif = 1, radiance%template%noSurfs
      do c = 1, radiance%template%noChans
        radiance%values(i,:) = &
          & lsbFraction%values(c,1) * lsb%values(i,:) + &
          & usbFraction%values(c,1) * usb%values(i,:)
        i = i + 1
      end do
    end do
d2604 31
a2634 1
  end subroutine FillFoldedRadiance
d2636 6
a2641 9
  ! ------------------------------------ FillPhiTanWithRefraction --
  subroutine FillPhiTanWithRefraction ( key, quantity, ptanQuantity, &
    & temperatureQuantity, h2oQuantity, refract )
    integer, intent(in) :: KEY          ! Tree node
    type (VectorValue_T), intent(inout) :: QUANTITY ! PhiTan quantity to fill
    type (VectorValue_T), pointer :: PTANQUANTITY ! Ptan for same module
    type (VectorValue_T), pointer :: TEMPERATUREQUANTITY ! Temperature
    type (VectorValue_T), pointer :: H2OQUANTITY ! Water vapor
    logical, intent(in) :: REFRACT      ! Do refraction or not
d2643 1
a2643 65
    ! Executable code
    ! First check sanity
    if ( .not. ValidateVectorQuantity ( quantity, &
      & quantityType=(/l_phiTan/), minorFrame=.true. ) ) &
      & call Announce_error ( key, 0, 'Quantity to fill is not phiTan' )
    if ( refract ) then
      ! More sanity checks
      if ( .not. ValidateVectorQuantity ( ptanQuantity, &
        & quantityType=(/l_ptan/), minorFrame=.true. ) ) &
        & call Announce_error ( key, 0, 'Problem with ptan quantity for phiTan fill' )
      if ( quantity%template%instrumentModule /= &
        &  ptanQuantity%template%instrumentModule ) &
        & call Announce_error ( key, 0, 'phiTan and ptan quantities not for same module' )
      if ( .not. ValidateVectorQuantity ( temperatureQuantity, &
        & quantityType=(/l_temperature/), coherent=.true., stacked=.true., &
        & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
        & call Announce_error ( key, 0, 'Problem with temperature quantity for phiTan fill' )
      if ( .not. ValidateVectorQuantity ( h2oQuantity, &
        & quantityType=(/l_vmr/), molecule=(/l_h2o/), coherent=.true., stacked=.true., &
        & frequencyCoordinate=(/l_none/), verticalCoordinate=(/l_zeta/) ) ) &
        & call Announce_error ( key, 0, 'Problem with temperature quantity for phiTan fill' )

      ! OK, do the refraction calculation
      call Announce_error ( key, 0, 'Refract=true, not yet supported' )
    else
      ! Just copy it from the template
      quantity%values = quantity%template%phi
    endif

  end subroutine FillPhiTanWithRefraction

    ! ------------------------------------- FillRHIFromH2O ----
  subroutine FillRHIFromH2O ( key, quantity, &
   & sourceQuantity, temperatureQuantity, &
   & dontMask, ignoreZero, ignoreNegative, interpolate, &
   & markUndefinedValues, invert )
    ! Convert h2o vmr to %RHI for all instances, channels, surfaces
    ! (See Eq. 9 from "UARS Microwave Limb Sounder upper tropospheric
    !  humidity measurement: Method and validation" Read et. al. 
    !  J. Geoph. Res. Dec. 2001 (106) D23)

    !  Method:
    ! (1) straight convert--all quantities must have the same shape
    !     (strictly we assume they have _all_ the same geolocations)
    ! (2) interpolate--all quantities may have different shapes
    !     (the interpolation will be along the vertical coordinate only)
    !     I.e., for xQuantity (where x can be h2o or temperature)
    !     if NoChans(xQuantity) /= NoChans(Quantity)
    !        => use only xQuantity(channel==1)
    !     if NoInstances(xQuantity) /= NoInstances(Quantity)
    !        => use only xQuantity(instance==1)
    !
    ! (3) if invert is TRUE, like (1) but its inverse: %RHI to h2o vmr
    integer, intent(in) :: key          ! For messages
    ! Actually, the meaning of the next two is reversed if invert is TRUE)
    type (VectorValue_T), intent(inout) :: QUANTITY ! (rhi) Quantity to fill
    type (VectorValue_T), intent(in) :: sourceQuantity ! vmr (unless invert)
    type (VectorValue_T), intent(in) :: temperatureQuantity ! T(zeta)
!   type (VectorValue_T), intent(in) :: refGPHQuantity ! zeta
    logical, intent(in)           ::    dontMask    ! Use even masked values
    logical, intent(in)           ::    ignoreZero  ! Ignore 0 values of h2o
    logical, intent(in)           ::    ignoreNegative  ! Ignore <0 values
    logical, intent(in)           ::    interpolate ! If VGrids or HGrids differ
    logical, intent(in)           ::    markUndefinedValues ! as UNDEFINED_VALUE
    logical, intent(in)           ::    invert      ! %RHI -> vmr if TRUE
d2645 143
a2787 141
    ! Local variables
    integer ::                          Channel     ! Channel loop counter    
    integer ::                          Chan_h2o    ! Channel loop counter    
    integer ::                          Chan_T      ! Channel loop counter    
    logical, parameter ::               DEEBUG_RHI = .false.
    integer                          :: dim
    integer ::                          I           ! Instances
    integer ::                          I_H2O       ! Instance num for values
    integer ::                          I_T         ! Instance num for values
    integer ::                          invs        ! 1 if invert, else -1
    integer ::                          QINDEX                                
    integer ::                          N           ! Num. of summed values   
    logical                          :: matched_h2o_channels
    logical                          :: matched_h2o_instances
    logical                          :: matched_sizes
    logical                          :: matched_surfs
    logical                          :: matched_T_channels
    logical                          :: matched_T_instances
    integer ::                          S           ! Surface loop counter    
    integer ::                          S_H2O       ! Instance num for surfs
    integer ::                          S_RHI       ! Instance num for surfs
    integer ::                          S_T         ! Instance num for surfs
    logical ::                          skipMe                                
    real (r8) ::                        T
    character(len=*), parameter ::      VMR_UNITS = 'vmr'
    integer ::                          VMR_UNIT_CNV
    logical ::                          wereAnySkipped
    ! These automatic arrays could cause trouble later
    ! You may consider declaring them as pointers and
    ! calling allocate_test and deallocate_test
    real (r8), dimension(quantity%template%noSurfs) :: &
     &                                  zeta, TofZeta, H2OofZeta
    real (r8), dimension(Temperaturequantity%template%noSurfs) :: &
     &                                  zetaTemperature, oldTemperature
    real (r8), dimension(sourceQuantity%template%noSurfs) :: &
     &                                  zetaH2o, oldH2o
    ! Executable statements
    ! Let any undefined values be so marked (but not necessarily masked)
    if ( markUndefinedValues ) Quantity%values = UNDEFINED_VALUE
    ! Will we convert %RHI to vmr?
    if ( invert ) then
      invs = 1
    else
      invs = -1
    endif
    ! Do we need to internally convert the vmr units?
    if ( VMR_UNITS == 'ppmv' ) then
      vmr_unit_cnv = 6
    elseif ( VMR_UNITS == 'ppbv' ) then
      vmr_unit_cnv = 9
    else
      vmr_unit_cnv = 0
    endif
    ! Check that all is well
    if ( invert .and. interpolate ) then
     call Announce_Error ( key, No_Error_code, &
      & ' FillRHIFromH2O unable to invert and interpolate simultaneously' )
     return
    endif
    matched_sizes = .true.
    do dim=1, 2
      matched_sizes = matched_sizes .and. &
      & .not. any( size(Quantity%values,dim) /= &
      &(/ size(sourceQuantity%values,dim), &
      & size(temperatureQuantity%values,dim) /)&
      & )
    enddo
    if ( .not. (matched_sizes .or. interpolate) ) then
     call Announce_Error ( key, No_Error_code, &
      & 'Incompatible quantities in FillRHIFromH2O--' //&
      & '(unless interpolating, all must have same shape)' )
     return
    endif
    matched_surfs = .true.
    matched_surfs = matched_surfs .and. &
     & .not. any( Quantity%template%noSurfs /= &
     &(/ sourceQuantity%template%noSurfs, &
     & temperatureQuantity%template%noSurfs /)&
     & )
    if ( .not. (matched_surfs .or. interpolate) ) then
     call Announce_Error ( key, No_Error_code, &
      & 'Different vertical coords in FillRHIFromH2O--' //&
      & '(unless interpolating, all must be on the same VGrid)' )
     return
    endif
    matched_h2o_channels = &
     &   (sourceQuantity%template%noChans == Quantity%template%noChans)
    matched_h2o_instances = &
     &   (sourceQuantity%template%noInstances == Quantity%template%noInstances)
    matched_T_channels = &
     &   (TemperatureQuantity%template%noChans == Quantity%template%noChans)
    matched_T_instances = &
     &   (TemperatureQuantity%template%noInstances == Quantity%template%noInstances)
    wereAnySkipped = .false.
    ! Now let's do the actual conversion
    do i=1, quantity%template%noInstances
      if ( quantity%template%coherent ) then
        s_rhi = 1
      else
        s_rhi = i
      endif
      if ( sourceQuantity%template%coherent ) then
        s_h2o = 1
      else
        s_h2o = i
      endif
      if ( temperaturequantity%template%coherent ) then
        s_t = 1
      else
        s_t = i
      endif
      ! zeta must be in log(hPa) units
      if ( quantity%template%verticalCoordinate == l_pressure ) then 
        zeta = -log10 ( quantity%template%surfs(:,s_rhi) )             
      else
        zeta = quantity%template%surfs(:,s_rhi)                        
      endif
      if ( interpolate .and. .not. matched_h2o_instances ) then
        i_h2o = 1
      else
        i_h2o = i
      endif
      if ( interpolate .and. .not. matched_T_instances ) then
        i_T = 1
      else
        i_T = i
      endif
      if ( sourceQuantity%template%verticalCoordinate == l_pressure ) then 
        zetah2o = -log10 ( sourceQuantity%template%surfs(:,s_h2o) )             
      else                                                           
        zetah2o = sourceQuantity%template%surfs(:,s_h2o)            
      endif
      if ( Temperaturequantity%template%verticalCoordinate == l_pressure ) then 
        zetaTemperature = -log10 ( Temperaturequantity%template%surfs(:,s_T) )             
      else                                                           
        zetaTemperature = Temperaturequantity%template%surfs(:,s_T)            
      endif
      N = 0
      do Channel=1, quantity%template%noChans
        if ( interpolate .and. .not. matched_h2o_channels ) then
          Chan_h2o = 1
d2789 5
a2793 4
          Chan_h2o = Channel
        endif
        if ( interpolate .and. .not. matched_T_channels ) then
          Chan_T = 1
d2795 4
a2798 25
          Chan_T = Channel
        endif
        if ( interpolate ) then
          do s=1, sourceQuantity%template%noSurfs
            qIndex = Chan_h2o + (s-1)*sourceQuantity%template%noChans
            oldH2o(s) = sourceQuantity%values(qIndex, i_h2o)
          enddo
          ! Know the following about the procedure we will call:
          ! First pair of args are old(X,Y), next pair are new(X,Y)
          ! We want newY(newX) via linear interp. w/o extrapolating
          ! and mark undefined values among oldY with UNDEFINED_VALUE
          call InterpolateValues( zetah2o, oldH2o, &
           & zeta, H2OofZeta, &
           & 'Linear', extrapolate='Constant', &
           & badValue=real(UNDEFINED_VALUE, r8), &
           & missingRegions=.TRUE. )
          do s=1, Temperaturequantity%template%noSurfs
            qIndex = Chan_T + (s-1)*Temperaturequantity%template%noChans
            oldTemperature(s) = TemperatureQuantity%values(qIndex, i_T)
          enddo
          call InterpolateValues( zetaTemperature, oldTemperature, &
           & zeta, TofZeta, &
           & 'Linear', extrapolate='Constant', &
           & badValue=real(UNDEFINED_VALUE, r8), &
           & missingRegions=.TRUE. )
d2800 60
d2863 42
a2904 4
            H2OofZeta(s) = sourceQuantity%values(qIndex, i)
            TofZeta(s) = TemperatureQuantity%values(qIndex, i)
          enddo
        endif
d2906 8
a2913 45
          N = N + 1
          qIndex = Channel + (s-1)*quantity%template%noChans
          skipMe = .false.
          if ( .not. interpolate) then
           skipMe = skipMe .or. &
           & .not. dontMask .and. ( &
           &   isVectorQtyMasked(sourceQuantity, qIndex, i) .or. &
           &   isVectorQtyMasked(temperatureQuantity, qIndex, i) &
           & )
          endif
          skipMe = skipMe .or. &
          & .not. dontMask .and. ( &
          & (ignoreNegative .and. H2OofZeta(s) < 0.0 ) &
          & .or. (ignoreZero .and. H2OofZeta(s) == 0.0 ) &
          & )
          ! But skip no matter what else if temperature illegal
          skipMe = skipMe .or. TofZeta(s) <= 0.0
          if ( .not. skipMe ) then
            T = TofZeta(s)
            Quantity%values(qIndex, i) = &
             & H2OofZeta(s) &
             & * &
             & exp(invs*( &
             & (C(T)+zeta(qIndex)+vmr_unit_cnv) * log(10.) &
             & + &
             & 3.56654*log(T/273.16) &
             & ))
          endif
          wereAnySkipped = wereAnySkipped .or. skipMe
        enddo
      enddo
    enddo
    if ( DEEBUG_RHI ) then
      call output('rhi Num. instances: ', advance='no')
      if ( invert ) then
        call output(sourceQuantity%template%noInstances, advance='yes')
      else
        call output(quantity%template%noInstances, advance='yes')
      endif
      call output('  size(surfs,2) ', advance='no')
      call output(size(quantity%template%surfs,2), advance='yes')
      call output('Were any rhi left undefined? ', advance='no')
      call output(wereAnySkipped, advance='yes')
      call dump(zeta, 'zeta(-log hPa)')
      do s=1, quantity%template%noSurfs
d2915 1
a2915 1
          zeta(s) = 1000000*Quantity%values(s,1)
d2917 22
a2938 33
          zeta(s) = 1000000*sourceQuantity%values(s,1)
        endif
      enddo
      call dump(zeta, 'H2O(ppmv)')
      call dump(TemperatureQuantity%values(:,1), 'Temperature(K)')
      if ( invert ) then
        call dump(sourceQuantity%values(:,1), 'RHI(%)')
      else
        call dump(Quantity%values(:,1), 'RHI(%)')
      endif
    endif
    contains
    function C ( T )
      ! As found in ref.
      real(r8), intent(in)   :: T
      real(r8)               :: C
      ! Local
      real(r8), parameter    :: a0 = -1.2141649d0
      real(r8), parameter    :: a1 = 9.09718d0
      real(r8), parameter    :: a2 = 0.876793d0
      real, parameter        :: ILLEGALTEMP = UNDEFINED_VALUE
      !
      if ( T > 0.d0 ) then
        C = a0 - a1*(273.16/T -1.0d0) + a2*(1.0d0 - T/273.16)
      else
        C = ILLEGALTEMP
      endif
    end function C
  end subroutine FillRHIFromH2O

  ! ---------------------------------- FillVectorQuantityWithEsimatedNoise ---
  subroutine FillVectorQtyWithEstNoise ( quantity, radiance, &
    & sysTemp, nbw, integrationTime )
d2940 3
a2942 1
    use MLSSignals_m, only: signals
d2944 1
a2944 6
    ! Dummy arguments
    type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
    type (VectorValue_T), intent(in) :: RADIANCE ! Radiances to use in calculation
    type (VectorValue_T), intent(in) :: SYSTEMP ! System temperature
    type (VectorValue_T), pointer :: NBW ! Noise bandwidth
    real(r8), intent(in) :: INTEGRATIONTIME ! Integration time in seconds
d2946 6
a2951 6
    ! Local variables
    integer :: C                        ! Channel loop counter
    integer :: S                        ! Surface loop counter
    integer :: I                        ! Index into first dimension of values
    real (r8), dimension(2) :: VALUEASARRAY
    integer, dimension(2) :: UNITASARRAY
d2953 4
a2956 2
    real (r8), dimension(:), pointer :: WIDTH ! Channel widths in MHz
    real (r8), dimension(quantity%template%noChans) :: SYSTEMTEMPERATURE
d2958 1
a2958 1
    ! Executable code
d2960 1
a2960 27
    if (.not. ValidateVectorQuantity ( quantity, &
      & quantityType=(/l_radiance/), minorFrame=.true.) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Invalid quantity for estimated noise fill.")

    if (.not. ValidateVectorQuantity ( radiance, &
      & quantityType=(/l_radiance/), minorFrame=.true.) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Invalid quantity for estimated noise fill.")

    if ( ( radiance%template%signal /= quantity%template%signal ) .or. &
      &  ( radiance%template%sideband /= quantity%template%sideband ) ) &
      & call MLSMEssage ( MLSMSG_Error, ModuleName, &
      & "Quantity and radiances not same signal for estimated noise fill.")

    if ( ( systemp%template%signal /= quantity%template%signal ) .or. &
      &  ( systemp%template%sideband /= quantity%template%sideband ) ) &
      & call MLSMEssage ( MLSMSG_Error, ModuleName, &
      & "Quantity and system temperature not same signal for estimated noise fill." )

    if (.not. ValidateVectorQuantity ( &
      & sysTemp, &
      & quantityType=(/l_systemTemperature/), &
      & verticalCoordinate=(/l_none/), &
      & noInstances=(/1/) ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Invalid system temperature quantity for estimated noise fill.")
d2962 2
a2963 6
    if ( associated ( nbw ) ) then 
      if (.not. ValidateVectorQuantity ( &
        & nbw, &
        & quantityType=(/l_noiseBandwidth/), &
        & verticalCoordinate=(/l_none/), &
        & noInstances=(/1/) ) ) &
d2965 1
a2965 9
        & "Invalid noise bandwidth quantity for estimated noise fill.")
      if ( ( nbw%template%signal /= quantity%template%signal ) .or. &
        &    ( nbw%template%sideband /= quantity%template%sideband ) ) &
        & call MLSMEssage ( MLSMSG_Error, ModuleName, &
        & "Quantity and noise bandwidth not same signal for estimated noise fill." )
      width => nbw%values(:,1)
    else
      width => signals(radiance%template%signal)%widths(:)
    end if
d2967 4
a2970 8
    i = 1
    do s = 1, quantity%template%noSurfs
      do c = 1, quantity%template%noChans
        quantity%values(i,:) = ( radiance%values(i,:) + sysTemp%values(c,1) ) / &
          & sqrt ( integrationTime * 1e6 * width(c) )
        i = i + 1
      end do
    end do
d2972 4
a2975 1
  end subroutine FillVectorQtyWithEstNoise
d2977 4
a2980 16
  ! ------------------------------------- FillVectorHydrostatically ----
  subroutine FillVectorQtyHydrostatically ( key, quantity, &
    & temperatureQuantity, refGPHQuantity, h2oQuantity, &
    & orbitInclinationQuantity, phiTanQuantity, geocAltitudeQuantity, maxIterations )
    ! Various hydrostatic fill operations
    integer, intent(in) :: key          ! For messages
    type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
    type (VectorValue_T), intent(in) :: TEMPERATUREQUANTITY
    type (VectorValue_T), intent(in) :: REFGPHQUANTITY
    type (VectorValue_T), pointer :: H2OQUANTITY
    type (VectorValue_T), pointer :: ORBITINCLINATIONQUANTITY
    type (VectorValue_T), pointer :: PHITANQUANTITY
    type (VectorValue_T), pointer :: GEOCALTITUDEQUANTITY
    integer, intent(in) :: MAXITERATIONS
    ! H2OQuantity and GeocAltitudeQuantity have to be pointers
    ! as they may be absent.
d2982 7
a2988 1
    ! Local variables
d2990 15
a3004 35
    ! Executable code

    if ( toggle(gen) ) call trace_begin ( "FillVectorQtyHydrostatically", key )

    select case ( quantity%template%quantityType )
    case ( l_gph )
      if ( (temperatureQuantity%template%noSurfs /= &
        &   quantity%template%noSurfs) .or. &
        &  (refGPHQuantity%template%noInstances /= &
        &   quantity%template%noInstances) .or. &
        &  (temperatureQuantity%template%noInstances /= &
        &   quantity%template%noInstances) ) then
        call Announce_Error ( key, nonConformingHydrostatic, &
          & "case l_gph failed first test" )
	if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
        return
      end if
      if ( (any(quantity%template%surfs /= temperatureQuantity%template%surfs)) .or. &
        & (any(quantity%template%phi /= temperatureQuantity%template%phi)) .or. &
        & (any(quantity%template%phi /= refGPHQuantity%template%phi)) ) then
        call Announce_Error ( key, nonConformingHydrostatic, &
          &  "case l_gph failed second test" )
	if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
        return
      end if
      call GetBasisGPH ( temperatureQuantity, refGPHQuantity, quantity%values )
    case ( l_ptan )
      if ( (temperatureQuantity%template%noInstances /= &
        &   refGPHquantity%template%noInstances) .or. &
        &  (temperatureQuantity%template%noInstances /= &
        &   h2oQuantity%template%noInstances) ) then
        call Announce_Error ( key, nonConformingHydrostatic, &
          & "case l_ptan failed first test" )
	if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
        return
a3005 53
      if ( (any(refGPHquantity%template%phi /= temperatureQuantity%template%phi)) .or. &
        & (any(h2oQuantity%template%phi /= temperatureQuantity%template%phi)) ) then
        call Announce_Error ( key, nonConformingHydrostatic, &
          & "case l_ptan failed second test" )
	if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
        return
      end if
      if ( (.not. ValidateVectorQuantity(quantity, minorFrame=.true.) ) .or. &
        &  (.not. ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ) .or. &
        &  (quantity%template%instrumentModule /= &
        &   geocAltitudeQuantity%template%instrumentModule) )  then
        call Announce_Error ( key, nonConformingHydrostatic, &
          & "case l_ptan failed third test" )
!        print *, 'ValidateVectorQuantity(quantity, minorFrame=.true.) ', &
!        &  ValidateVectorQuantity(quantity, minorFrame=.true., sayWhyNot=.true.)
!        print *, 'ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ', &
!        & ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true., sayWhyNot=.true.)
!        print *, 'quantity%template%instrumentModule ', &
!        & quantity%template%instrumentModule
!        print *, 'geocAltitudeQuantity%template%instrumentModule ', &
!        & geocAltitudeQuantity%template%instrumentModule
         call output('ValidateVectorQuantity(quantity, minorFrame=.true.) ')
         call blanks(3)
         call output( &
         & ValidateVectorQuantity(quantity, minorFrame=.true., sayWhyNot=.true.), &
         & advance='yes')

         call output('ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ')
         call blanks(3)
         call output( &
         & ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true., sayWhyNot=.true.), &
         & advance='yes')

         call output('quantity%template%instrumentModule ')
         call blanks(3)
         call output( &
         & quantity%template%instrumentModule, &
         & advance='yes')

         call output('geocAltitudeQuantity%template%instrumentModule ')
         call blanks(3)
         call output( &
         & geocAltitudeQuantity%template%instrumentModule, &
         & advance='yes')
	if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
        return
      end if
      call Get2DHydrostaticTangentPressure ( quantity, temperatureQuantity,&
        & refGPHQuantity, h2oQuantity, orbitInclinationQuantity, &
        & phiTanQuantity, geocAltitudeQuantity, maxIterations )
    case default
      call Announce_error ( 0, 0, 'No such fill yet' )
    end select
d3007 8
a3014 1
    if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically" )
d3016 1
a3016 1
  end subroutine FillVectorQtyHydrostatically
d3018 108
a3125 1
  ! -------------------------------------- FillVectorQtyFromIsotope -----------
d3127 1
a3127 4
  subroutine FillVectorQtyFromIsotope ( key, quantity, sourceQuantity, &
            & ratioQuantity )
    ! This routine fills one vector from another, given an appropriate
    ! isotope ratio.
d3129 1
a3129 4
    integer, intent(in) :: KEY          ! Tree node
    type (VectorValue_T), intent(inout) :: QUANTITY ! Quantity to fill
    type (VectorValue_T), intent(in) :: SOURCEQUANTITY ! Quantity to take vmr from
    type (VectorValue_T), intent(in) :: RATIOQUANTITY ! Isotope ratio information
d3131 1
a3131 2
    ! Local variables
    real (r8) :: FACTOR                 ! Multiplier to apply to sourceQuantity
d3133 51
a3183 1
    ! Executable code
d3185 1
a3185 36
    if (.not. ValidateVectorQuantity ( quantity, &
      & quantityType=(/ l_vmr /), frequencyCoordinate=(/ l_none /) ) ) &
      &   call MLSMessage ( MLSMSG_Error, ModuleName, &
      &      "Inappropriate quantity for isotope fill")

    if (.not. ValidateVectorQuantity ( sourceQuantity, &
      & quantityType=(/ l_vmr /), frequencyCoordinate=(/ l_none /) ) ) &
      &   call MLSMessage ( MLSMSG_Error, ModuleName, &
      &      "Inappropriate source quantity for isotope fill")

    if (.not. ValidateVectorQuantity ( ratioQuantity, &
      & quantityType=(/ l_isotopeRatio /), frequencyCoordinate=(/ l_none /), &
      & noInstances=(/1/), noSurfs=(/1/) ) ) &
      &   call MLSMessage ( MLSMSG_Error, ModuleName, &
      &     "Inappropriate form/quantity for isotope ratio")


    if ( .not. DoHGridsMatch ( quantity, sourceQuantity ) .or. &
      &  .not. DoVGridsMatch ( quantity, sourceQuantity ) ) &
      &    call MLSMessage ( MLSMSG_Error, ModuleName, &
      &      "Quantity and source quantity don't match for isotope fill" )

    if ( quantity%template%molecule == sourceQuantity%template%molecule ) &
      & call MLSMessage( MLSMSG_Error, ModuleName, &
      &   "Source and quantity both describe same molecule in isotope fill")

    if ( ratioQuantity%template%molecule == quantity%template%molecule ) then
      ! Going from parent to isotope
      factor = ratioQuantity%values(1,1)
    else if ( ratioQuantity%template%molecule == sourceQuantity%template%molecule ) then
      ! Going from isotope to parent
      factor = 1.0/ratioQuantity%values(1,1)
    else 
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Unable to understand isotope fill" )
    end if
d3187 1
a3187 1
    quantity%values = sourceQuantity%values * factor
d3189 55
a3243 47
  end subroutine FillVectorQtyFromIsotope
  
  !=============================================== ExplicitFillVectorQuantity ==
  subroutine ExplicitFillVectorQuantity(quantity, valuesNode, spread, globalUnit, &
    & dontmask)

    ! This routine is called from MLSL2Fill to fill values from an explicit
    ! fill command line

    ! Dummy arguments
    type (VectorValue_T), intent(inout) :: QUANTITY ! The quantity to fill
    integer, intent(in) :: VALUESNODE   ! Tree node
    logical, intent(in) :: SPREAD       ! One instance given, spread to all
    integer, intent(in) :: GLOBALUNIT   ! From parent vector
    logical, intent(in) :: DONTMASK     ! Don't bother with the mask

    ! Local variables
    integer :: K                        ! Loop counter
    integer :: I,J                      ! Other indices
    integer, DIMENSION(2) :: unitAsArray ! Unit for value given
    real (r8), DIMENSION(2) :: valueAsArray ! Value given
    integer :: TestUnit                 ! Unit to use
    
    ! Executable code
    testUnit = quantity%template%unit
    if ( globalUnit /= phyq_Invalid ) testUnit = globalUnit

    if (spread) then      ! 1 instance/value given, spread to all instances

      ! Check we have the right number of values
      if ( ( (nsons(valuesNode)-1 /= quantity%template%instanceLen) .and. &
        &    (nsons(valuesNode)-1 /= 1) ) .or. &
        &  (.not. quantity%template%regular)) &
        & call Announce_error ( valuesNode, invalidExplicitFill )

      ! Loop over the values
      do k=1,nsons(valuesNode)-1
        ! Get value from tree
        call expr(subtree(k+1,valuesNode),unitAsArray,valueAsArray)
        ! Check unit OK
        if ( (unitAsArray(1) /= testUnit) .and. &
          &  (unitAsArray(1) /= PHYQ_Dimensionless) ) &
          & call Announce_error ( valuesNode, badUnitsForExplicit )
        ! Store value
        if ( .not. dontMask .and. associated ( quantity%mask ) ) then
          if ( nsons(valuesNode)-1 == 1 ) then
            where ( iand ( ichar(quantity%mask), m_Fill ) == 0 )
d3245 1
a3245 3
            end where
          else
            where ( iand ( ichar(quantity%mask(k,:)), m_Fill ) == 0 )
d3247 1
a3247 1
            end where
d3249 1
a3249 11
        else
          ! No mask to worry about
          if (nsons(valuesNode)-1 == 1) then
            quantity%values=valueAsArray(1)
          else
            quantity%values(k,:)=valueAsArray(1)
          endif
        end if
      end do
     
    else                  ! Not spread, fill all values
d3251 1
a3251 4
      ! Check we have the right number of values
      if (nsons(valuesNode)-1 /= &
        & quantity%template%noInstances*quantity%template%instanceLen) &
        & call Announce_error ( valuesNode, invalidExplicitFill )
d3253 25
a3277 20
      ! Loop over values
      do k=1,nsons(valuesNode)-1
        ! Get value from tree
        call expr(subtree(k+1,valuesNode),unitAsArray,valueAsArray)
        ! Check unit OK
        if ( (unitAsArray(1) /= testUnit) .and. &
          &  (unitAsArray(1) /= PHYQ_Dimensionless) ) &
          & call Announce_error ( valuesNode, badUnitsForExplicit )
        ! Store value
        i = mod(k-1,quantity%template%instanceLen) + 1
        j = (k-1) / quantity%template%instanceLen + 1
        if ( .not. dontMask .and. associated ( quantity%mask ) ) then
          if ( iand ( ichar(quantity%mask(i,j)), m_Fill ) == 0 ) &
            & quantity%values(i,j) = valueAsArray(1)
        else
          quantity%values(i,j) = valueAsArray(1)
        end if
      end do
    end if
  end subroutine ExplicitFillVectorQuantity
d3279 53
a3331 9
  ! ----------------------------------------- FillVectorQuantityFromL1B ----
  subroutine FillVectorQuantityFromL1B ( root, quantity, chunk, l1bInfo, &
    & isPrecision, PrecisionQuantity )
    integer, intent(in) :: root
    type (VectorValue_T), INTENT(INOUT) ::        QUANTITY
    type (MLSChunk_T), INTENT(IN) ::              CHUNK
    type (l1bInfo_T), INTENT(IN) ::               L1BINFO
    logical, intent(in)               ::          ISPRECISION
    type (VectorValue_T), INTENT(IN), optional :: PRECISIONQUANTITY
d3333 1
a3333 5
    ! Local variables
    character (len=80) :: NAMESTRING
    integer :: fileID, FLAG, NOMAFS
    type (l1bData_T) :: L1BDATA
    integer :: ROW, COLUMN
d3335 26
a3360 1
    ! Executable code
d3362 51
a3412 1
    if ( toggle(gen) ) call trace_begin ("FillVectorQuantityFromL1B",root)
d3414 5
a3418 77
    fileID=l1bInfo%l1bOAID
    select case ( quantity%template%quantityType )
    case ( l_ptan )
      call GetModuleName( quantity%template%instrumentModule,nameString )
      nameString=TRIM(nameString)//'.ptan'
    case ( l_radiance )
      call GetSignalName ( quantity%template%signal, nameString, &
        & sideband=quantity%template%sideband, noChannels=.TRUE. )
      fileID = FindL1BData (l1bInfo%l1bRadIDs, nameString )
    case ( l_tngtECI )
      call GetModuleName( quantity%template%instrumentModule,nameString )
      nameString=TRIM(nameString)//'.tpECI'
    case ( l_tngtGeodAlt )
      call GetModuleName( quantity%template%instrumentModule,nameString )
      nameString=TRIM(nameString)//'.tpGeodAlt'
    case ( l_tngtGeocAlt )
      call GetModuleName( quantity%template%instrumentModule,nameString )
      nameString=TRIM(nameString)//'.tpGeocAlt'
    case ( l_scECI )
      nameString='scECI'
    case ( l_scVel )
      nameString='scVel'
    case ( l_scVelECI )
      nameString='scVelECI'
    case ( l_scVelECR )
      nameString='scVelECR'
    case ( l_scGeocAlt )
      nameString='scGeocAlt'
    case ( l_orbitInclination )
      nameString='scOrbIncl'
    case default
      call Announce_Error ( root, cantFillFromL1B )
    end select

    if ( isPrecision ) nameString = trim(nameString) // PRECISIONSUFFIX

    call ReadL1BData ( fileID , nameString, l1bData, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
      & NeverFail= .false. )
    ! We'll have to think about `bad' values here .....
    if ( flag /= 0 ) then
      call Announce_Error ( root, errorReadingL1B )
      if ( toggle(gen) ) call trace_end ( "FillVectorQuantityFromL1B")
      return
    end if
    quantity%values = RESHAPE(l1bData%dpField, &
      & (/ quantity%template%instanceLen, quantity%template%noInstances /) )
    if ( isPrecision ) then
      do column=1, size(quantity%values(1, :))
        do row=1, size(quantity%values(:, 1))
          if ( quantity%values(row, column) < 0.d0 ) &
            & call MaskVectorQty(quantity, row, column)
        enddo
      enddo
    elseif ( present(precisionQuantity) ) then
      do column=1, size(quantity%values(1, :))
        do row=1, size(quantity%values(:, 1))
          if ( isVectorQtyMasked(precisionQuantity, row, column) ) &
            & call MaskVectorQty(quantity, row, column)
        enddo
      enddo
    endif

    if ( index(switches, 'l1b') /= 0 ) &
      & call Dump( l1bData )
    call DeallocateL1BData(l1bData)

    if (toggle(gen) ) call trace_end( "FillVectorQuantityFromL1B" )
  end subroutine FillVectorQuantityFromL1B

  !=============================== FillQuantityFromLosGrid ====
  subroutine FillQuantityFromLosGrid ( key, Qty, LOS, &
    & Ptan, Re, noFineGrid, extinction, errorCode )

    ! This is to fill a l2gp type of quantity with a los grid type of quantity.
    ! The los quantity is a vector quantity that has dimension of (s, mif, maf),
    ! where s is the path along los.
d3420 16
a3435 2
    ! Linear interpolation is used to fill l2gp grids and unfilled grids are
    ! marked with the baddata flag (-999.)
d3437 20
a3456 9
    ! Dummy arguments
    integer, intent(in) :: key          ! For messages    
    type (VectorValue_T), intent(in) :: LOS ! Vector quantity to fill from
    type (VectorValue_T), intent(in) :: Ptan ! tangent pressure
    type (VectorValue_T), intent(in) :: Re ! Earth's radius
    type (VectorValue_T), INTENT(INOUT) :: QTY ! Quantity to fill
    integer, intent(in) :: noFineGrid   ! make finer sGrid with this number
    logical, intent(in) :: extinction  ! Flag for extinction fill and calculation
    integer, intent(out) :: errorCode ! Error code
d3458 2
a3459 29
    ! Local variables
    integer :: i, j, maf, mif                ! Loop counter
    integer :: maxZ, minZ                    ! pressure range indices of sGrid
    integer :: noMAFs,noMIFs,noDepths
    integer, dimension(qty%template%noSurfs,qty%template%noInstances) :: cnt
    real (r8), dimension(qty%template%noSurfs,qty%template%noInstances) :: out
    real (r8), dimension(qty%template%noSurfs) :: outZeta, phi_out, beta_out
    real (r8), dimension(los%template%noChans) :: x_in, y_in, sLevel
    real (r8), dimension(los%template%noSurfs) :: zt
    real (r8), dimension(los%template%noChans*noFineGrid) :: betaFine, TransFine, SFine
    real (r8), dimension(los%template%noChans, &
      & los%template%noSurfs,los%template%noInstances) :: beta
    real (r8) :: ds, ColTrans

    if ( toggle(gen) ) call trace_begin ( "FillQuantityFromLosGrid", key )

    errorCode=0

    ! Make sure this quantity is appropriate
    !    if (.not. ValidateVectorQuantity(qty, coherent=.TRUE., stacked=.TRUE., &
    !      & verticalCoordinate= (/ l_pressure, l_zeta /) ) ) then
    !      call output ( " quantity vertical grid in FillQuantityFromLOSgrid is not valid")
    !    end if

    if ( qty%template%verticalCoordinate == l_pressure ) then
      outZeta = -log10 ( qty%template%surfs(:,1) )
    else
      outZeta = qty%template%surfs(:,1)
    end if
d3461 1
a3461 16
    noMAFs=los%template%noInstances
    noMIFs=los%template%noSurfs
    ! Now, we use frequency coordinate as sGrid along the path
    noDepths=los%template%noChans
    sLevel = los%template%frequencies

    ! the input losQty is the increment of cloud transmission function by default.
    ! it is converted to cloud extinction if extinction flag is on.
    if(extinction) then
      ! both sGrid and sFineGrid are expected to be evenly spaced at present
      ds = sLevel(2)-sLevel(1)  
      do i=1,noDepths
        do j=1,noFineGrid
          Sfine(j+(i-1)*noFineGrid) = sLevel(i)+(j-1._r8)*ds/noFineGrid
        end do
      end do
d3463 4
a3466 14
      do maf=1,noMafs
        do mif=1,noMifs
          do i=1,noDepths
            ! convert increments to derivatives
            y_in(i) = los%values(i+(mif-1)*noDepths,maf)/ds
          end do
          call InterpolateValues(sLevel,y_in,sFine,TransFine,method='Linear')  
          ! calculate column transmission function by integrating
          ! the derivatives on fine grid
          do i=1,noFineGrid*noDepths
            betaFine(i) = 0._r8
            colTrans=0._r8
            do j=1,i
              colTrans=colTrans + transFine(j)*ds/noFineGrid
a3467 2
            colTrans = 1._r8 - colTrans
            if(colTrans > 0.02_r8) betaFine(i)= transFine(i)/colTrans
d3469 3
a3471 2
          ! interpolate betaFine back to the coarser sGrid
          call InterpolateValues(sFine,betaFine,sLevel,beta(:,mif,maf),method='Linear')
d3473 6
d3482 17
a3498 1
    else
d3500 4
a3503 4
      do maf=1,noMafs
        do mif=1,noMifs
          do i=1,noDepths
            beta(i,mif,maf)=los%values(i+(mif-1)*noDepths,maf)
d3505 2
a3506 2
        end do
      end do
d3508 59
a3566 8
    end if

    ! initialize quantity
    do j = 1, qty%template%noInstances
      do i = 1, qty%template%noSurfs
        qty%values(i,j)=qty%template%badValue
        cnt(i,j)=0
        out(i,j)=0._r8
d3568 1
a3568 1
    end do
d3570 6
a3575 60
    do maf=1,noMAFs  
      zt = ptan%values(:,maf)   ! noChans=1 for ptan
      zt = (zt+3.)*16.                      ! converted to height in km
      do mif=1,noMIFs
        if (ptan%values(mif,maf) .gt. -2.5) cycle ! for testing
        ! find altitude of each s grid
        x_in = sLevel**2/2./(re%values(1,maf)*0.001_r8 + zt(mif))
        ! converted to zeta
        x_in = x_in/16. + ptan%values(mif,maf)
        ! find minimum and maximum pressures indices in sGrid
        do i = 2,qty%template%noSurfs-1
          if (ptan%values(mif,maf) < (outZeta(i)+outZeta(i+1))/2. .and. &
            & ptan%values(mif,maf) > (outZeta(i)+outZeta(i-1))/2.) &
            & minZ = i
        end do
        if (ptan%values(mif,maf) < (outZeta(1)+outZeta(2))/2.) minZ=1
        if (ptan%values(mif,maf) > outZeta(qty%template%noSurfs)) cycle ! goto next mif

        do i = 2,qty%template%noSurfs-1
          if (x_in(noDepths) < (outZeta(i)+outZeta(i+1))/2. .and. &
            & x_in(noDepths) > (outZeta(i)+outZeta(i-1))/2.) &
            & maxZ = i
        end do
        if (x_in(noDepths) < (outZeta(1)+outZeta(2))/2.) cycle    ! goto next mif
        if (x_in(noDepths) > outZeta(qty%template%noSurfs)) maxZ=qty%template%noSurfs

        ! get phi along path for each mif (phi is in degree)
        y_in = los%template%phi(mif,maf) &
          & - atan(sLevel/(re%values(1,maf)*0.001_r8 + zt(mif)))*180._r8/Pi
        ! interpolate phi onto standard vertical grids     
        call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),phi_out(minZ:maxZ), &
          & method='Linear')
        ! interpolate quantity to standard vertical grids      
        y_in = beta(:,mif,maf)
        call InterpolateValues(x_in,y_in,outZeta(minZ:maxZ),beta_out(minZ:maxZ), &
          & method='Linear')
        ! interpolate quantity to standard phi grids
        do i=minZ,maxZ  
          do j = 2, qty%template%noInstances-1
            if(phi_out(i) .lt. &     
              & (qty%template%phi(1,j)+qty%template%phi(1,j+1))/2. &
              & .and. phi_out(i) .ge. &  
              & (qty%template%phi(1,j-1)+qty%template%phi(1,j))/2. ) then
              out(i,j)=out(i,j) + beta_out(i)
              cnt(i,j)=cnt(i,j)+1       !  counter
            end if
          end do
        end do
      end do                            ! End surface loop
    end do                              ! End instance loop
    ! average all non-zero bins
    where (cnt > 0) qty%values = out/cnt

  end subroutine FillQuantityFromLosGrid

  ! ---------------------------------------------- TRANSFERVECTORS -----
  subroutine TransferVectors ( source, dest )
    ! Copy common items in source to those in dest
    type (Vector_T), intent(in) :: SOURCE
    type (Vector_T), intent(inout) :: DEST
d3577 1
a3577 5
    ! Local variables
    integer :: Dummy                   ! Dummy integer
    type (VectorValue_T), pointer :: DQ ! Destination quantity
    type (VectorValue_T), pointer :: SQ ! Source quantity
    integer :: SQI                      ! Quantity index in source
d3579 2
a3580 1
    ! Executable code
d3582 4
a3585 15
    ! First copy those things in source, loop over them
    dest%globalUnit = source%globalUnit
    do sqi = 1, size ( source%quantities )
      ! Try to find this in dest
      sq => source%quantities(sqi)
      dq => GetVectorQtyByTemplateIndex ( dest, source%template%quantities(sqi), dummy )
      if ( associated ( dq ) ) then
        dq%values = sq%values
        if (associated(sq%mask)) then
          if (.not. associated(dq%mask)) call CreateMask ( dq )
          dq%mask = sq%mask
        else
          if ( associated(dq%mask) ) &
            & call Deallocate_test ( dq%mask, 'dq%mask', ModuleName )
        endif
a3586 2
    end do
  end subroutine TransferVectors
d3588 2
a3589 140
  ! ---------------------------------------------  ANNOUNCE_ERROR  -----
  subroutine ANNOUNCE_ERROR ( where, CODE , ExtraMessage, ExtraInfo )
    integer, intent(in) :: where   ! Tree node where error was noticed
    integer, intent(in) :: CODE    ! Code for error message
    character (LEN=*), intent(in), optional :: ExtraMessage
    integer, intent(in), dimension(:), optional :: ExtraInfo

    integer :: I

    error = max(error,1)
    call output ( '***** At ' )

    if ( where > 0 ) then
      call print_source ( source_ref(where) )
    else
      call output ( '(no lcf tree available)' )
    end if

    call output ( ': ' )
    call output ( "The " );

    select case ( code )
    case ( allocation_err )
      call output ( " command caused an allocation error in squeeze.", advance='yes' )
    case ( badEstNoiseFill )
      call output ( " missing information for estimated noise fill", advance='yes' )
    case ( badGeocAltitudeQuantity )
      call output ( " geocAltitudeQuantity is not geocAltitude", advance='yes' )
    case ( badlosGridfill )
      call output ( " incomplete/incorrect information for los Grid fill", advance='yes' )
    case ( badlosvelfill )
      call output ( " incomplete/incorrect information for los velocity", advance='yes' )
    case ( badIsotopeFill )
      call output ( " incomplete/incorrect information for isotope fill", advance='yes' )
    case ( badREFGPHQuantity )
      call output ( " refGPHQuantity is not refGPH", advance='yes' )
    case ( badTemperatureQuantity )
      call output ( " temperatureQuantity is not temperature", advance='yes' )
    case ( badUnitsForExplicit )
      call output ( " explitictValues field has inappropriate " // &
        & "units for Fill instruction.", advance='yes' )
    case ( badUnitsForIntegrationTime )
      call output ( " has inappropriate units for integration time.", advance='yes' )
    case ( badUnitsForSystemTemperature )
      call output ( " has inappropriate units for system temperature.", advance='yes' )
    case ( badUnitsForMaxIterations )
      call output ( " maxIterations should be dimensionless", advance='yes' )
    case ( bothFractionAndLength )
      call output ( " specified both fraction and lengthScale", advance='yes' )
    case ( cantFillFromL1B )
      call output ( " command could not be filled from L1B.", advance='yes' )
    case ( cantFillFromL2AUX )
      call output ( " command could not be filled from L2AUX.", advance='yes' )
    case ( cantInterpolate3D )
      call output ( " cannot interpolate 3d quantities (yet).", advance='yes' )
    case ( deallocation_err )
      call output ( " command caused an deallocation error in squeeze.", advance='yes' )
    case ( errorReadingL1B )
      call output ( " L1B file could not be read.", advance='yes' )
    case ( invalidExplicitFill )
      call output ( " has inappropriate dimensionality for explicit fill.", advance='yes' )
    case ( m1_too_small )
      call output ( " command caused a m1 too small error in squeeze.", advance='yes' )
    case ( m2_too_small )
      call output ( " command caused a m2 too small error in squeeze.", advance='yes' )
    case ( missingField )
      call output ( " fields " )
      do i = 1, size(extraInfo)
        call display_string ( field_indices(i) )
        if ( i == size(extraInfo) ) then
          call output ( " and " )
        else
          call output ( ", " )
        end if
      end do
      call output ( " are required.", advance='yes' )
    case ( needGeocAltitude )
      call output ( " needs geocAltitudeQuantity.", advance='yes' )
    case ( needH2O )
      call output ( " needs H2OQuantity.", advance='yes' )
    case ( needOrbitInclination )
      call output ( " needs OrbitalInclination.", advance='yes' )
    case ( needTempREFGPH )
      call output ( " needs temperatureQuantity and refGPHquantity.", advance='yes' )
    case ( noExplicitValuesGiven )
      call output ( " no explicit values given for explicit fill.", advance='yes' )
    case ( nonConformingHydrostatic )
      call output ( " quantities needed for hydrostatic fill do not conform", advance='yes' )
    case ( noSourceGridGiven )
      call output ( " no sourceGrid field given for gridded fill.", advance='yes' )
    case ( noSourceL2AUXGiven )
      call output ( " no sourceL2AUX field given for L2AUX fill.", advance='yes' )
    case ( noSourceL2GPGiven )
      call output ( " no sourceL2GP field given for L2GP fill.", advance='yes' )
    case ( noSourceQuantityGiven )
      call output ( " no sourceQuantity field given for vector fill.", advance='yes' )
    case ( noSpecialFill )
      call output ( " invalid special fill", advance='yes' )
    case ( notImplemented )
      call output ( extraMessage )
      call output ( " is not implemented yet.", advance='yes' )
    case ( notSPD )
      call output ( " is not a SPD matrix.", advance='yes' )
    case ( not_permutation )
      call output ( " command caused an illegal permutation in squeeze.", advance='yes' )
    case ( numInstancesisZero )
      call output ( " command has zero instances.", advance='yes' )
    case ( numSurfsisZero )
      call output ( " command has zero surfaces.", advance='yes' )
    case ( n1_is_zero )
      call output ( " command caused an n1=0 error in squeeze.", advance='yes' )
    case ( n2_is_zero )
      call output ( " command caused an n2=0 error in squeeze.", advance='yes' )
    case ( n3_is_zero )
      call output ( " command caused an n3=0 error in squeeze.", advance='yes' )
    case ( objIsFullRank3 )
      call output ( " command array is full rank 3.", advance='yes' )
    case ( otherErrorInFillVector )
      call output ( " command caused an error in FillVector.", advance='yes' )
    case ( source_not_in_db )
      call output ( " source was not found in the db.", advance='yes' )
    case ( unknownQuantityName )
      call output ( " quantity was not found in the vector", advance='yes' )
    case ( vectorWontMatchPDef )
      call output ( " command found new and prev. vectors unmatched.", advance='yes' )
    case ( wrong_number )
      call output ( " command does not have exactly one field.", advance='yes' )
    case ( zeroGeodSpan )
      call output ( " command found zero geod. ang. span.", advance='yes' )
    case ( zeroProfilesFound )
      call output ( " command found zero profiles.", advance='yes' )
    case ( badRefractFill )
      call output ( " missing information for phiTan refract fill", advance='yes' )
    case default
      call output ( " command caused an unrecognized programming error", advance='yes' )
    end select
    if ( present(ExtraMessage) ) then
      call output(ExtraMessage, advance='yes')
    end if
  end subroutine ANNOUNCE_ERROR
d3591 120
d3717 3
@


2.135
log
@Tidied up FillVectorQtyFromProfile
@
text
@d172 1
a172 1
       "$Id: Fill.f90,v 2.134 2002/08/16 16:08:58 livesey Exp $"
d1742 1
a1742 1
        & call AnnounceError ( valuesNode, 0, 'Bad height units for profile fill' )
d1752 1
a1752 1
        & call AnnounceError ( valuesNode, 0, 'Bad units for profile fill' )
d3715 3
@


2.134
log
@Bug fix in the Matrix fill (covariance with frequency variation).
@
text
@d91 1
a91 1
  use VGridsDatabase, only: VGRID_T
d172 1
a172 1
       "$Id: Fill.f90,v 2.133 2002/08/15 03:52:52 livesey Exp $"
d1702 1
d1705 1
d1710 1
d1722 4
d1728 1
a1728 1
    nullify ( heights, values, outHeights )
d1731 2
d1739 4
a1742 1
      ! WRITE THIS!
d1744 2
a1745 2
      if ( exprUnit(1) == PHYQ_Pressure .and. &
        & quantity%template%verticalCoordinate == l_zeta ) then
a1749 1

d1751 2
a1752 2
      ! WRITE THIS!

d1757 1
a1757 1
    ! Get the appropriate height coordinate for output
d1770 12
a1781 5
      & quantity%values(:,1), 'Linear', extrapolate='Constant' )
    ! Spread it into the other instances
    quantity%values = spread ( &
      & quantity%values(:,1), quantity%template%noInstances, 2 )

d1787 1
d3715 3
@


2.133
log
@Added profile fill, still not complete though.
@
text
@d172 1
a172 1
       "$Id: Fill.f90,v 2.132 2002/08/03 20:41:40 livesey Exp $"
d1505 2
a1506 1
                  distance = abs ( surfs ( j/qt%noChans ) - surfs ( k/qt%noChans ) )
d1508 2
a1509 1
                  distance = abs ( surfs ( j/qt%noChans ) - surfs ( k/qt%noChans ) ) * decade
d1511 2
a1512 2
                  distance = abs ( -log10 ( surfs(j/qt%noChans) ) + &
                    &               log10 ( surfs(k/qt%noChans) ) ) / decade
d3696 3
@


2.132
log
@Added snooping of matrices
@
text
@d21 1
a21 1
    & F_ORBITINCLINATION, F_PRECISIONFACTOR, &
d37 1
a37 1
    & L_PRESSURE, L_PHITAN, L_PTAN, L_RADIANCE, L_RHI, &
d49 1
a49 1
    & PHYQ_Time, PHYQ_Length
d172 1
a172 1
       "$Id: Fill.f90,v 2.131 2002/06/26 01:26:21 livesey Exp $"
d596 2
d810 6
d1687 82
d3694 3
@


2.131
log
@Added 2D pressure guesser
@
text
@d59 1
a59 1
    & DestroyMatrix, Dump, GetDiagonal, &
d63 2
d67 1
a67 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d172 1
a172 1
       "$Id: Fill.f90,v 2.130 2002/06/18 20:00:36 livesey Exp $"
d237 3
d297 2
a298 1
    integer :: NoFineGrid               ! no of fine grids for cloud extinction calculation
d328 1
d1272 22
a1293 1
        call Snoop ( key=key, vectorDatabase=vectors )
d3604 3
@


2.130
log
@Removed unwanted print
@
text
@d21 2
a22 2
    & F_PRECISIONFACTOR, &
    & F_PTANQUANTITY, F_QUANTITY, F_RADIANCEQUANTITY, F_RATIOQUANTITY, &
d73 1
a73 1
  use ScanModelModule, only: GetBasisGPH, GetHydrostaticTangentPressure
d153 2
a154 1
  integer, parameter :: NeedGeocAltitude = needH2O + 1
d170 1
a170 1
       "$Id: Fill.f90,v 2.129 2002/06/14 16:40:00 livesey Exp $"
d217 1
d229 1
d293 4
d575 5
d592 3
d763 8
d778 6
d788 2
a789 1
            & refGPHQuantity, h2oQuantity, geocAltitudeQuantity, maxIterations )          
d2880 1
a2880 1
    & geocAltitudeQuantity, maxIterations )
d2887 2
d2979 3
a2981 2
      call GetHydrostaticTangentPressure ( quantity, temperatureQuantity,&
        & refGPHQuantity, h2oQuantity, geocAltitudeQuantity, maxIterations )
d3509 2
d3576 3
@


2.129
log
@Orbital inclination can now be filled from l1b
@
text
@d169 1
a169 1
       "$Id: Fill.f90,v 2.128 2002/06/04 23:22:36 livesey Exp $"
a2442 1
    print*,'There'
d3541 3
@


2.128
log
@Bug fixes on phiTan fill, other cleanups
@
text
@d35 2
a36 1
    & L_RECTANGLEFROMLOS, L_NEGATIVEPRECISION, L_NOISEBANDWIDTH, L_LOSVEL, L_NONE, L_PLAIN, &
d169 1
a169 1
       "$Id: Fill.f90,v 2.127 2002/06/04 22:40:44 livesey Exp $"
d3154 2
d3542 3
@


2.127
log
@Added framework for phiTan fill
@
text
@d168 1
a168 1
       "$Id: Fill.f90,v 2.126 2002/05/28 17:08:42 livesey Exp $"
d289 2
a290 2
    integer :: PTANVECTORINDEX          !
    integer :: PTANQTYINDEX             !
d578 1
a578 1
            PtanQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
d771 2
a772 1
          if ( refract .and. .not. all ( got ( &
d775 12
a786 1
          call FillPhiTanWithRefrcation ( key, quantity, ptanQuantity, temperatureQuantity, &
d795 1
a795 1
            & vectors(PtanVectorIndex), PtanQtyIndex )
d2431 1
a2431 1
  subroutine FillPhiTanWithRefrcation ( key, quantity, ptanQuantity, &
d2442 1
d2470 1
a2470 1
  end subroutine FillPhiTanWithRefrcation
d3539 3
@


2.126
log
@More explicit error message still in l2gp fill.
@
text
@d23 1
a23 1
    & F_REFGPHQUANTITY, F_RESETSEED, F_RHIQUANTITY, F_Rows, &
d36 2
a37 2
    & L_PRESSURE, L_PTAN, L_RADIANCE, L_RHI, &
    & L_REFGPH, L_SCECI, L_SCGEOCALT, L_SCVEL, L_SCVELECI, L_SCVELECR, &
d162 1
d168 1
a168 1
       "$Id: Fill.f90,v 2.125 2002/05/23 20:51:53 livesey Exp $"
d226 1
a226 1
    type (vectorValue_T), pointer :: TNGTPRESQUANTITY
d299 1
d302 2
a303 2
    logical :: ResetSeed                ! Let mls_random_seed choose new seed
    integer :: RowVector                ! Vector defining rows of Matrix
d378 1
d588 2
d770 7
d782 1
a782 1
          TngtPresQuantity => GetVectorQtyByTemplateIndex( &
d787 1
a787 1
            & tngtPresQuantity, earthRadiusQty, &
d2418 42
a2459 1
  ! ------------------------------------- FillRHIFromH2O ----
d3510 2
d3526 3
@


2.125
log
@Bug fix, checking wrong in special fill for los velocity.
@
text
@d167 1
a167 1
       "$Id: Fill.f90,v 2.124 2002/05/17 17:55:48 livesey Exp $"
d1557 6
a1562 3
      &         quantity%template%phi(1,:)) > tolerance) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Quantity has profiles that mismatch l2gp in geodetic angle' )
d3471 3
@


2.124
log
@Added sideband folding fill
@
text
@d40 1
a40 1
    & L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VGRID, L_VMR, L_ZETA
d67 1
a67 1
  use MLSSignals_m, only: GetSignalName, GetModuleName
d167 1
a167 1
       "$Id: Fill.f90,v 2.123 2002/05/14 00:26:25 livesey Exp $"
d1615 21
a1635 14
    if ( (qty%template%quantityType /= l_losVel) .or. &
      &  (tngtECI%template%quantityType /= l_tngtECI) .or. &
      &  (scECI%template%quantityType /= l_scECI) .or. &
      & .not. any( &
      &  (scVel%template%quantityType == &
      & (/ l_scVelECI /))) ) then
      call Announce_Error ( key, badLOSVelFill )
      return
    end if

    if ( qty%template%instrumentModule /= tngtECI%template%instrumentModule ) then
      call Announce_Error ( key, badLOSVelFill )
      return
    end if
a1639 14
    if ( size(qty%values(:,1)) < noMIFs ) then
      call Announce_Error ( key, No_Error_code, &
       & 'noMIFs too large for los quantity' )
      return
    elseif ( size(qty%values(1,:)) < noMAFs ) then
      call Announce_Error ( key, No_Error_code, &
       & 'noMAFs too large for los quantity' )
      return
    elseif ( size(scVel%values(1,:)) < 3 ) then
      call Announce_Error ( key, No_Error_code, &
       & 'scVel has too few components' )
      return
    end if

d3468 3
@


2.123
log
@New code for system temperatures etc.
@
text
@d18 1
d29 1
a29 1
    & F_TYPE, F_VECTOR, F_VMRQUANTITY, FIELD_FIRST, FIELD_LAST
d33 1
a33 1
    & L_COLUMNABUNDANCE, L_ESTIMATEDNOISE, L_EXPLICIT, L_GPH, L_GRIDDED, L_HEIGHT, &
d38 2
a39 1
    & L_SPD, L_SPECIAL, L_SYSTEMTEMPERATURE, L_TEMPERATURE, L_TNGTECI, L_TNGTGEODALT, &
d167 1
a167 1
       "$Id: Fill.f90,v 2.122 2002/05/06 22:30:51 livesey Exp $"
d202 3
a204 1
    type (vectorValue_T), pointer :: QUANTITY ! Quantity to be filled
d207 7
d215 1
d226 2
a227 3
    type (vectorValue_T), pointer :: EARTHRADIUSQTY
    type (vectorValue_T), pointer :: LOSQTY
    type (vectorValue_T), pointer :: BNDPRESSQTY
a228 5
    type (vectorValue_T), pointer :: MEASQTY
    type (vectorValue_T), pointer :: MODELQTY
    type (vectorValue_T), pointer :: NBWQUANTITY
    type (vectorValue_T), pointer :: NOISEQTY
    type (vectorValue_T), pointer :: APRIORIPRECISION
d271 4
d325 4
d535 6
d633 6
d973 11
d2363 46
d3475 3
@


2.122
log
@Tidied up l2gp fill.
@
text
@d19 2
a20 1
    & F_MODEL, F_MULTIPLIER, F_NOFINEGRID, F_PRECISION,  F_PRECISIONFACTOR, &
d34 1
a34 1
    & L_RECTANGLEFROMLOS, L_NEGATIVEPRECISION, L_LOSVEL, L_NONE, L_PLAIN, &
d37 1
a37 1
    & L_SPD, L_SPECIAL, L_TEMPERATURE, L_TNGTECI, L_TNGTGEODALT, &
d159 1
d165 1
a165 1
       "$Id: Fill.f90,v 2.121 2002/04/25 20:47:02 livesey Exp $"
d210 1
d214 9
a222 8
    type (vectorValue_T), pointer :: earthRadiusQty
    type (vectorValue_T), pointer :: losQty
    type (vectorValue_T), pointer :: bndPressQty
    type (vectorValue_T), pointer :: vmrQty
    type (vectorValue_T), pointer :: measQty
    type (vectorValue_T), pointer :: modelQty
    type (vectorValue_T), pointer :: noiseQty
    type (vectorValue_T), pointer :: aprioriPrecision
d275 2
d305 3
a307 2
    real :: T1, T2                      ! for timing
    integer :: SYSTEMPNODE              ! Tree node
d541 3
d605 2
a606 1
            sysTempNode = subtree(j,key)
d994 3
d999 8
d1008 2
a1009 1
            & quantity, radianceQuantity, sysTempNode, integrationTime )
d1522 1
a1522 1
      & 'Quantity has profiles that mismatch in geodetic angle' )
d1527 1
a1527 1
      & 'Quantity has profiles that mismatch in time' )
d1583 1
a1583 1
      & (/ l_scVel, l_scVelECI, l_scVelECR /))) ) then
d2623 1
a2623 1
    & sysTempNode, integrationTime )
d2630 2
a2631 1
    integer, intent(in) :: SYSTEMPNODE ! Node describing system temperature
d2656 2
a2657 1
    if ( radiance%template%signal /= quantity%template%signal ) &
d2661 4
a2664 3
    if ( DEEBUG .and. .not. associated(quantity%values) ) &
      & call announce_error( 0, No_Error_code, &
      & 'quantity values unassociated in FillVectorQtyWithEstNoise')
d2666 7
a2672 1
    width => signals(radiance%template%signal)%widths
d2674 6
a2679 2
    if ( nsons(sysTempNode) > 2 ) then
      if ( nsons(sysTempNode) /= 1+quantity%template%noChans ) &
d2681 6
a2686 8
        & 'Inappropriate number of values for system temperature' )
      do c = 1, quantity%template%noChans
        call expr ( subtree ( c+1, sysTempNode ) , unitAsArray, valueAsArray )
        if ( all (unitAsArray /= (/PHYQ_Temperature, PHYQ_Invalid/) ) ) &
          call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Bad units for system temperature' )
        systemTemperature(c) = valueAsArray(1)
      end do
d2688 1
a2688 5
      call expr ( subtree ( 2, sysTempNode ) , unitAsArray, valueAsArray )
      if ( all (unitAsArray /= (/PHYQ_Temperature, PHYQ_Invalid/) ) ) &
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Bad units for system temperature' )
      systemTemperature(:) = valueAsArray(1)
d2694 1
a2694 1
        quantity%values(i,:) = ( radiance%values(i,:) + systemTemperature(c) ) / &
d3273 2
d3392 3
@


2.121
log
@Added channel dependent system temperature, and removed
embarassing bug whereby radiance noise was sqrt(10) too small!
@
text
@d103 1
a103 2
  integer, parameter :: VectorWontMatchL2GP = zeroGeodSpan + 1
  integer, parameter :: CantFillFromL2AUX = vectorWontMatchL2GP + 1
d163 1
a163 1
       "$Id: Fill.f90,v 2.120 2002/04/18 20:14:52 pwagner Exp $"
d1444 3
a1446 1
    real(r8), parameter:: TOLERANCE=0.05 ! Tolerence for angles
d1458 3
a1460 4
      & verticalCoordinate= (/ l_pressure, l_zeta /) ) ) then
      errorCode=vectorWontMatchL2GP
      return
    end if
d1463 3
a1465 4
      &  ((quantity%template%noChans/=1) .or. (l2gp%nFreqs/=0)) ) then
      errorCode=vectorWontMatchL2GP
      return
    end if
d1467 3
a1469 4
    if ( quantity%template%noSurfs /= l2gp%nLevels .and. (.not. interpolate) ) then
      errorCode=vectorWontMatchL2GP
      return
    end if
d1474 3
a1476 4
          & LOG10(l2gp%pressures)) > TOLERANCE) ) then
          errorCode=vectorWontMatchL2GP
          return
        end if
d1479 3
a1481 4
          & LOG10(l2gp%pressures)) > TOLERANCE) ) then
          errorCode=vectorWontMatchL2GP
          return
        end if
d1491 3
a1493 4
    if (lastProfile > l2gp%nTimes ) then
      errorCode=vectorWontMatchL2GP
      return
    end if
d1497 3
a1499 4
      &         quantity%template%phi(1,:)) > tolerance) ) then
      errorCode=vectorWontMatchL2GP
      return
    end if
d1502 3
a1504 4
      &         quantity%template%time(1,:)) > tolerance) ) then
      errorCode=vectorWontMatchL2GP
      return
    end if
a3339 3
    case ( vectorWontMatchL2GP )
      call output ( " command found no match of vetor and L2GP (set interpolate?).",&
        & advance='yes' )
d3360 4
@


2.120
log
@Fills either rhi from h2o or inverse; passes non-interpolating test
@
text
@d164 1
a164 1
       "$Id: Fill.f90,v 2.119 2002/04/16 23:27:43 pwagner Exp $"
a299 1
    real(r8) :: SYSTEMTEMPERATURE       ! For estimated noise
d301 1
d596 1
a596 4
            call expr ( gson , unitAsArray, valueAsArray )
            if ( all (unitAsArray /= (/PHYQ_Temperature, PHYQ_Invalid/) ) ) &
              call Announce_error ( key, badUnitsForSystemTemperature )
            systemTemperature = valueAsArray(1)
d987 1
a987 1
            & quantity, radianceQuantity, systemTemperature, integrationTime )
d2607 1
a2607 1
    & systemTemperature, integrationTime )
d2614 1
a2614 1
    real(r8), intent(in) :: SYSTEMTEMPERATURE ! System temperature in K
d2621 2
d2625 1
d2649 19
d2671 2
a2672 2
        quantity%values(i,:) = ( radiance%values(i,:) + systemTemperature ) / &
          & sqrt ( integrationTime * 10e6 * width(c) )
d3370 3
@


2.119
log
@FillRHI testing begun; incomplete
@
text
@d20 3
a22 2
    & F_PTANQUANTITY, F_QUANTITY, F_RADIANCEQUANTITY, F_RATIOQUANTITY, F_REFGPHQUANTITY, &
    & F_RESETSEED, F_Rows, F_SCECI, F_SCVEL, F_SCVELECI, F_SCVELECR, F_SEED, &
d164 1
a164 1
       "$Id: Fill.f90,v 2.118 2002/04/13 00:31:46 pwagner Exp $"
d353 1
d508 2
d561 3
d835 2
a836 2
            !if ( .not. any(got( &
            ! & (/f_h2oquantity, f_temperatureQuantity, f_refGPHQuantity/) &
d855 11
d869 37
a905 1
                & dontMask, ignoreZero, ignoreNegative, interpolate, .true. )
d2316 1
a2316 1
   & h2oQuantity, temperatureQuantity, &
d2318 1
a2318 1
   & markUndefinedValues )
d2326 1
d2335 1
d2337 3
a2339 2
    type (VectorValue_T), intent(inout) :: QUANTITY ! rhi Quantity to fill
    type (VectorValue_T), intent(in) :: h2oQuantity ! vmr
d2347 1
d2353 1
a2353 1
    logical, parameter ::               DEEBUG_RHI = .true.
d2358 1
d2373 2
d2383 1
a2383 1
    real (r8), dimension(h2oquantity%template%noSurfs) :: &
d2388 14
d2403 5
d2412 1
a2412 1
      &(/ size(h2oQuantity%values,dim), &
d2425 1
a2425 1
     &(/ h2oQuantity%template%noSurfs, &
d2435 1
a2435 1
     &   (h2oQuantity%template%noChans == Quantity%template%noChans)
d2437 1
a2437 1
     &   (h2oQuantity%template%noInstances == Quantity%template%noInstances)
d2450 1
a2450 1
      if ( h2oquantity%template%coherent ) then
d2463 1
a2463 1
      else                                                           
d2476 2
a2477 2
      if ( h2oquantity%template%verticalCoordinate == l_pressure ) then 
        zetah2o = -log10 ( h2oquantity%template%surfs(:,s_h2o) )             
d2479 1
a2479 1
        zetah2o = h2oquantity%template%surfs(:,s_h2o)            
d2499 3
a2501 3
          do s=1, h2oquantity%template%noSurfs
            qIndex = Chan_h2o + (s-1)*h2oquantity%template%noChans
            oldH2o(s) = h2oQuantity%values(qIndex, i_h2o)
d2525 1
a2525 1
            H2OofZeta(s) = h2oQuantity%values(qIndex, i)
d2536 1
a2536 1
           &   isVectorQtyMasked(h2oQuantity, qIndex, i) .or. &
d2552 5
a2556 3
             & exp(-(C(T)+zeta(qIndex)) * log(10.)) &
             & / &
             & exp(3.56654*log(T/273.16))
d2564 5
a2568 1
      call output(quantity%template%noInstances, advance='yes')
d2573 9
a2581 2
      call dump(zeta, 'zeta(log hPa)')
      call dump(h2oQuantity%values(:,1), 'H2O(vmr)')
d2583 5
a2587 1
      call dump(Quantity%values(:,1), 'RHI(%)')
d2601 1
d3351 3
@


2.118
log
@More flesh on FillrhiFromH2o; still untested
@
text
@d163 1
a163 1
       "$Id: Fill.f90,v 2.117 2002/04/11 23:51:28 pwagner Exp $"
a839 2
              !refGPHQuantity => GetVectorQtyByTemplateIndex( &
              !  & vectors(refGPHVectorIndex), refGPHQuantityIndex)
a847 4
              !elseif ( .not. ValidateVectorQuantity(refGPHQuantity, &
              !  & quantityType=(/l_refgph/)) ) then
              !  call Announce_Error ( key, No_Error_code, &
              !  & 'The refgphQuantity is not a refgph'  )
d851 1
a851 1
                & dontMask, ignoreZero, ignoreNegative, interpolate )
d2263 3
a2265 2
   & dontMask, ignoreZero, ignoreNegative, interpolate )
    ! Convert h2o vmr to %RHI
d2288 2
a2289 1
    logical, intent(in)           ::    interpolate ! If VGrids differ
d2295 2
a2296 1
    integer ::                          S           ! Surface loop counter    
d2298 2
a2299 2
    integer ::                          I_H2O       ! Instances
    integer ::                          I_T         ! Instances
a2301 1
    logical ::                          skipMe                                
d2308 10
a2317 2
!    logical, parameter               :: interpolate = .false.
    integer                          :: dim
a2323 1
    real (r8) ::                        T
d2325 2
d2362 1
d2365 15
d2382 1
a2382 1
        zeta = -log10 ( quantity%template%surfs(:,i) )             
d2384 1
a2384 1
        zeta = quantity%template%surfs(:,i)                        
d2397 1
a2397 1
        zetah2o = -log10 ( h2oquantity%template%surfs(:,i_h2o) )             
d2399 1
a2399 1
        zetah2o = h2oquantity%template%surfs(:,i_h2o)            
d2402 1
a2402 1
        zetaTemperature = -log10 ( Temperaturequantity%template%surfs(:,i_T) )             
d2404 1
a2404 1
        zetaTemperature = Temperaturequantity%template%surfs(:,i_T)            
d2476 1
d2480 12
d3253 3
@


2.117
log
@Fleshed out FillRHIFromH2O; untested yet
@
text
@d163 1
a163 1
       "$Id: Fill.f90,v 2.116 2002/04/10 17:45:44 pwagner Exp $"
d857 1
a857 1
                & dontMask, ignoreZero, ignoreNegative )
d2268 2
a2269 1
   & h2oQuantity, temperatureQuantity, dontMask, ignoreZero, ignoreNegative )
d2274 11
d2293 1
d2297 2
d2300 3
a2302 1
    integer ::                          I           ! Instances               
a2303 1
    integer ::                          NOCHANS                               
d2306 2
d2310 3
a2312 1
    logical, parameter               :: interpolate = .false.
d2314 6
a2319 1
    real (r8), dimension(quantity%template%noSurfs) :: outZeta
d2334 1
a2334 1
      & '(currently all must have same size)' )
d2346 1
a2346 1
      & '(currently all must be on the same VGrid)' )
d2349 8
a2356 6
    ! zeta must be in log(hPa) units
    if ( quantity%template%verticalCoordinate == l_pressure ) then  
      outZeta = -log10 ( quantity%template%surfs(:,1) )             
    else                                                            
      outZeta = quantity%template%surfs(:,1)                        
    endif                                                           
d2359 26
d2387 41
d2430 10
a2439 2
          qIndex = Channel + (s-1)*nochans
          skipMe = &
d2441 3
a2443 4
          &   isVectorQtyMasked(h2oQuantity, qIndex, i) .or. &
          &   isVectorQtyMasked(temperatureQuantity, qIndex, i) &
          & .or. (ignoreNegative .and. h2oQuantity%values(qIndex, i) < 0.0 ) &
          & .or. (ignoreZero .and. h2oQuantity%values(qIndex, i) == 0.0 ))
d2445 1
a2445 1
          skipMe = skipMe .or. temperatureQuantity%values(qIndex, i) <= 0.0
d2447 1
a2447 1
            T = temperatureQuantity%values(qIndex, i)
d2449 1
a2449 1
             & h2oQuantity%values(qIndex, i) &
d2451 1
a2451 1
             & exp(-(C(T)+outZeta(qIndex)) * log(10.)) &
d3219 3
@


2.116
log
@Added FillRHI from h2oquantity (just a placeholder)
@
text
@d1 1
a1 1
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
a160 1
  !  integer, parameter :: s_Fill = 0   ! to be replaced by entry in init_tables_module
d163 1
a163 1
       "$Id: Fill.f90,v 2.115 2002/04/04 16:32:42 livesey Exp $"
a246 1
  !  The next three are FALSE by default
a329 7
    ! Logical id of file(s) holding old L2GP data
    !    OL2FileHandle = mlspcf_ol2gp_start

    ! starting quantities number for *this* vector; what if we have more?
    !    qtiesStart = 1
    !   Calculate qtiesStart for the specific quantity below

d552 1
a552 1
          case ( f_refGPHQuantity ) ! For hydrostatic
d596 1
a596 1
          case ( f_temperatureQuantity ) ! For hydrostatic
d828 5
a832 1
            if ( .not. got(f_h2oQuantity) ) then
d834 1
a834 1
              & 'Missing the h2o field to fill rhi'  )
d838 4
d843 16
a858 3
                & quantityType=(/l_vmr/), molecule=(/l_h2o/)) )&
                & call Announce_Error ( key, badGeocAltitudeQuantity )
              call FillRHI ( key, quantity, h2oQuantity )
d2266 3
a2268 2
  ! ------------------------------------- FillRHI ----
  subroutine FillRHI ( key, quantity, h2oQuantity )
d2271 1
a2271 1
    !  humidity measurement: Metjod and validation" Read et. al. 
d2276 5
d2282 92
a2373 1
  end subroutine FillRHI
d3118 3
@


2.115
log
@Added negative error bar stuff
@
text
@d33 1
a33 1
    & L_PRESSURE, L_PTAN, L_RADIANCE, &
d164 1
a164 1
       "$Id: Fill.f90,v 2.114 2002/03/27 17:37:57 livesey Exp $"
d493 1
a493 1
          case ( f_h2oQuantity ) ! For hydrostatic
d836 12
d2254 12
d3009 3
@


2.114
log
@Minor changes to random number stuff.
Now seed incremented with chunk number
@
text
@d12 1
a12 1
  use INIT_TABLES_MODULE, only: F_BOUNDARYPRESSURE, &
d19 2
a20 2
    & F_MODEL, F_MULTIPLIER, F_NOFINEGRID, F_PRECISION,  F_PTANQUANTITY, &
    & F_QUANTITY, F_RADIANCEQUANTITY, F_RATIOQUANTITY, F_REFGPHQUANTITY, &
d32 1
a32 1
    & L_RECTANGLEFROMLOS, L_LOSVEL, L_NONE, L_PLAIN, &
d164 1
a164 1
       "$Id: Fill.f90,v 2.113 2002/03/19 00:52:40 pwagner Exp $"
d219 1
d221 2
d277 1
d367 1
d470 3
d543 6
d840 10
d2985 4
@


2.113
log
@SOme new checks added to FillLOSVelocity
@
text
@d164 1
a164 1
       "$Id: Fill.f90,v 2.112 2002/03/14 17:29:59 pwagner Exp $"
d620 4
d634 1
a634 1
              seed(j) = int(valueAsArray(1))
d2961 3
@


2.112
log
@Fixed check in FillLOSVelocity
@
text
@d164 1
a164 1
       "$Id: Fill.f90,v 2.111 2002/03/14 01:01:17 pwagner Exp $"
d1483 14
d2957 3
@


2.111
log
@Can fill scVelECI and scVelECR from l1b
@
text
@d164 1
a164 1
       "$Id: Fill.f90,v 2.110 2002/03/13 22:01:41 livesey Exp $"
d1469 1
a1469 1
      &  (scVel%template%quantityType /= &
d2943 3
@


2.110
log
@Added masking of fill from vector quantity, also changed
from m_explicitfill to m_fill
@
text
@d21 2
a22 1
    & F_RESETSEED, F_Rows, F_SCECI, F_SCVEL, F_SEED, F_SOURCE, F_SOURCEGRID, &
d34 1
a34 1
    & L_REFGPH, L_SCECI, L_SCGEOCALT, L_SCVEL, &
d164 1
a164 1
       "$Id: Fill.f90,v 2.109 2002/03/08 08:07:00 livesey Exp $"
d558 6
d748 2
a749 1
            if ( .not. any(got( (/f_tngtECI, f_scECI, f_scVel/) )) ) then
d1468 3
a1470 1
      &  (scVel%template%quantityType /= l_scVel) ) then
d2552 4
d2943 4
@


2.109
log
@Added explicit fill mask
@
text
@d82 1
a82 1
    & VectorTemplate_T, VectorValue_T, M_ExplicitFill
d163 1
a163 1
       "$Id: Fill.f90,v 2.105 2002/02/06 01:35:29 livesey Exp $"
d855 3
d868 8
a875 9
          quantity%values = sourceQuantity%values
          ! If we have a mask, copy it over.
          if ( associated(sourceQuantity%mask) ) then
            call CreateMask ( quantity )
            quantity%mask = sourceQuantity%mask
          else
            ! Otherwise, if the destination quantity had one, then
            ! delete that.
            call Deallocate_test ( quantity%mask, 'quantity%mask', ModuleName )
d2454 1
a2454 1
            where ( iand ( ichar(quantity%mask), m_ExplicitFill ) == 0 )
d2458 1
a2458 1
            where ( iand ( ichar(quantity%mask(k,:)), m_ExplicitFill ) == 0 )
d2491 1
a2491 1
          if ( iand ( ichar(quantity%mask(i,j)), m_ExplicitFill ) == 0 ) &
d2929 3
@


2.108
log
@Hooked up the errors for height restricted explicit fills.
@
text
@d15 1
a15 1
    & F_EXTINCTION, F_FRACTION, F_HEIGHT, F_H2OQUANTITY, F_LOSQTY,&
d29 1
a29 2
    & L_COLUMNABUNDANCE, L_ESTIMATEDNOISE, L_EXPLICIT, L_GEODALTITUDE, L_GPH, &
    & L_GRIDDED, L_HEIGHT, &
d43 1
a43 1
    & PHYQ_Time, PHYQ_Length, PHYQ_Pressure
d75 1
a75 2
  use TREE_TYPES, only: N_NAMED, N_SET_ONE, N_NUMBER, N_COLON_LESS, &
    & N_LESS_COLON, N_LESS_COLON_LESS
d82 1
a82 1
    & VectorTemplate_T, VectorValue_T
a104 5
  integer, parameter :: InvalidQtyHeightForExplicit = CantFillFromL1B + 1
  integer, parameter :: OnlyOneHeightForExplicit = &
    & InvalidQtyHeightForExplicit + 1
  integer, parameter :: badHeightUnitForExplicit = OnlyOneHeightForExplicit + 1
  integer, parameter :: invalidHeightRestrExpFill = badHeightUnitForExplicit + 1
d107 1
a107 1
  integer, parameter :: MissingField = InvalidHeightRestrExpFill + 1
d163 1
a163 1
       "$Id: Fill.f90,v 2.107 2002/02/20 22:42:35 livesey Exp $"
a240 1
    integer :: HEIGHTNODE               ! A node of the tree
a361 1
      heightNode = 0
a474 2
          case ( f_height )
            heightNode=subtree(j,key)
d886 1
a886 1
            & vectors(vectorIndex)%globalUnit, heightNode )
d2409 3
a2411 2
  subroutine ExplicitFillVectorQuantity(quantity, valuesNode, spread, &
    & globalUnit, heightNode )
d2417 2
a2418 2
    integer, intent(in) :: VALUESNODE ! Tree node
    logical, intent(in) :: SPREAD ! One instance given, spread to all
d2420 1
a2420 1
    integer, intent(in) :: HEIGHTNODE   ! From tree
d2423 5
a2427 9
    integer :: K                ! Loop counter
    integer, DIMENSION(2) :: UNITASARRAY ! Unit for value given
    real (r8), DIMENSION(2) :: VALUEASARRAY ! Value given
    integer :: TESTUNIT                 ! Unit to use
    integer, dimension(1) :: S1, S2     ! Surfaces to consider
    integer :: CHAN                     ! Channel counter
    integer :: HEIGHTID                 ! Node ID
    integer :: I                        ! Array index
    integer :: REQUIREDHEIGHTUNIT       ! For checking
d2433 1
a2433 43
    ! Note this is a rather brain dead fill method, it is pretty restricitive
    ! on what options you can combine (spread/heights, etc.) mainly because of
    ! lazyness on behalf of the author, rather than any actual limit, though
    ! there is a recognition that the 'obscure' options are not likely to be
    ! wanted.

    ! If got heights, setup the limits
    if ( heightNode /= 0 ) then

      ! Check that we're not venturing into uncharted territory
      if ( ( .not. spread ) .or. ( quantity%template%noChans /= 1 ) .or. &
        & ( .not. quantity%template%coherent ) .or. &
        & ( nsons(valuesNode)-1 /= 1 ) )  &
        & call Announce_error ( valuesNode, invalidHeightRestrExpFill )

      ! Work out what height coordinate we should be expecting
      select case ( quantity%template%verticalCoordinate ) 
      case ( l_zeta )
        requiredHeightUnit = phyq_pressure
      case ( l_pressure )
        requiredHeightUnit = phyq_pressure
      case ( l_geodAltitude )
        requiredHeightUnit = phyq_length
      case default
        call Announce_error ( heightNode, invalidQtyHeightForExplicit )
      end select
      if ( nsons ( heightNode ) > 2 ) &
        & call Announce_error ( heightNode, onlyOneHeightForExplicit )
      call expr ( subtree(k+1,heightNode), unitAsArray, valueAsArray )
      heightID = node_id ( subtree(k+1,heightNode) )
      ! Check units
      if ( heightID == n_number ) then
        ! Just a single number
        if ( unitAsArray(1) /= requiredHeightUnit ) &
          & call Announce_error ( heightNode, badHeightUnitForExplicit )
        ! Make it look like a range to make the code simpler
        valueAsArray(2) = valueAsArray(1)
      else
        if ( all ( unitAsArray /= requiredHeightUnit ) .or. &
          & any ( unitAsArray /= requiredHeightUnit .and. unitAsArray /=&
          & phyq_dimensionless ) ) &
          & call Announce_error ( heightNode, badHeightUnitForExplicit )
      end if
a2434 25
      ! Now work out the surfaces in question
      if ( quantity%template%verticalCoordinate == l_pressure ) then
        s1 = minloc ( abs ( -log10(quantity%template%surfs(:,1)) + log10(valueAsArray(1)) ) )
        s2 = minloc ( abs ( -log10(quantity%template%surfs(:,1)) + log10(valueAsArray(2)) ) )
      else
        s1 = minloc ( abs ( quantity%template%surfs(:,1) - valueAsArray(1) ) )
        s2 = minloc ( abs ( quantity%template%surfs(:,1) - valueAsArray(2) ) )
      end if
      
      ! Now consider the open range issue
      select case ( heightID )
      case ( n_colon_less )
        s1 = min ( s1 + 1, quantity%template%noSurfs )
      case ( n_less_colon )
        s2 = max ( s2 - 1, 1 )
      case ( n_less_colon_less )
        s1 = min ( s1 + 1, quantity%template%noSurfs )
        s2 = max ( s2 - 1, 1 )
      end select
    else
      s1 = 1
      s2 = quantity%template%instanceLen
    end if

    if (spread) then      ! 1 instance/value given, spread to all instances
d2440 1
d2446 1
a2446 1
       if ( (unitAsArray(1) /= testUnit) .and. &
d2450 10
a2459 2
        if (nsons(valuesNode)-1 == 1) then
          quantity%values(s1(1):s2(1),:) = valueAsArray(1)
d2461 7
a2467 3
          ! Can't get here in the 'height' case, so don't worry about s1,s2
          quantity%values(k,:)=valueAsArray(1)
        endif
d2469 4
a2472 3
    else                                ! Not spread, fill all values
      ! Check we have the right number of values (can't get here in the
      ! 'height' case so don't worry about s1,s2
d2476 1
d2486 8
a2493 3
        quantity%values(mod(k-1,quantity%template%instanceLen)+1,&
          &             (k-1)/quantity%template%instanceLen+1)=&
          & valueAsArray(1)
a2808 2
    case ( badHeightUnitForExplicit )
      call output ( " incorrect units for height field", advance='yes' )
d2841 1
a2841 3
      call output ( " is an inappropriate explicit fill.", advance='yes' )
    case ( invalidHeightRestrExpFill )
      call output ( " is an inappropriate height restricted explicit fill.", advance='yes' )
a2895 2
    case ( onlyOneHEightForExplicit )
      call output ( " can only have one height field for explicit fill.", advance='yes' )
a2926 6
! Revision 2.107  2002/02/20 22:42:35  livesey
! Embarassing bug fix
!
! Revision 2.106  2002/02/20 02:08:14  livesey
! Added height restricted explicit fill (not yet tested.)
!
@


2.107
log
@Embarassing bug fix
@
text
@d170 1
a170 1
       "$Id: Fill.f90,v 2.106 2002/02/20 02:08:14 livesey Exp $"
d2870 2
d2905 2
d2961 2
d2994 3
@


2.106
log
@Added height restricted explicit fill (not yet tested.)
@
text
@d170 1
a170 1
       "$Id: Fill.f90,v 2.105 2002/02/06 01:35:29 livesey Exp $"
d2510 1
d2988 3
@


2.105
log
@Added ability to load ptan from l1b
@
text
@d15 1
a15 1
    & F_EXTINCTION, F_FRACTION, F_H2OQUANTITY, F_LOSQTY,&
d29 2
a30 1
    & L_COLUMNABUNDANCE, L_ESTIMATEDNOISE, L_EXPLICIT, L_GPH, L_GRIDDED, L_HEIGHT, &
d44 1
a44 1
    & PHYQ_Time, PHYQ_Length
d76 2
a77 1
  use TREE_TYPES, only: N_NAMED, N_SET_ONE
d107 5
d114 1
a114 1
  integer, parameter :: MissingField = cantFillFromL1B + 1
d170 1
a170 1
       "$Id: Fill.f90,v 2.104 2002/02/05 01:45:21 livesey Exp $"
d248 1
d370 1
d484 2
d897 1
a897 1
            & vectors(vectorIndex)%globalUnit )
d2420 2
a2421 2
  subroutine ExplicitFillVectorQuantity(quantity, valuesNode, spread, globalUnit)

d2430 1
d2434 8
a2441 3
    integer, DIMENSION(2) :: unitAsArray ! Unit for value given
    real (r8), DIMENSION(2) :: valueAsArray ! Value given
    integer :: TestUnit                 ! Unit to use
d2447 67
a2514 1

a2519 1

d2530 1
a2530 1
          quantity%values=valueAsArray(1)
d2532 1
d2536 3
a2538 4

    else                  ! Not spread, fill all values

      ! Check we have the right number of values
a2541 1

d2901 1
a2901 1
      call output ( " has inappropriate dimensionality for explicit fill.", advance='yes' )
d2987 3
@


2.104
log
@Added preliminary vector/vector fill, not yet tested.
@
text
@d163 1
a163 1
       "$Id: Fill.f90,v 2.103 2002/01/18 00:24:21 livesey Exp $"
d2499 3
d2906 3
@


2.103
log
@Added sideband argument to call to GetSignalName when reading
L1B radiances (so can now read split signals).
@
text
@d35 1
a35 1
    & L_TNGTGEOCALT, L_TRUE, L_VGRID, L_VMR, L_ZETA
d163 1
a163 1
       "$Id: Fill.f90,v 2.102 2002/01/16 18:06:31 livesey Exp $"
d852 24
d2903 4
@


2.102
log
@Changed neverFail flag in ReadL1B to false.  I want to see
the error message.
@
text
@d163 1
a163 1
       "$Id: Fill.f90,v 2.101 2002/01/09 00:00:04 pwagner Exp $"
d2476 2
a2477 1
      call GetSignalName ( quantity%template%signal, nameString, noChannels=.TRUE. )
d2879 4
@


2.101
log
@Replaced write or print statements with calls to output
@
text
@d163 1
a163 1
       "$Id: Fill.f90,v 2.100 2001/12/06 23:45:07 livesey Exp $"
d2455 1
a2455 1
  & isPrecision, PrecisionQuantity )
d2497 1
a2497 1
   if ( isPrecision ) nameString = trim(nameString) // PRECISIONSUFFIX
d2501 1
a2501 1
      & NeverFail=.true. )
d2514 1
a2514 1
          & call MaskVectorQty(quantity, row, column)
d2521 1
a2521 1
          & call MaskVectorQty(quantity, row, column)
d2525 1
a2525 1
    
d2527 1
a2527 1
     & call Dump( l1bData )
d2878 3
@


2.100
log
@Dealt with move of Omega to Units
@
text
@d163 1
a163 1
       "$Id: Fill.f90,v 2.99 2001/11/09 23:17:22 vsnyder Exp $"
d2282 31
a2312 8
        print *, 'ValidateVectorQuantity(quantity, minorFrame=.true.) ', &
        &  ValidateVectorQuantity(quantity, minorFrame=.true., sayWhyNot=.true.)
        print *, 'ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true.) ', &
        & ValidateVectorQuantity(geocAltitudeQuantity, minorFrame=.true., sayWhyNot=.true.)
        print *, 'quantity%template%instrumentModule ', &
        & quantity%template%instrumentModule
        print *, 'geocAltitudeQuantity%template%instrumentModule ', &
        & geocAltitudeQuantity%template%instrumentModule
d2878 3
@


2.99
log
@Use Time_Now instead of CPU_TIME
@
text
@d67 1
a67 1
  use ScanModelModule, only: GetBasisGPH, GetHydrostaticTangentPressure, OMEGA
d76 1
a76 1
  use UNITS
d163 1
a163 1
       "$Id: Fill.f90,v 2.98 2001/10/26 23:23:05 pwagner Exp $"
d2855 3
@


2.98
log
@Complies with l1b data dump
@
text
@d70 1
d163 1
a163 1
       "$Id: Fill.f90,v 2.97 2001/10/26 18:15:18 livesey Exp $"
d322 1
a322 1
    if ( timing ) call cpu_time ( t1 )
d1015 1
a1015 1
          call cpu_time ( t1 )
d1042 1
a1042 1
      call cpu_time ( t2 )
d2855 3
@


2.97
log
@Added upper argument to MatrixInversion in FillCovariance
@
text
@d44 1
a44 1
  use L1BData, only: DeallocateL1BData, DumpL1BData, FindL1BData, L1BData_T, &
d162 1
a162 1
       "$Id: Fill.f90,v 2.96 2001/10/25 23:32:11 pwagner Exp $"
d2503 1
a2503 1
     & call DumpL1BData( l1bData )
d2854 3
@


2.96
log
@Responds to l1b switch by dumping l1b quantity during Fill
@
text
@d162 1
a162 1
       "$Id: Fill.f90,v 2.95 2001/10/24 22:35:33 dwu Exp $"
d1243 1
a1243 1
            call MatrixInversion(M)
d2854 3
@


2.95
log
@add FillDiagonal
@
text
@d44 2
a45 2
  use L1BData, only: DeallocateL1BData, FindL1BData, L1BData_T, ReadL1BData, &
    & PRECISIONSUFFIX
d70 1
a70 1
  use TOGGLES, only: GEN, LEVELS, TOGGLE
d162 1
a162 1
       "$Id: Fill.f90,v 2.94 2001/10/23 16:38:09 pwagner Exp $"
d2476 2
a2477 1
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
d2501 3
d2854 3
@


2.94
log
@Fill from l1b can fill precision, set mask
@
text
@d38 1
a38 1
    & S_MATRIX,  S_SNOOP, S_TIME, S_TRANSFER, S_VECTOR
d53 1
a53 1
    & DestroyMatrix, Dump, &
d162 1
a162 1
       "$Id: Fill.f90,v 2.93 2001/10/19 23:42:50 pwagner Exp $"
d912 20
d2850 3
@


2.93
log
@Applies multipliers to chi^2 fills, too
@
text
@d17 3
a19 3
    & F_INTEGRATIONTIME, F_INTERPOLATE, F_INVERT, F_INTRINSIC, F_LENGTHSCALE, &
    & F_MATRIX, F_MAXITERATIONS, F_METHOD, &
    & F_MEASUREMENTS, F_MODEL, F_MULTIPLIER, F_NOFINEGRID, F_PTANQUANTITY, &
d44 2
a45 1
  use L1BData, only: DeallocateL1BData, FindL1BData, L1BData_T, ReadL1BData
d79 1
a79 1
    & GetVectorQtyByTemplateIndex, isVectorQtyMasked, &
d162 1
a162 1
       "$Id: Fill.f90,v 2.92 2001/10/19 22:32:44 pwagner Exp $"
d200 1
d228 1
a243 1
    logical :: DONTMASK                 ! Use even masked values if TRUE
d251 1
d272 2
d349 1
a349 2
      spread = .false.
      interpolate = .false.
d351 1
a351 1
      dontMask = .false.
d354 2
a355 1
      got= .false.
d357 1
d505 2
d530 3
d864 9
a872 1
          call FillVectorQuantityFromL1B ( key, quantity, chunks(chunkNo), l1bInfo )
d2410 2
a2411 1
  subroutine FillVectorQuantityFromL1B ( root, quantity, chunk, l1bInfo )
d2413 5
a2417 3
    type (VectorValue_T), INTENT(INOUT) :: QUANTITY
    type (MLSChunk_T), INTENT(IN) :: CHUNK
    type (l1bInfo_T), INTENT(IN) :: L1BINFO
d2423 1
d2453 2
d2465 15
d2830 3
@


2.92
log
@Can destroy a vector or a matrix; def. multiplier(s) in addNoise
@
text
@d161 1
a161 1
       "$Id: Fill.f90,v 2.91 2001/10/19 00:00:36 pwagner Exp $"
d638 1
a638 1
              call expr(subtree(j+1,seedNode),unitAsArray,valueAsArray)
d711 16
d766 1
a766 1
                & dontMask, ignoreZero, ignoreNegative )
d781 1
a781 1
                & dontMask, ignoreZero, ignoreNegative )
d796 1
a796 1
                & dontMask, ignoreZero, ignoreNegative )
d1549 2
a1550 1
  & dontMask, ignoreZero, ignoreNegative, firstInstance, lastInstance )
d1562 2
d1579 1
d1582 19
d1661 1
a1661 1
            & (measQty%values(qIndex, i) - modelQty%values(qIndex, i)) &
d1681 2
a1682 1
  & dontMask, ignoreZero, ignoreNegative, firstInstance, lastInstance )
d1694 2
d1711 22
d1799 1
a1799 1
            & (measQty%values(row, i) - modelQty%values(row, i)) &
d1819 2
a1820 1
  & dontMask, ignoreZero, ignoreNegative, firstInstance, lastInstance )
d1832 2
d1851 22
d1933 1
a1933 1
            & (measQty%values(qIndex, i) - modelQty%values(qIndex, i)) &
d2790 3
@


2.91
log
@Replaced remove with destroy
@
text
@d19 1
a19 1
    & F_MEASUREMENTS, F_MODEL, F_NOFINEGRID, F_PTANQUANTITY, &
d52 2
a53 1
    & Dump, FindBlock, GetKindFromMatrixDatabase, GetFromMatrixDatabase, K_SPD, &
d155 2
d161 1
a161 1
       "$Id: Fill.f90,v 2.90 2001/10/18 23:29:57 pwagner Exp $"
d260 1
d263 2
d270 1
a270 1
    integer :: RADIANCEVECTORINDEX    ! For radiance quantity
d282 1
a316 3
    dontMask = .false.
    ignoreZero = .false.
    ignoreNegative = .false.
a330 3
    spread = .false.
    interpolate = .false.
    extinction = .false.
a331 1
    noFineGrid = 1
d344 6
d354 1
d515 2
a538 3
          case ( f_sourceQuantity )       ! When filling from a vector, what vector/quantity
            sourceVectorIndex = decoration(decoration(subtree(1,gson)))
            sourceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
d545 2
a546 2
          case ( f_seed ) ! For explicit fill
            valuesNode=subtree(j,key)
d553 3
d609 2
a610 2
            do j=1, nsons(valuesNode)-1
              call expr(subtree(j+1,valuesNode),unitAsArray,valueAsArray)
a626 1
            call mls_random_seed(gget=seed(1:))
d628 1
d633 16
d650 1
a650 1
            & noiseQty )
d880 4
a883 2
        if (DEEBUG) call output('Destroy vector instruction', advance='no')
        ! Here we're to try to shrink the vector database by removing a vector
d889 1
d896 2
d903 29
a931 13
        if (DEEBUG) then
          if ( vectors(sourceVectorIndex)%name /= 0 ) then
            call output ( '   Vector Name = ' )
            call display_string ( vectors(sourceVectorIndex)%name )
          end if
          if ( vectors(sourceVectorIndex)%template%name /= 0 ) then
            call output ( ' Template_Name = ' )
            call display_string ( vectors(sourceVectorIndex)%template%name )
            call output ( ' ', advance='yes' )
          end if
          call output ( ' -- vector database before removal --', advance='yes' )
          call dump(vectors, details=-2)
        endif
d933 1
a933 5
        call DestroyVectorInfo ( vectors(sourceVectorIndex) )
!        vectorindex = rmVectorFromDatabase ( vectors, vectors(sourceVectorIndex) )
        if (DEEBUG) then
          call output ( ' -- vector database after removal --', advance='yes' )
          call dump(vectors, details=-2)
d1003 1
a1003 1
            & noiseQty )
d1006 2
d1010 4
a1013 3
    type (VectorValue_T), intent(inout) ::   quantity
    type (VectorValue_T), intent(in) ::      sourceQuantity
    type (VectorValue_T), intent(in) ::      noiseQty
d1017 1
d1028 17
d1047 2
a1048 1
        quantity%values(row, column) = sourceQuantity%values(row, column) &
d1050 1
a1050 1
          & drang() * noiseQty%values(row, column)
d2701 3
@


2.90
log
@Fixes in addNoise, remove
@
text
@d37 2
a38 2
  use INIT_TABLES_MODULE, only: S_DUMP, S_FILL, S_FILLCOVARIANCE, S_MATRIX, S_REMOVE, &
    & S_SNOOP, S_TIME, S_TRANSFER, S_VECTOR
d158 1
a158 1
       "$Id: Fill.f90,v 2.89 2001/10/18 23:07:40 livesey Exp $"
d854 2
a855 2
      case ( s_remove ) ! ===============================  Remove ==
        if (DEEBUG) call output('Remove vector instruction', advance='no')
d858 1
a858 1
        ! (Shall we allow multiple rms on a single line? Maybe later)
d868 1
a868 1
          case ( f_source )
d2637 3
@


2.89
log
@Removed debug dump statement
@
text
@d158 1
a158 1
       "$Id: Fill.f90,v 2.88 2001/10/18 23:06:05 livesey Exp $"
d305 1
d313 1
d855 1
a855 1
        if (DEEBUG) call output('Remove vector instruction', advance='yes')
d860 7
a866 3
          gson = subtree(j,key)  ! The argument
          fieldIndex = get_field_id(gson)
          gson = subtree(2,gson) ! Now the value of said argument
d869 1
a869 1
            sourceVectorIndex = decoration(gson)
d873 13
d887 6
a892 1
        vectorindex = rmVectorFromDatabase ( vectors, vectors(sourceVectorIndex) )
d939 1
d2637 3
@


2.88
log
@Tidied up some bugs in transfer, must have been asleep or something!
@
text
@d158 1
a158 1
       "$Id: Fill.f90,v 2.87 2001/10/18 22:30:30 livesey Exp $"
a1021 2
      call Dump ( LMasked )

d2612 3
@


2.87
log
@Added s_dump and more functionality to fillCovariance
@
text
@d158 1
a158 1
       "$Id: Fill.f90,v 2.86 2001/10/18 03:51:46 livesey Exp $"
d987 2
a988 2
    type (Vector_T), pointer :: DMASKED ! Masked diagonal
    type (Vector_T), pointer :: LMASKED ! Masked length scale
d1006 3
a1008 1
    call CopyVector ( Dmasked, vectors(diagonal) )
d1018 2
a1019 2
      nullify ( m )
      call CopyVector ( Lmasked, vectors(lengthScale) ) 
d1021 2
d2455 1
a2455 1
      sq => dest%quantities(sqi)
d2459 2
a2460 2
        if (associated(dq%mask)) then
          if (.not. associated(sq%mask)) call CreateMask ( dq )
d2614 3
@


2.86
log
@Just some tidying up.
@
text
@d25 1
a25 1
    & F_TYPE, F_VMRQUANTITY, FIELD_FIRST, FIELD_LAST
d37 1
a37 1
  use INIT_TABLES_MODULE, only: S_FILL, S_FILLCOVARIANCE, S_MATRIX, S_REMOVE, &
d74 3
a76 1
  use VectorsModule, only: AddVectorToDatabase, CreateVector, Dump, &
d158 1
a158 1
       "$Id: Fill.f90,v 2.85 2001/10/18 00:46:32 livesey Exp $"
d381 15
d983 3
d987 2
d1001 1
d1005 4
d1012 4
a1015 1
    else
d1017 4
a1020 1
      ! Do a more complex fill.  First check our vectors are OK.
d1022 1
a1022 1
        & vectors(diagonal)%template%id ) call MLSMessage ( MLSMSG_Error, &
d1025 1
a1025 1
        & vectors(lengthScale)%template%id ) call MLSMessage ( MLSMSG_Error, &
d1027 1
a1027 1
      if ( vectors(lengthScale)%globalUnit /= phyq_length ) &
d1030 1
d1044 6
a1049 1
        qt => vectors(diagonal)%quantities(q)%template
d1058 1
a1058 1
        do i = 1, covariance%m%col%vec%quantities(q)%template%noInstances
d1064 1
a1064 1
            m(j,j) = vectors(diagonal)%quantities(q)%values(j,i) ** 2.0
d1072 1
a1072 2
                meanLength = sqrt ( vectors(lengthScale)%quantities(q)%values(j,i) * &
                  &                 vectors(lengthScale)%quantities(q)%values(k,i) )
d1074 1
a1074 2
                if ( fraction /= 0) thisFraction = &
                  & vectors(fraction)%quantities(q)%values(j,i)
d1089 15
a1103 1
          if ( invert ) call MatrixInversion(M)
d1110 4
d2441 2
a2442 1
    type (VectorValue_T), POINTER :: DQ ! Destination quantity
d2451 1
d2454 8
a2461 2
        dq%values = source%quantities(sqi)%values
        ! Think about mask later !??? NJL
d2610 3
@


2.85
log
@Bug fixes in Transfer
@
text
@d156 1
a156 1
       "$Id: Fill.f90,v 2.84 2001/10/17 23:40:08 pwagner Exp $"
d2212 1
a2212 1
   & Ptan, Re, noFineGrid, extinction, errorCode )
d2217 1
a2217 1
    !
d2241 2
a2242 1
    real (r8), dimension(los%template%noChans,los%template%noSurfs,los%template%noInstances) :: beta
d2250 4
a2253 4
!    if (.not. ValidateVectorQuantity(qty, coherent=.TRUE., stacked=.TRUE., &
!      & verticalCoordinate= (/ l_pressure, l_zeta /) ) ) then
!      call output ( " quantity vertical grid in FillQuantityFromLOSgrid is not valid")
!    end if
d2256 1
a2256 1
        outZeta = -log10 ( qty%template%surfs(:,1) )
d2258 1
a2258 1
        outZeta = qty%template%surfs(:,1)
d2263 1
a2263 1
! Now, we use frequency coordinate as sGrid along the path
d2266 6
a2271 14
          
! the input losQty is the increment of cloud transmission function by default.
! it is converted to cloud extinction if extinction flag is on.
   if(extinction) then
   ! both sGrid and sFineGrid are expected to be evenly spaced at present
   ds = sLevel(2)-sLevel(1)  
   do i=1,noDepths
   do j=1,noFineGrid
      Sfine(j+(i-1)*noFineGrid) = sLevel(i)+(j-1._r8)*ds/noFineGrid
   end do
   end do
   
   do maf=1,noMafs
   do mif=1,noMifs
d2273 3
a2275 1
        y_in(i) = los%values(i+(mif-1)*noDepths,maf)/ds  ! convert increments to derivatives
d2277 32
a2308 7
      call InterpolateValues(sLevel,y_in,sFine,TransFine,method='Linear')  
      ! calculate column transmission function by integrating the derivatives on fine grid
      do i=1,noFineGrid*noDepths
      betaFine(i) = 0._r8
        colTrans=0._r8
        do j=1,i
          colTrans=colTrans + transFine(j)*ds/noFineGrid
a2309 2
        colTrans = 1._r8 - colTrans
      if(colTrans > 0.02_r8) betaFine(i)= transFine(i)/colTrans
a2310 2
      ! interpolate betaFine back to the coarser sGrid
      call InterpolateValues(sFine,betaFine,sLevel,beta(:,mif,maf),method='Linear')
d2312 8
a2319 9
   end do
   end do
   
   else
   
   do maf=1,noMafs
   do mif=1,noMifs
      do i=1,noDepths
         beta(i,mif,maf)=los%values(i+(mif-1)*noDepths,maf)
d2321 2
a2322 14
   end do
   end do
   
   end if
      
! initialize quantity
   do j = 1, qty%template%noInstances
   do i = 1, qty%template%noSurfs
   qty%values(i,j)=qty%template%badValue
   cnt(i,j)=0
   out(i,j)=0._r8
   end do 
   end do
   
d2327 6
a2332 6
      if (ptan%values(mif,maf) .gt. -2.5) cycle ! for testing
      ! find altitude of each s grid
      x_in = sLevel**2/2./(re%values(1,maf)*0.001_r8 + zt(mif))
      ! converted to zeta
      x_in = x_in/16. + ptan%values(mif,maf)
      ! find minimum and maximum pressures indices in sGrid
d2334 3
a2336 3
        if (ptan%values(mif,maf) < (outZeta(i)+outZeta(i+1))/2. .and. &
          & ptan%values(mif,maf) > (outZeta(i)+outZeta(i-1))/2.) &
          & minZ = i
d2340 1
a2340 1
        
d2342 3
a2344 3
        if (x_in(noDepths) < (outZeta(i)+outZeta(i+1))/2. .and. &
          & x_in(noDepths) > (outZeta(i)+outZeta(i-1))/2.) &
          & maxZ = i
d2349 3
a2351 3
      ! get phi along path for each mif (phi is in degree)
      y_in = los%template%phi(mif,maf) &
        & - atan(sLevel/(re%values(1,maf)*0.001_r8 + zt(mif)))*180._r8/Pi
d2354 1
a2354 1
           & method='Linear')
d2358 1
a2358 1
           & method='Linear')
d2362 7
a2368 7
          if(phi_out(i) .lt. &     
            & (qty%template%phi(1,j)+qty%template%phi(1,j+1))/2. &
            & .and. phi_out(i) .ge. &  
            & (qty%template%phi(1,j-1)+qty%template%phi(1,j))/2. ) then
            out(i,j)=out(i,j) + beta_out(i)
            cnt(i,j)=cnt(i,j)+1       !  counter
          end if
d2374 1
a2374 1
     where (cnt > 0) qty%values = out/cnt
d2547 3
@


2.84
log
@Exploits visibility of MATH77_ran_pack
@
text
@d156 1
a156 1
       "$Id: Fill.f90,v 2.83 2001/10/16 23:34:05 pwagner Exp $"
d862 1
a862 1
            sourceVectorIndex = decoration(gson)
d864 1
a864 1
            destinationVectorIndex = decoration(gson)
d996 1
a996 1
        & "fraction vector does not have dimensions of length" )
d2389 1
d2544 3
@


2.83
log
@intrinsic, resetseed, seed fields added to addnoise method
@
text
@d59 1
a59 1
  use MLSRandomNumber, only: drang, mls_random_seed
d156 1
a156 1
       "$Id: Fill.f90,v 2.82 2001/10/16 00:07:48 livesey Exp $"
a327 2
    resetSeed = .false.
    switch2intrinsic = .false.
d341 3
d569 1
a569 1
          if ( switch2intrinsic ) call mls_random_seed(MATH77_ranpack=.false.)
a580 1
            seed = 0
d598 6
d2543 3
@


2.82
log
@Got smoothing working.
@
text
@d17 3
a19 2
    & F_INTEGRATIONTIME, F_INTERPOLATE, F_INVERT, F_LENGTHSCALE, F_MATRIX, &
    & F_MAXITERATIONS, F_METHOD,F_MEASUREMENTS, F_MODEL, F_NOFINEGRID, F_PTANQUANTITY, &
d21 2
a22 2
    & F_Rows, F_SCECI, F_SCVEL, F_SOURCE, F_SOURCEGRID, F_SOURCEL2AUX, &
    & F_SOURCEL2GP, F_SOURCEQUANTITY, F_SOURCEVGRID, &
d24 2
a25 2
    & F_SYSTEMTEMPERATURE, F_TEMPERATUREQUANTITY, F_TEMPLATE, F_TNGTECI, F_TYPE, &
    & F_VMRQUANTITY, FIELD_FIRST, FIELD_LAST
d59 1
a59 1
  use MLSRandomNumber, only: drang
d87 1
a87 1
  logical, parameter :: DEEBUG = .TRUE.                 ! Usually FALSE
d156 1
a156 1
       "$Id: Fill.f90,v 2.81 2001/10/15 22:10:42 livesey Exp $"
d267 1
d273 1
d279 1
d328 2
d470 2
d508 2
d519 2
d568 31
d2537 3
@


2.81
log
@Interim version with smoothing stubbed
@
text
@d28 1
a28 1
    & L_COLUMNABUNDANCE, L_ESTIMATEDNOISE, L_EXPLICIT, L_GPH, L_GRIDDED, &
d49 1
d51 1
a51 1
    & Dump, GetKindFromMatrixDatabase, GetFromMatrixDatabase, K_SPD, &
d155 1
a155 1
       "$Id: Fill.f90,v 2.80 2001/10/02 23:12:50 pwagner Exp $"
d907 1
a907 1
    type (Vector_T), dimension(:), intent(in) :: VECTORS ! The vector database
d913 97
a1009 2
    call updateDiagonal ( covariance, vectors(diagonal), square=.true., &
      & invert=invert )
d2494 3
@


2.80
log
@More chi^2 fixes
@
text
@d13 1
a13 1
    & F_COLUMNS, F_DECAY, F_DESTINATION, F_DIAGONAL, F_NOISE, &
d15 1
a15 1
    & F_EXTINCTION, F_H2OQUANTITY, F_LOSQTY,&
d17 2
a18 2
    & F_INTEGRATIONTIME, F_INTERPOLATE, F_INVERT, F_MATRIX, F_MAXITERATIONS, &
    & F_METHOD,F_MEASUREMENTS, F_MODEL, F_NOFINEGRID, F_PTANQUANTITY, &
d23 1
a23 1
    & F_SYSTEMTEMPERATURE, F_TEMPERATUREQUANTITY, F_TNGTECI, F_TYPE, &
d42 1
a42 1
    & PHYQ_Time
d124 1
d127 1
a127 1
  integer, parameter :: N1_is_zero = notImplemented + 1
d154 1
a154 1
       "$Id: Fill.f90,v 2.79 2001/09/28 23:59:20 pwagner Exp $"
a212 1
    integer :: Decay                    ! Index of decay-rate vector in database
d224 1
d235 1
d245 1
d341 20
a360 2
        if ( nsons(key) /= 2 ) call announce_error ( son, wrong_number )
        templateIndex = decoration(decoration(subtree(2,subtree(2,key))))
d362 2
a364 1

d367 1
a367 1
          & qtyTemplates ) ) )
d739 2
a740 1
          call ExplicitFillVectorQuantity ( quantity, valuesNode, spread )
d751 2
d766 4
a769 2
          case ( f_decay )
            decay = gson
a778 3
        ! All the fields are collected.  Now fill the matrix.
        !??? This will need a lot more work when f_decay ???
        !??? and f_superDiagonal are implemented.        ???
d780 2
a781 2
        call updateDiagonal ( covariance, vectors(diagonal), square=.true., &
          & invert=invert )
d900 15
d1942 1
a1942 1
  subroutine ExplicitFillVectorQuantity(quantity, valuesNode, spread)
d1951 1
d1957 1
d1960 2
d1976 1
a1976 1
       if ( (unitAsArray(1) /= quantity%template%unit) .and. &
d1999 1
a1999 1
        if ( (unitAsArray(1) /= quantity%template%unit) .and. &
d2291 2
a2292 1
      call output ( " has inappropriate units for Fill instruction.", advance='yes' )
d2299 2
d2398 3
@


2.79
log
@Fixed various timing problems
@
text
@d85 1
a85 1
  logical, parameter :: DEEBUG = .FALSE.                 ! Usually FALSE
d153 1
a153 1
       "$Id: Fill.f90,v 2.78 2001/09/28 17:50:30 pwagner Exp $"
a337 1
        if (DEEBUG) call output('vector spec', advance='yes')
a349 1
        if (DEEBUG) call output('matrix spec', advance='yes')
a394 1
        if (DEEBUG) call output('Fill instruction', advance='yes')
a407 1
            if (DEEBUG) call output('noise field', advance='yes')
a449 1
            if (DEEBUG) call output('measurements field', advance='yes')
a452 1
            if (DEEBUG) call output('method field', advance='yes')
a454 1
            if (DEEBUG) call output('model field', advance='yes')
d527 2
a528 2
          ! Quantity => GetVectorQtyByTemplateIndex( &
          !  & vectors(VectorIndex), QuantityIndex )
a536 1
          if (DEEBUG) call output('hydrostatic method', advance='yes')
a594 1
          if (DEEBUG) call output('special method', advance='yes')
a726 1
        if (DEEBUG) call output('Fill covariance instruction', advance='yes')
a779 1
        if (DEEBUG) call output('Transfer vector instruction', advance='yes')
d850 3
a852 3
    type (VectorValue_T), intent(out) ::   quantity
    type (VectorValue_T), intent(in) ::    sourceQuantity
    type (VectorValue_T), intent(in) ::    noiseQty
d1237 8
d1344 8
d1459 8
d1740 4
d2352 3
@


2.78
log
@MLSL2Timings module keeps timing info
@
text
@d27 1
a27 1
    & L_CHISQMMAF, L_CHISQMMIF, L_CLOUDICE,L_CHOLESKY, &
d31 1
a31 1
    & L_PRESSURE, L_PTAN, L_RADIANCE, L_EARTHRADIUS, &
d34 1
a34 1
    & L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VGRID, L_VMR, L_ZETA
d39 3
a41 3
  use Intrinsic, only: Field_Indices, Lit_Indices
  use Intrinsic, only: L_CHANNEL, L_INTERMEDIATEFREQUENCY, L_USBFREQUENCY,&
    & L_LSBFREQUENCY, L_MIF, L_MAF, PHYQ_Dimensionless, PHYQ_Invalid, PHYQ_Temperature, &
d45 1
a45 1
  use L2AUXData, only: L2AUXData_T, L2AUXRank
d49 1
a49 1
  use MatrixModule_1, only: AddToMatrixDatabase, ClearMatrix, CreateEmptyMatrix, &
d53 1
a53 1
  use MLSCommon, only: L1BInfo_T, NameLen, LineLen, MLSChunk_T, R8
d65 2
a66 2
  use String_Table, only: Display_String, Get_string
  use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
d68 1
a68 1
  use TREE, only: DECORATE, DECORATION, DUMP_TREE_NODE, NODE_ID, NSONS, &
d70 1
a70 1
  use TREE_TYPES, only: N_NAMED, N_DOT, N_SET_ONE
d153 1
a153 1
       "$Id: Fill.f90,v 2.77 2001/09/24 17:28:15 pwagner Exp $"
a202 1
    type (vectorValue_T), pointer :: colAbundQty
d231 1
a231 1
    integer :: I, J, K                  ! Loop indices for section, spec, expr
a235 1
    integer :: IND                      ! Temoprary index
a242 1
    integer :: L2INDEX                  ! Where source is among l2gp or l2au database
a251 2
    character (LEN=LineLen) ::  Msr
    type (Vector_T) :: NewVector ! A vector we've created
a252 1
    integer :: PREVDEFDQT               !
d298 1
a1562 2
    real (r8) :: Delta_p_0       ! p[j+1] - p[j]
    real (r8) :: Delta_log_0     ! ln p[j+1] - ln p[j]
a2214 6
!   if ( where > 0 ) then
!     call dump_tree_node ( where, 0 )
!   else
!     call output ( '(no lcf node available)' )
!   end if

d2335 3
@


2.77
log
@Gets drang from MLSRandomNumber
@
text
@d54 1
d61 1
a61 1
  use OUTPUT_M, only: OUTPUT
d66 1
a66 1
  use TOGGLES, only: GEN, LEVELS, TOGGLE
d153 1
a153 1
       "$Id: Fill.f90,v 2.76 2001/09/21 23:23:35 pwagner Exp $"
d303 1
a303 1
    timing = .false.
d845 5
d2348 3
@


2.76
log
@Stiff fails to add noise properly
@
text
@d55 2
a56 1
  use MLSNumerics, only: InterpolateValues, drang
d152 1
a152 1
       "$Id: Fill.f90,v 2.75 2001/09/20 20:57:25 pwagner Exp $"
d2342 3
@


2.75
log
@Fleshed out adding noise thing
@
text
@d83 1
d151 1
a151 1
       "$Id: Fill.f90,v 2.74 2001/09/19 23:42:29 pwagner Exp $"
d341 1
d354 1
d400 1
d414 1
d457 1
a457 1
            fillMethod = l_special
d461 1
d464 1
a464 1
            fillMethod = l_special
d528 2
a529 1
        quantity => GetVectorQtyByTemplateIndex(vectors(vectorIndex),quantityIndex)
d533 1
d537 2
a538 2
          Quantity => GetVectorQtyByTemplateIndex( &
            & vectors(VectorIndex), QuantityIndex )
d547 1
d606 1
d739 1
d775 1
d793 1
d1107 1
a1107 1
    !   case where all args present
d1118 1
d1124 9
d1134 25
a1158 1
    aok = .true.
d1160 1
d1162 9
a1170 7
    aok = aok .and. &
      & (qty%template%molecule == measQty%template%molecule) &
      & .and. &
      & (qty%template%molecule == modelQty%template%molecule)
    if ( present(noiseQty) ) aok = aok &
      & .and. &
      & (qty%template%molecule == noiseQty%template%molecule)
d1173 9
a1181 7
    aok = aok .and. &
      & (qty%template%signal == measQty%template%signal) &
      & .and. &
      & (qty%template%signal == modelQty%template%signal)
    if ( present(noiseQty) ) aok = aok &
      & .and. &
      & (qty%template%signal == noiseQty%template%signal)
d1184 21
a1204 19
    aok = aok .and. &
      & DoHgridsMatch( qty, measQty ) &
      & .and. &
      & DoHgridsMatch( qty, modelQty )
    if ( present(noiseQty) ) aok = aok &
      & .and. &
      & DoHgridsMatch( qty, noiseQty )

    ! (4)
    aok = aok .and. &
      & DoVgridsMatch( measqty, modelQty )
    if ( present(noiseQty) ) then
      aok = aok &
      & .and. &
      & DoVgridsMatch( measqty, noiseQty )
    else
      aok = aok &
      & .and. &
      & DoVgridsMatch( measqty, Qty )
d2341 3
@


2.74
log
@New Remove command, ignore() fields
@
text
@d16 1
a16 1
    & F_IGNOREMASK, F_IGNORENEGATIVE, F_IGNOREZERO, &
d55 1
a56 1
  use MLSNumerics, only: InterpolateValues
d150 1
a150 1
       "$Id: Fill.f90,v 2.73 2001/09/18 23:53:08 pwagner Exp $"
d230 4
a233 1
    logical :: ignoreMask, ignoreZero, ignoreNegative
d301 1
a301 1
    ignoreMask = .false.
d426 2
a427 2
          case ( f_ignoreMask )
            ignoreMask = get_boolean ( gson )
d636 1
a636 1
                & ignoreMask, ignoreZero, ignoreNegative )
d651 1
a651 1
                & ignoreMask, ignoreZero, ignoreNegative )
d666 1
a666 1
                & ignoreMask, ignoreZero, ignoreNegative )
d842 2
a843 2
    ! A special fill of chi squared 
    ! broken out according to channels
d846 1
a846 1
    type (VectorValue_T), intent(out) :: quantity
a848 2
    ! The last two are set if only part (e.g. overlap regions) of the quantity
    ! is to be stored in qty
d851 1
a851 1
    real(r8), dimension(:), pointer  ::    VALUES => NULL()
d855 14
d1092 11
a1102 6
    ! Check whether we may proceed with special fill of chi squared 
    type (VectorValue_T), intent(in) :: QTY
    type (VectorValue_T), intent(in) ::    modelQty
    type (VectorValue_T), intent(in) ::    measQty
    type (VectorValue_T), intent(in) ::    noiseQty
    LOGICAL ::                             AOK
d1104 1
a1104 1
    ! What we will check is that:
d1108 2
a1109 1
    ! (4) all but qty (chiSq) have same VGrid
d1117 2
a1118 1
      & (qty%template%molecule == modelQty%template%molecule) &
d1126 2
a1127 1
      & (qty%template%signal == modelQty%template%signal) &
d1133 6
a1138 5
    & DoHgridsMatch( qty, measQty ) &
    & .and. &
    & DoHgridsMatch( qty, modelQty ) &
    & .and. &
    & DoHgridsMatch( qty, noiseQty )
d1142 10
a1151 3
    & DoVgridsMatch( measqty, modelQty ) &
    & .and. &
    & DoVgridsMatch( measqty, noiseQty )
d1158 1
a1158 1
  & ignoreMask, ignoreZero, ignoreNegative, firstInstance, lastInstance )
d1167 1
a1167 1
    logical, intent(in)           ::       ignoreMask  ! Ignore any masked values
d1198 1
a1198 1
      & .not. (ignoreZero .or. ignoreMask) ) then
d1231 1
a1231 1
          & ignoreMask .and. ( &
d1259 1
a1259 1
  & ignoreMask, ignoreZero, ignoreNegative, firstInstance, lastInstance )
d1268 1
a1268 1
    logical, intent(in)           ::       ignoreMask  ! Ignore any masked values
d1297 1
a1297 1
      & .not. (ignoreZero .or. ignoreMask) ) then
d1324 1
a1324 1
      if( .not. (ignoreMask .or. ignoreNegative .or. ignoreZero )) then
d1336 1
a1336 1
          & ignoreMask .and. ( &
d1364 1
a1364 1
  & ignoreMask, ignoreZero, ignoreNegative, firstInstance, lastInstance )
d1373 1
a1373 1
    logical, intent(in)           ::       ignoreMask  ! Ignore any masked values
d1404 1
a1404 1
      & .not. (ignoreZero .or. ignoreMask) ) then
d1437 1
a1437 1
          & ignoreMask .and. ( &
d2287 3
@


2.73
log
@Replaced error field name with noise; began addNoise Fill method
@
text
@d16 1
d36 2
a37 2
  use INIT_TABLES_MODULE, only: S_FILL, S_FILLCOVARIANCE, S_MATRIX, S_SNOOP, &
    & S_TIME, S_TRANSFER, S_VECTOR
d71 2
a72 1
    & GetVectorQtyByTemplateIndex, ValidateVectorQuantity, Vector_T, &
d150 1
a150 1
       "$Id: Fill.f90,v 2.72 2001/09/17 23:12:21 pwagner Exp $"
d230 1
d298 3
d423 6
d632 2
a633 1
                & measQty, modelQty, noiseQty )
d647 2
a648 1
                & measQty, modelQty, noiseQty )
d662 2
a663 1
                & measQty, modelQty, noiseQty )
d760 17
d1127 1
a1127 1
  & firstInstance, lastInstance )
d1136 3
d1152 2
d1166 2
a1167 1
    elseif (any ( noiseQty%values == 0.0) ) then
d1195 2
d1199 15
a1213 5
          values(s) = ( &
          & (measQty%values(qIndex, i) - modelQty%values(qIndex, i)) &
          & / &
          & noiseQty%values(qIndex, i) &
          &  ) ** 2
d1215 5
a1219 1
        qty%values(c, i) = sum(values) / measQty%template%noSurfs
d1228 1
a1228 1
  & firstInstance, lastInstance )
d1237 3
a1247 2
    integer ::                             C           ! Channel loop counter
    integer ::                             S           ! Surface loop counter
d1249 4
a1252 1
    integer ::                             INSTANCELEN
d1265 2
a1266 1
    elseif (any ( noiseQty%values == 0.0) ) then
d1293 1
d1299 27
a1325 1
        qty%values(1, i) = sum(values) / instanceLen
d1333 1
a1333 1
  & firstInstance, lastInstance )
d1342 3
d1358 2
d1372 2
a1373 1
    elseif (any ( noiseQty%values == 0.0) ) then
d1401 2
d1405 15
a1419 5
          values(c) = ( &
          & (measQty%values(qIndex, i) - modelQty%values(qIndex, i)) &
          & / &
          & noiseQty%values(qIndex, i) &
          &  ) ** 2
d1421 5
a1425 1
        qty%values(s, i) = sum(values) / measQty%template%noChans
d2256 3
@


2.72
log
@Fleshed out FillChi.. some more
@
text
@d13 2
a14 2
    & F_COLUMNS, F_DECAY, F_DESTINATION, F_DIAGONAL, F_ERROR, &
    & F_GEOCALTITUDEQUANTITY, F_EARTHRADIUS,F_ERROR, F_EXPLICITVALUES, &
d25 1
a25 1
  use INIT_TABLES_MODULE, only: L_BOUNDARYPRESSURE, L_CHISQCHAN, &
d148 1
a148 1
       "$Id: Fill.f90,v 2.71 2001/09/14 23:34:13 pwagner Exp $"
d202 1
a202 1
    type (vectorValue_T), pointer :: errorQty
d290 2
a291 2
    integer :: errorQtyIndex
    integer :: errorVectorIndex
d400 3
a402 4
          case ( f_error )   ! Only used for diagnostic special fills
            fillMethod = l_special
            errorVectorIndex = decoration(decoration(subtree(1,gson)))
            errorQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
d510 13
d609 1
a609 1
            if ( .not. any(got( (/f_measurements, f_model, f_error/) )) ) then
d617 2
a618 2
              errorQty => GetVectorQtyByTemplateIndex( &
                & vectors(errorVectorIndex), errorQtyIndex)
d620 1
a620 1
                & measQty, modelQty, errorQty )
d623 1
a623 1
            if ( .not. any(got( (/f_measurements, f_model, f_error/) )) ) then
d631 2
a632 2
              errorQty => GetVectorQtyByTemplateIndex( &
                & vectors(errorVectorIndex), errorQtyIndex)
d634 1
a634 1
                & measQty, modelQty, errorQty )
d637 1
a637 1
            if ( .not. any(got( (/f_measurements, f_model, f_error/) )) ) then
d645 2
a646 2
              errorQty => GetVectorQtyByTemplateIndex( &
                & vectors(errorVectorIndex), errorQtyIndex)
d648 1
a648 1
                & measQty, modelQty, errorQty )
d804 22
d1044 1
a1044 1
  function FillableChiSq ( qty, measQty, modelQty, errorQty ) result ( aok )
d1046 1
a1046 1
    type (VectorValue_T), intent(inout) :: QTY
d1049 1
a1049 1
    type (VectorValue_T), intent(in) ::    errorQty
d1066 1
a1066 1
      & (qty%template%molecule == errorQty%template%molecule)
d1074 1
a1074 1
      & (qty%template%signal == errorQty%template%signal)
d1082 1
a1082 1
    & DoHgridsMatch( qty, errorQty )
d1088 1
a1088 1
    & DoVgridsMatch( measqty, errorQty )
d1094 1
a1094 1
  subroutine FillChiSqChan ( key, qty, measQty, modelQty, errorQty, &
d1103 1
a1103 1
    type (VectorValue_T), intent(in) ::    errorQty
d1125 1
a1125 1
    elseif (.not. FillableChiSq ( qty, measQty, modelQty, errorQty ) ) then
d1129 1
a1129 1
    elseif (any ( errorQty%values == 0.0) ) then
d1162 1
a1162 1
          & errorQty%values(qIndex, i) &
d1173 1
a1173 1
  subroutine FillChiSqMMaf ( key, qty, measQty, modelQty, errorQty, &
d1182 1
a1182 1
    type (VectorValue_T), intent(in) ::    errorQty
d1203 1
a1203 1
    elseif (.not. FillableChiSq ( qty, measQty, modelQty, errorQty ) ) then
d1207 1
a1207 1
    elseif (any ( errorQty%values == 0.0) ) then
d1209 1
a1209 1
      & 'A vanishing error filling chi^2 MMAFwise'  )
d1237 1
a1237 1
          & errorQty%values(:, i) &
d1246 1
a1246 1
  subroutine FillChiSqMMif ( key, qty, measQty, modelQty, errorQty, &
d1255 1
a1255 1
    type (VectorValue_T), intent(in) ::    errorQty
d1277 1
a1277 1
    elseif (.not. FillableChiSq ( qty, measQty, modelQty, errorQty ) ) then
d1281 1
a1281 1
    elseif (any ( errorQty%values == 0.0) ) then
d1283 1
a1283 1
      & 'A vanishing error filling chi^2 MMIFwise'  )
d1314 1
a1314 1
          & errorQty%values(qIndex, i) &
d2148 3
@


2.71
log
@Now should allow special fill of chi^2..
@
text
@d148 1
a148 1
       "$Id: Fill.f90,v 2.70 2001/08/03 23:13:52 pwagner Exp $"
d1009 50
d1064 1
d1074 62
d1143 1
d1153 56
d1215 2
a1216 1
    ! broken out according to channels
d1226 62
d2114 3
@


2.70
log
@Began testing; at least now exits normally again
@
text
@d13 2
a14 2
    & F_COLUMNS, F_DECAY, F_DESTINATION, F_DIAGONAL, &
    & F_GEOCALTITUDEQUANTITY, F_EARTHRADIUS, F_EXPLICITVALUES, &
d16 3
a18 3
    & F_INTEGRATIONTIME, F_INTERPOLATE, F_INVERT, F_MAXITERATIONS, &
    & F_MATRIX, F_METHOD, F_NOFINEGRID, F_PTANQUANTITY, F_QUANTITY, &
    & F_RADIANCEQUANTITY, F_RATIOQUANTITY, F_REFGPHQUANTITY, &
d25 2
a26 1
  use INIT_TABLES_MODULE, only: L_BOUNDARYPRESSURE, L_CHOLESKY, &
d148 1
a148 1
       "$Id: Fill.f90,v 2.69 2001/08/02 00:17:06 pwagner Exp $"
d200 3
d286 6
d397 58
d458 9
a466 2
          case ( f_method )   ! How are we going to fill it?
            fillMethod = decoration(gson)
a469 3
          case ( f_tngtECI )              ! For special fill of losVel
            tngtECIVectorIndex = decoration(decoration(subtree(1,gson)))
            tngtECIQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
a479 29
          case ( f_temperatureQuantity ) ! For hydrostatic
            temperatureVectorIndex = decoration(decoration(subtree(1,gson)))
            temperatureQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_h2oQuantity ) ! For hydrostatic
            h2oVectorIndex = decoration(decoration(subtree(1,gson)))
            h2oQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_geocAltitudeQuantity ) ! For hydrostatic
            geocAltitudeVectorIndex = decoration(decoration(subtree(1,gson)))
            geocAltitudeQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_ratioQuantity )      ! For isotope ratio
            ratioVectorIndex = decoration(decoration(subtree(1,gson)))
            ratioQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_radianceQuantity )      ! For estimated noise
            radianceVectorIndex = decoration(decoration(subtree(1,gson)))
            radianceQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_refGPHQuantity ) ! For hydrostatic
            refGPHVectorIndex = decoration(decoration(subtree(1,gson)))
            refGPHQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))    
          case ( f_earthRadius ) ! For losGrid fill
            earthRadiusVectorIndex = decoration(decoration(subtree(1,gson)))
            earthRadiusQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_losQty ) ! For losGrid fill
            losVectorIndex = decoration(decoration(subtree(1,gson)))
            losQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_PtanQuantity ) ! For losGrid fill
            PtanVectorIndex = decoration(decoration(subtree(1,gson)))
            PtanQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_explicitValues ) ! For explicit fill
            valuesNode=subtree(j,key)
a483 18
          case ( f_vmrQuantity )     ! For special fill of columnAbundance
            vmrQtyVctrIndex = decoration(decoration(subtree(1,gson)))
            vmrQtyIndex = decoration(decoration(decoration(subtree(2,gson))))
          case ( f_systemTemperature )
            call expr ( gson , unitAsArray, valueAsArray )
            if ( all (unitAsArray /= (/PHYQ_Temperature, PHYQ_Invalid/) ) ) &
              call Announce_error ( key, badUnitsForSystemTemperature )
            systemTemperature = valueAsArray(1)
          case ( f_integrationTime )
            call expr ( gson , unitAsArray, valueAsArray )
            if ( all (unitAsArray /= (/PHYQ_Time, PHYQ_Invalid/) ) ) &
              call Announce_error ( key, badUnitsForIntegrationtime )
            integrationTime = valueAsArray(1)
          case ( f_maxIterations )      ! For hydrostatic fill
            call expr ( subtree(2,subtree(j,key)), unitAsArray,valueAsArray )
            if ( all(unitAsArray(1) /= (/PHYQ_Dimensionless,PHYQ_Invalid/)) ) &
              & call Announce_error ( key, badUnitsForMaxIterations )
            maxIterations = valueAsArray(1)
d490 14
a503 17
          case ( f_interpolate ) ! For l2gp etc. fill
            if ( node_id(gson) == n_set_one ) then
              interpolate=.TRUE.
            else
              interpolate = decoration(subtree(2,gson)) == l_true
            end if
          case ( f_extinction ) ! For cloud extinction fill
            if ( node_id(gson) == n_set_one ) then
              extinction=.TRUE.
            else
              extinction = decoration(subtree(2,gson)) == l_true
            end if
          case ( f_noFineGrid )      ! For cloud extinction fill
            call expr ( subtree(2,subtree(j,key)), unitAsArray,valueAsArray )
            if ( all(unitAsArray(1) /= (/PHYQ_Dimensionless,PHYQ_Invalid/)) ) &
              & call Announce_error ( key, badUnitsForMaxIterations )
            noFineGrid = valueAsArray(1)
d596 42
d1009 48
d1881 3
@


2.69
log
@Mostly done with column fill; untested
@
text
@d147 1
a147 1
       "$Id: Fill.f90,v 2.68 2001/08/01 00:05:25 dwu Exp $"
a700 5
      if ( ERROR /= 0 ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem with Fill section' )
!        call Announce_error ( key, 0, &
!                          & 'Problem with Fill section (This would be fatal)')
      end if
d703 3
d976 2
d992 2
d1016 3
a1018 1
    elseif ( vmrQty%template%verticalCoordinate /= l_pressure) then
d1020 1
a1020 1
              & 'Fill column abundance, but vmr not on pressure surfs.'  )
d1045 8
d1061 13
a1073 1
      if(vmrQty%template%surfs(1, surfaceInstance) &
d1082 1
a1082 1
         if(vmrQty%template%surfs(surface, surfaceInstance) &
d1093 2
a1094 4
      Delta_p_plus = vmrQty%template%surfs(firstSurface+1, surfaceInstance) - &
      & vmrQty%template%surfs(firstSurface, surfaceInstance)
      Delta_log_plus = log(vmrQty%template%surfs(firstSurface+1, surfaceInstance)) - &
      & log(vmrQty%template%surfs(firstSurface, surfaceInstance))
d1099 2
a1100 4
         Delta_p_plus = vmrQty%template%surfs(surface+1, surfaceInstance) - &
         & vmrQty%template%surfs(surface, surfaceInstance)
         Delta_log_plus = log(vmrQty%template%surfs(surface+1, surfaceInstance)) - &
         & log(vmrQty%template%surfs(surface, surfaceInstance))
d1112 6
d1769 3
@


2.68
log
@remove f_sourceSGrid
@
text
@d147 1
a147 1
       "$Id: Fill.f90,v 2.67 2001/07/31 23:53:37 dwu Exp $"
d948 2
a949 1
  subroutine FillColAbundance ( key, qty, bndPressQty, vmrQty)
d955 13
d970 5
a974 3
    type (VectorValue_T), intent(in) :: bndPressQty
    type (VectorValue_T), intent(in) :: vmrQty

d978 6
a983 4
    integer :: surface
    integer :: instance
    integer :: surfaceInstance
    integer :: firstSurface
d1020 16
d1041 2
a1042 1
   do instance=1, vmrQty%template%noInstances
d1073 1
d1743 3
@


2.67
log
@remove sGrid source
@
text
@d20 1
a20 1
    & F_SOURCEL2GP, F_SOURCEQUANTITY, F_SOURCESGRID, F_SOURCEVGRID, &
d147 1
a147 1
       "$Id: Fill.f90,v 2.66 2001/07/31 23:24:17 pwagner Exp $"
d1426 1
a1426 1
      
d1707 3
@


2.66
log
@column abundance calculation more fleshed out--not tested
@
text
@d147 1
a147 1
       "$Id: Fill.f90,v 2.65 2001/07/30 23:28:38 pwagner Exp $"
a438 2
          case ( f_sourceSGrid )
            vGridIndex=decoration(decoration(gson))
d535 1
a535 1
          if (.not. all(got((/f_sourceSGrid,f_losQty,f_earthRadius,f_PtanQuantity/))))&
d544 1
a544 1
            & Vgrids(vGridIndex), tngtPresQuantity, earthRadiusQty, &
d1372 1
a1372 1
  subroutine FillQuantityFromLosGrid ( key, Qty, LOS, Sgrid, &
a1383 1
    type (VGrid_T), intent(in) :: SGrid
d1399 1
a1399 1
    real (r8), dimension(los%template%noChans) :: x_in, y_in
d1423 1
d1425 1
d1431 1
a1431 1
   ds = sGrid%surfs(2)-sGrid%surfs(1)  
d1434 1
a1434 1
      Sfine(j+(i-1)*noFineGrid) = sGrid%surfs(i)+(j-1._r8)*ds/noFineGrid
d1443 1
a1443 1
      call InterpolateValues(sGrid%surfs,y_in,sFine,TransFine,method='Linear')  
d1455 1
a1455 1
      call InterpolateValues(sFine,betaFine,sGrid%surfs,beta(:,mif,maf),method='Linear')
d1487 1
a1487 1
      x_in = sGrid%surfs**2/2./(re%values(1,maf)*0.001_r8 + zt(mif))
d1509 1
a1509 1
        & - atan(sgrid%surfs/(re%values(1,maf)*0.001_r8 + zt(mif)))*180._r8/Pi
d1707 3
@


2.65
log
@Added columnAbundances scaffolding--needs fleshing out
@
text
@d147 1
a147 1
       "$Id: Fill.f90,v 2.64 2001/07/26 20:33:40 vsnyder Exp $"
d963 12
d981 1
a981 1
              call Announce_error ( key, No_Error_code, &
d984 18
d1004 54
d1708 3
@


2.64
log
@Eliminate the 'extra' field of the 'matrix' spec
@
text
@d12 2
a13 1
  use INIT_TABLES_MODULE, only: F_COLUMNS, F_DECAY, F_DESTINATION, F_DIAGONAL, &
d22 2
a23 1
    & F_SYSTEMTEMPERATURE, F_TEMPERATUREQUANTITY, F_TNGTECI, F_TYPE, FIELD_FIRST, FIELD_LAST
d25 2
a26 1
  use INIT_TABLES_MODULE, only: L_CHOLESKY, L_ESTIMATEDNOISE, L_EXPLICIT, L_GPH, L_GRIDDED, &
d82 2
a83 1
  integer, parameter :: Wrong_Number = 1     ! of fields of a VECTOR command
d147 1
a147 1
       "$Id: Fill.f90,v 2.63 2001/07/20 20:03:30 dwu Exp $"
d196 3
d200 2
d280 2
d384 3
d443 3
d564 12
d949 27
d1624 3
@


2.63
log
@fix problems in cloud extinction calculation
@
text
@d14 1
a14 1
    & F_EXTINCTION, F_EXTRA, F_H2OQUANTITY, F_LOSQTY,&
d143 1
a143 1
       "$Id: Fill.f90,v 2.62 2001/07/20 19:25:03 dwu Exp $"
a203 1
    logical :: Extra                    ! Matrix needs an extra column / row
a321 1
        extra = .false.
a334 2
          case ( f_extra )
            extra = get_boolean(gson)
d343 1
a343 2
              & vectors(rowVector), vectors(colVector), &
              & extra_Row = extra, extra_Col = extra )
d351 1
a351 1
              vectors(colVector), extra_Col = extra )
d355 1
a355 2
              & vectors(colVector), vectors(colVector), &
              & extra_Row = extra, extra_Col = extra )
d1568 3
@


2.62
log
@add cloud extinction calculation
@
text
@d143 1
a143 1
       "$Id: Fill.f90,v 2.61 2001/07/19 21:45:33 dwu Exp $"
d1270 1
a1270 1
    real (r8), dimension(los%template%noSurfs*noFineGrid) :: betaFine, TransFine, SFine
d1297 2
a1298 3

   Sfine(1) = sGrid%surfs(1)
   ds = sGrid%surfs(2)-sGrid%surfs(1) ! both sGrid and sFineGrid are expected to be evenly spaced at present
d1301 1
a1301 1
      Sfine(j+i*noFineGrid) = sGrid%surfs(i)+j*ds/noFineGrid
d1313 1
a1313 1
      betaFine = 0._r8
d1319 1
a1319 1
      if(colTrans > 0.02) betaFine(i)= transFine(i)/colTrans
d1323 1
d1574 3
@


2.61
log
@some fixes for FillQuantityFromLOS
@
text
@d13 2
a14 2
    & F_GEOCALTITUDEQUANTITY, &
    & F_EARTHRADIUS, F_EXPLICITVALUES, F_EXTRA, F_H2OQUANTITY, F_LOSQTY,&
d16 2
a17 2
    & F_MATRIX, F_METHOD, F_PTANQUANTITY, F_QUANTITY, F_RADIANCEQUANTITY, &
    & F_RATIOQUANTITY, F_REFGPHQUANTITY, &
d143 1
a143 1
       "$Id: Fill.f90,v 2.60 2001/07/19 18:05:42 dwu Exp $"
d203 1
d236 1
d290 1
d292 1
d462 11
d535 2
a536 1
            & Vgrids(vGridIndex), tngtPresQuantity, earthRadiusQty, errorCode )
d1241 1
a1241 1
   & Ptan, Re, errorCode )
d1257 2
d1264 1
a1264 1
    integer :: noMAFs, noMIFs, noDepths    
d1270 3
d1280 2
a1281 3
!      & verticalCoordinate= (/ l_pressure, l_zeta /)) ) then
!      errorCode=vectorWontMatchL2GP
!      return
d1289 49
a1338 4
    noMAFs = los%template%noInstances
    noMIFs = los%template%noSurfs
    noDepths = los%template%noChans
    
d1380 2
a1381 4
        ! interpolate quantity to standard vertical grids
        do i=1,noDepths
          y_in = los%values(i+(mif-1)*noDepths,maf)
        end do
d1574 3
@


2.60
log
@add sourceSGRID
@
text
@d143 1
a143 1
       "$Id: Fill.f90,v 2.59 2001/07/19 00:56:27 dwu Exp $"
d1224 1
a1224 1
  subroutine FillQuantityFromLosGrid ( key, Qty, LOS, Vgrid, &
d1236 1
a1236 1
    type (VGrid_T), intent(in) :: VGrid
d1244 3
a1246 2
    integer :: i, j, maf, mif, id                ! Loop counter
    integer :: noMAFs, noMIFs, noDepths
d1248 1
a1250 1
    real (r8), dimension(los%template%noChans) :: sGrid ! losGrid surf values
a1272 2
! get los grid surf values
    sGrid = vGrid%surfs
d1279 1
d1284 2
a1285 2
      zt = -log10(ptan%template%surfs(:,maf))   ! noChans=1 for ptan
      zt = (zt-3.)*16.                      ! converted to height in km
d1287 1
d1289 1
a1289 1
      x_in = sGrid/2./(re%values(1,maf) + zt(mif))
d1291 19
a1309 3
      x_in = x_in/16.-3.
      ! interpolate to get phi along path on the near side of tangent pt.
      ! phi is in degree
d1311 7
a1317 5
        & - atan(sgrid/(re%values(1,maf) + zt(mif)))*180._r8/Pi     
        call InterpolateValues(x_in,y_in,outZeta,phi_out,method='Linear')
        ! interpolate to get values along s
        do id=1,noDepths
          y_in = los%values(id+(mif-1)*noDepths,maf)
d1319 4
a1322 3
        call InterpolateValues(x_in,y_in,outZeta,beta_out,method='Linear')
        ! find geolocation of each s element on the los grid
        do id=1,noDepths  
d1324 1
a1324 1
          if(phi_out(id) .lt. &     
d1326 1
a1326 1
            & .and. phi_out(id) .ge. &  
d1328 1
a1328 2
            do i = 1, qty%template%noSurfs
            qty%values(i,j)=qty%values(i,j) + beta_out(id)
a1329 1
            end do
d1336 2
a1337 2
    where (cnt > 0) qty%values = qty%values/cnt
    
d1511 3
@


2.59
log
@fix bugs in FillQuantityFromLos
@
text
@d19 2
a20 1
    & F_SOURCEL2GP, F_SOURCEQUANTITY, F_SOURCEVGRID, F_SPREAD, F_SUPERDIAGONAL, &
d143 1
a143 1
       "$Id: Fill.f90,v 2.58 2001/07/19 00:19:42 dwu Exp $"
d427 2
d511 1
a511 1
          if (.not. all(got((/f_sourceVgrid,f_losQty,f_earthRadius,f_PtanQuantity/))))&
d1493 3
@


2.58
log
@add new method=rectanglefromlos
@
text
@d63 1
d142 1
a142 1
       "$Id: Fill.f90,v 2.57 2001/06/22 05:37:27 livesey Exp $"
d1242 2
a1243 1
    integer :: noMAFs, noMIFs, noDepths 
d1276 1
a1276 1
   qty%mask(i,j)=0
d1288 4
a1291 4
        ! interpolate to get phi along s
        do id=1,noDepths
          y_in(id) = los%template%phi(id+(mif-1)*noDepths,maf)
        end do
d1307 1
a1307 1
            qty%mask(i,j)=qty%mask(i,j)+1       ! use quantity mask as counter
d1315 1
a1315 1
    where (qty%mask > 0) qty%values = qty%values/qty%mask
d1490 3
@


2.57
log
@First version of transfer command
@
text
@d13 2
a14 1
    & F_GEOCALTITUDEQUANTITY, F_EXPLICITVALUES, F_EXTRA, F_H2OQUANTITY, &
d16 1
a16 1
    & F_MATRIX, F_METHOD, F_QUANTITY, F_RADIANCEQUANTITY, &
d24 3
a26 2
    & L_LOSVEL, L_NONE, L_PLAIN, &
    & L_PRESSURE, L_PTAN, L_RADIANCE, L_REFGPH, L_SCECI, L_SCGEOCALT, L_SCVEL, &
d106 2
a107 1
  integer, parameter :: CantInterpolate3d = badIsotopeFill + 1
d141 1
a141 1
       "$Id: Fill.f90,v 2.56 2001/06/13 20:41:35 vsnyder Exp $"
d187 3
d196 2
d221 3
a223 1
    integer :: L2INDEX                  ! Where source is among l2gp or l2aux database
d234 2
d411 10
a420 1
            refGPHQuantityIndex = decoration(decoration(decoration(subtree(2,gson))))
d506 12
d1219 98
d1324 1
a1324 1
    integer :: DUMMY                    ! Dummy integer
d1373 2
d1488 3
@


2.56
log
@Make sure 'invert' has a value
@
text
@d12 1
a12 1
  use INIT_TABLES_MODULE, only: F_Columns, F_Decay, F_Diagonal, &
d29 1
a29 1
    & S_TIME, S_VECTOR
d138 1
a138 1
       "$Id: Fill.f90,v 2.55 2001/05/30 23:56:39 livesey Exp $"
d188 1
d595 19
d1186 24
d1355 3
@


2.55
log
@Changed for new L1BData
@
text
@d138 1
a138 1
       "$Id: Fill.f90,v 2.54 2001/05/30 20:16:26 vsnyder Exp $"
d560 1
d1311 3
@


2.54
log
@Add 'invert' field to 'fillCovariance' spec
@
text
@d138 1
a138 1
       "$Id: Fill.f90,v 2.53 2001/05/23 04:38:16 livesey Exp $"
d1160 1
a1160 1
    call DeallocateL1BData(l1bData,flag)
d1310 3
@


2.53
log
@Changes chunks to pointer rather than intent(in), so it gets the right indices
@
text
@d14 2
a15 2
    & F_INTEGRATIONTIME, F_INTERPOLATE, F_MAXITERATIONS, F_MATRIX, F_METHOD, &
    & F_QUANTITY, F_RADIANCEQUANTITY, &
d138 1
a138 1
       "$Id: Fill.f90,v 2.52 2001/05/19 00:15:39 livesey Exp $"
d208 1
d576 2
d585 2
d588 2
a589 1
        call updateDiagonal ( covariance, vectors(diagonal), square=.true. )
d1310 3
@


2.52
log
@OK, that should have been square!!! (fool!)
@
text
@d138 1
a138 1
       "$Id: Fill.f90,v 2.51 2001/05/19 00:13:41 livesey Exp $"
d168 1
a168 1
    type (mlSChunk_T), dimension(:), intent(in) :: Chunks
d1304 3
@


2.51
log
@Made fillcovariance apply square root option to update diagonal
@
text
@d138 1
a138 1
       "$Id: Fill.f90,v 2.50 2001/05/18 22:39:45 livesey Exp $"
d583 1
a583 1
        call updateDiagonal ( covariance, vectors(diagonal), squareRoot=.true. )
d1304 3
@


2.50
log
@Bug fix.
@
text
@d138 1
a138 1
       "$Id: Fill.f90,v 2.49 2001/05/18 19:50:50 livesey Exp $"
d583 1
a583 1
        call updateDiagonal ( covariance, vectors(diagonal) )
d1304 3
@


2.49
log
@Added interpolate option for l2gp fills
@
text
@d138 1
a138 1
       "$Id: Fill.f90,v 2.48 2001/05/16 19:44:16 livesey Exp $"
d708 13
a720 11
    if ( quantity%template%verticalCoordinate == l_pressure ) then
      if ( any(ABS(-LOG10(quantity%template%surfs(:,1))+ &
        & LOG10(l2gp%pressures)) > TOLERANCE) .and. (.not. interpolate) ) then
        errorCode=vectorWontMatchL2GP
        return
      end if
    else                                ! Must be l_zeta
      if ( any(ABS(quantity%template%surfs(:,1)+ &
        & LOG10(l2gp%pressures)) > TOLERANCE) .and. (.not. interpolate) ) then
        errorCode=vectorWontMatchL2GP
        return
d753 1
a753 1
    if (interpolate) then
d1304 3
@


2.48
log
@Added estimated noise stuff
@
text
@d14 1
a14 1
    & F_INTEGRATIONTIME, F_MAXITERATIONS, F_MATRIX, F_METHOD, &
d48 1
d104 1
d107 1
a107 1
  integer, parameter :: NotSPD = BadIsotopeFill + 1
d138 1
a138 1
       "$Id: Fill.f90,v 2.47 2001/05/10 23:25:12 livesey Exp $"
d206 1
d270 2
a271 1
    spread=.FALSE.
d425 6
d531 1
a531 1
            & ( quantity, l2gpDatabase(l2gpIndex), errorCode )
d668 1
a668 1
  subroutine FillVectorQuantityFromL2GP(quantity,l2gp, errorCode)
d676 1
d685 3
d703 1
a703 1
    if ( quantity%template%noSurfs /= l2gp%nLevels ) then
d710 1
a710 1
        & LOG10(l2gp%pressures)) > TOLERANCE) ) then
d716 1
a716 1
        & LOG10(l2gp%pressures)) > TOLERANCE) ) then
d746 24
a769 3
    quantity%values=RESHAPE(l2gp%l2gpValue(:,:,firstProfile:lastProfile),&
      & (/quantity%template%noChans*quantity%template%noSurfs,&
      &   quantity%template%noInstances/))
d1209 2
d1280 2
a1281 1
      call output ( " command found no match of vetor and L2GP.", advance='yes' )
d1302 3
@


2.47
log
@Added isotope scaling stuff, tidied up some old code.
@
text
@d14 3
a16 1
    & F_MAXITERATIONS, F_Matrix, F_METHOD, F_QUANTITY, F_RATIOQUANTITY, F_REFGPHQUANTITY, &
d18 2
a19 2
    & F_SOURCEL2GP, F_SOURCEQUANTITY, F_SOURCEVGRID, F_SPREAD, F_SuperDiagonal, &
    & F_TEMPERATUREQUANTITY, F_TNGTECI, F_TYPE, FIELD_FIRST, FIELD_LAST
d21 1
a21 1
  use INIT_TABLES_MODULE, only: L_CHOLESKY, L_EXPLICIT, L_GPH, L_GRIDDED, &
d33 2
a34 1
    & L_LSBFREQUENCY, L_MIF, L_MAF, PHYQ_Dimensionless, PHYQ_Invalid
d100 3
a102 1
  integer, parameter :: BadIsotopeFill = badUnitsForExplicit + 1
d136 1
a136 1
       "$Id: Fill.f90,v 2.46 2001/05/08 20:34:26 vsnyder Exp $"
d171 1
d174 1
a174 1
    type (VectorValue_T), pointer :: QUANTITY ! Quantity to be filled
d203 1
d220 2
d234 2
a235 2
    logical :: SPREAD           ! Do we spread values accross instances in explict
    integer :: SuperDiagonal            ! Index of superdiagonal matrix in database
d237 1
d388 3
d400 10
d530 6
d809 48
d1164 4
d1264 3
@


2.46
log
@Cosmetic changes
@
text
@d14 1
a14 1
    & F_MAXITERATIONS, F_Matrix, F_METHOD, F_QUANTITY, F_REFGPHQUANTITY, &
d20 2
a21 1
    & L_HYDROSTATIC, L_KRONECKER, L_L1B, L_L2GP, L_L2AUX, L_LOSVEL, L_NONE, L_PLAIN, &
d37 1
d97 1
d100 1
a100 1
  integer, parameter :: NotSPD = badUnitsForExplicit + 1
d131 1
a131 1
       "$Id: Fill.f90,v 2.45 2001/05/03 20:30:29 vsnyder Exp $"
d169 1
d173 1
a210 1
!    INTEGER :: OL2FileHandle
d213 2
d375 3
d440 10
a588 100
  !=============================== FillVector ==========================
  subroutine FillVector ( errorCode, inArray, Vector, arrayType, vectorType, &
    & NumQtys, numChans, numSurfs, numInstances, qtiesStart, dim_order )
    !=============================== FillVector ==========================

    ! Fill the vector Vector with values taken from the array inArray
    ! in a manner that depends on their respective types:

    !        arrayType        vectorType            operation
    !          l2gp              l2gp       vector(:,:,:) = inArray(:,:,:)

    ! It is assumed that the rank3 inArray is filled from
    ! inArray(1, 1, 1) to inArray(numChans, numSurfs, numInstances)

    ! With the redefinition of Vector%quantities to be a rank2 object
    ! we are faced with a problem: how to fill a rank 2 object from a rank 3 one?
    ! If the rank 3 object is full, then it use the following trick:
    ! Vector(1:numChans*numSurfs, 1:numInstances) = 
    !                   inArray(1:numChans, 1:numSurfs, 1:numInstances)

    character (Len=*), intent(IN) ::        arrayType, vectorType
    integer, intent(OUT) ::                 errorCode		! zero unless an error
    ! REAL(r8), POINTER, DIMENSION(:,:,:) ::  inPointer
    real(r8), dimension(:,:,:) ::           inArray
    type(Vector_T), intent(OUT) ::          Vector
    integer, intent(IN) ::                  NumQtys, qtiesStart
    integer, intent(IN) ::                  numInstances, numSurfs, numChans
    integer, intent(IN), optional, dimension(:) :: dim_order

    ! Private
    character (LEN=LineLen) ::              msr
    integer ::                              qty
    character (LEN=4) ::                    qtyChar, errorCodeChar

    ! Sanity checks:
    if ( numChans.eq.0 ) then
      !	call announce_error ( ErrorInFillVector, numChansisZero )
      errorCode = numChansisZero
      return
    else if ( numSurfs.eq.0 ) then
      !	call announce_error ( ErrorInFillVector, numSurfsisZero )
      errorCode = numSurfsisZero
      return
    else if ( numInstances.eq.0 ) then
      !	call announce_error ( ErrorInFillVector, numInstancesisZero )
      errorCode = numInstancesisZero
      return
    end if

    Vector%template%NoQuantities = NumQtys
    select case (arrayType(:4) // VectorType(:4))
    case ('l2gpl2gp')
      do qty = qtiesStart, qtiesStart - 1 + NumQtys
        write(qtyChar, '(I4)') qty
        Vector%quantities(qty)%template%noChans = numChans
        Vector%quantities(qty)%template%noSurfs = numSurfs
        Vector%quantities(qty)%template%noInstances = numInstances    
        !     CALL put_3d_view(inPointer, &
        !        & numChans, &
        !        & numSurfs, &
        !        & numInstances, &
        !        & Vector%quantities(qty)%values)
        !     Vector%quantities(qty)%values = inPointer
        !	if ( numChans.EQ.1 ) then
        !        	Vector%quantities(qty)%values = inPointer(:, :, 1)
        !	else if ( numSurfs.EQ.1 ) then
        !        	Vector%quantities(qty)%values = inPointer(:, 1, :)
        !	else if ( numInstances.EQ.1 ) then
        !        	Vector%quantities(qty)%values = inPointer(1, :, :)
        !        ELSE
        !		call announce_error ( ErrorInFillVector, objIsFullRank3 )
        !       		RETURN
        !	end if
	call squeeze(errorCode, inArray, Vector%quantities(qty)%values)
        !     WRITE(errorCodeChar, '(I4)') errorCode
        !     msr = 'Error #' // errorCodeChar // ' in squeezing l2gp into quantity ' // qtyChar
        !     if ( errorCode /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
        !        & msr)
      end do
    case ('l2aul2au')
      do qty = qtiesStart, qtiesStart - 1 + NumQtys
        write(qtyChar, '(I4)') qty
        Vector%quantities(qty)%template%noChans = numChans
        Vector%quantities(qty)%template%noSurfs = numSurfs
        Vector%quantities(qty)%template%noInstances = numInstances
        if ( present(dim_order) ) then
          call squeeze(errorCode, inArray, Vector%quantities(qty)%values, dim_order)
        else    
          call squeeze(errorCode, inArray, Vector%quantities(qty)%values)
        end if
        !     WRITE(errorCodeChar, '(I4)') errorCode
        !     msr = 'Error #' // errorCodeChar // ' in squeezing l2aux into quantity ' // qtyChar
        !     if ( errorCode /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
        !        & msr)
      end do
    case default
      ! FillVector not yet written to handle these cases
    end select

  end subroutine FillVector
d590 1
a590 1
  !=============================== FillOL2GPVector ==========================
d628 1
a628 1
  !=============================== FillOL2GPVector ==========================
d867 1
a867 20
  !=============================== FillPrevDefd ==========================
  subroutine FillPrevDefd(OldVector, PrevDefdQt, qtyTemplates, &
    & Output, QuantityName, qtiesStart, chunkNo, errorCode)
    !=============================== FillPrevDefd ==========================

    ! If the times, pressures, and geolocations match,
    ! fill the vector Output with values taken from the appropriate quantity in
    ! previously defined vector OldVector
    ! 

    integer, intent(IN) ::                            PrevDefdQt
    integer, intent(IN) ::                            qtiesStart
    type(Vector_T), intent(IN) ::                     OldVector
    type (QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
    type(Vector_T), intent(INOUT) ::                  Output
    character*(*), intent(IN) ::                      QuantityName
    ! If done chunk-by-chunk, the following is the chunk number
    ! Otherwise, chunkNo should = -1
    integer, intent(in) ::                        chunkNo
    integer, intent(OUT) ::                            errorCode	! if error
d869 4
a872 2
    ! Local variables
    !::::::::::::::::::::::::: LOCALS :::::::::::::::::::::
d874 4
a877 132
    real(r8) ::                                       TOLERANCE
    parameter(TOLERANCE=0.05)

    ! A wrong version compared ChunkNo to OldVector%ChunkNumbers
    logical ChunkNumberIsTrustworthy
    parameter(ChunkNumberIsTrustworthy=.false.)

    type (QuantityTemplate_T) ::                      PDQTemplate	! Prev. def'd Quantity Template
    type (QuantityTemplate_T) ::                      OQTemplate	! Output Quantity Template
    integer ::                                        i
    integer ::                                        firstProfile, lastProfile
    integer ::                                        noL2GPValues=1
    logical ::                                        TheyMatch
    real(r8) ::                                       phiMin, phiMax
    real(r8) ::                                       phi_TOLERANCE

    PDQTemplate = qtyTemplates(OldVector%TEMPLATE%QUANTITIES(PrevDefdQt))
    OQTemplate = qtyTemplates(Output%TEMPLATE%QUANTITIES(qtiesStart))

    if ( OQTemplate%noInstances <= 0 ) then
      errorCode=zeroProfilesFound
      return
    else if ( PDQTemplate%noInstances <= 0 ) then
      errorCode=zeroProfilesFound
      return
    end if
    ! Chunk-by-chunk, or all chunks at once?
    if ( chunkNo == -1 ) then
      firstProfile = 1
      lastProfile = PDQTemplate%noInstances
    else if ( ChunkNumberIsTrustworthy ) then
      !	lastProfile = 1
      !   firstProfile = PDQTemplate%noInstances
      !	DO i=1, PDQTemplate%noInstances
      !        	if ( chunkNo == OldVector%chunkNumber(i) ) then
      !				firstProfile = MIN(firstProfile, i)
      !				lastProfile = MAX(lastProfile, i)
      !         end if
      !   end do
      !Can't get here unless ChunkNumberIsTrustworthy has been reset
      call announce_error ( 0, miscellaneous_err, &
	& "Programming error in Module Fill, SUBROUTINE FillPrevDefd " &
	& // "ChunkNumberIsTrustworthy must be FALSE" )
    else
      ! Instead of comparing OldVector%chunkNumbers to ChunkNo
      ! we will compare geodetic angles to phi
      phiMin = OQTemplate%phi(1, 1)
      phiMax = OQTemplate%phi(1, 1)
      do i=1, OQTemplate%noInstances
        phiMin = min(phiMin, OQTemplate%phi(1, i))
        phiMax = max(phiMax, OQTemplate%phi(1, i))
      end do
      phi_TOLERANCE = TOLERANCE *(phiMax-phiMin) / OQTemplate%noInstances
      if ( phi_TOLERANCE <= 0.D0 ) then
        errorCode=zeroGeodSpan
        return
      end if
      lastProfile = 1
      firstProfile = PDQTemplate%noInstances
      do i=1, PDQTemplate%noInstances
        if ( phiMin <= (PDQTemplate%phi(1, i) + phi_TOLERANCE) ) then
          firstProfile = min(firstProfile, i)
        end if
        if ( phiMax >= (PDQTemplate%phi(1, i) - phi_TOLERANCE) ) then
          lastProfile = max(lastProfile, i)
        end if
      end do
    end if

    TheyMatch = OQTemplate%noInstances .eq. (lastProfile-firstProfile+1)
    TheyMatch = TheyMatch &
      & .and. &
      & (OQTemplate%stacked .eqv. PDQTemplate%stacked) &
      & .and. &
      & (OQTemplate%coherent .eqv. PDQTemplate%coherent) &
      & .and. &
      & (OQTemplate%regular .eqv. PDQTemplate%regular) 
    if ( TheyMatch ) then
      do i = firstProfile, lastProfile
        if ( &
          &   nearBy(PDQTemplate%geodLat(1,i), OQTemplate%geodLat(1,i)) &
          & .and. &
          &   nearBy(PDQTemplate%lon(1,i), OQTemplate%lon(1,i)) &
          & .and. &
          &   nearBy(PDQTemplate%solarTime(1,i), OQTemplate%solarTime(1,i)) &
          & ) then
        else
          TheyMatch = .false.
          exit
        end if
      end do
    end if
    if ( TheyMatch &
      & .and. &
      & PDQTemplate%noSurfs == OQTemplate%noSurfs &
      & .and. &
      & PDQTemplate%noSurfs == 1 ) then
      do i = 1, OQTemplate%noSurfs
        if ( &
          &   nearBy(PDQTemplate%surfs(i,1), OQTemplate%surfs(i,1)) &
          & ) then
        else
          TheyMatch = .false.
          exit
        end if
      end do
    end if
    if ( TheyMatch ) then
      Output%quantities(qtiesStart)%values = OldVector%quantities(PrevDefdQt)%values
    else
      errorCode=vectorWontMatchPDef
    end if
  end subroutine FillPrevDefd

  !=============================== FillOL2AUXVector ==========================
  subroutine FillOL2AUXVector(OldL2AUXData, qtyTemplates, &
    & Output, QuantityName, qtiesStart, chunkNo, errorCode)
    !=============================== FillOL2AUXVector ==========================

    ! If the times, pressures, and geolocations match,
    ! fill the vector Output with values taken from the
    ! Old L2AUX vector OldL2AUXData
    ! 

    integer, intent(IN) ::                            qtiesStart
    type(L2AUXData_T) ::                               OldL2AUXData
    type (QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
    !TYPE(L2GPData_T), DIMENSION(:), POINTER ::        L2GPDatabase
    type(Vector_T), intent(INOUT) ::                  Output
    character*(*), intent(IN) ::                      QuantityName
    integer, intent(in) :: chunkNo
    integer, intent(OUT) ::                            errorCode	! if error
d880 1
a880 47
    !::::::::::::::::::::::::: LOCALS :::::::::::::::::::::
    type (QuantityTemplate_T) ::                      OQTemplate	! Output Quantity Template
    integer ::                                        OQType	! Ouptut quantity type
    integer ::                                        OQNVals	! No. Ouptut quantity vals
    integer ::                                        ChanDim	! which dim no. is channel
    integer ::                                        IntFreqDim	! which dim no. is int. frq.
    integer ::                                        USBDim	! which dim no. is USB
    integer ::                                        LSBDim	! which dim no. is LSB
    integer ::                                        MAFDim	! which dim no. is MAF
    integer ::                                        MIFDim	! which dim no. is MIF
    integer ::                                        L2NVals	! No. l2 aux vals
    integer ::                                        i
    logical ::                                        TheyMatch
    ! This will let us re-order the vector dimensions differently from the l2aux
    integer, dimension(3) ::                          dim_order

    ! Properties of Output Vector
    OQTemplate = qtyTemplates(Output%TEMPLATE%QUANTITIES(qtiesStart))
    OQType = OQtemplate%quantityType
    OQNVals = OQtemplate%noInstances*OQtemplate%noSurfs*OQtemplate%noChans

    ! Properties of l2 aux
    ChanDim = 0
    IntFreqDim = 0
    USBDim = 0
    LSBDim = 0
    MAFDim = 0
    MIFDim = 0
    L2NVals = 1
    do i=1, L2AUXRank
      L2NVals = L2NVals*OldL2AUXData%dimensions(i)%noValues
      select case(OldL2AUXData%dimensions(i)%dimensionFamily)
      case(L_Channel)
        ChanDim = i
        dim_order(1) = i
      case(L_IntermediateFrequency)
        IntFreqDim = i
      case(L_USBFrequency)
        USBDim = i
      case(L_LSBFrequency)
        LSBDim = i
      case(L_MIF)
        MIFDim = i
      case(L_MAF)
        MAFDim = i
      case DEFAULT	! We are not yet interested in these dimensions
      end select
d882 1
a882 11
    end do

    ! Check that the dimensions match up and are of the same family
    TheyMatch = OQNVals == L2NVals
    if ( OQTemplate%minorFrame ) then
      TheyMatch = TheyMatch .and. MIFDim > 0
    end if
    if ( OQTemplate%noChans > 0 ) then
      TheyMatch = TheyMatch .and. &
        & (  ChanDim > 0   )
    end if
d884 35
a918 11
    if ( TheyMatch ) then
      call FillVector(errorCode, OldL2AUXData%values, Output, &
        & 'l2aux', 'l2aux', 1, &
        & max(OldL2AUXData%dimensions(1)%noValues, 1), &
        & max(OldL2AUXData%dimensions(2)%noValues, 1), &
        & max(OldL2AUXData%dimensions(3)%noValues, 1), &
        & qtiesStart)
    else
      !   CALL MLSMessage(MLSMSG_Error, ModuleName, &
      !        & 'Vector and old L2AUX do not match')
      errorCode=cantFillFromL2AUX
d921 1
a921 1
  end subroutine FillOL2AUXVector
d923 2
a1044 154
  !=============================== nearby ==========================
  function nearby(x, y, inRelSmall, inOverallTol)
    !=============================== nearby ==========================
    ! This functions returns TRUE if x and y are "nearby" comparing either
    ! their relative difference (proportionally small) 
    ! or their differences with an overall tolerance
    real(r8), intent(IN) ::              x, y
    real(r8), intent(IN), optional ::    inRelSmall
    real(r8), intent(IN), optional ::    inOverallTol

    ! result
    logical ::                           nearby

    ! Private
    real(r8) ::                          small=1.D-32
    real(r8) ::                          tolerance=0.D0

    if ( present(inRelSmall) ) then
      small = inRelSmall
    end if

    if ( present(inOverallTol) ) then
      tolerance = inOverallTol
    end if

    if ( abs(x-y) <= tolerance ) then
      nearby = .true.
    else if ( x*y /= 0 ) then
      nearby = abs(x-y) .lt. small*sqrt(abs(x))*sqrt(abs(y))
    else if ( x /= 0 ) then
      nearby = abs(x-y) .lt. small*abs(x)
    else
      nearby=.true.
    end if

  end function nearby

  !=============================== whatQuantityNumber ==========================
  function WhatQuantityNumber ( X, Y, XVectorTemplate )
    !=============================== whatQuantityNumber ==========================
    ! This functions returns the quantity number of quantity y in vector x
    ! where x and y are sub-rosa indexes of their actual names;
    ! i.e., they are specified in the cf as name[x].name[y]
    ! where name[x] = get_char(x), name[y] = get_char[y]

    ! If the quantity is not found, it returns FAILED (-1)
    integer, intent(IN) ::               X, Y
    type (VectorTemplate_T)  ::          XVectorTemplate

    ! result
    integer ::                           WhatQuantityNumber

    ! Private
    integer, parameter ::                FAILED = -1
    integer              ::              Qty

    whatQuantityNumber = FAILED
    do qty = 1, xVectorTemplate%NoQuantities
      if ( xVectorTemplate%Name == y ) then
        whatQuantityNumber = qty
        exit
      end if
    end do

  end function WhatQuantityNumber

  !=============================== squeeze ==========================
  subroutine Squeeze ( ErrorCode, Source, Sink, Source_order )
    !=============================== squeeze ==========================
    ! takes a rank 3 object source and returns a rank2 object sink
    ! source(1..n1, 1..n2, 1..n3) -> sink(1..n1*n2, 1..n3)
    ! unless it can't--then it returns errorCode /= 0
    ! One reason it may fail: shape of sink too small

    ! Assuming that shape(source) = {n1, n2, n3}
    !     =>          shape(sink) = {m1, m2}
    ! then we must further assume (else set errorCode)
    ! n1*n2 <= m1
    ! n3 <= m2

    ! if source_order is present, it is a permutation of (1 2 3)
    ! such that before squeezing, the source is re-ordered:
    ! temp(1, 2, 3) = source(order(1), order(2), order(3))
    ! and then
    ! temp(1..n1, 1..n2, 1..n3) -> sink(1..n1*n2, 1..n3)

    ! (A future improvement might take as optional arguments
    !  integer arrays source_shape, sink_shape, 
    !  or else shape-params n1, n2, m1)
    !--------Argument--------!
    real(r8), dimension(:,:,:), intent(in) :: Source
    real(r8), dimension(:,:), intent(out)  :: Sink
    integer, intent(out)                   :: ErrorCode
    integer, intent(in), optional, dimension(:) :: Source_order

    !----------Local vars----------!

    integer, dimension(4) :: Source_shape
    integer, dimension(4) :: Sink_shape
    integer, dimension(4) :: Temp_shape
    integer :: I, Icode, Offset
    real(r8), dimension(:,:,:), allocatable :: Temp
    !----------Executable part----------!
    source_shape(1:3) = shape(source)
    sink_shape(1:2) = shape(sink)

    if ( source_shape(1) == 0 ) then
      errorCode = n1_is_zero
      return
    else if ( source_shape(2) == 0 ) then
      errorCode = n2_is_zero
      return
    else if ( source_shape(3) == 0 ) then
      errorCode = n3_is_zero
      return
    else if ( sink_shape(1) < source_shape(1)*source_shape(2) ) then
      errorCode = m1_too_small
      return
    else if ( sink_shape(2) < source_shape(3) ) then
      errorCode = m2_too_small
      return
    else
      errorCode = 0
    end if

    if ( present(source_order) ) then
      !        Check that source_order is a legal permutation of (1 2 3)
      !        using trick: sum and product must each equal 6
      if ( source_order(1)+source_order(2)+source_order(3) /= 6 &
        & .or. &
        & source_order(1)*source_order(2)*source_order(3) /= 6 ) then
        errorCode = not_permutation
        return
      end if
      temp_shape(1:3) = source_shape(source_order(1:3))
      allocate ( temp(temp_shape(1), temp_shape(2), temp_shape(3)), &
        & STAT=errorCode )
      if ( errorCode /= 0 ) then
        errorCode = allocation_err
        return
      end if
      temp = reshape(source, temp_shape(1:3), order=source_order(1:3))
      sink = reshape(temp, sink_shape(1:2))
      deallocate ( temp, STAT=errorCode )
      if ( errorCode /= 0 ) then
        errorCode = deallocation_err
        return
      end if
    else
      sink = reshape(source, sink_shape(1:2))
    end if

  end subroutine Squeeze

d1079 2
d1183 3
@


2.45
log
@Add a 'nullify' and some cosmetic changes
@
text
@d12 5
a16 4
  use INIT_TABLES_MODULE, only: F_Columns, F_GEOCALTITUDEQUANTITY, &
    & F_EXPLICITVALUES, F_H2OQUANTITY, F_MAXITERATIONS, F_METHOD, F_QUANTITY, &
    & F_REFGPHQUANTITY, F_Rows, F_SCECI, F_SCVEL, F_SOURCE, F_SOURCEGRID, &
    & F_SOURCEL2AUX, F_SOURCEL2GP, F_SOURCEQUANTITY, F_SOURCEVGRID, F_SPREAD, &
d25 2
a26 1
  use INIT_TABLES_MODULE, only: S_FILL, S_MATRIX, S_SNOOP, S_TIME, S_VECTOR
d28 3
a30 2
  use Intrinsic, only: Lit_Indices
  !??? will be added
d36 4
a39 3
  use MatrixModule_1, only: AddToMatrixDatabase, CreateEmptyMatrix, &
    & Dump, Matrix_Cholesky_T, Matrix_Database_T, Matrix_Kronecker_T, &
    & Matrix_SPD_T, Matrix_T
d44 1
a44 1
  use MoreTree, only: Get_Field_ID, Get_Spec_ID
d47 2
a57 4
  use ScanModelModule, only: GetBasisGPH, GetHydrostaticTangentPressure, OMEGA
  use Intrinsic, only: L_CHANNEL, L_INTERMEDIATEFREQUENCY, L_USBFREQUENCY,&
    & L_LSBFREQUENCY, L_MIF, L_MAF, PHYQ_Dimensionless, PHYQ_Invalid
  use SnoopMLSL2, only: SNOOP
d69 2
a70 2
  integer, parameter :: WRONG_NUMBER = 1     ! of fields of a VECTOR command
  integer, parameter :: UnknownQuantityName = WRONG_NUMBER + 1
d82 1
a82 1
  ! more Error codes relating to FillVector
d96 4
d101 1
a101 1
  integer, parameter :: N1_is_zero = badUnitsForExplicit + 1
d110 1
a110 1
  ! miscellaneous
d128 1
a128 1
       "$Id: Fill.f90,v 2.44 2001/04/28 01:43:21 vsnyder Exp $"
d173 5
d179 1
d181 1
d201 1
d220 3
a222 1
    real :: T1, T2              ! for timing
d270 1
a270 1
      case ( s_vector )
d282 2
a283 1
      case ( s_matrix )
d286 1
a286 1
        do j=2,nsons(key)
d290 2
a291 1
          gson = decoration(subtree(2,gson)) ! The field's value
d294 1
a294 1
            colVector = decoration(gson)
d296 3
a298 1
            rowVector = decoration(gson)
d300 1
a300 1
            matrixType = gson
d303 1
a303 1
        if ( got(f_columns) .and. got(f_rows) ) then
d307 2
a308 1
              & vectors(rowVector), vectors(colVector) )
d316 1
a316 1
              vectors(colVector) )
d320 2
a321 1
              & vectors(rowVector), vectors(colVector) )
d325 1
a325 1
          call announce_error ( missingField, key, &
d329 1
a329 1
      case ( s_fill )
d333 1
a333 1
        do j=2,nsons(key)
d335 1
a335 1
          fieldIndex=get_field_id(gson)
d394 1
a395 2


d404 1
a404 1
            & call Announce_Error (key, badTemperatureQuantity)
d413 1
a413 1
              & call Announce_Error( key, needGeocAltitude )
d417 1
a417 1
              & call Announce_Error( key, badGeocAltitudeQuantity )
d419 1
a419 1
              & call Announce_Error( key, needH2O )
d424 1
a424 1
              & call Announce_Error( key, badGeocAltitudeQuantity )
d497 1
a497 1
          call Announce_error ( key,0, 'This fill method not yet implemented' )
a498 2
        
        ! End of fill operations
d500 30
a529 1
      case ( s_time )
d542 5
a548 5
    if ( ERROR /= 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem with Fill section' )
!      call Announce_error(key,0, &
!			 & 'Problem with Fill section (This would be fatal)')
    end if
d816 1
a816 1
      call Announce_Error(key, badLOSVelFill)
d821 1
a821 1
      call Announce_Error(key, badLOSVelFill)
d891 1
a891 1
        & "case l_gph failed first test" )
d899 1
a899 1
        &  "case l_gph failed second test")
d910 1
a910 1
        & "case l_ptan failed first test")
d917 1
a917 1
        & "case l_ptan failed second test" )
d925 2
a926 2
        call Announce_Error (key, nonConformingHydrostatic, &
        & "case l_ptan failed third test" )
d1012 1
a1012 1
      call announce_error(0, miscellaneous_err, &
d1014 1
a1014 1
	& // "ChunkNumberIsTrustworthy must be FALSE")
d1205 1
a1205 1
        & call Announce_error(valuesNode,invalidExplicitFill)
d1214 1
a1214 1
          & call Announce_error(valuesNode,badUnitsForExplicit)
d1228 1
a1228 1
        & call Announce_error(valuesNode,invalidExplicitFill)
d1237 1
a1237 1
          & call Announce_error(valuesNode,badUnitsForExplicit)
d1283 1
a1283 1
      call Announce_Error(root, cantFillFromL1B)
d1290 2
a1291 2
      call Announce_Error(errorReadingL1B, root)
		    if ( toggle(gen) ) call trace_end ( "FillVectorQuantityFromL1B")
d1476 5
a1480 5
    if ( where > 0 ) then
      call dump_tree_node ( where, 0 )
    else
      call output ( '(no lcf node available)' )
    end if
d1512 1
a1512 1
      call output ( " the fields " )
d1514 1
a1514 1
        call display_string ( lit_indices(i) )
d1542 5
d1591 3
@


2.44
log
@Improved the timing message
@
text
@d122 1
a122 1
       "$Id: Fill.f90,v 2.43 2001/04/26 02:44:17 vsnyder Exp $"
a155 1
    type (VectorValue_T), pointer :: QUANTITY ! Quantity to be filled
d159 1
a165 4
    type (Vector_T) :: NewVector ! A vector we've created
    character (LEN=LineLen) ::              Msr
    real :: T1, T2              ! for timing

d172 1
a176 1
    integer :: INSTANCE                 ! Loop counter
d179 1
d190 3
d205 2
d210 1
a219 7
    logical :: TIMING
    logical :: SPREAD           ! Do we spread values accross instances in explict

    logical, dimension(field_first:field_last) :: got

    !    INTEGER :: OL2FileHandle

d317 20
a336 20
          case (f_quantity)   ! What quantity are we filling quantity=vector.quantity
            vectorIndex=decoration(decoration(subtree(1,gson)))
            quantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_method)   ! How are we going to fill it?
            fillMethod=decoration(gson)
          case (f_sourceQuantity)       ! When filling from a vector, what vector/quantity
            sourceVectorIndex=decoration(decoration(subtree(1,gson)))
            sourceQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_tngtECI)              ! For special fill of losVel
            tngtECIVectorIndex=decoration(decoration(subtree(1,gson)))
            tngtECIQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_scECI)                ! For special fill of losVel
            scECIVectorIndex=decoration(decoration(subtree(1,gson)))
            scECIQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_scVel)                ! For special fill of losVel
            scVelVectorIndex=decoration(decoration(subtree(1,gson)))
            scVelQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_sourceL2AUX)          ! Which L2AUXDatabase entry to use
            l2auxIndex=decoration(decoration(gson))
          case (f_sourceL2GP)           ! Which L2GPDatabase entry to use
d338 13
a350 13
          case (f_temperatureQuantity) ! For hydrostatic
            temperatureVectorIndex=decoration(decoration(subtree(1,gson)))
            temperatureQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_h2oQuantity) ! For hydrostatic
            h2oVectorIndex=decoration(decoration(subtree(1,gson)))
            h2oQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_geocAltitudeQuantity) ! For hydrostatic
            geocAltitudeVectorIndex=decoration(decoration(subtree(1,gson)))
            geocAltitudeQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_refGPHQuantity) ! For hydrostatic
            refGPHVectorIndex=decoration(decoration(subtree(1,gson)))
            refGPHQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
          case (f_explicitValues) ! For explicit fill
d352 1
a352 1
          case (f_sourceGrid)
d354 1
a354 1
          case (f_sourceVGrid)
d356 7
a362 7
          case (f_maxIterations)      ! For hydrostatic fill
            call expr(subtree(2,subtree(j,key)), unitAsArray,valueAsArray)
            if (all(unitAsArray(1) /= (/PHYQ_Dimensionless,PHYQ_Invalid/))) &
              & call Announce_error( key, badUnitsForMaxIterations)
            maxIterations=valueAsArray(1)
          case (f_spread) ! For explicit fill, note that gson here is not same as others
            if (node_id(gson) == n_set_one ) then
d365 1
a365 1
              spread=decoration(subtree(2,gson)) == l_true
d371 2
a372 2
        quantity=>GetVectorQtyByTemplateIndex(vectors(vectorIndex),quantityIndex)
        select case (fillMethod)
d375 1
a375 1
        case (l_hydrostatic) ! -------------------------- Hydrostatic fills ------
d377 2
a378 2
          if (.not.all(got( (/ f_refGPHQuantity, f_temperatureQuantity /)))) &
            call Announce_Error(key,needTempREFGPH)
d382 1
a382 1
          if (temperatureQuantity%template%quantityType /= l_Temperature) &
d387 2
a388 2
          if (refGPHQuantity%template%quantityType /= l_refGPH) &
            & call Announce_Error (key, badrefGPHQuantity)
d390 2
a391 2
          if (quantity%template%quantityType==l_ptan ) then
            if (.not. got(f_geocAltitudeQuantity)) &
d395 1
a395 1
            if (geocAltitudeQuantity%template%quantityType /= l_tngtgeocAlt) &
d397 1
a397 1
            if (.not. got(f_h2oQuantity)) &
d401 2
a402 2
            if (.not. ValidateVectorQuantity(h2oQuantity, &
              & quantityType=(/l_vmr/), molecule=(/l_h2o/)))&
d405 1
a405 2
            geocAltitudeQuantity=>NULL()
            h2oQuantity=>NULL()
d407 2
a408 2
          call FillVectorQtyHydrostatically(key, quantity, temperatureQuantity, &
            & refGPHQuantity, h2oQuantity, geocAltitudeQuantity, maxIterations)          
d410 5
a414 5
        case (l_special) ! ------------------ Special fills for some quantities --
          select case (quantity%template%quantityType)
          case (l_losVel)
            if (.not. any(got( (/f_tngtECI, f_scECI, f_scVel/) )) ) then
              call Announce_error(key, badlosVelFill)
d416 1
a416 1
              tngtECIQuantity=> GetVectorQtyByTemplateIndex( &
d418 1
a418 1
              scECIQuantity=> GetVectorQtyByTemplateIndex( &
d420 1
a420 1
              scVelQuantity=> GetVectorQtyByTemplateIndex( &
d422 2
a423 2
              call FillLOSVelocity(key, quantity, tngtECIQuantity, &
                & scECIquantity, scVelQuantity)
d426 1
a426 1
            call Announce_error(key, noSpecialFill)
d429 1
a429 1
        case (l_vGrid) ! ---------------------- Fill from vGrid ---------
d432 3
a434 3
            & frequencyCoordinate = (/l_none/) ) ) &
            & call MLSMessage(MLSMSG_Error,ModuleName,&
            &   'vGrids can only be used to fill ptan quantities')
d436 2
a437 2
            & call MLSMessage (MLSMSG_Error,ModuleName, &
            &  'Vertical coordinate in vGrid is not zeta')
d439 2
a440 2
            & call MLSMessage (MLSMSG_Error,ModuleName, &
            &  'VGrid is not of the same size as the quantity')
d447 17
a463 13
        case (l_gridded) ! --------------------- Fill from gridded data --
          if (.not. got(f_sourceGrid)) call Announce_Error(key,noSourceGridGiven)
          call FillVectorQuantityFromGrid(quantity,griddedData(gridIndex),errorCode)
          if (errorCode/=0) call Announce_error(key,errorCode)

        case (l_l2gp) ! ---------------------- Fill from L2GP quantity ---
          if (.NOT. got(f_sourceL2GP)) call Announce_Error(key,noSourceL2GPGiven)
          call FillVectorQuantityFromL2GP(quantity,l2gpDatabase(l2gpIndex),errorCode)
          if (errorCode/=0) call Announce_error(key,errorCode)


        case (l_l2aux) ! --------------------- Fill from L2AUX quantity --
          if (.NOT. got(f_sourceL2AUX)) call Announce_Error(key,noSourceL2AUXGiven)
d465 1
a465 2
          if (errorCode/=0) call Announce_error(key,errorCode)

d467 3
a469 3
        case (l_explicit) ! -------------------- Explicity fill from l2cf -
          if (.not. got(f_explicitValues)) call Announce_Error(key, &
            & noExplicitValuesGiven)
d472 1
a472 2

        case (l_l1b)                    ! Fill from L1B data
a474 1

d476 1
a476 2
          call Announce_error(key,0, &
			 & 'This fill method not yet implemented')
d489 3
a491 2
        case ( s_snoop )
          call Snoop( key=key, vectorDatabase=vectors)
d496 2
a497 2
    if (ERROR/=0 ) then
	 	call MLSMessage(MLSMSG_Error,ModuleName,'Problem with Fill section')
d500 1
a500 1
	end if
d814 1
a814 1
  subroutine FillVectorQtyHydrostatically(key, quantity, &
d816 1
a816 1
    & geocAltitudeQuantity, maxIterations)
d834 2
a835 2
    select case (quantity%template%quantityType)
    case (l_gph)
d847 1
a847 1
      if ((any(quantity%template%surfs /= temperatureQuantity%template%surfs)) .or. &
d855 2
a856 2
      call GetBasisGPH(temperatureQuantity, refGPHQuantity, quantity%values)
    case (l_ptan)
d866 1
a866 1
      if ((any(refGPHquantity%template%phi /= temperatureQuantity%template%phi)) .or. &
d890 2
a891 2
      call GetHydrostaticTangentPressure(quantity, temperatureQuantity,&
        & refGPHQuantity, h2oQuantity, geocAltitudeQuantity, maxIterations)
d893 1
a893 2
          call Announce_error(0, 0, &
			 & 'No such fill yet')
d1538 3
@


2.43
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d122 1
a122 1
       "$Id: $"
d125 1
a125 1
       "$RCSfile: $"
d518 1
a518 1
      call output ( "Timing for MLSL2Fill =" )
d1543 3
@


2.42
log
@Made spread more flexible
@
text
@d26 1
a26 1
  use Init_Tables_Module, only: Lit_Indices
d120 7
a126 5
  !---------------------------- RCS Ident Info -------------------------------
  character (len=256) :: Id = &
    "$id: fill.f90,v 1.1 2000/01/21 21:04:06 livesey Exp $"
  character (len=*), parameter :: ModuleName= "$RCSfile: Fill.f90,v $"
  !---------------------------------------------------------------------------
d1543 3
@


2.41
log
@Removed some unnecessary logic
@
text
@d1154 1
a1154 1
    if (spread ) then      ! 1 instance given, spread to all instances
d1157 2
a1158 1
      if ( (nsons(valuesNode)-1 /= quantity%template%instanceLen) .or. &
d1171 5
a1175 1
        quantity%values(k,:)=valueAsArray(1)
d1541 3
@


2.40
log
@Add fill from l2gp
@
text
@d649 1
a649 2
      print*,'Doing instance:',instance,instIndex
      
d859 1
a859 3
      if ( (quantity%template%noInstances /= &
        &   temperatureQuantity%template%noInstances) .or. &
        &  (quantity%template%noInstances /= &
d861 1
a861 1
        &  (quantity%template%noInstances /= &
d1536 3
@


2.39
log
@Longer error messages; halts if problem in fill
@
text
@d15 2
a16 2
    & F_SOURCEL2AUX, F_SOURCEL2GP, F_SOURCEQUANTITY, F_SPREAD, &
    & F_TEMPERATUREQUANTITY, F_TNGTECI, F_Type, FIELD_FIRST, FIELD_LAST
d19 1
a19 1
    & L_HYDROSTATIC, L_KRONECKER, L_L1B, L_L2GP, L_L2AUX, L_LOSVEL, L_PLAIN, &
d22 1
a22 1
    & L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VMR, L_ZETA
d56 1
d134 1
a134 1
    & QtyTemplates , Matrices, L2GPDatabase, L2AUXDatabase, Chunks, ChunkNo )
d147 1
d178 1
d213 2
a214 1
                                        !
d356 2
d432 18
d1539 3
@


2.38
log
@Construct matrix properly
@
text
@d37 1
a453 1
!          call MLSMessage(MLSMSG_Error,ModuleName,'This fill method not yet implemented')
d475 3
a477 3
	 !	call MLSMessage(MLSMSG_Error,ModuleName,'Problem with Fill section')
          call Announce_error(key,0, &
			 & 'Problem with Fill section')
d821 2
a822 1
        call Announce_Error ( key, nonConformingHydrostatic )
d829 2
a830 1
        call Announce_Error ( key, nonConformingHydrostatic )
d842 2
a843 1
        call Announce_Error ( key, nonConformingHydrostatic )
d849 2
a850 1
        call Announce_Error ( key, nonConformingHydrostatic )
d858 10
a867 1
        call Announce_Error (key, nonConformingHydrostatic )
a873 1
!      call MLSMessage(MLSMSG_Error, ModuleName, 'No such fill yet')
d1505 1
a1505 1
      call output(ExtraMessage)
d1515 3
@


2.37
log
@Now does fill from Grid.
@
text
@d34 1
a34 1
    & Matrix_Cholesky_T, Matrix_Database_T, Matrix_Kronecker_T, &
d273 1
a273 1
            colVector = gson
d275 1
a275 1
            rowVector = gson
d482 2
a483 1
        call dump ( vectors )
d1503 3
@


2.36
log
@Implement 'matrix' spec in Fill section
@
text
@d31 1
d115 1
d608 2
d611 26
d1502 3
@


2.35
log
@Calls trace_end if needed before every return
@
text
@d11 17
a27 10
  use INIT_TABLES_MODULE, only: F_GEOCALTITUDEQUANTITY, F_EXPLICITVALUES, &
    & F_H2OQUANTITY, F_MAXITERATIONS, F_METHOD, F_QUANTITY, F_REFGPHQUANTITY, &
    & F_SCECI, F_SCVEL, F_SOURCE, F_SOURCEGRID, F_SOURCEL2AUX, F_SOURCEL2GP, &
    & F_SOURCEQUANTITY, F_SPREAD, F_TEMPERATUREQUANTITY, F_TNGTECI, FIELD_FIRST, &
    & FIELD_LAST, L_EXPLICIT, L_GPH, L_GRIDDED, L_HYDROSTATIC, L_L1B, L_L2GP, &
    & L_L2AUX, L_LOSVEL, L_PRESSURE, L_PTAN, L_RADIANCE, L_REFGPH, &
    & L_SCECI, L_SCGEOCALT, L_SCVEL, L_SPECIAL, L_TEMPERATURE, L_TNGTECI,&
    & L_TNGTGEODALT, L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VMR, &
    & L_ZETA, S_TIME, S_VECTOR, S_FILL, S_SNOOP
  ! will be added
d32 3
d38 1
a38 1
  use MoreTree, only: Get_Spec_ID
d41 1
a41 1
  use string_table, only: get_string
d65 12
a76 8
  integer, parameter :: unknownQuantityName = WRONG_NUMBER+1
  integer, parameter :: source_not_in_db = unknownQuantityName+1
  integer, parameter :: zeroProfilesFound = source_not_in_db+1
  integer, parameter :: zeroGeodSpan = zeroProfilesFound+1
  integer, parameter :: vectorWontMatchL2GP = zeroGeodSpan+1
  integer, parameter :: cantFillFromL2AUX = vectorWontMatchL2GP+1
  integer, parameter :: vectorWontMatchPDef = cantFillFromL2AUX+1
  integer, parameter :: cantFillFromL1B = vectorWontMatchPDef+1
d78 12
a89 12
  integer, parameter :: numInstancesisZero = cantFillFromL1B+1
  integer, parameter :: numSurfsisZero = numInstancesisZero+1
  integer, parameter :: numChansisZero = numSurfsisZero+1
  integer, parameter :: objIsFullRank3 = numChansisZero+1
  integer, parameter :: otherErrorInFillVector = objIsFullRank3+1
  integer, parameter :: noSourceGridGiven= otherErrorInFillVector+1
  integer, parameter :: noSourceL2GPGiven= noSourceGridGiven+1
  integer, parameter :: noSourceL2AUXGiven= noSourceL2GPGiven+1
  integer, parameter :: noExplicitValuesGiven= noSourceL2AUXGiven+1
  integer, parameter :: noSourceQuantityGiven= noExplicitValuesGiven+1
  integer, parameter :: invalidExplicitFill= noSourceQuantityGiven+1
  integer, parameter :: badUnitsForExplicit= invalidExplicitFill+1
d92 8
a99 8
  integer, parameter :: n1_is_zero = badUnitsForExplicit+1
  integer, parameter :: n2_is_zero = n1_is_zero+1
  integer, parameter :: n3_is_zero = n2_is_zero+1
  integer, parameter :: m1_too_small = n3_is_zero+1
  integer, parameter :: m2_too_small = m1_too_small+1
  integer, parameter :: not_permutation = m2_too_small+1
  integer, parameter :: allocation_err = not_permutation+1
  integer, parameter :: deallocation_err = allocation_err+1
d102 12
a113 12
  integer, parameter :: miscellaneous_err = deallocation_err+1
  integer, parameter :: errorReadingL1B = miscellaneous_err+1
  integer, parameter :: needTempREFGPH = errorReadingL1B+1
  integer, parameter :: needH2O = needTempRefGPH+1
  integer, parameter :: needGeocAltitude = needH2O+1
  integer, parameter :: badGeocAltitudeQuantity = needGeocAltitude+1
  integer, parameter :: badTemperatureQuantity = badGeocAltitudeQuantity+1
  integer, parameter :: badREFGPHQuantity = badTemperatureQuantity+1
  integer, parameter :: nonConformingHydrostatic = badREFGPHQuantity+1
  integer, parameter :: badUnitsForMaxIterations = nonConformingHydrostatic+1
  integer, parameter :: noSpecialFill = badUnitsForMaxIterations + 1
  integer, parameter :: badlosVelFill = noSpecialFill + 1
d129 2
a130 2
  subroutine MLSL2Fill ( root, l1bInfo, griddedData, vectorTemplates, vectors, &
    & qtyTemplates , L2GPDatabase, L2AUXDatabase, chunks, chunkNo )
d137 10
a146 9
    type (L1BInfo_T), intent(in) :: l1bInfo
    type (GriddedData_T), dimension(:), pointer :: griddedData
    type (VectorTemplate_T), dimension(:), pointer :: vectorTemplates
    type (Vector_T), dimension(:), pointer :: vectors
    type (QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
    type (L2GPData_T), dimension(:), pointer :: L2GPDatabase
    type (L2AUXData_T), dimension(:), pointer :: L2AUXDatabase
    type (MLSChunk_T), dimension(:), intent(in) :: chunks
    integer, intent(in) :: chunkNo
d151 7
a157 7
    type (VectorValue_T), pointer :: GEOCALTITUDEQUANTITY
    type (VectorValue_T), pointer :: H2OQUANTITY
    type (VectorValue_T), pointer :: REFGPHQUANTITY
    type (VectorValue_T), pointer :: SCECIQUANTITY
    type (VectorValue_T), pointer :: SCVELQUANTITY
    type (VectorValue_T), pointer :: TEMPERATUREQUANTITY
    type (VectorValue_T), pointer :: TNGTECIQUANTITY
d159 2
a160 2
    type (Vector_T) :: newVector ! A vector we've created
    character (LEN=LineLen) ::              msr
d162 2
a163 3
    
    integer :: GEOCALTITUDEQUANTITYINDEX    ! In the source vector
    integer :: GEOCALTITUDEVECTORINDEX      ! In the vector database
d167 3
a170 1
    integer :: GRIDINDEX                ! Index of requested grid
d174 1
a174 1
    integer :: ind                      ! Temoprary index
d179 5
d189 2
d192 1
a192 1
    integer :: SCECIQUANTITYINDEX       ! In the quantities database
a193 1
    integer :: SCVELQUANTITYINDEX       ! In the quantities database
d200 1
d202 2
a203 3
    integer :: TNGTECIQUANTITYINDEX     ! In the quantities database
    integer, DIMENSION(2) :: UNITASARRAY ! From expr
    real(r8), DIMENSION(2) :: VALUEASARRAY ! From expr
d211 1
a211 1
    logical, DIMENSION(field_first:field_last) :: got
d261 41
d308 1
a308 1
          fieldIndex=decoration(subtree(1,gson))
d355 1
a355 1
            if (node_id(gson) == n_set_one) then
d359 1
a359 1
            endif
d383 1
a383 1
          if (quantity%template%quantityType==l_ptan) then
d400 1
a400 1
          endif
d407 1
a407 1
            if (.not. any(got( (/f_tngtECI, f_scECI, f_scVel/) ))) then
d418 1
a418 1
            endif
d472 1
a472 1
    if (ERROR/=0) then
d476 1
a476 1
	endif
d498 2
a499 2
  subroutine FillVector(errorCode, inArray, Vector, arrayType, vectorType, NumQtys, &
    & numChans, numSurfs, numInstances, qtiesStart, dim_order)
d504 1
a504 1
!
d510 1
a510 1
!
d532 1
a532 1
    if(numChans.eq.0) then
d536 1
a536 1
    elseif(numSurfs.eq.0) then
d540 1
a540 1
    elseif(numInstances.eq.0) then
d544 1
a544 1
    endif
d560 1
a560 1
        !	IF(numChans.EQ.1) THEN
d562 1
a562 1
        !	ELSEIF(numSurfs.EQ.1) THEN
d564 1
a564 1
        !	ELSEIF(numInstances.EQ.1) THEN
d569 1
a569 1
        !	ENDIF
d573 1
a573 1
        !     IF(errorCode /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
d575 1
a575 1
      enddo
d582 1
a582 1
        if(present(dim_order)) then
d586 1
a586 1
        endif
d589 1
a589 1
        !     IF(errorCode /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
d591 1
a591 1
      enddo
d646 1
a646 1
    if ( quantity%template%verticalCoordinate == l_pressure) then
d648 1
a648 1
        & LOG10(l2gp%pressures)) > TOLERANCE)) then
d654 1
a654 1
        & LOG10(l2gp%pressures)) > TOLERANCE)) then
d666 1
a666 1
    if (lastProfile > l2gp%nTimes) then
d669 1
a669 1
    endif
d673 1
a673 1
      &         quantity%template%phi(1,:)) > tolerance)) then
d679 1
a679 1
      &         quantity%template%time(1,:)) > tolerance)) then
d715 1
a715 1
      &  (scVel%template%quantityType /= l_scVel)) then
d718 1
a718 1
    endif
d723 1
a723 1
    endif
d791 1
a791 1
		    if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d793 1
a793 1
      endif
d798 1
a798 1
		    if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d800 1
a800 1
      endif
d810 1
a810 1
		    if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d812 1
a812 1
      endif
d816 1
a816 1
		    if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d818 1
a818 1
      endif
d824 1
a824 1
		    if ( toggle(gen) ) call trace_end ( "FillVectorQtyHydrostatically")
d882 1
a882 1
    if(OQTemplate%noInstances <= 0) then
d885 1
a885 1
    elseif(PDQTemplate%noInstances <= 0) then
d888 1
a888 1
    endif
d890 1
a890 1
    if(chunkNo == -1) then
d893 1
a893 1
    elseif(ChunkNumberIsTrustworthy) then
d897 1
a897 1
      !        	IF(chunkNo == OldVector%chunkNumber(i)) THEN
d900 2
a901 2
      !         ENDIF
      !   ENDDO
d914 1
a914 1
      enddo
d916 1
a916 1
      if(phi_TOLERANCE <= 0.D0) then
d919 1
a919 1
      endif
d923 1
a923 1
        if(phiMin <= (PDQTemplate%phi(1, i) + phi_TOLERANCE)) then
d925 2
a926 2
        endif
        if(phiMax >= (PDQTemplate%phi(1, i) - phi_TOLERANCE)) then
d928 4
a931 4
        endif
      enddo
    endif
!
d940 1
a940 1
    if(TheyMatch) then
d942 1
a942 1
        if( &
d948 1
a948 1
          &) then
d952 1
a952 1
        endif
d954 2
a955 2
    endif
    if( TheyMatch &
d961 1
a961 1
        if( &
d967 1
a967 1
        endif
d969 2
a970 2
    endif
    if(TheyMatch) then
d974 1
a974 1
    endif
d1045 1
a1045 1
    enddo
d1049 1
a1049 1
    if(OQTemplate%minorFrame) then
d1051 2
a1052 2
    endif
    if(OQTemplate%noChans > 0) then
d1055 1
a1055 1
    endif
d1057 1
a1057 1
    if(TheyMatch) then
d1068 1
a1068 1
    endif
d1090 1
a1090 1
    if (spread) then      ! 1 instance given, spread to all instances
d1129 1
a1129 1
    endif
d1204 1
a1204 1
    if(present(inRelSmall)) then
d1206 1
a1206 1
    endif
d1208 1
a1208 1
    if(present(inOverallTol)) then
d1210 1
a1210 1
    endif
d1212 1
a1212 1
    if(abs(x-y) <= tolerance) then
d1214 1
a1214 1
    elseif(x*y /= 0) then
d1216 1
a1216 1
    elseif(x /= 0) then
d1220 1
a1220 1
    endif
d1225 1
a1225 1
  function whatQuantityNumber(x, y, xVectorTemplate)
d1231 1
a1231 1
!
d1233 2
a1234 2
    integer, intent(IN) ::               x, y
    type (VectorTemplate_T)  ::          xVectorTemplate
d1237 1
a1237 1
    integer ::                           whatQuantityNumber
d1240 2
a1241 2
    integer, parameter ::                FAILED=-1
    integer              ::              qty
d1245 1
a1245 1
      if(xVectorTemplate%Name == y) then
d1248 2
a1249 2
      endif
    enddo
d1251 1
a1251 1
  end function whatQuantityNumber
d1254 1
a1254 1
  subroutine squeeze(errorCode, source, sink, source_order)
d1260 1
a1260 1
!
d1266 1
a1266 1
!
d1272 1
a1272 1
!
d1277 4
a1280 4
    real(r8), dimension(:,:,:), intent(IN) :: source
    real(r8), dimension(:,:), intent(OUT)  :: sink
    integer, intent(OUT)                   :: errorCode
    integer, intent(IN), optional, dimension(:) :: source_order
d1284 5
a1288 5
    integer, dimension(4) :: source_shape
    integer, dimension(4) :: sink_shape
    integer, dimension(4) :: temp_shape
    integer::i,icode,offset
    real(r8), dimension(:,:,:), allocatable :: temp
d1293 1
a1293 1
    if (source_shape(1) == 0) then
d1296 1
a1296 1
    elseif (source_shape(2) == 0) then
d1299 1
a1299 1
    elseif (source_shape(3) == 0) then
d1302 1
a1302 1
    elseif (sink_shape(1) < source_shape(1)*source_shape(2)) then
d1305 1
a1305 1
    elseif (sink_shape(2) < source_shape(3)) then
d1310 1
a1310 1
    endif
d1312 1
a1312 1
    if(present(source_order)) then
d1315 1
a1315 1
      if(source_order(1)+source_order(2)+source_order(3) /= 6 &
d1318 1
a1318 1
        errorCode=not_permutation
d1320 6
a1325 8
      endif
      do i=1, 3
        temp_shape(i) = source_shape(source_order(i))
      enddo
      allocate(temp(temp_shape(1), temp_shape(2), temp_shape(3)), &
        & STAT=errorCode)
      if(errorCode /= 0) then
        errorCode=allocation_err
d1327 1
a1327 1
      endif
d1330 3
a1332 4
      deallocate(temp, &
        & STAT=errorCode)
      if(errorCode /= 0) then
        errorCode=deallocation_err
d1334 1
a1334 1
      endif
d1337 1
a1337 1
    endif
d1339 1
a1339 1
  end subroutine squeeze
a1340 2
!
!
d1342 1
a1342 1
  subroutine ANNOUNCE_ERROR ( where, CODE , ExtraMessage)
d1345 4
a1348 1
    character (LEN=*), optional :: ExtraMessage
d1353 5
a1357 5
	if(where > 0) then
    call print_source ( source_ref(where) )
		else
    call output ( '(no lcf tree available)' )
		endif
d1362 5
a1366 5
	if(where > 0) then
    call dump_tree_node ( where, 0 )
		else
    call output ( '(no lcf node available)' )
		endif
d1369 10
d1381 4
a1384 12
    case ( wrong_number )
      call output ( " command does not have exactly one field.", advance='yes' )
    case ( unknownQuantityName )
      call output ( " quantity was not found in the vector", advance='yes' )
    case ( source_not_in_db )
      call output ( " source was not found in the db.", advance='yes' )
    case ( zeroProfilesFound )
      call output ( " command found zero profiles.", advance='yes' )
    case ( zeroGeodSpan )
      call output ( " command found zero geod. ang. span.", advance='yes' )
    case ( vectorWontMatchL2GP )
      call output ( " command found no match of vetor and L2GP.", advance='yes' )
d1387 2
a1388 2
    case ( cantFillFromL1B )
      call output ( " command could not be filled from L1B.", advance='yes' )
d1391 2
a1392 16
    case ( vectorWontMatchPDef )
      call output ( " command found new and prev. vectors unmatched.", advance='yes' )
    case ( numInstancesisZero )
      call output ( " command has zero instances.", advance='yes' )
    case ( numSurfsisZero )
      call output ( " command has zero surfaces.", advance='yes' )
    case ( objIsFullRank3 )
      call output ( " command array is full rank 3.", advance='yes' )
    case ( otherErrorInFillVector )
      call output ( " command caused an error in FillVector.", advance='yes' )
    case ( n1_is_zero )
      call output ( " command caused an n1=0 error in squeeze.", advance='yes' )
    case ( n2_is_zero )
      call output ( " command caused an n2=0 error in squeeze.", advance='yes' )
    case ( n3_is_zero )
      call output ( " command caused an n3=0 error in squeeze.", advance='yes' )
d1397 17
a1413 6
    case ( not_permutation )
      call output ( " command caused an illegal permutation in squeeze.", advance='yes' )
    case ( allocation_err )
      call output ( " command caused an allocation error in squeeze.", advance='yes' )
    case ( deallocation_err )
      call output ( " command caused an deallocation error in squeeze.", advance='yes' )
d1416 2
d1420 2
a1423 2
    case ( noSourceL2AUXGiven )
      call output ( " no sourceL2AUX field given for L2AUX fill.", advance='yes' )
a1425 18
    case ( invalidExplicitFill )
      call output ( " has inappropriate dimensionality for explicit fill.", advance='yes' )
    case ( needTempREFGPH )
      call output ( " needs temperatureQuantity and refGPHquantity.", advance='yes' )
    case ( needH2O )
      call output ( " needs H2OQuantity.", advance='yes' )
    case ( needGeocAltitude )
      call output ( " needs geocAltitudeQuantity.", advance='yes' )
    case ( badTemperatureQuantity )
      call output ( " temperatureQuantity is not temperature", advance='yes' )
    case ( badREFGPHQuantity )
      call output ( " refGPHQuantity is not refGPH", advance='yes' )
    case ( badGeocAltitudeQuantity )
      call output ( " geocAltitudeQuantity is not geocAltitude", advance='yes' )
    case ( nonConformingHydrostatic )
      call output ( " quantities needed for hydrostatic fill do not conform", advance='yes' )
    case ( badUnitsForMaxIterations )
      call output ( " maxIterations should be dimensionless", advance='yes' )
d1428 30
a1457 2
    case ( badlosvelfill )
      call output ( " incomplete/incorrect information for los velocity", advance='yes' )
d1461 1
a1461 1
    if( present(ExtraMessage)) then
d1463 1
a1463 1
    endif
d1472 3
@


2.34
log
@Deleted all MLSMessages
@
text
@d728 1
d735 1
d747 1
d753 1
d761 1
d1114 1
d1400 3
@


2.33
log
@Added gridded data fill
@
text
@a26 1
  use MLSMessageModule, only: MLSMSG_Error, MLSMessage
d388 3
a390 1
          call MLSMessage(MLSMSG_Error,ModuleName,'This fill method not yet implemented')
d409 5
a413 1
    if (ERROR/=0) call MLSMessage(MLSMSG_Error,ModuleName,'Problem with Fill section')
d762 3
a764 1
      call MLSMessage(MLSMSG_Error, ModuleName, 'No such fill yet')
d1285 2
d1288 4
d1294 2
d1297 4
d1394 3
@


2.32
log
@Bug fix
@
text
@d13 3
a15 3
    & F_SCECI, F_SCVEL, F_SOURCE, F_SOURCEL2AUX, F_SOURCEL2GP, F_SOURCEQUANTITY,&
    & F_SPREAD, F_TEMPERATUREQUANTITY, F_TNGTECI, FIELD_FIRST, FIELD_LAST,&
    & L_EXPLICIT, L_GPH, L_HYDROSTATIC, L_L1B, L_L2GP, &
d70 2
a71 1
  integer, parameter :: noSourceL2GPGiven= otherErrorInFillVector+1
d116 1
a116 1
  subroutine MLSL2Fill ( root, l1bInfo, aprioriData, vectorTemplates, vectors, &
d125 1
a125 1
    type (GriddedData_T), dimension(:), pointer :: aprioriData
d155 1
d285 2
d361 5
d531 11
d1331 2
d1375 3
@


2.31
log
@Use Get_Spec_ID instead of decoration(subtree...
@
text
@d637 2
a638 1
    noMAFs=qty%template%noInstances
d640 2
a641 2
    do mif = 1, noMIFs
      do maf = 1, noMAFs
d649 3
a651 3
        x=1 + 3*(mif-1)
        y=x+1
        z=x+2
d664 1
a664 1
        qty%values(x:z,maf) = dot_product(tngtVel, los) - &
d1353 3
@


2.30
log
@Added special fill for losVel, and dealt with new MLSSignals_m
@
text
@d29 1
d225 1
a225 1
      select case( decoration(subtree(1,decoration(subtree(1,key)))) )
d1352 3
@


2.29
log
@Added some more l1b fill options.
@
text
@d8 1
d12 7
a18 5
    & F_H2OQUANTITY, F_MAXITERATIONS, F_METHOD, F_QUANTITY, F_REFGPHQUANTITY, F_SOURCE, &
    & F_SOURCEL2AUX, F_SOURCEL2GP, F_SOURCEQUANTITY, F_SPREAD, F_TEMPERATUREQUANTITY, &
    & FIELD_FIRST, FIELD_LAST, L_EXPLICIT, L_GPH, L_HYDROSTATIC, L_L1B, L_L2GP, &
    & L_L2AUX, L_PRESSURE, L_PTAN, L_RADIANCE, L_REFGPH, L_SCECI, L_SCGEOCALT, L_SCVEL, &
    & L_TEMPERATURE, L_TNGTECI, L_TNGTGEODALT, L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VMR, &
d40 1
a40 1
  use ScanModelModule, only: GetBasisGPH, GetHydrostaticTangentPressure
d97 2
d133 10
a142 5
    type (VectorValue_T), POINTER :: QUANTITY ! Quantity to be filled
    type (VectorValue_T), POINTER :: TEMPERATUREQUANTITY ! Source quantity
    type (VectorValue_T), POINTER :: REFGPHQUANTITY ! Source quantity
    type (VectorValue_T), POINTER :: H2OQUANTITY ! Source quantity
    type (VectorValue_T), POINTER :: GEOCALTITUDEQUANTITY ! Source quantity
d153 1
a153 1
    integer :: H2OQUANTITYINDEX         ! In the source vector
d164 1
a164 1
    integer :: REFGPHQUANTITYINDEX      ! In the source vector
d166 4
d171 1
a171 1
    integer :: SOURCEQUANTITYINDEX      ! In the source vector
d173 1
a173 1
    integer :: TEMPERATUREQUANTITYINDEX ! In the source vector
d176 2
d252 1
a252 1
          case (f_sourceQuantity) ! When filling from a vector, what vector/quantity
d255 10
a264 1
          case (f_sourceL2AUX)  ! Which L2AUXDatabase entry to use
d266 1
a266 1
          case (f_sourceL2GP)   ! Which L2GPDatabase entry to use
d337 18
d601 70
d727 2
a728 2
        &  (decoration(quantity%template%instrumentModule) /= &
        &   decoration(geocAltitudeQuantity%template%instrumentModule) ) ) then
d1333 4
d1351 3
@


2.28
log
@Added snoop option
@
text
@d14 2
a15 2
    & L_L2AUX, L_PRESSURE, L_PTAN, L_RADIANCE, L_REFGPH, L_SCGEOCALT, &
    & L_TEMPERATURE, L_TNGTGEODALT, L_TNGTGEOCALT, L_TRUE, L_VECTOR, L_VMR, &
d943 3
d952 4
d959 1
a959 1
      call Announce_Error(cantFillFromL1B, root)
d1234 3
@


2.27
log
@Got pressure guesser to work
@
text
@d16 1
a16 1
    & L_ZETA, S_TIME, S_VECTOR, S_FILL
d40 1
a176 1
    got= .false.
d204 1
d348 3
d1227 3
@


2.26
log
@New L2AUX stuff
@
text
@d273 3
a275 1
        case (l_hydrostatic)
d310 3
a312 1
        case (l_l2gp)
d316 3
a318 1
        case (l_l2aux)
d322 3
a324 1
        case (l_explicit)       ! An explicit fill
d328 2
d332 2
d563 2
a564 2
    type (VectorValue_T), intent(in) :: H2OQUANTITY
    type (VectorValue_T), intent(in) :: GEOCALTITUDEQUANTITY
d566 2
d1223 3
@


2.25
log
@Regular commit.
@
text
@d20 1
a20 3
  use L2AUXData, only: L2AUXData_T, L2AUXDim_None, L2AUXDim_Channel, &
    & L2AUXDim_IntermediateFrequency, L2AUXDim_USBFrequency, L2AUXDim_LSBFrequency, &
    & L2AUXDim_MIF, L2AUXDim_MAF, L2AUXDim_GeodAngle
d38 2
a39 1
  use Intrinsic, only: PHYQ_Dimensionless, PHYQ_Invalid
d798 1
a798 1
    do i=1, OldL2AUXData%noDimensionsUsed
d801 1
a801 1
      case(L2AUXDim_Channel)
d804 1
a804 1
      case(L2AUXDim_IntermediateFrequency)
d806 1
a806 1
      case(L2AUXDim_USBFrequency)
d808 1
a808 1
      case(L2AUXDim_LSBFrequency)
d810 1
a810 1
      case(L2AUXDim_MIF)
d812 1
a812 1
      case(L2AUXDim_MAF)
d1209 3
@


2.24
log
@Regular commit, hydrostatic stuff in place.
@
text
@d40 1
a40 1
  use Intrinsic, only: PHYQ_Dimensionless
d192 1
a192 1
    maxIterations = 0
d258 2
a259 2
            call expr(subtree(2,key), unitAsArray,valueAsArray)
            if (unitAsArray(1) /= PHYQ_Dimensionless) &
d308 1
a308 1
            & refGPHQuantity, h2oQuantity, geocAltitudeQuantity)          
d545 2
a546 1
    & temperatureQuantity, refGPHQuantity, h2oQuantity, geocAltitudeQuantity, maxIterations)
d554 1
a554 1
    integer, intent(in), optional :: MAXITERATIONS
d559 3
d603 1
a603 3
        & refGPHQuantity, h2oQuantity, geocAltitudeQuantity, maxIterations=maxIterations)
!      call output ("Resulting ptan")
!      call dump(quantity%values)
d608 2
d1210 3
@


2.23
log
@Started hydrostic stuff
@
text
@d11 1
a11 1
    & F_H2OQUANTITY, F_METHOD, F_QUANTITY, F_REFGPHQUANTITY, F_SOURCE, &
d13 3
a15 2
    & FIELD_FIRST, FIELD_LAST, L_EXPLICIT, L_HYDROSTATIC, L_L1B, L_L2GP, &
    & L_L2AUX, L_PRESSURE, L_RADIANCE, L_SCGEOCALT, L_TRUE, L_VECTOR, &
d26 2
a27 2
  !  use MLSMessageModule, only: MLSMSG_Error, MLSMessage
  !  use MLSStrings, only: lowercase
d37 3
a39 2
    & GetVectorQtyByTemplateIndex, ValidateVectorQuantity, Vector_T, VectorTemplate_T
  use ScanModelModule
d87 2
a88 1
  integer, parameter :: needGeocAltitude = needTempRefGPH+1
d92 2
d131 1
d151 1
d162 2
d192 1
d257 5
d278 1
d283 3
d288 1
a288 2
          refGPHQuantity => GetVectorQtyByTemplateIndex( &
            & vectors(refGPHVectorIndex), refGPHQuantityIndex)
d296 7
d305 1
d307 2
a308 2
          call FillVectorQtyHydrostatically(quantity, temperatureQuantity, &
            & refGPHQuantity, geocAltitudeQuantity)          
d544 2
a545 2
  subroutine FillVectorQtyHydrostatically(quantity, &
    & temperatureQuantity, refGPHQuantity, geocAltitudeQuantity)
d547 2
a548 1
    type (VectorValue_T), intent(inout) :: QUANTITY
d551 1
d553 1
d558 47
d1178 2
d1188 4
d1206 3
@


2.22
log
@Removed debuging dump.
@
text
@d10 1
a10 1
  use INIT_TABLES_MODULE, only: F_ALTITUDEQUANTITY, F_EXPLICITVALUES, &
d84 5
d123 4
a126 1
    type (VectorValue_T), POINTER :: quantity ! Quantity to be filled
d131 2
a132 2
    integer :: ALTITUDEQUANTITYINDEX    ! In the source vector
    integer :: ALTITUDEVECTORINDEX      ! In the vector database
d239 3
a241 3
          case (f_altitudeQuantity) ! For hydrostatic
            altitudeVectorIndex=decoration(decoration(subtree(1,gson)))
            altitudeQuantityIndex=decoration(decoration(decoration(subtree(2,gson))))
d259 24
d517 15
d1100 10
d1124 3
@


2.21
log
@Added fill from l1b
@
text
@a264 1
          call dump(quantity%values)
d1067 3
@


2.20
log
@Tidied stuff up a bit.
@
text
@d13 3
a15 2
    & FIELD_FIRST, FIELD_LAST, L_EXPLICIT, L_HYDROSTATIC, L_L2GP, L_L2AUX, L_PRESSURE, &
    & L_TRUE, L_VECTOR, L_ZETA, S_TIME, S_VECTOR, S_FILL
d17 1
d24 1
d36 1
a36 1
    & ValidateVectorQuantity, Vector_T, VectorTemplate_T
d57 1
d59 1
a59 1
  integer, parameter :: numInstancesisZero = vectorWontMatchPDef+1
d83 1
d123 21
a143 20
    integer :: ALTITUDEQUANTITYINDEX ! In the source vector
    integer :: ALTITUDEVECTORINDEX ! In the vector database
    integer :: ERRORCODE        ! 0 unless error; returned by called routines
    integer :: FIELDINDEX       ! Entry in tree
    integer :: FILLMETHOD       ! How will we fill this quantity
    integer :: GSON             ! Descendant of Son
    integer :: H2OQUANTITYINDEX ! In the source vector
    integer :: H2OVECTORINDEX ! In the vector database
    integer :: I, J, K          ! Loop indices for section, spec, expr
    integer :: KEY              ! Definitely n_named
    integer :: L2AUXINDEX       ! Index into L2AUXDatabase
    integer :: L2GPINDEX        ! Index into L2GPDatabase
    integer :: L2INDEX          ! Where source is among l2gp or l2aux database
    integer :: PREVDEFDQT
    integer :: QUANTITYINDEX    ! Within the vector
    integer :: REFGPHQUANTITYINDEX ! In the source vector
    integer :: REFGPHVECTORINDEX ! In the vector database
    integer :: SON              ! Of root, an n_spec_args or a n_named
    integer :: SOURCEQUANTITYINDEX ! In the source vector
    integer :: SOURCEVECTORINDEX ! In the vector database
d145 6
a150 6
    integer :: TEMPERATUREVECTORINDEX ! In the vector database
    integer :: TEMPLATEINDEX    ! In the template database
    integer :: VALUESNODE       ! For the parser
    integer :: VECTORINDEX      ! In the vector database
    integer :: VECTORNAME       ! Name of vector to create

d249 1
a249 1
        quantity=>vectors(vectorIndex)%quantities(quantityIndex)
d262 4
a265 1
          call ExplicitFillVectorQuantity(quantity,valuesNode,spread)
d779 47
d1014 4
d1068 3
@


2.19
log
@Used new ValidateVectorQuantity routine
@
text
@a20 1
  use ManipulateVectorQuantities, only: ValidateVectorQuantity
d32 2
a33 2
  use VectorsModule, only: AddVectorToDatabase, CreateVector, Dump, Vector_T, &
    & VectorTemplate_T
d1008 3
@


2.18
log
@Made sure verticalCoordinate=l_zeta worked for filling from L2GP
@
text
@d21 1
d417 2
a418 4
    if ( (.NOT. quantity%template%coherent) .or. &
      &  (.NOT. quantity%template%stacked) .or. &
      &  ( (quantity%template%verticalCoordinate /= l_pressure) .or. &
      &    (quantity%template%verticalCoordinate /= l_zeta) ) ) then
d1009 3
@


2.17
log
@Regular commit
@
text
@d14 1
a14 1
    & L_TRUE, L_VECTOR, S_TIME, S_VECTOR, S_FILL
d418 2
a419 1
      &  (quantity%template%verticalCoordinate /= l_pressure) ) then
d435 12
a446 4
    if ( any(ABS(-LOG10(quantity%template%surfs(:,1))+ &
      & LOG10(l2gp%pressures)) > TOLERANCE)) then
      errorCode=vectorWontMatchL2GP
      return
d1010 3
@


2.16
log
@Got the explicit fill to work.
@
text
@a256 1
          call dump(vectors(vectorIndex:vectorIndex))
d429 11
d458 6
d733 1
a733 2
        print*,unitAsArray(1), quantity%template%unit, PHYQ_Dimensionless
        if ( (unitAsArray(1) /= quantity%template%unit) .and. &
d1001 3
@


2.15
log
@Simplify access to abstract syntax tree.
@
text
@d6 1
a6 1
!=============================================================================
d8 1
d10 10
a19 6
  use INIT_TABLES_MODULE, only: F_SOURCE, S_TIME, S_VECTOR, s_Fill
                                                           ! will be added
  USE L2GPData, only: L2GPData_T
  USE L2AUXData, only: L2AUXData_T, L2AUXDim_None, L2AUXDim_Channel, &
  & L2AUXDim_IntermediateFrequency, L2AUXDim_USBFrequency, L2AUXDim_LSBFrequency, &
  & L2AUXDim_MIF, L2AUXDim_MAF, L2AUXDim_GeodAngle
d22 2
a23 2
!  use MLSMessageModule, only: MLSMSG_Error, MLSMessage
!  use MLSStrings, only: lowercase
d31 1
a31 1
  use TREE_TYPES, only: N_NAMED, N_DOT
d34 2
d40 1
a40 1
  
d54 1
a54 1
! more Error codes relating to FillVector
d56 20
a75 14
integer, parameter :: numSurfsisZero = numInstancesisZero+1
integer, parameter :: numChansisZero = numSurfsisZero+1
integer, parameter :: objIsFullRank3 = numChansisZero+1
integer, parameter :: otherErrorInFillVector = objIsFullRank3+1

    ! Error codes resulting from squeeze
integer, parameter :: n1_is_zero = otherErrorInFillVector+1
integer, parameter :: n2_is_zero = n1_is_zero+1
integer, parameter :: n3_is_zero = n2_is_zero+1
integer, parameter :: m1_too_small = n3_is_zero+1
integer, parameter :: m2_too_small = m1_too_small+1
integer, parameter :: not_permutation = m2_too_small+1
integer, parameter :: allocation_err = not_permutation+1
integer, parameter :: deallocation_err = allocation_err+1
d77 2
a78 2
! miscellaneous
integer, parameter :: miscellaneous_err = deallocation_err+1
d80 1
a80 1
!  integer, parameter :: s_Fill = 0   ! to be replaced by entry in init_tables_module
d83 1
a83 1
       "$id: fill.f90,v 1.1 2000/01/21 21:04:06 livesey Exp $"
d97 2
a98 2
  ! This is the main routine for the module.  It parses the relevant lines
  ! of the l2cf and works out what to do.
d107 2
a108 2
    TYPE (L2GPData_T), DIMENSION(:), POINTER :: L2GPDatabase
    TYPE (L2AUXData_T), DIMENSION(:), POINTER :: L2AUXDatabase
d113 32
a144 12
    integer :: GSON                ! Descendant of Son
    integer :: I, J                ! Loop indices for section, spec
    integer :: IERR                ! 0 unless error; returned by called routines
    LOGICAL :: is_l2gp, is_l2aux, is_prev_vec
    integer :: KEY                 ! Definitely n_named
    integer :: l2Index             ! Where source is among l2gp or l2aux database
    CHARACTER (LEN=LineLen) ::              msr
    type (Vector_T) :: newVector
    INTEGER :: PrevDefdQt
    INTEGER :: qtiesStart
    integer :: quantityName        ! Sub-rosa index
    REAL :: T1, T2     ! for timing
d146 1
a146 9
    integer :: SON                 ! Of root, an n_spec_args or a n_named
    integer :: sourceIndex         ! In the vector database
    integer :: sourceName          ! Sub-rosa index
    integer :: templateIndex       ! In the template database
    integer :: vectorIndex         ! In the vector database
    integer :: vectorName          ! Sub-rosa index
    INTEGER :: VectorDBSize
    CHARACTER (LEN=NameLen) :: vectorNameString, templateNameString
    CHARACTER (LEN=NameLen) :: sourceNameString, quantityNameString
d148 3
a150 1
!    INTEGER :: OL2FileHandle
d154 1
d159 1
a159 1
!    OL2FileHandle = mlspcf_ol2gp_start
d162 2
a163 2
!    qtiesStart = 1
!   Calculate qtiesStart for the specific quantity below
d168 1
d193 1
a193 1
            & qtyTemplates ) ) )
d197 66
a262 156
     case ( s_fill )
          ! We can for now only fill vectors from either:
        ! (1) old l2gp file
        ! (2) old l2aux file
        ! (3) previously defined vector
        !          vectorName=""
        !          sourceName=""
        !          quantityName=""

          ! A Fill instruction, this contains just a vector name and quantity 
          ! and a source name assuming the same quantity
          ! e.g., Fill, state.quantity, source=oldState.quantity

        if ( nsons(key) < 3 ) call announce_error ( son, wrong_number )
        gson = subtree(2,key) ! First positional argument
        IF(node_id(gson) /= n_dot) then
           ! In case dotless
           vectorIndex = decoration(decoration(gson))
           quantityName=0
        ELSE
           ! Assume form : x.y
           vectorName=sub_rosa(subtree(1, gson))     ! x
           quantityName=sub_rosa(subtree(2, gson))   ! y
           vectorIndex = decoration(decoration(subtree(1, gson)))
        ENDIF

        DO j=3, nsons(key)
           gson = subtree(j,key) ! Now indexes n_assign
           SELECT CASE( decoration(subtree(1,gson)) )
              CASE(f_source)
                 ! source=vector.quantity
                 gson = subtree(2, gson) ! now indexes n_dot
                 sourceName=sub_rosa(subtree(1, gson))      ! vector
                 sourceIndex = decoration(subtree(1, gson))
                 IF(quantityName==0) THEN
                    quantityName=sub_rosa(subtree(2, gson)) ! quantity
                 ENDIF
!              CASE(f_method)
!              CASE(f_other)
              CASE DEFAULT ! Can't get here if tree_checker worked correctly
           END SELECT
        ENDDO

        CALL get_string(vectorName, vectorNameString)
        CALL get_string(quantityName, quantityNameString)
        CALL get_string(sourceName, sourceNameString)

!          vectorIndex=LinearSearchStringArray(vectors%name,&
!               & vectorName,caseInsensitive=.FALSE.)

         ! compute what quantity number the vector quantity corresponds to
         qtiesStart = whatQuantityNumber(vectorName, quantityName, &
         & vectors(vectorIndex)%Template)

         IF(qtiesStart < 0) THEN
!	Shouldn't get here if type-checker worked properly
              msr = 'Quantity Name ' // quantityNameString // &
              & ' not found among quantities assoc. with ' // vectorNameString
 !             CALL MLSMessage(MLSMSG_Error, ModuleName, &
 !                    & msr)
 				CALL announce_error(son, unknownQuantityName, msr)
         ENDIF
! Is our source of type l2gp or l2aux?
!  (As pw did it)
!         is_l2gp = .FALSE.
!         is_l2aux = .FALSE.
 
!         l2Index = 1
!         DO WHILE (.NOT. is_l2gp .AND. l2Index.LE.SIZE(L2GPDatabase))
!             IF(sourceName.EQ.L2GPDatabase(l2Index)%nameIndex) THEN
!                 is_l2gp = .TRUE.
!                 exit
!             ENDIF
!             l2Index = l2Index + 1
!         ENDDO
 
!         IF(.NOT. is_l2gp) THEN
!                l2Index = 1
!                DO WHILE (.NOT. is_l2aux .AND. l2Index.LE.SIZE(L2AUXDatabase))
!                    IF(sourceName.EQ.L2AUXDatabase(l2Index)%Name) THEN
!                        is_l2aux = .TRUE.
!                        exit
!                    ENDIF
!                    l2Index = l2Index + 1
!                ENDDO
!         ENDIF
! (As van simplified it)

! Under f90 and f95 if a do-loop ends w/o exit, its loop index
! is index_final_value + index_increment; thus the post-loop conditions
  do l2Index = 1, size(l2gpDatabase)
    if ( sourceName == l2gpDatabase(l2Index)%nameIndex ) exit
  end do
  is_l2gp = l2Index <= size(l2gpDatabase)

  if ( .not. is_l2gp ) then
    do l2Index = 1, size(l2auxDatabase)
      if ( sourceName == l2auxDatabase(l2Index)%name ) exit
    end do
    is_l2aux = l2Index <= size(l2auxDatabase)
  else

!   This isn't important--is_l2aux will not be checked if is_l2gp is TRUE--
!   but in case we check its value while debugging, say, lest it be undefined
  	is_l2aux = .FALSE.
  end if

  if ( .not. (is_l2gp .OR. is_l2aux)) then
    do l2Index = 1, size(vectors)
      if ( sourceName == vectors(l2Index)%name ) exit
    end do
    is_prev_vec = l2Index <= size(vectors)
  else

!   This isn't important--is_prev_vec will not be checked if others TRUE--
!   but in case we check its value while debugging, say, lest it be undefined
  	is_prev_vec = .FALSE.
  end if



! Fill
         IF(is_l2gp) THEN
 ! (1)   l2gp
                CALL FillOL2GPVector(L2GPDatabase(l2Index), qtyTemplates, &
                      & vectors(vectorIndex), quantityNameString, qtiesStart, &
                      & chunkNo, IERR)

         ELSEIF(is_l2aux) THEN
 ! (2)   l2aux
                CALL FillOL2AUXVector(L2AUXDatabase(l2Index), qtyTemplates, &
                      & vectors(vectorIndex), quantityNameString, qtiesStart, &
                      & chunkNo, IERR)

         ELSEIF(is_prev_vec) THEN
 ! (3)   previously defined vector  
                 PrevDefdQt = whatQuantityNumber(sourceName, quantityName, &
         &       vectors(sourceIndex)%Template)

                 IF(PrevDefdQt < 0) THEN
!	Shouldn't get here if type-checker worked properly
                  msr = 'Quantity Name ' // quantityNameString // &
              & ' not found among quantities assoc. with ' // sourceNameString
 				      CALL announce_error(son, unknownQuantityName, msr)
                ENDIF
                CALL FillPrevDefd(vectors(l2Index), PrevDefdQt, qtyTemplates, &
                      & vectors(vectorIndex), quantityNameString, qtiesStart, &
                      & chunkNo, IERR)

         ELSE
!                CALL MLSMessage(MLSMSG_Error, ModuleName, &
!                     & 'source file in neither l2gp nor l2aux databases')
					 CALL announce_error(son, source_not_in_db)
         ENDIF

!          qtiesStart = qtiesStart+1
d275 2
d289 1
a289 1
      call output ( DBLE(t2 - t1), advance = 'yes' )
d294 1
a294 1
! =====     Private Procedures     =====================================
d296 4
a299 4
!=============================== FillVector ==========================
SUBROUTINE FillVector(IERR, inArray, Vector, arrayType, vectorType, NumQtys, &
     & numChans, numSurfs, numInstances, qtiesStart, dim_order)
!=============================== FillVector ==========================
d301 2
a302 2
! Fill the vector Vector with values taken from the array inArray
! in a manner that depends on their respective types:
d304 2
a305 2
!        arrayType        vectorType            operation
!          l2gp              l2gp       vector(:,:,:) = inArray(:,:,:)
d307 2
a308 2
! It is assumed that the rank3 inArray is filled from
! inArray(1, 1, 1) to inArray(numChans, numSurfs, numInstances)
d310 84
a393 96
! With the redefinition of Vector%quantities to be a rank2 object
! we are faced with a problem: how to fill a rank 2 object from a rank 3 one?
! If the rank 3 object is full, then it use the following trick:
! Vector(1:numChans*numSurfs, 1:numInstances) = 
!                   inArray(1:numChans, 1:numSurfs, 1:numInstances)

CHARACTER (Len=*), INTENT(IN) ::        arrayType, vectorType
INTEGER, INTENT(OUT) ::                 IERR		! zero unless an error
! REAL(r8), POINTER, DIMENSION(:,:,:) ::  inPointer
REAL(r8), DIMENSION(:,:,:) ::           inArray
TYPE(Vector_T), INTENT(OUT) ::          Vector
INTEGER, INTENT(IN) ::                  NumQtys, qtiesStart
INTEGER, INTENT(IN) ::                  numInstances, numSurfs, numChans
INTEGER, INTENT(IN), OPTIONAL, DIMENSION(:) :: dim_order

! Private
CHARACTER (LEN=LineLen) ::              msr
INTEGER ::                              qty
CHARACTER (LEN=4) ::                    qtyChar, IERRChar

! Sanity checks:
IF(numChans.EQ.0) THEN
!	call announce_error ( ErrorInFillVector, numChansisZero )
	IERR = numChansisZero
        RETURN
ELSEIF(numSurfs.EQ.0) THEN
!	call announce_error ( ErrorInFillVector, numSurfsisZero )
	IERR = numSurfsisZero
        RETURN
ELSEIF(numInstances.EQ.0) THEN
!	call announce_error ( ErrorInFillVector, numInstancesisZero )
	IERR = numInstancesisZero
        RETURN
ENDIF

Vector%template%NoQuantities = NumQtys
SELECT CASE (arrayType(:4) // VectorType(:4))
CASE ('l2gpl2gp')
   DO qty = qtiesStart, qtiesStart - 1 + NumQtys
     WRITE(qtyChar, '(I4)') qty
     Vector%quantities(qty)%template%noChans = numChans
     Vector%quantities(qty)%template%noSurfs = numSurfs
     Vector%quantities(qty)%template%noInstances = numInstances    
!     CALL put_3d_view(inPointer, &
!        & numChans, &
!        & numSurfs, &
!        & numInstances, &
!        & Vector%quantities(qty)%values)
!     Vector%quantities(qty)%values = inPointer
!	IF(numChans.EQ.1) THEN
!        	Vector%quantities(qty)%values = inPointer(:, :, 1)
!	ELSEIF(numSurfs.EQ.1) THEN
!        	Vector%quantities(qty)%values = inPointer(:, 1, :)
!	ELSEIF(numInstances.EQ.1) THEN
!        	Vector%quantities(qty)%values = inPointer(1, :, :)
!        ELSE
!		call announce_error ( ErrorInFillVector, objIsFullRank3 )
!       		RETURN
!	ENDIF
	CALL squeeze(IERR, inArray, Vector%quantities(qty)%values)
!     WRITE(IERRChar, '(I4)') IERR
!     msr = 'Error #' // IERRChar // ' in squeezing l2gp into quantity ' // qtyChar
!     IF(IERR /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
!        & msr)
   ENDDO
CASE ('l2aul2au')
   DO qty = qtiesStart, qtiesStart - 1 + NumQtys
     WRITE(qtyChar, '(I4)') qty
     Vector%quantities(qty)%template%noChans = numChans
     Vector%quantities(qty)%template%noSurfs = numSurfs
     Vector%quantities(qty)%template%noInstances = numInstances
     IF(PRESENT(dim_order)) THEN
        CALL squeeze(IERR, inArray, Vector%quantities(qty)%values, dim_order)
     ELSE    
        CALL squeeze(IERR, inArray, Vector%quantities(qty)%values)
     ENDIF
!     WRITE(IERRChar, '(I4)') IERR
!     msr = 'Error #' // IERRChar // ' in squeezing l2aux into quantity ' // qtyChar
!     IF(IERR /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
!        & msr)
   ENDDO
CASE default
   ! FillVector not yet written to handle these cases
END SELECT

END SUBROUTINE FillVector

!=============================== FillOL2GPVector ==========================
SUBROUTINE FillOL2GPVector(OldL2GPData, qtyTemplates, &
& Output, QuantityName, qtiesStart, chunkNo, IERR)
!=============================== FillOL2GPVector ==========================

! If the times, pressures, and geolocations match,
! fill the vector Output with values taken from the appropriate quantity in
! Old L2GP vector OldL2GPData
! 
d395 52
a446 10
INTEGER, INTENT(IN) ::                            qtiesStart
TYPE(L2GPData_T) ::                               OldL2GPData
    type (QuantityTemplate_T), dimension(:), pointer :: qtyTemplates
!TYPE(L2GPData_T), DIMENSION(:), POINTER ::        L2GPDatabase
TYPE(Vector_T), INTENT(INOUT) ::                  Output
CHARACTER*(*), INTENT(IN) ::                      QuantityName
! If done chunk-by-chunk, the following is the chunk number
! Otherwise, chunkNo should = -1
    integer, intent(in) ::                        chunkNo
INTEGER, INTENT(OUT) ::                            IERR	! if error
d448 19
a466 174
! Local variables
!::::::::::::::::::::::::: LOCALS :::::::::::::::::::::
!TYPE(L2GPData_T) ::                               L2GPData
! INTEGER ::                                        Qty

REAL(r8) ::                                       TOLERANCE
PARAMETER(TOLERANCE=0.05)

! A wrong version compared ChunkNo to OLDL2GPData%ChunkNumbers
LOGICAL ChunkNumberIsTrustworthy
PARAMETER(ChunkNumberIsTrustworthy=.FALSE.)

type (QuantityTemplate_T) ::                      OQTemplate	! Output Quantity Template
INTEGER ::                                        i
INTEGER ::                                        ONTimes
!INTEGER ::                                        alloc_err
INTEGER ::                                        firstProfile, lastProfile
INTEGER ::                                        noL2GPValues=1
LOGICAL ::                                        TheyMatch
REAL(r8) ::                                       phiMin, phiMax
REAL(r8) ::                                       phi_TOLERANCE

OQTemplate = qtyTemplates(Output%TEMPLATE%QUANTITIES(qtiesStart))

IF(OQTemplate%noInstances <= 0) THEN
!   CALL MLSMessage(MLSMSG_Error, ModuleName, &
!        & 'Vector geolocations are 0 profiles or instances')
	IERR=zeroProfilesFound
	RETURN
ENDIF
! Chunk-by-chunk, or all chunks at once?
IF(chunkNo == -1) THEN
	firstProfile = 1
   lastProfile = OldL2GPData%nTimes
ELSEIF(ChunkNumberIsTrustworthy) THEN
	lastProfile = 1
   firstProfile = OldL2GPData%nTimes
	DO i=1, OldL2GPData%nTimes
        	IF(chunkNo == OldL2GPData%chunkNumber(i)) THEN
				firstProfile = MIN(firstProfile, i)
				lastProfile = MAX(lastProfile, i)
         ENDIF
   ENDDO
ELSE
! Instead of comparing OldL2GPData%chunkNumbers to ChunkNo
! we will compare geodetic angles to phi
	phiMin = OQTemplate%phi(1, 1)
	phiMax = OQTemplate%phi(1, 1)
	DO i=1, OQTemplate%noInstances
		phiMin = MIN(phiMin, OQTemplate%phi(1, i))
		phiMax = MAX(phiMax, OQTemplate%phi(1, i))
	ENDDO
	phi_TOLERANCE = TOLERANCE *(phiMax-phiMin) / OQTemplate%noInstances
	IF(phi_TOLERANCE <= 0.D0) THEN
!   	CALL MLSMessage(MLSMSG_Error, ModuleName, &
!        & 'phiMin==phiMax')
		  IERR=zeroGeodSpan
		RETURN
	ENDIF
	lastProfile = 1
   firstProfile = OldL2GPData%nTimes
	DO i=1, OldL2GPData%nTimes
        	IF(phiMin <= (OldL2GPData%geodAngle(i) + phi_TOLERANCE)) THEN
				firstProfile = MIN(firstProfile, i)
         ENDIF
        	IF(phiMax >= (OldL2GPData%geodAngle(i) - phi_TOLERANCE)) THEN
				lastProfile = MAX(lastProfile, i)
         ENDIF
   ENDDO
ENDIF
!
! Read the old L2GP file for QuantityName
!CALL ReadL2GPData(OL2FileHandle, TRIM(LowerCase(QuantityName)), &
!     & OldL2GPData, ONTimes)
! Allocate space for current l2gpdata
!ALLOCATE(l2gpData%pressures(OldL2GPData%nLevels),&
!     & l2gpData%latitude(ONTimes), &
!     & l2gpData%longitude(ONTimes), & 
!     & l2gpData%time(ONTimes), &
!     & l2gpData%solarTime(ONTimes), &
!     & l2gpData%solarZenith(ONTimes), &
!     & l2gpData%losAngle(ONTimes), &
!     & l2gpData%geodAngle(ONTimes), &
!     & l2gpData%chunkNumber(ONTimes), &
!     & l2gpData%frequency(OldL2GPData%nFreqs), &
!     & l2gpData%l2gpValue(OldL2GPData%nFreqs, OldL2GPData%nLevels, ONTimes), &
!     & l2gpData%l2gpPrecision(OldL2GPData%nFreqs, OldL2GPData%nLevels, ONTimes), &
!     & l2gpData%status(ONTimes), l2gpData%quality(ONTimes), &
!     & STAT=alloc_err)
!IF(alloc_err /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
!     & 'Failed to allocate temp l2gpData')
! Check that times, etc. match
!L2GPData    = L2GPDatabase(1)
TheyMatch = OQTemplate%noInstances .EQ. (lastProfile-firstProfile+1)
TheyMatch = TheyMatch .AND. OQTemplate%stacked
IF(TheyMatch) THEN
   DO i = firstProfile, lastProfile
      IF( &
        &   nearBy(OldL2GPData%latitude(i), OQTemplate%geodLat(1,i)) &
        & .AND. &
        &   nearBy(OldL2GPData%longitude(i), OQTemplate%lon(1,i)) &
        & .AND. &
        &   nearBy(OldL2GPData%solarTime(i), OQTemplate%solarTime(1,i)) &
        &) THEN
       ELSE
          TheyMatch = .FALSE.
          EXIT
      ENDIF
   END DO
ENDIF
IF(TheyMatch .AND. OldL2GPData%NLevels.EQ.OQTemplate%noSurfs) THEN
   DO i = 1, OldL2GPData%NLevels
      IF( &
        &   nearBy(OldL2GPData%pressures(i), OQTemplate%surfs(i,1)) &
        & ) THEN
     ELSE
       TheyMatch = .FALSE.
       EXIT
    ENDIF
   END DO
ENDIF
IF(TheyMatch) THEN
!   DO Qty=1, 
!   CALL put_3d_view(Output, &
!        & OldL2GPData%quantities(qty)%template%noFreqs, &
!        & OldL2GPData%quantities(qty)%template%noSurfs, &
!        & OldL2GPData%quantities(qty)%template%noInstances, &
!        & OldL2GPData%quantities(qty)%values)
   CALL FillVector(IERR, OldL2GPData%l2gpValue(:, :, firstProfile:lastProfile), &
        & Output, &
        & 'l2gp', 'l2gp', NoL2GPValues, &
        & OldL2GPData%nFreqs, &
        & OldL2GPData%nLevels, &
        & lastProfile-firstProfile+1, &
        & qtiesStart)
ELSE
!   CALL MLSMessage(MLSMSG_Error, ModuleName, &
!        & 'Vector and old L2GP do not match in times or geolocations')
	IERR=vectorWontMatchL2GP
ENDIF
!DEALLOCATE(l2gpData%pressures, &
!     & l2gpData%latitude, l2gpData%longitude, l2gpData%time, &
!     & l2gpData%solarTime, l2gpData%solarZenith, l2gpData%losAngle, &
!     & l2gpData%geodAngle, l2gpData%chunkNumber, &
!     & l2gpData%l2gpValue, l2gpData%frequency, &
!     & l2gpData%l2gpPrecision, l2gpData%status, l2gpData%quality, &
!     & STAT=alloc_err)
!IF(alloc_err /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
!     & 'Failed to deallocate temp l2gpData')
!
!DEALLOCATE(OldL2GPData%pressures, &
!     & OldL2GPData%latitude, l2gpData%longitude, OldL2GPData%time, &
!     & OldL2GPData%solarTime, OldL2GPData%solarZenith, OldL2GPData%losAngle, &
!     & OldL2GPData%geodAngle, OldL2GPData%chunkNumber, &
!     & OldL2GPData%l2gpValue, OldL2GPData%frequency, &
!     & OldL2GPData%l2gpPrecision, OldL2GPData%status, OldL2GPData%quality,&
!     & STAT=alloc_err)
!IF(alloc_err /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
!     & 'Failed to deallocate temp OldL2GPData')
END SUBROUTINE FillOL2GPVector

!=============================== FillPrevDefd ==========================
SUBROUTINE FillPrevDefd(OldVector, PrevDefdQt, qtyTemplates, &
& Output, QuantityName, qtiesStart, chunkNo, IERR)
!=============================== FillPrevDefd ==========================

! If the times, pressures, and geolocations match,
! fill the vector Output with values taken from the appropriate quantity in
! previously defined vector OldVector
! 

INTEGER, INTENT(IN) ::                            PrevDefdQt
INTEGER, INTENT(IN) ::                            qtiesStart
TYPE(Vector_T), INTENT(IN) ::                     OldVector
d468 4
a471 4
TYPE(Vector_T), INTENT(INOUT) ::                  Output
CHARACTER*(*), INTENT(IN) ::                      QuantityName
! If done chunk-by-chunk, the following is the chunk number
! Otherwise, chunkNo should = -1
d473 1
a473 1
INTEGER, INTENT(OUT) ::                            IERR	! if error
d475 2
a476 2
! Local variables
!::::::::::::::::::::::::: LOCALS :::::::::::::::::::::
d478 2
a479 2
REAL(r8) ::                                       TOLERANCE
PARAMETER(TOLERANCE=0.05)
d481 38
a518 38
! A wrong version compared ChunkNo to OldVector%ChunkNumbers
LOGICAL ChunkNumberIsTrustworthy
PARAMETER(ChunkNumberIsTrustworthy=.FALSE.)

type (QuantityTemplate_T) ::                      PDQTemplate	! Prev. def'd Quantity Template
type (QuantityTemplate_T) ::                      OQTemplate	! Output Quantity Template
INTEGER ::                                        i
INTEGER ::                                        firstProfile, lastProfile
INTEGER ::                                        noL2GPValues=1
LOGICAL ::                                        TheyMatch
REAL(r8) ::                                       phiMin, phiMax
REAL(r8) ::                                       phi_TOLERANCE

PDQTemplate = qtyTemplates(OldVector%TEMPLATE%QUANTITIES(PrevDefdQt))
OQTemplate = qtyTemplates(Output%TEMPLATE%QUANTITIES(qtiesStart))

IF(OQTemplate%noInstances <= 0) THEN
	IERR=zeroProfilesFound
	RETURN
ELSEIF(PDQTemplate%noInstances <= 0) THEN
	IERR=zeroProfilesFound
	RETURN
ENDIF
! Chunk-by-chunk, or all chunks at once?
IF(chunkNo == -1) THEN
	firstProfile = 1
   lastProfile = PDQTemplate%noInstances
ELSEIF(ChunkNumberIsTrustworthy) THEN
!	lastProfile = 1
!   firstProfile = PDQTemplate%noInstances
!	DO i=1, PDQTemplate%noInstances
!        	IF(chunkNo == OldVector%chunkNumber(i)) THEN
!				firstProfile = MIN(firstProfile, i)
!				lastProfile = MAX(lastProfile, i)
!         ENDIF
!   ENDDO
!Can't get here unless ChunkNumberIsTrustworthy has been reset
	CALL announce_error(0, miscellaneous_err, &
d521 25
a545 25
ELSE
! Instead of comparing OldVector%chunkNumbers to ChunkNo
! we will compare geodetic angles to phi
	phiMin = OQTemplate%phi(1, 1)
	phiMax = OQTemplate%phi(1, 1)
	DO i=1, OQTemplate%noInstances
		phiMin = MIN(phiMin, OQTemplate%phi(1, i))
		phiMax = MAX(phiMax, OQTemplate%phi(1, i))
	ENDDO
	phi_TOLERANCE = TOLERANCE *(phiMax-phiMin) / OQTemplate%noInstances
	IF(phi_TOLERANCE <= 0.D0) THEN
		  IERR=zeroGeodSpan
		RETURN
	ENDIF
	lastProfile = 1
   firstProfile = PDQTemplate%noInstances
	DO i=1, PDQTemplate%noInstances
        	IF(phiMin <= (PDQTemplate%phi(1, i) + phi_TOLERANCE)) THEN
				firstProfile = MIN(firstProfile, i)
         ENDIF
        	IF(phiMax >= (PDQTemplate%phi(1, i) - phi_TOLERANCE)) THEN
				lastProfile = MAX(lastProfile, i)
         ENDIF
   ENDDO
ENDIF
d547 54
a600 54
TheyMatch = OQTemplate%noInstances .EQ. (lastProfile-firstProfile+1)
TheyMatch = TheyMatch &
& .AND. &
& (OQTemplate%stacked .eqv. PDQTemplate%stacked) &
& .AND. &
& (OQTemplate%coherent .eqv. PDQTemplate%coherent) &
& .AND. &
& (OQTemplate%regular .eqv. PDQTemplate%regular) 
IF(TheyMatch) THEN
   DO i = firstProfile, lastProfile
      IF( &
        &   nearBy(PDQTemplate%geodLat(1,i), OQTemplate%geodLat(1,i)) &
        & .AND. &
        &   nearBy(PDQTemplate%lon(1,i), OQTemplate%lon(1,i)) &
        & .AND. &
        &   nearBy(PDQTemplate%solarTime(1,i), OQTemplate%solarTime(1,i)) &
        &) THEN
       ELSE
          TheyMatch = .FALSE.
          EXIT
      ENDIF
   END DO
ENDIF
IF( TheyMatch &
& .AND. &
& PDQTemplate%noSurfs == OQTemplate%noSurfs &
& .AND. &
& PDQTemplate%noSurfs == 1 ) THEN
   DO i = 1, OQTemplate%noSurfs
      IF( &
        &   nearBy(PDQTemplate%surfs(i,1), OQTemplate%surfs(i,1)) &
        & ) THEN
     ELSE
       TheyMatch = .FALSE.
       EXIT
    ENDIF
   END DO
ENDIF
IF(TheyMatch) THEN
	Output%quantities(qtiesStart)%values = OldVector%quantities(PrevDefdQt)%values
ELSE
	IERR=vectorWontMatchPDef
ENDIF
END SUBROUTINE FillPrevDefd

!=============================== FillOL2AUXVector ==========================
SUBROUTINE FillOL2AUXVector(OldL2AUXData, qtyTemplates, &
& Output, QuantityName, qtiesStart, chunkNo, IERR)
!=============================== FillOL2AUXVector ==========================

! If the times, pressures, and geolocations match,
! fill the vector Output with values taken from the
! Old L2AUX vector OldL2AUXData
! 
d602 2
a603 2
INTEGER, INTENT(IN) ::                            qtiesStart
TYPE(L2AUXData_T) ::                               OldL2AUXData
d605 3
a607 3
!TYPE(L2GPData_T), DIMENSION(:), POINTER ::        L2GPDatabase
TYPE(Vector_T), INTENT(INOUT) ::                  Output
CHARACTER*(*), INTENT(IN) ::                      QuantityName
d609 1
a609 1
INTEGER, INTENT(OUT) ::                            IERR	! if error
d611 34
a644 34
! Local variables
!::::::::::::::::::::::::: LOCALS :::::::::::::::::::::
type (QuantityTemplate_T) ::                      OQTemplate	! Output Quantity Template
INTEGER ::                                        OQType	! Ouptut quantity type
INTEGER ::                                        OQNVals	! No. Ouptut quantity vals
INTEGER ::                                        ChanDim	! which dim no. is channel
INTEGER ::                                        IntFreqDim	! which dim no. is int. frq.
INTEGER ::                                        USBDim	! which dim no. is USB
INTEGER ::                                        LSBDim	! which dim no. is LSB
INTEGER ::                                        MAFDim	! which dim no. is MAF
INTEGER ::                                        MIFDim	! which dim no. is MIF
INTEGER ::                                        L2NVals	! No. l2 aux vals
INTEGER ::                                        i
LOGICAL ::                                        TheyMatch
! This will let us re-order the vector dimensions differently from the l2aux
INTEGER, DIMENSION(3) ::                          dim_order

! Properties of Output Vector
OQTemplate = qtyTemplates(Output%TEMPLATE%QUANTITIES(qtiesStart))
OQType = OQtemplate%quantityType
OQNVals = OQtemplate%noInstances*OQtemplate%noSurfs*OQtemplate%noChans

! Properties of l2 aux
ChanDim = 0
IntFreqDim = 0
USBDim = 0
LSBDim = 0
MAFDim = 0
MIFDim = 0
L2NVals = 1
DO i=1, OldL2AUXData%noDimensionsUsed
    L2NVals = L2NVals*OldL2AUXData%dimensions(i)%noValues
    SELECT CASE(OldL2AUXData%dimensions(i)%dimensionFamily)
    CASE(L2AUXDim_Channel)
d647 1
a647 1
    CASE(L2AUXDim_IntermediateFrequency)
d649 1
a649 1
    CASE(L2AUXDim_USBFrequency)
d651 1
a651 1
    CASE(L2AUXDim_LSBFrequency)
d653 1
a653 1
    CASE(L2AUXDim_MIF)
d655 1
a655 1
    CASE(L2AUXDim_MAF)
d657 4
a660 4
    CASE DEFAULT	! We are not yet interested in these dimensions
    END SELECT
    
ENDDO
d662 7
a668 7
! Check that the dimensions match up and are of the same family
TheyMatch = OQNVals == L2NVals
IF(OQTemplate%minorFrame) THEN
	TheyMatch = TheyMatch .AND. MIFDim > 0
ENDIF
IF(OQTemplate%noChans > 0) THEN
	TheyMatch = TheyMatch .AND. &
d670 1
a670 1
ENDIF
d672 2
a673 2
IF(TheyMatch) THEN
   CALL FillVector(IERR, OldL2AUXData%values, Output, &
d675 3
a677 3
        & MAX(OldL2AUXData%dimensions(1)%noValues, 1), &
        & MAX(OldL2AUXData%dimensions(2)%noValues, 1), &
        & MAX(OldL2AUXData%dimensions(3)%noValues, 1), &
d679 113
a791 52
ELSE
!   CALL MLSMessage(MLSMSG_Error, ModuleName, &
!        & 'Vector and old L2AUX do not match')
	IERR=cantFillFromL2AUX
ENDIF

END SUBROUTINE FillOL2AUXVector

!=============================== nearby ==========================
FUNCTION nearby(x, y, inRelSmall, inOverallTol)
!=============================== nearby ==========================
! This functions returns TRUE if x and y are "nearby" comparing either
! their relative difference (proportionally small) 
! or their differences with an overall tolerance
REAL(r8), INTENT(IN) ::              x, y
REAL(r8), INTENT(IN), OPTIONAL ::    inRelSmall
REAL(r8), INTENT(IN), OPTIONAL ::    inOverallTol

! result
LOGICAL ::                           nearby

! Private
REAL(r8) ::                          small=1.D-32
REAL(r8) ::                          tolerance=0.D0

IF(PRESENT(inRelSmall)) THEN
    small = inRelSmall
ENDIF

IF(PRESENT(inOverallTol)) THEN
    tolerance = inOverallTol
ENDIF

IF(ABS(x-y) <= tolerance) THEN
   nearby = .TRUE.
ELSEIF(x*y /= 0) THEN
   nearby = ABS(x-y) .LT. small*SQRT(ABS(x))*SQRT(ABS(y))
ELSEIF(x /= 0) THEN
   nearby = ABS(x-y) .LT. small*ABS(x)
ELSE
   nearby=.TRUE.
ENDIF

END FUNCTION nearby

!=============================== whatQuantityNumber ==========================
FUNCTION whatQuantityNumber(x, y, xVectorTemplate)
!=============================== whatQuantityNumber ==========================
! This functions returns the quantity number of quantity y in vector x
! where x and y are sub-rosa indexes of their actual names;
! i.e., they are specified in the cf as name[x].name[y]
! where name[x] = get_char(x), name[y] = get_char[y]
d793 14
a806 14
! If the quantity is not found, it returns FAILED (-1)
INTEGER, INTENT(IN) ::               x, y
type (VectorTemplate_T)  ::          xVectorTemplate

! result
INTEGER ::                           whatQuantityNumber

! Private
INTEGER, PARAMETER ::                FAILED=-1
INTEGER              ::              qty

whatQuantityNumber = FAILED
DO qty = 1, xVectorTemplate%NoQuantities
    IF(xVectorTemplate%Name == y) THEN
d808 9
a816 9
        EXIT
    ENDIF
ENDDO

END FUNCTION whatQuantityNumber

!=============================== squeeze ==========================
SUBROUTINE squeeze(IERR, source, sink, source_order)
!=============================== squeeze ==========================
d819 1
a819 1
    ! unless it can't--then it returns iERR /= 0
d821 1
a821 1
    !
d824 1
a824 1
    ! then we must further assume (else set IERR)
d827 1
a827 1
    !
d833 1
a833 1
    !
d838 4
a841 4
    REAL(r8), DIMENSION(:,:,:), INTENT(IN) :: source
    REAL(r8), DIMENSION(:,:), INTENT(OUT)  :: sink
    INTEGER, INTENT(OUT)                   :: IERR
    INTEGER, INTENT(IN), OPTIONAL, DIMENSION(:) :: source_order
d844 6
a849 6
    
    INTEGER, DIMENSION(4) :: source_shape
    INTEGER, DIMENSION(4) :: sink_shape
    INTEGER, DIMENSION(4) :: temp_shape
    INTEGER::i,icode,offset
    REAL(r8), DIMENSION(:,:,:), ALLOCATABLE :: temp
d854 50
a903 50
    IF (source_shape(1) == 0) THEN
    	IERR = n1_is_zero
        RETURN
    ELSEIF (source_shape(2) == 0) THEN
    	IERR = n2_is_zero
        RETURN
    ELSEIF (source_shape(3) == 0) THEN
    	IERR = n3_is_zero
        RETURN
    ELSEIF (sink_shape(1) < source_shape(1)*source_shape(2)) THEN
    	IERR = m1_too_small
        RETURN
    ELSEIF (sink_shape(2) < source_shape(3)) THEN
    	IERR = m2_too_small
        RETURN
    ELSE
    	IERR = 0
    ENDIF

    IF(PRESENT(source_order)) THEN
!        Check that source_order is a legal permutation of (1 2 3)
!        using trick: sum and product must each equal 6
        IF(source_order(1)+source_order(2)+source_order(3) /= 6 &
        & .OR. &
        & source_order(1)*source_order(2)*source_order(3) /= 6 ) THEN
             IERR=not_permutation
             RETURN
        ENDIF
        DO i=1, 3
           temp_shape(i) = source_shape(source_order(i))
        ENDDO
        ALLOCATE(temp(temp_shape(1), temp_shape(2), temp_shape(3)), &
        & STAT=IERR)
        IF(IERR /= 0) THEN
        	IERR=allocation_err
                RETURN
        ENDIF
        temp = reshape(source, temp_shape(1:3), order=source_order(1:3))
        sink = reshape(temp, sink_shape(1:2))
        DEALLOCATE(temp, &
        & STAT=IERR)
        IF(IERR /= 0) THEN
        	IERR=deallocation_err
                RETURN
        ENDIF
    ELSE
        sink = reshape(source, sink_shape(1:2))
    ENDIF
    
END SUBROUTINE squeeze
d908 2
a909 2
  subroutine ANNOUNCE_ERROR ( WHERE, CODE , ExtraMessage)
    integer, intent(in) :: WHERE   ! Tree node where error was noticed
d911 1
a911 1
	 CHARACTER (LEN=*), OPTIONAL :: ExtraMessage
d920 2
d962 10
d975 3
a977 3
    IF( PRESENT(ExtraMessage)) THEN
      CALL output(ExtraMessage)
	 ENDIF
d980 1
a980 1
!=============================================================================
d986 3
@


2.14
log
@Can fill from prev. defd. vector
@
text
@d100 1
d182 2
a183 1
        IF(node_id(subtree(2, key)) /= n_dot) then
d185 1
a185 1
           vectorIndex = decoration(decoration(subtree(2,subtree(2,key))))
d189 3
a191 4
           J = subtree(2, subtree(2, key))
           vectorName=sub_rosa(subtree(2, J))     ! x
           quantityName=sub_rosa(subtree(3, J))   ! y
           vectorIndex = decoration(subtree(2, J))
d194 3
a196 2
        DO J=3, nsons(key)
           SELECT CASE( decoration(subtree(1,decoration(subtree(J,key)))) )
d199 3
a201 2
                 sourceName=sub_rosa(subtree(J, subtree(2, key)))
                 sourceIndex = decoration(subtree(2, J))
d203 1
a203 1
                    quantityName=sub_rosa(subtree(3, subtree(J, key)))   ! y
d1097 3
@


2.13
log
@Using announce_error, simplified
@
text
@d42 3
a44 3
  integer, parameter :: zeroProfilesInL2GP = source_not_in_db+1
  integer, parameter :: zeroGeodSpanInL2GP = zeroProfilesInL2GP+1
  integer, parameter :: vectorWontMatchL2GP = zeroGeodSpanInL2GP+1
d46 1
d48 1
a48 1
  integer, parameter :: numInstancesisZero = cantFillFromL2AUX+1
d64 3
d100 1
d102 1
a102 1
    integer :: I, J                ! Loop indices for section, spec
d104 2
d107 5
d113 2
a117 3
    integer :: quantityName        ! Sub-rosa index
    integer :: sourceName          ! Sub-rosa index
    integer :: l2Index             ! Where source is among l2gp or l2aux database
a120 5
    LOGICAL :: is_l2gp, is_l2aux

    ! These should be moved into open_init some day soon
!    INTEGER :: mlspcf_ol2gp_start=22000
!    INTEGER :: mlspcf_ol2gp_end=22050
a122 4
    INTEGER :: qtiesStart
    CHARACTER (LEN=LineLen) ::              msr
    REAL :: T1, T2     ! for timing
    logical :: TIMING
d169 3
a171 2
        ! old l2gp file
        ! old l2aux file
d198 1
d272 12
d288 1
d294 1
d299 15
d501 1
a501 1
	IERR=zeroProfilesInL2GP
d530 1
a530 1
		  IERR=zeroGeodSpanInL2GP
d635 138
d1046 4
a1049 4
    case ( zeroProfilesInL2GP )
      call output ( " command found zero profiles in L2GP.", advance='yes' )
    case ( zeroGeodSpanInL2GP )
      call output ( " command found zero geod. ang. span in L2GP.", advance='yes' )
d1054 2
d1094 3
@


2.12
log
@Chunk bounds determined by geodet.ang.
@
text
@d9 1
a9 1
  use INIT_TABLES_MODULE, only: F_SOURCE, S_TIME, S_VECTOR ! Later, s_Fill
d17 1
a17 1
  use MLSMessageModule, only: MLSMSG_Error, MLSMessage
d38 1
a38 1
  ! Error codes for "announce_error"
d40 22
d63 1
a63 1
  integer, parameter :: s_Fill = 0   ! to be replaced by entry in init_tables_module
d96 1
d216 1
d219 3
a221 2
              CALL MLSMessage(MLSMSG_Error, ModuleName, &
                     & msr)
d224 3
a226 2
         is_l2gp = .FALSE.
         is_l2aux = .FALSE.
d228 8
a235 8
         l2Index = 1
         DO WHILE (.NOT. is_l2gp .AND. l2Index.LE.SIZE(L2GPDatabase))
             IF(sourceName.EQ.L2GPDatabase(l2Index)%nameIndex) THEN
                 is_l2gp = .TRUE.
                 exit
             ENDIF
             l2Index = l2Index + 1
         ENDDO
d237 32
a268 10
         IF(.NOT. is_l2gp) THEN
                l2Index = 1
                DO WHILE (.NOT. is_l2aux .AND. l2Index.LE.SIZE(L2AUXDatabase))
                    IF(sourceName.EQ.L2AUXDatabase(l2Index)%Name) THEN
                        is_l2aux = .TRUE.
                        exit
                    ENDIF
                    l2Index = l2Index + 1
                ENDDO
         ENDIF
d274 1
a274 1
                      & chunkNo)
d279 1
a279 1
                      & chunkNo)
d282 3
a284 2
                CALL MLSMessage(MLSMSG_Error, ModuleName, &
                     & 'source file in neither l2gp nor l2aux databases')
a285 1
          ! This is *not* going to work if you have more than one vector
d287 1
a287 1
          qtiesStart = qtiesStart+1
d320 1
a320 1
SUBROUTINE FillVector(inPointer, Vector, pointerType, vectorType, NumQtys, &
d324 1
a324 1
! Fill the vector Vector with values taken from the array pointed to by inPointer
d327 2
a328 2
!        pointerType        vectorType            operation
!          l2gp              l2gp       vector(:,:,:) = pointer(:,:,:)
d330 2
a331 2
! It is assumed that the rank3 Pointer is filled from
! Pointer(1, 1, 1) to Pointer(numChans, numSurfs, numInstances)
d337 1
a337 1
!                   Pointer(1:numChans, 1:numSurfs, 1:numInstances)
d339 2
a340 1
CHARACTER (Len=*), INTENT(IN) ::        pointerType, vectorType
d342 1
a342 1
REAL(r8), DIMENSION(:,:,:) ::           inPointer
d350 1
a350 1
INTEGER ::                              qty, IERR
a351 6
! Error codes
INTEGER ::                              numInstancesisZero=1
INTEGER ::                              numSurfsisZero=2
INTEGER ::                              numChansisZero=3
INTEGER ::                              objIsFullRank3=4
INTEGER ::                              ErrorInFillVector=-999
d355 2
a356 1
	call announce_error ( ErrorInFillVector, numChansisZero )
d359 2
a360 1
	call announce_error ( ErrorInFillVector, numSurfsisZero )
d363 2
a364 1
	call announce_error ( ErrorInFillVector, numInstancesisZero )
d369 1
a369 1
SELECT CASE (PointerType(:4) // VectorType(:4))
d392 5
a396 5
	CALL squeeze(IERR, inPointer, Vector%quantities(qty)%values)
     WRITE(IERRChar, '(I4)') IERR
     msr = 'Error #' // IERRChar // ' in squeezing l2gp into quantity ' // qtyChar
     IF(IERR /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
        & msr)
d405 1
a405 1
        CALL squeeze(IERR, inPointer, Vector%quantities(qty)%values, dim_order)
d407 1
a407 1
        CALL squeeze(IERR, inPointer, Vector%quantities(qty)%values)
d409 4
a412 4
     WRITE(IERRChar, '(I4)') IERR
     msr = 'Error #' // IERRChar // ' in squeezing l2aux into quantity ' // qtyChar
     IF(IERR /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
        & msr)
d422 1
a422 1
& Output, QuantityName, qtiesStart, chunkNo)
d438 2
a439 1
    integer, intent(in) :: chunkNo
d456 1
a456 1
INTEGER ::                                        alloc_err
d466 3
a468 2
   CALL MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Vector geolocations are 0 profiles or instances')
d495 3
a497 2
   	CALL MLSMessage(MLSMSG_Error, ModuleName, &
        & 'phiMin==phiMax')
d569 1
a569 1
   CALL FillVector(OldL2GPData%l2gpValue(:, :, firstProfile:lastProfile), &
d577 3
a579 2
   CALL MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Vector and old L2GP do not match in times or geolocations')
d604 1
a604 1
& Output, QuantityName, qtiesStart, chunkNo)
d619 1
d683 1
a683 1
   CALL FillVector(OldL2AUXData%values, Output, &
d690 3
a692 2
   CALL MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Vector and old L2AUX do not match')
a792 9
    ! Error codes
    INTEGER               :: n1_is_zero = 1
    INTEGER               :: n2_is_zero = 2
    INTEGER               :: n3_is_zero = 3
    INTEGER               :: m1_too_small = 4
    INTEGER               :: m2_too_small = 5
    INTEGER               :: not_permutation = 6
    INTEGER               :: allocation_err = 7
    INTEGER               :: deallocation_err = 8
d828 1
a828 1
             IERR=6
d857 1
a857 1
  subroutine ANNOUNCE_ERROR ( WHERE, CODE )
d860 1
d866 2
a869 2
      call output ( "The " );
      call dump_tree_node ( where, 0 )
d871 38
d910 3
d921 3
@


2.11
log
@Changed types of t1, t2 to real
@
text
@d398 8
d413 2
d417 6
d427 9
d437 16
a452 2
	firstProfile = 1
   lastProfile = OldL2GPData%nTimes
d454 1
a454 1
        	IF(chunkNo == OldL2GPData%chunkNumber(i)) THEN
d456 2
d836 3
@


2.10
log
@Accounts for chunking when filling from old L2GP
@
text
@d96 1
a96 1
    double precision :: T1, T2     ! for timing
d264 1
a264 1
      call output ( t2 - t1, advance = 'yes' )
d795 3
@


2.9
log
@added whatquantitynumber
@
text
@d16 1
a16 1
  use MLSCommon, only: L1BInfo_T, NameLen, LineLen, R8
d56 1
a56 1
    & qtyTemplates , L2GPDatabase, L2AUXDatabase)
d70 2
d225 2
a226 1
                      & vectors(vectorIndex), quantityNameString, qtiesStart)
d230 2
a231 1
                      & vectors(vectorIndex), quantityNameString, qtiesStart)
d292 2
a293 1
REAL(r8), POINTER, DIMENSION(:,:,:) ::  inPointer
d376 1
a376 1
& Output, QuantityName, qtiesStart)
d390 3
d402 1
d407 14
d444 1
a444 1
TheyMatch = OQTemplate%noInstances .EQ. OldL2GPData%nTimes
d447 1
a447 1
   DO i = 1, OldL2GPData%nTimes
d479 2
a480 1
   CALL FillVector(OldL2GPData%l2gpValue, Output, &
d484 1
a484 1
        & OldL2GPData%nTimes, &
d513 1
a513 1
& Output, QuantityName, qtiesStart)
d527 1
d795 3
@


2.8
log
@Completed FillOL2AUXData; changed squeeze, nearby
@
text
@d93 1
d106 2
a107 2
    qtiesStart = 1

d186 10
a195 1

d219 1
a219 1
         
d616 29
d770 3
@


2.7
log
@Added FillOL2AUXVector
@
text
@a7 2
  USE L2GPData
  USE L2AUXData
d11 4
d16 3
a18 2
  use MLSCommon, only: L1BInfo_T, NameLen
  use MLSStrings, only: lowercase
d203 1
a203 1
                        is_l2gp = .TRUE.
d215 1
a215 1
         ELSE
d219 3
d259 1
a259 1
     & numChans, numSurfs, numInstances, qtiesStart)
d282 1
d285 1
d287 1
d311 1
d331 21
a351 1
	CALL squeeze(inPointer, Vector%quantities(qty)%values, IERR)
d454 1
a454 1
        & 'Old and new L2GPData don''t match in times or geolocations')
d483 1
a483 1
! fill the vector Output with values taken from the appropriate quantity in
d494 73
d570 1
a570 1
FUNCTION nearby(x, y)
d572 3
a574 2
! This functions returns TRUE if x and y are "nearby" compared
! with their moduli (proportionally small) and an overall tolerance
d576 2
d584 1
a584 1
! REAL(r8) ::                          tolerance=1.D-32
d586 11
a596 1
IF(x*y /= 0) THEN
d607 1
a607 1
SUBROUTINE squeeze(source, sink, IERR)
d620 6
d633 1
d642 3
d648 1
d650 1
d674 29
a702 1
    sink = reshape(source, sink_shape(1:2))
d731 3
@


2.6
log
@functions properly moved to read a priori
@
text
@d9 1
d53 1
a53 1
    & qtyTemplates , L2GPDatabase)
d66 1
d78 1
d82 1
a82 1

d137 3
a139 1
          ! We can only fill vectors from an old l2gp file for now
a180 2
          CALL FillOL2GPVector(L2GPDatabase(1), qtyTemplates, &
               & vectors(vectorIndex), quantityNameString, qtiesStart)
d182 35
d447 19
d575 3
@


2.5
log
@Implement timing.
@
text
@d14 1
d82 2
a83 2
    INTEGER :: mlspcf_ol2gp_start=22000
    INTEGER :: mlspcf_ol2gp_end=22050
d85 1
a85 1
    INTEGER :: OL2FileHandle
d96 1
a96 1
    OL2FileHandle = mlspcf_ol2gp_start
d176 1
a176 1
          CALL FillOL2GPVector(OL2FileHandle, L2GPDatabase, &
d292 2
a293 2
SUBROUTINE FillOL2GPVector( OL2FileHandle, L2GPDatabase, Output, QuantityName,&
qtiesStart)
d301 4
a304 2
INTEGER, INTENT(IN) ::                            OL2FileHandle, qtiesStart
TYPE(L2GPData_T), DIMENSION(:), POINTER ::        L2GPDatabase
d310 1
a310 2
TYPE(L2GPData_T) ::                               L2GPData
TYPE(L2GPData_T) ::                               OldL2GPData
d312 1
d319 1
d322 2
a323 2
CALL ReadL2GPData(OL2FileHandle, TRIM(LowerCase(QuantityName)), &
     & OldL2GPData, ONTimes)
d325 16
a340 16
ALLOCATE(l2gpData%pressures(OldL2GPData%nLevels),&
     & l2gpData%latitude(ONTimes), &
     & l2gpData%longitude(ONTimes), & 
     & l2gpData%time(ONTimes), &
     & l2gpData%solarTime(ONTimes), &
     & l2gpData%solarZenith(ONTimes), &
     & l2gpData%losAngle(ONTimes), &
     & l2gpData%geodAngle(ONTimes), &
     & l2gpData%chunkNumber(ONTimes), &
     & l2gpData%frequency(OldL2GPData%nFreqs), &
     & l2gpData%l2gpValue(OldL2GPData%nFreqs, OldL2GPData%nLevels, ONTimes), &
     & l2gpData%l2gpPrecision(OldL2GPData%nFreqs, OldL2GPData%nLevels, ONTimes), &
     & l2gpData%status(ONTimes), l2gpData%quality(ONTimes), &
     & STAT=alloc_err)
IF(alloc_err /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
     & 'Failed to allocate temp l2gpData')
d342 3
a344 2
L2GPData    = L2GPDatabase(1)
TheyMatch = ONTimes .EQ. L2GPData%nTimes
d348 1
a348 1
        &   nearBy(OldL2GPData%latitude(i), L2GPData%latitude(i)) &
d350 1
a350 1
        &   nearBy(OldL2GPData%longitude(i), L2GPData%longitude(i)) &
d352 1
a352 1
        &   nearBy(OldL2GPData%solarTime(i), L2GPData%solarTime(i)) &
d360 1
a360 1
IF(TheyMatch) THEN
d363 1
a363 1
        &   nearBy(OldL2GPData%latitude(i), L2GPData%latitude(i)) &
d388 9
a396 9
DEALLOCATE(l2gpData%pressures, &
     & l2gpData%latitude, l2gpData%longitude, l2gpData%time, &
     & l2gpData%solarTime, l2gpData%solarZenith, l2gpData%losAngle, &
     & l2gpData%geodAngle, l2gpData%chunkNumber, &
     & l2gpData%l2gpValue, l2gpData%frequency, &
     & l2gpData%l2gpPrecision, l2gpData%status, l2gpData%quality, &
     & STAT=alloc_err)
IF(alloc_err /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
     & 'Failed to deallocate temp l2gpData')
d398 9
a406 9
DEALLOCATE(OldL2GPData%pressures, &
     & OldL2GPData%latitude, l2gpData%longitude, OldL2GPData%time, &
     & OldL2GPData%solarTime, OldL2GPData%solarZenith, OldL2GPData%losAngle, &
     & OldL2GPData%geodAngle, OldL2GPData%chunkNumber, &
     & OldL2GPData%l2gpValue, OldL2GPData%frequency, &
     & OldL2GPData%l2gpPrecision, OldL2GPData%status, OldL2GPData%quality,&
     & STAT=alloc_err)
IF(alloc_err /= 0) CALL MLSMessage(MLSMSG_Error, ModuleName, &
     & 'Failed to deallocate temp OldL2GPData')
a492 26
!=============================== lowercase ==========================
FUNCTION lowercase(str) RESULT (outstr)
!=============================== lowercase ==========================
    ! takes A-Z and replaces with a-z 
    ! leaving other chars alone
    !--------Argument--------!
    CHARACTER (LEN=*), INTENT(IN) :: str
    CHARACTER (LEN=LEN(str)) :: outstr

    !----------Local vars----------!
    CHARACTER(LEN=LEN(STR))::capstr
    INTEGER::i,icode,offset
    !----------Executable part----------!
    capstr=str
    offset=ICHAR("a")-ICHAR("A")

    DO i=1,LEN(str)
       icode=ICHAR(capstr(i:i))
       IF ( icode >=ICHAR("A") .AND. icode <= ICHAR("Z")) THEN
          capstr(i:i)=char(icode+offset)
       ENDIF
    ENDDO

    outstr=capstr
END FUNCTION lowercase

d518 3
@


2.4
log
@Adapted for rank2 vectorsModule
@
text
@d10 2
a11 1
  use INIT_TABLES_MODULE, only: S_VECTOR,F_SOURCE   ! Later, s_Fill will be added
d86 2
d90 1
d182 7
d199 9
d539 3
@


2.3
log
@Fills from old l2gp data
@
text
@d193 2
a194 2
SUBROUTINE FillVector(Pointer, Vector, pointerType, vectorType, NumQtys, &
     & numInstances, numSurfs, numChans, qtiesStart)
d197 1
a197 1
! Fill the vector Vector with values taken from the array pointed to by pointer
d203 9
d213 1
a213 1
REAL(r8), POINTER, DIMENSION(:,:,:) ::  Pointer
d219 19
a237 1
INTEGER ::                              qty
d246 1
a246 1
!     CALL put_3d_view(Pointer, &
d251 12
a262 1
     Vector%quantities(qty)%values = Pointer
d408 60
d519 3
@


2.2
log
@Removed old log entries in file.
@
text
@d8 1
d10 1
a10 1
  use INIT_TABLES_MODULE, only: S_VECTOR
d12 1
a12 1
  use MLSCommon, only: L1BInfo_T
d15 1
d20 1
a20 1
  use TREE_TYPES, only: N_NAMED
d35 1
d50 1
a50 1
    & qtyTemplates )
d62 1
d72 13
d90 7
d128 49
a176 1
!     case ( s_fill )
d192 206
d421 3
@


1.1
log
@First version
@
text
@d5 1
a5 1
MODULE Fill                     ! Create vectors and fill them.
d8 24
a31 5
  USE MLSCommon
  USE MLSMessageModule
  USE MLSStrings
  USE GriddedData
  USE VectorsModule
a32 4
  IMPLICIT NONE
  PUBLIC
  
  PRIVATE :: Id, ModuleName
d34 3
a36 3
  CHARACTER (LEN=256) :: Id = &
       "$Id: Fill.f90,v 1.1 2000/01/21 21:04:06 livesey Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: Fill.f90,v $"
d42 3
a44 1
  CONTAINS
d46 2
a47 1
  !---------------------------------------------------------------------------
a51 2
  SUBROUTINE MLSL2Fill(mlscf,l1bInfo,aprioriData, vectorTemplates, vectors)

d53 6
a58 5
    TYPE (MLSCF_T), INTENT(IN) :: mlscf
    TYPE (L1BInfo_T), INTENT(IN) :: l1bInfo
    TYPE (GriddedData_T), DIMENSION(:), POINTER :: aprioriData
    TYPE (VectorTemplate_T), DIMENSION(:), POINTER :: vectorTemplates
    TYPE (Vector_T), DIMENSION(:), POINTER :: vectors
d61 7
a67 6
    TYPE (MLSCFSection_T) :: mlscfSection
    INTEGER :: mlscfLine,mlscfCell
    CHARACTER (LEN=NameLen) :: vectorName,templateName
    TYPE (MLSCFCell_T) :: cell
    TYPE (Vector_T) :: newVector
    INTEGER :: templateIndex,vectorIndex
d71 1
a71 4
    ! Get the relevant section of the configuration file
    mlscfSection=GetMLSCFSection(mlscf,"Fill")

    ! Now we simply loop over the lines in the configuration file
d73 63
a135 53
    DO mlscfLine=1,mlscfSection%noSectionEntries
       ! Each line is either a CREATE, or a FILL

       SELECT CASE (TRIM(Capitalize(mlscfSection%entries(mlscfLine)% &
            & mlscfEntryName)))
       CASE ("CREATE")
          vectorName=""
          templateName=""
          ! A Create instruction, this contains just a name and a template name
          DO mlscfCell=1,mlscfSection%entries(mlscfLine)%mlscfEntryNoKeys
             cell=mlscfSection%entries(mlscfLine)%cells(mlscfCell)
             SELECT CASE(TRIM(cell%keyword))
             CASE ("NAME")
                vectorName=cell%charValue
             CASE ("TEMPLATE")
                templateName=cell%charValue
             CASE DEFAULT
                CALL MLSMessage(MLSMSG_Error,ModuleName,&
                     & "Invalid cell in create instruction")
             END SELECT
          END DO
          
          ! Now do a sanity check
          IF (ASSOCIATED(vectors)) THEN
             IF (LinearSearchStringArray(vectors%name,vectorName,&
                  & caseInsensitive=.FALSE.)/=0) CALL MLSMessage(MLSMSG_Error,&
                  & ModuleName,"A vector named "//vectorName//&
                  & " already exists")
          END IF
          IF (.NOT. ASSOCIATED(vectorTemplates)) CALL MLSMessage(&
               & MLSMSG_Error,ModuleName,"There are no vector templates")
          templateIndex=LinearSearchStringArray(vectorTemplates%name,&
               & templateName,caseInsensitive=.FALSE.)
          IF (templateIndex==0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
               & "No such vector template: "//templateName)
          
          ! Now create the vector, and add it to the database.
          ! Note that adding it to the database is *not* an intensive
          ! operation, as the pointer is copied, not the contents.
          
          CALL CreateVector(vectorName,vectorTemplates(templateIndex), &
               & newVector)
          CALL AddVectorToDatabase(vectors,newVector)
          
          ! That's the end of the create operation
          
       CASE ("FILL")
          
       CASE DEFAULT
          CALL MLSMessage(MLSMSG_Error,ModuleName,"Expected CREATE or FILL")
       END SELECT
    END DO
  END SUBROUTINE MLSL2Fill
d138 1
a138 1
END MODULE Fill
d143 5
a147 2
! Revision 1.1  2000/01/21 21:04:06  livesey
! First version
@


