head	2.60;
access;
symbols
	v5-02-NRT-19:2.60
	v6-00:2.60
	v5-02-NRT-18:2.60
	v5-02:2.60
	v5-01-NRT-17:2.60
	v5-01-NRT-16:2.60
	v5-01-NRT-15:2.60
	v5-01-NRT-14:2.60
	neuralnetworks-1-0:2.60.0.4
	cfm-single-freq-0-1:2.60.0.2
	v5-01:2.60
	v5-00:2.60
	v4-23-TA133:2.57.0.2
	mus-emls-1-70:2.53.0.4
	rel-1-0-englocks-work:2.53.0.2
	VUMLS1-00:2.53
	VPL1-00:2.53
	V4-22-NRT-08:2.53
	VAM1-00:2.53
	V4-21:2.52.0.2
	V4-13:2.52
	V4-12:2.52
	V4-11:2.52
	V4-10:2.52
	V3-43:2.49
	M4-00:2.52
	V3-41:2.49
	V3-40-PlusGM57:2.49.0.2
	V2-24-NRT-04:2.48
	V3-33:2.49
	V2-24:2.48
	V3-31:2.49
	V3-30-NRT-05:2.49
	cfm-01-00:2.49
	V3-30:2.49
	V3-20:2.49
	V3-10:2.49
	V2-23-NRT-02:2.48
	V2-23:2.48
	V2-22-NRT-01:2.48
	V2-22:2.48
	V2-21:2.46
	V2-20:2.46
	V2-11:2.46
	V2-10:2.46
	V2-00:2.46
	V1-51:2.41
	V1-50:2.41
	V1-45:2.41
	V1-44:2.41
	V1-43:2.41
	V1-32:2.41
	V1-31:2.41
	V1-30:2.41
	V1-13:2.41
	V1-12:2.41
	V1-11:2.41
	V1-10:2.41
	newfwm-feb03:2.41.0.2
	V1-04:2.21
	V1-03:2.21
	V1-02:2.21
	JointForwardModel:2.21.0.2
	V1-00:2.21
	newfwm-sep01:2.19.0.2
	V0-7:2.19
	V0-5-Level2:2.6
	V0-5-SIPS:2.4;
locks; strict;
comment	@# @;


2.60
date	2019.09.23.20.04.38;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2019.08.20.23.52.00;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2019.06.24.23.29.26;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2018.08.04.02.06.51;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2018.07.23.23.29.56;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2018.07.23.22.23.30;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2018.07.23.22.20.21;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2015.05.15.23.41.01;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2012.09.13.18.06.56;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2012.08.30.23.04.02;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2012.04.20.01.29.21;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2007.09.22.00.25.16;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2007.01.11.20.46.33;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2006.06.08.23.55.59;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2006.06.06.15.22.51;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2006.06.03.00.15.59;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2006.05.30.22.44.36;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2005.06.22.18.57.01;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2003.02.03.23.11.23;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2003.01.18.01.39.57;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2003.01.16.21.48.37;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2003.01.16.04.06.58;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2003.01.15.01.49.51;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2002.10.25.22.24.33;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2002.10.23.01.15.06;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2002.10.07.23.43.11;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2002.09.23.22.04.11;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2002.09.21.00.33.47;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2002.09.21.00.21.44;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2002.09.19.01.25.53;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2002.09.14.02.46.00;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2002.09.14.00.36.13;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2002.09.11.23.41.53;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2002.09.10.23.52.56;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2002.07.26.22.46.40;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2002.07.26.01.19.18;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2002.07.24.20.32.15;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2002.07.24.01.08.11;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2002.02.14.21.53.10;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2002.01.09.00.00.04;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2001.06.13.23.57.12;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2001.06.13.23.50.57;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.06.01.23.04.11;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.06.01.01.38.27;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.05.25.20.14.01;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2001.05.25.04.58.50;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.05.24.23.28.06;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.05.24.20.23.41;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2001.05.24.18.16.11;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.05.22.19.10.33;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.05.18.01.02.43;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.05.17.20.15.28;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.05.12.01.10.24;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.05.03.02.00.39;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.04.28.01.47.39;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.04.12.00.03.21;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.16.00.19.34;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.06.23.33.54;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.06.23.23.53;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.60
log
@Add comments about Newton moves after 'uphill' moves
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module DNWT_Module
!>> 2000-12-19 W. V. Snyder Removed fwd communication and linear algebra
!>> 2000-03-21 DNWT_MODULE W. V. Snyder Converted to Fortran 90
!>> 2018-07-17 W. V. Snyder Restructured
!--D replaces "?": ?NWT_MODULE, ?NWT_TYPE, ?NWT, ?NWTA, ?NWTDB, ?NWTOP

!****************** Program description ********************************

! These subroutines solve f(x)=0 (or find the least square solution)
! where f is a vector with NF components, and x is a vector with NX
! components.

! Reverse communication is used.  Reverse communication means that a
! return to the user's program is made whenever additional information
! is required. When this return is made NFlag will be set to indicate
! the necessary action.  Negative values indicate that the calling
! program unit should carry out a computation and call NWTA again.
! Positive values indicate that NWTA believes the computation is
! finished.

! Assign values to OPT.

! *************************************************
! **  CALL NWT ( NFlag, AJ, Opt )                **
! *************************************************

!     You will need a Matrix J, and seven vectors:  F, X, "Best X", DX,
!     "Candidate DX" Gradient and "Best Gradient".

!     Set options using OPT as explained below, or set values
!     in AJ%O (see type NWT_Options below).

!     Set X( ) = initial guess for the solution, and
!         AJ%AXMAX = MAXVAL(ABS(X(1:NX)))
!     DO
! *************************************************
! **    CALL NWTA ( NFlag, AJ )                  **
! *************************************************
!       SELECT CASE ( NFlag ) ! NFlag > 0 means "Done", <0 means "Continue"
!       CASE ( NF_EVALF )
!         IF ( too many function values ) EXIT
!         Compute f(x)
!         Compute the Jacobian matrix J if you feel like doing it now (and
!         maybe do the other stuff required for NF_EvalJ now too)
!         Set AJ%FNORM = L2 norm of f(x)
!         IF ( AJ%FNORM is small enough ) EXIT
!       CASE ( NF_EVALJ )
!         IF ( too many Jacobian values ) EXIT
!         Compute the Jacobian matrix J if you didn't do it when NFlag
!         was NF_EVALF:
!           J(K,L) = Partial of F(K) / W.R.T. X(L), K = 1:NF, L = 1:NX
!         Compute (negative of the) gradient =
!         -(Jacobian)**T * F.  This is the RHS of the normal equations
!         J^T * J * "Candidate DX" = -J^T * F.
!         Triangularize J using QR, or J^T J using Cholesky.
!         Set
!           AJ%DIAG = element on diagonal of triangular factor with smallest
!                   absolute value,
!           AJ%AJN = maximum L1 norm of column in upper triangular factor,
!           AJ%FNMIN = L2 Norm of F not in column space of the Jacobian after
!                   stabilization, ||F + J * "Candidate DX"||, (which can be
!                   gotten without solving for "Candidate DX": if -F is put as
!                   the last column of J before triangularization, either by QR
!                   or by Cholesky factoring the normal equations, this is
!                   R(N+1,N+1) (or U(N+1,N+1) after factorization),
!           AJ%GRADN = L2 norm of Gradient.
!           The Q factor of the Jacobian factored as QR is the same as the
!           Cholesky factor U of U^T U = J^T J, except signs on the diagonal
!           might be different.
!       CASE ( NF_LEV )
!         Compute quantities necessary to determine the Levenberg-Marquardt
!         stabilization parameter: Solve U^T q = dX where U is the Cholesky
!         factor of J^T J, compute |q|**2 and store it in AJ%QNSQ.  This is
!         for the Moré-Sorensen algorithm.
!       CASE ( NF_SOLVE )
!         Apply Levenberg-Marquardt stabilization with parameter = AJ%SQ,
!         and solve the least-squares problem
!           (Jacobian) * "candidate DX" ~ -F
!         for "candidate DX".
!         Set AJ%FNMIN as for NWT_FLAG = NF_EVALJ, but taking account
!         of Levenberg-Marquardt stabilization.
!         Set
!           AJ%DXN = L2 norm of "candidate DX",
!           AJ%GDX = (Gradient) .dot. ("candidate DX")
!       CASE ( NF_NEWX )
!         Set X = X + DX
!             AJ%AXMAX = MAXVAL(ABS(X)),
!             AJ%BIG = ANY ( DX > 10.0 * epsilon(X) * X )
!       CASE ( NF_GMOVE )
!         Set X = "Best X"
!             DX = AJ%GFAC * "Best Gradient"
!       CASE ( NF_BEST )
!         Best solution so far.
!         Set "Best X" = X, "Best Gradient" = Gradient
!       CASE ( NF_AITKEN )
!         Set DX = DX - "Candidate DX",
!             AJ%DXDX = dot_product( DX, DX )
!         IF ( AJ%DXDX /= 0.0 ) &
!           Set AJ%DXDXL = dot_product( DX, "Candidate DX" )
!       CASE ( NF_DX )
!         Set DX = "Candidate DX"
!       CASE ( NF_DX_AITKEN )
!         Set DX = AJ%CAIT * "Candidate DX"
!       CASE ( NF_TOLX, NF_TOLX_BEST, NF_TOLF, NF_TOO_SMALL )
!         IF ( NFlag == NF_TOO_SMALL ) THEN
!           Take special action if requested accuracy is critical
!         END IF
!         If ( NFlag == NF_TOLX_BEST ) copy "best X" to "X"
!         Convergence to desired solution.  Do whatever you want to
!         with the solution.
!         EXIT ! unless you have a really good reason to continue
!       CASE ( NF_FANDJ )
!         There is probably an error in the way F or J is computed.
!         A warning has been printed by the error message processor.
!         IF ( you don't have confidence in F and J ) STOP
!         If you don't stop, a gradient move is forced
!           (next NFlag == NF_Gmove).
!       END SELECT
!       IF ( you want to return to a previous best X ) NFlag = NF_START
!     END DO

  use Ermsg_m, only: Ermsg
  use DNWT_Type, only: RK
  use Output_M, only: NewLine, Output

  implicit NONE

  private
  public :: RK, DNWT, DNWTA, DNWTDB
  public ::      NWT,  NWTA,  NWTDB, NWT_Options, NWT_t
  public :: FlagName

  ! Start, or restart with gradient move from "Best":
  integer, parameter, public :: NF_START = 0

  ! Reasons for returning to user.  See description of usage above.

  ! Reasons to continue

  !      Evaluate F and AJ%FNORM:
  integer, parameter, public :: NF_EVALF = NF_START - 1

  !      Evaluate J and do other things:
  integer, parameter, public :: NF_EVALJ = nf_evalf-1

  !      Calculate quantities necessary to determine the Levenberg-Marquardt
  !      stabilization parameter:
  integer, parameter, public :: NF_LEV = nf_evalj-1

  !      Solve for candidate DX:
  integer, parameter, public :: NF_SOLVE = nf_lev-1

  !      Compute X = X + DX, set AJ%AXMAX = MAXVAL(ABS(X)),
  !      AJ%BIG = ANY ( ABS(DX) > 10.0 * epsilon(X) * ABS(X) );
  !      IF ( .not. AJ%STARTING ) set
  !      aj%dxdxl = dot_product( DX, "Candidate DX" ):
  integer, parameter, public :: NF_NEWX = nf_solve-1

  !      Set X = "Best X", DX = AJ%GFAC * "Best Gradient":
  integer, parameter, public :: NF_GMOVE = nf_newx-1

  !      Set "Best X" = X, "Best Gradient" = Gradient:
  integer, parameter, public :: NF_BEST = nf_gmove-1

  !      Set DX = DX - "Candidate DX",
  !          AJ%DXDX = dot_product( DX, DX )
  !      IF ( AJ%DXDX /= 0.0 ) Set AJ%DXDXL = dot_product( DX, "Candidate DX" ):
  integer, parameter, public :: NF_AITKEN = nf_best-1

  !      Set DX = "Candidate DX":
  integer, parameter, public :: NF_DX = nf_aitken-1

  !      Set DX = AJ%CAIT * "Candidate DX":
  integer, parameter, public :: NF_DX_AITKEN = nf_dx-1

  ! Reasons to stop

  !      Convergence due to TOLXA and TOLXR tests:
  integer, parameter, public :: NF_TOLX = NF_START + 1

  !      Convergence due to TOLXA and TOLXR tests, but solution
  !      is saved "best X":
  integer, parameter, public :: NF_TOLX_BEST = nf_tolx+1

  !      Convergence due to RELSF test:
  integer, parameter, public :: NF_TOLF = nf_tolx_best+1

  !      Convergence due to too small a move:
  integer, parameter, public :: NF_TOO_SMALL = nf_tolf+1

  !      F and J appear not to be consistent:
  integer, parameter, public :: NF_FANDJ = nf_too_small+1

  !      In case you want to add some flags for your own use...  If ?NWTA sees
  !      flags that are out of range, it prints a message but otherwise does
  !      nothing.
  integer, parameter, public :: NF_BIGGEST_FLAG = NF_FANDJ
  integer, parameter, public :: NF_SMALLEST_FLAG = NF_DX_AITKEN

  real(rk), parameter, private :: EPS = epsilon(1.0_rk), CBIG = huge(1.0_rk)

  ! Options for DNWT:

  type NWT_Options
    real(rk) :: AJSCAL = eps      ! Approximate absolute error in computing the
                                  ! Jacobian
    real(rk) :: DXMAXI = 0.1*cbig ! Largest value permitted for DXINC at any
                                  ! time
    real(rk) :: DXNOIS = 0.0      ! 1.0E-4_rk * largest move that gives a new
                                  ! best X (used to see if increase in AJ%FNORM
                                  ! might be due to too small a step)
    integer :: K1IT = 0           ! Number of iterations for which to give
                                  ! internal output
    real(rk) :: RELSF = max(0.01_rk,eps) ! Convergence is indicated with
                                  ! NFlag = NF_TOLF if AJ%FNORM - AJ%FNMIN <
                                  ! RELSF * AJ%FNMIN
    real(rk) :: SPMINI = eps      ! Nominal minimum value for normalized
                                  ! Marquardt parameter
    real(rk) :: SPSTRT = 0.1_rk   ! Starting value for normalized Marquardt
                                  ! parameter
    real(rk) :: TOLXA = tiny(1.0_rk)**0.75 ! Absolute tolerance on X. 
                                  ! Convergence is indicated with NFlag =
                                  ! NF_TOLX or NF_TOLX_BEST if the (possibly
                                  ! scaled) norm of the difference between the
                                  ! current X and the solution is estimated to
                                  ! be <= TOLXA.
    real(rk) :: TOLXR = eps**0.75 ! Relative tolerance on X.  Convergence is
                                  ! indicated with NFlag = NF_TOLX or
                                  ! NF_TOLX_BEST if the (possibly scaled) norm
                                  ! of the difference between the current X and
                                  ! the solution is estimated to be <= TOLXR *
                                  ! maxval (abs(X)).
  end type NWT_Options

  type(nwt_options), parameter :: Default_Options = NWT_options()

  type NWT_t               ! Stuff about the problem, neatly packaged.  This
                           ! is the type of the AJ argument of NWT*.
    type(nwt_options) :: O = Default_Options

    ! Inputs to ?NWTA.  Values to be set depend upon NFlag.
    ! See usage instructions above.
    real(rk) :: AJN        ! Largest L1 norm of column in upper triangle
                           ! of factored Jacobian matrix.  See NF_EvalJ
                           ! description above.
    real(rk) :: AXMAX      ! MAXVAL(ABS(X)).  See NF_NewX description above.
    real(rk) :: DIAG       ! Smallest | diagonal element | after factoring the
                           ! Jacobian matrix.  See NF_EvalF description above.
    real(rk) :: DXDX       ! dot_product( DX, DX ) (Newton step length)^2.
                           ! See NF_Aitken description above.
    real(rk) :: DXDXL      ! dot_product( "candidate DX", DX ).  See NF_Aitken
                           ! description above.
    real(rk) :: DXN        ! L2 Norm of candidate DX (Newton step length).  See
                           ! NF_Solve description above.
    real(rk) :: FNMIN      ! L2 Norm of F not in column space of the Jacobian.
                           ! See NF_EvalJ description above.
    real(rk) :: FNORM      ! L2 Norm of F at current X.  See NF_EvalF
                           ! description above.
    real(rk) :: GDX        ! dot_product( Gradient, "Candidate DX" ).  See
                           ! NF_Solve description above.
    real(rk) :: GRADN      ! L2 norm of Gradient = || J^T F ||.  See NF_EvalJ
                           ! description above.
    real(rk) :: QNSQ       ! Square of norm of solution of U^T q = x.  See
                           ! NF_Lev description above.
    logical :: BIG         ! ANY( DX > 10.0 * epsilon(X) * X ).  See NF_NewX
                           ! description above.

    ! Outputs from ?NWTA.  DO NOT CHANGE THESE!
    real(rk) :: CAIT = 0.0 ! Candidate factor for Aitken acceleration.  See
                           ! NF_DX_Aitken description above.
    real(rk) :: CGDX = 0.0 ! COS of angle between gradient and DX.   Not needed
                           ! from return until next call.  Here for printing by
                           ! ?NWTDB or the user.
    real(rk) :: GFAC = 1.0 ! Factor by which the gradient is to be multiplied
                           ! when taking a gradient move from the best X.  See
                           ! NF_Gmove description above.
    real(rk) :: SQ = 0.0   ! Actual value of Marquardt parameter. If SQ < 0,
                           ! modified Aitken acceleration is being used and
                           ! ABS(SQ) gives the acceleration factor.  See
                           ! NF_Solve description above.
    real(rk) :: SQMIN = 0.0 ! Current minimum value of SQ; recommend to use
                           ! this as a floor for Levenberg-Marquardt
                           ! stabilization in the caller.
    logical :: STARTING = .true. ! NWTA is still in "starting up" phase

    ! Values retained from return until next call.  DO NOT CHANGE THESE!
    real(rk) :: AXMAXB     ! AXMAX at best X (not actually used)
    real(rk) :: CDXDXL     ! COS of angle between DX (current move) and
                           ! DXL (previous move)
    real(rk) :: CONDAI     ! Crude estimate of reciprocal of condition number
                           ! of the Jacobian
    real(rk) :: DXBAD      ! This size for DX is likely a disaster
    real(rk) :: DXFAIL     ! Like DXINC, but more so.
    real(rk) :: DXI        ! Largest factor by which stepsize is allowed to
                           ! increase
    real(rk) :: DXINC      ! Largest value for DXN currently allowed
    real(rk) :: DXNBIG = 0.1*cbig ! A size of move that should be safe.
    real(rk) :: DXNL       ! L2 Norm of last candidate DX
    real(rk) :: FNMINB     ! FNMIN at best X, not best FNMIN
    real(rk) :: FNORMB     ! L2 Norm of F at best X
    real(rk) :: FNORML     ! Last value of AJ%FNORM
    real(rk) :: FNXE       ! Used to test if F is behaving with near linearity.
                           ! If ( FNORM**2 on the next iteration ) <= FNXE
                           ! then linear behavior is assumed.
    real(rk) :: FRZ        ! Norm of projection of F into the column space of
                           ! the Jacobian
    real(rk) :: FRZB       ! FRZ at best X (not actually used)
    real(rk) :: FRZL       ! Last value of FRZ
    real(rk) :: GRADNB     ! L2 norm of Gradient at best F
    real(rk) :: GRADNL     ! Last value of GRADN
    integer :: INC         ! Flag set to indicate some past history
                           ! =-1  Starting
                           ! =0   Last X == best X
                           ! =J>0 AJ%FNORM > AJ%FNORML J times since last best X
    integer :: ITER        ! Number of current iteration
    integer :: ITKEN       ! Index used to keep track of Aitken accelerations
    integer :: KB          ! Flag set to indicate some past history
                           ! =2    Starting
                           ! =-J   (J>0) Making gradient move from best X
                           !       (-KB serves as a counter)
                           ! =1    Last F is bigger than the best F
                           ! =0    (INC >0) trying a move in wrong direction
                           !       from the best X
                           ! =0    (INC =0) new best X
    integer :: KFAIL       ! Failure count: 0 no failures; k > 0 we have
                           ! successfully taken k - 1 steps of size DXBAD.
    real(rk) :: SP         ! Current normalized Marquardt parameter
    real(rk) :: SPACT      ! Set to 0.25 * CONDAI after evaluating J (but not
                           ! after CONDAI is calculated after solving for DX).
                           ! If SP <SPACT, SQ is set = SQMIN
    real(rk) :: SPB        ! Normalized Marquardt parameter used to get best X
    real(rk) :: SPFAC      ! Factor multiplying last normalized Marquardt
                           ! parameter to get one estimate to use for current
                           ! normalized Marquardt parameter
    real(rk) :: SPG        ! Used to initialize SPL after taking a gradient
                           ! move from best X after a previous failure
    real(rk) :: SPINC      ! Lower bound permitted for normalized Marquardt
                           ! parameter based on past behavior
    real(rk) :: SPL        ! Normalized Marquardt parameter from last
                           ! iteration, and then the current one
    real(rk) :: SQB        ! Value of SQL from last best X
    real(rk) :: SQL        ! 0.9 * AJN * SPL 
                           ! (frequently = 0.9 * last Marquardt parameter)
    real(rk) :: SQT = 0.0  ! Total Levenberg-Marquardt stabilization
    integer :: WHERE_TO = NF_Start   ! Internal value of NFlag, to remember
                           ! reason for return, and therefore where to go next.

  contains
    procedure, pass(AJ) :: DNWT
    generic :: NWT => DNWT
    procedure, pass(AJ) :: DNWTA
    generic :: NWTA => DNWTA
    procedure, pass(AJ) :: DNWTDB
    generic :: NWTDB => DNWTDB
  end type NWT_t

  interface NWT; module procedure DNWT; end interface
  interface NWTA; module procedure DNWTA; end interface
  interface NWTDB; module procedure DNWTDB; end interface

  ! This should be internal to DNWTDB, but as of 2 July 2019 some processors
  ! still do not support internal procedures as specific procedures for a
  ! generic identifier.

  interface Add_To_Line
    procedure Add_To_Line_I, Add_To_Line_L, Add_To_Line_R
  end interface

! *****     Private data     *******************************************

  character(len=*), parameter :: ME = 'DNWT'

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: dnwt_module.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

! ***************************************************     DNWT     *****

  subroutine DNWT ( NFlag, AJ, Opt )

! **********************************************************************

!>> 2000-03-21 W. V. Snyder Converted to Fortran 90.
!>> 1988-07-21 C. L. Lawson adapting code for the MATH77 library.
!-----------------------------------------------------------

! Original design and code by FRED T. KROGH
! Modifications for new usage coded by S. SINGLETARY
! Modifications to add bounds, JULY 1977
! JET PROPULSION LAB, PASADENA    JULY, 1974
! Re-structured by VAN SNYDER, JPL, 17 July 2018

! Arguments in the calling sequence are of the following types:

    integer, intent(out) :: NFlag
    class (NWT_t), intent(inout) :: AJ
    type (NWT_Options), intent(in), optional :: Opt

! The above arguments are used as follows:

! NFlag  = Integer used for communication with the user.  NWT sets NFlag =
!     NF_START.  NFlag is used by NWTA.  When NWTA returns control to the
!     calling program unit, NFlag is used as shown above.

! AJ =  NWTA internal state.

! Opt = Options; see type NWT_Options above.  Options can also be set by
!       the caller using AJ%O = Opt.

    aj%where_to = nf_start
    nflag = aj%where_to
    if ( present(opt) ) aj%o = opt

  end subroutine DNWT

! **************************************************     DNWTA     *****

  subroutine DNWTA ( NFlag, AJ )

! **********************************************************************

! Arguments in the calling sequence are of the following types:

    integer, intent(inout) :: NFlag    ! See usage instructions above
    class (nwt_t), intent(inout) :: AJ ! "About the Jacobian."  See usage
                                       ! instructions above.

!-----     Parameters and Unsaved Local Variables     ------------------

    integer, parameter :: IncBig = huge(0) / 2
    real(rk) :: TP       ! Widely used temporary variable.  Not needed from
                         ! one call to the next.

! RND      Used to decide if answer has been determined to machine
!          accuracy.

    real(rk), parameter :: RND = 10.0_rk * epsilon(0.0)

    ! Values for Before_Solve argument of Do_NF_Solve
    integer, parameter :: Solve_Only = 0
    integer, parameter :: Set_New_Marquardt = 1 + 2 * Solve_Only
    integer, parameter :: Test_GradN_Increase = 1 + 2 * Set_New_Marquardt
    integer, parameter :: Test_F_Linear = 1 + Test_GradN_Increase

!-----     Executable Statements     -----------------------------------

    if ( nflag == nf_start ) then
      ! Either initialization, or user is forcing retreat to best X
      ! followed by gradient move

      if ( aj%where_to == nf_start ) then ! Initialization
      ! Initialization
        aj%ajn = 0.0
        aj%condai = 0.0
        aj%dxnl = 1.0
        aj%fnormb = sqrt(huge(aj%fnormb))
        aj%dxfail = huge(aj%dxfail)
        aj%dxbad = aj%dxfail
        aj%kfail = 0
        aj%fnorml = 0.0
        aj%inc = -1 ! Starting
      ! aj%inc = 0  ! Pretend we're at a "best"
        aj%iter = 0
        aj%itken = 0
        aj%kb = 2
        aj%spl = 0.0
        aj%sql = 0.0
        aj%sq = 0.0
        aj%dxdxl = 0.0 ! So it's not undefined, because the user isn't expected
                       ! to set it when starting.
        call do_NF_Evalf
      else ! User is forcing retreat to best X followed by gradient move
        call Do_NF_GMove_First
      end if

    else if ( nflag < nf_smallest_flag .or. nflag > nf_biggest_flag ) then

      call ermsg ( me // 'A', 98, 2, &
        & 'Invalid value of NFLAG', '.' )

    else if ( nflag /= aj%where_to ) then

      call ermsg ( me // 'A', 98, 2, &
        & 'NFLAG was changed to be inconsistent with AJ%WHERE_TO', '.' )

    else

! Continuing after return for reverse communication:

      select case ( aj%where_to )
      case ( nf_evalf ) ! Resumed here after evaluating F.

        aj%iter = aj%iter + 1

        ! Test if a retreat to a previous -- best -- X should be made

        tp = 0.9 * aj%spl * aj%ajn ! .9 times aj%sql on previous iteration
        if ( aj%fnorm < aj%fnorml ) then ! Things are getting better
          !{ \hspace*{20mm} $|F| < |F|_{\text{last}}$.
          if ( aj%fnorm >= aj%fnormb ) then ! But no better than the best X.
            !{ \hspace*{25mm} $|F| \geq |F|_{\text{best}}$.

            ! If our Marquardt parameter is small and aj%fnorm does not appear
            ! to be getting close to smaller than aj%fnormb, and we are not
            ! making a move in a quite different direction we give up and go
            ! back to previous best.

            if ( (max(tp, aj%sql) <= aj%sqmin) .and. &
               & ((aj%fnorm * (aj%fnorm/aj%fnorml)**2) > aj%fnormb) .and. &
               & (aj%cdxdxl >= 0.25) ) then
              call Do_NF_GMove_First
              return ! -----  GMove  ---------------------------------->
            end if
          end if
        else ! ( aj%fnorm >= aj%fnorml ) -- F norm increased

          !{ \hspace*{20mm} $|F| \geq |F|_{\text{last}}$.

          ! The residual expected if the problem is locally linear is
          ! aj%fnmin. Hopefully, the definition of "locally linear" is
          ! consistent with the Levenberg-Marquardt parameter. If aj%fnmin is
          ! smaller than the best one -- aj%fnminb, maybe it's OK to take
          ! another Newton move after the norm increases. But we don't want to
          ! do that if there have been a lot of "uphill" Newton moves.

          ! AJ%FNORML will have been set to zero if there are four consecutive
          ! gradient moves.

          ! Test for X convergence

          if ( x_converge() ) return ! -----  TolX or Tolx_Best  ------>
          if ( aj%inc >= 0 ) then ! We are not starting
            if ( aj%inc == 0 ) then ! Last X == Best X
              aj%dxnbig = max(aj%dxnl, aj%o%dxnois)

            else      ! aj%inc > 0 -- Not starting, Last X not Best X
              if ( aj%kb == 0 ) then ! Trying to move in wrong direction from
                                     ! best X.
                if ( aj%fnorm < aj%fnormb ) then
                  !{  \hspace*{35mm} $|F| < |F|_{\text{best}}$.
                  aj%gfac = -aj%gfac
                  if ( aj%gfac >=  0 ) then
                    ! Error processing -- F and J appear not to be consistent.
                    call ermsg ( me, 2, 0, 'J or F might be in error', '.' )
                    aj%where_to = nf_fandj
                    nflag = aj%where_to
                    return ! -----  FandJ  ---------------------------->
                  end if
                end if
                call Do_NF_GMove_Small
                return ! -----  GMove  -------------------------------->
              end if
              if ( aj%dxnl <= aj%o%dxnois ) then ! Last Newton move tiny?
                call do_nf_evalj ( tp )
                return ! ---------------------------------------------->
              end if
              if ( aj%kb < 0 ) then ! Gradient move last time?
                call Do_NF_GMove_Second
                return ! -----  GMove  -------------------------------->
              end if

! WVS revised this 2012-08-27 based upon advice from FTK
!             if ( (tp >= min(aj%sql,aj%sqb+aj%sqb)) .or. (aj%inc >= incbig) ) then
              if ( aj%fnmin > (1.0+0.5*aj%o%relsf)*aj%fnminb .or. &
                 & aj%inc >= incbig ) then
                ! Residual of locally-linear problem is too much bigger than
                ! the best estimate of the residual of the locally-linear
                ! problem, or we took an "uphill" Newton move after a
                ! gradient move after starting.
                call Do_NF_GMove_First
                return ! -----  GMove  -------------------------------->
              end if
            end if
            aj%sqmin = min ( aj%sqb, 4.0 * max( aj%spl, aj%spact ) * aj%ajn )
            aj%dxinc = max ( 0.5 * aj%dxnl, aj%o%dxnois )
            aj%inc = aj%inc + 1 ! Increase count of "uphill" Newton moves
          end if
        end if

        call do_NF_EvalJ ( tp ) ! -----  EvalJ  ----------------------->

      case ( nf_evalj ) ! Resumed here after computing Jacobian

        if ( aj%gradn <= 0.0 ) then
           aj%gradn = 1.0
           if ( aj%ajn <= 0.0 ) aj%ajn = 1.0
        end if
        tp = aj%diag / aj%ajn
        aj%condai = max ( min ( aj%condai,tp ), tp**2 )
        aj%spact = 0.25 * aj%condai

        !{ \hspace*{15mm}FRZ $= \sqrt{ | ( |F|^2 - |F|^2_{\text{min} } |) }$
        aj%frz = sqrt ( abs ( (aj%fnorm-aj%fnmin) * (aj%fnorm+aj%fnmin) ) )

        if ( aj%iter == 1 ) then ! First iteration
          aj%sp = aj%o%spstrt
          aj%spinc = aj%sp
          if ( aj%frz <= rnd * aj%fnmin ) then
            call Do_NF_Tolf
            return ! -----  TolF  ------------------------------------->
          end if
          aj%dxi = 0.125
        else
          if ( aj%fnorm >= aj%fnorml ) then

            !{ \hspace*{24mm} $|F| \geq |F|_{\text{last}}$.

            ! Select new Levenberg-Marquardt stabilizing parameter for the
            ! case when AJ%FNORM has increased -- an "uphill" Newton move.

            aj%kb = 1
            if ( aj%dxnl < aj%o%dxnois ) then
              aj%sp = 1.0e-4 * aj%sp
              aj%sqmin = min ( aj%sqmin, aj%sp * aj%ajn )
!             aj%dxnl = aj%dxnl * 100.0
              call do_NF_Solve ( before_Solve = set_new_marquardt )
              return ! -----  Solve  ---------------------------------->
            end if
            aj%spfac = max ( (aj%fnorm/aj%fnorml)**2, 10.0_rk )
            aj%spinc = aj%spl + aj%spl + aj%spact
            aj%dxi = 1.0
            call do_NF_Solve ( before_Solve = test_GradN_Increase )
            return ! -----  Solve  ------------------------------------>
          end if
          if ( aj%fnorm >= aj%fnormb ) then ! Is function norm larger than best?
            !{ \hspace*{24mm} $|F| \geq |F|_{\text{best}}$.
            if ( .not. f_converge() ) &
              & call do_NF_Solve ( before_Solve = test_f_linear )
            return ! -----  Solve  ------------------------------------>
          end if
        end if

        ! New best X

        if ( aj%kfail /= 0 ) then
           if ( aj%kb == 0 ) then ! Got new best immediately
              if ( aj%dxn >= 0.9_rk * aj%dxbad ) then
                 aj%dxbad = aj%dxbad * (1.25_rk ** aj%kfail)
                 aj%dxfail = aj%dxbad
                 aj%kfail = aj%kfail + 1
              else
                 aj%dxfail = 0.75_rk * aj%dxfail + 0.25_rk * aj%dxbad
                 aj%kfail = 1
              end if
           else
              aj%dxfail = min ( 1.0625_rk * aj%dxfail, aj%dxbad )
           end if
           aj%dxinc = min ( aj%o%dxmaxi, aj%dxfail )
        else
           aj%dxinc = aj%o%dxmaxi
        end if

        aj%spinc = min ( aj%spinc, &
                       & max ( aj%o%spmini, abs(aj%o%ajscal) / aj%ajn ) )
        aj%sqmin = 0.0
        aj%spb = aj%spl
        aj%sqb = aj%sql
        if ( aj%inc < 0 ) then ! Starting
          call do_NF_Solve ( before_Solve = set_new_marquardt )
          return ! -----  Solve  -------------------------------------->
        end if
        if ( aj%inc /= 0 ) then
          if ( aj%kb < 0 ) then
            aj%dxi = 0.25
          else if ( aj%kb == 1 ) then
          ! We had a function increase prior to getting a new best.
            aj%dxi = 0.25 * aj%dxnl / aj%dxnbig ! prior to getting a new best.
          end if
          aj%kb = 0
          aj%inc = 0
        end if

        ! Test for convergence in sense of AJ%FNORM < (aj%o%RELSF * aj%FNMIN)

        if ( .not. f_converge() ) &
           & call do_NF_Solve ( before_Solve = test_F_Linear )

        ! -----  TolF or Solve  --------------------------------------->

      case ( nf_solve ) ! Resumed here after doing Levenberg-Marquardt
                        ! stabilization and solving for candidate DX

        !{ \hspace*{14mm} {\tt CGDX}
        !  $= \cos( \nabla \mathbf{f} - \delta \mathbf{x} ) =
        !  \frac{\nabla \mathbf{f} \cdot \delta \mathbf{x}}
        !       {|\nabla \mathbf{f}|\,|\delta \mathbf{x}|}$
        aj%cgdx = aj%gdx / (aj%gradn * aj%dxn) ! Cosine ( gradient, dx )
        aj%condai = min ( aj%cgdx, &
                        & aj%gradn / ( aj%dxn * aj%ajn**2 ), &
                        & aj%diag / aj%ajn )
        aj%fnxe = aj%fnmin**2 - (aj%sq * aj%dxn)**2
        if ( aj%inc < 0 ) then ! Starting
          if ( aj%dxn <= aj%dxinc ) then ! Move length OK?
            aj%inc = incbig
            aj%cdxdxl = 0.0 ! Don't think about Aitken
            call do_nf_best ! Go save best X, then either DX or Aitken
            return ! -----  Best  ------------------------------------->
          end if
        else
          !{ \hspace*{18mm} {\tt CDXDXL }$= \cos( \delta \mathbf{x} -
          !                        \delta \mathbf{x}_{\text{last}}) =
          ! \frac{\delta \mathbf{x} \cdot \delta \mathbf{x}_{\text{last}}}
          !      {|\delta \mathbf{x}| \, |\delta \mathbf{x}_{\text{last}}|}$
          aj%cdxdxl = aj%dxdxl / ( aj%dxn * aj%dxnl )
          if ( aj%fnxe > aj%fnormb**2 ) then
            if ( aj%o%k1it /= 0 ) call nwtdb ( aj, width=9, why='Give up' )
            call Do_NF_GMove_First
            return ! -----  GMove  ------------------------------------>
          end if
          if ( aj%dxn < 1.1_rk * aj%dxinc )  then
            if ( aj%sq <= 0.0 .or. aj%dxn > 0.90_rk * aj%dxinc ) then
              if ( aj%inc == 0 ) then ! Previous move not gradient move
                if ( .not. x_converge() ) call do_nf_best
                return ! -----  TolX or TolX_Best or Best  ------------>
              end if
              aj%cait = cbig
              call do_nf_dx  ! Store Candidate DX as DX
              return ! -----  DX  ------------------------------------->
            end if
! WVS: was  aj%dxinc = aj%dxi * aj%dxn * (1.0 - aj%cdxdxl)**2
! This was clearly wrong, since it says "If consecutive Newton moves are in
! the same direction, take shorter steps"
            aj%dxinc = aj%dxi * aj%dxn / (1.025 - aj%cdxdxl)**2
          end if
        end if

        ! Newton step length is too large or too small

        if ( aj%o%k1it /= 0 ) call nwtdb ( aj, width=9, why='Step length' )

        aj%where_to = nf_lev
        nflag = aj%where_to

        !{ Calculate {\tt qn}$^2 = {\bf q}^T{\bf q} = ||{\bf q}||^2$, used to
        !  determine the Levenberg-Marquardt parameter $\lambda$, where ${\bf q}
        !  = {\bf U}^{-T} {\delta\bf x}$ and ${\delta\bf x}$ is the Newton step
        !  computed with the current value of $\lambda$.  The method to
        !  determine $\lambda$ and the reason for being interested in ${\bf
        !  q}^T{\bf q}$ are explained below.

        ! -----  Lev  ------------------------------------------------->

      case ( nf_lev ) ! Resumed here after calculating QN**2.
      
!{ Determine the Levenberg-Marquardt parameter $\lambda$, known here as SQ,
!  using the Mor\'e-Sorensen method.
!  The last parameter used was SQ, which means that {\tt SQ}$^2 = \lambda^2$
!  was added to the diagonal of the normal equations.  A little bit of 
!  derivation so you have some idea of what is going on.  Start with
!
!  $({\bf H} + \lambda {\bf I})\, {\delta\bf x} = -{\bf g}$,
!
!  where ${\bf H}$ is the Hessian matrix.  In our case, ${\bf J}^T {\bf J}$,
!  where ${\bf J}$ is the Jacobian matrix, is an approximate Hessian. 
!  Differentiating both sides with respect to $\lambda$ gives
!
!  $({\bf H} + \lambda {\bf I})\, \frac{\partial{\delta\bf x}}{\partial\lambda}
!  + {\bf I}\, {\delta\bf x} = 0$ or
!  $({\bf H} + \lambda {\bf I})\, \frac{\partial{\delta\bf x}}{\partial\lambda}
!  = -{\delta\bf x}$.
!
!  Cholesky factoring $({\bf H} + \lambda {\bf I})$, we have
!  ${\bf U}^T {\bf U} \frac{\partial{\delta\bf x}}{\partial\lambda} =
!  -{\delta\bf x}$ or ${\bf U} \frac{\partial{\delta\bf x}}{\partial\lambda} =
!  -{\bf U}^{-T} {\delta\bf x} = -{\bf q}$.
!
!  Multiplying ${\bf U}^T {\bf U} \frac{\partial{\delta\bf x}}{\partial\lambda} =
!  -{\delta\bf x}$ on the left by $\frac{\partial{\delta\bf x}}{\partial\lambda}^T$
!  and substituting
!  ${\bf U} \frac{\partial{\delta\bf x}}{\partial\lambda} = - {\bf q}$ we have
!  $\frac{\partial{\delta\bf x}}{\partial\lambda}^T {\bf U}^T {\bf U}
!   \frac{\partial{\delta\bf x}}{\partial\lambda}
!  = -\frac{\partial{\delta\bf x}}{\partial\lambda}^T {\delta\bf x} =
!  {\bf q}^T {\bf q}$.
!
!  We intend to find a zero of
!  $\phi = \frac1{|| {\delta\bf x} ||} - \frac1{\rho}$, where $\rho$ is the
!  desired step length for ${\delta\bf x}$,
!  treating ${\delta\bf x}$ as a function of $\lambda$.
!
!  $\frac{\partial\phi}{\partial\lambda} =
!  \frac{\partial ( (|| {\delta\bf x} ||^2)^{-1/2}
!   - \frac1{\rho})}{\partial{\delta\bf x}}
!  \frac{\partial{\delta\bf x}}{\partial\lambda}
!  = \frac{-1}{|| {\delta\bf x} ||^{3}} {\delta\bf x}^T
!    \frac{\partial{\delta\bf x}}{\partial\lambda}
!  = \frac{-1}{|| {\delta\bf x} ||^{3}} (- {\bf q}^T {\bf q})$
!
!  The Newton method gives us
!
!  $\lambda_{\text{new}} = \lambda_{\text{old}} -
!    \phi / \frac{\partial\phi}{\partial\lambda_{\text{old}}}
!    = \lambda_{\text{old}} - \frac{|| {\delta\bf x} ||^3}{{\bf q}^T {\bf q}}
!      \left( \frac1{|| {\delta\bf x} ||} - \frac1{\rho} \right)
!    = \lambda_{\text{old}} - \frac{|| {\delta\bf x} ||^2}{|| {\bf q} ||^2}
!      \left(1 - \frac{|| {\bf \delta x} ||}{\rho}\right)$
!
! If you have been looking at Mor\'e and Sorensen, this update is the 
! negative of theirs since they define $\lambda$ as the negative of the 
! $\lambda$ above.  Also, Mor\'e and Sorensen write $\lambda$ as the quantity
! added to the diagonal of the normal equations, which we call $\lambda^2$, so
! the iteration above and the code below are really iterating on what we call
! $\lambda^2$.  I.e., from a least-squares point of view we write
!%
! \begin{equation*}
! \left[ \begin{array}{c} {\bf J} \\
!                 \lambda {\bf I} \\
! \end{array} \right] {\delta \bf x} \simeq
! \left[ \begin{array}{c} -{\bf f} \\
!                          {\bf 0} \\
! \end{array} \right]
! \end{equation*}
! which, in normal-equations form is $({\bf J}^T {\bf J} + \lambda^2 {\bf I})
! {\,\delta\bf x} = -{\bf J}^T {\bf f} = -{\bf g}$.

        aj%sq = sqrt ( max( 0.0_rk, &
                          & aj%sq**2 - (aj%dxn**2 / aj%qnsq) * &
                                     & (1.0_rk - aj%dxn / aj%dxinc) ) )
        aj%sp = aj%sq / aj%ajn
        call do_NF_Solve ( before_Solve = solve_only )

        ! -----  Solve  ----------------------------------------------->

      case ( nf_newx ) ! Resumed here after computing new X

        if ( .not. aj%big ) then ! All dx components are very small
          if ( (aj%spl <= aj%o%spmini) .or. (aj%sq == 0.0) ) then
            if ( (aj%inc > 0) .and. (aj%kb /= 0) ) then ! Go do gradient move
              call Do_NF_GMove_First
            else ! Convergence -- move too small
              nflag = nf_too_small
              aj%where_to = nflag
            end if
            return ! -----  GMove or TooSmall  ------------------------>
          end if
          ! Set so steps don't get too small:
          aj%o%dxnois = max ( aj%o%dxnois, 10.0 * aj%dxn )
        end if
        call do_NF_EvalF

      case ( nf_gmove ) ! Resumed here after computing gradient step from best X

        ! In case the caller wants to compute cosines:
        aj%dxn = aj%gradnb * aj%gfac
        if ( aj%gfac <= 0.0 ) then
          call do_NF_NewX
        else
          aj%axmax = aj%axmaxb
          aj%gfac = 0.125 * aj%gfac
          aj%spl = aj%spg
          aj%spg = 8.0 * aj%spl
          aj%fnorm = aj%fnormb
          aj%fnxe = 0.5 * aj%fnorm **2
          aj%frz = aj%frzb
          aj%gradn = aj%gradnb
          call do_NF_NewX_First
        end if

        ! -----  NewX  ------------------------------------------------>

      case ( nf_best ) ! Resumed here after saving X as "best X" and
                       ! Gradient as "Best gradient"

        aj%axmaxb = aj%axmax
        aj%o%dxnois = max ( aj%o%dxnois, 1.0e-4 * aj%dxnl )
        aj%gfac = min ( 0.125 * aj%dxn / aj%gradn, aj%ajn**(-2) )
        aj%spg = aj%spl + 0.01
        aj%fnormb = aj%fnorm
        aj%frzb = aj%frz
        aj%fnminb = aj%fnmin
        aj%gradnb = aj%gradn
        if ( abs(aj%cdxdxl) < 0.9 .or. aj%sq /= 0.0 .or. aj%dxn >= aj%dxnl ) then
          call do_nf_dx ! Store Candidate DX as DX
        else

          ! Compute scalar factor for (modified) Aitken acceleration

          aj%where_to = nf_aitken
          nflag = aj%where_to
        end if

        ! -----  DX or Aitken  ---------------------------------------->

      case ( nf_aitken ) ! Resumed here after computing some numbers needed
                         ! for (modified) Aitken acceleration

        tp = aj%dxdx
        if ( tp /= 0.0 ) then
           tp = 1.0 + aj%dxdxl/tp
           tp = min ( 10.0_rk, max ( tp, 0.01_rk ) )
           if ( abs(aj%cait-tp) < abs ( 0.25 * (aj%cait+tp)-0.5 ) ) then
              ! Set DX = Aitken-modified DX = aj%CAIT * "Candidate DX"
              aj%cait = tp
              aj%itken = aj%iter + 2
              aj%sq = -aj%cait
              aj%dxn = aj%cait*aj%dxn
              aj%where_to = nf_dx_aitken
              nflag = aj%where_to
              return ! -----  Dx_Aitken  ------------------------------>
           end if
           if ( aj%itken < aj%iter ) aj%cait = tp
        end if

        ! End of logic for Aitken acceleration

        call do_nf_dx ! Store Candidate DX as DX

        ! -----  DX  -------------------------------------------------->

      case ( nf_dx, nf_dx_aitken ) ! Resumed here after DX = "Candidate DX"
                                   ! or DX = aj%CAIT * "Candidate DX"

        aj%dxnl = aj%dxn
        call do_NF_NewX_First

        !  -----  NewX  ----------------------------------------------->
! Continuing after return that was expected to be final:

      case ( nf_tolx, nf_tolx_best )
        call do_NF_Best ! -----  Best  -------------------------------->
      case ( nf_tolf )
        call do_NF_Solve ( before_Solve = test_F_Linear )
        ! -----  Solve  ----------------------------------------------->
      case ( nf_too_small )
        call do_nf_gmove ! -----  GMove  ------------------------------>
      case ( nf_fandj )
        call do_NF_GMove_Small ! -----  GMove  ------------------------>
      end select

    end if

  contains

    ! ...............................................  Do_NF_Best  .....
    subroutine Do_NF_Best

    ! Store best X, the gradient, and other constants used if a
    ! return needs to be made to the best X

      aj%fnormb = aj%fnorm
      nflag = nf_best
      aj%where_to = nflag 
      end subroutine Do_NF_Best

    ! .................................................  Do_NF_DX  .....
    subroutine Do_NF_DX

    ! Store Candidate DX as DX

      nflag = nf_dx
      aj%where_to = nflag
    end subroutine Do_NF_DX

    ! ..............................................  Do_NF_EvalF  .....
    subroutine Do_NF_EvalF

    ! Evaluate F

      nflag = nf_evalf
      aj%where_to = nflag
    end subroutine Do_NF_EvalF

    ! ..............................................  Do_NF_EvalJ  .....
    subroutine Do_NF_EvalJ ( New_SQL )
      real(rk), intent(in) :: New_SQL

    ! Evaluate J

      aj%sql = new_sql
      nflag = nf_evalj
      aj%where_to = nflag
    end subroutine Do_NF_EvalJ

    ! ..............................................  Do_NF_GMove  .....
    subroutine Do_NF_GMove

    ! Retreat to a previous -- best -- X and step in gradient direction.  An
    ! alternative is to use the gradients at the best X and the current X to
    ! compute the directional derivatives along the line from the best X to the
    ! current X, fit a cubic polynomial to F using Hermite interpolation, and
    ! go to the minimum of that polynomial if it's between the current X and
    ! the best X.

      nflag = nf_gmove
      aj%where_to = nflag
    end subroutine Do_NF_GMove

    ! ........................................  Do_NF_GMove_First  .....
    subroutine Do_NF_GMove_First

    ! Set up for the first gradient move after a successful Newton move

      aj%kb = -1 ! Set consecutive gradient move counter
      aj%dxbad = 0.75 * min ( aj%dxn, aj%dxbad )
      aj%dxfail = 0.125 * aj%dxbad
      aj%kfail = 1
      call do_NF_GMove_Second
    end subroutine Do_NF_GMove_First

    ! .......................................  Do_NF_GMove_Second  .....
    subroutine Do_NF_GMove_Second

    ! Set up for a gradient move after a previous gradient move, or
    ! finish setting up for a first gradient move.

      aj%kb = aj%kb - 1
      if ( aj%kb <= -4 ) then   ! Four consecutive gradient moves !

        ! Setup to test if Jacobian matrix is being computed properly

        aj%kb = 0
        aj%fnorml = 0.0
        aj%gfac = -100.0 * aj%gfac
      end if
      call do_NF_GMove
    end subroutine Do_NF_GMove_Second

    ! ........................................  Do_NF_GMove_Small  .....
    subroutine Do_NF_GMove_Small

    ! Set up for a really small gradient move.

      aj%kb = -1 ! Restart consecutive gradient move counter
      aj%gfac = -0.01_rk * aj%gfac
      call do_NF_GMove
    end subroutine Do_NF_GMove_Small

    ! .........................................  Do_NF_NewX_First  .....
    subroutine Do_NF_NewX_First

    ! Compute new X and test for too small a correction

      aj%fnorml = aj%fnorm
      aj%frzl = aj%frz
      aj%fnxe = 0.25 * aj%fnorm**2 + 0.76_rk * aj%fnxe
      call do_NF_NewX
    end subroutine Do_NF_NewX_First


    ! ...............................................  Do_NF_NewX  .....
    subroutine Do_NF_NewX

    ! Compute new X and test for too small a correction

      if ( aj%o%k1it /= 0 ) then ! Do requested debugging output
        aj%o%k1it = aj%o%k1it - 1
        call nwtdb ( aj, width=9, why='Before new X' )
      end if

      aj%starting = aj%inc < 0
      nflag = nf_newx
      aj%where_to = nflag
    end subroutine Do_NF_NewX

    ! ..............................................  Do_NF_Solve  .....

    subroutine Do_NF_Solve ( Before_Solve )
      integer, intent(in) :: Before_Solve

      ! Select new stabilizing parameter.  Also comes back here if user
      ! continues after TOLF convergence.

      if ( before_solve >= test_F_Linear ) then

        tp = min ( aj%frz / aj%frzl, aj%fnorm / aj%fnorml )

        ! Test if F appears almost linear over last step

        if ( aj%fnorm**2 < 1.125 * aj%fnxe ) then ! F appears almost linear.
          aj%spfac = 0.125 * (1.025 - aj%cdxdxl) * tp**2
          if ( aj%spl <= aj%spinc ) aj%spinc = 0.25 * aj%spinc
          aj%dxi = min ( aj%dxi, 0.25_rk )
        else ! F not linear over last step
        ! aj%spfac = tp*(aj%fnorm**2)/aj%fnxe
        ! if ( aj%cdxdxl >= 0.9_rk) aj%spfac = min(aj%spfac,0.5_rk)
        ! On 2002/07/25, FTK recommended:
          aj%spfac = min ( tp * (aj%fnorm**2) / aj%fnxe, &
                         & 32.0 * (1.025 - aj%cdxdxl)**2 )
          aj%dxi = 1.0
        end if
      end if
      if ( before_solve >= test_GradN_Increase ) then
        if ( aj%gradn > aj%gradnl ) aj%spfac = aj%spfac * aj%gradnl / aj%gradn
        aj%sp = max ( aj%spinc, min ( aj%spb, aj%spl * aj%spfac ) )
      end if
      if ( before_solve >= set_New_Marquardt ) then
        aj%sp = max ( aj%sp,aj%sqmin / aj%ajn )
    !   if ( aj%inc == 0 ) aj%sp = min(aj%sp, 0.5 * aj%spl)
        aj%spl = aj%sp
        aj%sq = aj%sp * aj%ajn
        aj%sqt = aj%sq
        if ( aj%sp < aj%spact .and. aj%inc >= 0 ) aj%sq = aj%sqmin
        aj%gradnl = aj%gradn
      end if

    ! Do Levenberg-Marquardt stabilization, solve for "Candidate DX"

      aj%starting = aj%inc < 0
      nflag = nf_solve
      aj%where_to = nflag
    end subroutine Do_NF_Solve

    ! ...............................................  Do_NF_Tolf  .....

    subroutine Do_NF_Tolf

    ! Announce function (not DX) convergence

      nflag = nf_tolf
      aj%where_to = nflag
    end subroutine Do_NF_Tolf

    ! ...............................................  F_Converge  .....
    logical function F_Converge ( )

    ! Test for convergence in sense of AJ%FNORM < (1 + AJ%O%RELSF)*AJ%FNMIN

      f_converge = .false.
      if ( aj%inc == 0 ) then
        tp = aj%fnorm - ( 1.0 + aj%o%relsf ) * aj%fnmin
        if ( tp < 0.0 ) then
                    ! WVS changed this 2012-09-10 to allow convergence
                    ! with nonzero Levenberg-Marquardt parameter
!           if ( (aj%sq <= aj%sqmin) .or. (aj%spl <= aj%o%spmini) .or. &
!            &   (tp <= -(1.0+aj%o%relsf)*aj%spl*aj%fnorm) ) then
          call do_nf_tolf
          f_converge = .true.
        end if
      end if

    end function F_Converge

    ! ...............................................  X_Converge  .....
    logical function X_Converge ( )
    ! Test whether convergence has occurred due to very small \delta X
      x_converge = .false.
      if ( aj%fnorml > 0.0 ) then ! Not doing gradient moves from the best X
        if ( aj%dxn <= aj%o%tolxa .or. &
           & ((aj%sq == 0.0).or.(aj%spl <= aj%o%spmini)) .and. &
             & aj%dxn <= aj%o%tolxr * aj%axmax ) then
          ! Convergence if aj%dxn is small enough or we have a suffiently small
          ! Levenberg-Marquardt parameter and we had a very small move.
          aj%where_to = nf_tolx
          if ( aj%kb /= 0 ) then
            aj%fnorm = aj%fnormb
            aj%where_to = nf_tolx_best
          end if
          nflag = aj%where_to
          x_converge = .true.
        end if
      end if
    end function X_Converge

  end subroutine DNWTA

! *************************************************     DNWTDB     *****

  subroutine DNWTDB ( AJ, WIDTH, WHY )

!   Print the scalars in the module.  Print the stuff in AJ if it's
!   present.  Print the integer scalars first.  Then print
!   max(5,min(9,WIDTH)) real scalars per line if width is present, else
!   print five per line.

    class (NWT_T), intent(in) :: AJ
    integer, intent(in), optional :: WIDTH
    character(len=*), intent(in), optional :: WHY ! printed if present

    integer :: I                        ! Which one in the line is being worked
    character(len=9) :: IFLname, NFLname
    integer :: MyWidth
    character(len=132) :: Name_Line     ! For names
    character(len=132) :: Output_Line   ! For values

    myWidth = 5
    if ( present(width) ) myWidth = max(5,min(9,width))

    output_line = '-----     DNWT options     ---------------------------------&
      &------------------------------------------------------------------'
    call output ( output_line(1:14*myWidth), advance='yes' )

    call flagName ( aj%where_to, iflName ); call flagName ( aj%where_to, nflName )

!   write ( *, '(a)' ) &
    call output( '  WHERE_TO        INC    ITER   ITKEN    K1IT      KB' )
    if ( present(why) ) call output ( '  WHY' )
    call newLine
    write ( output_line, '(1x,a9,i11,4i8)' ) adjustr(iflName), aj%inc, &
      & aj%iter, aj%itken, aj%o%k1it, aj%kb
    call output ( trim(output_line) )
    if ( present(why) ) call output ( '  ' // trim(why) )
    call newLine

    i = 1
    name_line = ''
    output_line = ''
    call add_to_line ( aj%o%ajscal, 'AJSCAL', name_line, i, myWidth, output_Line )
    call add_to_line ( aj%o%dxmaxi, 'DXMAXI', name_line, i, myWidth, output_Line )
    call add_to_line ( aj%o%dxnois, 'DXNOIS', name_line, i, myWidth, output_Line )
    call add_to_line ( aj%o%relsf,  'RELSF',  name_line, i, myWidth, output_Line )
    call add_to_line ( aj%o%spmini, 'SPMINI', name_line, i, myWidth, output_Line )
    call add_to_line ( aj%o%spstrt, 'SPSTRT', name_line, i, myWidth, output_Line )
    call add_to_line ( aj%o%tolxa,  'TOLXA',  name_line, i, myWidth, output_Line )
    call add_to_line ( aj%o%tolxr,  'TOLXR',  name_line, i, myWidth, output_Line )
    if ( i /= 1 ) call print_lines ( name_line, output_line, i )

    output_line = '-----     DNWT variables     -------------------------------&
      &------------------------------------------------------------------'
    call output ( output_line(1:14*myWidth), advance='yes' )
    output_line = ''

    call add_to_line ( aj%ajn,        'AJN',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%axmax,      'AXMAX',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%axmaxb,     'AXMAXB',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%cait,       'CAIT',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%cdxdxl,     'CDXDXL',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%cgdx,       'CGDX',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%condai,     'CONDAI',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%diag,       'DIAG',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxbad,      'DXBAD',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxi,        'DXI',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxinc,      'DXINC',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxnbig,     'DXNBIG',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxfail,     'DXFAIL',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxdx,       'DXDX',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxdxl,      'DXDXL',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxn,        'DXN',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%dxnl,       'DXNL',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%fnmin,      'FNMIN',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%fnminb,     'FNMINB',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%fnorm,      'FNORM',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%fnormb,     'FNORMB',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%fnorml,     'FNORML',   name_line, i, myWidth, output_Line )
    call add_to_line ( sqrt(aj%fnxe), 'FNXE**.5', name_line, i, myWidth, output_Line )
    call add_to_line ( aj%frz,        'FRZ',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%frzb,       'FRZB',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%frzl,       'FRZL',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%gdx,        'GDX',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%gfac,       'GFAC',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%gradn,      'GRADN',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%gradnb,     'GRADNB',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%gradnl,     'GRADNL',   name_line, i, myWidth, output_Line )
    call add_to_line ( aj%kfail,      'KFAIL',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%qnsq,       'QNSQ',     name_line, i, myWidth, output_Line )
    call add_to_line ( aj%sp,         'SP ',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%spact,      'SPACT',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%spb,        'SPB',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%spfac,      'SPFAC',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%spg,        'SPG',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%spinc,      'SPINC',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%spl,        'SPL',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%sq,         'SQ',       name_line, i, myWidth, output_Line )
    call add_to_line ( aj%sqb,        'SQB',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%sql,        'SQL',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%sqmin,      'SQMIN',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%sqt,        'SQT',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%kfail,      'KFAIL',    name_line, i, myWidth, output_Line )
    call add_to_line ( aj%big,        'BIG',      name_line, i, myWidth, output_Line )
    call add_to_line ( aj%starting,   'STARTING', name_line, i, myWidth, output_Line )
    if ( i /= 1 ) call print_lines ( name_line, output_line, i )

    output_line = '------------------------------------------------------------&
      &------------------------------------------------------------------'
    call output ( output_line(1:14*myWidth), advance='yes' )

  contains
  end subroutine DNWTDB

  ! The next three subroutines ought to be internal to DNWTDB, but as of
  ! 2 July 2019, some processors still don't support Fortran 2008.  In
  ! Fortran 2003, internal procedures were prohibited to be specific
  ! procedures for a generic identifier.

  subroutine Add_To_Line_R ( Value, Name, Name_Line, I, MyWidth, Output_Line )
    real(rk), intent(in) :: Value
    character(len=*), intent(in) :: Name
    character(len=*), intent(inout) :: Name_Line
    integer, intent(inout) :: I
    integer, intent(inout) :: MyWidth
    character(len=*), intent(inout) :: Output_Line
    name_line(1+14*(i-1):10+14*(i-1)) = name
    name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
    write ( output_line(1+14*(i-1):14*i), '(es13.6)' ) value
    i = i + 1
    if ( i > myWidth ) call print_lines ( name_line, output_line, i )
  end subroutine Add_To_Line_R

  subroutine Add_To_Line_I ( Value, Name, Name_Line, I, MyWidth, Output_Line )
    integer, intent(in) :: Value
    character(len=*), intent(in) :: Name
    character(len=*), intent(inout) :: Name_Line
    integer, intent(inout) :: I
    integer, intent(inout) :: MyWidth
    character(len=*), intent(inout) :: Output_Line
    name_line(1+14*(i-1):10+14*(i-1)) = name
    name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
    write ( output_line(1+14*(i-1):10+14*(i-1)), '(I10)' ) value
    i = i + 1
    if ( i > myWidth ) call print_lines ( name_line, output_line, i )
  end subroutine Add_To_Line_I

  subroutine Add_To_Line_L ( Value, Name, Name_Line, I, MyWidth, Output_Line )
    logical, intent(in) :: Value
    character(len=*), intent(in) :: Name
    character(len=*), intent(inout) :: Name_Line
    integer, intent(inout) :: I
    integer, intent(inout) :: MyWidth
    character(len=*), intent(inout) :: Output_Line
    name_line(1+14*(i-1):10+14*(i-1)) = name
    name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
    write ( output_line(1+14*(i-1):1+14*(i-1)), '(L1)' ) value
    output_line(1+14*(i-1):10+14*(i-1)) = adjustr(output_line(1+14*(i-1):10+14*(i-1)))
    i = i + 1
    if ( i > myWidth ) call print_lines ( name_line, output_line, i )
  end subroutine Add_To_Line_L

  ! The next subroutine is referenced by Add_To_Line_*, and ought to be
  ! internal to DNWTDB.

  subroutine Print_Lines ( Name_Line, Output_Line, I )
    character, intent(inout) :: Name_Line, Output_Line
    integer, intent(out) :: I
    call output ( trim(name_line), advance='yes' )
    call output ( trim(output_line), advance='yes' )
    i = 1
    name_line = ''
    output_line = ''
  end subroutine Print_Lines

! ***********************************************     FlagName     *****

  subroutine FlagName ( NFlag, ItsName )
  ! Return the name of *NWTA's flag
    integer, intent(in) :: NFlag
    character(len=*), intent(out) :: ItsName
    select case ( nflag )
    case ( NF_EVALF )
      itsName = 'EVALF'
    case ( NF_EVALJ )
      itsName = 'EVALJ'
    case ( NF_LEV )
      itsName = 'LEV'
    case ( NF_SOLVE )
      itsName = 'SOLVE'
    case ( NF_NEWX )
      itsName = 'NEWX'
    case ( NF_GMOVE )
      itsName = 'GMOVE'
    case ( NF_BEST )
      itsName = 'BEST'
    case ( NF_AITKEN )
      itsName = 'AITKEN'
    case ( NF_DX )
      itsName = 'DX'
    case ( NF_DX_AITKEN )
      itsName = 'DX_AITKEN'
    case ( NF_START )
      itsName = 'START'
    case ( NF_TOLX )
      itsName = 'TOLX'
    case ( NF_TOLX_BEST )
      itsName = 'TOLX_BEST'
    case ( NF_TOLF )
      itsName = 'TOLF'
    case ( NF_TOO_SMALL )
      itsName = 'TOO_SMALL'
    case ( NF_FANDJ )
      itsName = 'FANDJ'
    case default
      itsName = 'What???'
    end select
  end subroutine FlagName

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: dnwt_module.f90,v 2.59 2019/08/20 23:52:00 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module DNWT_MODULE

! $Log: dnwt_module.f90,v $
! Revision 2.59  2019/08/20 23:52:00  vsnyder
! Move Add_To_Line* from internal to module scope because some processors
! (NAG in particular) do not yet support internal procedures as specific
! procedures for a generic identifier.
!
! Revision 2.58  2019/06/24 23:29:26  pwagner
! Updated to reflect TA-01-143
!
! Revision 2.53  2015/05/15 23:41:01  vsnyder
! Add FNORMB to AJ
!
! Revision 2.52  2012/09/13 18:06:56  vsnyder
! Add SQMIN to AJ structure, allow convergence with nonzero lambda
!
! Revision 2.51  2012/08/30 23:04:02  vsnyder
! Use FNMIN at best X to decide on gradient move
!
! Revision 2.50  2012/04/20 01:29:21  vsnyder
! Change dxinc calculation, add QNSQ output
!
! Revision 2.49  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.48  2007/09/22 00:25:16  vsnyder
! Initialize DXMAXI to 0.1*huge() so as not to get overflow
!
! Revision 2.47  2007/01/11 20:46:33  vsnyder
! Correct a comment
!
! Revision 2.46  2006/06/08 23:55:59  vsnyder
! Tighten More' Sorensen convergence criteria, TeXnicalities
!
! Revision 2.45  2006/06/06 15:22:51  vsnyder
! Some code restructuring and commenting
!
! Revision 2.44  2006/06/03 00:15:59  vsnyder
! Respect initial Levenberg-Marquardt parameter
!
! Revision 2.43  2006/05/30 22:44:36  vsnyder
! Handle Newton moves after gradient moves better
!
! Revision 2.42  2005/06/22 18:57:01  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.41  2003/02/03 23:11:23  vsnyder
! Implement Mor\'e and Sorensen calculation of the Lavenberg parameter
!
! Revision 2.40  2003/01/18 01:39:57  vsnyder
! More output, prepare for More and Sorensen
!
! Revision 2.39  2003/01/16 21:48:37  vsnyder
! More work on internal output
!
! Revision 2.38  2003/01/16 04:06:58  vsnyder
! Change some output in DNWT
!
! Revision 2.37  2003/01/15 01:49:51  vsnyder
! Add an '12-interesting-variables' dump
!
! Revision 2.36  2002/10/25 22:24:33  livesey
! Changed order of nwt_t
!
! Revision 2.35  2002/10/23 01:15:06  livesey
! Added chiSq stuff
!
! Revision 2.34  2002/10/07 23:43:11  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.33  2002/09/23 22:04:11  vsnyder
! Correct an error message, better computation of defaults for two options
!
! Revision 2.32  2002/09/21 00:33:47  vsnyder
! Repair an error message
!
! Revision 2.31  2002/09/21 00:21:44  vsnyder
! Correct a FlagName result
!
! Revision 2.30  2002/09/19 01:25:53  vsnyder
! More on when to stop going uphill
!
! Revision 2.29  2002/09/14 02:46:00  vsnyder
! Move test for retreat-to-best, some housecleaning
!
! Revision 2.27  2002/09/11 23:41:53  vsnyder
! Correct improved test for retreating to best X
!
! Revision 2.26  2002/09/10 23:52:56  vsnyder
! Improved test for retreating to best X
!
! Revision 2.25  2002/07/26 22:46:40  vsnyder
! More better output in DNWTDB
!
! Revision 2.24  2002/07/26 01:19:18  vsnyder
! Better output in DNWTDB, changed how Levenberg_Marquardt changes, per Fred
!
! Revision 2.23  2002/07/24 20:32:15  vsnyder
! Moved AXMAX, AXMAXB, CGDX, SP and SQ from DNWTA to module scope.
! Added a "get DNWT's guts" routine.
!
! Revision 2.22  2002/07/24 01:08:11  vsnyder
! Made most local variables SAVE.  Mark Filipiak noticed this problem.
!
! Revision 2.21  2002/02/14 21:53:10  vsnyder
! Add parameters for largest and smallest nwt_flag values
!
! Revision 2.20  2002/01/09 00:00:04  pwagner
! Replaced write or print statements with calls to output
!
! Revision 2.19  2001/06/13 23:57:12  vsnyder
! Use NF_START instead of zero to start IFL
!
! Revision 2.18  2001/06/13 23:50:57  vsnyder
! Correct not-restarting-correctly in DNWT
!
! Revision 2.17  2001/06/01 23:04:11  vsnyder
! Corrected two bugs having to do with Aitken acceleration
!
! Revision 2.16  2001/06/01 01:38:27  vsnyder
! Correct some comments, and some cosmetic changes
!
! Revision 2.15  2001/05/25 20:14:01  vsnyder
! Replace 1p5e format that NAG doesn't like with 5es format
!
! Revision 2.14  2001/05/25 04:58:50  livesey
! Had to comment out some of Van's code to make it compile on NAG.
!
! Revision 2.13  2001/05/24 23:28:06  vsnyder
! Improve internal output; initial value for dxnl=1, not zero
!
! Revision 2.12  2001/05/24 20:23:41  vsnyder
! Keep aj%dxn up to date after Gradient or Aitken moves
!
! Revision 2.11  2001/05/24 18:16:11  vsnyder
! Added NF_START parameter; initially define aj%dxdxl
!
! Revision 2.10  2001/05/22 19:10:33  vsnyder
! Compute aj%starting; improve some comments
!
! Revision 2.9  2001/05/18 01:02:43  vsnyder
! Checking for 'big' move incorrectly
!
! Revision 2.8  2001/05/17 20:15:28  vsnyder
! Make sure aj%dxdxl has an initial value
!
! Revision 2.7  2001/05/12 01:10:24  vsnyder
! Correct 'iter' calculation, add 'FlagName' subroutine
!
! Revision 2.6  2001/05/03 02:00:39  vsnyder
! Insert copyright notice
!
! Revision 2.5  2001/04/28 01:47:39  vsnyder
! Get correct initial value for nflag
!
! Revision 2.4  2001/04/12 00:03:21  vsnyder
! Put 'Total Levenberg-Marquart' in AJ
!
! Revision 2.3  2001/02/16 00:19:34  vsnyder
! Corrected some comments; changed a dummy argument name.
!
! Revision 2.2  2001/02/06 23:33:54  vsnyder
! Initially botched putting in the CVS variables; got it right this time.
!
! Revision 2.1  2001/02/06 23:23:53  vsnyder
! Initial commit
!
@


2.59
log
@Move Add_To_Line* from internal to module scope because some processors
(NAG in particular) do not yet support internal procedures as specific
procedures for a generic identifier.
@
text
@d534 7
d558 1
a558 1
                    ! Error processing
d581 4
d591 1
a591 1
            aj%inc = aj%inc + 1 ! Increase count of "uphill" moves
d623 2
a624 2
            ! Select new stabilizing parameter for the case when AJ%FNORM
            ! has increased
d707 1
a707 1
        if ( aj%inc < 0 ) then
d727 1
a727 1
              if ( aj%inc == 0 ) then
d1392 1
a1392 1
       "$Id: dnwt_module.f90,v 2.58 2019/06/24 23:29:26 pwagner Exp $"
d1402 5
@


2.58
log
@Updated to reflect TA-01-143
@
text
@d133 1
a133 1
  use Ermsg_m, only: Ermsg, Ervn
d372 8
a1178 4
    interface Add_To_Line
      procedure Add_To_Line_I, Add_To_Line_L, Add_To_Line_R
    end interface

d1201 9
a1209 9
    call add_to_line ( aj%o%ajscal, 'AJSCAL' )
    call add_to_line ( aj%o%dxmaxi, 'DXMAXI' )
    call add_to_line ( aj%o%dxnois, 'DXNOIS' )
    call add_to_line ( aj%o%relsf,  'RELSF' )
    call add_to_line ( aj%o%spmini, 'SPMINI' )
    call add_to_line ( aj%o%spstrt, 'SPSTRT' )
    call add_to_line ( aj%o%tolxa,  'TOLXA' )
    call add_to_line ( aj%o%tolxr,  'TOLXR' )
    if ( i /= 1 ) call print_lines
d1216 49
a1264 49
    call add_to_line ( aj%ajn,        'AJN' )
    call add_to_line ( aj%axmax,      'AXMAX' )
    call add_to_line ( aj%axmaxb,     'AXMAXB' )
    call add_to_line ( aj%cait,       'CAIT' )
    call add_to_line ( aj%cdxdxl,     'CDXDXL' )
    call add_to_line ( aj%cgdx,       'CGDX' )
    call add_to_line ( aj%condai,     'CONDAI' )
    call add_to_line ( aj%diag,       'DIAG' )
    call add_to_line ( aj%dxbad,      'DXBAD' )
    call add_to_line ( aj%dxi,        'DXI' )
    call add_to_line ( aj%dxinc,      'DXINC' )
    call add_to_line ( aj%dxnbig,     'DXNBIG' )
    call add_to_line ( aj%dxfail,     'DXFAIL' )
    call add_to_line ( aj%dxdx,       'DXDX' )
    call add_to_line ( aj%dxdxl,      'DXDXL' )
    call add_to_line ( aj%dxn,        'DXN' )
    call add_to_line ( aj%dxnl,       'DXNL' )
    call add_to_line ( aj%fnmin,      'FNMIN' )
    call add_to_line ( aj%fnminb,     'FNMINB' )
    call add_to_line ( aj%fnorm,      'FNORM' )
    call add_to_line ( aj%fnormb,     'FNORMB' )
    call add_to_line ( aj%fnorml,     'FNORML' )
    call add_to_line ( sqrt(aj%fnxe), 'FNXE**.5')
    call add_to_line ( aj%frz,        'FRZ' )
    call add_to_line ( aj%frzb,       'FRZB' )
    call add_to_line ( aj%frzl,       'FRZL' )
    call add_to_line ( aj%gdx,        'GDX' )
    call add_to_line ( aj%gfac,       'GFAC' )
    call add_to_line ( aj%gradn,      'GRADN' )
    call add_to_line ( aj%gradnb,     'GRADNB' )
    call add_to_line ( aj%gradnl,     'GRADNL' )
    call add_to_line ( aj%kfail,      'KFAIL' )
    call add_to_line ( aj%qnsq,       'QNSQ' )
    call add_to_line ( aj%sp,         'SP ' )
    call add_to_line ( aj%spact,      'SPACT' )
    call add_to_line ( aj%spb,        'SPB' )
    call add_to_line ( aj%spfac,      'SPFAC' )
    call add_to_line ( aj%spg,        'SPG' )
    call add_to_line ( aj%spinc,      'SPINC' )
    call add_to_line ( aj%spl,        'SPL' )
    call add_to_line ( aj%sq,         'SQ' )
    call add_to_line ( aj%sqb,        'SQB' )
    call add_to_line ( aj%sql,        'SQL' )
    call add_to_line ( aj%sqmin,      'SQMIN' )
    call add_to_line ( aj%sqt,        'SQT' )
    call add_to_line ( aj%kfail,      'KFAIL' )
    call add_to_line ( aj%big,        'BIG' )
    call add_to_line ( aj%starting,   'STARTING' )
    if ( i /= 1 ) call print_lines
a1270 35
    subroutine Add_To_Line_R ( Value, Name )
      real(rk), intent(in) :: Value
      character(len=*), intent(in) :: Name
      name_line(1+14*(i-1):10+14*(i-1)) = name
      name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
      write ( output_line(1+14*(i-1):14*i), '(es13.6)' ) value
      i = i + 1
      if ( i > myWidth ) call print_lines
    end subroutine Add_To_Line_R
    subroutine Add_To_Line_I ( Value, Name )
      integer, intent(in) :: Value
      character(len=*), intent(in) :: Name
      name_line(1+14*(i-1):10+14*(i-1)) = name
      name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
      write ( output_line(1+14*(i-1):10+14*(i-1)), '(I10)' ) value
      i = i + 1
      if ( i > myWidth ) call print_lines
    end subroutine Add_To_Line_I
    subroutine Add_To_Line_L ( Value, Name )
      logical, intent(in) :: Value
      character(len=*), intent(in) :: Name
      name_line(1+14*(i-1):10+14*(i-1)) = name
      name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
      write ( output_line(1+14*(i-1):1+14*(i-1)), '(L1)' ) value
      output_line(1+14*(i-1):10+14*(i-1)) = adjustr(output_line(1+14*(i-1):10+14*(i-1)))
      i = i + 1
      if ( i > myWidth ) call print_lines
    end subroutine Add_To_Line_L
    subroutine Print_Lines
      call output ( trim(name_line), advance='yes' )
      call output ( trim(output_line), advance='yes' )
      i = 1
      name_line = ''
      output_line = ''
    end subroutine Print_Lines
d1273 61
d1381 1
a1381 1
       "$Id: dnwt_module.f90,v 2.53 2015/05/15 23:41:01 vsnyder Exp $"
d1391 3
@


2.57
log
@Use specific Add_To_Line_? routines because some processors still don't
allow internal procedures to be specifics for generics.
@
text
@a0 1
!*==dnwt_module.f    processed by SPAG 7.20RA at 19:07 on 16 Jul 2018
d14 1
a14 1
!>> 2000-03-21 DNWT_Module W. V. Snyder Converted to Fortran 90
a17 5
! All versions use ERMSG.
! ERMSG and ERVN need ERFIN.

! ***** THIS PACKAGE IS STILL UNDER DEVELOPMENT ******

d20 2
a21 2
! These subroutines solve F(X)=0 (or find the least square solution)
! where F is a vector with NF components, and X is a vector with NX
d26 1
a26 1
! is required. When this return is made NFLAG will be set to indicate
d32 1
a32 1
! Assign values to XOPT( ) and NOPT( ).
d35 1
a35 1
! **  CALL NWT ( NFLAG, AJ, XOPT, NOPT)                 **
d41 4
a44 1
!     Set X( ) = initial guess for the solution,
d48 1
a48 1
! **    CALL NWTA ( NFLAG, AJ )                  **
d50 1
a50 1
!       SELECT CASE ( NFLAG ) ! NFLAG > 0 means "Done", <0 means "Continue"
d53 4
a56 3
!         Compute F(X)
!         Compute the Jacobian matrix J if you feel like it
!         Set AJ%FNORM = L2 norm of F(X)
d60 1
a60 1
!         Compute the Jacobian matrix J if you didn't do it when NFLAG
d62 1
a62 1
!           J(K,L) = Partial of F(K) / W.R.T. X(L), K = 1, NF, L = 1, NX
d65 2
a66 2
!         J**T * J * "Candidate DX" = -J**T * F.
!         Triangularize J.
d68 3
a70 4
!           AJ%DIAG = element on diagonal with smallest absolute value,
!                   after triangularization,
!           AJ%AJN = maximum L1 norm of column in upper triangle
!                   after triangularization,
d74 3
a76 3
!                   the last column of J before triangularization, either by
!                   Householder or by Cholesky factoring the normal equations,
!                   this is J(N+1,N+1)),
d78 3
d88 3
a90 1
!         and solve (Jacobian) * "candidate DX" ~ -F for "candidate DX".
d116 1
a116 1
!         IF ( NFLAG == NF_TOO_SMALL ) THEN
d119 1
a119 1
!         If ( NFLAG == NF_TOLX_BEST ) copy "best X" to "X"
d125 1
a125 1
!         A warning has been printed by the error processor.
d128 1
a128 1
!           (next NFLAG == NF_Gmove).
d130 1
a130 1
!       IF ( you want to return to a previous best X ) NFLAG = NF_START
d133 1
a133 1
  use ERMSG_M, only: Ermsg, Ervn
d140 2
a141 2
  public :: RK, DNWT, DNWTA, DNWTDB, DNWTOP, DNWT_GUTS
  public ::     NWT,  NWTA,  NWTDB,  NWTOP,  NWT_GUTS, NWT_T
d144 1
a144 1
  ! Start or restart:
d146 1
d148 1
d150 1
d153 1
d156 1
d158 1
a158 1
  !      stabilization parameter
d160 1
d163 1
d169 1
d172 2
a173 1
  !      Set "Best X" = X, "Best Gradient" = Gradient
d175 1
d180 2
a181 1
  !      Set DX = "Candidate DX"
d183 2
a184 1
  !      Set DX = AJ%CAIT * "Candidate DX"
d188 1
d191 1
d195 1
d198 1
d201 1
d204 5
a208 4
  !      Indicate not ready to return:
  integer, parameter, private :: NF_NOTHING = nf_fandj+1
  !      In case you want to add some flags of your own...
  integer, parameter, public :: NF_BIGGEST_FLAG = NF_NOTHING
d213 31
a243 22
  type NWT_Options    ! Options that can be set by DNWTOP
    real(rk) :: AJSCAL = eps         ! Approximate absolute error in computing the
                                     ! Jacobian
    real(rk) :: DXMAXI = 0.1*cbig    ! Largest value permitted for DXINC at any time
    real(rk) :: DXNOIS = 0.0         ! 1.0E-4_rk * largest move that gives a new best X
                                     ! (used to see if increase in AJ%FNORM might be
                                     ! due to too small a step)
    integer :: K1IT = 0              ! Number of iterations to give basic internal output
    real(rk) :: RELSF = max(0.01_rk,eps) ! Convergence is indicated with NFLAG = NF_TOLF if
                                     ! AJ%FNORM - AJ%FNMIN < RELSF*AJ%FNMIN
    real(rk) :: SPMINI = eps         ! Nominal minimum value for normalized Marquardt
                                     ! parameter
    real(rk) :: SPSTRT = 0.1_rk      ! Starting value for normalized Marquardt parameter
    real(rk) :: TOLXA = 0.0          ! Absolute tolerance on X.  Convergence is indicated
                                     ! with NFLAG = NF_TOLX* if the (possibly scaled)
                                     ! norm of the difference between the current x and
                                     ! the solution is estimated to be <= TOLXA.
    real(rk) :: TOLXR = 0.0          ! Relative tolerance on X.  Convergence is indicated
                                     ! with NFLAG = NF_TOLX* if the (possibly scaled)
                                     ! norm of the difference between the current x and
                                     ! the solution is estimated to be <= TOLXR * max
                                     ! (abs(X(i))).
d248 6
a253 3
  type NWT_T               ! Stuff about the problem, neatly packaged.  This
                           ! is the type of the AJ argument of NWTA.
    ! Inputs to ?NWTA.  See usage instructions above.
d255 33
a287 20
                           ! of factored Jacobian matrix
    real(rk) :: AXMAX      ! MAXVAL(ABS(X))
    real(rk) :: DIAG       ! Smallest | diagonal element | after factoring
    real(rk) :: DXDX       ! dot_product( DX, DX )
    real(rk) :: DXDXL      ! dot_product( "candidate DX", DX )
    real(rk) :: DXN        ! L2 Norm of candidate DX (Newton step length)
    real(rk) :: FNMIN      ! L2 Norm of F not in column space of the Jacobian
    real(rk) :: FNORM      ! L2 Norm of F at current X
    real(rk) :: GDX        ! dot_product( Gradient, "Candidate DX" )
    real(rk) :: GFAC       ! Factor by which the gradient is to be multiplied
                           ! when taking a gradient move from the best X
    real(rk) :: GRADN      ! L2 norm of Gradient
    real(rk) :: QNSQ       ! Square of norm of solution of U^T q = x
    real(rk) :: SQMIN = 0.0 ! Current minimum value of SQ ; recommend to use
                           ! this as a floor for Levenberg-Marquardt
                           ! stabilization in the caller
    logical :: BIG         ! ANY( DX > 10.0 * epsilon(X) * X )
    ! Outputs from ?NWTA
    real(rk) :: CAIT = 0.0 ! Candidate factor for Aitken acceleration
    real(rk) :: DXINC      ! Largest value for DXN currently allowed
d290 5
a294 2
                           ! ABS(SQ) gives the acceleration factor
    real(rk) :: SQT = 0.0  ! Total Levenberg-Marquardt stabilization
d296 2
a297 1
    ! Values retained from return until next call
d307 2
a308 1
    real(rk) :: DXNBIG     ! A size of move that should be safe.
d322 14
d355 2
a356 1
    integer :: WHERE_TO = NF_Start   ! Internal value of NFLAG, to remember
d359 12
a370 16
    ! Temporary only, but here for printing by ?NWTDB
    real(rk) :: CGDX       ! COS of angle between gradient and DX
  end type NWT_T

  interface NWT
    module procedure DNWT
  end interface
  interface NWTA
    module procedure DNWTA
  end interface
  interface NWTDB
    module procedure DNWTDB
  end interface
  interface NWTOP
    module procedure DNWTOP
  end interface
a372 24
  save

  ! Variables that can be set from the option vector:

  real(rk) :: AJSCAL
  real(rk) :: DXMAXI
  real(rk) :: DXNOIS
  real(rk) :: RELSF
  real(rk) :: SPMINI, SPSTRT
  real(rk) :: TOLXA, TOLXR      ! WVS added 2000-04-05
  integer :: K1IT

  integer :: INC, ITER, ITKEN
  integer :: KB

  type NWT_GUTS    ! Public type returned by DNWT_GUTS
    real(rk) :: AJSCAL
    real(rk) :: DXMAXI, DXNOIS
    integer :: INC, ITER, ITKEN
    integer :: K1IT, KB
    real(rk) :: RELSF, SPMINI
    real(rk) :: SPSTRT
    real(rk) :: TOLXA, TOLXR      ! WVS added 2000-04-05
  end type NWT_GUTS
d379 1
a379 1
  private :: not_used_here
d383 1
d385 4
a388 1
  subroutine DNWT ( NFLAG, AJ, XOPT, NOPT )
d400 1
a400 1
! Variables in the calling sequence are of the following types
d402 3
a404 4
    integer, intent(out) :: NFLAG
    type(nwt_t), intent(inout) :: AJ
    real(rk), intent(in) :: XOPT(*)
    integer, intent(in), optional :: NOPT(*)
d408 3
a410 67
! NFLAG  = Integer used for communication with the user.  NWT sets NFLAG =
!     NF_START.  NFLAG is used by NWTA.  When NWTA returns control to the
!     calling program unit, NFLAG is used as shown above.

! XOPT( ) = Array used for values needed to set options; see NOPT below.

! NOPT( ) = Array of options.
!           If no options are being used, omit NOPT or set NOPT(1) = 0.
!           Otherwise set NOPT(1) /= 0; then NOPT( ) must be a vector,
!           with dimension that depends on the options being specified.
!           Any option below which uses NOPT(K) as a pointer to a loca-
!           tion in XOPT( ) requires NOPT(K) > 7 * NX.  In such a case,
!           IDIMX should be increased as required by the pointer and
!           the option.

!           Define I=1 initially, and after the specification of any
!           option let I=index of next location in NOPT.  Then
!    NOPT(I)
!    = 0    No more options.  The last location in NOPT( ) must always
!           equal 0.
!    = 1    Give the basic internal output for NOPT(I+1) iterations.
!    = 2    Same as 1 above, except AJ is also printed.
!    = 3    Not used.  Do not use.
!    = 4    Not used.  Do not use.
!    = 5    Not used.  Do not use.
!    = 6    Not used.  Do not use.
!    = 7    Not used.  Do not use.
!    = 8    Not used.  Do not use.
!    = 9    Reserved -- currently sets all options to their default values.
!    = 10   Set all options to their default values.
!    = 11   Set SPSTRT = XOPT(NOPT(I+1)), where SPSTRT is the starting
!           value of the normalized Levenberg-Marquardt parameter.
!           NOPT(I) = -11 gives SPSTRT = 0.1  .
!    = 12   Set SPMINI = XOPT(NOPT(I+1)), where SPMINI is the approximate
!           relative error in computing the Jacobian. NOPT(I)= -12 gives
!           SPMINI= 10**(1-D) where D is the number of significant
!           digits in the floating point numbers used.
!    = 13   Set AJSCAL = XOPT(NOPT(I+1)), where AJSCAL is the approximate
!           absolute error in computing the Jacobian. NOPT(I)= -13 gives
!           AJSCAL = 0  .
!    = 14   Set DXMAXI = XOPT(NOPT(I+1)), where DXMAXI is the largest value
!           permitted for DXINC at any time. NOPT(I)= -14 gives
!           DXMAXI = 10**30  .
!    = 15   Set RELSF = XOPT(NOPT(I+1)), where convergence is indicated
!           with NFLAG = NF_TOLF if AJ%FNORM - AJ%FNMIN < RELSF * AJ%FNMIN .
!           NOPT(I) = -15 gives RELSF = 0.01  .
!    = 16   Set DXNIOS = XOPT(NOPT(I+1)), where DXNOIS is the smallest move
!           considered to be significant when the norm of f increases.
!           The initial default is 0, but DXNOIS is updated later.
!    = 17   Set TOLXA = XOPT(NOPT(I+1)), where convergence is indicated
!           with NFLAG = NF_TOLX* if the (possibly scaled) norm of the
!           difference between the current x and the solution is
!           estimated to be <= TOLXA.  The default value is
!           (underflow limit) ** .75.
!    = 18   Set TOLXR = XOPT(NOPT(I+1)), where convergence is indicated
!           with NFLAG = NF_TOLX* if the (possibly scaled) norm of the
!           difference between the current x and the solution is
!           estimated to be <= TOLXR * max (abs(X(i))).  The default
!           value is (relative precision) ** .75.
!    = 19   Not used.  Do not use.

!           Any option once set remains set until turned off. In order
!           to return the option with NOPT(I)= K to the nominal state,
!           set NOPT(I)= -K.  The same number of cells in NOPT are requi-
!           red for the -K case, even though any additional cells requi-
!           red by the K case are not referenced.
!???        This appears not to be the way DNWTOP works
d412 4
a415 1
!****************** END OF INITIAL COMMENTS ****************
a416 1
    nflag = nf_start
d418 2
a419 2
    if ( present(nopt) ) call nwtop ( aj, nopt, xopt )
    call nwtop ( aj ) ! default initialization
d425 1
a425 1
  subroutine DNWTA ( NFLAG, AJ )
d429 1
a429 2
! This subroutine is referenced by the user.
! Arguments in the calling sequence are defined below.
d431 3
a433 2
    integer, intent(inout) :: NFLAG ! See usage instructions above
    type(nwt_t), intent(inout) :: AJ
d435 1
a435 1
!                V A R I A B L E   D E F I N I T I O N S
d437 3
a440 28
! AJ       About the Jacobian.  See usage instructions above.
! AJSCAL   Approximate absolute error in computing the Jacobian

! CBIG     Constant 'BIG' = HUGE()

! DXMAXI   Largest value permitted for DXINC at any time
! DXNOIS   1.0E-4_rk * largest move that gives a new best X (used to
!          see if increase in AJ%FNORM might be due to too small a step)

! INC      Flag set to indicate some past history
!          =-1  Starting
!          =0   Last X == best X
!          =J>0 AJ%FNORM > AJ%FNORML  J times since last best X
! ITER     Number of current iteration
! ITKEN    Index used to keep track of Aitken accelerations

! K1IT     Number of iterations to give basic internal output
! KB       Flag set to indicate some past history
!          =2    Starting
!          =-J   (J>0) Making gradient move from best X (-KB serves as
!                a counter)
!          =1    Last F is bigger than the best F
!          =0    (INC >0) trying a move in wrong direction from the
!                best X
!          =0    (INC =0) new best X

! RELSF    Convergence is indicated with NFLAG = NF_TOLF if
!          AJ%FNORM - AJ%FNMIN < RELSF*AJ%FNMIN
d442 1
a442 14
!          accuracy (RND is 10 times the round-off level)

! SPMINI   Nominal minimum value for normalized Marquardt parameter
! SPSTRT   Starting value for normalized Marquardt parameter

! TOLXA    absolute tolerance on X
! TOLXC    tolerance on X
! TP       Temporary storage

!-----     Parameters and Unsaved Local Variables     ------------------

    integer, parameter :: INCBIG = huge(inc) / 2

    real(rk) :: TP       ! Widely used temporary variable
d458 1
a458 1
      if ( aj%where_to == nf_start ) then
d468 5
a472 5
        inc = -1 ! Starting
      ! inc = 0  ! Pretend we're at a "best"
        iter = 0
        itken = 0
        kb = 2
d474 1
d479 1
a479 2
      else
        ! User forcing retreat to best X followed by gradient move
d483 5
d490 1
a490 1
      call ermsg ( me, 99, 2, &
d495 6
a500 2
      ! Continuing after return for reverse communication for the caller
      ! to do some computation:
d502 1
a502 2
      select case ( aj%where_to )        ! Reason for returning
      case ( nf_evalf )                  ! Resumed after evaluating F
d504 19
a522 1
        ! Re-enter after evaluating F.
d524 1
a524 1
        iter = iter + 1
d526 4
a529 1
        ! Test if a retreat to a previous -- best -- X should be made
d531 4
a534 2
        tp = 0.9_rk * aj%spl * aj%ajn     ! .9 times sql on previous iteration
        if ( aj%fnorm >= aj%fnorml ) then ! Things are not getting better
d536 5
a540 12
        ! AJ%FNORML will have been set to zero if there are four consecutive
        ! gradient moves.
        ! Test for X convergence

          if ( x_converge() ) return
          if ( inc >= 0 ) then   ! We are not starting
            if ( inc == 0 ) then ! Last X == Best X
              aj%dxnbig = max(aj%dxnl,dxnois)

            else  ! inc > 0 -- Not starting, Last X not Best X
              if ( kb == 0 ) then
                if ( aj%fnorm < aj%fnormb ) then ! New best |F|
d542 1
a542 1
                  if ( aj%gfac >= 0 ) then
d544 4
a547 4
                    call ermsg ( me, 2, 0, 'J or F may be in error', '.' )
                    nflag = nf_fandj
                    aj%where_to = nflag
                    return
d551 1
a551 1
                return
d553 3
a555 3
              if ( aj%dxnl <= dxnois ) then ! Last Newton move tiny?
                call do_NF_EvalJ ( tp )
                return
d557 3
a559 3
              if ( kb < 0 ) then ! Gradient move last time
                call do_NF_Gmove_second
                return
d561 1
d563 5
a567 5
!             if ( (tp >= min(aj%sql,aj%sqb+aj%sqb)) .or. (inc >= incbig) ) then
              if ( aj%fnmin > (1.0+0.5*relsf)*aj%fnminb .or. &
                 & inc >= incbig ) then
                call do_NF_GMove_First
                return
d570 3
a572 16
            aj%sqmin = min(aj%sqb, max(aj%spl, aj%spact) * 4.0 * aj%ajn)
            aj%dxinc = max(aj%dxnl * 0.5,dxnois)
            inc = inc + 1
          end if
        else if ( aj%fnorm >= aj%fnormb ) then ! Things are getting better, but
                                               ! no better than at the best X
          ! If our Marquardt parameter is small and AJ%FNORM does not appear to
          ! be getting close to or smaller than AJ%FNORMB, and we are not
          ! making a move in a quite different direction we give up and go back
          ! to the previous best X and take a gradient move.

          if ( (max(tp,aj%sql) <= aj%sqmin) .and. &
             & ((aj%fnorm*(aj%fnorm/aj%fnorml)**2) > aj%fnormb) .and. &
             & (aj%cdxdxl >= 0.25_rk) ) then
            call Do_NF_GMove_First
            return
d576 1
a576 3
        call do_NF_EvalJ ( tp )

      case ( nf_evalj )              ! Resumed after evaluating J
d578 1
a578 1
        ! Re-enter after evaluating Jacobian
a579 4
        ! diag =  Smallest | diagonal element | after factoring
        ! ajn =   Largest L1 norm of column in upper triangle
        ! fnmin = L2 Norm of F not in column space of the Jacobian
        ! gradn = L2 norm of gradient
d581 2
a582 2
          aj%gradn = 1.0
          if ( aj%ajn <= 0.0 ) aj%ajn = 1.0
d584 2
a585 2
        tp = aj%diag/aj%ajn
        aj%condai = max(min(aj%condai,tp),tp**2)
a586 1
        aj%frz = sqrt(abs((aj%fnorm-aj%fnmin)*(aj%fnorm+aj%fnmin)))
d588 5
a592 2
        if ( iter == 1 ) then ! First iteration
          aj%sp = spstrt
d594 3
a596 3
          if ( aj%frz <= rnd*aj%fnmin ) then
            call do_nf_tolf
            return
d598 1
a598 1
          aj%dxi = 0.125_rk
d600 1
a600 1
          if ( aj%fnorm >= aj%fnorml ) then  ! AJ%FNORM increased
d602 1
a602 2
            ! Select new stabilizing parameter for case when AJ%FNORM has
            ! increased
d604 8
a611 5
            kb = 1
            if ( aj%dxnl < dxnois ) then
              aj%sp = 1.0E-4_rk * aj%sp
              aj%sqmin = min(aj%sqmin, aj%sp * aj%ajn)
            ! aj%dxnl = aj%dxnl * 100.0
d613 1
d615 1
a615 1
            aj%spfac = max( (aj%fnorm / aj%fnorml)**2, 10.0_rk )
d618 2
a619 1
            call do_NF_Solve ( before_Solve = test_gradn_increase )
d622 1
d625 1
a625 1
            return
d632 13
a644 11
          if ( kb /=0 ) then ! Got new best immediately
            aj%dxfail = min(1.0625_rk*aj%dxfail,aj%dxbad)
          else if ( aj%dxn >= 0.9_rk*aj%dxbad ) then
            aj%dxbad = aj%dxbad*(1.25_rk**aj%kfail)
            aj%dxfail = aj%dxbad
            aj%kfail = aj%kfail + 1
          else
            aj%dxfail = 0.75_rk*aj%dxfail + 0.25_rk*aj%dxbad
            aj%kfail = 1
          end if
          aj%dxinc = min(dxmaxi,aj%dxfail)
d646 1
a646 1
          aj%dxinc = dxmaxi
d649 2
a650 1
        aj%spinc = min(aj%spinc, max(spmini, abs(ajscal) / aj%ajn))
d654 1
a654 1
        if ( inc < 0 ) then ! Starting
d656 1
a656 1
          return
d658 2
a659 2
        if ( inc /= 0 ) then
          if ( kb < 0 ) then
d661 1
a661 1
          else if ( kb == 1 ) then
d663 1
a663 1
            aj%dxi = 0.25 * aj%dxnl / aj%dxnbig
d665 2
a666 2
          kb = 0
          inc = 0
d668 3
d672 1
a672 1
          & call do_NF_Solve ( before_Solve = test_f_linear )
d674 1
a674 1
      case ( nf_solve )              ! Resumed after solving for DX
d676 2
a677 2
      ! Re-enter after doing Levenberg-Marquardt stabilization and solving for
      ! candidate DX
d679 22
a700 6
        ! fnmin = L2 Norm of F not in column space of the Jacobian
        aj%cgdx = aj%gdx/(aj%gradn*aj%dxn) ! Cosine ( gradient, dx )
        aj%condai = min(aj%cgdx,aj%gradn/(aj%dxn*aj%ajn**2),aj%diag/aj%ajn)
        aj%fnxe = aj%fnmin**2 - (aj%sq*aj%dxn)**2
        if ( inc >= 0 ) then
          aj%cdxdxl = aj%dxdxl/(aj%dxn*aj%dxnl) ! cosine between DX and last DX
d702 1
a702 1
            if ( k1it /= 0 ) call nwtdb ( width=9, level=0, why='Give up' )
d704 1
a704 1
            return
d706 3
a708 3
          if ( aj%dxn < 1.1_rk*aj%dxinc ) then
            if ( aj%sq <= 0.0 .or. aj%dxn > 0.90_rk*aj%dxinc ) then
              if ( inc==0 ) then
d710 1
a710 1
                return
d713 2
a714 2
              call do_NF_DX
              return
d716 3
a718 3
!! WVS: was          dxinc = aj%dxi * aj%dxn * (1.0 - aj%cdxdxl)**2
!! This was clearly wrong, since it says "If consecutive Newton moves are in
!! the same direction, take shorter steps"
a720 5
        else if ( aj%dxn <= aj%dxinc ) then ! Move length OK?
          inc = incbig
          aj%cdxdxl = 0.0 ! Don't think about Aitken
          call do_nf_best
          return
d725 4
a728 1
        if ( k1it /= 0 ) call nwtdb ( width=9, level=0, why='Step length' )
d730 15
a744 16
        !{ Calculate {\tt qn}$^2 = {\bf q}^T{\bf q} = ||{\bf q}||^2$, used
        !  to determine the Levenberg-Marquardt parameter $\lambda$, where
        !  ${\bf q} = {\bf U}^{-T} {\delta\bf x}$ and ${\delta\bf x}$ is the
        !  Newton step computed with the current value of $\lambda$.  The
        !  method to determine $\lambda$ and the reason for being interested
        !  in ${\bf q}^T{\bf q}$ are explained below.

        nflag = nf_lev
        aj%where_to = nflag

      case ( nf_lev )              ! Resumed after doing the calculations for
                                   ! the Moré-Sorensen algorithm

!{ Determine the Levenberg-Marquardt parameter $\lambda$, known here as AJ%SQ.
!  The last Marquardt parameter used was AJ%SQ, which means that AJ%SQ**2 was
!  added to the diagonal of the normal equations.  A little bit of
d747 1
a747 1
!  $({\bf H} + \lambda {\bf I}) {\delta\bf x} = -{\bf g}$,
d750 1
a750 1
!  where ${\bf J}$ is the Jacobian matrix, is an approximate Hessian.
d753 1
a753 1
!  $({\bf H} + \lambda {\bf I}) \frac{\text{d}{\delta\bf x}}{\text{d}\lambda}
d755 1
a755 1
!  $({\bf H} + \lambda {\bf I}) \frac{\text{d}{\delta\bf x}}{\text{d}\lambda}
d759 2
a760 2
!  ${\bf U}^T {\bf U} \frac{\text{d}{\delta\bf x}}{\text{d}\lambda} =
!  -{\delta\bf x}$ or ${\bf U} \frac{\text{d}{\delta\bf x}}{\text{d}\lambda} =
d763 2
a764 2
!  Multiplying ${\bf U}^T {\bf U} \frac{\text{d}{\delta\bf x}}{\text{d}\lambda} =
!  -{\delta\bf x}$ on the left by $\frac{\text{d}{\delta\bf x}}{\text{d}\lambda}^T$
d766 4
a769 4
!  ${\bf U} \frac{\text{d}{\delta\bf x}}{\text{d}\lambda} = - {\bf q}$ we have
!  $\frac{\text{d}{\delta\bf x}}{\text{d}\lambda}^T {\bf U}^T {\bf U}
!   \frac{\text{d}{\delta\bf x}}{\text{d}\lambda}
!  = -\frac{\text{d}{\delta\bf x}}{\text{d}\lambda}^T {\delta\bf x} =
d777 1
a777 1
!  $\frac{\text{d}\phi}{\text{d}\lambda} =
d780 1
a780 1
!  \frac{\text{d}{\delta\bf x}}{\text{d}\lambda}
d782 1
a782 1
!    \frac{\text{d}{\delta\bf x}}{\text{d}\lambda}
d788 1
a788 1
!    \phi / \frac{\text{d}\phi}{\text{d}\lambda_{\text{old}}}
d794 2
a795 2
! If you have been looking at Mor\'e and Sorensen, this update is the
! negative of theirs since they define $\lambda$ as the negative of the
d810 1
a810 1
! {\delta\bf x} = -{\bf J}^T {\bf f} = -{\bf g}$.
d812 3
a814 2
        aj%sq = sqrt(max(0.0_rk, &
                         aj%sq**2-(aj%dxn**2/aj%qnsq)*(1.0 - aj%dxn/aj%dxinc)))
a815 1
        ! Solve again with new Marquardt parameter
d818 1
a818 1
      case ( nf_newx )               ! Resumed after calculating new X
d820 1
a820 1
        ! Re-enter after computing new X
d822 3
a824 4
        if ( .not. aj%big ) then ! All dx's are very small
          if ( (aj%spl <= spmini) .or. (aj%sq == 0.0) ) then

            if ( (inc > 0) .and. (kb /= 0) ) then ! Go do gradient move
d826 3
a828 1
              return
d830 1
a830 8

            ! Convergence -- move too small

            nflag = nf_too_small
            aj%where_to = nflag
            return
          else
            dxnois = max(dxnois,10.0_rk*aj%dxn) ! Set so steps don't get too small.
d832 2
d835 1
d837 1
a837 5
        call do_NF_Evalf

      case ( nf_gmove )              ! Resumed after gradient move from best X

        ! Re-enter after computing gradient step from best X
d839 2
a840 1
        aj%dxn = aj%gradnb * aj%gfac ! In case the caller wants to compute cosines
d842 11
a852 2
          call do_NF_NewX ( .true. )
          return
a853 8
        aj%axmax = aj%axmaxb
        aj%gfac = 0.125 * aj%gfac
        aj%spl = aj%spg
        aj%spg = 8.0 * aj%spl
        aj%fnxe = 0.5 * aj%fnorm**2
        aj%frz = aj%frzb
        aj%gradn = aj%gradnb
        call do_NF_NewX
d855 1
a855 1
      case ( nf_best )               ! Resumed after saving X as best X
d857 2
a858 2
        ! Re-enter here after saving X as "best X" and Gradient as
        ! "Best gradient"
d861 2
a862 2
        dxnois = max(dxnois,1.0E-4_rk*aj%dxnl)
        aj%gfac = min(0.125*aj%dxn/aj%gradn,aj%ajn**(-2))
d868 2
a869 3
        if ( abs(aj%cdxdxl) < 0.9_rk .or. aj%sq /= 0.0 .or. &
           & aj%dxn >= aj%dxnl ) then
          call do_NF_DX
d874 2
a875 2
          nflag = nf_aitken
          aj%where_to = nflag
d878 4
a881 3
      case ( nf_aitken )             ! Resumed after computing some numbers
                                     ! needed for (modified) Aitken
                                     ! acceleration
d883 1
a883 1
        tp = aj%dxdx     ! | dX | **2
d885 13
a897 13
          tp = 1.0 + aj%dxdxl/tp
          tp = min(10.0_rk,max(tp,0.01_rk))
          if ( abs(aj%cait-tp) < abs(0.25_rk*(aj%cait+tp)-0.5_rk) ) then
          ! Set DX = Aitken-modified DX = AJ%CAIT * "Candidate DX"
            aj%cait = tp
            itken = iter + 2
            aj%sq = -aj%cait
            aj%dxn = aj%cait*aj%dxn
            nflag = nf_dx_aitken
            aj%where_to = nflag
            return
          end if
          if ( itken < iter ) aj%cait = tp
a898 1
        call do_NF_DX
d902 6
a907 2
      case ( nf_dx, nf_dx_aitken )   ! Resumed after DX = "Candidate DX" or
                                     ! DX = AJ%CAIT * "Candidate DX"
d910 4
a913 1
        call do_NF_NewX
d915 9
a923 11
      ! Continuing after return that was expected to be final:
      case ( nf_tolx, nf_tolx_best ) ! Converged because distance from C to
                                     ! solution was estimated to be small and
                                     ! DX is small
        call do_nf_best
      case ( nf_tolf )               ! Converged because |F| is small
        call do_NF_Solve ( before_Solve = test_f_linear )
      case ( nf_too_small )          ! Converged because DX was too small
        call do_NF_GMove
      case ( nf_fandj )              ! F and J appeared not to be consistent
        call Do_NF_GMove_Small
d939 1
a939 1
    end subroutine Do_NF_Best
d989 3
a991 3
      kb = -1 ! Set consecutive gradient move counter
      aj%dxbad = 0.75_rk*min(aj%dxn,aj%dxbad)
      aj%dxfail = 0.125_rk*aj%dxbad
d1002 2
a1003 2
      kb = kb - 1
      if ( kb <= -4 ) then   ! Four consecutive gradient moves !
d1007 1
a1007 1
        kb = 0
d1019 2
a1020 2
      kb = -1 ! Restart consecutive gradient move counter
      aj%gfac = -0.01 * aj%gfac
d1024 12
d1037 1
a1037 2
    subroutine Do_NF_NewX ( Gfac_Negative )
      logical, intent(in), optional :: Gfac_Negative ! Present means true
d1041 3
a1043 8
      if ( .not. present(gfac_negative) ) then
        aj%fnorml = aj%fnorm
        aj%frzl = aj%frz
        aj%fnxe = 0.25_rk*aj%fnorm**2 + 0.76_rk*aj%fnxe
      end if
      if ( k1it /= 0 ) then ! Do requested debugging output
        k1it = k1it - 1
        call nwtdb ( width=9, level=0, why='Before new X' )
d1046 1
a1046 1
      aj%starting = inc < 0
d1061 1
a1061 1
        tp = min((aj%frz/aj%frzl),(aj%fnorm/aj%fnorml))
d1068 1
a1068 1
          aj%dxi = min(aj%dxi,0.25_rk)
d1073 2
a1074 2
          aj%spfac = min( tp*(aj%fnorm**2)/aj%fnxe, &
                        & 32.0 * (1.025 - aj%cdxdxl)**2 )
d1080 1
a1080 1
        aj%sp = max(aj%spinc, min(aj%spb, aj%spl * aj%spfac))
d1083 2
a1084 2
        aj%sp = max(aj%sp,aj%sqmin / aj%ajn)
    !   if ( inc == 0 ) aj%sp = min(aj%sp, 0.5 * aj%spl)
d1088 2
a1089 1
        if ( aj%sp < aj%spact .and. inc >= 0 ) aj%sq = aj%sqmin
d1094 1
a1094 1
      aj%starting = inc<0
d1112 1
a1112 1
    ! Test for convergence in sense of AJ%FNORM < (1 + RELSF)*AJ%FNMIN
d1115 2
a1116 2
      if ( inc==0 ) then
        tp = aj%fnorm - (1.0+relsf)*aj%fnmin
d1120 2
a1121 2
!           if ( (aj%sq <= aj%sqmin) .or. (aj%spl <= spmini) .or. &
!            &   (tp <= -(1.0+relsf)*aj%spl*aj%fnorm) ) then
a1130 1

a1131 1

d1133 8
a1140 9
      if ( aj%fnorml > 0.0 ) then
      ! Didn't just do four gradient moves from the best X
        if ( aj%dxn <= tolxa .or. &
           & ( (aj%sq == 0.0) .or. (aj%spl <= spmini) ) .and. &
           &   aj%dxn <= tolxr*aj%axmax ) then
        ! Convergence if aj%dxn is small enough or we have a suffiently small
        ! Levenberg-Marquardt parameter and we had a very small move.
          nflag = nf_tolx
          if ( kb /= 0 ) then  ! Made gradient move, or F increased
d1142 1
a1142 1
            nflag = nf_tolx_best ! Solution is at best X, not current X
d1144 1
a1144 1
          aj%where_to = nflag
a1147 1

a1151 89
! *************************************************     DNWTOP     *****
  subroutine DNWTOP ( AJ, NOPT, XOPT )
    ! Process option vector for DNWT.  With no arguments, does default
    ! initialization.
    type(nwt_t), intent(inout) :: AJ
    integer, intent(in), optional :: NOPT(*)
    real(rk), intent(in), optional :: XOPT(*)

    logical, save :: FIRST = .true.
    integer I, INDIC, K, KA, NACT
    integer, save :: IOPTS(8) = (/ 0, 0, 0, 0, 0, 0, 0, 150 /)
    character(len=4), parameter :: LABL(2) = (/ '(I) ', 'NOPT' /)
    ! ??? Defaults aren't what comments say
    real(rk),save :: VALUES(9) = (/ 0.1_rk, epsilon(values), epsilon(values), &
                                  & 0.1*huge(values), 0.01_rk, 0.0_rk, 0.0_rk, &
                                  & 0.0_rk, 0.0_rk /)
    real(rk),save :: VALNOM(9) = (/ 0.1_rk, epsilon(values), epsilon(values), &
                                  & 0.1*huge(values), 0.01_rk, 0.0_rk, 0.0_rk, &
                                  & 0.0_rk, 0.0_rk /)
    integer :: IVAL(2) ! for error messages

!*************** Start of executable code ******************

    if ( first ) then
      valnom(7) = sqrt(sqrt(tiny(values)))**3
      valnom(8) = sqrt(sqrt(epsilon(values)))**3
      values(7:8) = valnom(7:8)
      first = .false.
    end if
    if ( present(nopt) ) then
      if ( .not.present(xopt) ) then
        call ermsg ( me, 99, 2, 'NOPT present but XOPT absent', '.' )
        return
      end if
      i = 1
      do while ( nopt(i) /= 0 )
        k = nopt(i)
        ka = abs(k)
        select case (ka)
!****************** Change *DATA* values *******************
        case ( 1, 2 )      ! Set K1IT
          if ( k > 0 ) iopts(ka) = nopt(i+1)
          k1it = max(iopts(1),iopts(2))
        case ( 3, 4, 7, 8) ! Change XSCAL and FSCAL indices in data
                           ! or set up bounds option in data
          if ( k > 0 ) iopts(ka) = nopt(i+1)
        case ( 5, 6 )      ! Set flags in data for reverse communi-
                           ! cation and special matrix operations
          if ( k > 0 ) iopts(ka) = 1
          i = i - 1
        case ( 9, 10 )     ! Set to default values
          iopts = 0
          iopts(8) = 150
          values = valnom
          i = i - 1
        case ( 11: 19 )    ! Set in data SPSTRT, SPMINI, AJSCAL,
                           ! DXMAXI, RELSF, and DXNOIS
          values(ka-10) = valnom(ka-10) ! Reset to nominal value
          if ( k > 0 ) & ! If indicated, set to user input value
          values(ka-10) = xopt(nopt(i+1))
        case default
          indic = 1
          nact = 2
          call ermsg ( me, indic, nact, 'INVALID NOPT', ',' )
          ival(1) = i
          ival(2) = nopt(i)
          call ervn ( labl, ival, '.' )
          return
        end select
        i = i + 2
      end do
    else
      k1it = max(iopts(1),iopts(2))
      aj%where_to = nf_start
    end if
!                     Reset every time one of them changes
    spmini = values(2)
    ajscal = values(3)
    dxmaxi = values(4)
    relsf = max(values(5),epsilon(relsf))
    tolxa = values(7)
    tolxr = values(8)
    if ( present(nopt) ) return
!                     Only set during initialization
    spstrt = values(1)
    dxnois = values(6)
    return
  end subroutine DNWTOP

d1154 1
a1154 1
  subroutine DNWTDB ( AJ, WIDTH, LEVEL, WHY )
d1161 1
a1161 1
    type (NWT_T), intent(in), optional :: AJ
a1162 5
    integer, intent(in), optional :: LEVEL ! Absent, do everything
    ! Present and 1 (default) do everything
    ! Present and 0 don't do internal variables,
    ! and if AJ is present skip AXMAX, AXMAXB, CAIT, DXI, DXNL, FNMINB,
    !   FNORMB, FNORML, FRZB, FRZL, GRADNB, GRADNL, from AJ
a1164 7
!   namelist /DNWTDB_OUT/ AJSCAL
!   namelist /DNWTDB_OUT/ DXMAXI, DXNOIS
!   namelist /DNWTDB_OUT/ INC, ITER, ITKEN
!   namelist /DNWTDB_OUT/ K1IT, KB
!   namelist /DNWTDB_OUT/ RELSF, SPMINI
!   namelist /DNWTDB_OUT/ SPSTRT

d1166 2
a1167 2
    character(len=9) :: Where_To_Name
    integer :: MyLevel, MyWidth
d1171 3
a1173 4
!     Some processors don't accept this yet.
!     interface Add_To_Line
!       procedure Add_To_Line_I, Add_To_Line_L, Add_To_Line_R
!     end interface
a1174 2
    myLevel = 1
    if ( present(level) ) myLevel = level
a1176 1
    if ( myLevel == 0 ) myWidth = min(8,myWidth)
d1178 2
a1179 2
    output_line = '-----     DNWT internal variables     ----------------------&
    &------------------------------------------------------------------'
d1182 1
a1182 1
    call flagName ( aj%where_to, where_to_name )
d1184 2
a1185 2
    call output (  &
      & '  WHERE_TO        INC    ITER   ITKEN    K1IT      KB' )
d1188 2
a1189 2
    write ( output_line, '(1x,a9,i11,4i8,1x,a9)' ) adjustr(where_to_name), INC, &
         & ITER, ITKEN, K1IT, KB
d1191 1
a1191 1
    if ( present(why) ) call output ( '  '//trim(why) )
d1197 14
a1210 15
    if ( myLevel > 0 ) call add_to_line_R ( ajscal, 'AJSCAL' )
    if ( myLevel > 0 ) call add_to_line_R ( dxmaxi, 'DXMAXI' )
    if ( myLevel > 0 ) call add_to_line_R ( dxnois, 'DXNOIS' )
    if ( myLevel > 0 ) call add_to_line_R ( relsf,  'RELSF' )
    if ( myLevel > 0 ) call add_to_line_R ( spmini, 'SPMINI' )
    if ( myLevel > 0 ) call add_to_line_R ( spstrt, 'SPSTRT' )
    if ( myLevel > 0 ) call add_to_line_R ( tolxa,  'TOLXA' )
    if ( myLevel > 0 ) call add_to_line_R ( tolxr,  'TOLXR' )
    if ( i/=1 ) call print_lines

    if ( present(aj) ) then
      output_line = '-----     DNWT external variables     ----------------------&
        &------------------------------------------------------------------'
      call output ( output_line(1:14*myWidth), advance='yes' )
      output_line = ''
d1212 49
a1260 48
      call add_to_line_R ( aj%ajn,        'AJN' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%axmax,      'AXMAX' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%axmaxb,     'AXMAXB' )
      if ( myLevel > 0 ) call add_to_line_L ( aj%big,        'BIG' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%cait,       'CAIT' )
      call add_to_line_R ( aj%cdxdxl,     'CDXDXL' )
      call add_to_line_R ( aj%cgdx,       'CGDX' )
      call add_to_line_R ( aj%condai,     'CONDAI' )
      call add_to_line_R ( aj%diag,       'DIAG' )
      call add_to_line_R ( aj%dxbad,      'DXBAD' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%dxi,        'DXI' )
      call add_to_line_R ( aj%dxinc,      'DXINC' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%dxnbig,     'DXNBIG' )
      call add_to_line_R ( aj%dxfail,     'DXFAIL' )
      call add_to_line_R ( aj%dxdx,       'DXDX' )
      call add_to_line_R ( aj%dxdxl,      'DXDXL' )
      call add_to_line_R ( aj%dxn,        'DXN' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%dxnl,       'DXNL' )
      call add_to_line_R ( aj%fnmin,      'FNMIN' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%fnminb,     'FNMINB' )
      call add_to_line_R ( aj%fnorm,      'FNORM' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%fnormb,     'FNORMB' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%fnorml,     'FNORML' )
      call add_to_line_R ( sqrt(aj%fnxe), 'FNXE**.5')
      call add_to_line_R ( aj%frz,        'FRZ' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%frzb,       'FRZB' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%frzl,       'FRZL' )
      call add_to_line_R ( aj%gdx,        'GDX' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%gfac,       'GFAC' )
      call add_to_line_R ( aj%gradn,      'GRADN' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%gradnb,     'GRADNB' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%gradnl,     'GRADNL' )
      call add_to_line_I ( aj%kfail,      'KFAIL' )
      call add_to_line_R ( aj%qnsq,       'QNSQ' )
      call add_to_line_R ( aj%sp,         'SP ' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%spact,      'SPACT' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%spb,        'SPB' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%spfac,      'SPFAC' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%spg,        'SPG' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%spinc,      'SPINC' )
      call add_to_line_R ( aj%spl,        'SPL' )
      call add_to_line_R ( aj%sq,         'SQ' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%sqb,        'SQB' )
      if ( myLevel > 0 ) call add_to_line_R ( aj%sql,        'SQL' )
      call add_to_line_R ( aj%sqmin,      'SQMIN' )
      call add_to_line_R ( aj%sqt,        'SQT' )
      call add_to_line_L ( aj%starting,   'STARTING' )
      if ( i /=1 ) call print_lines
a1261 1
    end if
d1267 9
a1275 1

d1280 1
a1280 2
      name_line(1+14*(i-1):10+14*(i-1)) &
        & = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
d1289 1
a1289 2
      name_line(1+14*(i-1):10+14*(i-1)) &
        & = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
d1291 1
a1291 2
      output_line(1+14*(i-1):10+14*(i-1)) &
        & = adjustr(output_line(1+14*(i-1):10+14*(i-1)))
a1294 10
    subroutine Add_To_Line_R ( Value, Name )
      real(rk), intent(in) :: Value
      character(len=*), intent(in) :: Name
      name_line(1+14*(i-1):10+14*(i-1)) = name
      name_line(1+14*(i-1):10+14*(i-1)) &
        & = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
      write ( output_line(1+14*(i-1):14*i), '(es14.7)' ) value
      i = i + 1
      if ( i > myWidth ) call print_lines
    end subroutine Add_To_Line_R
d1296 2
a1297 2
      call output(trim(name_line),advance='yes')
      call output(trim(output_line),advance='yes')
a1303 21
! **********************************************     DNWT_GUTS     *****

  subroutine DNWT_GUTS ( GUTS )
  ! Get the private saved variables of DNWT, for debugging purposes
    type(NWT_GUTS), intent(out) :: GUTS

    guts%ajscal = ajscal
    guts%dxmaxi = dxmaxi
    guts%dxnois = dxnois
    guts%inc = inc
    guts%iter = iter
    guts%itken = itken
    guts%k1it = k1it
    guts%kb = kb
    guts%relsf = relsf
    guts%spmini = spmini
    guts%spstrt = spstrt
    guts%tolxa = tolxa
    guts%tolxr = tolxr
  end subroutine DNWT_GUTS

d1310 2
a1311 2
    select case (nflag)
    case (NF_EVALF)
d1313 1
a1313 1
    case (NF_EVALJ)
d1315 1
a1315 1
    case (NF_LEV)
d1317 1
a1317 1
    case (NF_SOLVE)
d1319 1
a1319 1
    case (NF_NEWX)
d1321 1
a1321 1
    case (NF_GMOVE)
d1323 1
a1323 1
    case (NF_BEST)
d1325 1
a1325 1
    case (NF_AITKEN)
d1327 1
a1327 1
    case (NF_DX)
d1329 1
a1329 1
    case (NF_DX_AITKEN)
d1331 1
a1331 1
    case (NF_START)
d1333 1
a1333 1
    case (NF_TOLX)
d1335 1
a1335 1
    case (NF_TOLX_BEST)
d1337 1
a1337 1
    case (NF_TOLF)
d1339 1
a1339 1
    case (NF_TOO_SMALL)
d1341 1
a1341 1
    case (NF_FANDJ)
d1346 1
a1346 1
  end subroutine FLAGNAME
d1350 4
a1353 4
    character (len=*), parameter :: IdParm = &
       "$Id: dnwt_module.f90,v 2.56 2018/07/23 23:29:56 vsnyder Exp $"
    character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1)==ModuleName(1:1))
d1355 1
a1355 1
  end function NOT_USED_HERE
d1358 1
a1358 1
end module DNWT_Module
a1360 4
! Revision 2.56  2018/07/23 23:29:56  vsnyder
! Remove ChiSqMinNorm and ChiSqNorm from DNWT AJ structure because DNWT
! doesn't compute them or use them.
!
@


2.56
log
@Remove ChiSqMinNorm and ChiSqNorm from DNWT AJ structure because DNWT
doesn't compute them or use them.
@
text
@d341 1
a341 1
       "$RCSfile: DNWT_Module.f90,v $"
d1298 4
a1301 3
    interface Add_To_Line
      procedure Add_To_Line_I, Add_To_Line_L, Add_To_Line_R
    end interface
d1328 8
a1335 8
    if ( myLevel > 0 ) call add_to_line ( ajscal, 'AJSCAL' )
    if ( myLevel > 0 ) call add_to_line ( dxmaxi, 'DXMAXI' )
    if ( myLevel > 0 ) call add_to_line ( dxnois, 'DXNOIS' )
    if ( myLevel > 0 ) call add_to_line ( relsf,  'RELSF' )
    if ( myLevel > 0 ) call add_to_line ( spmini, 'SPMINI' )
    if ( myLevel > 0 ) call add_to_line ( spstrt, 'SPSTRT' )
    if ( myLevel > 0 ) call add_to_line ( tolxa,  'TOLXA' )
    if ( myLevel > 0 ) call add_to_line ( tolxr,  'TOLXR' )
d1344 47
a1390 48
      call add_to_line ( aj%ajn,        'AJN' )
      if ( myLevel > 0 ) call add_to_line ( aj%axmax,      'AXMAX' )
      if ( myLevel > 0 ) call add_to_line ( aj%axmaxb,     'AXMAXB' )
      if ( myLevel > 0 ) call add_to_line ( aj%cait,       'CAIT' )
      call add_to_line ( aj%cdxdxl,     'CDXDXL' )
      call add_to_line ( aj%cgdx,       'CGDX' )
      call add_to_line ( aj%condai,     'CONDAI' )
      call add_to_line ( aj%diag,       'DIAG' )
      call add_to_line ( aj%dxbad,      'DXBAD' )
      if ( myLevel > 0 ) call add_to_line ( aj%dxi,        'DXI' )
      call add_to_line ( aj%dxinc,      'DXINC' )
      if ( myLevel > 0 ) call add_to_line ( aj%dxnbig,     'DXNBIG' )
      call add_to_line ( aj%dxfail,     'DXFAIL' )
      call add_to_line ( aj%dxdx,       'DXDX' )
      call add_to_line ( aj%dxdxl,      'DXDXL' )
      call add_to_line ( aj%dxn,        'DXN' )
      if ( myLevel > 0 ) call add_to_line ( aj%dxnl,       'DXNL' )
      call add_to_line ( aj%fnmin,      'FNMIN' )
      if ( myLevel > 0 ) call add_to_line ( aj%fnminb,     'FNMINB' )
      call add_to_line ( aj%fnorm,      'FNORM' )
      if ( myLevel > 0 ) call add_to_line ( aj%fnormb,     'FNORMB' )
      if ( myLevel > 0 ) call add_to_line ( aj%fnorml,     'FNORML' )
      call add_to_line ( sqrt(aj%fnxe), 'FNXE**.5')
      call add_to_line ( aj%frz,        'FRZ' )
      if ( myLevel > 0 ) call add_to_line ( aj%frzb,       'FRZB' )
      if ( myLevel > 0 ) call add_to_line ( aj%frzl,       'FRZL' )
      call add_to_line ( aj%gdx,        'GDX' )
      if ( myLevel > 0 ) call add_to_line ( aj%gfac,       'GFAC' )
      call add_to_line ( aj%gradn,      'GRADN' )
      if ( myLevel > 0 ) call add_to_line ( aj%gradnb,     'GRADNB' )
      if ( myLevel > 0 ) call add_to_line ( aj%gradnl,     'GRADNL' )
      call add_to_line ( aj%kfail,      'KFAIL' )
      call add_to_line ( aj%qnsq,       'QNSQ' )
      call add_to_line ( aj%sp,         'SP ' )
      if ( myLevel > 0 ) call add_to_line ( aj%spact,      'SPACT' )
      if ( myLevel > 0 ) call add_to_line ( aj%spb,        'SPB' )
      if ( myLevel > 0 ) call add_to_line ( aj%spfac,      'SPFAC' )
      if ( myLevel > 0 ) call add_to_line ( aj%spg,        'SPG' )
      if ( myLevel > 0 ) call add_to_line ( aj%spinc,      'SPINC' )
      call add_to_line ( aj%spl,        'SPL' )
      call add_to_line ( aj%sq,         'SQ' )
      if ( myLevel > 0 ) call add_to_line ( aj%sqb,        'SQB' )
      if ( myLevel > 0 ) call add_to_line ( aj%sql,        'SQL' )
      call add_to_line ( aj%sqmin,      'SQMIN' )
      call add_to_line ( aj%sqt,        'SQT' )
      call add_to_line ( aj%kfail,      'KFAIL' )
      call add_to_line ( aj%big,        'BIG' )
      call add_to_line ( aj%starting,   'STARTING' )
d1399 1
d1509 1
a1509 1
       "$Id: dnwt_module.f90,v 2.53 2015/05/15 23:41:01 vsnyder Exp $"
d1519 4
@


2.55
log
@Correct the comment about initial call to include AJ
@
text
@d1 1
d13 1
a13 1
module DNWT_MODULE
d15 2
a16 1
!>> 2000-03-21 DNWT_MODULE W. V. Snyder Converted to Fortran 90
d26 2
a27 2
! These subroutines solve f(x)=0 (or find the least square solution)
! where f is a vector with NF components, and x is a vector with NX
d41 1
a41 1
! **  CALL NWT ( NFLAG, AJ, XOPT, NOPT)          **
d56 1
a56 1
!         Compute f(x)
d58 1
a58 1
!         Set AJ%FNORM = L2 norm of f(x)
d65 1
a65 1
!         Triangularize J, and compute (negative of the) gradient =
d68 1
d74 5
a78 5
!           AJ%FNMIN = L2 norm of residual, ||F + J * "Candidate DX"||
!                   (which can be gotten without solving for
!                   "Candidate DX": if -F is put as the last column of
!                   J before triangularization, either by Householder
!                   or by Cholesky factoring the normal equations,
d84 2
a85 1
!         factor of J^T J, compute |q|**2 and store it in AJ%QNSQ.
d102 1
d124 3
a126 2
!         IF ( you have confidence in F and J ) CYCLE
!         STOP
d131 3
a133 3
  use ERMSG_M, only: ERMSG, ERVN
  use DNWT_TYPE, only: RK
  use OUTPUT_M, only: OUTPUT
d139 1
a139 1
  public :: NWT, NWTA, NWTDB, NWTOP, NWT_GUTS, NWT_T
a141 37
  type NWT_T               ! Stuff about the problem, neatly packaged.  This
                           ! is the type of the AJ argument of NWTA.  Unless
                           ! otherwise noted, components are inputs to ?NWTA.
                           ! See usage instructions above.
    real(rk) :: AJN        ! Largest L1 norm of column in upper triangle
                           ! of factored Jacobian matrix
    real(rk) :: AXMAX      ! MAXVAL(ABS(X))
    real(rk) :: CAIT = 0.0 ! Aitken parameter -- intent(out)
    real(rk) :: CHISQMINNORM ! FNMIN^2 / no degrees of freedom
    real(rk) :: CHISQNORM  ! FNORM^2 / no degrees of freedom
    real(rk) :: DIAG       ! Smallest | diagonal element | after factoring
    real(rk) :: DXBAD      ! This size for DX is likely a disaster (Temporary)
    real(rk) :: DXDX       ! dot_product( DX, DX )
    real(rk) :: DXDXL      ! dot_product( "candidate DX", DX )
    real(rk) :: DXFAIL     ! Like DXINC, but more so.  (Temporary)
    real(rk) :: DXN        ! L2 Norm of candidate DX
    real(rk) :: DXNL = 0.0 ! L2 Norm of last candidate DX -- intent(out)
    real(rk) :: FNMIN      ! L2 Norm of F not in column space of the Jacobian
    real(rk) :: FNORM      ! L2 Norm of F at current X
    real(rk) :: FNORMB     ! L2 Norm of F at best X
    real(rk) :: GDX        ! dot_product( Gradient, "Candidate DX" )
    real(rk) :: GFAC       ! Amount of best gradient to use for DX
    real(rk) :: GRADN      ! L2 norm of Gradient
    real(rk) :: GRADNB     ! L2 norm of Gradient at best F
    real(rk) :: QNSQ       ! Square of norm of solution of U^T q = x
    real(rk) :: SQ = 0.0   ! Levenberg-Marquardt parameter -- intent(out)
    real(rk) :: SQMIN = 0.0 ! Value of SQ above which function tolerance is
                           ! not allowed -- intent(in); recommen to use this
                           ! as a floor for Levenberg-Marquardt stabilization
                           ! in the caller
    real(rk) :: SQT        ! Total Levenberg-Marquardt stabilization -- intent(out)
    integer :: KFAIL       ! Failure count: 0 nofailures; k > 0 we have successfully
                           ! taken k - 1 steps of size DXBAD. (Temporary)
    logical :: BIG         ! ANY( DX > 10.0 * epsilon(X) * X )
    logical :: STARTING = .true. ! NWTA is still in "starting up" phase -- intent(out)
  end type NWT_T

d147 1
a147 1
  integer, parameter, public :: NF_EVALF = -1
d172 1
d175 1
a175 1
  integer, parameter, public :: NF_TOLX = 1
d185 2
d188 1
a188 1
  integer, parameter, public :: NF_BIGGEST_FLAG = NF_FANDJ
d191 119
a309 4
  interface NWT; module procedure DNWT; end interface
  interface NWTA; module procedure DNWTA; end interface
  interface NWTDB; module procedure DNWTDB; end interface
  interface NWTOP; module procedure DNWTOP; end interface
d314 7
a320 9
  real(rk) :: AJN, AJSCAL, AXMAX, AXMAXB, CAIT, CDXDXL, CGDX, CONDAI
  real(rk) :: DIAG, DXI, DXINC, DXMAXI, DXN, DXNBIG, DXNL, DXNOIS
  real(rk) :: FN, FNB, FNL, FNMIN, FNMINB, FNXE, FRZ, FRZB
  real(rk) :: FRZL, GFAC, GRADN, GRADNB, GRADNL
  integer :: IFL, INC, ITER, ITKEN
  integer :: K1IT, KB
  integer :: NFL
  real(rk) :: RELSF, SP, SPACT, SPB, SPFAC, SPG, SPINC, SPL, SPMINI
  real(rk) :: SPSTRT, SQ, SQB, SQL, SQMIN
d322 4
d328 3
a330 5
    real(rk) :: AJN, AJSCAL, AXMAX, AXMAXB, CAIT, CDXDXL, CGDX, CONDAI
    real(rk) :: DIAG, DXI, DXINC, DXMAXI, DXN, DXNBIG, DXNL, DXNOIS
    real(rk) :: FN, FNB, FNL, FNMIN, FNMINB, FNXE, FRZ, FRZB
    real(rk) :: FRZL, GFAC, GRADN, GRADNB, GRADNL
    integer :: IFL, INC, ITER, ITKEN
d332 2
a333 3
    integer :: NFL
    real(rk) :: RELSF, SP, SPACT, SPB, SPFAC, SPG, SPINC, SPL, SPMINI
    real(rk) :: SPSTRT, SQ, SQB, SQL, SQMIN
d341 2
a342 2
       "$RCSfile: dnwt_module.f90,v $"
  private :: not_used_here 
d357 1
d359 1
a359 1
! Variables in the calling sequence are of the following type
d366 1
a366 1
! The above parameters are used as follows:
d412 1
a412 1
!           with NFLAG = NF_TOLF if FN - FNMIN < RELSF * FNMIN .
d416 1
a416 1
!           The initial default is 0, but DXNOIS if updated later.
d420 1
a420 1
!           estimated to be .le. TOLXA.  The default value is
d425 1
a425 1
!           estimated to be .le. TOLXR * max (abs(X(i))).  The default
d438 2
a439 2
    ifl = nf_start
    nflag = ifl
d442 1
a442 1
    return
d449 1
a449 1
! **************************************************************
d452 1
a452 1
! Variables in the calling sequence are defined below.
d454 1
a454 1
    integer, intent(inout) :: NFLAG
a460 1
! AJN      Norm of the Jacobian
a461 2
! AXMAX    MAXVAL(ABS(X))
! AXMAXB   AXMAX at best X.
a462 7
! C0       Constant 0
! C1       Constant 1
! C10      Constant 10
! C100     Constant 100
! C1PXM4   Constant 1.E-4
! C4       Constant 4
! CAIT     Candidate factor for Aitken acceleration
d464 1
a464 13
! CDXDXL   COS of angle between DX and DXL ! ??? DX and DXL aren't defined
! CGDX     COS of angle between gradient and DX
! CONDAI   Crude estimate of reciprocal of condition number of the Jacobian
! CP01     constant .01
! CP125    constant .125
! CP25     constant .25
! CP5      constant .5
! CP76     constant .76
! CP9      constant .9

! DIAG     Minimum diagonal element of triangularized Jacobian
! DXI      Largest factor by which stepsize is allowed to increase
! DXINC    Largest value for DXN currently allowed
d466 2
a467 26
! DXN      Norm of current DX (=stepsize)
! DXNBIG   A move of size that should be safe.
! DXNL     Last value of DXN
! DXNOIS   C1PXM4 * largest move that gives a new best X (used to
!          see if increase in FN might be due to too small a step)

! ERMSG    Error message routine

! FN       Norm of F at X from which next step is being taken
! FNB      Value of FN at best X (smallest FN obtained up to this point)
! FNL      Last value of FN
! FNMIN    Norm of component of F orthogonal to the column space of
!          the Jacobian after stabilization
! FNMINB   FNMIN at best X, not best FNMIN
! FNXE     Used to test if F is behaving with near linearity. If
!          FNORM on the next iteration satisfies FNORM**2 <= FNXE
!          then linear behavior is assumed.
! FRZ      Norm of projection of F into the column space of the Jacobian
! FRZB     FRZ at best X
! FRZL     Last value of FRZ

! GFAC     Factor by which the gradient is multiplied when taking a
!          move from the best X
! GRADN    Norm of the gradient
! GRADNB   Value of GRADN at the best X
! GRADNL   Last value of GRADN
a468 2
! IFL      Internal flag (NFLAG is usually set same as IFL)
!          See NF_... parameters above that have negative values.
d472 1
a472 1
!          =J>0 FN > FNL  J times since last best X
d486 2
a487 6
! NFL      Internal flag to indicate reason for returning to user.
!          See positive values of NF_... parameters above.
! NFLAG    Set same as NFL or same as IFL.

! RELSF    Convergence is indicated with NFLAG=NF_TOLF if
!          FN-FNMIN < RELSF*FNMIN
a490 12
! SP       Value of current normalized Marquardt parameter
! SPACT    If SP<SPACT, SQ is set = SQMIN
! SPB      Normalized Marquardt parameter used to get best X
! SPFAC    Factor multiplying last normalized Marquardt parameter
!          to get one estimate to use for current normalized
!          Marquardt parameter
! SPG      Used to initialize SPL after taking a move from best X
!          after a previous failure
! SPINC    Lower bound permitted for normalized Marquardt parameter
!          based on past behavior
! SPL      Used to store normalized Marquardt parameter from last
!          iteration and also the current one
a492 6
! SQ       Actual value of Marquardt parameter. If SQ < 0, modified
!          Aitken acceleration is being used and ABS(SQ) gives the
!          acceleration factor
! SQB      Value of SQL from last best X
! SQL      CP9*AJN*SQL (frequently = CP9* last Marquardt parameter)
! SQMIN    Current minimum value of SQ
d498 1
a498 1
!-----     Local Variables     ------------------------------------
a499 13
    real(rk), parameter :: C0 = 0.0_rk
    real(rk), parameter :: C1 = 1.0_rk
    real(rk), parameter :: C10 = 10.0_rk
    real(rk), parameter :: C100 = 100.0_rk
    real(rk), parameter :: C1PXM4 = 1.0E-4_rk
    real(rk), parameter :: C4 = 4.0_rk
    real(rk), parameter :: CBIG = huge(1.0_rk)
    real(rk), parameter :: CP01 = 0.01_rk
    real(rk), parameter :: CP125 = 0.125_rk
    real(rk), parameter :: CP25 = 0.25_rk
    real(rk), parameter :: CP5 = 0.5_rk
    real(rk), parameter :: CP76 = 0.76_rk
    real(rk), parameter :: CP9 = 0.9_rk
d502 1
a502 1
    real(rk) :: TP
d504 1
a504 1
    real(rk), parameter :: RND = 10.0_rk * epsilon(c0)
d506 36
a541 1
!-----     Executable Statements     ------------------------------
d543 1
a543 50
! Continuing after return that was expected to be final:
      if ( nflag > 0 ) &
!                nf_tolx nf_tolx_best nf_tolf nf_too_small nf_fandj
        & go to (735,    735,         470,    230,         228), nfl

! Continuing after return for reverse communication:
      if ( nflag < 0 ) &
!                nf_evalf nf_evalj nf_lev nf_solve nf_newx nf_gmove nf_best
        & go to (160,     260,     600,   540,     850,    240,     740, &
!                nf_aitken nf_dx nf_dx_aitken
        &        750,      770,  770), -ifl

! Initialization
   10 if ( ifl /= nf_start ) go to 222 ! User forcing retreat to best X
      ajn = c0
      condai = c0
      dxnl = c1
      aj%dxnl = c1
      fnb = sqrt(huge(fnb))
      aj%dxfail = huge(aj%dxfail)
      aj%dxbad = aj%dxfail
      aj%kfail = 0
      fnl = c0
      inc = -1 ! Starting
!     inc = 0  ! Pretend we're at a "best"
      iter = 0
      itken = 0
      kb = 2
      spl = c0
      sq = c0
      axmax = aj%axmax
      aj%dxdxl = c0 ! So it's not undefined, because the user isn't expected
      ! to set it when starting.
   20 ifl = nf_evalf
      nflag = ifl
      return

! Re-enter after evaluating F.

  160 iter = iter + 1
      fn = aj%fnorm

! Test if a retreat to a previous -- best -- X should be made

      tp = spl*ajn*cp9 ! .9 time sql on previous iteration
      if ( fn < fnl ) then ! Things are getting better
        if ( fn >= fnb ) then ! But no better than the best x
! If our Marquardt parameter is small and fn does not appear to be
! getting close to smaller than fnb, and we are not making a move
! in a quite different direction we give up and go back to previous best.
d545 10
a554 4
          if ( (max(tp, sql) <= aj%sqmin) .and. &
               ((fn*(fn/fnl)**2) > fnb) .and. (cdxdxl >= cp25) ) go to 222
        end if
      else ! ( fn >= fnl )
d556 1
a556 2
! FNL will have been set to zero if there are four consecutive gradient moves
! Test for X convergence
d558 27
a584 15
        if ( x_converge() ) return
        if ( inc >= 0 ) then ! We are not starting
          if ( inc == 0 ) then ! Last X == Best X
            dxnbig = max(dxnl, dxnois)

          else      ! inc > 0 -- Not starting, Last X not Best X
            if ( kb == 0 ) then
              if ( fn < fnb ) then
                gfac = -gfac
                if ( gfac >=  0 ) then
                  ! Error processing
                  call ermsg ( me, 2, 0, 'J or F may be in error', '.' )
                  nfl = nf_fandj
                  nflag = nfl
                  return
d586 17
a603 1
              go to 228
d605 16
a620 5
            if ( dxnl <= dxnois ) go to 219 ! Last Newton move tiny?
            if ( kb < 0 ) go to 224 ! Gradient move last time?
! WVS revised this 2012-08-27 based upon advice from FTK
!           if ( (tp >= min(sql,sqb+sqb)) .or. (inc >= incbig) ) go to 222
            if ( fnmin > (c1+0.5*relsf)*fnminb .or. inc >= incbig ) go to 222
a621 3
          sqmin = min(sqb, max(spl, spact)*ajn*c4)
          dxinc = max(dxnl*cp5, dxnois)
          inc = inc + 1
a622 1
      end if
d624 1
a624 17
  219 sql = tp
      ifl = nf_evalj
      nflag = ifl
      return

! Retreat to a previous -- best -- X and step in gradient direction.  An
! alternative is to use the gradients at the best X and the current X to
! compute the directional derivatives along the line from the best X to the
! current X, fit a cubic polynomial to F using Hermite interpolation, and
! go to the minimum of that polynomial if it's less than the best F.

  222 kb = -1
      aj%dxbad = 0.75_rk * min(aj%dxn, aj%dxbad)
      aj%dxfail = 0.125_rk * aj%dxbad
      aj%kfail = 1
  224 kb = kb - 1
      if ( kb <= (-4) ) then ! Four consecutive gradient moves !
d626 1
a626 1
! Setup to test if Jacobian matrix is being computed properly
d628 1
a628 50
        kb = 0
        fnl = c0
        gfac = -gfac*c100
      end if
      go to 230
  228 gfac = -gfac*cp01
      kb = -1
! Return to best X and step in gradient direction
  230 aj%gfac = gfac
      ifl = nf_gmove
      nflag = ifl
      return

! Re-enter after computing gradient step from best X

  240 continue
      aj%dxn = gradnb*gfac ! In case the caller wants to compute cosines
      if ( gfac <= c0 ) go to 780
      axmax = axmaxb
      dxn = aj%dxn
      gfac = gfac*cp125
      spl = spg
      spg = spl/cp125
      fn = fnb
      fnxe = cp5 * fn **2
      frz = frzb
      gradn = gradnb
      go to 775

! Re-enter after computing Jacobian

  260 diag = aj%diag     ! Smallest | diagonal element | after factoring
      ajn = aj%ajn       ! Largest L1 norm of column in upper triangle
      fnmin = aj%fnmin   ! L2 Norm of F not in column space of the Jacobian
      gradn = aj%gradn   ! L2 norm of gradient
      if ( gradn <= c0 ) then
         gradn = c1
         if ( ajn <= c0 ) ajn = c1
      end if
      condai = max(min(condai, diag/ajn), (diag/ajn)**2)
      spact = cp25*condai
      frz = sqrt(abs((fn-fnmin)*(fn+fnmin)))

      if ( iter == 1 ) then ! First iteration
        sp = spstrt
        spinc = sp
        if ( frz <= rnd*fnmin ) go to 465
        dxi = cp125
      else
        if ( fn >= fnl ) then
d630 43
a672 8
! Select new stabilizing parameter for case when F has increased

          kb = 1
          if ( dxnl < dxnois ) then
            sp = c1pxm4*sp
            sqmin = min(sqmin, sp*ajn)
!           dxnl = dxnl * c100
            go to 520
a673 4
          spfac = max((fn/fnl)**2, c10)
          spinc = spl + spl + spact
          dxi = c1
          go to 515
a674 2
        if ( fn >= fnb ) go to 460
      end if
d676 1
a676 1
! New best X
d678 15
a692 17
      if ( aj%kfail /= 0 ) then
         if ( kb == 0 ) then ! Got new best immediately
            if ( aj%dxn >= 0.9_rk * aj%dxbad ) then
               aj%dxbad = aj%dxbad * (1.25_rk ** aj%kfail)
               aj%dxfail = aj%dxbad
               aj%kfail = aj%kfail + 1
            else
               aj%dxfail = 0.75_rk * aj%dxfail + 0.25_rk * aj%dxbad
               aj%kfail = 1
            end if
         else
            aj%dxfail = min(1.0625_rk * aj%dxfail, aj%dxbad)
         end if
         dxinc = min(dxmaxi, aj%dxfail)
      else
         dxinc = dxmaxi
      end if
d694 7
a700 10
      spinc = min(spinc, max(spmini, abs(ajscal)/ajn))
      sqmin = c0
      spb = spl
      sqb = sql
      if ( inc < 0 ) go to 520
      if ( inc /= 0 ) then
        if ( kb < 0 ) then
          dxi = cp25
        else if ( kb == 1 ) then ! We had a function increase
          dxi = cp25*dxnl/dxnbig ! prior to getting a new best.
d702 9
a710 13
        kb = 0
        inc = 0
      end if

! Test for convergence in sense of FN < (RELSF*FNMIN)

  460 if ( inc == 0 ) then
        tp = fn - (c1+relsf)*fnmin
        if ( (tp < c0 ) ) then
          go to 465 ! WVS changed this 2012-09-10 to allow convergence
                    ! with nonzero Levenberg-Marquardt parameter
!           if ( (sq <= aj%sqmin) .or. (spl <= spmini) .or. &
!            &   (tp <= -(c1+relsf)*spl*fn) ) go to 465
d712 2
a713 2
      end if
      go to 470
d715 1
a715 31
  465 nfl = nf_tolf
      nflag = nfl
      return

! Select new stabilizing parameter.  Also comes back here if user continues
! after TOLF convergence.

  470 tp = min((frz/frzl), (fn/fnl))

! Test if F appears almost linear over last step

      if ( fn**2 < 1.125_rk * fnxe ) then ! F appears almost linear.
        spfac = cp125*(1.025_rk-cdxdxl)*tp**2
        if ( spl <= spinc ) spinc = cp25*spinc
        dxi = min(dxi,cp25)
      else ! F not linear over last step
      ! spfac = tp*(fn**2)/fnxe
      ! if ( cdxdxl >= cp9) spfac = min(spfac,cp5)
      ! On 2002/07/25, FTK recommended:
        spfac = min(tp*(fn**2)/fnxe, 32.0_rk*(1.025_rk - cdxdxl)**2)
        dxi = c1
      end if
  515 if ( gradn > gradnl ) spfac = spfac*gradnl/gradn
      sp = max(spinc, min(spb, spl*spfac))
  520 sp = max(sp, sqmin/ajn)
!     if ( inc == 0 ) sp = min(sp, 0.5_rk*spl)
      spl = sp
      sq = sp*ajn
      aj%sqt = sq
      if ( sp < spact .and. inc >= 0 ) sq = sqmin
      gradnl = gradn
d717 2
a718 1
! Do Levenberg-Marquardt stabilization, solve for "Candidate DX"
d720 10
a729 35
  530 aj%sq = sq
      aj%starting = inc < 0
      ifl = nf_solve
      nflag = ifl
      return

! Re-enter after doing Levenberg-Marquardt stabilization and solving for
! candidate DX

  540 fnmin = aj%fnmin
      dxn = aj%dxn
      cgdx = aj%gdx/(gradn*dxn) ! Cosine ( gradient, dx )
      condai = min(cgdx, gradn/(dxn*ajn**2), diag/ajn)
      fnxe = fnmin**2
      if ( sq /= c0 ) fnxe = fnxe - (sq*dxn)**2
      if ( inc < 0 ) then
        if ( dxn <= dxinc ) then ! Move length OK?
          inc = incbig
          cdxdxl = c0 ! Don't think about Aitken
          go to 735   ! Go save best X, then use Newton's DX
        end if
      else
        cdxdxl = aj%dxdxl/(dxn*dxnl)
        if ( fnxe > fnb**2 ) then
          if ( k1it /= 0 ) call nwtdb ( width=9, level=0, why='Give up' )
          go to 222 ! Go do a gradient move
        end if
        if ( dxn < 1.1_rk * dxinc )  then
          if ( sq <= c0 .or. dxn > 0.90_rk * dxinc ) then
             if ( inc == 0 ) then
               if ( x_converge() ) return
               go to 735 ! Go save best X, then either DX or Aitken
             end if
             cait = cbig
             go to 755   ! Go use DX
d731 11
a741 1
!! WVS: was          dxinc = dxi * dxn * (c1 - cdxdxl)**2
d744 7
a750 1
          dxinc = dxi * dxn / (1.025 - cdxdxl)**2
a751 1
      end if
d753 1
a753 1
! Newton step length is too large or too small
d755 1
a755 1
      if ( k1it /= 0 ) call nwtdb ( width=9, level=0, why='Step length' )
d757 16
a772 14
!{ Calculate {\tt qn}$^2 = {\bf q}^T{\bf q} = ||{\bf q}||^2$, used to
!  determine the Levenberg-Marquardt parameter $\lambda$, where ${\bf q} =
!  {\bf U}^{-T} {\delta\bf x}$ and ${\delta\bf x}$ is the Newton step
!  computed with the current value of $\lambda$.  The method to determine
!  $\lambda$ and the reason for being interested in ${\bf q}^T{\bf q}$ are
!  explained below.

      ifl = nf_lev
      nflag = ifl
      return

!{ Determine the Levenberg-Marquardt parameter $\lambda$, known here as SQ.
!  The last Marquardt parameter used was SQ, which means that SQ**2 was
!  added to the diagonal of the normal equations.  A little bit of 
d778 1
a778 1
!  where ${\bf J}$ is the Jacobian matrix, is an approximate Hessian. 
d822 2
a823 2
! If you have been looking at Mor\'e and Sorensen, this update is the 
! negative of theirs since they define $\lambda$ as the negative of the 
d840 83
a922 42
  600 continue
      sq = sqrt(max( 0.0_rk, sq**2 - (dxn**2 / aj%qnsq) * (1.0_rk - dxn / dxinc) ))
      sp = sq / ajn
      go to 530

! Store best X, the gradient, and other constants used if a
! return needs to be made to the best X

  735 aj%fnormb = aj%fnorm
      ifl = nf_best
      nflag = ifl
      return

! Re-enter here after saving X as "best X" and Gradient as "Best gradient"

  740 axmaxb = axmax
      dxnois = max( dxnois, c1pxm4*dxnl)
      gfac = min(cp125*dxn/gradn, ajn**(-2))
      spg = spl + cp01
      fnb = fn
      frzb = frz
      fnminb = fnmin
      gradnb = gradn
      aj%gradnb = gradnb
      if ( abs(cdxdxl) < cp9 .or. sq /= c0 .or. dxn >= dxnl ) go to 755

! Compute scalar factor for (modified) Aitken acceleration

      ifl = nf_aitken
      nflag = ifl
      return

! Re-enter here after computing some numbers needed for (modified)
! Aitken acceleration

  750 tp = aj%dxdx
      if ( tp /= c0 ) then
         tp = c1 + aj%dxdxl/tp
         tp = min(c10, max(tp,cp01))
         if ( abs(cait-tp) < abs(cp25*(cait+tp)-cp5) ) then
            ! Set DX = Aitken-modified DX = CAIT * "Candidate DX"
            cait = tp
d924 4
a927 6
            sq = -cait
            dxn = cait*dxn
            aj%dxn = dxn ! In case the caller wants to compute cosines
            aj%cait = cait
            ifl = nf_dx_aitken
            nflag = ifl
d929 110
a1038 2
         end if
         if ( itken < iter ) cait = tp
d1040 12
d1053 3
a1055 1
! End of logic for Aitken acceleration
d1057 1
a1057 1
! Store Candidate DX as DX
d1059 6
a1064 13
  755 ifl = nf_dx
      nflag = ifl
      return

! Re-enter here after DX = "Candidate DX" or DX = CAIT * "Candidate DX"

  770 dxnl = dxn
      aj%dxnl = dxnl
      ! Come here after returning from a gradient move
  775 fnl = fn
      frzl = frz
      fnxe = cp25*fn**2 + cp76*fnxe
  780 if ( k1it /= 0 ) then
a1068 2
! Compute new X and test for too small a correction

d1070 30
a1099 9
      ifl = nf_newx
      nflag = ifl
      return

! Re-enter after computing new X

  850 if ( .not. aj%big ) then ! All dx's are very small
         if ( (spl <= spmini).or.(sq == c0) ) go to 870
         dxnois = max(dxnois, c10*dxn) ! Set so steps don't get too small.
d1101 29
a1129 2
      axmax = aj%axmax
      go to 20
d1131 2
a1132 1
  870 if ( (inc > 0) .and. (kb /= 0) ) go to 222 ! Go do gradient move
d1134 1
a1134 1
! Convergence -- move too small
d1136 12
a1147 3
      nfl = nf_too_small
      nflag = nfl
      return
d1149 4
a1152 1
  contains
a1153 2
    ! ...............................................  X_CONVERGE  .....
    logical function X_CONVERGE ( )
d1155 1
d1157 11
a1167 9
      if ( fnl > c0 ) then ! Not doing gradient moves from the best X
        if ( dxn <= tolxa .or. &
          & ((sq == c0).or.(spl <= spmini)) .and. dxn <= tolxr * axmax ) then
! Convergence if dxn is small enough or we have a suffiently small
! Levenberg-Marquardt parameter and we had a very small move.
          nfl = nf_tolx
          if ( kb /= 0 ) then
            aj%fnorm = fnb
            nfl = nf_tolx_best
d1169 1
a1169 1
          nflag = nfl
d1173 2
a1174 1
    end function X_CONVERGE
d1182 1
a1182 1
    type (NWT_T), intent(in) :: AJ
d1192 2
a1193 2
                                    0.1*huge(values), 0.01_rk, 0.0_rk, 0.0_rk, &
                                    0.0_rk, 0.0_rk /)
d1195 2
a1196 2
                                    0.1*huge(values), 0.01_rk, 0.0_rk, 0.0_rk, &
                                    0.0_rk, 0.0_rk /)
d1202 2
a1203 2
      valnom(7) = sqrt(sqrt(tiny(values))) ** 3
      valnom(8) = sqrt(sqrt(epsilon(values))) ** 3
d1208 1
a1208 1
      if ( .not. present(xopt) ) then
d1216 1
a1216 1
        select case ( ka )
d1218 1
a1218 1
        case ( 1, 2 ) ! Set K1IT
d1221 2
a1222 2
        case ( 3, 4, 7, 8 ) ! Change XSCAL and FSCAL indexes in data
                            ! or set up bounds option in data
d1224 2
a1225 2
        case ( 5, 6 ) ! Set flags in data for reverse communi-
                      ! cation and special matrix operations
d1228 1
a1228 1
        case ( 9, 10 ) ! Set to default values
d1233 2
a1234 2
        case ( 11:19 ) ! Set in data SPSTRT, SPMINI, AJSCAL,
                       ! DXMAXI, RELSF, and DXNOIS
d1237 1
a1237 1
            values(ka-10) = xopt(nopt(i+1))
d1251 1
d1279 4
a1282 2
    ! Present and 1 do everything
    ! Present and 0 do CDXDXL, CGDX, DXN, FN, FNMIN, INC, SP, SQ, SQRT(FNXE)
d1285 3
a1287 5
!   namelist /DNWTDB_OUT/ AJN, AJSCAL, CAIT, CDXDXL, CONDAI, DIAG
!   namelist /DNWTDB_OUT/ DXI, DXINC, DXMAXI, DXN, DXNBIG, DXNL, DXNOIS
!   namelist /DNWTDB_OUT/ FN, FNB, FNL, FNMIN, FNXE, FRZ, FRZB
!   namelist /DNWTDB_OUT/ FRZL, GFAC, GRADN, GRADNB, GRADNL
!   namelist /DNWTDB_OUT/ IFL, INC, ITER, ITKEN
d1289 2
a1290 3
!   namelist /DNWTDB_OUT/ NFL
!   namelist /DNWTDB_OUT/ RELSF, SPACT, SPB, SPFAC, SPG, SPINC, SPL, SPMINI
!   namelist /DNWTDB_OUT/ SPSTRT, SQB, SQL, SQMIN
d1293 1
a1293 1
    character(len=9) :: IFLname, NFLname
d1298 4
d1309 1
a1309 1
      &------------------------------------------------------------------'
d1312 1
a1312 1
    call flagName ( ifl, iflName ); call flagName ( nfl, nflName )
d1314 2
a1315 3
!   write ( *, '(a)' ) &
    call output( &
      & '       IFL        INC    ITER   ITKEN    K1IT      KB       NFL' )
d1317 3
a1319 3
    call output ( '', advance='yes' )
    write ( output_line, '(1x,a9,i11,4i8,1x,a9)' ) adjustr(iflName), INC, ITER, &
      & ITKEN, K1IT, KB, adjustr(nflName)
d1321 2
a1322 2
    if ( present(why) ) call output ( '  ' // trim(why) )
    call output ( '', advance='yes' )
a1326 1
    call add_to_line ( ajn,    'AJN' )
a1327 9
    if ( myLevel > 0 ) call add_to_line ( axmax,  'AXMAX' )
    if ( myLevel > 0 ) call add_to_line ( axmaxb, 'AXMAXB' )
    if ( myLevel > 0 ) call add_to_line ( cait,   'CAIT' )
    call add_to_line ( cdxdxl, 'CDXDXL' )
    call add_to_line ( cgdx,   'CGDX' )
    call add_to_line ( condai, 'CONDAI' )
    call add_to_line ( diag,   'DIAG' )
    if ( myLevel > 0 ) call add_to_line ( dxi,    'DXI' )
    call add_to_line ( dxinc,  'DXINC' )
a1328 3
    call add_to_line ( dxn,    'DXN' )
    if ( myLevel > 0 ) call add_to_line ( dxnbig, 'DXNBIG' )
    if ( myLevel > 0 ) call add_to_line ( dxnl,   'DXNL' )
a1329 13
    call add_to_line ( fn,     'FN ')
    if ( myLevel > 0 ) call add_to_line ( fnb,    'FNB' )
    if ( myLevel > 0 ) call add_to_line ( fnl,    'FNL' )
    call add_to_line ( fnmin,  'FNMIN' )
    if ( myLevel > 0 ) call add_to_line ( fnminb,  'FNMINB' )
    call add_to_line ( sqrt(fnxe),   'FNXE**.5' )
    call add_to_line ( frz,    'FRZ' )
    if ( myLevel > 0 ) call add_to_line ( frzb,   'FRZB' )
    if ( myLevel > 0 ) call add_to_line ( frzl ,  'FRZL' )
    if ( myLevel > 0 ) call add_to_line ( gfac,   'GFAC' )
    call add_to_line ( gradn,  'GRADN' )
    if ( myLevel > 0 ) call add_to_line ( gradnb, 'GRADNB' )
    if ( myLevel > 0 ) call add_to_line ( gradnl, 'GRADNL' )
a1330 7
    call add_to_line ( sp,     'SP ')
    if ( myLevel > 0 ) call add_to_line ( spact,  'SPACT' )
    if ( myLevel > 0 ) call add_to_line ( spb,    'SPB' )
    if ( myLevel > 0 ) call add_to_line ( spfac,  'SPFAC' )
    if ( myLevel > 0 ) call add_to_line ( spg,    'SPG' )
    if ( myLevel > 0 ) call add_to_line ( spinc,  'SPINC' )
    call add_to_line ( spl,    'SPL' )
a1332 3
    call add_to_line ( sq,     'SQ ')
    if ( myLevel > 0 ) call add_to_line ( sqb,    'SQB' )
    if ( myLevel > 0 ) call add_to_line ( sql,    'SQL' )
d1335 1
a1335 1
    if ( i /= 1 ) call print_lines
d1343 49
a1391 23
      call add_to_line ( aj%ajn,    'AJN' )
      call add_to_line ( aj%axmax,  'AXMAX' )
      call add_to_line ( aj%cait,   'CAIT' )
      call add_to_line ( aj%diag,   'DIAG' )
      call add_to_line ( aj%dxbad,  'DXBAD' )
      call add_to_line ( aj%dxfail, 'DXFAIL' )
      call add_to_line ( aj%dxdx,   'DXDX' )
      call add_to_line ( aj%dxdxl,  'DXDXL' )
      call add_to_line ( aj%dxn,    'DXN' )
      call add_to_line ( aj%dxnl,   'DXNL' )
      call add_to_line ( aj%fnmin,  'FNMIN' )
      call add_to_line ( aj%fnorm,  'FNORM' )
      call add_to_line ( aj%gdx,    'GDX' )
      call add_to_line ( aj%gfac,   'GFAC' )
      call add_to_line ( aj%gradn,  'GRADN' )
      call add_to_line ( aj%qnsq,   'QNSQ' )
      call add_to_line ( aj%sq,     'SQ' )
      call add_to_line ( aj%sqmin,  'SQMIN' )
      call add_to_line ( aj%sqt,    'SQT' )
      call add_to_line_I ( aj%kfail,    'KFAIL' )
      call add_to_line_L ( aj%big,      'BIG' )
      call add_to_line_L ( aj%starting, 'STARTING' )
      if ( i /= 1 ) call print_lines
a1398 9
    subroutine Add_To_Line ( Value, Name )
      real(rk), intent(in) :: Value
      character(len=*), intent(in) :: Name
      name_line(1+14*(i-1):10+14*(i-1)) = name
      name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
      write ( output_line(1+14*(i-1):14*i), '(es14.7)' ) value
      i = i + 1
      if ( i > myWidth ) call print_lines
    end subroutine Add_To_Line
d1403 2
a1404 1
      name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
d1413 2
a1414 1
      name_line(1+14*(i-1):10+14*(i-1)) = adjustr(name_line(1+14*(i-1):10+14*(i-1)))
d1416 2
a1417 1
      output_line(1+14*(i-1):10+14*(i-1)) = adjustr(output_line(1+14*(i-1):10+14*(i-1)))
d1421 10
d1432 2
a1433 2
      call output ( trim(name_line), advance='yes' )
      call output ( trim(output_line), advance='yes' )
a1445 1
    guts%ajn = ajn
a1446 9
    guts%axmax = axmax
    guts%axmaxb = axmaxb
    guts%cait = cait
    guts%cdxdxl = cdxdxl
    guts%cgdx = cgdx
    guts%condai = condai
    guts%diag = diag
    guts%dxi = dxi
    guts%dxinc = dxinc
a1447 3
    guts%dxn = dxn
    guts%dxnbig = dxnbig
    guts%dxnl = dxnl
a1448 14
    guts%fn = fn
    guts%fnb = fnb
    guts%fnl = fnl
    guts%fnmin = fnmin
    guts%fnminb = fnminb
    guts%fnxe = fnxe
    guts%frz = frz
    guts%frzb = frzb
    guts%frzl = frzl
    guts%gfac = gfac
    guts%gradn = gradn
    guts%gradnb = gradnb
    guts%gradnl = gradnl
    guts%ifl = ifl
a1453 1
    guts%nfl = nfl
a1454 7
    guts%sp = sp
    guts%spact = spact
    guts%spb = spb
    guts%spfac = spfac
    guts%spg = spg
    guts%spinc = spinc
    guts%spl = spl
a1456 3
    guts%sq = sq
    guts%sqb = sqb
    guts%sql = sql
d1467 2
a1468 2
    select case ( nflag )
    case ( NF_EVALF )
d1470 1
a1470 1
    case ( NF_EVALJ )
d1472 1
a1472 1
    case ( NF_LEV )
d1474 1
a1474 1
    case ( NF_SOLVE )
d1476 1
a1476 1
    case ( NF_NEWX )
d1478 1
a1478 1
    case ( NF_GMOVE )
d1480 1
a1480 1
    case ( NF_BEST )
d1482 1
a1482 1
    case ( NF_AITKEN )
d1484 1
a1484 1
    case ( NF_DX )
d1486 1
a1486 1
    case ( NF_DX_AITKEN )
d1488 1
a1488 1
    case ( NF_START )
d1490 1
a1490 1
    case ( NF_TOLX )
d1492 1
a1492 1
    case ( NF_TOLX_BEST )
d1494 1
a1494 1
    case ( NF_TOLF )
d1496 1
a1496 1
    case ( NF_TOO_SMALL )
d1498 1
a1498 1
    case ( NF_FANDJ )
d1503 1
a1503 1
  end subroutine FlagName
d1507 4
a1510 4
  character (len=*), parameter :: IdParm = &
       "$Id: dnwt_module.f90,v 2.54 2018/07/23 22:20:21 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
d1512 1
a1512 1
  end function not_used_here
d1515 1
a1515 1
end module DNWT_MODULE
a1517 4
! Revision 2.54  2018/07/23 22:20:21  vsnyder
! Add AJ to all argument lists for nwt* so the options can be (eventually)
! stored there instead of as saved module variables.
!
@


2.54
log
@Add AJ to all argument lists for nwt* so the options can be (eventually)
stored there instead of as saved module variables.
@
text
@d39 1
a39 1
! **  CALL NWT ( NFLAG, XOPT, NOPT)                 **
d1386 1
a1386 1
       "$Id: dnwt_module.f90,v 2.53 2015/05/15 23:41:01 vsnyder Exp $"
d1396 4
@


2.53
log
@Add FNORMB to AJ
@
text
@d261 1
a261 1
  subroutine DNWT ( NFLAG, XOPT, NOPT )
d275 1
d353 2
a354 2
    if ( present(nopt) ) call nwtop ( nopt, xopt )
    call nwtop ( ) ! default initialization
d1016 1
a1016 1
  subroutine DNWTOP ( NOPT, XOPT )
d1019 1
d1386 1
a1386 1
       "$Id: dnwt_module.f90,v 2.52 2012/09/13 18:06:56 vsnyder Exp $"
d1396 3
@


2.52
log
@Add SQMIN to AJ structure, allow convergence with nonzero lambda
@
text
@d155 1
d899 2
a900 1
  735 ifl = nf_best
d1384 1
a1384 1
       "$Id: dnwt_module.f90,v 2.51 2012/08/30 23:04:02 vsnyder Exp $"
d1394 3
@


2.51
log
@Use FNMIN at best X to decide on gradient move
@
text
@d161 4
d553 1
a553 1
          if ( (max(tp, sql) <= sqmin) .and. &
d719 6
a724 3
        if ( (tp < c0 ) .and. &
           & ( (sq == c0) .or. (spl <= spmini) .or. &
           &   (tp <= -(c1+relsf)*spl*fn) ) ) go to 465
a1198 1
    if ( myLevel > 0 ) call add_to_line ( sqmin,  'SQMIN' )
d1226 1
a1330 1
    guts%sqmin = sqmin
d1382 1
a1382 1
       "$Id: dnwt_module.f90,v 2.50 2012/04/20 01:29:21 vsnyder Exp $"
d1392 3
@


2.50
log
@Change dxinc calculation, add QNSQ output
@
text
@d224 1
a224 1
  real(rk) :: FN, FNB, FNL, FNMIN, FNXE, FRZ, FRZB
d236 1
a236 1
    real(rk) :: FN, FNB, FNL, FNMIN, FNXE, FRZ, FRZB
d408 1
d578 3
a580 1
            if ( (tp >= min(sql,sqb+sqb)) .or. (inc >= incbig) ) go to 222
d903 1
a903 1
!     fnminb = fnmin
d1170 1
d1295 1
d1376 1
a1376 1
       "$Id: dnwt_module.f90,v 2.49 2009/06/23 18:46:18 pwagner Exp $"
d1386 3
@


2.49
log
@Prevent Intel from optimizing ident string away
@
text
@d250 1
a250 1
       "$RCSfile: $"
d788 4
a791 1
          dxinc = dxi * dxn * (c1 - cdxdxl)**2
d1214 1
d1371 1
a1371 1
       "$Id: read_apriori.f90 is it here $"
d1381 3
@


2.48
log
@Initialize DXMAXI to 0.1*huge() so as not to get overflow
@
text
@d250 1
a250 1
       "$RCSfile: dnwt_module.f90,v $"
d1364 1
a1365 1
!---------------------------- RCS Ident Info -------------------------------
d1367 2
a1368 3
       "$Id: dnwt_module.f90,v 2.47 2007/01/11 20:46:33 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1370 1
d1372 1
d1377 3
@


2.47
log
@Correct a comment
@
text
@d1012 1
a1012 1
                                    huge(values), 0.01_rk, 0.0_rk, 0.0_rk, &
d1015 1
a1015 1
                                    huge(values), 0.01_rk, 0.0_rk, 0.0_rk, &
d1367 1
a1367 1
       "$Id: dnwt_module.f90,v 2.46 2006/06/08 23:55:59 vsnyder Exp $"
d1376 3
@


2.46
log
@Tighten More' Sorensen convergence criteria, TeXnicalities
@
text
@d81 1
a81 1
!         factor of J^T J, compute |q|**2
d1367 1
a1367 1
       "$Id: dnwt_module.f90,v 2.45 2006/06/06 15:22:51 vsnyder Exp $"
d1376 3
@


2.45
log
@Some code restructuring and commenting
@
text
@d80 2
a81 2
!         stabilization parameter:
! FRED: You need to tell me what to do here.
d590 5
a594 1
! Retreat to a previous -- best -- X
d603 1
a603 1
! Test if Jacobian matrix is being computed properly
d779 2
a780 2
        if ( dxn < 1.25_rk * dxinc )  then
          if ( sq <= c0 .or. dxn > cp5 * dxinc ) then
d796 6
a801 2
!{ Calculate qn$^2$ necessary to determine Levenberg-Marquardt parameter.
!  qn = $|| {\bf q} ||$ where ${\bf U}^T {\bf q} = {\delta\bf x}$.
d814 3
a816 3
!  where ${\bf H}$ is the Hessian matrix.  In our case, ${\bf A}^T {\bf A}$
!  is an approximate Hessian.  Differentiating both sides with respect to
!  $\lambda$ gives
d819 2
d823 1
a823 1
!  Or, using the Cholesky factor of $({\bf H} + \lambda {\bf I})$, we have
d825 2
a826 1
!  -{\delta\bf x}$.
d828 4
a831 1
!  The ${\bf q}$ we want is ${\bf U}^{-T} {\delta\bf x}$.  Thus from
d834 2
a835 3
!  = -\frac{\text{d}{\delta\bf x}}{\text{d}\lambda}^T {\delta\bf x}$ we have
!  ${\bf q}^T {\bf q} =
!  -\frac{\text{d}{\delta\bf x}}{\text{d}\lambda}^T {\delta\bf x}$.
d838 2
a839 2
!  $\phi = \frac1{|| {\delta\bf x} ||} - \frac1{\rho}$, where $\rho$ is the desired
!  step length ${\delta\bf x}$,
d845 3
a847 1
!  {\delta\bf x}^T \frac{\partial{\delta\bf x}}{\partial\lambda}
d859 1
a859 1
! (If you have been looking at Mor\'e and Sorensen, this update is the 
d861 15
a875 1
! $\lambda$ above.)
d1367 1
a1367 1
       "$Id: dnwt_module.f90,v 2.44 2006/06/03 00:15:59 vsnyder Exp $"
d1376 3
@


2.44
log
@Respect initial Levenberg-Marquardt parameter
@
text
@a376 1
! C1P025   Constant 1.025
a479 1
    real(rk), parameter :: C1P025 = 1.025_rk
d551 1
a551 2
        go to 219
      end if
d553 2
a554 1
! Test for convergence
d556 18
a573 10
      if ( x_converge() ) return
      if ( inc >= 0 ) then ! We are not starting
        if ( inc == 0 ) then ! Last X == Best X
          dxnbig = max(dxnl, dxnois)
          
        else      ! inc > 0 -- Last X not Best X
          if ( kb == 0 ) then
            if ( fn < fnb ) then
               gfac = -gfac
               if ( gfac >=  0 ) go to 927
d575 3
a577 1
            go to 228
d579 3
a581 3
          if ( dxnl <= dxnois ) go to 219
          if ( kb < 0 ) go to 224
          if ( (tp >= min(sql,sqb+sqb)) .or. (inc >= incbig) ) go to 222
a582 3
        sqmin = min(sqb, max(spl, spact)*ajn*c4)
        dxinc = max(dxnl*cp5, dxnois)
        inc = inc + 1
d597 1
a597 1
      if ( kb == (-4) ) then ! Four consecutive gradient moves !
d726 1
a726 1
        spfac = cp125*(c1p025-cdxdxl)*tp**2
d764 1
a764 1
        if ( dxn <= dxinc ) then
d766 2
a767 2
          cdxdxl = c0
          go to 735
d788 1
a788 1
! Step length is too large or too small
d938 1
a938 1
  870 if ( (inc > 0) .and. (kb /= 0) ) go to 222
a945 7
! Error processing

  927 call ermsg ( me, 2, 0, 'J or F may be in error', '.' )
      nfl = nf_fandj
      nflag = nfl
      return

d1338 1
a1338 1
       "$Id: dnwt_module.f90,v 2.43 2006/05/30 22:44:36 vsnyder Exp $"
d1347 3
@


2.43
log
@Handle Newton moves after gradient moves better
@
text
@d522 2
a523 1
      inc = -1
d633 1
a633 1
         if ( ajn <= c0) ajn = c1
d666 3
a668 3
      if (aj%kfail /= 0) then
         if (kb == 0) then ! Got new best immediately
            if (aj%dxn >= 0.9_rk * aj%dxbad) then
d703 1
a703 1
        if ( (tp < c0) .and. &
d722 1
a722 1
        if ( spl <= spinc) spinc = cp25*spinc
d738 1
a738 1
      if ( sp < spact) sq = sqmin
d757 1
a757 1
      if ( sq /= c0) fnxe = fnxe - (sq*dxn)**2
d798 1
a798 1
!%
d800 1
a800 1
!%
d804 1
a804 1
!%
d807 1
a807 1
!%
d811 1
a811 1
!%
d893 1
a893 1
         if ( itken < iter) cait = tp
d1012 1
a1012 1
          if ( k > 0) iopts(ka) = nopt(i+1)
d1016 1
a1016 1
          if ( k > 0) iopts(ka) = nopt(i+1)
d1019 1
a1019 1
          if ( k > 0) iopts(ka) = 1
d1029 1
a1029 1
          if ( k > 0) & ! If indicated, set to user input value
d1340 1
a1340 1
       "$Id: dnwt_module.f90,v 2.42 2005/06/22 18:57:01 pwagner Exp $"
d1349 3
@


2.42
log
@Reworded Copyright statement, moved rcs id
@
text
@d147 1
d150 1
d162 2
d250 1
a250 1
       "$RCSfile: $"
d397 1
a397 1
! DXNBIG   Value of DXN that resulted in a larger FN
d518 3
d542 7
a548 3
      tp = spl*ajn*cp9
      if ( fn < fnl ) then
        if ( fn >= fnb ) then
d558 1
a558 1
      if ( inc >= 0 ) then
d561 2
a562 1
        else      ! INC > 0 -- Last X not Best X
d587 3
d665 18
a682 1
      dxinc = dxmaxi
d691 2
a692 2
        else if ( kb == 1 ) then
          dxi = cp25*dxnl/dxnbig
d727 1
a727 1
        spfac = min(tp*(fn**2)/fnxe, 32.D0*(1.025D0 - cdxdxl)**2)
d925 1
a925 1
  850 if ( .not. aj%big ) then
d927 1
a927 1
         dxnois = max(dxnois, c10*dxn)
d953 1
a953 1
      if ( fnl > c0 ) then
d956 2
d1107 2
a1108 2
    write ( output_line, '(1x,a9,i11,4i8,1x,a9)' ) adjustr(iflName), INC, ITER, ITKEN, &
      & K1IT, KB, adjustr(nflName)
d1168 18
a1185 15
      call add_to_line ( aj%ajn,   'AJN' )
      call add_to_line ( aj%axmax, 'AXMAX' )
      call add_to_line ( aj%cait,  'CAIT' )
      call add_to_line ( aj%diag,  'DIAG' )
      call add_to_line ( aj%dxdx,  'DXDX' )
      call add_to_line ( aj%dxdxl, 'DXDXL' )
      call add_to_line ( aj%dxn,   'DXN' )
      call add_to_line ( aj%dxnl,  'DXNL' )
      call add_to_line ( aj%fnmin, 'FNMIN' )
      call add_to_line ( aj%fnorm, 'FNORM' )
      call add_to_line ( aj%gdx,   'GDX' )
      call add_to_line ( aj%gfac,  'GFAC' )
      call add_to_line ( aj%gradn, 'GRADN' )
      call add_to_line ( aj%sq,    'SQ' )
      call add_to_line ( aj%sqt,   'SQT' )
d1205 9
d1339 1
a1339 1
       "$Id: $"
d1348 3
@


2.41
log
@Implement Mor\'e and Sorensen calculation of the Lavenberg parameter
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d244 1
a244 4
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
       "$Id: dnwt_module.f90,v 2.40 2003/01/18 01:39:57 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
d246 2
a247 2
       "$RCSfile: dnwt_module.f90,v $"
  private :: not_used_here
d1291 5
d1302 3
@


2.40
log
@More output, prepare for More and Sorensen
@
text
@d148 2
d238 1
a238 1
       "$Id: dnwt_module.f90,v 2.39 2003/01/16 21:48:37 vsnyder Exp $"
d310 2
a311 2
!           with NFLAG= 2 if FN - FNMIN < RELSF * FNMIN .
!           NOPT(I) = -15 gives RELSF= 0.01  .
d367 1
d464 1
a464 2
! TP
! TP1      Temporary storage
d471 1
d475 1
a475 1
    real(rk), parameter :: CBIG = huge(c0)
d482 1
d484 1
a484 1
    real(rk) :: TP, TP1
a529 1
      ifl = nf_evalj
d541 1
a541 13
  200 if ( fnl > c0 ) then
        if ( dxn <= tolxa .or. &
           ((sq == c0).or.(spl <= spmini)) .and. dxn <= tolxr * axmax ) then
          nfl = nf_tolx
          if ( kb /= 0 ) then
            aj%fnorm = fnb
            nfl = nf_tolx_best
          end if
          nflag = nfl
          return
        end if
      end if
      if ( fn < fnl ) go to 735
d555 1
a555 2
          if ( (tp >= min(sql,sqb+sqb)) .or. (inc >= huge(inc)) ) go to 222
          inc = inc + 1
d559 1
d563 1
d577 1
a577 1
        gfac = -gfac/cp01
d612 1
a612 1
         if ( ajn <= c0) ajn=c1
d621 1
a621 1
        if ( frz <= rnd*fnmin ) go to 865
d632 1
a632 1
!           dxnl = dxnl / cp01
d667 1
a667 2
           &   ( tp <= -(c1+relsf)*spl*fn) ) ) go to 865 ! May eventually
           ! come back to next statement -- see computed GO TO on NFL near top
d669 1
d671 6
a676 1
! Select new stabilizing parameter
d682 1
a682 1
      if ( fn**2 < fnxe ) then ! F appears almost linear.
d693 1
a693 1
  515 if ( gradn > gradnl) spfac = spfac*gradnl/gradn
d696 1
a719 1
      tp = dxinc
d722 1
a722 1
          inc = huge(inc)
d732 10
a741 7
        tp1 = min(cp5, dxi*((c1-cdxdxl)**2))
        if ( tp*tp1 > dxnl) tp = dxnl/tp1
        if ( dxn <= tp .or. sp >= 1.0e12_rk ) then
          ifl = nf_dx
          if ( inc == 0 ) go to 200
          cait = cbig
          go to 755
d745 1
a745 1
! Step length is too large
a747 6
      spinc = sp
      sp = c4*spl + min(condai+condai, min(cp125, condai)*(dxn-tp)/tp)
      sq = sp*ajn
      spl = sqrt(sp**2+spl**2)
      aj%sqt = spl*ajn
      dxi = dxi*cp5
d749 2
a750 1
! Calculate quantities necessary to determine Levenberg-Marquardt parameter
d756 48
a803 1
! Determine the Levenberg-Marquardt parameter SQ.
d806 2
a807 1
! FRED: This is presumably where you finish off the More' and Sorensen.
d827 1
a893 3
  865 nfl = nf_tolf
      nflag = nfl
      return
d910 20
d1087 1
a1087 1
    if ( myLevel > 0 ) call add_to_line ( dxinc,  'DXINC' )
d1252 2
d1292 3
@


2.39
log
@More work on internal output
@
text
@d70 4
d162 3
d166 1
a166 1
  integer, parameter, public :: NF_SOLVE = nf_evalj-1
d236 1
a236 1
       "$Id: dnwt_module.f90,v 2.38 2003/01/16 04:06:58 vsnyder Exp $"
d493 2
a494 2
!                nf_evalf nf_evalj nf_solve nf_newx nf_gmove nf_best
        & go to (160,     260,     540,     850,    240,     740, &
d565 1
a568 1
        inc = inc + 1
d731 4
a734 1
        if ( fnxe > fnb**2 ) go to 222 ! Go do a gradient move
d738 1
d754 11
d816 1
a816 1
! Store DX
d1005 1
a1005 1
    if ( present(why) ) call output ( '  ' // why )
d1009 3
a1011 1
    call output ( trim(output_line), advance='yes' )
d1229 3
@


2.38
log
@Change some output in DNWT
@
text
@a191 1
  character(LEN=132), private :: output_line
d229 1
a229 1
       "$Id: dnwt_module.f90,v 2.37 2003/01/15 01:49:51 vsnyder Exp $"
d810 1
a810 1
        call nwtdb ( width=9, level=1, why='Before new X' )
d962 1
a962 1
    integer :: I ! Which one in the line is being worked
d965 2
a966 1
    character(132) :: Name_Line ! For names
d1205 3
@


2.37
log
@Add an '12-interesting-variables' dump
@
text
@d57 1
a57 1
!         J**T * J * "Candidate DX" = -J**T * F.            
d207 1
a207 1
  integer :: K1IT, K2IT, KB
d219 1
a219 1
    integer :: K1IT, K2IT, KB
d230 1
a230 1
       "$Id: dnwt_module.f90,v 2.36 2002/10/25 22:24:33 livesey Exp $"
d234 1
a234 1
  private :: not_used_here 
d413 1
a413 4
! K1IT     Counter on number of iterations to give basic internal
!          output
! K2IT     Counter on number of iterations to give extended internal
!          output
d493 1
a493 1
   10 if (ifl /= nf_start) go to 222 ! User forcing retreat to best X
d524 1
a524 1
          if ( (max(tp,sql) <= sqmin) .and. &
d547 1
a547 1
          dxnbig = max(dxnl,dxnois)
d550 1
a550 1
            if (fn < fnb) then
d552 1
a552 1
               if (gfac >=  0) go to 927
d556 1
a556 1
          if (dxnl <= dxnois) go to 219
d558 1
a558 1
          if ((tp >= min(sql,sqb+sqb)) .or. (inc >= huge(inc))) go to 222
d560 2
a561 2
        sqmin = min(sqb,max(spl,spact)*ajn*c4)
        dxinc = max(dxnl*cp5,dxnois)
d573 1
a573 1
      if (kb == (-4)) then
d594 1
a594 1
      if (gfac <= c0) go to 780
d612 1
a612 1
      if (gradn <= c0) then
d614 1
a614 1
         if (ajn <= c0) ajn=c1
d616 1
a616 1
      condai = max(min(condai,diag/ajn),(diag/ajn)**2)
d620 1
a620 1
      if (iter == 1) then ! First iteration
d623 1
a623 1
        if (frz <= rnd*fnmin) go to 865
d626 1
a626 1
        if (fn >= fnl) then
d631 1
a631 1
          if (dxnl < dxnois) then
d633 1
a633 1
            sqmin = min (sqmin, sp*ajn)
d637 2
a638 2
          spfac = max((fn/fnl)**2,c10)
          spinc = spl+spl+spact
d642 1
a642 1
        if (fn >= fnb) go to 460
d648 1
a648 1
      spinc = min(spinc,max(spmini,abs(ajscal)/ajn))
d652 3
a654 3
      if (inc < 0) go to 520
      if (inc /= 0) then
        if (kb < 0) then
d656 1
a656 1
        else if (kb == 1) then
d675 1
a675 1
  470 tp = min((frz/frzl),(fn/fnl))
d679 1
a679 1
      if (fn**2 < fnxe) then ! F appears almost linear.
d681 1
a681 1
        if (spl <= spinc) spinc = cp25*spinc
d685 2
a686 2
      ! if (cdxdxl >= cp9) spfac = min(spfac,cp5)
      ! On 020725, FTK recommended:
d690 3
a692 3
  515 if (gradn > gradnl) spfac = spfac*gradnl/gradn
      sp = max(spinc,min(spb,spl*spfac))
  520 sp = max(sp,sqmin/ajn)
d696 1
a696 1
      if (sp < spact) sq = sqmin
d713 1
a713 1
      condai = min(cgdx,gradn/(dxn*ajn**2),diag/ajn)
d715 1
a715 1
      if (sq /= c0) fnxe = fnxe-(sq*dxn)**2
d717 2
a718 2
      if (inc < 0) then
        if (dxn <= dxinc) then
d726 3
a728 3
        tp1 = min(cp5,dxi*((c1-cdxdxl)**2))
        if (tp*tp1 > dxnl) tp = dxnl/tp1
        if (dxn <= tp .or. sp >= 1.0e12_rk) then
d737 1
a737 7
      if (k1it /= 0) then
         write(output_line,3001) dxn,cdxdxl,spl,sq,cgdx,condai,inc,kb
 3001    format(' DXN=',1PG10.3,'  CDXDXL=',G10.3,'  SPL=', &
     &          G10.3,'  SQ=',G10.3,'  CGDX=',G10.3,        &
     &          '  CI=',G10.3,'  I,K=',I2,',',I2)
        call output(trim(output_line), advance='yes')
      end if
d739 1
a739 1
      sp = c4*spl+min(condai+condai,min(cp125,condai)*(dxn-tp)/tp)
d756 3
a758 3
      dxnois = max(dxnois,c1pxm4*dxnl)
      gfac = min(cp125*dxn/gradn,ajn**(-2))
      spg = spl+cp01
d775 2
a776 2
      if (tp /= c0) then
         tp = c1+aj%dxdxl/tp
d778 2
a779 1
         if (abs(cait-tp) < abs(cp25*(cait+tp)-cp5)) then
d781 8
a788 2
            itken = iter+2
            go to 760
d790 1
a790 1
         if (itken < iter) cait = tp
a799 8
! Store the Aitken-modified DX
  760 sq = -cait
      dxn = cait*dxn
      aj%dxn = dxn ! In case the caller wants to compute cosines
      aj%cait = cait
      ifl = nf_dx_aitken
      nflag = ifl
      return
d808 4
a811 14
      fnxe = cp25*fn**2+cp76*fnxe
  780 if (k1it /= 0) then
         k1it = k1it-1
         write(output_line,3002) iter,fn,frz,fnmin,fnxe,spl,sq
 3002    format(' ITER=',I4,'  FN=',G10.3, '  FRZ=',G10.3, &
     &          '  FNMIN=',G10.3,'  FNXE=', G10.3,'  SPL=',G10.3, &
     &          '  SQ=',G10.3)
         call output(trim(output_line), advance='yes')
         write(output_line,3003) dxn,gradn,cgdx,cdxdxl,ajn,diag,condai, &
     &                 inc,kb
 3003    format(' DXN=', G10.3,'  GRADN=',G10.3,'  CGDX=',G10.3, &
     &          '  CDXDXL=',G10.3,'  AJN=',G10.3,'  DIAG=',      &
     &          G10.3,'  CI=',G10.3,'  I,K=',I2,',',I2)
         call output(trim(output_line), advance='yes')
d824 1
a824 1
         if ((spl <= spmini).or.(sq == c0))  go to 870
d833 1
a833 1
  870 if ((inc > 0) .and. (kb /= 0)) go to 222
d877 1
a877 1
    end if      
d889 2
a890 2
        case ( 1, 2 ) ! Set K1IT and K2IT (data and common)
          if (k > 0) iopts(ka) = nopt(i+1)
a891 1
          k2it = iopts(2)
d894 1
a894 1
          if (k > 0) iopts(ka) = nopt(i+1)
d897 1
a897 1
          if (k > 0) iopts(ka) = 1
d907 1
a907 1
          if (k > 0) & ! If indicated, set to user input value
d914 1
a914 1
          ival(2) = nopt(i) 
a921 1
      k2it = iopts(2)
d939 1
a939 1
  subroutine DNWTDB ( AJ, WIDTH, LEVEL )
d951 1
d958 1
a958 1
!   namelist /DNWTDB_OUT/ K1IT, K2IT, KB
d972 1
a972 1
    if ( level == 0 ) myWidth = min(8,myWidth)
d980 8
a987 14
    if ( myLevel > 0 ) then
!     write ( *, '(a)' ) &
      call output( &
        & '       IFL        INC    ITER   ITKEN    K1IT    K2IT      KB       NFL', &
        & advance='yes' )
      write ( output_line, '(1x,a9,i11,5i8,1x,a9)' ) adjustr(iflName), INC, ITER, ITKEN, &
        & K1IT, K2IT, KB, adjustr(nflName)
    else
      call output ( &
        & '       IFL        INC       NFL', advance='yes' )
      write ( output_line, '(1x,a9,i11,1x,a9)' ) &
        & adjustr(iflName), inc, adjustr(nflName)
    end if
    call output(trim(output_line), advance='yes')
d992 1
a992 1
    if ( myLevel > 0 ) call add_to_line ( ajn,    'AJN' )
d999 2
a1000 2
    if ( myLevel > 0 ) call add_to_line ( condai, 'CONDAI' )
    if ( myLevel > 0 ) call add_to_line ( diag,   'DIAG' )
d1013 1
a1013 1
    if ( myLevel > 0 ) call add_to_line ( frz,    'FRZ' )
d1017 1
a1017 1
    if ( myLevel > 0 ) call add_to_line ( gradn,  'GRADN' )
d1027 1
a1027 1
    if ( myLevel > 0 ) call add_to_line ( spl,    'SPL' )
a1135 1
    guts%k2it = k2it
d1205 3
@


2.36
log
@Changed order of nwt_t
@
text
@d230 1
a230 1
       "$Id: dnwt_module.f90,v 2.35 2002/10/23 01:15:06 livesey Exp $"
d718 1
a718 1
      if (sq /= c0) fnxe = fnxe-(spl*ajn*dxn)**2
d961 1
a961 1
  subroutine DNWTDB ( AJ, WIDTH )
d970 3
d986 1
a986 1
    integer :: MyWidth
d989 2
d993 1
d1001 13
a1013 6
!    write ( *, '(a)' ) &
    call output( &
      & '       IFL        INC    ITER   ITKEN    K1IT    K2IT      KB       NFL', &
      & advance='yes' )
    write ( output_line, '(1x,a9,i11,5i8,1x,a9)' ) adjustr(iflName), INC, ITER, ITKEN, &
      & K1IT, K2IT, KB, adjustr(nflName)
d1019 5
a1023 5
    call add_to_line ( ajn,    'AJN' )
    call add_to_line ( ajscal, 'AJSCAL' )
    call add_to_line ( axmax,  'AXMAX' )
    call add_to_line ( axmaxb, 'AXMAXB' )
    call add_to_line ( cait,   'CAIT' )
d1026 5
a1030 5
    call add_to_line ( condai, 'CONDAI' )
    call add_to_line ( diag,   'DIAG' )
    call add_to_line ( dxi,    'DXI' )
    call add_to_line ( dxinc,  'DXINC' )
    call add_to_line ( dxmaxi, 'DXMAXI' )
d1032 3
a1034 3
    call add_to_line ( dxnbig, 'DXNBIG' )
    call add_to_line ( dxnl,   'DXNL' )
    call add_to_line ( dxnois, 'DXNOIS' )
d1036 2
a1037 2
    call add_to_line ( fnb,    'FNB' )
    call add_to_line ( fnl,    'FNL' )
d1039 9
a1047 9
    call add_to_line ( fnxe,   'FNXE' )
    call add_to_line ( frz,    'FRZ' )
    call add_to_line ( frzb,   'FRZB' )
    call add_to_line ( frzl ,  'FRZL' )
    call add_to_line ( gfac,   'GFAC' )
    call add_to_line ( gradn,  'GRADN' )
    call add_to_line ( gradnb, 'GRADNB' )
    call add_to_line ( gradnl, 'GRADNL' )
    call add_to_line ( relsf,  'RELSF' )
d1049 8
a1056 8
    call add_to_line ( spact,  'SPACT' )
    call add_to_line ( spb,    'SPB' )
    call add_to_line ( spfac,  'SPFAC' )
    call add_to_line ( spg,    'SPG' )
    call add_to_line ( spinc,  'SPINC' )
    call add_to_line ( spl,    'SPL' )
    call add_to_line ( spmini, 'SPMINI' )
    call add_to_line ( spstrt, 'SPSTRT' )
d1058 5
a1062 5
    call add_to_line ( sqb,    'SQB' )
    call add_to_line ( sql,    'SQL' )
    call add_to_line ( sqmin,  'SQMIN' )
    call add_to_line ( tolxa,  'TOLXA' )
    call add_to_line ( tolxr,  'TOLXR' )
d1233 3
@


2.35
log
@Added chiSq stuff
@
text
@d132 2
a140 2
    real(rk) :: CHISQMINNORM ! FNMIN^2 / no degrees of freedom
    real(rk) :: CHISQNORM  ! FNORM^2 / no degrees of freedom
d230 1
a230 1
       "$Id: dnwt_module.f90,v 2.34 2002/10/07 23:43:11 pwagner Exp $"
d1220 3
@


2.34
log
@Added idents to survive zealous Lahey optimizer
@
text
@d139 2
d230 1
a230 1
       "$Id: dnwt_module.f90,v 2.33 2002/09/23 22:04:11 vsnyder Exp $"
d1220 3
@


2.33
log
@Correct an error message, better computation of defaults for two options
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.32 2002/09/21 00:33:47 vsnyder Exp $"
d232 1
d1211 4
d1218 3
@


2.32
log
@Repair an error message
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.31 2002/09/21 00:21:44 vsnyder Exp $"
d890 2
a891 2
      valnom(7) = tiny(values) / sqrt(sqrt(tiny(values)))
      valnom(8) = epsilon(values) / sqrt(sqrt(epsilon(values)))
d897 1
a897 1
        call ermsg ( me, 99, 2, 'NOPT present but XOPT absent', ',' )
d1213 3
@


2.31
log
@Correct a FlagName result
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.30 2002/09/19 01:25:53 vsnyder Exp $"
d860 1
a860 1
  927 call ermsg ( me, 2, 0, 'J or F may be in error', ',' )
d1213 3
@


2.30
log
@More on when to stop going uphill
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.29 2002/09/14 02:46:00 vsnyder Exp $"
d1192 1
a1192 1
      itsName = 'AITKEN'
d1213 3
@


2.29
log
@Move test for retreat-to-best, some housecleaning
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.27 2002/09/11 23:41:53 vsnyder Exp $"
a715 1
      if ( fnxe > fnb**2 ) go to 222
d725 1
a729 1
      if ( fnxe > fnb**2 ) go to 222
d1213 3
@


2.28
log
@FNXE is the square of the norm.  Compare it to FNB**2
@
text
@d498 1
d716 1
d730 1
d743 1
a743 1
      call output(trim(output_line), advance='yes')
a812 1
      if ( fnxe > fnb**2 ) go to 222
@


2.27
log
@Correct improved test for retreating to best X
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.26 2002/09/10 23:52:56 vsnyder Exp $"
d810 1
a810 1
      if ( fnxe > fnb ) go to 222
d1212 3
@


2.26
log
@Improved test for retreating to best X
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.25 2002/07/26 22:46:40 vsnyder Exp $"
d810 1
a810 1
      if ( sqrt(fnmin**2 - (sq*dxn)**2) > fnb ) go to 222
d1212 3
@


2.25
log
@More better output in DNWTDB
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.24 2002/07/26 01:19:18 vsnyder Exp $"
d402 1
a402 1
!          See negative values of NF_... parameters above.
d493 1
a493 1
   10 if (ifl /= nf_start) go to 222 ! retreat to best X
d521 2
a522 2
      if (fn < fnl) then
        if (fn >= fnb) then
d524 1
a524 1
               ((fn*(fn/fnl)**2) > fnb) .and. (cdxdxl >= cp25)) go to 222
d810 1
d1212 3
@


2.24
log
@Better output in DNWTDB, changed how Levenberg_Marquardt changes, per Fred
@
text
@d190 1
a190 1
  character(LEN=80), private :: output_line
d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.23 2002/07/24 20:32:15 vsnyder Exp $"
d816 6
a821 2
         write(output_line,3002) iter,fn,frz,fnmin,fnxe,spl,         &
     &                 sq,dxn,gradn,cgdx,cdxdxl,ajn,diag,condai, &
d823 2
a824 5
 3002    format(' ITER=',I4,'  FN=',G10.3,  &
     &          '  FRZ=',G10.3,'  FNMIN=',G10.3,'  FNXE=',    &
     &          G10.3,'  SPL=',G10.3,'  SQ=',G10.3/' DXN=',   &
     &          G10.3,'  GRADN=',G10.3,'  CGDX=',G10.3,       &
     &          '  CDXDXL=',G10.3,'  AJN=',G10.3,'  DIAG=',   &
d956 1
a956 1
  subroutine DNWTDB ( AJ )
d959 3
a961 1
!   present.
d964 1
d966 9
a974 9
    namelist /DNWTDB_OUT/ AJN, AJSCAL, CAIT, CDXDXL, CONDAI, DIAG
    namelist /DNWTDB_OUT/ DXI, DXINC, DXMAXI, DXN, DXNBIG, DXNL, DXNOIS
    namelist /DNWTDB_OUT/ FN, FNB, FNL, FNMIN, FNXE, FRZ, FRZB
    namelist /DNWTDB_OUT/ FRZL, GFAC, GRADN, GRADNB, GRADNL
    namelist /DNWTDB_OUT/ IFL, INC, ITER, ITKEN
    namelist /DNWTDB_OUT/ K1IT, K2IT, KB
    namelist /DNWTDB_OUT/ NFL
    namelist /DNWTDB_OUT/ RELSF, SPACT, SPB, SPFAC, SPG, SPINC, SPL, SPMINI
    namelist /DNWTDB_OUT/ SPSTRT, SQB, SQL, SQMIN
d976 1
d978 2
d981 2
a982 38
    call output ( &
      & '-----     DNWT internal variables     --------------------------------', &
      & advance='yes' )
!   write (*,dnwtdb_out)
!    write ( *, '(a)' ) &
    call output( &
      & '       AJN        AJSCAL         AXMAX        AXMAXB          CAIT', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) AJN, AJSCAL, AXMAX, AXMAXB, CAIT
    call output(trim(output_line), advance='yes')

!    write ( *, '(a)' ) &
    call output( &
      & '    CDXDXL          CGDX        CONDAI          DIAG           DXI', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) CDXDXL, CGDX, CONDAI, DIAG, DXI
    call output(trim(output_line), advance='yes')

!    write ( *, '(a)' ) &
    call output( &
      & '     DXINC        DXMAXI           DXN        DXNBIG          DXNL', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) DXINC, DXMAXI, DXN, DXNBIG, DXNL
    call output(trim(output_line), advance='yes')

!    write ( *, '(a)' ) &
    call output( &
      & '    DXNOIS            FN           FNB           FNL         FNMIN', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) DXNOIS, FN, FNB, FNL, FNMIN
    call output(trim(output_line), advance='yes')

!    write ( *, '(a)' ) &
    call output( &
      & '      FNXE           FRZ          FRZB          FRZL          GFAC', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) FNXE, FRZ, FRZB, FRZL, GFAC
    call output(trim(output_line), advance='yes')
d984 3
a986 6
!    write ( *, '(a)' ) &
    call output( &
      & '     GRADN        GRADNB        GRADNL', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) GRADN, GRADNB, GRADNL
    call output(trim(output_line), advance='yes')
d998 48
a1045 26
!    write ( *, '(a)' ) &
    call output( &
      & '     RELSF            SP         SPACT           SPB         SPFAC', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) RELSF, SP, SPACT, SPB, SPFAC
    call output(trim(output_line), advance='yes')

!    write ( *, '(a)' ) &
    call output( &
      & '       SPG         SPINC           SPL        SPMINI        SPSTRT', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) SPG, SPINC, SPL, SPMINI, SPSTRT
    call output(trim(output_line), advance='yes')

!    write ( *, '(a)' ) &
    call output( &
      & '        SQ           SQB           SQL         SQMIN         TOLXA', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) SQ, SQB, SQL, SQMIN, TOLXA
    call output(trim(output_line), advance='yes')

    call output( &
      & '     TOLXR', &
      & advance='yes' )
    write ( output_line, '(5es14.7)' ) TOLXR
    call output(trim(output_line), advance='yes')
d1048 23
a1070 26
      call output ( &
        & '-----     DNWT external variables     --------------------------------', &
        & advance='yes' )

      call output( &
        & '       AJN         AXMAX          CAIT          DIAG          DXDX', &
        & advance='yes' )
      write ( output_line, '(5es14.7)' ) aj%AJN, aj%AXMAX, aj%CAIT, aj%DIAG, aj%DXDX
      call output(trim(output_line), advance='yes')

      call output( &
        & '     DXDXL           DXN          DXNL         FNMIN         FNORM', &
        & advance='yes' )
      write ( output_line, '(5es14.7)' ) aj%DXDXL, aj%DXN, aj%DXNL, aj%FNMIN, aj%FNORM
      call output(trim(output_line), advance='yes')

      call output( &
        & '       GDX          GFAC         GRADN            SQ           SQT', &
        & advance='yes' )
      write ( output_line, '(5es14.7)' ) aj%GDX, aj%GFAC, aj%GRADN, aj%SQ, aj%SQT
      call output(trim(output_line), advance='yes')

      call output( &
        & '       BIG      STARTING', advance='yes' )
      write ( output_line, '(9x,l1,13x,l1)' ) aj%BIG, aj%STARTING
      call output(trim(output_line), advance='yes') 
d1073 31
a1103 3
    call output ( &
      & '----------------------------------------------------------------------', &
      & advance='yes' )
d1211 3
@


2.23
log
@Moved AXMAX, AXMAXB, CGDX, SP and SQ from DNWTA to module scope.
Added a "get DNWT's guts" routine.
@
text
@d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.22 2002/07/24 01:08:11 vsnyder Exp $"
d683 4
a686 2
        spfac = tp*(fn**2)/fnxe
        if (cdxdxl >= cp9) spfac = min(spfac,cp5)
d955 1
a955 1
  subroutine DNWTDB
d957 4
a960 1
!   Print the scalars in the module
d974 3
d980 10
a989 3
      & '       AJN        AJSCAL          CAIT        CDXDXL        CONDAI', &
      & advance='yes')
    write ( output_line, '(5es14.7)' ) AJN, AJSCAL, CAIT, CDXDXL, CONDAI
d994 3
a996 3
      & '      DIAG           DXI         DXINC        DXMAXI           DXN', &
      & advance='yes')
    write ( output_line, '(5es14.7)' ) DIAG, DXI, DXINC, DXMAXI, DXN
d1001 3
a1003 3
      & '    DXNBIG          DXNL        DXNOIS            FN           FNB', &
      & advance='yes')
    write ( output_line, '(5es14.7)' ) DXNBIG, DXNL, DXNOIS, FN, FNB
d1008 3
a1010 3
      & '       FNL         FNMIN          FNXE           FRZ          FRZB', &
      & advance='yes')
    write ( output_line, '(5es14.7)' ) FNL, FNMIN, FNXE, FRZ, FRZB
d1015 3
a1017 3
      & '      FRZL          GFAC         GRADN        GRADNB        GRADNL', &
      & advance='yes')
    write ( output_line, '(5es14.7)' ) FRZL, GFAC, GRADN, GRADNB, GRADNL
d1019 1
d1025 1
a1025 1
      & advance='yes')
d1032 3
a1034 3
      & '     RELSF         SPACT           SPB         SPFAC           SPG', &
      & advance='yes')
    write ( output_line, '(5es14.7)' ) RELSF, SPACT, SPB, SPFAC, SPG
d1039 3
a1041 3
      & '     SPINC           SPL        SPMINI        SPSTRT           SQB', &
      & advance='yes')
    write ( output_line, '(5es14.7)' ) SPINC, SPL, SPMINI, SPSTRT, SQB
d1046 3
a1048 3
      & '       SQL         SQMIN         TOLXA         TOLXR', &
      & advance='yes')
    write ( output_line, '(5es14.7)' ) SQL, SQMIN, TOLXA, TOLXR
d1050 39
d1090 1
d1196 4
@


2.22
log
@Made most local variables SAVE.  Mark Filipiak noticed this problem.
@
text
@d120 2
a121 2
  public :: RK, DNWT, DNWTA, DNWTDB, DNWTOP
  public :: NWT, NWT_T, NWTA, NWTDB, NWTOP
d200 2
a201 2
  real(rk) :: AJN, AJSCAL, CAIT, CDXDXL, CONDAI, DIAG
  real(rk) :: DXI, DXINC, DXMAXI, DXN, DXNBIG, DXNL, DXNOIS
d207 2
a208 2
  real(rk) :: RELSF, SPACT, SPB, SPFAC, SPG, SPINC, SPL, SPMINI
  real(rk) :: SPSTRT, SQB, SQL, SQMIN
d211 13
d228 1
a228 1
       "$Id: dnwt_module.f90,v 2.21 2002/02/14 21:53:10 vsnyder Exp $"
a473 1
    real(rk), save :: AXMAX, AXMAXB, CGDX, SP, SQ
d1035 59
d1140 3
@


2.21
log
@Add parameters for largest and smallest nwt_flag values
@
text
@d215 1
a215 1
       "$Id: dnwt_module.f90,v 2.20 2002/01/09 00:00:04 pwagner Exp $"
d461 2
a462 1
    real(rk) :: AXMAX, AXMAXB, CGDX, SP, SQ, TP, TP1
d1069 3
@


2.20
log
@Replaced write or print statements with calls to output
@
text
@d187 3
d215 1
a215 1
       "$Id: dnwt_module.f90,v 2.19 2001/06/13 23:57:12 vsnyder Exp $"
d1068 3
@


2.19
log
@Use NF_START instead of zero to start IFL
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d115 1
d187 1
d212 1
a212 1
       "$Id: dnwt_module.f90,v 2.18 2001/06/13 23:50:57 vsnyder Exp $"
d718 1
a718 1
         write(*,3001) dxn,cdxdxl,spl,sq,cgdx,condai,inc,kb
d722 1
d798 1
a798 1
         write(*,3002) iter,fn,frz,fnmin,fnxe,spl,         &
d807 1
d954 34
a987 15
    write ( *, '(a)' ) &
      & '       AJN        AJSCAL          CAIT        CDXDXL        CONDAI'
    write ( *, '(5es14.7)' ) AJN, AJSCAL, CAIT, CDXDXL, CONDAI
    write ( *, '(a)' ) &
      & '      DIAG           DXI         DXINC        DXMAXI           DXN'
    write ( *, '(5es14.7)' ) DIAG, DXI, DXINC, DXMAXI, DXN
    write ( *, '(a)' ) &
      & '    DXNBIG          DXNL        DXNOIS            FN           FNB'
    write ( *, '(5es14.7)' ) DXNBIG, DXNL, DXNOIS, FN, FNB
    write ( *, '(a)' ) &
      & '       FNL         FNMIN          FNXE           FRZ          FRZB'
    write ( *, '(5es14.7)' ) FNL, FNMIN, FNXE, FRZ, FRZB
    write ( *, '(a)' ) &
      & '      FRZL          GFAC         GRADN        GRADNB        GRADNL'
    write ( *, '(5es14.7)' ) FRZL, GFAC, GRADN, GRADNB, GRADNL
d989 6
a994 3
    write ( *, '(a)' ) &
      & '       IFL        INC    ITER   ITKEN    K1IT    K2IT      KB       NFL'
    write ( *, '(1x,a9,i11,5i8,1x,a9)' ) adjustr(iflName), INC, ITER, ITKEN, &
d996 22
a1017 9
    write ( *, '(a)' ) &
      & '     RELSF         SPACT           SPB         SPFAC           SPG'
    write ( *, '(5es14.7)' ) RELSF, SPACT, SPB, SPFAC, SPG
    write ( *, '(a)' ) &
      & '     SPINC           SPL        SPMINI        SPSTRT           SQB'
    write ( *, '(5es14.7)' ) SPINC, SPL, SPMINI, SPSTRT, SQB
    write ( *, '(a)' ) &
      & '       SQL         SQMIN         TOLXA         TOLXR'
    write ( *, '(5es14.7)' ) SQL, SQMIN, TOLXA, TOLXR
d1065 3
@


2.18
log
@Correct not-restarting-correctly in DNWT
@
text
@d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.17 2001/06/01 23:04:11 vsnyder Exp $"
d307 2
a308 2
    nflag = nf_start
    ifl = 0
d475 1
a475 1
   10 if (ifl /= 0) go to 222 ! retreat to best X
d1026 3
@


2.17
log
@Corrected two bugs having to do with Aitken acceleration
@
text
@d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.16 2001/06/01 01:38:27 vsnyder Exp $"
d308 1
d1026 3
@


2.16
log
@Correct some comments, and some cosmetic changes
@
text
@d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.15 2001/05/25 20:14:01 vsnyder Exp $"
d471 1
a471 1
        &        740,      770,  770), -ifl
d750 1
d1025 3
@


2.15
log
@Replace 1p5e format that NAG doesn't like with 5es format
@
text
@d123 22
a144 22
  type NWT_T             ! Stuff about the problem, neatly packaged.  This
                         ! is the type of the AJ argument of NWTA.  Unless
                         ! otherwise noted, components are inputs to ?NWTA.
                         ! See usage instructions above.
    real(rk) :: AJN      ! Largest L1 norm of column in upper triangle
                         ! of factored Jacobian matrix
    real(rk) :: AXMAX    ! MAXVAL(ABS(X))
    real(rk) :: CAIT     ! Aitken parameter -- intent(out)
    real(rk) :: DIAG     ! Smallest | diagonal element | after factoring
    real(rk) :: DXDX     ! dot_product( DX, DX )
    real(rk) :: DXDXL    ! dot_product( "candidate DX", DX )
    real(rk) :: DXN      ! L2 Norm of candidate DX
    real(rk) :: DXNL     ! L2 Norm of last candidate DX -- intent(out)
    real(rk) :: FNMIN    ! L2 Norm of F not in column space of the Jacobian
    real(rk) :: FNORM    ! L2 Norm of F at current X
    real(rk) :: GDX      ! dot_product( Gradient, "Candidate DX" )
    real(rk) :: GFAC     ! Amount of best gradient to use for DX
    real(rk) :: GRADN    ! L2 norm of Gradient
    real(rk) :: SQ       ! Levenberg-Marquardt parameter -- intent(out)
    real(rk) :: SQT      ! Total Levenberg-Marquardt stabilization -- intent(out)
    logical :: BIG       ! ANY( DX > 10.0 * epsilon(X) * X )
    logical :: STARTING  ! NWTA is still in "starting up" phase -- intent(out)
d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.14 2001/05/25 04:58:50 livesey Exp $"
d231 3
a233 3
      integer, intent(out) :: NFLAG
      real(rk), intent(in) :: XOPT(*)
      integer, intent(in), optional :: NOPT(*)
d237 3
a239 3
! NFLAG  = Integer used for communication with the user.  NWT sets NFLAG
!     = 0.  NFLAG is by NWTA.  When NWTA returns control to the calling
!     program unit, NFLAG is used as shown above.
d1024 3
@


2.14
log
@Had to comment out some of Van's code to make it compile on NAG.
@
text
@d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.13 2001/05/24 23:28:06 vsnyder Exp $"
d573 1
d576 1
a576 2
      dxn = gradnb*gfac
      aj%dxn = dxn ! In case the caller wants to compute cosines
d584 1
a584 1
      go to 770
d787 2
a788 1
      fnl = fn
d948 15
a962 15
!     write ( *, '(a)' ) &
!       & '       AJN        AJSCAL          CAIT        CDXDXL        CONDAI'
!     write ( *, '(1p5e14.7)' ) AJN, AJSCAL, CAIT, CDXDXL, CONDAI
!     write ( *, '(a)' ) &
!       & '      DIAG           DXI         DXINC        DXMAXI           DXN'
!     write ( *, '(1p5e14.7)' ) DIAG, DXI, DXINC, DXMAXI, DXN
!     write ( *, '(a)' ) &
!       & '    DXNBIG          DXNL        DXNOIS            FN           FNB'
!     write ( *, '(1p5e14.7)' ) DXNBIG, DXNL, DXNOIS, FN, FNB
!     write ( *, '(a)' ) &
!       & '       FNL         FNMIN          FNXE           FRZ          FRZB'
!     write ( *, '(1p5e14.7)' ) FNL, FNMIN, FNXE, FRZ, FRZB
!     write ( *, '(a)' ) &
!       & '      FRZL          GFAC         GRADN        GRADNB        GRADNL'
!     write ( *, '(1p5e14.7)' ) FRZL, GFAC, GRADN, GRADNB, GRADNL
d964 13
a976 13
!     write ( *, '(a)' ) &
!       & '       IFL        INC    ITER   ITKEN    K1IT    K2IT      KB       NFL'
!     write ( *, '(1x,a9,i11,5i8,1x,a9)' ) adjustr(iflName), INC, ITER, ITKEN, &
!       & K1IT, K2IT, KB, adjustr(nflName)
!     write ( *, '(a)' ) &
!       & '     RELSF         SPACT           SPB         SPFAC           SPG'
!     write ( *, '(1p5e14.7)' ) RELSF, SPACT, SPB, SPFAC, SPG
!     write ( *, '(a)' ) &
!       & '     SPINC           SPL        SPMINI        SPSTRT           SQB'
!     write ( *, '(1p5e14.7)' ) SPINC, SPL, SPMINI, SPSTRT, SQB
!     write ( *, '(a)' ) &
!       & '       SQL         SQMIN         TOLXA         TOLXR'
!     write ( *, '(1p5e14.7)' ) SQL, SQMIN, TOLXA, TOLXR
d1024 3
@


2.13
log
@Improve internal output; initial value for dxnl=1, not zero
@
text
@d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.12 2001/05/24 20:23:41 vsnyder Exp $"
d947 15
a961 15
    write ( *, '(a)' ) &
      & '       AJN        AJSCAL          CAIT        CDXDXL        CONDAI'
    write ( *, '(1p5e14.7)' ) AJN, AJSCAL, CAIT, CDXDXL, CONDAI
    write ( *, '(a)' ) &
      & '      DIAG           DXI         DXINC        DXMAXI           DXN'
    write ( *, '(1p5e14.7)' ) DIAG, DXI, DXINC, DXMAXI, DXN
    write ( *, '(a)' ) &
      & '    DXNBIG          DXNL        DXNOIS            FN           FNB'
    write ( *, '(1p5e14.7)' ) DXNBIG, DXNL, DXNOIS, FN, FNB
    write ( *, '(a)' ) &
      & '       FNL         FNMIN          FNXE           FRZ          FRZB'
    write ( *, '(1p5e14.7)' ) FNL, FNMIN, FNXE, FRZ, FRZB
    write ( *, '(a)' ) &
      & '      FRZL          GFAC         GRADN        GRADNB        GRADNL'
    write ( *, '(1p5e14.7)' ) FRZL, GFAC, GRADN, GRADNB, GRADNL
d963 13
a975 13
    write ( *, '(a)' ) &
      & '       IFL        INC    ITER   ITKEN    K1IT    K2IT      KB       NFL'
    write ( *, '(1x,a9,i11,5i8,1x,a9)' ) adjustr(iflName), INC, ITER, ITKEN, &
      & K1IT, K2IT, KB, adjustr(nflName)
    write ( *, '(a)' ) &
      & '     RELSF         SPACT           SPB         SPFAC           SPG'
    write ( *, '(1p5e14.7)' ) RELSF, SPACT, SPB, SPFAC, SPG
    write ( *, '(a)' ) &
      & '     SPINC           SPL        SPMINI        SPSTRT           SQB'
    write ( *, '(1p5e14.7)' ) SPINC, SPL, SPMINI, SPSTRT, SQB
    write ( *, '(a)' ) &
      & '       SQL         SQMIN         TOLXA         TOLXR'
    write ( *, '(1p5e14.7)' ) SQL, SQMIN, TOLXA, TOLXR
d1023 3
@


2.12
log
@Keep aj%dxn up to date after Gradient or Aitken moves
@
text
@d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.11 2001/05/24 18:16:11 vsnyder Exp $"
d478 1
a478 1
      aj%dxnl = c0
d693 1
a693 1
      if (sq /= c0)  fnxe = fnxe-(spl*ajn*dxn)**2
d944 32
a975 1
    write (*,dnwtdb_out)
d1003 2
d1014 2
a1016 1
    case default
d1023 3
@


2.11
log
@Added NF_START parameter; initially define aj%dxdxl
@
text
@d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.10 2001/05/22 19:10:33 vsnyder Exp $"
d576 1
d777 1
d989 3
@


2.10
log
@Compute aj%starting; improve some comments
@
text
@d110 1
a110 1
!       IF ( you want to return to a previous best X ) NFLAG = 0
d135 1
d147 2
d210 1
a210 1
       "$Id: dnwt_module.f90,v 2.9 2001/05/18 01:02:43 vsnyder Exp $"
d307 1
a307 1
    nflag = 0
d477 2
a478 1
      dxnl = c0
d487 1
a487 1
      aj%dxdxl = 0.0 ! So it's not undefined, because the user isn't expected
d704 1
a704 1
        if (dxn <= tp .or. sp >= 1.0d12) then
d784 1
d987 3
@


2.9
log
@Checking for 'big' move incorrectly
@
text
@d51 1
d53 1
a53 1
!         was -1:
d148 1
a148 1
  !      Evaluate F AJ%FNORM:
d207 1
a207 1
       "$Id: dnwt_module.f90,v 2.8 2001/05/17 20:15:28 vsnyder Exp $"
d798 1
d982 3
@


2.8
log
@Make sure aj%dxdxl has an initial value
@
text
@d206 1
a206 1
       "$Id: $"
d209 1
a209 1
       "$RCSfile: $"
d803 1
a803 1
  850 if ( aj%big ) then
d980 3
@


2.7
log
@Correct 'iter' calculation, add 'FlagName' subroutine
@
text
@d205 5
a209 4
  CHARACTER (LEN=256) :: Id = &
       "$Id: dnwt_module.f90,v 2.6 2001/05/03 02:00:39 vsnyder Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
       "$RCSfile: dnwt_module.f90,v $"
d482 2
d980 3
@


2.6
log
@Insert copyright notice
@
text
@d120 1
d206 1
a206 1
       "$Id: dnwt_module.f90,v 2.5 2001/04/28 01:47:39 vsnyder Exp $"
d487 2
a488 1
  160 fn = aj%fnorm
d934 40
d977 3
@


2.5
log
@Get correct initial value for nflag
@
text
@d1 3
d205 1
a205 1
       "$Id: dnwt_module.f90,v 2.4 2001/04/12 00:03:21 vsnyder Exp $"
d935 3
@


2.4
log
@Put 'Total Levenberg-Marquart' in AJ
@
text
@d202 1
a202 1
       "$Id: dnwt_module.f90,v 2.3 2001/02/16 00:19:34 vsnyder Exp $"
d478 1
a478 1
      nflag = nflag
d932 3
@


2.3
log
@Corrected some comments; changed a dummy argument name.
@
text
@d136 1
d202 1
a202 1
       "$Id: dnwt_module.f90,v 2.2 2001/02/06 23:33:54 vsnyder Exp $"
d659 1
d708 1
d710 1
a710 1
      sq = sp*ajn
d932 3
@


2.2
log
@Initially botched putting in the CVS variables; got it right this time.
@
text
@d4 1
a4 1
!--D replaces "?": ?NWT_MODULE, ?NWT_TYPE, ?NWT,    ?NWTA, ?NWTDB, ?NWTOP
d25 1
a25 1
! Assign values to X( ) and NOPT( ).
d28 1
a28 1
! **  CALL NWT ( NFLAG, X, NOPT)                 **
d140 1
a140 1
  ! Reasons for returning to user.  See description of usage below.
d201 1
a201 1
       "$Id: dnwt_module.f90,v 2.1 2001/02/06 23:23:53 vsnyder Exp $"
d208 1
a208 1
  subroutine DNWT ( NFLAG, X, NOPT )
d222 1
a222 1
      real(rk), intent(in) :: X(*)
d231 1
a231 1
! X( ) = Array used for values needed to set options; see NOPT below.
d238 1
a238 1
!           tion in X( ) requires NOPT(K) > 7 * NX.  In such a case,
d257 1
a257 1
!    = 11   Set SPSTRT = X(NOPT(I+1)), where SPSTRT is the starting
d260 1
a260 1
!    = 12   Set SPMINI = X(NOPT(I+1)), where SPMINI is the approximate
d264 1
a264 1
!    = 13   Set AJSCAL = X(NOPT(I+1)), where AJSCAL is the approximate
d267 1
a267 1
!    = 14   Set DXMAXI = X(NOPT(I+1)), where DXMAXI is the largest value
d270 1
a270 1
!    = 15   Set RELSF = X(NOPT(I+1)), where convergence is indicated
d273 1
a273 1
!    = 16   Set DXNIOS = X(NOPT(I+1)), where DXNOIS is the smallest move
d276 1
a276 1
!    = 17   Set TOLXA = X(NOPT(I+1)), where convergence is indicated
d281 1
a281 1
!    = 18   Set TOLXR = X(NOPT(I+1)), where convergence is indicated
d298 1
a298 1
    if ( present(nopt) ) call nwtop ( nopt, x )
d929 3
@


2.1
log
@Initial commit
@
text
@a10 7
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id: ermsg_m.f90,v 2.1 2001/02/06 23:21:28 vsnyder Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
       "$RCSfile: ermsg_m.f90,v $"
!---------------------------------------------------------------------------

d199 7
d928 4
a931 1
! $Log: $
@

