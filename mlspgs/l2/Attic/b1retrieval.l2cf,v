head	1.4;
access;
symbols
	V1-04:1.3
	V1-03:1.3
	V1-02:1.3
	V1-00:1.3;
locks; strict;
comment	@# @;


1.4
date	2002.06.06.18.13.41;	author bill;	state dead;
branches;
next	1.3;

1.3
date	2001.10.09.01.10.43;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.03.04.54.22;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.03.03.17.48;	author livesey;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Removed
@
text
@; This l2cf is an attempt to make a universal l2cf for doing sids runs
; This is a simple l2cf for testing purposes. Mainly for testing the
; M4 stuff.  The band number to do is passed in as _band, the date as
; !day.

; First some m4 directives.
include(m4defs.l2cf)

!define(outpath,/bigdata/livesey/misc/)
!define(ver,v0-5-test1)
!define(day,1996-051)

!define(signal,!sigBand$1)
!define(molecules,!mol$1)
!define(systemp, !systemp$1)

; Now include the valid signals database
!include(validsignals-emls.l2cf)

; Now the spectroscopy database
!include(spectroscopy.l2cf)

; Now read the l2gp files for each specie
!include(readl2gpfiles.l2cf)

; Now read the gridded data for each specie
!include(readclimatology.l2cf)

; -------------------------------------------- Global settings ----
begin GlobalSettings

  l1Boa, file='!data/emls/l1boa/truth/!year(!day)/MLS-Aura_L1BOA_Full_s4-t_!day.dat'
  startTime = "00:00:00"
  endTime = "00:05:00"

  vGridStandard: vGrid, coordinate=Zeta, type=Logarithmic, $
    start=1000mb, formula=[25:12, 24:6]
  vGridBaseline: vGrid, coordinate=Zeta, type=Logarithmic, $
    start=1000mb, formula=[37:6]

  vGridRefGPH: vGrid, coordinate=Zeta, type=Explicit, values=100mb


  forwardModelGlobal, $
    l2pc='/bigdata/livesey/misc/l2pc_band1L_v1.0.dat'

  sidsFwm: forwardModel, type=linear,  $
    signals = 'R1A:118.B1LF:PT', /do_baseline
  retFwm: forwardModel, type=linear,  $
    signals = 'R1A:118.B1LF:PT', /temp_der, /do_baseline
  scanFwm: forwardModel, type=scan, module=GHz

end GlobalSettings

; ------------------------------------------ Chunk divide  ----
!include(chunkdivide1.l2cf)

; ------------------------------------------- Construct sections --
begin Construct
  hGridStandard: hGrid, type=height, height=15km, module=GHz
end Construct

!include(constructstandardspecies.l2cf)
!include(constructunfoldedradiances.l2cf)

begin Construct

  stateTemplate: VectorTemplate, quantities=  $
    [ refGPH, ptanGHz, temp, baselineR1A ]
  
  extraStateTemplate: VectorTemplate, quantities =  $
    [ tngtGeocAltGHz, h2o ]
  
  measTemplate: VectorTemplate, quantities= $
    [ band1L, scanResidualGHz ]
end Construct

; ------------------------------------------- Fill -----------------

begin Fill

  !define( truthGPH, 15.8km )
  
  ;; Define the vectors
  x: Vector, template=stateTemplate ; State
  a: Vector, template=stateTemplate ; A priori
  sdIn: Vector, template=stateTemplate ; A priori standard deviation
  sdOut: Vector, template=stateTemplate ; Solution standard deviation
  t: Vector, template=stateTemplate ; Truth
  
  b: Vector, template=extraStateTemplate ; Extra state
  y: Vector, template=measTemplate ; Radiances
  ya: Vector, template=measTemplate ; Radiances for a priori state
  f: Vector, template=measTemplate ; Forward model radiances
  yNoise: Vector, template=measTemplate ; Radiance noise
  
  ;; Define the matrix
  K: Matrix, rows=y, columns=x
  
  ;; Fill t with the `truth'
  Fill, quantity=t.temp,    method=l2gp, sourceL2GP=l2gpTEMPInput, /interpolate
  Fill, quantity=t.refGPH,  method=explicit, explicitValues=!truthGPH, /spread
  
  ;; Fill a and x with a apriori
  Fill, quantity=a.temp, method=gridded, sourceGrid=gridTemperature
  Fill, quantity=x.temp, method=gridded, sourceGrid=gridTemperature
  Fill, quantity=a.refGPH, method=explicit, explicitvalues=16km,/spread
  Fill, quantity=x.refGPH, method=explicit, explicitvalues=16km,/spread
  Fill, quantity=a.baselineR1A, method=explicit, explicitvalues=0K,/spread
  Fill, quantity=x.baselineR1A, method=explicit, explicitvalues=0K,/spread
  
;   ;; OR can use truth
;   Fill, quantity=a.temp, method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
;   Fill, quantity=x.temp, method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
;   Fill, quantity=a.refGPH, method=explicit, explicitvalues=!truthGPH,/spread
;   Fill, quantity=x.refGPH, method=explicit, explicitvalues=!truthGPH,/spread
;   Fill, quantity=a.baselineR1A, method=explicit, explicitvalues=0K,/spread
;   Fill, quantity=x.baselineR1A, method=explicit, explicitvalues=0K,/spread
  
  ;; Now fill the remaining state quantities
  Fill, quantity=b.h2o, method=gridded, sourceGrid=gridH2O, /interpolate
  Fill, quantity=b.tngtGeocAltGHz, method=l1b
  
  ;; Now the tangent presssures
  Fill, quantity=t.ptanGHz, method=hydrostatic, $
    h2oQuantity=b.h2o, $
    temperatureQuantity=t.temp, $
    refGPHQuantity=t.refGPH, $
    geocAltitudeQuantity=b.tngtGeocAltGHz, $
    maxIterations=10
  
  ;; Fill x and a from a priori
  Fill, quantity=x.ptanGHz, method=hydrostatic, $
    h2oQuantity=b.h2o, $
    temperatureQuantity=a.temp, $
    refGPHQuantity=a.refGPH, $
    geocAltitudeQuantity=b.tngtGeocAltGHz, $
    maxIterations=10
  Fill, quantity=a.ptanGHz, method=hydrostatic, $
    h2oQuantity=b.h2o, $
    temperatureQuantity=a.temp, $
    refGPHQuantity=a.refGPH, $
    geocAltitudeQuantity=b.tngtGeocAltGHz, $
    maxIterations=10
  
;   ;; Or can use truth
;   Fill, quantity=x.ptanGHz, method=hydrostatic, $
;     h2oQuantity=b.h2o, $
;     temperatureQuantity=t.temp, $
;     refGPHQuantity=t.refGPH, $
;     geocAltitudeQuantity=b.tngtGeocAltGHz, $
;     maxIterations=10
;   Fill, quantity=a.ptanGHz, method=hydrostatic, $
;     h2oQuantity=b.h2o, $
;     temperatureQuantity=t.temp, $
;     refGPHQuantity=t.refGPH, $
;     geocAltitudeQuantity=b.tngtGeocAltGHz, $
;     maxIterations=10
  
  ;; Define matrices
  ;; myJacobian: matrix, rows=radiance, columns=state
  myCovariance: matrix, columns=x, type=spd
  
  Fill, quantity=sdIn.temp, method=explicit, explicitValues=20 K, /spread
  Fill, quantity=sdIn.refGPH, method=explicit, explicitValues= 5 km, /spread
  Fill, quantity=sdIn.ptanGHz, method=explicit, explicitValues= 0.2, /spread
  Fill, quantity=sdIn.baselineR1A, method=explicit, explicitValues= 5 K, /spread
  FillCovariance, matrix=myCovariance, diagonal=sdIn, /invert
end Fill

; ------------------------------------------------------- Sids -----

begin Retrieve
  Sids, fwdModelIn=t, fwdModelExtra=b, fwdModelOut=y,$
    forwardModel=[sidsFwm]
  Sids, fwdModelIn=a, fwdModelExtra=b, fwdModelOut=ya,$
    forwardModel=[sidsFwm]
end Retrieve

; ------------------------------------------------- Fill, noise -----

begin Fill
  Fill, quantity=yNoise.band1L, radianceQuantity=y.band1L,  $
    systemTemperature= 1500K, integrationTime=0.16 s,  $
    method = estimatedNoise
  Fill, quantity=yNoise.scanResidualGHz, method=explicit,  $
    explicitValues = 10 m ,/spread
  Snoop, comment='Before retrieval'
end Fill

; ------------------------------------------------------- Retrieve -----

begin Retrieve
;  Snoop, comment='Only retrieval'
  ;; Subset, quantity=x.temp, height= [ 100mb: 0.1mb ]
  Retrieve, state=x, fwdModelExtra=b, measurements=y, measurementSD=yNoise, $
    forwardModel= [ retFwm, scanFwm ], $
    covariance=myCovariance, apriori=a, columnScale=none, $
    maxF=200, maxJ=100, lambda=10.0, outputSD=SDout
  Sids, fwdModelIn=x, fwdModelExtra=b, fwdModelOut=f,$
     forwardModel=[sidsFwm]
  Sids, fwdModelIn=x, fwdModelExtra=b, fwdModelOut=f,$
    forwardModel=[scanFwm]
end Retrieve

begin Fill
   Snoop, comment='After retrieval'
end Fill

; ------------------------------------------------------- Join -----

begin Join
  l2gpTx: l2gp, source=x.temp, swath = 'Temperature', precision=sdOut.temp
  l2gpTa: l2gp, source=a.temp, swath = 'Temperature', precision=sdIn.temp
  l2gpTt: l2gp, source=t.temp,  swath = 'Temperature'
  l2gpHx: l2gp, source=x.refGPH, swath = 'refGPH', precision=sdOut.refGPH
  l2gpHa: l2gp, source=a.refGPH, swath = 'refGPH', precision=sdIn.refGPH
  l2gpHt: l2gp, source=t.refGPH,  swath = 'refGPH'
  
  ptanXl2aux: l2aux, source=x.ptanGHz,sdName='ptanGHzX'
  ptanAl2aux: l2aux, source=a.ptanGHz,sdName='ptanGHzA'
  ptanTl2aux: l2aux, source=t.ptanGHz,sdName='ptanGHzT'
  ptanASl2aux: l2aux, source=sdIn.ptanGHz,sdName='ptanGHzA precision'
  ptanXSl2aux: l2aux, source=sdOut.ptanGHz,sdName='ptanGHzX precision'
  
  measRadL2AUX: l2aux, source=y.band1L, /prefixSignal, sdName=''
  measNoiseL2AUX: l2aux, source=yNoise.band1L, /prefixSignal, sdName=' precision'
  aprioriRadL2AUX: l2aux, source=ya.band1L, /prefixSignal, sdName=' apr'
  fitRadL2AUX: l2aux, source=f.band1L, /prefixSignal, sdName=' fit'
end Join


; ---------------------------------------------------------  Output  -----
begin Output
    
  Output, file='!outpath/temp_x.l2gp', quantities=l2gpTx, type=l2gp
  Output, file='!outpath/temp_a.l2gp', quantities=l2gpTa, type=l2gp
  Output, file='!outpath/temp_t.l2gp', quantities=l2gpTt, type=l2gp
  Output, file='!outpath/refGPH_x.l2gp', quantities=l2gpHx, type=l2gp
  Output, file='!outpath/refGPH_a.l2gp', quantities=l2gpHa, type=l2gp
  Output, file='!outpath/refGPH_t.l2gp', quantities=l2gpHt, type=l2gp
  
  Output, file='!outpath/data.l2aux', quantities= $
    [ ptanXl2aux, ptanAl2aux, ptanTl2aux, ptanASl2aux, ptanXSl2aux, $
    measRadL2aux, measNoiseL2AUX, aprioriRadL2AUX, fitRadL2AUX ], type=l2aux

end Output




@


1.3
log
@Regular commit, new m4 version
@
text
@@


1.2
log
@Interim version
@
text
@d4 1
a4 10
; _day.

define(_outpath,/bigdata/livesey/misc/)
define(_ver,v0-5-test1)
define(_day,1996-051)
define(_year,1996)

define(_signal,_sigBand$1)
define(_molecules,_mol$1)
define(_systemp, _systemp$1)
d9 8
d18 1
a18 1
l2cfinc(validsignals-emls.l2cf)
d21 1
a21 1
l2cfinc(spectroscopy.l2cf)
d24 1
a24 1
l2cfinc(readl2gpfiles.l2cf)
d27 1
a27 1
l2cfinc(readclimatology.l2cf)
d30 5
a34 1
BEGIN GlobalSettings
d36 4
a39 3
    l1Boa, file='/data/emls/l1boa/truth/{}_year{}/MLS-Aura_L1BOA_Full_s4-t_{}_day{}.dat'
    startTime = "00:00:00"
    endTime = "00:05:00"
d41 1
a41 2
    vGridStandard: vGrid, coordinate=Zeta, type=Logarithmic, $
                   start=1000mb, formula=[25:12, 24:6]
a42 1
    vGridRefGPH: vGrid, coordinate=Zeta, type=Explicit, values=100mb
d44 2
a45 2
    forwardModelGlobal, $
      l2pc='/bigdata/livesey/misc/l2pc_band1L_v1.0.dat'
d47 5
a51 5
    sidsFwm: forwardModel, type=linear,  $
      signals = 'R1A:118.B1LF:PT', /do_baseline
    retFwm: forwardModel, type=linear,  $
      signals = 'R1A:118.B1LF:PT', /temp_der, /do_baseline
    scanFwm: forwardModel, type=scan, module=GHz
d53 1
a53 1
END GlobalSettings
d56 1
a56 14
BEGIN ChunkDivide
    IdealLength = 10 MAFs
    noChunks = 1
    ignoreL1B = true

;    IdealLength =             0.125 orbits
    overlap =                 0 MAFs
    HomeGeodAngle =           0 degrees
    HomeModule =              GHz
    ScanLowerLimit =          -10 km : 20 km
    ScanUpperLimit =          40 km : 100 km
    CriticalScanningModules = Both
    MaxGap =                  3 minutes
END ChunkDivide
d59 3
a61 5
BEGIN Construct

    hGridStandard: hGrid, type=height, height=15km, module=GHz

END Construct
d63 2
a64 2
l2cfinc(constructstandardspecies.l2cf)
l2cfinc(constructunfoldedradiances.l2cf)
d66 1
a66 3
BEGIN Construct
  baseline: Quantity, type=baseline, radiometer=R1A, $
    hGrid=hGridStandard, vGrid=vGridStandard
d69 1
a69 1
    [ refGPH, ptanGHz, temp, baseline ]
d76 1
a76 1
END Construct
d80 1
a80 1
BEGIN Fill
d82 88
a169 70
    ;; Define the vectors
    x: Vector, template=stateTemplate ; State
    a: Vector, template=stateTemplate ; A priori
    sdIn: Vector, template=stateTemplate ; A priori standard deviation
    sdOut: Vector, template=stateTemplate ; Solution standard deviation
    t: Vector, template=stateTemplate ; Truth

    b: Vector, template=extraStateTemplate ; Extra state
    y: Vector, template=measTemplate ; Radiances
    ya: Vector, template=measTemplate ; Radiances for a priori state
    f: Vector, template=measTemplate ; Forward model radiances
    yNoise: Vector, template=measTemplate ; Radiance noise

    ;; Define the matrix
    K: Matrix, rows=y, columns=x

    ;; Fill t with the `truth'
    Fill, quantity=t.temp,    method=l2gp, sourceL2GP=l2gpTEMPInput, /interpolate
    Fill, quantity=t.refGPH,  method=explicit, explicitValues=15km, /spread
    Fill, quantity=t.baseline, method=explicit, explicitValues=0K, /spread
    
    ;; Fill a and x with a apriori
    Fill, quantity=a.temp,    method=gridded, sourceGrid=gridTemperature
    Fill, quantity=x.temp,    method=gridded, sourceGrid=gridTemperature
    Fill, quantity=a.refGPH, method=explicit, explicitvalues=16km,/spread
    Fill, quantity=x.refGPH, method=explicit, explicitvalues=16km,/spread
    Fill, quantity=a.baseline, method=explicit, explicitValues=0K, /spread
    Fill, quantity=x.baseline, method=explicit, explicitValues=0K, /spread

; OR can use truth
;     Fill, quantity=a.temp, method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
;     Fill, quantity=x.temp, method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
;     Fill, quantity=x.temp, method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
;     Fill, quantity=a.refGPH, method=explicit, explicitvalues=15km,/spread
;     Fill, quantity=x.refGPH, method=explicit, explicitvalues=15km,/spread
;     Fill, quantity=a.baseline, method=explicit, explicitValues=0K, /spread
;     Fill, quantity=x.baseline, method=explicit, explicitValues=0K, /spread

    ;; Now fill the remaining state quantities
    Fill, quantity=b.h2o,    method=gridded, sourceGrid=gridH2O, /interpolate

    Fill, quantity=b.tngtGeocAltGHz, method=l1b

    ;; Now the tangent presssures
    Fill, quantity=t.ptanGHz, method=hydrostatic, $
      h2oQuantity=b.h2o, $
      temperatureQuantity=t.temp, $
      refGPHQuantity=t.refGPH, $
      geocAltitudeQuantity=b.tngtGeocAltGHz, $
      maxIterations=10

    Fill, quantity=x.ptanGHz, method=hydrostatic, $
      h2oQuantity=b.h2o, $
      temperatureQuantity=x.temp, $
      refGPHQuantity=t.refGPH, $
      geocAltitudeQuantity=b.tngtGeocAltGHz, $
      maxIterations=10

    ;; Define matrices
    ;; myJacobian: matrix, rows=radiance, columns=state
    myCovariance: matrix, columns=x, type=spd

    Fill, quantity=sdIn.temp, method=explicit, explicitValues=20 K, /spread
    Fill, quantity=sdIn.refGPH, method=explicit, explicitValues= 5 km, /spread
    Fill, quantity=sdIn.baseline, method=explicit, explicitValues= 5 K, /spread
    Fill, quantity=sdIn.ptanGHz, method=explicit, explicitValues=10, /spread
    fillCovariance, matrix=myCovariance, diagonal=sdIn, /invert

    Snoop, comment='Before sids'
END Fill
d173 6
a178 9
BEGIN Retrieve

   time
   sids, fwdModelIn=t, fwdModelExtra=b, fwdModelOut=y,$
     forwardModel=[sidsFwm]
   sids, fwdModelIn=a, fwdModelExtra=b, fwdModelOut=ya,$
     forwardModel=[sidsFwm]

END Retrieve
d182 8
a189 9
BEGIN Fill

    Fill, quantity=yNoise.band1L, radianceQuantity=y.band1L,  $
      systemTemperature= 1500K, integrationTime=0.16 s,  $
      method = estimatedNoise
    Fill, quantity=yNoise.scanResidualGHz, method=explicit,  $
      explicitValues = 16 km ,/spread
    Snoop,comment='Before retrieval'
END Fill
d193 8
a200 8
BEGIN Retrieve

;   Subset, quantity=x.temp, height= [ 100mb : 0.1mb ]
   Retrieve, state=x, fwdModelExtra=b, measurements=y, measurementSD=yNoise, $
      forwardModel= [ retFwm, scanFwm ], $
      covariance=myCovariance, apriori=a, columnScale=none, $
      maxF=8, maxJ=4, lambda=1.0, outputSD=SDout
   sids, fwdModelIn=x, fwdModelExtra=b, fwdModelOut=f,$
d202 7
a208 6

END Retrieve

BEGIN Fill
   Snoop,comment='After retrieval'
END Fill
d212 19
a230 19
BEGIN Join
    l2gpTx:  l2gp, source=x.temp, swath = 'Temperature', precision=sdOut.temp
    l2gpTa:  l2gp, source=a.temp, swath = 'Temperature', precision=sdIn.temp
    l2gpTt:  l2gp, source=t.temp,  swath = 'Temperature'
    l2gpHx:  l2gp, source=x.refGPH, swath = 'refGPH', precision=sdOut.refGPH
    l2gpHa:  l2gp, source=a.refGPH, swath = 'refGPH', precision=sdIn.refGPH
    l2gpHt:  l2gp, source=t.refGPH,  swath = 'refGPH'

    ptanXl2aux: l2aux, source=x.ptanGHz,sdName='ptanGHzX'
    ptanAl2aux: l2aux, source=a.ptanGHz,sdName='ptanGHzA'
    ptanTl2aux: l2aux, source=t.ptanGHz,sdName='ptanGHzT'
    ptanASl2aux: l2aux, source=sdIn.ptanGHz,sdName='ptanGHzA precision'
    ptanXSl2aux: l2aux, source=sdOut.ptanGHz,sdName='ptanGHzX precision'

    measRadL2AUX: l2aux, source=y.band1L, /prefixSignal, sdName=''
    measNoiseL2AUX: l2aux, source=yNoise.band1L, /prefixSignal, sdName=' precision'
    aprioriRadL2AUX: l2aux, source=ya.band1L, /prefixSignal, sdName=' apr'
    fitRadL2AUX: l2aux, source=f.band1L, /prefixSignal, sdName=' fit'
END Join
d234 1
a234 1
BEGIN Output
d236 10
a245 15
    output, file='{}_outpath{}temp_x.l2gp', quantities=l2gpTx, type=l2gp
    output, file='{}_outpath{}temp_a.l2gp', quantities=l2gpTa, type=l2gp
    output, file='{}_outpath{}temp_t.l2gp', quantities=l2gpTt, type=l2gp
    output, file='{}_outpath{}refGPH_x.l2gp', quantities=l2gpHx, type=l2gp
    output, file='{}_outpath{}refGPH_a.l2gp', quantities=l2gpHa, type=l2gp
    output, file='{}_outpath{}refGPH_t.l2gp', quantities=l2gpHt, type=l2gp

    output, file='{}_outpath{}data.l2aux', quantities= $
      [ ptanXl2aux, ptanAl2aux, ptanTl2aux, ptanASl2aux, ptanXSl2aux, $
        measRadL2aux, measNoiseL2AUX, aprioriRadL2AUX, fitRadL2AUX ], type=l2aux

END Output



d247 1
@


1.1
log
@Interim version with baseline
@
text
@d200 1
a200 1
      maxF=8, maxJ=4, lambda=0.0, outputSD=SDout
@

