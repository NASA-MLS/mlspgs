head	2.138;
access;
symbols
	V0-5-Level2:2.127
	V0-5-SIPS:2.92;
locks; strict;
comment	@# @;


2.138
date	2001.05.29.23.19.06;	author livesey;	state dead;
branches;
next	2.137;

2.137
date	2001.05.29.23.09.59;	author livesey;	state Exp;
branches;
next	2.136;

2.136
date	2001.05.25.20.25.56;	author livesey;	state Exp;
branches;
next	2.135;

2.135
date	2001.05.21.23.58.10;	author livesey;	state Exp;
branches;
next	2.134;

2.134
date	2001.05.17.01.44.16;	author livesey;	state Exp;
branches;
next	2.133;

2.133
date	2001.05.17.00.49.54;	author livesey;	state Exp;
branches;
next	2.132;

2.132
date	2001.05.16.23.03.59;	author livesey;	state Exp;
branches;
next	2.131;

2.131
date	2001.05.16.01.20.08;	author livesey;	state Exp;
branches;
next	2.130;

2.130
date	2001.05.15.03.46.31;	author zvi;	state Exp;
branches;
next	2.129;

2.129
date	2001.05.14.23.18.26;	author livesey;	state Exp;
branches;
next	2.128;

2.128
date	2001.05.11.22.18.56;	author livesey;	state Exp;
branches;
next	2.127;

2.127
date	2001.05.03.23.34.44;	author livesey;	state Exp;
branches;
next	2.126;

2.126
date	2001.05.03.20.31.34;	author vsnyder;	state Exp;
branches;
next	2.125;

2.125
date	2001.05.02.20.31.43;	author livesey;	state Exp;
branches;
next	2.124;

2.124
date	2001.05.02.20.28.35;	author livesey;	state Exp;
branches;
next	2.123;

2.123
date	2001.04.28.17.47.42;	author livesey;	state Exp;
branches;
next	2.122;

2.122
date	2001.04.28.01.44.09;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2001.04.26.22.53.37;	author zvi;	state Exp;
branches;
next	2.120;

2.120
date	2001.04.26.20.02.09;	author livesey;	state Exp;
branches;
next	2.119;

2.119
date	2001.04.26.19.47.53;	author livesey;	state Exp;
branches;
next	2.118;

2.118
date	2001.04.26.02.50.47;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2001.04.26.02.49.52;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2001.04.26.00.06.58;	author livesey;	state Exp;
branches;
next	2.114;

2.114
date	2001.04.25.00.50.33;	author livesey;	state Exp;
branches;
next	2.113;

2.113
date	2001.04.25.00.09.48;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2001.04.24.23.11.04;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2001.04.24.19.44.48;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2001.04.24.00.03.36;	author livesey;	state Exp;
branches;
next	2.109;

2.109
date	2001.04.23.22.22.50;	author livesey;	state Exp;
branches;
next	2.108;

2.108
date	2001.04.23.22.09.54;	author zvi;	state Exp;
branches;
next	2.107;

2.107
date	2001.04.23.21.56.06;	author livesey;	state Exp;
branches;
next	2.106;

2.106
date	2001.04.23.21.42.46;	author zvi;	state Exp;
branches;
next	2.105;

2.105
date	2001.04.21.01.21.29;	author livesey;	state Exp;
branches;
next	2.104;

2.104
date	2001.04.20.23.34.54;	author livesey;	state Exp;
branches;
next	2.103;

2.103
date	2001.04.20.23.08.55;	author livesey;	state Exp;
branches;
next	2.102;

2.102
date	2001.04.20.02.59.40;	author livesey;	state Exp;
branches;
next	2.101;

2.101
date	2001.04.20.02.55.19;	author livesey;	state Exp;
branches;
next	2.100;

2.100
date	2001.04.19.23.55.04;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2001.04.19.22.24.09;	author livesey;	state Exp;
branches;
next	2.98;

2.98
date	2001.04.19.22.09.32;	author livesey;	state Exp;
branches;
next	2.97;

2.97
date	2001.04.19.20.59.50;	author livesey;	state Exp;
branches;
next	2.96;

2.96
date	2001.04.19.20.42.34;	author livesey;	state Exp;
branches;
next	2.95;

2.95
date	2001.04.19.20.31.14;	author livesey;	state Exp;
branches;
next	2.94;

2.94
date	2001.04.19.08.13.06;	author zvi;	state Exp;
branches;
next	2.93;

2.93
date	2001.04.19.06.46.35;	author zvi;	state Exp;
branches;
next	2.92;

2.92
date	2001.04.17.09.16.12;	author zvi;	state Exp;
branches;
next	2.91;

2.91
date	2001.04.17.01.01.34;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2001.04.13.23.29.36;	author livesey;	state Exp;
branches;
next	2.89;

2.89
date	2001.04.13.21.40.22;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2001.04.12.21.41.59;	author livesey;	state Exp;
branches;
next	2.87;

2.87
date	2001.04.12.17.48.31;	author livesey;	state Exp;
branches;
next	2.86;

2.86
date	2001.04.12.16.55.08;	author livesey;	state Exp;
branches;
next	2.85;

2.85
date	2001.04.12.01.50.02;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2001.04.11.02.09.46;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2001.04.11.01.18.37;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2001.04.11.00.50.06;	author livesey;	state Exp;
branches;
next	2.81;

2.81
date	2001.04.10.23.51.18;	author livesey;	state Exp;
branches;
next	2.80;

2.80
date	2001.04.10.23.15.55;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2001.04.10.22.04.16;	author livesey;	state Exp;
branches;
next	2.78;

2.78
date	2001.04.10.18.51.02;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2001.04.10.10.15.48;	author zvi;	state Exp;
branches;
next	2.76;

2.76
date	2001.04.10.02.46.16;	author livesey;	state Exp;
branches;
next	2.75;

2.75
date	2001.04.10.02.24.55;	author livesey;	state Exp;
branches;
next	2.74;

2.74
date	2001.04.10.01.16.10;	author livesey;	state Exp;
branches;
next	2.73;

2.73
date	2001.04.09.22.21.41;	author livesey;	state Exp;
branches;
next	2.72;

2.72
date	2001.04.09.21.05.40;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2001.04.09.20.51.03;	author zvi;	state Exp;
branches;
next	2.70;

2.70
date	2001.04.07.23.59.32;	author zvi;	state Exp;
branches;
next	2.69;

2.69
date	2001.04.07.23.49.54;	author zvi;	state Exp;
branches;
next	2.68;

2.68
date	2001.04.07.01.50.48;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2001.04.07.01.38.22;	author livesey;	state Exp;
branches;
next	2.66;

2.66
date	2001.04.06.21.53.40;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2001.04.05.23.02.31;	author zvi;	state Exp;
branches;
next	2.64;

2.64
date	2001.04.05.22.53.20;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2001.04.01.00.08.52;	author zvi;	state Exp;
branches;
next	2.62;

2.62
date	2001.03.31.01.49.45;	author zvi;	state Exp;
branches;
next	2.61;

2.61
date	2001.03.30.20.55.25;	author zvi;	state Exp;
branches;
next	2.60;

2.60
date	2001.03.30.03.05.49;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2001.03.30.02.45.23;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2001.03.30.01.45.08;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2001.03.30.00.36.57;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2001.03.30.00.07.36;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2001.03.29.23.56.49;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2001.03.29.23.42.55;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2001.03.29.22.07.16;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2001.03.29.12.11.16;	author zvi;	state Exp;
branches;
next	2.51;

2.51
date	2001.03.29.02.37.30;	author livesey;	state Exp;
branches;
next	2.50;

2.50
date	2001.03.29.01.21.25;	author zvi;	state Exp;
branches;
next	2.49;

2.49
date	2001.03.29.00.53.54;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2001.03.29.00.33.21;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2001.03.28.23.51.15;	author zvi;	state Exp;
branches;
next	2.46;

2.46
date	2001.03.28.22.41.10;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2001.03.28.22.00.10;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2001.03.28.21.22.22;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2001.03.28.01.31.39;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2001.03.28.01.31.16;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2001.03.28.00.39.15;	author zvi;	state Exp;
branches;
next	2.40;

2.40
date	2001.03.27.00.21.18;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2001.03.26.21.13.02;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2001.03.26.18.01.20;	author zvi;	state Exp;
branches;
next	2.37;

2.37
date	2001.03.25.00.50.31;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2001.03.24.00.33.38;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2001.03.24.00.32.56;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2001.03.23.23.55.54;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2001.03.23.19.00.14;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2001.03.22.01.01.12;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2001.03.21.02.14.01;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2001.03.21.01.10.09;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2001.03.21.01.07.45;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2001.03.20.23.25.54;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2001.03.20.11.03.43;	author zvi;	state Exp;
branches;
next	2.26;

2.26
date	2001.03.20.02.28.58;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2001.03.19.17.10.35;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.03.18.00.55.50;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.03.17.21.08.01;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.03.17.03.24.23;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2001.03.17.01.05.46;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.03.17.00.58.22;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.03.17.00.50.57;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.03.16.21.05.22;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.03.15.12.18.37;	author zvi;	state Exp;
branches;
next	2.16;

2.16
date	2001.03.13.00.43.12;	author zvi;	state Exp;
branches;
next	2.15;

2.15
date	2001.03.13.00.23.41;	author zvi;	state Exp;
branches;
next	2.14;

2.14
date	2001.03.09.02.46.15;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2001.03.09.02.27.20;	author zvi;	state Exp;
branches;
next	2.12;

2.12
date	2001.03.09.01.49.31;	author zvi;	state Exp;
branches;
next	2.11;

2.11
date	2001.03.09.01.08.07;	author zvi;	state Exp;
branches;
next	2.10;

2.10
date	2001.03.09.00.54.00;	author zvi;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.08.21.59.52;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.08.20.11.19;	author zvi;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.08.19.22.12;	author zvi;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.08.03.23.45;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.08.00.42.09;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.07.23.59.52;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.21.00.07.57;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.08.00.56.11;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.07.00.52.27;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.138
log
@Split up and renamed, FullForwardModel now in fwdmdl, other stuff now in ForwardModelSupport
@
text
@! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

!=============================================================================
module ForwardModelInterface
  !=============================================================================

  ! Set up the forward model.  Interface from the retrieve step to the
  ! forward model.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use ForwardModelConfig, only: AddForwardModelConfigToDatabase, Dump, &
    & ForwardModelConfig_T
  use Init_Tables_Module, only: FIELD_FIRST, FIELD_LAST
  use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR
  use Init_Tables_Module, only: F_ANTENNAPATTERNS, F_ATMOS_DER, F_CHANNELS, &
    & F_DO_CONV, F_DO_FREQ_AVG, F_FILTERSHAPES, F_FREQUENCY, F_FRQGAP,&
    & F_INTEGRATIONGRID, F_L2PC, F_MOLECULES, F_MOLECULEDERIVATIVES, F_PHIWINDOW, &
    & F_POINTINGGRIDS, F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, F_TYPE,&
    & F_MODULE, F_SKIPOVERLAPS
  use MLSCommon, only: R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate,&
     & MLSMSG_Error
  use MoreTree, only: Get_Boolean, Get_Field_ID
  use Output_M, only: Output
  use Parse_Signal_m, only: PARSE_SIGNAL
  use String_Table, only: Display_String, Get_String
  use Toggles, only: Emit, Gen, Levels, Switches, Toggle
  use Trace_M, only: Trace_begin, Trace_end
  use Tree, only: Decoration, Node_ID, Nsons, Source_Ref, Sub_Rosa, Subtree
  use Tree_Types, only: N_named
  use Units, only: Deg2Rad, PHYQ_FREQUENCY
  use VGridsDatabase, only: VGrid_T
  use PointingGrid_m, only: READ_POINTING_GRID_FILE, CLOSE_POINTING_GRID_FILE
  use L2PC_m, only: OPEN_L2PC_FILE, CLOSE_L2PC_FILE, READ_L2PC_FILE
  use AntennaPatterns_m, only: OPEN_ANTENNA_PATTERNS_FILE, READ_ANTENNA_PATTERNS_FILE,&
    & CLOSE_ANTENNA_PATTERNS_FILE
  use FilterShapes_m, only: OPEN_FILTER_SHAPES_FILE, READ_FILTER_SHAPES_FILE,&
    & CLOSE_FILTER_SHAPES_FILE
  use Expr_M, only: EXPR
  use Lexer_Core, only: PRINT_SOURCE
  use MLSNumerics, only: HUNT
  use PointingGrid_m, only: Close_Pointing_Grid_File, &
    & Open_Pointing_Grid_File, Read_Pointing_Grid_File


  implicit none
  private
  public :: ConstructForwardModelConfig, ForwardModelGlobalSetup

  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter, private :: IdParm = &
    & "$Id: ForwardModelInterface.f90,v 2.137 2001/05/29 23:09:59 livesey Exp $"
  character (len=len(idParm)) :: Id = IdParm
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: ForwardModelInterface.f90,v $"
  !---------------------------------------------------------------------------

  ! Error codes

  integer, parameter :: AllocateError        = 1
  integer, parameter :: BadMolecule          = AllocateError + 1
  integer, parameter :: DefineSignalsFirst   = BadMolecule + 1
  integer, parameter :: DefineMoleculesFirst = DefineSignalsFirst + 1
  integer, parameter :: IncompleteFullFwm    = DefineMoleculesFirst + 1
  integer, parameter :: IncompleteLinearFwm  = IncompleteFullFwm + 1
  integer, parameter :: IrrelevantFwmParameter = IncompleteLinearFwm + 1
  integer, parameter :: TangentNotSubset     =  IrrelevantFwmParameter + 1
  integer, parameter :: PhiWindowMustBeOdd   = TangentNotSubset + 1
  integer, parameter :: FrqGapNotFrq         = PhiWindowMustBeOdd + 1

  integer :: Error            ! Error level -- 0 = OK

contains ! =====     Public Procedures     =============================

  ! ------------------------------------  ForwardModelGlobalSetup  -----
  subroutine ForwardModelGlobalSetup ( Root )
    ! Process the forwardModel specification to produce ForwardModelInfo.

    integer, intent(in) :: Root         ! of the forwardModel specification.
    !                                     Indexes a "spec_args" vertex.

    integer :: I                        ! Loop inductor, subscript
    integer :: Lun                      ! Unit number for reading a file
    character(len=255) :: FileName      ! Duh
    integer :: Son                      ! Some subtree of root.

    ! Error message codes

    error = 0
    if ( toggle(gen) ) call trace_begin ( 'ForwardModelGlobalSetup', root )

    ! "Root" now indexes an n_spec_args vertex.  See "Configuration file
    ! parser users' guide" for pictures of the trees being analyzed.
    ! Collect data from the fields.

    do i = 2, nsons(root)
      son = subtree(i,root)
      select case ( get_field_id(son) )
      case ( f_antennaPatterns )
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        call open_antenna_patterns_file ( fileName, lun )
        call read_antenna_patterns_file ( lun )
        call close_antenna_patterns_file ( lun )
      case ( f_filterShapes )
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        call open_filter_shapes_file ( fileName, lun )
        call read_filter_shapes_file ( lun )
        call close_filter_shapes_file ( lun )
      case ( f_pointingGrids )
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        call open_pointing_grid_file ( fileName, lun )
        call read_pointing_grid_file ( lun )
        call close_pointing_grid_file ( lun )
      case ( f_l2pc )
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        call open_l2pc_file (fileName, lun)
        call read_l2pc_file ( lun )
        call close_l2pc_file ( lun )
      case default
        ! Can't get here if the type checker worked
      end select
    end do

    if ( toggle(gen) ) call trace_end ( 'ForwardModelGlobalSetup' )
  end subroutine ForwardModelGlobalSetup

  ! ------------------------------------------  ConstructForwardModelConfig  -----
  type (forwardModelConfig_T) function ConstructForwardModelConfig &
    & ( ROOT, VGRIDS ) result ( info )
    ! Process the forwardModel specification to produce ForwardModelConfig to add
    ! to the database
    use MLSSignals_M, only: Signals

    integer, intent(in) :: ROOT         ! of the forwardModel specification.
    !                                     Indexes either a "named" or
    !                                     "spec_args" vertex. Local variables
    type (vGrid_T), dimension(:), target :: vGrids ! vGrid database

    logical, dimension(:), pointer :: Channels   ! From Parse_Signal
    integer :: COMMONSIZE               ! Dimension
    integer :: Field                    ! Field index -- f_something
    logical :: Got(field_first:field_last)   ! "Got this field already"
    integer :: I                        ! Subscript and loop inductor.
    integer :: J                        ! Subscript and loop inductor.
    integer :: Key                      ! Indexes the spec_args vertex.
    integer :: Name                     ! sub_rosa of label of specification,
    ! if any, else zero.
    integer :: NoChannelsSpecs          ! Number of channel specs we've had
    integer :: SIDEBAND                 ! Returned from Parse_Signal
    integer, dimension(:), pointer :: SIGNALINDS ! From Parse_Signal
    character (len=80) :: SIGNALSTRING  ! E.g. R1A....
    integer :: Son                      ! Some subtree of root.
    integer :: STATUS                   ! From allocates etc.
    integer :: TANGENT                  ! Loop counter
    integer :: THISMOLECULE             ! Tree index.
    integer :: type                     ! Type of value returned by EXPR
    integer :: Units(2)                 ! Units of value returned by EXPR
    real (r8) :: Value(2)               ! Value returned by EXPR
    integer :: WANTED                   ! Which signal do we want?

    ! Error message codes

    ! Nullify some pointers so allocate_test doesn't try to deallocate them.
    ! Don't initialize them with =>NULL() because that makes them SAVEd.

    nullify ( channels, signalInds )

    error = 0
    if ( toggle(gen) ) call trace_begin ( "ConstructForwardModelConfig", root )
    if ( node_id(root) == n_named ) then
      name = subtree(1, root)
      key = subtree(2, root)
    else
      name = 0
      key = root
    end if

    ! Set sensible defaults
    info%do_conv = .false.
    info%do_freq_avg = .false.
    info%temp_der = .false.
    info%atmos_der = .false.
    info%spect_der = .false.
    info%skipOverlaps = .false.
    info%phiwindow = 5
    info%frqGap = 0.0                   ! Default to everything

    noChannelsSpecs=0

    ! "Key" now indexes an n_spec_args vertex.  See "Configuration file
    ! parser users' guide" for pictures of the trees being analyzed.

    got = .false.
    do i = 2, nsons(key)
      son = subtree(i,key)
      field = get_field_id(son)
      got(field) = .true.
      select case ( field )
      case ( f_type )
        info%fwmType = decoration(subtree(2,son))
      case ( f_atmos_der )
        info%atmos_der = get_boolean(son)
      case ( f_do_conv )
        info%do_conv = get_boolean(son)
      case ( f_do_freq_avg )
        info%do_freq_avg = get_boolean(son)
      case ( f_skipOverlaps )
        info%skipOverlaps = get_boolean(son)
      case ( f_frqGap )
        call expr ( subtree(2,son), units, value, type )
        info%frqGap = value(1)
        if ( units(1) /= phyq_frequency ) &
          & call AnnounceError ( frqGapNotFrq, key )
      case ( f_module )
        info%instrumentModule = decoration(decoration(subtree(2,son)))
      case ( f_molecules )
        call allocate_test ( info%molecules, nsons(son)-1, "info%molecules", &
          & ModuleName )
        call allocate_test ( info%moleculeDerivatives, nsons(son)-1, &
          & "info%moleculeDerivatives", ModuleName )
        info%moleculeDerivatives = .false.
        do j = 1, nsons(son)-1
          info%molecules(j) = decoration( subtree( j+1, son ) )
        end do                          ! End loop over listed signals
      case ( f_moleculeDerivatives )
        if ( .not. associated(info%molecules) ) then
          call announceError( DefineMoleculesFirst, key)
        else
          do j = 1, nsons(son)-1
            thisMolecule = decoration( subtree( j+1, son ) )
            if ( .not. any(info%molecules == thisMolecule ) ) &
              & call announceError( BadMolecule, key )
            where ( info%molecules == thisMolecule )
              info%moleculeDerivatives = .true.
            end where
          end do                          ! End loop over listed signals
        end if
      case ( f_signals )
        allocate ( info%signals (nsons(son)-1), stat = status )
        if ( status /= 0 ) call announceError( AllocateError, key )
        do j = 1, nsons(son)-1
          call get_string ( sub_rosa(subtree(j+1,son)), signalString, &
            & strip=.true.)
          call parse_Signal ( signalString, signalInds, &
            & tree_index=son, sideband=sideband, channels=channels )
          if ( .not. associated(signalInds) ) then ! A parse error occurred
            error = max(error,1)
            exit
          end if
          ! Later on choose the `right' one from the match
          ! For the moment choose first !????
          wanted=1
          info%signals(j) = signals(signalInds(wanted))
          info%signals(j)%sideband = sideband
          call allocate_Test ( info%signals(j)%channels, &
            & size(info%signals(j)%frequencies), 'info%signals%channels', &
            & ModuleName )
          if ( associated(channels) ) then
            info%signals(j)%channels(1:lbound(channels,1)-1) = .false.
            info%signals(j)%channels(lbound(channels,1):ubound(channels,1)) = &
              channels
            info%signals(j)%channels(ubound(channels,1)+1:) = .false.
          else
            info%signals(j)%channels = .true.
          end if
          call deallocate_test ( channels, 'channels', ModuleName )
          call deallocate_test ( signalInds, 'signalInds', ModuleName )
        end do                          ! End loop over listed signals
      case ( f_phiWindow )
        call expr ( subtree(2,son), units, value, type )
        info%phiWindow = nint( value(1) )
        if ( mod(info%phiWindow,2) /= 1 ) &
          & call AnnounceError ( phiWindowMustBeOdd, key )
      case ( f_spect_der )
        info%spect_der = get_boolean(son)
      case ( f_temp_der )
        info%temp_der = get_boolean(son)
      case ( f_integrationGrid )
        info%integrationGrid => vGrids(decoration(decoration(subtree(2,son))))
      case ( f_tangentGrid )
        info%tangentGrid => vGrids(decoration(decoration(subtree(2,son))))
      case default
        ! Shouldn't get here if the type checker worked
      end select

    end do ! i = 2, nsons(key)

    ! Now some more error checking
    select case ( info%fwmType )
    case ( l_full )
      if ( .not. all(got( (/ f_molecules, f_signals, f_integrationGrid, &
        & f_tangentGrid /) )) ) call AnnounceError ( IncompleteFullFwm, root )

      ! Now identify the Earth's surface in the tangent grid
      call Hunt(info%tangentGrid%surfs, info%integrationGrid%surfs(1), &
        &  info%surfaceTangentIndex)

      ! Ensure that points in tangentGrid at and above the surface are a subset
      ! of integration grid
      do tangent = info%surfaceTangentIndex, info%tangentGrid%noSurfs
        if ( .not. any ( abs(info%tangentGrid%surfs(tangent) - &
          & info%integrationGrid%surfs) < 1e-4) ) &
          & call AnnounceError ( TangentNotSubset, root )
      end do

      ! Check parameters needed only for linear/scan are not included
      !????
    case ( l_scan )
      ! Add 1d/2d method later probably !??? NJL
      if ( any(got( (/f_atmos_der, f_channels, f_do_conv, &
        & f_do_freq_avg, f_frequency, f_molecules, f_moleculeDerivatives, &
        & f_signals, f_spect_der, f_temp_der /) )) ) &
        & call AnnounceError ( IrrelevantFwmParameter, root )
    case ( l_linear)
      if ( .not. all(got( (/f_molecules, f_signals/) )) ) & ! Maybe others later
        & call AnnounceError ( IncompleteLinearFwm, root )
      if ( any(got( (/f_do_conv, f_do_freq_avg, f_frequency /) )) ) &
        & call AnnounceError ( IrrelevantFwmParameter, root )
    end select

    if ( error /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An error occured' )
    if ( toggle(gen) ) call trace_end ( "ConstructForwardModelConfig" )

  end function ConstructForwardModelConfig

  ! =====     Private Procedures     =====================================
  ! ----------------------------------------------  AnnounceError  -----
  subroutine AnnounceError ( Code, where, FieldIndex )
    integer, intent(in) :: Code       ! Index of error message
    integer, intent(in) :: where      ! Where in the tree did the error occur?
    integer, intent(in), optional :: FieldIndex ! f_...

    error = max(error,1)
    call output ( '***** At ' )
    call print_source ( source_ref ( where ) )
    call output ( ' ForwardModelSetup complained: ' )
    select case ( code )
    case ( AllocateError )
      call output ( 'allocation error.', advance='yes' )
    case ( BadMolecule )
      call output ( 'asked for derivatives for an unlisted molecule.', &
        & advance='yes' )
    case ( DefineMoleculesFirst )
      call output ( 'molecule must be defined before moleules derivatives.', &
        & advance='yes')
    case ( DefineSignalsFirst )
      call output ( 'signals must be defined before channels.',advance='yes')
    case ( IncompleteFullFwm )
      call output ('incomplete full foward model specification',advance='yes' )
    case ( IncompleteLinearFwm )
      call output ( 'incomplete linear foward model specification', &
        & advance='yes' )
    case ( IrrelevantFwmParameter )
      call output ( 'irrelevant parameter for this forward model type', &
        & advance='yes' )
    case ( TangentNotSubset )
      call output ('non subsurface tangent grid not a subset of integration&
        & grid', advance='yes' )
    case ( PhiWindowMustBeOdd )
      call output ( 'phiWindow is not odd', advance='yes' )
    case ( FrqGapNotFrq )
      call output ( 'frqGap does not have dimensions of frequency', advance='yes' )
    end select
  end subroutine AnnounceError

end module ForwardModelInterface

! $Log: ForwardModelInterface.f90,v $
! Revision 2.137  2001/05/29 23:09:59  livesey
! Last version, before being renamed! :-(
!
! Revision 2.136  2001/05/25 20:25:56  livesey
! Now optionally skips MAFs in overlap regions
!
! Revision 2.135  2001/05/21 23:58:10  livesey
! Moved some of the emits to higher numbers
!
! Revision 2.134  2001/05/17 01:44:16  livesey
! Bug fix for non frequency avg. case
!
! Revision 2.133  2001/05/17 00:49:54  livesey
! Interim version.  Slight problem somewhere with convolution for some bands.
!
! Revision 2.132  2001/05/16 23:03:59  livesey
! New version, now gets correct antenna pattern too.
!
! Revision 2.131  2001/05/16 01:20:08  livesey
! Interim version.  Does pointing grids and channel shapes right, not
! yet antenna patterns.  Also can do forward model with multiple signals
!
! Revision 2.130  2001/05/15 03:46:31  zvi
! Adding derivative flag to beta calculations
!
! Revision 2.129  2001/05/14 23:18:26  livesey
! Added frqGap parameter
!
! Revision 2.128  2001/05/11 22:18:56  livesey
! Changed first dimension of ifm%tan_dh_dt from nlvl to no_tan_hts.
! Also tidied up allocates of ifm stuff.
!
! Revision 2.127  2001/05/03 23:34:44  livesey
! More stuff to support scan model
!
! Revision 2.126  2001/05/03 20:31:34  vsnyder
! Thought I needed to add a nullify, ended up with only cosmetic changes
!
! Revision 2.125  2001/05/02 20:31:43  livesey
! Removed frequency from config
!
! Revision 2.124  2001/05/02 20:28:35  livesey
! Removed some dead variables.
!
! Revision 2.123  2001/04/28 17:47:42  livesey
! Passes row flags to convolve and no convolve
!
! Revision 2.122  2001/04/28 01:44:09  vsnyder
! Make debugging output conditional on toggle(emit) etc.
!
! Revision 2.121  2001/04/26 22:53:37  zvi
! Fixing some phiwindow bug
!
! Revision 2.120  2001/04/26 20:02:09  livesey
! Made l2pc database a saved array in L2PC_m
!
! Revision 2.119  2001/04/26 19:47:53  livesey
! Renamed main routine to full forward model
!
! Revision 2.118  2001/04/26 02:50:47  vsnyder
! Cosmetic changes
!
! Revision 2.117  2001/04/26 02:49:52  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic (again)
!
! Revision 2.116  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.115  2001/04/26 00:06:58  livesey
! Added l2pc reading to global setup
!
! Revision 2.114  2001/04/25 00:50:33  livesey
! Changed maxPath to maxVert, better name
!
! Revision 2.113  2001/04/25 00:09:48  vsnyder
! Use 'levels(emit)' to control output detail
!
! Revision 2.112  2001/04/24 23:11:04  vsnyder
! Use 'emit' toggle (set by -f option or @@E) to control output
!
! Revision 2.111  2001/04/24 19:44:48  vsnyder
! Add 'toggle(gen)' stuff in ForwardModel
!
! Revision 2.110  2001/04/24 00:03:36  livesey
! Bug fix
!
! Revision 2.109  2001/04/23 22:22:50  livesey
! Working version.  Can now have no_phi_t /= noMAFs
!
! Revision 2.108  2001/04/23 22:09:54  zvi
! Re-Introducing no_phi_t etc.
!
! Revision 2.107  2001/04/23 21:56:06  livesey
! Pass closest instances to comp_path_entities
!
! Revision 2.106  2001/04/23 21:42:46  zvi
! Introducing no_phi_t etc.
!
! Revision 2.105  2001/04/21 01:21:29  livesey
! Fixed memory leak properly!
!
! Revision 2.104  2001/04/20 23:34:54  livesey
! Fixed sideband code
!
! Revision 2.103  2001/04/20 23:08:55  livesey
! Cleaned up confusion in multi-channel cases
!
! Revision 2.102  2001/04/20 02:59:40  livesey
! Whoops typo!
!
! Revision 2.101  2001/04/20 02:55:19  livesey
! Now writes back derivatives in Jacobian!!! Not folded yet though,
! but that will be easy!
!
! Revision 2.100  2001/04/19 23:55:04  livesey
! Interim version, new convolve etc. but no derivatives
!
! Revision 2.99  2001/04/19 22:24:09  livesey
! More moving window stuff sorted out, now uses FindClosestInstance
!
! Revision 2.98  2001/04/19 22:09:32  livesey
! New calling sequence for comp_path_entities
!
! Revision 2.97  2001/04/19 20:59:50  livesey
! Reordered a loop
!
! Revision 2.96  2001/04/19 20:42:34  livesey
! Minor bug in calls to freq_avg fixed.  Going to change agains soon
! anyway
!
! Revision 2.95  2001/04/19 20:31:14  livesey
! Removed stuff that destroyed ifm (now upto calling code, e.g. in
! SidsModule) to do it.  Also added sideband folding loop, works
! for radiances, not derivatives yet.
!
! Revision 2.94  2001/04/19 08:13:06  zvi
! Some more leaks..
!
! Revision 2.92  2001/04/17 09:16:12  zvi
! Taking care of a whole buch of deallocation statements ..
!
! Revision 2.91  2001/04/17 01:01:34  vsnyder
! Add ??? Deallocated ??? comments
!
! Revision 2.90  2001/04/13 23:29:36  livesey
! Sorted out selection of appropriate pointing frequency grid.
!
! Revision 2.89  2001/04/13 21:40:22  vsnyder
! Replace pointing-grid stuff by STOP -- Nathaniel will fix it.
!
! Revision 2.88  2001/04/12 21:41:59  livesey
! Interim version.
!
! Revision 2.87  2001/04/12 17:48:31  livesey
! Moved maf increment to calling code, left finished flag here though.
!
! Revision 2.86  2001/04/12 16:55:08  livesey
! Fixed arguments to comp_path_entities
!
! Revision 2.85  2001/04/12 01:50:02  vsnyder
! Explicitly nullify instead of =>NULL()
!
! Revision 2.84  2001/04/11 02:09:46  vsnyder
! Handle 'Parse_Signal' error
!
! Revision 2.83  2001/04/11 01:18:37  vsnyder
! Check channel number range
!
! Revision 2.82  2001/04/11 00:50:06  livesey
! Another interim version, the `moving window' is better implemented
!
! Revision 2.81  2001/04/10 23:51:18  livesey
! Another working version.  More temporary arrays now alloctable/pointer
!
! Revision 2.80  2001/04/10 23:15:55  livesey
! Reverse communication seems to be working. Needs a bit more tidying up though.
!
! Revision 2.79  2001/04/10 22:04:16  livesey
! Intermediate version, slight problem with signals.
!
! Revision 2.78  2001/04/10 18:51:02  vsnyder
! Finish removing sideband stuff
!
! Revision 2.77  2001/04/10 10:15:48  zvi
! fixing bug conneced with convolve
!
! Revision 2.76  2001/04/10 02:46:16  livesey
! Working version, no more FMI/TFMI
!
! Revision 2.75  2001/04/10 02:24:55  livesey
! Stable derivative code, still not sure about vmr.  About to remove FMI, TFMI!!  :-)
!
! Revision 2.74  2001/04/10 01:16:10  livesey
! Another interim version.
!
! Revision 2.73  2001/04/09 22:21:41  livesey
! An interim version, derivatives get right numbers.
!
! Revision 2.72  2001/04/09 21:05:40  vsnyder
! Remove unneeded explicit conversion to double
!
! Revision 2.71  2001/04/09 20:51:03  zvi
! Debugging Derivatives version
!
! Revision 2.70  2001/04/07 23:59:32  zvi
! Ellimination the second dimension from ptg_angles (not MAF dependant)
!
! Revision 2.69  2001/04/07 23:49:54  zvi
! Code modified to do spsfunc & refraction inside the MAF loop
!
! Revision 2.68  2001/04/07 01:50:48  vsnyder
! Move some of VGrid to lib/VGridsDatabase.  Move FwdModelConf_T and
! some related stuff to fwdmdl/FwdModelConf.
!
! Revision 2.67  2001/04/07 01:38:22  livesey
! Another interim working version
!
! Revision 2.66  2001/04/06 21:53:40  vsnyder
! Move duplicate-field checking to init_tables
!
! Revision 2.65  2001/04/05 23:02:31  zvi
! Implementing Anntena, FilterShape & Spectroscopy l2cf inputs instead of FMI
!
! Revision 2.64  2001/04/05 22:53:20  vsnyder
! Use AntennaPatterns_m
!
! Revision 2.63  2001/04/01 00:08:52  zvi
! *** empty log message ***
!
! Revision 2.62  2001/03/31 01:49:45  zvi
! *** empty log message ***
!
! Revision 2.61  2001/03/30 20:55:25  zvi
! Remove the need for COMMON BLOCK..(ELLIPSE)
!
! Revision 2.60  2001/03/30 03:05:49  vsnyder
! Add 'antennaPatterns' field to 'forwardModelGlobal'
!
! Revision 2.59  2001/03/30 02:45:23  livesey
! Numbers agree again, was velocity.
!
! Revision 2.58  2001/03/30 01:45:08  livesey
! Some changes and debug stuff, still no agreement.
!
! Revision 2.57  2001/03/30 00:36:57  livesey
! Interim version, doesn't quite get the same numbers as Zvi, but we
! think we know why.
!
! Revision 2.56  2001/03/30 00:07:36  livesey
! Removed more FMC/TFMI stuff
!
! Revision 2.55  2001/03/29 23:56:49  livesey
! Added phi Window
!
! Revision 2.54  2001/03/29 23:42:55  vsnyder
! Add 'filterShapes' field to forwardModelGlobal
!
! Revision 2.53  2001/03/29 22:07:16  livesey
! Added phiWindow
!
! Revision 2.52  2001/03/29 12:11:16  zvi
! Fixing Bug seeting surface index erroniously
!
! Revision 2.51  2001/03/29 02:37:30  livesey
! Modified convolution to use new grids
!
! Revision 2.50  2001/03/29 01:21:25  zvi
! Interim version
!
! Revision 2.49  2001/03/29 00:53:54  livesey
! Modified error message.
!
! Revision 2.48  2001/03/29 00:33:21  livesey
! Added some error checking for tangentGrid
!
! Revision 2.47  2001/03/28 23:51:15  zvi
! Tanget below surface are in Zeta units
!
! Revision 2.46  2001/03/28 22:41:10  livesey
! Got rid of a print statement that was annoying zvi
!
! Revision 2.45  2001/03/28 22:00:10  livesey
! Interim version, now uses more allocatables etc.
!
! Revision 2.44  2001/03/28 21:22:22  vsnyder
! Use Deg2Rad from Units
!
! Revision 2.43  2001/03/28 01:31:39  livesey
! Got rid of a dump statement
!
! Revision 2.42  2001/03/28 01:31:16  livesey
! Got convolution working.
!
! Revision 2.41  2001/03/28 00:39:15  zvi
! Fixing up the convolution call
!
! Revision 2.40  2001/03/27 00:21:18  livesey
! Got frequency averaging working.
!
! Revision 2.39  2001/03/26 21:13:02  livesey
! Stableish version, frequency averaging still highly suspect.
!
! Revision 2.38  2001/03/26 18:01:20  zvi
! New code to deal with dh_dt_path being computed on the fly
!
! Revision 2.37  2001/03/25 00:50:31  livesey
! Interim version, bug with frequency averaging
!
! Revision 2.36  2001/03/24 00:33:38  livesey
! Bug fix (Typo)
!
! Revision 2.35  2001/03/24 00:32:56  livesey
! Modified use of FMI%f_grid_filter
!
! Revision 2.34  2001/03/23 23:55:54  livesey
! Another interim version.  Frequency averaging doesn't crash but
! produces bad numbers. Note that the handling of k_... when passed to
! the convolution (or noconvolution) routine is highly nefarious.
!
! Revision 2.33  2001/03/23 19:00:14  livesey
! Interim version, tidied some stuff up, still gets same numbers as Zvi
!
! Revision 2.32  2001/03/22 01:01:12  livesey
! Interim version, no rights radiances out to a vector.
!
! Revision 2.31  2001/03/21 02:14:01  livesey
! Interim version mr_f in, but not quite working yet.
!
! Revision 2.30  2001/03/21 01:10:09  livesey
! Interim version before dealing with mr_f
!
! Revision 2.29  2001/03/21 01:07:45  livesey
! Before moving away from mr_f
!
! Revision 2.28  2001/03/20 23:25:54  livesey
! Copied changes from Zvi
!
! Revision 2.27  2001/03/20 11:03:43  zvi
! Fixing code, increase dim. etc.
!
! Revision 2.26  2001/03/20 02:28:58  livesey
! Interim version, gets same numbers as Zvi
!
! Revision 2.25  2001/03/19 17:10:35  livesey
! Added more checks etc.
!
! Revision 2.24  2001/03/18 00:55:50  livesey
! Interim version
!
! Revision 2.23  2001/03/17 21:08:01  livesey
! Added forward model type stuff to FwdModelConf_T and parser thereof
!
! Revision 2.22  2001/03/17 03:24:23  vsnyder
! Work on forwardModelGlobalSetup
!
! Revision 2.21  2001/03/17 01:05:46  livesey
! OK, I've sorted it out, but problems may remain in forwardmodelglobalsetup
!
! Revision 2.20  2001/03/17 00:58:22  livesey
! Fixed bug in previous commit, have had to comment out line 139 to
! let it compile.
!
! Revision 2.19  2001/03/17 00:50:57  livesey
! New fwdModelConf stuff and merge from Van
!
! Revision 2.18  2001/03/16 21:05:22  vsnyder
! Move dumping of pointing grid database to PointingGrid_m
!
! Revision 2.17  2001/03/15 12:18:37  zvi
! Adding the velocity effect on line center frequency
!
! Revision 2.16  2001/03/13 00:43:12  zvi
! *** empty log message ***
!
! Revision 2.15  2001/03/13 00:23:41  zvi
! Correction to no_tan_hts for hydrostatic_model repeating calls
!
! Revision 2.14  2001/03/09 02:46:15  vsnyder
! Make sure "io" has a value
!
! Revision 2.13  2001/03/09 02:27:20  zvi
! *** empty log message ***
!
! Revision 2.12  2001/03/09 01:49:31  zvi
! *** empty log message ***
!
! Revision 2.11  2001/03/09 01:08:07  zvi
! *** empty log message ***
!
! Revision 2.10  2001/03/09 00:54:00  zvi
! *** empty log message ***
!
! Revision 2.9  2001/03/08 21:59:52  vsnyder
! Mostly just cosmetic rearranging
!
! Revision 2.8  2001/03/08 20:11:19  zvi
! *** empty log message ***
!
! Revision 2.7  2001/03/08 19:22:12  zvi
! New ForwardModelInterface with Zvi's code in it ..
!
! Revision 2.6  2001/03/08 03:23:45  vsnyder
! More stuff to work with L2_Load
!
! Revision 2.5  2001/03/08 00:42:09  vsnyder
! Add temporary stuff to use with L2_Load
!
! Revision 2.4  2001/03/07 23:59:52  vsnyder
! Add stuff for SIDS.
!
! Revision 2.3  2001/02/21 00:07:57  vsnyder
! Periodic commit.  Still needs a lot of work.
!
! Revision 2.2  2001/02/08 00:56:11  vsnyder
! Periodic commit.  Still needs a lot of work.
!
! Revision 2.1  2001/02/07 00:52:27  vsnyder
! Initial commit
@


2.137
log
@Last version, before being renamed! :-(
@
text
@d53 1
a53 1
    & "$Id: ForwardModelInterface.f90,v 2.136 2001/05/25 20:25:56 livesey Exp $"
d371 3
@


2.136
log
@Now optionally skips MAFs in overlap regions
@
text
@a11 6
  use AntennaPatterns_m, only: AntennaPatterns
  use AntennaPatterns_m, only: Close_Antenna_Patterns_File, &
    & Open_Antenna_Patterns_File, Read_Antenna_Patterns_File
  use Declaration_Table, only: NUM_VALUE, RANGE
  use Dump_0, only: Dump
  use Expr_M, only: EXPR
a13 7
  use ForwardModelIntermediate, only: ForwardModelIntermediate_T, ForwardModelStatus_T
  use SpectroscopyCatalog_m, only: Catalog_T, Lines, Catalog
  use FilterShapes_m, only: Close_Filter_Shapes_File, &
    & Open_Filter_Shapes_File, Read_Filter_Shapes_File, FilterShapes
  ! We're going to use lots of things from init_tables_module, so let's sort
  ! them into some sort of order
  ! First admin stuff
d15 1
a15 1
  ! Now fields
a20 10
  ! Now literals
  use Init_Tables_Module, only: L_CHANNEL, L_EARTHREFL, L_ELEVOFFSET, L_FULL, &
    & L_LINEAR, L_LOSVEL, L_NONE, L_ORBITINCLINE, L_PTAN, L_RADIANCE,&
    & L_REFGPH, L_SCAN, L_SCGEOCALT, L_SIDEBANDRATIO, L_SPACERADIANCE, &
    & L_TEMPERATURE, L_VMR
  ! That's it for Init_Tables_Module
  use Lexer_Core, only: Print_Source
  use L2PC_M, only: OPEN_L2PC_FILE, READ_L2PC_FILE, CLOSE_L2PC_FILE
  use ManipulateVectorQuantities, only: FindClosestInstances
  use MatrixModule_1, only: Matrix_Database_T, Matrix_T
d23 1
a23 5
    & MLSMSG_Error
  use MLSNumerics, only: Hunt
  use MLSSignals_m, only: ARESIGNALSSUPERSET, GetSignal, MaxSigLen, Signal_T, GetSignalName,&
    & MATCHSIGNAL, DUMP
  use Molecules, only: spec_tags
a26 2
  use PointingGrid_m, only: Close_Pointing_Grid_File, &
    & Open_Pointing_Grid_File, Read_Pointing_Grid_File, PointingGrids
a32 2
  use VectorsModule, only: GetVectorQuantityByType, ValidateVectorQuantity, &
    & Vector_T, VectorValue_T
d34 12
d49 1
a49 2
  public :: ConstructForwardModelConfig, FullForwardModel, &
    ForwardModelGlobalSetup
d53 1
a53 1
    & "$Id: ForwardModelInterface.f90,v 2.135 2001/05/21 23:58:10 livesey Exp $"
a327 1106
  ! -----------------------------------------------  ForwardModel  -----
  subroutine FullForwardModel ( FwdModelConf, FwdModelIn, FwdModelExtra, &
    &                       FwdModelOut, Ifm, FmStat, Jacobian )

    use GL6P, only: NG
    use MLSCommon, only: I4, R4, R8
    use L2PC_PFA_STRUCTURES, only: K_MATRIX_INFO
    use ELLIPSE_M, only: ELLIPSE
    use COMP_PATH_ENTITIES_M, only: COMP_PATH_ENTITIES
    use GET_PATH_SPSFUNC_NGRID_M, only: GET_PATH_SPSFUNC_NGRID
    use REFRACTION_M, only: REFRACTION_CORRECTION
    use PATH_ENTITIES_M, only: PATH_INDEX, PATH_VECTOR, PATH_BETA, &
      PATH_DERIVATIVE, PATH_VECTOR_2D
    use HYDROSTATIC_MODEL_M, only: HYDROSTATIC_MODEL
    use GET_CHI_ANGLES_M, only: GET_CHI_ANGLES
    use GET_BETA_PATH_M, only: GET_BETA_PATH
    use GEOC_GEOD_CONV_M, only: GEOC_GEOD_CONV
    use RAD_TRAN_M, only: RAD_TRAN
    use RAD_TRAN_WD_M, only: RAD_TRAN_WD
    use FREQ_AVG_M, only: FREQ_AVG
    use CONVOLVE_ALL_M, only: CONVOLVE_ALL
    use NO_CONV_AT_ALL_M, only: NO_CONV_AT_ALL
    use D_LINTRP_M, only: LINTRP
    use D_HUNT_M, only: hunt_zvi => HUNT

    ! Dummy arguments --------------------------------------------------------

    ! From ForwardModelSetup
    type(forwardModelConfig_T), intent(inout) :: fwdModelConf
    type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
    type(vector_T), intent(inout) :: FwdModelOut  ! Radiances, etc.
    type(forwardModelIntermediate_T), intent(inout) :: Ifm ! Workspace
    type(forwardModelStatus_t), intent(inout) :: FmStat ! Reverse comm. stuff
    type(matrix_T), intent(inout), optional :: Jacobian

    ! Local parameters ---------------------------------------------------------

    character, parameter :: INVALIDQUANTITY = "Invalid vector quantity for "

    ! Local variables ----------------------------------------------------------

    ! First the old stuff which we hope to get rid of or redefine
    integer(i4) :: brkpt, ch, frq_i, i, ier, ihi, ilo, j, k, lmax, m, maf, &
      max_phi_dim, max_zeta_dim, mid, n, no_ele, no_tan_hts, &
      ptg_i, si, Spectag

    !    real(r4) :: K_STAR_ALL(25,20,mxco,mnp,Nptg)
    !    type(k_matrix_info) :: K_star_info(20)


    type(path_derivative) :: K_temp_frq
    type(path_derivative), allocatable, dimension(:) :: K_atmos_frq

    type(path_beta), dimension(:,:), pointer :: Beta_path

    real(r8) :: Frq, Geod_lat, H_tan, Phi_tan, Rad

    ! This is the `legit stuff' we hope will stay; they are all pointers to
    ! VectorValue_T's containing vector quantities.
    type (VectorValue_T), pointer :: EARTHREFL     ! Earth reflectivity
    type (VectorValue_T), pointer :: ELEVOFFSET    ! Elevation offset quantity
    type (VectorValue_T), pointer :: F             ! An arbitrary species
    type (VectorValue_T), pointer :: LOSVEL        ! Line of sight velocity
    type (VectorValue_T), pointer :: ORBINCLINE    ! Orbital inclination (beta)
    type (VectorValue_T), pointer :: PTAN          ! PTAN quantity
    type (VectorValue_T), pointer :: FIRSTRADIANCE ! One radiance quantity to be filled
    type (VectorValue_T), pointer :: THISRADIANCE ! One radiance quantity to be filled
    type (VectorValue_T), pointer :: REFGPH        ! Reference GPH, (zRef and hRef)
    type (VectorValue_T), pointer :: SCGEOCALT     ! Geocentric spacecraft altitude
    type (VectorValue_T), pointer :: SIDEBANDRATIO ! Sideband ratio for radiance
    type (VectorValue_T), pointer :: SPACERADIANCE ! Space radiance
    type (VectorValue_T), pointer :: TEMP          ! Temperature quantity

    integer :: CHANNEL                  ! Loop counter
    integer :: INSTANCE                 ! Loop counter
    integer :: MAFTINSTANCE             ! Temperature instance closest to this MAF
    integer :: MAXNOFREQS               ! Used for sizing arrays
    integer :: MAXNOFSURFS              ! Max. no. surfaces for any molecule
    integer :: MAXSUPERSET              ! Max. value of superset
    integer :: MAXVERT                  ! Number of points in gl grid
    integer :: N2LVL                    ! Twice size of tangent grid
    integer :: NLVL                     ! Size of tangent grid
    integer :: NOFREQS                  ! Number of frequencies for a pointing
    integer :: NOMAFS                   ! Number of major frames
    integer :: NOMIFS                   ! Number of minor frames
    integer :: NOSPECIES                ! Number of molecules we're considering
    integer :: NOUSEDCHANNELS           ! Number of channels to output
    integer :: NO_PHI_T                 ! No. of Temp. profiles in the chunk
    integer :: PHIWINDOW                ! Copy of forward model config%phiWindow
    integer :: SHAPEIND                 ! Index into filter shapes
    integer :: SIDEBANDSTART            ! Loop limit
    integer :: SIDEBANDSTEP             ! Loop step
    integer :: SIDEBANDSTOP             ! Loop limit
    integer :: SIGIND                   ! Loop counter
    integer :: SPECIE                   ! Loop counter
    integer :: STATUS                   ! From allocates etc.
    integer :: SURFACE                  ! Loop counter
    integer :: THISSIDEBAND             ! Loop counter
    integer :: TOTALSIGNALS             ! Used when hunting for pointing grids
    integer :: WHICHPATTERN             ! Index of antenna pattern
    integer :: WHICHPOINTINGGRID        ! Index of pointing grid
    integer :: WINDOWFINISH             ! Range of window
    integer :: WINDOWSTART              ! Range of window

    real (r8) :: CENTERFREQ             ! Of band
    real (r8) :: CENTER_ANGLE           ! For angles
    real (r8) :: R                      ! To convert the kind of output from
    !                                     Freq_Avg
    real (r8) :: THISRATIO              ! A sideband ratio

    integer, dimension(:), pointer :: CHANNELINDEX ! E.g. 1..25
    integer, dimension(:), pointer :: GRIDS ! Frq grid for each tan_press
    integer, dimension(:), pointer :: SUPERSET ! Result of AreSignalsSuperset
    integer, dimension(:), pointer :: USEDCHANNELS ! Array of indices used
    integer, dimension(:), pointer :: USEDSIGNALS ! Array of indices used

    logical :: FOUNDINFIRST                     ! Flag to indicate derivatives

    real(r8), dimension(:,:),   pointer :: D2X_DXDT    ! (No_tan_hts, Tsurfs)
    real(r8), dimension(:,:,:), pointer :: DH_DT_PATH  ! (pathSize, Tsurfs, Tinstance)
    real(r8), dimension(:), allocatable :: Dum
    real(r8), dimension(:,:),   pointer :: DX_DT       ! (No_tan_hts, Tsurfs)
    real(r8), dimension(:),     pointer :: FREQUENCIES ! Frequency points
    real(r8), dimension(:,:),   pointer :: I_STAR_ALL    ! (noMIFs,noChans)
    real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS ! (channel,Nptg,mxco,mnp,Nsps)
    real(r4), dimension(:,:,:,:), pointer :: K_TEMP    ! (channel,Nptg,mxco,mnp)
    real(r8), dimension(:),     pointer :: PTG_ANGLES  ! (no_tan_hts)
    real(r8), dimension(:,:),   pointer :: RADIANCES     ! (Nptg,noChans)
    real(r8), dimension(:),     pointer :: RadV
    real(r8), dimension(:,:),   pointer :: REF_CORR    ! (n2lvl, no_tan_hts)
    real(kind(k_temp_frq%values)), &
      & dimension(:), pointer :: TOAVG ! Stuff to be passed to frq.avg.
    real(r8), dimension(:),     pointer :: T_SCRIPT    ! (n2lvl)
    real(r8), dimension(:),     pointer :: TAU         ! (n2lvl)

    integer, dimension(1) :: WHICHPOINTINGGRIDASARRAY ! Result of minloc
    integer, dimension(1) :: WHICHPATTERNASARRAY ! Result of minloc

    type(path_vector), dimension(:), allocatable :: N_PATH    ! (No_tan_hts)

    ! dimensions of SPSFUNC_PATH are: (Nsps,No_tan_hts)
    type(path_vector), allocatable, dimension(:,:) :: SPSFUNC_PATH
    type(signal_t) :: FirstSignal
    type(signal_t) :: ThisSignal
    type(catalog_T), dimension(:), pointer :: My_Catalog

    ! Executable code --------------------------------------------------------

    if ( toggle(emit) ) call trace_begin ( 'ForwardModel' )

    ! Nullify a bunch of pointers so that Allocate_Test doesn't try to
    ! deallocate them.  We don't want them to be initialized NULL()
    ! because that makes them SAVEd.

    nullify (beta_path, channelIndex, d2x_dxdt, dh_dt_path, dx_dt, &
      & frequencies, grids, i_star_all, k_atmos, k_temp, my_Catalog, &
      & ptg_angles, radiances, radV, ref_corr, superset, t_script, &
      & tau, usedChannels, usedSignals )

    ! Identify the vector quantities we're going to need.
    ! The key is to identify the signal we'll be working with first
    firstSignal = fwdModelConf%signals(1)

    ! Now make sure all the signals we're dealing with are same module,
    ! radiometer and sideband.
    if ( any( fwdModelConf%signals%sideband .ne. &
      & firstSignal%sideband ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed sidebands in forward model config")
    if ( any( fwdModelConf%signals%radiometer .ne. &
      & firstSignal%radiometer ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed radiometers in forward model config")

    ! Now from that we identify the radiance quantity we'll be outputting
    firstRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
      & signal=firstSignal%index, sideband=firstSignal%sideband )

    ! Identify the appropriate state vector components, save vmrs for later
    temp => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_temperature )
    ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ptan, instrumentModule=firstSignal%instrumentModule )
    elevOffset => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_elevOffset, radiometer=firstSignal%radiometer )
    orbIncline => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_orbitIncline )
    spaceRadiance => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_spaceRadiance )
    earthRefl => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_earthRefl )
    refGPH => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_refGPH )
    losVel => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_losVel, instrumentModule=firstSignal%instrumentModule )
    scGeocAlt => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_scGeocAlt )
    sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_sidebandRatio, signal= firstSignal%index, noError=.true. )

    ! We won't seek for molecules here as we can't have an array of pointers.
    ! When we do want molecule i we would do something like
    ! vmr => GetVectorQuantityBytype (fwdModelIn, fwdModelExtra, &
    !   quantityType=l_vmr, molecule=fwdModelConf.molecules(i))

    ! Now we're going to validate the quantities we've been given, don't forget
    ! we already know what their quantityType's are as that's how we found them
    !, so we don't need to check that.
    if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'temperature' )
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'ptan' )
    if ( .not. ValidateVectorQuantity(elevOffset, verticalCoordinate=(/l_none/), &
      & frequencyCoordinate=(/l_none/), noInstances=(/1/)) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & InvalidQuantity//'elevOffset' )
    ! There will be more to come here.

    noSpecies = size(fwdModelConf%molecules)

    !  Create a subset of the catalog composed only of those molecules to be
    !  used for this run

    maxNoFSurfs = 0
    do specie = 1, noSpecies
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )
      maxNoFSurfs = max(maxNoFSurfs, f%template%noSurfs)
    end do

    allocate ( My_Catalog(noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'my_catalog' )

    do j = 1, noSpecies
      Spectag = spec_tags(fwdModelConf%molecules(j))
      do i = 1, Size(Catalog)
        if ( Catalog(i)%Spec_Tag == Spectag ) then
          My_Catalog(j) = Catalog(i)
          exit
        end if
      end do
    end do

    ! Get the max. dimension in zeta coeff. space and phi coeff. space
    ! (To be used later in rad_tran_wd, for automatic arrays asignement)
    max_phi_dim = 1
    max_zeta_dim = 1
    if ( FwdModelConf%temp_der ) then
      max_zeta_dim = temp%template%noSurfs
      max_phi_dim = temp%template%noInstances
    end if

    if ( fwdModelConf%atmos_der ) then
      do k = 1, noSpecies
        if ( fwdModelConf%moleculeDerivatives(k) ) then
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            &     quantityType=l_vmr, molecule=fwdModelConf%molecules(k))
          j = f%template%noInstances
          max_phi_dim = max(max_phi_dim,j)
          j = f%template%noSurfs
          max_zeta_dim = max(max_zeta_dim,j)
        end if
      end do
    end if

    ! Deal with fmStat%rows
    if ( present(Jacobian) .and. ( .not. associated (fmStat%rows) ) ) then
      call Allocate_test ( fmStat%rows, Jacobian%row%nb, 'fmStat%rows', &
        & ModuleName)
      fmStat%rows = .false.
    endif

    ! Get some dimensions that we'll use a lot
    noMAFs = firstRadiance%template%noInstances
    noMIFs = firstRadiance%template%noSurfs
    no_phi_t = temp%template%noInstances
    no_tan_hts = FwdModelConf%TangentGrid%nosurfs
    maxVert = 2 * (NG+1) * size(FwdModelConf%integrationGrid%surfs)
    nlvl=size(FwdModelConf%integrationGrid%surfs)
    n2lvl=2*nlvl
    phiWindow = FwdModelConf%phiWindow

    if ( toggle(emit) ) then
      print*,'Dimensions:'
      print*,'noMAFs:',noMAFs
      print*,'no_phi_t:',no_phi_t
      print*,'no_tan_hts:',no_tan_hts
      print*,'maxVert:',maxVert
      print*,'nlvl:',nlvl
      print*,'n2lvl:',n2lvl
      print*,'phiWindow:',phiWindow
      print*,'noSpecies:',noSpecies
      print*,'maxNoFSurfs:',maxNoFSurfs
      print*,'MAF:',fmStat%maf
    end if

    ! Work out which channels are used, also check we have radiances for them.
    noUsedChannels = 0
    do sigInd = 1, size(fwdModelConf%signals)
      thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
        & signal=fwdModelConf%signals(sigInd)%index, sideband=firstSignal%sideband )
      if ( .not. ValidateVectorQuantity(thisRadiance, minorFrame=.true.,&
        & frequencyCoordinate=(/l_channel/)) ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, InvalidQuantity//'radiance' )
      noUsedChannels = noUsedChannels + &
        & count( fwdModelConf%signals(sigInd)%channels )
    end do
    call allocate_test ( usedChannels, noUsedChannels, &
      & 'usedChannels', ModuleName )
    call allocate_test ( usedSignals, noUsedChannels, &
      & 'usedSignals', ModuleName )
    channel = 1
    do sigInd = 1, size(fwdModelConf%signals)
      do i = 1, size(fwdModelConf%signals(sigInd)%frequencies)
        if (fwdModelConf%signals(sigInd)%channels(i)) then
          usedChannels(channel) = i
          usedSignals(channel) = sigInd
          channel = channel + 1
        end if
      end do
    end do

    ! --------------- Hydrostatic stuff ---------------------------------
    if ( fmStat%newHydros ) then

      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_begin ( 'ForwardModel.hydrostatic' )

      ! Now we're going to create the many temporary arrays we need
      allocate ( ifm%ndx_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'ndx_path' )
      allocate ( ifm%dhdz_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'dhdz_path' )
      allocate ( ifm%h_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'h_path' )
      allocate ( ifm%phi_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'phi_path' )
      allocate ( ifm%t_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'t_path' )
      allocate ( ifm%z_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'z_path' )

      allocate ( ifm%eta_phi(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'eta_phi' )

      allocate ( ifm%elvar(no_phi_t), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'elvar' )

      call allocate_test ( ifm%geoc_lat, no_phi_t, 'geoc_lat', ModuleName )
      call allocate_test ( ifm%e_rad, no_phi_t, 'e_rad', ModuleName )

      call allocate_test ( ifm%z_glgrid, maxVert/2, 'z_glgrid', ModuleName )
      call allocate_test ( ifm%h_glgrid, maxVert, no_phi_t, 'h_glgrid', &
        &  ModuleName )
      call allocate_test ( ifm%t_glgrid, maxVert, no_phi_t, 't_glgrid', &
        &  ModuleName )
      call allocate_test ( ifm%dh_dt_glgrid, maxVert, no_phi_t, &
        & temp%template%noSurfs,'dh_dt_glgrid', ModuleName )
      call allocate_test ( ifm%dhdz_glgrid, maxVert, no_phi_t, &
        &  'dhdz_glgrid', ModuleName )
      call allocate_test ( ifm%tan_hts, no_tan_hts, no_phi_t, 'tan_hts', &
        &  ModuleName )
      call allocate_test ( ifm%tan_temp, no_tan_hts, no_phi_t, 'tan_hts', &
        &  ModuleName )
      call allocate_test ( ifm%tan_dh_dt, no_tan_hts, no_phi_t, &
        & temp%template%noSurfs, 'tan_dh_dt', ModuleName )
      call Allocate_test( ifm%closestInstances, noMAFs, 'closestInstances', ModuleName)

      ! Setup for hydrostatic calculation
      call FindClosestInstances ( temp, firstRadiance, ifm%closestInstances )

      do i = 1, no_phi_t
        phi_tan = Deg2Rad*temp%template%phi(1,i)
        geod_lat= Deg2Rad*temp%template%geodLat(1,i)
        call geoc_geod_conv ( ifm%elvar(i), orbIncline%values(1,1), &
          &  phi_tan, geod_lat, ifm%geoc_lat(i), ifm%E_rad(i) )
      end do

      ! Now compute a hydrostatic grid given the temperature and refGPH
      ! information.
      call hydrostatic_model ( FwdModelConf%SurfaceTangentIndex, &
        &  no_phi_t, ifm%geoc_lat, 0.001*refGPH%values(1,:), &
        &  refGPH%template%surfs(1,1), &
        &  FwdModelConf%integrationGrid%surfs, &
        &  temp%template%surfs(:,1), temp%values, &
        &  ifm%z_glgrid, ifm%h_glgrid, ifm%t_glgrid, &
        &  ifm%dhdz_glgrid, ifm%dh_dt_glgrid, &
        &  FwdModelConf%TangentGrid%surfs, &
        &  ifm%tan_hts, ifm%tan_temp, ifm%tan_dh_dt, &
        &  ifm%gl_count, Ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Hydrostatic model failed' )

      ! Now compute stuff along the path given this hydrostatic grid.
      call comp_path_entities ( temp, ifm%closestInstances, &
        &  FwdModelConf%integrationGrid%noSurfs, &
        &  temp%template%noSurfs, ifm%gl_count, ifm%ndx_path, ifm%z_glgrid, &
        &  ifm%t_glgrid, ifm%h_glgrid, ifm%dhdz_glgrid, ifm%tan_hts,        &
        &  no_tan_hts, ifm%z_path, ifm%h_path, ifm%t_path, ifm%phi_path,    &
        &  ifm%dhdz_path, ifm%eta_phi, no_phi_t,                            &
        &  temp%template%phi(1,:)*Deg2Rad, noMAFs, phiWindow, ifm%elvar, Ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Hydrostatic model failed' )

      fmStat%newHydros = .false.

      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.hydrostatic' )
    end if

    ! ------ End of hydrostatic setup stuff --------------------------

    ! Skip this MAF if it's in an overlap region possibly
    maf=fmStat%maf
    if ( (.not. fwdModelConf%skipOverlaps) .or. &
      & ( maf > firstRadiance%template%noInstancesLowerOverlap .and. &
      &   maf <= noMAFs - firstRadiance%template%noInstancesUpperOverlap ) ) then

      ! ------ Begin main MAF Specific stuff ---------------------------

      ! Now allocate other stuff
      call allocate_test ( t_script, n2lvl, 't_srcipt', ModuleName )
      call allocate_test ( ref_corr, n2lvl, no_tan_hts, 'ref_corr', ModuleName )
      call allocate_test ( tau, n2lvl, 'tau', ModuleName )
      call allocate_test ( ptg_angles, no_tan_hts, 'ptg_angles', ModuleName )

      allocate ( k_atmos_frq(noSpecies), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'k_atmos_frq' )

      allocate ( n_path(No_tan_hts), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'n_path' )
      allocate ( spsfunc_path(noSpecies,No_tan_hts), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'spsfunc_path' )
      call allocate_test ( dx_dt, No_tan_hts, temp%template%noSurfs, &
        & 'dx_dt', ModuleName )
      call allocate_test ( d2x_dxdt, No_tan_hts, temp%template%noSurfs, &
        & 'd2x_dxdt', ModuleName )

      call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
        & 'Radiances', ModuleName )
      call allocate_test ( i_star_all, noUsedChannels, noMIFs, &
        & 'i_star_all', ModuleName )

      ! Now set radiances to zero, forward model just adds in terms
      do i = 1, noUsedChannels
        thisRadiance = GetVectorQuantityByType (fwdModelOut, &
          & quantityType=l_radiance, &
          & signal=fwdModelConf%signals(usedSignals(i))%index, &
          & sideband=firstSignal%sideband )
        ch = usedChannels(i)
        do j = 1, noMIFs
          thisRadiance%values( ch + (j-1)*thisRadiance%template%noChans, fmStat%maf) = 0.0
        end do
      end do

      if ( fwdModelConf%signals(1)%sideband == 0 ) then
        if (.not. associated (sidebandRatio) ) &
          & call MLSMessage(MLSMSG_Error,ModuleName, &
          & "No sideband ratio supplied")
        sidebandStart = -1
        sidebandStop = 1
        sidebandStep = 2
      else
        sidebandStart = fwdModelConf%signals(1)%sideband
        sidebandStop = sideBandStart
        sidebandStep = 1
      endif

      ! ----------------- Begin loop over sidebands -----------------------
      do thisSideband = sidebandStart, sidebandStop, sidebandStep


        if ( toggle(emit) .and. levels(emit) > 0 ) then
          call trace_begin ( 'ForwardModel.sideband' )
          call output ( ' Doing sideband ' )
          call output ( thisSideband )
          call output ( ' (' ); call output ( sidebandStart )
          call output ( ', ' ); call output ( sidebandStop )
          call output ( ')', advance='yes' )
        end if

        ! Now code splits into two sections, one for when we're doing frequency
        ! averaging, and one when we're not.
        if ( fwdModelConf%do_freq_avg ) then ! --- Doing freq. avg. ---
          if ( toggle(emit) .and. levels(emit) > 0 ) &
            & call trace_begin ( 'ForwardModel.FreqAvg' )

          call allocate_test ( superset, size(pointingGrids), &
            & 'superset', ModuleName )
          do i = 1, size(pointingGrids)
            superset(i) = AreSignalsSuperset ( pointingGrids(i)%signals, &
              & fwdModelConf%signals, sideband=thisSideband )
          end do
          if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "No matching pointing frequency grids." )

          maxSuperset = maxval ( superset )
          where ( superset < 0 )
            superset = maxSuperset + 1
          end where
          whichPointingGridAsArray = minloc ( superset )
          whichPointingGrid = whichPointingGridAsArray(1)
          call deallocate_test ( superset, 'superset', ModuleName )

          if ( toggle(emit) ) then
            call output ( 'Using pointing frequency grid: ' )
            call output ( whichPointingGrid, advance='yes' )
          end if

          ! Now we've identified the pointing grids.  Locate the tangent grid
          ! within it.
          call allocate_test ( grids, FwdModelConf%TangentGrid%nosurfs, &
            "Grids", ModuleName )
          call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
            & FwdModelConf%TangentGrid%surfs, grids, allowTopValue=.true. )
          if ( toggle(emit) .and. levels(emit) > 0 ) &
            & call trace_end ( 'ForwardModel.FreqAvg' )

        else ! ------------------------- Not frequency averaging ---------

          if ( toggle(emit) .and. levels(emit) > 0 ) &
            & call trace_begin ( 'ForwardModel.NotFreqAvg' )

          call allocate_test ( frequencies,noUsedChannels, "frequencies", ModuleName )
          do channel = 1, noUsedchannels
            frequencies(channel) = &
              & fwdModelConf%signals(usedSignals(channel))%centerFrequency + &
              & fwdModelConf%signals(usedSignals(channel))% &
              &  frequencies(usedChannels(channel))
          end do
          select case ( thisSideband )
          case ( -1 )
            frequencies = firstSignal%lo - frequencies
          case ( +1 )
            frequencies = firstSignal%lo + frequencies
          case ( 0 )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Folded signal requested in forward model' )
          case default
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Bad value of signal%sideband' )
          end select
          noFreqs = noUsedChannels
          if ( toggle(emit) .and. levels(emit) > 0 ) &
            & call trace_end ( 'ForwardModel.NotFreqAvg' )
        end if

        ! ----------- Done the gnarly frequency stuff ----------

        ! Now work out what `window' we're inside.  This will need to be changed
        ! a bit in later versions to avoid the noMAFS==noTemp/f instances
        ! assertion

        mafTInstance = ifm%closestInstances(maf)

        windowStart  = max(1, mafTInstance - phiWindow/2)
        windowFinish = min(mafTInstance + phiWindow/2, no_phi_t)

        if ( toggle(emit) .and. levels(emit) > 0 ) then
          print *, 'Doing MAF: ', maf
          Print *, 'mafTInstance:',mafTInstance
          print *, 'WindowStart:',WindowStart
          print *, 'WindowFinish:',WindowFinish
        end if

        allocate ( k_temp(noUsedChannels, no_tan_hts, temp%template%noSurfs, &
          & windowStart:windowFinish), stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_temp' )
        allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
          & windowStart:windowFinish, noSpecies), stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_atmos' )

        ! Compute the specie function (spsfunc) and the refraction along
        ! all the paths for the current maf

        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.get_path_spsfunc_ngrid' )
        Call get_path_spsfunc_ngrid ( fwdModelIn, fwdModelExtra, &
          &  fwdModelConf%molecules, ifm%ndx_path(:,maf), no_tan_hts, &
          &  ifm%z_path(:,maf), ifm%t_path(:,maf), ifm%phi_path(:,maf), n_path, &
          &  spsfunc_path, Ier )
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.get_path_spsfunc_ngrid' )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'get_path_sps_fun_ngrid failed' )

        !??? Choose better value for phi_tan later
        phi_tan = Deg2Rad * temp%template%phi(1,mafTInstance)

        ! Compute the ptg_angles (chi) for Antenna convolution, also the
        ! derivatives of chi w.r.t to T and other parameters
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.get_chi_angles' )
        call get_chi_angles ( ifm%ndx_path(:,maf), n_path, &
          &  fwdModelConf%tangentGrid%surfs, &
          &  ifm%tan_hts(:,mafTInstance),ifm%tan_temp(:,mafTInstance),&
          &  phi_tan,ifm%elvar(maf)%Roc,&
          &  0.001*scGeocAlt%values(1,1),  &
          &  elevOffset%values(1,1), &
          &  ifm%tan_dh_dt(:,mafTInstance,:), no_tan_hts, &
          &  temp%template%noSurfs, &
          &  temp%template%surfs(:,1), &
          &  fwdModelConf%SurfaceTangentIndex, &
          &  center_angle, ptg_angles, dx_dt, d2x_dxdt, ier )
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.get_chi_angles' )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'get_chi_angles failed' )

        ! Compute the refraction correction scaling matrix for this mmaf:
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.refraction_correction' )
        call refraction_correction ( no_tan_hts, ifm%tan_hts(:,mafTInstance), &
          &  ifm%h_path(:,maf), n_path, ifm%ndx_path(:,maf),      &
          &  ifm%E_rad(mafTInstance), ref_corr )
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.refraction_correction' )

        Radiances = 0.0

        ! If we're not doing frequency averaging, instead outputting radiances
        ! corresponding to delta function responses, we can set up the frequency
        ! information here.  In the more common case where we are doing the
        ! averaging, the frequency grid varies from pointing to pointing, and is
        ! allocated inside the pointing loop.

        ! First we have a mini loop over pointings to work out an upper limit
        ! for the number of frequencies we're going to be dealing with
        if ( fwdModelConf%do_freq_avg ) then
          maxNoFreqs = size(PointingGrids(whichPointingGrid)%OneGrid(grids(1))%Frequencies)
          do ptg_i = 2, no_tan_hts - 1
            maxNoFreqs = max ( maxNoFreqs, size(PointingGrids(whichPointingGrid) &
              & %OneGrid(grids(ptg_i))%Frequencies) )
          end do
        else
          maxNoFreqs = noFreqs
        end if

        ! Now allocate arrays this size
        if ( fwdModelConf%temp_der ) then
          allocate ( k_temp_frq%values( maxNoFreqs, temp%template%noSurfs, &
            & windowStart:windowFinish), stat=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
            & MLSMSG_Allocate//'k_temp_frq' )
          k_temp_frq%values = 0.0_r8
        end if

        call allocate_test ( radV,maxNoFreqs, 'radV', ModuleName )

        do specie = 1, noSpecies
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )

          ! Allocate intermediate space for vmr derivatives
          if ( fwdModelConf%moleculeDerivatives(specie) ) then
            allocate ( k_atmos_frq(specie)%values(maxNoFreqs,f%template%noSurfs,&
              & windowStart:windowFinish), stat=status )
            if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
              & MLSMSG_Allocate//'k_atmos_frq' )
          end if

        end do ! End loop over species

        ! Now we can go ahead and loop over pointings
        ! ------------------------------ Begin loop over pointings --------
        do ptg_i = 1, no_tan_hts - 1
          if ( toggle(emit) .and. levels(emit) > 1 ) then
            call trace_begin ( 'ForwardModel.Pointing' )
            call output ( 'Ptg = ' ); call output ( ptg_i, advance='yes' )
          end if
          k = ptg_i
          h_tan = ifm%tan_hts(k,mafTInstance)
          lmax = ubound(ifm%eta_phi(ptg_i,maf)%values,2)

          ! Compute the beta's along the path, for this tanget hight and this mmaf:

          no_ele = ifm%ndx_path(ptg_i,maf)%total_number_of_elements

          ! If we're doing frequency averaging, get the frequencies we need for
          ! this pointing.
          if ( FwdModelConf%do_freq_avg ) then
            frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
            noFreqs = size(frequencies)
          end if ! If not, we dealt with this outside the loop

          call get_beta_path ( frequencies, my_Catalog, no_ele, &
            &                  ifm%z_path(ptg_i,maf), ifm%t_path(ptg_i,maf), &
            &                  beta_path, 0.001*losVel%values(1,maf), &
            &                  fwdModelConf%frqGap,             &
            &                  fwdModelConf%temp_der,           &
            &                  fwdModelConf%spect_der, Ier)
          if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'get_beta_path failed' )

          ! Define the dh_dt_path for this pointing and this MAF:

          ! Need to allocate this even if no derivatives as we pass it

          call allocate_test ( dh_dt_path, no_ele, phiWindow, &
            & temp%template%noSurfs, "dh_dt_path", ModuleName )

          if ( fwdModelConf%temp_der ) then
            allocate ( dum(no_ele), stat=ier )
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
              & MLSMSG_Allocate // 'dum' )
            do j = 1, temp%template%noSurfs
              do i = 1, phiWindow
                m = min(lmax,i+windowStart-1)
                call Lintrp ( ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,&
                  &           ifm%dh_dt_glgrid(:,m,j), dum, ifm%gl_count,&
                  &           no_ele )
                dh_dt_path(:,i,j) = dum(:) * ifm%eta_phi(ptg_i,maf)%values(:,m)
              end do
            end do
            deallocate ( dum, stat=ier )
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
              & MLSMSG_DeAllocate // 'dum' )
          end if

          ! ------------------------------- Begin loop over frequencies ------
          do frq_i = 1, noFreqs

            Frq = frequencies(frq_i)
            if ( toggle(emit) .and. levels(emit) > 2 ) then
              call trace_begin ( 'ForwardModel.Frequencies' )
              call output ( 'Frq = ' ); call output ( frq_i, advance='yes' )
            end if

            Call Rad_Tran ( ifm%elvar(maf), Frq, &
              & fwdModelConf%integrationGrid%noSurfs, h_tan, &
              & noSpecies, ifm%ndx_path(k,maf), ifm%z_path(k,maf), &
              & ifm%h_path(k,maf), ifm%t_path(k,maf), ifm%phi_path(k,maf), &
              & ifm%dHdz_path(k,maf), earthRefl%values(1,1), beta_path(:,frq_i), &
              & spsfunc_path(:,k), ref_corr(:,k), spaceRadiance%values(1,1), &
              & brkpt, no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier )
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'rad_tran failed' )

            RadV(frq_i) = Rad

            ! Now, Compute the radiance derivatives:

            !??? Do we need to do this if there's no Jacobian or no derivatives requested ???
            Call Rad_Tran_WD ( FwdModelConf, FwdModelExtra, FwdModelIn, &
              &  ifm%elvar(maf), frq_i, Frq, noSpecies, ifm%z_path(k,maf), &
              &  ifm%h_path(k,maf), ifm%t_path(k,maf), ifm%phi_path(k,maf), &
              &  ifm%dHdz_path(k,maf), beta_path(:,frq_i), spsfunc_path(:, &
              &  k), temp%template%surfs(:,1), temp%template%noSurfs, &
              &  ref_corr(:,k), temp%template%noInstances, &
              &  temp%template%phi(1,:)*Deg2Rad, dh_dt_path, k_temp_frq, &
              &  k_atmos_frq, brkpt, no_ele, mid, ilo, ihi, t_script, tau, &
              &  max_zeta_dim, max_phi_dim, ier )
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'rad_tran_wd failed' )

            if ( toggle(emit) .and. levels(emit) > 2 ) &
              & call trace_end ( 'ForwardModel.Frequencies' )
          end do                          ! Frequency loop

          ! ----------------------------- End loop over frequencies ----

          ! Here we either frequency average to get the unconvolved radiances, or
          ! we just store what we have as we're using delta funciton channels

          if ( toggle(emit) .and. levels(emit) > 1 ) &
            & call trace_begin ( 'ForwardModel.FrequencyAvg' )
          if ( fwdModelConf%do_freq_avg ) then
            do i = 1, noUsedChannels
              sigInd = usedSignals(i)
              ch = usedChannels(i)
              if ( toggle(emit) .and. levels(emit) > 2 ) then
                call output ( 'Channel = ' )
                call output ( i )
                call output ( ' ( ' )
                call output ( sigInd )
                call output ( ':' )
                call output ( ch )
                call output ( ' )', advance='yes' )
              end if
              centerFreq = firstSignal%lo + &
                & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
              shapeInd = MatchSignal ( filterShapes%signal, &
                & fwdModelConf%signals(sigInd), sideband = thisSideband )
              if ( shapeInd == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                & "No matching channel shape information" )
              if ( toggle(emit) .and. levels(emit) > 2 ) then
                call output ( 'Using filter shape:' )
                call output ( shapeInd, advance='yes' )
              endif

              call Freq_Avg ( frequencies, &
                & centerFreq+thisSideband * &
                & FilterShapes(shapeInd)%FilterGrid(ch,:), &
                & FilterShapes(shapeInd)%FilterShape(ch,:), RadV, noFreqs,  &
                & Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), Radiances(ptg_i,i) )
            end do
          else
            Radiances(ptg_i,:) = RadV(1:noFreqs)
          end if

          ! Frequency Average the temperature derivatives with the appropriate
          ! filter shapes
          !??? Do we need to do this if there's no Jacobian ???
          if ( fwdModelConf%temp_der ) then
            if ( fwdModelConf%do_freq_avg ) then
              do i = 1, noUsedChannels
                sigInd = usedSignals(i)
                ch = usedChannels(i)
                centerFreq = firstSignal%lo + &
                  & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
                shapeInd = MatchSignal ( filterShapes%signal, &
                  & fwdModelConf%signals(sigInd), &
                  & sideband = thisSideband, channel=ch )
                do instance = lbound(k_temp_frq%values,3), &
                  & ubound(k_temp_frq%values,3)
                  do surface = 1, temp%template%noSurfs
                    ToAvg => k_temp_frq%values(1:noFreqs,surface,instance)
                    call Freq_Avg ( frequencies,                        &
                      & centerFreq+thisSideband* &
                      & FilterShapes(shapeInd)%FilterGrid(ch,:), &
                      & FilterShapes(shapeInd)%FilterShape(ch,:),&
                      & real(ToAvg,r8), noFreqs, &
                      & Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
                    k_temp(i,ptg_i,surface,instance) = r
                  end do                  ! Surface loop
                end do                    ! Instance loop
              end do                      ! Channel loop
            else
              do i = 1, noUsedChannels
                k_temp(i,ptg_i,1:temp%template%noSurfs,:) = &
                  &  k_temp_frq%values(i,1:temp%template%noSurfs,:)
              end do
            end if
          end if

          ! Frequency Average the atmospheric derivatives with the appropriate
          ! filter shapes
          !??? Do we need to do this if there's no Jacobian ???
          do specie = 1, noSpecies
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
                &  quantityType=l_vmr, molecule=fwdModelConf%molecules(specie))
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  ch = usedChannels(i)
                  centerFreq = firstSignal%lo + &
                    & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd), &
                    & sideband = thisSideband, channel=ch )
                  do instance = lbound(k_atmos_frq(specie)%values,3),&
                    & ubound(k_atmos_frq(specie)%values,3)
                    do surface = 1, f%template%noSurfs
                      ToAvg => k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(ch,:), &
                        & FilterShapes(shapeInd)%FilterShape(ch,:), &
                        & real(ToAvg,r8),  &
                        & noFreqs, Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
                      k_atmos(i,ptg_i,surface,instance,specie) = r
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! Else not frequency averaging
                surface = f%template%noSurfs
                do i = 1, noUsedChannels
                  k_atmos(i,ptg_i,1:surface,:,specie) = &
                    &  k_atmos_frq(specie)%values(i,1:surface,:)
                end do
              end if                      ! Frequency averaging or not
            end if                        ! Want derivatives for this
          end do                          ! Loop over species

          if ( toggle(emit) .and. levels(emit) > 1 ) &
            & call trace_end ( 'ForwardModel.FrequencyAvg' )

          call deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )

          if ( toggle(emit) .and. levels(emit) > 1 ) &
            & call trace_end ( 'ForwardModel.Pointing' )

        end do                            ! Pointing Loop
        ! ---------------------------------- End of Pointing Loop ---------------

        ! Complete the radiance's last location; also complete k_temp last
        ! location.

        do i = 1, noUsedChannels
          ch = usedChannels(i)
          Radiances(no_tan_hts,i) = Radiances(no_tan_hts-1,i)
          if ( FwdModelConf%temp_der ) then
            n = temp%template%noSurfs
            k_temp(i,no_tan_hts,1:n,:) = k_temp(i,no_tan_hts-1,1:n,:)
          end if
          if ( FwdModelConf%atmos_der ) then
            do m = 1, noSpecies
              f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
                & quantityType=l_vmr, molecule=fwdModelConf%molecules(m),&
                & foundInFirst=foundInFirst )
              if ( foundInFirst ) then
                n = f%template%noSurfs
                k_atmos(i,no_tan_hts,1:n,:,m)= k_atmos(i,no_tan_hts-1,1:n,:,m)
              end if
            end do
          end if
        end do

        !  Here comes the Convolution code
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.Convolution' )
        call allocate_test ( superset, size(antennaPatterns), &
          & 'superset', ModuleName )
        do i = 1, noUsedChannels

          ch = usedChannels(i)
          sigInd = usedSignals(i)
          thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
            & signal=fwdModelConf%signals(sigInd)%index, &
            & sideband=firstSignal%sideband )

          if ( sidebandStart /= sidebandStop ) then ! We're folding
            thisRatio = sidebandRatio%values(ch,1)
            if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
          else ! Otherwise, want just unfolded signal
            thisRatio = 1.0
          end if

          if ( FwdModelConf%do_conv ) then

            do j = 1, size(antennaPatterns)
              superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
                & fwdModelConf%signals, sideband=thisSideband, channel=ch )
            end do
            if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "No matching antenna patterns." )

            maxSuperset = maxval ( superset )
            where ( superset < 0 )
              superset = maxSuperset + 1
            end where
            whichPatternAsArray = minloc ( superset )
            whichPattern = whichPatternAsArray(1)
            if ( toggle(emit) .and. levels(emit) > 2 ) then
              call output ( 'Using antenna pattern: ' )
              call output ( whichPattern, advance='yes' )
            end if

            call convolve_all ( fwdModelConf, fwdModelIn, maf, ch, &
              &     windowStart, windowFinish, mafTInstance-windowStart+1, &
              &     temp, ptan, thisRadiance, &
              &     FwdModelConf%tangentGrid%surfs, ptg_angles, &
              &     ifm%tan_temp(:,maf), dx_dt, d2x_dxdt, si, center_angle, &
              &     Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
              &     thisRatio, Jacobian, fmStat%rows,  &
              &     antennaPatterns(whichPattern), ier )
            !??? Need to choose some index other than 1 for AntennaPatterns ???
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'convolve_all failed' )
          else
            call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, ch,  &
              &     windowStart, windowFinish, temp, ptan, thisRadiance, &
              &     FwdModelConf%tangentGrid%surfs, &
              &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
              &     thisRatio, Jacobian, fmStat%rows )

          end if

        end do                            ! Channel loop
        call deallocate_test ( superset, 'superset', ModuleName )
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.Convolution' )

        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.sideband' )
      end do
      ! ---------------------------- End of loop over sideband ------------------

      ! ------------------------------ End of Major Frame Specific stuff --------

      if ( associated(beta_path) ) then
        do i = 1, size(beta_path,1)
          do j = 1, size(beta_path,2)
            deallocate ( beta_path(i,j)%values, beta_path(i,j)%t_power, &
              & beta_path(i,j)%dbeta_dw, beta_path(i,j)%dbeta_dn, &
              & beta_path(i,j)%dbeta_dnu, STAT=k )
          end do
        end do
      end if

      deallocate ( beta_path, STAT=k )

      if ( FwdModelConf%temp_der ) call deallocate_test &
        & ( k_temp_frq%values, "k_temp_frq%values", ModuleName )
      if ( FwdModelConf%atmos_der ) then
        do j = 1, noSpecies
          call deallocate_test ( k_atmos_frq(j)%values, "k_atmos_frq(j)%values", &
            & ModuleName )
        end do
      end if

      if ( index(switches,'rad') /= 0 ) then
        ! *** DEBUG Print
        if ( FwdModelConf%do_conv ) then
          print *,'Convolution: ON'
        else
          print *,'Convolution: OFF'
        end if

        if ( FwdModelConf%do_freq_avg ) then
          print *,'Frequency Averaging: ON'
        else
          print *,'Frequency Averaging: OFF'
          print '(A,f12.4,a)', ' (All computations done at Frq =',Frequencies(1),')'
        end if
        print *

        do i = 1, noUsedChannels
          ch = usedChannels(i)
          print 903, ch, char(92), ptan%template%noSurfs
903       format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
          print 905, ( firstRadiance%values(ch+(k-1)*firstRadiance%template%noChans,maf),&
            & k = 1, ptan%template%noSurfs )
905       format ( 4(2x, 1pg15.8) )
        end do
      end if

      do j = 1, No_tan_hts
        deallocate ( n_path(j)%values, stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate//'n_path%values' )
        do i = 1, noSpecies
          deallocate ( spsfunc_path(i,j)%values, stat=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_Deallocate//'spsfunc_path%values' )
        end do
      end do

      deallocate ( n_path, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'n_path' )

      deallocate ( spsfunc_path, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'spsfunc_path' )

      call deallocate_test ( dx_dt, 'dx_dt', ModuleName )
      call deallocate_test ( d2x_dxdt, 'd2x_dxdt', ModuleName )

      call deallocate_test ( t_script, 't_srcipt', ModuleName )
      call deallocate_test ( ref_corr, 'ref_corr', ModuleName )
      call deallocate_test ( tau, 'tau', ModuleName )
      call deallocate_test ( ptg_angles, 'ptg_angles', ModuleName )

      deallocate ( k_atmos_frq, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_atmos_frq' )
      deallocate ( k_temp, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_temp' )
      deallocate ( k_atmos, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'k_atmos' )
      deallocate ( My_Catalog, stat=status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'My_catalog' )

      call deallocate_test ( radiances, 'Radiances', ModuleName )
      call deallocate_test ( i_star_all, 'i_star_all', ModuleName )
      call deallocate_test ( radv, 'rad_v', ModuleName )
      call deallocate_test ( grids, 'grids',  ModuleName )

    else
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call output ( 'This MAF skipped as in overlap region', advance='yes' )
    endif ! --------------------------- Possible skip of this major frame

    if ( maf == noMAFs ) fmStat%finished = .true.
    
    call Deallocate_test ( usedChannels, 'usedChannels', ModuleName )
    call Deallocate_test ( usedSignals, 'usedSignals', ModuleName )

    if ( .not. fwdModelConf%do_freq_avg ) call deallocate_test ( &
      & frequencies, "frequencies", ModuleName )

    if ( toggle(emit) ) call trace_end ( 'ForwardModel' )

  end subroutine FullForwardModel

d371 3
@


2.135
log
@Moved some of the emits to higher numbers
@
text
@d33 1
a33 1
    & F_MODULE
d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.134 2001/05/17 01:44:16 livesey Exp $"
d205 1
d228 2
d391 2
a392 2
                   max_phi_dim, max_zeta_dim, mid, n, no_ele, no_tan_hts, &
                   ptg_i, si, Spectag
d394 2
a395 2
!    real(r4) :: K_STAR_ALL(25,20,mxco,mnp,Nptg)
!    type(k_matrix_info) :: K_star_info(20)
d482 1
a482 1
    
d712 1
a712 1
                        &  ModuleName )
d714 1
a714 1
                        &  ModuleName )
d718 1
a718 1
                        &  'dhdz_glgrid', ModuleName )
d720 1
a720 1
                        &  ModuleName )
d722 1
a722 1
                        &  ModuleName )
d724 1
a724 1
                        & temp%template%noSurfs, 'tan_dh_dt', ModuleName )
d749 2
a750 1
      if ( ier /= 0 ) goto 99
d760 2
a761 1
      if ( ier /= 0 ) goto 99
a769 1
    ! ------ Begin main MAF Specific stuff ---------------------------
d771 13
a783 37
    ! Now allocate other stuff
    call allocate_test ( t_script, n2lvl, 't_srcipt', ModuleName )
    call allocate_test ( ref_corr, n2lvl, no_tan_hts, 'ref_corr', ModuleName )
    call allocate_test ( tau, n2lvl, 'tau', ModuleName )
    call allocate_test ( ptg_angles, no_tan_hts, 'ptg_angles', ModuleName )

    allocate ( k_atmos_frq(noSpecies), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_atmos_frq' )

    allocate ( n_path(No_tan_hts), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'n_path' )
    allocate ( spsfunc_path(noSpecies,No_tan_hts), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'spsfunc_path' )
    call allocate_test ( dx_dt, No_tan_hts, temp%template%noSurfs, &
      & 'dx_dt', ModuleName )
    call allocate_test ( d2x_dxdt, No_tan_hts, temp%template%noSurfs, &
      & 'd2x_dxdt', ModuleName )

    call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
      & 'Radiances', ModuleName )
    call allocate_test ( i_star_all, noUsedChannels, noMIFs, &
      & 'i_star_all', ModuleName )

    ! Now set radiances to zero, forward model just adds in terms
    do i = 1, noUsedChannels
      thisRadiance = GetVectorQuantityByType (fwdModelOut, &
        & quantityType=l_radiance, &
        & signal=fwdModelConf%signals(usedSignals(i))%index, &
        & sideband=firstSignal%sideband )
      ch = usedChannels(i)
      do j = 1, noMIFs
        thisRadiance%values( ch + (j-1)*thisRadiance%template%noChans, fmStat%maf) = 0.0
      end do
    end do
d785 3
a787 12
    if ( fwdModelConf%signals(1)%sideband == 0 ) then
      if (.not. associated (sidebandRatio) ) &
        & call MLSMessage(MLSMSG_Error,ModuleName, &
        & "No sideband ratio supplied")
      sidebandStart = -1
      sidebandStop = 1
      sidebandStep = 2
    else
      sidebandStart = fwdModelConf%signals(1)%sideband
      sidebandStop = sideBandStart
      sidebandStep = 1
    endif
d789 15
a803 2
    ! ----------------- Begin loop over sidebands -----------------------
    do thisSideband = sidebandStart, sidebandStop, sidebandStep
d805 9
a813 21

      if ( toggle(emit) .and. levels(emit) > 0 ) then
        call trace_begin ( 'ForwardModel.sideband' )
        call output ( ' Doing sideband ' )
        call output ( thisSideband )
        call output ( ' (' ); call output ( sidebandStart )
        call output ( ', ' ); call output ( sidebandStop )
        call output ( ')', advance='yes' )
      end if

      ! Now code splits into two sections, one for when we're doing frequency
      ! averaging, and one when we're not.
      if ( fwdModelConf%do_freq_avg ) then ! --- Doing freq. avg. ---
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.FreqAvg' )

        call allocate_test ( superset, size(pointingGrids), &
          & 'superset', ModuleName )
        do i = 1, size(pointingGrids)
         superset(i) = AreSignalsSuperset ( pointingGrids(i)%signals, &
            & fwdModelConf%signals, sideband=thisSideband )
d815 1
a815 10
        if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "No matching pointing frequency grids." )
        
        maxSuperset = maxval ( superset )
        where ( superset < 0 )
          superset = maxSuperset + 1
        end where
        whichPointingGridAsArray = minloc ( superset )
        whichPointingGrid = whichPointingGridAsArray(1)
        call deallocate_test ( superset, 'superset', ModuleName )
d817 24
a840 3
        if ( toggle(emit) ) then
          call output ( 'Using pointing frequency grid: ' )
          call output ( whichPointingGrid, advance='yes' )
a841 9
        
        ! Now we've identified the pointing grids.  Locate the tangent grid
        ! within it.
        call allocate_test ( grids, FwdModelConf%TangentGrid%nosurfs, &
          "Grids", ModuleName )
        call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
          & FwdModelConf%TangentGrid%surfs, grids, allowTopValue=.true. )
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.FreqAvg' )
d843 14
a856 28
      else ! ------------------------- Not frequency averaging ---------
        
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.NotFreqAvg' )
        
        call allocate_test ( frequencies,noUsedChannels, "frequencies", ModuleName )
        do channel = 1, noUsedchannels
          frequencies(channel) = &
            & fwdModelConf%signals(usedSignals(channel))%centerFrequency + &
            & fwdModelConf%signals(usedSignals(channel))% &
            &  frequencies(usedChannels(channel))
        end do
        select case ( thisSideband )
        case ( -1 )
          frequencies = firstSignal%lo - frequencies
        case ( +1 )
          frequencies = firstSignal%lo + frequencies
        case ( 0 )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Folded signal requested in forward model' )
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Bad value of signal%sideband' )
        end select
        noFreqs = noUsedChannels
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.NotFreqAvg' )
      end if
d858 12
a869 1
      ! ----------- Done the gnarly frequency stuff ----------
d871 37
a907 1
      maf=fmStat%maf
d909 1
a909 3
      ! Now work out what `window' we're inside.  This will need to be changed
      ! a bit in later versions to avoid the noMAFS==noTemp/f instances
      ! assertion
d911 15
a925 1
      mafTInstance = ifm%closestInstances(maf)
d927 8
a934 2
      windowStart  = max(1, mafTInstance - phiWindow/2)
      windowFinish = min(mafTInstance + phiWindow/2, no_phi_t)
d936 2
a937 6
      if ( toggle(emit) .and. levels(emit) > 0 ) then
        print *, 'Doing MAF: ', maf
        Print *, 'mafTInstance:',mafTInstance
        print *, 'WindowStart:',WindowStart
        print *, 'WindowFinish:',WindowFinish
      end if
d939 10
a948 8
      allocate ( k_temp(noUsedChannels, no_tan_hts, temp%template%noSurfs, &
        & windowStart:windowFinish), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'k_temp' )
      allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
        & windowStart:windowFinish, noSpecies), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'k_atmos' )
d950 2
a951 2
      ! Compute the specie function (spsfunc) and the refraction along
      ! all the paths for the current maf
d953 19
a971 9
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_begin ( 'ForwardModel.get_path_spsfunc_ngrid' )
      Call get_path_spsfunc_ngrid ( fwdModelIn, fwdModelExtra, &
        &  fwdModelConf%molecules, ifm%ndx_path(:,maf), no_tan_hts, &
        &  ifm%z_path(:,maf), ifm%t_path(:,maf), ifm%phi_path(:,maf), n_path, &
        &  spsfunc_path, Ier )
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.get_path_spsfunc_ngrid' )
      if ( ier /= 0 ) goto 99
d973 8
a980 2
      !??? Choose better value for phi_tan later
      phi_tan = Deg2Rad * temp%template%phi(1,mafTInstance)
d982 1
a982 18
      ! Compute the ptg_angles (chi) for Antenna convolution, also the
      ! derivatives of chi w.r.t to T and other parameters
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_begin ( 'ForwardModel.get_chi_angles' )
      call get_chi_angles ( ifm%ndx_path(:,maf), n_path, &
        &  fwdModelConf%tangentGrid%surfs, &
        &  ifm%tan_hts(:,mafTInstance),ifm%tan_temp(:,mafTInstance),&
        &  phi_tan,ifm%elvar(maf)%Roc,&
        &  0.001*scGeocAlt%values(1,1),  &
        &  elevOffset%values(1,1), &
        &  ifm%tan_dh_dt(:,mafTInstance,:), no_tan_hts, &
        &  temp%template%noSurfs, &
        &  temp%template%surfs(:,1), &
        &  fwdModelConf%SurfaceTangentIndex, &
        &  center_angle, ptg_angles, dx_dt, d2x_dxdt, ier )
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.get_chi_angles' )
      if ( ier /= 0 ) goto 99
d984 5
a988 8
      ! Compute the refraction correction scaling matrix for this mmaf:
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_begin ( 'ForwardModel.refraction_correction' )
      call refraction_correction ( no_tan_hts, ifm%tan_hts(:,mafTInstance), &
        &  ifm%h_path(:,maf), n_path, ifm%ndx_path(:,maf),      &
        &  ifm%E_rad(mafTInstance), ref_corr )
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.refraction_correction' )
d990 11
a1000 1
      Radiances = 0.0
d1002 3
a1004 36
      ! If we're not doing frequency averaging, instead outputting radiances
      ! corresponding to delta function responses, we can set up the frequency
      ! information here.  In the more common case where we are doing the
      ! averaging, the frequency grid varies from pointing to pointing, and is
      ! allocated inside the pointing loop.

      ! First we have a mini loop over pointings to work out an upper limit
      ! for the number of frequencies we're going to be dealing with
      if ( fwdModelConf%do_freq_avg ) then
        maxNoFreqs = size(PointingGrids(whichPointingGrid)%OneGrid(grids(1))%Frequencies)
        do ptg_i = 2, no_tan_hts - 1
          maxNoFreqs = max ( maxNoFreqs, size(PointingGrids(whichPointingGrid) &
            & %OneGrid(grids(ptg_i))%Frequencies) )
        end do
      else
        maxNoFreqs = noFreqs
      end if

      ! Now allocate arrays this size
      if ( fwdModelConf%temp_der ) then
        allocate ( k_temp_frq%values( maxNoFreqs, temp%template%noSurfs, &
          & windowStart:windowFinish), stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
          & MLSMSG_Allocate//'k_temp_frq' )
        k_temp_frq%values = 0.0_r8
      end if

      call allocate_test ( radV,maxNoFreqs, 'radV', ModuleName )

      do specie = 1, noSpecies
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )

        ! Allocate intermediate space for vmr derivatives
        if ( fwdModelConf%moleculeDerivatives(specie) ) then
          allocate ( k_atmos_frq(specie)%values(maxNoFreqs,f%template%noSurfs,&
d1007 2
a1008 1
            & MLSMSG_Allocate//'k_atmos_frq' )
d1011 1
a1011 1
      end do ! End loop over species
d1013 3
a1015 10
      ! Now we can go ahead and loop over pointings
      ! ------------------------------ Begin loop over pointings --------
      do ptg_i = 1, no_tan_hts - 1
        if ( toggle(emit) .and. levels(emit) > 1 ) then
          call trace_begin ( 'ForwardModel.Pointing' )
          call output ( 'Ptg = ' ); call output ( ptg_i, advance='yes' )
        end if
        k = ptg_i
        h_tan = ifm%tan_hts(k,mafTInstance)
        lmax = ubound(ifm%eta_phi(ptg_i,maf)%values,2)
d1017 7
a1023 1
        ! Compute the beta's along the path, for this tanget hight and this mmaf:
d1025 1
a1025 1
        no_ele = ifm%ndx_path(ptg_i,maf)%total_number_of_elements
d1027 50
a1076 33
        ! If we're doing frequency averaging, get the frequencies we need for
        ! this pointing.
        if ( FwdModelConf%do_freq_avg ) then
          frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
          noFreqs = size(frequencies)
        end if ! If not, we dealt with this outside the loop

        call get_beta_path ( frequencies, my_Catalog, no_ele, &
          &                  ifm%z_path(ptg_i,maf), ifm%t_path(ptg_i,maf), &
          &                  beta_path, 0.001*losVel%values(1,maf), &
          &                  fwdModelConf%frqGap,             &
          &                  fwdModelConf%temp_der,           &
          &                  fwdModelConf%spect_der, Ier)
        if ( ier /= 0 ) goto 99

        ! Define the dh_dt_path for this pointing and this MAF:

        ! Need to allocate this even if no derivatives as we pass it

        call allocate_test ( dh_dt_path, no_ele, phiWindow, &
          & temp%template%noSurfs, "dh_dt_path", ModuleName )

        if ( fwdModelConf%temp_der ) then
          allocate ( dum(no_ele), stat=ier )
          if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & MLSMSG_Allocate // 'dum' )
          do j = 1, temp%template%noSurfs
            do i = 1, phiWindow
              m = min(lmax,i+windowStart-1)
              call Lintrp ( ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,&
                &           ifm%dh_dt_glgrid(:,m,j), dum, ifm%gl_count,&
                &           no_ele )
              dh_dt_path(:,i,j) = dum(:) * ifm%eta_phi(ptg_i,maf)%values(:,m)
d1078 4
a1081 5
          end do
          deallocate ( dum, stat=ier )
          if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & MLSMSG_DeAllocate // 'dum' )
        end if
d1083 2
a1084 2
        ! ------------------------------- Begin loop over frequencies ------
        do frq_i = 1, noFreqs
d1086 5
a1090 5
          Frq = frequencies(frq_i)
          if ( toggle(emit) .and. levels(emit) > 2 ) then
            call trace_begin ( 'ForwardModel.Frequencies' )
            call output ( 'Frq = ' ); call output ( frq_i, advance='yes' )
          end if
d1092 30
a1121 28
          Call Rad_Tran ( ifm%elvar(maf), Frq, &
            & fwdModelConf%integrationGrid%noSurfs, h_tan, &
            & noSpecies, ifm%ndx_path(k,maf), ifm%z_path(k,maf), &
            & ifm%h_path(k,maf), ifm%t_path(k,maf), ifm%phi_path(k,maf), &
            & ifm%dHdz_path(k,maf), earthRefl%values(1,1), beta_path(:,frq_i), &
            & spsfunc_path(:,k), ref_corr(:,k), spaceRadiance%values(1,1), &
            & brkpt, no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier )
          if ( ier /= 0 ) goto 99

          RadV(frq_i) = Rad

          ! Now, Compute the radiance derivatives:

!??? Do we need to do this if there's no Jacobian or no derivatives requested ???
          Call Rad_Tran_WD ( FwdModelConf, FwdModelExtra, FwdModelIn, &
            &  ifm%elvar(maf), frq_i, Frq, noSpecies, ifm%z_path(k,maf), &
            &  ifm%h_path(k,maf), ifm%t_path(k,maf), ifm%phi_path(k,maf), &
            &  ifm%dHdz_path(k,maf), beta_path(:,frq_i), spsfunc_path(:, &
            &  k), temp%template%surfs(:,1), temp%template%noSurfs, &
            &  ref_corr(:,k), temp%template%noInstances, &
            &  temp%template%phi(1,:)*Deg2Rad, dh_dt_path, k_temp_frq, &
            &  k_atmos_frq, brkpt, no_ele, mid, ilo, ihi, t_script, tau, &
            &  max_zeta_dim, max_phi_dim, ier )
          if ( ier /= 0 ) goto 99

          if ( toggle(emit) .and. levels(emit) > 2 ) &
            & call trace_end ( 'ForwardModel.Frequencies' )
        end do                          ! Frequency loop
d1123 1
a1123 1
        ! ----------------------------- End loop over frequencies ----
d1125 2
a1126 2
        ! Here we either frequency average to get the unconvolved radiances, or
        ! we just store what we have as we're using delta funciton channels
d1128 2
a1129 40
        if ( toggle(emit) .and. levels(emit) > 1 ) &
          & call trace_begin ( 'ForwardModel.FrequencyAvg' )
        if ( fwdModelConf%do_freq_avg ) then
          do i = 1, noUsedChannels
            sigInd = usedSignals(i)
            ch = usedChannels(i)
            if ( toggle(emit) .and. levels(emit) > 2 ) then
              call output ( 'Channel = ' )
              call output ( i )
              call output ( ' ( ' )
              call output ( sigInd )
              call output ( ':' )
              call output ( ch )
              call output ( ' )', advance='yes' )
            end if
            centerFreq = firstSignal%lo + &
              & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
            shapeInd = MatchSignal ( filterShapes%signal, &
              & fwdModelConf%signals(sigInd), sideband = thisSideband )
            if ( shapeInd == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "No matching channel shape information" )
            if ( toggle(emit) .and. levels(emit) > 2 ) then
              call output ( 'Using filter shape:' )
              call output ( shapeInd, advance='yes' )
            endif
                          
            call Freq_Avg ( frequencies, &
              & centerFreq+thisSideband * &
              & FilterShapes(shapeInd)%FilterGrid(ch,:), &
              & FilterShapes(shapeInd)%FilterShape(ch,:), RadV, noFreqs,  &
              & Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), Radiances(ptg_i,i) )
          end do
        else
          Radiances(ptg_i,:) = RadV(1:noFreqs)
        end if

        ! Frequency Average the temperature derivatives with the appropriate
        ! filter shapes
!??? Do we need to do this if there's no Jacobian ???
        if ( fwdModelConf%temp_der ) then
d1134 9
d1146 14
a1159 16
                & fwdModelConf%signals(sigInd), &
                & sideband = thisSideband, channel=ch )
              do instance = lbound(k_temp_frq%values,3), &
                & ubound(k_temp_frq%values,3)
                do surface = 1, temp%template%noSurfs
                  ToAvg => k_temp_frq%values(1:noFreqs,surface,instance)
                  call Freq_Avg ( frequencies,                        &
                    & centerFreq+thisSideband* &
                    & FilterShapes(shapeInd)%FilterGrid(ch,:), &
                    & FilterShapes(shapeInd)%FilterShape(ch,:),&
                    & real(ToAvg,r8), noFreqs, &
                    & Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
                  k_temp(i,ptg_i,surface,instance) = r
                end do                  ! Surface loop
              end do                    ! Instance loop
            end do                      ! Channel loop
d1161 1
a1161 4
            do i = 1, noUsedChannels
              k_temp(i,ptg_i,1:temp%template%noSurfs,:) = &
                &  k_temp_frq%values(i,1:temp%template%noSurfs,:)
            end do
a1162 1
        end if
d1164 4
a1167 7
        ! Frequency Average the atmospheric derivatives with the appropriate
        ! filter shapes
!??? Do we need to do this if there's no Jacobian ???
        do specie = 1, noSpecies
          if ( fwdModelConf%moleculeDerivatives(specie) ) then
            f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
              &  quantityType=l_vmr, molecule=fwdModelConf%molecules(specie))
d1170 13
a1182 13
              sigInd = usedSignals(i)
              ch = usedChannels(i)
              centerFreq = firstSignal%lo + &
                & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
              shapeInd = MatchSignal ( filterShapes%signal, &
                & fwdModelConf%signals(sigInd), &
                & sideband = thisSideband, channel=ch )
              do instance = lbound(k_atmos_frq(specie)%values,3),&
                  & ubound(k_atmos_frq(specie)%values,3)
                  do surface = 1, f%template%noSurfs
                    ToAvg => k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
                    call Freq_Avg ( frequencies,                      &
                      & centerFreq+thisSideband * &
d1184 8
a1191 9
                      & FilterShapes(shapeInd)%FilterShape(ch,:), &
                      & real(ToAvg,r8),  &
                      & noFreqs, Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
                      k_atmos(i,ptg_i,surface,instance,specie) = r
                  end do                ! Surface loop
                end do                  ! Instance loop
              end do                    ! Channel loop
            else                        ! Else not frequency averaging
              surface = f%template%noSurfs
d1193 2
a1194 2
                k_atmos(i,ptg_i,1:surface,:,specie) = &
                  &  k_atmos_frq(specie)%values(i,1:surface,:)
d1196 2
a1197 3
            end if                      ! Frequency averaging or not
          end if                        ! Want derivatives for this
        end do                          ! Loop over species
d1199 73
a1271 2
        if ( toggle(emit) .and. levels(emit) > 1 ) &
          & call trace_end ( 'ForwardModel.FrequencyAvg' )
d1273 6
a1278 1
        call deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )
d1280 12
a1291 2
        if ( toggle(emit) .and. levels(emit) > 1 ) &
          & call trace_end ( 'ForwardModel.Pointing' )
d1293 1
a1293 2
      end do                            ! Pointing Loop
      ! ---------------------------------- End of Pointing Loop ---------------
d1295 6
a1300 2
      ! Complete the radiance's last location; also complete k_temp last
      ! location.
d1302 9
a1310 15
      do i = 1, noUsedChannels
        ch = usedChannels(i)
        Radiances(no_tan_hts,i) = Radiances(no_tan_hts-1,i)
        if ( FwdModelConf%temp_der ) then
          n = temp%template%noSurfs
          k_temp(i,no_tan_hts,1:n,:) = k_temp(i,no_tan_hts-1,1:n,:)
        end if
        if ( FwdModelConf%atmos_der ) then
          do m = 1, noSpecies
            f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
              & quantityType=l_vmr, molecule=fwdModelConf%molecules(m),&
              & foundInFirst=foundInFirst )
            if ( foundInFirst ) then
              n = f%template%noSurfs
              k_atmos(i,no_tan_hts,1:n,:,m)= k_atmos(i,no_tan_hts-1,1:n,:,m)
a1311 3
          end do
        end if
      end do
d1313 19
a1331 6
      !  Here comes the Convolution code
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_begin ( 'ForwardModel.Convolution' )
      call allocate_test ( superset, size(antennaPatterns), &
        & 'superset', ModuleName )
      do i = 1, noUsedChannels
d1333 4
a1336 5
        ch = usedChannels(i)
        sigInd = usedSignals(i)
        thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
          & signal=fwdModelConf%signals(sigInd)%index, &
          & sideband=firstSignal%sideband )
d1338 4
a1341 6
        if ( sidebandStart /= sidebandStop ) then ! We're folding
          thisRatio = sidebandRatio%values(ch,1)
          if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
        else ! Otherwise, want just unfolded signal
          thisRatio = 1.0
        end if
d1343 1
a1343 1
        if ( FwdModelConf%do_conv ) then
d1345 6
a1350 3
          do j = 1, size(antennaPatterns)
            superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
              & fwdModelConf%signals, sideband=thisSideband, channel=ch )
d1352 13
a1364 13
          if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "No matching antenna patterns." )
          
          maxSuperset = maxval ( superset )
          where ( superset < 0 )
            superset = maxSuperset + 1
          end where
          whichPatternAsArray = minloc ( superset )
          whichPattern = whichPatternAsArray(1)
          if ( toggle(emit) .and. levels(emit) > 2 ) then
            call output ( 'Using antenna pattern: ' )
            call output ( whichPattern, advance='yes' )
          end if
d1366 4
a1369 10
          call convolve_all ( fwdModelConf, fwdModelIn, maf, ch, &
            &     windowStart, windowFinish, mafTInstance-windowStart+1, &
            &     temp, ptan, thisRadiance, &
            &     FwdModelConf%tangentGrid%surfs, ptg_angles, &
            &     ifm%tan_temp(:,maf), dx_dt, d2x_dxdt, si, center_angle, &
            &     Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
            &     thisRatio, Jacobian, fmStat%rows,  &
            &     antennaPatterns(whichPattern), ier )
          !??? Need to choose some index other than 1 for AntennaPatterns ???
          if ( ier /= 0 ) goto 99
d1371 2
a1372 5
          call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, ch,  &
            &     windowStart, windowFinish, temp, ptan, thisRadiance, &
            &     FwdModelConf%tangentGrid%surfs, &
            &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
            &     thisRatio, Jacobian, fmStat%rows )
d1374 5
d1380 1
d1382 9
a1390 4
      end do                            ! Channel loop
      call deallocate_test ( superset, 'superset', ModuleName )
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.Convolution' )
d1392 8
a1399 14
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.sideband' )
    end do
    ! ---------------------------- End of loop over sideband ------------------

    if ( maf == noMAFs ) fmStat%finished = .true.
    ! ------------------------------ End of Major Frame Specific stuff --------

    if ( associated(beta_path) ) then
      do i = 1, size(beta_path,1)
        do j = 1, size(beta_path,2)
          deallocate ( beta_path(i,j)%values, beta_path(i,j)%t_power, &
            & beta_path(i,j)%dbeta_dw, beta_path(i,j)%dbeta_dn, &
            & beta_path(i,j)%dbeta_dnu, STAT=k )
a1401 1
    end if
d1403 7
a1409 1
    deallocate ( beta_path, STAT=k )
d1411 2
a1412 8
    if ( FwdModelConf%temp_der ) call deallocate_test &
      & ( k_temp_frq%values, "k_temp_frq%values", ModuleName )
    if ( FwdModelConf%atmos_der ) then
      do j = 1, noSpecies
        call deallocate_test ( k_atmos_frq(j)%values, "k_atmos_frq(j)%values", &
          & ModuleName )
      end do
    end if
d1414 4
a1417 7
    if ( index(switches,'rad') /= 0 ) then
      ! *** DEBUG Print
      if ( FwdModelConf%do_conv ) then
        print *,'Convolution: ON'
      else
        print *,'Convolution: OFF'
      end if
d1419 12
a1430 7
      if ( FwdModelConf%do_freq_avg ) then
        print *,'Frequency Averaging: ON'
      else
        print *,'Frequency Averaging: OFF'
        print '(A,f12.4,a)', ' (All computations done at Frq =',Frequencies(1),')'
      end if
      print *
d1432 4
a1435 9
      do i = 1, noUsedChannels
        ch = usedChannels(i)
        print 903, ch, char(92), ptan%template%noSurfs
903     format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
        print 905, ( firstRadiance%values(ch+(k-1)*firstRadiance%template%noChans,maf),&
          & k = 1, ptan%template%noSurfs )
905     format ( 4(2x, 1pg15.8) )
      end do
    end if
d1437 4
a1440 2
    if ( .not. fwdModelConf%do_freq_avg ) call deallocate_test ( &
      & frequencies, "frequencies", ModuleName )
d1442 2
d1445 1
d1447 2
a1448 48
99  continue

    do j = 1, No_tan_hts
      deallocate ( n_path(j)%values, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'n_path%values' )
      do i = 1, noSpecies
        deallocate ( spsfunc_path(i,j)%values, stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate//'spsfunc_path%values' )
      end do
    end do

    deallocate ( n_path, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'n_path' )

    deallocate ( spsfunc_path, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'spsfunc_path' )

    call deallocate_test ( dx_dt, 'dx_dt', ModuleName )
    call deallocate_test ( d2x_dxdt, 'd2x_dxdt', ModuleName )

    call deallocate_test ( t_script, 't_srcipt', ModuleName )
    call deallocate_test ( ref_corr, 'ref_corr', ModuleName )
    call deallocate_test ( tau, 'tau', ModuleName )
    call deallocate_test ( ptg_angles, 'ptg_angles', ModuleName )

    deallocate ( k_atmos_frq, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_atmos_frq' )
    deallocate ( k_temp, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'k_temp' )
    deallocate ( k_atmos, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_atmos' )
    deallocate ( My_Catalog, stat=status)
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'My_catalog' )

    call deallocate_test ( radiances, 'Radiances', ModuleName )
    call deallocate_test ( i_star_all, 'i_star_all', ModuleName )
    call deallocate_test ( radv, 'rad_v', ModuleName )
    call deallocate_test ( grids, 'grids',  ModuleName )

!    if ( i > -22) Stop      ! DEBUG, Zvi
a1451 2
    Return

d1497 3
@


2.134
log
@Bug fix for non frequency avg. case
@
text
@d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.133 2001/05/17 00:49:54 livesey Exp $"
d1134 1
a1134 1
            if ( toggle(emit) .and. levels(emit) > 1 ) then
d1293 1
a1293 1
          if ( toggle(emit) .and. levels(emit) > 1 ) then
d1480 3
@


2.133
log
@Interim version.  Slight problem somewhere with convolution for some bands.
@
text
@d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.132 2001/05/16 23:03:59 livesey Exp $"
d872 2
a873 2

        call allocate_test ( frequencies,noFreqs, "frequencies", ModuleName )
d1480 3
@


2.132
log
@New version, now gets correct antenna pattern too.
@
text
@d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.131 2001/05/16 01:20:08 livesey Exp $"
d853 5
d1119 9
d1134 5
d1293 4
d1305 1
a1305 1
            &     antennaPatterns(1), ier )
d1480 3
@


2.131
log
@Interim version.  Does pointing grids and channel shapes right, not
yet antenna patterns.  Also can do forward model with multiple signals
@
text
@d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.130 2001/05/15 03:46:31 zvi Exp $"
d481 1
d840 2
a841 2
          superset(i) = AreSignalsSuperset ( pointingGrids(i)%signals, &
            & fwdModelConf%signals )
d1242 2
d1261 13
a1273 4
!          whichPattern = MatchSignal ( antennaPatterns%signal, &
!            & fwdModelConf%signals(sigInd), sideband=thisSideband, &
!            & channel=ch )
          whichPattern = 1
d1295 1
d1457 4
@


2.130
log
@Adding derivative flag to beta calculations
@
text
@d48 1
a48 1
  use MLSSignals_m, only: GetSignal, MaxSigLen, Signal_T, GetSignalName,&
d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.129 2001/05/14 23:18:26 livesey Exp $"
d346 1
a346 1
  subroutine FullForwardModel ( ForwardModelConfig, FwdModelIn, FwdModelExtra, &
d373 1
a373 1
    type(forwardModelConfig_T), intent(inout) :: forwardModelConfig
d410 2
a411 1
    type (VectorValue_T), pointer :: RADIANCE      ! Radiance quantity to be filled
d423 1
d434 1
d438 1
a438 2
    integer :: SIG0                     ! Lower part of signal range
    integer :: SIG1                     ! Upper part of signal range
d444 2
a445 1
    integer :: WHICHPOINTINGGRID        ! Index of poiting grid
d456 2
a457 2
    integer, dimension(:), pointer :: GRIDS            ! Frq grid for each tan_press
    integer, dimension(:), pointer :: SIGNALSGRID ! Used in ptg grid hunt
d459 1
a460 1
    logical, dimension(:), pointer :: ALLMATCH  ! Used in pointing grid hunt
a461 1
    logical, dimension(:), pointer :: THISMATCH ! Used in pointing grid hunt
d475 2
a476 2
!   real(r4), dimension(:), pointer :: TOAVG ! Stuff to be passed to frq.avg.
    real(kind(k_temp_frq%values)), dimension(:), pointer :: TOAVG ! Stuff to be passed to frq.avg.
d479 2
a480 3


    type(Signal_T), dimension(:), pointer :: ALLSIGNALS ! Used in ptg grid hunt
d486 2
a487 1
    type(signal_t) :: Signal
d498 1
a498 1
    nullify ( allMatch, beta_path, channelIndex, d2x_dxdt, dh_dt_path, dx_dt, &
d500 2
a501 2
      & ptg_angles, radiances, radV, ref_corr, signalsGrid, t_script, &
      & tau, thisMatch, usedChannels )
d505 12
a516 5
    ! Deal with multiple signals in later versions !??? NJL
    if ( size(forwardModelConfig%signals) > 1 ) call MLSMessage ( &
      & MLSMSG_Error,ModuleName, &
      & "Can't yet have multiple signals in forward model" )
    signal = forwardModelConfig%signals(1)
d519 2
a520 2
    radiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
      & signal= signal%index, sideband=signal%sideband )
d526 1
a526 1
      & quantityType=l_ptan, instrumentModule=signal%instrumentModule )
d528 1
a528 1
      & quantityType=l_elevOffset, radiometer=signal%radiometer )
d538 1
a538 1
      & quantityType=l_losVel, instrumentModule=signal%instrumentModule )
d542 1
a542 1
      & quantityType=l_sidebandRatio, signal= signal%index, noError=.true. )
d547 1
a547 1
    !   quantityType=l_vmr, molecule=forwardModelConfig.molecules(i))
a551 3
    if ( .not. ValidateVectorQuantity(radiance, minorFrame=.true.,&
      & frequencyCoordinate=(/l_channel/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'radiance' )
d564 1
a564 1
    noSpecies = size(forwardModelConfig%molecules)
d572 1
a572 1
        & quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie) )
d581 1
a581 1
      Spectag = spec_tags(forwardModelConfig%molecules(j))
d594 1
a594 1
    if ( ForwardModelConfig%temp_der ) then
d599 1
a599 1
    if ( forwardModelConfig%atmos_der ) then
d601 1
a601 1
        if ( forwardModelConfig%moleculeDerivatives(k) ) then
d603 1
a603 1
            &     quantityType=l_vmr, molecule=forwardModelConfig%molecules(k))
a618 3
    ! Work out what signal we're after
    signal = forwardModelConfig%signals(1)

d620 2
a621 2
    noMAFs = radiance%template%noInstances
    noMIFs = radiance%template%noSurfs
d623 3
a625 3
    no_tan_hts = ForwardModelConfig%TangentGrid%nosurfs
    maxVert = 2 * (NG+1) * size(ForwardModelConfig%integrationGrid%surfs)
    nlvl=size(ForwardModelConfig%integrationGrid%surfs)
d627 1
a627 1
    phiWindow = ForwardModelConfig%phiWindow
d643 24
a666 8
    ! Work out which channels are used
    call allocate_test ( channelIndex, size(signal%frequencies), &
    &                   'channelIndex', ModuleName )
    noUsedChannels = count ( signal%channels )
    call allocate_test ( usedChannels, noUsedChannels, 'channelIndex', &
                      &  ModuleName )
    do channel = 1, size( signal%frequencies)
      channelIndex(channel) = channel
a667 2
    usedChannels = pack ( channelIndex, signal%channels )
    call deallocate_test ( channelIndex,'channelIndex',ModuleName )
d669 1
d724 1
a724 1
      call FindClosestInstances ( temp, radiance, ifm%closestInstances )
d735 1
a735 1
      call hydrostatic_model ( ForwardModelConfig%SurfaceTangentIndex, &
d738 1
a738 1
        &  ForwardModelConfig%integrationGrid%surfs, &
d742 1
a742 1
        &  ForwardModelConfig%TangentGrid%surfs, &
d748 2
a749 2
      call comp_path_entities ( radiance, temp, ifm%closestInstances, &
        &  ForwardModelConfig%integrationGrid%noSurfs, &
a791 6
    ! Now work out what sideband(s) we're going to be doing
    if ( any( forwardModelConfig%signals%sideband .ne. &
      & forwardModelConfig%signals(1)%sideband ) ) &
      &  call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed sidebands in forward model config")

d794 4
d799 2
a800 2
      do j = 1, radiance%template%noSurfs
        radiance%values( ch + (j-1)*radiance%template%noChans, fmStat%maf) = 0.0
d804 1
a804 1
    if ( forwardModelConfig%signals(1)%sideband == 0 ) then
d812 1
a812 1
      sidebandStart = forwardModelConfig%signals(1)%sideband
d832 1
a832 1
      if ( forwardModelConfig%do_freq_avg ) then ! --- Doing freq. avg. ---
d835 3
a837 1
        totalSignals = 0
d839 2
a840 1
          totalSignals = totalSignals + size(pointingGrids(i)%signals)
d842 2
d845 7
a851 40
        allocate ( allSignals(totalSignals), STAT=status)
        call allocate_test ( signalsGrid,   totalSignals, 'signalsGrid',  &
          & ModuleName)
        
        totalSignals = 0
        do i = 1, size(pointingGrids)
          sig0 = totalSignals + 1
          sig1 = totalSignals + size(pointingGrids(i)%signals)
          allSignals(sig0:sig1) = pointingGrids(i)%signals
          signalsGrid(sig0:sig1) = i
          totalSignals = sig1
        end do
        
        call allocate_test ( allMatch, totalSignals, 'allMatch', ModuleName )
        call allocate_test ( thisMatch, totalSignals, 'thisMatch', ModuleName )
        
        allMatch = .true.
        do i = 1, size(forwardModelConfig%signals)
          j = MatchSignal ( allSignals, forwardModelConfig%signals(i), &
            & sideband=thisSideband, matchFlags=thisMatch )
          allMatch = allMatch .and. thisMatch
        end do
        
        if ( count (allMatch) == 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
          & 'No matching pointing frequency grids' )
        
        ! For the moment take the first match, later we'll be cleverer and choose
        ! the smallest.  Or maybe we'll turn this whole section into another routine.
        do i = 1, totalSignals
          if ( allMatch(i) ) exit
        end do
        whichPointingGrid = signalsGrid(i)
        
        call deallocate_test ( thisMatch, 'thisMatch', ModuleName )
        call deallocate_test ( allMatch, 'allMatch', ModuleName )
        
        deallocate ( allSignals, STAT=status)
        if ( status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
          & MLSMSG_DeAllocate//'allSignals')
        call deallocate_test ( signalsGrid, 'signalsGrid', ModuleName )
d855 1
a855 1
        call allocate_test ( grids, ForwardModelConfig%TangentGrid%nosurfs, &
d858 1
a858 1
          & ForwardModelConfig%TangentGrid%surfs, grids, allowTopValue=.true. )
d866 1
a866 1
        noFreqs = count( forwardModelConfig%signals(1)%channels )
d868 6
a873 2
        frequencies = pack( signal%frequencies, &
          & forwardModelConfig%signals(1)%channels )
d876 1
a876 1
          frequencies = signal%lo - (signal%centerFrequency+frequencies)
d878 1
a878 1
          frequencies = signal%lo + (signal%centerFrequency+frequencies)
d886 1
a886 1
        noFreqs = size(frequencies)
d926 1
a926 1
        &  forwardModelConfig%molecules, ifm%ndx_path(:,maf), no_tan_hts, &
d941 1
a941 1
        &  forwardModelConfig%tangentGrid%surfs, &
d949 1
a949 1
        &  forwardModelConfig%SurfaceTangentIndex, &
d974 1
a974 1
      if ( forwardModelConfig%do_freq_avg ) then
d985 1
a985 1
      if ( forwardModelConfig%temp_der ) then
d997 1
a997 1
          & quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie) )
d1000 1
a1000 1
        if ( forwardModelConfig%moleculeDerivatives(specie) ) then
d1020 1
a1020 1
   ! Compute the beta's along the path, for this tanget hight and this mmaf:
d1026 1
a1026 1
        if ( ForwardModelConfig%do_freq_avg ) then
d1034 3
a1036 3
          &                  forwardModelConfig%frqGap,             &
          &                  forwardModelConfig%temp_der,           &
          &                  forwardModelConfig%spect_der, Ier)
d1046 1
a1046 1
        if ( forwardModelConfig%temp_der ) then
d1074 1
a1074 1
            & forwardModelConfig%integrationGrid%noSurfs, h_tan, &
d1087 1
a1087 1
          Call Rad_Tran_WD ( ForwardModelConfig, FwdModelExtra, FwdModelIn, &
d1109 1
a1109 2
        if ( forwardModelConfig%do_freq_avg ) then
          centerFreq = signal%lo + thisSideband * signal%centerFrequency
d1111 1
d1113 11
a1123 4
            call Freq_Avg ( frequencies,                           &
              &       centerFreq+thisSideband*FilterShapes(ch)%FilterGrid, &
              &       FilterShapes(ch)%FilterShape, RadV, noFreqs,  &
              &       Size(FilterShapes(ch)%FilterGrid), Radiances(ptg_i,i) )
d1132 2
a1133 2
        if ( forwardModelConfig%temp_der ) then
          if ( forwardModelConfig%do_freq_avg ) then
d1135 1
d1137 5
d1147 5
a1151 3
                    &  centerFreq+thisSideband*FilterShapes(ch)%FilterGrid, &
                    &  FilterShapes(ch)%FilterShape, real(ToAvg,r8), &
                    &  noFreqs, Size(FilterShapes(ch)%FilterGrid), r )
d1168 1
a1168 1
          if ( forwardModelConfig%moleculeDerivatives(specie) ) then
d1170 2
a1171 2
              &  quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie))
            if ( forwardModelConfig%do_freq_avg ) then
d1173 8
a1180 2
                ch = usedChannels(i)
                do instance = lbound(k_atmos_frq(specie)%values,3),&
d1185 5
a1189 3
                      &  centerFreq+thisSideband*FilterShapes(ch)%FilterGrid, &
                      &  FilterShapes(ch)%FilterShape, real(ToAvg,r8),  &
                      &  noFreqs, Size(FilterShapes(ch)%FilterGrid), r )
d1221 1
a1221 1
        if ( ForwardModelConfig%temp_der ) then
d1225 1
a1225 1
        if ( ForwardModelConfig%atmos_der ) then
d1228 1
a1228 1
              & quantityType=l_vmr, molecule=forwardModelConfig%molecules(m),&
d1244 5
d1256 8
a1263 2
        if ( ForwardModelConfig%do_conv ) then
          call convolve_all ( forwardModelConfig, fwdModelIn, maf, ch, &
d1265 2
a1266 2
            &     temp, ptan, radiance, &
            &     ForwardModelConfig%tangentGrid%surfs, ptg_angles, &
d1274 3
a1276 3
          call no_conv_at_all ( forwardModelConfig, fwdModelIn, maf, ch,  &
            &     windowStart, windowFinish, temp, ptan, radiance, &
            &     ForwardModelConfig%tangentGrid%surfs, &
d1306 1
a1306 1
    if ( ForwardModelConfig%temp_der ) call deallocate_test &
d1308 1
a1308 1
    if ( ForwardModelConfig%atmos_der ) then
d1317 1
a1317 1
      if ( ForwardModelConfig%do_conv ) then
d1323 1
a1323 1
      if ( ForwardModelConfig%do_freq_avg ) then
d1335 1
a1335 1
        print 905, ( radiance%values(ch+(k-1)*radiance%template%noChans,maf),&
d1341 1
a1341 1
    if ( .not. forwardModelConfig%do_freq_avg ) call deallocate_test ( &
d1444 3
d1633 2
a1634 2
! Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
! some related stuff to fwdmdl/ForwardModelConfig.
d1772 1
a1772 1
! Added forward model type stuff to ForwardModelConfig_T and parser thereof
d1785 1
a1785 1
! New forwardModelConfig stuff and merge from Van
@


2.129
log
@Added frqGap parameter
@
text
@d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.128 2001/05/11 22:18:56 livesey Exp $"
d1042 3
a1044 1
          &                  forwardModelConfig%frqGap, ier )
d1418 3
@


2.128
log
@Changed first dimension of ifm%tan_dh_dt from nlvl to no_tan_hts.
Also tidied up allocates of ifm stuff.
@
text
@d30 1
a30 1
    & F_DO_CONV, F_DO_FREQ_AVG, F_FILTERSHAPES, F_FREQUENCY, &
d61 1
a61 1
  use Units, only: Deg2Rad
d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.127 2001/05/03 23:34:44 livesey Exp $"
d90 1
d206 1
d227 5
d1041 2
a1042 1
          &                  beta_path, 0.001*losVel%values(1,maf), ier )
d1408 2
d1416 4
@


2.127
log
@More stuff to support scan model
@
text
@d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.126 2001/05/03 20:31:34 vsnyder Exp $"
d690 1
a690 2
      call allocate_test ( ifm%tan_hts, &
        & size(ForwardModelConfig%tangentGrid%surfs), no_phi_t, 'tan_hts', &
d692 1
a692 2
      call allocate_test ( ifm%tan_temp, &
        & size(ForwardModelConfig%tangentGrid%surfs), no_phi_t, 'tan_hts', &
d694 1
a694 1
      call allocate_test ( ifm%tan_dh_dt, nlvl, no_phi_t, &
d1406 3
@


2.126
log
@Thought I needed to add a nullify, ended up with only cosmetic changes
@
text
@d32 2
a33 1
    & F_POINTINGGRIDS, F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, F_TYPE
d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.125 2001/05/02 20:31:43 livesey Exp $"
d225 2
d1408 3
@


2.125
log
@Removed frequency from config
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.124 2001/05/02 20:28:35 livesey Exp $"
d148 1
a148 1
    & ( ROOT, VGRIDS ) result(info)
d158 1
d169 2
d173 1
a175 1
    integer :: TANGENT                  ! Loop counter
d177 1
a178 4
    real (r8) :: Value(2)               ! Value returned by EXPR
    character (len=80) :: SIGNALSTRING  ! E.g. R1A....
    logical, dimension(:), pointer :: channels   ! From Parse_Signal
    integer, dimension(:), pointer :: SIGNALINDS ! From Parse_Signal
d377 3
a379 3
    integer(i4) :: i, j, k, m, n, no_tan_hts, ch, Spectag, ier, &
                   maf, si, ptg_i, frq_i, brkpt, no_ele, mid, ilo, ihi, &
                   lmax, max_phi_dim, max_zeta_dim
d390 1
a390 5
    real(r8) :: Frq, H_tan, Rad, Geod_lat, Phi_tan, R

    Real(r8), dimension(:), allocatable :: dum

    real(r8), dimension(:), pointer :: RadV
d438 2
d443 1
d447 3
a449 2
    logical, dimension(:), pointer :: ALLMATCH ! Used in pointing grid hunt
    logical, dimension(:), pointer :: THISMATCH ! USed in pointing grid hunt
d451 1
a451 2
    real(r4), dimension(:),     pointer :: TOAVG       ! Stuff to be passed to frq.avg.
    real(r8), dimension(:),     pointer :: FREQUENCIES ! Frequency points
d453 1
d455 10
a464 1
    real(r8), dimension(:,:),   pointer :: D2X_DXDT    ! (No_tan_hts, Tsurfs)
a465 1
    real(r8), dimension(:,:),   pointer :: REF_CORR    ! (n2lvl, no_tan_hts)
a466 8
    real(r8), dimension(:),     pointer :: PTG_ANGLES  ! (no_tan_hts)

    real(r4), dimension(:,:,:,:), pointer :: K_TEMP    ! (channel,Nptg,mxco,mnp)
    real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS ! (channel,Nptg,mxco,mnp,Nsps)
    real(r8), dimension(:,:), pointer :: RADIANCES     ! (Nptg,noChans)
    real(r8), dimension(:,:), pointer :: I_STAR_ALL    ! (noMIFs,noChans)

    integer, pointer, dimension(:) :: GRIDS            ! Frq grid for each tan_press
a467 1
    logical :: FOUNDINFIRST             ! Flag to indicate derivatives
d469 1
a469 1
    type(Signal_T), pointer, dimension(:) :: ALLSIGNALS ! Used in ptg grid hunt
d471 1
a471 1
    type(path_vector), allocatable, dimension(:) :: N_PATH    ! (No_tan_hts)
d476 1
a476 1
    type(catalog_T), pointer, dimension(:) :: My_Catalog
d486 4
a489 4
    nullify ( radV, channelIndex, usedChannels, frequencies, dh_dt_path, &
      & dx_dt, d2x_dxdt, t_script, ref_corr, tau, ptg_angles, k_temp, &
      & k_atmos, radiances, grids, my_Catalog, beta_path, allMatch, thisMatch,&
      & signalsGrid, i_star_all )
d1164 1
a1164 1
                    k_atmos(i,ptg_i,surface,instance,specie) = r
d1405 3
@


2.124
log
@Removed some dead variables.
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.123 2001/04/28 17:47:42 livesey Exp $"
a199 1
    info%the_freq = 0.0
d1406 3
@


2.123
log
@Passes row flags to convolve and no convolve
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.122 2001/04/28 01:44:09 vsnyder Exp $"
a157 1
    type (signal_T) :: thisSignal ! A signal
a224 24
      case ( f_frequency )
        call expr ( subtree(2,son), units, value, type )
        info%the_freq = value(1)
        !       case ( f_channels )
        !         if ( .not. associated( info%signals ) ) then
        !           call AnnounceError(DefineSignalsFirst, key)
        !         else
        !           noChannelsSpecs=noChannelsSpecs+1
        !           thisSignal => info%signals(noChannelsSpecs)
        !           ! Now default to none included
        !           thisSignal%channels = .false.
        !           do j = 2, nsons(son)
        !             call expr ( subtree(j,son), units, value, type )
        !             select case (type)
        !             case (num_value)
        !               thisFWMSignal%channelIncluded(int(value(1))) = .true.
        !             case (range)
        !               thisFWMSignal%channelIncluded(int(value(1)):int(value(2))) =&
        !                 & .true.
        !             case default
        !               ! Shouldn't get here if parser worked
        !             end select
        !           end do
        !         end if
d378 2
a379 2
    integer(i4) :: i, j, k, m, n, ht_i, mnz, no_tan_hts, ch, Spectag, ier, &
                   maf, si, ptg_i, frq_i, klo, brkpt, no_ele, mid, ilo, ihi, &
d391 1
a391 1
    real(r8) :: Zeta, Frq, H_tan, Rad, Geod_lat, Phi_tan, R
a394 6
    character (len=01) :: CA
    character (len=08) :: Name
    character (len=16) :: Vname
    character (len=80) :: Line
    character (len=40) :: Ax, Dtm1, Dtm2

a417 1
    integer :: MIF                      ! Loop counter
a418 1
    integer :: NAMELEN                  ! Length of string
a443 1
    real (r8) :: SENSE                  ! Multiplier (+/-1)
d1407 3
@


2.122
log
@Make debugging output conditional on toggle(emit) etc.
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.121 2001/04/26 22:53:37 zvi Exp $"
d351 1
a351 1
      if ( any(got( (/f_atmos_der, f_do_conv, f_do_freq_avg, f_frequency /) )) ) &
d1268 1
a1268 1
            &     thisRatio, Jacobian, &
d1277 1
a1277 1
            &     thisRatio, Jacobian )
d1441 3
@


2.121
log
@Fixing some phiwindow bug
@
text
@d56 1
a56 1
  use Toggles, only: Emit, Gen, Levels, Toggle
d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.120 2001/04/26 20:02:09 livesey Exp $"
d642 1
a642 1
    ! Get some dimensions which we'll use a lot
a650 11
    print*,'Dimensions:'
    print*,'noMAFs:',noMAFs
    print*,'no_phi_t:',no_phi_t
    print*,'no_tan_hts:',no_tan_hts
    print*,'maxVert:',maxVert
    print*,'nlvl:',nlvl
    print*,'n2lvl:',n2lvl
    print*,'phiWindow:',phiWindow
    print*,'noSpecies:',noSpecies
    print*,'maxNoFSurfs:',maxNoFSurfs
    print*,'MAF:',fmStat%maf
d652 13
d684 1
a684 1
      allocate (ifm%ndx_path(No_tan_hts,noMAFs), stat=status )
d687 1
a687 1
      allocate (ifm%dhdz_path(No_tan_hts,noMAFs), stat=status )
d690 1
a690 1
      allocate (ifm%h_path(No_tan_hts,noMAFs), stat=status )
d693 1
a693 1
      allocate (ifm%phi_path(No_tan_hts,noMAFs), stat=status )
d696 1
a696 1
      allocate (ifm%t_path(No_tan_hts,noMAFs), stat=status )
d699 1
a699 1
      allocate (ifm%z_path(No_tan_hts,noMAFs), stat=status )
d703 1
a703 1
      allocate (ifm%eta_phi(No_tan_hts,noMAFs), stat=status )
d734 1
a734 1
      call FindClosestInstances( temp, radiance, ifm%closestInstances )
d803 2
a804 2
    if (any ( forwardModelConfig%signals%sideband .ne. &
      & forwardModelConfig%signals(1)%sideband ) )&
d852 2
a853 2
        allocate (allSignals(totalSignals), STAT=status)
        call allocate_test( signalsGrid,   totalSignals, 'signalsGrid',  &
d865 2
a866 2
        call allocate_test( allMatch, totalSignals, 'allMatch', ModuleName )
        call allocate_test( thisMatch, totalSignals, 'thisMatch', ModuleName )
d869 1
a869 1
        do i = 1, size ( forwardModelConfig%signals)
d885 2
a886 2
        call deallocate_test( thisMatch, 'thisMatch', ModuleName )
        call deallocate_test( allMatch, 'allMatch', ModuleName )
d888 1
a888 1
        deallocate (allSignals, STAT=status)
d891 1
a891 1
        call deallocate_test(signalsGrid, 'signalsGrid', ModuleName)
a929 4
      if ( toggle(emit) .and. levels(emit) > 0 ) then
        call output ( 'Doing MAF: ' )
        call output ( maf, advance='yes' )
      end if
d940 6
a945 3
      Print *,'mafTInstance:',mafTInstance
      print*,'WindowStart:',WindowStart
      print*,'WindowFinish:',WindowFinish
d994 1
a994 1
      call refraction_correction(no_tan_hts, ifm%tan_hts(:,mafTInstance), &
d996 1
a996 1
        &  ifm%E_rad(mafTInstance), ref_corr)
d1037 1
a1037 1
          allocate (k_atmos_frq(specie)%values(maxNoFreqs,f%template%noSurfs,&
d1081 9
a1089 12
          if ( ier /= 0 ) then
            Print *,'** ALLOCATE Error: dum or dh_dt_path, stat =',ier
            goto 99
          else
            do j = 1, temp%template%noSurfs
              do i = 1, phiWindow
                m = min(lmax,i+windowStart-1)
                call Lintrp ( ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,&
                  &           ifm%dh_dt_glgrid(:,m,j), dum, ifm%gl_count,&
                  &           no_ele )
                dh_dt_path(:,i,j) = dum(:) * ifm%eta_phi(ptg_i,maf)%values(:,m)
              end do
d1091 4
a1094 2
            deallocate ( dum, stat=i )
          end if
d1110 1
a1110 1
            & ifm%dHdz_path(k,maf), earthRefl%values(1,1),beta_path(:,frq_i), &
d1119 1
d1121 6
a1126 6
            &  ifm%elvar(maf), frq_i, Frq, noSpecies, ifm%z_path(k, maf), &
            &  ifm%h_path(k, maf), ifm%t_path(k, maf), ifm%phi_path(k, maf), &
            &  ifm%dHdz_path(k, maf), beta_path(:, frq_i), spsfunc_path(:, &
            &  k), temp%template%surfs(:, 1), temp%template%noSurfs, &
            &  ref_corr(:, k), temp%template%noInstances, &
            &  temp%template%phi(1, :)*Deg2Rad, dh_dt_path, k_temp_frq, &
d1157 1
d1184 1
d1225 1
a1225 1
      ! Complete the radiances's last location, also complete k_temp last
d1266 3
a1268 3
            &     ifm%tan_temp(:,maf), dx_dt, d2x_dxdt,si, center_angle, &
            &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
            &     thisRatio,Jacobian, &
d1277 1
a1277 1
            &     thisRatio,Jacobian )
a1288 1
    ! ------------------------------ End of Major Frame Specific stuff --------
d1291 1
d1303 1
a1303 1
    deallocate(beta_path,STAT=k)
d1305 2
a1306 2
    if(ForwardModelConfig%temp_der) call deallocate_test (k_temp_frq%values,&
      & "k_temp_frq%values", ModuleName )
d1309 1
a1309 1
        call deallocate_test (k_atmos_frq(j)%values, "k_atmos_frq(j)%values",&
d1314 7
a1320 1
    ! *** DEBUG Print
d1322 7
a1328 5
    if ( ForwardModelConfig%do_conv ) then
      print *,'Convolution: ON'
    else
      print *,'Convolution: OFF'
    end if
d1330 8
a1337 6
    if ( .not. ForwardModelConfig%do_freq_avg ) then
      Frq = Frequencies(1)
      print *,'Frequency Averaging: OFF'
      write(6,'(A,f12.4,a1)') ' (All computations done at Frq =',Frq,')'
    else
      print *,'Frequency Averaging: ON'
a1338 1
    print *
d1340 1
a1340 1
    if ( .not. forwardModelConfig%do_freq_avg) call deallocate_test ( &
a1342 9
    do i = 1, noUsedChannels
      ch = usedChannels(i)
      write(*,903) ch, char(92), ptan%template%noSurfs
      write(*,905) ( radiance%values(ch+(k-1)*radiance%template%noChans,maf),&
        & k = 1, ptan%template%noSurfs )
    end do
903 format('ch',i2.2,'_pfa_rad',a1,i3.3)
905 format(4(2x,1pg15.8))

a1346 2
913 format(a,a1,i2.2)

d1441 3
@


2.120
log
@Made l2pc database a saved array in L2PC_m
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.119 2001/04/26 19:47:53 livesey Exp $"
d403 3
a405 4
    integer(i4) :: i, j, k, ht_i, mnz, no_tan_hts, ch, Spectag, &
      m, ier, maf, si, ptg_i, frq_i, klo, n, brkpt, no_ele, &
      mid, ilo, ihi, k_info_count, ld, &
      max_phi_dim, max_zeta_dim
d663 1
d936 1
a936 2
      windowStart = max(1,ifm%closestInstances(maf)-phiWindow/2)
      windowFinish = min(ifm%closestInstances(maf)+phiWindow/2, temp%template%noInstances)
d939 7
d1053 1
d1055 1
a1055 1
        ! Compute the beta's along the path, for this tanget hight and this mmaf:
d1084 1
a1084 1
            do j = 1,  temp%template%noSurfs
d1086 1
a1086 1
                m = i + windowStart - 1
d1088 2
a1089 2
                  &           ifm%dh_dt_glgrid(:,m,j), dum, &
                  &           ifm%gl_count, no_ele )
d1230 1
a1230 2
          k_temp(i,no_tan_hts,1:n,1:phiWindow) = &
            & k_temp(i,no_tan_hts-1,1:n,1:phiWindow)
a1237 1
              k = f%template%noInstances
d1239 1
a1239 2
              k_atmos(i,no_tan_hts,1:n,1:phiWindow,m)= &
                & k_atmos(i,no_tan_hts-1,1:n,1:phiWindow,m)
d1440 3
@


2.119
log
@Renamed main routine to full forward model
@
text
@d40 1
a40 1
  use L2PC_M, only: L2PC_T, OPEN_L2PC_FILE, READ_L2PC_FILE, CLOSE_L2PC_FILE
d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.118 2001/04/26 02:50:47 vsnyder Exp $"
d95 1
a95 1
  subroutine ForwardModelGlobalSetup ( Root, l2pcDatabase )
a99 1
    type (L2PC_T), pointer, dimension(:) :: l2pcDatabase
d136 1
a136 1
        call read_l2pc_file (lun, l2pcDatabase )
d1436 3
@


2.118
log
@Cosmetic changes
@
text
@d67 1
a67 1
  public :: ConstructForwardModelConfig, ForwardModel, &
d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.117 2001/04/26 02:49:52 vsnyder Exp $"
d363 1
a363 1
  subroutine ForwardModel ( ForwardModelConfig, FwdModelIn, FwdModelExtra, &
d1394 1
a1394 1
  end subroutine ForwardModel
d1437 3
@


2.117
log
@Moved *_indices declarations from init_tables_module to intrinsic (again)
@
text
@d16 1
a63 1
  use dump_0, only: Dump
d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.116 2001/04/26 02:44:17 vsnyder Exp $"
d1437 3
@


2.116
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.115 2001/04/26 00:06:58 livesey Exp $"
d137 1
a137 1
        call read_l2pc_file (lun, lit_indices, l2pcDatabase )
d1437 3
@


2.115
log
@Added l2pc reading to global setup
@
text
@d26 1
a26 2
  use Init_Tables_Module, only: FIELD_FIRST, FIELD_INDICES, FIELD_LAST, &
    & LIT_INDICES, SPEC_INDICES
d67 1
a67 1
  public :: ConstructForwardModelConfig, Dump, ForwardModel, &
a69 4
  interface Dump
    module procedure MyDump_ForwardModelConfigs
  end interface

d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.114 2001/04/25 00:50:33 livesey Exp $"
d122 1
a122 1
        call read_antenna_patterns_file ( lun, spec_indices )
d127 1
a127 1
        call read_filter_shapes_file ( lun, spec_indices )
d132 1
a132 1
        call read_pointing_grid_file ( lun, spec_indices )
d279 1
a279 1
          call parse_Signal ( signalString, signalInds, spec_indices, &
a1433 6
  ! ---------------------------------  MyDump_ForwardModelConfigs  -----
  subroutine MyDump_ForwardModelConfigs ( ForwardModelConfigs )
    type(forwardModelConfig_T), pointer, dimension(:) :: ForwardModelConfigs
    call dump ( forwardModelConfigs, lit_indices )
  end subroutine MyDump_ForwardModelConfigs

d1437 3
@


2.114
log
@Changed maxPath to maxVert, better name
@
text
@d31 1
a31 1
    & F_INTEGRATIONGRID, F_MOLECULES, F_MOLECULEDERIVATIVES, F_PHIWINDOW, &
d40 1
d77 1
a77 1
    & "$Id: ForwardModelInterface.f90,v 2.113 2001/04/25 00:09:48 vsnyder Exp $"
d100 1
a100 1
  subroutine ForwardModelGlobalSetup ( Root )
d105 1
d139 5
d1448 3
@


2.113
log
@Use 'levels(emit)' to control output detail
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.112 2001/04/24 23:11:04 vsnyder Exp $"
a442 2
    integer :: WHICHPOINTINGGRID        ! Index of poiting grid
    integer :: MIF                      ! Loop counter
d444 1
d448 4
a451 1
    integer :: MAXPATH                  ! Number of points on longest path
a452 2
    integer :: N2LVL                    ! Twice size of tangent grid
    integer :: NOUSEDCHANNELS           ! Number of channels to output
d456 2
a458 2
    integer :: NOSPECIES                ! Number of molecules we're considering
    integer :: NAMELEN                  ! Length of string
d466 1
a467 1
    integer :: STATUS                   ! From allocates etc.
d470 1
a470 1
    integer :: INSTANCE                 ! Loop counter
d647 1
a647 1
    maxPath = 2 * (NG+1) * size(ForwardModelConfig%integrationGrid%surfs)
d655 1
a655 1
    print*,'maxPath:',maxPath
d711 2
a712 2
      call allocate_test ( ifm%z_glgrid, maxPath/2, 'z_glgrid', ModuleName )
      call allocate_test ( ifm%h_glgrid, maxPath, no_phi_t, 'h_glgrid', &
d714 1
a714 1
      call allocate_test ( ifm%t_glgrid, maxPath, no_phi_t, 't_glgrid', &
d716 1
a716 1
      call allocate_test ( ifm%dh_dt_glgrid, maxPath, no_phi_t, &
d718 1
a718 1
      call allocate_test ( ifm%dhdz_glgrid, maxPath, no_phi_t, &
d1441 3
@


2.112
log
@Use 'emit' toggle (set by -f option or @@E) to control output
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.111 2001/04/24 19:44:48 vsnyder Exp $"
a927 1
        call trace_begin ( 'ForwardModel.MAF' )
d1040 1
a1040 1
        if ( toggle(emit) .and. levels(emit) > 0 ) then
d1093 1
a1093 1
          if ( toggle(emit) .and. levels(emit) > 0 ) then
d1122 1
a1122 1
          if ( toggle(emit) .and. levels(emit) > 0 ) &
d1131 1
a1131 1
        if ( toggle(emit) .and. levels(emit) > 0 ) &
d1203 1
a1203 1
        if ( toggle(emit) .and. levels(emit) > 0 ) &
d1208 1
a1208 1
        if ( toggle(emit) .and. levels(emit) > 0 ) &
d1441 3
@


2.111
log
@Add 'toggle(gen)' stuff in ForwardModel
@
text
@d55 1
a55 1
  use Toggles, only: Gen, Toggle
d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.110 2001/04/24 00:03:36 livesey Exp $"
d113 1
a113 1
    if ( toggle(gen) ) call trace_begin ( "ForwardModelGlobalSetup", root )
d142 1
a142 1
    if ( toggle(gen) ) call trace_end ( "ForwardModelGlobalSetup" )
d516 1
a516 1
    if ( toggle(gen) ) call trace_begin ( "ForwardModel" )
d677 2
a678 1
      if ( toggle(gen) ) call trace_begin ( "ForwardModel.hydrostatic" )
d766 2
a767 1
      if ( toggle(gen) ) call trace_end ( "ForwardModel.hydrostatic" )
d830 2
a831 2
      if ( toggle(gen) ) then
        call trace_begin ( "ForwardModel.sideband" )
d842 2
a843 1
        if ( toggle(gen) ) call trace_begin ( "ForwardModel.FreqAvg" )
d896 2
a897 1
        if ( toggle(gen) ) call trace_end ( "ForwardModel.FreqAvg" )
d901 2
a902 1
        if ( toggle(gen) ) call trace_begin ( "ForwardModel.NotFreqAvg" )
d920 2
a921 1
        if ( toggle(gen) ) call trace_end ( "ForwardModel.NotFreqAvg" )
d927 2
a928 2
      if ( toggle(gen) ) then
        call trace_begin ( "ForwardModel.MAF" )
d952 2
a953 2
      if ( toggle(gen) ) &
        call trace_begin ( 'ForwardModel.get_path_spsfunc_ngrid' )
d958 2
a959 2
      if ( toggle(gen) ) &
        call trace_end ( 'ForwardModel.get_path_spsfunc_ngrid' )
d967 2
a968 1
      if ( toggle(gen) ) call trace_begin ( 'ForwardModel.get_chi_angles' )
d980 2
a981 1
      if ( toggle(gen) ) call trace_end ( 'ForwardModel.get_chi_angles' )
d985 1
a985 1
      if ( toggle(gen) ) &
d990 1
a990 1
      if ( toggle(gen) ) &
d1041 1
a1041 1
        if ( toggle(gen) ) then
d1094 1
a1094 1
          if ( toggle(gen) ) then
d1123 2
a1124 1
          if ( toggle(gen) ) call trace_end ( 'ForwardModel.Frequencies' )
d1132 2
a1133 1
        if ( toggle(gen) ) call trace_begin ( 'ForwardModel.FrequencyAvg' )
d1204 2
a1205 1
        if ( toggle(gen) ) call trace_end ( 'ForwardModel.FrequencyAvg' )
d1209 2
a1210 1
        if ( toggle(gen) ) call trace_end ( 'ForwardModel.Pointing' )
d1242 2
a1243 1
      if ( toggle(gen) ) call trace_begin ( 'ForwardModel.Convolution' )
d1275 2
a1276 1
      if ( toggle(gen) ) call trace_end ( 'ForwardModel.Convolution' )
d1278 2
a1279 1
      if ( toggle(gen) ) call trace_end ( "ForwardModel.sideband" )
d1389 1
a1389 1
    if ( toggle(gen) ) call trace_end ( "ForwardModel" )
d1442 3
@


2.110
log
@Bug fix
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.109 2001/04/23 22:22:50 livesey Exp $"
d516 2
d585 1
d677 2
a678 1
      print*,'(re)computing hydrostatic stuff.'
d764 2
d827 9
a835 2
      print 901,thisSideband,sidebandStart,sidebandStop
901   format(' Doing sideband: ',i2,' (',i2,', ',i2,')')
d840 1
d887 2
a888 2
   ! Now we've identified the pointing grids.  Locate the tangent grid within
   ! it.
d893 1
d897 1
d915 1
d921 5
a925 1
      print*,'Doing maf:',maf
d946 2
d952 2
d961 1
d973 1
d977 2
d982 2
d988 1
a988 1
      ! corresponding to delta function responses, we can setup the frequency
d990 1
a990 1
      ! averaging the frequency grid varies from pointing to pointing, and is
d1028 1
a1028 1
      end do ! End loop over speices
d1033 4
d1086 4
d1115 1
d1123 1
d1194 2
d1198 2
d1230 1
d1262 1
d1264 1
d1374 2
d1427 3
@


2.109
log
@Working version.  Can now have no_phi_t /= noMAFs
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.108 2001/04/23 22:09:54 zvi Exp $"
d402 1
a402 1
    integer(i4) :: i, j, k, kz, ht_i, mnz, no_tan_hts, ch, Spectag, &
a657 1
!   fmStat%maf = 3       ! DEBUG, Zvi
a819 1
!  print*,'Doing sideband:', thisSideband, '( ',sidebandStart,sidebandStop,')'
a859 1
        print*,'All match:',allMatch
d1005 1
a1005 1
   ! Compute the beta's along the path, for this tanget hight and this mmaf:
d1025 1
a1025 1
        call allocate_test ( dh_dt_path, no_ele, temp%template%noInstances, &
d1035 2
a1036 1
              do i = 1, temp%template%noInstances
d1038 3
a1040 3
                  &           ifm%dh_dt_glgrid(:,i,j), dum, ifm%gl_count,&
                  &           no_ele )
                dh_dt_path(:,i,j) = dum(:) * ifm%eta_phi(ptg_i,maf)%values(:,i)
d1377 3
@


2.108
log
@Re-Introducing no_phi_t etc.
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.107 2001/04/23 21:56:06 livesey Exp $"
d700 1
a700 1
      allocate ( ifm%elvar(noMAFs), stat=status )
d704 2
a705 2
      call allocate_test ( ifm%geoc_lat, noMAFs, 'geoc_lat', ModuleName )
      call allocate_test ( ifm%e_rad, noMAFs, 'e_rad', ModuleName )
d1379 3
@


2.107
log
@Pass closest instances to comp_path_entities
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.106 2001/04/23 21:42:46 zvi Exp $"
d658 1
d935 1
a935 1
      phi_tan = Deg2Rad * temp%template%phi(1,maf)
d940 3
a942 2
        &  forwardModelConfig%tangentGrid%surfs,      &
        &  ifm%tan_hts(:,maf),ifm%tan_temp(:,maf),phi_tan,ifm%elvar(maf)%Roc,&
d945 2
a946 1
        &  ifm%tan_dh_dt(:,maf,:), no_tan_hts, temp%template%noSurfs, &
d953 1
a953 1
      call refraction_correction(no_tan_hts, ifm%tan_hts(:,maf), &
d955 1
a955 1
        &  ifm%E_rad(maf), ref_corr)
d1006 1
a1006 1
        h_tan = ifm%tan_hts(k,maf)
d1379 3
@


2.106
log
@Introducing no_phi_t etc.
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.105 2001/04/21 01:21:29 livesey Exp $"
a479 1
    integer, dimension(:), pointer :: CLOSESTINSTANCES ! To each maf
a657 1
    fmStat%maf = 3                          ! DEBUG, Zvi
d723 1
d726 1
a726 1
      ! Assert radiance%template%noInstances=temp%template%noInstances
d728 5
a732 8
      if ( temp%template%noInstances /= noMAFs ) &
        & call MLSMessage(MLSMSG_Error,ModuleName,'no temperature profiles /= no maf')
      do maf = 1, noMAFs
        phi_tan = Deg2Rad*temp%template%phi(1,maf)
        ! ??? For the moment, change this soon.
        geod_lat= Deg2Rad*temp%template%geodLat(1,maf)
        call geoc_geod_conv ( ifm%elvar(maf), orbIncline%values(1,1), &
          &  phi_tan, geod_lat, ifm%geoc_lat(maf), ifm%E_rad(maf) )
d750 1
a750 1
      call comp_path_entities ( radiance, temp, &
d911 3
a913 7
      nullify(closestInstances)
      call Allocate_test(closestInstances, noMAFs, 'closestInstances', ModuleName)
      call FindClosestInstances( temp, radiance, closestInstances )
      windowStart = max(1,closestInstances(maf)-phiWindow/2)
      windowFinish = min(closestInstances(maf)+phiWindow/2, temp%template%noInstances)
      mafTInstance = closestInstances(maf)
      call Deallocate_test(closestInstances, 'closestInstances', ModuleName)
d1323 1
a1323 1
    if ( i > -22) Stop      ! DEBUG, Zvi
d1376 3
@


2.105
log
@Fixed memory leak properly!
@
text
@d36 2
a37 2
    & L_REFGPH, L_SCAN, L_SCGEOCALT, L_SIDEBANDRATIO, L_SPACERADIANCE, L_TEMPERATURE, &
    & L_VMR
d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.104 2001/04/20 23:34:54 livesey Exp $"
d456 1
d643 1
d651 1
d659 1
d663 2
a664 2
    call allocate_test ( channelIndex, size(signal%frequencies), 'channelIndex', &
      & ModuleName )
d666 2
a667 1
    call allocate_test ( usedChannels, noUsedChannels, 'channelIndex', ModuleName )
a707 2
      call allocate_test ( ifm%h_glgrid, maxPath, noMAFs, 'h_glgrid', ModuleName )
      call allocate_test ( ifm%t_glgrid, maxPath, noMAFs, 't_glgrid', ModuleName )
d709 5
a713 1
      call allocate_test ( ifm%dh_dt_glgrid, maxPath, noMAFs, &
d715 2
a716 1
      call allocate_test ( ifm%dhdz_glgrid, maxPath, noMAFs, 'dhdz_glgrid', ModuleName )
d718 2
a719 1
        & size(ForwardModelConfig%tangentGrid%surfs), noMAFs, 'tan_hts', ModuleName )
d721 4
a724 3
        & size(ForwardModelConfig%tangentGrid%surfs), noMAFs, 'tan_hts', ModuleName )
      call allocate_test ( ifm%tan_dh_dt, nlvl, noMAFs, &
        & temp%template%noSurfs, 'tan_dh_dt', ModuleName )
d742 1
a742 1
        &  noMAFs, ifm%geoc_lat, 0.001*refGPH%values(1,:), &
d759 1
a759 1
        &  ifm%dhdz_path, ifm%eta_phi, temp%template%noInstances,           &
d824 4
a827 1
      print*,'Doing sideband:', thisSideband, '( ',sidebandStart,sidebandStop,')'
d879 2
a880 2
        ! Now we've identified the pointing grids.  Locate the tangent grid within
        ! it.
d936 3
a938 3
        &     forwardModelConfig%molecules, ifm%ndx_path(:,maf), no_tan_hts, &
        &     ifm%z_path(:,maf), ifm%t_path(:,maf), ifm%phi_path(:,maf), n_path, &
        &     spsfunc_path, Ier )
d947 8
a954 8
        &     forwardModelConfig%tangentGrid%surfs,      &
        &     ifm%tan_hts(:,maf), ifm%tan_temp(:,maf), phi_tan, ifm%elvar(maf)%Roc, &
        &     0.001*scGeocAlt%values(1,1),  &
        &     elevOffset%values(1,1), &
        &     ifm%tan_dh_dt(:,maf,:), no_tan_hts, temp%template%noSurfs, &
        &     temp%template%surfs(:,1), &
        &     forwardModelConfig%SurfaceTangentIndex, &
        &     center_angle, ptg_angles, dx_dt, d2x_dxdt, ier )
d999 1
a999 1
          allocate ( k_atmos_frq(specie)%values( maxNoFreqs, f%template%noSurfs, &
d1013 1
a1013 1
        ! Compute the beta's along the path, for this tanget hight and this mmaf:
d1044 3
a1046 2
                call Lintrp ( ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,       &
                  &           ifm%dh_dt_glgrid(:,i,j), dum, ifm%gl_count, no_ele )
d1114 3
a1116 3
                    &        centerFreq+thisSideband*FilterShapes(ch)%FilterGrid, &
                    &        FilterShapes(ch)%FilterShape, real(ToAvg,r8), &
                    &        noFreqs, Size(FilterShapes(ch)%FilterGrid), r )
d1143 3
a1145 3
                      &          centerFreq+thisSideband*FilterShapes(ch)%FilterGrid, &
                      &          FilterShapes(ch)%FilterShape, real(ToAvg,r8),  &
                      &          noFreqs, Size(FilterShapes(ch)%FilterGrid), r )
d1225 1
a1225 1
    ! ---------------------------- End of loop over sideband --------------------
a1281 48
!     ! ** DEBUG, Zvi
!     !   if ( i > -22) Stop
!     ! ** END DEBUG

!     if ( .not. any((/ForwardModelConfig%temp_der,&
!       & ForwardModelConfig%atmos_der,ForwardModelConfig%spect_der/)) ) goto 99

!     m = ptan%template%noSurfs
!     tau(1:m) = ptan%values(1:m,3)
!     tau(m+1:) = 0.0

!     klo = -1
!     Zeta = -1.666667
!     call Hunt_zvi ( Zeta, tau, m, klo, j )
!     if ( abs(Zeta-tau(j)) < abs(Zeta-tau(klo))) klo=j

!     m = -1
!     ch = 1
!     tau = 0.0
!     do i = 1, k_info_count
!       print *
!       Name = ' '
!       Name = k_star_info(i)%name
!       if ( Name == 'PTAN') cycle
!       kz = k_star_info(i)%first_dim_index
!       mnz = k_star_info(i)%no_zeta_basis
!       ht_i = k_star_info(i)%no_phi_basis
!       nameLen = len_trim(Name)
!       if ( Name(nameLen-1:nameLen) == '_W' .or.  &
!         &   Name(nameLen-1:nameLen) == '_N' .or.  &
!         &   Name(nameLen-1:nameLen) == '_V' ) then
!         print *,Name
! !        r = sum(k_star_all(ch,kz,1:mnz,1:ht_i,klo))
!         print *,'  Sum over all zeta & phi coeff:',sngl(r)
!       else
!         if ( Name == 'TEMP' ) then
!           write(6,913) 'dI_dT',char(92),ht_i
!         else
!           write(6,913) 'dI_d'//Name(1:nameLen),char(92),ht_i
!         end if
!         tau = 0.0
!         tau(1:mnz) = k_star_info(i)%zeta_basis(1:mnz)
!         call Hunt_zvi ( Zeta, tau, mnz, m, j )
!         if ( abs(Zeta-tau(j)) < abs(Zeta-tau(m))) m=j
! !        print *,(k_star_all(ch,kz,m,j,klo),j=1,ht_i)
!       end if
!     end do

d1329 1
d1331 1
a1331 10
    if ( fmStat%Finished ) then

      call deallocate_test ( grids, 'grids',  ModuleName )
      call deallocate_test ( radV, 'radV', ModuleName )

    end if

    ! ** DEBUG, Zvi
    !         if ( i > -22) Stop
    ! ** END DEBUG
d1358 1
a1358 1
      call output ( 'signals must be defined before channels.', advance='yes')
d1360 1
a1360 1
      call output ( 'incomplete full foward model specification', advance='yes' )
d1368 2
a1369 2
      call output ( 'non subsurface tangent grid not a subset of integration grid', &
        & advance='yes' )
d1384 3
@


2.104
log
@Fixed sideband code
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.103 2001/04/20 23:08:55 livesey Exp $"
d852 1
d856 1
a856 1
        whichPointingGrid = i
d1362 1
d1426 3
@


2.103
log
@Cleaned up confusion in multi-channel cases
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.102 2001/04/20 02:59:40 livesey Exp $"
d1076 1
a1076 7
          if ( signal%sideband == 0 ) then
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Asked for folded in wrong place' )
          else
            sense = signal%sideband
            centerFreq = signal%lo + sense * signal%centerFrequency
          end if
d1080 1
a1080 1
              &       centerFreq+sense*FilterShapes(ch)%FilterGrid, &
d1099 1
a1099 1
                    &        centerFreq+sense*FilterShapes(ch)%FilterGrid, &
d1128 1
a1128 1
                      &          centerFreq+sense*FilterShapes(ch)%FilterGrid, &
d1424 3
@


2.102
log
@Whoops typo!
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.101 2001/04/20 02:55:19 livesey Exp $"
d791 8
d974 1
a1056 1
          if ( ForwardModelConfig%temp_der ) k_temp_frq%values = 0.0_r8
d1088 1
a1088 1
              &       Size(FilterShapes(ch)%FilterGrid), Radiances(ptg_i,ch) )
d1091 1
a1091 1
          Radiances(ptg_i,usedChannels) = RadV(1:noFreqs)
d1108 1
a1108 1
                  k_temp(ch,ptg_i,surface,instance) = r
d1115 1
a1115 1
                &  k_temp_frq%values(1,1:temp%template%noSurfs,:)
d1137 1
a1137 1
                    k_atmos(ch,ptg_i,surface,instance,specie) = r
d1145 1
a1145 1
                  &  k_atmos_frq(specie)%values(1,1:surface,:)
d1161 1
a1161 1
        Radiances(no_tan_hts,ch) = Radiances(no_tan_hts-1,ch)
d1186 6
a1193 4

          ! Note I am replacing the i's in the k's with 1's (enclosed in
          ! brackets to make it clear.)  We're not wanting derivatives anyway
          ! so it shouldn't matter
d1199 2
a1200 2
            &     Radiances(:,ch), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
            &     i_star_all(i,:),Jacobian, &
a1204 1

d1208 2
a1209 2
            &     Radiances(:,ch), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
            &     i_star_all(i,:),Jacobian )
a1214 23
      do channel = 1, noUsedChannels
        ! Work out factor to multiply by
        if ( sidebandStart /= sidebandStop ) then ! We're folding
          thisRatio = sidebandRatio%values(usedChannels(Channel),1)
          if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
        else ! Otherwise, want just unfolded signal
          thisRatio = 1.0
        end if

        do mif = 1, radiance%template%noSurfs
          ! Work out index
          k = usedChannels(channel)+(mif-1)*radiance%template%noChans

          ! If first sideband, place answer in else add to result
          if ( thisSideband == sidebandStart ) then
            radiance%values(k,maf) = thisRatio*i_star_all(channel,mif)
          else
            radiance%values(k,maf) = radiance%values(k,maf) + &
              & thisRatio*i_star_all(channel,mif)
          end if
        end do
      end do

d1430 3
@


2.101
log
@Now writes back derivatives in Jacobian!!! Not folded yet though,
but that will be easy!
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.100 2001/04/19 23:55:04 livesey Exp $"
d631 1
a631 1
      & call Allocate_test ( fmStat%rows, Jacobian%row%nb, 'fmStat%rows', &
d634 1
d1444 4
@


2.100
log
@Interim version, new convolve etc. but no derivatives
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.99 2001/04/19 22:24:09 livesey Exp $"
a365 1
!    use L2PC_FILE_PARAMETERS, only: mxco => MAX_NO_ELMNTS_PER_SV_COMPONENT
a366 2
!    use L2PCdim, only: NSPS, Nptg, MNP => max_no_phi, &
!      MNM => max_no_mmaf
d408 1
a408 1
    type(k_matrix_info) :: K_star_info(20)
d446 1
d630 1
a630 1
    if ( present(Jacobian) .and. ( .not. associated (fmStat%rows) ) ) &
d632 2
a633 1
      & ModuleName)
d897 1
d1183 3
a1185 2
          call convolve_all ( forwardModelConfig, fwdModelIn, maf, &
            &     windowStart, windowFinish, temp, ptan, radiance, &
d1195 1
a1195 1
          call no_conv_at_all ( forwardModelConfig, fwdModelIn, maf, &
d1286 47
a1332 47
    ! ** DEBUG, Zvi
    !   if ( i > -22) Stop
    ! ** END DEBUG

    if ( .not. any((/ForwardModelConfig%temp_der,&
      & ForwardModelConfig%atmos_der,ForwardModelConfig%spect_der/)) ) goto 99

    m = ptan%template%noSurfs
    tau(1:m) = ptan%values(1:m,3)
    tau(m+1:) = 0.0

    klo = -1
    Zeta = -1.666667
    call Hunt_zvi ( Zeta, tau, m, klo, j )
    if ( abs(Zeta-tau(j)) < abs(Zeta-tau(klo))) klo=j

    m = -1
    ch = 1
    tau = 0.0
    do i = 1, k_info_count
      print *
      Name = ' '
      Name = k_star_info(i)%name
      if ( Name == 'PTAN') cycle
      kz = k_star_info(i)%first_dim_index
      mnz = k_star_info(i)%no_zeta_basis
      ht_i = k_star_info(i)%no_phi_basis
      nameLen = len_trim(Name)
      if ( Name(nameLen-1:nameLen) == '_W' .or.  &
        &   Name(nameLen-1:nameLen) == '_N' .or.  &
        &   Name(nameLen-1:nameLen) == '_V' ) then
        print *,Name
!        r = sum(k_star_all(ch,kz,1:mnz,1:ht_i,klo))
        print *,'  Sum over all zeta & phi coeff:',sngl(r)
      else
        if ( Name == 'TEMP' ) then
          write(6,913) 'dI_dT',char(92),ht_i
        else
          write(6,913) 'dI_d'//Name(1:nameLen),char(92),ht_i
        end if
        tau = 0.0
        tau(1:mnz) = k_star_info(i)%zeta_basis(1:mnz)
        call Hunt_zvi ( Zeta, tau, mnz, m, j )
        if ( abs(Zeta-tau(j)) < abs(Zeta-tau(m))) m=j
!        print *,(k_star_all(ch,kz,m,j,klo),j=1,ht_i)
      end if
    end do
d1443 3
@


2.99
log
@More moving window stuff sorted out, now uses FindClosestInstance
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.98 2001/04/19 22:09:32 livesey Exp $"
d366 1
a366 1
    use L2PC_FILE_PARAMETERS, only: mxco => MAX_NO_ELMNTS_PER_SV_COMPONENT
d368 2
a369 2
    use L2PCdim, only: NSPS, Nptg, MNP => max_no_phi, &
      MNM => max_no_mmaf
d410 1
a410 2
    real(r8) :: I_STAR_ALL(25,Nptg)
    real(r4) :: K_STAR_ALL(25,20,mxco,mnp,Nptg)
d457 1
d500 2
a501 1
    real(r8), dimension(:,:), pointer :: Radiances     ! (Nptg,25)
d525 1
a525 1
      & signalsGrid )
d608 1
a608 1
!
d617 1
a617 1
!
d630 6
a635 1
!
d641 1
d782 2
d1183 2
a1184 2
          call convolve_all ( forwardModelConfig, fwdModelIn, &
            &     ptan%values(:,maf), noSpecies, &
d1188 2
a1189 4
            &     no_tan_hts, k_info_count, i_star_all(i,:), &
            &     k_star_all(i,:,:,:,:), k_star_info, &
            &     temp%template%noSurfs, temp%template%noInstances, &
            &     temp%template%surfs(:,1), antennaPatterns(1), ier )
d1194 2
a1195 2
          call no_conv_at_all ( forwardModelConfig, fwdModelIn, &
            &     ptan%values(:,maf), noSpecies,  &
d1198 1
a1198 4
            &     no_tan_hts, k_info_count, i_star_all(i,:), &
            &     k_star_all(i,:,:,:,:), k_star_info, &
            &     temp%template%noSurfs, temp%template%noInstances, &
            &     temp%template%surfs(:,1) )
d1317 1
a1317 1
        r = sum(k_star_all(ch,kz,1:mnz,1:ht_i,klo))
d1329 1
a1329 1
        print *,(k_star_all(ch,kz,m,j,klo),j=1,ht_i)
d1378 1
d1442 3
@


2.98
log
@New calling sequence for comp_path_entities
@
text
@d40 1
d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.97 2001/04/19 20:59:50 livesey Exp $"
d481 1
d882 8
a889 3
      ! a bit in later versions to avoid the noMAFS==noTemp/f instances assertion
      windowStart = max(1,maf-phiWindow/2)
      windowFinish = min(maf+phiWindow/2, temp%template%noInstances)
d1437 3
@


2.97
log
@Reordered a loop
@
text
@d75 1
a75 1
    & "$Id: ForwardModelInterface.f90,v 2.96 2001/04/19 20:42:34 livesey Exp $"
d735 2
a736 1
      call comp_path_entities ( ForwardModelConfig%integrationGrid%noSurfs, &
d1430 3
@


2.96
log
@Minor bug in calls to freq_avg fixed.  Going to change agains soon
anyway
@
text
@d75 1
a75 1
    & "$Id: ForwardModelInterface.f90,v 2.95 2001/04/19 20:31:14 livesey Exp $"
a772 1

a844 4
        if ( whichPointingGrid <= 0 ) &
          call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "There is no pointing grid for the desired signal" )
        
a1124 1

d1192 8
a1199 9
      do mif = 1, radiance%template%noSurfs
        do channel = 1, noUsedChannels
          ! Work out factor to multiply by
          if ( sidebandStart /= sidebandStop ) then ! We're folding
            thisRatio = sidebandRatio%values(usedChannels(Channel),1)
            if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
          else ! Otherwise, want just unfolded signal
            thisRatio = 1.0
          end if
d1201 1
d1429 4
@


2.95
log
@Removed stuff that destroyed ifm (now upto calling code, e.g. in
SidsModule) to do it.  Also added sideband folding loop, works
for radiances, not derivatives yet.
@
text
@d75 1
a75 1
    & "$Id: ForwardModelInterface.f90,v 2.94 2001/04/19 08:13:06 zvi Exp $"
d1065 3
a1067 3
              &       centerFreq+sense*FilterShapes(i)%FilterGrid, &
              &       FilterShapes(i)%FilterShape, RadV, noFreqs,  &
              &       Size(FilterShapes(i)%FilterGrid), Radiances(ptg_i,ch) )
d1084 3
a1086 3
                    &        centerFreq+sense*FilterShapes(i)%FilterGrid, &
                    &        FilterShapes(i)%FilterShape, real(ToAvg,r8), &
                    &        noFreqs, Size(FilterShapes(i)%FilterGrid), r )
d1113 3
a1115 3
                      &          centerFreq+sense*FilterShapes(i)%FilterGrid, &
                      &          FilterShapes(i)%FilterShape, real(ToAvg,r8),  &
                      &          noFreqs, Size(FilterShapes(i)%FilterGrid), r )
d1230 1
a1230 1
          DEALLOCATE ( beta_path(i,j)%values, beta_path(i,j)%t_power, &
d1435 5
@


2.94
log
@Some more leaks..
@
text
@d36 1
a36 1
    & L_REFGPH, L_SCAN, L_SCGEOCALT, L_SPACERADIANCE, L_TEMPERATURE, &
d75 1
a75 1
    & "$Id: ForwardModelInterface.f90,v 2.92 2001/04/17 09:16:12 zvi Exp $"
d250 1
a250 1
                             & ModuleName )
d280 1
a280 1
        exit
d291 4
a294 4
           info%signals(j)%channels(1:lbound(channels,1)-1) = .false.
           info%signals(j)%channels(lbound(channels,1):ubound(channels,1)) = &
             channels
           info%signals(j)%channels(ubound(channels,1)+1:) = .false.
d433 1
a433 3
    type (VectorValue_T), pointer :: RADIANCE      ! Radiance quantity to be filled
    type (VectorValue_T), pointer :: TEMP          ! Temperature quantity
    type (VectorValue_T), pointer :: PTAN          ! PTAN quantity
d435 2
d438 2
a439 2
    type (VectorValue_T), pointer :: SPACERADIANCE ! Space radiance
    type (VectorValue_T), pointer :: EARTHREFL     ! Earth reflectivity
a440 1
    type (VectorValue_T), pointer :: LOSVEL        ! Line of sight velocity
d442 3
a444 1
    type (VectorValue_T), pointer :: F             ! An arbitrary species
d460 3
d468 1
d476 1
d555 2
d568 1
a568 1
        & ModuleName, InvalidQuantity//'radiance' )
d571 1
a571 1
        & ModuleName, InvalidQuantity//'temperature' )
d574 1
a574 1
        & ModuleName, InvalidQuantity//'ptan' )
d577 2
a578 2
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & InvalidQuantity//'elevOffset' )
a646 1
    fmStat%maf = 3                      ! DEBUG, Zvi
d746 3
a772 12
    ! The first part of the forward model dealt with the chunks as a whole.
    ! This next part is more complex, and is performed within a global outer
    ! loop over major frame (maf)

    ! First we need to identify the pointing grid we're going to be using.
    ! I might as well go the whole way and deal with the multiple signals case
    ! while I'm about it.  The surrounding code can't yet support that though

    totalSignals = 0
    do i = 1, size(pointingGrids)
      totalSignals = totalSignals + size(pointingGrids(i)%signals)
    end do
d774 103
a876 13
    allocate (allSignals(totalSignals), STAT=status)
    call allocate_test( signalsGrid,   totalSignals, 'signalsGrid',  &
      & ModuleName)

    totalSignals = 0
    do i = 1, size(pointingGrids)
!     print*,3,i
      sig0 = totalSignals + 1
      sig1 = totalSignals + size(pointingGrids(i)%signals)
      allSignals(sig0:sig1) = pointingGrids(i)%signals
      signalsGrid(sig0:sig1) = i
      totalSignals = sig1
    end do
d878 1
a878 2
    call allocate_test( allMatch, totalSignals, 'allMatch', ModuleName )
    call allocate_test( thisMatch, totalSignals, 'thisMatch', ModuleName )
d880 2
a881 5
    allMatch = .true.
    do i = 1, size ( forwardModelConfig%signals)
      j = MatchSignal ( allSignals, forwardModelConfig%signals(i), thisMatch )
      allMatch = allMatch .and. thisMatch
    end do
d883 4
a886 2
    if ( count (allMatch) == 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
      & 'No matching pointing frequency grids' )
d888 8
a895 6
    ! For the moment take the first match, later we'll be cleverer and choose
    ! the smallest.  Or maybe we'll turn this whole section into another routine.
    do i = 1, totalSignals
      if ( allMatch(i) ) exit
    end do
    whichPointingGrid = i
d897 2
a898 2
    call deallocate_test( thisMatch, 'thisMatch', ModuleName )
    call deallocate_test( allMatch, 'allMatch', ModuleName )
d900 5
a904 34
    deallocate (allSignals, STAT=status)
    if ( status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
      & MLSMSG_DeAllocate//'allSignals')
    call deallocate_test(signalsGrid, 'signalsGrid', ModuleName)

    if ( whichPointingGrid <= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "There is no pointing grid for the desired signal" )

    ! Now we've identified the pointing grids.  Locate the tangent grid within
    ! it.
    call allocate_test ( grids, ForwardModelConfig%TangentGrid%nosurfs, &
      "Grids", ModuleName )
    call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
      & ForwardModelConfig%TangentGrid%surfs, grids, allowTopValue=.true. )

    ! ---------------------------- Begin main MAF Specific stuff --------

    maf=fmStat%maf
    print*,'Doing maf:',maf

    ! Now work out what `window' we're inside.  This will need to be changed
    ! a bit in later versions to avoid the noMAFS==noTemp/f instances assertion
    windowStart = max(1,maf-phiWindow/2)
    windowFinish = min(maf+phiWindow/2, temp%template%noInstances)

    allocate ( k_temp(noUsedChannels, no_tan_hts, temp%template%noSurfs, &
      & windowStart:windowFinish), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_temp' )
    allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
      & windowStart:windowFinish, noSpecies), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_atmos' )
d906 2
a907 2
    ! Compute the specie function (spsfunc) and the refraction along
    ! all the paths for the current maf
d909 12
a920 58
    Call get_path_spsfunc_ngrid ( fwdModelIn, fwdModelExtra, &
      &     forwardModelConfig%molecules, ifm%ndx_path(:,maf), no_tan_hts, &
      &     ifm%z_path(:,maf), ifm%t_path(:,maf), ifm%phi_path(:,maf), n_path, &
      &     spsfunc_path, Ier )
    if ( ier /= 0 ) goto 99

    !??? Choose better value for phi_tan later
    phi_tan = Deg2Rad * temp%template%phi(1,maf)

    ! Compute the ptg_angles (chi) for Antenna convolution, also the
    ! derivatives of chi w.r.t to T and other parameters
    call get_chi_angles ( ifm%ndx_path(:,maf), n_path, &
      &     forwardModelConfig%tangentGrid%surfs,      &
      &     ifm%tan_hts(:,maf), ifm%tan_temp(:,maf), phi_tan, ifm%elvar(maf)%Roc, &
      &     0.001*scGeocAlt%values(1,1),  &
      &     elevOffset%values(1,1), &
      &     ifm%tan_dh_dt(:,maf,:), no_tan_hts, temp%template%noSurfs, &
      &     temp%template%surfs(:,1), &
      &     forwardModelConfig%SurfaceTangentIndex, &
      &     center_angle, ptg_angles, dx_dt, d2x_dxdt, ier )
    if ( ier /= 0 ) goto 99

    ! Compute the refraction correction scaling matrix for this mmaf:
    call refraction_correction(no_tan_hts, ifm%tan_hts(:,maf), &
      &  ifm%h_path(:,maf), n_path, ifm%ndx_path(:,maf),      &
      &  ifm%E_rad(maf), ref_corr)

    Radiances = 0.0

    ! If we're not doing frequency averaging, instead outputting radiances
    ! corresponding to delta function responses, we can setup the frequency
    ! information here.  In the more common case where we are doing the
    ! averaging the frequency grid varies from pointing to pointing, and is
    ! allocated inside the pointing loop.
    if ( .not. forwardModelConfig%do_freq_avg ) then
      ! Think later about multiple signals case!???
      noFreqs = count( forwardModelConfig%signals(1)%channels )
      call allocate_test ( frequencies,noFreqs, "frequencies", ModuleName )
      frequencies = pack( signal%frequencies, &
        & forwardModelConfig%signals(1)%channels )
!%%%%%%%%%%%%% DEBUG NJL
      print*,'Signal sideband:',signal%sideband
      signal%sideband=-1
!%%%%%%%%%%%%%%
      select case ( signal%sideband )
      case ( -1 )
        frequencies = signal%lo - (signal%centerFrequency+frequencies)
      case ( +1 )
        frequencies = signal%lo + (signal%centerFrequency+frequencies)
      case ( 0 )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Folded signal requested in forward model' )
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Bad value of signal%sideband' )
      end select
      noFreqs = size(frequencies)
    end if
d922 12
a933 7
    ! First we have a mini loop over pointings to work out an upper limit
    ! for the number of frequencies we're going to be dealing with
    maxNoFreqs = size(PointingGrids(whichPointingGrid)%OneGrid(grids(1))%Frequencies)
    do ptg_i = 2, no_tan_hts - 1
      maxNoFreqs = max ( maxNoFreqs, size(PointingGrids(whichPointingGrid) &
        & %OneGrid(grids(ptg_i))%Frequencies) )
    end do
d935 11
a945 7
    ! Now allocate arrays this size
    if ( forwardModelConfig%temp_der ) then
      allocate ( k_temp_frq%values( maxNoFreqs, temp%template%noSurfs, &
        & windowStart:windowFinish), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
        & MLSMSG_Allocate//'k_temp_frq' )
    end if
d947 3
a949 9
    call allocate_test ( radV,maxNoFreqs, 'radV', ModuleName )

    do specie = 1, noSpecies
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie) )

      ! Allocate intermediate space for vmr derivatives
      if ( forwardModelConfig%moleculeDerivatives(specie) ) then
        allocate ( k_atmos_frq(specie)%values( maxNoFreqs, f%template%noSurfs, &
d952 1
a952 1
          & MLSMSG_Allocate//'k_atmos_frq' )
d955 1
a955 1
    end do ! End loop over speices
d957 13
a969 16
    ! Now we can go ahead and loop over pointings
    ! ------------------------------ Begin loop over pointings --------
    do ptg_i = 1, no_tan_hts - 1
      k = ptg_i
      h_tan = ifm%tan_hts(k,maf)

      ! Compute the beta's along the path, for this tanget hight and this mmaf:

      no_ele = ifm%ndx_path(ptg_i,maf)%total_number_of_elements

      ! If we're doing frequency averaging, get the frequencies we need for
      ! this pointing.
      if ( ForwardModelConfig%do_freq_avg ) then
        frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
        noFreqs = size(frequencies)
      end if ! If not, we dealt with this outside the loop
d971 21
a991 4
      call get_beta_path ( frequencies, my_Catalog, no_ele, &
        &                  ifm%z_path(ptg_i,maf), ifm%t_path(ptg_i,maf), &
        &                  beta_path, 0.001*losVel%values(1,maf), ier )
      if ( ier /= 0 ) goto 99
d993 1
a993 1
      ! Define the dh_dt_path for this pointing and this MAF:
d995 1
a995 1
      ! Need to allocate this even if no derivatives as we pass it
d997 2
a998 2
      call allocate_test ( dh_dt_path, no_ele, temp%template%noInstances, &
        & temp%template%noSurfs, "dh_dt_path", ModuleName )
d1000 12
a1011 11
      if ( forwardModelConfig%temp_der ) then
        allocate ( dum(no_ele), stat=ier )
        if ( ier /= 0 ) then
          Print *,'** ALLOCATE Error: dum or dh_dt_path, stat =',ier
          goto 99
        else
          do j = 1,  temp%template%noSurfs
            do i = 1, temp%template%noInstances
              call Lintrp ( ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,       &
                &           ifm%dh_dt_glgrid(:,i,j), dum, ifm%gl_count, no_ele )
              dh_dt_path(:,i,j) = dum(:) * ifm%eta_phi(ptg_i,maf)%values(:,i)
d1013 2
a1014 2
          end do
          deallocate ( dum, stat=i )
a1015 1
      end if
d1017 2
a1018 2
      ! ------------------------------- Begin loop over frequencies ------
      do frq_i = 1, noFreqs
d1020 1
a1020 1
        Frq = frequencies(frq_i)
d1022 24
a1045 8
        Call Rad_Tran ( ifm%elvar(maf), Frq, &
          & forwardModelConfig%integrationGrid%noSurfs, h_tan, &
          & noSpecies, ifm%ndx_path(k,maf), ifm%z_path(k,maf), &
          & ifm%h_path(k,maf), ifm%t_path(k,maf), ifm%phi_path(k,maf), &
          & ifm%dHdz_path(k,maf), earthRefl%values(1,1),beta_path(:,frq_i), &
          & spsfunc_path(:,k), ref_corr(:,k), spaceRadiance%values(1,1), &
          & brkpt, no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier )
        if ( ier /= 0 ) goto 99
d1047 1
a1047 1
        RadV(frq_i) = Rad
d1049 1
a1049 1
        ! Now, Compute the radiance derivatives:
d1051 2
a1052 11
        if ( ForwardModelConfig%temp_der ) k_temp_frq%values = 0.0_r8
        Call Rad_Tran_WD ( ForwardModelConfig, FwdModelExtra, FwdModelIn, &
          &  ifm%elvar(maf), frq_i, Frq, noSpecies, ifm%z_path(k, maf), &
          &  ifm%h_path(k, maf), ifm%t_path(k, maf), ifm%phi_path(k, maf), &
          &  ifm%dHdz_path(k, maf), beta_path(:, frq_i), spsfunc_path(:, &
          &  k), temp%template%surfs(:, 1), temp%template%noSurfs, &
          &  ref_corr(:, k), temp%template%noInstances, &
          &  temp%template%phi(1, :)*Deg2Rad, dh_dt_path, k_temp_frq, &
          &  k_atmos_frq, brkpt, no_ele, mid, ilo, ihi, t_script, tau, &
          &  max_zeta_dim, max_phi_dim, ier )
        if ( ier /= 0 ) goto 99
a1053 29
      end do                          ! Frequency loop

      ! ----------------------------- End loop over frequencies ----

      ! Here we either frequency average to get the unconvolved radiances, or
      ! we just store what we have as we're using delta funciton channels

      if ( forwardModelConfig%do_freq_avg ) then
        if ( signal%sideband == 0 ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Asked for folded in wrong place' )
        else
          sense = signal%sideband
          centerFreq = signal%lo + sense * signal%centerFrequency
        end if
        do i = 1, noUsedChannels
          ch = usedChannels(i)
          call Freq_Avg ( frequencies,                           &
            &       centerFreq+sense*FilterShapes(i)%FilterGrid, &
            &       FilterShapes(i)%FilterShape, RadV, noFreqs,  &
            &       Size(FilterShapes(i)%FilterGrid), Radiances(ptg_i,ch) )
        end do
      else
        Radiances(ptg_i,usedChannels) = RadV(1:noFreqs)
      end if

      ! Frequency Average the temperature derivatives with the appropriate
      ! filter shapes
      if ( forwardModelConfig%temp_der ) then
d1055 7
d1064 5
a1068 12
            do instance = lbound(k_temp_frq%values,3), &
              & ubound(k_temp_frq%values,3)
              do surface = 1, temp%template%noSurfs
                ToAvg => k_temp_frq%values(1:noFreqs,surface,instance)
                call Freq_Avg ( frequencies,                        &
                  &        centerFreq+sense*FilterShapes(i)%FilterGrid, &
                  &        FilterShapes(i)%FilterShape, real(ToAvg,r8), &
                  &        noFreqs, Size(FilterShapes(i)%FilterGrid), r )
                k_temp(ch,ptg_i,surface,instance) = r
              end do                  ! Surface loop
            end do                    ! Instance loop
          end do                      ! Channel loop
d1070 1
a1070 4
          do i = 1, noUsedChannels
            k_temp(i,ptg_i,1:temp%template%noSurfs,:) = &
              &  k_temp_frq%values(1,1:temp%template%noSurfs,:)
          end do
a1071 1
      end if
d1073 3
a1075 6
      ! Frequency Average the atmospheric derivatives with the appropriate
      ! filter shapes
      do specie = 1, noSpecies
        if ( forwardModelConfig%moleculeDerivatives(specie) ) then
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            &  quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie))
d1079 13
a1091 14
              do instance = lbound(k_atmos_frq(specie)%values,3),&
                & ubound(k_atmos_frq(specie)%values,3)
                do surface = 1, f%template%noSurfs
                  ToAvg => k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
                  call Freq_Avg ( frequencies,                      &
                    &          centerFreq+sense*FilterShapes(i)%FilterGrid, &
                    &          FilterShapes(i)%FilterShape, real(ToAvg,r8),  &
                    &          noFreqs, Size(FilterShapes(i)%FilterGrid), r )
                  k_atmos(ch,ptg_i,surface,instance,specie) = r
                end do                ! Surface loop
              end do                  ! Instance loop
            end do                    ! Channel loop
          else                        ! Else not frequency averaging
            surface = f%template%noSurfs
d1093 2
a1094 2
              k_atmos(i,ptg_i,1:surface,:,specie) = &
                &  k_atmos_frq(specie)%values(1,1:surface,:)
d1096 2
a1097 3
          end if                      ! Frequency averaging or not
        end if                        ! Want derivatives for this
      end do                          ! Loop over species
d1099 62
d1162 2
a1163 1
      call deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )
d1165 1
a1165 2
    end do                            ! Pointing Loop
    ! ---------------------------------- End of Pointing Loop ---------------
d1167 1
a1167 2
    ! Complete the radiances's last location, also complete k_temp last
    ! location.
d1169 15
a1183 22
    do i = 1, noUsedChannels
      ch = usedChannels(i)
      Radiances(no_tan_hts,ch) = Radiances(no_tan_hts-1,ch)
      if ( ForwardModelConfig%temp_der ) then
        n = temp%template%noSurfs
        k_temp(i,no_tan_hts,1:n,1:phiWindow) = &
          & k_temp(i,no_tan_hts-1,1:n,1:phiWindow)
      end if
      if ( ForwardModelConfig%atmos_der ) then
        do m = 1, noSpecies
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            & quantityType=l_vmr, molecule=forwardModelConfig%molecules(m),&
            & foundInFirst=foundInFirst )
          if ( foundInFirst ) then
            k = f%template%noInstances
            n = f%template%noSurfs
            k_atmos(i,no_tan_hts,1:n,1:phiWindow,m)= &
              & k_atmos(i,no_tan_hts-1,1:n,1:phiWindow,m)
          end if
        end do
      end if
    end do
d1185 8
a1192 2
    !  Here comes the Convolution code
    do i = 1, noUsedChannels
d1194 1
a1194 1
      ch = usedChannels(i)
d1196 1
a1196 1
      if ( ForwardModelConfig%do_conv ) then
d1198 9
a1206 15
        ! Note I am replacing the i's in the k's with 1's (enclosed in
        ! brackets to make it clear.)  We're not wanting derivatives anyway
        ! so it shouldn't matter
        call convolve_all ( forwardModelConfig, fwdModelIn, &
          &     ptan%values(:,maf), noSpecies, &
          &     ForwardModelConfig%tangentGrid%surfs, ptg_angles, &
          &     ifm%tan_temp(:,maf), dx_dt, d2x_dxdt,si, center_angle, &
          &     Radiances(:,ch), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
          &     no_tan_hts, k_info_count, i_star_all(i,:), &
          &     k_star_all(i,:,:,:,:), k_star_info, &
          &     temp%template%noSurfs, temp%template%noInstances, &
          &     temp%template%surfs(:,1), antennaPatterns(1), ier )
        !??? Need to choose some index other than 1 for AntennaPatterns ???
        if ( ier /= 0 ) goto 99
      else
d1208 2
a1209 8
        call no_conv_at_all ( forwardModelConfig, fwdModelIn, &
          &     ptan%values(:,maf), noSpecies,  &
          &     ForwardModelConfig%tangentGrid%surfs, &
          &     Radiances(:,ch), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
          &     no_tan_hts, k_info_count, i_star_all(i,:), &
          &     k_star_all(i,:,:,:,:), k_star_info, &
          &     temp%template%noSurfs, temp%template%noInstances, &
          &     temp%template%surfs(:,1) )
d1211 9
a1219 1
      end if
a1220 7
    end do                            ! Channel loop

    do mif = 1, radiance%template%noSurfs
      do channel = 1, noUsedChannels
        k = usedChannels(channel)+(mif-1)*radiance%template%noChans
        radiance%values(k,maf) = i_star_all(channel,mif)
      end do
d1222 1
a1222 1

d1271 2
a1272 1
      write(*,905) ( i_star_all(i,k), k = 1, ptan%template%noSurfs )
d1334 1
a1334 1
         & MLSMSG_Deallocate//'n_path%values' )
d1338 1
a1338 1
           & MLSMSG_Deallocate//'spsfunc_path%values' )
d1344 1
a1344 1
       & MLSMSG_Deallocate//'n_path' )
d1348 1
a1348 1
       & MLSMSG_Deallocate//'spsfunc_path' )
a1374 62
      deallocate (ifm%ndx_path, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'ndx_path' )
!
      do j = 1, noMAFs
        do i = 1, No_tan_hts
          deallocate (ifm%z_path(i,j)%values, stat=status )
          if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//'z_path%values' )
          deallocate (ifm%h_path(i,j)%values, stat=status )
          if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//'h_path%values' )
          deallocate (ifm%t_path(i,j)%values, stat=status )
          if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//'t_path%values' )
          deallocate (ifm%phi_path(i,j)%values, stat=status )
          if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//'phi_path%values' )
          deallocate (ifm%dhdz_path(i,j)%values, stat=status )
          if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//'dhdz_path%values' )
          deallocate (ifm%eta_phi(i,j)%values, stat=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
            & MLSMSG_Allocate//'eta_phi%values' )
        end do
      end do
!
      deallocate (ifm%z_path, stat=status )
      if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'z_path' )
      deallocate (ifm%h_path, stat=status )
      if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'h_path' )
      deallocate (ifm%t_path, stat=status )
      if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'t_path' )
      deallocate (ifm%phi_path, stat=status )
      if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'phi_path' )
      deallocate (ifm%dhdz_path, stat=status )
      if( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'dhdz_path' )
      deallocate (ifm%eta_phi, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'eta_phi' )

      deallocate ( ifm%elvar, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'elvar' )

      call deallocate_test ( ifm%geoc_lat, 'geoc_lat', ModuleName )
      call deallocate_test ( ifm%e_rad, 'e_rad', ModuleName )

      call deallocate_test ( ifm%h_glgrid, 'h_glgrid', ModuleName )
      call deallocate_test ( ifm%t_glgrid, 't_glgrid', ModuleName )
      call deallocate_test ( ifm%z_glgrid, 'z_glgrid', ModuleName )
      call deallocate_test ( ifm%dh_dt_glgrid, 'dh_dt_glgrid', ModuleName )
      call deallocate_test ( ifm%dhdz_glgrid, 'dhdz_glgrid', ModuleName )
      call deallocate_test ( ifm%tan_hts,'tan_hts', ModuleName )
      call deallocate_test ( ifm%tan_temp,'tan_temp', ModuleName )
      call deallocate_test ( ifm%tan_dh_dt, 'tan_dh_dt', ModuleName )

d1381 1
a1381 1
         if ( i > -22) Stop
d1388 1
a1388 1
! =====     Private Procedures     =====================================
d1435 3
@


2.93
log
@Fixing Memory leaks ..
@
text
@d639 1
a639 1
!   fmStat%maf = 3                      ! DEBUG, Zvi
d1385 1
d1388 3
d1394 1
a1394 1
    !    if ( i > -22) Stop
@


2.92
log
@Taking care of a whole buch of deallocation statements ..
@
text
@d75 1
a75 1
    & "$Id: ForwardModelInterface.f90,v 2.91 2001/04/17 01:01:34 vsnyder Exp $"
d250 1
a250 1
          & moduleName )
d252 1
a252 1
          & "info%moleculeDerivatives", moduleName )
d644 1
a644 1
      & moduleName )
d646 1
a646 1
    call allocate_test ( usedChannels, noUsedChannels, 'channelIndex', moduleName )
d651 1
a651 1
    call deallocate_test ( channelIndex,'channelIndex',moduleName )
d684 2
a685 2
      call allocate_test ( ifm%geoc_lat, noMAFs, 'geoc_lat', moduleName )
      call allocate_test ( ifm%e_rad, noMAFs, 'e_rad', moduleName )
d687 3
a689 3
      call allocate_test ( ifm%h_glgrid, maxPath, noMAFs, 'h_glgrid', moduleName )
      call allocate_test ( ifm%t_glgrid, maxPath, noMAFs, 't_glgrid', moduleName )
      call allocate_test ( ifm%z_glgrid, maxPath/2, 'z_glgrid', moduleName )
d691 2
a692 2
        & temp%template%noSurfs,'dh_dt_glgrid', moduleName )
      call allocate_test ( ifm%dhdz_glgrid, maxPath, noMAFs, 'dhdz_glgrid', moduleName )
d694 1
a694 1
        & size(ForwardModelConfig%tangentGrid%surfs), noMAFs, 'tan_hts', moduleName )
d696 1
a696 1
        & size(ForwardModelConfig%tangentGrid%surfs), noMAFs, 'tan_hts', moduleName )
d698 1
a698 1
        & temp%template%noSurfs, 'tan_dh_dt', moduleName )
d729 4
a732 5
        &  temp%template%noSurfs, &
        &  ifm%gl_count, ifm%ndx_path, ifm%z_glgrid, ifm%t_glgrid, &
        &  ifm%h_glgrid, ifm%dhdz_glgrid, ifm%tan_hts, no_tan_hts, ifm%z_path, &
        &  ifm%h_path, ifm%t_path, &
        &  ifm%phi_path, ifm%dhdz_path, ifm%eta_phi, temp%template%noInstances, &
d756 1
a756 1
      & 'dx_dt', moduleName )
d758 1
a758 1
      & 'd2x_dxdt', moduleName )
d761 1
a761 1
      & 'Radiances', moduleName )
d818 1
a818 1
      call MLSMessage ( MLSMSG_Error, moduleName, &
d824 1
a824 1
      "Grids", moduleName )
d873 3
a875 2
    call refraction_correction(no_tan_hts, ifm%tan_hts(:,maf), ifm%h_path(:,maf), &
      &                n_path, ifm%ndx_path(:,maf), ifm%E_rad(maf), ref_corr)
d925 1
a925 1
    call allocate_test ( radV,maxNoFreqs, 'radV', moduleName )
d968 1
a968 1
        & temp%template%noSurfs, "dh_dt_path", moduleName )
d994 5
a998 5
          & noSpecies, ifm%ndx_path(k,maf), ifm%z_path(k,maf), ifm%h_path(k,maf), &
          & ifm%t_path(k,maf), ifm%phi_path(k,maf), ifm%dHdz_path(k,maf), &
          & earthRefl%values(1,1),beta_path(:,frq_i), spsfunc_path(:,k), &
          & ref_corr(:,k), spaceRadiance%values(1,1), brkpt, no_ele, mid, &
          & ilo, ihi, t_script, tau, Rad, Ier )
d1101 1
a1101 1
      call deallocate_test ( dh_dt_path, 'dh_dt_path', moduleName )
d1179 14
a1192 2
    if ( ForwardModelConfig%temp_der) call deallocate_test ( k_temp_frq%values, &
      & "k_temp_frq%values", moduleName )
d1195 2
a1196 2
        call deallocate_test ( k_atmos_frq(j)%values, "k_atmos_frq(j)%values", &
          & moduleName )
d1218 1
a1218 1
      & frequencies, "frequencies", moduleName )
d1228 1
a1228 1
    call Deallocate_test ( usedChannels, 'usedChannels', moduleName )
d1282 11
d1295 2
a1296 1
      & MLSMSG_Deallocate//'n_path' )
d1299 1
a1299 1
      & MLSMSG_Deallocate//'spsfunc_path' )
d1301 7
a1307 8
    call deallocate_test ( dx_dt, 'dx_dt', moduleName )
    call deallocate_test ( d2x_dxdt, 'd2x_dxdt', moduleName )
    !     call deallocate_test ( geoc_lat, 'geoc_lat', moduleName )
    !     call deallocate_test ( e_rad, 'e_rad', moduleName )
    call deallocate_test ( t_script, 't_srcipt', moduleName )
    call deallocate_test ( ref_corr, 'ref_corr', moduleName )
    call deallocate_test ( tau, 'tau', moduleName )
    call deallocate_test ( ptg_angles, 'ptg_angles', moduleName )
d1322 1
a1322 1
    call deallocate_test ( radiances, 'Radiances', moduleName )
d1329 27
a1355 3
      deallocate (ifm%dhdz_path, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'dhdz_path' )
d1357 1
a1357 1
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
d1359 3
d1363 1
a1363 1
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
d1365 3
a1367 7
      deallocate (ifm%t_path, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'t_path' )
      deallocate (ifm%z_path, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'z_path' )

d1376 2
a1377 2
      call deallocate_test ( ifm%geoc_lat, 'geoc_lat', moduleName )
      call deallocate_test ( ifm%e_rad, 'e_rad', moduleName )
d1379 7
a1385 7
      call deallocate_test ( ifm%h_glgrid, 'h_glgrid', moduleName )
      call deallocate_test ( ifm%t_glgrid, 't_glgrid', moduleName )
      call deallocate_test ( ifm%z_glgrid, 'z_glgrid', moduleName )
      call deallocate_test ( ifm%dh_dt_glgrid, 'dh_dt_glgrid', moduleName )
      call deallocate_test ( ifm%dhdz_glgrid, 'dhdz_glgrid', moduleName )
      call deallocate_test ( ifm%tan_hts,'tan_hts', moduleName )
      call deallocate_test ( ifm%tan_dh_dt, 'tan_dh_dt', moduleName )
d1444 3
@


2.91
log
@Add ??? Deallocated ??? comments
@
text
@d75 1
a75 1
    & "$Id: ForwardModelInterface.f90,v 2.90 2001/04/13 23:29:36 livesey Exp $"
d346 1
a346 1
    case ( l_linear) 
d489 1
a489 1
    
d576 1
a576 1
    
d584 1
a584 1
    allocate ( My_Catalog(noSpecies), stat=ier ) !??? deallocated ???
a597 10
    ! *** DEBUG
!
!    ForwardModelConfig%temp_der = .true.
!    ForwardModelConfig%atmos_der = .true.
!    do j = 1, noSpecies
!      forwardModelConfig%moleculeDerivatives(j) = .true.
!    end do
!
    ! *** END DEBUG

d639 1
d657 1
a657 1
      allocate (ifm%ndx_path(No_tan_hts,noMAFs), stat=status ) !??? Deallocated ???
d660 1
a660 1
      allocate (ifm%dhdz_path(No_tan_hts,noMAFs), stat=status )!??? Deallocated ???
d663 1
a663 1
      allocate (ifm%h_path(No_tan_hts,noMAFs), stat=status )   !??? Deallocated ???
d666 1
a666 1
      allocate (ifm%phi_path(No_tan_hts,noMAFs), stat=status ) !??? Deallocated ???
d669 1
a669 1
      allocate (ifm%t_path(No_tan_hts,noMAFs), stat=status )   !??? Deallocated ???
d672 1
a672 1
      allocate (ifm%z_path(No_tan_hts,noMAFs), stat=status )   !??? Deallocated ???
d676 1
a676 1
      allocate (ifm%eta_phi(No_tan_hts,noMAFs), stat=status )  !??? Deallocated ???
d680 1
a680 1
      allocate ( ifm%elvar(noMAFs), stat=status )              !??? Deallocated ???
d684 2
a685 2
      call allocate_test ( ifm%geoc_lat, noMAFs, 'geoc_lat', moduleName )!??? Deallocated ???
      call allocate_test ( ifm%e_rad, noMAFs, 'e_rad', moduleName )!??? Deallocated ???
d687 4
a690 4
      call allocate_test ( ifm%h_glgrid, maxPath, noMAFs, 'h_glgrid', moduleName )!??? Deallocated ???
      call allocate_test ( ifm%t_glgrid, maxPath, noMAFs, 'h_glgrid', moduleName )!??? Deallocated ???
      call allocate_test ( ifm%z_glgrid, maxPath/2, 'z_glgrid', moduleName )!??? Deallocated ???
      call allocate_test ( ifm%dh_dt_glgrid, maxPath, noMAFs, &!??? Deallocated ???
d692 2
a693 2
      call allocate_test ( ifm%dhdz_glgrid, maxPath, noMAFs, 'dhdz_glgrid', moduleName )!??? Deallocated ???
      call allocate_test ( ifm%tan_hts, &                      !??? Deallocated ???
d695 1
a695 1
      call allocate_test ( ifm%tan_temp, &                     !??? Deallocated ???
d697 1
a697 1
      call allocate_test ( ifm%tan_dh_dt, nlvl, noMAFs, &      !??? Deallocated ???
d768 1
a768 1
    ! First we need to identify the pointing grid we're going to be using. 
d777 1
a777 1
    allocate (allSignals(totalSignals), STAT=status) 
d783 1
a783 1
      print*,3,i
d817 1
a817 1
      
d892 1
a892 1
signal%sideband=-1
d918 1
a918 1
    if ( forwardModelConfig%temp_der ) then 
d938 1
a938 1
      
a1269 9
    !     deallocate (ndx_path, stat=status )
    !     if ( status /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName, &
    !       & MLSMSG_Deallocate//'ndx_path')
    !     deallocate (dhdz_path, stat=status )
    !     if ( status /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName, &
    !       & MLSMSG_Deallocate//'dhdz_path')
    !     deallocate (h_path, stat=status )
    !     if ( status /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName, &
    !      & MLSMSG_Deallocate//'h_path')
a1272 9
    !     deallocate (phi_path, stat=status )
    !     if ( status /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName, &
    !       & MLSMSG_Deallocate//'phi_path')
    !     deallocate (t_path, stat=status )
    !     if ( status /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName, &
    !       & MLSMSG_Deallocate//'t_path')
    !     deallocate (z_path, stat=status )
    !     if ( status /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName, &
    !       & MLSMSG_Deallocate//'z_path')
a1275 6
    !     deallocate (eta_phi, stat=status )
    !     if ( status /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName, &
    !       & MLSMSG_Deallocate//'eta_phi')
    !     deallocate (elvar, stat=status )
    !     if ( status /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName, &
    !       & MLSMSG_Deallocate//'elvar')
a1288 1

d1295 4
d1301 42
d1398 3
@


2.90
log
@Sorted out selection of appropriate pointing frequency grid.
@
text
@d75 1
a75 1
    & "$Id: ForwardModelInterface.f90,v 2.89 2001/04/13 21:40:22 vsnyder Exp $"
d584 1
a584 1
    allocate ( My_Catalog(noSpecies), stat=ier )
d666 1
a666 1
      allocate (ifm%ndx_path(No_tan_hts,noMAFs), stat=status )
d669 1
a669 1
      allocate (ifm%dhdz_path(No_tan_hts,noMAFs), stat=status )
d672 1
a672 1
      allocate (ifm%h_path(No_tan_hts,noMAFs), stat=status )
d675 1
a675 1
      allocate (ifm%phi_path(No_tan_hts,noMAFs), stat=status )
d678 1
a678 1
      allocate (ifm%t_path(No_tan_hts,noMAFs), stat=status )
d681 1
a681 1
      allocate (ifm%z_path(No_tan_hts,noMAFs), stat=status )
d685 1
a685 1
      allocate (ifm%eta_phi(No_tan_hts,noMAFs), stat=status )
d689 1
a689 1
      allocate ( ifm%elvar(noMAFs), stat=status )
d693 2
a694 2
      call allocate_test ( ifm%geoc_lat, noMAFs, 'geoc_lat', moduleName )
      call allocate_test ( ifm%e_rad, noMAFs, 'e_rad', moduleName )
d696 4
a699 4
      call allocate_test ( ifm%h_glgrid, maxPath, noMAFs, 'h_glgrid', moduleName )
      call allocate_test ( ifm%t_glgrid, maxPath, noMAFs, 'h_glgrid', moduleName )
      call allocate_test ( ifm%z_glgrid, maxPath/2, 'z_glgrid', moduleName )
      call allocate_test ( ifm%dh_dt_glgrid, maxPath, noMAFs, &
d701 2
a702 2
      call allocate_test ( ifm%dhdz_glgrid, maxPath, noMAFs, 'dhdz_glgrid', moduleName )
      call allocate_test ( ifm%tan_hts, &
d704 1
a704 1
      call allocate_test ( ifm%tan_temp, &
d706 2
a707 2
      call allocate_test ( ifm%tan_dh_dt, nlvl, noMAFs, temp%template%noSurfs,&
        & 'tan_dh_dt', moduleName )
d1386 3
@


2.89
log
@Replace pointing-grid stuff by STOP -- Nathaniel will fix it.
@
text
@d45 2
a46 1
  use MLSSignals_m, only: GetSignal, MaxSigLen, Signal_T, GetSignalName
d75 1
a75 1
    & "$Id: ForwardModelInterface.f90,v 2.88 2001/04/12 21:41:59 livesey Exp $"
d459 2
d464 1
d474 1
d477 3
d498 2
d515 2
a516 1
      & k_atmos, radiances, grids, my_Catalog, beta_path )
a775 2
    ! Now we have the full information about the number of tangent heights,
    ! including the subsrufaces ones.
d777 50
a826 5
print *, 'Need to get the correct pointing grid by matching signals'
print *, 'associated with each pointing grid against the desired signal,'
print *, 'instead of by getting a pointing grid index from the signals database'
stop
!   whichPointingGrid = signal%pointingGrid
d830 3
d841 1
a841 1
print*,'Doing maf:',maf
d1386 3
@


2.88
log
@Interim version.
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.87 2001/04/12 17:48:31 livesey Exp $"
d768 5
a772 1
    whichPointingGrid = signal%pointingGrid
d1329 3
@


2.87
log
@Moved maf increment to calling code, left finished flag here though.
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.86 2001/04/12 16:55:08 livesey Exp $"
d517 1
a517 1
      & signal= signal%index )
d589 5
a593 5
    ForwardModelConfig%temp_der = .true.
    ForwardModelConfig%atmos_der = .true.
    do j = 1, noSpecies
      forwardModelConfig%moleculeDerivatives(j) = .true.
    end do
d629 10
d653 1
a653 1
print*,'(re)computing hydrostatic stuff.'
d839 1
d1325 3
@


2.86
log
@Fixed arguments to comp_path_entities
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.85 2001/04/12 01:50:02 vsnyder Exp $"
d1114 1
a1114 3
    ! Update status
    fmStat%maf = fmStat%maf + 1
    fmStat%finished = fmStat%maf > noMAFs
d1314 3
@


2.85
log
@Explicitly nullify instead of =>NULL()
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.84 2001/04/11 02:09:46 vsnyder Exp $"
d722 1
a722 1
        &  temp%template%phi(1,:)*Deg2Rad, noMAFs, ifm%elvar, Ier )
d1316 3
@


2.84
log
@Handle 'Parse_Signal' error
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.83 2001/04/11 01:18:37 vsnyder Exp $"
d94 1
a94 1
contains
d175 2
a176 2
    logical, dimension(:), pointer :: channels=>NULL() ! From Parse_Signal
    integer, dimension(:), pointer :: SIGNALINDS=>NULL() ! From Parse_Signal
d180 5
d215 1
a215 1
      case (f_type)
d248 4
a251 4
        allocate ( info%molecules(nsons(son)-1), stat = status)
        if (status /= 0) call AnnounceError( AllocateError, key )
        allocate ( info%moleculeDerivatives (nsons(son)-1), stat = status)
        if (status /= 0) call AnnounceError( AllocateError, key )
d257 2
a258 2
        if (.not. associated(info%molecules)) then
          call AnnounceError( DefineMoleculesFirst, key)
d262 3
a264 3
            if (.not. any(info%molecules == thisMolecule ) ) &
              & call AnnounceError( BadMolecule, key )
            where (info%molecules == thisMolecule)
d270 1
a270 1
        allocate ( info%signals (nsons(son)-1), stat = status)
d301 1
a301 1
        call expr( subtree(2,son), units, value, type )
d303 2
a304 2
        if (mod(info%phiWindow,2) /= 1) &
          & call AnnounceError (phiWindowMustBeOdd, key)
d320 4
a323 4
    select case (info%fwmType)
    case (l_full)
      if (.not. all(got( (/ f_molecules, f_signals, f_integrationGrid, &
        & f_tangentGrid /) ))) call AnnounceError (IncompleteFullFwm, root)
d332 1
a332 1
        if (.not. any ( abs(info%tangentGrid%surfs(tangent) - &
d334 1
a334 1
          & call AnnounceError (TangentNotSubset, root)
d339 1
a339 1
    case (l_scan)
d341 1
a341 1
      if (any(got( (/f_atmos_der, f_channels, f_do_conv, &
d343 7
a349 7
        & f_signals, f_spect_der, f_temp_der /) ))) &
        & call AnnounceError (IrrelevantFwmParameter, root)
    case (l_linear)
      if (.not. all(got( (/f_molecules, f_signals/) ))) & ! Maybe others later
        & call AnnounceError (IncompleteLinearFwm, root)
      if (any(got( (/f_atmos_der, f_do_conv, f_do_freq_avg, f_frequency /) ))) &
        & call AnnounceError (IrrelevantFwmParameter, root)
d352 2
a353 1
    if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, 'An error occured')
d360 1
a360 1
    &                       FwdModelOut, ifm, fmStat, Jacobian)
d392 2
a393 2
    type(ForwardModelIntermediate_T), intent(inout) :: ifm ! Workspace
    type(ForwardModelStatus_t), intent(inout) :: fmStat ! Reverse comm. stuff
d398 1
a398 1
    character, parameter :: INVALIDQUANTITY="Invalid vector quantity for "
d410 1
a410 1
    type(k_matrix_info) :: k_star_info(20)
d413 2
a414 2
    type(path_derivative) :: k_temp_frq
    type(path_derivative), allocatable, dimension(:) :: k_atmos_frq
d416 1
a416 1
    type(path_beta), dimension(:,:), pointer :: beta_path => null()
d418 25
a442 25
    real(r8) :: Zeta, Frq, h_tan, Rad, geod_lat, phi_tan, r

    Real(r8), DIMENSION(:), ALLOCATABLE :: dum

    character (LEN=01) :: CA
    character (LEN=08) :: Name
    character (LEN=16) :: Vname
    character (LEN=80) :: Line
    character (LEN=40) :: Ax, Dtm1, Dtm2

    real(r8), dimension(:), pointer :: RadV=>NULL()

    ! This is the `legit stuff' we hope will stay they are all pointers to
    ! VectorValue_T's containing vector quantities
    type (VectorValue_T), pointer :: RADIANCE=>NULL() ! Radiance quantity to be filled
    type (VectorValue_T), pointer :: TEMP=>NULL() ! Temperature quantity
    type (VectorValue_T), pointer :: PTAN=>NULL() ! PTAN quantity
    type (VectorValue_T), pointer :: ELEVOFFSET=>NULL() ! Elevation offset quantity
    type (VectorValue_T), pointer :: ORBINCLINE=>NULL() ! Orbital inclination (beta)
    type (VectorValue_T), pointer :: SPACERADIANCE=>NULL() ! Space radiance
    type (VectorValue_T), pointer :: EARTHREFL=>NULL() ! Earth reflectivity
    type (VectorValue_T), pointer :: REFGPH=>NULL() ! Reference GPH, (zRef and hRef)
    type (VectorValue_T), pointer :: LOSVEL=>NULL() ! Line of sight velocity
    type (VectorValue_T), pointer :: SCGEOCALT=>NULL() ! Geocentric spacecraft altitude
    type (VectorValue_T), pointer :: F=>NULL() ! An arbitrary species
d466 1
a466 1
    real (r8) :: CENTER_ANGLE            ! For angles
d469 2
a470 2
    integer, dimension(:), pointer :: CHANNELINDEX=>NULL() ! E.g. 1..25
    integer, dimension(:), pointer :: USEDCHANNELS=>NULL() ! Array of indices used
d472 9
a480 9
    real(r4), dimension(:),     pointer :: TOAVG=>NULL()   ! Stuff to be passed to frq.avg.
    real(r8), dimension(:),     pointer :: FREQUENCIES=>NULL() ! Frequency points
    real(r8), dimension(:,:,:), pointer :: DH_DT_PATH=>NULL()  ! (pathSize, Tsurfs, Tinstance)
    real(r8), dimension(:,:),   pointer :: DX_DT=>NULL() ! (No_tan_hts, Tsurfs)
    real(r8), dimension(:,:),   pointer :: D2X_DXDT=>NULL() ! (No_tan_hts, Tsurfs)
    real(r8), dimension(:),     pointer :: T_SCRIPT=>NULL() ! (n2lvl)
    real(r8), dimension(:,:),   pointer :: REF_CORR=>NULL() ! (n2lvl, no_tan_hts)
    real(r8), dimension(:),     pointer :: TAU=>NULL() ! (n2lvl)
    real(r8), dimension(:),     pointer :: PTG_ANGLES=>NULL() ! (no_tan_hts)
d482 3
a484 3
    real(r4), dimension(:,:,:,:), pointer :: K_TEMP=>NULL() ! (channel,Nptg,mxco,mnp)
    real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS=>NULL() ! (channel,Nptg,mxco,mnp,Nsps)
    real(r8), dimension(:,:), pointer :: Radiances=>NULL() ! (Nptg,25)
d486 1
a486 1
    integer, pointer, dimension(:) :: GRIDS=>NULL()    ! Frq grid for each tan_press
d495 1
a495 1
    type(Catalog_T), pointer, dimension(:) :: My_Catalog => NULL()
d499 9
a507 1
    ! First we identify the vector quantities we're going to need.
d510 1
a510 1
    if (size(forwardModelConfig%signals) > 1) call MLSMessage ( &
d512 1
a512 1
      & "Can't yet have multiple signals in forward model")
d521 1
a521 1
      & quantityType=l_temperature)
d523 1
a523 1
      & quantityType=l_ptan, instrumentModule=signal%instrumentModule)
d525 1
a525 1
      & quantityType=l_elevOffset, radiometer=signal%radiometer)
d527 1
a527 1
      & quantityType=l_orbitIncline)
d529 1
a529 1
      & quantityType=l_spaceRadiance)
d531 1
a531 1
      & quantityType=l_earthRefl)
d533 1
a533 1
      & quantityType=l_refGPH)
d535 1
a535 1
      & quantityType=l_losVel, instrumentModule=signal%instrumentModule)
d537 1
a537 1
      & quantityType=l_scGeocAlt)
d547 13
a559 13
    if (.not. ValidateVectorQuantity(radiance, minorFrame=.true.,&
      & frequencyCoordinate=(/l_channel/))) call MLSMessage(MLSMSG_Error, ModuleName, &
      & InvalidQuantity//'radiance')
    if (.not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
      & frequencyCoordinate=(/l_none/))) call MLSMessage(MLSMSG_Error, ModuleName,&
      & InvalidQuantity//'temperature')
    if (.not. ValidateVectorQuantity(ptan, minorFrame=.true., &
      & frequencyCoordinate=(/l_none/))) call MLSMessage(MLSMSG_Error, ModuleName, &
      & InvalidQuantity//'ptan')
    if (.not. ValidateVectorQuantity(elevOffset, verticalCoordinate=(/l_none/), &
      & frequencyCoordinate=(/l_none/), noInstances=(/1/))) &
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & InvalidQuantity//'elevOffset')
d569 1
a569 1
        &     quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie))
d573 3
a575 3
    ALLOCATE(My_Catalog(noSpecies),STAT=ier)
    if (ier /= 0) call MLSMessage(MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'my_catalog')
d580 1
a580 1
        if(Catalog(i)%Spec_Tag == Spectag) then
d582 2
a583 2
          EXIT
        endif
d601 1
a601 1
    if(ForwardModelConfig%temp_der) then
d604 1
a604 1
    endif
d606 1
a606 1
    if(forwardModelConfig%atmos_der) then
d608 1
a608 1
        IF (forwardModelConfig%moleculeDerivatives(k)) THEN
d615 1
a615 1
        ENDIF
d617 1
a617 1
    endif
d631 2
a632 1
    call allocate_test (channelIndex, size(signal%frequencies), 'channelIndex', ModuleName)
d634 1
a634 1
    call allocate_test (usedChannels, noUsedChannels, 'channelIndex', ModuleName)
d639 1
a639 1
    call deallocate_test(channelIndex,'channelIndex',ModuleName)
d641 1
a641 1
    if (fmStat%newHydros) then
d643 1
a643 1
      print*,'(re)computing hydrostatic stuff.'
d645 42
a686 42
      allocate (ifm%ndx_path(No_tan_hts,noMAFs), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'ndx_path')
      allocate (ifm%dhdz_path(No_tan_hts,noMAFs), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'dhdz_path')
      allocate (ifm%h_path(No_tan_hts,noMAFs), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'h_path')
      allocate (ifm%phi_path(No_tan_hts,noMAFs), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'phi_path')
      allocate (ifm%t_path(No_tan_hts,noMAFs), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'t_path')
      allocate (ifm%z_path(No_tan_hts,noMAFs), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'z_path')

      allocate (ifm%eta_phi(No_tan_hts,noMAFs), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'eta_phi')

      allocate(ifm%elvar(noMAFs), STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'elvar')

      call allocate_test(ifm%geoc_lat, noMAFs, 'geoc_lat', ModuleName)
      call allocate_test(ifm%e_rad, noMAFs, 'e_rad', ModuleName)

      call allocate_test(ifm%h_glgrid, maxPath, noMAFs, 'h_glgrid', ModuleName)
      call allocate_test(ifm%t_glgrid, maxPath, noMAFs, 'h_glgrid', ModuleName)
      call allocate_test(ifm%z_glgrid, maxPath/2, 'z_glgrid', ModuleName)
      call allocate_test(ifm%dh_dt_glgrid, maxPath, noMAFs, &
        & temp%template%noSurfs,'dh_dt_glgrid', ModuleName)
      call allocate_test(ifm%dhdz_glgrid, maxPath, noMAFs, 'dhdz_glgrid', ModuleName)
      call allocate_test(ifm%tan_hts, &
        & size(ForwardModelConfig%tangentGrid%surfs), noMAFs, 'tan_hts', ModuleName)
      call allocate_test(ifm%tan_temp, &
        & size(ForwardModelConfig%tangentGrid%surfs), noMAFs, 'tan_hts', ModuleName)
      call allocate_test(ifm%tan_dh_dt, nlvl, noMAFs, temp%template%noSurfs,&
        & 'tan_dh_dt', ModuleName)
d691 1
a691 1
      if (temp%template%noInstances /= noMAFs) &
d697 2
a698 2
        call geoc_geod_conv(ifm%elvar(maf),orbIncline%values(1,1), &
          &  phi_tan,geod_lat, ifm%geoc_lat(maf),ifm%E_rad(maf))
d703 2
a704 2
      call hydrostatic_model(ForwardModelConfig%SurfaceTangentIndex, &
        &  noMAFs, ifm%geoc_lat,0.001*refGPH%values(1,:), &
d707 3
a709 2
        &  temp%template%surfs(:,1),temp%values,ifm%z_glgrid,ifm%h_glgrid,ifm%t_glgrid, &
        &  ifm%dhdz_glgrid,ifm%dh_dt_glgrid, &
d711 3
a713 3
        &  ifm%tan_hts,ifm%tan_temp,ifm%tan_dh_dt, &
        &  ifm%gl_count, Ier)
      if(ier /= 0) goto 99
d716 8
a723 7
      call comp_path_entities(ForwardModelConfig%integrationGrid%noSurfs, &
        &  temp%template%noSurfs,ifm%gl_count,ifm%ndx_path,ifm%z_glgrid,ifm%t_glgrid,&
        &  ifm%h_glgrid,ifm%dhdz_glgrid,ifm%tan_hts,no_tan_hts,ifm%z_path,&
        & ifm%h_path,ifm%t_path,&
        &  ifm%phi_path,ifm%dhdz_path,ifm%eta_phi,temp%template%noInstances, &
        &  temp%template%phi(1,:)*Deg2Rad,noMAFs,ifm%elvar,Ier)
      if(ier /= 0) goto 99
d726 1
a726 1
    endif
d729 19
a747 19
    call allocate_test(t_script, n2lvl, 't_srcipt', ModuleName)
    call allocate_test(ref_corr, n2lvl, no_tan_hts, 'ref_corr', ModuleName)
    call allocate_test(tau, n2lvl, 'tau', ModuleName)
    call allocate_test(ptg_angles, no_tan_hts, 'ptg_angles', ModuleName)

    allocate(k_atmos_frq(noSpecies),STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_atmos_frq')

    allocate (n_path(No_tan_hts), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'n_path')
    allocate (spsfunc_path(noSpecies,No_tan_hts), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'spsfunc_path')
    call allocate_test(dx_dt, No_tan_hts, temp%template%noSurfs, &
      & 'dx_dt', ModuleName)
    call allocate_test(d2x_dxdt, No_tan_hts, temp%template%noSurfs, &
      & 'd2x_dxdt', ModuleName)
d749 2
a750 2
    call allocate_test(radiances, no_tan_hts, noUsedChannels, &
      & 'Radiances', ModuleName)
d764 2
a765 2
    call Hunt(PointingGrids(whichPointingGrid)%oneGrid%height, &
      & ForwardModelConfig%TangentGrid%surfs, grids, allowTopValue=.true.)
d770 1
a770 1
    print*,'Doing maf:',maf
d777 8
a784 8
    allocate (k_temp(noUsedChannels, no_tan_hts, temp%template%noSurfs, &
      & windowStart:windowFinish), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_temp')
    allocate (k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
      & windowStart:windowFinish, noSpecies), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_atmos')
d789 2
a790 2
    Call get_path_spsfunc_ngrid(fwdModelIn, fwdModelExtra, &
      &     forwardModelConfig%molecules, ifm%ndx_path(:,maf),no_tan_hts, &
d792 2
a793 2
      &     spsfunc_path, Ier)
    if(ier /= 0) goto 99
d796 1
a796 1
    phi_tan = Deg2Rad*temp%template%phi(1,maf)
d800 3
a802 3
    call get_chi_angles(ifm%ndx_path(:,maf),n_path,&
      &     forwardModelConfig%tangentGrid%surfs,        &
      &     ifm%tan_hts(:,maf),ifm%tan_temp(:,maf),phi_tan,ifm%elvar(maf)%Roc,&
d805 2
a806 2
      &     ifm%tan_dh_dt(:,maf,:),no_tan_hts,temp%template%noSurfs, &
      &     temp%template%surfs(:,1),&
d808 2
a809 2
      &     center_angle,ptg_angles,dx_dt,d2x_dxdt,ier)
    if(ier /= 0) goto 99
d822 1
a822 1
    if (.not. forwardModelConfig%do_freq_avg) then
d824 3
a826 3
      noFreqs = count ( forwardModelConfig%signals(1)%channels )
      call allocate_test(frequencies,noFreqs,"frequencies",ModuleName)
      frequencies = pack ( signal%frequencies, &
d828 4
a831 4
      !%%%%%%%%%%%%% DEBUG NJL
      signal%sideband=-1
      !%%%%%%%%%%%%%%
      select case (signal%sideband)
d837 2
a838 2
        call MLSMessage(MLSMSG_Error, ModuleName, &
          & 'Folded signal requested in forward model')
d840 2
a841 2
        call MLSMessage(MLSMSG_Error, ModuleName, &
          & 'Bad value of signal%sideband')
d844 1
a844 1
    endif
d857 3
a859 3
        & windowStart:windowFinish), STAT=status)
      if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,&
        & MLSMSG_Allocate//'k_temp_frq')
d862 1
a862 1
    call Allocate_Test(radV,maxNoFreqs, 'radV', ModuleName)
d866 1
a866 1
        & quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie))
d871 3
a873 3
          & windowStart:windowFinish), STAT=status)
        if (status/=0) call MLSMessage(MLSMSG_Error,ModuleName,&
          & MLSMSG_Allocate//'k_atmos_frq')
d890 1
a890 1
      if (ForwardModelConfig%do_freq_avg) then
d893 1
a893 1
      endif ! If not, we dealt with this outside the loop
d898 4
a901 4
      if(ier /= 0) goto 99
!
      !  Define the dh_dt_path for this pointing and this MAF:
!
d903 3
a905 2
      ALLOCATE(dh_dt_path(no_ele,temp%template%noInstances, &
        & temp%template%noSurfs),STAT=ier)
d908 3
a910 3
        if(ier == 0) ALLOCATE(dum(no_ele),STAT=ier)
        IF(ier /= 0) then
          Print *,'** ALLOCATE Error: dum or dh_dt_path, STAT =',ier
d915 2
a916 2
              CALL Lintrp(ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,       &
                &            ifm%dh_dt_glgrid(:,i,j), dum, ifm%gl_count, no_ele)
d920 2
a921 2
          DEALLOCATE(dum,STAT=i)
        endif
d929 1
a929 1
        Call Rad_Tran(ifm%elvar(maf), Frq, &
d934 3
a936 3
          & ref_corr(:,k), spaceRadiance%values(1,1), brkpt, no_ele, mid,&
          & ilo, ihi, t_script, tau, Rad, Ier)
        if(ier /= 0) goto 99
d942 11
a952 10
        if (ForwardModelConfig%temp_der) k_temp_frq%values=0.0_r8
        Call Rad_Tran_WD(ForwardModelConfig, FwdModelExtra, FwdModelIn, &
          &  ifm%elvar(maf),frq_i,Frq,noSpecies,ifm%z_path(k,maf), &
          &  ifm%h_path(k,maf),ifm%t_path(k,maf),ifm%phi_path(k,maf),ifm%dHdz_path(k,maf),&
          &  beta_path(:,frq_i),spsfunc_path(:,k),temp%template%surfs(:,1),&
          &  temp%template%noSurfs,ref_corr(:,k),temp%template%noInstances,&
          &  temp%template%phi(1,:)*Deg2Rad,dh_dt_path,&
          &  k_temp_frq,k_atmos_frq,brkpt,no_ele,mid,ilo,ihi, &
          &  t_script,tau,max_zeta_dim,max_phi_dim,ier)
        IF(ier /= 0) goto 99
d963 2
a964 2
          call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'Asked for folded in wrong place')
d971 1
a971 1
          call Freq_Avg(frequencies,                           &
d973 2
a974 2
            &       FilterShapes(i)%FilterShape,RadV,noFreqs,    &
            &       Size(FilterShapes(i)%FilterGrid),Radiances(ptg_i,ch))
d978 1
a978 1
      endif
d982 2
a983 2
      if ( forwardModelConfig%temp_der) then
        if ( forwardModelConfig%do_freq_avg) then
d990 1
a990 1
                call Freq_Avg(frequencies,                        &
d992 2
a993 2
                  &        FilterShapes(i)%FilterShape,real(ToAvg,r8),  &
                  &        noFreqs,Size(FilterShapes(i)%FilterGrid),r)
d1003 2
a1004 2
        endif
      endif
d1012 1
a1012 1
          if ( forwardModelConfig%do_freq_avg) then
d1018 2
a1019 3
                  ToAvg =>   &
                    &        k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
                  call Freq_Avg(frequencies,                      &
d1021 2
a1022 2
                    &          FilterShapes(i)%FilterShape,real(ToAvg,r8),  &
                    &          noFreqs,Size(FilterShapes(i)%FilterGrid),r)
d1038 1
a1038 3
      deallocate (dh_dt_path, STAT=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
        & MLSMSG_Deallocate//'dh_dt_path')
d1043 1
a1043 1
    ! Complete the radiances's last location, also  complete k_temp last
d1049 1
a1049 1
      if(ForwardModelConfig%temp_der) then
d1051 4
a1054 3
        k_temp(i,no_tan_hts,1:n,1:phiWindow)=k_temp(i,no_tan_hts-1,1:n,1:phiWindow)
      endif
      if(ForwardModelConfig%atmos_der) then
d1064 1
a1064 1
          endif
d1066 1
a1066 1
      endif
d1074 1
a1074 1
      if(ForwardModelConfig%do_conv) then
d1079 1
a1079 1
        call convolve_all(forwardModelConfig, fwdModelIn, &
d1081 7
a1087 7
          &     ForwardModelConfig%tangentGrid%surfs,ptg_angles,&
          &     ifm%tan_temp(:,maf),dx_dt, d2x_dxdt,si,center_angle,&
          &     Radiances(:,ch),k_temp(i,:,:,:),k_atmos(i,:,:,:,:), &
          &     no_tan_hts,k_info_count,i_star_all(i,:), &
          &     k_star_all(i,:,:,:,:),k_star_info,&
          &     temp%template%noSurfs,temp%template%noInstances,&
          &     temp%template%surfs(:,1),AntennaPatterns(1),ier)
d1089 1
a1089 1
        if(ier /= 0) goto 99
d1092 1
a1092 1
        call no_conv_at_all(forwardModelConfig, fwdModelIn, &
d1095 1
a1095 1
          &     Radiances(:,ch),k_temp(i,:,:,:),k_atmos(i,:,:,:,:), &
d1097 3
a1099 3
          &     k_star_all(i,:,:,:,:),k_star_info, &
          &     temp%template%noSurfs,temp%template%noInstances, &
          &     temp%template%surfs(:,1))
d1101 1
a1101 1
      endif
d1118 3
a1120 2
    if(ForwardModelConfig%temp_der) deallocate(k_temp_frq%values,STAT=i)
    if(ForwardModelConfig%atmos_der) then
d1122 2
a1123 1
        deallocate(k_atmos_frq(j)%values,STAT=i)
d1125 1
a1125 1
    endif
d1129 1
a1129 1
    if(ForwardModelConfig%do_conv) then
d1133 1
a1133 1
    endif
d1135 1
a1135 1
    if(.not. ForwardModelConfig%do_freq_avg) then
d1141 1
a1141 1
    endif
d1144 2
a1145 1
    if (.not. forwardModelConfig%do_freq_avg) deallocate(frequencies)
d1149 2
a1150 2
      write(*,903) ch,char(92),ptan%template%noSurfs
      write(*,905) (i_star_all(i,k),k=1,ptan%template%noSurfs)
d1155 1
a1155 1
    call Deallocate_test(usedChannels, 'usedChannels', ModuleName)
d1158 1
a1158 1
    !   if(i > -22) Stop
d1161 2
a1162 2
    if(.not. any((/ForwardModelConfig%temp_der,&
      & ForwardModelConfig%atmos_der,ForwardModelConfig%spect_der/))) goto 99
d1170 2
a1171 2
    call Hunt_zvi(Zeta,tau,m,klo,j)
    if(abs(Zeta-tau(j)) < abs(Zeta-tau(klo))) klo=j
d1180 1
a1180 1
      if(Name == 'PTAN') cycle
d1185 1
a1185 1
      if(Name(nameLen-1:nameLen) == '_W' .or.  &
d1192 1
a1192 1
        if(Name == 'TEMP') then
d1196 1
a1196 1
        endif
d1199 2
a1200 2
        call Hunt_zvi(Zeta,tau,mnz,m,j)
        if(abs(Zeta-tau(j)) < abs(Zeta-tau(m))) m=j
d1202 1
a1202 1
      endif
d1209 2
a1210 2
    !     deallocate (ndx_path, STAT=status)
    !     if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
d1212 2
a1213 2
    !     deallocate (dhdz_path, STAT=status)
    !     if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
d1215 2
a1216 2
    !     deallocate (h_path, STAT=status)
    !     if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
d1218 5
a1222 5
    deallocate (n_path, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'n_path')
    !     deallocate (phi_path, STAT=status)
    !     if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
d1224 2
a1225 2
    !     deallocate (t_path, STAT=status)
    !     if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
d1227 2
a1228 2
    !     deallocate (z_path, STAT=status)
    !     if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
d1230 5
a1234 5
    deallocate (spsfunc_path, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'spsfunc_path')
    !     deallocate (eta_phi, STAT=status)
    !     if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
d1236 2
a1237 2
    !     deallocate (elvar, STAT=status)
    !     if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
d1240 20
a1259 20
    call deallocate_test(dx_dt, 'dx_dt', ModuleName)
    call deallocate_test(d2x_dxdt, 'd2x_dxdt', ModuleName)
    !     call deallocate_test(geoc_lat, 'geoc_lat', ModuleName)
    !     call deallocate_test(e_rad, 'e_rad', ModuleName)
    call deallocate_test(t_script, 't_srcipt', ModuleName)
    call deallocate_test(ref_corr, 'ref_corr', ModuleName)
    call deallocate_test(tau, 'tau', ModuleName)
    call deallocate_test(ptg_angles, 'ptg_angles', ModuleName)

    deallocate(k_atmos_frq,STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'k_atmos_frq')

    deallocate (k_temp, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_temp')
    deallocate (k_atmos, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_atmos')
    call deallocate_test(radiances, 'Radiances', ModuleName)
d1262 1
a1262 1
    !    if(i > -22) Stop
d1269 1
a1269 1
  ! =====     Private Procedures     =====================================
d1316 3
@


2.83
log
@Check channel number range
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.82 2001/04/11 00:50:06 livesey Exp $"
d84 1
a84 2
  integer, parameter :: ChannelOutOfRange    = BadMolecule + 1
  integer, parameter :: DefineSignalsFirst   = ChannelOutOfRange + 1
d272 4
d285 4
a288 8
            if ( ubound(channels,1) > ubound(info%signals(j)%channels,1) ) then
              call announceError ( channelOutOfRange, key )
            else
              info%signals(j)%channels(1:lbound(channels,1)-1) = .false.
              info%signals(j)%channels(lbound(channels,1):ubound(channels,1)) = &
                channels
              info%signals(j)%channels(ubound(channels,1)+1:) = .false.
            end if
a1265 2
    case ( channelOutOfRange )
      call output ( 'Channel out-of-range for signal.', advance='yes' )
d1296 3
@


2.82
log
@Another interim version, the `moving window' is better implemented
@
text
@d32 1
a32 1
    & F_POINTINGGRIDS,F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, F_TYPE
d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.81 2001/04/10 23:51:18 livesey Exp $"
d84 2
a85 1
  integer, parameter :: DefineSignalsFirst   = BadMolecule + 1
d267 1
a267 1
        if (status /= 0) call AnnounceError( AllocateError, key )
d269 4
a272 3
          call get_string(sub_rosa(subtree(j+1,son)), signalString, strip=.true.)
          call Parse_Signal(signalString, signalInds, spec_indices, &
            tree_index=son, sideband=sideband, channels=channels)
d278 12
a289 5
          call Allocate_Test(info%signals(j)%channels, &
            & size(info%signals(j)%frequencies), 'info%signals%channels', ModuleName)
          if (associated(channels)) then
            commonSize=min(size(info%signals(j)%channels),size(channels))
            info%signals(j)%channels(1:commonSize) = channels(1:commonSize)
d293 2
a294 2
          call deallocate_test(channels,'channels',ModuleName)
          call deallocate_test(signalInds,'signalInds',ModuleName)
d299 2
a300 1
        if (mod(info%phiWindow,2) /= 1) call AnnounceError (phiWindowMustBeOdd, key)
d1262 11
a1272 7
    case (AllocateError)
      call output ( 'allocation error.', advance='yes')
    case (BadMolecule)
      call output ( 'asked for derivatives for an unlisted molecule.')
    case (DefineMoleculesFirst)
      call output ( 'molecule must be defined before moleules derivatives.', advance='yes')
    case (DefineSignalsFirst)
d1274 13
a1286 10
    case (IncompleteFullFwm)
      call output ( 'incomplete full foward model specification' )
    case (IncompleteLinearFwm)
      call output ( 'incomplete linear foward model specification' )
    case (IrrelevantFwmParameter)
      call output ( 'irrelevant parameter for this forward model type' )
    case (TangentNotSubset)
      call output ( 'non subsurface tangent grid not a subset of integration grid' )
    case (PhiWindowMustBeOdd)
      call output ( 'phiWindow is not odd' )
d1299 3
@


2.81
log
@Another working version.  More temporary arrays now alloctable/pointer
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.80 2001/04/10 23:15:55 livesey Exp $"
a392 3
    real(r4) :: K_TEMP(25,Nptg,mxco,mnp)
    real(r4) :: K_ATMOS(25,Nptg,mxco,mnp,Nsps)

a393 1

d397 1
a402 1
    real(r8) :: Radiances(Nptg,25)
d433 1
d442 1
d447 2
d466 4
d542 7
d601 5
a616 6
    ! Setup various array dimensions
    no_tan_hts = ForwardModelConfig%TangentGrid%nosurfs
    maxPath = 2 * (NG+1) * size(ForwardModelConfig%integrationGrid%surfs)
    nlvl=size(ForwardModelConfig%integrationGrid%surfs)
    n2lvl=2*nlvl

a689 2
      ! phi_window = ForwardModelConfig%phiWindow

d723 3
d746 14
d829 5
a833 5

    if ( forwardModelConfig%temp_der ) then
      call Allocate_Test(k_temp_frq%values, maxNoFreqs, &
        &   temp%template%noSurfs, temp%template%noInstances, &
        &   'k_temp_frq', ModuleName)
d844 4
a847 3
        call Allocate_Test( k_atmos_frq(specie)%values, &
          & maxNoFreqs, f%template%noSurfs, f%template%noInstances, &
          & 'k_atmos_frq(..)', ModuleName )
d849 1
a849 1

d958 2
a959 1
            do instance = 1, temp%template%noInstances
d972 2
a973 2
            k_temp(i,ptg_i,1:temp%template%noSurfs,1:temp%template%noInstances) = &
              &  k_temp_frq%values(1,1:temp%template%noSurfs,1:temp%template%noInstances)
d987 2
a988 1
              do instance = 1, f%template%noInstances
a1001 1
            instance = f%template%noInstances
d1003 2
a1004 2
              k_atmos(i,ptg_i,1:surface,1:instance,specie) = &
                &  k_atmos_frq(specie)%values(1,1:surface,1:instance)
d1026 1
a1026 2
        k = temp%template%noInstances
        k_temp(i,no_tan_hts,1:n,1:k)=k_temp(i,no_tan_hts-1,1:n,1:k)
d1036 2
a1037 1
            k_atmos(i,no_tan_hts,1:n,1:k,m)=k_atmos(i,no_tan_hts-1,1:n,1:k,m)
d1224 7
d1282 3
@


2.80
log
@Reverse communication seems to be working. Needs a bit more tidying up though.
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.79 2001/04/10 22:04:16 livesey Exp $"
d351 1
a351 1
    use L2PCdim, only: Nlvl, N2lvl, NSPS, Nptg, MNP => max_no_phi, &
a387 2
    integer(i4), parameter :: NGT = (Ng+1) * N2lvl

a392 4
    real(r8) :: t_script(N2lvl),ref_corr(N2lvl,Nptg),tau(N2lvl)

    real(r8) :: ptg_angles(Nptg), center_angle

d401 2
a402 1
    type(path_derivative) :: k_temp_frq, k_atmos_frq(Nsps)
d438 2
d451 1
d457 2
a458 2
    real(r4), dimension(:), pointer :: TOAVG=>NULL()   ! Stuff to be passed to frq.avg.
    real(r8), dimension(:), pointer :: FREQUENCIES=>NULL() ! Frequency points
d460 6
a465 2
    real(r8), dimension(:,:), pointer :: DX_DT=>NULL() ! (Nptg, Tsurfs)
    real(r8), dimension(:,:), pointer :: D2X_DXDT=>NULL() ! (Nptg, Tsurfs)
d471 1
a471 1
    type(path_vector), allocatable, dimension(:) :: N_PATH    ! (Nptg)
d473 1
a473 1
    ! dimensions of SPSFUNC_PATH are: (Nsps,Nptg)
d601 1
a601 1
    !    Nptg = forwardModelConfig%tangentGrid%noSurfs
d603 3
d611 1
a611 1
      allocate (ifm%ndx_path(Nptg,noMAFs), STAT=status)
d614 1
a614 1
      allocate (ifm%dhdz_path(Nptg,noMAFs), STAT=status)
d617 1
a617 1
      allocate (ifm%h_path(Nptg,noMAFs), STAT=status)
d620 1
a620 1
      allocate (ifm%phi_path(Nptg,noMAFs), STAT=status)
d623 1
a623 1
      allocate (ifm%t_path(Nptg,noMAFs), STAT=status)
d626 1
a626 1
      allocate (ifm%z_path(Nptg,noMAFs), STAT=status)
d630 1
a630 1
      allocate (ifm%eta_phi(Nptg,noMAFs), STAT=status)
a640 1
      maxPath = 2 * (NG+1) * size(ForwardModelConfig%integrationGrid%surfs)
d651 3
a653 2
      call allocate_test(ifm%tan_dh_dt, size(ForwardModelConfig%integrationGrid%surfs), &
        & noMAFs, temp%template%noSurfs,'tan_dh_dt',ModuleName)
d656 1
d694 11
a704 1
    allocate (n_path(Nptg), STAT=status)
d707 1
a707 1
    allocate (spsfunc_path(noSpecies,Nptg), STAT=status)
d710 1
a710 1
    call allocate_test(dx_dt, Nptg, temp%template%noSurfs, &
d712 1
a712 1
    call allocate_test(d2x_dxdt, Nptg, temp%template%noSurfs, &
d1188 9
d1248 3
@


2.79
log
@Intermediate version, slight problem with signals.
@
text
@d6 1
a6 1
!=============================================================================
d19 1
d70 1
a70 1
  end interface Dump
d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.78 2001/04/10 18:51:02 vsnyder Exp $"
d136 1
a136 1
      ! Can't get here if the type checker worked
d177 1
a177 1
    
d221 21
a241 21
!       case ( f_channels )
!         if ( .not. associated( info%signals ) ) then
!           call AnnounceError(DefineSignalsFirst, key)
!         else
!           noChannelsSpecs=noChannelsSpecs+1
!           thisSignal => info%signals(noChannelsSpecs)
!           ! Now default to none included
!           thisSignal%channels = .false.
!           do j = 2, nsons(son)
!             call expr ( subtree(j,son), units, value, type )
!             select case (type)
!             case (num_value)
!               thisFWMSignal%channelIncluded(int(value(1))) = .true.
!             case (range)
!               thisFWMSignal%channelIncluded(int(value(1)):int(value(2))) =&
!                 & .true.
!             case default
!               ! Shouldn't get here if parser worked
!             end select
!           end do
!         end if
d344 2
a345 2
  subroutine ForwardModel ( ForwardModelConfig, FwdModelExtra, FwdModelIn, &
    &                       Jacobian, RowBlock, FwdModelOut)
d373 1
a373 2
! From ForwardModelSetup
!   type(forwardModelConfig_T), intent(in) :: forwardModelConfig
d375 4
a378 2

    type(vector_T), intent(in) :: FwdModelExtra, FwdModelIn ! ???
a379 3
    integer, intent(in), optional :: RowBlock          ! With which block of
    ! rows of F and Jacobian are we computing? All of them if absent.
    type(vector_T), intent(inout), optional :: FwdModelOut  ! Radiances, etc.
d391 3
a393 6
                   m, ier, maf, si, ptg_i, frq_i, klo, n, brkpt, no_ele, &
                   mid, ilo, ihi, k_info_count, gl_count, ld, &
                   max_phi_dim, max_zeta_dim

    real(r8) :: t_script(N2lvl),ref_corr(N2lvl,Nptg),tau(N2lvl), &
                tan_dh_dt(Nlvl,mnm,mxco)
d395 1
a395 2
    real(r8) :: h_glgrid(ngt,mnm), t_glgrid(ngt,mnm), z_glgrid(ngt/2)
    real(r8) :: dh_dt_glgrid(ngt,mnm,mxco), dhdz_glgrid(ngt,mnp)
a397 1
    real(r8) :: tan_hts(Nptg,mnm), tan_temp(Nptg,mnm)
a398 4

    ! real(r4) :: K_TEMP(totalChannels,
    ! size(ForwardModelConfig%tangentGrid%surfs,temp%template%noSurfs,phiWindow)
    
d442 1
a458 2
    real(r8), dimension(:), pointer :: GEOC_LAT=>NULL() ! Geocentric latitude of maf (radians)
    real(r8), dimension(:), pointer :: E_RAD=>NULL() ! Effective earth radius at maf (km)
a468 2
    type(path_index), allocatable, dimension(:,:) :: NDX_PATH ! (Nptg,mnm)

d471 1
a471 7
    type(path_vector), allocatable, dimension(:,:) :: DHDZ_PATH ! (Nptg,mnm)
    type(path_vector), allocatable, dimension(:,:) :: H_PATH    ! (Nptg,mnm)
    type(path_vector), allocatable, dimension(:,:) :: PHI_PATH  ! (Nptg,mnm)
    type(path_vector), allocatable, dimension(:,:) :: T_PATH    ! (Nptg,mnm)
    type(path_vector), allocatable, dimension(:,:) :: Z_PATH    ! (Nptg,mnm)

! dimensions of SPSFUNC_PATH are: (Nsps,Nptg)
a472 5

    Type(path_vector_2d), allocatable, dimension(:,:) :: ETA_PHI ! (Nptg,mnm)

    Type(ELLIPSE), allocatable, dimension(:)  :: ELVAR    ! mnm

a473 1

d551 1
a551 1
! *** DEBUG
d553 2
a554 2
    ForwardModelConfig%temp_der = .false.
    ForwardModelConfig%atmos_der = .false.
d559 1
a559 1
! *** END DEBUG
d561 2
a562 2
! Get the max. dimension in zeta coeff. space and phi coeff. space
! (To be used later in rad_tran_wd, for automatic arrays asignement)
d574 1
a574 1
       &     quantityType=l_vmr, molecule=forwardModelConfig%molecules(k))
d599 88
a686 1
!    Nptg = forwardModelConfig%tangentGrid%noSurfs
a687 10
    ! Now we're going to create the many temporary arrays we need
    allocate (ndx_path(Nptg,noMAFs), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'ndx_path')
    allocate (dhdz_path(Nptg,noMAFs), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'dhdz_path')
    allocate (h_path(Nptg,noMAFs), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'h_path')
a690 10
    allocate (phi_path(Nptg,noMAFs), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'phi_path')
    allocate (t_path(Nptg,noMAFs), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'t_path')
    allocate (z_path(Nptg,noMAFs), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'z_path')

a693 8
    allocate (eta_phi(Nptg,noMAFs), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'eta_phi')

    allocate(elvar(noMAFs), STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'elvar')

d699 3
a701 30
    call allocate_test(geoc_lat, noMAFs, 'geoc_lat', ModuleName)
    call allocate_test(e_rad, noMAFs, 'e_rad', ModuleName)

    ! Assert radiance%template%noInstances=temp%template%noInstances
    if (temp%template%noInstances /= noMAFs) &
      & call MLSMessage(MLSMSG_Error,ModuleName,'no temperature profiles /= no maf')
    do maf = 1, noMAFs
      phi_tan = Deg2Rad*temp%template%phi(1,maf)
         ! ??? For the moment, change this soon.
      geod_lat= Deg2Rad*temp%template%geodLat(1,maf)
      call geoc_geod_conv(elvar(maf),orbIncline%values(1,1), &
        &  phi_tan,geod_lat, geoc_lat(maf),E_rad(maf))
    end do

    ! Compute the hydrostatic_model on the GL-Grid for all maf(s):
    ! First extend the grid below the surface.

    ! Now compute a hydrostatic grid given the temperature and refGPH
    ! information.
    call hydrostatic_model(ForwardModelConfig%SurfaceTangentIndex, &
      &  noMAFs, geoc_lat,0.001*refGPH%values(1,:), &
      &  refGPH%template%surfs(1,1), &
      &  ForwardModelConfig%integrationGrid%surfs, &
      &  temp%template%surfs(:,1),temp%values,z_glgrid,h_glgrid,t_glgrid, &
      &  dhdz_glgrid,dh_dt_glgrid, &
      &  ForwardModelConfig%TangentGrid%surfs, &
      &  tan_hts,tan_temp,tan_dh_dt, &
      &  gl_count, Ier)
    if(ier /= 0) goto 99

d710 1
a710 1
    "Grids", moduleName )
d714 28
a741 8
    no_tan_hts = ForwardModelConfig%TangentGrid%nosurfs
!    phi_window = ForwardModelConfig%phiWindow
    ! Now compute stuff along the path given this hydrostatic grid.
    call comp_path_entities(ForwardModelConfig%integrationGrid%noSurfs, &
      &  temp%template%noSurfs,gl_count,ndx_path,z_glgrid,t_glgrid,&
      &  h_glgrid,dhdz_glgrid,tan_hts,no_tan_hts,z_path,h_path,t_path,&
      &  phi_path,dhdz_path,eta_phi,temp%template%noInstances, &
      &  temp%template%phi(1,:)*Deg2Rad,noMAFs,elvar,Ier)
d744 50
a793 3
    ! The first part of the forward model dealt with the chunks as a whole.
    ! This next part is more complex, and is performed within a global outer
    ! loop over major frame (maf)
d795 1
a795 1
    ! ---------------------------- Begin main Major Frame loop --------
d797 10
a806 15
   do maf = 3, 3
!    do maf = 1, noMAFs
      print*,'Doing maf:',maf

 ! Compute the specie function (spsfunc) and the refraction along
 ! all the paths for the current maf

      Call get_path_spsfunc_ngrid(fwdModelIn, fwdModelExtra, &
     &     forwardModelConfig%molecules, ndx_path(:,maf),no_tan_hts, &
     &     z_path(:,maf), t_path(:,maf), phi_path(:,maf), n_path, &
     &     spsfunc_path, Ier)
      if(ier /= 0) goto 99
!
!??? Choose better value for phi_tan later
      phi_tan = Deg2Rad*temp%template%phi(1,maf)
d808 1
a808 12
      ! Compute the ptg_angles (chi) for Antenna convolution, also the
      ! derivatives of chi w.r.t to T and other parameters
      call get_chi_angles(ndx_path(:,maf),n_path,&
        &     forwardModelConfig%tangentGrid%surfs,        &
        &     tan_hts(:,maf),tan_temp(:,maf),phi_tan,elvar(maf)%Roc,&
        &     0.001*scGeocAlt%values(1,1),  &
        &     elevOffset%values(1,1), &
        &     tan_dh_dt(:,maf,:),no_tan_hts,temp%template%noSurfs, &
        &     temp%template%surfs(:,1),&
        &     forwardModelConfig%SurfaceTangentIndex, &
        &     center_angle,ptg_angles,dx_dt,d2x_dxdt,ier)
      if(ier /= 0) goto 99
d810 14
a823 32
      ! Compute the refraction correction scaling matrix for this mmaf:
      call refraction_correction(no_tan_hts, tan_hts(:,maf), h_path(:,maf), &
        &                n_path, ndx_path(:,maf), E_rad(maf), ref_corr)

      Radiances = 0.0

      ! If we're not doing frequency averaging, instead outputting radiances
      ! corresponding to delta function responses, we can setup the frequency
      ! information here.  In the more common case where we are doing the
      ! averaging the frequency grid varies from pointing to pointing, and is
      ! allocated inside the pointing loop.
      if (.not. forwardModelConfig%do_freq_avg) then
        ! Think later about multiple signals case!???
        noFreqs = count ( forwardModelConfig%signals(1)%channels )
        call allocate_test(frequencies,noFreqs,"frequencies",ModuleName)
        frequencies = pack ( signal%frequencies, &
          & forwardModelConfig%signals(1)%channels )
        !%%%%%%%%%%%%% DEBUG NJL
        signal%sideband=-1
        !%%%%%%%%%%%%%%
        select case (signal%sideband)
        case ( -1 )
          frequencies = signal%lo - (signal%centerFrequency+frequencies)
        case ( +1 )
          frequencies = signal%lo + (signal%centerFrequency+frequencies)
        case ( 0 )
          call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'Folded signal requested in forward model')
        case default
          call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'Bad value of signal%sideband')
        end select
d825 1
a825 1
      endif
d827 10
a836 9
      ! First we have a mini loop over pointings to work out an upper limit
      ! for the number of frequencies we're going to be dealing with
      maxNoFreqs = size(PointingGrids(whichPointingGrid)%OneGrid(grids(1))%Frequencies)
      do ptg_i = 2, no_tan_hts - 1
        maxNoFreqs = max ( maxNoFreqs, size(PointingGrids(whichPointingGrid) &
          & %OneGrid(grids(ptg_i))%Frequencies) )
      end do

      ! Now allocate arrays this size
d839 14
a852 3
        call Allocate_Test(k_temp_frq%values, maxNoFreqs, &
          &   temp%template%noSurfs, temp%template%noInstances, &
          &   'k_temp_frq', ModuleName)
d855 2
a856 1
      call Allocate_Test(radV,maxNoFreqs, 'radV', ModuleName)
d858 1
a858 3
      do specie = 1, noSpecies
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie))
d860 8
a867 6
        ! Allocate intermediate space for vmr derivatives
        if ( forwardModelConfig%moleculeDerivatives(specie) ) then
          call Allocate_Test( k_atmos_frq(specie)%values, &
            & maxNoFreqs, f%template%noSurfs, f%template%noInstances, &
            & 'k_atmos_frq(..)', ModuleName )
        end if
d869 1
a869 1
      end do ! End loop over speices
d871 1
a871 52
      ! Now we can go ahead and loop over pointings
      ! ------------------------------ Begin loop over pointings --------
      do ptg_i = 1, no_tan_hts - 1
        k = ptg_i
        h_tan = tan_hts(k,maf)

 ! Compute the beta's along the path, for this tanget hight and this mmaf:

        no_ele = ndx_path(ptg_i,maf)%total_number_of_elements

        ! If we're doing frequency averaging, get the frequencies we need for
        ! this pointing.
        if (ForwardModelConfig%do_freq_avg) then
!           call Allocate_Test(frequencies, &
!             & size(PointingGrids(whichPointingGrid)%&
!             &      oneGrid(grids(ptg_i))%frequencies),&
!             &      'frequencies', ModuleName)
!          Note that this deallocates the ones from the previous go round
!          print*,'Center frequency is:',PointingGrids(whichPointingGrid)%CenterFrequency
!          print*,'Offsets:'
!          call dump(PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies )
          frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
          noFreqs = size(frequencies)
        endif ! If not, we dealt with this outside the loop

        call get_beta_path ( frequencies, my_Catalog, no_ele, &
          &                  z_path(ptg_i,maf), t_path(ptg_i,maf), &
          &                  beta_path, 0.001*losVel%values(1,maf), ier )
        if(ier /= 0) goto 99
!
!  Define the dh_dt_path for this pointing and this MAF:
!
        ! Need to allocate this even if no derivatives as we pass it
        ALLOCATE(dh_dt_path(no_ele,temp%template%noInstances, &
          & temp%template%noSurfs),STAT=ier)

        if ( forwardModelConfig%temp_der ) then
          if(ier == 0) ALLOCATE(dum(no_ele),STAT=ier)
          IF(ier /= 0) then
            Print *,'** ALLOCATE Error: dum or dh_dt_path, STAT =',ier
            goto 99
          else
            do j = 1,  temp%template%noSurfs
              do i = 1, temp%template%noInstances
                CALL Lintrp(z_glgrid, z_path(ptg_i,maf)%values,       &
               &            dh_dt_glgrid(:,i,j), dum, gl_count, no_ele)
                dh_dt_path(:,i,j) = dum(:) * eta_phi(ptg_i,maf)%values(:,i)
              end do
            end do
            DEALLOCATE(dum,STAT=i)
          endif
        end if
d873 12
d886 1
a886 2
! ------------------------------- Begin loop over frequencies ------
        do frq_i = 1, noFreqs
d888 2
a889 1
          Frq = frequencies(frq_i)
d891 23
a913 39
          Call Rad_Tran(elvar(maf), Frq, &
             & forwardModelConfig%integrationGrid%noSurfs, h_tan, &
             & noSpecies, ndx_path(k,maf), z_path(k,maf), h_path(k,maf), &
             & t_path(k,maf), phi_path(k,maf), dHdz_path(k,maf), &
             & earthRefl%values(1,1),beta_path(:,frq_i), spsfunc_path(:,k), &
             & ref_corr(:,k), spaceRadiance%values(1,1), brkpt, no_ele, mid,&
             & ilo, ihi, t_script, tau, Rad, Ier)
          if(ier /= 0) goto 99

          RadV(frq_i) = Rad

! Now, Compute the radiance derivatives:

          if (ForwardModelConfig%temp_der) k_temp_frq%values=0.0_r8
          Call Rad_Tran_WD(ForwardModelConfig, FwdModelExtra, FwdModelIn, &
            &  elvar(maf),frq_i,Frq,noSpecies,z_path(k,maf), &
            &  h_path(k,maf),t_path(k,maf),phi_path(k,maf),dHdz_path(k,maf),&
            &  beta_path(:,frq_i),spsfunc_path(:,k),temp%template%surfs(:,1),&
            &  temp%template%noSurfs,ref_corr(:,k),temp%template%noInstances,&
            &  temp%template%phi(1,:)*Deg2Rad,dh_dt_path,&
            &  k_temp_frq,k_atmos_frq,brkpt,no_ele,mid,ilo,ihi, &
            &  t_script,tau,max_zeta_dim,max_phi_dim,ier)
          IF(ier /= 0) goto 99

        end do                          ! Frequency loop

! ----------------------------- End loop over frequencies ----

        ! Here we either frequency average to get the unconvolved radiances, or
        ! we just store what we have as we're using delta funciton channels

        if ( forwardModelConfig%do_freq_avg ) then
          if ( signal%sideband == 0 ) then
             call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Asked for folded in wrong place')
          else
            sense = signal%sideband
            centerFreq = signal%lo + sense * signal%centerFrequency
          end if
d916 15
a930 4
            call Freq_Avg(frequencies,                           &
              &       centerFreq+sense*FilterShapes(i)%FilterGrid, &
              &       FilterShapes(i)%FilterShape,RadV,noFreqs,    &
              &       Size(FilterShapes(i)%FilterGrid),Radiances(ptg_i,ch))
a931 2
        else
          Radiances(ptg_i,usedChannels) = RadV(1:noFreqs)
d933 1
d935 6
a940 3
        ! Frequency Average the temperature derivatives with the appropriate
        ! filter shapes
        if ( forwardModelConfig%temp_der) then
d944 15
a958 12
              do instance = 1, temp%template%noInstances
                do surface = 1, temp%template%noSurfs
                  ToAvg => k_temp_frq%values(1:noFreqs,surface,instance)
                  call Freq_Avg(frequencies,                        &
              &        centerFreq+sense*FilterShapes(i)%FilterGrid, &
              &        FilterShapes(i)%FilterShape,real(ToAvg,r8),  &
              &        noFreqs,Size(FilterShapes(i)%FilterGrid),r)
                  k_temp(ch,ptg_i,surface,instance) = r
                end do                  ! Surface loop
              end do                    ! Instance loop
            end do                      ! Channel loop
          else
d960 2
a961 2
              k_temp(i,ptg_i,1:temp%template%noSurfs,1:temp%template%noInstances) = &
                &  k_temp_frq%values(1,1:temp%template%noSurfs,1:temp%template%noInstances)
d963 32
d996 3
a998 1
        endif
d1000 2
a1001 64
        ! Frequency Average the atmospheric derivatives with the appropriate
        ! filter shapes
        do specie = 1, noSpecies
          if ( forwardModelConfig%moleculeDerivatives(specie) ) then
            f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
     &  quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie))
            if ( forwardModelConfig%do_freq_avg) then
              do i = 1, noUsedChannels
                ch = usedChannels(i)
                do instance = 1, f%template%noInstances
                  do surface = 1, f%template%noSurfs
                    ToAvg =>   &
              &        k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
                    call Freq_Avg(frequencies,                      &
              &          centerFreq+sense*FilterShapes(i)%FilterGrid, &
              &          FilterShapes(i)%FilterShape,real(ToAvg,r8),  &
              &          noFreqs,Size(FilterShapes(i)%FilterGrid),r)
                    k_atmos(ch,ptg_i,surface,instance,specie) = r
                  end do                ! Surface loop
                end do                  ! Instance loop
              end do                    ! Channel loop
            else                        ! Else not frequency averaging
              surface = f%template%noSurfs
              instance = f%template%noInstances
              do i = 1, noUsedChannels
                k_atmos(i,ptg_i,1:surface,1:instance,specie) = &
                       &  k_atmos_frq(specie)%values(1,1:surface,1:instance)
              end do
            end if                      ! Frequency averaging or not
          end if                        ! Want derivatives for this
        end do                          ! Loop over species


        deallocate (dh_dt_path, STAT=status)
        if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
          & MLSMSG_Deallocate//'dh_dt_path')

      end do                            ! Pointing Loop
      ! ---------------------------------- End of Pointing Loop ---------------

      ! Complete the radiances's last location, also  complete k_temp last
      ! location.

      do i = 1, noUsedChannels
        ch = usedChannels(i)
        Radiances(no_tan_hts,ch) = Radiances(no_tan_hts-1,ch)
        if(ForwardModelConfig%temp_der) then
          n = temp%template%noSurfs
          k = temp%template%noInstances
          k_temp(i,no_tan_hts,1:n,1:k)=k_temp(i,no_tan_hts-1,1:n,1:k)
        endif
        if(ForwardModelConfig%atmos_der) then
          do m = 1, noSpecies
            f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
              & quantityType=l_vmr, molecule=forwardModelConfig%molecules(m),&
              & foundInFirst=foundInFirst )
            if ( foundInFirst ) then
              k = f%template%noInstances
              n = f%template%noSurfs
              k_atmos(i,no_tan_hts,1:n,1:k,m)=k_atmos(i,no_tan_hts-1,1:n,1:k,m)
            endif
          end do
        endif
      end do
d1003 1
a1003 2
      !  Here comes the Convolution code
      do i = 1, noUsedChannels
d1005 1
a1005 1
        ch = usedChannels(i)
d1007 15
a1021 1
        if(ForwardModelConfig%do_conv) then
d1023 8
a1030 15
          ! Note I am replacing the i's in the k's with 1's (enclosed in
          ! brackets to make it clear.)  We're not wanting derivatives anyway
          ! so it shouldn't matter
          call convolve_all(forwardModelConfig, fwdModelIn, &
            &     ptan%values(:,maf), noSpecies, &
            &     ForwardModelConfig%tangentGrid%surfs,ptg_angles,&
            &     tan_temp(:,maf),dx_dt, d2x_dxdt,si,center_angle,&
            &     Radiances(:,ch),k_temp(i,:,:,:),k_atmos(i,:,:,:,:), &
            &     no_tan_hts,k_info_count,i_star_all(i,:), &
            &     k_star_all(i,:,:,:,:),k_star_info,&
            &     temp%template%noSurfs,temp%template%noInstances,&
            &     temp%template%surfs(:,1),AntennaPatterns(1),ier)
!??? Need to choose some index other than 1 for AntennaPatterns ???
          if(ier /= 0) goto 99
        else
d1032 1
a1032 8
          call no_conv_at_all(forwardModelConfig, fwdModelIn, &
            &     ptan%values(:,maf), noSpecies,  &
            &     ForwardModelConfig%tangentGrid%surfs, &
            &     Radiances(:,ch),k_temp(i,:,:,:),k_atmos(i,:,:,:,:), &
            &     no_tan_hts, k_info_count, i_star_all(i,:), &
            &     k_star_all(i,:,:,:,:),k_star_info, &
            &     temp%template%noSurfs,temp%template%noInstances, &
            &     temp%template%surfs(:,1))
d1034 1
a1034 1
        endif
d1036 6
a1041 1
      end do                            ! Channel loop
d1043 1
a1043 6
      do mif = 1, radiance%template%noSurfs
        do channel = 1, noUsedChannels
          k = usedChannels(channel)+(mif-1)*radiance%template%noChans
          radiance%values(k,maf) = i_star_all(channel,mif)
        end do
      end do
d1045 3
a1047 2
    end do                              ! MAF loop
    ! ------------------------------ End of Major Frame Loop -----------
d1085 3
a1087 3
! ** DEBUG, Zvi
!   if(i > -22) Stop
! ** END DEBUG
d1137 9
a1145 9
    deallocate (ndx_path, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'ndx_path')
    deallocate (dhdz_path, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'dhdz_path')
    deallocate (h_path, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'h_path')
d1149 9
a1157 9
    deallocate (phi_path, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'phi_path')
    deallocate (t_path, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'t_path')
    deallocate (z_path, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'z_path')
d1161 6
a1166 6
    deallocate (eta_phi, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'eta_phi')
    deallocate (elvar, STAT=status)
    if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName, &
      & MLSMSG_Deallocate//'elvar')
d1170 2
a1171 2
    call deallocate_test(geoc_lat, 'geoc_lat', ModuleName)
    call deallocate_test(e_rad, 'e_rad', ModuleName)
d1173 3
a1175 3
! ** DEBUG, Zvi
!    if(i > -22) Stop
! ** END DEBUG
d1223 3
@


2.78
log
@Finish removing sideband stuff
@
text
@d18 1
a18 1
    & ForwardModelConfig_T, ForwardModelSignalInfo_T
d48 1
d65 1
a65 1
    ForwardModelGlobalSetup, ForwardModelSignalInfo_T
d73 1
a73 1
    & "$Id: ForwardModelInterface.f90,v 2.77 2001/04/10 10:15:48 zvi Exp $"
d147 1
d155 1
a155 1
    type (forwardModelSignalInfo_T), pointer :: thisFWMSignal=>NULL() ! A signal
d164 1
d171 1
d173 4
a176 1

d220 21
a240 21
      case ( f_channels )
        if ( .not. associated( info%siginfo ) ) then
          call AnnounceError(DefineSignalsFirst, key)
        else
          noChannelsSpecs=noChannelsSpecs+1
          thisFWMSignal => info%sigInfo(noChannelsSpecs)
          ! Now default to none included
          thisFWMSignal%channelIncluded = .false.
          do j = 2, nsons(son)
            call expr ( subtree(j,son), units, value, type )
            select case (type)
            case (num_value)
              thisFWMSignal%channelIncluded(int(value(1))) = .true.
            case (range)
              thisFWMSignal%channelIncluded(int(value(1)):int(value(2))) =&
                & .true.
            case default
              ! Shouldn't get here if parser worked
            end select
          end do
        end if
d264 1
a264 1
        allocate ( info%sigInfo (nsons(son)-1), stat = status)
d267 15
a281 10
          info%sigInfo(j)%signal = &
            & decoration(decoration( subtree(j+1, son )))
          ! Now allocate the channels information
          thisSignal = GetSignal( info%sigInfo(j)%signal )
          allocate ( info%sigInfo(j)%channelIncluded( &
            & lbound(thisSignal%frequencies,1):ubound(thisSignal%frequencies,1)),&
            & stat=status)
          if (status /= 0) then
            call AnnounceError ( AllocateError, key )
            exit
d283 2
a284 2
          ! Default to include this channel
          info%sigInfo(j)%channelIncluded = .true.
a342 2
  ! subroutine ForwardModel ( ForwardModelConfig, FwdModelExtra, FwdModelIn, &
  !   &                       Jacobian, RowBlock, FwdModelOut )
d406 3
a410 3
    real(r4) :: K_SPECT_DW(25,Nptg,mxco,mnp,Nsps),  &
                K_SPECT_DN(25,Nptg,mxco,mnp,Nsps),  &
                K_SPECT_DNU(25,Nptg,mxco,mnp,Nsps)
d417 1
a417 3
    type(path_derivative) :: k_temp_frq, k_atmos_frq(Nsps), &
                k_spect_dw_frq(Nsps), k_spect_dn_frq(Nsps), &
                k_spect_dnu_frq(Nsps)
d506 1
a506 1
    if (size(forwardModelConfig%sigInfo) > 1) call MLSMessage ( &
d509 1
a509 1
    signal = GetSignal(forwardModelConfig%sigInfo(1)%signal)
d513 1
a513 1
      & signal= forwardModelConfig%sigInfo(1)%signal )
d578 2
a579 2
    ForwardModelConfig%temp_der = .true.
    ForwardModelConfig%atmos_der = .true.
d609 1
a609 1
    signal = getSignal ( forwardModelConfig%sigInfo(1)%signal )
d616 1
a616 1
    noUsedChannels = count ( forwardModelConfig%sigInfo(1)%channelIncluded)
d621 1
a621 1
    usedChannels = pack ( channelIndex, forwardModelConfig%sigInfo(1)%channelIncluded)
d723 2
a724 2
!   do maf = 3, 3
    do maf = 1, noMAFs
d765 1
a765 1
        noFreqs = count ( forwardModelConfig%sigInfo(1)%channelIncluded )
d768 4
a771 1
          & forwardModelConfig%sigInfo(1)%channelIncluded )
a815 12
        ! Allocate intermediate space for spectroscopy derivatives
        if ( forwardModelConfig%spect_der ) then
          call Allocate_Test( k_spect_dw_frq(specie)%values, &
            & maxNoFreqs, f%template%noSurfs, f%template%noInstances, &
            & 'k_spect_dw_frq(..)', ModuleName )
          call Allocate_Test( k_spect_dn_frq(specie)%values, &
            & maxNoFreqs, f%template%noSurfs, f%template%noInstances, &
            & 'k_spect_dn_frq(..)', ModuleName )
          call Allocate_Test( k_spect_dnu_frq(specie)%values, &
            & maxNoFreqs, f%template%noSurfs, f%template%noInstances, &
            & 'k_spect_dnu_frq(..)', ModuleName )
        endif
a983 48
!        if(ForwardModelConfig%spect_der) then
! Frequency Average the spectroscopic derivatives with the appropriate
! filter shapes
!           do i = 1, noUsedChannels
!             ch = usedChannels(i)
!             do m = 1, FMI%n_sps
!               j = FMI%spect_atmos(m)
!               if(.not.  FMI%spectroscopic(j)%DER_CALC(FMI%band)) cycle
!               Spectag = FMI%spectroscopic(j)%Spectag
!               do
!                 if(FMI%spectroscopic(j)%Spectag /= Spectag) exit
!                 RadV(1:noFreqs) = 0.0
!                 CA = FMI%spectroscopic(j)%type
!                 do k = 1, FMI%spectroscopic(j)%no_phi_values
!                   do n = 1, FMI%spectroscopic(j)%no_zeta_values
!                     select case ( CA )
!                     case ( 'W' )
!                       RadV(1:noFreqs) = k_spect_dw_frq(m)%values(1:noFreqs,n,k)
!                     case ( 'N' )
!                       RadV(1:noFreqs) = k_spect_dn_frq(m)%values(1:noFreqs,n,k)
!                     case ( 'V' )
!                       RadV(1:noFreqs) = k_spect_dnu_frq(m)%values(1:noFreqs,n,k)
!                     end select
!                     if(ForwardModelConfig%do_freq_avg) then
!                       call Freq_Avg(frequencies,                        &
!                      &     centerFreq+sense*FilterShapes(i)%FilterGrid, &
!                      &     FilterShapes(i)%FilterShape,RadV,            &
!                      &     noFreqs,Size(FilterShapes(i)%FilterGrid),r)
!
!                     else
!                       r = RadV(1)
!                     endif
!                     select case ( CA )
!                     case ( 'W' )
!                       k_spect_dw(ch,ptg_i,n,k,j) = r
!                     case ( 'N' )
!                       k_spect_dn(ch,ptg_i,n,k,j) = r
!                     case ( 'V' )
!                       k_spect_dnu(ch,ptg_i,n,k,j) = r
!                     end select
!                   end do
!                 end do
!                 j = j + 1
!                 if(j > 3 * FMI%n_sps) exit
!               end do
!             end do
!           end do
!        endif
d993 1
a993 1
      ! location as well as k_atmos last location and k_spect_d? last location:
a1014 17
!         if(ForwardModelConfig%spect_der) then
!           do m = 1, noSpecies
!             j = FMI%spect_atmos(m)
!             if(.not.  FMI%spectroscopic(j)%DER_CALC(FMI%band)) cycle
!             Spectag =  FMI%spectroscopic(j)%Spectag
!             do
!               if(FMI%spectroscopic(j)%Spectag /= Spectag) exit
!               k = FMI%spectroscopic(j)%no_phi_values
!               n = FMI%spectroscopic(j)%no_zeta_values
!               k_spect_dw(i,no_tan_hts,1:n,1:k,j)=k_spect_dw(i,no_tan_hts-1,1:n,1:k,j)
!               k_spect_dn(i,no_tan_hts,1:n,1:k,j)=k_spect_dn(i,no_tan_hts-1,1:n,1:k,j)
!               k_spect_dnu(i,no_tan_hts,1:n,1:k,j)=k_spect_dnu(i,no_tan_hts-1,1:n,1:k,j)
!               j = j + 1
!               if(j > 3 * FMI%n_sps) exit
!             end do
!           end do
!         endif
d1064 5
a1068 8
    do j = 1, noSpecies
      if(ForwardModelConfig%atmos_der) deallocate(k_atmos_frq(j)%values,STAT=i)
      if(ForwardModelConfig%spect_der) then
        deallocate(k_spect_dw_frq(j)%values,STAT=i)
        deallocate(k_spect_dn_frq(j)%values,STAT=i)
        deallocate(k_spect_dnu_frq(j)%values,STAT=i)
      endif
    end do
d1237 3
@


2.77
log
@fixing bug conneced with convolve
@
text
@d33 3
a35 3
  use Init_Tables_Module, only: L_CHANNEL, L_EARTHREFL, L_ELEVOFFSET, L_FULL, L_FOLDED, &
    & L_LINEAR, L_LOSVEL, L_LOWER, L_NONE, L_ORBITINCLINE, L_PTAN, L_RADIANCE,&
    & L_REFGPH, L_SCAN, L_SCGEOCALT, L_SPACERADIANCE, L_TEMPERATURE, L_UPPER,&
d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.76 2001/04/10 02:46:16 livesey Exp $"
d762 1
a762 1
        case ( l_lower )
d764 1
a764 1
        case ( l_upper )
d766 1
a766 1
        case ( l_folded )
d910 1
a910 8
          select case (signal%sideband)
          case (l_lower)
            centerFreq = signal%lo - signal%centerFrequency
            sense = -1.0
          case (l_upper)
            centerFreq = signal%lo + signal%centerFrequency
            sense = +1.0
          case default              ! Put error message here later
d913 4
a916 1
          end select
d1306 3
@


2.76
log
@Working version, no more FMI/TFMI
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.75 2001/04/10 02:24:55 livesey Exp $"
d569 1
d572 4
a575 3
!   do j = 1, noSpecies
!     forwardModelConfig%moleculeDerivatives(j) = .true.
!   end do
d715 2
a716 2
    do maf = 3, 3
    !do maf = 1, noMAFs
d893 7
a899 7
            &     elvar(maf),frq_i,Frq,noSpecies,z_path(k,maf), &
            &     h_path(k,maf),t_path(k,maf),phi_path(k,maf),dHdz_path(k,maf),&
            &     beta_path(:,frq_i),spsfunc_path(:,k),temp%template%surfs(:,1),&
            &     temp%template%noSurfs,ref_corr(:,k),temp%template%noInstances,&
            &     temp%template%phi(1,:)*Deg2Rad,dh_dt_path,&
            &     k_temp_frq,k_atmos_frq,brkpt,no_ele,mid,ilo,ihi, &
            &     t_script,tau,max_zeta_dim,max_phi_dim,ier)
d979 2
d982 2
a983 2
                k_atmos(i,ptg_i,:,:,specie) = &
                       &  k_atmos_frq(specie)%values(1,:,:)
d1052 3
a1054 3
          k_temp(i,no_tan_hts,1:temp%template%noSurfs,1:temp%template%noInstances) = &
            &              k_temp(i,no_tan_hts-1,1:temp%template%noSurfs,&
            &              1:temp%template%noInstances)
d1059 1
a1059 1
              & quantityType=l_vmr, molecule=forwardModelConfig%molecules(m), &
a1060 1

d1101 3
a1103 4
            &     Radiances(:,ch),k_temp(i,:,:,:), &
            &     k_atmos(i,:,:,:,:), &
            &     no_tan_hts,k_info_count,&
            &     i_star_all(i,:),k_star_all(i,:,:,:,:),k_star_info,&
d1105 1
a1105 2
            &     temp%template%surfs(:,1),&
            &     AntennaPatterns(1),ier)
d1111 1
a1111 1
            & ptan%values(:,maf), noSpecies,  &
d1113 3
a1115 4
            &     Radiances(:,ch),k_temp(i,:,:,:),  &
            &     k_atmos(i,:,:,:,:), &
            &     no_tan_hts, k_info_count,       &
            &     i_star_all(i,:), k_star_all(i,:,:,:,:),k_star_info, &
d1310 3
@


2.75
log
@Stable derivative code, still not sure about vmr.  About to remove FMI, TFMI!!  :-)
@
text
@a36 2
  ! Now temporary stuff we hope not to have to use in the end
  use Init_Tables_Module, only: F_ZVI
a60 4
  !??? The next USE statement is Temporary for l2load:
  use L2_TEST_STRUCTURES_M, only: FWD_MDL_CONFIG, FWD_MDL_INFO, &
    & TEMPORARY_FWD_MDL_INFO

d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.74 2001/04/10 01:16:10 livesey Exp $"
d334 1
a334 1
    &                       Jacobian, RowBlock, FwdModelOut, FMI, TFMI)
a337 1
    use L2_TEST_STRUCTURES_M
a371 7
    !??? Begin temporary stuff to start up the forward model
    !   type(fwd_mdl_info), dimension(:), pointer, optional :: FMI
    type(fwd_mdl_info),                        optional :: FMI
    !   type(temporary_fwd_mdl_info), dimension(:), pointer, optional :: TFMI
    type(temporary_fwd_mdl_info),                        optional :: TFMI
    !??? End of temporary stuff to start up the forward model

d1310 3
@


2.74
log
@Another interim version.
@
text
@d78 1
a78 1
    & "$Id: ForwardModelInterface.f90,v 2.73 2001/04/09 22:21:41 livesey Exp $"
d905 1
a905 1
            &     elvar(maf),frq_i,FMI%band,Frq,noSpecies,z_path(k,maf), &
d909 2
a910 3
            &     temp%template%phi(1,:)*Deg2Rad,dh_dt_path,FMI%spect_atmos,&
            &     FMI%spectroscopic,k_temp_frq,k_atmos_frq,k_spect_dw_frq, &
            &     k_spect_dn_frq,k_spect_dnu_frq,brkpt,no_ele,mid,ilo,ihi, &
d1079 17
a1095 17
        if(ForwardModelConfig%spect_der) then
          do m = 1, noSpecies
            j = FMI%spect_atmos(m)
            if(.not.  FMI%spectroscopic(j)%DER_CALC(FMI%band)) cycle
            Spectag =  FMI%spectroscopic(j)%Spectag
            do
              if(FMI%spectroscopic(j)%Spectag /= Spectag) exit
              k = FMI%spectroscopic(j)%no_phi_values
              n = FMI%spectroscopic(j)%no_zeta_values
              k_spect_dw(i,no_tan_hts,1:n,1:k,j)=k_spect_dw(i,no_tan_hts-1,1:n,1:k,j)
              k_spect_dn(i,no_tan_hts,1:n,1:k,j)=k_spect_dn(i,no_tan_hts-1,1:n,1:k,j)
              k_spect_dnu(i,no_tan_hts,1:n,1:k,j)=k_spect_dnu(i,no_tan_hts-1,1:n,1:k,j)
              j = j + 1
              if(j > 3 * FMI%n_sps) exit
            end do
          end do
        endif
d1112 1
a1112 1
            &     FMI%fft_pts,Radiances(:,ch),k_temp(i,:,:,:), &
d1123 2
a1124 1
          call no_conv_at_all(ptan%values(:,maf),noSpecies, &
a1125 2
            &     FMI%band,ForwardModelConfig%temp_der,&
            &     ForwardModelConfig%atmos_der,ForwardModelConfig%spect_der,&
d1127 2
a1128 3
            &     k_atmos(i,:,:,:,:),k_spect_dw(i,:,:,:,:),       &
            &     k_spect_dn(i,:,:,:,:),k_spect_dnu(i,:,:,:,:),   &
            &     FMI%spect_atmos,no_tan_hts, k_info_count,       &
d1131 1
a1131 2
            &     TFMI%no_phi_f,temp%template%surfs(:,1),TFMI%atmospheric,&
            &     FMI%spectroscopic)
d1324 3
@


2.73
log
@An interim version, derivatives get right numbers.
@
text
@d78 1
a78 1
    & "$Id: ForwardModelInterface.f90,v 2.72 2001/04/09 21:05:40 vsnyder Exp $"
d478 1
a478 1
    real(r8), dimension(:,:,:), allocatable :: DH_DT_PATH  ! (pathSize, Tsurfs, Tinstance)
d484 2
d584 1
a584 1
!   ForwardModelConfig%atmos_der = .true.
d727 2
a728 2
 !  do maf = 3, 3
    do maf = 1, noMAFs
a833 1
        print*,'Pointing:',ptg_i
d863 4
a867 3
          DEALLOCATE(dum,dh_dt_path,STAT=i)
          ALLOCATE(dh_dt_path(no_ele,temp%template%noInstances, &
                 & temp%template%noSurfs),STAT=ier)
d883 1
a883 2
!
        print*,'Frequencies:',frequencies
a889 2
          print*,'Calling rad tran'

a900 2
          print*,'Calling rad tran wd'

d903 1
a903 1
          k_temp_frq%values=0.0_r8
d905 8
a912 8
         &     elvar(maf),frq_i,FMI%band,Frq,noSpecies,z_path(k,maf), &
         &     h_path(k,maf),t_path(k,maf),phi_path(k,maf),dHdz_path(k,maf),&
         &     beta_path(:,frq_i),spsfunc_path(:,k),temp%template%surfs(:,1),&
         &     temp%template%noSurfs,ref_corr(:,k),temp%template%noInstances,&
         &     temp%template%phi(1,:)*Deg2Rad,dh_dt_path,FMI%spect_atmos,&
         &     FMI%spectroscopic,k_temp_frq,k_atmos_frq,k_spect_dw_frq, &
         &     k_spect_dn_frq,k_spect_dnu_frq,brkpt,no_ele,mid,ilo,ihi, &
         &     t_script,tau,max_zeta_dim,max_phi_dim,ier)
d1049 4
d1070 2
a1071 1
              & quantityType=l_vmr, molecule=forwardModelConfig%molecules(m))
d1073 1
a1073 1
            if(TFMI%atmospheric(m)%der_calc(FMI%band)) then
d1109 2
a1110 3
          call convolve_all(ptan%values(:,maf),TFMI%atmospheric, &
            &     noSpecies,ForwardModelConfig%temp_der, &
            &     ForwardModelConfig%atmos_der,ForwardModelConfig%spect_der,&
d1112 1
a1112 1
            &     tan_temp(:,maf),dx_dt, d2x_dxdt,FMI%band,si,center_angle,&
d1114 2
a1115 3
            &     k_atmos(i,:,:,:,:),k_spect_dw(i,:,:,:,:), &
            &     k_spect_dn(i,:,:,:,:),k_spect_dnu(i,:,:,:,:),&
            &     FMI%spect_atmos,no_tan_hts,k_info_count,&
d1118 2
a1119 2
            &     TFMI%no_phi_f,FMI%spectroscopic,temp%template%surfs(:,1),&
            &     AntennaPatterns(1),FMI%Ias,ier)
d1279 1
a1279 1
    if(i > -22) Stop
d1328 3
@


2.72
log
@Remove unneeded explicit conversion to double
@
text
@d61 1
d78 1
a78 1
    & "$Id: ForwardModelInterface.f90,v 2.71 2001/04/09 20:51:03 zvi Exp $"
d758 1
a758 1
      Radiances(1:Nptg,1:25) = 0.0
d832 1
d882 1
d889 2
d902 2
d906 1
d934 1
a934 1
            call MLSMessage(MLSMSG_Error, ModuleName, &
d967 2
a968 1
              k_temp(i,ptg_i,:,:) = k_temp_frq%values(1,:,:)
d1123 1
d1136 1
d1328 3
@


2.71
log
@Debugging Derivatives version
@
text
@a10 2
  !??? Do we want a forward model database ???

d77 1
a77 1
    & "$Id: ForwardModelInterface.f90,v 2.70 2001/04/07 23:59:32 zvi Exp $"
d724 2
a725 2
    do maf = 3, 3
 !  do maf = 1, noMAFs
a1185 1
    tau(1:) = 0.0
d1187 2
a1188 1
    tau(1:m) = dble(ptan%values(1:m,3))
d1317 3
@


2.70
log
@Ellimination the second dimension from ptg_angles (not MAF dependant)
@
text
@d79 1
a79 1
    & "$Id: ForwardModelInterface.f90,v 2.69 2001/04/07 23:49:54 zvi Exp $"
a189 1
    info%atmos_der = .false.
d193 2
d196 1
a196 1
    info%temp_der = .false.
d370 4
a373 1
    type(forwardModelConfig_T), intent(in) :: forwardModelConfig ! From ForwardModelSetup
d397 3
a399 3
      m, prev_npf, ier, maf, si, ptg_i, &
      frq_i, klo, n, brkpt, no_ele, mid, ilo, ihi, &
      k_info_count, gl_count, ld
d423 2
a424 2
      k_spect_dw_frq(Nsps), k_spect_dn_frq(Nsps), &
      k_spect_dnu_frq(Nsps)
d580 31
a610 1

d688 1
a688 1
      &  noMAFs, geoc_lat,refGPH%values(1,:)/1.0e3, &
d736 1
a736 1
     &     spsfunc_path(:,:), Ier)
a758 1
      prev_npf = -1
d836 1
a836 1
        ! Compute the beta's along the path, for this tanget hight and this mmaf:
d863 1
d889 6
a894 6
            &    forwardModelConfig%integrationGrid%noSurfs, &
            &    h_tan, noSpecies, ndx_path(k,maf),  &
            &    z_path(k,maf), h_path(k,maf), t_path(k,maf), phi_path(k,maf),&
            &    dHdz_path(k,maf),earthRefl%values(1,1),beta_path(:,frq_i),  &
            &    spsfunc_path(:,k), ref_corr(:,k), spaceRadiance%values(1,1), &
            &    brkpt, no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier)
d901 10
a910 16
!         Call Rad_Tran_WD(elvar(maf),frq_i,FMI%band,Frq, &
!        &     ForwardModelConfig%integrationGrid%noSurfs,FMI%n_sps, &
!        &     ForwardModelConfig%temp_der,forwardModelConfig%atmos_der, &
!        &     ForwardModelConfig%spect_der,            &
!        &     z_path(k,maf),h_path(k,maf),t_path(k,maf),phi_path(k,maf),   &
!        &     dHdz_path(k,maf),TFMI%atmospheric,beta_path(:,frq_i),&
!        &     spsfunc_path(:,k),temp%template%surfs(:,1),  &
!        &     TFMI%f_zeta_basis,TFMI%no_coeffs_f,   &
!        &     TFMI%mr_f,TFMI%no_t,ref_corr(:,k),TFMI%no_phi_f,       &
!        &     TFMI%f_phi_basis,temp%template%noInstances, &
!        &     temp%template%phi(1,:)*Deg2Rad,  &
!        &     dh_dt_path,FMI%spect_atmos,         &
!        &     FMI%spectroscopic,k_temp_frq,k_atmos_frq,k_spect_dw_frq,   &
!        &     k_spect_dn_frq,k_spect_dnu_frq,TFMI%is_f_log,brkpt,       &
!        &     no_ele,mid,ilo,ihi,t_script,tau,ier)
!         IF(ier /= 0) goto 99
d913 1
a930 1

a937 1

d939 1
a939 3

          Radiances(ptg_i, usedChannels) = RadV

d960 3
a962 1
            k_temp(:,ptg_i,:,:) = k_temp_frq%values
d971 1
a971 3
              & quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie))

            print*,'Doing a vmr derivative'
d988 4
a991 1
              k_atmos(:,ptg_i,:,:,specie)=  k_atmos_frq(specie)%values
d997 2
a998 2
!           ! Frequency Average the spectroscopic derivatives with the appropriate
!           ! filter shapes
d1101 11
a1111 13
            &     noSpecies, &
            &     ForwardModelConfig%temp_der,ForwardModelConfig%atmos_der,&
            &     ForwardModelConfig%spect_der,                   &
            &     ForwardModelConfig%tangentGrid%surfs,&
            &     ptg_angles,tan_temp(:,maf), &
            &     dx_dt, d2x_dxdt,FMI%band,si,center_angle,FMI%fft_pts,   &
            &     Radiances(:,ch),k_temp((1),:,:,:),k_atmos((1),:,:,:,:), &
            &     k_spect_dw((1),:,:,:,:),k_spect_dn((1),:,:,:,:),    &
            &     k_spect_dnu((1),:,:,:,:),FMI%spect_atmos,&
            &     ForwardModelConfig%tangentGrid%noSurfs,  &
            &     k_info_count,i_star_all(i,:),k_star_all((1),:,:,:,:), &
            &     k_star_info,temp%template%noSurfs,temp%template%noInstances,&
            &     TFMI%no_phi_f, FMI%spectroscopic,temp%template%surfs(:,1), &
a1115 3
          ! Note I am replacing the i's in the k's with 1's (enclosed in
          ! brackets to make it clear.)  We're not wanting derivatives anyway
          ! so it shouldn't matter
d1119 8
a1126 9
            &     ForwardModelConfig%atmos_der,ForwardModelConfig%spect_der,      &
            &     Radiances(:,ch),k_temp((1),:,:,:),                    &
            &     k_atmos((1),:,:,:,:),k_spect_dw((1),:,:,:,:),       &
            &     k_spect_dn((1),:,:,:,:),k_spect_dnu((1),:,:,:,:),   &
            &     FMI%spect_atmos, ForwardModelConfig%tangentGrid%noSurfs,&
            &     k_info_count,               &
            &     i_star_all(i,:), k_star_all((1),:,:,:,:),            &
            &     k_star_info,temp%template%noSurfs,temp%template%noInstances, &
            &     TFMI%no_phi_f,temp%template%surfs(:,1),TFMI%atmospheric,    &
d1134 2
a1135 2
          radiance%values( usedChannels(channel)+ &
            & (mif-1)*radiance%template%noChans, maf ) = i_star_all( channel, mif )
a1170 8
    tau(1:Nptg) = 0.0
    tau(1:ptan%template%noSurfs) = dble(ptan%values(:,3))

    klo = -1
    Zeta = -1.666667
    call Hunt_zvi(Zeta,tau,ptan%template%noSurfs,klo,j)
    if(abs(Zeta-tau(j)) < abs(Zeta-tau(klo))) klo=j

d1182 1
a1182 1
!   if(i > -2) Stop
d1188 9
d1225 1
a1225 1
        print *,(k_star_all(ch,kz,m,ptan%template%noSurfs,klo),k=1,ht_i)
d1269 5
a1273 1
    return
d1319 3
@


2.69
log
@Code modified to do spsfunc & refraction inside the MAF loop
@
text
@d79 1
a79 1
    & "$Id: ForwardModelInterface.f90,v 2.68 2001/04/07 01:50:48 vsnyder Exp $"
d403 1
a403 1
    real(r8) :: ptg_angles(Nptg,mnm), center_angle
d718 1
a718 1
        &     center_angle,ptg_angles(:,maf),dx_dt,d2x_dxdt,ier)
d1077 1
a1077 1
            &     ptg_angles(:,maf),tan_temp(:,maf), &
d1167 4
d1292 3
@


2.68
log
@Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
some related stuff to fwdmdl/ForwardModelConfig.
@
text
@d59 1
a59 1
  use Units, only: DegToRad => Deg2Rad
d79 1
a79 1
    & "$Id: ForwardModelInterface.f90,v 2.67 2001/04/07 01:38:22 livesey Exp $"
d351 1
d360 1
a360 1
    ! use RAD_TRAN_WD_M, only: RAD_TRAN_WD
d479 1
a479 1
    integer, pointer, dimension(:) :: GRIDS=>NULL()       ! Frq grid for each tan_press
d483 2
a486 1
    type(path_vector), allocatable, dimension(:,:) :: N_PATH    ! (Nptg,mnm)
d491 2
a492 2
! dimensions of SPSFUNC_PATH are: (Nsps,Nptg,mnm)
    type(path_vector), allocatable, dimension(:,:,:) :: SPSFUNC_PATH
d560 1
a560 1
    !  Create a subset of the catalog composed only of those molecules to be 
d572 1
a572 1
          exit
d605 1
a605 1
    allocate (n_path(Nptg,noMAFs), STAT=status)
d618 1
a618 1
    allocate (spsfunc_path(noSpecies,Nptg,noMAFs), STAT=status)
d641 1
a641 1
      phi_tan = degToRad*temp%template%phi(1,maf)
d643 1
a643 1
      geod_lat= degToRad*temp%template%geodLat(1,maf)
d679 5
a683 7
    call comp_path_entities(fwdModelIn, fwdModelExtra, &
      &  forwardModelConfig%molecules, &
      &  ForwardModelConfig%integrationGrid%noSurfs,temp%template%noSurfs,&
      &  gl_count,ndx_path,z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid, &
      &  tan_hts,no_tan_hts, z_path,h_path,t_path, phi_path,n_path,&
      &  dhdz_path,eta_phi,temp%template%noInstances, &
      &  temp%template%phi(1,:)*degToRad,spsfunc_path,noMAFs,elvar,Ier)
d692 2
a693 2
    !do maf = 3, 3
    do maf = 1, noMAFs
d696 11
a706 1
      phi_tan = degtorad*temp%template%phi(1,maf) !??? Choose better value later
d710 1
a710 1
      call get_chi_angles(ndx_path(:,maf),n_path(:,maf),&
d713 1
a713 1
        &     1.0e-3*scGeocAlt%values(1,1),  &
d715 2
a716 1
        &     tan_dh_dt(:,maf,:),no_tan_hts,temp%template%noSurfs,temp%template%surfs(:,1),&
d723 1
a723 1
        &                n_path(:,maf), ndx_path(:,maf), E_rad(maf), ref_corr)
d823 2
a824 2
          &                  z_path(ptg_i,maf), t_path(ptg_i,maf), beta_path, &
          &                  0.001*losVel%values(1,maf), ier )
d849 1
a849 1
        ! ------------------------------- Begin loop over frequencies ------
d851 1
d854 1
a854 1
          call Rad_Tran(elvar(maf), Frq, &
d858 3
a860 3
            &    dHdz_path(k,maf), earthRefl%values(1,1), beta_path(:,frq_i),      &
            &    spsfunc_path(:,k,maf), ref_corr(:,k), spaceRadiance%values(1,1), brkpt, &
            &    no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier)
d865 18
a882 17
          ! Now, Compute the radiance derivatives:
          !         CALL Rad_Tran_WD(elvar(maf),frq_i,FMI%band,Frq, &
          !        &     ForwardModelConfig%integrationGrid%noSrfs,FMI%n_sps, &
          !        &     ForwardModelConfig%temp_der,forwardModelConfig%atmos_der, &
          !        &     ForwardModelConfig%spect_der,            &
          !        &     z_path(k,maf),h_path(k,maf),t_path(k,maf),phi_path(k,maf),   &
          !        &     dHdz_path(k,maf),TFMI%atmospheric,beta_path(:,frq_i),&
          !        &     spsfunc_path(:,k,maf),temp%template%surfs(:,1),  &
          !        &     TFMI%f_zeta_basis,TFMI%no_coeffs_f,   &
          !        &     TFMI%mr_f,TFMI%no_t,ref_corr(:,k),TFMI%no_phi_f,       &
          !        &     TFMI%f_phi_basis,temp%template%noInstances, &
          !        &     temp%template%phi(1,:)*degToRad,  &
          !        &     dh_dt_path,FMI%spect_atmos,         &
          !        &     FMI%spectroscopic,k_temp_frq,k_atmos_frq,k_spect_dw_frq,   &
          !        &     k_spect_dn_frq,k_spect_dnu_frq,TFMI%is_f_log,brkpt,       &
          !        &     no_ele,mid,ilo,ihi,t_script,tau,ier)
          !         IF(ier /= 0) goto 99
d885 1
a885 1
        ! ----------------------------- End loop over frequencies ----
d1288 4
a1495 1
!
@


2.67
log
@Another interim working version
@
text
@d6 1
a6 1
  !=============================================================================
a17 1
  use Dump_0, only: DUMP
d19 2
d51 1
a51 1
  use Output_M, only: Output, Blanks
d62 1
a62 1
  use VGrid, only: VGRID_T, DUMP
d70 6
a75 7
  public :: AddForwardModelConfigToDatabase, ConstructForwardModelConfig, &
    Dump, DestroyFWMConfigDatabase, ForwardModel, ForwardModelGlobalSetup, &
    ForwardModelConfig_T, ForwardModelSignalInfo_T

  interface DUMP
    module procedure DUMP_FORWARDMODELCONFIGS
  end interface
d79 1
a79 1
    & "$Id: ForwardModelInterface.f90,v 2.66 2001/04/06 21:53:40 vsnyder Exp $"
a84 22
  type ForwardModelSignalInfo_T
    integer :: signal                   ! The signal we're considering
    logical, dimension(:), pointer :: channelIncluded=>null() ! Which channels to use
  end type ForwardModelSignalInfo_T

  type ForwardModelConfig_T
    integer :: fwmType        ! l_linear, l_full or l_scan
    logical :: Atmos_Der      ! Do atmospheric derivatives
    logical :: Do_Conv        ! Do convolution
    logical :: Do_Freq_Avg    ! Do Frequency averaging
    integer, dimension(:), pointer :: molecules=>NULL() ! Which molecules to consider
    logical, dimension(:), pointer :: moleculeDerivatives=>NULL() ! Want jacobians
    real(r8) :: The_Freq      ! Frequency to use if .not. do_freq_avg
    type (ForwardModelSignalInfo_T), dimension(:), pointer :: siginfo=>NULL()
    logical :: Spect_Der      ! Do spectroscopy derivatives
    logical :: Temp_Der       ! Do temperature derivatives
    type(vGrid_T), pointer :: integrationGrid ! Zeta grid for integration
    type(vGrid_T), pointer :: tangentGrid     ! Zeta grid for integration
    integer :: surfaceTangentIndex  ! Index in Tangentgrid of Earth's surface
    integer :: phiWindow            ! Window size for examining stuff
  end type ForwardModelConfig_T

d149 1
a149 1
  type (ForwardModelConfig_T) function ConstructForwardModelConfig &
d159 2
a160 2
    type (Signal_T) :: thisSignal ! A signal
    type (ForwardModelSignalInfo_T), pointer :: thisFWMSignal=>NULL() ! A signal
d301 2
a302 2
      if (.not. all(got( (/f_molecules, f_signals/) ))) &
        & call AnnounceError (IncompleteFullFwm, root)
d811 3
a813 3
        call get_beta_path(frequencies,My_Catalog,no_ele,z_path(ptg_i,maf), &
          &                t_path(ptg_i,maf),beta_path,                  &
          &                1.0e-3*losVel%values(1,maf),ier)
a1232 49
  ! ----------------------------  AddForwardModelConfigToDatabase  -----
  integer function AddForwardModelConfigToDatabase ( database, item )

    ! Add a quantity template to a database, or create the database if it
    ! doesn't yet exist

    ! Dummy arguments
    type (ForwardModelConfig_T), dimension(:), pointer :: database
    type (ForwardModelConfig_T), intent(in) :: item

    ! Local variables
    type (ForwardModelConfig_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddForwardModelConfigToDatabase = newSize
  end function AddForwardModelConfigToDatabase

  ! --------------------------  DestroyForwardModelConfigDatabase  -----
  subroutine DestroyFWMConfigDatabase(database)
    ! Dummy arguments
    type (ForwardModelConfig_T), dimension(:), pointer :: DATABASE

    ! Local variables
    integer :: CONFIG                   ! Loop counter
    integer :: SIGNAL                   ! Loop counter
    integer :: STATUS                   ! Flag

    if (associated(database)) then
      do config = 1, size(database)
        do signal = 1, size(database(config)%sigInfo)
          deallocate(database(config)%sigInfo(signal)%channelIncluded,stat=status)
          if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
            & MLSMSG_Deallocate//"database%signals%channelIncluded")
        end do
        deallocate (database(config)%sigInfo, stat=status)
        if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
          & MLSMSG_Deallocate//"database%signals")
        deallocate (database(config)%molecules, stat=status)
        if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
          & MLSMSG_Deallocate//"database%molecules")
      end do

      deallocate (database, stat=status)
      if (status /= 0) call MLSMessage(MLSMSG_Error,ModuleName,&
        & MLSMSG_Deallocate//"database")
    end if
  end subroutine DestroyFWMConfigDatabase

a1233 46
  ! ------------------------------------  DUMP_FOWARDMODELCONFIGS  -----
  subroutine Dump_ForwardModelConfigs ( database )
    type (ForwardModelConfig_T), dimension(:), pointer :: database

    ! Local variables
    integer :: I, J                          ! Loop counters
    character (len=MaxSigLen) :: SignalName  ! A line of text

    ! executable code
    if ( associated(database) ) then
      do i = 1, size(database)
        call output ( 'FowardModelConfig: ' )
        call output ( i, advance = 'yes' )
        call output ( '  Atmos_der:' )
        call output ( database(i)%atmos_der, advance='yes' )
        call output ( '  Do_conv:' )
        call output ( database(i)%do_conv, advance='yes' )
        call output ( '  Do_freq_avg:' )
        call output ( database(i)%do_freq_avg, advance='yes' )
        call output ( '  Spect_der:' )
        call output ( database(i)%spect_der, advance='yes' )
        call output ( '  Temp_der:' )
        call output ( database(i)%temp_der, advance='yes' )
        call output ( '  The_freq:' )
        call output ( database(i)%the_freq, advance='yes' )
        call output ( '  Molecules: ', advance='yes' )
        do j = 1, size(database(i)%molecules)
          call output ( '    ' )
          call display_string(lit_indices(database(i)%molecules(j)))
          if (database(i)%moleculeDerivatives(j)) then
            call output (' compute derivatives', advance='yes')
          else
            call output (' no derivatives', advance='yes')
          end if
        end do
        call output ( '  Signals:', advance='yes')
        do j = 1, size(database(i)%sigInfo)
          call output ( '    ' )
          call GetSignalName( database(i)%sigInfo(j)%signal, signalName)
          call output ( signalName//' channelIncluded:', advance='yes')
          call dump ( database(i)%sigInfo(j)%channelIncluded )
        end do
      end do
    end if
  end subroutine Dump_ForwardModelConfigs

a1264 2
!
!zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d1266 5
a1270 94
! ----------------------------------------  Dump_Lines_Database  -----
  subroutine Dump_Lines_Database ( Start, End, Number )
    use Dump_0, only: Dump
    integer, intent(in), optional :: Start, End
    logical, intent(in), optional :: Number
    integer :: I                   ! Subscript, loop inductor
    integer :: MyStart, MyEnd
    logical :: MyNumber

    myStart = 1
    if ( present(start) ) myStart = start
    myEnd = size(lines)
    if ( present(end) ) myEnd = end
    myNumber = .true.
    if ( present(number) ) myNumber = number
    if ( .not. present(start) .and. .not. present(end) ) then
      call output ('Spectroscopy lines database: SIZE = ' )
      call output ( size(lines), advance='yes' )
    end if
    do i = myStart, myEnd
      if ( myNumber ) then
        call output ( i, 4 )
        call output ( ': ' )
      else
        call blanks ( 6 )
      end if
      if ( lines(i)%line_name /= 0 ) then
        call output ( 'Name = ' )
        call display_string ( lines(i)%line_name )
        call output ( ', ' )
      end if
      call output ( 'V0 = ' )
      call output ( lines(i)%v0 )
      call output ( ', El = ' )
      call output ( lines(i)%el )
      call output ( ', Str =' )
      call output ( lines(i)%str )
      call output ( ', W =' )
      call output ( lines(i)%str, advance='yes' )
      call blanks ( 6 )
      call output ( 'Ps = ' )
      call output ( lines(i)%ps )
      call output ( ', N = ' )
      call output ( lines(i)%n )
      call output ( ': Delta = ' )
      call output ( lines(i)%delta )
      call output ( ', N1 = ' )
      call output ( lines(i)%n1, advance='yes' )
      call blanks ( 6 )
      call output ( 'Gamma = ' )
      call output ( lines(i)%gamma )
      call output ( ', N2 = ' )
      call output ( lines(i)%n2, advance='yes' )
    end do
  end subroutine Dump_Lines_Database
! -------------------------------------  Dump_SpectCat_Database  -----
  subroutine Dump_SpectCat_Database (my_catalog, Lit_Indices )

    use Dump_0, only: Dump

    type(Catalog_T),dimension(:),intent(in) :: My_Catalog
    integer, intent(in), dimension(:) :: Lit_Indices

    integer :: I, J                ! Subscript, loop inductor

    call output ( 'Spectroscopy my_catalog: SIZE = ' )
    call output ( size(my_catalog), advance='yes' )
    do i = 1, size(my_catalog)
      call output ( i, 4 )
      call output ( ': ' )
      if ( my_catalog(i)%species_name /= 0 ) then
        call display_string ( my_catalog(i)%species_name )
        call output ( ', ' )
      end if
      call output ( 'Species = ' )
      call display_string ( lit_indices(my_catalog(i)%molecule) )
      call output ( ', SpecTag = ' )
      call output ( my_catalog(i)%spec_tag )
      call output ( ', Qlog = [ ' )
      do j = 1, 3
        call output ( my_catalog(i)%qlog(j) )
        if ( j < 3 ) call output ( ', ' )
      end do
      call output ( ' ]', advance='yes' )
      call blanks ( 6 + int(log10(i+0.0)) )
      call output ( 'Lines:', advance='yes' )
      do j = 1, size(my_catalog(i)%lines)
        call dump_lines_database ( my_catalog(i)%lines(j), &
       &                           my_catalog(i)%lines(j), .false. )
      end do
    end do ! i
  end subroutine Dump_SpectCat_Database

!zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d1275 3
@


2.66
log
@Move duplicate-field checking to init_tables
@
text
@d48 1
d79 1
a79 1
    & "$Id: ForwardModelInterface.f90,v 2.65 2001/04/05 23:02:31 zvi Exp $"
a555 22
!
!  Create a subset of the catalog composed only of those molecules to be 
!  used for this run
!
    ALLOCATE(My_Catalog(FMI%n_sps),STAT=ier)
    IF(ier /= 0) then
      Print *,'** ALLOCATE Error: My_Catalog, STAT =',ier
      goto 99
    ENDIF
!
    do j = 1, FMI%n_sps
      Spectag = FMI%Pfa_spectrum(j)%SPECTAG
      do i = 1, Size(Catalog)
        if(Catalog(i)%Spec_Tag == Spectag) then
          My_Catalog(j) = Catalog(i)
          EXIT
        endif
      end do
    end do
!      
    print*,'Just some checks:',temp%template%noInstances, &
      & radiance%template%noInstances, ptan%template%noInstances
d579 18
a612 3
    ! Look at the species
    noSpecies = size(forwardModelConfig%molecules)

a662 1
      print*,'MAF ',maf,' phi_tan ',phi_tan
d714 2
a715 2
    do maf = 3, 3
      !do maf = 1, noMAFs
a762 2
!       print*,'Doing frequencies'
!       print*,frequencies
a810 1
!       print*,'  Doing pointing:',ptg_i
d833 1
a833 1
        call get_beta_path(frequencies,Catalog,no_ele,z_path(ptg_i,maf), &
a861 1

d955 1
a1174 5
!   print*,'At the end radiances are:'
!   call dump(radiance%values)
!  *** Zvi DEBUG   
     if(i > -2) Stop
!  *** END Zvi DEBUG   
d1483 3
@


2.65
log
@Implementing Anntena, FilterShape & Spectroscopy l2cf inputs instead of FMI
@
text
@d78 1
a78 1
    & "$Id: ForwardModelInterface.f90,v 2.64 2001/04/05 22:53:20 vsnyder Exp $"
d112 1
a112 2
  integer, parameter :: DuplicateField       = DefineMoleculesFirst + 1
  integer, parameter :: IncompleteFullFwm    = DuplicateField + 1
a226 2
      if ( got(field) .and. (field /= f_channels) ) &
        &  call AnnounceError( DuplicateField, key, field)
a1384 3
    case (DuplicateField)
      call output ( 'duplicate field specified:' )
      call display_string(field_indices(FieldIndex), advance='yes')
d1498 3
@


2.64
log
@Use AntennaPatterns_m
@
text
@d20 1
d22 1
a22 1
    & Open_Filter_Shapes_File, Read_Filter_Shapes_File
d49 1
a49 1
  use Output_M, only: Output
d78 1
a78 1
    & "$Id: ForwardModelInterface.f90,v 2.63 2001/04/01 00:08:52 zvi Exp $"
d371 1
a371 1
    use L2PCdim, only: Nlvl, N2lvl, NSPS, Nptg, NCH, MNP => max_no_phi, &
a389 2
    !zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz

d430 5
a434 14
    !   Real(r4) :: K_TEMP(Nch,Nptg,mxco,mnp)
    !   Real(r4) :: K_ATMOS(Nch,Nptg,mxco,mnp,Nsps)
    !   Real(r4) :: K_SPECT_DW(Nch,Nptg,mxco,mnp,Nsps),  &
    !               K_SPECT_DN(Nch,Nptg,mxco,mnp,Nsps),  &
    !               K_SPECT_DNU(Nch,Nptg,mxco,mnp,Nsps)

    ! ** DEBUG, memory limitations force us to have up to 2 channels
    !           only (Replacing Nch by: 2)

    real(r4) :: K_TEMP(02,Nptg,mxco,mnp)
    real(r4) :: K_ATMOS(02,Nptg,mxco,mnp,Nsps)
    real(r4) :: K_SPECT_DW(02,Nptg,mxco,mnp,Nsps),  &
                K_SPECT_DN(02,Nptg,mxco,mnp,Nsps),  &
                K_SPECT_DNU(02,Nptg,mxco,mnp,Nsps)
d436 1
a436 1
    real(r8) :: I_STAR_ALL(Nch,Nptg)
d438 1
a438 1
    real(r4) :: K_STAR_ALL(02,20,mxco,mnp,Nptg)      ! 02 should be: Nch
d447 1
a447 1
    real(r8) :: Radiances(Nptg,Nch)
d496 1
a496 1
    real(r4), dimension(:), pointer :: TOAVERAGE=>NULL()   ! Stuff to be passed to frq.avg.
d522 2
d558 20
d747 1
a747 1
      Radiances(1:Nptg,1:Nch) = 0.0
d846 3
a848 3
        call get_beta_path(frequencies,&
          & FMI%pfa_spectrum,no_ele, z_path(ptg_i,maf),t_path(ptg_i,maf), &
          & beta_path, 1.0e-3*losVel%values(1,maf),ier)
d928 4
a931 3
            call Freq_Avg(frequencies,centerFreq+sense*FMI%F_grid_filter(:,i),  &
              &     FMI%Filter_func(:,ch),RadV,noFreqs,FMI%no_filt_pts, &
              &     Radiances(ptg_i,ch))
d933 1
d935 1
d937 1
d948 5
a952 5
                  toAverage => k_temp_frq%values( &
                    & 1:noFreqs,surface,instance)
                  call Freq_Avg(frequencies, centerFreq+sense*FMI%F_grid_filter(:,i), &
                    & FMI%Filter_func(:,i), real(toAverage,r8), &
                    & noFreqs,FMI%no_filt_pts,r)
d974 6
a979 4
                    toAverage => k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
                    call Freq_Avg(frequencies,centerFreq+sense*FMI%F_grid_filter(:,i), &
                      & FMI%Filter_func(:,i), real(toAverage, r8), &
                      & noFreqs,FMI%no_filt_pts,r)
d1014 5
a1018 3
!                       call Freq_Avg(frequencies,centerFrequency+sense*FMI%F_grid_filter(:,i), &
!                         &              FMI%Filter_func(:,i),&
!                         &              RadV,noFreqs,FMI%no_filt_pts,r)
d1403 97
d1504 3
@


2.63
log
@*** empty log message ***
@
text
@d14 1
d77 1
a77 1
    & "$Id: ForwardModelInterface.f90,v 2.62 2001/03/31 01:49:45 zvi Exp $"
d1088 2
a1089 1
            &     FMI%Xlamda,FMI%Aaap, FMI%D1Aaap,FMI%D2Aaap,FMI%Ias,ier)
d1387 3
@


2.62
log
@*** empty log message ***
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.61 2001/03/30 20:55:25 zvi Exp $"
d107 2
a108 2
  integer, parameter :: BadMolecule          = AllocateError + 1  
  integer, parameter :: DefineSignalsFirst   = BadMolecule + 1  
d329 1
a329 1
      
d442 2
a443 2
      K_SPECT_DN(02,Nptg,mxco,mnp,Nsps),  &
      K_SPECT_DNU(02,Nptg,mxco,mnp,Nsps)
d521 1
a521 1
    
d523 1
a523 1
    type(path_vector), allocatable, dimension(:,:,:) :: SPSFUNC_PATH 
d533 1
a533 1
    ! First we identify the vector quantities we're going to need.  
d567 1
a567 1
    ! We won't seek for molecules here as we can't have an array of pointers. 
d657 1
a657 1
      phi_tan = degToRad*temp%template%phi(1,maf) 
d705 1
a705 1
    ! The first part of the forward model dealt with the chunks as a whole. 
d717 1
a717 1
      ! Compute the ptg_angles (chi) for Antenna convolution, also the 
d779 1
a779 1
 
d785 1
a785 1
        
d829 1
a829 1
          frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies 
d900 1
a900 1
        if ( forwardModelConfig%do_freq_avg ) then 
d951 1
a951 1
            
d1025 1
a1025 1
        ch = usedChannels(i)        
d1086 1
a1086 1
            &     TFMI%no_phi_f, FMI%spectroscopic,temp%template%surfs(:,1), &  
d1168 3
d1358 1
a1358 1
    case (AllocateError) 
d1360 1
a1360 1
    case (BadMolecule) 
d1362 1
a1362 1
    case (DefineMoleculesFirst) 
d1364 1
a1364 1
    case (DefineSignalsFirst) 
d1366 1
a1366 1
    case (DuplicateField) 
d1385 3
@


2.61
log
@Remove the need for COMMON BLOCK..(ELLIPSE)
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.60 2001/03/30 03:05:49 vsnyder Exp $"
d612 1
a612 1
    allocate (ndx_path(Nptg,radiance%template%noInstances), STAT=status)
d615 1
a615 1
    allocate (dhdz_path(Nptg,radiance%template%noInstances), STAT=status)
d618 1
a618 1
    allocate (h_path(Nptg,radiance%template%noInstances), STAT=status)
d621 1
a621 1
    allocate (n_path(Nptg,radiance%template%noInstances), STAT=status)
d624 1
a624 1
    allocate (phi_path(Nptg,radiance%template%noInstances), STAT=status)
d627 1
a627 1
    allocate (t_path(Nptg,radiance%template%noInstances), STAT=status)
d630 1
a630 1
    allocate (z_path(Nptg,radiance%template%noInstances), STAT=status)
d634 1
a634 1
    allocate (spsfunc_path(noSpecies,Nptg,radiance%template%noInstances), STAT=status)
d637 1
a637 1
    allocate (eta_phi(Nptg,radiance%template%noInstances), STAT=status)
d654 1
a654 1
    if (temp%template%noInstances /= radiance%template%noInstances) &
d656 1
a656 1
    do maf = 1, radiance%template%noInstances
d671 1
a671 2
      &  radiance%template%noInstances, &
      &  geoc_lat,refGPH%values(1,:)/1e3, &
d1382 3
@


2.60
log
@Add 'antennaPatterns' field to 'forwardModelGlobal'
@
text
@d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.59 2001/03/30 02:45:23 livesey Exp $"
d371 1
a371 1
    use ELLIPSE, only: PHI_TAN, ROC
d457 1
a457 1
    real(r8) :: Zeta, Frq, h_tan, Rad, geod_lat, r
d522 3
a524 1
    type(path_vector), allocatable, dimension(:,:,:) :: SPSFUNC_PATH ! (Nsps,Nptg,mnm)
d527 2
d533 2
a534 2
    ! First we identify the vector quantities we're going to need.  The key is to
    ! identify the signal we'll be working with first
d641 4
d657 2
a658 1
      phi_tan = degToRad*temp%template%phi(1,maf) ! ??? For the moment, change this soon.
d661 2
a662 2
      call geoc_geod_conv(orbIncline%values(1,1),phi_tan,geod_lat, &
        & geoc_lat(maf),E_rad(maf))
a664 7
    maf = 3                             ! Zvi will sort this out later!!!!
    phi_tan = degToRad*temp%template%phi(1,maf)
    geod_lat= degToRad*temp%template%geodLat(1,maf)
    call geoc_geod_conv(orbIncline%values(1,1),phi_tan,geod_lat, &
      & geoc_lat(maf),E_rad(maf))
    ! End of Zvi'ism

d700 4
a703 5
      &  gl_count,ndx_path, &
      &     z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid,                    &
      &     tan_hts,no_tan_hts, z_path,h_path,t_path,       &
      &     phi_path,n_path,dhdz_path,eta_phi,temp%template%noInstances,        &
      &     temp%template%phi(1,:)*degToRad,spsfunc_path,noMAFs,Ier)
d718 2
a719 2
      ! Compute the ptg_angles (chi) for Antenna convolution, also the derivatives
      ! of chi w.r.t to T and other parameters
d722 2
a723 1
        &     tan_hts(:,maf),tan_temp(:,maf),phi_tan,RoC,1e-3*scGeocAlt%values(1,1),  &
d761 2
a762 2
        print*,'Doing frequencies'
        print*,frequencies
d811 1
a811 1
        print*,'  Doing pointing:',ptg_i
d836 1
a836 2
          & beta_path, 1e-3*losVel%values(1,maf),ier) !??? Note only using MIF 1 for losvel

d866 2
a867 1
          call Rad_Tran(Frq, forwardModelConfig%integrationGrid%noSurfs, &
d878 1
a878 1
          !         CALL Rad_Tran_WD(frq_i,FMI%band,Frq, &
d1140 1
d1142 1
d1236 3
d1383 3
@


2.59
log
@Numbers agree again, was velocity.
@
text
@d14 2
d20 1
a20 1
    & Open_Filter_Shapes_File, Read_Filter_Shapes_File, FilterShapes
d27 4
a30 4
  use Init_Tables_Module, only: F_ATMOS_DER, F_CHANNELS, F_DO_CONV, &
    & F_DO_FREQ_AVG, F_FILTERSHAPES, F_FREQUENCY, F_INTEGRATIONGRID, &
    & F_MOLECULES, F_MOLECULEDERIVATIVES, F_PHIWINDOW, F_POINTINGGRIDS, &
    & F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, F_TYPE
d76 1
a76 1
    & "$Id: ForwardModelInterface.f90,v 2.58 2001/03/30 01:45:08 livesey Exp $"
d145 5
d1376 3
@


2.58
log
@Some changes and debug stuff, still no agreement.
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.57 2001/03/30 00:36:57 livesey Exp $"
a658 2
    si = ForwardModelConfig%SurfaceTangentIndex

d708 1
a708 1
      phi_tan = radiance%template%phi(1,maf) !??? Choose better value later
d717 1
a717 1
        &     si,    &
a824 1
        print*,'Using velocity:',1e-3*losVel%values(1,maf)
d828 1
d1027 1
a1027 1
              & quantityType=l_vmr, molecule=forwardModelConfig%molecules(specie))
d1369 3
@


2.57
log
@Interim version, doesn't quite get the same numbers as Zvi, but we
think we know why.
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.56 2001/03/30 00:07:36 livesey Exp $"
d638 3
d642 1
a642 1
      phi_tan = degToRad*radiance%template%phi(1,maf) ! ??? For the moment, change this soon.
d644 1
a644 1
      geod_lat= degToRad*radiance%template%geodLat(1,maf)
d650 2
a651 2
    phi_tan = degToRad*temp%template%phi(1,3)
    geod_lat= degToRad*radiance%template%geodLat(1,maf)
d695 1
a695 2
      &     tan_hts,no_tan_hts,FMI%n_sps,             &
      &     z_path,h_path,t_path,       &
d714 2
a715 1
      call get_chi_angles(ndx_path(:,maf),n_path(:,maf),FMI%tan_press,        &
d754 2
d776 1
a776 1
      do specie = 1, size(forwardModelConfig%molecules)
d861 1
a861 1
            &    h_tan, FMI%n_sps, ndx_path(k,maf),  &
d941 1
a941 1
        do specie = 1, FMI%n_sps
d1027 1
a1027 1
          do m = 1, FMI%n_sps
d1039 1
a1039 1
          do m = 1, FMI%n_sps
d1067 4
a1070 2
          call convolve_all(ptan%values(:,maf),TFMI%atmospheric,FMI%n_sps,   &
            &     ForwardModelConfig%temp_der,ForwardModelConfig%atmos_der,ForwardModelConfig%spect_der,                   &
d1087 1
a1087 1
          call no_conv_at_all(ptan%values(:,maf),FMI%n_sps, &
d1089 2
a1090 1
            &     FMI%band,ForwardModelConfig%temp_der,ForwardModelConfig%atmos_der,ForwardModelConfig%spect_der,      &
d1115 1
a1115 1
    do j = 1, FMI%n_sps
d1371 4
@


2.56
log
@Removed more FMC/TFMI stuff
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.55 2001/03/29 23:56:49 livesey Exp $"
d640 1
d705 2
a706 1
    !do maf = 1, noMAFs
d799 1
a799 1

d822 1
d825 1
a825 1
          & beta_path, losVel%values(1,maf),ier) !??? Note only using MIF 1 for losvel
d1363 3
@


2.55
log
@Added phi Window
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.54 2001/03/29 23:42:55 vsnyder Exp $"
d355 1
a355 1
    &                       Jacobian, RowBlock, FwdModelOut, FMI, TFMI )
d694 1
a694 1
      &     temp%template%phi(1,:)*degToRad,spsfunc_path,TFMI%is_f_log,noMAFs,Ier)
d941 2
a942 2
                do instance = 1, TFMI%no_phi_f(j)
                  do surface = 1, TFMI%no_coeffs_f(j)
d1020 3
d1024 2
a1025 2
              k = TFMI%no_phi_f(m)
              n = TFMI%no_coeffs_f(m)
d1360 3
@


2.54
log
@Add 'filterShapes' field to forwardModelGlobal
@
text
@d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.53 2001/03/29 22:07:16 livesey Exp $"
d355 1
a355 1
    &                       Jacobian, RowBlock, FwdModelOut, FMC, FMI, TFMI )
a392 1
    type(fwd_mdl_config), optional :: FMC
d450 1
a450 1
    real(r8) :: e_rad, Zeta, Frq, h_tan, Rad, geoc_lat, geod_lat, r
d482 1
d496 2
d582 3
d635 2
d638 6
a643 2
    ! This stuff fills FMC, which is a temporary structure we hope to be
    ! removing in the end.
d645 6
a650 15
    fmc%atmos_der = forwardModelConfig%atmos_der
    fmc%do_conv = forwardModelConfig%do_conv
    fmc%do_frqavg = forwardModelConfig%do_Freq_Avg
    fmc%spect_Der = forwardModelConfig%spect_Der
    fmc%temp_Der = forwardModelConfig%temp_Der
    fmc%zfrq = forwardModelConfig%the_Freq

    ! THIS WHOLE SECTION NEEDS TO BE REMOVED AND SORTED OUT
    ! Convert GeoDetic Latitude to GeoCentric Latitude, and convert both to
    ! Radians (instead of Degrees). Also compute the effective earth radius.
    maf = 3                     ! Do only this maf (middle phi)
    phi_tan = degToRad*temp%template%phi(1,maf) ! ??? For the moment, change this soon.
    geod_lat= TFMI%t_geod_lat(maf)
    call geoc_geod_conv(orbIncline%values(1,1),phi_tan,geod_lat, geoc_lat,E_rad)
    ! ZVI WILL LOOK AT THIS
d684 1
a684 1
    
d688 1
a688 1
      &  FMC%n_lvls,temp%template%noSurfs,&
d691 2
a692 3
      &     TFMI%atmospheric,TFMI%f_zeta_basis,TFMI%mr_f,              &
      &     TFMI%no_coeffs_f,tan_hts,no_tan_hts,FMI%n_sps,             &
      &     TFMI%no_phi_f,TFMI%f_phi_basis,z_path,h_path,t_path,       &
d694 1
a694 1
      &     temp%template%phi(1,:)*degToRad,spsfunc_path,TFMI%is_f_log,FMC%no_mmaf,Ier)
d704 1
a704 1
    !do maf = 1, radiance%template%noInstances
d706 1
a706 1
      phi_tan = fmc%phi_tan_mmaf(maf) !??? Get this from state vector lter
d720 1
a720 1
        &                n_path(:,maf), ndx_path(:,maf), E_rad, ref_corr)
d807 1
a807 1
        if (FMC%do_frqavg) then
d822 1
a822 1
          & beta_path, FMC%vel_z_mmaf(maf),ier)
d852 2
a853 1
          call Rad_Tran(Frq, FMC%N_lvls, h_tan, FMI%n_sps, ndx_path(k,maf),  &
d863 4
a866 2
          !         CALL Rad_Tran_WD(frq_i,FMI%band,Frq,FMC%N_lvls,FMI%n_sps, &
          !        &     FMC%temp_der,fmc%atmos_der,FMC%spect_der,            &
d957 1
a957 1
!        if(FMC%spect_der) then
d980 1
a980 1
!                     if(FMC%do_frqavg) then
d1013 1
a1013 1
        if(FMC%temp_der) then
d1018 1
a1018 1
        if(FMC%atmos_der) then
d1027 1
a1027 1
        if(FMC%spect_der) then
d1051 1
a1051 1
        if(FMC%do_conv) then
d1057 1
a1057 1
            &     FMC%temp_der,FMC%atmos_der,FMC%spect_der,                   &
d1076 1
a1076 1
            &     FMI%band,FMC%temp_der,FMC%atmos_der,FMC%spect_der,      &
d1100 1
a1100 1
    if(FMC%temp_der) deallocate(k_temp_frq%values,STAT=i)
d1102 2
a1103 2
      if(FMC%atmos_der) deallocate(k_atmos_frq(j)%values,STAT=i)
      if(FMC%spect_der) then
d1112 1
a1112 1
    if(FMC%do_conv) then
d1118 2
a1119 2
    if(FMC%Zfrq > 0.0) then
      Frq = FMC%Zfrq
d1147 2
a1148 1
    if(.not. any((/FMC%temp_der,FMC%atmos_der,FMC%spect_der/))) goto 99
d1216 2
d1357 3
@


2.53
log
@Added phiWindow
@
text
@d17 3
a19 1
  ! We're going to use lots of things from init_tables_module, so lets sort
d25 4
a28 3
  use Init_Tables_Module, only: F_ATMOS_DER, F_CHANNELS, F_DO_CONV, F_DO_FREQ_AVG, &
    F_FREQUENCY, F_INTEGRATIONGRID, F_MOLECULES, F_MOLECULEDERIVATIVES, &
    F_PHIWINDOW, F_POINTINGGRIDS, F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, F_TYPE
d43 1
a43 1
  use MLSSignals_m, only: GetSignal, Signal_T, GetSignalName
a46 1
    & Dump_Pointing_Grid_Database, &
d74 1
a74 1
    & "$Id: ForwardModelInterface.f90,v 2.52 2001/03/29 12:11:16 zvi Exp $"
d124 1
a124 1
    ! Indexes a "spec_args" vertex.
d126 3
a128 2
    integer :: Lun                      ! Unit number for pointing grid file
    character(len=80) :: PointingGridsFile   ! Duh
d140 17
a156 9
    ! The only field so far is the PointingGrids field, and it is required.
    son = subtree(2,root)
    call get_string ( sub_rosa(subtree(2,son)), pointingGridsFile, strip=.true. )

    ! The ExtraHeights and PointingGrids fields are required, so we don't
    ! need to verify that they were provided.
    call open_pointing_grid_file ( pointingGridsFile, lun )
    call read_pointing_grid_file ( lun, spec_indices )
    call close_pointing_grid_file ( lun )
d168 2
a170 3
    ! Indexes either a "named" or
    ! "spec_args" vertex.
    ! Local variables
d219 1
a219 1
      if ( got(field) .and. (field /= f_channels) )&
d381 1
d1271 2
a1272 2
    integer :: I,J                      ! Loop counters
    character (len=80) :: signalName    ! A line of text
d1350 3
@


2.52
log
@Fixing Bug seeting surface index erroniously
@
text
@d25 1
a25 1
    F_POINTINGGRIDS, F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, F_TYPE
d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.51 2001/03/29 02:37:30 livesey Exp $"
d97 1
d110 2
a111 1
  integer, parameter :: TangentNotSubset = IrrelevantFwmParameter + 1
d285 4
d540 3
d1331 2
d1339 3
@


2.51
log
@Modified convolution to use new grids
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.50 2001/03/29 01:21:25 zvi Exp $"
d632 2
a633 1
    si = FMI%Surface_index
d1043 2
a1044 3
            &     TFMI%no_phi_f,   &
            &     FMI%spectroscopic,temp%template%surfs(:,1),FMI%Xlamda,FMI%Aaap,&
            &     FMI%D1Aaap,FMI%D2Aaap,FMI%Ias,ier)
d1120 2
a1121 2
    print*,'At the end radiances are:'
    call dump(radiance%values)
d1328 3
@


2.50
log
@Interim version
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.49 2001/03/29 00:53:54 livesey Exp $"
d1033 2
a1034 1
            &     FMI%tan_press,ptg_angles(:,maf),tan_temp(:,maf), &
d1038 2
a1039 1
            &     k_spect_dnu((1),:,:,:,:),FMI%spect_atmos,no_tan_hts,  &
d1050 2
a1051 1
          call no_conv_at_all(ptan%values(:,maf),FMI%n_sps,FMI%tan_press, &
d1056 2
a1057 1
            &     FMI%spect_atmos, no_tan_hts,k_info_count,               &
d1328 3
@


2.49
log
@Modified error message.
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.48 2001/03/29 00:33:21 livesey Exp $"
a348 1
    use L2_LOAD_M, only: L2_LOAD
a632 1
    no_tan_hts = FMC%no_tan_hts
d637 4
a640 4
      &  FMC%N_lvls,temp%template%noSurfs, &
      &  radiance%template%noInstances,FMC%t_indx, &
      &  no_tan_hts,geoc_lat,refGPH%values(1,:)/1e3, &
      &  refGPH%template%surfs(1,1),FMI%z_grid, &
d642 3
a644 1
      &  dhdz_glgrid,dh_dt_glgrid,FMI%tan_press,tan_hts,tan_temp,tan_dh_dt, &
d655 2
a656 1
    call allocate_test ( grids, no_tan_hts, "Grids", moduleName )
d658 3
a660 1
      & FMI%tan_press(1:no_tan_hts), grids, allowTopValue=.true.)
a661 3
!    call get_grids_near_tan_pressures ( whichPointingGrid, FMI%tan_press(1:no_tan_hts), &
!      & tol, grids)

d1324 3
@


2.48
log
@Added some error checking for tangentGrid
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.47 2001/03/28 23:51:15 zvi Exp $"
d109 1
d312 1
a312 2
          & call MLSMessage(MLSMSG_Error, ModuleName, &
          & "tagnent grid is not a subset of integration grid")
d1316 2
d1324 3
@


2.47
log
@Tanget below surface are in Zeta units
@
text
@d54 1
a54 1
  use VGrid, only: VGRID_T
d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.46 2001/03/28 22:41:10 livesey Exp $"
d173 1
d301 13
a313 2
      ! Ensure that points in tangentGrid above surface are a subset
      ! of integration grid !????
d1322 3
@


2.46
log
@Got rid of a print statement that was annoying zvi
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.45 2001/03/28 22:00:10 livesey Exp $"
d96 1
d626 8
a633 7
    call hydrostatic_model(si,FMC%N_lvls,temp%template%noSurfs, &
      & radiance%template%noInstances,FMC%t_indx, &
      & no_tan_hts,geoc_lat,refGPH%values(1,:)/1e3, &
      & refGPH%template%surfs(1,1),FMI%z_grid,FMI%Tan_hts_below_surface(1:si-1), &
      & temp%template%surfs(:,1), temp%values, z_glgrid, h_glgrid, t_glgrid, &
      dhdz_glgrid,dh_dt_glgrid,FMI%tan_press,tan_hts,tan_temp,tan_dh_dt, &
      gl_count, Ier)
d1310 3
@


2.45
log
@Interim version, now uses more allocatables etc.
@
text
@d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.44 2001/03/28 21:22:22 vsnyder Exp $"
a1077 3
      write(*,901) Frq
901   format(' Frequency Averaging: OFF',/,  &
        &    ' (All computations done at Frq =',f12.4,')')
d1308 3
@


2.44
log
@Use Deg2Rad from Units
@
text
@d24 2
a25 2
    F_FREQUENCY, F_MOLECULES, F_MOLECULEDERIVATIVES, F_POINTINGGRIDS, F_SIGNALS, &
    F_SPECT_DER, F_TEMP_DER, F_TYPE
d54 1
d72 1
a72 1
    & "$Id: ForwardModelInterface.f90,v 2.43 2001/03/28 01:31:39 livesey Exp $"
d94 2
d147 2
a148 1
  type (ForwardModelConfig_T) function ConstructForwardModelConfig ( ROOT ) result(info)
d152 2
a153 1
    integer :: ROOT                     ! of the forwardModel specification.
d284 4
d299 3
a327 2
    !zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz

d353 2
a354 1
    !zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d371 1
a371 1
    !zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d373 1
a373 2
    ! Local parameters
    character, parameter :: InvalidQuantity="Invalid vector quantity for "
d375 1
a375 13
    ! This is the `legit stuff' we hope will stay they are all pointers to
    ! VectorValue_T's containing vector quantities
    type (VectorValue_T), pointer :: radiance=>NULL() ! Radiance quantity to be filled
    type (VectorValue_T), pointer :: temp=>NULL() ! Temperature quantity
    type (VectorValue_T), pointer :: ptan=>NULL() ! PTAN quantity
    type (VectorValue_T), pointer :: elevOffset=>NULL() ! Elevation offset quantity
    type (VectorValue_T), pointer :: orbIncline=>NULL() ! Orbital inclination (beta)
    type (VectorValue_T), pointer :: spaceRadiance=>NULL() ! Space radiance
    type (VectorValue_T), pointer :: earthRefl=>NULL() ! Earth reflectivity
    type (VectorValue_T), pointer :: refGPH=>NULL() ! Reference GPH, (zRef and hRef)
    type (VectorValue_T), pointer :: losVel=>NULL() ! Line of sight velocity
    type (VectorValue_T), pointer :: scGeocAlt=>NULL() ! Geocentric spacecraft altitude
    type (VectorValue_T), pointer :: f=>NULL() ! An arbitrary species
d377 2
a378 1
    integer(i4), parameter :: ngt = (Ng+1) * N2lvl
a384 30

    integer :: WhichPointingGrid        ! Index of poiting grid
    integer :: MIF                      ! Loop counter
    integer :: CHANNEL                  ! Loop counter
    integer :: MAXNOFREQS               ! Used for sizing arrays
    integer :: NOUSEDCHANNELS           ! Number of channels to output
    integer :: NOFREQS                  ! Number of frequencies for a pointing
    integer :: NAMELEN                  ! Length of string
    integer :: SPECIE                   ! Loop counter
    integer :: SURFACE                  ! Loop counter
    integer :: INSTANCE                 ! Loop counter

    real (r8) :: CENTERFREQ             ! Of band
    real (r8) :: SENSE                  ! Multiplier (+/-1)

    integer, dimension(:), pointer :: CHANNELINDEX=>NULL() ! E.g. 1..25
    integer, dimension(:), pointer :: USEDCHANNELS=>NULL() ! Array of indices used

    real(r4), dimension(:), pointer :: TOAVERAGE ! Stuff to be passed to frq.avg.

    type(path_index)  :: ndx_path(Nptg,mnm)
    type(path_vector) :: z_path(Nptg,mnm),t_path(Nptg,mnm),h_path(Nptg,mnm),  &
      dhdz_path(Nptg,mnm), spsfunc_path(Nsps,Nptg,mnm),    &
      n_path(Nptg,mnm),phi_path(Nptg,mnm)

    Type(path_vector_2d) :: eta_phi(Nptg,mnm)

    Real(r8), DIMENSION(:,:,:), ALLOCATABLE :: dh_dt_path

    real(r8) :: thbs(10)
a387 2
    real(r8) :: dx_dt(Nptg,mxco), d2x_dxdt(Nptg,mxco)

d418 1
a418 1
!
d425 1
a425 1
!
a432 1
    real(r8), dimension(:), pointer :: frequencies=>NULL()
d434 53
a486 4
    real(r8), parameter :: TOL = 0.001            ! How close to a tan_press
    !                                               must a frq grid be in order
    !                                               to correspond?
    integer, pointer, dimension(:) :: Grids=>NULL()       ! Frq grid for each tan_press
d489 1
a489 3
    !zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz

    print*,'Entering forwardModel'
d545 3
d558 40
a597 1
    signal = getSignal ( forwardModelConfig%sigInfo(1)%signal )
a608 1

a619 1
    thbs = 0.0
a621 1
    thbs(1:si-1) = FMI%Tan_hts_below_surface(1:si-1)
a624 1
    print*,'Setting up hydrostatic grid'
d628 1
a628 1
      & refGPH%template%surfs(1,1),FMI%z_grid,thbs, &
a648 1
    print*,'Setting up paths'
a668 1
      print*,'Major frame: ',maf
a673 1
      print*,'scGeocAlt is:',scGeocAlt%values(1,1)
d827 1
a827 1
          !        &     FMC%temp_der,FMC%atmos_der,FMC%spect_der,            &
a1012 1
          print*,'Doing convolution'
a1030 1
          print*,'Not doing convolution'
d1146 30
a1177 1
    !zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d1311 3
@


2.43
log
@Got rid of a dump statement
@
text
@d51 1
d71 1
a71 1
    & "$Id: ForwardModelInterface.f90,v 2.42 2001/03/28 01:31:16 livesey Exp $"
a107 2
  real (r8), parameter :: DegToRad=1.745329252e-2

d1236 3
@


2.42
log
@Got convolution working.
@
text
@d70 1
a70 1
    & "$Id: ForwardModelInterface.f90,v 2.41 2001/03/28 00:39:15 zvi Exp $"
a633 2
      print*,'After get_chi_angles ptg_angles is:'
      call dump(ptg_angles(:,maf))
d1237 3
@


2.41
log
@Fixing up the convolution call
@
text
@d70 1
a70 1
    & "$Id: ForwardModelInterface.f90,v 2.40 2001/03/27 00:21:18 livesey Exp $"
a476 2
    call Dump_Pointing_grid_database

a597 9
    call output('Tangent pressures:',advance='yes')
    call dump(FMI%tan_press(1:no_tan_hts))
    call output('Pointing grid zetas:',advance='yes')
    call dump(PointingGrids(whichPointingGrid)%oneGrid%height)
    call output('Grids near zetas:',advance='yes')
    call dump(grids)
    call output('Pressures of said grids:',advance='yes')
    call dump(PointingGrids(whichPointingGrid)%oneGrid(grids)%height)

d626 1
d628 1
a628 1
        &     tan_hts(:,maf),tan_temp(:,maf),phi_tan,RoC,scGeocAlt%values(1,1),  &
d634 2
a667 2
        print*,'Using frequencies:'
        call dump(frequencies)
a715 1
        print*,'  Pointing:',ptg_i,' of ',no_tan_hts, FMI%tan_press(ptg_i)
a736 2
          print*,'     Using:'
          call dump(frequencies)
a766 1
        print*,'    Loop over frequencies will be:', noFreqs
a816 4
            if ( ch == 1 ) then
              call output ('Frequency terms for channel 1',advance='yes')
              call dump(centerFreq+sense*FMI%F_grid_filter(:,i))
            endif
d968 1
d987 1
a987 1
          
d1239 3
@


2.40
log
@Got frequency averaging working.
@
text
@d70 1
a70 1
    & "$Id: ForwardModelInterface.f90,v 2.39 2001/03/26 21:13:02 livesey Exp $"
d993 1
a993 1
            &     dx_dt, d2x_dxdt,FMI%band,center_angle,FMI%fft_pts,          &
d1256 3
@


2.39
log
@Stableish version, frequency averaging still highly suspect.
@
text
@d37 3
a39 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate, MLSMSG_Error
d44 1
a44 1
    & Dump_Pointing_Grid_Database, Get_Grids_Near_Tan_Pressures, &
d70 1
a70 1
    & "$Id: ForwardModelInterface.f90,v 2.38 2001/03/26 18:01:20 zvi Exp $"
a327 1
    use PTG_FRQ_LOAD_M, only: PTG_FRQ_LOAD
d342 1
a342 1
    use D_HUNT_M, only: HUNT
d477 2
a545 7
    whichPointingGrid = signal%pointingGrid
    if ( whichPointingGrid <= 0 ) &
      call MLSMessage ( MLSMSG_Error, moduleName, &
      & "There is no pointing grid for the desired signal" )
    call allocate_test ( grids, size(FMI%tan_press), "Grids", moduleName )
    call get_grids_near_tan_pressures ( whichPointingGrid, FMI%tan_press, &
      & tol, grids )
d586 23
a662 1
        print*,'Interim frequencies:',frequencies
d676 2
a677 3
        print*,'Center frequency:', signal%centerFrequency
        print*,'LO:', signal%lo
        print*,'Using frequency: ',frequencies
d738 5
a742 5
          call Allocate_Test(frequencies, &
            & size(PointingGrids(whichPointingGrid)%&
            &      oneGrid(grids(ptg_i))%frequencies),&
            &      'frequencies', ModuleName)
          ! Note that this deallocates the ones from the previous go round
d746 1
a746 1
          frequencies =>PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies 
d831 4
a834 1
            if ( ch == 1 ) print*,(centerFreq+sense*FMI%F_grid_filter(:,i))
d1067 1
a1067 1
    call Hunt(Zeta,tau,ptan%template%noSurfs,klo,j)
d1110 1
a1110 1
        call Hunt(Zeta,tau,mnz,m,j)
d1256 3
@


2.38
log
@New code to deal with dh_dt_path being computed on the fly
@
text
@d68 1
a68 1
    & "$Id: ForwardModelInterface.f90,v 2.37 2001/03/25 00:50:31 livesey Exp $"
d808 2
d814 1
d1236 3
@


2.37
log
@Interim version, bug with frequency averaging
@
text
@d68 1
a68 1
    & "$Id: ForwardModelInterface.f90,v 2.36 2001/03/24 00:33:38 livesey Exp $"
d105 1
a105 1
  real (r8), parameter :: DegToRad=1.74532925e-2
d330 1
a330 1
      PATH_DERIVATIVE
d340 1
d411 3
a413 1
    type(path_derivative) :: dh_dt_path(Nptg,mnm)
d417 1
a417 1
      tan_dh_dt(Nlvl,mnm,mxco)
d456 2
d592 5
a596 4
    call comp_path_entities(fwdModelIn, fwdModelExtra, forwardModelConfig%molecules, &
      & FMC%n_lvls,temp%template%noSurfs,&
      & gl_count,ndx_path, &
      &     z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid,dh_dt_glgrid,       &
d600 1
a600 1
      &     phi_path,n_path,dhdz_path,dh_dt_path,temp%template%noInstances,        &
d678 1
a678 1

d739 22
d787 1
a787 1
          !        &     dh_dt_path(k,maf),FMI%spect_atmos,         &
d1233 3
@


2.36
log
@Bug fix (Typo)
@
text
@d68 1
a68 1
    & "$Id: ForwardModelInterface.f90,v 2.35 2001/03/24 00:32:56 livesey Exp $"
d604 2
a605 2
    !do maf = 3, 3
    do maf = 1, radiance%template%noInstances
d638 1
d652 3
d703 1
a703 1
        print*,'  Pointing:',ptg_i,' of ',no_tan_hts
d715 9
a723 2
          frequencies => PointingGrids(whichPointingGrid)%oneGrid(&
            & grids(ptg_i))%frequencies
d725 2
d735 1
d1008 2
a1009 1
    if (.not. FMC%do_frqavg) deallocate(frequencies)
d1205 3
@


2.35
log
@Modified use of FMI%f_grid_filter
@
text
@d68 1
a68 1
    & "$Id: ForwardModelInterface.f90,v 2.34 2001/03/23 23:55:54 livesey Exp $"
d788 1
a788 1
                  call Freq_Avg(frequencies, centerFrequency+sense*FMI%F_grid_filter(:,i), &
d813 1
a813 1
                    call Freq_Avg(frequencies,centerFrequency+sense*FMI%F_grid_filter(:,i), &
d1190 3
@


2.34
log
@Another interim version.  Frequency averaging doesn't crash but
produces bad numbers. Note that the handling of k_... when passed to
the convolution (or noconvolution) routine is highly nefarious.
@
text
@d68 1
a68 1
    & "$Id: ForwardModelInterface.f90,v 2.33 2001/03/23 19:00:14 livesey Exp $"
d397 3
d756 12
a767 1
        if ( forwardModelConfig%do_freq_avg ) then
d770 1
a770 1
            call Freq_Avg(frequencies,FMI%F_grid_filter(:,i),  &
d788 1
a788 1
                  call Freq_Avg(frequencies, FMI%F_grid_filter(:,i), &
d813 1
a813 1
                    call Freq_Avg(frequencies,FMI%F_grid_filter(:,i), &
d850 1
a850 1
!                       call Freq_Avg(frequencies,FMI%F_grid_filter(:,i), &
d1190 5
@


2.33
log
@Interim version, tidied some stuff up, still gets same numbers as Zvi
@
text
@d68 1
a68 1
    & "$Id: ForwardModelInterface.f90,v 2.32 2001/03/22 01:01:12 livesey Exp $"
d601 2
a602 1
    do maf = 3, 3
a603 1
      ! do maf = 1, radiance%template%noInstances (HOPEFULLY THE FINAL FORM!)
a646 1
        print*,'Using:',frequencies
d655 1
a655 1
          & %OneGrid(grids(1))%Frequencies) )
a719 1
          print*,'    Frequency:',frq_i,' of ',noFreqs
a750 1

d908 3
d915 4
a918 4
            &     Radiances(:,ch),k_temp(i,:,:,:),k_atmos(i,:,:,:,:), &
            &     k_spect_dw(i,:,:,:,:),k_spect_dn(i,:,:,:,:),    &
            &     k_spect_dnu(i,:,:,:,:),FMI%spect_atmos,no_tan_hts,  &
            &     k_info_count,i_star_all(i,:),k_star_all(i,:,:,:,:), &
d926 3
d931 3
a933 3
            &     Radiances(:,ch),k_temp(i,:,:,:),                    &
            &     k_atmos(i,:,:,:,:),k_spect_dw(i,:,:,:,:),       &
            &     k_spect_dn(i,:,:,:,:),k_spect_dnu(i,:,:,:,:),   &
d935 1
a935 1
            &     i_star_all(i,:), k_star_all(i,:,:,:,:),            &
d1176 3
@


2.32
log
@Interim version, no rights radiances out to a vector.
@
text
@d6 1
a6 1
!=============================================================================
d8 2
a9 2
! Set up the forward model.  Interface from the retrieve step to the
! forward model.
d11 1
a11 1
!??? Do we want a forward model database ???
d29 2
a30 1
    & L_REFGPH, L_SCAN, L_SCGEOCALT, L_SPACERADIANCE, L_TEMPERATURE, L_UPPER
d56 1
a56 1
  implicit NONE
d68 1
a68 1
    & "$Id: ForwardModelInterface.f90,v 2.31 2001/03/21 02:14:01 livesey Exp $"
d111 1
a111 1
  ! Process the forwardModel specification to produce ForwardModelInfo.
d114 1
a114 1
                                        ! Indexes a "spec_args" vertex.
d148 2
a149 2
                                        ! Indexes either a "named" or
                                        ! "spec_args" vertex.
d160 1
a160 1
                                        ! if any, else zero.
d165 1
a165 1
    integer :: Type                     ! Type of value returned by EXPR
d180 1
a180 1
    
d190 1
a190 1
    
d310 2
a311 2
! subroutine ForwardModel ( ForwardModelConfig, FwdModelExtra, FwdModelIn, &
!   &                       Jacobian, RowBlock, FwdModelOut )
d315 1
a315 1
!zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d323 1
a323 1
                       MNM => max_no_mmaf
d330 1
a330 1
                               PATH_DERIVATIVE
d336 1
a336 1
  ! use RAD_TRAN_WD_M, only: RAD_TRAN_WD
d342 1
a342 1
!zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d351 1
a351 1
!??? Begin temporary stuff to start up the forward model
d353 1
a353 1
!   type(fwd_mdl_info), dimension(:), pointer, optional :: FMI
d355 1
a355 1
!   type(temporary_fwd_mdl_info), dimension(:), pointer, optional :: TFMI
d357 1
a357 1
!??? End of temporary stuff to start up the forward model
d359 1
a359 1
!zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d376 1
d378 1
a378 6
    Integer(i4), parameter :: ngt = (Ng+1) * N2lvl

    Integer(i4) :: i, j, k, kk, kz, ht_i, mnz, no_tan_hts, ch, Spectag, &
                   m, prev_npf, ier, mmaf, si, ptg_i, &
                   frq_i, io, klo, l, n, brkpt, no_ele, mid, ilo, ihi, &
                   k_info_count, gl_count, ld
d380 4
a383 1
    Integer(i4) :: ch1, ch2
a384 1
    Integer(i4) :: WhichPointingGrid
d386 1
d389 8
a396 2
    integer :: NOUSEDCHANNELS           ! Array size
    
d400 6
a405 4
    Type(path_index)  :: ndx_path(Nptg,mnm)
    Type(path_vector) :: z_path(Nptg,mnm),t_path(Nptg,mnm),h_path(Nptg,mnm),  &
                         dhdz_path(Nptg,mnm), spsfunc_path(Nsps,Nptg,mnm),    &
                         n_path(Nptg,mnm),phi_path(Nptg,mnm)
d407 1
a407 1
    Type(path_derivative) :: dh_dt_path(Nptg,mnm)
d409 3
a411 3
    Real(r8) :: thbs(10),elev_offset
    Real(r8) :: t_script(N2lvl),ref_corr(N2lvl,Nptg),tau(N2lvl), &
                tan_dh_dt(Nlvl,mnm,mxco)
d413 1
a413 1
    Real(r8) :: dx_dt(Nptg,mxco), d2x_dxdt(Nptg,mxco)
d415 2
a416 2
    Real(r8) :: h_glgrid(ngt,mnm), t_glgrid(ngt,mnm), z_glgrid(ngt/2)
    Real(r8) :: dh_dt_glgrid(ngt,mnm,mxco), dhdz_glgrid(ngt,mnp)
d418 2
a419 2
    Real(r8) :: ptg_angles(Nptg,mnm), center_angle
    Real(r8) :: tan_hts(Nptg,mnm), tan_temp(Nptg,mnm)
d422 5
a426 5
!   Real(r4) :: K_TEMP(Nch,Nptg,mxco,mnp)
!   Real(r4) :: K_ATMOS(Nch,Nptg,mxco,mnp,Nsps)
!   Real(r4) :: K_SPECT_DW(Nch,Nptg,mxco,mnp,Nsps),  &
!               K_SPECT_DN(Nch,Nptg,mxco,mnp,Nsps),  &
!               K_SPECT_DNU(Nch,Nptg,mxco,mnp,Nsps)
d428 2
a429 2
! ** DEBUG, memory limitations force us to have up to 2 channels
!           only (Replacing Nch by: 2)
d431 5
a435 5
    Real(r4) :: K_TEMP(02,Nptg,mxco,mnp)
    Real(r4) :: K_ATMOS(02,Nptg,mxco,mnp,Nsps)
    Real(r4) :: K_SPECT_DW(02,Nptg,mxco,mnp,Nsps),  &
                K_SPECT_DN(02,Nptg,mxco,mnp,Nsps),  &
                K_SPECT_DNU(02,Nptg,mxco,mnp,Nsps)
d440 1
a440 1
    Type(k_matrix_info) :: k_star_info(20)
d442 5
a446 14
    Type(path_derivative) :: k_temp_frq, k_atmos_frq(Nsps), &
                             k_spect_dw_frq(Nsps), k_spect_dn_frq(Nsps), &
                             k_spect_dnu_frq(Nsps)
    !
    Type(path_beta), DIMENSION(:,:), POINTER :: beta_path => null()

    Real(r8) :: Radiances(Nptg,Nch)
    Real(r8) :: e_rad, Zeta, Frq, h_tan, Rad, geoc_lat, geod_lat, r
    !
    Character (LEN=01) :: CA
    Character (LEN=08) :: Name
    Character (LEN=16) :: Vname
    Character (LEN=80) :: Line
    Character (LEN=40) :: Ax, Dtm1, Dtm2
d448 10
a457 1
    Real(r8), dimension(:), allocatable :: RadV
d466 1
a466 1
!zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d534 11
a544 1
    print*,'Got part of the way through'
a552 3
    io = 0
    ch1 = FMC%Channels_range(1)
    ch2 = FMC%Channels_range(2)
d554 8
a561 1
    elev_offset = 0.0                         ! Zero elev_offset in any case
d563 2
a564 20
    signal = getSignal ( forwardModelConfig%sigInfo(1)%signal )
    whichPointingGrid = signal%pointingGrid
    if ( whichPointingGrid <= 0 ) &
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & "There is no pointing grid for the desired signal" )
    call allocate_test ( grids, size(FMI%tan_press), "Grids", moduleName )
    call get_grids_near_tan_pressures ( whichPointingGrid, FMI%tan_press, &
    & tol, grids )

!
! Convert GeoDetic Latitude to GeoCentric Latitude, and convert both to
! Radians (instead of Degrees). Also compute the effective earth radius.
!
    mmaf = 3                     ! Do only this mmaf (middle phi)
    phi_tan = FMC%phi_tan_mmaf(mmaf)
    geod_lat= TFMI%t_geod_lat(mmaf)
    Call geoc_geod_conv(orbIncline%values(1,1),phi_tan,geod_lat, geoc_lat,E_rad)
!
! Compute the hydrostatic_model on the GL-Grid for all mmaf(s):
!
d569 5
a573 1
    Call hydrostatic_model(si,FMC%N_lvls,temp%template%noSurfs, &
d580 5
a584 5
    IF(ier /= 0) goto 99
!
! Compute all path entities for all mmafs and tanget pointings
!
    Call comp_path_entities(fwdModelIn, fwdModelExtra, forwardModelConfig%molecules, &
d587 33
a619 7
   &     z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid,dh_dt_glgrid,       &
   &     TFMI%atmospheric,TFMI%f_zeta_basis,TFMI%mr_f,              &
   &     TFMI%no_coeffs_f,tan_hts,no_tan_hts,FMI%n_sps,             &
   &     TFMI%no_phi_f,TFMI%f_phi_basis,z_path,h_path,t_path,       &
   &     phi_path,n_path,dhdz_path,dh_dt_path,temp%template%noInstances,        &
   &     temp%template%phi(1,:)*degToRad,spsfunc_path,TFMI%is_f_log,FMC%no_mmaf,Ier)
    IF(ier /= 0) goto 99
a620 25
!
! **********************  MAIN Mmaf Loop *******************
!
    l = mmaf
!   DO l = 1, FMC%no_mmaf
!   DO l = 1, radiance%template%noInstances   ! ** DEBUG, only one mmaf
!
      phi_tan = fmc%phi_tan_mmaf(l)
!
! Compute the ptg_angles (chi) for Antenna convolution, also the derivatives
! of chi w.r.t to T and other parameters
!
      Call get_chi_angles(ndx_path(:,l),n_path(:,l),FMI%tan_press,        &
     &     tan_hts(:,l),tan_temp(:,l),phi_tan,RoC,scGeocAlt%values(1,1),  &
     &     elevOffset%values(1,1), &
     &     tan_dh_dt(:,l,:),no_tan_hts,temp%template%noSurfs,temp%template%surfs(:,1),&
     &     si,    &
     &     center_angle,ptg_angles(:,l),dx_dt,d2x_dxdt,ier)
      IF(ier /= 0) goto 99
!
! Compute the refraction correction scaling matrix for this mmaf:
!
      Call refraction_correction(no_tan_hts, tan_hts(:,l), h_path(:,l), &
     &                n_path(:,l), ndx_path(:,l), E_rad, ref_corr)
!
d623 75
a697 4
!
! **********************  MAIN Pointing Loop *******************
!
      DO ptg_i = 1, no_tan_hts-1
d700 3
a702 74
        h_tan = tan_hts(k,l)
        kk = SIZE(PointingGrids(whichPointingGrid)%OneGrid(grids(ptg_i))%Frequencies)
        FMI%no_ptg_frq(k)=kk !??? Remove this later...
!        kk = FMI%no_ptg_frq(k)
!
        if(kk /= prev_npf) then
!
          prev_npf = kk
          DEALLOCATE(k_temp_frq%values,STAT=i)
!
          DEALLOCATE(RadV,STAT=i)
          ALLOCATE(RadV(kk),STAT=ier)
          IF(ier /= 0) then
            Print *,'** ALLOCATE Error: RadV array, STAT =',ier
            goto 99
          endif
!
          do j = 1, FMI%n_sps
            DEALLOCATE(k_atmos_frq(j)%values,STAT=i)
            DEALLOCATE(k_spect_dw_frq(j)%values,STAT=i)
            DEALLOCATE(k_spect_dn_frq(j)%values,STAT=i)
            DEALLOCATE(k_spect_dnu_frq(j)%values,STAT=i)
          end do
!
          ALLOCATE(k_temp_frq%values(kk,temp%template%noSurfs,&
            & temp%template%noInstances),STAT=ier)
          IF(ier /= 0) then
            Print *,'** ALLOCATE Error: k_temp_frq array, STAT =',ier
            goto 99
          endif
!
          do j = 1, FMI%n_sps
            m = max(1,TFMI%no_phi_f(j))
            i = max(1,TFMI%no_coeffs_f(j))
            ALLOCATE(k_atmos_frq(j)%values(kk,i,m),STAT=ier)
            IF(ier /= 0) then
              Print *,'** ALLOCATE Error: k_atmos_frq, STAT =',ier
              goto 99
            endif
          end do
!
          do m = 1, FMI%n_sps
            j = FMI%spect_atmos(m)
            if(j < 1) CYCLE
            if(.not. FMI%spectroscopic(j)%DER_CALC(FMI%band)) CYCLE
            Vname = ' '
            Spectag = FMI%spectroscopic(j)%Spectag
            DO
              if(FMI%spectroscopic(j)%Spectag /= Spectag) EXIT
              n = FMI%spectroscopic(j)%no_phi_values
              i = FMI%spectroscopic(j)%no_zeta_values
              CA = FMI%spectroscopic(j)%type
              select case ( CA )
                case ( 'W' )
                  Vname = 'k_spect_dw_frq'
                  ALLOCATE(k_spect_dw_frq(m)%values(kk,i,n),STAT=ier)
                case ( 'N' )
                  Vname = 'k_spect_dn_frq'
                  ALLOCATE(k_spect_dn_frq(m)%values(kk,i,n),STAT=ier)
                case ( 'V' )
                  Vname = 'k_spect_dnu_frq'
                  ALLOCATE(k_spect_dnu_frq(m)%values(kk,i,n),STAT=ier)
                case default
                  Ier = -99
                  Print *,'** Unknown Spectroscopic element !'
              end select
              IF(ier /= 0) then
                Print *,'** ALLOCATE Error: ',Vname,', STAT =',ier
                goto 99
              ENDIF
              j = j + 1
              if(j > 3 * FMI%n_sps) EXIT
            END DO
          end do
d704 1
a704 5
        endif            ! On DEALLOCATE/ALLOCATE cycle
!
! Compute the beta's along the path, for this tanget hight and this mmaf:
!
        no_ele = ndx_path(ptg_i,l)%total_number_of_elements
d706 2
d709 13
a721 21
          frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
        else
          ! Think later about multiple signals case!???
          kk = count ( forwardModelConfig%sigInfo(1)%channelIncluded )
          call allocate_test(frequencies,kk,"frequencies",ModuleName)
          frequencies = pack ( signal%frequencies, &
            & forwardModelConfig%sigInfo(1)%channelIncluded )
          select case (signal%sideband)
          case ( l_lower )
            frequencies = signal%lo - (signal%centerFrequency+frequencies)
          case ( l_upper )
            frequencies = signal%lo + (signal%centerFrequency+frequencies)
          case ( l_folded )
            call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Folded signal requested in forward model')
          case default
            call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'Bad value of signal%sideband')
          end select
        endif
        kk = size(frequencies)
a722 16
        Call get_beta_path(frequencies,&
          & FMI%pfa_spectrum,no_ele, z_path(ptg_i,l),t_path(ptg_i,l), &
          & beta_path, FMC%vel_z_mmaf(l),ier)
        IF(ier /= 0) goto 99
!
        k_temp_frq%values = 0.0
        do j = 1, FMI%n_sps
          k_atmos_frq(j)%values = 0.0
          k_spect_dw_frq(j)%values = 0.0
          k_spect_dn_frq(j)%values = 0.0
          k_spect_dnu_frq(j)%values = 0.0
        end do
!
          
        do frq_i = 1, kk
!
d724 8
a731 15
!
!           call output("For pointing: ")
!           call output(ptg_i)
!           call output(" and frequency ")
!           call output(frq_i,advance='yes')
!           call output("beta_bath",advance='yes')
!           call dump(beta_path(1,frq_i)%values)
          
          Call Rad_Tran(Frq, FMC%N_lvls, h_tan, FMI%n_sps, ndx_path(k,l),  &
         &    z_path(k,l), h_path(k,l), t_path(k,l), phi_path(k,l),&
         &    dHdz_path(k,l), earthRefl%values(1,1), beta_path(:,frq_i),      &
         &    spsfunc_path(:,k,l), ref_corr(:,k), spaceRadiance%values(1,1), brkpt, &
         &    no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier)
          IF(ier /= 0) goto 99
!
a732 18
!
! Now, Compute the radiances derivatives:
!
!         CALL Rad_Tran_WD(frq_i,FMI%band,Frq,FMC%N_lvls,FMI%n_sps, &
!        &     FMC%temp_der,FMC%atmos_der,FMC%spect_der,            &
!        &     z_path(k,l),h_path(k,l),t_path(k,l),phi_path(k,l),   &
!        &     dHdz_path(k,l),TFMI%atmospheric,beta_path(:,frq_i),&
!        &     spsfunc_path(:,k,l),temp%template%surfs(:,1),  &
!        &     TFMI%f_zeta_basis,TFMI%no_coeffs_f,   &
!        &     TFMI%mr_f,TFMI%no_t,ref_corr(:,k),TFMI%no_phi_f,       &
!        &     TFMI%f_phi_basis,temp%template%noInstances,temp%template%phi(1,:)*degToRad,  &
!        &     dh_dt_path(k,l),FMI%spect_atmos,         &
!        &     FMI%spectroscopic,k_temp_frq,k_atmos_frq,k_spect_dw_frq,   &
!        &     k_spect_dn_frq,k_spect_dnu_frq,TFMI%is_f_log,brkpt,       &
!        &     no_ele,mid,ilo,ihi,t_script,tau,ier)
!         IF(ier /= 0) goto 99
!
        end do
d734 23
a756 21
!
! Frequency Average the radiances with the appropriate filter shapes
!
        do i = 1, noUsedChannels
          ch = usedChannels(i)
          if(FMC%do_frqavg) then
            print*,'Doing frequency averaging'
            Call Freq_Avg(frequencies,FMI%F_grid_filter(:,i),  &
           &     FMI%Filter_func(:,ch),RadV,kk,FMI%no_filt_pts, &
           &     Radiances(ptg_i,ch))
          else
            Radiances(ptg_i,ch) = RadV(i)
          endif
        end do
!
        if(FMC%temp_der) then
!
! Frequency Average the temperature derivatives with the appropriate
! filter shapes
!
          RadV(1:kk) = 0.0
d759 3
a761 13
            do j = 1, temp%template%noInstances
              do k = 1, temp%template%noSurfs
                if(FMC%do_frqavg) then
                  RadV(1:kk) = k_temp_frq%values(1:kk,k,j)
                  Call Freq_Avg(frequencies,FMI%F_grid_filter(:,i), &
                 &              FMI%Filter_func(:,i),          &
                 &              RadV,kk,FMI%no_filt_pts,r)
                else
                  r = k_temp_frq%values(1,k,j)
                endif
                k_temp(ch,ptg_i,k,j) = r
              end do
            end do
d763 2
a764 1
!
d767 20
a786 27
        if(FMC%atmos_der) then
!
! Frequency Average the atmospheric derivatives with the appropriate
! filter shapes
!
          do i = 1, noUsedChannels
            ch = usedChannels(i)
            do j = 1, FMI%n_sps
              if(TFMI%atmospheric(j)%der_calc(FMI%band)) THEN
                RadV(1:kk) = 0.0
                do k = 1, TFMI%no_phi_f(j)
                  do n = 1, TFMI%no_coeffs_f(j)
                    if(FMC%do_frqavg) then
                      RadV(1:kk) = k_atmos_frq(j)%values(1:kk,n,k)
                      Call Freq_Avg(frequencies,FMI%F_grid_filter(:,i), &
                     &              FMI%Filter_func(:,i),          &
                     &              RadV,kk,FMI%no_filt_pts,r)
                    else
                      r = k_atmos_frq(j)%values(1,n,k)
                    endif
                    k_atmos(ch,ptg_i,n,k,j) = r
                  end do
                end do
              endif
            end do
          end do
!
d789 78
a866 51
        if(FMC%spect_der) then
!
! Frequency Average the spectroscopic derivatives with the appropriate
! filter shapes
!
          do i = 1, noUsedChannels
            ch = usedChannels(i)
            do m = 1, FMI%n_sps
              j = FMI%spect_atmos(m)
              if(.not.  FMI%spectroscopic(j)%DER_CALC(FMI%band)) CYCLE
              Spectag = FMI%spectroscopic(j)%Spectag
              DO
                if(FMI%spectroscopic(j)%Spectag /= Spectag) EXIT
                RadV(1:kk) = 0.0
                CA = FMI%spectroscopic(j)%type
                do k = 1, FMI%spectroscopic(j)%no_phi_values
                  do n = 1, FMI%spectroscopic(j)%no_zeta_values
                    select case ( CA )
                      case ( 'W' )
                        RadV(1:kk) = k_spect_dw_frq(m)%values(1:kk,n,k)
                      case ( 'N' )
                        RadV(1:kk) = k_spect_dn_frq(m)%values(1:kk,n,k)
                      case ( 'V' )
                        RadV(1:kk) = k_spect_dnu_frq(m)%values(1:kk,n,k)
                    end select
                    if(FMC%do_frqavg) then
                        Call Freq_Avg(frequencies,FMI%F_grid_filter(:,i), &
                     &              FMI%Filter_func(:,i),&
                     &              RadV,kk,FMI%no_filt_pts,r)
                    else
                      r = RadV(1)
                    endif
                    select case ( CA )
                      case ( 'W' )
                        k_spect_dw(ch,ptg_i,n,k,j) = r
                      case ( 'N' )
                        k_spect_dn(ch,ptg_i,n,k,j) = r
                      case ( 'V' )
                        k_spect_dnu(ch,ptg_i,n,k,j) = r
                    end select
                  end do
                end do
                j = j + 1
                if(j > 3 * FMI%n_sps) EXIT
              END DO
            end do
          end do
!
        endif
!
      END DO              ! Pointing Loop
a867 5
!
! Complete the radiances's last location, also  complete k_temp last
! location as well as k_atmos last location and k_spect_d? last location:
!
      kk = no_tan_hts
d870 1
a870 1
        Radiances(kk,ch) = Radiances(kk-1,ch)
d872 3
a874 3
          k_temp(i,kk,1:temp%template%noSurfs,1:temp%template%noInstances) = &
       &              k_temp(i,kk-1,1:temp%template%noSurfs,&
       &              1:temp%template%noInstances)
d881 1
a881 1
              k_atmos(i,kk,1:n,1:k,m)=k_atmos(i,kk-1,1:n,1:k,m)
d888 1
a888 1
            if(.not.  FMI%spectroscopic(j)%DER_CALC(FMI%band)) CYCLE
d890 2
a891 2
            DO
              if(FMI%spectroscopic(j)%Spectag /= Spectag) EXIT
d894 3
a896 3
              k_spect_dw(i,kk,1:n,1:k,j)=k_spect_dw(i,kk-1,1:n,1:k,j)
              k_spect_dn(i,kk,1:n,1:k,j)=k_spect_dn(i,kk-1,1:n,1:k,j)
              k_spect_dnu(i,kk,1:n,1:k,j)=k_spect_dnu(i,kk-1,1:n,1:k,j)
d898 2
a899 2
              if(j > 3 * FMI%n_sps) EXIT
            END DO
d903 4
a906 5
!
!  Here comes the Convolution code
!
      DO i = 1, noUsedChannels
!
d908 1
a908 1
!
d910 14
a923 15
!
          Call convolve_all(ptan%values(:,l),TFMI%atmospheric,FMI%n_sps,   &
         &     FMC%temp_der,FMC%atmos_der,FMC%spect_der,                   &
         &     FMI%tan_press,ptg_angles(:,l),tan_temp(:,l), &
         &     dx_dt, d2x_dxdt,FMI%band,center_angle,FMI%fft_pts,          &
         &     Radiances(:,ch),k_temp(i,:,:,:),k_atmos(i,:,:,:,:), &
         &     k_spect_dw(i,:,:,:,:),k_spect_dn(i,:,:,:,:),    &
         &     k_spect_dnu(i,:,:,:,:),FMI%spect_atmos,no_tan_hts,  &
         &     k_info_count,i_star_all(i,:),k_star_all(i,:,:,:,:), &
         &     k_star_info,temp%template%noSurfs,temp%template%noInstances,&
         &     TFMI%no_phi_f,   &
         &     FMI%spectroscopic,temp%template%surfs(:,1),FMI%Xlamda,FMI%Aaap,&
         &     FMI%D1Aaap,FMI%D2Aaap,FMI%Ias,ier)
          IF(ier /= 0) goto 99
!
d925 11
a935 12
!
          Call no_conv_at_all(ptan%values(:,l),FMI%n_sps,FMI%tan_press, &
         &     FMI%band,FMC%temp_der,FMC%atmos_der,FMC%spect_der,      &
         &     Radiances(:,ch),k_temp(i,:,:,:),                    &
         &     k_atmos(i,:,:,:,:),k_spect_dw(i,:,:,:,:),       &
         &     k_spect_dn(i,:,:,:,:),k_spect_dnu(i,:,:,:,:),   &
         &     FMI%spect_atmos, no_tan_hts,k_info_count,               &
         &     i_star_all(i,:), k_star_all(i,:,:,:,:),            &
         &     k_star_info,temp%template%noSurfs,temp%template%noInstances, &
         &     TFMI%no_phi_f,temp%template%surfs(:,1),TFMI%atmospheric,    &
         &     FMI%spectroscopic)
!
d937 2
a938 2
!
      END DO                            ! Channel loop
d943 1
a943 1
            & (mif-1)*radiance%template%noChans, l ) = i_star_all( channel, mif )
d946 5
a950 4
!
!   END DO                ! Mmaf Loop
!
    if(FMC%temp_der) DEALLOCATE(k_temp_frq%values,STAT=i)
d952 1
a952 1
      if(FMC%atmos_der) DEALLOCATE(k_atmos_frq(j)%values,STAT=i)
d954 3
a956 3
        DEALLOCATE(k_spect_dw_frq(j)%values,STAT=i)
        DEALLOCATE(k_spect_dn_frq(j)%values,STAT=i)
        DEALLOCATE(k_spect_dnu_frq(j)%values,STAT=i)
d959 3
a961 3
!
! *** DEBUG Print
!
d963 1
a963 1
      Print *,'Convolution: ON'
d965 1
a965 1
      Print *,'Convolution: OFF'
d967 1
a967 1
!
d974 1
a974 1
      Print *,'Frequency Averaging: ON'
d976 1
a976 1
    Print *
d978 1
a978 1
!
d980 1
a980 2
    kk = TFMI%ptg_press%no_lin_values
    tau(1:kk) = dble(TFMI%ptg_press%lin_val(1:kk))
d984 3
a986 3
    Call Hunt(Zeta,tau,kk,klo,j)
    IF(ABS(Zeta-tau(j)) < ABS(Zeta-tau(klo))) klo=j
!
d989 2
a990 2
      write(*,903) ch,char(92),kk
      write(*,905) (i_star_all(i,k),k=1,kk)
d994 1
a994 1
!
d999 2
a1000 2
    if(.not. ANY((/FMC%temp_der,FMC%atmos_der,FMC%spect_der/))) goto 99
!
d1005 1
a1005 1
      Print *
d1008 1
a1008 1
      if(Name == 'PTAN') CYCLE
d1012 7
a1018 7
      l = LEN_TRIM(Name)
      if(Name(l-1:l) == '_W' .or.  &
     &   Name(l-1:l) == '_N' .or.  &
     &   Name(l-1:l) == '_V' ) then
        Print *,Name
        r = SUM(k_star_all(ch,kz,1:mnz,1:ht_i,klo))
        Print *,'  Sum over all zeta & phi coeff:',sngl(r)
d1023 1
a1023 1
          write(6,913) 'dI_d'//Name(1:l),char(92),ht_i
d1027 3
a1029 3
        Call Hunt(Zeta,tau,mnz,m,j)
        IF(ABS(Zeta-tau(j)) < ABS(Zeta-tau(m))) m=j
        Print *,(k_star_all(ch,kz,m,kk,klo),kk=1,ht_i)
d1033 2
a1035 4
!
 99  if (io /= 0) then
       Call ErrMsg(Line,io)
    endif
d1037 3
a1039 2
    Return
!zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
d1046 2
a1047 2
  ! Add a quantity template to a database, or create the database if it
  ! doesn't yet exist
d1075 1
a1075 1
          if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
d1079 1
a1079 1
        if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
d1082 1
a1082 1
        if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
d1085 1
a1085 1
      
d1087 1
a1087 1
      if (status /= 0) CALL MLSMessage(MLSMSG_Error,ModuleName,&
d1092 1
a1092 1
! =====     Private Procedures     =====================================
d1140 1
a1140 1
  subroutine AnnounceError ( Code, Where, FieldIndex )
d1142 1
a1142 1
    integer, intent(in) :: Where      ! Where in the tree did the error occur?
d1150 17
a1166 17
      case (AllocateError) 
        call output ( 'allocation error.', advance='yes')
      case (BadMolecule) 
        call output ( 'asked for derivatives for an unlisted molecule.')
      case (DefineMoleculesFirst) 
        call output ( 'molecule must be defined before moleules derivatives.', advance='yes')
      case (DefineSignalsFirst) 
        call output ( 'signals must be defined before channels.', advance='yes')
      case (DuplicateField) 
        call output ( 'duplicate field specified:' )
        call display_string(field_indices(FieldIndex), advance='yes')
      case (IncompleteFullFwm)
        call output ( 'incomplete full foward model specification' )
      case (IncompleteLinearFwm)
        call output ( 'incomplete linear foward model specification' )
      case (IrrelevantFwmParameter)
        call output ( 'irrelevant parameter for this forward model type' )
d1173 3
@


2.31
log
@Interim version mr_f in, but not quite working yet.
@
text
@d27 3
a29 3
  use Init_Tables_Module, only: L_CHANNEL, L_EARTHREFL, L_ELEVOFFSET, L_FULL, L_LINEAR,&
    & L_LOSVEL, L_NONE, L_ORBITINCLINE, L_PTAN, L_RADIANCE, L_REFGPH, L_SCAN,&
    & L_SCGEOCALT, L_SPACERADIANCE, L_TEMPERATURE
d67 1
a67 1
    & "$Id: ForwardModelInterface.f90,v 2.30 2001/03/21 01:10:09 livesey Exp $"
d383 1
a383 1
    Integer(i4) :: ch1, ch2, no_pfa_ch, pfa_ch(2)
d387 7
d516 10
a537 4
    no_pfa_ch = min(2,ch2-ch1+1)
    do i = 1, no_pfa_ch
      pfa_ch(i) = ch1 + i - 1
    end do
d704 17
a720 2
          call allocate_test(frequencies,1,"frequencies",ModuleName)
          frequencies(1)=FMC%zfrq
d779 2
a780 2
        do i = 1, no_pfa_ch
          ch = pfa_ch(i)
d784 1
a784 1
           &     FMI%Filter_func(:,i),RadV,kk,FMI%no_filt_pts, &
d787 1
a787 1
            Radiances(ptg_i,ch) = RadV(1)
d797 2
a798 3
          do i = 1, no_pfa_ch
!           ch = pfa_ch(i)
            ch = i               ! ** DEBUG, memory limitations on MLSGATE
d821 2
a822 3
          do i = 1, no_pfa_ch
!           ch = pfa_ch(i)
            ch = i                 ! ** DEBUG, memory limitations on MLSGATE
d850 2
a851 3
          do i = 1, no_pfa_ch
!           ch = pfa_ch(i)
            ch = i                 ! ** DEBUG, memory limitations on MLSGATE
d902 2
a903 2
      do i = 1, no_pfa_ch
        ch = pfa_ch(i)
d940 1
a940 1
      DO i = 1, no_pfa_ch
d942 1
a942 1
        ch = pfa_ch(i)
d975 8
a982 1
      END DO
d1024 2
a1025 2
    do i = 1, no_pfa_ch
      ch = pfa_ch(i)
d1032 4
d1069 1
d1211 3
@


2.30
log
@Interim version before dealing with mr_f
@
text
@d67 1
a67 1
    & "$Id: ForwardModelInterface.f90,v 2.29 2001/03/21 01:07:45 livesey Exp $"
d563 2
a564 1
    Call comp_path_entities(FMC%n_lvls,temp%template%noSurfs,&
d1174 3
@


2.29
log
@Before moving away from mr_f
@
text
@d67 1
a67 1
    & "$Id: ForwardModelInterface.f90,v 2.28 2001/03/20 23:25:54 livesey Exp $"
a508 21
!     call output ("Early work:",advance='yes')
!     call output ("t_zeta_basis",advance='yes')
!     call dump(TFMI%t_zeta_basis)
!     call output ("temp%template%surfs",advance='yes')
!     call dump(temp%template%surfs)
!     call output ("t_phi_basis",advance='yes')
!     call dump(TFMI%t_phi_basis)
!     call output ("temp%template%phi",advance='yes')
!     call dump(temp%template%phi)
!     call output ("t_coeff",advance='yes')
!     call dump(TFMI%t_coeff)
!     call output ("temp%values",advance='yes')
!     call dump(temp%values)
!     stop

!     call output("ptan%values(:,3)",advance='yes')
!     call dump(ptan%values(:,3))
!     call output("tfmi%ptg_press%lin_val",advance='yes')
!     call dump( real(tfmi%ptg_press%lin_val,r8) )
!     stop

a527 7
!
! Load the "Frequency gridding by pointing" file ("Bill's" file..)
!
! This has been moved into ForwardModelGlobalSetup, q.v.
!   Call ptg_frq_load(FMC, FMI, Ier)
!   if(ier /= 0) goto 99

a536 6
!??? Zvi:  The frequency pointing grids (The "Bill" file) are now read by
!??? PointingGrid_m.  That routine doesn't any longer have the tangent
!??? pressure arrays, so it doesn't eliminate grids that aren't "near"
!??? tangent pressures.  The intent is that get_grids_near_tan_pressures
!??? gives you the indices of the frequency grids that are "near" tangent
!??? pressures.
a604 4
!??? Zvi: This is as far as I got in my new scheme for frequency pointing
!??? grids.  Below, you'll need to use PointingGrids(grids(ptg_i)).  See
!??? the PointingGrid_m module for details of the data structure.

d746 1
d1173 3
@


2.28
log
@Copied changes from Zvi
@
text
@d67 1
a67 1
    & "$Id: ForwardModelInterface.f90,v 2.27 2001/03/20 11:03:43 zvi Exp $"
d104 2
d509 20
d578 1
a578 1
    Call geoc_geod_conv(TFMI%beta_inc,phi_tan,geod_lat, geoc_lat,E_rad)
d582 1
a582 1
    thbs(1:) = 0.0
d586 7
a592 5
    Call hydrostatic_model(si,FMC%N_lvls,TFMI%no_t,FMC%no_mmaf,FMC%t_indx, &
         no_tan_hts,geoc_lat,TFMI%Href,TFMI%Zref,FMI%z_grid,thbs, &
         TFMI%t_zeta_basis, TFMI%t_coeff, z_glgrid, h_glgrid, t_glgrid, &
         dhdz_glgrid,dh_dt_glgrid,FMI%tan_press,tan_hts,tan_temp,tan_dh_dt, &
         gl_count, Ier)
d597 2
a598 1
    Call comp_path_entities(FMC%n_lvls,TFMI%no_t,gl_count,ndx_path, &
d603 2
a604 2
   &     phi_path,n_path,dhdz_path,dh_dt_path,TFMI%no_phi_t,        &
   &     TFMI%t_phi_basis,spsfunc_path,TFMI%is_f_log,FMC%no_mmaf,Ier)
d619 6
a624 4
      Call get_chi_angles(ndx_path(1:,l),n_path(1:,l),FMI%tan_press,        &
     &     tan_hts(1:,l),tan_temp(1:,l),phi_tan,RoC,TFMI%h_obs,elev_offset, &
     &     tan_dh_dt(1:,l,1:),no_tan_hts,TFMI%no_t,TFMI%t_zeta_basis,si,    &
     &     center_angle,ptg_angles(1:,l),dx_dt,d2x_dxdt,ier)
d629 2
a630 2
      Call refraction_correction(no_tan_hts, tan_hts(1:,l), h_path(1:,l), &
     &                n_path(1:,l), ndx_path(1:,l), E_rad, ref_corr)
d668 2
a669 1
          ALLOCATE(k_temp_frq%values(kk,TFMI%no_t,TFMI%no_phi_t),STAT=ier)
d689 1
a689 1
            Vname(1:) = ' '
d760 2
a761 2
         &    dHdz_path(k,l), TFMI%earth_ref, beta_path(1:,frq_i),      &
         &    spsfunc_path(1:,k,l), ref_corr(1:,k), TFMI%s_temp, brkpt, &
d772 2
a773 2
!        &     dHdz_path(k,l),TFMI%atmospheric,beta_path(1:,frq_i),&
!        &     spsfunc_path(1:,k,l),TFMI%t_zeta_basis,  &
d775 2
a776 2
!        &     TFMI%mr_f,TFMI%no_t,ref_corr(1:,k),TFMI%no_phi_f,       &
!        &     TFMI%f_phi_basis,TFMI%no_phi_t,TFMI%t_phi_basis,  &
d791 2
a792 2
            Call Freq_Avg(frequencies,FMI%F_grid_filter(1:,i),  &
           &     FMI%Filter_func(1:,i),RadV,kk,FMI%no_filt_pts, &
d808 2
a809 2
            do j = 1, TFMI%no_phi_t
              do k = 1, TFMI%no_t
d812 2
a813 2
                  Call Freq_Avg(frequencies,FMI%F_grid_filter(1:,i), &
                 &              FMI%Filter_func(1:,i),          &
d840 2
a841 2
                      Call Freq_Avg(frequencies,FMI%F_grid_filter(1:,i), &
                     &              FMI%Filter_func(1:,i),          &
d882 2
a883 2
                        Call Freq_Avg(frequencies,FMI%F_grid_filter(1:,i), &
                     &              FMI%Filter_func(1:,i),&
d917 3
a919 2
          k_temp(i,kk,1:TFMI%no_t,1:TFMI%no_phi_t) = &
       &              k_temp(i,kk-1,1:TFMI%no_t,1:TFMI%no_phi_t)
d957 1
a957 1
          Call convolve_all(TFMI%ptg_press,TFMI%atmospheric,FMI%n_sps,   &
d959 1
a959 1
         &     FMI%tan_press,ptg_angles(1:,l),tan_temp(1:,l), &
d961 7
a967 6
         &     Radiances(1:,ch),k_temp(i,1:,1:,1:),k_atmos(i,1:,1:,1:,1:), &
         &     k_spect_dw(i,1:,1:,1:,1:),k_spect_dn(i,1:,1:,1:,1:),    &
         &     k_spect_dnu(i,1:,1:,1:,1:),FMI%spect_atmos,no_tan_hts,  &
         &     k_info_count,i_star_all(i,1:),k_star_all(i,1:,1:,1:,1:), &
         &     k_star_info,TFMI%no_t,TFMI%no_phi_t,TFMI%no_phi_f,   &
         &     FMI%spectroscopic,TFMI%t_zeta_basis,FMI%Xlamda,FMI%Aaap,&
d973 1
a973 1
          Call no_conv_at_all(TFMI%ptg_press,FMI%n_sps,FMI%tan_press, &
d975 3
a977 3
         &     Radiances(1:,ch),k_temp(i,1:,1:,1:),                    &
         &     k_atmos(i,1:,1:,1:,1:),k_spect_dw(i,1:,1:,1:,1:),       &
         &     k_spect_dn(i,1:,1:,1:,1:),k_spect_dnu(i,1:,1:,1:,1:),   &
d979 3
a981 3
         &     i_star_all(i,1:), k_star_all(i,1:,1:,1:,1:),            &
         &     k_star_info,TFMI%no_t,TFMI%no_phi_t,                  &
         &     TFMI%no_phi_f,TFMI%t_zeta_basis,TFMI%atmospheric,    &
d1040 1
a1040 1
    tau(1:) = 0.0
d1043 1
a1043 1
      Name(1:) = ' '
d1062 1
a1062 1
        tau(1:) = 0.0
d1210 3
@


2.27
log
@Fixing code, increase dim. etc.
@
text
@d67 1
a67 1
    & "$Id: ForwardModelInterface.f90,v 2.26 2001/03/20 02:28:58 livesey Exp $"
d432 1
a432 1
    Real(r8) :: e_rad, Zeta, Frq, h_tan, Rad, geoc_lat, r
d555 2
a556 1
    Call geoc_geod_conv(TFMI%beta_inc,phi_tan,geoc_lat,E_rad)
d879 1
d1003 1
a1003 1
903 format('ch',i2.2,'_avg_conv_pfa_rad',a1,i3.3)
d1180 3
@


2.26
log
@Interim version, gets same numbers as Zvi
@
text
@d67 1
a67 1
    & "$Id: ForwardModelInterface.f90,v 2.25 2001/03/19 17:10:35 livesey Exp $"
d573 6
a578 7
         z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid,dh_dt_glgrid,        &
         TFMI%atmospheric,TFMI%f_zeta_basis,TFMI%mr_f,            &
         TFMI%no_coeffs_f,tan_hts,no_tan_hts,FMI%n_sps,             &
         TFMI%no_phi_f,TFMI%f_phi_basis,z_path,h_path,t_path,      &
         phi_path,n_path,dhdz_path,dh_dt_path,TFMI%no_phi_t,        &
         TFMI%t_phi_basis,spsfunc_path,TFMI%is_f_log,FMC%no_mmaf,  &
         FMC%phi_tan_mmaf,Ier)
a589 14
      TFMI%t_phi_basis(1:TFMI%no_phi_t) = &
                      TFMI%T_PHI_BASIS_COPY(1:TFMI%no_phi_t) + phi_tan

      DO j = 1, FMI%n_sps
        k = TFMI%no_phi_f(j)
        TFMI%f_phi_basis(1:k,j) = TFMI%F_PHI_BASIS_COPY(1:k,j) + phi_tan
      end do

      k = FMI%mfi + 2
      do j = 1, FMI%no_spectro
        FMI%spectroscopic(j)%PHI_BASIS(1:k) = &
       &                TFMI%S_PHI_BASIS_COPY(1:k,j) + phi_tan
      end do
!
d1001 1
a1001 1
903 format('ch',i2.2,'_avg_conv_pfa_rad',a1,i2.2)
d1178 3
@


2.25
log
@Added more checks etc.
@
text
@d42 1
a42 1
    & Open_Pointing_Grid_File, Read_Pointing_Grid_File
d67 1
a67 1
    & "$Id: ForwardModelInterface.f90,v 2.24 2001/03/18 00:55:50 livesey Exp $"
d75 1
a75 1
    logical, dimension(:), pointer :: channelIncluded ! Which channels to use
d128 1
a128 1
    call get_string ( sub_rosa(subtree(2,son)), pointingGridsFile )
d150 1
a150 1
    type (ForwardModelSignalInfo_T), pointer :: thisFWMSignal ! A signal
d279 21
d301 1
a301 21
      ! Now some more error checking
      select case (info%fwmType)
      case (l_full)
        if (.not. all(got( (/f_molecules, f_signals/) ))) &
          & call AnnounceError (IncompleteFullFwm, root)
        ! Check parameters needed only for linear/scan are not included
        !????
      case (l_scan)
        ! Add 1d/2d method later probably !??? NJL
        if (any(got( (/f_atmos_der, f_channels, f_do_conv, &
          & f_do_freq_avg, f_frequency, f_molecules, f_moleculeDerivatives, &
          & f_signals, f_spect_der, f_temp_der /) ))) &
          & call AnnounceError (IrrelevantFwmParameter, root)
      case (l_linear)
        if (.not. all(got( (/f_molecules, f_signals/) ))) & ! Maybe others later
          & call AnnounceError (IncompleteLinearFwm, root)
        if (any(got( (/f_atmos_der, f_do_conv, f_do_freq_avg, f_frequency /) ))) &
          & call AnnounceError (IrrelevantFwmParameter, root)
      end select
      if (error /= 0) call MLSMessage(MLSMSG_Error, ModuleName, 'An error occured')
    end do ! i = 2, nsons(key)
d303 1
d363 10
a372 10
    type (VectorValue_T), pointer :: radiance ! Radiance quantity to be filled
    type (VectorValue_T), pointer :: temp ! Temperature quantity
    type (VectorValue_T), pointer :: ptan ! PTAN quantity
    type (VectorValue_T), pointer :: elevOffset ! Elevation offset quantity
    type (VectorValue_T), pointer :: orbIncline ! Orbital inclination (beta)
    type (VectorValue_T), pointer :: spaceRadiance ! Space radiance
    type (VectorValue_T), pointer :: earthRefl ! Earth reflectivity
    type (VectorValue_T), pointer :: refGPH ! Reference GPH, (zRef and hRef)
    type (VectorValue_T), pointer :: losVel ! Line of sight velocity
    type (VectorValue_T), pointer :: scGeocAlt ! Geocentric spacecraft altitude
d440 2
a441 1
    Real(r8), dimension(:), allocatable :: RadV, F_grid
d446 1
a446 1
    integer, pointer, dimension(:) :: Grids       ! Frq grid for each tan_press
d451 2
d462 1
a462 1
    radiance = GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
d508 2
d581 1
d587 1
a587 1
!   DO l = mmaf, mmaf                 ! ** DEBUG, only one mmaf
d589 1
a589 1
      phi_tan = FMC%phi_tan_mmaf(l)
a624 2
        if ( grids(ptg_i) == 0 ) cycle ! Skip tangent heights that don't have
        !                                a nearby pointing grid
d632 3
a634 1
        kk = FMI%no_ptg_frq(k)
d641 2
a642 2
          DEALLOCATE(RadV,F_grid,STAT=i)
          ALLOCATE(RadV(kk),F_grid(kk),STAT=ier)
d644 1
a644 1
            Print *,'** ALLOCATE Error: RadV or F_grid arrays, STAT =',ier
d710 12
a721 3
        Call get_beta_path(ptg_i,FMI%pfa_spectrum,no_ele,FMI%no_ptg_frq, &
       &     FMI%ptg_frq_grid,z_path(ptg_i,l),t_path(ptg_i,l),beta_path, &
       &     FMC%vel_z_mmaf(l),ier)
d732 1
a732 3
        RadV(1:kk) = 0.0
        F_grid(1:kk) = FMI%ptg_frq_grid(k)%values(1:kk)
!
d735 1
a735 1
          Frq = F_grid(frq_i)
d737 7
d776 2
a777 1
            Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i),  &
d798 1
a798 1
                  Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i), &
d826 1
a826 1
                      Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i), &
d868 1
a868 1
                        Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i), &
d1000 1
d1193 3
@


2.24
log
@Interim version
@
text
@d27 2
a28 2
  use Init_Tables_Module, only: L_EARTHREFL, L_ELEVOFFSET, L_FULL, L_LINEAR,&
    & L_LOSVEL, L_ORBITINCLINE, L_PTAN, L_RADIANCE, L_REFGPH, L_SCAN,&
d48 2
a49 1
  use VectorsModule, only: GetVectorQuantityByType, Vector_T, VectorValue_T
d67 1
a67 1
    & "$Id: ForwardModelInterface.f90,v 2.23 2001/03/17 21:08:01 livesey Exp $"
d488 1
a488 1
      & frequencyCoordinate=l_channel)) call MLSMessage(MLSMSG_Error, ModuleName, &
d491 1
a491 1
      & noChans=1)) call MLSMessage(MLSMSG_Error, ModuleName,&
d494 1
a494 1
      & frequencyCoordinate=l_none)) call MLSMessage(MLSMSG_Error, ModuleName, &
d496 2
a497 2
    if (.not. ValidateVectorQuantity(elevOffset, verticalCoordinate=l_none, &
      & frequencyCoordinate=l_none, noInstances=1) &
d1030 1
a1030 1
 99  if(io /= 0) then
d1169 3
@


2.23
log
@Added forward model type stuff to ForwardModelConfig_T and parser thereof
@
text
@d17 6
d24 1
a24 1
    F_FREQUENCY, F_MOLECULES, F_MOLECULEDERIVATIVES, F_SIGNALS, &
d26 7
a32 3
  use Init_Tables_Module, only: L_FULL, L_LINEAR, L_SCAN
  use Init_Tables_Module, only: F_POINTINGGRIDS, F_ZVI, field_indices, &
    & field_first, field_last, lit_indices, spec_indices
d48 1
a48 1
  use VectorsModule, only: Vector_T
d58 1
a58 1
    ForwardModelConfig_T, ForwardModelSignal_T
d66 1
a66 1
    & "$Id: ForwardModelInterface.f90,v 2.22 2001/03/17 03:24:23 vsnyder Exp $"
d72 1
a72 1
  type ForwardModelSignal_T
d75 1
a75 1
  end type ForwardModelSignal_T
d85 1
a85 1
    type (ForwardModelSignal_T), dimension(:), pointer :: signals=>NULL()
d149 1
a149 1
    type (ForwardModelSignal_T), pointer :: thisFWMSignal ! A signal
d210 1
a210 1
        if ( .not. associated( info%signals ) ) then
d214 1
a214 1
          thisFWMSignal => info%signals(noChannelsSpecs)
d253 1
a253 1
        allocate ( info%signals (nsons(son)-1), stat = status)
d256 1
a256 1
          info%signals(j)%signal = &
d259 2
a260 2
          thisSignal = GetSignal( info%signals(j)%signal )
          allocate ( info%signals(j)%channelIncluded( &
d268 1
a268 1
          info%signals(j)%channelIncluded = .true.
d355 16
d447 54
d526 1
a526 1
    signal = getSignal ( forwardModelConfig%signals(1)%signal )
d1068 2
a1069 2
        do signal = 1, size(database(config)%signals)
          deallocate(database(config)%signals(signal)%channelIncluded,stat=status)
d1073 1
a1073 1
        deallocate (database(config)%signals, stat=status)
a1086 1

d1124 1
a1124 1
        do j = 1, size(database(i)%signals)
d1126 1
a1126 1
          call GetSignalName( database(i)%signals(j)%signal, signalName)
d1128 1
a1128 1
          call dump ( database(i)%signals(j)%channelIncluded )
d1168 3
@


2.22
log
@Work on forwardModelGlobalSetup
@
text
@d19 2
a20 1
    F_SPECT_DER, F_TEMP_DER
d56 1
a56 1
    & "$Id: ForwardModelInterface.f90,v 2.21 2001/03/17 01:05:46 livesey Exp $"
d68 1
d87 3
d188 2
d267 21
d1077 6
d1089 3
@


2.21
log
@OK, I've sorted it out, but problems may remain in forwardmodelglobalsetup
@
text
@d20 2
a21 4
  use Init_Tables_Module, only: field_indices, field_first, field_last, &
    & lit_indices, spec_indices
!  use Init_Tables_Module, only: F_ATMOS_DER, F_DO_CONV, F_DO_FREQ_AVG, &
!    & F_EXTRAHEIGHTS, F_FREQUENCY, F_POINTINGGRIDS, F_SPECT_DER, F_TEMP_DER, &
d30 2
a31 2
    & Dump_Pointing_Grid_Database, ExtraHeights, Open_Pointing_Grid_File, &
    & Read_Pointing_Grid_File
d55 1
a55 1
    & "$Id: ForwardModelInterface.f90,v 2.20 2001/03/17 00:58:22 livesey Exp $"
d91 1
a91 1
  subroutine ForwardModelGlobalSetup ( Root, ForwardModelConfig )
d94 2
a95 4
    integer :: Root                     ! of the forwardModel specification.
                                        ! Indexes either a "named" or
                                        ! "spec_args" vertex.
    type(forwardModelConfig_T), intent(inout) :: ForwardModelConfig
a96 3
    integer :: Field                    ! Field index -- f_something
    integer :: I                        ! Subscript and loop inductor.
    integer :: Key                      ! Indexes the spec_args vertex.
a97 2
    integer :: Name                     ! sub_rosa of label of specification,
                                        ! if any, else zero.
a99 3
    integer :: Type                     ! Type of value returned by EXPR
    integer :: Units(2)                 ! Units of value returned by EXPR
    real (r8) :: Value(2)               ! Value returned by EXPR
a104 7
    if ( node_id(root) == n_named ) then
      name = subtree(1, root)
      key = subtree(2, root)
    else
      name = 0
      key = root
    end if
d106 1
a106 1
    ! "Key" now indexes an n_spec_args vertex.  See "Configuration file
d110 3
a112 7
    do i = 2, nsons(key)
      son = subtree(i,key)
      field = get_field_id(son)
      select case ( field )
        ! Shouldn't get here if the type checker worked
      end select
    end do ! i = 2, nsons(key)
d153 1
a153 1
    if ( toggle(gen) ) call trace_begin ( "ForwardModelSetup", root )
d262 1
a262 1
    if ( toggle(gen) ) call trace_end ( "ForwardModelSetup" )
d269 1
a269 1
    &                      Jacobian, RowBlock, FwdModelOut, FMC, FMI, TFMI )
d317 1
a317 1
    Integer(i4), PARAMETER :: ngt = (Ng+1) * N2lvl
d326 2
d383 7
a389 1
    Real(r8), DIMENSION(:), ALLOCATABLE :: RadV, F_grid
d414 19
a432 2
    Call ptg_frq_load(FMC, FMI, Ier)
    if(ier /= 0) goto 99
d508 7
a514 1
!
d930 1
a930 1
  ! ------------------------------------------- AddForwardModelConfigToDatabase --
d948 1
a948 1
  ! ------------------------------------------ DestroyForwardModelConfigDatabase --
d981 2
a982 2
  ! ------------------------------------------ DUMP_FOWARDMODELCONFIGS --
  subroutine Dump_ForwardModelConfigs(database)
d990 1
a990 1
    if (associated(database)) then
d1055 3
@


2.20
log
@Fixed bug in previous commit, have had to comment out line 139 to
let it compile.
@
text
@d20 2
a21 1
  use Init_Tables_Module, only: field_indices, field_first, field_last, lit_indices
d57 1
a57 1
    & "$Id: ForwardModelInterface.f90,v 2.19 2001/03/17 00:50:57 livesey Exp $"
d140 1
a140 1
    !call read_pointing_grid_file ( lun, spec_indices )
d1047 4
@


2.19
log
@New forwardModelConfig stuff and merge from Van
@
text
@d56 1
a56 1
    & "$Id: ForwardModelInterface.f90,v 2.17 2001/03/15 12:18:37 zvi Exp $"
a88 8
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter, private :: IdParm = &
    & "$Id: ForwardModelInterface.f90,v 2.18 2001/03/16 21:05:22 vsnyder Exp $"
  character (len=len(idParm)) :: Id = IdParm
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: ForwardModelInterface.f90,v $"
  !---------------------------------------------------------------------------

d139 1
a139 1
    call read_pointing_grid_file ( lun, spec_indices )
d1046 3
@


2.18
log
@Move dumping of pointing grid database to PointingGrid_m
@
text
@d13 3
d17 6
a22 4
  use Init_Tables_Module, only: field_first, field_last
  use Init_Tables_Module, only: F_ATMOS_DER, F_DO_CONV, F_DO_FREQ_AVG, &
    & F_EXTRAHEIGHTS, F_FREQUENCY, F_POINTINGGRIDS, F_SPECT_DER, F_TEMP_DER, &
    & SPEC_INDICES
d26 2
d36 1
a36 1
  use Tree, only: Node_ID, Nsons, Source_Ref, Sub_Rosa, Subtree
d46 7
a52 2
  public :: ForwardModel, ForwardModelGlobalSetup, ForwardModelInfo_T, &
    & ForwardModelSetup
d54 14
a67 1
  type ForwardModelInfo_T
d71 2
d74 1
d77 9
a85 1
  end type ForwardModelInfo_T
d91 1
a91 1
    & "$Id: ForwardModelInterface.f90,v 2.17 2001/03/15 12:18:37 zvi Exp $"
d100 1
a100 1
  subroutine ForwardModelGlobalSetup ( Root, ForwardModelInfo )
d106 1
a106 1
    type(forwardModelInfo_T), intent(inout) :: ForwardModelInfo
d118 1
a118 1
    double precision :: Value(2)        ! Value returned by EXPR
a139 20
      case ( f_atmos_der )
        forwardModelInfo%atmos_der = get_boolean(son)
      case ( f_do_conv )
        forwardModelInfo%do_conv = get_boolean(son)
      case ( f_do_freq_avg )
        forwardModelInfo%do_freq_avg = get_boolean(son)
      case ( f_extraHeights )
        call expr ( subtree(2,son), units, value, type )
        extraHeights = value(1)
      case ( f_frequency )
        call expr ( subtree(2,son), units, value, type )
        forwardModelInfo%the_freq = value(1)
      case ( f_pointingGrids )
        call get_string ( sub_rosa(subtree(2,son)), pointingGridsFile, &
          & strip=.true. )
      case ( f_spect_der )
        forwardModelInfo%spect_der = get_boolean(son)
      case ( f_temp_der )
        forwardModelInfo%temp_der = get_boolean(son)
      case default
d153 4
a156 4
  ! ------------------------------------------  ForwardModelSetup  -----
  subroutine ForwardModelSetup ( Root, VectorDatabase, MatrixDatabase, &
    &                            ForwardModelInfo )
  ! Process the forwardModel specification to produce ForwardModelInfo.
d158 1
a158 1
    integer :: Root                     ! of the forwardModel specification.
d161 1
a161 3
    type(vector_T), dimension(:), intent(inout), target :: VectorDatabase
    type(matrix_Database_T), dimension(:), pointer :: MatrixDatabase
    type(forwardModelInfo_T), intent(inout) :: ForwardModelInfo
d163 2
d168 1
d172 1
d174 5
d191 8
d200 2
d209 2
d213 74
d290 1
d293 1
a293 2

  end subroutine ForwardModelSetup
d296 1
a296 1
! subroutine ForwardModel ( FwdModelInfo, FwdModelExtra, FwdModelIn, &
d298 1
a298 1
  subroutine ForwardModel ( FwdModelInfo, FwdModelExtra, FwdModelIn, &
d330 1
a330 1
    type(forwardModelInfo_T), intent(in) :: FwdModelInfo ! From ForwardModelSetup
d415 8
d929 50
d980 46
d1030 1
a1030 1
    integer, intent(in) :: FieldIndex ! f_...
d1037 11
d1050 1
d1054 3
@


2.17
log
@Adding the velocity effect on line center frequency
@
text
@d16 2
a17 1
    & F_FREQUENCY, F_SPECT_DER, F_TEMP_DER
d23 4
a26 1
  use String_Table, only: Display_String
d29 1
a29 1
  use Tree, only: Node_ID, Nsons, Source_Ref, Subtree
d55 1
a55 1
    & "$Id: ForwardModelInterface.f90,v 2.16 2001/03/13 00:43:12 zvi Exp $"
d75 1
d78 1
d98 1
d110 3
d116 3
d127 7
d829 3
@


2.16
log
@*** empty log message ***
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.15 2001/03/13 00:23:41 zvi Exp $"
d456 2
a457 1
       &     FMI%ptg_frq_grid,z_path(ptg_i,l),t_path(ptg_i,l),beta_path,ier)
d809 3
@


2.15
log
@Correction to no_tan_hts for hydrostatic_model repeating calls
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.14 2001/03/09 02:46:15 vsnyder Exp $"
d735 1
d808 3
@


2.14
log
@Make sure "io" has a value
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.13 2001/03/09 02:27:20 zvi Exp $"
d222 1
a222 1
                   frq_i, io, klo, jj, l, n, brkpt, no_ele, mid, ilo, ihi, &
d313 1
d316 1
a316 1
         FMC%no_tan_hts,geoc_lat,TFMI%Href,TFMI%Zref,FMI%z_grid,thbs, &
a321 6
    jj = -1
    Zeta = -1.666667
    no_tan_hts = FMC%no_tan_hts
    Call Hunt(Zeta,FMI%tan_press,no_tan_hts,jj,i)
    IF(ABS(Zeta-FMI%tan_press(i)) < ABS(Zeta-FMI%tan_press(jj))) jj = i
!
d807 3
@


2.13
log
@*** empty log message ***
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.12 2001/03/09 01:49:31 zvi Exp $"
d286 1
d812 3
@


2.12
log
@*** empty log message ***
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.11 2001/03/09 01:08:07 zvi Exp $"
d737 2
d752 1
d811 3
@


2.11
log
@*** empty log message ***
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.10 2001/03/09 00:54:00 zvi Exp $"
d271 1
a271 1
    Type(path_beta), DIMENSION(:,:), POINTER :: beta_path
d808 3
@


2.10
log
@*** empty log message ***
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.9 2001/03/08 21:59:52 vsnyder Exp $"
d340 1
d808 3
@


2.9
log
@Mostly just cosmetic rearranging
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.8 2001/03/08 20:11:19 zvi Exp $"
d320 1
d807 3
@


2.8
log
@*** empty log message ***
@
text
@d50 3
a52 2
  character (len=130), private :: Id = &
    & "$Id: ForwardModelInterface.f90,v 2.7 2001/03/08 19:22:12 zvi Exp $"
d169 1
a169 1
 Subroutine ForwardModel ( FwdModelInfo, FwdModelExtra, FwdModelIn, &
d174 24
a197 24
  use GL6P, only: NG
  use MLSCommon, only: I4, R4, R8
  use L2_TEST_STRUCTURES_M
  use L2PC_FILE_PARAMETERS, only: mxco => MAX_NO_ELMNTS_PER_SV_COMPONENT
  use L2PC_PFA_STRUCTURES, only: K_MATRIX_INFO
  use L2PCdim, only: Nlvl, N2lvl, NSPS, Nptg, NCH, MNP => max_no_phi, &
                     MNM => max_no_mmaf
  use ELLIPSE, only: PHI_TAN, ROC
  use L2_LOAD_M, only: L2_LOAD
  use PTG_FRQ_LOAD_M, only: PTG_FRQ_LOAD
  use COMP_PATH_ENTITIES_M, only: COMP_PATH_ENTITIES
  use REFRACTION_M, only: REFRACTION_CORRECTION
  use PATH_ENTITIES_M, only: PATH_INDEX, PATH_VECTOR, PATH_BETA, &
                             PATH_DERIVATIVE
  use HYDROSTATIC_MODEL_M, only: HYDROSTATIC_MODEL
  use GET_CHI_ANGLES_M, only: GET_CHI_ANGLES
  use GET_BETA_PATH_M, only: GET_BETA_PATH
  use GEOC_GEOD_CONV_M, only: GEOC_GEOD_CONV
  use RAD_TRAN_M, only: RAD_TRAN
! use RAD_TRAN_WD_M, only: RAD_TRAN_WD
  use FREQ_AVG_M, only: FREQ_AVG
  use CONVOLVE_ALL_M, only: CONVOLVE_ALL
  use NO_CONV_AT_ALL_M, only: NO_CONV_AT_ALL
  use D_HUNT_M, only: HUNT
d201 6
a206 6
 type(forwardModelInfo_T), intent(in) :: FwdModelInfo ! From ForwardModelSetup
 type(vector_T), intent(in) :: FwdModelExtra, FwdModelIn ! ???
 type(matrix_T), intent(inout), optional :: Jacobian
 integer, intent(in), optional :: RowBlock          ! With which block of
 ! rows of F and Jacobian are we computing? All of them if absent.
 type(vector_T), intent(inout), optional :: FwdModelOut  ! Radiances, etc.
d209 5
a213 5
  type(fwd_mdl_config), optional :: FMC
! type(fwd_mdl_info), dimension(:), pointer, optional :: FMI
  type(fwd_mdl_info),                        optional :: FMI
! type(temporary_fwd_mdl_info), dimension(:), pointer, optional :: TFMI
  type(temporary_fwd_mdl_info),                        optional :: TFMI
d218 1
a218 1
Integer(i4), PARAMETER :: ngt = (Ng+1) * N2lvl
d220 4
a223 4
Integer(i4) :: i, j, k, kk, kz, ht_i, mnz, no_tan_hts, ch, Spectag, &
               m, prev_npf, ier, mmaf, si, ptg_i, &
               frq_i, io, klo, jj, l, n, brkpt, no_ele, mid, ilo, ihi, &
               k_info_count, gl_count, ld
d225 1
a225 1
Integer(i4) :: ch1, ch2, no_pfa_ch, pfa_ch(2)
d227 4
a230 4
Type(path_index)  :: ndx_path(Nptg,mnm)
Type(path_vector) :: z_path(Nptg,mnm),t_path(Nptg,mnm),h_path(Nptg,mnm),  &
                     dhdz_path(Nptg,mnm), spsfunc_path(Nsps,Nptg,mnm),    &
                     n_path(Nptg,mnm),phi_path(Nptg,mnm)
d232 1
a232 1
Type(path_derivative) :: dh_dt_path(Nptg,mnm)
d234 3
a236 3
Real(r8) :: thbs(10),elev_offset
Real(r8) :: t_script(N2lvl),ref_corr(N2lvl,Nptg),tau(N2lvl), &
            tan_dh_dt(Nlvl,mnm,mxco)
d238 1
a238 1
Real(r8) :: dx_dt(Nptg,mxco), d2x_dxdt(Nptg,mxco)
d240 2
a241 2
Real(r8) :: h_glgrid(ngt,mnm), t_glgrid(ngt,mnm), z_glgrid(ngt/2)
Real(r8) :: dh_dt_glgrid(ngt,mnm,mxco), dhdz_glgrid(ngt,mnp)
d243 2
a244 2
Real(r8) :: ptg_angles(Nptg,mnm), center_angle
Real(r8) :: tan_hts(Nptg,mnm), tan_temp(Nptg,mnm)
d247 5
a251 5
! Real(r4) :: K_TEMP(Nch,Nptg,mxco,mnp)
! Real(r4) :: K_ATMOS(Nch,Nptg,mxco,mnp,Nsps)
! Real(r4) :: K_SPECT_DW(Nch,Nptg,mxco,mnp,Nsps),  &
!             K_SPECT_DN(Nch,Nptg,mxco,mnp,Nsps),  &
!             K_SPECT_DNU(Nch,Nptg,mxco,mnp,Nsps)
d256 25
a280 5
Real(r4) :: K_TEMP(02,Nptg,mxco,mnp)
Real(r4) :: K_ATMOS(02,Nptg,mxco,mnp,Nsps)
Real(r4) :: K_SPECT_DW(02,Nptg,mxco,mnp,Nsps),  &
            K_SPECT_DN(02,Nptg,mxco,mnp,Nsps),  &
            K_SPECT_DNU(02,Nptg,mxco,mnp,Nsps)
d282 1
a282 21
real(r8) :: I_STAR_ALL(Nch,Nptg)

real(r4) :: K_STAR_ALL(02,20,mxco,mnp,Nptg)      ! 02 should be: Nch
Type(k_matrix_info) :: k_star_info(20)

Type(path_derivative) :: k_temp_frq, k_atmos_frq(Nsps), &
                         k_spect_dw_frq(Nsps), k_spect_dn_frq(Nsps), &
                         k_spect_dnu_frq(Nsps)
!
Type(path_beta), DIMENSION(:,:), POINTER :: beta_path

Real(r8) :: Radiances(Nptg,Nch)
Real(r8) :: e_rad, Zeta, Frq, h_tan, Rad, geoc_lat, r
!
Character (LEN=01) :: CA
Character (LEN=08) :: Name
Character (LEN=16) :: Vname
Character (LEN=80) :: Line
Character (LEN=40) :: Ax, Dtm1, Dtm2

Real(r8), DIMENSION(:), ALLOCATABLE :: RadV, F_grid
d286 6
a291 6
  ch1 = FMC%Channels_range(1)
  ch2 = FMC%Channels_range(2)
  no_pfa_ch = min(2,ch2-ch1+1)
  do i = 1, no_pfa_ch
    pfa_ch(i) = ch1 + i - 1
  end do
d293 1
a293 1
  elev_offset = 0.0                         ! Zero elev_offset in any case
d298 2
a299 2
  Call ptg_frq_load(FMC, FMI, Ier)
  if(ier /= 0) goto 99
d304 3
a306 3
  mmaf = 3                     ! Do only this mmaf (middle phi)
  phi_tan = FMC%phi_tan_mmaf(mmaf)
  Call geoc_geod_conv(TFMI%beta_inc,phi_tan,geoc_lat,E_rad)
d310 14
a323 14
  thbs(1:) = 0.0
  si = FMI%Surface_index
  thbs(1:si-1) = FMI%Tan_hts_below_surface(1:si-1)
  Call hydrostatic_model(si,FMC%N_lvls,TFMI%no_t,FMC%no_mmaf,FMC%t_indx, &
       FMC%no_tan_hts,geoc_lat,TFMI%Href,TFMI%Zref,FMI%z_grid,thbs, &
       TFMI%t_zeta_basis, TFMI%t_coeff, z_glgrid, h_glgrid, t_glgrid, &
       dhdz_glgrid,dh_dt_glgrid,FMI%tan_press,tan_hts,tan_temp,tan_dh_dt, &
       gl_count, Ier)
  IF(ier /= 0) goto 99
!
  Zeta = -1.666667
  no_tan_hts = FMC%no_tan_hts
  Call Hunt(Zeta,FMI%tan_press,no_tan_hts,jj,i)
  IF(ABS(Zeta-FMI%tan_press(i)) < ABS(Zeta-FMI%tan_press(jj))) jj = i
d327 9
a335 9
  Call comp_path_entities(FMC%n_lvls,TFMI%no_t,gl_count,ndx_path, &
       z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid,dh_dt_glgrid,        &
       TFMI%atmospheric,TFMI%f_zeta_basis,TFMI%mr_f,            &
       TFMI%no_coeffs_f,tan_hts,no_tan_hts,FMI%n_sps,             &
       TFMI%no_phi_f,TFMI%f_phi_basis,z_path,h_path,t_path,      &
       phi_path,n_path,dhdz_path,dh_dt_path,TFMI%no_phi_t,        &
       TFMI%t_phi_basis,spsfunc_path,TFMI%is_f_log,FMC%no_mmaf,  &
       FMC%phi_tan_mmaf,Ier)
  IF(ier /= 0) goto 99
d339 2
a340 2
! DO l = 1, FMC%no_mmaf
! DO l = mmaf, mmaf                 ! ** DEBUG, only one mmaf
d342 1
a342 1
    phi_tan = FMC%phi_tan_mmaf(l)
d344 2
a345 2
    TFMI%t_phi_basis(1:TFMI%no_phi_t) = &
                    TFMI%T_PHI_BASIS_COPY(1:TFMI%no_phi_t) + phi_tan
d347 4
a350 4
    DO j = 1, FMI%n_sps
      k = TFMI%no_phi_f(j)
      TFMI%f_phi_basis(1:k,j) = TFMI%F_PHI_BASIS_COPY(1:k,j) + phi_tan
    end do
d352 5
a356 5
    k = FMI%mfi + 2
    do j = 1, FMI%no_spectro
      FMI%spectroscopic(j)%PHI_BASIS(1:k) = &
     &                TFMI%S_PHI_BASIS_COPY(1:k,j) + phi_tan
    end do
d361 5
a365 5
    Call get_chi_angles(ndx_path(1:,l),n_path(1:,l),FMI%tan_press,         &
   &     tan_hts(1:,l),tan_temp(1:,l),phi_tan,RoC,TFMI%h_obs,elev_offset, &
   &     tan_dh_dt(1:,l,1:),no_tan_hts,TFMI%no_t,TFMI%t_zeta_basis,si,   &
   &     center_angle,ptg_angles(1:,l),dx_dt,d2x_dxdt,ier)
    IF(ier /= 0) goto 99
d369 2
a370 2
    Call refraction_correction(no_tan_hts, tan_hts(1:,l), h_path(1:,l), &
   &                n_path(1:,l), ndx_path(1:,l), E_rad, ref_corr)
d372 2
a373 2
    prev_npf = -1
    Radiances(1:Nptg,1:Nch) = 0.0
d377 1
a377 1
    DO ptg_i = 1, no_tan_hts-1
d379 8
a386 15
      k = ptg_i
      h_tan = tan_hts(k,l)
      kk = FMI%no_ptg_frq(k)
!
      if(kk /= prev_npf) then
!
        prev_npf = kk
        DEALLOCATE(k_temp_frq%values,STAT=i)
!
        DEALLOCATE(RadV,F_grid,STAT=i)
        ALLOCATE(RadV(kk),F_grid(kk),STAT=ier)
        IF(ier /= 0) then
          Print *,'** ALLOCATE Error: RadV or F_grid arrays, STAT =',ier
          goto 99
        endif
d388 6
a393 6
        do j = 1, FMI%n_sps
          DEALLOCATE(k_atmos_frq(j)%values,STAT=i)
          DEALLOCATE(k_spect_dw_frq(j)%values,STAT=i)
          DEALLOCATE(k_spect_dn_frq(j)%values,STAT=i)
          DEALLOCATE(k_spect_dnu_frq(j)%values,STAT=i)
        end do
d395 6
a400 5
        ALLOCATE(k_temp_frq%values(kk,TFMI%no_t,TFMI%no_phi_t),STAT=ier)
        IF(ier /= 0) then
          Print *,'** ALLOCATE Error: k_temp_frq array, STAT =',ier
          goto 99
        endif
d402 1
a402 4
        do j = 1, FMI%n_sps
          m = max(1,TFMI%no_phi_f(j))
          i = max(1,TFMI%no_coeffs_f(j))
          ALLOCATE(k_atmos_frq(j)%values(kk,i,m),STAT=ier)
d404 1
a404 1
            Print *,'** ALLOCATE Error: k_atmos_frq, STAT =',ier
a406 1
        end do
d408 4
a411 25
        do m = 1, FMI%n_sps
          j = FMI%spect_atmos(m)
          if(j < 1) CYCLE
          if(.not. FMI%spectroscopic(j)%DER_CALC(FMI%band)) CYCLE
          Vname(1:) = ' '
          Spectag = FMI%spectroscopic(j)%Spectag
          DO
            if(FMI%spectroscopic(j)%Spectag /= Spectag) EXIT
            n = FMI%spectroscopic(j)%no_phi_values
            i = FMI%spectroscopic(j)%no_zeta_values
            CA = FMI%spectroscopic(j)%type
            select case ( CA )
              case ( 'W' )
                Vname = 'k_spect_dw_frq'
                ALLOCATE(k_spect_dw_frq(m)%values(kk,i,n),STAT=ier)
              case ( 'N' )
                Vname = 'k_spect_dn_frq'
                ALLOCATE(k_spect_dn_frq(m)%values(kk,i,n),STAT=ier)
              case ( 'V' )
                Vname = 'k_spect_dnu_frq'
                ALLOCATE(k_spect_dnu_frq(m)%values(kk,i,n),STAT=ier)
              case default
                Ier = -99
                Print *,'** Unknown Spectroscopic element !'
            end select
d413 1
a413 1
              Print *,'** ALLOCATE Error: ',Vname,', STAT =',ier
d415 36
a450 5
            ENDIF
            j = j + 1
            if(j > 3 * FMI%n_sps) EXIT
          END DO
        end do
d452 1
a452 1
      endif            ! On DEALLOCATE/ALLOCATE cycle
d456 4
a459 4
      no_ele = ndx_path(ptg_i,l)%total_number_of_elements
      Call get_beta_path(ptg_i,FMI%pfa_spectrum,no_ele,FMI%no_ptg_frq, &
     &     FMI%ptg_frq_grid,z_path(ptg_i,l),t_path(ptg_i,l),beta_path,ier)
      IF(ier /= 0) goto 99
d461 7
a467 7
      k_temp_frq%values = 0.0
      do j = 1, FMI%n_sps
        k_atmos_frq(j)%values = 0.0
        k_spect_dw_frq(j)%values = 0.0
        k_spect_dn_frq(j)%values = 0.0
        k_spect_dnu_frq(j)%values = 0.0
      end do
d469 2
a470 2
      RadV(1:kk) = 0.0
      F_grid(1:kk) = FMI%ptg_frq_grid(k)%values(1:kk)
d472 1
a472 1
      do frq_i = 1, kk
d474 1
a474 1
        Frq = F_grid(frq_i)
d476 6
a481 6
        Call Rad_Tran(Frq, FMC%N_lvls, h_tan, FMI%n_sps, ndx_path(k,l),  &
       &    z_path(k,l), h_path(k,l), t_path(k,l), phi_path(k,l),&
       &    dHdz_path(k,l), TFMI%earth_ref, beta_path(1:,frq_i),      &
       &    spsfunc_path(1:,k,l), ref_corr(1:,k), TFMI%s_temp, brkpt, &
       &    no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier)
        IF(ier /= 0) goto 99
d483 1
a483 1
        RadV(frq_i) = Rad
d487 13
a499 13
!       CALL Rad_Tran_WD(frq_i,FMI%band,Frq,FMC%N_lvls,FMI%n_sps, &
!      &     FMC%temp_der,FMC%atmos_der,FMC%spect_der,            &
!      &     z_path(k,l),h_path(k,l),t_path(k,l),phi_path(k,l),   &
!      &     dHdz_path(k,l),TFMI%atmospheric,beta_path(1:,frq_i),&
!      &     spsfunc_path(1:,k,l),TFMI%t_zeta_basis,  &
!      &     TFMI%f_zeta_basis,TFMI%no_coeffs_f,   &
!      &     TFMI%mr_f,TFMI%no_t,ref_corr(1:,k),TFMI%no_phi_f,       &
!      &     TFMI%f_phi_basis,TFMI%no_phi_t,TFMI%t_phi_basis,  &
!      &     dh_dt_path(k,l),FMI%spect_atmos,         &
!      &     FMI%spectroscopic,k_temp_frq,k_atmos_frq,k_spect_dw_frq,   &
!      &     k_spect_dn_frq,k_spect_dnu_frq,TFMI%is_f_log,brkpt,       &
!      &     no_ele,mid,ilo,ihi,t_script,tau,ier)
!       IF(ier /= 0) goto 99
d501 1
a501 1
      end do
d505 10
a514 10
      do i = 1, no_pfa_ch
        ch = pfa_ch(i)
        if(FMC%do_frqavg) then
          Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i),  &
         &     FMI%Filter_func(1:,i),RadV,kk,FMI%no_filt_pts, &
         &     Radiances(ptg_i,ch))
        else
          Radiances(ptg_i,ch) = RadV(1)
        endif
      end do
d516 1
a516 1
      if(FMC%temp_der) then
d521 16
a536 15
        RadV(1:kk) = 0.0
        do i = 1, no_pfa_ch
!         ch = pfa_ch(i)
          ch = i               ! ** DEBUG, memory limitations on MLSGATE
          do j = 1, TFMI%no_phi_t
            do k = 1, TFMI%no_t
              if(FMC%do_frqavg) then
                RadV(1:kk) = k_temp_frq%values(1:kk,k,j)
                Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i), &
               &              FMI%Filter_func(1:,i),          &
               &              RadV,kk,FMI%no_filt_pts,r)
              else
                r = k_temp_frq%values(1,k,j)
              endif
              k_temp(ch,ptg_i,k,j) = r
a538 1
        end do
d540 1
a540 1
      endif
d542 1
a542 1
      if(FMC%atmos_der) then
d547 18
a564 17
        do i = 1, no_pfa_ch
!         ch = pfa_ch(i)
          ch = i                 ! ** DEBUG, memory limitations on MLSGATE
          do j = 1, FMI%n_sps
            if(TFMI%atmospheric(j)%der_calc(FMI%band)) THEN
              RadV(1:kk) = 0.0
              do k = 1, TFMI%no_phi_f(j)
                do n = 1, TFMI%no_coeffs_f(j)
                  if(FMC%do_frqavg) then
                    RadV(1:kk) = k_atmos_frq(j)%values(1:kk,n,k)
                    Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i), &
                   &              FMI%Filter_func(1:,i),          &
                   &              RadV,kk,FMI%no_filt_pts,r)
                  else
                    r = k_atmos_frq(j)%values(1,n,k)
                  endif
                  k_atmos(ch,ptg_i,n,k,j) = r
d566 2
a567 2
              end do
            endif
a568 1
        end do
d570 1
a570 1
      endif
d572 1
a572 1
      if(FMC%spect_der) then
d577 69
a645 3
        do i = 1, no_pfa_ch
!         ch = pfa_ch(i)
          ch = i                 ! ** DEBUG, memory limitations on MLSGATE
d649 1
a649 1
            Spectag = FMI%spectroscopic(j)%Spectag
d652 5
a656 29
              RadV(1:kk) = 0.0
              CA = FMI%spectroscopic(j)%type
              do k = 1, FMI%spectroscopic(j)%no_phi_values
                do n = 1, FMI%spectroscopic(j)%no_zeta_values
                  select case ( CA )
                    case ( 'W' )
                      RadV(1:kk) = k_spect_dw_frq(m)%values(1:kk,n,k)
                    case ( 'N' )
                      RadV(1:kk) = k_spect_dn_frq(m)%values(1:kk,n,k)
                    case ( 'V' )
                      RadV(1:kk) = k_spect_dnu_frq(m)%values(1:kk,n,k)
                  end select
                  if(FMC%do_frqavg) then
                      Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i), &
                   &              FMI%Filter_func(1:,i),&
                   &              RadV,kk,FMI%no_filt_pts,r)
                  else
                    r = RadV(1)
                  endif
                  select case ( CA )
                    case ( 'W' )
                      k_spect_dw(ch,ptg_i,n,k,j) = r
                    case ( 'N' )
                      k_spect_dn(ch,ptg_i,n,k,j) = r
                    case ( 'V' )
                      k_spect_dnu(ch,ptg_i,n,k,j) = r
                  end select
                end do
              end do
d661 2
a662 1
        end do
d664 1
a664 1
      endif
d666 1
a666 1
    END DO              ! Pointing Loop
d668 1
a668 38
! Complete the radiances's last location, also  complete k_temp last
! location as well as k_atmos last location and k_spect_d? last location:
!
    kk = no_tan_hts
    do i = 1, no_pfa_ch
      ch = pfa_ch(i)
      Radiances(kk,ch) = Radiances(kk-1,ch)
      if(FMC%temp_der) then
        k_temp(i,kk,1:TFMI%no_t,1:TFMI%no_phi_t) = &
     &              k_temp(i,kk-1,1:TFMI%no_t,1:TFMI%no_phi_t)
      endif
      if(FMC%atmos_der) then
        do m = 1, FMI%n_sps
          if(TFMI%atmospheric(m)%der_calc(FMI%band)) then
            k = TFMI%no_phi_f(m)
            n = TFMI%no_coeffs_f(m)
            k_atmos(i,kk,1:n,1:k,m)=k_atmos(i,kk-1,1:n,1:k,m)
          endif
        end do
      endif
      if(FMC%spect_der) then
        do m = 1, FMI%n_sps
          j = FMI%spect_atmos(m)
          if(.not.  FMI%spectroscopic(j)%DER_CALC(FMI%band)) CYCLE
          Spectag =  FMI%spectroscopic(j)%Spectag
          DO
            if(FMI%spectroscopic(j)%Spectag /= Spectag) EXIT
            k = FMI%spectroscopic(j)%no_phi_values
            n = FMI%spectroscopic(j)%no_zeta_values
            k_spect_dw(i,kk,1:n,1:k,j)=k_spect_dw(i,kk-1,1:n,1:k,j)
            k_spect_dn(i,kk,1:n,1:k,j)=k_spect_dn(i,kk-1,1:n,1:k,j)
            k_spect_dnu(i,kk,1:n,1:k,j)=k_spect_dnu(i,kk-1,1:n,1:k,j)
            j = j + 1
            if(j > 3 * FMI%n_sps) EXIT
          END DO
        end do
      endif
    end do
d670 1
a670 1
!  Here comes the Convolution code
d672 12
a683 1
    DO i = 1, no_pfa_ch
d685 1
a685 1
      ch = pfa_ch(i)
d687 10
a696 1
      if(FMC%do_conv) then
d698 1
a698 12
        Call convolve_all(TFMI%ptg_press,TFMI%atmospheric,FMI%n_sps,   &
       &     FMC%temp_der,FMC%atmos_der,FMC%spect_der,                   &
       &     FMI%tan_press,ptg_angles(1:,l),tan_temp(1:,l), &
       &     dx_dt, d2x_dxdt,FMI%band,center_angle,FMI%fft_pts,          &
       &     Radiances(1:,ch),k_temp(i,1:,1:,1:),k_atmos(i,1:,1:,1:,1:), &
       &     k_spect_dw(i,1:,1:,1:,1:),k_spect_dn(i,1:,1:,1:,1:),    &
       &     k_spect_dnu(i,1:,1:,1:,1:),FMI%spect_atmos,no_tan_hts,  &
       &     k_info_count,i_star_all(i,1:),k_star_all(i,1:,1:,1:,1:), &
       &     k_star_info,TFMI%no_t,TFMI%no_phi_t,TFMI%no_phi_f,   &
       &     FMI%spectroscopic,TFMI%t_zeta_basis,FMI%Xlamda,FMI%Aaap,&
       &     FMI%D1Aaap,FMI%D2Aaap,FMI%Ias,ier)
        IF(ier /= 0) goto 99
d700 1
a700 1
      else
d702 1
a702 10
        Call no_conv_at_all(TFMI%ptg_press,FMI%n_sps,FMI%tan_press, &
       &     FMI%band,FMC%temp_der,FMC%atmos_der,FMC%spect_der,      &
       &     Radiances(1:,ch),k_temp(i,1:,1:,1:),                    &
       &     k_atmos(i,1:,1:,1:,1:),k_spect_dw(i,1:,1:,1:,1:),       &
       &     k_spect_dn(i,1:,1:,1:,1:),k_spect_dnu(i,1:,1:,1:,1:),   &
       &     FMI%spect_atmos, no_tan_hts,k_info_count,               &
       &     i_star_all(i,1:), k_star_all(i,1:,1:,1:,1:),            &
       &     k_star_info,TFMI%no_t,TFMI%no_phi_t,                  &
       &     TFMI%no_phi_f,TFMI%t_zeta_basis,TFMI%atmospheric,    &
       &     FMI%spectroscopic)
d704 7
d712 1
a712 14
!
    END DO
!
! END DO                ! Mmaf Loop
!
  if(FMC%temp_der) DEALLOCATE(k_temp_frq%values,STAT=i)
  do j = 1, FMI%n_sps
    if(FMC%atmos_der) DEALLOCATE(k_atmos_frq(j)%values,STAT=i)
    if(FMC%spect_der) then
      DEALLOCATE(k_spect_dw_frq(j)%values,STAT=i)
      DEALLOCATE(k_spect_dn_frq(j)%values,STAT=i)
      DEALLOCATE(k_spect_dnu_frq(j)%values,STAT=i)
    endif
  end do
d782 1
a782 1
     endif
d784 1
a784 1
   Return
d806 3
@


2.7
log
@New ForwardModelInterface with Zvi's code in it ..
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.6 2001/03/08 03:23:45 vsnyder Exp $"
d209 4
a212 2
  type(fwd_mdl_info), dimension(:), pointer, optional :: FMI
  type(temporary_fwd_mdl_info), dimension(:), pointer, optional :: TFMI
d217 2
d805 3
@


2.6
log
@More stuff to work with L2_Load
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.5 2001/03/08 00:42:09 vsnyder Exp $"
d168 38
a205 8
  subroutine ForwardModel ( FwdModelInfo, FwdModelExtra, FwdModelIn, &
    &                       Jacobian, RowBlock, FwdModelOut, FMC, FMI, TFMI )
    type(forwardModelInfo_T), intent(in) :: FwdModelInfo ! From ForwardModelSetup
    type(vector_T), intent(in) :: FwdModelExtra, FwdModelIn ! ???
    type(matrix_T), intent(inout), optional :: Jacobian
    integer, intent(in), optional :: RowBlock          ! With which block of
    ! rows of F and Jacobian are we computing? All of them if absent.
    type(vector_T), intent(inout), optional :: FwdModelOut  ! Radiances, etc.
d213 569
d801 3
@


2.5
log
@Add temporary stuff to use with L2_Load
@
text
@d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.4 2001/03/07 23:59:52 vsnyder Exp $"
d126 1
a126 1
    type(forwardModelInfo_T), intent(out) :: ForwardModelInfo
d202 3
@


2.4
log
@Add stuff for SIDS.
@
text
@d29 4
d51 1
a51 1
    & "$Id: ForwardModelInterface.f90,v 2.3 2001/02/21 00:07:57 vsnyder Exp $"
d166 2
d169 1
a169 1
    &                       Jacobian, RowBlock, FwdModelOut )
d176 7
d202 3
@


2.3
log
@Periodic commit.  Still needs a lot of work.
@
text
@d13 4
a16 1
  use Init_Tables_Module, only: field_first, field_indices, field_last
d19 2
d25 1
a25 2
  use Tree, only: Decorate, Decoration, Node_ID, Nsons, Source_Ref, Sub_Rosa, &
    & Subtree
d31 2
a32 1
  public :: ForwardModel, ForwardModelInfo_T, ForwardModelSetup
d35 6
a40 1
    integer :: Foo !??? Just because the compiler insists
d43 2
d47 1
a47 1
    & "$Id: ForwardModelInterface.f90,v 2.2 2001/02/08 00:56:11 vsnyder Exp $"
d54 58
a123 1
    integer :: Error                    ! Error level seen so far
d150 1
a150 1
      field = decoration(subtree(1,son))
a158 16
    contains
    ! --------------------------------------------  AnnounceError  -----
    subroutine AnnounceError ( Code, FieldIndex )
      integer, intent(in) :: Code       ! Index of error message
      integer, intent(in) :: FieldIndex ! f_...

      integer :: Source

      error = max(error,1)
      source = source_ref ( son )
      call output ( '***** At ' )
      call print_source ( source_ref(son) )
      call output ( ' ForwardModelSetup complained: ' )
      select case ( code )
      end select
    end subroutine AnnounceError
d162 2
a163 2
  subroutine ForwardModel ( FwdModelInfo, FwdModelIn, Jacobian, F, RowBlock, &
    &                       FwdModelOut )
d165 1
a165 1
    type(vector_T), intent(in) :: FwdModelIn           ! ???
a166 1
    type(vector_T), intent(in), optional :: F          ! Computed radiances
d169 1
a169 1
    type(vector_T), intent(inout), optional :: FwdModelOut  ! ???
d172 14
d189 3
@


2.2
log
@Periodic commit.  Still needs a lot of work.
@
text
@d14 1
d35 1
a35 1
    & "$Id: ForwardModelInterface.f90,v 2.1 2001/02/07 00:52:27 vsnyder Exp $"
a63 1
    integer, parameter :: Twice = 1     ! A field appears twice
a81 1
      if ( got(field) ) call announceError ( twice, field )
d100 2
a101 4
      call output ( 'At line '  )
      call output ( mod(source,256) )
      call output ( ', column ' )
      call output ( source/256 )
a103 4
      case ( twice )
        call output ( 'the field ' )
        call display_string ( field_indices(fieldIndex) )
        call output ( ' shall not appear twice.', advance='yes' )
d123 3
@


2.1
log
@Initial commit
@
text
@d34 1
a34 1
    & "$Id: RetrievalModule.f90,v 2.2 2001/01/26 19:01:47 vsnyder Exp $"
d36 1
a36 1
    & "$RCSfile: RetrievalModule.f90,v $"
d81 1
a81 1
      field = decoration(subtree(1,decoration(subtree(1,son))))
d129 4
a132 1
! $Log: $
@

