head	2.24;
access;
symbols
	V1-43:2.20
	V1-32:2.19
	V1-31:2.19
	V1-30:2.19
	V1-13:2.15
	V1-12:2.15
	V1-11:2.15
	V1-10:2.15
	newfwm-feb03:2.15.0.2
	V1-04:2.12
	V1-03:2.12
	V1-02:2.12
	JointForwardModel:2.12.0.2
	V1-00:2.12
	newfwm-sep01:2.11.0.2
	V0-7:2.11
	V0-5-Level2:2.10
	V0-5-SIPS:2.9;
locks; strict;
comment	@# @;


2.24
date	2004.05.19.19.41.22;	author vsnyder;	state dead;
branches;
next	2.23;

2.23
date	2004.05.19.19.16.12;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2004.05.18.01.16.57;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2004.05.18.01.07.33;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2004.05.01.04.03.47;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2003.08.27.20.06.16;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2003.08.26.18.04.52;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2003.06.20.19.37.06;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2003.05.05.23.00.34;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2002.11.06.00.19.49;	author pwagner;	state Exp;
branches
	2.15.2.1;
next	2.14;

2.14
date	2002.10.08.17.36.20;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2002.08.22.01.22.20;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2001.10.17.20.50.30;	author dwu;	state Exp;
branches;
next	2.11;

2.11
date	2001.08.06.18.37.36;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2001.04.10.23.44.44;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.28.03.03.38;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.28.01.25.38;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.03.21.02.13.40;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.03.17.02.24.07;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.03.02.01.29.05;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.14.00.12.21;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.09.00.38.22;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2000.11.15.02.37.18;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.05;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.02.02.05.04;	author vsnyder;	state Exp;
branches;
next	;

2.15.2.1
date	2003.03.27.23.17.10;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.24
log
@Removed -- functionality move to modules where types are defined
@
text
@! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

module DUMPER

! Dump various stuff so we can look at it.

  implicit NONE
  private

! === (start of toc) ===                                                 
!     c o n t e n t s                                                    
!     - - - - - - - -                                                    

! dump                   Dump the various user-defined types of mlsl2  
! === (end of toc) ===                                                   
! === (start of api) ===
! dump (type arg ) or     
! dump (type args(:), [int details] )      
!    where arg(s) may be among the following types:
!      { MLSChunk_t, hGrid_T, QuantityTemplates }      
! === (end of api) ===

  public :: DUMP

!---------------------------- RCS Ident Info ---------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: dumper.f90,v 2.23 2004/05/19 19:16:12 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName= "$RCSfile: dumper.f90,v $"
  private :: not_used_here 
!-----------------------------------------------------------------------

  interface DUMP
    module procedure DUMP_a_HGRID
    module procedure DUMP_HGRIDS
  end interface

contains ! =====     Private Procedures     ============================

  ! ------------------------------------------------  DUMP_A_HGRID  -----
  subroutine DUMP_a_HGRID ( aHGRID )
    use HGridsDatabase, only: HGRID_T
    use OUTPUT_M, only: OUTPUT
    use STRING_TABLE, only: DISPLAY_STRING
    type(hGrid_T), intent(in) :: aHGRID
    integer :: J
      call output ( 'Name = ' )
      call display_string ( aHgrid%name )
      call output ( aHgrid%noProfs, before=' noProfs = ' )
      call output ( aHgrid%noProfsLowerOverlap, before=' lowerOverlap = ' )
      call output ( aHgrid%noProfsUpperOverlap, before=' upperOverlap = ', advance='yes' )
      call output ( ' prof       phi       geodLat           lon' )
      call output ( '          time     solarTime   solarZenith' )
      call output ( '      losAngle', advance='yes' )
      do j = 1, aHgrid%noProfs
        call output ( j, places=5 )
        call output ( aHgrid%phi(1,j), '(1x,1pg13.6)' )
        call output ( aHgrid%geodLat(1,j), '(1x,1pg13.6)' )
        call output ( aHgrid%lon(1,j), '(1x,1pg13.6)' )
        call output ( aHgrid%time(1,j), '(1x,1pg13.6)' )
        call output ( aHgrid%solarTime(1,j), '(1x,1pg13.6)' )
        call output ( aHgrid%solarZenith(1,j), '(1x,1pg13.6)' )
        call output ( aHgrid%losAngle(1,j), '(1x,1pg13.6)', advance='yes' )
      end do
  end subroutine DUMP_a_HGRID

  ! ------------------------------------------------  DUMP_HGRIDS  -----
  subroutine DUMP_HGRIDS ( HGRIDS )
    use HGridsDatabase, only: HGRID_T
    use OUTPUT_M, only: OUTPUT
    type(hGrid_T), intent(in) :: HGRIDS(:)
    integer :: I
    call output ( size(hgrids), before='HGRIDS: SIZE = ', advance='yes' )
    do i = 1, size(hgrids)
      call output ( i, 4, after=': ' )
      call dump ( hgrids(i) )
    end do
  end subroutine DUMP_HGRIDS

  logical function not_used_here()
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here

end module DUMPER

! $Log: dumper.f90,v $
! Revision 2.23  2004/05/19 19:16:12  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.22  2004/05/18 01:16:57  vsnyder
! More cannonball-polishing
!
! Revision 2.21  2004/05/18 01:07:33  vsnyder
! Repair broken Dump_a_HGrid and Dump_HGrids routines
!
! Revision 2.20  2004/05/01 04:03:47  vsnyder
! Get Dump_Quantity_Templates from QuantityTemplates instead of duplicating it
!
! Revision 2.19  2003/08/27 20:06:16  livesey
! More minor changes to dumping of chunks.
!
! Revision 2.18  2003/08/26 18:04:52  livesey
! Minor changes in dumping of chunks.
!
! Revision 2.17  2003/06/20 19:37:06  pwagner
! Quanities now share grids stored separately in databses
!
! Revision 2.16  2003/05/05 23:00:34  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.15.2.1  2003/03/27 23:17:10  vsnyder
! Use DUMP_a_HGRID in Dump_Hgrids instead of duplicating it
!
! Revision 2.15  2002/11/06 00:19:49  pwagner
! New chunk size info
!
! Revision 2.14  2002/10/08 17:36:20  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.13  2002/08/22 01:22:20  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.12  2001/10/17 20:50:30  dwu
! a fix of cloud retrieval
!
! Revision 2.11  2001/08/06 18:37:36  pwagner
! Added Copyright statement
!
! Revision 2.10  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.9  2001/04/10 23:44:44  vsnyder
! Improve 'dump'
!
! Revision 2.8  2001/03/28 03:03:38  vsnyder
! Remove use, only's that aren't used
!
! Revision 2.7  2001/03/28 01:25:38  vsnyder
! Move DUMP_VGRIDS from dumper.f90 to VGrid.f90
!
@


2.23
log
@Move MLSChunk_t to Chunks_m
@
text
@d28 1
a28 1
    & "$Id: dumper.f90,v 2.22 2004/05/18 01:16:57 vsnyder Exp $"
d88 3
@


2.22
log
@More cannonball-polishing
@
text
@a7 2
  use OUTPUT_M, only: OUTPUT
  use QuantityTemplates, only: DUMP
d28 1
a28 1
    & "$Id: dumper.f90,v 2.21 2004/05/18 01:07:33 vsnyder Exp $"
a34 1
    module procedure DUMP_CHUNKS
a39 26
  ! ------------------------------------------------  DUMP_CHUNKS  -----
  subroutine DUMP_CHUNKS ( CHUNKS )

    use MLSCommon, only: MLSCHUNK_T

    type(MLSChunk_t), intent(in) :: CHUNKS(:)
    integer :: I
    call output ( 'CHUNKS: SIZE = ' )
    call output ( size(chunks), advance='yes' )
    do i = 1, size(chunks)
      call output ( i, before=' Chunk ', advance='yes' )
      call output ( chunks(i)%firstMAFIndex, before='  firstMAFIndex: ' )
      call output ( chunks(i)%lastMAFIndex, before='  lastMAFIndex: ', advance='yes' )
      call output ( chunks(i)%noMAFsLowerOverlap, before='  noMAFsLowerOverlap: ' )
      call output ( chunks(i)%noMAFsUpperOverlap, before='  noMAFsUpperOverlap: ', advance='yes' )
      call output ( chunks(i)%firstMAFIndex + chunks(i)%noMAFsLowerOverlap, &
        & before='  1st non-overlapped MAF: ' )
      call output ( chunks(i)%lastMAFIndex - chunks(i)%noMAFsUpperOverlap, &
        & before='  last non-overlapped MAF: ', advance='yes' )
      call output ( chunks(i)%lastMAFIndex - chunks(i)%firstMAFIndex + 1, &
        & before='  chunk size: ' )
      call output ( chunks(i)%lastMAFIndex - chunks(i)%firstMAFIndex &
        & - chunks(i)%noMAFsUpperOverlap - chunks(i)%noMAFsLowerOverlap + 1, &
        & before='  non-overlapped chunk size: ', advance='yes' )
    end do
  end subroutine DUMP_CHUNKS
d44 1
d71 1
d88 3
@


2.21
log
@Repair broken Dump_a_HGrid and Dump_HGrids routines
@
text
@d30 1
a30 1
    & "$Id: dumper.f90,v 2.20 2004/05/01 04:03:47 vsnyder Exp $"
d53 7
a59 13
      call output ( ' Chunk ' )
      call output ( i, advance='yes' )
      call output ( '  firstMAFIndex: ' )
      call output ( chunks(i)%firstMAFIndex )
      call output ( '  lastMAFIndex: ' )
      call output ( chunks(i)%lastMAFIndex, advance='yes' )
      call output ( '  noMAFsLowerOverlap: ' )
      call output ( chunks(i)%noMAFsLowerOverlap )
      call output ( '  noMAFsUpperOverlap: ' )
      call output ( chunks(i)%noMAFsUpperOverlap, advance='yes' )
      call output ( '  1st non-overlapped MAF: ' )
      call output ( chunks(i)%firstMAFIndex + chunks(i)%noMAFsLowerOverlap )
      call output ( '  last non-overlapped MAF: ' )
d61 3
a63 4
        & advance='yes' )
      call output ( '  chunk size: ' )
      call output ( chunks(i)%lastMAFIndex - chunks(i)%firstMAFIndex + 1 )
      call output ( '  non-overlapped chunk size: ' )
d66 1
a66 1
        & advance='yes' )
d101 1
a101 2
    call output ( 'HGRIDS: SIZE = ' )
    call output ( size(hgrids), advance='yes' )
d115 3
@


2.20
log
@Get Dump_Quantity_Templates from QuantityTemplates instead of duplicating it
@
text
@d30 1
a30 1
    & "$Id: dumper.f90,v 2.19 2003/08/27 20:06:16 livesey Exp $"
d80 1
d83 17
a99 8
      do j = 1, ahgrid%noProfs
        call output ( ahgrid%phi(1,j), '(1x,1pg13.6)' )
        call output ( ahgrid%geodLat(1,j), '(1x,1pg13.6)' )
        call output ( ahgrid%lon(1,j), '(1x,1pg13.6)' )
        call output ( ahgrid%time(1,j), '(1x,1pg13.6)' )
        call output ( ahgrid%solarTime(1,j), '(1x,1pg13.6)' )
        call output ( ahgrid%solarZenith(1,j), '(1x,1pg13.6)' )
        call output ( ahgrid%losAngle(1,j), '(1x,1pg13.6)', advance='yes' )
a105 1
    use STRING_TABLE, only: DISPLAY_STRING
d107 1
a107 1
    integer :: I, J
d111 2
a112 16
      call output ( i, 4 )
      call output ( ': Name = ' )
      call display_string ( hgrids(i)%name )
      call output ( ' noProfs = ' )
      call output ( hgrids(i)%noProfs, advance='yes' )
      call output ( '      noProfsLowerOverlap = ' )
      call output ( hgrids(i)%noProfsLowerOverlap )
      call output ( ' noProfsUpperOverlap = ' )
      call output ( hgrids(i)%noProfsUpperOverlap, advance='yes' )
      call output ( ' prof          phi       geodLat           lon' )
      call output ( '          time     solarTime   solarZenith' )
      call output ( '      losAngle', advance='yes' )
      do j = 1, hgrids(i)%noProfs
        call output ( j, 4 )
        call dump ( hgrids(i) )
      end do
d123 3
@


2.19
log
@More minor changes to dumping of chunks.
@
text
@d9 1
d30 1
a30 1
    & "$Id: dumper.f90,v 2.18 2003/08/26 18:04:52 livesey Exp $"
a39 1
    module procedure DUMP_QUANTITY_TEMPLATES
a120 107
  ! ------------------------------------  DUMP_QUANTITY_TEMPLATES  -----
  subroutine DUMP_QUANTITY_TEMPLATES ( QUANTITY_TEMPLATES, DETAILS )

    use DUMP_0, only: DUMP
    use Intrinsic, only: LIT_INDICES, PHYQ_INDICES
    use MLSSignals_m, only: signals, DUMP, GetRadiometerName, GetModuleName
    use QuantityTemplates, only: QuantityTemplate_T
    use STRING_TABLE, only: DISPLAY_STRING

    type(QuantityTemplate_T), intent(in) :: QUANTITY_TEMPLATES(:)
    integer, intent(in), optional :: DETAILS ! <= 0 => Don't dump arrays
    !                                        ! >0   => Do dump arrays
    !                                        ! Default 1
    integer :: I, MyDetails
    character (len=80) :: Str
    myDetails = 1
    if ( present(details) ) myDetails = details
    call output ( 'QUANTITY_TEMPLATES: SIZE = ' )
    call output ( size(quantity_templates), advance='yes' )
    do i = 1, size(quantity_templates)
      call output ( i, 4 )
      call output ( ': Name = ' )
      call display_string ( quantity_templates(i)%name )
      call output ( ' quantityType = ' )
      call display_string ( lit_indices(quantity_templates(i)%quantityType), &
        & advance='yes' )
      call output ( '      NoInstances = ' )
      call output ( quantity_templates(i)%noInstances )
      call output ( ' NoSurfs = ' )
      call output ( quantity_templates(i)%noSurfs )
      call output ( ' noChans = ' )
      call output ( quantity_templates(i)%noChans, advance='yes' )
      call output ( '      ' )
      if ( .not. quantity_templates(i)%coherent ) call output ( 'in' )
      call output ( 'coherent ' )
      if ( .not. quantity_templates(i)%stacked ) call output ( 'non' )
      call output ( 'stacked ' )
      if ( .not. quantity_templates(i)%regular ) call output ( 'ir' )
      call output ( 'regular ' )
      if ( quantity_templates(i)%logBasis ) then
        call output ('log-')
      else
        call output ('linear-')
      endif
      call output ('basis ' )  
      if ( .not. quantity_templates(i)%minorFrame ) call output ( 'non' )
      call output ( 'minorFrame', advance='yes' )
      call output ( '      NoInstancesLowerOverlap = ' )
      call output ( quantity_templates(i)%noInstancesLowerOverlap )
      call output ( ' NoInstancesUpperOverlap = ' )
      call output ( quantity_templates(i)%noInstancesUpperOverlap, advance='yes' )
      call output ( '      BadValue = ' )
      call output ( quantity_templates(i)%badValue )
      call output ( ' Unit = ' )
      call display_string ( phyq_indices(quantity_templates(i)%unit) )
      call output ( ' InstanceLen = ' )
      call output ( quantity_templates(i)%InstanceLen, advance='yes' )
      if ( myDetails < 0 ) then
        call dump ( quantity_templates(i)%surfs, '  Surfs = ' )
        call dump ( quantity_templates(i)%phi, '      Phi = ' )
        call dump ( quantity_templates(i)%geodLat, '      GeodLat = ' )
        call dump ( quantity_templates(i)%lon, '      Lon = ' )
        call dump ( quantity_templates(i)%time, '      Time = ' )
        call dump ( quantity_templates(i)%solarTime, '      SolarTime = ' )
        call dump ( quantity_templates(i)%solarZenith, '      SolarZenith = ' )
        call dump ( quantity_templates(i)%losAngle, '      LosAngle = ' )
        if ( associated(quantity_templates(i)%frequencies) ) then
          call output ( '      FrequencyCoordinate = ' )
          call output ( quantity_templates(i)%frequencyCoordinate )
          call dump ( quantity_templates(i)%frequencies, ' Frequencies = ' )
        end if
      end if
      if ( quantity_templates(i)%radiometer /= 0 ) then
        call output ( '      Radiometer = ' )
        call GetRadiometerName ( quantity_templates(i)%radiometer, str )
        call output ( trim(str), advance='yes' )
      end if
      if ( quantity_templates(i)%molecule + &
        &  quantity_templates(i)%instrumentModule /= 0 ) then
        call output ( '     ' )
        if ( quantity_templates(i)%molecule /= 0 ) then
          call output ( ' Molecule = ' )
          call display_string ( lit_indices(quantity_templates(i)%molecule) )
        end if
        if ( quantity_templates(i)%instrumentModule /= 0 ) then
          call output ( ' Instrument Module = ' )
          call GetModuleName ( quantity_templates(i)%instrumentModule, str )
          call output ( trim(str) )
        end if
        call output ( '', advance = 'yes')
      end if
      if ( myDetails > 0 ) then
        if ( quantity_templates(i)%signal /= 0 ) then
          call dump ( signals( (/ quantity_templates(i)%signal /) ) )
        end if
        if ( quantity_templates(i)%radiometer + &
          &  quantity_templates(i)%molecule /= 0 ) &
          &  call output ( '', advance='yes' )
        if ( associated(quantity_templates(i)%surfIndex) ) then
          call dump ( quantity_templates(i)%surfIndex, '      SurfIndex = ' )
        end if
        if ( associated(quantity_templates(i)%chanIndex) ) then
          call dump ( quantity_templates(i)%chanIndex, '      ChanIndex = ' )
        end if
      end if
    end do
  end subroutine DUMP_QUANTITY_TEMPLATES
d128 3
@


2.18
log
@Minor changes in dumping of chunks.
@
text
@d29 1
a29 1
    & "$Id: dumper.f90,v 2.17 2003/06/20 19:37:06 pwagner Exp $"
d53 3
a55 2
      call output ( i, 4 )
      call output ( ':  firstMAFIndex: ' )
d235 3
@


2.17
log
@Quanities now share grids stored separately in databses
@
text
@d29 1
a29 1
    & "$Id: dumper.f90,v 2.16 2003/05/05 23:00:34 livesey Exp $"
d54 1
a54 1
      call output ( ': firstMAFIndex = ' )
d56 1
a56 1
      call output ( ' lastMAFIndex = ' )
d58 1
a58 1
      call output ( '      noMAFsLowerOverlap = ' )
d60 1
a60 1
      call output ( ' noMAFsUpperOverlap = ' )
d62 1
a62 1
      call output ( '      1st non-overlap chunk = ' )
d64 1
a64 1
      call output ( '      last non-overlap chunk = ' )
d67 3
a69 3
      call output ( '      chunk size= ' )
      call output ( chunks(i)%lastMAFIndex - chunks(i)%firstMAFIndex )
      call output ( '      non-overlap chunk size= ' )
d234 3
@


2.16
log
@Merged in feb03 newfwm branch
@
text
@d29 1
a29 1
    & "$Id$"
d31 1
a31 1
  character (len=*), parameter :: ModuleName= "$RCSfile$"
d71 2
a72 3
        & - chunks(i)%noMAFsUpperOverlap - chunks(i)%noMAFsLowerOverlap + 1)
      call output ( '      accumulatedMAFs = ' )
      call output ( chunks(i)%accumulatedMAFs, advance='yes' )
d78 1
a78 1
    use HGRID, only: HGRID_T
d82 7
a88 7
        call output ( ahgrid%phi(j), '(1x,1pg13.6)' )
        call output ( ahgrid%geodLat(j), '(1x,1pg13.6)' )
        call output ( ahgrid%lon(j), '(1x,1pg13.6)' )
        call output ( ahgrid%time(j), '(1x,1pg13.6)' )
        call output ( ahgrid%solarTime(j), '(1x,1pg13.6)' )
        call output ( ahgrid%solarZenith(j), '(1x,1pg13.6)' )
        call output ( ahgrid%losAngle(j), '(1x,1pg13.6)', advance='yes' )
d94 1
a94 1
    use HGRID, only: HGRID_T
a142 1
      call output ( ' Id = ' ); call output ( quantity_templates(i)%id )
d175 1
a175 3
      call output ( ' ScaleFactor = ' )
      call output ( quantity_templates(i)%scaleFactor, advance='yes' )
      call output ( '      InstanceLen = ' )
a185 4
        if ( associated(quantity_templates(i)%mafIndex) ) then
          call dump ( quantity_templates(i)%mafIndex, '      MAFIndex = ' )
          call dump ( quantity_templates(i)%mafCounter, '      MAFCounter = ' )
        end if
d233 4
a236 1
! $Log$
@


2.15
log
@New chunk size info
@
text
@d29 1
a29 1
    & "$Id: dumper.f90,v 2.14 2002/10/08 17:36:20 pwagner Exp $"
d31 1
a31 1
  character (len=*), parameter :: ModuleName= "$RCSfile: dumper.f90,v $"
d116 1
a116 7
        call output ( hgrids(i)%phi(j), '(1x,1pg13.6)' )
        call output ( hgrids(i)%geodLat(j), '(1x,1pg13.6)' )
        call output ( hgrids(i)%lon(j), '(1x,1pg13.6)' )
        call output ( hgrids(i)%time(j), '(1x,1pg13.6)' )
        call output ( hgrids(i)%solarTime(j), '(1x,1pg13.6)' )
        call output ( hgrids(i)%solarZenith(j), '(1x,1pg13.6)' )
        call output ( hgrids(i)%losAngle(j), '(1x,1pg13.6)', advance='yes' )
d241 7
a247 1
! $Log: dumper.f90,v $
@


2.15.2.1
log
@Use DUMP_a_HGRID in Dump_Hgrids instead of duplicating it
@
text
@d29 1
a29 1
    & "$Id: dumper.f90,v 2.15 2002/11/06 00:19:49 pwagner Exp $"
d116 7
a122 1
        call dump ( hgrids(i) )
a247 3
! Revision 2.15  2002/11/06 00:19:49  pwagner
! New chunk size info
!
@


2.14
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d12 13
d29 1
a29 1
    & "$Id: dumper.f90,v 2.13 2002/08/22 01:22:20 vsnyder Exp $"
d62 10
d248 3
@


2.13
log
@Move USE statements from module scope to procedure scope
@
text
@d16 1
a16 1
    & "$Id: dumper.f90,v 2.12 2001/10/17 20:50:30 dwu Exp $"
d19 1
d218 4
d225 3
@


2.12
log
@a fix of cloud retrieval
@
text
@a7 5
  use DUMP_0, only: DUMP
  use HGRID, only: HGRID_T
  use Intrinsic, only: LIT_INDICES, PHYQ_INDICES
  use MLSCommon, only: MLSCHUNK_T
  use MLSSignals_m, only: signals, DUMP, GetRadiometerName, GetModuleName
a8 2
  use QuantityTemplates, only: QuantityTemplate_T
  use STRING_TABLE, only: DISPLAY_STRING
d16 1
a16 1
    & "$Id: dumper.f90,v 2.11 2001/08/06 18:37:36 pwagner Exp $"
d23 1
a23 1
    module procedure DUMP_aHGRID
d31 3
d54 2
a55 1
  subroutine DUMP_aHGRID ( aHGRID )
d67 1
a67 1
  end subroutine DUMP_aHGRID
d71 2
d105 7
d220 3
@


2.11
log
@Added Copyright statement
@
text
@d23 1
a23 1
    & "$Id: dumper.f90,v 2.10 2001/04/26 02:44:17 vsnyder Exp $"
d30 1
d57 15
d214 3
@


2.10
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d1 3
d23 1
a23 1
    & "$Id: dumper.f90,v 2.9 2001/04/10 23:44:44 vsnyder Exp $"
d198 3
@


2.9
log
@Improve 'dump'
@
text
@d7 1
a7 1
  use INIT_TABLES_MODULE, only: LIT_INDICES, PHYQ_INDICES
d20 1
a20 1
    & "$Id: dumper.f90,v 2.8 2001/03/28 03:03:38 vsnyder Exp $"
d195 3
@


2.8
log
@Remove use, only's that aren't used
@
text
@d20 1
a20 1
    & "$Id: dumper.f90,v 2.7 2001/03/28 01:25:38 vsnyder Exp $"
d86 1
a86 1
  subroutine DUMP_QUANTITY_TEMPLATES ( QUANTITY_TEMPLATES )
d88 7
a94 2
    integer :: I
    character (len=80) :: str
d137 19
a155 17
      call output ( quantity_templates(i)%InstanceLen )
      call dump ( quantity_templates(i)%surfs, '  Surfs = ' )
      call dump ( quantity_templates(i)%phi, '      Phi = ' )
      call dump ( quantity_templates(i)%geodLat, '      GeodLat = ' )
      call dump ( quantity_templates(i)%lon, '      Lon = ' )
      call dump ( quantity_templates(i)%time, '      Time = ' )
      call dump ( quantity_templates(i)%solarTime, '      SolarTime = ' )
      call dump ( quantity_templates(i)%solarZenith, '      SolarZenith = ' )
      call dump ( quantity_templates(i)%losAngle, '      LosAngle = ' )
      if ( associated(quantity_templates(i)%mafIndex) ) then
        call dump ( quantity_templates(i)%mafIndex, '      MAFIndex = ' )
        call dump ( quantity_templates(i)%mafCounter, '      MAFCounter = ' )
      end if
      if ( associated(quantity_templates(i)%frequencies) ) then
        call output ( '      FrequencyCoordinate = ' )
        call output ( quantity_templates(i)%frequencyCoordinate )
        call dump ( quantity_templates(i)%frequencies, ' Frequencies = ' )
a156 3
      if ( quantity_templates(i)%radiometer + &
        &  quantity_templates(i)%molecule /= 0 ) &
        &  call output ( '     ' )
d158 1
a158 1
        call output ( ' Radiometer = ' )
d160 1
a160 20
        call output ( str )
      end if
      if ( quantity_templates(i)%instrumentModule /= 0 ) then
        call output ( ' Instrument Module = ' )
        call GetModuleName ( quantity_templates(i)%instrumentModule, str )
        call output ( str )
      end if
      if ( quantity_templates(i)%molecule /= 0 ) then
        call output ( ' Molecule = ' )
        call display_string ( lit_indices(quantity_templates(i)%molecule) )
      end if
      call output ( '', advance = 'yes')
      if ( quantity_templates(i)%signal /= 0 ) then
        call dump ( signals( (/ quantity_templates(i)%signal /) ) )
      end if
      if ( quantity_templates(i)%radiometer + &
        &  quantity_templates(i)%molecule /= 0 ) &
        &  call output ( '', advance='yes' )
      if ( associated(quantity_templates(i)%surfIndex) ) then
        call dump ( quantity_templates(i)%surfIndex, '      SurfIndex = ' )
d162 27
a188 2
      if ( associated(quantity_templates(i)%chanIndex) ) then
        call dump ( quantity_templates(i)%chanIndex, '      ChanIndex = ' )
d195 3
@


2.7
log
@Move DUMP_VGRIDS from dumper.f90 to VGrid.f90
@
text
@d5 1
a5 1
  use DUMP_0, only: AfterSub, DUMP
d9 1
a9 1
  use MLSSignals_m, only: radiometers, signals, DUMP, GetRadiometerName, GetModuleName
a12 1
  use VGRID, only: VGRID_T
d20 1
a20 1
    & "$Id: dumper.f90,v 2.6 2001/03/21 02:13:40 livesey Exp $"
d184 4
a187 1
! $Log: $
@


2.6
log
@typo
@
text
@d20 4
a23 4
  character (len=256) :: Id = &
       "$Id: dumper.f90,v 2.5 2001/03/17 02:24:07 livesey Exp $"
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: dumper.f90,v $"
a29 1
    module procedure DUMP_VGRIDS
a182 18

  ! ------------------------------------------------  DUMP_VGRIDS  -----
  subroutine DUMP_VGRIDS ( VGRIDS )
    type(vGrid_T), intent(in) :: VGRIDS(:)
    integer :: I
    call output ( 'VGRIDS: SIZE = ' )
    call output ( size(vgrids), advance='yes' )
    do i = 1, size(vgrids)
      call output ( i, 4 )
      call output ( ': Name = ' )
      call display_string ( vgrids(i)%name )
      call output ( ' noSurfs = ' )
      call output ( vgrids(i)%noSurfs )
      call output ( ' verticalCoordinate = ' )
      call display_string ( lit_indices(vgrids(i)%verticalCoordinate) )
      call dump ( vgrids(i)%surfs, ' Surfs = ' )
    end do
  end subroutine DUMP_VGRIDS
d185 1
a185 1
! $Log,v $
@


2.5
log
@Some changes to DUMP_QUANTITY_TEMPLATES
@
text
@d21 1
a21 1
       "$Id: dumper.f90,v 2.4 2001/03/02 01:29:05 livesey Exp $"
d118 1
a118 1
        call output ('linear')
@


2.4
log
@Fixed for new MLSSignals_m
@
text
@d9 1
a9 1
  use MLSSignals_m, only: radiometers, signals, DUMP
d21 1
a21 1
       "$Id: dumper.f90,v 2.3 2001/02/14 00:12:21 livesey Exp $"
d91 1
d115 6
d157 2
a158 1
        call display_string ( radiometers(quantity_templates(i)%radiometer)%prefix )
d162 2
a163 4
        call display_string ( quantity_templates(i)%instrumentModule )
      end if
      if ( quantity_templates(i)%signal /= 0 ) then
        call dump ( signals( (/ quantity_templates(i)%signal /) ) )
d168 4
@


2.3
log
@Removed firstIndexChannel
@
text
@d9 1
d21 1
a21 1
       "$Id: dumper.f90,v 2.2 2001/02/09 00:38:22 livesey Exp $"
a144 3
      if ( associated(quantity_templates(i)%signal) ) then
        ! ??? Dump the signal
      end if
d150 8
a157 1
        call display_string ( quantity_templates(i)%radiometer )
@


2.2
log
@Various updates
@
text
@d20 1
a20 1
       "$Id: dumper.f90,v 2.1 2000/11/15 02:37:18 vsnyder Exp $"
a126 2
      if ( .not. quantity_templates(i)%firstIndexChannel ) call output ( ' not' )
      call output ( ' firstIndexChannel' )
@


2.1
log
@Moved generic array dumping to lib/dump_0.f90
@
text
@d20 1
a20 1
       "$Id: dumper.f90,v 2.0 2000/09/05 18:57:05 ahanzel Exp $"
d149 1
a149 1
      if ( quantity_templates(i)%radiometerIndex + &
d152 1
a152 1
      if ( quantity_templates(i)%radiometerIndex /= 0 ) then
d154 1
a154 1
        call display_string ( quantity_templates(i)%radiometerIndex )
d160 1
a160 1
      if ( quantity_templates(i)%radiometerIndex + &
@


2.0
log
@Changing file revision to 2.0.
@
text
@d5 1
d20 1
a20 1
       "$Id: dumper.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
a29 5
    module procedure DUMP_1D_DOUBLE
    module procedure DUMP_1D_INTEGER
    module procedure DUMP_2D_DOUBLE
    module procedure DUMP_2D_INTEGER
    module procedure DUMP_3D_DOUBLE
a31 1
  character, parameter :: AfterSub = '#'
a188 120

  ! ---------------------------------------------  DUMP_1D_DOUBLE  -----
  subroutine DUMP_1D_DOUBLE ( ARRAY, NAME )
    double precision, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    integer :: J, K
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
      call output ( array(1), '(1x,1pg13.6)', advance='yes' )
    else
      if ( present(name) ) call output ( name, advance='yes' )
      do j = 1, size(array), 5
        call output ( j, 4 ); call output ( afterSub )
        do k = j, min(j+4, size(array))
          call output ( array(k), '(1x,1pg13.6)' )
        end do
        call output ( '', advance='yes' )
      end do
    end if
  end subroutine DUMP_1D_DOUBLE

  ! --------------------------------------------  DUMP_1D_INTEGER  -----
  subroutine DUMP_1D_INTEGER ( ARRAY, NAME )
    integer, intent(in) :: ARRAY(:)
    character(len=*), intent(in), optional :: NAME
    integer :: J, K
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
      call output ( array(1), advance='yes' )
    else
      if ( present(name) ) call output ( name, advance='yes' )
      do j = 1, size(array), 10
        call output ( j, 4 ); call output ( afterSub )
        do k = j, min(j+9, size(array))
          call output ( array(k), 6 )
        end do
        call output ( '', advance='yes' )
      end do
    end if
  end subroutine DUMP_1D_INTEGER

  ! ---------------------------------------------  DUMP_2D_DOUBLE  -----
  subroutine DUMP_2D_DOUBLE ( ARRAY, NAME )
    double precision, intent(in) :: ARRAY(:,:)
    character(len=*), intent(in), optional :: NAME
    integer :: I, J, K
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
      call output ( array(1,1), '(1x,1pg13.6)', advance='yes' )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name )
    else
      if ( present(name) ) call output ( name, advance='yes' )
      do i = 1, size(array,1)
        do j = 1, size(array,2), 5
          call output ( i, 4 )
          call output ( j, 4 ); call output ( afterSub )
          do k = j, min(j+4, size(array,2))
            call output ( array(i,k), '(1x,1pg13.6)' )
          end do
          call output ( '', advance='yes' )
        end do
      end do
    end if
  end subroutine DUMP_2D_DOUBLE

  ! --------------------------------------------  DUMP_2D_INTEGER  -----
  subroutine DUMP_2D_INTEGER ( ARRAY, NAME )
    integer, intent(in) :: ARRAY(:,:)
    character(len=*), intent(in), optional :: NAME
    integer :: I, J, K
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
      call output ( array(1,1), advance='yes' )
    else if ( size(array,2) == 1 ) then
      call dump ( array(:,1), name )
    else
      if ( present(name) ) call output ( name, advance='yes' )
      do i = 1, size(array,1)
        do j = 1, size(array,2), 10
          call output ( i, 4 )
          call output ( j, 4 ); call output ( afterSub )
          do k = j, min(j+9, size(array,2))
            call output ( array(i,k), 6 )
          end do
          call output ( '', advance='yes' )
        end do
      end do
    end if
  end subroutine DUMP_2D_INTEGER

  ! ---------------------------------------------  DUMP_3D_DOUBLE  -----
  subroutine DUMP_3D_DOUBLE ( ARRAY, NAME )
    double precision, intent(in) :: ARRAY(:,:,:)
    character(len=*), intent(in), optional :: NAME
    integer :: I, J, K, L
    if ( size(array) == 1 ) then
      if ( present(name) ) call output ( name )
      call output ( array(1,1,1), '(1x,1pg13.6)', advance='yes' )
    else if ( size(array,2) == 1 .and. size(array,3) == 1 ) then
      call dump ( array(:,1,1), name )
    else if ( size(array,3) == 1 ) then
      call dump ( array(:,:,1), name )
    else
      if ( present(name) ) call output ( name, advance='yes' )
      do i = 1, size(array,1)
        do j = 1, size(array,2)
          do k = 1, size(array,3), 5
            call output ( i, 4 )
            call output ( j, 4 )
            call output ( k, 4 ); call output ( afterSub )
            do l = k, min(k+4, size(array,3))
              call output ( array(i,j,l), '(1x,1pg13.6)' )
            end do
            call output ( '', advance='yes' )
          end do
        end do
      end do
    end if
  end subroutine DUMP_3D_DOUBLE
@


1.1
log
@Initial entry
@
text
@d19 1
a19 1
       "$Id: dumper.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
@


