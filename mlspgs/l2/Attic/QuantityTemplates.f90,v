head	2.1;
access;
symbols;
locks; strict;
comment	@# @;


2.1
date	2000.10.12.23.58.54;	author vsnyder;	state dead;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.04;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.02.02.05.04;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.1
log
@Moved to mlspgs/lib
@
text
@! Copyright (c) 1999, California Institute of Technology. ALL RIGHTS RESERVED.
! U.S. Government sponsorship under NASA Contract NAS7407 is acknowledged.

!=============================================================================
module QuantityTemplates         ! Quantities within vectors
!=============================================================================

  ! This module defines the `quantities' that make up vectors and their
  ! template information.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use MLSCommon, only: NameLen, R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    & MLSMSG_Error
  use MLSSignalNomenclature, only: MLSSignal_T

  implicit none
  public

  !------------------------------- RCS Ident Info ------------------------------
  character(len=130), private :: id = & 
       "$Id: QuantityTemplates.f90,v 2.0 2000/09/05 18:57:04 ahanzel Exp $"
  character(len=*), parameter, private :: ModuleName = &
    & "$RCSfile: QuantityTemplates.f90,v $"
  !-----------------------------------------------------------------------------

  ! This set of integers defines how quantities are broken into `channels'
  ! These are known as FGrid information.  Rather than have an FGrid module,
  ! for the moment we'll just handle this information here. This may be split
  ! out in later versions of the code.

  integer, parameter :: NoFGTypes=5
  character (len=24), parameter, dimension(NoFGTypes) :: &
    & FGTypeNames= (/ &
    & "No frequency dependence ", &
    & "MLS Channel             ", &
    & "Intermediate Frequecny  ", &
    & "Upper Sideband Frequency", &
    & "Lower Sideband Frequency"/)
  integer, parameter :: FG_Invalid=0
  integer, parameter :: FG_None=1
  integer, parameter :: FG_InstrumentChannel=2
  integer, parameter :: FG_IntermediateFrequency=3
  integer, parameter :: FG_USBFrequency=4
  integer, parameter :: FG_LSBFrequency=5

  ! Define some global parameters and data types.

  type QuantityTemplate_T

    ! Some administrative stuff

    integer :: Name            ! Sub-rosa index of quantity name
    integer :: id              ! Id code for quantity (for checking stuff)

    ! This integer is of an enumerated type describing what kind of
    ! quantity this is -- one of the l_lits of type t_quantityType
    ! in Init_Tables_Module, e.g. l_Temperature.

    integer :: quantityType

    ! The dimensions of this quantity

    integer :: noInstances     ! Number of horizontal instances in this quantity
    integer :: noSurfs         ! Number of surfaces per instance
    integer :: noChans         ! Number of channels

    ! Flags describing the quantity

    logical :: coherent        ! Do instances have same vertical coordinates?
    logical :: stacked         ! Are instances true vertical profiles?
    logical :: regular         ! Are all channels/heights represented

    ! This next one allows software using the vector quantities to be somewhat
    ! lazy and, for example, avoid interpolation.  Minor frame quantities are
    ! incoherent and unstacked, but may be regular or irregular.  However, not
    ! all incoherent unstacked quantities are minor frame quantities.

    logical :: minorFrame      ! Is this a minor frame quantity.

    ! This information describes how much of the data is in the overlap
    ! regions if any.

    integer :: noInstancesLowerOverlap
    integer :: noInstancesUpperOverlap

    ! Vertical coordinate

    integer :: verticalCoordinate ! The vertical coordinate used.  These
                                  ! are l_lits of the type t_VGridCoord
                                  ! defined in Init_Tables_Module.

    ! Misc. information

    real(r8) :: badValue      ! Value used to flag bad/missing data
    integer :: unit           ! Unit quantity is in when scaled as below,
                              ! an l_lit of the type t_units in
                              ! Init_Tables_Module.
    real(r8) :: scaleFactor   ! Scale factor used when printing etc.

    ! For regular quantities the number of elements of each instance
    ! is simply noSurfs*noChans.  For irregular ones it is less, but it is
    ! constant from instance to instance; this is that number.

    integer :: instanceLen

    ! Define how the data in each instance are stored, whether by
    ! surface or channels (regular quantities only).

    logical :: firstIndexChannel

    ! Give the vertical coordinates

    real(r8), dimension(:,:), pointer :: surfs

    ! This is dimensioned (noSurfs,1) for coherent quantities and
    ! (noSurfs, noInstances) for incoherent ones.

    ! Horizontal coordinates

    real(r8), dimension(:,:), pointer :: phi

    ! This is dimensioned (1, noInstances) for stacked quantities and
    ! (noSurfs, noInstances) for unstacked ones.
    
    ! These other coordinates are dimensioned in the same manner:

    real(r8), dimension(:,:), pointer :: geodLat, lon, time, &
      & solarTime, solarZenith, losAngle

    ! These optional integer arrays are used for minor frame quantities,
    ! to index the major frames.

    integer, dimension(:), pointer :: mafIndex => NULL(), mafCounter => NULL()

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! For quantities containing `channels' the following information may or
    ! may not be useful.

    ! Some quantities are on abritrary freqency grids; these quantities refer
    ! to those.

    integer :: frequencyCoordinate ! An enumerated type, e.g. FG_USBFreq
    real(r8), dimension(:), pointer :: frequencies ! List of frequencies
                                                   ! (noChans)

    real(r8) :: lo     ! Local oscillator (optional)

    type (MLSSignal_T), dimension(:), pointer :: signal => NULL() ! (optional)
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! Some families of quantities require special additional information.
    ! This is given here if needed.

    integer :: radiometerIndex ! Which radiometer does a ptan qty refer to?
    integer :: molecule ! What molecule does this refer to? (One of the l_...
                        ! lits of type t_molecule in Init_Tables_Module.)

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    ! For irregular quantities, instead of using the firstIndexChannel
    ! information, we have these arrays to help us navigate around the
    ! quantity.

    integer, dimension(:,:), pointer :: surfIndex
    integer, dimension(:,:), pointer :: chanIndex
    ! These are actually dimensioned (instanceLen, noInstances)
  end type QuantityTemplate_T

  ! Incrementing counter used to set the id field of a quantity template:

  integer, save, private :: quantityTemplateCounter = 0

contains ! =====     Public Procedures     =============================

  ! Subroutines to deal with these quantitites

  ! ------------------------------  AddQuantityTemplateToDatabase  -----
  integer function AddQuantityTemplateToDatabase ( database, item )

  ! Add a quantity template to a database, or create the database if it
  ! doesn't yet exist

    ! Dummy arguments
    type (QuantityTemplate_T), dimension(:), pointer :: database
    type (QuantityTemplate_T), intent(in) :: item

    ! Local variables
    type (QuantityTemplate_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    database(newSize) = item
    AddQuantityTemplateToDatabase = newSize
  end function AddQuantityTemplateToDatabase

  ! ----------------------------  DestroyQuantityTemplateContents  -----
  subroutine DestroyQuantityTemplateContents ( qty )

  ! Destroy a quantity template

    ! Dummy argument
    type (QuantityTemplate_T), intent(inout) :: QTY

    ! Local variables

    ! Executable code

    call deallocate_test ( qty%surfs, "qty%surfs", ModuleName )
    call deallocate_test ( qty%phi, "qty%phi", ModuleName )
    call deallocate_test ( qty%geodLat, "qty%geodLat", ModuleName )
    call deallocate_test ( qty%lon, "qty%lon", ModuleName )
    call deallocate_test ( qty%time, "qty%time", ModuleName )
    call deallocate_test ( qty%solarTime, "qty%solarTime", ModuleName )
    call deallocate_test ( qty%solarZenith, "qty%solarZenith", ModuleName )
    call deallocate_test ( qty%losAngle, "qty%losAngle", ModuleName )

    if (qty%minorFrame) then
      call deallocate_test ( qty%MAFIndex, "qty%MAFIndex", ModuleName )
      call deallocate_test ( qty%MAFCounter, "qty%MAFCounter", ModuleName )
    end if
    
    if (.NOT. qty%regular) then
      call deallocate_test ( qty%surfIndex, "qty%surfIndex", ModuleName )
      call deallocate_test ( qty%chanIndex, "qty%chanIndex", ModuleName )
    end if

  end subroutine DestroyQuantityTemplateContents

  ! ----------------------------  DestroyQuantityTemplateDatabase  -----
  subroutine DestroyQuantityTemplateDatabase ( database )

  ! Destroy a quantity template database

    ! Dummy argument
    type (QuantityTemplate_T), dimension(:), pointer :: DATABASE

    ! Local variables
    integer :: qtyIndex, status

    if ( associated(database) ) then
      do qtyIndex = 1, SIZE(database)
        call DestroyQuantityTemplateContents ( database(qtyIndex) )
      end do
      deallocate ( database, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate // "database" )
    end if
  end subroutine DestroyQuantityTemplateDatabase

  ! -----------------------------------  SetupNewQuantityTemplate  -----
  subroutine SetupNewQuantityTemplate ( qty, source, noInstances, noSurfs, &
    & noChans, coherent, stacked, regular, instanceLen, firstIndexChannel, &
    & minorFrame )

  ! Set up a new quantity template according to the user input.  This may
  ! be based on a previously supplied template (with possible
  ! modifications), or created from scratch.

    ! Dummy arguments
    type (QuantityTemplate_T), intent(out) :: qty ! Result

    type (QuantityTemplate_T), optional, intent(in) :: source ! Template
    integer, intent(in), optional :: noInstances
    integer, intent(in), optional :: noSurfs
    integer, intent(in), optional :: noChans
    logical, intent(in), optional :: coherent
    logical, intent(in), optional :: stacked
    logical, intent(in), optional :: regular
    integer, intent(in), optional :: instanceLen
    logical, intent(in), optional :: firstIndexChannel
    logical, intent(in), optional :: minorFrame

    ! Local variables
    integer :: noSurfsToAllocate        ! For allocations
    integer :: noInstancesToAllocate    ! For allocations

    ! Executable code

    ! First, if we have a template setup according to that
    if (present(source)) then
      qty%noInstances = source%noInstances
      qty%noSurfs = source%noSurfs
      qty%noChans = source%noChans
      qty%coherent = source%coherent
      qty%stacked = source%stacked
      qty%regular = source%regular
      qty%minorFrame = source%minorFrame
      qty%instanceLen = source%instanceLen
    else ! We have no template, setup a very bare quantity
      qty%noInstances = 1
      qty%noSurfs = 1
      qty%noChans = 1
      qty%coherent = .TRUE.
      qty%stacked = .TRUE.
      qty%regular = .TRUE.
      qty%minorFrame = .FALSE.
      qty%instanceLen = 1
    end if

    ! Now, see if the user asked for modifications to this
    if ( present(noInstances) ) qty%noInstances = noInstances
    if ( present(noSurfs) ) qty%noSurfs = noSurfs
    if ( present(noChans) ) qty%noChans = noChans
    if ( present(regular) ) qty%regular = regular
    if ( present(minorFrame) ) qty%minorFrame = minorFrame
    if ( qty%minorFrame ) then
      if ( present(coherent) ) then
        if ( coherent ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Minor frame quantities must be incoherent" )
      end if
      qty%coherent = .FALSE.
      if ( present(stacked) ) then
        if ( stacked ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Minor frame quantities must be unstacked" )
      end if
      qty%stacked = .FALSE.
    else
      if ( present(coherent) ) qty%coherent = coherent
      if ( present(stacked) ) qty%stacked = stacked
    end if

    ! Now think about instanceLen
    if ( (.NOT. qty%regular) .AND. (present(instanceLen)) ) then
      qty%instanceLen = instanceLen
    else
      qty%instanceLen = qty%noSurfs*qty%noChans
    end if

    ! Deal with the firstindexchannel argument
    qty%firstIndexchannel = .TRUE.
    if ( present(firstindexchannel) ) qty%firstIndexchannel = firstindexchannel

    ! Now we allocate all the arrays we're going to need

    if ( qty%coherent ) then 
      noInstancesToAllocate = 1
    else
      noInstancesToAllocate = qty%noInstances
    end if

    if ( qty%stacked ) then
      noSurfsToAllocate = 1
    else
      noSurfsToAllocate = qty%noSurfs
    end if

    ! First the vertical coordinates

    call allocate_test ( qty%surfs, qty%noSurfs, noInstancesToAllocate, &
      & "qty%surfs", ModuleName )

    ! Now the horizontal coordinates

    call allocate_test ( qty%phi, noSurfsToAllocate, qty%noInstances, &
      & "qty%phi", ModuleName )

    call allocate_test ( qty%geodLat, noSurfsToAllocate, qty%noInstances, &
      & "qty%geodLat", ModuleName )

    call allocate_test ( qty%lon, noSurfsToAllocate, qty%noInstances, &
      & "qty%lon", ModuleName )

    call allocate_test ( qty%time, noSurfsToAllocate, qty%noInstances, &
      & "qty%time", ModuleName )

    call allocate_test ( qty%solarTime, noSurfsToAllocate, qty%noInstances, &
      & "qty%solarTime", ModuleName )

    call allocate_test ( qty%solarZenith, noSurfsToAllocate, qty%noInstances, &
      & "qty%solarZenith", ModuleName )

    call allocate_test ( qty%losAngle, noSurfsToAllocate, qty%noInstances, &
      & "qty%losAngle", ModuleName )

    ! Now some other stuff to allocate

    if ( qty%minorFrame ) then
      call allocate_test ( qty%MAFIndex, qty%noInstances, &
        & "qty%MAFIndex", ModuleName )
      call allocate_test ( qty%MAFCounter, qty%noInstances, &
        & "qty%MAFCounter", ModuleName )
    else
      nullify ( qty%MAFIndex, qty%MAFCounter )
    end if

    if (.NOT. qty%regular) then
      call allocate_test ( qty%surfIndex, qty%instanceLen, qty%noInstances, &
        & "qty%surfIndex", ModuleName )
      call allocate_test ( qty%chanIndex, qty%instanceLen, qty%noInstances, &
        & "qty%chanIndex", ModuleName )
    else
      nullify ( qty%surfIndex, qty%chanIndex )
    end if

    ! Increment the id counter and set the id field
    quantityTemplateCounter = quantityTemplateCounter + 1
    qty%id = quantityTemplateCounter
  end subroutine SetupNewQuantityTemplate

!=============================================================================
end module QuantityTemplates
!=============================================================================

!
! $Log: QuantityTemplates.f90,v $
! Revision 2.0  2000/09/05 18:57:04  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:04  vsnyder
! Initial entry
!


@


2.0
log
@Changing file revision to 2.0.
@
text
@d22 1
a22 1
       "$Id: QuantityTemplates.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
d406 3
@


1.1
log
@Initial entry
@
text
@d22 1
a22 1
       "$Id: QuantityTemplates.f90,v 1.1 2000/09/02 02:05:04 vsnyder Exp $"
d406 3
d412 1
a412 67
! Revision 1.11  2000/05/17 23:49:14  lungu
! Added check "if (ASSOCIATED(database))deallocate ( database)".
! Added type for GPH.
!
! Revision 1.10  2000/05/15 22:52:35  livesey
! Typo fix.
!
! Revision 1.9  2000/01/20 21:59:28  livesey
! Replaced subVectorIndex with MAFIndex and MAFCounter
!
! Revision 1.8  2000/01/20 01:28:21  livesey
! Removed the horizontal coordinate information, and beefed up the
! frequency coordinate information.
!
! Revision 1.7  2000/01/18 21:27:00  livesey
! Added noSubVectors(Lower/Upper)Overlap, copied from HGrid or similar.
!
! Revision 1.6  2000/01/12 20:55:49  livesey
! Added minorFrame flag.
!
! Revision 1.5  2000/01/07 23:53:35  livesey
! Nearly integrated, just a few tweaks.
!
! Revision 1.4  1999/12/17 21:42:16  livesey
! Added check for duplicate name
!
! Revision 1.3  1999/12/16 23:46:35  livesey
! Added the unit field and fixed a couple of compile glitches
!
! Revision 1.2  1999/12/16 23:12:09  livesey
! Added quantityType and other support entries
!
! Revision 1.1  1999/12/16 18:31:43  livesey
! First version. Renamed from VectorQuantities
!
!
! This module was previously known as VectorQuantities.  This is it's previous
! revision history.
!
! Revision 1.9  1999/12/16 01:28:02  livesey
! Routine checkin
!
! Revision 1.8  1999/12/14 00:55:29  livesey
! Changed DOUBLE PRECISION to REAL(r8)
!
! Revision 1.7  1999/12/04 00:26:33  livesey
! Added a few comments.
!
! Revision 1.6  1999/12/03 22:27:08  livesey
! Tidied up some of the INTENT stuff
!
! Revision 1.5  1999/12/03 21:57:34  livesey
! Added the code to set the id field with an incrementing counter
!
! Revision 1.4  1999/12/01 23:01:41  livesey
! Before renaming things to upper/lower case
!
! Revision 1.3  1999/12/01 05:03:56  livesey
! Nightly checkin
!
! Revision 1.2  1999/11/30 04:03:51  livesey
! Bug fix
!
! Revision 1.1  1999/11/24 23:06:33  livesey
! First simple version.
!
!
@


