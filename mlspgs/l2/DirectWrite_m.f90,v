head	2.100;
access;
symbols
	v5-02-NRT-19:2.100
	v6-00:2.100
	v5-02-NRT-18:2.100
	v5-02:2.96
	v5-01-NRT-17:2.100
	v5-01-NRT-16:2.100
	v5-01-NRT-15:2.100
	v5-01-NRT-14:2.98
	neuralnetworks-1-0:2.96.0.4
	cfm-single-freq-0-1:2.96.0.2
	v5-01:2.96
	v5-00:2.94
	v4-23-TA133:2.94.0.2
	mus-emls-1-70:2.91.0.2
	rel-1-0-englocks-work:2.89.0.2
	VUMLS1-00:2.86
	VPL1-00:2.83
	V4-22-NRT-08:2.81
	VAM1-00:2.77
	V4-21:2.67.0.2
	V4-13:2.63
	V4-12:2.61
	V4-11:2.61
	V4-10:2.61
	V3-43:2.47
	M4-00:2.54
	V3-41:2.47
	V3-40-PlusGM57:2.47.0.2
	V2-24-NRT-04:2.41
	V3-33:2.47
	V2-24:2.41
	V3-31:2.47
	V3-30-NRT-05:2.47
	cfm-01-00:2.47
	V3-30:2.47
	V3-20:2.47
	V3-10:2.44
	V2-23-NRT-02:2.41
	V2-23:2.41
	V2-22-NRT-01:2.41
	V2-22:2.41
	V2-21:2.41
	V2-20:2.41
	V2-11:2.40
	V2-10:2.40
	V2-00:2.39
	V1-51:2.29
	V1-50:2.29
	V1-45:2.28
	V1-44:2.28
	V1-43:2.23
	V1-32:2.22
	V1-31:2.14
	V1-30:2.12;
locks; strict;
comment	@# @;


2.100
date	2021.09.02.22.49.24;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2021.08.06.17.15.11;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2021.07.22.23.12.54;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2021.06.10.23.47.44;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2020.03.04.21.27.32;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2020.02.13.21.27.45;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2019.02.13.18.58.42;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2018.11.12.23.13.26;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2018.07.27.23.17.16;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2018.04.19.01.14.16;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2018.04.13.00.20.42;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2018.01.12.00.22.34;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2017.08.10.22.47.36;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2017.07.27.17.02.08;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2017.02.24.19.47.52;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2016.09.21.00.39.46;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2016.09.07.22.46.49;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2016.08.09.21.39.40;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2016.05.25.00.07.18;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2016.05.18.19.05.44;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2016.02.29.19.49.29;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2015.10.14.23.24.46;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2015.10.06.17.37.05;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2015.09.17.23.24.50;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2015.07.29.00.29.54;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2015.07.14.23.32.01;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2015.04.29.01.15.09;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2015.04.25.02.10.36;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2015.04.21.17.53.03;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2015.04.09.22.19.59;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2015.04.07.02.56.29;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2015.03.31.21.01.57;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2015.03.28.02.30.58;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2015.02.05.21.42.23;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2014.12.11.21.27.04;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2014.12.10.23.02.59;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2014.11.04.01.25.41;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2014.10.02.17.22.23;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2014.09.05.00.40.24;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2014.04.10.00.47.18;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2014.04.07.18.03.03;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2013.11.20.00.56.19;	author pwagner;	state Exp;
branches;
next	2.57;

2.57
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2013.05.08.20.17.35;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2013.05.07.22.23.30;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2012.05.10.00.48.19;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2012.03.12.17.09.44;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2012.02.24.21.19.15;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2011.12.15.01.52.55;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2011.11.01.21.44.31;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2011.05.09.18.06.59;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2010.02.04.23.12.44;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2010.02.04.19.10.26;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2010.01.08.00.11.19;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2009.04.23.23.02.52;	author pwagner;	state Exp;
branches;
next	2.42;

2.42
date	2008.09.20.00.03.00;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2006.10.11.22.58.00;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2006.06.20.00.13.34;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2006.05.11.19.39.19;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2006.04.20.23.24.12;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2006.04.19.20.48.13;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2006.04.12.22.20.42;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2006.04.11.23.33.14;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2006.01.26.00.34.50;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2005.08.19.23.28.02;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2005.07.12.17.38.57;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2005.06.22.18.57.01;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2005.06.14.20.41.17;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2004.11.29.21.52.41;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2004.08.03.18.02.01;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2004.07.22.20.42.57;	author cvuu;	state Exp;
branches;
next	2.26;

2.26
date	2004.06.29.18.05.26;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2004.06.10.00.58.45;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2004.05.19.19.16.09;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2004.05.05.21.31.48;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2004.03.03.19.25.45;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2004.02.19.23.54.26;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2004.02.11.17.23.25;	author pwagner;	state Exp;
branches;
next	2.19;

2.19
date	2004.02.10.19.30.55;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2004.02.05.23.38.41;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2004.01.23.01.09.48;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2004.01.22.06.38.26;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2004.01.22.00.56.35;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2003.12.03.17.50.54;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2003.11.14.23.38.45;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2003.08.28.23.51.39;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2003.08.01.20.39.34;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2003.07.18.16.05.26;	author pwagner;	state Exp;
branches;
next	2.9;

2.9
date	2003.07.15.23.41.47;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2003.07.09.21.49.53;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2003.07.07.21.03.43;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2003.07.07.17.32.30;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2003.07.02.00.55.27;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2003.06.25.18.24.57;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2003.06.24.23.53.27;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2003.06.23.23.55.17;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2003.06.20.19.43.16;	author pwagner;	state Exp;
branches;
next	;


desc
@@


2.100
log
@-Sprofiled prints MAF data in addition to profiles
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=======================================================================================

module DirectWrite_m  ! Write l2gp and l2aux products out to files 
                      ! chunk-by-chunk

!=======================================================================================

    ! 
    ! Purpose:
    ! Write plain hdf-formatted files ala l2aux 
    ! or hdfeos-formatted l2gp for datasets that
    ! are too big to keep all chunks stored in memory
    ! or simply take too much time doing i/o
    ! so instead write them out chunk-by-chunk

  use Allocate_Deallocate, only: Allocate_Test
  use HighOutput, only: BeVerbose, LetsDebug, OutputNamedValue, OutputTable
  use Init_Tables_Module, only: L_GeodAltitude, L_Pressure, L_Zeta, &
    & L_L2gp, L_L2aux, L_L2dgg, L_L2fwm
  use L2ParInfo, only: Parallel
  use Machine, only: USleep
  use MLSCommon, only: Interval_T, MLSFile_T, &
    & InRange
  use MLSKinds, only: Rv
  use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Warning
  use MLSFiles, only: HDFversion_4, HDFversion_5, Dump, MLS_Exists, &
    & MLS_CloseFile, MLS_OpenFile, Split_Path_Name
  use MLSFinds, only: FindFirst
  use MLSHDFEOS, only: MLS_Swath_In_File
  use MLSL2Options, only: L2Options, MLSL2Message, WriteFileAttributes
  use MLSStringLists, only: SwitchDetail
  use MLSStrings, only: LowerCase
  use Output_M, only: Blanks, NewLine, Output
  use PCFHdr, only: GlobalAttributes
  use String_Table, only: Get_String
  use Toggles, only: Switches
  use VectorsModule, only: Vector_T, VectorValue_T, Dump

  implicit none

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (data types and parameters)
! DirectData_T                    An L2AUX or L2GP data file

!     (subroutines and functions)
! AddDirectToDatabase             Adds a direct data type to a database of that type
! DestroyDirectDatabase           Deallocates all the arrays for entire database
! DirectRead                      Read the quantity from a file
! DirectWrite                     Write the quantity to a file; or
!                                   Write every quantity in a vector;
!                                   May be either l2gp or l2aux
! Dump                            Prints info on one direct or entire database
! ExpandDirectDB                  Expands a db if needed, or else
!                                   returns the matching direct
! ExpandSDNames                   Expands the array direct%sdNames if needed
! FileNameToID                    returns filename's index if found in db
! SetupNewDirect                  Allocates the arrays for a direct
! === (end of toc) ===

! === (start of api) ===
!     (user-defined types)
! DirectData_T  ( int type, int autoType, int fileIndex, int Handle, &
!    int NSDNames, char* sdNames(:), char* fileNameBase, char* fileName )

!     (subroutines and functions)
! AddDirectToDatabase AddDirectToDatabase( &
!   DirectData_T database(:), DirectData_T item )
! SetupNewDirect ( DirectData_T directData, int NsdNames )
! DestroyDirectDB ( DirectData_T database(:) )
! DirectRead ( MLSFile_T File, VectorValue_T quantity, char* qtyName, &
!    & int chunkNo, [char* options], [int rank] )
! ResizeL2AUXData ( L2AUXData_T l2aux, int newSize )
! int AddL2AUXToDatabase ( *L2AUXData_T DATABASE(:), L2AUXData_T ITEM )
! DestroyL2AUXDatabase ( *L2AUXData_T DATABASE(:) )
! Dump ( l2auxData_T L2aux(:), [char* Name], [int Details], [char* options] )
!    or Dump ( l2auxData_T L2aux, [int Details], [char* options] )
! ReadL2AUXData ( int sd_id, char* quantityname, l2auxData_T l2aux, 
!    [int firstProf], [int lastProf] )
! WriteHDF5Data ( real(r8) array(:,:,:), int l2FileHandle, int returnStatus, 
!    char* sdName )
! WriteL2AUXData ( l2auxData_T l2aux, int l2FileHandle, int returnStatus, 
!    [char* sdName], [int NoMAFS], [log WriteCounterMAF], [char* DimNames] )
! === (end of api) ===

  private
  public :: DirectData_T, &
    & AddDirectToDatabase, &
    & DestroyDirectDatabase, DirectRead, DirectWrite, Dump, &
    & ExpandDirectDB, ExpandSDNames, FileNameToID, &
    & SetupNewDirect

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: DirectWrite_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  interface DirectRead
    module procedure DirectRead_Quantity
  end interface

  interface DirectWrite
    module procedure DirectWrite_Hdf
    module procedure DirectWrite_L2Aux
    module procedure DirectWrite_L2GP
    module procedure DirectWrite_Quantity
    module procedure DirectWriteVector_Hdf
    module procedure DirectWriteVector_L2GP
    module procedure DirectWriteVector_L2Aux
    module procedure DirectWriteVector_EveryQuantity
  end interface

  interface DUMP
    module procedure DumpDirectWrite
    module procedure DumpDirectDB
  end interface

  type DirectData_T
    integer :: type       ! l_l2aux or l_l2gp
    integer :: autoType   ! 0 if not to be filled automatically, else type
    integer :: fileIndex  ! Index into character tables
    integer :: Handle     ! Set by toolkit
    integer :: NSDNames   ! How many sources
    character(len=80), dimension(:), pointer :: sdNames => null() ! source names
    character(len=1024) :: fileNameBase ! E.g., 'H2O'
    character(len=1024) :: fileName ! E.g., '/data/../MLS..H2O...he5'
  end type DirectData_T
  
  ! logical, parameter :: countEmpty = .true.
  ! integer, parameter :: S2US  = 1000000 ! How many microseconds in a s
  ! integer, parameter :: DELAY = 1*S2US  ! How long to sleep in microseconds
  logical, parameter :: DEEBUG = .false.
  logical, parameter :: MAYWRITEPOSTOVERLAPS = .true.
  ! For Announce_Error
  integer :: ERROR
  integer, save :: lastProfTooBigWarns = 0
  integer, parameter :: MAXNUMWARNS = 40

contains ! ======================= Public Procedures =========================

  !-------------------------------------------  AddDirectToDatabase  -----
  integer function AddDirectToDatabase( DATABASE, ITEM )

    ! This function adds a directly writeabledata type to a database
    ! creating a new database if it doesn't exist.  The result value is
    ! the size -- where it is put.

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (DirectData_T), dimension(:), pointer :: DATABASE
    type (DirectData_T), intent(in) :: ITEM

    ! Local variables
    type (DirectData_T), dimension(:), pointer :: tempDatabase
    !This include causes real trouble if you are compiling in a different 
    !directory.
    include "addItemToDatabase.f9h" 

    AddDirectToDatabase = newSize
  end function AddDirectToDatabase

  ! --------------------------------------------------------------------------

  ! This subroutine destroys a directly writeable database

  subroutine DestroyDirectDatabase ( DATABASE )
    use Allocate_Deallocate, only: Deallocate_Test, Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use Toggles, only: Gen, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

    ! Dummy argument
    type (DirectData_T), dimension(:), pointer :: DATABASE

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: directIndex, s, status
    integer :: Me = -1       ! String index for trace

    call trace_begin ( me, "DestroyDirectDatabase", cond=toggle(gen) )

    if ( associated(database) ) then
      do directIndex=1, size(DATABASE)
        call deallocate_test ( database(directIndex)%sdNames, &
          "database%sdNames", moduleName )
      end do
      s = size(database) * storage_size(database) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
      deallocate ( database, stat=status )
      call test_deallocate ( status, moduleName, "database", s, address=addr )
    end if
    call trace_end ( "DestroyDirectDatabase", cond=toggle(gen) )
  end subroutine DestroyDirectDatabase

  ! ------------------------------------------ DirectRead_Quantity --------
  ! We Read the quantity from a file, chunk by chunk, overlaps and all
  ! E.g., the qtyname is 'Q', and we have written chunks 1 and 2. Thus the
  ! file layout must be
  ! /
  !   Q/
  !     1/
  !       values
  !       lons
  !       lats
  !         ...
  !     2/
  !       values
  !       lons
  !       lats
  !         ...
  
  subroutine DirectRead_Quantity ( File, quantity, qtyName, &
    & chunkNo, options, rank )

    use Dates_Module, only: Tai93s2hid
    use Dump_0, only: Dump
    use HDF5, only: H5gclose_F, H5gopen_F
    use MLSHDF5, only: GetHDF5Attribute, IsHDF5GroupPresent, &
      & GetHDF5DSRank, LoadFromHDF5DS
    use MLSStringLists, only: OptionDetail
    use MLSStrings, only: WriteIntsToChars
    ! Args:
    type (VectorValue_T), intent(inout) :: QUANTITY
    character(len=*), intent(in) :: qtyName       ! Name of qty in output file
    type(MLSFile_T)                :: File
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    character(len=*), intent(in), optional :: options
    integer, intent(in), optional :: rank

    ! Local variables
    logical :: already_there
    logical :: geolocations
    integer :: grp_id
    integer :: itsRank
    integer :: myRank
    character(len=8) :: chunkStr        ! '1', '2', ..
    integer :: returnStatus
    ! logical, parameter :: DEEBUG = .true.
    logical :: verbose

    ! executable code
    verbose = BeVerbose ( 'direct', -1 )
    myRank = 0
    if ( present(rank) ) then
      if ( rank > 0 .and. rank < 5 ) myRank = rank
      ! call outputNamedValue ( 'input rank', rank )
    endif
    geolocations = optionDetail ( options, 'g' ) /= 'no'
    
    call WriteIntsToChars ( chunkNo, chunkStr )
    chunkStr = adjustl ( chunkStr )
    ! Create or access the SD
    already_There = mls_exists( File%name ) == 0
    if ( .not. already_There ) then
      call outputNamedValue( '  Sorry, file not found', trim(File%name) )
      return
    endif
    call mls_openFile ( File, returnStatus )
    if ( returnStatus /= 0 )  then
      call Dump( File )
      call outputNamedValue( '  Sorry, unable to open file', trim(File%name) )
      return
    endif
    already_there = IsHDF5GroupPresent( File%fileID%f_id, trim(qtyName) )
    if ( .not. already_There ) then
      call Dump( File )
      call outputNamedValue( '  Sorry, quantity not found in file', trim(qtyName) )
      return
    else
      call h5GOpen_f ( File%fileID%f_id, qtyName, grp_id, returnStatus )
    endif
    File%fileID%grp_id = grp_id
    call h5GOpen_f ( File%fileID%grp_id, chunkStr, grp_id, returnStatus )
    ! Begin the Reads
    ! Values
    ! call outputNamedValue ( 'rank', myRank )
    call GetHDF5DSRank ( grp_id, 'values', itsRank )
    if ( myRank > 0 .and. myRank /= itsRank ) &
      & call MLSL2Message ( MLSMSG_Warning, ModuleName // '%DirectRead', &
      & 'ranks differ for ' // trim(qtyName), &
      & MLSFile=File )
    select case ( myRank )
    case ( 1 )
      call LoadFromHDF5DS ( grp_id, 'values', quantity%value1 )
    case ( 2 )
      call LoadFromHDF5DS ( grp_id, 'values', quantity%values )
    case ( 3 )
      call LoadFromHDF5DS ( grp_id, 'values', quantity%value3 )
    case ( 4 )
      call LoadFromHDF5DS ( grp_id, 'values', quantity%value4 )
    case default
      call LoadFromHDF5DS ( grp_id, 'values', quantity%values )
    end select
    ! Geolocations
    if ( geolocations ) then
      call readQuantityAttributes ( quantity )
      call LoadFromHDF5DS( grp_id, 'surfs      ', quantity%template%surfs       )
      if ( associated(quantity%template%Geolocation) ) &
      & call LoadFromHDF5DS( grp_id, 'Geolocation  ', quantity%template%Geolocation )
      if ( allocated(quantity%template%Phi) ) &
      & call LoadFromHDF5DS( grp_id, 'Phi          ', quantity%template%Phi         )
      call LoadFromHDF5DS( grp_id, 'GeodLat        ', quantity%template%GeodLat     )
      call LoadFromHDF5DS( grp_id, 'Lon            ', quantity%template%Lon         )
      call LoadFromHDF5DS( grp_id, 'Time           ', quantity%template%Time        )
      call LoadFromHDF5DS( grp_id, 'SolarTime      ', quantity%template%SolarTime   )
      call LoadFromHDF5DS( grp_id, 'SolarZenith    ', quantity%template%SolarZenith )
      call LoadFromHDF5DS( grp_id, 'LosAngle       ', quantity%template%LosAngle    )
      if ( associated(quantity%template%CrossAngles) ) &
      & call LoadFromHDF5DS( grp_id, 'CrossAngles    ', quantity%template%CrossAngles   )
      if ( associated(quantity%template%Frequencies) ) &
      & call LoadFromHDF5DS( grp_id, 'Frequencies    ', quantity%template%Frequencies  )
      if ( associated(quantity%template%ChanInds) ) &
      & call LoadFromHDF5DS( grp_id, 'ChanInds       ', quantity%template%ChanInds   )
      if ( verbose ) then
        call dump( quantity%template%surfs        , 'surfs        ' )
        if ( associated(quantity%template%Geolocation) ) &
        & call dump( quantity%template%Geolocation, 'Geolocation  '  )
        if ( allocated(quantity%template%Phi) ) &
        & call dump( quantity%template%Phi, 'Phi          '          )
        call dump( quantity%template%GeodLat     , 'GeodLat        ' )
        call dump( quantity%template%Lon         , 'Lon            ' )
        call dump( &
        &  tai93s2hid( quantity%template%Time, leapsec=.true. ) &
        &                                        , 'Time (hid)     ' )
        call dump( quantity%template%SolarTime   , 'SolarTime      ' )
        call dump( quantity%template%SolarZenith , 'SolarZenith    ' )
        call dump( quantity%template%LosAngle    , 'LosAngle       ' )
        if ( associated(quantity%template%CrossAngles) ) &
        & call dump( quantity%template%CrossAngles  , 'CrossAngles    ' )
        if ( associated(quantity%template%Frequencies) ) &
        & call dump( quantity%template%Frequencies, 'Frequencies    '  )
        if ( associated(quantity%template%ChanInds) ) &
        & call dump( quantity%template%ChanInds  , 'ChanInds       '  )
      endif
    endif
    ! Close everything up
    call h5GClose_f ( grp_id, returnStatus )
    call h5GClose_f ( File%fileID%grp_id, returnStatus )

    call mls_CloseFile( File )
  contains
    subroutine readQuantityAttributes ( quantity )
      ! Args
      type (VectorValue_T), intent(inout) :: QUANTITY
      ! Local variables
      ! character(len=80) :: str
      ! Executable
      ! call get_string( lit_indices(quantity%template%quantityType ), str, strip=.true. )
      ! call GetHDF5Attribute ( File, 'type', str )

      call GetHDF5Attribute ( File, 'NoSurfs', quantity%template%NoSurfs )
      call GetHDF5Attribute ( File, 'NoChans', quantity%template%NoChans )
      call GetHDF5Attribute ( File, 'NoCrossTrack', quantity%template%NoCrossTrack )
      call GetHDF5Attribute ( File, 'coherent', quantity%template%coherent )
      call GetHDF5Attribute ( File, 'stacked', quantity%template%stacked )
      call GetHDF5Attribute ( File, 'regular', quantity%template%regular )
      call GetHDF5Attribute ( File, 'minorFrame', quantity%template%minorFrame )
      call GetHDF5Attribute ( File, 'majorFrame', quantity%template%majorFrame )
      call GetHDF5Attribute ( File, 'logBasis', quantity%template%logBasis )
      call GetHDF5Attribute ( File, 'minValue', quantity%template%minValue )
      call GetHDF5Attribute ( File, 'badValue', quantity%template%badValue )

      ! call get_string( lit_indices(quantity%template%unit ), str, strip=.true. )
      ! call GetHDF5Attribute ( File, 'unit', str )
      ! call get_string( lit_indices(quantity%template%verticalCoordinate ), str, strip=.true. )
      ! call GetHDF5Attribute ( File, 'verticalCoordinate', str )
      ! call get_string( lit_indices(quantity%template%horizontalCoordinate ), str, strip=.true. )
      ! call GetHDF5Attribute ( File, 'horizontalCoordinate', str )
      ! call get_string( lit_indices(quantity%template%latitudeCoordinate ), str, strip=.true. )
      ! call GetHDF5Attribute ( File, 'latitudeCoordinate', str )
      ! call get_string( lit_indices(quantity%template%frequencyCoordinate ), str, strip=.true. )
      ! call GetHDF5Attribute ( File, 'frequencyCoordinate', str )
    end subroutine readQuantityAttributes
  end subroutine DirectRead_Quantity

  ! ------------------------------------------- DirectWriteVector_EveryQuantity --------
  subroutine DirectWriteVector_EveryQuantity ( File, Vector, &
    & chunkNo, options, rank )

    ! Purpose:
    ! Write plain hdf-formatted files ala l2aux for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out chunk-by-chunk
    
    ! Despite the name the routine takes vector quantities, not l2aux ones
    ! It dooes so an entrire vector's worth of vector quantities
    use MLSStrings, only: WriteIntsToChars
    use String_Table, only: Get_String
    ! Args:
    type (Vector_T), intent(in)   :: VECTOR
    type(MLSFile_T)               :: File
    integer, intent(in)           :: CHUNKNO      ! Index into chunks
    character(len=*), intent(in)  :: options
    integer, intent(in), optional :: rank
    ! Local parameters
    integer                       :: j
    logical                       :: nameQtyByTemplate
    type (VectorValue_T), pointer :: QUANTITY
    character(len=32)             :: SDNAME       ! Name of sd in output file
    logical :: verbose
    ! Executable
    verbose = BeVerbose ( 'direct', -1 )
    nameQtyByTemplate = .not. ( index(options, 'num') > 0 )
    if ( verbose ) then
      if ( vector%name > 0 ) then
        call get_string( vector%name, sdName )
      else
        sdname = '(unknown)'
      endif
      call outputNamedValue( 'DW L2AUX vector name', trim(sdName) )
    endif
    do j = 1, size(vector%quantities)
      quantity => vector%quantities(j)
      if ( nameQtyByTemplate ) then
        call get_string( quantity%template%name, sdname )
      else
        call writeIntsToChars ( j, sdName )
        sdName = 'Quantity ' // trim(sdName)
      endif
      call DirectWrite_Quantity ( File, quantity, sdName, &
        & chunkNo, options, rank )
    enddo
  end subroutine DirectWriteVector_EveryQuantity

  ! ------------------------------------------ DirectWriteVector_L2GP --------
  subroutine DirectWriteVector_L2GP ( L2gpFile, &
    & vector, &
    & chunkNo, chunks, &
    & createSwath, lowerOverlap, upperOverlap, maxChunkSize )
    use Chunks_M, only: MLSChunk_T

    ! Purpose:
    ! Write out all the quantities in a vector as swaths to an hdfeos file
    ! Notes and limitations:
    ! Why don't you also supply an entire vector's worth of
    ! precision, quality, etc.?
    ! Args:
    type(MLSFile_T)               :: L2GPFile
    type (Vector_T), intent(in)   :: VECTOR
    integer, intent(in)              :: chunkNo
    type (MLSChunk_T), dimension(:), intent(in) :: Chunks
    logical, intent(in), optional :: createSwath
    logical, intent(in), optional :: lowerOverlap
    logical, intent(in), optional :: upperOverlap
    integer, intent(in), optional :: maxChunkSize
    ! Local variables
    integer                       :: j
    type (VectorValue_T), pointer :: Quantity
    type (VectorValue_T), pointer :: precision
    type (VectorValue_T), pointer :: quality
    type (VectorValue_T), pointer :: status
    type (VectorValue_T), pointer :: Convergence
    type (VectorValue_T), pointer :: AscDescMode
    character(len=32)             :: SDNAME       ! Name of sd in output file
    ! Executable
    nullify(precision, quality, status, convergence, AscDescMode)
    do j = 1, size(vector%quantities)
      quantity => vector%quantities(j)
      call get_string( quantity%template%name, sdname )
      call DirectWrite_L2GP ( L2gpFile, &
        & quantity, precision, quality, status, Convergence, AscDescMode, &
        & sdName, chunkNo, chunks, createSwath, lowerOverlap, upperOverlap, &
        & maxChunkSize )
    enddo
  end subroutine DirectWriteVector_L2GP

  ! ------------------------------------------ DirectWrite_L2GP --------
  subroutine DirectWrite_L2GP ( L2gpFile, &
    & quantity, precision, quality, status, Convergence, AscDescMode, &
    & sdName, chunkNo, chunks, &
    & createSwath, lowerOverlap, upperOverlap, &
    & maxChunkSize )
    use Chunks_M, only: MLSChunk_T

    ! Purpose:
    ! Write a swath to an hdfeos file composed of 
    ! what              supplied by
    ! l2gpvalues        quantity
    ! l2gpprecision     precision
    ! quality           quality
    ! status            status
    ! Convergence       Convergence
    ! AscDescMode       AscDescMode
    use HDF, only: Dfacc_Create, Dfacc_Rdonly, Dfacc_Rdwr
    use L2GPData, only: L2GPData_T, &
      & AppendL2GPData, DestroyL2GPContents, Dump
    use ReadApriori, only: WriteAPrioriAttributes
    ! Args:
    type(MLSFile_T)               :: L2GPFile
    type (VectorValue_T), intent(in) :: QUANTITY
    type (VectorValue_T), pointer :: precision
    type (VectorValue_T), pointer :: quality
    type (VectorValue_T), pointer :: status
    type (VectorValue_T), pointer :: Convergence
    type (VectorValue_T), pointer :: AscDescMode
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in)              :: chunkNo
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    logical, intent(in), optional :: createSwath
    logical, intent(in), optional :: lowerOverlap
    logical, intent(in), optional :: upperOverlap
    integer, intent(in), optional :: maxChunkSize
    ! Local variables
    logical :: DeeBug
    logical :: alreadyThere
    integer :: FIRSTINSTANCE
    integer :: GRANDTOTALINSTANCES
    type (L2GPData_T) :: l2gp
    integer :: LASTINSTANCE
    integer :: OFFSET
    character(len=8) :: overlaps ! 'lower', 'upper', or 'none'
    integer :: NOTOWRITE
    integer :: TOTALPROFS
    logical :: verbose
    ! Executable
    verbose = BeVerbose ( 'direct', -1 )
    deebug = LetsDebug ( 'direct', 0 )
    if ( verbose ) call outputNamedValue ('DW ChunkNo', ChunkNo )
    if ( present(createSwath) ) then
      alreadyThere = mls_exists( L2GPFile%name ) == 0
      if ( .not. alreadyThere .and. verbose ) &
        & call outputNamedValue( '  creating file', trim(L2GPFile%name) )
      if ( alreadyThere ) &
        & alreadyThere = mls_swath_in_file ( L2GPFile%name, trim(sdname), &
        & L2GPFile%hdfVersion )
      if ( .not. verbose ) then
        ! Remain silent
        overlaps = 'none'
      elseif ( createSwath .and. alreadyThere ) then
        call outputNamedValue( '  recreating swath', trim(sdname) )
      elseif ( createSwath ) then
        call outputNamedValue( '  creating swath', trim(sdname) )
      elseif ( .not. alreadyThere ) then
        call outputNamedValue( '  How can we add to a nonexistent swath?', trim(sdname) )
      else
        call outputNamedValue( '  adding to swath', trim(sdname) )
      endif
    endif
    ! Size the problem
    overlaps = 'none'
    if ( present(lowerOverlap) ) then
      if ( lowerOverlap ) overlaps = 'lower'
    endif
    if ( present(upperOverlap) ) then
      if ( upperOverlap ) overlaps = 'upper'
    endif
    select case ( overlaps )
    case ( 'lower' )
      firstInstance =  1
      lastInstance = quantity%template%noInstancesLowerOverlap
      ! DeeBug = .true.
    case ( 'upper' )
      firstInstance =  quantity%template%noInstances - &
        & quantity%template%noInstancesUpperOverlap + 1
      lastInstance = quantity%template%noInstances
      ! DeeBug = .true.
    case ( 'none' )
      firstInstance = quantity%template%noInstancesLowerOverlap + 1
      lastInstance = quantity%template%noInstances - &
        & quantity%template%noInstancesUpperOverlap
    end select
    noToWrite = lastInstance - firstInstance + 1
    offset = quantity%template%instanceOffset
    grandtotalinstances = quantity%template%grandTotalInstances
    totalProfs = grandtotalinstances
    ! Check sanity
    if ( offset + noToWrite - 1 > grandTotalInstances .and. grandTotalInstances > 0 ) then
      call output('offset: ', advance='no')
      call output(offset, advance='no')
      call output('   noToWrite: ', advance='no')
      call output(noToWrite, advance='no')
      call output('   grandTotalInstances: ', advance='no')
      call output(grandTotalInstances, advance='yes')
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'last profile > grandTotalInstances for ' // trim(sdName), &
        & MLSFile=L2GPFile )
      ! Last-ditch effort resets offset
      offset = max(0, min(offset, grandTotalInstances - noToWrite))
    endif
    if ( L2GPFile%access == DFACC_RDONLY )  &
      & call MLSL2Message( MLSMSG_Error, ModuleName, &
      & 'l2gp file is rdonly', MLSFile=L2GPFile )
    ! Convert vector quantity to l2gp
    call vectorValue_to_l2gp( quantity, &
      & precision, quality, status, convergence, AscDescMode, &
      & l2gp, &
      & sdname, chunkNo, chunks, offset=0, &
      & firstInstance=firstInstance, lastInstance=lastInstance )
    ! Output the l2gp into the file
    ! if ( l2gp%name == 'Temperature-InitPtan' .and. deebug ) then
    if ( deebug ) then
      call output('firstInstance: ', advance='no')
      call output(firstInstance, advance='no')
      call output('  lastInstance: ', advance='no')
      call output(lastInstance, advance='no')
      call output('  TotalProfs: ', advance='no')
      call output(TotalProfs, advance='yes')
      call dump(l2gp, Details=-1)
      call output('instanceOffset: ', advance='no')
      call output(quantity%template%instanceOffset, advance='yes')
      call output('noInstances: ', advance='no')
      call output(quantity%template%noInstances, advance='yes')
      call output('noInstancesLowerOverlap: ', advance='no')
      call output(quantity%template%noInstancesLowerOverlap, advance='yes')
      call output('noInstancesUpperOverlap: ', advance='no')
      call output(quantity%template%noInstancesUpperOverlap, advance='yes')
      call output('grandTotalInstances: ', advance='no')
      call output(quantity%template%grandTotalInstances, advance='yes')
      call dump( l2gp%chunkNumber, 'Appending chunkNumber' )
    endif
    if ( verbose ) call outputNamedValue( 'DW L2GP qty name', trim(sdName) )
    ! call usleep ( delay ) ! Should we make this parallel%delay?
    call usleep ( parallel%delay ) ! Done!
    if ( DEEBUG ) then
      if ( present(createSwath) ) then
        print *, 'create swath? ', createSwath
      else
        print *, 'create swath not present '
      endif
    endif
    call AppendL2GPData( l2gp, l2gpFile, &
      & sdName, offset, lastprofile=lastInstance, &
      & TotNumProfs=TotalProfs, createSwath=createSwath, &
      & maxChunkSize=maxChunkSize )
    if ( L2GPFile%access == DFACC_CREATE ) L2GPFile%access = DFACC_RDWR
    call writeAPrioriAttributes( l2gpFile, dontreplace=.true. )
    if ( switchDetail(switches, 'l2gp') > -1 ) call dump(l2gp)
    ! Clear up our temporary l2gp
    call DestroyL2GPContents(l2gp)
  end subroutine DirectWrite_L2GP

  ! ------------------------------------------- DirectWriteVector_L2Aux --------
  subroutine DirectWriteVector_L2Aux ( L2AUXFile, Vector, &
    & chunkNo, chunks, FWModelConfig, &
    & lowerOverlap, upperOverlap, single, options, groupName )

    ! Purpose:
    ! Write plain hdf-formatted files ala l2aux for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out chunk-by-chunk
    
    ! Despite the name the routine takes vector quantities, not l2aux ones
    ! It dooes so an entrire vector's worth of vector quantities
    use Chunks_M, only: MLSChunk_T
    use ForwardModelConfig, only: ForwardModelConfig_T
    use MLSStrings, only: WriteIntsToChars
    ! Args:
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    type (Vector_T), intent(in)   :: Vector
    type(MLSFile_T)               :: L2auxFile
    integer, intent(in)           :: ChunkNo      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    logical, intent(in), optional :: lowerOverlap
    logical, intent(in), optional :: upperOverlap
    logical, intent(in), optional :: single       ! Write only the 1st instance
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: groupName
    ! Local parameters
    integer                       :: j
    logical                       :: nameQtyByTemplate
    type (VectorValue_T), pointer :: QUANTITY
    type (VectorValue_T), pointer :: PRECISION
    character(len=32)             :: SDNAME       ! Name of sd in output file
    logical                       :: useGroupName
    logical                       :: verbose
    ! Executable
    verbose = BeVerbose ( 'direct', 0 )
    nameQtyByTemplate = .true.
    if ( present(options) ) nameQtyByTemplate = &
      & .not. ( index(options, 'num') > 0 )
    useGroupName = .false.
    if ( present(options) ) useGroupName = &
      & ( index(options, 'g') > 0 ) .and. present( groupName )
    nullify(precision)
    if ( verbose ) then
      if ( vector%name > 0 ) then
        call get_string( vector%name, sdName )
      else
        sdname = '(unknown)'
      endif
      call outputNamedValue( 'DW L2AUX vector name', trim(sdName) )
    endif
    do j = 1, size(vector%quantities)
      quantity => vector%quantities(j)
      if ( nameQtyByTemplate ) then
        call get_string( quantity%template%name, sdname )
      else
        call writeIntsToChars ( j, sdName )
        sdName = 'Quantity ' // trim(sdName)
      endif
      if ( useGroupName ) sdName = trim(groupName) // '/' // sdName
      call DirectWrite_L2Aux ( L2AUXFile, quantity, precision, sdName, &
        & chunkNo, chunks, FWModelConfig, &
        & lowerOverlap, upperOverlap, single, options )
    enddo
  end subroutine DirectWriteVector_L2Aux

  ! ------------------------------------------- DirectWriteVector_Hdf --------
  subroutine DirectWriteVector_Hdf ( L2AUXFile, Vector, &
    & options, groupName )

    ! Purpose:
    ! Write plain hdf-formatted files ala l2aux for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out chunk-by-chunk
    
    ! Despite the name the routine takes vector quantities, not l2aux ones
    ! It dooes so an entrire vector's worth of vector quantities
    use MLSStrings, only: WriteIntsToChars
    ! Args:
    type (Vector_T), intent(in)   :: VECTOR
    type(MLSFile_T)               :: L2AUXFile
    character(len=*), intent(in), optional :: options
    character(len=*), intent(in), optional :: groupName
    ! Local parameters
    integer                       :: j
    logical                       :: nameQtyByTemplate
    type (VectorValue_T), pointer :: QUANTITY
    type (VectorValue_T), pointer :: PRECISION
    character(len=32)             :: SDNAME       ! Name of sd in output file
    logical                       :: useGroupName
    logical                       :: verbose
    ! Executable
    verbose = BeVerbose ( 'direct', 0 )
    nameQtyByTemplate = .true.
    if ( present(options) ) nameQtyByTemplate = &
      & .not. ( index(options, 'num') > 0 )
    useGroupName = .false.
    if ( present(options) ) useGroupName = &
      & ( index(options, 'g') > 0 ) .and. present( groupName )
    nullify(precision)
    if ( verbose ) then
      if ( vector%name > 0 ) then
        call get_string( vector%name, sdName )
      else
        sdname = '(unknown)'
      endif
      call outputNamedValue( 'DW L2AUX vector name', trim(sdName) )
    endif
    do j = 1, size(vector%quantities)
      quantity => vector%quantities(j)
      if ( nameQtyByTemplate ) then
        call get_string( quantity%template%name, sdname )
      else
        call writeIntsToChars ( j, sdName )
        sdName = 'Quantity ' // trim(sdName)
      endif
      if ( useGroupName ) sdName = trim(groupName) // '/' // sdName
      call DirectWrite_Hdf ( L2AUXFile, quantity, precision, sdName, &
        & options )
    enddo
  end subroutine DirectWriteVector_Hdf

  ! ------------------------------------------- DirectWrite_Hdf --------
  subroutine DirectWrite_Hdf ( L2AUXFile, quantity, precision, sdName, &
    & options )

    ! Purpose:
    ! Write plain hdf-formatted files
    use MLSHDF5, only: SaveAsHDF5DS

    ! Args:
    type (VectorValue_T), intent(in) :: QUANTITY
    type (VectorValue_T), pointer :: PRECISION
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    type(MLSFile_T)                :: L2AUXFile
    character(len=*), intent(in), optional :: options
    ! Local parameters
    logical :: alreadyOpen
    logical :: already_there
    ! logical, parameter :: DEEBUG = .false.
    ! logical :: deebughere
    integer :: returnStatus
    ! character(len=*), parameter :: sdDebug = "R1A:118.B1F:PT.S0.FB25-1 Core"
    logical :: verbose
    ! Executable
    verbose = BeVerbose ( 'direct', 0 )
    alreadyOpen = L2AUXFile%stillOpen
    already_There = mls_exists( L2AUXFile%name ) == 0
    if ( .not. already_There ) then
      call outputNamedValue( '  creating file', trim(L2AUXFile%name) )
    elseif ( verbose ) then
      call outputNamedValue( '  no need to recreate file', trim(L2AUXFile%name) )
      call outputNamedValue( '  already open?', alreadyOpen )
    endif
    ! deebughere = ( deebug .or. sdname == sdDebug ) .and. .false.
    if ( .not. alreadyOpen ) then
      call mls_openFile(L2AUXFile, returnStatus)
      if ( returnStatus /= 0 ) &
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Unable to open l2aux file', MLSFile=L2AUXFile )
    endif
    call SaveAsHDF5DS ( L2AUXFile%FileID%f_id, SDname, quantity%values )
    if ( .not. alreadyOpen )  call mls_closeFile(L2AUXFile, returnStatus)
    L2AUXFile%errorCode = returnStatus
    L2AUXFile%lastOperation = 'write'
    if ( switchDetail(switches, 'l2aux') < 0 ) return
    call dump(quantity)
    if ( associated(precision) ) call dump(precision)
  end subroutine DirectWrite_Hdf

  ! ------------------------------------------- DirectWrite_L2Aux --------
  subroutine DirectWrite_L2Aux ( L2AUXFile, quantity, precision, sdName, &
    & chunkNo, chunks, FWModelConfig, &
    & lowerOverlap, upperOverlap, single, options )

    ! Purpose:
    ! Write plain hdf-formatted files ala l2aux for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out chunk-by-chunk
    
    ! Despite the name the routine takes vector quantities, not l2aux ones
    use Chunks_M, only: MLSChunk_T
    use ChunkDivide_M, only: ChunkDivideConfig
    use ForwardModelConfig, only: ForwardModelConfig_T
    use HDF, only: Dfacc_Rdonly

    ! Args:
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    type (VectorValue_T), intent(in) :: QUANTITY
    type (VectorValue_T), pointer :: PRECISION
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    type(MLSFile_T)                :: L2AUXFile
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    logical, intent(in), optional :: lowerOverlap
    logical, intent(in), optional :: upperOverlap
    logical, intent(in), optional :: single       ! Write only the 1st instance
    character(len=*), intent(in), optional :: options
    ! Local parameters
    logical :: alreadyOpen
    logical :: already_there
    logical, parameter :: DEEBUG = .false.
    logical :: deebughere
    integer :: lastMAF
    integer :: returnStatus
    character(len=*), parameter :: sdDebug = "R1A:118.B1F:PT.S0.FB25-1 Core"
    logical :: verbose
    ! Executable
    verbose = BeVerbose ( 'direct', 0 )
    alreadyOpen = L2AUXFile%stillOpen
    already_There = mls_exists( L2AUXFile%name ) == 0
    if ( .not. already_There ) then
      call outputNamedValue( '  creating file', trim(L2AUXFile%name) )
    elseif ( verbose ) then
      call outputNamedValue( '  no need to recreate file', trim(L2AUXFile%name) )
      call outputNamedValue( '  already open?', alreadyOpen )
    endif
    deebughere = ( deebug .or. sdname == sdDebug ) .and. .false.
    lastMAF = (quantity%template%instanceOffset+quantity%template%noInstances - &
        & quantity%template%noInstancesLowerOverlap - &
        & quantity%template%noInstancesUpperOverlap)
    if ( chunkNo == size(chunks) .and. MAYWRITEPOSTOVERLAPS .and. &
      & ChunkDivideConfig%allowPostOverlaps ) &
      & lastMAF = quantity%template%instanceOffset + &
      & quantity%template%noInstances - quantity%template%noInstancesLowerOverlap
    if ( .not. alreadyOpen ) then
      call mls_openFile(L2AUXFile, returnStatus)
      if ( returnStatus /= 0 ) &
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Unable to open l2aux file', MLSFile=L2AUXFile )
    endif
    if ( L2AUXFile%access == DFACC_RDONLY )  &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'l2aux file is rdonly', MLSFile=L2AUXFile )
    if ( (lastProfTooBigWarns <= MAXNUMWARNS) &
      & .and. &
      & (quantity%template%instanceOffset+quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap) &
      & > &
      & quantity%template%grandTotalInstances &
      & .and. &
      & quantity%template%grandTotalInstances > 0 ) then
      lastProfTooBigWarns = lastProfTooBigWarns + 1
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'last profile > grandTotalInstances for ' // trim(sdName), &
          & MLSFile=L2AUXFile)
      call output('instanceOffset: ', advance='no')
      call output(quantity%template%instanceOffset, advance='yes')
      call output('noInstances: ', advance='no')
      call output(quantity%template%noInstances, advance='yes')
      call output('noInstancesLowerOverlap: ', advance='no')
      call output(quantity%template%noInstancesLowerOverlap, advance='yes')
      call output('noInstancesUpperOverlap: ', advance='no')
      call output(quantity%template%noInstancesUpperOverlap, advance='yes')
      call output('last instance: ', advance='no')
      call output(lastMAF, advance='yes')
      call output('grandTotalInstances: ', advance='no')
      call output(quantity%template%grandTotalInstances, advance='yes')
      if ( lastProfTooBigWarns > MAXNUMWARNS ) &
          & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'Max no. of warnings reached--suppressing further ones')
    endif
    if ( deebughere ) then
      print *, 'Direct Writing to ', trim(L2AUXFile%name)
      print *, 'hdfVersion ', L2AUXFile%hdfVersion
      call output('instanceOffset: ', advance='no')
      call output(quantity%template%instanceOffset, advance='yes')
      call output('noInstances: ', advance='no')
      call output(quantity%template%noInstances, advance='yes')
      call output('noInstancesLowerOverlap: ', advance='no')
      call output(quantity%template%noInstancesLowerOverlap, advance='yes')
      call output('noInstancesUpperOverlap: ', advance='no')
      call output(quantity%template%noInstancesUpperOverlap, advance='yes')
      call output('last profile: ', advance='no')
      call output(lastMAF, advance='yes')
      call output('grandTotalInstances: ', advance='no')
      call output(quantity%template%grandTotalInstances, advance='yes')
    endif
    select case (l2AUXFile%hdfversion)
    case (HDFVERSION_4)
      call DirectWrite_L2Aux_hdf4 ( quantity, sdName, L2AUXFile, &
        & chunkNo, chunks, &
        & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
      if ( associated(precision) ) & 
        & call DirectWrite_L2Aux_hdf4 ( precision, &
        & trim(sdName) // 'precision', L2AUXFile, chunkNo, chunks, &
        & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
    case (HDFVERSION_5)
      call DirectWrite_L2Aux_hdf5 ( quantity, sdName, L2AUXFile, &
        & chunkNo, chunks, &
        & FWModelConfig, lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
        & single=single, options=options )
      if ( associated(precision) ) & 
        & call DirectWrite_L2Aux_hdf5 ( precision, &
        & trim(sdName) // 'precision', L2AUXFile, chunkNo, chunks, &
        & FWModelConfig, lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, &
        & single=single, options=options )
    case default
      call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Unsupported hdfVersion for DirectWrite_L2Aux (currently only 4 or 5)' )
    end select
    if ( verbose ) call outputNamedValue( 'DW L2AUX qty name', trim(sdName) )
    if ( .not. alreadyOpen )  call mls_closeFile(L2AUXFile, returnStatus)
    L2AUXFile%errorCode = returnStatus
    L2AUXFile%lastOperation = 'write'
    if ( switchDetail(switches, 'l2aux') < 0 ) return
    call dump(quantity)
    if ( associated(precision) ) call dump(precision)
  end subroutine DirectWrite_L2Aux

  ! ------------------------------------------ DirectWrite_L2Aux_hdf4 --------
  subroutine DirectWrite_L2Aux_hdf4 ( quantity, sdName, L2AUXFile, &
    & chunkNo, chunks, lowerOverlap, upperOverlap )

    use Chunks_M, only: MLSChunk_T
    use HDF, only: Sfn2index, Sfselect, Sfcreate, &
      & Sfendacc, Dfnt_Float32, SfwData_F90
    use Intrinsic, only: L_None
    use MLSKinds, only: R4, R8

    ! Args:
    type (VectorValue_T), intent(in) :: QUANTITY
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    type(MLSFile_T)                :: L2AUXFile
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    logical, intent(in), optional :: lowerOverlap
    logical, intent(in), optional :: upperOverlap

    ! Local variables
    integer :: SDINDEX                  ! Index of sd
    integer :: SDID                     ! Handle for sd
    integer :: STATUS                   ! Status flag
    integer :: START(3)                 ! HDF array starting position
    integer :: STRIDE(3)                ! HDF array stride
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: NODIMS                   ! Also index of maf dimension
    type ( MLSChunk_T ) :: LASTCHUNK    ! The last chunk in the file
    real (r8) :: HUGER4

    ! executable code

    hugeR4 = real ( huge(0.0_r4), r8 )

    if ( quantity%template%frequencyCoordinate == L_None ) then
      noDims = 2
    else
      noDims = 3
    end if

    ! Create or access the SD
    sdIndex = sfn2index ( L2AUXFile%fileID%f_id, trim(sdName) )
    if ( sdIndex == -1 ) then
      lastChunk = chunks(size(chunks))
      sizes(noDims) = lastChunk%lastMAFIndex - lastChunk%noMAFSUpperOverlap + 1
      sizes(noDims-1) = quantity%template%noSurfs
      if ( noDims == 3 ) sizes(1) = quantity%template%noChans
      sdId  = sfCreate ( L2AUXFile%fileID%f_id, trim(sdName), DFNT_FLOAT32, &
        & noDims, sizes )
    else
      sdId = sfSelect ( L2AUXFile%fileID%f_id, sdIndex )
    end if
    if ( sdId == -1 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
     & 'Error accessing SD '//trim(sdName) // ' (hdf4)', MLSFile=L2AUXFile)

    ! What exactly will be our contribution
    stride = 1
    start = 0
    sizes = 1
    sizes(noDims) = quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap
    sizes(noDims-1) = quantity%template%noSurfs
    if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    start(noDims) = quantity%template%instanceOffset

    ! Now write it out
    status = 0
    if ( sizes(noDims) > 0 ) &
      & status = SFWDATA_F90(sdId, start(1:noDims), &
      & stride(1:noDims), sizes(1:noDims), &
      & real ( max ( -hugeR4, min ( hugeR4, &
      &   quantity%values ( :, &
      &   1+quantity%template%noInstancesLowerOverlap : &
      &    quantity%template%noInstances - quantity%template%noInstancesUpperOverlap &
      &  ) ) ) ) )
    if ( status /= 0 ) then
      call announce_error (0,&
        & "Error writing SDS data " // trim(sdName) // " to l2aux file:  " )
    end if
    if ( DEEBUG ) then
      call output('noDims: ', advance='no')
      call output(noDims, advance='yes')
      call output('start: ', advance='no')
      call output(start, advance='yes')
      call output('stride: ', advance='no')
      call output(stride, advance='yes')
      call output('sizes: ', advance='no')
      call output(sizes, advance='yes')
      call output('shape(values): ', advance='no')
      call output(shape(quantity%values), advance='yes')
      call output('first instance: ', advance='no')
      call output(1+quantity%template%noInstancesLowerOverlap, advance='yes')
      call output('last instance: ', advance='no')
      call output(quantity%template%noInstances &
        & - quantity%template%noInstancesUpperOverlap, advance='yes')
    end if

    ! End access to the SD and close the file
    status = sfEndAcc ( sdId )
    if ( status == -1 ) call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Error ending access to direct write sd (hdf4)', MLSFile=L2AUXFile )

  end subroutine DirectWrite_L2Aux_hdf4

  ! ------------------------------------------ DirectWrite_L2Aux_hdf5 --------
  subroutine DirectWrite_L2Aux_hdf5 ( quantity, sdName, L2AUXFile, &
    & chunkNo, chunks, FWModelConfig, &
    & lowerOverlap, upperOverlap, single, options )

    use Chunks_M, only: MLSChunk_T
    use ChunkDivide_M, only: ChunkDivideConfig
    use ForwardModelConfig, only: ForwardModelConfig_T
    use ForwardModelSupport, only: Showfwdmodelnames
    use HDF5, only: H5gclose_F, H5gopen_F
    use Intrinsic, only: L_None
    use L2AuxData, only: L2AuxData_T, PhaseNameAttributes, &
      & DestroyL2Auxcontents, &
      & SetupnewL2Auxrecord, WriteL2Auxattributes, WriteHDF5Data
    use MLSHDF5, only: IsHDF5attributepresent, IsHDF5dspresent, &
      & MakeHDF5Attribute
    use MLSL2Timings, only: ShowTimingNames
    use PCFHdr, only: H5_WriteMLSFileattr, H5_Writeglobalattr
    use QuantityTemplates, only: WriteAttributes

    ! Args:
    type (VectorValue_T), intent(in) :: QUANTITY
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    type(MLSFile_T)                :: L2AUXFile
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    logical, intent(in), optional :: lowerOverlap
    logical, intent(in), optional :: upperOverlap
    logical, intent(in), optional :: single       ! Write 1st instance only
    character(len=*), intent(in), optional :: options

    ! Local variables
    logical :: addQtyAttributes
    logical :: already_there
    ! logical :: attributes_there
    ! character(len=128) :: barename
    integer :: first_maf
    ! character(len=128), dimension(25) :: groupNames
    integer :: grp_id
    type (L2AUXData_T) :: l2aux
    integer :: last_maf
    type ( MLSChunk_T ) :: LASTCHUNK    ! The last chunk in the file
    logical :: mySingle
    ! integer :: n
    integer :: NODIMS                   ! Also index of maf dimension
    integer :: Num_qty_values
    character(len=8) :: overlaps        ! 'lower', 'upper', or 'none'
    ! character(len=1024) :: path
    integer :: returnStatus
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: START(3)                 ! HDF array starting position
    integer :: total_DS_size
    logical, parameter :: MAYCOLLAPSEDIMS = .false.
    ! logical, parameter :: DEEBUG = .true.
    logical :: verbose

    ! executable code
    verbose = BeVerbose ( 'direct', 0 )
    Num_qty_values = size(quantity%values, 1)*size(quantity%values, 2)
    addQtyAttributes = .false.
    if ( present(options) ) addQtyAttributes = ( index(options, 'A') > 0 )
    if ( quantity%template%frequencyCoordinate == L_None &
      & .and. MAYCOLLAPSEDIMS) then
      noDims = 2
    else
      noDims = 3
    end if
    
    overlaps = 'none'
    if ( present(lowerOverlap) ) then
      if ( lowerOverlap ) overlaps = 'lower'
    endif
    if ( present(upperOverlap) ) then
      if ( upperOverlap ) overlaps = 'upper'
    endif
    
    mySingle = .false.
    if ( present(single) ) mySingle = single

    ! Create or access the SD
    already_There = mls_exists( L2AUXFile%name ) == 0
    if ( .not. already_There ) &
      & call outputNamedValue( '  creating file', trim(L2AUXFile%name) )
    already_there = IsHDF5DSPresent(L2AUXFile%fileID%f_id, trim(sdName))
    if ( .not. already_there ) then
      call outputNamedValue( '  creating sd', trim(sdname) )
      lastChunk = chunks(size(chunks))
      sizes(noDims) = lastChunk%lastMAFIndex - lastChunk%noMAFSUpperOverlap + 1
      if ( MAYWRITEPOSTOVERLAPS .and. ChunkDivideConfig%allowPostOverlaps ) &
        & sizes(noDims) = lastChunk%lastMAFIndex + 1
      sizes(noDims-1) = quantity%template%noSurfs
      if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    elseif ( verbose )then
      call outputNamedValue( '  adding to sd', trim(sdname) )
    end if

    ! What exactly will be our contribution
    start = 0
    sizes = 1
    sizes(noDims-1) = quantity%template%noSurfs
    if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    start(noDims) = quantity%template%instanceOffset
    select case ( overlaps )
    case ( 'lower' )
      sizes(noDims) = quantity%template%noInstancesLowerOverlap
      first_maf = 1
      last_maf = quantity%template%noInstances
    case ( 'upper' )
      sizes(noDims) = quantity%template%noInstancesUpperOverlap
      first_maf = quantity%template%noInstances &
        &       - quantity%template%noInstancesUpperOverlap + 1
      last_maf = quantity%template%noInstances
    case ( 'none' )
      sizes(noDims) = quantity%template%noInstances - &
        & quantity%template%noInstancesLowerOverlap - &
        & quantity%template%noInstancesUpperOverlap
      if ( MAYWRITEPOSTOVERLAPS .and. ChunkDivideConfig%allowPostOverlaps .and. &
        & chunkNo == size(chunks) ) &
        & sizes(noDims) = quantity%template%noInstances - &
        & quantity%template%noInstancesLowerOverlap
      first_maf = 1+quantity%template%noInstancesLowerOverlap
      last_maf = quantity%template%noInstances &
        &       - quantity%template%noInstancesUpperOverlap
      if ( MAYWRITEPOSTOVERLAPS .and. ChunkDivideConfig%allowPostOverlaps .and. &
        & chunkNo == size(chunks) ) &
        & last_maf = quantity%template%noInstances
    end select
    
    if ( mySingle ) then
      ! In case we write only the 1st instance
      last_maf = first_maf
      sizes(noDims) = 1
    endif

    if ( DEEBUG ) then
      print *, 'sdname ', trim(sdName)
      print *, 'already_there ', already_there
      print *, 'noDims ', noDims
      print *, 'instanceOffset ', quantity%template%instanceOffset
      print *, 'minorFrame ', quantity%template%minorFrame
      print *, 'start ', start
      print *, 'sizes ', sizes
      print *, 'shape(quantity%values) ', shape(quantity%values)
      print *, 'first_maf ', first_maf
      print *, 'last_maf ', last_maf
    endif
    ! Make certain things will fit
    if ( noDims == 3 ) then
      total_DS_size = sizes(1)*sizes(2)*sizes(3)
      if ( DEEBUG ) then
        print *, 'total_DS_size ', total_DS_size
        print *, 'Num_qty_values ', Num_qty_values
      endif
      if ( total_DS_size > Num_qty_values ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Number of 3d array elements to write > number stored in qty values', &
        & MLSFile=L2AUXFile )
      call WriteHDF5Data (  real( &
        &   reshape(quantity%values(:,first_maf:last_maf), sizes(1:3)) &
        & ), L2AUXFile%FileID%f_id, &
        & returnStatus, trim(sdname), already_there, &
        & start, sizes )
    else
      total_DS_size = sizes(1)*sizes(2)
      if ( DEEBUG ) then
        print *, 'total_DS_size ', total_DS_size
        print *, 'Num_qty_values ', Num_qty_values
      endif
      if ( total_DS_size > Num_qty_values ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Number of 2d array elements to write > number stored in qty values', &
        & MLSFile=L2AUXFile )
      call WriteHDF5Data (  real( &
        &   reshape(quantity%values(:,first_maf:last_maf), sizes(1:2)) &
        & ), L2AUXFile%FileID%f_id, &
        & returnStatus, trim(sdname), already_there, &
        & start(1:2), sizes(1:2) )
    endif

    ! call mls_CloseFile(L2AUXFILE)
    ! attributes_there = IsHDF5AttributeInFile( L2AUXFile%name, 'Phase Names' )
    ! call mls_OpenFile(L2AUXFILE)
    ! attributes_there = .false.
    ! Now some attribute stuff
    if ( PHASENAMEATTRIBUTES ) then
      if ( DeeBUG ) call dump(L2AUXFile, details=1)
      call h5gopen_f(L2AUXFile%fileID%f_id, '/', grp_id, returnstatus)
      if ( returnstatus /= 0 ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Unable to open group "/" to write attribute', &
        & MLSFile=L2AUXFile )
      if ( associated ( FWModelConfig ) ) then
        call MakeHDF5Attribute(grp_id, &
          & 'ForwardModel Names', ShowFwdModelNames(FWModelConfig), &
          & skip_if_already_there=.false., dont_trim=.true.)
      end if
      call MakeHDF5Attribute(grp_id, &
        & 'Phase Names', showTimingNames('phases', .true.), &
        & skip_if_already_there=.false., dont_trim=.true.)
      call MakeHDF5Attribute(grp_id, &
       & 'MiscNotes', GlobalAttributes%MiscNotes, .true.)
      call h5gclose_f(grp_id, returnstatus)
    endif

    if ( already_there ) return
    ! sd-level attributes
    call SetupNewL2AUXRecord ( L2AUX, quantity%template, &
      & first_MAF, last_MAF-first_MAF+1 )
    if ( DEEBUG ) then
      call output('Writing attributes to: ', advance='no')
      call output(trim(sdName), advance='yes')
    endif
    call WriteL2AUXAttributes(L2AUXFile%fileID%f_id, l2aux, trim(sdName))
    if ( addQtyAttributes ) &
      & call WriteAttributes ( L2AUXFile%fileID%f_id, trim(sdName), quantity%template )
    ! Deallocate memory used by the l2aux
    call DestroyL2AUXContents ( l2aux )
    ! file-level attributes
    call h5_writeglobalattr(L2AUXFile%fileID%f_id, skip_if_already_there=.true.)
    if ( PHASENAMEATTRIBUTES ) then
      call h5gopen_f(L2AUXFile%fileID%f_id, '/', grp_id, returnstatus)
      if ( .not. &
        & IsHDF5AttributePresent('/', L2AUXFile%fileID%f_id, 'Section Names') ) &
        & call MakeHDF5Attribute(grp_id, &
        & 'Section Names', trim(showTimingNames('sections', .true.)), .true.)
      call h5gclose_f(grp_id, returnstatus)
    endif
    if ( WRITEFILEATTRIBUTES ) call h5_writeMLSFileAttr(L2AUXFile, skip_if_already_there=.true.)

  end subroutine DirectWrite_L2Aux_hdf5

  ! ------------------------------------------ DirectWrite_Quantity --------
  ! We write the quantity to a file, chunk by chunk, overlaps and all
  ! E.g., the qtyname is 'Q', and we have written chunks 1 and 2. Then the
  ! file layout will be
  ! /
  !   Q/
  !     1/
  !       values
  !       lons
  !       lats
  !         ...
  !     2/
  !       values
  !       lons
  !       lats
  !         ...
  
  ! Alternative use: we may instead the contents of an input file as if it
  ! contained the quantity values
  !
  subroutine DirectWrite_Quantity ( File, Quantity, QtyName, &
    & ChunkNo, Options, Rank, inputFile )

    use HDF5, only: H5gclose_F, H5gcreate_F, H5gopen_F
    use Intrinsic, only: Lit_Indices
    use MLSHDF5, only: IsHDF5grouppresent, &
      & MakeHDF5attribute, SaveasHDF5ds
    use MLSL2Options, only: MLSL2Message
    use MLSSTrings, only: Writeintstochars
    use MoreMessage, only: MoreMLSMessage => MLSMessage
    ! Args:
    type(MLSFile_T)                  :: File
    type (VectorValue_T), intent(in) :: Quantity
    character(len=*), intent(in)     :: QtyName  ! Name of qty in output file
    integer, intent(in)              :: ChunkNo  ! Index into chunks
    character(len=*), intent(in), optional :: Options
    integer, intent(in), optional    :: Rank
    character(len=*), intent(in), optional :: inputFile

    ! Local variables
    logical :: already_there
    ! logical :: attributes_there
    integer :: grp_id
    integer :: myRank
    character(len=10) :: chunkStr ! chunk number '1', '2', ..,
    integer :: returnStatus
    integer :: TrueRank ! of the quantity's value
    ! logical, parameter :: DEEBUG = .true.
    logical :: verbose

    ! executable code
    verbose = BeVerbose ( 'direct', -1 )
    myRank = 2
    if ( present(rank) ) then
      if ( rank < 5 ) myRank = rank
      ! call outputNamedValue ( 'input rank', rank )
    end if
    call writeIntsToChars ( chunkNo, chunkStr )
    chunkStr = adjustl ( chunkStr )
    ! Create or access the SD
    already_There = mls_exists( File%name ) == 0
    if ( .not. already_There ) then
      call outputNamedValue( '  creating file', trim(File%name) )
    end if
    call mls_openFile ( File, returnStatus )
    already_there = IsHDF5GroupPresent( File%fileID%f_id, trim(qtyName) )
    if ( .not. already_There ) then
      if ( verbose ) call outputNamedValue( '  creating file', trim(File%name) )
      call h5GCreate_f ( File%fileID%f_id, qtyName, grp_id, returnStatus )
      if ( returnStatus /= 0 ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Unable to create group ' // trim(qtyName), MLSFile=File )
      call writeQuantityAttributes ( grp_id, quantity )
    else
      call h5GOpen_f ( File%fileID%f_id, qtyName, grp_id, returnStatus )
      if ( returnStatus /= 0 ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Unable to open group ' // trim(qtyName), MLSFile=File )
    end if
    File%fileID%grp_id = grp_id
    call h5GCreate_f ( File%fileID%grp_id, chunkStr, grp_id, returnStatus )
    if ( returnStatus /= 0 ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'Unable to create group ' // trim(chunkStr), MLSFile=File )
    ! Begin the writes
    ! Values
    ! Are we getting the values from an input file?
    if ( present(inputFile) ) then
      if ( verbose ) call outputNamedValue( 'inputFile', trim(inputFile) )
      call SaveAsHDF5DS ( inputFile, grp_id, &
        & 'values', maxLineLen=4096, fromNull='@@' )
    else
    
      ! call outputNamedValue ( 'rank', myRank )
      trueRank = 2 + merge(1,0,quantity%template%noChans>1) + &
               &     merge(1,0,quantity%template%noCrossTrack>1)
      if ( myRank <= 0 ) then
        myRank = trueRank
      else if ( trueRank > myRank ) then
        call MoreMLSMessage ( MLSMSG_Warning, moduleName, "Actual rank of Value %S is " // &
          & " %D but the specified rank is %D.  Are you sure this is what you want?", &
          & datum=[ quantity%template%name, trueRank, myRank] )
      end if
      select case ( myRank )
      case ( 1 )
        call SaveAsHDF5DS( grp_id, 'values', quantity%value1 )
      case ( 2 )
        call SaveAsHDF5DS( grp_id, 'values', quantity%values )
      case ( 3 )
        call SaveAsHDF5DS( grp_id, 'values', quantity%value3 )
      case ( 4 )
        call SaveAsHDF5DS( grp_id, 'values', quantity%value4 )
      case default
        call SaveAsHDF5DS( grp_id, 'values', quantity%values )
      end select
    endif
    ! Geolocations
    call SaveAsHDF5DS( grp_id, 'surfs', quantity%template%surfs )
    if ( associated(quantity%template%Geolocation) ) &
  & call SaveAsHDF5DS( grp_id, 'Geolocation', quantity%template%Geolocation )
    if ( allocated(quantity%template%Phi) ) &
  & call SaveAsHDF5DS( grp_id, 'Phi        ', quantity%template%Phi         )
    call SaveAsHDF5DS( grp_id, 'GeodLat    ', quantity%template%GeodLat     )
    call SaveAsHDF5DS( grp_id, 'Lon        ', quantity%template%Lon         )
    call SaveAsHDF5DS( grp_id, 'Time       ', quantity%template%Time        )
    call SaveAsHDF5DS( grp_id, 'SolarTime  ', quantity%template%SolarTime   )
    call SaveAsHDF5DS( grp_id, 'SolarZenith', quantity%template%SolarZenith )
    call SaveAsHDF5DS( grp_id, 'LosAngle   ', quantity%template%LosAngle    )
    if ( associated(quantity%template%CrossAngles) ) &
  & call SaveAsHDF5DS( grp_id, 'CrossAngles', quantity%template%CrossAngles )
    if ( associated(quantity%template%Frequencies) ) &
  & call SaveAsHDF5DS( grp_id, 'Frequencies', quantity%template%Frequencies )
    if ( associated(quantity%template%ChanInds) ) &
  & call SaveAsHDF5DS( grp_id, 'ChanInds   ', quantity%template%ChanInds    )
    
    ! Close everything up
    call h5GClose_f ( grp_id, returnStatus )
    if ( returnStatus /= 0 ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'Unable to close chunk group ' // trim(chunkStr), MLSFile=File )
    call h5GClose_f ( File%fileID%grp_id, returnStatus )
    if ( returnStatus /= 0 ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & 'Unable to close qty group ' // trim(qtyName), MLSFile=File )

    call mls_CloseFile( File )
  contains
    subroutine writeQuantityAttributes ( locID, quantity )
      ! Args
      integer, intent(in) :: locID
      type (VectorValue_T), intent(in) :: QUANTITY
      ! Local variables
      character(len=80) :: str
      ! Executable
      call get_string( lit_indices(quantity%template%quantityType ), str, strip=.true. )
      call MakeHDF5Attribute ( locID, 'type', str )

      call MakeHDF5Attribute ( locID, 'NoSurfs', quantity%template%NoSurfs )
      call MakeHDF5Attribute ( locID, 'NoChans', quantity%template%NoChans )
      call MakeHDF5Attribute ( locID, 'NoCrossTrack', quantity%template%NoCrossTrack )
      call MakeHDF5Attribute ( locID, 'coherent', quantity%template%coherent )
      call MakeHDF5Attribute ( locID, 'stacked', quantity%template%stacked )
      call MakeHDF5Attribute ( locID, 'regular', quantity%template%regular )
      call MakeHDF5Attribute ( locID, 'minorFrame', quantity%template%minorFrame )
      call MakeHDF5Attribute ( locID, 'majorFrame', quantity%template%majorFrame )
      call MakeHDF5Attribute ( locID, 'logBasis', quantity%template%logBasis )
      call MakeHDF5Attribute ( locID, 'minValue', quantity%template%minValue )
      call MakeHDF5Attribute ( locID, 'badValue', quantity%template%badValue )

      call get_string( lit_indices(quantity%template%unit ), str, strip=.true. )
      call MakeHDF5Attribute ( locID, 'unit', str )
      call get_string( lit_indices(quantity%template%verticalCoordinate ), str, strip=.true. )
      call MakeHDF5Attribute ( locID, 'verticalCoordinate', str )
      call get_string( lit_indices(quantity%template%horizontalCoordinate ), str, strip=.true. )
      call MakeHDF5Attribute ( locID, 'horizontalCoordinate', str )
      call get_string( lit_indices(quantity%template%latitudeCoordinate ), str, strip=.true. )
      call MakeHDF5Attribute ( locID, 'latitudeCoordinate', str )
      call get_string( lit_indices(quantity%template%frequencyCoordinate ), str, strip=.true. )
      call MakeHDF5Attribute ( locID, 'frequencyCoordinate', str )
    end subroutine writeQuantityAttributes
  end subroutine DirectWrite_Quantity

  !------------------------------------------  DumpDirectDB  -----
  subroutine DumpDirectDB ( directDB, Details )

    ! This routine dumps the DirectWrite DB

    ! Dummy arguments
    type (DirectData_T), dimension(:), pointer  :: directDB
    integer, intent(in), optional :: DETAILS

    ! Local variables
    character(len=256), dimension(:,:), pointer :: array
    integer :: i
    integer :: myDetails
    integer :: n
    ! Executable
    myDetails = 1
    if ( present(details) ) myDetails = details
    call output ( '========== DirectWrite Data Base ==========', advance='yes' )
    call output ( ' ', advance='yes' )
    if ( .not. associated(directDB) ) then
      call output ( '**** directWrite Database empty ****', advance='yes' )
      return
    elseif ( size(directDB) < 1 ) then
      call output ( '**** directWrite Database empty ****', advance='yes' )
      return
    endif
    if ( myDetails < -1 ) then
      nullify( array )
      n = size(directDB)
      allocate( array(n+1, 2 ) )
      array(1,1) = 'name'
      array(1,2) = 'path'
      do i = 1, size(directDB)
        call split_path_name( directDB(i)%filename, array(i+1, 2), array(i+1, 1) )
      end do
      call outputTable( array, border='-', headliner='-' )
      deallocate( array )
    else
      do i = 1, size(directDB)
        call DumpDirectWrite(directDB(i), Details)
      end do
    endif
  end subroutine DumpDirectDB

  !------------------------------------------  DumpDirectWrite  -----
  subroutine DumpDirectWrite ( directWrite, Details )

    ! This routine dumps the DirectWrite DB

    ! Dummy arguments
    type (DirectData_T)  :: directWrite
    integer, intent(in), optional :: DETAILS

    ! Local variables
    integer :: i
    integer :: myDetails
    ! Executable
    myDetails = 1
    if ( present(details) ) myDetails = details

    if ( myDetails > -2 ) then
      call output ( 'File Name index: ')
      call output ( directWrite%fileIndex )
      call output ( '   File Name (base): ')
      call output ( trim(directWrite%fileNameBase), advance='yes' )
    endif
    call output ( 'Full File Name  : ')
    call output ( trim(directWrite%fileName), advance='yes' )
    if ( myDetails < -1 ) return
    call output ( 'Type  : ')
    call output ( directWrite%type, advance='no' )
    call blanks ( 3 )
    if ( directWrite%type == l_l2aux ) then
      call output ( '(l2aux)', advance='yes')
    elseif ( directWrite%type == l_l2gp ) then
      call output ( '(l2gp)', advance='yes')
    elseif ( directWrite%type == l_l2dgg ) then
      call output ( '(l2dgg)', advance='yes')
    elseif ( directWrite%type == l_l2fwm ) then
      call output ( '(l2fwm)', advance='yes')
    else
      call output ( '(unknown)', advance='yes')
    endif
    if ( directWrite%autoType < 1 ) then
      call output ( '(Is not', advance='no')
    else
      call output ( '(Is', advance='no')
    endif
    call output (' eligible to be auto-filled)', advance='yes' )
    call output ( 'Handle  : ')
    call output ( directWrite%Handle, advance='yes' )
    call output ( 'Num sci. datasets  : ')
    call output ( directWrite%NSDNames, advance='yes' )
    if ( .not. associated(directWrite%SDNames)  .or. myDetails < 1 ) then
      call output ( 's.d. names not associated', advance='yes' )
      return
    endif
    do i = 1, size(directWrite%sdNames)
      call blanks ( 3 )
      call output(trim(directWrite%SDNames(i)), advance='yes')
    end do
  end subroutine DumpDirectWrite

  !------------------------------------------  ExpandDirectDB  -----
  subroutine ExpandDirectDB ( directDB, fileNameBase, directData, isNew )

    ! This routine expands the DirectWrite DB if necessary
    ! Returning either a match or a new one

    ! Dummy arguments
    type (DirectData_T), dimension(:), pointer  :: directDB
    type (DirectData_T), pointer :: directData
    character(len=*), intent(in) :: fileNameBase
    logical, intent(out) :: isNew

    ! Local variables
    integer :: dbID
    type (DirectData_T)                      :: tempDirectData
    ! Begin executable
    isNew = .true.
    ! Do we have any database yet?
    if ( size(directDB) < 1 ) then
      ! print *, 'Setting up initial database with ', trim(fileNameBase)
      call SetupNewDirect(tempDirectData, 0)
      dbID = AddDirectToDatabase( directDB, tempDirectData )
      directData => directDB(dbID)
    else
      ! Check if the fileNameBase already there
      ! print *, 'Checking if ', trim(fileNameBase), ' is in database'
      do dbID = 1, size(directDB)
        ! print *, dbID, trim(directDB(dbID)%fileNameBase)
      enddo
      dbID = FindFirst(fileNameBase == directDB%fileNameBase)
      if ( dbID > 0 ) then
        directData => directDB(dbID)
        isNew = .false.
        ! print *, 'Recognized ', trim(fileNameBase), ' in ', trim(directData%FileName)
      else
        call SetupNewDirect(tempDirectData, 0)
        dbID = AddDirectToDatabase( directDB, tempDirectData )
        directData => directDB(dbID)
        ! print *, 'Adding to database ', trim(fileNameBase)
      endif
    endif
  end subroutine ExpandDirectDB

  !------------------------------------------  ExpandSDNames  -----
  subroutine ExpandSDNames ( directData, sdName )
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test

    ! This routine adds to the sdNames arrays for a DirectWrite if necessary

    ! Dummy arguments
    type (DirectData_T), intent(inout)  :: directData
    character(len=*), intent(in) :: sdName

    ! Local variables
    logical :: alreadyThere
    integer :: i
    integer :: newsize
    character(len=80), dimension(:), pointer :: sdNames
    ! Check if the sdName already there
    ! print *, 'Check if the sdName already there'
    nullify ( sdNames )
    if ( associated(directData%sdNames) ) then
      newSize=SIZE(directData%sdNames)+1
      ! alreadyThere = any(sdName == directData%sdNames)
      alreadyThere = .false.
      do i=1, size(directData%sdNames)
        alreadyThere = alreadyThere .or. (sdName == directData%sdNames(i))
      end do
      ! if ( alreadyThere ) print *, trim(sdName), ' already there'
      if ( alreadyThere ) return
    else
      ! print *, 'Allocating for ', trim(sdName)
      newSize=1
    end if
    directData%NsdNames = newsize
    ! print *, ' allocating ', newsize
    call allocate_test ( sdNames, newSize, "sdNames", moduleName )
    if ( newSize>1 ) sdNames(1:newSize-1) = directData%sdNames
    if ( associated(directData%sdNames) ) &
      call deallocate_test ( directData%sdNames, "directData%sdNames", &
        & moduleName )
    directData%sdNames => sdNames
    directData%sdNames(newSize) = sdName
  end subroutine ExpandSDNames

  !------------------------------------------  FileNameToID  -----
  function FileNameToID ( fileName, DataBase )  result(ID)

    ! Given filename, returns index; if name not found in db, returns 0

    ! Dummy arguments
    type (DirectData_T), dimension(:), pointer :: DATABASE
    character(len=*), intent(in) :: FileName
    integer                      :: ID

    ! Local variables
    ! Executable
    id = 0
    if ( .not. associated(dataBase) .or. len_trim(filename) < 1 ) return
    do id =1, size(database)
      if ( fileName == dataBase(id)%fileName ) exit
      if ( fileName == dataBase(id)%fileNameBase ) exit
    enddo
    if ( id > size(database) ) id = 0
  end function FileNameToID

  !------------------------------------------  SetupNewDirect  -----
  subroutine SetupNewDirect ( directData, NsdNames )

    ! This routine sets up the arrays for a directWrite

    ! Dummy arguments
    type (DirectData_T), intent(inout)  :: directData
    integer, intent(in) :: NsdNames            ! Dimensions

    ! Allocate the sdNames
    directData%autoType = 0
    directData%Handle = 0
    directData%Type = 0
    directData%NSDNames = NSDNames
    directData%FileNameBase = ' '
    directData%FileName = ' '
    nullify(directData%sdNames)
    if ( NSDNames <= 0 ) return
    call allocate_test ( directData%sdNames, NsdNames, "directData%sdNames", &
         & ModuleName )
  end subroutine SetupNewDirect

! =====     Private Procedures     =====================================
  ! ---------------------------------------------  vectorValue_to_l2gp  -----
  subroutine vectorValue_to_l2gp ( quantity, &
    & precision, quality, status, convergence, AscDescMode, &
    & l2gp, name, chunkNo, chunks, offset, firstInstance, lastInstance )
    use Chunks_M, only: MLSChunk_T
    use Dump_0, only: Dump
    use Intrinsic, only: L_None, Lit_Indices, L_GPH
    use L2GPData, only: AscDescModeIsField, DescendingRange, L2GPData_T, RGP, &
      & SetupNewL2GPRecord
    use QuantityTemplates, only: Dump
    ! Args:
    type (VectorValue_T), intent(in) :: quantity
    type (VectorValue_T), pointer    :: precision
    type (VectorValue_T), pointer    :: quality
    type (VectorValue_T), pointer    :: status
    type (VectorValue_T), pointer    :: convergence
    type (VectorValue_T), pointer    :: AscDescMode
    type (L2GPData_T)                :: l2gp
    character(len=*), intent(in)     :: name
    integer, intent(in)              :: chunkNo      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: Chunks
    type (Interval_T)                :: myRange
    integer, intent(in), optional    :: offset
    integer, intent(in), optional    :: firstInstance
    integer, intent(in), optional    :: lastInstance

    ! Local variables
    logical :: DEEBUG
    integer :: firstProfile
    real(rv) :: HUGERGP
    integer :: lastProfile
    integer :: noSurfsInL2GP
    integer :: noFreqsInL2GP
    integer :: nProfiles
    logical :: profiled  ! Print grep-able info about overlaps discarded
    character(len=32)     :: QtyName
    integer :: useFirstInstance
    integer :: useLastInstance
    logical :: verbose
    ! Executable
    profiled = BeVerbose ( 'profiled', -1 )
    verbose = BeVerbose ( 'direct', -1 )
    deebug = LetsDebug ( 'direct', 0 )
    
    hugeRgp = real ( huge(0.0_rgp), rv )

    ! Work out what to do with the first and last instance information
    
    if ( present(firstInstance) ) then
      useFirstInstance = firstInstance
    else
      useFirstInstance = quantity%template%noInstancesLowerOverlap+1
    end if

    if ( present(lastInstance) ) then
      useLastInstance = lastInstance
    else
      useLastInstance = quantity%template%noInstances- &
        & quantity%template%noInstancesUpperOverlap
    end if

    ! noOutputInstances = useLastInstance-useFirstInstance+1
    ! Now create an empty L2GP record with this dimension

    if (any(quantity%template%verticalCoordinate == &
      & (/l_Pressure, l_Zeta, l_geodAltitude /) )) then
      noSurfsInL2GP = quantity%template%noSurfs
    else
      noSurfsInL2GP = 0
    end if

    if ( quantity%template%frequencyCoordinate == l_None) then
       noFreqsInL2GP = 0
    else
       noFreqsInL2GP = quantity%template%noChans
    end if
    
    if ( present(offset) ) then
      firstProfile=offset+1
    else
      firstProfile=1
    endif
    nProfiles = useLastInstance - useFirstInstance + 1
    lastProfile = firstProfile - 1 + nProfiles

    call get_string( lit_indices(quantity%template%QuantityType ), &
      & QtyName, strip=.true. )      

    if ( DEEBUG ) print *, 'noFreqsInL2GP, noSurfsInL2GP, lastProfile: ', &
      & noFreqsInL2GP, noSurfsInL2GP, lastProfile
      
    if ( profiled ) then
      call output ( '## ## ' // trim(QtyName)                , advance='no' )
      call Blanks ( 2 )
      call output ( ChunkNo                                  , advance='no' )
      call Blanks ( 2 )
      call output ( quantity%template%noInstancesLowerOverlap, advance='no' )
      call Blanks ( 2 )
      call output ( quantity%template%noInstancesUpperOverlap, advance='no' )
      call Blanks ( 2 )
      call output ( firstProfile                             , advance='no' )
      call Blanks ( 2 )
      call output ( lastProfile                              , advance='no' )
      call Blanks ( 2 )
      call output ( chunks(ChunkNo)%noMAFsLowerOverlap       , advance='no' )
      call Blanks ( 2 )
      call output ( chunks(ChunkNo)%noMAFsUpperOverlap       , advance='no' )
      call Blanks ( 2 )
      call output ( chunks(ChunkNo)%firstMAFIndex            , advance='no' )
      call Blanks ( 2 )
      call output ( chunks(ChunkNo)%lastMAFIndex             , advance='no' )
      call NewLine
    endif
    call SetupNewl2gpRecord ( l2gp, noFreqsInL2GP, noSurfsInL2GP, lastProfile )
    ! Setup the standard stuff, only pressure as it turns out.  
    select case ( quantity%template%verticalCoordinate )
    case ( l_Pressure ) 
      l2gp%pressures = quantity%template%surfs(:,1)
    case ( l_Zeta ) 
      l2gp%pressures = 10.0**(-quantity%template%surfs(:,1))
    case default
      call get_string( lit_indices(quantity%template%verticalCoordinate ), &
        & l2gp%verticalCoordinate, strip=.true. )      
      if ( noSurfsInL2GP > 0 ) l2gp%pressures = quantity%template%surfs(:,1)
      ! Don't warn about quantities with no vertically-resolved levels,
      ! e.g. Column amounts
      if ( noSurfsInL2GP > 1 ) call MLSL2Message( MLSMSG_Warning, ModuleName, &
        & 'Converting qty with non-pressure vertical coordinate ' // &
        & l2gp%verticalCoordinate )
      if ( verbose ) call dump( l2gp%pressures, 'vertical coordinates' )
      if ( deebug  ) call dump( quantity%template )
    end select
    
    ! We must choose a custom FillValue for GPH because
    ! -999.99 is a possibly legitimate value
    if ( quantity%template%QuantityType == l_gph .or. &
      & index( lowercase(name), 'gph' ) > 0 ) &
      & l2gp%MissingL2GP = L2Options%GPH_MissingValue
    ! It inherits its quantity type from the quantity template
    ! l2gp%quantityType=quantity%template%quantityType
    ! Do something about frequency
    if ( associated ( quantity%template%frequencies ) ) then
      l2gp%frequency = quantity%template%frequencies
    else
      l2gp%frequency = 0.0
    end if
    ! call ExpandL2GPDataInPlace ( l2gp, &
    !  & lastProfile-firstProfile+1 )

    ! Now copy the information from the quantity to the l2gpData
    L2GP%nTimesTotal = quantity%template%grandTotalInstances

    ! name is an integer, but L2GP%name is Character data
    l2gp%nameIndex = 0
    l2gp%name = name

    ! Now fill the data, first the geolocation
    l2gp%latitude(firstProfile:lastProfile) = &
      & quantity%template%geodLat(1,useFirstInstance:useLastInstance)
    l2gp%longitude(firstProfile:lastProfile) = &
      & quantity%template%lon(1,useFirstInstance:useLastInstance)
    l2gp%solarTime(firstProfile:lastProfile) = &
      & quantity%template%solarTime(1,useFirstInstance:useLastInstance)
    l2gp%solarZenith(firstProfile:lastProfile) = &
      & quantity%template%solarZenith(1,useFirstInstance:useLastInstance)
    l2gp%losAngle(firstProfile:lastProfile) = &
      & quantity%template%losAngle(1,useFirstInstance:useLastInstance)
    ! If the quantity isn't stacked, Phi is meaningless, and has zero size.
    if ( allocated(quantity%template%phi) .and. quantity%template%stacked ) then
      l2gp%geodAngle(firstProfile:lastProfile) = &
        & quantity%template%phi(1,useFirstInstance:useLastInstance)
    else
      l2gp%geodAngle(firstProfile:lastProfile) = 0
    end if
    l2gp%time(firstProfile:lastProfile) = &
      & quantity%template%time(1,useFirstInstance:useLastInstance)
    l2gp%chunkNumber(firstProfile:lastProfile) = chunkNo
    if ( deebug ) then
      call outputNamedValue( 'firstProfile, lastProfile', (/firstProfile, lastProfile /) )
      call outputNamedValue( 'chunkNos', l2gp%chunkNumber(firstProfile:lastProfile) )
    endif

    ! Now the various data quantities.

    l2gp%l2gpValue(:,:,firstProfile:lastProfile) = &
      & reshape ( max ( -hugeRgp, min ( hugeRgp, &
      &   quantity%values(:,useFirstInstance:useLastInstance) ) ), &
      &  (/max(l2gp%nFreqs,1),max(l2gp%nLevels,1),lastProfile-firstProfile+1/))
    if (associated(precision)) then
      l2gp%l2gpPrecision(:,:,firstProfile:lastProfile) = &
        & reshape ( max ( -hugeRgp, min ( hugeRgp, &
        &   precision%values(:,useFirstInstance:useLastInstance) ) ), &
        &  (/max(l2gp%nFreqs,1),max(l2gp%nLevels,1),lastProfile-firstProfile+1/))
    else
      l2gp%l2gpPrecision(:,:,firstProfile:lastProfile) = 0.0
    end if
    if (associated(quality)) then
      l2gp%quality(firstProfile:lastProfile) = &
        & quality%values(1,useFirstInstance:useLastInstance)
    else
      l2gp%quality(firstProfile:lastProfile) = 0.0
    endif
    if (associated(status)) then
      l2gp%status(firstProfile:lastProfile) = &
        & status%values(1,useFirstInstance:useLastInstance)
    else
      l2gp%status(firstProfile:lastProfile) = 0
    endif
    if (associated(convergence)) then
      l2gp%convergence(firstProfile:lastProfile) = &
        & convergence%values(1,useFirstInstance:useLastInstance)
    else
      l2gp%convergence(firstProfile:lastProfile) = 0.0
    endif
    if ( .not. AscDescModeIsField ) then
      ! The field has been dropped from l2gp swaths
    elseif (associated(AscDescMode)) then
      ! This sets the AscDescMode field to 
      ! +1 for values of +1
      ! -1 for values of -1
      l2gp%AscDescMode(firstProfile:lastProfile) = &
        & merge( 1, -1, &
        & (AscDescMode%values(1,useFirstInstance:useLastInstance) > 0._rv) &
        & )
    elseif( DescendingRange%Bottom < DescendingRange%Top ) then
      ! Turnaround points are assigned Mode values according to
      ! 90 deg  -> descending
      ! 270 deg -> ascending
      myRange%Bottom = DescendingRange%Bottom
      myRange%Top    = DescendingRange%Top / (1. + 1.e-6)
      l2gp%AscDescMode(firstProfile:lastProfile) = &
        & merge( -1, 1, &
        & inRange( &
        &  mod( l2gp%geodAngle(firstProfile:lastProfile), 360._rgp ) &
        & , myRange ) &
        & )
      if ( DEEBUG ) then
        call Dump( (/myRange%Bottom, myRange%top/), 'myRange' )
        call Dump( mod( l2gp%geodAngle(firstProfile:lastProfile), 360._rgp ), &
          & 'Orbit Angle' )
        call Dump( l2gp%AscDescMode(firstProfile:lastProfile), 'Mode' )
      endif
    else
      l2gp%AscDescMode(firstProfile:lastProfile) = 0
    endif
    if ( DEEBUG ) then
      print *, 'Vector converted to l2gp; name: ', trim(name)
      print *, 'firstProfile, lastProfile: ', firstProfile, lastProfile
      print *, 'useFirstInstance, useLastInstance: ', useFirstInstance, useLastInstance
      call outputNamedValue ( 'lons', l2gp%longitude(firstProfile:lastProfile) )
      call outputNamedValue ( 'lats', l2gp%latitude(firstProfile:lastProfile) )
    endif
    if ( all(l2gp%chunkNumber == -999) ) &
      & call output( 'all converted chunk numbers are -999', advance='yes' )
    if ( associated(quantity%BinNumber) ) then
      allocate( l2gp%BinNumber(1:lastProfile) )
      l2gp%BinNumber(1:lastProfile) = &
        & quantity%BinNumber(useFirstInstance:useLastInstance)
      if ( DEEBUG ) call Dump( l2gp%BinNumber, 'l2gp bin numbers' )
    elseif ( DEEBUG ) then
      call output( 'Bin numbers not allocated', advance='yes' )
    endif
    if ( associated(quantity%MAF) ) then
      allocate( l2gp%MAF(1:lastProfile) )
      l2gp%MAF(1:lastProfile) = quantity%MAF(useFirstInstance:useLastInstance)
      if ( DEEBUG ) call Dump( l2gp%MAF, 'l2gp MAFs' )
    elseif ( DEEBUG ) then
      call output( 'MAFs not allocated', advance='yes' )
    endif
  end subroutine vectorValue_to_l2gp

  ! ---------------------------------------------  ANNOUNCE_ERROR  -----
  subroutine ANNOUNCE_ERROR ( Where, Full_message, Code, Penalty )

    use Lexer_Core, only: Print_Source
    use Tree, only: Where_At=>where

    ! Args:
    integer, intent(in) :: Where   ! Tree node where error was noticed
    character(LEN=*), intent(in) :: Full_Message
    integer, intent(in), optional :: Code    ! Code for error message
    integer, intent(in), optional :: Penalty
    integer :: myPenalty

    myPenalty = 1
    if ( present(penalty) ) myPenalty = penalty
    error = max(error,myPenalty)

    call output ( '***** At ' )
    if ( where > 0 ) then
      call print_source ( where_at(where) )
    else
      call output ( '(no lcf node available)' )
    end if
    call output ( ModuleName // ' complained: ' )

    call output ( trim(full_message), advance='yes', &
      & from_where=ModuleName )
    if ( present(code) ) then
      select case ( code )
      end select
    end  if
  end subroutine ANNOUNCE_ERROR

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: DirectWrite_m.f90,v 2.99 2021/08/06 17:15:11 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module DirectWrite_m

! $Log: DirectWrite_m.f90,v $
! Revision 2.99  2021/08/06 17:15:11  pwagner
! Print debugging stuff only if DEEBUG is true
!
! Revision 2.98  2021/07/22 23:12:54  pwagner
! Swicth setting -Sprofiled prints grepable info about chunk overlaps
!
! Revision 2.97  2021/06/10 23:47:44  pwagner
! When creating l2gps from qties, copy their BinNumber and MAF, too
!
! Revision 2.96  2020/03/04 21:27:32  pwagner
! Skip Warnings about Column amounts: already know they lack vertical coords
!
! Revision 2.95  2020/02/13 21:27:45  pwagner
! Fix errors relating to separate MissingValue for GPH
!
! Revision 2.94  2019/02/13 18:58:42  pwagner
! New GPH_MissingValue field of L2Options can now be st to a value other than default -999.99
!
! Revision 2.93  2018/11/12 23:13:26  pwagner
! Deprecated AscDescMode
!
! Revision 2.92  2018/07/27 23:17:16  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.91  2018/04/19 01:14:16  vsnyder
! Remove USE statements for unused names
!
! Revision 2.90  2018/04/13 00:20:42  pwagner
! Plain hdf DirectWrites and -Reads are now 'auto'
!
! Revision 2.89  2018/01/12 00:22:34  pwagner
! Reduce amount written by lowest verbose level
!
! Revision 2.88  2017/08/10 22:47:36  pwagner
! Use WriteHDF5Data from L2AuxData
!
! Revision 2.87  2017/07/27 17:02:08  pwagner
! If an sdName contains one or more '/', will attempt ot open or create nested hdf5 groups
!
! Revision 2.86  2017/02/24 19:47:52  pwagner
! Sleep time now same as parallel%delay
!
! Revision 2.85  2016/09/21 00:39:46  pwagner
! Usually dump DirectDB as a table
!
! Revision 2.84  2016/09/07 22:46:49  pwagner
! Removed unused QuantityType component from L2GPData type
!
! Revision 2.83  2016/08/09 21:39:40  pwagner
! Removed unused variables
!
! Revision 2.82  2016/05/25 00:07:18  pwagner
! To appease NAG which disliked ambiguity in generic DirectWrites
!
! Revision 2.81  2016/05/18 19:05:44  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.80  2016/02/29 19:49:29  pwagner
! Usleep got from machine module instead of being an external
!
! Revision 2.79  2015/10/14 23:24:46  pwagner
! Cope better with l2gp qty with non-pressure vertical coordinate
!
! Revision 2.78  2015/10/06 17:37:05  pwagner
! Added more error checking; allow for altitude vertical coordinate
!
! Revision 2.77  2015/09/17 23:24:50  pwagner
! Passes Max chunk size for l2gp DirectWrites
!
! Revision 2.76  2015/07/29 00:29:54  vsnyder
! Convert Phi from pointer to allocatable
!
! Revision 2.75  2015/07/14 23:32:01  pwagner
! label and inputFile fields in DirectWrite
!
! Revision 2.74  2015/04/29 01:15:09  vsnyder
! Calculate TrueRank correctly, allow to use it if rank<0
!
! Revision 2.73  2015/04/25 02:10:36  vsnyder
! Spiff a message
!
! Revision 2.72  2015/04/21 17:53:03  pwagner
! May DirectRead quantity geolocations
!
! Revision 2.71  2015/04/09 22:19:59  pwagner
! We may DirectRead a quantity type
!
! Revision 2.70  2015/04/07 02:56:29  vsnyder
! Add warning about rank being wrong in DirectWrite_Quantity.  Add ability to
! detect rank if requested rank is <= 0.  Add FrequencyCoordinate.
!
! Revision 2.69  2015/03/31 21:01:57  pwagner
! rank is a new field for DirectWrite-ing quantity values as, say, rank3; now write qty attributes, too
!
! Revision 2.68  2015/03/28 02:30:58  vsnyder
! Added stuff to trace allocate/deallocate addresses.  Paul added
! DirectWriteQuantity stuff.
!
! Revision 2.67  2015/02/05 21:42:23  vsnyder
! Don't use Phi for unstacked quantities
!
! Revision 2.66  2014/12/11 21:27:04  pwagner
! Turn off more printing unless verbose or debug
!
! Revision 2.65  2014/12/10 23:02:59  pwagner
! Correct erroneous calculation of AscDescMode; now based on geodAngle
!
! Revision 2.64  2014/11/04 01:25:41  pwagner
! May switch on verbose, deebug modes with -Sdirect[n]
!
! Revision 2.63  2014/10/02 17:22:23  pwagner
! DirectWrite now responsible for writing MiscNotes for l2gp files
!
! Revision 2.62  2014/09/05 00:40:24  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.61  2014/04/10 00:47:18  pwagner
! More consistent in when to announce creating files, datasets
!
! Revision 2.60  2014/04/07 18:03:03  pwagner
! May specify AscDescMode when DirectWrite-ing swaths
!
! Revision 2.59  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.58  2013/11/20 00:56:19  pwagner
! Reduce default dump of directWriteDB to just file names
!
! Revision 2.57  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.56  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.55  2013/05/08 20:17:35  pwagner
! Changed sleep to usleep to link with NAG
!
! Revision 2.54  2013/05/07 22:23:30  pwagner
! A workaround to prevent unexpected Missing/Fill values
!
! Revision 2.53  2012/05/10 00:48:19  pwagner
! A little less clumsy at creating files, swaths
!
! Revision 2.52  2012/03/12 17:09:44  pwagner
! Use new writeAPrioriAttributes api
!
! Revision 2.51  2012/02/24 21:19:15  pwagner
! May DirectWrite a /single instance only
!
! Revision 2.50  2011/12/15 01:52:55  pwagner
! 'num' option names quantity in entireVector DirectWrites numerically
!
! Revision 2.49  2011/11/01 21:44:31  pwagner
! May optionally add quantity Attributes via options='A' field
!
! Revision 2.48  2011/05/09 18:06:59  pwagner
! May directwrite an entire vector
!
! Revision 2.47  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
! Revision 2.46  2010/02/04 19:10:26  pwagner
! Change condition on directwrite db from associated to zero size
!
! Revision 2.45  2010/01/08 00:11:19  pwagner
! Added ability to write MLSFile_T fields as attributes
!
! Revision 2.44  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.43  2009/04/23 23:02:52  pwagner
! May specify upperOverlap or lowerOverlap in DirectWrites
!
! Revision 2.42  2008/09/20 00:03:00  pwagner
! Added print statement to not_used_here
!
! Revision 2.41  2006/10/11 22:58:00  pwagner
! Will write convergence ratio as another quality-like field of l2gp
!
! Revision 2.40  2006/06/20 00:13:34  pwagner
! Fwm files should haves MAFs matching radiance files
!
! Revision 2.39  2006/05/11 19:39:19  pwagner
! Should not segment fault if dumping empty DB
!
! Revision 2.38  2006/04/20 23:24:12  pwagner
! More bugs squashed related to extra-range MAFs; one crashed final chunk
!
! Revision 2.37  2006/04/19 20:48:13  pwagner
! Undid most of the changes regarding extra MAFs; perhaps fixed bugs
!
! Revision 2.36  2006/04/12 22:20:42  pwagner
! Attempted workaround for hdf5-1.6.5 bugs rewriting string attributes
!
! Revision 2.35  2006/04/11 23:33:14  pwagner
! Fixed bug which added excess profiles
!
! Revision 2.34  2006/01/26 00:34:50  pwagner
! demoted more use statements from module level to speed Lahey compiles
!
! Revision 2.33  2005/08/19 23:28:02  pwagner
! Trying to avoid possibility of Lahey-causes memory leak
!
! Revision 2.32  2005/07/12 17:38:57  pwagner
! Writes APriori File names as an attribute to every l2gp file
!
! Revision 2.31  2005/06/22 18:57:01  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.30  2005/06/14 20:41:17  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.29  2004/11/29 21:52:41  livesey
! Bug fix for handling cases where no forward models are defined.
!
! Revision 2.28  2004/08/03 18:02:01  pwagner
! Sets fillValue for l2aux type
!
! Revision 2.27  2004/07/22 20:42:57  cvuu
! May write ForwardModel Names as file-level attributes and fix the phase names
!
! Revision 2.26  2004/06/29 18:05:26  pwagner
! May write phase, section names as file-level attributes
!
! Revision 2.25  2004/06/10 00:58:45  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.24  2004/05/19 19:16:09  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.23  2004/05/05 21:31:48  pwagner
! More debug printing
!
! Revision 2.22  2004/03/03 19:25:45  pwagner
! Fixed poorly understood prob with single chunks; more initializing in setup
!
! Revision 2.21  2004/02/19 23:54:26  pwagner
! Dumps during directWrites if l2gp or l2aux switch set
!
! Revision 2.20  2004/02/11 17:23:25  pwagner
! l2gp status an integer, not a char
!
! Revision 2.19  2004/02/10 19:30:55  pwagner
! Cures serial directWrites from writing more than one chunk at a time
!
! Revision 2.18  2004/02/05 23:38:41  pwagner
! Writes attributes to directwrite l2aux file
!
! Revision 2.17  2004/01/23 01:09:48  pwagner
! Only directwrite files entered in global settings eligible to be auto-sourced
!
! Revision 2.16  2004/01/22 06:38:26  livesey
! Typo fix
!
! Revision 2.15  2004/01/22 00:56:35  pwagner
! Fixed many bugs in auto-distribution of DirectWrites
!
! Revision 2.14  2003/12/03 17:50:54  pwagner
! L2GP tracks both nTimes (for this slave) and nTimesTotal (done by all)
!
! Revision 2.13  2003/11/14 23:38:45  pwagner
! Uses DirectWrite databse in preference to repeated calls to toolkit
!
! Revision 2.12  2003/08/28 23:51:39  livesey
! Various bug fixes and simplifications
!
! Revision 2.11  2003/08/01 20:39:34  pwagner
! Skip warning mesg about grandTotalInstances when 0
!
! Revision 2.10  2003/07/18 16:05:26  pwagner
! Stops printing warnings after 40 times
!
! Revision 2.9  2003/07/15 23:41:47  pwagner
! l2aux always rank 3 unless MAYCOLLAPSEDIMS; disabled most printing
!
! Revision 2.8  2003/07/09 21:49:53  pwagner
! Tries to figure out in advance whether to create swath
!
! Revision 2.7  2003/07/07 21:03:43  pwagner
! Removed DirectWrite_L2Aux_FileName; tries to deal sensibly with all-overlap chunks
!
! Revision 2.6  2003/07/07 17:32:30  livesey
! New approach to DirectWrite
!
! Revision 2.5  2003/07/02 00:55:27  pwagner
! Some improvements in DirectWrites of l2aux, l2gp
!
! Revision 2.4  2003/06/25 18:24:57  pwagner
! A fix to vectorValue_to_l2gp
!
! Revision 2.3  2003/06/24 23:53:27  pwagner
! Allows unassociated precisions as args to direct write
!
! Revision 2.2  2003/06/23 23:55:17  pwagner
! Added DirectData_T to keep track of data written directly
!
! Revision 2.1  2003/06/20 19:43:16  pwagner
! First commit
!
@


2.99
log
@Print debugging stuff only if DEEBUG is true
@
text
@d444 3
a446 1
    & chunkNo, createSwath, lowerOverlap, upperOverlap, maxChunkSize )
d457 1
d464 1
a464 1
    type (VectorValue_T), pointer :: QUANTITY
d478 1
a478 1
        & sdName, chunkNo, createSwath, lowerOverlap, upperOverlap, &
d486 2
a487 1
    & sdName, chunkNo, createSwath, lowerOverlap, upperOverlap, &
d489 1
d514 1
d603 1
a603 1
      & sdname, chunkNo, offset=0, &
d665 3
a667 3
    type (Vector_T), intent(in)   :: VECTOR
    type(MLSFile_T)               :: L2AUXFile
    integer, intent(in)           :: CHUNKNO      ! Index into chunks
d1714 2
a1715 1
    & l2gp, name, chunkNo, offset, firstInstance, lastInstance )
d1730 2
a1731 1
    integer, intent(in)              :: chunkNo
d1814 8
d1825 1
a1825 1
    ! Setup the standard stuff, only pressure as it turns out.
d2018 1
a2018 1
       "$Id: DirectWrite_m.f90,v 2.98 2021/07/22 23:12:54 pwagner Exp $"
d2028 3
@


2.98
log
@Swicth setting -Sprofiled prints grepable info about chunk overlaps
@
text
@d624 6
a629 4
    if ( present(createSwath) ) then
      print *, 'create swath? ', createSwath
    else
      print *, 'create swath not present '
d1954 1
a1954 1
    else
d1961 1
a1961 1
    else
d2002 1
a2002 1
       "$Id: DirectWrite_m.f90,v 2.97 2021/06/10 23:47:44 pwagner Exp $"
d2012 3
@


2.97
log
@When creating l2gps from qties, copy their BinNumber and MAF, too
@
text
@d44 1
a44 1
  use Output_M, only: Blanks, Output
d591 2
a592 2
      & call MLSL2Message(MLSMSG_Error, ModuleName, &
      & 'l2gp file is rdonly', MLSFile=L2GPFile)
d598 1
a598 1
      & firstInstance=firstInstance, lastInstance=lastInstance)
d1735 2
d1741 1
d1785 4
d1791 15
d2000 1
a2000 1
       "$Id: DirectWrite_m.f90,v 2.96 2020/03/04 21:27:32 pwagner Exp $"
d2010 3
@


2.96
log
@Skip Warnings about Column amounts: already know they lack vertical coords
@
text
@d624 5
d1925 15
d1978 1
a1978 1
       "$Id: DirectWrite_m.f90,v 2.95 2020/02/13 21:27:45 pwagner Exp $"
d1988 3
@


2.95
log
@Fix errors relating to separate MissingValue for GPH
@
text
@d1777 2
a1778 1
    if ( DEEBUG ) print *, 'noFreqsInL2GP, noSurfsInL2GP, lastProfile: ', noFreqsInL2GP, noSurfsInL2GP, lastProfile
d1787 2
a1788 1
      call get_string( lit_indices(quantity%template%verticalCoordinate ), l2gp%verticalCoordinate, strip=.true. )      
d1790 5
a1794 2
      call MLSL2Message( MLSMSG_Warning, ModuleName, &
        & 'Converting qty with non-pressure vertical coordinate ' // l2gp%verticalCoordinate )
d1958 1
a1958 1
       "$Id: DirectWrite_m.f90,v 2.94 2019/02/13 18:58:42 pwagner Exp $"
d1968 3
@


2.94
log
@New GPH_MissingValue field of L2Options can now be st to a value other than default -999.99
@
text
@d1798 1
a1798 1
      & l2gp%MissingValue = L2Options%GPH_MissingValue
d1953 1
a1953 1
       "$Id: DirectWrite_m.f90,v 2.93 2018/11/12 23:13:26 pwagner Exp $"
d1963 3
@


2.93
log
@Deprecated AscDescMode
@
text
@d33 1
a33 1
  use MLSCommon, only: DefaultUndefinedValue, Interval_T, MLSFile_T, &
d36 1
a36 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d41 3
a43 2
  use MLSL2Options, only: MLSL2Message, WriteFileAttributes
  use MLSStringLists, only: List2Array, NumStringElements, SwitchDetail
d143 2
a144 2
  logical, parameter :: countEmpty = .true.
  integer, parameter :: S2US  = 1000000 ! How many microseconds in a s
a762 1
    use HDF, only: Dfacc_Rdonly
d774 2
a775 3
    logical, parameter :: DEEBUG = .false.
    logical :: deebughere
    integer :: lastMAF
d777 1
a777 1
    character(len=*), parameter :: sdDebug = "R1A:118.B1F:PT.S0.FB25-1 Core"
d789 1
a789 1
    deebughere = ( deebug .or. sdname == sdDebug ) .and. .false.
d1067 1
a1067 2
      & IsHDF5GroupPresent, &
      & MakeHDF5Attribute, MakeNestedGroups
d1088 1
a1088 1
    character(len=128) :: barename
d1090 1
a1090 1
    character(len=128), dimension(25) :: groupNames
d1096 1
a1096 1
    integer :: n
d1100 1
a1100 1
    character(len=1024) :: path
d1703 1
a1703 1
    use Intrinsic, only: L_None, Lit_Indices
d1793 6
d1953 1
a1953 1
       "$Id: DirectWrite_m.f90,v 2.92 2018/07/27 23:17:16 pwagner Exp $"
d1963 3
@


2.92
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d14 2
a15 2
module DirectWrite_m  ! alternative to Join/OutputAndClose methods
                      ! appropriate L2 Files
d1706 1
a1706 1
    use L2GPData, only: DescendingRange, L2GPData_T, RGP, &
d1871 3
a1873 1
    if (associated(AscDescMode)) then
d1949 1
a1949 1
       "$Id: DirectWrite_m.f90,v 2.91 2018/04/19 01:14:16 vsnyder Exp $"
d1959 3
@


2.91
log
@Remove USE statements for unused names
@
text
@d41 1
a41 1
  use MLSL2Options, only: WriteFileAttributes
d294 1
a294 1
      & call MLSMessage ( MLSMSG_Warning, ModuleName // '%DirectRead', &
d583 1
a583 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d590 1
a590 1
      & call MLSMessage(MLSMSG_Error, ModuleName, &
d794 2
a795 2
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2aux file', MLSFile=L2AUXFile)
d864 2
a865 2
        call MLSMessage(MLSMSG_Error, ModuleName, &
        & 'Unable to open l2aux file', MLSFile=L2AUXFile)
d868 2
a869 2
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & 'l2aux file is rdonly', MLSFile=L2AUXFile)
d880 1
a880 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d896 1
a896 1
          & call MLSMessage ( MLSMSG_Warning, ModuleName, &
d935 1
a935 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d1000 1
a1000 1
    if ( sdId == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1048 1
a1048 1
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1209 1
a1209 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1224 1
a1224 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1243 1
a1243 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1313 1
a1313 1
    use MLSL2Options, only: MLSMessage
d1356 1
a1356 1
        & call MLSMessage(MLSMSG_Error, ModuleName, &
d1362 1
a1362 1
        & call MLSMessage(MLSMSG_Error, ModuleName, &
d1368 1
a1368 1
      & call MLSMessage(MLSMSG_Error, ModuleName, &
d1424 1
a1424 1
      & call MLSMessage(MLSMSG_Error, ModuleName, &
d1428 1
a1428 1
      & call MLSMessage(MLSMSG_Error, ModuleName, &
d1790 1
a1790 1
      call MLSMessage( MLSMSG_Warning, ModuleName, &
d1947 1
a1947 1
       "$Id: DirectWrite_m.f90,v 2.90 2018/04/13 00:20:42 pwagner Exp $"
d1957 3
@


2.90
log
@Plain hdf DirectWrites and -Reads are now 'auto'
@
text
@a161 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d1947 1
a1947 1
       "$Id: DirectWrite_m.f90,v 2.89 2018/01/12 00:22:34 pwagner Exp $"
d1957 3
@


2.89
log
@Reduce amount written by lowest verbose level
@
text
@d116 3
a118 2
    module procedure DirectWrite_L2Aux_MF
    module procedure DirectWrite_L2GP_MF
d120 3
a122 2
    module procedure DirectWriteVector_L2GP_MF
    module procedure DirectWriteVector_L2Aux_MF
d441 2
a442 2
  ! ------------------------------------------ DirectWriteVector_L2GP_MF --------
  subroutine DirectWriteVector_L2GP_MF ( L2gpFile, &
d473 1
a473 1
      call DirectWrite_L2GP_MF ( L2gpFile, &
d478 1
a478 1
  end subroutine DirectWriteVector_L2GP_MF
d480 2
a481 2
  ! ------------------------------------------ DirectWrite_L2GP_MF --------
  subroutine DirectWrite_L2GP_MF ( L2gpFile, &
d633 1
a633 1
  end subroutine DirectWrite_L2GP_MF
d635 2
a636 2
  ! ------------------------------------------- DirectWriteVector_L2Aux_MF --------
  subroutine DirectWriteVector_L2Aux_MF ( L2AUXFile, Vector, &
d695 1
a695 1
      call DirectWrite_L2Aux_MF ( L2AUXFile, quantity, precision, sdName, &
d699 1
a699 1
  end subroutine DirectWriteVector_L2Aux_MF
d701 3
d705 104
a808 2
  ! ------------------------------------------- DirectWrite_L2Aux_MF --------
  subroutine DirectWrite_L2Aux_MF ( L2AUXFile, quantity, precision, sdName, &
d918 1
a918 1
      call DirectWrite_L2Aux_MF_hdf4 ( quantity, sdName, L2AUXFile, &
d922 1
a922 1
        & call DirectWrite_L2Aux_MF_hdf4 ( precision, &
d926 1
a926 1
      call DirectWrite_L2Aux_MF_hdf5 ( quantity, sdName, L2AUXFile, &
d931 1
a931 1
        & call DirectWrite_L2Aux_MF_hdf5 ( precision, &
d946 1
a946 1
  end subroutine DirectWrite_L2Aux_MF
d948 2
a949 2
  ! ------------------------------------------ DirectWrite_L2Aux_MF_hdf4 --------
  subroutine DirectWrite_L2Aux_MF_hdf4 ( quantity, sdName, L2AUXFile, &
d1052 1
a1052 1
  end subroutine DirectWrite_L2Aux_MF_hdf4
d1054 2
a1055 2
  ! ------------------------------------------ DirectWrite_L2Aux_MF_hdf5 --------
  subroutine DirectWrite_L2Aux_MF_hdf5 ( quantity, sdName, L2AUXFile, &
d1285 1
a1285 1
  end subroutine DirectWrite_L2Aux_MF_hdf5
d1948 1
a1948 1
       "$Id: DirectWrite_m.f90,v 2.88 2017/08/10 22:47:36 pwagner Exp $"
d1958 3
@


2.88
log
@Use WriteHDF5Data from L2AuxData
@
text
@d617 1
a619 1
    if ( verbose ) call dump( l2gp%chunkNumber, 'Appending chunkNumber' )
d668 1
a668 1
    verbose = BeVerbose ( 'direct', -1 )
d741 6
a746 2
    if ( .not. already_There ) &
      & call outputNamedValue( '  creating file', trim(L2AUXFile%name) )
d1006 1
a1006 1
    verbose = BeVerbose ( 'direct', -1 )
d1728 1
a1728 1
    if ( verbose ) then
d1841 1
a1841 1
       "$Id: DirectWrite_m.f90,v 2.87 2017/07/27 17:02:08 pwagner Exp $"
d1851 3
@


2.87
log
@If an sdName contains one or more '/', will attempt ot open or create nested hdf5 groups
@
text
@d50 48
d949 2
a950 2
    use ChunkDivide_M, only: Chunkdivideconfig
    use ForwardModelConfig, only: Forwardmodelconfig_T
d954 3
a956 3
    use L2AuxData, only: L2auxData_T, Phasenameattributes, &
      & Destroyl2auxcontents, &
      & Setupnewl2auxrecord, Writel2auxattributes
d959 1
a959 1
      & MakeHDF5Attribute, MakeNestedGroups, SaveasHDF5ds
d1102 1
a1102 13
      ! Is here a '/' in sdname?
      if ( index( sdname, '/' ) > 0 ) then
        ! Do the containing groups exist yet?
        call split_path_name ( sdname, path, bareName )
        if ( .not. IsHDF5GroupPresent( L2AUXFile%fileID%f_id, trim(path)) ) then
          call List2Array ( path, groupnames, countEmpty, inseparator='/' )
          n = NumStringElements ( path, countEmpty, inseparator='/' )
          n = max( n, 2 )
          call MakeNestedGroups( L2AUXFile%fileID%f_id, groupNames(1:n-1) )
        endif
      endif
      call SaveAsHDF5DS( L2AUXFile%fileID%f_id, trim(sdName), &
        & real( &
d1104 3
a1106 2
        & ), start, sizes, may_add_to=.true., adding_to=already_there, &
        & fillValue=DEFAULTUNDEFINEDVALUE )
d1117 1
a1117 2
      call SaveAsHDF5DS( L2AUXFile%fileID%f_id, trim(sdName), &
        & real( &
d1119 3
a1121 2
        & ), start, sizes, may_add_to=.true., adding_to=already_there, &
        & fillValue=DEFAULTUNDEFINEDVALUE)
d1837 1
a1837 1
       "$Id: DirectWrite_m.f90,v 2.86 2017/02/24 19:47:52 pwagner Exp $"
d1847 3
@


2.86
log
@Sleep time now same as parallel%delay
@
text
@d42 1
a42 1
  use MLSStringLists, only: SwitchDetail
d91 2
d588 1
a588 1
    & lowerOverlap, upperOverlap, single, options )
d610 1
d617 2
a618 1
    logical :: verbose
d624 3
d644 1
d910 2
a911 1
      & MakeHDF5attribute, SaveasHDF5ds
d932 1
d934 1
d940 1
d944 1
d1054 11
d1800 1
a1800 1
       "$Id: DirectWrite_m.f90,v 2.85 2016/09/21 00:39:46 pwagner Exp $"
d1810 3
@


2.85
log
@Usually dump DirectDB as a table
@
text
@d27 5
a31 4
  use Allocate_deallocate, only: allocate_test
  use HighOutput, only: beVerbose, LetsDebug, outputNamedValue, outputTable
  use Init_tables_module, only: l_geodAltitude, l_pressure, l_zeta, &
    & L_l2gp, l_l2aux, l_l2dgg, l_l2fwm
d33 1
a33 1
  use MLSCommon, only: defaultUndefinedValue, Interval_T, MLSFile_T, &
d35 1
a35 1
  use MLSKinds, only: rv
d37 7
a43 7
  use MLSFiles, only: hdfversion_4, hdfversion_5, dump, MLS_Exists, &
    & MLS_CloseFile, MLS_OpenFile, split_path_name
  use MLSFinds, only: findFirst
  use MLSHDFEOS, only: MLS_Swath_in_file
  use MLSL2Options, only: writeFileAttributes
  use MLSStringLists, only: switchDetail
  use Output_m, only: blanks, output
d45 3
a47 3
  use String_table, only: get_string
  use Toggles, only: switches
  use VectorsModule, only: vector_t, vectorValue_t, dump
d92 1
a92 1
  integer, parameter :: DELAY = 1*S2US  ! How long to sleep in microseconds
d179 7
a185 7
    use dates_module, only: tai93s2hid
    use dump_0, only: dump
    use hdf5, only: h5gclose_f, h5gopen_f
    use MLSHDF5, only: GetHDF5Attribute, isHDF5GroupPresent, &
      & getHDF5DSRank, loadFromHDF5DS
    use MLSStringLists, only: optionDetail
    use MLSStrings, only: writeIntsToChars
d351 2
a352 2
    use MLSStrings, only: writeIntsToChars
    use string_table, only: get_string
d443 4
a446 4
    use HDF, only: dfacc_create, dfacc_rdonly, dfacc_rdwr
    use L2GPData, only: L2GPData_t, &
      & appendL2GPData, destroyL2GPContents, dump
    use readApriori, only: writeAPrioriAttributes
d570 2
a571 1
    call usleep ( delay ) ! Should we make this parallel%delay?
d595 3
a597 3
    use chunks_m, only: MLSChunk_t
    use forwardModelConfig, only: forwardModelConfig_t
    use MLSStrings, only: writeIntsToChars
d655 4
a658 4
    use chunks_m, only: MLSChunk_t
    use chunkDivide_m, only: chunkDivideConfig
    use forwardModelConfig, only: forwardModelConfig_t
    use hdf, only: dfacc_rdonly
d785 5
a789 5
    use chunks_m, only: MLSChunk_t
    use hdf, only: sfn2index, sfselect, sfcreate, &
      & sfendacc, dfnt_float32, sfwdata_f90
    use intrinsic, only: l_none
    use mlskinds, only: r4, r8
d892 14
a905 14
    use chunks_m, only: MLSChunk_t
    use chunkDivide_m, only: chunkdivideconfig
    use forwardModelConfig, only: forwardmodelconfig_t
    use forwardModelSupport, only: showfwdmodelnames
    use hdf5, only: h5gclose_f, h5gopen_f
    use intrinsic, only: l_none
    use L2Auxdata, only:  l2auxdata_t, phasenameattributes, &
      & destroyl2auxcontents, &
      & setupnewl2auxrecord, writel2auxattributes
    use MLSHDF5, only: ishdf5attributepresent, ishdf5dspresent, &
      & makehdf5attribute, saveashdf5ds
    use MLSL2Timings, only: showTimingNames
    use PCFHdr, only: h5_writemlsfileattr, h5_writeglobalattr
    use quantityTemplates, only: writeAttributes
d1138 4
a1141 4
    use HDF5, only: h5gclose_f, h5gcreate_f, h5gopen_f
    use intrinsic, only: lit_indices
    use MLSHDF5, only: ishdf5grouppresent, &
      & makehdf5attribute, saveashdf5ds
d1143 1
a1143 1
    use MLSSTrings, only: writeintstochars
d1534 3
a1536 3
    use intrinsic, only: l_none, lit_indices
    use L2GPData, only: descendingRange, L2GPData_T, RGP, &
      & setupNewL2GPRecord
d1743 2
a1744 2
    use lexer_core, only: print_source
    use tree, only: where_at=>where
d1776 1
a1776 1
       "$Id: DirectWrite_m.f90,v 2.84 2016/09/07 22:46:49 pwagner Exp $"
d1786 3
@


2.84
log
@Removed unused QuantityType component from L2GPData type
@
text
@d28 1
a28 1
  use HighOutput, only: beVerbose, LetsDebug, outputNamedValue
d37 1
a37 1
    & MLS_CloseFile, MLS_OpenFile
d1305 1
d1307 5
d1321 16
a1336 3
    do i = 1, size(directDB)
      call DumpDirectWrite(directDB(i), Details)
    end do
d1351 1
a1351 1
    ! Executable code
d1774 1
a1774 1
       "$Id: DirectWrite_m.f90,v 2.83 2016/08/09 21:39:40 pwagner Exp $"
d1784 3
@


2.83
log
@Removed unused variables
@
text
@d1604 1
a1604 1
    l2gp%quantityType=quantity%template%quantityType
d1755 1
a1755 1
       "$Id: DirectWrite_m.f90,v 2.82 2016/05/25 00:07:18 pwagner Exp $"
d1765 3
@


2.82
log
@To appease NAG which disliked ambiguity in generic DirectWrites
@
text
@d27 5
a31 5
  use allocate_deallocate, only: allocate_test
  use highOutput, only: beVerbose, LetsDebug, outputNamedValue
  use init_tables_module, only: l_geodAltitude, l_pressure, l_zeta, &
    & l_l2gp, l_l2aux, l_l2dgg, l_l2fwm
  use machine, only: USleep
d33 1
a33 1
    & inRange
d37 3
a39 3
    & MLS_closefile, MLS_openfile
  use MLSFinds, only: findfirst
  use MLSHDFEOS, only: MLS_swath_in_file
d42 1
a42 1
  use output_m, only: blanks, output
d44 3
a46 3
  use string_table, only: get_string
  use toggles, only: switches
  use vectorsModule, only: vector_t, vectorValue_t, dump
d309 1
a309 1
      character(len=80) :: str
a932 1
    integer :: STRIDE(3)                ! HDF array stride
a978 1
    stride = 1
d1755 1
a1755 1
       "$Id: DirectWrite_m.f90,v 2.81 2016/05/18 19:05:44 vsnyder Exp $"
d1765 3
@


2.81
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@d356 1
a356 1
    character(len=*), intent(in), optional :: options
d366 1
a366 3
    nameQtyByTemplate = .true.
    if ( present(options) ) nameQtyByTemplate = &
      & .not. ( index(options, 'num') > 0 )
d1757 1
a1757 1
       "$Id: DirectWrite_m.f90,v 2.80 2016/02/29 19:49:29 pwagner Exp $"
d1767 4
@


2.80
log
@Usleep got from machine module instead of being an external
@
text
@d393 1
a393 1
    & chunkNo, HGrids, createSwath, lowerOverlap, upperOverlap, maxChunkSize )
a399 1
    use HGridsDatabase, only: HGrid_t
a403 1
    type (HGrid_T), dimension(:), pointer ::     HGrids
d424 1
a424 1
        & sdName, chunkNo, HGrids, createSwath, lowerOverlap, upperOverlap, &
d432 1
a432 1
    & sdName, chunkNo, HGrids, createSwath, lowerOverlap, upperOverlap, &
a444 1
    use HGridsDatabase, only: hgrid_t
a457 1
    type (HGrid_T), dimension(:), pointer ::     HGrids
d546 1
a546 1
      & sdname, chunkNo, HGrids, offset=0, &
d1515 1
a1515 1
    & l2gp, name, chunkNo, HGrids, offset, firstInstance, lastInstance )
a1516 1
    use HGridsDatabase, only: HGrid_T
a1530 1
    type (HGrid_T), dimension(:), pointer ::     HGrids
d1759 1
a1759 1
       "$Id: DirectWrite_m.f90,v 2.79 2015/10/14 23:24:46 pwagner Exp $"
d1769 3
@


2.79
log
@Cope better with l2gp qty with non-pressure vertical coordinate
@
text
@d31 1
d1765 1
a1765 1
       "$Id: DirectWrite_m.f90,v 2.78 2015/10/06 17:37:05 pwagner Exp $"
d1775 3
@


2.78
log
@Added more error checking; allow for altitude vertical coordinate
@
text
@d350 1
d480 1
d573 1
a1149 1
    use String_Table, only: Get_String
d1516 1
a1516 1
  subroutine vectorValue_to_l2gp ( QUANTITY, &
d1518 2
a1519 2
    & l2gp, &
    & name, chunkNo, HGrids, offset, firstInstance, lastInstance )
d1521 1
a1521 1
    use intrinsic, only: l_none
d1524 1
d1526 1
a1526 1
    type (VectorValue_T), intent(in) :: QUANTITY
d1599 13
a1611 4
    if ( quantity%template%verticalCoordinate == l_Pressure ) &
      & l2gp%pressures = quantity%template%surfs(:,1)
    if ( quantity%template%verticalCoordinate == l_Zeta ) &
      & l2gp%pressures = 10.0**(-quantity%template%surfs(:,1))
d1650 5
a1654 1
    l2gp%chunkNumber(firstProfile:lastProfile)=chunkNo
d1724 2
d1764 1
a1764 1
       "$Id: DirectWrite_m.f90,v 2.77 2015/09/17 23:24:50 pwagner Exp $"
d1774 3
@


2.77
log
@Passes Max chunk size for l2gp DirectWrites
@
text
@d28 2
a29 2
  use highoutput, only: beVerbose, LetsDebug, outputNamedValue
  use init_tables_module, only: l_pressure, l_zeta, &
d40 1
a40 1
  use MLSStringlists, only: switchdetail
d444 2
a445 2
    use hdf, only: dfacc_create, dfacc_rdonly, dfacc_rdwr
    use hgridsdatabase, only: hgrid_t
d1144 1
d1146 1
a1146 1
    use MoreMessage, only: MLSMessage
d1187 3
d1193 3
d1199 3
d1206 1
a1206 1
      call outputnamedValue( 'inputFile', trim(inputFile) )
d1217 1
a1217 1
        call MLSMessage ( MLSMSG_Warning, moduleName, "Actual rank of Value %S is " // &
d1255 3
d1259 3
d1573 2
a1574 1
    if (any(quantity%template%verticalCoordinate == (/l_Pressure, l_Zeta /) )) then
d1581 1
a1581 1
       noFreqsInL2GP=0
d1583 1
a1583 1
       noFreqsInL2GP=quantity%template%noChans
d1746 1
a1746 1
       "$Id: DirectWrite_m.f90,v 2.76 2015/07/29 00:29:54 vsnyder Exp $"
d1756 3
@


2.76
log
@Convert Phi from pointer to allocatable
@
text
@d69 1
d391 1
a391 1
    & chunkNo, HGrids, createSwath, lowerOverlap, upperOverlap )
d407 1
d424 2
a425 1
        & sdName, chunkNo, HGrids, createSwath, lowerOverlap, upperOverlap )
d432 2
a433 1
    & sdName, chunkNo, HGrids, createSwath, lowerOverlap, upperOverlap )
d463 1
d574 2
a575 1
      & TotNumProfs=TotalProfs, createSwath=createSwath )
d1729 1
a1729 1
       "$Id: DirectWrite_m.f90,v 2.75 2015/07/14 23:32:01 pwagner Exp $"
d1739 3
@


2.75
log
@label and inputFile fields in DirectWrite
@
text
@d261 1
a261 1
      if ( associated(quantity%template%Phi) ) &
d279 1
a279 1
        if ( associated(quantity%template%Phi) ) &
d1222 1
a1222 1
    if ( associated(quantity%template%Phi) ) &
d1607 1
a1607 1
    if ( associated(quantity%template%phi) .and. quantity%template%stacked ) then
d1723 1
a1723 1
       "$Id: DirectWrite_m.f90,v 2.74 2015/04/29 01:15:09 vsnyder Exp $"
d1733 3
@


2.74
log
@Calculate TrueRank correctly, allow to use it if rank<0
@
text
@d1128 3
d1132 1
a1132 1
    & ChunkNo, Options, Rank )
d1148 1
d1188 30
a1217 22
    ! call outputNamedValue ( 'rank', myRank )
    trueRank = 2 + merge(1,0,quantity%template%noChans>1) + &
             &     merge(1,0,quantity%template%noCrossTrack>1)
    if ( myRank <= 0 ) then
      myRank = trueRank
    else if ( trueRank > myRank ) then
      call MLSMessage ( MLSMSG_Warning, moduleName, "Actual rank of Value %S is " // &
        & " %D but the specified rank is %D.  Are you sure this is what you want?", &
        & datum=[ quantity%template%name, trueRank, myRank] )
    end if
    select case ( myRank )
    case ( 1 )
      call SaveAsHDF5DS( grp_id, 'values', quantity%value1 )
    case ( 2 )
      call SaveAsHDF5DS( grp_id, 'values', quantity%values )
    case ( 3 )
      call SaveAsHDF5DS( grp_id, 'values', quantity%value3 )
    case ( 4 )
      call SaveAsHDF5DS( grp_id, 'values', quantity%value4 )
    case default
      call SaveAsHDF5DS( grp_id, 'values', quantity%values )
    end select
d1723 1
a1723 1
       "$Id: DirectWrite_m.f90,v 2.73 2015/04/25 02:10:36 vsnyder Exp $"
d1733 3
@


2.73
log
@Spiff a message
@
text
@d1128 2
a1129 2
  subroutine DirectWrite_Quantity ( File, quantity, qtyName, &
    & chunkNo, options, rank )
d1139 6
a1144 6
    type (VectorValue_T), intent(in) :: QUANTITY
    character(len=*), intent(in) :: qtyName       ! Name of qty in output file
    type(MLSFile_T)                :: File
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    character(len=*), intent(in), optional :: options
    integer, intent(in), optional :: rank
d1161 1
a1161 1
      if ( rank > 0 .and. rank < 5 ) myRank = rank
d1163 1
a1163 1
    endif
d1170 1
a1170 1
    endif
d1179 1
a1179 1
    endif
d1185 2
a1186 1
    trueRank = count(shape(quantity%value4)>1)
d1190 2
a1191 2
      call MLSMessage ( MLSMSG_Warning, moduleName, "Actual rank of Value $S is " // &
        & " $D but the specified rank is $D.  Are you sure this is what you want?", &
d1711 1
a1711 1
       "$Id: DirectWrite_m.f90,v 2.72 2015/04/21 17:53:03 pwagner Exp $"
d1721 3
@


2.72
log
@May DirectRead quantity geolocations
@
text
@d1136 1
d1151 1
a1151 1
    character(len=127) :: chunkStr ! chunk number '1', '2', .., then a temp later
d1189 3
a1191 6
      chunkStr = "Actual rank of Value"
      if ( quantity%template%name > 0 ) &
        & call get_string ( quantity%template%name, chunkStr(len_trim(chunkStr)+2:) )
      write ( chunkStr(len_trim(chunkStr)+1:), '(1x,3(a,i0))' ) " is ", trueRank, &
        & " but the specified rank is ", myRank, ".  Are you sure this is what you want?"
      call MLSMessage ( MLSMSG_Warning, moduleName, chunkStr )
d1710 1
a1710 1
       "$Id: DirectWrite_m.f90,v 2.71 2015/04/09 22:19:59 pwagner Exp $"
d1720 3
@


2.71
log
@We may DirectRead a quantity type
@
text
@d176 4
a179 3
    use hdf5, only: h5gclose_f, h5gcreate_f, h5gopen_f
    use intrinsic, only: l_none, lit_indices
    use MLSHDF5, only: isHDF5GroupPresent, isHDF5DSPresent, &
d181 2
a182 1
    use MLSStrings, only: writeintstochars
d184 1
a184 1
    type (VectorValue_T), intent(in) :: QUANTITY
d193 1
a193 1
    integer :: first_maf
d209 2
d256 41
d302 33
d1132 2
a1133 2
    use intrinsic, only: l_none, lit_indices
    use MLSHDF5, only: ishdf5grouppresent, ishdf5dspresent, &
a1145 1
    logical :: addQtyAttributes
a1147 1
    integer :: first_maf
d1173 1
a1173 1
      call outputNamedValue( '  creating file', trim(File%name) )
a1408 1
    integer :: status
d1712 1
a1712 1
       "$Id: DirectWrite_m.f90,v 2.69 2015/03/31 21:01:57 pwagner Exp $"
d1722 3
@


2.70
log
@Add warning about rank being wrong in DirectWrite_Quantity.  Add ability to
detect rank if requested rank is <= 0.  Add FrequencyCoordinate.
@
text
@d51 1
a51 1
    & DestroyDirectDatabase, DirectWrite, Dump, &
d61 4
d156 103
d270 1
a270 1
    use MLSSTRINGS, only: WRITEINTSTOCHARS
d319 1
a319 1
    use HGRIDSDATABASE, only: HGRID_T
d362 5
a366 5
    use HDF, only: DFACC_CREATE, DFACC_RDONLY, DFACC_RDWR
    use HGRIDSDATABASE, only: HGRID_T
    use L2GPDATA, only: L2GPDATA_T, &
      & APPENDL2GPDATA, DESTROYL2GPCONTENTS, DUMP
    use READAPRIORI, only: WRITEAPRIORIATTRIBUTES
d511 3
a513 3
    use CHUNKS_M, only: MLSCHUNK_T
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use MLSSTRINGS, only: WRITEINTSTOCHARS
d571 4
a574 4
    use CHUNKS_M, only: MLSCHUNK_T
    use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use HDF, only: DFACC_RDonly
d701 5
a705 5
    use CHUNKS_M, only: MLSCHUNK_T
    use HDF, only: SFN2INDEX, SFSELECT, SFCREATE, &
      & SFENDACC, DFNT_FLOAT32, SFWDATA_F90
    use INTRINSIC, only: L_NONE
    use MLSKINDS, only: R4, R8
d808 14
a821 14
    use CHUNKS_M, only: MLSCHUNK_T
    use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use FORWARDMODELSUPPORT, only: SHOWFWDMODELNAMES
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
    use INTRINSIC, only: L_NONE
    use L2AUXDATA, only:  L2AUXDATA_T, PHASENAMEATTRIBUTES, &
      & DESTROYL2AUXCONTENTS, &
      & SETUPNEWL2AUXRECORD, WRITEL2AUXATTRIBUTES
    use MLSHDF5, only: ISHDF5ATTRIBUTEPRESENT, ISHDF5DSPRESENT, &
      & MAKEHDF5ATTRIBUTE, SAVEASHDF5DS
    use MLSL2TIMINGS, only: SHOWTIMINGNAMES
    use PCFHDR, only: H5_WRITEMLSFILEATTR, H5_WRITEGLOBALATTR
    use QUANTITYTEMPLATES, only: WRITEATTRIBUTES
d1053 5
a1057 5
    use HDF5, only: H5GCLOSE_F, H5GCreate_F, H5GOPEN_F
    use INTRINSIC, only: L_NONE, Lit_Indices
    use MLSHDF5, only: ISHDF5GroupPRESENT, ISHDF5DSPRESENT, &
      & MAKEHDF5ATTRIBUTE, SAVEASHDF5DS
    use MLSSTRINGS, only: WRITEINTSTOCHARS
d1604 2
a1605 2
    use LEXER_CORE, only: PRINT_SOURCE
    use TREE, only: WHERE_AT=>WHERE
d1647 4
@


2.69
log
@rank is a new field for DirectWrite-ing quantity values as, say, rank3; now write qty attributes, too
@
text
@d951 1
d967 1
a967 1
    character(len=8) :: chunkStr        ! '1', '2', ..
d969 1
d1001 11
d1079 2
d1530 1
a1530 1
       "$Id: DirectWrite_m.f90,v 2.68 2015/03/28 02:30:58 vsnyder Exp $"
d1540 3
@


2.68
log
@Added stuff to trace allocate/deallocate addresses.  Paul added
DirectWriteQuantity stuff.
@
text
@d34 2
a35 2
  use MLSMessagemodule, only: MLSmessage, MLSmsg_error, MLSmsg_warning
  use MLSFiles, only: hdfversion_4, hdfversion_5, dump, MLS_exists, &
d39 1
a39 1
  use MLSL2options, only: writefileattributes
d45 1
a45 1
  use vectorsmodule, only: vector_t, vectorvalue_t, dump
d154 1
a154 1
    & chunkNo, options )
d169 1
d198 1
a198 1
        & chunkNo, options )
d944 1
a944 1
    & chunkNo, options )
d947 1
a947 4
    use INTRINSIC, only: L_NONE
    use L2AUXDATA, only:  L2AUXDATA_T, PHASENAMEATTRIBUTES, &
      & DESTROYL2AUXCONTENTS, &
      & SETUPNEWL2AUXRECORD, WRITEL2AUXATTRIBUTES
d957 1
d965 1
a965 5
    type (L2AUXData_T) :: l2aux
    integer :: last_maf
    logical :: mySingle
    integer :: NODIMS                   ! Also index of maf dimension
    integer :: Num_qty_values
a967 5
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: START(3)                 ! HDF array starting position
    integer :: STRIDE(3)                ! HDF array stride
    integer :: total_DS_size
    logical, parameter :: MAYCOLLAPSEDIMS = .false.
d973 5
d990 1
d998 13
a1010 1
    call SaveAsHDF5DS( grp_id, 'values', quantity%values )
d1035 32
d1515 1
a1515 1
       "$Id: DirectWrite_m.f90,v 2.67 2015/02/05 21:42:23 vsnyder Exp $"
d1525 4
@


2.67
log
@Don't use Phi for unstacked quantities
@
text
@d64 1
d66 1
a66 1
    module procedure DirectWriteVector_L2GP_MF
d103 1
d124 1
a124 1

d132 1
d144 2
d147 1
a147 1
      call test_deallocate ( status, moduleName, "database", s )
d152 49
d925 104
d1475 1
a1475 1
       "$Id: DirectWrite_m.f90,v 2.66 2014/12/11 21:27:04 pwagner Exp $"
d1485 3
@


2.66
log
@Turn off more printing unless verbose or debug
@
text
@d1200 7
a1206 2
    l2gp%geodAngle(firstProfile:lastProfile) = &
      & quantity%template%phi(1,useFirstInstance:useLastInstance)
d1317 1
a1317 1
       "$Id: DirectWrite_m.f90,v 2.65 2014/12/10 23:02:59 pwagner Exp $"
d1327 3
@


2.65
log
@Correct erroneous calculation of AscDescMode; now based on geodAngle
@
text
@d236 1
a236 1
      if ( .not. alreadyThere ) &
d241 4
a244 1
      if ( createSwath .and. alreadyThere ) then
d250 1
a250 1
      elseif ( verbose ) then
d1258 6
a1263 3
      call Dump( (/myRange%Bottom, myRange%top/), 'myRange' )
      call Dump( mod( l2gp%geodAngle(firstProfile:lastProfile), 360._rgp ), 'Orbit Angle' )
      call Dump( l2gp%AscDescMode(firstProfile:lastProfile), 'Mode' )
d1312 1
a1312 1
       "$Id: DirectWrite_m.f90,v 2.64 2014/11/04 01:25:41 pwagner Exp $"
d1322 3
@


2.64
log
@May switch on verbose, deebug modes with -Sdirect[n]
@
text
@d31 2
a32 1
  use MLSCommon, only: defaultundefinedvalue, MLSfile_t
d1087 4
a1090 4
    use HGRIDSDATABASE, only: HGRID_T
    use INTRINSIC, only: L_NONE
    use L2GPDATA, only: L2GPDATA_T, RGP, &
      & SETUPNEWL2GPRECORD
d1093 5
a1097 5
    type (VectorValue_T), pointer :: precision
    type (VectorValue_T), pointer :: quality
    type (VectorValue_T), pointer :: status
    type (VectorValue_T), pointer :: convergence
    type (VectorValue_T), pointer :: AscDescMode
d1102 1
d1243 15
d1306 1
a1306 1
       "$Id: DirectWrite_m.f90,v 2.63 2014/10/02 17:22:23 pwagner Exp $"
d1316 3
@


2.63
log
@DirectWrite now responsible for writing MiscNotes for l2gp files
@
text
@d28 1
a28 1
  use highoutput, only: beverbose, outputnamedvalue
d31 4
a34 4
  use MLScommon, only: defaultundefinedvalue, MLSfile_t
  use MLSkinds, only: rv
  use MLSmessagemodule, only: MLSmessage, MLSmsg_error, MLSmsg_warning
  use MLSfiles, only: hdfversion_4, hdfversion_5, dump, MLS_exists, &
d36 4
a39 4
  use MLSfinds, only: findfirst
  use MLShdfeos, only: MLS_swath_in_file
  use MLSl2options, only: writefileattributes
  use MLSstringlists, only: switchdetail
d219 1
a219 1
    ! logical :: DeeBug
d232 1
d310 10
d1104 1
d1106 4
d1112 1
d1115 4
a1118 5
    integer :: firstProfile
    integer :: lastProfile
    integer :: nProfiles

    real(rv) :: HUGERGP
d1244 7
a1250 3
    if ( DEEBUG ) print *, 'Vector converted to l2gp; name: ', trim(name)
    if ( DEEBUG ) print *, 'firstProfile, lastProfile: ', firstProfile, lastProfile
    if ( DEEBUG ) print *, 'useFirstInstance, useLastInstance: ', useFirstInstance, useLastInstance
d1289 1
a1289 1
       "$Id: DirectWrite_m.f90,v 2.62 2014/09/05 00:40:24 vsnyder Exp $"
d1299 3
@


2.62
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d27 18
a44 17
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST
  use HIGHOUTPUT, only: BEVERBOSE, OUTPUTNAMEDVALUE
  use INIT_TABLES_MODULE, only: L_PRESSURE, L_ZETA, &
    & L_L2GP, L_L2AUX, L_L2DGG, L_L2FWM
  use MLSCOMMON, only: DEFAULTUNDEFINEDVALUE, MLSFILE_T
  use MLSKINDS, only: RV
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
  use MLSFILES, only: HDFVERSION_4, HDFVERSION_5, DUMP, mls_exists, &
    & MLS_CLOSEFILE, MLS_OPENFILE
  use MLSFINDS, only: FINDFIRST
  use MLSHDFEOS, only: MLS_SWATH_IN_FILE
  use MLSL2OPTIONS, only: WRITEFILEATTRIBUTES
  use MLSSTRINGLISTS, only: SWITCHDETAIL
  use OUTPUT_M, only: BLANKS, OUTPUT
  use STRING_TABLE, only: GET_STRING
  use TOGGLES, only: SWITCHES
  use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T, DUMP
d824 2
d1269 1
a1269 1
       "$Id: DirectWrite_m.f90,v 2.61 2014/04/10 00:47:18 pwagner Exp $"
d1279 3
@


2.61
log
@More consistent in when to announce creating files, datasets
@
text
@d33 1
a33 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
    & MLSMSG_ERROR, MLSMSG_WARNING
d99 2
d119 4
d128 4
a131 1
    integer :: directIndex, status
d135 6
a140 9
        status = 0
        if ( associated(database(directIndex)%sdNames) ) &
          & deallocate ( database(directIndex)%sdNames, stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_deallocate // "sdNames" )
      enddo
       deallocate ( database, stat=status )
       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_deallocate // "database" )
d142 1
d982 1
d994 1
a994 1
    character(len=80), dimension(:), pointer :: sdNames => null()
d998 1
d1005 1
a1005 1
      enddo
d1014 1
a1014 3
    allocate(sdNames(newSize),STAT=status)
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "temp sdnames")
d1016 3
a1018 4
    if ( ASSOCIATED(directData%sdNames) ) &
      & deallocate ( directData%sdNames, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "sdNames" )
d1266 1
a1266 1
       "$Id: DirectWrite_m.f90,v 2.60 2014/04/07 18:03:03 pwagner Exp $"
d1276 3
@


2.60
log
@May specify AscDescMode when DirectWrite-ing swaths
@
text
@d35 2
d38 1
d213 1
d226 9
a234 1
      if ( createSwath ) then
d236 2
a390 2
    use MLSFILES, only: HDFVERSION_4, HDFVERSION_5, &
      & MLS_CLOSEFILE, MLS_OPENFILE
d406 1
a409 1
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
d414 1
a414 2
    verbose = BeVerbose ( 'direct', -1 )

d416 3
a521 1
    use MLSFILES, only: HDFVERSION_4
a532 4
    ! Local parameters
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, parameter :: HDFVERSION = HDFVERSION_4

a632 1
    use MLSFILES, only: HDFVERSION_5, DUMP
a650 4
    ! Local parameters
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, parameter :: HDFVERSION = HDFVERSION_5

d671 1
d674 1
d697 3
d702 1
d709 2
d1261 1
a1261 1
       "$Id: DirectWrite_m.f90,v 2.59 2014/01/09 00:30:24 pwagner Exp $"
d1271 3
@


2.59
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d36 1
d142 4
a145 3
    ! Write standard hdfeos-formatted files ala l2gp for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out profile-by-profile
d162 1
d165 1
a165 1
    nullify(precision, quality, status, convergence)
d170 1
a170 1
        & quantity, precision, quality, status, Convergence, &
d177 1
a177 1
    & quantity, precision, quality, status, Convergence, &
d181 8
a188 3
    ! Write standard hdfeos-formatted files ala l2gp for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out profile-by-profile
d201 1
d274 2
a275 1
      & precision, quality, status, convergence, l2gp, &
d831 1
a831 1
    call h5_writeMLSFileAttr(L2AUXFile, skip_if_already_there=.true.)
d1051 4
a1054 3
  subroutine vectorValue_to_l2gp (QUANTITY, &
    & precision, quality, status, convergence,  l2gp, &
    & name, chunkNo, HGrids, offset, firstInstance, lastInstance)
d1065 1
d1197 11
d1249 1
a1249 1
       "$Id: DirectWrite_m.f90,v 2.58 2013/11/20 00:56:19 pwagner Exp $"
d1259 3
@


2.58
log
@Reduce default dump of directWriteDB to just file names
@
text
@d28 1
d37 1
a37 1
  use OUTPUT_M, only: BEVERBOSE, BLANKS, OUTPUT, OUTPUTNAMEDVALUE
d1226 1
a1226 1
       "$Id: DirectWrite_m.f90,v 2.57 2013/09/24 23:47:22 vsnyder Exp $"
d1236 3
@


2.57
log
@Use Where instead of Source_Ref for messages
@
text
@d36 1
a36 1
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE
a207 1

d210 1
a210 1
    verbose = ( switchDetail(switches, 'direct') > -1 )
d323 1
a323 1
    verbose = ( switchDetail(switches, 'direct') > -1 )
d391 1
a391 1
    verbose = ( switchDetail(switches, 'direct') > -1 )
d865 6
a870 4
    call output ( 'File Name index: ')
    call output ( directWrite%fileIndex )
    call output ( '   File Name (base): ')
    call output ( trim(directWrite%fileNameBase), advance='yes' )
d873 1
d1225 1
a1225 1
       "$Id: DirectWrite_m.f90,v 2.56 2013/08/12 23:49:41 pwagner Exp $"
d1235 3
@


2.56
log
@FindSomethings moved to MLSFinds module
@
text
@d1191 1
a1191 1
    use TREE, only: SOURCE_REF
d1206 1
a1206 1
      call print_source ( source_ref(where) )
d1223 1
a1223 1
       "$Id: DirectWrite_m.f90,v 2.55 2013/05/08 20:17:35 pwagner Exp $"
d1233 3
@


2.55
log
@Changed sleep to usleep to link with NAG
@
text
@d34 1
a34 1
  use MLSSETS, only: FINDFIRST
d280 1
a280 1
    call usleep ( delay )
d1223 1
a1223 1
       "$Id: DirectWrite_m.f90,v 2.54 2013/05/07 22:23:30 pwagner Exp $"
d1233 3
@


2.54
log
@A workaround to prevent unexpected Missing/Fill values
@
text
@d77 2
d280 1
a280 1
    call sleep (1)
d1223 1
a1223 1
       "$Id: DirectWrite_m.f90,v 2.53 2012/05/10 00:48:19 pwagner Exp $"
d1233 3
@


2.53
log
@A little less clumsy at creating files, swaths
@
text
@d278 1
d1221 1
a1221 1
       "$Id: DirectWrite_m.f90,v 2.52 2012/03/12 17:09:44 pwagner Exp $"
d1231 3
@


2.52
log
@Use new writeAPrioriAttributes api
@
text
@d178 1
a178 1
    use HDF, only: DFACC_CREATE, DFACC_RDonly
d281 1
d1220 1
a1220 1
       "$Id: DirectWrite_m.f90,v 2.51 2012/02/24 21:19:15 pwagner Exp $"
d1230 3
@


2.51
log
@May DirectWrite a /single instance only
@
text
@d210 7
a274 4
      if ( present(createSwath) ) then
        call output('  createSwath: ', advance='no')
        call output(createSwath, advance='yes')
      endif
d281 1
a281 1
    if ( l2gpFile%access == DFACC_CREATE ) call writeAPrioriAttributes(l2gpFile)
d1219 1
a1219 1
       "$Id: DirectWrite_m.f90,v 2.50 2011/12/15 01:52:55 pwagner Exp $"
d1229 3
@


2.50
log
@'num' option names quantity in entireVector DirectWrites numerically
@
text
@d286 2
a287 1
    & chunkNo, chunks, FWModelConfig, lowerOverlap, upperOverlap, options )
d307 1
d339 2
a340 1
        & chunkNo, chunks, FWModelConfig, lowerOverlap, upperOverlap, options )
d347 2
a348 1
    & chunkNo, chunks, FWModelConfig, lowerOverlap, upperOverlap, options )
d373 1
d461 3
a463 2
        & chunkNo, chunks, FWModelConfig, &
        & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap, options=options )
d468 1
a468 1
        & options=options )
d595 2
a596 1
    & chunkNo, chunks, FWModelConfig, lowerOverlap, upperOverlap, options )
d623 1
d639 1
a639 1
    character(len=8) :: overlaps        ! 'lower', 'upper', or 'none'
d642 1
d669 3
d716 6
d1216 1
a1216 1
       "$Id: DirectWrite_m.f90,v 2.49 2011/11/01 21:44:31 pwagner Exp $"
d1226 3
@


2.49
log
@May optionally add quantity Attributes via options='A' field
@
text
@d294 1
d297 1
d309 1
d316 3
d330 6
a335 1
      call get_string( quantity%template%name, sdname )
d1198 1
a1198 1
       "$Id: DirectWrite_m.f90,v 2.48 2011/05/09 18:06:59 pwagner Exp $"
d1208 3
@


2.48
log
@May directwrite an entire vector
@
text
@d141 1
a141 1
    use HGridsDatabase, only: HGrid_T
d178 6
a183 5
    use Hdf, only: DFACC_CREATE, DFACC_RDONLY
    use HGridsDatabase, only: HGrid_T
    use L2GPData, only: L2GPData_T, &
      & AppendL2GPData, DestroyL2GPContents, DUMP
    use readApriori, only: writeAPrioriAttributes
d286 1
a286 1
    & chunkNo, chunks, FWModelConfig, lowerOverlap, upperOverlap )
d294 2
a295 2
    use Chunks_m, only: MLSChunk_T
    use ForwardModelConfig, only: ForwardModelConfig_T
d304 1
d326 1
a326 1
        & chunkNo, chunks, FWModelConfig, lowerOverlap, upperOverlap )
d333 1
a333 1
    & chunkNo, chunks, FWModelConfig, lowerOverlap, upperOverlap )
d341 6
a346 6
    use Chunks_m, only: MLSChunk_T
    use ChunkDivide_m, only: ChunkDivideConfig
    use ForwardModelConfig, only: ForwardModelConfig_T
    use Hdf, only: DFACC_RDONLY
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
      & mls_closeFile, mls_openFile
d348 1
d358 1
d446 1
a446 1
        & lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
d450 2
a451 1
        & FWModelConfig, lowerOverlap=lowerOverlap, upperOverlap=upperOverlap )
d469 2
a470 2
    use Chunks_m, only: MLSChunk_T
    use Hdf, only: SFN2INDEX, SFSELECT, SFCREATE, &
d472 3
a474 3
    use Intrinsic, only: L_None
    use MLSCommon, only: R4, R8
    use MLSFiles, only: HDFVERSION_4
d476 1
d578 1
a578 1
    & chunkNo, chunks, FWModelConfig, lowerOverlap, upperOverlap )
d580 15
a594 14
    use Chunks_m, only: MLSChunk_T
    use ChunkDivide_m, only: ChunkDivideConfig
    use ForwardModelConfig, only: ForwardModelConfig_T
    use ForwardModelSupport, only: ShowFwdModelNames
    use HDF5, only: h5gclose_f, h5gopen_f
    use Intrinsic, only: L_None
    use L2AUXData, only:  L2AUXData_T, PHASENAMEATTRIBUTES, &
      & DestroyL2AUXContents, &
      & SetupNewL2AUXRecord, WriteL2AUXAttributes
    use MLSFiles, only: HDFVERSION_5, Dump
    use MLSHDF5, only: IsHDF5AttributePresent, ISHDF5DSPRESENT, &
      & MakeHDF5Attribute, SaveAsHDF5DS
    use MLSL2Timings, only: showTimingNames
    use PCFHdr, only: H5_WRITEMLSFILEATTR, H5_WRITEGLOBALATTR
d596 1
d605 1
d612 1
d633 2
a634 1

d771 2
d1005 5
a1009 4
    use HGridsDatabase, only: HGrid_T
    use Intrinsic, only: L_None
    use L2GPData, only: L2GPData_T, RGP, &
      & SetupNewl2gpRecord
d1157 1
d1187 1
a1187 1
       "$Id: DirectWrite_m.f90,v 2.47 2010/02/04 23:12:44 vsnyder Exp $"
d1197 3
@


2.47
log
@Remove USE or declaration for unreferenced names
@
text
@d27 1
a27 1
  use Allocate_Deallocate, only: Allocate_test
d30 8
a37 5
  use MLSCommon, only: RV, DEFAULTUNDEFINEDVALUE, MLSFile_T
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    & MLSMSG_Error, MLSMSG_Warning
  use MLSSets, only: FindFirst
  use OUTPUT_M, only: blanks, OUTPUT
d39 1
a39 1
  use VectorsModule, only: VectorValue_T
d45 1
a45 1
    & DestroyDirectDatabase, DirectWrite_L2Aux, DirectWrite_L2GP, Dump, &
d55 1
a55 1
  interface DirectWrite_L2Aux
a56 3
  end interface

  interface DirectWrite_L2GP
d58 2
d132 37
d206 3
a208 3
    ! Executable code
    ! DeeBug = index(l2gp%name, 'lower') > 0 .or. &
    !   & index(l2gp%name, 'upper') > 0
d273 1
d278 1
a278 1
    if ( index(switches, 'l2gp') /= 0 ) call dump(l2gp)
d283 46
a344 1
    use VectorsModule, only: VectorValue_T, Dump
d363 3
a365 1
    ! executable code
d451 1
d455 1
a455 1
    if ( index(switches, 'l2aux') == 0 ) return
a469 1
    use VectorsModule, only: VectorValue_T
a587 1
    use VectorsModule, only: VectorValue_T
d1172 1
a1172 1
       "$Id: DirectWrite_m.f90,v 2.46 2010/02/04 19:10:26 pwagner Exp $"
d1182 3
@


2.46
log
@Change condition on directwrite db from associated to zero size
@
text
@a138 1
    use ChunkDivide_m, only: ChunkDivideConfig
a905 1
    use ChunkDivide_m, only: ChunkDivideConfig
d1086 1
a1086 1
       "$Id: DirectWrite_m.f90,v 2.45 2010/01/08 00:11:19 pwagner Exp $"
d1096 3
@


2.45
log
@Added ability to write MLSFile_T fields as attributes
@
text
@d790 1
a790 1
    if ( .not. associated(directDB) ) then
d1088 1
a1088 1
       "$Id: DirectWrite_m.f90,v 2.44 2009/06/23 18:46:18 pwagner Exp $"
d1098 3
@


2.44
log
@Prevent Intel from optimizing ident string away
@
text
@d48 1
a48 1
       "$RCSfile: $"
d501 1
a501 1
    use PCFHdr, only: h5_writeglobalattr
d687 1
d1088 1
a1088 1
       "$Id: read_apriori.f90 is it here $"
d1098 3
@


2.43
log
@May specify upperOverlap or lowerOverlap in DirectWrites
@
text
@d48 1
a48 1
       "$RCSfile: DirectWrite_m.f90,v $"
d1084 1
a1085 1
!---------------------------- RCS Ident Info -------------------------------
d1087 2
a1088 3
       "$Id: DirectWrite_m.f90,v 2.42 2008/09/20 00:03:00 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1090 1
a1090 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1092 1
d1097 3
@


2.42
log
@Added print statement to not_used_here
@
text
@d133 1
a133 1
    & sdName, chunkNo, HGrids, createSwath )
d155 2
d158 1
a158 2
    type (L2GPData_T) :: l2gp
    integer :: OFFSET
d161 1
d163 2
d169 2
d172 22
a193 3
    firstInstance = quantity%template%noInstancesLowerOverlap + 1
    lastInstance = quantity%template%noInstances - &
      & quantity%template%noInstancesUpperOverlap
a197 9
    if ( ChunkDivideConfig%allowPriorOverlaps .and. .false. ) then
      offset = offset - &
        & hGrids(quantity%template%hGridIndex)%noProfsLowerOverlap
      totalProfs = totalProfs - &
        & hGrids(quantity%template%hGridIndex)%noProfsLowerOverlap
    endif
    if ( ChunkDivideConfig%allowPostOverlaps .and. .false. ) &
      & totalProfs = totalProfs - &
      & hGrids(quantity%template%hGridIndex)%noProfsUpperOverlap
d221 2
a222 1
    if ( l2gp%name == 'Temperature-InitPtan' .and. deebug ) then
d246 1
a246 1
    & chunkNo, chunks, FWModelConfig )
a264 1
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
d269 2
d347 2
a348 1
        & chunkNo, chunks )
d351 2
a352 1
        & trim(sdName) // 'precision', L2AUXFile, chunkNo, chunks )
d355 2
a356 1
        & chunkNo, chunks, FWModelConfig )
d359 2
a360 1
        & trim(sdName) // 'precision', L2AUXFile, chunkNo, chunks, FWModelConfig )
d375 1
a375 1
    & chunkNo, chunks )
d391 2
d486 1
a486 1
    & chunkNo, chunks, FWModelConfig )
a504 1
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
d510 2
d525 1
d545 8
a568 7
    sizes(noDims) = quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap
    if ( MAYWRITEPOSTOVERLAPS .and. ChunkDivideConfig%allowPostOverlaps .and. &
      & chunkNo == size(chunks) ) &
      & sizes(noDims) = quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap
d572 25
a596 6
    first_maf = 1+quantity%template%noInstancesLowerOverlap
    last_maf = quantity%template%noInstances &
      &       - quantity%template%noInstancesUpperOverlap
    if ( MAYWRITEPOSTOVERLAPS .and. ChunkDivideConfig%allowPostOverlaps .and. &
      & chunkNo == size(chunks) ) &
      & last_maf = quantity%template%noInstances
a992 6
    if ( ChunkDivideConfig%allowPriorOverlaps .and. .false. ) &
      & L2GP%nTimesTotal = L2GP%nTimesTotal - &
      & hGrids(quantity%template%hGridIndex)%noProfsLowerOverlap
    if ( ChunkDivideConfig%allowPostOverlaps .and. .false. ) &
      & L2GP%nTimesTotal = L2GP%nTimesTotal - &
      & hGrids(quantity%template%hGridIndex)%noProfsUpperOverlap
d1087 1
a1087 1
       "$Id: DirectWrite_m.f90,v 2.41 2006/10/11 22:58:00 pwagner Exp $"
d1097 3
@


2.41
log
@Will write convergence ratio as another quality-like field of l2gp
@
text
@d218 1
a218 1
    call AppendL2GPData(l2gp, l2gpFile, &
d220 1
a220 1
      & TotNumProfs=TotalProfs, createSwath=createSwath)
d1047 1
a1047 1
       "$Id: DirectWrite_m.f90,v 2.40 2006/06/20 00:13:34 pwagner Exp $"
d1051 1
d1057 3
@


2.40
log
@Fwm files should haves MAFs matching radiance files
@
text
@d27 1
a27 1
  use Allocate_Deallocate, only: Allocate_test, DeAllocate_test
a34 1
  use STRING_TABLE, only: GET_STRING
d132 1
a132 1
    & quantity, precision, quality, status, &
d142 1
a142 1
    use L2GPData, only: L2GPData_T, L2GPNameLen, &
d150 1
a155 1
    logical :: alreadyOpen
d200 2
a201 1
    call vectorValue_to_l2gp(quantity, precision, quality, status, l2gp, &
d240 1
a240 1
    use Hdf, only: DFACC_CREATE, DFACC_RDONLY
d475 1
a475 1
      & MakeHDF5Attribute, SaveAsHDF5DS, GetHDF5Attribute
a507 1
    character (len=2000) :: value1
a738 1
    character(len=80), dimension(:), pointer :: sdNames => null()
d857 2
a858 1
  subroutine vectorValue_to_l2gp (QUANTITY, precision, quality, status, l2gp, &
d864 1
a864 2
      & SetupNewl2gpRecord, &
      & ExpandL2GPDataInPlace
d869 1
d1001 6
d1047 1
a1047 1
       "$Id: DirectWrite_m.f90,v 2.39 2006/05/11 19:39:19 pwagner Exp $"
d1056 3
@


2.39
log
@Should not segment fault if dumping empty DB
@
text
@d77 1
d238 1
d256 2
d260 1
d264 8
d302 2
a303 4
      call output('last profile: ', advance='no')
      call output((quantity%template%instanceOffset+quantity%template%noInstances - &
        & quantity%template%noInstancesLowerOverlap - &
        & quantity%template%noInstancesUpperOverlap), advance='yes')
d310 1
a310 1
    if ( DEEBUG ) then
d313 12
d465 1
d526 2
d539 4
d549 3
d1042 1
a1042 1
       "$Id: DirectWrite_m.f90,v 2.38 2006/04/20 23:24:12 pwagner Exp $"
d1051 3
@


2.38
log
@More bugs squashed related to extra-range MAFs; one crashed final chunk
@
text
@d625 4
a628 1
    if ( size(directDB) < 1 ) then
d1009 1
a1009 1
       "$Id: DirectWrite_m.f90,v 2.37 2006/04/19 20:48:13 pwagner Exp $"
d1018 3
@


2.37
log
@Undid most of the changes regarding extra MAFs; perhaps fixed bugs
@
text
@d179 1
a179 1
    if ( ChunkDivideConfig%allowPostOverlaps ) &
d204 13
a221 13
    if ( l2gp%name == 'Temperature-InitPtan' .and. deebug ) then
    call output('firstInstance: ', advance='no')
    call output(firstInstance, advance='no')
    call output('  lastInstance: ', advance='no')
    call output(lastInstance, advance='no')
    call output('  TotalProfs: ', advance='no')
    call output(TotalProfs, advance='yes')
    if ( present(createSwath) ) then
    call output('  createSwath: ', advance='no')
    call output(createSwath, advance='yes')
    endif
    call dump(l2gp, Details=-1)
    endif
d912 1
a912 1
    if ( ChunkDivideConfig%allowPriorOverlaps ) &
d915 1
a915 1
    if ( ChunkDivideConfig%allowPostOverlaps ) &
d1006 1
a1006 1
       "$Id: DirectWrite_m.f90,v 2.36 2006/04/12 22:20:42 pwagner Exp $"
d1015 3
@


2.36
log
@Attempted workaround for hdf5-1.6.5 bugs rewriting string attributes
@
text
@d173 1
a173 1
    if ( ChunkDivideConfig%allowPriorOverlaps ) then
d209 1
a209 1
    if ( l2gp%name == 'Temperature-Core' .and. deebug ) then
d1006 1
a1006 1
       "$Id: DirectWrite_m.f90,v 2.35 2006/04/11 23:33:14 pwagner Exp $"
d1015 3
@


2.35
log
@Fixed bug which added excess profiles
@
text
@a53 1
    module procedure DirectWrite_L2Aux_FH
a57 1
    ! module procedure DirectWrite_L2GP_FH
a225 362
  ! ------------------------------------------- DirectWrite_L2Aux_FH --------
  subroutine DirectWrite_L2Aux_FH ( fileID, quantity, precision, sdName, &
    & hdfVersion, chunkNo, chunks, FWModelConfig )

    ! Purpose:
    ! Write plain hdf-formatted files ala l2aux for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out chunk-by-chunk
    
    ! Despite the name the routine takes vector quantities, not l2aux ones
    use Chunks_m, only: MLSChunk_T
    use ForwardModelConfig, only: ForwardModelConfig_T
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5
    use VectorsModule, only: VectorValue_T, Dump

    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    type (VectorValue_T), intent(in) :: QUANTITY
    type (VectorValue_T), pointer :: PRECISION
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILEID       ! ID of output file
    integer, intent(in) :: HDFVERSION   ! Version of HDF file to write out
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    ! Local parameters
    logical, parameter :: DEEBUG = .FALSE.
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    ! executable code

    if ( (lastProfTooBigWarns <= MAXNUMWARNS) &
      & .and. &
      & (quantity%template%instanceOffset+quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap) &
      & > &
      & quantity%template%grandTotalInstances &
      & .and. &
      & quantity%template%grandTotalInstances > 0 ) then
      lastProfTooBigWarns = lastProfTooBigWarns + 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'last profile > grandTotalInstances for ' // trim(sdName))
      call output('instanceOffset: ', advance='no')
      call output(quantity%template%instanceOffset, advance='yes')
      call output('noInstances: ', advance='no')
      call output(quantity%template%noInstances, advance='yes')
      call output('noInstancesLowerOverlap: ', advance='no')
      call output(quantity%template%noInstancesLowerOverlap, advance='yes')
      call output('noInstancesUpperOverlap: ', advance='no')
      call output(quantity%template%noInstancesUpperOverlap, advance='yes')
      call output('last profile: ', advance='no')
      call output((quantity%template%instanceOffset+quantity%template%noInstances - &
        & quantity%template%noInstancesLowerOverlap - &
        & quantity%template%noInstancesUpperOverlap), advance='yes')
      call output('grandTotalInstances: ', advance='no')
      call output(quantity%template%grandTotalInstances, advance='yes')
      if ( lastProfTooBigWarns > MAXNUMWARNS ) &
          & call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Max no. of warnings reached--suppressing further ones')
    endif
    select case (hdfversion)
    case (HDFVERSION_4)
      call DirectWrite_L2Aux_FH_hdf4 ( quantity, sdName, fileID, &
        & chunkNo, chunks )
      if ( associated(precision) ) & 
        & call DirectWrite_L2Aux_FH_hdf4 ( precision, &
        & trim(sdName) // 'precision', fileID, chunkNo, chunks )
    case (HDFVERSION_5)
      call DirectWrite_L2Aux_FH_hdf5 ( quantity, sdName, fileID, &
        & chunkNo, chunks, FWModelConfig )
      if ( associated(precision) ) & 
        & call DirectWrite_L2Aux_FH_hdf5 ( precision, &
        & trim(sdName) // 'precision', fileID, chunkNo, chunks, FWModelConfig )
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unsupported hdfVersion for DirectWrite_L2Aux (currently only 4 or 5)' )
    end select
    if ( index(switches, 'l2aux') == 0 ) return
    call dump(quantity)
    if ( associated(precision) ) call dump(precision)
  end subroutine DirectWrite_L2Aux_FH

  ! ------------------------------------------ DirectWrite_L2Aux_FH_hdf4 --------
  subroutine DirectWrite_L2Aux_FH_hdf4 ( quantity, sdName, fileID, &
    & chunkNo, chunks )

    use Chunks_m, only: MLSChunk_T
    use Hdf, only: SFN2INDEX, SFSELECT, SFCREATE, &
      & SFENDACC, DFNT_FLOAT32, SFWDATA_F90
    use Intrinsic, only: L_None
    use MLSCommon, only: R4, R8
    use MLSFiles, only: HDFVERSION_4
    use VectorsModule, only: VectorValue_T

    type (VectorValue_T), intent(in) :: QUANTITY
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILEID       ! ID of output file
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS

    ! Local parameters
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, parameter :: HDFVERSION = HDFVERSION_4

    ! Local variables
    integer :: SDINDEX                  ! Index of sd
    integer :: SDID                     ! Handle for sd
    integer :: STATUS                   ! Status flag
    integer :: START(3)                 ! HDF array starting position
    integer :: STRIDE(3)                ! HDF array stride
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: NODIMS                   ! Also index of maf dimension
    type ( MLSChunk_T ) :: LASTCHUNK    ! The last chunk in the file
    real (r8) :: HUGER4

    ! executable code

    hugeR4 = real ( huge(0.0_r4), r8 )

    if ( quantity%template%frequencyCoordinate == L_None ) then
      noDims = 2
    else
      noDims = 3
    end if

    ! Create or access the SD
    sdIndex = sfn2index ( fileID, trim(sdName) )
    if ( sdIndex == -1 ) then
      lastChunk = chunks(size(chunks))
      sizes(noDims) = lastChunk%lastMAFIndex - lastChunk%noMAFSUpperOverlap + 1
      sizes(noDims-1) = quantity%template%noSurfs
      if ( noDims == 3 ) sizes(1) = quantity%template%noChans
      sdId  = sfCreate ( fileID, trim(sdName), DFNT_FLOAT32, &
        & noDims, sizes )
    else
      sdId = sfSelect ( fileID, sdIndex )
    end if
    if ( sdId == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
     & 'Error accessing SD '//trim(sdName) // ' (hdf4)')

    ! What exactly will be our contribution
    stride = 1
    start = 0
    sizes = 1
    sizes(noDims) = quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap
    sizes(noDims-1) = quantity%template%noSurfs
    if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    ! start(noDims) = quantity%template%mafIndex ( &
    !  & 1+quantity%template%noInstancesLowerOverlap )
    start(noDims) = quantity%template%instanceOffset
    ! if ( quantity%template%minorFrame ) &
    !  & start(noDims) = quantity%template%instanceOffset + 1

    ! Now write it out
    status = 0
    if ( sizes(noDims) > 0 ) &
      & status = SFWDATA_F90(sdId, start(1:noDims), &
      & stride(1:noDims), sizes(1:noDims), &
      & real ( max ( -hugeR4, min ( hugeR4, &
      &   quantity%values ( :, &
      &   1+quantity%template%noInstancesLowerOverlap : &
      &    quantity%template%noInstances - quantity%template%noInstancesUpperOverlap &
      &  ) ) ) ) )
    if ( status /= 0 ) then
      call announce_error (0,&
        & "Error writing SDS data " // trim(sdName) // " to l2aux file:  " )
    end if
    if ( DEEBUG ) then
      call output('noDims: ', advance='no')
      call output(noDims, advance='yes')
      call output('start: ', advance='no')
      call output(start, advance='yes')
      call output('stride: ', advance='no')
      call output(stride, advance='yes')
      call output('sizes: ', advance='no')
      call output(sizes, advance='yes')
      call output('shape(values): ', advance='no')
      call output(shape(quantity%values), advance='yes')
      call output('first instance: ', advance='no')
      call output(1+quantity%template%noInstancesLowerOverlap, advance='yes')
      call output('last instance: ', advance='no')
      call output(quantity%template%noInstances &
        & - quantity%template%noInstancesUpperOverlap, advance='yes')
    end if

    ! End access to the SD and close the file
    status = sfEndAcc ( sdId )
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error ending access to direct write sd (hdf4)' )

  end subroutine DirectWrite_L2Aux_FH_hdf4

  ! ------------------------------------------ DirectWrite_L2Aux_FH_hdf5 --------
  subroutine DirectWrite_L2Aux_FH_hdf5 ( quantity, sdName, fileID, &
    & chunkNo, chunks, FWModelConfig )

    use Chunks_m, only: MLSChunk_T
    use ForwardModelConfig, only: ForwardModelConfig_T
    use ForwardModelSupport, only: ShowFwdModelNames
    use HDF5, only: h5gclose_f, h5gopen_f
    use Intrinsic, only: L_None
    use L2AUXData, only:  L2AUXData_T, PHASENAMEATTRIBUTES, &
      & DestroyL2AUXContents, &
      & SetupNewL2AUXRecord, WriteL2AUXAttributes
    use MLSFiles, only: HDFVERSION_5
    use MLSHDF5, only: IsHDF5AttributePresent, ISHDF5DSPRESENT, &
      & MakeHDF5Attribute, SaveAsHDF5DS, GetHDF5Attribute
    use MLSL2Timings, only: showTimingNames
    use PCFHdr, only: h5_writeglobalattr
    use VectorsModule, only: VectorValue_T

    type (VectorValue_T), intent(in) :: QUANTITY
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILEID       ! ID of output file
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig

    ! Local parameters
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, parameter :: HDFVERSION = HDFVERSION_5

    ! Local variables
    logical :: already_there
    integer :: first_maf
    integer :: grp_id
    type (L2AUXData_T) :: l2aux
    integer :: last_maf
    type ( MLSChunk_T ) :: LASTCHUNK    ! The last chunk in the file
    integer :: NODIMS                   ! Also index of maf dimension
    integer :: Num_qty_values
    integer :: returnStatus
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: START(3)                 ! HDF array starting position
    integer :: STRIDE(3)                ! HDF array stride
    integer :: total_DS_size
    logical, parameter :: MAYCOLLAPSEDIMS = .false.
    character (len=2000) :: value1

    ! executable code
    Num_qty_values = size(quantity%values, 1)*size(quantity%values, 2)

    if ( quantity%template%frequencyCoordinate == L_None &
      & .and. MAYCOLLAPSEDIMS) then
      noDims = 2
    else
      noDims = 3
    end if

    ! Create or access the SD
    already_there = IsHDF5DSPresent(fileID, trim(sdName))
    if ( .not. already_there ) then
      lastChunk = chunks(size(chunks))
      sizes(noDims) = lastChunk%lastMAFIndex - lastChunk%noMAFSUpperOverlap + 1
      sizes(noDims-1) = quantity%template%noSurfs
      if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    end if

    ! What exactly will be our contribution
    stride = 1
    start = 0
    sizes = 1
    sizes(noDims) = quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap
    sizes(noDims-1) = quantity%template%noSurfs
    if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    ! start(noDims) = quantity%template%mafIndex ( &
    !  & 1+quantity%template%noInstancesLowerOverlap )
    start(noDims) = quantity%template%instanceOffset
    ! if ( quantity%template%minorFrame ) &
    !  & start(noDims) = quantity%template%instanceOffset + 1
    first_maf = 1+quantity%template%noInstancesLowerOverlap
    last_maf = quantity%template%noInstances &
      &       - quantity%template%noInstancesUpperOverlap

    if ( DEEBUG ) then
      print *, 'sdname ', trim(sdName)
      print *, 'already_there ', already_there
      print *, 'noDims ', noDims
      print *, 'instanceOffset ', quantity%template%instanceOffset
      print *, 'minorFrame ', quantity%template%minorFrame
      print *, 'start ', start
      print *, 'sizes ', sizes
      print *, 'shape(quantity%values) ', shape(quantity%values)
      print *, 'first_maf ', first_maf
      print *, 'last_maf ', last_maf
    endif
    ! Make certain things will fit
    if ( noDims == 3 ) then
      total_DS_size = sizes(1)*sizes(2)*sizes(3)
      if ( DEEBUG ) then
        print *, 'total_DS_size ', total_DS_size
        print *, 'Num_qty_values ', Num_qty_values
      endif
      if ( total_DS_size > Num_qty_values ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Number of 3d array elements to write > number stored in qty values' )
      call SaveAsHDF5DS( fileID, trim(sdName), &
        & real( &
        &   reshape(quantity%values(:,first_maf:last_maf), sizes(1:3)) &
        & ), start, sizes, may_add_to=.true., adding_to=already_there, &
        & fillValue=DEFAULTUNDEFINEDVALUE )
    else
      total_DS_size = sizes(1)*sizes(2)
      if ( DEEBUG ) then
        print *, 'total_DS_size ', total_DS_size
        print *, 'Num_qty_values ', Num_qty_values
      endif
      if ( total_DS_size > Num_qty_values ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Number of 2d array elements to write > number stored in qty values' )
      call SaveAsHDF5DS( fileID, trim(sdName), &
        & real( &
        &   reshape(quantity%values(:,first_maf:last_maf), sizes(1:2)) &
        & ), start, sizes, may_add_to=.true., adding_to=already_there, &
        & fillValue=DEFAULTUNDEFINEDVALUE)
    endif

    ! Now some attribute stuff
    if ( PHASENAMEATTRIBUTES ) then
      call h5gopen_f(fileID, '/', grp_id, returnstatus)
      if ( associated ( FWModelConfig ) ) then
        call MakeHDF5Attribute(grp_id, &
          & 'ForwardModel Names', trim(ShowFwdModelNames(FWModelConfig)), .false.)
      end if
      call MakeHDF5Attribute(grp_id, &
        & 'Phase Names', trim(showTimingNames('phases', .true.)), .false.)
      call h5gclose_f(grp_id, returnstatus)
    endif

    if ( already_there ) return
    ! sd-level attributes
    call SetupNewL2AUXRecord ( L2AUX, quantity%template, &
      & first_MAF, last_MAF-first_MAF+1 )
    if ( DEEBUG ) then
      call output('Writing attributes to: ', advance='no')
      call output(trim(sdName), advance='yes')
    endif
    call WriteL2AUXAttributes(fileID, l2aux, trim(sdName))
    ! Deallocate memory used by the l2aux
    call DestroyL2AUXContents ( l2aux )
    ! file-level attributes
    call h5_writeglobalattr(fileID, skip_if_already_there=.true.)
    if ( PHASENAMEATTRIBUTES ) then
      call h5gopen_f(fileID, '/', grp_id, returnstatus)
      !if ( .not. &
      !  & IsHDF5AttributePresent('/', fileID, 'Phase Names') ) &
      !  & call MakeHDF5Attribute(grp_id, &
      !  & 'Phase Names', trim(showTimingNames('phases', .true.)), .true.)
      if ( .not. &
        & IsHDF5AttributePresent('/', fileID, 'Section Names') ) &
        & call MakeHDF5Attribute(grp_id, &
        & 'Section Names', trim(showTimingNames('sections', .true.)), .true.)
      call h5gclose_f(grp_id, returnstatus)
    endif

  end subroutine DirectWrite_L2Aux_FH_hdf5

d449 1
a449 1
    use MLSFiles, only: HDFVERSION_5
d470 1
d485 1
d565 4
d571 1
d573 4
d579 2
a580 1
          & 'ForwardModel Names', trim(ShowFwdModelNames(FWModelConfig)), .false.)
d583 2
a584 1
        & 'Phase Names', trim(showTimingNames('phases', .true.)), .false.)
d1006 1
a1006 1
       "$Id: DirectWrite_m.f90,v 2.34 2006/01/26 00:34:50 pwagner Exp $"
d1015 3
@


2.34
log
@demoted more use statements from module level to speed Lahey compiles
@
text
@d59 1
a59 1
    module procedure DirectWrite_L2GP_FH
a131 64
  ! ------------------------------------------ DirectWrite_L2GP_FH --------
  subroutine DirectWrite_L2GP_FH ( L2gpFileHandle, &
    & quantity, precision, quality, status, &
    & sdName, chunkNo, hdfVersion, fileName, createSwath )

    ! Purpose:
    ! Write standard hdfeos-formatted files ala l2gp for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out profile-by-profile
    use L2GPData, only: L2GPData_T, L2GPNameLen, &
      & AppendL2GPData, DestroyL2GPContents, DUMP

    integer, intent(in) :: L2gpFileHandle
    type (VectorValue_T), intent(in) :: QUANTITY
    type (VectorValue_T), pointer :: precision
    type (VectorValue_T), pointer :: quality
    type (VectorValue_T), pointer :: status
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: HDFVERSION   ! Version of HDF file to write out
    integer, intent(in)              :: chunkNo
    character(len=*), intent(in), optional :: FILENAME
    logical, intent(in), optional :: createSwath
    ! Local variables
    type (L2GPData_T) :: l2gp
    integer :: OFFSET
    integer :: FIRSTINSTANCE
    integer :: LASTINSTANCE
    integer :: TOTALPROFS
    integer :: NOTOWRITE

    ! Executable code
    ! Size the problem
    firstInstance = quantity%template%noInstancesLowerOverlap + 1
    lastInstance = quantity%template%noInstances - &
      & quantity%template%noInstancesUpperOverlap
    noToWrite = lastInstance - firstInstance + 1
!     if ( noToWrite <= 0 ) then
!       call MLSMessage ( MLSMSG_Warning, 'No profiles in chunk to write' )
!       return
!     end if
    offset = quantity%template%instanceOffset
    totalProfs = quantity%template%grandTotalInstances

    ! Check sanity
    if ( offset + noToWrite - 1 > totalProfs .and. totalProfs > 0 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'last profile > grandTotalInstances for ' // trim(sdName) )
      ! Last-ditch effort resets offset
      offset = max(0, min(offset, totalProfs - noToWrite))
    endif
    ! Convert vector quantity to l2gp
    call vectorValue_to_l2gp(quantity, precision, quality, status, l2gp, &
      & sdname, chunkNo, offset=0, &
      & firstInstance=firstInstance, lastInstance=lastInstance)
    ! Output the l2gp into the file
    call AppendL2GPData(l2gp, l2gpFileHandle, &
      & sdName, filename, offset, lastprofile=lastInstance, &
      & TotNumProfs=TotalProfs, hdfVersion=hdfVersion, createSwath=createSwath)
    if ( index(switches, 'l2gp') /= 0 ) call dump(l2gp)
    ! Clear up our temporary l2gp
    call DestroyL2GPContents(l2gp)
  end subroutine DirectWrite_L2GP_FH

d135 1
a135 1
    & sdName, chunkNo, createSwath )
d141 1
d143 1
a151 1
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
d154 1
d161 1
d173 11
a183 2
    totalProfs = quantity%template%grandTotalInstances

d185 7
a191 1
    if ( offset + noToWrite - 1 > totalProfs .and. totalProfs > 0 ) then
d196 1
a196 1
      offset = max(0, min(offset, totalProfs - noToWrite))
d203 1
a203 1
      & sdname, chunkNo, offset=0, &
d211 13
d1175 3
a1177 1
    & name, chunkNo, offset, firstInstance, lastInstance)
a1187 1
    ! integer, intent(in)            :: nameIndex
d1189 1
d1263 6
d1357 1
a1357 1
       "$Id: DirectWrite_m.f90,v 2.33 2005/08/19 23:28:02 pwagner Exp $"
d1366 3
@


2.33
log
@Trying to avoid possibility of Lahey-causes memory leak
@
text
@a27 1
  use Hdf, only: DFACC_CREATE, DFACC_RDONLY
a34 1
  use readAPriori, only: APrioriFiles
d205 1
d635 1
a1341 5
    ! njl wants this done by l2cf in FillStatus Quantity
    !  if ( APrioriFiles%dao // AprioriFiles%ncep == ' ' ) &
    !    & l2gp%status(firstProfile:lastProfile) = &
    !    & l2gp%status(firstProfile:lastProfile) + CLIMATOLOGYFALLBACKSTATUS
    ! l2gp%status(firstProfile:lastProfile) = 'G'
d1382 1
a1382 1
       "$Id: DirectWrite_m.f90,v 2.32 2005/07/12 17:38:57 pwagner Exp $"
d1391 3
@


2.32
log
@Writes APriori File names as an attribute to every l2gp file
@
text
@d1129 2
a1131 1
    integer :: newsize
d1137 5
a1141 1
      alreadyThere = any(sdName == directData%sdNames)
d1387 1
a1387 1
       "$Id: DirectWrite_m.f90,v 2.31 2005/06/22 18:57:01 pwagner Exp $"
d1396 3
@


2.31
log
@Reworded Copyright statement, moved rcs id
@
text
@d28 1
a28 1
  use Hdf, only: DFACC_RDONLY
d36 1
d51 1
a51 1
       "$RCSfile: $"
d209 1
a209 1

d256 1
d1337 4
d1382 1
a1382 1
       "$Id: $"
d1391 3
@


2.30
log
@Interfaces changed to accept MLSFile_T args
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d48 3
a50 6
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: IdParm = &
    & "$Id: DirectWrite_m.f90,v 2.29 2004/11/29 21:52:41 livesey Exp $"
  character(len=len(idParm)) :: Id = idParm
  character(len=*), parameter :: ModuleName = &
    & "$RCSfile: DirectWrite_m.f90,v $"
d52 1
a52 1
  !-----------------------------------------------------------------------------
d1374 5
d1385 3
@


2.29
log
@Bug fix for handling cases where no forward models are defined.
@
text
@d20 1
d23 1
a23 1
  use MLSCommon, only: RV, DEFAULTUNDEFINEDVALUE
d42 1
a42 1
    & "$Id: DirectWrite_m.f90,v 2.28 2004/08/03 18:02:01 pwagner Exp $"
d49 10
d128 2
a129 2
  ! ------------------------------------------ DirectWrite_L2GP --------
  subroutine DirectWrite_L2GP ( L2gpFileHandle, &
d190 13
a202 1
  end subroutine DirectWrite_L2GP
d204 53
a256 2
  ! ------------------------------------------- DirectWrite_L2Aux_FileName --------
  subroutine DirectWrite_L2Aux ( fileID, quantity, precision, sdName, &
d316 1
a316 1
      call DirectWrite_L2Aux_hdf4 ( quantity, sdName, fileID, &
d319 1
a319 1
        & call DirectWrite_L2Aux_hdf4 ( precision, &
d322 1
a322 1
      call DirectWrite_L2Aux_hdf5 ( quantity, sdName, fileID, &
d325 1
a325 1
        & call DirectWrite_L2Aux_hdf5 ( precision, &
d334 1
a334 1
  end subroutine DirectWrite_L2Aux
d336 2
a337 2
  ! ------------------------------------------ DirectWrite_L2Aux_hdf4 --------
  subroutine DirectWrite_L2Aux_hdf4 ( quantity, sdName, fileID, &
d447 1
a447 1
  end subroutine DirectWrite_L2Aux_hdf4
d449 2
a450 2
  ! ------------------------------------------ DirectWrite_L2Aux_hdf5 --------
  subroutine DirectWrite_L2Aux_hdf5 ( quantity, sdName, fileID, &
d615 373
a987 1
  end subroutine DirectWrite_L2Aux_hdf5
d1375 3
@


2.28
log
@Sets fillValue for l2aux type
@
text
@d41 1
a41 1
    & "$Id: DirectWrite_m.f90,v 2.27 2004/07/22 20:42:57 cvuu Exp $"
d506 2
a507 1
      call MakeHDF5Attribute(grp_id, &
d509 1
d511 1
a511 1
          & 'Phase Names', trim(showTimingNames('phases', .true.)), .false.)
d929 3
@


2.27
log
@May write ForwardModel Names as file-level attributes and fix the phase names
@
text
@d22 1
a22 1
  use MLSCommon, only: RV
d41 1
a41 1
    & "$Id: DirectWrite_m.f90,v 2.26 2004/06/29 18:05:26 pwagner Exp $"
d485 2
a486 1
        & ), start, sizes, may_add_to=.true., adding_to=already_there )
d499 2
a500 1
        & ), start, sizes, may_add_to=.true., adding_to=already_there)
d927 3
@


2.26
log
@May write phase, section names as file-level attributes
@
text
@d41 1
a41 1
    & "$Id: DirectWrite_m.f90,v 2.25 2004/06/10 00:58:45 vsnyder Exp $"
d183 1
a183 1
    & hdfVersion, chunkNo, chunks )
d192 1
d196 1
d249 1
a249 1
        & chunkNo, chunks )
d252 1
a252 1
        & trim(sdName) // 'precision', fileID, chunkNo, chunks )
d377 1
a377 1
    & chunkNo, chunks )
d380 2
d389 1
a389 1
      & MakeHDF5Attribute, SaveAsHDF5DS
d400 1
d421 1
d502 9
d526 4
a529 4
      if ( .not. &
        & IsHDF5AttributePresent('/', fileID, 'Phase Names') ) &
        & call MakeHDF5Attribute(grp_id, &
        & 'Phase Names', trim(showTimingNames('phases', .true.)), .true.)
d925 3
@


2.25
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d41 1
a41 1
    & "$Id: DirectWrite_m.f90,v 2.24 2004/05/19 19:16:09 vsnyder Exp $"
d378 1
d380 2
a381 1
    use L2AUXData, only:  L2AUXData_T, DestroyL2AUXContents, &
d384 3
a386 1
    use MLSHDF5, only: ISHDF5DSPRESENT, SaveAsHDF5DS
d404 1
d410 1
d509 12
d910 3
@


2.24
log
@Move MLSChunk_t to Chunks_m
@
text
@d22 1
a22 1
  use MLSCommon, only: FindFirst, RV
d25 1
d41 1
a41 1
    & "$Id: DirectWrite_m.f90,v 2.23 2004/05/05 21:31:48 pwagner Exp $"
d892 3
@


2.23
log
@More debug printing
@
text
@d40 1
a40 1
    & "$Id: DirectWrite_m.f90,v 2.22 2004/03/03 19:25:45 pwagner Exp $"
d190 1
a190 1
    use MLSCommon, only: MLSCHUNK_T
d263 1
d267 1
a267 1
    use MLSCommon, only: MLSCHUNK_T, R4, R8
d376 1
a379 1
    use MLSCommon, only: MLSCHUNK_T
d891 3
@


2.22
log
@Fixed poorly understood prob with single chunks; more initializing in setup
@
text
@d40 1
a40 1
    & "$Id: DirectWrite_m.f90,v 2.21 2004/02/19 23:54:26 pwagner Exp $"
d777 1
d846 3
d890 3
@


2.21
log
@Dumps during directWrites if l2gp or l2aux switch set
@
text
@d40 1
a40 1
    & "$Id: DirectWrite_m.f90,v 2.20 2004/02/11 17:23:25 pwagner Exp $"
d161 6
a166 4
    if ( offset + noToWrite - 1 > totalProfs .and. totalProfs > 0 ) &
      & call MLSMessage ( MLSMSG_Warning, ModuleName, &
      'last profile > grandTotalInstances for ' // trim(sdName) )

d567 1
a567 1
    call output ('( eligible to be auto-filled)', advance='yes' )
d697 2
d700 2
d886 3
@


2.20
log
@l2gp status an integer, not a char
@
text
@d27 1
d40 1
a40 1
    & "$Id: DirectWrite_m.f90,v 2.19 2004/02/10 19:30:55 pwagner Exp $"
d126 1
a126 1
      & AppendL2GPData, DestroyL2GPContents
d173 1
d190 1
a190 1
    use VectorsModule, only: VectorValue_T
d252 3
d880 3
@


2.19
log
@Cures serial directWrites from writing more than one chunk at a time
@
text
@d39 1
a39 1
    & "$Id: DirectWrite_m.f90,v 2.18 2004/02/05 23:38:41 pwagner Exp $"
d117 2
a118 2
    & quantity, quantity_precision, sdName, chunkNo, &
    & hdfVersion, fileName, createSwath )
d129 3
a131 1
    type (VectorValue_T), pointer :: QUANTITY_PRECISION
d165 1
a165 1
    call vectorValue_to_l2gp(quantity, Quantity_precision, l2gp, &
d699 2
a700 3
  subroutine vectorValue_to_l2gp (QUANTITY, Quantity_precision, l2gp, &
    & name, chunkNo, &
    & offset, firstInstance, lastInstance)
d706 3
a708 1
    type (VectorValue_T), pointer :: QUANTITY_PRECISION
d813 1
a813 1
    if (associated(quantity_precision)) then
d816 1
a816 1
        &   quantity_precision%values(:,useFirstInstance:useLastInstance) ) ), &
d821 13
a833 2
    l2gp%status(firstProfile:lastProfile) = 'G'
    l2gp%quality(firstProfile:lastProfile) = 0.0
d875 3
@


2.18
log
@Writes attributes to directwrite l2aux file
@
text
@d39 1
a39 1
    & "$Id: DirectWrite_m.f90,v 2.17 2004/01/23 01:09:48 pwagner Exp $"
d168 2
a169 1
      & sdName, filename, offset, TotalProfs, hdfVersion, createSwath)
d861 3
@


2.17
log
@Only directwrite files entered in global settings eligible to be auto-sourced
@
text
@d39 1
a39 1
    & "$Id: DirectWrite_m.f90,v 2.16 2004/01/22 06:38:26 livesey Exp $"
d181 2
d366 2
d388 1
d478 12
a489 6
    ! This first call to write dataset-specific stuff needs work
    ! basically repeat the steps you go through in SetupNewl2auxRecord;
    ! see e.g. Join
    ! call WriteL2AUXAttributes(fileID, l2aux, trim(dataProduct%name))
    ! However I'm too lazy--these files won't be archived at DAAC
    ! so the attribute writing can wait
d860 3
@


2.16
log
@Typo fix
@
text
@d39 1
a39 1
    & "$Id: DirectWrite_m.f90,v 2.15 2004/01/22 00:56:35 pwagner Exp $"
d52 6
a57 5
    integer :: type ! l_l2aux or l_l2gp  ! should be at least L2GPNameLen
    integer :: fileIndex  ! Index into character tables nonsense
    integer :: Handle     ! Some bit of toolkit foolishness
    integer :: NSDNames
    character(len=80), dimension(:), pointer :: sdNames => null()
d59 1
a59 1
    character(len=1024) :: fileName ! E.g., '/data/../MLS..H2O..'
d541 6
a673 1
    ! Local variables
d675 1
d849 3
@


2.15
log
@Fixed many bugs in auto-distribution of DirectWrites
@
text
@d39 1
a39 1
    & "$Id: DirectWrite_m.f90,v 2.14 2003/12/03 17:50:54 pwagner Exp $"
d333 1
a333 1
    if ( DEEBU4 ) then
d842 3
@


2.14
log
@L2GP tracks both nTimes (for this slave) and nTimesTotal (done by all)
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d20 2
a21 1
  use INIT_TABLES_MODULE, only: L_PRESSURE, L_ZETA, L_L2GP, L_L2AUX
d34 1
a34 1
    & ExpandDirectDB, ExpandSDNames, &
d39 1
a39 1
    & "$Id: DirectWrite_m.f90,v 2.13 2003/11/14 23:38:45 pwagner Exp $"
d53 1
d333 1
a333 1
    if ( DEEBUG ) then
d520 3
a522 1
    call output ( 'File Name (base): ')
d533 4
d580 4
d637 21
d842 3
@


2.13
log
@Uses DirectWrite databse in preference to repeated calls to toolkit
@
text
@d38 1
a38 1
    & "$Id: DirectWrite_m.f90,v 2.12 2003/08/28 23:51:39 livesey Exp $"
d729 1
d809 3
@


2.12
log
@Various bug fixes and simplifications
@
text
@d19 3
a21 3
  use Allocate_Deallocate, only: Allocate_test
  use INIT_TABLES_MODULE, only: L_PRESSURE, L_ZETA
  use MLSCommon, only: RV
d24 1
a24 1
  use OUTPUT_M, only: OUTPUT
d30 5
a34 2
  public :: DirectData_T, AddDirectToDatabase, DestroyDirectDatabase, &
    & DirectWrite_L2Aux, DirectWrite_L2GP, SetupNewDirect
d38 1
a38 1
    & "$Id: DirectWrite_m.f90,v 2.11 2003/08/01 20:39:34 pwagner Exp $"
d45 5
d52 2
d56 1
d244 1
a244 1
  ! ----------------------------------------------- DirectWrite_L2Aux_hdf4 --------
d356 1
a356 1
  ! ----------------------------------------------- DirectWrite_L2Aux_hdf5 --------
d480 145
d628 1
a628 1
    ! This routine sets up the arrays for an l2gp datatype.
d636 3
a638 1

d808 3
@


2.11
log
@Skip warning mesg about grandTotalInstances when 0
@
text
@d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.10 2003/07/18 16:05:26 pwagner Exp $"
a41 10
  interface DirectWrite_L2GP
    module procedure DirectWrite_L2GP_fileID
    module procedure DirectWrite_L2GP_fileName
  end interface

  interface DirectWrite_L2Aux
    module procedure DirectWrite_L2Aux_fileID
    ! module procedure DirectWrite_L2Aux_fileName
  end interface

d101 2
a102 80
  ! ----------------------------------------------- DirectWrite_L2GP --------
  subroutine DirectWrite_L2GP_filename ( quantity, quantity_precision, sdName, &
    & file, chunkNo, hdfVersion, firstProf, lastProf, createSwath )

    ! Purpose:
    ! Write standard hdfeos-formatted files ala l2gp for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out profile-by-profile
    use Hdf, only: DFACC_CREATE, DFACC_RDWR
    use L2GPData, only: L2GPNameLen
    use MLSFiles, only:  &
      & GetPCFromRef, split_path_name, mls_exists, &
      & mls_io_gen_openF, mls_io_gen_closeF
    use MLSL2Options, only: TOOLKIT
    use MLSPCF2, only: mlspcf_l2gp_start, mlspcf_l2gp_end

    type (VectorValue_T), intent(in) :: QUANTITY
    type (VectorValue_T), pointer :: QUANTITY_PRECISION
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILE         ! Name of output file
    integer, intent(in) :: HDFVERSION   ! Version of HDF file to write out
    integer, intent(in)              :: chunkNo
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
    logical, intent(in), optional :: createSwath
    ! Local parameters
    logical, parameter :: DEBUG = .FALSE.
    character (len=132) :: FILE_BASE    ! From the FILE location in string table
    character (len=1024) :: FILENAME    ! The actual filename
    integer :: L2gpFileHandle, L2gp_Version
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    character (len=132) :: path
    character (len=L2GPNameLen) :: swathname    ! From the FILE location in string table
    integer :: fileaccess               ! DFACC_CREATE or DFACC_RDWR
    integer :: record_length
    integer :: ReturnStatus
    ! executable code

    ! Setup information, sanity checks etc.
    call get_string ( file, file_base, strip=.true. )
    ! call get_string ( sdname, swathname, strip=.true. )
    swathname=sdName
    L2gp_Version = 1
    if ( TOOLKIT ) then
      call split_path_name(file_base, path, file_base)
      if ( DEBUG ) call output('file_base after split: ', advance='no')
      if ( DEBUG ) call output(trim(file_base), advance='yes')

      L2gpFileHandle = GetPCFromRef(file_base, &
      & mlspcf_l2gp_start, mlspcf_l2gp_end, &
      & TOOLKIT, returnStatus, L2gp_Version, DEBUG, &
      & exactName=Filename)
    else
      Filename = file_base
      returnStatus = 0
    end if
    if ( returnStatus /= 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
         &  "Error finding l2gp file matching:  "// trim(file_base))
    endif
    if ( mls_exists(trim(Filename)) == 0 ) then
      fileaccess = DFACC_RDWR
    else
      fileaccess = DFACC_CREATE
    endif
    L2gpFileHandle = mls_io_gen_openF('sw', .true., returnStatus, &
        & record_length, FileAccess, FileName, hdfVersion=hdfVersion)
    call DirectWrite_L2GP_fileID( L2gpFileHandle, &
      & quantity, quantity_precision, sdName, chunkNo, &
      & hdfVersion, firstProf, lastProf, filename=filename, &
      & createSwath=createSwath )
    ReturnStatus = mls_io_gen_closeF('swclose', L2gpFileHandle, &
      & FileName=FileName, hdfVersion=hdfVersion)
    if ( ReturnStatus /= 0 ) &
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Unable to close L2gp file: " // trim(FileName) // ' after reading')
  end subroutine DirectWrite_L2GP_filename

  ! ------------------------------------------ DirectWrite_L2GP_fileID --------
  subroutine DirectWrite_L2GP_fileID ( L2gpFileHandle, &
d104 1
a104 1
    & hdfVersion, firstProf, lastProf, fileName, createSwath )
a119 1
    integer, intent(in), optional :: firstProf, lastProf ! Defaults to first and last
d122 1
a122 1
    ! Local parameters
d124 25
a148 34
    logical, parameter :: DEBUG = .FALSE.
    ! character (len=L2GPNameLen) :: swathname    ! From the FILE location in string table
    integer :: offset
    integer :: myFirstProf
    integer :: myLastProf
    integer :: FirstInstance
    integer :: LastInstance
    integer :: TotNumProfs
    ! executable code qty%template%instanceOffset + 1
    
    ! Non-overlapped portion of quantity:
    FirstInstance = quantity%template%noInstancesLowerOverlap+1
    LastInstance = quantity%template%noInstances- &
        & quantity%template%noInstancesUpperOverlap
        
    myFirstProf = 1
    if ( present(firstprof) ) myFirstProf = firstprof
    myLastProf = quantity%template%grandTotalInstances
    if ( present(lastprof) ) myLastProf = lastprof

    TotNumProfs = myLastProf
    offset = myFirstProf - 1
    if ( .not. present(firstprof) ) offset=quantity%template%instanceOffset
    if ( myLastProf > quantity%template%grandTotalInstances .and. &
      & quantity%template%grandTotalInstances > 0 ) then
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'last profile > grandTotalInstances for ' // trim(sdName))
      if (DEEBUG) then
        call output('last profile: ', advance='no')
        call output(myLastProf, advance='yes')
        call output('grandTotalInstances: ', advance='no')
        call output(quantity%template%grandTotalInstances, advance='yes')
      endif
    endif
d152 1
d154 2
a155 1
      & SDNAME, filename, offset, TotNumProfs, hdfVersion, createSwath)
d157 1
a157 1
  end subroutine DirectWrite_L2GP_fileID
d160 1
a160 1
  subroutine DirectWrite_L2Aux_FileID ( fileID, quantity, precision, sdName, &
d180 1
a180 1
    logical, parameter :: DEBUG = .FALSE.
d231 1
a231 1
  end subroutine DirectWrite_L2Aux_FileID
d650 3
@


2.10
log
@Stops printing warnings after 40 times
@
text
@d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.9 2003/07/15 23:41:47 pwagner Exp $"
d286 3
a288 1
      & quantity%template%grandTotalInstances) then
d746 3
@


2.9
log
@l2aux always rank 3 unless MAYCOLLAPSEDIMS; disabled most printing
@
text
@d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.8 2003/07/09 21:49:53 pwagner Exp $"
d60 2
d280 3
a282 1
    if ( (quantity%template%instanceOffset+quantity%template%noInstances - &
d287 1
d304 3
d536 1
a536 1
        & ), start, sizes, may_add_to=.true., adding_to=already_there)
d744 3
@


2.8
log
@Tries to figure out in advance whether to create swath
@
text
@d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.7 2003/07/07 21:03:43 pwagner Exp $"
d57 1
a57 1
  logical, parameter :: DEEBUG = .true.
d234 2
a235 1
    if ( myLastProf > quantity%template%grandTotalInstances ) then
d238 6
a243 4
      call output('last profile: ', advance='no')
      call output(myLastProf, advance='yes')
      call output('grandTotalInstances: ', advance='no')
      call output(quantity%template%grandTotalInstances, advance='yes')
d464 1
d469 7
a484 6
    if ( quantity%template%frequencyCoordinate == L_None ) then
      noDims = 2
    else
      noDims = 3
    end if

d539 3
a541 2
        & real(quantity%values(:,first_maf:last_maf)), &
        & start, sizes, may_add_to=.true., adding_to=already_there)
d736 3
@


2.7
log
@Removed DirectWrite_L2Aux_FileName; tries to deal sensibly with all-overlap chunks
@
text
@d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.6 2003/07/07 17:32:30 livesey Exp $"
d111 1
a111 1
    & file, chunkNo, hdfVersion, firstProf, lastProf )
d133 1
d178 4
a181 3
      & hdfVersion, firstProf, lastProf )
    ReturnStatus = mls_io_gen_closeF('swclose', L2gpFileHandle, FileName=FileName, &
      & hdfVersion=hdfVersion)
d190 1
a190 1
    & hdfVersion, firstProf, lastProf )
d207 2
d246 1
a246 1
      & SDNAME, offset, TotNumProfs, hdfVersion)
d377 1
d483 1
d730 3
@


2.6
log
@New approach to DirectWrite
@
text
@d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.5 2003/07/02 00:55:27 pwagner Exp $"
d49 1
a49 1
    module procedure DirectWrite_L2Aux_fileName
a246 95
  subroutine DirectWrite_L2Aux_FileName ( quantity, precision, sdName, file, &
    & hdfVersion, chunkNo, chunks )

    ! If slave, requests permission from master to access file
    ! Opens File (if it exists already) or else creates it
    ! Calls for direct write by file handle
    ! Closes file
    ! If slave, tells master it has finished
    use Hdf, only: DFACC_CREATE, DFACC_RDWR
    use L2ParInfo, only: PARALLEL !, REQUESTDIRECTWRITEPERMISSION, FINISHEDDIRECTWRITE
    use MLSCommon, only: MLSCHUNK_T
    use MLSFiles, only: &
      & GetPCFromRef, split_path_name, mls_sfstart, mls_sfend
    use MLSL2Options, only: TOOLKIT
    use MLSPCF2, only: mlspcf_l2fwm_full_start, mlspcf_l2fwm_full_end
    use VectorsModule, only: VectorValue_T

    type (VectorValue_T), intent(in) :: QUANTITY
    type (VectorValue_T), pointer :: PRECISION
    ! integer, intent(in) :: SDNAME       ! Name of sd in output file
    character(len=*), intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILE         ! Name of output file
    integer, intent(in) :: HDFVERSION   ! Version of HDF file to write out
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    ! Local parameters
    logical, parameter :: DEBUG = .FALSE.
    character (len=132) :: FILE_BASE    ! From the FILE location in string table
    character (len=1024) :: FILENAME    ! The actual filename
    integer :: fileID, L2fwm_Version
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, save :: NOCREATEDFILES=0   ! Number of files created

    character (len=132) :: path
    integer :: status
    integer :: ReturnStatus
    logical :: createFile
    logical :: you_may
    ! Saved variable - used to work out file information.
    integer, dimension(maxFiles), save :: CREATEDFILENAMES = 0
    ! executable code

    ! Setup information, sanity checks etc.
    call get_string ( file, file_base, strip=.true. )
    l2fwm_Version = 1
    if ( TOOLKIT ) then
      call split_path_name(file_base, path, file_base)
      if ( DEBUG ) call output('file_base after split: ', advance='no')
      if ( DEBUG ) call output(trim(file_base), advance='yes')

      fileID = GetPCFromRef(file_base, mlspcf_l2fwm_full_start, &
      & mlspcf_l2fwm_full_end, &
      & TOOLKIT, returnStatus, L2fwm_Version, DEBUG, &
      & exactName=Filename)
    else
      Filename = file_base
      returnStatus = 0
    end if
    if ( returnStatus /= 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
         &  "Error finding l2gp file matching:  "// trim(file_base))
    endif
    ! Setup information, sanity checks etc.
    ! If we're a slave, we need to request permission from the master.
    if ( parallel%slave ) then
!      call RequestDirectWritePermission ( file, createFile, .true., you_may )
    else
      createFile = .not. any ( createdFilenames == file )
      if ( createFile ) then
        noCreatedFiles = noCreatedFiles + 1
        if ( noCreatedFiles > maxFiles ) call MLSMessage ( &
          & MLSMSG_Error, ModuleName, 'Too many direct write files (hdf4)' )
        createdFilenames ( noCreatedFiles ) = file
      end if
    end if

    ! Create or open the file
    if ( createFile ) then
      fileID = mls_sfstart ( trim(filename), DFACC_CREATE, &
       & hdfVersion=hdfVersion )
    else
      fileID = mls_sfstart ( trim(filename), DFACC_RDWR, hdfVersion=hdfVersion )
    end if
    call DirectWrite_L2Aux_FileID ( fileID, quantity, precision, sdName, &
      & hdfVersion, chunkNo, chunks )

    status = mls_sfend( fileID, hdfVersion=hdfVersion)
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error ending closing direct write l2aux file' )

    ! Tell master we're done
!    if ( parallel%slave ) call FinishedDirectWrite
  end subroutine DirectWrite_L2Aux_FileName

  ! ------------------------------------------- DirectWrite_L2Aux_FileName --------
d385 3
a387 1
    status = SFWDATA_F90(sdId, start(1:noDims), &
d724 3
@


2.5
log
@Some improvements in DirectWrites of l2aux, l2gp
@
text
@d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.4 2003/06/25 18:24:57 pwagner Exp $"
d256 1
a256 2
    use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, &
      & FINISHEDDIRECTWRITE
d312 1
a312 1
      call RequestDirectWritePermission ( file, createFile, .true., you_may )
d338 1
a338 1
    if ( parallel%slave ) call FinishedDirectWrite
d817 3
@


2.4
log
@A fix to vectorValue_to_l2gp
@
text
@d23 1
a23 1
    & MLSMSG_Error
d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.3 2003/06/24 23:53:27 pwagner Exp $"
d57 1
d208 1
a208 1
    character (len=L2GPNameLen) :: swathname    ! From the FILE location in string table
d224 1
a224 1
    myLastProf = 1
d230 8
d242 1
a242 1
      & swathname, offset, TotNumProfs, hdfVersion)
d367 22
d477 2
a478 2
    if ( quantity%template%minorFrame ) &
      & start(noDims) = quantity%template%instanceOffset + 1
d492 17
a540 1
    logical, parameter :: DEEBUG = .false.
d580 2
a581 2
    if ( quantity%template%minorFrame ) &
      & start(noDims) = quantity%template%instanceOffset + 1
d590 2
d719 1
d801 1
a801 1
    call output ( ' OutputAndClose complained: ' )
d818 3
@


2.3
log
@Allows unassociated precisions as args to direct write
@
text
@d19 1
a19 1
  use Allocate_Deallocate, only: Allocate_test, Deallocate_test
d23 2
a24 2
    & MLSMSG_Error, MLSMSG_Warning, MLSMSG_Debug
  use OUTPUT_M, only: blanks, OUTPUT
d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.2 2003/06/23 23:55:17 pwagner Exp $"
d117 1
a117 1
    use L2GPData, only: L2GPData_T, L2GPNameLen
a137 2
    integer, save :: NOCREATEDFILES=0   ! Number of files created

d193 2
a194 7
    use L2GPData, only: L2GPData_T, L2GPNameLen, RGP, &
      & AppendL2GPData, DestroyL2GPContents, SetupNewl2gpRecord
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
      & GetPCFromRef, split_path_name
    use MLSL2Options, only: PENALTY_FOR_NO_METADATA, TOOLKIT, &
      & DEFAULT_HDFVERSION_WRITE
    use MLSPCF2, only: mlspcf_l2gp_start, mlspcf_l2gp_end
a206 7
    character (len=132) :: FILE_BASE    ! From the FILE location in string table
    character (len=1024) :: FILENAME    ! The actual filename
    integer :: L2gp_Version
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, save :: NOCREATEDFILES=0   ! Number of files created

    character (len=132) :: path
a213 2
    ! Saved variable - used to work out file information.
    integer, dimension(maxFiles), save :: CREATEDFILENAMES = 0
d228 4
a231 2
    call vectorValue_to_l2gp(QUANTITY, Quantity_precision, l2gp, &
      & sdname, myFirstProf, myLastProf, chunkNo, firstInstance, lastInstance)
d250 1
a250 1
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
d252 1
a252 2
    use MLSL2Options, only: PENALTY_FOR_NO_METADATA, TOOLKIT, &
      & DEFAULT_HDFVERSION_WRITE
d342 1
a342 5
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
      & GetPCFromRef, split_path_name
    use MLSL2Options, only: PENALTY_FOR_NO_METADATA, TOOLKIT, &
      & DEFAULT_HDFVERSION_WRITE
    use MLSPCF2, only: mlspcf_l2fwm_full_start, mlspcf_l2fwm_full_end
a354 3
    character (len=132) :: FILE_BASE    ! From the FILE location in string table
    character (len=1024) :: FILENAME    ! The actual filename
    integer :: L2fwmFileHandle, L2fwm_Version
a355 6
    integer, save :: NOCREATEDFILES=0   ! Number of files created

    character (len=132) :: path
    integer :: ReturnStatus
    ! Saved variable - used to work out file information.
    integer, dimension(maxFiles), save :: CREATEDFILENAMES = 0
d381 1
a381 1
    use Hdf, only: DFACC_CREATE, DFACC_RDWR, SFN2INDEX, SFSELECT, SFCREATE, &
a383 2
    use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, &
      & FINISHEDDIRECTWRITE
d385 1
a385 1
    use MLSFiles, only: HDFVERSION_4, MLS_SFSTART, MLS_SFEND
a399 1
    logical :: CREATEFILE               ! Set if file needs to be created
a472 1
    use HDF5, only: h5dopen_f
a473 2
    use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, &
     &  FINISHEDDIRECTWRITE
d475 1
a475 1
    use MLSFiles, only: HDFVERSION_5, MLS_SFSTART, MLS_SFEND
a492 1
    logical :: CREATEFILE               ! Set if file needs to be created
a498 2
    integer :: SDID                     ! Handle for sd
    integer :: SDINDEX                  ! Index of sd
a499 1
    integer :: STATUS                   ! Status flag
d607 2
a608 2
    & name, chunkNo, firstProfile, lastProfile, &
    & firstInstance, lastInstance)
d610 2
a611 2
    use L2GPData, only: L2GPData_T, L2GPNameLen, RGP, &
      & AppendL2GPData, DestroyL2GPContents, SetupNewl2gpRecord, &
a617 2
    integer, intent(in)              :: firstProfile
    integer, intent(in)              :: lastProfile
d619 1
d627 3
d664 8
a671 1
    call SetupNewl2gpRecord ( l2gp, noFreqsInL2GP, noSurfsInL2GP )
d685 2
a686 2
    call ExpandL2GPDataInPlace ( l2gp, &
      & lastProfile-firstProfile+1 )
a691 1
    ! call Get_String( nameIndex, l2gp%name, strip=.true.)
a692 2
    ! lastProfile=l2gp%nTimes
    ! firstProfile=lastProfile-noOutputInstances+1
d768 3
@


2.2
log
@Added DirectData_T to keep track of data written directly
@
text
@d19 1
d31 1
a31 1
    & DirectWrite_L2Aux, DirectWrite_L2GP
d35 1
a35 1
    & "$Id: DirectWrite_m.f90,v 2.1 2003/06/20 19:43:16 pwagner Exp $"
d53 3
a55 2
    integer :: type ! l_l2aux or l_l2gp
    character(len=80) :: sdName ! should be at least L2GPNameLen
d92 1
a92 1
    integer :: l2gpIndex, status
d95 7
d125 1
a125 1
    type (VectorValue_T), intent(in) :: QUANTITY_PRECISION
d205 1
a205 1
    type (VectorValue_T), intent(in) :: QUANTITY_PRECISION
d272 1
a272 1
    type (VectorValue_T), intent(in) :: PRECISION
d365 1
a365 1
    type (VectorValue_T), intent(in) :: PRECISION
d390 1
a390 1
      if ( associated(precision%values) ) & 
d396 1
a396 1
      if ( associated(precision%values) ) & 
d626 16
d652 1
a652 1
    type (VectorValue_T), intent(in) :: QUANTITY_PRECISION
d749 1
a749 1
    if (associated(quantity_precision%values)) then
d800 3
@


2.1
log
@First commit
@
text
@d21 2
a22 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d29 2
a30 1
  public :: DirectWrite_L2Aux, DirectWrite_L2GP
d34 1
a34 1
    & "$Id: DirectWrite_m.f90,v 2.72 2003/06/09 22:49:33 pwagner Exp $"
d51 4
d60 39
d775 3
@

