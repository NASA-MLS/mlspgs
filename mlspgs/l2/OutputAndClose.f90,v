head	2.209;
access;
symbols
	v5-02-NRT-19:2.209
	v6-00:2.209
	v5-02-NRT-18:2.209
	v5-02:2.207
	v5-01-NRT-17:2.208
	v5-01-NRT-16:2.208
	v5-01-NRT-15:2.208
	v5-01-NRT-14:2.208
	neuralnetworks-1-0:2.208.0.4
	cfm-single-freq-0-1:2.208.0.2
	v5-01:2.207
	v5-00:2.206
	v4-23-TA133:2.206.0.2
	mus-emls-1-70:2.205.0.2
	rel-1-0-englocks-work:2.204.0.2
	VUMLS1-00:2.201
	VPL1-00:2.200
	V4-22-NRT-08:2.199
	VAM1-00:2.193
	V4-21:2.190.0.2
	V4-13:2.188
	V4-12:2.184
	V4-11:2.184
	V4-10:2.184
	V3-43:2.149
	M4-00:2.167
	V3-41:2.149
	V3-40-PlusGM57:2.149.0.2
	V2-24-NRT-04:2.130
	V3-33:2.153
	V2-24:2.130
	V3-31:2.153
	V3-30-NRT-05:2.153
	cfm-01-00:2.152
	V3-30:2.149
	V3-20:2.149
	V3-10:2.143
	V2-23-NRT-02:2.130
	V2-23:2.130
	V2-22-NRT-01:2.130
	V2-22:2.130
	V2-21:2.127
	V2-20:2.126
	V2-11:2.124
	V2-10:2.124
	V2-00:2.124
	V1-51:2.104
	V1-50:2.104
	V1-45:2.99
	V1-44:2.99
	V1-43:2.96
	V1-32:2.94
	V1-31:2.88
	V1-30:2.84
	V1-13:2.69
	V1-12:2.69
	V1-11:2.68
	V1-10:2.64
	newfwm-feb03:2.66.0.2
	V1-04:2.50
	V1-03:2.50
	V1-02:2.50
	JointForwardModel:2.54.0.2
	V1-00:2.50
	newfwm-sep01:2.37.0.2
	V0-7:2.37
	V0-5-Level2:2.32
	V0-5-SIPS:2.23
	V0_1:1.6;
locks; strict;
comment	@# @;


2.209
date	2023.04.25.22.49.43;	author pwagner;	state Exp;
branches;
next	2.208;

2.208
date	2020.04.30.23.32.24;	author pwagner;	state Exp;
branches;
next	2.207;

2.207
date	2020.02.07.01.15.26;	author pwagner;	state Exp;
branches;
next	2.206;

2.206
date	2018.07.27.23.19.53;	author pwagner;	state Exp;
branches;
next	2.205;

2.205
date	2018.05.31.22.49.27;	author pwagner;	state Exp;
branches;
next	2.204;

2.204
date	2018.03.22.18.15.05;	author pwagner;	state Exp;
branches;
next	2.203;

2.203
date	2017.10.11.23.58.40;	author pwagner;	state Exp;
branches;
next	2.202;

2.202
date	2017.07.10.23.09.13;	author pwagner;	state Exp;
branches;
next	2.201;

2.201
date	2016.11.15.21.18.15;	author pwagner;	state Exp;
branches;
next	2.200;

2.200
date	2016.06.01.23.26.48;	author pwagner;	state Exp;
branches;
next	2.199;

2.199
date	2016.05.18.01.37.30;	author vsnyder;	state Exp;
branches;
next	2.198;

2.198
date	2016.04.01.00.27.15;	author pwagner;	state Exp;
branches;
next	2.197;

2.197
date	2016.02.29.19.51.22;	author pwagner;	state Exp;
branches;
next	2.196;

2.196
date	2015.11.19.23.57.23;	author pwagner;	state Exp;
branches;
next	2.195;

2.195
date	2015.10.15.23.07.54;	author pwagner;	state Exp;
branches;
next	2.194;

2.194
date	2015.09.30.23.02.27;	author pwagner;	state Exp;
branches;
next	2.193;

2.193
date	2015.08.03.21.45.22;	author pwagner;	state Exp;
branches;
next	2.192;

2.192
date	2015.06.19.20.54.56;	author pwagner;	state Exp;
branches;
next	2.191;

2.191
date	2015.03.28.02.50.35;	author vsnyder;	state Exp;
branches;
next	2.190;

2.190
date	2015.02.18.00.29.03;	author pwagner;	state Exp;
branches;
next	2.189;

2.189
date	2014.11.04.01.23.50;	author pwagner;	state Exp;
branches;
next	2.188;

2.188
date	2014.10.13.18.10.01;	author pwagner;	state Exp;
branches;
next	2.187;

2.187
date	2014.10.07.00.06.47;	author pwagner;	state Exp;
branches;
next	2.186;

2.186
date	2014.09.05.01.16.18;	author vsnyder;	state Exp;
branches;
next	2.185;

2.185
date	2014.09.05.00.49.07;	author vsnyder;	state Exp;
branches;
next	2.184;

2.184
date	2014.04.14.17.39.48;	author pwagner;	state Exp;
branches;
next	2.183;

2.183
date	2014.04.07.18.09.27;	author pwagner;	state Exp;
branches;
next	2.182;

2.182
date	2014.04.02.23.04.34;	author pwagner;	state Exp;
branches;
next	2.181;

2.181
date	2014.03.28.00.01.10;	author pwagner;	state Exp;
branches;
next	2.180;

2.180
date	2014.03.26.17.46.59;	author pwagner;	state Exp;
branches;
next	2.179;

2.179
date	2014.02.28.01.06.44;	author vsnyder;	state Exp;
branches;
next	2.178;

2.178
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.177;

2.177
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.176;

2.176
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.175;

2.175
date	2013.10.15.23.52.55;	author pwagner;	state Exp;
branches;
next	2.174;

2.174
date	2013.10.09.23.42.13;	author vsnyder;	state Exp;
branches;
next	2.173;

2.173
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.172;

2.172
date	2013.09.06.21.10.45;	author pwagner;	state Exp;
branches;
next	2.171;

2.171
date	2013.09.04.17.35.47;	author pwagner;	state Exp;
branches;
next	2.170;

2.170
date	2013.08.30.02.45.45;	author vsnyder;	state Exp;
branches;
next	2.169;

2.169
date	2013.08.20.00.32.11;	author pwagner;	state Exp;
branches;
next	2.168;

2.168
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.167;

2.167
date	2012.11.08.23.20.00;	author pwagner;	state Exp;
branches;
next	2.166;

2.166
date	2012.08.16.17.51.43;	author pwagner;	state Exp;
branches;
next	2.165;

2.165
date	2012.07.10.15.21.15;	author pwagner;	state Exp;
branches;
next	2.164;

2.164
date	2012.07.05.23.54.21;	author pwagner;	state Exp;
branches;
next	2.163;

2.163
date	2012.05.14.18.33.34;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2012.05.11.00.18.37;	author pwagner;	state Exp;
branches;
next	2.161;

2.161
date	2012.05.10.00.47.02;	author pwagner;	state Exp;
branches;
next	2.160;

2.160
date	2012.03.14.16.57.03;	author pwagner;	state Exp;
branches;
next	2.159;

2.159
date	2012.03.12.17.28.22;	author pwagner;	state Exp;
branches;
next	2.158;

2.158
date	2012.02.24.21.18.01;	author pwagner;	state Exp;
branches;
next	2.157;

2.157
date	2012.02.08.23.16.30;	author pwagner;	state Exp;
branches;
next	2.156;

2.156
date	2011.11.30.21.34.23;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2011.07.15.00.14.28;	author pwagner;	state Exp;
branches;
next	2.154;

2.154
date	2011.06.29.21.51.51;	author pwagner;	state Exp;
branches;
next	2.153;

2.153
date	2010.09.17.00.07.18;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2010.05.20.00.32.32;	author pwagner;	state Exp;
branches;
next	2.151;

2.151
date	2010.03.24.20.53.45;	author vsnyder;	state Exp;
branches;
next	2.150;

2.150
date	2010.02.25.18.18.31;	author pwagner;	state Exp;
branches;
next	2.149;

2.149
date	2010.02.04.23.12.44;	author vsnyder;	state Exp;
branches;
next	2.148;

2.148
date	2010.01.08.00.11.37;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2009.11.10.00.44.03;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2009.10.01.19.53.53;	author vsnyder;	state Exp;
branches;
next	2.145;

2.145
date	2009.09.29.23.37.32;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2009.08.26.17.18.42;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2009.07.01.20.37.30;	author pwagner;	state Exp;
branches;
next	2.142;

2.142
date	2009.06.26.00.17.14;	author pwagner;	state Exp;
branches;
next	2.141;

2.141
date	2009.06.23.18.45.16;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2009.06.02.17.53.15;	author cvuu;	state Exp;
branches;
next	2.139;

2.139
date	2009.04.27.20.45.18;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2009.04.01.23.32.32;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2008.12.02.23.13.15;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2008.09.19.23.55.50;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2008.07.09.16.38.24;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2008.04.25.22.55.29;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2008.03.24.17.07.02;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2008.02.22.21.36.41;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2007.12.07.01.51.40;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2007.05.30.22.30.29;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2007.04.05.22.52.01;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2007.03.23.00.28.39;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2007.01.18.19.39.16;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2006.10.02.23.06.56;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2006.08.02.19.52.55;	author vsnyder;	state Exp;
branches;
next	2.124;

2.124
date	2006.05.09.16.40.41;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2006.04.28.00.46.28;	author pwagner;	state Exp;
branches;
next	2.122;

2.122
date	2006.04.11.23.35.38;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2006.03.15.23.47.53;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2006.03.04.00.23.30;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2006.02.21.19.13.33;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2005.12.21.18.46.29;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2005.12.10.00.51.36;	author pwagner;	state Exp;
branches;
next	2.116;

2.116
date	2005.11.15.00.22.05;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2005.11.04.18.55.46;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2005.10.28.23.19.01;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2005.10.22.00.46.14;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2005.09.23.23.39.35;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2005.09.21.23.27.17;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2005.09.14.00.15.32;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2005.08.19.23.35.35;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2005.06.22.18.57.02;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2005.06.16.18.43.01;	author pwagner;	state Exp;
branches;
next	2.106;

2.106
date	2005.06.14.20.43.49;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2005.03.15.23.57.23;	author pwagner;	state Exp;
branches;
next	2.104;

2.104
date	2004.12.14.21.45.01;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2004.09.23.23.02.46;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2004.09.16.23.57.54;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2004.09.16.00.19.05;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2004.08.26.18.52.56;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2004.08.04.23.19.58;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2004.06.10.00.58.45;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2004.05.19.20.22.09;	author vsnyder;	state Exp;
branches;
next	2.96;

2.96
date	2004.04.24.00.22.55;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2004.03.12.00.39.37;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2004.03.03.19.23.48;	author pwagner;	state Exp;
branches;
next	2.93;

2.93
date	2004.02.19.23.57.47;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2004.02.05.23.35.21;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2004.01.27.21.37.26;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2004.01.23.01.15.00;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2004.01.22.00.52.19;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2003.11.07.00.46.51;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2003.10.28.21.42.36;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2003.10.20.23.59.20;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2003.10.16.18.29.35;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2003.09.19.23.29.27;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2003.09.04.22.42.47;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2003.08.15.20.43.10;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2003.08.08.23.06.39;	author livesey;	state Exp;
branches;
next	2.80;

2.80
date	2003.08.01.20.07.44;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2003.07.23.18.29.32;	author cvuu;	state Exp;
branches;
next	2.78;

2.78
date	2003.07.07.23.49.11;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2003.07.07.17.31.44;	author livesey;	state Exp;
branches;
next	2.76;

2.76
date	2003.06.26.00.17.17;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2003.06.24.23.54.07;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2003.06.23.18.06.33;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2003.06.20.19.38.26;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2003.06.09.22.49.33;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2003.05.12.02.07.06;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2003.04.03.22.59.23;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2003.03.20.19.22.56;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2003.03.11.00.21.36;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2003.03.01.00.25.20;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2003.02.12.21.51.32;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2003.02.10.22.01.54;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2003.01.23.23.31.42;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2002.12.11.22.21.05;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2002.11.22.19.10.30;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2002.11.13.01.10.09;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2002.10.08.17.36.22;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2002.08.21.02.35.18;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2002.08.21.01.05.06;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2002.08.20.04.37.06;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2002.08.20.04.33.13;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2002.08.15.21.47.04;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2002.06.12.17.58.42;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2002.05.22.16.30.31;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2002.05.22.00.49.01;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2002.05.07.20.26.15;	author livesey;	state Exp;
branches
	2.51.2.1;
next	2.50;

2.50
date	2002.02.22.19.19.48;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2002.02.22.01.16.17;	author pwagner;	state Exp;
branches;
next	2.48;

2.48
date	2002.01.29.23.49.38;	author pwagner;	state Exp;
branches;
next	2.47;

2.47
date	2002.01.26.00.10.45;	author pwagner;	state Exp;
branches;
next	2.46;

2.46
date	2002.01.23.21.52.15;	author pwagner;	state Exp;
branches;
next	2.45;

2.45
date	2002.01.18.23.07.48;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2002.01.18.00.24.34;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2001.11.20.00.48.54;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2001.11.01.21.05.10;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2001.10.12.23.12.23;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2001.09.28.23.59.20;	author pwagner;	state Exp;
branches;
next	2.38;

2.38
date	2001.09.28.17.50.30;	author pwagner;	state Exp;
branches;
next	2.37;

2.37
date	2001.06.04.23.57.40;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2001.05.30.23.03.13;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.17.22.33.28;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2001.05.04.23.22.13;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2001.05.04.23.19.55;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2001.05.03.20.32.33;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2001.05.01.23.57.23;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2001.04.28.01.30.52;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2001.04.26.20.02.09;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2001.04.26.15.59.13;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.25.21.51.28;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.25.20.34.04;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.20.23.51.24;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2001.04.19.23.51.40;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2001.04.16.23.51.08;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.13.23.48.37;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.13.00.26.23;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.12.22.19.33;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.04.10.23.01.57;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2001.04.09.23.44.34;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.07.00.13.44;	author pwagner;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.04.23.44.52;	author pwagner;	state Exp;
branches;
next	2.15;

2.15
date	2001.04.03.23.51.28;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2001.04.02.23.43.46;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2001.03.28.00.23.20;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2001.03.20.18.35.02;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2001.03.15.21.18.57;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.03.06.22.40.24;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.02.23.18.15.48;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.02.13.22.59.36;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.02.09.19.30.16;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.02.09.00.38.22;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.01.03.18.15.13;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2000.11.16.02.25.13;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2000.10.05.16.43.00;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2000.09.11.19.43.47;	author ahanzel;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.03;	author ahanzel;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.29.23.58.42;	author lungu;	state Exp;
branches;
next	;

2.51.2.1
date	2002.05.22.23.14.42;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.209
log
@Fixed bug preventing us from processing more than one command per Output section
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================================================

module OutputAndClose ! outputs all data from the Join module to the
                      ! appropriate L2 Files

!==============================================================================

  use HDF, only: Dfacc_Rdonly, Dfacc_Rdwr
  use HighOutput, only: LetsDebug, OutputNamedValue
  use Machine, only: USleep
  use MLSFiles, only: HDFVersion_5, AddInitializeMLSFile, Dump, &
    & GetMLSFileByName, GetMLSFileByType, GetPCFromRef, &
    & MLS_CloseFile, MLS_Exists, MLS_Inqswath, MLS_OpenFile, &
    & MLS_SFStart, MLS_SFEnd, &
    & Split_Path_Name, UnSplitName
  use MLSHDF5, only: GetHDF5Attribute, MakeHDF5Attribute
  use MLSL2Options, only: Checkpaths, Default_HDFVersion_Write, L2cfnode, &
    & SpecialDumpFile, SkipDirectwrites, Toolkit, &
    & MLSL2Message, WriteFileAttributes
  use MLSMessageModule, only: MLSMSG_Error, MLSMSG_Info, MLSMSG_Warning
  use String_Table, only: Display_String, Get_String
  use Toggles, only: Gen, Toggle, Switches

  implicit none
  private
  public :: OUTPUT_CLOSE, ADD_METADATA

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: OutputAndClose.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! -----     Private declarations     ---------------------------------

  ! Should we get any of this from MLSL2Options?
  logical, parameter :: COPYGLOBALATTRIBUTES = .true.
  logical, parameter :: DGGFILEISHYBRID = .false.      ! may write PCF as DS?
  logical, parameter :: LOGFILEGETSMETADATA = .false.  ! metadata to log file?
  logical, parameter :: FAKEPARALLELMASTER =  .false.  ! make up fake stuff?
  integer, parameter :: MAXQUANTITIESPERFILE = 10000
  ! For Announce_Error
  integer :: ERROR

contains ! =====     Public Procedures     =============================

  ! -----------------------------------------------  Output_Close  -----
  subroutine Output_Close ( root, L2GPDatabase, L2AUXDatabase, DirectDatabase, &
    & matrices, hessians, vectors, fileDataBase, GriddedDataBase, &
    & chunks, processingRange, canWriteL2PC )

    ! Hard-wired assumptions:

    ! ----------------------- metadata ------------------------

    !   for the l2aux the mcf is MLSPCF_MCF_L2DGM_Start
    !   for the log file the mcf is MLSPCF_MCF_L2LOG_Start
    !   for the dgg file the mcf is MLSPCF_MCF_L2DGG_Start

    ! The correspondence between MCF and l2gp files is determined by
    ! the value of        MCFFORL2GPOPTION
    ! (see write_metadata module for fuller explanation)

    use Allocate_Deallocate, only: Deallocate_Test, Allocate_Test
    use Chunks_M, only: MLSChunk_T, Dump
    use ChunkDivide_M, only: ChunkDivideConfig, Obstructions
    use DestroyCommand_M, only: DestroyCommand
    use DirectWrite_M, only: DirectData_T, Dump
    use DumpCommand_M, only: BooleanFromEmptySwath, BooleanFromFormula, &
      & DumpCommand, ExecuteCommand, MLSCase, MLSEndselect, MLSSelect, &
      & MLSSelecting, Skip
    use Expr_M, only: Expr
    use GriddedData, only: GriddedData_T
    use HessianModule_1, only: Hessian_T
    use HGrid, only: CreateHGridfromMLSCfinfo, DealWithObstructions
    use HGridsDatabase, only: HGrid_T, HGrids_T, &
      & AddHGridtoDatabase, Dump
    use Init_Tables_Module, only: F_Additional, F_AttrName, F_AttrValue, &
      & F_Destroy, F_Dontpack, F_File, F_HDFversion, &
      & F_MetaDataonly, F_Metaname, F_Moleculesecondderivatives, F_Overlaps, &
      & F_Packed, F_Quantities, F_Reset, F_Time, F_Type, F_WritecounterMAF, &
      & Field_First, Field_Last, &
      & L_L2aux, L_L2cf, L_L2dgg, L_L2gp, L_L2pc, &
      & S_Boolean, S_Case, S_Catenate, S_Copy, &
      & S_Destroy, S_Diff, S_Dump, S_Dumpblocks, S_Endselect, S_Execute, &
      & S_Hgrid, S_IsFileAbsent, S_Isswathempty, S_L2gp, S_Output, &
      & S_Reevaluate, S_Select, S_Skip, S_Sleep, S_Time, S_WriteFileAttribute
    use Intrinsic, only: Lit_Indices
    use L2AUXData, only: L2AUXData_T
    use L2GPData, only: L2GPData_T, &
      & AddL2GPToDatabase, WriteMastersFileAttributes
    use L2PC_M, only: OutputHDF5L2PC
    use L2ParInfo, only: Parallel
    use MatrixModule_1, only: Matrix_Database_T
    use MatrixTools, only: Dumpblocks
    use MLSCommon, only: MLSFile_T, Tai93_Range_T, Filenamelen
    use MLSL2Timings, only: Section_Times
    use MLSPCF2, only: MLSPCF_L2GP_End, &
      & MLSPCF_L2GP_Start, MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End
    use MLSStringlists, only: Switchdetail
    use MLSStrings, only: Trim_Safe
    use Moretree, only: Get_Label_And_Spec, Get_Spec_Id, Get_Boolean
    use Next_Tree_Node_M, only: Next_Tree_Node, Next_Tree_Node_State
    use Output_M, only: Output, RevertOutput, SwitchOutput
    use Time_M, only: SayTime, Time_Now
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decorate, Decoration, Nsons, Subtree, Sub_Rosa
    use VectorsModule, only: Vector_T
    use WriteMetaData, only: L2PCF, WriteMetalog

    ! Arguments
    integer, intent(in) :: ROOT   ! Of the output section's AST
    type (L2GPData_T), dimension(:), pointer :: L2GPDataBASE ! L2GP products
    type (L2AUXData_T), dimension(:), pointer :: L2AUXDataBASE ! L2AUX products
    type (Matrix_Database_T), dimension(:), pointer :: MATRICES ! Matrix database (for l2pcs)
    type (Hessian_T), dimension(:), pointer :: HESSIANS ! Hessian database (for l2pcs)
    type (Vector_T), dimension(:), pointer :: Vectors ! Vectors database
    type (DirectData_T), dimension(:), pointer :: DirectDatabase
    type (MLSChunk_T), dimension(:), pointer ::  Chunks  ! of data
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (GriddedData_T), dimension(:), pointer :: GriddedDataBase
    type (TAI93_Range_T), intent(in) :: processingRange

    logical, intent(in) :: canWriteL2PC ! Flag

    ! - - - Local declarations - - -

    type (MLSChunk_T) ::  AllChunks     ! in one
    ! logical, parameter :: DEBUG = .false.
    logical :: debug
    logical :: additional
    integer :: delay                    ! how many microseconds to sleep
    logical :: DESTROY
    integer, dimension(:), pointer :: DONTPACK ! Quantities not to pack
    integer :: FIELD_INDEX              ! F_... field code
    integer :: FIELD_NO                 ! Index of assign vertex sons of Key
    integer :: FIELDVALUE               ! For get_boolean
    character (len=FileNameLen) :: FILE_BASE    ! From the FILE= field
    logical, dimension(field_first:field_last) :: GOT ! Fields
    integer :: GSON                     ! Son of Son -- an assign node
    type (HGrids_T), dimension(:), pointer :: HGrids => null()
    integer :: HDFVERSION
    integer :: KEY                      ! Index of spec_args node
    integer :: Me = -1                  ! String index for trace
    integer :: Metadata_error
    character (len=32) :: meta_name     ! From the metaName= field
    integer :: NAME                     ! string index of label on output
    type (HGrid_T), pointer :: newHGridp
    integer :: NODE
    integer :: noGapsHGIndex = 0
    integer :: OUTPUT_TYPE              ! L_L2AUX, L_L2GP, L_PC, L_L2DGG
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    logical :: PACKED                   ! Do we pack this l2pc?
    integer :: QUANTITIESNODE           ! A tree node
    logical :: reset
    integer :: SECONDDERIVNODE
    integer :: SON                      ! Of Root -- spec_args or named node
    type(next_tree_node_state) :: State ! of tree traverser
    character (len=80) :: strValue
    real :: T1     ! for timing
    integer :: Units(2)                 ! Units of value returned by EXPR
    logical :: USINGL2Q                 ! Set if using the l2q queue manager
    logical :: USINGOLDSUBMIT              ! Set if using the submit mechanism
    logical :: USINGSUBMIT              ! Set if using the submit mechanism
    double precision :: Value(2)        ! Value returned by EXPR
    logical :: TIMING
    logical :: WriteCounterMAF          ! Add the counter MAF field
    logical :: writeMetaDataOnly

    ! Executable code

    call trace_begin ( me, "Output_Close", root, cond=toggle(gen) )
    timing = section_times
    if ( timing ) call time_now ( t1 )
    nullify ( dontPack )

    debug = LetsDebug ( 'output', 0 )
    error = 0

    if ( switchDetail( switches, 'pro') > -1 ) then
      call output ( '============ Level 2 Products ============', advance='yes' )
      call output ( ' ', advance='yes' )
    end if

    usingL2Q = ( index(parallel%submit, 'l2q') > 0 )
    usingSubmit = trim_safe(parallel%submit) /= ''
    usingOldSubmit = usingSubmit .and. .not. usingL2Q
    WRITEMASTERSFILEATTRIBUTES = .not. parallel%master ! cp file attributes from slaves

    AllChunks%firstMAFIndex = chunks(1)%firstMAFIndex
    AllChunks%noMAFsLowerOverlap = chunks(1)%noMAFsLowerOverlap
    AllChunks%lastMAFIndex = chunks(size(chunks))%lastMAFIndex
    AllChunks%noMAFsUpperOverlap = chunks(size(chunks))%noMAFsUpperOverlap

    if ( DEBUG ) then
      print *, 'Num chunks: ', size(chunks)
      print *, 'firstMAFIndex: ', AllChunks%firstMAFIndex
      print *, 'lastMAFIndex: ', AllChunks%lastMAFIndex
      call dump(AllChunks)
    endif
    ! Loop over the lines in the l2cf

    do 
      son = next_tree_node ( root, state )
      if ( son == 0 ) exit

      meta_name = ''
      writeCounterMAF = .false.
      got = .false.
      additional = .false.

      call get_label_and_spec ( son, name, key )
      L2CFNODE = key

      if ( MLSSelecting .and. &
        & .not. any( get_spec_id(key) == (/ s_endselect, s_select, s_case /) ) ) &
        & cycle

      reset = .false.
      do field_no = 2, nsons(key) ! fields of the "time" specification
        gson = subtree(field_no, key)   ! An assign node
        if ( nsons(gson) > 1 ) then
          fieldValue = decoration(subtree(2,gson)) ! The field's value
        else
          fieldValue = gson
        end if
        field_index = decoration(subtree(1,gson))
        got(field_index) = .true.
        select case ( field_index )   ! Field name
        case ( f_reset )
          reset = Get_Boolean ( gson )
        case default
          ! Shouldn't get here if the type checker worked
        end select
      end do ! j = 2, nsons(key)
      select case ( get_spec_id(key) )
      case ( s_Boolean )
        call decorate ( key,  BooleanFromFormula ( name, key ) )
      case ( s_Catenate )
        if ( associated(DirectDatabase) &
          & .and. .not. SKIPDIRECTWRITES ) then
          call output( ' unsplitting dgg/dgm files', advance='yes' )
          call unsplitFiles ( key, DirectDatabase, FileDatabase, HGrids, &
            & usingOldSubmit, debug )
        end if
      case ( s_sleep ) ! ============ Sleep ==========
        delay = 1000 ! defaults to 1000 microseconds
        do field_no = 2, nsons(key)       ! Skip the command name
          gson = subtree(field_no, key)   ! An assign node
          field_index = decoration(subtree(1,gson))
          got(field_index) = .true.
          select case ( field_index )   ! Field name
          case ( f_time )
            ! Did we say for how long?
            call expr ( subtree(2,gson), units, value )
            delay = value(1)*1.d6  ! Converted to microseconds
          case default
          end select 
        enddo
        call usleep ( delay )
      case ( s_select ) ! ============ Start of select .. case ==========
        ! We'll start seeking a matching case
        call MLSSelect (key)
      case ( s_case ) ! ============ seeking matching case ==========
        ! We'll continue seeking a match unless the case is TRUE
        call MLSCase (key)
      case ( s_endSelect ) ! ============ End of select .. case ==========
        ! We'done with seeking a match
        call MLSEndSelect (key)
      case ( s_reevaluate )
        call decorate ( key,  BooleanFromFormula ( 0, key ) )
      case ( s_skip ) ! ============================== Skip ==========
        ! We'll skip the rest of the section if the Boolean cond'n is TRUE
        if ( Skip(key) ) then
          call output( '(Skipping rest of this section)', advance='yes' )
          exit
        endif
      case ( s_diff, s_dump )
        call dumpCommand ( key, griddedDataBase=griddedDataBase, &
          & FiledataBase=FileDataBase, MatrixdataBase=matrices, &
          & Hessiandatabase=Hessians, HGrids=HGrids )
      case ( s_isFileAbsent, s_isSwathEmpty )
        if ( checkPaths ) cycle
        call decorate ( key, BooleanFromEmptySwath ( key ) )
      case ( s_copy )
        call copyQuantity( key, filedatabase )

      case ( s_Destroy )
        call destroyCommand ( key, matrices, vectors, griddedDataBase )
      case ( s_Dumpblocks )
        call dumpBlocks ( key, matrices, hessians )
      case ( s_execute ) ! ======================== ExecuteCommand ==========
        call ExecuteCommand ( key )
      case ( s_HGrid )
        if ( specialDumpFile /= ' ' ) &
          & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )
        call decorate ( key, AddHGridToDatabase ( hGrids, CreateHGridFromMLSCFInfo ( name, key, filedatabase, L2GPDatabase, &
          & processingRange, allChunks ) ) )
        if ( DEBUG ) print *, 'Before dealing with obstructions'
        newHGridp => hGrids(1)%the_hGrid
        if ( DEBUG ) call dump(newHGridp)
        if ( associated(obstructions) ) &
          & call DealWithObstructions( newHGridp, obstructions, DestroyOld = .false. )
        ! Don't skip the lower overlap profiles if ChunkDivide included them
        if ( ChunkDivideConfig%allowPriorOverlaps ) &
          & newHGridp%noProfsLowerOverlap = 0
        if ( specialDumpFile /= ' ' ) &
          & call revertOutput

      case ( s_l2gp )
        call decorate ( key, AddL2GPToDatabase ( L2GPDatabase, &
          & CreateAndReadL2GP ( name, key, filedatabase ) ) )

      case ( s_output )
        call output ( 'Processing an Output command', advance='yes' )
        do field_no = 2, nsons(key)       ! Skip the command name
          gson = subtree(field_no, key)   ! An assign node
          if ( nsons(gson) > 1 ) then
            fieldValue = decoration(subtree(2,gson)) ! The field's value
          else
            fieldValue = gson
          end if
          field_index = decoration(subtree(1,gson))
          got(field_index) = .true.
          select case ( field_index )   ! Field name
          case ( f_file )
            call get_string ( sub_rosa(subtree(2,gson)), file_base, strip=.true. )
          case ( f_metaName )
            call get_string ( sub_rosa(subtree(2,gson)), meta_name, strip=.true. )
          case ( f_type )
            output_type = decoration(subtree(2,gson))
            call get_string ( lit_indices(output_Type), outputTypeStr, strip=.true. )
          case ( f_writeCounterMAF )
            writeCounterMAF = get_boolean ( fieldValue )
          case ( f_MetaDataOnly )
            writeMetaDataOnly = get_boolean ( fieldValue )
          case ( f_hdfVersion )
            call expr ( subtree(2,gson), units, value )
            hdfVersion = nint(value(1))
            if ( hdfVersion /= 4 .and. hdfVersion /= 5 ) &
              & call Announce_error ( gson, 'hdfVersion must be 4 or 5')
          case default                  ! Everything else processed later
          end select
        end do

        ! Unless outputting l2cf, you must have supplied a quantities field
        ! (parser used to catch this)
        if ( .not. got(f_quantities) .and. output_type /= l_l2cf ) &
          & call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'No quantities field in Output command' )
        ! Otherwise--normal output commands
        select case ( output_type )
        case ( l_l2cf ) ! ------------------------------ Writing l2cf file ---
          call CopyTextFileToHDF ( file_base, DEBUG, filedatabase )
          ! return
          cycle

        case ( l_l2gp ) ! --------------------- Writing l2gp files -----
        if ( noGapsHGIndex > 0 ) newHGridp => HGrids(noGapsHGIndex)%the_hGrid
          call OutputL2GP ( key, file_base, DEBUG, &
            & output_type, MLSPCF_L2GP_Start, MLSPCF_L2GP_End, &
            & filedatabase, L2GPDatabase, newHGridp )
          if ( .not. TOOLKIT ) cycle ! return

        case ( l_l2aux ) ! ------------------------------ Writing l2aux files ---
          call OutputL2AUX ( key, file_base, DEBUG, writeCounterMAF, &
            & filedatabase, L2AUXDatabase )
          if ( .not. TOOLKIT ) cycle ! return

        case ( l_l2pc ) ! ------------------------------ Writing l2pc files --
          print *, 'checkPaths: ', checkPaths
          print *, 'canWriteL2PC: ', canWriteL2PC
          if ( checkPaths ) exit   ! Not done on sips, so this is good enough
          ! I intend to completely ignore the PCF file in this case,
          ! it's not worth the effort!
          ! In that case, I will ignore the possibility of checkPaths being true
          if ( .not. canWriteL2PC ) call MLSL2Message( MLSMSG_Error, ModuleName, &
            & "Cannot write l2pc files with multi chunk l2cf's" )
          destroy = .false.
          packed = .false.
          secondDerivNode = 0
          do field_no = 2, nsons(key) ! Skip "output" name
            gson = subtree(field_no,key)
            select case ( decoration(subtree(1,gson)) )
            case ( f_destroy )
              destroy = get_boolean ( gson )
            case ( f_dontPack )
              call Allocate_Test ( dontPack, nsons(gson)-1, 'dontPack', ModuleName )
              do node = 2, nsons(gson)
                dontPack(node-1) = decoration(decoration(subtree(node,gson)))
              end do
            case ( f_moleculeSecondDerivatives )
              secondDerivNode = gson
            case ( f_overlaps )
              ! ??? More work needed here
            case ( f_packed )
              packed = get_boolean ( gson )
            case ( f_quantities )
              quantitiesNode = gson
            end select
          end do ! field_no = 2, nsons(key)
          call output ( 'About to call OutputHDF5L2PC', advance='yes' )
          call outputNamedValue ( 'l2pc file name', trim(file_base) )

          call OutputHDF5L2PC ( trim(file_base), matrices, hessians, &
            & quantitiesNode, secondDerivNode, packed, dontPack )

          ! We used to destroy the written out matrix here, but I don't want to do that anymore
          ! (NJL, 13 Feb 2010)
          
          call Deallocate_test ( dontPack, 'dontPack', ModuleName )

        case ( l_l2dgg ) ! --------------------- Writing l2dgg files -----
        if ( noGapsHGIndex > 0 ) newHGridp => HGrids(noGapsHGIndex)%the_hGrid
          call OutputL2GP ( key, file_base, DEBUG, &
            & output_type, MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End, &
            & filedatabase, L2GPDatabase, newHGridp )
          if ( .not. TOOLKIT ) cycle ! return

        case default
          if ( any(output_type /= (/ l_l2gp, l_l2dgg, l_l2aux, l_l2pc /)) ) then
            call announce_error ( son, &
            &  "Error--unknown output type: parser should have caught this")
          else
            call output('Lahey did weird thing again: ', advance='yes')
          end if
          call output('l2gp type number: ', advance='no')
          call output(l_l2gp, advance='yes')

          call output('l2aux type number: ', advance='no')
          call output(l_l2aux, advance='yes')

          call output('l2dgg type number: ', advance='no')
          call output(l_l2dgg, advance='yes')

          call output('output type number: ', advance='no')
          call output(output_type, advance='yes')

          call output('file_base: ', advance='no')
          call output(trim(file_base), advance='yes')

        end select

      case ( s_time )
        if ( timing .and. .not. reset ) then
          call sayTime ( 'Output_Close', t1=t1, cumulative=.false. )
        else
          call time_now ( t1 )
          timing = .true.
        end if

      case ( s_writeFileAttribute )
        do field_no = 2, nsons(key)       ! Skip the command name
          gson = subtree(field_no, key)   ! An assign node
          if ( nsons(gson) > 1 ) then
            fieldValue = decoration(subtree(2,gson)) ! The field's value
          else
            fieldValue = gson
          end if
          field_index = decoration(subtree(1,gson))
          got(field_index) = .true.
          select case ( field_index )   ! Field name
          case ( f_file )
            call get_string ( sub_rosa(subtree(2,gson)), file_base, strip=.true. )
          case ( f_additional )
            additional = get_boolean( gson )
          case ( f_attrName )
            call get_string ( sub_rosa(subtree(2,gson)), meta_name, strip=.true. )
          case ( f_attrValue )
            call get_string ( sub_rosa(subtree(2,gson)), strValue, strip=.true. )
          case ( f_type )
            output_type = decoration(subtree(2,gson))
            call get_string ( lit_indices(output_Type), outputTypeStr, strip=.true. )
          case default                  ! Everything else processed later
          end select
        end do
        if ( checkPaths ) cycle
        select case ( output_type )
        case ( l_l2aux ) ! --------------------- Writing it to l2aux files -----
          call writeAttributeToL2AUX ( file_base, meta_name, strValue, &
            & filedatabase, additional )       
        case ( l_l2gp ) ! --------------------- Writing it to l2gp files -----
          call writeAttributeToL2GP ( file_base, meta_name, strValue, &
            & output_type, MLSPCF_L2GP_Start, MLSPCF_L2GP_End, &
            & filedatabase, additional )       
        case ( l_l2dgg ) ! --------------------- Writing it to l2dgg files -----
          call writeAttributeToL2GP ( file_base, meta_name, strValue, &
            & output_type, MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End, &
            & filedatabase, additional )       
        case default
          call MLSL2Message( MLSMSG_Warning, ModuleName, &
          & 'Not yet able to write file attributes to this file type' )
        end select

      case default
        call announce_error ( son, &
          &  "Error--unknown son: parser should have caught this")

      end select

    end do
    
    ! Write the log file metadata
    if ( LOGFILEGETSMETADATA .and. .not. checkPaths ) then
      if ( DEBUG ) then
        call output('About to write log file metadata' , advance='yes')
      end if

      if ( TOOLKIT ) then
        call writeMetaLog ( metadata_error )
        ! error = max(error, metadata_error)
      end if
    end if

    ! Done wirh any Hgrids we may have created

    ! Done with text of PCF file at last
   
    if ( DEBUG ) &
      & call output ( 'About to deallocate text of PCF file' , advance='yes' )

    call deallocate_test ( l2pcf%anText, 'anText of PCF file', moduleName )

    if ( switchDetail(switches, 'pro') > -1 ) then
      call output ( '============ End Level 2 Products ============', advance='yes' )
      call output ( ' ', advance='yes' )
    end if

    if ( error /= 0 ) then
      call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Problem with Output_Close section' )
    end if

    if ( timing ) call sayTime ( 'Output_Close', cumulative=.false. )
    call trace_end ( "Output_Close", cond=toggle(gen) )

  end subroutine Output_Close

  ! ---------------------------------------------  CreateAndReadL2GP  -----
  function CreateAndReadL2GP ( name, key, filedatabase ) result(l2gp)
    ! Read and store l2gp data type from a file
    use Init_Tables_Module, only: F_File, F_Sdname, F_NoPCFid, F_Swath, &
      & Field_First, Field_Last
    use L2GPData, only: L2GPData_T
    use MLSCommon, only: FileNameLen, MLSFile_T
    use MLSFiles, only: AddFileToDatabase
    use MLSPCF2, only: &
      & MLSPCF_L2APriori_Start, MLSPCF_L2APriori_End
    use MoreTree, only: Get_Boolean
    use Readapriori, only: ProcessOneL2GPFile
    use Tree, only: Decoration, Nsons, &
      & Sub_Rosa, Subtree
    ! Args
    integer, intent(in)             :: name
    integer, intent(in)             :: key
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (L2GPData_T)               :: L2GP
    ! Internal variables
    integer                         :: field
    integer                         :: fieldIndex
    integer                         :: FileIndex
    integer                         :: FileName    ! Sub-rosa index of name in file='name'
    character(len=FileNameLen)      :: FileNameString ! actual literal file name
    logical, dimension(field_first:field_last) :: GOT
    integer                         :: j
    type (MLSFile_T)                :: L2GPFile
    integer                         :: LastAprioriPCF      ! l2gp or l2aux  apriori
    logical                         :: noPCFid
    integer                         :: SdName  ! sub-rosa index of name in sdName='name'
    character(len=FileNameLen)      :: ShortFileName
    integer                         :: son
    integer                         :: SwathName        ! sub-rosa index of name in swath='name'
    character(len=FileNameLen)      :: SWATHNAMESTRING ! actual literal swath name
    ! Executable
    LastAprioriPCF = MLSPCF_L2APriori_start - 1
    got = .false.
    noPCFid = .false.
    do j = 2, nsons(key)
      field = subtree(j,key)
      L2CFNODE = field
      fieldIndex = decoration(subtree(1,field))
      got(fieldIndex) = .true.
      select case ( fieldIndex )
      case ( f_file )
        fileName = sub_rosa(subtree(2,field))
      case ( f_noPCFid )
        noPCFid = get_boolean(field)
      case ( f_sdname )
        sdname = sub_rosa(subtree(2,field))
      case ( f_swath )
        swathName = sub_rosa(subtree(2,field))
      end select
    end do
    if ( got(f_file) ) then
      call get_string ( FileName, fileNameString, strip=.true. )
    else
      fileNameString = ''
    end if
    shortFileName = fileNameString
    if ( .not. got(f_file) ) &
      & call announce_error ( son, &
        & 'Filename name must be specified to read an l2gp' )
    swathNameString=''
    if ( got(f_swath) ) &
      & call get_string ( swathName, swathNameString, strip=.true. )
    call processOneL2GPFile ( FileNameString, swathNameString, &
      & noPCFid, MLSPCF_L2APriori_start, MLSPCF_L2APriori_end, &
      & LastAprioriPCF, ' ', .false., &
      & L2GP, L2GPFile )
    FileIndex = AddFileToDataBase( filedatabase, L2GPFile )
  end function CreateAndReadL2GP
    
  ! ---------------------------------------------  add_metadata  -----
  subroutine add_metadata ( node, fileName, l2metaData, &
    & hdfVersion, filetype, metadata_error, &
    & numquantitiesperfileinput, quantityNamesInput )
    
    use Allocate_Deallocate, only: Deallocate_Test, Allocate_Test
    use Init_Tables_Module, only: L_L2dgg, L_Quantity
    use Intrinsic, only: L_Swath, L_HDF
    use MLSCommon, only: L2metaData_T
    use L2GPData, only: L2GPNamelen, Maxswathnamesbufsize
    use MLSHDF5, only: GetallHDF5dsnames
    use MLSPCF2, only: MLSPCF_L2DGM_End, MLSPCF_L2DGM_Start, MLSPCF_L2GP_End, &
      & MLSPCF_L2GP_Start, MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End, &
      & MLSPCF_MCF_L2DGM_Start, MLSPCF_MCF_L2DGG_Start, &
      & MLSPCF_MCF_L2GP_Start
    use MLSStringLists, only: GetHashElement, List2array, NumStringElements
    use Output_M, only: Output
    use WriteMetaData, only: L2PCF, Populate_MetaData_Std, &
      & Populate_MetaData_Oth, Get_L2gp_Mcf
  ! Deal with metadata--1st for direct write, but later for all cases
  integer, intent(in) :: node
  character(len=*), intent(in) :: fileName
  type (L2Metadata_T) :: l2metaData
  integer, intent(in) :: hdfVersion
  integer, intent(in) :: fileType  ! l_swath, l_hdf, ..
  integer, intent(out) :: metadata_error
  integer, optional, intent(in) :: numquantitiesperfileInput
  character(len=*), dimension(:), optional, intent(in) :: quantityNamesInput
  
  ! Internal variables
  integer :: baseIndex
  logical, parameter :: countEmpty = .true.
  ! logical, parameter :: DEBUG = .false.
  logical :: debug
  character(len=*), parameter :: L2GPHEAD = 'L2GP-'
  integer :: field_no
  character (len=132) :: FILE_BASE
  integer :: fileHandle
  integer :: L2aux_mcf
  integer :: l2dgg_mcf
  integer :: L2gp_mcf
  integer :: listSize
  character (len=32) :: meta_name=' '
  integer :: numquantitiesperfile
  character (len=132) :: path
  character(len=len(fileName)) :: PhysicalFilename
  character(len=L2GPNameLen), dimension(:), pointer :: quantityNames => null()
  integer :: returnStatus
  character(len=MAXSWATHNAMESBUFSIZE) :: sdList
  integer :: Version
  ! Executable
  debug = LetsDebug ( 'output', 0 )
  nullify(quantityNames)
  l2aux_mcf = MLSPCF_MCF_L2DGM_Start
  l2dgg_mcf = MLSPCF_MCF_L2DGG_Start
  l2gp_mcf  = MLSPCF_MCF_L2GP_Start - 1
  metadata_error = 0
  Version = 1
  select case (filetype)
  case (l_swath, l_l2dgg)
     call split_path_name(fileName, path, file_base)
     baseIndex = index(trim(file_base), L2GPHEAD)
     if ( baseIndex > 0 ) then
       file_base=file_base(baseIndex+len(L2GPHEAD):)
     end if
     if ( filetype == l_l2dgg ) then
       FileHandle = GetPCFromRef(file_base, MLSPCF_L2DGG_Start, &
         & MLSPCF_L2DGG_End, &
         & .true., returnStatus, Version, DEBUG, &
         & exactName=PhysicalFilename)
       l2gp_mcf = l2dgg_mcf
       call GetHashElement ( l2pcf%spec_keys, l2pcf%spec_doinames      , &
          & 'dgg', l2metaData%doiIdentifier, .TRUE. )
       if ( len_trim(l2metaData%doiIdentifier) < 1 ) &
         & l2metaData%doiIdentifier = '10.5067/AURA/MLS/DATA2006'
     else
       FileHandle = GetPCFromRef(file_base, MLSPCF_L2GP_Start, &
         & MLSPCF_L2GP_End, &
         & .true., returnStatus, Version, DEBUG, &
         & exactName=PhysicalFilename)
       call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf, &
         & l2metaData%doiIdentifier )
     end if
     if (returnStatus /= 0) then
         call MLSL2Message ( MLSMSG_Error, ModuleName, &
           &  "While adding metadata failed to GetPCFromRef for " // trim(fileName) )
     else if ( l2gp_mcf <= -999 ) then
         call MLSL2Message ( MLSMSG_Warning, ModuleName, &
           &  "no mcf for this l2gp species in" // trim(file_base) )
         return
     else if (l2gp_mcf <= 0) then
         call MLSL2Message ( MLSMSG_Error, ModuleName, &
           &  "no mcf for this l2gp species in" // trim(file_base) )
     end if
     
     ! What quantities do we want metadata for?
     if ( present(quantityNamesInput) .and. present(numquantitiesperfileInput) ) then
       call allocate_test( quantityNames, size(quantityNamesInput), &
         & 'quantityNames', ModuleName )
       numquantitiesperfile = numquantitiesperfileInput
       quantityNames = quantityNamesInput
     else
       numquantitiesperfile = mls_InqSwath ( PhysicalFilename, sdList, listSize, &
           & hdfVersion=hdfVersion)
       call allocate_test(quantityNames, numquantitiesperfile, &
         & 'quantityNames', ModuleName )
       call List2Array( sdList, quantityNames, countEmpty )
     endif

     if ( QuantityNames(numquantitiesperfile) &
       & == QuantityNames(1) ) then
       ! Typical homogeneous l2gp file: 
       ! e.g., associated with BrO is ML2BRO.001.MCF
       if ( DEBUG ) then
         call output('preparing to populate metadata_std', advance='yes')
         call output('l2gpFileHandle: ', advance='no')
         call output(FileHandle , advance='no')
         call output('   l2gp_mcf: ', advance='no')
         call output(l2gp_mcf , advance='yes')
       end if
       call populate_metadata_std &
         & (FileHandle, l2gp_mcf, QuantityNames(1), l2metaData, &
         & hdfVersion=hdfVersion, metadata_error=metadata_error, &
         & filetype=filetype  )
     else
       ! Type l2gp file 'other'
       if ( DEBUG ) then
         call output ( 'preparing to populate metadata_oth', advance='yes' )
         call output ( 'l2gpFileHandle: ', advance='no' )
         call output ( FileHandle , advance='no' )
         call output ( '   l2gp_mcf: ', advance='no' )
         call output ( l2gp_mcf , advance='yes' )
       end if

       call populate_metadata_oth &
         & ( FileHandle, l2gp_mcf, &
         & numquantitiesperfile, QuantityNames, l2metaData, &
         & hdfVersion=hdfVersion, metadata_error=metadata_error, &
         & filetype=filetype  )
     end if
  case (l_hdf)
     if ( DEBUG ) call output ( 'output file type l2aux', advance='yes' )
     ! Get the l2aux file name from the PCF

     call split_path_name(fileName, path, file_base)
     FileHandle = GetPCFromRef(file_base, MLSPCF_L2DGM_Start, &
       & MLSPCF_L2DGM_End, &
       & .true., returnStatus, Version, DEBUG, &
       & exactName=PhysicalFilename)
     ! Some hdf-formatted product files lack metadata, e.g. fwm radiances
     if (returnStatus /= 0) then
         metadata_error = returnStatus
         call outputNamedValue ( 'fileName', trim(fileName) )
         call outputNamedValue ( 'PCFIds', (/ MLSPCF_L2DGM_Start, MLSPCF_L2DGM_End /) )
         call MLSL2Message ( MLSMSG_Warning, ModuleName, &
           &  "While adding metadata failed to GetPCFromRef for " // trim(fileName) )
         return
     end if
     if ( present(quantityNamesInput) .and. present(numquantitiesperfileInput) ) then
       call allocate_test( quantityNames, size(quantityNamesInput), &
         & 'quantityNames', ModuleName )
       numquantitiesperfile = numquantitiesperfileInput
       quantityNames = quantityNamesInput
     else
       call GetAllHDF5DSNames ( PhysicalFilename, '/', sdList )
       numquantitiesperfile = NumStringElements ( sdList, countEmpty )
       call allocate_test( quantityNames, numquantitiesperfile, &
         & 'quantityNames', ModuleName )
       call List2Array( sdList, quantityNames, countEmpty )
     endif
     if ( DEBUG ) then
       call output ( 'preparing to populate metadata_oth', advance='yes' )
       call output ( 'l2auxFileHandle: ', advance='no' )
       call output ( FileHandle , advance='no' )
       call output ( '   l2aux_mcf: ', advance='no' )
       call output ( l2aux_mcf , advance='no' )
       call output ( '   number of quantities: ', advance='no' )
       call output ( numquantitiesperfile , advance='yes' )
       if ( associated(QuantityNames) ) then
         do field_no=1, numquantitiesperfile
           call output ( field_no , advance='no' )
           call output ( '       ', advance='no' )
           call output ( trim(QuantityNames(field_no)) , advance='yes' )
         end do
       endif
     endif
     call GetHashElement ( l2pcf%spec_keys, l2pcf%spec_doinames      , &
          & 'dgm', l2metaData%doiIdentifier, .TRUE. )
     if ( len_trim(l2metaData%doiIdentifier) < 1 ) &
       & l2metaData%doiIdentifier = '10.5067/AURA/MLS/DATA2007'
     call populate_metadata_oth &
       & ( FileHandle, l2aux_mcf, &
       & numquantitiesperfile, QuantityNames, l2metaData, &
       & hdfVersion=hdfVersion, metadata_error=metadata_error, &
       & filetype=filetype  )
  case ( l_quantity )
    call MLSL2Message( MLSMSG_Warning, ModuleName, &
      & "Unable to add metadata for the file type of "&
      & // trim(filename) )
  case default
    call announce_error ( node, &
      &  "Error--filetype unrecognized", filetype)
    call MLSL2Message( MLSMSG_Error, ModuleName, &
      & "Unrecognized filetype in add_metadata (must be swath or hdf) "&
      & // trim(filename) )
  end select

  call deallocate_test( quantityNames, 'quantityNames', ModuleName )
  end subroutine add_metadata

! =====     Private Procedures     =====================================

  ! ---------------------------------------------  announce_success  -----
  subroutine announce_success ( Name, l2_type, num_quants, quantities, hdfVersion )
    use Output_M, only: Blanks, Output
    integer, intent(in) :: num_quants 
    character(LEN=*), intent(in)   :: Name
    character(LEN=*), intent(in)   :: l2_type
    integer, optional,  intent(in) :: hdfVersion
    character(LEN=*), dimension(:), optional, intent(in) :: quantities
    integer :: i

    call output ( 'Level 2 output product type : ' )
    call output ( trim(l2_type), advance='no')
    if ( present(hdfVersion) ) then
      call blanks(4)
      call output ( 'hdf ' )
      call output ( hdfVersion, advance='yes')
    else
      call output ( ' ', advance='yes')
    end if
    call blanks(15)
    call output ( 'name : ' )
    call blanks(8)
    call output ( trim(Name), advance='yes')

    if ( num_quants > 0 .and. present(quantities) ) then
      call output ( 'number ' )
      call blanks(5)
      call output ( 'quantity', advance='yes')
      do i=1, num_quants
          call output ( i )
          call blanks(5)
          call output ( trim(quantities(i)), advance='yes')
      end do
    end  if
  end subroutine announce_success

  ! ---------------------------------------------  ANNOUNCE_ERROR  -----
  subroutine ANNOUNCE_ERROR ( Where, Full_message, Code, Penalty )

    use Lexer_Core, only: Print_Source
    use Output_M, only: Output
    use Tree, only: Where_At => Where

    integer, intent(in) :: Where   ! Tree node where error was noticed
    character(LEN=*), intent(in) :: Full_Message
    integer, intent(in), optional :: Code    ! Code for error message
    integer, intent(in), optional :: Penalty
    integer :: myPenalty

    myPenalty = 1
    if ( present(penalty) ) myPenalty = penalty
    error = max(error,myPenalty)

    call output ( '***** At ' )
    if ( where > 0 ) then
      call print_source ( where_at(where) )
    else
      call output ( '(no lcf node available)' )
    end if
    call output ( ' OutputAndClose complained: ' )

    call output ( trim(full_message), advance='yes', &
      & from_where=ModuleName )
    if ( present(code) ) then
      ! select case ( code )
      ! end select
      call output ( ' Code: ' )
      call output ( Code, advance='yes' )
    end  if
  end subroutine ANNOUNCE_ERROR

  ! ---------------------------------------------  CopyQuantity  -----
  subroutine CopyQuantity ( key, fileDatabase )
    ! Do the work of copying named quantity data to a named file
    use Expr_M, only: Expr
    use HGridsDatabase, only: HGrids_T, Dump
    use Init_Tables_Module, only: F_Create, &
      & F_Exclude, F_File, F_HDFversion, F_Hgrid, &
      & F_Ifanycrashedchunks, F_InputFile, F_Inputtype, &
      & F_Options, &
      & F_Rename, F_Repairgeolocations, &
      & F_Swath, F_Toattribute, F_Type, &
      & Field_First, Field_Last, &
      & L_L2aux, L_L2cf, L_L2dgg, L_L2gp
    use HighOutput, only: OutputnamedValue
    use Intrinsic, only: L_Ascii, L_Swath, L_HDF, Lit_Indices
    use L2AUXData, only: CpL2AUXData
    use L2GPData, only: Avoidunlimiteddims, &
      & Maxswathnamesbufsize, CpL2GPData, CpL2GPDatatoattribute
    use L2parinfo, only: Parallel
    use MLSCommon, only: MLSFile_T, Filenamelen, L2metaData_T
    use MLSPCF2, only: MLSPCF_L2DGM_End, MLSPCF_L2DGM_Start, MLSPCF_L2GP_End, &
      & MLSPCF_L2GP_Start, MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End, &
      & MLSPCF_L2ascii_Start, MLSPCF_L2ascii_End
    use MLSStringlists, only: Intersection, Switchdetail
    use MLSStrings, only: Lowercase
    use Moretree, only: Get_Boolean
    use Output_M, only: Output
    use PCFHdr, only: Globalattributes, DumpGlobalAttributes, &
      & H5_Writeglobalattr, He5_WriteMLSFileattr, He5_WriteGlobalAttr
    use ReadAPriori, only: ReadAPrioriattributes, WriteAPrioriAttributes
    use Tree, only: Decoration, Nsons, Subtree, Sub_Rosa
    ! Args
    integer, intent(in)                       :: KEY
    type (MLSFile_T), dimension(:), pointer   :: FILEDATABASE
    ! Local variables
    logical :: create
    ! logical, parameter :: DEBUG = .false.
    logical :: debug
    character (len=MAXSWATHNAMESBUFSIZE) :: EXCLUDE   ! From the exclude= field
    integer :: FIELD_INDEX              ! F_... field code
    integer :: FIELD_NO                 ! Index of assign vertex sons of Key
    integer :: FIELDVALUE               ! For get_boolean
    character (len=FileNameLen) :: FILE_BASE    ! From the FILE= field
    integer :: FORMATTYPE               ! l_hdf or l_swath
    logical, dimension(field_first:field_last) :: GOT ! Fields
    type (HGrids_T), dimension(:), pointer :: HGrids => null()
    integer :: GSON                     ! Son of Son -- an assign node
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: HGridIndex
    integer :: INPUT_TYPE              ! L_L2AUX, L_L2GP, L_PC, L_L2DGG
    type(MLSFile_T), pointer :: inputFile
    character (len=FileNameLen) :: INPUTFILE_BASE    ! From the inputfile= field
    character (len=FileNameLen) :: inputPhysicalFilename
    character (len=MAXSWATHNAMESBUFSIZE) :: inSwathList
    character (len=MAXSWATHNAMESBUFSIZE) :: outSwathList
    type (L2Metadata_T) :: l2metaData ! L2GP metadata 
    integer :: listSize
    integer :: Metadata_error
    integer :: numSwaths
    logical :: newFile                  ! is this file new?
    integer :: noGapsHGIndex = 0
    integer :: noSwaths
    character(len=8) :: optionsString   ! e.g. '-f'
    integer :: OUTPUT_TYPE              ! L_L2AUX, L_L2GP, L_PC, L_L2DGG
    type(MLSFile_T), pointer :: outputFile
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    character (len=FileNameLen) :: PhysicalFilename
    character (len=MAXSWATHNAMESBUFSIZE) :: rename
    logical :: RepairGeoLocations
    character (len=MAXSWATHNAMESBUFSIZE) :: sdList
    character (len=MAXSWATHNAMESBUFSIZE) :: sdListThere
    logical :: skipCopy
    integer :: SON                      ! Of Root -- spec_args or named node
    logical :: toAttribute
    integer :: Units(2)                 ! Units of value returned by EXPR
    double precision :: Value(2)        ! Value returned by EXPR
    ! Executable
    debug = LetsDebug ( 'output', 0 )
    hdfVersion = DEFAULT_HDFVERSION_WRITE
    exclude = ''
    sdList = '*' ! This is wildcard meaning 'every sd or swath'
    rename = ' ' ! This is a blank meaning 'Dont rename the swaths'
    optionsString = ' ' ! This is a blank meaning 'Dont rename the swaths'
    got = .false.
    repairGeoLocations = .false.
    skipCopy = .false.
    create = .false.
    newFile = .false.
    toAttribute = .false.
    do field_no = 2, nsons(key)       ! Skip the command name
      gson = subtree(field_no, key)   ! An assign node
      if ( nsons(gson) > 1 ) then
        fieldValue = decoration(subtree(2,gson)) ! The field's value
      else
        fieldValue = gson
      end if
      field_index = decoration(subtree(1,gson))
      got(field_index) = .true.
      select case ( field_index )   ! Field name
      case ( f_create )
        create = get_boolean ( gson )
      case ( f_exclude )
        call get_string ( sub_rosa(subtree(2,gson)), exclude, strip=.true. )
      case ( f_file )
        call get_string ( sub_rosa(subtree(2,gson)), file_base, strip=.true. )
        if ( DEBUG ) print *, 'file_base: ', trim(file_base)
      case ( f_hdfVersion )
        call expr ( subtree(2,gson), units, value )
        hdfVersion = value(1)
        if ( hdfVersion /= 4 .and. hdfVersion /= 5 ) &
          & call Announce_error ( gson, 'hdfVersion must be 4 or 5')
      case ( f_hgrid )
        HGridIndex = decoration(fieldValue)
        if ( DEBUG ) print *, 'HGridIndex: ', HGridIndex
      case ( f_ifAnyCrashedChunks )
        skipCopy = get_boolean ( gson ) .and. &
          & ( parallel%numFailedChunks == 0 )
      case ( f_inputfile )
        call get_string ( sub_rosa(subtree(2, gson)), inputfile_base, strip=.true. )
      case ( f_inputtype )
        input_type = decoration(subtree(2, gson))
      case ( f_options )
        call get_string ( sub_rosa(subtree(2, gson)), optionsString, strip=.true. )
        optionsString = lowerCase(optionsString)
        if (switchDetail( switches, 'pro') > 0 ) &
          & call outputNamedValue( 'options', trim(optionsString) )
      case ( f_rename )
        call get_string ( sub_rosa(subtree(2,gson)), rename, strip=.true. )
      case ( f_repairGeoLocations )
        repairGeoLocations = get_boolean ( gson )
      case ( f_swath )
        call get_string ( sub_rosa(subtree(2,gson)), sdList, strip=.true. )
      case ( f_toAttribute )
        toAttribute = get_boolean ( gson )
      case ( f_type )
        output_type = decoration(subtree(2, gson))
        call get_string ( lit_indices(output_Type), outputTypeStr, strip=.true. )
      case default                  ! Parser should have caught this
      end select
    end do
    ! Make certain we have everything we need
    if ( ( got(f_repairGeoLocations) .and. .not. got(f_hgrid) ) ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & "Cannot repair Geolocs w/o an HGrid to copy from" )
    if ( .not. associated(HGrids) ) then
      if ( got(f_hgrid) ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & "No HGrids defined yet" )
    else
      if ( ( size(HGrids) < 1 .and. got(f_hgrid) ) ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & "No HGrids defined yet" )
    endif
    if ( ( got(f_swath) .and. got(f_exclude) ) ) &
      & call MLSL2Message ( MLSMSG_Error, ModuleName, &
      & "Cannot copy specifying both swaths and excludes" )
    ! To skip or not to skip
    if ( skipCopy ) then
      call MLSL2Message ( MLSMSG_Info, ModuleName, &
      & "No crashed chunks so skipping this copy" )
      return
    endif
    if ( .not. got(f_inputtype) ) input_type = output_type

    select case ( output_type )
    case ( l_l2aux ) ! --------------------- Copying l2aux files -----
      call returnFullFileName(file_base, PhysicalFilename, &
        & MLSPCF_L2DGM_Start, MLSPCF_L2DGM_End)
      outputFile => GetMLSFileByName(filedatabase, PhysicalFilename)
      if ( .not. associated(outputFile) ) then
        newFile = .true.
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=PhysicalFilename, shortName=file_base, &
          & type=l_hdf, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=MLSPCF_L2DGM_Start, PCTop=MLSPCF_L2DGM_End)
      endif
    case ( l_l2gp ) ! --------------------- Copying l2gp files -----
      call returnFullFileName(file_base, PhysicalFilename, &
        & MLSPCF_L2GP_Start, MLSPCF_L2GP_End)
      outputFile => GetMLSFileByName(filedatabase, PhysicalFilename)
      if ( .not. associated(outputFile) ) then
        newFile = .true.
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=PhysicalFilename, shortName=file_base, &
          & type=l_swath, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=MLSPCF_L2GP_Start, PCTop=MLSPCF_L2GP_End)
      endif
    case ( l_l2dgg ) ! --------------------- Copying l2dgg files -----
      call returnFullFileName(file_base, PhysicalFilename, &
        & MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End)
      outputFile => GetMLSFileByName(filedatabase, PhysicalFilename)
      if ( .not. associated(outputFile) ) then
        newFile = .true.
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=PhysicalFilename, shortName=file_base, &
          & type=l_swath, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=MLSPCF_L2DGG_Start, PCTop=MLSPCF_L2DGG_End)
      endif
    case default
    end select

    if ( .not. associated(outputFile) ) then
      call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'Unable to Copy to ' // trim(PhysicalFilename) )
    endif
    if ( DEBUG ) call dump( outputFile, details=2 )

    select case ( input_type )
    case ( l_l2aux ) ! --------------------- Copying l2aux files -----
      call returnFullFileName(inputfile_base, inputPhysicalFilename, &
        & MLSPCF_L2DGM_Start, MLSPCF_L2DGM_End)
      inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
      if ( .not. associated(inputFile) ) then
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
      endif
    case ( l_l2gp ) ! --------------------- Copying l2gp files -----
      call returnFullFileName(inputfile_base, inputPhysicalFilename, &
        & MLSPCF_L2GP_Start, MLSPCF_L2GP_End)
      inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
      if ( .not. associated(inputFile) ) then
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
      endif
    case ( l_l2dgg ) ! --------------------- Copying l2dgg files -----
      call returnFullFileName(inputfile_base, inputPhysicalFilename, &
        & MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End)
      inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
      if ( .not. associated(inputFile) ) then
        call output( ' output base ', advance='no' )
        call output( trim(file_base), advance='yes' )
        call output( ' output file ', advance='no' )
        call output( trim(outputFile%name), advance='yes' )
        call output( ' input base ', advance='no' )
        call output( trim(inputfile_base), advance='yes' )
        call output( ' input file ', advance='no' )
        call output( '(not associated)', advance='yes' )
        call dump(filedatabase)
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
      endif
    case ( l_ascii, l_l2cf ) ! --------------------- Copying ascii files -----
      call returnFullFileName(inputfile_base, inputPhysicalFilename, &
        & MLSPCF_l2ascii_start, MLSPCF_l2ascii_end)
      inputFile => AddInitializeMLSFile( filedatabase, &
          & content=trim(inputfile_base), &
          & name=inputPhysicalFilename, shortName=inputfile_base, &
          & type=l_ascii, access=DFACC_RDWR, &
          & PCBottom=MLSPCF_l2ascii_start, PCTop=MLSPCF_l2ascii_end )
      if ( .not. associated(inputFile) ) then
        call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
        return
      endif
      if ( DEBUG ) call dump( inputFile )
    case default
    end select

    if ( DEBUG ) print *, 'inputPhysicalfileName: ', trim(inputPhysicalfileName)
    if ( DEBUG ) print *, 'outputPhysicalfileName: ', trim(PhysicalfileName)
    if ( DEBUG ) print *, 'repairGeoLocations: ', repairGeoLocations
    if ( DEBUG ) print *, 'create: ', create
    if ( DEBUG ) call display_string ( lit_indices(output_type), &
    &             strip=.true., advance='yes' )
    if ( DEBUG ) call display_string ( lit_indices(input_type), &
    &             strip=.true., advance='yes' )

    if ( CHECKPATHS ) return

    if ( DEBUG ) call dump( inputFile, details=2 )
    if ( repairGeoLocations ) optionsString = trim(optionsString) // 'cr'
    select case ( output_type )
    case ( l_l2aux ) ! --------------------- Copying to l2aux files -----
      formattype = l_hdf
      ! Note that we haven't yet implemented repair stuff for l2aux
      ! So crashed chunks remain crashed chunks
      if ( DEBUG ) call Dump( inputFile )
      if ( input_type /= output_type ) then
        ! So far we only allow copying text files
        if ( .not. any( input_type == (/ l_ascii, l_l2cf /) ) ) then
          call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'Unable to copy to l2aux file file type for' // trim(inputPhysicalFilename) )
          return
        endif
        if ( mls_exists( inputFile%Name ) == 0 ) &
          & call CopyTextFileToHDF ( file_base, DEBUG, filedatabase, inputFile )
      else
        call cpL2AUXData( inputFile, &
          & outputFile, create2=create, &
          & sdList=trim(sdList) )
      endif
    case ( l_l2gp, l_l2dgg ) ! --------------------- Copying l2gp files -----
      formattype = l_swath
      ! How to use swaths field? See definition of sdList
      ! Before trying to cp these swaths, make sure they're actually there
      noSwaths = mls_InqSwath ( inputFile%name, sdListThere, listSize, &
       & hdfVersion=inputFile%hdfVersion )
      sdList = Intersection( sdList, sdListThere )
      if ( sdList == ' ' ) return
      if ( toAttribute ) then
        if ( len_trim(rename) < 1 ) rename = sdlist
        call cpL2GPDataToAttribute( inputfile, outputfile, &
          & sdList, rename )
      elseif ( got(f_exclude) .and. .not. repairGeoLocations ) then
        call cpL2GPData( l2metaData, inputfile, &
          & outputfile, create2=create, &
          & exclude=trim(exclude), &
          & notUnlimited=avoidUnlimitedDims, &
          & andGlAttributes=COPYGLOBALATTRIBUTES, options=optionsString )
      elseif ( .not. got(f_exclude) .and. repairGeoLocations ) then
        if ( DEBUG ) print *,' size(filedatabse) ', size(filedatabase)
        if ( DEBUG ) print *, 'input file: ', trim(inputPhysicalFilename)
        if ( DEBUG ) print *, 'output file: ', trim(PhysicalFilename)
        call cpL2GPData( l2metaData, inputfile, &
          & outputfile, create2=create, &
          & swathList=trim(sdList), rename=rename, &
          & notUnlimited=avoidUnlimitedDims, andGlAttributes=COPYGLOBALATTRIBUTES, &
          & HGrid=HGrids(HGridIndex)%the_hGrid, options=optionsString )
      elseif ( got(f_exclude) .and. repairGeoLocations ) then
        call cpL2GPData( l2metaData, inputfile, &
          & outputfile, create2=create, &
          & swathList=trim(sdList), rename=rename, &
          & exclude=trim(exclude), &
          & notUnlimited=avoidUnlimitedDims, andGlAttributes=COPYGLOBALATTRIBUTES, &
          & HGrid=HGrids(HGridIndex)%the_hGrid, options=optionsString )
      else
        if ( DEBUG ) then
          call output( 'input file', advance='yes' )
          call dump( inputFile )
          call output( 'output file', advance='yes' )
          call dump( outputFile )
          numSwaths = mls_InqSwath ( inputfile%name, inSwathList, listSize, &
             & hdfVersion=hdfVersion )
          call outputNamedValue ( 'input swaths', trim(inSwathList) )
          numSwaths = mls_InqSwath ( outputfile%name, outSwathList, listSize, &
             & hdfVersion=hdfVersion )
          call outputNamedValue ( 'output swaths', trim(outSwathList) )
          numSwaths = mls_InqSwath ( PhysicalFilename, outSwathList, listSize, &
             & hdfVersion=hdfVersion )
          call outputNamedValue ( 'output swaths', trim(outSwathList) )
          call outputNamedValue ( 'swath', trim(sdList) )
        endif
        call cpL2GPData( l2metaData, inputfile, &
          & outputfile, create2=create, &
          & swathList=trim(sdList), rename=rename, &
          & notUnlimited=avoidUnlimitedDims, &
          & andGlAttributes=COPYGLOBALATTRIBUTES, options=optionsString )
      endif
      if ( WRITEFILEATTRIBUTES ) call he5_writeMLSFileAttr( outputFile )
      if ( create ) then
        call readAPrioriAttributes( inputFile )
        call writeAPrioriAttributes( outputFile )
      endif
      if ( noGapsHGIndex > 0 ) &
        & call writeHGridComponents( trim(PhysicalFilename), &
        & HGrids(noGapsHGIndex)%the_hGrid )
    case default
    end select

    if ( TOOLKIT .and. newFile ) then
      call add_metadata ( son, file_base, l2metaData, &
        & outputfile%hdfVersion, formattype, metadata_error )
      if ( len_trim(l2metaData%doiIdentifier) < 1 ) then
        call MLSL2Message( MLSMSG_Warning, ModuleName, &
          & 'empty doiIdentidier for ' // trim(PhysicalFilename) )
        return
      endif
      ! Set the file-level attribute DOI to its metadata value
      GlobalAttributes%DOI = l2metaData%doiIdentifier
      select case ( output_type )
      case ( l_l2aux ) ! --------------------- Copying to l2aux files -----
        call output( 'Writing file level attributes to h5 ' // &
          & trim(PhysicalFilename), advance='yes' )
        call outputNamedValue( 'identifier_product_DOI', trim(GlobalAttributes%DOI) )
        call outputNamedValue( 'ProductionLocation', trim(GlobalAttributes%productionLoc) )
        call h5_writeGlobalAttr ( outputFile, &
          & skip_if_already_there=.false., doi=.true. )
        call DumpGlobalAttributes
      case ( l_l2gp, l_l2dgg ) ! --------------------- Copying l2gp files -----
        call output( 'Writing file level attributes to he5 ' // &
          & trim(PhysicalFilename), advance='yes' )
        call outputNamedValue( 'identifier_product_doi', trim(GlobalAttributes%DOI) )
        call outputNamedValue( 'ProductionLocation', trim(GlobalAttributes%productionLoc) )
        call he5_writeglobalattr( outputFile, doi=.true. )
        call DumpGlobalAttributes
      end select
    endif
  end subroutine CopyQuantity

  ! ---------------------------------------------  writeAttributeToL2AUX  -----
  subroutine writeAttributeToL2AUX ( fileName, attrName, attrValue, &
    & filedatabase, additional )
    ! Do the work of outputting specified attribute to a named l2aux file
    use HDF5, only: H5GClose_F, H5GOpen_F
    use Intrinsic, only: L_HDF
    use MLSCommon, only: MLSFile_T, FileNameLen
    use MLSPCF2, only: MLSPCF_L2DGM_Start, MLSPCF_L2DGM_End
    use MLSStringLists, only: SwitchDetail
    use Output_M, only: Output
    ! Args
    character(len=*), intent(inout)         :: fileName ! according to l2cf
    character(len=*), intent(in)            :: attrName ! according to l2cf
    character(len=*), intent(in)            :: attrValue ! according to l2cf
    type(MLSFile_T), dimension(:), pointer  :: filedatabase
    logical, intent(in)                     :: additional
    ! Local variables
    ! logical, parameter :: DEBUG = .false.
    logical :: debug
    character (len=FileNameLen) :: FullFilename
    integer :: FileHandle
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    type(MLSFile_T), pointer :: outputFile
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    character (len=132) :: path
    integer :: ReturnStatus
    logical :: skipIfAlreadyThere
    character (len=132) :: str
    integer :: Version

    ! Executable
    debug = LetsDebug ( 'output', 0 )
    Version = 1
    OUTPUTTYPESTR = 'l2aux'
    ! Get the l2aux file name from the PCF

    if ( TOOLKIT ) then
      call split_path_name(fileName, path, fileName)

      FileHandle = GetPCFromRef(fileName, MLSPCF_L2DGM_Start, &
        & MLSPCF_L2DGM_End, &
        & TOOLKIT, returnStatus, Version, DEBUG, &
        & exactName=FullFilename)
    else
      FullFilename = fileName
      returnStatus = 0
    end if

    if ( mls_exists(trim(FullFilename)) /= 0 ) then
      if( DEBUG .or.  switchDetail(switches, 'pro') > -1 ) &
        & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'Its non-existence prevented writing attribute to ' &
        & // trim(FullFilename) )
      return
    elseif ( returnStatus == 0 .and. .not. checkPaths ) then
      ! Open the HDF file and write l2aux data
      outputFile => GetMLSFileByName(filedatabase, FullFilename)
      if ( .not. associated(outputFile) ) then
      if( DEBUG .or.  switchDetail(switches, 'pro') > -1 ) &
          & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'No entry in filedatabase for ' // trim(FullFilename) )
        outputFile => AddInitializeMLSFile( filedatabase, &
          & content=outputTypeStr, &
          & name=FullFilename, shortName=fileName, &
          & type=l_hdf, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=MLSPCF_L2DGM_Start, PCTop=MLSPCF_L2DGM_End )
      endif
    endif
    if ( .not. outputFile%stillOpen ) &
      & call mls_openFile( outputFile, returnStatus )
    call h5gopen_f( outputFile%FileID%f_id, '/', outputFile%FileID%grp_id, &
      & returnStatus )
    if ( .not. additional ) then
      str = attrValue
      skipIfAlreadyThere = .true.
    else
      call GetHDF5Attribute ( outputFile%FileID%grp_id, attrname, str )
      str = trim(str) // attrValue
      skipIfAlreadyThere = .false.
      if ( debug ) call output( 'Updated glob attr to ' // trim(str), advance='yes' )
    endif
    call MakeHDF5Attribute( outputFile%FileID%grp_id, &
      & attrName, str, skip_if_already_there=skipIfAlreadyThere )
    call h5gclose_f( outputFile%FileID%grp_id, returnStatus )
  end subroutine writeAttributeToL2AUX

  ! ---------------------------------------------  writeAttributeToL2GP  -----
  subroutine writeAttributeToL2GP ( fileName, attrName, attrValue, &
    & output_type, pcf_start, pcf_end, &
    & filedatabase, additional )
    ! Do the work of outputting specified attribute to a named l2gp file
    use HDFEOS5, only: MLS_Chartype
    use HDF5, only: H5f_Acc_Rdwr_F, H5fclose_F, H5fopen_F, H5gclose_F, H5gopen_F
    use Intrinsic, only: L_Swath, Lit_Indices
    use MLSCommon, only: MLSFile_T, FileNameLen
    use MLSHDF5, only: MakeHDF5Attribute
    use MLSHDFEOS, only: HE5_EHRDGlAtt, MLS_EHWRGlatt
    use MLSStringLists, only: SwitchDetail
    use Output_M, only: Output
    ! Args
    character(len=*), intent(inout)         :: fileName ! according to l2cf
    character(len=*), intent(in)            :: attrName ! according to l2cf
    character(len=*), intent(in)            :: attrValue ! according to l2cf
    integer, intent(in)                     :: output_type
    integer, intent(in)                     :: pcf_start
    integer, intent(in)                     :: pcf_end
    type(MLSFile_T), dimension(:), pointer  :: filedatabase
    logical, intent(in)                     :: additional

    ! Local variables
    ! logical, parameter :: DEBUG = .false.
    logical :: debug
    character (len=FileNameLen) :: FullFilename
    integer :: FileHandle
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    type(MLSFile_T), pointer :: outputFile
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    character (len=132) :: path
    integer :: ReturnStatus
    ! logical :: skipIfAlreadyThere
    character (len=132) :: str
    integer :: Version
    ! Treat as plain hdf
    logical, parameter :: plainHDF = .true.

    ! Executable
    debug = LetsDebug ( 'output', 0 )
    Version = 1
    call get_string ( lit_indices(output_Type), outputTypeStr, strip=.true. )
    ! Get the l2gp file name from the PCF

    if ( TOOLKIT ) then
      call split_path_name(fileName, path, fileName)

      FileHandle = GetPCFromRef(fileName, pcf_start, &
        & pcf_end, &
        & TOOLKIT, returnStatus, Version, DEBUG, &
        & exactName=FullFilename)
    else
      FullFilename = fileName
      returnStatus = 0
    end if

    if ( mls_exists(trim(FullFilename)) /= 0 ) then
      if( DEBUG .or.  switchDetail(switches, 'pro') > -1 ) &
        & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'Its non-existence prevented writing attribute to ' &
          & // trim(FullFilename) )
      return
    elseif ( returnStatus == 0 .and. .not. checkPaths ) then
      ! Open the HDF-EOS file and write the attribute
      outputFile => GetMLSFileByName(filedatabase, FullFilename)
      if ( .not. associated(outputFile) ) then
      if( DEBUG .or.  switchDetail(switches, 'pro') > -1 ) &
        & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'No entry in filedatabase for ' // trim(FullFilename) )
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=FullFilename, shortName=fileName, &
          & type=l_swath, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=pcf_start, PCTop=pcf_end)
      endif
    endif
    if ( plainHDF .and. additional ) then
      call dump ( outputFile, details=1 )
      ! Due to problems extending the hdfeos implementation of file-level
      ! attributes, we resort to the plain vanilla hdf5 api
      ! We first close it as an hdfeos file and reopen it as plain hdf5
      if ( outputFile%stillOpen ) then
        call mls_closeFile( outputFile, returnStatus )
        if ( returnStatus /= 0 ) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
            & 'Unable to hdfeos_close ' // trim(FullFilename) )
      endif
      call h5fopen_f ( trim(outputFile%name), H5F_ACC_RDWR_F, &
        & outputFile%FileID%f_id, returnStatus )
      if ( returnStatus /= 0 ) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'Unable to open ' // trim(FullFilename) )
      call h5gopen_f( outputFile%FileID%f_id, &
        & '/HDFEOS/ADDITIONAL/FILE_ATTRIBUTES', outputFile%FileID%grp_id, &
        & returnStatus )
      if ( returnStatus /= 0 ) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'Unable to open group /HDFEOS/ADDITIONAL/FILE_ATTRIBUTES for ' // &
          & trim(FullFilename) )
      outputFile%FileID%sd_id = 0 ! To ensure we read from the grp_id
      call dump ( outputFile, details=1 )
      if ( additional ) then
        call GetHDF5Attribute ( outputFile, attrname, str )
        str = trim(str) // attrValue
        if ( debug ) call output( 'Updated glob attr to ' // trim(str), advance='yes' )
      else
        str = attrValue
        if ( debug ) call output( 'Set glob attr to ' // trim(str), advance='yes' )
      endif
      call MakeHDF5Attribute( outputFile%FileID%grp_id, &
        & attrName, str, skip_if_already_there = .false. )
      call h5gclose_f( outputFile%FileID%grp_id, returnStatus )
      if ( returnStatus /= 0 ) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'Unable to close group ' // trim(FullFilename) )
      call h5fclose_f ( outputFile%FileID%f_id, returnStatus )
      if ( returnStatus /= 0 ) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'Unable to close  ' // trim(FullFilename) )
      return
    endif
    if ( .not. outputFile%stillOpen ) &
      & call mls_openFile( outputFile, returnStatus )
    if ( .not. additional ) then
      str = attrValue
    else
      returnStatus = HE5_EHRDGlAtt ( outputFile%FileID%f_id, attrName, str )
      str = trim(str) // attrValue
      call output( 'Updated l2gp glob attr to ' // trim(str), advance='yes' )
    endif
    returnStatus = mls_EHwrglatt( outputFile%FileID%f_id, &
     & attrName, MLS_CharType, 1, &
     &  str )
  end subroutine writeAttributeToL2GP

  ! ---------------------------------------------  OutputL2AUX  -----
  subroutine OutputL2AUX ( key, fileName, DEBUG, writeCounterMAF, &
    & filedatabase, L2AUXDatabase )
    ! Do the work of outputting specified l2aux data to a named file
    use Init_Tables_Module, only: F_Overlaps, F_Quantities
    use Intrinsic, only: L_HDF
    use L2AUXData, only: L2AUXData_T, WriteL2AUXData
    use L2GPData, only: L2GPNamelen
    use MLSCommon, only: MLSFile_T, FileNamelen, L2metaData_T
    use MLSPCF2, only: MLSPCF_L2DGM_Start, MLSPCF_L2DGM_End
    use MLSStringLists, only: SwitchDetail
    use SDPToolkit, only: Pgs_S_Success
    use Tree, only: Decoration, Nsons, Subtree
    ! Args
    integer, intent(in)                     :: key ! tree node
    character(len=*), intent(inout)         :: fileName ! according to l2cf
    logical, intent(in)                     :: DEBUG ! Print lots?
    logical, intent(in)                     :: writeCounterMAF
    type(MLSFile_T), dimension(:), pointer  :: filedatabase
    type(L2AUXData_T), dimension(:), pointer :: L2AUXDatabase
    ! Local variables
    integer :: DB_index
    integer :: FIELD_NO                 ! Index of assign vertex sons of Key
    character (len=FileNameLen) :: FullFilename
    integer :: FileHandle
    integer :: GSON                     ! Son of Son -- an assign node
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: IN_FIELD_NO              ! Index of sons of assign vertex
    integer :: Metadata_error
    integer :: Numquantitiesperfile     ! < MAXQUANTITIESPERFILE
    type(MLSFile_T), pointer :: outputFile
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    character (len=132) :: path
    character(len=L2GPNameLen), dimension(MAXQUANTITIESPERFILE) :: &
      &                           QuantityNames  ! From "quantities" field
    integer :: ReturnStatus
    integer :: SON                      ! Of Root -- spec_args or named node
    integer :: Version
    type(L2Metadata_T) :: l2metaData

    ! Executable
    Version = 1
    OUTPUTTYPESTR = 'l2aux'
    ! Get the l2aux file name from the PCF

    if ( TOOLKIT ) then
      call split_path_name(fileName, path, fileName)

      FileHandle = GetPCFromRef(fileName, MLSPCF_L2DGM_Start, &
        & MLSPCF_L2DGM_End, &
        & TOOLKIT, returnStatus, Version, DEBUG, &
        & exactName=FullFilename)
    else
      FullFilename = fileName
      returnStatus = 0
    end if

    if ( returnStatus == 0 .and. .not. checkPaths ) then
      ! Open the HDF file and write l2aux data
      outputFile => GetMLSFileByName(filedatabase, FullFilename)
      if ( .not. associated(outputFile) ) then
        if(DEBUG) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'No entry in filedatabase for ' // trim(FullFilename) )
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=FullFilename, shortName=fileName, &
          & type=l_hdf, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=MLSPCF_L2DGM_Start, PCTop=MLSPCF_L2DGM_End)
      endif
      ! Loop over the segments of the l2cf line

      numquantitiesperfile = 0
      do field_no = 2, nsons(key) ! Skip "output" name
        gson = subtree(field_no,key)
        select case ( decoration(subtree(1,gson)) )
        case ( f_quantities )
          do in_field_no = 2, nsons(gson)
            db_index = -decoration(decoration(subtree(in_field_no, gson)))
            if ( db_index >= 1 ) then
              call WriteL2AUXData ( L2AUXDatabase(db_index), outputFile, &
                & returnStatus, &
                & WriteCounterMAF = &
                &   (writeCounterMAF .and. numquantitiesperfile == 0) )
                    error = max(error, returnStatus)
              numquantitiesperfile = numquantitiesperfile+1
              if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                call announce_error ( son, &
                  & 'Attempt to write too many l2aux quantities to a file', &
                  & numquantitiesperfile )
                numquantitiesperfile = MAXQUANTITIESPERFILE
              end if
              call get_string &
                & ( L2AUXDatabase(db_index)%name, &
                &     QuantityNames(numquantitiesperfile) )
            else
              call MLSL2Message ( MLSMSG_Warning, ModuleName, &
                & 'Unable to write quantity to l2aux file, ' // &
                & 'perhaps no chunks processed' )
            end if
          end do ! in_field_no = 2, nsons(gson)
        case ( f_overlaps )
          ! ??? More work needed here
        end select
      end do ! field_no = 2, nsons(key)

      if ( switchDetail(switches, 'pro') > -1 ) then
        call announce_success(FullFilename, 'l2aux', &
          & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
      end if

      if ( .not. TOOLKIT ) return

      ! Write the metadata file
      call add_metadata ( son, fileName, l2metaData, &
        & hdfVersion, l_hdf, metadata_error, &
        & numquantitiesperfile, quantityNames )
    else if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( son, &
        &  "Error finding l2aux file matching:  "//fileName, returnStatus)
    end if
  end subroutine OutputL2AUX

  ! ---------------------------------------------  CopyTextFileToHDF  -----
  subroutine CopyTextFileToHDF ( fileName, DEBUG, filedatabase, inputFile )
    ! Do the work of copying the text file to a named file
    ! If inputFile omitted, copy the l2cf
   use Intrinsic, only: L_HDF
   use MLSCommon, only: MLSFile_T, FileNameLen
   use MLSHDF5, only: SaveasHDF5ds
   use MLSPCF2, only: MLSPCF_L2DGM_Start, MLSPCF_L2DGM_End
   use MLSStringLists, only: SwitchDetail
   use Output_M, only: Output
    ! Args
    character(len=*), intent(inout)         :: fileName ! according to l2cf
    logical, intent(in)                     :: DEBUG ! Print lots?
    type(MLSFile_T), dimension(:), pointer  :: filedatabase
    type(MLSFile_T), optional, pointer      :: inputFile
    ! Internal variables
    type(MLSFile_T), pointer                :: MLSL2CF
    integer                                 :: status
    integer :: FileHandle
    character (len=FileNameLen) :: FullFilename
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    type(MLSFile_T), pointer :: outputFile
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    character (len=132) :: path
    integer :: ReturnStatus
    integer :: Version
    ! Executable
    nullify ( MLSL2CF )
    if ( present(inputFile) ) then
      MLSL2CF => inputFile
    else
      MLSL2CF => GetMLSFileByType(filedatabase, content='l2cf')
    endif
    if ( .not. associated(MLSL2CF) ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'Unable to write dataset--no entry in filedatabase for text file' )
      return
    endif
    if ( MLSL2CF%stillOpen ) call mls_closeFile( MLSL2CF, status )
    if ( MLSL2CF%name == '<STDIN>' ) then
      call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'Unable to write dataset--stdin has been used for text file' )
      return
    endif
    Version = 1
    OUTPUTTYPESTR = 'l2aux'
    ! Get the l2aux file name from the PCF

    if ( TOOLKIT ) then
      call split_path_name(fileName, path, fileName)

      FileHandle = GetPCFromRef(fileName, MLSPCF_L2DGM_Start, &
        & MLSPCF_L2DGM_End, &
        & TOOLKIT, returnStatus, Version, DEBUG, &
        & exactName=FullFilename)
    else
      FullFilename = fileName
      returnStatus = 0
    end if

    if ( mls_exists(trim(FullFilename)) /= 0 ) then
      if( DEBUG .or.  switchDetail(switches, 'pro') > -1 ) &
        & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'Its non-existence prevented any copying to ' &
        & // trim(FullFilename) )
      return
    elseif ( returnStatus == 0 .and. .not. checkPaths ) then
      ! Open the HDF file and write text file
      outputFile => GetMLSFileByName(filedatabase, FullFilename)
      if ( .not. associated(outputFile) ) then
        if( DEBUG .or.  switchDetail(switches, 'pro') > -1 ) &
          & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'No entry in filedatabase for ' // trim(FullFilename) )
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=FullFilename, shortName=fileName, &
          & type=l_hdf, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=MLSPCF_L2DGM_Start, PCTop=MLSPCF_L2DGM_End)
      endif
      if ( DEBUG ) then
        call output ( 'About to copy text file to hdf', advance='yes' )
        call output ( 'input text file', advance='yes' )
        call dump( MLSL2CF, details=2 )
        call output ( 'output hdf file', advance='yes' )
        call dump( outputFile, details=2 )
      endif
      if ( .not. outputFile%stillOpen ) call mls_openFile( outputFile, status )
      call SaveAsHDF5DS ( MLSL2CF%name, outputFile%FileID%f_id, &
        & trim(MLSL2CF%content), maxLineLen=4096 )
      call mls_closeFile( outputFile, status )
    endif
  end subroutine CopyTextFileToHDF

  ! ---------------------------------------------  OutputL2GP  -----
  subroutine OutputL2GP ( key, fileName, DEBUG, &
    & output_type, pcf_start, pcf_end, &
    & filedatabase, L2GPDatabase, HGrid )
    ! Do the work of outputting specified l2gp data to a named file
    use HGridsDatabase, only: HGrid_T
    use Init_Tables_Module, only: F_Overlaps, F_Quantities
    use Intrinsic, only: L_Swath, Lit_Indices
    use L2GPData, only: L2GPData_T, L2gpnamelen, WriteL2GPData
    use MLSCommon, only: MLSFile_T, Filenamelen, L2metaData_T
    use MLSStringlists, only: Switchdetail
    use SDPToolkit, only: Pgs_S_Success
    use Tree, only: Decoration, Nsons, Subtree
    ! Args
    integer, intent(in)                     :: key ! tree node
    character(len=*), intent(inout)         :: fileName ! according to l2cf
    logical, intent(in)                     :: DEBUG ! Print lots?
    integer, intent(in)                     :: output_type
    integer, intent(in)                     :: pcf_start
    integer, intent(in)                     :: pcf_end
    type(MLSFile_T), dimension(:), pointer  :: filedatabase
    type(L2GPData_T), dimension(:), pointer :: L2GPDatabase
    type(HGrid_T)                           :: HGrid
    ! Local variables
    integer :: DB_index
    integer :: FIELD_NO                 ! Index of assign vertex sons of Key
    character (len=FileNameLen) :: FullFilename
    integer :: FileHandle
    integer :: GSON                     ! Son of Son -- an assign node
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: IN_FIELD_NO              ! Index of sons of assign vertex
    integer :: Metadata_error
    integer :: Numquantitiesperfile     ! < MAXQUANTITIESPERFILE
    type(MLSFile_T), pointer :: outputFile
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    character (len=132) :: path
    character(len=L2GPNameLen), dimension(MAXQUANTITIESPERFILE) :: &
      &                           QuantityNames  ! From "quantities" field
    integer :: ReturnStatus
    integer :: SON                      ! Of Root -- spec_args or named node
    integer :: Version
    type(L2Metadata_T) :: l2metaData

    ! Executable
    Version = 1
    call get_string ( lit_indices(output_Type), outputTypeStr, strip=.true. )
    ! Get the l2gp file name from the PCF

    if ( TOOLKIT ) then
      call split_path_name(fileName, path, fileName)

      FileHandle = GetPCFromRef(fileName, pcf_start, &
        & pcf_end, &
        & TOOLKIT, returnStatus, Version, DEBUG, &
        & exactName=FullFilename)
    else
      FullFilename = fileName
      returnStatus = 0
    end if

    if ( returnStatus == 0 .and. .not. checkPaths ) then
      ! Open the HDF-EOS file and write swath data
      outputFile => GetMLSFileByName(filedatabase, FullFilename)
      if ( .not. associated(outputFile) ) then
        if(DEBUG) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          & 'No entry in filedatabase for ' // trim(FullFilename) )
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=FullFilename, shortName=fileName, &
          & type=l_swath, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=pcf_start, PCTop=pcf_end)
      endif
      ! Loop over the segments of the l2cf line

      numquantitiesperfile = 0
      do field_no = 2, nsons(key) ! Skip "output" name
        gson = subtree(field_no,key)
        select case ( decoration(subtree(1,gson)) )
        case ( f_quantities )
          do in_field_no = 2, nsons(gson)
            db_index = -decoration(decoration(subtree(in_field_no ,gson)))
            if ( db_index >= 1 ) then
              call writeL2GPData ( L2GPDatabase(db_index), outputFile )
              numquantitiesperfile = numquantitiesperfile+1
              if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                call announce_error ( son, &
                  & 'Attempt to write too many ' // trim(outputTypeStr) // &
                  & ' quantities to a file', &
                  & numquantitiesperfile )
                numquantitiesperfile = MAXQUANTITIESPERFILE
              end if
              quantityNames(numquantitiesperfile) = L2GPDatabase(db_index)%name
            else
              call MLSL2Message ( MLSMSG_Warning, ModuleName, &
                & 'Unable to write quantity to ' // trim(outputTypeStr) // &
                & ' file, ' // &
                & 'perhaps no chunks processed' )
            end if
          end do ! in_field_no = 2, nsons(gson)
        case ( f_overlaps )
          ! ??? More work needed here
        end select
      end do ! field_no = 2, nsons(key)

      if ( switchDetail(switches, 'pro') > -1 ) then
        call announce_success(FullFilename, trim(outputTypeStr), &
          & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
      end if

      call writeHGridComponents( filename, HGrid )
      if ( .not. TOOLKIT ) return

      ! Write the metadata file
      call add_metadata ( son, fileName, l2metaData, &
        & hdfVersion, l_swath, metadata_error, &
        & numquantitiesperfile, quantityNames )
    else if ( returnStatus /= PGS_S_SUCCESS ) then
      call announce_error ( son, &
        &  "Error finding " // trim(outputTypeStr)  // &
        & ' file matching:  ' //fileName, returnStatus)
    end if
  end subroutine OutputL2GP

  ! ---------------------------------------------  writeHGridComponents  -----
  subroutine writeHGridComponents ( fileName, HGrid )
    use HDFEOS5, only: He5_Swclose, He5_Swopen, &
      & He5f_Acc_Rdwr, He5t_Native_Int, He5t_Native_Double
    use HGridsDatabase, only: Hgrid_T
    use MLSHDFEOS, only: He5_Ehwrglatt, Hsize, MLS_Isglatt
    ! Args
    character(len=*), intent(in) :: fileName
    type(HGrid_T)                :: HGrid
    ! Internal variables
    integer :: FileID
    integer :: H                        ! Num of profiles in HGrid
    integer :: Status
    ! Executable
    if ( .not. MLS_isGlAtt ( filename, 'HGrid_noProfs' ) ) then
      ! call dump(HGrid)
      fileID = he5_swopen(trim(fileName), HE5F_ACC_RDWR)
      h = HGrid%noProfs
      status = he5_EHwrglatt(fileID, 'HGrid_noProfs', HE5T_NATIVE_INT, HSIZE(1), &
        &  (/ h /) )
      status = he5_EHwrglatt(fileID, 'HGrid_phi', HE5T_NATIVE_DOUBLE, hsize(h), &
        &  HGrid%phi(1,:) )
      status = he5_EHwrglatt(fileID, 'HGrid_geodLat', HE5T_NATIVE_DOUBLE, hsize(h), &
        &  HGrid%geodLat(1,:) )
      status = he5_EHwrglatt(fileID, 'HGrid_lon', HE5T_NATIVE_DOUBLE, hsize(h), &
        &  HGrid%lon(1,:) )
      status = he5_EHwrglatt(fileID, 'HGrid_time', HE5T_NATIVE_DOUBLE, hsize(h), &
        &  HGrid%time(1,:) )
      status = he5_EHwrglatt(fileID, 'HGrid_solarTime', HE5T_NATIVE_DOUBLE, hsize(h), &
        &  HGrid%solarTime(1,:) )
      status = he5_EHwrglatt(fileID, 'HGrid_solarZenith', HE5T_NATIVE_DOUBLE, hsize(h), &
        &  HGrid%solarZenith(1,:) )
      status = he5_EHwrglatt(fileID, 'HGrid_losAngle', HE5T_NATIVE_DOUBLE, hsize(h), &
        &  HGrid%losAngle(1,:) )
      status = he5_swclose(fileID)
    endif
  end subroutine writeHGridComponents

  ! ---------------------------------------------  returnFullFileName  -----
  subroutine returnFullFileName ( shortName, FullName, &
    & pcf_start, pcf_end )
    ! Given a possibly-abbreviated shortName, return the full name
    ! as found in the PCF
    ! (w/o toolkit panoply, simply return shortName)
    ! Args
    character(len=*), intent(in)  :: shortName
    character(len=*), intent(out) :: FullName
    integer, intent(in)           :: pcf_start
    integer, intent(in)           :: pcf_end
    ! Internal variables
    ! logical, parameter :: DEBUG = .false.
    logical :: debug
    integer :: FileHandle
    integer :: returnStatus
    integer :: Version
    ! Executable
    debug = LetsDebug ( 'output', 0 )
    if ( TOOLKIT .and. pcf_end >= pcf_start ) then
      Version = 1
      FileHandle = GetPCFromRef(shortName, pcf_start, &
        & pcf_end, &
        & TOOLKIT, returnStatus, Version, DEBUG, &
        & exactName=FullName)
      if ( returnStatus /= 0 ) FullName = shortName ! In cases omitted from PCF
    else
      FullName = shortName
    end if
  end subroutine returnFullFileName

  ! ---------------------------------------------  unsplitFiles  -----
  subroutine unsplitFiles ( key, DirectDatabase, FileDatabase, HGrids, &
    & usingSubmit, debug )
    ! Catenate any split Direct Writes of dgg/dgm files
    ! Also write various types of metadata
    ! We assume hdfVersion is 5
    use Allocate_Deallocate, only: Deallocate_Test, Allocate_Test
    use ChunkDivide_M, only: Obstructions
    use DirectWrite_M, only: DirectData_T, Dump
    use HDF5, only: H5gclose_F, H5gopen_F
    use HGridsDatabase, only: HGrids_T, Dump
    use Init_Tables_Module, only: L_L2aux, L_L2dgg
    use Init_Tables_Module, only: F_File, F_Hgrid, &
      & Field_First, Field_Last, &
      & F_Type, F_RepairGeolocations
    use Intrinsic, only: L_Swath, L_HDF, Lit_Indices
    use L2AUXData, only: CpL2AUXData, Phasenameattributes
    use L2GPData, only: AvoidUnlimitedDims, &
      & MaxSwathNamesBufSize, CpL2GPData
    use L2ParInfo, only: Parallel
    use MLSCommon, only: MLSFile_T, Filenamelen, L2metaData_T
    use MLSHDF5, only: CpHDF5Glattribute, MakeHDF5Attribute, SaveAsHDF5DS
    use MLSPCF2, only: MLSPCF_L2DGM_Start, MLSPCF_L2DGM_End, &
      & MLSPCF_L2DGG_Start, MLSPCF_L2DGG_End
    use MLSFinds, only: FindFirst, FindNext
    use MLSStringLists, only: Array2List, SwitchDetail
    use MLSStrings, only: Trim_Safe
    use MoreTree, only: Get_Boolean
    use Output_M, only: Blanks, Output
    use PCFHdr, only: Globalattributes, DumpGlobalAttributes, &
      & H5_WriteMLSFileattr, H5_Writeglobalattr, &
      & He5_Writeglobalattr, He5_WriteMLSFileattr, &
      & WriteleapsecHDFeosattr, WriteleapsecHDF5ds, &
      & WriteutcpoleHDFeosattr, WriteutcpoleHDF5ds
    use Readapriori, only: Readaprioriattributes, Writeaprioriattributes
    use Tree, only: Decoration, Nsons, Subtree, Sub_Rosa
    ! Arguments
    integer, intent(in)                        :: key
    type (DirectData_T), dimension(:), pointer :: DirectDatabase
    type (MLSFile_T), dimension(:), pointer    :: FILEDATABASE
    type (HGrids_T), dimension(:), pointer     :: HGrids
    logical, intent(in)                        :: debug
    logical, intent(in)                        :: USINGSUBMIT ! Set if using the submit mechanism
    ! Local variables
    logical, parameter :: ALWAYSFILTERSWATHS = .true. ! Set Status to 'crashed'
    logical :: create2                                ! If geolocs contain Fills
    integer :: DB_index
    integer :: FIELD_INDEX              ! F_... field code
    integer :: FIELD_NO                 ! Index of assign vertex sons of Key
    integer :: FIELDVALUE               ! For get_boolean
    character (len=FileNameLen) :: FILE_BASE    ! From the FILE= field
    integer :: FILEID
    logical, dimension(field_first:field_last) :: GOT ! Fields
    integer :: GRP_ID
    integer :: GSON                     ! Son of Son -- an assign node
    integer :: HGridIndex
    type(MLSFile_T), pointer :: inputFile
    character (len=FileNameLen) :: L2auxPhysicalFilename
    integer :: L2gpFileHandle, L2gp_Version
    character (len=FileNameLen) :: L2gpPhysicalFilename
    integer :: listSize
    logical :: madeFile
    ! logical, parameter :: NEVERDUPSWATHNAMES = .true. ! Skip cp if dup
    integer :: numswaths
    integer :: obst
    integer, dimension(:,:), pointer :: obstruction_mafs => null()
    character(len=8) :: options
    type(MLSFile_T), pointer :: outputFile
    character(len=8) :: outputTypeStr
    integer :: output_type
    character (len=MAXSWATHNAMESBUFSIZE) :: outsdList
    logical :: RepairGeolocations
    integer :: ReturnStatus
    integer :: SDFID                ! File handle
    character (len=MAXSWATHNAMESBUFSIZE) :: sdList
    type(L2Metadata_T) :: l2metaData

    ! Executable
    options = ' '
    if ( ALWAYSFILTERSWATHS ) options = '-f'
    repairGeolocations = .false.
    if ( debug ) call dump(DirectDatabase)
    got = .false.
    HGridIndex = 0
    do field_no = 2, nsons(key)       ! Skip the command name
      gson = subtree(field_no, key)   ! An assign node
      if ( nsons(gson) > 1 ) then
        fieldValue = decoration(subtree(2,gson)) ! The field's value
      else
        fieldValue = gson
      end if
      field_index = decoration(subtree(1,gson))
      got(field_index) = .true.
      select case ( field_index )   ! Field name
      case ( f_file )
        call get_string ( sub_rosa(subtree(2,gson)), file_base, strip=.true. )
      case ( f_hgrid )
        HGridIndex = decoration(fieldValue)
        if ( DEBUG ) print *, 'HGridIndex: ', HGridIndex
      case ( f_type )
        output_type = decoration(subtree(2,gson))
        call get_string ( lit_indices(output_Type), outputTypeStr, strip=.true. )
      case ( f_repairGeolocations )
        repairGeolocations = get_boolean ( fieldValue )
      case default                  ! Everything else processed later
      end select
    end do
    ! Any dgg eligible for being catenated
    DB_index = findFirst( DirectDatabase%autoType, l_l2dgg )
    if ( findNext(DirectDatabase%autoType, l_l2dgg, DB_index) > 0 ) then
      if ( TOOLKIT ) then
        l2gp_Version = 1
        l2gpFileHandle = GetPCFromRef('DGG', MLSPCF_L2DGG_Start, &
          & MLSPCF_L2DGG_End, &
          & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
          & exactName=l2gpPhysicalFilename)
      else
        file_base = DirectDatabase(DB_index)%fileName
        l2gpPhysicalFilename = unSplitName(file_base)
        returnStatus = 0
      end if
      if ( len_trim(l2gpPhysicalFilename) < 1 ) &
        & l2gpPhysicalFilename = 'DGG' ! 'all_dgg.he5'
      if ( any(DirectDatabase%fileName == l2gpPhysicalFilename) ) then
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          & "Cannot unsplit dgg dw to existing file " // &
          & trim(l2gpPhysicalFilename) )
      end if
      outputFile => GetMLSFileByName(filedatabase, l2gpPhysicalFilename)
      if ( .not. associated(outputFile) ) then
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content='l2dgg', &
          & name=l2gpPhysicalFilename, shortName='DGG', &
          & type=l_swath, access=DFACC_RDWR, HDFVersion=HDFVERSION_5, &
          & PCBottom=MLSPCF_L2DGG_Start, PCTop=MLSPCF_L2DGG_End)
      endif
      madeFile = .false.
      create2 = .true.
      do DB_index = 1, size(DirectDatabase)
        if ( DirectDatabase(DB_index)%autoType /= l_l2dgg ) cycle
        numswaths = mls_InqSwath ( &
          & trim(DirectDatabase(DB_index)%fileName), sdList, listSize, &
          & hdfVersion=HDFVERSION_5 )
        if ( numSwaths < 1 ) cycle
        if ( DEBUG ) then
          call output ( 'preparing to cp split dgg', advance='yes' )
          call output ( 'from: ', advance='no' )
          call output ( trim(DirectDatabase(DB_index)%fileName) , advance='yes' )
          call output ( '   to: ', advance='no' )
          call output ( trim(l2gpPhysicalFilename) , advance='yes' )
        end if
        if ( mls_exists(trim(DirectDatabase(DB_index)%fileName)) /= 0 ) cycle
        inputFile => GetMLSFileByName(filedatabase, &
          & DirectDatabase(DB_index)%fileName)
        if ( .not. associated(inputFile) ) then
          call MLSL2Message ( MLSMSG_Error, ModuleName, &
            & 'No entry in filedatabase for ' // &
            & trim(DirectDatabase(DB_index)%fileName) )
        endif
        if ( CHECKPATHS ) cycle
        madeFile = .true.
        inputFile%access = DFACC_RDONLY
        if ( repairGeoLocations .and. got(f_HGrid) ) then
          numswaths = mls_InqSwath ( &
            & outputFile%Name, outsdList, listSize, &
            & hdfVersion=HDFVERSION_5 )
          if ( DEBUG ) then
            call outputnamedvalue( 'numswaths', numswaths )
            call outputnamedvalue( 'listSize', listSize )
            call outputnamedvalue( 'len_trim(outsdList)', len_trim(outsdList) )
          end if
          call cpL2GPData( l2metaData, inputFile, &
            & outputFile, exclude=outsdList, create2=create2, &
            & notUnlimited=avoidUnlimitedDims, &
            & andGlAttributes=COPYGLOBALATTRIBUTES, &
            & HGrid=HGrids(HGridIndex)%the_hGrid, options=trim(options) // 'cr' )
        else
          call cpL2GPData( l2metaData, inputFile, &
            & outputFile, exclude=outsdList, create2=create2, &
            & notUnlimited=avoidUnlimitedDims, &
            & andGlAttributes=COPYGLOBALATTRIBUTES, &
            & options=options )
        endif
        create2 = .false.
      end do
      ! Now write various kinds of metadata
      ! (1) Catalog metadata: only if file is just created, and TOOLKIT is available
      ! (2) File level attributes: only if file is just created
      ! (3) leapsec and utcpole contents: only if file is just created, and TOOLKIT is available
      if ( TOOLKIT .and. madeFile ) then
        ! (1) Catalog metadata
        call add_metadata ( 0, trim(l2gpPhysicalFilename), l2metaData, &
          & HDFVERSION_5, l_l2dgg, returnStatus, 1, (/'dgg'/) )
        if ( returnStatus /= 0 ) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'unable to addmetadata to ' // trim(l2gpPhysicalFilename) )
        if ( len_trim(l2metaData%doiIdentifier) < 1 ) then
          call MLSL2Message( MLSMSG_Warning, ModuleName, &
            & 'empty doiIdentidier for ' // trim(l2gpPhysicalFilename) )
        endif
        ! Set the file-level attribute DOI to its metadata value
        GlobalAttributes%DOI = l2metaData%doiIdentifier
      end if
      if ( madeFile ) then
         call output( 'Writing file level attributes to he5 ' // &
          & trim(l2gpPhysicalFilename), advance='yes' )
         call outputNamedValue( 'identifier_product_doi', trim(GlobalAttributes%DOI) )
         call outputNamedValue( 'ProductionLocation', trim(GlobalAttributes%productionLoc) )
         call he5_writeglobalattr( outputFile, &
           & doi=.true., skip_if_already_there=.true. )
         call DumpGlobalAttributes
       ! (2) File level attributes
        if ( WRITEFILEATTRIBUTES ) call he5_writeMLSFileAttr( outputFile )
        ! Is the next line necessary?
        if ( inputFile%stillOpen ) then
          call output( 'Closing input file before reading apriori attributes', &
            & advance='yes' )
          call MLS_CloseFile ( inputFile )
        endif
        call readAPrioriAttributes( inputFile )
        call writeAPrioriAttributes( outputFile )
      end if
      if ( TOOLKIT .and. madeFile ) then
        ! (3) leapsec and utcpole contents
        if (switchDetail( switches, 'pro') > 0 ) &
          call output ( 'About to open ' // trim(l2gpPhysicalFilename) , advance='yes' )
        call MLS_OpenFile( outputFile )
        call WriteLeapSecHDFEOSAttr ( outputFile%fileID%f_id )
        if ( .not. DGGFILEISHYBRID ) &
          & call WriteutcPoleHDFEOSAttr ( outputFile%fileID%f_id )
        call MLS_CloseFile ( outputFile )
        if ( DGGFILEISHYBRID ) then
          ! The utcpole is too large to be stored as an HDFEOS attribute
          ! Note:
          ! The dgg file up to v2.22 was already a "hybrid" file because
          ! the PCF was stored as a dataset instead of an attribute
          FileID = mls_sfstart( l2gpPhysicalFilename, DFACC_RDWR, &
              & hdfVersion=HDFVERSION_5 )
          call WriteutcPoleHDF5DS ( fileID )
          ReturnStatus = mls_sfend( fileID, hdfVersion=HDFVERSION_5 )
        endif
      end if
    end if
    ! Next we would do the same for any split dgm direct write files
    ! We must not write the phase and forward model names
    ! as held by us, the master, but instead
    ! wait until we can copy the correct values known only to the slaves
    PHASENAMEATTRIBUTES = .false.
    DB_index = findFirst( DirectDatabase%autoType, l_l2aux )
    if ( findNext(DirectDatabase%autoType, l_l2aux, DB_index) > 0 ) then
      if ( TOOLKIT ) then
        l2gp_Version = 1
        l2gpFileHandle = GetPCFromRef('DGM', MLSPCF_L2DGM_Start, &
          & MLSPCF_L2DGM_End, &
          & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
          & exactName=l2auxPhysicalFilename)
      else
        file_base = DirectDatabase(DB_index)%fileName
        l2auxPhysicalFilename = unSplitName(file_base)
        returnStatus = 0
      end if
      if ( len_trim(l2auxPhysicalFilename) < 1 ) &
        & l2auxPhysicalFilename = 'DGM' ! 'all_dgm.h5'
      if ( any(DirectDatabase%fileName == l2auxPhysicalFilename) ) then
        call MLSL2Message ( MLSMSG_Error, ModuleName, &
          &  "Must not unsplit dgm dw to " // trim(l2auxPhysicalFilename) )
      end if
      outputFile => GetMLSFileByName(filedatabase, l2auxPhysicalFilename)
      if ( .not. associated(outputFile) ) then
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content='l2aux', &
          & name=l2auxPhysicalFilename, shortName='L2AUX-DGM', &
          & type=l_hdf, access=DFACC_RDWR, HDFVersion=HDFVERSION_5, &
          & PCBottom=MLSPCF_L2DGM_Start, PCTop=MLSPCF_L2DGM_End)
      endif
      madeFile = .false.
      create2 = .true.
      do DB_index = 1, size(DirectDatabase)
        if ( CHECKPATHS ) cycle
        if ( DirectDatabase(DB_index)%autoType /= l_l2aux ) cycle
        if ( .not. associated(DirectDatabase(DB_index)%sdNames) ) then
          ! Someday, go back in Join and find out why these aren't saved
          ! call MLSL2Message ( MLSMSG_Warning, ModuleName, &
          !   &  "no sd known for " // trim(DirectDatabase(DB_index)%fileName) )
          sdList = ' '
        else
          call Array2List(DirectDatabase(DB_index)%sdNames, sdList)
        endif

        if ( DEBUG ) then
          call output ( 'preparing to cp split dgm', advance='yes' )
          call output ( 'from: ', advance='no' )
          call output ( 'DB_index ', advance='no' )
          call output ( DB_index , advance='no' )
          call blanks(3)
          call output ( trim(DirectDatabase(DB_index)%fileName) , advance='yes' )
          call output ( '   to: ', advance='no' )
          call output ( trim(l2auxPhysicalFilename) , advance='yes' )
          call output ( '   sdList: ', advance='no' )
          call output ( trim(sdList) , advance='yes' )
        end if
        if ( mls_exists(trim(DirectDatabase(DB_index)%fileName)) /= 0 ) cycle
        inputFile => GetMLSFileByName(filedatabase, &
          & DirectDatabase(DB_index)%fileName)
        if ( .not. associated(inputFile) ) then
          call MLSL2Message ( MLSMSG_Error, ModuleName, &
            & 'No entry in filedatabase for ' // &
            & trim(DirectDatabase(DB_index)%fileName) )
        endif

        inputFile%access = DFACC_RDONLY
        madeFile = .true.
        if ( sdList /= ' ' ) then
          call cpL2AUXData( inputFile, &
          & outputFile, create2=create2, sdList=trim(sdList) )
        else
          ! Last-ditch effort if somehow sdNames empty or Array2List fails
          call cpL2AUXData( inputFile, &
          & outputFile, create2=create2 )
        end if
        if ( create2 ) then
          call CpHDF5GlAttribute ( DirectDatabase(DB_index)%fileName, &
            & l2auxPhysicalFilename, 'Phase Names' )
          call CpHDF5GlAttribute ( DirectDatabase(DB_index)%fileName, &
            & l2auxPhysicalFilename, 'ForwardModel Names', &
            & skip_if_already_there=.true. )
          call CpHDF5GlAttribute ( DirectDatabase(DB_index)%fileName, &
            & l2auxPhysicalFilename, 'MiscNotes' )
        endif
        create2= .false.
      end do
      ! Is metadata really needed for l2aux files? Yes.
      if ( TOOLKIT .and. madeFile ) then
        call add_metadata ( 0, trim(l2auxPhysicalFilename), l2metaData, &
          & HDFVERSION_5, l_hdf, returnStatus, 1, (/'dgm'/) )
        GlobalAttributes%DOI = l2metaData%doiIdentifier
        if ( returnStatus /= 0 ) call MLSL2Message ( MLSMSG_Warning, ModuleName, &
        & 'unable to addmetadata to ' // trim(l2auxPhysicalFilename) )
        call output( 'Writing file level attributes to h5 ' // &
          & trim(l2auxPhysicalFilename), advance='yes' )
        call outputNamedValue( 'identifier_product_doi', trim(GlobalAttributes%DOI) )
        call outputNamedValue( 'ProductionLocation', trim(GlobalAttributes%productionLoc) )
        call h5_writeGlobalAttr ( outputFile, &
          & skip_if_already_there=.false., doi=.true. )
        call DumpGlobalAttributes
      end if
      
      ! Now we can write any last-minute attributes or datasets to the l2aux
      if ( madeFile .and. WRITEFILEATTRIBUTES ) &
        & call h5_writeMLSFileAttr ( outputFile )
      ! E.g., parallel stuff
      if ( (parallel%master .or. switchDetail(switches, 'chu') > -1 ) &
        & .and. .not. (checkPaths .or. SKIPDIRECTWRITES) .and. &
        & madeFile .and. l2auxPhysicalFilename /= ' ' ) then
        sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_RDWR, &
            & hdfVersion=HDFVERSION_5)
        if ( TOOLKIT ) then
          call WriteLeapSecHDF5DS (sdfId)
          call WriteutcPoleHDF5DS (sdfId)
        endif
        call h5gopen_f(sdfId, '/', grp_id, returnStatus)
        if ( .not. parallel%master .and. FAKEPARALLELMASTER ) then
          parallel%numCompletedChunks = 347
          parallel%numFailedChunks = 3
          parallel%FailedChunks = '2,5,129'
          parallel%FailedMachs = 'c0-1,c0-66,c0-66'
          parallel%FailedMachs = 'msg 1\msg 2\msg 3'
        endif
        call MakeHDF5Attribute(grp_id, &
         & 'NumCompletedChunks', parallel%numCompletedChunks, .true.)
        call MakeHDF5Attribute(grp_id, &
         & 'NumFailedChunks', parallel%numFailedChunks, .true.)
        call MakeHDF5Attribute(grp_id, &
         & 'FailedChunks', trim_safe(parallel%FailedChunks), .true.)
        if ( .not. usingSubmit ) &
          call MakeHDF5Attribute(grp_id, &
           & 'FailedMachines', trim_safe(parallel%FailedMachs), .true.)
        call MakeHDF5Attribute(grp_id, &
         & 'FailedMsgs', trim_safe(parallel%FailedMsgs), .true.)
        call h5gclose_f(grp_id, returnStatus)
        ! Write 2 datasets for obstructions db
        if ( associated(obstructions) ) then
          if ( size(obstructions) > 0 ) then
            call allocate_test( obstruction_mafs, size(obstructions), 2, &
              & 'obstruction_mafs', ModuleName )
            do obst=1, size(obstructions)
              obstruction_mafs(obst, :) = obstructions(obst)%mafs
            enddo
            call SaveAsHDF5DS( sdfID, 'obstructions_range', &
              & merge( 1, 0, obstructions%range ) )
            call SaveAsHDF5DS( sdfID, 'obstruction_mafs', obstruction_mafs )
            call deallocate_test( obstruction_mafs, &
              & 'obstruction_mafs', ModuleName )
          endif
        endif
        returnStatus = mls_sfend(sdfid, hdfVersion=HDFVERSION_5)
      endif
    end if
    PHASENAMEATTRIBUTES = .true.
  end subroutine unsplitFiles
    
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: OutputAndClose.f90,v 2.208 2020/04/30 23:32:24 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module OutputAndClose

! $Log: OutputAndClose.f90,v $
! Revision 2.208  2020/04/30 23:32:24  pwagner
! Give default non-blank filenames to catenated DGG/DGMs
!
! Revision 2.207  2020/02/07 01:15:26  pwagner
! Restores writing metadata for Cloud file
!
! Revision 2.206  2018/07/27 23:19:53  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.205  2018/05/31 22:49:27  pwagner
! Changed name of attribute to identifier_product_doi to please DAAC
!
! Revision 2.204  2018/03/22 18:15:05  pwagner
! Added command IsFileAbsent; may occur in ReadApriori, MergeGrids, and Output sections
!
! Revision 2.203  2017/10/11 23:58:40  pwagner
! Write obstructions%range as ints: 1 for T, 0 for F
!
! Revision 2.202  2017/07/10 23:09:13  pwagner
! Use MLSPCF_l2ascii_start, end for copying ascii files instead of MLSPCF_L2Clim_start
!
! Revision 2.201  2016/11/15 21:18:15  pwagner
! Use SayTime from time_m instead of local implementation
!
! Revision 2.200  2016/06/01 23:26:48  pwagner
! Be forgiving of Copy commands directed to non-existent files
!
! Revision 2.199  2016/05/18 01:37:30  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.198  2016/04/01 00:27:15  pwagner
! May now Execute a single command or a script of lines from l2cf
!
! Revision 2.197  2016/02/29 19:51:22  pwagner
! Usleep got from machine module instead of being an external
!
! Revision 2.196  2015/11/19 23:57:23  pwagner
! Now able to read from L2GP file
!
! Revision 2.195  2015/10/15 23:07:54  pwagner
! If /repairGeolocations , repair also any with chunknumber = -999
!
! Revision 2.194  2015/09/30 23:02:27  pwagner
! Catenate can repair geoLocations
!
! Revision 2.193  2015/08/03 21:45:22  pwagner
! Attempt to get dois for dgg and dgm like other prod names
!
! Revision 2.192  2015/06/19 20:54:56  pwagner
! Avoid Copying text file if it does not exist
!
! Revision 2.191  2015/03/28 02:50:35  vsnyder
! Paul added checking for Quantity type in DirectWrite
!
! Revision 2.190  2015/02/18 00:29:03  pwagner
! Debugging-type info shown only if debugging
!
! Revision 2.189  2014/11/04 01:23:50  pwagner
! Worked around hdfeos bug in implementing /additional for swath file attributes
!
! Revision 2.188  2014/10/13 18:10:01  pwagner
! Copying a swath also copies AprioriAttributes
!
! Revision 2.187  2014/10/07 00:06:47  pwagner
! May now write added file attributes
!
! Revision 2.186  2014/09/05 01:16:18  vsnyder
! Remove declarations of unused variables
!
! Revision 2.185  2014/09/05 00:49:07  vsnyder
! EmpiricalGeometry.f90 -- Wrong comment
!
! Revision 2.184  2014/04/14 17:39:48  pwagner
! Fixed bugs in writing DOIs for dgg, dgm files; still hard-wired, though
!
! Revision 2.183  2014/04/07 18:09:27  pwagner
! Stop Writing MLSFile_T attributes by default; they confuse users
!
! Revision 2.182  2014/04/02 23:04:34  pwagner
! Removed redundant open_ and close_MLSFile
!
! Revision 2.181  2014/03/28 00:01:10  pwagner
! repaired some bugs in writing DOI, ProdLoc attributes
!
! Revision 2.180  2014/03/26 17:46:59  pwagner
! Added ProductionLocation, identifier_product_DOI to attributes
!
! Revision 2.179  2014/02/28 01:06:44  vsnyder
! Move units checking to type checker.  Check value of hdfVersion.  Look
! for TIME field on SLEEP command, not CREATE field.
!
! Revision 2.178  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.177  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.176  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.175  2013/10/15 23:52:55  pwagner
! May copy quantity values to a file global attribute
!
! Revision 2.174  2013/10/09 23:42:13  vsnyder
! Add Evaluate_Variable
!
! Revision 2.173  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.172  2013/09/06 21:10:45  pwagner
! Move CopyQuantity into a separate subroutine
!
! Revision 2.171  2013/09/04 17:35:47  pwagner
! Replaced '--cat' cmdline option; 'Catenate' now an Output section command
!
! Revision 2.170  2013/08/30 02:45:45  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.169  2013/08/20 00:32:11  pwagner
! Avoid crashing when no ForwardModel Names attribute missing
!
! Revision 2.168  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.167  2012/11/08 23:20:00  pwagner
! Tries to avoid duplicating swath names during unsplit
!
! Revision 2.166  2012/08/16 17:51:43  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.165  2012/07/10 15:21:15  pwagner
! Sets Status to 'crashed' for swaths with Fills in geolocations
!
! Revision 2.164  2012/07/05 23:54:21  pwagner
! Copy command in Output may contain options field
!
! Revision 2.163  2012/05/14 18:33:34  pwagner
! Fixed bug that dooms checkPaths test flights
!
! Revision 2.162  2012/05/11 00:18:37  pwagner
! Added isSwathEmpty to set Boolean in Output; we can Skip Copy of OH when THz is off
!
! Revision 2.161  2012/05/10 00:47:02  pwagner
! Output section can have l2cf-control stuctures
!
! Revision 2.160  2012/03/14 16:57:03  pwagner
! Fixed most recent goldbrick-busting bug
!
! Revision 2.159  2012/03/12 17:28:22  pwagner
! Fixed bug preventing us from copying apriori attributes successfully
!
! Revision 2.158  2012/02/24 21:18:01  pwagner
! Correctly copy a priori attributes when unplitting files
!
! Revision 2.157  2012/02/08 23:16:30  pwagner
! Cant write utcpole, leapsec files w/o toolkit
!
! Revision 2.156  2011/11/30 21:34:23  pwagner
! Fixed bug affecting files w/o pcfids when using pcf
!
! Revision 2.155  2011/07/15 00:14:28  pwagner
! Wont crash on metadata errors now; was crashing goldbrick
!
! Revision 2.154  2011/06/29 21:51:51  pwagner
! Some cases may safely omit l1b files
!
! Revision 2.153  2010/09/17 00:07:18  pwagner
! Can constrain writing l2pc blocks by name
!
! Revision 2.152  2010/05/20 00:32:32  pwagner
! Remove unused stuff
!
! Revision 2.151  2010/03/24 20:53:45  vsnyder
! Add DumpBlocks to Output section
!
! Revision 2.150  2010/02/25 18:18:31  pwagner
! Conforms with changed l2pc structure
!
! Revision 2.149  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
! Revision 2.148  2010/01/08 00:11:37  pwagner
! Added ability to write MLSFile_T fields as attributes
!
! Revision 2.147  2009/11/10 00:44:03  pwagner
! Copies MiscNotes while unsplitting l2aux files, too
!
! Revision 2.146  2009/10/01 19:53:53  vsnyder
! Use strip=.true in get_string instead of unquote later
!
! Revision 2.145  2009/09/29 23:37:32  pwagner
! Changes needed by 64-bit build
!
! Revision 2.144  2009/08/26 17:18:42  pwagner
! Master copies file attributes from slaves instead of writing its own
!
! Revision 2.143  2009/07/01 20:37:30  pwagner
! Avoid adding metadata to a file more than once
!
! Revision 2.142  2009/06/26 00:17:14  pwagner
! May now copy ascii file to DGM calling input file type 'ascii' insstead of 'l2cf'
!
! Revision 2.141  2009/06/23 18:45:16  pwagner
! May copy arbitrary text file into DGM file
!
! Revision 2.140  2009/06/02 17:53:15  cvuu
! Add NRT Lat and Lon bounding to metadata
!
! Revision 2.139  2009/04/27 20:45:18  pwagner
! Fixed bug causing crashes in add_metadata when debugging
!
! Revision 2.138  2009/04/01 23:32:32  pwagner
! Writes obstructions db to l2aux file
!
! Revision 2.137  2008/12/02 23:13:15  pwagner
! mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
!
! Revision 2.136  2008/09/19 23:55:50  pwagner
! May now Destroy GriddedData
!
! Revision 2.135  2008/07/09 16:38:24  pwagner
! ReadStatus optional arg eliminated
!
! Revision 2.134  2008/04/25 22:55:29  pwagner
! Exploits ability of SaveAsHDF5DS to take textfile as arg
!
! Revision 2.133  2008/03/24 17:07:02  pwagner
! Removed unused procedures
!
! Revision 2.132  2008/02/22 21:36:41  pwagner
! DGG file was hybrid by default; now it will be pure HDFEOS
!
! Revision 2.131  2007/12/07 01:51:40  pwagner
! Removed unused dummy variables, etc.
!
! Revision 2.130  2007/05/30 22:30:29  pwagner
! Tries to avoid accessing components of unassociated pointers
!
! Revision 2.129  2007/04/05 22:52:01  pwagner
! NAG, too, now able to write L2CF to L2AUX
!
! Revision 2.128  2007/03/23 00:28:39  pwagner
! Steps gingerly around case of disassociated HGrids
!
! Revision 2.127  2007/01/18 19:39:16  pwagner
! Fixed bug causing Phase Names attribute to include only 1st phase
!
! Revision 2.126  2006/10/02 23:06:56  pwagner
! Write FailedMachines attribute unless using old mlssubmit
!
! Revision 2.125  2006/08/02 19:52:55  vsnyder
! Add destroy command and destroy field for output command
!
! Revision 2.124  2006/05/09 16:40:41  pwagner
! Added writing l2cf to dgm
!
! Revision 2.123  2006/04/28 00:46:28  pwagner
! Overcome namelength (132) limitation for file= field
!
! Revision 2.122  2006/04/11 23:35:38  pwagner
! More info why unable to unsplit dgg/dgm files
!
! Revision 2.121  2006/03/15 23:47:53  pwagner
! Fixed bug causing crashes when no gapless HGrid declared
!
! Revision 2.120  2006/03/04 00:23:30  pwagner
! Will not attempt copy unless input file contains swath
!
! Revision 2.119  2006/02/21 19:13:33  pwagner
! Some tweaks to where, when to dump
!
! Revision 2.118  2005/12/21 18:46:29  pwagner
! Fixed bug that clobbered split dgm files while copying them
!
! Revision 2.117  2005/12/10 00:51:36  pwagner
! Copies ForwardModel Names attribute when unsplitting spli dgms
!
! Revision 2.116  2005/11/15 00:22:05  pwagner
! Defined Overlaps for AllChunks chunk
!
! Revision 2.115  2005/11/04 18:55:46  pwagner
! Can add metadata when copying swaths, datasets
!
! Revision 2.114  2005/10/28 23:19:01  pwagner
! Many changes related to Copy; one may fixed a bug
!
! Revision 2.113  2005/10/22 00:46:14  pwagner
! May write all-day HGrid as attributes
!
! Revision 2.112  2005/09/23 23:39:35  pwagner
! Added rename field to copy command
!
! Revision 2.111  2005/09/21 23:27:17  pwagner
! Pokes holes in all-day HGrid to match obstructions
!
! Revision 2.110  2005/09/14 00:15:32  pwagner
! Relocate unsplitFiles before l2cf commands (so may copy swaths from DGG)
!
! Revision 2.109  2005/08/19 23:35:35  pwagner
! Allow Output to repair l2gp with HGrid while copying files
!
! Revision 2.108  2005/06/22 18:57:02  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.107  2005/06/16 18:43:01  pwagner
! Should not bomb if catenating split files w/o toolkit
!
! Revision 2.106  2005/06/14 20:43:49  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.105  2005/03/15 23:57:23  pwagner
! Makes error messages from about-to-die chunks dgm attributes
!
! Revision 2.104  2004/12/14 21:45:01  pwagner
! Avoid catenating non-existent split files
!
! Revision 2.103  2004/09/23 23:02:46  pwagner
! DGG gets apriori attrs; master task copies Phase Names from slave DGM
!
! Revision 2.102  2004/09/16 23:57:54  pwagner
! Now tracks machine names of failed chunks
!
! Revision 2.101  2004/09/16 00:19:05  pwagner
! Writes info on completed, failed chunks to l2aux as global attrs
!
! Revision 2.100  2004/08/26 18:52:56  pwagner
! Fixed checkPaths bug if outputting l2pc
!
! Revision 2.99  2004/08/04 23:19:58  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.98  2004/06/10 00:58:45  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.97  2004/05/19 20:22:09  vsnyder
! Remove USEs for unreferenced symbols, polish some cannonballs
!
! Revision 2.96  2004/04/24 00:22:55  pwagner
! Forcibly sets ReadStatus when knitting DGG; prunes L2GP- prefix from file_base
!
! Revision 2.95  2004/03/12 00:39:37  pwagner
! Interface to cpL2GPData changed to match
!
! Revision 2.94  2004/03/03 19:23:48  pwagner
! Master task never knows actual sdList to catenate; let cpL2AUXData figure it out
!
! Revision 2.93  2004/02/19 23:57:47  pwagner
! Hopefully will not try to write metadata if no file exists
!
! Revision 2.92  2004/02/05 23:35:21  pwagner
! Fixed some bugs in catenating split dgg/dgm directwrites
!
! Revision 2.91  2004/01/27 21:37:26  pwagner
! Can catenate split l2aux files
!
! Revision 2.90  2004/01/23 01:15:00  pwagner
! Began effort to catenate split direct write files
!
! Revision 2.89  2004/01/22 00:52:19  pwagner
! Small changes regarding metadata
!
! Revision 2.88  2003/11/07 00:46:51  pwagner
! New quicker preflight option: --checkPaths
!
! Revision 2.87  2003/10/28 21:42:36  pwagner
! Exits with message if cant GetPCFFromRef
!
! Revision 2.86  2003/10/20 23:59:20  pwagner
! Simplified code for writing metadata
!
! Revision 2.85  2003/10/16 18:29:35  pwagner
! Should not try to write metadata twice on DirectWrite files
!
! Revision 2.84  2003/09/19 23:29:27  pwagner
! Should not be a metadata error when DirectWrite-ing CH3CN
!
! Revision 2.83  2003/09/04 22:42:47  pwagner
! Some tweaks relating to DirectWrite; may not matter
!
! Revision 2.82  2003/08/15 20:43:10  pwagner
! Downgraded to warning if directwrite output_type unkown, e.g. l_l2fwm
!
! Revision 2.81  2003/08/08 23:06:39  livesey
! Added the dontPack option on outputing l2pc files.
!
! Revision 2.80  2003/08/01 20:07:44  pwagner
! Fixed Toolkit bug; metadata distinguishes l2dgg from l2gp
!
! Revision 2.79  2003/07/23 18:29:32  cvuu
! quick and dirty fixed for CH3CN
!
! Revision 2.78  2003/07/07 23:49:11  pwagner
! Add_metadata procedure now public
!
! Revision 2.77  2003/07/07 17:31:44  livesey
! Mainly cosmetic changes
!
! Revision 2.76  2003/06/26 00:17:17  pwagner
! Writes metadata to all files in DirectDataBase
!
! Revision 2.75  2003/06/24 23:54:07  pwagner
! New db indexes stored for entire direct file
!
! Revision 2.74  2003/06/23 18:06:33  pwagner
! Should allow us to write metadata after DirectWrite
!
! Revision 2.73  2003/06/20 19:38:26  pwagner
! Allows direct writing of output products
!
! Revision 2.72  2003/06/09 22:49:33  pwagner
! Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
!
! Revision 2.71  2003/05/12 02:07:06  livesey
! Bound r8->r4 conversion in direct write
!
! Revision 2.70  2003/04/03 22:59:23  pwagner
! setAlias no longer an arg to write_meta
!
! Revision 2.69  2003/03/20 19:22:56  pwagner
! Fixed bug in DirectWrite_hdf5; seems to work
!
! Revision 2.68  2003/03/11 00:21:36  pwagner
! Interfaces fit new WritePCF2Hdr flixibility
!
! Revision 2.67  2003/03/01 00:25:20  pwagner
! Disabled writing metadata to Log file (aka PH)
!
! Revision 2.66  2003/02/12 21:51:32  pwagner
! Should allow direct write with attributes
!
! Revision 2.65  2003/02/10 22:01:54  pwagner
! Passes isHDFEOS to metadata; writes globalattributes during DirectWrite
!
! Revision 2.64  2003/01/23 23:31:42  pwagner
! May directwrite to hdf5 l2aux files
!
! Revision 2.63  2002/12/11 22:21:05  pwagner
! Makes soft link to data field name from L2gpValue field in hdf5 l2gp
!
! Revision 2.62  2002/11/22 19:10:30  pwagner
! Upped MAXQUANTITIESPERFILE to 10k
!
! Revision 2.61  2002/11/13 01:10:09  pwagner
! Beginnings of attempt to write hdf5 L2AUX; incomplete
!
! Revision 2.60  2002/10/08 17:36:22  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.59  2002/08/21 02:35:18  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.58  2002/08/21 01:05:06  livesey
! Changed to single precision for direct write
!
! Revision 2.57  2002/08/20 04:37:06  livesey
! Minor typo
!
! Revision 2.56  2002/08/20 04:33:13  livesey
! Added extra check in direct write
!
! Revision 2.55  2002/08/15 21:47:04  pwagner
! WriteL2AuxData now returns non-zero status if it fails
!
! Revision 2.54  2002/06/12 17:58:42  livesey
! Intermediate support for HDF5 L2PCs
!
! Revision 2.53  2002/05/22 16:30:31  livesey
! Bug fix in directWrite
!
! Revision 2.52  2002/05/22 00:49:01  livesey
! Added direct write stuff
!
! Revision 2.51  2002/05/07 20:26:15  livesey
! Added writeCounterMAF option for l2aux
!
! Revision 2.50  2002/02/22 19:19:48  pwagner
! Fixed bug in metaName use
!
! Revision 2.49  2002/02/22 01:16:17  pwagner
! Uses new metaName field for mcf file hint
!
! Revision 2.48  2002/01/29 23:49:38  pwagner
! Separate DEFAULT_HDFVERSION_(READ)(WRITE)
!
! Revision 2.47  2002/01/26 00:10:45  pwagner
! Correctly sets hdfVersion; changed proclaim to announce_success
!
! Revision 2.46  2002/01/23 21:52:15  pwagner
! Accepts and uses hdfVersion optional field
!
! Revision 2.45  2002/01/18 23:07:48  pwagner
! Uses MLSFiles instead of HDFEOS
!
! Revision 2.44  2002/01/18 00:24:34  livesey
! Added packed option to outputing l2pc files
!
! Revision 2.43  2001/11/20 00:48:54  livesey
! Alleviated one bug in zero chunks case, but there's another one to
! fix later.  We need to decide how to handle this one.
!
! Revision 2.42  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.41  2001/11/01 21:05:10  pwagner
! Satisfies new WriteL2AuxData interface
!
! Revision 2.40  2001/10/12 23:12:23  pwagner
! Checks that number of quantities written to a file not grow too large
!
! Revision 2.39  2001/09/28 23:59:20  pwagner
! Fixed various timing problems
!
! Revision 2.38  2001/09/28 17:50:30  pwagner
! MLSL2Timings module keeps timing info
!
! Revision 2.37  2001/06/04 23:57:40  pwagner
! Splits path from l2cf-defined file name before getPCfromRef
!
! Revision 2.36  2001/05/30 23:03:13  pwagner
! Moved PCFL2CFSAMECASE to MLSL2Options
!
! Revision 2.35  2001/05/17 22:33:28  pwagner
! Prints info if pro switch set
!
! Revision 2.34  2001/05/04 23:22:13  pwagner
! Detachable from Toolkit; created metafiles conditionally
!
! Revision 2.33  2001/05/04 23:19:55  pwagner
! Detachable from Toolkit; created metafiles conditionally
!
! Revision 2.32  2001/05/03 20:32:33  vsnyder
! Add a nullify and some cosmetic changes
!
! Revision 2.31  2001/05/01 23:57:23  pwagner
! Added l2dgg output type
!
! Revision 2.30  2001/04/28 01:30:52  livesey
! Stuff formerly outputting L2PCs is now outputting matrices.
!
! Revision 2.29  2001/04/26 20:02:09  livesey
! Made l2pc database a saved array in L2PC_m
!
! Revision 2.28  2001/04/26 15:59:13  livesey
! Fixed arguments to writeOneL2PC
!
! Revision 2.27  2001/04/25 21:51:28  livesey
! Minor changes, add canWriteL2PC flag
!
! Revision 2.26  2001/04/25 20:34:04  livesey
! Now writes l2pc files
!
! Revision 2.25  2001/04/20 23:51:24  vsnyder
! Improve an error message.  Add an option to consider the penalty in
! Announce_Error.  Numerous cosmetic changes.
!
! Revision 2.24  2001/04/19 23:51:40  pwagner
! Moved anText to become component of PCFData_T
!
! Revision 2.23  2001/04/16 23:51:08  pwagner
! Gets penalty from MLSL2Options
!
! Revision 2.22  2001/04/13 23:48:37  pwagner
! Removed bogus increment of l2gp_mcf
!
! Revision 2.21  2001/04/13 00:26:23  pwagner
! Whether files named in PCF agree in case with l2cf controlled
!
! Revision 2.19  2001/04/10 23:01:57  pwagner
! Now works better; tacks if no metadata
!
! Revision 2.18  2001/04/09 23:44:34  pwagner
! Fewer mistakes, more debug-type output
!
! Revision 2.17  2001/04/07 00:13:44  pwagner
! Extra error checks
!
! Revision 2.16  2001/04/04 23:44:52  pwagner
! Now deallocates anText of PCF file at last
!
! Revision 2.15  2001/04/03 23:51:28  pwagner
! Many changes; some may be right
!
! Revision 2.14  2001/04/02 23:43:46  pwagner
! Now makes metadata calls; it compiles, but does it bomb?
!
! Revision 2.13  2001/03/28 00:23:20  pwagner
! Made tiny changes to use announce_error
!
! Revision 2.12  2001/03/20 18:35:02  pwagner
! Using GetPCFromRef to get file handles
!
! Revision 2.11  2001/03/15 21:18:57  vsnyder
! Use Get_Spec_ID instead of decoration(subtree...
!
! Revision 2.10  2001/03/06 22:40:24  livesey
! Working l2aux
!
! Revision 2.9  2001/02/23 18:15:48  livesey
! Added trace calls.
!
! Revision 2.8  2001/02/13 22:59:36  pwagner
! l2 modules can only use MLSPCF2
!
! Revision 2.7  2001/02/09 19:30:16  vsnyder
! Move checking for required and duplicate fields to init_tables_module
!
! Revision 2.6  2001/02/09 00:38:22  livesey
! Various updates
!
! Revision 2.5  2001/01/03 18:15:13  pwagner
! Changed types of t1, t2 to real
!
! Revision 2.4  2000/11/16 02:25:13  vsnyder
! Implement timing.
!
! Revision 2.3  2000/10/05 16:43:00  pwagner
! Now compiles with new L2GPData module
!
! Revision 2.2  2000/09/11 19:43:47  ahanzel
! Removed old log entries.
!
! Revision 2.1  2000/09/08 22:55:56  vsnyder
! Revised to use the tree output by the parser
!

@


2.208
log
@Give default non-blank filenames to catenated DGG/DGMs
@
text
@d326 1
d366 2
a367 1
          return
d374 1
a374 1
          if ( .not. TOOLKIT ) return
d379 1
a379 1
          if ( .not. TOOLKIT ) return
d382 2
d413 2
d429 1
a429 1
          if ( .not. TOOLKIT ) return
d2326 1
a2326 1
       "$Id: OutputAndClose.f90,v 2.207 2020/02/07 01:15:26 pwagner Exp $"
d2336 3
@


2.207
log
@Restores writing metadata for Cloud file
@
text
@d2038 2
d2177 2
d2320 1
a2320 1
       "$Id: OutputAndClose.f90,v 2.206 2018/07/27 23:19:53 pwagner Exp $"
d2330 3
@


2.206
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d767 1
d769 4
a772 1
         call MLSL2Message ( MLSMSG_Error, ModuleName, &
d774 1
d2316 1
a2316 1
       "$Id: OutputAndClose.f90,v 2.205 2018/05/31 22:49:27 pwagner Exp $"
d2326 3
@


2.205
log
@Changed name of attribute to identifier_product_doi to please DAAC
@
text
@d30 1
a30 1
    & MLSMessage, WriteFileAttributes
d359 1
a359 1
          & call MLSMessage(MLSMSG_Error, ModuleName, &
d384 1
a384 1
          if ( .not. canWriteL2PC ) call MLSMessage( MLSMSG_Error, ModuleName, &
d496 1
a496 1
          call MLSMessage( MLSMSG_Warning, ModuleName, &
d535 1
a535 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d702 1
a702 1
         call MLSMessage ( MLSMSG_Error, ModuleName, &
d705 1
a705 1
         call MLSMessage ( MLSMSG_Warning, ModuleName, &
d709 1
a709 1
         call MLSMessage ( MLSMSG_Error, ModuleName, &
d768 1
a768 1
         call MLSMessage ( MLSMSG_Error, ModuleName, &
d809 1
a809 1
    call MLSMessage( MLSMSG_Warning, ModuleName, &
d815 1
a815 1
    call MLSMessage( MLSMSG_Error, ModuleName, &
d1038 2
a1039 2
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & "Cannot repair Geolocs w/o an HGrid to copy from")
d1042 2
a1043 2
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & "No HGrids defined yet")
d1046 2
a1047 2
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & "No HGrids defined yet")
d1050 2
a1051 2
      & call MLSMessage(MLSMSG_Error, ModuleName, &
      & "Cannot copy specifying both swaths and excludes")
d1054 2
a1055 2
      call MLSMessage(MLSMSG_Info, ModuleName, &
      & "No crashed chunks so skipping this copy")
d1101 1
a1101 1
      call MLSMessage(MLSMSG_Error, ModuleName, &
d1112 1
a1112 1
        call MLSMessage(MLSMSG_Error, ModuleName, &
d1120 1
a1120 1
        call MLSMessage(MLSMSG_Error, ModuleName, &
d1137 1
a1137 1
        call MLSMessage(MLSMSG_Error, ModuleName, &
d1149 1
a1149 1
        call MLSMessage(MLSMSG_Warning, ModuleName, &
d1179 1
a1179 1
          call MLSMessage(MLSMSG_Warning, ModuleName, &
d1262 1
a1262 1
        call MLSMessage( MLSMSG_Warning, ModuleName, &
d1338 1
a1338 1
        & call MLSMessage(MLSMSG_Warning, ModuleName, &
d1347 1
a1347 1
          & call MLSMessage(MLSMSG_Warning, ModuleName, &
d1433 1
a1433 1
        & call MLSMessage(MLSMSG_Warning, ModuleName, &
d1442 1
a1442 1
        & call MLSMessage(MLSMSG_Warning, ModuleName, &
d1458 1
a1458 1
        if ( returnStatus /= 0 ) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1463 1
a1463 1
      if ( returnStatus /= 0 ) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1468 1
a1468 1
      if ( returnStatus /= 0 ) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1484 1
a1484 1
      if ( returnStatus /= 0 ) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1487 1
a1487 1
      if ( returnStatus /= 0 ) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1566 1
a1566 1
        if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1600 1
a1600 1
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1661 1
a1661 1
      call MLSMessage(MLSMSG_Warning, ModuleName, &
d1667 1
a1667 1
      call MLSMessage(MLSMSG_Warning, ModuleName, &
d1689 1
a1689 1
        & call MLSMessage(MLSMSG_Warning, ModuleName, &
d1698 1
a1698 1
          & call MLSMessage(MLSMSG_Warning, ModuleName, &
d1784 1
a1784 1
        if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1813 1
a1813 1
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2034 1
a2034 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d2065 1
a2065 1
          call MLSMessage(MLSMSG_Error, ModuleName, &
d2103 1
a2103 1
        if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2106 1
a2106 1
          call MLSMessage( MLSMSG_Warning, ModuleName, &
d2171 1
a2171 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d2189 1
a2189 1
          ! call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2212 1
a2212 1
          call MLSMessage(MLSMSG_Error, ModuleName, &
d2243 1
a2243 1
        if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
d2311 1
a2311 1
       "$Id: OutputAndClose.f90,v 2.204 2018/03/22 18:15:05 pwagner Exp $"
d2321 3
@


2.204
log
@Added command IsFileAbsent; may occur in ReadApriori, MergeGrids, and Output sections
@
text
@d923 1
a923 1
    use PCFHdr, only: Globalattributes, &
d1276 1
d1280 1
a1280 1
        call outputNamedValue( 'identifier_product_DOI', trim(GlobalAttributes%DOI) )
d1283 1
d1941 1
a1941 1
    use PCFHdr, only: Globalattributes, &
d2115 1
a2115 1
         call outputNamedValue( 'identifier_product_DOI', trim(GlobalAttributes%DOI) )
d2119 1
d2247 1
a2247 1
        call outputNamedValue( 'identifier_product_DOI', trim(GlobalAttributes%DOI) )
d2251 1
d2311 1
a2311 1
       "$Id: OutputAndClose.f90,v 2.203 2017/10/11 23:58:40 pwagner Exp $"
d2321 3
@


2.203
log
@Write obstructions%range as ints: 1 for T, 0 for F
@
text
@d81 2
a82 2
      & DumpCommand, ExecuteCommand, MLSCase, MLSEndselect, MLSSelect, MLSSelecting, &
      & Skip
d96 2
a97 2
      & S_Destroy, S_Diff, S_Dump, S_Dumpblocks, &
      & S_Endselect, S_Execute, S_Hgrid, S_Isswathempty, S_L2gp, S_Output, &
d293 1
a293 1
      case ( s_isSwathEmpty )
d2307 1
a2307 1
       "$Id: OutputAndClose.f90,v 2.202 2017/07/10 23:09:13 pwagner Exp $"
d2317 3
@


2.202
log
@Use MLSPCF_l2ascii_start, end for copying ascii files instead of MLSPCF_L2Clim_start
@
text
@d2291 3
a2293 2
            call SaveAsHDF5DS( sdfID, 'obstructions_range', obstructions%range )
            call SaveAsHDF5DS( sdfID, 'obstructions_mafs', obstruction_mafs )
d2307 1
a2307 1
       "$Id: OutputAndClose.f90,v 2.201 2016/11/15 21:18:15 pwagner Exp $"
d2317 3
@


2.201
log
@Use SayTime from time_m instead of local implementation
@
text
@d19 6
a24 6
  use HDF, only: dfacc_rdonly, dfacc_rdwr
  use HighOutput, only: letsDebug, outputNamedValue
  use machine, only: USleep
  use MLSFiles, only: HDFVersion_5, addInitializeMLSFile, dump, &
    & GetMLSFileByName, getMLSFileByType, getPCFromRef, &
    & MLS_Closefile, MLS_Exists, MLS_Inqswath, MLS_Openfile, &
d26 1
a26 1
    & Split_path_name, unSplitName
d28 3
a30 3
  use MLSL2Options, only: checkpaths, &
    & Default_HDFVersion_write, l2cfnode, &
    & SpecialDumpFile, skipDirectwrites, toolkit, MLSMessage, writeFileAttributes
d32 2
a33 2
  use String_table, only: display_string, get_string
  use Toggles, only: gen, toggle, switches
d75 34
a108 34
    use allocate_deallocate, only: deallocate_test, allocate_test
    use chunks_m, only: MLSchunk_t, dump
    use chunkDivide_m, only: chunkDivideConfig, obstructions
    use destroyCommand_m, only: destroyCommand
    use directWrite_m, only: directData_t, dump
    use dumpCommand_m, only: booleanFromEmptySwath, booleanFromFormula, &
      & dumpCommand, ExecuteCommand, MLScase, MLSendselect, MLSselect, MLSselecting, &
      & skip
    use expr_m, only: expr
    use griddedData, only: griddedData_t
    use hessianModule_1, only: hessian_t
    use HGrid, only: createHGridfromMLScfinfo, dealWithObstructions
    use HGridsdatabase, only: HGrid_T, HGrids_t, &
      & addHGridtodatabase, dump
    use init_tables_module, only: f_additional, f_attrName, f_attrValue, &
      & f_destroy, f_dontpack, f_file, f_hdfversion, &
      & f_metadataonly, f_metaname, f_moleculesecondderivatives, f_overlaps, &
      & f_packed, f_quantities, f_reset, f_time, f_type, f_writecountermaf, &
      & field_first, field_last, &
      & l_l2aux, l_l2cf, l_l2dgg, l_l2gp, l_l2pc, &
      & s_boolean, s_case, s_catenate, s_copy, &
      & s_destroy, s_diff, s_dump, s_dumpblocks, &
      & s_endselect, s_execute, s_hgrid, s_isswathempty, s_l2gp, s_output, &
      & s_reevaluate, s_select, s_skip, s_sleep, s_time, s_writeFileAttribute
    use intrinsic, only: lit_indices
    use L2AUXData, only: L2AUXData_t
    use L2GPData, only: L2GPData_t, &
      & AddL2GPToDatabase, writeMastersFileAttributes
    use L2PC_m, only: outputHDF5L2PC
    use L2ParInfo, only: parallel
    use matrixModule_1, only: matrix_database_t
    use matrixTools, only: dumpblocks
    use MLSCommon, only: MLSfile_t, tai93_range_t, filenamelen
    use MLSL2Timings, only: section_times, total_times
d111 10
a120 10
    use MLSStringlists, only: switchdetail
    use MLSStrings, only: trim_safe
    use moretree, only: get_label_and_spec, get_spec_id, get_boolean
    use next_tree_node_m, only: next_tree_node, next_tree_node_state
    use output_m, only: blanks, output, revertoutput, switchoutput
    use time_m, only: SayTime, time_now
    use trace_m, only: trace_begin, trace_end
    use tree, only: decorate, decoration, nsons, subtree, sub_rosa
    use vectorsModule, only: vector_t
    use writeMetadata, only: L2PCF, writeMetalog
d132 1
a132 1
    type (griddedData_T), dimension(:), pointer :: GriddedDataBase
d171 1
a171 1
    real :: T1, T2     ! for timing
d547 4
a550 4
    use Init_tables_module, only: f_file, f_sdname, f_noPCFid, f_swath, &
      & field_first, field_last
    use L2GPData, only: L2GPData_t
    use MLSCommon, only: fileNameLen, MLSFile_t
d553 5
a557 5
      & MLSPCF_L2APriori_start, MLSPCF_L2APriori_end
    use MoreTree, only: get_boolean
    use readapriori, only: processOneL2GPFile
    use Tree, only: decoration, nsons, &
      &             sub_rosa, subtree
d623 6
a628 6
    use allocate_deallocate, only: deallocate_test, allocate_test
    use init_tables_module, only: l_l2dgg, l_quantity
    use intrinsic, only: l_swath, l_hdf
    use MLSCommon, only: l2metadata_t
    use L2GPData, only: L2GPNamelen, maxswathnamesbufsize
    use MLSHDF5, only: getallhdf5dsnames
d633 4
a636 4
    use MLSStringLists, only: getHashElement, list2array, numStringElements
    use output_m, only: output
    use writeMetadata, only: L2PCF, populate_metadata_std, &
      & populate_metadata_oth, get_l2gp_mcf
d827 1
a827 1
    use output_m, only: blanks, output
d864 3
a866 3
    use lexer_core, only: print_source
    use output_m, only: output
    use tree, only: Where_At => Where
d899 17
a915 17
    use expr_m, only: expr
    use HGridsdatabase, only: HGrids_t, dump
    use init_tables_module, only: f_create, &
      & f_exclude, f_file, f_hdfversion, f_hgrid, &
      & f_ifanycrashedchunks, f_inputfile, f_inputtype, &
      & f_options, &
      & f_rename, f_repairgeolocations, &
      & f_swath, f_toattribute, f_type, &
      & field_first, field_last, &
      & l_l2aux, l_l2cf, l_l2dgg, l_l2gp
    use highOutput, only: outputnamedValue
    use intrinsic, only: l_ascii, l_swath, l_hdf, lit_indices
    use L2AUXData, only: cpL2AUXData
    use L2GPData, only: avoidunlimiteddims, &
      & maxswathnamesbufsize, cpL2GPData, cpL2GPDatatoattribute
    use l2parinfo, only: parallel
    use MLSCommon, only: mlsfile_t, filenamelen, l2metadata_t
d918 9
a926 9
      & MLSPCF_L2CLIM_Start, MLSPCF_L2CLIM_End
    use MLSStringlists, only: intersection, switchdetail
    use MLSStrings, only: lowercase
    use moretree, only: get_boolean
    use output_m, only: output
    use PCFHdr, only: globalattributes, &
      & h5_writeglobalattr, he5_writeMLSFileattr, he5_writeGlobalAttr
    use readAPriori, only: readAPrioriattributes, writeAPrioriAttributes
    use tree, only: decoration, nsons, subtree, sub_rosa
d1142 1
a1142 1
        & MLSPCF_L2Clim_start, MLSPCF_L2Clim_end)
d1147 1
a1147 1
          & PCBottom=MLSPCF_L2Clim_start, PCTop=MLSPCF_L2Clim_end )
d1290 3
a1292 3
    use HDF5, only: H5GClose_f, H5GOpen_f
    use intrinsic, only: l_hdf
    use MLSCommon, only: MLSFile_t, fileNameLen
d1294 2
a1295 2
    use MLSStringLists, only: switchDetail
    use output_m, only: output
d1378 3
a1380 3
    use HDF5, only: h5f_acc_rdwr_f, h5fclose_f, h5fopen_f, h5gclose_f, h5gopen_f
    use intrinsic, only: l_swath, lit_indices
    use MLSCommon, only: MLSFile_t, fileNameLen
d1383 2
a1384 2
    use MLSStringLists, only: switchDetail
    use output_m, only: output
d1507 3
a1509 3
    use init_tables_module, only: f_overlaps, f_quantities
    use intrinsic, only: l_hdf
    use L2AUXData, only: L2AUXData_t, writeL2AUXData
d1511 1
a1511 1
    use MLSCommon, only: MLSFile_t, fileNamelen, l2metadata_t
d1513 3
a1515 3
    use MLSStringLists, only: switchDetail
    use SDPToolkit, only: pgs_s_success
    use tree, only: decoration, nsons, subtree
d1629 6
a1634 6
    use intrinsic, only: l_hdf
    use MLSCommon, only: MLSFile_t, fileNameLen
    use MLSHDF5, only: saveashdf5ds
    use MLSPCF2, only: MLSPCF_L2DGM_Start, MLSPCF_L2DGM_End
    use MLSStringLists, only: switchDetail
    use output_m, only: output
d1723 8
a1730 8
    use HGridsDatabase, only: HGrid_t
    use Init_tables_module, only: f_overlaps, f_quantities
    use intrinsic, only: l_swath, lit_indices
    use L2GPData, only: L2GPData_t, l2gpnamelen, writeL2GPData
    use MLSCommon, only: mlsfile_t, filenamelen, l2metadata_t
    use MLSStringlists, only: switchdetail
    use SDPToolkit, only: pgs_s_success
    use Tree, only: decoration, nsons, subtree
d1843 4
a1846 4
    use HDFEOS5, only: he5_swclose, he5_swopen, &
      & he5f_acc_rdwr, he5t_native_int, he5t_native_double
    use HGridsDatabase, only: hgrid_t
    use MLSHDFEOS, only: he5_ehwrglatt, hsize, mls_isglatt
d1916 16
a1931 16
    use allocate_deallocate, only: deallocate_test, allocate_test
    use chunkDivide_m, only: obstructions
    use directWrite_m, only: directData_t, dump
    use hdf5, only: h5gclose_f, h5gopen_f
    use HGridsDatabase, only: HGrids_t, dump
    use init_tables_module, only: l_l2aux, l_l2dgg
    use init_tables_module, only: f_file, f_hgrid, &
      & field_first, field_last, &
      & f_type, f_repairGeolocations
    use intrinsic, only: l_swath, l_hdf, lit_indices
    use L2AUXData, only: cpL2AUXData, phasenameattributes
    use L2GPData, only: avoidUnlimitedDims, &
      & maxSwathNamesBufSize, cpL2GPData
    use L2ParInfo, only: parallel
    use MLSCommon, only: mlsfile_t, filenamelen, l2metadata_t
    use MLSHdf5, only: cpHDF5Glattribute, makeHDF5Attribute, saveAsHDF5DS
d1934 12
a1945 12
    use MLSFinds, only: findFirst, findNext
    use MLSStringLists, only: array2List, switchDetail
    use MLSStrings, only: trim_safe
    use moreTree, only: get_boolean
    use output_m, only: blanks, output
    use PCFHdr, only: globalattributes, &
      & h5_writemlsfileattr, h5_writeglobalattr, &
      & he5_writeglobalattr, he5_writemlsfileattr, &
      & writeleapsechdfeosattr, writeleapsechdf5ds, &
      & writeutcpolehdfeosattr, writeutcpolehdf5ds
    use readapriori, only: readaprioriattributes, writeaprioriattributes
    use tree, only: decoration, nsons, subtree, sub_rosa
d2306 1
a2306 1
       "$Id: OutputAndClose.f90,v 2.200 2016/06/01 23:26:48 pwagner Exp $"
d2316 3
@


2.200
log
@Be forgiving of Copy commands directed to non-existent files
@
text
@d92 1
a92 1
      & f_packed, f_quantities, f_time, f_type, f_writecountermaf, &
d102 1
a102 1
      & AddL2GPToDatabase, writemastersfileattributes
d108 1
a108 1
    use MLSL2timings, only: section_times, total_times
d116 1
a116 1
    use time_m, only: time_now
d166 1
d227 2
a228 1
        & .not. any( get_spec_id(key) == (/ s_endselect, s_select, s_case /) ) ) cycle
d230 17
d450 2
a451 2
        if ( timing ) then
          call sayTime
d539 1
a539 1
    if ( timing ) call sayTime
a541 13
  contains
    subroutine SayTime
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      end if
      call output ( "Timing for Output_Close =" )
      call output ( DBLE(t2 - t1), advance = 'yes' )
      timing = .false.
    end subroutine SayTime

d2306 1
a2306 1
       "$Id: OutputAndClose.f90,v 2.199 2016/05/18 01:37:30 vsnyder Exp $"
d2316 3
@


2.199
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@d22 1
a22 1
  use MLSFiles, only: hdfversion_5, addInitializeMLSFile, dump, &
d24 2
a25 2
    & MLS_Closefile, mls_exists, mls_inqswath, mls_openfile, &
    & MLS_SFStart, mls_sfend, &
d31 1
a31 1
  use MLSMessagemodule, only: MLSMSG_Error, MLSMSG_Info, MLSMSG_Warning
d33 1
d59 1
a59 1
  subroutine Output_Close ( root, l2gpDatabase, l2auxDatabase, DirectDatabase, &
d67 3
a69 3
    !   for the l2aux the mcf is mlspcf_mcf_l2dgm_start
    !   for the log file the mcf is mlspcf_mcf_l2log_start
    !   for the dgg file the mcf is mlspcf_mcf_l2dgg_start
d100 1
a100 1
    use L2AuxData, only: L2AUXData_t
d109 2
a110 2
    use MLSPcf2, only: MLSpcf_l2gp_end, &
      & MLSPcf_l2gp_start, MLSpcf_l2dgg_start, MLSpcf_l2dgg_end
a116 1
    use toggles, only: gen, toggle, switches
d124 2
a125 2
    type (L2GPData_T), dimension(:), pointer :: L2GPDATABASE ! L2GP products
    type (L2AUXData_T), dimension(:), pointer :: L2AUXDATABASE ! L2AUX products
d190 1
a190 1
    if (switchDetail( switches, 'pro') > -1 ) then
d289 1
a289 1
        call decorate ( key, AddHGridToDatabase ( hGrids, CreateHGridFromMLSCFInfo ( name, key, filedatabase, l2gpDatabase, &
d351 2
a352 2
            & output_type, mlspcf_l2gp_start, mlspcf_l2gp_end, &
            & filedatabase, l2gpDatabase, newHGridp )
d357 1
a357 1
            & filedatabase, l2auxDatabase )
d402 2
a403 2
            & output_type, mlspcf_l2dgg_start, mlspcf_l2dgg_end, &
            & filedatabase, l2gpDatabase, newHGridp )
d470 1
a470 1
            & output_type, mlspcf_l2gp_start, mlspcf_l2gp_end, &
d474 1
a474 1
            & output_type, mlspcf_l2dgg_start, mlspcf_l2dgg_end, &
d543 2
a544 2
    use L2GPdata, only: L2GPData_t
    use MLSCommon, only: filenamelen, MLSfile_t
d547 1
a547 1
      & MLSPCF_l2apriori_start, MLSPCF_l2apriori_end
d574 1
a574 1
    LastAprioriPCF = mlspcf_l2apriori_start - 1
d606 1
a606 1
      & noPCFid, mlspcf_l2apriori_start, mlspcf_l2apriori_end, &
d623 4
a626 4
    use MLSPCF2, only: MLSPCF_l2dgm_end, MLSPCF_l2dgm_start, MLSPCF_l2gp_end, &
      & MLSPCF_l2gp_start, MLSPCF_l2dgg_start, MLSPCF_l2dgg_end, &
      & MLSPCF_mcf_l2dgm_start, MLSPCF_mcf_l2dgg_start, &
      & MLSPCF_mcf_l2gp_start
d665 3
a667 3
  l2aux_mcf = mlspcf_mcf_l2dgm_start
  l2dgg_mcf = mlspcf_mcf_l2dgg_start
  l2gp_mcf  = mlspcf_mcf_l2gp_start - 1
d678 2
a679 2
       FileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
         & mlspcf_l2dgg_end, &
d688 2
a689 2
       FileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
         & mlspcf_l2gp_end, &
d757 2
a758 2
     FileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
       & mlspcf_l2dgm_end, &
d905 3
a907 3
    use l2auxdata, only: cpl2auxdata
    use l2gpdata, only: avoidunlimiteddims, &
      & maxswathnamesbufsize, cpl2gpdata, cpl2gpdatatoattribute
d910 3
a912 3
    use MLSPCF2, only: MLSPCF_l2dgm_end, MLSPCF_l2dgm_start, MLSPCF_l2gp_end, &
      & MLSPCF_l2gp_start, MLSPCF_l2dgg_start, MLSPCF_l2dgg_end, &
      & MLSPCF_l2clim_start, MLSPCF_l2clim_end
a919 1
    use toggles, only: switches
d1057 1
a1057 1
        & mlspcf_l2dgm_start, mlspcf_l2dgm_end)
d1065 1
a1065 1
          & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
d1069 1
a1069 1
        & mlspcf_l2gp_start, mlspcf_l2gp_end)
d1077 1
a1077 1
          & PCBottom=mlspcf_l2gp_start, PCTop=mlspcf_l2gp_end)
d1081 1
a1081 1
        & mlspcf_l2dgg_start, mlspcf_l2dgg_end)
d1089 1
a1089 1
          & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
d1103 1
a1103 1
        & mlspcf_l2dgm_start, mlspcf_l2dgm_end)
d1111 1
a1111 1
        & mlspcf_l2gp_start, mlspcf_l2gp_end)
d1119 1
a1119 1
        & mlspcf_l2dgg_start, mlspcf_l2dgg_end)
d1136 1
a1136 1
        & mlspcf_l2clim_start, mlspcf_l2clim_end)
d1141 1
a1141 1
          & PCBottom=mlspcf_l2clim_start, PCTop=mlspcf_l2clim_end )
d1286 3
a1288 2
    use MLSCommon, only: mlsfile_t, filenamelen
    use MLSPcf2, only: mlspcf_l2dgm_start, mlspcf_l2dgm_end
d1319 2
a1320 2
      FileHandle = GetPCFromRef(fileName, mlspcf_l2dgm_start, &
        & mlspcf_l2dgm_end, &
d1328 7
a1334 1
    if ( returnStatus == 0 .and. .not. checkPaths ) then
d1338 2
a1339 1
        if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1345 1
a1345 1
          & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end )
d1377 1
d1423 8
a1430 2
    if ( returnStatus == 0 .and. .not. checkPaths ) then
      ! Open the HDF-EOS file and write swath data
d1433 2
a1434 1
        if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1499 1
a1499 1
    & filedatabase, l2auxDatabase )
d1504 1
a1504 1
    use L2GPdata, only: L2GPNamelen
d1506 1
a1506 1
    use MLSPcf2, only: mlspcf_l2dgm_start, mlspcf_l2dgm_end
a1508 1
    use toggles, only: switches
d1516 1
a1516 1
    type(L2AUXData_T), dimension(:), pointer :: l2auxDatabase
d1545 2
a1546 2
      FileHandle = GetPCFromRef(fileName, mlspcf_l2dgm_start, &
        & mlspcf_l2dgm_end, &
d1564 1
a1564 1
          & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
d1576 1
a1576 1
              call WriteL2AUXData ( l2auxDatabase(db_index), outputFile, &
d1589 1
a1589 1
                & ( l2auxDatabase(db_index)%name, &
d1626 2
a1627 1
    use MLSPCF2, only: mlspcf_l2dgm_start, mlspcf_l2dgm_end
d1670 2
a1671 2
      FileHandle = GetPCFromRef(fileName, mlspcf_l2dgm_start, &
        & mlspcf_l2dgm_end, &
d1679 7
a1685 1
    if ( returnStatus == 0 .and. .not. checkPaths ) then
d1689 2
a1690 1
        if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
d1696 1
a1696 1
          & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
d1715 1
a1715 1
    & filedatabase, l2gpDatabase, HGrid )
d1720 1
a1720 1
    use L2gpdata, only: l2gpdata_t, l2gpnamelen, writel2gpdata
a1723 1
    use Toggles, only: switches
d1733 1
a1733 1
    type(L2GPData_T), dimension(:), pointer :: l2gpDatabase
d1794 1
a1794 1
              call writeL2GPData ( l2gpDatabase(db_index), outputFile )
d1803 1
a1803 1
              quantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
d1911 2
a1912 2
    use chunkdivide_m, only: obstructions
    use directwrite_m, only: directdata_t, dump
d1914 1
a1914 1
    use HGridsdatabase, only: HGrids_t, dump
d1920 4
a1923 4
    use l2auxdata, only: cpl2auxdata, phasenameattributes
    use l2gpdata, only: avoidunlimiteddims, &
      & maxswathnamesbufsize, cpl2gpdata
    use l2parinfo, only: parallel
d1925 5
a1929 5
    use MLSHdf5, only: cphdf5glattribute, makehdf5attribute, saveashdf5ds
    use MLSPcf2, only: mlspcf_l2dgm_end, mlspcf_l2dgm_start, &
      & MLSPcf_l2dgg_start, mlspcf_l2dgg_end
    use MLSFinds, only: findfirst, findnext
    use MLSStringlists, only: array2list, switchdetail
d1931 1
a1931 1
    use moretree, only: get_boolean
d1933 1
a1933 1
    use pcfhdr, only: globalattributes, &
a1938 1
    use toggles, only: switches
d2016 2
a2017 2
        l2gpFileHandle = GetPCFromRef('DGG', mlspcf_l2dgg_start, &
          & mlspcf_l2dgg_end, &
d2036 1
a2036 1
          & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
d2152 2
a2153 2
        l2gpFileHandle = GetPCFromRef('DGM', mlspcf_l2dgm_start, &
          & mlspcf_l2dgm_end, &
d2171 1
a2171 1
          & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
d2300 1
a2300 1
       "$Id: OutputAndClose.f90,v 2.198 2016/04/01 00:27:15 pwagner Exp $"
d2310 4
@


2.198
log
@May now Execute a single command or a script of lines from l2cf
@
text
@d86 1
a86 1
    use HGridsdatabase, only: HGrid_t, &
d152 1
a152 1
    type (HGrid_T), dimension(:), pointer :: HGrids => null()
d292 1
a292 1
        newHGridp => hGrids(1) 
d349 1
a349 1
        if ( noGapsHGIndex > 0 ) newHGridp => HGrids(noGapsHGIndex)
d400 1
a400 1
        if ( noGapsHGIndex > 0 ) newHGridp => HGrids(noGapsHGIndex)
d894 1
a894 1
    use HGridsdatabase, only: HGrid_t, dump
d936 1
a936 1
    type (HGrid_T), dimension(:), pointer :: HGrids => null()
d1211 1
a1211 1
          & HGrid=HGrids(HGridIndex), options=optionsString )
d1218 1
a1218 1
          & HGrid=HGrids(HGridIndex), options=optionsString )
d1249 1
a1249 1
        & HGrids(noGapsHGIndex) )
d1695 2
a1696 2
    use hgridsdatabase, only: hgrid_t
    use init_tables_module, only: f_overlaps, f_quantities
d1698 1
a1698 1
    use l2gpdata, only: l2gpdata_t, l2gpnamelen, writel2gpdata
d1702 2
a1703 2
    use toggles, only: switches
    use tree, only: decoration, nsons, subtree
d1713 1
a1713 1
    type(HGRID_T)                           :: HGrid
d1893 1
a1893 1
    use HGridsdatabase, only: HGrid_t, dump
d1924 1
a1924 1
    type (HGrid_T), dimension(:), pointer      :: HGrids
d2057 1
a2057 1
            & HGrid=HGrids(HGridIndex), options=trim(options) // 'cr' )
d2280 1
a2280 1
       "$Id: OutputAndClose.f90,v 2.197 2016/02/29 19:51:22 pwagner Exp $"
d2290 3
@


2.197
log
@Usleep got from machine module instead of being an external
@
text
@d76 6
a81 5
    use chunkdivide_m, only: chunkdivideconfig, obstructions
    use destroycommand_m, only: destroycommand
    use directwrite_m, only: directdata_t, dump
    use dumpcommand_m, only: booleanfromemptyswath, booleanfromformula, &
      & dumpcommand, MLScase, MLSendselect, MLSselect, MLSselecting, skip
d83 5
a87 5
    use griddeddata, only: griddeddata_t
    use hessianmodule_1, only: hessian_t
    use hgrid, only: createhgridfromMLScfinfo, dealwithobstructions
    use hgridsdatabase, only: hgrid_t, &
      & addhgridtodatabase, dump
d96 1
a96 1
      & s_endselect, s_hgrid, s_isswathempty, s_l2gp, s_output, &
d119 2
a120 2
    use vectorsmodule, only: vector_t
    use writemetadata, only: l2pcf, writemetalog
d284 2
d541 3
a543 10
    use Init_tables_module, only: f_auraInstrument, &
      & f_date, f_dimlist, f_downsample, &
      & f_field, f_file, f_grid, f_HDFVersion, f_missingvalue, f_noPCFid, &
      & f_origin, f_quantitytype, f_sdname, f_deferReading, f_sum, f_swath, &
      & field_first, field_last, &
      & l_climatology, l_dao, l_geos5, l_geos5_7, l_gloria, &
      & l_merra, l_ncep, l_none, l_strat, l_surfaceheight, &
      & s_diff, s_dump, s_gridded, s_l2aux, s_l2gp, s_readGriddedData
    use L2GPdata, only: l2GPdata_t, &
      & Addl2GPtodatabase, readl2GPdata, dump
d545 1
a545 4
    use MLSFiles, only: filenotfound, &
      & HDFVersion_4, HDFVersion_5, wildCardHDFVersion, &
      & AddFileToDatabase, MLS_CloseFile, dump, getPCFromRef, initializeMLSFile, &
      & MLS_HDF_Version, MLS_inqswath, MLS_openfile, split_path_name
d547 1
a547 6
      & MLSPCF_l2apriori_start, MLSPCF_l2apriori_end, &
      & MLSPCF_l2clim_start, MLSPCF_l2clim_end, &
      & MLSPCF_l2dao_start, MLSPCF_l2dao_end, &
      & MLSPCF_l2geos5_start, MLSPCF_l2geos5_end, &
      & MLSPCF_l2ncep_start, MLSPCF_l2ncep_end, &
      & MLSPCF_surfaceheight_start, MLSPCF_surfaceheight_end
d550 2
a551 2
    use Tree, only: decorate, decoration, nsons, &
      &             sub_rosa, subtree, dump_tree_node, where
a567 1
    integer                         :: ReturnStatus
a568 1
    character(len=FileNameLen)      :: SDNAMESTRING ! actual literal sdName
d2280 1
a2280 1
       "$Id: OutputAndClose.f90,v 2.196 2015/11/19 23:57:23 pwagner Exp $"
d2290 3
@


2.196
log
@Now able to read from L2GP file
@
text
@d21 1
d2294 1
a2294 1
       "$Id: OutputAndClose.f90,v 2.195 2015/10/15 23:07:54 pwagner Exp $"
d2304 3
@


2.195
log
@If /repairGeolocations , repair also any with chunknumber = -999
@
text
@d94 1
a94 1
      & s_endselect, s_hgrid, s_isswathempty, s_output, &
d97 4
a100 3
    use L2AuxData, only: l2auxdata_t
    use L2GPData, only: l2gpdata_t, writemastersfileattributes
    use L2PC_m, only: outputhdf5l2pc
d298 4
d534 91
d2293 1
a2293 1
       "$Id: OutputAndClose.f90,v 2.194 2015/09/30 23:02:27 pwagner Exp $"
d2303 3
@


2.194
log
@Catenate can repair geoLocations
@
text
@a155 1
    type (HGrid_T), target :: newHGrid
d270 1
a270 1
          & Hessiandatabase=Hessians )
d284 2
a285 2
        newHGrid = CreateHGridFromMLSCFInfo ( name, key, filedatabase, l2gpDatabase, &
          & processingRange, allChunks )
d287 1
a287 1
        newHGridp => newHGrid 
a288 2
        noGapsHGIndex = AddHGridToDatabase ( hGrids, newHGridp )
        newHGridp => newHGrid  ! newHGrid takes due notice of obstructions
a293 1
        call decorate ( key, AddHGridToDatabase ( hGrids, newHGridp ) )
d1081 1
a1081 1
    if ( repairGeoLocations ) optionsString = trim(optionsString) // 'r'
d1881 1
d1965 5
a1969 3
          call outputnamedvalue( 'numswaths', numswaths )
          call outputnamedvalue( 'listSize', listSize )
          call outputnamedvalue( 'len_trim(outsdList)', len_trim(outsdList) )
d1974 1
a1974 1
            & HGrid=HGrids(HGridIndex), options=trim(options) // 'r' )
d2197 1
a2197 1
       "$Id: OutputAndClose.f90,v 2.193 2015/08/03 21:45:22 pwagner Exp $"
d2207 3
@


2.193
log
@Attempt to get dois for dgg and dgm like other prod names
@
text
@d233 2
a234 1
          call unsplitFiles ( DirectDatabase, FileDatabase, usingOldSubmit, debug )
d824 1
d865 2
d870 1
d1091 1
a1091 1
      call Dump( inputFile )
d1141 16
d1805 2
a1806 1
  subroutine unsplitFiles ( DirectDatabase, FileDatabase, usingSubmit, debug )
d1814 1
d1816 4
a1819 1
    use intrinsic, only: l_swath, l_hdf
d1831 1
d1840 1
d1842 1
d1844 4
a1847 3
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    logical, intent(in) :: debug
    logical, intent(in) :: USINGSUBMIT              ! Set if using the submit mechanism
d1852 3
d1857 1
d1859 2
d1867 1
a1867 1
    logical, parameter :: NEVERDUPSWATHNAMES = .true. ! Skip cp if dup
d1873 2
d1876 1
d1886 25
d1964 1
a1964 1
        if ( NEVERDUPSWATHNAMES ) then
d1968 3
d1975 1
a1975 1
            & options=options )
d1978 1
a1978 1
            & outputFile, create2=create2, &
d2198 1
a2198 1
       "$Id: OutputAndClose.f90,v 2.192 2015/06/19 20:54:56 pwagner Exp $"
d2208 3
@


2.192
log
@Avoid Copying text file if it does not exist
@
text
@d547 1
a547 1
    use MLSStringLists, only: list2array, numstringelements
d549 1
a549 1
    use writemetadata, only: populate_metadata_std, &
d603 4
a606 1
       l2metaData%doiIdentifier = '10.5067/AURA/MLS/DATA2006'
d713 4
a721 1
       l2metaData%doiIdentifier = '10.5067/AURA/MLS/DATA2007'
d2131 1
a2131 1
       "$Id: OutputAndClose.f90,v 2.191 2015/03/28 02:50:35 vsnyder Exp $"
d2141 3
@


2.191
log
@Paul added checking for Quantity type in DirectWrite
@
text
@d19 7
a25 7
  use hdf, only: dfacc_rdonly, dfacc_rdwr
  use highOutput, only: letsDebug, outputNamedValue
  use MLSFiles, only: hdfversion_5, addinitializemlsfile, dump, &
    & getmlsfilebyname, getmlsfilebytype, getpcfromref, &
    & mls_closefile, mls_exists, mls_inqswath, mls_openfile, &
    & mls_sfstart, mls_sfend, &
    & split_path_name, unsplitname
d28 4
a31 4
    & default_hdfversion_write, l2cfnode, &
    & specialdumpfile, skipdirectwrites, toolkit, MLSMessage, writefileattributes
  use MLSMessagemodule, only: MLSMsg_error, MLSMsg_info, MLSMsg_warning
  use string_table, only: display_string, get_string
d540 2
a541 2
    use mlscommon, only: l2metadata_t
    use l2gpdata, only: l2gpnamelen, maxswathnamesbufsize
d774 1
a774 1
    use TREE, only: Where_At => Where
d831 2
a832 2
      & h5_writeglobalattr, he5_writemlsfileattr, he5_writeglobalattr
    use readapriori, only: readaprioriattributes, writeaprioriattributes
d1080 1
d1088 2
a1089 1
        call CopyTextFileToHDF ( file_base, DEBUG, filedatabase, inputFile )
d1380 10
a1389 10
    use INIT_TABLES_MODULE, only: F_OVERLAPS, F_QUANTITIES
    use INTRINSIC, only: L_HDF
    use L2AUXDATA, only: L2AUXDATA_T, WRITEL2AUXDATA
    use L2GPDATA, only: L2GPNAMELEN
    use MLSCOMMON, only: MLSFILE_T, FILENAMELEN, L2METADATA_T
    use MLSPCF2, only: MLSPCF_L2DGM_START, MLSPCF_L2DGM_END
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use SDPTOOLKIT, only: PGS_S_SUCCESS
    use TOGGLES, only: SWITCHES
    use TREE, only: DECORATION, NSONS, SUBTREE
d1503 5
a1507 5
    use INTRINSIC, only: L_HDF
    use MLSCOMMON, only: MLSFILE_T, FILENAMELEN
    use MLSHDF5, only: SAVEASHDF5DS
    use MLSPCF2, only: MLSPCF_L2DGM_START, MLSPCF_L2DGM_END
    use OUTPUT_M, only: OUTPUT
d1710 4
a1713 4
    use HDFEOS5, only: HE5_SWCLOSE, HE5_SWOPEN, &
      & HE5F_ACC_RDWR, HE5T_NATIVE_INT, HE5T_NATIVE_DOUBLE
    use HGRIDSDATABASE, only: HGRID_T
    use MLSHDFEOS, only: HE5_EHWRGLATT, HSIZE, MLS_ISGLATT
d2125 1
a2125 1
       "$Id: OutputAndClose.f90,v 2.190 2015/02/18 00:29:03 pwagner Exp $"
d2135 3
@


2.190
log
@Debugging-type info shown only if debugging
@
text
@d538 1
a538 1
    use init_tables_module, only: l_l2dgg
d716 4
d723 1
a723 1
    call MLSMessage(MLSMSG_Error,ModuleName,&
d725 1
a725 1
      & // trim(filename))
d2123 1
a2123 1
       "$Id: OutputAndClose.f90,v 2.189 2014/11/04 01:23:50 pwagner Exp $"
d2133 3
@


2.189
log
@Worked around hdfeos bug in implementing /additional for swath file attributes
@
text
@d20 1
d137 2
a138 1
    logical, parameter :: DEBUG = .false.
d185 1
d564 2
a565 1
  logical, parameter :: DEBUG = .false.
d583 1
a804 1
    use highoutput, only: outputnamedvalue
d836 2
a837 1
    logical, parameter :: DEBUG = .false.
d874 1
d1185 2
a1186 1
    logical, parameter :: DEBUG = .false.
d1199 1
d1240 1
a1240 1
      call output( 'Updated glob attr to ' // trim(str), advance='yes' )
d1270 2
a1271 1
    logical, parameter :: DEBUG = .false.
d1286 1
d1341 1
a1341 1
        call output( 'Updated glob attr to ' // trim(str), advance='yes' )
d1344 1
a1344 1
        call output( 'Set glob attr to ' // trim(str), advance='yes' )
d1752 2
a1753 1
    logical, parameter :: DEBUG = .false.
d1758 1
a1779 1
    use highoutput, only: outputnamedvalue
d2119 1
a2119 1
       "$Id: OutputAndClose.f90,v 2.188 2014/10/13 18:10:01 pwagner Exp $"
d2129 3
@


2.188
log
@Copying a swath also copies AprioriAttributes
@
text
@d25 1
a25 1
  use MLSHDF5, only: MakeHDF5Attribute
d85 1
a85 1
    use init_tables_module, only: f_attrName, f_attrValue, &
d137 1
d215 1
d442 2
d458 1
a458 1
            & filedatabase )       
d462 1
a462 1
            & filedatabase )       
d466 1
a466 1
            & filedatabase )       
a539 1
    use MLSHDFeos, only: 
d1165 1
a1165 1
    & filedatabase )
a1167 1
    use init_tables_module, only: f_overlaps, f_quantities
d1169 1
a1169 3
    use l2auxdata, only: l2auxdata_t, writel2auxdata
    use l2gpdata, only: l2gpnamelen
    use MLSCommon, only: mlsfile_t, filenamelen, l2metadata_t
d1171 1
a1171 4
    use MLSStringlists, only: switchdetail
    use SDPToolkit, only: pgs_s_success
    use toggles, only: switches
    use tree, only: decoration, nsons, subtree
d1177 1
a1178 1
    integer :: DB_index
a1179 1
    integer :: FIELD_NO                 ! Index of assign vertex sons of Key
a1181 1
    integer :: GSON                     ! Son of Son -- an assign node
a1182 3
    integer :: IN_FIELD_NO              ! Index of sons of assign vertex
    integer :: Metadata_error
    integer :: Numquantitiesperfile     ! < MAXQUANTITIESPERFILE
a1185 2
    character(len=L2GPNameLen), dimension(MAXQUANTITIESPERFILE) :: &
      &                           QuantityNames  ! From "quantities" field
d1187 2
a1188 1
    integer :: SON                      ! Of Root -- spec_args or named node
a1189 1
    type(L2Metadata_T) :: l2metaData
d1223 11
a1233 1
    call h5gopen_f( outputFile%FileID%f_id, '/', outputFile%FileID%grp_id, returnStatus )
d1235 1
a1235 1
      & attrName, attrValue, .true. )
d1242 1
a1242 1
    & filedatabase )
d1245 1
a1245 2
    use hgridsdatabase, only: hgrid_t
    use init_tables_module, only: f_overlaps, f_quantities
d1247 4
a1250 7
    use l2gpdata, only: l2gpdata_t, l2gpnamelen, writel2gpdata
    use MLSCommon, only: mlsfile_t, filenamelen, l2metadata_t
    use MLSHDFEOS, only: MLS_EHWRGlatt
    use MLSStringlists, only: switchdetail
    use SDPToolkit, only: pgs_s_success
    use toggles, only: switches
    use tree, only: decoration, nsons, subtree
d1259 1
a1261 1
    integer :: DB_index
a1262 1
    integer :: FIELD_NO                 ! Index of assign vertex sons of Key
a1264 1
    integer :: GSON                     ! Son of Son -- an assign node
a1265 3
    integer :: IN_FIELD_NO              ! Index of sons of assign vertex
    integer :: Metadata_error
    integer :: Numquantitiesperfile     ! < MAXQUANTITIESPERFILE
a1268 2
    character(len=L2GPNameLen), dimension(MAXQUANTITIESPERFILE) :: &
      &                           QuantityNames  ! From "quantities" field
d1270 2
a1271 1
    integer :: SON                      ! Of Root -- spec_args or named node
d1273 2
a1274 1
    type(L2Metadata_T) :: l2metaData
d1306 40
d1348 7
d1356 2
a1357 2
     & attrName, MLS_CHARTYPE, 1, &
     &  attrValue )
d2108 1
a2108 1
       "$Id: OutputAndClose.f90,v 2.187 2014/10/07 00:06:47 pwagner Exp $"
d2118 3
@


2.187
log
@May now write added file attributes
@
text
@d821 1
d1122 4
d2070 1
a2070 1
       "$Id: OutputAndClose.f90,v 2.186 2014/09/05 01:16:18 vsnyder Exp $"
d2080 3
@


2.186
log
@Remove declarations of unused variables
@
text
@d12 1
a12 1
!=======================================================================================
d17 1
a17 1
!=======================================================================================
d19 12
a30 6
  use HDF, only: DFACC_RDONLY, DFACC_RDWR
  use MLSL2OPTIONS, only: CHECKPATHS, &
    & DEFAULT_HDFVERSION_WRITE, L2CFNODE, &
    & SPECIALDUMPFILE, SKIPDIRECTWRITES, TOOLKIT, MLSMESSAGE, WRITEFILEATTRIBUTES
  use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_INFO, MLSMSG_WARNING
  use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
d72 45
a116 47
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST, ALLOCATE_TEST
    use CHUNKS_M, only: MLSCHUNK_T, DUMP
    use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG, OBSTRUCTIONS
    use DESTROYCOMMAND_M, only: DESTROYCOMMAND
    use DIRECTWRITE_M, only: DIRECTDATA_T, DUMP
    use DUMPCOMMAND_M, only: BOOLEANFROMEMPTYSWATH, BOOLEANFROMFORMULA, &
      & DUMPCOMMAND, MLSCASE, MLSENDSELECT, MLSSELECT, MLSSELECTING, SKIP
    use EXPR_M, only: EXPR
    use GRIDDEDDATA, only: GRIDDEDDATA_T
    use HESSIANMODULE_1, only: HESSIAN_T
    use HGRID, only: CREATEHGRIDFROMMLSCFINFO, DEALWITHOBSTRUCTIONS
    use HGRIDSDATABASE, only: HGRID_T, &
      & ADDHGRIDTODATABASE, DUMP
    use INIT_TABLES_MODULE, only: F_DESTROY, F_DONTPACK, F_FILE, &
      & F_HDFVERSION, F_METADATAONLY, F_METANAME, &
      & F_MOLECULESECONDDERIVATIVES, F_OVERLAPS, F_PACKED, &
      & F_QUANTITIES, F_Time, F_TYPE, F_WRITECOUNTERMAF, &
      & FIELD_FIRST, FIELD_LAST, &
      & L_L2AUX, L_L2CF, L_L2DGG, L_L2GP, L_L2PC, &
      & S_BOOLEAN, S_CASE, S_CATENATE, S_COPY, &
      & S_DESTROY, S_DIFF, S_DUMP, S_DUMPBLOCKS, &
      & S_ENDSELECT, S_HGRID, S_ISSWATHEMPTY, &
      & S_OUTPUT, S_REEVALUATE, S_SELECT, S_SKIP, S_SLEEP, S_TIME
    use INTRINSIC, only: LIT_INDICES
    use L2AUXDATA, only: L2AUXDATA_T
    use L2GPDATA, only: L2GPDATA_T, WRITEMASTERSFILEATTRIBUTES
    use L2PC_M, only: OUTPUTHDF5L2PC
    use L2PARINFO, only: PARALLEL
    use MATRIXMODULE_1, only: MATRIX_DATABASE_T
    use MATRIXTOOLS, only: DUMPBLOCKS
    use MLSCOMMON, only: MLSFILE_T, TAI93_RANGE_T, FILENAMELEN
    use MLSFILES, only: &
      & DUMP
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES
    use MLSPCF2, only: MLSPCF_L2GP_END, &
      & MLSPCF_L2GP_START, MLSPCF_L2DGG_START, MLSPCF_L2DGG_END
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MLSSTRINGS, only: TRIM_SAFE
    use MORETREE, only: Get_Label_And_Spec, GET_SPEC_ID, GET_BOOLEAN
    use Next_Tree_Node_m, only: Next_Tree_Node, Next_Tree_Node_State
    use OUTPUT_M, only: BLANKS, OUTPUT, REVERTOUTPUT, SWITCHOUTPUT
    use TIME_M, only: TIME_NOW
    use TOGGLES, only: GEN, TOGGLE, SWITCHES
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATE, DECORATION, NSONS, SUBTREE, SUB_ROSA
    use VECTORSMODULE, only: VECTOR_T
    use WRITEMETADATA, only: L2PCF, WRITEMETALOG
d164 1
d427 41
d530 15
a544 16
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST, ALLOCATE_TEST
    use INIT_TABLES_MODULE, only: L_L2DGG
    use INTRINSIC, only: L_SWATH, L_HDF
    use MLSCOMMON, only: L2METADATA_T
    use L2GPDATA, only: L2GPNAMELEN, MAXSWATHNAMESBUFSIZE
    use MLSFILES, only: GETPCFROMREF, MLS_INQSWATH, SPLIT_PATH_NAME
    use MLSHDF5, only: GETALLHDF5DSNAMES
    use MLSHDFEOS, only: 
    use MLSPCF2, only: MLSPCF_L2DGM_END, MLSPCF_L2DGM_START, MLSPCF_L2GP_END, &
      & MLSPCF_L2GP_START, MLSPCF_L2DGG_START, MLSPCF_L2DGG_END, &
      & MLSPCF_MCF_L2DGM_START, MLSPCF_MCF_L2DGG_START, &
      & MLSPCF_MCF_L2GP_START
    use MLSSTRINGLISTS, only: LIST2ARRAY, NUMSTRINGELEMENTS
    use OUTPUT_M, only: OUTPUT
    use WRITEMETADATA, only: POPULATE_METADATA_STD, &
      & POPULATE_METADATA_OTH, GET_L2GP_MCF
d723 1
a723 1
    use OUTPUT_M, only: BLANKS, OUTPUT
d760 2
a761 2
    use LEXER_CORE, only: PRINT_SOURCE
    use OUTPUT_M, only: OUTPUT
d795 28
a822 30
    use EXPR_M, only: EXPR
    use HGRIDSDATABASE, only: HGRID_T, DUMP
    use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
    use INIT_TABLES_MODULE, only: F_CREATE, &
      & F_EXCLUDE, F_FILE, F_HDFVERSION, F_HGRID, &
      & F_IFANYCRASHEDCHUNKS, F_INPUTFILE, F_INPUTTYPE, &
      & F_OPTIONS, &
      & F_RENAME, F_REPAIRGEOLOCATIONS, &
      & F_SWATH, F_TOATTRIBUTE, F_TYPE, &
      & FIELD_FIRST, FIELD_LAST, &
      & L_L2AUX, L_L2CF, L_L2DGG, L_L2GP
    use INTRINSIC, only: L_ASCII, L_SWATH, L_HDF, LIT_INDICES
    use L2AUXDATA, only: CPL2AUXDATA
    use L2GPDATA, only: AVOIDUNLIMITEDDIMS, &
      & MAXSWATHNAMESBUFSIZE, CPL2GPDATA, CPL2GPDATATOATTRIBUTE
    use L2PARINFO, only: PARALLEL
    use MLSCOMMON, only: MLSFILE_T, FILENAMELEN, L2METADATA_T
    use MLSFILES, only: ADDINITIALIZEMLSFILE, DUMP, GETMLSFILEBYNAME, &
      & MLS_INQSWATH
    use MLSPCF2, only: MLSPCF_L2DGM_END, MLSPCF_L2DGM_START, MLSPCF_L2GP_END, &
      & MLSPCF_L2GP_START, MLSPCF_L2DGG_START, MLSPCF_L2DGG_END, &
      & MLSPCF_L2CLIM_START, MLSPCF_L2CLIM_END
    use MLSSTRINGLISTS, only: INTERSECTION, SWITCHDETAIL
    use MLSSTRINGS, only: LOWERCASE
    use MORETREE, only: GET_BOOLEAN
    use OUTPUT_M, only: OUTPUT
    use PCFHDR, only: GLOBALATTRIBUTES, &
      & H5_WRITEGLOBALATTR, HE5_WRITEMLSFILEATTR, HE5_WRITEGLOBALATTR
    use TOGGLES, only: SWITCHES
    use TREE, only: DECORATION, NSONS, SUBTREE, SUB_ROSA
d1155 162
a1325 2
    use MLSFILES, only: ADDINITIALIZEMLSFILE, GETMLSFILEBYNAME, &
      & GETPCFROMREF, SPLIT_PATH_NAME
a1445 4
    use MLSFILES, only: ADDINITIALIZEMLSFILE, DUMP, &
      & GETMLSFILEBYNAME, GETMLSFILEBYTYPE, GETPCFROMREF, &
      & MLS_CLOSEFILE, MLS_OPENFILE, &
      & SPLIT_PATH_NAME
d1530 9
a1538 11
    use HGRIDSDATABASE, only: HGRID_T
    use INIT_TABLES_MODULE, only: F_OVERLAPS, F_QUANTITIES
    use INTRINSIC, only: L_SWATH, LIT_INDICES
    use L2GPDATA, only: L2GPDATA_T, L2GPNAMELEN, WRITEL2GPDATA
    use MLSCOMMON, only: MLSFILE_T, FILENAMELEN, L2METADATA_T
    use MLSFILES, only: ADDINITIALIZEMLSFILE, GETMLSFILEBYNAME, &
      & GETPCFROMREF, SPLIT_PATH_NAME
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use SDPTOOLKIT, only: PGS_S_SUCCESS
    use TOGGLES, only: SWITCHES
    use TREE, only: DECORATION, NSONS, SUBTREE
a1689 1
    use MLSFILES, only: GETPCFROMREF
d1721 26
a1746 31
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST, ALLOCATE_TEST
    use CHUNKDIVIDE_M, only: OBSTRUCTIONS
    use DIRECTWRITE_M, only: DIRECTDATA_T, DUMP
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
    use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
    use INIT_TABLES_MODULE, only: L_L2AUX, L_L2DGG
    use INTRINSIC, only: L_SWATH, L_HDF
    use L2AUXDATA, only: CPL2AUXDATA, PHASENAMEATTRIBUTES
    use L2GPDATA, only: AVOIDUNLIMITEDDIMS, &
      & MAXSWATHNAMESBUFSIZE, CPL2GPDATA
    use L2PARINFO, only: PARALLEL
    use MLSCOMMON, only: MLSFILE_T, FILENAMELEN, L2METADATA_T
    use MLSFILES, only: HDFVERSION_5, &
      & ADDINITIALIZEMLSFILE, MLS_CloseFile, DUMP, &
      & GETMLSFILEBYNAME, GETPCFROMREF, &
      & MLS_EXISTS, MLS_INQSWATH, MLS_SFSTART, MLS_SFEND, &
      & MLS_OpenFile, UNSPLITNAME
    use MLSHDF5, only: CPHDF5GLATTRIBUTE, MAKEHDF5ATTRIBUTE, SAVEASHDF5DS
    use MLSPCF2, only: MLSPCF_L2DGM_END, MLSPCF_L2DGM_START, &
      & MLSPCF_L2DGG_START, MLSPCF_L2DGG_END
    use MLSFINDS, only: FINDFIRST, FINDNEXT
    use MLSSTRINGLISTS, only: ARRAY2LIST, SWITCHDETAIL
    use MLSSTRINGS, only: TRIM_SAFE
    use OUTPUT_M, only: BLANKS, OUTPUT
    use PCFHDR, only: GLOBALATTRIBUTES, &
      & H5_WRITEMLSFILEATTR, H5_WRITEGLOBALATTR, &
      & HE5_WRITEGLOBALATTR, HE5_WRITEMLSFILEATTR, &
      & WRITELEAPSECHDFEOSATTR, WRITELEAPSECHDF5DS, &
      & WRITEUTCPOLEHDFEOSATTR, WRITEUTCPOLEHDF5DS
    use READAPRIORI, only: READAPRIORIATTRIBUTES, WRITEAPRIORIATTRIBUTES
    use TOGGLES, only: SWITCHES
d2065 1
a2065 1
       "$Id: OutputAndClose.f90,v 2.185 2014/09/05 00:49:07 vsnyder Exp $"
d2075 3
@


2.185
log
@EmpiricalGeometry.f90
@
text
@d1874 1
a1874 1
       "$Id: OutputAndClose.f90,v 2.184 2014/04/14 17:39:48 pwagner Exp $"
d1884 3
@


2.184
log
@Fixed bugs in writing DOIs for dgg, dgm files; still hard-wired, though
@
text
@a497 1
    use PCFHDR, only: GLOBALATTRIBUTES, H5_WRITEGLOBALATTR
a514 1
  character (len=32) :: doiIdentier=' '
d1874 1
a1874 1
       "$Id: OutputAndClose.f90,v 2.183 2014/04/07 18:09:27 pwagner Exp $"
d1884 3
@


2.183
log
@Stop Writing MLSFile_T attributes by default; they confuse users
@
text
@d552 1
a552 1
       l2metaData%doiIdentifier = '10.5067/AURA/MLS/BOGUSDATA204'
d664 1
a664 1
       l2metaData%doiIdentifier = '10.5067/AURA/MLS/BOGUSDATA205'
d1079 1
a1079 1
      call he5_writeMLSFileAttr( outputFile )
d1090 1
a1090 1
        call MLSMessage(MLSMSG_Warning, ModuleName, &
d1552 2
a1553 1
      & H5_WRITEMLSFILEATTR, H5_WRITEGLOBALATTR, HE5_WRITEMLSFILEATTR, &
d1673 6
d1681 7
a1687 1
        ! (2) File level attributes
d1876 1
a1876 1
       "$Id: OutputAndClose.f90,v 2.182 2014/04/02 23:04:34 pwagner Exp $"
d1886 3
@


2.182
log
@Removed redundant open_ and close_MLSFile
@
text
@d22 1
a22 1
    & SPECIALDUMPFILE, SKIPDIRECTWRITES, TOOLKIT, MLSMESSAGE
d39 1
a39 1
  logical, parameter :: COPYFILEATTRIBUTES = .true.
d1055 1
a1055 1
          & andGlAttributes=copyFileAttributes, options=optionsString )
d1063 1
a1063 1
          & notUnlimited=avoidUnlimitedDims, andGlAttributes=copyFileAttributes, &
d1070 1
a1070 1
          & notUnlimited=avoidUnlimitedDims, andGlAttributes=copyFileAttributes, &
d1077 1
a1077 1
          & andGlAttributes=copyFileAttributes, options=optionsString )
d1651 1
a1651 1
            & andGlAttributes=copyFileAttributes, &
d1657 1
a1657 1
            & andGlAttributes=copyFileAttributes, &
d1675 1
a1675 1
        call he5_writeMLSFileAttr( outputFile )
d1808 2
a1809 1
      if ( madeFile ) call h5_writeMLSFileAttr ( outputFile )
d1863 1
a1863 1
       "$Id: OutputAndClose.f90,v 2.181 2014/03/28 00:01:10 pwagner Exp $"
d1873 3
@


2.181
log
@repaired some bugs in writing DOI, ProdLoc attributes
@
text
@d1540 1
a1540 1
      & ADDINITIALIZEMLSFILE, CLOSE_MLSFILE, DUMP, &
d1543 1
a1543 1
      & OPEN_MLSFILE, UNSPLITNAME
d1680 1
a1680 1
          call close_MLSFile ( inputFile )
d1689 1
a1689 1
        call open_MLSFile( outputFile )
d1693 1
a1693 1
        call close_MLSFile ( outputFile )
d1862 1
a1862 1
       "$Id: OutputAndClose.f90,v 2.180 2014/03/26 17:46:59 pwagner Exp $"
d1872 3
@


2.180
log
@Added ProductionLocation, identifier_product_DOI to attributes
@
text
@d664 1
d778 2
a779 1
    use PCFHDR, only: GLOBALATTRIBUTES, H5_WRITEGLOBALATTR, HE5_WRITEMLSFILEATTR
d1098 6
a1103 1
        call h5_writeGlobalAttr ( outputFile, skip_if_already_there=.false. )
d1105 1
a1105 1
        call output( 'Writing file level attributes to ' // &
d1107 3
a1109 1
        call he5_writeMLSFileAttr( outputFile )
d1531 1
d1551 2
a1552 1
    use PCFHDR, only: H5_WRITEMLSFILEATTR, HE5_WRITEMLSFILEATTR, &
d1796 1
d1799 6
d1862 1
a1862 1
       "$Id: OutputAndClose.f90,v 2.179 2014/02/28 01:06:44 vsnyder Exp $"
d1872 3
@


2.179
log
@Move units checking to type checker.  Check value of hdfVersion.  Look
for TIME field on SLEEP command, not CREATE field.
@
text
@d498 1
d516 1
d552 1
d558 2
a559 1
       call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf  )
d777 1
a777 1
    use PCFHDR, only: HE5_WRITEMLSFILEATTR
d1032 1
a1032 1
        call cpL2AUXData(inputFile, &
d1034 1
a1034 1
          & sdList=trim(sdList))
d1086 16
a1101 1
      & outputfile%hdfVersion, formattype, metadata_error )
d1844 1
a1844 1
       "$Id: OutputAndClose.f90,v 2.178 2014/01/11 01:44:18 vsnyder Exp $"
d1854 4
@


2.178
log
@Decruftification
@
text
@d79 4
a82 6
    use INIT_TABLES_MODULE, only: F_CREATE, F_DESTROY, F_DONTPACK, &
      & F_FILE, F_HDFVERSION, &
      & F_METADATAONLY, F_METANAME, F_MOLECULESECONDDERIVATIVES, &
      & F_OVERLAPS, F_PACKED, &
      & F_QUANTITIES, &
      & F_TYPE, F_WRITECOUNTERMAF, &
d89 1
a89 2
    use INTRINSIC, only: LIT_INDICES, &
      & PHYQ_DIMENSIONLESS, PHYQ_TIME
a160 1
    integer :: Type                     ! Type of value returned by EXPR
a228 5
          if ( nsons(gson) > 1 ) then
            fieldValue = decoration(subtree(2,gson)) ! The field's value
          else
            fieldValue = gson
          end if
d232 1
a232 1
          case ( f_create )
d234 1
a234 4
            call expr ( subtree(2,gson), units, value, type )
            if ( units(1) /= phyq_time ) &
              & call Announce_error ( gson, &
              & 'Wrong units for sleep time')
d313 1
a313 4
            call expr ( subtree(2,gson), units, value, type )
            if ( units(1) /= phyq_dimensionless ) &
              & call Announce_error ( gson, &
              & 'No units allowed for hdfVersion: just integer 4 or 5')
d315 2
d758 1
a758 2
    use INTRINSIC, only: L_ASCII, L_SWATH, L_HDF, LIT_INDICES, &
      & PHYQ_DIMENSIONLESS
a814 1
    integer :: Type                     ! Type of value returned by EXPR
d847 1
a847 4
        call expr ( subtree(2,gson), units, value, type )
        if ( units(1) /= phyq_dimensionless ) &
          & call Announce_error ( gson, &
          & 'No units allowed for hdfVersion: just integer 4 or 5')
d849 2
d1825 1
a1825 1
       "$Id: OutputAndClose.f90,v 2.177 2014/01/09 00:30:24 pwagner Exp $"
d1835 3
@


2.177
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d113 1
a113 1
    use TREE, only: DECORATE, DECORATION, NODE_ID, NSONS, SUBTREE, SUB_ROSA
a161 1
    integer :: SPEC_NO                  ! Index of son of Root
d441 1
a441 1
    end do  ! spec_no
d1841 1
a1841 1
       "$Id: OutputAndClose.f90,v 2.176 2013/12/12 02:11:26 vsnyder Exp $"
d1851 3
@


2.176
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d763 1
d787 1
a787 1
    use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d1842 1
a1842 1
       "$Id: OutputAndClose.f90,v 2.175 2013/10/15 23:52:55 pwagner Exp $"
d1852 3
@


2.175
log
@May copy quantity values to a file global attribute
@
text
@a72 1
    use EVALUATE_VARIABLE_M, only: EVALUATE_VARIABLE
d107 2
a108 1
    use MORETREE, only: GET_SPEC_ID, GET_BOOLEAN
a113 1
    use TREE_TYPES, only: N_NAMED, N_VARIABLE
d163 1
d207 3
a209 1
    do spec_no = 2, nsons(root)-1 ! Skip name at begin and end of section
d215 1
a215 12
      son = subtree(spec_no,root)
      if ( node_id(son) == n_variable ) then
        call evaluate_variable ( son )
    cycle
      end if
      if ( node_id(son) == n_named ) then ! Is spec labeled?
        key = subtree(2,son)
        name = sub_rosa(subtree(1,son))
      else ! Son is n_spec_args
        key = son
        name = 0
      end if
d437 2
a438 2
        call announce_error ( spec_no, &
          &  "Error--unknown spec_no: parser should have caught this")
d1841 1
a1841 1
       "$Id: OutputAndClose.f90,v 2.174 2013/10/09 23:42:13 vsnyder Exp $"
d1851 3
@


2.174
log
@Add Evaluate_Variable
@
text
@d73 1
a73 1
    use Evaluate_Variable_m, only: Evaluate_Variable
d114 1
a114 1
    use TREE_TYPES, only: N_NAMED, N_Variable
d275 4
a278 1
        if ( Skip(key) ) exit
d777 1
a777 1
      & F_SWATH, F_TYPE, &
d784 1
a784 1
      & MAXSWATHNAMESBUFSIZE, CPL2GPDATA
d837 1
d852 1
d897 2
d1065 5
a1069 1
      if ( got(f_exclude) .and. .not. repairGeoLocations ) then
d1850 1
a1850 1
       "$Id: OutputAndClose.f90,v 2.173 2013/09/24 23:47:22 vsnyder Exp $"
d1860 3
@


2.173
log
@Use Where instead of Source_Ref for messages
@
text
@d73 1
d114 1
a114 1
    use TREE_TYPES, only: N_NAMED
d214 4
d1839 1
a1839 1
       "$Id: OutputAndClose.f90,v 2.172 2013/09/06 21:10:45 pwagner Exp $"
d1849 3
@


2.172
log
@Move CopyQuantity into a separate subroutine
@
text
@d729 1
a729 1
    use TREE, only: SOURCE_REF
d743 1
a743 1
      call print_source ( source_ref(where) )
d1834 1
a1834 1
       "$Id: OutputAndClose.f90,v 2.171 2013/09/04 17:35:47 pwagner Exp $"
d1844 3
@


2.171
log
@Replaced '--cat' cmdline option; 'Catenate' now an Output section command
@
text
@d28 1
a28 1
  public :: Output_Close, add_metadata
d43 1
a43 1
  integer, parameter:: MAXQUANTITIESPERFILE=10000
d80 1
a80 2
      & F_EXCLUDE, F_FILE, F_HDFVERSION, F_HGRID, &
      & F_IFANYCRASHEDCHUNKS, F_INPUTFILE, F_INPUTTYPE, &
d82 3
a84 3
      & F_OPTIONS, F_OVERLAPS, F_PACKED, &
      & F_QUANTITIES, F_RENAME, F_REPAIRGEOLOCATIONS, &
      & F_SWATH, F_TYPE, F_WRITECOUNTERMAF, &
d91 1
a91 1
    use INTRINSIC, only: L_ASCII, L_SWATH, L_HDF, LIT_INDICES, &
d93 2
a94 3
    use L2AUXDATA, only: L2AUXDATA_T, CPL2AUXDATA
    use L2GPDATA, only: AVOIDUNLIMITEDDIMS, L2GPDATA_T, &
      & MAXSWATHNAMESBUFSIZE, WRITEMASTERSFILEATTRIBUTES, CPL2GPDATA
d99 1
a99 1
    use MLSCOMMON, only: MLSFILE_T, TAI93_RANGE_T, FILENAMELEN, L2METADATA_T
d101 1
a101 2
      & ADDINITIALIZEMLSFILE, DUMP, GETMLSFILEBYNAME, &
      & MLS_INQSWATH
d103 4
a106 5
    use MLSPCF2, only: MLSPCF_L2DGM_END, MLSPCF_L2DGM_START, MLSPCF_L2GP_END, &
      & MLSPCF_L2GP_START, MLSPCF_L2DGG_START, MLSPCF_L2DGG_END, &
      & MLSPCF_L2CLIM_START, MLSPCF_L2CLIM_END
    use MLSSTRINGLISTS, only: INTERSECTION, SWITCHDETAIL
    use MLSSTRINGS, only: LOWERCASE, TRIM_SAFE
d108 1
a108 2
    use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE, REVERTOUTPUT, SWITCHOUTPUT
    use PCFHDR, only: HE5_WRITEMLSFILEATTR
a128 1
    type (L2Metadata_T) :: l2metaData ! L2GP metadata 
d135 1
a135 1
    logical :: ASCII                    ! Is this l2pc ascii?
d137 1
a137 2
    logical :: Destroy                  ! matrices after outputting them
    logical :: create
a138 2
    logical, parameter :: DEBUG = .false.
    character (len=MAXSWATHNAMESBUFSIZE) :: EXCLUDE   ! From the exclude= field
a142 1
    integer :: FORMATTYPE               ! l_hdf or l_swath
a144 2
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: HGridIndex
d146 1
a146 4
    character (len=FileNameLen) :: INPUTFILE_BASE    ! From the inputfile= field
    character (len=FileNameLen) :: inputPhysicalFilename
    integer :: INPUT_TYPE              ! L_L2AUX, L_L2GP, L_PC, L_L2DGG
    type(MLSFile_T), pointer :: inputFile
a147 1
    integer :: listSize
a151 1
    logical :: newFile                  ! is this file new?
a155 2
    integer :: noSwaths
    character(len=8) :: optionsString   ! e.g. '-f'
a156 1
    type(MLSFile_T), pointer :: outputFile
a158 1
    character (len=FileNameLen) :: PhysicalFilename
a159 5
    integer :: RECLEN                   ! For file stuff
    character (len=MAXSWATHNAMESBUFSIZE) :: rename
    logical :: RepairGeoLocations
    character (len=MAXSWATHNAMESBUFSIZE) :: sdList
    character (len=MAXSWATHNAMESBUFSIZE) :: sdListThere
a160 1
    logical :: skipCopy
d172 1
a172 1
    logical :: WriteMetaDataOnly        ! Because it was a directWrite
a203 2
    inputPhysicalFilename = ' '
    PhysicalFilename = ' '
a207 2
      hdfVersion = DEFAULT_HDFVERSION_WRITE
      exclude = ''
a208 3
      sdList = '*' ! This is wildcard meaning 'every sd or swath'
      rename = ' ' ! This is a blank meaning 'Dont rename the swaths'
      optionsString = ' ' ! This is a blank meaning 'Dont rename the swaths'
a209 1
      writeMetaDataOnly = .false.
a210 4
      repairGeoLocations = .false.
      skipCopy = .false.
      create = .false.
      newFile = .false.
d279 1
a279 250
        do field_no = 2, nsons(key)       ! Skip the command name
          gson = subtree(field_no, key)   ! An assign node
          if ( nsons(gson) > 1 ) then
            fieldValue = decoration(subtree(2,gson)) ! The field's value
          else
            fieldValue = gson
          end if
          field_index = decoration(subtree(1,gson))
          got(field_index) = .true.
          select case ( field_index )   ! Field name
          case ( f_create )
            create = get_boolean ( gson )
          case ( f_exclude )
            call get_string ( sub_rosa(subtree(2,gson)), exclude, strip=.true. )
          case ( f_file )
            call get_string ( sub_rosa(subtree(2,gson)), file_base, strip=.true. )
            if ( DEBUG ) print *, 'file_base: ', trim(file_base)
          case ( f_hdfVersion )
            call expr ( subtree(2,gson), units, value, type )
            if ( units(1) /= phyq_dimensionless ) &
              & call Announce_error ( gson, &
              & 'No units allowed for hdfVersion: just integer 4 or 5')
            hdfVersion = value(1)
          case ( f_hgrid )
            HGridIndex = decoration(fieldValue)
            if ( DEBUG ) print *, 'HGridIndex: ', HGridIndex
          case ( f_ifAnyCrashedChunks )
            skipCopy = get_boolean ( gson ) .and. &
              & ( parallel%numFailedChunks == 0 )
          case ( f_inputfile )
            call get_string ( sub_rosa(subtree(2, gson)), inputfile_base, strip=.true. )
          case ( f_inputtype )
            input_type = decoration(subtree(2, gson))
          case ( f_options )
            call get_string ( sub_rosa(subtree(2, gson)), optionsString, strip=.true. )
            optionsString = lowerCase(optionsString)
            if (switchDetail( switches, 'pro') > 0 ) &
              & call outputNamedValue( 'options', trim(optionsString) )
          case ( f_rename )
            call get_string ( sub_rosa(subtree(2,gson)), rename, strip=.true. )
          case ( f_repairGeoLocations )
            repairGeoLocations = get_boolean ( gson )
          case ( f_swath )
            call get_string ( sub_rosa(subtree(2,gson)), sdList, strip=.true. )
          case ( f_type )
            output_type = decoration(subtree(2, gson))
            call get_string ( lit_indices(output_Type), outputTypeStr, strip=.true. )
          case default                  ! Parser should have caught this
          end select
        end do
        ! Make certain we have everything we need
        if ( ( got(f_repairGeoLocations) .and. .not. got(f_hgrid) ) ) &
          & call MLSMessage(MLSMSG_Error, ModuleName, &
          & "Cannot repair Geolocs w/o an HGrid to copy from")
        if ( .not. associated(HGrids) ) then
          if ( got(f_hgrid) ) &
          & call MLSMessage(MLSMSG_Error, ModuleName, &
          & "No HGrids defined yet")
        else
          if ( ( size(HGrids) < 1 .and. got(f_hgrid) ) ) &
          & call MLSMessage(MLSMSG_Error, ModuleName, &
          & "No HGrids defined yet")
        endif
        if ( ( got(f_swath) .and. got(f_exclude) ) ) &
          & call MLSMessage(MLSMSG_Error, ModuleName, &
          & "Cannot copy specifying both swaths and excludes")
        ! To skip or not to skip
        if ( skipCopy ) then
          call MLSMessage(MLSMSG_Info, ModuleName, &
          & "No crashed chunks so skipping this copy")
          cycle
        endif
        if ( .not. got(f_inputtype) ) input_type = output_type

        select case ( output_type )
        case ( l_l2aux ) ! --------------------- Copying l2aux files -----
          call returnFullFileName(file_base, PhysicalFilename, &
            & mlspcf_l2dgm_start, mlspcf_l2dgm_end)
          outputFile => GetMLSFileByName(filedatabase, PhysicalFilename)
          if ( .not. associated(outputFile) ) then
            newFile = .true.
            outputFile => AddInitializeMLSFile(filedatabase, &
              & content=outputTypeStr, &
              & name=PhysicalFilename, shortName=file_base, &
              & type=l_hdf, access=DFACC_RDWR, HDFVersion=hdfVersion, &
              & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
          endif
        case ( l_l2gp ) ! --------------------- Copying l2gp files -----
          call returnFullFileName(file_base, PhysicalFilename, &
            & mlspcf_l2gp_start, mlspcf_l2gp_end)
          outputFile => GetMLSFileByName(filedatabase, PhysicalFilename)
          if ( .not. associated(outputFile) ) then
            newFile = .true.
            outputFile => AddInitializeMLSFile(filedatabase, &
              & content=outputTypeStr, &
              & name=PhysicalFilename, shortName=file_base, &
              & type=l_swath, access=DFACC_RDWR, HDFVersion=hdfVersion, &
              & PCBottom=mlspcf_l2gp_start, PCTop=mlspcf_l2gp_end)
          endif
        case ( l_l2dgg ) ! --------------------- Copying l2dgg files -----
          call returnFullFileName(file_base, PhysicalFilename, &
            & mlspcf_l2dgg_start, mlspcf_l2dgg_end)
          outputFile => GetMLSFileByName(filedatabase, PhysicalFilename)
          if ( .not. associated(outputFile) ) then
            newFile = .true.
            outputFile => AddInitializeMLSFile(filedatabase, &
              & content=outputTypeStr, &
              & name=PhysicalFilename, shortName=file_base, &
              & type=l_swath, access=DFACC_RDWR, HDFVersion=hdfVersion, &
              & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
          endif
        case default
        end select

        if ( .not. associated(outputFile) ) then
          call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'Unable to Copy to ' // trim(PhysicalFilename) )
        endif
        if ( DEBUG ) call dump( outputFile, details=2 )

        select case ( input_type )
        case ( l_l2aux ) ! --------------------- Copying l2aux files -----
          call returnFullFileName(inputfile_base, inputPhysicalFilename, &
            & mlspcf_l2dgm_start, mlspcf_l2dgm_end)
          inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
          if ( .not. associated(inputFile) ) then
            call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
          endif
        case ( l_l2gp ) ! --------------------- Copying l2gp files -----
          call returnFullFileName(inputfile_base, inputPhysicalFilename, &
            & mlspcf_l2gp_start, mlspcf_l2gp_end)
          inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
          if ( .not. associated(inputFile) ) then
            call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
          endif
        case ( l_l2dgg ) ! --------------------- Copying l2dgg files -----
          call returnFullFileName(inputfile_base, inputPhysicalFilename, &
            & mlspcf_l2dgg_start, mlspcf_l2dgg_end)
          inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
          if ( .not. associated(inputFile) ) then
            call output( ' output base ', advance='no' )
            call output( trim(file_base), advance='yes' )
            call output( ' output file ', advance='no' )
            call output( trim(outputFile%name), advance='yes' )
            call output( ' input base ', advance='no' )
            call output( trim(inputfile_base), advance='yes' )
            call output( ' input file ', advance='no' )
            call output( '(not associated)', advance='yes' )
            call dump(filedatabase)
            call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
          endif
        case ( l_ascii, l_l2cf ) ! --------------------- Copying ascii files -----
          call returnFullFileName(inputfile_base, inputPhysicalFilename, &
            & mlspcf_l2clim_start, mlspcf_l2clim_end)
          inputFile => AddInitializeMLSFile( filedatabase, &
              & content=trim(inputfile_base), &
              & name=inputPhysicalFilename, shortName=inputfile_base, &
              & type=l_ascii, access=DFACC_RDWR, &
              & PCBottom=mlspcf_l2clim_start, PCTop=mlspcf_l2clim_end )
          if ( .not. associated(inputFile) ) then
            call MLSMessage(MLSMSG_Warning, ModuleName, &
              & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
            cycle
          endif
          if ( DEBUG ) call dump( inputFile )
        case default
        end select

        if ( DEBUG ) print *, 'inputPhysicalfileName: ', trim(inputPhysicalfileName)
        if ( DEBUG ) print *, 'outputPhysicalfileName: ', trim(PhysicalfileName)
        if ( DEBUG ) print *, 'repairGeoLocations: ', repairGeoLocations
        if ( DEBUG ) print *, 'create: ', create
        if ( DEBUG ) call display_string ( lit_indices(output_type), &
        &             strip=.true., advance='yes' )
        if ( DEBUG ) call display_string ( lit_indices(input_type), &
        &             strip=.true., advance='yes' )

        if ( CHECKPATHS ) cycle

        if ( DEBUG ) call dump( inputFile, details=2 )
        if ( repairGeoLocations ) optionsString = trim(optionsString) // 'r'
        select case ( output_type )
        case ( l_l2aux ) ! --------------------- Copying to l2aux files -----
          formattype = l_hdf
          ! Note that we haven't yet implemented repair stuff for l2aux
          ! So crashed chunks remain crashed chunks
          if ( input_type /= output_type ) then
            ! So far we only allow copying text files
            if ( .not. any( input_type == (/ l_ascii, l_l2cf /) ) ) then
              call MLSMessage(MLSMSG_Warning, ModuleName, &
              & 'Unable to copy to l2aux file file type for' // trim(inputPhysicalFilename) )
              cycle
            endif
            call CopyTextFileToHDF ( file_base, DEBUG, filedatabase, inputFile )
          else
            call cpL2AUXData(inputFile, &
              & outputFile, create2=create, &
              & sdList=trim(sdList))
          endif
        case ( l_l2gp, l_l2dgg ) ! --------------------- Copying l2gp files -----
          formattype = l_swath
          ! How to use swaths field? See definition of sdList
          ! Before trying to cp these swaths, make sure they're actually there
          noSwaths = mls_InqSwath ( inputFile%name, sdListThere, listSize, &
           & hdfVersion=inputFile%hdfVersion )
          sdList = Intersection( sdList, sdListThere )
          if ( sdList == ' ' ) cycle
          if ( got(f_exclude) .and. .not. repairGeoLocations ) then
            call cpL2GPData( l2metaData, inputfile, &
              & outputfile, create2=create, &
              & exclude=trim(exclude), &
              & notUnlimited=avoidUnlimitedDims, &
              & andGlAttributes=copyFileAttributes, options=optionsString )
          elseif ( .not. got(f_exclude) .and. repairGeoLocations ) then
            if ( DEBUG ) print *,' size(filedatabse) ', size(filedatabase)
            if ( DEBUG ) print *, 'input file: ', trim(inputPhysicalFilename)
            if ( DEBUG ) print *, 'output file: ', trim(PhysicalFilename)
            call cpL2GPData( l2metaData, inputfile, &
              & outputfile, create2=create, &
              & swathList=trim(sdList), rename=rename, &
              & notUnlimited=avoidUnlimitedDims, andGlAttributes=copyFileAttributes, &
              & HGrid=HGrids(HGridIndex), options=optionsString )
          elseif ( got(f_exclude) .and. repairGeoLocations ) then
            call cpL2GPData( l2metaData, inputfile, &
              & outputfile, create2=create, &
              & swathList=trim(sdList), rename=rename, &
              & exclude=trim(exclude), &
              & notUnlimited=avoidUnlimitedDims, andGlAttributes=copyFileAttributes, &
              & HGrid=HGrids(HGridIndex), options=optionsString )
          else
            call cpL2GPData( l2metaData, inputfile, &
              & outputfile, create2=create, &
              & swathList=trim(sdList), rename=rename, &
              & notUnlimited=avoidUnlimitedDims, &
              & andGlAttributes=copyFileAttributes, options=optionsString )
          endif
          call he5_writeMLSFileAttr( outputFile )
          if ( noGapsHGIndex > 0 ) &
            & call writeHGridComponents( trim(PhysicalFilename), &
            & HGrids(noGapsHGIndex) )
        case default
        end select
        
        if ( TOOLKIT .and. newFile ) then
          call add_metadata ( son, file_base, l2metaData, &
          & outputfile%hdfVersion, formattype, metadata_error )
        endif
d345 1
a345 1
          cycle
d352 1
a352 1
          if ( .not. TOOLKIT ) cycle
d357 1
a357 1
          if ( .not. TOOLKIT ) cycle
a365 2
          recLen = 0
          ascii = .false.
d403 1
a403 1
          if ( .not. TOOLKIT ) cycle
d759 336
d1834 1
a1834 1
       "$Id: OutputAndClose.f90,v 2.170 2013/08/30 02:45:45 vsnyder Exp $"
d1844 3
@


2.170
log
@Revise calls to trace_begin and trace_end
@
text
@d20 1
a20 1
  use MLSL2OPTIONS, only: CATENATESPLITS, CHECKPATHS, &
d88 2
a89 1
      & S_BOOLEAN, S_CASE, S_COPY, S_DESTROY, S_DIFF, S_DUMP, S_DUMPBLOCKS, &
d91 3
a93 2
      & S_OUTPUT, S_REEVALUATE, S_SELECT, S_SKIP, S_TIME
    use INTRINSIC, only: L_ASCII, L_SWATH, L_HDF, LIT_INDICES, PHYQ_DIMENSIONLESS
d142 1
a219 19
    ! Before looping over lines in l2cf, do any automatic tasks
    ! Catenate any split Direct Writes
    ! (Because copy commands may refer to DGG/DGM file)
    ! We assume hdfVersion is 5
    ! (Shouldn't you test and report an error if it's not?)
    if ( CATENATESPLITS .and. associated(DirectDatabase) &
      & .and. .not. SKIPDIRECTWRITES ) then
      call output( ' unsplitting dgg/dgm files', advance='yes' )
      call unsplitFiles ( DirectDatabase, FileDatabase, usingOldSubmit, debug )
    else
      call output( 'catenatesplits: ', advance='no' )
      call output( catenatesplits, advance='yes' )
      call output( 'associated(DirectDatabase): ', advance='no' )
      call output( associated(DirectDatabase), advance='yes' )
      call output( 'skipdirectwrites: ', advance='no' )
      call output( skipdirectwrites, advance='yes' )
    end if

    
d267 29
d1788 1
a1788 1
       "$Id: OutputAndClose.f90,v 2.169 2013/08/20 00:32:11 pwagner Exp $"
d1798 3
@


2.169
log
@Avoid crashing when no ForwardModel Names attribute missing
@
text
@d161 1
d163 1
a163 1
    character (len=32) :: meta_name    ! From the metaName= field
d199 2
a204 2
    if ( toggle(gen) ) call trace_begin ( "Output_Close", root)

d754 1
a754 1
    if ( toggle(gen) ) call trace_end ( "Output_Close")
d1775 1
a1775 1
       "$Id: OutputAndClose.f90,v 2.168 2013/08/12 23:49:41 pwagner Exp $"
d1785 3
@


2.168
log
@FindSomethings moved to MLSFinds module
@
text
@d1704 2
a1705 1
            & l2auxPhysicalFilename, 'ForwardModel Names' )
d1774 1
a1774 1
       "$Id: OutputAndClose.f90,v 2.167 2012/11/08 23:20:00 pwagner Exp $"
d1784 3
@


2.167
log
@Tries to avoid duplicating swath names during unsplit
@
text
@d1467 1
a1467 1
    use MLSSETS, only: FINDFIRST, FINDNEXT
d1773 1
a1773 1
       "$Id: OutputAndClose.f90,v 2.166 2012/08/16 17:51:43 pwagner Exp $"
d1783 3
@


2.166
log
@Exploit level 2-savvy MLSMessage
@
text
@d1494 1
d1500 1
d1563 16
a1578 5
        call cpL2GPData( l2metaData, inputFile, &
          & outputFile, create2=create2, &
          & notUnlimited=avoidUnlimitedDims, &
          & andGlAttributes=copyFileAttributes, &
          & options=options )
d1773 1
a1773 1
       "$Id: OutputAndClose.f90,v 2.165 2012/07/10 15:21:15 pwagner Exp $"
d1783 3
@


2.165
log
@Sets Status to 'crashed' for swaths with Fills in geolocations
@
text
@d20 4
a23 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, &
    & MLSMSG_ERROR, MLSMSG_INFO, MLSMSG_WARNING
a102 3
    use MLSL2OPTIONS, only: CATENATESPLITS, CHECKPATHS, &
      & DEFAULT_HDFVERSION_WRITE, &
      & SPECIALDUMPFILE, SKIPDIRECTWRITES, TOOLKIT
d274 1
a1043 1
    use MLSL2OPTIONS, only: CHECKPATHS, TOOLKIT
a1165 1
    use MLSL2OPTIONS, only: CHECKPATHS, TOOLKIT
a1260 1
    use MLSL2OPTIONS, only: CHECKPATHS, TOOLKIT
a1416 1
    use MLSL2OPTIONS, only: TOOLKIT
a1464 2
    use MLSL2OPTIONS, only: CHECKPATHS, &
      & SKIPDIRECTWRITES, TOOLKIT
d1760 1
a1760 1
       "$Id: OutputAndClose.f90,v 2.164 2012/07/05 23:54:21 pwagner Exp $"
d1770 3
@


2.164
log
@Copy command in Output may contain options field
@
text
@d1488 2
a1489 1
    logical :: create2
d1503 1
d1511 2
d1569 3
a1571 1
          & notUnlimited=avoidUnlimitedDims, andGlAttributes=copyFileAttributes )
d1766 1
a1766 1
       "$Id: OutputAndClose.f90,v 2.163 2012/05/14 18:33:34 pwagner Exp $"
d1776 3
@


2.163
log
@Fixed bug that dooms checkPaths test flights
@
text
@d80 2
a81 2
      & F_METADATAonly, F_METANAME, F_MOLECULESECONDDERIVATIVES, &
      & F_OVERLAPS, F_PACKED, &
d109 1
a109 1
    use MLSSTRINGS, only: TRIM_SAFE
d111 1
a111 1
    use OUTPUT_M, only: BLANKS, OUTPUT, REVERTOUTPUT, SWITCHOUTPUT
d171 1
d258 1
d337 5
d487 1
d518 2
a519 1
              & notUnlimited=avoidUnlimitedDims, andGlAttributes=copyFileAttributes )
d524 1
a524 1
            call cpL2GPData(l2metaData, inputfile, &
d528 1
a528 1
              & HGrid=HGrids(HGridIndex), options="-r")
d530 1
a530 1
            call cpL2GPData(l2metaData, inputfile, &
d535 1
a535 1
              & HGrid=HGrids(HGridIndex), options="-r")
d540 2
a541 1
              & notUnlimited=avoidUnlimitedDims, andGlAttributes=copyFileAttributes )
d1760 1
a1760 1
       "$Id: OutputAndClose.f90,v 2.162 2012/05/11 00:18:37 pwagner Exp $"
d1770 3
@


2.162
log
@Added isSwathEmpty to set Boolean in Output; we can Skip Copy of OH when THz is off
@
text
@d299 1
d1750 1
a1750 1
       "$Id: OutputAndClose.f90,v 2.161 2012/05/10 00:47:02 pwagner Exp $"
d1760 3
@


2.161
log
@Output section can have l2cf-control stuctures
@
text
@d69 1
a69 1
    use DumpCommand_m, only: BOOLEANFROMEMPTYGRID, BOOLEANFROMFORMULA, &
d87 2
a88 2
      & S_ENDSELECT, &
      & S_HGRID, S_OUTPUT, S_REEVALUATE, S_SELECT, S_SKIP, S_TIME
d298 2
d1749 1
a1749 1
       "$Id: OutputAndClose.f90,v 2.160 2012/03/14 16:57:03 pwagner Exp $"
d1759 3
@


2.160
log
@Fixed most recent goldbrick-busting bug
@
text
@d69 2
d86 3
a88 1
      & S_COPY, S_DESTROY, S_DUMPBLOCKS, S_HGRID, S_OUTPUT, S_TIME
d274 3
d278 20
d1747 1
a1747 1
       "$Id: OutputAndClose.f90,v 2.159 2012/03/12 17:28:22 pwagner Exp $"
d1757 3
@


2.159
log
@Fixed bug preventing us from copying apriori attributes successfully
@
text
@d1426 2
a1427 1
      & MLS_EXISTS, MLS_SFSTART, MLS_SFEND, OPEN_MLSFILE, UNSPLITNAME
d1457 1
d1459 1
d1501 4
d1720 1
a1720 1
       "$Id: OutputAndClose.f90,v 2.158 2012/02/24 21:18:01 pwagner Exp $"
d1730 3
@


2.158
log
@Correctly copy a priori attributes when unplitting files
@
text
@d1515 1
d1535 6
d1713 1
a1713 1
       "$Id: OutputAndClose.f90,v 2.157 2012/02/08 23:16:30 pwagner Exp $"
d1723 3
@


2.157
log
@Cant write utcpole, leapsec files w/o toolkit
@
text
@d1439 1
a1439 1
    use READAPRIORI, only: WRITEAPRIORIATTRIBUTES
d1534 1
d1706 1
a1706 1
       "$Id: OutputAndClose.f90,v 2.156 2011/11/30 21:34:23 pwagner Exp $"
d1716 3
@


2.156
log
@Fixed bug affecting files w/o pcfids when using pcf
@
text
@d1409 2
a1410 1
    ! Catenate any split Direct Writes
d1520 4
d1525 1
d1532 1
d1535 3
d1642 1
a1642 1
      ! Is metadata really needed for l2aux files?
d1658 4
a1661 2
        call WriteLeapSecHDF5DS (sdfId)
        call WriteutcPoleHDF5DS (sdfId)
d1705 1
a1705 1
       "$Id: OutputAndClose.f90,v 2.155 2011/07/15 00:14:28 pwagner Exp $"
d1715 3
@


2.155
log
@Wont crash on metadata errors now; was crashing goldbrick
@
text
@d434 1
d1395 1
a1395 1
    if ( TOOLKIT ) then
d1401 1
d1693 1
a1693 1
       "$Id: OutputAndClose.f90,v 2.154 2011/06/29 21:51:51 pwagner Exp $"
d1703 3
@


2.154
log
@Some cases may safely omit l1b files
@
text
@d688 1
a688 1
        error = max(error, metadata_error)
d1520 1
a1520 1
        if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1634 1
a1634 1
        if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1691 1
a1691 1
       "$Id: OutputAndClose.f90,v 2.153 2010/09/17 00:07:18 pwagner Exp $"
d1701 3
@


2.153
log
@Can constrain writing l2pc blocks by name
@
text
@d19 3
a21 3
  use Hdf, only: DFACC_RDONLY, DFACC_RDWR
  use MLSMessageModule, only: MLSMessage, &
    & MLSMSG_Error, MLSMSG_Info, MLSMSG_Warning
d64 11
a74 11
    use Allocate_Deallocate, only: Deallocate_Test, Allocate_test
    use Chunks_m, only: MLSChunk_T, dump
    use ChunkDivide_m, only: ChunkDivideConfig, OBSTRUCTIONS
    use DestroyCommand_m, only: DestroyCommand
    use DirectWrite_m, only: DirectData_T, Dump
    use Expr_M, only: Expr
    use GriddedData, only: griddedData_T
    use HessianModule_1, only: Hessian_T
    use HGrid, only: CREATEHGRIDFROMMLSCFINFO, DEALWITHOBSTRUCTIONS
    use HGridsDatabase, only: HGRID_T, &
      & ADDHGRIDTODATABASE, Dump
d78 1
a78 1
      & F_METADATAONLY, F_METANAME, F_MOLECULESECONDDERIVATIVES, &
d84 4
a87 4
      & S_COPY, S_Destroy, S_DumpBlocks, S_HGrid, S_OUTPUT, S_TIME
    use Intrinsic, only: l_ascii, l_swath, l_hdf, Lit_indices, PHYQ_Dimensionless
    use L2AUXData, only: L2AUXDATA_T, cpL2AUXData
    use L2GPData, only: AVOIDUNLIMITEDDIMS, L2GPDATA_T, &
d89 7
a95 7
    use L2PC_m, only: OUTPUTHDF5L2PC
    use L2ParInfo, only: parallel
    use MatrixModule_1, only: MATRIX_DATABASE_T
    use MatrixTools, only: DumpBlocks
    use MLSCommon, only: MLSFile_T, TAI93_Range_T, FileNameLen, L2Metadata_T
    use MLSFiles, only: &
      & AddInitializeMLSFile, Dump, GetMLSFileByName, &
d97 1
a97 1
    use MLSL2Options, only: CATENATESPLITS, CHECKPATHS, &
d99 2
a100 2
      & PENALTY_FOR_NO_METADATA, SPECIALDUMPFILE, SKIPDIRECTWRITES, TOOLKIT
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
d104 7
a110 7
    use MLSStringLists, only: Intersection, switchDetail
    use MLSStrings, only: trim_safe
    use MoreTree, only: Get_Spec_ID, GET_BOOLEAN
    use OUTPUT_M, only: blanks, OUTPUT, revertOutput, switchOutput
    use PCFHdr, only: HE5_WRITEMLSFILEATTR
    use Time_M, only: Time_Now
    use TOGGLES, only: GEN, TOGGLE, Switches
d114 2
a115 2
    use VectorsModule, only: Vector_T
    use WriteMetadata, only: L2PCF, WriteMetaLog
d688 1
a688 1
        error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
d734 1
a734 1
    use Allocate_Deallocate, only: Deallocate_Test, Allocate_test
d736 5
a740 5
    use Intrinsic, only: l_swath, l_hdf
    use MLSCommon, only: L2Metadata_T
    use L2GPData, only: L2GPNameLen, MAXSWATHNAMESBUFSIZE
    use MLSFiles, only: GetPCFromRef, MLS_INQSWATH, split_path_name
    use MLSHDF5, only: GetAllHDF5DSNames
d743 4
a746 4
      & MLSPCF_L2GP_START, mlspcf_l2dgg_start, mlspcf_l2dgg_end, &
      & Mlspcf_mcf_l2dgm_start, Mlspcf_mcf_l2dgg_start, &
      & Mlspcf_mcf_l2gp_start
    use MLSStringLists, only: List2Array, NumStringElements
d748 2
a749 2
    use WriteMetadata, only: Populate_metadata_std, &
      & Populate_metadata_oth, Get_l2gp_mcf
d925 1
a925 1
    use OUTPUT_M, only: blanks, OUTPUT
d999 11
a1009 11
    use Intrinsic, only: l_hdf
    use L2AUXData, only: L2AUXDATA_T, WriteL2AUXData
    use L2GPData, only: L2GPNameLen
    use MLSCommon, only: MLSFile_T, FileNameLen, L2Metadata_T
    use MLSL2Options, only: checkPaths, TOOLKIT
    use MLSFiles, only: AddInitializeMLSFile, GetMLSFileByName, &
      & GetPCFromRef, split_path_name
    use MLSPCF2, only: mlspcf_l2dgm_start, mlspcf_l2dgm_end
    use MLSStringLists, only: switchDetail
    use SDPToolkit, only: PGS_S_SUCCESS
    use TOGGLES, only: Switches
d1124 9
a1132 9
    use Intrinsic, only: l_hdf
    use MLSCommon, only: MLSFile_T, FileNameLen
    use MLSL2Options, only: checkPaths, TOOLKIT
    use MLSFiles, only: AddInitializeMLSFile, dump, &
      & GetMLSFileByName, GetMLSFileByType, GetPCFromRef, &
      & mls_closeFile, mls_openFile, &
      & split_path_name
    use MLSHDF5, only: SaveAsHDF5DS
    use MLSPCF2, only: mlspcf_l2dgm_start, mlspcf_l2dgm_end
d1215 1
a1215 1
    use HGridsDatabase, only: HGRID_T
d1217 9
a1225 9
    use Intrinsic, only: l_swath, Lit_indices
    use L2GPData, only: L2GPData_T, L2GPNameLen, WriteL2GPData
    use MLSCommon, only: MLSFile_T, FileNameLen, L2Metadata_T
    use MLSL2Options, only: checkPaths, TOOLKIT
    use MLSFiles, only: AddInitializeMLSFile, GetMLSFileByName, &
      & GetPCFromRef, split_path_name
    use MLSStringLists, only: switchDetail
    use SDPToolkit, only: PGS_S_SUCCESS
    use TOGGLES, only: Switches
d1339 1
a1339 1
    use HDFEOS5, only: he5_swclose, he5_swopen, &
d1341 1
a1341 1
    use HGridsDatabase, only: HGRID_T
d1378 2
a1379 2
    use MLSFiles, only: GetPCFromRef
    use MLSL2Options, only: TOOLKIT
d1409 4
a1412 4
    use Allocate_Deallocate, only: Deallocate_Test, Allocate_test
    use ChunkDivide_m, only: OBSTRUCTIONS
    use DirectWrite_m, only: DirectData_T, Dump
    use HDF5, only: h5gclose_f, h5gopen_f
d1414 12
a1425 12
    use Intrinsic, only: l_swath, l_hdf
    use L2AUXData, only: CPL2AUXDATA, PHASENAMEATTRIBUTES
    use L2GPData, only: AVOIDUNLIMITEDDIMS, &
      & MAXSWATHNAMESBUFSIZE, cpL2GPData
    use L2ParInfo, only: parallel
    use MLSCommon, only: MLSFile_T, FileNameLen, L2Metadata_T
    use MLSFiles, only: HDFVERSION_5, &
      & AddInitializeMLSFile, close_MLSFile, DUMP, &
      & GetMLSFileByName, GetPCFromRef, &
      & mls_exists, MLS_SFSTART, MLS_SFEND, open_MLSFile, unSplitName
    use MLSHDF5, only: CpHDF5GlAttribute, MakeHDF5Attribute, SaveAsHDF5DS
    use MLSL2Options, only: CHECKPATHS, &
d1428 10
a1437 10
      & mlspcf_l2dgg_start, mlspcf_l2dgg_end
    use MLSSets, only: FindFirst, FindNext
    use MLSStringLists, only: Array2List, switchDetail
    use MLSStrings, only: trim_safe
    use OUTPUT_M, only: blanks, OUTPUT
    use PCFHdr, only: h5_writeMLSFileAttr, he5_writeMLSFileAttr, &
      & WriteLeapSecHDFEOSAttr, WriteLeapSecHDF5DS, &
      & WriteutcPoleHDFEOSAttr, WriteutcPoleHDF5DS
    use readAPriori, only: writeAPrioriAttributes
    use TOGGLES, only: Switches
d1691 1
a1691 1
       "$Id: OutputAndClose.f90,v 2.152 2010/05/20 00:32:32 pwagner Exp $"
d1701 3
@


2.152
log
@Remove unused stuff
@
text
@d78 2
a79 1
      & F_METADATAONLY, F_METANAME, F_OVERLAPS, F_PACKED, &
d178 1
d597 2
a598 2
          if ( .not. canWriteL2PC ) call MLSMessage(MLSMSG_Error,ModuleName,&
            & "Cannot write l2pc files with multi chunk l2cf's")
d603 1
d614 2
d625 2
a626 2
          call OutputHDF5L2PC ( trim(file_base), matrices, hessians, quantitiesNode, packed, &
            & dontPack )
d1691 1
a1691 1
       "$Id: OutputAndClose.f90,v 2.151 2010/03/24 20:53:45 vsnyder Exp $"
d1701 3
@


2.151
log
@Add DumpBlocks to Output section
@
text
@d90 1
a90 2
    use MatrixModule_1, only: DestroyMatrix, GETFROMMATRIXDATABASE, &
      & MATRIX_DATABASE_T, MATRIX_T
d94 2
a95 2
      & AddInitializeMLSFile, close_MLSFile, Dump, GetMLSFileByName, &
      & MLS_INQSWATH, open_MLSFile
a135 1
    integer :: DB_index
a150 1
    integer :: IN_FIELD_NO              ! Index of sons of assign vertex
a186 1
    type (Matrix_T), pointer :: TMPMATRIX ! A pointer to a matrix to write into l2pc
d1686 1
a1686 1
       "$Id: OutputAndClose.f90,v 2.150 2010/02/25 18:18:31 pwagner Exp $"
d1696 3
@


2.150
log
@Conforms with changed l2pc structure
@
text
@d83 1
a83 1
      & S_COPY, S_Destroy, S_HGrid, S_OUTPUT, S_TIME
d92 1
d518 2
d1690 1
a1690 1
       "$Id: OutputAndClose.f90,v 2.149 2010/02/04 23:12:44 vsnyder Exp $"
d1700 3
@


2.149
log
@Remove USE or declaration for unreferenced names
@
text
@d49 1
a49 1
    & matrices, vectors, fileDataBase, GriddedDataBase, &
d71 1
d75 1
a75 1
    use INIT_TABLES_MODULE, only: F_ASCII, F_CREATE, F_DESTROY, F_DONTPACK, &
d88 1
a88 1
    use L2PC_m, only: WRITEONEL2PC, OUTPUTHDF5L2PC
d121 1
a604 2
            case ( f_ascii )
              ascii = get_boolean ( gson )
d621 2
a622 31
          ! Open file
          if ( ascii ) then
            ! ASCII l2pc file
            call returnFullFileName( file_base, PhysicalFilename, &
              & 0, 0 )
            outputFile => GetMLSFileByName(filedatabase, PhysicalFilename)
            if ( .not. associated(outputFile) ) then
              outputFile => AddInitializeMLSFile( filedatabase, &
                & content='l2pc', &
                & name=PhysicalFilename, shortName=file_base, &
                & type=l_ascii, access=DFACC_RDWR )
              call open_MLSFile( outputFile )
            endif

            do in_field_no = 2, nsons(quantitiesNode)
              db_index = decoration(decoration(subtree(in_field_no, quantitiesNode )))
              call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
              call writeOneL2PC ( tmpMatrix, outputFile%FileID%f_id, packed )
              if ( destroy ) call DestroyMatrix ( matrices(db_index) )
            end do ! in_field_no = 2, nsons(gson)
            call close_MLSFile( outputFile )

          else
            ! For the moment call a routine
            call OutputHDF5L2PC ( trim(file_base), matrices, quantitiesNode, packed, &
              & dontPack )

            do in_field_no = 2, nsons(quantitiesNode)
              db_index = decoration(decoration(subtree(in_field_no, quantitiesNode )))
              if ( destroy ) call DestroyMatrix ( matrices(db_index) )
            end do ! in_field_no = 2, nsons(gson)
d624 3
a626 1
          end if
d1687 1
a1687 1
       "$Id: OutputAndClose.f90,v 2.148 2010/01/08 00:11:37 pwagner Exp $"
d1697 3
@


2.148
log
@Added ability to write MLSFile_T fields as attributes
@
text
@d19 1
a19 2
  use Hdf, only: DFACC_CREATE, DFACC_RDONLY, DFACC_RDWR
  use MLSCommon, only: L2Metadata_T
d1156 1
a1156 1
    use OUTPUT_M, only: blanks, OUTPUT
d1714 1
a1714 1
       "$Id: OutputAndClose.f90,v 2.147 2009/11/10 00:44:03 pwagner Exp $"
d1724 3
@


2.147
log
@Copies MiscNotes while unsplitting l2aux files, too
@
text
@d107 1
d502 1
d1457 2
a1458 1
    use PCFHdr, only: WriteLeapSecHDFEOSAttr, WriteLeapSecHDF5DS, &
d1548 1
d1663 1
d1715 1
a1715 1
       "$Id: OutputAndClose.f90,v 2.146 2009/10/01 19:53:53 vsnyder Exp $"
d1725 3
@


2.146
log
@Use strip=.true in get_string instead of unquote later
@
text
@d669 2
a670 2
            call output('l2gp type number: ', advance='no')
            call output(l_l2gp, advance='yes')
d672 2
a673 2
            call output('l2aux type number: ', advance='no')
            call output(l_l2aux, advance='yes')
d675 2
a676 2
            call output('l2dgg type number: ', advance='no')
            call output(l_l2dgg, advance='yes')
d678 2
a679 2
            call output('output type number: ', advance='no')
            call output(output_type, advance='yes')
d681 2
a682 2
            call output('file_base: ', advance='no')
            call output(trim(file_base), advance='yes')
d1545 3
a1547 12
       call writeAPrioriAttributes( outputFile )
       ! call writeAPrioriAttributes(trim(l2gpPhysicalFilename), HDFVERSION_5)
       ! outputFile => AddInitializeMLSFile(filedatabase, &
        ! & content='l2dgg', &
        ! & name=l2gpPhysicalFilename, shortName='DGG', &
        ! & type=l_swath, access=DFACC_CREATE, HDFVersion=HDFVERSION_5, &
        ! & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
        ! FileID = mls_io_gen_openF( l_swath, .TRUE., ReturnStatus, &
        ! & record_length, DFACC_RDWR, FileName=l2gpPhysicalFilename, &
        ! & hdfVersion=HDFVERSION_5 )
        !call dump ( outputFile, details = 1 )
        call output ( 'About to open ' // trim(l2gpPhysicalFilename) , advance='yes' )
a1551 2
        ! ReturnStatus = mls_io_gen_closeF( l_swath, FileID, &
        ! & hdfVersion=HDFVERSION_5, debugOption=.false. )
a1605 2
          ! print *, 'About to try to convert array2List'
          ! call dump(DirectDatabase(DB_index))
a1606 1
          ! print *, 'result: ', trim(sdList)
a1640 1
          ! print *, 'About to CpHDF5GlAttribute from ' // trim(DirectDatabase(DB_index)%fileName)
d1645 2
d1710 1
a1710 1
       "$Id: OutputAndClose.f90,v 2.145 2009/09/29 23:37:32 pwagner Exp $"
d1720 3
@


2.145
log
@Changes needed by 64-bit build
@
text
@d103 1
a103 1
    use MLSStringLists, only: Intersection, switchDetail, unquote
d284 1
a284 2
            call get_string ( sub_rosa(subtree(2,gson)), exclude )
            exclude = unquote(exclude) ! Parser includes quotes
d286 1
a286 2
            call get_string ( sub_rosa(subtree(2,gson)), file_base )
            file_base = unquote(file_base) ! Parser includes quotes
d301 1
a301 2
            call get_string ( sub_rosa(subtree(2, gson)), inputfile_base )
            inputfile_base = unquote(inputfile_base) ! Parser includes quotes
d305 1
a305 2
            call get_string ( sub_rosa(subtree(2,gson)), rename )
            rename = unquote(rename) ! Parser includes quotes
d309 1
a309 2
            call get_string ( sub_rosa(subtree(2,gson)), sdList )
            sdList = unquote(sdList) ! Parser includes quotes
d545 1
a545 2
            call get_string ( sub_rosa(subtree(2,gson)), file_base )
            file_base = file_base(2:LEN_TRIM(file_base)-1) ! Parser includes quotes
d547 1
a547 2
            call get_string ( sub_rosa(subtree(2,gson)), meta_name )
            meta_name = meta_name(2:LEN_TRIM(meta_name)-1) ! Parser includes quotes
d560 1
a560 1
            hdfVersion = value(1)
d1723 1
a1723 1
       "$Id: OutputAndClose.f90,v 2.144 2009/08/26 17:18:42 pwagner Exp $"
d1733 3
@


2.144
log
@Master copies file attributes from slaves instead of writing its own
@
text
@d1371 1
a1371 1
    use MLSHDFEOS, only: he5_EHwrglatt, MLS_isGlAtt
d1384 1
a1384 1
      status = he5_EHwrglatt(fileID, 'HGrid_noProfs', HE5T_NATIVE_INT, 1, &
d1386 1
a1386 1
      status = he5_EHwrglatt(fileID, 'HGrid_phi', HE5T_NATIVE_DOUBLE, h, &
d1388 1
a1388 1
      status = he5_EHwrglatt(fileID, 'HGrid_geodLat', HE5T_NATIVE_DOUBLE, h, &
d1390 1
a1390 1
      status = he5_EHwrglatt(fileID, 'HGrid_lon', HE5T_NATIVE_DOUBLE, h, &
d1392 1
a1392 1
      status = he5_EHwrglatt(fileID, 'HGrid_time', HE5T_NATIVE_DOUBLE, h, &
d1394 1
a1394 1
      status = he5_EHwrglatt(fileID, 'HGrid_solarTime', HE5T_NATIVE_DOUBLE, h, &
d1396 1
a1396 1
      status = he5_EHwrglatt(fileID, 'HGrid_solarZenith', HE5T_NATIVE_DOUBLE, h, &
d1398 1
a1398 1
      status = he5_EHwrglatt(fileID, 'HGrid_losAngle', HE5T_NATIVE_DOUBLE, h, &
d1730 1
a1730 1
       "$Id: OutputAndClose.f90,v 2.143 2009/07/01 20:37:30 pwagner Exp $"
d1740 3
@


2.143
log
@Avoid adding metadata to a file more than once
@
text
@d38 1
d86 2
a87 2
    use L2GPData, only: AVOIDUNLIMITEDDIMS, L2GPData_T, &
      & MAXSWATHNAMESBUFSIZE, cpL2GPData
d209 1
d483 1
a483 1
              & notUnlimited=avoidUnlimitedDims )
d491 1
a491 1
              & notUnlimited=avoidUnlimitedDims, &
d498 1
a498 1
              & notUnlimited=avoidUnlimitedDims, &
d504 1
a504 1
              & notUnlimited=avoidUnlimitedDims )
d1542 1
a1542 1
          & notUnlimited=avoidUnlimitedDims )
d1730 1
a1730 1
       "$Id: OutputAndClose.f90,v 2.142 2009/06/26 00:17:14 pwagner Exp $"
d1740 3
@


2.142
log
@May now copy ascii file to DGM calling input file type 'ascii' insstead of 'l2cf'
@
text
@d159 1
d256 1
d349 1
d361 1
d373 1
d387 1
d450 1
d510 1
a510 1
        if ( TOOLKIT ) then
d1154 1
a1154 1
    use MLSFiles, only: AddInitializeMLSFile, &
d1160 1
d1223 7
d1728 1
a1728 1
       "$Id: OutputAndClose.f90,v 2.141 2009/06/23 18:45:16 pwagner Exp $"
d1738 3
@


2.141
log
@May copy arbitrary text file into DGM file
@
text
@d31 1
a31 1
       "$RCSfile: $"
d417 1
a417 1
        case ( l_l2cf ) ! --------------------- Copying l2gp files -----
a419 1
          ! inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
d421 1
a421 1
              & content='mlsl2.ident', &
d426 1
a426 1
            call MLSMessage(MLSMSG_Error, ModuleName, &
d428 1
d445 1
a445 1
        case ( l_l2aux ) ! --------------------- Copying l2aux files -----
d450 6
a455 1
            ! So far we only allow copying l2cf types, i.e. text files
d1713 1
a1713 1
       "$Id: read_apriori.f90 is it here $"
d1723 3
@


2.140
log
@Add NRT Lat and Lon bounding to metadata
@
text
@d31 1
a31 1
       "$RCSfile: OutputAndClose.f90,v $"
d100 2
a101 1
      & MLSPCF_L2GP_START, mlspcf_l2dgg_start, mlspcf_l2dgg_end
d417 13
d449 8
a456 3
          call cpL2AUXData(inputFile, &
            & outputFile, create2=create, &
            & sdList=trim(sdList))
d566 1
a566 1
          call OutputL2CF ( file_base, DEBUG, filedatabase )
d1135 4
a1138 3
  ! ---------------------------------------------  OutputL2CF  -----
  subroutine OutputL2CF ( fileName, DEBUG, filedatabase )
    ! Do the work of outputting the l2cf to a named file
d1152 1
d1166 5
a1170 1
    MLSL2CF => GetMLSFileByType(filedatabase, content='l2cf')
d1173 1
a1173 1
        & 'Unable to write dataset--no entry in filedatabase for l2cf' )
d1179 1
a1179 1
        & 'Unable to write dataset--stdin has been used for l2cf' )
d1199 1
a1199 1
      ! Open the HDF file and write l2cf
d1211 2
a1212 2
      call SaveAsHDF5DS ( MLSL2CF%name, outputFile%FileID%f_id, 'l2cf', &
        & maxLineLen=4096 )
d1215 1
a1215 1
  end subroutine OutputL2CF
d1705 1
a1706 1
!---------------------------- RCS Ident Info -------------------------------
d1708 2
a1709 3
       "$Id: OutputAndClose.f90,v 2.139 2009/04/27 20:45:18 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1711 1
a1711 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1713 1
d1718 3
@


2.139
log
@Fixed bug causing crashes in add_metadata when debugging
@
text
@d20 1
d91 1
a91 1
    use MLSCommon, only: MLSFile_T, TAI93_Range_T, FileNameLen
d124 2
d447 1
a447 1
            call cpL2GPData( inputfile, &
d455 1
a455 1
            call cpL2GPData(inputfile, &
d461 1
a461 1
            call cpL2GPData(inputfile, &
d468 1
a468 1
            call cpL2GPData( inputfile, &
d480 1
a480 1
          call add_metadata ( son, file_base, &
d726 1
a726 1
  subroutine add_metadata ( node, fileName, &
d733 1
d749 1
d841 1
a841 1
         & (FileHandle, l2gp_mcf, QuantityNames(1), &
d856 1
a856 1
         & numquantitiesperfile, QuantityNames, &
d903 1
a903 1
       & numquantitiesperfile, QuantityNames,&
d998 1
a998 1
    use MLSCommon, only: MLSFile_T, FileNameLen
d1032 2
d1107 1
a1107 1
      call add_metadata ( son, fileName, &
d1201 1
a1201 1
    use MLSCommon, only: MLSFile_T, FileNameLen
d1237 2
d1309 1
a1309 1
      call add_metadata ( son, fileName, &
d1401 1
a1401 1
    use MLSCommon, only: MLSFile_T, FileNameLen
d1441 2
d1493 1
a1493 1
        call cpL2GPData( inputFile, &
d1499 1
a1499 1
        call add_metadata ( 0, trim(l2gpPhysicalFilename), &
d1625 1
a1625 1
        call add_metadata ( 0, trim(l2auxPhysicalFilename), &
d1683 1
a1683 1
       "$Id: OutputAndClose.f90,v 2.138 2009/04/01 23:32:32 pwagner Exp $"
d1693 3
@


2.138
log
@Writes obstructions db to l2aux file
@
text
@a866 13
     else if ( DEBUG ) then
       call output ( 'preparing to populate metadata_oth', advance='yes' )
       call output ( 'l2auxFileHandle: ', advance='no' )
       call output ( FileHandle , advance='no' )
       call output ( '   l2aux_mcf: ', advance='no' )
       call output ( l2aux_mcf , advance='no' )
       call output ( '   number of quantities: ', advance='no' )
       call output ( numquantitiesperfile , advance='yes' )
       do field_no=1, numquantitiesperfile
         call output ( field_no , advance='no' )
         call output ( '       ', advance='no' )
         call output ( trim(QuantityNames(field_no)) , advance='yes' )
       end do
d880 16
d1672 1
a1672 1
       "$Id: OutputAndClose.f90,v 2.137 2008/12/02 23:13:15 pwagner Exp $"
d1682 3
@


2.137
log
@mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
@
text
@a448 1
            ! call dump(HGrids(HGridIndex))
a450 1
            ! call dump(inputfile)
a451 1
            ! call dump(outputfile)
a456 1
              ! & HGrid=HGrids(HGridIndex), options="-rv")
a463 1
              ! & HGrid=HGrids(HGridIndex), options="-rv")
a469 4
          ! if ( noGapsHGIndex > 0 ) newHGridp => HGrids(noGapsHGIndex)
          ! print *, 'Before writing attributes'
          ! print *, 'noGapsHGIndex: ', noGapsHGIndex
          ! call dump(hGrids(noGapsHGIndex))
a483 2
        ! call announce_error ( spec_no, &
        !   &  "Error--HGrid not implemented yet")
a491 3
        ! print *, 'On first adding to db'
        ! print *, 'noGapsHGIndex: ', noGapsHGIndex
        ! call dump(hGrids(noGapsHGIndex))
a492 1
        ! noGapsHGrid = newHGrid
a498 6
        ! print *, 'After adding second Hgrid to db'
        ! print *, 'noGapsHGIndex: ', noGapsHGIndex
        ! call dump(hGrids(noGapsHGIndex))
        ! print *, 'HGrid added; size now: ', size(hGrids)
        ! print *, 'After dealing with obstructions'
        ! call dump(newHGridp)
a531 1
          ! case ( f_quantities )
a593 5
     !  l2pcUnit = mls_io_gen_openf ( l_ascii, .true., error, &
     !    & recLen, PGSd_IO_Gen_WSeqFrm, trim(file_base), 0,0,0, &
     !    & unknown=.true. )
     !  if ( error /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName,&
     !    & 'Failed to open l2pc file:'//trim(file_base))
a612 7
            ! error = mls_io_gen_closef ( l_ascii, l2pcUnit)
            ! if ( error /= 0 ) then
            !  call MLSMessage(MLSMSG_Error,ModuleName,&
            !    & 'Failed to close l2pc file:'//trim(file_base))
            ! else if ( switchDetail(switches, 'pro') > -1 ) then
            !   call announce_success(file_base, 'l2pc', 0)
            ! end if
a685 2
    ! print *, 'Was About to destroy HGridDataBase (but we granted it clemency)'
    ! call destroyHGridDatabase ( hGrids )
d1379 2
d1394 1
a1394 1
    use MLSHDF5, only: CpHDF5GlAttribute, MakeHDF5Attribute
d1423 2
d1646 14
d1669 1
a1669 1
       "$Id: OutputAndClose.f90,v 2.136 2008/09/19 23:55:50 pwagner Exp $"
d1679 3
@


2.136
log
@May now Destroy GriddedData
@
text
@d19 1
a19 1
  use Hdf, only: DFACC_RDONLY, DFACC_RDWR
d92 2
a93 2
      & AddInitializeMLSFile, Dump, GetMLSFileByName, &
      & MLS_INQSWATH, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF
a103 1
    use SDPToolkit, only: PGSD_IO_GEN_WSEQFRM
a150 1
    integer :: L2PCUNIT
d416 2
a417 2
        if ( DEBUG ) print *, 'inputPhysicalfileName: ', inputPhysicalfileName
        if ( DEBUG ) print *, 'outputPhysicalfileName: ', PhysicalfileName
d616 15
a630 4
            l2pcUnit = mls_io_gen_openf ( l_ascii, .true., error,&
              & recLen, PGSd_IO_Gen_WSeqFrm, trim(file_base), 0,0,0, unknown=.true. )
            if ( error /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName,&
              & 'Failed to open l2pc file:'//trim(file_base))
d635 1
a635 1
              call writeOneL2PC ( tmpMatrix, l2pcUnit, packed )
d638 1
d640 7
a646 7
            error = mls_io_gen_closef ( l_ascii, l2pcUnit)
            if ( error /= 0 ) then
              call MLSMessage(MLSMSG_Error,ModuleName,&
                & 'Failed to close l2pc file:'//trim(file_base))
            else if ( switchDetail(switches, 'pro') > -1 ) then
              call announce_success(file_base, 'l2pc', 0)
            end if
d1423 1
a1423 1
    use MLSCommon, only: I4, MLSFile_T, FileNameLen
d1425 3
a1427 3
      & AddInitializeMLSFile, GetMLSFileByName, GetPCFromRef, mls_exists, &
      & MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, MLS_SFSTART, MLS_SFEND, &
      & unSplitName
a1457 1
    integer :: Record_Length
d1459 1
a1459 1
    integer(i4) :: SDFID                ! File handle
d1523 19
a1541 13
       call writeAPrioriAttributes(trim(l2gpPhysicalFilename), HDFVERSION_5)
       outputFile => AddInitializeMLSFile(filedatabase, &
         & content='l2dgg', &
         & name=l2gpPhysicalFilename, shortName='DGG', &
         & type=l_swath, access=DFACC_RDWR, HDFVersion=HDFVERSION_5, &
         & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
        FileID = mls_io_gen_openF( l_swath, .TRUE., ReturnStatus, &
        & record_length, DFACC_RDWR, FileName=l2gpPhysicalFilename, &
        & hdfVersion=HDFVERSION_5 )
        call WriteLeapSecHDFEOSAttr (fileID)
        if ( .not. DGGFILEISHYBRID ) call WriteutcPoleHDFEOSAttr (fileID)
        ReturnStatus = mls_io_gen_closeF( l_swath, FileID, &
        & hdfVersion=HDFVERSION_5, debugOption=.false. )
d1687 1
a1687 1
       "$Id: OutputAndClose.f90,v 2.135 2008/07/09 16:38:24 pwagner Exp $"
d1697 3
@


2.135
log
@ReadStatus optional arg eliminated
@
text
@d48 2
a49 1
    & matrices, vectors, fileDataBase, chunks, processingRange, canWriteL2PC )
d69 1
d122 1
d493 1
a493 1
        call destroyCommand ( key, matrices, vectors )
d1672 1
a1672 1
       "$Id: OutputAndClose.f90,v 2.134 2008/04/25 22:55:29 pwagner Exp $"
d1676 1
d1682 3
@


2.134
log
@Exploits ability of SaveAsHDF5DS to take textfile as arg
@
text
@d443 1
a443 1
            call cpL2GPData(inputfile, &
d446 1
a446 1
              & notUnlimited=avoidUnlimitedDims, ReadStatus=.true.)
d457 1
a457 1
              & notUnlimited=avoidUnlimitedDims, ReadStatus=.true., &
d465 1
a465 1
              & notUnlimited=avoidUnlimitedDims, ReadStatus=.true., &
d469 1
a469 1
            call cpL2GPData(inputfile, &
d472 1
a472 1
              & notUnlimited=avoidUnlimitedDims, ReadStatus=.true.)
d1499 1
a1499 1
        call cpL2GPData(inputFile, &
d1501 1
a1501 1
          & notUnlimited=avoidUnlimitedDims, ReadStatus=.true.)
d1669 1
a1669 1
       "$Id: OutputAndClose.f90,v 2.133 2008/03/24 17:07:02 pwagner Exp $"
d1678 3
@


2.133
log
@Removed unused procedures
@
text
@d1132 1
a1132 1
    use Intrinsic, only: l_hdf, l_ascii
d1138 1
a1138 3
      & readnchars, reserve_MLSFile, split_path_name, textFile_to_chars
    use MLSNumerics, only: Battleship
    use MLSStrings, only: Replace
a1145 3
    integer, parameter                      :: MAXL2CFSIZE = 2000000
    character(LEN=MAXL2CFSIZE)              :: L2CFTEXT
    ! character(len=1), dimension(MAXL2CFSIZE) :: l2cfarray
a1150 1
    integer :: length
a1154 2
    integer :: textLength
    logical, parameter :: useExactTextLength = .true. ! NAG demands TRUE
a1169 4
    ! Use the textFile_to_chars subroutine
    call textFile_to_chars( MLSL2CF%name, l2cftext )
    length = len_trim(l2cftext)

d1172 1
a1172 1
    ! Get the l2gp file name from the PCF
d1199 2
a1200 1
      call SaveAsHDF5DS ( outputFile%FileID%f_id, 'l2cf', l2cftext )
d1417 1
a1417 1
      & SIPS_VERSION, SKIPDIRECTWRITES, TOOLKIT
d1669 1
a1669 1
       "$Id: OutputAndClose.f90,v 2.132 2008/02/22 21:36:41 pwagner Exp $"
d1678 3
@


2.132
log
@DGG file was hybrid by default; now it will be pure HDFEOS
@
text
@d1050 1
a1050 1
    ! Get the l2gp file name from the PCF
d1138 1
a1138 1
      & readnchars, reserve_MLSFile, split_path_name
d1178 2
a1179 24
    textLength = 2000000
    l2cftext = ' '
    if ( useExactTextLength ) then
      call reserve_MLSFile ( MLSL2CF%name, type=l_ascii )
      if ( readnchars(1024) /= readnchars(2000000) ) &
        & call Battleship( readnchars, textLength, &
        & ns = (/ 1024, 100000, 2000000 /) )
    endif
    open(UNIT=MLSL2CF%FileID%f_id, access='direct', recl=textLength, &
      & file=trim(MLSL2CF%name), status='old', iostat=status )
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to write dataset--failed to open l2cf' )
      return
    endif
    read(UNIT=MLSL2CF%FileID%f_id, REC=1, IOSTAT=status) l2cftext(:textLength)
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to read l2cf' )
      return
    endif
    ! Unfortunately, a lot of null characters sneak into this
    l2cftext = Replace( l2cftext, char(0), char(32) ) ! Replace null with space
    close( UNIT=MLSL2CF%FileID%f_id, iostat=status )
a1340 113
  ! ---------------------------------------------  OutputTextFile  -----
  subroutine OutputTextFile ( textFile, fileName, DEBUG, filedatabase )
    ! Do the work of outputting a named text file to a named l2aux file
    use Intrinsic, only: l_hdf, l_ascii
    use MLSCommon, only: MLSFile_T, FileNameLen
    use MLSL2Options, only: checkPaths, TOOLKIT
    use MLSFiles, only: AddInitializeMLSFile, &
      & GetMLSFileByName, GetMLSFileByType, GetPCFromRef, &
      & mls_closeFile, mls_openFile, &
      & readnchars, reserve_MLSFile, split_path_name
    use MLSNumerics, only: Battleship
    use MLSStrings, only: Replace
    use MLSHDF5, only: SaveAsHDF5DS
    use MLSPCF2, only: mlspcf_l2dgm_start, mlspcf_l2dgm_end
    ! Args
    character(len=*), intent(inout)         :: textFile ! take as input
    character(len=*), intent(inout)         :: fileName ! output
    logical, intent(in)                     :: DEBUG ! Print lots?
    type(MLSFile_T), dimension(:), pointer  :: filedatabase
    ! Internal variables
    integer, parameter                      :: MAXTEXTSIZE = 2000000
    character(LEN=MAXTEXTSIZE)              :: TEXT
    type(MLSFile_T), pointer                :: MLSTEXT
    integer                                 :: status
    integer :: FileHandle
    character (len=FileNameLen) :: FullFilename
    integer :: hdfVersion               ! 4 or 5 (corresp. to hdf4 or hdf5)
    integer :: length
    type(MLSFile_T), pointer :: outputFile
    character(len=8) :: OUTPUTTYPESTR   ! 'l2gp', 'l2aux', etc.
    character (len=132) :: path
    integer :: ReturnStatus
    integer :: textLength
    logical, parameter :: useExactTextLength = .true. ! NAG demands TRUE
    integer :: Version
    ! Executable
    nullify ( MLSTEXT )
    MLSTEXT => GetMLSFileByName( filedatabase, textFile )
    if ( .not. associated(MLSTEXT) ) then
      MLSText => AddInitializeMLSFile( filedatabase, l_ascii, &
        & DFACC_RDONLY, 'text', textFile )
    endif
    if ( .not. associated(MLSTEXT) ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to write dataset--failed to find/create ' // trim(textFile) )
      return
    endif
    if ( MLSTEXT%stillOpen ) call mls_closeFile( MLSTEXT, status )
    if ( MLSTEXT%name == '<STDIN>' ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to write dataset--stdin has been used for textfile' )
      return
    endif
    textLength = 2000000
    text = ' '
    if ( useExactTextLength ) then
      call reserve_MLSFile ( MLSTEXT%name, type=l_ascii )
      if ( readnchars(1024) /= readnchars(2000000) ) &
        & call Battleship( readnchars, textLength, &
        & ns = (/ 1024, 100000, 2000000 /) )
    endif
    open(UNIT=MLSTEXT%FileID%f_id, access='direct', recl=textLength, &
      & file=trim(MLSTEXT%name), status='old', iostat=status )
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to write dataset--failed to open textfile' )
      return
    endif
    read(UNIT=MLSTEXT%FileID%f_id, REC=1, IOSTAT=status) text(:textLength)
    if ( status /= 0 ) then
      call MLSMessage(MLSMSG_Warning, ModuleName, &
        & 'Unable to read textfile' )
      return
    endif
    ! Unfortunately, a lot of null characters sneak into this
    text = Replace( text, char(0), char(32) ) ! Replace null with space
    close( UNIT=MLSTEXT%FileID%f_id, iostat=status )
    length = len_trim(text)

    Version = 1
    OUTPUTTYPESTR = 'l2aux'
    ! Get the l2gp file name from the PCF

    if ( TOOLKIT ) then
      call split_path_name(fileName, path, fileName)

      FileHandle = GetPCFromRef(fileName, mlspcf_l2dgm_start, &
        & mlspcf_l2dgm_end, &
        & TOOLKIT, returnStatus, Version, DEBUG, &
        & exactName=FullFilename)
    else
      FullFilename = fileName
      returnStatus = 0
    end if

    if ( returnStatus == 0 .and. .not. checkPaths ) then
      ! Open the HDF file and write l2cf
      outputFile => GetMLSFileByName(filedatabase, FullFilename)
      if ( .not. associated(outputFile) ) then
        if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
          & 'No entry in filedatabase for ' // trim(FullFilename) )
        outputFile => AddInitializeMLSFile(filedatabase, &
          & content=outputTypeStr, &
          & name=FullFilename, shortName=fileName, &
          & type=l_hdf, access=DFACC_RDWR, HDFVersion=hdfVersion, &
          & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
      endif
      if ( .not. outputFile%stillOpen ) call mls_openFile( outputFile, status )
      call SaveAsHDF5DS ( outputFile%FileID%f_id, trim(textFile), text )
      call mls_closeFile( outputFile, status )
    endif
  end subroutine OutputTextFile

d1680 1
a1680 1
       "$Id: OutputAndClose.f90,v 2.131 2007/12/07 01:51:40 pwagner Exp $"
d1689 3
@


2.131
log
@Removed unused dummy variables, etc.
@
text
@d36 2
a37 1
  ! Should we get this from MLSL2Options?
d1363 113
d1559 1
a1559 1
      & MLS_SFSTART, MLS_SFEND, &
d1563 1
a1563 1
      & SKIPDIRECTWRITES, TOOLKIT
d1570 2
d1583 1
d1591 1
d1663 17
d1784 2
d1815 1
a1815 1
       "$Id: OutputAndClose.f90,v 2.130 2007/05/30 22:30:29 pwagner Exp $"
d1824 3
@


2.130
log
@Tries to avoid accessing components of unassociated pointers
@
text
@d564 1
a564 1
          call OutputL2CF ( key, file_base, DEBUG, filedatabase )
d1129 1
a1129 1
  subroutine OutputL2CF ( key, fileName, DEBUG, filedatabase )
a1130 1
    ! use dump_0, only: dump
d1134 1
a1134 1
    use MLSFiles, only: AddInitializeMLSFile, Dump, &
a1142 1
    integer, intent(in)                     :: key ! tree node
a1159 1
    integer :: SON                      ! Of Root -- spec_args or named node
a1170 1
    ! call dump(MLSL2CF, details=1)
a1176 2
    !call mls_openFile(MLSL2CF, status)
    !call dump(MLSL2CF, details=1)
a1199 1
    !call mls_closeFile(MLSL2CF, status)
a1201 4
    ! print *, 'Length: ', length
    ! print *, '1st char: ', l2cftext(1:1), ichar( l2cftext(1:1) )
    ! print *, 'last char: ', l2cftext(length:length), ichar( l2cftext(length:length) )
    ! call dump( transfer(l2cftext, l2cfarray) )
d1678 1
a1678 1
       "$Id: OutputAndClose.f90,v 2.129 2007/04/05 22:52:01 pwagner Exp $"
d1687 3
@


2.129
log
@NAG, too, now able to write L2CF to L2AUX
@
text
@d372 5
d406 1
a406 1
            call output( trim(inputFile%name), advance='yes' )
d1689 1
a1689 1
       "$Id: OutputAndClose.f90,v 2.128 2007/03/23 00:28:39 pwagner Exp $"
d1698 3
@


2.128
log
@Steps gingerly around case of disassociated HGrids
@
text
@d1126 2
a1127 2
    use dump_0, only: dump
    use Intrinsic, only: l_hdf
d1132 3
a1134 1
      & mls_closeFile, mls_openFile, split_path_name
d1146 1
a1146 1
    character(len=1), dimension(MAXL2CFSIZE) :: l2cfarray
d1158 2
d1178 9
a1186 1
    open(UNIT=MLSL2CF%FileID%f_id, access='direct', recl=2000000, &
d1193 1
a1193 1
    read(UNIT=MLSL2CF%FileID%f_id, REC=1, IOSTAT=status) l2cftext
d1684 1
a1684 1
       "$Id: OutputAndClose.f90,v 2.127 2007/01/18 19:39:16 pwagner Exp $"
d1693 3
@


2.127
log
@Fixed bug causing Phase Names attribute to include only 1st phase
@
text
@d315 2
a316 1
        if ( ( size(HGrids) < 1 .and. got(f_hgrid) ) ) &
d319 5
d1672 1
a1672 1
       "$Id: OutputAndClose.f90,v 2.126 2006/10/02 23:06:56 pwagner Exp $"
d1681 3
@


2.126
log
@Write FailedMachines attribute unless using old mlssubmit
@
text
@d1426 1
a1426 1
    use L2AUXData, only: cpL2AUXData
d1536 4
d1614 1
a1614 1
          ! print *, 'About to CpHDF5GlAttribute'
d1660 1
d1666 1
a1666 1
       "$Id: OutputAndClose.f90,v 2.125 2006/08/02 19:52:55 vsnyder Exp $"
d1675 3
@


2.125
log
@Add destroy command and destroy field for output command
@
text
@d175 2
d198 1
d200 1
d210 1
a210 1
      call unsplitFiles ( DirectDatabase, FileDatabase, usingSubmit, debug )
d1661 1
a1661 1
       "$Id: OutputAndClose.f90,v 2.124 2006/05/09 16:40:41 pwagner Exp $"
d1670 3
@


2.124
log
@Added writing l2cf to dgm
@
text
@d47 1
a47 1
    & matrices, fileDataBase, chunks, processingRange, canWriteL2PC )
d64 1
d70 2
a71 2
    use INIT_TABLES_MODULE, only: F_ASCII, F_CREATE, F_DONTPACK, F_EXCLUDE, &
      & F_FILE, F_HDFVERSION, F_HGRID, &
d78 1
a78 1
      & S_COPY, S_HGrid, S_OUTPUT, S_TIME
d85 2
a86 1
    use MatrixModule_1, only: MATRIX_DATABASE_T, MATRIX_T, GETFROMMATRIXDATABASE
d107 1
d115 1
d127 1
d255 2
a256 2
      select case( get_spec_id(key) )
      case (s_copy)
d473 3
a475 1
      case (s_HGrid)
d541 1
a541 1
        ! Unless outputting l2cf, you must have supplied a quantities fild
d572 2
a574 1
          ascii = .false.
d578 4
a581 6
            case ( f_quantities )
              quantitiesNode = gson
            case ( f_overlaps )
              ! ??? More work needed here
            case ( f_packed )
              packed = get_boolean ( gson )
d587 6
a592 2
            case ( f_ascii )
              ascii = get_boolean ( gson )
d608 1
d623 5
d1657 1
a1657 1
       "$Id: OutputAndClose.f90,v 2.123 2006/04/28 00:46:28 pwagner Exp $"
d1666 3
@


2.123
log
@Overcome namelength (132) limitation for file= field
@
text
@d76 1
a76 1
      & L_L2AUX, L_L2DGG, L_L2GP, L_L2PC, &
d529 1
d533 6
d541 4
d1097 108
d1641 1
a1641 1
       "$Id: OutputAndClose.f90,v 2.122 2006/04/11 23:35:38 pwagner Exp $"
d1650 3
@


2.122
log
@More info why unable to unsplit dgg/dgm files
@
text
@d85 1
a85 1
    use MLSCommon, only: MLSFile_T, TAI93_Range_T
d130 1
a130 1
    character (len=132) :: FILE_BASE    ! From the FILE= field
d138 2
a139 2
    character (len=132) :: INPUTFILE_BASE    ! From the inputfile= field
    character (len=132) :: inputPhysicalFilename
d157 1
a157 1
    character (len=132) :: PhysicalFilename
d970 1
a970 1
    use MLSCommon, only: MLSFile_T
d989 1
a989 1
    character (len=132) :: FullFilename
d1095 1
a1095 1
    use MLSCommon, only: MLSFile_T
d1116 1
a1116 1
    character (len=132) :: FullFilename
d1291 1
a1291 1
    use MLSCommon, only: I4, MLSFile_T
d1315 1
a1315 1
    character (len=132) :: FILE_BASE    ! From the FILE= field
d1318 1
a1318 1
    character (len=132) :: L2auxPhysicalFilename
d1320 1
a1320 1
    character (len=132) :: L2gpPhysicalFilename
d1522 1
a1522 1
       "$Id: OutputAndClose.f90,v 2.121 2006/03/15 23:47:53 pwagner Exp $"
d1531 3
@


2.121
log
@Fixed bug causing crashes when no gapless HGrid declared
@
text
@d200 1
d202 7
d1522 1
a1522 1
       "$Id: OutputAndClose.f90,v 2.120 2006/03/04 00:23:30 pwagner Exp $"
d1531 3
@


2.120
log
@Will not attempt copy unless input file contains swath
@
text
@d449 3
a451 1
          call writeHGridComponents( trim(PhysicalFilename), HGrids(noGapsHGIndex) )
d1514 1
a1514 1
       "$Id: OutputAndClose.f90,v 2.119 2006/02/21 19:13:33 pwagner Exp $"
d1523 3
@


2.119
log
@Some tweaks to where, when to dump
@
text
@d88 1
a88 1
      & MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF
d95 1
a95 1
    use MLSStringLists, only: switchDetail, unquote
d144 1
d152 1
d163 1
d371 9
a406 3
          ! print *, 'Before cpL2GPFata'
          ! print *, 'noGapsHGIndex: ', noGapsHGIndex
          ! call dump(hGrids)
d408 5
d1512 1
a1512 1
       "$Id: OutputAndClose.f90,v 2.118 2005/12/21 18:46:29 pwagner Exp $"
d1521 3
@


2.118
log
@Fixed bug that clobbered split dgm files while copying them
@
text
@a21 1
  use OUTPUT_M, only: blanks, OUTPUT
d68 1
a68 1
      & ADDHGRIDTODATABASE, destroyHGridDatabase, Dump
d80 1
a80 1
    use L2GPData, only: AVOIDUNLIMITEDDIMS, L2GPData_T, L2GPNameLen, &
d91 1
a91 1
      & PENALTY_FOR_NO_METADATA, SKIPDIRECTWRITES, TOOLKIT
d95 1
a95 1
    use MLSStringLists, only: unquote
d98 1
a156 2
    character(len=L2GPNameLen), dimension(MAXQUANTITIESPERFILE) :: &
      &                           QuantityNames  ! From "quantities" field
d183 1
a183 1
    if (index(switches, 'pro') /= 0) then
d447 2
d472 2
d569 1
a569 1
            else if ( index(switches, 'pro') /= 0) then
d650 1
a650 1
    if (index(switches, 'pro') /= 0) then
d695 1
d869 1
d907 1
d951 1
d1045 1
a1045 1
      if (index(switches, 'pro') /= 0) then
d1075 1
d1168 1
a1168 1
      if (index(switches, 'pro') /= 0) then
d1278 1
a1278 1
    use MLSStringLists, only: Array2List
d1280 1
d1465 1
a1465 1
      if ( (parallel%master .or. index(switches, 'chu') /= 0) &
d1498 1
a1498 1
       "$Id: OutputAndClose.f90,v 2.117 2005/12/10 00:51:36 pwagner Exp $"
d1507 3
@


2.117
log
@Copies ForwardModel Names attribute when unsplitting spli dgms
@
text
@d19 1
a19 1
  use Hdf, only: DFACC_RDWR
d1396 9
a1404 3
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          &  "no sd known for " // trim(DirectDatabase(DB_index)%fileName) )
          cycle
a1405 4
        ! print *, 'About to try to convert array2List'
        ! call dump(DirectDatabase(DB_index))
        call Array2List(DirectDatabase(DB_index)%sdNames, sdList)
        ! print *, 'result: ', trim(sdList)
d1427 2
d1490 1
a1490 1
       "$Id: OutputAndClose.f90,v 2.116 2005/11/15 00:22:05 pwagner Exp $"
d1499 3
@


2.116
log
@Defined Overlaps for AllChunks chunk
@
text
@d1438 2
d1486 1
a1486 1
       "$Id: OutputAndClose.f90,v 2.115 2005/11/04 18:55:46 pwagner Exp $"
d1495 3
@


2.115
log
@Can add metadata when copying swaths, datasets
@
text
@d204 1
d206 1
d1484 1
a1484 1
       "$Id: OutputAndClose.f90,v 2.114 2005/10/28 23:19:01 pwagner Exp $"
d1493 3
@


2.114
log
@Many changes related to Copy; one may fixed a bug
@
text
@d81 1
a81 1
    use L2GPData, only: AVOIDUNLIMITEDDIMS, L2GPData_T, &
d131 1
d157 2
d378 1
a378 1
        call display_string ( lit_indices(output_type), &
d380 1
a380 1
        call display_string ( lit_indices(input_type), &
d383 2
d387 1
d394 1
d438 5
d675 3
a677 2
  subroutine add_metadata ( node, fileName, numquantitiesperfile, &
    & quantityNames, hdfVersion, filetype, metadata_error )
d679 1
d682 4
a685 1
    use MLSFiles, only: GetPCFromRef, split_path_name
d690 1
a695 2
  integer, intent(in) :: numquantitiesperfile
  character(len=*), dimension(:), intent(in) :: quantityNames
d699 2
d704 1
d713 1
d715 1
d718 1
d720 1
d723 1
d760 14
d832 12
d857 1
d1045 3
a1047 2
      call add_metadata ( son, fileName, numquantitiesperfile, &
        & quantityNames, hdfVersion, l_hdf, metadata_error )
d1168 3
a1170 2
      call add_metadata ( son, fileName, numquantitiesperfile, &
        & quantityNames, hdfVersion, l_swath, metadata_error )
d1340 1
d1348 2
a1349 2
        call add_metadata ( 0, trim(l2gpPhysicalFilename), 1, &
          & (/'dgg'/), HDFVERSION_5, l_l2dgg, returnStatus )
d1391 1
d1441 2
a1442 2
        call add_metadata ( 0, trim(l2auxPhysicalFilename), 1, &
          & (/'dgm'/), HDFVERSION_5, l_hdf, returnStatus )
d1482 1
a1482 1
       "$Id: OutputAndClose.f90,v 2.113 2005/10/22 00:46:14 pwagner Exp $"
d1491 3
@


2.113
log
@May write all-day HGrid as attributes
@
text
@d69 1
a69 1
      & ADDHGRIDTODATABASE, Dump
d88 1
a88 1
      & AddInitializeMLSFile, GetMLSFileByName, &
d246 1
d265 1
a265 1
            ! print *, 'HGridIndex: ', HGridIndex
a305 28
        select case ( input_type )
        case ( l_l2aux ) ! --------------------- Copying l2aux files -----
          call returnFullFileName(inputfile_base, inputPhysicalFilename, &
            & mlspcf_l2dgm_start, mlspcf_l2dgm_end)
          inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
          if ( .not. associated(inputFile) ) then
            call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
          endif
        case ( l_l2gp ) ! --------------------- Copying l2gp files -----
          call returnFullFileName(inputfile_base, inputPhysicalFilename, &
            & mlspcf_l2gp_start, mlspcf_l2gp_end)
          inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
          if ( .not. associated(inputFile) ) then
            call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
          endif
        case ( l_l2dgg ) ! --------------------- Copying l2dgg files -----
          call returnFullFileName(inputfile_base, inputPhysicalFilename, &
            & mlspcf_l2dgg_start, mlspcf_l2dgg_end)
          inputFile => GetMLSFileByName(filedatabase, inputPhysicalFilename)
          if ( .not. associated(inputFile) ) then
            call MLSMessage(MLSMSG_Error, ModuleName, &
              & 'No entry in filedatabase for ' // trim(inputPhysicalFilename) )
          endif
        case default
        end select

d342 29
d399 5
d408 2
a409 1
              & HGrid=HGrids(HGridIndex), options="-rv")
d416 2
a417 1
              & HGrid=HGrids(HGridIndex), options="-rv")
d468 1
d623 4
d1427 1
a1427 1
       "$Id: OutputAndClose.f90,v 2.112 2005/09/23 23:39:35 pwagner Exp $"
d1436 3
@


2.112
log
@Added rename field to copy command
@
text
@a18 1
  use DirectWrite_m, only: DirectData_T, Dump
d65 1
d68 2
a69 1
    use HGridsDatabase, only: ADDHGRIDTODATABASE, Dump, HGRID_T
a78 1
    use HDF5, only: h5gclose_f, h5gopen_f
d80 3
a82 3
    use L2AUXData, only: L2AUXDATA_T, cpL2AUXData, WriteL2AUXData
    use L2GPData, only: AVOIDUNLIMITEDDIMS, L2GPNameLen, L2GPData_T, &
      & MAXSWATHNAMESBUFSIZE, cpL2GPData, WriteL2GPData
d86 4
a89 6
    use MLSCommon, only: I4, MLSFile_T, TAI93_Range_T
    use MLSFiles, only: HDFVERSION_5, &
      & AddInitializeMLSFile, GetMLSFileByName, GetPCFromRef, mls_exists, &
      & MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, MLS_SFSTART, MLS_SFEND, &
      & SPLIT_PATH_NAME, unSplitName
    use MLSHDF5, only: CpHDF5GlAttribute, MakeHDF5Attribute
d95 2
a96 5
      & MLSPCF_L2GP_START, mlspcf_l2dgg_start, mlspcf_l2dgg_end, &
      & Mlspcf_mcf_l2gp_start, Mlspcf_mcf_l2dgm_start, &
      & Mlspcf_mcf_l2dgg_start
    use MLSSets, only: FindFirst, FindNext
    use MLSStringLists, only: Array2List, unquote
d99 1
a99 2
    use SDPToolkit, only: PGS_S_SUCCESS, PGSD_IO_GEN_WSEQFRM, Pgs_smf_getMsg
    use readAPriori, only: writeAPrioriAttributes
a131 1
    integer :: GRP_ID
a134 2
    type (HGrid_T), target :: newHGrid
    type (HGrid_T), pointer :: newHGridp
d140 1
a142 1
    logical :: madeFile
d146 2
d149 1
a149 1
    integer :: Numquantitiesperfile     ! < MAXQUANTITIESPERFILE
a153 1
    character (len=132) :: path
a158 2
    integer :: ReturnStatus
    integer(i4) :: SDFID                ! File handle
a237 2
        ! call announce_error ( spec_no, &
        !  &  "Error--copy not implemented yet")
d309 5
d317 5
d325 5
d337 8
d348 8
d359 8
d380 1
a380 1
          ! Note that we haven't yet implemented all the repair stuff
d382 3
a384 3
          call cpL2AUXData(trim(inputPhysicalfileName), &
            & trim(PhysicalFilename), create2=create, &
            & hdfVersion=HDFVERSION_5, sdList=trim(sdList))
d386 3
d391 2
a392 3
            call cpL2GPData(trim(inputPhysicalfileName), &
              & trim(PhysicalFilename), create2=create, &
              & hdfVersion1=HDFVERSION_5, hdfVersion2=HDFVERSION_5, &
d397 2
a398 3
            call cpL2GPData(trim(inputPhysicalfileName), &
              & trim(PhysicalFilename), create2=create, &
              & hdfVersion1=HDFVERSION_5, hdfVersion2=HDFVERSION_5, &
d403 2
a404 3
            call cpL2GPData(trim(inputPhysicalfileName), &
              & trim(PhysicalFilename), create2=create, &
              & hdfVersion1=HDFVERSION_5, hdfVersion2=HDFVERSION_5, &
d410 2
a411 3
            call cpL2GPData(trim(inputPhysicalfileName), &
              & trim(PhysicalFilename), create2=create, &
              & hdfVersion1=HDFVERSION_5, hdfVersion2=HDFVERSION_5, &
d415 5
d429 1
a429 1
        newHGridp => newHGrid
d431 6
d438 1
a438 1
          & call DealWithObstructions( newHGridp, obstructions )
d443 6
a448 3
        if ( DEBUG ) print *, 'HGrid added; size now: ', size(hGrids)
        if ( DEBUG ) print *, 'After dealing with obstructions'
        if ( DEBUG ) call dump(newHGridp)
d485 1
d488 1
a488 1
            & filedatabase, l2gpDatabase )
d555 1
d558 1
a558 1
            & filedatabase, l2gpDatabase )
d871 2
a872 2
    use Intrinsic, only: l_ascii, l_swath, l_hdf, Lit_indices, PHYQ_Dimensionless
    use L2AUXData, only: L2AUXDATA_T, cpL2AUXData, WriteL2AUXData
d874 1
a874 1
    use MLSCommon, only: I4, MLSFile_T
d879 1
a879 1
    use SDPToolkit, only: PGS_S_SUCCESS, PGSD_IO_GEN_WSEQFRM, Pgs_smf_getMsg
d881 1
a881 1
    use TREE, only: DECORATION, NODE_ID, NSONS, SUBTREE, SUB_ROSA
d925 1
a925 1
      ! Open the HDF-EOS file and write swath data
d991 1
a991 1
    & filedatabase, l2gpDatabase )
d993 1
d995 1
a995 1
    use Intrinsic, only: l_ascii, l_swath, l_hdf, Lit_indices, PHYQ_Dimensionless
d997 1
a997 1
    use MLSCommon, only: I4, MLSFile_T
d1001 1
a1001 1
    use SDPToolkit, only: PGS_S_SUCCESS, PGSD_IO_GEN_WSEQFRM, Pgs_smf_getMsg
d1003 1
a1003 1
    use TREE, only: DECORATION, NODE_ID, NSONS, SUBTREE, SUB_ROSA
d1013 1
d1098 1
d1111 38
d1152 1
a1152 4
    use MLSFiles, only: HDFVERSION_5, &
      & AddInitializeMLSFile, GetMLSFileByName, GetPCFromRef, mls_exists, &
      & MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, MLS_SFSTART, MLS_SFEND, &
      & SPLIT_PATH_NAME, unSplitName
d1183 1
d1185 1
a1185 4
    use INIT_TABLES_MODULE, only: F_ASCII, F_EXCLUDE, F_FILE, F_HDFVERSION, &
      & F_METANAME, F_METADATAONLY, F_OVERLAPS, F_PACKED, F_QUANTITIES, &
      & F_SWATH, F_TYPE, F_WRITECOUNTERMAF, F_DONTPACK, &
      & L_L2AUX, L_L2DGG, L_L2GP, L_L2PC, S_COPY, S_OUTPUT, S_TIME
d1187 3
a1189 3
    use L2AUXData, only: L2AUXDATA_T, cpL2AUXData, WriteL2AUXData
    use L2GPData, only: AVOIDUNLIMITEDDIMS, L2GPNameLen, L2GPData_T, &
      & MAXSWATHNAMESBUFSIZE, cpL2GPData, WriteL2GPData
d1194 2
a1195 2
      & MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, MLS_SFSTART, MLS_SFEND, &
      & SPLIT_PATH_NAME, unSplitName
d1197 4
a1200 7
    use MLSL2Options, only: CATENATESPLITS, CHECKPATHS, &
      & DEFAULT_HDFVERSION_WRITE, &
      & PENALTY_FOR_NO_METADATA, SKIPDIRECTWRITES, TOOLKIT
    use MLSPCF2, only: MLSPCF_L2DGM_END, MLSPCF_L2DGM_START, MLSPCF_L2GP_END, &
      & MLSPCF_L2GP_START, mlspcf_l2dgg_start, mlspcf_l2dgg_end, &
      & Mlspcf_mcf_l2gp_start, Mlspcf_mcf_l2dgm_start, &
      & Mlspcf_mcf_l2dgg_start
d1202 1
a1202 1
    use MLSStringLists, only: Array2List, unquote
d1212 1
d1216 1
a1216 1
    integer :: L2auxFileHandle, L2aux_Version
a1217 1
    integer :: L2aux_mcf, L2dgg_mcf, L2gp_mcf  ! mcf numbers for writing metadata
a1219 1
    integer :: L2PCUNIT
a1221 1
    character (len=132) :: path
d1225 39
a1263 15
      ! Executable
      if ( debug ) call dump(DirectDatabase)
      ! Any dgg eligible for being catenated
      DB_index = findFirst( DirectDatabase%autoType, l_l2dgg )
      if ( findNext(DirectDatabase%autoType, l_l2dgg, DB_index) > 0 ) then
        if ( TOOLKIT ) then
          l2gp_Version = 1
          l2gpFileHandle = GetPCFromRef('DGG', mlspcf_l2dgg_start, &
            & mlspcf_l2dgg_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2gpPhysicalFilename)
        else
          file_base = DirectDatabase(DB_index)%fileName
          l2gpPhysicalFilename = unSplitName(file_base)
          returnStatus = 0
d1265 80
a1344 4
        if ( any(DirectDatabase%fileName == l2gpPhysicalFilename) ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Cannot unsplit dgg dw to existing file " // &
            & trim(l2gpPhysicalFilename) )
d1346 12
a1357 41
        madeFile = .false.
        do DB_index = 1, size(DirectDatabase)
          if ( DirectDatabase(DB_index)%autoType /= l_l2dgg ) cycle
          if ( DEBUG ) then
            call output ( 'preparing to cp split dgg', advance='yes' )
            call output ( 'from: ', advance='no' )
            call output ( trim(DirectDatabase(DB_index)%fileName) , advance='yes' )
            call output ( '   to: ', advance='no' )
            call output ( trim(l2gpPhysicalFilename) , advance='yes' )
          end if
          if ( mls_exists(trim(DirectDatabase(DB_index)%fileName)) /= 0 ) cycle
          madeFile = .true.
          call cpL2GPData(trim(DirectDatabase(DB_index)%fileName), &
            & trim(l2gpPhysicalFilename), create2=(DB_index==1), &
            & hdfVersion1=HDFVERSION_5, hdfVersion2=HDFVERSION_5, &
            & notUnlimited=avoidUnlimitedDims, ReadStatus=.true.)
        end do
        if ( TOOLKIT .and. madeFile ) then
          call add_metadata ( 0, trim(l2gpPhysicalFilename), 1, &
            & (/'dgg'/), HDFVERSION_5, l_l2dgg, returnStatus )
          if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'unable to addmetadata to ' // trim(l2gpPhysicalFilename) )
        end if
        if ( madeFile ) then
         call writeAPrioriAttributes(trim(l2gpPhysicalFilename), HDFVERSION_5)
         outputFile => AddInitializeMLSFile(filedatabase, &
           & content='l2dgg', &
           & name=l2gpPhysicalFilename, shortName='DGG', &
           & type=l_swath, access=DFACC_RDWR, HDFVersion=HDFVERSION_5, &
           & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
        end if
      end if
      ! Next we would do the same for any split dgm direct write files
      DB_index = findFirst( DirectDatabase%autoType, l_l2aux )
      if ( findNext(DirectDatabase%autoType, l_l2aux, DB_index) > 0 ) then
        if ( TOOLKIT ) then
          l2gp_Version = 1
          l2gpFileHandle = GetPCFromRef('DGM', mlspcf_l2dgm_start, &
            & mlspcf_l2dgm_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2auxPhysicalFilename)
d1359 3
a1361 3
          file_base = DirectDatabase(DB_index)%fileName
          l2auxPhysicalFilename = unSplitName(file_base)
          returnStatus = 0
d1363 3
a1365 40
        if ( any(DirectDatabase%fileName == l2auxPhysicalFilename) ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            &  "Must not unsplit dgm dw to " // trim(l2auxPhysicalFilename) )
        end if
        madeFile = .false.
        do DB_index = 1, size(DirectDatabase)
          if ( DirectDatabase(DB_index)%autoType /= l_l2aux ) cycle
          if ( .not. associated(DirectDatabase(DB_index)%sdNames) ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            &  "no sd known for " // trim(DirectDatabase(DB_index)%fileName) )
            cycle
          endif
          ! print *, 'About to try to convert array2List'
          ! call dump(DirectDatabase(DB_index))
          call Array2List(DirectDatabase(DB_index)%sdNames, sdList)
          ! print *, 'result: ', trim(sdList)
          ! Not implemented yet
          if ( DEBUG ) then
            call output ( 'preparing to cp split dgm', advance='yes' )
            call output ( 'from: ', advance='no' )
            call output ( trim(DirectDatabase(DB_index)%fileName) , advance='yes' )
            call output ( '   to: ', advance='no' )
            call output ( trim(l2auxPhysicalFilename) , advance='yes' )
            call output ( '   sdList: ', advance='no' )
            call output ( trim(sdList) , advance='yes' )
          end if
          if ( mls_exists(trim(DirectDatabase(DB_index)%fileName)) /= 0 ) cycle
          madeFile = .true.
          if ( sdList /= ' ' ) then
            call cpL2AUXData(trim(DirectDatabase(DB_index)%fileName), &
            & trim(l2auxPhysicalFilename), create2=(DB_index==1), &
            & hdfVersion=HDFVERSION_5, sdList=trim(sdList))
          else
            ! Last-ditch effort if somehow sdNames empty or Array2List fails
            call cpL2AUXData(trim(DirectDatabase(DB_index)%fileName), &
            & trim(l2auxPhysicalFilename), create2=(DB_index==1), &
            & hdfVersion=HDFVERSION_5)
          end if
          if ( DB_index==1 ) &
            & call CpHDF5GlAttribute ( DirectDatabase(DB_index)%fileName, &
a1366 44
        end do
        ! Is metadata really needed for l2aux files?
        if ( TOOLKIT .and. madeFile ) then
          call add_metadata ( 0, trim(l2auxPhysicalFilename), 1, &
            & (/'dgm'/), HDFVERSION_5, l_hdf, returnStatus )
          if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'unable to addmetadata to ' // trim(l2auxPhysicalFilename) )
        end if
        
        ! Now we can write any last-minute attributes or datasets to the l2aux
        ! E.g., parallel stuff
        if ( (parallel%master .or. index(switches, 'chu') /= 0) &
          & .and. .not. (checkPaths .or. SKIPDIRECTWRITES) .and. &
          & madeFile .and. l2auxPhysicalFilename /= ' ' ) then
          sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_RDWR, &
              & hdfVersion=HDFVERSION_5)
          call h5gopen_f(sdfId, '/', grp_id, returnStatus)
          if ( .not. parallel%master .and. FAKEPARALLELMASTER ) then
            parallel%numCompletedChunks = 347
            parallel%numFailedChunks = 3
            parallel%FailedChunks = '2,5,129'
            parallel%FailedMachs = 'c0-1,c0-66,c0-66'
            parallel%FailedMachs = 'msg 1\msg 2\msg 3'
          endif
          call MakeHDF5Attribute(grp_id, &
           & 'NumCompletedChunks', parallel%numCompletedChunks, .true.)
          call MakeHDF5Attribute(grp_id, &
           & 'NumFailedChunks', parallel%numFailedChunks, .true.)
          call MakeHDF5Attribute(grp_id, &
           & 'FailedChunks', trim_safe(parallel%FailedChunks), .true.)
          if ( .not. usingSubmit ) &
            call MakeHDF5Attribute(grp_id, &
             & 'FailedMachines', trim_safe(parallel%FailedMachs), .true.)
          call MakeHDF5Attribute(grp_id, &
           & 'FailedMsgs', trim_safe(parallel%FailedMsgs), .true.)
          call h5gclose_f(grp_id, returnStatus)
          returnStatus = mls_sfend(sdfid, hdfVersion=HDFVERSION_5)
          ! Probably excessively complex conditions for whether to add
          ! into database or not
          outputFile => AddInitializeMLSFile(filedatabase, &
           & content='l2aux', &
           & name=l2auxPhysicalFilename, shortName='L2AUX-DGM', &
           & type=l_hdf, access=DFACC_RDWR, HDFVersion=HDFVERSION_5, &
           & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
d1368 8
d1377 31
d1413 1
a1413 1
       "$Id: OutputAndClose.f90,v 2.111 2005/09/21 23:27:17 pwagner Exp $"
d1422 3
@


2.111
log
@Pokes holes in all-day HGrid to match obstructions
@
text
@d73 1
a73 1
      & F_QUANTITIES, F_REPAIRGEOLOCATIONS, &
d165 1
d229 1
d285 3
d371 1
a371 1
              & swathList=trim(sdList), &
d378 1
a378 1
              & swathList=trim(sdList), &
d386 1
a386 1
              & swathList=trim(sdList), &
d1311 1
a1311 1
       "$Id: OutputAndClose.f90,v 2.110 2005/09/14 00:15:32 pwagner Exp $"
d1320 3
@


2.110
log
@Relocate unsplitFiles before l2cf commands (so may copy swaths from DGG)
@
text
@d64 2
a65 2
    use Chunks_m, only: MLSChunk_T
    use ChunkDivide_m, only: ChunkDivideConfig
d67 1
a67 1
    use HGrid, only: CREATEHGRIDFROMMLSCFINFO
d142 2
d212 6
d368 1
a368 1
              & HGrid=HGrids(HGridIndex), options="-r")
d376 1
a376 1
              & HGrid=HGrids(HGridIndex), options="-r")
d390 7
a396 3
        call decorate ( key, AddHGridToDatabase ( hGrids, &
          & CreateHGridFromMLSCFInfo ( name, key, filedatabase, l2gpDatabase, &
          & processingRange, allChunks ) ) )
d399 2
a400 1
          & HGrids(size(hGrids))%noProfsLowerOverlap = 0
d402 2
a403 1
        if ( DEBUG ) call dump(HGrids(size(hGrids)))
d1306 1
a1306 1
       "$Id: OutputAndClose.f90,v 2.109 2005/08/19 23:35:35 pwagner Exp $"
d1315 3
@


2.109
log
@Allow Output to repair l2gp with HGrid while copying files
@
text
@d65 1
d195 11
d207 1
a207 1
    AllChunks%firstMAFIndex = chunks(1)%firstMAFIndex + 1
d219 1
a219 1
      sdList = '*'
d257 1
a257 1
            print *, 'file_base: ', trim(file_base)
d329 4
a332 4
        print *, 'inputPhysicalfileName: ', inputPhysicalfileName
        print *, 'outputPhysicalfileName: ', PhysicalfileName
        print *, 'repairGeoLocations: ', repairGeoLocations
        print *, 'create: ', create
d340 2
d346 1
a346 1
          ! How to use swaths field?
d385 5
a389 2
        print *, 'HGrid added; size now: ', size(hGrids)
        call dump(HGrids(size(hGrids)))
a539 7
    ! Catenate any split Direct Writes
    ! We assume hdfVersion is 5
    if ( CATENATESPLITS .and. associated(DirectDatabase) &
      & .and. .not. SKIPDIRECTWRITES ) then
      call unsplitFiles ( DirectDatabase, FileDatabase, usingSubmit, debug )
    end if

d1292 1
a1292 1
       "$Id: OutputAndClose.f90,v 2.108 2005/06/22 18:57:02 pwagner Exp $"
d1301 3
@


2.108
log
@Reworded Copyright statement, moved rcs id
@
text
@d21 2
a22 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d24 1
a24 1
  use STRING_TABLE, only: GET_STRING
d32 1
a32 1
       "$RCSfile: $"
d41 1
d49 1
a49 1
    & matrices, fileDataBase, canWriteL2PC )
d64 1
d66 11
a76 4
    use INIT_TABLES_MODULE, only: F_ASCII, F_FILE, F_HDFVERSION, &
      & F_METANAME, F_METADATAONLY, F_OVERLAPS, F_PACKED, F_QUANTITIES, &
      & F_TYPE, F_WRITECOUNTERMAF, F_DONTPACK, &
      & L_L2AUX, L_L2DGG, L_L2GP, L_L2PC, S_OUTPUT, S_TIME
d85 1
a85 1
    use MLSCommon, only: I4, MLSFile_T
d100 1
a100 1
    use MLSStringLists, only: Array2List
d108 1
a108 1
    use TREE, only: DECORATION, NODE_ID, NSONS, SUBTREE, SUB_ROSA
d118 3
a121 2
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    ! type(PCFData_T), intent(in) :: l2pcf
d125 1
d128 1
d131 1
d136 1
d140 2
d143 3
a146 5
    integer :: L2auxFileHandle, L2aux_Version
    character (len=132) :: L2auxPhysicalFilename
    integer :: L2aux_mcf, L2dgg_mcf, L2gp_mcf  ! mcf numbers for writing metadata
    integer :: L2gpFileHandle, L2gp_Version
    character (len=132) :: L2gpPhysicalFilename
a148 1
    integer, parameter:: MAXQUANTITIESPERFILE=10000
d159 1
a160 1
    character(len=L2GPNameLen), dimension(MAXQUANTITIESPERFILE) :: QuantityNames  ! From "quantities" field
d162 1
d166 1
d194 3
d198 2
a199 7
    ! l2gp_mcf will be incremented in get_l2gp_mcf (if MCFFORL2GPOPTION == 1)
    l2gp_mcf = mlspcf_mcf_l2gp_start - 1   

    l2aux_mcf = mlspcf_mcf_l2dgm_start
    l2dgg_mcf = mlspcf_mcf_l2dgg_start

    L2auxPhysicalFilename = ' '
a203 2
      l2gp_Version = 1
      l2aux_Version = 1
d205 1
d207 1
d210 4
d225 149
d409 4
a412 83
          ! Get the l2gp file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)

            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
              & mlspcf_l2gp_end, &
              & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
              & exactName=l2gpPhysicalFilename)
          else
            l2gpPhysicalFilename = file_base
            returnStatus = 0
          end if

          if ( returnStatus == 0 .and. .not. checkPaths ) then
            ! Open the HDF-EOS file and write swath data

!             swfid = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
!               & record_length, DFACC_CREATE, FileName=l2gpPhysicalFilename, &
!               & hdfVersion=hdfVersion, debugOption=.false. )
            outputFile => GetMLSFileByName(filedatabase, l2gpPhysicalFilename)
            if ( .not. associated(outputFile) ) then
              if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
                & 'No entry in filedatabase for ' // trim(l2gpPhysicalFilename) )
              outputFile => AddInitializeMLSFile(filedatabase, &
                & content=outputTypeStr, &
                & name=l2gpPhysicalFilename, shortName=file_base, &
                & type=l_swath, access=DFACC_RDWR, HDFVersion=hdfVersion, &
                & PCBottom=mlspcf_l2gp_start, PCTop=mlspcf_l2gp_end)
            endif
            ! Loop over the segments of the l2cf line

            numquantitiesperfile = 0
            do field_no = 2, nsons(key) ! Skip "output" name
              gson = subtree(field_no,key)
              select case ( decoration(subtree(1,gson)) )
              case ( f_quantities )
                do in_field_no = 2, nsons(gson)
                  db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                  if ( db_index >= 1 ) then
!                     call writeL2GPData ( l2gpDatabase(db_index), swfid, &
!                       & hdfVersion=hdfVersion )
                    call writeL2GPData ( l2gpDatabase(db_index), outputFile )
                    numquantitiesperfile = numquantitiesperfile+1
                    if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                      call announce_error ( son, &
                        & 'Attempt to write too many l2gp quantities to a file', &
                        & numquantitiesperfile )
                      numquantitiesperfile = MAXQUANTITIESPERFILE
                    end if
                    quantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
                  else
                    call MLSMessage ( MLSMSG_Warning, ModuleName, &
                      & 'Unable to write quantity to l2gp file, perhaps no chunks processed' )
                  end if
                end do ! in_field_no = 2, nsons(gson)
              case ( f_overlaps )
                ! ??? More work needed here
              end select
            end do ! field_no = 2, nsons(key)

            !           returnStatus = swclose(swfid)
!             returnStatus = mls_io_gen_closeF('swclose', swfid, &
!               & hdfVersion=hdfVersion)
!             if ( returnStatus /= PGS_S_SUCCESS ) then
!               call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
!               call MLSMessage ( MLSMSG_Error, ModuleName, &
!                 &  "Error closing  l2gp file:  "//mnemonic//" "//msg )
!             else if (index(switches, 'pro') /= 0) then
            if (index(switches, 'pro') /= 0) then
              call announce_success(l2gpPhysicalFilename, 'l2gp', &
                & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
            end if

            if ( .not. TOOLKIT ) cycle

            ! Write the metadata file
            call add_metadata ( son, file_base, numquantitiesperfile, &
              & quantityNames, hdfVersion, l_swath, metadata_error )
          else if ( returnStatus /= PGS_S_SUCCESS ) then
            call announce_error ( son, &
              &  "Error finding l2gp file matching:  "//file_base, returnStatus)
          end if
d415 3
a417 92

          ! Get the l2aux file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)
            l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
              & mlspcf_l2dgm_end, &
              & TOOLKIT, returnStatus, l2aux_Version, DEBUG, &
              & exactName=l2auxPhysicalFilename)
          else
            l2auxPhysicalFilename = file_base
            returnStatus = 0
          end if

          if ( returnStatus == 0 .and. .not. checkPaths ) then

            ! Create the HDF file and initialize the SD interface
!             sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_CREATE, &
!               & hdfVersion=hdfVersion)
            outputFile => GetMLSFileByName(filedatabase, l2auxPhysicalFilename)
            if ( .not. associated(outputFile) ) then
              if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
                & 'No entry in filedatabase for ' // trim(l2auxPhysicalFilename) )
              outputFile => AddInitializeMLSFile(filedatabase, &
                & content=outputTypeStr, &
                & name=l2auxPhysicalFilename, shortName=file_base, &
                & type=l_hdf, access=DFACC_RDWR, HDFVersion=hdfVersion, &
                & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
            endif

            numquantitiesperfile = 0
            do field_no = 2, nsons(key) ! Skip "output" name
              gson = subtree(field_no,key)
              select case ( decoration(subtree(1,gson)) )
              case ( f_quantities )
                do in_field_no = 2, nsons(gson)
                  db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                  if ( db_index >= 1 ) then
!                     call WriteL2AUXData ( l2auxDatabase(db_index), sdfid, returnStatus,&
!                       & WriteCounterMAF = &
!                       &   (writeCounterMAF .and. numquantitiesperfile == 0), &
!                       & hdfVersion=hdfVersion )
                    call WriteL2AUXData ( l2auxDatabase(db_index), outputFile,&
                      & returnStatus, &
                      & WriteCounterMAF = &
                      &   (writeCounterMAF .and. numquantitiesperfile == 0) )
                    error = max(error, returnStatus)
                    numquantitiesperfile = numquantitiesperfile+1
                    if ( DEBUG ) call output(&
                      & "attempting to fill quantity name", advance='yes')
                    if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                      call announce_error ( son, &
                        & 'Attempt to write too many l2aux quantities to a file', &
                        & numquantitiesperfile )
                      numquantitiesperfile = MAXQUANTITIESPERFILE
                    end if
                    call get_string &
                      & ( l2auxDatabase(db_index)%name, &
                      &     QuantityNames(numquantitiesperfile) )
                  else
                    call MLSMessage ( MLSMSG_Warning, ModuleName, &
                      & 'Unable to save l2aux quantity, perhaps no chunks processed' )
                  end if
                end do ! in_field_no = 2, nsons(gson)
              case ( f_overlaps )
                ! ??? More work needed here
              end select
            end do ! field_no = 2, nsons(key)

            ! Now close the file
!            returnStatus = mls_sfend(sdfid, hdfVersion=hdfVersion)
            !        returnStatus = sfend(sdfid)

!             if ( returnStatus /= PGS_S_SUCCESS ) then
!               call announce_error ( son, &
!                 &  "Error closing l2aux file:  "//l2auxPhysicalFilename, returnStatus)
!             else if (index(switches, 'pro') /= 0) then
            if (index(switches, 'pro') /= 0) then
              call announce_success(l2auxPhysicalFilename, 'l2aux', &
                & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
            end if

            if ( .not. TOOLKIT ) cycle

            ! Write the metadata file
            call add_metadata ( son, file_base, numquantitiesperfile, &
              & quantityNames, hdfVersion, l_hdf, metadata_error )

          else if ( returnStatus /= PGS_S_SUCCESS ) then
            call announce_error ( son, &
              &  "Error finding l2aux file matching:  "//file_base, returnStatus)
          end if
d467 1
a467 2
              call announce_success(file_base, 'l2pc', &
                & 0, quantityNames)
a472 14
            ! Later on when HDF5 is 'blessed' I want to move all this code
            ! here instead
            !            call H5FCreate_F ( trim(file_base), H5F_ACC_TRUNC, l2pcUnit, &
            !              & returnStatus )
            !            if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            !              & 'Unable to open hdf5 l2pc file for output.' )
            !            do in_field_no = 2, nsons(quantitiesNode)
            !              db_index = decoration(decoration(subtree(in_field_no, quantitiesNode )))
            !              call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
            !              call writeOneHDF5L2PC ( tmpMatrix, l2pcUnit, packed )
            !            end do ! in_field_no = 2, nsons(gson)
            !            call H5FClose ( l2pcUnit, returnStatus )
            !            if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
            !              & 'Unable to close hdf5 l2pc file.' )
d478 4
a481 80

          ! Get the l2gp file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)
            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
              & mlspcf_l2dgg_end, &
              & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
              & exactName=l2gpPhysicalFilename)
          else
            l2gpPhysicalFilename = file_base
            returnStatus = 0
          end if

         if ( returnStatus == 0 .and. .not. checkPaths ) then
            ! Open the HDF-EOS file and write swath data

!             swfid = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
!               & record_length, DFACC_CREATE, FileName=l2gpPhysicalFilename, &
!               & hdfVersion=hdfVersion, debugOption=.false. )
            outputFile => GetMLSFileByName(filedatabase, l2gpPhysicalFilename)
            if ( .not. associated(outputFile) ) then
              if(DEBUG) call MLSMessage(MLSMSG_Warning, ModuleName, &
                & 'No entry in filedatabase for ' // trim(l2gpPhysicalFilename) )
              outputFile => AddInitializeMLSFile(filedatabase, &
                & content=outputTypeStr, &
                & name=l2gpPhysicalFilename, shortName=file_base, &
                & type=l_swath, access=DFACC_RDWR, HDFVersion=hdfVersion, &
                & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
            endif

            ! Loop over the segments of the l2cf line

            numquantitiesperfile = 0
            do field_no = 2, nsons(key) ! Skip "output" name
              gson = subtree(field_no,key)
              select case ( decoration(subtree(1,gson)) )
              case ( f_quantities )
                do in_field_no = 2, nsons(gson)
                  db_index = -decoration(decoration(subtree(in_field_no ,gson)))
!                   call writeL2GPData ( l2gpDatabase(db_index), swfid, &
!                     & hdfVersion=hdfVersion )
                  call writeL2GPData ( l2gpDatabase(db_index), outputFile )
                  numquantitiesperfile = numquantitiesperfile+1
                  if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                    call announce_error ( son, &
                      & 'Attempt to write too many l2dgg quantities to a file', &
                      & numquantitiesperfile )
                    numquantitiesperfile = MAXQUANTITIESPERFILE
                  end if
                  quantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
                end do ! in_field_no = 2, nsons(gson)
              case ( f_overlaps )
                ! ??? More work needed here
              end select
            end do ! field_no = 2, nsons(key)

!             returnStatus = mls_io_gen_closeF('swclose', swfid, &
!               & hdfVersion=hdfVersion)
!             if ( returnStatus /= PGS_S_SUCCESS ) then
!               call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
!               call MLSMessage ( MLSMSG_Error, ModuleName, &
!                 &  "Error closing  l2dgg file:  "//mnemonic//" "//msg )
!            else if (index(switches, 'pro') /= 0) then
            if (index(switches, 'pro') /= 0) then
              call announce_success(l2gpPhysicalFilename, 'l2dgg', &
                & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
            end if

            if ( .not. TOOLKIT ) cycle

            ! Write the metadata file
            call add_metadata ( son, file_base, numquantitiesperfile, &
              & quantityNames, hdfVersion, output_type, metadata_error )

          else if ( returnStatus /= PGS_S_SUCCESS ) then
            call announce_error ( son, &
              &  "Error finding l2gp file matching:  "//file_base, returnStatus)
          end if

d527 1
a527 153
      if ( debug ) call dump(DirectDatabase)
      ! Any dgg eligible for being catenated
      DB_index = findFirst( DirectDatabase%autoType, l_l2dgg )
      if ( findNext(DirectDatabase%autoType, l_l2dgg, DB_index) > 0 ) then
        if ( TOOLKIT ) then
          l2gp_Version = 1
          l2gpFileHandle = GetPCFromRef('DGG', mlspcf_l2dgg_start, &
            & mlspcf_l2dgg_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2gpPhysicalFilename)
        else
          file_base = DirectDatabase(DB_index)%fileName
          l2gpPhysicalFilename = unSplitName(file_base)
          returnStatus = 0
        end if
        if ( any(DirectDatabase%fileName == l2gpPhysicalFilename) ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Cannot unsplit dgg dw to existing file " // &
            & trim(l2gpPhysicalFilename) )
        end if
        madeFile = .false.
        do DB_index = 1, size(DirectDatabase)
          if ( DirectDatabase(DB_index)%autoType /= l_l2dgg ) cycle
          if ( DEBUG ) then
            call output ( 'preparing to cp split dgg', advance='yes' )
            call output ( 'from: ', advance='no' )
            call output ( trim(DirectDatabase(DB_index)%fileName) , advance='yes' )
            call output ( '   to: ', advance='no' )
            call output ( trim(l2gpPhysicalFilename) , advance='yes' )
          end if
          if ( mls_exists(trim(DirectDatabase(DB_index)%fileName)) /= 0 ) cycle
          madeFile = .true.
          call cpL2GPData(trim(DirectDatabase(DB_index)%fileName), &
            & trim(l2gpPhysicalFilename), create2=(DB_index==1), &
            & hdfVersion1=HDFVERSION_5, hdfVersion2=HDFVERSION_5, &
            & notUnlimited=avoidUnlimitedDims, ReadStatus=.true.)
        end do
        if ( TOOLKIT .and. madeFile ) then
          call add_metadata ( 0, trim(l2gpPhysicalFilename), 1, &
            & (/'dgg'/), HDFVERSION_5, l_l2dgg, returnStatus )
          if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'unable to addmetadata to ' // trim(l2gpPhysicalFilename) )
        end if
        if ( madeFile ) then
         call writeAPrioriAttributes(trim(l2gpPhysicalFilename), HDFVERSION_5)
         outputFile => AddInitializeMLSFile(filedatabase, &
           & content='l2dgg', &
           & name=l2gpPhysicalFilename, shortName='DGG', &
           & type=l_swath, access=DFACC_RDWR, HDFVersion=HDFVERSION_5, &
           & PCBottom=mlspcf_l2dgg_start, PCTop=mlspcf_l2dgg_end)
        end if
      end if
      ! Next we would do the same for any split dgm direct write files
      DB_index = findFirst( DirectDatabase%autoType, l_l2aux )
      if ( findNext(DirectDatabase%autoType, l_l2aux, DB_index) > 0 ) then
        if ( TOOLKIT ) then
          l2gp_Version = 1
          l2gpFileHandle = GetPCFromRef('DGM', mlspcf_l2dgm_start, &
            & mlspcf_l2dgm_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2auxPhysicalFilename)
        else
          file_base = DirectDatabase(DB_index)%fileName
          l2auxPhysicalFilename = unSplitName(file_base)
          returnStatus = 0
        end if
        if ( any(DirectDatabase%fileName == l2auxPhysicalFilename) ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            &  "Must not unsplit dgm dw to " // trim(l2auxPhysicalFilename) )
        end if
        madeFile = .false.
        do DB_index = 1, size(DirectDatabase)
          if ( DirectDatabase(DB_index)%autoType /= l_l2aux ) cycle
          if ( .not. associated(DirectDatabase(DB_index)%sdNames) ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            &  "no sd known for " // trim(DirectDatabase(DB_index)%fileName) )
            cycle
          endif
          ! print *, 'About to try to convert array2List'
          ! call dump(DirectDatabase(DB_index))
          call Array2List(DirectDatabase(DB_index)%sdNames, sdList)
          ! print *, 'result: ', trim(sdList)
          ! Not implemented yet
          if ( DEBUG ) then
            call output ( 'preparing to cp split dgm', advance='yes' )
            call output ( 'from: ', advance='no' )
            call output ( trim(DirectDatabase(DB_index)%fileName) , advance='yes' )
            call output ( '   to: ', advance='no' )
            call output ( trim(l2auxPhysicalFilename) , advance='yes' )
            call output ( '   sdList: ', advance='no' )
            call output ( trim(sdList) , advance='yes' )
          end if
          if ( mls_exists(trim(DirectDatabase(DB_index)%fileName)) /= 0 ) cycle
          madeFile = .true.
          if ( sdList /= ' ' ) then
            call cpL2AUXData(trim(DirectDatabase(DB_index)%fileName), &
            & trim(l2auxPhysicalFilename), create2=(DB_index==1), &
            & hdfVersion=HDFVERSION_5, sdList=trim(sdList))
          else
            ! Last-ditch effort if somehow sdNames empty or Array2List fails
            call cpL2AUXData(trim(DirectDatabase(DB_index)%fileName), &
            & trim(l2auxPhysicalFilename), create2=(DB_index==1), &
            & hdfVersion=HDFVERSION_5)
          end if
          if ( DB_index==1 ) &
            & call CpHDF5GlAttribute ( DirectDatabase(DB_index)%fileName, &
            & l2auxPhysicalFilename, 'Phase Names' )
        end do
        ! Is metadata really needed for l2aux files?
        if ( TOOLKIT .and. madeFile ) then
          call add_metadata ( 0, trim(l2auxPhysicalFilename), 1, &
            & (/'dgm'/), HDFVERSION_5, l_hdf, returnStatus )
          if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'unable to addmetadata to ' // trim(l2auxPhysicalFilename) )
        end if
        
        ! Now we can write any last-minute attributes or datasets to the l2aux
        ! E.g., parallel stuff
        if ( (parallel%master .or. index(switches, 'chu') /= 0) &
          & .and. .not. (checkPaths .or. SKIPDIRECTWRITES) .and. &
          & madeFile .and. l2auxPhysicalFilename /= ' ' ) then
          sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_RDWR, &
              & hdfVersion=HDFVERSION_5)
          call h5gopen_f(sdfId, '/', grp_id, returnStatus)
          if ( .not. parallel%master .and. FAKEPARALLELMASTER ) then
            parallel%numCompletedChunks = 347
            parallel%numFailedChunks = 3
            parallel%FailedChunks = '2,5,129'
            parallel%FailedMachs = 'c0-1,c0-66,c0-66'
            parallel%FailedMachs = 'msg 1\msg 2\msg 3'
          endif
          call MakeHDF5Attribute(grp_id, &
           & 'NumCompletedChunks', parallel%numCompletedChunks, .true.)
          call MakeHDF5Attribute(grp_id, &
           & 'NumFailedChunks', parallel%numFailedChunks, .true.)
          call MakeHDF5Attribute(grp_id, &
           & 'FailedChunks', trim_safe(parallel%FailedChunks), .true.)
          if ( .not. usingSubmit ) &
            call MakeHDF5Attribute(grp_id, &
             & 'FailedMachines', trim_safe(parallel%FailedMachs), .true.)
          call MakeHDF5Attribute(grp_id, &
           & 'FailedMsgs', trim_safe(parallel%FailedMsgs), .true.)
          call h5gclose_f(grp_id, returnStatus)
          returnStatus = mls_sfend(sdfid, hdfVersion=HDFVERSION_5)
          ! Probably excessively complex conditions for whether to add
          ! into database or not
          outputFile => AddInitializeMLSFile(filedatabase, &
           & content='l2aux', &
           & name=l2auxPhysicalFilename, shortName='L2AUX-DGM', &
           & type=l_hdf, access=DFACC_RDWR, HDFVersion=HDFVERSION_5, &
           & PCBottom=mlspcf_l2dgm_start, PCTop=mlspcf_l2dgm_end)
        endif
      end if
d586 2
a587 1
      & Mlspcf_mcf_l2dgm_start, Mlspcf_mcf_l2dgg_start
d617 1
d732 1
a732 1
    character(LEN=*), dimension(:), intent(in) :: quantities
d749 1
a749 1
    if ( num_quants > 0 ) then
d795 484
d1282 1
a1282 1
       "$Id: $"
d1291 3
@


2.107
log
@Should not bomb if catenating split files w/o toolkit
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
d29 3
a31 6
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: IdParm = &
    & "$Id: OutputAndClose.f90,v 2.106 2005/06/14 20:43:49 pwagner Exp $"
  character(len=len(idParm)) :: Id = idParm
  character(len=*), parameter :: ModuleName = &
    & "$RCSfile: OutputAndClose.f90,v $"
d33 1
a33 1
  !-----------------------------------------------------------------------------
d1038 5
d1049 3
@


2.106
log
@Interfaces changed to accept MLSFile_T args
@
text
@d11 1
a11 1
  use DirectWrite_m, only: DirectData_T
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.105 2005/03/15 23:57:23 pwagner Exp $"
d112 1
a112 1
    logical, parameter :: DEBUG = .FALSE.
d614 1
a614 1
    !! if ( .true. .and. associated(DirectDatabase) ) then
d657 8
a664 2
        if ( madeFile ) &
         & call writeAPrioriAttributes(trim(l2gpPhysicalFilename), HDFVERSION_5)
d687 5
d758 7
d1039 3
@


2.105
log
@Makes error messages from about-to-die chunks dgm attributes
@
text
@d12 1
a12 1
  use Hdf, only: DFACC_CREATE, DFACC_RDWR
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.104 2004/12/14 21:45:01 pwagner Exp $"
d42 1
a42 1
    & matrices, canWriteL2PC )
d63 1
a63 1
    use Intrinsic, only: l_swath, l_hdf, PHYQ_Dimensionless
d70 1
a70 1
    use MLSCommon, only: I4
d72 1
a72 1
      & GetPCFromRef, mls_exists, &
d104 1
a131 2
    character (len=32) :: Mnemonic
    character (len=256) :: Msg
d136 2
a142 1
    integer :: record_length
a147 1
    integer :: SWFID
d220 1
a233 16

        if ( DEBUG ) call output('l2gp type number: ', advance='no')
        if ( DEBUG ) call output(l_l2gp, advance='yes')

        if ( DEBUG ) call output('l2aux type number: ', advance='no')
        if ( DEBUG ) call output(l_l2aux, advance='yes')

        if ( DEBUG ) call output('l2dgg type number: ', advance='no')
        if ( DEBUG ) call output(l_l2dgg, advance='yes')

        if ( DEBUG ) call output('output type number: ', advance='no')
        if ( DEBUG ) call output(output_type, advance='yes')

        if ( DEBUG ) call output('file_base: ', advance='no')
        if ( DEBUG ) call output(trim(file_base), advance='yes')

a236 1
          if ( DEBUG ) call output('output file type l2gp', advance='yes')
a240 2
            if ( DEBUG ) call output('file_base after split: ', advance='no')
            if ( DEBUG ) call output(trim(file_base), advance='yes')
a251 2
            if ( DEBUG ) call output(&
              & 'file name: ' // TRIM(l2gpPhysicalFilename), advance='yes')
d254 13
a266 6
            if ( DEBUG ) call output('Attempting swopen', advance='yes')
            !           swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
            swfid = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
              & record_length, DFACC_CREATE, FileName=l2gpPhysicalFilename, &
              & hdfVersion=hdfVersion, debugOption=.false. )

d277 3
a279 2
                    call writeL2GPData ( l2gpDatabase(db_index), swfid, &
                      & hdfVersion=hdfVersion )
a297 1
            if ( DEBUG ) call output('Attempting swclose', advance='yes')
d299 8
a306 7
            returnStatus = mls_io_gen_closeF('swclose', swfid, &
              & hdfVersion=hdfVersion)
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                &  "Error closing  l2gp file:  "//mnemonic//" "//msg )
            else if (index(switches, 'pro') /= 0) then
a322 1
          if ( DEBUG ) call output ( 'output file type l2aux', advance='yes' )
a337 2
            if ( DEBUG ) call output ( 'file name: ' // TRIM(l2auxPhysicalFilename), &
              & advance='yes' )
d339 12
a350 3
            if ( DEBUG ) call output ( 'Attempting sfstart', advance='yes' )
            sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_CREATE, &
              & hdfVersion=hdfVersion)
a351 1
            if ( DEBUG ) call output ( "looping over quantities", advance='yes' )
a357 2
                  if ( DEBUG ) &
                    & call output ( "computing db index", advance='yes')
d360 6
a365 1
                    call WriteL2AUXData ( l2auxDatabase(db_index), sdfid, returnStatus,&
d367 1
a367 2
                      &   (writeCounterMAF .and. numquantitiesperfile == 0), &
                      & hdfVersion=hdfVersion )
d392 1
a392 1
            returnStatus = mls_sfend(sdfid, hdfVersion=hdfVersion)
d395 5
a399 4
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call announce_error ( son, &
                &  "Error closing l2aux file:  "//l2auxPhysicalFilename, returnStatus)
            else if (index(switches, 'pro') /= 0) then
d447 1
a447 1
            l2pcUnit = mls_io_gen_openf ( 'open', .true., error,&
d458 1
a458 1
            error = mls_io_gen_closef ( 'cl', l2pcUnit)
a489 1
          if ( DEBUG ) call output('output file type l2dgg', advance='yes')
a503 2
            if ( DEBUG ) call output(&
              & 'file name: ' // TRIM(l2gpPhysicalFilename), advance='yes')
d506 13
a518 5
            if ( DEBUG ) call output('Attempting swopen', advance='yes')
            !           swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
            swfid = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
              & record_length, DFACC_CREATE, FileName=l2gpPhysicalFilename, &
              & hdfVersion=hdfVersion, debugOption=.false. )
d529 3
a531 2
                  call writeL2GPData ( l2gpDatabase(db_index), swfid, &
                    & hdfVersion=hdfVersion )
d546 8
a553 9
            if ( DEBUG ) call output('Attempting swclose', advance='yes')
            !           returnStatus = swclose(swfid)
            returnStatus = mls_io_gen_closeF('swclose', swfid, &
              & hdfVersion=hdfVersion)
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                &  "Error closing  l2dgg file:  "//mnemonic//" "//msg )
            else if (index(switches, 'pro') /= 0) then
d1021 3
@


2.104
log
@Avoid catenating non-existent split files
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.103 2004/09/23 23:02:46 pwagner Exp $"
d86 1
d173 1
a173 1
    usingSubmit = trim(parallel%submit) /= ''
d732 1
d739 1
a739 1
           & 'FailedChunks', trim(parallel%FailedChunks), .true.)
d742 3
a744 1
             & 'FailedMachines', trim(parallel%FailedMachs), .true.)
d1021 3
@


2.103
log
@DGG gets apriori attrs; master task copies Phase Names from slave DGM
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.102 2004/09/16 23:57:54 pwagner Exp $"
d77 2
a78 1
      & DEFAULT_HDFVERSION_WRITE, PENALTY_FOR_NO_METADATA, TOOLKIT
d180 1
d611 2
a612 1
    if ( CATENATESPLITS .and. associated(DirectDatabase) ) then
d720 3
a722 1
        if ( parallel%master .or. index(switches, 'chu') /= 0 ) then
d1017 3
@


2.102
log
@Now tracks machine names of failed chunks
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.101 2004/09/16 00:19:05 pwagner Exp $"
d75 1
a75 1
    use MLSHDF5, only: MakeHDF5Attribute
d87 1
d653 2
d703 3
d1012 3
@


2.101
log
@Writes info on completed, failed chunks to l2aux as global attrs
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.100 2004/08/26 18:52:56 pwagner Exp $"
d34 1
d149 1
d170 2
d715 6
d727 3
d1006 3
@


2.100
log
@Fixed checkPaths bug if outputting l2pc
@
text
@d12 1
a12 2
! use DirectWrite_m, only: dump
  use Hdf, only: DFACC_CREATE
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.99 2004/08/04 23:19:58 pwagner Exp $"
d61 1
d67 1
d74 1
d112 1
d704 16
d993 3
@


2.99
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d24 1
a24 1
    & "$Id: OutputAndClose.f90,v 2.98 2004/06/10 00:58:45 vsnyder Exp $"
d410 1
d974 3
@


2.98
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d24 1
a24 1
    & "$Id: OutputAndClose.f90,v 2.97 2004/05/19 20:22:09 vsnyder Exp $"
d81 1
a81 1
    use MLSStrings, only: Array2List
d973 3
@


2.97
log
@Remove USEs for unreferenced symbols, polish some cannonballs
@
text
@d24 1
a24 1
    & "$Id: OutputAndClose.f90,v 2.96 2004/04/24 00:22:55 pwagner Exp $"
d68 1
a68 2
    use MLSCommon, only: I4, findFirst, findNext
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
d75 1
d80 1
d85 1
a86 1
    use TOGGLES, only: GEN, TOGGLE, Switches
d603 2
a604 2
      DB_index = findFirst( DirectDatabase%autoType == l_l2dgg )
      if ( findNext(DirectDatabase%autoType == l_l2dgg, DB_index) > 0 ) then
d646 2
a647 2
      DB_index = findFirst( DirectDatabase%autoType == l_l2aux )
      if ( findNext(DirectDatabase%autoType == l_l2aux, DB_index) > 0 ) then
d973 3
@


2.96
log
@Forcibly sets ReadStatus when knitting DGG; prunes L2GP- prefix from file_base
@
text
@d11 2
a12 1
  use DirectWrite_m, only: DirectData_T, dump
d24 1
a24 1
    & "$Id: OutputAndClose.f90,v 2.95 2004/03/12 00:39:37 pwagner Exp $"
d62 1
a62 2
    use Intrinsic, only: l_swath, l_grid, l_hdf, &
      & PHYQ_Dimensionless
d88 1
a88 2
    use WriteMetadata, only: L2PCF, Populate_metadata_std, &
      & Populate_metadata_oth, WriteMetaLog, Get_l2gp_mcf
d317 1
a317 1
          elseif ( returnStatus /= PGS_S_SUCCESS ) then
d403 1
a403 1
          elseif ( returnStatus /= PGS_S_SUCCESS ) then
d551 1
a551 1
          elseif ( returnStatus /= PGS_S_SUCCESS ) then
d563 1
a563 1
          endif
d614 1
a614 1
        endif
d619 1
a619 1
        endif
d629 1
a629 1
          endif
d636 1
a636 1
        enddo
d642 2
a643 2
        endif
      endif
d657 1
a657 1
        endif
d661 1
a661 1
        endif
d678 1
a678 1
          endif
d690 2
a691 2
          endif
        enddo
d698 3
a700 3
        endif
      endif
    endif
d754 1
a754 1
    use Intrinsic, only: l_swath, l_grid, l_hdf
d758 1
a758 2
      & Mlspcf_mcf_l2gp_start, Mlspcf_mcf_l2dgm_start, &
      & Mlspcf_mcf_l2dgg_start
d796 1
a796 1
     endif
d809 1
a809 1
     endif
d813 1
a813 1
     elseif ( l2gp_mcf <= -999 ) then
d865 1
a865 1
     elseif ( DEBUG ) then
d972 3
@


2.95
log
@Interface to cpL2GPData changed to match
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.94 2004/03/03 19:23:48 pwagner Exp $"
d636 1
a636 1
            & notUnlimited=avoidUnlimitedDims)
d773 1
d775 1
d795 4
d974 3
@


2.94
log
@Master task never knows actual sdList to catenate; let cpL2AUXData figure it out
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.93 2004/02/19 23:57:47 pwagner Exp $"
d635 2
a636 1
            & hdfVersion=HDFVERSION_5, notUnlimited=avoidUnlimitedDims)
d968 3
@


2.93
log
@Hopefully will not try to write metadata if no file exists
@
text
@d11 1
a11 1
  use DirectWrite_m, only: DirectData_T
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.92 2004/02/05 23:35:21 pwagner Exp $"
d618 2
a619 2
            &  "Cant not unsplit dgg dw to existing file " // &
            &trim(l2gpPhysicalFilename) )
d660 1
a660 1
            &  "Must not unsplit dgg dw to " // trim(l2auxPhysicalFilename) )
d665 2
d668 1
d681 2
a682 1
          call cpL2AUXData(trim(DirectDatabase(DB_index)%fileName), &
d685 6
d967 3
@


2.92
log
@Fixed some bugs in catenating split dgg/dgm directwrites
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.91 2004/01/27 21:37:26 pwagner Exp $"
d71 1
a71 1
      & GetPCFromRef, &
d120 1
d618 2
a619 1
            &  "Must not unsplit dgg dw to " // trim(l2gpPhysicalFilename) )
d621 1
d631 2
d637 1
a637 1
        if ( TOOLKIT ) then
d662 1
d676 2
d682 6
a687 1
        if ( TOOLKIT ) then
d957 3
@


2.91
log
@Can catenate split l2aux files
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.90 2004/01/23 01:15:00 pwagner Exp $"
d64 2
a65 1
    use L2GPData, only: L2GPData_T, cpL2GPData, WriteL2GPData, L2GPNameLen
d80 1
d137 1
d600 1
d615 4
d621 10
a630 3
          call cpL2GPData(trim(l2gpPhysicalFilename), &
            & trim(DirectDatabase(DB_index)%fileName), create2=(DB_index==1), &
            & hdfVersion=HDFVERSION_5)
d653 4
d659 1
d661 12
a672 3
          call cpL2AUXData(trim(l2auxPhysicalFilename), &
            & trim(DirectDatabase(DB_index)%fileName), create2=(DB_index==1), &
            & hdfVersion=HDFVERSION_5)
d749 1
a749 1
  logical, parameter :: DEBUG = .true.
d944 3
@


2.90
log
@Began effort to catenate split direct write files
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.89 2004/01/22 00:52:19 pwagner Exp $"
d63 1
a63 1
    use L2AUXData, only: L2AUXDATA_T, WriteL2AUXData
a342 1
            !        sdfId = sfstart(l2auxPhysicalFilename, DFACC_CREATE)
d641 3
a643 3
          ! call cpL2aux(trim(l2auxPhysicalFilename), &
          !   & trim(DirectDatabase(DB_index)%fileName), create2=(DB_index==1), &
          !   & hdfVersion=HDFVERSION_5)
d915 3
@


2.89
log
@Small changes regarding metadata
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.88 2003/11/07 00:46:51 pwagner Exp $"
d64 1
a64 1
    use L2GPData, only: L2GPData_T, WriteL2GPData, L2GPNameLen
d67 1
a67 1
    use MLSCommon, only: I4
d70 5
a74 4
      & GetPCFromRef, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
      & SPLIT_PATH_NAME, MLS_SFSTART, MLS_SFEND
    use MLSL2Options, only: CHECKPATHS, PENALTY_FOR_NO_METADATA, TOOLKIT, &
      & DEFAULT_HDFVERSION_WRITE
d594 62
d657 3
a659 10
      ! Write the log file metadata
      if ( LOGFILEGETSMETADATA .and. .not. checkPaths ) then
        if ( DEBUG ) then
          call output('About to write log file metadata' , advance='yes')
        end if

        if ( TOOLKIT ) then
          call writeMetaLog ( metadata_error )
          error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
        end if
d661 1
d663 1
a663 1
      ! Done with text of PCF file at last
d665 2
a666 2
      if ( DEBUG ) &
        & call output ( 'About to deallocate text of PCF file' , advance='yes' )
d668 1
a668 1
      call deallocate_test ( l2pcf%anText, 'anText of PCF file', moduleName )
d670 4
a673 4
      if (index(switches, 'pro') /= 0) then
        call output ( '============ End Level 2 Products ============', advance='yes' )
        call output ( ' ', advance='yes' )
      end if
d916 3
@


2.88
log
@New quicker preflight option: --checkPaths
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.87 2003/10/28 21:42:36 pwagner Exp $"
d311 2
a312 2
            call add_metadata ( file_base, numquantitiesperfile, quantityNames, &
              & hdfVersion, l_swath, metadata_error )
d397 2
a398 2
            call add_metadata ( file_base, numquantitiesperfile, quantityNames, &
              & hdfVersion, l_hdf, metadata_error )
d545 2
a546 2
            call add_metadata ( file_base, numquantitiesperfile, quantityNames, &
              & hdfVersion, output_type, metadata_error )
d642 3
a644 2
  subroutine add_metadata ( fileName, numquantitiesperfile, quantityNames, &
    & hdfVersion, filetype, metadata_error )
d655 1
d772 2
d775 2
a776 1
      & "Unrecognized filetype in add_metadata (must be swath or hdf) ")
d845 4
a848 2
      select case ( code )
      end select
d859 3
@


2.87
log
@Exits with message if cant GetPCFFromRef
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.86 2003/10/20 23:59:20 pwagner Exp $"
d72 1
a72 1
    use MLSL2Options, only: PENALTY_FOR_NO_METADATA, TOOLKIT, &
d254 1
a254 1
          if ( returnStatus == 0 ) then
d313 1
a313 1
          else
d334 1
a334 1
          if ( returnStatus == 0 ) then
d400 1
a400 1
          else
d408 1
d493 1
a493 1
          if ( returnStatus == 0 ) then
d548 1
a548 1
          else
d595 1
a595 1
      if ( LOGFILEGETSMETADATA ) then
d852 3
@


2.86
log
@Simplified code for writing metadata
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.85 2003/10/16 18:29:35 pwagner Exp $"
d694 4
a697 1
     if ( l2gp_mcf <= -999 ) then
d746 4
a749 1
     if ( DEBUG ) then
d851 3
@


2.85
log
@Should not try to write metadata twice on DirectWrite files
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.84 2003/09/19 23:29:27 pwagner Exp $"
d311 2
a312 62

            call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf  )

	         if ( l2gp_mcf <= -999 ) then
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
                &  "no mcf for this l2gp species in" // trim(file_base) )
		
            else if ( l2gp_mcf <= 0 ) then

              ! Error in finding mcf number
              call announce_error ( son, &
                & 'No mcf numbers correspond to this l2gp file: ' &
                & // trim(file_base), l2gp_mcf, &
                & PENALTY_FOR_NO_METADATA )

            else if ( numquantitiesperfile <= 0 ) then

              ! Error in number of quantities
              call announce_error ( son, &
                & 'No quantities written for this l2gp file')

            else if ( QuantityNames(numquantitiesperfile) &
              & == QuantityNames(1) ) then

              ! Typical homogeneous l2gp file: 
              ! e.g., associated with BrO is ML2BRO.001.MCF
              if ( DEBUG ) then
                call output('preparing to populate metadata_std', advance='yes')
                call output('l2gpFileHandle: ', advance='no')
                call output(l2gpFileHandle , advance='no')
                call output('   l2gp_mcf: ', advance='no')
                call output(l2gp_mcf , advance='no')
                call output('   swfid: ', advance='no')
                call output(swfid , advance='yes')
              end if

              call populate_metadata_std &
                & (l2gpFileHandle, l2gp_mcf, QuantityNames(1), &
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype=l_swath )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
            else

              ! Type l2gp file 'other'
              if ( DEBUG ) then
                call output ( 'preparing to populate metadata_oth', advance='yes' )
                call output ( 'l2gpFileHandle: ', advance='no' )
                call output ( l2gpFileHandle , advance='no' )
                call output ( '   l2gp_mcf: ', advance='no' )
                call output ( l2gp_mcf , advance='no' )
                call output ( '   swfid: ', advance='no' )
                call output ( swfid , advance='yes')
              end if

              call populate_metadata_oth &
                & ( l2gpFileHandle, l2gp_mcf, &
                & numquantitiesperfile, QuantityNames, &
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype=l_swath  )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
            end if

d397 2
a398 30
            if ( numquantitiesperfile <= 0 ) then
              call announce_error ( son, &
                & 'No quantities written for this l2aux file')
            else

              ! We may need to think more about this; until then reuse
              ! populate_metadata_oth, but with l2aux_mcf
              if ( DEBUG ) then
                call output ( 'preparing to populate metadata_oth', advance='yes' )
                call output ( 'l2auxFileHandle: ', advance='no' )
                call output ( l2auxFileHandle , advance='no' )
                call output ( '   l2aux_mcf: ', advance='no' )
                call output ( l2aux_mcf , advance='no' )
                call output ( '   sdfId: ', advance='no' )
                call output ( sdfId , advance='yes' )
                call output ( '   number of quantities: ', advance='no' )
                call output ( numquantitiesperfile , advance='yes' )
                do field_no=1, numquantitiesperfile
                  call output ( field_no , advance='no' )
                  call output ( '       ', advance='no' )
                  call output ( trim(QuantityNames(field_no)) , advance='yes' )
                end do
              end if
              call populate_metadata_oth &
                & ( l2auxFileHandle, l2aux_mcf, &
                & numquantitiesperfile, QuantityNames,&
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype=l_hdf  )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
            end if
d544 2
a545 27

            if ( numquantitiesperfile <= 0 ) then

              ! Error in number of quantities
              call announce_error ( son, &
                & 'No quantities written for this l2dgg file')

            else

              ! Similar to type l2gp file 'other'
              if ( DEBUG ) then
                call output ( 'preparing to populate metadata_oth', advance='yes' )
                call output ( 'l2gpFileHandle: ', advance='no' )
                call output ( l2gpFileHandle , advance='no' )
                call output ( '   l2dgg_mcf: ', advance='no' )
                call output ( mlspcf_mcf_l2dgg_start , advance='no' )
                call output ( '   swfid: ', advance='no' )
                call output ( swfid , advance='yes' )
              end if

              call populate_metadata_oth &
                & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, &
                & numquantitiesperfile, QuantityNames, &
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype=l_swath  )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
            end if
a592 166
    ! Write metadata for any directdata files
    ! No--metadata has already been written
    ! add_metadata called from Join module back when file was first created
    if ( associated ( directDatabase )  .and. .FALSE. ) then
      if ( size(DirectDatabase) > 0 .and. TOOLKIT ) then
        meta_name = ' '
        do DB_index=1, size(DirectDatabase)
          hdfVersion = HDFVERSION_5      ! Because DirectWrite only allows 5
          l2gp_Version = 1
          l2aux_Version = 1
          file_base = DirectDatabase(DB_index)%fileNameBase
          output_type = DirectDatabase(DB_index)%type
          numquantitiesperfile = size(DirectDatabase(DB_index)%sdNames)
          do quantitiesnode=1, numquantitiesperfile
            QuantityNames(quantitiesnode) = &
              & DirectDatabase(DB_index)%sdNames(quantitiesnode)
          enddo
          select case ( output_type )
          case ( l_l2gp ) ! --------------------- Writing l2gp files -----
            if ( DEBUG ) call output('output file type l2gp', advance='yes')
            ! Get the l2gp file name from the PCF

            if ( DEBUG ) call output('file_base after split: ', advance='no')
            if ( DEBUG ) call output(trim(file_base), advance='yes')

            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
              & mlspcf_l2gp_end, &
              & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
              & exactName=l2gpPhysicalFilename)
            ! Write the metadata file

            call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf  )

	         if ( l2gp_mcf <= -999 ) then
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
                &  "no mcf for this l2gp species in" // trim(file_base) )
		
            else if ( l2gp_mcf <= 0 ) then

              ! Error in finding mcf number
              call announce_error ( son, &
                & 'No mcf numbers correspond to this l2gp file: ' &
                & // trim(file_base), l2gp_mcf, &
                & PENALTY_FOR_NO_METADATA )

            else if ( numquantitiesperfile <= 0 ) then

              ! Error in number of quantities
              call announce_error ( son, &
                & 'No quantities written for this l2gp file')

            else if ( QuantityNames(numquantitiesperfile) &
              & == QuantityNames(1) ) then

              ! Typical homogeneous l2gp file: 
              ! e.g., associated with BrO is ML2BRO.001.MCF
              if ( DEBUG ) then
                call output('preparing to populate metadata_std', advance='yes')
                call output('l2gpFileHandle: ', advance='no')
                call output(l2gpFileHandle , advance='no')
                call output('   l2gp_mcf: ', advance='no')
                call output(l2gp_mcf , advance='no')
                call output('   swfid: ', advance='no')
                call output(swfid , advance='yes')
              end if

              call populate_metadata_std &
                & (l2gpFileHandle, l2gp_mcf, QuantityNames(1), &
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype=l_swath )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)

            else

              ! Type l2gp file 'other'
              if ( DEBUG ) then
                call output ( 'preparing to populate metadata_oth', advance='yes' )
                call output ( 'l2gpFileHandle: ', advance='no' )
                call output ( l2gpFileHandle , advance='no' )
                call output ( '   l2gp_mcf: ', advance='no' )
                call output ( l2gp_mcf , advance='no' )
                call output ( '   swfid: ', advance='no' )
                call output ( swfid , advance='yes' )
              end if

              call populate_metadata_oth &
                & ( l2gpFileHandle, l2gp_mcf, &
                & numquantitiesperfile, QuantityNames, &
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype=l_swath  )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
            end if
          case ( l_l2aux ) ! ------------------------------ Writing l2aux files ---

            if ( DEBUG ) call output ( 'output file type l2aux', advance='yes' )
            ! Get the l2aux file name from the PCF

            call split_path_name(file_base, path, file_base)
            l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
              & mlspcf_l2dgm_end, &
              & TOOLKIT, returnStatus, l2aux_Version, DEBUG, &
              & exactName=l2auxPhysicalFilename)
            if ( DEBUG ) then
              call output ( 'preparing to populate metadata_oth', advance='yes' )
              call output ( 'l2auxFileHandle: ', advance='no' )
              call output ( l2auxFileHandle , advance='no' )
              call output ( '   l2aux_mcf: ', advance='no' )
              call output ( l2aux_mcf , advance='no' )
              call output ( '   sdfId: ', advance='no' )
              call output ( sdfId , advance='yes' )
              call output ( '   number of quantities: ', advance='no' )
              call output ( numquantitiesperfile , advance='yes' )
              do field_no=1, numquantitiesperfile
                call output ( field_no , advance='no' )
                call output ( '       ', advance='no' )
                call output ( trim(QuantityNames(field_no)) , advance='yes' )
              end do
            end if
            call populate_metadata_oth &
              & ( l2auxFileHandle, l2aux_mcf, &
              & numquantitiesperfile, QuantityNames,&
              & hdfVersion=hdfVersion, metadata_error=metadata_error, &
              & filetype=l_hdf  )
            error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
          case ( l_l2pc ) ! ------------------------------ Writing l2pc files --
            ! I intend to completely ignore the PCF file in this case,
            ! it's not worth the effort!
            call MLSMessage(MLSMSG_Error,ModuleName,&
              & "Cannot write metadata to l2pc files ")
          case ( l_l2dgg ) ! --------------------- Writing l2dgg files -----

            if ( DEBUG ) call output('output file type l2dgg', advance='yes')
            ! Get the l2gp file name from the PCF

            call split_path_name(file_base, path, file_base)
            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
              & mlspcf_l2dgg_end, &
              & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
              & exactName=l2gpPhysicalFilename)
            if ( DEBUG ) then
              call output ( 'preparing to populate metadata_oth', advance='yes' )
              call output ( 'l2gpFileHandle: ', advance='no' )
              call output ( l2gpFileHandle , advance='no' )
              call output ( '   l2dgg_mcf: ', advance='no' )
              call output ( mlspcf_mcf_l2dgg_start , advance='no' )
              call output ( '   swfid: ', advance='no' )
              call output ( swfid , advance='yes' )
            end if

            call populate_metadata_oth &
              & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, &
              & numquantitiesperfile, QuantityNames, &
              & hdfVersion=hdfVersion, metadata_error=metadata_error, &
              & filetype=l_swath  )
            error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
          case default
            ! call announce_error ( ROOT, &
            !  &  "Error--unknown output type: parser should have caught this")
            call MLSMessage(MLSMSG_Warning, ModuleName,&
              & "Cannot write metadata to unknown DirectWrite output type " &
              & // trim(file_base))

          end select
        enddo
      end if

a615 1
    end if
d845 3
@


2.84
log
@Should not be a metadata error when DirectWrite-ing CH3CN
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.83 2003/09/04 22:42:47 pwagner Exp $"
d707 3
a709 1
    if ( associated ( directDatabase ) ) then
d1125 3
@


2.83
log
@Some tweaks relating to DirectWrite; may not matter
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.82 2003/08/15 20:43:10 pwagner Exp $"
d314 1
a314 1
	    if ( l2gp_mcf <= -999 ) then
d737 5
a741 1
            if ( l2gp_mcf <= 0 ) then
d1123 3
@


2.82
log
@Downgraded to warning if directwrite output_type unkown, e.g. l_l2fwm
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.81 2003/08/08 23:06:39 livesey Exp $"
d69 2
a70 1
    use MLSFiles, only: GetPCFromRef, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
d322 2
a323 1
                & 'No mcf numbers correspond to this l2gp file', l2gp_mcf, &
d709 1
d711 1
d741 2
a742 1
                & 'No mcf numbers correspond to this l2gp file', l2gp_mcf, &
a954 4
     FileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
       & mlspcf_l2gp_end, &
       & .true., returnStatus, Version, DEBUG, &
       & exactName=PhysicalFilename)
d956 4
d962 4
d1119 3
@


2.81
log
@Added the dontPack option on outputing l2pc files.
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.80 2003/08/01 20:07:44 pwagner Exp $"
d372 1
a372 1
            call announce_error ( ROOT, &
d445 1
a445 1
              call announce_error ( root, &
d487 1
a487 1
            call announce_error ( root, &
d659 1
a659 1
            call announce_error ( ROOT, &
d665 2
a666 1
          call announce_error ( ROOT, &
d668 17
d697 1
a697 1
        call announce_error ( ROOT, &
d851 5
a855 2
            call announce_error ( ROOT, &
              &  "Error--unknown output type: parser should have caught this")
d1110 3
@


2.80
log
@Fixed Toolkit bug; metadata distinguishes l2dgg from l2gp
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.79 2003/07/23 18:29:32 cvuu Exp $"
d55 1
a55 1
    use Allocate_Deallocate, only: Deallocate_Test
d59 1
a59 1
      & F_TYPE, F_WRITECOUNTERMAF, &
d100 1
d122 1
d148 1
d508 5
d542 2
a543 1
            call OutputHDF5L2PC ( trim(file_base), matrices, quantitiesNode, packed )
d560 1
d1089 3
@


2.79
log
@quick and dirty fixed for CH3CN
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.78 2003/07/07 23:49:11 pwagner Exp $"
d680 2
d881 1
d904 1
d912 3
d917 1
a917 1
  case (l_swath)
d923 5
a927 1
     call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf  )
d931 1
d1079 3
@


2.78
log
@Add_metadata procedure now public
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.77 2003/07/07 17:31:44 livesey Exp $"
d219 1
a219 1
        if ( DEBUG ) call output(l_l2gp, advance='yes')
d310 5
a314 1
            if ( l2gp_mcf <= 0 ) then
a346 1

d357 1
a357 1
                call output ( swfid , advance='yes' )
d841 1
a841 1

d876 1
a876 1
  ! ---------------------------------------------  announce_success  -----
d917 7
d1067 3
@


2.77
log
@Mainly cosmetic changes
@
text
@d19 1
a19 1
  public :: Output_Close
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.76 2003/06/26 00:17:17 pwagner Exp $"
d41 1
a41 1
    & matrices, l2pcf, canWriteL2PC )
d61 2
a62 1
    use Intrinsic, only: PHYQ_Dimensionless
d84 1
a84 1
    use WriteMetadata, only: PCFData_T, Populate_metadata_std, &
d94 1
a94 1
    type(PCFData_T), intent(in) :: l2pcf
d308 1
a308 1
            call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf, l2pcf  )
d339 1
a339 1
                & (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
d341 1
a341 1
                & filetype='sw' )
d358 1
a358 1
                & ( l2gpFileHandle, l2gp_mcf, l2pcf, &
d361 1
a361 1
                & filetype='sw'  )
d473 1
a473 1
                & ( l2auxFileHandle, l2aux_mcf, l2pcf, &
d476 1
a476 1
                & filetype='hdf'  )
d638 1
a638 1
                & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, l2pcf, &
d641 1
a641 1
                & filetype='sw'  )
d698 1
a698 1
            call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf, l2pcf  )
d729 1
a729 1
                & (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
d731 1
a731 1
                & filetype='sw' )
d748 1
a748 1
                & ( l2gpFileHandle, l2gp_mcf, l2pcf, &
d751 1
a751 1
                & filetype='sw'  )
d781 1
a781 1
              & ( l2auxFileHandle, l2aux_mcf, l2pcf, &
d784 1
a784 1
              & filetype='hdf'  )
d812 1
a812 1
              & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, l2pcf, &
d815 1
a815 1
              & filetype='sw'  )
d832 1
a832 1
          call writeMetaLog ( l2pcf, metadata_error )
d873 108
d1057 3
@


2.76
log
@Writes metadata to all files in DirectDataBase
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.75 2003/06/24 23:54:07 pwagner Exp $"
d46 1
a46 1
    
d150 149
a298 149
   if (index(switches, 'pro') /= 0) then
    call output ( '============ Level 2 Products ============', advance='yes' )
    call output ( ' ', advance='yes' )
   end if

   ! l2gp_mcf will be incremented in get_l2gp_mcf (if MCFFORL2GPOPTION == 1)
   l2gp_mcf = mlspcf_mcf_l2gp_start - 1   

   l2aux_mcf = mlspcf_mcf_l2dgm_start
   l2dgg_mcf = mlspcf_mcf_l2dgg_start

   ! Loop over the lines in the l2cf

   do spec_no = 2, nsons(root)-1 ! Skip name at begin and end of section

     l2gp_Version = 1
     l2aux_Version = 1
     hdfVersion = DEFAULT_HDFVERSION_WRITE
     meta_name = ''
     writeCounterMAF = .false.
     writeMetaDataOnly = .false.

     son = subtree(spec_no,root)
     if ( node_id(son) == n_named ) then ! Is spec labeled?
       key = subtree(2,son)
       name = sub_rosa(subtree(1,son))
     else ! Son is n_spec_args
       key = son
       name = 0
     end if

     select case( get_spec_id(key) )
     case ( s_output )
       do field_no = 2, nsons(key)       ! Skip the command name
         gson = subtree(field_no, key)   ! An assign node
         if ( nsons(gson) > 1 ) then
           fieldValue = decoration(subtree(2,gson)) ! The field's value
         else
           fieldValue = gson
         end if
         field_index = decoration(subtree(1,gson))
         select case ( field_index )   ! Field name
         case ( f_file )
           call get_string ( sub_rosa(subtree(2,gson)), file_base )
           file_base = file_base(2:LEN_TRIM(file_base)-1) ! Parser includes quotes
         case ( f_metaName )
           call get_string ( sub_rosa(subtree(2,gson)), meta_name )
           meta_name = meta_name(2:LEN_TRIM(meta_name)-1) ! Parser includes quotes
         case ( f_type )
           output_type = decoration(subtree(2,gson))
         case ( f_writeCounterMAF )
           writeCounterMAF = get_boolean ( fieldValue )
         case ( f_MetaDataOnly )
           writeMetaDataOnly = get_boolean ( fieldValue )
         case ( f_hdfVersion )
           call expr ( subtree(2,gson), units, value, type )
           if ( units(1) /= phyq_dimensionless ) &
             & call Announce_error ( gson, &
               & 'No units allowed for hdfVersion: just integer 4 or 5')
           hdfVersion = value(1)
         case default                  ! Everything else processed later
         end select
       end do

       if ( DEBUG ) call output('l2gp type number: ', advance='no')
       if ( DEBUG ) call output(l_l2gp, advance='yes')

       if ( DEBUG ) call output('l2aux type number: ', advance='no')
       if ( DEBUG ) call output(l_l2gp, advance='yes')

       if ( DEBUG ) call output('l2dgg type number: ', advance='no')
       if ( DEBUG ) call output(l_l2dgg, advance='yes')

       if ( DEBUG ) call output('output type number: ', advance='no')
       if ( DEBUG ) call output(output_type, advance='yes')

       if ( DEBUG ) call output('file_base: ', advance='no')
       if ( DEBUG ) call output(trim(file_base), advance='yes')

       ! Otherwise--normal output commands
       select case ( output_type )
       case ( l_l2gp ) ! --------------------- Writing l2gp files -----
         if ( DEBUG ) call output('output file type l2gp', advance='yes')
         ! Get the l2gp file name from the PCF

         if ( TOOLKIT ) then
           call split_path_name(file_base, path, file_base)
          if ( DEBUG ) call output('file_base after split: ', advance='no')
          if ( DEBUG ) call output(trim(file_base), advance='yes')

           l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
           & mlspcf_l2gp_end, &
           & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
           & exactName=l2gpPhysicalFilename)
         else
           l2gpPhysicalFilename = file_base
           returnStatus = 0
         end if

         if ( returnStatus == 0 ) then
           if ( DEBUG ) call output(&
             & 'file name: ' // TRIM(l2gpPhysicalFilename), advance='yes')
           ! Open the HDF-EOS file and write swath data

           if ( DEBUG ) call output('Attempting swopen', advance='yes')
!           swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
           swfid = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
            & record_length, DFACC_CREATE, FileName=l2gpPhysicalFilename, &
            & hdfVersion=hdfVersion, debugOption=.false. )

           ! Loop over the segments of the l2cf line

           numquantitiesperfile = 0
           do field_no = 2, nsons(key) ! Skip "output" name
             gson = subtree(field_no,key)
             select case ( decoration(subtree(1,gson)) )
             case ( f_quantities )
               do in_field_no = 2, nsons(gson)
                 db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                 if ( db_index >= 1 ) then
                   call writeL2GPData ( l2gpDatabase(db_index), swfid, &
                    & hdfVersion=hdfVersion )
                   numquantitiesperfile = numquantitiesperfile+1
                   if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                     call announce_error ( son, &
                       & 'Attempt to write too many l2gp quantities to a file', &
                       & numquantitiesperfile )
                     numquantitiesperfile = MAXQUANTITIESPERFILE
                   end if
                   quantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
                 else
                   call MLSMessage ( MLSMSG_Warning, ModuleName, &
                     & 'Unable to write quantity to l2gp file, perhaps no chunks processed' )
                 end if
               end do ! in_field_no = 2, nsons(gson)
             case ( f_overlaps )
               ! ??? More work needed here
             end select
           end do ! field_no = 2, nsons(key)

           if ( DEBUG ) call output('Attempting swclose', advance='yes')
!           returnStatus = swclose(swfid)
           returnStatus = mls_io_gen_closeF('swclose', swfid, &
            & hdfVersion=hdfVersion)
           if ( returnStatus /= PGS_S_SUCCESS ) then
             call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
             call MLSMessage ( MLSMSG_Error, ModuleName, &
               &  "Error closing  l2gp file:  "//mnemonic//" "//msg )
           else if (index(switches, 'pro') /= 0) then
d300 2
a301 2
              & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
           end if
d303 1
a303 1
           if ( .not. TOOLKIT ) cycle
d305 1
a305 1
           ! Write the metadata file
d307 1
a307 1
           call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf, l2pcf  )
d309 132
a440 132
           if ( l2gp_mcf <= 0 ) then

             ! Error in finding mcf number
             call announce_error ( son, &
               & 'No mcf numbers correspond to this l2gp file', l2gp_mcf, &
               & PENALTY_FOR_NO_METADATA )

           else if ( numquantitiesperfile <= 0 ) then

             ! Error in number of quantities
             call announce_error ( son, &
               & 'No quantities written for this l2gp file')

           else if ( QuantityNames(numquantitiesperfile) &
             & == QuantityNames(1) ) then

             ! Typical homogeneous l2gp file: 
             ! e.g., associated with BrO is ML2BRO.001.MCF
             if ( DEBUG ) then
               call output('preparing to populate metadata_std', advance='yes')
               call output('l2gpFileHandle: ', advance='no')
               call output(l2gpFileHandle , advance='no')
               call output('   l2gp_mcf: ', advance='no')
               call output(l2gp_mcf , advance='no')
               call output('   swfid: ', advance='no')
               call output(swfid , advance='yes')
             end if

             call populate_metadata_std &
               & (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
               & hdfVersion=hdfVersion, metadata_error=metadata_error, &
               & filetype='sw' )
             error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)

           else

             ! Type l2gp file 'other'
             if ( DEBUG ) then
               call output ( 'preparing to populate metadata_oth', advance='yes' )
               call output ( 'l2gpFileHandle: ', advance='no' )
               call output ( l2gpFileHandle , advance='no' )
               call output ( '   l2gp_mcf: ', advance='no' )
               call output ( l2gp_mcf , advance='no' )
               call output ( '   swfid: ', advance='no' )
               call output ( swfid , advance='yes' )
             end if

             call populate_metadata_oth &
               & ( l2gpFileHandle, l2gp_mcf, l2pcf, &
               & numquantitiesperfile, QuantityNames, &
               & hdfVersion=hdfVersion, metadata_error=metadata_error, &
               & filetype='sw'  )
             error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
           end if

         else
           call announce_error ( ROOT, &
             &  "Error finding l2gp file matching:  "//file_base, returnStatus)
         end if

       case ( l_l2aux ) ! ------------------------------ Writing l2aux files ---

         if ( DEBUG ) call output ( 'output file type l2aux', advance='yes' )
         ! Get the l2aux file name from the PCF

         if ( TOOLKIT ) then
           call split_path_name(file_base, path, file_base)
           l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
           & mlspcf_l2dgm_end, &
           & TOOLKIT, returnStatus, l2aux_Version, DEBUG, &
           & exactName=l2auxPhysicalFilename)
         else
           l2auxPhysicalFilename = file_base
           returnStatus = 0
         end if

         if ( returnStatus == 0 ) then

           if ( DEBUG ) call output ( 'file name: ' // TRIM(l2auxPhysicalFilename), &
             & advance='yes' )
           ! Create the HDF file and initialize the SD interface
           if ( DEBUG ) call output ( 'Attempting sfstart', advance='yes' )
           sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_CREATE, &
           & hdfVersion=hdfVersion)
  !        sdfId = sfstart(l2auxPhysicalFilename, DFACC_CREATE)

           if ( DEBUG ) call output ( "looping over quantities", advance='yes' )
           numquantitiesperfile = 0
           do field_no = 2, nsons(key) ! Skip "output" name
             gson = subtree(field_no,key)
             select case ( decoration(subtree(1,gson)) )
             case ( f_quantities )
               do in_field_no = 2, nsons(gson)
                 if ( DEBUG ) &
                   & call output ( "computing db index", advance='yes')
                 db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                 if ( db_index >= 1 ) then
                   call WriteL2AUXData ( l2auxDatabase(db_index), sdfid, returnStatus,&
                     & WriteCounterMAF = &
                     &   (writeCounterMAF .and. numquantitiesperfile == 0), &
                     & hdfVersion=hdfVersion )
                   error = max(error, returnStatus)
                   numquantitiesperfile = numquantitiesperfile+1
                   if ( DEBUG ) call output(&
                     & "attempting to fill quantity name", advance='yes')
                   if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                     call announce_error ( son, &
                       & 'Attempt to write too many l2aux quantities to a file', &
                       & numquantitiesperfile )
                     numquantitiesperfile = MAXQUANTITIESPERFILE
                   end if
                   call get_string &
                     & ( l2auxDatabase(db_index)%name, &
                     &     QuantityNames(numquantitiesperfile) )
                 else
                   call MLSMessage ( MLSMSG_Warning, ModuleName, &
                     & 'Unable to save l2aux quantity, perhaps no chunks processed' )
                 end if
               end do ! in_field_no = 2, nsons(gson)
             case ( f_overlaps )
               ! ??? More work needed here
             end select
           end do ! field_no = 2, nsons(key)

           ! Now close the file
           returnStatus = mls_sfend(sdfid, hdfVersion=hdfVersion)
  !        returnStatus = sfend(sdfid)
           
           if ( returnStatus /= PGS_S_SUCCESS ) then
             call announce_error ( root, &
               &  "Error closing l2aux file:  "//l2auxPhysicalFilename, returnStatus)
           else if (index(switches, 'pro') /= 0) then
d442 2
a443 2
              & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
           end if
d445 1
a445 1
           if ( .not. TOOLKIT ) cycle
d447 162
a608 162
           ! Write the metadata file
           if ( numquantitiesperfile <= 0 ) then
	     call announce_error ( son, &
	       & 'No quantities written for this l2aux file')
           else

             ! We may need to think more about this; until then reuse
             ! populate_metadata_oth, but with l2aux_mcf
             if ( DEBUG ) then
               call output ( 'preparing to populate metadata_oth', advance='yes' )
               call output ( 'l2auxFileHandle: ', advance='no' )
               call output ( l2auxFileHandle , advance='no' )
               call output ( '   l2aux_mcf: ', advance='no' )
               call output ( l2aux_mcf , advance='no' )
               call output ( '   sdfId: ', advance='no' )
               call output ( sdfId , advance='yes' )
               call output ( '   number of quantities: ', advance='no' )
               call output ( numquantitiesperfile , advance='yes' )
               do field_no=1, numquantitiesperfile
                 call output ( field_no , advance='no' )
                 call output ( '       ', advance='no' )
                 call output ( trim(QuantityNames(field_no)) , advance='yes' )
               end do
             end if
             call populate_metadata_oth &
               & ( l2auxFileHandle, l2aux_mcf, l2pcf, &
               & numquantitiesperfile, QuantityNames,&
               & hdfVersion=hdfVersion, metadata_error=metadata_error, &
               & filetype='hdf'  )
             error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
           end if

         else
           call announce_error ( root, &
             &  "Error finding l2aux file matching:  "//file_base, returnStatus)
         end if

       case ( l_l2pc ) ! ------------------------------ Writing l2pc files --
         ! I intend to completely ignore the PCF file in this case,
         ! it's not worth the effort!
         if ( .not. canWriteL2PC ) call MLSMessage(MLSMSG_Error,ModuleName,&
           & "Cannot write l2pc files with multi chunk l2cf's")
         recLen = 0
         packed = .false.
         ascii = .false.
         do field_no = 2, nsons(key) ! Skip "output" name
           gson = subtree(field_no,key)
           select case ( decoration(subtree(1,gson)) )
           case ( f_quantities )
             quantitiesNode = gson
           case ( f_overlaps )
             ! ??? More work needed here
           case ( f_packed )
             packed = get_boolean ( gson )
           case ( f_ascii )
             ascii = get_boolean ( gson )
           end select
         end do ! field_no = 2, nsons(key)

         ! Open file
         if ( ascii ) then
           ! ASCII l2pc file
           l2pcUnit = mls_io_gen_openf ( 'open', .true., error,&
             & recLen, PGSd_IO_Gen_WSeqFrm, trim(file_base), 0,0,0, unknown=.true. )
           if ( error /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName,&
             & 'Failed to open l2pc file:'//trim(file_base))
           
           do in_field_no = 2, nsons(quantitiesNode)
             db_index = decoration(decoration(subtree(in_field_no, quantitiesNode )))
             call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
             call writeOneL2PC ( tmpMatrix, l2pcUnit, packed )
           end do ! in_field_no = 2, nsons(gson)

           error = mls_io_gen_closef ( 'cl', l2pcUnit)
           if ( error /= 0 ) then
             call MLSMessage(MLSMSG_Error,ModuleName,&
               & 'Failed to close l2pc file:'//trim(file_base))
           else if ( index(switches, 'pro') /= 0) then
             call announce_success(file_base, 'l2pc', &
               & 0, quantityNames)
           end if
         else
           ! For the moment call a routine
           call OutputHDF5L2PC ( trim(file_base), matrices, quantitiesNode, packed )
           ! Later on when HDF5 is 'blessed' I want to move all this code
           ! here instead
!            call H5FCreate_F ( trim(file_base), H5F_ACC_TRUNC, l2pcUnit, &
!              & returnStatus )
!            if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!              & 'Unable to open hdf5 l2pc file for output.' )
!            do in_field_no = 2, nsons(quantitiesNode)
!              db_index = decoration(decoration(subtree(in_field_no, quantitiesNode )))
!              call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
!              call writeOneHDF5L2PC ( tmpMatrix, l2pcUnit, packed )
!            end do ! in_field_no = 2, nsons(gson)
!            call H5FClose ( l2pcUnit, returnStatus )
!            if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
!              & 'Unable to close hdf5 l2pc file.' )

         end if

       case ( l_l2dgg ) ! --------------------- Writing l2dgg files -----

         if ( DEBUG ) call output('output file type l2dgg', advance='yes')
         ! Get the l2gp file name from the PCF

         if ( TOOLKIT ) then
           call split_path_name(file_base, path, file_base)
           l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
           & mlspcf_l2dgg_end, &
           & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
           & exactName=l2gpPhysicalFilename)
         else
           l2gpPhysicalFilename = file_base
           returnStatus = 0
         end if

         if ( returnStatus == 0 ) then
           if ( DEBUG ) call output(&
             & 'file name: ' // TRIM(l2gpPhysicalFilename), advance='yes')
           ! Open the HDF-EOS file and write swath data

           if ( DEBUG ) call output('Attempting swopen', advance='yes')
!           swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
           swfid = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
            & record_length, DFACC_CREATE, FileName=l2gpPhysicalFilename, &
            & hdfVersion=hdfVersion, debugOption=.false. )

           ! Loop over the segments of the l2cf line

           numquantitiesperfile = 0
           do field_no = 2, nsons(key) ! Skip "output" name
             gson = subtree(field_no,key)
             select case ( decoration(subtree(1,gson)) )
             case ( f_quantities )
               do in_field_no = 2, nsons(gson)
                 db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                 call writeL2GPData ( l2gpDatabase(db_index), swfid, &
                  & hdfVersion=hdfVersion )
                 numquantitiesperfile = numquantitiesperfile+1
                 if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                   call announce_error ( son, &
                     & 'Attempt to write too many l2dgg quantities to a file', &
                     & numquantitiesperfile )
                   numquantitiesperfile = MAXQUANTITIESPERFILE
                 end if
                 quantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
               end do ! in_field_no = 2, nsons(gson)
             case ( f_overlaps )
               ! ??? More work needed here
             end select
           end do ! field_no = 2, nsons(key)

           if ( DEBUG ) call output('Attempting swclose', advance='yes')
!           returnStatus = swclose(swfid)
           returnStatus = mls_io_gen_closeF('swclose', swfid, &
            & hdfVersion=hdfVersion)
           if ( returnStatus /= PGS_S_SUCCESS ) then
             call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
             call MLSMessage ( MLSMSG_Error, ModuleName, &
               &  "Error closing  l2dgg file:  "//mnemonic//" "//msg )
           else if (index(switches, 'pro') /= 0) then
d610 2
a611 2
              & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
           end if
d613 1
a613 1
           if ( .not. TOOLKIT ) cycle
d615 1
a615 1
           ! Write the metadata file
d617 1
a617 1
           if ( numquantitiesperfile <= 0 ) then
d619 29
a647 29
             ! Error in number of quantities
             call announce_error ( son, &
               & 'No quantities written for this l2dgg file')

           else

             ! Similar to type l2gp file 'other'
             if ( DEBUG ) then
               call output ( 'preparing to populate metadata_oth', advance='yes' )
               call output ( 'l2gpFileHandle: ', advance='no' )
               call output ( l2gpFileHandle , advance='no' )
               call output ( '   l2dgg_mcf: ', advance='no' )
               call output ( mlspcf_mcf_l2dgg_start , advance='no' )
               call output ( '   swfid: ', advance='no' )
               call output ( swfid , advance='yes' )
             end if

             call populate_metadata_oth &
               & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, l2pcf, &
               & numquantitiesperfile, QuantityNames, &
               & hdfVersion=hdfVersion, metadata_error=metadata_error, &
               & filetype='sw'  )
             error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
           end if

         else
           call announce_error ( ROOT, &
             &  "Error finding l2gp file matching:  "//file_base, returnStatus)
         end if
d651 2
a652 2
           call announce_error ( ROOT, &
             &  "Error--unknown output type: parser should have caught this")
d654 1
a654 1
       end select
d656 166
a821 171
     case ( s_time )
       if ( timing ) then
         call sayTime
       else
         call time_now ( t1 )
         timing = .true.
       end if

     case default
           call announce_error ( ROOT, &
             &  "Error--unknown spec_no: parser should have caught this")

     end select

   end do  ! spec_no

   ! Write metadata for any directdata files
   if ( size(DirectDatabase) > 0 .and. TOOLKIT ) then
    do DB_index=1, size(DirectDatabase)
       file_base = DirectDatabase(DB_index)%fileNameBase
       output_type = DirectDatabase(DB_index)%type
       numquantitiesperfile = size(DirectDatabase(DB_index)%sdNames)
       do quantitiesnode=1, numquantitiesperfile
         QuantityNames(quantitiesnode) = &
           & DirectDatabase(DB_index)%sdNames(quantitiesnode)
       enddo
       select case ( output_type )
       case ( l_l2gp ) ! --------------------- Writing l2gp files -----
         if ( DEBUG ) call output('output file type l2gp', advance='yes')
         ! Get the l2gp file name from the PCF

          if ( DEBUG ) call output('file_base after split: ', advance='no')
          if ( DEBUG ) call output(trim(file_base), advance='yes')

           l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
           & mlspcf_l2gp_end, &
           & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
           & exactName=l2gpPhysicalFilename)
         ! Write the metadata file

         call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf, l2pcf  )

         if ( l2gp_mcf <= 0 ) then

           ! Error in finding mcf number
           call announce_error ( son, &
             & 'No mcf numbers correspond to this l2gp file', l2gp_mcf, &
             & PENALTY_FOR_NO_METADATA )

         else if ( numquantitiesperfile <= 0 ) then

           ! Error in number of quantities
           call announce_error ( son, &
             & 'No quantities written for this l2gp file')

         else if ( QuantityNames(numquantitiesperfile) &
           & == QuantityNames(1) ) then

           ! Typical homogeneous l2gp file: 
           ! e.g., associated with BrO is ML2BRO.001.MCF
           if ( DEBUG ) then
             call output('preparing to populate metadata_std', advance='yes')
             call output('l2gpFileHandle: ', advance='no')
             call output(l2gpFileHandle , advance='no')
             call output('   l2gp_mcf: ', advance='no')
             call output(l2gp_mcf , advance='no')
             call output('   swfid: ', advance='no')
             call output(swfid , advance='yes')
           end if

           call populate_metadata_std &
             & (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
             & hdfVersion=hdfVersion, metadata_error=metadata_error, &
             & filetype='sw' )
           error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)

         else

           ! Type l2gp file 'other'
           if ( DEBUG ) then
             call output ( 'preparing to populate metadata_oth', advance='yes' )
             call output ( 'l2gpFileHandle: ', advance='no' )
             call output ( l2gpFileHandle , advance='no' )
             call output ( '   l2gp_mcf: ', advance='no' )
             call output ( l2gp_mcf , advance='no' )
             call output ( '   swfid: ', advance='no' )
             call output ( swfid , advance='yes' )
           end if

           call populate_metadata_oth &
             & ( l2gpFileHandle, l2gp_mcf, l2pcf, &
             & numquantitiesperfile, QuantityNames, &
             & hdfVersion=hdfVersion, metadata_error=metadata_error, &
             & filetype='sw'  )
           error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
         end if
       case ( l_l2aux ) ! ------------------------------ Writing l2aux files ---

         if ( DEBUG ) call output ( 'output file type l2aux', advance='yes' )
         ! Get the l2aux file name from the PCF

           call split_path_name(file_base, path, file_base)
           l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
           & mlspcf_l2dgm_end, &
           & TOOLKIT, returnStatus, l2aux_Version, DEBUG, &
           & exactName=l2auxPhysicalFilename)
         if ( DEBUG ) then
           call output ( 'preparing to populate metadata_oth', advance='yes' )
           call output ( 'l2auxFileHandle: ', advance='no' )
           call output ( l2auxFileHandle , advance='no' )
           call output ( '   l2aux_mcf: ', advance='no' )
           call output ( l2aux_mcf , advance='no' )
           call output ( '   sdfId: ', advance='no' )
           call output ( sdfId , advance='yes' )
           call output ( '   number of quantities: ', advance='no' )
           call output ( numquantitiesperfile , advance='yes' )
           do field_no=1, numquantitiesperfile
             call output ( field_no , advance='no' )
             call output ( '       ', advance='no' )
             call output ( trim(QuantityNames(field_no)) , advance='yes' )
           end do
         end if
         call populate_metadata_oth &
           & ( l2auxFileHandle, l2aux_mcf, l2pcf, &
           & numquantitiesperfile, QuantityNames,&
           & hdfVersion=hdfVersion, metadata_error=metadata_error, &
           & filetype='hdf'  )
         error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
       case ( l_l2pc ) ! ------------------------------ Writing l2pc files --
         ! I intend to completely ignore the PCF file in this case,
         ! it's not worth the effort!
         call MLSMessage(MLSMSG_Error,ModuleName,&
           & "Cannot write metadata to l2pc files ")
       case ( l_l2dgg ) ! --------------------- Writing l2dgg files -----

         if ( DEBUG ) call output('output file type l2dgg', advance='yes')
         ! Get the l2gp file name from the PCF

           call split_path_name(file_base, path, file_base)
           l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
           & mlspcf_l2dgg_end, &
           & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
           & exactName=l2gpPhysicalFilename)
         if ( DEBUG ) then
           call output ( 'preparing to populate metadata_oth', advance='yes' )
           call output ( 'l2gpFileHandle: ', advance='no' )
           call output ( l2gpFileHandle , advance='no' )
           call output ( '   l2dgg_mcf: ', advance='no' )
           call output ( mlspcf_mcf_l2dgg_start , advance='no' )
           call output ( '   swfid: ', advance='no' )
           call output ( swfid , advance='yes' )
         end if

         call populate_metadata_oth &
           & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, l2pcf, &
           & numquantitiesperfile, QuantityNames, &
           & hdfVersion=hdfVersion, metadata_error=metadata_error, &
           & filetype='sw'  )
         error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
       case default
         call announce_error ( ROOT, &
           &  "Error--unknown output type: parser should have caught this")

       end select
     enddo
   end if

! Write the log file metadata
    if ( LOGFILEGETSMETADATA ) then
      if ( DEBUG ) then
        call output('About to write log file metadata' , advance='yes')
d824 10
a833 3
      if ( TOOLKIT ) then
        call writeMetaLog ( l2pcf, metadata_error )
        error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
a834 1
    end if
d836 1
a836 1
! Done with text of PCF file at last
d838 2
a839 2
    if ( DEBUG ) &
      & call output ( 'About to deallocate text of PCF file' , advance='yes' )
d841 1
a841 6
    call deallocate_test ( l2pcf%anText, 'anText of PCF file', moduleName )

   if (index(switches, 'pro') /= 0) then
    call output ( '============ End Level 2 Products ============', advance='yes' )
    call output ( ' ', advance='yes' )
   end if
d843 5
d948 3
@


2.75
log
@New db indexes stored for entire direct file
@
text
@d12 1
a12 2
  use Hdf, only: DFACC_CREATE, DFACC_RDWR, SFN2INDEX, SFSELECT, SFCREATE, &
    & SFENDACC, DFNT_FLOAT32, SFWDATA_F90
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.74 2003/06/23 18:06:33 pwagner Exp $"
d155 2
a156 2
    ! l2gp_mcf will be incremented in get_l2gp_mcf (if MCFFORL2GPOPTION == 1)
    l2gp_mcf = mlspcf_mcf_l2gp_start - 1   
d158 2
a159 2
    l2aux_mcf = mlspcf_mcf_l2dgm_start
    l2dgg_mcf = mlspcf_mcf_l2dgg_start
d161 1
a161 1
    ! Loop over the lines in the l2cf
d163 231
a393 17
    do spec_no = 2, nsons(root)-1 ! Skip name at begin and end of section

      l2gp_Version = 1
      l2aux_Version = 1
      hdfVersion = DEFAULT_HDFVERSION_WRITE
      meta_name = ''
      writeCounterMAF = .false.
      writeMetaDataOnly = .false.

      son = subtree(spec_no,root)
      if ( node_id(son) == n_named ) then ! Is spec labeled?
        key = subtree(2,son)
        name = sub_rosa(subtree(1,son))
      else ! Son is n_spec_args
        key = son
        name = 0
      end if
d395 14
a408 250
      select case( get_spec_id(key) )
      case ( s_output )
        do field_no = 2, nsons(key)       ! Skip the command name
          gson = subtree(field_no, key)   ! An assign node
          if ( nsons(gson) > 1 ) then
            fieldValue = decoration(subtree(2,gson)) ! The field's value
          else
            fieldValue = gson
          end if
          field_index = decoration(subtree(1,gson))
          select case ( field_index )   ! Field name
          case ( f_file )
            call get_string ( sub_rosa(subtree(2,gson)), file_base )
            file_base = file_base(2:LEN_TRIM(file_base)-1) ! Parser includes quotes
          case ( f_metaName )
            call get_string ( sub_rosa(subtree(2,gson)), meta_name )
            meta_name = meta_name(2:LEN_TRIM(meta_name)-1) ! Parser includes quotes
          case ( f_type )
            output_type = decoration(subtree(2,gson))
          case ( f_writeCounterMAF )
            writeCounterMAF = get_boolean ( fieldValue )
          case ( f_MetaDataOnly )
            writeMetaDataOnly = get_boolean ( fieldValue )
          case ( f_hdfVersion )
            call expr ( subtree(2,gson), units, value, type )
            if ( units(1) /= phyq_dimensionless ) &
              & call Announce_error ( gson, &
                & 'No units allowed for hdfVersion: just integer 4 or 5')
            hdfVersion = value(1)
          case default                  ! Everything else processed later
          end select
        end do

      if ( DEBUG ) call output('l2gp type number: ', advance='no')
      if ( DEBUG ) call output(l_l2gp, advance='yes')

      if ( DEBUG ) call output('l2aux type number: ', advance='no')
      if ( DEBUG ) call output(l_l2gp, advance='yes')

      if ( DEBUG ) call output('l2dgg type number: ', advance='no')
      if ( DEBUG ) call output(l_l2dgg, advance='yes')

      if ( DEBUG ) call output('output type number: ', advance='no')
      if ( DEBUG ) call output(output_type, advance='yes')

      if ( DEBUG ) call output('file_base: ', advance='no')
      if ( DEBUG ) call output(trim(file_base), advance='yes')

      if ( WriteMetaDataOnly ) then
        if ( .not. TOOLKIT ) cycle
      ! Skip regular data
        select case ( output_type )
        case ( l_l2gp ) ! --------------------- Writing l2gp files -----
          if ( DEBUG ) call output('output file type l2gp', advance='yes')
          ! Get the l2gp file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)
           if ( DEBUG ) call output('file_base after split: ', advance='no')
           if ( DEBUG ) call output(trim(file_base), advance='yes')

            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
            & mlspcf_l2gp_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2gpPhysicalFilename)
          else
            l2gpPhysicalFilename = file_base
            returnStatus = 0
          end if
          ! Write the metadata file

          call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf, l2pcf  )

          if ( l2gp_mcf <= 0 ) then

            ! Error in finding mcf number
            call announce_error ( son, &
              & 'No mcf numbers correspond to this l2gp file', l2gp_mcf, &
              & PENALTY_FOR_NO_METADATA )

          else if ( numquantitiesperfile <= 0 ) then

            ! Error in number of quantities
            call announce_error ( son, &
              & 'No quantities written for this l2gp file')

          else if ( QuantityNames(numquantitiesperfile) &
            & == QuantityNames(1) ) then

            ! Typical homogeneous l2gp file: 
            ! e.g., associated with BrO is ML2BRO.001.MCF
            if ( DEBUG ) then
              call output('preparing to populate metadata_std', advance='yes')
              call output('l2gpFileHandle: ', advance='no')
              call output(l2gpFileHandle , advance='no')
              call output('   l2gp_mcf: ', advance='no')
              call output(l2gp_mcf , advance='no')
              call output('   swfid: ', advance='no')
              call output(swfid , advance='yes')
            end if

            call populate_metadata_std &
              & (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
              & hdfVersion=hdfVersion, metadata_error=metadata_error, &
              & filetype='sw' )
            error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)

          else

            ! Type l2gp file 'other'
            if ( DEBUG ) then
              call output ( 'preparing to populate metadata_oth', advance='yes' )
              call output ( 'l2gpFileHandle: ', advance='no' )
              call output ( l2gpFileHandle , advance='no' )
              call output ( '   l2gp_mcf: ', advance='no' )
              call output ( l2gp_mcf , advance='no' )
              call output ( '   swfid: ', advance='no' )
              call output ( swfid , advance='yes' )
            end if

            call populate_metadata_oth &
              & ( l2gpFileHandle, l2gp_mcf, l2pcf, &
              & numquantitiesperfile, QuantityNames, &
              & hdfVersion=hdfVersion, metadata_error=metadata_error, &
              & filetype='sw'  )
            error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
          end if
        case ( l_l2aux ) ! ------------------------------ Writing l2aux files ---

          if ( DEBUG ) call output ( 'output file type l2aux', advance='yes' )
          ! Get the l2aux file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)
            l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
            & mlspcf_l2dgm_end, &
            & TOOLKIT, returnStatus, l2aux_Version, DEBUG, &
            & exactName=l2auxPhysicalFilename)
          else
            l2auxPhysicalFilename = file_base
            returnStatus = 0
          end if
          if ( DEBUG ) then
            call output ( 'preparing to populate metadata_oth', advance='yes' )
            call output ( 'l2auxFileHandle: ', advance='no' )
            call output ( l2auxFileHandle , advance='no' )
            call output ( '   l2aux_mcf: ', advance='no' )
            call output ( l2aux_mcf , advance='no' )
            call output ( '   sdfId: ', advance='no' )
            call output ( sdfId , advance='yes' )
            call output ( '   number of quantities: ', advance='no' )
            call output ( numquantitiesperfile , advance='yes' )
            do field_no=1, numquantitiesperfile
              call output ( field_no , advance='no' )
              call output ( '       ', advance='no' )
              call output ( trim(QuantityNames(field_no)) , advance='yes' )
            end do
          end if
          call populate_metadata_oth &
            & ( l2auxFileHandle, l2aux_mcf, l2pcf, &
            & numquantitiesperfile, QuantityNames,&
            & hdfVersion=hdfVersion, metadata_error=metadata_error, &
            & filetype='hdf'  )
          error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
        case ( l_l2pc ) ! ------------------------------ Writing l2pc files --
          ! I intend to completely ignore the PCF file in this case,
          ! it's not worth the effort!
          call MLSMessage(MLSMSG_Error,ModuleName,&
            & "Cannot write metadata to l2pc files ")
        case ( l_l2dgg ) ! --------------------- Writing l2dgg files -----

          if ( DEBUG ) call output('output file type l2dgg', advance='yes')
          ! Get the l2gp file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)
            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
            & mlspcf_l2dgg_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2gpPhysicalFilename)
          else
            l2gpPhysicalFilename = file_base
            returnStatus = 0
          end if
          if ( DEBUG ) then
            call output ( 'preparing to populate metadata_oth', advance='yes' )
            call output ( 'l2gpFileHandle: ', advance='no' )
            call output ( l2gpFileHandle , advance='no' )
            call output ( '   l2dgg_mcf: ', advance='no' )
            call output ( mlspcf_mcf_l2dgg_start , advance='no' )
            call output ( '   swfid: ', advance='no' )
            call output ( swfid , advance='yes' )
          end if

          call populate_metadata_oth &
            & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, l2pcf, &
            & numquantitiesperfile, QuantityNames, &
            & hdfVersion=hdfVersion, metadata_error=metadata_error, &
            & filetype='sw'  )
          error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
        case default
          call announce_error ( ROOT, &
            &  "Error--unknown output type: parser should have caught this")

        end select
        cycle        ! Skip to next Output command
      end if
        
      ! Otherwise--normal output commands
        select case ( output_type )
        case ( l_l2gp ) ! --------------------- Writing l2gp files -----
          if ( DEBUG ) call output('output file type l2gp', advance='yes')
          ! Get the l2gp file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)
           if ( DEBUG ) call output('file_base after split: ', advance='no')
           if ( DEBUG ) call output(trim(file_base), advance='yes')

            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
            & mlspcf_l2gp_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2gpPhysicalFilename)
          else
            l2gpPhysicalFilename = file_base
            returnStatus = 0
          end if

          if ( returnStatus == 0 ) then
            if ( DEBUG ) call output(&
              & 'file name: ' // TRIM(l2gpPhysicalFilename), advance='yes')
            ! Open the HDF-EOS file and write swath data

            if ( DEBUG ) call output('Attempting swopen', advance='yes')
!            swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
            swfid = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
             & record_length, DFACC_CREATE, FileName=l2gpPhysicalFilename, &
             & hdfVersion=hdfVersion, debugOption=.false. )

            ! Loop over the segments of the l2cf line

            numquantitiesperfile = 0
            do field_no = 2, nsons(key) ! Skip "output" name
              gson = subtree(field_no,key)
              select case ( decoration(subtree(1,gson)) )
              case ( f_quantities )
                do in_field_no = 2, nsons(gson)
                  db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                  if ( db_index >= 1 ) then
                    call writeL2GPData ( l2gpDatabase(db_index), swfid, &
d410 193
a602 121
                    numquantitiesperfile = numquantitiesperfile+1
                    if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                      call announce_error ( son, &
                        & 'Attempt to write too many l2gp quantities to a file', &
                        & numquantitiesperfile )
                      numquantitiesperfile = MAXQUANTITIESPERFILE
                    end if
                    quantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
                  else
                    call MLSMessage ( MLSMSG_Warning, ModuleName, &
                      & 'Unable to write quantity to l2gp file, perhaps no chunks processed' )
                  end if
                end do ! in_field_no = 2, nsons(gson)
              case ( f_overlaps )
                ! ??? More work needed here
              end select
            end do ! field_no = 2, nsons(key)

            if ( DEBUG ) call output('Attempting swclose', advance='yes')
!            returnStatus = swclose(swfid)
            returnStatus = mls_io_gen_closeF('swclose', swfid, &
             & hdfVersion=hdfVersion)
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                &  "Error closing  l2gp file:  "//mnemonic//" "//msg )
            else if (index(switches, 'pro') /= 0) then
               call announce_success(l2gpPhysicalFilename, 'l2gp', &
               & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
            end if

            if ( .not. TOOLKIT ) cycle

            ! Write the metadata file

            call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf, l2pcf  )

            if ( l2gp_mcf <= 0 ) then

              ! Error in finding mcf number
              call announce_error ( son, &
                & 'No mcf numbers correspond to this l2gp file', l2gp_mcf, &
                & PENALTY_FOR_NO_METADATA )

            else if ( numquantitiesperfile <= 0 ) then

              ! Error in number of quantities
              call announce_error ( son, &
                & 'No quantities written for this l2gp file')

            else if ( QuantityNames(numquantitiesperfile) &
              & == QuantityNames(1) ) then

              ! Typical homogeneous l2gp file: 
              ! e.g., associated with BrO is ML2BRO.001.MCF
              if ( DEBUG ) then
                call output('preparing to populate metadata_std', advance='yes')
                call output('l2gpFileHandle: ', advance='no')
                call output(l2gpFileHandle , advance='no')
                call output('   l2gp_mcf: ', advance='no')
                call output(l2gp_mcf , advance='no')
                call output('   swfid: ', advance='no')
                call output(swfid , advance='yes')
              end if

              call populate_metadata_std &
                & (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype='sw' )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)

            else

              ! Type l2gp file 'other'
              if ( DEBUG ) then
                call output ( 'preparing to populate metadata_oth', advance='yes' )
                call output ( 'l2gpFileHandle: ', advance='no' )
                call output ( l2gpFileHandle , advance='no' )
                call output ( '   l2gp_mcf: ', advance='no' )
                call output ( l2gp_mcf , advance='no' )
                call output ( '   swfid: ', advance='no' )
                call output ( swfid , advance='yes' )
              end if

              call populate_metadata_oth &
                & ( l2gpFileHandle, l2gp_mcf, l2pcf, &
                & numquantitiesperfile, QuantityNames, &
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype='sw'  )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
            end if

          else
            call announce_error ( ROOT, &
              &  "Error finding l2gp file matching:  "//file_base, returnStatus)
          end if

        case ( l_l2aux ) ! ------------------------------ Writing l2aux files ---

          if ( DEBUG ) call output ( 'output file type l2aux', advance='yes' )
          ! Get the l2aux file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)
            l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
            & mlspcf_l2dgm_end, &
            & TOOLKIT, returnStatus, l2aux_Version, DEBUG, &
            & exactName=l2auxPhysicalFilename)
          else
            l2auxPhysicalFilename = file_base
            returnStatus = 0
          end if

          if ( returnStatus == 0 ) then

            if ( DEBUG ) call output ( 'file name: ' // TRIM(l2auxPhysicalFilename), &
              & advance='yes' )
            ! Create the HDF file and initialize the SD interface
            if ( DEBUG ) call output ( 'Attempting sfstart', advance='yes' )
  ! (((( This will have to be changed to incorporate hdf5 ))))
           sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_CREATE, &
d604 44
a647 1
  !         sdfId = sfstart(l2auxPhysicalFilename, DFACC_CREATE)
a648 274
            if ( DEBUG ) call output ( "looping over quantities", advance='yes' )
            numquantitiesperfile = 0
            do field_no = 2, nsons(key) ! Skip "output" name
              gson = subtree(field_no,key)
              select case ( decoration(subtree(1,gson)) )
              case ( f_quantities )
                do in_field_no = 2, nsons(gson)
                  if ( DEBUG ) &
                    & call output ( "computing db index", advance='yes')
                  db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                  if ( db_index >= 1 ) then
                    call WriteL2AUXData ( l2auxDatabase(db_index), sdfid, returnStatus,&
                      & WriteCounterMAF = &
                      &   (writeCounterMAF .and. numquantitiesperfile == 0), &
                      & hdfVersion=hdfVersion )
                    error = max(error, returnStatus)
                    numquantitiesperfile = numquantitiesperfile+1
                    if ( DEBUG ) call output(&
                      & "attempting to fill quantity name", advance='yes')
                    if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                      call announce_error ( son, &
                        & 'Attempt to write too many l2aux quantities to a file', &
                        & numquantitiesperfile )
                      numquantitiesperfile = MAXQUANTITIESPERFILE
                    end if
                    call get_string &
                      & ( l2auxDatabase(db_index)%name, &
                      &     QuantityNames(numquantitiesperfile) )
                  else
                    call MLSMessage ( MLSMSG_Warning, ModuleName, &
                      & 'Unable to save l2aux quantity, perhaps no chunks processed' )
                  end if
                end do ! in_field_no = 2, nsons(gson)
              case ( f_overlaps )
                ! ??? More work needed here
              end select
            end do ! field_no = 2, nsons(key)

            ! Now close the file
  ! ((((( This, too, will have to be changed for hdf5 )))))
  !                  conversion
            returnStatus = mls_sfend(sdfid, hdfVersion=hdfVersion)
  !         returnStatus = sfend(sdfid)
            
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call announce_error ( root, &
                &  "Error closing l2aux file:  "//l2auxPhysicalFilename, returnStatus)
            else if (index(switches, 'pro') /= 0) then
               call announce_success(l2auxPhysicalFilename, 'l2aux', &
               & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
            end if

            if ( .not. TOOLKIT ) cycle

            ! Write the metadata file
            if ( numquantitiesperfile <= 0 ) then
	      call announce_error ( son, &
	        & 'No quantities written for this l2aux file')
            else

              ! We may need to think more about this; until then reuse
              ! populate_metadata_oth, but with l2aux_mcf
              if ( DEBUG ) then
                call output ( 'preparing to populate metadata_oth', advance='yes' )
                call output ( 'l2auxFileHandle: ', advance='no' )
                call output ( l2auxFileHandle , advance='no' )
                call output ( '   l2aux_mcf: ', advance='no' )
                call output ( l2aux_mcf , advance='no' )
                call output ( '   sdfId: ', advance='no' )
                call output ( sdfId , advance='yes' )
                call output ( '   number of quantities: ', advance='no' )
                call output ( numquantitiesperfile , advance='yes' )
                do field_no=1, numquantitiesperfile
                  call output ( field_no , advance='no' )
                  call output ( '       ', advance='no' )
                  call output ( trim(QuantityNames(field_no)) , advance='yes' )
                end do
              end if
              call populate_metadata_oth &
                & ( l2auxFileHandle, l2aux_mcf, l2pcf, &
                & numquantitiesperfile, QuantityNames,&
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype='hdf'  )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
            end if

          else
            call announce_error ( root, &
              &  "Error finding l2aux file matching:  "//file_base, returnStatus)
          end if

        case ( l_l2pc ) ! ------------------------------ Writing l2pc files --
          ! I intend to completely ignore the PCF file in this case,
          ! it's not worth the effort!
          if ( .not. canWriteL2PC ) call MLSMessage(MLSMSG_Error,ModuleName,&
            & "Cannot write l2pc files with multi chunk l2cf's")
          recLen = 0
          packed = .false.
          ascii = .false.
          do field_no = 2, nsons(key) ! Skip "output" name
            gson = subtree(field_no,key)
            select case ( decoration(subtree(1,gson)) )
            case ( f_quantities )
              quantitiesNode = gson
            case ( f_overlaps )
              ! ??? More work needed here
            case ( f_packed )
              packed = get_boolean ( gson )
            case ( f_ascii )
              ascii = get_boolean ( gson )
            end select
          end do ! field_no = 2, nsons(key)

          ! Open file
          if ( ascii ) then
            ! ASCII l2pc file
            l2pcUnit = mls_io_gen_openf ( 'open', .true., error,&
              & recLen, PGSd_IO_Gen_WSeqFrm, trim(file_base), 0,0,0, unknown=.true. )
            if ( error /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName,&
              & 'Failed to open l2pc file:'//trim(file_base))
            
            do in_field_no = 2, nsons(quantitiesNode)
              db_index = decoration(decoration(subtree(in_field_no, quantitiesNode )))
              call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
              call writeOneL2PC ( tmpMatrix, l2pcUnit, packed )
            end do ! in_field_no = 2, nsons(gson)

            error = mls_io_gen_closef ( 'cl', l2pcUnit)
            if ( error /= 0 ) then
              call MLSMessage(MLSMSG_Error,ModuleName,&
                & 'Failed to close l2pc file:'//trim(file_base))
            else if ( index(switches, 'pro') /= 0) then
              call announce_success(file_base, 'l2pc', &
                & 0, quantityNames)
            end if
          else
            ! For the moment call a routine
            call OutputHDF5L2PC ( trim(file_base), matrices, quantitiesNode, packed )
            ! Later on when HDF5 is 'blessed' I want to move all this code
            ! here instead
!             call H5FCreate_F ( trim(file_base), H5F_ACC_TRUNC, l2pcUnit, &
!               & returnStatus )
!             if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!               & 'Unable to open hdf5 l2pc file for output.' )
!             do in_field_no = 2, nsons(quantitiesNode)
!               db_index = decoration(decoration(subtree(in_field_no, quantitiesNode )))
!               call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
!               call writeOneHDF5L2PC ( tmpMatrix, l2pcUnit, packed )
!             end do ! in_field_no = 2, nsons(gson)
!             call H5FClose ( l2pcUnit, returnStatus )
!             if ( returnStatus /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,&
!               & 'Unable to close hdf5 l2pc file.' )

          end if

        case ( l_l2dgg ) ! --------------------- Writing l2dgg files -----

          if ( DEBUG ) call output('output file type l2dgg', advance='yes')
          ! Get the l2gp file name from the PCF

          if ( TOOLKIT ) then
            call split_path_name(file_base, path, file_base)
            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
            & mlspcf_l2dgg_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2gpPhysicalFilename)
          else
            l2gpPhysicalFilename = file_base
            returnStatus = 0
          end if

          if ( returnStatus == 0 ) then
            if ( DEBUG ) call output(&
              & 'file name: ' // TRIM(l2gpPhysicalFilename), advance='yes')
            ! Open the HDF-EOS file and write swath data

            if ( DEBUG ) call output('Attempting swopen', advance='yes')
!            swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
            swfid = mls_io_gen_openF('swopen', .TRUE., returnStatus, &
             & record_length, DFACC_CREATE, FileName=l2gpPhysicalFilename, &
             & hdfVersion=hdfVersion, debugOption=.false. )

            ! Loop over the segments of the l2cf line

            numquantitiesperfile = 0
            do field_no = 2, nsons(key) ! Skip "output" name
              gson = subtree(field_no,key)
              select case ( decoration(subtree(1,gson)) )
              case ( f_quantities )
                do in_field_no = 2, nsons(gson)
                  db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                  call writeL2GPData ( l2gpDatabase(db_index), swfid, &
                   & hdfVersion=hdfVersion )
                  numquantitiesperfile = numquantitiesperfile+1
                  if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                    call announce_error ( son, &
                      & 'Attempt to write too many l2dgg quantities to a file', &
                      & numquantitiesperfile )
                    numquantitiesperfile = MAXQUANTITIESPERFILE
                  end if
                  quantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
                end do ! in_field_no = 2, nsons(gson)
              case ( f_overlaps )
                ! ??? More work needed here
              end select
            end do ! field_no = 2, nsons(key)

            if ( DEBUG ) call output('Attempting swclose', advance='yes')
!            returnStatus = swclose(swfid)
            returnStatus = mls_io_gen_closeF('swclose', swfid, &
             & hdfVersion=hdfVersion)
            if ( returnStatus /= PGS_S_SUCCESS ) then
              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                &  "Error closing  l2dgg file:  "//mnemonic//" "//msg )
            else if (index(switches, 'pro') /= 0) then
               call announce_success(l2gpPhysicalFilename, 'l2dgg', &
               & numquantitiesperfile, quantityNames, hdfVersion=hdfVersion)
            end if

            if ( .not. TOOLKIT ) cycle

            ! Write the metadata file

            if ( numquantitiesperfile <= 0 ) then

              ! Error in number of quantities
              call announce_error ( son, &
                & 'No quantities written for this l2dgg file')

            else

              ! Similar to type l2gp file 'other'
              if ( DEBUG ) then
                call output ( 'preparing to populate metadata_oth', advance='yes' )
                call output ( 'l2gpFileHandle: ', advance='no' )
                call output ( l2gpFileHandle , advance='no' )
                call output ( '   l2dgg_mcf: ', advance='no' )
                call output ( mlspcf_mcf_l2dgg_start , advance='no' )
                call output ( '   swfid: ', advance='no' )
                call output ( swfid , advance='yes' )
              end if

              call populate_metadata_oth &
                & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, l2pcf, &
                & numquantitiesperfile, QuantityNames, &
                & hdfVersion=hdfVersion, metadata_error=metadata_error, &
                & filetype='sw'  )
              error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
            end if

          else
            call announce_error ( ROOT, &
              &  "Error finding l2gp file matching:  "//file_base, returnStatus)
          end if


         case default
            call announce_error ( ROOT, &
              &  "Error--unknown output type: parser should have caught this")

        end select

      case ( s_time )
        if ( timing ) then
          call sayTime
        else
          call time_now ( t1 )
          timing = .true.
        end if

      case default
            call announce_error ( ROOT, &
              &  "Error--unknown spec_no: parser should have caught this")
d650 3
a652 1
      end select
d654 1
a654 1
    end do  ! spec_no
d656 162
a817 146
    ! Write metadata for any directdata files
    if ( size(DirectDatabase) > 0 .and. TOOLKIT ) then
     do DB_index=1, size(DirectDatabase)
        file_base = DirectDatabase(DB_index)%fileNameBase
        output_type = DirectDatabase(DB_index)%type
        numquantitiesperfile = size(DirectDatabase(DB_index)%sdNames)
        do quantitiesnode=1, numquantitiesperfile
          QuantityNames(quantitiesnode) = &
            & DirectDatabase(DB_index)%sdNames(quantitiesnode)
        enddo
        select case ( output_type )
        case ( l_l2gp ) ! --------------------- Writing l2gp files -----
          if ( DEBUG ) call output('output file type l2gp', advance='yes')
          ! Get the l2gp file name from the PCF

           if ( DEBUG ) call output('file_base after split: ', advance='no')
           if ( DEBUG ) call output(trim(file_base), advance='yes')

            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
            & mlspcf_l2gp_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2gpPhysicalFilename)
          ! Write the metadata file

          call get_l2gp_mcf ( file_base, meta_name, l2gp_mcf, l2pcf  )

          if ( l2gp_mcf <= 0 ) then

            ! Error in finding mcf number
            call announce_error ( son, &
              & 'No mcf numbers correspond to this l2gp file', l2gp_mcf, &
              & PENALTY_FOR_NO_METADATA )

          else if ( numquantitiesperfile <= 0 ) then

            ! Error in number of quantities
            call announce_error ( son, &
              & 'No quantities written for this l2gp file')

          else if ( QuantityNames(numquantitiesperfile) &
            & == QuantityNames(1) ) then

            ! Typical homogeneous l2gp file: 
            ! e.g., associated with BrO is ML2BRO.001.MCF
            if ( DEBUG ) then
              call output('preparing to populate metadata_std', advance='yes')
              call output('l2gpFileHandle: ', advance='no')
              call output(l2gpFileHandle , advance='no')
              call output('   l2gp_mcf: ', advance='no')
              call output(l2gp_mcf , advance='no')
              call output('   swfid: ', advance='no')
              call output(swfid , advance='yes')
            end if

            call populate_metadata_std &
              & (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
              & hdfVersion=hdfVersion, metadata_error=metadata_error, &
              & filetype='sw' )
            error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)

          else

            ! Type l2gp file 'other'
            if ( DEBUG ) then
              call output ( 'preparing to populate metadata_oth', advance='yes' )
              call output ( 'l2gpFileHandle: ', advance='no' )
              call output ( l2gpFileHandle , advance='no' )
              call output ( '   l2gp_mcf: ', advance='no' )
              call output ( l2gp_mcf , advance='no' )
              call output ( '   swfid: ', advance='no' )
              call output ( swfid , advance='yes' )
            end if

            call populate_metadata_oth &
              & ( l2gpFileHandle, l2gp_mcf, l2pcf, &
              & numquantitiesperfile, QuantityNames, &
              & hdfVersion=hdfVersion, metadata_error=metadata_error, &
              & filetype='sw'  )
            error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
          end if
        case ( l_l2aux ) ! ------------------------------ Writing l2aux files ---

          if ( DEBUG ) call output ( 'output file type l2aux', advance='yes' )
          ! Get the l2aux file name from the PCF

            call split_path_name(file_base, path, file_base)
            l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
            & mlspcf_l2dgm_end, &
            & TOOLKIT, returnStatus, l2aux_Version, DEBUG, &
            & exactName=l2auxPhysicalFilename)
          if ( DEBUG ) then
            call output ( 'preparing to populate metadata_oth', advance='yes' )
            call output ( 'l2auxFileHandle: ', advance='no' )
            call output ( l2auxFileHandle , advance='no' )
            call output ( '   l2aux_mcf: ', advance='no' )
            call output ( l2aux_mcf , advance='no' )
            call output ( '   sdfId: ', advance='no' )
            call output ( sdfId , advance='yes' )
            call output ( '   number of quantities: ', advance='no' )
            call output ( numquantitiesperfile , advance='yes' )
            do field_no=1, numquantitiesperfile
              call output ( field_no , advance='no' )
              call output ( '       ', advance='no' )
              call output ( trim(QuantityNames(field_no)) , advance='yes' )
            end do
          end if
          call populate_metadata_oth &
            & ( l2auxFileHandle, l2aux_mcf, l2pcf, &
            & numquantitiesperfile, QuantityNames,&
            & hdfVersion=hdfVersion, metadata_error=metadata_error, &
            & filetype='hdf'  )
          error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
        case ( l_l2pc ) ! ------------------------------ Writing l2pc files --
          ! I intend to completely ignore the PCF file in this case,
          ! it's not worth the effort!
          call MLSMessage(MLSMSG_Error,ModuleName,&
            & "Cannot write metadata to l2pc files ")
        case ( l_l2dgg ) ! --------------------- Writing l2dgg files -----

          if ( DEBUG ) call output('output file type l2dgg', advance='yes')
          ! Get the l2gp file name from the PCF

            call split_path_name(file_base, path, file_base)
            l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
            & mlspcf_l2dgg_end, &
            & TOOLKIT, returnStatus, l2gp_Version, DEBUG, &
            & exactName=l2gpPhysicalFilename)
          if ( DEBUG ) then
            call output ( 'preparing to populate metadata_oth', advance='yes' )
            call output ( 'l2gpFileHandle: ', advance='no' )
            call output ( l2gpFileHandle , advance='no' )
            call output ( '   l2dgg_mcf: ', advance='no' )
            call output ( mlspcf_mcf_l2dgg_start , advance='no' )
            call output ( '   swfid: ', advance='no' )
            call output ( swfid , advance='yes' )
          end if

          call populate_metadata_oth &
            & ( l2gpFileHandle, mlspcf_mcf_l2dgg_start, l2pcf, &
            & numquantitiesperfile, QuantityNames, &
            & hdfVersion=hdfVersion, metadata_error=metadata_error, &
            & filetype='sw'  )
          error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
        case default
          call announce_error ( ROOT, &
            &  "Error--unknown output type: parser should have caught this")
d819 3
a821 3
        end select
      enddo
    end if
d947 3
@


2.74
log
@Should allow us to write metadata after DirectWrite
@
text
@d11 1
d24 1
a24 1
    & "$Id: OutputAndClose.f90,v 2.73 2003/06/20 19:38:26 pwagner Exp $"
d41 2
a42 2
  subroutine Output_Close ( root, l2gpDatabase, l2auxDatabase, matrices, &
    & l2pcf, canWriteL2PC )
d92 1
d836 151
d1111 3
@


2.73
log
@Allows direct writing of output products
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.72 2003/06/09 22:49:33 pwagner Exp $"
d58 3
a60 2
      & F_METANAME, F_OVERLAPS, F_PACKED, F_QUANTITIES, F_TYPE, &
      & L_L2AUX, L_L2DGG, L_L2GP, L_L2PC, S_OUTPUT, S_TIME, F_WRITECOUNTERMAF
d139 1
d169 1
d201 2
d228 161
d958 3
@


2.72
log
@Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
@
text
@d19 1
a19 1
  public :: Output_Close, DirectWrite
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.71 2003/05/12 02:07:06 livesey Exp $"
a715 358
  ! ----------------------------------------------- DirectWrite --------
  subroutine DirectWrite ( quantity, sdName, file, hdfVersion, &
    & chunkNo, chunks )

    ! Purpose:
    ! Write plain hdf-formatted files ala l2aux for datasets that
    ! are too big to keep all chunks stored in memory
    ! so instead write them out chunk-by-chunk
    use MLSCommon, only: MLSCHUNK_T
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, &
      & GetPCFromRef, split_path_name
    use MLSL2Options, only: PENALTY_FOR_NO_METADATA, TOOLKIT, &
      & DEFAULT_HDFVERSION_WRITE
    use MLSPCF2, only: mlspcf_l2fwm_full_start, mlspcf_l2fwm_full_end
    use VectorsModule, only: VectorValue_T

    type (VectorValue_T), intent(in) :: QUANTITY
    integer, intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILE         ! Name of output file
    integer, intent(in) :: HDFVERSION   ! Version of HDF file to write out
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS
    ! Local parameters
    logical, parameter :: DEBUG = .FALSE.
    character (len=132) :: FILE_BASE    ! From the FILE location in string table
    character (len=1024) :: FILENAME    ! The actual filename
    integer :: L2fwmFileHandle, L2fwm_Version
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, save :: NOCREATEDFILES=0   ! Number of files created

    character (len=132) :: path
    integer :: ReturnStatus
    ! Saved variable - used to work out file information.
    integer, dimension(maxFiles), save :: CREATEDFILENAMES = 0
    ! executable code

    ! Setup information, sanity checks etc.
    call get_string ( file, file_base, strip=.true. )
    l2fwm_Version = 1
    if ( TOOLKIT ) then
      call split_path_name(file_base, path, file_base)
      if ( DEBUG ) call output('file_base after split: ', advance='no')
      if ( DEBUG ) call output(trim(file_base), advance='yes')

      L2fwmFileHandle = GetPCFromRef(file_base, mlspcf_l2fwm_full_start, &
      & mlspcf_l2fwm_full_end, &
      & TOOLKIT, returnStatus, L2fwm_Version, DEBUG, &
      & exactName=Filename)
    else
      Filename = file_base
      returnStatus = 0
    end if
    if ( returnStatus /= 0 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
         &  "Error finding l2gp file matching:  "// trim(file_base))
    endif
    ! Setup information, sanity checks etc.
    !if ( hdfVersion /= 4 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !  & 'Unsupported hdfVersion for directWrite' )
    select case (hdfversion)
    case (HDFVERSION_4)
      call DirectWrite_hdf4 ( quantity, sdName, file, fileName, &
        & chunkNo, chunks )
    case (HDFVERSION_5)
      call DirectWrite_hdf5 ( quantity, sdName, file, fileName, &
        & chunkNo, chunks )
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unsupported hdfVersion for directWrite (currently only 4 or 5)' )
    end select
  end subroutine DirectWrite

  ! ----------------------------------------------- DirectWrite_hdf4 --------
  subroutine DirectWrite_hdf4 ( quantity, sdName, file, filename, &
    & chunkNo, chunks )

    use Intrinsic, only: L_None
    use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, &
      & FINISHEDDIRECTWRITE
    use MLSCommon, only: MLSCHUNK_T, R4, R8
    use MLSFiles, only: HDFVERSION_4, MLS_SFSTART, MLS_SFEND
    use VectorsModule, only: VectorValue_T

    type (VectorValue_T), intent(in) :: QUANTITY
    integer, intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILE       ! Name of output file
    character(len=*), intent(in) ::     FILENAME   ! Name of output file
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS

    ! Local parameters
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, parameter :: HDFVERSION = HDFVERSION_4

    ! Saved variable - used to work out file information.
    integer, dimension(maxFiles), save :: CREATEDFILENAMES = 0
    integer, save :: NOCREATEDFILES=0   ! Number of files created

    ! Local variables
    ! character (len=1024) :: FILENAME    ! The actual filename
    character (len=1024) :: SDNAMESTR   ! SDName as a string
    logical :: CREATEFILE               ! Set if file needs to be created
    integer :: FILEID                   ! File handle
    integer :: SDINDEX                  ! Index of sd
    integer :: SDID                     ! Handle for sd
    integer :: STATUS                   ! Status flag
    integer :: START(3)                 ! HDF array starting position
    integer :: STRIDE(3)                ! HDF array stride
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: NODIMS                   ! Also index of maf dimension
    type ( MLSChunk_T ) :: LASTCHUNK    ! The last chunk in the file
    real (r8) :: HUGER4

    ! executable code
    hugeR4 = real ( huge(0.0_r4), r8 )

    ! Setup information, sanity checks etc.
    ! call get_string ( file, filename, strip=.true. )
    call get_string ( sdName, sdNameStr, strip=.true. )
    if ( quantity%template%frequencyCoordinate == L_None ) then
      noDims = 2
    else
      noDims = 3
    end if

    ! If we're a slave, we need to request permission from the master.
    if ( parallel%slave ) then
      call RequestDirectWritePermission ( file, createFile )
    else
      createFile = .not. any ( createdFilenames == file )
      if ( createFile ) then
        noCreatedFiles = noCreatedFiles + 1
        if ( noCreatedFiles > maxFiles ) call MLSMessage ( &
          & MLSMSG_Error, ModuleName, 'Too many direct write files (hdf4)' )
        createdFilenames ( noCreatedFiles ) = file
      end if
    end if

    ! Create or open the file
    if ( createFile ) then
      fileID = mls_sfstart ( trim(filename), DFACC_CREATE, &
       & hdfVersion=hdfVersion )
    else
      fileID = mls_sfstart ( trim(filename), DFACC_RDWR, hdfVersion=hdfVersion )
    end if

    ! Create or access the SD
    sdIndex = sfn2index ( fileID, trim(sdNameStr) )
    if ( sdIndex == -1 ) then
      lastChunk = chunks(size(chunks))
      sizes(noDims) = lastChunk%lastMAFIndex - lastChunk%noMAFSUpperOverlap + 1
      sizes(noDims-1) = quantity%template%noSurfs
      if ( noDims == 3 ) sizes(1) = quantity%template%noChans
      sdId  = sfCreate ( fileID, trim(sdNameStr), DFNT_FLOAT32, &
        & noDims, sizes )
    else
      sdId = sfSelect ( fileID, sdIndex )
    end if
    if ( sdId == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
     & 'Error accessing SD '//trim(sdNameStr) // ' (hdf4)')

    ! What exactly will be our contribution
    stride = 1
    start = 0
    sizes(noDims) = quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap
    sizes(noDims-1) = quantity%template%noSurfs
    if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    start(noDims) = quantity%template%mafIndex ( &
      & 1+quantity%template%noInstancesLowerOverlap )

    ! Now write it out
    status = SFWDATA_F90(sdId, start(1:noDims), &
      & stride(1:noDims), sizes(1:noDims), &
      & real ( max ( -hugeR4, min ( hugeR4, &
      &   quantity%values ( :, &
      &   1+quantity%template%noInstancesLowerOverlap : &
      &    quantity%template%noInstances - quantity%template%noInstancesUpperOverlap &
      &  ) ) ) ) )
    if ( status /= 0 ) then
      call announce_error (0,&
        & "Error writing SDS data " // trim(sdNameStr) // " to l2aux file:  " )
    end if

    ! End access to the SD and close the file
    status = sfEndAcc ( sdId )
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error ending access to direct write sd (hdf4)' )
    status = mls_sfend( fileID, hdfVersion=hdfVersion)
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error ending closing direct write file (hdf4)' )

    ! Tell master we're done
    if ( parallel%slave ) call FinishedDirectWrite

  end subroutine DirectWrite_hdf4

  ! ----------------------------------------------- DirectWrite_hdf5 --------
  subroutine DirectWrite_hdf5 ( quantity, sdName, file, fileName, &
    & chunkNo, chunks )

    use HDF5, only: h5dopen_f
    use Intrinsic, only: L_None
    use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, &
     &  FINISHEDDIRECTWRITE
    use MLSCommon, only: MLSCHUNK_T
    use MLSFiles, only: HDFVERSION_5, MLS_SFSTART, MLS_SFEND
    use MLSHDF5, only: ISHDF5DSPRESENT, SaveAsHDF5DS
    use PCFHdr, only: h5_writeglobalattr
    use VectorsModule, only: VectorValue_T

    type (VectorValue_T), intent(in) :: QUANTITY
    integer, intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILE         ! Name of output file
    character(len=*), intent(in) :: FILENAME  ! Name of output file
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS

    ! Local parameters
    integer, parameter :: MAXFILES = 100             ! Set for an internal array
    integer, parameter :: HDFVERSION = HDFVERSION_5

    ! Saved variable - used to work out file information.
    integer, dimension(maxFiles), save :: CREATEDFILENAMES = 0
    integer, save :: NOCREATEDFILES=0   ! Number of files created

    ! Local variables
    ! character (len=1024) :: FILENAME    ! The actual filename
    logical :: already_there
    logical :: CREATEFILE               ! Set if file needs to be created
    logical, parameter :: DEEBUG = .false.
    integer :: FILEID                   ! File handle
    integer :: first_maf
    integer :: last_maf
    type ( MLSChunk_T ) :: LASTCHUNK    ! The last chunk in the file
    integer :: NODIMS                   ! Also index of maf dimension
    integer :: Num_qty_values
    integer :: SDID                     ! Handle for sd
    integer :: SDINDEX                  ! Index of sd
    character (len=1024) :: SDNAMESTR   ! SDName as a string
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: STATUS                   ! Status flag
    integer :: START(3)                 ! HDF array starting position
    integer :: STRIDE(3)                ! HDF array stride
    integer :: total_DS_size

    ! executable code
    Num_qty_values = size(quantity%values, 1)*size(quantity%values, 2)

    ! Setup information, sanity checks etc.
    ! call get_string ( file, filename, strip=.true. )
    call get_string ( sdName, sdNameStr, strip=.true. )
    if ( quantity%template%frequencyCoordinate == L_None ) then
      noDims = 2
    else
      noDims = 3
    end if

    ! If we're a slave, we need to request permission from the master.
    if ( parallel%slave ) then
      call RequestDirectWritePermission ( file, createFile )
    else
      createFile = .not. any ( createdFilenames == file )
      if ( createFile ) then
        noCreatedFiles = noCreatedFiles + 1
        if ( noCreatedFiles > maxFiles ) call MLSMessage ( &
          & MLSMSG_Error, ModuleName, 'Too many direct write files (hdf5)' )
        createdFilenames ( noCreatedFiles ) = file
      end if
    end if

    ! Create or open the file
    if ( createFile ) then
      fileID = mls_sfstart ( trim(filename), DFACC_CREATE, &
       &                                                 hdfVersion=hdfVersion )
    else
      fileID = mls_sfstart ( trim(filename), DFACC_RDWR, hdfVersion=hdfVersion )
    end if

    ! Create or access the SD
    already_there = IsHDF5DSPresent(fileID, trim(sdNameStr))
    if ( .not. already_there ) then
      lastChunk = chunks(size(chunks))
      sizes(noDims) = lastChunk%lastMAFIndex - lastChunk%noMAFSUpperOverlap + 1
      sizes(noDims-1) = quantity%template%noSurfs
      if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    end if

    ! What exactly will be our contribution
    stride = 1
    start = 0
    sizes(noDims) = quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap
    sizes(noDims-1) = quantity%template%noSurfs
    if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    start(noDims) = quantity%template%mafIndex ( &
      & 1+quantity%template%noInstancesLowerOverlap )
    first_maf = 1+quantity%template%noInstancesLowerOverlap
    last_maf = quantity%template%noInstances &
      &       - quantity%template%noInstancesUpperOverlap

    if ( DEEBUG ) then
      print *, 'sdname ', trim(sdNameStr)
      print *, 'already_there ', already_there
      print *, 'noDims ', noDims
      print *, 'start ', start
      print *, 'sizes ', sizes
      print *, 'shape(quantity%values) ', shape(quantity%values)
      print *, 'first_maf ', first_maf
      print *, 'last_maf ', last_maf
    endif
    ! Make certain things will fit
    if ( noDims == 3 ) then
      total_DS_size = sizes(1)*sizes(2)*sizes(3)
      if ( DEEBUG ) then
        print *, 'total_DS_size ', total_DS_size
        print *, 'Num_qty_values ', Num_qty_values
      endif
      if ( total_DS_size > Num_qty_values ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Number of 3d array elements to write > number stored in qty values' )
      call SaveAsHDF5DS( fileID, trim(sdNameStr), &
        & real( &
        &   reshape(quantity%values(:,first_maf:last_maf), sizes(1:3)) &
        & ), start, sizes, may_add_to=.true., adding_to=already_there)
    else
      total_DS_size = sizes(1)*sizes(2)
      if ( DEEBUG ) then
        print *, 'total_DS_size ', total_DS_size
        print *, 'Num_qty_values ', Num_qty_values
      endif
      if ( total_DS_size > Num_qty_values ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Number of 2d array elements to write > number stored in qty values' )
      call SaveAsHDF5DS( fileID, trim(sdNameStr), &
        & real(quantity%values(:,first_maf:last_maf)), &
        & start, sizes, may_add_to=.true., adding_to=already_there)
    endif

    ! Now some attribute stuff
    ! This first call to write dataset-specific stuff needs work
    ! basically repeat the steps you go through in SetupNewl2auxRecord;
    ! see e.g. Join
    ! call WriteL2AUXAttributes(fileID, l2aux, trim(dataProduct%name))
    ! However I'm too lazy--these files won't be archived at DAAC
    ! so the attribute writing can wait
    call h5_writeglobalattr(fileID, skip_if_already_there=.true.)
    status = mls_sfend( fileID, hdfVersion=hdfVersion)
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error ending closing direct write file (hdf5)' )

    ! Tell master we're done
    if ( parallel%slave ) call FinishedDirectWrite

  end subroutine DirectWrite_hdf5

d792 3
@


2.71
log
@Bound r8->r4 conversion in direct write
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.70 2003/04/03 22:59:23 pwagner Exp $"
d69 2
a70 2
    use MLSL2Options, only: PENALTY_FOR_NO_METADATA, CREATEMETADATA, PCF, &
      & PCFL2CFSAMECASE, DEFAULT_HDFVERSION_WRITE
d228 1
a228 1
          if ( PCF ) then
d235 1
a235 1
            & PCFL2CFSAMECASE, returnStatus, l2gp_Version, DEBUG, &
d296 1
a296 1
            if ( .not. CREATEMETADATA ) cycle
d367 1
a367 1
          if ( PCF ) then
d371 1
a371 1
            & PCFL2CFSAMECASE, returnStatus, l2aux_Version, DEBUG, &
d441 1
a441 1
            if ( .not. CREATEMETADATA ) cycle
d549 1
a549 1
          if ( PCF ) then
d553 1
a553 1
            & PCFL2CFSAMECASE, returnStatus, l2gp_Version, DEBUG, &
d609 1
a609 1
            if ( .not. CREATEMETADATA ) cycle
d674 1
a674 1
      if (CREATEMETADATA ) then
d727 2
a728 2
    use MLSL2Options, only: PENALTY_FOR_NO_METADATA, CREATEMETADATA, PCF, &
      & PCFL2CFSAMECASE, DEFAULT_HDFVERSION_WRITE
d755 1
a755 1
    if ( PCF ) then
d762 1
a762 1
      & PCFL2CFSAMECASE, returnStatus, L2fwm_Version, DEBUG, &
d898 1
a898 1
        & "Error writing SDS data to l2aux file:  " )
d1150 3
@


2.70
log
@setAlias no longer an arg to write_meta
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.69 2003/03/20 19:22:56 pwagner Exp $"
d795 1
a795 1
    use MLSCommon, only: MLSCHUNK_T
d827 1
d830 1
d890 2
a891 1
      & stride(1:noDims), sizes(1:noDims), real ( &
d895 1
a895 1
      &  ) ) )
d1150 3
@


2.69
log
@Fixed bug in DirectWrite_hdf5; seems to work
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.68 2003/03/11 00:21:36 pwagner Exp $"
d333 1
a333 1
                & setAlias=.true., filetype='sw' )
d353 1
a353 1
                & setAlias=.true., filetype='sw'  )
d471 1
a471 1
                & setAlias=.false., filetype='hdf'  )
d636 1
a636 1
                & setAlias=.true., filetype='sw'  )
d1147 3
@


2.68
log
@Interfaces fit new WritePCF2Hdr flixibility
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.67 2003/03/01 00:25:20 pwagner Exp $"
d725 5
a729 1
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5
a737 1

d739 4
d744 1
d746 2
d750 1
a750 1
    integer, save :: NOCREATEDFILES=0   ! Number of files created
d752 7
a758 2
    ! Local variables
    ! executable code
d760 12
d777 1
a777 1
      call DirectWrite_hdf4 ( quantity, sdName, file, &
d780 1
a780 1
      call DirectWrite_hdf5 ( quantity, sdName, file, &
d789 1
a789 1
  subroutine DirectWrite_hdf4 ( quantity, sdName, file, &
d801 2
a802 1
    integer, intent(in) :: FILE         ! Name of output file
d815 1
a815 1
    character (len=1024) :: FILENAME    ! The actual filename
d831 1
a831 1
    call get_string ( file, filename, strip=.true. )
d912 1
a912 1
  subroutine DirectWrite_hdf5 ( quantity, sdName, file, &
d928 1
d941 2
a942 2
    character (len=1024) :: FILENAME    ! The actual filename
    character (len=1024) :: SDNAMESTR   ! SDName as a string
d944 1
d946 6
d953 2
a954 1
    integer :: SDID                     ! Handle for sd
d958 1
a958 4
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: NODIMS                   ! Also index of maf dimension
    type ( MLSChunk_T ) :: LASTCHUNK    ! The last chunk in the file
    logical :: already_there
d961 1
d964 1
a964 1
    call get_string ( file, filename, strip=.true. )
a993 1
    ! sdIndex = sfn2index ( fileID, trim(sdNameStr) )
a999 5
      ! call h5sCreate_simple_f ( 3, int(shp, hSize_T), spaceID, status )
      !sdId  = sfCreate ( fileID, trim(sdNameStr), DFNT_FLOAT32, &
      !  & noDims, sizes )
    ! else
     ! call h5dopen_f ( fileID, trim(sdNameStr), sdIndex, status )
a1000 2
    ! if ( sdId == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !  & 'Error accessing SD '//trim(sdNameStr) // ' (hdf5)' )
d1012 41
a1052 3

    call SaveAsHDF5DS( fileID, trim(sdNameStr), real(quantity%values), &
      & start, sizes, may_add_to=.true., adding_to=already_there)
d1059 2
d1147 3
@


2.67
log
@Disabled writing metadata to Log file (aka PH)
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.66 2003/02/12 21:51:32 pwagner Exp $"
d333 1
a333 1
                & setAlias=.true., isHDFEOS=.true. )
d353 1
a353 1
                & setAlias=.true., isHDFEOS=.true.  )
d471 1
a471 1
                & setAlias=.false., isHDFEOS=.false.  )
d636 1
a636 1
                & setAlias=.true., isHDFEOS=.true.  )
d1080 3
@


2.66
log
@Should allow direct write with attributes
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.65 2003/02/10 22:01:54 pwagner Exp $"
d32 2
d669 4
d674 4
a677 7
    if ( DEBUG ) then
      call output('About to write log file metadata' , advance='yes')
    end if

    if (CREATEMETADATA ) then
      call writeMetaLog ( l2pcf, metadata_error )
      error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
d1080 3
@


2.65
log
@Passes isHDFEOS to metadata; writes globalattributes during DirectWrite
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.64 2003/01/23 23:31:42 pwagner Exp $"
d991 1
a991 1
    call h5_writeglobalattr(fileID)
d1077 3
@


2.64
log
@May directwrite to hdf5 l2aux files
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.63 2002/12/11 22:21:05 pwagner Exp $"
d331 1
a331 1
                & setAlias=.true. )
d351 1
a351 1
                & setAlias=.true.  )
d469 1
a469 1
                & setAlias=.false.  )
d634 1
a634 1
                & setAlias=.true.  )
d717 4
d891 1
a982 7
    ! Now write it out
! >     status = SFWDATA_F90(sdId, start(1:noDims), &
! >       & stride(1:noDims), sizes(1:noDims), real ( &
! >       &   quantity%values ( :, &
! >       &   1+quantity%template%noInstancesLowerOverlap : &
! >       &    quantity%template%noInstances - quantity%template%noInstancesUpperOverlap &
! >       &  ) ) )
a984 4
    ! if ( status /= 0 ) then
    !  call announce_error (0,&
    !    & "Error writing SDS data to l2aux file:  " )
    ! end if
d986 6
a991 4
    ! End access to the SD and close the file
    ! status = sfEndAcc ( sdId )
    ! if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !     & 'Error ending access to direct write sd' )
d1077 3
@


2.63
log
@Makes soft link to data field name from L2gpValue field in hdf5 l2gp
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.62 2002/11/22 19:10:30 pwagner Exp $"
d717 41
d759 2
a760 1
    use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, FINISHEDDIRECTWRITE
d762 1
a762 1
    use MLSFiles, only: MLS_SFSTART, MLS_SFEND
a767 1
    integer, intent(in) :: HDFVERSION   ! Version of HDF file to write out
d773 1
a795 2
    if ( hdfVersion /= 4 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unsupported hdfVersion for directWrite' )
d812 1
a812 1
          & MLSMSG_Error, ModuleName, 'Too many direct write files' )
d819 2
a820 1
      fileID = mls_sfstart ( trim(filename), DFACC_CREATE, hdfVersion=hdfVersion )
d838 1
a838 1
      & 'Error accessing SD '//trim(sdNameStr) )
d866 130
a995 1
        & 'Error ending access to direct write sd' )
d998 1
a998 1
        & 'Error ending closing direct write file' )
d1003 1
a1003 1
  end subroutine DirectWrite
d1081 3
@


2.62
log
@Upped MAXQUANTITIESPERFILE to 10k
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.61 2002/11/13 01:10:09 pwagner Exp $"
d44 1
a44 1

d330 2
a331 1
                & hdfVersion=hdfVersion, metadata_error=metadata_error )
d350 2
a351 1
                & hdfVersion=hdfVersion, metadata_error=metadata_error )
d468 2
a469 1
                & hdfVersion=hdfVersion, metadata_error=metadata_error )
d633 2
a634 1
                & hdfVersion=hdfVersion, metadata_error=metadata_error )
d911 3
@


2.61
log
@Beginnings of attempt to write hdf5 L2AUX; incomplete
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.60 2002/10/08 17:36:22 pwagner Exp $"
d110 1
a110 1
    integer, parameter:: MAXQUANTITIESPERFILE=64        
d907 3
@


2.60
log
@Added idents to survive zealous Lahey optimizer
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.59 2002/08/21 02:35:18 vsnyder Exp $"
d398 2
a399 1
                      &   (writeCounterMAF .and. numquantitiesperfile == 0))
d907 3
@


2.59
log
@Move USE statements from module scope to procedure scope
@
text
@d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.58 2002/08/21 01:05:06 livesey Exp $"
d27 1
d899 4
d906 3
@


2.58
log
@Changed to single precision for direct write
@
text
@a10 2
  use Allocate_Deallocate, only: Deallocate_Test
  use Expr_M, only: Expr
a12 16
  use INIT_TABLES_MODULE, only: F_ASCII, F_FILE, F_HDFVERSION, &
    & F_METANAME, F_OVERLAPS, F_PACKED, F_QUANTITIES, F_TYPE, &
    & L_L2AUX, L_L2DGG, L_L2GP, L_L2PC, S_OUTPUT, S_TIME, F_WRITECOUNTERMAF
  use Intrinsic, only: PHYQ_Dimensionless, L_None
  use L2AUXData, only: L2AUXDATA_T, WriteL2AUXData
  use L2GPData, only: L2GPData_T, WriteL2GPData, L2GPNameLen
  use L2PC_m, only: WRITEONEL2PC, OUTPUTHDF5L2PC
  use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, FINISHEDDIRECTWRITE
  use LEXER_CORE, only: PRINT_SOURCE
  use MatrixModule_1, only: MATRIX_DATABASE_T, MATRIX_T, GETFROMMATRIXDATABASE
  use MLSCommon, only: I4, MLSCHUNK_T
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
  use MLSFiles, only: GetPCFromRef, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF, &
    & SPLIT_PATH_NAME, MLS_SFSTART, MLS_SFEND
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA, CREATEMETADATA, PCF, &
    & PCFL2CFSAMECASE, DEFAULT_HDFVERSION_WRITE
a13 5
  use MLSPCF2, only: MLSPCF_L2DGM_END, MLSPCF_L2DGM_START, MLSPCF_L2GP_END, &
    & MLSPCF_L2GP_START, mlspcf_l2dgg_start, mlspcf_l2dgg_end, &
    & Mlspcf_mcf_l2gp_start, Mlspcf_mcf_l2dgm_start, &
    & Mlspcf_mcf_l2dgg_start
  use MoreTree, only: Get_Spec_ID, GET_BOOLEAN
a14 1
  use SDPToolkit, only: PGS_S_SUCCESS, PGSD_IO_GEN_WSEQFRM, Pgs_smf_getMsg
a15 9
  use Time_M, only: Time_Now
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TOGGLES, only: GEN, TOGGLE, switches
  use TREE, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, &
    & SUBTREE, SUB_ROSA
  use TREE_TYPES, only: N_NAMED
  use VectorsModule, only: VectorValue_T
  use WriteMetadata, only: PCFData_T, Populate_metadata_std, &
    & Populate_metadata_oth, WriteMetaLog, Get_l2gp_mcf
d23 1
a23 1
    & "$Id: OutputAndClose.f90,v 2.57 2002/08/20 04:37:06 livesey Exp $"
d52 30
d144 1
a144 1
   if(index(switches, 'pro') /= 0) then
d147 1
a147 1
   endif
d237 1
a237 1
          endif
d268 1
a268 1
                    endif
d288 1
a288 1
            elseif(index(switches, 'pro') /= 0) then
d371 1
a371 1
          endif
d407 1
a407 1
                    endif
d430 1
a430 1
            elseif(index(switches, 'pro') /= 0) then
d516 1
a516 1
            endif
d551 1
a551 1
          endif
d581 1
a581 1
                  endif
d597 1
a597 1
            elseif(index(switches, 'pro') /= 0) then
d669 1
a669 1
    endif
d678 1
a678 1
   if(index(switches, 'pro') /= 0) then
d681 1
a681 1
   endif
d699 1
a699 1
      endif
d710 7
d814 1
a814 1
    endif
d848 1
a848 1
    endif
d862 1
a862 1
      enddo
d868 4
d901 3
@


2.57
log
@Minor typo
@
text
@d14 1
a14 1
    & SFENDACC, DFNT_FLOAT64, SFWDATA_F90
d56 1
a56 1
    & "$Id: OutputAndClose.f90,v 2.56 2002/08/20 04:33:13 livesey Exp $"
d781 1
a781 1
      sdId  = sfCreate ( fileID, trim(sdNameStr), DFNT_FLOAT64, &
d802 5
a806 3
      & stride(1:noDims), sizes(1:noDims), quantity%values ( :, &
      & 1+quantity%template%noInstancesLowerOverlap : &
      & quantity%template%noInstances - quantity%template%noInstancesUpperOverlap ) )
d893 3
@


2.56
log
@Added extra check in direct write
@
text
@d56 1
a56 1
    & "$Id: OutputAndClose.f90,v 2.55 2002/08/15 21:47:04 pwagner Exp $"
d787 1
a787 1
      & 'Error accessing SD '\\trim(sdNameStr) )
d891 3
@


2.55
log
@WriteL2AuxData now returns non-zero status if it fails
@
text
@d56 1
a56 1
    & "$Id: OutputAndClose.f90,v 2.54 2002/06/12 17:58:42 livesey Exp $"
d786 2
d891 3
@


2.54
log
@Intermediate support for HDF5 L2PCs
@
text
@d56 1
a56 1
    & "$Id: OutputAndClose.f90,v 2.53 2002/05/22 16:30:31 livesey Exp $"
d220 3
d230 3
d398 1
a398 1
                    call WriteL2AUXData ( l2auxDatabase(db_index), sdfid, &
d400 2
a401 1
                      &   (writeCounterMAF .and. numquantitiesperfile == 0) )
d889 3
@


2.53
log
@Bug fix in directWrite
@
text
@d15 1
a15 1
  use INIT_TABLES_MODULE, only: F_FILE, F_HDFVERSION, &
d21 1
a21 1
  use L2PC_m, only: WRITEONEL2PC
d56 1
a56 1
    & "$Id: OutputAndClose.f90,v 2.52 2002/05/22 00:49:01 livesey Exp $"
d95 1
d476 1
a476 4
          l2pcUnit = mls_io_gen_openf ( 'open', .true., error,&
            & recLen, PGSd_IO_Gen_WSeqFrm, trim(file_base), 0,0,0, unknown=.true. )
          if ( error /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName,&
            & 'Failed to open l2pc file:'//trim(file_base))
d486 2
d491 39
a529 14
          do in_field_no = 2, nsons(quantitiesNode)
            db_index = decoration(decoration(subtree(in_field_no, quantitiesNode )))
            call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
            call writeOneL2PC ( tmpMatrix, l2pcUnit, packed )
          end do ! in_field_no = 2, nsons(gson)

          error = mls_io_gen_closef ( 'cl', l2pcUnit)
          if ( error /= 0 ) then
            call MLSMessage(MLSMSG_Error,ModuleName,&
            & 'Failed to close l2pc file:'//trim(file_base))
          elseif(index(switches, 'pro') /= 0) then
               call announce_success(file_base, 'l2pc', &
               & 0, quantityNames)
         endif
d531 1
d882 3
@


2.52
log
@Added direct write stuff
@
text
@d56 1
a56 1
    & "$Id: OutputAndClose.f90,v 2.51 2002/05/07 20:26:15 livesey Exp $"
d769 1
a769 1
      & quantity%template%noInstances - quantity%template%noInstancesLowerOverlap ) )
d856 3
@


2.51
log
@Added writeCounterMAF option for l2aux
@
text
@d13 2
a14 1
  use Hdf, only: DFACC_CREATE  !, SFEND, SFSTART
d18 1
a18 1
  use Intrinsic, only: PHYQ_Dimensionless
d22 1
d25 1
a25 1
  use MLSCommon, only: I4
d46 1
d52 1
a52 1
  public :: Output_Close
d56 1
a56 1
    & "$Id: OutputAndClose.f90,v 2.50 2002/02/22 19:19:48 pwagner Exp $"
d677 111
d856 3
@


2.51.2.1
log
@*** empty log message ***
@
text
@d13 1
a13 2
  use Hdf, only: DFACC_CREATE, DFACC_RDWR, SFN2INDEX, SFSELECT, SFCREATE, &
    & SFENDACC, DFNT_FLOAT64, SFWDATA_F90
d17 1
a17 1
  use Intrinsic, only: PHYQ_Dimensionless, L_None
a20 1
  use L2ParInfo, only: PARALLEL, REQUESTDIRECTWRITEPERMISSION, FINISHEDDIRECTWRITE
d23 1
a23 1
  use MLSCommon, only: I4, MLSCHUNK_T
a43 1
  use VectorsModule, only: VectorValue_T
d49 1
a49 1
  public :: Output_Close, DirectWrite
d53 1
a53 1
    & "$Id: OutputAndClose.f90,v 2.53 2002/05/22 16:30:31 livesey Exp $"
a673 111
  ! ----------------------------------------------- DirectWrite --------
  subroutine DirectWrite ( quantity, sdName, file, hdfVersion, &
    & chunkNo, chunks )
    type (VectorValue_T), intent(in) :: QUANTITY
    integer, intent(in) :: SDNAME       ! Name of sd in output file
    integer, intent(in) :: FILE         ! Name of output file
    integer, intent(in) :: HDFVERSION   ! Version of HDF file to write out
    integer, intent(in) :: CHUNKNO      ! Index into chunks
    type (MLSChunk_T), dimension(:), intent(in) :: CHUNKS

    ! Local parameters
    integer, parameter :: MAXFILES = 100             ! Set for an internal array

    ! Saved variable - used to work out file information.
    integer, dimension(maxFiles), save :: CREATEDFILENAMES = 0
    integer, save :: NOCREATEDFILES=0   ! Number of files created

    ! Local variables
    character (len=1024) :: FILENAME    ! The actual filename
    character (len=1024) :: SDNAMESTR   ! SDName as a string
    logical :: CREATEFILE               ! Set if file needs to be created
    integer :: FILEID                   ! File handle
    integer :: SDINDEX                  ! Index of sd
    integer :: SDID                     ! Handle for sd
    integer :: STATUS                   ! Status flag
    integer :: START(3)                 ! HDF array starting position
    integer :: STRIDE(3)                ! HDF array stride
    integer :: SIZES(3)                 ! HDF array sizes
    integer :: NODIMS                   ! Also index of maf dimension
    type ( MLSChunk_T ) :: LASTCHUNK    ! The last chunk in the file

    ! executable code

    ! Setup information, sanity checks etc.
    if ( hdfVersion /= 4 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unsupported hdfVersion for directWrite' )
    call get_string ( file, filename, strip=.true. )
    call get_string ( sdName, sdNameStr, strip=.true. )
    if ( quantity%template%frequencyCoordinate == L_None ) then
      noDims = 2
    else
      noDims = 3
    end if

    ! If we're a slave, we need to request permission from the master.
    if ( parallel%slave ) then
      call RequestDirectWritePermission ( file, createFile )
    else
      createFile = .not. any ( createdFilenames == file )
      if ( createFile ) then
        noCreatedFiles = noCreatedFiles + 1
        if ( noCreatedFiles > maxFiles ) call MLSMessage ( &
          & MLSMSG_Error, ModuleName, 'Too many direct write files' )
        createdFilenames ( noCreatedFiles ) = file
      end if
    end if

    ! Create or open the file
    if ( createFile ) then
      fileID = mls_sfstart ( trim(filename), DFACC_CREATE, hdfVersion=hdfVersion )
    else
      fileID = mls_sfstart ( trim(filename), DFACC_RDWR, hdfVersion=hdfVersion )
    end if

    ! Create or access the SD
    sdIndex = sfn2index ( fileID, trim(sdNameStr) )
    if ( sdIndex == -1 ) then
      lastChunk = chunks(size(chunks))
      sizes(noDims) = lastChunk%lastMAFIndex - lastChunk%noMAFSUpperOverlap + 1
      sizes(noDims-1) = quantity%template%noSurfs
      if ( noDims == 3 ) sizes(1) = quantity%template%noChans
      sdId  = sfCreate ( fileID, trim(sdNameStr), DFNT_FLOAT64, &
        & noDims, sizes )
    else
      sdId = sfSelect ( fileID, sdIndex )
    end if

    ! What exactly will be our contribution
    stride = 1
    start = 0
    sizes(noDims) = quantity%template%noInstances - &
      & quantity%template%noInstancesLowerOverlap - &
      & quantity%template%noInstancesUpperOverlap
    sizes(noDims-1) = quantity%template%noSurfs
    if ( noDims == 3 ) sizes(1) = quantity%template%noChans
    start(noDims) = quantity%template%mafIndex ( &
      & 1+quantity%template%noInstancesLowerOverlap )

    ! Now write it out
    status = SFWDATA_F90(sdId, start(1:noDims), &
      & stride(1:noDims), sizes(1:noDims), quantity%values ( :, &
      & 1+quantity%template%noInstancesLowerOverlap : &
      & quantity%template%noInstances - quantity%template%noInstancesUpperOverlap ) )
    if ( status /= 0 ) then
      call announce_error (0,&
        & "Error writing SDS data to l2aux file:  " )
    endif

    ! End access to the SD and close the file
    status = sfEndAcc ( sdId )
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error ending access to direct write sd' )
    status = mls_sfend( fileID, hdfVersion=hdfVersion)
    if ( status == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Error ending closing direct write file' )

    ! Tell master we're done
    if ( parallel%slave ) call FinishedDirectWrite

  end subroutine DirectWrite

a741 9
! Revision 2.53  2002/05/22 16:30:31  livesey
! Bug fix in directWrite
!
! Revision 2.52  2002/05/22 00:49:01  livesey
! Added direct write stuff
!
! Revision 2.51  2002/05/07 20:26:15  livesey
! Added writeCounterMAF option for l2aux
!
@


2.50
log
@Fixed bug in metaName use
@
text
@d16 1
a16 1
    & L_L2AUX, L_L2DGG, L_L2GP, L_L2PC, S_OUTPUT, S_TIME
d53 1
a53 1
    & "$Id: OutputAndClose.f90,v 2.49 2002/02/22 01:16:17 pwagner Exp $"
a60 3
  ! Shall we write bogus CounterMAF so l2aux is l1brad counterfeit?
  logical, parameter :: COUNTERFEITCOUNTERMAF = .false.

d96 1
d133 1
d162 1
d177 5
d192 2
d389 2
a390 2
                      & WriteCounterMAF=&
                      & (COUNTERFEITCOUNTERMAF .and. numquantitiesperfile == 0) )
d742 3
@


2.49
log
@Uses new metaName field for mcf file hint
@
text
@d53 1
a53 1
    & "$Id: OutputAndClose.f90,v 2.48 2002/01/29 23:49:38 pwagner Exp $"
d184 1
a184 1
            meta_name = file_base(2:LEN_TRIM(meta_name)-1) ! Parser includes quotes
d735 3
@


2.48
log
@Separate DEFAULT_HDFVERSION_(READ)(WRITE)
@
text
@d15 1
a15 1
    & F_OVERLAPS, F_PACKED, F_QUANTITIES, F_TYPE, &
d53 1
a53 1
    & "$Id: OutputAndClose.f90,v 2.47 2002/01/26 00:10:45 pwagner Exp $"
d112 1
d162 1
d182 3
d283 1
a283 1
            call get_l2gp_mcf ( file_base, l2gp_mcf, l2pcf )
d735 3
@


2.47
log
@Correctly sets hdfVersion; changed proclaim to announce_success
@
text
@d13 1
a13 1
  use Hdf, only: DFACC_CREATE, SFEND, SFSTART
d26 1
a26 1
    & split_path_name !, mls_sfsstart
d28 1
a28 1
    & PCFL2CFSAMECASE, DEFAULT_HDFVERSION
d53 1
a53 1
    & "$Id: OutputAndClose.f90,v 2.46 2002/01/23 21:52:15 pwagner Exp $"
d160 1
a160 1
      hdfVersion = DEFAULT_HDFVERSION
d361 3
a363 3
  !         sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_CREATE, &
  !          & hdfVersion=hdfVersion)
            sdfId = sfstart(l2auxPhysicalFilename, DFACC_CREATE)
d404 2
a405 2
  !         returnStatus = mls_sfend(sdfid, hdfVersion=hdfVersion)
            returnStatus = sfend(sdfid)
d730 3
@


2.46
log
@Accepts and uses hdfVersion optional field
@
text
@d1 1
a1 1
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d12 1
d17 1
d53 1
a53 1
    & "$Id: OutputAndClose.f90,v 2.45 2002/01/18 23:07:48 pwagner Exp $"
d129 3
d183 5
a187 1
            hdfVersion = subtree(2,gson)
d270 1
a270 1
               call proclaim(l2gpPhysicalFilename, 'l2gp', &
d411 1
a411 1
               call proclaim(l2auxPhysicalFilename, 'l2aux', &
d487 1
a487 1
               call proclaim(file_base, 'l2pc', &
d553 1
a553 1
               call proclaim(l2gpPhysicalFilename, 'l2dgg', &
d664 2
a665 2
  ! ---------------------------------------------  proclaim  -----
  subroutine proclaim ( Name, l2_type, num_quants, quantities, hdfVersion )
d697 1
a697 1
  end subroutine proclaim
d730 3
@


2.45
log
@Uses MLSFiles instead of HDFEOS
@
text
@d13 2
a14 1
  use INIT_TABLES_MODULE, only: F_FILE, F_OVERLAPS, F_PACKED, F_QUANTITIES, F_TYPE, &
d26 1
a26 1
    & PCFL2CFSAMECASE
d51 1
a51 1
    & "$Id: OutputAndClose.f90,v 2.44 2002/01/18 00:24:34 livesey Exp $"
d99 1
d155 1
d177 2
d220 1
a220 1
             & debugOption=.false. )
d232 2
a233 1
                    call writeL2GPData ( l2gpDatabase(db_index), swfid )
d254 2
a255 1
            returnStatus = mls_io_gen_closeF('swclose', swfid)
d262 1
a262 1
               & numquantitiesperfile, quantityNames)
d301 1
a301 1
                & metadata_error )
d319 2
a320 1
                & numquantitiesperfile, QuantityNames, metadata_error )
d352 2
a353 1
  !         sdfId = mls_sfstart(l2auxPhysicalFilename, DFACC_CREATE)
d393 3
d397 1
d403 1
a403 1
               & numquantitiesperfile, quantityNames)
d434 2
a435 1
                & numquantitiesperfile, QuantityNames, metadata_error )
d508 1
a508 1
             & debugOption=.false. )
d519 2
a520 1
                  call writeL2GPData ( l2gpDatabase(db_index), swfid )
d537 2
a538 1
            returnStatus = mls_io_gen_closeF('swclose', swfid)
d545 1
a545 1
               & numquantitiesperfile, quantityNames)
d573 2
a574 1
                & numquantitiesperfile, QuantityNames, metadata_error )
d656 1
a656 1
  subroutine proclaim ( Name, l2_type, num_quants, quantities )
d658 3
a660 2
    character(LEN=*), intent(in) :: Name
    character(LEN=*), intent(in) :: l2_type
d665 8
a672 1
    call output ( trim(l2_type), advance='yes')
d721 3
@


2.44
log
@Added packed option to outputing l2pc files
@
text
@a12 1
  use HDFEOS, only: SWCLOSE, SWOPEN
d23 1
a23 1
    & split_path_name
d50 1
a50 1
    & "$Id: OutputAndClose.f90,v 2.43 2001/11/20 00:48:54 livesey Exp $"
d118 1
d212 4
a215 1
            swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
d247 2
a248 1
            returnStatus = swclose(swfid)
d343 2
d491 4
a494 1
            swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
d521 2
a522 1
            returnStatus = swclose(swfid)
d696 3
@


2.43
log
@Alleviated one bug in zero chunks case, but there's another one to
fix later.  We need to decide how to handle this one.
@
text
@d14 1
a14 1
  use INIT_TABLES_MODULE, only: F_FILE, F_OVERLAPS, F_QUANTITIES, F_TYPE, &
d32 1
a32 1
  use MoreTree, only: Get_Spec_ID
d51 1
a51 1
    & "$Id: OutputAndClose.f90,v 2.42 2001/11/09 23:17:22 vsnyder Exp $"
d114 1
d116 1
d430 1
d439 1
a439 5
              do in_field_no = 2, nsons(gson)
                db_index = decoration(decoration(subtree(in_field_no ,gson)))
                call GetFromMatrixDatabase ( matrices(db_index), tmpMatrix )
                call writeOneL2PC ( tmpMatrix, l2pcUnit )
              end do ! in_field_no = 2, nsons(gson)
d442 2
d446 7
d686 4
@


2.42
log
@Use Time_Now instead of CPU_TIME
@
text
@d27 1
a27 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d51 1
a51 1
    & "$Id: OutputAndClose.f90,v 2.41 2001/11/01 21:05:10 pwagner Exp $"
d221 14
a234 9
                  call writeL2GPData ( l2gpDatabase(db_index), swfid )
                  numquantitiesperfile = numquantitiesperfile+1
                  if ( numquantitiesperfile > MAXQUANTITIESPERFILE ) then
                    call announce_error ( son, &
                      & 'Attempt to write too many l2gp quantities to a file', &
                      & numquantitiesperfile )
                    numquantitiesperfile = MAXQUANTITIESPERFILE
                  endif
                  quantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
d349 1
a349 7
                  if ( DEBUG ) then
                    call output ( "db index:  ", advance='no')
                    call output ( db_index, advance='yes')
                    call output ( "db size:  ", advance='no')
                    call output ( size(l2auxDatabase), advance='yes')
                  end if
                  if ( db_index <= size(l2auxDatabase) ) then
d351 2
a352 2
                    & WriteCounterMAF=&
                    & (COUNTERFEITCOUNTERMAF .and. numquantitiesperfile == 0) )
d362 1
a362 1
                       call get_string &
d366 2
a367 6
                    call announce_error ( root, &
              	      &  "l2aux database smaller than db_index  ")
                    call output ( "db size:  ", advance='no')
                    call output ( size(l2auxDatabase), advance='yes')
                    call output ( "db index:  ", advance='no')
                    call output ( db_index, advance='yes')
d678 3
@


2.41
log
@Satisfies new WriteL2AuxData interface
@
text
@d36 1
d51 1
a51 1
    & "$Id: OutputAndClose.f90,v 2.40 2001/10/12 23:12:23 pwagner Exp $"
d128 1
a128 1
    if ( timing ) call cpu_time ( t1 )
d564 1
a564 1
          call cpu_time ( t1 )
d610 1
a610 1
      call cpu_time ( t2 )
d683 3
@


2.40
log
@Checks that number of quantities written to a file not grow too large
@
text
@d50 1
a50 1
    & "$Id: OutputAndClose.f90,v 2.39 2001/09/28 23:59:20 pwagner Exp $"
d58 3
d350 3
a352 1
                    call WriteL2AUXData ( l2auxDatabase(db_index),sdfid )
d682 3
@


2.39
log
@Fixed various timing problems
@
text
@d50 1
a50 1
    & "$Id: OutputAndClose.f90,v 2.38 2001/09/28 17:50:30 pwagner Exp $"
d108 1
a108 1
    integer :: Numquantitiesperfile        
d219 6
d351 7
a357 1
                    call get_string &
d489 6
a568 1
    if ( timing ) call sayTime
d599 1
d635 3
a637 3
    call output ( 'number ' )
    call blanks(5)
    call output ( 'quantity', advance='yes')
d677 3
@


2.38
log
@MLSL2Timings module keeps timing info
@
text
@d15 1
a15 1
    & L_L2AUX, L_L2DGG, L_L2GP, L_L2PC, LIT_INDICES, S_OUTPUT, S_TIME
d18 1
a18 1
  use L2PC_m, only: WRITEONEL2PC, L2PCDATABASE
d38 1
a38 1
  use TREE, only: DECORATION, DUMP_TREE_NODE, NODE_ID, NSONS, SOURCE_REF, &
d50 1
a50 1
    & "$Id: OutputAndClose.f90,v 2.37 2001/06/04 23:57:40 pwagner Exp $"
d124 1
d659 3
@


2.37
log
@Splits path from l2cf-defined file name before getPCfromRef
@
text
@d22 1
d50 1
a50 1
    & "$Id: OutputAndClose.f90,v 2.36 2001/05/30 23:03:13 pwagner Exp $"
d123 1
a123 1
    timing = .false.
d586 5
d658 3
@


2.36
log
@Moved PCFL2CFSAMECASE to MLSL2Options
@
text
@d22 2
a23 1
  use MLSFiles, only: GetPCFromRef, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF
d49 1
a49 1
    & "$Id: OutputAndClose.f90,v 2.35 2001/05/17 22:33:28 pwagner Exp $"
d109 1
d188 1
d304 1
d446 1
d652 3
@


2.35
log
@Prints info if pro switch set
@
text
@d23 2
a24 1
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA, CREATEMETADATA, PCF
d48 1
a48 1
    & "$Id: OutputAndClose.f90,v 2.34 2001/05/04 23:22:13 pwagner Exp $"
a58 3
  ! Must files named in PCF have same case as short names used in l2cf?
  logical, parameter :: PCFL2FCSAMECASE = .FALSE.

d188 1
a188 1
            & PCFL2FCSAMECASE, returnStatus, l2gp_Version, DEBUG, &
d303 1
a303 1
            & PCFL2FCSAMECASE, returnStatus, l2aux_Version, DEBUG, &
d444 1
a444 1
            & PCFL2FCSAMECASE, returnStatus, l2gp_Version, DEBUG, &
d647 3
@


2.34
log
@Detachable from Toolkit; created metafiles conditionally
@
text
@d30 1
a30 1
  use OUTPUT_M, only: OUTPUT
d34 1
a34 1
  use TOGGLES, only: GEN, TOGGLE
d47 1
a47 1
    & "$Id: OutputAndClose.f90,v 2.33 2001/05/04 23:19:55 pwagner Exp $"
d128 5
d229 3
d363 3
d429 2
a430 1
          if ( error /= 0 ) call MLSMessage(MLSMSG_Error,ModuleName,&
d432 4
d485 3
d566 6
d591 27
d649 3
@


2.33
log
@Detachable from Toolkit; created metafiles conditionally
@
text
@d47 1
a47 1
    & "$Id: OutputAndClose.f90,v 2.32 2001/05/03 20:32:33 vsnyder Exp $"
d535 4
a538 2
    call writeMetaLog ( l2pcf, metadata_error )
    error = max(error, PENALTY_FOR_NO_METADATA*metadata_error)
d597 3
@


2.32
log
@Add a nullify and some cosmetic changes
@
text
@d23 1
a23 1
  use MLSL2Options, only: PENALTY_FOR_NO_METADATA
d31 1
a31 1
  use SDPToolkit, only: PGS_S_SUCCESS, PGS_SMF_GETMSG, PGSD_IO_GEN_WSEQFRM
d47 1
a47 1
    & "$Id: OutputAndClose.f90,v 2.31 2001/05/01 23:57:23 pwagner Exp $"
d182 2
a183 1
          l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
d187 4
d226 2
d260 2
a261 2
              call populate_metadata_std ( &
                & l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
d278 2
a279 2
              call populate_metadata_oth ( &
                & l2gpFileHandle, l2gp_mcf, l2pcf, &
d294 2
a295 1
          l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
d299 4
d357 2
d383 2
a384 2
              call populate_metadata_oth ( &
                & l2auxFileHandle, l2aux_mcf, l2pcf, &
d427 2
a428 1
          l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2dgg_start, &
d432 4
d471 2
d494 2
a495 2
              call populate_metadata_oth ( &
                & l2gpFileHandle, mlspcf_mcf_l2dgg_start, l2pcf, &
d595 3
@


2.31
log
@Added l2dgg output type
@
text
@d47 1
a47 1
    & "$Id: OutputAndClose.f90,v 2.30 2001/04/28 01:30:52 livesey Exp $"
d90 1
d97 5
a101 2
    integer :: l2auxFileHandle, l2aux_Version
    integer :: l2gp_mcf, l2aux_mcf, l2dgg_mcf  ! mcf numbers for writing metadata
a102 3
    character (len=132) :: l2auxPhysicalFilename
    integer :: l2gpFileHandle, l2gp_Version
    character (len=132) :: l2gpPhysicalFilename
d104 3
a106 3
    integer :: metadata_error
    character (len=32) :: mnemonic
    character (len=256) :: msg
d108 1
a108 1
    integer:: numquantitiesperfile        
d112 1
a112 1
    integer :: returnStatus
d118 1
a119 3
    logical, parameter :: DEBUG = .FALSE.

    type (Matrix_T), pointer :: TMPMATRIX ! A pointer to a matrix to write into l2pc
a395 1
                nullify (tmpMatrix)
d574 3
@


2.30
log
@Stuff formerly outputting L2PCs is now outputting matrices.
@
text
@d15 1
a15 1
    & L_L2AUX, L_L2GP, L_L2PC, LIT_INDICES, S_OUTPUT, S_TIME
d26 1
a26 1
    & MLSPCF_L2GP_START, &
d47 1
a47 1
    & "$Id: OutputAndClose.f90,v 2.29 2001/04/26 20:02:09 livesey Exp $"
d108 1
a108 1
    integer :: OUTPUT_TYPE              ! L_L2AUX or L_L2GP
d166 12
d408 83
d500 5
d506 1
d576 3
@


2.29
log
@Made l2pc database a saved array in L2PC_m
@
text
@d18 1
a18 1
  use L2PC_m, only: L2PC_T, WRITEONEL2PC, L2PCDATABASE
d20 1
d47 1
a47 1
    & "$Id: OutputAndClose.f90,v 2.28 2001/04/26 15:59:13 livesey Exp $"
d64 1
a64 1
  subroutine Output_Close ( root, l2gpDatabase, l2auxDatabase, &
d81 3
a83 2
    type (L2GPData_T), dimension(:), pointer :: l2gpDatabase ! L2GP products
    type (L2AUXData_T), dimension(:), pointer :: l2auxDatabase ! L2AUX products
d120 2
d385 3
a387 1
                call writeOneL2PC ( l2pcDatabase(db_index), l2pcUnit )
d475 3
@


2.28
log
@Fixed arguments to writeOneL2PC
@
text
@d18 1
a18 1
  use L2PC_m, only: L2PC_T, WRITEONEL2PC
d46 1
a46 1
    & "$Id: OutputAndClose.f90,v 2.27 2001/04/25 21:51:28 livesey Exp $"
d63 1
a63 1
  subroutine Output_Close ( root, l2gpDatabase, l2auxDatabase, l2pcDatabase,&
a81 1
    type (L2PC_T), dimension(:), pointer :: l2pcDatabase ! L2PC products
d469 3
@


2.27
log
@Minor changes, add canWriteL2PC flag
@
text
@d46 1
a46 1
    & "$Id: OutputAndClose.f90,v 2.26 2001/04/25 20:34:04 livesey Exp $"
d382 1
a382 1
                call writeOneL2PC ( l2pcDatabase(db_index), l2pcUnit, lit_indices )
d470 3
@


2.26
log
@Now writes l2pc files
@
text
@d46 1
a46 1
    & "$Id: OutputAndClose.f90,v 2.25 2001/04/20 23:51:24 vsnyder Exp $"
d64 1
a64 1
    & l2pcf )
d83 2
a84 1
    type(PCFData_T) :: l2pcf
d369 2
d373 1
a373 1
            & recLen, PGSd_IO_Gen_WSeqFrm, trim(file_base), 0,0,0 )
d470 3
@


2.25
log
@Improve an error message.  Add an option to consider the penalty in
Announce_Error.  Numerous cosmetic changes.
@
text
@d15 1
a15 1
    & L_L2AUX, L_L2GP, S_OUTPUT, S_TIME
d18 1
d21 1
a21 1
  use MLSFiles, only: GetPCFromRef
d30 1
a30 1
  use SDPToolkit, only: PGS_S_SUCCESS, Pgs_smf_getMsg
d46 1
a46 1
    & "$Id: OutputAndClose.f90,v 2.24 2001/04/19 23:51:40 pwagner Exp $"
d63 2
a64 1
  subroutine Output_Close ( root, l2gpDatabase, l2auxDatabase, l2pcf )
d82 1
d96 1
d108 1
d163 1
a163 1
        case ( l_l2gp )
d173 2
a174 1
            if ( DEBUG ) call output('file name: ' // TRIM(l2gpPhysicalFilename), advance='yes')
d267 1
a267 1
        case ( l_l2aux )
d279 2
a280 1
            if ( DEBUG ) call output ( 'file name: ' // TRIM(l2auxPhysicalFilename), advance='yes' )
d304 2
a305 1
                    if ( DEBUG ) call output("attempting to fill quantity name", advance='yes')
d365 23
d389 1
d467 4
@


2.24
log
@Moved anText to become component of PCFData_T
@
text
@d11 2
a12 2
  use Hdf, only: DFACC_CREATE, SFEND, &
    & SFSTART
d15 1
a15 1
    & FIELD_FIRST, FIELD_LAST, L_L2AUX, L_L2GP, S_OUTPUT, S_TIME
d25 2
a26 2
    & mlspcf_mcf_l2gp_start, mlspcf_mcf_l2dgm_start, &
    & mlspcf_mcf_l2dgg_start
d36 2
a37 2
  use WriteMetadata, only: PCFData_T, populate_metadata_std, &
    & populate_metadata_oth, WriteMetaLog, get_l2gp_mcf
d44 4
a47 3
  CHARACTER(LEN=130), private :: id = & 
    & "$Id: OutputAndClose.f90,v 2.23 2001/04/16 23:51:08 pwagner Exp $"
  character(len=*), parameter, private :: ModuleName = &
d54 1
a54 1
    integer :: ERROR
d57 1
a57 1
    logical, parameter :: PCFL2FCSAMECASE = .FALSE.
d64 1
a64 11
	! Hard-wired assumptions:
	
	! ----------------------- metadata ------------------------
	
	!   for the l2aux the mcf is mlspcf_mcf_l2dgm_start
	!   for the log file the mcf is mlspcf_mcf_l2log_start
	!   for the dgg file the mcf is mlspcf_mcf_l2dgg_start

	! The correspondence between MCF and l2gp files is determined by
	! the value of        MCFFORL2GPOPTION
   ! (see write_metadata module for fuller explanation)
d66 11
a76 1
  ! Arguments
d80 1
a80 1
	 type(PCFData_T) :: l2pcf
d82 1
a82 1
  ! - - - Local declarations - - -
d84 1
a84 1
    integer :: db_index
a87 1
    logical :: GOT(field_first:field_last)
d109 1
a109 1
    REAL :: T1, T2     ! for timing
a118 1
    got = .false.
d130 2
a131 2
    	l2gp_Version = 1
    	l2aux_Version = 1
a146 1
          got(field_index) = .true.
d150 1
a150 1
            file_base=file_base(2:LEN_TRIM(file_base)-1) ! Parser includes quotes
d159 1
a159 1
			if(DEBUG) call output('output file type l2gp', advance='yes')
d162 2
a163 2
   				l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
				& mlspcf_l2gp_end, &
d166 70
a235 88
 
            if ( returnStatus == 0 ) then
					if(DEBUG) call output('file name: ' // TRIM(l2gpPhysicalFilename), advance='yes')
                ! Open the HDF-EOS file and write swath data
                
					if(DEBUG) call output('Attempting swopen', advance='yes')
                swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)

                ! Loop over the segments of the l2cf line
                
					numquantitiesperfile = 0
                do field_no = 2, nsons(key) ! Skip "output" name
                  gson = subtree(field_no,key)
                  select case ( decoration(subtree(1,gson)) )
                  case ( f_quantities )
                    do in_field_no = 2, nsons(gson)
                      db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                      CALL WriteL2GPData(l2gpDatabase(db_index),swfid)
							 numquantitiesperfile=numquantitiesperfile+1
							 QuantityNames(numquantitiesperfile) = l2gpDatabase(db_index)%name
                    end do ! in_field_no = 2, nsons(gson)
                  case ( f_overlaps )
                    ! ??? More work needed here
                  end select
                end do ! field_no = 2, nsons(key)

					if(DEBUG) call output('Attempting swclose', advance='yes')
                returnStatus = swclose(swfid)
                if (returnStatus /= PGS_S_SUCCESS) then
                  call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                  call MLSMessage ( MLSMSG_Error, ModuleName, &
                    &  "Error closing  l2gp file:  "//mnemonic//" "//msg )
                end if

					! Write the metadata file

               call get_l2gp_mcf(file_base, l2gp_mcf, l2pcf)

					if(l2gp_mcf <= 0) then

               ! Error in finding mcf number
						call announce_error(son, &
						& 'No mcf numbers correspond to this l2gp file', l2gp_mcf)

					elseif(numquantitiesperfile <= 0) then

               ! Error in number of quantities
						call announce_error(son, &
						& 'No quantities written for this l2gp file')

					elseif(QuantityNames(numquantitiesperfile) &
					& == QuantityNames(1) ) then

					! Typical homogeneous l2gp file: 
               ! e.g., associated with BrO is ML2BRO.001.MCF
					if(DEBUG) then
						call output('preparing to populate metadata_std', advance='yes')
						call output('l2gpFileHandle: ', advance='no')
						call output(l2gpFileHandle , advance='no')
						call output('   l2gp_mcf: ', advance='no')
						call output(l2gp_mcf , advance='no')
						call output('   swfid: ', advance='no')
						call output(swfid , advance='yes')
					endif

						call populate_metadata_std &
						& (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), &
                  & metadata_error)
                  error=max(error, PENALTY_FOR_NO_METADATA*metadata_error)

					else

					! Type l2gp file 'other'
					if(DEBUG) then
						call output('preparing to populate metadata_oth', advance='yes')
						call output('l2gpFileHandle: ', advance='no')
						call output(l2gpFileHandle , advance='no')
						call output('   l2gp_mcf: ', advance='no')
						call output(l2gp_mcf , advance='no')
						call output('   swfid: ', advance='no')
						call output(swfid , advance='yes')
					endif

						call populate_metadata_oth &
						& (l2gpFileHandle, l2gp_mcf, l2pcf, &
						& numquantitiesperfile, QuantityNames, metadata_error)
                  error=max(error, PENALTY_FOR_NO_METADATA*metadata_error)
					endif
a237 2
              call announce_error ( ROOT, &
                &  "Error finding l2gp file matching:  "//file_base, returnStatus)
d239 15
d255 6
a260 1
            
d262 5
a266 5
          
 			if(DEBUG) call output('output file type l2aux', advance='yes')
         ! Get the l2aux file name from the PCF
          
  				l2auxFileHandle = GetPCFromRef(file_base, mlspcf_l2dgm_start, &
d268 4
a271 83
             & PCFL2FCSAMECASE, returnStatus, l2aux_Version, DEBUG, &
             & exactName=l2auxPhysicalFilename)
 
            if ( returnStatus == 0 ) then
				
					if(DEBUG) call output('file name: ' // TRIM(l2auxPhysicalFilename), advance='yes')
                ! Create the HDF file and initialize the SD interface
					if(DEBUG) call output('Attempting sfstart', advance='yes')
                sdfId = sfstart(l2auxPhysicalFilename, DFACC_CREATE)
                
              	if(DEBUG) call output ( "looping over quantities", advance='yes')
					numquantitiesperfile = 0
                do field_no = 2, nsons(key) ! Skip "output" name
                  gson = subtree(field_no,key)
                  select case ( decoration(subtree(1,gson)) )
                  case ( f_quantities )
                    do in_field_no = 2, nsons(gson)
              				if(DEBUG) &
								& call output ( "computing db index", advance='yes')
                      db_index = -decoration(decoration(subtree(in_field_no ,gson)))
              				if(DEBUG) then
								  call output ( "db index:  ", advance='no')
								  call output ( db_index, advance='yes')
								  call output ( "db size:  ", advance='no')
              				  call output ( size(l2auxDatabase), advance='yes')
								endif
								if(db_index <= size(l2auxDatabase)) then
                     		 CALL WriteL2AUXData(l2auxDatabase(db_index),sdfid)
									 numquantitiesperfile=numquantitiesperfile+1
              				 if(DEBUG) call output("attempting to fill quantity name", advance='yes')
			          		  call get_string &
                          & ( l2auxDatabase(db_index)%name, &
                          &     QuantityNames(numquantitiesperfile) )
								else
              				 call announce_error ( ROOT, &
               			 &  "l2aux database smaller than db_index  ")
								 call output ( "db size:  ", advance='no')
              				 call output ( size(l2auxDatabase), advance='yes')
								 call output ( "db index:  ", advance='no')
              				 call output ( db_index, advance='yes')
								endif
                    end do ! in_field_no = 2, nsons(gson)
                  case ( f_overlaps )
                    ! ??? More work needed here
                  end select
                end do ! field_no = 2, nsons(key)
                
                ! Now close the file
                returnStatus = sfend(sdfid)
                if ( returnStatus /= PGS_S_SUCCESS ) then
              		 call announce_error ( ROOT, &
               	 &  "Error closing l2aux file:  "//l2auxPhysicalFilename, returnStatus)
               end if

				! Write the metadata file
					if(numquantitiesperfile <= 0) then
						call announce_error(son, &
						& 'No quantities written for this l2aux file')
					else

					! We may need to think more about this; until then reuse
               ! populate_metadata_oth, but with l2aux_mcf
					if(DEBUG) then
						call output('preparing to populate metadata_oth', advance='yes')
						call output('l2auxFileHandle: ', advance='no')
						call output(l2auxFileHandle , advance='no')
						call output('   l2aux_mcf: ', advance='no')
						call output(l2aux_mcf , advance='no')
						call output('   sdfId: ', advance='no')
						call output(sdfId , advance='yes')
						call output('   number of quantities: ', advance='no')
						call output(numquantitiesperfile , advance='yes')
                  do field_no=1, numquantitiesperfile
						   call output(field_no , advance='no')
						   call output('       ', advance='no')
						   call output(trim(QuantityNames(field_no)) , advance='yes')
                  enddo
					endif
						call populate_metadata_oth &
						& (l2auxFileHandle, l2aux_mcf, l2pcf, &
						& numquantitiesperfile, QuantityNames, metadata_error)
                  error=max(error, PENALTY_FOR_NO_METADATA*metadata_error)
					endif
d273 53
d327 23
a349 2
              call announce_error ( ROOT, &
                &  "Error finding l2aux file matching:  "//file_base, returnStatus)
d352 5
d371 3
a373 3
		if(DEBUG) then
			call output('About to write log file metadata' , advance='yes')
		endif
d375 2
a376 2
      CALL WriteMetaLog(l2pcf, metadata_error)
      error=max(error, PENALTY_FOR_NO_METADATA*metadata_error)
d380 9
a388 14
		if(DEBUG) then
			call output('About to deallocate text of PCF file' , advance='yes')
		endif

      DEALLOCATE(l2pcf%anText, STAT=returnStatus)
		if(returnStatus /= 0) then
			call announce_error(0, &
			& 'Failed to deallocate anText of PCF file')
		endif

    if (ERROR/=0 ) then
	 	call MLSMessage(MLSMSG_Error,ModuleName, &
      & 'Problem with Output_Close section')
	end if
d405 10
a414 4
  subroutine ANNOUNCE_ERROR ( WHERE, full_message, CODE )
    integer, intent(in) :: WHERE   ! Tree node where error was noticed
    character(LEN=*), intent(in)    :: full_message
    integer, intent(in), optional :: CODE    ! Code for error message
a415 1
    error = max(error,1)
a423 10
    call output ( ': ' )
    call output ( "The " );
    if ( where > 0 ) then
      call dump_tree_node ( where, 0 )
    else
      call output ( '(no lcf tree available)' )
    end if

    call output ( " Caused the following error: ", advance='yes', &
      & from_where=ModuleName )
d435 3
@


2.23
log
@Gets penalty from MLSL2Options
@
text
@d45 1
a45 1
    & "$Id: OutputAndClose.f90,v 2.22 2001/04/13 23:48:37 pwagner Exp $"
d61 1
a61 1
  subroutine Output_Close ( root, l2gpDatabase, l2auxDatabase, l2pcf, anText )
a79 1
      CHARACTER (LEN=1), POINTER :: anText(:)
d234 1
a234 1
						& (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), anText, &
d253 1
a253 1
						& numquantitiesperfile, QuantityNames, anText, metadata_error)
d350 1
a350 1
						& numquantitiesperfile, QuantityNames, anText, metadata_error)
d386 1
a386 1
      DEALLOCATE(anText, STAT=returnStatus)
d447 3
@


2.22
log
@Removed bogus increment of l2gp_mcf
@
text
@d21 1
d26 1
a26 1
    & mlspcf_mcf_l2dgg_start, PENALTY_FOR_NO_METADATA
d37 1
a37 1
    & populate_metadata_oth, WriteMetaLog, get_l2gp_mcf, MCFFORL2GPOPTION
d45 1
a45 1
    & "$Id: OutputAndClose.f90,v 2.21 2001/04/13 00:26:23 pwagner Exp $"
a81 11

  ! - - - External Procedures

! Not needed any longer
!    interface
!      integer function SFSDMNAME ( DIM_ID, DIM_NAME ) ! An HDF function
!        integer, intent(in) :: DIM_ID
!        character(len=*), intent(in) :: DIM_NAME
!      end function SFSDMNAME
!    end interface

a97 1
!    integer, parameter :: MCFFORL2GPOPTION=1		! 1, 2 or 3
d165 1
a165 12
 !         l2gpFileHandle = mlspcf_l2gp_start
 !         found = .FALSE.
 !         do while ((.NOT. found) .AND. (l2gpFileHandle <=  mlspcf_l2gp_end))
 !           l2gp_Version=1
 !           returnStatus = Pgs_pc_getReference(l2gpFileHandle, l2gp_Version, &
 !             & l2gpPhysicalFilename)
 !           
 !           if ( returnStatus == PGS_S_SUCCESS ) then
 !             if ( INDEX(l2gpPhysicalFilename, TRIM(file_base)) /= 0 ) then
 !               found = .true.
 
  				l2gpFileHandle = GetPCFromRef(file_base, mlspcf_l2gp_start, &
a256 3
!              else                ! Found the right file
!                l2gpFileHandle = l2gpFileHandle + 1
!              end if
a258 3
!              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
!              call MLSMessage ( MLSMSG_Error, ModuleName, &
!                &  "Error finding l2gp file:  "//mnemonic//" "//msg )
a263 4
!          end do !(.not. found) .and. (l2gpFileHandle <=  mlspcf_l2gp_end)
!          IF (.NOT. found) CALL MLSMessage(MLSMSG_Error,ModuleName,&
!            'Unable to find filename containing '//TRIM(file_base))
          
a268 11
!          l2auxFileHandle = mlspcf_l2dgm_start
!          found = .FALSE.
!          do while ((.NOT. found) .AND. (l2auxFileHandle <=  mlspcf_l2dgm_end))
!            l2aux_Version=1
!            returnStatus = Pgs_pc_getReference(l2auxFileHandle, l2aux_Version, &
!              & l2auxPhysicalFilename)
            
!            if ( returnStatus == PGS_S_SUCCESS ) then
!              if ( INDEX(l2auxPhysicalFilename, TRIM(file_base)) /= 0 )then
!                found = .TRUE.
                
a320 3
 !                 call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
 !                 call MLSMessage ( MLSMSG_Error, ModuleName, &
 !                   &  "Error closing l2aux file:  "//mnemonic//" "//msg )
a353 3
!              else
!                l2auxFileHandle =  l2auxFileHandle + 1
!              end if
a355 3
!              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
!              call MLSMessage ( MLSMSG_Error, ModuleName, &
!                &  "Error finding l2aux file:  "//mnemonic//" "//msg )
a358 2
            
!          end do ! (.not. found) .and. (l2auxFileHandle <=  mlspcf_l2aux_end)
a419 1
!    call print_source ( source_ref(where) )
d448 3
@


2.21
log
@Whether files named in PCF agree in case with l2cf controlled
@
text
@d44 1
a44 1
    & "$Id: OutputAndClose.f90,v 2.19 2001/04/10 23:01:57 pwagner Exp $"
a259 1
						l2gp_mcf = l2gp_mcf + 1
d344 3
a346 1
			          		  call get_string ( sub_rosa(subtree(2,gson)), QuantityNames(numquantitiesperfile) )
d387 7
d503 3
@


2.20
log
@Improved an error message
@
text
@d54 3
d72 1
d108 1
a108 1
!    integer, parameter :: MCFFORL2GPOPTION=1		! Either 1 or 2
d133 3
a135 1
    l2gp_mcf = mlspcf_mcf_l2gp_start
d189 2
a190 1
  & .TRUE., returnStatus, l2gp_Version, .true., exactName=l2gpPhysicalFilename)
d226 3
a228 3
					if(MCFFORL2GPOPTION == 2) then
						l2gp_mcf = get_l2gp_mcf(swfid)
					endif
d230 2
d234 1
d236 2
d240 1
d244 2
a245 1
					! Typical homogeneous l2gp file: e.g., BrO is ML2BRO.001.MCF
d255 1
d274 1
d314 3
a316 2
				& mlspcf_l2dgm_end, &
  & .TRUE., returnStatus, l2aux_Version, .true., exactName=l2auxPhysicalFilename)
d376 2
a377 1
					! We will need to think harder about this; until then reuse
@


2.19
log
@Now works better; tacks if no metadata
@
text
@d24 2
a25 2
	 & mlspcf_mcf_l2gp_start, mlspcf_mcf_l2dgm_start, &
	 & mlspcf_mcf_l2dgg_start, PENALTY_FOR_NO_METADATA
d36 1
a36 1
  & populate_metadata_oth, WriteMetaLog, get_l2gp_mcf, MCFFORL2GPOPTION
d44 1
a44 1
    & "$Id: OutputAndClose.f90,v 2.18 2001/04/09 23:44:34 pwagner Exp $"
d443 1
a443 1
	character(LEN=*), intent(in)    :: full_message
d449 5
a453 5
	if(where > 0) then
	    call print_source ( source_ref(where) )
		else
    call output ( '(no lcf node available)' )
		endif
d458 15
a472 15
	if(where > 0) then
    call dump_tree_node ( where, 0 )
		else
    call output ( '(no lcf tree available)' )
		endif

		CALL output("Caused the following error:", advance='yes', &
		& from_where=ModuleName)
		CALL output(trim(full_message), advance='yes', &
		& from_where=ModuleName)
		if(present(code)) then
			select case ( code )
			end select
		endif
    end subroutine ANNOUNCE_ERROR
d477 3
@


2.18
log
@Fewer mistakes, more debug-type output
@
text
@d25 1
a25 1
	 & mlspcf_mcf_l2dgg_start
d36 1
a36 1
  & populate_metadata_oth, WriteMetaLog, get_l2gp_mcf
d44 1
a44 1
    & "$Id: OutputAndClose.f90,v 2.17 2001/04/07 00:13:44 pwagner Exp $"
a68 21
	! Either
	!                          (1)
	! The PCF numbers for the mcf corresponding to each
	! of the l2gp files begin with mlspcf_mcf_l2gp_start
	! and increase 1 by 1 with each succeeding species.
	! Then, after the last single-species l2gp, the very next pcf number
	! is for the one called 'other' ML2OTH.001.MCF
	! This hateful inflexibility leads to possibility
	
	!                          (2)
	! Each l2gp file name, stripped of their paths, fits the pattern
	!  *_l2gp_species_*
	! and the corresponding MCF files fit the pattern
	!  *SPECIES.*
	! where species and SPECIES are case-nsensitive "species" name
	! i.e., BrO, ClO, etc.
	! Warning:
	! You therefore must use exactly the same abbreviation for the l2gp and the
	! corresponding MCF: if the MCF is ML2T.001.MCF, don't use "temp"
	! in the l2gp name
	! This inflexibility replaces the different kind in option (1)
d104 2
a105 1
    integer, parameter :: MCFFORL2GPOPTION=1		! Either 1 or 2
d119 1
a119 1
    logical, parameter :: DEBUG = .TRUE.
d242 3
a244 1
						& (l2gpFileHandle, l2gp_mcf, l2pcf, QuantityNames(1), anText)
d261 2
a262 2
						& numquantitiesperfile, QuantityNames, anText)

d371 2
a372 2
						& numquantitiesperfile, QuantityNames, anText)

d406 2
a407 1
      CALL WriteMetaLog(l2pcf)
d421 5
d477 3
@


2.17
log
@Extra error checks
@
text
@d11 2
a12 2
  use Hdf, only: DFACC_CREATE, DFNT_FLOAT64, SFCREATE, SFDIMID, SFEND, &
    & SFENDACC, SFSTART, SFWDATA
d24 1
a24 1
	 & mlspcf_mcf_l2gp_start, mlspcf_mcf_l2dgm_start, mlspcf_mcf_l2log_start, &
d28 1
a28 1
  use SDPToolkit, only: Pgs_pc_getReference, PGS_S_SUCCESS, Pgs_smf_getMsg
d44 1
a44 1
    & "$Id: OutputAndClose.f90,v 2.16 2001/04/04 23:44:52 pwagner Exp $"
d101 7
a107 6
    interface
      integer function SFSDMNAME ( DIM_ID, DIM_NAME ) ! An HDF function
        integer, intent(in) :: DIM_ID
        character(len=*), intent(in) :: DIM_NAME
      end function SFSDMNAME
    end interface
a114 2
    integer :: FLAG
    logical :: FOUND
a116 2
    integer :: I
    integer :: IN_FIELD                 ! A son of an assign vertex
a135 1
    integer(i4) :: START(3), STRIDE(3), DIM_SIZES(3)
d203 1
a203 1
  & .TRUE., returnStatus, l2gp_Version, .true.)
d206 1
a206 1
					if(DEBUG) call output('file name: ' // TRIM(file_base), advance='yes')
d210 1
a210 1
                swfid = swopen(file_base, DFACC_CREATE)
d252 9
a260 1
					if(DEBUG) call output('preparing to populate metadata_std', advance='yes')
d262 1
a262 1
						& (swfid, l2gp_mcf, l2pcf, QuantityNames(1), anText)
d268 9
a276 1
					if(DEBUG) call output('preparing to populate metadata_oth', advance='yes')
d278 1
a278 1
						& (swfid, l2gp_mcf, l2pcf, &
d291 1
a291 1
                &  "Error finding l2gp file:  "//file_base, returnStatus)
d317 1
a317 1
  & .TRUE., returnStatus, l2aux_Version, .true.)
d321 1
a321 1
					if(DEBUG) call output('file name: ' // TRIM(file_base), advance='yes')
d368 1
a368 1
               	 &  "Error closing l2aux file:  "//file_base, returnStatus)
d378 9
a386 1
					if(DEBUG) call output('preparing to populate metadata_oth', advance='yes')
d388 1
a388 1
						& (swfid, l2aux_mcf, l2pcf, &
d401 1
a401 1
                &  "Error finding l2aux file:  "//file_base, returnStatus)
d418 1
a418 1
    if ( toggle(gen) ) call trace_end ( "Output_Close")
d420 3
a422 1
! Write the log file metadata
d428 4
d438 2
d468 7
d489 3
@


2.16
log
@Now deallocates anText of PCF file at last
@
text
@d44 1
a44 1
    & "$Id: OutputAndClose.f90,v 2.15 2001/04/03 23:51:28 pwagner Exp $"
d143 1
a151 2
    l2gp_Version = 1
    l2aux_Version = 1
d160 4
d191 1
a191 1

d207 1
a207 1
  & .TRUE., returnStatus, l2gp_Version)
d210 1
d213 1
d234 1
d256 1
d264 1
d289 2
a290 1
          ! Get the l2aux file name from the PCF
d305 1
a305 1
  & .TRUE., returnStatus, l2aux_Version)
d309 1
d311 1
d314 1
d321 2
d324 19
a342 3
                      CALL WriteL2AUXData(l2auxDatabase(db_index),sdfid)
							 numquantitiesperfile=numquantitiesperfile+1
			            call get_string ( sub_rosa(subtree(2,gson)), QuantityNames(numquantitiesperfile) )
d352 6
a357 4
                  call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                  call MLSMessage ( MLSMSG_Error, ModuleName, &
                    &  "Error closing l2aux file:  "//mnemonic//" "//msg )
                end if
d366 1
d454 3
@


2.15
log
@Many changes; some may be right
@
text
@d44 1
a44 1
    & "$Id: OutputAndClose.f90,v 2.14 2001/04/02 23:43:46 pwagner Exp $"
d371 7
d421 3
@


2.14
log
@Now makes metadata calls; it compiles, but does it bomb?
@
text
@d36 1
a36 1
  & populate_metadata_oth, WriteMetaLog
d44 1
a44 1
    & "$Id: OutputAndClose.f90,v 2.13 2001/03/28 00:23:20 pwagner Exp $"
d57 1
a57 1
  subroutine Output_Close ( root, l2gpDatabase, l2auxDatabase, l2pcf )
d62 9
d76 1
d78 12
a89 3
	!   for the l2aux the mcf is mlspcf_mcf_l2dgm_start
	!   for the log file the mcf is mlspcf_mcf_l2log_start
	!   for the dgg file the mcf is mlspcf_mcf_l2dgg_start
d96 2
d123 1
a123 1
    integer :: l2gp_mcf, l2gp_oth_mcf, l2aux_mcf, l2dgg_mcf  ! mcf numbers for writing metadata
d128 1
a156 1
	 l2gp_oth_mcf = l2gp_mcf+1	! We will always assume that 'OTH' comes last
d237 7
a243 1
					if(numquantitiesperfile <= 0) then
d251 1
a251 1
						& (swfid, l2gp_mcf, l2pcf, QuantityNames(1))
a252 1
						 l2gp_oth_mcf = l2gp_mcf+1	! We will always assume that 'OTH' comes last
d258 2
a259 2
						& (swfid, l2gp_oth_mcf, l2pcf, &
						& numquantitiesperfile, QuantityNames)
d336 1
a336 1
						& numquantitiesperfile, QuantityNames)
d414 3
@


2.13
log
@Made tiny changes to use announce_error
@
text
@d17 1
a17 1
  use L2GPData, only: L2GPData_T, WriteL2GPData
a21 2
!  use MLSPCF, only: MLSPCF_L2AUX_END, MLSPCF_L2AUX_START, MLSPCF_L2GP_END, &
!    & MLSPCF_L2GP_START
d23 3
a25 1
    & MLSPCF_L2GP_START
d35 2
d44 1
a44 1
    & "$Id: OutputAndClose.f90,v 2.12 2001/03/20 18:35:02 pwagner Exp $"
d57 14
a70 1
  subroutine Output_Close ( root, l2gpDatabase, l2auxDatabase )
d76 1
d102 1
d106 1
d110 1
d112 1
a112 1
    character(len=132) :: QuantityName  ! From "quantities" field
d132 4
a135 1
    
d192 1
d200 2
d214 22
d277 1
d285 2
d300 13
d341 5
d388 3
@


2.12
log
@Using GetPCFromRef to get file handles
@
text
@d42 1
a42 1
    & "$Id: OutputAndClose.f90,v 2.11 2001/03/15 21:18:57 vsnyder Exp $"
d194 5
a198 3
              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                &  "Error finding l2gp file:  "//mnemonic//" "//msg )
d255 5
a259 3
              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                &  "Error finding l2aux file:  "//mnemonic//" "//msg )
d291 1
a291 1
  subroutine ANNOUNCE_ERROR ( WHERE, CODE )
d293 2
a294 1
    integer, intent(in) :: CODE    ! Code for error message
d298 6
a303 1
    call print_source ( source_ref(where) )
d305 10
a314 2
    select case ( code )
    end select
d320 3
@


2.11
log
@Use Get_Spec_ID instead of decoration(subtree...
@
text
@d20 1
d42 1
a42 1
    & "$Id: OutputAndClose.f90,v 2.10 2001/03/06 22:40:24 livesey Exp $"
d148 16
a163 10
          l2gpFileHandle = mlspcf_l2gp_start
          found = .FALSE.
          do while ((.NOT. found) .AND. (l2gpFileHandle <=  mlspcf_l2gp_end))
            l2gp_Version=1
            returnStatus = Pgs_pc_getReference(l2gpFileHandle, l2gp_Version, &
              & l2gpPhysicalFilename)
            
            if ( returnStatus == PGS_S_SUCCESS ) then
              if ( INDEX(l2gpPhysicalFilename, TRIM(file_base)) /= 0 ) then
                found = .true.
d166 1
a166 1
                swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
d182 1
d189 4
a192 3
              else                ! Found the right file
                l2gpFileHandle = l2gpFileHandle + 1
              end if
d197 1
d200 3
a202 3
          end do !(.not. found) .and. (l2gpFileHandle <=  mlspcf_l2gp_end)
          IF (.NOT. found) CALL MLSMessage(MLSMSG_Error,ModuleName,&
            'Unable to find filename containing '//TRIM(file_base))
d208 6
a213 6
          l2auxFileHandle = mlspcf_l2dgm_start
          found = .FALSE.
          do while ((.NOT. found) .AND. (l2auxFileHandle <=  mlspcf_l2dgm_end))
            l2aux_Version=1
            returnStatus = Pgs_pc_getReference(l2auxFileHandle, l2aux_Version, &
              & l2auxPhysicalFilename)
d215 3
a217 3
            if ( returnStatus == PGS_S_SUCCESS ) then
              if ( INDEX(l2auxPhysicalFilename, TRIM(file_base)) /= 0 )then
                found = .TRUE.
d219 6
d248 4
a251 3
              else
                l2auxFileHandle =  l2auxFileHandle + 1
              end if
d258 2
a259 1
          end do ! (.not. found) .and. (l2auxFileHandle <=  mlspcf_l2aux_end)
d302 3
@


2.10
log
@Working l2aux
@
text
@d25 1
d41 1
a41 1
    & "$Id: OutputAndClose.f90,v 2.9 2001/02/23 18:15:48 livesey Exp $"
d126 1
a126 1
      select case( decoration(subtree(1,decoration(subtree(1,key)))) )
d284 3
@


2.9
log
@Added trace calls.
@
text
@d16 1
a16 1
  use L2AUXData, only: L2AUXDATA_T, L2AUXDIMNAMES
d40 1
a40 1
    & "$Id: OutputAndClose.f90,v 2.8 2001/02/13 22:59:36 pwagner Exp $"
d93 1
a93 1
    integer(i4) :: SD_ID, SDS_ID, DIM_ID
d154 29
a182 30
               if ( INDEX(l2gpPhysicalFilename, TRIM(file_base)) /= 0 ) then
                  found = .true.
                  ! Open the HDF-EOS file and write swath data

                  swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)

                  ! Loop over the segments of the l2cf line

                  do field_no = 2, nsons(key) ! Skip "output" name
                     gson = subtree(field_no,key)
                     select case ( decoration(subtree(1,gson)) )
                     case ( f_quantities )
                        do in_field_no = 2, nsons(gson)
                           db_index = -decoration(decoration(subtree(in_field_no ,gson)))
                           CALL WriteL2GPData(l2gpDatabase(db_index),swfid,swathName='Fred')
                        end do ! in_field_no = 2, nsons(gson)
                     case ( f_overlaps )
                        ! ??? More work needed here
                     end select
                  end do ! field_no = 2, nsons(key)
                  returnStatus = swclose(swfid)
                  if (returnStatus /= PGS_S_SUCCESS) then
                     call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                     call MLSMessage ( MLSMSG_Error, ModuleName, &
                          &  "Error closing  l2gp file:  "//mnemonic//" "//msg )
                  end if

               else                ! Found the right file
                  l2gpFileHandle = l2gpFileHandle + 1
               end if
d184 3
a186 3
               call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
               call MLSMessage ( MLSMSG_Error, ModuleName, &
                    &  "Error finding  l2gp file:  "//mnemonic//" "//msg )
d188 5
a192 5

        end do !(.not. found) .and. (l2gpFileHandle <=  mlspcf_l2gp_end)
        IF (.NOT. found) CALL MLSMessage(MLSMSG_Error,ModuleName,&
             'Unable to find filename containing '//TRIM(file_base))

d194 1
a194 1

d196 1
a196 1

a198 1
!          do while ((.NOT. found) .AND. (l2auxFileHandle <=  mlspcf_l2aux_end))
d200 1
a200 1
             l2aux_Version=1
d203 1
a203 1

d205 1
a205 1
              if ( INDEX(file_base, l2auxPhysicalFilename) /= 0 )then
d207 1
a207 1

d209 2
a210 5

                sd_id = sfstart(l2auxPhysicalFilename, DFACC_CREATE)

                ! Loop over the segments of the l2aux line

d212 1
a212 1
                  gson = subtree(field_no,key) ! An assign vertex
d215 3
a217 45
                    do in_field_no = 2, nsons(gson) ! Skip "quantities" name
                      in_field = subtree(in_field_no,gson)
                      db_index = -decoration(decoration(in_field_no))

                      ! Set up dimensions
                      dim_sizes(1:3) = &
                        & l2auxDatabase(db_index)%dimensions(1:3)%noValues
                      if ( l2auxDatabase(db_index)%noDimensionsUsed == 2 ) &
                        & dim_sizes(3)=1
                      ! Create data set
                      call get_string ( sub_rosa(in_field), quantityName )
                      sds_id = sfcreate(sd_id, quantityName, DFNT_FLOAT64, &
                        & l2auxDatabase(db_index)%noDimensionsUsed, dim_sizes)

                      ! Give names to the dimensions
                      do i = 1, l2auxDatabase(db_index)%noDimensionsUsed
                        dim_id = sfdimid(sds_id, i)
                        returnStatus = sfsdmname(dim_id, &
                          & L2AUXDimNames(l2auxDatabase(db_index)% &
                          & dimensions(i)%dimensionFamily))
                        if ( returnStatus /= PGS_S_SUCCESS ) then
                          call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                          call MLSMessage ( MLSMSG_Error, ModuleName, &
                            & "Error setting dimension name to SDS l2aux file:  "// &
                            & L2AUXDimNames(l2auxDatabase(db_index)%dimensions(i)% &
                            & dimensionFamily) //mnemonic//" "//msg )
                        end if
                      end do

                      ! Write out the SDS data
                      start=0
                      stride=1

                      returnStatus = sfwdata(sds_id, start, stride, dim_sizes, &
                        & l2auxDatabase(db_index)%values )
                      if ( returnStatus /= PGS_S_SUCCESS ) then
                        call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                        call MLSMessage ( MLSMSG_Error, ModuleName, &
                          & "Error writing SDS data to  l2aux file:  " // &
                          & mnemonic // " " // msg )
                      end if

                      ! Terminate access to the data set

                      returnStatus = sfendacc(sds_id)
d220 1
a220 1
                  ! ??? More work needed here
d223 3
a225 2

                returnStatus = sfend(sd_id)
a230 1

a234 1

d237 1
a237 1
                &  "Error finding  l2aux file:  "//mnemonic//" "//msg )
d239 1
a239 1

d283 3
@


2.8
log
@l2 modules can only use MLSPCF2
@
text
@d28 2
d40 1
a40 1
    & "$Id: OutputAndClose.f90,v 2.7 2001/02/09 19:30:16 vsnyder Exp $"
d104 2
d111 2
d301 2
d331 3
@


2.7
log
@Move checking for required and duplicate fields to init_tables_module
@
text
@d21 3
a23 1
  use MLSPCF, only: MLSPCF_L2AUX_END, MLSPCF_L2AUX_START, MLSPCF_L2GP_END, &
d38 1
a38 1
    & "$Id: OutputAndClose.f90,v 2.6 2001/02/09 00:38:22 livesey Exp $"
d192 1
a192 1
          l2auxFileHandle = mlspcf_l2aux_start
d194 2
a195 1
          do while ((.NOT. found) .AND. (l2auxFileHandle <=  mlspcf_l2aux_end))
d323 3
@


2.6
log
@Various updates
@
text
@d36 1
a36 1
    & "$Id: OutputAndClose.f90,v 2.5 2001/01/03 18:15:13 pwagner Exp $"
a44 1
    integer, parameter :: DUPLICATE_FIELD = 1
d122 9
a130 13
          if ( got(field_index) ) then
            call announce_error ( gson, duplicate_field )
          else
            got(field_index) = .true.
            select case ( field_index )   ! Field name
            case ( f_file )
              call get_string ( sub_rosa(subtree(2,gson)), file_base )
              file_base=file_base(2:LEN_TRIM(file_base)-1) ! Parser includes quotes
            case ( f_type )
              output_type = decoration(subtree(2,gson))
            case default                  ! Everything else processed later
            end select
          end if
d312 1
a312 1
    call output ( ': ' )
a313 4
    case ( duplicate_field )
      call output ( "The " )
      call dump_tree_node ( where, 0 )
      call output ( " field appears more than once.", advance='yes' )
d320 3
@


2.5
log
@Changed types of t1, t2 to real
@
text
@d17 1
a17 1
!  use L2GPData, only: L2GPData_T
a23 9

!These functions now in L2GPData
!  use OutputL2GP, only: OutputL2GP_createFile, OutputL2GP_writeData, &
!    & OutputL2GP_writeGEO

  use L2GPData, only: L2GPData_T, &
       & OutputL2GP_createFile, OutputL2GP_writeData, &
    & OutputL2GP_writeGEO

d36 1
a36 1
    & "$Id: OutputAndClose.f90,v 2.4 2000/11/16 02:25:13 vsnyder Exp $"
d130 1
d146 1
d149 1
a149 1

d151 30
a180 42
              if ( INDEX(file_base, l2gpPhysicalFilename) /= 0 ) then
                found = .true.

                ! Open the HDF-EOS file and write swath data

                swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)

                ! Loop over the segments of the l2cf line

                do field_no = 2, nsons(key) ! Skip "output" name
                  gson = subtree(field_no,key)
                  select case ( decoration(subtree(1,gson)) )
                  case ( f_quantities )
                    do in_field_no = 2, nsons(gson)
                      db_index = decoration(decoration(subtree(in_field_no ,gson)))

!Reordered parameters in following call to reflect recoded L2GPData
!and eliminated optional parameter flag which was of inconsistent
!type INTEGER when CHARACTER was expected, anyway
!                    call OutputL2GP_createFile ( swfid,l2gpDatabase(db_index), &
!                      & flag )

                      call OutputL2GP_createFile ( l2gpDatabase(db_index), &
                        & swfid)

                      call OutputL2GP_writeGEO ( l2gpDatabase(db_index), swfid )
                      call OutputL2GP_writeData ( l2gpDatabase(db_index), swfid )
                    end do ! in_field_no = 2, nsons(gson)
                  case ( f_overlaps )
                  ! ??? More work needed here
                  end select
                end do ! field_no = 2, nsons(key)
                returnStatus = swclose(swfid)
                if (returnStatus /= PGS_S_SUCCESS) then
                  call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                  call MLSMessage ( MLSMSG_Error, ModuleName, &
                    &  "Error closing  l2gp file:  "//mnemonic//" "//msg )
                end if

              else
                 l2gpFileHandle = l2gpFileHandle + 1
              end if
d182 3
a184 4

              call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                &  "Error finding  l2gp file:  "//mnemonic//" "//msg )
d187 3
a189 1
          end do !(.not. found) .and. (l2gpFileHandle <=  mlspcf_l2gp_end)
d198 1
d218 1
a218 1
                      db_index = decoration(decoration(in_field_no))
d329 3
@


2.4
log
@Implement timing.
@
text
@d45 1
a45 1
    & "$Id: OutputAndClose.f90,v 2.3 2000/10/05 16:43:00 pwagner Exp $"
d104 1
a104 1
    double precision :: T1, T2     ! for timing
d318 1
a318 1
      call output ( t2 - t1, advance = 'yes' )
d346 3
@


2.3
log
@Now compiles with new L2GPData module
@
text
@d15 1
a15 1
    & FIELD_FIRST, FIELD_LAST, L_L2AUX, L_L2GP
d45 1
a45 1
    & "$Id: OutputAndClose.f90,v 2.2 2000/09/11 19:43:47 ahanzel Exp $"
d104 3
a106 1
 
d108 1
d127 18
a144 16
      do field_no = 2, nsons(key)       ! Skip the command name
        gson = subtree(field_no, key)   ! An assign node
        field_index = decoration(subtree(1,gson))
        if ( got(field_index) ) then
          call announce_error ( gson, duplicate_field )
        else
          got(field_index) = .true.
          select case ( field_index )   ! Field name
          case ( f_file )
            call get_string ( sub_rosa(subtree(2,gson)), file_base )
          case ( f_type )
            output_type = decoration(subtree(2,gson))
          case default                  ! Everything else processed later
          end select
        end if
      end do
d146 2
a147 2
      select case ( output_type )
      case ( l_l2gp )
d149 1
a149 1
        ! Get the l2gp file name from the PCF
d151 5
a155 5
        l2gpFileHandle = mlspcf_l2gp_start
        found = .FALSE.
        do while ((.NOT. found) .AND. (l2gpFileHandle <=  mlspcf_l2gp_end))
          returnStatus = Pgs_pc_getReference(l2gpFileHandle, l2gp_Version, &
            & l2gpPhysicalFilename)
d157 3
a159 3
          if ( returnStatus == PGS_S_SUCCESS ) then
            if ( INDEX(file_base, l2gpPhysicalFilename) /= 0 ) then
              found = .true.
d161 1
a161 1
              ! Open the HDF-EOS file and write swath data
d163 1
a163 1
              swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
d165 1
a165 1
              ! Loop over the segments of the l2cf line
d167 6
a172 6
              do field_no = 2, nsons(key) ! Skip "output" name
                gson = subtree(field_no,key)
                select case ( decoration(subtree(1,gson)) )
                case ( f_quantities )
                  do in_field_no = 2, nsons(gson)
                    db_index = decoration(decoration(subtree(in_field_no ,gson)))
d180 2
a181 2
                    call OutputL2GP_createFile ( l2gpDatabase(db_index), &
                      & swfid)
d183 16
a198 12
                    call OutputL2GP_writeGEO ( l2gpDatabase(db_index), swfid )
                    call OutputL2GP_writeData ( l2gpDatabase(db_index), swfid )
                  end do ! in_field_no = 2, nsons(gson)
                case ( f_overlaps )
                ! ??? More work needed here
                end select
              end do ! field_no = 2, nsons(key)
              returnStatus = swclose(swfid)
              if (returnStatus /= PGS_S_SUCCESS) then
                call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                call MLSMessage ( MLSMSG_Error, ModuleName, &
                  &  "Error closing  l2gp file:  "//mnemonic//" "//msg )
d200 1
d202 3
a204 2
            else
               l2gpFileHandle = l2gpFileHandle + 1
a205 1
          else
d207 1
a207 4
            call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              &  "Error finding  l2gp file:  "//mnemonic//" "//msg )
          end if
d209 1
a209 1
        end do !(.not. found) .and. (l2gpFileHandle <=  mlspcf_l2gp_end)
d211 1
a211 1
      case ( l_l2aux )
d213 52
a264 1
        ! Get the l2aux file name from the PCF
d266 2
a267 40
        l2auxFileHandle = mlspcf_l2aux_start
        found = .FALSE.
        do while ((.NOT. found) .AND. (l2auxFileHandle <=  mlspcf_l2aux_end))
          returnStatus = Pgs_pc_getReference(l2auxFileHandle, l2aux_Version, &
            & l2auxPhysicalFilename)

          if ( returnStatus == PGS_S_SUCCESS ) then
            if ( INDEX(file_base, l2auxPhysicalFilename) /= 0 )then
              found = .TRUE.

              ! Create the HDF file and initialize the SD interface

              sd_id = sfstart(l2auxPhysicalFilename, DFACC_CREATE)

              ! Loop over the segments of the l2aux line

              do field_no = 2, nsons(key) ! Skip "output" name
                gson = subtree(field_no,key) ! An assign vertex
                select case ( decoration(subtree(1,gson)) )
                case ( f_quantities )
                  do in_field_no = 2, nsons(gson) ! Skip "quantities" name
                    in_field = subtree(in_field_no,gson)
                    db_index = decoration(decoration(in_field_no))

                    ! Set up dimensions
                    dim_sizes(1:3) = &
                      & l2auxDatabase(db_index)%dimensions(1:3)%noValues
                    if ( l2auxDatabase(db_index)%noDimensionsUsed == 2 ) &
                      & dim_sizes(3)=1
                    ! Create data set
                    call get_string ( sub_rosa(in_field), quantityName )
                    sds_id = sfcreate(sd_id, quantityName, DFNT_FLOAT64, &
                      & l2auxDatabase(db_index)%noDimensionsUsed, dim_sizes)

                    ! Give names to the dimensions
                    do i = 1, l2auxDatabase(db_index)%noDimensionsUsed
                      dim_id = sfdimid(sds_id, i)
                      returnStatus = sfsdmname(dim_id, &
                        & L2AUXDimNames(l2auxDatabase(db_index)% &
                        & dimensions(i)%dimensionFamily))
d271 2
a272 3
                          & "Error setting dimension name to SDS l2aux file:  "// &
                          & L2AUXDimNames(l2auxDatabase(db_index)%dimensions(i)% &
                          & dimensionFamily) //mnemonic//" "//msg )
a273 1
                    end do
d275 18
a292 27
                    ! Write out the SDS data
                    start=0
                    stride=1

                    returnStatus = sfwdata(sds_id, start, stride, dim_sizes, &
                      & l2auxDatabase(db_index)%values )
                    if ( returnStatus /= PGS_S_SUCCESS ) then
                      call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                      call MLSMessage ( MLSMSG_Error, ModuleName, &
                        & "Error writing SDS data to  l2aux file:  " // &
                        & mnemonic // " " // msg )
                    end if

                    ! Terminate access to the data set

                    returnStatus = sfendacc(sds_id)
                  end do ! in_field_no = 2, nsons(gson)
                case ( f_overlaps )
                ! ??? More work needed here
                end select
              end do ! field_no = 2, nsons(key)

              returnStatus = sfend(sd_id)
              if ( returnStatus /= PGS_S_SUCCESS ) then
                call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
                call MLSMessage ( MLSMSG_Error, ModuleName, &
                  &  "Error closing l2aux file:  "//mnemonic//" "//msg )
d294 1
d296 3
a298 2
            else
              l2auxFileHandle =  l2auxFileHandle + 1
a299 1
          else
d301 9
a309 6
            call Pgs_smf_getMsg ( returnStatus, mnemonic, msg )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              &  "Error finding  l2aux file:  "//mnemonic//" "//msg )
          end if

        end do ! (.not. found) .and. (l2auxFileHandle <=  mlspcf_l2aux_end)
d312 9
d346 3
@


2.2
log
@Removed old log entries.
@
text
@d17 1
a17 1
  use L2GPData, only: L2GPData_T
d24 7
a30 1
  use OutputL2GP, only: OutputL2GP_createFile, OutputL2GP_writeData, &
d32 1
d45 1
a45 1
    & "$Id: OutputAndClose.f90,v 2.1 2000/09/08 22:55:56 vsnyder Exp $"
d168 10
a177 2
                    call OutputL2GP_createFile ( swfid,l2gpDatabase(db_index), &
                      & flag )
d324 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@d6 2
a7 1
MODULE OutputAndClose !outputs all data from the Join module to the appropriate L2 Files
d10 87
a96 46
USE MLSCommon
USE MLSStrings 
USE MLSMessageModule
USE L2GPData
USE L2AUXData
USE SDPToolkit
USE MLSPCF
USE MLSCF 
USE Hdf 
USE HDFEOS 
USE OutputL2GP
USE WriteMetadata

IMPLICIT NONE

PUBLIC

PRIVATE :: Id, ModuleName
!------------------------------- RCS Ident Info ------------------------------
CHARACTER(LEN=130) :: id = & 
   "$Id: OutputAndClose.f90,v 2.0 2000/09/05 18:57:03 ahanzel Exp $"
CHARACTER(LEN=*), PARAMETER :: ModuleName="$RCSfile: OutputAndClose.f90,v $"
!-----------------------------------------------------------------------------

!Parameters


CONTAINS

!============================================================
  SUBROUTINE Ouput_Close(l2cf, l2gpDatabase, l2auxDatabase)
!============================================================


! Arguments
  TYPE (MLSCF_T) :: l2cf        ! The information from the l2cf file
  TYPE (L2GPData_T), DIMENSION(:), POINTER :: l2gpDatabase ! L2GP products
  TYPE (L2AUXData_T), DIMENSION(:), POINTER :: l2auxDatabase ! L2AUX products

! - - - local declarations - - -

  INTEGER*4 sd_id, sds_id, dim_id
  INTEGER*4 sds_index
  INTEGER*4 start(3), edges(3), stride(3), dim_sizes(3)
  INTEGER i,j,k
  INTEGER file_id, gd_id
d98 1
a98 227
  INTEGER :: returnStatus
  INTEGER :: l2auxFileHandle, l2aux_Version
  CHARACTER (LEN=132) :: l2auxPhysicalFilename
  INTEGER :: l2gpFileHandle, l2gp_Version, swfid, swid
  CHARACTER (LEN=132) :: l2gpPhysicalFilename
  CHARACTER (LEN=132) :: MCFPhysicalFilename
  CHARACTER (LEN=32) :: mnemonic, name
  CHARACTER (LEN=132) :: msg
  INTEGER :: MCFFileHandle, MCF_Version
  TYPE (MLSCFSection_T) :: l2cfSection
  TYPE (MLSCFCell_T) :: cell
  INTEGER :: l2cfLine, l2cfCellIndex, db_index, flag, ncnb
  LOGICAL :: found, MCFfound, caseInsensitive

  INTEGER :: sfn2index, sfselect, sfwdata

! Executable code
l2cfSection=GetMLSCFSection(l2cf,'Output')

!Loop over the lines in the l2cf

DO l2cfLine=1,l2cfSection%noSectionEntries
   l2gp_Version = 1
   l2aux_Version = 1 
   name=TRIM(l2cfSection%entries(l2cfLine)%mlscfEntryName)
   IF (name(1:4) == 'l2gp')THEN

      ! Get the l2gp file name from PCF

      l2gpFileHandle = mlspcf_l2gp_start
      found = .FALSE.
      DO WHILE ((.NOT. found) .AND. (l2gpFileHandle <=  mlspcf_l2gp_end))
         l2gp_Version = 1
         returnStatus = Pgs_pc_getReference(l2gpFileHandle, l2gp_Version, l2gpPhysicalFilename)
         IF(returnStatus == PGS_S_SUCCESS) THEN
            MCFFileHandle = mlspcf_MCF_start
            name = l2cfSection%entries(l2cfLine)%cells(1)%CharValue

            IF(INDEX(Capitalize(l2gpPhysicalFilename), &
                     Capitalize(name(1:LEN_TRIM(name)))) /= 0)THEN
               found = .TRUE.
               ! Get the MCF file name from PCF
               MCFfound = .false.
               DO WHILE ((.NOT. MCFfound) .AND. (MCFFileHandle <=  mlspcf_MCF_end))
                  MCF_Version = 1
                  returnStatus = Pgs_pc_getReference(MCFFileHandle, MCF_Version, &
                       MCFPhysicalFilename)
                  IF(INDEX(Capitalize(MCFPhysicalFilename), &
                       Capitalize(name(1:LEN_TRIM(name)))) /= 0)THEN
                     MCFfound = .TRUE.
                  ELSE
                     MCFFileHandle = MCFFileHandle + 1
                  END IF
               END DO
               IF (.not. MCFfound) THEN  

                  CALL MLSMessage (MLSMSG_Error, ModuleName, &
                       "Error finding  MCF file: "//name)               
               END IF

               swfid = swopen(l2gpPhysicalFilename, DFACC_CREATE)
               ! Open the HDF-EOS file and write swath data
               ! Loop over the segments of the l2cf line
               IF(swfid == -1)THEN
                  CALL MLSMessage (MLSMSG_Error, ModuleName, &
                       'Error opening l2gp file:  '//l2gpPhysicalFilename)

               ELSE
                  CALL MLSMessage(MLSMSG_Info, ModuleName,'L2GP file opened successfully: '&
                                  //l2gpPhysicalFilename)
               END IF
               DO l2cfCellIndex=1,l2cfSection%entries(l2cfLine)%mlscfEntryNoKeys
                  
                  cell=l2cfSection%entries(l2cfLine)%cells(l2cfCellIndex)
                  IF(INDEX(cell%keyword, 'SPECIES') == 1)THEN
                  
                     db_index=LinearSearchStringArray(l2gpDatabase%name,&
                          TRIM(cell%charValue), caseInsensitive=.TRUE.)
                     IF (db_index==0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
                          "Inconsistent l2gp naming :"//cell%charValue)
                     CALL OutputL2GP_createFile (swfid,l2gpDatabase(db_index) , flag)
                     CALL OutputL2GP_writeGEO (l2gpDatabase(db_index),swfid)
                     CALL OutputL2GP_writeData (l2gpDatabase(db_index),swfid)

                     returnStatus = swclose(swfid)
                     IF(returnStatus /= PGS_S_SUCCESS) THEN
                        CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
                        CALL MLSMessage (MLSMSG_Error, ModuleName, &
                             "Error closing  l2gp file:  "//mnemonic//" "//msg)
                     ELSE
                        CALL MLSMessage(MLSMSG_Info, ModuleName,&
                             'L2GP file written and closed successfully: '&
                                  //l2gpPhysicalFilename)

                     END IF
                  END IF

               END DO !l2cfCellIndex=1,l2cfSection%entries(l2cfLine)%mlscfEntryNoKeys
  
               CALL populate_metadata(l2gpFileHandle, MCFFileHandle)
               
               CALL MLSMessage(MLSMSG_Info, ModuleName,&
                             'Metadata written successfully for: '&
                              //l2gpPhysicalFilename)
            ELSE
               l2gpFileHandle =  l2gpFileHandle + 1
            END IF
         ELSE

            CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
            CALL MLSMessage (MLSMSG_Error, ModuleName, &
                 "Error finding  l2gp file:  "//mnemonic//" "//msg)
         END IF

      END DO !(.not. found) .and. (l2gpFileHandle <=  mlspcf_l2gp_end)
      IF (.not. found) THEN
         CALL MLSMessage (MLSMSG_Error, ModuleName, &
                          "Error finding  l2gp file: "//name)
      END IF

   ELSE  IF (name(1:5) == 'l2aux')THEN
      ! Get the l2aux file name from the PCF

      l2auxFileHandle = mlspcf_l2aux_start
      found = .FALSE.
      DO WHILE ((.NOT. found) .AND. (l2auxFileHandle <=  mlspcf_l2aux_end))
         l2aux_Version = 1
         returnStatus = Pgs_pc_getReference(l2auxFileHandle, l2aux_Version, l2auxPhysicalFilename)
         IF(returnStatus == PGS_S_SUCCESS) THEN
            name = l2cfSection%entries(l2cfLine)%cells(1)%CharValue
            IF(INDEX(l2auxPhysicalFilename, name(1:LEN_TRIM(name))) /= 0)THEN
               found = .TRUE.
               ! Create the HDF file and initialize the SD interface

               sd_id = sfstart(l2auxPhysicalFilename, DFACC_CREATE)

               ! Loop over the segments of the l2cf line

               DO l2cfCellIndex=1, l2cfSection%entries(l2cfLine)%mlscfEntryNoKeys
                  cell=l2cfSection%entries(l2cfLine)%cells(l2cfCellIndex)
                  IF(INDEX(cell%keyword, 'SPECIES') == 1)THEN
                     
                     db_index=LinearSearchStringArray(l2auxDatabase%name, cell%charValue,&
                          & caseInsensitive=.TRUE.)

                     IF (db_index==0) CALL MLSMessage(MLSMSG_Error,ModuleName, &
                          "Inconsistent l2aux naming :"//cell%charValue)

                     !set up dimensions
                     DO i = 1,3
                        dim_sizes(i)=l2auxDatabase(db_index)%dimensions(i)%noValues 
                     END DO

                     IF (l2auxDatabase(db_index)%noDimensionsUsed == 2)dim_sizes(3)=0
                     ! Create  data set

                     !                  dim_sizes(2) = SD_UNLIMITED
                     sds_id = sfcreate(sd_id, cell%charValue , DFNT_FLOAT64, &
                          l2auxDatabase(db_index)%noDimensionsUsed,dim_sizes(1:2))

                     ! Give names to the dimensions

                     DO i = 1, l2auxDatabase(db_index)%noDimensionsUsed 
                        dim_id = sfdimid(sds_id, i-1)
                        returnStatus = sfsdmname(dim_id, &
                             L2AUXDimNames(l2auxDatabase(db_index)%dimensions(i)%dimensionFamily))
                        IF(returnStatus /= PGS_S_SUCCESS) THEN
                           CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
                           CALL MLSMessage (MLSMSG_Error, ModuleName, &
                                "Error setting dimension name to SDS l2aux file:  "// &
                                L2AUXDimNames(l2auxDatabase(db_index)%dimensions(i)%dimensionFamily) &
                                //mnemonic//" "//msg)
                        END IF
                     END DO
                     returnStatus = sfendacc(sds_id) 
                     ! Write out the SDS data

                     stride = 1
                     start(1) = 0
                     start(2) = 0 !l2auxDatabase(db_index)%dimensions(2)%noValues -1
                     edges(1) = l2auxDatabase(db_index)%dimensions(1)%noValues 
                     edges(2) = l2auxDatabase(db_index)%dimensions(2)%noValues

                     sds_index = sfn2index(sd_id, cell%charValue)
                     sds_id = sfselect(sd_id, sds_index)
                     returnStatus = sfwdata(sds_id, start(1:2), stride(1:2),&
                          edges(1:2), l2auxDatabase(db_index)%values)
                     IF(returnStatus /= PGS_S_SUCCESS) THEN
                        CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
                        CALL MLSMessage (MLSMSG_Error, ModuleName, &
                             "Error writing SDS data to  l2aux file:  "//mnemonic//" "//msg)
                     END IF

                     ! Terminate access to the data set

                     returnStatus = sfendacc(sds_id)
                   
                  END IF ! keyword = "species"

               END DO !l2cfCellIndex=1,l2cfSection%entries(l2cfLine)%mlscfEntryNoKeys

               
               returnStatus = sfend(sd_id)
               IF(returnStatus /= PGS_S_SUCCESS) THEN
                  CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
                  CALL MLSMessage (MLSMSG_Error, ModuleName, &
                       "Error closing  l2aux file:  "//mnemonic//" "//msg)
               END IF

            ELSE
               l2auxFileHandle =  l2auxFileHandle + 1
            END IF
         ELSE

            CALL Pgs_smf_getMsg(returnStatus, mnemonic, msg)
            CALL MLSMessage (MLSMSG_Error, ModuleName, &
                 "Error finding  l2aux file:  "//mnemonic//" "//msg)
         END IF

      END DO !(.not. found) .and. (l2auxFileHandle <=  mlspcf_l2aux_end)
      IF (.not. found) THEN
         CALL MLSMessage (MLSMSG_Error, ModuleName, &
                          "Error finding  l2aux file: "//name)               
      END IF
   END IF
END DO  !l2cfLine=1,l2cfSection%noSectionEntries
END SUBROUTINE Ouput_Close
d100 205
d306 1
a306 1
END MODULE OutputAndClose
d309 2
a310 2
! Revision 2.0  2000/09/05 18:57:03  ahanzel
! Changing file revision to 2.0.
d312 2
a313 2
! Revision 1.7  2000/07/31 18:38:14  lungu
! Logged opening and writing of output files.
@


1.6
log
@Changed PGSd_MET_MCF_FILE to MCFFileHandle
in call to populate_metadata.
@
text
@d29 1
a29 1
   "$Id: OutputAndClose.f90,v 1.6 2000/06/29 23:58:42 lungu Exp $"
d119 3
d123 4
d145 5
d156 4
d288 2
a289 3
! Revision 1.6  2000/06/29 23:58:42  lungu
! Changed PGSd_MET_MCF_FILE to MCFFileHandle
! in call to populate_metadata.
d291 2
a292 14
! Revision 1.5  2000/06/27 23:46:35  lungu
! Added code for multiple MCFs.
!
! Revision 1.4  2000/06/19 22:23:16  lungu
! Added code to handle metadata.
!
! Revision 1.3  2000/01/21 01:48:37  lungu
! Fixed minor typos.
!
! Revision 1.2  2000/01/20 01:38:16  lungu
! Added L2aux files.
!
! Revision 1.1  2000/01/19 02:04:36  lungu
! Initial release.
d294 1
@


