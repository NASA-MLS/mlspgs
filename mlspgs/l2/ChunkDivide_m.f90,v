head	2.140;
access;
symbols
	v5-02-NRT-19:2.140
	v6-00:2.138
	v5-02-NRT-18:2.138
	v5-02:2.135
	v5-01-NRT-17:2.138
	v5-01-NRT-16:2.138
	v5-01-NRT-15:2.138
	v5-01-NRT-14:2.138
	neuralnetworks-1-0:2.138.0.4
	cfm-single-freq-0-1:2.138.0.2
	v5-01:2.135
	v5-00:2.135
	v4-23-TA133:2.135.0.2
	mus-emls-1-70:2.133.0.2
	rel-1-0-englocks-work:2.129.0.2
	VUMLS1-00:2.122
	VPL1-00:2.119
	V4-22-NRT-08:2.119
	VAM1-00:2.118
	V4-21:2.116.0.2
	V4-13:2.115
	V4-12:2.113
	V4-11:2.113
	V4-10:2.113
	V3-43:2.91
	M4-00:2.100
	V3-41:2.91
	V3-40-PlusGM57:2.91.0.2
	V2-24-NRT-04:2.85
	V3-33:2.95
	V2-24:2.85
	V3-31:2.95
	V3-30-NRT-05:2.94
	cfm-01-00:2.94
	V3-30:2.91
	V3-20:2.91
	V3-10:2.91
	V2-23-NRT-02:2.85
	V2-23:2.85
	V2-22-NRT-01:2.85
	V2-22:2.85
	V2-21:2.79
	V2-20:2.76
	V2-11:2.76
	V2-10:2.76
	V2-00:2.75
	V1-51:2.57
	V1-50:2.57
	V1-45:2.54
	V1-44:2.53
	V1-43:2.45
	V1-32:2.45
	V1-31:2.45
	V1-30:2.45
	V1-13:2.29
	V1-12:2.29
	V1-11:2.29
	V1-10:2.29
	newfwm-feb03:2.29.0.2
	V1-04:2.18
	V1-03:2.18
	V1-02:2.18
	JointForwardModel:2.20.0.2
	V1-00:2.18;
locks; strict;
comment	@# @;


2.140
date	2024.08.14.22.53.08;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2024.08.08.20.42.22;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2020.07.22.22.50.04;	author pwagner;	state Exp;
branches;
next	2.137;

2.137
date	2020.07.09.23.52.25;	author pwagner;	state Exp;
branches;
next	2.136;

2.136
date	2019.10.16.20.57.37;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2018.10.05.20.42.21;	author pwagner;	state Exp;
branches;
next	2.134;

2.134
date	2018.08.03.23.43.42;	author vsnyder;	state Exp;
branches;
next	2.133;

2.133
date	2018.06.26.00.12.32;	author pwagner;	state Exp;
branches;
next	2.132;

2.132
date	2018.06.22.23.22.08;	author pwagner;	state Exp;
branches;
next	2.131;

2.131
date	2018.05.14.23.23.58;	author vsnyder;	state Exp;
branches;
next	2.130;

2.130
date	2018.04.19.01.14.16;	author vsnyder;	state Exp;
branches;
next	2.129;

2.129
date	2018.03.05.19.51.56;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2018.02.23.22.14.26;	author mmadatya;	state Exp;
branches;
next	2.127;

2.127
date	2018.02.09.00.58.27;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2018.01.03.01.15.22;	author pwagner;	state Exp;
branches;
next	2.125;

2.125
date	2017.09.15.22.15.39;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2017.09.14.23.19.36;	author pwagner;	state Exp;
branches;
next	2.123;

2.123
date	2017.09.14.18.36.13;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2017.03.06.19.55.48;	author pwagner;	state Exp;
branches;
next	2.121;

2.121
date	2017.02.15.00.48.26;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2017.02.10.21.57.47;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2015.10.03.00.31.01;	author pwagner;	state Exp;
branches;
next	2.118;

2.118
date	2015.06.24.18.01.56;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2015.03.28.02.19.01;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2015.02.27.23.18.47;	author pwagner;	state Exp;
branches;
next	2.115;

2.115
date	2014.09.05.00.36.15;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2014.08.07.22.47.12;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2014.03.07.19.20.05;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2014.03.01.03.10.56;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2014.01.09.00.30.24;	author pwagner;	state Exp;
branches;
next	2.109;

2.109
date	2013.12.12.02.11.26;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2013.10.09.23.40.34;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2013.09.21.00.39.43;	author vsnyder;	state Exp;
branches;
next	2.105;

2.105
date	2013.08.30.02.45.34;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2013.08.12.23.49.41;	author pwagner;	state Exp;
branches;
next	2.103;

2.103
date	2013.06.28.19.02.58;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2013.06.21.17.37.38;	author pwagner;	state Exp;
branches;
next	2.101;

2.101
date	2013.06.20.17.56.16;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2013.05.21.22.50.24;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2012.06.21.00.41.08;	author pwagner;	state Exp;
branches;
next	2.98;

2.98
date	2012.03.14.16.56.26;	author pwagner;	state Exp;
branches;
next	2.97;

2.97
date	2011.11.30.21.33.13;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2011.06.29.21.50.20;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2011.02.05.01.41.44;	author pwagner;	state Exp;
branches;
next	2.94;

2.94
date	2010.04.20.17.32.23;	author honghanh;	state Exp;
branches;
next	2.93;

2.93
date	2010.03.25.20.16.06;	author honghanh;	state Exp;
branches;
next	2.92;

2.92
date	2010.03.23.23.53.08;	author honghanh;	state Exp;
branches;
next	2.91;

2.91
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2009.06.16.17.42.59;	author pwagner;	state Exp;
branches;
next	2.89;

2.89
date	2009.04.02.18.09.26;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2009.04.01.23.34.26;	author pwagner;	state Exp;
branches;
next	2.87;

2.87
date	2008.07.12.00.12.07;	author pwagner;	state Exp;
branches;
next	2.86;

2.86
date	2008.05.28.21.51.43;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2007.12.14.01.55.28;	author pwagner;	state Exp;
branches;
next	2.84;

2.84
date	2007.11.01.23.30.48;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2007.10.24.00.14.58;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2007.09.06.22.31.50;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2007.06.08.22.00.23;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2007.03.23.00.16.57;	author pwagner;	state Exp;
branches;
next	2.79;

2.79
date	2007.02.09.01.10.00;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2007.02.06.23.13.40;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2007.01.25.19.04.59;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2006.06.20.00.12.30;	author pwagner;	state Exp;
branches;
next	2.75;

2.75
date	2006.05.09.23.41.41;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2006.04.20.23.22.54;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2006.04.10.23.45.18;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2006.04.03.20.26.08;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2006.03.17.21.57.43;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2006.03.17.00.06.31;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2006.02.10.21.19.24;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2006.02.07.00.55.47;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2006.01.26.00.34.50;	author pwagner;	state Exp;
branches;
next	2.66;

2.66
date	2005.12.16.00.06.51;	author pwagner;	state Exp;
branches;
next	2.65;

2.65
date	2005.10.22.00.43.43;	author pwagner;	state Exp;
branches;
next	2.64;

2.64
date	2005.09.21.23.25.42;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2005.09.14.00.10.37;	author pwagner;	state Exp;
branches;
next	2.62;

2.62
date	2005.08.09.00.02.09;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2005.06.03.02.02.17;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2005.06.01.17.39.26;	author pwagner;	state Exp;
branches;
next	2.59;

2.59
date	2005.05.31.17.51.16;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2005.05.27.19.53.43;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2004.12.14.21.43.33;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2004.11.03.17.19.09;	author livesey;	state Exp;
branches;
next	2.55;

2.55
date	2004.10.05.23.09.54;	author pwagner;	state Exp;
branches;
next	2.54;

2.54
date	2004.08.23.22.00.39;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2004.08.16.17.10.04;	author pwagner;	state Exp;
branches;
next	2.52;

2.52
date	2004.08.09.21.43.10;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2004.08.04.23.19.57;	author pwagner;	state Exp;
branches;
next	2.50;

2.50
date	2004.08.02.23.40.29;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2004.07.31.19.58.28;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2004.07.30.00.25.49;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2004.06.10.00.58.44;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2004.05.19.19.16.09;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2003.08.27.20.08.04;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2003.08.26.19.49.22;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2003.08.26.19.43.42;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2003.08.26.18.05.14;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2003.08.25.23.43.08;	author pwagner;	state Exp;
branches;
next	2.40;

2.40
date	2003.08.21.22.51.18;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2003.08.21.22.49.22;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2003.08.15.23.58.20;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2003.06.20.19.38.25;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2003.06.09.22.55.23;	author pwagner;	state Exp;
branches;
next	2.35;

2.35
date	2003.06.05.23.37.14;	author pwagner;	state Exp;
branches;
next	2.34;

2.34
date	2003.05.17.00.06.06;	author pwagner;	state Exp;
branches;
next	2.33;

2.33
date	2003.05.09.16.43.05;	author pwagner;	state Exp;
branches;
next	2.32;

2.32
date	2003.05.07.23.43.05;	author pwagner;	state Exp;
branches;
next	2.31;

2.31
date	2003.04.30.22.06.04;	author pwagner;	state Exp;
branches;
next	2.30;

2.30
date	2003.04.28.23.07.00;	author pwagner;	state Exp;
branches;
next	2.29;

2.29
date	2003.01.06.20.13.09;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2002.12.11.22.17.05;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2002.12.06.01.08.33;	author pwagner;	state Exp;
branches;
next	2.26;

2.26
date	2002.11.13.01.03.11;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2002.11.06.00.21.16;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2002.10.07.23.49.49;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2002.10.07.18.00.10;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2002.08.22.01.23.52;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2002.08.04.15.59.45;	author mjf;	state Exp;
branches;
next	2.20;

2.20
date	2002.05.24.20.57.34;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2002.05.24.16.47.30;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2001.12.17.23.09.18;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.12.16.00.56.43;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2001.11.20.00.10.29;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2001.11.19.23.53.50;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.11.19.23.33.45;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.11.16.20.38.42;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.11.15.17.43.46;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.11.14.22.33.40;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.11.14.01.49.12;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.11.12.21.15.34;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.11.12.20.31.23;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.11.10.01.09.41;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.11.10.01.01.03;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.11.10.00.56.24;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.11.10.00.03.44;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.11.09.23.17.22;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2001.11.09.06.34.39;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.11.09.06.08.04;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.140
log
@Worked on fixing bug that broke nightly goldbrick
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module ChunkDivide_m

  ! This module replaces the old ScanDivide, and is a new approach to dividing
  ! the data into chunks.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use ChunkDivideConfig_M, only: ChunkDivideConfig_T, ChunkDivideConfig, Dump, &
    & Dump_CriticalSignals
  use Chunks_M, only: MLSChunk_T, Dump
  use Dump_0, only: Dump
  use HighOutput, only: OutputnamedValue
  use Init_Tables_Module, only: F_Crashifphinotmono, &
    & F_Criticalbands, F_Criticalmodules, F_Criticalsignals, &
    & F_Excludepostoverlaps, F_Excludeprioroverlaps, &
    & F_Homemodule, F_Homegeodangle, &
    & F_Maxlength, F_Maxorby, F_Method, F_Module, F_Nochunks, F_Noslaves, &
    & F_Overlap, F_Loweroverlap, &
    & F_Saveobstructions, F_Scanlowerlimit, F_Scanupperlimit, &
    & F_SkipL1Bcheck, F_Upperoverlap, &
    & Field_First, Field_Last, L_Both, L_Either, L_Even, &
    & L_Fixed, L_Polygon, F_Maxgap, L_Orbital, L_Pe, S_Chunkdivide, S_Dump
  use Intrinsic, only: L_None, Field_Indices, Lit_Indices, Phyq_Angle, &
    & Phyq_Dimensionless, Phyq_Length, Phyq_Mafs, Phyq_Time
  use L1bData, only: L1bData_T, Namelen, Precisionsuffix, &
    & AssembleL1Bqtyname, Dump, DeallocateL1BData, GetL1BFile, ReadL1BData
  use MLSCommon, only: MLSFile_T, Range_T, Tai93_Range_T, InRange
  use MLSFinds, only: FindFirst, FindLast, FindLongestRange
  use MLSFiles, only: Dump, GetMLSFilebytype, MLS_OpenFile
  use MLSKinds, only: R8, Rp
  use MLSMessageModule, only: MLSMessage, MLSMsg_Error, MLSMsg_Warning
  use MLSNumerics, only: Hunt
  use MLSFinds, only: FindFirst
  use MLSSignals_M, only: Dump, Modules, GetModuleName
  use MLSStringlists, only: SwitchDetail
  use Output_M, only: Blanks, Output, &
    & RevertOutput, SwitchOutput
  use PCFHdr, only: GlobalAttributes
  use String_Table, only: Get_String, Display_String
  use Toggles, only: Gen, Levels, Switches, Toggle
  use Polygon_M, only: Polygon_Inside, Polygon_Vertices

  implicit none
  private

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -
! any_good_signaldata      Return TRUE if and only if any good data in signal
! ChunkDivide              Divide MAFs in processing range among chunks
! DestroyChunkDatabase     Deallocate memory taken by chunk database
! ReduceChunkDatabase      Reduce chunk database to [first, last] chunks
! === (end of toc) ===
! === (start of api) ===
! log any_good_signaldata ( int signal, int sideband,
!  *MLSFile_T filedatabase(:), [int maf], [int maf2], &
!    & [log good_buffer(:)], [int mafRange(2)] )
! ChunkDivide (int root, TAI93_Range_T processingRange,
!    *MLSFile_T filedatabase(:), *mlSChunk_T Chunks(:) )
! DestroyChunkDatabase (*mlSChunk_T Chunks(:) )
! === (end of api) ===
  public :: CHUNKDIVIDE, CFM_CHUNKDIVIDE, &
    & DESTROYCHUNKDATABASE, REDUCECHUNKDATABASE

  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
    "$RCSfile: ChunkDivide_m.f90,v $"
  private :: not_used_here
  !---------------------------------------------------------------------------

  public :: CHUNKDIVIDECONFIG_T, CHUNKDIVIDECONFIG

  ! The chunk divide methods are:
  !
  ! Fixed - Ignore the L1B file, just give a fixed set of chunks as described
  !
  ! Polygon - Used for QTM, ASMLS
  !
  ! PE - One chunk centred on the given orbit geodetic angle.
  !
  ! Orbital - Chunks are some ideal fraction of an orbit.  The algorithm
  !           desires to keep the chunk boundaries at the same positions each
  !           orbit where possible.
  !
  ! Even - Hope to have chunks all about the same length, as quoted.

  type MAFRange_T
    integer, dimension(2) :: L1BCover ! Range found in L1B files
    integer, dimension(2) :: L2Cover  ! Range covered by L2 ProcessingRange
    integer, dimension(2) :: Expanded ! L2Cover plus prior/post overlaps
  end  type MAFRange_T

  public :: OBSTRUCTION_T
  ! This type describes obstructions in the Level 1 data which will affect the
  ! selection of chunk divisions.
  type Obstruction_T
    logical :: range                    ! If set is a range not a wall
    integer, dimension(2) :: MAFS       ! Affected MAF or MAF range
  end type Obstruction_T

  type (Obstruction_T), dimension(:), public, save, pointer :: OBSTRUCTIONS => null()

  interface dump
    module procedure DUMP_OBSTRUCTIONS
    ! module procedure DUMP_CRITICALSIGNALS
  end interface

  logical, parameter :: CHECKFORSHAREDMAFS = .true.
  integer, parameter :: SEVERITYIFPHINOTMONO = MLSMSG_Error
  logical, parameter :: DONTPAD = .true.
  integer :: swLevel ! How much extra debugging info to print (-1 means none)
  integer, parameter :: VERBOSETHRESHOLD = 1 ! was 0; turn on extra debugging

contains ! ===================================== Public Procedures =====

  !----------------------------------------  DestroyChunkDatabase  -----
  subroutine DestroyChunkDatabase ( Chunks, Shallow )
    use Allocate_Deallocate, only: Deallocate_Test, Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use Toggles, only: Gen, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

    type( MLSChunk_T ), dimension(:), pointer  :: CHUNKS
    logical, intent(in), optional :: Shallow ! Don't deallocate components

    integer(c_intptr_t) :: Addr    ! For tracing
    integer :: CHUNK               ! Index
    logical :: Deep                ! .not. shallow, else .false.
    integer :: Me = -1             ! String index for trace
    integer :: S                   ! Size in bytes of an object to deallocate
    integer :: STATUS              ! From deallocate

    if ( .not. associated ( chunks ) ) return

    call trace_begin ( me, "DestroyChunkDatabase", cond=toggle(gen) )
    deep = .true.
    if ( present(shallow) ) deep = .not. shallow
    if ( deep ) then
      do chunk = 1, size ( chunks )
        call Deallocate_test ( chunks(chunk)%hGridOffsets, &
          & 'chunks(?)%hGridOffsets', ModuleName )
        call Deallocate_test ( chunks(chunk)%hGridTotals, &
          & 'chunks(?)%hGridTotals', ModuleName )
      end do
    end if
    s = size(chunks) * storage_size(chunks) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(chunks(1)), addr)
    deallocate ( chunks, stat=status )
    call test_deallocate ( status, moduleName, "chunks", s, address=addr )
    call trace_end ( "DestroyChunkDatabase", cond=toggle(gen) )
  end subroutine DestroyChunkDatabase

  !----------------------------------------  ReduceChunkDatabase  -----
  subroutine ReduceChunkDatabase ( chunks, firstChunk, lastChunk )

    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use Toggles, only: Gen, Toggle
    use Trace_m, only: Trace_Begin, Trace_End
    type (MLSChunk_T), dimension(:), pointer :: chunks
    integer, intent(in) :: firstChunk, lastChunk
    ! Local variables
    integer(c_intptr_t) :: Addr    ! For tracing
    type (MLSChunk_T), dimension(:), pointer :: TEMPDATABASE
    integer :: Me = -1             ! String index for trace
    integer :: newSize, status
    ! Executable
    if ( .not. associated ( chunks ) ) return
    call trace_begin ( me, "ReduceChunkDatabase", cond=toggle(gen) )
    newSize = lastChunk - firstChunk + 1
    if ( newSize < 1 ) return
    if ( lastChunk > size(chunks) ) return
    allocate(tempDatabase(newSize), STAT=status)
    addr = 0
    if ( status == 0 .and. newSize>0 ) addr = transfer(c_loc(tempDatabase(1)), addr )
    call test_allocate ( status, moduleName, "tempDatabase", uBounds = newSize, &
      elementSize = storage_size(tempDatabase) / 8, address=addr )

    tempDatabase(1:newSize) = chunks(firstChunk:lastChunk)
    call DestroyChunkDatabase ( chunks, shallow=.true. )
    chunks => tempDatabase
    call trace_end ( "ReduceChunkDatabase", cond=toggle(gen) )

  end subroutine ReduceChunkDatabase

  ! ------------------------------------------------  Chunk Divide -----
  subroutine ChunkDivide ( root, processingRange, filedatabase, chunks )

    use Allocate_Deallocate, only: Test_Deallocate
    use DumpCommand_m, only: DumpCommand
    use Expr_m, only: Expr
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use Lexer_Core, only: Print_Source
    use MLSCommon, only: TAI93_Range_T
    use MLSHDF5, only: GetHDF5Attribute
    use MLSL2Options, only: Need_L1BFiles, SpecialDumpfile
    use MLSL2Timings, only: Section_Times, Total_Times
    use MoreTree, only: Get_Field_ID, Get_Spec_ID
    use Next_Tree_Node_m, only: Next_Tree_Node, Next_Tree_Node_State
    use Time_m, only: Time_Now
    use Trace_m, only: Trace_Begin, Trace_End
    use Tree, only: Decoration, Node_ID, NSons, Subtree, Sub_Rosa, Where_At=>Where
    use Tree_Types, only: N_Named

    integer, intent(in) :: ROOT    ! Root of the L2CF tree for ChunkDivide
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type( TAI93_Range_T ), intent(in) :: PROCESSINGRANGE
    type( MLSChunk_T ), dimension(:), pointer  :: CHUNKS, TempChunks

    ! Local variables
    integer(c_intptr_t) :: Addr    ! For tracing
    type (MLSFile_T), pointer :: DACSFile
    type (MAFRange_T) :: MAFRange
    integer :: Me = -1                  ! String index for trace
    integer :: S                        ! Size in bytes of an object to deallocate
    integer :: Son                      ! of section root
    type(next_tree_node_state) :: State ! of tree traverser
    integer :: STATUS                   ! From deallocate

    ! For announce_error:
    logical :: DidOne                   ! Found a ChunkDivide spec
    integer :: ERROR                    ! Error level
    integer :: CHUNK                    ! Loop counter
    integer :: NumberOlds               ! Loop counter
    integer :: OLDCHUNK                 ! Loop counter

    integer, parameter :: BadUnits = 1
    integer, parameter :: NotSpecified = BadUnits + 1
    integer, parameter :: Unnecessary = NotSpecified + 1
    integer, parameter :: invalid = Unnecessary + 1
    integer :: instrumentModule
    character (len=NameLen) :: InstrumentModuleName
    type(Range_T), dimension(:), allocatable :: MAFRanges

    ! For timing
    logical :: Timing
    real :: T1

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    nullify(ChunkDivideConfig%criticalSignals)    ! Just for Sun's compiler

    call trace_begin ( me, "ChunkDivide", root, cond=toggle(gen) )

    timing = section_times
    if ( timing ) call time_now ( t1 )
    if ( specialDumpFile /= ' ' ) &
      & call switchOutput( specialDumpFile, keepOldUnitOpen=.true. )

    ! First decode the l2cf instructions

    ! Eventually the ChunkDivide command will be free floating, in the meantime
    ! find it within the section
    ! WE CAN GET RID OF THIS BIT WHEN THE COMMAND FLOATS FREE LATER
    didOne = .false.
    do
      son = next_tree_node ( root, state )
      if ( son == 0 ) exit
      if ( node_id(son) == n_named ) son = subtree(2,son) ! Ignore label
      select case ( get_spec_id(son) )
      case ( s_dump )
        call dumpCommand ( son )
      case ( s_chunkDivide )
        call chunkDivideL2CF ( son )
        call dump(ChunkDivideConfig)
        didOne = .true.
      end select
    end do
    if ( .not. didOne ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & 'ChunkDivide section must include a ChunkDivide Spec' )

    ! For methods other than fixed, we want to survey the L1 data and note the
    ! location of obstructions
    nullify ( obstructions )
    if ( .not. NEED_L1BFILES ) then
      call output( 'Entered ChunkDivide w/o an l1boa file--hope thats OK', &
        & advance='yes' )
    elseif ( ChunkDivideConfig%method /= l_fixed ) then
      call output( 'We must survey the l1b data for this Chunk Divide method', &
        & advance='yes' )
      call SurveyL1BData ( processingRange, filedatabase, mafRange )
      if ( swLevel > -1 ) then
        call output ( 'Requested time range ' )
        call output ( processingRange%startTime )
        call output ( ' : ' )
        call output ( processingRange%endTime, advance='yes' )
        call output ( 'Corresponding MAF range ' )
        call output ( mafRange%L2Cover(1) )
        call output ( ' : ' )
        call output ( mafRange%L2Cover(2), advance='yes' )
        call output ( 'MAF range in L1B files ' )
        call output ( mafRange%L1BCover(1) )
        call output ( ' : ' )
        call output ( mafRange%L1BCover(2), advance='yes' )
        call output ( 'including overlapped days ' )
        call output ( mafRange%Expanded(1) )
        call output ( ' : ' )
        call output ( mafRange%Expanded(2), advance='yes' )
        call output ( 'Method: ' )
        call display_string ( lit_indices(ChunkDivideConfig%method), &
          &             strip=.true., advance='yes' )
      endif
    endif

    ! Now go place the chunks.
    select case ( ChunkDivideConfig%method )
    case ( l_fixed )
      call ChunkDivide_Fixed ( chunks, root )
    case ( l_polygon )
      if ( .not. NEED_L1BFILES ) then
        call AnnounceError ( root, invalid, ChunkDivideConfig%method )
      else
        call ChunkDivide_Polygon ( mafRange, filedatabase, chunks, &
                                 & InstrumentModuleName, root )
      endif
    case ( l_PE )
      if ( .not. NEED_L1BFILES ) then
        call AnnounceError ( root, invalid, ChunkDivideConfig%method )
      else
        call ChunkDivide_PE ( mafRange%Expanded, filedatabase, chunks )
      endif
    case ( l_orbital )
      if ( .not. NEED_L1BFILES ) then
        call AnnounceError ( root, invalid, ChunkDivideConfig%method )
      else
        call ChunkDivide_Orbital ( mafRange, filedatabase, chunks, root )
      endif
    case ( l_even )
      if ( .not. NEED_L1BFILES ) then
        call AnnounceError ( root, invalid, ChunkDivideConfig%method )
      else
        call ChunkDivide_Even ( mafRange%Expanded, filedatabase, chunks )
      endif
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unexpected problem with ChunkDivide' )
    end select

    ! Check that level 1 has done the DACS deconvolution (so we don't have to)
    ! Note that this would be an attribute, a global one, of the DACS
    ! radiance file attached to the group object '/'
    if ( NEED_L1BFILES ) &
      & DACSFile => GetL1BFile ( filedatabase, 'DACsDeconvolved', '-/a' )
    if ( .not. NEED_L1BFILES ) then
      ChunkDivideConfig%DACSDeconvolved = .false.
    elseif ( associated(DACSFile) ) then
      if ( .not. DACSFile%stillOpen ) call mls_OpenFile(DACSFile)
      DACSFile%fileID%sd_id = 0 ! So we don't look here for the attribute
      ! We still need to open the root group '/'
      call h5gopen_f ( DACSFile%fileID%f_id, '/', DACSFile%fileID%grp_id, status )
      call GetHDF5Attribute( DACSFile, 'DACsDeconvolved', &
      & ChunkDivideConfig%DACSDeconvolved )
      call h5gclose_f ( DACSFile%fileID%grp_id, status )
    else
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & 'Attribute DACsDeconvolved not found in probable DACS file' )
      ChunkDivideConfig%DACSDeconvolved = .false.
    endif

    if ( .not. ChunkDivideConfig%DACSDeconvolved ) &
      & call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & 'Failed to confirm that level 1 performed DACS deconvolution--hope' // &
      & ' you are OK with that' )

    ! Tidy up
    if ( swLevel > -1 .or. &
      & switchDetail(switches, 'opt') > -1 ) call dump(ChunkDivideConfig)
    if ( associated(obstructions) ) then
      if ( swLevel > -1 ) call Dump_Obstructions ( obstructions )
      if ( .not. ChunkDivideConfig%saveObstructions ) then
        s = size(obstructions) * storage_size(obstructions) / 8
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(obstructions(1)), addr)
        deallocate ( obstructions, stat=status )
        call test_deallocate ( status, moduleName, 'obstructions', s, address=addr )
      end if
    end if
    if ( associated(ChunkDivideConfig%criticalSignals) ) then
      if ( swLevel > -1 ) &
        & call Dump_criticalSignals(ChunkDivideConfig%criticalSignals)
      s = size(ChunkDivideConfig%criticalSignals) * &
        & storage_size(ChunkDivideConfig%criticalSignals) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(ChunkDivideConfig%criticalSignals(1)(1:1)), addr)
      deallocate ( ChunkDivideConfig%criticalSignals, stat=status )
      call test_deallocate ( status, moduleName, &
        & 'ChunkDivideConfig%criticalSignals', s, address=addr )
    end if
    ! Check that no 2 chunks share non-overlapped MAFs
    ! That mafrange(1) <= all_mafs <= mafrange(2)
    ! And that all overlaps are >= 0
    if ( ChunkDivideConfig%method /= l_fixed ) &
      & call CheckChunkSanity ( chunks, mafRange%Expanded )
    if ( .not. associated(chunks) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'ChunkDivide failed to associate the chunks pointer with a target' )
    else if ( size(chunks) < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'ChunkDivide failed to produce any chunks' )
    endif
    
    !! Check that no chunk is wholly contained inside another
    NumberOlds = size ( chunks )
    allocate( MAFRanges( NumberOlds ) )
    do chunk = 1, NumberOlds
      MAFRanges(chunk)%Bottom = chunks(chunk)%firstMAFIndex
      MAFRanges(chunk)%Top    = chunks(chunk)%lastMAFIndex
    enddo
    
    call OutputNamedValue('Num Chunks before checking inRange', NumberOlds )
    
    nullify (TempChunks)
    do OldChunk = 1, NumberOlds
      if ( OldChunk == 1 ) then
        ! if ( any ( inRange( MAFRanges(OldChunk), MAFRanges(2:NumberOlds) ) ) ) cycle
        if ( any ( &
          & inRange( MAFRanges(OldChunk), MAFRanges(2:NumberOlds), butNotEqual=.true. ) &
          & ) ) then
          ! What we want to know is, does this chunk have as many 
          ! non-overlap MAFs as the other chunks  with the same range
        endif
        if ( inRange( MAFRanges(OldChunk), MAFRanges(2) ) ) then
          if ( nonOverlapMAFs( chunks(1) ) <= nonOverlapMAFs( chunks(2) ) ) cycle
        endif
      elseif ( OldChunk < size ( chunks ) ) then
        if ( &
          & any ( &
          & inRange( MAFRanges(OldChunk), MAFRanges(1:OldChunk-1), butNotEqual=.true. ) &
          & ) &
          & .or. &
          & any ( &
          & inRange( MAFRanges(OldChunk), MAFRanges(OldChunk+1:NumberOlds), butNotEqual=.true. ) &
          & ) &
          & ) cycle
        if ( inRange( MAFRanges(OldChunk), MAFRanges(OldChunk-1) ) ) then
          if ( nonOverlapMAFs( chunks(OldChunk) ) < nonOverlapMAFs( chunks(OldChunk-1) ) ) cycle
        endif
      ! This is checking about the last chunk
      ! No matter what, if we haven't any chunks that survived the check so far
      ! let this last chunk through, or we wont't end up with any.
      elseif ( associated(TempChunks) ) then
        if ( any ( &
        & inRange( MAFRanges(OldChunk), MAFRanges(1:OldChunk-1), butNotEqual=.true. ) &
        & ) ) cycle
        if ( inRange( MAFRanges(OldChunk), MAFRanges(OldChunk-1) ) ) then
          if ( nonOverlapMAFs( chunks(OldChunk) ) < nonOverlapMAFs( chunks(OldChunk-1) ) ) cycle
        endif
      endif
      call AddChunkToDatabase ( TempChunks, Chunks(OldChunk) )
    enddo
    call DestroyChunkDatabase ( chunks, shallow=.true. )
    chunks => TempChunks
    
    call OutputNamedValue('Num Chunks after removing inRange', size ( chunks ) )

    ! Now go through and number the chunks
    do chunk = 1, size ( chunks )
      chunks(chunk)%chunkNumber = chunk
    end do

    if ( swLevel > 0 .or. .true. ) then
      call dump ( chunks )
    else
      call OutputNamedValue( 'Number of chunks', size(chunks) )
    endif
    if ( specialDumpFile /= ' ' ) call revertOutput
    call trace_end ( "ChunkDivide", cond=toggle(gen) )

  contains

  ! ========================================== Internal Procedures =====
  
    ! ---------------------------------------------- nonOverlapMAFs -----
    function nonOverlapMAFs ( chunk ) result ( number )
      type(MLSChunk_T), intent(in) :: chunk
      integer                      :: number
      number = chunk%lastMAFIndex - chunk%firstMAFIndex + 1 &
        & - chunk%noMAFsLowerOverlap - chunk%noMAFsUpperOverlap
    end function nonOverlapMAFs

    ! ---------------------------------------------- AnnounceError -----
    subroutine AnnounceError ( where, Code, field )
      integer, intent(in) :: where, Code, field

      error = max(error,1)
      call print_source ( where_at(where) )
      call output ( ', ChunkDivide complained: ' )
      select case ( code )
      case ( BadUnits )
        call output ( ' The field ' )
        call display_string ( field_indices(field) )
        call output (' has inappropriate units', advance='yes' )
      case ( notSpecified )
        call output ( ' The parameter ' )
        call display_string ( field_indices(field) )
        call output ( ' is required but not specified.', advance='yes' )
      case ( unnecessary )
        call output ( ' The parameter ' )
        call display_string ( field_indices(field) )
        call output ( ' is specified but not appropriate.', advance='yes' )
      case ( invalid )
        call output ( ' The method ' )
        call display_string ( lit_indices(field) )
        call output ( ' is invalid w/o an l1boa file.', advance='yes' )
      end select
    end subroutine AnnounceError

    !-------------------------------------------- ChunkDivide_Even -----
    subroutine ChunkDivide_Even ( mafRange, filedatabase, chunks, root )
      integer, dimension(2), intent(in) :: MAFRANGE
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (MLSChunk_T), dimension(:), pointer :: CHUNKS
      integer, intent(in), optional :: Root ! in l2cf tree, for tracing

      ! Local variables
      integer :: Me = -1             ! String index for trace

      ! Exectuable code
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "I'm sorry, we haven't written the code for even chunk divides yet" )
      if ( present(root) ) call trace_begin ( me, 'ChunkDivide_even', root, &
          & cond=toggle(gen) .and. levels(gen) > 2 )
      if ( present(root) ) call trace_end ( &
        & 'ChunkDivide_even', cond=toggle(gen) .and. levels(gen) > 2 )
    end subroutine ChunkDivide_Even

    !------------------------------------------- ChunkDivide_Fixed -----
    subroutine ChunkDivide_Fixed ( chunks, root )
      ! type (ChunkDivideConfig_T), intent(in) :: CONFIG
      use Allocate_Deallocate, only: Test_Allocate
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
      type (MLSChunk_T), dimension(:), pointer :: CHUNKS
      integer, intent(in), optional :: Root ! in l2cf tree, for tracing

      ! Local variables
      integer(c_intptr_t) :: Addr         ! For tracing
      integer :: I                        ! Loop inductor
      integer :: Me = -1                  ! String index for trace
      integer :: STATUS                   ! From allocate
      integer :: MAXLENGTH                ! nint(config%maxLength)
      integer :: LOWEROVERLAP             ! nint(config%lowerOverlap)
      integer :: UPPEROVERLAP             ! nint(config%upperOverlap)

      ! Executable code
      if ( present(root) ) call trace_begin ( me, 'ChunkDivide_fixed', root, &
          & cond=toggle(gen) .and. levels(gen) > 2 )
      swlevel = switchDetail(switches, 'chu' )
      allocate ( chunks(ChunkDivideConfig%noChunks), stat=status )
      addr = 0
      if ( status == 0 .and. ChunkDivideConfig%noChunks > 0 ) &
        & addr = transfer(c_loc(chunks(1)), addr)
      call test_allocate ( status, moduleName, 'chunks', &
        & uBounds = ChunkDivideConfig%noChunks, &
        & elementSize = storage_size(chunks) / 8, address=addr )

      maxLength = nint ( ChunkDivideConfig%maxLength )
      lowerOverlap = nint ( ChunkDivideConfig%lowerOverlap )
      upperOverlap = nint ( ChunkDivideConfig%upperOverlap )
      do i = 1, ChunkDivideConfig%noChunks
        chunks(i)%firstMAFIndex = max ( (i-1)*maxLength - lowerOverlap, 0 )
        chunks(i)%lastMAFIndex = i*maxLength + upperOverlap - 1
        chunks(i)%noMAFsUpperOverlap = upperOverlap
        if ( i > 1 ) then
          chunks(i)%noMAFsLowerOverlap = lowerOverlap
        else
          chunks(i)%noMAFsLowerOverlap = 0
        end if
      end do
      if ( present(root) ) call trace_end ( &
        & 'ChunkDivide_fixed', cond=toggle(gen) .and. levels(gen) > 2 )

    end subroutine ChunkDivide_Fixed

    !------------------------------------------- ChunkDivide_Polygon -----
    subroutine ChunkDivide_Polygon ( mafRange, filedatabase, chunks, &
                                   & InstrumentModuleName, root )
      ! integer, dimension(2), intent(in) :: MAFRANGE
      use Allocate_Deallocate, only: Test_Allocate
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
      use Dump_Geolocation_m, only: Dump_H_t
      use Geometry, only: To_XYZ
      use PnPoly_m, only: PnPoly

      type (MAFRange_T) :: MAFRange
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (MLSChunk_T), dimension(:), pointer :: CHUNKS
      character (len=NameLen) :: InstrumentModuleName
      integer, intent(in), optional :: Root ! in l2cf tree, for tracing


      ! Local variables
      integer(c_intptr_t) :: Addr         ! For tracing
      integer :: I                        ! Loop inductor
      integer :: MAF
      integer :: Me = -1                  ! String index for trace
      integer :: STATUS                   ! From allocate
      integer :: MAXLENGTH                ! nint(config%maxLength)
      integer :: LOWEROVERLAP             ! nint(config%lowerOverlap)
      integer :: UPPEROVERLAP             ! nint(config%upperOverlap)
      type (L1BData_T) :: lats            ! lats data
      type (L1BData_T) :: lons            ! lons data
      type (MLSFile_T), pointer             :: L1BFile
      integer :: L1BFLAG                  ! error Flag
      integer :: NoMAFs
      character (len=NameLen) :: L1BItemName
      logical, dimension(:), pointer :: ptsInPolygon => null()
      real(r8), dimension(3)         :: xyz
      real(r8), dimension(:), allocatable :: Vertices_XX, Vertices_YY
      real(r8), dimension(3)         :: PolyVert_XYZ
      integer :: n
      integer, dimension(2) :: range
      ! integer :: pointTest

      ! Executable code
      if ( present(root) ) call trace_begin ( me, 'ChunkDivide_polygon', root, &
          & cond=toggle(gen) .and. levels(gen) > 2 )
      ! 1st-- read lats and lons from the l1b file
      L1BFile => GetMLSFileByType( filedatabase, content='l1boa' )
      if ( .not. associated(L1BFile) ) &
        & call MLSMessage  ( MLSMSG_Error, ModuleName, &
          & "Can't make progress in ChunkDivide_polygon without L1BOA files" )
      l1bItemName = AssembleL1BQtyName (  instrumentModuleName//".tpGeodLat", L1BFile%HDFVersion, .false. )
      call output (trim(l1bItemName), advance ='yes')
      call ReadL1BData ( L1BFile, l1bItemName, lats, noMAFs, &
        & l1bFlag )
      if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Where is ' // l1bItemName )
      call output ('lats is ', advance='yes' )
      call output( lats%dpField(1,1,1::NoMAFS), advance='yes')
      call dump ( lats, 0)
      l1bItemName = AssembleL1BQtyName ( instrumentModuleName//".tpLon", L1BFile%HDFVersion, .false. )
      call output (trim(l1bItemName), advance ='yes')
      call ReadL1BData ( L1BFile, l1bItemName, lons, noMAFs, &
        & l1bFlag )
      if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Where is ' // l1bItemName )
      call output ('lons is ' )
      call dump ( lons, 0 )
      call allocate_test( ptsInPolygon, noMAFs, 'ptsInPolygon', &
        & ModuleName )
      n = size(polygon_vertices)
      allocate(Vertices_XX(n))
      allocate(Vertices_YY(n))



      do i = 1, n
        PolyVert_XYZ = to_xyz(polygon_vertices(i)%lat, polygon_vertices(i)%lon%d)
        call output ( polygon_vertices(i)%lon%d )
        Vertices_XX(i)= PolyVert_XYZ(1)
        call output ('   ')
        call output ( polygon_vertices(i)%lat, advance='yes' )
        Vertices_YY(i) = PolyVert_XYZ(2)
        call output ('Vertices_XX,  Vertices_YY for polygon is ')
        call output (Vertices_XX(i))
        call output ('   ')
        call output (Vertices_YY(i), advance='yes')
      end do

      ! Now we'll check for whether the points are inside or outside the PolyGon
      call output ('before do MAF loop', advance='yes')
      !pointTest = 0
      do MAF=1, NoMAFs
         call output('lat = ')
         call output( lats%dpField(1,1,MAF) )
         call output ('  lon = ')
         call output( lons%dpField(1,1,MAF), advance='yes')
         xyz = to_xyz ( lats%dpField(1,1,MAF), lons%dpField(1,1,MAF))
         call output ('xyz is ')
         call output (xyz, advance='yes')
         call output(PnPoly(xyz(1), xyz(2), Vertices_XX, Vertices_YY ), advance='yes')
         if ((PnPoly(xyz(1), xyz(2), Vertices_XX, Vertices_YY )) == 1)  then
             ptsInPolygon(MAF) = .true.
             !pointTest = pointTest + 1
           !  if (MAF == 70) then
           !    ptsInPolygon(MAF) = .false.
           !  end if
           !  if (MAF == 100) then
            !    ptsInPolygon(MAF) = .false.
           !  end if
           !  if (MAF == 200) then
           !     ptsInPolygon(MAF) = .false.
           !  end if
           !  if (MAF == 240) then
           !     ptsInPolygon(MAF) = .false.
           !  end if
           !  if (MAF == 300) then
           !     ptsInPolygon(MAF) = .false.
          !   end if
         else
             !ptsInPolygon(MAF) = pointTest
             !pointTest = 0
             ptsInPolygon(MAF) = .false.
         end if

        ! Use To_XYZ to get XX, YY, ZZ
        ! The send XX, YY through Pn_Poly
        ! Set to true or false depending on retrun value (-1 outside, +1 inside)
        ! store in ptsInPolygon
      enddo
      ! Now dump ptsInPolygon
      call dump(ptsInPolygon, "ptsInPolygon")

      call output ( 'ChunckDivide_Polygon is usign Fixed method exactly.\n' )
      call output ( 'vertices \n')
      call dump_h_t ( polygon_vertices, &
      & 'Polygon boundary vertices (lon,lat):', format='(f8.3)' )

      call output ( 'Polygon_Inside \n')
      call output ( polygon_inside%lon%d, before='Point inside polygon (lon,lat): (' )
      call output ( polygon_inside%lat, before=',', after=')', advance='yes' )

      call output ( 'mafRange ', advance='yes')
       call output ( 'Corresponding MAF range ')
        call output ( mafRange%L2Cover(1) )
        call output ( ' : ' )
        call output ( mafRange%L2Cover(2), advance='yes' )
        call output ( 'MAF range in L1B files ' )
        call output ( mafRange%L1BCover(1) )
        call output ( ' : ' )
        call output ( mafRange%L1BCover(2), advance='yes' )
        call output ( 'including overlapped days ' )
        call output ( mafRange%Expanded(1) )
        call output ( ' : ' )
        call output ( mafRange%Expanded(2), advance='yes' )

        call output ( 'before  FindLongestRange  call ', advance='yes')
        call FindLongestRange (ptsInPolygon, .true., range)
        call output ('range is ')
        call output (range, advance='yes')

        call output ( 'after  FindLongestRange  call ')

      swlevel = switchDetail(switches, 'chu' )
      allocate ( chunks(ChunkDivideConfig%noChunks), stat=status )
      addr = 0
      if ( status == 0 .and. ChunkDivideConfig%noChunks > 0 ) &
        & addr = transfer(c_loc(chunks(1)), addr)
      call test_allocate ( status, moduleName, 'chunks', &
        & uBounds = ChunkDivideConfig%noChunks, &
        & elementSize = storage_size(chunks) / 8, address=addr )

      maxLength = nint ( ChunkDivideConfig%maxLength )
      lowerOverlap = nint ( ChunkDivideConfig%lowerOverlap )
      upperOverlap = nint ( ChunkDivideConfig%upperOverlap )
      do i = 1, ChunkDivideConfig%noChunks
        chunks(i)%firstMAFIndex = max ( (i-1)*maxLength - lowerOverlap, 0 )
        chunks(i)%lastMAFIndex = i*maxLength + upperOverlap - 1
        chunks(i)%noMAFsUpperOverlap = upperOverlap
        if ( i > 1 ) then
          chunks(i)%noMAFsLowerOverlap = lowerOverlap
        else
          chunks(i)%noMAFsLowerOverlap = 0
        end if
      end do
      if ( present(root) ) call trace_end ( &
        & 'ChunkDivide_Polygon', cond=toggle(gen) .and. levels(gen) > 2 )

    end subroutine ChunkDivide_Polygon

    !---------------------------------------------- ChunkDivide_PE -----
    subroutine ChunkDivide_PE ( mafRange, filedatabase, chunks, root )
      ! type (ChunkDivideConfig_T), intent(in) :: CONFIG
      use Allocate_Deallocate, only: Test_Allocate
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
      integer, dimension(2), intent(in) :: MAFRANGE
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (MLSChunk_T), dimension(:), pointer :: CHUNKS
      integer, intent(in), optional :: Root ! in l2cf tree, for tracing

      ! Local parameters
      real(r8), parameter :: HOMEACCURACY = 3.0 ! Try to hit homeGeodAngle within this

      ! Local variables
      type (L1BData_T) :: TAITIME         ! From L1BOA
      type (L1BData_T) :: TPGEODANGLE     ! From L1BOA

      character(len=10) :: MODNAMESTR     ! Home module name as string

      integer(c_intptr_t) :: Addr         ! For tracing
      integer :: FLAG                     ! From ReadL1B
      integer :: HOMEMAF                  ! first MAF after homeGeodAngle
      integer :: HOME                     ! Index of home MAF in array
      integer :: Me = -1                  ! String index for trace
      integer :: M1, M2                   ! MafRange + 1
      integer :: NOMAFS                   ! Number of MAFs to consider
      integer :: NOMAFSREAD               ! From ReadL1B
      integer :: ORBIT                    ! Used to locate homeMAF
      integer :: STATUS                   ! From allocate etc.
      integer :: NOCHUNKS                 ! Number of chunks
      integer :: MAXLENGTH                ! Max length as integer (MAFs)

      real(r8) :: ANGLEINCREMENT          ! Increment in hunt for homeMAF
      real(r8) :: MAXANGLE                ! Of range in data
      real(r8) :: MINANGLE                ! Of range in data
      real(r8) :: TESTANGLE               ! Angle to check for

      integer   ::                 l1b_hdf_version
      character(len=namelen) ::    MAF_start, tp_angle
      type (MLSFile_T), pointer :: L1BFile

      ! Executable code
      if ( present(root) ) call trace_begin ( me, 'ChunkDivide_PE', root, &
          & cond=toggle(gen) .and. levels(gen) > 2 )
      swlevel = switchDetail(switches, 'chu' )

      ! Read in the data we're going to need
      call get_string ( lit_indices(ChunkDivideConfig%homeModule), modNameStr, &
        & strip=.true. )
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      if ( .not. associated(L1BFile) ) &
        & call MLSMessage  ( MLSMSG_Error, ModuleName, &
          & "Can't make progress in ChunkDivide_PE without L1BOA files" )
      ! call dump(L1BFile)
      l1b_hdf_version = L1BFile%HDFVersion
      MAF_start = AssembleL1BQtyName ( 'MAFStartTimeTAI', l1b_hdf_version, &
        .false. )
      tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
        & l1b_hdf_version, &
        & .false. )
      call ReadL1BData ( L1BFile, trim(tp_angle), &
        & tpGeodAngle, noMAFsRead, flag, &
        & dontPad=DONTPAD )
      ! If you needed this, should you be using this chunkDivide?
      call smoothOutDroppedMAFs(tpGeodAngle%dpField)
      call smoothOutDroppedMAFs(tpGeodAngle%dpField, monotonize=.true.)
      call ReadL1BData ( L1BFile, trim(MAF_start), &
        & taiTime, noMAFsRead, flag, &
        & dontPad=DONTPAD )
      call smoothOutDroppedMAFs(taiTime%dpField)
      noMAFs = mafRange(2) - mafRange(1) + 1
      m1 = mafRange(1) + 1
      m2 = mafRange(2) + 1

      minAngle = minval ( tpGeodAngle%dpField(1,1,m1:m2) )
      maxAngle = maxval ( tpGeodAngle%dpField(1,1,m1:m2) )

      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! First try to locate the last MAF before the homeGeodAngle
      orbit = int ( tpGeodAngle%dpField(1,1,m1)/360.0 )
      if ( tpGeodAngle%dpField(1,1,m1) < 0.0 ) orbit = orbit - 1
      testAngle = ChunkDivideConfig%homeGeodAngle + orbit*360.0
      if ( ChunkDivideConfig%maxLengthFamily == PHYQ_Angle ) then
        angleIncrement = ChunkDivideConfig%maxLength
      else
        angleIncrement = 360.0
      end if

      maxLength = nint ( ChunkDivideConfig%maxLength )

      homeHuntLoop: do
        if ( testAngle < minAngle ) then
          testAngle = testAngle + angleIncrement
          cycle
        endif
        if ( testAngle > maxAngle ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Unable to establish a home major frame, using the first' )
          home = 1
          exit homeHuntLoop
        end if
        ! Find MAF which starts before this test angle
        call Hunt ( tpGeodAngle%dpField(1,1,:), testAngle, home, nearest=.true.,&
          & allowTopValue = .true. )
        ! Now if this is close enough, and has enough MAFs around it, accept it
        if ( ( abs ( tpGeodAngle%dpField(1,1,home) - &
          & testAngle ) < HomeAccuracy ) &
          & .and. ( home - maxLength/2 >= 1 ) &
          & .and. ( home + maxLength/2 <= noMAFs ) ) exit homeHuntLoop
        ! Otherwise, keep looking
        testAngle = testAngle + angleIncrement
      end do homeHuntLoop
      homeMAF = home + m1 - 1

      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! OK, now we have a home MAF, get a first cut for the chunks
      ! We work out the chunk ends for each chunk according to how the
      ! maxLength field is specified.
      ! ChunkDivideConfig%maxLengthFamily == PHYQ_MAFs
      noChunks = 1

      ! Allocate the chunk
      allocate ( chunks(noChunks), stat=status )
      addr = 0
      if ( status == 0 .and. noChunks > 0 ) addr = transfer(c_loc(chunks(1)), addr )
      call test_allocate ( status, ModuleName, 'chunks', uBounds = noChunks, &
        & elementSize = storage_size(chunks) / 8, address=addr )

      ! Work out its position (in the file)
      chunks(1)%firstMAFIndex = homeMAF - maxLength/2 - 1
      chunks(1)%lastMAFIndex = homeMAF + maxLength/2 - 1

      chunks(1)%noMAFsUpperOverlap = 0
      chunks(1)%noMAFsLowerOverlap = 0

      call DeallocateL1BData ( tpGeodAngle )
      call DeallocateL1BData ( taiTime )
      if ( present(root) ) call trace_end ( &
        & 'ChunkDivide_PE', cond=toggle(gen) .and. levels(gen) > 2 )

    end subroutine ChunkDivide_PE

    !--------------------------------------------- ChunkDivideL2CF -----
    subroutine ChunkDivideL2CF ( root )
      ! This subroutine identifies, separates, and checks values from the section
      ! of the MLSCF (ChunkDivide) passed to Scan/Divide.
      use HighOutput, only: LetsDebug, OutputNamedValue
      use Init_Tables_Module, only: Field_Indices
      use moreTree, only: get_boolean
      integer, intent(in) :: ROOT    ! Root of the ChunkDivide command
                                     ! MLSCF abstract syntax tree
      ! type (ChunkDivideConfig_T), intent(out) :: CONFIG ! Result of operation

      integer, target, dimension(2) :: NeededForFixed = &
        & (/ f_maxLength, f_overlap /)
        ! & (/ f_noChunks, f_maxLength, f_overlap /)
      integer, target, dimension(7) :: NotWantedForFixed = &
        & (/ f_noSlaves, f_homeModule, f_homeGeodAngle, f_scanLowerLimit, &
        &    f_scanUpperLimit, f_criticalModules, f_maxGap /)

      integer, target, dimension(3) :: NeededForPE = &
        & (/ f_maxLength, f_homeModule, f_homeGeodAngle /)
      integer, target, dimension(7) :: NotWantedForPE = &
        & (/ f_noChunks, f_overlap, f_noSlaves, f_scanLowerLimit, &
        &    f_scanUpperLimit, f_criticalModules, f_maxGap /)

      integer, target, dimension(5) :: NeededForOrbital = &
        & (/ f_maxLength, f_overlap, f_homeModule, f_homeGeodAngle, &
        &    f_maxGap /)
        ! &    f_criticalModules, f_maxGap /)
      integer, target, dimension(1) :: NotWantedForOrbital = &
        & (/ f_noSlaves /)

      integer, target, dimension(6) :: NeededForEven = &
        & (/ f_maxLength, f_overlap, f_maxLength, f_noSlaves, f_maxGap, &
        &    f_criticalModules /)
      integer, target, dimension(3) :: NotWantedForEven = &
        & (/ f_noChunks, f_homeModule, f_homeGeodAngle /)

      ! Local variables
      logical :: debug
      integer :: FieldIndex               ! Of son of the ChunkDivide command
      integer :: FieldValue
      integer :: GSON                     ! A son of son the ChunkDivide command node
      integer :: I                        ! Loop inductor
      integer :: J                        ! Another loop inductor
      logical :: Log_Value                ! For boolean fields
      integer :: Me = -1                  ! String index for trace cacheing
      integer :: numCriticalSignals       ! How many crit. Sigs
      integer :: signalsNode              ! Node where crit. Sig. begin
      integer :: SON                      ! A son of the ChunkDivide command
      integer :: UNITS(2)                 ! Units of expression
      integer, dimension(:), pointer :: NEEDED ! Which fields are needed
      integer, dimension(:), pointer :: NOTWANTED ! Which fields are not wanted
      logical :: GOT(field_first:field_last) = .false.
      real(rp) :: VALUE(2)                ! Value of expression

      ! Executable code
      call trace_begin ( me, 'ChunkDivideL2CF', root, &
        & cond=toggle(gen) .and. levels(gen) > 0 )
      swlevel = switchDetail(switches, 'chu' )
      debug = LetsDebug ( 'chu', 2 )
      error = 0
      ChunkDivideConfig%where = root

      got = .false.

      ! Loop through the command identifying fields and storing values.
      do i = 2, nsons(root) ! Skip the command
        son = subtree(i,root)
        if ( nsons(son) > 1 ) then
          fieldValue = decoration(subtree(2,son)) ! The field's value
        else
          fieldValue = son
        end if
        fieldIndex = get_field_id(son)
        got(fieldIndex) = .true.
        call trace_begin ( 'ChunkDivideL2CF.loop', root, &
          & string=field_indices(fieldIndex),&
          & cond=toggle(gen) .and. levels(gen) > 1 )
        if ( &
          & any(fieldIndex == &
          & (/ f_excludePostOverlaps, f_excludePriorOverlaps, f_skipL1BCheck, &
          & f_crashIfPhiNotMono, f_saveObstructions /) &
          & ) &
          & ) then
          log_value = get_Boolean(son)
        else
          log_value = .false.
        endif
        if ( debug ) then
        call OutputNamedValue ( 'fieldIndex ', fieldIndex )
        call OutputNamedValue ( 'nsons(son) ', nsons(son) )
        call OutputNamedValue ( 'log_value ', log_value )
        endif
        if (nsons(son) > 1 ) then
          gson = subtree(2,son)
          call expr ( gson, units, value )
          ! log_value = get_boolean ( fieldValue )
        elseif (nsons(son) > 0 ) then
          value = 0.0
          ! log_value = get_boolean ( fieldValue )
        else
          value = 0.0
          ! log_value = .false.
        end if
        ! Get value for this field if appropriate
        select case ( fieldIndex )
        case ( f_method )
          ChunkDivideConfig%method = decoration ( gson )
        case ( f_module )
          call output ('Inside case f_module', advance='yes')
          !ChunkDivideConfig%module = decoration ( gson )
          instrumentModule = decoration(decoration(subtree(2,son)))
          call GetModuleName ( instrumentModule , instrumentModuleName )
          call output ('insturmentModule name is   ')
          call output (instrumentModule , advance='yes')
          call output ('insturmentModuleNAME name is   ')
          call output (instrumentModuleName , advance='yes')
          ChunkDivideConfig%module = instrumentModule
        case ( f_noChunks )
          ChunkDivideConfig%noChunks = nint ( value(1) )
        case ( f_maxLength )
          ChunkDivideConfig%maxLength = value(1)
          ChunkDivideConfig%maxLengthFamily = units(1)
        case ( f_maxOrbY )
          ChunkDivideConfig%maxOrbY = value(1)
          if ( units(1) /= PHYQ_Length ) &
            & call AnnounceError ( root, BadUnits, fieldIndex )
        case ( f_overlap )
          ChunkDivideConfig%overlap = value(1)
          ChunkDivideConfig%overlapFamily = units(1)
        case ( f_lowerOverlap )
          ChunkDivideConfig%lowerOverlap = value(1)
          ChunkDivideConfig%lowerOverlapFamily = units(1)
        case ( f_upperOverlap )
          ChunkDivideConfig%upperOverlap = value(1)
          ChunkDivideConfig%upperOverlapFamily = units(1)
        case ( f_noSlaves )
          ChunkDivideConfig%noSlaves = value(1)
        case ( f_homeModule )
          ChunkDivideConfig%homeModule = decoration ( gson )
          !instrumentModule = decoration(decoration(subtree(2,son)))
          !call GetModuleName ( instrumentModule , instrumentModuleName )
          !ChunkDivideConfig%homeModule = instrumentModule
        case ( f_homeGeodAngle )
          ChunkDivideConfig%homeGeodAngle = value(1)
        case ( f_scanLowerLimit )
          if ( any ( units /= PHYQ_Dimensionless .and. units /= PHYQ_Length ) &
            & .or. .not. any ( units == PHYQ_Length ) ) &
            & call AnnounceError ( root, BadUnits, fieldIndex )
          ChunkDivideConfig%scanLowerLimit = value
          ChunkDivideConfig%scanLLSet = .true.
        case ( f_scanUpperLimit )
          if ( any ( units /= PHYQ_Dimensionless .and. units /= PHYQ_Length ) &
            & .or. .not. any ( units == PHYQ_Length ) ) &
            & call AnnounceError ( root, BadUnits, fieldIndex )
          ChunkDivideConfig%scanUpperLimit = value
          ChunkDivideConfig%scanULSet = .true.
        case ( f_criticalBands )
          call get_string ( sub_rosa ( gson ), &
              & ChunkDivideConfig%criticalBands, strip=.true. )
          call output ( 'reading critical bands ' )
          call output ( trim(ChunkDivideConfig%criticalBands), advance='yes' )
        case ( f_criticalModules )
          ChunkDivideConfig%criticalModules = decoration ( gson )
        case ( f_criticalSignals )
          signalsNode = son
          numCriticalSignals = nsons(signalsNode) - 1
          call allocate_test(ChunkDivideConfig%criticalSignals, numCriticalSignals, &
            & 'critical signals', ModuleName)
          do j = 2, nsons(signalsNode)    ! Skip name
            call get_string ( sub_rosa ( subtree (j, signalsNode) ), &
              & ChunkDivideConfig%criticalSignals(j-1), strip=.true. )
          end do
        case ( f_excludePostOverlaps )
          ChunkDivideConfig%allowPostOverlaps = .not. log_value ! log_value
          if ( .not. ChunkDivideConfig%allowPostOverlaps ) &
            & call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'You have elected to exclude MAFs after time range' )
        case ( f_excludePriorOverlaps )
          ChunkDivideConfig%allowPriorOverlaps = .not. log_value ! log_value
          if ( .not. ChunkDivideConfig%allowPriorOverlaps ) &
            & call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'You have elected to exclude MAFs prior to time range' )
        case ( f_maxGap )
          ChunkDivideConfig%maxGap = value(1)
          ChunkDivideConfig%maxGapFamily = units(1)
        case ( f_skipL1BCheck )
          ! print *, 'processing f_skipL1BCheck ', log_value
          ChunkDivideConfig%skipL1BCheck = log_value ! log_value
          if ( ChunkDivideConfig%skipL1BCheck ) &
            & call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'You have elected to skip checking the l1b data for problems' )
        case ( f_crashIfPhiNotMono )
          ChunkDivideConfig%crashIfPhiNotMono = log_value ! log_value
          if ( ChunkDivideConfig%crashIfPhiNotMono ) &
            & call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'You have elected to crash if phi, the master geodetic angle, is' // &
            & ' not monotonic' )
        case ( f_saveObstructions )
          ChunkDivideConfig%saveObstructions = log_value ! log_value
          if ( ChunkDivideConfig%saveObstructions ) &
            & call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'You have elected to save obstructions (possibly for Output_Close)' )
        end select
        call trace_end ( 'ChunkDivideL2CF.loop', &
          & cond=toggle(gen) .and. levels(gen) > 1 )
      end do

      ! Now check the sanity of what we've been given, this varies a bit
      ! depending on the method
      if ( ChunkDivideConfig%skipL1BCheck .and. &
        & ChunkDivideConfig%crashIfPhiNotMono ) &
        & call MLSMessage(MLSMSG_Error, ModuleName, &
            & 'How can we check if phi, the master geodetic angle, is' // &
            & ' not monotonic when we skip checking the l1B file?' )
      select case ( ChunkDivideConfig%method )
      case ( l_fixed )
        needed => NeededForFixed
        notWanted => NotWantedForFixed
        ! We made NoChunks an optional parameter instead of a required one
        ! So if it's not present, the default value, 0, will be
        ! replaced with the number of MAFs in the level 1 files
        ! If that's not what you want, then you had better overide the default
        ! 0 with the actual number
        if ( ChunkDivideConfig%NoChunks < 1 ) &
          & ChunkDivideConfig%NoChunks = 1 + &
          & (GlobalAttributes%LastMAFCtr - GlobalAttributes%FirstMAFCtr) / &
          & ChunkDivideConfig%maxLength
      case ( l_polygon )
        needed => NeededForFixed
        notWanted => NotWantedForFixed
      case ( l_PE )
        needed => NeededForPE
        notWanted => NotWantedForPE
      case ( l_orbital )
        needed => NeededForOrbital
        notWanted => NotWantedForOrbital
      case ( l_even )
        needed => NeededForEven
        notWanted => NotWantedForEven
      end select

      ! Some special thought for overlap cases
      if ( any ( got ( (/ f_lowerOverlap, f_upperOverlap /) ) ) ) then
        if ( .not. all ( got ( (/ f_lowerOverlap, f_upperOverlap /) ) ) ) &
          & call AnnounceError ( root, notSpecified, &
          & FindFirst ( .not. got ( (/ f_lowerOverlap, f_upperOverlap /) ) ) )
        if ( got ( f_overlap ) ) &
          & call AnnounceError ( root, unnecessary, f_overlap )
        got ( f_overlap ) = .true.
        ! Insist that upper/lower overlaps be specified in the same units
        if ( ChunkDivideConfig%lowerOverlapFamily /= ChunkDivideConfig%upperOverlapFamily ) &
          & call AnnounceError ( root, badUnits, f_upperOverlap )
      else
        ! If single overlap specified, copy it into upper/lower
        if ( got ( f_overlap ) ) then
          ChunkDivideConfig%lowerOverlap = ChunkDivideConfig%overlap
          ChunkDivideConfig%lowerOverlapFamily = ChunkDivideConfig%overlapFamily
          ChunkDivideConfig%upperOverlap = ChunkDivideConfig%overlap
          ChunkDivideConfig%upperOverlapFamily = ChunkDivideConfig%overlapFamily
        end if
      end if

      ! Check we've got all the arguments we need
      do i = 1, size(needed)
        if ( .not. got(needed(i) ) ) &
          & call AnnounceError ( root, notSpecified, needed(i) )
      end do
      ! Check we don't have unnecessary ones
      do i = 1, size(notWanted)
        if ( got(notWanted(i) ) ) &
          & call AnnounceError ( root, unnecessary, notWanted(i) )
      end do

      ! Make other checks of parameters
      if ( ChunkDivideConfig%criticalModules /= l_none ) then
        if ( .not. got(f_scanLowerLimit) ) &
          & call AnnounceError ( root, notSpecified, f_scanLowerLimit )
        if ( .not. got (f_scanUpperLimit) ) &
          & call AnnounceError ( root, notSpecified, f_scanUpperLimit )
      else
        if ( got(f_scanLowerLimit) ) &
          & call AnnounceError ( root, unnecessary, f_scanLowerLimit )
        if ( got (f_scanUpperLimit) ) &
          & call AnnounceError ( root, unnecessary, f_scanUpperLimit )
      end if

      ! Now check the units for various cases
      if ( got(f_maxgap) .and. all ( ChunkDivideConfig%maxGapFamily /= &
        & (/ PHYQ_MAFs, PHYQ_Angle, PHYQ_Time /))) &
        & call AnnounceError ( root, badUnits, f_maxGap )
      select case ( ChunkDivideConfig%method )
      case ( l_PE )
        if ( ChunkDivideConfig%maxLengthFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_maxLength )
      case ( l_orbital )
        if (all(ChunkDivideConfig%maxLengthFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
          & call AnnounceError ( root, badUnits, f_maxLength )
        if (all(ChunkDivideConfig%lowerOverlapFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
          & call AnnounceError ( root, badUnits, f_lowerOverlap )
        if (all(ChunkDivideConfig%upperOverlapFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
          & call AnnounceError ( root, badUnits, f_upperOverlap )
      case ( l_fixed, l_even )
        if ( ChunkDivideConfig%maxLengthFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_maxLength )
        if ( ChunkDivideConfig%lowerOverlapFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_lowerOverlap )
        if ( ChunkDivideConfig%upperOverlapFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_upperOverlap )
      end select

      if ( error /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Problem with ChunkDivide command' )

      ! That's it, we're all valid now.
      call trace_end ( 'ChunkDivideL2CF', &
        & cond=toggle(gen) .and. levels(gen) > 0 )

    end subroutine ChunkDivideL2CF

    ! ---------------------------------------------------- SayTime -----
    subroutine SayTime
      real :: T2
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      endif
      call output ( 'Timing for ChunkDivide = ' )
      call output ( dble(t2-t1), advance='yes' )
      timing = .false.
    end subroutine SayTime

    ! ---------------------------------------------------- CheckChunkSanity -----
    subroutine CheckChunkSanity ( chunks, mafRange )
      type (MLSChunk_T), dimension(:), intent(inout) :: CHUNKS
      integer, dimension(2), intent(in) :: MAFRANGE   ! Processing range in MAFs

      ! Local variables
      integer :: i
      logical :: sharing, outrange, negovlps

      ! Executable statements
      sharing = .false.
      outrange = .false.
      negovlps = .false.
      if ( CHECKFORSHAREDMAFS ) then
        do i = 1, size(chunks) - 1
          sharing = (chunks(i)%lastMAFIndex - chunks(i)%noMAFsUpperOverlap) >= &
            & chunks(i+1)%firstMAFIndex + chunks(i+1)%noMAFsLowerOverlap
          if ( sharing ) exit
        enddo
      endif
      outrange = any(chunks%firstMAFIndex < mafrange(1)) .or. &
        &        any(chunks%lastMAFIndex > mafrange(2))
      negovlps = any(chunks%noMAFsLowerOverlap < 0) .or. &
        &        any(chunks%noMAFsUpperOverlap < 0)
      if ( sharing ) then
        call output ( "Shared non-overlaps MAFs detected ", advance='yes' )
        call output ( "(Either tweak ChunkDivide section or get someone " )
        call output ( " to fix the code) ", advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Shared non-overlapped MAFs' )
      elseif ( outrange ) then
        call output ( " MAFs detected outside range: " )
        call output ( mafRange, advance='yes' )
        call output ( "(Either tweak ChunkDivide section or get someone " )
        call output ( " to fix the code) ", advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'MAFs outside range' )
      elseif ( negovlps ) then
        call output ( "Negative overlaps detected ", advance='yes' )
        call output ( "(Either tweak ChunkDivide section or get someone " )
        call output ( " to fix the code) ", advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Negative overlaps' )
      endif
    end subroutine CheckChunkSanity
  end subroutine ChunkDivide

  ! -------------------------------------------- Dump Obstructions -----
  subroutine Dump_Obstructions ( obstructions )

    use Output_M, only: OUTPUT

    type (Obstruction_T), dimension(:), pointer :: obstructions
    ! Local variables
    integer :: i                        ! Loop counter
    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    if ( associated ( obstructions ) ) then
      if ( size(obstructions) == 0 ) then
        call output ( 'Obstructions is a zero size array.', advance='yes' )
      else
        call output ( 'Dumping ' )
        call output ( size(obstructions) )
        call output ( ' obstructions:', advance='yes' )
        do i = 1, size(obstructions)
          call output ( i )
          if ( obstructions(i)%range ) then
            call output ( ' : Range [ ' )
            call output ( obstructions(i)%mafs(1) )
            call output ( ' : ' )
            call output ( obstructions(i)%mafs(2) )
            call output ( ' ]', advance='yes' )
          else
            call output ( ' : Wall [ ' )
            call output ( obstructions(i)%mafs(1) )
            call output ( ' ]', advance='yes' )
          end if
        end do
      end if
    else
      call output ( 'Obstructions is not associated.', advance='yes')
    end if
  end subroutine Dump_Obstructions

! -----------------------------------------------  ANY_GOOD_SIGNALDATA  -----
  function ANY_GOOD_SIGNALDATA ( signal, sideband, filedatabase, maf, maf2, &
    & good_buffer, mafRange )  &
    & result (answer)
  ! Scalar use:
  ! Read precision of signal
  ! if all values < 0.0, return FALSE
  ! if no precision data in file, return FALSE
  ! otherwise return true
  !
  ! Array use
  ! Return one logical value in good_buffer
  ! for each of the_mafs between maf and maf2
  ! Arguments

    use MLSKinds, only: Rk => R8
    use MLSSignals_m, only: GetSignalName

    integer, intent(in)                            :: signal
    integer, intent(in)                            :: sideband
    logical                                        :: answer
    integer, intent(in)                            :: maf
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    integer, optional, intent(in)                  :: maf2
    logical, dimension(:), optional, intent(inout) :: good_buffer
    integer, dimension(2), optional, intent(in)    :: MAFRANGE   ! Processing
    ! Private                                                   range in MAFs
    integer :: flag
    type(MLSFile_T), pointer :: L1BFile
    integer :: maf_index   ! 1 <= maf_index <= mafrange(2)-mafrange(1)+1
    type (l1bData_T) :: MY_L1BDATA
    integer :: mymaf2
    character(len=127)  :: namestring
    integer :: noMAFs
    integer :: the_maf

    ! Executable
    swlevel = switchDetail(switches, 'chu' )
    answer = .false.
    mymaf2 = maf
    if ( present(maf2) ) mymaf2 = maf2

    ! Set defaults for the good_buffer if present
    if ( present(good_buffer) ) then
      if ( .not. present(mafrange) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'mafRange must be supplied to any_good_signaldata' )
      endif
      good_buffer ( maf - mafRange(1) + 1 : myMAF2 - mafRange(1) + 1 ) = .false.
    end if

    ! OK, try to find this item in an l1brad file
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) return
    call GetSignalName ( signal, nameString, &
      & sideband=sideband, noChannels=.TRUE. )
    nameString = AssembleL1BQtyName ( nameString, L1BFile%hdfVersion, .false. )
    nameString = trim(nameString) // PRECISIONSUFFIX
    ! fileID = FindL1BData (filedatabase, nameString, hdfVersion )
    L1BFile => GetL1bFile(filedatabase, namestring)
    ! If not found, exit appropriately
    if ( .not. associated(L1BFile) ) then
      answer = .false.
      return
    end if

    ! OK, we've found it.  Read the data in.
    call ReadL1BData ( L1BFile, nameString, my_l1bData, noMAFs, flag, &
      & firstMAF=maf, lastMAF=mymaf2, &
      & NeverFail= .true., dontPad = .false. )
    ! Quit if the reading failed.
    if ( flag /= 0 ) then
      answer = .false.
      return
    end if

    ! Give detailed or curt response
    if ( present(good_buffer) ) then
      answer = .true.    ! This value should be ignored by the caller
      do the_maf = maf, mymaf2
        maf_index = the_maf - mafRange(1) + 1
        good_buffer(maf_index) = .not. &
          & all (my_l1bData%DpField(:,:, the_maf+1-maf) < 0.0_rk)
      end do
    else
      answer = .not. all (my_l1bData%DpField < 0._rk)
    end if
    call DeallocateL1bData ( my_l1bData )

  end function ANY_GOOD_SIGNALDATA

  logical function isNotACriticalBand( band )
    use MLSStringLists, only: NumStringElements, StringElement
    use MLSStrings, only: ReadIntsFromChars
    ! Args
    integer, intent(in) :: band
    ! Internal variables
    logical, parameter :: countEmpty = .true.
    integer :: i
    integer :: n
    ! Executable
    isNotACriticalBand = .true.
    do i=1, NumStringElements( trim(ChunkDivideConfig%criticalBands), countEmpty )
      call readIntsFromChars( trim(&
        & StringElement( ChunkDivideConfig%criticalBands, i, countEmpty ) &
        & ), n, ignore='*' )
      isNotACriticalBand = isNotACriticalBand .and. (band /= n)
    enddo
  end function isNotACriticalBand

  subroutine smoothOutDroppedMAFs(field, wasSmoothed, monotonize)
    ! detect any fillValues--replace them with nearest neighbor values
    ! or, optionally, detect and correct any departures from monotone growth
    use MLSFillValues, only: IsFillValue
    ! Args
    real(r8), intent(inout)                      :: field(:,:,:)
    logical, dimension(:), optional, intent(out) :: wasSmoothed
    logical, optional, intent(in)                :: monotonize
    ! Internal variables
    integer :: maf, nearest
    logical :: myMonotonize
    real(r8):: lastValue
    ! Executable
    swlevel = switchDetail(switches, 'chu' )
    myMonotonize = .false.
    if ( present(monotonize) ) mymonotonize = monotonize
    if ( present(wasSmoothed) ) wasSmoothed = .false.
    lastValue = field(1,1,1)
    do maf=1, size(field, 3)
      if ( myMonotonize ) then
        nearest = max(maf-1, 1)
        if ( field(1,1,maf) < lastValue ) then
          if ( present(wasSmoothed) ) wasSmoothed(maf) = .true.
          field(:,:,maf) = field(:,:,nearest)
        else
          lastValue = field(1,1,maf)
        endif
      elseif ( any( isFillValue(field(:,:,maf)) ) ) then
        if ( present(wasSmoothed) ) wasSmoothed(maf) = .true.
        if ( maf == 1 ) then
          nearest = findfirst(.not. isFillValue(field(1,1,:)) )
        else
          nearest = maf - 1
        endif
        field(:,:,maf) = field(:,:,nearest)
      endif
    enddo
  end subroutine smoothOutDroppedMAFs

  ! ----------------------------------------- DealWithObstructions -----
  subroutine DealWithObstructions ( chunks, obstructions )
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS
    type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
    ! This routine modifies the chunks according to the information
    ! given in the obstructions.

    ! Local variables
    type (MLSChunk_T) :: NEWCHUNK       ! A chunk to create
    integer :: CHUNK                    ! Index of chunk under some consideration
    integer :: DEADCHUNK                ! Index of chunk to kill
    integer :: FIRSTMAF                 ! Index of first MAF in range
    integer :: LASTMAF                  ! Index of last MAF in range
    integer :: MAF                      ! Index of MAF for wall
    integer :: OBSTRUCTION              ! Loop counter

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )

    do obstruction = 1, size ( obstructions )
      ! Find chunk where this obstruction is/starts
      if ( obstructions(obstruction)%range ) then
        ! A range obstruction

        ! first identify the chunks whose non overlapped portion falls completely
        ! within the range and delete them
        firstMAF = obstructions(obstruction)%mafs(1)
        lastMAF = obstructions(obstruction)%mafs(2)
        insideRange: do
          deadChunk = FindFirst ( &
            & chunks%firstMAFIndex + chunks%noMAFsLowerOverlap >= firstMAF .and. &
            & chunks%lastMAFIndex - chunks%noMAFsUpperOverlap <= lastMAF )
          if ( deadChunk == 0 ) exit insideRange
          call DeleteChunk ( chunks, deadChunk )
        end do insideRange

        ! Now think about chunks whose non overlapped part completely
        ! encompass the range, and split them.
        ! (we'll deal with the issue of ranges spilling into overlap regions below)
        chunk = FindFirst ( &
          & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap <= firstMAF ) .and. &
          & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap >= lastMAF ) )
        if ( chunk /= 0 ) then
          ! Create two new chunks with the wall between, first the lower portion
          newChunk = chunks ( chunk )
          newChunk%lastMAFIndex = firstMAF - 1
          newChunk%noMAFsUpperOverlap = 0
          if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
            & call AddChunkToDatabase ( chunks, newChunk )
          ! Now the upper portion
          newChunk = chunks ( chunk )
          newChunk%firstMAFIndex = lastMAF + 1
          newChunk%noMAFsLowerOverlap = 0
          if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
            & call AddChunkToDatabase ( chunks, newChunk )
          ! Delete the old chunk
          call DeleteChunk ( chunks, chunk )
        endif

        ! So the cases we have left do not involve deleting or creating new
        ! chunks, just modifying existing ones.  Note that this includes
        ! cases where a range starts end ends in a chunk but one or other boundary
        ! is in the overlap regions.

        ! Look for chunks where the range starts in the chunk
        moveEnd: do
          chunk = FindFirst ( &
            & chunks%firstMAFIndex <= firstMAF .and. &
            & chunks%lastMAFIndex >= firstMAF )
          if ( chunk == 0 ) exit moveEnd
          chunks(chunk)%noMAFsUpperOverlap = max ( 0, &
            & chunks(chunk)%noMAFsUpperOverlap - &
            &    ( chunks(chunk)%lastMAFIndex - (firstMAF-1) ) )
          chunks(chunk)%lastMAFIndex = firstMAF - 1
        end do moveEnd

        ! Look for chunks where the range ends in the chunk
        moveStart: do
          chunk = FindFirst ( &
            & chunks%firstMAFIndex <= lastMAF .and. &
            & chunks%lastMAFIndex >= lastMAF )
          if ( chunk == 0 ) exit moveStart
          chunks(chunk)%noMAFsLowerOverlap = max ( 0, &
            & chunks(chunk)%noMAFsLowerOverlap - &
            &    ( (lastMAF+1) - chunks(chunk)%firstMafIndex ) )
          chunks(chunk)%firstMAFIndex = lastMAF + 1
        end do moveStart

      else ! - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        ! A wall obstruction
        maf = obstructions(obstruction)%mafs(1)

        ! First look for where the wall occurs in the non overlapped part
        chunk = FindFirst ( &
          & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap <= maf ) .and. &
          & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap >= maf ) )

        if ( chunk /= 0 ) then
          ! Create two new chunks with the wall between, first the lower portion
          newChunk = chunks ( chunk )
          newChunk%lastMAFIndex = maf - 1
          newChunk%noMAFsUpperOverlap = 0
          if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
            & call AddChunkToDatabase ( chunks, newChunk )
          ! Now the upper portion
          newChunk = chunks ( chunk )
          newChunk%firstMAFIndex = maf
          newChunk%noMAFsLowerOverlap = 0
          if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
            & call AddChunkToDatabase ( chunks, newChunk )
          ! Now delete the original chunk
          call DeleteChunk ( chunks, chunk )
        endif

        ! For chunks where the wall is in the overlap, just make the
        ! overlap shorter
        ! First the lower overlap
        wallInLower: do
          chunk = FindFirst ( &
            & ( chunks%firstMAFIndex < maf ) .and. &
            & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap > maf ) )
          if ( chunk == 0 ) exit wallInLower
          chunks(chunk)%noMAFsLowerOverlap = &
          & max ( chunks(chunk)%noMAFsLowerOverlap - &
          & ( maf - chunks(chunk)%firstMAFIndex ), 0 )
          chunks(chunk)%firstMAFIndex = maf
        end do wallInLower
        ! Now the upper overlap
        wallInUpper: do
          chunk = FindFirst ( &
            & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap < maf ) .and. &
            & ( chunks%lastMAFIndex > maf ) )
          if ( chunk == 0 ) exit wallInUpper
          chunks(chunk)%noMAFsUpperOverlap = &
            & max ( chunks(chunk)%noMAFsUpperOverlap - &
            & ( chunks(chunk)%lastMAFIndex - (maf-1) ), 0 )
          chunks(chunk)%lastMAFIndex = maf - 1
        end do wallInUpper
      end if  ! - - - - - - - - - - - - ! Wall obstructions

    end do                              ! Loop over obstructions

    ! Sort the chunks back into order
    call SortChunks ( chunks )

  end subroutine DealWithObstructions

  ! --------------------------------------------- SortObstructions -----
  subroutine SortObstructions ( obstructions )
    ! Sort the obstructions into order of increasing
    ! mafs(1) (start/wall MAF index)
    type (Obstruction_T), dimension(:), intent(inout) :: OBSTRUCTIONS

    ! Local variables
    type (Obstruction_T) :: TEMP
    integer :: I                        ! Loop counters
    integer, dimension(1) :: TOSWAP     ! Index

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    do i = 1, size(obstructions) - 1
      toSwap = minloc ( obstructions(i:)%mafs(1) ) + (/ i-1 /)
      if ( toSwap(1) /= i ) then
        temp = obstructions(i)
        obstructions(i) = obstructions(toSwap(1))
        obstructions(toSwap(1)) = temp
      end if
    end do
  end subroutine SortObstructions

  ! -------------------------------------------- DeleteObstruction -----
  subroutine DeleteObstruction ( obstructions, index )
    ! Dummy arguments
    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type (Obstruction_T), pointer, dimension(:) :: OBSTRUCTIONS
    integer, intent(in) :: INDEX

    ! Local variables
    type (Obstruction_T), pointer, dimension(:) :: TEMP
    integer(c_intptr_t) :: Addr    ! For tracing
    integer :: S                   ! Size in bytes of object to deallocate
    integer :: STATUS              ! From allocate

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    allocate ( temp ( size(obstructions) - 1 ), stat=status )
    addr = 0
    if ( status == 0 .and. size(obstructions) > 0 ) addr = transfer(c_loc(temp(1)), addr )
    call test_allocate ( status, ModuleName, 'temp', &
      & uBounds = size(obstructions) - 1, &
      & elementSize = storage_size(temp) / 8, address=addr )

    if ( index > 1 ) temp(1:index-1) = obstructions(1:index-1)
    if ( index < size(obstructions) .and. size(obstructions) > 1 ) &
      & temp(index:) = obstructions(index+1:)

    s = size(obstructions) * storage_size(obstructions) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(obstructions(1)), addr )
    deallocate ( obstructions, stat=status )
    call test_deallocate ( status, moduleName, 'obstructions', s, address=addr )

    obstructions => temp

  end subroutine DeleteObstruction

  ! ---------------------------------------- ChooseCriticalSignals -----
  subroutine ChooseCriticalSignals ( criticalSignals )
    use MLSSignals_m, only: Dump_Signals, GetSignalName, Signals
    use MLSStringLists, only: CatLists, List2Array
    use MLSStrings, only: Lowercase

    ! Args
    character(len=160), dimension(:), pointer :: criticalSignals
    ! Internal variables
    character(len=40) :: critical_module_str
    integer, parameter :: MAXCRITICALSIGNALLENGTH = 40000
    character(len=MAXCRITICALSIGNALLENGTH) :: criticalSignalStr
    character(len=40) :: module_str
    integer :: numCriticalSignals
    character(len=40) :: signal_full
    integer :: signalIndex
    logical, dimension(:), pointer :: isSignalcritical => null()
    ! Executable
    swlevel = switchDetail(switches, 'chu' )
    if ( ChunkDivideConfig%criticalModules == l_none .and. &
      & len_trim(ChunkDivideConfig%criticalBands) < 1 ) return
    critical_module_str = ' '
    if ( ChunkDivideConfig%criticalModules /= l_none ) then
      call get_string( lit_indices(ChunkDivideConfig%criticalModules), signal_full, &
        & strip=.true. )
      critical_module_str = lowercase(signal_full)
      if ( critical_module_str /= 'ghz' ) return
    endif
    criticalSignalStr = ' '
    numCriticalSignals = 0
    if ( swLevel > -1 ) &
      & call outputNamedValue( 'critical module', critical_module_str )
    if ( swLevel > -1 ) &
      & call outputNamedValue( 'critical bands', ChunkDivideConfig%criticalBands )
    if ( swLevel > -1 ) &
      & call outputNamedValue( 'size(signals)', size(signals) )
    call allocate_test( isSignalCritical, size(signals), 'isSignalCritical', &
      & ModuleName )
    do signalIndex=1, size(signals)
      isSignalCritical(signalIndex) = &
        & .not. isNotACriticalBand( signals(signalIndex)%Band )
      if ( swLevel > -1 .and. .false. ) then
        call outputNamedValue( 'signal index', signalIndex )
        call GetSignalName( signalIndex, signal_full )
        call outputNamedValue( 'signal', signal_full )
        call outputNamedValue( 'band', signals(signalIndex)%Band )
        call outputNamedValue( 'critical?', &
          & .not. isNotACriticalBand( signals(signalIndex)%Band ) )
        call get_string( modules(signals(signalIndex)%instrumentModule)%name, &
          &  module_str, strip=.true. )
        call outputNamedValue( 'module', module_str )
      endif
      if ( len_trim(ChunkDivideConfig%criticalBands) > 0 ) then
        ! See if the band is one of the critical bands
        if ( isNotACriticalBand( signals(signalIndex)%Band ) ) cycle
      elseif ( len_trim(critical_module_str) > 0 ) then
        call get_string( modules(signals(signalIndex)%instrumentModule)%name, &
          & signal_full, strip=.true. )
        module_str = lowercase(signal_full)
        if ( module_str /= critical_module_str ) cycle
      endif
      numCriticalSignals = numCriticalSignals + 1
      call GetSignalName( signalIndex, signal_full )
      criticalSignalStr = catLists( criticalSignalStr, signal_full )
    enddo
    if ( swLevel > -1 ) &
      call Dump_Signals( signals, isSignalCritical, 1 )
    call deallocate_test( isSignalCritical,'isSignalCritical', &
      & ModuleName )
    if ( numCriticalSignals < 1 ) return
    call allocate_test( criticalSignals, numCriticalSignals, 'criticalSignals', &
      & ModuleName )
    call List2Array (criticalSignalStr, criticalSignals,  countEmpty=.true. )
    if ( swLevel > -1 ) &
      & call dump( criticalSignals, 'critical Signals chosen', &
      & options=what_options(trim=.true.) )
  end subroutine ChooseCriticalSignals

  ! -------------------------------------------- NoteL1BRADChanges -----
  subroutine NoteL1BRADChanges ( obstructions, mafRange, filedatabase )
    use MLSSignals_M, only: Dumpsignals=>dump, Getsignalindex, Getsignalname, &
      & GetNameofsignal, Signals
    use MLSStringlists, only: NumstringElements, GetstringElement
    use MLSStrings, only: Lowercase
    use Parse_Signal_M, only: Parse_Signal
    ! This routine notes any lack of good data for one of the
    ! signals, and, depending on sensitivity,
    ! augments the database of obstructions
    type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
    type (Obstruction_T) :: NEWOBSTRUCTION ! In progrss
    type (MAFRange_T) :: MAFRange
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE

    ! Local variables
    ! This next sets the threshold of what it takes to be an obstruction
    ! At the most sensitive, hair-trigger level, any change in goodness
    ! of any signal would suffice
    ! Otherwise, a dead-zone in any signal must persist for at least a
    ! duration of config%maxGap before we declare it an obstruction
    ! and add it to the database
    logical, parameter :: ANYCHANGEISOBSTRUCTION = .false.
    logical :: choseCriticalSignals
    integer :: critical_index
    character(len=40) :: critical_module_str
    integer, dimension(:), pointer            :: criticalIndices => null() ! taken from config or criticalModules
    character(len=160), dimension(:), pointer :: criticalSignals => null() ! taken from config or criticalModules
    integer :: critical_sub_index
    integer, pointer, dimension(:) :: goods_after_gap
    integer, pointer, dimension(:) :: goodness_changes
    logical, dimension(size(signals)) :: good_after_maxgap
    logical, dimension(size(signals)) :: good_signals_now
    logical, dimension(size(signals)) :: good_signals_last
    integer, dimension(size(signals)) :: howlong_nogood
    integer :: i
    integer :: maf              ! mafrange(1) <= maf <= mafrange(2)
    integer :: maf_index   ! 1 <= maf_index <= mafrange(2)-mafrange(1)+1
    integer :: mafset
    integer :: mafset_end
    integer :: mafset_start
    integer, parameter :: MAXMAFSINSET = 250
    character(len=40) :: module_str
    integer :: nmafs
    integer :: nmafsets
    integer :: num_goods_after_gap
    integer :: num_goodness_changes
    logical, dimension(:), pointer  :: or_valids_buffer
    integer :: SignalIndex
    character(len=40) :: signal_full
    character(len=40) :: signal_str
    integer, pointer :: Signal_Indices(:)         ! Indices in the signals
    logical, dimension(:,:), pointer  :: signals_buffer
    logical :: this_maf_valid
    logical, dimension(:), pointer  :: valids_buffer
    ! Won't check if there are no files at all
    if ( .not. associated(filedatabase) ) return
    ! Won't check if there are no radiance files
    if ( .not. any(filedatabase%content == 'l1brad') ) return
    swlevel = SwitchDetail(switches, 'chu')
    nmafs = mafRange%Expanded(2) - mafRange%Expanded(1) + 1
    choseCriticalSignals = .false.
    ! Here we will loop over the signals database
    ! Searching for
    ! (1) mafs where there is no good data for any of the signals
    ! (2) mafs where the good data is switched from one signal to another
    ! (See Construct QuantityTemplates below line 253)

    ! (Possibly) time-consuming step:
    ! Read through the l1b radiance files for all signals,
    ! noting which ones are good, which not

    nullify ( signals_buffer, goods_after_gap, goodness_changes )
    call allocate_test( &
      & signals_buffer, nmafs , size(signals), &
      & 'signals_buffer', ModuleName )
    call allocate_test( goods_after_gap, nmafs,&
      & 'goods_after_gap', ModuleName )
    call allocate_test( goodness_changes, nmafs,&
      & 'goodness_changes', ModuleName )
    good_signals_now = .false.   ! Initializing
    signals_buffer = .false.
    if ( swLevel > -1 ) then
      call outputNamedValue ( 'shape(signals_buffer)', shape(signals_buffer) )
      call outputNamedValue ( 'shape(goods_after_gap)', shape(goods_after_gap) )
      call outputNamedValue ( 'shape(goodness_changes)', shape(goodness_changes) )
    endif
    if ( associated(ChunkDivideConfig%criticalSignals) ) then
      criticalSignals => ChunkDivideConfig%criticalSignals
      if ( swLevel > -1 ) then
        call output('Critical Signals from config', advance='yes' )
        call Dump (  criticalSignals )
      endif
    elseif ( ChunkDivideConfig%chooseCriticalSignals ) then
      ! We can choose as critical signals all the signals belonging
      ! to a critical module
      call chooseCriticalSignals( criticalSignals )
      choseCriticalSignals = .true.
      if ( swLevel > -1 ) then
        call Dump (  criticalSignals, 'Critical Signals you chose', &
          & options=what_options(trim=.true.) )
      endif
    endif
    ! We'll need the index number for each of the critical signals
    call allocate_test( criticalIndices, size(criticalSignals),&
      & 'critical indices', ModuleName )
    do critical_index = 1, size(criticalSignals)
      call GetSignalIndex( criticalSignals(critical_index), &
        & criticalIndices(critical_index) )
      if ( swLevel < VERBOSETHRESHOLD ) cycle
      call outputnamedValue( 'critical signal string', criticalSignals(critical_index) )
      call outputnamedValue( 'its index', criticalIndices(critical_index) )
    enddo
    if ( swLevel >= VERBOSETHRESHOLD ) then
      ! call dumpSignals( signals )
      call GetNameOfSignal ( signals(1), signal_str )
      call outputnamedValue( 'signal(1)%name', signal_str )
      call dump( criticalSignals, 'criticalSignals' )
      call dump( criticalIndices, 'criticalIndices' )
    endif
    do signalIndex=1, size(signals)
      call get_string( lit_indices(ChunkDivideConfig%criticalModules), &
        & signal_full, &
        & strip=.true. )
      critical_module_str = lowercase(signal_full)
      call get_string( modules(signals(signalIndex)%instrumentModule)%name, &
        & signal_full, &
        & strip=.true. )
      module_str = lowercase(signal_full)
      if ( swLevel >= VERBOSETHRESHOLD ) &
        & call outputNamedValue( 'module', module_str )
      if ( ChunkDivideConfig%criticalModules == l_none ) then
        ! No module is critical for signal data being good
      elseif ( module_str /= critical_module_str ) then
        cycle
      elseif ( .not. any(signalIndex == criticalIndices) ) then
        cycle
      endif
      if ( swLevel >= VERBOSETHRESHOLD ) &
        & call dumpSignals( signals(signalIndex) )
      if ( swLevel >= VERBOSETHRESHOLD ) &
        & call outputNamedValue( 'critical module', critical_module_str )
      if ( nmafs <= MAXMAFSINSET ) then
        good_signals_now(signalIndex) = &
          & any_good_signaldata ( signalIndex, signals(signalIndex)%sideband, &
          &   filedatabase, mafRange%Expanded(1), mafRange%Expanded(2), &
          &   signals_buffer(:,signalIndex), mafRange%Expanded )
      else
        nmafsets = (nmafs-1)/MAXMAFSINSET + 1   ! A trick--mafset_start
        mafset_end = mafRange%Expanded(1) - 1   ! is mafRange(1)
        do mafset=1, nmafsets
          mafset_start = mafset_end + 1
          mafset_end = min ( mafRange%Expanded(2), mafset_end + MAXMAFSINSET )
          good_signals_now(signalIndex) = &
            &   any_good_signaldata ( signalIndex, &
            &   signals(signalIndex)%sideband, &
            &   filedatabase, mafset_start, mafset_end, &
            &   signals_buffer(:,signalIndex), mafRange%Expanded )
        enddo
      endif
    enddo
    if ( swlevel > -1 ) &
      & call outputNamedValue ( 'shape(signals_buffer)', shape(signals_buffer) )
    if ( swlevel >= VERBOSETHRESHOLD ) &
      & call dump ( signals_buffer, 'signals_buffer' )

    ! Task (1a): Find mafs where there is at least one signal which
    ! changes from either nogood to good or from good to nogood
    ! compared with the last maf
    ! Task (1b): Find mafs where there is at least one signal which
    ! changes from nogood to good after a dead zone
    ! lasting at least maxGap mafs
    num_goodness_changes = 0
    num_goods_after_gap = 0
    howlong_nogood       = 0
    good_after_maxgap = .false.
    do maf = mafRange%Expanded(1), mafRange%Expanded(2)
      maf_index = maf - mafRange%Expanded(1) + 1
      do signalIndex=1, size(signals)
        if ( .not. any(signalIndex == criticalIndices) ) cycle
        good_signals_now(signalIndex) = signals_buffer(maf_index, signalIndex)
        if ( .not. good_signals_now(signalIndex) ) &
          & howlong_nogood(signalIndex) = howlong_nogood(signalIndex) + 1
        good_after_maxgap(signalIndex) = &
          & good_signals_now(signalIndex) &
          & .and. &
          & ( howlong_nogood(signalIndex) > ChunkDivideConfig%maxGap )
        if ( good_signals_now(signalIndex) ) howlong_nogood(signalIndex) = 0
      enddo
      if ( maf /= mafRange%Expanded(1) ) then
        if ( Any(good_signals_now .neqv. good_signals_last) ) then
          num_goodness_changes = num_goodness_changes + 1
          goodness_changes(num_goodness_changes) = maf
        endif
      endif
      if ( Any(good_after_maxgap) ) then
        num_goods_after_gap = num_goods_after_gap + 1
        goods_after_gap(num_goods_after_gap) = maf
      endif
      good_signals_last = good_signals_now
    enddo
    call outputNamedValue( 'num_goods_after_gap', num_goods_after_gap )

    ! Task (2): Find regions where there is no signal among at least one
    ! of the critical signals
    if ( associated(criticalSignals) ) then
      ! What we're about to do is:
      ! Assume we're given an array of char strings
      ! array = [str_1, str_2, ..]
      ! and each string contains comma-separated signals
      ! str_1 = 'sig_1,sig_2,..'
      ! Then the rule is that for a maf to pass the critical signals test,
      ! for each array element at least one of the signals within that
      ! string must be turned on for that maf
      ! Thus the shorthand formula that we're and-ing the array elements
      ! and or-ing the list elements
      ! You might prefer the formula that a maf is invalid if for any of the
      ! array elements, none of its signals is turned on
      !
      ! Unfortunately, if we chose our critical signals based on a critical module
      ! the role the string containing comma-separated signals is played by
      ! by the array so in that case we'll need to be or-ing the array elements,
      ! not and-ing them
      nullify ( valids_buffer )
      call allocate_test( &
        & valids_buffer, nmafs , &
        & 'valids_buffer', ModuleName)
      nullify ( or_valids_buffer )
      call allocate_test( &
        & or_valids_buffer, nmafs , &
        & 'or_valids_buffer', ModuleName)
      !
      valids_buffer = .not. choseCriticalSignals ! .true.
      if ( SwLevel >= VERBOSETHRESHOLD ) then
        call output ( 'Checking for critical signals: ')
        do critical_index=1, size(criticalSignals)
          call output ( trim(criticalSignals(critical_index)), &
            & advance='yes')
        enddo
        call output ( &
          & 'Which signals match the incomplete signal string ' &
          &  // 'weve been given', advance='yes')
      endif
      do critical_index=1, size(criticalSignals)
        or_valids_buffer = .false.
        do critical_sub_index=1, NumStringElements( &
          & trim(criticalSignals(critical_index)), .FALSE.)
          call GetStringElement( &
            & trim(criticalSignals(critical_index)), signal_str, &
            & critical_sub_index, .FALSE. )
          ! Which signals match the incomplete signal string we've been given?
          nullify(Signal_Indices)
          call Parse_signal(signal_str, signal_indices)
          if ( .not. associated(Signal_Indices) ) exit
          if ( SwLevel >= VERBOSETHRESHOLD ) then
            call output ( 'Signal_Indices: ')
            call output ( Signal_Indices, advance='yes')
            do i=1, size(Signal_Indices)
              call GetSignalName(Signal_Indices(i), signal_full)
              call output ( 'Full Signal Name: ')
              call output ( trim(signal_full), advance='yes')
            enddo
          endif
          do maf = mafRange%Expanded(1), mafRange%Expanded(2)
            maf_index = maf - mafRange%Expanded(1) + 1
            this_maf_valid = .false.   ! not valid unless at least one signal
            do i=1, size(Signal_Indices)
              signalIndex = Signal_Indices(i)
              this_maf_valid = &
                & this_maf_valid .or. signals_buffer(maf_index, signalIndex)
            enddo
            or_valids_buffer(maf_index) = &
              & or_valids_buffer(maf_index) .or. this_maf_valid
          enddo
          call deallocate_test(Signal_Indices, 'Signal_Indices', ModuleName)
        enddo
        ! An ad-hoc filter to ignore bands that are simply switched off
        ! if ( swLevel > -1 ) call outputNamedValue ( 'count(or_valids_buffer)', count(or_valids_buffer), advance='yes')
        ! if ( count(or_valids_buffer) < &
        !  & ( mafRange%Expanded(2) - mafRange%Expanded(1) ) / 50 ) cycle
        ! call dump ( or_valids_buffer, 'or_valids_buffer' )
        if ( choseCriticalSignals ) then
          valids_buffer = &
            & valids_buffer .or. or_valids_buffer
        else
          valids_buffer = &
            & valids_buffer .and. or_valids_buffer
        endif
      enddo
      if ( swLevel >= VERBOSETHRESHOLD ) call dump ( valids_buffer, 'valids_buffer' )
      if ( swLevel > -1 ) then
        call outputNamedValue ( 'count(valids_buffer)', count(valids_buffer), advance='yes')
        call output ( 'Before converting valids to obstructions', advance='yes' )
        call dump(obstructions)
      endif
      call ConvertFlagsToObstructions ( valids_buffer, obstructions, &
        & mafRange%Expanded, obstructionType='critical radiances' )
      if ( swLevel > -1 ) then
        call output ( 'After converting valids to obstructions', advance='yes' )
        call dump(obstructions)
      endif
      call deallocate_test(valids_buffer, 'valids_buffer', ModuleName)
      call deallocate_test(or_valids_buffer, 'or_valids_buffer', ModuleName)
      if ( .not. associated(ChunkDivideConfig%criticalSignals) )  &
        & call deallocate_test( criticalSignals, 'criticalSignals', &
        & ModuleName )
    endif

    ! Depending on sensitivity, add these to Obstructions database
    if ( ANYCHANGEISOBSTRUCTION .and. num_goodness_changes > 0 ) then
      do mafset = 1, num_goodness_changes
        newObstruction%range = .false.
        newObstruction%mafs(1) = goodness_changes(mafset)
        newObstruction%mafs(2) = 0    ! For overzealous Lahey uninitialized checking
        call AddObstructionToDatabase ( obstructions, newObstruction )
        if ( swLevel > -1 ) &
          call outputNamedValue( &
          & 'maf where any change made obstruction', goodness_changes(mafset) )
      enddo
    elseif ( num_goods_after_gap > 0 ) then
      do mafset = 1, num_goods_after_gap
        newObstruction%range = .false.
        newObstruction%mafs(1) = goods_after_gap(mafset)
        newObstruction%mafs(2) = 0    ! For overzealous Lahey uninitialized checking
        call AddObstructionToDatabase ( obstructions, newObstruction )
        if ( swLevel > -1 ) &
          call outputNamedValue( &
          & 'maf where num goods after gap made obstruction', goods_after_gap(mafset) )
      enddo
    endif
    ! OK, we have the mafs where the goodness changes, now what?
    call deallocate_test( signals_buffer, 'signals_buffer', ModuleName )
    call deallocate_test( goods_after_gap, 'goods_after_gap', ModuleName )
    call deallocate_test( goodness_changes, 'goodness_changes', ModuleName )
    call deallocate_test( criticalIndices, 'critical indices', ModuleName )
  end subroutine NoteL1BRADChanges

  ! ----------------------------------- ConvertFlagsToObstructions -----
  subroutine ConvertFlagsToObstructions ( valid, obstructions, &
    & mafRange, obstructionType )
    ! This routine takes an array of logicals indicating good/bad data
    ! and converts it into obstruction information.
    logical, dimension(:), intent(in)           :: VALID
    type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
    integer, dimension(:), intent(in), optional :: MAFRANGE
    character(len=*), intent(in), optional      :: obstructionType

    ! Local variables
    logical :: LASTONEVALID           ! Flag
    integer :: MAF                    ! Loop counter
    type (Obstruction_T) :: NEWOBSTRUCTION ! In progrss
    character(len=64)    :: obstructionTrigger
    integer :: OFFSET                 ! MAF index offset

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    lastOneValid = .true.
    offset = 0
    if ( present(mafRange) ) offset = mafRange(1)
    obstructionTrigger = &
      & 'maf where transition from bad to good made obstruction'
    if ( present(obstructionType) ) obstructionTrigger = &
      & 'maf where transition from bad to good ' // trim(obstructionType) // &
      & 'made obstruction'

    do maf = 1, size(valid)
      if ( valid(maf) .neqv. lastOneValid ) then
        ! A transition either from good to bad or bad to good
        if ( .not. valid(maf) ) then
          ! From good to bad
          newObstruction%range = .true.
          newObstruction%mafs(1) = maf - 1 + offset
        else
          newObstruction%mafs(2) = maf - 1 + offset
          call AddObstructionToDatabase ( obstructions, newObstruction )
          if ( swLevel > -1 ) &
            call outputNamedValue( &
            & trim(obstructionTrigger), maf )
        end if
      end if
      lastOneValid = valid(maf)
    end do
    ! Check that the two mafs after the obstruction end are valid
!     maf = newObstruction%mafs(2) + 1
!     if ( maf <= size(valid) ) then
!       if ( .not. valid(maf) ) print *, 'Warning not valid at maf ', maf
!       newObstruction%mafs(2) = newObstruction%mafs(2) + 1
!     endif
!     maf = newObstruction%mafs(2) + 1
!     if ( maf <= size(valid) ) then
!       if ( .not. valid(maf) ) print *, 'Warning not valid at maf ', maf
!       newObstruction%mafs(2) = newObstruction%mafs(2) + 1
!     endif

    ! Make sure any range at the end gets added
    if ( .not. lastOneValid ) then
      newObstruction%mafs(2) = size(valid) - 1 + offset
      call AddObstructionToDatabase ( obstructions, newObstruction )
      if ( swLevel > -1 ) &
        call outputNamedValue( &
        & trim(obstructionTrigger), size(valid)-1 )
    end if
  end subroutine ConvertFlagsToObstructions

  ! ------------------------------------------------ SurveyL1BData -----
  subroutine SurveyL1BData ( processingRange, filedatabase, mafRange )
    ! This goes through the L1B o/a data file and tries to spot possible
    ! obstructions.
    ! If any breaks in valid data are revealed, they will be added to 
    ! the obsstructions database
    use Monotone, only: isMonotonic
    type (TAI93_Range_T), intent(in)        :: PROCESSINGRANGE
    type (MLSFile_T), dimension(:), pointer :: FILEDATABASE
    type (MAFRange_T), intent(out)          :: MAFRange

    ! Local variables
    ! The following 5 l1b data sets will be examined for possible breaks
    ! in valid data
    type (L1BData_T) :: SCVEL           ! Read from L1BOA file
    type (L1BData_T) :: TAITIME         ! Read from L1BOA file
    type (L1BData_T) :: TPGEODALT       ! Read from L1BOA file
    type (L1BData_T) :: TPGEODANGLE     ! Read from L1BOA file
    type (L1BData_T) :: TPORBY          ! Read from L1BOA file

    character(len=10) :: MODNAMESTR     ! Module name

    integer :: FLAG                     ! From L1B
    integer :: MAF                      ! Loop inductor
    integer :: MOD                      ! Loop inductor
    integer :: NOMAFS                   ! Number of MAFs in processing range
    integer :: NOMAFSREAD               ! From L1B

    logical :: THISONEVALID             ! To go into valid
    logical, dimension(:), pointer :: ANGLEWASSMOOTHED ! Flag for each MAF
    logical, dimension(:), pointer :: VALID ! Flag for each MAF
    logical, dimension(:), pointer :: WASSMOOTHED ! Flag for each MAF

    real(r8) :: ORBYMAX                 ! Maximum value of orbY each maf
    real(r8) :: SCANMAX                 ! Range of scan each maf
    real(r8) :: SCANMIN                 ! Range of scan each maf
    real(r8) :: SCVELMAX                ! Maximum value of abs(sc/VelECR)

    integer   ::                       l1b_hdf_version
    character(len=namelen) ::          MAF_start
    character(len=namelen) ::          sc_vel
    character(len=namelen) ::          tp_alt
    character(len=namelen) ::          tp_orbY
    character(len=namelen) ::          tp_angle
    type (MLSFile_T), pointer       :: L1BFile
    ! Executable code
    swlevel = switchDetail(switches, 'chu' )

    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) &
      & call MLSMessage  ( MLSMSG_Error, ModuleName, &
        & "Can't make progress in SurveyL1BData without L1BOA files" )
    if ( swLevel > -1 ) then
      call output( 'here is the L1BOA', advance='yes' )
      call dump( L1BFile )
    endif
    l1b_hdf_version = L1BFile%HDFVersion
    MAF_start = AssembleL1BQtyName ( 'MAFStartTimeTAI', l1b_hdf_version, &
      .false. )
    ! tp_angle = &
    !  & AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
    !  & l1b_hdf_version, &
    !  & .false. )
    ! Read time from the L1BOA file
    call ReadL1BData ( L1BFile, trim(MAF_start), taiTime, &
      & noMAFsRead, flag, &
      & dontPad=DONTPAD )
    call smoothOutDroppedMAFs(taiTime%dpField)

    ! We shall assume that all l1b files cover this range
    mafRange%L1BCover(1) = taiTime%FirstMAF
    mafRange%L1BCover(2) = taiTime%NoMAFs - 1 ! Because it starts with 0

    ! Deduce the first and last MAFs covered the L2 Processing Range
    call Hunt ( taiTime%dpField(1,1,:), &
      & (/ processingRange%startTime, processingRange%endTime /), &
      & mafRange%L2Cover, allowTopValue=.true., allowBelowValue=.true. )

    ! Check the validity of the MAF range returned
    if ( mafRange%L2Cover(1) == taiTime%noMAFs ) then
      call outputNamedValue ( 'processingRange', &
        & (/ processingRange%startTime, processingRange%endTime /) )
      call outputNamedValue ( 'noMAFsRead', noMAFsRead )
      call dump ( taiTime%dpField(1,1,:), 'MAF_start' )
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'L1B data ends before requested processing range' )
    endif
    if ( mafRange%L2Cover(1) == taiTime%noMAFs ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'L1B data ends before requested processing range' )
    mafRange%L2Cover = min ( noMAFsRead-1, max ( 0, mafRange%L2Cover - 1 ) )          ! Index from zero
    if ( mafRange%L2Cover(2) < mafRange%L2Cover(1) ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'L2 mafRange(2) < L2 mafRange(1)' )
    elseif ( mafRange%L2Cover(2) < 1 ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'L2 mafRange(2) < 1' )
    endif

    mafRange%Expanded(1) = mafRange%L2Cover(1)
    mafRange%Expanded(2) = mafRange%L2Cover(2)
    ! Expand the range covered by L2 with possible overlaps
    if ( ChunkDivideConfig%allowPriorOverlaps ) then
      mafRange%Expanded(1) = max( mafRange%L1BCover(1), &
        & mafRange%L2Cover(1) - nint(ChunkDivideConfig%lowerOverlap) )
    endif
    if ( ChunkDivideConfig%allowPostOverlaps ) then
      mafRange%Expanded(2) = min( mafRange%L1BCover(2), &
        & mafRange%L2Cover(2) + nint(ChunkDivideConfig%upperOverlap) )
    endif
    ! Why was this here? if ( sharedPCF ) return
    noMAFS = mafRange%Expanded(2) - mafRange%Expanded(1) + 1
    ! Now look through the L1B data, first look for scan problems
    if ( ChunkDivideConfig%criticalModules /= l_none ) then
      call outputNamedValue( 'Looking for scan problems; swLevel ', swlevel )
      nullify ( valid )
      nullify ( anglewasSmoothed )
      nullify ( wasSmoothed )
      call Allocate_test ( valid, noMAFs, 'valid', ModuleName )
      call Allocate_test ( anglewasSmoothed, noMAFs, 'angleWasSmoothed', ModuleName )
      call Allocate_test ( wasSmoothed, noMAFs, 'wasSmoothed', ModuleName )
      ! How to choose initial values for valid:
      ! It depends on whether we insist "both" modules are critical
      ! or not.
      ! In practice we will never insist.
      if ( ChunkDivideConfig%criticalModules == l_both ) then
        valid = .true.
      else
        valid = .false.
      endif
      do mod = 1, size(modules)
        call get_string ( modules(mod)%name, modNameStr, strip=.true. )
        sc_vel = 'sc/VelECR'
        tp_alt = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAlt', &
          & l1b_hdf_version, .false. )
        tp_orby = AssembleL1BQtyName ( trim(modNameStr)//'.tpOrbY', &
          & l1b_hdf_version, .false. )
        tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
          & l1b_hdf_version, .false. )
        if ( .not. modules(mod)%spacecraft .and. &
          & ( any ( ChunkDivideConfig%criticalModules == (/ l_either, l_both /) ) .or. &
          &   lit_indices(ChunkDivideConfig%criticalModules) == modules(mod)%name ) ) then
          ! Read the s/c velocity
          call ReadL1BData ( L1BFile, trim(sc_vel), &
            & scVel, noMAFsRead, flag, &
            & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
            & dontPad=DONTPAD )
          ! Read the tangent point altitude
          call ReadL1BData ( L1BFile, trim(tp_alt), &
            & tpGeodAlt, noMAFsRead, flag, &
            & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
            & dontPad=DONTPAD )
          ! Read the out of plane distance
          call ReadL1BData ( L1BFile, trim(tp_orby), &
            & tpOrbY, noMAFsRead, flag, &
            & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
            & dontPad=DONTPAD )
          call ReadL1BData ( L1BFile, trim(tp_angle), &
            & tpGeodAngle, noMAFsRead, flag, &
            & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
            & dontPad=DONTPAD )
          if ( .not. ChunkDivideConfig%skipL1BCheck ) then
            if ( .not. isMonotonic(tpGeodAngle%dpField(1,1,1:noMAFsRead) ) &
              & ) then
              call MLSMessage ( PhiNotMonotonicFun(), ModuleName, &
                & 'tpGeodAngle is not monotonic--may quit', MLSFile=L1BFile )
            endif
          endif
          ! For a reason forgotten in the fog of antiquity we, and mlsl2,
          ! smooth out discontinuities in the tp quantities if possible.
          call smoothOutDroppedMAFs(tpGeodAngle%dpField, angleWasSmoothed, &
            & monotonize=.true.)
          call smoothOutDroppedMAFs(tpGeodAlt%dpField, wasSmoothed)
          call smoothOutDroppedMAFs(tpOrbY%dpField)
          if ( swLevel > 1 ) then
            call dump( angleWasSmoothed, 'smoothed because of geodetic angle' )
            call dump( wasSmoothed, 'smoothed because of geodetic altitude' )
          endif
          wasSmoothed = (wasSmoothed .or. angleWasSmoothed)
          ! Consider the scan range in each MAF in turn
          do maf = 1, noMAFs
            scanMax = maxval ( tpGeodAlt%dpField(1,:,maf) )
            scanMin = minval ( tpGeodAlt%dpField(1,:,maf) )
            orbyMax = maxval ( tpOrbY%dpField(1,:,maf) )
            scVelMax = maxval ( abs(scVel%dpField(1,:,maf)) )

            thisOneValid = ( &
              &   scanMin >= ChunkDivideConfig%scanLowerLimit(1) .and. &
              &   scanMin <= ChunkDivideConfig%scanLowerLimit(2) ) .and. ( &
              &   scanMax >= ChunkDivideConfig%scanUpperLimit(1) .and. &
              &   scanMax <= ChunkDivideConfig%scanUpperLimit(2) )
            if ( ChunkDivideConfig%maxOrbY > 0.0 ) then
              thisOneValid = thisOneValid .and. orbYMax < ChunkDivideConfig%maxOrbY
            end if
            if ( ChunkDivideConfig%maxscVel > 0.0 ) then
              thisOneValid = thisOneValid .and. scVelMax < ChunkDivideConfig%maxscVel
            end if
            ! this one is not valid if it's valid only by virtue
            ! of having been smoothed
            thisOneValid = thisOneValid .and. .not. wasSmoothed(maf)
            if ( ChunkDivideConfig%criticalModules == l_both ) then
              valid(maf) = valid(maf) .and. thisOneValid
            else
              valid(maf) = valid(maf) .or. thisOneValid
            end if
          end do                        ! Maf loop
          call DeallocateL1BData ( taiTime )
          call DeallocateL1BData ( tpgeodalt )
          call DeallocateL1BData ( tpgeodangle )
          call DeallocateL1BData ( tporby )
          call DeallocateL1BData ( scVel )
        end if                          ! Consider this module
      end do                            ! Module Loop
      ! Convert this information into obstructions and tidy up.
      if ( swLevel > 1 ) call Dump( valid, 'valid array passed to ConvertFlagsToObstructions' )
      maf = FindFirst ( .not. valid )
      call OutputNamedValue ( 'First not valid', maf )
      maf = FindLast ( .not. valid )
      call OutputNamedValue ( 'Last not valid', maf )
      call ConvertFlagsToObstructions ( valid, obstructions, &
        & obstructionType='scan' )
      call Deallocate_test ( valid, 'valid', ModuleName )
      call Deallocate_test ( wasSmoothed, 'wasSmoothed', ModuleName )
      call Deallocate_test ( angleWasSmoothed, 'angleWasSmoothed', ModuleName )
    end if                              ! Consider scan issues

    ! Here we look at radiances and switch changes.
    if ( swLevel > -1 ) call output ( 'NoteL1BRADChanges', advance='yes' )
    if ( .not. ChunkDivideConfig%skipL1BCheck ) &
      call NoteL1BRADChanges ( obstructions, mafRange, filedatabase )

    ! Sort the obstructions into order; prune them of repeats, overlaps etc.
    call PruneObstructions ( obstructions )

    ! Tidy up
    call DeallocateL1BData ( taiTime )

  contains
    function PhiNotMonotonicFun() result( SEVERITY )
    ! Default severity (probably ERROR) incurred
    ! if config options set the crashIfPhiNotMono flag
    ! Args
    integer :: SEVERITY
    ! if ( switchDetail(switches,'nmono') > -1 ) then ! be lenient
    if ( ChunkDivideConfig%crashIfPhiNotMono ) then ! be lenient
      severity = severityifphinotmono
    else
      severity = min( MLSMSG_Warning, severityifphinotmono )
    endif
    end function PhiNotMonotonicFun
  end subroutine SurveyL1BData

  ! -------------------------------------------- PruneObstructions -----
  subroutine PruneObstructions ( obstructions )
    ! This routine merges overlapping range obstructions and deletes
    ! wall obstructions inside ranges.  The job is made easier
    ! by sorting the obstructions into order
    use Allocate_Deallocate, only: Test_Allocate
    type(Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS

    ! Local variables
    integer :: I,J                  ! Loop counters
    type (Obstruction_T) :: newObs  ! New Obstruction
    logical :: FOUNDONE             ! Found at least one
    integer :: STATUS               ! Flag from allocate

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    ! If no obstructions make sure allocate to size zero, not just unassociated pointer
    if ( .not. associated(obstructions) ) then
      allocate ( obstructions(0), stat=status )
      call test_allocate ( status, ModuleName, 'obstructions', &
        & uBounds = 0, elementSize = storage_size(obstructions) / 8 )
      return
    end if

    ! Otherwise, do the tidying up
    outerLoop: do
      foundOne = .false.
      i = 0
      call SortObstructions(obstructions)
      middleLoop: do
        i = i + 1
        if ( i >= size(obstructions) ) exit middleLoop
        j = i
        innerLoop: do
          j = j + 1
          if ( j > size(obstructions) ) exit innerLoop
          if ( all ( obstructions((/i,j/))%range ) ) then
            ! --------------------------- ( Range, range )
            if ( obstructions(j)%mafs(1) <= obstructions(i)%mafs(2) + 1 ) then
              ! Combine overlapping range obstructions
              newObs%range = .true.
              newObs%mafs(1) = obstructions(i)%mafs(1)
              newObs%mafs(2) = &
                & max ( obstructions(i)%mafs(2), obstructions(j)%mafs(2) )
              ! Must delete these in order: otherwise
              ! if deleted i first where i < j, index would
              ! no longer be "j" afterwards
              call DeleteObstruction ( obstructions, j )
              call DeleteObstruction ( obstructions, i )
              call AddObstructionToDatabase ( obstructions, newObs )
              call SortObstructions ( obstructions )
              foundOne = .true.
              exit middleLoop
            end if
          else if ( obstructions(i)%range .and. .not. obstructions(j)%range ) then
            ! --------------------------- ( Range, wall )
            if ( obstructions(j)%mafs(1) >= obstructions(i)%mafs(1) .and. &
              &  obstructions(j)%mafs(1) <= obstructions(i)%mafs(2) + 1 ) then
              ! Delete wall obstruction inside range
              call DeleteObstruction ( obstructions, j )
              foundOne = .true.
              exit middleLoop
            end if
          else
            ! --------------------------- ( Wall, range ) or ( Wall, wall )
            ! Becuase the obstructions are in order, we know in the wall, range
            ! case that the wall must be at the start of the range, not inside it.
            if ( obstructions(i)%mafs(1) == obstructions(j)%mafs(1) ) then
              ! Delete wall obstruction at start of a range or at another wall
              call DeleteObstruction ( obstructions, i )
              foundOne = .true.
              exit middleLoop
            end if
          end if
          ! I'm pretty sure this covers all the possibilities.  It might seem
          ! not at first glance, but I think the fact that I always re-sort the
          ! obstructions into order means that the above code does catch everything.

        end do innerLoop
      end do middleLoop
      if ( .not. foundOne ) exit outerLoop
    end do outerLoop

  end subroutine PruneObstructions

  !------------------------------------------- ChunkDivide_Orbital -----
  subroutine ChunkDivide_Orbital ( mafRange, filedatabase, chunks, root )
    ! integer, dimension(2), intent(in) :: MAFRANGE
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use Trace_m, only: Trace_Begin, Trace_End
    type (MAFRange_T) :: MAFRange
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS
    integer, intent(in), optional :: Root ! of the l2cf tree, for tracing

    ! Local parameters
    real(r8), parameter :: HOMEACCURACY = 3.0 ! Try to hit homeGeodAngle within this
    ! (see homeHuntLoop warning below)
    ! Local variables
    type (L1BData_T) :: TAITIME         ! From L1BOA
    type (L1BData_T) :: TPGEODANGLE     ! From L1BOA

    character(len=10) :: MODNAMESTR     ! Home module name as string

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: CHUNK                    ! Loop counter
    integer :: FLAG                     ! From ReadL1B
    integer :: HOME                     ! Index of home MAF in array
    integer :: M1, M2                   ! MafRange%L2Cover + 1
    integer :: Me = -1                  ! String index for trace
    integer :: MEXP1, MEXP2             ! MafRange%Expanded + 1
    integer :: NOCHUNKSBELOWHOME        ! Used for placing chunks
    integer :: NOMAFSATORABOVEHOME      ! Fairly self descriptive
    integer :: NOMAFSBELOWHOME          ! Fairly self descriptive
    ! integer :: NOMAFS                   ! Number of MAFs to consider
    integer :: NOMAFSREAD               ! From ReadL1B
    integer :: ORBIT                    ! Used to locate home
    integer :: STATUS                   ! From allocate etc.
    integer :: NOCHUNKS                 ! Number of chunks
    integer :: MAXLENGTH                ! Max length as integer (MAFs)

    integer, dimension(:), pointer :: NEWFIRSTMAFS ! For thinking about overlaps
    integer, dimension(:), pointer :: NEWLASTMAFS ! For thinking about overlaps

    real(r8) :: ANGLEINCREMENT          ! Increment in hunt for home
    real(r8) :: MAXANGLE                ! Of range in data
    real(r8) :: MAXTIME                 ! Time range in data
    real(r8) :: MAXV                    ! Either minTime or minAngle
    real(r8) :: MINANGLE                ! Of range in data
    real(r8) :: MINTIME                 ! Time range in data
    real(r8) :: MINV                    ! Either minTime or minAngle
    real(r8) :: TESTANGLE               ! Angle to check for
    real(r8) :: HOMEV                   ! Value of angle/time at home

    real(r8), dimension(:), pointer :: BOUNDARIES ! Used in placing chunks
    real(r8), dimension(:), pointer :: FIELD ! Used in placing chunks

    integer   ::                       l1b_hdf_version
    character(len=namelen) ::         MAF_start, tp_angle
    type (MLSFile_T), pointer             :: L1BFile

    ! Executable code
    if ( present(root) ) call trace_begin ( me, 'ChunkDivide_orbital', root, &
        & cond=toggle(gen) .and. levels(gen) > 2 )

    swlevel = switchDetail(switches, 'chu' )
    if ( swLevel > -1 ) then
      call output('Entering Orbital Chunk Divide', advance='yes')
      call dump( obstructions )
    endif
    ! Read in the data we're going to need
    call get_string ( lit_indices(ChunkDivideConfig%homeModule), modNameStr, strip=.true. )
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) &
      & call MLSMessage  ( MLSMSG_Error, ModuleName, &
        & "Can't make progress in ChunkDivide_Orbital without L1BOA files" )
    ! call dump(L1BFile)
    l1b_hdf_version = L1BFile%HDFVersion
    MAF_start = AssembleL1BQtyName ( 'MAFStartTimeTAI', l1b_hdf_version, &
      .false. )
    tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
      & l1b_hdf_version, &
      & .false. )
    if ( swLevel > -1 ) &
      & call output('Reading Geod Angle', advance='yes')
    call ReadL1BData ( L1BFile, trim(tp_angle), &
      & tpGeodAngle, noMAFsRead, flag, &
      & dontPad=DONTPAD )
    if ( swLevel > -1 ) &
      & call output('1st smoothing', advance='yes')
    call smoothOutDroppedMAFs(tpGeodAngle%dpField)
    if ( swLevel > -1 ) &
      & call output('2nd smoothing', advance='yes')
    call smoothOutDroppedMAFs(tpGeodAngle%dpField, monotonize=.true.)
    if ( swLevel > -1 ) &
      & call output('Reading tai Time', advance='yes')
    call ReadL1BData ( L1BFile, trim(MAF_start), &
      & taiTime, noMAFsRead, flag, &
      & dontPad=DONTPAD )
    call smoothOutDroppedMAFs(taiTime%dpField)
    ! noMAFs = mafRange%L2Cover(2) - mafRange%L2Cover(1) + 1
    m1 = mafRange%L2Cover(1) + 1
    m2 = mafRange%L2Cover(2) + 1
    mexp1 = mafRange%Expanded(1) + 1
    mexp2 = mafRange%Expanded(2) + 1

    minAngle = minval ( tpGeodAngle%dpField(1,1,m1:m2) )
    maxAngle = maxval ( tpGeodAngle%dpField(1,1,m1:m2) )
    minTime = minval ( taiTime%dpField(1,1,m1:m2) )
    maxTime = maxval ( taiTime%dpField(1,1,m1:m2) )
    if ( swLevel > -1 ) then
      call output ( 'Num MAFs in file: ' )
      call output ( noMAFsRead, advance='yes' )
      call output ( 'MAF time range: ' )
      call output ( minTime )
      call output ( ' : ' )
      call output ( maxTime, advance='yes' )
      call output ( 'Angle range: ' )
      call output ( minAngle )
      call output ( ' : ' )
      call output ( maxAngle, advance='yes' )
    end if

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! First try to locate the last MAF before the homeGeodAngle
    orbit = int ( tpGeodAngle%dpField(1,1,m1)/360.0 )
    if ( tpGeodAngle%dpField(1,1,m1) < 0.0 ) orbit = orbit - 1
    testAngle = ChunkDivideConfig%homeGeodAngle + orbit*360.0
    if ( ChunkDivideConfig%maxLengthFamily == PHYQ_Angle ) then
      angleIncrement = ChunkDivideConfig%maxLength
    else
      angleIncrement = 360.0
    end if

    if ( swLevel > -1 ) then
      call output ( ' orbit  ', advance='no' )
      call output ( orbit , advance='no' )
      call output ( '    testAngle  ', advance='no' )
      call output ( testAngle , advance='no' )
      call output ( '    angleIncrement  ', advance='no' )
      call output ( angleIncrement , advance='yes' )
    end if
    ! In my opinion (paw) here's what the following loop should do:
    ! Find the 1st MAF within HOMEACCURACY of home_angle
    ! where home_angle has been corrected for the starting orbit number
    ! Afterwards, the preceding MAFs must be divided among one or more
    ! chunks, and the same done with subsequent MAFs
    !
    ! Instead what it actually does is
    ! Find the 1st MAF within HOMEACCURACY of (home_angle + n*angleIncrement)
    ! where home_angle has been corrected for the starting orbit number
    ! In effect the home_angle is set only within an unknown number
    ! of angleIncrements
    ! While there may be few cases in which they don't do about as well
    ! let this be a warning
    homeHuntLoop: do
      if ( testAngle < minAngle ) then
        testAngle = testAngle + angleIncrement
        cycle
      endif
      if ( testAngle > maxAngle ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to establish a home major frame, using the first in your range' )
        home = m1
        exit homeHuntLoop
      end if
      ! Find MAF which starts before this test angle
      call Hunt ( tpGeodAngle%dpField(1,1,:), testAngle, home, nearest=.true.,&
        & allowTopValue = .true. )
      ! Now if this is close enough, accept it
      if ( abs ( tpGeodAngle%dpField(1,1,home) - &
        & testAngle ) < HomeAccuracy ) exit homeHuntLoop
      ! Otherwise, keep looking
      testAngle = testAngle + angleIncrement
    end do homeHuntLoop
    if ( swLevel > -1 ) then
      call output ( 'Test Angle  ' )
      call output ( testAngle , advance='yes' )
      call output ( 'Angle(home)  ' )
      call output ( tpGeodAngle%dpField(1,1,home) , advance='yes' )
      call output ( 'Home  ' )
      call output ( home  )
      call output ( 'Difference  ' )
      call output (  abs ( tpGeodAngle%dpField(1,1,home) - &
        & testAngle ) , advance='yes' )
    end if

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! OK, now we have a home MAF, get a first cut for the chunks
    ! We work out the chunk ends for each chunk according to how the
    ! maxLength field is specified.
    if ( ChunkDivideConfig%maxLengthFamily == PHYQ_MAFs ) then
      maxLength = nint ( ChunkDivideConfig%maxLength )
      noMAFsBelowHome = home - m1
      noChunksBelowHome = noMAFsBelowHome / maxLength
      if ( mod ( noMAFsBelowHome, maxLength ) /= 0 ) noChunksBelowHome = noChunksBelowHome + 1
      noMAFsAtOrAboveHome = m2 - home + 1
      if ( ChunkDivideConfig%noChunks == 0 ) then
         ! If user did not request specific number of chunks choose them
         noChunks = noChunksBelowHome + noMAFsAtOrAboveHome / maxLength
         if ( mod ( noMAFsAtOrAboveHome, maxLength ) /= 0 ) &
            & noChunks = noChunks + 1
      else
        ! User requested specific number of chunks
        noChunks = ChunkDivideConfig%noChunks
      end if

      ! Allocate the chunks
      allocate ( chunks(noChunks), stat=status )
      addr = 0
      if ( status == 0 .and. noChunks > 0 ) addr = transfer(c_loc(chunks(1)), addr)
      call test_allocate ( status, ModuleName, 'chunks', &
        & uBounds = noChunks, elementSize = storage_size(chunks) / 8, address=addr )

      ! Work out their positions
      do chunk = 1, noChunks
        chunks(chunk)%lastMAFIndex = home + &
          & ( chunk - noChunksBelowHome ) * maxLength - 1
        ! Subtract one to convert from index in array to index in file
      end do
    else
      ! For angle and time, they are similar enough we'll just do some stuff
      ! with pointers to allow us to use common code to sort them out
      select case ( ChunkDivideConfig%maxLengthFamily )
      case ( PHYQ_Angle )
        field => tpGeodAngle%dpField(1,1,:)
        minV = minAngle
        maxV = maxAngle
      case ( PHYQ_Time )
        field => taiTime%dpField(1,1,:)
        minV = minTime
        maxV = maxTime
      case ( PHYQ_MAFs)
      end select
      homeV = field(home)

      noMAFsBelowHome = -999
      noMAFsAtOrAboveHome = -999
      noChunksBelowHome = int ( &
        & ( homeV - minV ) / ChunkDivideConfig%maxLength )
      if ( homeV > minV ) noChunksBelowHome = noChunksBelowHome + 1
      if ( ChunkDivideConfig%noChunks == 0 ) then
        ! Choose the number of chunks ourselves
        noChunks = noChunksBelowHome + int ( &
          & ( maxV - homeV ) / ChunkDivideConfig%maxLength )
        if ( homeV + ChunkDivideConfig%maxLength * &
          & ( noChunks - noChunksBelowHome ) < maxV ) &
          & noChunks = noChunks + 1
        if ( (mexp1 < m1) .and. ( &
          & homeV + (ChunkDivideConfig%maxLength-1) + &
          & ChunkDivideConfig%maxLength * &
          & ( noChunks - 1 - noChunksBelowHome ) < maxV ) ) &
          & noChunks = noChunks + 1
      else
        noChunks = ChunkDivideConfig%noChunks
      end if

      ! Allocate the chunks
      allocate ( chunks(noChunks), stat=status )
      addr = 0
      if ( status == 0 .and. noChunks > 0 ) addr = transfer(c_loc(chunks(1)), addr )
      call test_allocate ( status, ModuleName, 'chunks', &
        & uBounds = noChunks, elementSize = storage_size(chunks) / 8, address=addr )

      ! Work out their positions
      ! Boundaries are the angles/times at the end of the chunks
      nullify ( boundaries )
      call Allocate_test ( boundaries, noChunks, 'boundaries', ModuleName )
      ! When we allow prior overlaps, the first chunk
      ! sometimes has 1 too many MAFs unless we take extra care
      if ( mexp1 == m1 ) then
        do chunk = 1, noChunks
          boundaries(chunk) = homeV + &
            & ( chunk - noChunksBelowHome ) * ChunkDivideConfig%maxLength
        end do
      else
        boundaries(1) = homeV + &
          & ( 1 - noChunksBelowHome ) * (ChunkDivideConfig%maxLength - 1)
        do chunk = 2, noChunks
          boundaries(chunk) = boundaries(chunk-1) + &
            & ChunkDivideConfig%maxLength
        end do
      endif
      boundaries = min ( boundaries, maxV )
      boundaries = max ( boundaries, minV )
      if ( ChunkDivideConfig%maxLengthFamily == PHYQ_Angle ) then
        chunks(1)%phiStart = homeV
        chunks%phiEnd = boundaries
        chunks(2:noChunks)%phiStart = chunks(1:noChunks-1)%phiEnd
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & 'Regular HGrids will be unable to exploit chunk Geodetic Range' )
      endif

      ! Do some dumping
      if ( swLevel > -1 ) then
        call output ( ' minV: ' )
        call output ( minV  )
        call output ( ' maxV: ' )
        call output ( maxV , advance='yes' )
        call output ( ' homeV: ' )
        call output ( homeV , advance='yes' )
        call output ( ' noMAFSBelowHome: ' )
        call output ( noMAFsBelowHome, advance='yes' )
        call output ( ' noMAFSAtOrAboveHome: ' )
        call output ( noMAFsAtOrAboveHome, advance='yes' )
        call output ( ' NoChunks: ' )
        call output ( NoChunks, advance='yes' )
        call output ( ' noChunksBelowHome: ' )
        call output ( noChunksBelowHome , advance='yes' )
        call dump ( boundaries , 'boundaries' )
        call dump ( chunks%phiStart , 'phiStarts' )
        call dump ( chunks%phiEnd ,   'phiEnds' )
        call dump ( field, 'field' )
      end if

      call Hunt ( field, boundaries, chunks%lastMAFIndex, start=m1, &
        & allowTopValue=.true., nearest=.true. )
      call Deallocate_test ( boundaries, 'boundaries', ModuleName )
    end if

    ! Now deduce the chunk starts from the ends of their predecessors
    if ( noChunks > 1 ) &
      & chunks(2:noChunks)%firstMAFIndex = &
      & chunks(1:noChunks-1)%lastMAFIndex + 1
    chunks(1)%firstMAFIndex = m1

    ! Now bound the chunks to be within the processing range
    chunks%firstMAFIndex = min ( max ( chunks%firstMAFIndex, m1 ), m2 )
    chunks%lastMAFIndex = min ( max ( chunks%lastMAFIndex, m1 ), m2 )
    
    ! Each chunk remembers its own time range
    ! in case we readGriddedDatat during the loop of chunks
    ! chunks%Startime = taiTime%dpField(1,1,chunks%firstMAFIndex)
    ! chunks%Endtime =  taiTime%dpField(1,1,chunks%lastMAFIndex)

    ! Now offset these to the index in the file not the array
    ! chunks%firstMAFIndex = chunks%firstMAFIndex + mafRange(1) - 1
    ! chunks%lastMAFIndex = chunks%lastMAFIndex + mafRange(1) - 1
    chunks%firstMAFIndex = chunks%firstMAFIndex - 1
    chunks%lastMAFIndex = chunks%lastMAFIndex - 1

    ! If at this point the last two chunks end in the same place, this is
    ! a subtle defect in our chunking algorithm, lets avoid it
    if ( noChunks > 1 ) then
      if ( chunks(noChunks-1)%lastMAFIndex == chunks(noChunks)%lastMAFIndex ) then
        call DeleteChunk ( chunks, noChunks )
        noChunks = noChunks - 1
      end if
    end if

    ! Do some dumping
    if ( swLevel > -1 ) then
      call dump ( chunks%lastMAFIndex , 'chunks%lastMAFIndex' )
      call dump ( chunks%firstMAFIndex , 'chunks%firstMAFIndex' )
    end if

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! Think about overlaps
    nullify ( newFirstMAFs, newLastMAFs )
    call Allocate_test ( newFirstMAFs, noChunks, 'newFirstMAFs', ModuleName )
    call Allocate_test ( newLastMAFs, noChunks, 'newLastMAFs', ModuleName )
    ! We could split things out to deal with mixed unit, but lets make life easier
    ! for ourselves.  ChunkDivideL2PC has already insisted that
    ! lowerOverlapFamily == upperOverlapFamily.
    if ( ChunkDivideConfig%lowerOverlapFamily == PHYQ_MAFs ) then
      newFirstMAFs = max(chunks%firstMAFIndex - nint(ChunkDivideConfig%lowerOverlap), &
        & m1 - 1 )
      newLastMAFs = min(chunks%lastMAFIndex + nint(ChunkDivideConfig%upperOverlap), &
        & m2 - 1 )
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'The bit of code that deals with non-MAF overlaps is probably broken' )
    end if
    chunks%noMAFsLowerOverlap = chunks%firstMAFIndex - newFirstMAFs
    chunks%noMAFsUpperOverlap = newLastMAFs - chunks%lastMAFIndex
    chunks%firstMAFIndex = newFirstMAFs
    chunks%lastMAFIndex = newLastMAFs
    if ( swLevel > -1 ) then
      call dump ( newFirstMAFs , 'newFirstMAFs' )
      call dump ( newLastMAFs , 'newLastMAFs' )
      call dump ( chunks%noMAFsLowerOverlap , 'chunks%noMAFsLowerOverlap' )
      call dump ( chunks%noMAFsUpperOverlap , 'chunks%noMAFsUpperOverlap' )
    endif
    call Deallocate_test ( newFirstMAFs, 'newFirstMAFs', ModuleName )
    call Deallocate_test ( newLastMAFs, 'newLastMAFs', ModuleName )

    ! Delete any zero length or all overlapped chunks
    call PruneChunks ( chunks )
    if ( .not. associated(chunks) ) then
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'No chunks remaining after we pruned them for bad radiances; bad day?' )
    else if ( size(chunks) < 1 ) then
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'No chunks remaining after we pruned them for bad radiances; bad day?' )
    end if

    if ( swLevel > -1 ) then
      call output ( 'Before dealing with obstructions', advance='yes' )
      call Dump ( chunks )
    end if

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! Now think about the obstructions
    if ( associated(obstructions) ) &
      & call DealWithObstructions ( chunks, obstructions )

    ! Delete any zero length or all overlapped chunks
    call PruneChunks ( chunks )
    if ( .not. associated(chunks) ) then
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'No chunks remaining after we pruned them for zero length; bad day?' )
    else if ( size(chunks) < 1 ) then
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'No chunks remaining after we pruned them for zero length; bad day?' )
    end if

!     ! Forcibly zero out number of lower (upper) overlaps on 1st (last) chunks
    noChunks = size ( chunks )
!     chunks(1)%noMAFsLowerOverlap = 0
!     chunks(noChunks)%noMAFsUpperOverlap = 0

    ! Add lower overlap to first chunk if allowed
    if ( mexp1 < m1 ) then
      chunks(1)%firstMAFIndex = chunks(1)%firstMAFIndex + mexp1 - m1
      chunks(1)%noMAFsLowerOverlap = m1 - mexp1
    endif

    ! Add upper overlap to last chunk if allowed
    if ( mexp2 > m2 ) then
      chunks(noChunks)%lastMAFIndex = chunks(noChunks)%lastMAFIndex + mexp2 - m2
      chunks(noChunks)%noMAFsUpperOverlap = mexp2 - m2
    endif

    ! Now we assign phiStarts and phiEnds to each chunk
    do chunk = 1, noChunks
      m1 = max( chunks(chunk)%firstMAFIndex + 1, mafRange%L2Cover(1) + 1 )
      m2 = min( chunks(chunk)%lastMAFIndex + 1,  mafRange%L2Cover(2) + 1 )
      chunks(chunk)%phiStart = tpGeodAngle%dpField(1,1,m1)
      chunks(chunk)%phiEnd = tpGeodAngle%dpField(1,1,m2)
      chunks(chunk)%StartTime = taiTime%dpField(1,1,m1)
      chunks(chunk)%EndTime   = taiTime%dpField(1,1,m2)
    enddo
    if ( swLevel > -1 ) then
      call output ( 'After dealing with obstructions', advance='no' )
      call output ( ', poss. overlaps outside proc. range', advance='yes' )
      call Dump ( chunks )
      call dump ( chunks%phiStart  , 'phiStarts' )
      call dump ( chunks%phiEnd    , 'phiEnds  ' )
      call dump ( chunks%StartTime , 'StartTime' )
      call dump ( chunks%EndTime   , 'EndTime  ' )
    endif
    ! Tidy up
    call DeallocateL1BData ( tpGeodAngle )
    call DeallocateL1BData ( taiTime )

    if ( present(root) ) call trace_end ( &
      & 'ChunkDivide_orbital', cond=toggle(gen) .and. levels(gen) > 2 )

  end subroutine ChunkDivide_Orbital

  ! --------------------------------------------------- SortChunks -----
  subroutine SortChunks ( chunks )
    ! Sort the chunks into order of increasing firstMAFIndex
    type (MLSChunk_T), dimension(:), intent(inout) :: CHUNKS

    ! Local variables
    type (MLSChunk_T) :: TEMP
    integer :: I                        ! Loop counters
    integer, dimension(1) :: TOSWAP     ! Index

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    do i = 1, size(chunks) - 1
      toSwap = minloc ( chunks(i:)%firstMAFIndex + &
        & chunks(i:)%noMAFsLowerOverlap ) + (/ i-1 /)
      if ( toSwap(1) /= i ) then
        temp = chunks(i)
        chunks(i) = chunks(toSwap(1))
        chunks(toSwap(1)) = temp
      end if
    end do
  end subroutine SortChunks

  ! -------------------------------------------------- PruneChunks -----
  subroutine PruneChunks ( chunks )
     type (MLSChunk_T), dimension(:), pointer :: CHUNKS
     integer :: CHUNK
     ! Now delete chunks that either:
     !  1 - Are nothing but overlap
     !  2 - Have <=0 MAFs
     pruneChunksLoop: do
        chunk = FindFirst ( &
           & ( chunks%noMAFsLowerOverlap + chunks%noMAFsUpperOverlap ) >= &
           & ( chunks%lastMAFIndex - chunks%firstMAFIndex + 1 ) &
           & .or.&
           & ( chunks%firstMAFIndex > chunks%lastMAFIndex ) )
        if ( chunk == 0 ) exit pruneChunksLoop
        call DeleteChunk ( chunks, chunk )
     end do pruneChunksLoop
  end subroutine PruneChunks

  ! -------------------------------------------------- DeleteChunk -----
  subroutine DeleteChunk ( chunks, index )
    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    ! Dummy arguments
    type (MLSChunk_T), pointer, dimension(:) :: CHUNKS
    integer, intent(in) :: INDEX

    ! Local variables
    type (MLSChunk_T), pointer, dimension(:) :: TEMP
    integer(c_intptr_t) :: Addr ! For tracing
    integer :: S                ! Size in bytes of object to deallocate
    integer :: STATUS           ! From allocate

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    allocate ( temp ( size(chunks) - 1 ), stat=status )
    addr = 0
    if ( status == 0 .and. size(chunks) > 1 ) addr = transfer(c_loc(temp(1)), addr)
    call test_allocate ( status, ModuleName, 'temp', &
      & uBounds = size(chunks) - 1, elementSize = storage_size(temp) / 8, &
      & address=addr )

    if ( index > 1 ) temp(1:index-1) = chunks(1:index-1)
    if ( index < size(chunks) .and. size(chunks) > 1 ) &
       & temp(index:) = chunks(index+1:)

    s = size(chunks) * storage_size(chunks) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(chunks(1)), addr)
    deallocate ( chunks, stat=status )
    call test_deallocate ( status, moduleName, 'chunks', s, address=addr )

    chunks => temp

  end subroutine DeleteChunk

  !----------------------------------- Add obstruction to database -----
  subroutine AddObstructionToDatabase ( database, item )

     use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

     ! Dummy arguments
     type (Obstruction_T), dimension(:), pointer :: DATABASE
     type (Obstruction_T), intent(in) :: ITEM

     ! Local variables
     type (Obstruction_T), dimension(:), pointer :: TEMPDATABASE

     include "addItemToDatabase.f9h"

  end subroutine AddObstructionToDatabase

  !----------------------------------------- Add chunk to database -----
  subroutine AddChunkToDatabase ( database, item )

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (MLSChunk_T), dimension(:), pointer :: DATABASE
    type (MLSChunk_T), intent(in) :: ITEM

    ! Local variables
    type (MLSChunk_T), dimension(:), pointer :: TEMPDATABASE

    include "addItemToDatabase.f9h"

  end subroutine AddChunkToDatabase

  ! --------------------------------------------  CFM_ChunkDivide  -----
  type(MLSChunk_T) function CFM_ChunkDivide (processingRange, &
     filedatabase, config) result(chunk)

     type (TAI93_Range_T), intent(in) :: processingRange
     type (MLSFile_T), dimension(:), pointer :: filedatabase
     type(ChunkDivideConfig_T), intent(in) :: config

     type (MAFRange_T) :: MAFRange
     type(MLSChunk_T), dimension(:), pointer :: chunks => null()

     ! Executables
     chunkDivideConfig = config

     nullify(chunkDivideConfig%criticalSignals)   ! Just for Sun's compiler
     nullify(obstructions)

     ! not sure how to deal with obstruction, ignore it
     if (chunkDivideConfig%method /= l_fixed) then
        call SurveyL1BData ( processingRange, filedatabase, mafRange)
     end if

     if (chunkdivideconfig%method == l_orbital) then
        call ChunkDivide_Orbital (mafRange, filedatabase, chunks)
        chunk = chunks(1)
     else
        print *, "chunk divide method is unsupported"
     end if
  end function CFM_ChunkDivide

  !------------------------------------------------  what_options  -----
  function what_options( clean, transpose, trim ) result( options )
    use MLSStrings, only: Trim_Safe
    logical, optional, intent(in) :: clean
    logical, optional, intent(in) :: transpose
    logical, optional, intent(in) :: trim
    character(len=8) :: options
    options = ' '
    if ( present(clean) ) then
      if ( clean ) options = trim_safe(options) // 'c'
    endif
    if ( present(transpose) ) then
      if ( transpose ) options = trim_safe(options) // 'p'
    endif
    if ( present(trim) ) then
      if ( trim ) options = trim_safe(options) // 't'
    endif
  end function what_options

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ChunkDivide_m.f90,v 2.139 2024/08/08 20:42:22 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ChunkDivide_m

! $Log: ChunkDivide_m.f90,v $
! Revision 2.139  2024/08/08 20:42:22  pwagner
! Fixed two bugs in handling level 1 obstructions
!
! Revision 2.138  2020/07/22 22:50:04  pwagner
! Added chunks%Start, EndTimes to Dumps ending ChunkDivide_Orbital
!
! Revision 2.137  2020/07/09 23:52:25  pwagner
! Added Start,EndTime components to MLSChunk_T
!
! Revision 2.136  2019/10/16 20:57:37  pwagner
! Fixed a strange bug involving get_boolean
!
! Revision 2.135  2018/10/05 20:42:21  pwagner
! Improved appearance of how we Dump Critical Signals
!
! Revision 2.134  2018/08/03 23:43:42  vsnyder
! Add tracing to several routines.  Some cannonball polishing
!
! Revision 2.133  2018/06/26 00:12:32  pwagner
! Avoids accessing index=1 of 0-sized temp in DeleteChunk
!
! Revision 2.132  2018/06/22 23:22:08  pwagner
! Say why we stop if none remain after 2nd PruneChunks
!
! Revision 2.131  2018/05/14 23:23:58  vsnyder
! Remove tab formatting (again) to eliminate compiler warnings
!
! Revision 2.130  2018/04/19 01:14:16  vsnyder
! Remove USE statements for unused names
!
! Revision 2.129  2018/03/05 19:51:56  pwagner
! Now uses Dump_Signals
!
! Revision 2.128  2018/02/23 22:14:26  mmadatya
! Updated for polygon for ASMLS
!
! Revision 2.127  2018/02/09 00:58:27  pwagner
! Removed unused variables; wider use of outputNamedValue
!
! Revision 2.126  2018/01/03 01:15:22  pwagner
! Prints a little more debugging info
!
! Revision 2.125  2017/09/15 22:15:39  pwagner
! Correct bugs in evaluating excludeOverlap fields
!
! Revision 2.124  2017/09/14 23:19:36  pwagner
! Fixed some errors in ChunkDivide_Polygon
!
! Revision 2.123  2017/09/14 18:36:13  vsnyder
! Remove tab formatting to eliminate compiler warnings
!
! Revision 2.122  2017/03/06 19:55:48  pwagner
! Corrected remaining mistakes in evaluating logical values
!
! Revision 2.121  2017/02/15 00:48:26  pwagner
! Repaired bugs in processing Boolean fields /exclude..
!
! Revision 2.120  2017/02/10 21:57:47  pwagner
! Added the polygon method for ChunkDivide; NoChunks an optional parameter for fixed method
!
! Revision 2.119  2015/10/03 00:31:01  pwagner
! Will now show number of chunks
!
! Revision 2.118  2015/06/24 18:01:56  pwagner
! Halt with useful error message if no radiances, instead of vanishing in puff of smoke
!
! Revision 2.117  2015/03/28 02:19:01  vsnyder
! Added shallow destruction to DestroyChunkDatabase.  Got IsMonotonic from
! Monotone instead of MLSFillValues.
! Added stuff to trace allocate/deallocate addresses.
!
! Revision 2.116  2015/02/27 23:18:47  pwagner
! Require -Schu1 or greater to dump chunks
!
! Revision 2.115  2014/09/05 00:36:15  vsnyder
! More complete and accurate allocate/deallocate size tracking.  Add some
! tracing.
!
! Revision 2.114  2014/08/07 22:47:12  vsnyder
! Delete local declaration of Obstructions from AddChunkToDatabase so that
! when it's nullified the one at module scope gets nullified.  It was
! not otherwise used in AddChunkToDatabase.
!
! Revision 2.113  2014/03/07 19:20:05  pwagner
! Name_Len changed to nameLen; got from MLSCommon
!
! Revision 2.112  2014/03/01 03:10:56  vsnyder
! Move units checking to init_tables_module
!
! Revision 2.111  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.110  2014/01/09 00:30:24  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.109  2013/12/12 02:11:26  vsnyder
! Use iterator to handle variables, and IF and SELECT constructs
!
! Revision 2.108  2013/10/09 23:40:34  vsnyder
! Add Evaluate_Variable
!
! Revision 2.107  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.106  2013/09/21 00:39:43  vsnyder
! Repair some tree examination errors.  Move ChunkDivideConfig_t,
! ChunkDivideConfig, and some dumpers to ChunkDivideConfig_m.  Call
! DumpCommand.
!
! Revision 2.105  2013/08/30 02:45:34  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.104  2013/08/12 23:49:41  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.103  2013/06/28 19:02:58  pwagner
! criticalSignals may be used in place of criticalModules; it will be effective everywhere in marking obstructions
!
! Revision 2.102  2013/06/21 17:37:38  pwagner
! /crashIfPhiNotMono flag added to ChunkDivide config; default is to just warn; removed -Snmono switch
!
! Revision 2.101  2013/06/20 17:56:16  pwagner
! -Snmono lets us warn, not quit if phi not monotonic
!
! Revision 2.100  2013/05/21 22:50:24  pwagner
! Workaround for ifort13 bug
!
! Revision 2.99  2012/06/21 00:41:08  pwagner
! Added phi start and end to be used someday by HGrid
!
! Revision 2.98  2012/03/14 16:56:26  pwagner
! NAG-debug required this change
!
! Revision 2.97  2011/11/30 21:33:13  pwagner
! Quits with message if GeodAngle not monotonic
!
! Revision 2.96  2011/06/29 21:50:20  pwagner
! Some cases may safely omit l1b files
!
! Revision 2.95  2011/02/05 01:41:44  pwagner
! Define and use consistently swLevel to control dump verboseness
!
! Revision 2.94  2010/04/20 17:32:23  honghanh
! Abandon attempt to remove the requirement to have a maxMafLength
! in ChunkDivide_Orbital
!
! Revision 2.92  2010/03/23 23:53:08  honghanh
! Move most subroutine inside ChunkDivide out, including
! ChunkDivide_Orbital, create CFM_ChunkDivide, which call
! ChunkDivide_Orbital
!
! Revision 2.91  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.90  2009/06/16 17:42:59  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.89  2009/04/02 18:09:26  pwagner
! Fixed bug where status might be undefined
!
! Revision 2.88  2009/04/01 23:34:26  pwagner
! By default saves obstructions db to written to l2aux file
!
! Revision 2.87  2008/07/12 00:12:07  pwagner
! dump_criticalsignals not generic to appease sun studio 12
!
! Revision 2.86  2008/05/28 21:51:43  pwagner
! May choose critical band(s)
!
! Revision 2.85  2007/12/14 01:55:28  pwagner
! Must delete obstructions observing proper order for indexing
!
! Revision 2.84  2007/11/01 23:30:48  pwagner
! Should permit us to make sids files, i.e. omit l1brad
!
! Revision 2.83  2007/10/24 00:14:58  pwagner
! Removed unused declarations
!
! Revision 2.82  2007/09/06 22:31:50  pwagner
! Raise switch threshold for dumpings signals
!
! Revision 2.81  2007/06/08 22:00:23  vsnyder
! Quit gracefully if no L1BOA files
!
! Revision 2.80  2007/03/23 00:16:57  pwagner
! Prevent crashing while printing extra-long signals names
!
! Revision 2.79  2007/02/09 01:10:00  pwagner
! Fixed bug where criticalSignals not nullified
!
! Revision 2.78  2007/02/06 23:13:40  pwagner
! Now can chooseCriticalSignals based on criticalModule
!
! Revision 2.77  2007/01/25 19:04:59  pwagner
! Warns if DACsDeconvolved attribute not found
!
! Revision 2.76  2006/06/20 00:12:30  pwagner
! Improved two printed formats
!
! Revision 2.75  2006/05/09 23:41:41  pwagner
! Warn if not assured DACS deconvolution performed by level 1
!
! Revision 2.74  2006/04/20 23:22:54  pwagner
! Show both kinds of allowed extra-range overlaps
!
! Revision 2.73  2006/04/10 23:45:18  pwagner
! Reset defaults in read_apriori, not ChunkDivide
!
! Revision 2.72  2006/04/03 20:26:08  pwagner
! More verbose notice when using l2gp a priori exclude outside overlaps
!
! Revision 2.71  2006/03/17 21:57:43  pwagner
! Adjust default behavior to exclude overlaps outside processing if sids run
!
! Revision 2.70  2006/03/17 00:06:31  pwagner
! Change default to allowing overlaps outside processingRange
!
! Revision 2.69  2006/02/10 21:19:24  pwagner
! dumps may go to special dumpfile
!
! Revision 2.68  2006/02/07 00:55:47  pwagner
! Now allows overlaps after data end time
!
! Revision 2.67  2006/01/26 00:34:50  pwagner
! demoted more use statements from module level to speed Lahey compiles
!
! Revision 2.66  2005/12/16 00:06:51  pwagner
! Changes to reflect new MLSFillValues module
!
! Revision 2.65  2005/10/22 00:43:43  pwagner
! Gets DACSDeconvolved attribute from l1b file if there
!
! Revision 2.64  2005/09/21 23:25:42  pwagner
! Obstructions public now; optionally saved; should add deallocate in tree_walker
!
! Revision 2.63  2005/09/14 00:10:37  pwagner
! ChunkDivideConfig public so allowPriorOverlaps visible
!
! Revision 2.62  2005/08/09 00:02:09  pwagner
! hdfVersion not left undefined in ANY_GOOD_SIGNALDATA
!
! Revision 2.61  2005/06/03 02:02:17  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades
!
! Revision 2.60  2005/06/01 17:39:26  pwagner
! Dont read L1bFile if unassocated
!
! Revision 2.59  2005/05/31 17:51:16  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.58  2005/05/27 19:53:43  vsnyder
! Produce meaningful error message instead of crash for empty section
!
! Revision 2.57  2004/12/14 21:43:33  pwagner
! Repaired bug in reading mafRange rather than all mafs
!
! Revision 2.56  2004/11/03 17:19:09  livesey
! Bug fix in case where only one chunk
!
! Revision 2.55  2004/10/05 23:09:54  pwagner
! Can handle dropped MAFs, maneuvers that disrupt monotonic geodAngle
!
! Revision 2.54  2004/08/23 22:00:39  pwagner
! Made most readl1bData dontpad=.true.
!
! Revision 2.53  2004/08/16 17:10:04  pwagner
! Passes dontPad option to readL1BData
!
! Revision 2.52  2004/08/09 21:43:10  livesey
! Bug fixes and added the maxOrbY argument.
!
! Revision 2.51  2004/08/04 23:19:57  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.50  2004/08/02 23:40:29  livesey
! Bug fixes in the orbital case when chunk length is expressed in MAFs
!
! Revision 2.49  2004/07/31 19:58:28  livesey
! Various bug fixes and clean ups in the light of real data.
!
! Revision 2.47  2004/06/10 00:58:44  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.46  2004/05/19 19:16:09  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.45  2003/08/27 20:08:04  livesey
! Removed print statements
!
! Revision 2.44  2003/08/26 19:49:22  livesey
! Removed another print statement.
!
! Revision 2.43  2003/08/26 19:43:42  livesey
! Commented out a print statement
!
! Revision 2.42  2003/08/26 18:05:14  livesey
! Various fixes to the obstruction stuff.  More to come probably.
!
! Revision 2.41  2003/08/25 23:43:08  pwagner
! Added ReduceChunkDatabase
!
! Revision 2.40  2003/08/21 22:51:18  livesey
! Removed yet more print statements!
!
! Revision 2.39  2003/08/21 22:49:22  livesey
! Removed more print statements etc.
!
! Revision 2.38  2003/08/15 23:58:20  vsnyder
! Get PHYQ_... directly from Intrinsic instead of indirectly via Units
!
! Revision 2.37  2003/06/20 19:38:25  pwagner
! Allows direct writing of output products
!
! Revision 2.36  2003/06/09 22:55:23  pwagner
! Improved criticalSignals; some bug fixes
!
! Revision 2.35  2003/06/05 23:37:14  pwagner
! 1st version of criticalSignals in Chunk Divide Orbital
!
! Revision 2.34  2003/05/17 00:06:06  pwagner
! Wont check sidebands for missing radiances
!
! Revision 2.33  2003/05/09 16:43:05  pwagner
! Speedup of L1B radiance check
!
! Revision 2.32  2003/05/07 23:43:05  pwagner
! Optionally may skipL1BCheck
!
! Revision 2.31  2003/04/30 22:06:04  pwagner
! Shouldnt check for good signals if there arent any
!
! Revision 2.30  2003/04/28 23:07:00  pwagner
! Fleshed out notel1brad_changes; not yet tested where needed
!
! Revision 2.29  2003/01/06 20:13:09  livesey
! New split upper/lower overlaps
!
! Revision 2.28  2002/12/11 22:17:05  pwagner
! Added error checks on hdf version
!
! Revision 2.27  2002/12/06 01:08:33  pwagner
! Less likely to bomb on single chunks
!
! Revision 2.26  2002/11/13 01:03:11  pwagner
! Actually reads hdf5 radiances
!
! Revision 2.25  2002/11/06 00:21:16  pwagner
! Fixed non-zero starttime prob; some extra checks, printing
!
! Revision 2.24  2002/10/07 23:49:49  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.23  2002/10/07 18:00:10  livesey
! Added call to trace_end, whoops!
!
! Revision 2.22  2002/08/22 01:23:52  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.21  2002/08/04 15:59:45  mjf
! New method "PE" for a single chunk centred on (or near) a given phi.
!
! Revision 2.20  2002/05/24 20:57:34  livesey
! More revisions associated with being able to have a specific number of chunks
!
! Revision 2.19  2002/05/24 16:47:30  livesey
! Allowed user to request specific number of chunks for orbital
!
! Revision 2.18  2001/12/17 23:09:18  livesey
! Now deletes chunks that are nothing but overlap
!
! Revision 2.17  2001/12/16 00:56:43  livesey
! Added dump option
!
! Revision 2.16  2001/11/20 00:10:29  livesey
! Another bug fix
!
! Revision 2.15  2001/11/19 23:53:50  livesey
! Works better, fixed bug with cases with all missing data, also handles
! ends of processing range properly.
!
! Revision 2.14  2001/11/19 23:33:45  livesey
! Interim version, some bugs to track down
!
! Revision 2.13  2001/11/16 20:38:42  livesey
! Nullified some pointers I missed
!
! Revision 2.12  2001/11/15 17:43:46  livesey
! Tidied up, more comments etc.
!
! Revision 2.11  2001/11/14 22:33:40  livesey
! This version seems pretty good.
!
! Revision 2.10  2001/11/14 01:49:12  livesey
! Improvements, getting closer
!
! Revision 2.9  2001/11/12 21:15:34  livesey
! More bug fixes
!
! Revision 2.8  2001/11/12 20:31:23  livesey
! Bug fix check in
!
! Revision 2.7  2001/11/10 01:09:41  livesey
! Bug fixes
!
! Revision 2.6  2001/11/10 01:01:03  livesey
! Just tidied up
!
! Revision 2.5  2001/11/10 00:56:24  livesey
! OK, this is getting close to being ready for testing.
!
! Revision 2.4  2001/11/10 00:03:44  livesey
! More work, still got issues!
!
! Revision 2.3  2001/11/09 23:17:22  vsnyder
! Use Time_Now instead of CPU_TIME
!
! Revision 2.2  2001/11/09 06:34:39  livesey
! Minor bug fix, and added Log stuff
!
@


2.139
log
@Fixed two bugs in handling level 1 obstructions
@
text
@d427 10
a436 1
        if ( any ( inRange( MAFRanges(OldChunk), MAFRanges(2:NumberOlds) ) ) ) cycle
d439 3
a441 1
          & any ( inRange( MAFRanges(OldChunk), MAFRanges(1:OldChunk-1) ) ) &
d443 3
a445 1
          & any ( inRange( MAFRanges(OldChunk), MAFRanges(OldChunk+1:NumberOlds) ) ) &
d447 13
a459 2
      else
        if ( any ( inRange( MAFRanges(OldChunk), MAFRanges(1:OldChunk-1) ) ) ) cycle
d484 8
d3128 1
a3128 1
       "$Id: ChunkDivide_m.f90,v 2.138 2020/07/22 22:50:04 pwagner Exp $"
d3138 3
@


2.138
log
@Added chunks%Start, EndTimes to Dumps ending ChunkDivide_Orbital
@
text
@d37 2
a38 2
  use MLSCommon, only: MLSFile_T, Tai93_Range_T
  use MLSFinds, only: findfirst, FindLongestRange
d220 1
a220 1
    type( MLSChunk_T ), dimension(:), pointer  :: CHUNKS
d236 2
d245 1
d413 30
d449 1
a449 1
    if ( swLevel > 0 ) then
d452 1
a452 1
      call outputnamedValue( 'Number of chunks', size(chunks) )
d2109 1
a2109 1
          newObstruction%mafs(2) = maf - 2 + offset
d2118 11
d2142 1
a2142 1
    ! This goes through the L1B data files and tries to spot possible
d2144 2
a2145 1
    ! use MLSL2Options, only: sharedPCF
d2147 3
a2149 3
    type (TAI93_Range_T), intent(in) :: PROCESSINGRANGE
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (MAFRange_T), intent(out) :: MAFRange
d2152 3
d2169 1
a2171 1
    logical, dimension(:), pointer :: ANGLEWASSMOOTHED ! Flag for each MAF
d2173 1
d2176 1
a2176 1
    real(r8) :: ORBYMAX                 ! Maximum value of orbY each maf
d2179 6
a2184 2
    character(len=namelen) ::         MAF_start, tp_alt, tp_orbY, tp_angle
    type (MLSFile_T), pointer             :: L1BFile
d2261 4
d2272 1
d2282 5
d2308 2
d2314 1
a2314 1
          if ( swLevel > -1 ) then
d2324 1
d2334 3
d2350 1
d2354 5
d3096 1
a3096 1
       "$Id: ChunkDivide_m.f90,v 2.137 2020/07/09 23:52:25 pwagner Exp $"
d3106 3
@


2.137
log
@Added Start,EndTime components to MLSChunk_T
@
text
@d2845 4
a2848 2
      call dump ( chunks%phiStart , 'phiStarts' )
      call dump ( chunks%phiEnd ,   'phiEnds' )
d3021 1
a3021 1
       "$Id: ChunkDivide_m.f90,v 2.136 2019/10/16 20:57:37 pwagner Exp $"
d3031 3
@


2.136
log
@Fixed a strange bug involving get_boolean
@
text
@d2728 5
d2741 1
a2741 1
    ! a subtle defect in our chunking algorihtm, lets avoid it
d2838 2
d3019 1
a3019 1
       "$Id: ChunkDivide_m.f90,v 2.135 2018/10/05 20:42:21 pwagner Exp $"
d3029 3
@


2.135
log
@Improved appearance of how we Dump Critical Signals
@
text
@d854 1
d888 1
d909 1
d928 15
a942 2
        ! print *, 'fieldIndex ', fieldIndex
        ! print *, 'nsons(son) ', nsons(son)
d949 1
a949 1
          log_value = get_boolean ( fieldValue )
d952 1
a952 1
          log_value = .false.
d1024 1
a1024 1
          ChunkDivideConfig%allowPostOverlaps = .not. get_boolean ( fieldValue ) ! log_value
d1029 1
a1029 1
          ChunkDivideConfig%allowPriorOverlaps = .not. get_boolean ( fieldValue ) ! log_value
d1038 1
a1038 1
          ChunkDivideConfig%skipL1BCheck = get_boolean ( fieldValue ) ! log_value
d1043 1
a1043 1
          ChunkDivideConfig%crashIfPhiNotMono = get_boolean ( fieldValue ) ! log_value
d1049 1
a1049 1
          ChunkDivideConfig%saveObstructions = get_boolean ( fieldValue ) ! log_value
d3012 1
a3012 1
       "$Id: ChunkDivide_m.f90,v 2.134 2018/08/03 23:43:42 vsnyder Exp $"
d3022 3
@


2.134
log
@Add tracing to several routines.  Some cannonball polishing
@
text
@d1786 2
a1787 2
        call output('Critical Signals you chose', advance='yes' )
        call Dump (  criticalSignals )
d2996 1
a2996 1
       "$Id: ChunkDivide_m.f90,v 2.133 2018/06/26 00:12:32 pwagner Exp $"
d3006 3
@


2.133
log
@Avoids accessing index=1 of 0-sized temp in DeleteChunk
@
text
@d317 1
a317 1
      call ChunkDivide_Fixed ( chunks )
d322 2
a323 1
        call ChunkDivide_Polygon ( mafRange, filedatabase, chunks, InstrumentModuleName  )
d335 1
a335 1
        call ChunkDivide_Orbital ( mafRange, filedatabase, chunks )
d456 1
a456 1
    subroutine ChunkDivide_Even ( mafRange, filedatabase, chunks )
d460 1
d463 1
d468 4
d475 1
a475 1
    subroutine ChunkDivide_Fixed ( chunks )
d480 1
d485 1
d492 2
d516 2
d522 2
a523 1
    subroutine ChunkDivide_Polygon ( mafRange, filedatabase, chunks, InstrumentModuleName )
d535 1
d542 1
d562 2
d703 2
d709 1
a709 1
    subroutine ChunkDivide_PE ( mafRange, filedatabase, chunks )
d716 1
d731 1
d745 3
a747 3
      integer   ::                       l1b_hdf_version
      character(len=namelen) ::         MAF_start, tp_angle
      type (MLSFile_T), pointer             :: L1BFile
d750 2
d845 2
d1365 1
a1365 1
  use MLSFillValues, only: IsFillValue
d1401 6
a1406 6
    ! --------------------------------------- DealWithObstructions -----
    subroutine DealWithObstructions ( chunks, obstructions )
      type (MLSChunk_T), dimension(:), pointer :: CHUNKS
      type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
      ! This routine modifies the chunks according to the information
      ! given in the obstructions.
d1408 8
a1415 8
      ! Local variables
      type (MLSChunk_T) :: NEWCHUNK       ! A chunk to create
      integer :: CHUNK                    ! Index of chunk under some consideration
      integer :: DEADCHUNK                ! Index of chunk to kill
      integer :: FIRSTMAF                 ! Index of first MAF in range
      integer :: LASTMAF                  ! Index of last MAF in range
      integer :: MAF                      ! Index of MAF for wall
      integer :: OBSTRUCTION              ! Loop counter
d1417 2
a1418 2
      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
d1420 39
a1458 39
      do obstruction = 1, size ( obstructions )
        ! Find chunk where this obstruction is/starts
        if ( obstructions(obstruction)%range ) then
          ! A range obstruction

          ! first identify the chunks whose non overlapped portion falls completely
          ! within the range and delete them
          firstMAF = obstructions(obstruction)%mafs(1)
          lastMAF = obstructions(obstruction)%mafs(2)
          insideRange: do
            deadChunk = FindFirst ( &
              & chunks%firstMAFIndex + chunks%noMAFsLowerOverlap >= firstMAF .and. &
              & chunks%lastMAFIndex - chunks%noMAFsUpperOverlap <= lastMAF )
            if ( deadChunk == 0 ) exit insideRange
            call DeleteChunk ( chunks, deadChunk )
          end do insideRange

          ! Now think about chunks whose non overlapped part completely
          ! encompass the range, and split them.
          ! (we'll deal with the issue of ranges spilling into overlap regions below)
          chunk = FindFirst ( &
            & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap <= firstMAF ) .and. &
            & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap >= lastMAF ) )
          if ( chunk /= 0 ) then
            ! Create two new chunks with the wall between, first the lower portion
            newChunk = chunks ( chunk )
            newChunk%lastMAFIndex = firstMAF - 1
            newChunk%noMAFsUpperOverlap = 0
            if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
              & call AddChunkToDatabase ( chunks, newChunk )
            ! Now the upper portion
            newChunk = chunks ( chunk )
            newChunk%firstMAFIndex = lastMAF + 1
            newChunk%noMAFsLowerOverlap = 0
            if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
              & call AddChunkToDatabase ( chunks, newChunk )
            ! Delete the old chunk
            call DeleteChunk ( chunks, chunk )
          endif
d1460 4
a1463 28
          ! So the cases we have left do not involve deleting or creating new
          ! chunks, just modifying existing ones.  Note that this includes
          ! cases where a range starts end ends in a chunk but one or other boundary
          ! is in the overlap regions.

          ! Look for chunks where the range starts in the chunk
          moveEnd: do
            chunk = FindFirst ( &
              & chunks%firstMAFIndex <= firstMAF .and. &
              & chunks%lastMAFIndex >= firstMAF )
            if ( chunk == 0 ) exit moveEnd
            chunks(chunk)%noMAFsUpperOverlap = max ( 0, &
              & chunks(chunk)%noMAFsUpperOverlap - &
              &    ( chunks(chunk)%lastMAFIndex - (firstMAF-1) ) )
            chunks(chunk)%lastMAFIndex = firstMAF - 1
          end do moveEnd

          ! Look for chunks where the range ends in the chunk
          moveStart: do
            chunk = FindFirst ( &
              & chunks%firstMAFIndex <= lastMAF .and. &
              & chunks%lastMAFIndex >= lastMAF )
            if ( chunk == 0 ) exit moveStart
            chunks(chunk)%noMAFsLowerOverlap = max ( 0, &
              & chunks(chunk)%noMAFsLowerOverlap - &
              &    ( (lastMAF+1) - chunks(chunk)%firstMafIndex ) )
            chunks(chunk)%firstMAFIndex = lastMAF + 1
          end do moveStart
d1465 11
a1475 1
        else ! - - - - - - - - - - - - - - - - - - - - - - - - - - - -
d1477 38
a1514 2
          ! A wall obstruction
          maf = obstructions(obstruction)%mafs(1)
d1516 15
a1530 1
          ! First look for where the wall occurs in the non overlapped part
d1532 22
a1553 2
            & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap <= maf ) .and. &
            & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap >= maf ) )
d1555 4
a1558 16
          if ( chunk /= 0 ) then
            ! Create two new chunks with the wall between, first the lower portion
            newChunk = chunks ( chunk )
            newChunk%lastMAFIndex = maf - 1
            newChunk%noMAFsUpperOverlap = 0
            if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
              & call AddChunkToDatabase ( chunks, newChunk )
            ! Now the upper portion
            newChunk = chunks ( chunk )
            newChunk%firstMAFIndex = maf
            newChunk%noMAFsLowerOverlap = 0
            if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
              & call AddChunkToDatabase ( chunks, newChunk )
            ! Now delete the original chunk
            call DeleteChunk ( chunks, chunk )
          endif
d1560 11
a1570 38
          ! For chunks where the wall is in the overlap, just make the
          ! overlap shorter
          ! First the lower overlap
          wallInLower: do
            chunk = FindFirst ( &
              & ( chunks%firstMAFIndex < maf ) .and. &
              & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap > maf ) )
            if ( chunk == 0 ) exit wallInLower
            chunks(chunk)%noMAFsLowerOverlap = &
            & max ( chunks(chunk)%noMAFsLowerOverlap - &
            & ( maf - chunks(chunk)%firstMAFIndex ), 0 )
            chunks(chunk)%firstMAFIndex = maf
          end do wallInLower
          ! Now the upper overlap
          wallInUpper: do
            chunk = FindFirst ( &
              & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap < maf ) .and. &
              & ( chunks%lastMAFIndex > maf ) )
            if ( chunk == 0 ) exit wallInUpper
            chunks(chunk)%noMAFsUpperOverlap = &
              & max ( chunks(chunk)%noMAFsUpperOverlap - &
              & ( chunks(chunk)%lastMAFIndex - (maf-1) ), 0 )
            chunks(chunk)%lastMAFIndex = maf - 1
          end do wallInUpper
        end if  ! - - - - - - - - - - - - ! Wall obstructions

      end do                              ! Loop over obstructions

      ! Sort the chunks back into order
      call SortChunks ( chunks )

    end subroutine DealWithObstructions

    ! ------------------------------------------- SortObstructions -----
    subroutine SortObstructions ( obstructions )
      ! Sort the obstructions into order of increasing
      ! mafs(1) (start/wall MAF index)
      type (Obstruction_T), dimension(:), intent(inout) :: OBSTRUCTIONS
d1572 7
a1578 4
      ! Local variables
      type (Obstruction_T) :: TEMP
      integer :: I                        ! Loop counters
      integer, dimension(1) :: TOSWAP     ! Index
d1580 5
a1584 11
      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
      do i = 1, size(obstructions) - 1
        toSwap = minloc ( obstructions(i:)%mafs(1) ) + (/ i-1 /)
        if ( toSwap(1) /= i ) then
          temp = obstructions(i)
          obstructions(i) = obstructions(toSwap(1))
          obstructions(toSwap(1)) = temp
        end if
      end do
    end subroutine SortObstructions
d1586 28
a1613 7
    ! ------------------------------------------ DeleteObstruction -----
    subroutine DeleteObstruction ( obstructions, index )
      ! Dummy arguments
      use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
      type (Obstruction_T), pointer, dimension(:) :: OBSTRUCTIONS
      integer, intent(in) :: INDEX
d1615 54
a1668 56
      ! Local variables
      type (Obstruction_T), pointer, dimension(:) :: TEMP
      integer(c_intptr_t) :: Addr    ! For tracing
      integer :: S                   ! Size in bytes of object to deallocate
      integer :: STATUS              ! From allocate

      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
      allocate ( temp ( size(obstructions) - 1 ), stat=status )
      addr = 0
      if ( status == 0 .and. size(obstructions) > 0 ) addr = transfer(c_loc(temp(1)), addr )
      call test_allocate ( status, ModuleName, 'temp', &
        & uBounds = size(obstructions) - 1, &
        & elementSize = storage_size(temp) / 8, address=addr )

      if ( index > 1 ) temp(1:index-1) = obstructions(1:index-1)
      if ( index < size(obstructions) .and. size(obstructions) > 1 ) &
        & temp(index:) = obstructions(index+1:)

      s = size(obstructions) * storage_size(obstructions) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(obstructions(1)), addr )
      deallocate ( obstructions, stat=status )
      call test_deallocate ( status, moduleName, 'obstructions', s, address=addr )

      obstructions => temp

    end subroutine DeleteObstruction

    ! ----------------------------------------- ChooseCriticalSignals -----------
    subroutine ChooseCriticalSignals ( criticalSignals )
      use MLSSignals_m, only: Dump_Signals, GetSignalName, Signals
      use MLSStringLists, only: CatLists, List2Array
      use MLSStrings, only: Lowercase

      ! Args
      character(len=160), dimension(:), pointer :: criticalSignals
      ! Internal variables
      character(len=40) :: critical_module_str
      integer, parameter :: MAXCRITICALSIGNALLENGTH = 40000
      character(len=MAXCRITICALSIGNALLENGTH) :: criticalSignalStr
      character(len=40) :: module_str
      integer :: numCriticalSignals
      character(len=40) :: signal_full
      integer :: signalIndex
      logical, dimension(:), pointer :: isSignalcritical => null()
      ! Executable
      swlevel = switchDetail(switches, 'chu' )
      if ( ChunkDivideConfig%criticalModules == l_none .and. &
        & len_trim(ChunkDivideConfig%criticalBands) < 1 ) return
      critical_module_str = ' '
      if ( ChunkDivideConfig%criticalModules /= l_none ) then
        call get_string( lit_indices(ChunkDivideConfig%criticalModules), signal_full, &
          & strip=.true. )
        critical_module_str = lowercase(signal_full)
        if ( critical_module_str /= 'ghz' ) return
d1670 31
a1700 64
      criticalSignalStr = ' '
      numCriticalSignals = 0
      if ( swLevel > -1 ) &
        & call outputNamedValue( 'critical module', critical_module_str )
      if ( swLevel > -1 ) &
        & call outputNamedValue( 'critical bands', ChunkDivideConfig%criticalBands )
      if ( swLevel > -1 ) &
        & call outputNamedValue( 'size(signals)', size(signals) )
      call allocate_test( isSignalCritical, size(signals), 'isSignalCritical', &
        & ModuleName )
      do signalIndex=1, size(signals)
        isSignalCritical(signalIndex) = &
          & .not. isNotACriticalBand( signals(signalIndex)%Band )
        if ( swLevel > -1 .and. .false. ) then
          call outputNamedValue( 'signal index', signalIndex )
          call GetSignalName( signalIndex, signal_full )
          call outputNamedValue( 'signal', signal_full )
          call outputNamedValue( 'band', signals(signalIndex)%Band )
          call outputNamedValue( 'critical?', &
            & .not. isNotACriticalBand( signals(signalIndex)%Band ) )
          call get_string( modules(signals(signalIndex)%instrumentModule)%name, &
            &  module_str, strip=.true. )
          call outputNamedValue( 'module', module_str )
        endif
        if ( len_trim(ChunkDivideConfig%criticalBands) > 0 ) then
          ! See if the band is one of the critical bands
          if ( isNotACriticalBand( signals(signalIndex)%Band ) ) cycle
        elseif ( len_trim(critical_module_str) > 0 ) then
          call get_string( modules(signals(signalIndex)%instrumentModule)%name, &
            & signal_full, strip=.true. )
          module_str = lowercase(signal_full)
          if ( module_str /= critical_module_str ) cycle
        endif
        numCriticalSignals = numCriticalSignals + 1
        call GetSignalName( signalIndex, signal_full )
        criticalSignalStr = catLists( criticalSignalStr, signal_full )
      enddo
      if ( swLevel > -1 ) &
        call Dump_Signals( signals, isSignalCritical, 1 )
      call deallocate_test( isSignalCritical,'isSignalCritical', &
        & ModuleName )
      if ( numCriticalSignals < 1 ) return
      call allocate_test( criticalSignals, numCriticalSignals, 'criticalSignals', &
        & ModuleName )
      call List2Array (criticalSignalStr, criticalSignals,  countEmpty=.true. )
      if ( swLevel > -1 ) &
        & call dump( criticalSignals, 'critical Signals chosen', &
        & options=what_options(trim=.true.) )
    end subroutine ChooseCriticalSignals

    ! ----------------------------------------- NoteL1BRADChanges -----
    subroutine NoteL1BRADChanges ( obstructions, mafRange, filedatabase )
      use MLSSignals_M, only: Dumpsignals=>dump, Getsignalindex, Getsignalname, &
        & GetNameofsignal, Signals
      use MLSStringlists, only: NumstringElements, GetstringElement
      use MLSStrings, only: Lowercase
      use Parse_Signal_M, only: Parse_Signal
      ! This routine notes any lack of good data for one of the
      ! signals, and, depending on sensitivity,
      ! augments the database of obstructions
      type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
      type (Obstruction_T) :: NEWOBSTRUCTION ! In progrss
      type (MAFRange_T) :: MAFRange
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
d1702 74
a1775 67
      ! Local variables
      ! This next sets the threshold of what it takes to be an obstruction
      ! At the most sensitive, hair-trigger level, any change in goodness
      ! of any signal would suffice
      ! Otherwise, a dead-zone in any signal must persist for at least a
      ! duration of config%maxGap before we declare it an obstruction
      ! and add it to the database
      logical, parameter :: ANYCHANGEISOBSTRUCTION = .false.
      logical :: choseCriticalSignals
      integer :: critical_index
      character(len=40) :: critical_module_str
      integer, dimension(:), pointer            :: criticalIndices => null() ! taken from config or criticalModules
      character(len=160), dimension(:), pointer :: criticalSignals => null() ! taken from config or criticalModules
      integer :: critical_sub_index
      integer, pointer, dimension(:) :: goods_after_gap
      integer, pointer, dimension(:) :: goodness_changes
      logical, dimension(size(signals)) :: good_after_maxgap
      logical, dimension(size(signals)) :: good_signals_now
      logical, dimension(size(signals)) :: good_signals_last
      integer, dimension(size(signals)) :: howlong_nogood
      integer :: i
      integer :: maf              ! mafrange(1) <= maf <= mafrange(2)
      integer :: maf_index   ! 1 <= maf_index <= mafrange(2)-mafrange(1)+1
      integer :: mafset
      integer :: mafset_end
      integer :: mafset_start
      integer, parameter :: MAXMAFSINSET = 250
      character(len=40) :: module_str
      integer :: nmafs
      integer :: nmafsets
      integer :: num_goods_after_gap
      integer :: num_goodness_changes
      logical, dimension(:), pointer  :: or_valids_buffer
      integer :: SignalIndex
      character(len=40) :: signal_full
      character(len=40) :: signal_str
      integer, pointer :: Signal_Indices(:)         ! Indices in the signals
      logical, dimension(:,:), pointer  :: signals_buffer
      logical :: this_maf_valid
      logical, dimension(:), pointer  :: valids_buffer
      ! Won't check if there are no files at all
      if ( .not. associated(filedatabase) ) return
      ! Won't check if there are no radiance files
      if ( .not. any(filedatabase%content == 'l1brad') ) return
      swlevel = SwitchDetail(switches, 'chu')
      nmafs = mafRange%Expanded(2) - mafRange%Expanded(1) + 1
      choseCriticalSignals = .false.
      ! Here we will loop over the signals database
      ! Searching for
      ! (1) mafs where there is no good data for any of the signals
      ! (2) mafs where the good data is switched from one signal to another
      ! (See Construct QuantityTemplates below line 253)

      ! (Possibly) time-consuming step:
      ! Read through the l1b radiance files for all signals,
      ! noting which ones are good, which not

      nullify ( signals_buffer, goods_after_gap, goodness_changes )
      call allocate_test( &
        & signals_buffer, nmafs , size(signals), &
        & 'signals_buffer', ModuleName )
      call allocate_test( goods_after_gap, nmafs,&
        & 'goods_after_gap', ModuleName )
      call allocate_test( goodness_changes, nmafs,&
        & 'goodness_changes', ModuleName )
      good_signals_now = .false.   ! Initializing
      signals_buffer = .false.
d1777 2
a1778 19
        call outputNamedValue ( 'shape(signals_buffer)', shape(signals_buffer) )
        call outputNamedValue ( 'shape(goods_after_gap)', shape(goods_after_gap) )
        call outputNamedValue ( 'shape(goodness_changes)', shape(goodness_changes) )
      endif
      if ( associated(ChunkDivideConfig%criticalSignals) ) then
        criticalSignals => ChunkDivideConfig%criticalSignals
        if ( swLevel > -1 ) then
          call output('Critical Signals from config', advance='yes' )
          call Dump (  criticalSignals )
        endif
      elseif ( ChunkDivideConfig%chooseCriticalSignals ) then
        ! We can choose as critical signals all the signals belonging
        ! to a critical module
        call chooseCriticalSignals( criticalSignals )
        choseCriticalSignals = .true.
        if ( swLevel > -1 ) then
          call output('Critical Signals you chose', advance='yes' )
          call Dump (  criticalSignals )
        endif
d1780 8
a1787 16
      ! We'll need the index number for each of the critical signals
      call allocate_test( criticalIndices, size(criticalSignals),&
        & 'critical indices', ModuleName )
      do critical_index = 1, size(criticalSignals)
        call GetSignalIndex( criticalSignals(critical_index), &
          & criticalIndices(critical_index) )
        if ( swLevel < VERBOSETHRESHOLD ) cycle
        call outputnamedValue( 'critical signal string', criticalSignals(critical_index) )
        call outputnamedValue( 'its index', criticalIndices(critical_index) )
      enddo
      if ( swLevel >= VERBOSETHRESHOLD ) then
        ! call dumpSignals( signals )
        call GetNameOfSignal ( signals(1), signal_str )
        call outputnamedValue( 'signal(1)%name', signal_str )
        call dump( criticalSignals, 'criticalSignals' )
        call dump( criticalIndices, 'criticalIndices' )
d1789 51
a1839 23
      do signalIndex=1, size(signals)
        call get_string( lit_indices(ChunkDivideConfig%criticalModules), &
          & signal_full, &
          & strip=.true. )
        critical_module_str = lowercase(signal_full)
        call get_string( modules(signals(signalIndex)%instrumentModule)%name, &
          & signal_full, &
          & strip=.true. )
        module_str = lowercase(signal_full)
        if ( swLevel >= VERBOSETHRESHOLD ) &
          & call outputNamedValue( 'module', module_str )
        if ( ChunkDivideConfig%criticalModules == l_none ) then
          ! No module is critical for signal data being good
        elseif ( module_str /= critical_module_str ) then
          cycle
        elseif ( .not. any(signalIndex == criticalIndices) ) then
          cycle
        endif
        if ( swLevel >= VERBOSETHRESHOLD ) &
          & call dumpSignals( signals(signalIndex) )
        if ( swLevel >= VERBOSETHRESHOLD ) &
          & call outputNamedValue( 'critical module', critical_module_str )
        if ( nmafs <= MAXMAFSINSET ) then
d1841 3
a1843 2
            & any_good_signaldata ( signalIndex, signals(signalIndex)%sideband, &
            &   filedatabase, mafRange%Expanded(1), mafRange%Expanded(2), &
d1845 30
a1874 13
        else
          nmafsets = (nmafs-1)/MAXMAFSINSET + 1   ! A trick--mafset_start
          mafset_end = mafRange%Expanded(1) - 1   ! is mafRange(1)
          do mafset=1, nmafsets
            mafset_start = mafset_end + 1
            mafset_end = min ( mafRange%Expanded(2), mafset_end + MAXMAFSINSET )
            good_signals_now(signalIndex) = &
              &   any_good_signaldata ( signalIndex, &
              &   signals(signalIndex)%sideband, &
              &   filedatabase, mafset_start, mafset_end, &
              &   signals_buffer(:,signalIndex), mafRange%Expanded )
          enddo
        endif
d1876 4
a1879 33
      if ( swlevel > -1 ) &
        & call outputNamedValue ( 'shape(signals_buffer)', shape(signals_buffer) )
      if ( swlevel >= VERBOSETHRESHOLD ) &
        & call dump ( signals_buffer, 'signals_buffer' )

      ! Task (1a): Find mafs where there is at least one signal which
      ! changes from either nogood to good or from good to nogood
      ! compared with the last maf
      ! Task (1b): Find mafs where there is at least one signal which
      ! changes from nogood to good after a dead zone
      ! lasting at least maxGap mafs
      num_goodness_changes = 0
      num_goods_after_gap = 0
      howlong_nogood       = 0
      good_after_maxgap = .false.
      do maf = mafRange%Expanded(1), mafRange%Expanded(2)
        maf_index = maf - mafRange%Expanded(1) + 1
        do signalIndex=1, size(signals)
          if ( .not. any(signalIndex == criticalIndices) ) cycle
          good_signals_now(signalIndex) = signals_buffer(maf_index, signalIndex)
          if ( .not. good_signals_now(signalIndex) ) &
            & howlong_nogood(signalIndex) = howlong_nogood(signalIndex) + 1
          good_after_maxgap(signalIndex) = &
            & good_signals_now(signalIndex) &
            & .and. &
            & ( howlong_nogood(signalIndex) > ChunkDivideConfig%maxGap )
          if ( good_signals_now(signalIndex) ) howlong_nogood(signalIndex) = 0
        enddo
        if ( maf /= mafRange%Expanded(1) ) then
          if ( Any(good_signals_now .neqv. good_signals_last) ) then
            num_goodness_changes = num_goodness_changes + 1
            goodness_changes(num_goodness_changes) = maf
          endif
d1881 8
a1888 7
        if ( Any(good_after_maxgap) ) then
          num_goods_after_gap = num_goods_after_gap + 1
          goods_after_gap(num_goods_after_gap) = maf
        endif
        good_signals_last = good_signals_now
      enddo
      call outputNamedValue( 'num_goods_after_gap', num_goods_after_gap )
d1890 32
a1921 40
      ! Task (2): Find regions where there is no signal among at least one
      ! of the critical signals
      if ( associated(criticalSignals) ) then
        ! What we're about to do is:
        ! Assume we're given an array of char strings
        ! array = [str_1, str_2, ..]
        ! and each string contains comma-separated signals
        ! str_1 = 'sig_1,sig_2,..'
        ! Then the rule is that for a maf to pass the critical signals test,
        ! for each array element at least one of the signals within that
        ! string must be turned on for that maf
        ! Thus the shorthand formula that we're and-ing the array elements
        ! and or-ing the list elements
        ! You might prefer the formula that a maf is invalid if for any of the
        ! array elements, none of its signals is turned on
        !
        ! Unfortunately, if we chose our critical signals based on a critical module
        ! the role the string containing comma-separated signals is played by
        ! by the array so in that case we'll need to be or-ing the array elements,
        ! not and-ing them
        nullify ( valids_buffer )
        call allocate_test( &
          & valids_buffer, nmafs , &
          & 'valids_buffer', ModuleName)
        nullify ( or_valids_buffer )
        call allocate_test( &
          & or_valids_buffer, nmafs , &
          & 'or_valids_buffer', ModuleName)
        !
        valids_buffer = .not. choseCriticalSignals ! .true.
        if ( SwLevel >= VERBOSETHRESHOLD ) then
          call output ( 'Checking for critical signals: ')
          do critical_index=1, size(criticalSignals)
            call output ( trim(criticalSignals(critical_index)), &
              & advance='yes')
          enddo
          call output ( &
            & 'Which signals match the incomplete signal string ' &
            &  // 'weve been given', advance='yes')
        endif
d1923 34
a1956 29
          or_valids_buffer = .false.
          do critical_sub_index=1, NumStringElements( &
            & trim(criticalSignals(critical_index)), .FALSE.)
            call GetStringElement( &
              & trim(criticalSignals(critical_index)), signal_str, &
              & critical_sub_index, .FALSE. )
            ! Which signals match the incomplete signal string we've been given?
            nullify(Signal_Indices)
            call Parse_signal(signal_str, signal_indices)
            if ( .not. associated(Signal_Indices) ) exit
            if ( SwLevel >= VERBOSETHRESHOLD ) then
              call output ( 'Signal_Indices: ')
              call output ( Signal_Indices, advance='yes')
              do i=1, size(Signal_Indices)
                call GetSignalName(Signal_Indices(i), signal_full)
                call output ( 'Full Signal Name: ')
                call output ( trim(signal_full), advance='yes')
              enddo
            endif
            do maf = mafRange%Expanded(1), mafRange%Expanded(2)
              maf_index = maf - mafRange%Expanded(1) + 1
              this_maf_valid = .false.   ! not valid unless at least one signal
              do i=1, size(Signal_Indices)
                signalIndex = Signal_Indices(i)
                this_maf_valid = &
                  & this_maf_valid .or. signals_buffer(maf_index, signalIndex)
              enddo
              or_valids_buffer(maf_index) = &
                & or_valids_buffer(maf_index) .or. this_maf_valid
d1958 2
a1959 1
            call deallocate_test(Signal_Indices, 'Signal_Indices', ModuleName)
d1961 1
a1961 12
          ! An ad-hoc filter to ignore bands that are simply switched off
          ! if ( swLevel > -1 ) call outputNamedValue ( 'count(or_valids_buffer)', count(or_valids_buffer), advance='yes')
          ! if ( count(or_valids_buffer) < &
          !  & ( mafRange%Expanded(2) - mafRange%Expanded(1) ) / 50 ) cycle
          ! call dump ( or_valids_buffer, 'or_valids_buffer' )
          if ( choseCriticalSignals ) then
            valids_buffer = &
              & valids_buffer .or. or_valids_buffer
          else
            valids_buffer = &
              & valids_buffer .and. or_valids_buffer
          endif
d1963 11
a1973 5
        if ( swLevel >= VERBOSETHRESHOLD ) call dump ( valids_buffer, 'valids_buffer' )
        if ( swLevel > -1 ) then
          call outputNamedValue ( 'count(valids_buffer)', count(valids_buffer), advance='yes')
          call output ( 'Before converting valids to obstructions', advance='yes' )
          call dump(obstructions)
d1975 12
a1986 11
        call ConvertFlagsToObstructions ( valids_buffer, obstructions, &
          & mafRange%Expanded, obstructionType='critical radiances' )
        if ( swLevel > -1 ) then
          call output ( 'After converting valids to obstructions', advance='yes' )
          call dump(obstructions)
        endif
        call deallocate_test(valids_buffer, 'valids_buffer', ModuleName)
        call deallocate_test(or_valids_buffer, 'or_valids_buffer', ModuleName)
        if ( .not. associated(ChunkDivideConfig%criticalSignals) )  &
          & call deallocate_test( criticalSignals, 'criticalSignals', &
          & ModuleName )
d1988 52
d2041 20
a2060 16
      ! Depending on sensitivity, add these to Obstructions database
      if ( ANYCHANGEISOBSTRUCTION .and. num_goodness_changes > 0 ) then
        do mafset = 1, num_goodness_changes
          newObstruction%range = .false.
          newObstruction%mafs(1) = goodness_changes(mafset)
          newObstruction%mafs(2) = 0    ! For overzealous Lahey uninitialized checking
          call AddObstructionToDatabase ( obstructions, newObstruction )
          if ( swLevel > -1 ) &
            call outputNamedValue( &
            & 'maf where any change made obstruction', goodness_changes(mafset) )
        enddo
      elseif ( num_goods_after_gap > 0 ) then
        do mafset = 1, num_goods_after_gap
          newObstruction%range = .false.
          newObstruction%mafs(1) = goods_after_gap(mafset)
          newObstruction%mafs(2) = 0    ! For overzealous Lahey uninitialized checking
d2064 1
a2064 52
            & 'maf where num goods after gap made obstruction', goods_after_gap(mafset) )
        enddo
      endif
      ! OK, we have the mafs where the goodness changes, now what?
      call deallocate_test( signals_buffer, 'signals_buffer', ModuleName )
      call deallocate_test( goods_after_gap, 'goods_after_gap', ModuleName )
      call deallocate_test( goodness_changes, 'goodness_changes', ModuleName )
      call deallocate_test( criticalIndices, 'critical indices', ModuleName )
    end subroutine NoteL1BRADChanges

    ! --------------------------------- ConvertFlagsToObstructions -----
    subroutine ConvertFlagsToObstructions ( valid, obstructions, &
      & mafRange, obstructionType )
      ! This routine takes an array of logicals indicating good/bad data
      ! and converts it into obstruction information.
      logical, dimension(:), intent(in)           :: VALID
      type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
      integer, dimension(:), intent(in), optional :: MAFRANGE
      character(len=*), intent(in), optional      :: obstructionType

      ! Local variables
      logical :: LASTONEVALID           ! Flag
      integer :: MAF                    ! Loop counter
      type (Obstruction_T) :: NEWOBSTRUCTION ! In progrss
      character(len=64)    :: obstructionTrigger
      integer :: OFFSET                 ! MAF index offset

      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
      lastOneValid = .true.
      offset = 0
      if ( present(mafRange) ) offset = mafRange(1)
      obstructionTrigger = &
        & 'maf where transition from bad to good made obstruction'
      if ( present(obstructionType) ) obstructionTrigger = &
        & 'maf where transition from bad to good ' // trim(obstructionType) // &
        & 'made obstruction'

      do maf = 1, size(valid)
        if ( valid(maf) .neqv. lastOneValid ) then
          ! A transition either from good to bad or bad to good
          if ( .not. valid(maf) ) then
            ! From good to bad
            newObstruction%range = .true.
            newObstruction%mafs(1) = maf - 1 + offset
          else
            newObstruction%mafs(2) = maf - 2 + offset
            call AddObstructionToDatabase ( obstructions, newObstruction )
            if ( swLevel > -1 ) &
              call outputNamedValue( &
              & trim(obstructionTrigger), maf )
          end if
a2065 10
        lastOneValid = valid(maf)
      end do

      ! Make sure any range at the end gets added
      if ( .not. lastOneValid ) then
        newObstruction%mafs(2) = size(valid) - 1 + offset
        call AddObstructionToDatabase ( obstructions, newObstruction )
        if ( swLevel > -1 ) &
          call outputNamedValue( &
          & trim(obstructionTrigger), size(valid)-1 )
d2067 2
a2068 1
    end subroutine ConvertFlagsToObstructions
d2070 9
a2078 9
    ! ---------------------------------------------- SurveyL1BData -----
    subroutine SurveyL1BData ( processingRange, filedatabase, mafRange )
      ! This goes through the L1B data files and tries to spot possible
      ! obstructions.
      ! use MLSL2Options, only: sharedPCF
      use Monotone, only: isMonotonic
      type (TAI93_Range_T), intent(in) :: PROCESSINGRANGE
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (MAFRange_T), intent(out) :: MAFRange
d2080 9
a2088 22
      ! Local variables
      type (L1BData_T) :: TAITIME         ! Read from L1BOA file
      type (L1BData_T) :: TPGEODALT       ! Read from L1BOA file
      type (L1BData_T) :: TPGEODANGLE     ! Read from L1BOA file
      type (L1BData_T) :: TPORBY          ! Read from L1BOA file

      character(len=10) :: MODNAMESTR     ! Module name

      integer :: FLAG                     ! From L1B
      integer :: MAF                      ! Loop inductor
      integer :: MOD                      ! Loop inductor
      integer :: NOMAFS                   ! Number of MAFs in processing range
      integer :: NOMAFSREAD               ! From L1B

      logical :: THISONEVALID             ! To go into valid
      logical, dimension(:), pointer :: VALID ! Flag for each MAF
      logical, dimension(:), pointer :: WASSMOOTHED ! Flag for each MAF
      logical, dimension(:), pointer :: ANGLEWASSMOOTHED ! Flag for each MAF

      real(r8) :: SCANMAX                 ! Range of scan each maf
      real(r8) :: SCANMIN                 ! Range of scan each maf
      real(r8) :: ORBYMAX                 ! Maximum value of orbY each maf
d2090 28
a2117 5
      integer   ::                       l1b_hdf_version
      character(len=namelen) ::         MAF_start, tp_alt, tp_orbY, tp_angle
      type (MLSFile_T), pointer             :: L1BFile
      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
d2119 50
a2168 20
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      if ( .not. associated(L1BFile) ) &
        & call MLSMessage  ( MLSMSG_Error, ModuleName, &
          & "Can't make progress in SurveyL1BData without L1BOA files" )
      if ( swLevel > -1 ) then
        call output( 'here is the L1BOA', advance='yes' )
        call dump( L1BFile )
      endif
      l1b_hdf_version = L1BFile%HDFVersion
      MAF_start = AssembleL1BQtyName ( 'MAFStartTimeTAI', l1b_hdf_version, &
        .false. )
      ! tp_angle = &
      !  & AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
      !  & l1b_hdf_version, &
      !  & .false. )
      ! Read time from the L1BOA file
      call ReadL1BData ( L1BFile, trim(MAF_start), taiTime, &
        & noMAFsRead, flag, &
        & dontPad=DONTPAD )
      call smoothOutDroppedMAFs(taiTime%dpField)
d2170 26
a2195 28
      ! We shall assume that all l1b files cover this range
      mafRange%L1BCover(1) = taiTime%FirstMAF
      mafRange%L1BCover(2) = taiTime%NoMAFs - 1 ! Because it starts with 0

      ! Deduce the first and last MAFs covered the L2 Processing Range
      call Hunt ( taiTime%dpField(1,1,:), &
        & (/ processingRange%startTime, processingRange%endTime /), &
        & mafRange%L2Cover, allowTopValue=.true., allowBelowValue=.true. )

      ! Check the validity of the MAF range returned
      if ( mafRange%L2Cover(1) == taiTime%noMAFs ) then
        call outputNamedValue ( 'processingRange', &
          & (/ processingRange%startTime, processingRange%endTime /) )
        call outputNamedValue ( 'noMAFsRead', noMAFsRead )
        call dump ( taiTime%dpField(1,1,:), 'MAF_start' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L1B data ends before requested processing range' )
      endif
      if ( mafRange%L2Cover(1) == taiTime%noMAFs ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L1B data ends before requested processing range' )
      mafRange%L2Cover = min ( noMAFsRead-1, max ( 0, mafRange%L2Cover - 1 ) )          ! Index from zero
      if ( mafRange%L2Cover(2) < mafRange%L2Cover(1) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L2 mafRange(2) < L2 mafRange(1)' )
      elseif ( mafRange%L2Cover(2) < 1 ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L2 mafRange(2) < 1' )
d2197 30
a2226 59

      mafRange%Expanded(1) = mafRange%L2Cover(1)
      mafRange%Expanded(2) = mafRange%L2Cover(2)
      ! Expand the range covered by L2 with possible overlaps
      if ( ChunkDivideConfig%allowPriorOverlaps ) then
        mafRange%Expanded(1) = max( mafRange%L1BCover(1), &
          & mafRange%L2Cover(1) - nint(ChunkDivideConfig%lowerOverlap) )
      endif
      if ( ChunkDivideConfig%allowPostOverlaps ) then
        mafRange%Expanded(2) = min( mafRange%L1BCover(2), &
          & mafRange%L2Cover(2) + nint(ChunkDivideConfig%upperOverlap) )
      endif
      ! Why was this here? if ( sharedPCF ) return
      noMAFS = mafRange%Expanded(2) - mafRange%Expanded(1) + 1
      ! Now look through the L1B data, first look for scan problems
      if ( ChunkDivideConfig%criticalModules /= l_none ) then
        call outputNamedValue( 'Looking for scan problems; swLevel ', swlevel )
        nullify ( valid )
        nullify ( anglewasSmoothed )
        nullify ( wasSmoothed )
        call Allocate_test ( valid, noMAFs, 'valid', ModuleName )
        call Allocate_test ( anglewasSmoothed, noMAFs, 'angleWasSmoothed', ModuleName )
        call Allocate_test ( wasSmoothed, noMAFs, 'wasSmoothed', ModuleName )
        if ( ChunkDivideConfig%criticalModules == l_both ) then
          valid = .true.
        else
          valid = .false.
        endif
        do mod = 1, size(modules)
          call get_string ( modules(mod)%name, modNameStr, strip=.true. )
          tp_alt = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAlt', &
            & l1b_hdf_version, .false. )
          tp_orby = AssembleL1BQtyName ( trim(modNameStr)//'.tpOrbY', &
            & l1b_hdf_version, .false. )
          tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
            & l1b_hdf_version, .false. )
          if ( .not. modules(mod)%spacecraft .and. &
            & ( any ( ChunkDivideConfig%criticalModules == (/ l_either, l_both /) ) .or. &
            &   lit_indices(ChunkDivideConfig%criticalModules) == modules(mod)%name ) ) then
            ! Read the tangent point altitude
            call ReadL1BData ( L1BFile, trim(tp_alt), &
              & tpGeodAlt, noMAFsRead, flag, &
              & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
              & dontPad=DONTPAD )
            ! Read the out of plane distance
            call ReadL1BData ( L1BFile, trim(tp_orby), &
              & tpOrbY, noMAFsRead, flag, &
              & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
              & dontPad=DONTPAD )
            call ReadL1BData ( L1BFile, trim(tp_angle), &
              & tpGeodAngle, noMAFsRead, flag, &
              & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
              & dontPad=DONTPAD )
            if ( .not. ChunkDivideConfig%skipL1BCheck ) then
              if ( .not. isMonotonic(tpGeodAngle%dpField(1,1,1:noMAFsRead) ) &
                & ) then
                call MLSMessage ( PhiNotMonotonicFun(), ModuleName, &
                  & 'tpGeodAngle is not monotonic--may quit', MLSFile=L1BFile )
              endif
d2228 51
a2278 50
            call smoothOutDroppedMAFs(tpGeodAngle%dpField, angleWasSmoothed, &
              & monotonize=.true.)
            call smoothOutDroppedMAFs(tpGeodAlt%dpField, wasSmoothed)
            call smoothOutDroppedMAFs(tpOrbY%dpField)
            if ( swLevel > -1 ) then
              call dump( angleWasSmoothed, 'smoothed because of geodetic angle' )
              call dump( wasSmoothed, 'smoothed because of geodetic altitude' )
            endif
            wasSmoothed = (wasSmoothed .or. angleWasSmoothed)
            ! Consider the scan range in each MAF in turn
            do maf = 1, noMAFs
              scanMax = maxval ( tpGeodAlt%dpField(1,:,maf) )
              scanMin = minval ( tpGeodAlt%dpField(1,:,maf) )
              orbyMax = maxval ( tpOrbY%dpField(1,:,maf) )

              thisOneValid = ( &
                &   scanMin >= ChunkDivideConfig%scanLowerLimit(1) .and. &
                &   scanMin <= ChunkDivideConfig%scanLowerLimit(2) ) .and. ( &
                &   scanMax >= ChunkDivideConfig%scanUpperLimit(1) .and. &
                &   scanMax <= ChunkDivideConfig%scanUpperLimit(2) )
              if ( ChunkDivideConfig%maxOrbY > 0.0 ) then
                thisOneValid = thisOneValid .and. orbYMax < ChunkDivideConfig%maxOrbY
              end if
              ! this one is not valid if it's valid only by virtue
              ! of having been smoothed
              thisOneValid = thisOneValid .and. .not. wasSmoothed(maf)
              if ( ChunkDivideConfig%criticalModules == l_both ) then
                valid(maf) = valid(maf) .and. thisOneValid
              else
                valid(maf) = valid(maf) .or. thisOneValid
              end if
            end do                        ! Maf loop
            call DeallocateL1BData ( taiTime )
            call DeallocateL1BData ( tpgeodalt )
            call DeallocateL1BData ( tpgeodangle )
            call DeallocateL1BData ( tporby )
          end if                          ! Consider this module
        end do                            ! Module Loop
        ! Convert this information into obstructions and tidy up.
        call ConvertFlagsToObstructions ( valid, obstructions, &
          & obstructionType='scan' )
        call Deallocate_test ( valid, 'valid', ModuleName )
        call Deallocate_test ( wasSmoothed, 'wasSmoothed', ModuleName )
        call Deallocate_test ( angleWasSmoothed, 'angleWasSmoothed', ModuleName )
      end if                              ! Consider scan issues

      ! Here we look at radiances and switch changes.
      if ( swLevel > -1 ) call output ( 'NoteL1BRADChanges', advance='yes' )
      if ( .not. ChunkDivideConfig%skipL1BCheck ) &
        call NoteL1BRADChanges ( obstructions, mafRange, filedatabase )
d2280 2
a2281 2
      ! Sort the obstructions into order; prune them of repeats, overlaps etc.
      call PruneObstructions ( obstructions )
d2283 2
a2284 2
      ! Tidy up
      call DeallocateL1BData ( taiTime )
d2286 14
a2299 14
    contains
      function PhiNotMonotonicFun() result( SEVERITY )
      ! Default severity (probably ERROR) incurred
      ! if config options set the crashIfPhiNotMono flag
      ! Args
      integer :: SEVERITY
      ! if ( switchDetail(switches,'nmono') > -1 ) then ! be lenient
      if ( ChunkDivideConfig%crashIfPhiNotMono ) then ! be lenient
        severity = severityifphinotmono
      else
        severity = min( MLSMSG_Warning, severityifphinotmono )
      endif
      end function PhiNotMonotonicFun
    end subroutine SurveyL1BData
d2301 7
a2307 7
    ! ----------------------------------------- PruneObstructions -----
    subroutine PruneObstructions ( obstructions )
      ! This routine merges overlapping range obstructions and deletes
      ! wall obstructions inside ranges.  The job is made easier
      ! by sorting the obstructions into order
      use Allocate_Deallocate, only: Test_Allocate
      type(Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
d2309 5
a2313 5
      ! Local variables
      integer :: I,J                  ! Loop counters
      type (Obstruction_T) :: newObs  ! New Obstruction
      logical :: FOUNDONE             ! Found at least one
      integer :: STATUS               ! Flag from allocate
d2315 9
a2323 9
      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
      ! If no obstructions make sure allocate to size zero, not just unassociated pointer
      if ( .not. associated(obstructions) ) then
        allocate ( obstructions(0), stat=status )
        call test_allocate ( status, ModuleName, 'obstructions', &
          & uBounds = 0, elementSize = storage_size(obstructions) / 8 )
        return
      end if
d2325 48
a2372 49
      ! Otherwise, do the tidying up
      outerLoop: do
        foundOne = .false.
        i = 0
        call SortObstructions(obstructions)
        middleLoop: do
          i = i + 1
          if ( i >= size(obstructions) ) exit middleLoop
          j = i
          innerLoop: do
            j = j + 1
            if ( j > size(obstructions) ) exit innerLoop
            if ( all ( obstructions((/i,j/))%range ) ) then
              ! --------------------------- ( Range, range )
              if ( obstructions(j)%mafs(1) <= obstructions(i)%mafs(2) + 1 ) then
                ! Combine overlapping range obstructions
                newObs%range = .true.
                newObs%mafs(1) = obstructions(i)%mafs(1)
                newObs%mafs(2) = &
                  & max ( obstructions(i)%mafs(2), obstructions(j)%mafs(2) )
                ! Must delete these in order: otherwise
                ! if deleted i first where i < j, index would
                ! no longer be "j" afterwards
                call DeleteObstruction ( obstructions, j )
                call DeleteObstruction ( obstructions, i )
                call AddObstructionToDatabase ( obstructions, newObs )
                call SortObstructions ( obstructions )
                foundOne = .true.
                exit middleLoop
              end if
            else if ( obstructions(i)%range .and. .not. obstructions(j)%range ) then
              ! --------------------------- ( Range, wall )
              if ( obstructions(j)%mafs(1) >= obstructions(i)%mafs(1) .and. &
                &  obstructions(j)%mafs(1) <= obstructions(i)%mafs(2) + 1 ) then
                ! Delete wall obstruction inside range
                call DeleteObstruction ( obstructions, j )
                foundOne = .true.
                exit middleLoop
              end if
            else
              ! --------------------------- ( Wall, range ) or ( Wall, wall )
              ! Becuase the obstructions are in order, we know in the wall, range
              ! case that the wall must be at the start of the range, not inside it.
              if ( obstructions(i)%mafs(1) == obstructions(j)%mafs(1) ) then
                ! Delete wall obstruction at start of a range or at another wall
                call DeleteObstruction ( obstructions, i )
                foundOne = .true.
                exit middleLoop
              end if
d2374 22
a2395 8
            ! I'm pretty sure this covers all the possibilities.  It might seem
            ! not at first glance, but I think the fact that I always re-sort the
            ! obstructions into order means that the above code does catch everything.

          end do innerLoop
        end do middleLoop
        if ( .not. foundOne ) exit outerLoop
      end do outerLoop
d2397 6
a2402 1
    end subroutine PruneObstructions
d2404 1
a2404 8
    !----------------------------------------- ChunkDivide_Orbital -----
    subroutine ChunkDivide_Orbital ( mafRange, filedatabase, chunks )
      ! integer, dimension(2), intent(in) :: MAFRANGE
      use Allocate_Deallocate, only: Test_Allocate
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
      type (MAFRange_T) :: MAFRange
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (MLSChunk_T), dimension(:), pointer :: CHUNKS
d2406 36
a2441 6
      ! Local parameters
      real(r8), parameter :: HOMEACCURACY = 3.0 ! Try to hit homeGeodAngle within this
      ! (see homeHuntLoop warning below)
      ! Local variables
      type (L1BData_T) :: TAITIME         ! From L1BOA
      type (L1BData_T) :: TPGEODANGLE     ! From L1BOA
d2443 3
a2445 1
      character(len=10) :: MODNAMESTR     ! Home module name as string
d2447 57
a2503 15
      integer(c_intptr_t) :: Addr         ! For tracing
      integer :: CHUNK                    ! Loop counter
      integer :: FLAG                     ! From ReadL1B
      integer :: HOME                     ! Index of home MAF in array
      integer :: M1, M2                   ! MafRange%L2Cover + 1
      integer :: MEXP1, MEXP2             ! MafRange%Expanded + 1
      integer :: NOCHUNKSBELOWHOME        ! Used for placing chunks
      integer :: NOMAFSATORABOVEHOME      ! Fairly self descriptive
      integer :: NOMAFSBELOWHOME          ! Fairly self descriptive
      ! integer :: NOMAFS                   ! Number of MAFs to consider
      integer :: NOMAFSREAD               ! From ReadL1B
      integer :: ORBIT                    ! Used to locate home
      integer :: STATUS                   ! From allocate etc.
      integer :: NOCHUNKS                 ! Number of chunks
      integer :: MAXLENGTH                ! Max length as integer (MAFs)
d2505 10
a2514 2
      integer, dimension(:), pointer :: NEWFIRSTMAFS ! For thinking about overlaps
      integer, dimension(:), pointer :: NEWLASTMAFS ! For thinking about overlaps
d2516 52
a2567 9
      real(r8) :: ANGLEINCREMENT          ! Increment in hunt for home
      real(r8) :: MAXANGLE                ! Of range in data
      real(r8) :: MAXTIME                 ! Time range in data
      real(r8) :: MAXV                    ! Either minTime or minAngle
      real(r8) :: MINANGLE                ! Of range in data
      real(r8) :: MINTIME                 ! Time range in data
      real(r8) :: MINV                    ! Either minTime or minAngle
      real(r8) :: TESTANGLE               ! Angle to check for
      real(r8) :: HOMEV                   ! Value of angle/time at home
d2569 19
a2587 2
      real(r8), dimension(:), pointer :: BOUNDARIES ! Used in placing chunks
      real(r8), dimension(:), pointer :: FIELD ! Used in placing chunks
d2589 6
a2594 3
      integer   ::                       l1b_hdf_version
      character(len=namelen) ::         MAF_start, tp_angle
      type (MLSFile_T), pointer             :: L1BFile
d2596 21
a2616 41
      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
      if ( swLevel > -1 ) then
        call output('Entering Orbital Chunk Divide', advance='yes')
        call dump( obstructions )
      endif
      ! Read in the data we're going to need
      call get_string ( lit_indices(ChunkDivideConfig%homeModule), modNameStr, strip=.true. )
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      if ( .not. associated(L1BFile) ) &
        & call MLSMessage  ( MLSMSG_Error, ModuleName, &
          & "Can't make progress in ChunkDivide_Orbital without L1BOA files" )
      ! call dump(L1BFile)
      l1b_hdf_version = L1BFile%HDFVersion
      MAF_start = AssembleL1BQtyName ( 'MAFStartTimeTAI', l1b_hdf_version, &
        .false. )
      tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
        & l1b_hdf_version, &
        & .false. )
      if ( swLevel > -1 ) &
        & call output('Reading Geod Angle', advance='yes')
      call ReadL1BData ( L1BFile, trim(tp_angle), &
        & tpGeodAngle, noMAFsRead, flag, &
        & dontPad=DONTPAD )
      if ( swLevel > -1 ) &
        & call output('1st smoothing', advance='yes')
      call smoothOutDroppedMAFs(tpGeodAngle%dpField)
      if ( swLevel > -1 ) &
        & call output('2nd smoothing', advance='yes')
      call smoothOutDroppedMAFs(tpGeodAngle%dpField, monotonize=.true.)
      if ( swLevel > -1 ) &
        & call output('Reading tai Time', advance='yes')
      call ReadL1BData ( L1BFile, trim(MAF_start), &
        & taiTime, noMAFsRead, flag, &
        & dontPad=DONTPAD )
      call smoothOutDroppedMAFs(taiTime%dpField)
      ! noMAFs = mafRange%L2Cover(2) - mafRange%L2Cover(1) + 1
      m1 = mafRange%L2Cover(1) + 1
      m2 = mafRange%L2Cover(2) + 1
      mexp1 = mafRange%Expanded(1) + 1
      mexp2 = mafRange%Expanded(2) + 1
d2618 19
a2636 15
      minAngle = minval ( tpGeodAngle%dpField(1,1,m1:m2) )
      maxAngle = maxval ( tpGeodAngle%dpField(1,1,m1:m2) )
      minTime = minval ( taiTime%dpField(1,1,m1:m2) )
      maxTime = maxval ( taiTime%dpField(1,1,m1:m2) )
      if ( swLevel > -1 ) then
        call output ( 'Num MAFs in file: ' )
        call output ( noMAFsRead, advance='yes' )
        call output ( 'MAF time range: ' )
        call output ( minTime )
        call output ( ' : ' )
        call output ( maxTime, advance='yes' )
        call output ( 'Angle range: ' )
        call output ( minAngle )
        call output ( ' : ' )
        call output ( maxAngle, advance='yes' )
d2639 28
a2666 5
      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! First try to locate the last MAF before the homeGeodAngle
      orbit = int ( tpGeodAngle%dpField(1,1,m1)/360.0 )
      if ( tpGeodAngle%dpField(1,1,m1) < 0.0 ) orbit = orbit - 1
      testAngle = ChunkDivideConfig%homeGeodAngle + orbit*360.0
d2668 3
a2670 1
        angleIncrement = ChunkDivideConfig%maxLength
d2672 3
a2674 2
        angleIncrement = 360.0
      end if
d2676 1
d2678 18
a2695 50
        call output ( ' orbit  ', advance='no' )
        call output ( orbit , advance='no' )
        call output ( '    testAngle  ', advance='no' )
        call output ( testAngle , advance='no' )
        call output ( '    angleIncrement  ', advance='no' )
        call output ( angleIncrement , advance='yes' )
      end if
      ! In my opinion (paw) here's what the following loop should do:
      ! Find the 1st MAF within HOMEACCURACY of home_angle
      ! where home_angle has been corrected for the starting orbit number
      ! Afterwards, the preceding MAFs must be divided among one or more
      ! chunks, and the same done with subsequent MAFs
      !
      ! Instead what it actually does is
      ! Find the 1st MAF within HOMEACCURACY of (home_angle + n*angleIncrement)
      ! where home_angle has been corrected for the starting orbit number
      ! In effect the home_angle is set only within an unknown number
      ! of angleIncrements
      ! While there may be few cases in which they don't do about as well
      ! let this be a warning
      homeHuntLoop: do
        if ( testAngle < minAngle ) then
          testAngle = testAngle + angleIncrement
          cycle
        endif
        if ( testAngle > maxAngle ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Unable to establish a home major frame, using the first in your range' )
          home = m1
          exit homeHuntLoop
        end if
        ! Find MAF which starts before this test angle
        call Hunt ( tpGeodAngle%dpField(1,1,:), testAngle, home, nearest=.true.,&
          & allowTopValue = .true. )
        ! Now if this is close enough, accept it
        if ( abs ( tpGeodAngle%dpField(1,1,home) - &
          & testAngle ) < HomeAccuracy ) exit homeHuntLoop
        ! Otherwise, keep looking
        testAngle = testAngle + angleIncrement
      end do homeHuntLoop
      if ( swLevel > -1 ) then
        call output ( 'Test Angle  ' )
        call output ( testAngle , advance='yes' )
        call output ( 'Angle(home)  ' )
        call output ( tpGeodAngle%dpField(1,1,home) , advance='yes' )
        call output ( 'Home  ' )
        call output ( home  )
        call output ( 'Difference  ' )
        call output (  abs ( tpGeodAngle%dpField(1,1,home) - &
          & testAngle ) , advance='yes' )
d2698 4
a2701 19
      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! OK, now we have a home MAF, get a first cut for the chunks
      ! We work out the chunk ends for each chunk according to how the
      ! maxLength field is specified.
      if ( ChunkDivideConfig%maxLengthFamily == PHYQ_MAFs ) then
        maxLength = nint ( ChunkDivideConfig%maxLength )
        noMAFsBelowHome = home - m1
        noChunksBelowHome = noMAFsBelowHome / maxLength
        if ( mod ( noMAFsBelowHome, maxLength ) /= 0 ) noChunksBelowHome = noChunksBelowHome + 1
        noMAFsAtOrAboveHome = m2 - home + 1
        if ( ChunkDivideConfig%noChunks == 0 ) then
           ! If user did not request specific number of chunks choose them
           noChunks = noChunksBelowHome + noMAFsAtOrAboveHome / maxLength
           if ( mod ( noMAFsAtOrAboveHome, maxLength ) /= 0 ) &
              & noChunks = noChunks + 1
        else
          ! User requested specific number of chunks
          noChunks = ChunkDivideConfig%noChunks
        end if
d2703 24
a2726 6
        ! Allocate the chunks
        allocate ( chunks(noChunks), stat=status )
        addr = 0
        if ( status == 0 .and. noChunks > 0 ) addr = transfer(c_loc(chunks(1)), addr)
        call test_allocate ( status, ModuleName, 'chunks', &
          & uBounds = noChunks, elementSize = storage_size(chunks) / 8, address=addr )
d2728 5
a2732 21
        ! Work out their positions
        do chunk = 1, noChunks
          chunks(chunk)%lastMAFIndex = home + &
            & ( chunk - noChunksBelowHome ) * maxLength - 1
          ! Subtract one to convert from index in array to index in file
        end do
      else
        ! For angle and time, they are similar enough we'll just do some stuff
        ! with pointers to allow us to use common code to sort them out
        select case ( ChunkDivideConfig%maxLengthFamily )
        case ( PHYQ_Angle )
          field => tpGeodAngle%dpField(1,1,:)
          minV = minAngle
          maxV = maxAngle
        case ( PHYQ_Time )
          field => taiTime%dpField(1,1,:)
          minV = minTime
          maxV = maxTime
        case ( PHYQ_MAFs)
        end select
        homeV = field(home)
d2734 29
a2762 20
        noMAFsBelowHome = -999
        noMAFsAtOrAboveHome = -999
        noChunksBelowHome = int ( &
          & ( homeV - minV ) / ChunkDivideConfig%maxLength )
        if ( homeV > minV ) noChunksBelowHome = noChunksBelowHome + 1
        if ( ChunkDivideConfig%noChunks == 0 ) then
          ! Choose the number of chunks ourselves
          noChunks = noChunksBelowHome + int ( &
            & ( maxV - homeV ) / ChunkDivideConfig%maxLength )
          if ( homeV + ChunkDivideConfig%maxLength * &
            & ( noChunks - noChunksBelowHome ) < maxV ) &
            & noChunks = noChunks + 1
          if ( (mexp1 < m1) .and. ( &
            & homeV + (ChunkDivideConfig%maxLength-1) + &
            & ChunkDivideConfig%maxLength * &
            & ( noChunks - 1 - noChunksBelowHome ) < maxV ) ) &
            & noChunks = noChunks + 1
        else
          noChunks = ChunkDivideConfig%noChunks
        end if
d2764 9
a2772 36
        ! Allocate the chunks
        allocate ( chunks(noChunks), stat=status )
        addr = 0
        if ( status == 0 .and. noChunks > 0 ) addr = transfer(c_loc(chunks(1)), addr )
        call test_allocate ( status, ModuleName, 'chunks', &
          & uBounds = noChunks, elementSize = storage_size(chunks) / 8, address=addr )

        ! Work out their positions
        ! Boundaries are the angles/times at the end of the chunks
        nullify ( boundaries )
        call Allocate_test ( boundaries, noChunks, 'boundaries', ModuleName )
        ! When we allow prior overlaps, the first chunk
        ! sometimes has 1 too many MAFs unless we take extra care
        if ( mexp1 == m1 ) then
          do chunk = 1, noChunks
            boundaries(chunk) = homeV + &
              & ( chunk - noChunksBelowHome ) * ChunkDivideConfig%maxLength
          end do
        else
          boundaries(1) = homeV + &
            & ( 1 - noChunksBelowHome ) * (ChunkDivideConfig%maxLength - 1)
          do chunk = 2, noChunks
            boundaries(chunk) = boundaries(chunk-1) + &
              & ChunkDivideConfig%maxLength
          end do
        endif
        boundaries = min ( boundaries, maxV )
        boundaries = max ( boundaries, minV )
        if ( ChunkDivideConfig%maxLengthFamily == PHYQ_Angle ) then
          chunks(1)%phiStart = homeV
          chunks%phiEnd = boundaries
          chunks(2:noChunks)%phiStart = chunks(1:noChunks-1)%phiEnd
        else
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Regular HGrids will be unable to exploit chunk Geodetic Range' )
        endif
d2774 4
a2777 21
        ! Do some dumping
        if ( swLevel > -1 ) then
          call output ( ' minV: ' )
          call output ( minV  )
          call output ( ' maxV: ' )
          call output ( maxV , advance='yes' )
          call output ( ' homeV: ' )
          call output ( homeV , advance='yes' )
          call output ( ' noMAFSBelowHome: ' )
          call output ( noMAFsBelowHome, advance='yes' )
          call output ( ' noMAFSAtOrAboveHome: ' )
          call output ( noMAFsAtOrAboveHome, advance='yes' )
          call output ( ' NoChunks: ' )
          call output ( NoChunks, advance='yes' )
          call output ( ' noChunksBelowHome: ' )
          call output ( noChunksBelowHome , advance='yes' )
          call dump ( boundaries , 'boundaries' )
          call dump ( chunks%phiStart , 'phiStarts' )
          call dump ( chunks%phiEnd ,   'phiEnds' )
          call dump ( field, 'field' )
        end if
d2779 4
a2782 4
        call Hunt ( field, boundaries, chunks%lastMAFIndex, start=m1, &
          & allowTopValue=.true., nearest=.true. )
        call Deallocate_test ( boundaries, 'boundaries', ModuleName )
      end if
d2784 9
a2792 24
      ! Now deduce the chunk starts from the ends of their predecessors
      if ( noChunks > 1 ) &
        & chunks(2:noChunks)%firstMAFIndex = &
        & chunks(1:noChunks-1)%lastMAFIndex + 1
      chunks(1)%firstMAFIndex = m1

      ! Now bound the chunks to be within the processing range
      chunks%firstMAFIndex = min ( max ( chunks%firstMAFIndex, m1 ), m2 )
      chunks%lastMAFIndex = min ( max ( chunks%lastMAFIndex, m1 ), m2 )

      ! Now offset these to the index in the file not the array
      ! chunks%firstMAFIndex = chunks%firstMAFIndex + mafRange(1) - 1
      ! chunks%lastMAFIndex = chunks%lastMAFIndex + mafRange(1) - 1
      chunks%firstMAFIndex = chunks%firstMAFIndex - 1
      chunks%lastMAFIndex = chunks%lastMAFIndex - 1

      ! If at this point the last two chunks end in the same place, this is
      ! a subtle defect in our chunking algorihtm, lets avoid it
      if ( noChunks > 1 ) then
        if ( chunks(noChunks-1)%lastMAFIndex == chunks(noChunks)%lastMAFIndex ) then
          call DeleteChunk ( chunks, noChunks )
          noChunks = noChunks - 1
        end if
      end if
d2794 10
a2803 5
      ! Do some dumping
      if ( swLevel > -1 ) then
        call dump ( chunks%lastMAFIndex , 'chunks%lastMAFIndex' )
        call dump ( chunks%firstMAFIndex , 'chunks%firstMAFIndex' )
      end if
d2805 5
a2809 39
      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! Think about overlaps
      nullify ( newFirstMAFs, newLastMAFs )
      call Allocate_test ( newFirstMAFs, noChunks, 'newFirstMAFs', ModuleName )
      call Allocate_test ( newLastMAFs, noChunks, 'newLastMAFs', ModuleName )
      ! We could split things out to deal with mixed unit, but lets make life easier
      ! for ourselves.  ChunkDivideL2PC has already insisted that
      ! lowerOverlapFamily == upperOverlapFamily.
      if ( ChunkDivideConfig%lowerOverlapFamily == PHYQ_MAFs ) then
        newFirstMAFs = max(chunks%firstMAFIndex - nint(ChunkDivideConfig%lowerOverlap), &
          & m1 - 1 )
        newLastMAFs = min(chunks%lastMAFIndex + nint(ChunkDivideConfig%upperOverlap), &
          & m2 - 1 )
      else
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'The bit of code that deals with non-MAF overlaps is probably broken' )
      end if
      chunks%noMAFsLowerOverlap = chunks%firstMAFIndex - newFirstMAFs
      chunks%noMAFsUpperOverlap = newLastMAFs - chunks%lastMAFIndex
      chunks%firstMAFIndex = newFirstMAFs
      chunks%lastMAFIndex = newLastMAFs
      if ( swLevel > -1 ) then
        call dump ( newFirstMAFs , 'newFirstMAFs' )
        call dump ( newLastMAFs , 'newLastMAFs' )
        call dump ( chunks%noMAFsLowerOverlap , 'chunks%noMAFsLowerOverlap' )
        call dump ( chunks%noMAFsUpperOverlap , 'chunks%noMAFsUpperOverlap' )
      endif
      call Deallocate_test ( newFirstMAFs, 'newFirstMAFs', ModuleName )
      call Deallocate_test ( newLastMAFs, 'newLastMAFs', ModuleName )

      ! Delete any zero length or all overlapped chunks
      call PruneChunks ( chunks )
      if ( .not. associated(chunks) ) then
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'No chunks remaining after we pruned them for bad radiances; bad day?' )
      elseif ( size(chunks) < 1 ) then
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'No chunks remaining after we pruned them for bad radiances; bad day?' )
      endif
d2811 17
a2827 4
      if ( swLevel > -1 ) then
        call output ( 'Before dealing with obstructions', advance='yes' )
        call Dump ( chunks )
      end if
d2829 2
a2830 31
      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! Now think about the obstructions
      if ( associated(obstructions) ) &
        & call DealWithObstructions ( chunks, obstructions )

      ! Delete any zero length or all overlapped chunks
      call PruneChunks ( chunks )
      if ( .not. associated(chunks) ) then
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'No chunks remaining after we pruned them for zero length; bad day?' )
      elseif ( size(chunks) < 1 ) then
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'No chunks remaining after we pruned them for zero length; bad day?' )
      endif

!       ! Forcibly zero out number of lower (upper) overlaps on 1st (last) chunks
      noChunks = size ( chunks )
!       chunks(1)%noMAFsLowerOverlap = 0
!       chunks(noChunks)%noMAFsUpperOverlap = 0

      ! Add lower overlap to first chunk if allowed
      if ( mexp1 < m1 ) then
        chunks(1)%firstMAFIndex = chunks(1)%firstMAFIndex + mexp1 - m1
        chunks(1)%noMAFsLowerOverlap = m1 - mexp1
      endif

      ! Add upper overlap to last chunk if allowed
      if ( mexp2 > m2 ) then
        chunks(noChunks)%lastMAFIndex = chunks(noChunks)%lastMAFIndex + mexp2 - m2
        chunks(noChunks)%noMAFsUpperOverlap = mexp2 - m2
      endif
d2832 1
a2832 17
      ! Now we assign phiStarts and phiEnds to each chunk
      do chunk = 1, noChunks
        m1 = max( chunks(chunk)%firstMAFIndex + 1, mafRange%L2Cover(1) + 1 )
        m2 = min( chunks(chunk)%lastMAFIndex + 1,  mafRange%L2Cover(2) + 1 )
        chunks(chunk)%phiStart = tpGeodAngle%dpField(1,1,m1)
        chunks(chunk)%phiEnd = tpGeodAngle%dpField(1,1,m2)
      enddo
      if ( swLevel > -1 ) then
        call output ( 'After dealing with obstructions', advance='no' )
        call output ( ', poss. overlaps outside proc. range', advance='yes' )
        call Dump ( chunks )
        call dump ( chunks%phiStart , 'phiStarts' )
        call dump ( chunks%phiEnd ,   'phiEnds' )
      endif
      ! Tidy up
      call DeallocateL1BData ( tpGeodAngle )
      call DeallocateL1BData ( taiTime )
d2834 4
a2837 1
    end subroutine ChunkDivide_Orbital
d2839 4
a2842 4
    ! ------------------------------------------------- SortChunks -----
    subroutine SortChunks ( chunks )
      ! Sort the chunks into order of increasing firstMAFIndex
      type (MLSChunk_T), dimension(:), intent(inout) :: CHUNKS
d2844 12
a2855 4
      ! Local variables
      type (MLSChunk_T) :: TEMP
      integer :: I                        ! Loop counters
      integer, dimension(1) :: TOSWAP     ! Index
d2857 25
a2881 12
      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
      do i = 1, size(chunks) - 1
        toSwap = minloc ( chunks(i:)%firstMAFIndex + &
          & chunks(i:)%noMAFsLowerOverlap ) + (/ i-1 /)
        if ( toSwap(1) /= i ) then
          temp = chunks(i)
          chunks(i) = chunks(toSwap(1))
          chunks(toSwap(1)) = temp
        end if
      end do
    end subroutine SortChunks
d2883 5
a2887 17
    ! ----------------------------------------- PruneChunks -----------
    subroutine PruneChunks ( chunks )
       type (MLSChunk_T), dimension(:), pointer :: CHUNKS
       integer :: CHUNK
       ! Now delete chunks that either:
       !  1 - Are nothing but overlap
       !  2 - Have <=0 MAFs
       pruneChunksLoop: do
          chunk = FindFirst ( &
             & ( chunks%noMAFsLowerOverlap + chunks%noMAFsUpperOverlap ) >= &
             & ( chunks%lastMAFIndex - chunks%firstMAFIndex + 1 ) &
             & .or.&
             & ( chunks%firstMAFIndex > chunks%lastMAFIndex ) )
          if ( chunk == 0 ) exit pruneChunksLoop
          call DeleteChunk ( chunks, chunk )
       end do pruneChunksLoop
    end subroutine PruneChunks
d2889 8
a2896 13
    ! ------------------------------------------------ DeleteChunk -----
    subroutine DeleteChunk ( chunks, index )
      use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
      ! Dummy arguments
      type (MLSChunk_T), pointer, dimension(:) :: CHUNKS
      integer, intent(in) :: INDEX

      ! Local variables
      type (MLSChunk_T), pointer, dimension(:) :: TEMP
      integer(c_intptr_t) :: Addr ! For tracing
      integer :: S                ! Size in bytes of object to deallocate
      integer :: STATUS           ! From allocate
d2898 3
a2900 12
      ! Executable code
      swlevel = switchDetail(switches, 'chu' )
      allocate ( temp ( size(chunks) - 1 ), stat=status )
      addr = 0
      if ( status == 0 .and. size(chunks) > 1 ) addr = transfer(c_loc(temp(1)), addr)
      call test_allocate ( status, ModuleName, 'temp', &
        & uBounds = size(chunks) - 1, elementSize = storage_size(temp) / 8, &
        & address=addr )

      if ( index > 1 ) temp(1:index-1) = chunks(1:index-1)
      if ( index < size(chunks) .and. size(chunks) > 1 ) &
         & temp(index:) = chunks(index+1:)
d2902 5
a2906 5
      s = size(chunks) * storage_size(chunks) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(chunks(1)), addr)
      deallocate ( chunks, stat=status )
      call test_deallocate ( status, moduleName, 'chunks', s, address=addr )
d2908 1
a2908 1
      chunks => temp
d2910 1
a2910 1
    end subroutine DeleteChunk
d2912 2
a2913 2
    !--------------------------------- Add obstruction to database -----
    subroutine AddObstructionToDatabase ( database, item )
d2915 1
a2915 1
       use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
d2917 3
a2919 3
       ! Dummy arguments
       type (Obstruction_T), dimension(:), pointer :: DATABASE
       type (Obstruction_T), intent(in) :: ITEM
d2921 2
a2922 2
       ! Local variables
       type (Obstruction_T), dimension(:), pointer :: TEMPDATABASE
d2924 1
a2924 1
       include "addItemToDatabase.f9h"
d2926 1
a2926 1
    end subroutine AddObstructionToDatabase
d2928 2
a2929 2
    !--------------------------------------- Add chunk to database -----
    subroutine AddChunkToDatabase ( database, item )
d2931 1
a2931 1
      use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
d2933 3
a2935 3
      ! Dummy arguments
      type (MLSChunk_T), dimension(:), pointer :: DATABASE
      type (MLSChunk_T), intent(in) :: ITEM
d2937 2
a2938 2
      ! Local variables
      type (MLSChunk_T), dimension(:), pointer :: TEMPDATABASE
d2940 1
a2940 1
      include "addItemToDatabase.f9h"
d2942 1
a2942 1
    end subroutine AddChunkToDatabase
d2944 3
a2946 2
     type(MLSChunk_T) function CFM_ChunkDivide (processingRange, &
        filedatabase, config) result(chunk)
d2948 3
a2950 3
        type (TAI93_Range_T), intent(in) :: processingRange
        type (MLSFile_T), dimension(:), pointer :: filedatabase
        type(ChunkDivideConfig_T), intent(in) :: config
d2952 2
a2953 2
        type (MAFRange_T) :: MAFRange
        type(MLSChunk_T), dimension(:), pointer :: chunks => null()
d2955 2
a2956 2
        ! Executables
        chunkDivideConfig = config
d2958 2
a2959 2
        nullify(chunkDivideConfig%criticalSignals)   ! Just for Sun's compiler
        nullify(obstructions)
d2961 4
a2964 4
        ! not sure how to deal with obstruction, ignore it
        if (chunkDivideConfig%method /= l_fixed) then
           call SurveyL1BData ( processingRange, filedatabase, mafRange)
        end if
d2966 7
a2972 7
        if (chunkdivideconfig%method == l_orbital) then
           call ChunkDivide_Orbital (mafRange, filedatabase, chunks)
           chunk = chunks(1)
        else
           print *, "chunk divide method is unsupported"
        end if
     end function
d2974 1
d2996 1
a2996 1
       "$Id: ChunkDivide_m.f90,v 2.132 2018/06/22 23:22:08 pwagner Exp $"
d3006 3
@


2.132
log
@Say why we stop if none remain after 2nd PruneChunks
@
text
@d43 1
a43 1
  use MLSFinds, only: Findfirst, FindLongestStretch
d539 1
a539 2
      real(r8)                       :: xx, yy
      real(r8), dimension(:), ALLOCATABLE :: Vertices_XX, Vertices_YY
d541 1
a541 1
      integer :: M1, M2, n
d543 1
a543 1
      integer :: pointTest
d571 2
a572 2
      ALLOCATE(Vertices_XX(n))
      ALLOCATE(Vertices_YY(n))
a840 7
      !added for Polygon
      integer, target, dimension(0) :: NeededForPolygon
      integer, target, dimension(10) :: NotWantedForPolygon = &
        & (/ f_noSlaves, f_homeModule, f_homeGeodAngle, f_scanLowerLimit, &
        &    f_scanUpperLimit, f_criticalModules, f_maxGap, f_noChunks, f_maxLength, f_overlap /)
      !ended for Polygon

d2058 1
a2058 1
      use MLSL2Options, only: sharedPCF
d2858 1
a2858 1
      if ( status == 0 .and. size(chunks) > 0 ) addr = transfer(c_loc(temp(1)), addr)
d2959 1
a2959 1
       "$Id: ChunkDivide_m.f90,v 2.131 2018/05/14 23:23:58 vsnyder Exp $"
d2969 3
@


2.131
log
@Remove tab formatting (again) to eliminate compiler warnings
@
text
@d2762 7
d2967 1
a2967 1
       "$Id: ChunkDivide_m.f90,v 2.130 2018/04/19 01:14:16 vsnyder Exp $"
d2977 3
@


2.130
log
@Remove USE statements for unused names
@
text
@d86 1
a86 1
  !  
d507 1
a507 1
    
d516 1
a516 1
     
d521 2
a522 2
      
    
d574 3
a576 3
      
      
      
d580 2
a581 2
	Vertices_XX(i)= PolyVert_XYZ(1)
	call output ('   ')
d583 5
a587 6
	Vertices_YY(i) = PolyVert_XYZ(2)
	call output ('Vertices_XX,  Vertices_YY for polygon is ')
	call output (Vertices_XX(i))
	call output ('   ')
	call output (Vertices_YY(i), advance='yes')
	
d589 1
a589 2
   
    
d596 30
a625 30
	 call output ('  lon = ')   
	 call output( lons%dpField(1,1,MAF), advance='yes')
	 xyz = to_xyz ( lats%dpField(1,1,MAF), lons%dpField(1,1,MAF))
	 call output ('xyz is ')
	 call output (xyz, advance='yes')
	 call output(PnPoly(xyz(1), xyz(2), Vertices_XX, Vertices_YY ), advance='yes')
	 if ((PnPoly(xyz(1), xyz(2), Vertices_XX, Vertices_YY )) == 1)  then
	     ptsInPolygon(MAF) = .true.
	     !pointTest = pointTest + 1
	   !  if (MAF == 70) then
	   !    ptsInPolygon(MAF) = .false.
	   !  end if
	   !  if (MAF == 100) then
	    !    ptsInPolygon(MAF) = .false.
	   !  end if
	   !  if (MAF == 200) then
	   !     ptsInPolygon(MAF) = .false.
	   !  end if
	   !  if (MAF == 240) then
	   !     ptsInPolygon(MAF) = .false.
	   !  end if
	   !  if (MAF == 300) then
	   !     ptsInPolygon(MAF) = .false.
	  !   end if
	 else
	     !ptsInPolygon(MAF) = pointTest
	     !pointTest = 0 
	     ptsInPolygon(MAF) = .false.
	 end if
	 
d638 1
a638 1
     
d642 2
a643 2
       
      call output ( 'mafRange ', advance='yes')  
d656 8
a663 8
	
	call output ( 'before  FindLongestRange  call ', advance='yes')
	call FindLongestRange (ptsInPolygon, .true., range)
	call output ('range is ')
	call output (range, advance='yes')
	
	call output ( 'after  FindLongestRange  call ')
	
d841 1
a841 1
        
d843 1
a843 1
      integer, target, dimension(0) :: NeededForPolygon 
d848 1
a848 1
       
d925 1
a925 1
	  call output ('Inside case f_module', advance='yes')
d927 1
a927 1
	  instrumentModule = decoration(decoration(subtree(2,son)))
d929 5
a933 5
	  call output ('insturmentModule name is   ')
	  call output (instrumentModule , advance='yes')
	  call output ('insturmentModuleNAME name is   ')
	  call output (instrumentModuleName , advance='yes')
	  ChunkDivideConfig%module = instrumentModule
d956 1
a956 1
	  !instrumentModule = decoration(decoration(subtree(2,son)))
d1023 1
a1023 1
    
d1046 1
a1046 1
        notWanted => NotWantedForFixed  
d1057 1
a1057 1
    
d1078 1
a1078 1
    
d1089 1
a1089 1
    
d1102 1
a1102 1
    
d1126 1
a1126 1
    
d1759 1
a1759 1
          call output('Critical Signals from config', advance='yes' ) 
d1768 1
a1768 1
          call output('Critical Signals you chose', advance='yes' ) 
d2960 1
a2960 1
       "$Id: ChunkDivide_m.f90,v 2.129 2018/03/05 19:51:56 pwagner Exp $"
d2970 3
@


2.129
log
@Now uses Dump_Signals
@
text
@a2883 1
       use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
a2899 1
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d2962 1
a2962 1
       "$Id: ChunkDivide_m.f90,v 2.128 2018/02/23 22:14:26 mmadatya Exp $"
d2972 3
@


2.128
log
@Updated for polygon for ASMLS
@
text
@d1595 1
a1595 1
      use MLSSignals_m, only: GetSignalName, Signals
d1609 1
d1629 2
d1632 3
a1634 1
        if ( swLevel > -1 ) then
d1641 2
a1642 2
          call get_string( modules(signals(signalIndex)%instrumentModule)%name, module_str, &
            & strip=.true. )
d1649 2
a1650 2
          call get_string( modules(signals(signalIndex)%instrumentModule)%name, signal_full, &
            & strip=.true. )
d1658 4
d2964 1
a2964 1
       "$Id: ChunkDivide_m.f90,v 2.127 2018/02/09 00:58:27 pwagner Exp $"
d2974 3
@


2.127
log
@Removed unused variables; wider use of outputNamedValue
@
text
@d43 1
a43 1
  use MLSFinds, only: Findfirst
d203 1
a203 1
    use HDF5, only: H5GClose_F, H5GOpen_F
d243 1
d539 1
a539 1
      ! real(r8)                       :: xx, yy
d542 1
a542 1
      integer :: n
d544 2
a545 2
      ! integer :: pointTest
    
d580 2
a581 2
        Vertices_XX(i)= PolyVert_XYZ(1)
        call output ('   ')
d583 6
a588 6
        Vertices_YY(i) = PolyVert_XYZ(2)
        call output ('Vertices_XX,  Vertices_YY for polygon is ')
        call output (Vertices_XX(i))
        call output ('   ')
        call output (Vertices_YY(i), advance='yes')
        
d590 1
a590 1
    
d594 1
a594 1
      ! pointTest = 0
d598 30
a627 30
         call output ('  lon = ')   
         call output( lons%dpField(1,1,MAF), advance='yes')
         xyz = to_xyz ( lats%dpField(1,1,MAF), lons%dpField(1,1,MAF))
         call output ('xyz is ')
         call output (xyz, advance='yes')
         call output(PnPoly(xyz(1), xyz(2), Vertices_XX, Vertices_YY ), advance='yes')
         if ((PnPoly(xyz(1), xyz(2), Vertices_XX, Vertices_YY )) == 1)  then
             ptsInPolygon(MAF) = .true.
             !pointTest = pointTest + 1
           !  if (MAF == 70) then
           !    ptsInPolygon(MAF) = .false.
           !  end if
           !  if (MAF == 100) then
            !    ptsInPolygon(MAF) = .false.
           !  end if
           !  if (MAF == 200) then
           !     ptsInPolygon(MAF) = .false.
           !  end if
           !  if (MAF == 240) then
           !     ptsInPolygon(MAF) = .false.
           !  end if
           !  if (MAF == 300) then
           !     ptsInPolygon(MAF) = .false.
          !   end if
         else
             !ptsInPolygon(MAF) = pointTest
             !pointTest = 0 
             ptsInPolygon(MAF) = .false.
         end if
         
d636 2
a637 2
      call output ( 'MARET ChunckDivide_Polygon is usign Fixed method exactly.\n' )
      call output ( 'MARET vertices \n')
d641 1
a641 1
      call output ( 'MARET Polygon_Inside \n')
d645 1
a645 1
      call output ( 'MARET mafRange ', advance='yes')  
d658 8
a665 8
        
        call output ( 'MARET before  FindLongestRange  call ', advance='yes')
        call FindLongestRange (ptsInPolygon, .true., range)
        call output ('range is ')
        call output (range, advance='yes')
        
        call output ( 'MARET after  FindLongestRange  call ')
        
d844 1
a844 1
      !MARET added for Polygon
d849 1
a849 1
      !MARET ended for Polygon
d876 1
a876 1
      ! logical :: Log_Value                ! For boolean fields
d917 1
a917 2
          ! log_value = get_boolean ( fieldValue )
          ! print *, 'log_value ', log_value
d920 1
a920 1
          ! log_value = .false.
d927 1
a927 1
          call output ('Inside case f_module', advance='yes')
d929 1
a929 1
          instrumentModule = decoration(decoration(subtree(2,son)))
d931 5
a935 5
          call output ('insturmentModule name is   ')
          call output (instrumentModule , advance='yes')
          call output ('insturmentModuleNAME name is   ')
          call output (instrumentModuleName , advance='yes')
          ChunkDivideConfig%module = instrumentModule
d958 1
a958 1
          !instrumentModule = decoration(decoration(subtree(2,son)))
d1202 1
a1202 1
    use Output_M, only: Output
d2059 2
a2060 1
      use Monotone, only: IsMonotonic
d2099 1
a2099 1
        ! call output( 'here is the L1BOA', advance='yes' )
d2434 1
a2434 1
      if ( swLevel > 1 ) &
d2439 1
a2439 1
      if ( swLevel > 1 ) &
d2442 1
a2442 1
      if ( swLevel > 1 ) &
d2462 10
a2471 3
        call outputNamedValue ( 'Num MAFs in file', noMAFsRead )
        call outputNamedValue ( 'MAF time range', (/minTime, maxTime/) )
        call outputNamedValue ( 'Angle range', (/minAngle, maxAngle/) )
d2486 6
a2491 3
        call outputNamedValue ( 'orbit', orbit )
        call outputNamedValue ( 'test Angle', testAngle )
        call outputNamedValue ( 'angle Increment', angleIncrement )
d2527 9
a2535 5
        call outputNamedValue ( 'Test Angle', TestAngle )
        call outputNamedValue ( 'Angle(home)', tpGeodAngle%dpField(1,1,home) )
        call outputNamedValue ( 'Home', Home )
        call outputNamedValue ( 'Difference', &
          & abs ( tpGeodAngle%dpField(1,1,home) - testAngle ) )
d2905 6
a2910 2
  type(MLSChunk_T) function CFM_ChunkDivide (processingRange, &
     filedatabase, config) result(chunk)
d2912 21
a2932 25
     type (TAI93_Range_T), intent(in) :: processingRange
     type (MLSFile_T), dimension(:), pointer :: filedatabase
     type(ChunkDivideConfig_T), intent(in) :: config

     type (MAFRange_T) :: MAFRange
     type(MLSChunk_T), dimension(:), pointer :: chunks => null()

     ! Executables
     chunkDivideConfig = config

     nullify(chunkDivideConfig%criticalSignals)   ! Just for Sun's compiler
     nullify(obstructions)

     ! not sure how to deal with obstruction, ignore it
     if (chunkDivideConfig%method /= l_fixed) then
        call SurveyL1BData ( processingRange, filedatabase, mafRange)
     end if

     if (chunkdivideconfig%method == l_orbital) then
        call ChunkDivide_Orbital (mafRange, filedatabase, chunks)
        chunk = chunks(1)
     else
        print *, "chunk divide method is unsupported"
     end if
  end function
d2955 1
a2955 1
       "$Id: ChunkDivide_m.f90,v 2.126 2018/01/03 01:15:22 pwagner Exp $"
d2965 3
@


2.126
log
@Prints a little more debugging info
@
text
@d43 1
a43 1
  use MLSFinds, only: Findfirst, FindLongestStretch
d538 1
a538 1
      real(r8)                       :: xx, yy
d541 1
a541 1
      integer :: M1, M2, n
d543 1
a543 1
      integer :: pointTest
d593 1
a593 1
      pointTest = 0
d875 1
a875 1
      logical :: Log_Value                ! For boolean fields
d916 1
a916 1
          log_value = get_boolean ( fieldValue )
d920 1
a920 1
          log_value = .false.
a2058 1
      use MLSL2Options, only: SharedPCF
d2098 1
a2098 1
        call output( 'here is the L1BOA', advance='yes' )
d2433 1
a2433 1
      if ( swLevel > -1 ) &
d2438 1
a2438 1
      if ( swLevel > -1 ) &
d2441 1
a2441 1
      if ( swLevel > -1 ) &
d2461 3
a2463 10
        call output ( 'Num MAFs in file: ' )
        call output ( noMAFsRead, advance='yes' )
        call output ( 'MAF time range: ' )
        call output ( minTime )
        call output ( ' : ' )
        call output ( maxTime, advance='yes' )
        call output ( 'Angle range: ' )
        call output ( minAngle )
        call output ( ' : ' )
        call output ( maxAngle, advance='yes' )
d2478 3
a2480 6
        call output ( ' orbit  ', advance='no' )
        call output ( orbit , advance='no' )
        call output ( '    testAngle  ', advance='no' )
        call output ( testAngle , advance='no' )
        call output ( '    angleIncrement  ', advance='no' )
        call output ( angleIncrement , advance='yes' )
d2516 5
a2520 9
        call output ( 'Test Angle  ' )
        call output ( testAngle , advance='yes' )
        call output ( 'Angle(home)  ' )
        call output ( tpGeodAngle%dpField(1,1,home) , advance='yes' )
        call output ( 'Home  ' )
        call output ( home  )
        call output ( 'Difference  ' )
        call output (  abs ( tpGeodAngle%dpField(1,1,home) - &
          & testAngle ) , advance='yes' )
d2940 1
a2940 1
       "$Id: ChunkDivide_m.f90,v 2.125 2017/09/15 22:15:39 pwagner Exp $"
d2950 3
@


2.125
log
@Correct bugs in evaluating excludeOverlap fields
@
text
@d44 1
a44 1
  use MLSSignals_M, only: Modules, GetModuleName
d284 2
a285 1
      call output( 'Entered ChunkDivide w/o an l1boa file--hope thats OK', advance='yes' )
d287 2
d1626 2
d1744 5
d1751 4
d1760 4
d1783 2
a1784 1
        call get_string( lit_indices(ChunkDivideConfig%criticalModules), signal_full, &
d1787 2
a1788 1
        call get_string( modules(signals(signalIndex)%instrumentModule)%name, signal_full, &
d1791 2
a1792 1
        if ( swLevel >= VERBOSETHRESHOLD ) call outputNamedValue( 'module', module_str )
d1800 4
a1803 2
        if ( swLevel >= VERBOSETHRESHOLD ) call dumpSignals( signals(signalIndex) )
        if ( swLevel >= VERBOSETHRESHOLD ) call outputNamedValue( 'critical module', critical_module_str )
d1810 2
a1811 2
          nmafsets = (nmafs-1)/MAXMAFSINSET + 1
          mafset_end = mafRange%Expanded(1) - 1   ! A trick--mafset_start is mafRange(1)
d1816 2
a1817 1
              & any_good_signaldata ( signalIndex, signals(signalIndex)%sideband, &
d1823 4
a1826 1
      if ( swlevel >= VERBOSETHRESHOLD ) call dump ( signals_buffer, 'signals_buffer' )
d2098 4
a2101 1
      ! call dump(L1BFile)
d2105 4
a2108 2
      ! tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', l1b_hdf_version, &
      !  .false. )
d2126 2
a2127 1
        call outputNamedValue ( 'processingRange', (/ processingRange%startTime, processingRange%endTime /) )
d2133 2
a2134 1
      if ( mafRange%L2Cover(1) == taiTime%noMAFs ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2156 1
a2156 1
      if ( sharedPCF ) return
d2219 5
a2223 4
              thisOneValid = ( scanMin >= ChunkDivideConfig%scanLowerLimit(1) .and. &
                &              scanMin <= ChunkDivideConfig%scanLowerLimit(2) ) .and. &
                &            ( scanMax >= ChunkDivideConfig%scanUpperLimit(1) .and. &
                &              scanMax <= ChunkDivideConfig%scanUpperLimit(2) )
d2251 1
d2955 1
a2955 1
       "$Id: ChunkDivide_m.f90,v 2.124 2017/09/14 23:19:36 pwagner Exp $"
d2965 3
@


2.124
log
@Fixed some errors in ChunkDivide_Polygon
@
text
@d910 1
a910 1
          log_value = nint(value(1)) /= 0
d914 1
d989 1
a989 1
          ChunkDivideConfig%allowPostOverlaps = log_value
d994 1
a994 1
          ChunkDivideConfig%allowPriorOverlaps = log_value
d1003 1
a1003 1
          ChunkDivideConfig%skipL1BCheck = log_value
d1008 1
a1008 1
          ChunkDivideConfig%crashIfPhiNotMono = log_value
d1014 1
a1014 1
          ChunkDivideConfig%saveObstructions = log_value
d2919 1
a2919 1
       "$Id: ChunkDivide_m.f90,v 2.123 2017/09/14 18:36:13 vsnyder Exp $"
d2929 3
@


2.123
log
@Remove tab formatting to eliminate compiler warnings
@
text
@d27 1
a27 1
    & F_Maxlength, F_Maxorby, F_Method, F_Nochunks, F_Noslaves, &
d35 2
a36 2
  use L1bData, only: L1bData_T, ReadL1BData, GetL1BFile, Namelen, &
    & AssembleL1Bqtyname, Precisionsuffix, DeallocateL1BData
d38 1
d44 1
a44 1
  use MLSSignals_M, only: Modules
d241 2
a242 1

d318 1
a318 1
        call ChunkDivide_Polygon ( mafRange, filedatabase, chunks )
d505 1
a505 1
    subroutine ChunkDivide_Polygon ( mafRange, filedatabase, chunks )
d512 1
d516 1
d518 1
a518 2
      

d528 1
a528 1
      type (L1BData_T) :: lons            ! lats data
d533 1
a533 1
      logical, dimension(:), pointer :: ptsInPolygon
d536 6
a541 1

d548 2
a549 1
      l1bItemName = AssembleL1BQtyName ( 'tpGeodLat', L1BFile%HDFVersion, .false. )
d554 5
a558 2
      
      l1bItemName = AssembleL1BQtyName ( 'tpLon', L1BFile%HDFVersion, .false. )
d563 2
a564 1
      
d567 17
d585 3
d589 2
d592 32
d630 1
d641 2
a642 2
      call output ( 'MARET mafRange \n')  
       call output ( 'Corresponding MAF range ' )
d654 8
a661 5

        call output ( 'MARET before  FindLongestStretch  call ')
        call FindLongestStretch ((chunks%lastMAFIndex - chunks%firstMAFIndex), 1, mafRange%L2Cover)
        call output ( 'MARET after  FindLongestStretch  call ')

d828 1
a828 1
      use MoreTree, only: Get_Boolean
d839 1
a839 1

d910 1
a910 2
          ! log_value = nint(value(1)) /= 0
          ! print *, 'Case 1 ', log_value
a913 1
          ! print *, 'Case 2 ', log_value
a916 1
          ! print *, 'Case 3 ', log_value
d922 10
d954 3
d988 1
a988 3
          log_value = get_boolean ( fieldValue )
          ! print *, 'processing f_excludePost.. ', log_value
          ChunkDivideConfig%allowPostOverlaps = .not. log_value
d993 1
a993 3
          log_value = get_boolean ( fieldValue )
          ! print *, 'processing f_excludePrior.. ', log_value
          ChunkDivideConfig%allowPriorOverlaps = .not. log_value
a1000 1
          log_value = get_boolean ( fieldValue )
a1006 1
          log_value = get_boolean ( fieldValue )
a1012 1
          log_value = get_boolean ( fieldValue )
d1021 1
a1021 1

d1044 1
a1044 1
        notWanted => NotWantedForFixed
d1055 1
a1055 1

d1076 1
a1076 1

d1087 1
a1087 1

d1100 1
a1100 1

d1124 1
a1124 1

d2092 7
a2098 2
      if ( mafRange%L2Cover(2) == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L1B data starts after requested processing range' )
d2918 1
a2918 1
       "$Id: ChunkDivide_m.f90,v 2.122 2017/03/06 19:55:48 pwagner Exp $"
d2928 3
@


2.122
log
@Corrected remaining mistakes in evaluating logical values
@
text
@d271 1
a271 1
	call dump(ChunkDivideConfig)
d586 5
a590 5
	
	call output ( 'MARET before  FindLongestStretch  call ')
	call FindLongestStretch ((chunks%lastMAFIndex - chunks%firstMAFIndex), 1, mafRange%L2Cover)
	call output ( 'MARET after  FindLongestStretch  call ')
	
d768 1
a768 1
	
d970 1
a970 1
        notWanted => NotWantedForFixed	
d2839 1
a2839 1
       "$Id: ChunkDivide_m.f90,v 2.121 2017/02/15 00:48:26 pwagner Exp $"
d2849 3
@


2.121
log
@Repaired bugs in processing Boolean fields /exclude..
@
text
@d17 2
a18 2
  use allocate_deallocate, only: allocate_test, deallocate_test
  use ChunkDivideConfig_m, only: ChunkDivideConfig_t, ChunkDivideConfig, Dump, &
d20 31
a50 32
  use chunks_m, only: mlschunk_t, dump
  use dump_0, only: dump
  use highoutput, only: outputnamedvalue
  use init_tables_module, only: f_crashifphinotmono, &
      & f_criticalbands, f_criticalmodules, f_criticalsignals, &
      & f_excludepostoverlaps, f_excludeprioroverlaps, &
      & f_homemodule, f_homegeodangle, &
      & f_maxlength, f_maxorby, f_method, f_nochunks, f_noslaves, &
      & f_overlap, f_loweroverlap, &
      & f_saveobstructions, f_scanlowerlimit, f_scanupperlimit, &
      & f_skipl1bcheck, f_upperoverlap, &
      & field_first, field_last, l_both, l_either, l_even, &
      & l_fixed, l_polygon, f_maxgap, l_orbital, l_pe, s_chunkdivide, s_dump
  use intrinsic, only: l_none, field_indices, lit_indices, phyq_angle, &
      & phyq_dimensionless, phyq_length, phyq_mafs, phyq_time
  use l1bdata, only: l1bdata_t, readl1bdata, getl1bfile, namelen, &
      & assemblel1bqtyname, precisionsuffix, deallocatel1bdata
  use MLSCommon, only: mlsfile_t, tai93_range_t
  use MLSFiles, only: dump, getmlsfilebytype, mls_openfile
  use MLSKinds, only: r8, rp
  use MLSMessageModule, only: MLSMessage, MLSMsg_error, MLSMsg_warning
  use MLSNumerics, only: hunt
  use MLSFinds, only: findfirst, FindLongestStretch
  use MLSSignals_m, only: modules
  use MLSStringlists, only: switchDetail
  use output_m, only: blanks, output, &
      & revertOutput, switchOutput
  use PCFHdr, only: globalAttributes
  use string_table, only: get_string, display_string
  use toggles, only: gen, levels, switches, toggle
  use Polygon_m, only: Polygon_Inside, Polygon_Vertices
  
d202 1
a202 1
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
d757 1
a757 1
      use moreTree, only: get_boolean
d839 1
a839 1
          log_value = nint(value(1)) /= 0
d907 1
d914 1
d924 2
a925 1
          print *, 'processing f_skipL1BCheck ', log_value
d931 1
d938 1
d1124 1
a1124 1
    use Output_M, only: OUTPUT
d1173 2
a1174 2
    use MLSKinds, only: rk => r8
    use MLSSignals_m, only: getsignalname
d1250 2
a1251 2
    use MLSStringlists, only: numStringElements, stringElement
    use MLSStrings, only: readintsfromchars
d1271 1
a1271 1
  use MLSFillValues, only: isfillvalue
d1517 3
a1519 3
      use MLSSignals_m, only: getsignalname, signals
      use MLSStringlists, only: catlists, list2array
      use MLSStrings, only: lowercase
d1584 5
a1588 5
      use MLSSignals_m, only: dumpsignals=>dump, getsignalindex, getsignalname, &
        & GetNameofsignal, signals
      use MLSStringlists, only: numstringelements, getstringelement
      use MLSStrings, only: lowercase
      use parse_signal_m, only: parse_signal
d1957 2
a1958 2
      use MLSL2Options, only: sharedPCF
      use Monotone, only: isMonotonic
d2789 2
a2790 9
     type(MLSChunk_T) function CFM_ChunkDivide (processingRange, &
        filedatabase, config) result(chunk)

        type (TAI93_Range_T), intent(in) :: processingRange
        type (MLSFile_T), dimension(:), pointer :: filedatabase
        type(ChunkDivideConfig_T), intent(in) :: config

        type (MAFRange_T) :: MAFRange
        type(MLSChunk_T), dimension(:), pointer :: chunks => null()
d2792 25
a2816 18
        ! Executables
        chunkDivideConfig = config

        nullify(chunkDivideConfig%criticalSignals)   ! Just for Sun's compiler
        nullify(obstructions)

        ! not sure how to deal with obstruction, ignore it
        if (chunkDivideConfig%method /= l_fixed) then
           call SurveyL1BData ( processingRange, filedatabase, mafRange)
        end if

        if (chunkdivideconfig%method == l_orbital) then
           call ChunkDivide_Orbital (mafRange, filedatabase, chunks)
           chunk = chunks(1)
        else
           print *, "chunk divide method is unsupported"
        end if
     end function
d2819 1
a2819 1
    use MLSStrings, only: trim_safe
d2839 1
a2839 1
       "$Id: ChunkDivide_m.f90,v 2.120 2017/02/10 21:57:47 pwagner Exp $"
d2849 3
@


2.120
log
@Added the polygon method for ChunkDivide; NoChunks an optional parameter for fixed method
@
text
@d841 1
d845 1
d849 1
d908 2
a909 1
          ChunkDivideConfig%allowPostOverlaps = log_value
d914 2
a915 1
          ChunkDivideConfig%allowPriorOverlaps = log_value
d923 1
a923 1
          ! print *, 'processing f_skipL1BCheck ', log_value
d2835 1
a2835 1
       "$Id: ChunkDivide_m.f90,v 2.119 2015/10/03 00:31:01 pwagner Exp $"
d2845 3
@


2.119
log
@Will now show number of chunks
@
text
@d32 1
a32 1
      & l_fixed, f_maxgap, l_orbital, l_pe, s_chunkdivide, s_dump
d42 1
a42 1
  use MLSFinds, only: findfirst
d47 1
d50 2
d86 2
d272 1
d313 6
d502 114
d758 1
d763 3
a765 2
      integer, target, dimension(3) :: NeededForFixed = &
        & (/ f_noChunks, f_maxLength, f_overlap /)
d769 8
a776 1

d798 1
d825 5
d835 2
d841 3
d918 1
d950 12
d2830 1
a2830 1
       "$Id: ChunkDivide_m.f90,v 2.118 2015/06/24 18:01:56 pwagner Exp $"
d2840 3
@


2.118
log
@Halt with useful error message if no radiances, instead of vanishing in puff of smoke
@
text
@d398 5
a402 1
    if ( swLevel > 0 ) call dump ( chunks )
d2671 1
a2671 1
       "$Id: ChunkDivide_m.f90,v 2.117 2015/03/28 02:19:01 vsnyder Exp $"
d2681 3
@


2.117
log
@Added shallow destruction to DestroyChunkDatabase.  Got IsMonotonic from
Monotone instead of MLSFillValues.
Added stuff to trace allocate/deallocate addresses.
@
text
@d2447 7
d2667 1
a2667 1
       "$Id: ChunkDivide_m.f90,v 2.116 2015/02/27 23:18:47 pwagner Exp $"
d2677 5
@


2.116
log
@Require -Schu1 or greater to dump chunks
@
text
@d122 3
a124 2
  subroutine DestroyChunkDatabase ( chunks )
    use allocate_deallocate, only: deallocate_test, Test_Deallocate
d129 3
d133 1
d141 10
a150 6
    do chunk = 1, size ( chunks )
      call Deallocate_test ( chunks(chunk)%hGridOffsets, &
        & 'chunks(?)%hGridOffsets', ModuleName )
      call Deallocate_test ( chunks(chunk)%hGridTotals, &
        & 'chunks(?)%hGridTotals', ModuleName )
    end do
d152 2
d155 1
a155 1
    call test_deallocate ( status, moduleName, "chunks", s )
d163 1
d169 1
d180 4
a183 2
    call test_allocate ( status, moduleName, "tempDatabase", &
      uBounds = newSize, elementSize = storage_size(tempDatabase) / 8 )
d186 1
a186 1
    call DestroyChunkDatabase ( chunks )
d197 14
a210 13
    use expr_m, only: expr
    use lexer_core, only: print_source
    use MLSCommon, only: tai93_range_t
    use MLSHdf5, only: gethdf5attribute
    use MLSL2options, only: need_l1bfiles, specialdumpfile
    use MLSL2timings, only: section_times, total_times
    use moretree, only: get_field_id, get_spec_id
    use next_tree_node_m, only: next_tree_node, next_tree_node_state
    use time_m, only: time_now
    use trace_m, only: trace_begin, trace_end
    use tree, only: decoration, node_id, nsons, subtree, sub_rosa, where_at=>where
    use tree_types, only: n_named
    use hdf5, only: h5gclose_f, h5gopen_f
d218 1
d363 2
d366 1
a366 1
        call test_deallocate ( status, moduleName, 'obstructions', s )
d374 2
d378 1
a378 1
        & 'ChunkDivideConfig%criticalSignals', s )
d450 1
d454 1
d464 3
d468 2
a469 1
        uBounds = ChunkDivideConfig%noChunks, elementSize = storage_size(chunks) / 8 )
d491 1
d505 1
d606 2
d609 1
a609 1
        & elementSize = storage_size(chunks) / 8 )
d1310 1
d1316 1
d1323 2
d1326 2
a1327 1
        & uBounds = size(obstructions) - 1, elementSize = storage_size(temp) / 8 )
d1334 2
d1337 1
a1337 1
      call test_deallocate ( status, moduleName, 'obstructions', s )
a1784 1
      use MLSFillValues, only: isMonotonic
d1786 1
d1997 4
a2000 4
      integer :: I,J                      ! Loop counters
      type (Obstruction_T) :: newObs      ! New Obstruction
      logical :: FOUNDONE                 ! Found at least one
      integer :: STATUS                   ! Flag from allocate
d2077 1
d2091 1
d2272 2
d2275 1
a2275 1
          & uBounds = noChunks, elementSize = storage_size(chunks) / 8 )
d2322 2
d2325 1
a2325 1
          & uBounds = noChunks, elementSize = storage_size(chunks) / 8 )
d2521 17
a2537 17
     ! ----------------------------------------- PruneChunks -----------
     subroutine PruneChunks ( chunks )
        type (MLSChunk_T), dimension(:), pointer :: CHUNKS
        integer :: CHUNK
        ! Now delete chunks that either:
        !  1 - Are nothing but overlap
        !  2 - Have <=0 MAFs
        pruneChunksLoop: do
           chunk = FindFirst ( &
              & ( chunks%noMAFsLowerOverlap + chunks%noMAFsUpperOverlap ) >= &
              & ( chunks%lastMAFIndex - chunks%firstMAFIndex + 1 ) &
              & .or.&
              & ( chunks%firstMAFIndex > chunks%lastMAFIndex ) )
           if ( chunk == 0 ) exit pruneChunksLoop
           call DeleteChunk ( chunks, chunk )
        end do pruneChunksLoop
     end subroutine PruneChunks
d2539 7
a2545 6
     ! ------------------------------------------------ DeleteChunk -----
     subroutine DeleteChunk ( chunks, index )
       use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
       ! Dummy arguments
       type (MLSChunk_T), pointer, dimension(:) :: CHUNKS
       integer, intent(in) :: INDEX
d2547 5
a2551 4
       ! Local variables
       type (MLSChunk_T), pointer, dimension(:) :: TEMP
       integer :: S                ! Size in bytes of object to deallocate
       integer :: STATUS           ! From allocate
d2553 8
a2560 5
       ! Executable code
       swlevel = switchDetail(switches, 'chu' )
       allocate ( temp ( size(chunks) - 1 ), stat=status )
       call test_allocate ( status, ModuleName, 'temp', &
         & uBounds = size(chunks) - 1, elementSize = storage_size(temp) / 8 )
d2562 3
a2564 3
       if ( index > 1 ) temp(1:index-1) = chunks(1:index-1)
       if ( index < size(chunks) .and. size(chunks) > 1 ) &
          & temp(index:) = chunks(index+1:)
d2566 5
a2570 3
       s = size(chunks) * storage_size(chunks) / 8
       deallocate ( chunks, stat=status )
       call test_deallocate ( status, moduleName, 'chunks', s )
d2572 1
a2572 1
       chunks => temp
d2574 1
a2574 1
     end subroutine DeleteChunk
d2576 2
a2577 2
     !--------------------------------- Add obstruction to database -----
     subroutine AddObstructionToDatabase ( database, item )
d2579 2
a2580 1
        use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
d2582 3
a2584 3
        ! Dummy arguments
        type (Obstruction_T), dimension(:), pointer :: DATABASE
        type (Obstruction_T), intent(in) :: ITEM
d2586 2
a2587 2
        ! Local variables
        type (Obstruction_T), dimension(:), pointer :: TEMPDATABASE
d2589 1
a2589 1
        include "addItemToDatabase.f9h"
d2591 1
a2591 1
     end subroutine AddObstructionToDatabase
d2596 2
a2597 1
        use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
d2660 1
a2660 1
       "$Id: ChunkDivide_m.f90,v 2.115 2014/09/05 00:36:15 vsnyder Exp $"
d2670 3
@


2.115
log
@More complete and accurate allocate/deallocate size tracking.  Add some
tracing.
@
text
@d17 1
a17 1
  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
d20 29
a48 29
  use CHUNKS_M, only: MLSCHUNK_T, DUMP
  use DUMP_0, only: DUMP
  use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
  use INIT_TABLES_MODULE, only: F_CRASHIFPHINOTMONO, &
      & F_CRITICALBANDS, F_CRITICALMODULES, F_CRITICALSIGNALS, &
      & F_EXCLUDEPOSTOVERLAPS, F_EXCLUDEPRIOROVERLAPS, &
      & F_HOMEMODULE, F_HOMEGEODANGLE, &
      & F_MAXLENGTH, F_MAXORBY, F_METHOD, F_NOCHUNKS, F_NOSLAVES, &
      & F_OVERLAP, F_LOWEROVERLAP, &
      & F_SAVEOBSTRUCTIONS, F_SCANLOWERLIMIT, F_SCANUPPERLIMIT, &
      & F_SKIPL1BCHECK, F_UPPEROVERLAP, &
      & FIELD_FIRST, FIELD_LAST, L_BOTH, L_EITHER, L_EVEN, &
      & L_FIXED, F_MAXGAP, L_ORBITAL, L_PE, S_CHUNKDIVIDE, S_Dump
  use INTRINSIC, only: L_NONE, FIELD_INDICES, LIT_INDICES, PHYQ_ANGLE, &
      & PHYQ_DIMENSIONLESS, PHYQ_LENGTH, PHYQ_MAFS, PHYQ_TIME
  use L1BDATA, only: L1BDATA_T, READL1BDATA, GETL1BFILE, namelen, &
      & ASSEMBLEL1BQTYNAME, PRECISIONSUFFIX, DEALLOCATEL1BDATA
  use MLSCOMMON, only: MLSFILE_T, TAI93_RANGE_T
  use MLSFILES, only: DUMP, GETMLSFILEBYTYPE, MLS_OPENFILE
  use MLSKINDS, only: R8, RP
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
  use MLSNUMERICS, only: HUNT
  use MLSFINDS, only: FINDFIRST
  use MLSSIGNALS_M, only: MODULES
  use MLSSTRINGLISTS, only: SWITCHDETAIL
  use OUTPUT_M, only: BLANKS, OUTPUT, &
      & REVERTOUTPUT, SWITCHOUTPUT
  use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
  use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
d123 1
a123 1
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST, Test_Deallocate
d182 13
a194 13
    use EXPR_M, only: EXPR
    use LEXER_CORE, only: PRINT_SOURCE
    use MLSCOMMON, only: TAI93_RANGE_T
    use MLSHDF5, only: GETHDF5ATTRIBUTE
    use MLSL2OPTIONS, only: NEED_L1BFILES, SPECIALDUMPFILE
    use MLSL2TIMINGS, only: SECTION_TIMES, TOTAL_TIMES
    use MORETREE, only: GET_FIELD_ID, GET_SPEC_ID
    use Next_Tree_Node_m, only: Next_Tree_Node, Next_Tree_Node_State
    use TIME_M, only: TIME_NOW
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NODE_ID, NSONS, SUBTREE, SUB_ROSA, WHERE_AT=>WHERE
    use Tree_Types, only: N_Named
    use HDF5, only: H5GCLOSE_F, H5GOPEN_F
d377 1
a377 1
    if ( swLevel > -1 ) call dump ( chunks )
d970 2
a971 2
    use MLSKINDS, only: RK => R8
    use MLSSIGNALS_M, only: GETSIGNALNAME
d1047 2
a1048 2
    use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, STRINGELEMENT
    use MLSSTRINGS, only: READINTSFROMCHARS
d1068 1
a1068 1
  use MLSFillValues, only: ISFILLVALUE
d1307 3
a1309 3
      use MLSSIGNALS_M, only: GETSIGNALNAME, SIGNALS
      use MLSSTRINGLISTS, only: CATLISTS, LIST2ARRAY
      use MLSSTRINGS, only: LOWERCASE
d1374 5
a1378 5
      use MLSSIGNALS_M, only: DUMPSIGNALS=>DUMP, GETSIGNALINDEX, GETSIGNALNAME, &
        & GETNAMEOFSIGNAL, SIGNALS
      use MLSSTRINGLISTS, only: NUMSTRINGELEMENTS, GETSTRINGELEMENT
      use MLSSTRINGS, only: LOWERCASE
      use PARSE_SIGNAL_M, only: PARSE_SIGNAL
d1747 2
a1748 2
      use MLSFillValues, only: ISMONOTONIC
      use MLSL2OPTIONS, only: SHAREDPCF
d2587 1
a2587 1
    use MLSStrings, only: TRIM_SAFE
d2607 1
a2607 1
       "$Id: ChunkDivide_m.f90,v 2.114 2014/08/07 22:47:12 vsnyder Exp $"
d2617 4
@


2.114
log
@Delete local declaration of Obstructions from AddChunkToDatabase so that
when it's nullified the one at module scope gets nullified.  It was
not otherwise used in AddChunkToDatabase.
@
text
@d40 1
a40 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_DEALLOCATE, MLSMSG_WARNING, &
                              MLSMSG_ERROR, MLSMSG_ALLOCATE
d123 3
a125 1
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST
d128 4
a131 2
    integer :: STATUS                   ! From deallocate
    integer :: CHUNK                    ! Index
d134 2
d142 1
d144 2
a145 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Warning, ModuleName, &
      & MLSMSG_DeAllocate // "Chunks" )
d151 3
d158 1
d162 1
d167 2
a168 2
    if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "tempDatabase")
d173 1
d180 1
d205 1
d345 1
d347 1
a347 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate//'obstructions' )
d353 2
d356 2
a357 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'ChunkDivideConfig%criticalSignals' )
d428 1
d441 2
a442 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'chunks' )
d463 1
d577 2
a578 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'chunks (maxLength/MAFs)' )
d1278 1
d1284 2
a1285 1
      integer :: STATUS                   ! From allocate
d1290 2
a1291 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'temp' )
d1297 1
d1299 1
a1299 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'obstructions' )
d1955 1
d1969 2
a1970 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'obstructions(0)' )
d2038 1
d2232 2
a2233 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'chunks (maxLength/MAFs)' )
d2280 2
a2281 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'chunks (maxLength/time/angle)' )
d2497 1
d2504 2
a2505 1
       integer :: STATUS                   ! From allocate
d2510 2
a2511 2
       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'temp' )
d2517 1
d2519 1
a2519 2
       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate//'chunks' )
d2528 2
d2544 2
d2607 1
a2607 1
       "$Id: ChunkDivide_m.f90,v 2.113 2014/03/07 19:20:05 pwagner Exp $"
d2617 5
@


2.113
log
@Name_Len changed to nameLen; got from MLSCommon
@
text
@a2536 1
        type(Obstruction_T), dimension(:), pointer :: obstructions
d2579 1
a2579 1
       "$Id: ChunkDivide_m.f90,v 2.112 2014/03/01 03:10:56 vsnyder Exp $"
d2589 3
@


2.112
log
@Move units checking to init_tables_module
@
text
@d35 1
a35 1
  use L1BDATA, only: L1BDATA_T, READL1BDATA, GETL1BFILE, NAME_LEN, &
d476 1
a476 1
      character(len=NAME_LEN) ::         MAF_start, tp_angle
d1757 1
a1757 1
      character(len=NAME_LEN) ::         MAF_start, tp_alt, tp_orbY, tp_angle
d2062 1
a2062 1
      character(len=NAME_LEN) ::         MAF_start, tp_angle
d2580 1
a2580 1
       "$Id: ChunkDivide_m.f90,v 2.111 2014/01/11 01:44:18 vsnyder Exp $"
d2590 3
@


2.111
log
@Decruftification
@
text
@a672 2
          if ( units(1) /= PHYQ_DimensionLess ) &
            & call AnnounceError ( root, BadUnits, fieldIndex )
a676 2
          if ( units(1) /= PHYQ_Angle ) &
            & call AnnounceError ( root, BadUnits, fieldIndex )
d2580 1
a2580 1
       "$Id: ChunkDivide_m.f90,v 2.110 2014/01/09 00:30:24 pwagner Exp $"
d2590 3
@


2.110
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d34 1
a34 1
      & PHYQ_DIMENSIONLESS, PHYQ_INVALID, PHYQ_LENGTH, PHYQ_MAFS, PHYQ_TIME
a168 1
    use Evaluate_Variable_m, only: Evaluate_Variable
d175 1
a175 1
    use MORETREE, only: GET_BOOLEAN, GET_FIELD_ID, GET_SPEC_ID
a189 1
    integer :: I                        ! Loop inductor
d2584 1
a2584 1
       "$Id: ChunkDivide_m.f90,v 2.109 2013/12/12 02:11:26 vsnyder Exp $"
d2594 3
@


2.109
log
@Use iterator to handle variables, and IF and SELECT constructs
@
text
@d22 1
d46 1
a46 1
  use OUTPUT_M, only: BLANKS, OUTPUT, OUTPUTNAMEDVALUE, &
d2586 1
a2586 1
       "$Id: ChunkDivide_m.f90,v 2.108 2013/10/09 23:40:34 vsnyder Exp $"
d2596 3
@


2.108
log
@Add Evaluate_Variable
@
text
@d176 1
d180 1
a180 1
    use TREE_TYPES, only: N_NAMED, N_Variable
d194 1
d198 1
d227 12
a238 15
    if ( nsons(root) <= 2 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & 'ChunkDivide section cannot be empty' )
    do i = 2, nsons(root)-1      ! Skip the begin/end section
      son = subtree(i,root)
      if ( node_id(son) == n_variable ) then
        call evaluate_variable ( son )
      else
        if ( node_id(son) == n_named ) son = subtree(2,son) ! Ignore label
        select case ( get_spec_id(son) )
        case ( s_dump )
          call dumpCommand ( son )
        case ( s_chunkDivide )
          call chunkDivideL2CF ( son )
        end select
      end if
d240 2
d2585 1
a2585 1
       "$Id: ChunkDivide_m.f90,v 2.107 2013/09/24 23:47:22 vsnyder Exp $"
d2595 3
@


2.107
log
@Use Where instead of Source_Ref for messages
@
text
@d168 1
d179 1
a179 1
    use TREE_TYPES, only: N_NAMED
d228 11
a238 7
      if ( node_id(son) == n_named ) son = subtree(2,son) ! Ignore label
      select case ( get_spec_id(son) )
      case ( s_dump )
        call dumpCommand ( son )
      case ( s_chunkDivide )
        call chunkDivideL2CF ( son )
      end select
d2583 1
a2583 1
       "$Id: ChunkDivide_m.f90,v 2.106 2013/09/21 00:39:43 vsnyder Exp $"
d2593 3
@


2.106
log
@Repair some tree examination errors.  Move ChunkDivideConfig_t,
ChunkDivideConfig, and some dumpers to ChunkDivideConfig_m.  Call
DumpCommand.
@
text
@d177 1
a177 1
    use TREE, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, SUBTREE, SUB_ROSA
d368 2
a369 2
      call print_source ( source_ref(where) )
      call output ( ' ChunkDivide complained: ' )
d2578 1
a2578 1
       "$Id: ChunkDivide_m.f90,v 2.105 2013/08/30 02:45:34 vsnyder Exp $"
d2588 5
@


2.105
log
@Revise calls to trace_begin and trace_end
@
text
@d18 2
d30 2
a31 2
      & FIELD_FIRST, FIELD_LAST, L_EVEN, &
      & L_FIXED, F_MAXGAP, L_ORBITAL, L_PE, S_CHUNKDIVIDE, L_BOTH, L_EITHER
d48 1
a48 1
  use TOGGLES, only: GEN, TOGGLE, SWITCHES
d78 1
a78 38
  public :: CHUNKDIVIDECONFIG_T
  ! This type is filled by the l2cf and describes the configuration of the
  ! chunk division process.
  type ChunkDivideConfig_T
    integer :: method = l_none          ! See below.
    real(rp) :: maxLength = 0           ! Maximum length of chunks
    integer :: maxLengthFamily = PHYQ_Invalid ! PHYQ_Angle etc.
    integer :: noChunks = 0             ! Number of chunks for [fixed]
    real(rp) :: overlap = 0.0           ! Desired length of overlaps
    real(rp) :: lowerOverlap = 0.0      ! Desired length of lower overlaps
    real(rp) :: upperOverlap = 0.0      ! Desired length of lower overlaps
    integer :: overlapFamily = PHYQ_Invalid ! PHYQ_MAF, PHYQ_Time etc.
    integer :: lowerOverlapFamily = PHYQ_Invalid
    integer :: upperOverlapFamily = PHYQ_Invalid
    integer :: noSlaves = 0             ! Number of slave nodes [even]
    integer :: homeModule = l_none      ! Which module to consider [orbital]
    real(rp) :: homeGeodAngle = 0.0     ! Aim for one chunk to start here [orbital]
    logical   :: scanLLSet = .false.    ! True if scan lower limit should be used
    logical   :: scanULSet = .false.    ! True if scan upper limit should be used
    real(rp), dimension(2) :: scanLowerLimit ! Range for bottom of scan
    real(rp), dimension(2) :: scanUpperLimit ! Range for top of scan
    real(rp) :: maxOrbY = -1.0                 ! Maximum out of plane distance allowed <=0.0 default
    character(len=128) :: criticalBands = ' ' ! Which bands must be scanning
    integer   :: criticalModules = l_none ! Which modules must be scanning
    logical   :: chooseCriticalSignals = .true. ! Use criticalModules, Bands?
    character(len=160), dimension(:), pointer &
      & :: criticalSignals => null() ! Which signals must be on
    real(rp)  :: maxGap = 0.0           ! Length of time/MAFs/orbits allowed for gap
    integer   :: maxGapFamily = PHYQ_Invalid ! PHYQ_MAF, PHYQ_Time etc.
    logical   :: skipL1BCheck = .false. ! Don't check for l1b data probs
    logical   :: crashIfPhiNotMono = .false. ! If l1b contains non-monotonic phi
    logical   :: allowPriorOverlaps = .true. ! Use MAFs before start time
    logical   :: allowPostOverlaps = .true. ! Use MAFs after end time
    logical   :: saveObstructions = .true. ! Save obstructions for Output_Close
    logical   :: DACSDeconvolved = .true. ! Don't need to do this in level 2
    integer   :: numPriorOverlaps = 0     ! How many profiles before processingRanges
    integer   :: numPostOverlaps = 0     ! How many profiles after processingRanges
  end type ChunkDivideConfig_T
a91 2
  type(ChunkDivideConfig_T), public, save :: CHUNKDIVIDECONFIG

a109 1
    module procedure DUMP_CONFIG
d167 1
d188 1
d191 1
d219 16
a234 1
    call ChunkDivideL2CF ( root )
d569 1
a569 1
    subroutine ChunkDivideL2CF ( sectionRoot )
d572 3
a574 2
      integer, intent(in) :: SECTIONROOT    ! Root of the ChunkDivide section of the
      ! MLSCF abstract syntax tree
d603 2
a604 3
      integer :: FIELDINDEX               ! Tree type
      integer :: fieldValue               ! Node in the tree
      integer :: GSON                     ! A son of son the ChunkDivide section node
d607 2
a609 1
      integer :: ROOT                     ! Root of ChunkDivide command
d611 1
a611 1
      integer :: SON                      ! A son of the ChunkDivide section node
d619 2
d623 1
a623 11

      ! Eventually the ChunkDivide command will be free floating, in the meantime
      ! find it within the section
      ! WE CAN GET RID OF THIS BIT WHEN THE COMMAND FLOATS FREE LATER
      if ( nsons(sectionRoot) <= 2 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'ChunkDivide section cannot be empty' )
      do i = 2, nsons(sectionRoot)-1      ! Skip the begin/end section
        root = subtree(i,sectionRoot)
        if ( node_id(root) /= n_named ) cycle
        if ( get_spec_id(root) == s_chunkDivide ) exit
      end do
d627 1
a627 1
      ! Loop through the command identifying parameters.
d632 3
d638 1
a638 1
          fieldValue = decoration(subtree(2,son)) ! The field's value
d640 2
a641 1
          fieldValue = son
d704 1
a704 1
          ChunkDivideConfig%allowPostOverlaps = .not. get_boolean ( fieldValue )
d707 1
a707 1
            & 'You have elected to exclude MAFs after to time range' )
d709 1
a709 1
          ChunkDivideConfig%allowPriorOverlaps = .not. get_boolean ( fieldValue )
d717 1
a717 1
          ChunkDivideConfig%skipL1BCheck = get_boolean ( fieldValue )
d722 1
a722 1
          ChunkDivideConfig%crashIfPhiNotMono = get_boolean ( fieldValue )
d728 1
a728 1
          ChunkDivideConfig%saveObstructions = get_boolean ( fieldValue )
d733 2
d832 2
a897 110
  ! -------------------------------------------- Dump_config -----
  subroutine Dump_config(config)

    use Intrinsic, only: PHYQ_INDICES

    ! Args
    type(ChunkDivideConfig_T), intent(in) :: Config

    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    call output ( 'method ' )
    call display_string ( lit_indices(Config%method), &
      &             strip=.true., advance='yes' )
    call output ( 'max Length ' )
    call output ( config%maxLength, advance='yes' )
    call output ( 'max Length Family ' )
    call display_string ( phyq_indices(Config%maxLengthFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'num chunks ' )
    call output ( config%noChunks, advance='yes' )
    call output ( 'overlap ' )
    call output ( config%overlap, advance='yes' )
    call output ( 'overlap Family ' )
    call display_string ( phyq_indices(Config%overlapFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'lower overlap ' )
    call output ( config%loweroverlap, advance='yes' )
    call output ( 'lower overlap Family ' )
    call display_string ( phyq_indices(Config%loweroverlapFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'upper overlap ' )
    call output ( config%upperoverlap, advance='yes' )
    call output ( 'upper overlap Family ' )
    call display_string ( phyq_indices(Config%upperoverlapFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'num slaves ' )
    call output ( config%noSlaves, advance='yes' )
    call output ( 'home module ' )
    call display_string ( lit_indices(Config%homeModule), &
      &             strip=.true., advance='yes' )
    call output ( 'home Geod Angle ' )
    call output ( config%homeGeodAngle, advance='yes' )
    call output ( 'set scan lower limit? ' )
    call output ( config%scanLLSet, advance='yes' )
    if ( config%scanLLSet ) then
    call output ( 'Bottom scan range ' )
    call output ( config%scanLowerLimit, advance='yes' )
    endif
    call output ( 'set scan upper limit? ' )
    call output ( config%scanULSet, advance='yes' )
    if ( config%scanULSet ) then
    call output ( 'Top scan range ' )
    call output ( config%scanUpperLimit, advance='yes' )
    endif
    call output ( 'max out-of-plane distance ' )
    call output ( config%maxOrbY, advance='yes' )
    call output ( 'critical modules ' )
    call display_string ( lit_indices(Config%criticalModules), &
      &             strip=.true., advance='yes' )
    call output ( 'critical bands ' )
    call output ( trim(config%criticalBands), advance='yes' )
    call output ( 'use critical modules to choose critical signals?' )
    call output ( config%chooseCriticalSignals, advance='yes' )
    call output ( 'max gap ' )
    call output ( config%maxGap, advance='yes' )
    call output ( 'max Gap Family ' )
    call display_string ( phyq_indices(Config%maxGapFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'skip check of l1b files ' )
    call output ( config%skipL1BCheck, advance='yes' )
    call output ( 'allow overlaps to prior day?' )
    call output ( config%allowPriorOverlaps, advance='yes' )
    call output ( 'allow overlaps to next day?' )
    call output ( config%allowPostOverlaps, advance='yes' )
    call output ( 'save obstructions?' )
    call output ( config%saveObstructions, advance='yes' )
    call output ( 'DACS already deconvolved?' )
    call output ( config%DACSDeconvolved, advance='yes' )
    call Dump_criticalSignals(config%criticalSignals)
  end subroutine Dump_config

  ! -------------------------------------------- Dump_criticalSignals -----
  subroutine Dump_criticalSignals(criticalSignals)

    use Output_M, only: OUTPUT

    character(len=160), dimension(:), pointer &
      & :: criticalSignals       ! Which signals must be on
    ! Local variables
    integer :: i                        ! Loop counter
    ! Executable code
    swlevel = switchDetail(switches, 'chu' )
    if ( associated ( criticalSignals ) ) then
      if ( size(criticalSignals) == 0 ) then
        call output ( 'criticalSignals is a zero size array.', advance='yes' )
      else
        call output ( 'Dumping ' )
        call output ( size(criticalSignals) )
        call output ( ' criticalSignals:', advance='yes' )
        do i = 1, size(criticalSignals)
          call output ( i )
          call output ( ': ' )
          call output ( trim(criticalSignals(i)), advance='yes' )
        end do
      end if
    else
      call output ( 'critical Signals is not associated.', advance='yes')
    end if
  end subroutine Dump_criticalSignals

d2578 1
a2578 1
       "$Id: ChunkDivide_m.f90,v 2.104 2013/08/12 23:49:41 pwagner Exp $"
d2588 3
@


2.104
log
@FindSomethings moved to MLSFinds module
@
text
@d226 1
d246 1
a246 1
    if ( toggle(gen) ) call trace_begin ( "ChunkDivide", root )
d376 2
a377 3
    if ( specialDumpFile /= ' ' ) &
      & call revertOutput
    if ( toggle(gen) ) call trace_end ( "ChunkDivide" )
d2707 1
a2707 1
       "$Id: ChunkDivide_m.f90,v 2.103 2013/06/28 19:02:58 pwagner Exp $"
d2717 3
@


2.103
log
@criticalSignals may be used in place of criticalModules; it will be effective everywhere in marking obstructions
@
text
@d40 1
a40 1
  use MLSSETS, only: FINDFIRST
d2707 1
a2707 1
       "$Id: ChunkDivide_m.f90,v 2.102 2013/06/21 17:37:38 pwagner Exp $"
d2717 3
@


2.102
log
@/crashIfPhiNotMono flag added to ChunkDivide config; default is to just warn; removed -Snmono switch
@
text
@d608 1
a608 1
      integer, target, dimension(6) :: NeededForOrbital = &
d610 2
a611 1
        &    f_criticalModules, f_maxGap /)
d1481 2
a1482 2
      use MLSSIGNALS_M, only: DUMPSIGNALS=>DUMP, GETSIGNALNAME, &
        & SIGNALS
d1505 1
d1554 1
a1554 1
        & 'signals_buffer', ModuleName)
d1556 1
a1556 1
        & 'goods_after_gap', ModuleName)
d1558 1
a1558 1
        & 'goodness_changes', ModuleName)
d1569 17
a1586 1
        if ( swLevel >= VERBOSETHRESHOLD ) call dumpSignals( signals(signalIndex) )
a1589 1
        if ( swLevel >= VERBOSETHRESHOLD ) call outputNamedValue( 'critical module', critical_module_str )
d1598 2
d1601 2
d1632 1
d1636 1
d1658 1
d1748 3
a1750 3
        call outputNamedValue ( 'count(valids_buffer)', count(valids_buffer), advance='yes')
        call output ( 'Before converting valids to obstructions', advance='yes' )
        call dump(obstructions)
d1755 2
a1756 2
        call output ( 'After converting valids to obstructions', advance='yes' )
        call dump(obstructions)
d1789 3
a1791 2
      call deallocate_test( goods_after_gap, 'goods_after_gap', ModuleName)
      call deallocate_test( goodness_changes, 'goodness_changes', ModuleName)
d2707 1
a2707 1
       "$Id: ChunkDivide_m.f90,v 2.101 2013/06/20 17:56:16 pwagner Exp $"
d2717 3
@


2.101
log
@-Snmono lets us warn, not quit if phi not monotonic
@
text
@d20 2
a21 2
  use INIT_TABLES_MODULE, only: F_CRITICALBANDS, F_CRITICALMODULES, &
      & F_CRITICALSIGNALS, &
d106 1
d743 6
d759 5
d2019 2
a2020 2
      ! Default severity (probably ERROR) can be reduced to a warning 
      ! by adding -Snmono to command line
d2023 4
a2026 1
      if ( switchDetail(switches,'nmono') > -1 ) then ! be lenient
a2027 2
      else
        severity = severityifphinotmono
d2682 1
a2682 1
       "$Id: ChunkDivide_m.f90,v 2.100 2013/05/21 22:50:24 pwagner Exp $"
d2692 3
@


2.100
log
@Workaround for ifort13 bug
@
text
@d67 2
a68 2
  public :: ChunkDivide, CFM_ChunkDivide, &
    & DestroyChunkDatabase, ReduceChunkDatabase
d76 1
a76 1
  public :: ChunkDivideConfig_T
d126 1
a126 1
  type(ChunkDivideConfig_T), public, save :: ChunkDivideConfig
d134 1
a134 1
  public :: Obstruction_T
d151 1
a151 3
  logical, parameter :: CHECKFORMAFSINRANGE = .true.
  logical, parameter :: CHECKFORNONNEGOVLPS = .true.
  logical, parameter :: BOMBIFPHINOTMONO = .true.
a432 1
      integer :: NONONOVERLAP             ! maxLength-2*overlap
a442 1
      noNonOverlap = maxLength - ( lowerOverlap + upperOverlap )
a484 1
      real(r8) :: MAXTIME                 ! Time range in data
a485 1
      real(r8) :: MINTIME                 ! Time range in data
a524 2
      minTime = minval ( taiTime%dpField(1,1,m1:m2) )
      maxTime = maxval ( taiTime%dpField(1,1,m1:m2) )
d1943 1
a1943 2
            if ( BOMBIFPHINOTMONO .and. &
              & .not. ChunkDivideConfig%skipL1BCheck ) then
d1946 2
a1947 2
                call MLSMessage ( MLSMSG_Error, ModuleName, &
                  & 'tpGeodAngle is not monotonic--must quit', MLSFile=L1BFile )
d2005 12
d2669 1
a2669 1
       "$Id: ChunkDivide_m.f90,v 2.99 2012/06/21 00:41:08 pwagner Exp $"
d2679 3
@


2.99
log
@Added phi start and end to be used someday by HGrid
@
text
@d1476 1
a1476 1
      use MLSSIGNALS_M, only: DUMP, GETSIGNALNAME, &
d1564 1
a1564 1
        if ( swLevel >= VERBOSETHRESHOLD ) call dump( signals(signalIndex) )
d2666 1
a2666 1
       "$Id: ChunkDivide_m.f90,v 2.98 2012/03/14 16:56:26 pwagner Exp $"
d2676 3
@


2.98
log
@NAG-debug required this change
@
text
@d2368 8
d2394 2
d2498 7
d2509 3
a2511 2
      end if

d2666 1
a2666 1
       "$Id: ChunkDivide_m.f90,v 2.97 2011/11/30 21:33:13 pwagner Exp $"
d2676 3
@


2.97
log
@Quits with message if GeodAngle not monotonic
@
text
@d2465 2
a2466 1
      call DealWithObstructions ( chunks, obstructions )
d2648 1
a2648 1
       "$Id: ChunkDivide_m.f90,v 2.96 2011/06/29 21:50:20 pwagner Exp $"
d2658 3
@


2.96
log
@Some cases may safely omit l1b files
@
text
@d153 1
d1825 1
d1951 8
d2005 1
a2005 1
      if ( .not. ChunkDivideConfig%skipL1BCheck) &
d2647 1
a2647 1
       "$Id: ChunkDivide_m.f90,v 2.95 2011/02/05 01:41:44 pwagner Exp $"
d2657 3
@


2.95
log
@Define and use consistently swLevel to control dump verboseness
@
text
@d17 4
a20 17
  use Intrinsic, only: L_NONE, PHYQ_INVALID
  use MLSCommon, only: R8, RP
  use MLSSets, only: FINDFIRST
  use MLSCommon, only: MLSFile_T, TAI93_Range_T
  use Chunks_m, only: MLSCHUNK_T, Dump
  use L1BData, only: L1BData_T, READL1BDATA, GetL1bFile, NAME_LEN, &
      & AssembleL1BQtyName, PRECISIONSUFFIX, DEALLOCATEL1BDATA
  use Intrinsic, only: L_NONE, FIELD_INDICES, LIT_INDICES, PHYQ_ANGLE, &
      & PHYQ_DIMENSIONLESS, PHYQ_LENGTH, PHYQ_MAFS, PHYQ_TIME
  use MLSMessageModule, only: MLSMessage, MLSMSG_Deallocate, MLSMSG_Warning, &
                              MLSMSG_Error, MLSMSG_Allocate
  use MLSFiles, only: dump, GetMLSFileByType, mls_OpenFile
  use TOGGLES, only: GEN, TOGGLE, SWITCHES
  use Output_M, only: BLANKS, OUTPUT, outputNamedValue, &
      & revertoutput, switchOutput
  use Dump_0, only: DUMP
  use Init_Tables_Module, only: F_CRITICALBANDS, F_CRITICALMODULES, &
d30 17
a46 5
  use String_table, only: GET_STRING
  use MLSStringLists, only: SWITCHDETAIL
  use MLSNumerics, only: Hunt
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use MLSSignals_m, only: MODULES
d161 1
a161 1
    use Allocate_Deallocate, only: DEALLOCATE_TEST
d206 7
a212 13
    use L1BData, only: DEALLOCATEL1BDATA, L1BDATA_T, READL1BDATA, &
      & AssembleL1BQtyName, GetL1BFile
    use Lexer_core, only: PRINT_SOURCE
    use MLSCommon, only: R8, RP, MLSFile_T, TAI93_Range_T
    use MLSHDF5, only: GetHDF5Attribute
    use MLSL2Options, only: SPECIALDUMPFILE
    use MLSSets, only: FINDFIRST
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, &
      & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMSG_WARNING
    use MoreTree, only: GET_BOOLEAN, GET_FIELD_ID, GET_SPEC_ID
    use String_table, only: GET_STRING, DISPLAY_STRING
    use Time_M, only: Time_Now
d214 3
a216 3
    use Tree, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, SUBTREE, SUB_ROSA
    use Tree_types, only: N_NAMED
    use HDF5, only: h5gclose_f, h5gopen_f
d235 1
d258 3
a260 1
    if ( ChunkDivideConfig%method /= l_fixed ) then
d290 5
a294 1
      call ChunkDivide_PE ( mafRange%Expanded, filedatabase, chunks )
d296 5
a300 1
      call ChunkDivide_Orbital ( mafRange, filedatabase, chunks )
d302 5
a306 1
      call ChunkDivide_Even ( mafRange%Expanded, filedatabase, chunks )
d315 5
a319 2
    DACSFile => GetL1BFile ( filedatabase, 'DACsDeconvolved', '-/a' )
    if ( associated(DACSFile) ) then
d403 4
d914 1
a914 3
    use Intrinsic, only: LIT_INDICES, phyq_indices
    use Output_M, only: OUTPUT
    use String_table, only: DISPLAY_STRING
d1073 2
a1074 4
    use MLSCommon, only: MLSFile_T, RK => R8
    use MLSFiles, only: GetMLSFileByType
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only: GetSignalName
d1150 2
a1151 2
    use MLSStringLists, only: NumStringElements, StringElement
    use MLSStrings, only: readIntsFromChars
d1408 3
a1410 3
      use MLSSignals_m, only: GetSignalName, SIGNALS
      use MLSStringLists, only: catLists, List2Array
      use MLSStrings, only: lowercase
d1475 1
a1475 1
      use MLSSignals_m, only: Dump, GetSignalName, &
d1477 3
a1479 4
      use MLSStringLists, only: NumStringElements, GetStringElement
      use MLSStrings, only: lowercase
      use Parse_signal_m, only: Parse_signal
      use String_table, only: GET_STRING
d1824 1
a1824 2
      use MLSL2Options, only: SharedPCF
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d2617 1
a2617 1
    use MLSStrings, only: trim_safe
d2637 1
a2637 1
       "$Id: ChunkDivide_m.f90,v 2.94 2010/04/20 17:32:23 honghanh Exp $"
d2647 3
@


2.94
log
@Abandon attempt to remove the requirement to have a maxMafLength
in ChunkDivide_Orbital
@
text
@d155 2
d248 1
d266 1
a266 1
      if ( switchDetail(switches, 'chu' ) > -1 ) then
d328 1
a328 1
    if ( switchDetail(switches, 'chu') > -1 .or. &
d331 1
a331 1
      if ( switchDetail(switches, 'chu' ) > -1 ) call Dump_Obstructions ( obstructions )
d339 1
a339 1
      if ( switchDetail(switches, 'chu' ) > -1 ) &
d363 1
a363 1
    if ( switchDetail(switches, 'chu' ) > -1 ) call dump ( chunks )
d421 2
a422 1
      ! Exectuable code
d483 1
d628 1
d907 1
d989 1
d1017 1
d1084 1
d1170 1
d1213 1
d1356 1
d1378 1
d1412 1
d1424 1
a1424 1
      if ( switchDetail(switches, 'chu') > -1 ) &
d1426 1
a1426 1
      if ( switchDetail(switches, 'chu') > -1 ) &
d1429 1
a1429 1
        if ( switchDetail(switches, 'chu') > -1 ) then
d1457 1
a1457 1
      if ( switchDetail(switches, 'chu') > -1 ) &
a1514 1
      integer :: swLevel ! How much extra debugging info to print (-1 means none)
a1516 1
      integer, parameter :: VERBOSETHRESHOLD = 1 ! was 0; turn on extra debugging
d1733 1
a1733 1
          if ( switchDetail(switches, 'chu') > -1 ) &
d1743 1
a1743 1
          if ( switchDetail(switches, 'chu') > -1 ) &
d1772 1
d1792 1
a1792 1
            if ( switchDetail(switches, 'chu') > -1 ) &
d1804 1
a1804 1
        if ( switchDetail(switches, 'chu') > -1 ) &
d1847 1
d1903 1
d1944 4
d2011 1
d2133 2
a2134 1
      if ( index ( switches, 'chu' ) /= 0 ) then
d2151 1
a2151 1
      if ( index ( switches, 'chu' ) /= 0 ) &
d2156 1
a2156 1
      if ( index ( switches, 'chu' ) /= 0 ) &
d2159 1
a2159 1
      if ( index ( switches, 'chu' ) /= 0 ) &
d2162 1
a2162 1
      if ( index ( switches, 'chu' ) /= 0 ) &
d2178 1
a2178 1
      if ( index ( switches, 'chu' ) /= 0 ) then
d2202 1
a2202 1
      if ( switchDetail(switches, 'chu' ) > -1 ) then
d2243 1
a2243 1
      if ( switchDetail(switches, 'chu' ) > -1 ) then
d2351 1
a2351 1
        if ( switchDetail(switches, 'chu' ) > -1 ) then
d2401 1
a2401 1
      if ( switchDetail(switches, 'chu' ) > -1 ) then
d2427 1
a2427 1
      if ( switchDetail(switches, 'chu' ) > -1 ) then
d2439 1
a2439 1
      if ( index ( switches, 'chu' ) /= 0 ) then
d2468 1
a2468 1
      if ( switchDetail(switches, 'chu' ) > -1 ) then
d2491 1
d2532 1
d2628 1
a2628 1
       "$Id: ChunkDivide_m.f90,v 2.92 2010/03/23 23:53:08 honghanh Exp $"
d2638 4
@


2.93
log
@Fix a bug of using uninitialized variable
@
text
@d2238 5
a2243 6
           maxLength = nint ( ChunkDivideConfig%maxLength )
           noMAFsBelowHome = home - m1
           noChunksBelowHome = noMAFsBelowHome / maxLength
           if ( mod ( noMAFsBelowHome, maxLength ) /= 0 ) &
              noChunksBelowHome = noChunksBelowHome + 1
           noMAFsAtOrAboveHome = m2 - home + 1
@


2.92
log
@Move most subroutine inside ChunkDivide out, including
ChunkDivide_Orbital, create CFM_ChunkDivide, which call
ChunkDivide_Orbital
@
text
@a2241 2
           ! If user did not request specific number of chunks choose them
           noChunks = noChunksBelowHome + noMAFsAtOrAboveHome / maxLength
d2245 2
d2342 1
a2342 1
          call output ( NoChunks , advance='yes' )
d2605 1
a2605 1
       "$Id: ChunkDivide_m.f90,v 2.91 2009/06/23 18:46:18 pwagner Exp $"
d2615 5
@


2.91
log
@Prevent Intel from optimizing ident string away
@
text
@d20 28
d52 3
a54 3
! === (start of toc) ===                                                 
!     c o n t e n t s                                                    
!     - - - - - - - -                                                    
d56 2
a57 2
! ChunkDivide              Divide MAFs in processing range among chunks  
! DestroyChunkDatabase     Deallocate memory taken by chunk database     
d59 1
a59 1
! === (end of toc) ===                                                   
d61 1
a61 1
! log any_good_signaldata ( int signal, int sideband, 
d65 2
a66 2
!    *MLSFile_T filedatabase(:), *mlSChunk_T Chunks(:) )      
! DestroyChunkDatabase (*mlSChunk_T Chunks(:) )      
d68 1
a68 1
  public :: ChunkDivide, &
d74 1
a74 1
  private :: not_used_here 
d125 1
a125 1
  ! Even - Hope to have chunks all about the same length, as quoted. 
d150 1
a150 1
  
a160 2
    use Chunks_m, only: MLSCHUNK_T
    use MLSMessageModule, only: MLSMessage, MLSMSG_Deallocate, MLSMSG_Warning
a179 2
    use Chunks_m, only: MLSCHUNK_T
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate
a203 3
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use Chunks_m, only: DUMP, MLSCHUNK_T
    use Dump_0, only: DUMP
d205 1
a205 13
    use Init_Tables_Module, only: F_CRITICALBANDS, F_CRITICALMODULES, &
      & F_CRITICALSIGNALS, &
      & F_EXCLUDEPOSTOVERLAPS, F_EXCLUDEPRIOROVERLAPS, &
      & F_HOMEMODULE, F_HOMEGEODANGLE, &
      & F_MAXLENGTH, F_MAXORBY, F_METHOD, F_NOCHUNKS, F_NOSLAVES, &
      & F_OVERLAP, F_LOWEROVERLAP, &
      & F_SAVEOBSTRUCTIONS, F_SCANLOWERLIMIT, F_SCANUPPERLIMIT, &
      & F_SKIPL1BCHECK, F_UPPEROVERLAP, &
      & FIELD_FIRST, FIELD_LAST, L_EVEN, &
      & L_FIXED, F_MAXGAP, L_ORBITAL, L_PE, S_CHUNKDIVIDE, L_BOTH, L_EITHER
    use Intrinsic, only: L_NONE, FIELD_INDICES, LIT_INDICES, PHYQ_ANGLE, &
      & PHYQ_DIMENSIONLESS, PHYQ_LENGTH, PHYQ_MAFS, PHYQ_TIME
    use L1BData, only: DEALLOCATEL1BDATA, L1BDATA_T, NAME_LEN, READL1BDATA, &
a208 1
    use MLSFiles, only: dump, GetMLSFileByType, mls_OpenFile
a211 1
    use MLSStringLists, only: SWITCHDETAIL
a214 2
    use MLSNumerics, only: Hunt
    use MLSSignals_m, only: MODULES
a215 2
    use Output_M, only: BLANKS, OUTPUT, outputNamedValue, &
      & revertoutput, switchOutput
a217 1
    use TOGGLES, only: GEN, TOGGLE, SWITCHES
d264 6
a269 6
        call output ( 'Requested time range ' )          
        call output ( processingRange%startTime )              
        call output ( ' : ' )    
        call output ( processingRange%endTime, advance='yes' )    
        call output ( 'Corresponding MAF range ' )          
        call output ( mafRange%L2Cover(1) )              
d272 2
a273 2
        call output ( 'MAF range in L1B files ' )          
        call output ( mafRange%L1BCover(1) )              
d276 2
a277 2
        call output ( 'including overlapped days ' )          
        call output ( mafRange%Expanded(1) )              
d348 2
a349 2
      call MLSMessage ( MLSMSG_Error, ModuleName, &  
        & 'ChunkDivide failed to associate the chunks pointer with a target' )     
d351 2
a352 2
      call MLSMessage ( MLSMSG_Error, ModuleName, &  
        & 'ChunkDivide failed to produce any chunks' )     
a368 28
    !--------------------------------- Add obstruction to database -----
    subroutine AddObstructionToDatabase ( database, item )

      ! Dummy arguments
      type (Obstruction_T), dimension(:), pointer :: DATABASE
      type (Obstruction_T), intent(in) :: ITEM

      ! Local variables
      type (Obstruction_T), dimension(:), pointer :: TEMPDATABASE

      include "addItemToDatabase.f9h"

    end subroutine AddObstructionToDatabase

    !--------------------------------------- Add chunk to database -----
    subroutine AddChunkToDatabase ( database, item )

      ! Dummy arguments
      type (MLSChunk_T), dimension(:), pointer :: DATABASE
      type (MLSChunk_T), intent(in) :: ITEM

      ! Local variables
      type (MLSChunk_T), dimension(:), pointer :: TEMPDATABASE

      include "addItemToDatabase.f9h"

    end subroutine AddChunkToDatabase

d574 7
a580 6
    !----------------------------------------- ChunkDivide_Orbital -----
    subroutine ChunkDivide_Orbital ( mafRange, filedatabase, chunks )
      ! integer, dimension(2), intent(in) :: MAFRANGE
      type (MAFRange_T) :: MAFRange
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (MLSChunk_T), dimension(:), pointer :: CHUNKS
d582 5
a586 6
      ! Local parameters
      real(r8), parameter :: HOMEACCURACY = 3.0 ! Try to hit homeGeodAngle within this
      ! (see homeHuntLoop warning below)
      ! Local variables
      type (L1BData_T) :: TAITIME         ! From L1BOA
      type (L1BData_T) :: TPGEODANGLE     ! From L1BOA
d588 5
a592 1
      character(len=10) :: MODNAMESTR     ! Home module name as string
d594 5
a598 14
      integer :: CHUNK                    ! Loop counter
      integer :: FLAG                     ! From ReadL1B
      integer :: HOME                     ! Index of home MAF in array
      integer :: M1, M2                   ! MafRange%L2Cover + 1
      integer :: MEXP1, MEXP2             ! MafRange%Expanded + 1
      integer :: NOCHUNKSBELOWHOME        ! Used for placing chunks
      integer :: NOMAFSATORABOVEHOME      ! Fairly self descriptive
      integer :: NOMAFSBELOWHOME          ! Fairly self descriptive
      ! integer :: NOMAFS                   ! Number of MAFs to consider
      integer :: NOMAFSREAD               ! From ReadL1B
      integer :: ORBIT                    ! Used to locate home
      integer :: STATUS                   ! From allocate etc.
      integer :: NOCHUNKS                 ! Number of chunks
      integer :: MAXLENGTH                ! Max length as integer (MAFs)
d600 5
a604 2
      integer, dimension(:), pointer :: NEWFIRSTMAFS ! For thinking about overlaps
      integer, dimension(:), pointer :: NEWLASTMAFS ! For thinking about overlaps
d606 15
a620 12
      real(r8) :: ANGLEINCREMENT          ! Increment in hunt for home
      real(r8) :: MAXANGLE                ! Of range in data
      real(r8) :: MAXTIME                 ! Time range in data
      real(r8) :: MAXV                    ! Either minTime or minAngle
      real(r8) :: MINANGLE                ! Of range in data
      real(r8) :: MINTIME                 ! Time range in data
      real(r8) :: MINV                    ! Either minTime or minAngle
      real(r8) :: TESTANGLE               ! Angle to check for
      real(r8) :: HOMEV                   ! Value of angle/time at home

      real(r8), dimension(:), pointer :: BOUNDARIES ! Used in placing chunks
      real(r8), dimension(:), pointer :: FIELD ! Used in placing chunks
a621 3
      integer   ::                       l1b_hdf_version
      character(len=NAME_LEN) ::         MAF_start, tp_angle
      type (MLSFile_T), pointer             :: L1BFile
d623 1
d625 10
a634 39
      if ( index ( switches, 'chu' ) /= 0 ) then
        call output('Entering Orbital Chunk Divide', advance='yes')
        call dump( obstructions )
      endif
      ! Read in the data we're going to need
      call get_string ( lit_indices(ChunkDivideConfig%homeModule), modNameStr, strip=.true. )
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      if ( .not. associated(L1BFile) ) &
        & call MLSMessage  ( MLSMSG_Error, ModuleName, &
          & "Can't make progress in ChunkDivide_Orbital without L1BOA files" )
      ! call dump(L1BFile)
      l1b_hdf_version = L1BFile%HDFVersion
      MAF_start = AssembleL1BQtyName ( 'MAFStartTimeTAI', l1b_hdf_version, &
        .false. )
      tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
        & l1b_hdf_version, &
        & .false. )
      if ( index ( switches, 'chu' ) /= 0 ) &
        & call output('Reading Geod Angle', advance='yes')
      call ReadL1BData ( L1BFile, trim(tp_angle), &
        & tpGeodAngle, noMAFsRead, flag, &
        & dontPad=DONTPAD )
      if ( index ( switches, 'chu' ) /= 0 ) &
        & call output('1st smoothing', advance='yes')
      call smoothOutDroppedMAFs(tpGeodAngle%dpField)
      if ( index ( switches, 'chu' ) /= 0 ) &
        & call output('2nd smoothing', advance='yes')
      call smoothOutDroppedMAFs(tpGeodAngle%dpField, monotonize=.true.)
      if ( index ( switches, 'chu' ) /= 0 ) &
        & call output('Reading tai Time', advance='yes')
      call ReadL1BData ( L1BFile, trim(MAF_start), &
        & taiTime, noMAFsRead, flag, &
        & dontPad=DONTPAD )
      call smoothOutDroppedMAFs(taiTime%dpField)
      ! noMAFs = mafRange%L2Cover(2) - mafRange%L2Cover(1) + 1
      m1 = mafRange%L2Cover(1) + 1
      m2 = mafRange%L2Cover(2) + 1
      mexp1 = mafRange%Expanded(1) + 1
      mexp2 = mafRange%Expanded(2) + 1
d636 1
a636 16
      minAngle = minval ( tpGeodAngle%dpField(1,1,m1:m2) )
      maxAngle = maxval ( tpGeodAngle%dpField(1,1,m1:m2) )
      minTime = minval ( taiTime%dpField(1,1,m1:m2) )
      maxTime = maxval ( taiTime%dpField(1,1,m1:m2) )
      if ( index ( switches, 'chu' ) /= 0 ) then
        call output ( 'Num MAFs in file: ' )
        call output ( noMAFsRead, advance='yes' )
        call output ( 'MAF time range: ' )
        call output ( minTime )
        call output ( ' : ' )
        call output ( maxTime, advance='yes' )
        call output ( 'Angle range: ' )
        call output ( minAngle )
        call output ( ' : ' )
        call output ( maxAngle, advance='yes' )
      end if
d638 11
a648 42
      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! First try to locate the last MAF before the homeGeodAngle
      orbit = int ( tpGeodAngle%dpField(1,1,m1)/360.0 )
      if ( tpGeodAngle%dpField(1,1,m1) < 0.0 ) orbit = orbit - 1
      testAngle = ChunkDivideConfig%homeGeodAngle + orbit*360.0
      if ( ChunkDivideConfig%maxLengthFamily == PHYQ_Angle ) then
        angleIncrement = ChunkDivideConfig%maxLength
      else
        angleIncrement = 360.0
      end if

      if ( switchDetail(switches, 'chu' ) > -1 ) then    
        call output ( ' orbit  ', advance='no' )   
        call output ( orbit , advance='no' )      
        call output ( '    testAngle  ', advance='no' )   
        call output ( testAngle , advance='no' )      
        call output ( '    angleIncrement  ', advance='no' )   
        call output ( angleIncrement , advance='yes' )      
      end if
      ! In my opinion (paw) here's what the following loop should do:
      ! Find the 1st MAF within HOMEACCURACY of home_angle
      ! where home_angle has been corrected for the starting orbit number
      ! Afterwards, the preceding MAFs must be divided among one or more
      ! chunks, and the same done with subsequent MAFs
      !
      ! Instead what it actually does is
      ! Find the 1st MAF within HOMEACCURACY of (home_angle + n*angleIncrement)
      ! where home_angle has been corrected for the starting orbit number
      ! In effect the home_angle is set only within an unknown number
      ! of angleIncrements
      ! While there may be few cases in which they don't do about as well
      ! let this be a warning
      homeHuntLoop: do
        if ( testAngle < minAngle ) then
          testAngle = testAngle + angleIncrement
          cycle
        endif
        if ( testAngle > maxAngle ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'Unable to establish a home major frame, using the first in your range' )
          home = m1
          exit homeHuntLoop
d650 8
a657 330
        ! Find MAF which starts before this test angle
        call Hunt ( tpGeodAngle%dpField(1,1,:), testAngle, home, nearest=.true.,&
          & allowTopValue = .true. )
        ! Now if this is close enough, accept it
        if ( abs ( tpGeodAngle%dpField(1,1,home) - &
          & testAngle ) < HomeAccuracy ) exit homeHuntLoop
        ! Otherwise, keep looking
        testAngle = testAngle + angleIncrement
      end do homeHuntLoop
      if ( switchDetail(switches, 'chu' ) > -1 ) then    
        call output ( 'Test Angle  ' )   
        call output ( testAngle , advance='yes' )      
        call output ( 'Angle(home)  ' )   
        call output ( tpGeodAngle%dpField(1,1,home) , advance='yes' )      
        call output ( 'Home  ' )   
        call output ( home  )      
        call output ( 'Difference  ' )   
        call output (  abs ( tpGeodAngle%dpField(1,1,home) - &
          & testAngle ) , advance='yes' )      
      end if

      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! OK, now we have a home MAF, get a first cut for the chunks
      ! We work out the chunk ends for each chunk according to how the
      ! maxLength field is specified.
      if ( ChunkDivideConfig%maxLengthFamily == PHYQ_MAFs ) then
        maxLength = nint ( ChunkDivideConfig%maxLength )
        noMAFsBelowHome = home - m1
        noChunksBelowHome = noMAFsBelowHome / maxLength
        if ( mod ( noMAFsBelowHome, maxLength ) /= 0 ) noChunksBelowHome = noChunksBelowHome + 1
        noMAFsAtOrAboveHome = m2 - home + 1
        if ( ChunkDivideConfig%noChunks == 0 ) then
          ! If user did not request specific number of chunks choose them
          noChunks = noChunksBelowHome + noMAFsAtOrAboveHome / maxLength
          if ( mod ( noMAFsAtOrAboveHome, maxLength ) /= 0 ) &
            & noChunks = noChunks + 1
        else
          ! User requested specific number of chunks
          noChunks = ChunkDivideConfig%noChunks
        end if

        ! Allocate the chunks
        allocate ( chunks(noChunks), stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'chunks (maxLength/MAFs)' )

        ! Work out their positions
        do chunk = 1, noChunks
          chunks(chunk)%lastMAFIndex = home + &
            & ( chunk - noChunksBelowHome ) * maxLength - 1
          ! Subtract one to convert from index in array to index in file
        end do
      else
        ! For angle and time, they are similar enough we'll just do some stuff
        ! with pointers to allow us to use common code to sort them out
        select case ( ChunkDivideConfig%maxLengthFamily )
        case ( PHYQ_Angle )
          field => tpGeodAngle%dpField(1,1,:)
          minV = minAngle
          maxV = maxAngle
        case ( PHYQ_Time )
          field => taiTime%dpField(1,1,:)
          minV = minTime
          maxV = maxTime
        case ( PHYQ_MAFs)
        end select
        homeV = field(home)

        noMAFsBelowHome = -999
        noMAFsAtOrAboveHome = -999
        noChunksBelowHome = int ( &
          & ( homeV - minV ) / ChunkDivideConfig%maxLength )
        if ( homeV > minV ) noChunksBelowHome = noChunksBelowHome + 1
        if ( ChunkDivideConfig%noChunks == 0 ) then
          ! Choose the number of chunks ourselves
          noChunks = noChunksBelowHome + int ( &
            & ( maxV - homeV ) / ChunkDivideConfig%maxLength )
          if ( homeV + ChunkDivideConfig%maxLength * &
            & ( noChunks - noChunksBelowHome ) < maxV ) &
            & noChunks = noChunks + 1
          if ( (mexp1 < m1) .and. ( &
            & homeV + (ChunkDivideConfig%maxLength-1) + &
            & ChunkDivideConfig%maxLength * &
            & ( noChunks - 1 - noChunksBelowHome ) < maxV ) ) &
            & noChunks = noChunks + 1
        else
          noChunks = ChunkDivideConfig%noChunks
        end if

        ! Allocate the chunks
        allocate ( chunks(noChunks), stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'chunks (maxLength/time/angle)' )

        ! Work out their positions
        ! Boundaries are the angles/times at the end of the chunks
        nullify ( boundaries )
        call Allocate_test ( boundaries, noChunks, 'boundaries', ModuleName )
        ! When we allow prior overlaps, the first chunk 
        ! sometimes has 1 too many MAFs unless we take extra care
        if ( mexp1 == m1 ) then
          do chunk = 1, noChunks
            boundaries(chunk) = homeV + &
              & ( chunk - noChunksBelowHome ) * ChunkDivideConfig%maxLength
          end do
        else
          boundaries(1) = homeV + &
            & ( 1 - noChunksBelowHome ) * (ChunkDivideConfig%maxLength - 1)
          do chunk = 2, noChunks
            boundaries(chunk) = boundaries(chunk-1) + &
              & ChunkDivideConfig%maxLength
          end do
        endif
        boundaries = min ( boundaries, maxV )
        boundaries = max ( boundaries, minV )

        ! Do some dumping
        if ( switchDetail(switches, 'chu' ) > -1 ) then
          call output ( ' minV: ' ) 
          call output ( minV  ) 
          call output ( ' maxV: ' ) 
          call output ( maxV , advance='yes' ) 
          call output ( ' homeV: ' ) 
          call output ( homeV , advance='yes' ) 
          call output ( ' noMAFSBelowHome: ' )
          call output ( noMAFsBelowHome, advance='yes' )
          call output ( ' noMAFSAtOrAboveHome: ' )
          call output ( noMAFsAtOrAboveHome, advance='yes' )
          call output ( ' NoChunks: ' ) 
          call output ( NoChunks , advance='yes' ) 
          call output ( ' noChunksBelowHome: ' ) 
          call output ( noChunksBelowHome , advance='yes' ) 
          call dump ( boundaries , 'boundaries' ) 
          call dump ( field, 'field' )
        end if

        call Hunt ( field, boundaries, chunks%lastMAFIndex, start=m1, &
          & allowTopValue=.true., nearest=.true. )
        call Deallocate_test ( boundaries, 'boundaries', ModuleName )
      end if

      ! Now deduce the chunk starts from the ends of their predecessors
      if ( noChunks > 1 ) &
        & chunks(2:noChunks)%firstMAFIndex = &
        & chunks(1:noChunks-1)%lastMAFIndex + 1
      chunks(1)%firstMAFIndex = m1

      ! Now bound the chunks to be within the processing range
      chunks%firstMAFIndex = min ( max ( chunks%firstMAFIndex, m1 ), m2 )
      chunks%lastMAFIndex = min ( max ( chunks%lastMAFIndex, m1 ), m2 )

      ! Now offset these to the index in the file not the array
      ! chunks%firstMAFIndex = chunks%firstMAFIndex + mafRange(1) - 1
      ! chunks%lastMAFIndex = chunks%lastMAFIndex + mafRange(1) - 1 
      chunks%firstMAFIndex = chunks%firstMAFIndex - 1
      chunks%lastMAFIndex = chunks%lastMAFIndex - 1 

      ! If at this point the last two chunks end in the same place, this is
      ! a subtle defect in our chunking algorihtm, lets avoid it
      if ( noChunks > 1 ) then
        if ( chunks(noChunks-1)%lastMAFIndex == chunks(noChunks)%lastMAFIndex ) then
          call DeleteChunk ( chunks, noChunks )
          noChunks = noChunks - 1
        end if
      end if

      ! Do some dumping
      if ( switchDetail(switches, 'chu' ) > -1 ) then                      
        call dump ( chunks%lastMAFIndex , 'chunks%lastMAFIndex' )
        call dump ( chunks%firstMAFIndex , 'chunks%firstMAFIndex' )  
      end if

      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! Think about overlaps
      nullify ( newFirstMAFs, newLastMAFs )
      call Allocate_test ( newFirstMAFs, noChunks, 'newFirstMAFs', ModuleName )
      call Allocate_test ( newLastMAFs, noChunks, 'newLastMAFs', ModuleName )
      ! We could split things out to deal with mixed unit, but lets make life easier 
      ! for ourselves.  ChunkDivideL2PC has already insisted that 
      ! lowerOverlapFamily == upperOverlapFamily.
      if ( ChunkDivideConfig%lowerOverlapFamily == PHYQ_MAFs ) then
        newFirstMAFs = max(chunks%firstMAFIndex - nint(ChunkDivideConfig%lowerOverlap), &
          & m1 - 1 )
        newLastMAFs = min(chunks%lastMAFIndex + nint(ChunkDivideConfig%upperOverlap), &
          & m2 - 1 )
      else
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'The bit of code that deals with non-MAF overlaps is probably broken' )
      end if
      chunks%noMAFsLowerOverlap = chunks%firstMAFIndex - newFirstMAFs
      chunks%noMAFsUpperOverlap = newLastMAFs - chunks%lastMAFIndex
      chunks%firstMAFIndex = newFirstMAFs
      chunks%lastMAFIndex = newLastMAFs
      if ( switchDetail(switches, 'chu' ) > -1 ) then
        call dump ( newFirstMAFs , 'newFirstMAFs' ) 
        call dump ( newLastMAFs , 'newLastMAFs' ) 
        call dump ( chunks%noMAFsLowerOverlap , 'chunks%noMAFsLowerOverlap' ) 
        call dump ( chunks%noMAFsUpperOverlap , 'chunks%noMAFsUpperOverlap' ) 
      endif
      call Deallocate_test ( newFirstMAFs, 'newFirstMAFs', ModuleName )
      call Deallocate_test ( newLastMAFs, 'newLastMAFs', ModuleName )

      ! Delete any zero length or all overlapped chunks
      call PruneChunks ( chunks )

      if ( index ( switches, 'chu' ) /= 0 ) then
        call output ( 'Before dealing with obstructions', advance='yes' )
        call Dump ( chunks )
      end if

      ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ! Now think about the obstructions
      call DealWithObstructions ( chunks, obstructions )

      ! Delete any zero length or all overlapped chunks
      call PruneChunks ( chunks )

!       ! Forcibly zero out number of lower (upper) overlaps on 1st (last) chunks
      noChunks = size ( chunks )
!       chunks(1)%noMAFsLowerOverlap = 0
!       chunks(noChunks)%noMAFsUpperOverlap = 0

      ! Add lower overlap to first chunk if allowed
      if ( mexp1 < m1 ) then
        chunks(1)%firstMAFIndex = chunks(1)%firstMAFIndex + mexp1 - m1
        chunks(1)%noMAFsLowerOverlap = m1 - mexp1
      endif

      ! Add upper overlap to last chunk if allowed
      if ( mexp2 > m2 ) then
        chunks(noChunks)%lastMAFIndex = chunks(noChunks)%lastMAFIndex + mexp2 - m2
        chunks(noChunks)%noMAFsUpperOverlap = mexp2 - m2
      endif

      if ( switchDetail(switches, 'chu' ) > -1 ) then
        call output ( 'After dealing with obstructions', advance='no' )
        call output ( ', poss. overlaps outside proc. range', advance='yes' )
        call Dump ( chunks )
      end if

      ! Tidy up
      call DeallocateL1BData ( tpGeodAngle )
      call DeallocateL1BData ( taiTime )

    end subroutine ChunkDivide_Orbital

    !--------------------------------------------- ChunkDivideL2CF -----
    subroutine ChunkDivideL2CF ( sectionRoot )
      ! This subroutine identifies, separates, and checks values from the section
      ! of the MLSCF (ChunkDivide) passed to Scan/Divide.
      integer, intent(in) :: SECTIONROOT    ! Root of the ChunkDivide section of the
      ! MLSCF abstract syntax tree
      ! type (ChunkDivideConfig_T), intent(out) :: CONFIG ! Result of operation

      integer, target, dimension(3) :: NeededForFixed = &
        & (/ f_noChunks, f_maxLength, f_overlap /)
      integer, target, dimension(7) :: NotWantedForFixed = &
        & (/ f_noSlaves, f_homeModule, f_homeGeodAngle, f_scanLowerLimit, &
        &    f_scanUpperLimit, f_criticalModules, f_maxGap /)

      integer, target, dimension(3) :: NeededForPE = &
        & (/ f_maxLength, f_homeModule, f_homeGeodAngle /)
      integer, target, dimension(7) :: NotWantedForPE = &
        & (/ f_noChunks, f_overlap, f_noSlaves, f_scanLowerLimit, &
        &    f_scanUpperLimit, f_criticalModules, f_maxGap /)

      integer, target, dimension(6) :: NeededForOrbital = &
        & (/ f_maxLength, f_overlap, f_homeModule, f_homeGeodAngle, &
        &    f_criticalModules, f_maxGap /)
      integer, target, dimension(1) :: NotWantedForOrbital = &
        & (/ f_noSlaves /)

      integer, target, dimension(6) :: NeededForEven = &
        & (/ f_maxLength, f_overlap, f_maxLength, f_noSlaves, f_maxGap, &
        &    f_criticalModules /)
      integer, target, dimension(3) :: NotWantedForEven = &
        & (/ f_noChunks, f_homeModule, f_homeGeodAngle /)

      ! Local variables
      integer :: FIELDINDEX               ! Tree type
      integer :: fieldValue               ! Node in the tree
      integer :: GSON                     ! A son of son the ChunkDivide section node
      integer :: I                        ! Loop inductor
      integer :: J                        ! Another loop inductor
      integer :: numCriticalSignals       ! How many crit. Sigs
      integer :: ROOT                     ! Root of ChunkDivide command
      integer :: signalsNode              ! Node where crit. Sig. begin
      integer :: SON                      ! A son of the ChunkDivide section node
      integer :: UNITS(2)                 ! Units of expression
      integer, dimension(:), pointer :: NEEDED ! Which fields are needed
      integer, dimension(:), pointer :: NOTWANTED ! Which fields are not wanted
      logical :: GOT(field_first:field_last) = .false.
      real(rp) :: VALUE(2)                ! Value of expression

      ! Executable code
      error = 0

      ! Eventually the ChunkDivide command will be free floating, in the meantime
      ! find it within the section
      ! WE CAN GET RID OF THIS BIT WHEN THE COMMAND FLOATS FREE LATER
      if ( nsons(sectionRoot) <= 2 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'ChunkDivide section cannot be empty' )
      do i = 2, nsons(sectionRoot)-1      ! Skip the begin/end section
        root = subtree(i,sectionRoot)
        if ( node_id(root) /= n_named ) cycle
        if ( get_spec_id(root) == s_chunkDivide ) exit
      end do

      got = .false.

      ! Loop through the command identifying parameters.
      do i = 2, nsons(root) ! Skip the command
        son = subtree(i,root)
        fieldIndex = get_field_id(son)
        got(fieldIndex) = .true.
        if (nsons(son) > 1 ) then
          gson = subtree(2,son)
          call expr ( gson, units, value )
          fieldValue = decoration(subtree(2,son)) ! The field's value
        else
          fieldValue = son
        end if
        ! Get value for this field if appropriate
        select case ( fieldIndex )
        case ( f_method )
          ChunkDivideConfig%method = decoration ( gson )
        case ( f_noChunks )
          ChunkDivideConfig%noChunks = nint ( value(1) )
        case ( f_maxLength )
          ChunkDivideConfig%maxLength = value(1)
d770 232
a1001 3
          ChunkDivideConfig%upperOverlapFamily = ChunkDivideConfig%overlapFamily
        end if
      end if
d1003 1
a1003 10
      ! Check we've got all the arguments we need
      do i = 1, size(needed)
        if ( .not. got(needed(i) ) ) &
          & call AnnounceError ( root, notSpecified, needed(i) )
      end do
      ! Check we don't have unnecessary ones
      do i = 1, size(notWanted)
        if ( got(notWanted(i) ) ) &
          & call AnnounceError ( root, unnecessary, notWanted(i) )
      end do
d1005 7
a1011 6
      ! Make other checks of parameters
      if ( ChunkDivideConfig%criticalModules /= l_none ) then
        if ( .not. got(f_scanLowerLimit) ) &
          & call AnnounceError ( root, notSpecified, f_scanLowerLimit )
        if ( .not. got (f_scanUpperLimit) ) &
          & call AnnounceError ( root, notSpecified, f_scanUpperLimit )
d1013 17
a1029 4
        if ( got(f_scanLowerLimit) ) &
          & call AnnounceError ( root, unnecessary, f_scanLowerLimit )
        if ( got (f_scanUpperLimit) ) &
          & call AnnounceError ( root, unnecessary, f_scanUpperLimit )
d1031 4
d1036 14
a1049 23
      ! Now check the units for various cases
      if ( got(f_maxgap) .and. all ( ChunkDivideConfig%maxGapFamily /= &
        & (/ PHYQ_MAFs, PHYQ_Angle, PHYQ_Time /))) &
        & call AnnounceError ( root, badUnits, f_maxGap )
      select case ( ChunkDivideConfig%method )
      case ( l_PE )
        if ( ChunkDivideConfig%maxLengthFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_maxLength )
      case ( l_orbital )
        if (all(ChunkDivideConfig%maxLengthFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
          & call AnnounceError ( root, badUnits, f_maxLength )
        if (all(ChunkDivideConfig%lowerOverlapFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
          & call AnnounceError ( root, badUnits, f_lowerOverlap )
        if (all(ChunkDivideConfig%upperOverlapFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
          & call AnnounceError ( root, badUnits, f_upperOverlap )
      case ( l_fixed, l_even )
        if ( ChunkDivideConfig%maxLengthFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_maxLength )
        if ( ChunkDivideConfig%lowerOverlapFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_lowerOverlap )
        if ( ChunkDivideConfig%upperOverlapFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_upperOverlap )
      end select
d1051 4
a1054 2
      if ( error /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Problem with ChunkDivide command' )
d1056 17
a1072 1
      ! That's it, we're all valid now.
d1074 4
a1077 1
    end subroutine ChunkDivideL2CF
d1079 8
a1086 9
    ! --------------------------------- ConvertFlagsToObstructions -----
    subroutine ConvertFlagsToObstructions ( valid, obstructions, &
      & mafRange, obstructionType )
      ! This routine takes an array of logicals indicating good/bad data
      ! and converts it into obstruction information.
      logical, dimension(:), intent(in)           :: VALID
      type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
      integer, dimension(:), intent(in), optional :: MAFRANGE
      character(len=*), intent(in), optional      :: obstructionType
d1088 14
a1101 6
      ! Local variables
      logical :: LASTONEVALID           ! Flag
      integer :: MAF                    ! Loop counter
      type (Obstruction_T) :: NEWOBSTRUCTION ! In progrss
      character(len=64)    :: obstructionTrigger
      integer :: OFFSET                 ! MAF index offset
d1103 9
a1111 9
      ! Executable code
      lastOneValid = .true.
      offset = 0
      if ( present(mafRange) ) offset = mafRange(1)
      obstructionTrigger = &
        & 'maf where transition from bad to good made obstruction'
      if ( present(obstructionType) ) obstructionTrigger = &
        & 'maf where transition from bad to good ' // trim(obstructionType) // &
        & 'made obstruction'
d1113 7
a1119 16
      do maf = 1, size(valid)
        if ( valid(maf) .neqv. lastOneValid ) then
          ! A transition either from good to bad or bad to good
          if ( .not. valid(maf) ) then
            ! From good to bad
            newObstruction%range = .true.
            newObstruction%mafs(1) = maf - 1 + offset
          else
            newObstruction%mafs(2) = maf - 2 + offset
            call AddObstructionToDatabase ( obstructions, newObstruction )
            if ( switchDetail(switches, 'chu') > -1 ) &
              call outputNamedValue( &
              & trim(obstructionTrigger), maf )
          end if
        end if
        lastOneValid = valid(maf)
d1121 25
d1147 37
a1183 9
      ! Make sure any range at the end gets added
      if ( .not. lastOneValid ) then
        newObstruction%mafs(2) = size(valid) - 1 + offset
        call AddObstructionToDatabase ( obstructions, newObstruction )
        if ( switchDetail(switches, 'chu') > -1 ) &
          call outputNamedValue( &
          & trim(obstructionTrigger), size(valid)-1 )
      end if
    end subroutine ConvertFlagsToObstructions
d1299 2
a1300 2
          ! For chunks where the wall is in the overlap, just make the 
          ! overlap shorter 
d1332 5
a1336 5
    ! ------------------------------------------------ DeleteChunk -----
    subroutine DeleteChunk ( chunks, index )
      ! Dummy arguments
      type (MLSChunk_T), pointer, dimension(:) :: CHUNKS
      integer, intent(in) :: INDEX
d1339 3
a1341 2
      type (MLSChunk_T), pointer, dimension(:) :: TEMP
      integer :: STATUS                   ! From allocate
d1344 9
a1352 15
      allocate ( temp ( size(chunks) - 1 ), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'temp' )

      if ( index > 1 ) temp(1:index-1) = chunks(1:index-1)
      if ( index < size(chunks) .and. size(chunks) > 1 ) &
        & temp(index:) = chunks(index+1:)

      deallocate ( chunks, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'chunks' )

      chunks => temp

    end subroutine DeleteChunk
d1381 66
d1512 1
a1512 1
      ! Searching for 
d1516 1
a1516 1
      
d1520 1
a1520 1
      
d1578 1
a1578 1
      ! changes from nogood to good after a dead zone 
d1607 1
a1607 1
      
d1636 1
a1636 1
        ! 
d1712 1
a1712 1
      
d1741 146
a1886 20
    ! ----------------------------------------- ChooseCriticalSignals -----------
    subroutine ChooseCriticalSignals ( criticalSignals )
      use MLSSignals_m, only: GetSignalName, SIGNALS
      use MLSStringLists, only: catLists, List2Array
      use MLSStrings, only: lowercase
      use String_table, only: GET_STRING
      ! Args
      character(len=160), dimension(:), pointer :: criticalSignals
      ! Internal variables
      character(len=40) :: critical_module_str
      integer, parameter :: MAXCRITICALSIGNALLENGTH = 40000
      character(len=MAXCRITICALSIGNALLENGTH) :: criticalSignalStr
      character(len=40) :: module_str
      integer :: numCriticalSignals
      character(len=40) :: signal_full
      integer :: signalIndex
      ! Executable
      if ( ChunkDivideConfig%criticalModules == l_none .and. &
        & len_trim(ChunkDivideConfig%criticalBands) < 1 ) return
      critical_module_str = ' '
d1888 10
a1897 22
        call get_string( lit_indices(ChunkDivideConfig%criticalModules), signal_full, &
          & strip=.true. )
        critical_module_str = lowercase(signal_full)
        if ( critical_module_str /= 'ghz' ) return
      endif
      criticalSignalStr = ' '
      numCriticalSignals = 0
      if ( switchDetail(switches, 'chu') > -1 ) &
        & call outputNamedValue( 'critical module', critical_module_str )
      if ( switchDetail(switches, 'chu') > -1 ) &
        & call outputNamedValue( 'critical bands', ChunkDivideConfig%criticalBands )
      do signalIndex=1, size(signals)
        if ( switchDetail(switches, 'chu') > -1 ) then
          call outputNamedValue( 'signal index', signalIndex )
          call GetSignalName( signalIndex, signal_full )
          call outputNamedValue( 'signal', signal_full )
          call outputNamedValue( 'band', signals(signalIndex)%Band )
          call outputNamedValue( 'critical?', &
            & .not. isNotACriticalBand( signals(signalIndex)%Band ) )
          call get_string( modules(signals(signalIndex)%instrumentModule)%name, module_str, &
            & strip=.true. )
          call outputNamedValue( 'module', module_str )
d1899 75
a1973 21
        if ( len_trim(ChunkDivideConfig%criticalBands) > 0 ) then
          ! See if the band is one of the critical bands
          if ( isNotACriticalBand( signals(signalIndex)%Band ) ) cycle
        elseif ( len_trim(critical_module_str) > 0 ) then
          call get_string( modules(signals(signalIndex)%instrumentModule)%name, signal_full, &
            & strip=.true. )
          module_str = lowercase(signal_full)
          if ( module_str /= critical_module_str ) cycle
        endif
        numCriticalSignals = numCriticalSignals + 1
        call GetSignalName( signalIndex, signal_full )
        criticalSignalStr = catLists( criticalSignalStr, signal_full )
      enddo
      if ( numCriticalSignals < 1 ) return
      call allocate_test( criticalSignals, numCriticalSignals, 'criticalSignals', &
        & ModuleName )
      call List2Array (criticalSignalStr, criticalSignals,  countEmpty=.true. )
      if ( switchDetail(switches, 'chu') > -1 ) &
        & call dump( criticalSignals, 'critical Signals chosen', &
        & options=what_options(trim=.true.) )
    end subroutine ChooseCriticalSignals
d1975 1
a1975 17
    ! ----------------------------------------- PruneChunks -----------
    subroutine PruneChunks ( chunks )
      type (MLSChunk_T), dimension(:), pointer :: CHUNKS
      integer :: CHUNK
      ! Now delete chunks that either:
      !  1 - Are nothing but overlap
      !  2 - Have <=0 MAFs
      pruneChunksLoop: do
        chunk = FindFirst ( &
          & ( chunks%noMAFsLowerOverlap + chunks%noMAFsUpperOverlap ) >= &
          & ( chunks%lastMAFIndex - chunks%firstMAFIndex + 1 ) &
          & .or.&
          & ( chunks%firstMAFIndex > chunks%lastMAFIndex ) )
        if ( chunk == 0 ) exit pruneChunksLoop
        call DeleteChunk ( chunks, chunk )
      end do pruneChunksLoop
    end subroutine PruneChunks
d2054 1
a2054 1
        end do middleLoop 
d2060 4
a2063 111
    ! ---------------------------------------------------- SayTime -----
    subroutine SayTime
      real :: T2
      call time_now ( t2 )
      if ( total_times ) then
        call output ( "Total time = " )
        call output ( dble(t2), advance = 'no' )
        call blanks ( 4, advance = 'no' )
      endif
      call output ( 'Timing for ChunkDivide = ' )
      call output ( dble(t2-t1), advance='yes' )
      timing = .false.
    end subroutine SayTime

    ! ---------------------------------------------------- CheckChunkSanity -----
    subroutine CheckChunkSanity ( chunks, mafRange )
      type (MLSChunk_T), dimension(:), intent(inout) :: CHUNKS
      integer, dimension(2), intent(in) :: MAFRANGE   ! Processing range in MAFs

      ! Local variables
      integer :: i
      logical :: sharing, outrange, negovlps

      ! Executable statements
      sharing = .false.
      outrange = .false.
      negovlps = .false.
      if ( CHECKFORSHAREDMAFS ) then
        do i = 1, size(chunks) - 1
          sharing = (chunks(i)%lastMAFIndex - chunks(i)%noMAFsUpperOverlap) >= &
            & chunks(i+1)%firstMAFIndex + chunks(i+1)%noMAFsLowerOverlap
          if ( sharing ) exit
        enddo
      endif
      outrange = any(chunks%firstMAFIndex < mafrange(1)) .or. &
        &        any(chunks%lastMAFIndex > mafrange(2))
      negovlps = any(chunks%noMAFsLowerOverlap < 0) .or. &
        &        any(chunks%noMAFsUpperOverlap < 0)
      if ( sharing ) then
        call output ( "Shared non-overlaps MAFs detected ", advance='yes' )
        call output ( "(Either tweak ChunkDivide section or get someone " )
        call output ( " to fix the code) ", advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Shared non-overlapped MAFs' )
      elseif ( outrange ) then
        call output ( " MAFs detected outside range: " )
        call output ( mafRange, advance='yes' )
        call output ( "(Either tweak ChunkDivide section or get someone " )
        call output ( " to fix the code) ", advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'MAFs outside range' )
      elseif ( negovlps ) then
        call output ( "Negative overlaps detected ", advance='yes' )
        call output ( "(Either tweak ChunkDivide section or get someone " )
        call output ( " to fix the code) ", advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Negative overlaps' )
      endif
    end subroutine CheckChunkSanity

    ! ------------------------------------------------- SortChunks -----
    subroutine SortChunks ( chunks )
      ! Sort the chunks into order of increasing firstMAFIndex
      type (MLSChunk_T), dimension(:), intent(inout) :: CHUNKS

      ! Local variables
      type (MLSChunk_T) :: TEMP
      integer :: I                        ! Loop counters
      integer, dimension(1) :: TOSWAP     ! Index

      ! Executable code
      do i = 1, size(chunks) - 1
        toSwap = minloc ( chunks(i:)%firstMAFIndex + &
          & chunks(i:)%noMAFsLowerOverlap ) + (/ i-1 /)
        if ( toSwap(1) /= i ) then
          temp = chunks(i)
          chunks(i) = chunks(toSwap(1))
          chunks(toSwap(1)) = temp
        end if
      end do
    end subroutine SortChunks

    ! ------------------------------------------- SortObstructions -----
    subroutine SortObstructions ( obstructions )
      ! Sort the obstructions into order of increasing
      ! mafs(1) (start/wall MAF index)
      type (Obstruction_T), dimension(:), intent(inout) :: OBSTRUCTIONS

      ! Local variables
      type (Obstruction_T) :: TEMP
      integer :: I                        ! Loop counters
      integer, dimension(1) :: TOSWAP     ! Index

      ! Executable code
      do i = 1, size(obstructions) - 1
        toSwap = minloc ( obstructions(i:)%mafs(1) ) + (/ i-1 /)
        if ( toSwap(1) /= i ) then
          temp = obstructions(i)
          obstructions(i) = obstructions(toSwap(1))
          obstructions(toSwap(1)) = temp
        end if
      end do
    end subroutine SortObstructions

    ! ---------------------------------------------- SurveyL1BData -----
    subroutine SurveyL1BData ( processingRange, filedatabase, mafRange )
      ! This goes through the L1B data files and tries to spot possible
      ! obstructions.
      use MLSL2Options, only: SharedPCF
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error
      type (TAI93_Range_T), intent(in) :: PROCESSINGRANGE
d2065 1
a2065 1
      type (MAFRange_T), intent(out) :: MAFRange
d2067 3
d2071 4
a2074 4
      type (L1BData_T) :: TAITIME         ! Read from L1BOA file
      type (L1BData_T) :: TPGEODALT       ! Read from L1BOA file
      type (L1BData_T) :: TPGEODANGLE     ! Read from L1BOA file
      type (L1BData_T) :: TPORBY          ! Read from L1BOA file
d2076 14
a2089 1
      character(len=10) :: MODNAMESTR     ! Module name
d2091 2
a2092 5
      integer :: FLAG                     ! From L1B
      integer :: MAF                      ! Loop inductor
      integer :: MOD                      ! Loop inductor
      integer :: NOMAFS                   ! Number of MAFs in processing range
      integer :: NOMAFSREAD               ! From L1B
d2094 9
a2102 4
      logical :: THISONEVALID             ! To go into valid
      logical, dimension(:), pointer :: VALID ! Flag for each MAF
      logical, dimension(:), pointer :: WASSMOOTHED ! Flag for each MAF
      logical, dimension(:), pointer :: ANGLEWASSMOOTHED ! Flag for each MAF
d2104 2
a2105 3
      real(r8) :: SCANMAX                 ! Range of scan each maf
      real(r8) :: SCANMIN                 ! Range of scan each maf
      real(r8) :: ORBYMAX                 ! Maximum value of orbY each maf
d2108 1
a2108 1
      character(len=NAME_LEN) ::         MAF_start, tp_alt, tp_orbY, tp_angle
d2110 1
d2112 6
a2117 1

d2121 1
a2121 1
          & "Can't make progress in SurveyL1BData without L1BOA files" )
d2124 224
a2347 13
      MAF_start = AssembleL1BQtyName ( 'MAFStartTimeTAI', l1b_hdf_version, &
        .false. )
      ! tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', l1b_hdf_version, &
      !  .false. )
      ! Read time from the L1BOA file
      call ReadL1BData ( L1BFile, trim(MAF_start), taiTime, &
        & noMAFsRead, flag, &
        & dontPad=DONTPAD )
      call smoothOutDroppedMAFs(taiTime%dpField)
      
      ! We shall assume that all l1b files cover this range
      mafRange%L1BCover(1) = taiTime%FirstMAF
      mafRange%L1BCover(2) = taiTime%NoMAFs - 1 ! Because it starts with 0
d2349 4
a2352 4
      ! Deduce the first and last MAFs covered the L2 Processing Range
      call Hunt ( taiTime%dpField(1,1,:), &
        & (/ processingRange%startTime, processingRange%endTime /), &
        & mafRange%L2Cover, allowTopValue=.true., allowBelowValue=.true. )
d2354 5
a2358 13
      ! Check the validity of the MAF range returned
      if ( mafRange%L2Cover(2) == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L1B data starts after requested processing range' )
      if ( mafRange%L2Cover(1) == taiTime%noMAFs ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L1B data ends before requested processing range' )
      mafRange%L2Cover = min ( noMAFsRead-1, max ( 0, mafRange%L2Cover - 1 ) )          ! Index from zero
      if ( mafRange%L2Cover(2) < mafRange%L2Cover(1) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L2 mafRange(2) < L2 mafRange(1)' )
      elseif ( mafRange%L2Cover(2) < 1 ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'L2 mafRange(2) < 1' )
      endif
d2360 3
a2362 61
      mafRange%Expanded(1) = mafRange%L2Cover(1)
      mafRange%Expanded(2) = mafRange%L2Cover(2)
      ! Expand the range covered by L2 with possible overlaps
      if ( ChunkDivideConfig%allowPriorOverlaps ) then
        mafRange%Expanded(1) = max( mafRange%L1BCover(1), &
          & mafRange%L2Cover(1) - nint(ChunkDivideConfig%lowerOverlap) )
      endif
      if ( ChunkDivideConfig%allowPostOverlaps ) then
        mafRange%Expanded(2) = min( mafRange%L1BCover(2), &
          & mafRange%L2Cover(2) + nint(ChunkDivideConfig%upperOverlap) )
      endif
      if ( sharedPCF ) return
      noMAFS = mafRange%Expanded(2) - mafRange%Expanded(1) + 1
      ! Now look through the L1B data, first look for scan problems
      if ( ChunkDivideConfig%criticalModules /= l_none ) then
        nullify ( valid )
        nullify ( anglewasSmoothed )
        nullify ( wasSmoothed )
        call Allocate_test ( valid, noMAFs, 'valid', ModuleName )
        call Allocate_test ( anglewasSmoothed, noMAFs, 'angleWasSmoothed', ModuleName )
        call Allocate_test ( wasSmoothed, noMAFs, 'wasSmoothed', ModuleName )
        if ( ChunkDivideConfig%criticalModules == l_both ) then
          valid = .true.
        else
          valid = .false.
        endif
        do mod = 1, size(modules)
          call get_string ( modules(mod)%name, modNameStr, strip=.true. )
          tp_alt = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAlt', &
            & l1b_hdf_version, .false. )
          tp_orby = AssembleL1BQtyName ( trim(modNameStr)//'.tpOrbY', &
            & l1b_hdf_version, .false. )
          tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', &
            & l1b_hdf_version, .false. )
          if ( .not. modules(mod)%spacecraft .and. &
            & ( any ( ChunkDivideConfig%criticalModules == (/ l_either, l_both /) ) .or. &
            &   lit_indices(ChunkDivideConfig%criticalModules) == modules(mod)%name ) ) then
            ! Read the tangent point altitude
            call ReadL1BData ( L1BFile, trim(tp_alt), &
              & tpGeodAlt, noMAFsRead, flag, &
              & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
              & dontPad=DONTPAD )
            ! Read the out of plane distance
            call ReadL1BData ( L1BFile, trim(tp_orby), &
              & tpOrbY, noMAFsRead, flag, &
              & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
              & dontPad=DONTPAD )
            call ReadL1BData ( L1BFile, trim(tp_angle), &
              & tpGeodAngle, noMAFsRead, flag, &
              & firstMAF=mafRange%Expanded(1), lastMAF=mafRange%Expanded(2), &
              & dontPad=DONTPAD )
            call smoothOutDroppedMAFs(tpGeodAngle%dpField, angleWasSmoothed, &
              & monotonize=.true.)
            call smoothOutDroppedMAFs(tpGeodAlt%dpField, wasSmoothed)
            call smoothOutDroppedMAFs(tpOrbY%dpField)
            wasSmoothed = (wasSmoothed .or. angleWasSmoothed)
            ! Consider the scan range in each MAF in turn
            do maf = 1, noMAFs
              scanMax = maxval ( tpGeodAlt%dpField(1,:,maf) )
              scanMin = minval ( tpGeodAlt%dpField(1,:,maf) )
              orbyMax = maxval ( tpOrbY%dpField(1,:,maf) )
d2364 5
a2368 29
              thisOneValid = ( scanMin >= ChunkDivideConfig%scanLowerLimit(1) .and. &
                &              scanMin <= ChunkDivideConfig%scanLowerLimit(2) ) .and. &
                &            ( scanMax >= ChunkDivideConfig%scanUpperLimit(1) .and. &
                &              scanMax <= ChunkDivideConfig%scanUpperLimit(2) )
              if ( ChunkDivideConfig%maxOrbY > 0.0 ) then
                thisOneValid = thisOneValid .and. orbYMax < ChunkDivideConfig%maxOrbY
              end if
              ! this one is not valid if it's valid only by virtue
              ! of having been smoothed
              thisOneValid = thisOneValid .and. .not. wasSmoothed(maf)
              if ( ChunkDivideConfig%criticalModules == l_both ) then
                valid(maf) = valid(maf) .and. thisOneValid
              else
                valid(maf) = valid(maf) .or. thisOneValid
              end if
            end do                        ! Maf loop
            call DeallocateL1BData ( taiTime )
            call DeallocateL1BData ( tpgeodalt )
            call DeallocateL1BData ( tpgeodangle )
            call DeallocateL1BData ( tporby )
          end if                          ! Consider this module
        end do                            ! Module Loop
        ! Convert this information into obstructions and tidy up.
        call ConvertFlagsToObstructions ( valid, obstructions, &
          & obstructionType='scan' )
        call Deallocate_test ( valid, 'valid', ModuleName )
        call Deallocate_test ( wasSmoothed, 'wasSmoothed', ModuleName )
        call Deallocate_test ( angleWasSmoothed, 'angleWasSmoothed', ModuleName )
      end if                              ! Consider scan issues
d2370 8
a2377 3
      ! Here we look at radiances and switch changes.
      if ( .not. ChunkDivideConfig%skipL1BCheck) &
        call NoteL1BRADChanges ( obstructions, mafRange, filedatabase ) 
d2379 5
a2383 2
      ! Sort the obstructions into order; prune them of repeats, overlaps etc.
      call PruneObstructions ( obstructions ) 
d2385 29
a2413 2
      ! Tidy up
      call DeallocateL1BData ( taiTime )
d2415 2
a2416 2
    end subroutine SurveyL1BData
  end subroutine ChunkDivide
d2418 4
a2421 2
  ! -------------------------------------------- Dump_config -----
  subroutine Dump_config(config)
d2423 3
a2425 3
    use Intrinsic, only: LIT_INDICES, phyq_indices
    use Output_M, only: OUTPUT
    use String_table, only: DISPLAY_STRING
d2427 2
a2428 2
    ! Args
    type(ChunkDivideConfig_T), intent(in) :: Config
d2430 4
a2433 71
    ! Executable code
    call output ( 'method ' )
    call display_string ( lit_indices(Config%method), &
      &             strip=.true., advance='yes' )
    call output ( 'max Length ' )
    call output ( config%maxLength, advance='yes' )
    call output ( 'max Length Family ' )
    call display_string ( phyq_indices(Config%maxLengthFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'num chunks ' )
    call output ( config%noChunks, advance='yes' )
    call output ( 'overlap ' )
    call output ( config%overlap, advance='yes' )
    call output ( 'overlap Family ' )
    call display_string ( phyq_indices(Config%overlapFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'lower overlap ' )
    call output ( config%loweroverlap, advance='yes' )
    call output ( 'lower overlap Family ' )
    call display_string ( phyq_indices(Config%loweroverlapFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'upper overlap ' )
    call output ( config%upperoverlap, advance='yes' )
    call output ( 'upper overlap Family ' )
    call display_string ( phyq_indices(Config%upperoverlapFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'num slaves ' )
    call output ( config%noSlaves, advance='yes' )
    call output ( 'home module ' )
    call display_string ( lit_indices(Config%homeModule), &
      &             strip=.true., advance='yes' )
    call output ( 'home Geod Angle ' )
    call output ( config%homeGeodAngle, advance='yes' )
    call output ( 'set scan lower limit? ' )
    call output ( config%scanLLSet, advance='yes' )
    if ( config%scanLLSet ) then
    call output ( 'Bottom scan range ' )
    call output ( config%scanLowerLimit, advance='yes' )
    endif
    call output ( 'set scan upper limit? ' )
    call output ( config%scanULSet, advance='yes' )
    if ( config%scanULSet ) then
    call output ( 'Top scan range ' )
    call output ( config%scanUpperLimit, advance='yes' )
    endif
    call output ( 'max out-of-plane distance ' )
    call output ( config%maxOrbY, advance='yes' )
    call output ( 'critical modules ' )
    call display_string ( lit_indices(Config%criticalModules), &
      &             strip=.true., advance='yes' )
    call output ( 'critical bands ' )
    call output ( trim(config%criticalBands), advance='yes' )
    call output ( 'use critical modules to choose critical signals?' )
    call output ( config%chooseCriticalSignals, advance='yes' )
    call output ( 'max gap ' )
    call output ( config%maxGap, advance='yes' )
    call output ( 'max Gap Family ' )
    call display_string ( phyq_indices(Config%maxGapFamily), &
      &             strip=.true., advance='yes' )
    call output ( 'skip check of l1b files ' )
    call output ( config%skipL1BCheck, advance='yes' )
    call output ( 'allow overlaps to prior day?' )
    call output ( config%allowPriorOverlaps, advance='yes' )
    call output ( 'allow overlaps to next day?' )
    call output ( config%allowPostOverlaps, advance='yes' )
    call output ( 'save obstructions?' )
    call output ( config%saveObstructions, advance='yes' )
    call output ( 'DACS already deconvolved?' )
    call output ( config%DACSDeconvolved, advance='yes' )
    call Dump_criticalSignals(config%criticalSignals)
  end subroutine Dump_config
d2435 5
a2439 2
  ! -------------------------------------------- Dump_criticalSignals -----
  subroutine Dump_criticalSignals(criticalSignals)
d2441 5
a2445 1
    use Output_M, only: OUTPUT
d2447 4
a2450 17
    character(len=160), dimension(:), pointer &
      & :: criticalSignals       ! Which signals must be on
    ! Local variables
    integer :: i                        ! Loop counter
    ! Executable code
    if ( associated ( criticalSignals ) ) then
      if ( size(criticalSignals) == 0 ) then
        call output ( 'criticalSignals is a zero size array.', advance='yes' )
      else
        call output ( 'Dumping ' )
        call output ( size(criticalSignals) )
        call output ( ' criticalSignals:', advance='yes' )
        do i = 1, size(criticalSignals)
          call output ( i )
          call output ( ': ' )
          call output ( trim(criticalSignals(i)), advance='yes' )
        end do
a2451 4
    else
      call output ( 'critical Signals is not associated.', advance='yes')
    end if
  end subroutine Dump_criticalSignals
d2453 15
a2467 2
  ! -------------------------------------------- Dump Obstructions -----
  subroutine Dump_Obstructions ( obstructions ) 
d2469 11
a2479 1
    use Output_M, only: OUTPUT
d2481 51
a2531 30
    type (Obstruction_T), dimension(:), pointer :: obstructions
    ! Local variables
    integer :: i                        ! Loop counter
    ! Executable code
    if ( associated ( obstructions ) ) then
      if ( size(obstructions) == 0 ) then
        call output ( 'Obstructions is a zero size array.', advance='yes' )
      else
        call output ( 'Dumping ' )
        call output ( size(obstructions) )
        call output ( ' obstructions:', advance='yes' )
        do i = 1, size(obstructions)
          call output ( i )
          if ( obstructions(i)%range ) then
            call output ( ' : Range [ ' )
            call output ( obstructions(i)%mafs(1) )
            call output ( ' : ' )
            call output ( obstructions(i)%mafs(2) )
            call output ( ' ]', advance='yes' )
          else
            call output ( ' : Wall [ ' )
            call output ( obstructions(i)%mafs(1) )
            call output ( ' ]', advance='yes' )
          end if
        end do
      end if
    else
      call output ( 'Obstructions is not associated.', advance='yes')
    end if
  end subroutine Dump_Obstructions
d2533 2
a2534 14
! -----------------------------------------------  ANY_GOOD_SIGNALDATA  -----
  function ANY_GOOD_SIGNALDATA ( signal, sideband, filedatabase, maf, maf2, &
    & good_buffer, mafRange )  &
    & result (answer)
  ! Scalar use:
  ! Read precision of signal
  ! if all values < 0.0, return FALSE
  ! if no precision data in file, return FALSE
  ! otherwise return true
  !
  ! Array use
  ! Return one logical value in good_buffer
  ! for each of the_mafs between maf and maf2
  ! Arguments
d2536 1
a2536 6
    use L1BData, only: L1BData_T, READL1BDATA, GetL1bFile, &
      & AssembleL1BQtyName, PRECISIONSUFFIX, DEALLOCATEL1BDATA
    use MLSCommon, only: MLSFile_T, RK => R8
    use MLSFiles, only: GetMLSFileByType
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only: GetSignalName
d2538 1
a2538 17
    integer, intent(in)                            :: signal
    integer, intent(in)                            :: sideband
    logical                                        :: answer
    integer, intent(in)                            :: maf
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    integer, optional, intent(in)                  :: maf2
    logical, dimension(:), optional, intent(inout) :: good_buffer
    integer, dimension(2), optional, intent(in)    :: MAFRANGE   ! Processing 
    ! Private                                                   range in MAFs
    integer :: flag
    type(MLSFile_T), pointer :: L1BFile
    integer :: maf_index   ! 1 <= maf_index <= mafrange(2)-mafrange(1)+1
    type (l1bData_T) :: MY_L1BDATA
    integer :: mymaf2
    character(len=127)  :: namestring
    integer :: noMAFs
    integer :: the_maf
d2540 2
a2541 4
    ! Executable
    answer = .false.
    mymaf2 = maf
    if ( present(maf2) ) mymaf2 = maf2
d2543 3
a2545 8
    ! Set defaults for the good_buffer if present
    if ( present(good_buffer) ) then
      if ( .not. present(mafrange) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'mafRange must be supplied to any_good_signaldata' )
      endif
      good_buffer ( maf - mafRange(1) + 1 : myMAF2 - mafRange(1) + 1 ) = .false.
    end if
d2547 2
a2548 14
    ! OK, try to find this item in an l1brad file
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) return
    call GetSignalName ( signal, nameString, &                   
      & sideband=sideband, noChannels=.TRUE. )                     
    nameString = AssembleL1BQtyName ( nameString, L1BFile%hdfVersion, .false. )
    nameString = trim(nameString) // PRECISIONSUFFIX
    ! fileID = FindL1BData (filedatabase, nameString, hdfVersion )
    L1BFile => GetL1bFile(filedatabase, namestring)
    ! If not found, exit appropriately
    if ( .not. associated(L1BFile) ) then
      answer = .false.
      return
    end if
d2550 1
a2550 9
    ! OK, we've found it.  Read the data in.
    call ReadL1BData ( L1BFile, nameString, my_l1bData, noMAFs, flag, &
      & firstMAF=maf, lastMAF=mymaf2, &
      & NeverFail= .true., dontPad = .false. )
    ! Quit if the reading failed.
    if ( flag /= 0 ) then
      answer = .false.
      return
    end if
d2552 1
a2552 12
    ! Give detailed or curt response
    if ( present(good_buffer) ) then
      answer = .true.    ! This value should be ignored by the caller
      do the_maf = maf, mymaf2
        maf_index = the_maf - mafRange(1) + 1
        good_buffer(maf_index) = .not. &
          & all (my_l1bData%DpField(:,:, the_maf+1-maf) < 0.0_rk)
      end do
    else
      answer = .not. all (my_l1bData%DpField < 0._rk)
    end if
    call DeallocateL1bData ( my_l1bData )
d2554 2
a2555 1
  end function ANY_GOOD_SIGNALDATA
d2557 18
a2574 18
  logical function isNotACriticalBand( band )
    use MLSStringLists, only: NumStringElements, StringElement
    use MLSStrings, only: readIntsFromChars
    ! Args
    integer, intent(in) :: band
    ! Internal variables
    logical, parameter :: countEmpty = .true.
    integer :: i
    integer :: n
    ! Executable
    isNotACriticalBand = .true.
    do i=1, NumStringElements( trim(ChunkDivideConfig%criticalBands), countEmpty )
      call readIntsFromChars( trim(&
        & StringElement( ChunkDivideConfig%criticalBands, i, countEmpty ) &
        & ), n, ignore='*' )
      isNotACriticalBand = isNotACriticalBand .and. (band /= n)
    enddo
  end function isNotACriticalBand
d2576 3
a2578 23
  subroutine smoothOutDroppedMAFs(field, wasSmoothed, monotonize)
    ! detect any fillValues--replace them with nearest neighbor values
    ! or, optionally, detect and correct any departures from monotone growth
  use MLSFillValues, only: ISFILLVALUE
    ! Args
    real(r8), intent(inout)                      :: field(:,:,:)
    logical, dimension(:), optional, intent(out) :: wasSmoothed
    logical, optional, intent(in)                :: monotonize
    ! Internal variables
    integer :: maf, nearest
    logical :: myMonotonize
    real(r8):: lastValue
    ! Executable
    myMonotonize = .false.
    if ( present(monotonize) ) mymonotonize = monotonize
    if ( present(wasSmoothed) ) wasSmoothed = .false.
    lastValue = field(1,1,1)
    do maf=1, size(field, 3)
      if ( myMonotonize ) then
        nearest = max(maf-1, 1)
        if ( field(1,1,maf) < lastValue ) then
          if ( present(wasSmoothed) ) wasSmoothed(maf) = .true.
          field(:,:,maf) = field(:,:,nearest)
d2580 3
a2582 13
          lastValue = field(1,1,maf)
        endif
      elseif ( any( isFillValue(field(:,:,maf)) ) ) then
        if ( present(wasSmoothed) ) wasSmoothed(maf) = .true.
        if ( maf == 1 ) then
          nearest = findfirst(.not. isFillValue(field(1,1,:)) )
        else
          nearest = maf - 1
        endif
        field(:,:,maf) = field(:,:,nearest)
      endif
    enddo
  end subroutine smoothOutDroppedMAFs
d2605 1
a2605 1
       "$Id: read_apriori.f90 is it here $"
d2615 3
@


2.90
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d2571 1
a2572 1
  !---------------------------- RCS Ident Info -------------------------------
d2574 1
a2574 1
    "$Id: ChunkDivide_m.f90,v 2.89 2009/04/02 18:09:26 pwagner Exp $"
a2575 1
  !---------------------------------------------------------------------------
d2577 1
a2577 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d2579 1
d2584 3
@


2.89
log
@Fixed bug where status might be undefined
@
text
@d1254 2
a1255 1
    subroutine ConvertFlagsToObstructions ( valid, obstructions, mafRange )
d1258 1
a1258 1
      logical, dimension(:), intent(in) :: VALID
d1261 1
d1264 1
d1266 2
a1268 2
      logical :: LASTONEVALID           ! Flag
      type (Obstruction_T) :: NEWOBSTRUCTION ! In progrss
d1274 5
d1292 1
a1292 1
              & 'maf where transition from bad to good made obstruction', maf )
d1304 1
a1304 1
          & 'maf where transition from bad to good made obstruction', size(valid)-1 )
d1763 1
a1763 1
          & mafRange%Expanded )
d1865 2
a1866 1
        & call dump( criticalSignals, 'critical Signals chosen', trim=.true. )
d2236 2
a2237 1
        call ConvertFlagsToObstructions ( valid, obstructions )
d2553 18
d2574 1
a2574 1
    "$Id: ChunkDivide_m.f90,v 2.88 2009/04/01 23:34:26 pwagner Exp $"
d2584 3
@


2.88
log
@By default saves obstructions db to written to l2aux file
@
text
@d327 5
a331 4
      if ( .not. ChunkDivideConfig%saveObstructions ) &
        & deallocate ( obstructions, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'obstructions' )
d2546 1
a2546 1
    "$Id: ChunkDivide_m.f90,v 2.87 2008/07/12 00:12:07 pwagner Exp $"
d2556 3
@


2.87
log
@dump_criticalsignals not generic to appease sun studio 12
@
text
@d81 1
a81 1
    logical   :: saveObstructions = .false. ! Save obstructions for Output_Close
d1281 3
d1293 3
d1773 3
d1783 3
d2545 1
a2545 1
    "$Id: ChunkDivide_m.f90,v 2.86 2008/05/28 21:51:43 pwagner Exp $"
d2549 1
d2555 3
@


2.86
log
@May choose critical band(s)
@
text
@d120 1
a120 1
    module procedure DUMP_CRITICALSIGNALS
d2533 1
a2533 1
    "$Id: ChunkDivide_m.f90,v 2.85 2007/12/14 01:55:28 pwagner Exp $"
d2542 3
@


2.85
log
@Must delete obstructions observing proper order for indexing
@
text
@d71 1
d73 1
a73 1
    logical   :: chooseCriticalSignals = .true. ! Whether to use criticalModules
d184 2
a185 1
    use Init_Tables_Module, only: F_CRITICALMODULES, F_CRITICALSIGNALS, &
d651 4
a654 2
      if ( index ( switches, 'chu' ) /= 0 ) &
        & call output('Entering Orbital Chunk Divide', advance='yes')
d1117 5
d1799 9
a1807 5
      if ( ChunkDivideConfig%criticalModules == l_none ) return
      call get_string( lit_indices(ChunkDivideConfig%criticalModules), signal_full, &
        & strip=.true. )
      critical_module_str = lowercase(signal_full)
      if ( critical_module_str /= 'ghz' ) return
d1810 4
d1815 20
a1834 4
        call get_string( modules(signals(signalIndex)%instrumentModule)%name, signal_full, &
          & strip=.true. )
        module_str = lowercase(signal_full)
        if ( module_str /= critical_module_str ) cycle
d1844 1
a1844 1
        & call dump( criticalSignals, 'critical Signals', trim=.true. )
d2056 1
d2140 1
d2293 2
d2473 19
d2533 1
a2533 1
    "$Id: ChunkDivide_m.f90,v 2.84 2007/11/01 23:30:48 pwagner Exp $"
d2542 3
@


2.84
log
@Should permit us to make sids files, i.e. omit l1brad
@
text
@d1874 4
a1878 1
                call DeleteObstruction ( obstructions, j )
d2477 1
a2477 1
    "$Id: ChunkDivide_m.f90,v 2.83 2007/10/24 00:14:58 pwagner Exp $"
d2486 3
@


2.83
log
@Removed unused declarations
@
text
@d1542 1
a1542 1
      ! Won't check if there are no radiances
d1544 2
d2474 1
a2474 1
    "$Id: ChunkDivide_m.f90,v 2.82 2007/09/06 22:31:50 pwagner Exp $"
d2483 3
@


2.82
log
@Raise switch threshold for dumpings signals
@
text
@d1492 1
a1492 1
      use String_table, only: GET_STRING, DISPLAY_STRING
d1776 1
a1776 1
      use String_table, only: GET_STRING, DISPLAY_STRING
a2017 1
      use L1BData, only: DUMP
d2196 3
a2198 4
    use Intrinsic, only: LIT_INDICES, phyq_indices, &
      & PHYQ_MAFS, PHYQ_ANGLE, PHYQ_TIME, PHYQ_INVALID
    use Output_M, only: BLANKS, OUTPUT
    use String_table, only: GET_STRING, DISPLAY_STRING
a2202 2
    ! Local variables
    integer :: i                        ! Loop counter
d2472 1
a2472 1
    "$Id: ChunkDivide_m.f90,v 2.81 2007/06/08 22:00:23 vsnyder Exp $"
d2481 3
@


2.81
log
@Quit gracefully if no L1BOA files
@
text
@d1541 1
d1576 1
a1576 1
        if ( swLevel > -1 ) call dump( signals(signalIndex) )
d1580 1
a1580 1
        if ( swLevel > -1 ) call outputNamedValue( 'critical module', critical_module_str )
d1584 1
a1584 1
        if ( swLevel > -1 ) call outputNamedValue( 'module', module_str )
d1608 1
a1608 1
      if ( swlevel > 0 ) call dump ( signals_buffer, 'signals_buffer' )
d1674 1
a1674 1
        if ( SwLevel > -1 ) then
d1695 1
a1695 1
            if ( SwLevel > -1 ) then
d1730 1
a1730 1
        if ( swLevel > 0 ) call dump ( valids_buffer, 'valids_buffer' )
d2476 1
a2476 1
    "$Id: ChunkDivide_m.f90,v 2.80 2007/03/23 00:16:57 pwagner Exp $"
d2485 3
@


2.80
log
@Prevent crashing while printing extra-long signals names
@
text
@d507 3
d654 3
d2016 1
d2018 1
a2018 1
      ! obstructions.
d2052 3
d2475 1
a2475 1
    "$Id: ChunkDivide_m.f90,v 2.79 2007/02/09 01:10:00 pwagner Exp $"
d2484 3
@


2.79
log
@Fixed bug where criticalSignals not nullified
@
text
@d1801 2
a1802 1
      if ( switchDetail(switches, 'chu') > -1 ) call dump( criticalSignals, 'critical Signals' )
d2465 1
a2465 1
    "$Id: ChunkDivide_m.f90,v 2.78 2007/02/06 23:13:40 pwagner Exp $"
d2474 3
@


2.78
log
@Now can chooseCriticalSignals based on criticalModule
@
text
@d1506 1
a1506 1
      character(len=160), dimension(:), pointer :: criticalSignals ! taken from config or criticalModules
d2464 1
a2464 1
    "$Id: ChunkDivide_m.f90,v 2.77 2007/01/25 19:04:59 pwagner Exp $"
d2473 3
@


2.77
log
@Warns if DACsDeconvolved attribute not found
@
text
@d72 1
d209 2
a210 1
    use Output_M, only: BLANKS, OUTPUT, revertoutput, switchOutput
d259 1
a259 1
      if ( index(switches, 'chu') /= 0 ) then
d324 1
a324 1
      if ( index(switches, 'chu') /= 0 ) call Dump_Obstructions ( obstructions )
d331 1
a331 1
      if ( index(switches, 'chu') /= 0 ) &
d355 1
a355 1
    if ( index(switches, 'chu') /= 0 ) call dump ( chunks )
d709 1
a709 1
      if ( index(switches, 'chu') /= 0 ) then    
d750 1
a750 1
      if ( index(switches, 'chu') /= 0 ) then    
d858 1
a858 1
        if ( index(switches, 'chu') /= 0 ) then
d908 1
a908 1
      if ( index(switches, 'chu') /= 0 ) then                      
d934 1
a934 1
      if ( index(switches, 'chu') /= 0 ) then
d975 1
a975 1
      if ( index(switches, 'chu') /= 0 ) then
d1481 1
a1481 1
      use MLSSignals_m, only: GetSignalName, &
d1484 1
d1486 1
d1503 1
d1505 2
d1521 1
d1532 1
d1537 1
d1539 1
d1559 9
d1569 14
d1601 1
a1601 1
      ! call dump ( signals_buffer, 'signals_buffer' )
d1639 18
a1656 2
      ! if (config%criticalSignals /= '' ) then
      if ( associated(ChunkDivideConfig%criticalSignals) ) then
d1665 3
a1667 2
        valids_buffer = .true.
        if ( index(switches, 'chu') /= 0 ) then
d1669 2
a1670 2
          do critical_index=1, size(ChunkDivideConfig%criticalSignals)
            call output ( trim(ChunkDivideConfig%criticalSignals(critical_index)), &
d1677 1
a1677 13
        ! What we're about to do is:
        ! Assume we're given an array of char strings
        ! array = [str_1, str_2, ..]
        ! and each string contains comma-separated signals
        ! str_1 = 'sig_1,sig_2,..'
        ! Then the rule is that for a maf to pass the critical signals test,
        ! for each array element at least one of the signals within that
        ! string must be turned on for that maf
        ! Thus the shorthand formula that we're and-ing the array elements
        ! and or-ing the list elements
        ! You might prefer the formula that a maf is invalid if for any of the
        ! array elements, none of its signals is turned on
        do critical_index=1, size(ChunkDivideConfig%criticalSignals)
d1680 1
a1680 1
            & trim(ChunkDivideConfig%criticalSignals(critical_index)), .FALSE.)
d1682 1
a1682 1
              & trim(ChunkDivideConfig%criticalSignals(critical_index)), signal_str, &
d1688 1
a1688 1
            if ( index(switches, 'chu') /= 0 ) then
d1710 12
a1721 2
          valids_buffer = &
            & valids_buffer .and. or_valids_buffer
d1723 6
d1731 4
d1737 3
d1764 40
d2245 2
d2464 1
a2464 1
    "$Id: ChunkDivide_m.f90,v 2.76 2006/06/20 00:12:30 pwagner Exp $"
d2473 3
@


2.76
log
@Improved two printed formats
@
text
@d308 2
d2360 1
a2360 1
    "$Id: ChunkDivide_m.f90,v 2.75 2006/05/09 23:41:41 pwagner Exp $"
d2369 3
@


2.75
log
@Warn if not assured DACS deconvolution performed by level 1
@
text
@d266 1
a266 1
        call output ( 'MAF range in L1B files' )          
d270 1
a270 1
        call output ( 'including overlapped days' )          
d2358 1
a2358 1
    "$Id: ChunkDivide_m.f90,v 2.74 2006/04/20 23:22:54 pwagner Exp $"
d2367 3
@


2.74
log
@Show both kinds of allowed extra-range overlaps
@
text
@d307 2
d311 5
d2358 1
a2358 1
    "$Id: ChunkDivide_m.f90,v 2.73 2006/04/10 23:45:18 pwagner Exp $"
d2367 3
@


2.73
log
@Reset defaults in read_apriori, not ChunkDivide
@
text
@d310 2
a311 1
    if ( switchDetail(switches, 'chu') > -1 ) call dump(ChunkDivideConfig)
d2351 1
a2351 1
    "$Id: ChunkDivide_m.f90,v 2.72 2006/04/03 20:26:08 pwagner Exp $"
d2360 3
@


2.72
log
@More verbose notice when using l2gp a priori exclude outside overlaps
@
text
@d81 2
a248 16
    ! Do we have any l2gp files in our database that we may have to fill from?
    ! (If so, we will change default behavior so that we won't allow
    ! overlaps outside the processing range)
    if ( associated(filedatabase) ) then
      if ( size(filedatabase) > 0 ) then
        if ( any(filedatabase%content == 'l2gp') ) then
          call output( 'count(filedatabase%content == l2gp)', advance='no' )
          call output( count(filedatabase%content == 'l2gp'), advance='yes' )
          call output( '(Resetting defaults to exclude overlaps outside '&
            & // 'processingRange', advance='yes' )
          ChunkDivideConfig%allowPriorOverlaps = .false.
          ChunkDivideConfig%allowPostOverlaps = .false.
        endif
      endif
    endif

d1897 1
d2350 1
a2350 1
    "$Id: ChunkDivide_m.f90,v 2.71 2006/03/17 21:57:43 pwagner Exp $"
d2359 3
@


2.71
log
@Adjust default behavior to exclude overlaps outside processing if sids run
@
text
@d253 4
d2363 1
a2363 1
    "$Id: ChunkDivide_m.f90,v 2.70 2006/03/17 00:06:31 pwagner Exp $"
d2372 3
@


2.70
log
@Change default to allowing overlaps outside processingRange
@
text
@d247 12
d2359 1
a2359 1
    "$Id: ChunkDivide_m.f90,v 2.69 2006/02/10 21:19:24 pwagner Exp $"
d2368 3
@


2.69
log
@dumps may go to special dumpfile
@
text
@d27 1
a27 1

d33 3
d40 2
a41 1
  public :: DestroyChunkDatabase, ChunkDivide, ReduceChunkDatabase
d77 2
a78 2
    logical   :: allowPriorOverlaps = .false. ! Use MAFs before start time
    logical   :: allowPostOverlaps = .false. ! Use MAFs after end time
d180 2
a181 2
    use Init_Tables_Module, only: F_ALLOWPOSTOVERLAPS, F_ALLOWPRIOROVERLAPS, &
      & F_CRITICALMODULES, F_CRITICALSIGNALS, &
d1104 10
a1121 10
        case ( f_allowPriorOverlaps )
          ChunkDivideConfig%allowPriorOverlaps = get_boolean ( fieldValue )
          if ( ChunkDivideConfig%allowPriorOverlaps ) &
            & call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'You have elected to allow MAFs prior to time range' )
        case ( f_allowPostOverlaps )
          ChunkDivideConfig%allowPostOverlaps = get_boolean ( fieldValue )
          if ( ChunkDivideConfig%allowPostOverlaps ) &
            & call MLSMessage(MLSMSG_Warning, ModuleName, &
            & 'You have elected to allow MAFs after to time range' )
a2134 9
    ! call output ( Config%maxGapFamily )
    ! call blanks ( 3 )
    ! call output ( PHYQ_Invalid )
    ! call blanks ( 3 )
    ! call output ( PHYQ_MAFs )
    ! call blanks ( 3 )
    ! call output ( PHYQ_Angle )
    ! call blanks ( 3 )
    ! call output ( PHYQ_Time, advance='yes' )
d2347 1
a2347 1
    "$Id: ChunkDivide_m.f90,v 2.68 2006/02/07 00:55:47 pwagner Exp $"
d2356 3
@


2.68
log
@Now allows overlaps after data end time
@
text
@d193 1
d202 1
a202 1
    use Output_M, only: BLANKS, OUTPUT
d240 2
d337 3
a340 1
    if ( index(switches, 'chu') /= 0 ) call dump ( chunks )
d2352 1
a2352 1
    "$Id: ChunkDivide_m.f90,v 2.67 2006/01/26 00:34:50 pwagner Exp $"
d2361 3
@


2.67
log
@demoted more use statements from module level to speed Lahey compiles
@
text
@d74 1
d176 1
a176 1
    use Init_Tables_Module, only: F_ALLOWPRIOROVERLAPS, &
d278 1
a278 1
      call ChunkDivide_Orbital ( mafRange%Expanded, filedatabase, chunks )
d573 2
a574 1
      integer, dimension(2), intent(in) :: MAFRANGE
d590 2
a591 1
      integer :: M1, M2                   ! MafRange + 1
d595 1
a595 1
      integer :: NOMAFS                   ! Number of MAFs to consider
d652 5
a656 3
      noMAFs = mafRange(2) - mafRange(1) + 1
      m1 = mafRange(1) + 1
      m2 = mafRange(2) + 1
d788 2
a789 1
        noChunksBelowHome = int ( ( homeV - minV ) / ChunkDivideConfig%maxLength )
d793 9
a801 2
          noChunks = noChunksBelowHome + int ( ( maxV - homeV ) / ChunkDivideConfig%maxLength )
          if ( homeV + ChunkDivideConfig%maxLength * ( noChunks - noChunksBelowHome ) < maxV ) &
d816 15
a830 3
        do chunk = 1, noChunks
          boundaries(chunk) = homeV + ( chunk - noChunksBelowHome ) * ChunkDivideConfig%maxLength
        end do
d900 1
a900 1
          & mafRange(1) )
d902 1
a902 1
          & mafRange(2) )
d936 1
a936 1
!       noChunks = size ( chunks )
d940 12
d953 2
a954 1
        call output ( 'After dealing with obstructions', advance='yes' )
d1108 5
d1955 2
a1957 1
      ! For now, allow only lower overlaps
d1961 4
a1964 4
        mafRange%Expanded(2) = mafRange%L2Cover(2)
      else
        mafRange%Expanded(1) = mafRange%L2Cover(1)
        mafRange%Expanded(2) = mafRange%L2Cover(2)
d2139 2
d2347 1
a2347 1
    "$Id: ChunkDivide_m.f90,v 2.66 2005/12/16 00:06:51 pwagner Exp $"
d2356 3
@


2.66
log
@Changes to reflect new MLSFillValues module
@
text
@a18 1
  use MLSFillValues, only: ISFILLVALUE
d2263 1
d2301 1
a2301 1
    "$Id: ChunkDivide_m.f90,v 2.65 2005/10/22 00:43:43 pwagner Exp $"
d2310 3
@


2.65
log
@Gets DACSDeconvolved attribute from l1b file if there
@
text
@d19 1
a19 1
  use MLSNumerics, only: ISFILLVALUE
d2301 1
a2301 1
    "$Id: ChunkDivide_m.f90,v 2.64 2005/09/21 23:25:42 pwagner Exp $"
d2310 3
@


2.64
log
@Obstructions public now; optionally saved; should add deallocate in tree_walker
@
text
@d35 1
a35 1
!    L1BInfo_T l1bInfo, *mlSChunk_T Chunks(:) )      
d76 1
d111 1
d186 1
a186 1
      & PHYQ_DIMENSIONLESS, PHYQ_INVALID, PHYQ_LENGTH, PHYQ_MAFS, PHYQ_TIME
d188 1
a188 1
      & AssembleL1BQtyName
d190 3
a192 2
    use MLSCommon, only: R8, RP, L1BINFO_T, MLSFile_T, TAI93_Range_T
    use MLSFiles, only: dump, GetMLSFileByType
d194 1
d208 1
d216 1
a216 2
    ! type (ChunkDivideConfig_T) :: CONFIG ! Configuration
    ! type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
a218 1
    ! integer, dimension(2) :: MAFRANGE   ! Processing range in MAFs
d286 14
d301 1
d310 2
a311 1
      if ( index(switches, 'chu') /= 0 ) call Dump_criticalSignals
a1463 1
      ! if ( .not. associated(l1bInfo%l1bRadIDs) ) return
d2015 90
a2104 2
  ! -------------------------------------------- Dump Dump_criticalSignals -----
  subroutine Dump_criticalSignals
d2108 2
a2109 1
    ! type (ChunkDivideConfig_T) :: CONFIG ! Configuration
d2113 2
a2114 2
    if ( associated ( ChunkDivideConfig%criticalSignals ) ) then
      if ( size(ChunkDivideConfig%criticalSignals) == 0 ) then
d2118 1
a2118 1
        call output ( size(ChunkDivideConfig%criticalSignals) )
d2120 1
a2120 1
        do i = 1, size(ChunkDivideConfig%criticalSignals)
d2123 1
a2123 1
          call output ( trim(ChunkDivideConfig%criticalSignals(i)), advance='yes' )
a2181 2
    use Allocate_Deallocate, only: Deallocate_Test
    use Chunks_m, only: MLSChunk_T
d2183 3
a2185 3
      & FindL1BData, AssembleL1BQtyName, PRECISIONSUFFIX, DEALLOCATEL1BDATA
    use MLSCommon, only: L1BInfo_T, MLSFile_T, RK => R8
    use MLSFiles, only: dump, GetMLSFileByType
d2198 3
a2200 2
    integer :: FileID, flag, noMAFs
    character(len=127)  :: namestring
d2203 2
a2205 2
    integer :: maf_index   ! 1 <= maf_index <= mafrange(2)-mafrange(1)+1
    type(MLSFile_T), pointer :: L1BFile
a2234 1
    ! call dump(L1BFile)
d2301 1
a2301 1
    "$Id: ChunkDivide_m.f90,v 2.63 2005/09/14 00:10:37 pwagner Exp $"
d2310 3
@


2.63
log
@ChunkDivideConfig public so allowPriorOverlaps visible
@
text
@d75 1
d98 1
d106 2
d177 4
a180 3
      & F_OVERLAP, F_LOWEROVERLAP, F_UPPEROVERLAP, &
      & F_MAXLENGTH, F_MAXORBY, F_METHOD, F_NOCHUNKS, &
      & F_SCANLOWERLIMIT, F_SCANUPPERLIMIT, F_NOSLAVES, F_SKIPL1BCHECK, &
d212 1
a212 1
    type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
d244 1
a244 2
      call SurveyL1BData ( processingRange, filedatabase, mafRange,&
      & obstructions )
d273 1
a273 2
      call ChunkDivide_PE ( mafRange%Expanded, filedatabase, &
        & obstructions, chunks )
d275 1
a275 2
      call ChunkDivide_Orbital ( mafRange%Expanded, filedatabase, &
        & obstructions, chunks )
d277 1
a277 2
      call ChunkDivide_Even ( mafRange%Expanded, filedatabase, &
        & obstructions, chunks )
d286 2
a287 1
      deallocate ( obstructions, stat=status )
d374 1
a374 3
    subroutine ChunkDivide_Even ( mafRange, filedatabase, &
      & obstructions, chunks )
      ! type (ChunkDivideConfig_T), intent(in) :: CONFIG
a376 1
      type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
d422 1
a422 2
    subroutine ChunkDivide_PE ( mafRange, filedatabase, &
      & obstructions, chunks )
a425 1
      type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
d553 1
a553 3
    subroutine ChunkDivide_Orbital ( mafRange, filedatabase, &
      & obstructions, chunks )
      ! type (ChunkDivideConfig_T), intent(in) :: CONFIG
a555 1
      type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
d1052 5
d1229 2
a1230 2
          ! Now think about chunks who's non overlapped part completely
          ! encompas the range, and split them.
a1406 1
      ! integer, dimension(2), intent(in) :: MAFRANGE   ! Processing range in MAFs
d1824 1
a1824 2
    subroutine SurveyL1BData ( processingRange, filedatabase, mafRange, &
      & obstructions )
a1828 1
      ! type (ChunkDivideConfig_T), intent(in) :: CONFIG
a1829 2
      !integer, dimension(2), intent(out) :: MAFRANGE   ! Processing range in MAFs
      type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
d2196 1
a2196 1
    "$Id: ChunkDivide_m.f90,v 2.62 2005/08/09 00:02:09 pwagner Exp $"
d2205 3
@


2.62
log
@hdfVersion not left undefined in ANY_GOOD_SIGNALDATA
@
text
@d46 1
d74 1
d89 8
d170 4
a173 1
    use Init_Tables_Module, only: F_OVERLAP, F_LOWEROVERLAP, F_UPPEROVERLAP, &
a174 1
      & F_HOMEMODULE, F_CRITICALMODULES, F_CRITICALSIGNALS, F_HOMEGEODANGLE, &
a201 1
    ! type( L1BInfo_T ), intent(in) :: L1BINFO
d206 1
a206 1
    type (ChunkDivideConfig_T) :: CONFIG ! Configuration
d208 1
d210 1
a210 1
    integer, dimension(2) :: MAFRANGE   ! Processing range in MAFs
d225 1
a225 1
    nullify(config%criticalSignals)    ! Just for Sun's compiler
d233 1
a233 1
    call ChunkDivideL2CF ( root, config )
d238 2
a239 3
    if ( config%method /= l_fixed ) then
      ! call SurveyL1BData ( processingRange, l1bInfo, config, mafRange,&
      call SurveyL1BData ( processingRange, filedatabase, config, mafRange,&
d247 5
a251 1
        call output ( mafRange(1) )              
d253 5
a257 1
        call output ( mafRange(2), advance='yes' )
d259 1
a259 1
        call display_string ( lit_indices(config%method), &
d265 1
a265 1
    select case ( config%method )
d267 1
a267 1
      call ChunkDivide_Fixed ( config, chunks )
d269 1
a269 1
      call ChunkDivide_PE ( config, mafRange, filedatabase, &
d272 1
a272 1
      call ChunkDivide_Orbital ( config, mafRange, filedatabase, &
d275 1
a275 1
      call ChunkDivide_Even ( config, mafRange, filedatabase, &
d289 3
a291 3
    if ( associated(config%criticalSignals) ) then
      if ( index(switches, 'chu') /= 0 ) call Dump_criticalSignals ( config )
      deallocate ( config%criticalSignals, stat=status )
d293 1
a293 1
        & MLSMSG_Deallocate//'config%criticalSignals' )
d298 2
a299 2
    if ( config%method /= l_fixed ) &
      & call CheckChunkSanity ( chunks, mafRange )
d372 1
a372 2
    ! subroutine ChunkDivide_Even ( config, mafRange, l1bInfo, &
    subroutine ChunkDivide_Even ( config, mafRange, filedatabase, &
d374 1
a374 1
      type (ChunkDivideConfig_T), intent(in) :: CONFIG
a376 1
      ! type (L1BInfo_T), intent(in) :: L1BINFO
d388 2
a389 2
    subroutine ChunkDivide_Fixed ( config, chunks )
      type (ChunkDivideConfig_T), intent(in) :: CONFIG
d401 1
a401 1
      allocate ( chunks(config%noChunks), stat=status )
d405 3
a407 3
      maxLength = nint ( config%maxLength )
      lowerOverlap = nint ( config%lowerOverlap )
      upperOverlap = nint ( config%upperOverlap )
d409 1
a409 1
      do i = 1, config%noChunks
d423 1
a423 1
    subroutine ChunkDivide_PE ( config, mafRange, filedatabase, &
d425 1
a425 1
      type (ChunkDivideConfig_T), intent(in) :: CONFIG
a427 1
      ! type (L1BInfo_T), intent(in) :: L1BINFO
d465 1
a465 1
      call get_string ( lit_indices(config%homeModule), modNameStr, &
d498 3
a500 3
      testAngle = config%homeGeodAngle + orbit*360.0
      if ( config%maxLengthFamily == PHYQ_Angle ) then
        angleIncrement = config%maxLength
d505 1
a505 1
      maxLength = nint ( config%maxLength )
d535 1
a535 1
      ! config%maxLengthFamily == PHYQ_MAFs
d556 1
a556 1
    subroutine ChunkDivide_Orbital ( config, mafRange, filedatabase, &
d558 1
a558 1
      type (ChunkDivideConfig_T), intent(in) :: CONFIG
a560 1
      ! type (L1BInfo_T), intent(in) :: L1BINFO
d611 1
a611 1
      call get_string ( lit_indices(config%homeModule), modNameStr, strip=.true. )
d646 1
a646 1
        call output ( 'No MAFs in file: ' )
d662 3
a664 3
      testAngle = config%homeGeodAngle + orbit*360.0
      if ( config%maxLengthFamily == PHYQ_Angle ) then
        angleIncrement = config%maxLength
d726 2
a727 2
      if ( config%maxLengthFamily == PHYQ_MAFs ) then
        maxLength = nint ( config%maxLength )
d732 1
a732 1
        if ( config%noChunks == 0 ) then
d739 1
a739 1
          noChunks = config%noChunks
d756 1
a756 1
        select case ( config%maxLengthFamily )
d771 1
a771 1
        noChunksBelowHome = int ( ( homeV - minV ) / config%maxLength )
d773 1
a773 1
        if ( config%noChunks == 0 ) then
d775 2
a776 2
          noChunks = noChunksBelowHome + int ( ( maxV - homeV ) / config%maxLength )
          if ( homeV + config%maxLength * ( noChunks - noChunksBelowHome ) < maxV ) &
d779 1
a779 1
          noChunks = config%noChunks
d792 1
a792 1
          boundaries(chunk) = homeV + ( chunk - noChunksBelowHome ) * config%maxLength
d861 2
a862 2
      if ( config%lowerOverlapFamily == PHYQ_MAFs ) then
        newFirstMAFs = max(chunks%firstMAFIndex - nint(config%lowerOverlap), &
d864 1
a864 1
        newLastMAFs = min(chunks%lastMAFIndex + nint(config%upperOverlap), &
a868 29
!         ! For angle and time, they are similar enough we'll just do some stuff
!         ! with pointers to allow us to use common code to sort them out
!         ! Note that before we search only over the range in mafRange, here we
!         ! search over the whole file as we can spill over the processing range
!         ! for overlaps.
!         select case ( config%maxLengthFamily )
!         case ( PHYQ_Angle )
!           field => tpGeodAngle%dpField(1,1,:)
!           minV = minAngle
!         case ( PHYQ_Time )
!           field => taiTime%dpField(1,1,:)
!           minV = minTime
!         case ( PHYQ_MAFs)
!         end select
!         call Hunt ( field, field(chunks%firstMAFIndex-1) + &
!           & config%lowerOverlap, newFirstMAFs, allowTopValue=.true. )
!         call Hunt ( field, field(chunks%firstMAFIndex-1) - &
!           & config%upperOverlap, newLastMAFs, allowTopValue=.true. )
!         if ( index(switches, 'chu') /= 0 ) then
!           call dump ( field(chunks%firstMAFIndex-1) + &
!             & config%lowerOverlap , 'fields+lowerOverlap' )
!           call dump ( field(newFirstMAFs) , 'hunted values' )
!           call dump ( field(chunks%firstMAFIndex-1) - &
!             & config%upperOverlap , 'fields-upperOverlap' )
!           call dump ( field(newLastMAFs) , 'hunted values' )
!         end if
!         ! Correct this to be real MAF indices (starting from zero)
!         newFirstMAFs = newFirstMAFs - 1
!         newLastMAFs = newLastMAFs - 1
d915 1
a915 1
    subroutine ChunkDivideL2CF ( sectionRoot, config )
d920 1
a920 1
      type (ChunkDivideConfig_T), intent(out) :: CONFIG ! Result of operation
d993 1
a993 1
          config%method = decoration ( gson )
d995 1
a995 1
          config%noChunks = nint ( value(1) )
d997 2
a998 2
          config%maxLength = value(1)
          config%maxLengthFamily = units(1)
d1000 1
a1000 1
          config%maxOrbY = value(1)
d1004 2
a1005 2
          config%overlap = value(1)
          config%overlapFamily = units(1)
d1007 2
a1008 2
          config%lowerOverlap = value(1)
          config%lowerOverlapFamily = units(1)
d1010 2
a1011 2
          config%upperOverlap = value(1)
          config%upperOverlapFamily = units(1)
d1013 1
a1013 1
          config%noSlaves = value(1)
d1017 1
a1017 1
          config%homeModule = decoration ( gson )
d1019 1
a1019 1
          config%homeGeodAngle = value(1)
d1026 2
a1027 2
          config%scanLowerLimit = value
          config%scanLLSet = .true.
d1032 2
a1033 2
          config%scanUpperLimit = value
          config%scanULSet = .true.
d1035 1
a1035 1
          config%criticalModules = decoration ( gson )
a1036 3
          ! sub_rosa_index = sub_rosa(gson)
          ! call get_string ( sub_rosa_index, config%criticalSignals, &
          !  & strip=.true. )
d1039 1
a1039 1
          call allocate_test(config%criticalSignals, numCriticalSignals, &
d1043 1
a1043 1
              & config%criticalSignals(j-1), strip=.true. )
d1046 2
a1047 2
          config%maxGap = value(1)
          config%maxGapFamily = units(1)
d1049 2
a1050 2
          config%skipL1BCheck = get_boolean ( fieldValue )
          if ( config%skipL1BCheck ) &
d1053 5
d1063 1
a1063 1
      select case ( config%method )
d1087 1
a1087 1
        if ( config%lowerOverlapFamily /= config%upperOverlapFamily ) &
d1092 4
a1095 4
          config%lowerOverlap = config%overlap
          config%lowerOverlapFamily = config%overlapFamily
          config%upperOverlap = config%overlap
          config%upperOverlapFamily = config%overlapFamily
d1111 1
a1111 1
      if ( config%criticalModules /= l_none ) then
d1124 1
a1124 1
      if ( got(f_maxgap) .and. all ( config%maxGapFamily /= &
d1127 1
a1127 1
      select case ( config%method )
d1129 1
a1129 1
        if ( config%maxLengthFamily /= PHYQ_MAFs ) &
d1132 1
a1132 1
        if (all(config%maxLengthFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
d1134 1
a1134 1
        if (all(config%lowerOverlapFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
d1136 1
a1136 1
        if (all(config%upperOverlapFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
d1139 1
a1139 1
        if ( config%maxLengthFamily /= PHYQ_MAFs ) &
d1141 1
a1141 1
        if ( config%lowerOverlapFamily /= PHYQ_MAFs ) &
d1143 1
a1143 1
        if ( config%upperOverlapFamily /= PHYQ_MAFs ) &
a1396 1
    ! subroutine NoteL1BRADChanges ( obstructions, mafRange, l1bInfo )
d1407 2
a1408 1
      integer, dimension(2), intent(in) :: MAFRANGE   ! Processing range in MAFs
a1409 1
      !type (L1BInfo_T), intent(in) :: L1BINFO
d1434 1
d1449 1
d1462 1
a1462 1
        & signals_buffer, mafRange(2) - mafRange(1) + 1 , size(signals), &
d1464 1
a1464 1
      call allocate_test( goods_after_gap, mafRange(2) - mafRange(1) + 1,&
d1466 1
a1466 1
      call allocate_test( goodness_changes, mafRange(2) - mafRange(1) + 1,&
d1470 1
a1470 1
        if ( mafRange(2) - mafRange(1) + 1 <= MAXMAFSINSET ) then
d1473 2
a1474 2
            &   filedatabase, mafRange(1), mafRange(2), &
            &   signals_buffer(:,signalIndex), mafRange )
d1476 2
a1477 2
          nmafsets = (mafRange(2) - mafRange(1))/MAXMAFSINSET + 1
          mafset_end = mafRange(1) - 1   ! A trick--mafset_start is mafRange(1)
d1480 1
a1480 1
            mafset_end = min ( mafRange(2), mafset_end + MAXMAFSINSET )
d1484 1
a1484 1
              &   signals_buffer(:,signalIndex), mafRange )
d1499 2
a1500 2
      do maf = mafRange(1), mafRange(2)
        maf_index = maf - mafRange(1) + 1
d1508 1
a1508 1
            & ( howlong_nogood(signalIndex) > config%maxGap )
d1511 1
a1511 1
        if ( maf /= mafRange(1) ) then
d1527 1
a1527 1
      if ( associated(config%criticalSignals) ) then
d1530 1
a1530 1
          & valids_buffer, mafRange(2) - mafRange(1) + 1 , &
d1534 1
a1534 1
          & or_valids_buffer, mafRange(2) - mafRange(1) + 1 , &
d1539 2
a1540 2
          do critical_index=1, size(config%criticalSignals)
            call output ( trim(config%criticalSignals(critical_index)), &
d1559 1
a1559 1
        do critical_index=1, size(config%criticalSignals)
d1562 1
a1562 1
            & trim(config%criticalSignals(critical_index)), .FALSE.)
d1564 1
a1564 1
              & trim(config%criticalSignals(critical_index)), signal_str, &
d1579 2
a1580 2
            do maf = mafRange(1), mafRange(2)
              maf_index = maf - mafRange(1) + 1
d1595 2
a1596 1
        call ConvertFlagsToObstructions ( valids_buffer, obstructions, mafRange )
d1606 1
a1606 1
          newObstruction%mafs(2) = 0    ! For overzelous Lahey uninitialized checking
d1613 1
a1613 1
          newObstruction%mafs(2) = 0    ! For overzelous Lahey uninitialized checking
d1826 1
a1826 1
    subroutine SurveyL1BData ( processingRange, filedatabase, config, mafRange,&
d1828 1
a1828 1
      ! This goes through the L1B data files and trys to spot possible
d1832 3
a1834 3
      ! type (L1BInfo_T), intent(in) :: L1BINFO
      type (ChunkDivideConfig_T), intent(in) :: CONFIG
      integer, dimension(2), intent(out) :: MAFRANGE   ! Processing range in MAFs
d1877 4
d1882 1
a1882 1
      ! Deduce the first and last MAFs to consider
d1885 1
a1885 1
        & mafRange, allowTopValue=.true., allowBelowValue=.true. )
d1888 1
a1888 1
      if ( mafRange(2) == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1890 1
a1890 1
      if ( mafRange(1) == taiTime%noMAFs ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1892 2
a1893 3
      mafRange = min ( noMAFsRead-1, max ( 0, mafRange - 1 ) )          ! Index from zero
      noMAFS = mafRange(2) - mafRange(1) + 1
      if ( mafRange(2) < mafRange(1) ) then
d1895 2
a1896 2
          & 'mafRange(2) < mafRange(1)' )
      elseif ( mafRange(2) < 1 ) then
d1898 1
a1898 1
          & 'mafRange(2) < 1' )
d1901 11
d1913 1
a1913 1
      if ( config%criticalModules /= l_none ) then
d1920 1
a1920 1
        if ( config%criticalModules == l_both ) then
d1934 2
a1935 2
            & ( any ( config%criticalModules == (/ l_either, l_both /) ) .or. &
            &   lit_indices(config%criticalModules) == modules(mod)%name ) ) then
d1939 1
a1939 1
              & firstMAF=mafRange(1), lastMAF=mafRange(2), &
d1944 1
a1944 1
              & firstMAF=mafRange(1), lastMAF=mafRange(2), &
d1948 1
a1948 1
              & firstMAF=mafRange(1), lastMAF=mafRange(2), &
d1961 6
a1966 6
              thisOneValid = ( scanMin >= config%scanLowerLimit(1) .and. &
                &              scanMin <= config%scanLowerLimit(2) ) .and. &
                &            ( scanMax >= config%scanUpperLimit(1) .and. &
                &              scanMax <= config%scanUpperLimit(2) )
              if ( config%maxOrbY > 0.0 ) then
                thisOneValid = thisOneValid .and. orbYMax < config%maxOrbY
d1971 1
a1971 1
              if ( config%criticalModules == l_both ) then
d1991 1
a1991 1
      if ( .not. config%skipL1BCheck) &
d2004 1
a2004 1
  subroutine Dump_criticalSignals ( config )
d2008 1
a2008 1
    type (ChunkDivideConfig_T) :: CONFIG ! Configuration
d2012 2
a2013 2
    if ( associated ( config%criticalSignals ) ) then
      if ( size(config%criticalSignals) == 0 ) then
d2017 1
a2017 1
        call output ( size(config%criticalSignals) )
d2019 1
a2019 1
        do i = 1, size(config%criticalSignals)
d2022 1
a2022 1
          call output ( trim(config%criticalSignals(i)), advance='yes' )
a2066 1
  ! function ANY_GOOD_SIGNALDATA ( signal, sideband, l1bInfo, maf, maf2, &
a2094 1
    ! type (L1BInfo_T), intent(in) :: L1BINFO
d2202 1
a2202 1
    "$Id: ChunkDivide_m.f90,v 2.61 2005/06/03 02:02:17 vsnyder Exp $"
d2211 3
@


2.61
log
@New copyright notice, move Id to not_used_here to avoid cascades
@
text
@a210 1
    type (MLSFile_T)             :: L1BFile
d2083 1
a2083 1
    use MLSFiles, only: dump
a2099 1
    integer :: hdfVersion
d2120 2
d2124 1
a2124 1
    nameString = AssembleL1BQtyName ( nameString, hdfVersion, .false. )
a2128 1
    ! if ( fileID <= 0 ) then
d2200 1
a2200 1
    "$Id: ChunkDivide_m.f90,v 2.60 2005/06/01 17:39:26 pwagner Exp $"
d2209 3
@


2.60
log
@Dont read L1bFile if unassocated
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a40 3
  character (len=*), private, parameter :: IdParm = &
    "$Id: ChunkDivide_m.f90,v 2.59 2005/05/31 17:51:16 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d2199 5
d2210 3
@


2.59
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d34 1
a34 1
    "$Id: ChunkDivide_m.f90,v 2.57 2004/12/14 21:43:33 pwagner Exp $"
d2079 1
d2124 2
a2125 1
    if ( fileID <= 0 ) then
d2129 1
d2200 3
@


2.58
log
@Produce meaningful error message instead of crash for empty section
@
text
@d149 1
a149 1
  subroutine ChunkDivide ( root, processingRange, l1bInfo, chunks )
d166 2
a167 4
    use MLSCommon, only: R8, RP, L1BINFO_T, TAI93_Range_T
    use MLSFiles, only: HDFVERSION_4, HDFVERSION_5, WILDCARDHDFVERSION, &
      & mls_hdf_version
    use MLSL2Options, only: LEVEL1_HDFVERSION
d173 1
a173 1
    use MLSSignals_m, only: MODULES, ISMODULESPACECRAFT
d181 1
a181 1
    use Tree_types, only: N_EQUAL, N_NAMED
d184 2
a185 1
    type( L1BInfo_T ), intent(in) :: L1BINFO
d206 1
d223 2
a224 1
      call SurveyL1BData ( processingRange, l1bInfo, config, mafRange,&
d246 1
a246 1
      call ChunkDivide_PE ( config, mafRange, l1bInfo, &
d249 1
a249 1
      call ChunkDivide_Orbital ( config, mafRange, l1bInfo, &
d252 1
a252 1
      call ChunkDivide_Even ( config, mafRange, l1bInfo, &
d349 2
a350 1
    subroutine ChunkDivide_Even ( config, mafRange, l1bInfo, &
d354 2
a355 1
      type (L1BInfo_T), intent(in) :: L1BINFO
d402 1
a402 1
    subroutine ChunkDivide_PE ( config, mafRange, l1bInfo, &
d406 2
a407 1
      type (L1BInfo_T), intent(in) :: L1BINFO
a423 2
      integer :: NOCHUNKSBELOWHOME        ! Used for placing chunks
      integer :: NOMAFSATORABOVEHOME      ! Fairly self descriptive
a437 2
      real(r8), dimension(:), pointer :: BOUNDARIES ! Used in placing chunks
      real(r8), dimension(:), pointer :: FIELD ! Used in placing chunks
d440 1
d447 3
a449 8
      if ( LEVEL1_HDFVERSION /= WILDCARDHDFVERSION ) then
        l1b_hdf_version = LEVEL1_HDFVERSION
      else
        l1b_hdf_version = mls_hdf_version(trim(l1bInfo%L1BOAFileName))
        if ( l1b_hdf_version <= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
      endif
d455 2
a456 2
      call ReadL1BData ( l1bInfo%l1bOAId, trim(tp_angle), &
        & tpGeodAngle, noMAFsRead, flag, hdfVersion=l1b_hdf_version , &
d461 2
a462 2
      call ReadL1BData ( l1bInfo%l1bOAId, trim(MAF_start), &
        & taiTime, noMAFsRead, flag, hdfVersion=l1b_hdf_version , &
d536 1
a536 1
    subroutine ChunkDivide_Orbital ( config, mafRange, l1bInfo, &
d540 2
a541 1
      type (L1BInfo_T), intent(in) :: L1BINFO
d586 1
d593 3
a595 8
      if ( LEVEL1_HDFVERSION /= WILDCARDHDFVERSION ) then
        l1b_hdf_version = LEVEL1_HDFVERSION
      else
        l1b_hdf_version = mls_hdf_version(trim(l1bInfo%L1BOAFileName))
        if ( l1b_hdf_version <= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
      endif
d603 2
a604 2
      call ReadL1BData ( l1bInfo%l1bOAId, trim(tp_angle), &
        & tpGeodAngle, noMAFsRead, flag, hdfVersion=l1b_hdf_version , &
d614 2
a615 2
      call ReadL1BData ( l1bInfo%l1bOAId, trim(MAF_start), &
        & taiTime, noMAFsRead, flag, hdfVersion=l1b_hdf_version , &
a965 1
      integer :: sub_rosa_index
d1405 4
a1408 4
    subroutine NoteL1BRADChanges ( obstructions, mafRange, l1bInfo )
      use MLSSignals_m, only:GetModuleFromRadiometer, GetModuleFromSignal, &
        & GetRadiometerFromSignal, GetSignal, GetSignalName, &
        & Signal_T, SIGNALS, MODULES
d1417 2
a1418 1
      type (L1BInfo_T), intent(in) :: L1BINFO
d1455 2
a1456 1
      if ( .not. associated(l1bInfo%l1bRadIDs) ) return
d1480 1
a1480 1
            &   l1bInfo, mafRange(1), mafRange(2), &
d1490 1
a1490 1
              &   l1bInfo, mafset_start, mafset_end, &
d1832 1
a1832 1
    subroutine SurveyL1BData ( processingRange, l1bInfo, config, mafRange,&
d1837 2
a1838 1
      type (L1BInfo_T), intent(in) :: L1BINFO
a1847 1
      type (Obstruction_T) :: NEWOBSTRUCTION ! A single obstruction
a1856 1
      logical :: LASTONEVALID             ! To run through valid
d1868 1
d1871 3
a1873 8
      if ( LEVEL1_HDFVERSION /= WILDCARDHDFVERSION ) then
        l1b_hdf_version = LEVEL1_HDFVERSION
      else
        l1b_hdf_version = mls_hdf_version(trim(l1bInfo%L1BOAFileName))
        if ( l1b_hdf_version <= 0 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
      endif
d1879 2
a1880 2
      call ReadL1BData ( l1bInfo%l1boaId, trim(MAF_start), taiTime, &
        & noMAFsRead, flag, hdfVersion=l1b_hdf_version , &
d1929 2
a1930 2
            call ReadL1BData ( l1bInfo%l1boaID, trim(tp_alt), &
              & tpGeodAlt, noMAFsRead, flag, hdfVersion=l1b_hdf_version , &
d1934 2
a1935 2
            call ReadL1BData ( l1bInfo%l1boaID, trim(tp_orby), &
              & tpOrbY, noMAFsRead, flag, hdfVersion=l1b_hdf_version , &
d1938 2
a1939 2
            call ReadL1BData ( l1bInfo%l1boaID, trim(tp_angle), &
              & tpGeodAngle, noMAFsRead, flag, hdfVersion=l1b_hdf_version , &
d1984 1
a1984 1
        call NoteL1BRADChanges ( obstructions, mafRange, l1bInfo ) 
d2059 2
a2060 1
  function ANY_GOOD_SIGNALDATA ( signal, sideband, l1bInfo, maf, maf2, &
d2076 1
a2076 1
    use L1BData, only: L1BData_T, READL1BDATA, &
d2078 1
a2078 3
    use MLSCommon, only: L1BInfo_T, RK => R8
    use MLSFiles, only: MLS_HDF_Version
    use MLSL2Options, only: LEVEL1_HDFVERSION
d2086 2
a2087 1
    type (l1bInfo_T), intent(in)                   :: L1bInfo
d2099 1
a2114 3
    ! Quit if no l1b rad files.
    if ( .not. associated(l1bInfo%l1bRadIDs) ) return

a2115 4
    hdfVersion = mls_hdf_version ( trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION )
    if ( hdfversion <= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
d2120 2
a2121 1
    fileID = FindL1BData (l1bInfo%l1bRadIDs, nameString, hdfVersion )
d2129 1
a2129 1
    call ReadL1BData ( fileID , nameString, my_l1bData, noMAFs, flag, &
d2131 1
a2131 1
      & NeverFail= .true., hdfVersion=hdfVersion, dontPad = .false. )
d2197 3
@


2.57
log
@Repaired bug in reading mafRange rather than all mafs
@
text
@d34 1
a34 1
    "$Id: ChunkDivide_m.f90,v 2.56 2004/11/03 17:19:09 livesey Exp $"
d986 2
d2213 3
@


2.56
log
@Bug fix in case where only one chunk
@
text
@d34 1
a34 1
    "$Id: ChunkDivide_m.f90,v 2.55 2004/10/05 23:09:54 pwagner Exp $"
d234 3
d591 2
d608 2
d613 2
d616 2
d619 2
d1940 1
d1945 1
d1949 1
d2211 3
@


2.55
log
@Can handle dropped MAFs, maneuvers that disrupt monotonic geodAngle
@
text
@d34 1
a34 1
    "$Id: ChunkDivide_m.f90,v 2.54 2004/08/23 22:00:39 pwagner Exp $"
d815 5
a819 3
      if ( chunks(noChunks-1)%lastMAFIndex == chunks(noChunks)%lastMAFIndex ) then
        call DeleteChunk ( chunks, noChunks )
        noChunks = noChunks - 1
d2195 3
@


2.54
log
@Made most readl1bData dontpad=.true.
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d10 3
a12 1
  use MLSCommon, only: RP
d34 1
a34 1
    "$Id: ChunkDivide_m.f90,v 2.53 2004/08/16 17:10:04 pwagner Exp $"
d459 3
d465 1
d606 2
d611 1
d1834 1
d1849 2
d1857 1
a1857 1
      character(len=NAME_LEN) ::         MAF_start, tp_alt, tp_orbY
d1876 1
d1901 2
d1904 2
d1917 2
d1930 8
d1951 3
d1961 3
d1969 2
d2149 37
d2193 3
@


2.53
log
@Passes dontPad option to readL1BData
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.52 2004/08/09 21:43:10 livesey Exp $"
d95 1
d455 2
a456 1
        & tpGeodAngle, noMAFsRead, flag, hdfVersion=l1b_hdf_version )
d458 2
a459 1
        & taiTime, noMAFsRead, flag, hdfVersion=l1b_hdf_version )
d598 2
a599 1
        & tpGeodAngle, noMAFsRead, flag, hdfVersion=l1b_hdf_version )
d601 2
a602 1
        & taiTime, noMAFsRead, flag, hdfVersion=l1b_hdf_version )
d1862 2
a1863 1
        & noMAFsRead, flag, hdfVersion=l1b_hdf_version )
d1905 2
a1906 1
              & tpGeodAlt, noMAFsRead, flag, hdfVersion=l1b_hdf_version )
d1909 2
a1910 1
              & tpOrbY, noMAFsRead, flag, hdfVersion=l1b_hdf_version )
d2121 3
@


2.52
log
@Bug fixes and added the maxOrbY argument.
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.51 2004/08/04 23:19:57 pwagner Exp $"
d2084 1
a2084 1
      & NeverFail= .true., hdfVersion=hdfVersion )
d2113 3
@


2.51
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.50 2004/08/02 23:40:29 livesey Exp $"
d59 1
d153 1
a153 1
      & F_MAXLENGTH, F_METHOD, F_NOCHUNKS, &
d986 4
d1820 1
d1836 2
a1837 1
      real(r8) :: SCANMIN                 ! Range of scan each mif
d1840 1
a1840 1
      character(len=NAME_LEN) ::         MAF_start, tp_alt
d1892 2
d1895 2
a1896 2
            & any ( config%criticalModules == &
            &     (/ modules(mod)%name, l_either, l_both /) ) ) then
d1900 3
d1907 2
d1913 3
d2113 3
@


2.50
log
@Bug fixes in the orbital case when chunk length is expressed in MAFs
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.49 2004/07/31 19:58:28 livesey Exp $"
d1381 1
a1381 1
      use MLSStrings, only: NumStringElements, GetStringElement
d2096 3
@


2.49
log
@Various bug fixes and clean ups in the light of real data.
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.47 2004/06/10 00:58:44 vsnyder Exp $"
d657 2
a658 2
            & 'Unable to establish a home major frame, using the first' )
          home = 1
d688 1
a688 1
        noMAFsBelowHome = home - m1 + 1
d2096 3
@


2.48
log
@Roped off the non MAF based overlap section, as I'm suspicious that it
doesn't work.
@
text
@d222 1
a222 1
        call output ( ' processingRange ' )          
d224 6
a229 6
        call output ( ' ', advance='no' )    
        call output ( processingRange%endTime )              
        call output ( ' ', advance='yes' )    
        call output ( ' mafRange ' )          
        call output ( mafRange )              
        call output ( ' ', advance='yes' )    
a545 1
      integer :: HOMEMAF                  ! first MAF after homeGeodAngle
d550 1
d553 1
a553 1
      integer :: ORBIT                    ! Used to locate homeMAF
a556 1
      integer :: two                      ! Min(2, NoChunks)
d561 1
a561 1
      real(r8) :: ANGLEINCREMENT          ! Increment in hunt for homeMAF
d605 12
a669 1
      homeMAF = home + m1 - 1
d671 1
a671 1
        call output ( '    testAngle  ', advance='no' )   
d673 1
a673 1
        call output ( '    Angle(home)  ', advance='no' )   
d675 3
a677 5
        call output ( ' home  ', advance='no' )   
        call output ( home , advance='no' )      
        call output ( ' homeMAF  ', advance='no' )   
        call output ( homeMAF , advance='yes' )      
        call output ( ' diff  ', advance='no' )   
d688 4
a691 3
        noChunksBelowHome = home / maxLength
        if ( mod ( home, maxLength ) /= 0 ) noChunksBelowHome = noChunksBelowHome + 1
        noMAFsAtOrAboveHome = noMAFs - home + 1
d709 3
a711 2
          chunks(chunk)%lastMAFIndex = homeMAF + &
            & ( chunk - noChunksBelowHome ) * maxLength
d729 2
a740 1
        two = min(2, noChunks)
d756 2
a757 2
        call Hunt ( field, boundaries, chunks%lastMAFIndex, &
          & allowTopValue=.true., nearest=.true. )
d759 3
a761 3
          call output ( ' minV: ', advance='no' ) 
          call output ( minV , advance='no' ) 
          call output ( ' maxV: ', advance='no' ) 
d763 1
a763 1
          call output ( ' homeV: ', advance='no' ) 
d765 5
a769 1
          call output ( ' NoChunks: ', advance='no' ) 
d771 1
a771 1
          call output ( ' noChunksBelowHome: ', advance='no' ) 
d774 1
a774 1
          call dump ( chunks%lastMAFIndex , 'chunks%lastMAFIndex' )
d776 3
d786 5
a790 5
      ! chunks(1)%firstMAFIndex = 1
      chunks(1)%firstMAFIndex = mafRange(1)
      if ( index(switches, 'chu') /= 0 ) then                      
        call dump ( chunks%firstMAFIndex , 'chunks%firstMAFIndex' )  
      end if
d797 14
a823 12
        if ( index(switches, 'chu') /= 0 ) then
          call output ( 'config%overlap  ' )
          call output ( config%overlap, advance='yes')
          call output ( 'config%lowerOverlap  ' )
          call output ( config%lowerOverlap, advance='yes')
          call output ( 'config%upperOverlap  ' )
          call output ( config%upperOverlap, advance='yes')
          call output ( 'new 1st MAF  ' )
          call output ( chunks(1:two)%firstMAFIndex - nint(config%overlap) )
          call output ( '   new last MAF  ' )
          call output ( chunks(1:two)%lastMAFIndex + nint(config%overlap) , advance='yes')
        endif
d826 30
a855 30
          & 'The code for non MAF based overlaps has not been tested, do not use!' )
        ! For angle and time, they are similar enough we'll just do some stuff
        ! with pointers to allow us to use common code to sort them out
        ! Note that before we search only over the range in mafRange, here we
        ! search over the whole file as we can spill over the processing range
        ! for overlaps.
        select case ( config%maxLengthFamily )
        case ( PHYQ_Angle )
          field => tpGeodAngle%dpField(1,1,:)
          minV = minAngle
        case ( PHYQ_Time )
          field => taiTime%dpField(1,1,:)
          minV = minTime
        case ( PHYQ_MAFs)
        end select
        call Hunt ( field, field(chunks%firstMAFIndex-1) + &
          & config%lowerOverlap, newFirstMAFs, allowTopValue=.true. )
        call Hunt ( field, field(chunks%firstMAFIndex-1) - &
          & config%upperOverlap, newLastMAFs, allowTopValue=.true. )
        if ( index(switches, 'chu') /= 0 ) then
          call dump ( field(chunks%firstMAFIndex-1) + &
            & config%lowerOverlap , 'fields+lowerOverlap' )
          call dump ( field(newFirstMAFs) , 'hunted values' )
          call dump ( field(chunks%firstMAFIndex-1) - &
            & config%upperOverlap , 'fields-upperOverlap' )
          call dump ( field(newLastMAFs) , 'hunted values' )
        end if
        ! Correct this to be real MAF indices (starting from zero)
        newFirstMAFs = newFirstMAFs - 1
        newLastMAFs = newLastMAFs - 1
d885 4
a888 4
      ! Forcibly zero out number of lower (upper) overlaps on 1st (last) chunks
      noChunks = size ( chunks )
      chunks(1)%noMAFsLowerOverlap = 0
      chunks(noChunks)%noMAFsUpperOverlap = 0
@


2.47
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.46 2004/05/19 19:16:09 vsnyder Exp $"
d805 2
d2076 3
@


2.46
log
@Move MLSChunk_t to Chunks_m
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.45 2003/08/27 20:08:04 livesey Exp $"
d162 1
a162 2
    use MLSCommon, only: R8, RP, L1BINFO_T, TAI93_Range_T, &
      & FINDFIRST
d166 1
d2074 3
@


2.45
log
@Removed print statements
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.44 2003/08/26 19:49:22 livesey Exp $"
d100 1
a100 1
    use MLSCommon, only: MLSCHUNK_T
d121 1
a121 1
    use MLSCommon, only: MLSCHUNK_T
d148 1
a148 1
    use Dumper, only: DUMP
d162 1
a162 1
    use MLSCommon, only: R8, RP, L1BINFO_T, MLSCHUNK_T, TAI93_Range_T, &
d1983 1
d1986 1
a1986 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, RK => R8
d2074 3
@


2.44
log
@Removed another print statement.
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.43 2003/08/26 19:43:42 livesey Exp $"
a129 3
    print *, 'size(chunks) ', size(chunks)
    print *, 'firstChunk, lastChunk ', firstChunk, lastChunk
    print *, 'associated ( chunks ) ', associated ( chunks )
a131 1
    print *, 'new size ', newSize
a132 1
    print *, 'lastChunk > size(chunks) ', (lastChunk > size(chunks))
a140 1
    print *, 'new size(chunks) ', size(chunks)
d268 1
a268 1
      & call share_non_ovmf ( chunks, mafRange )
d848 2
a849 10
      ! Now delete any chunks that are nothing but overlap
      ! or have negative overlaps
      allOverlapChunks: do
        chunk = FindFirst ( &
          & ( chunks%noMAFsLowerOverlap + chunks%noMAFsUpperOverlap ) >= &
          & ( chunks%lastMAFIndex - chunks%firstMAFIndex + 1 ) &
          & .or. (chunks%noMAFsUpperOverlap < 0) )
        if ( chunk == 0 ) exit allOverlapChunks
        call DeleteChunk ( chunks, chunk )
      end do allOverlapChunks
d851 4
a854 3
      ! Forcibly zero out number of lower (upper) overlaps on 1st (last) chunks
      chunks(1)%noMAFsLowerOverlap = 0
      chunks(noChunks)%noMAFsUpperOverlap = 0
d858 1
d860 4
a863 6
!       call output ( 'Before dealing with obstructions', advance='yes' )
!       call Dump ( chunks )
!       call Dump ( obstructions )
      call DealWithObstructions ( chunks, obstructions )
!       call output ( 'After dealing with obstructions', advance='yes' )
!       call Dump ( chunks )
d865 7
a872 2
      if ( index(switches, 'chu') /= 0 ) &
        & call Dump ( chunks )
a1184 1
            print*,'Deleting chunk: ', deadChunk, size(chunks)
a1186 1
          print*,'Think most deleted, whats left?'
a1194 1
            print*,'Splitting chunk: ', chunk
a1221 1
            print*,'Moving end of chunk:', chunk
a1233 1
            print*,'Moving start of chunk:', chunk
d1272 2
a1273 2
              & ( chunks%firstMAFIndex <= maf ) .and. &
              & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap - 1 >= maf ) )
d1283 2
a1284 2
              & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap + 1 <= maf ) .and. &
              & ( chunks%lastMAFIndex >= maf ) )
a1396 2
      integer :: signal_end
      integer :: signal_start
a1435 2
            signal_start = mafset_start + 1 - mafRange(1)
            signal_end = mafset_end + 1 - mafRange(1)
d1577 18
d1631 1
a1631 1
              if ( obstructions(j)%mafs(1) <= obstructions(i)%mafs(2) ) then
d1647 1
a1647 1
                &  obstructions(j)%mafs(1) <= obstructions(i)%mafs(2) ) then
d1661 1
a1661 1
                exit MiddleLoop
d1689 2
a1690 3
    ! ---------------------------------------------------- share_non_ovmf -----
    subroutine share_non_ovmf ( chunks, mafRange )
      ! Sort the chunks into order of increasing firstMAFIndex
d1697 1
a1697 1
      
d1706 1
d1733 1
a1733 1
    end subroutine share_non_ovmf
d2073 3
@


2.43
log
@Commented out a print statement
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.42 2003/08/26 18:05:14 livesey Exp $"
a1440 1
        print*,'Doing signal:', signalIndex
d2073 3
@


2.42
log
@Various fixes to the obstruction stuff.  More to come probably.
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.41 2003/08/25 23:43:08 pwagner Exp $"
d1462 1
a1462 1
      call dump ( signals_buffer, 'signals_buffer' )
d2074 3
@


2.41
log
@Added ReduceChunkDatabase
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.40 2003/08/21 22:51:18 livesey Exp $"
d538 1
a538 1
      type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
d543 1
a543 1
                                                ! (see homeHuntLoop warning below)
a561 1
      integer :: Nonovlp_1st_MAF          ! Non-overlapped 1st MAF
d754 1
a754 1
          call output ( ' minV  ', advance='no' ) 
d756 3
a758 3
          call output ( ' maxV  ', advance='no' ) 
          call output ( maxV , advance='no' ) 
          call output ( ' homeV  ', advance='no' ) 
d760 1
a760 1
          call output ( ' NoChunks  ', advance='no' ) 
d762 1
a762 1
          call output ( ' noChunksBelowHome  ', advance='no' ) 
a763 1
          call output ( ' boundaries  ', advance='yes' ) 
d772 2
a773 2
       & chunks(2:noChunks)%firstMAFIndex = &
       & chunks(1:noChunks-1)%lastMAFIndex + 1
d778 1
a778 1
      end if                                                       
d799 10
a808 10
            call output ( 'config%overlap  ' )
            call output ( config%overlap, advance='yes')
            call output ( 'config%lowerOverlap  ' )
            call output ( config%lowerOverlap, advance='yes')
            call output ( 'config%upperOverlap  ' )
            call output ( config%upperOverlap, advance='yes')
            call output ( 'new 1st MAF  ' )
            call output ( chunks(1:two)%firstMAFIndex - nint(config%overlap) )
            call output ( '   new last MAF  ' )
            call output ( chunks(1:two)%lastMAFIndex + nint(config%overlap) , advance='yes')
d831 1
a831 1
          & config%lowerOverlap , 'fields+lowerOverlap' )
d834 1
a834 1
          & config%upperOverlap , 'fields-upperOverlap' )
d846 4
a849 4
          call dump ( newFirstMAFs , 'newFirstMAFs' ) 
          call dump ( newLastMAFs , 'newLastMAFs' ) 
          call dump ( chunks%noMAFsLowerOverlap , 'chunks%noMAFsLowerOverlap' ) 
          call dump ( chunks%noMAFsUpperOverlap , 'chunks%noMAFsUpperOverlap' ) 
d856 13
a868 8
       allOverlapChunks: do
         chunk = FindFirst ( &
           & ( chunks%noMAFsLowerOverlap + chunks%noMAFsUpperOverlap ) >= &
           & ( chunks%lastMAFIndex - chunks%firstMAFIndex + 1 ) &
           & .or. (chunks%noMAFsUpperOverlap < 0) )
         if ( chunk == 0 ) exit allOverlapChunks
         call DeleteChunk ( chunks, chunk )
       end do allOverlapChunks
d872 3
d876 3
a878 3
       ! Forcibly zero out number of lower (upper) overlaps on 1st (last) chunks
       chunks(1)%noMAFsLowerOverlap = 0
       chunks(size(chunks))%noMAFsUpperOverlap = 0
d880 2
a881 40
      if ( index(switches, 'chu') /= 0 ) then
        call output ( ' Is maxLength PHYQ_MAFs?  ', advance='no' ) 
        call output ( config%maxLengthFamily == PHYQ_MAFs, advance='yes' ) 
        call output ( ' Is maxLength PHYQ_Angle?  ', advance='no' ) 
        call output ( config%maxLengthFamily == PHYQ_Angle, advance='yes' ) 
        call output ( ' Is maxLength PHYQ_Time?  ', advance='no' ) 
        call output ( config%maxLengthFamily == PHYQ_Time, advance='yes' ) 
        call output ( ' Is overlapFamily PHYQ_MAFs?  ', advance='no' ) 
        call output ( config%overlapFamily == PHYQ_MAFs, advance='yes' ) 
        call output ( ' Geod tpAngles of chunk 1st MAF ' ) 
        call output ( '   (its non-overlapped 1st MAF) ' ) 
        call output ( '   of its last MAF ' ) 
        call output ( '   (its non-overlapped last MAF) ', advance='yes' ) 
        do chunk=1, min(noChunks, 200)
          if ( chunks(chunk)%firstMAFIndex < 0 ) then
            call output ( 'chunks(' )
            call output ( chunk )
            call output ( ') is ' )
            call output ( chunks(chunk)%firstMAFIndex )
          else
            call output ( tpGeodAngle%DpField(1,1,chunks(chunk)%firstMAFIndex+1) &
              & - orbit*360.0 )
            call output ( ' (', advance='no' )
            Nonovlp_1st_MAF = &
              & chunks(chunk)%noMAFsLowerOverlap+chunks(chunk)%firstMAFIndex+1
            call output ( tpGeodAngle%DpField(1,1,Nonovlp_1st_MAF) &
              & - orbit*360.0)
            call output ( ' )   ' )
            call output ( tpGeodAngle%DpField(1,1,chunks(chunk)%lastMAFIndex+1) &
              & - orbit*360.0 )
            call output ( ' (', advance='no' )
            Nonovlp_1st_MAF = &
              & -chunks(chunk)%noMAFsUpperOverlap+chunks(chunk)%lastMAFIndex+1
            call output ( tpGeodAngle%DpField(1,1,Nonovlp_1st_MAF) &
              & - orbit*360.0)
            call output ( ' )', advance='yes' )
          endif
         enddo
        call output ( ' ', advance='yes' )    
      endif
d1122 1
a1122 1
    subroutine ConvertFlagsToObstructions ( valid, mafRange, obstructions )
a1125 1
      integer, dimension(:), intent(in) :: MAFRANGE
d1127 1
d1130 3
a1132 2
      integer :: MAF                      ! Loop counter
      logical :: LASTONEVALID             ! Flag
d1137 3
d1146 1
a1146 1
            newObstruction%mafs(1) = maf + mafRange(1) - 1
d1148 1
a1148 1
            newObstruction%mafs(2) = maf + mafRange(1) - 2
d1157 1
a1157 1
        newObstruction%mafs(2) = mafRange(2)
d1194 1
d1197 1
d1201 1
d1206 1
d1224 4
a1227 1
          ! chunks, just modifying existing ones
d1229 6
a1234 2
          chunk = FindFirst ( chunks%lastMAFIndex >= firstMAF )
          if ( chunk /= 0 ) then
d1239 2
a1240 1
          end if
d1242 6
a1247 2
          chunk = FindFirst ( chunks%firstMAFIndex <= lastMAF )
          if ( chunk /= 0 ) then
d1252 1
a1252 1
          end if
d1259 1
d1284 5
a1288 4
          chunk = FindFirst ( &
            & ( chunks%firstMAFIndex <= maf ) .and. &
            & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap - 1 >= maf ) )
          if ( chunk /= 0 ) then
d1293 1
a1293 1
          end if
d1295 5
a1299 4
          chunk = FindFirst ( &
            & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap + 1 <= maf ) .and. &
            & ( chunks%lastMAFIndex >= maf ) )
          if ( chunk /= 0 ) then
d1301 2
a1302 2
            & max ( chunks(chunk)%noMAFsUpperOverlap - &
            & ( chunks(chunk)%lastMAFIndex - (maf-1) ), 0 )
d1304 3
a1306 2
          end if
        end if                            ! Wall obstructions
d1368 2
a1369 2
    ! ----------------------------------------- notel1brad_changes -----
    subroutine notel1brad_changes ( obstructions, mafRange, l1bInfo )
d1395 4
a1398 4
      logical, dimension(size(SIGNALS)) :: good_after_maxgap
      logical, dimension(size(SIGNALS)) :: good_signals_now
      logical, dimension(size(SIGNALS)) :: good_signals_last
      integer, dimension(size(SIGNALS)) :: howlong_nogood
d1410 1
a1410 1
      integer :: Signal_index
a1430 1
      ! A wrinkle: only check center-band signals
d1433 1
a1433 1
        & signals_buffer, mafRange(2) - mafRange(1) + 1 , size(SIGNALS), &
d1440 20
a1459 21
      do Signal_index=1, size(SIGNALS)
        if ( signals(signal_index)%sideband == 0 ) then
          if ( mafRange(2) - mafRange(1) + 1 <= MAXMAFSINSET ) then
            good_signals_now(Signal_index) = &
              & any_good_signaldata ( Signal_index, signals(signal_index)%sideband, &
              &   l1bInfo, mafRange(1), mafRange(2), &
              &   signals_buffer(:,Signal_index), mafRange )
          else
            nmafsets = (mafRange(2) - mafRange(1))/MAXMAFSINSET + 1
            mafset_end = mafRange(1) - 1   ! A trick--mafset_start is mafRange(1)
            do mafset=1, nmafsets
              mafset_start = mafset_end + 1
              mafset_end = MIN(mafRange(2), mafset_end + MAXMAFSINSET)
              signal_start = mafset_start + 1 - mafRange(1)
              signal_end = mafset_end + 1 - mafRange(1)
              good_signals_now(Signal_index) = &
                & any_good_signaldata ( Signal_index, signals(signal_index)%sideband, &
                &   l1bInfo, mafset_start, mafset_end, &
                &   signals_buffer(:,Signal_index), mafRange )
            enddo
          endif
d1462 1
d1475 6
a1480 6
        do Signal_index=1, size(SIGNALS)
          good_signals_now(Signal_index) = signals_buffer(maf_index, Signal_index)
          if ( .not. good_signals_now(Signal_index) ) &
            & howlong_nogood(Signal_index) = howlong_nogood(Signal_index) + 1
          good_after_maxgap(Signal_index) = &
            & good_signals_now(Signal_index) &
d1482 2
a1483 2
            & ( howlong_nogood(Signal_index) > config%maxGap )
          if ( good_signals_now(Signal_index) ) howlong_nogood(Signal_index) = 0
d1557 1
a1557 1
                Signal_index = Signal_Indices(i)
d1559 1
a1559 1
                  & this_maf_valid .or. signals_buffer(maf_index, Signal_index)
d1569 1
a1569 2
        call ConvertFlagsToObstructions &
          & ( valids_buffer, mafRange, obstructions )
d1579 1
a1579 1
          newObstruction%mafs(2) = 0    ! For overzelous Lahey uninitlized checking
d1586 1
a1586 1
          newObstruction%mafs(2) = 0    ! For overzelous Lahey uninitlized checking
d1594 1
a1594 1
    end subroutine notel1brad_changes
d1748 2
a1749 1
        toSwap = minloc ( chunks(i:)%firstMAFIndex ) + (/ i-1 /)
a1829 5
      if ( index(switches, 'chu') /= 0 ) then
          call output ( ' shape(MAFStartTimeTAI)  ', advance='no' ) 
          call output ( shape(taiTime%dpField) , advance='yes' ) 
          call dump ( taiTime%dpField(1,1,:) , 'MAFStartTimeTAI' )
      end if
d1841 1
a1841 1
      mafRange = min ( noMAFsRead, max ( 0, mafRange - 1 ) )          ! Index from zero
a1849 3
      ! At this point we'd look through the L1B data for data gaps.
      ! I want to defer this for now until I've reached agreement with VSP, RFJ
      ! and RRL on how L1 would report these. NJL
d1851 1
a1851 1
      ! Now look through the L1B data first look for scan problems
d1888 1
a1888 1
        call ConvertFlagsToObstructions ( valid, mafRange, obstructions )
d1892 1
a1892 2
      ! Here we look at radiances and switch changes.  For the
      ! moment I'm letting paw code this (not tested yet). NJL.
d1894 1
a1894 1
        call notel1brad_changes ( obstructions, mafRange, l1bInfo ) 
d2058 1
a2058 1
          & all (my_l1bData%DpField(:,:, the_maf+1-maf) < 0._rk)
d2074 3
@


2.40
log
@Removed yet more print statements!
@
text
@d21 1
d28 1
a28 1
  public :: DestroyChunkDatabase, ChunkDivide
d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.39 2003/08/21 22:49:22 livesey Exp $"
d119 31
d2092 3
@


2.39
log
@Removed more print statements etc.
@
text
@d31 1
a31 1
    "$Id: ChunkDivide_m.f90,v 2.38 2003/08/15 23:58:20 vsnyder Exp $"
a1439 1
      call dump ( signals_buffer, 'signals_buffer' )
a1552 1
      print*,anyChangeIsObstruction, num_goodness_changes,num_goods_after_gap
a1880 1
      call Dump ( obstructions )
d2060 3
@


2.38
log
@Get PHYQ_... directly from Intrinsic instead of indirectly via Units
@
text
@d31 1
a31 1
    "$Id: ChunkDivide_m.f90,v 2.37 2003/06/20 19:38:25 pwagner Exp $"
d1346 5
a1350 5
    use MLSSignals_m, only:GetModuleFromRadiometer, GetModuleFromSignal, &
      & GetRadiometerFromSignal, GetSignal, GetSignalName, &
      & Signal_T, SIGNALS, MODULES
    use MLSStrings, only: NumStringElements, GetStringElement
    use Parse_signal_m, only: Parse_signal
d1354 1
a1354 1
      type(Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
d1369 2
a1370 2
      integer, dimension(size(SIGNALS)) :: goods_after_gap
      integer, dimension(size(SIGNALS)) :: goodness_changes
a1385 1
      type(Signal_T) :: Signal
d1408 1
a1408 1
      nullify ( signals_buffer )
d1412 4
d1418 1
a1418 1
        if ( Signal%sideband == 0 ) then
d1421 3
a1423 3
              & any_good_signaldata ( Signal_index, Signal%sideband, &
              & l1bInfo, mafRange(1), mafRange(2), &
              & signals_buffer(:,Signal_index), mafRange )
d1433 3
a1435 3
              & any_good_signaldata ( Signal_index, Signal%sideband, &
              & l1bInfo, mafset_start, mafset_end, &
              & signals_buffer(:,Signal_index), mafRange )
d1440 1
d1449 1
a1453 4
          Signal = SIGNALS(Signal_index)
          ! good_signals_now(Signal_index) = &
          !   & any_good_signaldata ( Signal_index, Signal%sideband, &
          !  & l1bInfo, maf )
d1552 1
a1552 1

d1554 1
d1559 1
d1566 1
d1572 2
d1883 1
d1974 1
a1974 1
      & FindL1BData, AssembleL1BQtyName, PRECISIONSUFFIX
d1989 1
a1989 1
  ! Private                                                   range in MAFs
d1998 1
a1998 1
  ! Executable
a1999 1
    if ( .not. associated(l1bInfo%l1bRadIDs) ) return
d2002 15
a2016 1
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
d2021 1
a2021 1
    & sideband=sideband, noChannels=.TRUE. )                     
d2025 1
d2030 2
d2035 1
d2038 5
a2042 5
    elseif ( present(good_buffer) ) then
      if ( .not. present(mafrange) ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'mafRange must be supplied to any_good_signaldata' )
      endif
d2048 1
a2048 2
      enddo
      call deallocate_test(my_l1bData%DpField, trim(nameString), ModuleName)
a2050 1
      call deallocate_test(my_l1bData%DpField, trim(nameString), ModuleName)
d2052 2
d2063 3
@


2.37
log
@Allows direct writing of output products
@
text
@d9 1
a9 1
  use Intrinsic, only: L_NONE
a10 1
  use Units, only: PHYQ_INVALID
d31 1
a31 1
    "$Id: ChunkDivide_m.f90,v 2.36 2003/06/09 22:55:23 pwagner Exp $"
d131 2
a132 1
    use Intrinsic, only: L_NONE, FIELD_INDICES, LIT_INDICES
a153 2
    use Units, only: PHYQ_INVALID, PHYQ_LENGTH, PHYQ_MAFS, PHYQ_TIME, &
      & PHYQ_ANGLE, PHYQ_LENGTH, PHYQ_DIMENSIONLESS
d2039 3
@


2.36
log
@Improved criticalSignals; some bug fixes
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.35 2003/06/05 23:37:14 pwagner Exp $"
d99 1
a99 1

d104 2
a105 1
    integer :: STATUS ! From deallocate
d107 7
d170 1
a208 1

d253 5
a258 1

a362 1
        chunks(i)%accumulatedMAFs = chunks(i)%firstMAFIndex
a495 1
      chunks(1)%accumulatedMAFs = chunks(1)%firstMAFIndex
a839 1
      chunks%accumulatedMAFs = chunks%firstMAFIndex
d2041 3
@


2.35
log
@1st version of criticalSignals in Chunk Divide Orbital
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.34 2003/05/17 00:06:06 pwagner Exp $"
d60 2
a61 1
    character(len=160) :: criticalSignals = '' ! Which signals must be on
d88 1
d172 1
d226 6
d918 2
d921 1
d999 11
a1009 3
          sub_rosa_index = sub_rosa(gson)
          call get_string ( sub_rosa_index, config%criticalSignals, &
            & strip=.true. )
d1361 1
d1369 2
a1370 1
      integer :: maf
d1378 1
d1413 1
a1413 1
              & signals_buffer(:,Signal_index) )
d1425 1
a1425 1
              & signals_buffer(:,Signal_index) )
d1440 1
d1446 1
a1446 1
          good_signals_now(Signal_index) = signals_buffer(maf+1, Signal_index)
d1470 2
a1471 1
      if (config%criticalSignals /= '' ) then
d1476 4
d1481 1
a1481 1
        if ( index(switches, 'chu') /= 0 ) then    
d1483 4
a1486 1
          call output ( trim(config%criticalSignals), advance='yes')
d1488 2
a1489 2
            & 'Which signals match the incomplete signal string weve been given', &
            &  advance='yes')
d1491 42
a1532 22
        do critical_index=1, NumStringElements(trim(config%criticalSignals), &
          & .FALSE.)
          call GetStringElement( trim(config%criticalSignals), signal_str, &
            & critical_index, .FALSE. )
          ! Which signals match the incomplete signal string we've been given?
          nullify(Signal_Indices)
          call Parse_signal(signal_str, signal_indices)
          if ( .not. associated(Signal_Indices) ) exit
          if ( index(switches, 'chu') /= 0 ) then    
            call output ( 'Signal_Indices: ')
            call output ( Signal_Indices, advance='yes')
            do i=1, size(Signal_Indices)
              call GetSignalName(Signal_Indices(i), signal_full)
              call output ( 'Full Signal Name: ')
              call output ( trim(signal_full), advance='yes')
            enddo
          endif
          do maf = mafRange(1), mafRange(2)
            this_maf_valid = .false.   ! not valid unless at least one signal
            do i=1, size(Signal_Indices)
              Signal_index = Signal_Indices(i)
              this_maf_valid = this_maf_valid .or. signals_buffer(maf+1, Signal_index)
d1534 1
a1534 1
            valids_buffer(maf+1) = valids_buffer(maf+1) .and. this_maf_valid
d1536 2
a1537 1
          call deallocate_test(Signal_Indices, 'Signal_Indices', ModuleName)
d1539 2
a1540 1
        call ConvertFlagsToObstructions ( valids_buffer, mafRange, obstructions )
d1542 1
d1880 27
d1945 1
a1945 1
    & good_buffer )  &
d1967 6
a1972 6
    integer, intent(in) :: signal
    integer, intent(in) :: sideband
    logical             :: answer
    integer, intent(in) :: maf
    type (l1bInfo_T), intent(in) :: L1bInfo
    integer, optional, intent(in) :: maf2
d1974 2
a1975 1
  ! Private
d1982 1
d2008 4
d2014 2
a2015 1
        good_buffer(the_maf+1) = .not. &
d2032 3
@


2.34
log
@Wont check sidebands for missing radiances
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.33 2003/05/09 16:43:05 pwagner Exp $"
d60 1
d117 2
a118 2
      & F_MAXLENGTH, F_NOCHUNKS, &
      & F_METHOD, F_HOMEMODULE, F_CRITICALMODULES, F_HOMEGEODANGLE, &
d142 1
a142 1
    use Tree, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, SUBTREE
d911 1
d986 4
a993 1
          ! print *, 'Hey-trying new skipL1BCheck flag'
a994 1
          ! print *, 'You tried to set it to: ', config%skipL1BCheck
d1320 4
a1323 1
      & GetRadiometerFromSignal, GetSignal, Signal_T, SIGNALS, MODULES
d1340 1
a1340 2
      integer :: Signal_index
      type(Signal_T) :: Signal
a1342 1
      integer, dimension(size(SIGNALS)) :: howlong_nogood
d1346 2
a1347 1
      logical, dimension(:,:), pointer  :: signals_buffer
d1350 4
d1356 10
d1386 19
a1404 4
          good_signals_now(Signal_index) = &
            & any_good_signaldata ( Signal_index, Signal%sideband, &
            & l1bInfo, mafRange(1), mafRange(2), &
            & signals_buffer(:,Signal_index) )
d1444 46
d1927 1
a1927 1
          & all (my_l1bData%DpField(:,:, the_maf+1) < 0._rk)
d1929 1
d1943 3
@


2.33
log
@Speedup of L1B radiance check
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.32 2003/05/07 23:43:05 pwagner Exp $"
d1357 2
d1363 1
d1365 3
a1367 2
        good_signals_now(Signal_index) = &
           & any_good_signaldata ( Signal_index, Signal%sideband, &
d1370 1
d1861 3
@


2.32
log
@Optionally may skipL1BCheck
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.31 2003/04/30 22:06:04 pwagner Exp $"
d1341 1
d1354 14
d1379 4
a1382 3
          good_signals_now(Signal_index) = &
            & any_good_signaldata ( Signal_index, Signal%sideband, &
            & l1bInfo, maf )
d1419 1
d1776 2
a1777 1
  function ANY_GOOD_SIGNALDATA ( signal, sideband, l1bInfo, maf )  &
d1779 1
d1784 4
d1804 2
d1811 2
d1817 2
d1833 1
a1833 1
      & firstMAF=maf, lastMAF=maf, &
d1835 9
a1843 1
    if ( flag == 0 ) then
a1845 2
    else
      answer = .false.
d1856 3
@


2.31
log
@Shouldnt check for good signals if there arent any
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.30 2003/04/28 23:07:00 pwagner Exp $"
d62 1
d118 1
a118 1
      & F_SCANLOWERLIMIT, F_SCANUPPERLIMIT, F_NOSLAVES, &
d135 1
a135 1
    use MoreTree, only: GET_FIELD_ID, GET_SPEC_ID
a363 1
      integer :: CHUNK                    ! Loop counter
a374 1
      integer :: OVERLAPS                 ! Overlaps as integer (MAFs)
a376 3
      integer, dimension(:), pointer :: NEWFIRSTMAFS ! For thinking about overlaps
      integer, dimension(:), pointer :: NEWLASTMAFS ! For thinking about overlaps

a379 1
      real(r8) :: MAXV                    ! Either minTime or minAngle
a381 1
      real(r8) :: MINV                    ! Either minTime or minAngle
a382 1
      real(r8) :: HOMEV                   ! Value of angle/time at home
a512 1
      integer :: OVERLAPS                 ! Overlaps as integer (MAFs)
d905 1
d938 3
d987 7
d1710 2
a1711 1
      call notel1brad_changes ( obstructions, mafRange, l1bInfo ) 
d1821 3
@


2.30
log
@Fleshed out notel1brad_changes; not yet tested where needed
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.29 2003/01/06 20:13:09 livesey Exp $"
d1342 2
d1784 2
d1817 3
@


2.29
log
@New split upper/lower overlaps
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.28 2002/12/11 22:17:05 pwagner Exp $"
d1311 6
a1316 4
    subroutine notel1brad_changes ( obstructions )
      ! This routine merges overlapping range obstructions and deletes
      ! wall obstructions inside ranges.  The job is made easier
      ! by sorting the obstructions into order
d1318 3
d1323 19
d1347 51
d1703 3
a1705 3
      ! Here we'll eventually look at radiances and switch changes.  For the
      ! moment I'm deferring this one too. NJL.
      call notel1brad_changes ( obstructions ) 
d1707 1
a1707 1
      ! Sort the obstructions into order and prune them of repeats, overlaps etc.
d1752 54
d1813 3
@


2.28
log
@Added error checks on hdf version
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.27 2002/12/06 01:08:33 pwagner Exp $"
d47 2
d50 2
d114 2
a115 1
    use Init_Tables_Module, only: F_OVERLAP, F_MAXLENGTH, F_NOCHUNKS, &
d318 2
a319 1
      integer :: OVERLAP                  ! nint(config%overlap)
d328 3
a330 2
      overlap = nint ( config%overlap )
      noNonOverlap = maxLength - 2 * overlap
d332 3
a334 3
        chunks(i)%firstMAFIndex = max ( (i-1)*maxLength - overlap, 0 )
        chunks(i)%lastMAFIndex = i*maxLength + overlap - 1
        chunks(i)%noMAFsUpperOverlap = overlap
d336 1
a336 1
          chunks(i)%noMAFsLowerOverlap = overlap
a744 1

d750 5
a754 2
      if ( config%overlapFamily == PHYQ_MAFs ) then
        newFirstMAFs = max(chunks%firstMAFIndex - nint(config%overlap), &
d756 1
a756 1
        newLastMAFs = min(chunks%lastMAFIndex + nint(config%overlap), &
d760 5
a764 1
            call output ( config%overlap , advance='yes')
d786 1
a786 1
          & config%overlap, newFirstMAFs, allowTopValue=.true. )
d788 1
a788 1
          & config%overlap, newLastMAFs, allowTopValue=.true. )
d790 3
d794 1
a794 4
          & config%overlap , 'fields-overlap' )
          call dump ( field(newFirstMAFs) , 'hunted values' )
          call dump ( field(chunks%firstMAFIndex-1) + &
          & config%overlap , 'fields+overlap' )
d958 6
d1011 21
d1067 4
a1070 2
        if (all(config%overlapFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
          & call AnnounceError ( root, badUnits, f_overlap )
d1074 4
a1077 2
        if ( config%overlapFamily /= PHYQ_MAFs ) &
          & call AnnounceError ( root, badUnits, f_overlap )
d1684 3
@


2.27
log
@Less likely to bomb on single chunks
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.26 2002/11/13 01:03:11 pwagner Exp $"
d392 2
a393 1
      call get_string ( lit_indices(config%homeModule), modNameStr, strip=.true. )
d398 3
d404 3
a406 2
      tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', l1b_hdf_version, &
        .false. )
d543 3
d549 3
a551 2
      tp_angle = AssembleL1BQtyName ( trim(modNameStr)//'.tpGeodAngle', l1b_hdf_version, &
        .false. )
d1503 3
d1640 3
@


2.26
log
@Actually reads hdf5 radiances
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.25 2002/11/06 00:21:16 pwagner Exp $"
d221 7
d510 1
d678 1
d715 3
a717 1
      chunks(2:noChunks)%firstMAFIndex = chunks(1:noChunks-1)%lastMAFIndex + 1
d744 1
a744 1
            call output ( chunks(1:2)%firstMAFIndex - nint(config%overlap) )
d746 1
a746 1
            call output ( chunks(1:2)%lastMAFIndex + nint(config%overlap) , advance='yes')
d1502 5
d1520 7
a1526 1

d1628 3
@


2.25
log
@Fixed non-zero starttime prob; some extra checks, printing
@
text
@d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.24 2002/10/07 23:49:49 pwagner Exp $"
a106 1
    use EXPR_M, only: EXPR
d109 6
a114 2
    use MLSCommon, only: R8, RP, L1BINFO_T, MLSCHUNK_T, TAI93_Range_T, FINDFIRST
    use MLSNumerics, only: Hunt
d116 2
a117 1
    use Tree, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, SUBTREE
d119 6
a124 8
    use Tree_types, only: N_EQUAL, N_NAMED
    use Init_Tables_Module, only: F_OVERLAP, F_MAXLENGTH, F_NOCHUNKS, &
      & F_METHOD, F_HOMEMODULE, F_CRITICALMODULES, F_HOMEGEODANGLE, F_SCANLOWERLIMIT, &
      & F_SCANUPPERLIMIT, F_NOSLAVES, FIELD_FIRST, FIELD_LAST, L_EVEN, &
      & L_FIXED, F_MAXGAP, L_ORBITAL, L_PE, S_CHUNKDIVIDE, L_BOTH, L_EITHER
    use L1BData, only: DEALLOCATEL1BDATA, L1BDATA_T, NAME_LEN, READL1BDATA
    use Units, only: PHYQ_INVALID, PHYQ_LENGTH, PHYQ_MAFS, PHYQ_TIME, PHYQ_ANGLE, &
      & PHYQ_LENGTH, PHYQ_DIMENSIONLESS
d127 1
a129 1
    use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
d135 4
d379 2
d382 1
a382 1
      ! Exectuable code
d386 13
a398 4
      call ReadL1BData ( l1bInfo%l1bOAId, trim(modNameStr)//'.tpGeodAngle', &
        & tpGeodAngle, noMAFsRead, flag )
      call ReadL1BData ( l1bInfo%l1bOAId, 'MAFStartTimeTAI', &
        & taiTime, noMAFsRead, flag )
d520 3
a522 1
      ! Exectuable code
d526 13
a538 4
      call ReadL1BData ( l1bInfo%l1bOAId, trim(modNameStr)//'.tpGeodAngle', &
        & tpGeodAngle, noMAFsRead, flag )
      call ReadL1BData ( l1bInfo%l1bOAId, 'MAFStartTimeTAI', &
        & taiTime, noMAFsRead, flag )
d1475 2
d1479 9
d1489 2
a1490 1
      call ReadL1BData ( l1bInfo%l1boaId, 'MAFStartTimeTAI', taiTime, noMAFsRead, flag )
d1520 2
d1526 2
a1527 2
            call ReadL1BData ( l1bInfo%l1boaID, trim(modNameStr)//'.tpGeodAlt', &
              & tpGeodAlt, noMAFsRead, flag )
d1606 3
@


2.24
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 1
a1 1
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d16 12
d32 1
a32 1
    "$Id: ChunkDivide_m.f90,v 2.23 2002/10/07 18:00:10 livesey Exp $"
d82 4
d158 1
a158 1
    if ( toggle(gen) ) call trace_begin ( "ScanDivide", root )
d169 2
a170 2
    if ( config%method /= l_fixed ) &
      & call SurveyL1BData ( processingRange, l1bInfo, config, mafRange,&
d172 12
d205 1
d210 5
d216 1
a216 1
    if ( toggle(gen) ) call trace_end ( "ScanDivide" )
d464 1
a464 1

d483 1
d531 21
d573 13
d659 15
d679 5
a683 1
      chunks(1)%firstMAFIndex = 1
d686 4
a689 2
      chunks%firstMAFIndex = chunks%firstMAFIndex + mafRange(1) - 1
      chunks%lastMAFIndex = chunks%lastMAFIndex + mafRange(1) - 1 
d697 12
a708 2
        newFirstMAFs = max(chunks%firstMAFIndex - nint(config%overlap), mafRange(1) )
        newLastMAFs = min(chunks%lastMAFIndex + nint(config%overlap), mafRange(2) )
d728 9
a736 1
        ! Correct this to be real MAF indicies (starting from zero)
d744 6
d754 9
a762 8
      allOverlapChunks: do
        chunk = FindFirst ( &
          & ( chunks%noMAFsLowerOverlap + chunks%noMAFsUpperOverlap ) >= &
          & ( chunks%lastMAFIndex - chunks%firstMAFIndex + 1 ) )
        if ( chunk == 0 ) exit allOverlapChunks
        call DeleteChunk ( chunks, chunk )
      end do allOverlapChunks

d767 45
a811 1

d1218 16
a1233 1
    ! ----------------------------------------- Prune Obstructions -----
d1322 1
a1322 1
      call output ( 'Timing for ScanDivide = ' )
d1327 46
d1510 1
d1564 3
@


2.23
log
@Added call to trace_end, whoops!
@
text
@d20 1
a20 1
    "$Id: ChunkDivide_m.f90,v 2.22 2002/08/22 01:23:52 vsnyder Exp $"
d24 1
d1336 4
d1343 3
@


2.22
log
@Move USE statements from module scope to procedure scope
@
text
@d20 1
a20 1
    "$Id: ChunkDivide_m.f90,v 2.21 2002/08/04 15:59:45 mjf Exp $"
d181 2
d1338 3
@


2.21
log
@New method "PE" for a single chunk centred on (or near) a given phi.
@
text
@a5 28
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use EXPR_M, only: EXPR
  use Dumper, only: DUMP
  use Dump_0, only: DUMP
  use MLSCommon, only: R8, RP, L1BINFO_T, MLSCHUNK_T, TAI93_Range_T, FINDFIRST
  use MLSNumerics, only: Hunt
  use Intrinsic, only: L_NONE, FIELD_INDICES, LIT_INDICES
  use Tree, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, SUBTREE
  use Lexer_core, only: PRINT_SOURCE
  use Tree_types, only: N_EQUAL, N_NAMED
  use Init_Tables_Module, only: F_OVERLAP, F_MAXLENGTH, F_NOCHUNKS, &
    & F_METHOD, F_HOMEMODULE, F_CRITICALMODULES, F_HOMEGEODANGLE, F_SCANLOWERLIMIT, &
    & F_SCANUPPERLIMIT, F_NOSLAVES, FIELD_FIRST, FIELD_LAST, L_EVEN, &
    & L_FIXED, F_MAXGAP, L_ORBITAL, L_PE, S_CHUNKDIVIDE, L_BOTH, L_EITHER
  use L1BData, only: DEALLOCATEL1BDATA, L1BDATA_T, NAME_LEN, READL1BDATA
  use Units, only: PHYQ_INVALID, PHYQ_LENGTH, PHYQ_MAFS, PHYQ_TIME, PHYQ_ANGLE, &
    & PHYQ_LENGTH, PHYQ_DIMENSIONLESS
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, &
    & MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, MLSMSG_WARNING
  use MLSSignals_m, only: MODULES, ISMODULESPACECRAFT
  use MoreTree, only: GET_FIELD_ID, GET_SPEC_ID
  use MLSL2Timings, only: SECTION_TIMES, TOTAL_TIMES
  use Output_M, only: BLANKS, OUTPUT
  use String_table, only: GET_STRING, DISPLAY_STRING
  use Time_M, only: Time_Now
  use TOGGLES, only: GEN, TOGGLE, SWITCHES
  use TRACE_M, only: TRACE_BEGIN, TRACE_END

d9 4
d20 1
a20 1
    "$Id: ChunkDivide_m.f90,v 2.20 2002/05/24 20:57:34 livesey Exp $"
d46 1
a65 3
  logical :: Timing
  real :: T1

d70 1
a70 1
contains ! =================================== Public Procedures==============
d72 1
a72 1
  !------------------------------------------  DestroyChunkDatabase  -----
d74 4
d86 1
a86 1
  ! ----------------------------------------  Chunk Divide --------------
d88 29
d128 11
d183 3
a185 1
  end subroutine ChunkDivide
d187 2
a188 1
  ! ============================== Private Procedures ====================
d190 3
a192 2
  !---------------------------------------- Add obstruction to database --
  subroutine AddObstructionToDatabase ( database, item )
d194 2
a195 3
    ! Dummy arguments
    type (Obstruction_T), dimension(:), pointer :: DATABASE
    type (Obstruction_T), intent(in) :: ITEM
d197 1
a197 2
    ! Local variables
    type (Obstruction_T), dimension(:), pointer :: TEMPDATABASE
d199 1
a199 1
    include "addItemToDatabase.f9h"
d201 2
a202 1
  end subroutine AddObstructionToDatabase
d204 3
a206 2
  !---------------------------------------- Add chunk to database --
  subroutine AddChunkToDatabase ( database, item )
d208 2
a209 3
    ! Dummy arguments
    type (MLSChunk_T), dimension(:), pointer :: DATABASE
    type (MLSChunk_T), intent(in) :: ITEM
d211 1
a211 2
    ! Local variables
    type (MLSChunk_T), dimension(:), pointer :: TEMPDATABASE
d213 1
a213 1
    include "addItemToDatabase.f9h"
d215 3
a217 1
  end subroutine AddChunkToDatabase
d219 18
a236 8
  !----------------------------------------- ChunkDivide_Even --------
  subroutine ChunkDivide_Even ( config, mafRange, l1bInfo, &
    & obstructions, chunks )
    type (ChunkDivideConfig_T), intent(in) :: CONFIG
    integer, dimension(2), intent(in) :: MAFRANGE
    type (L1BInfo_T), intent(in) :: L1BINFO
    type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS
d238 8
a245 11
    ! Local variables
    
    ! Exectuable code
    call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "I'm sorry, we haven't written the code for even chunk divides yet" )
  end subroutine ChunkDivide_Even

  !----------------------------------------- ChunkDivide_Even --------
  subroutine ChunkDivide_Fixed ( config, chunks )
    type (ChunkDivideConfig_T), intent(in) :: CONFIG
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS
d247 1
a247 26
    ! Local variables
    integer :: I                        ! Loop inductor
    integer :: STATUS                   ! From allocate
    integer :: MAXLENGTH                ! nint(config%maxLength)
    integer :: OVERLAP                  ! nint(config%overlap)
    integer :: NONONOVERLAP             ! maxLength-2*overlap
    
    ! Exectuable code
    allocate ( chunks(config%noChunks), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'chunks' )

    maxLength = nint ( config%maxLength )
    overlap = nint ( config%overlap )
    noNonOverlap = maxLength - 2 * overlap
    do i = 1, config%noChunks
      chunks(i)%firstMAFIndex = max ( (i-1)*maxLength - overlap, 0 )
      chunks(i)%lastMAFIndex = i*maxLength + overlap - 1
      chunks(i)%noMAFsUpperOverlap = overlap
      if ( i > 1 ) then
        chunks(i)%noMAFsLowerOverlap = overlap
      else
        chunks(i)%noMAFsLowerOverlap = 0
      end if
      chunks(i)%accumulatedMAFs = chunks(i)%firstMAFIndex
    end do
d249 4
a252 1
  end subroutine ChunkDivide_Fixed
d254 11
a264 8
  !----------------------------------------- ChunkDivide_PE --------
  subroutine ChunkDivide_PE ( config, mafRange, l1bInfo, &
    & obstructions, chunks )
    type (ChunkDivideConfig_T), intent(in) :: CONFIG
    integer, dimension(2), intent(in) :: MAFRANGE
    type (L1BInfo_T), intent(in) :: L1BINFO
    type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS
d266 4
a269 2
    ! Local parameters
    real(r8), parameter :: HOMEACCURACY = 3.0 ! Try to hit homeGeodAngle within this
d271 14
a284 3
    ! Local variables
    type (L1BData_T) :: TAITIME         ! From L1BOA
    type (L1BData_T) :: TPGEODANGLE     ! From L1BOA
d286 1
a286 1
    character(len=10) :: MODNAMESTR     ! Home module name as string
d288 75
a362 71
    integer :: CHUNK                    ! Loop counter
    integer :: FLAG                     ! From ReadL1B
    integer :: HOMEMAF                  ! first MAF after homeGeodAngle
    integer :: HOME                     ! Index of home MAF in array
    integer :: M1, M2                   ! MafRange + 1
    integer :: NOCHUNKSBELOWHOME        ! Used for placing chunks
    integer :: NOMAFSATORABOVEHOME      ! Fairly self descriptive
    integer :: NOMAFS                   ! Number of MAFs to consider
    integer :: NOMAFSREAD               ! From ReadL1B
    integer :: ORBIT                    ! Used to locate homeMAF
    integer :: STATUS                   ! From allocate etc.
    integer :: NOCHUNKS                 ! Number of chunks
    integer :: OVERLAPS                 ! Overlaps as integer (MAFs)
    integer :: MAXLENGTH                ! Max length as integer (MAFs)

    integer, dimension(:), pointer :: NEWFIRSTMAFS ! For thinking about overlaps
    integer, dimension(:), pointer :: NEWLASTMAFS ! For thinking about overlaps

    real(r8) :: ANGLEINCREMENT          ! Increment in hunt for homeMAF
    real(r8) :: MAXANGLE                ! Of range in data
    real(r8) :: MAXTIME                 ! Time range in data
    real(r8) :: MAXV                    ! Either minTime or minAngle
    real(r8) :: MINANGLE                ! Of range in data
    real(r8) :: MINTIME                 ! Time range in data
    real(r8) :: MINV                    ! Either minTime or minAngle
    real(r8) :: TESTANGLE               ! Angle to check for
    real(r8) :: HOMEV                   ! Value of angle/time at home

    real(r8), dimension(:), pointer :: BOUNDARIES ! Used in placing chunks
    real(r8), dimension(:), pointer :: FIELD ! Used in placing chunks

    ! Exectuable code
    
    ! Read in the data we're going to need
    call get_string ( lit_indices(config%homeModule), modNameStr, strip=.true. )
    call ReadL1BData ( l1bInfo%l1bOAId, trim(modNameStr)//'.tpGeodAngle', &
      & tpGeodAngle, noMAFsRead, flag )
    call ReadL1BData ( l1bInfo%l1bOAId, 'MAFStartTimeTAI', &
      & taiTime, noMAFsRead, flag )
    noMAFs = mafRange(2) - mafRange(1) + 1
    m1 = mafRange(1) + 1
    m2 = mafRange(2) + 1

    minAngle = minval ( tpGeodAngle%dpField(1,1,m1:m2) )
    maxAngle = maxval ( tpGeodAngle%dpField(1,1,m1:m2) )
    minTime = minval ( taiTime%dpField(1,1,m1:m2) )
    maxTime = maxval ( taiTime%dpField(1,1,m1:m2) )

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! First try to locate the last MAF before the homeGeodAngle
    orbit = int ( tpGeodAngle%dpField(1,1,m1)/360.0 )
    if ( tpGeodAngle%dpField(1,1,m1) < 0.0 ) orbit = orbit - 1
    testAngle = config%homeGeodAngle + orbit*360.0
    if ( config%maxLengthFamily == PHYQ_Angle ) then
      angleIncrement = config%maxLength
    else
      angleIncrement = 360.0
    end if
    
    maxLength = nint ( config%maxLength )
    
    homeHuntLoop: do
      if ( testAngle < minAngle ) then
        testAngle = testAngle + angleIncrement
        cycle
      endif
      if ( testAngle > maxAngle ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to establish a home major frame, using the first' )
        home = 1
        exit homeHuntLoop
a363 46
      ! Find MAF which starts before this test angle
      call Hunt ( tpGeodAngle%dpField(1,1,:), testAngle, home, nearest=.true.,&
        & allowTopValue = .true. )
      ! Now if this is close enough, and has enough MAFs around it, accept it
      if ( ( abs ( tpGeodAngle%dpField(1,1,home) - &
        & testAngle ) < HomeAccuracy ) &
        & .and. ( home - maxLength/2 >= 1 ) &
        & .and. ( home + maxLength/2 <= noMAFs ) ) exit homeHuntLoop
      ! Otherwise, keep looking
      testAngle = testAngle + angleIncrement
    end do homeHuntLoop
    homeMAF = home + m1 - 1

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! OK, now we have a home MAF, get a first cut for the chunks
    ! We work out the chunk ends for each chunk according to how the
    ! maxLength field is specified.
    ! config%maxLengthFamily == PHYQ_MAFs
    noChunks = 1
      
    ! Allocate the chunk
    allocate ( chunks(noChunks), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'chunks (maxLength/MAFs)' )
    
    ! Work out its position (in the file)
    chunks(1)%firstMAFIndex = homeMAF - maxLength/2 - 1
    chunks(1)%lastMAFIndex = homeMAF + maxLength/2 - 1

    chunks(1)%noMAFsUpperOverlap = 0
    chunks(1)%noMAFsLowerOverlap = 0
    chunks(1)%accumulatedMAFs = chunks(1)%firstMAFIndex
        
    call DeallocateL1BData ( tpGeodAngle )
    call DeallocateL1BData ( taiTime )

  end subroutine ChunkDivide_PE

  !----------------------------------------- ChunkDivide_Orbital --------
  subroutine ChunkDivide_Orbital ( config, mafRange, l1bInfo, &
    & obstructions, chunks )
    type (ChunkDivideConfig_T), intent(in) :: CONFIG
    integer, dimension(2), intent(in) :: MAFRANGE
    type (L1BInfo_T), intent(in) :: L1BINFO
    type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS
d365 1
a365 2
    ! Local parameters
    real(r8), parameter :: HOMEACCURACY = 3.0 ! Try to hit homeGeodAngle within this
d367 23
a389 5
    ! Local variables
    type (L1BData_T) :: TAITIME         ! From L1BOA
    type (L1BData_T) :: TPGEODANGLE     ! From L1BOA

    character(len=10) :: MODNAMESTR     ! Home module name as string
d391 6
a396 58
    integer :: CHUNK                    ! Loop counter
    integer :: FLAG                     ! From ReadL1B
    integer :: HOMEMAF                  ! first MAF after homeGeodAngle
    integer :: HOME                     ! Index of home MAF in array
    integer :: M1, M2                   ! MafRange + 1
    integer :: NOCHUNKSBELOWHOME        ! Used for placing chunks
    integer :: NOMAFSATORABOVEHOME      ! Fairly self descriptive
    integer :: NOMAFS                   ! Number of MAFs to consider
    integer :: NOMAFSREAD               ! From ReadL1B
    integer :: ORBIT                    ! Used to locate homeMAF
    integer :: STATUS                   ! From allocate etc.
    integer :: NOCHUNKS                 ! Number of chunks
    integer :: OVERLAPS                 ! Overlaps as integer (MAFs)
    integer :: MAXLENGTH                ! Max length as integer (MAFs)

    integer, dimension(:), pointer :: NEWFIRSTMAFS ! For thinking about overlaps
    integer, dimension(:), pointer :: NEWLASTMAFS ! For thinking about overlaps

    real(r8) :: ANGLEINCREMENT          ! Increment in hunt for homeMAF
    real(r8) :: MAXANGLE                ! Of range in data
    real(r8) :: MAXTIME                 ! Time range in data
    real(r8) :: MAXV                    ! Either minTime or minAngle
    real(r8) :: MINANGLE                ! Of range in data
    real(r8) :: MINTIME                 ! Time range in data
    real(r8) :: MINV                    ! Either minTime or minAngle
    real(r8) :: TESTANGLE               ! Angle to check for
    real(r8) :: HOMEV                   ! Value of angle/time at home

    real(r8), dimension(:), pointer :: BOUNDARIES ! Used in placing chunks
    real(r8), dimension(:), pointer :: FIELD ! Used in placing chunks

    ! Exectuable code
    
    ! Read in the data we're going to need
    call get_string ( lit_indices(config%homeModule), modNameStr, strip=.true. )
    call ReadL1BData ( l1bInfo%l1bOAId, trim(modNameStr)//'.tpGeodAngle', &
      & tpGeodAngle, noMAFsRead, flag )
    call ReadL1BData ( l1bInfo%l1bOAId, 'MAFStartTimeTAI', &
      & taiTime, noMAFsRead, flag )
    noMAFs = mafRange(2) - mafRange(1) + 1
    m1 = mafRange(1) + 1
    m2 = mafRange(2) + 1

    minAngle = minval ( tpGeodAngle%dpField(1,1,m1:m2) )
    maxAngle = maxval ( tpGeodAngle%dpField(1,1,m1:m2) )
    minTime = minval ( taiTime%dpField(1,1,m1:m2) )
    maxTime = maxval ( taiTime%dpField(1,1,m1:m2) )

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! First try to locate the last MAF before the homeGeodAngle
    orbit = int ( tpGeodAngle%dpField(1,1,m1)/360.0 )
    if ( tpGeodAngle%dpField(1,1,m1) < 0.0 ) orbit = orbit - 1
    testAngle = config%homeGeodAngle + orbit*360.0
    if ( config%maxLengthFamily == PHYQ_Angle ) then
      angleIncrement = config%maxLength
    else
      angleIncrement = 360.0
    end if
d398 1
a398 42
    homeHuntLoop: do
      if ( testAngle < minAngle ) then
        testAngle = testAngle + angleIncrement
        cycle
      endif
      if ( testAngle > maxAngle ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Unable to establish a home major frame, using the first' )
        home = 1
        exit homeHuntLoop
      end if
      ! Find MAF which starts before this test angle
      call Hunt ( tpGeodAngle%dpField(1,1,:), testAngle, home, nearest=.true.,&
        & allowTopValue = .true. )
      ! Now if this is close enough, accept it
      if ( abs ( tpGeodAngle%dpField(1,1,home) - &
        & testAngle ) < HomeAccuracy ) exit homeHuntLoop
      ! Otherwise, keep looking
      testAngle = testAngle + angleIncrement
    end do homeHuntLoop
    homeMAF = home + m1 - 1

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! OK, now we have a home MAF, get a first cut for the chunks
    ! We work out the chunk ends for each chunk according to how the
    ! maxLength field is specified.
    if ( config%maxLengthFamily == PHYQ_MAFs ) then
      maxLength = nint ( config%maxLength )
      noChunksBelowHome = home / maxLength
      if ( mod ( home, maxLength ) /= 0 ) noChunksBelowHome = noChunksBelowHome + 1
      noMAFsAtOrAboveHome = noMAFs - home + 1
      if ( config%noChunks == 0 ) then
        ! If user did not request specific number of chunks choose them
        noChunks = noChunksBelowHome + noMAFsAtOrAboveHome / maxLength
        if ( mod ( noMAFsAtOrAboveHome, maxLength ) /= 0 ) &
          & noChunks = noChunks + 1
      else
        ! User requested specific number of chunks
        noChunks = config%noChunks
      end if
      
      ! Allocate the chunks
a401 21
      
      ! Work out their positions
      do chunk = 1, noChunks
        chunks(chunk)%lastMAFIndex = homeMAF + &
          & ( chunk - noChunksBelowHome ) * maxLength
      end do
    else
      ! For angle and time, they are similar enough we'll just do some stuff
      ! with pointers to allow us to use common code to sort them out
      select case ( config%maxLengthFamily )
      case ( PHYQ_Angle )
        field => tpGeodAngle%dpField(1,1,:)
        minV = minAngle
        maxV = maxAngle
      case ( PHYQ_Time )
        field => taiTime%dpField(1,1,:)
        minV = minTime
        maxV = maxTime
      case ( PHYQ_MAFs)
      end select
      homeV = field(home)
d403 86
a488 7
      noChunksBelowHome = int ( ( homeV - minV ) / config%maxLength )
      if ( homeV > minV ) noChunksBelowHome = noChunksBelowHome + 1
      if ( config%noChunks == 0 ) then
        ! Choose the number of chunks ourselves
        noChunks = noChunksBelowHome + int ( ( maxV - homeV ) / config%maxLength )
        if ( homeV + config%maxLength * ( noChunks - noChunksBelowHome ) < maxV ) &
          & noChunks = noChunks + 1
d490 1
a490 1
        noChunks = config%noChunks
d493 21
a513 4
      ! Allocate the chunks
      allocate ( chunks(noChunks), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'chunks (maxLength/time/angle)' )
d515 18
a532 13
      ! Work out their positions
      ! Boundaries are the angles/times at the end of the chunks
      nullify ( boundaries )
      call Allocate_test ( boundaries, noChunks, 'boundaries', ModuleName )
      do chunk = 1, noChunks
        boundaries(chunk) = homeV + ( chunk - noChunksBelowHome ) * config%maxLength
      end do
      boundaries = min ( boundaries, maxV )
      boundaries = max ( boundaries, minV )
      call Hunt ( field, boundaries, chunks%lastMAFIndex, &
        & allowTopValue=.true., nearest=.true. )
      call Deallocate_test ( boundaries, 'boundaries', ModuleName )
    end if
d534 36
a569 54
    ! Now deduce the chunk starts from the ends of their predecessors
    chunks(2:noChunks)%firstMAFIndex = chunks(1:noChunks-1)%lastMAFIndex + 1
    chunks(1)%firstMAFIndex = 1
    
    ! Now offset these to the index in the file not the array
    chunks%firstMAFIndex = chunks%firstMAFIndex + mafRange(1) - 1
    chunks%lastMAFIndex = chunks%lastMAFIndex + mafRange(1) - 1 

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! Think about overlaps
    nullify ( newFirstMAFs, newLastMAFs )
    call Allocate_test ( newFirstMAFs, noChunks, 'newFirstMAFs', ModuleName )
    call Allocate_test ( newLastMAFs, noChunks, 'newLastMAFs', ModuleName )
    if ( config%overlapFamily == PHYQ_MAFs ) then
      newFirstMAFs = max(chunks%firstMAFIndex - nint(config%overlap), mafRange(1) )
      newLastMAFs = min(chunks%lastMAFIndex + nint(config%overlap), mafRange(2) )
    else
      ! For angle and time, they are similar enough we'll just do some stuff
      ! with pointers to allow us to use common code to sort them out
      ! Note that before we search only over the range in mafRange, here we
      ! search over the whole file as we can spill over the processing range
      ! for overlaps.
      select case ( config%maxLengthFamily )
      case ( PHYQ_Angle )
        field => tpGeodAngle%dpField(1,1,:)
        minV = minAngle
      case ( PHYQ_Time )
        field => taiTime%dpField(1,1,:)
        minV = minTime
      case ( PHYQ_MAFs)
      end select
      call Hunt ( field, field(chunks%firstMAFIndex-1) + &
        & config%overlap, newFirstMAFs, allowTopValue=.true. )
      call Hunt ( field, field(chunks%firstMAFIndex-1) - &
        & config%overlap, newLastMAFs, allowTopValue=.true. )
      ! Correct this to be real MAF indicies (starting from zero)
      newFirstMAFs = newFirstMAFs - 1
      newLastMAFs = newLastMAFs - 1
    end if
    chunks%noMAFsLowerOverlap = chunks%firstMAFIndex - newFirstMAFs
    chunks%noMAFsUpperOverlap = newLastMAFs - chunks%lastMAFIndex
    chunks%firstMAFIndex = newFirstMAFs
    chunks%lastMAFIndex = newLastMAFs
    call Deallocate_test ( newFirstMAFs, 'newFirstMAFs', ModuleName )
    call Deallocate_test ( newLastMAFs, 'newLastMAFs', ModuleName )

    ! Now delete any chunks that are nothing but overlap
    allOverlapChunks: do
      chunk = FindFirst ( &
        & ( chunks%noMAFsLowerOverlap + chunks%noMAFsUpperOverlap ) >= &
        & ( chunks%lastMAFIndex - chunks%firstMAFIndex + 1 ) )
      if ( chunk == 0 ) exit allOverlapChunks
      call DeleteChunk ( chunks, chunk )
    end do allOverlapChunks
d571 18
a588 2
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! Now think about the obstructions
d590 45
a634 1
    call DealWithObstructions ( chunks, obstructions )
d636 75
a710 3
    ! Tidy up
    call DeallocateL1BData ( tpGeodAngle )
    call DeallocateL1BData ( taiTime )
d712 1
a712 1
  end subroutine ChunkDivide_Orbital
d714 50
a763 7
  !---------------------------------------------- ChunkDivideL2CF -----
  subroutine ChunkDivideL2CF ( sectionRoot, config )
    ! This subroutine identifies, separates, and checks values from the section
    ! of the MLSCF (ChunkDivide) passed to Scan/Divide.
    integer, intent(in) :: SECTIONROOT    ! Root of the ChunkDivide section of the
    ! MLSCF abstract syntax tree
    type (ChunkDivideConfig_T), intent(out) :: CONFIG ! Result of operation
d765 16
a780 4
    ! For announce_error:
    integer, parameter :: BadUnits = 1
    integer, parameter :: NotSpecified = BadUnits + 1
    integer, parameter :: Unnecessary = NotSpecified + 1
d782 10
a791 23
    integer, target, dimension(3) :: NeededForFixed = &
      & (/ f_noChunks, f_maxLength, f_overlap /)
    integer, target, dimension(7) :: NotWantedForFixed = &
      & (/ f_noSlaves, f_homeModule, f_homeGeodAngle, f_scanLowerLimit, &
      &    f_scanUpperLimit, f_criticalModules, f_maxGap /)

    integer, target, dimension(3) :: NeededForPE = &
      & (/ f_maxLength, f_homeModule, f_homeGeodAngle /)
    integer, target, dimension(7) :: NotWantedForPE = &
      & (/ f_noChunks, f_overlap, f_noSlaves, f_scanLowerLimit, &
      &    f_scanUpperLimit, f_criticalModules, f_maxGap /)

    integer, target, dimension(6) :: NeededForOrbital = &
      & (/ f_maxLength, f_overlap, f_homeModule, f_homeGeodAngle, &
      &    f_criticalModules, f_maxGap /)
    integer, target, dimension(1) :: NotWantedForOrbital = &
      & (/ f_noSlaves /)

    integer, target, dimension(6) :: NeededForEven = &
      & (/ f_maxLength, f_overlap, f_maxLength, f_noSlaves, f_maxGap, &
      &    f_criticalModules /)
    integer, target, dimension(3) :: NotWantedForEven = &
      & (/ f_noChunks, f_homeModule, f_homeGeodAngle /)
d793 12
a804 12
    ! Local variables
    integer :: ERROR                    ! Error level
    integer :: FIELDINDEX               ! Tree type
    integer :: GSON                     ! A son of son the ChunkDivide section node
    integer :: I                        ! Loop inductor
    integer :: ROOT                     ! Root of ChunkDivide command
    integer :: SON                      ! A son of the ChunkDivide section node
    integer :: UNITS(2)                 ! Units of expression
    integer, dimension(:), pointer :: NEEDED ! Which fields are needed
    integer, dimension(:), pointer :: NOTWANTED ! Which fields are not wanted
    logical :: GOT(field_first:field_last) = .false.
    real(rp) :: VALUE(2)                ! Value of expression
d806 18
a823 62
    ! Executable code
    error = 0

    ! Eventually the ChunkDivide command will be free floating, in the meantime
    ! find it within the section
    ! WE CAN GET RID OF THIS BIT WHEN THE COMMAND FLOATS FREE LATER
    do i = 2, nsons(sectionRoot)-1      ! Skip the begin/end section
      root = subtree(i,sectionRoot)
      if ( node_id(root) /= n_named ) cycle
      if ( get_spec_id(root) == s_chunkDivide ) exit
    end do

    got = .false.

    ! Loop through the command identifying parameters.
    do i = 2, nsons(root) ! Skip the command
      son = subtree(i,root)
      fieldIndex = get_field_id(son)
      got(fieldIndex) = .true.
      if (nsons(son) > 1 ) then
        gson = subtree(2,son)
        call expr ( gson, units, value )
      end if
      ! Get value for this field if appropriate
      select case ( fieldIndex )
      case ( f_method )
        config%method = decoration ( gson )
      case ( f_noChunks )
        config%noChunks = nint ( value(1) )
      case ( f_maxLength )
        config%maxLength = value(1)
        config%maxLengthFamily = units(1)
      case ( f_overlap )
        config%overlap = value(1)
        config%overlapFamily = units(1)
      case ( f_noSlaves )
        config%noSlaves = value(1)
        if ( units(1) /= PHYQ_DimensionLess ) &
          & call AnnounceError ( root, BadUnits, fieldIndex )
      case ( f_homeModule )
        config%homeModule = decoration ( gson )
      case ( f_homeGeodAngle )
        config%homeGeodAngle = value(1)
        if ( units(1) /= PHYQ_Angle ) &
          & call AnnounceError ( root, BadUnits, fieldIndex )
      case ( f_scanLowerLimit )
        if ( any ( units /= PHYQ_Dimensionless .and. units /= PHYQ_Length ) &
          & .or. .not. any ( units == PHYQ_Length ) ) &
          & call AnnounceError ( root, BadUnits, fieldIndex )
        config%scanLowerLimit = value
        config%scanLLSet = .true.
      case ( f_scanUpperLimit )
        if ( any ( units /= PHYQ_Dimensionless .and. units /= PHYQ_Length ) &
          & .or. .not. any ( units == PHYQ_Length ) ) &
          & call AnnounceError ( root, BadUnits, fieldIndex )
        config%scanUpperLimit = value
        config%scanULSet = .true.
      case ( f_criticalModules )
        config%criticalModules = decoration ( gson )
      case ( f_maxGap )
        config%maxGap = value(1)
        config%maxGapFamily = units(1)
a824 1
    end do
d826 2
a827 16
    ! Now check the sanity of what we've been given, this varies a bit
    ! depending on the method
    select case ( config%method )
    case ( l_fixed )
      needed => NeededForFixed
      notWanted => NotWantedForFixed
    case ( l_PE )
      needed => NeededForPE
      notWanted => NotWantedForPE
    case ( l_orbital )
      needed => NeededForOrbital
      notWanted => NotWantedForOrbital
    case ( l_even )
      needed => NeededForEven
      notWanted => NotWantedForEven
    end select
d829 1
a829 23
    ! Check we've got all the arguments we need
    do i = 1, size(needed)
      if ( .not. got(needed(i) ) ) &
        & call AnnounceError ( root, notSpecified, needed(i) )
    end do
    ! Check we don't have unnecessary ones
    do i = 1, size(notWanted)
      if ( got(notWanted(i) ) ) &
        & call AnnounceError ( root, unnecessary, notWanted(i) )
    end do

    ! Make other checks of parameters
    if ( config%criticalModules /= l_none ) then
      if ( .not. got(f_scanLowerLimit) ) &
        & call AnnounceError ( root, notSpecified, f_scanLowerLimit )
      if ( .not. got (f_scanUpperLimit) ) &
        & call AnnounceError ( root, notSpecified, f_scanUpperLimit )
    else
      if ( got(f_scanLowerLimit) ) &
        & call AnnounceError ( root, unnecessary, f_scanLowerLimit )
      if ( got (f_scanUpperLimit) ) &
        & call AnnounceError ( root, unnecessary, f_scanUpperLimit )
    end if
d831 1
a831 19
    ! Now check the units for various cases
    if ( got(f_maxgap) .and. all ( config%maxGapFamily /= &
      & (/ PHYQ_MAFs, PHYQ_Angle, PHYQ_Time /))) &
      & call AnnounceError ( root, badUnits, f_maxGap )
    select case ( config%method )
    case ( l_PE )
      if ( config%maxLengthFamily /= PHYQ_MAFs ) &
        & call AnnounceError ( root, badUnits, f_maxLength )
    case ( l_orbital )
      if (all(config%maxLengthFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
        & call AnnounceError ( root, badUnits, f_maxLength )
      if (all(config%overlapFamily/=(/PHYQ_MAFs, PHYQ_Angle, PHYQ_Time/))) &
        & call AnnounceError ( root, badUnits, f_overlap )
    case ( l_fixed, l_even )
      if ( config%maxLengthFamily /= PHYQ_MAFs ) &
        & call AnnounceError ( root, badUnits, f_maxLength )
      if ( config%overlapFamily /= PHYQ_MAFs ) &
        & call AnnounceError ( root, badUnits, f_overlap )
    end select
d833 29
a861 2
    if ( error /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Problem with ChunkDivide command' )
d863 6
a868 1
    ! That's it, we're all valid now.
d870 75
a944 1
  contains ! - - - - - - - - - - - - - - - - - - - -
d946 1
a946 2
    subroutine AnnounceError ( where, Code, field )
      integer, intent(in) :: where, Code, field
d948 2
a949 18
      error = max(error,1)
      call print_source ( source_ref(where) )
      call output ( ' ChunkDivide complained: ' )
      select case ( code )
      case ( BadUnits )
        call output ( ' The field ' )
        call display_string ( field_indices(field) )
        call output (' has inappropriate units', advance='yes' )
      case ( notSpecified )
        call output ( ' The parameter ' )
        call display_string ( field_indices(field) )
        call output ( ' is required but not specified.', advance='yes' )
      case ( unnecessary )
        call output ( ' The parameter ' )
        call display_string ( field_indices(field) )
        call output ( ' is specified but not appropriate.', advance='yes' )
      end select
    end subroutine AnnounceError
d951 45
a995 1
  end subroutine ChunkDivideL2CF
d997 2
a998 7
  ! ------------------------------------------ ConvertFlagsToObstructions --
  subroutine ConvertFlagsToObstructions ( valid, mafRange, obstructions )
    ! This routine takes an array of logicals indicating good/bad data
    ! and converts it into obstruction information.
    logical, dimension(:), intent(in) :: VALID
    integer, dimension(:), intent(in) :: MAFRANGE
    type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS
d1000 1
a1000 4
    ! Local variables
    integer :: MAF                      ! Loop counter
    logical :: LASTONEVALID             ! Flag
    type (Obstruction_T) :: NEWOBSTRUCTION ! In progrss
d1002 9
a1010 23
    ! Executable code
    lastOneValid = .true.
    do maf = 1, size(valid)
      if ( valid(maf) .neqv. lastOneValid ) then
        ! A transition either from good to bad or bad to good
        if ( .not. valid(maf) ) then
          ! From good to bad
          newObstruction%range = .true.
          newObstruction%mafs(1) = maf + mafRange(1) - 1
        else
          newObstruction%mafs(2) = maf + mafRange(1) - 2
          call AddObstructionToDatabase ( obstructions, newObstruction )
        end if
      end if
      lastOneValid = valid(maf)
    end do
    
    ! Make sure any range at the end gets added
    if ( .not. lastOneValid ) then
      newObstruction%mafs(2) = mafRange(2)
      call AddObstructionToDatabase ( obstructions, newObstruction )
    end if
  end subroutine ConvertFlagsToObstructions
d1012 4
a1015 6
  ! ----------------------------------- DealWithObstructions ------------
  subroutine DealWithObstructions ( chunks, obstructions )
    type (MLSChunk_T), dimension(:), pointer :: CHUNKS
    type (Obstruction_T), dimension(:), intent(in) :: OBSTRUCTIONS
    ! This routine modifies the chunks according to the information
    ! given in the obstructions.
d1017 3
a1019 8
    ! Local variables
    type (MLSChunk_T) :: NEWCHUNK       ! A chunk to create
    integer :: CHUNK                    ! Index of chunk under some consideration
    integer :: DEADCHUNK                ! Index of chunk to kill
    integer :: FIRSTMAF                 ! Index of first MAF in range
    integer :: LASTMAF                  ! Index of last MAF in range
    integer :: MAF                      ! Index of MAF for wall
    integer :: OBSTRUCTION              ! Loop counter
d1021 3
a1023 1
    ! Executable code
d1025 1
a1025 16
    do obstruction = 1, size ( obstructions )
      ! Find chunk where this obstruction is/starts
      if ( obstructions(obstruction)%range ) then
        ! A range obstruction

        ! first identify the chunks whose non overlapped portion falls completely
        ! within the range and delete them
        firstMAF = obstructions(obstruction)%mafs(1)
        lastMAF = obstructions(obstruction)%mafs(2)
        insideRange: do
          deadChunk = FindFirst ( &
            & chunks%firstMAFIndex + chunks%noMAFsLowerOverlap >= firstMAF .and. &
            & chunks%lastMAFIndex - chunks%noMAFsUpperOverlap <= lastMAF )
          if ( deadChunk == 0 ) exit insideRange
          call DeleteChunk ( chunks, deadChunk )
        end do insideRange
d1027 1
a1027 21
        ! Now think about chunks who's non overlapped part completely
        ! encompas the range, and split them.
        chunk = FindFirst ( &
          & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap <= firstMAF ) .and. &
          & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap >= lastMAF ) )
        if ( chunk /= 0 ) then
          ! Create two new chunks with the wall between, first the lower portion
          newChunk = chunks ( chunk )
          newChunk%lastMAFIndex = firstMAF - 1
          newChunk%noMAFsUpperOverlap = 0
          if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
            & call AddChunkToDatabase ( chunks, newChunk )
          ! Now the upper portion
          newChunk = chunks ( chunk )
          newChunk%firstMAFIndex = lastMAF + 1
          newChunk%noMAFsLowerOverlap = 0
          if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
            & call AddChunkToDatabase ( chunks, newChunk )
          ! Delete the old chunk
          call DeleteChunk ( chunks, chunk )
        endif
d1029 5
a1033 18
        ! So the cases we have left do not involve deleting or creating new
        ! chunks, just modifying existing ones
        ! Look for chunks where the range starts in the chunk
        chunk = FindFirst ( chunks%lastMAFIndex >= firstMAF )
        if ( chunk /= 0 ) then
          chunks(chunk)%noMAFsUpperOverlap = max ( 0, &
            & chunks(chunk)%noMAFsUpperOverlap - &
            &    ( chunks(chunk)%lastMAFIndex - (firstMAF-1) ) )
          chunks(chunk)%lastMAFIndex = firstMAF - 1
        end if
        ! Look for chunks where the range ends in the chunk
        chunk = FindFirst ( chunks%firstMAFIndex <= lastMAF )
        if ( chunk /= 0 ) then
          chunks(chunk)%noMAFsLowerOverlap = max ( 0, &
            & chunks(chunk)%noMAFsLowerOverlap - &
            &    ( (lastMAF+1) - chunks(chunk)%firstMafIndex ) )
          chunks(chunk)%firstMAFIndex = lastMAF + 1
        end if
d1035 3
a1037 1
      else ! - - - - - - - - - - - - - - - - - - - - - - - - - - - -
d1039 4
a1042 2
        ! A wall obstruction
        maf = obstructions(obstruction)%mafs(1)
d1044 3
a1046 3
        chunk = FindFirst ( &
          & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap <= maf ) .and. &
          & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap >= maf ) )
d1048 3
a1050 16
        if ( chunk /= 0 ) then
          ! Create two new chunks with the wall between, first the lower portion
          newChunk = chunks ( chunk )
          newChunk%lastMAFIndex = maf - 1
          newChunk%noMAFsUpperOverlap = 0
          if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
            & call AddChunkToDatabase ( chunks, newChunk )
          ! Now the upper portion
          newChunk = chunks ( chunk )
          newChunk%firstMAFIndex = maf
          newChunk%noMAFsLowerOverlap = 0
          if ( newChunk%lastMAFIndex /= newChunk%firstMAFIndex ) &
            & call AddChunkToDatabase ( chunks, newChunk )
          ! Now delete the original chunk
          call DeleteChunk ( chunks, chunk )
        endif
d1052 1
a1052 24
        ! For chunks where the wall is in the overlap, just make the 
        ! overlap shorter 
        ! First the lower overlap
        chunk = FindFirst ( &
          & ( chunks%firstMAFIndex <= maf ) .and. &
          & ( chunks%firstMAFIndex + chunks%noMAFsLowerOverlap - 1 >= maf ) )
        if ( chunk /= 0 ) then
          chunks(chunk)%noMAFsLowerOverlap = &
          & max ( chunks(chunk)%noMAFsLowerOverlap - &
          & ( maf - chunks(chunk)%firstMAFIndex ), 0 )
          chunks(chunk)%firstMAFIndex = maf
        end if
        ! Now the upper overlap
        chunk = FindFirst ( &
          & ( chunks%lastMAFIndex - chunks%noMAFsUpperOverlap + 1 <= maf ) .and. &
          & ( chunks%lastMAFIndex >= maf ) )
        if ( chunk /= 0 ) then
          chunks(chunk)%noMAFsUpperOverlap = &
          & max ( chunks(chunk)%noMAFsUpperOverlap - &
          & ( chunks(chunk)%lastMAFIndex - (maf-1) ), 0 )
          chunks(chunk)%lastMAFIndex = maf - 1
        end if
      end if                            ! Wall obstructions
    end do                              ! Loop over obstructions
d1054 1
a1054 2
    ! Sort the chunks back into order
    call SortChunks ( chunks )
d1056 21
a1076 1
  end subroutine DealWithObstructions
d1078 92
a1169 5
  ! ------------------------------------------- DeleteObstruction -------
  subroutine DeleteObstruction ( obstructions, index )
    ! Dummy arguments
    type (Obstruction_T), pointer, dimension(:) :: OBSTRUCTIONS
    integer, intent(in) :: INDEX
d1171 21
a1191 3
    ! Local variables
    type (Obstruction_T), pointer, dimension(:) :: TEMP
    integer :: STATUS                   ! From allocate
d1193 94
a1286 22
    ! Executable code
    allocate ( temp ( size(obstructions) - 1 ), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'temp' )

    if ( index > 1 ) temp(1:index-1) = obstructions(1:index-1)
    if ( index < size(obstructions) .and. size(obstructions) > 1 ) &
      & temp(index:) = obstructions(index+1:)

    deallocate ( obstructions, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'obstructions' )

    obstructions => temp

  end subroutine DeleteObstruction

  ! ------------------------------------------- DeleteChunk -------
  subroutine DeleteChunk ( chunks, index )
    ! Dummy arguments
    type (MLSChunk_T), pointer, dimension(:) :: CHUNKS
    integer, intent(in) :: INDEX
d1288 2
a1289 3
    ! Local variables
    type (MLSChunk_T), pointer, dimension(:) :: TEMP
    integer :: STATUS                   ! From allocate
d1291 2
a1292 8
    ! Executable code
    allocate ( temp ( size(chunks) - 1 ), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'temp' )

    if ( index > 1 ) temp(1:index-1) = chunks(1:index-1)
    if ( index < size(chunks) .and. size(chunks) > 1 ) &
      & temp(index:) = chunks(index+1:)
d1294 2
a1295 3
    deallocate ( chunks, stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'chunks' )
d1297 2
a1298 1
    chunks => temp
d1300 1
a1300 1
  end subroutine DeleteChunk
a1301 2
  ! --------------------------------------- Dump Obstructions ------------
  subroutine Dump_Obstructions ( obstructions ) 
a1332 240
  ! --------------------------------------- Prune Obstructions ----------
  subroutine PruneObstructions ( obstructions )
    ! This routine merges overlapping range obstructions and deletes
    ! wall obstructions inside ranges.  The job is made easier
    ! by sorting the obstructions into order
    type(Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS

    ! Local variables
    integer :: I,J                      ! Loop counters
    type (Obstruction_T) :: newObs      ! New Obstruction
    logical :: FOUNDONE                 ! Found at least one
    integer :: STATUS                   ! Flag from allocate

    ! Executable code
    ! If no obstructions make sure allocate to size zero, not just unassociated pointer
    if ( .not. associated(obstructions) ) then
      allocate ( obstructions(0), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'obstructions(0)' )
      return
    end if

    ! Otherwise, do the tidying up
    outerLoop: do
      foundOne = .false.
      i = 0
      call SortObstructions(obstructions)
      middleLoop: do
        i = i + 1
        if ( i >= size(obstructions) ) exit middleLoop
        j = i
        innerLoop: do
          j = j + 1
          if ( j > size(obstructions) ) exit innerLoop
          if ( all ( obstructions((/i,j/))%range ) ) then
            ! --------------------------- ( Range, range )
            if ( obstructions(j)%mafs(1) <= obstructions(i)%mafs(2) ) then
              ! Combine overlapping range obstructions
              newObs%range = .true.
              newObs%mafs(1) = obstructions(i)%mafs(1)
              newObs%mafs(2) = &
                & max ( obstructions(i)%mafs(2), obstructions(j)%mafs(2) )
              call DeleteObstruction ( obstructions, i )
              call DeleteObstruction ( obstructions, j )
              call AddObstructionToDatabase ( obstructions, newObs )
              call SortObstructions ( obstructions )
              foundOne = .true.
              exit middleLoop
            end if
          else if ( obstructions(i)%range .and. .not. obstructions(j)%range ) then
            ! --------------------------- ( Range, wall )
            if ( obstructions(j)%mafs(1) >= obstructions(i)%mafs(1) .and. &
              &  obstructions(j)%mafs(1) <= obstructions(i)%mafs(2) ) then
              ! Delete wall obstruction inside range
              call DeleteObstruction ( obstructions, j )
              foundOne = .true.
              exit middleLoop
            end if
          else
            ! --------------------------- ( Wall, range ) or ( Wall, wall )
            ! Becuase the obstructions are in order, we know in the wall, range
            ! case that the wall must be at the start of the range, not inside it.
            if ( obstructions(i)%mafs(1) == obstructions(j)%mafs(1) ) then
              ! Delete wall obstruction at start of a range or at another wall
              call DeleteObstruction ( obstructions, i )
              foundOne = .true.
              exit MiddleLoop
            end if
          end if
          ! I'm pretty sure this covers all the possibilities.  It might seem
          ! not at first glance, but I think the fact that I always re-sort the
          ! obstructions into order means that the above code does catch everything.

        end do innerLoop
      end do middleLoop 
      if ( .not. foundOne ) exit outerLoop
    end do outerLoop

  end subroutine PruneObstructions
  
  ! ----------------------------------------- SortObstructions ----------
  subroutine SortObstructions ( obstructions )
    ! Sort the obstructions into order of increasing
    ! mafs(1) (start/wall MAF index)
    type (Obstruction_T), dimension(:), intent(inout) :: OBSTRUCTIONS

    ! Local variables
    type (Obstruction_T) :: TEMP
    integer :: I                        ! Loop counters
    integer, dimension(1) :: TOSWAP     ! Index

    ! Executable code
    do i = 1, size(obstructions) - 1
      toSwap = minloc ( obstructions(i:)%mafs(1) ) + (/ i-1 /)
      if ( toSwap(1) /= i ) then
        temp = obstructions(i)
        obstructions(i) = obstructions(toSwap(1))
        obstructions(toSwap(1)) = temp
      end if
    end do
  end subroutine SortObstructions

  ! ----------------------------------------- SortChunks ----------
  subroutine SortChunks ( chunks )
    ! Sort the chunks into order of increasing firstMAFIndex
    type (MLSChunk_T), dimension(:), intent(inout) :: CHUNKS

    ! Local variables
    type (MLSChunk_T) :: TEMP
    integer :: I                        ! Loop counters
    integer, dimension(1) :: TOSWAP     ! Index

    ! Executable code
    do i = 1, size(chunks) - 1
      toSwap = minloc ( chunks(i:)%firstMAFIndex ) + (/ i-1 /)
      if ( toSwap(1) /= i ) then
        temp = chunks(i)
        chunks(i) = chunks(toSwap(1))
        chunks(toSwap(1)) = temp
      end if
    end do
  end subroutine SortChunks

  ! ------------------------------------------- SayTime -----------------
  subroutine SayTime
    real :: T2
    call time_now ( t2 )
    if ( total_times ) then
      call output ( "Total time = " )
      call output ( dble(t2), advance = 'no' )
      call blanks ( 4, advance = 'no' )
    endif
    call output ( 'Timing for ScanDivide = ' )
    call output ( dble(t2-t1), advance='yes' )
    timing = .false.
  end subroutine SayTime

  ! ------------------------------------------ SurveyL1BData -----------
  subroutine SurveyL1BData ( processingRange, l1bInfo, config, mafRange,&
    & obstructions )
    ! This goes through the L1B data files and trys to spot possible
    ! obstructions.
    type (TAI93_Range_T), intent(in) :: PROCESSINGRANGE
    type (L1BInfo_T), intent(in) :: L1BINFO
    type (ChunkDivideConfig_T), intent(in) :: CONFIG
    integer, dimension(2), intent(out) :: MAFRANGE   ! Processing range in MAFs
    type (Obstruction_T), dimension(:), pointer :: OBSTRUCTIONS

    ! Local variables
    type (L1BData_T) :: TAITIME         ! Read from L1BOA file
    type (L1BData_T) :: TPGEODALT       ! Read from L1BOA file
    type (Obstruction_T) :: NEWOBSTRUCTION ! A single obstruction

    character(len=10) :: MODNAMESTR     ! Module name

    integer :: FLAG                     ! From L1B
    integer :: MAF                      ! Loop inductor
    integer :: MOD                      ! Loop inductor
    integer :: NOMAFS                   ! Number of MAFs in processing range
    integer :: NOMAFSREAD               ! From L1B

    logical :: LASTONEVALID             ! To run through valid
    logical :: THISONEVALID             ! To go into valid
    logical, dimension(:), pointer :: VALID ! Flag for each MAF

    real(r8) :: SCANMAX                 ! Range of scan each maf
    real(r8) :: SCANMIN                 ! Range of scan each mif

    ! Executable code
    
    ! Read time from the L1BOA file
    call ReadL1BData ( l1bInfo%l1boaId, 'MAFStartTimeTAI', taiTime, noMAFsRead, flag )

    ! Deduce the first and last MAFs to consider
    call Hunt ( taiTime%dpField(1,1,:), &
      & (/ processingRange%startTime, processingRange%endTime /), &
      & mafRange, allowTopValue=.true., allowBelowValue=.true. )

    ! Check the validity of the MAF range returned
    if ( mafRange(2) == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'L1B data starts after requested processing range' )
    if ( mafRange(1) == taiTime%noMAFs ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'L1B data ends before requested processing range' )
    mafRange = min ( noMAFsRead, max ( 0, mafRange - 1 ) )          ! Index from zero
    noMAFS = mafRange(2) - mafRange(1) + 1

    ! At this point we'd look through the L1B data for data gaps.
    ! I want to defer this for now until I've reached agreement with VSP, RFJ
    ! and RRL on how L1 would report these. NJL

    ! Now look through the L1B data first look for scan problems
    if ( config%criticalModules /= l_none ) then
      nullify ( valid )
      call Allocate_test ( valid, noMAFs, 'valid', ModuleName )
      if ( config%criticalModules == l_both ) then
        valid = .true.
      else
        valid = .false.
      endif
      do mod = 1, size(modules)
        call get_string ( modules(mod)%name, modNameStr, strip=.true. )
        if ( .not. modules(mod)%spacecraft .and. &
          & any ( config%criticalModules == &
          &     (/ modules(mod)%name, l_either, l_both /) ) ) then
          ! Read the tangent point altitude
          call ReadL1BData ( l1bInfo%l1boaID, trim(modNameStr)//'.tpGeodAlt', &
            & tpGeodAlt, noMAFsRead, flag )
          ! Consider the scan range in each MAF in turn
          do maf = 1, noMAFs
            scanMax = maxval ( tpGeodAlt%dpField(1,:,maf) )
            scanMin = minval ( tpGeodAlt%dpField(1,:,maf) )
            thisOneValid = ( scanMin >= config%scanLowerLimit(1) .and. &
              &              scanMin <= config%scanLowerLimit(2) ) .and. &
              &            ( scanMax >= config%scanUpperLimit(1) .and. &
              &              scanMax <= config%scanUpperLimit(2) )
            if ( config%criticalModules == l_both ) then
              valid(maf) = valid(maf) .and. thisOneValid
            else
              valid(maf) = valid(maf) .or. thisOneValid
            end if
          end do                        ! Maf loop
          call DeallocateL1BData ( taiTime )
        end if                          ! Consider this module
      end do                            ! Module Loop
      ! Convert this information into obstructions and tidy up.
      call ConvertFlagsToObstructions ( valid, mafRange, obstructions )
      call Deallocate_test ( valid, 'valid', ModuleName )
    end if                              ! Consider scan issues

    ! Here we'll eventually look at radiances and switch changes.  For the
    ! moment I'm deferring this one too. NJL.

    ! Sort the obstructions into order and prune them of repeats, overlaps etc.
    call PruneObstructions ( obstructions ) 

    ! Tidy up
    call DeallocateL1BData ( taiTime )

  end subroutine SurveyL1BData

d1336 3
@


2.20
log
@More revisions associated with being able to have a specific number of chunks
@
text
@d19 1
a19 1
    & L_FIXED, F_MAXGAP, L_ORBITAL, S_CHUNKDIVIDE, L_BOTH, L_EITHER
d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.19 2002/05/24 16:47:30 livesey Exp $"
d74 2
d142 3
d247 128
d634 6
d736 3
d775 5
a779 1
    if ( config%method == l_orbital ) then
d784 1
a784 1
    else
d789 1
a789 1
    end if
d1321 3
@


2.19
log
@Allowed user to request specific number of chunks for orbital
@
text
@d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.18 2001/12/17 23:09:18 livesey Exp $"
a357 1
        noChunksBelowHome = min ( noChunksBelowHome, noChunks )
d386 10
a395 6
      noChunks = int ( ( homeV - minV ) / config%maxLength )
      if ( homeV > minV ) noChunks = noChunks + 1
      noChunksBelowHome = noChunks
      noChunks = noChunks + int ( ( maxV - homeV ) / config%maxLength )
      if ( homeV + config%maxLength * ( noChunks - noChunksBelowHome ) < maxV ) &
        & noChunks = noChunks + 1
d1175 3
@


2.18
log
@Now deletes chunks that are nothing but overlap
@
text
@d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.17 2001/12/16 00:56:43 livesey Exp $"
d347 2
a348 3
      noChunks = home / maxLength
      if ( mod ( home, maxLength ) /= 0 ) noChunks = noChunks + 1
      noChunksBelowHome = noChunks
d350 10
a359 3
      noChunks = noChunks + noMAFsAtOrAboveHome / maxLength
      if ( mod ( noMAFsAtOrAboveHome, maxLength ) /= 0 ) &
        & noChunks = noChunks + 1
d501 2
a502 2
    integer, target, dimension(2) :: NotWantedForOrbital = &
      & (/ f_noChunks, f_noSlaves /)
d1172 3
@


2.17
log
@Added dump option
@
text
@d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.16 2001/11/20 00:10:29 livesey Exp $"
d453 9
d1166 3
@


2.16
log
@Another bug fix
@
text
@d31 1
a31 1
  use TOGGLES, only: GEN, TOGGLE
d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.15 2001/11/19 23:53:50 livesey Exp $"
d120 2
a121 2
    
    if ( toggle(gen) ) call trace_begin ("ScanDivide", root )
d158 2
d1097 1
a1097 1
    mafRange = mafRange - 1             ! Index from zero
d1157 3
@


2.15
log
@Works better, fixed bug with cases with all missing data, also handles
ends of processing range properly.
@
text
@d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.14 2001/11/19 23:33:45 livesey Exp $"
d309 1
a309 1
    if ( tpGeodAngle%dpField(1,1,mafRange(1)) < 0.0 ) orbit = orbit - 1
d1155 4
@


2.14
log
@Interim version, some bugs to track down
@
text
@d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.13 2001/11/16 20:38:42 livesey Exp $"
a135 2
    !call dump ( obstructions )

a157 3
    ! call dump ( chunks )
    ! stop

d398 2
d1155 3
@


2.13
log
@Nullified some pointers I missed
@
text
@d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.12 2001/11/15 17:43:46 livesey Exp $"
d90 4
d136 2
d160 3
d164 1
a164 1
    
d330 1
a330 1
        homeMAF = m1
a335 1
      homeMAF = home + m1 - 1
d342 1
d882 33
d1115 1
a1115 1
        call get_string ( lit_indices(modules(mod)%name), modNameStr, strip=.true. )
d1158 3
@


2.12
log
@Tidied up, more comments etc.
@
text
@d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.11 2001/11/14 22:33:40 livesey Exp $"
d389 1
d409 1
d1065 1
d1116 3
@


2.11
log
@This version seems pretty good.
@
text
@d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.10 2001/11/14 01:49:12 livesey Exp $"
a146 3
    call Dump ( chunks )
    stop

a222 1
      print*,'Doing:',i,noNonOverlap, maxLength, overlap
a300 1
    print*,'Angle range:',minAngle, maxAngle
a323 1
      print*,'Test angle:',testAngle
a334 2
    print*,'Home MAF is:', homeMAF, tpGeodAngle%dpField(1,1,home)

a361 1
      print*,'M1,M2', m1, m2
a373 1
      print*,'HomeV is:', homeV
a392 1
      call dump ( boundaries, 'boundaries' )
a397 4
    print*,'noChunks is:', noChunks
    print*,'noChunksBelowHome is:', noChunksBelowHome
    call dump ( chunks%lastMAFIndex,'lastMAFIndex' )

a400 1
    call dump ( chunks%firstMAFIndex,'firstMAFIndex' )
a402 1
    print*,'mafRange(1) is:', mafRange(1)
d689 2
a904 1
          ! --------------------------- ( Range, range )
d906 1
d920 1
a921 1
          else if ( obstructions(i)%range .and. .not. obstructions(j)%range ) then
d929 1
d931 2
a932 1
          else
d940 3
d1113 3
@


2.10
log
@Improvements, getting closer
@
text
@d10 1
a10 1
  use MLSCommon, only: R8, RP, L1BINFO_T, MLSCHUNK_T, TAI93_Range_T
d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.9 2001/11/12 21:15:34 livesey Exp $"
d175 14
d364 1
a364 1
        chunks(chunk)%lastMAFIndex = home + &
d373 1
a373 1
        field => tpGeodAngle%dpField(1,1,m1:m2)
d377 1
a377 1
        field => taiTime%dpField(1,1,m1:m2)
d401 1
a401 1
        boundaries(chunk) = field(home) + ( chunk - noChunksBelowHome ) * config%maxLength
d453 2
a454 2
    chunks%noMAFsLowerOverlap = chunks%lastMAFIndex - newLastMAFs
    chunks%noMAFsUpperOverlap = newFirstMAFs - chunks%firstMAFIndex 
d462 2
a463 1
    
d702 130
d859 27
d974 1
a974 1
      toSwap = maxloc ( obstructions(i:)%mafs(1) ) + (/ i-1 /)
d983 21
d1123 3
@


2.9
log
@More bug fixes
@
text
@d8 2
d44 1
a44 1
    "$Id: ChunkDivide_m.f90,v 2.8 2001/11/12 20:31:23 livesey Exp $"
d142 3
d147 3
d212 3
a214 2
      chunks(i)%firstMAFIndex = max ( (i-1)*noNonOverlap - overlap, 0 )
      chunks(i)%lastMAFIndex = i*noNonOverlap + overlap - 1
d221 1
a221 1
      chunks(i)%accumulatedMAFs = (i-1)*noNonOverlap
d247 1
d249 2
a250 1
    integer :: NOCOMPLETECHUNKSBELOWHOME ! Used for placing chunks
d255 3
a257 1
    integer :: noChunks                 ! Number of chunks
d265 1
d270 1
d291 1
d312 1
a312 1
        homeMAF = mafRange(1)
d315 1
d317 3
a319 2
      call Hunt ( tpGeodAngle%dpField(1,1,m1:m2), testAngle, homeMAF )
      homeMAF = homeMAF + m1 - 1
d321 1
a321 1
      if ( abs ( tpGeodAngle%dpField(1,1,homeMAF) - &
d327 2
d331 2
a332 17
    ! First work out how many there will be
    select case ( config%maxLengthFamily )
    case ( PHYQ_Angle )
      noChunks = int((maxAngle - minAngle)/config%maxLength) + 2
    case ( PHYQ_Time )
      noChunks = int((maxTime - minTime)/config%maxLength) + 2
    case ( PHYQ_MAFs )
      noChunks = int(noMAFs/config%maxLength) + 2
    end select

    ! Allocate them
    allocate ( chunks(noChunks), stat=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'chunks' )

    ! Now place them, we'll get the chunk ends first, with code that varies
    ! according to how the length was specified.
d334 19
a352 6
      noCompleteChunksBelowHome = int( (homeMAF-1)/nint(config%maxLength))
      ! Work out the boundaries (chunk starts) from there
      chunks(1)%lastMAFIndex = homeMAF - noCompleteChunksBelowHome*nint(config%maxLength)
      do chunk = 2, noChunks
        chunks(chunk)%lastMAFIndex = chunks(chunk-1)%lastMAFIndex + nint(config%maxLength)
      end do      
d356 1
d361 1
d365 1
d368 20
a387 9
      
      ! Now find the chunk ends
      call Allocate_test ( boundaries, noChunks-1, 'boundaries', ModuleName )
      noCompleteChunksBelowHome = &
        & int( (field(homeMAF)-minV)/config%maxLength )
      ! Work out the boundaries (chunk starts) from there
      boundaries(1) = field(homeMAF) - noCompleteChunksBelowHome*config%maxLength
      do chunk = 2, noChunks
        boundaries(chunk-1) = boundaries(chunk-2) + config%maxLength
d389 3
a391 4
      ! Now look for those in the data, set them as the chunk ends
      call Hunt ( field, boundaries, chunks(1:noChunks-1)%lastMAFIndex, &
        & allowTopValue=.true. )
      chunks(noChunks)%lastMAFIndex = noMAFs
d395 4
d402 1
d405 1
d411 2
a412 2
    call Allocate_test ( newFirstMAFs, noChunks, 'newMAFs', ModuleName )
    call Allocate_test ( newLastMAFs, noChunks, 'newMAFs', ModuleName )
d439 1
d441 4
a444 5
    chunks%lastMAFIndex = newFirstMAFs
    chunks%noMAFsLowerOverlap = chunks%firstMAFIndex - newLastMAFs
    chunks%firstMAFIndex = newLastMAFs
    call Deallocate_test ( newFirstMAFs, 'newMAFs', ModuleName )
    call Deallocate_test ( newLastMAFs, 'newMAFs', ModuleName )
d501 1
d519 4
a523 1
      if ( nsons(son) > 1 ) call expr ( subtree(2,son), units, value )
d526 1
a526 3
        config%method = decoration ( son )
        if ( units(1) /= PHYQ_DimensionLess ) &
          & call AnnounceError ( root, BadUnits, son )
d540 1
a540 1
        config%homeModule = decoration ( son )
d558 1
a558 1
        config%criticalModules = decoration ( son )
d587 1
a587 1
        & call AnnounceError ( root, notSpecified, notWanted(i) )
d596 5
d604 1
a604 1
    if ( all ( config%maxGapFamily /= &
d619 3
d636 1
a636 1
        call output (' has inappropriate units' )
d725 1
d728 9
a736 2
    if ( .not. associated ( obstructions ) ) return
    
d871 1
a871 1
    mafRange = max(mafRange, 1)
d930 3
@


2.8
log
@Bug fix check in
@
text
@d42 1
a42 1
    "$Id: ChunkDivide_m.f90,v 2.7 2001/11/10 01:09:41 livesey Exp $"
d817 1
a817 1
    noMAFS = mafRange(1) - mafRange(0) + 1
d843 4
a846 4
            thisOneValid = ( scanMin >= config%scanLowerLimit(0) .and. &
              &              scanMin <= config%scanLowerLimit(1) ) .and. &
              &            ( scanMax >= config%scanUpperLimit(0) .and. &
              &              scanMax <= config%scanUpperLimit(1) )
d875 3
@


2.7
log
@Bug fixes
@
text
@d42 1
a42 1
    "$Id: ChunkDivide_m.f90,v 2.6 2001/11/10 01:01:03 livesey Exp $"
d857 1
a857 1
      call ConvertFlagsToObstructions ( valid, obstructions )
d875 3
@


2.6
log
@Just tidied up
@
text
@d42 1
a42 1
    "$Id: ChunkDivide_m.f90,v 2.5 2001/11/10 00:56:24 livesey Exp $"
d604 1
a604 1
  subroutine ConvertFlagsToObstructions ( valid, obstructions )
d608 1
d624 1
a624 1
          newObstruction%mafs(1) = maf
d626 1
a626 1
          newObstruction%mafs(2) = maf - 1
d635 1
a635 1
      newObstruction%mafs(2) = size(valid)
d875 3
@


2.5
log
@OK, this is getting close to being ready for testing.
@
text
@d42 1
a42 1
    "$Id: ChunkDivide_m.f90,v 2.4 2001/11/10 00:03:44 livesey Exp $"
d230 1
d232 1
a232 1
    type (L1BData_T) :: TAITIME         ! From L1BOA
d234 3
d238 2
a239 4
    real(r8) :: TESTANGLE               ! Angle to check for
    real(r8) :: ANGLEINCREMENT          ! Increment in hunt for homeMAF
    integer :: noChunks                 ! Number of chunks
    integer :: ORBIT                    ! Used to locate homeMAF
d242 9
a250 4
    integer :: FLAG                     ! From ReadL1B
    integer :: CHUNK                    ! Loop counter
    real(r8) :: MINANGLE                 ! Of range in data
    real(r8) :: MAXANGLE                 ! Of range in data
d252 1
d254 4
a258 7
    real(r8), dimension(:), pointer :: BOUNDARIES ! Used in placing chunks
    integer :: NOCOMPLETECHUNKSBELOWHOME ! Used for placing chunks
    integer :: STATUS                   ! From allocate etc.
    real(r8) :: MINV                  ! Either minTime or minAngle
    integer, dimension(:), pointer :: NEWFIRSTMAFS ! For thinking about overlaps
    integer, dimension(:), pointer :: NEWLASTMAFS ! For thinking about overlaps
    integer :: M1, M2                   ! MafRange + 1
d453 1
a453 1
    logical :: GOT(field_first:field_last) = .false.
a456 1
    integer :: GSON                     ! A son of son the ChunkDivide section node
a457 1
    real(rp) :: VALUE(2)                ! Value of expression
d460 2
d784 5
a788 5
    logical, dimension(:), pointer :: VALID ! Flag for each MAF
    logical :: THISONEVALID             ! To go into valid
    logical :: LASTONEVALID             ! To run through valid
    real(r8) :: SCANMAX ! Range of scan each maf
    real(r8) :: SCANMIN ! Range of scan each mif
a789 1
    integer :: MAF                      ! Loop inductor
a790 2
    character(len=10) :: MODNAMESTR     ! Module name
    integer :: FLAG                     ! From L1B
d793 7
d874 3
@


2.4
log
@More work, still got issues!
@
text
@d42 1
a42 1
    "$Id: ChunkDivide_m.f90,v 2.3 2001/11/09 23:17:22 vsnyder Exp $"
a111 1
    integer :: TOTALMAFS                ! Total number of MAFs in file
d128 1
a128 1
      & totalMAFS, obstructions )
d135 1
a135 1
      call ChunkDivide_Orbital ( config, mafRange, totalMAFs, l1bInfo, &
d138 1
a138 1
      call ChunkDivide_Even ( config, mafRange, totalMAFs, l1bInfo, &
d168 1
a168 1
  subroutine ChunkDivide_Even ( config, mafRange, totalMAFs, l1bInfo, &
a171 1
    integer :: TOTALMAFS
d218 1
a218 1
  subroutine ChunkDivide_Orbital ( config, mafRange, totalMAFs, l1bInfo, &
a221 1
    integer, intent(in) :: TOTALMAFS
d253 1
d260 1
a260 1
      & tpGeodAngle, noMAFsRead, flag, firstMAF=mafRange(1), lastMAF=mafRange(2) )
d262 1
a262 1
      & taiTime, noMAFsRead, flag, firstMAF=mafRange(1), lastMAF=mafRange(2) )
d264 2
d267 4
a270 4
    minAngle = minval ( tpGeodAngle%dpField(1,1,:) )
    maxAngle = maxval ( tpGeodAngle%dpField(1,1,:) )
    minTime = minval ( taiTime%dpField(1,1,:) )
    maxTime = maxval ( taiTime%dpField(1,1,:) )
d274 2
a275 2
    orbit = int ( tpGeodAngle%dpField(1,1,1)/360.0 )
    if ( tpGeodAngle%dpField(1,1,1) < 0.0 ) orbit = orbit - 1
d291 1
a291 1
        homeMAF = 1
d295 2
a296 1
      call Hunt ( tpGeodAngle%dpField(1,1,:), testAngle, homeMAF )
d335 1
a335 1
        field => tpGeodAngle%dpField(1,1,:)
d338 1
a338 1
        field => taiTime%dpField(1,1,:)
d365 1
a365 1
    chunks%lastMAFIndex = chunks%lastMAFIndex + mafRange(1) - 1
d377 3
d389 1
a389 1
      call Hunt ( field, field(chunks%firstMAFIndex-mafRange(1)+1) + &
d391 1
a391 1
      call Hunt ( field, field(chunks%firstMAFIndex-mafRange(1)+1) - &
d393 3
a395 3
      ! Correct this again, so they are in the file not the array
      newFirstMAFs = newFirstMAFs + mafRange(1) - 1
      newLastMAFs = newLastMAFs + mafRange(1) - 1
d766 1
a766 1
    & totalMAFs, obstructions )
a772 1
    integer, intent(out) :: TOTALMAFS   ! Total in file
d794 1
a794 1
    call ReadL1BData ( l1bInfo%l1boaId, 'MAFStartTimeTAI', taiTime, totalMAFs, flag )
d865 3
@


2.3
log
@Use Time_Now instead of CPU_TIME
@
text
@d6 1
d9 2
a10 1
  use Intrinsic, only: L_NONE, FIELD_INDICES
d17 2
a18 1
    & L_FIXED, F_MAXGAP, L_ORBITAL, S_CHUNKDIVIDE
d23 1
d42 1
a42 1
    "$Id: ChunkDivide_m.f90,v 2.2 2001/11/09 06:34:39 livesey Exp $"
d111 2
d128 2
a129 1
      & call SurveyL1BData ( processingRange, l1bInfo, config, obstructions )
d136 1
a136 1
      call ChunkDivide_Orbital ( config, processingRange, l1bInfo, &
d139 1
a139 1
      call ChunkDivide_Even ( config, processingRange, l1bInfo, &
d169 1
a169 1
  subroutine ChunkDivide_Even ( config, processingRange, l1bInfo, &
d172 2
a173 1
    type (TAI93_Range_T), intent(in) :: PROCESSINGRANGE
a178 1
    integer :: I                        ! Loop inductor
d181 2
d220 1
a220 1
  subroutine ChunkDivide_Orbital ( config, processingRange, l1bInfo, &
d223 2
a224 1
    type (TAI93_Range_T), intent(in) :: PROCESSINGRANGE
d229 3
d233 169
a401 1
    integer :: I                        ! Loop inductor
d403 5
a407 1
    ! Exectuable code
d542 8
d594 36
d659 3
a661 1
    ! Dummy arguments
a663 4
    ! This routine merges overlapping range obstructions and deletes
    ! wall obstructions inside ranges.  Note that it assumes that the
    ! obstructions are sorted.

d670 1
d726 2
a727 1
    ! Dummy arguments
d761 4
a764 1
  subroutine SurveyL1BData ( processingRange, l1bInfo, config, obstructions )
d768 2
d772 85
d862 3
@


2.2
log
@Minor bug fix, and added Log stuff
@
text
@d24 1
d38 1
a38 1
    "$Id: ChunkDivide_m.f90,v 2.1 2001/11/09 06:08:04 livesey Exp $"
d113 1
a113 1
    if ( timing ) call cpu_time ( t1 )
d520 1
a520 1
    call cpu_time ( t2 )
d542 4
a545 1
! $Log$
@


2.1
log
@First version, not finished
@
text
@d37 1
a37 1
    "$Id: ScanDivide.f90,v 2.17 2001/09/28 23:59:20 pwagner Exp $"
d40 1
a40 1
    "$RCSfile: ScanDivide.f90,v $"
d484 1
a484 1
              exit Middle Loop
d540 2
@

