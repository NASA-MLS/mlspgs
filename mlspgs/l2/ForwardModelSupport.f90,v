head	2.194;
access;
symbols
	v5-02-NRT-19:2.194
	v6-00:2.194
	v5-02-NRT-18:2.194
	v5-02:2.191
	v5-01-NRT-17:2.194
	v5-01-NRT-16:2.194
	v5-01-NRT-15:2.194
	v5-01-NRT-14:2.194
	neuralnetworks-1-0:2.193.0.4
	cfm-single-freq-0-1:2.193.0.2
	v5-01:2.191
	v5-00:2.191
	v4-23-TA133:2.190.0.2
	mus-emls-1-70:2.188.0.4
	rel-1-0-englocks-work:2.188.0.2
	VUMLS1-00:2.184
	VPL1-00:2.184
	V4-22-NRT-08:2.184
	VAM1-00:2.181
	V4-21:2.179.0.2
	V4-13:2.179
	V4-12:2.178
	V4-11:2.178
	V4-10:2.178
	V3-43:2.147
	M4-00:2.164
	V3-41:2.147
	V3-40-PlusGM57:2.147.0.2
	V2-24-NRT-04:2.135
	V3-33:2.154
	V2-24:2.135
	V3-31:2.154
	V3-30-NRT-05:2.152
	cfm-01-00:2.151
	V3-30:2.147
	V3-20:2.147
	V3-10:2.145
	V2-23-NRT-02:2.135
	V2-23:2.135
	V2-22-NRT-01:2.135
	V2-22:2.135
	V2-21:2.133
	V2-20:2.133
	V2-11:2.133
	V2-10:2.133
	V2-00:2.132
	V1-51:2.106
	V1-50:2.106
	V1-45:2.98
	V1-44:2.98
	V1-43:2.91
	V1-32:2.88
	V1-31:2.88
	V1-30:2.84
	V1-13:2.57
	V1-12:2.57
	V1-11:2.57
	V1-10:2.55
	newfwm-feb03:2.56.0.2
	V1-04:2.30
	V1-03:2.30
	V1-02:2.30
	JointForwardModel:2.32.0.2
	V1-00:2.30
	newfwm-sep01:2.12.0.2
	V0-7:2.11;
locks; strict;
comment	@# @;


2.194
date	2021.06.25.21.13.50;	author pwagner;	state Exp;
branches;
next	2.193;

2.193
date	2020.07.05.20.20.19;	author vsnyder;	state Exp;
branches;
next	2.192;

2.192
date	2019.10.07.20.05.16;	author vsnyder;	state Exp;
branches;
next	2.191;

2.191
date	2019.04.24.19.15.25;	author vsnyder;	state Exp;
branches;
next	2.190;

2.190
date	2018.08.06.19.59.49;	author vsnyder;	state Exp;
branches;
next	2.189;

2.189
date	2018.07.27.23.18.48;	author pwagner;	state Exp;
branches;
next	2.188;

2.188
date	2017.11.03.20.59.08;	author pwagner;	state Exp;
branches;
next	2.187;

2.187
date	2017.09.14.18.36.26;	author vsnyder;	state Exp;
branches;
next	2.186;

2.186
date	2017.03.17.17.27.02;	author pwagner;	state Exp;
branches;
next	2.185;

2.185
date	2017.03.17.00.12.24;	author pwagner;	state Exp;
branches;
next	2.184;

2.184
date	2016.05.02.23.30.46;	author vsnyder;	state Exp;
branches;
next	2.183;

2.183
date	2016.03.25.00.39.58;	author pwagner;	state Exp;
branches;
next	2.182;

2.182
date	2016.01.29.01.09.51;	author vsnyder;	state Exp;
branches;
next	2.181;

2.181
date	2015.08.25.17.35.10;	author vsnyder;	state Exp;
branches;
next	2.180;

2.180
date	2015.03.28.02.42.19;	author vsnyder;	state Exp;
branches;
next	2.179;

2.179
date	2014.09.29.20.18.14;	author vsnyder;	state Exp;
branches;
next	2.178;

2.178
date	2014.04.22.00.49.03;	author vsnyder;	state Exp;
branches;
next	2.177;

2.177
date	2014.02.28.00.18.57;	author vsnyder;	state Exp;
branches;
next	2.176;

2.176
date	2014.02.27.02.36.07;	author vsnyder;	state Exp;
branches;
next	2.175;

2.175
date	2014.02.21.20.29.21;	author vsnyder;	state Exp;
branches;
next	2.174;

2.174
date	2014.01.11.01.44.18;	author vsnyder;	state Exp;
branches;
next	2.173;

2.173
date	2013.08.30.02.45.39;	author vsnyder;	state Exp;
branches;
next	2.172;

2.172
date	2013.08.23.00.32.47;	author pwagner;	state Exp;
branches;
next	2.171;

2.171
date	2013.08.16.02.34.46;	author vsnyder;	state Exp;
branches;
next	2.170;

2.170
date	2013.08.09.01.03.59;	author vsnyder;	state Exp;
branches;
next	2.169;

2.169
date	2013.07.25.00.23.41;	author vsnyder;	state Exp;
branches;
next	2.168;

2.168
date	2013.07.19.01.19.46;	author vsnyder;	state Exp;
branches;
next	2.167;

2.167
date	2013.07.12.23.44.28;	author vsnyder;	state Exp;
branches;
next	2.166;

2.166
date	2013.07.12.23.25.28;	author vsnyder;	state Exp;
branches;
next	2.165;

2.165
date	2013.06.12.02.37.14;	author vsnyder;	state Exp;
branches;
next	2.164;

2.164
date	2012.08.16.18.07.43;	author pwagner;	state Exp;
branches;
next	2.163;

2.163
date	2012.08.01.00.10.02;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2012.05.01.22.22.58;	author vsnyder;	state Exp;
branches;
next	2.161;

2.161
date	2012.03.28.00.56.49;	author vsnyder;	state Exp;
branches;
next	2.160;

2.160
date	2012.03.07.02.13.18;	author vsnyder;	state Exp;
branches;
next	2.159;

2.159
date	2011.08.20.02.03.34;	author vsnyder;	state Exp;
branches;
next	2.158;

2.158
date	2011.07.29.02.00.44;	author vsnyder;	state Exp;
branches;
next	2.157;

2.157
date	2011.05.10.17.11.28;	author pwagner;	state Exp;
branches;
next	2.156;

2.156
date	2011.05.09.18.09.30;	author pwagner;	state Exp;
branches;
next	2.155;

2.155
date	2011.03.31.19.47.54;	author vsnyder;	state Exp;
branches;
next	2.154;

2.154
date	2011.01.29.00.52.51;	author vsnyder;	state Exp;
branches;
next	2.153;

2.153
date	2010.11.08.19.26.22;	author pwagner;	state Exp;
branches;
next	2.152;

2.152
date	2010.08.27.06.20.47;	author yanovsky;	state Exp;
branches;
next	2.151;

2.151
date	2010.06.07.23.30.12;	author vsnyder;	state Exp;
branches;
next	2.150;

2.150
date	2010.04.30.01.53.26;	author vsnyder;	state Exp;
branches;
next	2.149;

2.149
date	2010.03.26.23.16.12;	author vsnyder;	state Exp;
branches;
next	2.148;

2.148
date	2010.02.25.18.17.48;	author pwagner;	state Exp;
branches;
next	2.147;

2.147
date	2010.02.09.16.22.32;	author pwagner;	state Exp;
branches;
next	2.146;

2.146
date	2010.01.22.01.00.20;	author vsnyder;	state Exp;
branches;
next	2.145;

2.145
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.144;

2.144
date	2009.04.16.21.56.43;	author pwagner;	state Exp;
branches;
next	2.143;

2.143
date	2008.09.30.22.37.51;	author vsnyder;	state Exp;
branches;
next	2.142;

2.142
date	2008.08.21.23.42.46;	author vsnyder;	state Exp;
branches;
next	2.141;

2.141
date	2008.07.30.19.08.00;	author vsnyder;	state Exp;
branches;
next	2.140;

2.140
date	2008.06.06.22.52.53;	author pwagner;	state Exp;
branches;
next	2.139;

2.139
date	2008.05.20.00.28.06;	author vsnyder;	state Exp;
branches;
next	2.138;

2.138
date	2008.05.02.00.33.30;	author vsnyder;	state Exp;
branches;
next	2.137;

2.137
date	2008.05.01.01.56.33;	author vsnyder;	state Exp;
branches;
next	2.136;

2.136
date	2007.11.07.03.10.48;	author vsnyder;	state Exp;
branches;
next	2.135;

2.135
date	2007.10.03.23.59.04;	author vsnyder;	state Exp;
branches;
next	2.134;

2.134
date	2006.11.29.01.08.58;	author vsnyder;	state Exp;
branches;
next	2.133;

2.133
date	2006.07.20.23.39.53;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2006.06.03.01.46.20;	author vsnyder;	state Exp;
branches;
next	2.131;

2.131
date	2006.05.11.19.37.32;	author pwagner;	state Exp;
branches;
next	2.130;

2.130
date	2006.04.18.00.08.45;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2006.03.30.18.58.47;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2006.03.22.02.23.46;	author vsnyder;	state Exp;
branches;
next	2.127;

2.127
date	2006.02.23.00.52.09;	author vsnyder;	state Exp;
branches;
next	2.126;

2.126
date	2006.02.08.21.33.43;	author vsnyder;	state Exp;
branches;
next	2.125;

2.125
date	2006.02.07.00.19.07;	author vsnyder;	state Exp;
branches;
next	2.124;

2.124
date	2006.01.11.01.56.48;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2006.01.04.21.54.26;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2005.12.29.01.11.08;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2005.12.22.21.08.15;	author vsnyder;	state Exp;
branches;
next	2.120;

2.120
date	2005.11.02.21.37.19;	author vsnyder;	state Exp;
branches;
next	2.119;

2.119
date	2005.10.14.23.14.28;	author vsnyder;	state Exp;
branches;
next	2.118;

2.118
date	2005.09.16.23.39.07;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2005.09.03.01.20.41;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2005.08.03.18.07.39;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2005.06.29.00.43.45;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2005.06.14.20.41.55;	author pwagner;	state Exp;
branches;
next	2.113;

2.113
date	2005.06.03.02.07.56;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2005.05.27.17.56.07;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2005.05.26.22.35.48;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2005.03.28.20.29.09;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2005.02.17.02.34.41;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2005.02.16.23.16.24;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2005.01.27.21.23.13;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2004.12.28.00.22.34;	author vsnyder;	state Exp;
branches;
next	2.105;

2.105
date	2004.12.13.20.15.40;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2004.11.16.02.56.01;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2004.11.05.19.39.06;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2004.11.04.03.42.33;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2004.11.01.20.27.55;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2004.10.13.02.24.56;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2004.10.06.21.14.37;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2004.08.05.21.01.59;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2004.08.04.23.19.57;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2004.07.22.20.40.10;	author cvuu;	state Exp;
branches;
next	2.95;

2.95
date	2004.07.17.02.27.24;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2004.07.08.02.35.46;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2004.06.12.00.42.35;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2004.05.18.01.25.14;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2004.05.01.04.05.50;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2004.03.22.18.24.40;	author livesey;	state Exp;
branches;
next	2.89;

2.89
date	2004.03.05.18.32.55;	author livesey;	state Exp;
branches;
next	2.88;

2.88
date	2003.10.29.00.44.33;	author livesey;	state Exp;
branches;
next	2.87;

2.87
date	2003.10.28.23.44.43;	author livesey;	state Exp;
branches;
next	2.86;

2.86
date	2003.10.15.16.59.25;	author pwagner;	state Exp;
branches;
next	2.85;

2.85
date	2003.09.11.23.15.42;	author livesey;	state Exp;
branches;
next	2.84;

2.84
date	2003.09.03.16.07.52;	author cvuu;	state Exp;
branches;
next	2.83;

2.83
date	2003.08.27.20.31.07;	author livesey;	state Exp;
branches;
next	2.82;

2.82
date	2003.08.21.21.15.18;	author cvuu;	state Exp;
branches;
next	2.81;

2.81
date	2003.08.19.05.51.31;	author livesey;	state Exp;
branches;
next	2.80;

2.80
date	2003.08.15.23.58.20;	author vsnyder;	state Exp;
branches;
next	2.79;

2.79
date	2003.08.15.20.28.44;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2003.08.14.20.25.06;	author livesey;	state Exp;
branches;
next	2.77;

2.77
date	2003.08.13.00.49.40;	author livesey;	state Exp;
branches;
next	2.76;

2.76
date	2003.08.12.18.16.13;	author livesey;	state Exp;
branches;
next	2.75;

2.75
date	2003.08.12.17.12.08;	author livesey;	state Exp;
branches;
next	2.74;

2.74
date	2003.08.11.22.35.34;	author livesey;	state Exp;
branches;
next	2.73;

2.73
date	2003.07.21.18.13.44;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2003.07.18.22.54.35;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2003.07.16.21.51.29;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2003.07.16.01.27.35;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2003.07.16.01.06.36;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2003.07.15.22.10.59;	author livesey;	state Exp;
branches;
next	2.67;

2.67
date	2003.07.15.18.17.50;	author livesey;	state Exp;
branches;
next	2.66;

2.66
date	2003.06.30.22.55.01;	author cvuu;	state Exp;
branches;
next	2.65;

2.65
date	2003.06.26.23.15.07;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2003.06.20.19.37.06;	author pwagner;	state Exp;
branches;
next	2.63;

2.63
date	2003.06.18.01.57.12;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2003.06.09.22.50.13;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2003.05.29.16.42.19;	author livesey;	state Exp;
branches;
next	2.60;

2.60
date	2003.05.05.23.00.34;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2003.04.11.00.48.13;	author dwu;	state Exp;
branches;
next	2.58;

2.58
date	2003.04.02.21.49.33;	author jonathan;	state Exp;
branches;
next	2.57;

2.57
date	2003.03.07.03.16.45;	author livesey;	state Exp;
branches;
next	2.56;

2.56
date	2003.02.08.05.28.47;	author vsnyder;	state Exp;
branches
	2.56.2.1;
next	2.55;

2.55
date	2003.02.06.22.04.48;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2003.02.06.00.45.51;	author livesey;	state Exp;
branches;
next	2.53;

2.53
date	2003.02.06.00.15.01;	author jonathan;	state Exp;
branches;
next	2.52;

2.52
date	2003.02.05.23.27.32;	author jonathan;	state Exp;
branches;
next	2.51;

2.51
date	2003.02.05.21.56.39;	author livesey;	state Exp;
branches;
next	2.50;

2.50
date	2003.02.04.22.02.18;	author jonathan;	state Exp;
branches;
next	2.49;

2.49
date	2003.02.04.19.03.06;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2003.01.30.17.28.21;	author jonathan;	state Exp;
branches;
next	2.47;

2.47
date	2003.01.29.01.48.29;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2003.01.27.16.51.08;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2003.01.26.04.42.55;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2003.01.16.00.55.41;	author jonathan;	state Exp;
branches;
next	2.43;

2.43
date	2003.01.13.17.17.04;	author jonathan;	state Exp;
branches;
next	2.42;

2.42
date	2003.01.03.21.03.02;	author pwagner;	state Exp;
branches;
next	2.41;

2.41
date	2002.11.22.12.20.13;	author mjf;	state Exp;
branches;
next	2.40;

2.40
date	2002.11.15.01.33.24;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2002.10.18.22.44.11;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2002.10.18.18.01.58;	author livesey;	state Exp;
branches;
next	2.37;

2.37
date	2002.10.08.17.36.20;	author pwagner;	state Exp;
branches;
next	2.36;

2.36
date	2002.09.25.20.08.26;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2002.08.21.23.31.52;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2002.08.04.16.02.23;	author mjf;	state Exp;
branches;
next	2.33;

2.33
date	2002.07.17.06.02.36;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2002.06.12.17.01.54;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2002.05.14.22.31.31;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2002.03.21.16.42.34;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2002.03.15.21.22.31;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2002.03.14.23.30.21;	author pwagner;	state Exp;
branches;
next	2.27;

2.27
date	2002.03.12.23.44.12;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2002.03.07.17.17.57;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2002.02.14.23.02.43;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2002.02.13.00.08.50;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2002.02.08.22.52.21;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2002.02.04.23.24.49;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2002.01.21.21.13.28;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.12.17.18.26.37;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2001.11.29.00.27.56;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2001.11.28.03.50.07;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2001.11.15.23.49.40;	author jonathan;	state Exp;
branches;
next	2.16;

2.16
date	2001.11.15.20.55.55;	author jonathan;	state Exp;
branches;
next	2.15;

2.15
date	2001.11.08.00.12.52;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.10.31.15.26.59;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.10.02.20.34.50;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.09.04.15.58.02;	author jonathan;	state Exp;
branches;
next	2.11;

2.11
date	2001.07.17.22.36.19;	author jonathan;	state Exp;
branches;
next	2.10;

2.10
date	2001.07.16.22.07.21;	author jonathan;	state Exp;
branches;
next	2.9;

2.9
date	2001.07.12.23.27.48;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.07.09.22.51.37;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2001.06.21.20.06.42;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2001.06.21.15.05.20;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.06.19.22.48.42;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2001.06.04.22.42.24;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.05.31.22.08.06;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.05.30.23.05.39;	author pwagner;	state Exp;
branches;
next	2.1;

2.1
date	2001.05.29.23.18.18;	author livesey;	state Exp;
branches;
next	;

2.56.2.1
date	2003.02.22.00.47.26;	author vsnyder;	state Exp;
branches;
next	2.56.2.2;

2.56.2.2
date	2003.04.08.23.40.50;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.194
log
@Forbid setting trapezoid to /correct/ because it isnt
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module ForwardModelSupport

  ! Set up the forward model stuff.
  use MLSL2Options, only: MLSL2Message

  implicit none
  private
  public :: ConstructForwardModelConfig, ForwardModelGlobalSetup, &
    & CreateBinSelectorFromMLSCFInfo, PrintForwardModelTiming, &
    & ResetForwardModelTiming, ShowFwdModelNames, FillFwdModelTimings

  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: ModuleName= &
    & "$RCSfile: ForwardModelSupport.f90,v $"
  !---------------------------------------------------------------------------

  ! Error codes
  logical, public    :: OnlyWarnIfTangentNotSubset = .false.

  integer, parameter :: BadBinSelectors        = 1
  integer, parameter :: BadHeightUnit          = BadBinSelectors + 1
  integer, parameter :: BadMoleculeGroup       = BadHeightUnit + 1
  integer, parameter :: BadQuantityType        = BadMoleculeGroup + 1
  integer, parameter :: CloudHas               = BadQuantityType + 1
  integer, parameter :: CloudLBL               = CloudHas + 1
  integer, parameter :: CloudNeeds             = CloudLBL + 1
  integer, parameter :: CloudNot               = CloudNeeds + 1
  integer, parameter :: DerivSansMolecules     = CloudNot  + 1
  integer, parameter :: DuplicateMolecule      = DerivSansMolecules + 1
  integer, parameter :: FirstSansFirst1        = DuplicateMolecule + 1
  integer, parameter :: FirstSansFirst2        = FirstSansFirst1 + 1
  integer, parameter :: Hess_notJac            = FirstSansFirst2 + 1
  integer, parameter :: IncompleteBinSelectors = Hess_notJac + 1
  integer, parameter :: IncompleteFullFwm      = IncompleteBinSelectors + 1
  integer, parameter :: IncompleteLinearFwm    = IncompleteFullFwm + 1
  integer, parameter :: IrrelevantFwmParameter = IncompleteLinearFwm + 1
  integer, parameter :: LBLandPFA              = IrrelevantFwmParameter + 1
  integer, parameter :: LinearSidebandHasUnits = LBLandPFA + 1
  integer, parameter :: LineNotMolecule        = LinearSidebandHasUnits + 1
  integer, parameter :: LineParamTwice         = LineNotMolecule + 1
  integer, parameter :: MIFTransformation_signals = LineParamTwice + 1
  integer, parameter :: NeedBothXYStar         = MIFTransformation_signals + 1
  integer, parameter :: NeedL2PCFiles          = NeedBothXYStar + 1
  integer, parameter :: NegativePhiWindow      = NeedL2PCFiles + 1
  integer, parameter :: Nested                 = NegativePhiWindow + 1
  integer, parameter :: NoArray                = Nested + 1
  integer, parameter :: NoBetaGroup            = NoArray + 1
  integer, parameter :: NoMolecule             = NoBetaGroup + 1
  integer, parameter :: NoPolarizedAndPFA      = NoMolecule + 1
  integer, parameter :: PFANotMolecule         = NoPolarizedAndPFA + 1
  integer, parameter :: PFATwice               = PFANotMolecule + 1
  integer, parameter :: PolarizedAndAllLines   = PFATwice + 1
  integer, parameter :: SecondSansFirst        = PolarizedAndAllLines  + 1
  integer, parameter :: SecondSansSecond1      = SecondSansFirst + 1
  integer, parameter :: SecondSansSecond2      = SecondSansSecond1 + 1
  integer, parameter :: TangentNotSubset       = SecondSansSecond2 + 1
  integer, parameter :: TooManyCosts           = TangentNotSubset + 1
  integer, parameter :: TooManyHeights         = TooManyCosts + 1
  integer, parameter :: WrongUnitsForWindow    = TooManyHeights + 1

  integer :: Error            ! Error level -- 0 = OK

contains ! =====     Public Procedures     =============================

  ! ------------------------------------  ForwardModelGlobalSetup  -----
  subroutine ForwardModelGlobalSetup ( Root, any_errors, fileDataBase )
    ! Process the forwardModel specification to produce ForwardModelInfo.

    use Antennapatterns_M, only: Open_Antenna_Patterns_File, &
      & Read_Antenna_Patterns_File, Close_Antenna_Patterns_File
    use Filtershapes_M, only: Open_Filter_Shapes_File, &
      & Read_Filter_Shapes_File, Read_Dacs_Filter_Shapes_File, &
      & Close_Filter_Shapes_File
    use Init_Tables_Module, only: F_Antennapatterns, F_Dacsfiltershapes, &
      & F_Filtershapes, F_L2pc, F_Mietables, F_PfaFiles, F_Pointinggrids, &
      & F_Polygon
    use Intrinsic, only: L_Ascii, L_HDF
    use L2parinfo, only: Parallel
    use L2pc_M, only: ReadcompleteHDF5l2pcFile
    use MLSCommon, only: MLSFile_T
    use MLSPcf2, only: MLSPcf_Antpats_Start, MLSPcf_Filtshps_Start, &
      & MLSPcf_Dacsfltsh_Start, MLSPcf_Ptggrids_Start, &
      & MLSPcf_Polygon_Start, &
      & MLSPcf_L2pc_Start, MLSPcf_L2pc_End, &
      & MLSPcf_Mietables_Start, &
      & MLSPcf_Pfa_Start, MLSPcf_Pfa_End
    use Moretree, only: Get_Field_Id
    use PfaDatabase_M, only: Process_Pfa_File
    use Pointinggrid_M, only: Close_Pointing_Grid_File, &
      & Open_Pointing_Grid_File, Read_Pointing_Grid_File
    use Polygon_M, only: Close_Polygon_File, Open_Polygon_File, &
      & Read_Polygon_File
    use Read_Mie_M, only: Read_Mie
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Nsons, Sub_Rosa, Subtree

    integer, intent(in) :: Root         ! of the forwardModel specification.
    !                                     Indexes a "spec_args" vertex.
    integer, intent(out) :: any_errors  ! non-zero means trouble
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE

    ! Internal variables
    logical, parameter :: DEBUG = .false.
    integer :: FileIndex                ! In the string table
    character(len=255) :: FileName      ! Duh
    integer :: I, J                     ! Loop inductor, subscript
    integer :: Lun                      ! Unit number for reading a file
    integer :: Me = -1                  ! String index for trace
    type (MLSFile_T), pointer   :: MLSFile
    integer :: Son                      ! Some subtree of root.
    integer :: Version
    integer, save :: last_l2pc = mlspcf_l2pc_start - 1
    integer, save :: last_pfa  = mlspcf_pfa_start  - 1

    ! Error message codes

    ! We skip this stage if we're just a master task
    any_errors = 0                      ! At least clear error if we're master
    if ( parallel%master .and. .not. parallel%fwmParallel ) return

    error = 0
    call trace_begin ( me, 'ForwardModelGlobalSetup', root, &
      & cond=toggle(gen) .and. levels(gen) > 0 )

    ! "Root" now indexes an n_spec_args vertex.  See "Configuration file
    ! parser users' guide" for pictures of the trees being analyzed.
    ! Collect data from the fields.

    do i = 2, nsons(root)
      Version = 1
      son = subtree(i,root)
      select case ( get_field_id(son) )
      case ( f_antennaPatterns )
        do j = 2, nsons(son)
          call get_file_name ( mlspcf_antpats_start, &
            & get_field_id(son), filedatabase, MLSFile, &
            & 'Antenna Patterns File not found in PCF' )
          call open_antenna_patterns_file ( fileName, lun )
          call read_antenna_patterns_file ( lun, subtree(j,son) )
          call close_antenna_patterns_file ( lun )
        end do
      case ( f_DACSfilterShapes )
        do j = 2, nsons(son)
          call get_file_name ( mlspcf_dacsfltsh_start, &
            & get_field_id(son), filedatabase, MLSFile, &
            & 'DACS Filter Shapes File not found in PCF' )
          call open_filter_shapes_file ( fileName, lun, fileIndex )
          call read_DACS_filter_shapes_file ( lun, fileIndex, subtree(j,son) )
          call close_filter_shapes_file ( lun )
        end do
      case ( f_filterShapes )
        do j = 2, nsons(son)
          call get_file_name ( mlspcf_filtshps_start, &
            & get_field_id(son), filedatabase, MLSFile, &
            & 'Filter Shapes File not found in PCF' )
          call open_filter_shapes_file ( fileName, lun, fileIndex )
          call read_filter_shapes_file ( lun, fileIndex, subtree(j,son) )
          call close_filter_shapes_file ( lun )
        end do
      case ( f_l2pc )
        last_l2pc = last_l2pc + 1
        do j = 2, nsons(son)
          call get_file_name ( last_l2pc, &
            & get_field_id(son), filedatabase, MLSFile, &
            & 'L2PC File not found in PCF', mlspcf_l2pc_end )
          call ReadCompleteHDF5L2PCFile ( MLSFile, subtree(j,son) )
        end do
      case ( f_MieTables )
        do j = 2, nsons(son)
          call get_file_name ( mlspcf_MieTables_start, &
            & get_field_id(son), filedatabase, MLSFile, &
            & 'Mie tables File not found in PCF' )
          call read_mie ( fileName )
        end do
      case ( f_PFAFiles )
        last_pfa = last_pfa + 1
        do j = 2, nsons(son)
          call get_file_name ( last_pfa, &
            & get_field_id(son), filedatabase, MLSFile, &
            & 'PFA File not found in PCF', mlspcf_pfa_end )
          if ( index ( fileName, '.h5' ) /= 0 ) then
            if ( process_PFA_File ( filename, &
            & subtree(j,son) ) /= 0 ) continue
          endif
        end do
      case ( f_pointingGrids )
        do j = 2, nsons(son)
          call get_file_name ( mlspcf_ptggrids_start, &
            & get_field_id(son), filedatabase, MLSFile, &
            & 'Pointing Grids File not found in PCF' )
          call open_pointing_grid_file ( fileName, lun )
          call read_pointing_grid_file ( lun, subtree(j,son) )
          call close_pointing_grid_file ( lun )
        end do
      case ( f_polygon )
        do j = 2, nsons(son)
          call get_file_name ( mlspcf_polygon_start, &
            & get_field_id(son), filedatabase, MLSFile, &
            & 'Polygon File not found in PCF' )
          call open_polygon_file ( fileName, lun )
          call read_polygon_file ( lun, subtree(j,son) )
          call close_polygon_file ( lun )
        end do
      case default
        ! Can't get here if the type checker worked
      end select
    end do

    call trace_end ( 'ForwardModelGlobalSetup', &
      & cond=toggle(gen) .and. levels(gen) > 0 )
    any_errors = error

  contains

    ! ............................................  Get_File_Name  .....
    subroutine Get_File_Name ( pcfCode, &
      & fileType, fileDataBase, MLSFile, MSG, pcfEndCode )
      use HDF, only: Dfacc_Rdonly
      use Init_Tables_Module, only: Field_Indices
      use MLSCommon, only: MLSFile_T
      use MLSFiles, only: HDFversion_5, &
        & AddinitializeMLSFile, Getpcfromref, Split_Path_Name
      use MLSL2options, only: Toolkit
      use Sdptoolkit, only: Pgs_Pc_Getreference
      use String_Table, only: Get_String
      ! Dummy args
      integer, intent(in) :: pcfCode
      integer, intent(in) :: fileType ! f_l2pc, f_antennaPatterns, etc.
      type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
      type (MLSFile_T), pointer   :: MLSFile
      character(len=*), intent(in) :: MSG ! in case of error
      integer, intent(in), optional :: pcfEndCode
      ! Internal variables
      character(len=255) :: fileTypeStr, PCFFileName, path, shortName
      integer :: returnStatus             ! non-zero means trouble
      integer :: mypcfEndCode
      ! Executable
      mypcfEndCode = 0
      lun = 0
      call get_string ( sub_rosa(subtree(j,son)), shortName, strip=.true. )
      fileName = shortName
      call get_string ( field_indices(fileType), fileTypeStr, strip=.true. )
      if ( TOOLKIT ) then
        mypcfEndCode = pcfCode
        if ( present(pcfEndCode) ) mypcfEndCode = pcfEndCode
        if ( fileName == ' ' ) then
          returnStatus = Pgs_pc_getReference(pcfCode, version, &
            & fileName)
          lun = pcfCode
        else
          PCFFileName = fileName
          call split_path_name ( PCFFileName, path, fileName )
          lun = GetPCFromRef(fileName, pcfCode, &
            & mypcfEndCode, &
            & TOOLKIT, returnStatus, Version, DEBUG, &
            & exactName=PCFFileName)
          if ( returnStatus /= 0 ) then
            call AnnounceError ( 0, son, extraMessage=MSG )
          else
            fileName = PCFFileName
          end if
        end if
      end if
      if ( fileType == f_l2pc ) then
        MLSFile => AddInitializeMLSFile(filedatabase, &
          & content=fileTypeStr, &
          & name=Filename, shortName=shortName, &
          & type=l_hdf, access=dfacc_rdonly, HDFVersion=HDFVERSION_5)
      else
        MLSFile => AddInitializeMLSFile(filedatabase, &
          & content=fileTypeStr, &
          & name=Filename, shortName=shortName, &
          & type=l_ascii, access=dfacc_rdonly)
      endif      
      MLSFile%PCFId = lun
    end subroutine Get_File_Name

  end subroutine ForwardModelGlobalSetup

  ! -----------------------------  CreateBinSelectorFromMLSCFInfo  -----
  type (BinSelector_T) function CreateBinSelectorFromMLSCFInfo ( root ) &
    & result ( binSelector )

    use Expr_M, only: Expr
    use Init_Tables_Module, only: Field_First, Field_Last
    use Init_Tables_Module, only: L_Namefragment, L_Vmr, L_Temperature, &
      & L_Latitude, L_Sza
    use Init_Tables_Module, only: F_Cost, F_Height, F_Molecule, F_Type, &
      & F_Namefragment, F_Exact
    use Intrinsic, only: Phyq_Angle, Phyq_Dimensionless, Phyq_Invalid, &
      & Phyq_Pressure, Phyq_Temperature, Phyq_Vmr
    use L2pc_M, only: Binselector_T, Binselectors, Createdefaultbinselectors
    use MLSKinds, only: R8
    use Moretree, only: Get_Field_Id, Get_Boolean
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree

    integer, intent(in) :: ROOT         ! Tree node
    ! Local variables
    integer :: SON                      ! Tree node
    integer :: GSON                     ! Tree node
    integer :: I                        ! Loop counters
    integer :: FIELD                    ! Field identifier
    logical :: GOT(field_first:field_last) ! "Got this field already"
    integer :: EXPR_UNITS(2)            ! Units from expr
    real(r8) :: VALUE(2)                ! Value from expr
    integer :: COSTUNIT                 ! Units for cost
    integer :: WANTEDUNIT               ! Units wanted for cost

    ! Executable code

    ! Make sure the default ones are created first
    if ( .not. associated ( binSelectors ) ) &
      & call CreateDefaultBinSelectors

    ! Set up appropriate initial values
    binSelector%molecule = 0
    binSelector%nameFragment = 0
    binSelector%heightRange = 0.0
    binSelector%cost = 0.0
    binSelector%exact = .false.

    do i = 2, nsons(root)               ! Skip binSelector command
      son = subtree ( i, root )
      field = get_field_id ( son )
      if ( nsons(son) == 2 ) gson = subtree(2,son)
      got(field) = .true.
      select case ( field )
      case ( f_type )
        binSelector%selectorType = decoration(gson)
      case ( f_molecule )
        binSelector%molecule = decoration(gson)
      case ( f_nameFragment )
        binSelector%nameFragment = sub_rosa(gson)
      case ( f_exact )
        binSelector%exact = get_boolean(gson)
      case ( f_height )
        if ( nsons(son) > 2 ) call AnnounceError ( TooManyHeights, son )
        call expr ( gson, expr_units, value )
        if ( any ( expr_units /= phyq_pressure .and. expr_units /= phyq_dimensionless ) .or. &
          & all ( expr_units /= phyq_pressure ) ) &
          & call AnnounceError ( BadHeightUnit, son )
        binSelector%heightRange = value
      case ( f_cost )
        if ( nsons(son) > 2 ) call AnnounceError ( TooManyCosts, son )
        call expr ( gson, expr_units, value )
        ! Units checking is below
        binSelector%cost = value(1)
        costUnit = expr_units(1)
      end select
    end do

    wantedUnit = phyq_invalid
    select case ( binSelector%selectorType )
    case ( l_vmr )
      wantedUnit = phyq_vmr
    case ( l_temperature )
      wantedUnit = phyq_temperature
    case ( l_latitude, l_sza )
      wantedUnit = phyq_angle
    end select

    ! Just check a few last details
    if ( ( binSelector%selectorType == l_vmr ) &
      & .and. ( .not. got(f_molecule) ) ) call AnnounceError ( &
      & NoMolecule, son )
    if ( ( binSelector%selectorType == l_nameFragment ) .and. &
      & ( .not. got(f_nameFragment) ) ) call AnnounceError ( &
      0, son, extraMessage='No name fragment supplied' )
    if ( ( wantedUnit /= phyq_invalid ) .and. ( wantedUnit /= costUnit ) ) &
      & call AnnounceError ( 0, son, extraMessage='Wrong units for cost' )

  end function CreateBinSelectorFromMLSCFInfo

  ! --------------------------------  ConstructForwardModelConfig  -----
  type (forwardModelConfig_T) function ConstructForwardModelConfig &
    & ( name, root, global ) result ( info )
    ! Process the forwardModel specification to produce ForwardModelConfig to
    ! add to the database

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, &
      & Test_Allocate
    use Declaration_Table, only: Range, Value_T
    use Expr_M, only: Expr
    use Forwardmodelconfig, only: Dump, Forwardmodelconfig_T, &
      & Linecenter, Linewidth, Linewidth_Tdep, &
      & Nullifyforwardmodelconfig, Spectroparam_T
    ! use HighOutput, only: OutputnamedValue
    use Init_Tables_Module, only: Field_First, Field_Last
    use Init_Tables_Module, only: L_Full, L_Scan, L_Linear, L_Cloudfull, L_Hybrid, &
      & L_Polarlinear
    use Init_Tables_Module, only: F_Alllinesforradiometer, &
      & F_Alllinesincatalog, F_Atmos_Der, F_Atmos_Second_Der, &
      & F_Binselectors, F_Channels, F_Cloud_Der, F_Default_Spectroscopy, &
      & F_Differentialscan, F_Do_1d, F_Do_Baseline, F_Do_Conv, &
      & F_Do_Freq_Avg, F_Forcesidebandfraction, F_Frqtol, &
      & F_Ignorehessian, F_Incl_Cld, F_Integrationgrid, F_I_Saturation, &
      & F_Linearsideband, F_Linecenter, F_Linewidth, F_Linewidth_Tdep, &
      & F_Lockbins, F_Lsblblmolecules, F_Lsbpfamolecules, F_MIFTangent, &
      & F_Module, F_Moleculederivatives, F_Molecules, &
      & F_Moleculesecondderivatives, F_Nabterms, F_Nazimuthangles, &
      & F_Ncloudspecies, F_Nmodelsurfs, F_No_Dup_Mol, F_Nscatteringangles, &
      & F_Nsizebins, F_Pathnorm, F_Phiwindow, F_Nomagneticfield, F_Polarized, &
      & F_ReferenceMIF, F_Refract, F_Scanaverage, F_Signals, F_Skipoverlaps, &
      & F_Specificquantities, F_Spect_Der, F_Switchingmirror, F_Tangentgrid, &
      & F_Temp_Der, F_Tolerance, F_TransformMIFextinction, F_TransformMIFrhi, &
      & F_Trapezoid, F_TscatMIF, F_Type, F_Usblblmolecules, F_Usbpfamolecules, &
      & F_Usetscat, F_Xstar, F_Ystar
    use Intrinsic, only: L_None, L_Clear, L_PTAN, L_Wrong, Phyq_Angle, &
      & Phyq_Dimensionless, Phyq_ProFiles
    use, Intrinsic :: Iso_C_Binding, only: C_Intptr_T, C_Loc
    use L2pc_M, only: Binselectors, Defaultselector_Latitude, L2pcDatabase, &
      & Createdefaultbinselectors
    use MLSKinds, only: R8
    use MLSL2options, only: L2cfnode
    use MLSMessagemodule, only: MLSMSG_Error, MLSMSG_Warning
    use MLSNumerics, only: Hunt
    use MLSSignals_M, only: Signals
    use Molecules, only: L_Cloudice
    use Moretree, only: Get_Boolean, Get_Field_Id
    use MLSStringlists, only: Switchdetail
    use Parse_Signal_M, only: Parse_Signal
    use String_Table, only: Get_String
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use Tree, only: Decoration, Node_Id, Nsons, Null_Tree, Sub_Rosa, Subtree
    use Tree_Types, only: N_Array
    use VgridsDatabase, only: Vgrids

    integer, intent(in) :: NAME         ! The name of the config
    integer, intent(in) :: ROOT         ! of the forwardModel specification.
    !                                     Indexes either a "named" or
    !                                     "spec_args" vertex. Local variables
    logical, intent(in) :: GLOBAL       ! Goes into info%globalConfig

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: B                        ! Index of a beta group
    logical, dimension(:), pointer :: Channels   ! From Parse_Signal
    integer :: DerivTree                ! Tree index of f_MoleculeDerivatives
    integer :: Expr_Type                ! Type of PhiWindow, num_value or range
    integer :: Expr_Units(2)            ! Units of value returned by EXPR
    integer :: Field                    ! Field index -- f_something
    integer :: Found                    ! Where something is found in a list
    logical :: Got(field_first:field_last)   ! "Got this field already"
    integer :: GSON                     ! Son of son
    integer :: I, J, K, M               ! Subscript and loop inductor.
    integer :: LBLTrees(2)              ! Tree indices of f_[lu]sbLBLMolecules
    type(spectroParam_t), pointer :: LineStru(:)
    integer :: LineTrees(3)             ! Tree indices of f_line...
    integer :: Me = -1                  ! String index for trace
    integer :: MoleculeTree             ! Tree index of f_Molecules
    integer, dimension(:), pointer :: MyMolecules ! In a LineTree
    integer :: NELTS                    ! Number of elements of an array tree
    integer :: NGroup                   ! Number of beta groups
    logical :: No_Dup_Mol               ! Duplicate molecules => error
    integer :: NumPFA, NumLBL           ! Numbers of such molecules in a beta group
    integer :: PFATrees(2)              ! Tree indices of f_[lu]sbPFAMolecules
    integer :: S                        ! Sideband index, for PFAtrees
    integer :: S1, S2                   ! Sideband Start/Stop (1..2, not -1..1).
    integer :: SecondDerivTree          ! Tree index of f_MoleculeSecondDerivatives
    integer :: SIDEBAND                 ! Returned from Parse_Signal
    integer, dimension(:), pointer :: SIGNALINDS ! From Parse_Signal
    character (len=80) :: SIGNALSTRING  ! E.g. R1A....
    integer :: Son                      ! Some subtree of root.
    integer :: STATUS                   ! From allocates etc.
    integer :: TANGENT                  ! Loop counter
    integer, pointer :: TempLBL(:), TempPFA(:) ! Used to separate LBL and PFA
    integer :: TheTree                  ! Either pfaTrees(s) or lblTrees(s)
    integer :: THISMOLECULE             ! Tree index.
    real (r8) :: Value(2)               ! Value returned by EXPR
    type(value_t), allocatable :: Values(:) ! returned by EXPR
    integer :: WANTED                   ! Which signal do we want?

    ! Nullify some pointers so allocate_test doesn't try to deallocate them.
    ! Don't initialize them with =>NULL() because that makes them SAVEd.

    nullify ( channels, signalInds )
    call NullifyForwardModelConfig ( info ) ! for Sun's rubbish compiler

    error = 0
    call trace_begin ( me, "ConstructForwardModelConfig", root, &
      & cond=toggle(gen) .and. levels(gen) > 0 )

    ! Set sensible defaults
    info%allLinesForRadiometer = .false.
    info%allLinesInCatalog = .false.
    info%anyLBL = .false.
    info%anyPFA = .false.
    info%atmos_der = .false.
    info%atmos_second_der = .false.
    info%cloud_der = l_none
    info%default_spectroscopy = .false.
    info%differentialScan = .false.
    info%do_1d = .false.
    info%do_baseline = .false.
    info%do_conv = .false.
    info%do_freq_avg = .false.
    info%do_path_norm = .false.
    info%forceFoldedOutput = .false.
    info%forceSidebandFraction = .false.
    info%frqTol = 600.0 ! MHz
    info%GenerateTScat = .false.
    info%globalConfig = global
    info%incl_cld = .false.
    info%ignoreHessian = .false.
    info%instrumentModule = 0
    info%i_saturation = l_clear
    info%lockBins = .false.
    info%linearSideband = 0
    info%MIFTangent = l_ptan
    info%name = name
    info%no_cloud_species = 2
    info%no_model_surfs = 640
    info%num_ab_terms = 50
    info%num_azimuth_angles = 8
    info%num_scattering_angles = 16
    info%num_size_bins = 40
    info%phiwindow = [ 2, 2 ] ! profiles before and after tangent point
    info%no_magnetic_field = .false.
    info%polarized = .false.
    info%refract = switchDetail(switches,'norf') < 0 ! Default .true.
    info%scanAverage = .false.
    info%sideBandStart = -1
    info%sideBandStop = 1
    info%skipOverlaps = .false.
    info%spect_der = .false.
    info%switchingMirror= .false.
    info%temp_der = .false.
    info%transformMIFextinction = .false.
    info%transformMIFRHI = .false.
    info%trapezoid = l_wrong
    info%TScatMIF = 1
    info%useTScat = .false.
    info%where = root
    info%windowUnits = phyq_profiles
    info%xStar = 0
    info%yStar = 0

    got = .false.
    info%tolerance = -1.0 ! Kelvins, in case the tolerance field is absent
    lblTrees = null_tree
    lineTrees = null_tree
    no_dup_mol = .false.
    pfaTrees = null_tree
    do i = 2, nsons(root)
      son = subtree(i,root)
      L2CFNODE = son
      field = get_field_id(son)
      got(field) = .true.
      select case ( field )
      case ( f_allLinesForRadiometer )
        info%allLinesForRadiometer = get_boolean(son)
      case ( f_allLinesInCatalog )
        info%allLinesInCatalog = get_boolean(son)
      case ( f_atmos_der )
        info%atmos_der = get_boolean(son)
      case ( f_atmos_second_der )
        info%atmos_second_der = get_boolean(son)
      case  ( f_binSelectors )
        call Allocate_test ( info%binSelectors, nsons(son)-1, &
          & 'info%binSelectors', ModuleName )
        do j = 1, nsons(son) - 1
          info%binSelectors(j) = decoration ( decoration ( subtree ( j+1, son ) ) )
        end do
      case ( f_cloud_der )
        info%cloud_der = decoration ( subtree(2,son) )
      case ( f_DEFAULT_spectroscopy )
        info%DEFAULT_spectroscopy = get_boolean(son)
      case ( f_differentialScan )
        info%differentialScan = get_boolean(son)
      case ( f_do_baseline )
        info%do_baseline = get_boolean(son)
      case ( f_do_conv )
        info%do_conv = get_boolean(son)
      case ( f_do_freq_avg )
        info%do_freq_avg = get_boolean(son)
      case ( f_do_1d )
        info%do_1d = get_boolean(son)
      case ( f_forceSidebandFraction )
        info%forceSidebandFraction = get_boolean(son)
      case ( f_frqTol )
        call expr ( subtree(2,son), expr_units, value )
        info%frqTol = value(1)
      case ( f_i_saturation )
        call expr ( subtree(2,son), expr_units, value )
        info%i_saturation = nint(value(1))
      case ( f_ignoreHessian )
        info%ignoreHessian = get_boolean(son)
      case ( f_incl_cld )
        info%incl_cld = get_boolean(son)
      case ( f_integrationGrid )
        info%integrationGrid => vGrids(decoration(decoration(subtree(2,son))))
      case ( f_linearSideband )
        call expr ( subtree(2,son), expr_units, value )
        info%linearSideband = nint ( value(1) )
      case ( f_lineCenter )
        lineTrees(lineCenter) = son
      case ( f_lineWidth )
        lineTrees(lineWidth) = son
      case ( f_lineWidth_TDep )
        lineTrees(lineWidth_TDep) = son
      case ( f_lockBins )
        info%lockBins = get_boolean(son)
      case ( f_lsbLBLMolecules )
        LBLTrees(1) = son
      case ( f_lsbPFAMolecules )
        PFATrees(1) = son
      case ( f_MIFTangent )
        info%MIFTangent = decoration(decoration(subtree(2,son)))
      case ( f_module )
        info%instrumentModule = decoration(decoration(subtree(2,son)))
      case ( f_moleculeDerivatives )
        derivTree = son
      case ( f_molecules )
        moleculeTree = son
      case ( f_nabterms )
        call expr ( subtree(2,son), expr_units, value )
        info%NUM_AB_TERMS = nint( value(1) )
      case ( f_nazimuthangles )
        call expr ( subtree(2,son), expr_units, value )
      case ( f_ncloudspecies )
        call expr ( subtree(2,son), expr_units, value )
        info%no_cloud_species = nint( value(1) )
      case ( f_nmodelsurfs )
        call expr ( subtree(2,son), expr_units, value )
        info%no_model_surfs = nint( value(1) )
      case ( f_no_dup_mol )
        no_dup_mol = get_boolean(son)
      case ( f_nscatteringangles )
        call expr ( subtree(2,son), expr_units, value )
        info%NUM_SCATTERING_ANGLES = nint( value(1) )
        info%NUM_AZIMUTH_ANGLES = nint( value(1) )
      case ( f_nsizebins )
        call expr ( subtree(2,son), expr_units, value )
        info%NUM_SIZE_BINS = nint( value(1) )
      case ( f_pathNorm )
        info%do_path_norm = get_boolean(son)
      case ( f_phiWindow )
        call expr ( subtree(2,son), expr_units, value, expr_type )
        info%phiWindow = value
        if ( any(value < 0) ) &
          & call AnnounceError ( NegativePhiWindow, son )
        ! Make sure the window units are profiles or angle.  Allow one of
        ! them to be dimensionless if it's a range.
        if ( expr_type /= range ) expr_units(2) = expr_units(1)
        if ( expr_units(1) == PHYQ_Dimensionless ) expr_units(1) = expr_units(2)
        if ( expr_units(2) == PHYQ_Dimensionless ) expr_units(2) = expr_units(1)
        if ( expr_units(1) /= expr_units(2) .or. &
          & all ( expr_units(1) /= (/ PHYQ_Profiles, PHYQ_Angle /) ) ) &
          & call AnnounceError ( WrongUnitsForWindow, son )
        info%windowUnits = expr_units(1)
        if ( expr_type /= range ) then ! only one value was given
          if ( info%windowUnits == PHYQ_Angle ) then
            ! Assume a symmetric window
            info%phiWindow(1) = 0.5 * value(1)
            info%phiWindow(2) = info%phiWindow(1)
          else ! info%windowUnits == PHYQ_Profiles
            ! Center the window with value(1) total profiles.
            ! If even, put one more before the tangent than after it.
            info%phiWindow(2) = nint(value(1)-1)/2 ! after tangent point
            info%phiWindow(1) = max(nint(value(1)) - info%phiWindow(2) - 1,0.0_r8) ! before
          end if
        end if
      case ( f_noMagneticField )
        info%no_magnetic_field = get_boolean(son)
      case ( f_polarized )
        info%polarized = get_boolean(son)
      case ( f_referenceMIF )
        call expr ( subtree(2,son), expr_units, value )
        info%referenceMIF = nint(value(1))
      case ( f_refract )
        info%refract = get_boolean(son)
      case ( f_scanAverage )
        info%scanAverage = get_boolean(son)
      case ( f_moleculeSecondDerivatives )
        secondDerivTree = son
      case ( f_signals )
        info%noUsedChannels = 0
        allocate ( info%signals (nsons(son)-1), stat = status )
        addr = 0
        if ( status == 0 .and. nsons(son)-1 > 0 ) &
          addr = transfer(c_loc(info%signals(1)), addr)
        call test_allocate ( status, moduleName, 'info%signals', &
          & uBounds = size(info%signals), &
          & elementSize = storage_size(info%signals) / 8, address=addr )
        info%signals%index = -1 ! Indicate error, covered up if successful
        call allocate_test ( info%signalIndices, nsons(son)-1, &
          & 'Info%SignalIndices', moduleName )
        do j = 1, nsons(son)-1
          gson = subtree(j+1,son)
          call get_string ( sub_rosa(gson), signalString, strip=.true.)
          call parse_Signal ( signalString, signalInds, &
            & tree_index=gson, sideband=sideband, channels=channels )
          if ( .not. associated(signalInds) ) then ! A parse error occurred
            error = max(error,1)
            cycle
          end if
          ! Later on choose the `right' one from the match
          ! For the moment choose first !????
          wanted=1
          info%signals(j) = signals(signalInds(wanted))
          info%signals(j)%sideband = sideband
          info%signalIndices(j) = signalInds(wanted)
          ! Don't hose channels in database, though shouldn't be an issue
          nullify ( info%signals(j)%channels )

          call allocate_Test ( info%signals(j)%channels, &
            & size(info%signals(j)%frequencies), 'info%signals%channels', &
            & ModuleName ) ! , lowBound=lbound(info%signals(j)%frequencies,1) )
          if ( associated(channels) ) then
            info%signals(j)%channels(1:lbound(channels,1)-1) = .false.
            info%signals(j)%channels(lbound(channels,1):ubound(channels,1)) = &
              channels
            info%noUsedChannels = info%noUsedChannels + count(channels)
            info%signals(j)%channels(ubound(channels,1)+1:) = .false.
          else
            info%signals(j)%channels = .true.
            info%noUsedChannels = info%noUsedChannels + &
              & size(info%signals(j)%channels)
          end if
          call deallocate_test ( channels, 'channels', ModuleName )
          call deallocate_test ( signalInds, 'signalInds', ModuleName )
        end do                          ! End loop over listed signals
        ! Make sure signal specifications make sense; get sideband Start/Stop
        call validateSignals
      case ( f_skipOverlaps )
        info%skipOverlaps = get_boolean(son)
      case ( f_specificQuantities )
        call Allocate_test ( info%specificQuantities, nsons(son)-1, &
          & 'info%specificQuantities', ModuleName )
        do j = 1, nsons(son) - 1
          info%specificQuantities(j) = decoration ( decoration ( subtree ( j+1, son ) ) )
        end do
      case ( f_spect_der )
        info%spect_der = get_boolean(son)
      case ( f_switchingMirror )
        info%switchingMirror = get_boolean(son)
      case ( f_tangentGrid )
        info%tangentGrid => vGrids(decoration(decoration(subtree(2,son))))
      case ( f_temp_der )
        info%temp_der = get_boolean(son)
      case ( f_tolerance )
        call expr ( subtree(2,son), expr_units, value )
        info%tolerance = value(1)
      case ( f_transformMIFextinction )
        info%transformMIFextinction = get_Boolean(son)
      case ( f_transformMIFRHI )
        info%transformMIFRHI = get_Boolean(son)
      case ( f_trapezoid )
        info%trapezoid = decoration(subtree(2,son))
        if ( info%trapezoid /= l_wrong ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        &   'We no longer permit the trapezoid option named /correct/' )
      case ( f_TScatMIF )
        call expr ( subtree(2,son), expr_units, value )
        info%TScatMIF = nint(value(1))
      case ( f_type )
        info%fwmType = decoration(subtree(2,son))
      case ( f_usbLBLMolecules )
        LBLTrees(2) = son
      case ( f_usbPFAMolecules )
        PFATrees(2) = son
      case ( f_useTScat )
        info%useTScat = get_boolean(son)
      case ( f_xStar )
        info%xStar = decoration ( decoration ( subtree ( 2, son ) ) )
      case ( f_yStar )
        info%yStar = decoration ( decoration ( subtree ( 2, son ) ) )
      case default
        ! Shouldn't get here if the type checker worked
      end select

    end do ! i = 2, nsons(root)

    ! call dump(info)

    if ( ( got(f_lsbPFAMolecules) .and. got(f_lsbLBLMolecules) ) ) &
      & call announceError ( LBLandPFA, lblTrees(1) )
    if ( ( got(f_usbPFAMolecules) .and. got(f_usbLBLMolecules) ) ) &
      & call announceError ( LBLandPFA, lblTrees(2) )

    if ( ( .not. info%atmos_der ) .and. info%atmos_second_der ) then
      call announceError( Hess_notJac, root )
    end if

    s1 = (info%sidebandStart+3)/2; s2 = (info%sidebandStop+3)/2

    ! Now the molecule lists.
    nGroup = 0   ! Number of beta groups
    if ( got(f_molecules) ) then
      ! Create the Beta_Group structure.  Temporarily assume all the
      ! molecules are LBL.  We'll separate them later, when processing
      ! the LBL or PFA Molecules trees.  Type checker guarantees molecules.
      ! First, count the groups.  This isn't just the number of sons, because
      ! they might be array-valued variables.  So it's the sum of the number
      ! of elements of the sons, with each array, i.e., [...], son counted as
      ! one beta group.
      do m = 2, nsons(moleculeTree)
        son = subtree(m,moleculeTree)
        if ( node_id(son) == n_array ) then
          nGroup = nGroup + 1
        else
          call expr ( son, expr_units, value, values=values )
          nGroup = nGroup + size(values)
        end if
      end do
      allocate ( info%beta_group(nGroup), stat = status )
      addr = 0
      if ( status == 0 .and. nGroup>0 ) addr = transfer(c_loc(info%beta_group(1)), addr)
      call test_allocate ( status, moduleName, 'info%beta_group', &
        & uBounds = nGroup, elementSize=storage_size(info%beta_group) / 8, &
        & address=addr )
      do b = 1, nsons(moleculeTree) - 1
        son = subtree(b+1,moleculeTree)
        info%beta_group(b)%group = node_id(son) == n_array
        if ( info%beta_group(b)%group ) then
          if ( info%fwmType /= l_full ) &
            & call announceError ( noBetaGroup, son )
          ! Count the number of elements in the beta group.  It's not just
          ! the number of sons because elements might be array-valued
          ! variables.  The first element of the first variable is the
          ! group name.
          nelts = 0
          do j = 1, nsons(son)
            gson = subtree(j,son)
            call expr ( gson, expr_units, value, values=values )
            nelts = nelts + size(values) - merge(1,0,j==1)
          end do
          if ( nelts < 1 ) call announceError ( badMoleculeGroup, son )
          do s = 1, 2 ! Both sidebands
            call allocate_test ( info%beta_group(b)%lbl(s)%molecules, nelts, &
              & 'info%beta_group(b)%lbl(s)%molecules', moduleName )
          end do
          nelts = 1
          do j = 1, nsons(son)
            gson = subtree(j,son)
            call expr ( gson, expr_units, value, values=values )
            if ( j == 1 ) & ! group name
              & info%beta_group(b)%molecule = nint(values(1)%value(1))
            m = size(values) - merge(1,0,j==1)
            do s = 1, 2 ! Both sidebands
              info%beta_group(b)%lbl(s)%molecules(nelts:nelts+m-1) = &
                & nint(values(merge(2,1,j==1):)%value(1))
            end do
            nelts = nelts + m
          end do ! j = 1, nsons(son)
        else
          call expr ( son, expr_units, value, values=values )
          ! Each element is a separate beta group
          do m = 1, size(values)
            info%beta_group(b)%molecule = nint(values(m)%value(1)) ! group name
            do s = 1, 2 ! Both sidebands
              call allocate_test ( info%beta_group(b)%lbl(s)%molecules, 1, &
                & 'info%beta_group(b)%lbl(s)%molecules', moduleName )
              info%beta_group(b)%lbl(s)%molecules(1) = info%beta_group(b)%molecule
            end do
          end do
        end if
        do s = s1, s2 ! both sidebands
          if ( max(pfaTrees(s),lblTrees(s)) /= null_tree ) then
            ! Allocate PFA_Molecules temporarily for a "this is a PFA molecule" flag
            ! If it turns out to be an LBL molecules list, we'll swap them later.
            call allocate_test ( info%beta_group(b)%pfa(s)%molecules, &
              & size(info%beta_group(b)%lbl(s)%molecules), 'PFA Molecules', &
              & moduleName, fill=0 )
          else
            call allocate_test ( info%beta_group(b)%pfa(s)%molecules, 0, &
              & 'PFA Molecules', moduleName )
          end if
        end do ! s = s1, s2
      end do ! b = 1, nsons(moleculeTree) - 1
    else
      allocate ( info%beta_group(0), stat = status )
      call test_allocate ( status, moduleName, 'info%beta_group', [1], [0] )
    end if
    info%molecules => info%beta_group%molecule

    ! Announce duplicate molecules, but don't make it an error.
    ! (unless we have specifically disallowed them with no_dup_mol)
    ! All of the molecules are in ...%lbl(1) at this moment.
    do b = 1, size(info%beta_group)
      do i = 1, size(info%beta_group(b)%lbl(1)%molecules)
        ! First in the same group
        do j = i+1, size(info%beta_group(b)%lbl(1)%molecules)
          if ( info%beta_group(b)%lbl(1)%molecules(i) == &
            &  info%beta_group(b)%lbl(1)%molecules(j) ) then
            call announceError ( duplicateMolecule, moleculeTree, &
              what=info%beta_group(b)%lbl(1)%molecules(i), &
              warn=.not. no_dup_mol)
          end if
        end do
        ! Now in other groups
        do k = b+1, size(info%beta_group)
          do j = 1, size(info%beta_group(k)%lbl(1)%molecules)
            if ( info%beta_group(b)%lbl(1)%molecules(i) == &
              &  info%beta_group(k)%lbl(1)%molecules(j) ) then
              call announceError ( duplicateMolecule, moleculeTree, &
                what=info%beta_group(b)%lbl(1)%molecules(i), &
                warn=.not. no_dup_mol )
            end if
          end do
        end do
      end do
    end do

    ! Now the LBLMolecules or PFAMolecules lists
    info%cat_size = 0
    do s = s1, s2
      theTree = merge(lblTrees(s),pfaTrees(s),lblTrees(s)/=null_tree)
      if ( theTree /= null_tree ) then
        ! Verify that the LBL or PFA molecules are all listed molecules.
        ! Mark the ones that are LBL or PFA.
op:     do j = 2, nsons(theTree)
          son = subtree( j, theTree )
          if ( node_id(son) == n_array ) then
            call announceError ( NoArray, son )
            cycle
          end if
          call expr ( son, expr_units, value, values=values )
          do m = 1, size(values)
            thisMolecule = nint(values(m)%value(1))
            do b = 1, size(info%beta_group)
              do k = 1, size(info%beta_group(b)%lbl(s)%molecules)
                if ( thisMolecule == info%beta_group(b)%lbl(s)%molecules(k) ) then
                  ! Duplicate in list is warning, not error.
!                   if ( info%beta_group(b)%pfa(s)%molecules(k) /= 0 ) &
!                     & call announceError ( PFATwice, son, warn=.true. )
                  info%beta_group(b)%pfa(s)%molecules(k) = -1
                  cycle op
                end if
              end do ! k = 1, size(info%beta_group(b)%lbl(s)%molecules)
            end do ! b = 1, size(info%beta_group)
          end do
          call announceError ( PFANotMolecule, son )
        end do op ! j = 2, nsons(theTree)
        ! Divide the LBL and PFA molecules into separate lists
        do b = 1, size(info%beta_group)
          tempLBL => info%beta_group(b)%lbl(s)%molecules
          tempPFA => info%beta_group(b)%pfa(s)%molecules
          if ( pfaTrees(s) /= null_tree ) then
            numLBL = count(tempPFA == 0)
            numPFA = size(tempPFA) - numLBL
          else
            numPFA = count(tempPFA == 0)
            numLBL = size(tempPFA) - numPFA
          end if
          nullify ( info%beta_group(b)%lbl(s)%molecules, &
            &       info%beta_group(b)%pfa(s)%molecules )
          call allocate_test ( info%beta_group(b)%lbl(s)%molecules, numLBL, &
            & 'LBL Molecules', moduleName )
          call allocate_test ( info%beta_group(b)%pfa(s)%molecules, numPFA, &
            & 'PFA Molecules', moduleName )
          if ( pfaTrees(s) /= null_tree ) then
            info%beta_group(b)%lbl(s)%molecules = pack(tempLBL,tempPFA == 0)
            info%beta_group(b)%pfa(s)%molecules = pack(tempLBL,tempPFA /= 0)
          else
            info%beta_group(b)%lbl(s)%molecules = pack(tempLBL,tempPFA /= 0)
            info%beta_group(b)%pfa(s)%molecules = pack(tempLBL,tempPFA == 0)
          end if
          call deallocate_test ( tempLBL, 'TempLBL', moduleName )
          call deallocate_test ( tempPFA, 'TempPFA', moduleName )
          if ( numLBL /= 0 ) info%anyLBL(s) = .true.
          if ( numPFA /= 0 ) info%anyPFA(s) = .true.
        end do ! b
      else
        info%anyLBL(s) = .true.
      end if

      ! Now the cat_index and isotope ratio fields
      info%cat_size(s) = 0
      do b = 1, size(info%beta_group)
        k = size(info%beta_group(b)%lbl(s)%molecules)
        info%cat_size(s) = info%cat_size(s) + k
        call allocate_test ( info%beta_group(b)%lbl(s)%cat_index, &
          &                  k, 'beta_group(b)%Cat_Index', moduleName )
        info%beta_group(b)%lbl(s)%cat_index = 0 ! in case somebody asks for a dump
        call allocate_test ( info%beta_group(b)%lbl(s)%ratio, &
          &                  k, 'LBL Ratio', moduleName )
        info%beta_group(b)%lbl(s)%ratio = 1.0
        call allocate_test ( info%beta_group(b)%pfa(s)%ratio, &
          &                  size(info%beta_group(b)%pfa(s)%molecules), &
          &                  'PFA Ratio', moduleName )
        info%beta_group(b)%pfa(s)%ratio = 1.0
      end do ! b = 1, size(info%beta_group)

    end do ! s = s1, s2

    ! Now the spectroscopy parameters.  They only make sense for LBL.
    do i = lineCenter, lineWidth_TDep
      ! Make a list of the molecules
      nelts = 0
      do j = 2, nsons(LineTrees(i))
        son = subtree( j, LineTrees(i) )
        call expr ( son, expr_units, value, values=values )
        nelts = nelts + size(values)
      end do
      allocate ( lineStru(nelts), stat=status )
      addr = 0
      if ( status == 0 .and. nelts>0 ) addr = transfer(c_loc(lineStru(1)), addr)
      call test_allocate ( status, moduleName, 'LineStru', uBounds=nelts, &
        & elementSize=storage_size(lineStru)/8, address=addr )
      select case ( i )
      case ( lineCenter )
        info%lineCenter => lineStru
      case ( lineWidth )
        info%lineWidth => lineStru
      case ( lineWidth_TDep )
        info%lineWidth_TDep => lineStru
      end select
      if ( lineTrees(i) == null_tree ) cycle
      myMolecules => lineStru%molecule
      nelts = 0
      do j = 2, nsons(LineTrees(i))
        son = subtree( j, LineTrees(i) )
        if ( node_id(son) == n_array ) then
          call announceError ( NoArray, son )
          cycle
        end if
        call expr ( son, expr_units, value, values=values )
        do m = 1, size(values)
          nelts = nelts + 1
          myMolecules(nelts) = nint(values(m)%value(1))
          ! Look for duplicates
          do k = 2, nelts-1
            if ( myMolecules(k-1) == thisMolecule ) &
              & call announceError ( lineParamTwice, son )
          end do  ! k = 2, nelts-1
        end do ! m = 1, size(values)
      end do ! j = 2, nsons(LineTrees(i))
      ! Check that molecules are in some LBL's molecule list
      do s = s1, s2 ! Sideband
        do b = 1, size(info%beta_group)
          if ( size(info%beta_group(b)%lbl(s)%molecules) > 0 ) then
            do found = 1, size(myMolecules)
              if ( abs(myMolecules(found)) == info%beta_group(b)%lbl(s)%molecules(1) ) then
                lineStru%beta(s) = b ! Store beta group index
                myMolecules(found) = -abs(myMolecules(found)) ! Mark it as used
                info%beta_group(b)%lbl(s)%spect_der_ix(i) = found
                exit
              end if
            end do ! found
          end if
        end do ! b = 1, size(info%beta_group)
      end do ! s = s1, s2
      ! Check for unused ones, make them positive again
      do j = 1, size(myMolecules)
        if ( myMolecules(j) > 0 ) & ! not used, so not in any LBL list
          & call announceError ( LineNotMolecule, subtree(j+1,lineTrees(i)) )
        myMolecules(j) = abs(myMolecules(j))
      end do
    end do ! i = lineCenter, lineWidth_TDep

    info%moleculeDerivatives => info%beta_group%derivatives
    info%moleculeDerivatives = .false.

    info%moleculeSecondDerivatives => info%beta_group%secondDerivatives
    info%moleculeSecondDerivatives = .false.

    ! Get info%moleculeDerivatives 
    if ( got(f_moleculeDerivatives) ) then
      if ( .not. associated(info%molecules) ) &
        & call announceError ( derivSansMolecules, derivTree )
      
      if ( .not. info%atmos_der ) &
        & call announceError ( firstSansFirst1, derivTree )

      do j = 2, nsons(derivTree)
        son = subtree( j, derivTree )
        call expr ( son, expr_units, value, values=values )
        do m = 1, size(values)
          thisMolecule = nint(values(m)%value(1))
          if ( .not. any(info%molecules == thisMolecule) ) &
              & call announceError ( derivSansMolecules, subtree(j,derivTree) )
          if ( got(f_molecules) ) where ( info%molecules == thisMolecule ) &
              & info%moleculeDerivatives = .true.
        end do ! m = 1, size(values)
      end do                          ! End loop over listed species
    else if ( info%atmos_der ) then
      call announceError ( firstSansFirst2, derivTree )
    end if

    ! Get info%moleculeSecondDerivatives 
    if ( got(f_moleculeSecondDerivatives) ) then
      if ( .not. got(f_moleculeDerivatives) ) &
        & call announceError ( secondSansFirst, secondDerivTree )

      if ( .not. info%atmos_second_der ) &
        & call announceError ( secondSansSecond1, secondDerivTree )

      do j = 2, nsons(secondDerivTree)
        son = subtree( j, secondDerivTree )
        call expr ( son, expr_units, value, values=values )
        do m = 1, size(values)
          thisMolecule = nint(values(m)%value(1))
          if ( .not. any(info%molecules == thisMolecule) ) &
            & call announceError ( derivSansMolecules, subtree(j,secondDerivTree) )
          if ( got(f_molecules) ) where ( info%molecules == thisMolecule ) &
            & info%moleculeSecondDerivatives = .true.
        end do ! m = 1, size(values)
      end do                          ! End loop over listed species
    else if ( info%atmos_second_der ) then
       call announceError ( secondSansSecond2, secondDerivTree )
    end if

    if ( (.not. got(f_moleculeSecondDerivatives)) .and. info%atmos_second_der ) then
      info%moleculeSecondDerivatives = info%moleculeDerivatives
    end if

    ! Now some more error checking
    ! MIFExtinction transformation needs signals
    if ( ( info%transformMIFextinction .or. info%transformMIFRhi ) &
         & .and. .not. associated(info%signals) ) &
      & call announceError ( MIFTransformation_signals, root )

    ! If any PFA, can't do polarized
    if ( any(info%anyPFA(s1:s2)) .and. info%polarized ) &
      & call announceError ( noPolarizedAndPFA, root )

    if ( ( info%xStar == 0 ) .neqv. ( info%yStar == 0 ) ) &
      & call AnnounceError ( NeedBothXYStar, root )

    select case ( info%fwmType )
    case ( l_full, l_hybrid )
      info%isRadianceModel = .true.
      if ( .not. ( got(f_molecules) .and. &
        & all(got( (/ f_signals, f_integrationGrid, f_tangentGrid /) )) ) ) &
        & call AnnounceError ( IncompleteFullFwm, root )

      if ( .not. associated(info%integrationGrid%surfs) ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        &   'How can the integration grid not be associated?' )

      ! Now identify the Earth's surface in the tangent grid
      call Hunt ( info%tangentGrid%surfs(:,1), info%integrationGrid%surfs(1,1), &
        &  info%surfaceTangentIndex )

      ! Ensure that points in tangentGrid at and above the surface are a subset
      ! of integration grid
      if ( .not. associated(info%tangentGrid,info%integrationGrid) ) then
        do tangent = info%surfaceTangentIndex, info%tangentGrid%noSurfs
          if ( all ( abs( info%tangentGrid%surfs(tangent,1) - &
            & info%integrationGrid%surfs(:,1) ) > 1.0e-4 ) ) then
            call AnnounceError ( TangentNotSubset, root, warn=OnlyWarnIfTangentNotSubset )
            ! call outputnamedValue ( 'tangent index', tangent )
          end if
        end do
      end if

      if ( info%sidebandStart == 1 .and. info%anyPFA(1) .or. &
         & info%sidebandStop == -1 .and. info%anyPFA(2) ) &
         & call MLSL2Message ( MLSMSG_Warning, ModuleName, &
         & 'Signal is SSB, but PFA is requested for the other sideband' )

      ! Cannot specify allLinesInCatalog and polarized
      if ( info%allLinesInCatalog .and. info%polarized ) &
        & call AnnounceError ( PolarizedAndAllLines, root )

      if ( info%incl_cld ) call checkCloud

    case ( l_cloudfull ) ! full cloud forward model

      info%isRadianceModel = .true.
      if ( .not. info%default_spectroscopy ) call checkCloud

    case ( l_scan )
      info%isRadianceModel = .false.
      ! Add 1d/2d method later probably !??? NJL
      if ( any(got( (/ f_channels, f_lineCenter, f_lineWidth, &
        &              f_lineWidth_TDep, f_molecules, f_moleculeDerivatives, &
        &              f_signals /) )) .or. &
        & any( (/ info%atmos_der, info%do_conv, info%do_baseline, &
        &         info%do_freq_avg, info%do_1d, info%incl_cld, &
        &         info%temp_der /) ) ) &
        & call AnnounceError ( IrrelevantFwmParameter, root, &
          & "channels, frequency, lineCenter, lineWidth, lineWidth_TDep, "// &
          & "molecules, moleculeDerivatives, signals" )

    case ( l_linear, l_polarLinear )
      info%isRadianceModel = .true.
      if ( .not. all(got( (/f_signals/) )) ) & ! Maybe others later
        & call AnnounceError ( IncompleteLinearFwm, root )
      if ( any(got( (/f_do_conv,f_do_freq_avg,f_do_1d,f_incl_cld /) )) ) &
        & call AnnounceError ( IrrelevantFwmParameter, root, &
        & "do_conv, do_freq_avg, do_1d, incl_cld, frequency" )
     if ( .not. associated(L2PCDatabase) ) & 
        & call AnnounceError ( NeedL2PCFiles, root, warn=.true. )
    case default
      info%isRadianceModel = .false.
    end select

    if ( any ( info%fwmType == (/ l_linear, l_polarLinear, l_hybrid /) ) ) then
      ! Make sure we get a default bin selector
      if ( .not. associated ( info%binSelectors ) ) then
        if ( .not. associated ( binSelectors ) ) call CreateDefaultBinSelectors
        call Allocate_test ( info%binSelectors, 1, 'info%binSelectors', ModuleName )
        info%binSelectors = DefaultSelector_Latitude
      end if
    end if

    do i = 1, size(info%beta_group)
      do s = s1, s2 ! Sideband
        if ( any(info%beta_group(i)%lbl(s)%molecules == l_cloudIce) ) &
             & call announceError ( CloudLBL, root )
      end do
    end do

    if ( error /= 0 ) then
      call dump ( info, 'ConstructForwardModelConfig' )
      call MLSL2Message ( MLSMSG_Error, ModuleName, &
        & 'An error occured; see **** above' )
    end if

    call trace_end ( "ConstructForwardModelConfig", &
      & cond=toggle(gen) .and. levels(gen) > 0 )

  contains
    ! ...............................................  CheckCloud  .....
    subroutine CheckCloud
      use Intrinsic, only: Lit_Indices
      use Molecules, only: L_H2O, L_H2O_18, L_N2, L_N2O, L_O2, L_O3, L_O_18_O
      integer :: J
      logical :: GotH2O, GotO3
      gotH2O = .false.; gotO3 = .false.
      do j = 1, size(info%molecules) - 1
        select case ( info%molecules(j) )
        case ( l_h2o )
          gotH2O = .true.
        case ( l_o3 )
          gotO3 = .true.
        case ( l_n2o )
        case default
          select case ( info%molecules(j) )
          case ( l_n2, l_o2, l_h2o_18, l_o_18_o)
            call announceError ( cloudHas, root, &
              & what=lit_indices( info%molecules(j) ), warn=.true. )
          case default
            call announceError ( cloudNot, root, &
              & what=lit_indices( info%molecules(j) ) )
          end select
        end select
      end do
      if ( .not. GotH2O .or. .not. GotO3 ) &
        & call announceError ( cloudNeeds, root )
    end subroutine CheckCloud

    ! ..........................................  ValidateSignals  .....
    subroutine ValidateSignals
      use MLSSignals_m, only: GetSidebandStartStop
      use HyperSlabs, only: EssentiallyEqual

      ! Make sure all the signals we're dealing with are same module,
      ! radiometer and sideband.
      if ( any( info%signals%sideband /= info%signals(1)%sideband ) ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        &  "Can't have mixed sidebands in forward model config" )
      if ( .not. all ( EssentiallyEqual ( info%signals%lo, info%signals(1)%lo ) ) ) &
        & call MLSL2Message ( MLSMSG_Error, ModuleName, &
        &  "Can't have mixed radiometers in forward model config" )

      ! Think about sidebands
      call getSidebandStartStop ( &
        & info%signals(1), info%sidebandStart, info%sidebandStop )

    end subroutine ValidateSignals

  end function ConstructForwardModelConfig

  ! ----------------------------------------  FillFwdModelTimings  -----
  subroutine FillFwdModelTimings ( timings, FWModelConfig, which )
  !  Fill and return an array of time, mean, std_dev for timing FullforwardModel

    use ForwardModelConfig, only: ForwardModelConfig_T

    ! Dummy argument
    !real, pointer :: timings(:)
    double precision, dimension(:) :: timings
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    character(len=*), intent(in) :: which    ! 'fwdTiming', 'mean, or 'stdDev'

    ! Local variables
    real :: mean_sqDelta, meanTimes, tmp_mean
    integer :: i

    if (which == 'fwdTiming') then
      do i =1, size(FWModelConfig)
        timings(i) = FWModelConfig(i)%sum_DeltaTime
      end do
    end if

    if (which == 'mean') then
      do i =1, size(FWModelConfig)
        if (FWModelConfig(i)%sum_DeltaTime == 0.0 ) then
          timings(i) = 0.0
        else
          timings(i) = FWModelConfig(i)%sum_DeltaTime/FWModelConfig(i)%Ntimes
        end if
      end do
     end if

    if (which == 'stdDev') then
      do i =1, size(FWModelConfig)
        tmp_mean = FWModelConfig(i)%sum_DeltaTime/FWModelConfig(i)%Ntimes
        mean_sqDelta =  FWModelConfig(i)%sum_squareDeltaTime / &
          & FWModelConfig(i)%Ntimes
        if (FWModelConfig(i)%Ntimes <= 1) then
          meanTimes = 1.0
        else
          meanTimes = FWModelConfig(i)%Ntimes / (FWModelConfig(i)%Ntimes - 1)
        end if
        if (FWModelConfig(i)%sum_DeltaTime == 0.0 .AND. &
            & FWModelConfig(i)%sum_squareDeltaTime == 0.0 ) then
          timings(i) = 0.0
        else
          timings(i) = sqrt(abs(meanTimes * (mean_sqDelta - (tmp_mean * tmp_mean))))
        end if
      end do
    end if

  end subroutine FillFwdModelTimings

  ! --------------------------------------------ShowFwdModelNames  -----
  function ShowFwdModelNames ( FWModelConfig ) result (fwdNames)

  !  Fill and return an array of forward Model Names

    use ForwardModelConfig, only: ForwardModelConfig_T
    use MLSStringLists, only: CatLists
    use String_Table, only: Get_String

    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig
    character(len=2000) :: fwdNames

    character(len=30) :: thisNames
    integer :: i

    fwdNames = ' '
    do i =1, size(FWModelConfig)
       call get_string ( FWModelConfig(i)%name, thisNames )
       fwdNames = catLists(trim(fwdNames), trim(thisNames), ' ')
       ! print *,' fwdNames: ', trim(fwdNames)
    end do

  end function ShowFwdModelNames

  ! ------------------------------------  PrintForwardModelTiming  -----
  subroutine PrintForwardModelTiming ( FWModelConfig )
  !  Print mean, std_dev for timing FullforwardModel

    use ForwardModelConfig, only: ForwardModelConfig_T
    use Output_m, only: Blanks, Output
    use String_Table, only: Get_String

    ! Dummy argument
    type(ForwardModelConfig_T), dimension(:), pointer :: FWModelConfig

    ! Local variables
    real :: mean, mean_sqDelta, meanTimes, std_dev
    character(len=25) :: thisName
    integer :: i

    call output ( "======= printForwardModelTiming =========", advance='yes')
    call output ( " ", advance = 'yes')
    call output ( "Name", advance='no')
    call blanks (18, advance ='no')
    call output ("| Invocation ", advance = 'no')
    call output ( "| Mean_time / s ", advance='no')
    call output ("| St. dev. / s", advance='yes')
    call output ("-------------------------------------------&
         &-----------------------------", advance= 'yes')
    do i =1, size(FWModelConfig)

       mean = FWModelConfig(i)%sum_DeltaTime/FWModelConfig(i)%Ntimes
       mean_sqDelta =  FWModelConfig(i)%sum_squareDeltaTime / &
                & FWModelConfig(i)%Ntimes
       if (FWModelConfig(i)%Ntimes <= 1) then
          meanTimes = 1.0
       else
          meanTimes = FWModelConfig(i)%Ntimes / (FWModelConfig(i)%Ntimes - 1)
       end if
       std_dev = sqrt(abs(meanTimes * (mean_sqDelta - (mean*mean))))
       call get_string ( FWModelConfig(i)%name, thisName )
       call output ( thisName, advance='no')
       call output ( FWModelConfig(i)%Ntimes, format = '(i6)',advance = 'no' )
       call blanks (8, advance = 'no')
       if (FWModelconfig(i)%Ntimes == 0) then
          mean = 0.0
          std_dev = 0.0
       end if
       call output ( mean, format='(f8.2)', advance = 'no' )
       call blanks (6, advance = 'no')
       call output ( std_dev, format='(f8.2)', advance = 'yes' )
       call output ( " ", advance = 'yes')
       call resetForwardModelTiming ( FWModelConfig(i))
     end do
  end subroutine PrintForwardModelTiming

  ! ------------------------------------  ResetForwardModelTiming  -----
  subroutine ResetForwardModelTiming ( FWModelConfig )
  ! reset the values for timing FullforwardModel

    use ForwardModelConfig, only: ForwardModelConfig_T

    ! Dummy argument
    type(ForwardModelConfig_T), intent(inout) :: FWModelConfig

    FWModelConfig%Ntimes = 0
    FWModelConfig%sum_DeltaTime = 0.0
    FWModelConfig%sum_squareDeltaTime = 0.0

  end subroutine ResetForwardModelTiming

  ! =====     Private Procedures     ===================================
  ! ----------------------------------------------  AnnounceError  -----
  subroutine AnnounceError ( Code, where, extraMessage, what, warn )

    use Intrinsic, only: Lit_Indices
    use MoreTree, only: StartErrorMessage
    use Optional_M, only: Default
    use Output_M, only: Output
    use String_Table, only: Display_String
    use Tree, only: Decoration

    integer, intent(in) :: Code       ! Index of error message
    integer, intent(in) :: where      ! Where in the tree did the error occur?
    character (LEN=*), optional, intent(in) :: extraMessage
    integer, intent(in), optional :: What ! Optional extra, usually string index
    logical, optional, intent(in) :: Warn ! Warning if TRUE
    ! Internal variables
    ! logical :: onlyWarn
    ! Executable
    ! onlyWarn = .false.
    ! if ( present(warn) ) onlyWarn = warn
    ! if ( .not. onlyWarn ) error = max(error,1)
    ! If warn is both  present and true, then leave error unchanged
    ! (so a prior error condition remains in effect)
    error = merge( error, max(error,1), Default( warn, .false. ) )
    call startErrorMessage ( where )
    call output ( ' ForwardModelSupport complained: ' )
    select case ( code )
    case ( BadBinSelectors )
      call output ('Cannot have a fieldAzimuth binSelector for polarlinear model', &
        & advance='yes' )
    case ( BadHeightUnit )
      call output ( 'Inappropriate units for height in binSelector', &
        & advance='yes' )
    case ( BadMoleculeGroup )
      call output ( 'A molecule group has to have a name and a molecule', &
        & advance='yes' )
    case ( BadQuantityType )
      call output ( 'Bin Selectors cannot apply to this quantity type', &
        & advance='yes' )
    case ( CloudHas )
      call display_string ( what, before='Cloud forward model internally has the ' )
      call output ( ' molecule', advance='yes' )
    case ( CloudLBL )
      call output ( 'Cloud_A and Cloud_S cannot be LBL', advance='yes' )
    case ( CloudNeeds )
      call output ( 'Cloud forward model needs both H2O and O3 molecules', &
        & advance='yes' )
    case ( CloudNot )
      call display_string ( what, before='Cloud forward model cannot accept the ' )
      call output ( ' molecule', advance='yes' )
    case ( DerivSansMolecules )
      call output ( 'Derivative(s) requested for molecule(s) not specified.', &
        & advance='yes')
    case ( DuplicateMolecule )
      call display_string ( lit_indices(what), before='Duplicate molecule ', &
        & advance='yes' )
    case ( FirstSansFirst1 )
      call output ('moleculeDerivatives IS present, but atmos_der is NOT present', &
        & advance='yes' )
    case ( FirstSansFirst2 )
      call output ('atmos_der IS present, but moleculeDerivatives is NOT present', &
        & advance='yes' )
    case ( Hess_notJac )
      call output ('Atmospheric Jacobian not present, while atmospheric Hessian present', &
        & advance='yes' )
    case ( IncompleteBinSelectors )
      call output ('Must have some binSelectors for the polarlinear model',advance='yes' )
    case ( IncompleteFullFwm )
      call output ('Incomplete full foward model specification',advance='yes' )
    case ( IncompleteLinearFwm )
      call output ( 'Incomplete linear foward model specification', &
        & advance='yes' )
    case ( LBLandPFA )
      call output ( 'Cannot have both LBL and PFA molecule lists for one sideband', &
        & advance='yes' )
    case ( IrrelevantFwmParameter )
      call output ( 'Irrelevant parameter for this forward model type', &
        & advance='yes' )
    case ( LinearSidebandHasUnits )
      call output ( 'Irrelevant units for this linear sideband', &
        & advance='yes' )
    case ( LineNotMolecule )
      call display_string ( lit_indices(decoration(where)), &
        before='Spectral parameter requested for ' )
      call output ( ' but it is not an LBL molecule group', advance='yes' )
    case ( LineParamTwice )
      call display_string ( lit_indices(decoration(where)), before='Molecule '  )
      call output ( ' listed twice for spectral parameter', advance='yes' )
    case ( MIFTransformation_signals )
      call output ( 'MIF transformation needs signals', advance='yes' )
    case ( NeedBothXYStar )
      call output ( 'X/YStar must either be both present or both absent', &
        & advance='yes' )
    case ( NeedL2PCFiles )
      call output ( 'This kind of fwmdl (linear or polar linear) requires l2pc files', &
        & advance='yes' )
    case ( NegativePhiWindow )
      call output ( 'PhiWindow is not allowed to be negative', advance='yes' )
    case ( Nested )
      call output ( 'Group within group is not allowed', advance='yes' )
    case ( NoArray )
      call output ( 'Nested array not allowed here', advance='yes' )
    case ( NoBetaGroup )
      call output ( 'Beta grouping allowed only for full clear-sky model', &
        & advance='yes' )
    case ( NoMolecule )
      call output ( 'A bin selector of type vmr must have a molecule', &
        & advance='yes' )
    case ( NoPolarizedAndPFA )
      call output ( "Sorry, don't yet know how to combine polarized and PFA", &
        & advance='yes' )
    case ( PFANotMolecule )
      call output ( 'LBL or PFA requested for ' )
      call display_string ( lit_indices(decoration(where)) )
      call output ( ' but it is not in the molecule list', advance='yes' )
    case ( PFATwice )
      call display_string ( lit_indices(decoration(where)), &
        & before='Molecule ' )
      call output ( ' listed twice for LBL or PFA', advance='yes' )
    case ( PolarizedAndAllLines )
      call output ( 'Cannot specify both polarized and allLinesInCatalog', &
        & advance='yes' )
    case ( SecondSansFirst )
      call output ('Second requests molecule with no first derivative', &
        & advance='yes' )
    case ( SecondSansSecond1 )
      call output ('moleculeSecondDerivatives IS present, but atmos_second_der is NOT present', &
        & advance='yes' )
    case ( SecondSansSecond2 )
      call output ('atmos_second_der IS present, but moleculeSecondDerivatives is NOT present', &
        & advance='yes' )
    case ( TangentNotSubset )
      call output ('Non subsurface tangent grid not a subset of integration grid', &
        & advance='yes' )
    case ( TooManyHeights )
      call output ( 'Bin Selectors can only refer to one height range', &
        & advance='yes' )
    case ( TooManyCosts )
      call output ( 'Bin Selectors can only have one cost', &
        & advance='yes' )
    case ( WrongUnitsForWindow )
      call output ( 'PhiWindow must be in degrees or profiles', &
        & advance='yes' )
    case default
      call output ( '(no specific description of this error)', advance='yes' )
    end select
    if ( present(extraMessage) ) call output ( extraMessage, advance='yes' )
    if ( error /= 0 ) &
      & call output ( '(Set to stop due to error)', advance='yes' )
  end subroutine AnnounceError

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ForwardModelSupport.f90,v 2.193 2020/07/05 20:20:19 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ForwardModelSupport

! $Log: ForwardModelSupport.f90,v $
! Revision 2.193  2020/07/05 20:20:19  vsnyder
! Remove frequency field because it's not used
!
! Revision 2.192  2019/10/07 20:05:16  vsnyder
! Add trapezoid field to ForwardModel, for quadrature in FullForwardModel
!
! Revision 2.191  2019/04/24 19:15:25  vsnyder
! Add MIFTangent field to forwardModel
!
! Revision 2.190  2018/08/06 19:59:49  vsnyder
! Remove unreferenced USE name
!
! Revision 2.189  2018/07/27 23:18:48  pwagner
! Renamed level 2-savvy MLSMessage MLSL2Message
!
! Revision 2.188  2017/11/03 20:59:08  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.187  2017/09/14 18:36:26  vsnyder
! Cannonball polishing
!
! Revision 2.186  2017/03/17 17:27:02  pwagner
! Downgraded NeedL2PCFiles mesg from Error to Warning
!
! Revision 2.185  2017/03/17 00:12:24  pwagner
! Quit with apt message if linear fwdmdl has no l2pc files to use
!
! Revision 2.184  2016/05/02 23:30:46  vsnyder
! Comment out unused USE
!
! Revision 2.183  2016/03/25 00:39:58  pwagner
! May downgrade severity if TangentNotSubset
!
! Revision 2.182  2016/01/29 01:09:51  vsnyder
! Add polygon file reader to ForwardModelGlobal
!
! Revision 2.181  2015/08/25 17:35:10  vsnyder
! PhiWindow is a tuple, with the first element specifying the angles or
! number of profiles/MAFs before the tangent point, and the second
! specifying the angles or number after.  Set its default to [2,2] instead
! of 5.  Check that the units are either angles or profiles.  If it's input
! as a tuple, allow one to be dimensionless.  If it's not a tuple, and its
! units are profiles, it specifies the total number of profiles; put (n-1)/2
! before and the rest after after, with one more before if n is even.  If
! it's not a tuple and its units are angles, put half before and half after.
! Don't allow either element to be negative.  Zero indicates a 1-D problem.
!
! Revision 2.180  2015/03/28 02:42:19  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.179  2014/09/29 20:18:14  vsnyder
! Add NoMagneticField switch to ForwardModel
!
! Revision 2.178  2014/04/22 00:49:03  vsnyder
! Remove unused sumbols
!
! Revision 2.177  2014/02/28 00:18:57  vsnyder
! Don't re-check types already checked by type checker.  Remove TYPE
! argument from calls to EXPR where it wasn't subsequently used.
!
! Revision 2.176  2014/02/27 02:36:07  vsnyder
! Restore accidentally removed assignment of FrqTol
!
! Revision 2.175  2014/02/21 20:29:21  vsnyder
! Process variables where molecules are expected
!
! Revision 2.174  2014/01/11 01:44:18  vsnyder
! Decruftification
!
! Revision 2.173  2013/08/30 02:45:39  vsnyder
! Revise calls to trace_begin and trace_end
!
! Revision 2.172  2013/08/23 00:32:47  pwagner
! Initialize transformMIFRHI
!
! Revision 2.171  2013/08/16 02:34:46  vsnyder
! Remove Model_Plane_MIF
!
! Revision 2.170  2013/08/09 01:03:59  vsnyder
! Add ReferenceMIF component
!
! Revision 2.169  2013/07/25 00:23:41  vsnyder
! Replace TransformRHI with TransformMIFRHI
!
! Revision 2.168  2013/07/19 01:19:46  vsnyder
! Add TransformRHI field
!
! Revision 2.167  2013/07/12 23:44:28  vsnyder
! Move units checking to type checker
!
! Revision 2.166  2013/07/12 23:25:28  vsnyder
! Bugus checkin: Remove unreferenced error messages
!
! Revision 2.165  2013/06/12 02:37:14  vsnyder
! Cruft removal
!
! Revision 2.164  2012/08/16 18:07:43  pwagner
! Exploit level 2-savvy MLSMessage
!
! Revision 2.163  2012/08/01 00:10:02  pwagner
! Prevent references to undefined cat_sizes
!
! Revision 2.162  2012/05/01 22:22:58  vsnyder
! Set IsRadianceModel component
!
! Revision 2.161  2012/03/28 00:56:49  vsnyder
! Move check for signals with MIF extinction from Wrappers to Support
!
! Revision 2.160  2012/03/07 02:13:18  vsnyder
! Add transformMIFextinction switch
!
! Revision 2.159  2011/08/20 02:03:34  vsnyder
! Remove unused use name
!
! Revision 2.158  2011/07/29 02:00:44  vsnyder
! Remove TScatMolecules and TScatMoleculeDerivatives.  Make CloudIce a
! molecule.  Remove Cloud_A and Cloud_S.
!
! Revision 2.157  2011/05/10 17:11:28  pwagner
! Corrected goof that changed info%refract default
!
! Revision 2.156  2011/05/09 18:09:30  pwagner
! Converted to using switchDetail
!
! Revision 2.155  2011/03/31 19:47:54  vsnyder
! Validate signals when the signals field is processed, so that sidebands
! are set.  Only check that cloud_a and cloud_s are PFA for the desired
! sidebands.
!
! Revision 2.154  2011/01/29 00:52:51  vsnyder
! Allow PFA without frequency averaging
!
! Revision 2.153  2010/11/08 19:26:22  pwagner
! Slight improvement of unhelpful error message
!
! Revision 2.152  2010/08/27 06:20:47  yanovsky
! Added atmos_second_der, moleculeSecondDerivatives.
! Added error handling: Hess_notJac, SecondDerivTree, FirstSansFirst1,
! FirstSansFirst2, SecondSansFirst, SecondSansSecond1, SecondSansSecond2.
!
! Revision 2.151  2010/06/07 23:30:12  vsnyder
! Add TScatMolecules, TScatMoleculeDerivatives, Use_Tscat.  Change
! PhaseFrqTol to FrqTol.
!
! Revision 2.150  2010/04/30 01:53:26  vsnyder
! Add description to 'Irrelevant parameter' error message
!
! Revision 2.149  2010/03/26 23:16:12  vsnyder
! Add ignoreHessian field to forward model config
!
! Revision 2.148  2010/02/25 18:17:48  pwagner
! Removed outmoded ascii l2pc file support
!
! Revision 2.147  2010/02/09 16:22:32  pwagner
! Give info%GenerateTScat an initial value
!
! Revision 2.146  2010/01/22 01:00:20  vsnyder
! Require Cloud_A and Cloud_S "molecules" to be handled as PFA, not LBL.
!
! Revision 2.145  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.144  2009/04/16 21:56:43  pwagner
! Added print to not_used_here
!
! Revision 2.143  2008/09/30 22:37:51  vsnyder
! Use nint(value) for TScatMIF
!
! Revision 2.142  2008/08/21 23:42:46  vsnyder
! Remove GenerateTScat from ForwardModel; use TScat on Sids
!
! Revision 2.141  2008/07/30 19:08:00  vsnyder
! Add PhaseFrqTol field to ForwardModel spec
!
! Revision 2.140  2008/06/06 22:52:53  pwagner
! EssentiallyEqual moved to MLSFillValues
!
! Revision 2.139  2008/05/20 00:28:06  vsnyder
! Process MieTables field from ForwardModelGlobal
!
! Revision 2.138  2008/05/02 00:33:30  vsnyder
! Delete unused symbol
!
! Revision 2.137  2008/05/01 01:56:33  vsnyder
! Don't check grids subset if they're associated
!
! Revision 2.136  2007/11/07 03:10:48  vsnyder
! Add pathNorm field to forward model config
!
! Revision 2.135  2007/10/03 23:59:04  vsnyder
! Add 'where' for tracing
!
! Revision 2.134  2006/11/29 01:08:58  vsnyder
! Allocate spectroscopy derivative stuff with zero size if not used
!
! Revision 2.133  2006/07/20 23:39:53  vsnyder
! Remove unused declarations and USEs
!
! Revision 2.132  2006/06/03 01:46:20  vsnyder
! Remove no_dup_mol flag from config structure
!
! Revision 2.131  2006/05/11 19:37:32  pwagner
! Added option to disallow duplicate molecules
!
! Revision 2.130  2006/04/18 00:08:45  pwagner
! Allow abbreviated, pathless PFA files with PCF
!
! Revision 2.129  2006/03/30 18:58:47  vsnyder
! Allow duplicates in [LU]SBpfaMolecules and [LU]SBlblMolecules lists
!
! Revision 2.128  2006/03/22 02:23:46  vsnyder
! Add lsbLBLmolecules, useLBLmolecules
!
! Revision 2.127  2006/02/23 00:52:09  vsnyder
! Make sure instrumentModule has a value, report all errors before quitting
!
! Revision 2.126  2006/02/08 21:33:43  vsnyder
! Announce warning for duplicate molecules
!
! Revision 2.125  2006/02/07 00:19:07  vsnyder
! Prohibit conspiracy of polarized and PFA
!
! Revision 2.124  2006/01/11 01:56:48  vsnyder
! Allow PFA for sidebands not in signals, but ignore it -- of course
!
! Revision 2.123  2006/01/04 21:54:26  vsnyder
! 'norf' switch sets refraction default to false
!
! Revision 2.122  2005/12/29 01:11:08  vsnyder
! Add boolean 'refract' field to ForwardModel spec
!
! Revision 2.121  2005/12/22 21:08:15  vsnyder
! Require frequency averaging if both PFA and LBL
!
! Revision 2.120  2005/11/02 21:37:19  vsnyder
! Hoist some stuff out of FullForwardModel
!
! Revision 2.119  2005/10/14 23:14:28  vsnyder
! Require Frequency Averaging if any PFA molecules
!
! Revision 2.118  2005/09/16 23:39:07  vsnyder
! Add spect_der field to ForwardModel
!
! Revision 2.117  2005/09/03 01:20:41  vsnyder
! Spectral parameter offsets stuff
!
! Revision 2.116  2005/08/03 18:07:39  vsnyder
! Scan averaging, some spectroscopy derivative stuff
!
! Revision 2.115  2005/06/29 00:43:45  pwagner
! Utilizes new interface to ReadCompleteHDF5L2PCFile
!
! Revision 2.114  2005/06/14 20:41:55  pwagner
! Interfaces changed to accept MLSFile_T args
!
! Revision 2.113  2005/06/03 02:07:56  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! get VGrids from VGridsDatabase instead of an argument, add SignalIndices
! component to config.
!
! Revision 2.112  2005/05/27 17:56:07  vsnyder
! Access Source_Ref in the right place
!
! Revision 2.111  2005/05/26 22:35:48  vsnyder
! Add PFAFiles field to ForwardModelGlobal
!
! Revision 2.110  2005/03/28 20:29:09  vsnyder
! Better error checking and reporting, some PFA stuff
!
! Revision 2.109  2005/02/17 02:34:41  vsnyder
! Fix a blunder in PFA setup
!
! Revision 2.108  2005/02/16 23:16:24  vsnyder
! Revise data structures for split-sideband PFA
!
! Revision 2.107  2005/01/27 21:23:13  vsnyder
! Inching toward separate LSB and USB PFA
!
! Revision 2.106  2004/12/28 00:22:34  vsnyder
! Remove unused declarations
!
! Revision 2.105  2004/12/13 20:15:40  vsnyder
! Add filter file names to string table
!
! Revision 2.104  2004/11/16 02:56:01  vsnyder
! Dump imputed to wrong requestor
!
! Revision 2.103  2004/11/05 19:39:06  vsnyder
! Moved some stuff here from fwdmdl/Get_Species_Data
!
! Revision 2.102  2004/11/04 03:42:33  vsnyder
! Provide for both LBL_Ratio and PFA_Ratio in beta_group
!
! Revision 2.101  2004/11/01 20:27:55  vsnyder
! Reorganization of representation for molecules and beta groups
!
! Revision 2.100  2004/10/13 02:24:56  livesey
! Bug fix, vGrids now pointer in case none defined
!
! Revision 2.99  2004/10/06 21:14:37  vsnyder
! Require Molecules or PFAMolecules
!
! Revision 2.98  2004/08/05 21:01:59  vsnyder
! Add sentinel at end of %molecules
!
! Revision 2.97  2004/08/04 23:19:57  pwagner
! Much moved from MLSStrings to MLSStringLists
!
! Revision 2.96  2004/07/22 20:40:10  cvuu
! Add 2 subroutines FillFwdModelTimings and ShowFwdModelnames
!
! Revision 2.95  2004/07/17 02:27:24  vsnyder
! Better error message for PFA and non-PFA conflict
!
! Revision 2.94  2004/07/08 02:35:46  vsnyder
! Put all line-by-line molecules before PFA ones
!
! Revision 2.93  2004/06/12 00:42:35  vsnyder
! Make sure PFAMolecules is associated -- at least with zero size
!
! Revision 2.92  2004/05/18 01:25:14  vsnyder
! Hopefully finish pfaMolecules field support
!
! Revision 2.91  2004/05/01 04:05:50  vsnyder
! Added pfaMolecules -- but more work needed
!
! Revision 2.90  2004/03/22 18:24:40  livesey
! Added handling of AllLinesInCatalog flag.
!
! Revision 2.89  2004/03/05 18:32:55  livesey
! Bug fix, but commented out for the moment, as I need to get a test
! going.
!
! Revision 2.88  2003/10/29 00:44:33  livesey
! Made sure that default bin selectors also applied to hybrid model.
!
! Revision 2.87  2003/10/28 23:44:43  livesey
! Added initialization of forceFoldedOutput
!
! Revision 2.86  2003/10/15 16:59:25  pwagner
! Should allow null filenames if TOOLKIT
!
! Revision 2.85  2003/09/11 23:15:42  livesey
! Added handling of xStar / yStar arguments to l2pc models.
!
! Revision 2.84  2003/09/03 16:07:52  cvuu
! Add all of the printout stuff into routine PrintForwardModelTiming
!
! Revision 2.83  2003/08/27 20:31:07  livesey
! Removed the prevention of tolerance>0.0 on polarized runs
!
! Revision 2.82  2003/08/21 21:15:18  cvuu
! Change the output format for fullForwardModel Timing
!
! Revision 2.81  2003/08/19 05:51:31  livesey
! Extra call to CreateDefaultBinSelectors
!
! Revision 2.80  2003/08/15 23:58:20  vsnyder
! Get PHYQ_... directly from Intrinsic instead of indirectly via Units
!
! Revision 2.79  2003/08/15 20:28:44  vsnyder
! Remove check for and prohibition against polarized VMR derivatives
!
! Revision 2.78  2003/08/14 20:25:06  livesey
! Added the exact bin selector stuff
!
! Revision 2.77  2003/08/13 00:49:40  livesey
! Added the polarLinear model and now ensures that a default bin selector
! is provided to the linear model if the user doesn't supply one.
!
! Revision 2.76  2003/08/12 18:16:13  livesey
! Forbid non negative tolerance in polarized model.
!
! Revision 2.75  2003/08/12 17:12:08  livesey
! Added check to ensure you don't ask for mixing ratio derivatives from
! the polarized model
!
! Revision 2.74  2003/08/11 22:35:34  livesey
! Now more forgiving of running e.g. R5H and R5V together.
!
! Revision 2.73  2003/07/21 18:13:44  pwagner
! Looks farther than just 1st l2pc file in pcf
!
! Revision 2.72  2003/07/18 22:54:35  pwagner
! Ignores path in file names if TOOLKIT
!
! Revision 2.71  2003/07/16 21:51:29  pwagner
! Uses mlspcf_dacsfltsh_start
!
! Revision 2.70  2003/07/16 01:27:35  vsnyder
! Futzing
!
! Revision 2.69  2003/07/16 01:06:36  vsnyder
! Add DACS filter shapes
!
! Revision 2.68  2003/07/15 22:10:59  livesey
! Added support for hybrid model
!
! Revision 2.67  2003/07/15 18:17:50  livesey
! Better handling of configuration name
!
! Revision 2.66  2003/06/30 22:55:01  cvuu
! Find mean, std dev timing of fullForwardModel calls
!
! Revision 2.65  2003/06/26 23:15:07  vsnyder
! Reinstate revision 2.63, which inscrutably got lost
!
! Revision 2.64  2003/06/20 19:37:06  pwagner
! Quanities now share grids stored separately in databses
!
! Revision 2.63  2003/06/18 01:57:12  vsnyder
! Move checking that all signals in a config are for the same radiometer,
! module and sideband here from FullForwardModel.  Move computation for
! SidebandStart and SidebandStop here from FullForwardModel.
!
! Revision 2.62  2003/06/09 22:50:13  pwagner
! Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
!
! Revision 2.61  2003/05/29 16:42:19  livesey
! New switchingMirror stuff
!
! Revision 2.60  2003/05/05 23:00:34  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.56.2.2  2003/04/08 23:40:50  jonathan
! remove cloud_fov
!
! Revision 2.56.2.1  2003/02/22 00:47:26  vsnyder
! Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
!
! Revision 2.56  2003/02/08 05:28:47  vsnyder
! Squash a bug (looking at type before evaluating the expression).
! Move USE statements from module scope to procedure scope, so as not to
! cause TREE_WALKER to be recompiled every time there's a minor change here.
!
! Revision 2.55  2003/02/06 22:04:48  vsnyder
! Add f_moleculesPol, f_moleculeDerivativesPol, delete f_polarized
!
! Revision 2.54  2003/02/06 00:45:51  livesey
! Added new binSelector stuff
!
! Revision 2.53  2003/02/06 00:15:01  jonathan
! sorry no_cloud_sps=2
!
! Revision 2.52  2003/02/05 23:27:32  jonathan
! change default no_cloud_species=1
!
! Revision 2.51  2003/02/05 21:56:39  livesey
! New binSelectors stuff
!
! Revision 2.50  2003/02/04 22:02:18  jonathan
! set i_saturation==0 as default
!
! Revision 2.49  2003/02/04 19:03:06  livesey
! Default tolerance now -1.0
!
! Revision 2.48  2003/01/30 17:28:21  jonathan
! add logical incl_cld
!
! Revision 2.47  2003/01/29 01:48:29  vsnyder
! Add 'polarized' field to forwardModel
!
! Revision 2.46  2003/01/27 16:51:08  livesey
! Added initialisation for windowUnits
!
! Revision 2.45  2003/01/26 04:42:55  livesey
! Added units for phiWindow
!
! Revision 2.44  2003/01/16 00:55:41  jonathan
! add do_1d
!
! Revision 2.43  2003/01/13 17:17:04  jonathan
!  change cloud_width to i_saturation
!
! Revision 2.42  2003/01/03 21:03:02  pwagner
! l2pc filenames now inputtable via PCF
!
! Revision 2.41  2002/11/22 12:20:13  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.40  2002/11/15 01:33:24  livesey
! Added allLinesForRadiometer stuff
!
! Revision 2.39  2002/10/18 22:44:11  vsnyder
! Remove some unreferenced USE names
!
! Revision 2.38  2002/10/18 18:01:58  livesey
! Ensure l2pc files etc. read in fwmParallel master mode.
!
! Revision 2.37  2002/10/08 17:36:20  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.36  2002/09/25 20:08:26  livesey
! Added globalConfig and specificQuantities
!
! Revision 2.35  2002/08/21 23:31:52  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.34  2002/08/04 16:02:23  mjf
! Added some nullify statements for Sun's rubbish compiler.
!
! Revision 2.33  2002/07/17 06:02:36  livesey
! New HDF5 l2pc stuff
!
! Revision 2.32  2002/06/12 17:01:54  livesey
! Stuff to support change to real phiWindow from integer
!
! Revision 2.31  2002/05/14 22:31:31  livesey
! Minor bug fix associated with running in parallel mode.
!
! Revision 2.30  2002/03/21 16:42:34  livesey
! Made it skip reading l2pc files etc for parallel master tasks.
!
! Revision 2.29  2002/03/15 21:22:31  livesey
! Dealt with new BinSelector type
!
! Revision 2.28  2002/03/14 23:30:21  pwagner
! Changed id of who announcesError
!
! Revision 2.27  2002/03/12 23:44:12  vsnyder
! Removed private attribute from CVS stuff because private is module's default
!
! Revision 2.26  2002/03/07 17:17:57  livesey
! Removed frqGap
!
! Revision 2.25  2002/02/14 23:02:43  livesey
! Added a safety net to guard against deallocating channels in signals
! database (shouldn't occur in current version, though may be relevant
! later).
!
! Revision 2.24  2002/02/13 00:08:50  livesey
! Added differential scan model
!
! Revision 2.23  2002/02/08 22:52:21  livesey
! Hooked up bin selectors
!
! Revision 2.22  2002/02/04 23:24:49  livesey
! Removed dumps
!
! Revision 2.21  2002/01/21 21:13:28  livesey
! Added binSelector parsing
!
! Revision 2.20  2001/12/17 18:26:37  vsnyder
! Improve method to put '-' sign on 'part of a tree of molecules'
!
! Revision 2.19  2001/11/29 00:27:56  vsnyder
! Fix blunders in arrays-of-arrays, alphabetize USEs
!
! Revision 2.18  2001/11/28 03:50:07  vsnyder
! Allow array of arrays for 'molecules' field
!
! Revision 2.17  2001/11/15 23:49:40  jonathan
! rename DF_spectroscopy to default_spectroscopy
!
! Revision 2.16  2001/11/15 20:55:55  jonathan
! add df_spectroscopy
!
! Revision 2.15  2001/11/08 00:12:52  livesey
! Removed an obsolete variable
!
! Revision 2.14  2001/10/31 15:26:59  livesey
! Allowed filename arguments to forward model global stuff to be arrays
!
! Revision 2.13  2001/10/02 20:34:50  livesey
! Added do_baseline stuff
!
! Revision 2.12  2001/09/04 15:58:02  jonathan
! add cloud_fov, jonathan
!
! Revision 2.11  2001/07/17 22:36:19  jonathan
! add cloud_width, jonathan/paul
!
! Revision 2.10  2001/07/16 22:07:21  jonathan
! change cloud_der to integer-type, jonathan
!
! Revision 2.9  2001/07/12 23:27:48  livesey
! Got rid of the s_cloudForwardModel stuff
!
! Revision 2.8  2001/07/09 22:51:37  pwagner
! Picks up cloud-related config components
!
! Revision 2.7  2001/06/21 20:06:42  vsnyder
! Make the tolerance field of the ForwardModel spec optional
!
! Revision 2.6  2001/06/21 15:05:20  livesey
! Added tolerance field to config
!
! Revision 2.5  2001/06/19 22:48:42  pwagner
! Eliminated duplicate declaration of PointingGrid_m
!
! Revision 2.4  2001/06/04 22:42:24  livesey
! Added belowRef to forwardModelIntermediate_T
!
! Revision 2.3  2001/05/31 22:08:06  livesey
! Added cloud_der flag
!
! Revision 2.2  2001/05/30 23:05:39  pwagner
! Uses PCF for 3 fwdmdl files
!
! Revision 2.1  2001/05/29 23:18:18  livesey
! First version, was ForwardModelInterface
!

@


2.193
log
@Remove frequency field because it's not used
@
text
@d763 3
d1579 1
a1579 1
       "$Id: ForwardModelSupport.f90,v 2.192 2019/10/07 20:05:16 vsnyder Exp $"
d1589 3
@


2.192
log
@Add trapezoid field to ForwardModel, for quadrature in FullForwardModel
@
text
@d408 1
a408 1
      & F_Do_Freq_Avg, F_Forcesidebandfraction, F_Frequency, F_Frqtol, &
d1177 1
a1177 1
      if ( any(got( (/ f_channels, f_frequency, f_lineCenter, f_lineWidth, &
d1191 1
a1191 1
      if ( any(got( (/f_do_conv,f_do_freq_avg,f_do_1d,f_incl_cld,f_frequency /) )) ) &
d1576 1
a1576 1
       "$Id: ForwardModelSupport.f90,v 2.191 2019/04/24 19:15:25 vsnyder Exp $"
d1586 3
@


2.191
log
@Add MIFTangent field to forwardModel
@
text
@d419 3
a421 3
      & F_TscatMIF, F_Type, F_Usblblmolecules, F_Usbpfamolecules, F_Usetscat, &
      & F_Xstar, F_Ystar
    use Intrinsic, only: L_None, L_Clear, L_PTAN, Phyq_Angle, &
d543 1
d761 2
d1576 1
a1576 1
       "$Id: ForwardModelSupport.f90,v 2.190 2018/08/06 19:59:49 vsnyder Exp $"
d1586 3
@


2.190
log
@Remove unreferenced USE name
@
text
@d411 12
a422 11
      & F_Lockbins, F_Lsblblmolecules, F_Lsbpfamolecules, F_Module, &
      & F_Moleculederivatives, F_Molecules, F_Moleculesecondderivatives, &
      & F_Nabterms, F_Nazimuthangles, F_Ncloudspecies, F_Nmodelsurfs, &
      & F_No_Dup_Mol, F_Nscatteringangles, F_Nsizebins, F_Pathnorm, &
      & F_Phiwindow, F_Nomagneticfield, F_Polarized, F_ReferenceMIF, F_Refract, &
      & F_Scanaverage, F_Signals, F_Skipoverlaps, F_Specificquantities, &
      & F_Spect_Der, F_Switchingmirror, F_Tangentgrid, F_Temp_Der, F_Tolerance, &
      & F_TransformMIFextinction, F_TransformMIFrhi, F_TscatMIF, F_Type, &
      & F_Usblblmolecules, F_Usbpfamolecules, F_Usetscat, F_Xstar, F_Ystar
    use Intrinsic, only: L_None, L_Clear, Phyq_Angle, Phyq_Dimensionless, &
      & Phyq_ProFiles
d522 1
d619 2
d1573 1
a1573 1
       "$Id: ForwardModelSupport.f90,v 2.189 2018/07/27 23:18:48 pwagner Exp $"
d1583 3
@


2.189
log
@Renamed level 2-savvy MLSMessage MLSL2Message
@
text
@d427 1
a427 1
    use MLSMessagemodule, only: MLSMSG_Error, MLSMSG_Warning, MLSMessage
d1569 1
a1569 1
       "$Id: ForwardModelSupport.f90,v 2.188 2017/11/03 20:59:08 pwagner Exp $"
d1579 3
@


2.188
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@d16 1
d426 2
a427 2
    use MLSL2options, only: L2cfnode, MLSMessage
    use MLSMessagemodule, only: MLSMSG_Error, MLSMSG_Warning
d1132 1
a1132 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1153 1
a1153 1
         & call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1211 1
a1211 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d1256 1
a1256 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1259 1
a1259 1
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1569 1
a1569 1
       "$Id: ForwardModelSupport.f90,v 2.187 2017/09/14 18:36:26 vsnyder Exp $"
d1579 3
@


2.187
log
@Cannonball polishing
@
text
@d1250 1
a1250 1
      use MLSFillValues, only: EssentiallyEqual
d1568 1
a1568 1
       "$Id: ForwardModelSupport.f90,v 2.186 2017/03/17 17:27:02 pwagner Exp $"
d1578 3
@


2.186
log
@Downgraded NeedL2PCFiles mesg from Error to Warning
@
text
@d19 3
a21 3
  public :: CONSTRUCTFORWARDMODELCONFIG, FORWARDMODELGLOBALSETUP, &
    & CREATEBINSELECTORFROMMLSCFINFO, PRINTFORWARDMODELTIMING, &
    & RESETFORWARDMODELTIMING, SHOWFWDMODELNAMES, FILLFWDMODELTIMINGS
d292 2
a293 2
  ! -----------------------------  CreateBinSelectorFromMLSCFINFO  -----
  type (BinSelector_T) function CreateBinSelectorFromMLSCFINFO ( root ) &
d384 1
a384 1
  end function CreateBinSelectorFromMLSCFINFO
d1269 1
a1269 1
  ! ------------------------------FillFwdModelTimings  -----
d1322 1
a1322 1
  ! ------------------------------ShowFwdModelNames  -----
d1568 1
a1568 1
       "$Id: ForwardModelSupport.f90,v 2.185 2017/03/17 00:12:24 pwagner Exp $"
d1578 3
@


2.185
log
@Quit with apt message if linear fwdmdl has no l2pc files to use
@
text
@d1187 1
a1187 1
        & call AnnounceError ( NeedL2PCFiles, root )
d1419 1
d1430 1
a1430 1
    logical :: onlyWarn
d1432 6
a1437 4
    onlyWarn = .false.
    if ( present(warn) ) onlyWarn = warn
    if ( .not. onlyWarn ) error = max(error,1)
    ! if ( .not. present(warn) ) error = max(error,1)
d1561 1
a1561 1
    if ( .not. onlyWarn ) &
d1568 1
a1568 1
       "$Id: ForwardModelSupport.f90,v 2.184 2016/05/02 23:30:46 vsnyder Exp $"
d1578 3
@


2.184
log
@Comment out unused USE
@
text
@d54 2
a55 1
  integer, parameter :: NegativePhiWindow      = NeedBothXYStar + 1
d80 7
a86 7
    use ANTENNAPATTERNS_M, only: OPEN_ANTENNA_PATTERNS_FILE, &
      & READ_ANTENNA_PATTERNS_FILE, CLOSE_ANTENNA_PATTERNS_FILE
    use FILTERSHAPES_M, only: OPEN_FILTER_SHAPES_FILE, &
      & READ_FILTER_SHAPES_FILE, READ_DACS_FILTER_SHAPES_FILE, &
      & CLOSE_FILTER_SHAPES_FILE
    use INIT_TABLES_MODULE, only: F_ANTENNAPATTERNS, F_DACSFILTERSHAPES, &
      & F_FILTERSHAPES, F_L2PC, F_MIETABLES, F_PFAFILES, F_POINTINGGRIDS, &
d88 15
a102 15
    use INTRINSIC, only: L_ASCII, L_HDF
    use L2PARINFO, only: PARALLEL
    use L2PC_M, only: READCOMPLETEHDF5L2PCFILE
    use MLSCOMMON, only: MLSFILE_T
    use MLSPCF2, only: MLSPCF_ANTPATS_START, MLSPCF_FILTSHPS_START, &
      &          MLSPCF_DACSFLTSH_START, MLSPCF_PTGGRIDS_START, &
      &          MLSPCF_Polygon_Start, &
      &          MLSPCF_L2PC_START, MLSPCF_L2PC_END, &
      &          MLSPCF_MIETABLES_START, &
      &          MLSPCF_PFA_START, MLSPCF_PFA_END
    use MORETREE, only: GET_FIELD_ID
    use PFADATABASE_M, only: PROCESS_PFA_FILE
    use POINTINGGRID_M, only: CLOSE_POINTING_GRID_FILE, &
      & OPEN_POINTING_GRID_FILE, READ_POINTING_GRID_FILE
    use Polygon_m, only: Close_Polygon_File, Open_Polygon_File, &
d104 4
a107 4
    use READ_MIE_M, only: READ_MIE
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: NSONS, SUB_ROSA, SUBTREE
d230 8
a237 8
      use HDF, only: DFACC_RDONLY
      use INIT_TABLES_MODULE, only: FIELD_INDICES
      use MLSCOMMON, only: MLSFILE_T
      use MLSFILES, only: HDFVERSION_5, &
        & ADDINITIALIZEMLSFILE, GETPCFROMREF, SPLIT_PATH_NAME
      use MLSL2OPTIONS, only: TOOLKIT
      use SDPTOOLKIT, only: PGS_PC_GETREFERENCE
      use STRING_TABLE, only: GET_STRING
d296 12
a307 12
    use EXPR_M, only: EXPR
    use INIT_TABLES_MODULE, only: FIELD_FIRST, FIELD_LAST
    use INIT_TABLES_MODULE, only: L_NAMEFRAGMENT, L_VMR, L_TEMPERATURE, &
      & L_LATITUDE, L_SZA
    use INIT_TABLES_MODULE, only: F_COST, F_HEIGHT, F_MOLECULE, F_TYPE, &
      & F_NAMEFRAGMENT, F_EXACT
    use INTRINSIC, only: PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_INVALID, &
      & PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_VMR
    use L2PC_M, only: BINSELECTOR_T, BINSELECTORS, CREATEDEFAULTBINSELECTORS
    use MLSKINDS, only: R8
    use MORETREE, only: GET_FIELD_ID, GET_BOOLEAN
    use TREE, only: DECORATION, NSONS, SUB_ROSA, SUBTREE
d394 45
a438 44
    use Declaration_Table, only: Range, Value_t
    use EXPR_M, only: EXPR
    use FORWARDMODELCONFIG, only: DUMP, FORWARDMODELCONFIG_T, &
      & LINECENTER, LINEWIDTH, LINEWIDTH_TDEP, &
      & NULLIFYFORWARDMODELCONFIG, SPECTROPARAM_T
  ! use highoutput, only: outputnamedvalue
    use INIT_TABLES_MODULE, only: FIELD_FIRST, FIELD_LAST
    use INIT_TABLES_MODULE, only: L_FULL, L_SCAN, L_LINEAR, L_CLOUDFULL, L_HYBRID, &
      & L_POLARLINEAR
    use INIT_TABLES_MODULE, only:  F_ALLLINESFORRADIOMETER, &
      & F_ALLLINESINCATALOG, F_ATMOS_DER, F_ATMOS_SECOND_DER, &
      & F_BINSELECTORS, F_CHANNELS, F_CLOUD_DER, F_DEFAULT_SPECTROSCOPY, &
      & F_DIFFERENTIALSCAN, F_DO_1D, F_DO_BASELINE, F_DO_CONV, &
      & F_DO_FREQ_AVG, F_FORCESIDEBANDFRACTION, F_FREQUENCY, F_FRQTOL, &
      & F_IGNOREHESSIAN, F_INCL_CLD, F_INTEGRATIONGRID, F_I_SATURATION, &
      & F_LINEARSIDEBAND, F_LINECENTER, F_LINEWIDTH, F_LINEWIDTH_TDEP, &
      & F_LOCKBINS, F_LSBLBLMOLECULES, F_LSBPFAMOLECULES, F_MODULE, &
      & F_MOLECULEDERIVATIVES, F_MOLECULES, F_MOLECULESECONDDERIVATIVES, &
      & F_NABTERMS, F_NAZIMUTHANGLES, F_NCLOUDSPECIES, F_NMODELSURFS, &
      & F_NO_DUP_MOL, F_NSCATTERINGANGLES, F_NSIZEBINS, F_PATHNORM, &
      & F_PHIWINDOW, F_NoMagneticField, F_POLARIZED, F_ReferenceMIF, F_REFRACT, &
      & F_SCANAVERAGE, F_SIGNALS, F_SKIPOVERLAPS, F_SPECIFICQUANTITIES, &
      & F_SPECT_DER, F_SWITCHINGMIRROR, F_TANGENTGRID, F_TEMP_DER, F_TOLERANCE, &
      & F_TRANSFORMMIFEXTINCTION, F_TRANSFORMMIFRHI, F_TSCATMIF, F_TYPE, &
      & F_USBLBLMOLECULES, F_USBPFAMOLECULES, F_useTSCAT, F_XSTAR, F_YSTAR
    use INTRINSIC, only: L_NONE, L_CLEAR, PHYQ_Angle, PHYQ_Dimensionless, &
      & PHYQ_Profiles
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use L2PC_M, only: BINSELECTORS, DEFAULTSELECTOR_LATITUDE, CREATEDEFAULTBINSELECTORS
    use MLSKINDS, only: R8
    use MLSL2OPTIONS, only: L2CFNODE, MLSMESSAGE
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING
    use MLSNUMERICS, only: HUNT
    use MLSSIGNALS_M, only: SIGNALS
    use MOLECULES, only: L_CLOUDICE
    use MORETREE, only: GET_BOOLEAN, GET_FIELD_ID
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use PARSE_SIGNAL_M, only: PARSE_SIGNAL
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NODE_ID, NSONS, NULL_TREE, SUB_ROSA, SUBTREE
    use TREE_TYPES, only: N_ARRAY
    use VGRIDSDATABASE, only: VGRIDS
d1186 2
a1187 1

d1250 1
a1250 1
      use MLSFillValues, only: ESSENTIALLYEQUAL
d1328 2
a1329 2
    use MLSStringLists, only: catLists
    use String_Table, only: GET_STRING
d1351 2
a1352 2
    use Output_m, only: BLANKS, Output
    use String_Table, only: GET_STRING
d1504 3
d1565 1
a1565 1
       "$Id: ForwardModelSupport.f90,v 2.183 2016/03/25 00:39:58 pwagner Exp $"
d1575 3
@


2.183
log
@May downgrade severity if TangentNotSubset
@
text
@d398 1
a398 1
    use highoutput, only: outputnamedvalue
d1144 1
a1144 1
          endif
d1559 1
a1559 1
       "$Id: ForwardModelSupport.f90,v 2.182 2016/01/29 01:09:51 vsnyder Exp $"
d1569 3
@


2.182
log
@Add polygon file reader to ForwardModelGlobal
@
text
@d29 1
d398 1
d1141 4
a1144 2
            & info%integrationGrid%surfs(:,1) ) > 1.0e-4 ) ) &
            & call AnnounceError ( TangentNotSubset, root )
d1559 1
a1559 1
       "$Id: ForwardModelSupport.f90,v 2.181 2015/08/25 17:35:10 vsnyder Exp $"
d1569 3
@


2.181
log
@PhiWindow is a tuple, with the first element specifying the angles or
number of profiles/MAFs before the tangent point, and the second
specifying the angles or number after.  Set its default to [2,2] instead
of 5.  Check that the units are either angles or profiles.  If it's input
as a tuple, allow one to be dimensionless.  If it's not a tuple, and its
units are profiles, it specifies the total number of profiles; put (n-1)/2
before and the rest after after, with one more before if n is even.  If
it's not a tuple and its units are angles, put half before and half after.
Don't allow either element to be negative.  Zero indicates a 1-D problem.
@
text
@d84 2
a85 1
      & F_FILTERSHAPES, F_L2PC, F_MIETABLES, F_PFAFILES, F_POINTINGGRIDS
d92 1
d100 2
d205 9
d1555 1
a1555 1
       "$Id: ForwardModelSupport.f90,v 2.180 2015/03/28 02:42:19 vsnyder Exp $"
d1565 11
@


2.180
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d53 2
a54 1
  integer, parameter :: Nested                 = NeedBothXYStar + 1
d379 1
a379 1
    use Declaration_Table, only: Value_t
d403 2
a404 1
    use INTRINSIC, only: L_NONE, L_CLEAR, PHYQ_ANGLE, PHYQ_PROFILES
d433 1
d510 1
a510 1
    info%phiwindow = 5
d628 11
a638 3
        call expr ( subtree(2,son), expr_units, value )
        info%phiWindow = value(1)
        if ( all ( expr_units(1) /= (/ PHYQ_Profiles, PHYQ_Angle /) ) ) &
d641 12
d1484 2
d1542 1
a1542 1
       "$Id: ForwardModelSupport.f90,v 2.179 2014/09/29 20:18:14 vsnyder Exp $"
d1552 3
@


2.179
log
@Add NoMagneticField switch to ForwardModel
@
text
@d376 1
a376 1
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST, &
d403 1
d427 1
d646 6
a651 1
        call test_allocate ( status, moduleName, 'info%signals' )
d769 5
a773 1
      call test_allocate ( status, moduleName, 'info%beta_group' )
d959 4
a962 1
      call test_allocate ( status, moduleName, 'LineStru' )
d1517 1
a1517 1
       "$Id: ForwardModelSupport.f90,v 2.178 2014/04/22 00:49:03 vsnyder Exp $"
d1527 3
@


2.178
log
@Remove unused sumbols
@
text
@d397 3
a399 3
      & F_PHIWINDOW, F_POLARIZED, F_ReferenceMIF, F_REFRACT, F_SCANAVERAGE, &
      & F_SIGNALS, F_SKIPOVERLAPS, F_SPECIFICQUANTITIES, F_SPECT_DER, &
      & F_SWITCHINGMIRROR, F_TANGENTGRID, F_TEMP_DER, F_TOLERANCE, &
d506 1
d628 2
d1503 1
a1503 1
       "$Id: ForwardModelSupport.f90,v 2.177 2014/02/28 00:18:57 vsnyder Exp $"
d1513 3
@


2.177
log
@Don't re-check types already checked by type checker.  Remove TYPE
argument from calls to EXPR where it wasn't subsequently used.
@
text
@d286 2
a287 2
    use INTRINSIC, only: T_NUMERIC_RANGE, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, &
      & PHYQ_INVALID, PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_VMR
d1500 1
a1500 1
       "$Id: ForwardModelSupport.f90,v 2.176 2014/02/27 02:36:07 vsnyder Exp $"
d1510 4
@


2.176
log
@Restore accidentally removed assignment of FrqTol
@
text
@a299 1
    integer :: TYPE                     ! Type of value returned by expr
d334 1
a334 3
        call expr ( gson, expr_units, value, type )
        if ( type /= t_numeric_range ) call AnnounceError ( 0, son, &
          & extraMessage='Height range expected' )
d341 2
a342 4
        call expr ( gson, expr_units, value, type )
        if ( type == t_numeric_range ) call AnnounceError ( 0, son, &
          & extraMessage='Cost must not be a range' )
        ! Some units checking should probably go here in the long run !???? NJL
a457 1
    integer :: type                     ! Type of value returned by EXPR
d567 1
a567 1
        call expr ( subtree(2,son), expr_units, value, type )
d570 1
a570 1
        call expr ( subtree(2,son), expr_units, value, type )
d579 1
a579 1
        call expr ( subtree(2,son), expr_units, value, type )
d600 1
a600 1
        call expr ( subtree(2,son), expr_units, value, type )
d603 1
a603 1
        call expr ( subtree(2,son), expr_units, value, type )
d605 1
a605 1
        call expr ( subtree(2,son), expr_units, value, type )
d608 1
a608 1
        call expr ( subtree(2,son), expr_units, value, type )
d613 1
a613 1
        call expr ( subtree(2,son), expr_units, value, type )
d617 1
a617 1
        call expr ( subtree(2,son), expr_units, value, type )
d622 1
a622 1
        call expr ( subtree(2,son), expr_units, value, type )
d630 1
a630 1
        call expr ( subtree(2,son), expr_units, value, type )
d699 1
a699 1
        call expr ( subtree(2,son), expr_units, value, type )
d706 1
a706 1
        call expr ( subtree(2,son), expr_units, value, type )
d754 1
a754 1
          call expr ( son, expr_units, value, type, values=values )
d773 1
a773 1
            call expr ( gson, expr_units, value, type, values=values )
d784 1
a784 1
            call expr ( gson, expr_units, value, type, values=values )
d795 1
a795 1
          call expr ( son, expr_units, value, type, values=values )
d866 1
a866 1
          call expr ( son, expr_units, value, type, values=values )
d941 1
a941 1
        call expr ( son, expr_units, value, type, values=values )
d963 1
a963 1
        call expr ( son, expr_units, value, type, values=values )
d1013 1
a1013 1
        call expr ( son, expr_units, value, type, values=values )
d1036 1
a1036 1
        call expr ( son, expr_units, value, type, values=values )
d1500 1
a1500 1
       "$Id: ForwardModelSupport.f90,v 2.175 2014/02/21 20:29:21 vsnyder Exp $"
d1510 3
@


2.175
log
@Process variables where molecules are expected
@
text
@d574 1
d1506 1
a1506 1
       "$Id: ForwardModelSupport.f90,v 2.174 2014/01/11 01:44:18 vsnyder Exp $"
d1516 3
@


2.174
log
@Decruftification
@
text
@d30 1
a30 2
  integer, parameter :: AllocateError          = 1
  integer, parameter :: BadBinSelectors        = AllocateError + 1
d381 2
a382 1
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
d439 1
a439 1
    integer :: I, J, K                  ! Subscript and loop inductor.
d447 1
a573 1
        info%frqTol = value(1)
d575 2
a576 1
        info%i_saturation = decoration(subtree(2,son))
d646 1
a646 1
        if ( status /= 0 ) call announceError( AllocateError, root )
d745 1
a745 1
    nelts = 0    ! Total number of molecules, not counting group names
d749 16
a764 3
      ! the LBL or PFA Molecules trees.
      allocate ( info%beta_group(nsons(moleculeTree)-1), stat = status )
      if ( status /= 0 ) call announceError( AllocateError, moleculeTree )
a766 1
        call expr ( son, expr_units, value, type, values=values )
d771 6
a776 9
          call allocate_test ( info%beta_group(b)%lbl(1)%molecules, nsons(son)-1, &
            & 'info%beta_group(b)%lbl(1)%molecules', moduleName )
          call allocate_test ( info%beta_group(b)%lbl(2)%molecules, nsons(son)-1, &
            & 'info%beta_group(b)%lbl(2)%molecules', moduleName )
          info%beta_group(b)%molecule = decoration(subtree(1,son)) ! group name
          j = nsons(son)
          if ( j < 2 ) call announceError ( badMoleculeGroup, son )
          nelts = nelts + j - 1
          do j = 2, j
d778 31
a808 5
            if ( node_id(gson) == n_array ) then
              call announceError ( nested, gson )
            else
              info%beta_group(b)%lbl(1)%molecules(j-1) = decoration(gson)
            end if
a809 10
          info%beta_group(b)%lbl(2)%molecules = info%beta_group(b)%lbl(1)%molecules
        else ! type checker guarantees a molecule name here
          nelts = nelts + 1
          info%beta_group(b)%molecule = decoration(son)
          call allocate_test ( info%beta_group(b)%lbl(1)%molecules, 1, &
            & 'info%beta_group(b)%lbl(1)%molecules', moduleName )
          call allocate_test ( info%beta_group(b)%lbl(2)%molecules, 1, &
            & 'info%beta_group(b)%lbl(2)%molecules', moduleName )
          info%beta_group(b)%lbl(1)%molecules(1) = info%beta_group(b)%molecule
          info%beta_group(b)%lbl(2)%molecules(1) = info%beta_group(b)%molecule
d826 1
a826 1
      if ( status /= 0 ) call announceError( AllocateError, moleculeTree )
d871 15
a885 12
          thisMolecule = decoration( son )
          do b = 1, size(info%beta_group)
            do k = 1, size(info%beta_group(b)%lbl(s)%molecules)
              if ( thisMolecule == info%beta_group(b)%lbl(s)%molecules(k) ) then
                ! Duplicate in list is warning, not error.
!                 if ( info%beta_group(b)%pfa(s)%molecules(k) /= 0 ) &
!                   & call announceError ( PFATwice, son, warn=.true. )
                info%beta_group(b)%pfa(s)%molecules(k) = -1
                cycle op
              end if
            end do ! k = 1, size(info%beta_group(b)%lbl(s)%molecules)
          end do ! b = 1, size(info%beta_group)
d943 8
a950 2
      allocate ( lineStru(max(nsons(lineTrees(i))-1,0)), stat=status )
      if ( status /= 0 ) call announceError( AllocateError, lineTrees(i) )
d961 1
d968 10
a977 6
        myMolecules(j-1) = decoration( son )
        ! Look for duplicates
        do k = 2, j-1
          if ( myMolecules(k-1) == thisMolecule ) &
            & call announceError ( lineParamTwice, son )
        end do  ! k = 2, j-1
d1017 9
a1025 5
        thisMolecule = decoration( subtree( j, derivTree ) )
        if ( .not. any(info%molecules == thisMolecule) ) &
          & call announceError ( derivSansMolecules, subtree(j,derivTree) )
        if ( got(f_molecules) ) where ( info%molecules == thisMolecule ) &
          & info%moleculeDerivatives = .true.
d1040 9
a1048 5
        thisMolecule = decoration( subtree( j, secondDerivTree ) )
        if ( .not. any(info%molecules == thisMolecule) ) &
          & call announceError ( derivSansMolecules, subtree(j,secondDerivTree) )
        if ( got(f_molecules) ) where ( info%molecules == thisMolecule ) &
          & info%moleculeSecondDerivatives = .true.
a1382 2
    case ( AllocateError )
      call output ( 'Allocation error.', advance='yes' )
d1505 1
a1505 1
       "$Id: ForwardModelSupport.f90,v 2.173 2013/08/30 02:45:39 vsnyder Exp $"
d1515 3
@


2.173
log
@Revise calls to trace_begin and trace_end
@
text
@d383 1
d464 1
d753 1
d1459 1
a1459 1
       "$Id: ForwardModelSupport.f90,v 2.172 2013/08/23 00:32:47 pwagner Exp $"
d1469 3
@


2.172
log
@Initialize transformMIFRHI
@
text
@d114 1
d128 2
a129 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_begin ( 'ForwardModelGlobalSetup', root )
d206 2
a207 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_end ( 'ForwardModelGlobalSetup' )
d442 1
d472 2
a473 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_begin ( "ConstructForwardModelConfig", root )
d1108 2
a1109 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_end ( "ConstructForwardModelConfig" )
d1456 1
a1456 1
       "$Id: ForwardModelSupport.f90,v 2.171 2013/08/16 02:34:46 vsnyder Exp $"
d1466 3
@


2.171
log
@Remove Model_Plane_MIF
@
text
@d19 3
a21 3
  public :: ConstructForwardModelConfig, ForwardModelGlobalSetup, &
    & CreateBinSelectorFromMLSCFInfo, printForwardModelTiming, &
    & resetForwardModelTiming, ShowFwdModelNames, FillFwdModelTimings
d214 1
a214 1
      use HDF, only: DFACC_RDonly
a381 1
    use DECLARATION_TABLE, only: RANGE
d403 1
a403 1
      & F_TransformMIFextinction, F_TransformMIFRHI, F_TSCATMIF, F_TYPE, &
d517 1
d1454 1
a1454 1
       "$Id: ForwardModelSupport.f90,v 2.170 2013/08/09 01:03:59 vsnyder Exp $"
d1464 3
@


2.170
log
@Add ReferenceMIF component
@
text
@d52 2
a53 2
  integer, parameter :: MIFextinction_signals  = LineParamTwice + 1
  integer, parameter :: NeedBothXYStar         = MIFextinction_signals + 1
d62 1
a62 1
  integer, parameter :: SecondSansFirst        = PolarizedAndAllLines + 1
d382 1
d397 9
a405 10
      & F_LOCKBINS, F_LSBLBLMOLECULES, F_LSBPFAMOLECULES, &
      & F_Model_Plane_Mif, F_MODULE, F_MOLECULEDERIVATIVES, F_MOLECULES, &
      & F_MOLECULESECONDDERIVATIVES, F_NABTERMS, F_NAZIMUTHANGLES, &
      & F_NCLOUDSPECIES, F_NMODELSURFS, F_NO_DUP_MOL, F_NSCATTERINGANGLES, &
      & F_NSIZEBINS, F_PATHNORM, F_PHIWINDOW, F_POLARIZED, F_ReferenceMIF, &
      & F_REFRACT, F_SCANAVERAGE, F_SIGNALS, F_SKIPOVERLAPS, &
      & F_SPECIFICQUANTITIES, F_SPECT_DER, F_SWITCHINGMIRROR, F_TANGENTGRID, &
      & F_TEMP_DER, F_TOLERANCE, F_TransformMIFextinction, F_TransformMIFRHI, &
      & F_TSCATMIF, F_TYPE, F_USBLBLMOLECULES, F_USBPFAMOLECULES, &
      & F_useTSCAT, F_XSTAR, F_YSTAR
a592 3
      case ( f_model_plane_MIF )
        call expr ( subtree(2,son), expr_units, value, type )
        info%model_plane_MIF = nint ( value(1) )
d1007 3
a1009 2
    if ( info%transformMIFextinction .and. .not. associated(info%signals) ) &
      & call announceError ( MIFextinction_signals, root )
d1393 2
a1394 2
    case ( MIFextinction_signals )
      call output ( 'MIF extinction transformation needs signals', advance='yes' )
d1454 1
a1454 1
       "$Id: ForwardModelSupport.f90,v 2.169 2013/07/25 00:23:41 vsnyder Exp $"
d1464 3
@


2.169
log
@Replace TransformRHI with TransformMIFRHI
@
text
@d400 4
a403 4
      & F_NSIZEBINS, F_PATHNORM, F_PHIWINDOW, F_POLARIZED, F_REFRACT, &
      & F_SCANAVERAGE, F_SIGNALS, F_SKIPOVERLAPS, F_SPECIFICQUANTITIES, &
      & F_SPECT_DER, F_SWITCHINGMIRROR, F_TANGENTGRID, F_TEMP_DER, &
      & F_TOLERANCE, F_TransformMIFextinction, F_TransformMIFRHI, &
d632 3
d1456 1
a1456 1
       "$Id: ForwardModelSupport.f90,v 2.168 2013/07/19 01:19:46 vsnyder Exp $"
d1466 3
@


2.168
log
@Add TransformRHI field
@
text
@d403 3
a405 3
      & F_TOLERANCE, F_TransformMIFextinction, F_TransformRHI, F_TSCATMIF, &
      & F_TYPE, F_USBLBLMOLECULES, F_USBPFAMOLECULES, F_useTSCAT, F_XSTAR, &
      & F_YSTAR
d703 2
a704 2
      case ( f_transformRHI )
        info%transformRHI = get_Boolean(son)
d1453 1
a1453 1
       "$Id: ForwardModelSupport.f90,v 2.167 2013/07/12 23:44:28 vsnyder Exp $"
d1463 3
@


2.167
log
@Move units checking to type checker
@
text
@d389 6
a394 5
    use INIT_TABLES_MODULE, only: F_ALLLINESFORRADIOMETER, F_ALLLINESINCATALOG, &
      & F_ATMOS_DER, F_ATMOS_SECOND_DER, F_BINSELECTORS, F_CHANNELS, F_CLOUD_DER, &
      & F_DEFAULT_SPECTROSCOPY, F_DIFFERENTIALSCAN, F_DO_BASELINE, F_DO_CONV, &
      & F_DO_FREQ_AVG, F_DO_1D, F_FORCESIDEBANDFRACTION, F_FREQUENCY, F_FRQTOL, &
      & F_I_SATURATION, F_INCL_CLD, F_IGNOREHESSIAN, F_INTEGRATIONGRID, &
d396 2
a397 2
      & F_LOCKBINS, F_LSBLBLMOLECULES, F_LSBPFAMOLECULES, F_Model_Plane_Mif, &
      & F_MODULE, F_MOLECULES, F_MOLECULEDERIVATIVES, &
d400 6
a405 5
      & F_NSIZEBINS, F_PATHNORM, F_PHIWINDOW, F_POLARIZED, &
      & F_REFRACT, F_SCANAVERAGE, F_SIGNALS, F_SKIPOVERLAPS, &
      & F_SPECIFICQUANTITIES, F_SPECT_DER, F_SWITCHINGMIRROR, F_TANGENTGRID, &
      & F_TEMP_DER, F_TOLERANCE, F_TransformMIFextinction, F_TSCATMIF, F_TYPE, &
      & F_USBLBLMOLECULES, F_USBPFAMOLECULES, F_useTSCAT, F_XSTAR, F_YSTAR
d703 2
d1453 1
a1453 1
       "$Id: ForwardModelSupport.f90,v 2.166 2013/07/12 23:25:28 vsnyder Exp $"
d1463 3
@


2.166
log
@Remove unreferenced error messages
@
text
@d1449 1
a1449 1
       "$Id: ForwardModelSupport.f90,v 2.165 2013/06/12 02:37:14 vsnyder Exp $"
d1459 3
@


2.165
log
@Cruft removal
@
text
@d35 1
a35 2
  integer, parameter :: BadSideband            = BadQuantityType + 1
  integer, parameter :: CloudHas               = BadSideband + 1
d66 1
a66 2
  integer, parameter :: ToleranceNotK          = TangentNotSubset + 1
  integer, parameter :: TooManyCosts           = ToleranceNotK + 1
d68 1
a68 3
  integer, parameter :: TScatMIF               = TooManyHeights + 1
  integer, parameter :: WrongUnitsForFrqTol    = TScatMIF + 1
  integer, parameter :: WrongUnitsForWindow    = WrongUnitsForFrqTol + 1
d395 3
a397 3
      & F_LOCKBINS, F_LSBLBLMOLECULES, F_LSBPFAMOLECULES, F_MODULE, &
      & F_MOLECULES, F_MOLECULEDERIVATIVES, F_MOLECULESECONDDERIVATIVES, &
      & F_NABTERMS, F_NAZIMUTHANGLES, &
d404 1
a404 2
    use INTRINSIC, only: L_NONE, L_CLEAR, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, &
      & PHYQ_FREQUENCY, PHYQ_PROFILES, PHYQ_TEMPERATURE
a567 2
        if ( expr_units(1) /= PHYQ_Frequency ) &
          & call AnnounceError ( WrongUnitsForFrqTol, son )
a578 2
        if ( expr_units(1) /= phyq_dimensionless ) &
          & call AnnounceError ( badSideband, root )
d591 3
a698 2
        if ( expr_units(1) /= phyq_temperature ) &
          & call AnnounceError ( toleranceNotK, root )
a703 2
        if ( expr_units(1) /= phyq_dimensionless ) &
          & call AnnounceError ( TScatMIF, root )
a1338 2
    case ( BadSideband )
      call output ( 'Sideband selector is not unitless', advance='yes' )
a1428 3
    case ( ToleranceNotK )
      call output ( 'Tolerance does not have dimensions of temperature/radiance', &
        & advance='yes' )
a1431 2
    case ( TScatMIF )
      call output ( 'TScatMIF must be dimensionless', advance='yes' )
a1434 2
    case ( WrongUnitsForFrqTol )
      call output ( 'FrqTol units must be frequency', advance='yes' )
d1449 1
a1449 1
       "$Id: ForwardModelSupport.f90,v 2.164 2012/08/16 18:07:43 pwagner Exp $"
d1459 3
@


2.164
log
@Exploit level 2-savvy MLSMessage
@
text
@a444 1
    integer :: M                        ! Max LBL molecules in either sideband
a910 1
    m = maxval(info%cat_size)
d1468 1
a1468 1
       "$Id: ForwardModelSupport.f90,v 2.163 2012/08/01 00:10:02 pwagner Exp $"
d1478 3
@


2.163
log
@Prevent references to undefined cat_sizes
@
text
@d412 2
a413 1
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
d537 1
d1470 1
a1470 1
       "$Id: ForwardModelSupport.f90,v 2.162 2012/05/01 22:22:58 vsnyder Exp $"
d1480 3
@


2.162
log
@Set IsRadianceModel component
@
text
@d833 1
d1468 1
a1468 1
       "$Id: ForwardModelSupport.f90,v 2.161 2012/03/28 00:56:49 vsnyder Exp $"
d1478 3
@


2.161
log
@Move check for signals with MIF extinction from Wrappers to Support
@
text
@d1024 1
d1060 1
d1064 1
d1077 1
d1084 2
d1467 1
a1467 1
       "$Id: ForwardModelSupport.f90,v 2.160 2012/03/07 02:13:18 vsnyder Exp $"
d1477 3
@


2.160
log
@Add transformMIFextinction switch
@
text
@d53 2
a54 1
  integer, parameter :: NeedBothXYStar         = LineParamTwice + 1
d1011 4
d1393 2
d1461 1
a1461 1
       "$Id: ForwardModelSupport.f90,v 2.159 2011/08/20 02:03:34 vsnyder Exp $"
d1471 3
@


2.159
log
@Remove unused use name
@
text
@d405 1
a405 1
      & F_TEMP_DER, F_TOLERANCE, F_TSCATMIF, F_TYPE, &
d519 1
d705 2
d1454 1
a1454 1
       "$Id: ForwardModelSupport.f90,v 2.158 2011/07/29 02:00:44 vsnyder Exp $"
d1464 3
@


2.158
log
@Remove TScatMolecules and TScatMoleculeDerivatives.  Make CloudIce a
molecule.  Remove Cloud_A and Cloud_S.
@
text
@a97 1
    use MLSSTRINGLISTS, only: SWITCHDETAIL
d1451 1
a1451 1
       "$Id: ForwardModelSupport.f90,v 2.157 2011/05/10 17:11:28 pwagner Exp $"
d1461 4
@


2.157
log
@Corrected goof that changed info%refract default
@
text
@d406 1
a406 2
      & F_TEMP_DER, F_TOLERANCE, F_TSCATMIF, F_TSCATMOLECULEDERIVATIVES, &
      & F_TSCATMOLECULES, F_TYPE, &
d415 1
a415 1
    use MOLECULES, only: L_CLOUD_A, L_CLOUD_S
a462 2
    integer :: TScatDerivTree           ! Tree index of f_TScatMoleculeDerivatives
    integer :: TScatMoleculeTree        ! Tree index of f_TScatMolecules
a709 4
      case ( f_TScatMoleculeDerivatives )
        TScatDerivTree = son
      case ( f_TScatMolecules )
        TScatMoleculeTree = son
a1006 23
    ! Get info%TScatMolecules and info%TScatMoleculeDerivatives
    if ( got(f_TScatMolecules) ) then
      call allocate_test ( info%TScatMolecules, nsons(TScatMoleculeTree)-1, &
        & 'TScatMolecules', moduleName )
      do j = 2, nsons(TScatMoleculeTree)
        info%TScatMolecules(j-1) = decoration( subtree( j, TScatMoleculeTree ) )
      end do
    end if
    if ( got(f_TScatMoleculeDerivatives) ) then
      call allocate_test ( info%TScatMoleculeDerivatives, &
        & nsons(TScatDerivTree)-1, 'TScatMoleculeDerivatives', moduleName, &
        & fill=.false. )
      if ( .not. associated(info%TScatMolecules) ) &
        & call announceError ( derivSansMolecules, derivTree )
      do j = 2, nsons(TScatDerivTree)
        thisMolecule = decoration( subtree( j, TScatDerivTree ) )
        if ( .not. any(info%TScatMolecules == thisMolecule) ) &
          & call announceError ( derivSansMolecules, subtree(j,TScatDerivTree) )
        if ( got(f_TScatMolecules) ) where ( info%TScatMolecules == thisMolecule ) &
            & info%TScatMoleculeDerivatives = .true.
      end do                          ! End loop over listed species
    end if
      
d1086 1
a1086 2
        if ( any(info%beta_group(i)%lbl(s)%molecules == l_cloud_a) .or. &
           & any(info%beta_group(i)%lbl(s)%molecules == l_cloud_s) ) &
d1452 1
a1452 1
       "$Id: ForwardModelSupport.f90,v 2.156 2011/05/09 18:09:30 pwagner Exp $"
d1462 3
@


2.156
log
@Converted to using switchDetail
@
text
@d515 1
a515 1
    info%refract = switchDetail(switches,'norf') == 0 ! Default .true.
d1483 1
a1483 1
       "$Id: ForwardModelSupport.f90,v 2.155 2011/03/31 19:47:54 vsnyder Exp $"
d1493 3
@


2.155
log
@Validate signals when the signals field is processed, so that sidebands
are set.  Only check that cloud_a and cloud_s are PFA for the desired
sidebands.
@
text
@d81 1
a81 1
    use AntennaPatterns_m, only: OPEN_ANTENNA_PATTERNS_FILE, &
d83 1
a83 1
    use FilterShapes_m, only: OPEN_FILTER_SHAPES_FILE, &
d86 20
a105 19
    use Init_Tables_Module, only: F_ANTENNAPATTERNS, F_DACSFILTERSHAPES, &
      & F_FILTERSHAPES, F_L2PC, F_MieTables, F_PFAFILES, F_POINTINGGRIDS
    use intrinsic, only: l_ascii, l_hdf
    use L2ParInfo, only: PARALLEL
    use L2PC_m, only: READCOMPLETEHDF5L2PCFILE
    use MLSCommon, only: MLSFile_T
    use MLSPCF2, only: MLSPCF_antpats_start, MLSPCF_filtshps_start, &
      &          mlspcf_dacsfltsh_start, MLSPCF_ptggrids_start, &
      &          mlspcf_l2pc_start, mlspcf_l2pc_end, &
      &          mlspcf_MieTables_start, &
      &          mlspcf_pfa_start, mlspcf_pfa_end
    use MoreTree, only: Get_Field_ID
    use PFADataBase_m, only: Process_PFA_File
    use PointingGrid_m, only: Close_Pointing_Grid_File, &
      & Open_Pointing_Grid_File, Read_Pointing_Grid_File
    use Read_Mie_m, only: Read_Mie
    use Toggles, only: Gen, Levels, Toggle
    use Trace_M, only: Trace_begin, Trace_end
    use Tree, only: Nsons, Sub_Rosa, Subtree
d218 8
a225 8
      use hdf, only: dfacc_rdonly
      use init_tables_module, only: field_indices
      use MLSCommon, only: MLSFile_T
      use MLSFiles, only: HDFVERSION_5, &
        & AddInitializeMLSFile, GetPCFromRef, split_path_name
      use MLSL2Options, only: TOOLKIT
      use SDPToolkit, only: Pgs_pc_getReference
      use String_Table, only: Get_String
d284 3
a286 3
    use Expr_M, only: EXPR
    use Init_Tables_Module, only: FIELD_FIRST, FIELD_LAST
    use Init_Tables_Module, only: L_NAMEFRAGMENT, L_VMR, L_TEMPERATURE, &
d288 1
a288 1
    use Init_Tables_Module, only: F_COST, F_HEIGHT, F_MOLECULE, F_TYPE, &
d290 1
a290 1
    use Intrinsic, only: T_NUMERIC_RANGE, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, &
d292 4
a295 4
    use L2PC_m, only: BINSELECTOR_T, BINSELECTORS, CREATEDEFAULTBINSELECTORS
    use MLSCommon, only: R8
    use MoreTree, only: Get_Field_ID, GET_BOOLEAN
    use Tree, only: Decoration, Nsons, Sub_Rosa, Subtree
d385 7
a391 7
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Expr_M, only: EXPR
    use ForwardModelConfig, only: Dump, ForwardModelConfig_T, &
      & LineCenter, LineWidth, LineWidth_TDep, &
      & NullifyForwardModelConfig, SpectroParam_T
    use Init_Tables_Module, only: FIELD_FIRST, FIELD_LAST
    use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR, L_CLOUDFULL, L_HYBRID, &
d393 1
a393 1
    use Init_Tables_Module, only: F_ALLLINESFORRADIOMETER, F_ALLLINESINCATALOG, &
d395 1
a395 1
      & F_DEFAULT_spectroscopy, F_DIFFERENTIALSCAN, F_DO_BASELINE, F_DO_CONV, &
d406 4
a409 4
      & F_TEMP_DER, F_TOLERANCE, F_TScatMIF, F_TScatMoleculeDerivatives, &
      & F_TScatMolecules, F_TYPE, &
      & F_USBLBLMOLECULES, F_USBPFAMOLECULES, F_UseTScat, F_XSTAR, F_YSTAR
    use Intrinsic, only: L_NONE, L_CLEAR, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, &
d411 15
a425 14
    use L2PC_m, only: BINSELECTORS, DEFAULTSELECTOR_LATITUDE, CREATEDEFAULTBINSELECTORS
    use MLSCommon, only: R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSNumerics, only: HUNT
    use MLSSignals_M, only: Signals
    use Molecules, only: L_Cloud_A, L_Cloud_S
    use MoreTree, only: Get_Boolean, Get_Field_ID
    use Parse_Signal_m, only: PARSE_SIGNAL
    use String_Table, only: Get_String
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_begin, Trace_end
    use Tree, only: Decoration, Node_ID, Nsons, Null_Tree, Sub_Rosa, Subtree
    use Tree_Types, only: N_Array
    use VGridsDatabase, only: VGrids
d515 1
a515 1
    info%refract = index(switches,'norf') == 0 ! Default .true.
d1483 1
a1483 1
       "$Id: ForwardModelSupport.f90,v 2.154 2011/01/29 00:52:51 vsnyder Exp $"
d1493 5
@


2.154
log
@Allow PFA without frequency averaging
@
text
@d683 2
a1066 3
      ! Make sure signal specifications make sense; get sideband Start/Stop
      call validateSignals

d1113 5
a1117 5
      if ( any(info%beta_group(i)%lbl(1)%molecules == l_cloud_a) .or. &
         & any(info%beta_group(i)%lbl(1)%molecules == l_cloud_s) .or. &
         & any(info%beta_group(i)%lbl(2)%molecules == l_cloud_a) .or. &
         & any(info%beta_group(i)%lbl(2)%molecules == l_cloud_s) ) &
           & call announceError ( CloudLBL, root )
d1481 1
a1481 1
       "$Id: ForwardModelSupport.f90,v 2.153 2010/11/08 19:26:22 pwagner Exp $"
d1491 3
@


2.153
log
@Slight improvement of unhelpful error message
@
text
@d59 1
a59 2
  integer, parameter :: PFANeedsFreqAvg        = NoPolarizedAndPFA + 1
  integer, parameter :: PFANotMolecule         = PFANeedsFreqAvg + 1
a1033 5
    ! If any PFA and any LBL, need to do frequency averaging too
    if ( any(info%anyPFA(s1:s2)) .and. any(info%anyLBL(s1:s2)) &
      & .and. .not. info%do_freq_avg ) &
      & call AnnounceError ( PFANeedsFreqAvg, root )

a1431 4
    case ( PFANeedsFreqAvg )
      call output ( &
        & 'Frequency averaging must be specified if there are both PFA and LBL molecules', &
        & advance='yes' )
d1482 1
a1482 1
       "$Id: ForwardModelSupport.f90,v 2.152 2010/08/27 06:20:47 yanovsky Exp $"
d1492 3
@


2.152
log
@Added atmos_second_der, moleculeSecondDerivatives.
Added error handling: Hess_notJac, SecondDerivTree, FirstSansFirst1,
FirstSansFirst2, SecondSansFirst, SecondSansSecond1, SecondSansSecond2.
@
text
@d1129 2
a1130 1
      call MLSMessage ( MLSMSG_Error, ModuleName, 'An error occured' )
d1492 1
a1492 1
       "$Id: ForwardModelSupport.f90,v 2.151 2010/06/07 23:30:12 vsnyder Exp $"
d1502 5
@


2.151
log
@Add TScatMolecules, TScatMoleculeDerivatives, Use_Tscat.  Change
PhaseFrqTol to FrqTol.
@
text
@d42 4
a45 1
  integer, parameter :: IncompleteBinSelectors = DuplicateMolecule + 1
d63 4
a66 1
  integer, parameter :: TangentNotSubset       = PolarizedAndAllLines + 1
d394 1
a394 1
      & F_ATMOS_DER, F_BINSELECTORS, F_CHANNELS, F_CLOUD_DER, &
d400 2
a401 1
      & F_MOLECULES, F_MOLECULEDERIVATIVES, F_NABTERMS, F_NAZIMUTHANGLES, &
d453 1
d485 1
d546 2
d640 2
d739 4
d966 3
d973 4
d984 25
d1381 1
a1381 1
      call display_string ( what, before='Cloud formard model cannot accept the ' )
d1389 9
d1452 9
d1462 2
a1463 2
      call output ('Non subsurface tangent grid not a subset of integration&
        & grid', advance='yes' )
d1491 1
a1491 1
       "$Id: ForwardModelSupport.f90,v 2.150 2010/04/30 01:53:26 vsnyder Exp $"
d1501 4
@


2.150
log
@Add description to 'Irrelevant parameter' error message
@
text
@d390 1
a390 1
      & F_DO_FREQ_AVG, F_DO_1D, F_FORCESIDEBANDFRACTION, F_FREQUENCY, &
d396 1
a396 1
      & F_NSIZEBINS, F_PATHNORM, F_PHASEFRQTOL, F_PHIWINDOW, F_POLARIZED, &
d399 3
a401 2
      & F_TEMP_DER, F_TOLERANCE, F_TScatMIF, F_TYPE, &
      & F_USBLBLMOLECULES, F_USBPFAMOLECULES, F_XSTAR, F_YSTAR
d438 1
a438 1
    integer :: MoleculeTree             ! Tree index of f_molecules
d455 2
d487 1
a502 1
    info%phaseFrqTol = 25000.0 ! MHz
d514 1
d559 5
a616 5
      case ( f_phaseFrqTol )
        call expr ( subtree(2,son), expr_units, value, type )
        info%phaseFrqTol = value(1)
        if ( expr_units(1) /= PHYQ_Frequency ) &
          & call AnnounceError ( WrongUnitsForFrqTol, son )
d697 4
d707 2
d949 1
a949 1
    ! Now some more error checking
d962 24
d1409 1
a1409 1
      call output ( 'PhaseFrqTol units must be frequency', advance='yes' )
d1424 1
a1424 1
       "$Id: ForwardModelSupport.f90,v 2.149 2010/03/26 23:16:12 vsnyder Exp $"
d1434 3
@


2.149
log
@Add ignoreHessian field to forward model config
@
text
@d1014 3
a1016 1
        & call AnnounceError ( IrrelevantFwmParameter, root )
d1022 2
a1023 1
        & call AnnounceError ( IrrelevantFwmParameter, root )
d1390 1
a1390 1
       "$Id: ForwardModelSupport.f90,v 2.148 2010/02/25 18:17:48 pwagner Exp $"
d1400 3
@


2.148
log
@Removed outmoded ascii l2pc file support
@
text
@d390 2
a391 2
      & F_DO_FREQ_AVG, F_DO_1D, F_FREQUENCY, F_I_SATURATION, F_INCL_CLD, &
      & F_FORCESIDEBANDFRACTION, F_INTEGRATIONGRID, &
d487 1
d557 2
d1387 1
a1387 1
       "$Id: ForwardModelSupport.f90,v 2.147 2010/02/09 16:22:32 pwagner Exp $"
d1397 3
@


2.147
log
@Give info%GenerateTScat an initial value
@
text
@d85 1
a85 2
    use L2PC_m, only: OPEN_L2PC_FILE, CLOSE_L2PC_FILE, READ_L2PC_FILE, &
      & READCOMPLETEHDF5L2PCFILE
d169 1
a169 8
          if ( index ( fileName, '.txt' ) /= 0 ) then
            call open_l2pc_file ( fileName, lun)
            call read_l2pc_file ( lun, subtree(j,son) )
            call close_l2pc_file ( lun )
          else
            ! call ReadCompleteHDF5L2PCFile ( fileName )
            call ReadCompleteHDF5L2PCFile ( MLSFile, subtree(j,son) )
          end if
d1384 1
a1384 1
       "$Id: ForwardModelSupport.f90,v 2.146 2010/01/22 01:00:20 vsnyder Exp $"
d1394 3
@


2.146
log
@Require Cloud_A and Cloud_S "molecules" to be handled as PFA, not LBL.
@
text
@d492 1
d1392 1
a1392 1
       "$Id: ForwardModelSupport.f90,v 2.145 2009/06/23 18:46:18 pwagner Exp $"
d1402 3
@


2.145
log
@Prevent Intel from optimizing ident string away
@
text
@d37 2
a38 1
  integer, parameter :: CloudNeeds             = CloudHas + 1
d416 1
d446 1
a446 1
    integer, dimension(:), pointer :: Molecules ! In a LineTree
d903 1
a903 1
      molecules => lineStru%molecule
d910 1
a910 1
        molecules(j-1) = decoration( son )
d913 1
a913 1
          if ( molecules(k-1) == thisMolecule ) &
d921 2
a922 2
            do found = 1, size(molecules)
              if ( abs(molecules(found)) == info%beta_group(b)%lbl(s)%molecules(1) ) then
d924 1
a924 1
                molecules(found) = -abs(molecules(found)) ! Mark it as used
d933 2
a934 2
      do j = 1, size(molecules)
        if ( molecules(j) > 0 ) & ! not used, so not in any LBL list
d936 1
a936 1
        molecules(j) = abs(molecules(j))
d1037 8
d1293 2
d1391 1
a1391 1
       "$Id: read_apriori.f90 is it here $"
d1401 3
@


2.144
log
@Added print to not_used_here
@
text
@d1376 2
a1377 2
  logical function NOT_USED_HERE()
  !---------------------------- RCS Ident Info -------------------------------
d1379 1
a1379 1
    & "$Id: ForwardModelSupport.f90,v 2.143 2008/09/30 22:37:51 vsnyder Exp $"
a1380 1
  !---------------------------------------------------------------------------
d1382 3
a1384 2
    print *, not_used_here ! .mod files sometimes change if PRINT is added
  end function NOT_USED_HERE
d1389 3
@


2.143
log
@Use nint(value) for TScatMIF
@
text
@a234 1
      ! type (MLSFile_T), pointer :: MLSFile
a269 1
          ! & type=l_hdf, access='rdonly', HDFVersion=HDFVERSION_5)
a274 1
          ! & type=l_ascii, access='rdonly')
d1379 1
a1379 1
    & "$Id: ForwardModelSupport.f90,v 2.142 2008/08/21 23:42:46 vsnyder Exp $"
d1383 1
d1389 3
@


2.142
log
@Remove GenerateTScat from ForwardModel; use TScat on Sids
@
text
@d695 1
a695 1
        info%TScatMIF = value(1)
d1382 1
a1382 1
    & "$Id: ForwardModelSupport.f90,v 2.141 2008/07/30 19:08:00 vsnyder Exp $"
d1391 3
@


2.141
log
@Add PhaseFrqTol field to ForwardModel spec
@
text
@d401 1
a401 1
      & F_FORCESIDEBANDFRACTION, F_GenerateTScat, F_INTEGRATIONGRID, &
a492 1
    info%generateTScat = .false.
a561 2
      case ( f_generateTScat )
        info%generateTScat = get_boolean(son)
d1382 1
a1382 1
    & "$Id: ForwardModelSupport.f90,v 2.140 2008/06/06 22:52:53 pwagner Exp $"
d1391 3
@


2.140
log
@EssentiallyEqual moved to MLSFillValues
@
text
@d63 3
a65 1
  integer, parameter :: WrongUnitsForWindow    = TooManyHeights + 1
d401 4
a404 4
      & F_FORCESIDEBANDFRACTION, F_INTEGRATIONGRID, F_LINEARSIDEBAND, &
      & F_LINECENTER, F_LINEWIDTH, F_LINEWIDTH_TDEP, F_LOCKBINS, &
      & F_LSBLBLMOLECULES, F_LSBPFAMOLECULES, F_MODULE, F_MOLECULES, &
      & F_MOLECULEDERIVATIVES, F_NABTERMS, F_NAZIMUTHANGLES, &
d406 5
a410 5
      & F_NSIZEBINS, F_PATHNORM, F_PHIWINDOW, F_POLARIZED, F_REFRACT, &
      & F_SCANAVERAGE, F_SIGNALS, F_SKIPOVERLAPS, F_SPECIFICQUANTITIES, &
      & F_SPECT_DER, F_SWITCHINGMIRROR, F_TANGENTGRID, F_TEMP_DER, &
      & F_TOLERANCE, F_TYPE, F_USBLBLMOLECULES, F_USBPFAMOLECULES, &
      & F_XSTAR, F_YSTAR
d412 1
a412 1
      & PHYQ_PROFILES, PHYQ_TEMPERATURE
d507 1
d518 1
a558 2
      case ( f_pathNorm )
        info%do_path_norm = get_boolean(son)
d563 2
d614 7
d696 5
d1364 2
d1369 2
d1385 1
a1385 1
    & "$Id: ForwardModelSupport.f90,v 2.139 2008/05/20 00:28:06 vsnyder Exp $"
d1394 3
@


2.139
log
@Process MieTables field from ForwardModelGlobal
@
text
@d1066 1
a1066 1
      use MLSNumerics, only: EssentiallyEqual
d1365 1
a1365 1
    & "$Id: ForwardModelSupport.f90,v 2.138 2008/05/02 00:33:30 vsnyder Exp $"
d1374 3
@


2.138
log
@Delete unused symbol
@
text
@d79 1
a79 1
      & F_FILTERSHAPES, F_L2PC, F_PFAFILES, F_POINTINGGRIDS
d88 1
d94 1
d176 7
d491 1
d1365 1
a1365 1
    & "$Id: ForwardModelSupport.f90,v 2.137 2008/05/01 01:56:33 vsnyder Exp $"
d1374 3
@


2.137
log
@Don't check grids subset if they're associated
@
text
@d95 1
a95 1
    use Tree, only: Nsons, Source_Ref, Sub_Rosa, Subtree
d1355 1
a1355 1
    & "$Id: ForwardModelSupport.f90,v 2.136 2007/11/07 03:10:48 vsnyder Exp $"
d1364 3
@


2.136
log
@Add pathNorm field to forward model config
@
text
@d962 7
a968 5
      do tangent = info%surfaceTangentIndex, info%tangentGrid%noSurfs
        if ( .not. any ( abs( info%tangentGrid%surfs(tangent,1) - &
          & info%integrationGrid%surfs(:,1) ) < 1e-4 ) ) &
          & call AnnounceError ( TangentNotSubset, root )
      end do
d1355 1
a1355 1
    & "$Id: ForwardModelSupport.f90,v 2.135 2007/10/03 23:59:04 vsnyder Exp $"
d1364 3
@


2.135
log
@Add 'where' for tracing
@
text
@d395 4
a398 4
      & F_NSIZEBINS, F_PHIWINDOW, F_POLARIZED, F_REFRACT, F_SCANAVERAGE, &
      & F_SIGNALS, F_SKIPOVERLAPS, F_SPECIFICQUANTITIES, F_SPECT_DER, &
      & F_SWITCHINGMIRROR, F_TANGENTGRID, &
      & F_TEMP_DER, F_TOLERANCE, F_TYPE, F_USBLBLMOLECULES, F_USBPFAMOLECULES, &
d479 1
d545 2
d1353 1
a1353 1
    & "$Id: ForwardModelSupport.f90,v 2.134 2006/11/29 01:08:58 vsnyder Exp $"
d1362 3
@


2.134
log
@Allocate spectroscopy derivative stuff with zero size if not used
@
text
@d138 1
a138 1
          call read_antenna_patterns_file ( lun )
d147 1
a147 1
          call read_DACS_filter_shapes_file ( lun, fileIndex )
d156 1
a156 1
          call read_filter_shapes_file ( lun, fileIndex )
d167 1
a167 1
            call read_l2pc_file ( lun )
d171 1
a171 1
            call ReadCompleteHDF5L2PCFile ( MLSFile )
d182 1
a182 1
            & source_ref(subtree(j,son)) ) /= 0 ) continue
d191 1
a191 1
          call read_pointing_grid_file ( lun )
d1350 1
a1350 1
    & "$Id: ForwardModelSupport.f90,v 2.133 2006/07/20 23:39:53 vsnyder Exp $"
d1359 3
@


2.133
log
@Remove unused declarations and USEs
@
text
@a865 1
      if ( lineTrees(i) == null_tree ) cycle
d867 1
a867 1
      allocate ( lineStru(nsons(lineTrees(i))-1), stat=status )
d877 1
d1350 1
a1350 1
    & "$Id: ForwardModelSupport.f90,v 2.132 2006/06/03 01:46:20 vsnyder Exp $"
d1359 3
@


2.132
log
@Remove no_dup_mol flag from config structure
@
text
@a408 1
    use output_m, only: output
d1350 1
a1350 1
    & "$Id: ForwardModelSupport.f90,v 2.131 2006/05/11 19:37:32 pwagner Exp $"
d1359 3
@


2.131
log
@Added option to disallow duplicate molecules
@
text
@d439 1
a489 1
    info%no_dup_mol = .false.
d514 1
d590 1
a590 3
        info%no_dup_mol = get_boolean(son)
!         call output('Setting no_dup_mol: ', advance='no')
!         call output(info%no_dup_mol, advance='yes')
d769 1
a769 1
              warn=.not. info%no_dup_mol)
d779 1
a779 1
                warn=.not. info%no_dup_mol )
d1351 1
a1351 1
    & "$Id: ForwardModelSupport.f90,v 2.130 2006/04/18 00:08:45 pwagner Exp $"
d1360 3
@


2.130
log
@Allow abbreviated, pathless PFA files with PCF
@
text
@d394 1
a394 1
      & F_NCLOUDSPECIES, F_NMODELSURFS, F_NSCATTERINGANGLES, &
d409 1
d489 1
d588 4
d690 2
d760 1
d769 2
a770 1
              what=info%beta_group(b)%lbl(1)%molecules(i), warn=.true. )
d779 2
a780 1
                what=info%beta_group(b)%lbl(1)%molecules(i), warn=.true. )
d1230 8
a1237 3
    logical, optional, intent(in) :: Warn ! Warning if present, no matter what value

    if ( .not. present(warn) ) error = max(error,1)
d1345 2
d1352 1
a1352 1
    & "$Id: ForwardModelSupport.f90,v 2.129 2006/03/30 18:58:47 vsnyder Exp $"
d1361 3
@


2.129
log
@Allow duplicates in [LU]SBpfaMolecules and [LU]SBlblMolecules lists
@
text
@d87 2
a88 1
      &          mlspcf_l2pc_start, mlspcf_l2pc_end
d112 1
d175 1
d177 5
a181 1
          if ( process_PFA_File ( sub_rosa(subtree(j,son)), &
d183 1
d1334 1
a1334 1
    & "$Id: ForwardModelSupport.f90,v 2.128 2006/03/22 02:23:46 vsnyder Exp $"
d1343 3
@


2.128
log
@Add lsbLBLmolecules, useLBLmolecules
@
text
@d784 3
a786 2
                if ( info%beta_group(b)%pfa(s)%molecules(k) /= 0 ) &
                  & call announceError ( PFATwice, son )
d1326 1
a1326 1
    & "$Id: ForwardModelSupport.f90,v 2.127 2006/02/23 00:52:09 vsnyder Exp $"
d1335 3
@


2.127
log
@Make sure instrumentModule has a value, report all errors before quitting
@
text
@d45 2
a46 1
  integer, parameter :: LinearSidebandHasUnits = IrrelevantFwmParameter + 1
d383 2
a384 2
      & F_LINECENTER, F_LINEWIDTH, F_LINEWIDTH_TDEP, &
      & F_LOCKBINS, F_LSBPFAMOLECULES, F_MODULE, F_MOLECULES, &
d390 2
a391 1
      & F_TEMP_DER, F_TOLERANCE, F_TYPE, F_USBPFAMOLECULES, F_XSTAR, F_YSTAR
d423 1
d441 1
d502 1
d557 2
d662 2
d675 6
d688 1
a688 1
      ! the PFA Molecules trees.
d725 1
a725 1
          if ( pfaTrees(s) /= null_tree ) then
d727 1
d729 2
a730 2
              & size(info%beta_group(b)%lbl(s)%molecules), 'PFA Molecules', moduleName )
            info%beta_group(b)%pfa(s)%molecules = 0
d768 1
a768 1
    ! Now the PFAMolecules lists
d770 6
a775 5
      if ( pfaTrees(s) /= null_tree ) then
        ! Verify that the PFA molecules are all listed molecules.  Mark the
        ! ones that are PFA.
op:     do j = 2, nsons(PFATrees(s))
          son = subtree( j, PFATrees(s) )
d792 1
a792 1
        end do op ! j = 2, nsons(PFATrees(s))
d797 7
a803 2
          numLBL = count(tempPFA == 0)
          numPFA = size(tempPFA) - numLBL
d810 7
a816 2
          info%beta_group(b)%lbl(s)%molecules = pack(tempLBL,tempPFA == 0)
          info%beta_group(b)%pfa(s)%molecules = pack(tempLBL,tempPFA /= 0)
d1217 1
a1217 1
      call output ( 'allocation error.', advance='yes' )
d1219 1
a1219 1
      call output ('cannot have a fieldAzimuth binSelector for polarlinear model', &
d1248 1
a1248 1
      call output ('must have some binSelectors for the polarlinear model',advance='yes' )
d1250 1
a1250 1
      call output ('incomplete full foward model specification',advance='yes' )
d1252 4
a1255 1
      call output ( 'incomplete linear foward model specification', &
d1258 1
a1258 1
      call output ( 'irrelevant parameter for this forward model type', &
d1261 1
a1261 1
      call output ( 'irrelevant units for this linear sideband', &
d1271 1
a1271 1
      call output ( 'x/yStar must either be both present or both absent', &
d1276 1
a1276 1
      call output ( "Nested array not allowed here", advance='yes' )
d1291 1
a1291 1
      call output ( 'PFA requested for ' )
d1297 1
a1297 1
      call output ( ' listed twice for PFA', advance='yes' )
d1299 1
a1299 1
      call output ( 'cannot specify both polarized and allLinesInCatalog', &
d1302 1
a1302 1
      call output ('non subsurface tangent grid not a subset of integration&
d1305 1
a1305 1
      call output ( 'tolerance does not have dimensions of temperature/radiance', &
d1314 1
a1314 1
      call output ( 'phiWindow must be in degrees or profiles', &
d1325 1
a1325 1
    & "$Id: ForwardModelSupport.f90,v 2.126 2006/02/08 21:33:43 vsnyder Exp $"
d1334 3
@


2.126
log
@Announce warning for duplicate molecules
@
text
@d470 1
d594 1
d604 1
a604 1
            exit
d1295 1
a1295 1
    & "$Id: ForwardModelSupport.f90,v 2.125 2006/02/07 00:19:07 vsnyder Exp $"
d1304 3
@


2.125
log
@Prohibit conspiracy of polarized and PFA
@
text
@d40 2
a41 1
  integer, parameter :: IncompleteBinSelectors = DerivSansMolecules + 1
d725 25
d1215 3
d1293 1
a1293 1
    & "$Id: ForwardModelSupport.f90,v 2.124 2006/01/11 01:56:48 vsnyder Exp $"
d1302 3
@


2.124
log
@Allow PFA for sidebands not in signals, but ignore it -- of course
@
text
@d52 2
a53 1
  integer, parameter :: PFANeedsFreqAvg        = NoMolecule + 1
d371 1
a419 1
    integer, dimension(:,:), pointer :: Line_Ix ! LineCenter_ix, ...
a441 3
    ! Subscripts for LineTrees
    integer, parameter :: LineCenter = 1, LineWidth = 2, LineWidth_TDep = 3

a796 2
      nullify ( line_ix )
      call allocate_test ( line_ix, 2, m, 'Line_ix', moduleName, fill=0 )
a799 1
        info%lineCenter_ix => line_ix
a801 1
        info%lineWidth_ix => line_ix
a803 1
        info%lineWidth_Tdep_ix => line_ix
a820 1
        k = 0 ! Index in line..._ix
d822 1
a822 2
          do j = 1, size(info%beta_group(b)%lbl(s)%molecules)
            k = k + 1
d824 2
a825 1
              if ( abs(molecules(found)) == info%beta_group(b)%lbl(s)%molecules(j) ) then
d827 1
a827 1
                line_ix(s,k) = found
d831 1
a831 1
          end do ! j
d863 4
d1178 1
a1178 2
      call output ( 'Cloud forward model internally has the ' )
      call display_string ( what )
d1184 1
a1184 2
      call output ( 'Cloud formard model cannot accept the ' )
      call display_string ( what )
d1203 3
a1205 3
      call output ( 'Spectral parameter requested for ' )
      call display_string ( lit_indices(decoration(where)) )
      call output ( ' but it is not in an LBL molecule list', advance='yes' )
d1207 1
a1207 2
      call output ( 'Molecule ' )
      call display_string ( lit_indices(decoration(where)) )
d1222 3
d1234 2
a1235 2
      call output ( 'Molecule ' )
      call display_string ( lit_indices(decoration(where)) )
d1264 1
a1264 1
    & "$Id: ForwardModelSupport.f90,v 2.123 2006/01/04 21:54:26 vsnyder Exp $"
d1273 3
@


2.123
log
@'norf' switch sets refraction default to false
@
text
@d54 1
a54 2
  integer, parameter :: PFASSB                 = PFANotMolecule + 1
  integer, parameter :: PFATwice               = PFASSB + 1
d391 1
a391 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d901 2
a902 1
         & call AnnounceError ( PFASSB, root )
a1236 3
    case ( PFASSB )
      call output ( 'Signal is SSB, but PFA is requested for the other sideband', &
        & advance='yes' )
d1268 1
a1268 1
    & "$Id: ForwardModelSupport.f90,v 2.122 2005/12/29 01:11:08 vsnyder Exp $"
d1277 3
@


2.122
log
@Add boolean 'refract' field to ForwardModel spec
@
text
@d398 1
a398 1
    use Toggles, only: Gen, Levels, Toggle
d484 1
a484 1
    info%refract = .true.
d1271 1
a1271 1
    & "$Id: ForwardModelSupport.f90,v 2.121 2005/12/22 21:08:15 vsnyder Exp $"
d1280 3
@


2.121
log
@Require frequency averaging if both PFA and LBL
@
text
@d35 2
a36 1
  integer, parameter :: CloudHas               = BadQuantityType  + 1
d384 2
a385 2
      & F_NSIZEBINS, F_PHIWINDOW, F_POLARIZED, F_SCANAVERAGE, F_SIGNALS, &
      & F_SKIPOVERLAPS, F_SPECIFICQUANTITIES, F_SPECT_DER, &
d484 1
d544 1
a544 1
          & call AnnounceError ( toleranceNotK, root )
d587 2
d1179 2
d1271 1
a1271 1
    & "$Id: ForwardModelSupport.f90,v 2.120 2005/11/02 21:37:19 vsnyder Exp $"
d1280 3
@


2.120
log
@Hoist some stuff out of FullForwardModel
@
text
@d863 3
a865 2
    ! If any PFA, need to do frequency averaging too
    if ( any(info%anyPFA(s1:s2)) .and. .not. info%do_freq_avg ) &
d1224 2
a1225 1
      call output ( 'Frequency averaging must be specified if there are any PFA molecules', &
d1265 1
a1265 1
    & "$Id: ForwardModelSupport.f90,v 2.119 2005/10/14 23:14:28 vsnyder Exp $"
d1274 3
@


2.119
log
@Require Frequency Averaging if any PFA molecules
@
text
@d588 1
d618 1
d622 2
d1263 1
a1263 1
    & "$Id: ForwardModelSupport.f90,v 2.118 2005/09/16 23:39:07 vsnyder Exp $"
d1272 3
@


2.118
log
@Add spect_der field to ForwardModel
@
text
@d51 2
a52 1
  integer, parameter :: PFANotMolecule         = NoMolecule + 1
d859 4
d1218 3
d1259 1
a1259 1
    & "$Id: ForwardModelSupport.f90,v 2.117 2005/09/03 01:20:41 vsnyder Exp $"
d1268 3
@


2.117
log
@Spectral parameter offsets stuff
@
text
@d383 1
a383 1
      & F_SKIPOVERLAPS, F_SPECIFICQUANTITIES, &
a431 1
    integer, pointer :: SpecIndices(:)  ! Indices in info%line...
d631 2
a787 1
      info%spect_der = .true.
d791 1
d1251 1
a1251 1
    & "$Id: ForwardModelSupport.f90,v 2.116 2005/08/03 18:07:39 vsnyder Exp $"
d1260 3
@


2.116
log
@Scan averaging, some spectroscopy derivative stuff
@
text
@d417 1
a417 1
    integer, pointer :: SpecIndices(:)  ! Indices in info%line...
d420 1
d427 1
d432 1
d656 1
d699 1
a699 1
        do s = 1, 2 ! both sidebands
d709 1
a709 1
        end do ! s = 1, 2
d718 1
a718 1
    do s = 1, 2
d765 1
d767 2
d770 1
a770 2
          & size(info%beta_group(b)%lbl(s)%molecules), &
          & 'beta_group(b)%Cat_Index', moduleName )
d773 1
a773 2
          &                  size(info%beta_group(b)%lbl(s)%molecules), &
          &                  'LBL Ratio', moduleName )
d781 2
a782 1
    end do ! s = 1, 2
d786 34
a819 33
      if ( lineTrees(i) /= null_tree ) then
        info%spect_der = .true.
        ! Make a list of the molecules
        allocate ( lineStru(nsons(lineTrees(i)-1)), stat=status )
        if ( status /= 0 ) call announceError( AllocateError, lineTrees(i) )
        select case ( i )
        case ( lineCenter )
          info%lineCenter => lineStru
        case ( lineWidth )
          info%lineWidth => lineStru
        case ( lineWidth_TDep )
          info%lineWidth_TDep => lineStru
        end select
        molecules => lineStru%molecule
        do j = 2, nsons(LineTrees(i))
          son = subtree( j, LineTrees(i) )
          if ( node_id(son) == n_array ) then
            call announceError ( NoArray, son )
            cycle
          end if
          thisMolecule = decoration( son )
          ! Find the molecule's index in info%molecules
          do k = size(info%molecules), 1, -1
            if ( info%molecules(k) == thisMolecule ) exit
          end do ! k = size(info%molecules), 1, -1
          if ( k == 0 ) call announceError ( LineNotMolecule, son )
          molecules(j-1) = thisMolecule
          ! Look for duplicates
          do k = 2, j-1
            if ( molecules(k-1) == k ) call announceError ( lineParamTwice, son )
          end do  ! k = 2, j-1
        end do ! j = 2, nsons(LineTrees(i))
        ! Abstract from the list for each beta group's LBL molecules
d821 10
a830 32
          do s = 1, 2 ! Sideband
            ! Do we need to allocate the spectroscopy parameter structure?
NeedSP:     do j = 1, size(molecules)
              do found = size(info%beta_group(b)%lbl(s)%molecules), 1, -1
                if ( molecules(j) == info%beta_group(b)%lbl(s)%molecules(found) ) &
                  & exit NeedSP
              end do ! found
            end do NeedSp
            if ( found > 0 ) then ! Need to allocate
              call allocate_test ( specIndices, &
                & size(info%beta_group(b)%lbl(s)%molecules), &
                & 'SpecIndices', moduleName, fill=0 )
            end if
            select case ( i )
            case ( lineCenter )
              info%beta_group(b)%lbl(s)%lineCenter => specIndices
            case ( lineWidth )
              info%beta_group(b)%lbl(s)%lineWidth => specIndices
            case ( lineWidth_TDep )
              info%beta_group(b)%lbl(s)%lineWidth_TDep => specIndices
            end select
            ! Now mark the molecules needed
MarkSP:     do j = 1, size(molecules)
              do found = 1, size(specIndices)
                if ( abs(molecules(j)) == info%beta_group(b)%lbl(s)%molecules(found) ) then
                  specIndices(found) = j
                  molecules(j) = -molecules(j) ! Mark it as used
                  exit MarkSP
                end if
              end do ! found
            end do MarkSP
          end do ! s = 1, 2
d832 7
a838 7
        ! Check for unused ones, make them positive again
        do j = 1, size(molecules)
          if ( molecules(j) > 0 ) & ! not used, so not in any LBL list
            & call announceError ( LineNotMolecule, subtree(j+1,lineTrees(i)) )
          molecules(j) = abs(molecules(j))
        end do
      end if ! lineTrees(i) /= null_tree
d866 4
d1250 1
a1250 1
    & "$Id: ForwardModelSupport.f90,v 2.115 2005/06/29 00:43:45 pwagner Exp $"
d1259 3
@


2.115
log
@Utilizes new interface to ReadCompleteHDF5L2PCFile
@
text
@d44 3
a46 1
  integer, parameter :: NeedBothXYStar         = LinearSidebandHasUnits + 1
d368 2
a369 1
    use ForwardModelConfig, only: Dump, ForwardModelConfig_T, NullifyForwardModelConfig
d378 1
d382 3
a384 2
      & F_NSIZEBINS, F_PHIWINDOW, F_POLARIZED, F_SIGNALS, F_SKIPOVERLAPS, &
      & F_SPECIFICQUANTITIES, F_SPECT_DER, F_SWITCHINGMIRROR, F_TANGENTGRID, &
d408 1
d413 1
d417 3
d421 1
d438 3
d458 1
a458 1
    info%DEFAULT_spectroscopy = .false.
d480 1
d494 1
d540 6
d582 2
a628 2
      case ( f_spect_der )
        info%spect_der = get_boolean(son)
d662 4
a665 4
      do i = 1, nsons(moleculeTree) - 1
        son = subtree(i+1,moleculeTree)
        info%beta_group(i)%group = node_id(son) == n_array
        if ( info%beta_group(i)%group ) then
d668 5
a672 5
          call allocate_test ( info%beta_group(i)%lbl(1)%molecules, nsons(son)-1, &
            & 'info%beta_group(i)%lbl(1)%molecules', moduleName )
          call allocate_test ( info%beta_group(i)%lbl(2)%molecules, nsons(son)-1, &
            & 'info%beta_group(i)%lbl(2)%molecules', moduleName )
          info%beta_group(i)%molecule = decoration(subtree(1,son)) ! group name
d681 1
a681 1
              info%beta_group(i)%lbl(1)%molecules(j-1) = decoration(gson)
d684 1
a684 1
          info%beta_group(i)%lbl(2)%molecules = info%beta_group(i)%lbl(1)%molecules
d687 7
a693 7
          info%beta_group(i)%molecule = decoration(son)
          call allocate_test ( info%beta_group(i)%lbl(1)%molecules, 1, &
            & 'info%beta_group(i)%lbl(1)%molecules', moduleName )
          call allocate_test ( info%beta_group(i)%lbl(2)%molecules, 1, &
            & 'info%beta_group(i)%lbl(2)%molecules', moduleName )
          info%beta_group(i)%lbl(1)%molecules(1) = info%beta_group(i)%molecule
          info%beta_group(i)%lbl(2)%molecules(1) = info%beta_group(i)%molecule
d698 3
a700 3
            call allocate_test ( info%beta_group(i)%pfa(s)%molecules, &
              & size(info%beta_group(i)%lbl(s)%molecules), 'PFA Molecules', moduleName )
            info%beta_group(i)%pfa(s)%molecules = 0
d702 1
a702 1
            call allocate_test ( info%beta_group(i)%pfa(s)%molecules, 0, &
d706 1
a706 1
      end do ! i = 1, nsons(moleculeTree) - 1
d718 1
a718 1
o:      do j = 2, nsons(PFATrees(s))
d725 4
a728 4
          do i = 1, size(info%beta_group)
            do k = 1, size(info%beta_group(i)%lbl(s)%molecules)
              if ( thisMolecule == info%beta_group(i)%lbl(s)%molecules(k) ) then
                if ( info%beta_group(i)%pfa(s)%molecules(k) /= 0 ) &
d730 2
a731 2
                info%beta_group(i)%pfa(s)%molecules(k) = -1
                cycle o
d733 2
a734 2
            end do ! k
          end do ! i
d736 1
a736 1
        end do o ! j
d738 3
a740 3
        do i = 1, size(info%beta_group)
          tempLBL => info%beta_group(i)%lbl(s)%molecules
          tempPFA => info%beta_group(i)%pfa(s)%molecules
d743 3
a745 3
          nullify ( info%beta_group(i)%lbl(s)%molecules, &
            &       info%beta_group(i)%pfa(s)%molecules )
          call allocate_test ( info%beta_group(i)%lbl(s)%molecules, numLBL, &
d747 1
a747 1
          call allocate_test ( info%beta_group(i)%pfa(s)%molecules, numPFA, &
d749 2
a750 2
          info%beta_group(i)%lbl(s)%molecules = pack(tempLBL,tempPFA == 0)
          info%beta_group(i)%pfa(s)%molecules = pack(tempLBL,tempPFA /= 0)
d755 1
a755 1
        end do ! i
d761 3
a763 3
      do i = 1, size(info%beta_group)
        call allocate_test ( info%beta_group(i)%lbl(s)%cat_index, &
          & size(info%beta_group(i)%lbl(s)%molecules), &
d765 3
a767 3
        info%beta_group(i)%lbl(s)%cat_index = 0 ! in case somebody asks for a dump
        call allocate_test ( info%beta_group(i)%lbl(s)%ratio, &
          &                  size(info%beta_group(i)%lbl(s)%molecules), &
d769 3
a771 3
        info%beta_group(i)%lbl(s)%ratio = 1.0
        call allocate_test ( info%beta_group(i)%pfa(s)%ratio, &
          &                  size(info%beta_group(i)%pfa(s)%molecules), &
d773 2
a774 2
        info%beta_group(i)%pfa(s)%ratio = 1.0
      end do ! i
d778 78
d912 6
a917 3
      if ( any(got( (/f_atmos_der,f_channels,f_do_conv,f_do_baseline,f_do_freq_avg, &
        & f_do_1d, f_incl_cld, f_frequency, f_molecules, f_moleculeDerivatives, &
        & f_signals, f_spect_der, f_temp_der /) )) ) &
d1202 8
d1216 1
a1216 1
      call output ( "I'm not set up to have a nested array in [LU]SBPFAMolecules", advance='yes' )
d1261 1
a1261 1
    & "$Id: ForwardModelSupport.f90,v 2.114 2005/06/14 20:41:55 pwagner Exp $"
d1270 3
@


2.114
log
@Interfaces changed to accept MLSFile_T args
@
text
@d95 1
d101 1
d127 1
a127 1
            & get_field_id(son), filedatabase, &
d136 1
a136 1
            & get_field_id(son), filedatabase, &
d145 1
a145 1
            & get_field_id(son), filedatabase, &
d155 1
a155 1
            & get_field_id(son), filedatabase, &
d162 2
a163 1
            call ReadCompleteHDF5L2PCFile ( fileName )
d174 1
a174 1
            & get_field_id(son), filedatabase, &
d193 1
a193 1
      & fileType, fileDataBase, MSG, pcfEndCode )
d206 1
d210 1
a210 1
      type (MLSFile_T), pointer :: MLSFile
d1150 1
a1150 1
    & "$Id: ForwardModelSupport.f90,v 2.113 2005/06/03 02:07:56 vsnyder Exp $"
d1159 3
@


2.113
log
@New copyright notice, move Id to not_used_here to avoid cascades,
get VGrids from VGridsDatabase instead of an argument, add SignalIndices
component to config.
@
text
@d64 1
a64 1
  subroutine ForwardModelGlobalSetup ( Root, any_errors )
d74 1
d78 1
d93 1
d125 1
d134 1
d143 1
d152 3
a154 2
          call get_file_name ( last_l2pc, 'L2PC File not found in PCF', &
            & mlspcf_l2pc_end )
d171 1
d189 7
a195 2
    subroutine Get_File_Name ( pcfCode, MSG, pcfEndCode )
      use MLSFiles, only: GetPCFromRef, split_path_name
d199 1
d201 2
d205 3
a207 2

      character(len=255) :: PCFFileName, path
d210 6
a215 2

      call get_string ( sub_rosa(subtree(j,son)), fileName, strip=.true. )
d222 1
a222 10
          return
        end if
        PCFFileName = fileName
        call split_path_name ( PCFFileName, path, fileName )
        lun = GetPCFromRef(fileName, pcfCode, &
          & mypcfEndCode, &
          & TOOLKIT, returnStatus, Version, DEBUG, &
          & exactName=PCFFileName)
        if ( returnStatus /= 0 ) then
          call AnnounceError ( 0, son, extraMessage=MSG )
d224 11
a234 1
          fileName = PCFFileName
d237 14
d1146 1
a1146 1
    & "$Id: ForwardModelSupport.f90,v 2.112 2005/05/27 17:56:07 vsnyder Exp $"
d1155 5
@


2.112
log
@Access Source_Ref in the right place
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a23 3
  character (len=*), parameter :: IdParm = &
    & "$Id: ForwardModelSupport.f90,v 2.111 2005/05/26 22:35:48 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
d320 1
a320 1
    & ( name, root, vgrids, global ) result ( info )
d355 1
a355 1
    use VGridsDatabase, only: VGrid_T
a360 1
    type (vGrid_T), dimension(:), pointer :: vGrids ! vGrid database
d523 2
d539 1
d1108 5
d1119 3
@


2.111
log
@Add PFAFiles field to ForwardModelGlobal
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.110 2005/03/28 20:29:09 vsnyder Exp $"
d81 1
a81 1
    use Tree, only: Nsons, Sub_Rosa, Subtree
d999 1
a999 1
    use Tree, only: Decoration, Source_Ref
d1107 3
@


2.110
log
@Better error checking and reporting, some PFA stuff
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.109 2005/02/17 02:34:41 vsnyder Exp $"
d68 1
a68 1
      & F_FILTERSHAPES, F_L2PC, F_POINTINGGRIDS
d76 1
a121 8
      case ( f_filterShapes )
        do j = 2, nsons(son)
          call get_file_name ( mlspcf_filtshps_start, &
            & 'Filter Shapes File not found in PCF' )
          call open_filter_shapes_file ( fileName, lun, fileIndex )
          call read_filter_shapes_file ( lun, fileIndex )
          call close_filter_shapes_file ( lun )
        end do
d130 1
a130 1
      case ( f_pointingGrids )
d132 5
a136 5
          call get_file_name ( mlspcf_ptggrids_start, &
            & 'Pointing Grids File not found in PCF' )
          call open_pointing_grid_file ( fileName, lun )
          call read_pointing_grid_file ( lun )
          call close_pointing_grid_file ( lun )
d151 13
d1107 3
@


2.109
log
@Fix a blunder in PFA setup
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.108 2005/02/16 23:16:24 vsnyder Exp $"
d41 2
a42 1
  integer, parameter :: NoBetaGroup            = Nested + 1
d44 3
a46 3
  integer, parameter :: PFAAndNotPFA           = NoMolecule + 1
  integer, parameter :: PFANotMolecule         = PFAAndNotPFA + 1
  integer, parameter :: PFATwice               = PFANotMolecule + 1
d340 1
a340 1
    use Toggles, only: Gen, Levels, Switches, Toggle
a354 2
    integer :: DumpFwm = -1             ! -1 = not called yet, 0 = no dumps,
                                        ! 1 = dump, 2 = dump and stop
a376 6
    if ( dumpFwm < 0 ) then ! done only once
      dumpFwm = 0
      if ( index(switches,'fwmd') /= 0 )  dumpFwm = 1
      if ( index(switches,'fwmD') /= 0 )  dumpFwm = 2
    end if

d390 1
d422 1
a477 1
        info%anyPFA = .true.
d506 1
a506 1
          call AnnounceError ( WrongUnitsForWindow, root )
d514 2
a515 2
          call get_string ( sub_rosa(subtree(j+1,son)), signalString, &
            & strip=.true.)
d517 1
a517 1
            & tree_index=son, sideband=sideband, channels=channels )
a568 1
        info%anyPFA = .true.
d638 1
a638 1
    ! Now the BPFAMolecules lists
d645 4
d678 2
d681 2
d743 4
d781 1
a781 1
    if ( dumpFwm > 0 .or. error /= 0 ) then
d783 1
a783 1
      if ( dumpFwm > 1 .and. error == 0 ) stop ! error message will stop later
a785 2
    if ( error /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'An error occured' )
d990 1
a990 1
    use Lexer_Core, only: PRINT_SOURCE
d1002 1
a1002 2
    call output ( '***** At ' )
    call print_source ( source_ref ( where ) )
d1051 2
a1058 4
    case ( PFAAndNotPFA )
      call output ( 'Molecule ' )
      call display_string ( lit_indices(decoration(where)) )
      call output ( ' listed for both PFA and non-PFA', advance='yes' )
d1063 3
d1101 3
@


2.108
log
@Revise data structures for split-sideband PFA
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.107 2005/01/27 21:23:13 vsnyder Exp $"
d667 2
a670 2
          tempLBL => info%beta_group(i)%lbl(s)%molecules
          tempPFA => info%beta_group(i)%pfa(s)%molecules
d1098 3
@


2.107
log
@Inching toward separate LSB and USB PFA
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.106 2004/12/28 00:22:34 vsnyder Exp $"
d341 1
a341 1
    use Tree, only: Decoration, Node_ID, Nsons, Sub_Rosa, Subtree
a360 1
    integer :: LsbPFATree               ! Tree index of f_lsbPFAMolecules
d364 2
a374 1
    integer :: UsbPFATree               ! Tree index of f_lsbPFAMolecules
d434 1
d482 1
a482 1
        lsbPFATree = son
d574 1
a574 1
        usbPFATree = son
d600 4
a603 2
          call allocate_test ( info%beta_group(i)%lbl_molecules, nsons(son)-1, &
            & 'info%beta_group(i)%lbl_molecules', moduleName )
d613 1
a613 1
              info%beta_group(i)%lbl_molecules(j-1) = decoration(gson)
d616 1
d620 6
a625 3
          call allocate_test ( info%beta_group(i)%lbl_molecules, 1, &
            & 'info%beta_group(i)%lbl_molecules', moduleName )
          info%beta_group(i)%lbl_molecules(1) = info%beta_group(i)%molecule
d627 12
a638 10
        if ( got(f_lsbPFAMolecules) .or. got(f_usbPFAmolecules) ) then
          ! Allocate PFA_Molecules temporarily for a "this is a PFA molecule" flag
          call allocate_test ( info%beta_group(i)%PFA_Molecules, &
            & size(info%beta_group(i)%lbl_molecules), 'PFA_Molecules', moduleName )
          info%beta_group(i)%PFA_Molecules = 0
        else
          call allocate_test ( info%beta_group(i)%PFA_Molecules, 0, &
            & 'PFA_Molecules', moduleName )
        end if
      end do
d645 21
a665 7
    ! Now the [LU]SBPFAMolecules lists
    if ( got(f_lsbPFAMolecules) .or. got(f_usbPFAMolecules) ) then
      ! Verify that the PFA molecules are all listed molecules.  Mark the
      ! ones that are PFA.
ol:   do j = 2, nsons(lsbPFATree)
        son = subtree( j, lsbPFATree )
        thisMolecule = decoration( son )
d667 14
a680 8
          do k = 1, size(info%beta_group(i)%LBL_Molecules)
            if ( thisMolecule == info%beta_group(i)%LBL_Molecules(k) ) then
              if ( info%beta_group(i)%PFA_Molecules(k) /= 0 ) &
                & call announceError ( PFATwice, son )
              info%beta_group(i)%PFA_Molecules(k) = -1
              cycle ol
            end if
          end do ! k
d682 3
a684 18
        call announceError ( PFANotMolecule, son )
      end do ol ! j
ou:   do j = 2, nsons(usbPFATree)
        son = subtree( j, usbPFATree )
        thisMolecule = decoration( son )
        do i = 1, size(info%beta_group)
          do k = 1, size(info%beta_group(i)%LBL_Molecules)
            if ( thisMolecule == info%beta_group(i)%LBL_Molecules(k) ) then
              if ( info%beta_group(i)%PFA_Molecules(k) /= 0 ) &
                & call announceError ( PFATwice, son )
              info%beta_group(i)%PFA_Molecules(k) = 1
              cycle ou
            end if
          end do ! k
        end do ! i
        call announceError ( PFANotMolecule, son )
      end do ou ! j
      ! Divide the LBL and PFA molecules into separate lists
d686 12
a697 29
        numLBL = 0
        numPFA = 0
        tempLBL => info%beta_group(i)%LBL_Molecules
        tempPFA => info%beta_group(i)%PFA_Molecules
        nullify ( info%beta_group(i)%LBL_Molecules, info%beta_group(i)%PFA_Molecules )
        do k = 1, size(tempLBL)
          if ( tempPFA(k) == 0 ) then
            numLBL = numLBL + 1
          else
            numPFA = numPFA + 1
          end if
        end do ! k
        call allocate_test ( info%beta_group(i)%LBL_Molecules, numLBL, &
          & 'LBL_Molecules', moduleName )
        call allocate_test ( info%beta_group(i)%PFA_Molecules, numPFA, &
          & 'PFA_Molecules', moduleName )
        numLBL = 0
        numPFA = 0
        do k = 1, size(tempLBL)
          if ( tempPFA(k) == 0 ) then
            numLBL = numLBL + 1
            info%beta_group(i)%LBL_Molecules(numLBL) = tempLBL(k)
          else
            numPFA = numPFA + 1
            info%beta_group(i)%PFA_Molecules(numPFA) = tempLBL(k)
          end if
        end do ! k
        call deallocate_test ( tempLBL, 'TempLBL', moduleName )
        call deallocate_test ( tempPFA, 'TempPFA', moduleName )
a698 1
    end if
d700 1
a700 15
    ! Now the cat_index and isotope ratio fields
    do i = 1, size(info%beta_group)
      call allocate_test ( info%beta_group(i)%cat_index, &
        & size(info%beta_group(i)%lbl_molecules), &
        & 'beta_group(b)%Cat_Index', moduleName )
      info%beta_group(i)%cat_index = 0 ! in case somebody asks for a dump
      call allocate_test ( info%beta_group(i)%LBL_Ratio, &
        &                  size(info%beta_group(i)%LBL_Molecules), &
        &                  'LBL_Ratio', moduleName )
      info%beta_group(i)%LBL_Ratio = 1.0
      call allocate_test ( info%beta_group(i)%PFA_Ratio, &
        &                  size(info%beta_group(i)%PFA_Molecules), &
        &                  'PFA_Ratio', moduleName )
      info%beta_group(i)%PFA_Ratio = 1.0
    end do ! i
d1098 3
@


2.106
log
@Remove unused declarations
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.105 2004/12/13 20:15:40 vsnyder Exp $"
d322 7
a328 6
      & F_FORCESIDEBANDFRACTION, F_INTEGRATIONGRID, F_LOCKBINS, F_MODULE, F_MOLECULES, &
      & F_MOLECULEDERIVATIVES, F_NABTERMS, &
      & F_NAZIMUTHANGLES, F_NCLOUDSPECIES, F_NMODELSURFS, F_NSCATTERINGANGLES, &
      & F_NSIZEBINS, F_PFAMOLECULES, F_PHIWINDOW, F_POLARIZED, F_SIGNALS, F_SKIPOVERLAPS, &
      & F_SPECIFICQUANTITIES, F_SPECT_DER, F_SWITCHINGMIRROR, F_TANGENTGRID, F_TEMP_DER, &
      & F_TOLERANCE, F_TYPE, F_LINEARSIDEBAND, F_XSTAR, F_YSTAR
d356 1
d361 1
a364 1
    integer :: PFATree                  ! Tree index of f_PFAMolecules
d374 1
a374 1
    integer :: Expr_Units(2)            ! Units of value returned by EXPR
d480 3
a506 3
      case ( f_pfaMolecules )
        pfaTree = son
        info%anyPFA = .true.
d572 3
d590 1
a590 1
      ! the pfaMolecules tree.
d620 1
a620 1
        if ( got(f_pfaMolecules) ) then
d636 2
a637 2
    ! Now the PFAMolecules list
    if ( got(f_pfaMolecules) ) then
d640 17
a656 2
op:   do j = 2, nsons(pfaTree)
        son = subtree( j, pfaTree )
d664 1
a664 1
              cycle op
d669 1
a669 1
      end do op ! j
d741 1
a741 1
      if ( .not. ( (got(f_molecules) .or. got(f_pfamolecules)) .and. &
d870 1
a870 3
    integer :: i, timingSize

    timingSize = size(FWModelconfig)
d1116 3
@


2.105
log
@Add filter file names to string table
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.104 2004/11/16 02:56:01 vsnyder Exp $"
a358 1
    integer :: MoleculeSign             ! in the info%molecules array.
a360 1
    integer :: NoCat                    ! Number of catalog elements
a790 1
      character(len=127) :: MolName
d1098 3
@


2.104
log
@Dump imputed to wrong requestor
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.103 2004/11/05 19:39:06 vsnyder Exp $"
d86 1
d124 2
a125 2
          call open_filter_shapes_file ( fileName, lun )
          call read_filter_shapes_file ( lun )
d132 2
a133 2
          call open_filter_shapes_file ( fileName, lun )
          call read_DACS_filter_shapes_file ( lun )
d858 4
a861 4
        do i =1, size(FWModelConfig)
           timings(i) = FWModelConfig(i)%sum_DeltaTime
        enddo
    endif
d864 8
a871 8
       	do i =1, size(FWModelConfig)
          if (FWModelConfig(i)%sum_DeltaTime == 0.0 ) then
	    timings(i) = 0.0
          else
       	    timings(i) = FWModelConfig(i)%sum_DeltaTime/FWModelConfig(i)%Ntimes
          endif
        enddo
     endif
d874 17
a890 17
       	do i =1, size(FWModelConfig)
       	    tmp_mean = FWModelConfig(i)%sum_DeltaTime/FWModelConfig(i)%Ntimes
            mean_sqDelta =  FWModelConfig(i)%sum_squareDeltaTime / &
                & FWModelConfig(i)%Ntimes
            if (FWModelConfig(i)%Ntimes <= 1) then
                meanTimes = 1.0
            else
                meanTimes = FWModelConfig(i)%Ntimes / (FWModelConfig(i)%Ntimes - 1)
            end if
            if (FWModelConfig(i)%sum_DeltaTime == 0.0 .AND. &
                  & FWModelConfig(i)%sum_squareDeltaTime == 0.0 ) then
		timings(i) = 0.0
            else
            	timings(i) = sqrt(abs(meanTimes * (mean_sqDelta - (tmp_mean * tmp_mean))))
	    endif
        enddo
     endif
d914 1
a914 1
    enddo
d1101 3
@


2.103
log
@Moved some stuff here from fwdmdl/Get_Species_Data
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.102 2004/11/04 03:42:33 vsnyder Exp $"
d776 1
a776 1
      call dump ( info, 'DeriveFromForwardModelConfig' )
d1100 3
@


2.102
log
@Provide for both LBL_Ratio and PFA_Ratio in beta_group
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.101 2004/11/01 20:27:55 vsnyder Exp $"
d685 1
a685 1
    ! Now the isotope ratio fields
d687 4
d1100 3
@


2.101
log
@Reorganization of representation for molecules and beta groups
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.100 2004/10/13 02:24:56 livesey Exp $"
a596 2
          call allocate_test ( info%beta_group(i)%ratio, nsons(son)-1, &
            & 'info%beta_group(i)%ratio', moduleName )
a597 1
          info%beta_group(i)%ratio = 0.0
a614 3
          call allocate_test ( info%beta_group(i)%ratio, 1, &
            & 'info%beta_group(i)%ratio', moduleName )
          info%beta_group(i)%ratio(1) = 1.0
d685 12
d1096 3
@


2.100
log
@Bug fix, vGrids now pointer in case none defined
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.99 2004/10/06 21:14:37 vsnyder Exp $"
d25 9
a33 5
  integer, parameter :: AllocateError          = 1                    
  integer, parameter :: BadBinSelectors        = AllocateError + 1    
  integer, parameter :: BadHeightUnit          = BadBinSelectors + 1  
  integer, parameter :: BadQuantityType        = BadHeightUnit + 1    
  integer, parameter :: DerivSansMolecules     = BadQuantityType  + 1 
d35 2
a36 2
  integer, parameter :: IncompleteFullFwm      = IncompleteBinSelectors + 1  
  integer, parameter :: IncompleteLinearFwm    = IncompleteFullFwm + 1       
d40 3
a42 1
  integer, parameter :: NoMolecule             = NeedBothXYStar + 1
d44 2
a45 1
  integer, parameter :: PFATwice               = PFAAndNotPFA + 1
a70 2
    use MLSFiles, only: GetPCFromRef, split_path_name
    use MLSL2Options, only: TOOLKIT
a76 3
    use SDPToolkit, only: &
      & Pgs_pc_getReference
    use String_Table, only: Get_String
d169 4
d189 1
a189 1
        endif
d191 1
a191 1
        call split_path_name(PCFFileName, path, fileName)
d276 1
a276 1
          & extraMessage='Cost must not be a range' ) 
d313 1
a313 1
    use ForwardModelConfig, only: ForwardModelConfig_T, NullifyForwardModelConfig
d337 1
a337 1
    use Toggles, only: Gen, Levels, Toggle
d352 2
d356 2
a357 2
    integer :: I                        ! Subscript and loop inductor.
    integer :: J                        ! Subscript and loop inductor.
d361 2
d370 1
d377 5
a381 1
    ! Error message codes
d396 1
d505 1
d532 1
a532 1
          nullify ( info%signals(j)%channels ) 
d582 1
a582 1
    nelts = 0
d584 47
a630 21
      do j = 2, nsons(moleculeTree)
        call countElements ( subtree(j,moleculeTree), nelts )
      end do
    end if
    info%firstPFA = nelts + 1
    if ( got(f_pfaMolecules) ) nelts = nelts + nsons(pfaTree) - 1
    if ( nelts > 0 ) then
      ! Last element of info%molecules is a huge sentinel used in Get_Species_Data,
      ! not a molecule
      call allocate_test ( info%molecules, nelts+1, "info%molecules", &
        & ModuleName )
      info%molecules(nelts+1) = huge(info%molecules(nelts+1))
      call allocate_test ( info%moleculeDerivatives, nelts, &
        & "info%moleculeDerivatives", ModuleName )
      info%moleculeDerivatives = .false.
    end if
    nelts = 0
    if ( got(f_molecules) ) then
      do j = 2, nsons(moleculeTree)
        moleculeSign = +1 ! Indicate "root of a tree of molecules"
        call fillElements ( subtree(j,moleculeTree), nelts, 0, info%molecules )
d632 3
d636 3
d640 49
a688 9
      i = nelts
      do j = 2, nsons(pfaTree)
        i = i + 1
        info%molecules(i) = decoration( subtree( j, pfaTree ) )
        if ( any(abs(info%molecules(:nelts)) == info%molecules(i)) ) &
          & call announceError ( PFAAndNotPFA, subtree(j,pfaTree) )
        if ( any(info%molecules(nelts+1:i-1) == info%molecules(i)) ) &
          & call announceError ( PFATwice, subtree(j,pfaTree) )
      end do
d691 3
a733 1
    case ( l_cloudfull )
d735 5
a739 1
      ! full cloud forward model
d743 1
a743 1
      if ( any(got( (/f_atmos_der,f_channels,f_do_conv,f_do_baseline,f_do_freq_avg,&
d765 5
d776 29
a804 31
    ! ............................................  CountElements  .....
    recursive subroutine CountElements ( root, count )
      integer, intent(in) :: ROOT       ! of a subtree
      integer, intent(inout) :: COUNT   ! Number of array elements
      integer :: I                      ! Subtree index, loop inductor
      if ( node_id(root) == n_array ) then
        do i = 1, nsons(root)
          call countElements ( subtree(i,root), count )
        end do
      else
        count = count + 1
      end if
    end subroutine CountElements

    ! .............................................  FillElements  .....
    recursive subroutine FillElements ( root, count, depth, molecules )
      integer, intent(in) :: ROOT       ! of a subtree
      integer, intent(inout) :: COUNT   ! of array elements processed
      integer, intent(in) :: DEPTH      ! in the array tree
      integer, intent(inout) :: MOLECULES(:)      ! The array to be filled
      integer :: I                      ! Subtree index, loop inductor
      if ( node_id(root) == n_array ) then
        do i = 1, nsons(root)
          call fillElements ( subtree(i,root), count, depth+1, molecules )
        end do
      else
        count = count + 1
        molecules(count) = moleculeSign * decoration(root)
        moleculeSign = -1 ! Indicate "Part of a tree of molecules"
      end if
    end subroutine FillElements
d808 1
a808 1
      use MLSSignals_m, only: Signal_t
a809 3
      type (Signal_T), pointer :: FirstSignal

      firstSignal => info%signals(1)
d813 1
a813 1
      if ( any( info%signals%sideband /= firstSignal%sideband ) ) &
d816 1
a816 1
      if ( .not. all ( EssentiallyEqual ( info%signals%lo, firstSignal%lo ) ) ) &
d821 3
a823 23
      if ( ( firstSignal%sideband == 0 ) .and.&
        &  ( firstSignal%singleSideband == 0 ) ) then
        ! Do a folded measurement
        info%sidebandStart = -1
        info%sidebandStop = 1
      else
        ! It's either a single sideband radiometer, or the user requested a
        ! specific sideband.
        ! Check sanity, if they are both non zero they should be the same.
        if ( ( firstSignal%singleSideband /= 0 ) .and. &
          &  ( firstSignal%sideband /= 0 ) .and. &
          &  ( firstSignal%singleSideband /= &
          &    firstSignal%sideband ) ) call MLSMessage ( &
          &      MLSMSG_Error, ModuleName, &
          &      "User requested a sideband that doesn't exist" )
        ! OK, use whichever one is given
        if ( firstSignal%singleSideband /= 0 ) then
          info%sidebandStart = firstSignal%singleSideband
        else
          info%sidebandStart = firstSignal%sideband
        end if
        info%sidebandStop = info%sidebandStart
      end if
d831 1
a831 1
    
d833 1
a833 1
                                                                                
d838 1
a838 1
    character(len=*), intent(in) :: which    ! 'fwdTiming', 'mean, or 'stdDev' 
d845 1
a845 1
 
d872 2
a873 2
            if (FWModelConfig(i)%sum_DeltaTime == 0.0 .AND. & 
                  & FWModelConfig(i)%sum_squareDeltaTime == 0.0 ) then 
d875 1
a875 1
            else 
d885 3
a887 3
     
  !  Fill and return an array of forward Model Names  
                                                                                
d910 1
a910 1
                                                                                
d914 1
a914 1
                                                                                
d958 1
a958 1
                                                                                
d962 1
a962 1
                                                                                
d964 1
a964 1
                                                                                
d967 1
a967 1
                                                                                
d971 1
a971 1
                                                                                
d976 1
a976 1
  subroutine AnnounceError ( Code, where, extraMessage )
d986 3
a988 1
    character (LEN=*), optional :: extraMessage
d990 1
a990 1
    error = max(error,1)
d1001 4
a1004 1
      call output ( 'Inappropriate units for height in binSelector',&
d1007 1
a1007 1
      call output ( 'Bin Selectors cannot apply to this quantity type',&
d1009 11
d1039 5
d1045 1
a1045 1
      call output ( 'A bin selector of type vmr must have a molecule',&
d1051 4
d1066 1
a1066 1
      call output ( 'tolerance does not have dimensions of temperature/radiance',&
d1069 1
a1069 1
      call output ( 'Bin Selectors can only refer to one height range',&
d1072 1
a1072 1
      call output ( 'Bin Selectors can only have one cost',&
d1090 3
@


2.99
log
@Require Molecules or PFAMolecules
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.98 2004/08/05 21:01:59 vsnyder Exp $"
d341 1
a341 1
    type (vGrid_T), dimension(:), target :: vGrids ! vGrid database
d990 3
@


2.98
log
@Add sentinel at end of %molecules
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.97 2004/08/04 23:19:57 pwagner Exp $"
d620 3
a622 2
      if ( .not. all(got( (/ f_molecules, f_signals, f_integrationGrid, &
        & f_tangentGrid /) )) ) call AnnounceError ( IncompleteFullFwm, root )
d990 3
@


2.97
log
@Much moved from MLSStrings to MLSStringLists
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.96 2004/07/22 20:40:10 cvuu Exp $"
d38 2
a39 1
  integer, parameter :: PolarizedAndAllLines   = PFAAndNotPFA + 1
d574 3
a576 1
      call allocate_test ( info%molecules, nelts, "info%molecules", &
d578 1
d597 2
a755 1
    use Allocate_Deallocate, only: Allocate_Test
d954 4
d989 3
@


2.96
log
@Add 2 subroutines FillFwdModelTimings and ShowFwdModelnames
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.95 2004/07/17 02:27:24 vsnyder Exp $"
d808 1
a808 1
    use MLSStrings, only: catLists
d980 3
@


2.95
log
@Better error message for PFA and non-PFA conflict
@
text
@d13 1
a13 1
    & resetForwardModelTiming
d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.94 2004/07/08 02:35:46 vsnyder Exp $"
d746 80
d980 3
@


2.94
log
@Put all line-by-line molecules before PFA ones
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.93 2004/06/12 00:42:35 vsnyder Exp $"
d592 1
a592 1
          & call announceError ( PFAAndNotPFA, subtree(j+1,pfaTree) )
d817 1
d820 2
a821 1
    use Tree, only: Source_Ref
d866 3
a868 1
      call output ( 'Molecule listed for both PFA and non-PFA', advance='yes' )
d900 3
@


2.93
log
@Make sure PFAMolecules is associated -- at least with zero size
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.92 2004/05/18 01:25:14 vsnyder Exp $"
d25 8
a32 8
  integer, parameter :: AllocateError        = 1
  integer, parameter :: BadBinSelectors      = AllocateError + 1
  integer, parameter :: BadMolecule          = BadBinSelectors + 1
  integer, parameter :: DefineSignalsFirst   = BadMolecule + 1
  integer, parameter :: DefineMoleculesFirst = DefineSignalsFirst + 1
  integer, parameter :: IncompleteBinSelectors    = DefineMoleculesFirst + 1
  integer, parameter :: IncompleteFullFwm    = IncompleteBinSelectors + 1
  integer, parameter :: IncompleteLinearFwm  = IncompleteFullFwm + 1
d35 9
a43 10
  integer, parameter :: TangentNotSubset     = LinearSidebandHasUnits + 1
  integer, parameter :: ToleranceNotK        = TangentNotSubset + 1
  integer, parameter :: TooManyHeights       = ToleranceNotK + 1
  integer, parameter :: TooManyCosts         = TooManyHeights + 1
  integer, parameter :: BadHeightUnit        = TooManyCosts + 1
  integer, parameter :: NoMolecule           = BadHeightUnit + 1
  integer, parameter :: BadQuantityType      = NoMolecule + 1
  integer, parameter :: WrongUnitsForWindow  = BadQuantityType + 1
  integer, parameter :: NeedBothXYStar       = WrongUnitsForWindow + 1
  integer, parameter :: PolarizedAndAllLines = NeedBothXYStar + 1
d257 1
a257 2
        if ( nsons(son) > 2 ) call AnnounceError ( TooManyHeights, son, &
          & f_height )
d259 2
a260 2
        if ( type /= t_numeric_range ) call AnnounceError ( 0, son, f_height, &
          & 'Height range expected' )
d263 1
a263 1
          & call AnnounceError ( BadHeightUnit, son, f_height )
d266 1
a266 2
        if ( nsons(son) > 2 ) call AnnounceError ( TooManyCosts, son, &
          & f_cost )
d269 1
a269 1
          & f_cost, 'Cost must not be a range' ) 
d301 2
a302 2
    ! Process the forwardModel specification to produce ForwardModelConfig to add
    ! to the database
d333 1
a333 1
    use Tree_Types, only: N_Array, N_named
d344 1
a348 1
    integer :: Key                      ! Indexes the spec_args vertex.
d350 1
a350 1
    integer :: Mol                      ! Tree indices of f_molecules, ...Pol
d352 1
a412 3
    ! Make sure PFAMolecules is associated, because its size is used in
    ! a specification expression.
    call allocate_test ( info%PFAMolecules, 0, 'info%PFAMolecules', moduleName )
d464 2
d467 1
a467 28
        mol = son
        nelts = 0
        do j = 2, nsons(son)
          call countElements ( subtree(j,son), nelts )
        end do
        call allocate_test ( info%molecules, nelts, "info%molecules", &
          & ModuleName )
        call allocate_test ( info%moleculeDerivatives, nelts, &
          & "info%moleculeDerivatives", ModuleName )
        info%moleculeDerivatives = .false.
        nelts = 0
        do j = 2, nsons(son)
          moleculeSign = +1 ! Indicate "root of a tree of molecules"
          call fillElements ( subtree(j,son), nelts, 0, info%molecules )
        end do
      case ( f_moleculeDerivatives )
        if ( .not. associated(info%molecules) ) then
          call announceError( DefineMoleculesFirst, root)
        else
          do j = 2, nsons(son)
            thisMolecule = decoration( subtree( j, son ) )
            if ( .not. any(info%molecules == thisMolecule ) ) &
              & call announceError( BadMolecule, root )
            where ( info%molecules == thisMolecule )
              info%moleculeDerivatives = .true.
            end where
          end do                          ! End loop over listed species
        end if
d487 1
a487 5
        call allocate_test ( info%pfaMolecules, nsons(son)-1, "info%pfaMolecules", &
          & moduleName )
        do j = 2, nsons(son)
          info%pfaMolecules(j-1) = decoration( subtree( j, son ) )
        end do
d532 1
a532 1
      case  ( f_specificQuantities )
d563 32
d597 12
d752 1
a752 1
    use String_Table, only: DISPLAY_STRING, GET_STRING
d815 1
a815 1
  subroutine AnnounceError ( Code, where, FieldIndex, extraMessage )
a816 1
    use Intrinsic, only: Lit_Indices
a818 1
    use String_Table, only: Display_String
a822 1
    integer, intent(in), optional :: FieldIndex ! f_...
a831 3
    case ( BadMolecule )
      call output ( 'asked for derivatives for an unlisted molecule.', &
        & advance='yes' )
d835 8
a842 2
    case ( DefineMoleculesFirst )
      call output ( 'molecule must be defined before moleules derivatives.', &
a843 2
    case ( DefineSignalsFirst )
      call output ( 'signals must be defined before channels.',advance='yes')
d857 11
a876 3
    case ( BadHeightUnit )
      call output ( 'Inappropriate units for height in binSelector',&
        & advance='yes' )
a879 6
    case ( BadQuantityType )
      call output ( 'Bin Selectors cannot apply to this quantity type',&
        & advance='yes' )
    case ( NoMolecule )
      call output ( 'A bin selector of type vmr must have a molecule',&
        & advance='yes' )
a882 6
    case ( NeedBothXYStar )
      call output ( 'x/yStar must either be both present or both absent', &
        & advance='yes' )
    case ( PolarizedAndAllLines )
      call output ( 'cannot specify both polarized and allLinesInCatalog', &
        & advance='yes' )
d896 3
@


2.92
log
@Hopefully finish pfaMolecules field support
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.91 2004/05/01 04:05:50 vsnyder Exp $"
d415 3
d892 3
@


2.91
log
@Added pfaMolecules -- but more work needed
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.90 2004/03/22 18:24:40 livesey Exp $"
d486 2
a487 2
          do j = 1, nsons(son)-1
            thisMolecule = decoration( subtree( j+1, son ) )
d516 3
d889 3
@


2.90
log
@Added handling of AllLinesInCatalog flag.
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.89 2004/03/05 18:32:55 livesey Exp $"
d320 1
a320 1
      & F_NSIZEBINS, F_PHIWINDOW, F_POLARIZED, F_SIGNALS, F_SKIPOVERLAPS, &
d513 3
d886 3
@


2.89
log
@Bug fix, but commented out for the moment, as I need to get a test
going.
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.88 2003/10/29 00:44:33 livesey Exp $"
d44 1
d313 2
a314 2
    use Init_Tables_Module, only: F_ALLLINESFORRADIOMETER, F_ATMOS_DER, &
      & F_BINSELECTORS, F_CHANNELS, F_CLOUD_DER, &
d381 1
d425 2
d612 4
d867 3
d883 4
@


2.88
log
@Made sure that default bin selectors also applied to hybrid model.
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.87 2003/10/28 23:44:43 livesey Exp $"
d539 1
a539 1
            & ModuleName )
d872 3
@


2.87
log
@Added initialization of forceFoldedOutput
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.86 2003/10/15 16:59:25 pwagner Exp $"
d624 4
d634 1
a634 2

    end select
d872 3
@


2.86
log
@Should allow null filenames if TOOLKIT
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.85 2003/09/11 23:15:42 livesey Exp $"
d388 1
d869 3
@


2.85
log
@Added handling of xStar / yStar arguments to l2pc models.
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.84 2003/09/03 16:07:52 cvuu Exp $"
d71 2
d88 1
d141 1
d143 1
a143 1
          call get_file_name ( mlspcf_l2pc_start, 'L2PC File not found in PCF', &
d178 5
d868 3
@


2.84
log
@Add all of the printout stuff into routine PrintForwardModelTiming
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.83 2003/08/27 20:31:07 livesey Exp $"
d43 1
d293 1
a293 1
    & ( NAME, ROOT, VGRIDS, GLOBAL ) result ( info )
d312 1
a312 1
      & F_TOLERANCE, F_TYPE, F_LINEARSIDEBAND
d401 2
d564 4
d574 1
d576 3
d843 4
a846 1
   case default
d859 3
@


2.83
log
@Removed the prevention of tolerance>0.0 on polarized runs
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.82 2003/08/21 21:15:18 cvuu Exp $"
d704 2
a705 2
    type(ForwardModelConfig_T), intent(inout) :: FWModelConfig
                                                                                
d709 1
d711 34
a744 20
    mean = FWModelConfig%sum_DeltaTime/FWModelConfig%Ntimes
    mean_sqDelta =  FWModelConfig%sum_squareDeltaTime / FWModelConfig%Ntimes 
    if (FWModelConfig%Ntimes <= 1) then
       meanTimes = 1.0 
    else
       meanTimes = FWModelConfig%Ntimes / (FWModelConfig%Ntimes - 1)
    end if
    std_dev = sqrt(abs(meanTimes * (mean_sqDelta - (mean*mean)))) 
    call get_string ( FWModelConfig%name, thisName )
    call output ( thisName, advance='no')
    call output ( FWModelConfig%Ntimes, format = '(i6)',advance = 'no' )
    call blanks (12, advance = 'no')
    if (FWModelconfig%Ntimes == 0) then
	mean = 0.0
	std_dev = 0.0
    end if
    call output ( mean, format='(f8.2)', advance = 'no' )
    call blanks (10, advance = 'no')
    call output ( std_dev, format='(f8.2)', advance = 'yes' )
                                                                                
d845 3
@


2.82
log
@Change the output format for fullForwardModel Timing
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.81 2003/08/19 05:51:31 livesey Exp $"
d37 1
a37 2
  integer, parameter :: ToleranceNotPolarized  = ToleranceNotK + 1
  integer, parameter :: TooManyHeights       = ToleranceNotPolarized + 1
a584 3
      if ( info%polarized .and. info%tolerance >= 0.0 ) &
        & call AnnounceError ( ToleranceNotPolarized, root )

a798 3
    case ( ToleranceNotPolarized )
      call output ( 'asks for non negative tolerance in the polarized forward model',&
        & advance='yes' )
d830 3
@


2.81
log
@Extra call to CreateDefaultBinSelectors
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.80 2003/08/15 23:58:20 vsnyder Exp $"
d705 1
a705 1
    use String_Table, only: DISPLAY_STRING
d712 1
d722 11
a732 12
    call output ( "======= printForwardModelTiming =========", advance = 'yes')
    call output ( " ", advance = 'yes')
    call output ( "Configuration: " )
    call display_string ( fwModelConfig%name, strip=.true., advance='yes' )
    call output ( "Ntimes = ")
    call output ( FWModelConfig%Ntimes, advance = 'yes' )
    call output ( "mean = ")
    call output ( mean, advance = 'yes' )
    call output ( "standard_deviation = ")
    call output ( std_dev, advance = 'yes' )
    call output ( " ", advance = 'yes')
    call output ( "======= end printForwardModelTiming =====", advance = 'yes')
d837 3
@


2.80
log
@Get PHYQ_... directly from Intrinsic instead of indirectly via Units
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.79 2003/08/15 20:28:44 vsnyder Exp $"
d315 1
a315 1
    use L2PC_m, only: BINSELECTORS, DEFAULTSELECTOR_LATITUDE
d609 1
d837 3
@


2.79
log
@Remove check for and prohibition against polarized VMR derivatives
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.78 2003/08/14 20:25:06 livesey Exp $"
d200 2
a201 1
    use Intrinsic, only: T_NUMERIC_RANGE
a205 2
    use Units, only: PHYQ_TEMPERATURE, PHYQ_PRESSURE, PHYQ_DIMENSIONLESS, &
      & PHYQ_ANGLE, PHYQ_VMR, PHYQ_INVALID
d313 2
a314 1
    use Intrinsic, only: L_NONE, L_CLEAR
a326 1
    use Units, only: PHYQ_TEMPERATURE, PHYQ_PROFILES, PHYQ_ANGLE, PHYQ_DIMENSIONLESS
d836 3
@


2.78
log
@Added the exact bin selector stuff
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.77 2003/08/13 00:49:40 livesey Exp $"
d35 1
a35 2
  integer, parameter :: NoPolarizedAtmosDer  = LinearSidebandHasUnits + 1
  integer, parameter :: TangentNotSubset     = NoPolarizedAtmosDer + 1
a586 4
      ! Make sure that we don't ask for mixing ratio derivatives from the polarized model
      if ( info%polarized .and. info%atmos_der ) &
        & call AnnounceError ( NoPolarizedAtmosDer, root )

a796 3
    case ( NoPolarizedAtmosDer )
      call output ( 'illegally asked for mixing ratio derivatives from the polarized model', &
        & advance='yes' )
d837 3
@


2.77
log
@Added the polarLinear model and now ensures that a default bin selector
is provided to the linear model if the user doesn't supply one.
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.76 2003/08/12 18:16:13 livesey Exp $"
d200 1
a200 1
      & F_NAMEFRAGMENT
d204 1
a204 1
    use MoreTree, only: Get_Field_ID
d233 1
d247 2
d845 4
@


2.76
log
@Forbid non negative tolerance in polarized model.
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.75 2003/08/12 17:12:08 livesey Exp $"
d26 2
a27 1
  integer, parameter :: BadMolecule          = AllocateError + 1
d30 2
a31 1
  integer, parameter :: IncompleteFullFwm    = DefineMoleculesFirst + 1
d202 1
a202 1
    use L2PC_m, only: BINSELECTOR_T
d224 4
d300 2
a301 1
    use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR, L_CLOUDFULL, L_HYBRID
d313 1
d604 2
a605 1
    case ( l_linear )
d610 6
d778 3
d786 2
d842 3
@


2.75
log
@Added check to ensure you don't ask for mixing ratio derivatives from
the polarized model
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.74 2003/08/11 22:35:34 livesey Exp $"
d36 2
a37 1
  integer, parameter :: TooManyHeights       = ToleranceNotK + 1
d581 3
d788 3
d822 4
@


2.74
log
@Now more forgiving of running e.g. R5H and R5V together.
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.73 2003/07/21 18:13:44 pwagner Exp $"
d33 2
a34 1
  integer, parameter :: TangentNotSubset     = LinearSidebandHasUnits + 1
d576 4
d775 3
d815 3
@


2.73
log
@Looks farther than just 1st l2pc file in pcf
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.72 2003/07/18 22:54:35 pwagner Exp $"
d635 1
d645 1
a645 1
      if ( any( info%signals%radiometer /= firstSignal%radiometer ) ) &
d807 3
@


2.72
log
@Ignores path in file names if TOOLKIT
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.71 2003/07/16 21:51:29 pwagner Exp $"
d136 2
a137 1
          call get_file_name ( mlspcf_l2pc_start, 'L2PC File not found in PCF' )
d158 1
a158 1
    subroutine Get_File_Name ( pcfCode, MSG )
d161 1
d165 1
d169 2
d174 1
a174 1
          & pcfCode, &
d806 3
@


2.71
log
@Uses mlspcf_dacsfltsh_start
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.70 2003/07/16 01:27:35 vsnyder Exp $"
d60 1
a60 1
    use MLSFiles, only: GetPCFromRef
d161 1
a161 1
      character(len=255) :: PCFFileName
d166 2
d801 3
@


2.70
log
@Futzing
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.69 2003/07/16 01:06:36 vsnyder Exp $"
d63 2
a64 1
      &          MLSPCF_ptggrids_start, mlspcf_l2pc_start, mlspcf_l2pc_end
d120 1
a120 1
          call get_file_name ( 999999, & !???? Paul -- need a name and number ????
d799 3
@


2.69
log
@Add DACS filter shapes
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.68 2003/07/15 22:10:59 livesey Exp $"
a79 2
    character(len=255) :: PCFFileName
    integer :: returnStatus             ! non-zero means trouble
d135 1
a135 2
          call get_file_name ( mlspcf_l2pc_start, &
            & 'L2PC File not found in PCF' )
d155 1
d160 3
d179 1
a179 1
  ! -------------------------------- CreateBinSelectorFromMLSCFINFO --
d274 1
a274 1
  ! ------------------------------------------  ConstructForwardModelConfig  -----
d592 1
d606 1
d624 1
d668 3
a670 2
  ! ---------------------- print mean, std_dev for timing FullforwardModel ---
  subroutine printForwardModelTiming (FWModelConfig)
d703 1
a703 1
  end subroutine printForwardModelTiming
d705 3
a707 2
  ! ----------------------- reset the values for timing FullforwardModel -----
  subroutine resetForwardModelTiming (FWModelConfig)
d718 1
a718 1
  end subroutine resetForwardModelTiming
d720 1
a720 1
  ! =====     Private Procedures     =====================================
d798 3
@


2.68
log
@Added support for hybrid model
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.67 2003/07/15 18:17:50 livesey Exp $"
d53 4
a56 3
      & READ_FILTER_SHAPES_FILE, CLOSE_FILTER_SHAPES_FILE
    use Init_Tables_Module, only: F_ANTENNAPATTERNS, F_FILTERSHAPES, &
      &  F_L2PC, F_POINTINGGRIDS
d105 2
a106 13
          call get_string ( sub_rosa(subtree(j,son)), fileName, strip=.true. )
          if ( TOOLKIT ) then
            lun = GetPCFromRef(fileName, mlspcf_antpats_start, &
              & mlspcf_antpats_start, &
              & TOOLKIT, returnStatus, Version, DEBUG, &
              & exactName=PCFFileName)
            if ( returnStatus /= 0 .and. TOOLKIT) then
              call AnnounceError(0, son, &
                & extraMessage='Antenna Patterns File not found in PCF')
            else if( returnStatus == 0) then
              fileName = PCFFileName
            endif
          endif
d113 2
a114 13
          call get_string ( sub_rosa(subtree(j,son)), fileName, strip=.true. )
          if ( TOOLKIT ) then
            lun = GetPCFromRef(fileName, mlspcf_filtshps_start, &
              & mlspcf_filtshps_start, &
              & TOOLKIT, returnStatus, Version, DEBUG, &
              & exactName=PCFFileName)
            if ( returnStatus /= 0 .and. TOOLKIT) then
              call AnnounceError(0, son, &
                & extraMessage='Filter Shapes File not found in PCF')
            else if( returnStatus == 0) then
              fileName = PCFFileName
            endif
          endif
d119 8
d129 2
a130 13
          call get_string ( sub_rosa(subtree(j,son)), fileName, strip=.true. )
          if ( TOOLKIT ) then
            lun = GetPCFromRef(fileName, mlspcf_ptggrids_start, &
              & mlspcf_ptggrids_start, &
              & TOOLKIT, returnStatus, Version, DEBUG, &
              & exactName=PCFFileName)
            if ( returnStatus /= 0 .and. TOOLKIT) then
              call AnnounceError(0, son, &
                & extraMessage='Pointing Grids File not found in PCF')
            else if( returnStatus == 0) then
              fileName = PCFFileName
            endif
          endif
d137 2
a138 13
          call get_string ( sub_rosa(subtree(j,son)), fileName, strip=.true. )
          if ( TOOLKIT ) then
            lun = GetPCFromRef(fileName, mlspcf_l2pc_start, &
              & mlspcf_l2pc_end, &
              & TOOLKIT, returnStatus, Version, DEBUG, &
              & exactName=PCFFileName)
            if ( returnStatus /= 0 .and. TOOLKIT) then
              call AnnounceError(0, son, &
                & extraMessage='L2PC File not found in PCF')
            else if( returnStatus == 0) then
              fileName = PCFFileName
            endif
          endif
d155 21
d792 3
@


2.67
log
@Better handling of configuration name
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.66 2003/06/30 22:55:01 cvuu Exp $"
d32 2
a33 1
  integer, parameter :: TangentNotSubset     = IrrelevantFwmParameter + 1
d297 1
a297 1
    use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR, L_CLOUDFULL
d302 1
a302 1
      & F_INTEGRATIONGRID, F_LOCKBINS, F_MODULE, F_MOLECULES, &
d307 1
a307 1
      & F_TOLERANCE, F_TYPE
d320 1
a320 1
    use Units, only: PHYQ_TEMPERATURE, PHYQ_PROFILES, PHYQ_ANGLE
d373 1
d378 1
d427 2
d435 5
d564 1
a564 1
    case ( l_full )
d592 1
a592 1
    case ( l_linear)
d766 3
d806 3
@


2.66
log
@Find mean, std dev timing of fullForwardModel calls
@
text
@d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.65 2003/06/26 23:15:07 vsnyder Exp $"
d288 1
a288 1
    & ( ROOT, VGRIDS, GLOBAL ) result ( info )
d322 1
a336 2
    integer :: Name                     ! sub_rosa of label of specification,
    ! if any, else zero.
a360 7
    if ( node_id(root) == n_named ) then
      name = subtree(1, root)
      key = subtree(2, root)
    else
      name = 0
      key = root
    end if
d376 1
a392 3
    ! "Key" now indexes an n_spec_args vertex.  See "Configuration file
    ! parser users' guide" for pictures of the trees being analyzed.

d395 2
a396 2
    do i = 2, nsons(key)
      son = subtree(i,key)
d452 1
a452 1
          call announceError( DefineMoleculesFirst, key)
d457 1
a457 1
              & call announceError( BadMolecule, key )
d491 1
a491 1
        if ( status /= 0 ) call announceError( AllocateError, key )
d543 1
a543 1
          & call AnnounceError ( toleranceNotK, key )
d550 1
a550 1
    end do ! i = 2, nsons(key)
d673 1
d691 2
d793 3
@


2.65
log
@Reinstate revision 2.63, which inscrutably got lost
@
text
@d12 2
a13 1
    & CreateBinSelectorFromMLSCFInfo
d17 1
a17 1
    & "$Id: ForwardModelSupport.f90,v 2.63 2003/06/18 01:57:12 vsnyder Exp $"
d678 47
d800 3
@


2.64
log
@Quanities now share grids stored separately in databses
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.62 2003/06/09 22:50:13 pwagner Exp $"
d221 2
a222 1
    ! Exeuctable code
d391 2
d579 2
d633 42
d752 8
@


2.63
log
@Move checking that all signals in a config are for the same radiometer,
module and sideband here from FullForwardModel.  Move computation for
SidebandStart and SidebandStop here from FullForwardModel.
@
text
@d222 6
a389 2
    info%sideBandStart = -1
    info%sideBandStop = 1
d565 1
a565 1
      call Hunt ( info%tangentGrid%surfs, info%integrationGrid%surfs(1), &
d571 2
a572 2
        if ( .not. any ( abs( info%tangentGrid%surfs(tangent) - &
          & info%integrationGrid%surfs ) < 1e-4 ) ) &
a575 2
      ! Make sure signal specifications make sense; get sideband Start/Stop
      call validateSignals
a627 42

    subroutine ValidateSignals
      use MLSSignals_m, only: Signal_t
      type (Signal_T), pointer :: FirstSignal

      firstSignal => info%signals(1)

      ! Make sure all the signals we're dealing with are same module,
      ! radiometer and sideband.
      if ( any( info%signals%sideband /= firstSignal%sideband ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        &  "Can't have mixed sidebands in forward model config" )
      if ( any( info%signals%radiometer /= firstSignal%radiometer ) ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        &  "Can't have mixed radiometers in forward model config" )

      ! Think about sidebands
      if ( ( firstSignal%sideband == 0 ) .and.&
        &  ( firstSignal%singleSideband == 0 ) ) then
        ! Do a folded measurement
        info%sidebandStart = -1
        info%sidebandStop = 1
      else
        ! It's either a single sideband radiometer, or the user requested a
        ! specific sideband.
        ! Check sanity, if they are both non zero they should be the same.
        if ( ( firstSignal%singleSideband /= 0 ) .and. &
          &  ( firstSignal%sideband /= 0 ) .and. &
          &  ( firstSignal%singleSideband /= &
          &    firstSignal%sideband ) ) call MLSMessage ( &
          &      MLSMSG_Error, ModuleName, &
          &      "User requested a sideband that doesn't exist" )
        ! OK, use whichever one is given
        if ( firstSignal%singleSideband /= 0 ) then
          info%sidebandStart = firstSignal%singleSideband
        else
          info%sidebandStart = firstSignal%sideband
        end if
        info%sidebandStop = info%sidebandStart
      end if
    end subroutine ValidateSignals

@


2.62
log
@Reduced everything (PCF, PUNISH.., etc.) to TOOLKIT
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.61 2003/05/29 16:42:19 livesey Exp $"
d384 2
d572 2
d626 42
d745 3
@


2.61
log
@New switchingMirror stuff
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.60 2003/05/05 23:00:34 livesey Exp $"
d58 1
a58 1
    use MLSL2Options, only: PCF, PCFL2CFSAMECASE, PUNISH_FOR_INVALID_PCF
d103 1
a103 1
          if ( PCF ) then
d106 1
a106 1
              & PCFL2CFSAMECASE, returnStatus, Version, DEBUG, &
d108 1
a108 1
            if ( returnStatus /= 0 .and. PUNISH_FOR_INVALID_PCF) then
d122 1
a122 1
          if ( PCF ) then
d125 1
a125 1
              & PCFL2CFSAMECASE, returnStatus, Version, DEBUG, &
d127 1
a127 1
            if ( returnStatus /= 0 .and. PUNISH_FOR_INVALID_PCF) then
d141 1
a141 1
          if ( PCF ) then
d144 1
a144 1
              & PCFL2CFSAMECASE, returnStatus, Version, DEBUG, &
d146 1
a146 1
            if ( returnStatus /= 0 .and. PUNISH_FOR_INVALID_PCF) then
d160 1
a160 1
          if ( PCF ) then
d163 1
a163 1
              & PCFL2CFSAMECASE, returnStatus, Version, DEBUG, &
d165 1
a165 1
            if ( returnStatus /= 0 .and. PUNISH_FOR_INVALID_PCF) then
d699 3
@


2.60
log
@Merged in feb03 newfwm branch
@
text
@d16 1
a16 1
    & "$Id$"
d19 1
a19 1
    & "$RCSfile$"
d297 1
a297 1
      & F_SPECIFICQUANTITIES, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, &
d386 1
d533 2
d698 4
a701 1
! $Log$
@


2.59
log
@change default values for i_saturation=l_clear, cloud_der = l_none, no_cloud_species=1
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.58 2003/04/02 21:49:33 jonathan Exp $"
d19 1
a19 1
    & "$RCSfile: ForwardModelSupport.f90,v $"
d31 1
a31 2
  integer, parameter :: Pol_and_not_Pol      = IrrelevantFwmParameter + 1
  integer, parameter :: TangentNotSubset     = Pol_and_not_Pol + 1
d293 2
a294 2
      & F_INTEGRATIONGRID, F_LOCKBINS, F_MODULE, F_MOLECULES, F_MOLECULESPOL, &
      & F_MOLECULEDERIVATIVES, F_MOLECULEDERIVATIVESPOL, F_NABTERMS, &
d296 1
a296 1
      & F_NSIZEBINS, F_PHIWINDOW, F_SIGNALS, F_SKIPOVERLAPS, &
d299 1
a299 1
    use intrinsic, only: l_clear, l_none
d305 1
a305 1
    use Parse_Signal_m, only: EXPAND_SIGNAL_LIST
d320 1
d331 3
a341 1
    logical :: ERRORFLAG                ! Set if problem
d348 1
d364 6
a369 1
    info%globalConfig = global
a370 1
    info%do_baseline = .false.
d372 1
a372 2
    info%do_1d = .false.
    info%DEFAULT_spectroscopy = .false.
d374 1
d376 10
a386 12
    info%atmos_der = .false.
    info%spect_der = .false.
    info%skipOverlaps = .false.
    info%differentialScan = .false.
    info%cloud_der = l_none
    info%no_cloud_species=1
    info%no_model_surfs =640
    info%NUM_SCATTERING_ANGLES=16
    info%NUM_AZIMUTH_ANGLES=8
    info%NUM_AB_TERMS=50
    info%NUM_SIZE_BINS=40
    info%phiwindow = 5
a387 1
    info%i_saturation = l_clear
a398 2
      case ( f_type )
        info%fwmType = decoration(subtree(2,son))
d409 4
d415 2
a418 2
      case ( f_do_baseline )
        info%do_baseline = get_boolean(son)
d423 2
d427 2
a430 9
      case ( f_DEFAULT_spectroscopy )
        info%DEFAULT_spectroscopy = get_boolean(son)
      case ( f_skipOverlaps )
        info%skipOverlaps = get_boolean(son)
      case ( f_tolerance )
        call expr ( subtree(2,son), expr_units, value, type )
        info%tolerance = value(1)
        if ( expr_units(1) /= phyq_temperature ) &
          & call AnnounceError ( toleranceNotK, key )
a448 15
      case ( f_moleculesPol )
        nelts = 0
        do j = 2, nsons(son)
          call countElements ( subtree(j,son), nelts )
        end do
        call allocate_test ( info%moleculesPol, nelts, "info%moleculesPol", &
          & ModuleName )
        call allocate_test ( info%moleculeDerivativesPol, nelts, &
          & "info%moleculeDerivativesPol", ModuleName )
        info%moleculeDerivativesPol = .false.
        nelts = 0
        do j = 2, nsons(son)
          moleculeSign = +1 ! Indicate "root of a tree of molecules"
          call fillElements ( subtree(j,son), nelts, 0, info%moleculesPol )
        end do
d462 4
a465 23
      case ( f_moleculeDerivativesPol )
        if ( .not. associated(info%moleculesPol) ) then
          call announceError( DefineMoleculesFirst, key)
        else
          do j = 1, nsons(son)-1
            thisMolecule = decoration( subtree( j+1, son ) )
            if ( .not. any(info%moleculesPol == thisMolecule ) ) &
              & call announceError( BadMolecule, key )
            where ( info%moleculesPol == thisMolecule )
              info%moleculeDerivativesPol = .true.
            end where
          end do                          ! End loop over listed species
        end if
      case ( f_signals )
        call Expand_Signal_List ( son, info%signals, errorFlag )
        if ( errorFlag ) call announceError ( 0, key )
      case  ( f_specificQuantities )
        call Allocate_test ( info%specificQuantities, nsons(son)-1, &
          & 'info%specificQuantities', ModuleName )
        do j = 1, nsons(son) - 1
          info%specificQuantities(j) = decoration ( decoration ( subtree ( j+1, son ) ) )
        end do
      case ( f_phiWindow )
a466 12
        info%phiWindow = value(1)
        if ( all ( expr_units(1) /= (/ PHYQ_Profiles, PHYQ_Angle /) ) ) &
          call AnnounceError ( WrongUnitsForWindow, root )
        info%windowUnits = expr_units(1)
      case ( f_spect_der )
        info%spect_der = get_boolean(son)
      case ( f_temp_der )
        info%temp_der = get_boolean(son)
      case ( f_integrationGrid )
        info%integrationGrid => vGrids(decoration(decoration(subtree(2,son))))
      case ( f_tangentGrid )
        info%tangentGrid => vGrids(decoration(decoration(subtree(2,son))))
a475 2
      case ( f_nazimuthangles )
        call expr ( subtree(2,son), expr_units, value, type )
a476 3
      case ( f_nabterms )
        call expr ( subtree(2,son), expr_units, value, type )
        info%NUM_AB_TERMS = nint( value(1) )
d480 1
a480 1
      case ( f_cloud_der )
d482 55
a536 2
        info%cloud_der = nint( value(1) )
      case ( f_i_saturation )
d538 5
a542 1
        info%i_saturation = nint( value(1) )
a583 12
    if ( got(f_molecules) .and. got(f_moleculesPol) ) then
      ! Make sure no molecules are both polarized and unpolarized.  The
      ! Derivatives will take care of themselves because f_moleculeDerivatives
      ! have to have values from f_molecules (and similarly for ...Pol).
      do i = 1, size(info%molecules)
        do j = 1, size(info%moleculesPol)
          if ( info%molecules(i) == info%moleculesPol(j) ) &
            & call announceError ( Pol_and_not_Pol, mol, info%moleculesPol(j) )
        end do
      end do
    end if

a658 4
    case ( Pol_and_not_Pol )
      call display_string ( lit_indices(fieldIndex) ) ! Actually a molecule index
      call output ( ' cannot be both polarized and not polarized.', &
        & advance='yes' )
d695 2
a696 2
! $Log: ForwardModelSupport.f90,v $
! Revision 2.58  2003/04/02 21:49:33  jonathan
d699 2
a700 2
! Revision 2.57  2003/03/07 03:16:45  livesey
! Moved some functionality into Expand_Signal_List in parse signals module
@


2.58
log
@remove cloud_fov
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.57 2003/03/07 03:16:45 livesey Exp $"
d300 1
d374 2
a375 2
    info%cloud_der = 0
    info%no_cloud_species=2
d383 1
a383 1
    info%i_saturation = 0
d705 3
@


2.57
log
@Moved some functionality into Expand_Signal_List in parse signals module
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.56 2003/02/08 05:28:47 vsnyder Exp $"
d291 1
a291 1
      & F_BINSELECTORS, F_CHANNELS, F_CLOUD_DER, F_CLOUD_FOV, &
a382 1
    info%cloud_fov = 1
a531 1
!      case ( f_cloud_width )
a533 1
!        info%cloud_width = nint( value(1) )
a534 3
      case ( f_cloud_fov )
        call expr ( subtree(2,son), expr_units, value, type )
        info%cloud_fov = nint( value(1) )
d704 3
@


2.56
log
@Squash a bug (looking at type before evaluating the expression).
Move USE statements from module scope to procedure scope, so as not to
cause TREE_WALKER to be recompiled every time there's a minor change here.
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.55 2003/02/06 22:04:48 vsnyder Exp $"
d305 1
a305 1
    use Parse_Signal_m, only: PARSE_SIGNAL
a319 1
    logical, dimension(:), pointer :: Channels   ! From Parse_Signal
a329 3
    integer :: SIDEBAND                 ! Returned from Parse_Signal
    integer, dimension(:), pointer :: SIGNALINDS ! From Parse_Signal
    character (len=80) :: SIGNALSTRING  ! E.g. R1A....
d338 1
a344 1
    nullify ( channels, signalInds )
d490 2
a491 33
        allocate ( info%signals (nsons(son)-1), stat = status )
        if ( status /= 0 ) call announceError( AllocateError, key )
        do j = 1, nsons(son)-1
          call get_string ( sub_rosa(subtree(j+1,son)), signalString, &
            & strip=.true.)
          call parse_Signal ( signalString, signalInds, &
            & tree_index=son, sideband=sideband, channels=channels )
          if ( .not. associated(signalInds) ) then ! A parse error occurred
            error = max(error,1)
            exit
          end if
          ! Later on choose the `right' one from the match
          ! For the moment choose first !????
          wanted=1
          info%signals(j) = signals(signalInds(wanted))
          info%signals(j)%sideband = sideband
          ! Don't hose channels in database, though shouldn't be an issue
          nullify ( info%signals(j)%channels ) 

          call allocate_Test ( info%signals(j)%channels, &
            & size(info%signals(j)%frequencies), 'info%signals%channels', &
            & ModuleName )
          if ( associated(channels) ) then
            info%signals(j)%channels(1:lbound(channels,1)-1) = .false.
            info%signals(j)%channels(lbound(channels,1):ubound(channels,1)) = &
              channels
            info%signals(j)%channels(ubound(channels,1)+1:) = .false.
          else
            info%signals(j)%channels = .true.
          end if
          call deallocate_test ( channels, 'channels', ModuleName )
          call deallocate_test ( signalInds, 'signalInds', ModuleName )
        end do                          ! End loop over listed signals
d710 5
@


2.56.2.1
log
@Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.56 2003/02/08 05:28:47 vsnyder Exp $"
d31 2
a32 1
  integer, parameter :: TangentNotSubset     = IrrelevantFwmParameter + 1
d294 2
a295 2
      & F_INTEGRATIONGRID, F_LOCKBINS, F_MODULE, F_MOLECULES, &
      & F_MOLECULEDERIVATIVES, F_NABTERMS, &
d297 1
a297 1
      & F_NSIZEBINS, F_PHIWINDOW, F_POLARIZED, F_SIGNALS, F_SKIPOVERLAPS, &
d364 2
a365 6
    info%atmos_der = .false.
    info%cloud_der = 0
    info%cloud_fov = 1
    info%DEFAULT_spectroscopy = .false.
    info%differentialScan = .false.
    info%do_1d = .false.
a366 1
    info%do_conv = .false.
d368 2
a369 1
    info%globalConfig = global
a370 1
    info%i_saturation = 0
d372 6
d380 2
a382 2
    info%NUM_AZIMUTH_ANGLES=8
    info%NUM_SCATTERING_ANGLES=16
a384 4
    info%polarized = .false.
    info%skipOverlaps = .false.
    info%spect_der = .false.
    info%temp_der = .false.
d386 2
d399 2
a410 9
      case ( f_cloud_der )
        call expr ( subtree(2,son), expr_units, value, type )
        info%cloud_der = nint( value(1) )
      case ( f_cloud_fov )
        call expr ( subtree(2,son), expr_units, value, type )
        info%cloud_fov = nint( value(1) )
!      case ( f_cloud_width )
      case ( f_DEFAULT_spectroscopy )
        info%DEFAULT_spectroscopy = get_boolean(son)
d413 2
a416 2
      case ( f_do_conv )
        info%do_conv = get_boolean(son)
a420 4
      case ( f_i_saturation )
        call expr ( subtree(2,son), expr_units, value, type )
!        info%cloud_width = nint( value(1) )
        info%i_saturation = nint( value(1) )
a422 2
      case ( f_integrationGrid )
        info%integrationGrid => vGrids(decoration(decoration(subtree(2,son))))
d425 9
d452 15
d480 13
a492 26
      case ( f_nabterms )
        call expr ( subtree(2,son), expr_units, value, type )
        info%NUM_AB_TERMS = nint( value(1) )
      case ( f_nazimuthangles )
        call expr ( subtree(2,son), expr_units, value, type )
      case ( f_ncloudspecies )
        call expr ( subtree(2,son), expr_units, value, type )
        info%no_cloud_species = nint( value(1) )
      case ( f_nmodelsurfs )
        call expr ( subtree(2,son), expr_units, value, type )
        info%no_model_surfs = nint( value(1) )
      case ( f_nscatteringangles )
        call expr ( subtree(2,son), expr_units, value, type )
        info%NUM_SCATTERING_ANGLES = nint( value(1) )
        info%NUM_AZIMUTH_ANGLES = nint( value(1) )
      case ( f_nsizebins )
        call expr ( subtree(2,son), expr_units, value, type )
        info%NUM_SIZE_BINS = nint( value(1) )
      case ( f_phiWindow )
        call expr ( subtree(2,son), expr_units, value, type )
        info%phiWindow = value(1)
        if ( all ( expr_units(1) /= (/ PHYQ_Profiles, PHYQ_Angle /) ) ) &
          call AnnounceError ( WrongUnitsForWindow, root )
        info%windowUnits = expr_units(1)
      case ( f_polarized )
        info%polarized = get_boolean(son)
a526 2
      case ( f_skipOverlaps )
        info%skipOverlaps = get_boolean(son)
d533 6
d541 4
d547 27
a573 3
      case ( f_temp_der )
        info%temp_der = get_boolean(son)
      case ( f_tolerance )
d575 1
a575 5
        info%tolerance = value(1)
        if ( expr_units(1) /= phyq_temperature ) &
          & call AnnounceError ( toleranceNotK, key )
      case ( f_type )
        info%fwmType = decoration(subtree(2,son))
d617 12
d704 4
a744 5
! Revision 2.56  2003/02/08 05:28:47  vsnyder
! Squash a bug (looking at type before evaluating the expression).
! Move USE statements from module scope to procedure scope, so as not to
! cause TREE_WALKER to be recompiled every time there's a minor change here.
!
@


2.56.2.2
log
@remove cloud_fov
@
text
@d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.56.2.1 2003/02/22 00:47:26 vsnyder Exp $"
d290 1
a290 1
      & F_BINSELECTORS, F_CHANNELS, F_CLOUD_DER, &
d365 1
d412 4
a702 3
! Revision 2.56.2.1  2003/02/22 00:47:26  vsnyder
! Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
!
@


2.55
log
@Add f_moleculesPol, f_moleculeDerivativesPol, delete f_polarized
@
text
@a8 28
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Expr_M, only: EXPR
  use Intrinsic, only: T_NUMERIC_RANGE
  use Init_Tables_Module, only: FIELD_FIRST, FIELD_LAST
  use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR, L_CLOUDFULL, &
    & L_NAMEFRAGMENT, L_VMR, L_TEMPERATURE, L_LATITUDE, L_SZA
  use Init_Tables_Module, only: F_ALLLINESFORRADIOMETER, &
    & F_ANTENNAPATTERNS, F_ATMOS_DER, F_CHANNELS, &
    & F_CLOUD_DER, F_COST, F_DO_BASELINE, F_DO_CONV, F_DO_FREQ_AVG, F_FILTERSHAPES, &
    & F_FREQUENCY, F_HEIGHT, F_DIFFERENTIALSCAN, F_DO_1D, F_INCL_CLD, &
    & F_INTEGRATIONGRID, F_LOCKBINS, F_L2PC, F_MOLECULE, F_MOLECULES, &
    & F_MOLECULESPOL, F_MOLECULEDERIVATIVES, F_MOLECULEDERIVATIVESPOL, &
    & F_PHIWINDOW, F_POINTINGGRIDS, F_SPECT_DER, &
    & F_TANGENTGRID, F_TEMP_DER, F_TYPE, F_MODULE, F_SKIPOVERLAPS, F_TOLERANCE, &
    & F_NABTERMS, F_NAMEFRAGMENT, F_NAZIMUTHANGLES, F_NCLOUDSPECIES, F_NMODELSURFS, &
    & F_NSCATTERINGANGLES, F_NSIZEBINS, F_I_SATURATION, F_CLOUD_FOV, &
    & F_DEFAULT_spectroscopy, F_SPECIFICQUANTITIES, F_SIGNALS, F_BINSELECTORS
  use MLSCommon, only: R8
  use MoreTree, only: Get_Boolean, Get_Field_ID
  use Parse_Signal_m, only: PARSE_SIGNAL
  use String_Table, only: Get_String
  use Toggles, only: Gen, Levels, Toggle
  use Trace_M, only: Trace_begin, Trace_end
  use Tree, only: Decoration, Node_ID, Nsons, Source_Ref, Sub_Rosa, Subtree
  use Units, only: PHYQ_TEMPERATURE, PHYQ_PRESSURE, PHYQ_DIMENSIONLESS, PHYQ_PROFILES, &
    & PHYQ_ANGLE, PHYQ_VMR, PHYQ_INVALID


d16 1
a16 1
    & "$Id: ForwardModelSupport.f90,v 2.54 2003/02/06 00:45:51 livesey Exp $"
d53 2
d62 1
d65 4
d112 1
a112 1
            elseif( returnStatus == 0) then
d131 1
a131 1
            elseif( returnStatus == 0) then
d150 1
a150 1
            elseif( returnStatus == 0) then
d169 1
a169 1
            elseif( returnStatus == 0) then
d195 7
d203 5
d213 1
a213 1
    integer :: I,J                      ! Loop counters
d217 1
a217 1
    integer :: UNITS(2)                 ! Units from expr
a218 5
    character ( len=132 ) :: signalString ! Value of signal
    integer, dimension(:), pointer :: THESESIGNALS => NULL()! From one parseSignal
    integer :: THISSIDEBAND
    integer :: SIGNALCOUNT              ! Number of signals
    integer :: THISSIGNALCOUNT          ! Number of signals for one signal string
d238 1
d241 2
a242 3
        call expr ( gson, units, value, type )
        if ( any ( units /= phyq_pressure .and. units /= phyq_dimensionless ) .or. &
          & all ( units /= phyq_pressure ) ) &
d248 1
a248 1
        call expr ( gson, units, value, type )
d253 1
a253 1
        costUnit = units(1)
d285 2
d288 13
a300 1
    use MLSSignals_M, only: Signals
d303 7
d311 1
a320 1
    integer :: COMMONSIZE               ! Dimension
d327 1
a327 1
    integer :: Mol, MolPol              ! Tree indices of f_molecules, ...Pol
a330 1
    integer :: NoChannelsSpecs          ! Number of channel specs we've had
d339 1
a339 1
    integer :: Units(2)                 ! Units of value returned by EXPR
a388 2
    noChannelsSpecs=0

d430 1
a430 1
        call expr ( subtree(2,son), units, value, type )
d432 1
a432 1
        if ( units(1) /= phyq_temperature ) &
a452 1
        molPol = son
d534 1
a534 1
        call expr ( subtree(2,son), units, value, type )
d536 1
a536 1
        if ( all ( units(1) /= (/ PHYQ_Profiles, PHYQ_Angle /) ) ) &
d538 1
a538 1
        info%windowUnits = units(1)
d548 1
a548 1
        call expr ( subtree(2,son), units, value, type )
d551 1
a551 1
        call expr ( subtree(2,son), units, value, type )
d554 1
a554 1
        call expr ( subtree(2,son), units, value, type )
d557 1
a557 1
        call expr ( subtree(2,son), units, value, type )
d560 1
a560 1
        call expr ( subtree(2,son), units, value, type )
d563 1
a563 1
        call expr ( subtree(2,son), units, value, type )
d566 1
a566 1
        call expr ( subtree(2,son), units, value, type )
d570 1
a570 1
        call expr ( subtree(2,son), units, value, type )
d574 1
a574 1
        call expr ( subtree(2,son), units, value, type )
d674 1
d745 3
@


2.54
log
@Added new binSelector stuff
@
text
@d20 2
a21 2
    & F_MOLECULEDERIVATIVES, &
    & F_PHIWINDOW, F_POINTINGGRIDS, F_POLARIZED, F_SPECT_DER, &
d44 1
a44 1
    & "$Id: ForwardModelSupport.f90,v 2.53 2003/02/06 00:15:01 jonathan Exp $"
d59 2
a60 1
  integer, parameter :: TangentNotSubset     =  IrrelevantFwmParameter + 1
d97 1
a97 1
    integer :: I,J                      ! Loop inductor, subscript
d320 1
a365 1
    info%polarized = .false.
a420 2
      case ( f_polarized )
        info%polarized = get_boolean(son)
d433 1
d448 16
d475 14
a488 1
          end do                          ! End loop over listed signals
d614 12
d667 1
d670 1
d700 4
d741 3
@


2.53
log
@sorry no_cloud_sps=2
@
text
@d11 1
d13 2
a14 1
  use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR, L_CLOUDFULL, L_VMR
d34 1
a34 1
    & PHYQ_ANGLE
d44 1
a44 1
    & "$Id: ForwardModelSupport.f90,v 2.52 2003/02/05 23:27:32 jonathan Exp $"
d232 2
d246 2
d251 2
d262 2
d266 1
d270 10
d284 6
d694 3
@


2.52
log
@change default no_cloud_species=1
@
text
@d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.51 2003/02/05 21:56:39 livesey Exp $"
d344 1
a344 1
    info%no_cloud_species=1
d667 3
@


2.51
log
@New binSelectors stuff
@
text
@d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.50 2003/02/04 22:02:18 jonathan Exp $"
d344 1
a344 1
    info%no_cloud_species=2
d667 3
@


2.50
log
@set i_saturation==0 as default
@
text
@d19 1
a19 1
    & F_PHIWINDOW, F_POINTINGGRIDS, F_POLARIZED, F_SIGNALS, F_SPECT_DER, &
d23 1
a23 1
    & F_DEFAULT_spectroscopy, F_SPECIFICQUANTITIES
d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.49 2003/02/04 19:03:06 livesey Exp $"
d213 1
a213 1
    use L2PC_m, only: BINSELECTOR_T, NullifyBinSelector
a231 1
    call nullifyBinSelector ( binSelector ) ! for Sun's rubbish compiler
a255 29
      case ( f_signals )
        ! First count the signals
        signalCount = 0
        do j = 2, nsons(son)
          gson = subtree ( j, son )
          call Get_string ( sub_rosa(gson), signalString, strip=.true. )
          call Parse_Signal ( signalString, theseSignals, onlyCountEm=thisSignalCount, &
            & tree_index = son )
          signalCount = signalCount + thisSignalCount
        end do
        ! Now setup the result
        call Allocate_test ( binSelector%signals, signalCount, &
          & 'binSelector%signals', ModuleName )
        call Allocate_test ( binSelector%sidebands, signalCount, &
          & 'binSelector%sidebands', ModuleName )
        ! Go through again and fill it up, use signalCount as index
        signalCount = 1
        do j = 2, nsons(son)
          gson = subtree ( j, son )
          call Get_string ( sub_rosa(gson), signalString, strip=.true. )
          call Parse_Signal ( signalString, theseSignals, &
            & sideband=thisSideband, tree_index = son )
          binSelector%signals ( signalCount : signalCount+size(theseSignals)-1 ) = &
            & theseSignals
          binSelector%sidebands ( signalCount : signalCount+size(theseSignals)-1 ) = &
            & thisSideband
          signalCount = signalCount + size(theseSignals)
          call Deallocate_test ( theseSignals, 'theseSignals', ModuleName )
        end do
a343 1
    info%nameFragment = 0
a352 1
!    info%cloud_width = 2
d373 6
a394 2
      case ( f_nameFragment )
        info%nameFragment = sub_rosa ( subtree(2,son) )
d667 3
@


2.49
log
@Default tolerance now -1.0
@
text
@d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.48 2003/01/30 17:28:21 jonathan Exp $"
d383 1
a383 1
    info%i_saturation = 2
d695 3
@


2.48
log
@add logical incl_cld
@
text
@d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.47 2003/01/29 01:48:29 vsnyder Exp $"
d393 1
a393 1
    info%tolerance = 0.2 ! Kelvins, in case the tolerance field is absent
d695 3
@


2.47
log
@Add 'polarized' field to forwardModel
@
text
@d16 1
a16 1
    & F_FREQUENCY, F_HEIGHT, F_DIFFERENTIALSCAN, F_DO_1D, &
d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.46 2003/01/27 16:51:08 livesey Exp $"
d365 1
d415 2
d575 2
a576 2
      if ( any(got( (/f_atmos_der, f_channels, f_do_conv, f_do_baseline, &
        & f_do_freq_avg, f_do_1d, f_frequency, f_molecules, f_moleculeDerivatives, &
d582 1
a582 1
      if ( any(got( (/f_do_conv, f_do_freq_avg, f_do_1d, f_frequency /) )) ) &
d695 3
@


2.46
log
@Added initialisation for windowUnits
@
text
@d19 2
a20 2
    & F_PHIWINDOW, F_POINTINGGRIDS, F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, &
    & F_TEMP_DER, F_TYPE, F_MODULE, F_SKIPOVERLAPS, F_TOLERANCE, &
d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.45 2003/01/26 04:42:55 livesey Exp $"
d366 1
d416 2
d692 3
@


2.45
log
@Added units for phiWindow
@
text
@d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.44 2003/01/16 00:55:41 jonathan Exp $"
d380 1
d689 3
@


2.44
log
@add do_1d
@
text
@d31 2
a32 1
  use Units, only: PHYQ_TEMPERATURE, PHYQ_PRESSURE, PHYQ_DIMENSIONLESS
d42 1
a42 1
    & "$Id: ForwardModelSupport.f90,v 2.43 2003/01/13 17:17:04 jonathan Exp $"
d64 1
d498 3
d672 3
d688 3
@


2.43
log
@ change cloud_width to i_saturation
@
text
@d16 1
a16 1
    & F_FREQUENCY, F_HEIGHT, F_DIFFERENTIALSCAN, &
d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.42 2003/01/03 21:03:02 pwagner Exp $"
d361 1
d408 2
d564 1
a564 1
        & f_do_freq_avg, f_frequency, f_molecules, f_moleculeDerivatives, &
d570 1
a570 1
      if ( any(got( (/f_do_conv, f_do_freq_avg, f_frequency /) )) ) &
d680 3
@


2.42
log
@l2pc filenames now inputtable via PCF
@
text
@d22 1
a22 1
    & F_NSCATTERINGANGLES, F_NSIZEBINS, F_CLOUD_WIDTH, F_CLOUD_FOV, &
d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.41 2002/11/22 12:20:13 mjf Exp $"
d377 2
a378 1
    info%cloud_width = 2
d522 2
a523 1
      case ( f_cloud_width )
d525 2
a526 1
        info%cloud_width = nint( value(1) )
d677 3
@


2.41
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.40 2002/11/15 01:33:24 livesey Exp $"
d82 1
a82 1
      &          MLSPCF_ptggrids_start
d177 12
a188 13
! l2pc files not in PCF (yet)
!           if ( PCF ) then
!             lun = GetPCFromRef(fileName, mlspcf_ptggrids_start, &
!               & mlspcf_ptggrids_start, &
!               & PCFL2CFSAMECASE, returnStatus, Version, DEBUG, &
!               & exactName=PCFFileName)
!             if ( returnStatus /= 0 .and. PUNISH_FOR_INVALID_PCF) then
!               call AnnounceError(0, son, &
!                 & extraMessage='Pointing Grids File not found in PCF')
!             elseif( returnStatus == 0) then
!               fileName = PCFFileName
!             endif
!           endif
d674 4
@


2.40
log
@Added allLinesForRadiometer stuff
@
text
@d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.39 2002/10/18 22:44:11 vsnyder Exp $"
d212 1
a212 1
    use L2PC_m, only: BINSELECTOR_T
d231 1
a231 1
    nullify ( binSelector%signals, binSelector%sidebands ) ! for Sun's rubbish compiler
d300 1
a300 1
    use ForwardModelConfig, only: ForwardModelConfig_T
d343 1
a343 1
    nullify ( info%molecules, info%moleculeDerivatives, info%signals ) ! for Sun's rubbish compiler
d675 3
@


2.39
log
@Remove some unreferenced USE names
@
text
@d13 2
a14 1
  use Init_Tables_Module, only: F_ANTENNAPATTERNS, F_ATMOS_DER, F_CHANNELS, &
d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.38 2002/10/18 18:01:58 livesey Exp $"
d357 1
d395 2
d675 3
@


2.38
log
@Ensure l2pc files etc. read in fwmParallel master mode.
@
text
@d12 1
a12 2
  use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR, L_CLOUDFULL, &
    & L_TEMPERATURE, L_VMR
d19 1
a19 1
    & F_TEMP_DER, F_TYPE, F_MODULE, F_SKIPOVERLAPS, F_TOLERANCE, S_FORWARDMODEL, &
d24 1
a24 1
  use MoreTree, only: Get_Boolean, Get_Field_ID, GET_SPEC_ID
d27 1
a27 1
  use Toggles, only: Gen, Levels, Switches, Toggle
d40 1
a40 1
    & "$Id: ForwardModelSupport.f90,v 2.37 2002/10/08 17:36:20 pwagner Exp $"
a43 1
  private :: not_used_here 
d664 1
a664 1
  logical function not_used_here()
d666 1
a666 1
  end function not_used_here
d671 3
@


2.37
log
@Added idents to survive zealous Lahey optimizer
@
text
@d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.36 2002/09/25 20:08:26 livesey Exp $"
d104 1
a104 1
    if ( parallel%master ) return
d673 3
@


2.36
log
@Added globalConfig and specificQuantities
@
text
@d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.35 2002/08/21 23:31:52 vsnyder Exp $"
d45 1
d666 4
d673 3
@


2.35
log
@Move USE statements from module scope to procedure scope
@
text
@d23 1
a23 1
    & F_DEFAULT_spectroscopy
d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.34 2002/08/04 16:02:23 mjf Exp $"
d106 2
a107 1
    if ( toggle(gen) ) call trace_begin ( 'ForwardModelGlobalSetup', root )
d203 2
a204 1
    if ( toggle(gen) ) call trace_end ( 'ForwardModelGlobalSetup' )
d296 1
a296 1
    & ( ROOT, VGRIDS ) result ( info )
d311 1
d346 2
a347 1
    if ( toggle(gen) ) call trace_begin ( "ConstructForwardModelConfig", root )
d357 1
d481 6
d568 2
a569 1
    if ( toggle(gen) ) call trace_end ( "ConstructForwardModelConfig" )
d668 3
@


2.34
log
@Added some nullify statements for Sun's rubbish compiler.
@
text
@a9 2
  use AntennaPatterns_m, only: OPEN_ANTENNA_PATTERNS_FILE, READ_ANTENNA_PATTERNS_FILE,&
    & CLOSE_ANTENNA_PATTERNS_FILE
a10 4
  use FilterShapes_m, only: OPEN_FILTER_SHAPES_FILE, READ_FILTER_SHAPES_FILE,&
    & CLOSE_FILTER_SHAPES_FILE
  use ForwardModelConfig, only: AddForwardModelConfigToDatabase, Dump, &
    & ForwardModelConfig_T
a23 4
  use L2ParInfo, only: PARALLEL
  use Lexer_Core, only: PRINT_SOURCE
  use L2PC_m, only: OPEN_L2PC_FILE, CLOSE_L2PC_FILE, READ_L2PC_FILE, BINSELECTOR_T, &
    & READCOMPLETEHDF5L2PCFILE
a24 7
  use MLSFiles, only: GetPCFromRef, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF
  use MLSL2Options, only: PCF, PCFL2CFSAMECASE, PUNISH_FOR_INVALID_PCF
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate,&
     & MLSMSG_Error
  use MLSNumerics, only: HUNT
  use MLSPCF2, only: mlspcf_antpats_start, mlspcf_filtshps_start, &
     &          mlspcf_ptggrids_start
a25 1
  use Output_M, only: Output
d27 2
a28 4
  use PointingGrid_m, only: Close_Pointing_Grid_File, &
    & Open_Pointing_Grid_File, Read_Pointing_Grid_File
  use String_Table, only: Display_String, Get_String
  use Toggles, only: Emit, Gen, Levels, Switches, Toggle
d31 1
a31 5
  use Tree, only: Print_Subtree
  use Tree_Types, only: N_Array, N_named
  use Units, only: Deg2Rad, PHYQ_FREQUENCY, PHYQ_TEMPERATURE, &
    & PHYQ_PRESSURE, PHYQ_DIMENSIONLESS
  use VGridsDatabase, only: VGrid_T
d41 1
a41 1
    & "$Id: ForwardModelSupport.f90,v 2.33 2002/07/17 06:02:36 livesey Exp $"
d72 14
d209 3
d297 2
d300 4
d527 2
a528 2
      call Hunt(info%tangentGrid%surfs, info%integrationGrid%surfs(1), &
        &  info%surfaceTangentIndex)
d594 4
d656 3
@


2.33
log
@New HDF5 l2pc stuff
@
text
@d65 1
a65 1
    & "$Id: ForwardModelSupport.f90,v 2.32 2002/06/12 17:01:54 livesey Exp $"
d236 1
d341 1
d653 3
@


2.32
log
@Stuff to support change to real phiWindow from integer
@
text
@d23 2
a24 1
    & F_INTEGRATIONGRID, F_L2PC, F_MOLECULE, F_MOLECULES, F_MOLECULEDERIVATIVES, &
d27 1
a27 1
    & F_NABTERMS, F_NAZIMUTHANGLES, F_NCLOUDSPECIES, F_NMODELSURFS, &
d32 2
a33 1
  use L2PC_m, only: OPEN_L2PC_FILE, CLOSE_L2PC_FILE, READ_L2PC_FILE, BINSELECTOR_T
d65 1
a65 1
    & "$Id: ForwardModelSupport.f90,v 2.31 2002/05/14 22:31:31 livesey Exp $"
d199 7
a205 3
          call open_l2pc_file (fileName, lun)
          call read_l2pc_file ( lun )
          call close_l2pc_file ( lun )
d356 1
d363 1
d398 4
d651 3
@


2.31
log
@Minor bug fix associated with running in parallel mode.
@
text
@d63 1
a63 1
    & "$Id: ForwardModelSupport.f90,v 2.30 2002/03/21 16:42:34 livesey Exp $"
d79 1
a79 2
  integer, parameter :: PhiWindowMustBeOdd   = TangentNotSubset + 1
  integer, parameter :: ToleranceNotK        = PhiWindowMustBeOdd + 1
d465 1
a465 3
        info%phiWindow = nint( value(1) )
        if ( mod(info%phiWindow,2) /= 1 ) &
          & call AnnounceError ( phiWindowMustBeOdd, key )
a611 2
    case ( PhiWindowMustBeOdd )
      call output ( 'phiWindow is not odd', advance='yes' ) 
d639 3
@


2.30
log
@Made it skip reading l2pc files etc for parallel master tasks.
@
text
@d63 1
a63 1
    & "$Id: ForwardModelSupport.f90,v 2.29 2002/03/15 21:22:31 livesey Exp $"
d111 1
d644 3
@


2.29
log
@Dealt with new BinSelector type
@
text
@d29 1
d63 1
a63 1
    & "$Id: ForwardModelSupport.f90,v 2.28 2002/03/14 23:30:21 pwagner Exp $"
d110 3
d643 3
@


2.28
log
@Changed id of who announcesError
@
text
@d62 1
a62 1
    & "$Id: ForwardModelSupport.f90,v 2.27 2002/03/12 23:44:12 vsnyder Exp $"
d233 1
a233 1
        binSelector%quantityType = decoration(gson)
d283 3
a285 10
    select case ( binSelector%quantityType ) 
    case ( l_temperature )
    case ( l_vmr )
      if ( .not. got(f_molecule) ) call AnnounceError ( &
        & NoMolecule, son )
    case default
      call AnnounceError ( BadQuantityType, son, f_type )
    end select
    if ( error /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "An error occured when parsing the BinSelector specification" )
d639 3
@


2.27
log
@Removed private attribute from CVS stuff because private is module's default
@
text
@d62 1
a62 1
    & "$Id: ForwardModelSupport.f90,v 2.26 2002/03/07 17:17:57 livesey Exp $"
d594 1
a594 1
    call output ( ' ForwardModelSetup complained: ' )
d646 3
@


2.26
log
@Removed frqGap
@
text
@d61 4
a64 4
  character (len=*), parameter, private :: IdParm = &
    & "$Id: ForwardModelSupport.f90,v 2.25 2002/02/14 23:02:43 livesey Exp $"
  character (len=len(idParm)) :: Id = IdParm
  character (len=*), parameter, private :: ModuleName= &
d646 3
@


2.25
log
@Added a safety net to guard against deallocating channels in signals
database (shouldn't occur in current version, though may be relevant
later).
@
text
@d22 1
a22 1
    & F_FREQUENCY, F_FRQGAP, F_HEIGHT, F_DIFFERENTIALSCAN, &
d62 1
a62 1
    & "$Id: ForwardModelSupport.f90,v 2.24 2002/02/13 00:08:50 livesey Exp $"
d79 1
a79 2
  integer, parameter :: FrqGapNotFrq         = PhiWindowMustBeOdd + 1
  integer, parameter :: ToleranceNotK        = FrqGapNotFrq + 1
a367 1
    info%frqGap = 0.0                   ! Default to everything
a396 5
      case ( f_frqGap )
        call expr ( subtree(2,son), units, value, type )
        info%frqGap = value(1)
        if ( units(1) /= phyq_frequency ) &
          & call AnnounceError ( frqGapNotFrq, key )
a618 2
    case ( FrqGapNotFrq )
      call output ( 'frqGap does not have dimensions of frequency', advance='yes' )
d646 5
@


2.24
log
@Added differential scan model
@
text
@d62 1
a62 1
    & "$Id: ForwardModelSupport.f90,v 2.23 2002/02/08 22:52:21 livesey Exp $"
d456 3
d655 3
@


2.23
log
@Hooked up bin selectors
@
text
@d22 1
a22 1
    & F_FREQUENCY, F_FRQGAP, F_HEIGHT, &
d62 1
a62 1
    & "$Id: ForwardModelSupport.f90,v 2.22 2002/02/04 23:24:49 livesey Exp $"
d358 1
d387 2
d652 3
@


2.22
log
@Removed dumps
@
text
@d57 2
a58 1
  public :: ConstructForwardModelConfig, ForwardModelGlobalSetup
d62 1
a62 1
    & "$Id: ForwardModelSupport.f90,v 2.21 2002/01/21 21:13:28 livesey Exp $"
d221 1
a221 1
    integer, dimension(:), pointer :: THESESIGNALS ! From one parseSignal
d244 1
d256 1
a256 1
          call Get_string ( decoration(gson), signalString )
d270 1
a270 1
          call Get_string ( decoration(gson), signalString )
d649 3
@


2.21
log
@Added binSelector parsing
@
text
@d61 1
a61 1
    & "$Id: ForwardModelSupport.f90,v 2.20 2001/12/17 18:26:37 vsnyder Exp $"
d524 2
a525 2
        if ( .not. any ( abs(info%tangentGrid%surfs(tangent) - &
          & info%integrationGrid%surfs) < 1e-4) ) &
d647 3
@


2.20
log
@Improve method to put '-' sign on 'part of a tree of molecules'
@
text
@d18 2
a19 1
  use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR, L_CLOUDFULL
d21 5
a25 5
    & F_CLOUD_DER, F_DO_BASELINE, F_DO_CONV, F_DO_FREQ_AVG, F_FILTERSHAPES, &
    & F_FREQUENCY, F_FRQGAP, &
    & F_INTEGRATIONGRID, F_L2PC, F_MOLECULES, F_MOLECULEDERIVATIVES, F_PHIWINDOW, &
    & F_POINTINGGRIDS, F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, F_TYPE, &
    & F_MODULE, F_SKIPOVERLAPS, F_TOLERANCE, S_FORWARDMODEL, &
d30 1
a30 1
  use L2PC_m, only: OPEN_L2PC_FILE, CLOSE_L2PC_FILE, READ_L2PC_FILE
d48 1
a48 1
use Tree, only: Print_Subtree
d50 2
a51 1
  use Units, only: Deg2Rad, PHYQ_FREQUENCY, PHYQ_TEMPERATURE
d61 1
a61 1
    & "$Id: ForwardModelSupport.f90,v 2.19 2001/11/29 00:27:56 vsnyder Exp $"
d80 5
d206 88
d623 15
d647 3
d707 1
@


2.19
log
@Fix blunders in arrays-of-arrays, alphabetize USEs
@
text
@d59 1
a59 1
    & "$Id: ForwardModelSupport.f90,v 2.18 2001/11/28 03:50:07 vsnyder Exp $"
d218 1
d323 1
d474 1
d481 2
a482 3
        molecules(count) = decoration(root)
        if ( count > 1 .and. (depth > 1 .or. depth > 0 .and. i > 1 ) ) &
          & molecules(count) = -molecules(count)
d537 3
@


2.18
log
@Allow array of arrays for 'molecules' field
@
text
@d10 5
d28 3
a31 1
  use MLSCommon, only: R8
d35 1
d41 2
d47 1
a50 10
  use L2PC_m, only: OPEN_L2PC_FILE, CLOSE_L2PC_FILE, READ_L2PC_FILE
  use AntennaPatterns_m, only: OPEN_ANTENNA_PATTERNS_FILE, READ_ANTENNA_PATTERNS_FILE,&
    & CLOSE_ANTENNA_PATTERNS_FILE
  use FilterShapes_m, only: OPEN_FILTER_SHAPES_FILE, READ_FILTER_SHAPES_FILE,&
    & CLOSE_FILTER_SHAPES_FILE
  use Expr_M, only: EXPR
  use Lexer_Core, only: PRINT_SOURCE
  use MLSNumerics, only: HUNT
  use PointingGrid_m, only: Close_Pointing_Grid_File, &
    & Open_Pointing_Grid_File, Read_Pointing_Grid_File
d59 1
a59 1
    & "$Id: ForwardModelSupport.f90,v 2.17 2001/11/15 23:49:40 jonathan Exp $"
a212 1
    integer :: Depth                    ! in an array tree
a319 1
        depth = 0
d322 1
a322 1
          call fillElements ( subtree(j,son), nelts, depth, info%molecules )
a457 1
      integer :: SON                    ! of ROOT
d460 1
a460 2
          son = subtree(i,root)
          call countElements ( son, count )
d470 1
a470 1
      integer, intent(inout) :: DEPTH   ! in the array tree
a472 1
        depth = depth + 1
d474 1
a474 2
          son = subtree(i,root)
          call fillElements ( son, count, depth, molecules )
a475 1
        depth = depth - 1
d479 2
a480 1
        if ( depth > 0 ) molecules(count) = -molecules(count)
d535 3
@


2.17
log
@rename DF_spectroscopy to default_spectroscopy
@
text
@d37 1
a37 1
  use Tree_Types, only: N_named
d58 1
a58 1
    & "$Id: ForwardModelSupport.f90,v 2.16 2001/11/15 20:55:55 jonathan Exp $"
d212 1
d220 1
d311 5
a315 1
        call allocate_test ( info%molecules, nsons(son)-1, "info%molecules", &
d317 1
a317 1
        call allocate_test ( info%moleculeDerivatives, nsons(son)-1, &
d320 5
a324 3
        do j = 1, nsons(son)-1
          info%molecules(j) = decoration( subtree( j+1, son ) )
        end do                          ! End loop over listed signals
d454 34
d540 3
@


2.16
log
@add df_spectroscopy
@
text
@d13 1
a13 1
  use Init_Tables_Module, only: L_FULL, L_SCAN, L_LINEAR
d21 2
a22 1
    & F_NSCATTERINGANGLES, F_NSIZEBINS, F_CLOUD_WIDTH, F_CLOUD_FOV, F_DF_spectroscopy
d58 1
a58 1
    & "$Id: ForwardModelSupport.f90,v 2.15 2001/11/08 00:12:52 livesey Exp $"
d253 1
a253 1
    info%DF_spectroscopy = .false.
a285 4
      case ( f_cloud_der )
!        info%cloud_der = get_boolean(son)
      call expr ( subtree(2,son), units, value, type )
        info%cloud_der = nint( value(1) )
d292 2
a293 2
      case ( f_DF_spectroscopy )
        info%DF_spectroscopy = get_boolean(son)
d392 3
d425 4
a428 2
      ! Check parameters needed only for linear/scan are not included
      !????
d498 3
@


2.15
log
@Removed an obsolete variable
@
text
@d19 1
a19 2
    & F_MODULE, F_SKIPOVERLAPS, F_TOLERANCE, &
    & S_FORWARDMODEL, &
d21 1
a21 1
    & F_NSCATTERINGANGLES, F_NSIZEBINS, F_CLOUD_WIDTH, F_CLOUD_FOV
d57 1
a57 1
    & "$Id: ForwardModelSupport.f90,v 2.14 2001/10/31 15:26:59 livesey Exp $"
d252 1
d295 2
d496 3
@


2.14
log
@Allowed filename arguments to forward model global stuff to be arrays
@
text
@d58 1
a58 1
    & "$Id: ForwardModelSupport.f90,v 2.13 2001/10/02 20:34:50 livesey Exp $"
a212 1
    integer :: fwdmdlFlvr               ! Which flavor of forward model are we
a239 1
    fwdmdlFlvr = get_spec_id(ROOT)
d494 3
@


2.13
log
@Added do_baseline stuff
@
text
@d58 1
a58 1
    & "$Id: ForwardModelSupport.f90,v 2.12 2001/09/04 15:58:02 jonathan Exp $"
d92 1
a92 1
    integer :: I                        ! Loop inductor, subscript
d113 3
a115 2
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        if ( PCF ) then
d117 3
a119 3
            & mlspcf_antpats_start, &
            & PCFL2CFSAMECASE, returnStatus, Version, DEBUG, &
            & exactName=PCFFileName)
d121 2
a122 2
               call AnnounceError(0, son, &
               & extraMessage='Antenna Patterns File not found in PCF')
d124 1
a124 1
               fileName = PCFFileName
d126 5
a130 4
        endif
        call open_antenna_patterns_file ( fileName, lun )
        call read_antenna_patterns_file ( lun )
        call close_antenna_patterns_file ( lun )
d132 3
a134 2
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        if ( PCF ) then
d136 3
a138 3
            & mlspcf_filtshps_start, &
            & PCFL2CFSAMECASE, returnStatus, Version, DEBUG, &
            & exactName=PCFFileName)
d140 2
a141 2
               call AnnounceError(0, son, &
               & extraMessage='Filter Shapes File not found in PCF')
d143 1
a143 1
               fileName = PCFFileName
d145 5
a149 4
        endif
        call open_filter_shapes_file ( fileName, lun )
        call read_filter_shapes_file ( lun )
        call close_filter_shapes_file ( lun )
d151 3
a153 2
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        if ( PCF ) then
d155 3
a157 3
            & mlspcf_ptggrids_start, &
            & PCFL2CFSAMECASE, returnStatus, Version, DEBUG, &
            & exactName=PCFFileName)
d159 2
a160 2
               call AnnounceError(0, son, &
               & extraMessage='Pointing Grids File not found in PCF')
d162 1
a162 1
               fileName = PCFFileName
d164 5
a168 4
        endif
        call open_pointing_grid_file ( fileName, lun )
        call read_pointing_grid_file ( lun )
        call close_pointing_grid_file ( lun )
d170 19
a188 5
        call get_string ( sub_rosa(subtree(2,son)), fileName, strip=.true. )
        ! l2pc files not in PCF (yet)
        call open_l2pc_file (fileName, lun)
        call read_l2pc_file ( lun )
        call close_l2pc_file ( lun )
d496 3
@


2.12
log
@add cloud_fov, jonathan
@
text
@d15 2
a16 1
    & F_CLOUD_DER, F_DO_CONV, F_DO_FREQ_AVG, F_FILTERSHAPES, F_FREQUENCY, F_FRQGAP, &
d58 1
a58 1
    & "$Id: ForwardModelSupport.f90,v 2.11 2001/07/17 22:36:19 jonathan Exp $"
d233 1
d273 2
d409 1
a409 1
      if ( any(got( (/f_atmos_der, f_channels, f_do_conv, &
d476 3
@


2.11
log
@add cloud_width, jonathan/paul
@
text
@d15 1
a15 1
    & F_CLOUD_DER, F_DO_CONV, F_DO_FREQ_AVG, F_FILTERSHAPES, F_FREQUENCY, F_FRQGAP,&
d17 1
a17 1
    & F_POINTINGGRIDS, F_SIGNALS, F_SPECT_DER, F_TANGENTGRID, F_TEMP_DER, F_TYPE,&
d20 2
a21 2
    & F_NABTERMS, F_NAZIMUTHANGLES, F_NCLOUDSPECIES, F_NMODELSURFS,&
    & F_NSCATTERINGANGLES, F_NSIZEBINS, F_CLOUD_WIDTH
d57 1
a57 1
    & "$Id: ForwardModelSupport.f90,v 2.10 2001/07/16 22:07:21 jonathan Exp $"
d246 1
d374 3
d472 3
@


2.10
log
@change cloud_der to integer-type, jonathan
@
text
@d21 1
a21 1
    & F_NSCATTERINGANGLES, F_NSIZEBINS
d57 1
a57 1
    & "$Id: ForwardModelSupport.f90,v 2.9 2001/07/12 23:27:48 livesey Exp $"
d245 1
d370 3
d468 3
@


2.9
log
@Got rid of the s_cloudForwardModel stuff
@
text
@d57 1
a57 1
    & "$Id: ForwardModelSupport.f90,v 2.8 2001/07/09 22:51:37 pwagner Exp $"
d237 7
a243 1
    info%cloud_der = .false.
d264 3
a266 1
        info%cloud_der = get_boolean(son)
d464 3
@


2.8
log
@Picks up cloud-related config components
@
text
@d19 1
a19 1
    & S_CLOUDFORWARDMODEL, S_FORWARDMODEL, &
d57 1
a57 1
    & "$Id: ForwardModelSupport.f90,v 2.7 2001/06/21 20:06:42 vsnyder Exp $"
a189 1
    logical :: Cloudy                   ! If flavor is CloudForwardModel
a220 1
    Cloudy = (fwdmdlFlvr == s_cloudforwardModel)
d456 3
@


2.7
log
@Make the tolerance field of the ForwardModel spec optional
@
text
@d18 4
a21 1
    & F_MODULE, F_SKIPOVERLAPS, F_TOLERANCE
d29 1
a29 1
  use MoreTree, only: Get_Boolean, Get_Field_ID
d57 1
a57 1
    & "$Id: ForwardModelSupport.f90,v 2.6 2001/06/21 15:05:20 livesey Exp $"
d190 1
d193 1
d221 2
d345 18
d458 3
@


2.6
log
@Added tolerance field to config
@
text
@d54 1
a54 1
    & "$Id: ForwardModelSupport.f90,v 2.5 2001/06/19 22:48:42 pwagner Exp $"
d242 1
d433 3
@


2.5
log
@Eliminated duplicate declaration of PointingGrid_m
@
text
@d18 1
a18 1
    & F_MODULE, F_SKIPOVERLAPS
d34 1
a34 1
  use Units, only: Deg2Rad, PHYQ_FREQUENCY
d54 1
a54 1
    & "$Id: ForwardModelSupport.f90,v 2.4 2001/06/04 22:42:24 livesey Exp $"
d72 1
d264 5
d417 1
a417 1
      call output ( 'phiWindow is not odd', advance='yes' )
d420 4
a423 1
    case default
d432 3
@


2.4
log
@Added belowRef to forwardModelIntermediate_T
@
text
@a35 1
  use PointingGrid_m, only: READ_POINTING_GRID_FILE, CLOSE_POINTING_GRID_FILE
d54 1
a54 1
    & "$Id: ForwardModelSupport.f90,v 2.3 2001/05/31 22:08:06 livesey Exp $"
d423 3
@


2.3
log
@Added cloud_der flag
@
text
@d55 1
a55 1
    & "$Id: ForwardModelSupport.f90,v 2.2 2001/05/30 23:05:39 pwagner Exp $"
d365 1
a365 1
      if ( .not. all(got( (/f_molecules, f_signals/) )) ) & ! Maybe others later
d424 3
@


2.2
log
@Uses PCF for 3 fwdmdl files
@
text
@d15 1
a15 1
    & F_DO_CONV, F_DO_FREQ_AVG, F_FILTERSHAPES, F_FREQUENCY, F_FRQGAP,&
d55 1
a55 1
    & "$Id: ForwardModelSupport.f90,v 2.1 2001/05/29 23:18:18 livesey Exp $"
d232 1
d251 2
d424 3
@


2.1
log
@First version, was ForwardModelInterface
@
text
@d19 1
d21 1
d24 2
d55 1
a55 1
    & "$Id: ForwardModelInterface.f90,v 2.137 2001/05/29 23:09:59 livesey Exp $"
d58 1
a58 1
    & "$RCSfile: ForwardModelInterface.f90,v $"
d79 1
a79 1
  subroutine ForwardModelGlobalSetup ( Root )
d84 1
d86 2
d90 2
a91 1
    character(len=255) :: FileName      ! Duh
d93 1
d105 1
d110 12
d127 12
d144 12
d161 1
d171 1
d376 1
a376 1
  subroutine AnnounceError ( Code, where, FieldIndex )
d380 1
d412 2
d415 1
d420 4
a423 1
! $Log$
@

