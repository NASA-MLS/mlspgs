head	2.209;
access;
symbols
	v5-02-NRT-19:2.209
	v6-00:2.209
	v5-02-NRT-18:2.208
	v5-02:2.207
	v5-01-NRT-17:2.208
	v5-01-NRT-16:2.208
	v5-01-NRT-15:2.208
	v5-01-NRT-14:2.208
	neuralnetworks-1-0:2.208.0.4
	cfm-single-freq-0-1:2.208.0.2
	v5-01:2.207
	v5-00:2.207
	v4-23-TA133:2.207.0.4
	mus-emls-1-70:2.207.0.2
	rel-1-0-englocks-work:2.206.0.2
	VUMLS1-00:2.202
	VPL1-00:2.198
	V4-22-NRT-08:2.189
	VAM1-00:2.186
	V4-21:2.177.0.2
	V4-13:2.177
	V4-12:2.176
	V4-11:2.176
	V4-10:2.176
	V3-43:2.154
	M4-00:2.167
	V3-41:2.154
	V3-40-PlusGM57:2.154.0.2
	V2-24-NRT-04:2.139
	V3-33:2.162
	V2-24:2.139
	V3-31:2.162
	V3-30-NRT-05:2.162
	cfm-01-00:2.162
	V3-30:2.154
	V3-20:2.154
	V3-10:2.149
	V2-23-NRT-02:2.139
	V2-23:2.139
	V2-22-NRT-01:2.139
	V2-22:2.139
	V2-21:2.136
	V2-20:2.136
	V2-11:2.132
	V2-10:2.132
	V2-00:2.131
	V1-51:2.118
	V1-50:2.118
	V1-45:2.114
	V1-44:2.114
	V1-43:2.109
	V1-32:2.105
	V1-31:2.105
	V1-30:2.105
	V1-13:2.88
	V1-12:2.88
	V1-11:2.88
	V1-10:2.86
	merged-HEAD:2.87.2.1
	newfwm-feb03:2.87.0.2
	V1-04:2.62
	V1-03:2.62
	V1-02:2.62
	JointForwardModel:2.67.0.2
	V1-00:2.61
	newfwm-sep01:2.51.0.2
	V0-7:2.51
	V0-5-Level2:2.30
	V0-5-SIPS:2.19;
locks; strict;
comment	@# @;


2.209
date	2024.02.02.21.31.45;	author pwagner;	state Exp;
branches;
next	2.208;

2.208
date	2020.01.27.18.02.46;	author pwagner;	state Exp;
branches;
next	2.207;

2.207
date	2018.04.11.17.47.05;	author pwagner;	state Exp;
branches;
next	2.206;

2.206
date	2018.02.23.22.04.45;	author mmadatya;	state Exp;
branches;
next	2.205;

2.205
date	2017.12.15.18.43.56;	author mmadatya;	state Exp;
branches;
next	2.204;

2.204
date	2017.10.27.01.29.46;	author vsnyder;	state Exp;
branches;
next	2.203;

2.203
date	2017.06.01.22.49.15;	author vsnyder;	state Exp;
branches;
next	2.202;

2.202
date	2016.11.04.23.05.48;	author pwagner;	state Exp;
branches;
next	2.201;

2.201
date	2016.10.20.23.13.39;	author pwagner;	state Exp;
branches;
next	2.200;

2.200
date	2016.10.14.00.05.46;	author pwagner;	state Exp;
branches;
next	2.199;

2.199
date	2016.09.21.00.41.32;	author pwagner;	state Exp;
branches;
next	2.198;

2.198
date	2016.08.12.00.33.05;	author pwagner;	state Exp;
branches;
next	2.197;

2.197
date	2016.08.09.21.51.57;	author pwagner;	state Exp;
branches;
next	2.196;

2.196
date	2016.07.28.19.56.00;	author pwagner;	state Exp;
branches;
next	2.195;

2.195
date	2016.07.28.00.42.46;	author vsnyder;	state Exp;
branches;
next	2.194;

2.194
date	2016.07.27.23.03.44;	author pwagner;	state Exp;
branches;
next	2.193;

2.193
date	2016.07.25.23.41.53;	author pwagner;	state Exp;
branches;
next	2.192;

2.192
date	2016.07.21.20.28.54;	author pwagner;	state Exp;
branches;
next	2.191;

2.191
date	2016.05.27.20.59.04;	author vsnyder;	state Exp;
branches;
next	2.190;

2.190
date	2016.05.27.01.24.07;	author vsnyder;	state Exp;
branches;
next	2.189;

2.189
date	2016.05.24.01.26.01;	author vsnyder;	state Exp;
branches;
next	2.188;

2.188
date	2016.05.18.01.37.30;	author vsnyder;	state Exp;
branches;
next	2.187;

2.187
date	2016.05.04.18.31.39;	author pwagner;	state Exp;
branches;
next	2.186;

2.186
date	2015.09.25.02.16.20;	author vsnyder;	state Exp;
branches;
next	2.185;

2.185
date	2015.09.22.01.57.57;	author vsnyder;	state Exp;
branches;
next	2.184;

2.184
date	2015.09.17.23.21.08;	author pwagner;	state Exp;
branches;
next	2.183;

2.183
date	2015.07.29.00.29.54;	author vsnyder;	state Exp;
branches;
next	2.182;

2.182
date	2015.07.27.22.28.06;	author vsnyder;	state Exp;
branches;
next	2.181;

2.181
date	2015.06.04.03.14.14;	author vsnyder;	state Exp;
branches;
next	2.180;

2.180
date	2015.06.03.00.01.51;	author vsnyder;	state Exp;
branches;
next	2.179;

2.179
date	2015.05.28.18.25.16;	author vsnyder;	state Exp;
branches;
next	2.178;

2.178
date	2015.03.28.02.29.39;	author vsnyder;	state Exp;
branches;
next	2.177;

2.177
date	2014.09.05.00.39.49;	author vsnyder;	state Exp;
branches;
next	2.176;

2.176
date	2014.04.24.23.58.21;	author pwagner;	state Exp;
branches;
next	2.175;

2.175
date	2014.04.07.18.01.12;	author pwagner;	state Exp;
branches;
next	2.174;

2.174
date	2013.09.24.23.47.22;	author vsnyder;	state Exp;
branches;
next	2.173;

2.173
date	2013.08.17.00.23.35;	author pwagner;	state Exp;
branches;
next	2.172;

2.172
date	2013.07.25.00.23.00;	author vsnyder;	state Exp;
branches;
next	2.171;

2.171
date	2013.07.19.01.21.49;	author vsnyder;	state Exp;
branches;
next	2.170;

2.170
date	2013.07.18.01.12.11;	author vsnyder;	state Exp;
branches;
next	2.169;

2.169
date	2013.05.31.00.42.35;	author vsnyder;	state Exp;
branches;
next	2.168;

2.168
date	2013.05.21.23.52.47;	author vsnyder;	state Exp;
branches;
next	2.167;

2.167
date	2013.02.21.21.37.10;	author pwagner;	state Exp;
branches;
next	2.166;

2.166
date	2012.01.05.01.20.47;	author pwagner;	state Exp;
branches;
next	2.165;

2.165
date	2011.12.21.01.40.57;	author vsnyder;	state Exp;
branches;
next	2.164;

2.164
date	2011.08.20.00.49.05;	author vsnyder;	state Exp;
branches;
next	2.163;

2.163
date	2011.05.09.18.05.32;	author pwagner;	state Exp;
branches;
next	2.162;

2.162
date	2010.04.05.17.40.55;	author honghanh;	state Exp;
branches;
next	2.161;

2.161
date	2010.04.05.17.32.04;	author honghanh;	state Exp;
branches;
next	2.160;

2.160
date	2010.03.31.19.59.55;	author honghanh;	state Exp;
branches;
next	2.159;

2.159
date	2010.03.24.17.35.13;	author honghanh;	state Exp;
branches;
next	2.158;

2.158
date	2010.03.09.22.44.08;	author honghanh;	state Exp;
branches;
next	2.157;

2.157
date	2010.03.09.22.40.50;	author honghanh;	state Exp;
branches;
next	2.156;

2.156
date	2010.03.05.20.17.51;	author honghanh;	state Exp;
branches;
next	2.155;

2.155
date	2010.03.02.01.09.20;	author pwagner;	state Exp;
branches;
next	2.154;

2.154
date	2010.02.04.23.12.44;	author vsnyder;	state Exp;
branches;
next	2.153;

2.153
date	2010.01.23.01.02.37;	author vsnyder;	state Exp;
branches;
next	2.152;

2.152
date	2009.09.25.02.40.28;	author vsnyder;	state Exp;
branches;
next	2.151;

2.151
date	2009.09.22.17.02.31;	author pwagner;	state Exp;
branches;
next	2.150;

2.150
date	2009.09.19.00.33.44;	author vsnyder;	state Exp;
branches;
next	2.149;

2.149
date	2009.06.23.18.46.18;	author pwagner;	state Exp;
branches;
next	2.148;

2.148
date	2009.03.14.02.44.46;	author honghanh;	state Exp;
branches;
next	2.147;

2.147
date	2008.10.03.16.39.42;	author livesey;	state Exp;
branches;
next	2.146;

2.146
date	2008.09.30.22.34.19;	author vsnyder;	state Exp;
branches;
next	2.145;

2.145
date	2008.08.22.01.04.18;	author vsnyder;	state Exp;
branches;
next	2.144;

2.144
date	2008.06.06.01.58.31;	author vsnyder;	state Exp;
branches;
next	2.143;

2.143
date	2008.06.05.20.00.45;	author vsnyder;	state Exp;
branches;
next	2.142;

2.142
date	2008.06.05.02.14.29;	author vsnyder;	state Exp;
branches;
next	2.141;

2.141
date	2008.05.28.21.03.58;	author pwagner;	state Exp;
branches;
next	2.140;

2.140
date	2008.04.26.00.39.46;	author livesey;	state Exp;
branches;
next	2.139;

2.139
date	2007.03.08.01.33.33;	author pwagner;	state Exp;
branches;
next	2.138;

2.138
date	2007.01.24.02.17.29;	author vsnyder;	state Exp;
branches;
next	2.137;

2.137
date	2007.01.11.20.44.27;	author vsnyder;	state Exp;
branches;
next	2.136;

2.136
date	2006.10.02.23.05.31;	author pwagner;	state Exp;
branches;
next	2.135;

2.135
date	2006.08.11.20.36.24;	author vsnyder;	state Exp;
branches;
next	2.134;

2.134
date	2006.08.04.20.52.20;	author pwagner;	state Exp;
branches;
next	2.133;

2.133
date	2006.08.03.01.57.42;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2006.07.20.23.39.53;	author vsnyder;	state Exp;
branches;
next	2.131;

2.131
date	2006.06.01.03.06.46;	author vsnyder;	state Exp;
branches;
next	2.130;

2.130
date	2006.04.11.23.32.08;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2006.03.04.00.18.02;	author pwagner;	state Exp;
branches;
next	2.128;

2.128
date	2006.01.11.18.00.12;	author pwagner;	state Exp;
branches;
next	2.127;

2.127
date	2005.09.14.00.13.30;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2005.09.02.21.57.23;	author vsnyder;	state Exp;
branches;
next	2.125;

2.125
date	2005.08.09.00.03.04;	author pwagner;	state Exp;
branches;
next	2.124;

2.124
date	2005.08.04.02.59.54;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2005.08.03.18.08.35;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2005.06.03.02.05.29;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2005.06.01.17.39.26;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2005.05.31.17.51.17;	author pwagner;	state Exp;
branches;
next	2.119;

2.119
date	2005.01.07.01.03.19;	author vsnyder;	state Exp;
branches;
next	2.118;

2.118
date	2004.10.16.17.25.55;	author livesey;	state Exp;
branches;
next	2.117;

2.117
date	2004.10.13.02.24.33;	author livesey;	state Exp;
branches;
next	2.116;

2.116
date	2004.09.27.20.11.05;	author livesey;	state Exp;
branches;
next	2.115;

2.115
date	2004.08.26.18.51.03;	author pwagner;	state Exp;
branches;
next	2.114;

2.114
date	2004.08.16.23.42.54;	author livesey;	state Exp;
branches;
next	2.113;

2.113
date	2004.06.29.00.09.25;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2004.06.21.23.58.40;	author pwagner;	state Exp;
branches;
next	2.111;

2.111
date	2004.06.17.23.17.00;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2004.05.19.19.16.09;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2004.04.16.00.48.52;	author livesey;	state Exp;
branches;
next	2.108;

2.108
date	2004.03.17.17.16.25;	author livesey;	state Exp;
branches;
next	2.107;

2.107
date	2004.02.10.21.17.24;	author livesey;	state Exp;
branches;
next	2.106;

2.106
date	2004.01.24.01.03.46;	author livesey;	state Exp;
branches;
next	2.105;

2.105
date	2003.08.08.23.06.53;	author livesey;	state Exp;
branches;
next	2.104;

2.104
date	2003.07.07.20.22.37;	author livesey;	state Exp;
branches;
next	2.103;

2.103
date	2003.07.01.23.18.04;	author livesey;	state Exp;
branches;
next	2.102;

2.102
date	2003.07.01.19.29.32;	author livesey;	state Exp;
branches;
next	2.101;

2.101
date	2003.06.27.00.07.07;	author pwagner;	state Exp;
branches;
next	2.100;

2.100
date	2003.06.20.19.37.06;	author pwagner;	state Exp;
branches;
next	2.99;

2.99
date	2003.05.29.18.18.39;	author livesey;	state Exp;
branches;
next	2.98;

2.98
date	2003.05.29.16.41.42;	author livesey;	state Exp;
branches;
next	2.97;

2.97
date	2003.05.28.05.59.06;	author livesey;	state Exp;
branches;
next	2.96;

2.96
date	2003.05.28.05.05.22;	author livesey;	state Exp;
branches;
next	2.95;

2.95
date	2003.05.28.05.04.20;	author livesey;	state Exp;
branches;
next	2.94;

2.94
date	2003.05.28.05.03.58;	author livesey;	state Exp;
branches;
next	2.93;

2.93
date	2003.05.28.04.40.08;	author livesey;	state Exp;
branches;
next	2.92;

2.92
date	2003.05.28.04.38.03;	author livesey;	state Exp;
branches;
next	2.91;

2.91
date	2003.05.22.04.04.07;	author livesey;	state Exp;
branches;
next	2.90;

2.90
date	2003.05.10.23.39.25;	author livesey;	state Exp;
branches;
next	2.89;

2.89
date	2003.05.07.01.00.03;	author livesey;	state Exp;
branches;
next	2.88;

2.88
date	2003.02.13.19.05.39;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2003.02.12.21.53.48;	author pwagner;	state Exp;
branches
	2.87.2.1;
next	2.86;

2.86
date	2003.02.07.03.42.50;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2003.02.07.03.38.05;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2003.02.07.00.41.41;	author livesey;	state Exp;
branches;
next	2.83;

2.83
date	2003.02.06.23.31.00;	author livesey;	state Exp;
branches;
next	2.82;

2.82
date	2003.01.14.00.40.29;	author pwagner;	state Exp;
branches;
next	2.81;

2.81
date	2003.01.09.00.09.15;	author pwagner;	state Exp;
branches;
next	2.80;

2.80
date	2003.01.08.23.50.44;	author livesey;	state Exp;
branches;
next	2.79;

2.79
date	2003.01.07.23.46.53;	author livesey;	state Exp;
branches;
next	2.78;

2.78
date	2002.12.11.22.17.05;	author pwagner;	state Exp;
branches;
next	2.77;

2.77
date	2002.11.26.23.37.50;	author livesey;	state Exp;
branches;
next	2.76;

2.76
date	2002.11.22.12.16.08;	author mjf;	state Exp;
branches;
next	2.75;

2.75
date	2002.11.13.01.05.03;	author pwagner;	state Exp;
branches;
next	2.74;

2.74
date	2002.10.08.17.36.19;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2002.09.26.18.03.06;	author livesey;	state Exp;
branches;
next	2.72;

2.72
date	2002.09.25.20.07.55;	author livesey;	state Exp;
branches;
next	2.71;

2.71
date	2002.09.24.21.37.44;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2002.09.24.00.27.16;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2002.09.18.22.48.32;	author pwagner;	state Exp;
branches;
next	2.68;

2.68
date	2002.08.04.16.01.19;	author mjf;	state Exp;
branches;
next	2.67;

2.67
date	2002.06.14.16.39.49;	author livesey;	state Exp;
branches;
next	2.66;

2.66
date	2002.06.04.22.07.35;	author livesey;	state Exp;
branches;
next	2.65;

2.65
date	2002.05.22.19.06.32;	author jonathan;	state Exp;
branches;
next	2.64;

2.64
date	2002.05.14.00.27.42;	author livesey;	state Exp;
branches
	2.64.2.1;
next	2.63;

2.63
date	2002.05.07.20.02.54;	author livesey;	state Exp;
branches;
next	2.62;

2.62
date	2002.04.10.17.44.22;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2002.03.19.00.51.32;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2002.02.09.21.35.52;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2001.11.08.00.13.38;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2001.10.31.19.07.25;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2001.10.12.23.15.05;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2001.10.02.23.12.50;	author pwagner;	state Exp;
branches;
next	2.55;

2.55
date	2001.10.02.20.50.54;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2001.09.17.23.11.50;	author pwagner;	state Exp;
branches;
next	2.53;

2.53
date	2001.09.17.21.58.50;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2001.09.14.23.30.33;	author pwagner;	state Exp;
branches;
next	2.51;

2.51
date	2001.08.01.00.04.29;	author dwu;	state Exp;
branches;
next	2.50;

2.50
date	2001.07.30.23.28.38;	author pwagner;	state Exp;
branches;
next	2.49;

2.49
date	2001.07.26.17.34.25;	author jonathan;	state Exp;
branches;
next	2.48;

2.48
date	2001.07.19.22.17.44;	author jonathan;	state Exp;
branches;
next	2.47;

2.47
date	2001.07.19.17.42.31;	author dwu;	state Exp;
branches;
next	2.46;

2.46
date	2001.07.18.23.17.30;	author dwu;	state Exp;
branches;
next	2.45;

2.45
date	2001.07.18.18.42.19;	author dwu;	state Exp;
branches;
next	2.44;

2.44
date	2001.07.17.23.23.05;	author dwu;	state Exp;
branches;
next	2.43;

2.43
date	2001.07.16.18.24.45;	author dwu;	state Exp;
branches;
next	2.42;

2.42
date	2001.07.13.18.41.59;	author dwu;	state Exp;
branches;
next	2.41;

2.41
date	2001.07.13.18.10.03;	author dwu;	state Exp;
branches;
next	2.40;

2.40
date	2001.07.11.21.40.00;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2001.07.10.23.45.16;	author jonathan;	state Exp;
branches;
next	2.38;

2.38
date	2001.07.09.22.37.23;	author livesey;	state Exp;
branches;
next	2.37;

2.37
date	2001.05.31.19.53.56;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2001.05.30.23.59.51;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2001.05.30.23.55.28;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2001.05.30.23.53.01;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2001.05.29.23.21.35;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2001.05.26.00.20.20;	author livesey;	state Exp;
branches;
next	2.31;

2.31
date	2001.05.10.01.08.53;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2001.05.03.23.08.36;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2001.05.03.20.30.09;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2001.04.26.02.45.25;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2001.04.26.02.44.17;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2001.04.25.20.33.07;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2001.04.25.19.29.49;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2001.04.25.00.01.23;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2001.04.24.22.21.17;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2001.04.23.23.25.10;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.04.20.23.11.39;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2001.04.19.20.30.06;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2001.04.12.23.25.29;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2001.04.12.21.41.42;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2001.04.10.22.27.47;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2001.04.07.01.50.48;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2001.03.28.23.48.13;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2001.03.28.18.33.19;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2001.03.21.02.13.30;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2001.03.17.02.23.55;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.03.15.21.07.47;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2001.03.15.18.41.17;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.03.08.21.49.26;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2001.03.03.00.08.09;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.03.02.01.28.23;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.02.28.01.17.04;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.02.22.23.37.24;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.02.21.01.09.00;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.02.20.18.43.50;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.02.14.00.12.45;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.02.09.00.38.22;	author livesey;	state Exp;
branches;
next	2.0;

2.0
date	2000.09.05.18.57.02;	author ahanzel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.02.02.05.03;	author vsnyder;	state Exp;
branches;
next	;

2.87.2.1
date	2003.02.13.20.36.06;	author livesey;	state Exp;
branches;
next	2.87.2.2;

2.87.2.2
date	2003.03.27.00.49.25;	author vsnyder;	state Exp;
branches;
next	;

2.64.2.1
date	2002.05.22.23.15.08;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.209
log
@Added CloudTopPressure as new Quantity type
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module ConstructQuantityTemplates

  ! This module is responsible for constructing templates for quantities.
  ! This version is a rewrite, aimed at tidying up a lot of the codebase
  use init_tables_module, only: first_lit, last_lit

  implicit none

  private 

  ! The various properties has/can have
  integer, parameter ::         Next                 = -1
  integer, public, parameter :: FirstProperty        = 1
  integer, public, parameter :: P_Chunked            = FirstProperty
  integer, public, parameter :: P_MajorFrame         = P_Chunked + 1
  integer, public, parameter :: P_MinorFrame         = P_MajorFrame + 1
  integer, public, parameter :: P_MustBeZeta         = P_MinorFrame + 1
  integer, public, parameter :: P_MustBeGeocalt      = P_MustBeZeta + 1
  integer, public, parameter :: P_FGrid              = P_MustBeGeocAlt + 1
  integer, public, parameter :: P_FGridOptional      = P_FGrid + 1
  integer, public, parameter :: P_FlexibleVHGrid     = P_FGridOptional + 1
  integer, public, parameter :: P_HGrid              = P_FlexibleVHGrid + 1
  integer, public, parameter :: P_Module             = P_HGrid + 1
  integer, public, parameter :: P_Molecule           = P_Module + 1
  integer, public, parameter :: P_SGrid              = P_Molecule + 1
  integer, public, parameter :: P_VGrid              = P_SGrid + 1
  integer, public, parameter :: P_Radiometer         = P_VGrid + 1
  integer, public, parameter :: P_RadiometerOptional = P_Radiometer + 1
  integer, public, parameter :: P_Reflector          = P_RadiometerOptional + 1
  integer, public, parameter :: P_SCmodule           = P_Reflector + 1
  integer, public, parameter :: P_Signal             = P_SCmodule + 1
  integer, public, parameter :: P_SignalOptional     = P_Signal + 1
  integer, public, parameter :: P_SuppressChannels   = P_SignalOptional + 1
  integer, public, parameter :: P_XYZ                = P_SuppressChannels + 1
  integer, public, parameter :: P_Matrix3x3          = P_XYZ + 1

  integer, public, parameter :: LastProperty         = P_Matrix3x3

  ! Local, saved variables (constant tables really)
  logical, public, save :: &
    & PROPERTYTABLE ( firstProperty: LastProperty, first_lit : last_lit )
  integer, public, save :: UNITSTABLE ( first_lit : last_lit )

  public :: AnyGoodSignalData, ConstructMinorFrameQuantity, ConstructMajorFrameQuantity
  public :: CreateQtyTemplateFromMLSCFInfo
  public :: ForgeMinorFrames
  public :: InitQuantityTemplates, GetQtyTypeIndex

  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: ConstructQuantityTemplates.f90,v $"
  private :: not_used_here 
  !---------------------------------------------------------------------------

  logical, save :: FIRSTCALL = .true.

contains ! ============= Public procedures ===================================

  ! ------------------------------------------- CreateQtyTemplateFromMLSCFInfo ----
  type (QuantityTemplate_T) function CreateQtyTemplateFromMLSCFInfo ( &
    & Name, Root, FGrids, HGrids, filedatabase, Chunk, MifGeolocation ) &
    & result ( QTY )
    use allocate_deallocate, only: allocate_test, deallocate_test
    use chunks_m, only: mlschunk_t
!   use chunkdivide_m, only: chunkdivideconfig
    use expr_m, only: expr
    use FGrid, only: FGrid_t
    use HGridsDatabase, only: HGrids_t
    use HighOutput, only: BeVerbose, outputNamedValue
    use init_tables_module, only:  f_badvalue, f_coordinate, f_fgrid, f_hgrid, &
      & f_irregular, f_keepchannels, f_logbasis, f_minvalue, f_module, &
      & f_molecule, f_radiometer, f_reflector, f_sgrid, f_signal, f_stacked, &
      & f_type, f_vgrid, f_xgrid, field_first, field_last, l_channel, &
      & l_explicit, l_geocaltitude, l_lostransfunc, l_matrix3x3, l_none, &
      & l_phitan, l_true, l_xyz, l_zeta
    use MLSCommon, only: MLSFile_t
    use MLSKinds, only: rk => r8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSSignals_m, only:getModuleFromRadiometer, getModuleFromSignal, &
      & getRadiometerFromSignal, getSignal, signal_t, &
      & isModuleSpacecraft
    use moreTree, only: get_boolean
    use parse_signal_m, only: parse_signal
    use quantityTemplates, only: nullifyQuantityTemplate, pointQuantityToHGrid, &
      & quantityTemplate_t, setupNewQuantityTemplate
    use string_table, only: get_string
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
    use tree, only: decoration, node_id, nsons, sub_rosa, subtree
    use tree_types, only: n_set_one
    use VGridsDatabase, only: VGrids

    ! Dummy arguments
    integer, intent(in) :: NAME              ! Sub-rosa index of name
    integer, intent(in) :: ROOT              ! Root of QuantityTemplate subtree
    type (FGrid_T), dimension(:), pointer :: FGrids
    type (HGrids_T), dimension(:), pointer :: HGrids
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (MLSChunk_T), intent(in) :: Chunk
    type (QuantityTemplate_T), dimension(:), intent(in), optional, target :: &
      & MifGeolocation ! TARGET attribute needed so pointers to MifGeolocation
                       ! created at lower levels in the call tree don't become
                       ! undefined when those procedures return.

    ! Local variables
    logical, pointer :: Channels(:)     ! From Parse_Signal
    logical :: LOGBASIS                 ! To place in quantity
    logical :: ISMINORFRAME             ! Is a minor frame quantity
    logical :: KeepChannels             ! From /channels, means keep the channels
                                        ! information from the signal
    logical :: REGULAR                  ! Flag
    logical :: PROPERTIES(firstProperty: LastProperty) ! Properties for this quantity type
    logical :: GOT(field_first:field_last) ! Fields
    character(len=127) :: SIGNALSTRING

    integer :: Coordinate               ! For vertical coordinate, in case we
                                        ! don't want L_None for MIF qty, e.g.
                                        ! tngtGeocAlt
    integer :: FGRIDINDEX               ! Index of frequency grid
    integer :: FREQUENCYCOORDINATE      ! Literal
    integer :: HGRIDINDEX               ! Index of horizontal grid
    integer :: HORIZONTALCOORDINATE     ! Literal
    integer :: I                        ! Loop counter
    integer :: INSTRUMENTMODULE         ! Database index
    integer :: KEY                      ! Field name, F_...
    integer :: Me = -1                  ! String index for trace
    integer :: MOLECULE                 ! Literal
    integer :: NOCHANS                  ! Quantity dimension
    integer :: NoCrossTrack             ! Number of cross-track angles
    integer :: NOINSTANCES              ! Quantity dimension
    integer :: NOSURFS                  ! Quantity dimension
    integer :: QUANTITYTYPE             ! Literal
    integer :: RADIOMETER               ! Database index
    integer :: REFLECTOR                ! Reflector literal
    integer :: SGRIDINDEX               ! Index for 'sGrid'
    integer :: SIDEBAND                 ! -1, 0, 1
    integer :: SIGNAL                   ! Database index
    integer :: SON                      ! A Son of Root -- an n_assign node
    logical :: Stacked                  ! All heights at a particular instance
                                        ! have same Lat and Lon
    integer :: VGRIDINDEX               ! Index in database
    integer :: VALUE                    ! Node index of value of field of spec
    integer :: S_INDEX                  ! Loop counter
    logical :: verbose
    integer :: xGridIndex               ! Index in hGrid database

    integer, dimension(2) :: EXPR_UNITS
    integer, dimension(:), pointer :: SignalInds ! From parse signal

    real(rk) :: BadValue
    real(rk) :: MINVALUE                ! Minimum value allowed for quantity in fwm
    real(rk), dimension(2) :: EXPR_VALUE
    type (signal_T) :: SIGNALINFO       ! Details of the appropriate signal

    ! Executable code
    if ( firstCall ) then
      call InitQuantityTemplates
      firstCall = .false.
    end if
    verbose = BeVerbose( 'qtmp', 0 )

    call trace_begin ( me, "CreateQtyTemplate", root, &
      & cond=toggle(gen) .and. levels(gen) > 1 )

    ! Set appropriate defaults
    call NullifyQuantityTemplate ( qty ) ! for Sun's rubbish compiler
    nullify ( channels, signalInds )
    qty%name = name
    fGridIndex = 0
    hGridIndex = 0
    horizontalCoordinate = l_phiTan
    instrumentModule = 0
    keepChannels = .false.
    logBasis = .false.
    minValue = -huge ( 0.0_rk )
    molecule = 0
    noChans = 1
    noCrossTrack = 1
    quantitytype = 0
    radiometer = 0
    reflector = 0
    regular = .true.
    sGridIndex = 0
    sideband = 0
    signal = 0
    signalString = ''
    stacked = .true.
    vGridIndex = 0
    xGridIndex = 0

    ! Go through the l2cf command line and parse it.
    got = .false.
    do i = 2, nsons(root)
      son = subtree(i,root)
      key = subtree(1,son)
      if ( node_id(son) == n_set_one ) then
        value = l_true
      else
        value = decoration(subtree(2,son))
      end if
      got ( decoration(key) ) = .true.

      select case ( decoration(key) )
      case ( f_badValue )
        call expr ( subtree(2,son), expr_units, expr_value )
        badValue = expr_value(1)
      case ( f_coordinate )
        coordinate = value
      case ( f_fgrid )
        fGridIndex = decoration(value)
      case ( f_hgrid )
        hGridIndex = decoration(value)
      case ( f_keepChannels )
        keepChannels = get_boolean(son)
      case ( f_logBasis )
        logBasis = get_boolean(son)
      case ( f_irregular )
        regular = get_boolean(son)
      case ( f_minValue )
        call expr ( subtree(2,son), expr_units, expr_value )
        minValue = expr_value(1)
      case ( f_module)
        instrumentModule = decoration(decoration(subtree(2,son)))
      case ( f_molecule )
        molecule = value
      case ( f_radiometer )
        radiometer = decoration(decoration(subtree(2,son)))
        instrumentModule = GetModuleFromRadiometer(radiometer)
      case ( f_reflector )
        reflector = value
      case ( f_sgrid )
        sGridIndex = decoration(value) ! node_id(value) == n_spec_args
      case ( f_signal )
        !??? For the moment it is simple, later we'll be more intelligent here
        !??? for example, letting the user choose either R1A or R1B.
        call get_string( sub_rosa(subtree(2,son)), signalString, strip=.true. )
        !??? Here we would do intelligent stuff to work out which bands
        !??? are present, for the moment choose the first
        call parse_Signal ( signalString, signalInds, &
          & tree_index=son, sideband=sideband, channels=channels )
        if ( .not. associated(signalInds) ) then ! A parse error occurred
          call MLSMessage ( MLSMSG_Error, ModuleName,&
            & 'Unable to parse signal string' )
        end if
        if ( size(signalInds) == 1 .or. .not. associated(filedatabase) ) then
          signal = signalInds(1)
        else
          ! Seek a signal with any precision values !< 0
          do s_index=1, size(signalInds)
            if ( AnyGoodSignalData ( signalInds(s_index), sideband, &
              & filedatabase, Chunk) ) exit
          end do
          if ( s_index > size(signalInds) ) then
            signal = signalInds(1)
          else
            signal = signalInds(s_index)
          end if
        end if
        call deallocate_test ( signalInds, 'signalInds', ModuleName )
        instrumentModule = GetModuleFromSignal(signal)
        radiometer = GetRadiometerFromSignal(signal)
      case ( f_stacked )
        stacked = get_boolean(son)
      case ( f_type )
        quantityType = value
      case ( f_vgrid )
        vGridIndex = decoration(value) ! node_id(value) == n_spec_args
      case ( f_xgrid ) ! an hGrid
        xGridIndex = decoration(value) ! node_id(value) == n_spec_args
        if ( hGrids(xGridIndex)%the_hGrid%type /= l_explicit ) &
          & call Announce_error ( root, 'XGrid is not explicit', quantityType )
        noCrossTrack = size(hgrids(xGridIndex)%the_hGrid%phi)
      end select
    end do

    ! Do a very low level sanity check, irregular quantities not supported
    if ( .not. regular ) call announce_error ( root,&
      & 'Inappropriate irregular quantity request' )

    ! Now get the properties for this quantity type
    properties = propertyTable ( :, quantityType )

    ! Now check various things out first check that required fields are present
    ! according to the quantity type
    ! First those that are fairly clear cut to check
    if ( .not. properties ( p_flexibleVHGrid ) ) then
      if ( got ( f_hGrid ) .neqv. properties ( p_hGrid ) ) &
        & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
        & got(f_hGrid) ) ) // ' hGrid for quantity type ', quantityType, &
        & severity='nonfatal' )
      if ( got ( f_vGrid ) .neqv. properties ( p_vGrid ) ) &
        & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
        & got(f_vGrid) ) ) // ' vGrid for quantity type ', quantityType )
    end if
    if ( got ( f_sGrid ) .neqv. properties ( p_sGrid ) ) &
      & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
      & got(f_sGrid) ) ) // ' sGrid for quantity type ', quantityType )
    if ( got ( f_Molecule ) .neqv. properties ( p_Molecule ) ) &
      & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
      & got(f_Molecule) ) ) // ' molecule for quantity type ', quantityType )
    if ( got ( f_Reflector ) .neqv. properties ( p_Reflector ) ) &
      & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
      & got(f_Reflector) ) ) // ' reflector for quantity type ', quantityType )
    ! These ones need a little more thought
    if ( .not. properties ( p_signalOptional ) ) then
      if ( got ( f_Signal ) .neqv. properties ( p_Signal ) ) &
        & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
        & got(f_Signal) ) ) // ' signal for quantity type ', quantityType )
    end if
    if ( .not. properties ( p_fGridOptional ) ) then
      if ( got ( f_fGrid ) .neqv. properties ( p_fGrid ) ) &
        & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
        & got(f_fGrid) ) ) // ' fGrid for quantity type ', quantityType )
    end if
    if ( .not. properties ( p_radiometerOptional ) ) then
      if ( got ( f_Radiometer ) .neqv. properties ( p_Radiometer ) ) &
        & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
        & got(f_Radiometer) ) ) // ' radiometer for quantity type ', quantityType )
    end if
    if ( got ( f_Module ) .neqv. ( properties ( p_Module ) .or. properties ( p_scModule) ) ) &
      & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
      & got(f_Module) ) ) // ' module for quantity type ', quantityType )

    ! Now do more derived checking / setting up
    if ( properties ( p_mustBeZeta ) .and. got(f_vGrid) ) then
      if ( vGrids(vGridIndex)%verticalCoordinate /= l_zeta ) &
        & call Announce_error ( root, 'Expecting log pressure coordinates for', &
        & quantityType )
    end if
    if ( properties ( p_mustBeGeocAlt ) .and. got(f_vGrid) ) then
      if ( vGrids(vGridIndex)%verticalCoordinate /= l_geocAltitude ) &
        & call Announce_error ( root, 'Expecting geocentric altitude coordinates for ', &
        & quantityType )
    end if
    if ( properties ( p_scModule ) ) then
      if ( .not. IsModuleSpacecraft ( instrumentModule ) ) &
        & call Announce_error ( root, 'Module must be spacecraft' )
    end if

    ! Now establish the frequency coordinate system
    if ( got(f_fGrid) ) then
      frequencyCoordinate = fGrids(fGridIndex)%frequencyCoordinate
      qty%frequencies => fGrids(fGridIndex)%values
      noChans = fGrids(fGridIndex)%noChans
      ! print *, '1st try: fGridIndex ', fGridIndex
      ! print *, fGrids(fGridIndex)%values
    else if ( properties(p_xyz) ) then
      ! XYZ quantity (e.g. ECI/ECR stuff)
      frequencyCoordinate = l_xyz
      noChans = 3
    else if ( properties(p_matrix3x3) ) then
      ! XYZ^2 quantity (e.g. rotation matrix)
      frequencyCoordinate = l_matrix3x3
      noChans = 9
    else if ( got(f_signal) .and. .not. properties(p_suppressChannels) ) then
      ! This is a channel based quantity
      signalInfo = GetSignal ( signal )
      frequencyCoordinate = l_channel
      noChans = size ( signalInfo%frequencies )
      if ( keepChannels ) then
        qty%channels => channels
        nullify ( channels ) ! so we don't deallocate out from under qty%channels
      end if
    else if ( got(f_sGrid) ) then
      ! Uses an sGrid.  This is faked as frequency, but it's not
      noChans = size ( vGrids(sGridIndex)%surfs )
      frequencyCoordinate = l_losTransFunc
    else
      ! No frequency variation
      noChans = 1
      frequencyCoordinate = l_none
    end if

    ! Now deal with the flexibleVHGrid quantities
    if ( properties(p_flexibleVHGrid) ) then
      if ( got ( f_hGrid ) .neqv. got ( f_vGrid ) ) &
        & call Announce_Error ( root, 'Must supply both or neither vGrid and hGrid' )
      isMinorFrame = .not. got ( f_hGrid )
    else
      isMinorFrame = properties(p_minorFrame)
    end if
    
    ! horizontalCoordinate?
    if ( got(f_hGrid) ) then
      if (  hGridIndex > 0 ) &
        & horizontalCoordinate = HGrids(hGridIndex)%the_hGrid%masterCoordinate
    else if ( got(f_xGrid) ) then
      call Announce_error ( root, 'XGrid specified without HGrid', quantityType )
    end if

    ! Now do the setup for the different families of quantities
    if ( isMinorFrame ) then
      ! Setup a minor frame quantity
      if ( got(f_coordinate) ) qty%verticalCoordinate = coordinate
      qty%quantityType = quantityType
      call ConstructMinorFrameQuantity ( instrumentModule, qty, &
        noChans=noChans, noCrossTrack=noCrossTrack, filedatabase=filedatabase, &
        chunk=chunk, mifGeolocation=mifGeolocation, &
        regular=regular )
    else if ( properties(p_majorFrame) ) then
      ! Setup a major frame quantity
      call ConstructMajorFrameQuantity ( chunk, instrumentModule, &
        & qty, noChans, mifGeolocation, noCrossTrack )
    else
      ! Setup a non major/minor frame quantity
      noInstances = 1
      if ( got ( f_hGrid ) ) noInstances = hGrids(hGridIndex)%the_hGrid%noProfs
      noSurfs = 1
      if ( got ( f_vGrid ) ) noSurfs = vGrids(vGridIndex)%noSurfs

      ! Setup the quantity template
      call SetupNewQuantityTemplate ( qty, noInstances=noInstances, &
        & noSurfs=noSurfs, coherent=.true., stacked=stacked, regular=.true.,&
        & noChans=noChans, noCrossTrack=noCrossTrack, &
        & sharedVGrid=.true., sharedFGrid=.true. )

      ! Setup the horizontal coordinates
      if ( got(f_hGrid) ) then
        qty%the_hGrid => hGrids(hGridIndex)%the_hGrid
        qty%hGridIndex = hGridIndex
        qty%xGridIndex = xGridIndex
        call PointQuantityToHGrid ( qty )
      else
        call SetupEmptyHGridForQuantity ( qty )
      end if
      ! Work out the instance offset
      if ( associated ( chunk%hGridOffsets ) ) then
        if ( got ( f_hGrid )  ) then
          qty%instanceOffset = chunk%hGridOffsets(hGridIndex)
          qty%grandTotalInstances = chunk%hGridTotals(hGridIndex)
          if ( verbose ) call outputnamedvalue ( 'grandTotalInstances from hgrid)', &
            & qty%grandTotalInstances )
          ! Subtract any instances outside processing range
          !   if ( ChunkDivideConfig%allowPriorOverlaps ) &
          !     & qty%grandTotalInstances = qty%grandTotalInstances - &
          !     & hGrids(hGridIndex)%the_hGrid%noProfsLowerOverlap
          !   if ( ChunkDivideConfig%allowPostOverlaps ) &
          !     & qty%grandTotalInstances = qty%grandTotalInstances - &
          !     & hGrids(hGridIndex)%the_hGrid%noProfsUpperOverlap
        else
          ! Must have a single instance per chunk
          qty%instanceOffset = chunk%chunkNumber - 1
          ! -1 because it's an offset remember, not an origin.
          qty%grandTotalInstances = 0
        end if
      end if

      ! Setup the vertical coordinates
      if ( got (f_vGrid) ) then
        qty%vGridIndex = vGridIndex
        qty%verticalCoordinate = vGrids(vGridIndex)%verticalCoordinate
        qty%surfs = vGrids(vGridIndex)%surfs
      else
        call SetupEmptyVGridForQuantity ( qty )
      end if
    end if

    ! Setup the cross-track coordinates
    nullify ( qty%crossAngles )
    if ( xGridIndex /= 0 ) then
      call allocate_test ( qty%crossAngles, &
        & size(hGrids(xGridIndex)%the_hGrid%phi,2), 'qty%crossAngles', moduleName )
      qty%crossAngles = hGrids(xGridIndex)%the_hGrid%phi(1,:)
    else
      call allocate_test ( qty%crossAngles, 1, 'qty%crossAngles', moduleName )
      qty%crossAngles = 0.0
    end if

    ! Fill the frequency information if appropriate
    if ( got ( f_fGrid ) ) then
      ! print *, 'About to: qty%GridIndex was ', qty%fGridIndex
      ! print *, 'qty%sharedFGrid ', qty%sharedFGrid
      ! print *, fGrids(fGridIndex)%values
      qty%fGridIndex = fGridIndex
      qty%frequencies => fGrids(fGridIndex)%values
      if ( .not. qty%sharedFGrid ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName,&
          & 'sharedFGrid needed to be reset' )
        qty%sharedFGrid = .true.
      end if
      ! print *, '2nd try: fGridIndex ', fGridIndex
      ! print *, 'qty%sharedFGrid ', qty%sharedFGrid
      ! print *, fGrids(fGridIndex)%values
    end if
    if ( properties ( p_sGrid ) ) then ! Faked as frequency, but it's not
      qty%sharedFGrid = .false.
      nullify(qty%frequencies) ! Lest we deallocate a database entry
      call Allocate_test ( qty%frequencies, qty%noChans, 'qty%frequencies', &
        & ModuleName )
      qty%fGridIndex = -sGridIndex        ! Use -ve value to denote sGrid
      qty%frequencies = vGrids(sGridIndex)%surfs(:,1)
      ! print *, 'Resetting: fGridIndex ', qty%fGridIndex
      ! print *, qty%frequencies
    end if

    ! Set up the remaining stuff
    qty%name = name
    qty%frequencyCoordinate = frequencyCoordinate
    qty%instrumentmodule = instrumentmodule
    qty%logBasis = logBasis
    qty%minValue = minValue
    qty%molecule = molecule
    qty%quantityType = quantityType
    qty%radiometer = radiometer
    qty%reflector = reflector
    qty%sideband = sideband
    qty%signal = signal
    qty%unit = unitsTable ( quantityType )
    qty%horizontalCoordinate = horizontalCoordinate
    if ( got(f_badValue) ) qty%badValue = badValue

    call deallocate_test ( channels, 'Channels', moduleName )

    call trace_end ( "CreateQtyTemplate", cond=toggle(gen) .and. levels(gen) > 1 )

  end function CreateQtyTemplateFromMLSCFInfo

  ! --------------------------------  ConstructMinorFrameQuantity  -----
  ! I think we should make filedatabase and chunk optional as well
  ! because we don't need it when mifGeolocation is present -haley
  subroutine ConstructMinorFrameQuantity ( instrumentModule, &
    & qty, noChans, regular, instanceLen, NoCrossTrack, &
    & filedatabase, chunk, mifGeolocation )

    use Chunks_m, only: MLSChunk_t
    use Dump_0, only: Dump
    use Dump_1, only: Dump
    use HighOutput, only: BeVerbose, LetsDebug, OutputNamedValue
    use Init_tables_module, only: l_geodaltitude, l_none
    use L1BData, only: L1BData_t, readL1BData, deallocateL1BData, &
      & AssembleL1bQtyName
    use MLSCommon, only: MLSFile_t, nameLen
    use MLSKinds, only: rk => r8
    use MLSFiles, only: HDFVersion_5, Dump, GetMLSFileByType
    use MLSHDF5, only: GetAllHDF5DSNames, IsHDF5DSPresent
    use MLSMessageModule, only: MLSMessage, &
      & MLSMSG_Error, MLSMSG_L1BRead, MLSMSG_Warning
    use MLSSignals_m, only:  Dump_Modules, GetModuleName, &
      & IsAnyModuleSpacecraft, isModuleSpacecraft
    use Output_m, only: Output
    use QuantityTemplates, only: QuantityTemplate_t, &
      & Dump, setupNewQuantityTemplate
    use String_table, only: Display_string
    use Toggles, only: Gen, Levels, Toggle
    use Trace_m, only: Trace_begin, Trace_end

    ! This routine constructs a minor frame based quantity.

    ! Dummy arguments
    integer, intent(in) :: instrumentModule  ! Database index
    type (QuantityTemplate_T), intent(inout) :: qty ! Resulting quantity
    integer, intent(in), optional :: noChans
    logical, intent(in), optional :: regular
    integer, intent(in), optional :: instanceLen
    integer, intent(in), optional :: NoCrossTrack ! Number of cross-track angles
    type (MLSFile_T), dimension(:), pointer, optional ::     FILEDATABASE
    type (MLSChunk_T), intent(in), optional :: chunk   ! The chunk under consideration
    type (QuantityTemplate_T), intent(in), dimension(:), optional :: &
         & mifGeolocation

    ! Local parameters
    real(rk), parameter :: SIXTH = 1.0_rk / 6.0_rk
    ! Note the similarity to CreateHGridFromMLSCFInfo:
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    type :: Item_T
      Integer :: Type
      character(15) :: Name
      logical :: Modular = .true. ! Tangent qty?
      logical :: Bare = .true.  ! Not under any groupname?
    end type Item_T
    enum, bind(C)
      enumerator :: FirstSCItem = 1, scGeodLat = 1, scLon, &
        & MAFStartTimeTAI, tpGeodLat, tpLon, tpGeodAngle, &
        & tpSolarZenith, tpSolarTime, tpLosAngle
    end enum
    integer, parameter :: LastSCItem = scLon
    integer, parameter :: LastL1BItem = tpLosAngle
    ! First, SC items, then instrument items
    type (item_t), parameter :: L1bItemsToRead(firstSCItem:lastL1BItem) = (/ &
      !        Type              Name              Modular
      & item_t(scGeodLat,       "scGeodLat      ", .false., .false.), &
      & item_t(scLon,           "scLon          ", .false., .false.), &
      & item_t(MAFStartTimeTAI, "MAFStartTimeTAI", .false.,  .true.), &
      & item_t(tpGeodLat,       "tpGeodLat      ", .true.,  .false.), &
      & item_t(tpLon,           "tpLon          ", .true.,  .false.), &
      & item_t(tpGeodAngle,     "tpGeodAngle    ", .true.,  .false.), &
      & item_t(tpSolarZenith,   "tpSolarZenith  ", .true.,  .false.), &
      & item_t(tpSolarTime,     "tpSolarTime    ", .true.,  .false.), &
      & item_t(tpLosAngle,      "tpLosAngle     ", .true.,  .false.) /)

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    ! Local variables
    character(len=1024) :: DSNames
    character (len=NameLen) :: instrumentModuleName
    type (L1BData_T) :: l1bField
    type (MLSFile_T), pointer :: L1BFile
    character (len=NameLen) :: l1bItemName
    integer :: hdfVersion, l1bFlag, l1bItem, noMAFs, mafIndex, mifIndex
    integer :: Me = -1      ! For tracing
    logical :: MissingOK
    integer :: Start, Stop  ! For reading L1B quantities, depending upon whether
                            ! they're for the instrument or the tangent point
    logical :: UseMIFGeolocation
    logical :: verbose
    logical :: verboser

    ! Executable code. There are basically two cases here. If we have a
    ! MIFGeolocation argument this conveys all the geolocation for this
    ! quantity.  Otherwise, we have to read it all from the l1boa file
    ! ourselves.

    call trace_begin ( me, "ConstructMinorFrameQuantity", &
      & cond=toggle(gen) .and. levels(gen) > 2 )

    MissingOK = .false. ! .not. AURA_L1BFILES
    verbose = BeVerbose( 'qtmp', -1 )
    verboser = LetsDebug( 'qtmp', 0 )
    MissingOK = BeVerbose( 'missOK', -1 )

    call GetModuleName( instrumentModule, instrumentModuleName )
    ! Now due to some error deper than we wish to delve,
    ! The s/c instrument module name is coming out as
    ! 'SC', but the l1boa file thinks it's just 'sc'.
    if ( instrumentModuleName == 'SC' ) instrumentModuleName = 'sc'
    if ( verbose ) then
      if ( qty%name > 0 ) then
        call output ( 'name: ', advance='no' )
        call display_string ( qty%name, advance='yes' )
      endif
      call outputnamedValue( 'instrumentModule index', instrumentModule )
      call outputnamedValue( 'instrumentModule name', trim(instrumentModuleName) )
    endif
    useMIFGeolocation = present(mifGeolocation)
    if ( useMIFGeolocation ) &
      & useMIFGeolocation = mifGeolocation(instrumentModule)%verticalCoordinate == &
                            qty%verticalCoordinate
    if ( verbose ) call outputnamedValue( 'useMIFGeolocation', useMIFGeolocation )
    if ( useMIFGeolocation ) then
      ! --  Got mifGeolocation and vertical coordinates match --
      if ( .not. (present(noChans)) ) &
         call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'You must supply NoChans to reuse geolocation information' )
      if ( verboser ) then
        call output( 'Dump of mifGeolocation; provides lat, etc.', advance = 'yes' )
        call Dump ( mifGeolocation(instrumentModule) )
      endif
      ! We have geolocation information, setup the quantity as a clone of that.
      qty = mifGeolocation(instrumentModule)
      qty%sharedVGrid = .true.
      if ( present ( regular ) ) qty%regular = regular
      qty%noChans = noChans
      if ( qty%regular ) then
        qty%instanceLen = qty%noChans * qty%noSurfs * qty%noCrossTrack
      else
        qty%instanceLen = 0
      end if

    else if (present(chunk) .and. present(filedatabase)) then
      if ( verbose ) call output( 'We have no geolocation information', advance='yes' )
      ! --  Not Got mifGeolocation or vertical coordinates do not match  --
      ! We have no geolocation information, or we don't want to use it.
      ! We have to read it ourselves from the L1BOA file.

      ! First we read xxGeodAlt to get the number of MAFs, and the surfs
      L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
      hdfversion = L1BFile%HDFVersion
      if ( IsModuleSpacecraft(instrumentModule) ) then
        if ( .not. isAnyModuleSpacecraft() ) then
          call output( 'You should never have come here like this', advance='yes' )
          stop
        endif
        l1bItemName = merge("scGeodAlt","scGeocAlt", &
                           &qty%verticalCoordinate==l_geodAltitude)
      else
        call GetModuleName ( instrumentModule, l1bItemName )
        l1bItemName = TRIM(l1bItemName) // "." // &
          & merge("tpGeodAlt","tpGeocAlt",qty%verticalCoordinate==l_geodAltitude)
      end if
      l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
      if ( verboser ) then
        call outputnamedValue ( 'l1bItemName#1', trim(l1bItemName) )
        call outputnamedValue ( 'isModuleSpacecraft', isModuleSpacecraft(instrumentModule) )
        call outputnamedValue ( 'isAnyModuleSpacecraft', isAnyModuleSpacecraft() )
        call outputnamedValue ( 'firstMAFIndex', chunk%firstMAFIndex )
        call outputnamedValue ( 'lastMAFIndex', chunk%lastMAFIndex )
        call Dump_Modules
      endif
      if ( verbose ) call outputnamedValue( 'hdfversion', L1BFile%HDFVersion )
      if ( L1BFile%HDFVersion == HDFVersion_5 ) then
        ! OK, so what if GeodAlt isn't here?
        ! 2nd bet: 
        if ( .not. IsHDF5DSPresent( L1BFile, trim(l1bItemName) ) ) &
          & l1bItemName = AssembleL1BQtyName ( 'tpGeodAlt', HDFVersion, &
          & .true., instrumentModuleName )
        if ( .not. IsHDF5DSPresent( L1BFile, trim(l1bItemName) ) ) then

          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & "Will not know number of mafs; unable to find " &
            & // trim(l1bItemName) )
          call Dump ( L1BFile, details=2 )
          ! call Dump ( filedatabase, details=2 )
          call GetAllHDF5DSNames ( L1BFile, DSNames )
          call Dump ( DSNames, 'DSNames' )
          qty%name = 0
          qty%instanceOffset = chunk%firstMAFIndex + chunk%noMAFsLowerOverlap
          qty%grandTotalInstances = 0
          call SetupNewQuantityTemplate ( qty, &
            & noInstances=chunk%lastMAFIndex-chunk%firstMAFIndex + 1, &
            & noSurfs=0, noChans=0, &
            & noCrossTrack=noCrossTrack, coherent=.false., &
            & stacked=.false., regular=regular, instanceLen=0, &
            & minorFrame=.true., verticalCoordinate=qty%verticalCoordinate )
          call outputNamedValue ( 'Set num of MAFs to', &
            & chunk%lastMAFIndex-chunk%firstMAFIndex + 1 )
          call Dump( qty, details=2 )
          call trace_end ( "ConstructMinorFrameQuantity", &
            & cond=toggle(gen) .and. levels(gen) > 2 )
          return
        endif
      endif
      call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & neverfail=MissingOK )
      if ( l1bFlag /= 0 .and. .not. MissingOK ) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_L1BRead//l1bItemName )
      else if ( l1bFlag /= 0 ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & MLSMSG_L1BRead//l1bItemName )
        ! return
      end if
      if ( verboser ) then
        call outputnamedValue ( 'noMAFs', noMAFs )
        call outputnamedValue ( 'l1bFlag', l1bFlag )
      endif

      qty%name = 0
      call SetupNewQuantityTemplate ( qty, noInstances=noMAFs, &
        & noSurfs=l1bField%maxMIFs, noChans=noChans, &
        & noCrossTrack=noCrossTrack, coherent=.false., &
        & stacked=.false., regular=regular, instanceLen=instanceLen, &
        & minorFrame=.true., verticalCoordinate=qty%verticalCoordinate )
      qty%noInstancesLowerOverlap = chunk%noMAFsLowerOverlap
      qty%noInstancesUpperOverlap = chunk%noMAFsUpperOverlap

      ! Now we're going to fill in the hGrid information
      qty%instanceOffset = chunk%firstMAFIndex + chunk%noMAFsLowerOverlap
      qty%grandTotalInstances = 0
      if ( verbose ) then
        call output ( "Instance offset for minor frame quantity is:" )
        call output ( qty%instanceOffset, advance='yes' )
      end if
      
      ! In case we didn't find the proper item in the l1boa files
      if ( l1bFlag /= 0 ) then
        call trace_end ( "ConstructMinorFrameQuantity", &
          & cond=toggle(gen) .and. levels(gen) > 1 )
        return
      endif

      ! Work out which items to read
      if ( IsModuleSpacecraft(instrumentModule) ) then
        start = firstSCitem
        stop = lastSCitem
        ! Zero out stuff that we don't read.  See L1bItemsToRead above.
        qty%phi = 0.0
        qty%time = 0.0
        qty%solarTime = 0.0
        qty%solarZenith = 0.0
        qty%losAngle = 0.0
      else
        start = lastSCitem + 1
        stop = lastL1Bitem
      end if

      ! Now we're going to deal with a VGrid for this quantity.
      ! This is either the scGeocAlt or tpGeo[cd]Alt read above
      qty%surfs = l1bField%dpField(1,:,:)

      call DeallocateL1BData ( l1bField )

      do l1bItem = start, stop
        if ( verbose ) call outputNamedValue ( 'l1bItem num', l1bItem )
        ! Get the name of the item to read
        l1bItemName = L1bItemsToRead(l1bItem)%name
        if ( verbose ) call outputNamedValue ( 'its name', trim(l1bItemName) )
        if ( L1bItemsToRead(l1bItem)%Bare ) then
          ! This should be the name as stored in the l1boa file
        elseif ( L1bItemsToRead(l1bItem)%modular ) then
          if ( verbose ) call output ( 'it is modular', advance='yes' )
          call GetModuleName ( instrumentModule, l1bItemName )
          if ( IsModuleSpacecraft(instrumentModule) ) &
            & call GetModuleName ( instrumentModule+1, instrumentModuleName )
          if ( instrumentModuleName == 'SC' ) instrumentModuleName = 'sc'
          l1bItemName = &
            & trim(instrumentModuleName)//'.'//L1bItemsToRead(l1bItem)%name
          if ( verboser ) &
            & call outputnamedValue ( 'before assembly', trim(l1bItemName) )
          l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        elseif ( .not. isAnyModuleSpacecraft() ) then
          cycle
        else
          l1bItemName = L1bItemsToRead(l1bItem)%name
          if ( verboser ) &
            & call outputnamedValue ( 'before assembly', trim(l1bItemName) )
          if ( l1bItemName(1:2) == 'sc' ) l1bItemName = l1bItemName(3:)
          l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false., &
            & InstrumentModuleName )
        end if

        ! Read it from the l1boa file
        if ( verboser ) call outputNamedValue ( 'MissingOK', MissingOK )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
          & l1bFlag, firstMAF=chunk%firstMafIndex, &
          & lastMAF=chunk%lastMafIndex, neverfail=MissingOK )
        if ( l1bFlag /= 0 ) then
          call MLSMessage ( merge(MLSMSG_Warning,MLSMSG_Error,missingOK), &
            & ModuleName, MLSMSG_L1BRead//l1bItemName )
          cycle
        end if

        ! Now we have to save this field in the quantity data.
        ! This is rather a kludgy way of doing it but this worked out the
        ! least boring way to write the code.  See the definition of
        ! L1BItemsToRead above for reference.
        
        select case ( L1bItemsToRead(l1bItem)%type )
        case ( MAFStartTimeTAI )
          !??? For time we have to do something a little more complicated.
          !??? This is a real kludge, and we have to find a way
          !??? to do it better in 0.5. Probably simply have time as a minor
          !??? frame quantity in L1, or MIF duration. !???????
          !??? Also note that it fills in times even for non existant MIFs
          do mafIndex = 1, noMAFs
            do mifIndex = 1, qty%noSurfs 
              qty%time(mifIndex,mafIndex) = &
                & l1bField%dpField(1,1,mafIndex) + &
                & (mifIndex-1) * sixth
            end do
          end do
        case ( tpGeodLat, scGeodLat )
          qty%geodLat = l1bField%dpField(1,:,:)
        case ( tpLon, scLon )
          qty%lon = l1bField%dpField(1,:,:)
        case ( tpGeodAngle )
          if ( associated(l1bField%intField) ) then
            qty%phi = l1bField%intField(1,:,:)
          else
            qty%phi = l1bField%dpField(1,:,:)
          endif
        case ( tpSolarZenith )
          qty%solarZenith = l1bField%dpField(1,:,:)
        case ( tpSolarTime )
          qty%solarTime = l1bField%dpField(1,:,:)
        case ( tpLosAngle )
          qty%losAngle = l1bField%dpField(1,:,:)
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "No code to read L1B item " // trim(L1bItemsToRead(l1bItem)%name) )
        end select
        if ( verboser ) then
          if ( associated(l1bField%intField) ) then
            call dump( l1bField%intField(1,:,:) )
          else
            call dump( l1bField%dpField(1,:,:) )
          endif
        endif
        call DeallocateL1BData ( l1bField )
      end do                          ! Loop over l1b quantities
    else
      call MLSMessage ( MLSMSG_Error, ModuleName, &
                        "Must supply either mifGeolocation " &
                        // "or both filedatabase and chunk")
    end if
    qty%frequencyCoordinate = L_None
    qty%instrumentModule = instrumentModule

    ! In later versions we'll probably need to think about FILL_VALUEs and
    ! setting things to the badData flag.
    
    ! We thought about about them, but not too hard apparently.

    call trace_end ( "ConstructMinorFrameQuantity", &
      & cond=toggle(gen) .and. levels(gen) > 1 )

  end subroutine ConstructMinorFrameQuantity

  ! ------------------------------------ ForgeMinorFrames --------------
  subroutine ForgeMinorFrames ( root, mifGeolocation )
    ! This routine is used when we're in the mode of creating l2pc files
    ! and we want to invent a set of minor frame quantities with no
    ! reference to the l1 files

    use expr_m, only: expr
    use init_tables_module, only: f_geodalt, f_geodangle, f_module, f_nomifs, &
      & f_solartime, f_solarzenith, f_truncate
    use init_tables_module, only: l_geodaltitude, phyq_angle, phyq_dimensionless, &
      & phyq_time
    use MLSKinds, only: rk => r8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MoreTree, only: Get_Boolean
    use QuantityTemplates, only: CopyQuantityTemplate, &
      & DestroyQuantityTemplateContents, QuantityTemplate_T, &
      & SetupNewQuantityTemplate
    use tree, only: decoration, nsons, subtree
    use vgridsdatabase, only: vgrid_t, vgrids

    ! Dummy arguments
    integer, intent(in) :: ROOT         ! Tree vertex
    type (QuantityTemplate_T), intent(inout), target :: MIFGEOLOCATION(:)

    ! Local variables
    integer :: GEODANGLENODE            ! Tree vertex
    integer :: I                        ! Loop counter
    integer :: INSTRUMENTMODULE         ! Database index
    integer :: KEY                      ! Tree vertex
    integer :: MAF                      ! Loop counter
    integer :: NODE                     ! A tree node
    integer :: NoInstances              ! In a truncated MIF geolocation
    integer :: NOMAFS                   ! Dimension
    integer :: NOMIFS                   ! Dimension
    integer :: NoSurfs                  ! In a truncated MIF geolocation
    integer :: PARAM                    ! Loop counter
    integer :: SOLARTIMENODE            ! Tree vertex
    integer :: SOLARZENITHNODE          ! Tree vertex
    integer :: SON                      ! Tree vertex
    logical :: Truncate                 ! Truncate existing MIF Geolocation
                                        ! instead of filling with zeros.
    integer :: UNITS                    ! Units for node

    real(rk), dimension(:,:), pointer :: VALUES ! An array to fill
    integer, dimension(2) :: EXPR_UNITS ! From tree
    real(rk), dimension(2) :: EXPR_VALUE ! From tree
    type ( quantityTemplate_t ) :: NewMIFGeolocation
    type(VGrid_T), pointer :: GEODALT

    ! Executable code
    nullify ( geodAlt )
    solarTimeNode = 0
    solarZenithNode = 0
    geodAngleNode = 0
    truncate = .false.

    do i = 2, nsons( root )
      son = subtree(i,root)
      key = subtree(1,son)

      select case ( decoration(key) )
      case ( f_module )
        instrumentModule = decoration(decoration(subtree(2,son)))
      case ( f_geodAngle )
        geodAngleNode = son
      case ( f_geodAlt )
        geodAlt => vGrids(decoration(decoration(subtree(2,son))))
      case ( f_solarTime )
        solarTimeNode = son
      case ( f_solarZenith )
        solarZenithNode = son
      case ( f_noMIFs )
        call expr ( subtree(2,son), expr_units, expr_value )
        noMIFs = expr_value(1)
      case ( f_truncate )
        truncate = get_boolean ( son )
      case default ! Can't get here if tree_checker works correctly
      end select
    end do

    ! Work out how many MAFs we're after
    if ( geodAngleNode /= 0 ) noMAFs = nsons ( geodAngleNode ) - 1
    if ( solarTimeNode /= 0 ) then
      if ( noMAFs /= 0 ) then
        if ( nsons ( solarTimeNode ) - 1 /= noMAFs ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Inconsistent explicit Forge definition' )
      else
        noMAFs = nsons ( solarTimeNode ) - 1
      end if
    end if
    if ( solarZenithNode /= 0 ) then
      if ( noMAFs /= 0 ) then
        if ( nsons ( solarZenithNode ) - 1 /= noMAFs ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Inconsistent explicit Forge definition' )
      else
        noMAFs = nsons ( solarZenithNode ) - 1
      end if
    end if

    ! Setup the minor frame quantity template
    ! Note this will destroy the old one's contents bit by bit.
    if ( truncate ) then
      noSurfs = min(noMIFS, mifGeolocation(instrumentModule)%noSurfs)
      noInstances = min(noMAFS, mifGeolocation(instrumentModule)%noInstances)
      call SetupNewQuantityTemplate ( NewMIFGeolocation, &
        & noInstances=noInstances, noSurfs=noSurfs, noChans=1, &
        & noCrossTrack=1, &
        & coherent=.false., stacked=.false., regular=.true., &
        & minorFrame=.true. )
      ! First put zeros in the new  arrays, in case the old ones are shorter.
      newMIFGeolocation%time = 0.0
      newMIFGeolocation%phi = 0.0
      newMIFGeolocation%geodLat = 0.0
      newMIFGeolocation%solarTime = 0.0
      newMIFGeolocation%solarZenith = 0.0
      newMIFGeolocation%lon = 0.0
      newMIFGeolocation%losAngle = 0.0
      newMIFGeolocation%surfs = 0.0
      newMIFGeolocation%instrumentModule = mifGeolocation(instrumentModule)%instrumentModule
      newMIFGeolocation%noInstancesLowerOverlap = mifGeolocation(instrumentModule)%noInstancesLowerOverlap
      newMIFGeolocation%noInstancesUpperOverlap = mifGeolocation(instrumentModule)%noInstancesUpperOverlap
      newMIFGeolocation%verticalCoordinate = mifGeolocation(instrumentModule)%verticalCoordinate
      newMIFGeolocation%time = mifGeolocation(instrumentModule)%time(:noSurfs,:noInstances)
      newMIFGeolocation%geodLat = mifGeolocation(instrumentModule)%geodLat(:noSurfs,:noInstances)
      newMIFGeolocation%solarTime = mifGeolocation(instrumentModule)%solarTime(:noSurfs,:noInstances)
      newMIFGeolocation%solarZenith = mifGeolocation(instrumentModule)%solarZenith(:noSurfs,:noInstances)
      newMIFGeolocation%lon = mifGeolocation(instrumentModule)%lon(:noSurfs,:noInstances)
      newMIFGeolocation%losAngle = mifGeolocation(instrumentModule)%losAngle(:noSurfs,:noInstances)
      newMIFGeolocation%surfs = mifGeolocation(instrumentModule)%surfs(:noSurfs,:noInstances)
      call copyQuantityTemplate ( mifGeolocation(instrumentModule), newMIFGeolocation )
      call destroyQuantityTemplateContents ( newMIFGeolocation )
  else
      mifGeolocation(instrumentModule)%name = 0
      call SetupNewQuantityTemplate ( mifGeolocation(instrumentModule), &
        & noInstances=noMAFs, noSurfs=noMIFs, noChans=1, &
        & noCrossTrack=1, &
        & coherent=.false., stacked=.false., regular=.true., &
        & minorFrame=.true. )

      ! Put zeros etc. in the appropriate places, may overwrite these later
      mifGeolocation(instrumentModule)%instrumentModule = instrumentModule
      mifGeolocation(instrumentModule)%noInstancesLowerOverlap = 0
      mifGeolocation(instrumentModule)%noInstancesUpperOverlap = 0
      mifGeolocation(instrumentModule)%verticalCoordinate = l_geodAltitude
      mifGeolocation(instrumentModule)%time = 0.0
      mifGeolocation(instrumentModule)%phi = 0.0
      mifGeolocation(instrumentModule)%geodLat = 0.0
      mifGeolocation(instrumentModule)%solarTime = 0.0
      mifGeolocation(instrumentModule)%solarZenith = 0.0
      mifGeolocation(instrumentModule)%lon = 0.0
      mifGeolocation(instrumentModule)%losAngle = 0.0
      mifGeolocation(instrumentModule)%surfs = 0.0
    end if

    ! Check the geodAlt information if supplied
    if ( associated ( geodAlt ) ) then 
      if ( noMIFs /= geodAlt%noSurfs ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Incorrect number of minor frames for geodAlt' )
      mifGeolocation(instrumentModule)%surfs = spread ( geodAlt%surfs(:,1), 2, noMAFs )
    end if

    ! Loop over the parameters we might have
    do param = 1, 3
      select case ( param )
      case ( 1 )
        values => mifGeolocation(instrumentModule)%phi
        node = geodAngleNode
        units = phyq_angle
      case ( 2 )
        values => mifGeolocation(instrumentModule)%solarTime
        node = solarTimeNode
        units = phyq_time
      case ( 3 )
        values => mifGeolocation(instrumentModule)%solarZenith
        node = solarZenithNode
        units = phyq_angle
      end select

      if ( node /= 0 ) then
        do maf = 1, noMAFs
          call expr ( subtree ( maf+1, node), expr_units, expr_value )
          if ( all ( expr_units(1) /= (/ phyq_dimensionless, units /) ) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Invalid units for explicit hGrid' )
          values(:,maf) = expr_value(1)
        end do
      end if
    end do
    ! Make the latitude the same as the geod angle
    ! This is a bit of a hack, but it should be OK in all cases.
    mifGeolocation(instrumentModule)%geodLat = &
      & mifGeolocation(instrumentModule)%phi
    
  end subroutine ForgeMinorFrames

  ! ======================================= Private proceedures ========
  
  ! -----------------------------------------------  Announce_Error  -----
  subroutine Announce_Error ( where, message, extra, severity )

    use lexer_core, only: print_source
    use output_m, only: blanks, output
    use tree, only: where_at=>where
    use Intrinsic, only: lit_indices
    use string_table, only: display_string
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error

    integer, intent(in) :: WHERE   ! Tree node where error was noticed
    character (LEN=*), intent(in) :: MESSAGE
    integer, intent(in), optional :: EXTRA
    character(len=*), intent(in), optional :: SEVERITY ! 'nonfatal' or 'fatal'
    character(len=8) :: mySeverity

    mySeverity = 'fatal'
    if ( present(severity) ) then
      if (index('WwNn', severity(1:1)) > 0 ) mySeverity='warning'
    end if
    if ( mySeverity /= 'fatal' ) then
      call blanks(5)
      call output ( ' (warning) ' )
    else
      call blanks(5, fillChar='*')
      call output ( ' (fatal) ' )
    end if
    call output ( 'At ' )
    if ( where > 0 ) then
      call print_source ( where_at(where) )
    else
      call output ( '(no lcf tree available)' )
    end if
    call output ( ': ' )
    call output ( message )
    if ( present ( extra ) ) call display_string ( lit_indices ( extra ), strip=.true. )
    call output ( '', advance='yes' )
    if ( mySeverity == 'fatal') &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem in Construct' )
  end subroutine Announce_Error

  ! -----------------------------------------------  AnyGoodSignalData  -----
  function AnyGoodSignalData ( SIGNAL, SIDEBAND, FILEDATABASE, CHUNK, MAFWISE ) &
    &  result (ANSWER)
  ! Read precision of signal
  ! if all values < 0.0, return FALSE
  ! if no precision data in file, return FALSE
  ! otherwise return true
  ! Arguments

    use chunks_m, only: MLSChunk_t
    use allocate_deallocate, only: deallocate_test
    use L1BData, only: L1BData_t, readL1BData, getl1bfile, &
      & assemblel1bqtyname, precisionsuffix
    use MLSCommon, only: MLSFile_t
    use MLSKinds, only: rk => r8
    use MLSFiles, only: geTMLSFileByType
    use MLSSignals_m, only: getSignalName

    integer, intent(in)                         :: signal
    integer, intent(in)                         :: sideband
    logical                                     :: answer
    type (MLSChunk_T), intent(in)               :: Chunk
    type (MLSFile_T), dimension(:), pointer     :: FILEDATABASE
    logical, dimension(:), optional, intent(out):: MAFWISE
  ! Private
    ! integer :: FileID
    integer :: flag
    integer :: i
    integer :: noMAFs
    character(len=127)  :: namestring
    type (l1bData_T) :: MY_L1BDATA
    type (MLSFile_T), pointer ::     L1BFile

  ! Executable
  answer = .false.
  if ( present(mafwise) ) mafwise = .false.
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    if ( .not. associated(L1BFile) ) return
    call GetSignalName ( signal, nameString, &                   
    & sideband=sideband, noChannels=.TRUE. )                     
    nameString = AssembleL1BQtyName ( nameString, L1BFile%hdfVersion, .false. )
    nameString = trim(nameString) // PRECISIONSUFFIX
    L1BFile => GetL1bFile(filedatabase, namestring)
    ! fileID = FindL1BData ( filedatabase, nameString )
    if ( .not. associated(L1BFile) ) then
      answer = .false.
      return
    end if
    ! print *, 'About to read ', trim(nameString)
    ! print *, 'From Fileid ', fileID
    call ReadL1BData ( L1BFile, nameString, my_l1bData, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
      & NeverFail= .true. )
    if ( flag == 0 ) then
      answer = .not. all (my_l1bData%DpField < 0._rk)
      if ( present( mafwise) ) then
        do i = 1, chunk%lastMAFIndex - chunk%firstMAFIndex + 1
          mafwise(i) = .not. all (my_l1bData%DpField(:,:,i) < 0._rk)
        enddo
      endif
      call deallocate_test(my_l1bData%DpField, trim(nameString), ModuleName)
    else
      answer = .false.
    end if
  end function AnyGoodSignalData

  ! --------------------------------  ConstructMajorFrameQuantity  -----
  subroutine ConstructMajorFrameQuantity( chunk, instrumentModule, qty, noChans, &
    & mifGeolocation, NoCrossTrack )
    ! Dummy arguments
    use chunks_m, only: MLSChunk_t
    use quantityTemplates, only: CreateGeolocationFields, quantityTemplate_t, &
      & setUpNewQuantityTemplate
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end

    type (MLSChunk_T), intent(in) :: CHUNK
    integer, intent(in) :: INSTRUMENTMODULE
    type (QuantityTemplate_T), intent(out) :: QTY
    type (QuantityTemplate_T), dimension(:), intent(in), target :: MIFGEOLOCATION
    integer, intent(in) :: NOCHANS
    integer, intent(in), optional :: NoCrossTrack
    ! Local variables

    integer :: Me = -1     ! For tracing
    type (QuantityTemplate_T), pointer :: source
    
    ! Executable code
    call trace_begin ( me, "ConstructMajorFrameQuantity", &
      & cond=toggle(gen) .and. levels(gen) > 2 )

    source => mifGeolocation(instrumentModule)
    qty%name = 0
    call SetupNewQuantityTemplate ( qty, noInstances=source%noInstances, &
      & noSurfs=1, coherent=.true., stacked=.true., regular=.true., &
      & noChans=noChans, noCrossTrack=noCrossTrack, &
      & sharedVGrid=.true. )
    call SetupEmptyVGridForQuantity ( qty )
    ! In some rare cases, e.g. non-Aura satellite data, source might be a dud
    if ( allocated(source%phi) ) then
      call createGeolocationFields ( qty, qty%noSurfs, 'Qty' )
      qty%geodLat = source%geodLat(1:1,:)
      qty%lon = source%lon(1:1,:)
      qty%phi = source%phi(1:1,:)
      qty%time => source%time(1:1,:)
      qty%solarTime => source%solarTime(1:1,:)
      qty%solarZenith => source%solarZenith(1:1,:)
      qty%losAngle => source%losAngle(1:1,:)
    end if

    qty%majorFrame = .true.
    qty%minorFrame = .false.
    qty%instanceOffset = source%instanceOffset
    qty%instrumentModule = source%instrumentModule
    qty%noInstancesLowerOverlap = chunk%noMAFsLowerOverlap
    qty%noInstancesUpperOverlap = chunk%noMAFsUpperOverlap

    call trace_end ( "ConstructMajorFrameQuantity", &
      & cond=toggle(gen) .and. levels(gen) > 1 )

  end subroutine ConstructMajorFrameQuantity

  ! ----------------------------------------------  GetQtyTypeIndex  -----
  subroutine GetQtyTypeIndex(string_text, QtyType)
    use Intrinsic, only: lit_indices
    use MLSStrings, only: lowercase
    use string_table, only: get_string
    ! Returns the lit index,  given QtyType name in mixed case
    ! Returns 0 if QtyType name not found
    ! (inverse function: GetQtyTypeName)
    integer, intent(out) :: QtyType
    character (len=*), intent(in) :: string_text
    ! Local variables
    character (len=len(string_text))             :: string_test
    do QtyType=first_lit, last_lit
      ! Skip if not quantity type
      if ( .not. any(PROPERTYTABLE(:, QtyType) ) ) cycle
      call get_string ( lit_indices(QtyType), string_test, strip=.true. )
      if ( LowerCase(trim(string_text)) == LowerCase(trim(string_test))) &
       & return
    end do
    QtyType = 0
  end subroutine GetQtyTypeIndex

  ! ----------------------------------------------- InitQuantityTemplates ----
  subroutine InitQuantityTemplates
    ! This routine initializes the quantity template properties
    ! This is the routine one needs to update when one introduces a new quantity type.
    use Init_Tables_Module, only:  l_adopted, l_adopted, l_baseline, &
      l_boundarypressure, l_calsidebandfraction, &
      l_chisqbinned, l_chisqchan, l_chisqmmaf, l_chisqmmif, l_cloudice, &
      l_cloudinducedradiance, l_cloudextinction, l_cloudminmax, l_cloudradsensitivity, &
      l_cloudtemperature, l_CloudTopPressure, l_cloudwater, l_columnabundance, &
      l_dnwt_abandoned, l_dnwt_ajn, l_dnwt_axmax, l_dnwt_cait, &
      l_dnwt_chisqminnorm, l_dnwt_chisqnorm, l_dnwt_chisqratio, &
      l_dnwt_count, l_dnwt_diag, l_dnwt_dxdx, l_dnwt_dxdxl, &
      l_dnwt_dxn, l_dnwt_dxnl, l_dnwt_flag, l_dnwt_fnmin, &
      l_dnwt_fnorm, l_dnwt_gdx, l_dnwt_gfac, &
      l_dnwt_gradn, l_dnwt_sq, l_dnwt_sqt,&
      l_earthradius, l_earthrefl, l_ecrtofov, l_effectiveopticaldepth, &
      l_elevoffset, l_extinction, l_extinctionv2, &
      l_fieldazimuth, l_fieldelevation, l_fieldstrength, &
      l_geolocation, l_gph, l_ghzazim, l_heightoffset, l_isotoperatio, l_iwc, &
      l_jacobian_cols, l_jacobian_rows, &
      l_l1bmafbaseline, l_l1bmif_tai, l_limbsidebandfraction, &
      l_linecenter, l_linewidth, l_linewidth_tdep, &
      l_lostransfunc, l_losvel, l_lowestretrievedpressure, &
      l_massmeandiameterice, l_massmeandiameterwater, l_magneticfield, &
      l_mifdeadtime, l_mifextinction, l_mifextinctionextrapolation, &
      l_mifExtinctionform, l_mifExtinctionv2, &
      l_mifRadC, l_mifRHI, &
      l_noisebandwidth, l_noradspermif, l_noradsbinned, &
      l_numgrad, l_numj, l_numnewt, &
      l_opticaldepth, l_orbitinclination, l_ascdescmode, l_geoheight, &
      l_phasetiming, l_phitan, l_ptan, l_quality, l_radiance, &
      l_refgph, l_refltemp, l_refltrans, l_reflrefl, l_reflspill, &
      l_rhi, l_singlechannelradiance, l_sizedistribution, &
      l_scanresidual, l_scatteringangle, l_sceci, l_instecr, l_scecr, l_scveleci, &
      l_scvelecr, l_scgeocalt, l_spaceradiance, l_status, &
      l_strayradiance, l_surfaceheight, l_surfacetype, l_systemtemperature, &
      l_temperature, l_tngteci, l_tngtecr, l_tngtgeodalt, l_tngtgeocalt, &
      l_totalpowerweight, l_tscat, l_vmr
    use Init_Tables_Module, only:  phyq_angle, phyq_colmabundance, &
     & phyq_dimensionless, phyq_extinction, phyq_frequency,&
     & phyq_gauss, phyq_icedensity, phyq_length, &
     & phyq_pressure, phyq_temperature, phyq_time, phyq_velocity, &
     & phyq_vmr, phyq_zeta

    use MLSMessageModule, only: MLSMSG_Error, MLSMessage
    use Intrinsic, only: Lit_Indices
    use Output_M, only: Output
    use String_Table, only: Display_String

    ! Local variables
    integer :: I                        ! Loop counter
    integer, dimension(1:0), parameter :: None = (/ ( 0, i=1,0 ) /)
    logical :: Valid                    ! Flag
    character(len=132) :: Message       ! An error message

    ! Executable code
    ! Basically here, we're going to go through and populate the various tables

    propertyTable = .false.
    unitsTable = 0

    ! DefineQtyTypes creates the arrays PropertyTable and UnitsTable. For
    ! each quantity type, the first thing in the list is the quantity's lit
    ! index.  The next is its physical dimension.  After that there is a
    ! list of properties.  The list of properties for a quantity ends with
    ! either "next,", after which information for another quantity may
    ! begin, or the end of the array.  The property "none" is a zero-extent
    ! array, provided for its documentary value.

    call DefineQtyTypes ( (/ &
      l_adopted, phyq_dimensionless, none, next, &
      l_baseline, phyq_temperature, p_flexibleVHGrid, p_fGrid, p_radiometerOptional, &
                  p_signalOptional, p_suppressChannels, p_mustBeZeta, next, &
      l_boundaryPressure, phyq_pressure, p_hGrid, next, &
      l_calSidebandFraction, phyq_dimensionless, p_signal, next, &
      l_chisqBinned, phyq_dimensionless, p_hGrid, p_vGrid, &
                     p_signal, p_suppressChannels, p_mustBeZeta, next, &
      l_chisqChan, phyq_dimensionless, p_majorFrame, p_signal, next, &
      l_chisqMMAF, phyq_dimensionless, p_majorFrame, p_signal, &
                   p_suppressChannels, next, &
      l_chisqMMIF, phyq_dimensionless, p_minorFrame, p_signal, &
                   p_suppressChannels, next, &
      l_cloudExtinction, phyq_dimensionless, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_cloudIce, phyq_IceDensity, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_cloudInducedRadiance, phyq_temperature, p_minorFrame, p_signal, next, &
      l_cloudMinMax, phyq_temperature, p_hGrid, p_vGrid, p_mustbezeta, &
                     p_signal, p_suppressChannels, next, &
      l_cloudRadSensitivity, phyq_temperature, p_minorFrame, p_signal, next, &
      l_cloudTemperature, phyq_temperature, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_CloudTopPressure, phyq_pressure, p_hGrid, next, &
      l_cloudWater, phyq_dimensionless, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_columnAbundance, phyq_colmabundance, p_hGrid, p_molecule, next, &
      l_dnwt_abandoned, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_ajn, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_axmax, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_cait, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_chisqminnorm, phyq_dimensionless, p_vGrid /) )

    call DefineQtyTypes ( (/ &
      l_dnwt_chisqnorm, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_chisqratio, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_count, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_diag, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_dxdxl, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_dxdx, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_dxnl, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_dxn, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_flag, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_fnmin, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_fnorm, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_gdx, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_gfac, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_gradn, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_sq, phyq_dimensionless, p_vGrid, next, &
      l_dnwt_sqt, phyq_dimensionless, p_vGrid, next, &
      l_earthRadius, phyq_length, p_hGrid, next, &
      l_earthRefl, phyq_dimensionless, none /) )

    call DefineQtyTypes ( (/ &
      l_ecrToFOV, phyq_dimensionless, p_minorFrame, p_module, p_matrix3x3, next, &
      l_effectiveOpticalDepth, phyq_dimensionless, p_minorFrame, p_signal, next, &
      l_elevOffset, phyq_angle, p_signal, next, &
      l_extinction, phyq_extinction, p_hGrid, p_vGrid, p_fGrid, p_radiometer, &
                    p_mustBeZeta, next, &
      l_extinctionv2, phyq_extinction, p_hGrid, p_vGrid, p_fGrid, p_radiometer, &
                      p_mustBeZeta, next, &
      l_fieldAzimuth, phyq_angle, p_hGrid, p_vGrid, next, &
      l_fieldElevation, phyq_angle, p_hGrid, p_vGrid, next, &
      l_fieldStrength, phyq_gauss, p_hGrid, p_vGrid, next, &
      l_geolocation, phyq_dimensionless, p_majorframe, p_module, next, &
      l_gph, phyq_length, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_GHzAzim, phyq_angle, p_minorFrame, p_module, next, &
      l_heightOffset, phyq_length, p_hGrid, p_vGrid, next, &
      l_isotopeRatio, phyq_dimensionless, p_molecule, next, &
      l_iwc, phyq_icedensity, p_hGrid, p_vGrid, next, &
      l_jacobian_cols, phyq_dimensionless, p_vGrid, next, &
      l_jacobian_rows, phyq_dimensionless, p_vGrid, next /) )

    call DefineQtyTypes ( (/ & 
      l_l1bMAFBaseline, phyq_temperature, p_majorFrame, p_signal, next, &
      l_l1bMIF_TAI, phyq_time, p_minorFrame, p_scmodule, next, &
      l_limbSidebandFraction, phyq_dimensionless, p_signal, next, &
      l_lineCenter, phyq_frequency, p_hGrid, p_vGrid, p_molecule, next, &
      l_lineWidth,  phyq_frequency, p_hGrid, p_vGrid, p_molecule, next, &
      l_lineWidth_TDep, phyq_dimensionless, p_hGrid, p_vGrid, p_molecule, next, &
      l_losTransFunc, phyq_dimensionless, p_minorFrame, p_sGrid, p_module, next, &
      l_losVel, phyq_dimensionless, p_minorFrame, p_module, next, & ! ??? Really phyq_dimensionless
      l_lowestRetrievedPressure, phyq_zeta, none, next, &
      l_magneticField, phyq_gauss, p_vGrid, p_hGrid, p_xyz, next, &
      l_massMeanDiameterIce, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, & ! ??? Really phyq_dimensionless
      l_massMeanDiameterWater, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, & ! ??? Really phyq_dimensionless
      l_mifDeadTime, phyq_time, next, &
      l_mifExtinction, phyq_extinction, p_flexibleVHGrid, &
        & p_minorFrame, p_radiometer, p_mustBeZeta, next, &
      l_mifExtinctionExtrapolation, phyq_dimensionless, none, next, &
      l_mifExtinctionForm, phyq_dimensionless, none, next, &
      l_mifExtinctionV2, phyq_extinction, p_flexibleVHGrid, &
        & p_minorFrame, p_radiometer, p_mustBeZeta, next, &
      phyq_length, p_minorFrame, p_module, next, &
      l_mifRadC, phyq_length, p_minorFrame, p_module, next, &
      l_mifRHI, phyq_dimensionless, p_flexibleVHGrid, &
        & p_minorFrame, p_radiometer, p_mustBeZeta, next, &
      l_noiseBandwidth, phyq_frequency, p_signal, next, &
      l_noRadsBinned, phyq_dimensionless, p_vGrid, p_hGrid, &
        & p_signal, p_suppressChannels, p_mustBeZeta, next, &
      l_noRadsPerMIF, phyq_dimensionless, p_minorFrame, p_signal, &
        & p_suppressChannels, next, &
      l_numNewt, phyq_dimensionless, p_vGrid, next, &
      l_numGrad, phyq_dimensionless, p_vGrid, next, &
      l_numJ, phyq_dimensionless, p_vGrid, next /) )

    call DefineQtyTypes ( (/ &
      l_opticalDepth, phyq_dimensionless, p_minorFrame, p_signal, next, &
      l_orbitInclination, phyq_angle, p_minorFrame, p_scModule, next, &
      l_AscDescMode, phyq_dimensionless, p_hGrid, next, & 
      l_geoheight, phyq_dimensionless, p_hGrid, p_vGrid, next, &
      l_phaseTiming, phyq_dimensionless, p_vGrid, next, &
      l_phiTan, phyq_angle, p_minorFrame, p_module, next, &
      l_ptan, phyq_zeta, p_minorFrame, p_module, next, &
      l_quality, phyq_dimensionless, p_hGrid, next, &
      l_radiance, phyq_temperature, p_minorFrame, p_signal, next, & 
      l_refGPH, phyq_length, p_hGrid, p_vGrid, p_mustBeZeta, next, &
      l_reflrefl, phyq_dimensionless, p_signal, p_reflector, next, &
      l_reflspill, phyq_temperature, p_signal, p_majorframe, p_reflector, next, &
      l_refltemp, phyq_temperature, p_majorFrame, p_reflector, p_module, next, &
      l_refltrans, phyq_dimensionless, p_signal, p_reflector, next, &
      l_rhi, phyq_dimensionless, p_hGrid, p_vGrid, p_molecule, p_mustBeZeta, next, &
      l_scanResidual, phyq_length, p_minorFrame, p_module, next, &
      l_scatteringAngle, phyq_angle, p_vGrid, next, &
      l_scECI, phyq_length, p_minorFrame, p_scModule, p_xyz, next, &
      l_instECR, phyq_length, p_minorFrame, p_Module, p_xyz, next, &
      l_scECR, phyq_length, p_minorFrame, p_scModule, p_xyz, next, &
      l_scGeocAlt, phyq_length, p_minorFrame, p_scModule, next, &
      l_scVelECI, phyq_velocity, p_minorFrame, p_scModule, p_xyz, next, &
      l_scVelECR, phyq_velocity, p_minorFrame, p_scModule, p_xyz, next, &
      l_singleChannelRadiance, phyq_temperature, p_minorFrame, p_signal, &
                               p_suppressChannels, next, &
      l_sizeDistribution, phyq_dimensionless, p_hGrid, p_vGrid, p_mustBeZeta, next, & 
      l_spaceRadiance, phyq_temperature, none, next, &
      l_status, phyq_dimensionless, p_hGrid, next, &
      l_strayRadiance, phyq_temperature, p_signal, p_majorFrame, next, &
      l_surfaceHeight, phyq_length, p_hGrid, next, &
      l_surfaceType, phyq_dimensionless, p_hGrid, next, & 
      l_systemTemperature, phyq_temperature, p_signal, next, &
      l_temperature, phyq_temperature, p_hGrid, p_vGrid, p_mustbezeta, next, &
      l_tngtECI, phyq_length, p_minorFrame, p_module, p_xyz, next, &
      l_tngtECR, phyq_length, p_minorFrame, p_module, p_xyz, next, &
      l_tngtGeocAlt, phyq_length, p_minorFrame, p_module, next, &
      l_tngtGeodAlt, phyq_length, p_minorFrame, p_module, next, &
      l_totalPowerWeight, phyq_dimensionless, p_signal, next, &
      l_TScat, phyq_temperature, p_hGrid, p_signal, p_vGrid, next, &
      l_vmr, phyq_vmr, p_hGrid, p_vGrid, p_fGridOptional, &
             p_molecule, p_radiometerOptional, p_mustbezeta, next /) )

    ! Do a bit of checking
    do i = first_lit, last_lit
      valid = .true.
      message =  ''
      ! Check it's not both major and minor frame
      if ( count ( propertyTable ( (/ p_minorFrame, p_majorFrame /), i ) ) > 1 ) then
        valid = .false.
        message = "Quantity cannot be both major and minor frame"
      end if
      ! Check that we can identify the module for major/minor frame
      if ( ( propertyTable ( p_minorFrame, i ) .or. &
        &    propertyTable ( p_majorFrame, i ) ) .and. &
        & .not. any ( propertyTable ( &
        & (/ p_radiometer, p_module, p_scModule, p_signal /), i ) ) ) then
        valid = .false.
        message = "Badly defined major/minor frame quantity"
      end if
      ! Check that mustBeZeta or mustBeGeocAlt quantities have a vGrid
      if ( ( propertyTable ( p_mustBeZeta, i ) .or. &
           & propertyTable ( p_mustBeGeocAlt, i ) ).and. .not. &
        & ( propertyTable ( p_vGrid, i ) .or. propertyTable ( p_flexibleVHGrid, i ) ) ) then
        valid = .false.
        message = "Quantity must have vGrid if it must be on log-pressure or geocentric altitude"
      end if
      ! Print out any message
      if ( .not. valid ) then
        call output ( "Offending quantity: " )
        call display_string ( lit_indices ( i ), strip=.true., advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, message )
      end if
    end do

  contains

    ! --------------------------- Internal subroutine
    subroutine DefineQtyTypes ( info )
      integer, dimension(:), intent(in) :: INFO
      ! Local variables
      integer :: I                      ! Location
      integer :: QTYTYPE                ! Index
      ! Executable code
      qtyType = 0
      i = 1
      do while ( i <= size(info) )
        if ( qtyType == 0 ) then
          qtyType = info ( i )
          propertyTable ( :, qtyType ) = .false.
          i = i + 1
          if ( i > size(info) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Malformed call to DefineQtyTypes' )
          unitsTable ( qtyType ) = info ( i )
        else
          if ( info(i) /= next ) then
            propertyTable ( info(i), qtyType ) = .true.
          else
            qtyType = 0
          end if
        end if
        i = i + 1
      end do
    end subroutine DefineQtyTypes
    
  end subroutine InitQuantityTemplates

  ! ---------------------------------- SetupEmptyHGridForQuantity
  subroutine SetupEmptyHGridForQuantity ( qty ) 
    use Allocate_Deallocate, only: allocate_test
    use QuantityTemplates, only: QuantityTemplate_T
    ! Dummy arguments
    type ( QuantityTemplate_T ), intent(inout) :: QTY
    ! Executable code
    qty%hGridIndex = 0
    qty%xGridIndex = 0
    ! Lest we deallocate a database entry:
    nullify( qty%frequencies, qty%time, qty%solarTime, &
      & qty%solarZenith, qty%losAngle, qty%crossAngles, qty%the_hGrid )
    call allocate_test ( qty%phi, 1, 1, 'qty%phi(1,1)', ModuleName )
    call allocate_test ( qty%geodLat, 1, 1, 'qty%geodLat(1,1)', ModuleName )
    call allocate_test ( qty%lon, 1, 1, 'qty%lon1(1,1)', ModuleName )
    call allocate_test ( qty%time, 1, 1, 'qty%time(1,1)', ModuleName )
    call allocate_test ( qty%solarTime, 1, 1, 'qty%solarTime(1,1)', ModuleName )
    call allocate_test ( qty%solarZenith, 1, 1, 'qty%solarZenith(1,1)', ModuleName )
    call allocate_test ( qty%losAngle, 1, 1, 'qty%losAngle(1,1)', ModuleName )
    call allocate_test ( qty%crossAngles, 1, 'qty%crossAngles(1)', ModuleName )
    qty%phi = 0.0
    qty%geodLat = 0.0
    qty%lon = 0.0
    qty%time = 0.0
    qty%solarTime = 0.0
    qty%solarZenith = 0.0
    qty%losAngle = 0.0
    qty%crossAngles = 0.0
  end subroutine SetupEmptyHGridForQuantity

  ! ---------------------------------- SetupEmptyVGridForQuantity
  subroutine SetupEmptyVGridForQuantity ( qty ) 
    use Allocate_Deallocate, only: ALLOCATE_TEST
    use Intrinsic, only: L_NONE
    use QuantityTemplates, only: QuantityTemplate_T
    ! Dummy arguments
    type ( QuantityTemplate_T ), intent(inout) :: QTY
    ! Executable code
    qty%sharedVGrid = .false.
    qty%vGridIndex = 0
    qty%verticalCoordinate = l_none
    call Allocate_test ( qty%surfs, 1, 1, 'qty%surfs(1,1)', ModuleName )
    qty%surfs = 0. ! We used to have impossible values for bnd. prs.
  end subroutine SetupEmptyVGridForQuantity

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ConstructQuantityTemplates.f90,v 2.208 2020/01/27 18:02:46 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ConstructQuantityTemplates
!
! $Log: ConstructQuantityTemplates.f90,v $
! Revision 2.208  2020/01/27 18:02:46  pwagner
! Worked around the error that made instrumentModuleName allcaps
!
! Revision 2.207  2018/04/11 17:47:05  pwagner
! Should work better with ASMLS mif geolocations
!
! Revision 2.206  2018/02/23 22:04:45  mmadatya
! Added l_instECR for ASMLS
!
! Revision 2.205  2017/12/15 18:43:56  mmadatya
! Added geoHeight as new quantity template
!
! Revision 2.204  2017/10/27 01:29:46  vsnyder
! Remove L_MIFLOS
!
! Revision 2.203  2017/06/01 22:49:15  vsnyder
! Remove unused USE names
!
! Revision 2.202  2016/11/04 23:05:48  pwagner
! Define some potentially undefined qty components
!
! Revision 2.201  2016/10/20 23:13:39  pwagner
! When warning of missing GeodAlt, say how big we set numMAFs
!
! Revision 2.200  2016/10/14 00:05:46  pwagner
! Show qty name, too, when verbosely Constructing its template
!
! Revision 2.199  2016/09/21 00:41:32  pwagner
! Default to printing less
!
! Revision 2.198  2016/08/12 00:33:05  pwagner
! Seems to restore tthe gold brick
!
! Revision 2.197  2016/08/09 21:51:57  pwagner
! Survives encounter with non-satellite data
!
! Revision 2.196  2016/07/28 19:56:00  pwagner
! Extra care in CConstructMinorFrameQs
!
! Revision 2.195  2016/07/28 00:42:46  vsnyder
! Remove unused USE
!
! Revision 2.194  2016/07/27 23:03:44  pwagner
! Works better with Aircraft-borne instrument data
!
! Revision 2.193  2016/07/25 23:41:53  pwagner
! Avoid reading l1b s/c fields if no module is s/c
!
! Revision 2.192  2016/07/21 20:28:54  pwagner
! Now remembers to call trace_end before returning from a failed l1b read
!
! Revision 2.191  2016/05/27 20:59:04  vsnyder
! Remove l_mifIncline and l_mifTanHt because they are redundant to
! l_OrbitInclination and l_tngtGeodAlt
!
! Revision 2.190  2016/05/27 01:24:07  vsnyder
! Add L_mifTanHt
!
! Revision 2.189  2016/05/24 01:26:01  vsnyder
! Add mifIncline, mifLOS, mifRadC
!
! Revision 2.188  2016/05/18 01:37:30  vsnyder
! Change HGrids database from an array of HGrid_T to an array of pointers
! to HGrid_T using the new type HGrids_T.
!
! Revision 2.187  2016/05/04 18:31:39  pwagner
! Requires -Sqtmp1 to dump l1b arrays when constructing minor fram qty
!
! Revision 2.186  2015/09/25 02:16:20  vsnyder
! Preserve the quantity template vertical coordinate.  Read the appropriate
! kind of altitude quantity from the L1BOA file, depending on the quantity
! template's vertical coordinate.
!
! Revision 2.185  2015/09/22 01:57:57  vsnyder
! Add GHzAzim and ScECR quantity types
!
! Revision 2.184  2015/09/17 23:21:08  pwagner
! Turning on verbose(r) prints more now in ConstructMinorFrameQuantity
!
! Revision 2.183  2015/07/29 00:29:54  vsnyder
! Convert Phi from pointer to allocatable
!
! Revision 2.182  2015/07/27 22:28:06  vsnyder
! Make cross angles always associated, with value zero if there's no xGrid
!
! Revision 2.181  2015/06/04 03:14:14  vsnyder
! Make Surfs component of quantity template allocatable
!
! Revision 2.180  2015/06/03 00:01:51  vsnyder
! Allocate rank-2 latitude and longitude, instead of rank-1 ones and then
! remapping to rank-2 and rank-3.
!
! Revision 2.179  2015/05/28 18:25:16  vsnyder
! Eliminate shared HGrid, get PointQuantityToHGrid from QuantityTemplates
!
! Revision 2.178  2015/03/28 02:29:39  vsnyder
! Added P_MustBeGeocalt, Coordinate, NoCrossTrack, Stacked, xGridIndex,
! xGrid, noCrossTrack, tracing, scGeodLat, scLon.  Support cross-track grids.
! Use Get_Boolean from More_Tree.  Added truncate field to Forge command --
! maybe should have been called "save" -- to save any geolocations gotten
! from L1BOA.  Deleted Azimuth.  Deleted mustBeZeta requirement of
! magnetic field (because we now use height for the vertical coordinate).
! Support for 3-d GeodLat and Lon.
!
! Revision 2.177  2014/09/05 00:39:49  vsnyder
! Add some tracing
!
! Revision 2.176  2014/04/24 23:58:21  pwagner
! If hGrid supplied, use it to set horizontalCoordinate
!
! Revision 2.175  2014/04/07 18:01:12  pwagner
! Added new quantity type AscDescMode
!
! Revision 2.174  2013/09/24 23:47:22  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.173  2013/08/17 00:23:35  pwagner
! New cmdline arg relaxes some for non-Aura l1b datasets
!
! Revision 2.172  2013/07/25 00:23:00  vsnyder
! Add MIFRHI quantity type
!
! Revision 2.171  2013/07/19 01:21:49  vsnyder
! Sort some stuff, turn off the first time flag so that InitQuantityTemplates
! is not done on every call.
!
! Revision 2.170  2013/07/18 01:12:11  vsnyder
! Remove scVel since it's ambiguous whether it's ECI or ECR, and nobody
! uses it anyway.
!
! Revision 2.169  2013/05/31 00:42:35  vsnyder
! Get geolocation if requested for L1B fill
!
! Revision 2.168  2013/05/21 23:52:47  vsnyder
! Add MIFExtinctionExtrapolation and MIFExtinctionForm
!
! Revision 2.167  2013/02/21 21:37:10  pwagner
! New optional arg mafwise to return anysignaldata maf-by-maf
!
! Revision 2.166  2012/01/05 01:20:47  pwagner
! Capitalized USEd stuff
!
! Revision 2.165  2011/12/21 01:40:57  vsnyder
! Add LowestRetrievedPressure, MIFExtinction[v2], and a description of the
! DefineQtyTypes table.
!
! Revision 2.164  2011/08/20 00:49:05  vsnyder
! Remove unused use names
!
! Revision 2.163  2011/05/09 18:05:32  pwagner
! Converted to using switchDetail
!
! Revision 2.162  2010/04/05 17:40:55  honghanh
! Fixed bug introduced by making filedatabase optional
!
! Revision 2.160  2010/03/31 19:59:55  honghanh
! Removing l_geodAltitude quantityType as there is l_tngtgeodaltitude
! quantityType already
!
! Revision 2.159  2010/03/24 17:35:13  honghanh
! Just a note to fix ConstructMinorFrameQuantity
!
! Revision 2.158  2010/03/09 22:44:08  honghanh
! Remove cfm_CreateQtyTemplate, set InitQuantityTemplate, and previously private constants to public
!
! Revision 2.157  2010/03/09 22:40:50  honghanh
! Change to support cfm creation of quantity template
!
! Revision 2.156  2010/03/05 20:17:51  honghanh
! Put ConstructMajorFrameQuantity to the list of public subroutine
!
! Revision 2.155  2010/03/02 01:09:20  pwagner
! Added geodAltitude as a quantity type
!
! Revision 2.154  2010/02/04 23:12:44  vsnyder
! Remove USE or declaration for unreferenced names
!
! Revision 2.153  2010/01/23 01:02:37  vsnyder
! Remove LogIWC
!
! Revision 2.152  2009/09/25 02:40:28  vsnyder
! Add badValue to specify badValue field, keepChannels to allocate a
! channels(:) pointer and save the channels output from Parse_Signal
!
! Revision 2.151  2009/09/22 17:02:31  pwagner
! NAG complained of too many continuation statements
!
! Revision 2.150  2009/09/19 00:33:44  vsnyder
! Add LogIWC
!
! Revision 2.149  2009/06/23 18:46:18  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.148  2009/03/14 02:44:46  honghanh
! Add dnwt_count and dnwt_abandoned
!
! Revision 2.147  2008/10/03 16:39:42  livesey
! Added EXTINCTIONV2
!
! Revision 2.146  2008/09/30 22:34:19  vsnyder
! Remove AuxGrid and an unnecessary dump routine
!
! Revision 2.145  2008/08/22 01:04:18  vsnyder
! Don't allow multiple AuxGrids fields
!
! Revision 2.144  2008/06/06 01:58:31  vsnyder
! Make Aux grids VGrids, define ScatteringAngle grid type
!
! Revision 2.143  2008/06/05 20:00:45  vsnyder
! auxGrid never required
!
! Revision 2.142  2008/06/05 02:14:29  vsnyder
! Added AuxGrid field to Quantity.  Defined CloudTemperature and TScat types.
!
! Revision 2.141  2008/05/28 21:03:58  pwagner
! New quantity type to hold chunk number[maf]
!
! Revision 2.140  2008/04/26 00:39:46  livesey
! Added total power stuff
!
! Revision 2.139  2007/03/08 01:33:33  pwagner
! We should never use undefined values for surfs even if no vgrid
!
! Revision 2.138  2007/01/24 02:17:29  vsnyder
! Add TARGET attribute for MifGeolocation to prevent dangling pointer
!
! Revision 2.137  2007/01/11 20:44:27  vsnyder
! Add SurfaceHeight
!
! Revision 2.136  2006/10/02 23:05:31  pwagner
! May Fill chi^2 ratio to measure convergence
!
! Revision 2.135  2006/08/11 20:36:24  vsnyder
! Add INTENT(IN) to MIFGeolocation
!
! Revision 2.134  2006/08/04 20:52:20  pwagner
! Restore quantity name (if clobbered by SetUp..)
!
! Revision 2.133  2006/08/03 01:57:42  vsnyder
! Make sure qty%name is defined
!
! Revision 2.132  2006/07/20 23:39:53  vsnyder
! Remove unused declarations and USEs
!
! Revision 2.131  2006/06/01 03:06:46  vsnyder
! Define numGrad and numNewt
!
! Revision 2.130  2006/04/11 23:32:08  pwagner
! Fixed bug which added excess profiles
!
! Revision 2.129  2006/03/04 00:18:02  pwagner
! AnyGoodSignalData made public
!
! Revision 2.128  2006/01/11 18:00:12  pwagner
! Consistent with new abstract phys quant colmAbundance
!
! Revision 2.127  2005/09/14 00:13:30  pwagner
! Uses ChunkDivideConfig%allowPriorOverlaps in calculating qty%noInstancesLowerOverlap
!
! Revision 2.126  2005/09/02 21:57:23  vsnyder
! Add spectroscopy parameter quantities
!
! Revision 2.125  2005/08/09 00:03:04  pwagner
! hdfVersion not left undefined in AnyGoodSignalData
!
! Revision 2.124  2005/08/04 02:59:54  vsnyder
! Correct definitions for L1BMIF_TAI and MIFDeadTime
!
! Revision 2.123  2005/08/03 18:08:35  vsnyder
! Add L1BMIF_TAI and MifDeadTime for scan averaging
!
! Revision 2.122  2005/06/03 02:05:29  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! get VGrids from VGridsDatabase instead of passing as an argument.
!
! Revision 2.121  2005/06/01 17:39:26  pwagner
! Dont read L1bFile if unassocated
!
! Revision 2.120  2005/05/31 17:51:17  pwagner
! Began switch from passing file handles to passing MLSFiles
!
! Revision 2.119  2005/01/07 01:03:19  vsnyder
! Remove unused declarations
!
! Revision 2.118  2004/10/16 17:25:55  livesey
! Added signalOptional property and more flexible handling of baseline
!
! Revision 2.117  2004/10/13 02:24:33  livesey
! Added ability to set altitude in forge
!
! Revision 2.116  2004/09/27 20:11:05  livesey
! Added L1BMAFBaseline
!
! Revision 2.115  2004/08/26 18:51:03  pwagner
! Failsafe feature for shared fgrids
!
! Revision 2.114  2004/08/16 23:42:54  livesey
! Added p_flexibleVHGrid in order to allow minor frame dependent
! baselines.
!
! Revision 2.113  2004/06/29 00:09:25  pwagner
! New phaseTiming type
!
! Revision 2.112  2004/06/21 23:58:40  pwagner
! numJ also mad e diagnostic qty that may be written to dgm file
!
! Revision 2.111  2004/06/17 23:17:00  pwagner
! Retrieval diagnostics freed from need to be l2gp
!
! Revision 2.110  2004/05/19 19:16:09  vsnyder
! Move MLSChunk_t to Chunks_m
!
! Revision 2.109  2004/04/16 00:48:52  livesey
! Added singleChannelRadiance type
!
! Revision 2.108  2004/03/17 17:16:25  livesey
! New cloudMinMax type.
!
! Revision 2.107  2004/02/10 21:17:24  livesey
! Added status and quality as valid quantity types
!
! Revision 2.106  2004/01/24 01:03:46  livesey
! Added the adopted option etc.
!
! Revision 2.105  2003/08/08 23:06:53  livesey
! Added the fieldStrength etc. quantities.
!
! Revision 2.104  2003/07/07 20:22:37  livesey
! Minor bug fix in minor frame quantities
!
! Revision 2.103  2003/07/01 23:18:04  livesey
! Added setting of grandTotalInstances for minor frame quantities.
!
! Revision 2.102  2003/07/01 19:29:32  livesey
! Added filling of grandTotalInstances
!
! Revision 2.101  2003/06/27 00:07:07  pwagner
! Made print offset depend on qtmp switch; restored some logs
!
! (logging disabled from Rev. 2.92-2.100)
! Revision 2.91  2003/05/22 04:04:07  livesey
! elevOffset is now a channel dependent rather than radiometer dependent
! quantity.
!
! Revision 2.90  2003/05/10 23:39:25  livesey
! Fixed problems with chisqs and noRads
!
! Revision 2.89  2003/05/07 01:00:03  livesey
! More stuff got missed in the merge, was I asleep or something?
!
! Revision 2.88  2003/02/13 19:05:39  vsnyder
! Move USEs from module to procedure scope, cosmetic changes
!
! Revision 2.87  2003/02/12 21:53:48  pwagner
! Fix to errant ANY_GOOD_SIGNALDATA in case of hdf5 files
!
! Revision 2.86  2003/02/07 03:42:50  vsnyder
! Fill NATURAL_UNITS on first call only -- it's a SAVE variable now
!
! Revision 2.85  2003/02/07 03:38:05  vsnyder
! Cosmetic change
!
! Revision 2.84  2003/02/07 00:41:41  livesey
! Bug fix/workaround
!
! Revision 2.83  2003/02/06 23:31:00  livesey
! New approach to Forge
!
! Revision 2.82  2003/01/14 00:40:29  pwagner
! Moved GetQuantityAttributes to L2AUXData
!
! Revision 2.81  2003/01/09 00:09:15  pwagner
! routine GetQuantityAttributes added
!
! Revision 2.80  2003/01/08 23:50:44  livesey
! Added irregular argument
!
! Revision 2.79  2003/01/07 23:46:53  livesey
! Added magnetic field stuff
!
! Revision 2.78  2002/12/11 22:17:05  pwagner
! Added error checks on hdf version
!
! Revision 2.77  2002/11/26 23:37:50  livesey
! Better handling of major frame quantities
!
! Revision 2.76  2002/11/22 12:16:08  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.75  2002/11/13 01:05:03  pwagner
! Actually reads hdf5 radiances
!
! Revision 2.74  2002/10/08 17:36:19  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.73  2002/09/26 18:03:06  livesey
! Changed extinction to a vmr
!
! Revision 2.72  2002/09/25 20:07:55  livesey
! Made -g less verbose
!
! Revision 2.71  2002/09/24 21:37:44  livesey
! Added minValue stuff
!
! Revision 2.70  2002/09/24 00:27:16  pwagner
! Wont bomb if no l1brads; nor whine if no good signals
!
! Revision 2.69  2002/09/18 22:48:32  pwagner
! Chooses signals first band with any good data
!
! Revision 2.68  2002/08/04 16:01:19  mjf
! Added some nullify statements for Sun's rubbish compiler.
!
! Revision 2.67  2002/06/14 16:39:49  livesey
! Orbital inclination now minor frame
!
! Revision 2.66  2002/06/04 22:07:35  livesey
! Added phiTan as a state vector element
!
! Revision 2.65  2002/05/22 19:06:32  jonathan
! added units for cloudextinction(m-1), totalextinction(m-1), and
! massmeandiameterice(micron m) as dimentionless for now, may define
! more clear later
!
! Revision 2.64  2002/05/14 00:27:42  livesey
! New code for system temperatures and noise bandwidths
!
! Revision 2.63  2002/05/07 20:02:54  livesey
! Added noise bandwidth
!
! Revision 2.62  2002/04/10 17:44:22  pwagner
! Added rhi quantity (but is this enough?)
!
! Revision 2.61  2002/03/19 00:51:32  pwagner
! Added new scVel quantity types
!
! Revision 2.60  2002/02/09 21:35:52  livesey
! Added optical depth stuff
!
! Revision 2.59  2001/11/08 00:13:38  livesey
! Sorted out extinction stuff
!
! Revision 2.58  2001/10/31 19:07:25  livesey
! Added fGrid stuff
!
! Revision 2.57  2001/10/12 23:15:05  pwagner
! Fixed biggest erros in diagnostic quantity templates
!
! Revision 2.56  2001/10/02 23:12:50  pwagner
! More chi^2 fixes
!
! Revision 2.55  2001/10/02 20:50:54  livesey
! No longer asserts baseline to be minor frame
!
! Revision 2.54  2001/09/17 23:11:50  pwagner
! Tiny changes for chi^2
!
! Revision 2.53  2001/09/17 21:58:50  livesey
! Added allocate of frequencies if needed
!
! Revision 2.52  2001/09/14 23:30:33  pwagner
! Now constructs major frame quantity templates
!
! Revision 2.51  2001/08/01 00:04:29  dwu
! add qty%frequencies = VGrids(sGridIndex)%surfs for quantity l_losTransFunc
!
! Revision 2.50  2001/07/30 23:28:38  pwagner
! Added columnAbundances scaffolding--needs fleshing out
!
! Revision 2.49  2001/07/26 17:34:25  jonathan
! add DTcir, etc, jonathan
!
! Revision 2.48  2001/07/19 22:17:44  jonathan
! add cloud stuff , jonathan/dwu
!
! Revision 2.47  2001/07/19 17:42:31  dwu
! add sGrid field
!
! Revision 2.46  2001/07/18 23:17:30  dwu
! rename l_radiusofearth as l_earthradius
!
! Revision 2.45  2001/07/18 18:42:19  dwu
! add radiusofearth quantity type
!
! Revision 2.44  2001/07/17 23:23:05  dwu
! make l_losTransFunc as non-minorframe but minorframe-like quantity
!
! Revision 2.43  2001/07/16 18:24:45  dwu
! add feature for losTransFunc type of quantities
!
! Revision 2.42  2001/07/13 18:41:59  dwu
! fix problem after adding losTransFunc
!
! Revision 2.41  2001/07/13 18:10:03  dwu
! add quantity losTransFunc
!
! Revision 2.40  2001/07/11 21:40:00  livesey
! More bug fixes
!
! Revision 2.39  2001/07/10 23:45:16  jonathan
! added cloudicedensity and template for cloudsfwm, paul/jonathan
!
! Revision 2.38  2001/07/09 22:37:23  livesey
! Embarassing memory leak caught!  It's our old friend
! mifGeolocation again.  I'm going to regret trying
! to be this clever!
!
! Revision 2.37  2001/05/31 19:53:56  livesey
! Whoops, debug stuff left in.
!
! Revision 2.36  2001/05/30 23:59:51  livesey
! Thought I'd made this change already.  I'm confused
!
! Revision 2.35  2001/05/30 23:55:28  livesey
! Previous one was debug version, this is correct one.
!
! Revision 2.34  2001/05/30 23:53:01  livesey
! For new version of L1Bdata
!
! Revision 2.33  2001/05/29 23:21:35  livesey
! Changed l_orbitincline to l_orbitinclination
!
! Revision 2.32  2001/05/26 00:20:20  livesey
! Cosmetic changes
!
! Revision 2.31  2001/05/10 01:08:53  livesey
! Changed hGrids and vGrids to pointers, rather than intent(in)
! to allow them to be empty.
!
! Revision 2.30  2001/05/03 23:08:36  livesey
! Added stuff to support scan model items.
!
! Revision 2.29  2001/05/03 20:30:09  vsnyder
! Add a 'nullify' and some cosmetic changes
!
! Revision 2.28  2001/04/26 02:45:25  vsnyder
! Fix up CVS stuff
!
! Revision 2.27  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.26  2001/04/25 20:33:07  livesey
! Minor bug fix, Forge now also zeros surfs.
!
! Revision 2.25  2001/04/25 19:29:49  livesey
! Fixed bug in forge, now sets mafCounter and mafIndex correctly.
!
! Revision 2.24  2001/04/25 00:01:23  livesey
! Bug fix, no default units for scGeocAlt
!
! Revision 2.23  2001/04/24 22:21:17  livesey
! Gave up on latitude for forge
!
! Revision 2.22  2001/04/23 23:25:10  livesey
! Fixed bug in forge
!
! Revision 2.21  2001/04/20 23:11:39  livesey
! Added forge stuff for minor frames
!
! Revision 2.20  2001/04/19 20:30:06  livesey
! Added specific stuff for sideband ratio
!
! Revision 2.19  2001/04/12 23:25:29  vsnyder
! Give "Sideband" an initial value
!
! Revision 2.18  2001/04/12 21:41:42  livesey
! Signal now a string.
!
! Revision 2.17  2001/04/10 22:27:47  vsnyder
! Nullify explicitly instead of with <initialization> so as not to give
! pointers the SAVE attribute.  <initialization> is NOT executed on each
! entry to a procedure.
!
! Revision 2.16  2001/04/07 01:50:48  vsnyder
! Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
! some related stuff to fwdmdl/ForwardModelConfig.
!
! Revision 2.15  2001/03/28 23:48:13  livesey
! Bug fixes zero out some stuff.
!
! Revision 2.14  2001/03/28 18:33:19  livesey
! Fixed bug with logBasis (wasn't initialised!)
!
! Revision 2.13  2001/03/21 02:13:30  livesey
! Bug with logBasis, put in a work around. Will need to fix later
!
! Revision 2.12  2001/03/17 02:23:55  livesey
! Added logBasis (and set value for badData)
!
! Revision 2.11  2001/03/15 21:07:47  vsnyder
! Cross-references between databases are by database index, not tree index
!
! Revision 2.10  2001/03/15 18:41:17  livesey
! Tidied up the frequency coordinate stuff.
!
! Revision 2.9  2001/03/08 21:49:26  livesey
! Added elev_offset
!
! Revision 2.8  2001/03/03 00:08:09  livesey
! Lots of changes mostly with minor frame quantities
!
! Revision 2.7  2001/03/02 01:28:23  livesey
! New quantity types etc.
!
! Revision 2.6  2001/02/28 01:17:04  livesey
! Interim version, on the way to using proper signals stuff
!
! Revision 2.5  2001/02/22 23:37:24  livesey
! Really removed all references to firstIndexChannel
!
! Revision 2.4  2001/02/21 01:09:00  livesey
! Allowed for quantities with no h/v grid
!
! Revision 2.3  2001/02/20 18:43:50  livesey
! Removed all references to firstIndexChannel
!
! Revision 2.2  2001/02/14 00:12:45  livesey
! Removed firstIndexChannel
!
! Revision 2.1  2001/02/09 00:38:22  livesey
! Various updates
!
! Revision 2.0  2000/09/05 18:57:02  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:03  vsnyder
! Initial entry
!
! Revision 1.13  2000/05/17 23:19:07  lungu
! Added "." between MLSInstrumentModuleNames and l1bItemName.
! Made hGridIndex=0 and vGridIndex=0 upon entry, so it does not "inherit" attributes from previous call.
! Made caseInsensitive=.TRUE. for all searches.
! Added type for QTY_Gph.
! Made stacked=.TRUE. so that CopyHGridInfoIntoQuantity works.
!
@


2.208
log
@Worked around the error that made instrumentModuleName allcaps
@
text
@d1292 1
a1292 1
      l_cloudtemperature, l_cloudwater, l_columnabundance, &
d1373 1
d1610 1
a1610 1
       "$Id: ConstructQuantityTemplates.f90,v 2.207 2018/04/11 17:47:05 pwagner Exp $"
d1620 3
@


2.207
log
@Should work better with ASMLS mif geolocations
@
text
@d633 4
d806 5
a810 2
          l1bItemName = trim(instrumentModuleName)//'.'//L1bItemsToRead(l1bItem)%name
          if ( verboser ) call outputnamedValue ( 'before assembly', trim(l1bItemName) )
d816 2
a817 1
          if ( verboser ) call outputnamedValue ( 'before assembly', trim(l1bItemName) )
d820 1
a820 1
            & instrumentModuleName )
d1609 1
a1609 1
       "$Id: ConstructQuantityTemplates.f90,v 2.206 2018/02/23 22:04:45 mmadatya Exp $"
d1619 3
@


2.206
log
@Added l_instECR for ASMLS
@
text
@d579 2
a580 1
      logical :: Modular = .true.
d592 9
a600 9
      & item_t(scGeodLat,       "scGeodLat      ", .false.), & ! Not tangent qty
      & item_t(scLon,           "scLon          ", .false.), & ! Not tangent qty
      & item_t(MAFStartTimeTAI, "MAFStartTimeTAI", .false.), & ! Not tangent qty
      & item_t(tpGeodLat,       "tpGeodLat      "), &
      & item_t(tpLon,           "tpLon          "), &
      & item_t(tpGeodAngle,     "tpGeodAngle    "), &
      & item_t(tpSolarZenith,   "tpSolarZenith  "), &
      & item_t(tpSolarTime,     "tpSolarTime    "), &
      & item_t(tpLosAngle,      "tpLosAngle     ") /)
d630 1
d795 3
a797 1
        if ( L1bItemsToRead(l1bItem)%modular ) then
d801 4
a804 2
            & call GetModuleName ( instrumentModule+1, l1bItemName )
          l1bItemName = trim(l1bItemName)//'.'//L1bItemsToRead(l1bItem)%name
d809 4
d816 1
a816 3
        if ( verboser ) call outputnamedValue ( 'before assembly', trim(l1bItemName) )
        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        if ( verboser ) call outputnamedValue ( 'l1bItemName#2', trim(l1bItemName) )
d1601 1
a1601 1
       "$Id: ConstructQuantityTemplates.f90,v 2.205 2017/12/15 18:43:56 mmadatya Exp $"
d1611 3
@


2.205
log
@Added geoHeight as new quantity template
@
text
@d1301 1
a1301 1
      l_scanresidual, l_scatteringangle, l_sceci, l_scecr, l_scveleci, &
d1457 1
d1593 1
a1593 1
       "$Id: ConstructQuantityTemplates.f90,v 2.204 2017/10/27 01:29:46 vsnyder Exp $"
d1603 3
@


2.204
log
@Remove L_MIFLOS
@
text
@d1297 1
a1297 1
      l_opticaldepth, l_orbitinclination, l_ascdescmode, &
d1442 1
d1592 1
a1592 1
       "$Id: ConstructQuantityTemplates.f90,v 2.203 2017/06/01 22:49:15 vsnyder Exp $"
d1602 3
@


2.203
log
@Remove unused USE names
@
text
@d1293 1
a1293 1
      l_mifExtinctionform, l_mifExtinctionv2, l_mifLOS, &
d1304 1
a1304 1
      l_temperature, l_tngteci, l_tngtgeodalt, l_tngtgeocalt, &
d1425 1
a1425 1
      l_mifLOS, phyq_length, p_minorFrame, p_module, next, &
d1471 1
d1591 1
a1591 1
       "$Id: ConstructQuantityTemplates.f90,v 2.202 2016/11/04 23:05:48 pwagner Exp $"
d1601 3
@


2.202
log
@Define some potentially undefined qty components
@
text
@d86 1
a86 1
      & l_phitan, l_true, l_xyz, l_zeta, lit_indices
d97 1
a97 1
    use string_table, only: get_string, display_string
d536 1
a536 1
    use chunks_m, only: MLSChunk_t
d539 2
a540 2
    use highOutput, only: BeVerbose, LetsDebug, outputNamedValue
    use init_tables_module, only: l_geodaltitude, l_none, lit_indices
d542 1
a542 1
      & assemblel1bqtyname
d545 1
a545 1
    use MLSFiles, only: HDFVersion_5, Dump, getMLSFileByType
d549 8
a556 8
    use MLSSignals_m, only:  Dump_Modules, getModuleName, &
      & isAnyModuleSpacecraft, isModuleSpacecraft
    use output_m, only: output
    use quantityTemplates, only: quantityTemplate_t, &
      & dump, setupNewQuantityTemplate
    use string_table, only: display_string
    use toggles, only: gen, levels, toggle
    use trace_m, only: trace_begin, trace_end
d1590 1
a1590 1
       "$Id: ConstructQuantityTemplates.f90,v 2.201 2016/10/20 23:13:39 pwagner Exp $"
d1600 3
@


2.201
log
@When warning of missing GeodAlt, say how big we set numMAFs
@
text
@d80 1
d155 1
d171 1
d442 2
d643 1
a643 1

d665 1
d694 1
a709 2
          call GetAllHDF5DSNames ( L1BFile%name, '/', DSNames )
          call Dump ( DSNames, 'DSNames' )
d711 2
d715 1
a715 1
            & noSurfs=l1bField%maxMIFs, noChans=noChans, &
d717 1
a717 1
            & stacked=.false., regular=regular, instanceLen=instanceLen, &
d721 1
d867 1
a867 1
       call MLSMessage ( MLSMSG_Error, ModuleName, &
d1590 1
a1590 1
       "$Id: ConstructQuantityTemplates.f90,v 2.200 2016/10/14 00:05:46 pwagner Exp $"
d1600 3
@


2.200
log
@Show qty name, too, when verbosely Constructing its template
@
text
@d707 1
a707 1
            & noInstances=chunk%lastMAFIndex-chunk%firstMAFIndex +1, &
d712 2
d1582 1
a1582 1
       "$Id: ConstructQuantityTemplates.f90,v 2.199 2016/09/21 00:41:32 pwagner Exp $"
d1592 3
@


2.199
log
@Default to printing less
@
text
@d85 1
a85 1
      & l_phitan, l_true, l_xyz, l_zeta
d96 1
a96 1
    use string_table, only: get_string
d535 1
a535 1
    use init_tables_module, only: l_geodaltitude, l_none
d549 1
d627 4
d1580 1
a1580 1
       "$Id: ConstructQuantityTemplates.f90,v 2.198 2016/08/12 00:33:05 pwagner Exp $"
d1590 3
@


2.198
log
@Seems to restore tthe gold brick
@
text
@d675 1
a675 1
      if ( verbose ) then
d723 1
a723 1
      if ( verbose ) then
d791 1
a791 1
        if ( verbose ) call outputnamedValue ( 'before assembly', trim(l1bItemName) )
d793 1
a793 1
        if ( verbose ) call outputnamedValue ( 'l1bItemName#2', trim(l1bItemName) )
d1575 1
a1575 1
       "$Id: ConstructQuantityTemplates.f90,v 2.197 2016/08/09 21:51:57 pwagner Exp $"
d1585 3
@


2.197
log
@Survives encounter with non-satellite data
@
text
@d540 1
a540 1
    use MLSFiles, only: Dump, getMLSFileByType
d683 28
a710 27

      ! OK, so what if GeodAlt isn't here?
      ! 2nd bet: 
      if ( .not. IsHDF5DSPresent( L1BFile, trim(l1bItemName) ) ) &
        & l1bItemName = AssembleL1BQtyName ( 'tpGeodAlt', HDFVersion, &
        & .true., instrumentModuleName )
      if ( .not. IsHDF5DSPresent( L1BFile, trim(l1bItemName) ) ) then

        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & "Will not know number of mafs; unable to find " &
          & // trim(l1bItemName) )
        call Dump ( L1BFile, details=2 )
        ! call Dump ( filedatabase, details=2 )
        call GetAllHDF5DSNames ( L1BFile, DSNames )
        call Dump ( DSNames, 'DSNames' )
        call GetAllHDF5DSNames ( L1BFile%name, '/', DSNames )
        call Dump ( DSNames, 'DSNames' )
        qty%name = 0
        call SetupNewQuantityTemplate ( qty, &
          & noInstances=chunk%lastMAFIndex-chunk%firstMAFIndex +1, &
          & noSurfs=l1bField%maxMIFs, noChans=noChans, &
          & noCrossTrack=noCrossTrack, coherent=.false., &
          & stacked=.false., regular=regular, instanceLen=instanceLen, &
          & minorFrame=.true., verticalCoordinate=qty%verticalCoordinate )
        call trace_end ( "ConstructMinorFrameQuantity", &
          & cond=toggle(gen) .and. levels(gen) > 2 )
        return
d1575 1
a1575 1
       "$Id: ConstructQuantityTemplates.f90,v 2.196 2016/07/28 19:56:00 pwagner Exp $"
d1585 3
@


2.196
log
@Extra care in CConstructMinorFrameQs
@
text
@d533 1
d540 2
a541 1
    use MLSFiles, only: getMLSFileByType
d598 2
a599 1

d624 1
d627 1
a627 2
      call GetModuleName ( instrumentModule, l1bItemName )
      call outputnamedValue( 'instrumentModule name', trim(l1bItemName) )
d659 1
a659 1
      ! First we read xxGeodalt to get the number of MAFs, and the surfs
d684 27
d841 7
a847 2
        if ( verboser ) call dump( l1bField%dpField(1,:,:) )

d1574 1
a1574 1
       "$Id: ConstructQuantityTemplates.f90,v 2.195 2016/07/28 00:42:46 vsnyder Exp $"
d1584 3
@


2.195
log
@Remove unused USE
@
text
@d542 1
a542 1
    use MLSSignals_m, only:  getModuleName, &
d621 5
d674 1
d678 1
d743 1
d746 1
d748 1
d750 2
d760 1
d1539 1
a1539 1
       "$Id: ConstructQuantityTemplates.f90,v 2.194 2016/07/27 23:03:44 pwagner Exp $"
d1549 3
@


2.194
log
@Works better with Aircraft-borne instrument data
@
text
@a79 1
    use highOutput, only: outputNamedValue
a85 1
    use intrinsic, only: phyq_indices
d91 1
a91 1
      & isAnyModuleSpacecraft, isModuleSpacecraft
d534 1
a534 1
    use init_tables_module, only: l_geocaltitude, l_geodaltitude, l_none
a538 1
    use MLSL2options, only: aura_L1BFiles
a543 1
    use MLSStringLists, only: switchDetail
d547 1
a547 1
    use toggles, only: gen, levels, switches, toggle
a1480 1
    use Pointer_Rank_Remapping, only: remap
d1526 1
a1526 1
       "$Id: ConstructQuantityTemplates.f90,v 2.193 2016/07/25 23:41:53 pwagner Exp $"
d1536 3
@


2.193
log
@Avoid reading l1b s/c fields if no module is s/c
@
text
@d787 5
a791 1
          qty%phi = l1bField%dpField(1,:,:)
d1531 1
a1531 1
       "$Id: ConstructQuantityTemplates.f90,v 2.192 2016/07/21 20:28:54 pwagner Exp $"
d1541 3
@


2.192
log
@Now remembers to call trace_end before returning from a failed l1b read
@
text
@d78 1
a78 1
    use fgrid, only: fgrid_t
d80 1
a80 1
    use highoutput, only: outputnamedvalue
d92 2
a93 1
      & getRadiometerFromSignal, getSignal, signal_t, isModuleSpacecraft
d545 2
a546 1
    use MLSSignals_m, only:  isModuleSpacecraft, getModuleName
d659 4
d672 2
d745 2
d753 1
a753 1
        if ( verbose ) call outputnamedValue ( 'l1bItemName', trim(l1bItemName) )
d1527 1
a1527 1
       "$Id: ConstructQuantityTemplates.f90,v 2.191 2016/05/27 20:59:04 vsnyder Exp $"
d1537 3
@


2.191
log
@Remove l_mifIncline and l_mifTanHt because they are redundant to
l_OrbitInclination and l_tngtGeodAlt
@
text
@d704 5
a708 1
      if ( l1bFlag /= 0 ) return
d1517 1
a1517 1
       "$Id: ConstructQuantityTemplates.f90,v 2.190 2016/05/27 01:24:07 vsnyder Exp $"
d1527 4
@


2.190
log
@Add L_mifTanHt
@
text
@d1215 2
a1216 2
      l_mifExtinctionform, l_mifExtinctionv2, l_mifIncline, l_mifLOS, &
      l_mifRadC, l_mifRHI, l_mifTanHt, &
d1235 3
a1237 3
    use Intrinsic, only: LIT_INDICES
    use Output_M, only: output
    use String_Table, only: display_string
d1241 3
a1243 3
    integer, dimension(1:0), parameter :: NONE = (/ ( 0, i=1,0 ) /)
    logical :: VALID                    ! Flag
    character(len=132) :: MESSAGE       ! An error message
a1346 1
      l_mifIncline, phyq_length, p_minorFrame, p_module, next, &
a1350 1
      l_mifTanHt, phyq_length, p_minorFrame, p_module, next, &
d1513 1
a1513 1
       "$Id: ConstructQuantityTemplates.f90,v 2.189 2016/05/24 01:26:01 vsnyder Exp $"
d1523 3
@


2.189
log
@Add mifIncline, mifLOS, mifRadC
@
text
@d1216 1
a1216 1
      l_mifRadC, l_mifRHI, &
d1352 1
d1515 1
a1515 1
       "$Id: ConstructQuantityTemplates.f90,v 2.188 2016/05/18 01:37:30 vsnyder Exp $"
d1525 3
@


2.188
log
@Change HGrids database from an array of HGrid_T to an array of pointers
to HGrid_T using the new type HGrids_T.
@
text
@d1215 2
a1216 1
      l_mifextinctionform, l_mifextinctionv2, l_mifrhi, &
d1347 3
d1514 1
a1514 1
       "$Id: ConstructQuantityTemplates.f90,v 2.187 2016/05/04 18:31:39 pwagner Exp $"
d1524 4
@


2.187
log
@Requires -Sqtmp1 to dump l1b arrays when constructing minor fram qty
@
text
@d79 1
a79 1
    use hgridsdatabase, only: hgrid_t
d108 1
a108 1
    type (HGrid_T), dimension(:), pointer :: HGrids
d279 1
a279 1
        if ( hGrids(xGridIndex)%type /= l_explicit ) &
d281 1
a281 1
        noCrossTrack = size(hgrids(xGridIndex)%phi)
d395 1
a395 1
        & horizontalCoordinate = HGrids(hGridIndex)%masterCoordinate
d416 1
a416 1
      if ( got ( f_hGrid ) ) noInstances = hGrids(hGridIndex)%noProfs
d428 1
a428 1
        qty%the_hGrid => hGrids(hGridIndex)
d443 1
a443 1
          !     & hGrids(hGridIndex)%noProfsLowerOverlap
d446 1
a446 1
          !     & hGrids(hGridIndex)%noProfsUpperOverlap
d468 3
a470 3
      call allocate_test ( qty%crossAngles, size(hGrids(xGridIndex)%phi,2), &
        & 'qty%crossAngles', moduleName )
      qty%crossAngles = hGrids(xGridIndex)%phi(1,:)
d1510 1
a1510 1
       "$Id: ConstructQuantityTemplates.f90,v 2.186 2015/09/25 02:16:20 vsnyder Exp $"
d1520 3
@


2.186
log
@Preserve the quantity template vertical coordinate.  Read the appropriate
kind of altitude quantity from the L1BOA file, depending on the quantity
template's vertical coordinate.
@
text
@d16 1
a16 1
  use INIT_TABLES_MODULE, only: FIRST_LIT, LAST_LIT
d74 9
a82 9
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use CHUNKS_M, only: MLSCHUNK_T
!   use CHUNKDIVIDE_M, only: CHUNKDIVIDECONFIG
    use EXPR_M, only: EXPR
    use FGRID, only: FGRID_T
    use HGRIDSDATABASE, only: HGRID_T
    use highOutput, only: outputNamedValue
    use init_tables_module, only:  f_badValue, f_coordinate, f_fGrid, f_hGrid, &
      & f_irregular, f_keepChannels, f_logBasis, f_minValue, f_module, &
d85 1
a85 1
      & l_explicit, l_geocAltitude, l_lostransfunc, l_matrix3x3, l_none, &
d88 15
a102 15
    use MLSCOMMON, only: MLSFILE_T
    use MLSKINDS, only: RK => R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
    use MLSSIGNALS_M, only:GETMODULEFROMRADIOMETER, GETMODULEFROMSIGNAL, &
      & GETRADIOMETERFROMSIGNAL, GETSIGNAL, SIGNAL_T, ISMODULESPACECRAFT
    use MoreTree, only: Get_Boolean
    use PARSE_SIGNAL_M, only: PARSE_SIGNAL
    use QUANTITYTEMPLATES, only: NULLIFYQUANTITYTEMPLATE, PointQuantityToHGrid, &
      & QUANTITYTEMPLATE_T, SETUPNEWQUANTITYTEMPLATE
    use STRING_TABLE, only: GET_STRING
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NODE_ID, NSONS, SUB_ROSA, SUBTREE
    use TREE_TYPES, only: N_SET_ONE
    use VGRIDSDATABASE, only: VGRIDS
d528 1
a528 1
  subroutine ConstructMinorFrameQuantity (instrumentModule, &
d532 1
a532 1
    use CHUNKS_M, only: MLSCHUNK_T
d535 16
a550 16
    use INIT_TABLES_MODULE, only: L_GeocAltitude, L_GeodAltitude, L_None
    use L1BDATA, only: L1BDATA_T, READL1BDATA, DEALLOCATEL1BDATA, &
      & ASSEMBLEL1BQTYNAME
    use MLSCOMMON, only: MLSFILE_T, NAMELEN
    use MLSKINDS, only: RK => R8
    use MLSL2OPTIONS, only: AURA_L1BFILES
    use MLSFILES, only: GETMLSFILEBYTYPE
    use MLSMESSAGEMODULE, only: MLSMESSAGE, &
      & MLSMSG_ERROR, MLSMSG_L1BREAD, MLSMSG_WARNING
    use MLSSIGNALS_M, only:  ISMODULESPACECRAFT, GETMODULENAME
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use OUTPUT_M, only: OUTPUT
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, &
      & Dump, SETUPNEWQUANTITYTEMPLATE
    use TOGGLES, only: Gen, Levels, SWITCHES, Toggle
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d784 1
a784 1
        if ( verbose ) call dump( l1bField%dpField(1,:,:) )
d812 7
a818 7
    use EXPR_M, only: EXPR
    use INIT_TABLES_MODULE, only: F_GEODALT, F_GEODANGLE, F_MODULE, F_NOMIFS, &
      & F_SOLARTIME, F_SOLARZENITH, F_Truncate
    use INIT_TABLES_MODULE, only: L_GEODALTITUDE, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, &
      & PHYQ_TIME
    use MLSKINDS, only: RK => R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
d820 1
a820 1
    use QUANTITYTEMPLATES, only: CopyQuantityTemplate, &
d823 2
a824 2
    use TREE, only: DECORATION, NSONS, SUBTREE
    use VGRIDSDATABASE, only: VGRID_T, VGRIDS
d1008 6
a1013 6
    use LEXER_CORE, only: PRINT_SOURCE
    use OUTPUT_M, only: BLANKS, OUTPUT
    use TREE, only: WHERE_AT=>WHERE
    use Intrinsic, only: LIT_INDICES
    use STRING_TABLE, only: DISPLAY_STRING
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
d1055 8
a1062 8
    use CHUNKS_M, only: MLSCHUNK_T
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST
    use L1BDATA, only: L1BDATA_T, READL1BDATA, GETL1BFILE, &
      & ASSEMBLEL1BQTYNAME, PRECISIONSUFFIX
    use MLSCOMMON, only: MLSFILE_T
    use MLSKINDS, only: RK => R8
    use MLSFILES, only: GETMLSFILEBYTYPE
    use MLSSIGNALS_M, only: GETSIGNALNAME
d1116 5
a1120 5
    use CHUNKS_M, only: MLSCHUNK_T
    use QUANTITYTEMPLATES, only: CreateGeolocationFields, QUANTITYTEMPLATE_T, &
      & SETUPNEWQUANTITYTEMPLATE
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d1170 3
a1172 3
    use Intrinsic, only: LIT_INDICES
    use MLSStrings, only: LOWERCASE
    use STRING_TABLE, only: GET_STRING
d1194 40
a1233 39
    use Init_Tables_Module, only:  L_ADOPTED, L_ADOPTED, L_BASELINE, &
      L_BOUNDARYPRESSURE, L_CALSIDEBANDFRACTION, &
      L_CHISQBINNED, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CLOUDICE, &
      L_CLOUDINDUCEDRADIANCE, L_CLOUDEXTINCTION, L_CLOUDMINMAX, L_CLOUDRADSENSITIVITY, &
      L_CLOUDTEMPERATURE, L_CLOUDWATER, L_COLUMNABUNDANCE, &
      L_DNWT_ABANDONED, L_DNWT_AJN, L_DNWT_AXMAX, L_DNWT_CAIT, &
      L_DNWT_CHISQMINNORM, L_DNWT_CHISQNORM, L_DNWT_CHISQRATIO, &
      L_DNWT_COUNT, L_DNWT_DIAG, L_DNWT_DXDX, L_DNWT_DXDXL, &
      L_DNWT_DXN, L_DNWT_DXNL, L_DNWT_FLAG, L_DNWT_FNMIN, &
      L_DNWT_FNORM, L_DNWT_GDX, L_DNWT_GFAC, &
      L_DNWT_GRADN, L_DNWT_SQ, L_DNWT_SQT,&
      L_EARTHRADIUS, L_EARTHREFL, L_ECRTOFOV, L_EFFECTIVEOPTICALDEPTH, &
      L_ELEVOFFSET, L_EXTINCTION, L_EXTINCTIONV2, &
      L_FIELDAZIMUTH, L_FIELDELEVATION, L_FIELDSTRENGTH, &
      L_GEOLOCATION, L_GPH, L_GHzAzim, L_HEIGHTOFFSET, L_ISOTOPERATIO, L_IWC, &
      L_JACOBIAN_COLS, L_JACOBIAN_ROWS, &
      L_L1BMAFBASELINE, L_L1BMIF_TAI, L_LIMBSIDEBANDFRACTION, &
      L_LINECENTER, L_LINEWIDTH, L_LINEWIDTH_TDEP, &
      L_LOSTRANSFUNC, L_LOSVEL, L_LOWESTRETRIEVEDPRESSURE, &
      L_MASSMEANDIAMETERICE, L_MASSMEANDIAMETERWATER, L_MAGNETICFIELD, &
      L_MIFDEADTIME, L_MIFEXTINCTION, L_MIFEXTINCTIONEXTRAPOLATION, &
      L_MIFEXTINCTIONFORM, L_MIFEXTINCTIONV2, L_MIFRHI, &
      L_NOISEBANDWIDTH, L_NORADSPERMIF, L_NORADSBINNED, &
      L_NUMGRAD, L_NUMJ, L_NUMNEWT, &
      L_OPTICALDEPTH, L_ORBITINCLINATION, L_AscDescMode, &
      L_PHASETIMING, L_PHITAN, L_PTAN, L_QUALITY, L_RADIANCE, &
      L_REFGPH, L_REFLTEMP, L_REFLTRANS, L_REFLREFL, L_REFLSPILL, &
      L_RHI, L_SINGLECHANNELRADIANCE, L_SIZEDISTRIBUTION, &
      L_SCANRESIDUAL, L_SCATTERINGANGLE, L_SCECI, L_SCECR, L_SCVELECI, &
      L_SCVELECR, L_SCGEOCALT, L_SPACERADIANCE, L_STATUS, &
      L_STRAYRADIANCE, L_SURFACEHEIGHT, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
      L_TEMPERATURE, L_TNGTECI, L_TNGTGEODALT, L_TNGTGEOCALT, &
      L_TOTALPOWERWEIGHT, L_TSCAT, L_VMR
    use Init_Tables_Module, only: PHYQ_ANGLE, PHYQ_COLMABUNDANCE, &
      & PHYQ_DIMENSIONLESS, PHYQ_EXTINCTION, PHYQ_FREQUENCY,&
      & PHYQ_GAUSS, PHYQ_IceDensity, PHYQ_LENGTH, &
      & PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_TIME, PHYQ_VELOCITY, &
      & PHYQ_VMR, PHYQ_ZETA
    use MLSMessageModule, only: MLSMSG_ERROR, MLSMESSAGE
d1235 2
a1236 2
    use Output_M, only: OUTPUT
    use String_Table, only: DISPLAY_STRING
d1463 2
a1464 2
    use Allocate_Deallocate, only: ALLOCATE_TEST
    use Pointer_Rank_Remapping, only: REMAP
d1510 1
a1510 1
       "$Id: ConstructQuantityTemplates.f90,v 2.185 2015/09/22 01:57:57 vsnyder Exp $"
d1520 5
@


2.185
log
@Add GHzAzim and ScECR quantity types
@
text
@d403 2
a408 2
      if ( got(f_coordinate ) ) qty%verticalCoordinate = coordinate
      qty%quantityType = quantityType
d535 1
a535 1
    use INIT_TABLES_MODULE, only: L_GEODALTITUDE, L_NONE
d600 1
a600 1
    type (MLSFile_T), pointer             :: L1BFile
d605 3
a609 2
    integer :: Start, Stop  ! For reading L1B quantities, depending upon whether
                            ! they're for the instrument or the tangent point
d623 7
a629 2
    if ( present(mifGeolocation) ) then
      ! -------------------------------------- Got mifGeolocation ------------
d649 3
a651 3
      ! ------------------------------------ Not Got mifGeolocation -----
      ! We have no geolocation information, we have to read it ourselves
      ! from the L1BOA file.
d653 1
a653 1
      ! First we read xxGeodalt to get the size of the quantity.
d657 2
a658 1
        l1bItemName = 'scGeocAlt' 
d661 2
a662 1
        l1bItemName = TRIM(l1bItemName) // "." // "tpGeodAlt"
d691 1
a691 1
        & minorFrame=.true. )
a710 1
        qty%surfs = 0.0
d719 1
d721 3
a723 19
        call GetModuleName ( instrumentModule, l1bItemName )
        l1bItemName = TRIM(l1bItemName) // "." // "tpGeodAlt"

        l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
        call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
          & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & neverfail=MissingOK )
        if ( l1bFlag /= 0 .and. .not. MissingOK ) then
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_L1BRead//l1bItemName )
        elseif ( l1bFlag /= 0 ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & MLSMSG_L1BRead//l1bItemName )
          return
        endif

        ! Now we're going to deal with a VGrid for this quantity
        qty%verticalCoordinate = l_geodAltitude
        qty%surfs = l1bField%dpField(1,:,:)  ! Vert coord is tpGeodAlt read above.
d725 1
a725 2
        call DeallocateL1BData(l1bfield)
      end if
d1509 1
a1509 1
       "$Id: ConstructQuantityTemplates.f90,v 2.184 2015/09/17 23:21:08 pwagner Exp $"
d1519 3
@


2.184
log
@Turning on verbose(r) prints more now in ConstructMinorFrameQuantity
@
text
@d1217 1
a1217 1
      L_GEOLOCATION, L_GPH, L_HEIGHTOFFSET, L_ISOTOPERATIO, L_IWC, &
d1231 1
a1231 1
      L_SCANRESIDUAL, L_SCATTERINGANGLE, L_SCECI, L_SCVELECI, &
d1327 1
d1383 1
d1518 1
a1518 1
       "$Id: ConstructQuantityTemplates.f90,v 2.183 2015/07/29 00:29:54 vsnyder Exp $"
d1528 3
@


2.183
log
@Convert Phi from pointer to allocatable
@
text
@d80 1
d87 1
d533 2
d547 2
a548 1
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, SETUPNEWQUANTITYTEMPLATE
d605 2
d618 3
a620 1
    MissingOK = .not. AURA_L1BFILES
d627 4
d657 4
d673 4
d690 1
a690 1
      if ( switchDetail(switches,'qtmp') > -1 ) then
d748 1
d793 1
d1516 1
a1516 1
       "$Id: ConstructQuantityTemplates.f90,v 2.182 2015/07/27 22:28:06 vsnyder Exp $"
d1526 3
@


2.182
log
@Make cross angles always associated, with value zero if there's no xGrid
@
text
@d814 1
a814 1
    type (QuantityTemplate_T), dimension(:), intent(inout) :: MIFGEOLOCATION
d1130 2
a1131 2
    ! In some rare cases, e.g. non-Aura satellite data, source may be a dud
    if ( associated(source%phi) ) then
d1135 1
a1135 1
      qty%phi => source%phi(1:1,:)
d1493 1
a1493 1
       "$Id: ConstructQuantityTemplates.f90,v 2.181 2015/06/04 03:14:14 vsnyder Exp $"
d1503 3
@


2.181
log
@Make Surfs component of quantity template allocatable
@
text
@d469 3
d1493 1
a1493 1
       "$Id: ConstructQuantityTemplates.f90,v 2.180 2015/06/03 00:01:51 vsnyder Exp $"
d1503 3
@


2.180
log
@Allocate rank-2 latitude and longitude, instead of rank-1 ones and then
remapping to rank-2 and rank-3.
@
text
@d457 1
a457 1
        qty%surfs => vGrids(vGridIndex)%surfs
d1452 1
a1452 1
    nullify( qty%frequencies, qty%geodLat, qty%lon, qty%time, qty%solarTime, &
a1482 1
    nullify(qty%surfs) ! Lest we deallocate a database entry
d1490 1
a1490 1
       "$Id: ConstructQuantityTemplates.f90,v 2.179 2015/05/28 18:25:16 vsnyder Exp $"
d1500 4
@


2.179
log
@Eliminate shared HGrid, get PointQuantityToHGrid from QuantityTemplates
@
text
@d548 1
a548 1
    type (QuantityTemplate_T) :: qty ! Resulting quantity
d1455 2
a1456 6
    call allocate_test ( qty%geodLat1, 1, 'qty%geodLat1(1)', ModuleName )
    call remap ( qty%geodLat1, qty%geodLat, [ 1, 1 ] )
    call remap ( qty%geodLat1, qty%geodLat3, [ 1, 1, 1 ] )
    call allocate_test ( qty%lon1, 1, 'qty%lon1(1)', ModuleName )
    call remap ( qty%lon1, qty%lon, [ 1, 1 ] )
    call remap ( qty%lon1, qty%lon3, [ 1, 1, 1 ] )
d1491 1
a1491 1
       "$Id: ConstructQuantityTemplates.f90,v 2.178 2015/03/28 02:29:39 vsnyder Exp $"
d1501 3
@


2.178
log
@Added P_MustBeGeocalt, Coordinate, NoCrossTrack, Stacked, xGridIndex,
xGrid, noCrossTrack, tracing, scGeodLat, scLon.  Support cross-track grids.
Use Get_Boolean from More_Tree.  Added truncate field to Forge command --
maybe should have been called "save" -- to save any geolocations gotten
from L1BOA.  Deleted Azimuth.  Deleted mustBeZeta requirement of
magnetic field (because we now use height for the vertical coordinate).
Support for 3-d GeodLat and Lon.
@
text
@d93 2
a94 3
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, &
      & SETUPNEWQUANTITYTEMPLATE, &
      & NULLIFYQUANTITYTEMPLATE
d422 1
a422 1
        & sharedVGrid=.true., sharedHGrid=.true., sharedFGrid=.true. )
d426 1
d429 1
a429 1
        call PointQuantityToHGrid ( hGrids(hGridIndex), chunk, qty )
d466 3
a468 7
      if ( qty%sharedHGrid ) then
        qty%crossAngles => hGrids(xGridIndex)%phi(1,:)
      else
        call allocate_test ( qty%crossAngles, size(hGrids(xGridIndex)%phi,2), &
          & 'qty%crossAngles', moduleName )
        qty%crossAngles = hGrids(xGridIndex)%phi(1,:)
      end if
a616 1
      qty%sharedHGrid = .true.
d790 1
a790 1
  subroutine ForgeMinorFrames ( root, chunk, mifGeolocation )
a794 1
    use CHUNKS_M, only: MLSCHUNK_T
a810 1
    type (MLSChunk_T), intent(in) :: CHUNK ! This chunk
d1100 2
a1101 1
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, SETUPNEWQUANTITYTEMPLATE
d1125 1
a1125 1
      & sharedHGrid=.true., sharedVGrid=.true. )
d1129 3
a1132 2
      qty%geodLat => source%geodLat(1:1,:)
      qty%lon => source%lon(1:1,:)
a1440 79
  ! ----------------------------------  PointQuantityToHGrid  -----
  subroutine PointQuantityToHGrid ( hGrid, chunk, qty )

  ! This routine associates HGrid information into an already defined quantity,
  ! except that if Qty%NoCrossTrack > 1, it creates a copy.

    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST
    use CHUNKS_M, only: MLSCHUNK_T
    use HGRIDSDATABASE, only: HGRID_T
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_Warning
    use QUANTITYTEMPLATES, only: CreateGeolocationFields, QUANTITYTEMPLATE_T
    use String_Table, only: Get_String
    use TOGGLES, only: GEN, LEVELS, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END

    ! Dummy arguments
    type (hGrid_T), intent(in) :: HGRID
    type (MLSChunk_T), intent(in) :: Chunk
    type (QuantityTemplate_T), intent(inout) :: QTY

    ! Local variables
    integer :: I
    integer :: Me = -1                  ! String index for trace
    character(127) :: QtyName

    ! Executable code

    call trace_begin ( me, "PointQuantityToHGrid", &
      & cond=toggle(gen) .and. levels(gen) > 2 )

    if ( qty%noInstances/=hGrid%noProfs ) call MLSMessage ( MLSMSG_Error,&
      & ModuleName, "Size of HGrid not compatible with size of quantity" )

    if ( qty%stacked ) then
      qty%phi => hGrid%phi
      if ( qty%noCrossTrack > 1 ) then
        call CreateGeolocationFields ( qty, size(hGrid%geodLat,1), 'Qty' )
        do i = 1, qty%noCrossTrack
          qty%geodLat3(:,:,i) = hGrid%geodLat
          qty%lon3(:,:,i) = hGrid%lon
        end do
      else
        qty%geodLat => hGrid%geodLat
        qty%lon => hGrid%lon
        qty%geodLat1(1:hGrid%noProfs) => hGrid%geodLat(1,1:hGrid%noProfs)
        qty%geodLat3(1:1,1:hGrid%noProfs,1:1) => hGrid%geodLat(1,1:hGrid%noProfs)
        qty%lon1(1:hGrid%noProfs) => hGrid%lon(1,1:hGrid%noProfs)
        qty%lon3(1:1,1:hGrid%noProfs,1:1) => hGrid%lon(1,1:hGrid%noProfs)
      end if
    else
      call CreateGeolocationFields ( qty, qty%noSurfs, 'Qty' )
      nullify ( qty%phi )
!       This results in a "double free or corruption" termination:
!       call allocate_test ( qty%phi, 0, 0, 'qty%phi(1,1)', ModuleName )
      if ( qty%name /= 0 ) then
        call get_string ( qty%name, qtyName )
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
        & "Cannot copy hGrids into unstacked quantity " // &
        & trim(qtyName) // &
        & "; assume Lat, Lon computed somehow; hope nobody needs Phi")
      else
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & "Cannot copy hGrids into unstacked quantities; assume Lat, Lon computed somehow; hope nobody needs Phi")
      end if
    end if
    qty%time => hGrid%time
    qty%solarTime => hGrid%solarTime
    qty%solarZenith => hGrid%solarZenith
    qty%losAngle => hGrid%losAngle
    qty%noInstancesLowerOverlap = hGrid%noProfsLowerOverlap
    qty%noInstancesUpperOverlap = hGrid%noProfsUpperOverlap
    ! if ( ChunkDivideConfig%allowPriorOverlaps .and. chunk%chunkNumber == 1 ) &
    !  & qty%noInstancesLowerOverlap = 0

    call trace_end ( "PointQuantityToHGrid", &
      & cond=toggle(gen) .and. levels(gen) > 2 )

  end subroutine PointQuantityToHGrid

a1448 1
    qty%sharedHGrid = .false.
d1450 2
d1453 1
a1453 1
      & qty%solarZenith, qty%losAngle, qty%crossAngles ) ! Lest we deallocate a database entry
d1495 1
a1495 1
       "$Id: ConstructQuantityTemplates.f90,v 2.177 2014/09/05 00:39:49 vsnyder Exp $"
d1505 9
@


2.177
log
@Add some tracing
@
text
@d23 1
a23 1
  integer, parameter ::         NEXT                 = -1
d25 22
a46 21
  integer, public, parameter :: P_CHUNKED            = FirstProperty
  integer, public, parameter :: P_MAJORFRAME         = P_CHUNKED + 1
  integer, public, parameter :: P_MINORFRAME         = P_MAJORFRAME + 1
  integer, public, parameter :: P_MUSTBEZETA         = P_MINORFRAME + 1
  integer, public, parameter :: P_FGRID              = P_MUSTBEZETA + 1
  integer, public, parameter :: P_FGRIDOPTIONAL      = P_FGRID + 1
  integer, public, parameter :: P_FLEXIBLEVHGRID     = P_FGRIDOPTIONAL + 1
  integer, public, parameter :: P_HGRID              = P_FLEXIBLEVHGRID + 1
  integer, public, parameter :: P_MODULE             = P_HGRID + 1
  integer, public, parameter :: P_MOLECULE           = P_MODULE + 1
  integer, public, parameter :: P_SGRID              = P_MOLECULE + 1
  integer, public, parameter :: P_VGRID              = P_SGRID + 1
  integer, public, parameter :: P_RADIOMETER         = P_VGRID + 1
  integer, public, parameter :: P_RADIOMETEROPTIONAL = P_RADIOMETER + 1
  integer, public, parameter :: P_REFLECTOR          = P_RADIOMETEROPTIONAL + 1
  integer, public, parameter :: P_SCMODULE           = P_REFLECTOR + 1
  integer, public, parameter :: P_SIGNAL             = P_SCMODULE + 1
  integer, public, parameter :: P_SIGNALOPTIONAL     = P_SIGNAL + 1
  integer, public, parameter :: P_SUPPRESSCHANNELS   = P_SIGNALOPTIONAL + 1
  integer, public, parameter :: P_XYZ                = P_SUPPRESSCHANNELS + 1
  integer, public, parameter :: P_MATRIX3X3          = P_XYZ + 1
d48 1
a48 1
  integer, public, parameter :: LastProperty         = P_MATRIX3X3
d80 6
a85 5
    use init_tables_module, only:  f_badValue, f_fGrid, f_hGrid, f_irregular, &
      & f_keepChannels, f_logBasis, f_minValue, f_module, f_molecule, &
      & f_radiometer, f_sgrid, f_signal, f_type, f_vgrid, f_reflector, &
      & field_first, field_last, l_true, l_zeta, l_xyz, l_matrix3x3, &
      & l_channel, l_lostransfunc, l_none, l_phitan
d91 1
d126 3
d139 1
d149 2
d154 1
d186 1
d194 2
d197 1
a197 1
    signalString = ''
d215 2
d222 1
a222 1
        keepChannels = (value == l_true)
d224 1
a224 1
        logBasis = (value == l_true)
d226 1
a226 1
        regular = (value /= l_true)
d270 2
d276 5
d338 5
d392 6
a397 2
    if ( got(f_hGrid) .and. hGridIndex > 0 ) &
      & horizontalCoordinate = HGrids(hGridIndex)%masterCoordinate
d401 1
d403 1
a403 1
        noChans=noChans, filedatabase=filedatabase, &
d406 2
a407 1
      ! Setup a minor frame quantity
d411 1
a411 1
        & qty, noChans, mifGeolocation )
d421 2
a422 2
        & noSurfs=noSurfs, coherent=.true., stacked=.true., regular=.true.,&
        & noChans=noChans, &
d428 1
d463 12
d528 2
a529 2
    & qty, noChans, regular, instanceLen, &
    filedatabase, chunk, mifGeolocation )
d545 2
a546 1
    use TOGGLES, only: SWITCHES
d556 1
d572 3
a574 3
      enumerator :: MAFStartTimeTAI = 1, tpGeodLat, tpLon, tpGeodAngle, &
        & tpSolarZenith, tpSolarTime, tpLosAngle, &
        & LastL1BItem ! Just to get the size; keep this one after the others
d576 4
a579 2
    integer, parameter :: NoL1BItemsToRead = lastL1BItem - 1
    type (item_t), parameter :: L1bItemsToRead(noL1BItemsToRead) = (/ &
d581 3
a583 1
      & item_t(MAFStartTimeTAI, "MAFStartTimeTAI", .false.), &
d590 1
d598 2
a599 1
    integer :: noMAFs, l1bFlag, l1bItem, mafIndex, mifIndex, hdfVersion
d601 2
d608 4
d626 1
a626 1
        qty%instanceLen = qty%noChans*qty%noSurfs
d653 1
a653 1
      elseif ( l1bFlag /= 0 ) then
d657 1
a657 1
      endif
d661 2
a662 1
        & noSurfs=l1bField%maxMIFs, noChans=noChans, coherent=.false., &
d679 15
a693 1
      if ( .not. IsModuleSpacecraft(instrumentModule) ) then
d696 1
a696 1
        
d709 1
a709 1
        
d715 1
d717 7
a723 2
        do l1bItem = 1, NoL1BItemsToRead
          ! Get the name of the item to read
d725 12
a736 6
          if ( L1bItemsToRead(l1bItem)%modular ) then
            call GetModuleName ( instrumentModule, l1bItemName )
            l1bItemName = trim(l1bItemName)//'.'//L1bItemsToRead(l1bItem)%name
          else
            l1bItemName = L1bItemsToRead(l1bItem)%name
          end if
d738 17
a754 32
          ! Read it from the l1boa file
          l1bItemName = AssembleL1BQtyName ( l1bItemName, hdfVersion, .false. )
          call ReadL1BData ( L1BFile, l1bItemName, l1bField, noMAFs, &
            & l1bFlag, firstMAF=chunk%firstMafIndex, &
            & lastMAF=chunk%lastMafIndex, neverfail=MissingOK )
          if ( l1bFlag /= 0 .and. .not. MissingOK ) then
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & MLSMSG_L1BRead//l1bItemName )
          elseif ( l1bFlag /= 0 ) then
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & MLSMSG_L1BRead//l1bItemName )
            cycle
          endif
          
          ! Now we have to save this field in the quantity data.
          ! This is rather a kludgy way of doing it but this worked out the
          ! least boring way to write the code.  See the definition of
          ! L1BItemsToRead above for reference.
          
          select case ( L1bItemsToRead(l1bItem)%type )
          case ( MAFStartTimeTAI )
            !??? For time we have to do something a little more complicated.
            !??? This is a real kludge, and we have to find a way
            !??? to do it better in 0.5. Probably simply have time as a minor
            !??? frame quantity in L1, or MIF duration. !???????
            !??? Also note that it fills in times even for non existant MIFs
            do mafIndex = 1, noMAFs
              do mifIndex = 1, qty%noSurfs 
                qty%time(mifIndex,mafIndex) = &
                  & l1bField%dpField(1,1,mafIndex) + &
                  & (mifIndex-1) * sixth
              end do
d756 20
a775 31
          case ( tpGeodLat )
            qty%geodLat = l1bField%dpField(1,:,:)
          case ( tpLon )
            qty%lon = l1bField%dpField(1,:,:)
          case ( tpGeodAngle )
            qty%phi = l1bField%dpField(1,:,:)
          case ( tpSolarZenith )
            qty%solarZenith = l1bField%dpField(1,:,:)
          case ( tpSolarTime )
            qty%solarTime = l1bField%dpField(1,:,:)
          case ( tpLosAngle )
            qty%losAngle = l1bField%dpField(1,:,:)
          case default
            call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "No code to read L1B item " // trim(L1bItemsToRead(l1bItem)%name) )
          end select

          call DeallocateL1BData ( l1bField )
        end do                          ! Loop over l1b quantities
      else                              ! Spacecraft module
        ! just zero stuff out.
        qty%surfs = 0.0
        qty%phi = 0.0
        qty%geodLat = 0.0
        qty%lon = 0.0
        qty%time = 0.0
        qty%solarTime = 0.0
        qty%solarZenith = 0.0
        qty%losAngle = 0.0
        call DeallocateL1BData(l1bfield)
      end if
d787 5
a791 1
    ! We thought about about them, but not too hard apparently
d802 2
a803 2
    use INIT_TABLES_MODULE, only: F_GEODANGLE, F_MODULE, F_NOMIFS, &
      & F_SOLARTIME, F_SOLARZENITH, F_GEODALT
d808 4
a811 1
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T, SETUPNEWQUANTITYTEMPLATE
d827 1
d830 1
d835 2
d842 1
d850 1
d870 2
d898 53
a950 20
    ! Note this will destroy the old ones contents bit by bit.
    mifGeolocation(instrumentModule)%name = 0
    call SetupNewQuantityTemplate ( mifGeolocation(instrumentModule), &
      & noInstances=noMAFs, noSurfs=noMIFs, noChans=1,&
      & coherent=.false., stacked=.false., regular=.true.,&
      & minorFrame=.true. )

    ! Put zeros etc. in the appropriate places, may overwrite these later
    mifGeolocation(instrumentModule)%instrumentModule = instrumentModule
    mifGeolocation(instrumentModule)%noInstancesLowerOverlap = 0
    mifGeolocation(instrumentModule)%noInstancesUpperOverlap = 0
    mifGeolocation(instrumentModule)%verticalCoordinate = l_geodAltitude
    mifGeolocation(instrumentModule)%time = 0.0
    mifGeolocation(instrumentModule)%phi = 0.0
    mifGeolocation(instrumentModule)%geodLat = 0.0
    mifGeolocation(instrumentModule)%solarTime = 0.0
    mifGeolocation(instrumentModule)%solarZenith = 0.0
    mifGeolocation(instrumentModule)%lon = 0.0
    mifGeolocation(instrumentModule)%losAngle = 0.0
    mifGeolocation(instrumentModule)%surfs = 0.0
a1101 35
  ! ----------------------------------  PointQuantityToHGrid  -----
  subroutine PointQuantityToHGrid ( hGrid, chunk, qty )

  ! This routine copies HGrid information into an already defined quantity

    use CHUNKS_M, only: MLSCHUNK_T
    use HGRIDSDATABASE, only: HGRID_T
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T

    ! Dummy arguments
    type (hGrid_T), intent(in) :: HGRID
    type (MLSChunk_T), intent(in) :: Chunk
    type (QuantityTemplate_T), intent(inout) :: QTY

    ! Executable code
    if ( qty%noInstances/=hGrid%noProfs ) call MLSMessage ( MLSMSG_Error,&
      & ModuleName, "Size of HGrid not compatible with size of quantity" )
    if ( .not. qty%stacked ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Cannot copy hGrids into unstacked quantities")

    qty%phi => hGrid%phi
    qty%geodLat => hGrid%geodLat
    qty%lon => hGrid%lon
    qty%time => hGrid%time
    qty%solarTime => hGrid%solarTime
    qty%solarZenith => hGrid%solarZenith
    qty%losAngle => hGrid%losAngle
    qty%noInstancesLowerOverlap = hGrid%noProfsLowerOverlap
    qty%noInstancesUpperOverlap = hGrid%noProfsUpperOverlap
    ! if ( ChunkDivideConfig%allowPriorOverlaps .and. chunk%chunkNumber == 1 ) &
    !  & qty%noInstancesLowerOverlap = 0

  end subroutine PointQuantityToHGrid

d1104 1
a1104 1
    & mifGeolocation )
d1108 2
d1116 1
d1118 2
d1123 3
d1130 2
a1131 1
      & noChans=noChans, sharedHGrid=.true., sharedVGrid=.true. )
d1142 1
a1142 1
    endif
d1150 4
d1155 1
a1155 1
  
d1182 1
a1182 1
    use Init_Tables_Module, only:  L_ADOPTED, L_ADOPTED, L_AZIMUTH, L_BASELINE, &
a1246 1
      l_azimuth, phyq_angle, none, next, &
d1322 1
a1322 1
      l_magneticField, phyq_gauss, p_vGrid, p_hGrid, p_xyz, p_mustBeZeta, next, &
d1399 3
a1401 2
      ! Check that mustBeZeta quantities have a vGrid
      if ( propertyTable ( p_mustBeZeta, i ) .and. .not. &
d1404 1
a1404 1
        message = "Quantity must have vGrid if it must be on log-pressure"
d1446 79
d1528 1
d1536 13
a1548 8
      & qty%solarZenith, qty%losAngle ) ! Lest we deallocate a database entry
    call Allocate_test ( qty%phi, 1, 1, 'qty%phi(1,1)', ModuleName )
    call Allocate_test ( qty%geodLat, 1, 1, 'qty%geodLat(1,1)', ModuleName )
    call Allocate_test ( qty%lon, 1, 1, 'qty%lon(1,1)', ModuleName )
    call Allocate_test ( qty%time, 1, 1, 'qty%time(1,1)', ModuleName )
    call Allocate_test ( qty%solarTime, 1, 1, 'qty%solarTime(1,1)', ModuleName )
    call Allocate_test ( qty%solarZenith, 1, 1, 'qty%solarZenith(1,1)', ModuleName )
    call Allocate_test ( qty%losAngle, 1, 1, 'qty%losAngle(1,1)', ModuleName )
d1556 1
d1578 1
a1578 1
       "$Id: ConstructQuantityTemplates.f90,v 2.176 2014/04/24 23:58:21 pwagner Exp $"
d1588 3
@


2.176
log
@If hGrid supplied, use it to set horizontalCoordinate
@
text
@d94 2
d130 1
d160 3
d473 3
d1405 1
a1405 1
       "$Id: ConstructQuantityTemplates.f90,v 2.175 2014/04/07 18:01:12 pwagner Exp $"
d1415 3
@


2.175
log
@Added new quantity type AscDescMode
@
text
@d79 5
a83 5
    use INIT_TABLES_MODULE, only:  F_BADVALUE, F_FGRID, F_HGRID, F_IRREGULAR, &
      & F_KEEPCHANNELS, F_LOGBASIS, F_MINVALUE, F_MODULE, F_MOLECULE, &
      & F_RADIOMETER, F_SGRID, F_SIGNAL, F_TYPE, F_VGRID, F_REFLECTOR, &
      & FIELD_FIRST, FIELD_LAST, L_TRUE, L_ZETA, L_XYZ, L_MATRIX3X3, &
      & L_CHANNEL, L_LOSTRANSFUNC, L_NONE
d124 1
d163 1
d357 4
d463 1
d1396 1
a1396 1
       "$Id: ConstructQuantityTemplates.f90,v 2.174 2013/09/24 23:47:22 vsnyder Exp $"
d1406 3
@


2.174
log
@Use Where instead of Source_Ref for messages
@
text
@d1099 2
a1100 2
      L_MIFDEADTIME, L_MIFEXTINCTION, L_MIFExtinctionExtrapolation, &
      L_MIFExtinctionForm, L_MIFEXTINCTIONV2, L_MIFRHI, &
d1102 2
a1103 1
      L_NUMGRAD, L_NUMJ, L_NUMNEWT, L_OPTICALDEPTH, L_ORBITINCLINATION, &
d1244 1
d1389 1
a1389 1
       "$Id: ConstructQuantityTemplates.f90,v 2.173 2013/08/17 00:23:35 pwagner Exp $"
d1399 3
@


2.173
log
@New cmdline arg relaxes some for non-Aura l1b datasets
@
text
@d875 1
a875 1
    use TREE, only: SOURCE_REF
d899 1
a899 1
      call print_source ( source_ref(where) )
d1387 1
a1387 1
       "$Id: ConstructQuantityTemplates.f90,v 2.172 2013/07/25 00:23:00 vsnyder Exp $"
d1397 3
@


2.172
log
@Add MIFRHI quantity type
@
text
@d475 1
d477 2
a478 1
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_L1BREAD
d530 1
d536 1
d572 10
a581 3
        & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
      if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_L1BRead//l1bItemName )
d598 3
d608 10
a617 3
          & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
        if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_L1BRead//l1bItemName )
d639 9
a647 3
            & lastMAF=chunk%lastMafIndex )
          if ( l1bFlag == -1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_L1BRead//l1bItemName )
d709 2
d1034 10
a1043 8

    qty%phi => source%phi(1:1,:)
    qty%geodLat => source%geodLat(1:1,:)
    qty%lon => source%lon(1:1,:)
    qty%time => source%time(1:1,:)
    qty%solarTime => source%solarTime(1:1,:)
    qty%solarZenith => source%solarZenith(1:1,:)
    qty%losAngle => source%losAngle(1:1,:)
d1387 1
a1387 1
       "$Id: ConstructQuantityTemplates.f90,v 2.171 2013/07/19 01:21:49 vsnyder Exp $"
d1397 3
@


2.171
log
@Sort some stuff, turn off the first time flag so that InitQuantityTemplates
is not done on every call.
@
text
@d1069 1
a1069 1
      L_MIFExtinctionForm, L_MIFEXTINCTIONV2, &
d1198 2
d1356 1
a1356 1
       "$Id: ConstructQuantityTemplates.f90,v 2.170 2013/07/18 01:12:11 vsnyder Exp $"
d1366 4
@


2.170
log
@Remove scVel since it's ambiguous whether it's ECI or ECR, and nobody
uses it anyway.
@
text
@d153 1
a153 1
      firstCall = .true.
d1144 1
d1146 1
a1146 1
      l_dnwt_dxdxl, phyq_dimensionless, p_vGrid, next, &
a1147 1
      l_dnwt_dxnl, phyq_dimensionless, p_vGrid, next, &
a1155 1
      l_geolocation, phyq_dimensionless, p_majorframe, p_module, next, &
d1170 1
d1186 1
a1186 1
      l_losVel, phyq_dimensionless, p_minorFrame, p_module, next, &
d1189 2
a1190 2
      l_massMeanDiameterIce, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_massMeanDiameterWater, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
d1198 1
d1203 1
a1203 1
      l_noiseBandwidth, phyq_frequency, p_signal, next, &
d1205 1
a1205 2
      l_numJ, phyq_dimensionless, p_vGrid, next, &
      l_numNewt, phyq_dimensionless, p_vGrid, next /) )
d1215 3
a1219 3
      l_reflrefl, phyq_dimensionless, p_signal, p_reflector, next, &
      l_reflspill, phyq_temperature, p_signal, p_majorframe, p_reflector, next, &
      l_refGPH, phyq_length, p_hGrid, p_vGrid, p_mustBeZeta, next, &
d1221 2
a1226 2
      l_scanResidual, phyq_length, p_minorFrame, p_module, next, &
      l_scatteringAngle, phyq_angle, p_vGrid, next, &
a1236 1
      l_totalPowerWeight, phyq_dimensionless, p_signal, next, &
d1240 1
d1275 1
d1277 1
d1354 1
a1354 1
       "$Id: ConstructQuantityTemplates.f90,v 2.169 2013/05/31 00:42:35 vsnyder Exp $"
d1364 4
@


2.169
log
@Get geolocation if requested for L1B fill
@
text
@d1075 1
a1075 1
      L_SCANRESIDUAL, L_SCATTERINGANGLE, L_SCECI, L_SCVEL, L_SCVELECI, &
a1222 1
      l_scVel, phyq_velocity, p_minorFrame, p_scModule, p_xyz, next, &
d1352 1
a1352 1
       "$Id: ConstructQuantityTemplates.f90,v 2.168 2013/05/21 23:52:47 vsnyder Exp $"
d1362 3
@


2.168
log
@Add MIFExtinctionExtrapolation and MIFExtinctionForm
@
text
@d500 20
a519 12
    ! IF MODIFYING THIS SECTION PLEASE TAKE CARE, SEE BELOW!
    integer, parameter :: NoL1BItemsToRead=7
    character (len=15), dimension(NoL1BItemsToRead), parameter :: &
         & L1bItemsToRead = &
         & (/"MAFStartTimeTAI","tpGeodLat      ","tpLon          ",&
         &   "tpGeodAngle    ","tpSolarZenith  ","tpSolarTime    ",&
         &   "tpLosAngle     "/)
    integer, parameter :: TransitionToModularItems = 2
    ! Entries in the above array below TransitionToModularItems are prefixed
    ! with either GHz or THz.  The layout of the above array is critically
    ! bound to the select case(l1bItem) code below.  So TAKE CARE! when
    ! modifing it.
d606 2
a607 2
          l1bItemName = l1bItemsToRead(l1bItem)
          if ( l1bItem >= TransitionToModularItems ) then
d609 1
a609 1
            l1bItemName = trim(l1bItemName)//'.'//l1bItemsToRead(l1bItem)
d611 1
a611 1
            l1bItemName = l1bItemsToRead(l1bItem)
d613 1
a613 1
          
d627 2
a628 2
          select case(l1bItem)
          case ( 1 )
d641 1
a641 1
          case ( 2 )
d643 1
a643 1
          case ( 3 )
d645 1
a645 1
          case ( 4 )
d647 1
a647 1
          case ( 5 )
d649 1
a649 1
          case ( 6 )
d651 1
a651 1
          case ( 7 )
d653 3
d1353 1
a1353 1
       "$Id: ConstructQuantityTemplates.f90,v 2.167 2013/02/21 21:37:10 pwagner Exp $"
d1363 3
@


2.167
log
@New optional arg mafwise to return anysignaldata maf-by-maf
@
text
@d1037 2
a1038 2
    use Init_Tables_Module, only:  L_ADOPTED, L_ADOPTED, L_BASELINE, L_BOUNDARYPRESSURE, &
      L_CALSIDEBANDFRACTION, &
d1057 2
a1058 1
      L_MIFDEADTIME, L_MIFEXTINCTION, L_MIFEXTINCTIONV2, &
d1097 1
a1097 1
    ! array, provided for its documentaty value.
d1101 1
d1181 1
a1181 1
      l_MIFExtinction, phyq_extinction, p_flexibleVHGrid, &
d1183 3
a1185 1
      l_MIFExtinctionV2, phyq_extinction, p_flexibleVHGrid, &
d1342 1
a1342 1
       "$Id: ConstructQuantityTemplates.f90,v 2.166 2012/01/05 01:20:47 pwagner Exp $"
d1352 3
@


2.166
log
@Capitalized USEd stuff
@
text
@d872 2
a873 1
  function AnyGoodSignalData ( signal, sideband, filedatabase, Chunk )  result (answer)
d889 6
a894 5
    integer, intent(in) :: signal
    integer, intent(in) :: sideband
    logical             :: answer
    type (MLSChunk_T), intent(in) :: Chunk
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
d896 4
a899 1
    integer :: FileID, flag, noMAFs
d906 1
d926 5
d1338 1
a1338 1
       "$Id: ConstructQuantityTemplates.f90,v 2.165 2011/12/21 01:40:57 vsnyder Exp $"
d1348 3
@


2.165
log
@Add LowestRetrievedPressure, MIFExtinction[v2], and a description of the
DefineQtyTypes table.
@
text
@d23 1
a23 1
  integer, parameter :: NEXT = -1
d1003 1
a1003 1
    use MLSStrings, only: LowerCase
d1043 2
a1044 2
      L_LineCenter, L_LineWidth, L_LineWidth_TDep, &
      L_LOSTRANSFUNC, L_LOSVEL, L_LowestRetrievedPressure, &
d1046 1
a1046 1
      L_MIFDEADTIME, l_MIFExtinction, l_MIFExtinctionV2, &
d1054 1
a1054 1
      L_STRAYRADIANCE, L_SurfaceHeight, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
d1062 1
a1062 1
    use MLSMessageModule, only: MLSMSG_Error, MLSMessage
d1327 1
a1327 1
       "$Id: ConstructQuantityTemplates.f90,v 2.164 2011/08/20 00:49:05 vsnyder Exp $"
d1337 4
@


2.164
log
@Remove unused use names
@
text
@d24 2
a25 1
  integer, parameter :: P_CHUNKED            = 1
d47 1
a47 1
  integer, public, parameter :: NOPROPERTIES = P_MATRIX3X3
d50 3
a52 3
  logical, public, save, dimension ( noProperties, first_lit : last_lit ) :: &
    & PROPERTYTABLE
  integer, public, save, dimension ( first_lit : last_lit ) :: UNITSTABLE
d117 2
a118 2
    logical, dimension(noProperties) :: PROPERTIES ! Properties for this quantity type
    logical, dimension(field_first:field_last) :: GOT ! Fields
d1044 1
a1044 1
      L_LOSTRANSFUNC, L_LOSVEL, &
d1046 1
a1046 1
      L_MIFDEADTIME, &
d1069 1
a1069 1
    integer, dimension(0), parameter :: NONE = (/ ( 0, i=1,0 ) /)
d1079 8
d1163 1
d1168 4
d1173 1
a1173 1
                      p_signal, p_suppressChannels, p_mustBeZeta, next, &
d1175 1
a1175 1
                      p_suppressChannels, next, &
d1327 1
a1327 1
       "$Id: ConstructQuantityTemplates.f90,v 2.163 2011/05/09 18:05:32 pwagner Exp $"
d1337 3
@


2.163
log
@Converted to using switchDetail
@
text
@d1003 1
a1003 1
    use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
d1313 1
a1313 1
       "$Id: ConstructQuantityTemplates.f90,v 2.162 2010/04/05 17:40:55 honghanh Exp $"
d1323 3
@


2.162
log
@Fixed bug introduced by making filedatabase optional
@
text
@d16 1
a16 1
  use Init_tables_module, only: FIRST_LIT, LAST_LIT
d72 3
a74 3
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Chunks_m, only: MLSChunk_T
!   use ChunkDivide_m, only: ChunkDivideConfig
d76 2
a77 2
    use FGrid, only: fGrid_T
    use HGridsDatabase, only: hGrid_T
d83 9
a91 8
    use MLSCommon, only: MLSFile_T, RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSSignals_m, only:GetModuleFromRadiometer, GetModuleFromSignal, &
      & GetRadiometerFromSignal, GetSignal, Signal_T, IsModuleSpacecraft
    use Parse_Signal_m, only: PARSE_SIGNAL
    use QuantityTemplates, only: QuantityTemplate_T, &
      & SetupNewQuantityTemplate, &
      & NullifyQuantityTemplate
d95 1
a95 1
    use VGridsDatabase, only: VGrids
d468 1
a468 1
    use Chunks_m, only: MLSChunk_T
d470 10
a479 8
    use L1BData, only: L1BData_T, READL1BDATA, DEALLOCATEL1BDATA, &
      & AssembleL1BQtyName
    use MLSCommon, only: MLSFile_T, NameLen, RK => R8
    use MLSFiles, only: GetMLSFileByType
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
    use MLSSignals_m, only:  IsModuleSpacecraft, GetModuleName
    use Output_m, only: OUTPUT
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate
d574 1
a574 1
      if ( index(switches,'qtmp') /= 0 ) then
d678 1
a678 1
    use Chunks_m, only: MLSChunk_T
d684 3
a686 3
    use MLSCommon, only: RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate
d688 1
a688 1
    use VgridsDatabase, only: VGrid_t, VGRIDS
d836 2
a837 2
    use String_Table, only: DISPLAY_STRING
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
d878 8
a885 8
    use Chunks_m, only: MLSChunk_T
    use Allocate_Deallocate, only: Deallocate_Test
    use L1BData, only: L1BData_T, READL1BDATA, GetL1BFile, &
      & AssembleL1BQtyName, PRECISIONSUFFIX
!   use L1BData, only: FindL1BData
    use MLSCommon, only: MLSFile_T, RK => R8
    use MLSFiles, only: GetMLSFileByType
    use MLSSignals_m, only: GetSignalName
d930 4
a933 5
    use Chunks_m, only: MLSChunk_T
!   use ChunkDivide_m, only: ChunkDivideConfig
    use HGridsDatabase, only: hGrid_T
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use QuantityTemplates, only: QuantityTemplate_T
d964 2
a965 2
    use Chunks_m, only: MLSChunk_T
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate
d1313 1
a1313 1
       "$Id: ConstructQuantityTemplates.f90,v 2.160 2010/03/31 19:59:55 honghanh Exp $"
d1323 3
@


2.161
log
@Make filedatabase and chunk in ConstructMinorFrameQuantity optional
@
text
@a521 3
    L1BFile => GetMLSFileByType(filedatabase, content='l1boa')
    hdfversion = L1BFile%HDFVersion

d545 2
@


2.160
log
@Removing l_geodAltitude quantityType as there is l_tngtgeodaltitude
quantityType already
@
text
@d356 4
a359 3
      call ConstructMinorFrameQuantity ( filedatabase, chunk, &
        & instrumentModule, qty, noChans=noChans, mifGeolocation=mifGeolocation, &
        & regular=regular )
d463 3
a465 2
  subroutine ConstructMinorFrameQuantity ( filedatabase, chunk, instrumentModule, &
    & qty, noChans, regular, instanceLen, mifGeolocation )
a481 2
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (MLSChunk_T), intent(in) :: chunk   ! The chunk under consideration
d487 2
d542 2
a543 1
    else ! ------------------------------------ Not Got mifGeolocation -----
d658 4
d1312 1
a1312 1
       "$Id: ConstructQuantityTemplates.f90,v 2.159 2010/03/24 17:35:13 honghanh Exp $"
d1322 4
@


2.159
log
@Just a note to fix ConstructMinorFrameQuantity
@
text
@d1031 1
a1031 1
      L_GEODALTITUDE, L_GEOLOCATION, L_GPH, L_HEIGHTOFFSET, L_ISOTOPERATIO, L_IWC, &
a1129 1
      l_geodAltitude, phyq_length, p_minorFrame, p_module, next, &
d1305 1
a1305 1
       "$Id: ConstructQuantityTemplates.f90,v 2.158 2010/03/09 22:44:08 honghanh Exp $"
d1315 3
@


2.158
log
@Remove cfm_CreateQtyTemplate, set InitQuantityTemplate, and previously private constants to public
@
text
@d460 2
d1306 1
a1306 1
       "$Id: ConstructQuantityTemplates.f90,v 2.157 2010/03/09 22:40:50 honghanh Exp $"
d1316 3
@


2.157
log
@Change to support cfm creation of quantity template
@
text
@d54 1
a54 1
  public :: cfm_CreateQtyTemplate, CreateQtyTemplateFromMLSCFInfo
a67 381
  ! ------------------------------------------- cfm_CreateQtyTemplate ----
  type (QuantityTemplate_T) function cfm_CreateQtyTemplate ( &
    & Name, filedatabase, Chunk, qFGrid, HGrid, VGrid, MifGeolocation, &
    & qLogBasis, qMinimumV, qInstModule, qRadiometer, qMolecule, &
    & qSignal, qType ) &
    & result ( QTY )
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate
    use Chunks_m, only: MLSChunk_T
!   use ChunkDivide_m, only: ChunkDivideConfig
    use Dump_0, only: Dump
    use EXPR_M, only: EXPR
    use FGrid, only: fGrid_T
    use HGridsDatabase, only: hGrid_T
    use INIT_TABLES_MODULE, only:  F_BADVALUE, F_FGRID, F_HGRID, F_IRREGULAR, &
      & F_KEEPCHANNELS, F_LOGBASIS, F_MINVALUE, F_MODULE, F_MOLECULE, &
      & F_RADIOMETER, F_SGRID, F_SIGNAL, F_TYPE, F_VGRID, F_REFLECTOR, &
      & FIELD_FIRST, FIELD_LAST, L_TRUE, L_ZETA, L_XYZ, L_MATRIX3X3, &
      & L_CHANNEL, L_LOSTRANSFUNC, L_NONE
    use Intrinsic, only: LIT_INDICES
    use MLSCommon, only: MLSFile_T, RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSSignals_m, only:GetModuleFromRadiometer, GetModuleFromSignal, &
      & GetModuleIndex, GetRadiometerFromSignal, GetRadiometerIndex, &
      & GetSignal, Signal_T, MODULES, IsModuleSpacecraft
    use Molecules, only: GetMoleculeIndex
    use OUTPUT_M, only: OUTPUT
    use Parse_Signal_m, only: PARSE_SIGNAL
    use QuantityTemplates, only: QuantityTemplate_T, &
      & DUMP, SetupNewQuantityTemplate, &
      & NullifyQuantityTemplate
    use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
    use TOGGLES, only: SWITCHES
    use TREE, only: DECORATION, NODE_ID, NSONS, SUB_ROSA, SUBTREE
    use TREE_TYPES, only: N_SET_ONE
    use VGridsDatabase, only: VGrids, VGrid_T

    ! Dummy arguments
    integer, intent(in) :: NAME              ! Sub-rosa index of name
    type (FGrid_T), optional      :: qFGrid
    type (HGrid_T), optional      :: HGrid
    type (VGrid_T) , optional     :: VGrid
    type (MLSFile_T), dimension(:), pointer ::     FILEDATABASE
    type (MLSChunk_T), intent(in) :: Chunk
    type (QuantityTemplate_T), dimension(:), intent(in), optional, target :: &
      & MifGeolocation ! TARGET attribute needed so pointers to MifGeolocation
                       ! created at lower levels in the call tree don't become
                       ! undefined when those procedures return.

    logical, optional               :: qLogBasis   
    real(rk), optional              :: qMinimumV   
    character(len=*), optional      :: qRadiometer 
    character(len=*), optional      :: qMolecule   
    character(len=*), optional      :: qType       
    character(len=*), optional      :: qInstModule
    character(len=*), optional      :: qSignal
    ! Local variables
    logical, pointer :: Channels(:)     ! From Parse_Signal
    logical :: LOGBASIS                 ! To place in quantity
    logical :: ISMINORFRAME             ! Is a minor frame quantity
    logical :: KeepChannels             ! From /channels, means keep the channels
                                        ! information from the signal
    logical :: REGULAR                  ! Flag
    logical, dimension(noProperties) :: PROPERTIES ! Properties for this quantity type
    logical, dimension(field_first:field_last) :: GOT ! Fields
    character(len=127) :: SIGNALSTRING

    integer :: FGRIDINDEX               ! Index of frequency grid
    integer :: FREQUENCYCOORDINATE      ! Literal
    integer :: HGRIDINDEX               ! Index of horizontal grid
    integer :: I                        ! Loop counter
    integer :: INSTRUMENTMODULE         ! Database index
    integer :: KEY                      ! Field name, F_...
    integer :: MOLECULE                 ! Literal
    integer :: NOCHANS                  ! Quantity dimension
    integer :: NOINSTANCES              ! Quantity dimension
    integer :: NOSURFS                  ! Quantity dimension
    integer :: QUANTITYTYPE             ! Literal
    integer :: RADIOMETER               ! Database index
    integer :: REFLECTOR                ! Reflector literal
    integer :: SGRIDINDEX               ! Index for 'sGrid'
    integer :: SIDEBAND                 ! -1, 0, 1
    integer :: SIGNAL                   ! Database index
    integer :: SON                      ! A Son of Root -- an n_assign node
    integer :: VGRIDINDEX               ! Index in database
    integer :: VALUE                    ! Node index of value of field of spec
    integer :: S_INDEX                  ! Loop counter

    integer, dimension(2) :: EXPR_UNITS
    integer, dimension(:), pointer :: SignalInds ! From parse signal

    real(rk) :: BadValue
    real(rk) :: MINVALUE                ! Minimum value allowed for quantity in fwm
    real(rk), dimension(2) :: EXPR_VALUE
    type (signal_T) :: SIGNALINFO       ! Details of the appropriate signal

    ! Executable code
    if ( firstCall ) then
      call InitQuantityTemplates
      firstCall = .true.
    end if

    ! Set appropriate defaults
    call NullifyQuantityTemplate ( qty ) ! for Sun's rubbish compiler
    nullify ( channels, signalInds )
    qty%name = name
    fGridIndex = 0
    hGridIndex = 0
    instrumentModule = 0
    keepChannels = .false.
    logBasis = .false.
    minValue = -huge ( 0.0_rk )
    molecule = 0
    noChans = 1
    quantitytype = 0
    radiometer = 0
    reflector = 0
    regular = .true.
    sGridIndex = 0
    sideband = 0
    signal = 0
    vGridIndex = 0
    signalString = ''

    ! Go through the l2cf command line and parse it.
    ! got = .false.
    ! do i = 2, nsons(root)
    !  son = subtree(i,root)
    !  key = subtree(1,son)
    !  if ( node_id(son) == n_set_one ) then
    !    value = l_true
    !  else
    !    value = decoration(subtree(2,son))
    !  end if
    !  got ( decoration(key) ) = .true.

      ! select case ( decoration(key) )
      ! case ( f_logBasis )
        if ( present(qLogBasis) ) logBasis = qLogBasis
      ! case ( f_minValue )
        ! call expr ( subtree(2,son), expr_units, expr_value )
        if ( present(qMinimumV) ) minValue = qMinimumV
      ! case ( f_module)
        if ( present(qInstModule) ) then
          call GetModuleIndex( qInstModule, instrumentModule )
        endif
      ! case ( f_molecule )
        if ( present(qMolecule) ) then
          call GetMoleculeIndex( qMolecule, molecule )
        endif
      ! case ( f_radiometer )
        if ( present(qRadiometer) ) then
          call getRadiometerIndex( qRadiometer, radiometer )
        endif
        instrumentModule = GetModuleFromRadiometer(radiometer)
      ! case ( f_sgrid )
        ! sGridIndex = decoration(value) ! node_id(value) == n_spec_args
      ! case ( f_signal )
        !??? For the moment it is simple, later we'll be more intelligent here
        !??? for example, letting the user choose either R1A or R1B.
        !call get_string( sub_rosa(subtree(2,son)), signalString, strip=.true. )
        if ( present(qSignal) ) then
          signalString = qSignal
          !??? Here we would do intelligent stuff to work out which bands
          !??? are present, for the moment choose the first
          call parse_Signal ( signalString, signalInds, &
            & sideband=sideband, channels=channels )
          if ( .not. associated(signalInds) ) then ! A parse error occurred
            call MLSMessage ( MLSMSG_Error, ModuleName,&
              & 'Unable to parse signal string' )
          end if
          if ( size(signalInds) == 1 .or. .not. associated(filedatabase) ) then
            signal = signalInds(1)
          else
            ! Seek a signal with any precision values !< 0
            do s_index=1, size(signalInds)
              if ( AnyGoodSignalData ( signalInds(s_index), sideband, &
                & filedatabase, Chunk) ) exit
            end do
            if ( s_index > size(signalInds) ) then
              signal = signalInds(1)
            else
              signal = signalInds(s_index)
            end if
          end if
          call deallocate_test ( signalInds, 'signalInds', ModuleName )
          instrumentModule = GetModuleFromSignal(signal)
          radiometer = GetRadiometerFromSignal(signal)
        endif
      ! case ( f_type )
        if ( present(qType) ) then
          call GetQtyTypeIndex( qType, quantityType )
        endif
      ! end select
    ! end do

    ! Do a very low level sanity check, irregular quantities not supported
    if ( .not. regular ) call announce_error ( 0,&
      & 'Inappropriate irregular quantity request' )

    ! Now get the properties for this quantity type
    properties = propertyTable ( :, quantityType )

    ! Now check various things out first check that required fields are present
    ! according to the quantity type
    ! First those that are fairly clear cut to check
    if ( .not. properties ( p_flexibleVHGrid ) ) then
      if ( present ( hGrid ) .neqv. properties ( p_hGrid ) ) &
        & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
        & present(hGrid) ) ) // ' hGrid for quantity type ', quantityType, &
        & severity='nonfatal' )
      if ( present ( vGrid ) .neqv. properties ( p_vGrid ) ) &
        & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
        & present(vGrid) ) ) // ' vGrid for quantity type ', quantityType )
    end if
    if ( present ( qMolecule ) .neqv. properties ( p_Molecule ) ) &
      & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
      & present(qMolecule) ) ) // ' molecule for quantity type ', quantityType )
    ! These ones need a little more thought
    if ( .not. properties ( p_signalOptional ) ) then
      if ( present ( qSignal ) .neqv. properties ( p_Signal ) ) &
        & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
        & present(qSignal) ) ) // ' signal for quantity type ', quantityType )
    end if
    if ( .not. properties ( p_fGridOptional ) ) then
      if ( present ( qFGrid ) .neqv. properties ( p_fGrid ) ) &
        & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
        & present(qFGrid) ) ) // ' fGrid for quantity type ', quantityType )
    end if
    if ( .not. properties ( p_radiometerOptional ) ) then
      if ( present ( qRadiometer ) .neqv. properties ( p_Radiometer ) ) &
        & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
        & present(qRadiometer) ) ) // ' radiometer for quantity type ', quantityType )
    end if
    if ( present ( qInstModule ) .neqv. ( properties ( p_Module ) .or. properties ( p_scModule) ) ) &
      & call Announce_error ( 0, trim ( merge ( 'unexpected', 'need      ', &
      & present(qInstModule) ) ) // ' module for quantity type ', quantityType )

    ! Now do more derived checking / setting up
    if ( properties ( p_mustBeZeta ) .and. present(vGrid) ) then
      if ( vGrid%verticalCoordinate /= l_zeta ) &
        & call Announce_error ( 0, 'Expecting log pressure coordinates for', &
        & quantityType )
    end if
    if ( properties ( p_scModule ) ) then
      if ( .not. IsModuleSpacecraft ( instrumentModule ) ) &
        & call Announce_error ( 0, 'Module must be spacecraft' )
    end if

    ! Now establish the frequency coordinate system
    if ( present(qfGrid) ) then
      frequencyCoordinate = qfGrid%frequencyCoordinate
      qty%frequencies => qfGrid%values
      noChans = qfGrid%noChans
      ! print *, '1st try: fGridIndex ', fGridIndex
      ! print *, fGridvalues
    else if ( properties(p_xyz) ) then
      ! XYZ quantity (e.g. ECI/ECR stuff)
      frequencyCoordinate = l_xyz
      noChans = 3
    else if ( properties(p_matrix3x3) ) then
      ! XYZ^2 quantity (e.g. rotation matrix)
      frequencyCoordinate = l_matrix3x3
      noChans = 9
    else if ( present(qsignal) .and. .not. properties(p_suppressChannels) ) then
      ! This is a channel based quantity
      signalInfo = GetSignal ( signal )
      frequencyCoordinate = l_channel
      noChans = size ( signalInfo%frequencies )
      if ( keepChannels ) then
        qty%channels => channels
        nullify ( channels ) ! so we don't deallocate out from under qty%channels
      end if
    else
      ! No frequency variation
      noChans = 1
      frequencyCoordinate = l_none
    end if

    ! Now deal with the flexibleVHGrid quantities
    if ( properties(p_flexibleVHGrid) ) then
      if ( present ( hGrid ) .neqv. present ( vGrid ) ) &
        & call Announce_Error ( 0, 'Must supply both or neither vGrid and hGrid' )
      isMinorFrame = .not. present ( hGrid )
    else
      isMinorFrame = properties(p_minorFrame)
    end if

    ! Now do the setup for the different families of quantities
    if ( isMinorFrame ) then
      call ConstructMinorFrameQuantity ( filedatabase, chunk, &
        & instrumentModule, qty, noChans=noChans, mifGeolocation=mifGeolocation, &
        & regular=regular )
      ! Setup a minor frame quantity
    else if ( properties(p_majorFrame) ) then
      ! Setup a major frame quantity
      call ConstructMajorFrameQuantity ( chunk, instrumentModule, &
        & qty, noChans, mifGeolocation )
    else
      ! Setup a non major/minor frame quantity
      noInstances = 1
      if ( present ( hGrid ) ) noInstances = hGrid%noProfs
      noSurfs = 1
      if ( present ( vGrid ) ) noSurfs = vGrid%noSurfs

      ! Setup the quantity template
      call SetupNewQuantityTemplate ( qty, noInstances=noInstances, &
        & noSurfs=noSurfs, coherent=.true., stacked=.true., regular=.true.,&
        & noChans=noChans, &
        & sharedVGrid=.true., sharedHGrid=.true., sharedFGrid=.true. )

      ! Setup the horizontal coordinates
      if ( present(hGrid) ) then
        qty%hGridIndex = hGridIndex
        call PointQuantityToHGrid ( hGrid, chunk, qty )
      else
        call SetupEmptyHGridForQuantity ( qty )
      end if
      ! Work out the instance offset
      if ( associated ( chunk%hGridOffsets ) ) then
        if ( present ( hGrid )  ) then
          qty%instanceOffset = chunk%hGridOffsets(hGridIndex)
          qty%grandTotalInstances = chunk%hGridTotals(hGridIndex)
          ! Subtract any instances outside processing range
          !   if ( ChunkDivideConfig%allowPriorOverlaps ) &
          !     & qty%grandTotalInstances = qty%grandTotalInstances - &
          !     & hGrid%noProfsLowerOverlap
          !   if ( ChunkDivideConfig%allowPostOverlaps ) &
          !     & qty%grandTotalInstances = qty%grandTotalInstances - &
          !     & hGrid%noProfsUpperOverlap
        else
          ! Must have a single instance per chunk
          qty%instanceOffset = chunk%chunkNumber - 1
          ! -1 because it's an offset remember, not an origin.
          qty%grandTotalInstances = 0
        end if
      end if

      ! Setup the vertical coordinates
      if ( present (vGrid) ) then
        qty%vGridIndex = vGridIndex
        qty%verticalCoordinate = vGrid%verticalCoordinate
        qty%surfs => vGrid%surfs
      else
        call SetupEmptyVGridForQuantity ( qty )
      end if
    end if

    ! Fill the frequency information if appropriate
    if ( present ( qfGrid ) ) then
      ! print *, 'About to: qty%GridIndex was ', qty%fGridIndex
      ! print *, 'qty%sharedFGrid ', qty%sharedFGrid
      ! print *, fGridvalues
      qty%fGridIndex = fGridIndex
      qty%frequencies => qfGrid%values
      if ( .not. qty%sharedFGrid ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName,&
          & 'sharedFGrid needed to be reset' )
        qty%sharedFGrid = .true.
      end if
      ! print *, '2nd try: fGridIndex ', fGridIndex
      ! print *, 'qty%sharedFGrid ', qty%sharedFGrid
      ! print *, fGridvalues
    end if

    ! Set up the remaining stuff
    qty%name = name
    qty%frequencyCoordinate = frequencyCoordinate
    qty%instrumentmodule = instrumentmodule
    qty%logBasis = logBasis
    qty%minValue = minValue
    qty%molecule = molecule
    qty%quantityType = quantityType
    qty%radiometer = radiometer
    qty%reflector = reflector
    qty%sideband = sideband
    qty%signal = signal
    qty%unit = unitsTable ( quantityType )

    call deallocate_test ( channels, 'Channels', moduleName )
  end function cfm_CreateQtyTemplate

d1304 1
a1304 1
       "$Id: ConstructQuantityTemplates.f90,v 2.156 2010/03/05 20:17:51 honghanh Exp $"
d1314 3
@


2.156
log
@Put ConstructMajorFrameQuantity to the list of public subroutine
@
text
@d19 33
a51 1
  private
d56 1
a63 30
  ! The various properties has/can have
  integer, parameter :: NEXT = -1
  integer, parameter :: P_CHUNKED            = 1
  integer, parameter :: P_MAJORFRAME         = P_CHUNKED + 1
  integer, parameter :: P_MINORFRAME         = P_MAJORFRAME + 1
  integer, parameter :: P_MUSTBEZETA         = P_MINORFRAME + 1
  integer, parameter :: P_FGRID              = P_MUSTBEZETA + 1
  integer, parameter :: P_FGRIDOPTIONAL      = P_FGRID + 1
  integer, parameter :: P_FLEXIBLEVHGRID     = P_FGRIDOPTIONAL + 1
  integer, parameter :: P_HGRID              = P_FLEXIBLEVHGRID + 1
  integer, parameter :: P_MODULE             = P_HGRID + 1
  integer, parameter :: P_MOLECULE           = P_MODULE + 1
  integer, parameter :: P_SGRID              = P_MOLECULE + 1
  integer, parameter :: P_VGRID              = P_SGRID + 1
  integer, parameter :: P_RADIOMETER         = P_VGRID + 1
  integer, parameter :: P_RADIOMETEROPTIONAL = P_RADIOMETER + 1
  integer, parameter :: P_REFLECTOR          = P_RADIOMETEROPTIONAL + 1
  integer, parameter :: P_SCMODULE           = P_REFLECTOR + 1
  integer, parameter :: P_SIGNAL             = P_SCMODULE + 1
  integer, parameter :: P_SIGNALOPTIONAL     = P_SIGNAL + 1
  integer, parameter :: P_SUPPRESSCHANNELS   = P_SIGNALOPTIONAL + 1
  integer, parameter :: P_XYZ                = P_SUPPRESSCHANNELS + 1
  integer, parameter :: P_MATRIX3X3          = P_XYZ + 1

  integer, parameter :: NOPROPERTIES = P_MATRIX3X3

  ! Local, saved variables (constant tables really)
  logical, save, dimension ( noProperties, first_lit : last_lit ) :: &
    & PROPERTYTABLE
  integer, save, dimension ( first_lit : last_lit ) :: UNITSTABLE
d862 1
a862 1
    type (QuantityTemplate_T), intent(out) :: qty ! Resulting quantity
d1387 1
a1387 1
        & return
d1685 1
a1685 1
       "$Id: ConstructQuantityTemplates.f90,v 2.155 2010/03/02 01:09:20 pwagner Exp $"
d1695 3
@


2.155
log
@Added geodAltitude as a quantity type
@
text
@d21 2
a22 1
  public :: AnyGoodSignalData, ConstructMinorFrameQuantity, CreateQtyTemplateFromMLSCFInfo
d65 381
d1367 22
d1682 1
a1682 1
       "$Id: ConstructQuantityTemplates.f90,v 2.154 2010/02/04 23:12:44 vsnyder Exp $"
d1692 3
@


2.154
log
@Remove USE or declaration for unreferenced names
@
text
@d1003 1
a1003 1
      L_GEOLOCATION, L_GPH, L_HEIGHTOFFSET, L_ISOTOPERATIO, L_IWC, &
d1102 1
d1278 1
a1278 1
       "$Id: ConstructQuantityTemplates.f90,v 2.153 2010/01/23 01:02:37 vsnyder Exp $"
d1288 3
@


2.153
log
@Remove LogIWC
@
text
@d68 1
a68 1
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate
a70 1
    use Dump_0, only: Dump
a78 1
    use Intrinsic, only: LIT_INDICES
d82 1
a82 2
      & GetRadiometerFromSignal, GetSignal, Signal_T, MODULES, IsModuleSpacecraft
    use OUTPUT_M, only: OUTPUT
d85 1
a85 1
      & DUMP, SetupNewQuantityTemplate, &
d87 1
a87 2
    use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
    use TOGGLES, only: SWITCHES
d1022 1
a1022 1
      & PHYQ_GAUSS, PHYQ_IceDensity, PHYQ_LENGTH, PHYQ_LogIceDensity, &
d1277 1
a1277 1
       "$Id: ConstructQuantityTemplates.f90,v 2.152 2009/09/25 02:40:28 vsnyder Exp $"
d1287 3
@


2.152
log
@Add badValue to specify badValue field, keepChannels to allocate a
channels(:) pointer and save the channels output from Parse_Signal
@
text
@d1011 1
a1011 1
      L_LogIWC, L_LOSTRANSFUNC, L_LOSVEL, &
a1119 1
      l_logiwc, phyq_logIceDensity, p_hGrid, p_vGrid, next, &
d1281 1
a1281 1
       "$Id: ConstructQuantityTemplates.f90,v 2.151 2009/09/22 17:02:31 pwagner Exp $"
d1291 4
@


2.151
log
@NAG complained of too many continuation statements
@
text
@d75 5
a79 4
    use INIT_TABLES_MODULE, only:  F_FGRID, F_HGRID, F_IRREGULAR, &
      & F_LOGBASIS, F_MINVALUE, F_MODULE, F_MOLECULE, F_RADIOMETER, F_SGRID, &
      & F_SIGNAL, F_TYPE, F_VGRID, F_REFLECTOR, FIELD_FIRST, FIELD_LAST, &
      & L_TRUE, L_ZETA, L_XYZ, L_MATRIX3X3, L_CHANNEL, L_LOSTRANSFUNC, L_NONE
d109 1
d112 2
d143 1
d156 1
a156 1
    nullify ( signalInds )
d161 1
d189 3
d196 2
d223 1
a223 1
          & tree_index=son, sideband=sideband )
d331 4
d454 1
d456 1
d1134 3
a1136 1
      l_numNewt, phyq_dimensionless, p_vGrid, next, &
d1139 1
a1139 3
      l_phaseTiming, phyq_dimensionless, p_vGrid, next /) )

    call DefineQtyTypes ( (/ & 
d1282 1
a1282 1
       "$Id: ConstructQuantityTemplates.f90,v 2.150 2009/09/19 00:33:44 vsnyder Exp $"
d1292 3
@


2.150
log
@Add LogIWC
@
text
@d1094 3
a1096 1
      l_jacobian_rows, phyq_dimensionless, p_vGrid, next, &
d1265 1
a1265 1
       "$Id: ConstructQuantityTemplates.f90,v 2.149 2009/06/23 18:46:18 pwagner Exp $"
d1275 3
@


2.149
log
@Prevent Intel from optimizing ident string away
@
text
@d994 1
a994 1
      L_LOSTRANSFUNC, L_LOSVEL, &
d1007 3
a1009 2
    use Init_Tables_Module, only: PHYQ_EXTINCTION, PHYQ_FREQUENCY,&
      & PHYQ_GAUSS, PHYQ_IceDensity, PHYQ_LENGTH, &
d1011 1
a1011 1
      & PHYQ_VMR, PHYQ_ZETA, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_COLMABUNDANCE
d1101 1
d1263 1
a1263 1
       "$Id: read_apriori.f90 is it here $"
d1273 3
@


2.148
log
@Add dnwt_count and dnwt_abandoned
@
text
@d1258 1
a1259 1
  !---------------------------- RCS Ident Info -------------------------------
d1261 1
a1261 1
       "$Id: ConstructQuantityTemplates.f90,v 2.147 2008/10/03 16:39:42 livesey Exp $"
a1262 1
  !---------------------------------------------------------------------------
d1264 1
a1264 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1266 1
d1271 3
@


2.147
log
@Added EXTINCTIONV2
@
text
@d976 1
a976 1
    use Init_Tables_Module, only:  L_ADOPTED, L_BASELINE, L_BOUNDARYPRESSURE, &
d981 1
a981 1
      L_DNWT_AJN, L_DNWT_AXMAX, L_DNWT_CAIT, &
d983 1
a983 1
      L_DNWT_DIAG, L_DNWT_DXDX, L_DNWT_DXDXL, &
d1050 1
d1059 1
d1261 1
a1261 1
       "$Id: ConstructQuantityTemplates.f90,v 2.146 2008/09/30 22:34:19 vsnyder Exp $"
d1271 3
@


2.146
log
@Remove AuxGrid and an unnecessary dump routine
@
text
@d988 1
a988 1
      L_ELEVOFFSET, L_EXTINCTION, &
d1081 2
d1114 1
a1114 3
      l_phaseTiming, phyq_dimensionless, p_vGrid, next, &
      l_phiTan, phyq_angle, p_minorFrame, p_module, next, & 
      l_ptan, phyq_zeta, p_minorFrame, p_module, next /) )
d1117 2
d1259 1
a1259 1
       "$Id: ConstructQuantityTemplates.f90,v 2.145 2008/08/22 01:04:18 vsnyder Exp $"
d1269 3
@


2.145
log
@Don't allow multiple AuxGrids fields
@
text
@d32 1
a32 2
  integer, parameter :: P_AUXGRID            = 1
  integer, parameter :: P_CHUNKED            = P_AUXGRID + 1
d71 1
d75 1
a75 1
    use INIT_TABLES_MODULE, only:  F_AUXGRID, F_FGRID, F_HGRID, F_IRREGULAR, &
a114 1
    integer :: AuxGridNode              ! Tree index of AuxGrid field
a121 1
    integer :: NOAUX                    ! Quantity dimension
a182 2
      case ( f_auxGrid )
        auxGridNode = key ! Might have several sons
d201 4
a233 4
      case ( f_reflector )
        reflector = value
      case ( f_sgrid )
        sGridIndex = decoration(value) ! node_id(value) == n_spec_args
a268 6

    ! auxGrid is never required, but is sometimes prohibited
    if ( got ( f_auxGrid ) .and. .not. properties ( p_auxGrid ) ) &
      & call Announce_error ( root, 'unexpected auxGrid for quantity type ', &
      & quantityType )

d337 1
a337 1
    endif
d389 1
a389 1
      ! Setup the vertical coordiantes
d410 1
a410 1
      endif
a425 15
    ! Aux grid stuff
    if ( got(f_auxGrid) ) then
      ! ??? Temp until init_tables says "no duplicate fields"
      if ( associated(qty%auxGrids) ) call Announce_Error ( root, &
        & 'AuxGrids field cannot be specified more than once' )
      noAux = 1
      allocate ( qty%auxGrids(nsons(auxGridNode)-1), stat=i )
      call test_allocate ( i, 'ConstructQuantityTemplates', 'qty%auxGrids', &
        (/ 1 /), (/ nsons(auxGridNode)-1 /) )
      do i = 2, nsons(auxGridNode)
        qty%auxGrids(i-1) = vGrids(decoration(subtree(i,auxGridNode)))
        noAux = noAux * qty%auxGrids(i-1)%noSurfs
      end do
    end if

a438 34
    
    if ( index(switches,'qtmp') /= 0 ) then
      call output( 'Template name: ', advance='no' )
      call display_string ( qty%name, advance='no' )
      call output( '   quantityType: ', advance='no' )
      call display_string( lit_indices(qty%quantityType), advance='yes' )
      call output( '   major frame? ', advance='no' )
      call output( qty%majorFrame, advance='no' )
      call output( '   minor frame? ', advance='no' )
      call output( qty%minorFrame, advance='yes' )
      call output( '    signal name: ', advance='no' )
      call output( trim(signalString), advance='yes' )
      call output( '   Instrument module: ', advance='no' )
      if ( qty%instrumentModule < 1 ) then
        call output( ' (none) ', advance='yes' )
      else
        call display_string ( modules(qty%instrumentModule)%name, advance='yes' )
      end if
      call output( '    Molecule: ', advance='no' )
      if  ( qty%molecule < 1 ) then
        call output ( ' (none)', advance='yes' )
      else
        call display_string ( qty%Molecule, advance='yes' )
      end if
      call output ( qty%noAux,       before='   noAux',     advance='no' )
      call output ( qty%noChans,     before=' noChans',     advance='no' )
      call output ( qty%noSurfs,     before=' noSurfs',     advance='no' )
      call output ( qty%noInstances, before=' noInstances', advance='no' )
      call output ( qty%instanceLen, before=' instanceLen', advance='yes' )
      call output ( ' verticalCoordinate = ' )
      call display_string ( lit_indices(qty%verticalCoordinate) )
      call output ( ' frequencyCoordinate = ' )
      call display_string ( lit_indices(qty%frequencyCoordinate), advance='yes' )
    end if
a439 1
    if ( index(switches, 'qtmp') > 0 ) call dump(qty, details=0, noL2CF=.true.)
d521 1
a521 2
    else
      ! -------------------------------------- Not Got mifGeolocation ------------
d553 1
a553 1
      endif
d820 1
a820 1
    endif
d827 1
a827 1
    endif
a932 9
  logical function not_used_here()
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: ConstructQuantityTemplates.f90,v 2.144 2008/06/06 01:58:31 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  !---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here

d990 2
a991 2
      L_GEOLOCATION, L_GPH, L_HEIGHTOFFSET, &
      L_ISOTOPERATIO, L_JACOBIAN_COLS, L_JACOBIAN_ROWS, &
d1087 1
d1141 1
a1141 2
      l_temperature, phyq_temperature, p_auxGrid, p_hGrid, p_vGrid, &
                     p_mustbezeta, next, &
d1146 2
a1147 2
      l_TScat, phyq_temperature, p_auxGrid, p_fGrid, p_hGrid, p_vGrid, next, &
      l_vmr, phyq_vmr, p_auxGrid, p_hGrid, p_vGrid, p_fGridOptional, &
d1254 10
d1267 3
@


2.144
log
@Make Aux grids VGrids, define ScatteringAngle grid type
@
text
@a160 1
    noAux = 1
d438 4
d997 1
a997 1
       "$Id: ConstructQuantityTemplates.f90,v 2.143 2008/06/05 20:00:45 vsnyder Exp $"
d1327 3
@


2.143
log
@auxGrid never required
@
text
@d69 1
a69 1
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
d439 3
a441 1
      call allocate_test ( qty%auxGrids, nsons(auxGridNode)-1, 'qty%auxGrids', moduleName )
d443 2
a444 2
        qty%auxGrids(i-1) = decoration(subtree(i,auxGridNode))
        noAux = noAux * vGrids(qty%auxGrids(i-1))%noSurfs
d994 1
a994 1
       "$Id: ConstructQuantityTemplates.f90,v 2.142 2008/06/05 02:14:29 vsnyder Exp $"
d1069 1
a1069 1
      L_SCANRESIDUAL, L_SCECI, L_SCVEL, L_SCVELECI, &
d1197 1
d1324 3
@


2.142
log
@Added AuxGrid field to Quantity.  Defined CloudTemperature and TScat types.
@
text
@d274 5
a278 3
    if ( got ( f_auxGrid ) .neqv. properties ( p_auxGrid ) ) &
      & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
      & got(f_auxGrid) ) ) // ' sGrid for quantity type ', quantityType )
d992 1
a992 1
       "$Id: ConstructQuantityTemplates.f90,v 2.141 2008/05/28 21:03:58 pwagner Exp $"
d1321 3
@


2.141
log
@New quantity type to hold chunk number[maf]
@
text
@d32 2
a33 1
  integer, parameter :: P_CHUNKED            = 1
d75 1
a75 1
    use INIT_TABLES_MODULE, only:  F_FGRID, F_HGRID, F_IRREGULAR, &
d115 1
d123 1
d161 1
d186 2
d264 1
a264 1
    endif
d274 3
d330 1
a330 1
      ! Uses an sGrid
d424 1
a424 1
    if ( properties ( p_sGrid ) ) then
d435 9
d481 5
a485 8
      call output ( '   noChans = ' )
      call output ( qty%noChans, advance='no' )
      call output ( ' noSurfs = ' )
      call output ( qty%noSurfs, advance='no' )
      call output ( ' noInstances = ' )
      call output ( qty%noInstances, advance='no' )
      call output ( ' instanceLen = ' )
      call output ( qty%instanceLen, advance='yes' )
d990 1
a990 1
       "$Id: ConstructQuantityTemplates.f90,v 2.140 2008/04/26 00:39:46 livesey Exp $"
d1043 1
a1043 1
      L_CLOUDWATER, L_COLUMNABUNDANCE, &
d1069 1
a1069 1
      L_TOTALPOWERWEIGHT, L_VMR
d1110 1
d1174 1
d1202 2
a1203 1
      l_temperature, phyq_temperature, p_hGrid, p_vGrid, p_mustbezeta, next, &
d1208 3
a1210 2
      l_vmr, phyq_vmr, p_hGrid, p_vGrid, p_fGridOptional, p_molecule, &
             p_radiometerOptional, p_mustbezeta, next /) )
a1211 2
    call DefineQtyTypes ( (/ & 
      l_phaseTiming, phyq_dimensionless, p_vGrid, next/) )
d1252 1
a1252 2
      defineLoop: do
        if ( i > size(info) ) exit defineLoop
d1268 1
a1268 1
      end do defineLoop
d1319 3
@


2.140
log
@Added total power stuff
@
text
@d975 1
a975 1
       "$Id: ConstructQuantityTemplates.f90,v 2.139 2007/03/08 01:33:33 pwagner Exp $"
d1038 1
a1038 1
      L_GPH, L_HEIGHTOFFSET, &
d1118 1
d1303 3
@


2.139
log
@We should never use undefined values for surfs even if no vgrid
@
text
@d975 1
a975 1
       "$Id: ConstructQuantityTemplates.f90,v 2.138 2007/01/24 02:17:29 vsnyder Exp $"
d1054 1
a1054 1
      L_VMR
d1185 1
d1302 3
@


2.138
log
@Add TARGET attribute for MifGeolocation to prevent dangling pointer
@
text
@d975 1
a975 1
       "$Id: ConstructQuantityTemplates.f90,v 2.137 2007/01/11 20:44:27 vsnyder Exp $"
d1295 1
d1301 3
@


2.137
log
@Add SurfaceHeight
@
text
@d101 4
a104 2
    type (QuantityTemplate_T), dimension(:), intent(in), optional :: &
      & MifGeolocation
d975 1
a975 1
       "$Id: ConstructQuantityTemplates.f90,v 2.136 2006/10/02 23:05:31 pwagner Exp $"
d1300 3
@


2.136
log
@May Fill chi^2 ratio to measure convergence
@
text
@d973 1
a973 1
       "$Id: ConstructQuantityTemplates.f90,v 2.135 2006/08/11 20:36:24 vsnyder Exp $"
d1049 2
a1050 2
      L_SCVELECR, L_SCGEOCALT, L_SPACERADIANCE, &
      L_STATUS, L_STRAYRADIANCE, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
d1179 1
d1298 3
@


2.135
log
@Add INTENT(IN) to MIFGeolocation
@
text
@d973 1
a973 1
       "$Id: ConstructQuantityTemplates.f90,v 2.134 2006/08/04 20:52:20 pwagner Exp $"
d1028 1
a1028 1
      L_DNWT_CHISQMINNORM, L_DNWT_CHISQNORM, &
d1102 1
d1297 3
@


2.134
log
@Restore quantity name (if clobbered by SetUp..)
@
text
@d973 1
a973 1
       "$Id: ConstructQuantityTemplates.f90,v 2.133 2006/08/03 01:57:42 vsnyder Exp $"
d989 1
a989 1
    type (QuantityTemplate_T), dimension(:), target :: MIFGEOLOCATION
d1296 3
@


2.133
log
@Make sure qty%name is defined
@
text
@d425 1
d973 1
a973 1
       "$Id: ConstructQuantityTemplates.f90,v 2.132 2006/07/20 23:39:53 vsnyder Exp $"
d1296 3
@


2.132
log
@Remove unused declarations and USEs
@
text
@d149 1
a429 1
    qty%name = name
d574 2
a575 1
      
d774 1
d972 1
a972 1
       "$Id: ConstructQuantityTemplates.f90,v 2.131 2006/06/01 03:06:46 vsnyder Exp $"
d995 1
d1295 3
@


2.131
log
@Define numGrad and numNewt
@
text
@d70 1
a70 1
    use ChunkDivide_m, only: ChunkDivideConfig
d887 2
a888 1
      & FindL1BData, AssembleL1BQtyName, PRECISIONSUFFIX
d937 1
a937 1
    use ChunkDivide_m, only: ChunkDivideConfig
d970 1
a970 1
       "$Id: ConstructQuantityTemplates.f90,v 2.130 2006/04/11 23:32:08 pwagner Exp $"
d1292 3
@


2.130
log
@Fixed bug which added excess profiles
@
text
@d969 1
a969 1
       "$Id: ConstructQuantityTemplates.f90,v 2.129 2006/03/04 00:18:02 pwagner Exp $"
d1039 1
a1039 1
      L_NUMJ, L_OPTICALDEPTH, L_ORBITINCLINATION, &
d1144 1
d1146 1
d1291 3
@


2.129
log
@AnyGoodSignalData made public
@
text
@d70 1
d327 1
a327 1
    ! Now deal with the fleixbleVHGrid quantities
d371 7
d961 2
a962 2
    if ( ChunkDivideConfig%allowPriorOverlaps .and. chunk%chunkNumber == 1 ) &
      & qty%noInstancesLowerOverlap = 0
d969 1
a969 1
       "$Id: ConstructQuantityTemplates.f90,v 2.128 2006/01/11 18:00:12 pwagner Exp $"
d1289 3
@


2.128
log
@Consistent with new abstract phys quant colmAbundance
@
text
@d21 1
a21 1
  public :: ConstructMinorFrameQuantity, CreateQtyTemplateFromMLSCFInfo
d961 1
a961 1
       "$Id: ConstructQuantityTemplates.f90,v 2.127 2005/09/14 00:13:30 pwagner Exp $"
d1281 3
@


2.127
log
@Uses ChunkDivideConfig%allowPriorOverlaps in calculating qty%noInstancesLowerOverlap
@
text
@d961 1
a961 1
       "$Id: ConstructQuantityTemplates.f90,v 2.126 2005/09/02 21:57:23 vsnyder Exp $"
d1043 1
a1043 1
      & PHYQ_VMR, PHYQ_ZETA, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_DOBSONUNITS
d1081 1
a1081 1
      l_columnAbundance, phyq_dobsonunits, p_hGrid, p_molecule, next, &
d1281 3
@


2.126
log
@Add spectroscopy parameter quantities
@
text
@a64 2
  ! type (QuantityTemplate_T) function CreateQtyTemplateFromMLSCFInfo ( &
  !  & Name, Root, FGrids, HGrids, L1bInfo, Chunk, MifGeolocation ) &
a98 1
    ! type (L1BInfo_T), intent(in) :: L1BINFO
a214 1
              ! & l1bInfo, Chunk) ) exit
a336 1
      ! call ConstructMinorFrameQuantity ( l1bInfo, chunk, &
d361 1
a361 1
        call PointQuantityToHGrid ( hGrids(hGridIndex), qty )
a488 1
    ! type (L1BInfo_T), intent(in) :: L1BINFO
a529 4
!     hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
!     if ( hdfversion <= 0 ) &
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
d880 1
a880 1
    use MLSCommon, only: L1BInfo_T, MLSFile_T, RK => R8
a896 4
!     hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
!     if ( hdfversion <= 0 ) &
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
d923 1
a923 1
  subroutine PointQuantityToHGrid ( hGrid, qty )
d927 2
d935 1
d953 2
d961 1
a961 1
       "$Id: ConstructQuantityTemplates.f90,v 2.125 2005/08/09 00:03:04 pwagner Exp $"
d1281 3
@


2.125
log
@hdfVersion not left undefined in AnyGoodSignalData
@
text
@d970 1
a970 1
       "$Id: ConstructQuantityTemplates.f90,v 2.124 2005/08/04 02:59:54 vsnyder Exp $"
d1034 3
a1036 1
      L_L1BMAFBASELINE, L_L1BMIF_TAI, L_LIMBSIDEBANDFRACTION, L_LOSTRANSFUNC, L_LOSVEL, &
d1131 3
d1290 3
@


2.124
log
@Correct definitions for L1BMIF_TAI and MIFDeadTime
@
text
@a474 1
  ! subroutine ConstructMinorFrameQuantity ( l1bInfo, chunk, instrumentModule, &
a878 1
  ! function AnyGoodSignalData ( signal, sideband, l1bInfo, Chunk )  result (answer)
d891 1
a898 1
    ! type( L1BInfo_T ), intent(in) :: L1BINFO
a902 1
    integer :: hdfVersion
d906 1
d911 2
d915 1
a915 1
    nameString = AssembleL1BQtyName ( nameString, hdfVersion, .false. )
d970 1
a970 1
       "$Id: ConstructQuantityTemplates.f90,v 2.123 2005/08/03 18:08:35 vsnyder Exp $"
d1285 3
@


2.123
log
@Add L1BMIF_TAI and MifDeadTime for scan averaging
@
text
@d970 1
a970 1
       "$Id: ConstructQuantityTemplates.f90,v 2.122 2005/06/03 02:05:29 vsnyder Exp $"
d1127 1
a1127 1
      l_l1bMIF_TAI, phyq_time, p_minorFrame, p_module, next, &
d1134 1
a1134 1
      l_mifDeadTime, phyq_time, p_module, next, &
d1285 3
@


2.122
log
@New copyright notice, move Id to not_used_here to avoid cascades,
get VGrids from VGridsDatabase instead of passing as an argument.
@
text
@d970 1
a970 1
       "$Id: ConstructQuantityTemplates.f90,v 2.121 2005/06/01 17:39:26 pwagner Exp $"
d1034 1
a1034 1
      L_L1BMAFBASELINE, L_LIMBSIDEBANDFRACTION, L_LOSTRANSFUNC, L_LOSVEL, &
d1036 1
d1049 1
a1049 1
      & PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_VELOCITY, &
d1127 1
d1134 1
d1285 4
@


2.121
log
@Dont read L1bFile if unassocated
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
a24 3
  character (len=*), private, parameter :: IdParm = &
       "$Id: ConstructQuantityTemplates.f90,v 2.120 2005/05/31 17:51:17 pwagner Exp $"
  character (len=len(idParm)), private :: Id = idParm
d66 1
a66 1
  !  & Name, Root, FGrids, VGrids, HGrids, L1bInfo, Chunk, MifGeolocation ) &
d68 1
a68 1
    & Name, Root, FGrids, VGrids, HGrids, filedatabase, Chunk, MifGeolocation ) &
d93 1
a93 1
    use VGridsDatabase, only: VGrid_T
a98 1
    type (VGrid_T), dimension(:), pointer :: VGrids
d683 1
a683 1
  subroutine ForgeMinorFrames ( root, chunk, mifGeolocation, vGrids )
d698 1
a698 1
    use VgridsDatabase, only: VGRID_T
a703 1
    type (VGrid_T), dimension(:), pointer :: VGRIDS
d968 5
d1282 3
@


2.120
log
@Began switch from passing file handles to passing MLSFiles
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.119 2005/01/07 01:03:19 vsnyder Exp $"
d915 2
a916 2
    ! fileID = FindL1BData (filedatabase, nameString, hdfVersion )
    if ( fileID <= 0 ) then
d922 1
a922 1
    call ReadL1BData ( L1BFile , nameString, my_l1bData, noMAFs, flag, &
d1274 3
@


2.119
log
@Remove unused declarations
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.118 2004/10/16 17:25:55 livesey Exp $"
d60 2
d63 1
a63 1
    & Name, Root, FGrids, VGrids, HGrids, L1bInfo, Chunk, MifGeolocation ) &
d75 1
a75 1
    use MLSCommon, only: L1BInfo_T, RK => R8
d96 2
a97 1
    type (l1bInfo_T), intent(in) :: L1bInfo
d207 1
a207 1
        if ( size(signalInds) == 1 .or. .not. associated(L1bInfo%L1BRADIds) ) then
d213 2
a214 1
              & l1bInfo, Chunk) ) exit
d337 2
a338 1
      call ConstructMinorFrameQuantity ( l1bInfo, chunk, &
d471 2
a472 1
  subroutine ConstructMinorFrameQuantity ( l1bInfo, chunk, instrumentModule, &
d479 2
a480 3
    use MLSCommon, only: L1BInfo_T, NameLen, RK => R8
    use MLSFiles, only: MLS_HDF_Version
    use MLSL2Options, only: LEVEL1_HDFVERSION
d490 2
a491 1
    type (L1BInfo_T), intent(in) :: l1bInfo  ! File handles for l1bdata
d522 1
d531 6
a536 4
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
    if ( hdfversion <= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
d569 2
a570 3
      call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & hdfVersion=hdfVersion )
d594 2
a595 3
        call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
          & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
          & hdfVersion=hdfVersion )
d617 1
a617 1
          call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
d619 1
a619 1
            & lastMAF=chunk%lastMafIndex, hdfVersion=hdfVersion )
d877 2
a878 1
  function AnyGoodSignalData ( signal, sideband, l1bInfo, Chunk )  result (answer)
d887 1
a887 1
    use L1BData, only: L1BData_T, READL1BDATA, &
d889 1
a889 4
    use MLSCommon, only: L1BInfo_T, RK => R8
    use MLSFiles, only: MLS_HDF_Version
    use MLSL2Options, only: LEVEL1_HDFVERSION
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d896 2
a897 1
    type (l1bInfo_T), intent(in) :: L1bInfo
d903 1
d906 4
a909 4
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
    if ( hdfversion <= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
d914 2
a915 1
    fileID = FindL1BData (l1bInfo%l1bRadIDs, nameString, hdfVersion )
d922 1
a922 1
    call ReadL1BData ( fileID , nameString, my_l1bData, noMAFs, flag, &
d924 1
a924 1
      & NeverFail= .true., hdfVersion=hdfVersion )
d1274 3
@


2.118
log
@Added signalOptional property and more flexible handling of baseline
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.117 2004/10/13 02:24:33 livesey Exp $"
d68 1
a68 1
    use INIT_TABLES_MODULE, only:  F_FGRID, F_GEODANGLE, F_HGRID, F_IRREGULAR, &
d70 1
a70 1
      & F_SIGNAL, F_TYPE, F_UNIT, F_VGRID, F_REFLECTOR, FIELD_FIRST, FIELD_LAST, &
d76 1
a76 1
      & GetRadiometerFromSignal, GetSignal, Signal_T, SIGNALS, MODULES, IsModuleSpacecraft
d83 1
a83 2
    use TOGGLES, only: GEN, TOGGLE, SWITCHES, LEVELS
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d679 1
a679 1
    use INIT_TABLES_MODULE, only: F_FGRID, F_GEODANGLE, F_MODULE, F_NOMIFS, &
a964 2
    use INIT_TABLES_MODULE, only: L_NONE
    use MLSCommon, only: RK => R8
d1029 1
a1029 1
      L_TOTALEXTINCTION, L_VMR
d1032 1
a1032 1
      & PHYQ_PCTRHI, PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_VELOCITY, &
d1266 3
@


2.117
log
@Added ability to set altitude in forge
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.116 2004/09/27 20:11:05 livesey Exp $"
d44 2
a45 1
  integer, parameter :: P_SUPPRESSCHANNELS   = P_SIGNAL + 1
a257 3
    if ( got ( f_Signal ) .neqv. properties ( p_Signal ) ) &
      & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
      & got(f_Signal) ) ) // ' signal for quantity type ', quantityType )
d263 5
d1056 2
a1057 2
      l_baseline, phyq_temperature, p_flexibleVHGrid, p_fGrid, p_radiometer, &
                  p_mustBeZeta, next, &
d1269 3
@


2.116
log
@Added L1BMAFBaseline
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.115 2004/08/26 18:51:03 pwagner Exp $"
d670 1
a670 1
  subroutine ForgeMinorFrames ( root, chunk, mifGeolocation )
d678 2
a679 2
      & F_SOLARTIME, F_SOLARZENITH
    use INIT_TABLES_MODULE, only: L_NONE, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, &
d685 1
d691 1
d711 1
d714 1
d718 1
d728 2
d773 1
a773 1
    mifGeolocation(instrumentModule)%verticalCoordinate = l_none
d783 7
d1266 3
@


2.115
log
@Failsafe feature for shared fgrids
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.114 2004/08/16 23:42:54 livesey Exp $"
d1004 1
a1004 1
      L_LIMBSIDEBANDFRACTION, L_LOSTRANSFUNC, L_LOSVEL, &
d1095 1
d1252 3
@


2.114
log
@Added p_flexibleVHGrid in order to allow minor frame dependent
baselines.
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.113 2004/06/29 00:09:25 pwagner Exp $"
d73 1
a73 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d78 2
a79 1
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate, &
d295 2
d384 3
d389 8
d400 1
d405 2
d460 1
d1215 2
d1244 1
d1251 4
@


2.113
log
@New phaseTiming type
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.112 2004/06/21 23:58:40 pwagner Exp $"
d33 2
a34 1
  integer, parameter :: P_HGRID              = P_FGRIDOPTIONAL + 1
d100 1
a100 2
    logical :: MAJORFRAME               ! Is a major frame quantity
    logical :: MINORFRAME               ! Is a minor frame quantity
d241 9
a249 7
    if ( got ( f_hGrid ) .neqv. properties ( p_hGrid ) ) &
      & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
      & got(f_hGrid) ) ) // ' hGrid for quantity type ', quantityType, &
      & severity='nonfatal' )
    if ( got ( f_vGrid ) .neqv. properties ( p_vGrid ) ) &
      & call Announce_error ( root, trim ( merge ( 'unexpected', 'need      ', &
      & got(f_vGrid) ) ) // ' vGrid for quantity type ', quantityType )
d279 1
a279 1
    if ( properties ( p_mustBeZeta ) ) then
d317 9
d327 1
a327 1
    if ( properties(p_minorFrame) ) then
d339 1
a339 1
      if ( properties ( p_hGrid ) ) noInstances = hGrids(hGridIndex)%noProfs
d341 1
a341 1
      if ( properties ( p_vGrid ) ) noSurfs = vGrids(vGridIndex)%noSurfs
d350 1
a350 1
      if ( properties(p_hGrid) ) then
d358 1
a358 1
        if ( properties ( p_hGrid )  ) then
d370 1
a370 1
      if ( properties(p_vGrid) ) then
d1021 1
a1021 1
      l_baseline, phyq_temperature, p_hGrid, p_vGrid, p_fGrid, p_radiometer, &
d1144 2
a1145 1
      if ( propertyTable ( p_mustBeZeta, i ) .and. .not. propertyTable ( p_vGrid, i ) ) then
d1230 3
@


2.112
log
@numJ also mad e diagnostic qty that may be written to dgm file
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.111 2004/06/17 23:17:00 pwagner Exp $"
d970 1
a970 1
      L_EARTHREFL, L_ECRTOFOV, L_EFFECTIVEOPTICALDEPTH, &
d978 2
a979 2
      L_NUMJ, L_OPTICALDEPTH, &
      L_ORBITINCLINATION, L_PHITAN, L_PTAN, L_QUALITY, L_RADIANCE, L_EARTHRADIUS,&
d983 2
a984 2
      L_SCVELECR, L_SCGEOCALT, &
      L_SPACERADIANCE, L_STATUS, L_STRAYRADIANCE, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
d1113 2
d1218 3
@


2.111
log
@Retrieval diagnostics freed from need to be l2gp
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.110 2004/05/19 19:16:09 vsnyder Exp $"
d1077 1
a1077 1
      l_numJ, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
d1216 3
@


2.110
log
@Move MLSChunk_t to Chunks_m
@
text
@d1 1
a1 1
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.109 2004/04/16 00:48:52 livesey Exp $"
d243 2
a244 1
      & got(f_hGrid) ) ) // ' hGrid for quantity type ', quantityType )
d784 1
a784 1
  subroutine Announce_Error ( where, message, extra )
d787 1
a787 1
    use OUTPUT_M, only: OUTPUT
d796 2
d799 12
a810 1
    call output ( '***** At ' )
d820 2
a821 1
    call MLSMessage ( MLSMSG_Error, ModuleName, 'Problem in Construct' )
d1029 4
a1032 4
      l_dnwt_ajn, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_axmax, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_cait, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_chisqminnorm, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta /) )
d1035 14
a1048 14
      l_dnwt_chisqnorm, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_diag, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_dxdx, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_dxdxl, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_dxn, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_dxnl, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_flag, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_fnmin, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_fnorm, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_gdx, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_gfac, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_gradn, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_sq, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_dnwt_sqt, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
d1064 2
a1065 2
      l_jacobian_cols, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
      l_jacobian_rows, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
d1216 3
@


2.109
log
@Added singleChannelRadiance type
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.108 2004/03/17 17:16:25 livesey Exp $"
d62 1
d71 1
a71 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, RK => R8
d437 1
d441 1
a441 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8
d645 1
d651 1
a651 1
    use MLSCommon, only: MLSChunk_T, RK => R8
d817 1
d821 1
a821 1
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, RK => R8
d904 1
d906 1
a906 1
    use MLSCommon, only: MLSChunk_T, RK => R8
d1201 3
@


2.108
log
@New cloudMinMax type.
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.107 2004/02/10 21:17:24 livesey Exp $"
d961 1
a961 1
      L_RHI, L_SIZEDISTRIBUTION, &
d1004 2
a1005 1
      l_cloudMinMax, phyq_temperature, p_hGrid, p_vGrid, p_mustbezeta, next, &
d1012 3
a1014 1
      l_dnwt_chisqminnorm, phyq_dimensionless, p_vGrid, p_hGrid, p_mustBeZeta, next, &
d1078 2
d1196 3
@


2.107
log
@Added status and quality as valid quantity types
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.106 2004/01/24 01:03:46 livesey Exp $"
d942 1
a942 1
      L_CLOUDINDUCEDRADIANCE, L_CLOUDEXTINCTION, L_CLOUDRADSENSITIVITY, &
d1004 1
d1191 3
@


2.106
log
@Added the adopted option etc.
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.105 2003/08/08 23:06:53 livesey Exp $"
d959 1
a959 1
      L_ORBITINCLINATION, L_PHITAN, L_PTAN, L_RADIANCE, L_EARTHRADIUS,&
d964 1
a964 1
      L_SPACERADIANCE, L_STRAYRADIANCE, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
d1059 2
a1060 1
    call DefineQtyTypes ( (/ &
d1076 1
d1190 3
@


2.105
log
@Added the fieldStrength etc. quantities.
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.104 2003/07/07 20:22:37 livesey Exp $"
d939 1
a939 1
    use Init_Tables_Module, only:  L_BASELINE, L_BOUNDARYPRESSURE, &
d989 1
d1188 3
@


2.104
log
@Minor bug fix in minor frame quantities
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.103 2003/07/01 23:18:04 livesey Exp $"
d951 3
a953 1
      L_ELEVOFFSET, L_EXTINCTION, L_GPH, L_HEIGHTOFFSET, &
d1033 3
d1187 3
@


2.103
log
@Added setting of grandTotalInstances for minor frame quantities.
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.102 2003/07/01 19:29:32 livesey Exp $"
d539 8
a563 8
        ! Now we're going to fill in the hGrid information
        qty%instanceOffset = chunk%firstMAFIndex + chunk%noMAFsLowerOverlap
        qty%grandTotalInstances = 0
        if ( index(switches,'qtmp') /= 0 ) then
          call output ( "Instance offset for minor frame quantity is:" )
          call output ( qty%instanceOffset, advance='yes' )
        endif

d1182 3
@


2.102
log
@Added filling of grandTotalInstances
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.101 2003/06/27 00:07:07 pwagner Exp $"
d553 4
d558 1
a563 3
        call DeallocateL1BData(l1bfield)

        ! Now we're going to fill in the hGrid information
d1182 3
@


2.101
log
@Made print offset depend on qtmp switch; restored some logs
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.100 2003/06/20 19:37:06 pwagner Exp $"
d347 1
d352 1
d1180 3
@


2.100
log
@Quanities now share grids stored separately in databses
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.99 2003/05/29 18:18:39 livesey Exp $"
d442 1
d444 1
a445 1
    use Output_m, only: OUTPUT
d552 4
a555 2
        call output ( "Instance offset for minor frame quantity is:" )
        call output ( qty%instanceOffset, advance='yes' )
d1176 299
@


2.99
log
@ReflRefl now signal based
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.98 2003/05/29 16:41:42 livesey Exp $"
d64 1
a64 1
    use HGrid, only: hGrid_T
a129 1
    real(rk) :: SCALEFACTOR             ! Probably not used
d140 1
a140 1
    call nullifyQuantityTemplate ( qty ) ! for Sun's rubbish compiler
a153 1
    scaleFactor = 1.0
d288 1
d327 1
a327 1
      noSurfs =1
d333 2
a334 1
        & noChans=noChans )
d336 1
a336 1
      ! Setup the horizontal coordinates or zero if irrelevant
d338 14
a351 9
        call CopyHGridInfoIntoQuantity ( hGrids(hGridIndex), qty )
      else                      ! Set `empty' values
        qty%phi = 0.0
        qty%geodLat = 0.0
        qty%lon = 0.0
        qty%time = 0.0
        qty%solarTime = 0.0
        qty%solarZenith = 0.0
        qty%losAngle = 0.0
d354 5
a358 3
      ! Setup the vertical coordiantes or zero if irrelvant
      if ( properties(p_vGrid) ) then 
        call CopyVGridInfoIntoQuantity ( vGrids(vGridIndex), qty )
d360 1
a360 2
        qty%surfs = 0.0
        qty%verticalCoordinate = l_none
d366 5
d373 2
a374 5
      qty%frequencies = fGrids(fGridIndex)%values
    end if
    if ( properties ( p_sGrid ) ) then
      call Allocate_test ( qty%frequencies, noChans, 'qty%frequencies', ModuleName )
      qty%frequencies = VGrids(sGridIndex)%surfs
a377 1
    qty%badValue = -999.99
a386 1
    qty%scaleFactor = scaleFactor
d395 1
a395 1
      call display_string( lit_indices(qty%quantityType), advance='yes<' )
d442 1
a442 2
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate, &
      & QuantityTemplateCounter
d444 1
d499 2
a507 3
      ! Increment the id counter and set the id field
      quantityTemplateCounter = quantityTemplateCounter + 1
      qty%id = quantityTemplateCounter
a546 8
        call SetupNewQuantityTemplate ( qty, noInstances=noMAFs, &
          & noSurfs=l1bField%maxMIFs, noChans=noChans, coherent=.FALSE., &
          & stacked=.FALSE., regular=regular, instanceLen=instanceLen, &
          & minorFrame=.TRUE. )
        
        qty%noInstancesLowerOverlap = chunk%noMAFsLowerOverlap
        qty%noInstancesUpperOverlap = chunk%noMAFsUpperOverlap
        
d550 4
a553 4
        qty%mafCounter = l1bField%counterMAF
        do mafIndex = chunk%firstMAFIndex, chunk%lastMAFIndex
          qty%mafIndex(mafIndex-chunk%firstMAFIndex+1) = mafIndex
        end do
a619 4
        qty%mafCounter = l1bField%counterMAF
        do mafIndex = chunk%firstMAFIndex, chunk%lastMAFIndex
          qty%mafIndex(mafIndex-chunk%firstMAFIndex+1) = mafIndex
        end do
d716 1
a733 2
    mifGeolocation(instrumentModule)%mafIndex = 0.0
    mifGeolocation(instrumentModule)%mafCounter = 0.0
d854 2
a855 2
  ! ----------------------------------  CopyHGridInfoIntoQuantity  -----
  subroutine CopyHGridInfoIntoQuantity ( My_hGrid, qty )
d859 1
a859 1
    use HGrid, only: hGrid_T
d864 1
a864 1
    type (hGrid_T), intent(in) :: My_hGrid
d868 1
a868 2

    if ( qty%noInstances/=my_hGrid%noProfs ) call MLSMessage ( MLSMSG_Error,&
d870 1
a870 2

    if ( .NOT. qty%stacked ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d873 9
a881 9
    qty%phi(1,:) = my_hGrid%phi
    qty%geodLat(1,:) = my_hGrid%geodLat
    qty%lon(1,:) = my_hGrid%lon
    qty%time(1,:) = my_hGrid%time
    qty%solarTime(1,:) = my_hGrid%solarTime
    qty%solarZenith(1,:) = my_hGrid%solarZenith
    qty%losAngle(1,:) = my_hGrid%losAngle
    qty%noInstancesLowerOverlap = my_hGrid%noProfsLowerOverlap
    qty%noInstancesUpperOverlap = my_hGrid%noProfsUpperOverlap
d883 1
a883 28
  end subroutine CopyHGridInfoIntoQuantity

  ! ----------------------------------  CopyVGridInfoIntoQuantity  -----
  subroutine CopyVGridInfoIntoQuantity ( vGrid, qty )

  ! This similar routine copies VGrid information into an already 
  ! defined quantity

    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use QuantityTemplates, only: QuantityTemplate_T
    use VGridsDatabase, only: VGrid_T

    ! Dummy arguments
    type (VGrid_T), intent(in) :: vGrid
    type (QuantityTemplate_T), intent(inout) :: qty

    ! Executable code

    if ( vGrid%noSurfs /= qty%noSurfs ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Size of vGrid not compatible with size of quantity" )

    if ( .NOT. qty%coherent ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Cannot copy vGrid information into incoherent quantities")

    qty%verticalCoordinate = vGrid%verticalCoordinate
    qty%surfs(:,1) = vGrid%surfs

  end subroutine CopyVGridInfoIntoQuantity
d909 3
a911 1
      & noChans=noChans )
a918 2
    qty%mafIndex => source%mafIndex
    qty%mafCounter => source%mafCounter
a919 1
    qty%verticalCoordinate = l_none
d922 2
a923 1

d1132 39
@


2.98
log
@Tidy ups and new reflector terms
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.97 2003/05/28 05:59:06 livesey Exp $"
d1087 1
a1087 1
      l_reflrefl, phyq_dimensionless, p_reflector, next, &
@


2.97
log
@Added some mustBeZetas
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.96 2003/05/28 05:05:22 livesey Exp $"
d40 2
a41 1
  integer, parameter :: P_SCMODULE           = P_RADIOMETEROPTIONAL + 1
d67 2
a68 19
      & F_SIGNAL, F_TYPE, F_UNIT, F_VGRID
    use INIT_TABLES_MODULE, only: FIRST_LIT, LAST_LIT, L_BASELINE, &
      & L_BOUNDARYPRESSURE, L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, &
      & L_CHISQMMIF, L_CLOUDEXTINCTION, L_CLOUDICE, L_CLOUDINDUCEDRADIANCE, &
      & L_CLOUDRADSENSITIVITY, L_COLUMNABUNDANCE, L_EARTHRADIUS, &
      & L_EARTHREFL, L_ECRTOFOV, L_EFFECTIVEOPTICALDEPTH, L_ELEVOFFSET, L_EXTINCTION, &
      & L_GEODALTITUDE, L_GPH, L_HEIGHTOFFSET, L_LOSTRANSFUNC, L_LOSVEL, &
      & L_MAGNETICFIELD, L_MASSMEANDIAMETERICE, L_MATRIX3X3, L_NOISEBANDWIDTH, L_NONE, &
      & L_NORADSPERMIF, L_OPTICALDEPTH, L_ORBITINCLINATION, &
      & L_PHITAN, L_PTAN, L_RADIANCE, &
      & L_REFGPH, L_RHI, L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, L_SCVEL, &
      & L_SCVELECI, L_SCVELECR, L_SIDEBANDRATIO, L_SPACERADIANCE, &
      & L_SYSTEMTEMPERATURE, L_TEMPERATURE, L_TNGTECI, L_TNGTGEOCALT, &
      & L_TNGTGEODALT, L_TOTALEXTINCTION, L_TRUE, L_VMR, L_XYZ, L_ZETA, &
      & PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_DOBSONUNITS, PHYQ_EXTINCTION, &
      & PHYQ_FREQUENCY, PHYQ_GAUSS, PHYQ_IceDensity, PHYQ_LENGTH, &
      & PHYQ_PCTRHI, PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_VELOCITY, &
      & PHYQ_VMR, PHYQ_ZETA, &
      & FIELD_FIRST, FIELD_LAST
d117 1
d152 1
d221 2
d257 3
d379 1
d970 1
d983 1
a983 1
      L_LOSTRANSFUNC, L_LOSVEL, &
d988 2
a989 1
      L_REFGPH, L_RHI, L_SIZEDISTRIBUTION, &
d991 2
a992 2
      L_SCVELECR, L_SCGEOCALT, L_SIDEBANDRATIO, &
      L_SPACERADIANCE, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
d1020 1
d1066 1
d1085 4
a1096 1
      l_sidebandratio, phyq_dimensionless, p_signal, next, & 
d1099 1
@


2.96
log
@Changed the value of next (worried about clash with phyq_invalid)
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.95 2003/05/28 05:04:20 livesey Exp $"
d1023 2
a1024 1
      l_baseline, phyq_temperature, p_hGrid, p_vGrid, p_fGrid, p_radiometer, next, &
d1027 1
a1027 1
                     p_signal, p_suppressChannels, next, &
d1029 6
a1034 4
      l_chisqMMAF, phyq_dimensionless, p_majorFrame, p_signal, p_suppressChannels, next, &
      l_chisqMMIF, phyq_dimensionless, p_minorFrame, p_signal, p_suppressChannels, next, &
      l_cloudExtinction, phyq_dimensionless, p_hGrid, p_vGrid, next, &
      l_cloudIce, phyq_IceDensity, p_hGrid, p_vGrid, next, &
d1037 1
a1037 1
      l_cloudWater, phyq_dimensionless, p_hGrid, p_vGrid, next, &
d1039 18
a1056 18
      l_dnwt_ajn, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_axmax, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_cait, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_chisqminnorm, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_chisqnorm, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_diag, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_dxdx, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_dxdxl, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_dxn, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_dxnl, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_flag, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_fnmin, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_fnorm, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_gdx, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_gfac, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_gradn, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_sq, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_dnwt_sqt, phyq_dimensionless, p_vGrid, p_hGrid, next, &
d1064 3
a1066 2
      l_extinction, phyq_extinction, p_hGrid, p_vGrid, p_fGrid, p_radiometer, next, &
      l_gph, phyq_length, p_hGrid, p_vGrid, next, &
d1069 2
a1070 2
      l_jacobian_cols, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_jacobian_rows, phyq_dimensionless, p_vGrid, p_hGrid, next, &
d1073 3
a1075 3
      l_magneticField, phyq_gauss, p_vGrid, p_hGrid, p_xyz, next, &
      l_massMeanDiameterIce, phyq_dimensionless, p_vGrid, p_hGrid, next, &
      l_massMeanDiameterWater, phyq_dimensionless, p_vGrid, p_hGrid, next, &
d1077 1
a1077 1
                      p_signal, p_suppressChannels, next, &
d1081 1
a1081 1
      l_numJ, phyq_dimensionless, p_vGrid, p_hGrid, next, &
d1089 2
a1090 2
      l_refGPH, phyq_length, p_hGrid, p_vGrid, next, &
      l_rhi, phyq_dimensionless, p_hGrid, p_vGrid, p_molecule, next, &
d1098 1
a1098 1
      l_sizeDistribution, phyq_dimensionless, p_hGrid, p_vGrid, next, & 
d1102 1
a1102 1
      l_temperature, phyq_temperature, p_hGrid, p_vGrid, next, &
d1107 1
a1107 1
             p_radiometerOptional, next /) )
d1125 5
@


2.95
log
@Cosmetic changes.
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.94 2003/05/28 05:03:58 livesey Exp $"
d26 1
a26 1
  integer, parameter :: NEXT = 0
@


2.94
log
@Changed the Init part a little to improve the readability.
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.93 2003/05/28 04:40:08 livesey Exp $"
d1082 1
@


2.93
log
@Removed obsolete returnStatus
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.92 2003/05/28 04:38:03 livesey Exp $"
d26 1
d253 1
d269 2
a270 1
    ! Now check the 'optional' ones specially
d1022 81
a1102 88
    call DefineQtyType ( l_baseline, phyq_temperature, &
      & (/ p_hGrid, p_vGrid, p_fGrid, p_radiometer /) )
    call DefineQtyType ( l_boundaryPressure, phyq_pressure, (/ p_hGrid /) )
    call DefineQtyType ( l_chisqBinned, phyq_dimensionless, &
      & (/ p_hGrid, p_vGrid, p_signal, p_suppressChannels /) )
    call DefineQtyType ( l_chisqChan, phyq_dimensionless, (/ p_majorFrame, p_signal /) )
    call DefineQtyType ( l_chisqMMAF, phyq_dimensionless, &
      & (/ p_majorFrame, p_signal, p_suppressChannels /) )
    call DefineQtyType ( l_chisqMMIF, phyq_dimensionless, &
      & (/ p_minorFrame, p_signal, p_suppressChannels /) )
    call DefineQtyType ( l_cloudExtinction, phyq_dimensionless, (/ p_hGrid, p_vGrid /) )
    call DefineQtyType ( l_cloudIce, phyq_IceDensity, (/ p_hGrid, p_vGrid /) )
    call DefineQtyType ( l_cloudInducedRadiance, phyq_temperature, &
      & (/ p_minorFrame, p_signal /) )
    call DefineQtyType ( l_cloudRadSensitivity, phyq_temperature, &
      & (/ p_minorFrame, p_signal /) )
    call DefineQtyType ( l_cloudWater, phyq_dimensionless, (/ p_hGrid, p_vGrid /) )
    call DefineQtyType ( l_columnAbundance, phyq_dobsonunits, (/ p_hGrid, p_molecule /) )
    call DefineQtyType ( l_dnwt_ajn, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_axmax, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_cait, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_chisqminnorm, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_chisqnorm, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_diag, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_dxdx, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_dxdxl, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_dxn, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_dxnl, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_flag, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_fnmin, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_fnorm, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_gdx, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_gfac, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_gradn, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_sq, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_dnwt_sqt, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_earthRadius, phyq_length, (/ p_hGrid /) )
    call DefineQtyType ( l_earthRefl, phyq_dimensionless, none )
    call DefineQtyType ( l_ecrToFOV, phyq_dimensionless, (/ p_minorFrame, p_module, &
      & p_matrix3x3 /) )
    call DefineQtyType ( l_effectiveOpticalDepth, phyq_dimensionless, &
      & (/ p_minorFrame, p_signal /) )
    call DefineQtyType ( l_elevOffset, phyq_angle, (/ p_signal /) )
    call DefineQtyType ( l_extinction, phyq_extinction, &
      & (/ p_hGrid, p_vGrid, p_fGrid, p_radiometer /) )
    call DefineQtyType ( l_gph, phyq_length, (/ p_hGrid, p_vGrid /) )
    call DefineQtyType ( l_heightOffset, phyq_length, (/ p_hGrid, p_vGrid /) )
    call DefineQtyType ( l_isotopeRatio, phyq_dimensionless, (/ p_molecule /) )
    call DefineQtyType ( l_jacobian_cols, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_jacobian_rows, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_losTransFunc, phyq_dimensionless, &
      & (/ p_minorFrame, p_sGrid, p_module /) )
    call DefineQtyType ( l_losVel, phyq_dimensionless, (/ p_minorFrame, p_module /) )
    call DefineQtyType ( l_magneticField, phyq_gauss, (/ p_vGrid, p_hGrid, p_xyz /) )
    call DefineQtyType ( l_massMeanDiameterIce, phyq_dimensionless, &
      & (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_massMeanDiameterWater, phyq_dimensionless, &
      & (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_noRadsBinned, phyq_dimensionless, &
      & (/ p_vGrid, p_hGrid, p_signal, p_suppressChannels /) )
    call DefineQtyType ( l_noRadsPerMIF, phyq_dimensionless, &
      & (/ p_minorFrame, p_signal, p_suppressChannels /) )
    call DefineQtyType ( l_noiseBandwidth, phyq_frequency, (/ p_signal /) )
    call DefineQtyType ( l_numJ, phyq_dimensionless, (/ p_vGrid, p_hGrid /) )
    call DefineQtyType ( l_opticalDepth, phyq_dimensionless, (/ p_minorFrame, p_signal /) )
    call DefineQtyType ( l_orbitInclination, phyq_angle, (/ p_minorFrame, p_scModule /) )
    call DefineQtyType ( l_phiTan, phyq_angle, (/ p_minorFrame, p_module /) ) 
    call DefineQtyType ( l_ptan, phyq_zeta, (/ p_minorFrame, p_module /) ) 
    call DefineQtyType ( l_radiance, phyq_temperature, (/ p_minorFrame, p_signal /) ) 
    call DefineQtyType ( l_refGPH, phyq_length, (/ p_hGrid, p_vGrid /) )
    call DefineQtyType ( l_rhi, phyq_dimensionless, (/ p_hGrid, p_vGrid, p_molecule /) )
    call DefineQtyType ( l_scECI, phyq_length, (/ p_minorFrame, p_scModule, p_xyz /) )
    call DefineQtyType ( l_scGeocAlt, phyq_length, (/ p_minorFrame, p_scModule /) )
    call DefineQtyType ( l_scVel, phyq_velocity, (/ p_minorFrame, p_scModule, p_xyz /) )
    call DefineQtyType ( l_scVelECI, phyq_velocity, (/ p_minorFrame, p_scModule, p_xyz /) )
    call DefineQtyType ( l_scVelECR, phyq_velocity, (/ p_minorFrame, p_scModule, p_xyz /) )
    call DefineQtyType ( l_scanResidual, phyq_length, (/ p_minorFrame, p_module /) )
    call DefineQtyType ( l_sidebandratio, phyq_dimensionless, (/ p_signal /) ) 
    call DefineQtyType ( l_sizeDistribution, phyq_dimensionless, (/ p_hGrid, p_vGrid /) ) 
    call DefineQtyType ( l_spaceRadiance, phyq_temperature, none )
    call DefineQtyType ( l_surfaceType, phyq_dimensionless, (/ p_hGrid /) ) 
    call DefineQtyType ( l_systemTemperature, phyq_temperature, (/ p_signal /) )
    call DefineQtyType ( l_temperature, phyq_temperature, (/ p_hGrid, p_vGrid /) )
    call DefineQtyType ( l_tngtECI, phyq_length, (/ p_minorFrame, p_module, p_xyz /) )
    call DefineQtyType ( l_tngtGeocAlt, phyq_length, (/ p_minorFrame, p_module /) )
    call DefineQtyType ( l_tngtGeodAlt, phyq_length, (/ p_minorFrame, p_module /) )
    call DefineQtyType ( l_vmr, phyq_vmr, (/ p_hGrid, p_vGrid, p_fGridOptional, &
      & p_molecule, p_radiometerOptional /) )
d1130 5
a1134 4
    subroutine DefineQtyType ( qtyType, unit, properties )
      integer, intent(in) :: QTYTYPE
      integer, intent(in) :: UNIT
      integer, dimension(:), intent(in) :: PROPERTIES
d1136 21
a1156 5
    ! First init the quantity
      propertyTable ( :, qtyType ) = .false.
      propertyTable ( properties, qtyType ) = .true.
      unitsTable ( qtyType ) = unit
    end subroutine DefineQtyType
@


2.92
log
@Large rewrite to simplify (hopefully) the code.
@
text
@d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.91 2003/05/22 04:04:07 livesey Exp $"
d57 1
a57 1
    & Name, Root, FGrids, VGrids, HGrids, L1bInfo, Chunk, MifGeolocation, returnStatus ) &
a109 1
    integer, intent(out) :: RETURNSTATUS
a152 1
    returnStatus = 0
@


2.91
log
@elevOffset is now a channel dependent rather than radiometer dependent
quantity.
@
text
@d4 1
a4 3
!=============================================================================
module ConstructQuantityTemplates ! Construct templates from user supplied info
!=============================================================================
d6 3
a8 1
  ! This module has various functionality for constructing quantity templates.
d10 1
a10 1
  implicit NONE
d12 1
d16 1
a16 18
! -----     Private declarations     -----------------------------------

  integer :: ERROR
  logical, parameter :: DEEBUG = .FALSE.                 ! Normally FALSE
  logical, parameter :: ALWAYSFIRSTSIGNAL = .FALSE.      ! Normally FALSE
  logical, parameter :: BE_WHINY_ABOUT_IT = .FALSE.      ! Normally FALSE
  integer, parameter :: HOWSEVEREISNOGOODSIGNAL = 0      ! Normally 0

! Error codes for "announce_error"
  integer, parameter :: No_Error_Code = 0
  integer, parameter :: BadUnitMessage =         No_Error_Code+1
  integer, parameter :: InappropriateQuantity =  BadUnitMessage+1
  integer, parameter :: NeedGrid =               InappropriateQuantity+1
  integer, parameter :: NoQuantityType =         NeedGrid+1
  integer, parameter :: UnnecessaryGrid =        NoQuantityType+1
  integer, parameter :: noModule=                UnnecessaryGrid+1

!---------------------------- RCS Ident Info -------------------------------
d18 1
a18 1
       "$Id: ConstructQuantityTemplates.f90,v 2.90 2003/05/10 23:39:25 livesey Exp $"
d23 31
a53 1
!---------------------------------------------------------------------------
d55 1
a55 2
contains ! =====     Public Procedures     =============================
  ! -----------------------------  CreateQtyTemplateFromMLSCFInfo  -----
d57 2
a58 4
    & Name, Root, FGrids, VGrids, HGrids, L1bInfo, Chunk, MifGeolocation, &
    & returnStatus ) &
    result ( QTY )

d78 1
a78 1
      & L_TNGTGEODALT, L_TOTALEXTINCTION, L_TRUE, L_VMR, L_XYZ, &
d82 3
a84 1
      & PHYQ_VMR, PHYQ_ZETA
d88 1
a88 1
      & GetRadiometerFromSignal, GetSignal, Signal_T, SIGNALS, MODULES
a99 3
  ! This routine constructs a vector quantity template based on instructions
  ! passed in an mlscf line.

d110 1
a110 1
    integer, intent(out) :: returnStatus      ! 0 unless trouble
d113 28
d142 4
d147 1
a147 34
    integer :: Family
    integer :: FGridIndex
    logical, save :: First = .true.
    integer :: FrequencyCoordinate
    integer :: HGridIndex
    integer :: I                        ! Loop counter
    integer :: IERR                     ! So display_string doesn't crash and burn
    integer :: InstrumentModule         ! Database index
    integer :: Key            ! Field name, F_... from Init_Tables_Module
    character(len=127) :: SIGNALSTRING
    logical :: LOGBASIS                 ! To place in quantity
    integer :: Molecule
    character(len=127) :: moleculeString
    integer, save :: Natural_Units(first_lit:last_lit)
    integer :: NoInstances
    integer :: NoSurfs
    real(rk) :: MinValue                ! Minimumvalue
    logical :: MinorFrame               ! Is a minor frame quantity
    logical :: MajorFrame               ! Is a major frame quantity
    integer :: NoChans
    integer :: QuantityType
    integer :: Radiometer               ! Database index
    logical :: Regular                  ! Flag
    real(rk) :: ScaleFactor
    integer :: Sideband
    integer :: Signal                   ! Database index
    integer :: s_index
    integer, dimension(:), pointer :: SignalInds ! From parse signal
    type (signal_T) :: SignalInfo       ! Details of the appropriate signal
    integer :: Son                      ! A Son of Root -- an n_assign node
    integer :: Type_Field               ! Index in subtree of "type"
    integer :: Value                    ! Node index of value of field of spec
    integer :: VGridIndex
    integer :: SGridIndex
d150 5
d156 1
a156 5
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_begin ( "CreateQtyTemplateFromMLSCFInfo", root )

! ??? Do we need a GOT_FIELD check like in VGrid, e.g. ???

d159 1
a159 2
    error = 0
    family = 0
a162 1
    regular = .true.
a164 47

    if ( first ) then
      ! Fill NATURAL_UNITS on first call only (it's a SAVE variable)
      first = .false.
      natural_units = 0
      natural_units(l_baseline) =                PHYQ_Temperature
      natural_units(l_boundaryPressure) =        PHYQ_Pressure
      natural_units(l_chisqchan) =               PHYQ_Dimensionless
      natural_units(l_chisqmmaf) =               PHYQ_Dimensionless
      natural_units(l_chisqmmif) =               PHYQ_Dimensionless
      natural_units(l_columnAbundance) =         PHYQ_DobsonUnits
      natural_units(l_cloudice) =                PHYQ_IceDensity
      natural_units(l_cloudextinction) =         PHYQ_Dimensionless
      natural_units(l_totalextinction) =         PHYQ_Dimensionless
      natural_units(l_massmeandiameterice) =     PHYQ_Dimensionless
      natural_units(l_earthRefl) =               PHYQ_Dimensionless
      natural_units(l_elevOffset) =              PHYQ_Angle
      natural_units(l_extinction) =              PHYQ_Extinction
      natural_units(l_gph) =                     PHYQ_Length
      natural_units(l_heightOffset ) =           PHYQ_Length
      natural_units(l_losTransFunc) =            PHYQ_Dimensionless
      natural_units(l_losVel) =                  PHYQ_Velocity
      natural_units(l_orbitInclination) =        PHYQ_Angle
      natural_units(l_noiseBandwidth) =          PHYQ_Frequency
      natural_units(l_phitan) =                  PHYQ_Angle
      natural_units(l_ptan) =                    PHYQ_Zeta
      natural_units(l_radiance) =                PHYQ_Temperature
      natural_units(l_cloudinducedradiance) =    PHYQ_Temperature
      natural_units(l_cloudradsensitivity) =     PHYQ_Temperature
      natural_units(l_effectiveopticaldepth) =   PHYQ_Dimensionless
      natural_units(l_earthradius) =             PHYQ_Length
      natural_units(l_refGPH) =                  PHYQ_Length
      natural_units(l_rhi) =                     PHYQ_PctRHI
      natural_units(l_scGeocAlt ) =              PHYQ_Length
      natural_units(l_scVel) =                   PHYQ_Velocity
      natural_units(l_scVelECI) =                PHYQ_Velocity   
      natural_units(l_scVelECR) =                PHYQ_Velocity   
      natural_units(l_scanResidual ) =           PHYQ_Length
      natural_units(l_spaceRadiance) =           PHYQ_Temperature
      natural_units(l_systemTemperature) =       PHYQ_Temperature
      natural_units(l_temperature) =             PHYQ_Temperature
      natural_units(l_tngtGeocAlt) =             PHYQ_Length
      natural_units(l_tngtGeodAlt) =             PHYQ_Length
      natural_units(l_vmr) =                     PHYQ_Vmr
      natural_units(l_magneticField) =           PHYQ_Gauss
    end if

d168 2
a172 1
    fGridIndex = 0
d174 1
a174 5
    sGridIndex = 0
    signalString = ' '
    moleculeString = ' '

    ! First we'll loop over the MLSCF keys.
d176 2
d186 1
d192 1
a192 1
        hGridIndex = decoration(value) ! node_id(value) == n_spec_args
a201 1
!      case ( f_molecule );          molecule = value  ! I don't understand this
a203 1
        call get_string( sub_rosa(subtree(2,son)), moleculeString, strip=.true. )
d219 1
a219 4
        ! print *, 'Parsed ', trim(signalString), ' for ', size(signalInds), &
        !  & ' bands'
        if ( size(signalInds) == 1 .or. ALWAYSFIRSTSIGNAL &
          & .or. .not. associated(L1bInfo%L1BRADIds) ) then
d224 1
a224 1
            if ( any_good_signaldata ( signalInds(s_index), sideband, &
d226 1
a226 1
          enddo
a227 3
            if ( BE_WHINY_ABOUT_IT ) call announce_error (root, No_Error_Code, &
              & 'Warning: no good signal data found for ' &
              & // trim(signalString), HOWSEVEREISNOGOODSIGNAL)
a239 2
        type_field = son
      case ( f_unit );              scaleFactor = value
d245 49
a293 2
    ! Now we know what the user asked for, try to make sense of it.
    ! First see that the `type' has been defined
d295 2
a296 4
    if ( quantityType == 0 ) call announce_error ( root, noQuantityType )
 
    ! Set defaults for other parameters
    if ( fGridIndex /= 0 ) then
d299 17
d317 1
a317 1
      frequencyCoordinate = L_None
d319 1
d322 8
a329 84
    ! Now, depending on the type, check out stuff and see if it's ok to
    ! first order.

    if ( family == 0 ) family = natural_units(quantityType)
    minorFrame = any(quantityType == (/ l_phiTan, l_Ptan, l_Radiance, &
      & l_cloudInducedRadiance, l_cloudRADSensitivity, l_effectiveOpticalDepth, &
      & l_tngtECI, l_tngtGeodAlt, l_tngtGeocAlt, l_scECI, l_scGeocAlt,&
      & l_scVel, l_scVelECI, l_scVelECR, l_losVel, l_heightOffset, &
      & l_scanResidual, l_chisqmmif, l_opticalDepth, l_orbitInclination, &
      & l_ECRtoFOV, l_noRadsPerMIF /) )

    majorFrame = any(quantityType == (/ l_chisqchan, l_chisqmmaf /) )
 
    ! Here the code splits, for minor frame quantities, we take the information
    ! from the previously constructed MIFGeolocation information.  Otherwise,
    ! we'll probably need to use any supplied vGrid/hGrid information.

    if ( minorFrame ) then

      ! This is a minor frame type quantity.
      if ( (hGridIndex /= 0) .OR. (vGridIndex /= 0 ) ) then
        call announce_error ( root, unnecessaryGrid )
      end if
      if ( instrumentModule == 0 ) then 
        call announce_error ( root, noModule )
      end if

      ! Work out the channel information
      if ( signal /= 0 ) then
        signalInfo = GetSignal(signal)
        noChans = size(signalInfo%frequencies)
        frequencyCoordinate = l_channel
      end if
    
      ! For some cases we know the quantity is an xyz vector, or a 3x3 xyz matrix
      if ( any(quantityType == &
       & (/ l_tngtECI, l_scECI, l_scVel, l_scVelECI, l_scVelECR /)) &
       & ) then
        noChans = 3
        frequencyCoordinate = l_xyz
      end if

      if ( quantityType == l_ECRtoFOV ) then
        noChans = 9
        frequencyCoordinate = l_matrix3X3
      end if

      ! Make absolutely certain template's dimensions are what we want
      if ( any ( quantityType == (/ l_chiSqMMIF, l_noRadsPerMIF /) ) ) then
        noChans = 1
        frequencyCoordinate = l_none
      end if

      ! Construct an empty quantity
      call ConstructMinorFrameQuantity ( l1bInfo, chunk, instrumentModule, &
        & qty, noChans=noChans, mifGeolocation=mifGeolocation, regular=regular )
        
    else if ( majorFrame ) then

      ! This is a major frame type quantity.
      if ( vGridIndex/=0 ) then
        call announce_error ( root, No_Error_Code, &
        &  'No vGrid should be specified for a major frame quantity' )
      end if

      ! Work out the channel information
      if ( signal == 0 ) then
        call announce_error ( root, No_Error_Code, &
        &  'A signal is required for every major frame quantity' )
      else if ( instrumentModule == 0 ) then 
        call announce_error ( root, noModule )
      else
        signalInfo = GetSignal(signal)
        noChans = size(signalInfo%frequencies)
        frequencyCoordinate = l_channel
      end if

      ! Make absolutely certain template's dimensions are what we want
      if ( quantityType == l_chisqMMAF .or. quantityType == l_chisqMMIF ) then
        noChans = 1
        frequencyCoordinate = l_none
      end if

      ! Construct an empty quantity
a331 15
      qty%frequencyCoordinate = frequencyCoordinate
        
   ! for losTransFunc type of quantity 
    else if ( quantityType == l_losTransFunc ) then
      ! replace noChans with no of grid along path which is specified from sGrid
        noChans = VGrids(sGridIndex)%noSurfs
        frequencyCoordinate = l_losTransFunc

       ! Construct an empty quantity
       call ConstructMinorFrameQuantity ( l1bInfo, chunk, instrumentModule, &
        & qty, noChans=noChans )
       call Allocate_test ( qty%frequencies, noChans, 'qty%frequencies', ModuleName )
       
       qty%frequencies = VGrids(sGridIndex)%surfs
        
d333 5
d339 1
a339 27
      ! This is not a minor frame quantity, set it up from FGrids, VGrids and HGrids

      if ( hGridIndex/=0 ) then
        noInstances=hGrids(hGridIndex)%noProfs
      else
        noInstances=1
      end if

      if ( vGridIndex/=0 ) then
        noSurfs=vGrids(vGridIndex)%noSurfs
      else
        noSurfs=1
      end if
      
      ! Some special cases for certain quantities
      select case (quantityType)
      case ( l_SidebandRatio, l_NoiseBandwidth, l_SystemTemperature, l_elevOffset )
        frequencyCoordinate = l_channel
        signalInfo = GetSignal(signal)
        noChans = size ( signalInfo%frequencies ) 
      case ( l_magneticField )
        frequencyCoordinate = l_xyz
        noChans = 3
      case default
      end select
      if ( .not. regular ) call announce_error ( root, no_error_code, &
        & 'Inappropriate irregular quantity request' )
d341 1
a341 1
        & noSurfs=noSurfs, coherent=.TRUE., stacked=.TRUE., regular=.TRUE.,&
a342 1
      ! ??? Note in later versions we'll need to think about channels here
d344 2
a345 1
      if ( hGridIndex /=0 ) then
d357 2
a358 11
      if ( quantityType == l_columnAbundance &
      & .or. &
      &   quantityType == l_boundaryPressure ) then
        if ( vGridIndex/=0 ) then
          call announce_error( root, no_error_code, &
          & 'No vGrid should be specified for column abundance ' &
          & // 'boundary pressure')
        end if
        frequencyCoordinate = L_None
        qty%verticalCoordinate = L_None
      else if ( vGridIndex /= 0 ) then
d362 1
a362 7
        qty%verticalCoordinate = L_None
      end if

      if ( fGridIndex /= 0 ) then
        call Allocate_test ( qty%frequencies, qty%noChans, 'qty%frequencies', &
          & ModuleName )
        qty%frequencies = fGrids(fGridIndex)%values
d364 1
d366 9
d377 2
a378 3
    ! Now fill up the remaining items, e.g. name etc.

    qty%badValue = -999.99              ! Think more about this later NJL !????
d390 3
a392 7
    qty%unit = family

    if ( majorFrame ) then
      qty%minorFrame = .false.
      qty%majorFrame = .true.
    end if
    if ( DEEBUG .or. index(switches,'qtmp') /= 0 ) then
d394 1
a394 1
      call display_string ( qty%name, advance='no', ierr=ierr )
d396 1
a396 1
      call output( qty%quantityType, advance='no' )
d401 5
a405 5
      call output( '   signal string: ', advance='no' )
      call output( trim(signalString), advance='no' )
      call output( '    signal: ', advance='no' )
      if ( qty%signal < 1 ) then
        call output( ' (none available) ', advance='yes' )
d407 1
a407 1
        call display_string ( signals(qty%signal)%name, advance='yes', ierr=ierr )
d409 3
a411 3
      call output( '   Instrument module: ', advance='no' )
      if ( qty%instrumentModule < 1 ) then
        call output( ' (none available) ', advance='yes' )
d413 1
a413 2
        call display_string ( modules(qty%instrumentModule)%name, advance='yes', &
          & ierr=ierr )
a414 4
!      call output( '    Molecule: ', advance='no' )
!      call display_string ( qty%Molecule, advance='yes', ierr=ierr )
      call output( '   molecule string: ', advance='no' )
      call output( trim(moleculeString), advance='yes' )
d423 4
a427 3
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_end ( "CreateQtyTemplateFromMLSCFInfo" )
    returnStatus = error
a430 142
! =====     Private Procedures     =====================================

! -----------------------------------------------  ANNOUNCE_ERROR  -----
  subroutine ANNOUNCE_ERROR ( WHERE, CODE, ExtraMessage, severity )

    use LEXER_CORE, only: PRINT_SOURCE
    use OUTPUT_M, only: OUTPUT
    use TREE, only: SOURCE_REF

    integer, intent(in) :: WHERE   ! Tree node where error was noticed
    integer, intent(in) :: CODE    ! Code for error message
    character (LEN=*), intent(in), optional :: ExtraMessage
    integer, intent(in), optional :: severity

    if ( present(severity) ) then
      error = max(error,severity)
    else
      error = max(error,1)
    end if
    call output ( '***** At ' )
    if ( where > 0 ) then
      call print_source ( source_ref(where) )
    else
      call output ( '(no lcf tree available)' )
    end if
    call output ( ': ' )
    select case ( code )
    case ( badUnitMessage )
      call output ( "Incorrect or absent unit.", advance='yes' )
    case ( InappropriateQuantity )
      call output ( "A quantity inappropriate for this version is specified.", &
                    advance='yes' )
    case ( needGrid )
      call output ( "Quantity needs a vGrid or hGrid.", advance='yes' )
    case ( noQuantityType )
      call output ( "No quantity type specified.", advance='yes' )
    case ( unnecessaryGrid )
      call output ( "Quantity has an unnecessary vGrid or hGrid.", advance='yes' )
    case ( noModule )
      call output ( "No module given or deducible.", advance='yes' )
    case default
      call output ( " command caused an unrecognized programming error", advance='yes' )
    end select
    if ( present(ExtraMessage) ) then
      call output(ExtraMessage, advance='yes')
    end if
  end subroutine ANNOUNCE_ERROR

! -----------------------------------------------  ANY_GOOD_SIGNALDATA  -----
  function ANY_GOOD_SIGNALDATA ( signal, sideband, l1bInfo, Chunk )  result (answer)
  ! Read precision of signal
  ! if all values < 0.0, return FALSE
  ! if no precision data in file, return FALSE
  ! otherwise return true
  ! Arguments

    use Allocate_Deallocate, only: Deallocate_Test
    use L1BData, only: L1BData_T, READL1BDATA, &
      & FindL1BData, AssembleL1BQtyName, PRECISIONSUFFIX
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, RK => R8
    use MLSFiles, only: MLS_HDF_Version
    use MLSL2Options, only: LEVEL1_HDFVERSION
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only: GetSignalName

    integer, intent(in) :: signal
    integer, intent(in) :: sideband
    logical             :: answer
    type (MLSChunk_T), intent(in) :: Chunk
    type (l1bInfo_T), intent(in) :: L1bInfo
  ! Private
    integer :: FileID, flag, noMAFs
    character(len=127)  :: namestring
    type (l1bData_T) :: MY_L1BDATA
    integer :: hdfVersion

  ! Executable
    hdfVersion = mls_hdf_version(trim(l1bInfo%L1BOAFileName), LEVEL1_HDFVERSION)
    if ( hdfversion <= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Illegal hdf version for l1boa file (file missing or non-hdf?)' )
    call GetSignalName ( signal, nameString, &                   
    & sideband=sideband, noChannels=.TRUE. )                     
    nameString = AssembleL1BQtyName ( nameString, hdfVersion, .false. )
    nameString = trim(nameString) // PRECISIONSUFFIX
    fileID = FindL1BData (l1bInfo%l1bRadIDs, nameString, hdfVersion )
    if ( fileID <= 0 ) then
      answer = .false.
      return
    end if
    ! print *, 'About to read ', trim(nameString)
    ! print *, 'From Fileid ', fileID
    call ReadL1BData ( fileID , nameString, my_l1bData, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
      & NeverFail= .true., hdfVersion=hdfVersion )
    if ( flag == 0 ) then
      answer = .not. all (my_l1bData%DpField < 0._rk)
      call deallocate_test(my_l1bData%DpField, trim(nameString), ModuleName)
    else
      answer = .false.
    end if
  end function ANY_GOOD_SIGNALDATA

  ! --------------------------------  ConstructMajorFrameQuantity  -----
  subroutine ConstructMajorFrameQuantity( chunk, instrumentModule, qty, noChans, &
    & mifGeolocation )
    ! Dummy arguments
    use INIT_TABLES_MODULE, only: L_NONE
    use MLSCommon, only: MLSChunk_T, RK => R8
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate

    type (MLSChunk_T), intent(in) :: CHUNK
    integer, intent(in) :: INSTRUMENTMODULE
    type (QuantityTemplate_T), intent(out) :: QTY
    type (QuantityTemplate_T), dimension(:), target :: MIFGEOLOCATION
    integer, intent(in) :: NOCHANS
    ! Local variables
    type (QuantityTemplate_T), pointer :: source
    
    ! Executable code
    source => mifGeolocation(instrumentModule)
    call SetupNewQuantityTemplate ( qty, noInstances=source%noInstances, &
      & noSurfs=1, coherent=.true., stacked=.true., regular=.true., &
      & noChans=noChans )
    qty%phi => source%phi(1:1,:)
    qty%geodLat => source%geodLat(1:1,:)
    qty%lon => source%lon(1:1,:)
    qty%time => source%time(1:1,:)
    qty%solarTime => source%solarTime(1:1,:)
    qty%solarZenith => source%solarZenith(1:1,:)
    qty%losAngle => source%losAngle(1:1,:)
    qty%mafIndex => source%mafIndex
    qty%mafCounter => source%mafCounter

    qty%verticalCoordinate = l_none
    qty%majorFrame = .true.
    qty%minorFrame = .false.

    qty%noInstancesLowerOverlap = chunk%noMAFsLowerOverlap
    qty%noInstancesUpperOverlap = chunk%noMAFsUpperOverlap
  end subroutine ConstructMajorFrameQuantity

d446 1
a446 1
  ! This routine constructs a minor frame based quantity.
d492 1
a530 9
      ! Now noMAFs qty%noInstances, l1bField%maxMIFs is no surfs.
      !print *, 'About to SetupNewQuantityTemplate'
      !print *, 'noInstances ', noMAFs
      !print *, 'noSurfs ', l1bField%maxMIFs
      !if ( present(noChans) ) then
      !  print *, 'noChans ', noChans
      !else
      !  print *, 'noChans not present'
      !end if
a548 2
        ! Now noMAFs qty%noInstances, l1bField%maxMIFs is no surfs.
        
a557 1
        
a566 1
        
a629 1
        
a633 1
        
a634 1
        
a635 1
      
a641 1

d785 84
a928 2

!=============================================================================
d933 216
a1149 296
!=============================================================================

!
! $Log: ConstructQuantityTemplates.f90,v $
! Revision 2.90  2003/05/10 23:39:25  livesey
! Fixed problems with chisqs and noRads
!
! Revision 2.89  2003/05/07 01:00:03  livesey
! More stuff got missed in the merge, was I asleep or something?
!
! Revision 2.88  2003/02/13 19:05:39  vsnyder
! Move USEs from module to procedure scope, cosmetic changes
!
! Revision 2.87  2003/02/12 21:53:48  pwagner
! Fix to errant ANY_GOOD_SIGNALDATA in case of hdf5 files
!
! Revision 2.86  2003/02/07 03:42:50  vsnyder
! Fill NATURAL_UNITS on first call only -- it's a SAVE variable now
!
! Revision 2.85  2003/02/07 03:38:05  vsnyder
! Cosmetic change
!
! Revision 2.84  2003/02/07 00:41:41  livesey
! Bug fix/workaround
!
! Revision 2.83  2003/02/06 23:31:00  livesey
! New approach to Forge
!
! Revision 2.82  2003/01/14 00:40:29  pwagner
! Moved GetQuantityAttributes to L2AUXData
!
! Revision 2.81  2003/01/09 00:09:15  pwagner
! routine GetQuantityAttributes added
!
! Revision 2.80  2003/01/08 23:50:44  livesey
! Added irregular argument
!
! Revision 2.79  2003/01/07 23:46:53  livesey
! Added magnetic field stuff
!
! Revision 2.78  2002/12/11 22:17:05  pwagner
! Added error checks on hdf version
!
! Revision 2.77  2002/11/26 23:37:50  livesey
! Better handling of major frame quantities
!
! Revision 2.76  2002/11/22 12:16:08  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.75  2002/11/13 01:05:03  pwagner
! Actually reads hdf5 radiances
!
! Revision 2.74  2002/10/08 17:36:19  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.73  2002/09/26 18:03:06  livesey
! Changed extinction to a vmr
!
! Revision 2.72  2002/09/25 20:07:55  livesey
! Made -g less verbose
!
! Revision 2.71  2002/09/24 21:37:44  livesey
! Added minValue stuff
!
! Revision 2.70  2002/09/24 00:27:16  pwagner
! Wont bomb if no l1brads; nor whine if no good signals
!
! Revision 2.69  2002/09/18 22:48:32  pwagner
! Chooses signals first band with any good data
!
! Revision 2.68  2002/08/04 16:01:19  mjf
! Added some nullify statements for Sun's rubbish compiler.
!
! Revision 2.67  2002/06/14 16:39:49  livesey
! Orbital inclination now minor frame
!
! Revision 2.66  2002/06/04 22:07:35  livesey
! Added phiTan as a state vector element
!
! Revision 2.65  2002/05/22 19:06:32  jonathan
! added units for cloudextinction(m-1), totalextinction(m-1), and
! massmeandiameterice(micron m) as dimentionless for now, may define
! more clear later
!
! Revision 2.64  2002/05/14 00:27:42  livesey
! New code for system temperatures and noise bandwidths
!
! Revision 2.63  2002/05/07 20:02:54  livesey
! Added noise bandwidth
!
! Revision 2.62  2002/04/10 17:44:22  pwagner
! Added rhi quantity (but is this enough?)
!
! Revision 2.61  2002/03/19 00:51:32  pwagner
! Added new scVel quantity types
!
! Revision 2.60  2002/02/09 21:35:52  livesey
! Added optical depth stuff
!
! Revision 2.59  2001/11/08 00:13:38  livesey
! Sorted out extinction stuff
!
! Revision 2.58  2001/10/31 19:07:25  livesey
! Added fGrid stuff
!
! Revision 2.57  2001/10/12 23:15:05  pwagner
! Fixed biggest erros in diagnostic quantity templates
!
! Revision 2.56  2001/10/02 23:12:50  pwagner
! More chi^2 fixes
!
! Revision 2.55  2001/10/02 20:50:54  livesey
! No longer asserts baseline to be minor frame
!
! Revision 2.54  2001/09/17 23:11:50  pwagner
! Tiny changes for chi^2
!
! Revision 2.53  2001/09/17 21:58:50  livesey
! Added allocate of frequencies if needed
!
! Revision 2.52  2001/09/14 23:30:33  pwagner
! Now constructs major frame quantity templates
!
! Revision 2.51  2001/08/01 00:04:29  dwu
! add qty%frequencies = VGrids(sGridIndex)%surfs for quantity l_losTransFunc
!
! Revision 2.50  2001/07/30 23:28:38  pwagner
! Added columnAbundances scaffolding--needs fleshing out
!
! Revision 2.49  2001/07/26 17:34:25  jonathan
! add DTcir, etc, jonathan
!
! Revision 2.48  2001/07/19 22:17:44  jonathan
! add cloud stuff , jonathan/dwu
!
! Revision 2.47  2001/07/19 17:42:31  dwu
! add sGrid field
!
! Revision 2.46  2001/07/18 23:17:30  dwu
! rename l_radiusofearth as l_earthradius
!
! Revision 2.45  2001/07/18 18:42:19  dwu
! add radiusofearth quantity type
!
! Revision 2.44  2001/07/17 23:23:05  dwu
! make l_losTransFunc as non-minorframe but minorframe-like quantity
!
! Revision 2.43  2001/07/16 18:24:45  dwu
! add feature for losTransFunc type of quantities
!
! Revision 2.42  2001/07/13 18:41:59  dwu
! fix problem after adding losTransFunc
!
! Revision 2.41  2001/07/13 18:10:03  dwu
! add quantity losTransFunc
!
! Revision 2.40  2001/07/11 21:40:00  livesey
! More bug fixes
!
! Revision 2.39  2001/07/10 23:45:16  jonathan
! added cloudicedensity and template for cloudsfwm, paul/jonathan
!
! Revision 2.38  2001/07/09 22:37:23  livesey
! Embarassing memory leak caught!  It's our old friend
! mifGeolocation again.  I'm going to regret trying
! to be this clever!
!
! Revision 2.37  2001/05/31 19:53:56  livesey
! Whoops, debug stuff left in.
!
! Revision 2.36  2001/05/30 23:59:51  livesey
! Thought I'd made this change already.  I'm confused
!
! Revision 2.35  2001/05/30 23:55:28  livesey
! Previous one was debug version, this is correct one.
!
! Revision 2.34  2001/05/30 23:53:01  livesey
! For new version of L1Bdata
!
! Revision 2.33  2001/05/29 23:21:35  livesey
! Changed l_orbitincline to l_orbitinclination
!
! Revision 2.32  2001/05/26 00:20:20  livesey
! Cosmetic changes
!
! Revision 2.31  2001/05/10 01:08:53  livesey
! Changed hGrids and vGrids to pointers, rather than intent(in)
! to allow them to be empty.
!
! Revision 2.30  2001/05/03 23:08:36  livesey
! Added stuff to support scan model items.
!
! Revision 2.29  2001/05/03 20:30:09  vsnyder
! Add a 'nullify' and some cosmetic changes
!
! Revision 2.28  2001/04/26 02:45:25  vsnyder
! Fix up CVS stuff
!
! Revision 2.27  2001/04/26 02:44:17  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 2.26  2001/04/25 20:33:07  livesey
! Minor bug fix, Forge now also zeros surfs.
!
! Revision 2.25  2001/04/25 19:29:49  livesey
! Fixed bug in forge, now sets mafCounter and mafIndex correctly.
!
! Revision 2.24  2001/04/25 00:01:23  livesey
! Bug fix, no default units for scGeocAlt
!
! Revision 2.23  2001/04/24 22:21:17  livesey
! Gave up on latitude for forge
!
! Revision 2.22  2001/04/23 23:25:10  livesey
! Fixed bug in forge
!
! Revision 2.21  2001/04/20 23:11:39  livesey
! Added forge stuff for minor frames
!
! Revision 2.20  2001/04/19 20:30:06  livesey
! Added specific stuff for sideband ratio
!
! Revision 2.19  2001/04/12 23:25:29  vsnyder
! Give "Sideband" an initial value
!
! Revision 2.18  2001/04/12 21:41:42  livesey
! Signal now a string.
!
! Revision 2.17  2001/04/10 22:27:47  vsnyder
! Nullify explicitly instead of with <initialization> so as not to give
! pointers the SAVE attribute.  <initialization> is NOT executed on each
! entry to a procedure.
!
! Revision 2.16  2001/04/07 01:50:48  vsnyder
! Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
! some related stuff to fwdmdl/ForwardModelConfig.
!
! Revision 2.15  2001/03/28 23:48:13  livesey
! Bug fixes zero out some stuff.
!
! Revision 2.14  2001/03/28 18:33:19  livesey
! Fixed bug with logBasis (wasn't initialised!)
!
! Revision 2.13  2001/03/21 02:13:30  livesey
! Bug with logBasis, put in a work around. Will need to fix later
!
! Revision 2.12  2001/03/17 02:23:55  livesey
! Added logBasis (and set value for badData)
!
! Revision 2.11  2001/03/15 21:07:47  vsnyder
! Cross-references between databases are by database index, not tree index
!
! Revision 2.10  2001/03/15 18:41:17  livesey
! Tidied up the frequency coordinate stuff.
!
! Revision 2.9  2001/03/08 21:49:26  livesey
! Added elev_offset
!
! Revision 2.8  2001/03/03 00:08:09  livesey
! Lots of changes mostly with minor frame quantities
!
! Revision 2.7  2001/03/02 01:28:23  livesey
! New quantity types etc.
!
! Revision 2.6  2001/02/28 01:17:04  livesey
! Interim version, on the way to using proper signals stuff
!
! Revision 2.5  2001/02/22 23:37:24  livesey
! Really removed all references to firstIndexChannel
!
! Revision 2.4  2001/02/21 01:09:00  livesey
! Allowed for quantities with no h/v grid
!
! Revision 2.3  2001/02/20 18:43:50  livesey
! Removed all references to firstIndexChannel
!
! Revision 2.2  2001/02/14 00:12:45  livesey
! Removed firstIndexChannel
!
! Revision 2.1  2001/02/09 00:38:22  livesey
! Various updates
!
! Revision 2.0  2000/09/05 18:57:02  ahanzel
! Changing file revision to 2.0.
!
! Revision 1.1  2000/09/02 02:05:03  vsnyder
! Initial entry
!
! Revision 1.13  2000/05/17 23:19:07  lungu
! Added "." between MLSInstrumentModuleNames and l1bItemName.
! Made hGridIndex=0 and vGridIndex=0 upon entry, so it does not "inherit" attributes from previous call.
! Made caseInsensitive=.TRUE. for all searches.
! Added type for QTY_Gph.
! Made stacked=.TRUE. so that CopyHGridInfoIntoQuantity works.
!
@


2.90
log
@Fixed problems with chisqs and noRads
@
text
@d34 1
a34 1
       "$Id: ConstructQuantityTemplates.f90,v 2.89 2003/05/07 01:00:03 livesey Exp $"
d427 1
a427 1
      case ( l_SidebandRatio, l_NoiseBandwidth, l_SystemTemperature )
d1127 3
@


2.89
log
@More stuff got missed in the merge, was I asleep or something?
@
text
@d34 1
a34 1
       "$Id: ConstructQuantityTemplates.f90,v 2.88 2003/02/13 19:05:39 vsnyder Exp $"
d62 2
a63 1
      & L_OPTICALDEPTH, L_ORBITINCLINATION, L_PHITAN, L_PTAN, L_RADIANCE, &
d317 1
a317 1
      & l_ECRtoFOV /) )
d355 6
a363 7

      ! Make absolutely certain template's dimensions are what we want
      if ( quantityType == l_chiSqMMIF ) then
        qty%noChans = 1
        qty%instanceLen = qty%NoSurfs
        qty%frequencyCoordinate = l_none
      end if
d1127 3
@


2.88
log
@Move USEs from module to procedure scope, cosmetic changes
@
text
@d34 1
a34 1
       "$Id: ConstructQuantityTemplates.f90,v 2.87 2003/02/12 21:53:48 pwagner Exp $"
d59 1
a59 1
      & L_EARTHREFL, L_EFFECTIVEOPTICALDEPTH, L_ELEVOFFSET, L_EXTINCTION, &
d61 1
a61 1
      & L_MAGNETICFIELD, L_MASSMEANDIAMETERICE, L_NOISEBANDWIDTH, L_NONE, &
d315 2
a316 1
      & l_scanResidual, l_chisqmmif, l_opticalDepth, l_orbitInclination /) )
d341 1
a341 1
      ! For some cases we know the quantity is an xyz vector
d349 5
d1127 3
@


2.87
log
@Fix to errant ANY_GOOD_SIGNALDATA in case of hdf5 files
@
text
@d5 1
a5 1
MODULE ConstructQuantityTemplates ! Construct templates from user supplied info
d10 1
a10 58
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use EXPR_M, only: EXPR
  use FGrid, only: fGrid_T
  use HGrid, only: hGrid_T
  use INIT_TABLES_MODULE, only: F_GEODANGLE, F_FGRID, F_HGRID, &
    & F_LOGBASIS, F_MINVALUE, F_MODULE, F_MOLECULE, F_NOMIFS, F_RADIOMETER, &
    & F_SIGNAL, F_SGRID, F_TYPE, F_UNIT, F_VGRID, F_IRREGULAR, &
    & F_SOLARTIME, F_SOLARZENITH
  use INIT_TABLES_MODULE, only: &
    FIRST_LIT, LAST_LIT, L_BASELINE, L_BOUNDARYPRESSURE, &
    L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CHUNK, L_CLOUDICE, &
    L_CLOUDEXTINCTION, L_CLOUDWATER, &
    L_TOTALEXTINCTION, L_MASSMEANDIAMETERICE, &
    L_CLOUDINDUCEDRADIANCE, L_CLOUDRADSENSITIVITY, &
    L_COLUMNABUNDANCE, L_DNWT_AJN, L_DNWT_AXMAX, &
    L_DNWT_CAIT, L_DNWT_CHISQMINNORM, L_DNWT_CHISQNORM, L_DNWT_DIAG, &
    L_DNWT_DXDX, L_DNWT_DXDXL, L_DNWT_DXN, L_DNWT_DXNL, L_DNWT_FLAG, &
    L_DNWT_FNMIN, L_DNWT_FNORM, L_DNWT_GDX, L_DNWT_GFAC, L_DNWT_GRADN, &
    L_DNWT_SQ, L_DNWT_SQT, &
    L_EARTHREFL, L_EARTHRADIUS, L_EFFECTIVEOPTICALDEPTH, &
    L_ELEVOFFSET, L_EXTINCTION, L_FREQUENCY, L_GEODALTITUDE, L_GPH, &
    L_HEIGHTOFFSET, L_ITERATION, L_JACOBIAN_COLS, L_JACOBIAN_ROWS, &
    L_LOSTRANSFUNC, L_LOSVEL, L_MAGNETICFIELD, &
    L_MAF, L_MASSMEANDIAMETERICE, L_MASSMEANDIAMETERWATER, L_MIF, &
    L_NOISEBANDWIDTH, L_NONE, L_NUMJ, L_ORBITINCLINATION, L_OPTICALDEPTH, &
    L_PHITAN, L_PTAN, L_RADIANCE, L_RHI, &
    L_REFGPH, L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, L_SCVEL, &
    L_SCVELECI, L_SCVELECR, L_SIDEBANDRATIO, L_SIZEDISTRIBUTION, &
    L_SPACERADIANCE, L_SURFACETYPE, L_SYSTEMTEMPERATURE, &
    L_TEMPERATURE, L_TNGTECI, L_TNGTGEOCALT, L_TNGTGEODALT, &
    L_TRUE,&
    L_VMR, L_XYZ, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_EXTINCTION, &
    PHYQ_FREQUENCY, PHYQ_DOBSONUNITS, PHYQ_IceDensity, PHYQ_LENGTH, PHYQ_PCTRHI, &
    PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_VELOCITY, PHYQ_VMR, &
    PHYQ_ZETA, PHYQ_GAUSS, PHYQ_TIME
  use L1BData, only: L1BData_T, READL1BDATA, DEALLOCATEL1BDATA, &
    & FindL1BData, AssembleL1BQtyName, PRECISIONSUFFIX
  use LEXER_CORE, only: PRINT_SOURCE
  use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, R8
  use MLSFiles, only: mls_hdf_version
  use MLSL2Options, only: LEVEL1_HDFVERSION
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
  use MLSSignals_m, only:  IsModuleSpacecraft, &
    & GetModuleFromRadiometer, GetModuleFromSignal, GetModuleName, &
    & GetRadiometerFromSignal, GetSignal,&
    & GetSignalName, Signal_T, SIGNALS, MODULES
  use OUTPUT_M, only: OUTPUT
  use Parse_Signal_m, only: PARSE_SIGNAL
  use QuantityTemplates, only: QuantityTemplate_T,SetupNewQuantityTemplate, &
    & QuantityTemplateCounter, NullifyQuantityTemplate
  use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
  use TOGGLES, only: GEN, TOGGLE, SWITCHES, LEVELS
  use TRACE_M, only: TRACE_BEGIN, TRACE_END
  use TREE, only: DECORATION, NODE_ID, NSONS, SOURCE_REF, SUB_ROSA, SUBTREE
  use TREE_TYPES, only: N_SET_ONE
  use VGridsDatabase, only: VGrid_T

  implicit none
d34 1
a34 1
       "$Id: ConstructQuantityTemplates.f90,v 2.86 2003/02/07 03:42:50 vsnyder Exp $"
d48 38
d103 1
a103 1
    real(r8), dimension(2) :: EXPR_VALUE
d120 1
a120 1
    real(r8) :: MinValue                ! Minimumvalue
d127 1
a127 1
    real(r8) :: ScaleFactor
d154 1
a154 1
    minValue = -huge ( 0.0_r8 )
d271 1
a271 1
            if (BE_WHINY_ABOUT_IT ) call announce_error (root, No_Error_Code, &
d277 2
a278 2
          endif
        endif
d305 1
a305 1
    endif
d326 1
a326 1
      if ( (hGridIndex /= 0) .OR. (vGridIndex /= 0 )) then
d343 1
a343 1
       &  ) then
d357 1
a357 1
      endif
d359 1
a359 1
    elseif ( majorFrame ) then
d365 1
a365 1
      endif
d371 1
a371 1
      elseif ( instrumentModule == 0 ) then 
d391 1
a391 1
   elseif (quantityType == l_losTransFunc) then
d403 1
a403 1
   else
d451 1
a451 1
      &   quantityType == l_boundaryPressure) then
d456 1
a456 1
        endif
d459 1
a459 1
      elseif ( vGridIndex /= 0 ) then
d493 2
a494 2
    endif
    if ( DEEBUG .or. index(switches,'qtmp') /= 0) then
d510 1
a510 1
      endif
d517 1
a517 1
      endif
d530 1
a530 1
    endif
d541 5
d551 1
a551 1
    if (present(severity)) then
d555 1
a555 1
    endif
d592 10
d610 1
a610 1
    type (l1bData_T) :: L1BDATA
d626 1
a626 1
    endif
d629 9
a637 9
      call ReadL1BData ( fileID , nameString, l1bData, noMAFs, flag, &
        & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
        & NeverFail= .true., hdfVersion=hdfVersion )
      if (flag == 0) then
        answer = .not. all (l1bData%DpField < 0._r8)
        call deallocate_test(l1bData%DpField, trim(nameString), ModuleName)
      else
        answer = .false.
      endif
d644 4
d683 11
d708 1
a708 1
    real(r8), parameter :: SIXTH = 1.0_r8 / 6.0_r8
d769 1
a769 1
      endif
d786 1
a786 1
      !endif
d914 11
a924 1
    
d945 1
a945 1
    real(r8), dimension(:,:), pointer :: VALUES ! An array to fill
d947 1
a947 1
    real(r8), dimension(2) :: EXPR_VALUE ! From tree
d1051 1
a1051 1
  subroutine CopyHGridInfoIntoQuantity ( hGrid, qty )
d1055 4
d1060 1
a1060 1
    type (hGrid_T), intent(in) :: hGrid
d1065 1
a1065 1
    if ( qty%noInstances/=hGrid%noProfs ) call MLSMessage ( MLSMSG_Error,&
d1071 9
a1079 9
    qty%phi(1,:) = hGrid%phi
    qty%geodLat(1,:) = hGrid%geodLat
    qty%lon(1,:) = hGrid%lon
    qty%time(1,:) = hGrid%time
    qty%solarTime(1,:) = hGrid%solarTime
    qty%solarZenith(1,:) = hGrid%solarZenith
    qty%losAngle(1,:) = hGrid%losAngle
    qty%noInstancesLowerOverlap = hGrid%noProfsLowerOverlap
    qty%noInstancesUpperOverlap = hGrid%noProfsUpperOverlap
d1089 4
d1121 3
@


2.87.2.1
log
@Changes merged in from HEAD
@
text
@d5 1
a5 1
module ConstructQuantityTemplates ! Construct templates from user supplied info
d10 58
a67 1
  implicit NONE
d91 1
a91 1
       "$Id: ConstructQuantityTemplates.f90,v 2.88 2003/02/13 19:05:39 vsnyder Exp $"
a104 38
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use EXPR_M, only: EXPR
    use FGrid, only: fGrid_T
    use HGrid, only: hGrid_T
    use INIT_TABLES_MODULE, only:  F_FGRID, F_GEODANGLE, F_HGRID, F_IRREGULAR, &
      & F_LOGBASIS, F_MINVALUE, F_MODULE, F_MOLECULE, F_RADIOMETER, F_SGRID, &
      & F_SIGNAL, F_TYPE, F_UNIT, F_VGRID
    use INIT_TABLES_MODULE, only: FIRST_LIT, LAST_LIT, L_BASELINE, &
      & L_BOUNDARYPRESSURE, L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, &
      & L_CHISQMMIF, L_CLOUDEXTINCTION, L_CLOUDICE, L_CLOUDINDUCEDRADIANCE, &
      & L_CLOUDRADSENSITIVITY, L_COLUMNABUNDANCE, L_EARTHRADIUS, &
      & L_EARTHREFL, L_EFFECTIVEOPTICALDEPTH, L_ELEVOFFSET, L_EXTINCTION, &
      & L_GEODALTITUDE, L_GPH, L_HEIGHTOFFSET, L_LOSTRANSFUNC, L_LOSVEL, &
      & L_MAGNETICFIELD, L_MASSMEANDIAMETERICE, L_NOISEBANDWIDTH, L_NONE, &
      & L_OPTICALDEPTH, L_ORBITINCLINATION, L_PHITAN, L_PTAN, L_RADIANCE, &
      & L_REFGPH, L_RHI, L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, L_SCVEL, &
      & L_SCVELECI, L_SCVELECR, L_SIDEBANDRATIO, L_SPACERADIANCE, &
      & L_SYSTEMTEMPERATURE, L_TEMPERATURE, L_TNGTECI, L_TNGTGEOCALT, &
      & L_TNGTGEODALT, L_TOTALEXTINCTION, L_TRUE, L_VMR, L_XYZ, &
      & PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_DOBSONUNITS, PHYQ_EXTINCTION, &
      & PHYQ_FREQUENCY, PHYQ_GAUSS, PHYQ_IceDensity, PHYQ_LENGTH, &
      & PHYQ_PCTRHI, PHYQ_PRESSURE, PHYQ_TEMPERATURE, PHYQ_VELOCITY, &
      & PHYQ_VMR, PHYQ_ZETA
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only:GetModuleFromRadiometer, GetModuleFromSignal, &
      & GetRadiometerFromSignal, GetSignal, Signal_T, SIGNALS, MODULES
    use OUTPUT_M, only: OUTPUT
    use Parse_Signal_m, only: PARSE_SIGNAL
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate, &
      & NullifyQuantityTemplate
    use STRING_TABLE, only: GET_STRING, DISPLAY_STRING
    use TOGGLES, only: GEN, TOGGLE, SWITCHES, LEVELS
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TREE, only: DECORATION, NODE_ID, NSONS, SUB_ROSA, SUBTREE
    use TREE_TYPES, only: N_SET_ONE
    use VGridsDatabase, only: VGrid_T

d122 1
a122 1
    real(rk), dimension(2) :: EXPR_VALUE
d139 1
a139 1
    real(rk) :: MinValue                ! Minimumvalue
d146 1
a146 1
    real(rk) :: ScaleFactor
d173 1
a173 1
    minValue = -huge ( 0.0_rk )
d290 1
a290 1
            if ( BE_WHINY_ABOUT_IT ) call announce_error (root, No_Error_Code, &
d296 2
a297 2
          end if
        end if
d324 1
a324 1
    end if
d345 1
a345 1
      if ( (hGridIndex /= 0) .OR. (vGridIndex /= 0 ) ) then
d362 1
a362 1
       & ) then
d376 1
a376 1
      end if
d378 1
a378 1
    else if ( majorFrame ) then
d384 1
a384 1
      end if
d390 1
a390 1
      else if ( instrumentModule == 0 ) then 
d410 1
a410 1
    else if ( quantityType == l_losTransFunc ) then
d422 1
a422 1
    else
d470 1
a470 1
      &   quantityType == l_boundaryPressure ) then
d475 1
a475 1
        end if
d478 1
a478 1
      else if ( vGridIndex /= 0 ) then
d512 2
a513 2
    end if
    if ( DEEBUG .or. index(switches,'qtmp') /= 0 ) then
d529 1
a529 1
      end if
d536 1
a536 1
      end if
d549 1
a549 1
    end if
a559 5

    use LEXER_CORE, only: PRINT_SOURCE
    use OUTPUT_M, only: OUTPUT
    use TREE, only: SOURCE_REF

d565 1
a565 1
    if ( present(severity) ) then
d569 1
a569 1
    end if
a605 10

    use Allocate_Deallocate, only: Deallocate_Test
    use L1BData, only: L1BData_T, READL1BDATA, &
      & FindL1BData, AssembleL1BQtyName, PRECISIONSUFFIX
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, RK => R8
    use MLSFiles, only: MLS_HDF_Version
    use MLSL2Options, only: LEVEL1_HDFVERSION
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only: GetSignalName

d614 1
a614 1
    type (l1bData_T) :: MY_L1BDATA
d630 1
a630 1
    end if
d633 9
a641 9
    call ReadL1BData ( fileID , nameString, my_l1bData, noMAFs, flag, &
      & firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex, &
      & NeverFail= .true., hdfVersion=hdfVersion )
    if ( flag == 0 ) then
      answer = .not. all (my_l1bData%DpField < 0._rk)
      call deallocate_test(my_l1bData%DpField, trim(nameString), ModuleName)
    else
      answer = .false.
    end if
a647 4
    use INIT_TABLES_MODULE, only: L_NONE
    use MLSCommon, only: MLSChunk_T, RK => R8
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate

a682 11
    use INIT_TABLES_MODULE, only: L_GEODALTITUDE, L_NONE
    use L1BData, only: L1BData_T, READL1BDATA, DEALLOCATEL1BDATA, &
      & AssembleL1BQtyName
    use MLSCommon, only: L1BInfo_T, MLSChunk_T, NameLen, RK => R8
    use MLSFiles, only: MLS_HDF_Version
    use MLSL2Options, only: LEVEL1_HDFVERSION
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
    use MLSSignals_m, only:  IsModuleSpacecraft, GetModuleName
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate, &
      & QuantityTemplateCounter

d697 1
a697 1
    real(rk), parameter :: SIXTH = 1.0_rk / 6.0_rk
d758 1
a758 1
      end if
d775 1
a775 1
      !end if
d903 1
a903 11

    use EXPR_M, only: EXPR
    use INIT_TABLES_MODULE, only: F_FGRID, F_GEODANGLE, F_MODULE, F_NOMIFS, &
      & F_SOLARTIME, F_SOLARZENITH
    use INIT_TABLES_MODULE, only: L_NONE, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, &
      & PHYQ_TIME
    use MLSCommon, only: MLSChunk_T, RK => R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use QuantityTemplates, only: QuantityTemplate_T, SetupNewQuantityTemplate
    use TREE, only: DECORATION, NSONS, SUBTREE

d924 1
a924 1
    real(rk), dimension(:,:), pointer :: VALUES ! An array to fill
d926 1
a926 1
    real(rk), dimension(2) :: EXPR_VALUE ! From tree
d1030 1
a1030 1
  subroutine CopyHGridInfoIntoQuantity ( My_hGrid, qty )
a1033 4
    use HGrid, only: hGrid_T
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use QuantityTemplates, only: QuantityTemplate_T

d1035 1
a1035 1
    type (hGrid_T), intent(in) :: My_hGrid
d1040 1
a1040 1
    if ( qty%noInstances/=my_hGrid%noProfs ) call MLSMessage ( MLSMSG_Error,&
d1046 9
a1054 9
    qty%phi(1,:) = my_hGrid%phi
    qty%geodLat(1,:) = my_hGrid%geodLat
    qty%lon(1,:) = my_hGrid%lon
    qty%time(1,:) = my_hGrid%time
    qty%solarTime(1,:) = my_hGrid%solarTime
    qty%solarZenith(1,:) = my_hGrid%solarZenith
    qty%losAngle(1,:) = my_hGrid%losAngle
    qty%noInstancesLowerOverlap = my_hGrid%noProfsLowerOverlap
    qty%noInstancesUpperOverlap = my_hGrid%noProfsUpperOverlap
a1063 4
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use QuantityTemplates, only: QuantityTemplate_T
    use VGridsDatabase, only: VGrid_T

a1091 6
! Revision 2.88  2003/02/13 19:05:39  vsnyder
! Move USEs from module to procedure scope, cosmetic changes
!
! Revision 2.87  2003/02/12 21:53:48  pwagner
! Fix to errant ANY_GOOD_SIGNALDATA in case of hdf5 files
!
@


2.87.2.2
log
@Add ECRtoFOV
@
text
@d34 1
a34 1
       "$Id: ConstructQuantityTemplates.f90,v 2.87.2.1 2003/02/13 20:36:06 livesey Exp $"
d56 11
a66 2
      & L_BOUNDARYPRESSURE, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, &
      & L_COLUMNABUNDANCE, L_EXTINCTION, &
a70 11
    use Intrinsic, only: L_CHANNEL, L_CLOUDEXTINCTION, L_CLOUDICE, &
      & L_CLOUDINDUCEDRADIANCE, L_CLOUDRADSENSITIVITY, L_EARTHRADIUS, &
      & L_EARTHREFL, L_ECRTOFOV, L_EFFECTIVEOPTICALDEPTH, L_ELEVOFFSET, &
      & L_GEODALTITUDE, L_GPH, L_HEIGHTOFFSET, L_LOSTRANSFUNC, L_LOSVEL, &
      & L_MAGNETICFIELD, L_MASSMEANDIAMETERICE, L_MATRIX3X3, &
      & L_NOISEBANDWIDTH, L_NONE, L_OPTICALDEPTH, L_ORBITINCLINATION, &
      & L_PHITAN, L_PTAN, L_RADIANCE, L_REFGPH, L_RHI, &
      & L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, L_SCVEL, L_SCVELECI, &
      & L_SCVELECR, L_SIDEBANDRATIO, L_SPACERADIANCE, L_SYSTEMTEMPERATURE, &
      & L_TEMPERATURE, L_TNGTECI, L_TNGTGEOCALT, &
      & L_TNGTGEODALT, L_TOTALEXTINCTION, L_TRUE, L_VMR, L_XYZ
d311 5
a315 6
    minorFrame = any(quantityType == (/ l_chisqmmif, l_cloudInducedRadiance, &
      & l_cloudRADSensitivity, l_ECRtoFOV, l_effectiveOpticalDepth, &
      & l_heightOffset, l_losVel, l_opticalDepth, l_orbitInclination, &
      & l_phiTan, l_Ptan, l_Radiance, l_scanResidual, l_scECI,  l_scGeocAlt, &
      & l_scVel, l_scVelECI, l_scVelECR, l_tngtECI,  l_tngtGeocAlt, &
      & l_tngtGeodAlt /) )
a345 3
      else if ( quantityType == l_ECRtoFOV ) then ! or a 3X3 matrix
        noChans = 9
        frequencyCoordinate = l_matrix3X3
d457 2
a458 2
        frequencyCoordinate = l_none
        qty%verticalCoordinate = l_none
d901 1
a901 1
    qty%frequencyCoordinate = l_none
a1120 3
! Revision 2.87.2.1  2003/02/13 20:36:06  livesey
! Changes merged in from HEAD
!
@


2.86
log
@Fill NATURAL_UNITS on first call only -- it's a SAVE variable now
@
text
@d91 1
a91 1
       "$Id: ConstructQuantityTemplates.f90,v 2.85 2003/02/07 03:38:05 vsnyder Exp $"
d603 2
a604 1
  ! else return true
d615 1
d618 4
d624 1
a624 1
    fileID = FindL1BData (l1bInfo%l1bRadIDs, nameString )
d626 5
d635 1
a635 1
        & NeverFail= .true., hdfVersion=LEVEL1_HDFVERSION )
d1092 3
@


2.85
log
@Cosmetic change
@
text
@d91 1
a91 1
       "$Id: ConstructQuantityTemplates.f90,v 2.84 2003/02/07 00:41:41 livesey Exp $"
d125 1
d136 1
a136 1
    integer :: Natural_Units(first_lit:last_lit)
d176 45
a220 41
    natural_units = 0
    natural_units(l_baseline) =                PHYQ_Temperature
    natural_units(l_boundaryPressure) =        PHYQ_Pressure
    natural_units(l_chisqchan) =               PHYQ_Dimensionless
    natural_units(l_chisqmmaf) =               PHYQ_Dimensionless
    natural_units(l_chisqmmif) =               PHYQ_Dimensionless
    natural_units(l_columnAbundance) =         PHYQ_DobsonUnits
    natural_units(l_cloudice) =                PHYQ_IceDensity
    natural_units(l_cloudextinction) =         PHYQ_Dimensionless
    natural_units(l_totalextinction) =         PHYQ_Dimensionless
    natural_units(l_massmeandiameterice) =     PHYQ_Dimensionless
    natural_units(l_earthRefl) =               PHYQ_Dimensionless
    natural_units(l_elevOffset) =              PHYQ_Angle
    natural_units(l_extinction) =              PHYQ_Extinction
    natural_units(l_gph) =                     PHYQ_Length
    natural_units(l_heightOffset ) =           PHYQ_Length
    natural_units(l_losTransFunc) =            PHYQ_Dimensionless
    natural_units(l_losVel) =                  PHYQ_Velocity
    natural_units(l_orbitInclination) =        PHYQ_Angle
    natural_units(l_noiseBandwidth) =          PHYQ_Frequency
    natural_units(l_phitan) =                  PHYQ_Angle
    natural_units(l_ptan) =                    PHYQ_Zeta
    natural_units(l_radiance) =                PHYQ_Temperature
    natural_units(l_cloudinducedradiance) =    PHYQ_Temperature
    natural_units(l_cloudradsensitivity) =     PHYQ_Temperature
    natural_units(l_effectiveopticaldepth) =   PHYQ_Dimensionless
    natural_units(l_earthradius) =             PHYQ_Length
    natural_units(l_refGPH) =                  PHYQ_Length
    natural_units(l_rhi) =                     PHYQ_PctRHI
    natural_units(l_scGeocAlt ) =              PHYQ_Length
    natural_units(l_scVel) =                   PHYQ_Velocity
    natural_units(l_scVelECI) =                PHYQ_Velocity   
    natural_units(l_scVelECR) =                PHYQ_Velocity   
    natural_units(l_scanResidual ) =           PHYQ_Length
    natural_units(l_spaceRadiance) =           PHYQ_Temperature
    natural_units(l_systemTemperature) =       PHYQ_Temperature
    natural_units(l_temperature) =             PHYQ_Temperature
    natural_units(l_tngtGeocAlt) =             PHYQ_Length
    natural_units(l_tngtGeodAlt) =             PHYQ_Length
    natural_units(l_vmr) =                     PHYQ_Vmr
    natural_units(l_magneticField) =           PHYQ_Gauss
d1081 3
@


2.84
log
@Bug fix/workaround
@
text
@d91 1
a91 1
       "$Id: ConstructQuantityTemplates.f90,v 2.83 2003/02/06 23:31:00 livesey Exp $"
d1076 3
d1135 3
a1137 1
! added units for cloudextinction(m-1), totalextinction(m-1), and massmeandiameterice(micron m) as dimentionless for now, may define more clear later
@


2.83
log
@New approach to Forge
@
text
@a13 1
  use Intrinsic, only: T_NUMERIC
d91 1
a91 1
       "$Id: ConstructQuantityTemplates.f90,v 2.82 2003/01/14 00:40:29 pwagner Exp $"
a905 1
    integer :: TYPE                     ! Type for the values
d996 9
a1004 9
      do maf = 1, noMAFs
        call expr ( subtree ( maf+1, node), expr_units, expr_value, type )
        if ( type /= t_numeric ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Only numerics, not ranges allowed in explicit hGrid' )
        if ( all ( expr_units(1) /= (/ phyq_dimensionless, units /) ) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Invalid units for explicit hGrid' )
        values(:,maf) = expr_value(1)
      end do
d1076 3
@


2.82
log
@Moved GetQuantityAttributes to L2AUXData
@
text
@d14 2
a15 1
  use INIT_TABLES_MODULE, only: F_GEODANGLE, F_FGRID, F_HGRID, F_INCLINATION, &
d17 2
a18 1
    & F_SIGNAL, F_SGRID, F_TYPE, F_UNIT, F_VGRID, F_IRREGULAR
d45 1
a45 1
    PHYQ_ZETA, PHYQ_GAUSS
d92 1
a92 1
       "$Id: ConstructQuantityTemplates.f90,v 2.81 2003/01/09 00:09:15 pwagner Exp $"
d900 1
d903 3
d907 2
d910 1
a911 1

a912 1
    real(r8) :: incline                 ! Orbital inclination
d915 3
d927 4
a933 3
      case ( f_inclination )
        call expr (subtree ( 2, son), expr_units, expr_value )
        incline = expr_value(1)
a936 1
    ! The tree checker will ensure we get all of these
d938 20
a957 1
    noMAFs = nsons(geodAngleNode) - 1
d959 1
d965 1
d971 2
d979 18
d998 9
a1006 8
    mifGeolocation(instrumentModule)%surfs = 0.0
    do maf = 1, noMAFs
      call expr (subtree ( maf+1, geodAngleNode), expr_units, expr_value )
      mifGeolocation(instrumentModule)%phi(:,maf) = expr_value(1)
      mifGeolocation(instrumentModule)%geodLat(:,maf) = &
        & mifGeolocation(instrumentModule)%phi(:,maf) ! Sort this out later
      mifGeolocation(instrumentModule)%mafIndex(maf) = maf + chunk%firstMAFIndex - 1
      mifGeolocation(instrumentModule)%mafCounter(maf) = maf + chunk%firstMAFIndex - 1
d1008 5
a1012 1

d1078 3
@


2.81
log
@routine GetQuantityAttributes added
@
text
@a69 1
  public :: GetQuantityAttributes
d90 1
a90 1
       "$Id: ConstructQuantityTemplates.f90,v 2.80 2003/01/08 23:50:44 livesey Exp $"
a958 150
  ! ----------------------------------  GetQuantityAttributes  -----
  subroutine GetQuantityAttributes ( quantityType, framing, dim_names)

  ! Given a quantity type, e.g. l_vmr,
  ! returns major/minor/neither framing disgnation
  ! and the 3 dimension names, e.g. (/l_channel, l_MIF, l_MAF/)

    ! Dummy arguments
    integer, intent(in)                :: quantityType
    character(len=*), intent(out)      :: framing
    integer, dimension(3), intent(out) :: dim_names

    ! Executable code
    select case (quantityType)                                       
    case ( l_chisqchan )  
      framing = 'major'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_chisqmmaf )  
      framing = 'major'
      dim_names = (/ l_none, l_none, l_MAF /)                  
    case ( l_chisqmmif )  
      framing = 'minor'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_cloudInducedRadiance )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_cloudExtinction )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_cloudRadSensitivity )  
      framing = 'minor'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_cloudWater )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_dnwt_ajn )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_dnwt_axmax )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_dnwt_cait, l_dnwt_chiSqMinNorm, l_dnwt_chiSqNorm, l_dnwt_diag, &
      & l_dnwt_dxdx, l_dnwt_dxdxl, l_dnwt_dxn, l_dnwt_dxnl, l_dnwt_flag, &
      & l_dnwt_fnmin, l_dnwt_fnorm, l_dnwt_gdx, l_dnwt_gfac, l_dnwt_gradn, &
      & l_dnwt_sq, l_dnwt_sqt )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_effectiveOpticalDepth )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_elevOffset )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_heightOffset )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_jacobian_cols )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_jacobian_rows )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_losTransFunc )  
      framing = 'neither'
      dim_names = (/ l_frequency, l_MIF, l_MAF /)                  
    case ( l_losVel )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_massMeanDiameterIce )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_massMeanDiameterWater )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_noiseBandwidth )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_numJ )  
      framing = 'neither'
      dim_names = (/ l_none, l_iteration, l_chunk /)                  
    case ( l_opticalDepth )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_orbitInclination )  
      framing = 'minor'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_phiTan )  
      framing = 'minor'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_ptan )  
      framing = 'minor'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_radiance )  
      framing = 'minor'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_sizedistribution )  
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    case ( l_scanResidual )  
      framing = 'minor'
      dim_names = (/ l_none, l_MIF, l_MAF /)                  
    case ( l_scECI )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_scVel )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_scVelECI )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_scVelECR )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_scGeocAlt )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_sidebandRatio )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_spaceRadiance )  
      framing = 'neither'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_surfacetype )  
      framing = 'neither'
      dim_names = (/ l_none, l_none, l_none /)                  
    case ( l_systemTemperature )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_none /)                  
    case ( l_tngtECI )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_tngtGeodAlt )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_tngtGeocAlt )  
      framing = 'minor'
      dim_names = (/ l_xyz, l_MIF, l_MAF /)                  
    case ( l_totalExtinction )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case ( l_vmr )  
      framing = 'neither'
      dim_names = (/ l_channel, l_none, l_MAF /)                  
    case default                                                     
      framing = 'neither'
      dim_names = (/ l_channel, l_MIF, l_MAF /)                  
    end select                                                       

  end subroutine GetQuantityAttributes

d1022 3
@


2.80
log
@Added irregular argument
@
text
@d1 1
a1 1
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
d19 2
a20 1
    L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CLOUDICE, L_CLOUDEXTINCTION, &
d23 11
a33 4
    L_COLUMNABUNDANCE, L_EARTHREFL, L_EFFECTIVEOPTICALDEPTH, &
    L_EARTHRADIUS, L_ELEVOFFSET, L_EXTINCTION, L_GEODALTITUDE, L_GPH, &
    L_HEIGHTOFFSET, L_LOSTRANSFUNC, L_LOSVEL, L_MAGNETICFIELD, &
    L_NOISEBANDWIDTH, L_NONE, L_ORBITINCLINATION, L_OPTICALDEPTH, &
d36 2
a37 2
    L_SCVELECI, L_SCVELECR, L_SIDEBANDRATIO, &
    L_SPACERADIANCE, L_SYSTEMTEMPERATURE, &
d70 1
d91 1
a91 1
       "$Id: ConstructQuantityTemplates.f90,v 2.79 2003/01/07 23:46:53 livesey Exp $"
d960 150
d1173 3
@


2.79
log
@Added magnetic field stuff
@
text
@d16 1
a16 1
    & F_SIGNAL, F_SGRID, F_TYPE, F_UNIT, F_VGRID
d82 1
a82 1
       "$Id: ConstructQuantityTemplates.f90,v 2.78 2002/12/11 22:17:05 pwagner Exp $"
d135 1
d162 1
d238 2
d355 1
a355 1
        & qty, noChans=noChans, mifGeolocation=mifGeolocation )
d403 1
a403 1
        & qty, noChans=noChans)
d435 2
a436 1

d711 1
d713 5
a717 1
      qty%instanceLen = qty%noChans*qty%noSurfs
d752 3
a754 3
        & noSurfs=l1bField%maxMIFs, noChans=noChans, coherent=.FALSE., &
        & stacked=.FALSE., regular=regular, instanceLen=instanceLen, &
        & minorFrame=.TRUE. )
d1014 3
@


2.78
log
@Added error checks on hdf version
@
text
@d24 1
a24 1
    L_HEIGHTOFFSET, L_LOSTRANSFUNC, L_LOSVEL, &
d35 1
a35 1
    PHYQ_ZETA
d82 1
a82 1
       "$Id: ConstructQuantityTemplates.f90,v 2.77 2002/11/26 23:37:50 livesey Exp $"
d204 1
d426 3
d441 1
a441 1
        qty%geodLAt = 0.0
d1004 3
@


2.77
log
@Better handling of major frame quantities
@
text
@d82 1
a82 1
       "$Id: ConstructQuantityTemplates.f90,v 2.76 2002/11/22 12:16:08 mjf Exp $"
d692 3
d1000 3
@


2.76
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d82 1
a82 1
       "$Id: ConstructQuantityTemplates.f90,v 2.75 2002/11/13 01:05:03 pwagner Exp $"
d378 6
a383 1
      
d386 3
a388 12
      call ConstructMinorFrameQuantity ( l1bInfo, chunk, instrumentModule, &
        & qty, noChans=noChans, mifGeolocation=mifGeolocation )

      ! Make absolutely certain template's dimensions are what we want
      qty%noSurfs = 1
      qty%verticalCoordinate = l_none
      if ( quantityType == l_chiSqMMAF ) then
        qty%noChans = 1
        qty%instanceLen = 1
      elseif ( quantityType == l_chiSqCHAN ) then
        qty%instanceLen = qty%noChans
      endif
d610 35
d997 4
@


2.75
log
@Actually reads hdf5 radiances
@
text
@d50 1
a50 1
    & QuantityTemplateCounter
d82 1
a82 1
       "$Id: ConstructQuantityTemplates.f90,v 2.74 2002/10/08 17:36:19 pwagner Exp $"
d154 1
a154 3
    nullify ( qty%surfs, qty%phi, qty%geodLat, qty%lon, qty%time, &
      & qty%solarTime, qty%solarZenith, qty%losAngle, qty%mafIndex, &
      & qty%mafCounter, qty%frequencies, qty%surfIndex, qty%chanIndex ) ! for Sun's rubbish compiler
d966 3
@


2.74
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d37 1
a37 1
    & FindL1BData, PRECISIONSUFFIX
d40 2
d82 1
a82 1
       "$Id: ConstructQuantityTemplates.f90,v 2.73 2002/09/26 18:03:06 livesey Exp $"
d607 1
a607 1
        & NeverFail= .true. )
d655 1
a655 1
    integer :: noMAFs, l1bFlag, l1bItem, mafIndex, mifIndex
d662 1
d665 3
d688 1
d691 2
a692 1
        & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
d697 8
d716 1
d718 2
a719 1
          & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
d756 1
d759 1
a759 1
            & lastMAF=chunk%lastMafIndex )
d968 3
@


2.73
log
@Changed extinction to a vmr
@
text
@d80 1
a80 1
       "$Id: ConstructQuantityTemplates.f90,v 2.72 2002/09/25 20:07:55 livesey Exp $"
d84 1
d940 4
d949 3
@


2.72
log
@Made -g less verbose
@
text
@d72 1
a72 2
  integer, parameter :: InappropriateExtinction = BadUnitMessage+1
  integer, parameter :: InappropriateQuantity =  InappropriateExtinction+1
d80 1
a80 1
       "$Id: ConstructQuantityTemplates.f90,v 2.71 2002/09/24 21:37:44 livesey Exp $"
a241 2
        if ( molecule == l_extinction ) &
          & call Announce_error ( root, inappropriateExtinction )
a559 3
    case ( InappropriateExtinction )
      call output ( "Extinction is not a valid molecule, use type=extinction instead", &
        advance='yes' )
d944 3
@


2.71
log
@Added minValue stuff
@
text
@d50 1
a50 1
  use TOGGLES, only: GEN, TOGGLE, SWITCHES
d81 1
a81 1
       "$Id: ConstructQuantityTemplates.f90,v 2.70 2002/09/24 00:27:16 pwagner Exp $"
d147 1
a147 1
    if ( toggle(gen) ) &
d533 2
a534 1
    if ( toggle(gen) ) call trace_end ( "CreateQtyTemplateFromMLSCFInfo" )
d950 3
@


2.70
log
@Wont bomb if no l1brads; nor whine if no good signals
@
text
@d15 1
a15 1
    & F_LOGBASIS, F_MODULE, F_MOLECULE, F_NOMIFS, F_RADIOMETER, &
d81 1
a81 1
       "$Id: ConstructQuantityTemplates.f90,v 2.69 2002/09/18 22:48:32 pwagner Exp $"
d110 2
a111 1

d127 1
d161 1
d235 3
d482 1
d949 3
@


2.69
log
@Chooses signals first band with any good data
@
text
@d66 1
d81 1
a81 1
       "$Id: ConstructQuantityTemplates.f90,v 2.68 2002/08/04 16:01:19 mjf Exp $"
d257 2
a258 1
        if ( size(signalInds) == 1 .or. ALWAYSFIRSTSIGNAL ) then
d267 1
a267 1
            call announce_error (root, No_Error_Code, &
d942 3
@


2.68
log
@Added some nullify statements for Sun's rubbish compiler.
@
text
@d36 2
a37 1
  use L1BData, only: L1BData_T, READL1BDATA, DEALLOCATEL1BDATA
d44 1
a44 1
    & Signal_T, SIGNALS, MODULES
d64 3
a66 1
  logical, parameter :: DEEBUG = .FALSE.      ! Normally FALSE
d80 1
a80 1
       "$Id: ConstructQuantityTemplates.f90,v 2.67 2002/06/14 16:39:49 livesey Exp $"
d89 2
a90 1
    & Name, Root, FGrids, VGrids, HGrids, L1bInfo, Chunk, MifGeolocation ) &
d106 1
d133 1
d254 19
a272 1
        signal = signalInds(1)
d525 1
d532 1
a532 1
  subroutine ANNOUNCE_ERROR ( WHERE, CODE, ExtraMessage )
d536 1
d538 5
a542 1
    error = max(error,1)
d575 34
d940 3
@


2.67
log
@Orbital inclination now minor frame
@
text
@d77 1
a77 1
       "$Id: ConstructQuantityTemplates.f90,v 2.66 2002/06/04 22:07:35 livesey Exp $"
d143 3
d876 3
@


2.66
log
@Added phiTan as a state vector element
@
text
@d77 1
a77 1
       "$Id: ConstructQuantityTemplates.f90,v 2.65 2002/05/22 19:06:32 jonathan Exp $"
d282 1
a282 1
      & l_scanResidual, l_chisqmmif, l_opticalDepth /) )
d873 3
@


2.65
log
@added units for cloudextinction(m-1), totalextinction(m-1), and massmeandiameterice(micron m) as dimentionless for now, may define more clear later
@
text
@d26 1
a26 1
    L_PTAN, L_RADIANCE, L_RHI, &
d77 1
a77 1
       "$Id: ConstructQuantityTemplates.f90,v 2.64 2002/05/14 00:27:42 livesey Exp $"
d171 1
d278 1
a278 1
    minorFrame = any(quantityType == (/ l_Ptan, l_Radiance, &
d873 3
@


2.64
log
@New code for system temperatures and noise bandwidths
@
text
@d19 2
a20 1
    L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CLOUDICE,&
d77 1
a77 1
       "$Id: ConstructQuantityTemplates.f90,v 2.63 2002/05/07 20:02:54 livesey Exp $"
d159 3
d872 3
@


2.64.2.1
log
@*** empty log message ***
@
text
@d19 1
a19 2
    L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CLOUDICE, L_CLOUDEXTINCTION, &
    L_TOTALEXTINCTION, L_MASSMEANDIAMETERICE, &
d76 1
a76 1
       "$Id: ConstructQuantityTemplates.f90,v 2.65 2002/05/22 19:06:32 jonathan Exp $"
a157 3
    natural_units(l_cloudextinction) =         PHYQ_Dimensionless
    natural_units(l_totalextinction) =         PHYQ_Dimensionless
    natural_units(l_massmeandiameterice) =     PHYQ_Dimensionless
a867 6
! Revision 2.65  2002/05/22 19:06:32  jonathan
! added units for cloudextinction(m-1), totalextinction(m-1), and massmeandiameterice(micron m) as dimentionless for now, may define more clear later
!
! Revision 2.64  2002/05/14 00:27:42  livesey
! New code for system temperatures and noise bandwidths
!
@


2.63
log
@Added noise bandwidth
@
text
@d28 1
a28 1
    L_SPACERADIANCE, &
d32 1
a32 1
    PHYQ_DOBSONUNITS, PHYQ_IceDensity, PHYQ_LENGTH, PHYQ_PCTRHI, &
d76 1
a76 1
       "$Id: ConstructQuantityTemplates.f90,v 2.62 2002/04/10 17:44:22 pwagner Exp $"
d166 1
d181 1
d387 1
a387 1
      case ( l_SidebandRatio, l_NoiseBandwidth )
d868 3
@


2.62
log
@Added rhi quantity (but is this enough?)
@
text
@d24 1
a24 1
    L_NONE, L_ORBITINCLINATION, L_OPTICALDEPTH, &
d76 1
a76 1
       "$Id: ConstructQuantityTemplates.f90,v 2.61 2002/03/19 00:51:32 pwagner Exp $"
d385 1
a385 1
      case (l_sidebandRatio)
d866 3
@


2.61
log
@Added new scVel quantity types
@
text
@d25 1
a25 1
    L_PTAN, L_RADIANCE, &
d32 3
a34 2
    PHYQ_DOBSONUNITS, PHYQ_IceDensity, PHYQ_LENGTH, PHYQ_PRESSURE, &
    PHYQ_TEMPERATURE, PHYQ_VELOCITY, PHYQ_VMR, PHYQ_ZETA
d76 1
a76 1
       "$Id: ConstructQuantityTemplates.f90,v 2.60 2002/02/09 21:35:52 livesey Exp $"
d173 1
d866 3
@


2.60
log
@Added optical depth stuff
@
text
@d26 2
a27 1
    L_REFGPH, L_SCANRESIDUAL, L_SCECI, L_SCGEOCALT, L_SCVEL, L_SIDEBANDRATIO, &
d75 1
a75 1
       "$Id: ConstructQuantityTemplates.f90,v 2.59 2001/11/08 00:13:38 livesey Exp $"
d174 2
d272 2
a273 2
      & l_scVel, l_losVel, l_heightOffset, l_scanResidual, l_chisqmmif, &
      & l_opticalDepth /) )
d299 3
a301 1
      if ( any(quantityType == (/ l_tngtECI, l_scECI, l_scVel /)) ) then
d864 3
@


2.59
log
@Sorted out extinction stuff
@
text
@d24 1
a24 1
    L_NONE, L_ORBITINCLINATION, &
d74 1
a74 1
       "$Id: ConstructQuantityTemplates.f90,v 2.58 2001/10/31 19:07:25 livesey Exp $"
d269 2
a270 1
      & l_scVel, l_losVel, l_heightOffset, l_scanResidual, l_chisqmmif /) )
d859 3
@


2.58
log
@Added fGrid stuff
@
text
@d65 2
a66 1
  integer, parameter :: InappropriateQuantity =  BadUnitMessage+1
d74 1
a74 1
       "$Id: ConstructQuantityTemplates.f90,v 2.57 2001/10/12 23:15:05 pwagner Exp $"
d215 2
d505 3
d858 3
@


2.57
log
@Fixed biggest erros in diagnostic quantity templates
@
text
@d12 1
d14 1
a14 1
  use INIT_TABLES_MODULE, only: F_GEODANGLE, F_HGRID, F_INCLINATION, &
d73 1
a73 1
       "$Id: ConstructQuantityTemplates.f90,v 2.56 2001/10/02 23:12:50 pwagner Exp $"
d82 1
a82 1
    & Name, Root, HGrids, VGrids, L1bInfo, Chunk, MifGeolocation ) &
d91 2
a93 1
    type (VGrid_T), dimension(:), pointer :: VGrids
d102 1
d185 1
d203 2
d249 9
d269 1
a269 5

    ! Set defaults for other parameters
    frequencyCoordinate = L_None
    noChans = 1

d290 1
a290 1
      
a296 1

d305 1
a305 1
        qty%frequencyCoordinate = l_channel
d358 1
a358 1
      ! This is not a minor frame quantity, set it up from VGrids and HGrids
d415 6
d852 3
@


2.56
log
@More chi^2 fixes
@
text
@d39 1
a39 1
    & Signal_T
d45 1
a45 1
  use TOGGLES, only: GEN, TOGGLE
d59 1
d72 1
a72 1
       "$Id: ConstructQuantityTemplates.f90,v 2.54 2001/09/17 23:11:50 pwagner Exp $"
d103 1
d109 1
d184 2
d205 4
a208 1
      case ( f_molecule );          molecule = value
d290 7
d329 2
d426 37
d836 3
@


2.55
log
@No longer asserts baseline to be minor frame
@
text
@a10 1
  use Dump_0, only: Dump
d13 1
a13 1
  use INIT_TABLES_MODULE, only: F_BAND, F_GEODANGLE, F_HGRID, F_INCLINATION, &
d16 1
a16 1
  use INIT_TABLES_MODULE, only: FIELD_FIRST, FIELD_LAST, &
d18 2
a19 2
    L_CHANNEL, L_CHISQCHAN, L_CHISQMMAF, L_CHISQMMIF, L_CLOUDICE,  L_CLOUDWATER,&
    L_CLOUDEXTINCTION, L_CLOUDINDUCEDRADIANCE, L_CLOUDRADSENSITIVITY, &
d22 2
a23 2
    L_HEIGHTOFFSET, L_LOSTRANSFUNC, L_LOSVEL, L_MASSMEANDIAMETERICE, &
    L_MASSMEANDIAMETERWATER, L_NONE, L_ORBITINCLINATION, &
d26 1
a26 1
    L_SIZEDISTRIBUTION, L_SPACERADIANCE, L_SURFACETYPE, &
d28 1
a28 1
    L_TOTALEXTINCTION, L_TRUE,&
d35 1
a35 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Info, MLSMSG_L1BRead
d38 1
a38 1
    & GetRadiometerName, GetRadiometerFromSignal, GetSignal, GetSignalName,&
a48 1
  use Units, only: DEG2RAD, RAD2DEG
a97 2
    logical :: BadUnit
    integer :: Band                     ! Tree index
a120 1
    character (len=80) :: Str
d405 4
d782 3
@


2.54
log
@Tiny changes for chi^2
@
text
@d73 1
a73 1
       "$Id: ConstructQuantityTemplates.f90,v 2.53 2001/09/17 21:58:50 livesey Exp $"
d245 1
a245 1
    minorFrame = any(quantityType == (/ l_Baseline, l_Ptan, l_Radiance, &
d783 3
@


2.53
log
@Added allocate of frequencies if needed
@
text
@d73 1
a73 1
       "$Id: ConstructQuantityTemplates.f90,v 2.52 2001/09/14 23:30:33 pwagner Exp $"
a307 6
      ! For some cases we know the quantity is an xyz vector
      if ( any(quantityType == (/ l_tngtECI, l_scECI, l_scVel /)) ) then
        noChans = 3
        frequencyCoordinate = l_xyz
      end if

d312 2
d316 4
d783 3
@


2.52
log
@Now constructs major frame quantity templates
@
text
@d73 1
a73 1
       "$Id: ConstructQuantityTemplates.f90,v 2.51 2001/08/01 00:04:29 dwu Exp $"
d330 3
a332 2
        
        qty%frequencies = VGrids(sGridIndex)%surfs
d783 3
@


2.51
log
@add qty%frequencies = VGrids(sGridIndex)%surfs for quantity l_losTransFunc
@
text
@d19 1
a19 1
    L_CHANNEL, L_CloudIce,  L_CLOUDWATER,&
d73 1
a73 1
       "$Id: ConstructQuantityTemplates.f90,v 2.50 2001/07/30 23:28:38 pwagner Exp $"
d115 1
d149 3
d248 3
a250 1
      & l_scVel, l_losVel, l_heightOffset, l_scanResidual/) )
d288 33
d322 1
a322 1
   else if (quantityType == l_losTransFunc) then
d782 3
@


2.50
log
@Added columnAbundances scaffolding--needs fleshing out
@
text
@d73 1
a73 1
       "$Id: ConstructQuantityTemplates.f90,v 2.49 2001/07/26 17:34:25 jonathan Exp $"
d290 3
a292 1
        & qty, noChans=noChans, mifGeolocation=mifGeolocation )
d743 3
@


2.49
log
@add DTcir, etc, jonathan
@
text
@d18 2
a19 1
    FIRST_LIT, LAST_LIT, L_BASELINE, L_CHANNEL, L_CloudIce,  L_CLOUDWATER,&
d21 1
a21 1
    L_EARTHREFL, L_EFFECTIVEOPTICALDEPTH, &
d31 1
a31 1
    PHYQ_IceDensity, PHYQ_LENGTH, &
d63 7
a69 6
  integer, parameter :: BadUnitMessage = 1
  integer, parameter :: InappropriateQuantity = 2
  integer, parameter :: NeedGrid = 3
  integer, parameter :: NoQuantityType = 4
  integer, parameter :: UnnecessaryGrid = 5
  integer, parameter :: noModule=6
d73 1
a73 1
       "$Id: ConstructQuantityTemplates.f90,v 2.48 2001/07/19 22:17:44 jonathan Exp $"
d146 27
a172 25
    natural_units(l_baseline) =       PHYQ_Temperature
    natural_units(l_cloudice) =       PHYQ_IceDensity
    natural_units(l_earthRefl) =      PHYQ_Dimensionless
    natural_units(l_elevOffset) =     PHYQ_Angle
    natural_units(l_extinction) =     PHYQ_Extinction
    natural_units(l_gph) =            PHYQ_Length
    natural_units(l_heightOffset ) =  PHYQ_Length
    natural_units(l_losTransFunc) =   PHYQ_Dimensionless
    natural_units(l_losVel) =         PHYQ_Velocity
    natural_units(l_orbitInclination) =   PHYQ_Angle
    natural_units(l_ptan) =           PHYQ_Zeta
    natural_units(l_radiance) =       PHYQ_Temperature
    natural_units(l_cloudinducedradiance) =       PHYQ_Temperature
    natural_units(l_cloudradsensitivity) =       PHYQ_Temperature
    natural_units(l_effectiveopticaldepth) =       PHYQ_Dimensionless
    natural_units(l_earthradius) =    PHYQ_Length
    natural_units(l_refGPH) =         PHYQ_Length
    natural_units(l_scGeocAlt ) =     PHYQ_Length
    natural_units(l_scVel) =          PHYQ_Velocity
    natural_units(l_scanResidual ) =  PHYQ_Length
    natural_units(l_spaceRadiance) =  PHYQ_Temperature
    natural_units(l_temperature) =    PHYQ_Temperature
    natural_units(l_tngtGeocAlt) =    PHYQ_Length
    natural_units(l_tngtGeodAlt) =    PHYQ_Length
    natural_units(l_vmr) =            PHYQ_Vmr
d334 11
a344 1
      if ( vGridIndex /= 0 ) then
d375 1
a375 1
  subroutine ANNOUNCE_ERROR ( WHERE, CODE )
d378 1
d382 5
a386 1
    call print_source ( source_ref(where) )
d402 2
d405 3
d741 3
@


2.48
log
@add cloud stuff , jonathan/dwu
@
text
@d19 2
a20 1
    L_CLOUDEXTINCTION, L_EARTHREFL, &
d71 1
a71 1
       "$Id: ConstructQuantityTemplates.f90,v 2.47 2001/07/19 17:42:31 dwu Exp $"
d156 4
a159 1
    natural_units(l_earthradius) =  PHYQ_Length
d238 1
d717 3
@


2.47
log
@add sGrid field
@
text
@d18 6
a23 4
    FIRST_LIT, LAST_LIT, L_BASELINE, L_CHANNEL, L_CloudIce,  L_EARTHREFL, &
    L_ELEVOFFSET, L_EXTINCTION, L_GEODALTITUDE, L_GPH, &
    L_HEIGHTOFFSET, L_LOSTRANSFUNC, L_LOSVEL, L_NONE, L_ORBITINCLINATION, &
    L_PTAN, L_EARTHRADIUS, L_RADIANCE, &
d25 3
a27 2
    L_SPACERADIANCE, &
    L_TEMPERATURE, L_TNGTECI, L_TNGTGEOCALT, L_TNGTGEODALT, L_TRUE,&
d70 1
a70 1
       "$Id: ConstructQuantityTemplates.f90,v 2.46 2001/07/18 23:17:30 dwu Exp $"
d712 3
@


2.46
log
@rename l_radiusofearth as l_earthradius
@
text
@d16 1
a16 1
    & F_SIGNAL, F_TYPE, F_UNIT, F_VGRID
d67 1
a67 1
       "$Id: ConstructQuantityTemplates.f90,v 2.45 2001/07/18 18:42:19 dwu Exp $"
d122 1
d170 1
d210 2
d270 1
a270 1
   ! for losTransFunc type of quantity
d272 2
a273 2

        noChans = vGrids(vGridIndex)%noSurfs
d709 3
@


2.45
log
@add radiusofearth quantity type
@
text
@d21 1
a21 1
    L_PTAN, L_RADIUSOFEARTH, L_RADIANCE, &
d67 1
a67 1
       "$Id: ConstructQuantityTemplates.f90,v 2.44 2001/07/17 23:23:05 dwu Exp $"
d151 1
a151 1
    natural_units(l_radiusofearth) =  PHYQ_Length
d705 3
@


2.44
log
@make l_losTransFunc as non-minorframe but minorframe-like quantity
@
text
@d21 1
a21 1
    L_PTAN, L_RADIANCE, &
d67 1
a67 1
       "$Id: ConstructQuantityTemplates.f90,v 2.43 2001/07/16 18:24:45 dwu Exp $"
d151 1
d705 3
@


2.43
log
@add feature for losTransFunc type of quantities
@
text
@d67 1
a67 1
       "$Id: ConstructQuantityTemplates.f90,v 2.42 2001/07/13 18:41:59 dwu Exp $"
d227 1
a227 1
      & l_scVel, l_losTransFunc, l_losVel, l_heightOffset, l_scanResidual/) )
d240 1
a240 2
      if ( ((hGridIndex /= 0) .OR. (vGridIndex /= 0 )) &
         &  .AND. quantityType /= l_losTransFunc ) then
d260 8
a267 2
      ! For quantity type l_losTransFunc
      if ( quantityType == l_losTransFunc ) then
a269 1
      end if
d271 2
a272 2
      ! Construct an empty quantity
      call ConstructMinorFrameQuantity ( l1bInfo, chunk, instrumentModule, &
d274 2
a275 1
    else
d704 3
@


2.42
log
@fix problem after adding losTransFunc
@
text
@d67 1
a67 1
       "$Id: ConstructQuantityTemplates.f90,v 2.41 2001/07/13 18:10:03 dwu Exp $"
d240 2
a241 1
      if ( (hGridIndex /= 0) .OR. (vGridIndex /= 0 ) ) then
d261 6
d699 3
@


2.41
log
@add quantity losTransFunc
@
text
@d20 2
a21 1
    L_HEIGHTOFFSET, L_LOSVEL, L_NONE, L_ORBITINCLINATION, L_PTAN, L_RADIANCE, &
d67 1
a67 1
       "$Id: ConstructQuantityTemplates.f90,v 2.40 2001/07/11 21:40:00 livesey Exp $"
a140 1
    natural_units(l_losTransFunc) =   PHYQ_Dimensionless
d146 1
d227 1
a227 1
      & l_scVel, l_losVel, l_heightOffset, l_scanResidual/) )
d692 3
@


2.40
log
@More bug fixes
@
text
@d66 1
a66 1
       "$Id: ConstructQuantityTemplates.f90,v 2.39 2001/07/10 23:45:16 jonathan Exp $"
d140 1
d691 3
@


2.39
log
@added cloudicedensity and template for cloudsfwm, paul/jonathan
@
text
@d37 2
a38 1
  use QuantityTemplates, only: QuantityTemplate_T,SetupNewQuantityTemplate
d66 1
a66 1
       "$Id: ConstructQuantityTemplates.f90,v 2.38 2001/07/09 22:37:23 livesey Exp $"
a275 1

d409 5
d690 3
@


2.38
log
@Embarassing memory leak caught!  It's our old friend
mifGeolocation again.  I'm going to regret trying
to be this clever!
@
text
@d18 1
a18 1
    FIRST_LIT, LAST_LIT, L_BASELINE, L_CHANNEL, L_EARTHREFL, &
d24 2
a25 1
    L_VMR, L_XYZ, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_EXTINCTION, PHYQ_LENGTH,&
d65 1
a65 1
       "$Id: ConstructQuantityTemplates.f90,v 2.37 2001/05/31 19:53:56 livesey Exp $"
d138 1
d685 5
@


2.37
log
@Whoops, debug stuff left in.
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.36 2001/05/30 23:59:51 livesey Exp $"
a404 1

d406 1
a406 24
      call SetupNewQuantityTemplate ( qty, &
        & source=mifGeolocation(instrumentModule), &
        & noChans=noChans,  regular=regular, instanceLen=instanceLen )

      ! Now we're going to deal with a VGrid for this quantity

      qty%verticalCoordinate = l_geodAltitude
      qty%surfs=>mifGeolocation(instrumentModule)%surfs

      ! Now we're going to fill in the hGrid information

      qty%time =>        MIFGeolocation(instrumentModule)%time
      qty%geodLat =>     MIFGeolocation(instrumentModule)%geodLat
      qty%lon =>         MIFGeolocation(instrumentModule)%lon
      qty%phi =>         MIFGeolocation(instrumentModule)%phi
      qty%solarZenith => MIFGeolocation(instrumentModule)%solarZenith
      qty%solarTime =>   MIFGeolocation(instrumentModule)%solarTime
      qty%losAngle =>    MIFGeolocation(instrumentModule)%losAngle
      qty%MAFCounter =>  MIFGeolocation(instrumentModule)%mafCounter
      qty%mafIndex =>    MIFGeolocation(instrumentModule)%mafIndex
      qty%noInstancesLowerOverlap = &
        & MIFGeolocation(instrumentModule)%noInstancesLowerOverlap
      qty%noInstancesUpperOverlap = &
        & MIFGeolocation(instrumentModule)%noInstancesUpperOverlap
d413 1
a413 2
      ! First we read tpGeodalt to get the size of the quantity.

d415 5
a419 13
        l1bItemName = 'scGeocAlt' ! For some reason crashes NAG if use quoted string
        call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
          & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
        if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_L1BRead//l1bItemName )
       
        ! Now noMAFs qty%noInstances, l1bField%maxMIFs is no surfs.
        call SetupNewQuantityTemplate ( qty, noInstances=noMAFs, &
          & noSurfs=l1bField%maxMIFs, noChans=noChans, coherent=.FALSE., &
          & stacked=.FALSE., regular=regular, instanceLen=instanceLen, &
          & minorFrame=.TRUE. )
        qty%noInstancesLowerOverlap = chunk%noMAFsLowerOverlap
        qty%noInstancesUpperOverlap = chunk%noMAFsUpperOverlap
d421 12
a432 10
        ! Later we'll put something here for lat/lon etc, for the moment
        ! just zero it out.
        qty%surfs = 0.0
        qty%phi = 0.0
        qty%geodLat = 0.0
        qty%lon = 0.0
        qty%time = 0.0
        qty%solarTime = 0.0
        qty%solarZenith = 0.0
        qty%losAngle = 0.0
d434 1
a434 8
        qty%mafCounter = l1bField%counterMAF
        do mafIndex = chunk%firstMAFIndex, chunk%lastMAFIndex
          qty%mafIndex(mafIndex-chunk%firstMAFIndex+1) = mafIndex
        end do

        call DeallocateL1BData(l1bfield)
        
      else                                    ! For THz/GHz things
d516 19
a534 1
        end do                      ! Loop over l1b quantities
d536 1
d683 3
@


2.36
log
@Thought I'd made this change already.  I'm confused
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.35 2001/05/30 23:55:28 livesey Exp $"
a445 1
        call DeallocateL1BData(l1bfield)
a479 1
        call DeallocateL1BData(l1bfield)
d702 3
@


2.35
log
@Previous one was debug version, this is correct one.
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.34 2001/05/30 23:53:01 livesey Exp $"
d481 1
a481 1
        call DeallocateL1BData(l1bfield, l1bFlag)
d704 3
@


2.34
log
@For new version of L1Bdata
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.33 2001/05/29 23:21:35 livesey Exp $"
a446 1
        return
d477 5
a481 6
!         call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
!           & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
!         if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & MLSMSG_L1BRead//l1bItemName )
!         call DeallocateL1BData(l1bfield, l1bFlag)
        return
d704 3
@


2.33
log
@Changed l_orbitincline to l_orbitinclination
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.32 2001/05/26 00:20:20 livesey Exp $"
d445 3
a447 1
        
a452 1
        
d472 1
a472 1
        call DeallocateL1BData(l1bfield, l1bFlag)
d478 6
a483 4
        call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
          & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
        if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_L1BRead//l1bItemName )
d503 1
a503 1
        call DeallocateL1BData(l1bfield, l1bFlag)
d557 1
a557 1
          call DeallocateL1BData ( l1bField, l1bFlag )
d706 3
@


2.32
log
@Cosmetic changes
@
text
@d20 1
a20 1
    L_HEIGHTOFFSET, L_LOSVEL, L_NONE, L_ORBITINCLINE, L_PTAN, L_RADIANCE, &
d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.31 2001/05/10 01:08:53 livesey Exp $"
d143 1
a143 1
    natural_units(l_orbitIncline) =   PHYQ_Angle
d703 3
@


2.31
log
@Changed hGrids and vGrids to pointers, rather than intent(in)
to allow them to be empty.
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.30 2001/05/03 23:08:36 livesey Exp $"
d404 1
d431 1
d433 1
d703 4
@


2.30
log
@Added stuff to support scan model items.
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.29 2001/05/03 20:30:09 vsnyder Exp $"
d82 2
a83 2
    type (HGrid_T), dimension(:), intent(in) :: HGrids
    type (VGrid_T), dimension(:), intent(in) :: VGrids
d700 3
@


2.29
log
@Add a 'nullify' and some cosmetic changes
@
text
@d20 3
a22 2
    L_LOSVEL, L_NONE, L_ORBITINCLINE, L_PTAN, L_RADIANCE, &
    L_REFGPH, L_SCECI, L_SCGEOCALT, L_SCVEL, L_SIDEBANDRATIO, L_SPACERADIANCE, &
d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.28 2001/04/26 02:45:25 vsnyder Exp $"
d141 1
d149 1
d222 1
a222 1
      & l_scVel, l_losVel/) )
d700 3
@


2.28
log
@Fix up CVS stuff
@
text
@d63 1
a63 1
       "$Id: $"
d66 1
a66 1
       "$RCSfile: $"
d111 1
a111 1
    integer, dimension(:), pointer :: signalInds=>NULL() ! From parse signal
d126 1
d697 3
@


2.27
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d61 7
a67 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=256) :: Id = &
       "$Id: ConstructQuantityTemplates.f90,v 2.26 2001/04/25 20:33:07 livesey Exp $"
  character (len=*), parameter :: ModuleName= &
       "$RCSfile: ConstructQuantityTemplates.f90,v $"
  !---------------------------------------------------------------------------
d696 3
@


2.26
log
@Minor bug fix, Forge now also zeros surfs.
@
text
@a10 1
  use HGrid, only: hGrid_T
d13 1
d24 1
a24 1
    PHYQ_TEMPERATURE, PHYQ_VELOCITY, PHYQ_VMR, PHYQ_ZETA, SPEC_INDICES
d41 1
a42 2
  use Init_tables_module, ONLY: LIT_INDICES
  use Units, only: DEG2RAD, RAD2DEG
d63 1
a63 1
       "$Id: ConstructQuantityTemplates.f90,v 2.25 2001/04/25 19:29:49 livesey Exp $"
d187 1
a187 1
        call parse_Signal ( signalString, signalInds, spec_indices, &
d695 3
@


2.25
log
@Fixed bug in forge, now sets mafCounter and mafIndex correctly.
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.24 2001/04/25 00:01:23 livesey Exp $"
d625 1
d696 3
@


2.24
log
@Bug fix, no default units for scGeocAlt
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.23 2001/04/24 22:21:17 livesey Exp $"
d560 1
a560 1
  subroutine ForgeMinorFrames ( root, mifGeolocation )
d566 2
a567 1
    integer, intent(in) :: ROOT          ! Tree vertex
d630 2
d695 3
@


2.23
log
@Gave up on latitude for forge
@
text
@d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.22 2001/04/23 23:25:10 livesey Exp $"
d144 1
d692 3
@


2.22
log
@Fixed bug in forge
@
text
@d12 1
d43 1
a43 1
  use Units, only: DEG2RAD
d64 1
a64 1
       "$Id: ConstructQuantityTemplates.f90,v 2.21 2001/04/20 23:11:39 livesey Exp $"
d627 1
a627 2
        &  asin( sin(deg2rad*mifGeolocation(instrumentModule)%phi(:,maf)) * &
        &        sin(deg2rad*incline) )/deg2rad
d691 3
@


2.21
log
@Added forge stuff for minor frames
@
text
@d63 1
a63 1
       "$Id: ConstructQuantityTemplates.f90,v 2.20 2001/04/19 20:30:06 livesey Exp $"
d624 3
a626 3
      mifGeolocation(instrumentModule)%phi(maf,:) = expr_value(1)
      mifGeolocation(instrumentModule)%geodLat(maf,:) = &
        &  asin( sin(deg2rad*mifGeolocation(instrumentModule)%phi(maf,1)) * &
d691 3
@


2.20
log
@Added specific stuff for sideband ratio
@
text
@d12 5
a16 2
  use INIT_TABLES_MODULE, only: F_BAND, F_HGRID, F_LOGBASIS, F_MODULE, &
    F_MOLECULE, F_RADIOMETER, F_SIGNAL, F_TYPE, F_UNIT, F_VGRID, &
d42 1
d47 1
d63 1
a63 1
       "$Id: ConstructQuantityTemplates.f90,v 2.19 2001/04/12 23:25:29 vsnyder Exp $"
d557 75
d691 3
@


2.19
log
@Give "Sideband" an initial value
@
text
@d17 1
a17 1
    L_REFGPH, L_SCECI, L_SCGEOCALT, L_SCVEL, L_SPACERADIANCE, &
d58 1
a58 1
       "$Id: ConstructQuantityTemplates.f90,v 2.18 2001/04/12 21:41:42 livesey Exp $"
d215 1
a246 1
      qty%frequencyCoordinate = frequencyCoordinate
d263 10
d274 2
a275 1
        & noSurfs=noSurfs, coherent=.TRUE., stacked=.TRUE., regular=.TRUE. )
d301 3
a303 1
    qty%unit = family
a307 1
    qty%instrumentmodule = instrumentmodule
d309 2
d312 1
a312 3
    qty%sideband = sideband
    qty%scaleFactor = scaleFactor
    qty%badValue = -999.99              ! Think more about this later NJL !????
d611 3
@


2.18
log
@Signal now a string.
@
text
@d58 1
a58 1
       "$Id: ConstructQuantityTemplates.f90,v 2.17 2001/04/10 22:27:47 vsnyder Exp $"
d66 1
a66 1
    & name, root, hGrids, vGrids, l1bInfo, chunk, mifGeolocation ) &
d75 4
a78 4
    type (HGrid_T), dimension(:), intent(in) :: hGrids
    type (VGrid_T), dimension(:), intent(in) :: vGrids
    type (l1bInfo_T), intent(in) :: l1bInfo
    type (MLSChunk_T), intent(in) :: chunk
d80 1
a80 2
      & mifGeolocation
    CHARACTER (LEN=80) :: str
d103 1
a103 1
    integer :: sideband
d106 1
d108 1
a111 1
    type (Signal_T) :: SignalInfo       ! Details of the appropriate signal
d123 2
a124 1
    vGridIndex = 0
d126 1
a127 1

d133 1
a133 1
    natural_units(l_losVel) =          PHYQ_Velocity
d141 1
a142 1
    natural_units(l_tngtGeocAlt) =    PHYQ_Length
d148 2
a149 1
    instrumentModule = 0
d151 1
a151 2
    logBasis = .false.
    scaleFactor = 1.0
a166 5
      case ( f_vgrid )
        vGridIndex = decoration(value) ! node_id(value) == n_spec_args
      case ( f_type )
        quantityType = value
        type_field = son
d169 2
a170 1
      case ( f_unit );              scaleFactor = value
a174 2
      case ( f_module)
        instrumentModule = decoration(decoration(subtree(2,son)))
d176 2
a177 2
        ! For the moment it is simple, later we'll be more intelligent here
        ! for example, letting the user choose either R1A or R1B.
d179 2
a180 2
        ! Here we would do intelligent stuff to work out which bands
        ! are present, for the moment choose the first
d184 2
a185 2
          call MLSMessage(MLSMSG_Error,ModuleName,&
            & 'Unable to parse signal string')
d188 1
a188 1
        call deallocate_test(signalInds,'signalInds',ModuleName)
d191 6
d209 1
a209 1
    minorFrame=any(quantityType == (/ l_Baseline, l_Ptan, l_Radiance, &
d223 1
a223 1
      if ( (hGridIndex /= 0) .OR. (vGridIndex /= 0 )) then
d231 1
a231 1
      if (signal /= 0) then
d235 1
a235 1
      endif
d238 1
a238 1
      if ( any(quantityType == (/ l_tngtECI, l_scECI, l_scVel /))) then
d241 1
a241 1
      endif
d255 1
a255 1
      endif
d261 1
a261 1
      endif
d267 1
a267 1
      if (hGridIndex /=0 ) then
d277 1
a277 1
      endif
d284 1
a284 1
      endif
d448 1
a448 1
        CALL GetModuleName ( instrumentModule, l1bItemName )
d486 1
a486 1
          endif
d501 6
a506 6
          case(1)
            ! For time we have to do something a little more complicated.
            ! This is a real kludge, and we have to find a way
            ! to do it better in 0.5. Probably simply have time as a minor
            ! frame quantity in L1, or MIF duration. !????
            ! Also note that it fills in times even for non existant MIFs
d514 12
a525 12
          case(2)
            qty%geodLat=l1bField%dpField(1,:,:)
          case(3)
            qty%lon=l1bField%dpField(1,:,:)
          case(4)
            qty%phi=l1bField%dpField(1,:,:)
          case(5)
            qty%solarZenith=l1bField%dpField(1,:,:)
          case(6)
            qty%solarTime=l1bField%dpField(1,:,:)
          case(7)
            qty%losAngle=l1bField%dpField(1,:,:)
d528 1
a528 1
          call DeallocateL1BData(l1bField, l1bFlag)
d599 3
@


2.17
log
@Nullify explicitly instead of with <initialization> so as not to give
pointers the SAVE attribute.  <initialization> is NOT executed on each
entry to a procedure.
@
text
@d10 1
a10 1
  use Allocate_Deallocate, only: Allocate_Test
d20 1
a20 1
    PHYQ_TEMPERATURE, PHYQ_VELOCITY, PHYQ_VMR, PHYQ_ZETA
d30 1
d58 1
a58 1
       "$Id: ConstructQuantityTemplates.f90,v 2.16 2001/04/07 01:50:48 vsnyder Exp $"
d93 1
a93 1
    character(len=127) :: LIT_TEXT
d104 1
d106 1
d181 13
a193 1
        signal = decoration(decoration(subtree(2,son)))
a198 1

d297 1
d598 5
@


2.16
log
@Move some of VGrid to lib/VGridsDatabase.  Move ForwardModelConfig_T and
some related stuff to fwdmdl/ForwardModelConfig.
@
text
@d37 2
a38 2
  use init_tables_module, ONLY: LIT_INDICES
  use dumper, only: dump
d57 1
a57 1
       "$Id: ConstructQuantityTemplates.f90,v 2.15 2001/03/28 23:48:13 livesey Exp $"
d583 4
@


2.15
log
@Bug fixes zero out some stuff.
@
text
@d36 1
a36 1
  use VGrid, only: VGrid_T
d57 1
a57 1
       "$Id: ConstructQuantityTemplates.f90,v 2.14 2001/03/28 18:33:19 livesey Exp $"
d583 3
@


2.14
log
@Fixed bug with logBasis (wasn't initialised!)
@
text
@d57 1
a57 1
       "$Id: ConstructQuantityTemplates.f90,v 2.13 2001/03/21 02:13:30 livesey Exp $"
d412 16
a427 1
        ! Later we'll put something here for lat/lon etc.
d487 1
a487 1
            ! ******* This is a real kludge, and we have to find a way
d489 2
a490 2
            ! frame quantity in L1, or MIF duration.
!
d492 1
a492 1
              do mifIndex = 1, l1bField%maxMIFs
d583 3
@


2.13
log
@Bug with logBasis, put in a work around. Will need to fix later
@
text
@d57 1
a57 1
       "$Id: ConstructQuantityTemplates.f90,v 2.12 2001/03/17 02:23:55 livesey Exp $"
d146 1
d169 1
a169 1
        logBasis = (value == l_true)    ! But this seems to get hosed !???? VAN!!!!
d276 1
a276 5
    call output('In the ideal world I would be setting logBasis to: ')
    call output(logBasis)
    call output(' for ')
    call display_string(name,advance='yes')
    qty%logBasis = .false. ! logBasis
d568 3
@


2.12
log
@Added logBasis (and set value for badData)
@
text
@d38 1
d57 1
a57 1
       "$Id: ConstructQuantityTemplates.f90,v 2.11 2001/03/15 21:07:47 vsnyder Exp $"
d168 1
a168 1
        logBasis = (value == l_true)
d275 5
a279 1
    qty%logBasis = logBasis
d571 3
@


2.11
log
@Cross-references between databases are by database index, not tree index
@
text
@d12 1
a12 1
  use INIT_TABLES_MODULE, only: F_BAND, F_HGRID, F_MODULE, &
d56 1
a56 1
       "$Id: ConstructQuantityTemplates.f90,v 2.10 2001/03/15 18:41:17 livesey Exp $"
d92 1
d152 1
a152 2
      if ( node_id(key) == n_set_one ) then
        key = subtree(1,key)
d166 2
d274 1
d282 1
d566 3
@


2.10
log
@Tidied up the frequency coordinate stuff.
@
text
@d25 1
a25 1
  use MLSSignals_m, only:  GetAllModules, IsModuleSpacecraft, GetModuleIndex, &
d56 1
a56 1
       "$Id: ConstructQuantityTemplates.f90,v 2.9 2001/03/08 21:49:26 livesey Exp $"
d83 5
a87 5
    logical :: BADUNIT
    integer :: BAND                     ! Tree index
    integer :: FAMILY
    integer :: FREQUENCYCOORDINATE
    integer :: HGRIDINDEX
d89 2
a90 2
    integer :: INSTRUMENTMODULE         ! Tree index
    integer :: KEY            ! Field name, F_... from Init_Tables_Module
d92 15
a106 15
    integer :: MOLECULE
    integer :: NATURAL_UNITS(first_lit:last_lit)
    integer :: NOINSTANCES
    integer :: NOSURFS
    logical :: MINORFRAME               ! Is a minor frame quantity
    integer :: NOCHANS
    integer :: QUANTITYTYPE
    integer :: RADIOMETER               ! Tree index
    real(r8) :: SCALEFACTOR
    integer :: SIGNAL                   ! Tree index
    integer :: SON                      ! A Son of Root -- an n_assign node
    integer :: TYPE_FIELD               ! Index in subtree of "type"
    integer :: VALUE                    ! Node index of value of field of spec
    integer :: VGRIDINDEX
    type (Signal_T) :: signalInfo       ! Details of the appropriate signal
d142 1
a142 1
    instrumentModule= 0
d169 1
a169 1
        radiometer = subtree(2,son)
d171 2
a172 1
      case ( f_module);             instrumentModule = subtree(2,son)
d174 1
a174 1
        signal = subtree(2,son)
d204 1
a204 1
      if ( (hGridIndex/=0) .OR. (vGridIndex/=0)) then
d207 1
a207 1
      if ( instrumentModule==0 ) then 
d251 7
a257 7
        qty%phi=0.0
        qty%geodLAt=0.0
        qty%lon=0.0
        qty%time=0.0
        qty%solarTime=0.0
        qty%solarZenith=0.0
        qty%losAngle=0.0
d260 1
a260 1
      if (vGridIndex /=0 ) then
d263 2
a264 2
        qty%surfs=0.0
        qty%verticalCoordinate=L_None
d275 1
a275 1
    qty%instrumentmodule= instrumentmodule
d319 3
a321 3
    type (L1BInfo_T), intent(in) :: l1bInfo ! File handles for l1bdata
    type (MLSChunk_T), intent(in) :: chunk ! The chunk under consideration
    integer, intent(in) :: instrumentModule ! Instrument module
d351 1
a351 1
    integer :: noMAFs, l1bFlag, l1bItem, mafIndex, mifIndex, instrumentModuleIndex
a360 1
      instrumentModuleIndex=GetModuleIndex(instrumentModule)
d362 1
a362 1
        & source=mifGeolocation(instrumentModuleIndex), &
d368 1
a368 1
      qty%surfs=>mifGeolocation(instrumentModuleIndex)%surfs
d372 9
a380 9
      qty%time =>        MIFGeolocation(instrumentModuleIndex)%time
      qty%geodLat =>     MIFGeolocation(instrumentModuleIndex)%geodLat
      qty%lon =>         MIFGeolocation(instrumentModuleIndex)%lon
      qty%phi =>         MIFGeolocation(instrumentModuleIndex)%phi
      qty%solarZenith => MIFGeolocation(instrumentModuleIndex)%solarZenith
      qty%solarTime =>   MIFGeolocation(instrumentModuleIndex)%solarTime
      qty%losAngle =>    MIFGeolocation(instrumentModuleIndex)%losAngle
      qty%MAFCounter =>  MIFGeolocation(instrumentModuleIndex)%mafCounter
      qty%mafIndex =>    MIFGeolocation(instrumentModuleIndex)%mafIndex
d382 1
a382 1
        & MIFGeolocation(instrumentModuleIndex)%noInstancesLowerOverlap
d384 1
a384 1
        & MIFGeolocation(instrumentModuleIndex)%noInstancesUpperOverlap
d391 2
a392 2
      if (IsModuleSpacecraft(instrumentModule)) then
        l1bItemName='scGeocAlt' ! For some reason crashes NAG if use quoted string
d411 1
a411 1
        CALL GetModuleName(instrumentModule,l1bItemName)
d443 3
a445 3
          l1bItemName=l1bItemsToRead(l1bItem)
          if ( l1bItem>=TransitionToModularItems ) then
            call GetModuleName(instrumentModule,l1bItemName)
d448 1
a448 1
            l1bItemName=l1bItemsToRead(l1bItem)
d455 1
a455 1
          if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
d562 3
@


2.9
log
@Added elev_offset
@
text
@d13 7
a19 5
    F_MOLECULE, F_RADIOMETER, F_SIGNAL, F_TYPE, F_UNIT, F_VGRID, FIRST_LIT, LAST_LIT, &
    L_BASELINE, L_EARTHREFL, L_ELEVOFFSET, L_EXTINCTION, L_GEODALTITUDE, L_GPH, &
    L_ORBITINCLINE, L_PTAN, L_RADIANCE, L_REFGPH, L_SCGEOCALT, L_SCVEL, &
    L_SPACERADIANCE, L_TEMPERATURE, L_TNGTGEOCALT, L_TNGTGEODALT, L_TRUE,&
    L_VMR, PHYQ_ANGLE, PHYQ_DIMENSIONLESS, PHYQ_EXTINCTION, PHYQ_LENGTH,&
d27 2
a28 1
    & GetRadiometerName, GetRadiometerFromSignal, GetSignalName
d31 1
a31 1
  use STRING_TABLE, only: GET_STRING
a36 1
  USE Intrinsic, ONLY: L_NONE
d56 1
a56 1
       "$Id: ConstructQuantityTemplates.f90,v 2.8 2001/03/03 00:08:09 livesey Exp $"
d86 1
d96 1
a96 1
    logical :: minorFrame               ! Is a minor frame quantity
d106 1
d127 1
d190 5
a194 1
      & l_tngtGeodAlt, l_tngtGeocAlt, l_scGeocAlt /) )
d210 13
d226 1
a246 2
      qty%frequencyCoordinate = L_None

d278 1
a278 1
    
d562 3
@


2.8
log
@Lots of changes mostly with minor frame quantities
@
text
@d14 5
a18 5
    L_BASELINE, L_EARTHREFL, L_EXTINCTION, L_GEODALTITUDE, L_GPH, L_ORBITINCLINE, &
    L_PTAN, L_RADIANCE, L_REFGPH, L_SCGEOCALT, L_SCVEL, L_SPACERADIANCE, L_TEMPERATURE, &
    L_TNGTGEOCALT, L_TNGTGEODALT, L_TRUE, L_VMR, PHYQ_ANGLE, &
    PHYQ_DIMENSIONLESS, PHYQ_EXTINCTION, PHYQ_LENGTH, PHYQ_TEMPERATURE, &
    PHYQ_VELOCITY, PHYQ_VMR, PHYQ_ZETA
d54 1
a54 1
       "$Id: ConstructQuantityTemplates.f90,v 2.7 2001/03/02 01:28:23 livesey Exp $"
d120 1
d541 3
@


2.7
log
@New quantity types etc.
@
text
@d10 1
d12 2
a13 2
  use INIT_TABLES_MODULE, only: F_BAND, F_HGRID, F_INSTRUMENTMODULE, &
    F_MOLECULE, F_RADIOMETER, F_TYPE, F_UNIT, F_VGRID, FIRST_LIT, LAST_LIT, &
d15 1
a15 1
    L_PTAN, L_RADIANCE, L_REFGPH, L_SCVEL, L_SPACERADIANCE, L_TEMPERATURE, &
d19 1
a19 1
  use L1BData, only: L1BData_T, READL1BDATA
d23 3
a25 1
  use MLSSignals_m, only: Modules
d50 1
d54 1
a54 1
       "$Id: ConstructQuantityTemplates.f90,v 2.6 2001/02/28 01:17:04 livesey Exp $"
d77 1
d82 1
a82 1
    integer :: BAND           ! String index of BAND= value
d85 2
a86 2
    integer :: I              ! Loop counter
    integer :: INSTRUMENTMODULE         ! Index into modules
d96 1
a96 1
    integer :: RADIOMETER               ! Index into radiometers database
d98 1
d137 1
d162 8
a169 3
      case ( f_radiometer );        radiometer = decoration(decoration(subtree(2,son)))
      case ( f_instrumentmodule);   instrumentModule = decoration(decoration(subtree(2,son)))
      case ( f_band );              band = decoration(subtree(2,son))
d173 1
d183 2
a184 19
    select case ( quantityType )
    case ( l_Baseline )
      minorFrame=.FALSE.
    case ( l_Extinction )
      ! ??? Need to think about a family here
      minorFrame=.FALSE.
    case ( l_Gph )
      ! ??? Need to think about a family here
      minorFrame=.FALSE.
    case ( l_Ptan )
      minorFrame=.TRUE.
    case ( l_Radiance )
      minorFrame=.TRUE.
    case ( l_Temperature )
      minorFrame=.FALSE.
    case ( l_Vmr )
      minorFrame=.FALSE.
    case default ! Can't get here if tree_walker works correctly
    end select
d193 6
a198 10
      if ( (hGridIndex/=0) .OR. (vGridIndex/=0)) &
        &  call announce_error ( root, unnecessaryGrid )

      select case ( quantityType )
      case ( l_Ptan )

      case ( l_Radiance )
      case default
        call announce_error ( type_field, inappropriateQuantity )
      end select
a202 1

d254 1
d284 2
d290 1
a290 1
  subroutine ConstructMinorFrameQuantity ( l1bInfo, chunk, instrumentModuleIndex, &
d298 1
a298 1
    integer, intent(in) :: instrumentModuleIndex ! Index into mifGeolocation
d328 1
a328 2

    integer :: noMAFs, l1bFlag, l1bItem, mafIndex, mifIndex
d338 1
a338 1

d369 23
a391 40
      CALL Get_String(modules(instrumentModuleIndex)%name,l1bItemName)
      l1bItemName = TRIM(l1bItemName) // "." // "tpGeodAlt"
      
      call ReadL1BData ( l1bInfo%l1boaid, l1bItemName, l1bField, noMAFs, &
        & l1bFlag, firstMAF=chunk%firstMAFIndex, lastMAF=chunk%lastMAFIndex )
      if ( l1bFlag==-1 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_L1BRead//l1bItemName )

      ! Now noMAFs qty%noInstances, l1bField%maxMIFs is no surfs.

      call SetupNewQuantityTemplate ( qty, noInstances=noMAFs, &
        & noSurfs=l1bField%maxMIFs, noChans=noChans, coherent=.FALSE., &
        & stacked=.FALSE., regular=regular, instanceLen=instanceLen, &
        & minorFrame=.TRUE. )

      qty%noInstancesLowerOverlap = chunk%noMAFsLowerOverlap
      qty%noInstancesUpperOverlap = chunk%noMAFsUpperOverlap

      ! Now we're going to deal with a VGrid for this quantity

      qty%verticalCoordinate = l_geodAltitude
      qty%surfs = l1bField%dpField(1,:,:)  ! Vert coord is tpGeodAlt read above.
      qty%mafCounter = l1bField%counterMAF
      do mafIndex = chunk%firstMAFIndex, chunk%lastMAFIndex
        qty%mafIndex(mafIndex-chunk%firstMAFIndex+1) = mafIndex
      end do

      ! Now we're going to fill in the hGrid information

      do l1bItem = 1, NoL1BItemsToRead
        ! Get the name of the item to read
        l1bItemName=l1bItemsToRead(l1bItem)
        if ( l1bItem>=TransitionToModularItems ) then
          call Get_String(modules(instrumentModuleIndex)%name,l1bItemName)
          l1bItemName = trim(l1bItemName)//'.'//l1bItemsToRead(l1bItem)
        else
          l1bItemName=l1bItemsToRead(l1bItem)
        endif

        ! Read it from the l1boa file
d393 2
a394 3
          & l1bFlag, firstMAF=chunk%firstMafIndex, &
          & lastMAF=chunk%lastMafIndex )
        if ( l1bFlag==-1) call MLSMessage ( MLSMSG_Error, ModuleName, &
d396 58
a453 18

        ! Now we have to save this field in the quantity data.
        ! This is rather a kludgy way of doing it but this worked out the
        ! least boring way to write the code.  See the definition of
        ! L1BItemsToRead above for reference.

        select case(l1bItem)
        case(1)
          ! For time we have to do something a little more complicated.
          ! ******* This is a real kludge, and we have to find a way
          ! to do it better in 0.5. Probably simply have time as a minor
          ! frame quantity in L1, or MIF duration.
          !
          do mafIndex = 1, noMAFs
            do mifIndex = 1, l1bField%maxMIFs
              qty%time(mifIndex,mafIndex) = &
                & l1bField%dpField(1,1,mafIndex) + &
                & (mifIndex-1) * sixth
d455 13
a467 16
          end do
        case(2)
          qty%geodLat=l1bField%dpField(1,:,:)
        case(3)
          qty%lon=l1bField%dpField(1,:,:)
        case(4)
          qty%phi=l1bField%dpField(1,:,:)
        case(5)
          qty%solarZenith=l1bField%dpField(1,:,:)
        case(6)
          qty%solarTime=l1bField%dpField(1,:,:)
        case(7)
          qty%losAngle=l1bField%dpField(1,:,:)
        end select
      end do                      ! Loop over l1b quantities
    endif
d469 4
d474 1
d540 3
@


2.6
log
@Interim version, on the way to using proper signals stuff
@
text
@d13 5
a17 3
    L_BASELINE, L_EXTINCTION, L_GEODALTITUDE, L_GPH, L_PTAN, L_RADIANCE, &
    L_TEMPERATURE, L_TRUE, L_VMR, PHYQ_LENGTH, PHYQ_TEMPERATURE, PHYQ_VMR, &
    PHYQ_ZETA
d22 1
a22 2
  use MLSSignalNomenclature, only: DestroyMLSSignalsInfo, MLSSignal_T, &
    & ParseMLSSignalRequest
d31 1
a31 1
  USE Intrinsic, ONLY: L_NONE, L_THz, L_GHz
d50 1
a50 1
       "$Id: ConstructQuantityTemplates.f90,v 2.5 2001/02/22 23:37:24 livesey Exp $"
d81 1
a81 1
    integer :: INSTRUMENTMODULE
d88 1
a88 1
    logical :: minorFrame       ! Is a minor frame quantity
d91 1
a91 1
    integer :: RADIOMETER     ! String index of RADIOMETER= value
d93 3
a95 4
    type (MLSSignal_T), dimension(:), pointer :: SIGNALS
    integer :: SON            ! A Son of Root -- an n_assign node
    integer :: TYPE_FIELD     ! Index in subtree of "type"
    integer :: VALUE          ! Node index of value of field of spec
d111 16
a126 6
    natural_units( (/     l_baseline,       l_extinction, &
      & l_gph,            l_ptan,           l_radiance, &
      & l_temperature,    l_vmr /) ) = &
                   (/     PHYQ_Temperature, PHYQ_Temperature, &
      & PHYQ_length,      PHYQ_Zeta,        PHYQ_Temperature, &
      & PHYQ_Temperature, PHYQ_Vmr /)
d155 2
a156 2
      case ( f_radiometer );        radiometer = decoration(subtree(2,son))
      case ( f_instrumentmodule);   instrumentModule = decoration(subtree(2,son))
d202 1
a202 4
        call get_string ( radiometer, lit_text, cap=.true. )
        call ParseMLSSignalRequest ( lit_text(2:len_trim(lit_text)-1), signals )
        instrumentModule = signals(1)%instrumentModule
        call DestroyMLSSignalsInfo ( signals )
a203 6
        call get_string ( band, lit_text, cap=.true. )
        call ParseMLSSignalRequest ( lit_text(2:len_trim(lit_text)-1), signals )
        if ( SIZE(signals)>1) call MLSMessage(MLSMSG_Error,ModuleName,&
             & "Only one matching signal allowed: "//lit_text )
        noChans = signals(1)%noChannelsInBand
!       call DestroyMLSSignalsInfo ( signals ) ! Done later
a211 7
      ! Fill what information we can

      if ( quantityType==l_Radiance ) then
        qty%signal = signals(1)
        call DestroyMLSSignalsInfo ( signals )
      end if

d264 1
a264 1

d296 1
a296 1
  subroutine ConstructMinorFrameQuantity ( l1bInfo, chunk, instrumentModule, &
d304 1
a304 1
    integer, intent(in) :: instrumentModule ! L_THz or L_GHz?
d335 1
a335 2
    integer :: noMAFs, l1bFlag, l1bItem, mafIndex, mifIndex, instrumentModuleIndex
    integer, DIMENSION(1) :: instrumentModuleIndexArray
a344 3
       instrumentModuleIndexArray=PACK( (/1,2/), &
            instrumentModule==mifGeolocation%instrumentModule)
       instrumentModuleIndex=instrumentModuleIndexArray(1)
d376 1
a376 1
      CALL Get_String(lit_indices(instrumentModule),l1bItemName)
d409 2
a410 2
           call Get_String(lit_indices(instrumentModule),l1bItemName)
           l1bItemName = trim(l1bItemName)//'.'//l1bItemsToRead(l1bItem)
d412 1
a412 1
           l1bItemName=l1bItemsToRead(l1bItem)
d523 3
@


2.5
log
@Really removed all references to firstIndexChannel
@
text
@d11 1
a11 1
  use INIT_TABLES_MODULE, only: F_BAND, F_HGRID, &
d15 1
a15 1
    PHYQ_ZETA, F_INSTRUMENTMODULE
d49 1
a49 1
       "$Id: ConstructQuantityTemplates.f90,v 2.4 2001/02/21 01:09:00 livesey Exp $"
d145 3
a147 3
      case ( f_radiometer );        radiometer = sub_rosa(subtree(2,son))
      case ( f_instrumentmodule);   instrumentModule = sub_rosa(subtree(2,son))
      case ( f_band );              band = sub_rosa(subtree(2,son))
d533 3
@


2.4
log
@Allowed for quantities with no h/v grid
@
text
@d49 1
a49 1
       "$Id: ConstructQuantityTemplates.f90,v 2.3 2001/02/20 18:43:50 livesey Exp $"
a77 1
    logical :: FIRSTINDEXCHANNEL
d533 3
@


2.3
log
@Removed all references to firstIndexChannel
@
text
@d19 1
a19 1
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_L1BRead
d49 1
a49 1
       "$Id: ConstructQuantityTemplates.f90,v 2.2 2001/02/14 00:12:45 livesey Exp $"
d86 3
a88 1
    logical :: NEEDVHGRIDS
a159 1
    badUnit = .FALSE.
d163 1
a163 2
      badUnit = family /= PHYQ_Temperature
      needVHGrids=.FALSE.
d166 1
a166 1
      needVHGrids=.TRUE.
d169 1
a169 1
      needVHGrids=.TRUE.
d171 1
a171 2
      badUnit = family /= PHYQ_Zeta
      needVHGrids=.FALSE.
d173 1
a173 2
      needVHGrids=.FALSE.
      badUnit = family /= PHYQ_Temperature
d175 1
a175 2
      needVHGrids=.TRUE.
      badUnit = family /= PHYQ_Temperature
d177 1
a177 2
      needVHGrids=.TRUE.
      badUnit = family /= PHYQ_vmr
d181 3
a183 1
    if ( badUnit ) call announce_error ( root, badUnitMessage )
d185 1
a185 3
    ! Here the code diverges.  In the case where vGrids and hGrids are
    ! required we set them up.  Where they're not we assume it's a
    ! minor frame quantity and work from there.
a186 16
    if ( needVHGrids ) then
      ! This is not a minor frame quantity, set it up from VGrids and HGrids
      if ( (hGridIndex==0) .OR. (vGridIndex==0) ) &
        call announce_error ( root, needGrid )

      call SetupNewQuantityTemplate ( qty, &
        & noInstances=hGrids(hGridIndex)%noProfs, &
        & noSurfs=vGrids(vGridIndex)%noSurfs, &
        & coherent=.TRUE., stacked=.TRUE., regular=.TRUE. )
      ! ??? Note in later versions we'll need to think about channels here

      qty%frequencyCoordinate = L_None
      call CopyHGridInfoIntoQuantity ( hGrids(hGridIndex), qty )
      call CopyVGridInfoIntoQuantity ( vGrids(vGridIndex), qty )

    else
a208 1

d219 41
d419 4
a422 4
        if ( l1bItem>=TransitionToModularItems ) THEN
           CALL Get_String(lit_indices(instrumentModule),l1bItemName)
           l1bItemName = TRIM(l1bItemName)//'.'//l1bItemsToRead(l1bItem)
        ELSE
d424 1
a424 1
        ENDIF
d534 3
@


2.2
log
@Removed firstIndexChannel
@
text
@d11 1
a11 1
  use INIT_TABLES_MODULE, only: F_BAND, F_FIRSTINDEXCHANNEL, F_HGRID, &
d49 1
a49 1
       "$Id: ConstructQuantityTemplates.f90,v 2.1 2001/02/09 00:38:22 livesey Exp $"
a105 1
    firstindexchannel = .FALSE.
a146 1
      case ( f_firstindexchannel ); firstIndexChannel = value == l_true
d231 1
a231 2
        & qty, noChans=noChans, firstIndexChannel=firstIndexChannel,    &
        & mifGeolocation=mifGeolocation )
d284 1
a284 1
    & qty, noChans, regular, instanceLen, firstIndexChannel, mifGeolocation )
a295 1
    logical, intent(in), optional :: firstIndexChannel
d514 3
@


2.1
log
@Various updates
@
text
@d49 1
a49 1
       "$Id: ConstructQuantityTemplates.f90,v 2.0 2000/09/05 18:57:02 ahanzel Exp $"
d343 1
a343 2
        & noChans=noChans,  regular=regular, instanceLen=instanceLen, &
        & firstIndexChannel=firstIndexChannel )
d383 2
a384 2
        & stacked=.FALSE., regular=regular, instanceLen=instanceLen ,&
        & firstIndexChannel=firstIndexChannel, minorFrame=.TRUE. )
d518 3
@


2.0
log
@Changing file revision to 2.0.
@
text
@d15 1
a15 1
    PHYQ_ZETA
d18 1
a18 2
  use MLSCommon, only: L1BInfo_T, MLSChunk_T, MLSInstrumentModuleNames, &
    NameLen, R8
d23 1
a23 2
  use QuantityTemplates, only: FG_NONE, QuantityTemplate_T, &
    & SetupNewQuantityTemplate
d30 2
d49 1
a49 1
       "$Id: ConstructQuantityTemplates.f90,v 1.1 2000/09/02 02:05:03 vsnyder Exp $"
d120 1
d146 1
d204 1
a204 1
      qty%frequencyCoordinate = FG_None
d251 2
a252 1
    qty%radiometerIndex = radiometer
d294 1
a294 1
    integer, intent(in) :: instrumentModule ! THz or GHz?
d326 2
a327 1
    integer :: noMAFs, l1bFlag, l1bItem, mafIndex, mifIndex
d337 3
d342 1
a342 1
        & source=mifGeolocation(instrumentModule), &
d349 1
a349 1
      qty%surfs=>mifGeolocation(instrumentModule)%surfs
d353 9
a361 9
      qty%time =>        MIFGeolocation(instrumentModule)%time
      qty%geodLat =>     MIFGeolocation(instrumentModule)%geodLat
      qty%lon =>         MIFGeolocation(instrumentModule)%lon
      qty%phi =>         MIFGeolocation(instrumentModule)%phi
      qty%solarZenith => MIFGeolocation(instrumentModule)%solarZenith
      qty%solarTime =>   MIFGeolocation(instrumentModule)%solarTime
      qty%losAngle =>    MIFGeolocation(instrumentModule)%losAngle
      qty%MAFCounter =>  MIFGeolocation(instrumentModule)%mafCounter
      qty%mafIndex =>    MIFGeolocation(instrumentModule)%mafIndex
d363 1
a363 1
        & MIFGeolocation(instrumentModule)%noInstancesLowerOverlap
d365 1
a365 1
        & MIFGeolocation(instrumentModule)%noInstancesUpperOverlap
d372 3
a374 2
      l1bItemName = TRIM(MLSInstrumentModuleNames(instrumentModule)) // &
                         "." // "tpGeodAlt"
d404 6
a409 2
        if ( l1bItem>=TransitionToModularItems ) l1bItemName = &
          & MLSInstrumentModuleNames(instrumentModule)//'.'//l1bItemName
d453 1
a453 2
    qty%frequencyCoordinate = FG_None
!   qty%name=MLSInstrumentModuleNames(InstrumentModule)
d519 3
@


1.1
log
@Initial entry
@
text
@d49 1
a49 1
       "$Id: ConstructQuantityTemplates.f90,v 1.1 2000/09/02 02:05:03 vsnyder Exp $"
d508 3
a519 41
!
! Revision 1.12  2000/05/16 20:20:38  livesey
! Another attempt to fix the `time' problem.
!
! Revision 1.11  2000/05/16 19:58:58  livesey
! Added stuff to deal with `time' correctly.
!
! Revision 1.10  2000/05/02 15:58:48  livesey
! Fixed a typo
!
! Revision 1.9  2000/01/20 22:03:13  livesey
! Dealt with replacement of subVectorIndex with mafCounter and mafIndex
!
! Revision 1.8  2000/01/20 01:29:03  livesey
! Replaced storeByChannel with firstIndexChannel, removed stride stuff.
!
! Revision 1.7  2000/01/18 21:34:23  livesey
! Removed reference to obsolete hGrid%profileIndices.
! Other typo fixes.
!
! Revision 1.6  2000/01/18 21:30:57  livesey
! Made sure that noSubVectors(Upper/Lower)Overlap are filled
! appropriately.  This is done right for l2gp and minor frame
! quantities.  More complex quantities may need more thought later.
!
! Revision 1.5  2000/01/18 00:10:29  livesey
! Interim version transfered home.  Need to think more about subVectorIndex
! as it applies to l2aux quantities, and is not used in l2gp.
!
! Revision 1.4  2000/01/12 21:44:05  livesey
! Modified to include the handling of the minorFrame flag.
!
! Revision 1.3  2000/01/11 22:51:34  livesey
! Dealt with ramifications of change from read_parse_l2cf to MLSCF
!
! Revision 1.2  1999/12/18 01:07:00  livesey
! Change vGrids and hGrids from pointer to intent(in)
!
! Revision 1.1  1999/12/18 00:35:40  livesey
! First version
!
@


